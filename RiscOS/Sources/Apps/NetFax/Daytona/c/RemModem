/*
 * RemModem.c - Remote modem (remote fax machine, Daytona or ISP) state machine
 *
 * Author: Ben Laughton
 * History:
 *
 * 1997-07-20: BAL
 * Created.
 *
 * 1997-08-01: MGR
 * Revised.
 *
 * 1997-09-26: SBF
 * Revised further.
 *
 * 1998-02-20: SBF
 * Added PPP timeout code.
 *
 * 1998-03-03: BAL
 * Fixed bugs in PPP timeout code.  If you got unlucky then the PPP connection
 * could succeed, but then timeout just afterwards.  Also, If PPP did timeout
 * it would:
 * a) Try to start the answer script again immediately without trying to hangup
 *    first.
 * b) Not reset the 'poll PPP' flag.
 * c) Get stuck in the 'PPP connecting' state.
 *
 * 1998-03-18: BAL
 * Removed Dialler polling from RemModem_PollStatus due to changes in the way
 * Daytona is informed of Dialler status changes (equivalent now done in
 * TaskModIf).
 *
 * Removed some dead code.
 *
 * 1998-05-06: BAL
 * Changed data hangup script to try to fix problem hanging up after ZModem
 * transfer once and for all.  Put an ATZ at the start of the answer scripts
 * to get modem into a clean state after eg. a ZModem transfer aborted half way
 * through.
 *
 * 1998-05-18: BAL
 * Added hack to RMReInit PPP before calling pppconnect (PAN-01797).
 *
 * 1998-05-21: BAL
 * Corrected recent changes to LED control.  LEDs are on while a call is
 * costing you money.  Also noticed and fixed a bug in the handling of a data
 * answer script failure: was starting the main answer script again before going
 * into state Incoming_RxFinished instead of starting hangup script.
 *
 * 1998-06-03: BAL
 * ISP and ZModem calls were using the same hangup script, so when I changed
 * the script on 1998-05-06 to fix a ZModem related problem I introduced some
 * ISP ones.  They now use different scripts.
 *
 * All calls to start scripts now tell the Dialler not to reset the modem.
 * Sometimes both Daytona and the Dialler were resetting the modem, causing
 * unnecessary delays.  Daytona now takes care of all the resets, which should
 * give us maximum flexibility for the future if eg. we need different reset
 * strategies for different situations.
 *
 * Updated all dialler_monitor_<x>_script calls.  The new version is more
 * readable, more compact and allows you to easily distinguish between completed
 * and failed scripts, even if you're going to end up in the same state for
 * both.
 *
 * Fixed a bug I noticed in Incoming_Data - if received an RX_RM_DIAL_<x> call
 * it would hangup and do the dial instead of sending RM_RM_DIAL_REJECTED.
 *
 * 1998-06-08: BAL
 * Tweaked ISP hangup script to treat any <CR><LF>respose<CR><LF> from +++
 * the same way, instead of just looking for <CR><LF>OK<CR><LF>.  This means
 * that when the modem sends NO CARRIER instead of OK (which it might do if
 * the peer drops the line in time) then the script will still run straight
 * through instead of timing out, saving 5 seconds.
 */



/* =============================================================================
 * Include header files
 */

#include "StdTypes.h"

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "toolbox.h"


#include "sys/types.h"
#include "sys/dcistructs.h"
#include "sys/errno.h"
#include "sys/socket.h"
#include "sys/ioctl.h"

#include "net/if.h"

#include "socklib.h"


#include "PageList.h"
#include "StateKicker.h"
#include "RemModem.h"
#include "RemXfer.h"
#include "Screen.h"
#include "functions.h"
#include "dialler.h"
#include "DiallerIF.h"
#include "DaytonaHW.h"
#include "main.h"
#include "serial.h"
#include "DebugLib.h"



/* =============================================================================
 * Define constants
 */

#define PPP_Connection_Error          0x0100
    /* probably needs formally defining and moving elsewhere? */
#define PPP_Stats                     0x4b606

/* Data connection types (as passed to "AT+FCLASS" modem command */
#define Modem_DataMode                "0"
#define Modem_FaxMode                 "1"
#define Modem_ISPMode                 "2"
    /* Assume data connection until told otherwise! */

#define RM_RM_POLL_PPP                0x667


enum state_RM
{
    Idle,
    Incoming_Data,
    Incoming_RxConnected,
    Incoming_SwitchingOver,
    Incoming_RxFinished,
    Outgoing_Dial,
    Outgoing_Dialling,
    Outgoing_PPPConnecting,
    Outgoing_TxConnected,
    Outgoing_SwitchingOver,
    Outgoing_PPPDisconnecting,
    Outgoing_TxFinished,
    Blocking
};
typedef enum state_RM state_RM;




/* =============================================================================
 * Define macros
 */




/* =============================================================================
 * Define types
 */




/* =============================================================================
 * Declare function prototypes
 */

static _kernel_oserror *idle (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state);

static _kernel_oserror *incoming_data (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state);

static _kernel_oserror *incoming_rx_connected (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state);

static _kernel_oserror *incoming_switching_over (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state);

static _kernel_oserror *incoming_rx_finished (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state);

static _kernel_oserror *outgoing_dial (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state,
                            const char *const            number,
                            const char *const            connection_type);

static _kernel_oserror *outgoing_dialling (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state,
                            const char *const            connection_type);

static _kernel_oserror *outgoing_ppp_connecting (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state);

static _kernel_oserror *outgoing_tx_connected (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state,
                            const char *const            connection_type);

static _kernel_oserror *outgoing_switching_over (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state);

static _kernel_oserror *outgoing_ppp_disconnecting (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state);

static _kernel_oserror *outgoing_tx_finished (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state);

static _kernel_oserror *blocking (
                            const int                    input,
                            messageDataBlock *const      messageData,
                            remoteModemDataBlock *const  remote_modem_data,
                            state_RM *const              state);

static _kernel_oserror *get_ppp_state (int *const  ppp_state);

static _kernel_oserror *RemoteModem_ResetModem (void);

static void RemModem_SendOSError (
                void               (*StateMachine) (
                                       int                 messageNumber,
                                       messageDataBlock *  messagedata),
                const int          messageNumber,
                _kernel_oserror *  error);

static void RemModem_SendRCError (
                void               (*StateMachine) (
                                       int                 messageNumber,
                                       messageDataBlock *  messagedata),
                const int          messageNumber,
                const char * const text,
                const int          rc);


/* =============================================================================
 * Declare global variables
 */

/*extern*/ static int g_reserved;
/*extern*/ remoteModemDataBlock g_remote_modem_data;

static int ppp_poll_status = 0;

static _kernel_oserror g_error[] =
{
    {-1, "Remote modem state machine in unknown state"}
};

enum error_RM
{
    E_BadModemRemState
};
typedef enum error_RM error_RM;

static const char answer_script[] =
    "TIMEOUT 5\n"
    "ABORT 'NO CARRIER'\n"
    "ABORT ERROR\n"
    "ABORT 'NO DIALTONE'\n"
    "ABORT BUSY\n"
    "ABORT 'NO ANSWER'\n"
    "REPORT FAX\n"
    "REPORT DATA\n"
    "\"\" ATZ\n"
    "\\r\\nOK\\r\\n AT+FCLASS=0\n"
    "\\r\\nOK\\r\\n AT%C3L1E0\\\\N3<Dialler$Global><Dialler$Answer>\n"
    "\\r\\nOK\\r\\n AT+FAE=1\n"
    "\\r\\nOK\\r\\n \\c\n"
    "TIMEOUT 0\n" /* @@@@ Need to specify that we want no timeout */
    "\\r\\nRING\\r\\n ATA\n" /* @@ Need to send ATO following a DATA response */
    "TIMEOUT 30\n"
    "\\r\\n \\c\n"
    "\\r\\n \\c\n";
//    "FAX\\r\\n \\c\n";
/*    "\\r\\nCONNECT\\r\\n \\c\n"; */

static const char fax_dial_script[] =
    "TIMEOUT 60\n"
    "ABORT 'NO CARRIER'\n"
    "ABORT ERROR\n"
    "ABORT 'NO DIALTONE'\n"
    "ABORT BUSY\n"
    "ABORT 'NO ANSWER'\n"
    "\"\" ATE0<Dialler$Global><Dialler$Dial$FaxLocal>\n"
    "\\r\\nOK\\r\\n AT+FCLASS=<Fax$Class>\n" /* @@@@ Need to select Class 0 or 1 prior to script execution */
    "\\r\\nOK\\r\\n ATD<Fax$Number>\n"; /* Need to select number prior to script execution */
/*    "\\r\\nCONNECT\\r\\n \\c\n"; */

static const char fax_hangup_script[] =
    "ABORT ERROR\n"
    "TIMEOUT 5\n"
    "\"\" ATH0\n"
    "\\r\\nOK\\r\\n \\c\n";

static const char data_hangup_script[] =
    "ABORT ERROR\n"
    "TIMEOUT 5\n"
    "'NO CARRIER-\\c' ATH0\n"
    "\\r\\nOK\\r\\n \\c\n";

static const char data_dial_script[] =
    "TIMEOUT 60\n"
    "ABORT 'NO CARRIER'\n"
    "ABORT ERROR\n"
    "ABORT 'NO DIALTONE'\n"
    "ABORT BUSY\n"
    "ABORT 'NO ANSWER'\n"
    "\"\" AT+FCLASS=0\n"
    "\\r\\nOK\\r\\n AT%C3L1E0W1\\\\N3<Dialler$Global><Dialler$Dial$DataLocal>\n"
    "\\r\\nOK\\r\\n ATD<Fax$Number>\n" /* Need to select number prior to script execution */
    "\\r\\nCONNECT \\c\n"
    "\\r\\n \\c\n";

static const char data_answer_script[] =
    "TIMEOUT 15\n"
    "ABORT 'NO CARRIER'\n"
    "ABORT ERROR\n"
    "ABORT 'NO DIALTONE'\n"
    "ABORT BUSY\n"
    "ABORT 'NO ANSWER'\n"
    "\"\" AT<Dialler$Global><Dialler$Answer$DataLocal>\n"
    "\\r\\nOK\\r\\n ATO\n"
    "\\r\\nCONNECT \\c\n"
    "\\r\\n \\c\n";

static const char outgoing_switchover_script[] =
    "ABORT 'NO CARRIER'\n"
    "ABORT ERROR\n"
    "ABORT 'NO DIALTONE'\n"
    "ABORT BUSY\n"
    "ABORT 'NO ANSWER'\n"
    "\"\" AT#CLS=8\n"    /* this may not be necessary */
    "\\r\\nOK\\r\\n AT#CLS=0\n"
    "\\r\\nOK\\r\\n AT&K3<Dialler$Global><Dialler$Dial$SwitchOver>\n"    /* to get around bug in Rockwell script (ensure we get RTS/CTS) */
    "\\r\\nOK\\r\\n ATD\n"
    "\\r\\nCONNECT \\c\n"
    "\\r\\n \\c\n";

static const char incoming_switchover_script[] =
    "ABORT 'NO CARRIER'\n"
    "ABORT ERROR\n"
    "ABORT 'NO DIALTONE'\n"
    "ABORT BUSY\n"
    "ABORT 'NO ANSWER'\n"
    "\"\" AT#CLS=8\n"    /* this may not be necessary */
    "\\r\\nOK\\r\\n AT#CLS=0\n"
    "\\r\\nOK\\r\\n AT+FAE=0\n"    /* get out of adaptive answering mode */
    "\\r\\nOK\\r\\n AT&K3<Dialler$Global><Dialler$Answer$SwitchOver>\n"    /* to get around bug in Rockwell script (ensure we get RTS/CTS) */
    "\\r\\nOK\\r\\n ATA\n"
    "\\r\\nCONNECT \\c\n"
    "\\r\\n \\c\n";


static const char isp_dial_script[] =
    "TIMEOUT 5\n"
    "ABORT 'NO CARRIER'\n"
    "ABORT ERROR\n"
    "ABORT 'NO DIALTONE'\n"
    "ABORT BUSY\n"
    "ABORT 'NO ANSWER'\n"
    "\"\" <Dialler$ModemInit><Dialler$Global><Dialler$Dial$ISPLocal>\n"
    "\\r\\nOK\\r\\n ATD<Dialler$Dial$Number>\n"
    "TIMEOUT 60\n"
    "\\r\\nCONNECT \\c\n"
    "<Dialler$Dial$Prompt1> <Dialler$Dial$Response1>\n"
    "<Dialler$Dial$Prompt2> <Dialler$Dial$Response2>\n"
    "<Dialler$Dial$Prompt3> <Dialler$Dial$Response3>\n"
    "<Dialler$Dial$Prompt4> <Dialler$Dial$Response4>\n"
    "<Dialler$Dial$Prompt5> <Dialler$Dial$Response5>\n"
    "CONNECTION_TIMEOUT 0\n";

static const char isp_hangup_script[] =
    "ABORT ERROR\n"
    "TIMEOUT 5\n"
    "\"\" +++\\d\\c\n"
    "\\r\\n \\c\n"
    "\\r\\n-\\c ATH0\n"
    "\\r\\nOK\\r\\n \\c\n";




/* =============================================================================
 * Define functions
 */

/* flash the active light */
void ActiveLight_On(void)
{
    _kernel_swi_regs  r;

    r.r[0] = 0;
    r.r[1] = DaytonaHW_LED_Active;
    r.r[2] = 0;
    r.r[3] = 75;
    r.r[4] = 75;
    _kernel_swi(DaytonaHW_LED, &r, &r);

}

void ActiveLight_Off(void)
{
    _kernel_swi_regs  r;

    r.r[0] = 0;
    r.r[1] = DaytonaHW_LED_Active;
    r.r[2] = 0;
    r.r[3] = 0;
    r.r[4] = 0;
    _kernel_swi(DaytonaHW_LED, &r, &r);
}

/* -----------------------------------------------------------------------------
+
-
 */

extern void RemModem_StateMachine (const int messageNumber, messageDataBlock *messageData)
{
    static state_RM state = Idle;
    static char stash_number[30];
    static char stash_connection_type[2];
    _kernel_oserror *e = NULL;
    remoteModemDataBlock *remote_modem_data = &g_remote_modem_data; /* @@ If it's global, why pass it? */

    /* Print state machine status */
    dprintf((NULL, "RemModem_StateMachine (entry): State => %d; Message => 0x%X\n", state, messageNumber));

    switch (state)
    {
        case Idle:
            e = idle (messageNumber, messageData, remote_modem_data, &state);
#if 1
            switch(messageNumber)
            {
                /* if message is RX_RM_DIAL_xxx, stash number and connection type away for later use */
                case RX_RM_DIAL_FAX:
                    strcpy(stash_number, messageData->data.dial.number);
                    strcpy(stash_connection_type, Modem_FaxMode);
                    break;

                case RX_RM_DIAL_DAYTONA:
                    strcpy(stash_number, messageData->data.dial.number);
                    strcpy(stash_connection_type, Modem_DataMode);
                    break;

                case RX_RM_DIAL_ISP:
                    strcpy(stash_number, messageData->data.dial.number);
                    strcpy(stash_connection_type, Modem_ISPMode);
                    break;
            }
#endif
            break;

        case Incoming_Data:
            e = incoming_data (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Incoming_RxConnected:
            e = incoming_rx_connected (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Incoming_SwitchingOver:
            e = incoming_switching_over (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Incoming_RxFinished:
            e = incoming_rx_finished (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Outgoing_Dial:
            e = outgoing_dial (messageNumber, messageData, remote_modem_data, &state, stash_number, stash_connection_type);
            break;

        case Outgoing_Dialling:
            e = outgoing_dialling (messageNumber, messageData, remote_modem_data, &state, stash_connection_type);
            break;

        case Outgoing_PPPConnecting:
            e = outgoing_ppp_connecting (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Outgoing_TxConnected:
            e = outgoing_tx_connected (messageNumber, messageData, remote_modem_data, &state, stash_connection_type);
            break;

        case Outgoing_SwitchingOver:
            e = outgoing_switching_over (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Outgoing_PPPDisconnecting:
            e = outgoing_ppp_disconnecting (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Outgoing_TxFinished:
            e = outgoing_tx_finished (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Blocking:
            e = blocking (messageNumber, messageData, remote_modem_data, &state);
            break;

        default:
            e = &g_error[E_BadModemRemState];
            break;
    }

    /* Print state machine status on exit */
    dprintf((NULL, "RemModem_StateMachine (exit): Next state => %d\n", state));

    if (e != NULL) /* Oops, _kernel_oserror error; report, reset modem, and go idle */
    {
        dprintf ((NULL, "RemModem_StateMachine error: %s\n", e->errmess));

        RemModem_SendOSError(RemXfer_StateMachine, RM_RX_ERROR, e);

        /* BAL: the assumption below is not valid */
        (void) RemoteModem_ResetModem ();

        state = Idle;
    }
}




static _kernel_oserror *idle (const int input,
                              messageDataBlock *const messageData,
                              remoteModemDataBlock *const remote_modem_data,
                              state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
       case RX_RM_QUERY_IDLE:
           StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_AM_IDLE, NULL);
           *state = Idle;
           break;

       case DI_RM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            /* probably want to turn dialler failed state into an error state */
            /* setup for new state */
            switch (dialler_monitor_answer_script (messageData->data.dialler.status))
            {
                case DiallerIF_ScriptCompleted:
                    *state = Incoming_RxConnected;
/* @@@@ No blocking is implemented for the time being
                    if (g_reserved)
                        *state = Blocking; /@ Refuse to accept call: short of memory
                                              and line needed to send fax being scanned @/
                    else
*/
                    {                      /* Accept call: enough memory */
                        char conntype[256];

                        StateKicker_SendMessage(Screen_StateMachine, RM_SC_INCOMING, NULL); /* show incoming call animation */

                        /* @@ Find out type of connection -- use REPORT FAX and REPORT DATA in script?*/
                        _swix (Dialler_Status, _INR (0, 2),

                               2,
                               conntype,
                               250); /* @@ Does this call put in a terminating NUL? */
                                                 /* @@ Even if buffer too small? */
                                                 /* @@ Does R2 on input include the terminator? */
                        dprintf((NULL, "Connection established: Type = '%s'\n", conntype));
                        ActiveLight_On();

                        if (strcmp (conntype, "FAX") == 0)
                        {
                            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_INCOMING_FAX, NULL);
                        }
                        else if (strcmp (conntype, "DATA") == 0)
                        {
                            e = dialler_start_answer_script (0,    /* don't force modem reset before starting script */
                                                             data_answer_script,
                                                             data_hangup_script,
                                                             remote_modem_data->serial_input_stream,
                                                             remote_modem_data->serial_output_stream);
                            if (e == NULL)
                            {
                                *state = Incoming_Data;
                            }
                        }
                        else
                        {
                            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_INCOMING_VOICE, NULL);
                        }
                    }
                    break;

                case DiallerIF_ScriptFailed:
                    /* Reset modem and attempt to restart script */
                    (void) RemoteModem_ResetModem ();
                    e = dialler_start_answer_script (
                            0,    /* don't reset modem before executing script */
                            answer_script,
                            fax_hangup_script,
                            remote_modem_data->serial_input_stream,
                            remote_modem_data->serial_output_stream);
                    *state = Idle;
                    break;

                default:    /* script still executing */
                    *state = Idle;
                    break;
            }
            break;

        case RX_RM_HANGUP:
            /* Idle already, but RemXfer must be sent GOING_IDLE */
            StateKicker_SendMessage(RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL);
            /* we haven't sent RM_SC_INCOMING, so don't send RM_SC_INCOMING_COMPLETE */
            *state = Idle;         /* Already idle */
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            e = dialler_start_hangup_script ();
            *state = Outgoing_Dial; /*@@ Must be careful not to leave script running if error */
            break;

        default:
            /* Ignore other inputs */
            break;
    }

    return e;
}




static _kernel_oserror *incoming_data (const int input,
                                       messageDataBlock *const messageData,
                                       remoteModemDataBlock *const remote_modem_data,
                                       state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
       case DI_RM_STATUS_CHANGED:
           switch (dialler_monitor_answer_script (messageData->data.dialler.status))
           {
               case DiallerIF_ScriptCompleted:
                   *state = Incoming_RxConnected;
                   StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_INCOMING_DAYTONA, NULL);
                   break;

               case DiallerIF_ScriptFailed:
                   e = dialler_start_hangup_script ();

                   StateKicker_SendMessage(Screen_StateMachine, RM_SC_INCOMING_COMPLETE, NULL); /* terminate incoming call animation */
                   *state = Incoming_RxFinished;
                   break;

               default:    /* script still executing */
                   *state = Incoming_Data;
                   break;
           }
           break;

        case RX_RM_HANGUP:
            e = dialler_start_hangup_script ();
            StateKicker_SendMessage(Screen_StateMachine, RM_SC_INCOMING_COMPLETE, NULL);    /* terminate incoming call animation */
            *state = Incoming_RxFinished;
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_DIAL_REJECTED, NULL);
            *state = Incoming_Data;
            break;

        default:
            /* Ignore other inputs */
            break;
    }

    if (e) dprintf((NULL,"Error (incoming data): '%s'\n", e->errmess));
    return e;
}




static _kernel_oserror *incoming_rx_connected (const int input,
                                               messageDataBlock *const messageData,
                                               remoteModemDataBlock *const remote_modem_data,
                                               state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case RX_RM_DO_SWITCHOVER:
            (void)Serial_Set_Baudrate(REMMODEM, 115200);
            e = dialler_start_answer_script (0,    /* don't reset modem before executing script */
                                             incoming_switchover_script,
                                             data_hangup_script,
                                             remote_modem_data->serial_input_stream,
                                             remote_modem_data->serial_output_stream);
            *state = Incoming_SwitchingOver;
            break;

        case RX_RM_HANGUP:
            e = dialler_start_hangup_script ();
            StateKicker_SendMessage(Screen_StateMachine, RM_SC_INCOMING_COMPLETE, NULL);    /* terminate incoming call animation */
            *state = Incoming_RxFinished; /*@@ Must be careful not to leave script running if error */
            /*RCM says: RM_RX_GOING_IDLE will be issued by Incoming_RxFinished*/
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            *state = Incoming_RxConnected;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_DIAL_REJECTED, NULL);
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *incoming_switching_over (const int input,
                                                 messageDataBlock *const messageData,
                                                 remoteModemDataBlock *const remote_modem_data,
                                                 state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case DI_RM_STATUS_CHANGED:
        {
            switch (dialler_monitor_answer_script (messageData->data.dialler.status))
            {
                case DiallerIF_ScriptCompleted:
                    StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_SWITCHOVER_DONE, NULL);
                    *state = Incoming_RxConnected;
                    break;

                case DiallerIF_ScriptFailed:
                    RemModem_SendRCError(RemXfer_StateMachine, RM_RX_ERROR, "Remote modem: Script failed (1)", (messageData->data.dialler.status & 0xFF));
                    *state = Incoming_RxConnected;
                    /*>>>Will be sent back RX_RM_HANGUP in response???*/
                    break;

                default:     /* script still executing */
                    *state = Incoming_SwitchingOver;
                    break;
            }
            break;
        }

        default:
            break;
    }

    return e;
}




static _kernel_oserror *incoming_rx_finished (const int input,
                                              messageDataBlock *const messageData,
                                              remoteModemDataBlock *const remote_modem_data,
                                              state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case DI_RM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            /* @@ probably want to turn dialler failed state into an error state */
            /* setup for new state */
            switch (dialler_monitor_hangup_script (messageData->data.dialler.status))
            {
                case DiallerIF_ScriptCompleted:
                case DiallerIF_ScriptFailed:
                    ActiveLight_Off ();
                    e = RemoteModem_ResetModem ();
                    e = dialler_start_answer_script (0,    /* don't reset modem before executing script */
                                                     answer_script,
                                                     fax_hangup_script,
                                                     remote_modem_data->serial_input_stream,
                                                     remote_modem_data->serial_output_stream);

                    StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL);
                    *state = Idle;
                    break;

                default:    /* script still executing */
                    *state = Incoming_RxFinished;
                    break;
            }
            break;

        case RX_RM_HANGUP:
            *state = Incoming_RxFinished; /* Already doing hangup */
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            *state = Incoming_RxFinished;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_DIAL_REJECTED, NULL);
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_dial (const int input,
                                       messageDataBlock *const messageData,
                                       remoteModemDataBlock *const remote_modem_data,
                                       state_RM *const state,
                                       const char *const number,
                                       const char *const connection_type)
{
    _kernel_oserror *e = NULL;
    const char *dial_script = NULL;    /* dial script to utilise */
    const char *hangup_script = NULL;    /* hangup script to utilise */

    switch (input)
    {
        case DI_RM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            /* probably want to turn dialler failed state into an error state */
            /* setup for new state */
            switch (dialler_monitor_hangup_script (messageData->data.dialler.status))
            {
                case DiallerIF_ScriptCompleted:
                    *state = Outgoing_Dialling;
                    e = RemoteModem_ResetModem ();

                    _swix (OS_SetVarVal, _INR (0, 4), /* Set up number to dial for script */

                           "Fax$Number",
                           number,
                           strlen (number),
                           0,
                           4); /* VarType_LiteralString */

                    _swix (OS_SetVarVal, _INR (0, 4), /* Set up modem class */

                           "Fax$Class",
                           connection_type,
                           strlen (connection_type),
                           0,
                           4); /* VarType_LiteralString */

                    /* Ascertain which dial script to use (depending upon connection type) */
                    if (strcmp(connection_type, Modem_DataMode) == 0)
                    {
                        (void)Serial_Set_Baudrate(REMMODEM, 115200);
                        dial_script = data_dial_script;
                        hangup_script = data_hangup_script;
                    }
                    else if (strcmp(connection_type, Modem_FaxMode) == 0)
                    {
                        (void)Serial_Set_Baudrate(REMMODEM, 19200);
                        dial_script = fax_dial_script;
                        hangup_script = fax_hangup_script;
                    }
                    else if (strcmp(connection_type, Modem_ISPMode) == 0)
                    {
                        /* This tasteful hack is to get round a problem where
                         * PPP would only send one LCP ConfReq and then not
                         * receive or transmit anything else.  It issues a
                         * command called 'PPPKick' to the CLI.  While PPP is
                         * broken this command can be aliased to *RMReInit PPP
                         * in the build; if PPP is ever fixed properly then
                         * this alias can be removed.
                         *
                         * This is not done immediately before the PPPConnect
                         * command because you need to allow callbacks to
                         * happen before PPP is ready for use.
                         */

                        /* NB. I haven't used the 'system' call because
                         * it's possible that Daytona will be in some sort of
                         * ROM some day, and calling system from ROM code
                         * makes things crash.
                         */
                        _swix (OS_CLI,
                               _IN (0),

                               "PPPKick");

                        _swix (OS_SetVarVal, _INR (0, 4), /* Set up number to dial for script */
                               "Dialler$Dial$Number",
                                number,
                                strlen (number),
                                0,
                                4); /* VarType_LiteralString */

                        (void)Serial_Set_Baudrate(REMMODEM, 115200);
                        dial_script = isp_dial_script;
                        hangup_script = isp_hangup_script;
                    }
                    else
                    {
                        dprintf((NULL, "Error: Outgoing dial failed: cannot select appropriate dial script\n"));
                    }

                    if (dial_script)
                    {
                           (void) RemoteModem_ResetModem ();
                           e = dialler_start_dial_script (0,    /* don't reset modem before executing script */
                                                          dial_script,
                                                          hangup_script,
                                                          remote_modem_data->serial_input_stream,
                                                          remote_modem_data->serial_output_stream);
                    }
                    StateKicker_SendMessage (Screen_StateMachine, RM_SC_DIALLING, NULL);
                    break;

                case DiallerIF_ScriptFailed:
                    e = RemoteModem_ResetModem ();
                    e = dialler_start_answer_script (0,    /* don't reset modem before executing script */
                                                     answer_script,
                                                     fax_hangup_script,
                                                     remote_modem_data->serial_input_stream,
                                                     remote_modem_data->serial_output_stream);

                    StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL);
                    *state = Idle;
                    break;

               default:    /* script still executing */
                   *state = Outgoing_Dial;
                   break;
            }
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_dialling (const int input,
                                           messageDataBlock *const messageData,
                                           remoteModemDataBlock *const remote_modem_data,
                                           state_RM *const state,
                                           const char *const connection_type)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case DI_RM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            /* probably want to turn dialler failed state into an error state */
            /* setup for new state */
            switch (dialler_monitor_dial_script (messageData->data.dialler.status))
            {
                case DiallerIF_ScriptCompleted:
                    *state = Outgoing_TxConnected;
                    ActiveLight_On();

                    if (strcmp (connection_type, Modem_ISPMode) == 0)
                    {
                        /* Issue PPP connect command.  PPP gets serial stream handles from Dialler, so
                         * no device name needs to be given to PPP.  Options are taken from InetDBase:PPP.options
                         */
                        {
                            char buffer[256];
                            char command[256];

                            readvarval("Inet$PPPOptions", buffer, sizeof(buffer));
                            sprintf(command, "PPPconnect Serial1: %s", buffer);
                            _swix (OS_CLI, _IN (0), command);
                        }
                        ppp_poll_status = 1;
                        *state = Outgoing_PPPConnecting;
                    }
                    else
                    {
                        StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_TXCONNECTED, NULL);
                    }
                    break;

                case DiallerIF_ScriptFailed:
                    /* Report dialler status (contains failure type in byte 0) */
                    RemModem_SendRCError(RemXfer_StateMachine, RM_RX_ERROR, "Remote modem: Dial failed", (messageData->data.dialler.status & 0xFF));

                    e = RemoteModem_ResetModem ();
                    e = dialler_start_answer_script (0,    /* don't reset modem before executing script */
                                                     answer_script,
                                                     fax_hangup_script,
                                                     remote_modem_data->serial_input_stream,
                                                     remote_modem_data->serial_output_stream);

                    StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL);
                    StateKicker_SendMessage (Screen_StateMachine, RM_SC_DIAL_COMPLETE, NULL);
                    *state = Idle;
                    break;

                default:    /* script still executing */
                    *state = Outgoing_Dialling;
                    break;
            }
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_ppp_connecting (const int input,
                                                 messageDataBlock *const messageData,
                                                 remoteModemDataBlock *const remote_modem_data,
                                                 state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case RM_RM_POLL_PPP:
        {
            int         ppp_state;
            static int  timeout_set = 0;
            static int  ppp_timeout = 0;

            if (!timeout_set)
            {
              /* Calculate time delay before PPP timeout */
              ppp_timeout = clock() + (readvareval("Inet$PPPConnectTimeout") * 100); /* Timeout converted to centiseconds */
              timeout_set = 1; /* set timeout flag */
            }

            /* Check to see if PPP connection is established */
            e = get_ppp_state (&ppp_state);
            if (e == NULL && ppp_state == 1)
            {
                /* PPP connection established */

                timeout_set = 0; /* reset timeout flag for next time */
                ppp_poll_status = 0;
                StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_TXCONNECTED, NULL);

                *state = Outgoing_TxConnected;
            }
            else if (clock() > ppp_timeout)
            {
                /* PPP connection timedout */

                /* Reset timeout flag */
                timeout_set = 0;
                ppp_poll_status = 0;

                /* Although PPP has timedout we are still connected */
                e = dialler_start_hangup_script ();

                /* Report error */
                RemModem_SendRCError(RemXfer_StateMachine, RM_RX_ERROR, "PPP connection timed out", PPP_Connection_Error);

                *state = Outgoing_TxFinished;
            }
            else
            {
                /* PPP in process of connecting */

                *state = Outgoing_PPPConnecting;
            }
            break;
        }

        default:
            *state = Outgoing_PPPConnecting;
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_tx_connected (const int input,
                                               messageDataBlock *const messageData,
                                               remoteModemDataBlock *const remote_modem_data,
                                               state_RM *const state,
                                               const char *const connection_type)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case RX_RM_DO_SWITCHOVER:
            (void)Serial_Set_Baudrate(REMMODEM, 115200);
            e = dialler_start_dial_script (0,    /* don't reset modem before executing script */
                                           outgoing_switchover_script,
                                           data_hangup_script,
                                           remote_modem_data->serial_input_stream,
                                           remote_modem_data->serial_output_stream);
            *state = Outgoing_SwitchingOver;
            break;

        case RX_RM_HANGUP:
            if (strcmp (connection_type, Modem_ISPMode) == 0)
            {
                _swix (OS_CLI, _IN (0), "pppdisconnect");
                ppp_poll_status = 1;
                *state = Outgoing_PPPDisconnecting;
            }
            else
            {
                e = dialler_start_hangup_script ();
                *state = Outgoing_TxFinished; /*@@ Must be careful not to leave script running if error */
            }
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            *state = Outgoing_TxConnected;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_DIAL_REJECTED, NULL);
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_switching_over (const int input,
                                                 messageDataBlock *const messageData,
                                                 remoteModemDataBlock *const remote_modem_data,
                                                 state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case DI_RM_STATUS_CHANGED:
        {
            switch (dialler_monitor_dial_script (messageData->data.dialler.status))
            {
                case DiallerIF_ScriptCompleted:
                    StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_SWITCHOVER_DONE, NULL);
                    *state = Outgoing_TxConnected;
                    break;

                case DiallerIF_ScriptFailed:
                    RemModem_SendRCError(RemXfer_StateMachine, RM_RX_ERROR, "Remote modem: Script failed (2)", (messageData->data.dialler.status & 0xFF));
                    *state = Outgoing_TxConnected;
                    /*>>>Will be sent back RX_RM_HANGUP in response???*/
                    break;

                default:    /* script still executing */
                    *state = Outgoing_SwitchingOver;
                    break;
            }
            break;
        }

        default:
            break;
    }

    return e;
}





static _kernel_oserror *outgoing_ppp_disconnecting (const int input,
                                                    messageDataBlock *const messageData,
                                                    remoteModemDataBlock *const remote_modem_data,
                                                    state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case RM_RM_POLL_PPP:
        {
            struct stats ppp_stats;

            e = _swix (PPP_Stats, _INR (0, 2), 0x1, 0, &ppp_stats);
            if (e == NULL && (ppp_stats.st_link_status & ST_STATUS_ACTIVE) == 0)
            {
                /* PPP is inactive */
                ppp_poll_status = 0;
                e = dialler_start_hangup_script ();
                *state = Outgoing_TxFinished; /*@@ Must be careful not to leave script running if error */
            }
            break;
        }

        default:
            *state = Outgoing_PPPDisconnecting;
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_tx_finished (const int input,
                                              messageDataBlock *const messageData,
                                              remoteModemDataBlock *const remote_modem_data,
                                              state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case DI_RM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            /* @@ probably want to turn dialler failed state into an error state */
            /* setup for new state */
            switch (dialler_monitor_hangup_script (messageData->data.dialler.status))
            {
                case DiallerIF_ScriptCompleted:
                case DiallerIF_ScriptFailed:
                    *state = Idle;
                    e = RemoteModem_ResetModem ();
                    e = dialler_start_answer_script (0,    /* don't reset modem before executing script */
                                                     answer_script,
                                                     fax_hangup_script,
                                                     remote_modem_data->serial_input_stream,
                                                     remote_modem_data->serial_output_stream);

                    ActiveLight_Off();
                    StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL);
                    StateKicker_SendMessage (Screen_StateMachine, RM_SC_DIAL_COMPLETE, NULL);
                    break;

                default:    /* script still executing */
                    *state = Outgoing_TxFinished;
                    break;
            }
            break;

        case RX_RM_HANGUP:
            *state = Outgoing_TxFinished; /* Already doing hangup */
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            *state = Outgoing_TxFinished;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_DIAL_REJECTED, NULL);
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *blocking (const int input,
                          messageDataBlock *const messageData,
                                  remoteModemDataBlock *const remote_modem_data,
                                  state_RM *const state)
{
/* @@@@ Blocking is TBD */
    _kernel_oserror *e = NULL;

    /* special case: check reserved flag first */
    if (g_reserved == FALSE)
    {
        *state = Idle;
        StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL);
        return NULL; /* @@@@ Erm, but the kick will be missed then, no? */
    }

    switch (input)
    {
        case RX_RM_HANGUP:
            *state = Blocking; /* Would be idle if someone wasn't calling us */
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            *state = Blocking; /* Can't dial because someone is calling us */
            break;

        default:
            break;
    }

    return e;
}




extern _kernel_oserror *RemModem_Initialise (void)
{
    _kernel_oserror *e;
    remoteModemDataBlock *const remote_modem_data = &g_remote_modem_data;

    g_remote_modem_data.serial_input_buffer = Modem[REMMODEM].BufferIn;
    g_remote_modem_data.serial_output_buffer = Modem[REMMODEM].BufferOut;
    g_remote_modem_data.serial_input_stream = Modem[REMMODEM].FileIn;
    g_remote_modem_data.serial_output_stream = Modem[REMMODEM].FileOut;

    (void) RemoteModem_ResetModem ();
    e = dialler_start_answer_script (
            0,    /* don't reset modem before executing script */
            answer_script,
            fax_hangup_script,
            remote_modem_data->serial_input_stream,
            remote_modem_data->serial_output_stream);

    return e;
}




extern void RemModem_Finalise (void)
{
    /* may do something in the future */
}




extern void RemModem_PollStatus(void)
{
    if (ppp_poll_status)
    {
        StateKicker_SendMessage (RemModem_StateMachine,
                                 RM_RM_POLL_PPP,
                                 NULL);

        /* deliver the queued messages */
        while (StateKicker_Deliver() > 1)
            /* null statement */;
    }
}




static _kernel_oserror *get_ppp_state (int *const ppp_state)
{
#if SUPPORT_EMAIL
    int s;
    struct ifreq ifr;

    s = socket (PF_INET, SOCK_RAW, 0);
    if (s == -1)
    {
        return &_inet_error;
    }

    strcpy (ifr.ifr_name, "ppp0");
    if (socketioctl (s, SIOCGIFFLAGS, &ifr) == -1)
    {
        return &_inet_error;
    }

    if (ifr.ifr_ifru.ifru_flags & IFF_UP)
    {
        *ppp_state = 1;
    }
    else
    {
        *ppp_state = 0;
    }

    if (socketclose (s) == -1)
    {
        return &_inet_error;
    }
#endif
    return NULL;
}




static _kernel_oserror *RemoteModem_ResetModem(void)
{
#if 0
    /* Use DTR line which may work */
    return(_swix(DaytonaHW_ResetModem, _INR(0, 1), DaytonaHW_ResetModem_DTR, Modem[REMMODEM].FileOut));
#else
    /* Use hardware reset line - should now work */
    return(_swix(DaytonaHW_ResetModem, _INR (0, 2), DaytonaHW_ResetModem_PIOReg, DaytonaHW_ResetModem_External, Modem[REMMODEM].FileOut));
#endif
}


static void RemModem_SendOSError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), const int messageNumber, _kernel_oserror *error)
{
    StateKicker_SendOSError(StateMachine, messageNumber, code_Dialler_OSError, ctx_Dialler_OSError, error);
}


static void RemModem_SendRCError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), const int messageNumber, const char * const text, const int rc)
{
    errorCode code;
    char buff[256];

    /* append the reason code to the textual message */
    sprintf(buff, "%s (%d)", text, rc);

    /* convert certain selected dialler error codes into our high level codes */
    switch (rc)
    {
        case Dialler_AbortedScript_NoDialtone:
            code = code_NoDialTone;
            break;

        case Dialler_AbortedScript_Busy:
            code = code_LineBusy;
            break;

        case Dialler_AbortedScript_NoAnswer:
            code = code_NoAnswer;
            break;

        case Dialler_AbortedScript_NoCarrier:
            code = code_NoCarrier;
            break;

        case PPP_Connection_Error:
            code = code_PPP_Connection_Error;
            break;

        default:
            code = code_Dialler_RCError;
            break;
    }

    StateKicker_SendRCError(StateMachine, messageNumber, code, ctx_Dialler_RCError, rc, buff);
}


/* end of RemModem.c */
