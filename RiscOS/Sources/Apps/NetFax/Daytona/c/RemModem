/*
 * RemModem.c - Remote modem (remote fax machine, Daytona or ISP) state machine
 *
 * Author: Ben Laughton
 * History: 1997-07-20: BAL: created
 *          1997-08-01: MGR: revised
 *          1997-09-26: SBF: revised further
 */



/* =============================================================================
 * Include header files
 */


#include "StdTypes.h"

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "toolbox.h"


#include "sys/types.h"
#include "sys/dcistructs.h"
#include "sys/errno.h"
#include "sys/socket.h"
/*#include "sys/sockio.h"*/
#include "sys/ioctl.h"

#include "net/if.h"

#include "socklib.h"


#include "StateKicker.h"
#include "RemModem.h"
#include "RemXfer.h"
#include "Screen.h"

#include "Dialler.h"
#include "DaytonaHW.h"
#include "serial.h"
#include "DebugLib.h"



/* =============================================================================
 * Define constants
 */
#define PPP_Stats 0x4b606
#define Dialler_Status                  0x04c6c2

/* Data connection types (as passed to "AT+FCLASS" modem command */
#define Modem_DataMode                  "0"
#define Modem_FaxMode                   "1"
#define Modem_ISPMode           "2"  /* Assume data connection until told otherwise! */

enum state_RM
{
    Idle,
/*     Answered, */
    Incoming_Data,
    Incoming_RxConnected,
    Incoming_SwitchingOver,
    Incoming_RxFinished,
/*     Incoming_StartAnswer, */
    Outgoing_Dial,
    Outgoing_Dialling,
    Outgoing_PPPConnecting,
    Outgoing_TxConnected,
    Outgoing_SwitchingOver,
    Outgoing_PPPDisconnecting,
    Outgoing_TxFinished,
/*     Outgoing_StartAnswer, */
    Blocking
};
typedef enum state_RM state_RM;




/* =============================================================================
 * Define macros
 */




/* =============================================================================
 * Define types
 */




/* =============================================================================
 * Declare function prototypes
 */

static _kernel_oserror *idle (const int input,
                              messageDataBlock *const messageData,
                              remoteModemDataBlock *const remote_modem_data,
                              state_RM *const state);

static _kernel_oserror *incoming_data (const int input,
                                       messageDataBlock *const messageData,
                                       remoteModemDataBlock *const remote_modem_data,
                                       state_RM *const state);

#if 0
static _kernel_oserror *answered (const int input,
                                  messageDataBlock *const messageData,
                                  remoteModemDataBlock *const remote_modem_data,
                                  state_RM *const state);
#endif

static _kernel_oserror *incoming_rx_connected (const int input,
                                               messageDataBlock *const messageData,
                                               remoteModemDataBlock *const remote_modem_data,
                                               state_RM *const state);

static _kernel_oserror *incoming_switching_over (const int input,
                                                 messageDataBlock *const messageData,
                                                 remoteModemDataBlock *const remote_modem_data,
                                                 state_RM *const state);

static _kernel_oserror *incoming_rx_finished (const int input,
                                              messageDataBlock *const messageData,
                                              remoteModemDataBlock *const remote_modem_data,
                                              state_RM *const state);

#if  0
static _kernel_oserror *incoming_start_answer (const int input,
                                               messageDataBlock *const messageData,
                                               remoteModemDataBlock *const remote_modem_data,
                                               state_RM *const state);
#endif

static _kernel_oserror *outgoing_dial (const int input,
                                       messageDataBlock *const messageData,
                                       remoteModemDataBlock *const remote_modem_data,
                                       state_RM *const state,
                                       const char *const number,
                                       const char *const connection_type);

static _kernel_oserror *outgoing_dialling (const int input,
                                           messageDataBlock *const messageData,
                                           remoteModemDataBlock *const remote_modem_data,
                                           state_RM *const state,
                                           const char *const connection_type);

static _kernel_oserror *outgoing_ppp_connecting (const int input,
                                                 messageDataBlock *const messageData,
                                                 remoteModemDataBlock *const remote_modem_data,
                                                 state_RM *const state);

static _kernel_oserror *outgoing_tx_connected (const int input,
                                               messageDataBlock *const messageData,
                                               remoteModemDataBlock *const remote_modem_data,
                                               state_RM *const state,
                                               const char *const connection_type);

static _kernel_oserror *outgoing_switching_over (const int input,
                                                 messageDataBlock *const messageData,
                                                 remoteModemDataBlock *const remote_modem_data,
                                                 state_RM *const state);

static _kernel_oserror *outgoing_ppp_disconnecting (const int input,
                                                    messageDataBlock *const messageData,
                                                    remoteModemDataBlock *const remote_modem_data,
                                                    state_RM *const state);

static _kernel_oserror *outgoing_tx_finished (const int input,
                                              messageDataBlock *const messageData,
                                              remoteModemDataBlock *const remote_modem_data,
                                              state_RM *const state);

#if 0
static _kernel_oserror *outgoing_start_answer (const int input,
                                               messageDataBlock *const messageData,
                                               remoteModemDataBlock *const remote_modem_data,
                                               state_RM *const state);
#endif

static _kernel_oserror *blocking (const int input,
                                  messageDataBlock *const messageData,
                                  remoteModemDataBlock *const remote_modem_data,
                                  state_RM *const state);

static _kernel_oserror *get_ppp_state (int *const ppp_state);

static _kernel_oserror *RemoteModem_ResetModem(void);

static void RemModem_SendOSError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber, _kernel_oserror *error);
static void RemModem_SendRCError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber, const char *text, int rc);


/* =============================================================================
 * Declare global variables
 */

/*extern*/ static int g_reserved;
/*extern*/ remoteModemDataBlock g_remote_modem_data;

static int ppp_poll_status = 0;

static _kernel_oserror g_error[] =
{
    {-1, "Remote modem state machine in unknown state"}
};

enum error_RM
{
    E_BadModemRemState
};
typedef enum error_RM error_RM;

static const char answer_script[] =
    "TIMEOUT 0\n" /* @@@@ Need to specify that we want no timeout */
    "REPORT FAX\n"
    "REPORT DATA\n"
    "\"\" AT+FCLASS=0\n"
    "\\r\\nOK\\r\\n AT%C3L1E0\\\\N3<Dialler$Global><Dialler$Answer>\n"
    "\\r\\nOK\\r\\n AT+FAE=1\n"
    "\\r\\nOK\\r\\n \\c\n"
    "\\r\\nRING\\r\\n ATA\n" /* @@ Need to send ATO following a DATA response */
    "TIMEOUT 30\n"
    "\\r\\n \\c\n"
    "\\r\\n \\c\n";
//    "FAX\\r\\n \\c\n";
/*    "\\r\\nCONNECT\\r\\n \\c\n"; */

static const char fax_dial_script[] =
    "TIMEOUT 60\n"
    "\"\" ATE0<Dialler$Global><Dialler$Dial$FaxLocal>\n"
    "\\r\\nOK\\r\\n AT+FCLASS=<Fax$Class>\n" /* @@@@ Need to select Class 0 or 1 prior to script execution */
    "\\r\\nOK\\r\\n ATD<Fax$Number>\n"; /* Need to select number prior to script execution */
/*    "\\r\\nCONNECT\\r\\n \\c\n"; */

static const char fax_hangup_script[] =
    "\"\" ATH0\n"
    "\\r\\nOK\\r\\n \\c\n";

static const char data_hangup_script[] =
    "\"\" \\d+++\\d\\c\n"
    "\\r\\nOK\\r\\n ATH0\n"
    "\\r\\nOK\\r\\n \\c\n";

static const char data_dial_script[] =
    "TIMEOUT 60\n"
    "\"\" AT+FCLASS=0\n"
    "\\r\\nOK\\r\\n AT%C3L1E0W1\\\\N3<Dialler$Global><Dialler$Dial$DataLocal>\n"
    "\\r\\nOK\\r\\n ATD<Fax$Number>\n" /* Need to select number prior to script execution */
    "\\r\\nCONNECT \\c\n"
    "\\r\\n \\c\n";

static const char data_answer_script[] =
    "TIMEOUT 15\n"
    "ABORT 'NO CARRIER'\n"
    "\"\" AT<Dialler$Global><Dialler$Answer$DataLocal>\n"
    "\\r\\nOK\\r\\n ATO\n"
    "\\r\\nCONNECT \\c\n"
    "\\r\\n \\c\n";

static const char outgoing_switchover_script[] =
    "\"\" AT#CLS=8\n"    /* this may not be necessary */
    "\\r\\nOK\\r\\n AT#CLS=0\n"
    "\\r\\nOK\\r\\n AT&K3<Dialler$Global><Dialler$Dial$SwitchOver>\n"    /* to get around bug in Rockwell script (ensure we get RTS/CTS) */
    "\\r\\nOK\\r\\n ATD\n"
    "\\r\\nCONNECT \\c\n"
    "\\r\\n \\c\n";

static const char incoming_switchover_script[] =
    "\"\" AT#CLS=8\n"    /* this may not be necessary */
    "\\r\\nOK\\r\\n AT#CLS=0\n"
    "\\r\\nOK\\r\\n AT+FAE=0\n"    /* get out of adaptive answering mode */
    "\\r\\nOK\\r\\n AT&K3<Dialler$Global><Dialler$Answer$SwitchOver>\n"    /* to get around bug in Rockwell script (ensure we get RTS/CTS) */
    "\\r\\nOK\\r\\n ATA\n"
    "\\r\\nCONNECT \\c\n"
    "\\r\\n \\c\n";


static const char isp_dial_script[] =
    "TIMEOUT 5\n"
    "\"\" <Dialler$ModemInit><Dialler$Global><Dialler$Dial$ISPLocal>\n"
    "\\r\\nOK\\r\\n ATDT<Dialler$Dial$Number>\n"
    "TIMEOUT 60\n"
    "\\r\\nCONNECT \\c\n"
    "<Dialler$Dial$Prompt1> <Dialler$Dial$Response1>\n"
    "<Dialler$Dial$Prompt2> <Dialler$Dial$Response2>\n"
    "<Dialler$Dial$Prompt3> <Dialler$Dial$Response3>\n"
    "<Dialler$Dial$Prompt4> <Dialler$Dial$Response4>\n"
    "<Dialler$Dial$Prompt5> <Dialler$Dial$Response5>\n"
    "CONNECTION_TIMEOUT 0\n";

static unsigned int last_status = 0;


#define DI_RM_STATUS_CHANGED 0x666
#define RM_RM_POLL_PPP 0x667


/* =============================================================================
 * Define functions
 */
/* flash the active light */
void ActiveLight_On(void)
{
	_kernel_swi_regs  r;

	r.r[0] = 0;
	r.r[1] = DaytonaHW_LED_Active;
	r.r[2] = 0;
	r.r[3] = 75;
	r.r[4] = 75;
    _kernel_swi(DaytonaHW_LED, &r, &r);

}

void ActiveLight_Off(void)
{
	_kernel_swi_regs  r;

	r.r[0] = 0;
	r.r[1] = DaytonaHW_LED_Active;
	r.r[2] = 0;
	r.r[3] = 0;
	r.r[4] = 0;
    _kernel_swi(DaytonaHW_LED, &r, &r);
}

/* -----------------------------------------------------------------------------
+
-
 */

extern void RemModem_StateMachine (const int messageNumber, messageDataBlock *messageData)
{
    static state_RM state = Idle;
    static char stash_number[30];
    static char stash_connection_type[2];
    _kernel_oserror *e = NULL;
    remoteModemDataBlock *remote_modem_data = &g_remote_modem_data; /* @@ If it's global, why pass it? */

    /* Print state machine status */
    dprintf((NULL, "RemModem_StateMachine (entry): State => %d; Message => 0x%X\n", state, messageNumber));

    switch (state)
    {
        case Idle:
            e = idle (messageNumber, messageData, remote_modem_data, &state);
#if 1
            switch(messageNumber)
            {
                /* if message is RX_RM_DIAL_xxx, stash number and connection type away for later use */
                case RX_RM_DIAL_FAX:
                    strcpy(stash_number, messageData->data.dial.number);
                    strcpy(stash_connection_type, Modem_FaxMode);
                    break;

                case RX_RM_DIAL_DAYTONA:
                    strcpy(stash_number, messageData->data.dial.number);
                    strcpy(stash_connection_type, Modem_DataMode);
                    break;

                case RX_RM_DIAL_ISP:
                    strcpy(stash_number, messageData->data.dial.number);
                    strcpy(stash_connection_type, Modem_ISPMode);
                    break;
            }
#endif
            break;

        case Incoming_Data:
            e = incoming_data (messageNumber, messageData, remote_modem_data, &state);
            break;

#if 0
        case Answered:
            e = answered (messageNumber, messageData, remote_modem_data, &state);
            break;
#endif
        case Incoming_RxConnected:
            e = incoming_rx_connected (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Incoming_SwitchingOver:
            e = incoming_switching_over (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Incoming_RxFinished:
            e = incoming_rx_finished (messageNumber, messageData, remote_modem_data, &state);
            break;

#if 0
        case Incoming_StartAnswer:
            e = incoming_start_answer (messageNumber, messageData, remote_modem_data, &state);
            break;
#endif
        case Outgoing_Dial:
#if 1
            e = outgoing_dial (messageNumber, messageData, remote_modem_data, &state, stash_number, stash_connection_type);
#else
            e = outgoing_dial (messageNumber, messageData, remote_modem_data, &state, messageData->data.dial.number);
#endif
            break;

        case Outgoing_Dialling:
            e = outgoing_dialling (messageNumber, messageData, remote_modem_data, &state, stash_connection_type);
            break;

        case Outgoing_PPPConnecting:
            e = outgoing_ppp_connecting (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Outgoing_TxConnected:
            e = outgoing_tx_connected (messageNumber, messageData, remote_modem_data, &state, stash_connection_type);
            break;

        case Outgoing_SwitchingOver:
            e = outgoing_switching_over (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Outgoing_PPPDisconnecting:
            e = outgoing_ppp_disconnecting (messageNumber, messageData, remote_modem_data, &state);
            break;

        case Outgoing_TxFinished:
            e = outgoing_tx_finished (messageNumber, messageData, remote_modem_data, &state);
            break;

#if 0
        case Outgoing_StartAnswer:
            e = outgoing_start_answer (messageNumber, messageData, remote_modem_data, &state);
            break;
#endif
        case Blocking:
            e = blocking (messageNumber, messageData, remote_modem_data, &state);
            break;

        default:
            e = &g_error[E_BadModemRemState];
            break;
    }

    /* Print state machine status on exit */
    dprintf((NULL, "RemModem_StateMachine (exit): Next state => %d\n", state));

    if (e != NULL) /* Oops, _kernel_oserror error; report, reset modem, and go idle */
    {
    	RemModem_SendOSError(RemXfer_StateMachine, RM_RX_ERROR, e);

        /* BAL: the assumption below is not valid */
        (void) RemoteModem_ResetModem ();

        state = Idle;
    }
}




static _kernel_oserror *idle (const int input,
                              messageDataBlock *const messageData,
                              remoteModemDataBlock *const remote_modem_data,
                              state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
       case RX_RM_QUERY_IDLE:
           StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_AM_IDLE, NULL);
           *state = Idle;
           break;

       case DI_RM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            dialler_monitor_answer_script ((int *) state,
                                           messageData->data.dialler.status,
                                           Idle,
                                           Idle,
                                           Incoming_RxConnected);
            /* probably want to turn dialler failed state into an error state */
            /* setup for new state */
            if (*state == Incoming_RxConnected)
            {
/* @@@@ No blocking is implemented for the time being
                if (g_reserved)
                    *state = Blocking; /@ Refuse to accept call: short of memory
                                          and line needed to send fax being scanned @/
                else
*/
                {                      /* Accept call: enough memory */
                    char conntype[256];

					StateKicker_SendMessage(Screen_StateMachine, RM_SC_INCOMING, NULL);	/* show incoming call animation */
					
                    /* @@ Find out type of connection -- use REPORT FAX and REPORT DATA in script?*/
                    _swix (Dialler_Status, _INR (0, 2),

                           2,
                           conntype,
                           250); /* @@ Does this call put in a terminating NUL? */
                                             /* @@ Even if buffer too small? */
                                             /* @@ Does R2 on input include the terminator? */
                    dprintf((NULL, "Connection established: Type = '%s'\n", conntype));
                    ActiveLight_On();

                    if (strcmp (conntype, "FAX") == 0)
                    {
                        StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_INCOMING_FAX, NULL);
                    }
                    else if (strcmp (conntype, "DATA") == 0)
                    {
#if 0 /* Original "ATO" send */
                        Serial_Write_String(REMMODEM, "ATO\r\n"); /* Send "ATO" to modem to resume online connection */
                        /* +++ Should really swallow the "CONNECT" string here!!! +++ */
                        StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_INCOMING_DAYTONA, NULL);
#endif
                        e = dialler_start_answer_script (0,    /* don't force modem reset before starting script */
                                                         data_answer_script,
                                                         data_hangup_script,
                                                         remote_modem_data->serial_input_stream,
                                                         remote_modem_data->serial_output_stream);
                        if (e == NULL)
                            *state = Incoming_Data;
                    }
                    else
                    {
                        StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_INCOMING_VOICE, NULL);
                    }
                }
            }
            break;

        case RX_RM_HANGUP:
        	/* Idle already, but RemXfer must be sent GOING_IDLE */
        	StateKicker_SendMessage(RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL);
        	/* we haven't sent RM_SC_INCOMING, so don't send RM_SC_INCOMING_COMPLETE */ 
            *state = Idle;         /* Already idle */
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            e = dialler_start_hangup_script ();
            *state = Outgoing_Dial; /*@@ Must be careful not to leave script running if error */
            break;

        default:
            /* Ignore other inputs */
            break;
    }

    return e;
}




static _kernel_oserror *incoming_data (const int input,
                                       messageDataBlock *const messageData,
                                       remoteModemDataBlock *const remote_modem_data,
                                       state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
       case DI_RM_STATUS_CHANGED:
           dialler_monitor_answer_script ((int *) state,
                                           messageData->data.dialler.status,
                                           Incoming_Data,
                                           Idle,
                                           Incoming_RxConnected);
           switch (*state)
           {
               case Incoming_RxConnected:
                   StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_INCOMING_DAYTONA, NULL);
                   break;

               case Idle:
                   e = dialler_start_answer_script (1,    /* force modem reset before executing script */
                                                    answer_script,
                                                    fax_hangup_script,
                                                    remote_modem_data->serial_input_stream,
                                                    remote_modem_data->serial_output_stream);
                                                    
			       StateKicker_SendMessage(Screen_StateMachine, RM_SC_INCOMING_COMPLETE, NULL);	/* terminate incoming call animation */
                   /*StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL); RCM says: let Incoming_RxFinished issue this*/
                   ActiveLight_Off();
                   *state = Incoming_RxFinished;
                   break;

               default:
                  break;
           }
           break;

        case RX_RM_HANGUP:
            e = dialler_start_answer_script (1,    /* force modem reset before executing script */
                                             answer_script,
                                             fax_hangup_script,
                                             remote_modem_data->serial_input_stream,
                                             remote_modem_data->serial_output_stream);

			StateKicker_SendMessage(Screen_StateMachine, RM_SC_INCOMING_COMPLETE, NULL);	/* terminate incoming call animation */
            /*StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL); RCM says: let Incoming_RxFinished issue this*/
            ActiveLight_Off();
            *state = Incoming_RxFinished;
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            e = dialler_start_hangup_script ();
            *state = Outgoing_Dial; /*@@ Must be careful not to leave script running if error */
            break;

        default:
            /* Ignore other inputs */
            break;
    }

    if (e) dprintf((NULL,"Error (incoming data): '%s'\n", e->errmess));
    return e;
}




#if 0
static _kernel_oserror *answered (const int input,
                                  messageDataBlock *const messageData,
                                  remoteModemDataBlock *const remote_modem_data,
                                  state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
/* @@ Now bypassed
        case ModemError: /@ @@ where is the appropriate #define? @/
            e = daytonahw_reset_modem (DaytonaHW_Modem_Remote);
            *state = Incoming_StartAnswer;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_INCOMING_FAILED, NULL);
            break;

        case VoiceConnection: /@ @@ where is the appropriate #define? @/
            e = daytonahw_reset_modem (DaytonaHW_Modem_Remote);
            *state = Incoming_StartAnswer;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_INCOMING_VOICE, NULL);
            break;

        case FaxConnection:
            *state = Incoming_RxConnected;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_INCOMING_FAX, NULL);
            break;

        case ZModemConnection:
            *state = Incoming_RxConnected;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_INCOMING_DAYTONA, NULL);
            break;
*/
        default:
            break;
    }

    return e;
}
#endif



static _kernel_oserror *incoming_rx_connected (const int input,
                                               messageDataBlock *const messageData,
                                               remoteModemDataBlock *const remote_modem_data,
                                               state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case RX_RM_DO_SWITCHOVER:
            (void)Serial_Set_Baudrate(REMMODEM, 115200);
            e = dialler_start_answer_script (0,    /* don't reset modem before executing script */
                                             incoming_switchover_script,
                                             data_hangup_script,
                                             remote_modem_data->serial_input_stream,
                                             remote_modem_data->serial_output_stream);
            *state = Incoming_SwitchingOver;
            break;

        case RX_RM_HANGUP:
            e = dialler_start_hangup_script ();
			StateKicker_SendMessage(Screen_StateMachine, RM_SC_INCOMING_COMPLETE, NULL);	/* terminate incoming call animation */            
            ActiveLight_Off();
            *state = Incoming_RxFinished; /*@@ Must be careful not to leave script running if error */
            /*RCM says: RM_RX_GOING_IDLE will be issued by Incoming_RxFinished*/ 
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            *state = Incoming_RxConnected;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_DIAL_REJECTED, NULL);
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *incoming_switching_over (const int input,
                                                 messageDataBlock *const messageData,
                                                 remoteModemDataBlock *const remote_modem_data,
                                                 state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case DI_RM_STATUS_CHANGED:
        {
            enum
            {
                Dialler_ExecutingScript,
                Dialler_ScriptFailed,
                Dialler_ScriptCompleted
            };
            int local_dialler_state;

            dialler_monitor_answer_script (&local_dialler_state,
                                           messageData->data.dialler.status,
                                           Dialler_ExecutingScript,
                                           Dialler_ScriptFailed,
                                           Dialler_ScriptCompleted);
            switch (local_dialler_state)
            {
                case Dialler_ExecutingScript:
                    *state = Incoming_SwitchingOver;
                    break;

                case Dialler_ScriptFailed:
                	{
#if 1
                        RemModem_SendRCError(RemXfer_StateMachine, RM_RX_ERROR, "Remote modem: Script failed (1)", (messageData->data.dialler.status & 0xFF));
#else
                		messageDataBlock *sendMessage;

                    	StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_ERROR, &sendMessage);
                    	sendMessage->data.rm_error.rc = 0;	/*>>>should rc be zero???*/
                    	sendMessage->data.rm_error.err.errnum = 0;	/*>>>should this be 'internal error + rc? */
                    	sprintf(sendMessage->data.rm_error.err.errmess, "Remote modem: Script failed (1)");
#endif
                    	*state = Incoming_RxConnected;
                    	/*>>>Will be sent back RX_RM_HANGUP in response???*/
                    }
                    break;

                case Dialler_ScriptCompleted:
                    StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_SWITCHOVER_DONE, NULL);
                    *state = Incoming_RxConnected;
                    break;

                default:
                    break;
            }
            break;
        }

        default:
            break;
    }

    return e;
}




static _kernel_oserror *incoming_rx_finished (const int input,
                                              messageDataBlock *const messageData,
                                              remoteModemDataBlock *const remote_modem_data,
                                              state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case DI_RM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            dialler_monitor_hangup_script ((int *) state,
                                           messageData->data.dialler.status,
                                           Incoming_RxFinished,
                                           Idle,
                                           Idle);
            /* @@ probably want to turn dialler failed state into an error state */
            /* setup for new state */
            if (*state == Idle) /* @@ Do this for failed+completed, yes? */
            {
                e = RemoteModem_ResetModem ();

                e = dialler_start_answer_script (1,    /* force modem reset before executing script */
                                                 answer_script,
                                                 fax_hangup_script,
                                                 remote_modem_data->serial_input_stream,
                                                 remote_modem_data->serial_output_stream);

                StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL);	/*RCM says: hasn't this already been issued by previous state???*/
            }
            break;

        case RX_RM_HANGUP:
            *state = Incoming_RxFinished; /* Already doing hangup */
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            *state = Incoming_RxFinished;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_DIAL_REJECTED, NULL);
            break;

        default:
            break;
    }

    return e;
}




#if 0
static _kernel_oserror *incoming_start_answer (const int input,
                                               messageDataBlock *const messageData,
                                               remoteModemDataBlock *const remote_modem_data,
                                               state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
/* @@ Now bypassed
        case DI_RM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            dialler_monitor_answer_script ((int *) state,
                                         messageData->data.dialler.status,
                                         Incoming_StartAnswer,
                                         Idle,
                                         Idle);
            /@ probably want to turn dialler failed state into an error state @/
            break;

        case RX_RM_HANGUP:
            *state = Incoming_StartAnswer; /@ Already doing hangup @/
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            *state = Incoming_StartAnswer;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_DIAL_REJECTED, NULL);
            break;
*/
        default:
            break;
    }

    return e;
}
#endif



static _kernel_oserror *outgoing_dial (const int input,
                                       messageDataBlock *const messageData,
                                       remoteModemDataBlock *const remote_modem_data,
                                       state_RM *const state,
                                       const char *const number,
                                       const char *const connection_type)
{
    _kernel_oserror *e = NULL;
    const char *dial_script = NULL;    /* dial script to utilise */
    const char *hangup_script = NULL;    /* hangup script to utilise */

    switch (input)
    {
        case DI_RM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            dialler_monitor_hangup_script ((int *) state,
                                           messageData->data.dialler.status,
                                           Outgoing_Dial,
                                           Idle,
                                           Outgoing_Dialling);

            /* probably want to turn dialler failed state into an error state */
            /* setup for new state */
            if (*state == Outgoing_Dialling)
            {
                e = RemoteModem_ResetModem ();

                _swix (OS_SetVarVal, _INR (0, 4), /* Set up number to dial for script */

                       "Fax$Number",
                       number,
                       strlen (number),
                       0,
                       4); /* VarType_LiteralString */

               _swix (OS_SetVarVal, _INR (0, 4), /* Set up modem class */

                       "Fax$Class",
                       connection_type,
                       strlen (connection_type),
                       0,
                       4); /* VarType_LiteralString */

                /* Ascertain which dial script to use (depending upon connection type) */
                if (strcmp(connection_type, Modem_DataMode) == 0)
                {
                   (void)Serial_Set_Baudrate(REMMODEM, 115200);
                   dial_script = data_dial_script;
                   hangup_script = data_hangup_script;
                }
                else if (strcmp(connection_type, Modem_FaxMode) == 0)
                {
                   (void)Serial_Set_Baudrate(REMMODEM, 19200);
                   dial_script = fax_dial_script;
                   hangup_script = fax_hangup_script;
                }
                else if (strcmp(connection_type, Modem_ISPMode) == 0)
                {
                	_swix (OS_SetVarVal, _INR (0, 4), /* Set up number to dial for script */
                       "Dialler$Dial$Number",
                       number,
                       strlen (number),
                       0,
                       4); /* VarType_LiteralString */

                   (void)Serial_Set_Baudrate(REMMODEM, 115200);
                   dial_script = isp_dial_script;
                   hangup_script = data_hangup_script;
                }
                else
                       dprintf((NULL, "Error: Outgoing dial failed: cannot select appropriate dial script\n"));

                if (dial_script)
                {
                       e = dialler_start_dial_script (1,    /* force modem reset before executing script */
                                                      dial_script,
                                                      hangup_script,
                                                      remote_modem_data->serial_input_stream,
                                                      remote_modem_data->serial_output_stream);
                }
                StateKicker_SendMessage (Screen_StateMachine, RM_SC_DIALLING, NULL);
            }
            else if (*state == Idle)
            {
                e = RemoteModem_ResetModem ();

                e = dialler_start_answer_script (1,    /* force modem reset before executing script */
                                                 answer_script,
                                                 fax_hangup_script,
                                                 remote_modem_data->serial_input_stream,
                                                 remote_modem_data->serial_output_stream);

                StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL);
            }
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_dialling (const int input,
                                           messageDataBlock *const messageData,
                                           remoteModemDataBlock *const remote_modem_data,
                                           state_RM *const state,
                                           const char *const connection_type)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case DI_RM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            dialler_monitor_dial_script ((int *) state,
                                         messageData->data.dialler.status,
                                         Outgoing_Dialling,
                                         Idle,
                                         Outgoing_TxConnected);

            /* probably want to turn dialler failed state into an error state */
            /* setup for new state */
            if (*state == Outgoing_TxConnected)
            {
                if (strcmp (connection_type, Modem_ISPMode) == 0)
                {
                    /* Issue PPP connect command.  PPP gets serial stream handles from Dialler, so
                     * no device name needs to be given to PPP.  Options are taken from InetDBase:PPP.options
                     */
                    {
                      char buffer[256];
                      char command[256];

                      readvarval("Inet$PPPOptions", buffer, sizeof(buffer));
                      sprintf(command, "PPPconnect Serial1: %s", buffer);
                      _swix (OS_CLI, _IN (0), command);
                    }
                    ppp_poll_status = 1;
                    *state = Outgoing_PPPConnecting;
                }
                else
                {
                	ActiveLight_On();
                    StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_TXCONNECTED, NULL);
                }
            }
            else if (*state == Idle)
            {
                /* Report dialler status (contains failure type in byte 0) */
                RemModem_SendRCError(RemXfer_StateMachine, RM_RX_ERROR, "Remote modem: Dial failed", (messageData->data.dialler.status & 0xFF));

                e = RemoteModem_ResetModem ();

                e = dialler_start_answer_script (1,    /* force modem reset before executing script */
                                                 answer_script,
                                                 fax_hangup_script,
                                                 remote_modem_data->serial_input_stream,
                                                 remote_modem_data->serial_output_stream);

                StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL);
                StateKicker_SendMessage (Screen_StateMachine, RM_SC_DIAL_COMPLETE, NULL);
            }
            break;

/*
        case Modem_Timeout: @@ All this goes, yes?
            e = daytonahw_reset_modem (DaytonaHW_Modem_Remote);
            *state = Outgoing_StartAnswer;
            *output = DialFailed_NoAnswer;
            break;

        case Modem_Error:
            e = daytonahw_reset_modem (DaytonaHW_Modem_Remote);
            *state = Outgoing_StartAnswer;
            *output = DialFailed_Error;

        case Modem_Connected:
            *state = Outgoing_TxConnected;
            *output = TxConnected;
*/

        default:
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_ppp_connecting (const int input,
                                                 messageDataBlock *const messageData,
                                                 remoteModemDataBlock *const remote_modem_data,
                                                 state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case RM_RM_POLL_PPP:
        {
            int ppp_state;

            e = get_ppp_state (&ppp_state);
            if (e == NULL && ppp_state == 1)
            {
                /* IP layer is ip */
                ppp_poll_status = 0;
               	ActiveLight_On();
                StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_TXCONNECTED, NULL);
                *state = Outgoing_TxConnected;
            }
            break;
        }

        default:
            *state = Outgoing_PPPConnecting;
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_tx_connected (const int input,
                                               messageDataBlock *const messageData,
                                               remoteModemDataBlock *const remote_modem_data,
                                               state_RM *const state,
                                               const char *const connection_type)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case RX_RM_DO_SWITCHOVER:
            (void)Serial_Set_Baudrate(REMMODEM, 115200);
            e = dialler_start_dial_script (0,    /* don't reset modem before executing script */
                                           outgoing_switchover_script,
                                           data_hangup_script,
                                           remote_modem_data->serial_input_stream,
                                           remote_modem_data->serial_output_stream);
            *state = Outgoing_SwitchingOver;
            break;

        case RX_RM_HANGUP:
            if (strcmp (connection_type, Modem_ISPMode) == 0)
            {
                _swix (OS_CLI, _IN (0), "pppdisconnect");
                ppp_poll_status = 1;
                *state = Outgoing_PPPDisconnecting;
            }
            else
            {
                e = dialler_start_hangup_script ();
                ActiveLight_Off();
                *state = Outgoing_TxFinished; /*@@ Must be careful not to leave script running if error */
            }
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            *state = Outgoing_TxConnected;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_DIAL_REJECTED, NULL);
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_switching_over (const int input,
                                                 messageDataBlock *const messageData,
                                                 remoteModemDataBlock *const remote_modem_data,
                                                 state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case DI_RM_STATUS_CHANGED:
        {
            enum
            {
                Dialler_ExecutingScript,
                Dialler_ScriptFailed,
                Dialler_ScriptCompleted
            };
            int local_dialler_state;

            dialler_monitor_dial_script (&local_dialler_state,
                                         messageData->data.dialler.status,
                                         Dialler_ExecutingScript,
                                         Dialler_ScriptFailed,
                                         Dialler_ScriptCompleted);
            switch (local_dialler_state)
            {
                case Dialler_ExecutingScript:
                    *state = Outgoing_SwitchingOver;
                    break;

                case Dialler_ScriptFailed:
                	{
#if 1
                        RemModem_SendRCError(RemXfer_StateMachine, RM_RX_ERROR, "Remote modem: Script failed (2)", (messageData->data.dialler.status & 0xFF));

#else                	
                		messageDataBlock *sendMessage;

                    	StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_ERROR, &sendMessage);
                    	sendMessage->data.rm_error.rc = 0;	/*>>>should rc be zero???*/
                    	sendMessage->data.rm_error.err.errnum = 0;	/*>>>should this be 'internal error + rc? */
                    	sprintf(sendMessage->data.rm_error.err.errmess, "Remote modem: Script failed (2)");
#endif
                    	*state = Outgoing_TxConnected;
                    	/*>>>Will be sent back RX_RM_HANGUP in response???*/
                    }
                    break;

                case Dialler_ScriptCompleted:
                    StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_SWITCHOVER_DONE, NULL);
                    *state = Outgoing_TxConnected;
                    break;

                default:
                    break;
            }
            break;
        }

        default:
            break;
    }

    return e;
}





static _kernel_oserror *outgoing_ppp_disconnecting (const int input,
                                                    messageDataBlock *const messageData,
                                                    remoteModemDataBlock *const remote_modem_data,
                                                    state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case RM_RM_POLL_PPP:
        {
            struct stats ppp_stats;

            e = _swix (PPP_Stats, _INR (0, 2), 0x1, 0, &ppp_stats);
            if (e == NULL && (ppp_stats.st_link_status & ST_STATUS_ACTIVE) == 0)
            {
                /* PPP is inactive */
                ppp_poll_status = 0;
                ActiveLight_Off();
                e = dialler_start_hangup_script ();
                *state = Outgoing_TxFinished; /*@@ Must be careful not to leave script running if error */
            }
            break;
        }

        default:
            *state = Outgoing_PPPDisconnecting;
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_tx_finished (const int input,
                                              messageDataBlock *const messageData,
                                              remoteModemDataBlock *const remote_modem_data,
                                              state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case DI_RM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            dialler_monitor_hangup_script ((int *) state,
                                         messageData->data.dialler.status,
                                         Outgoing_TxFinished,
                                         Idle,
                                         Idle);
            /* @@ probably want to turn dialler failed state into an error state */
            /* setup for new state */
            if (*state == Idle) /* @@ Do this for failed+completed, yes? */
            {
                e = RemoteModem_ResetModem ();

                e = dialler_start_answer_script (1,    /* force modem reset before executing script */
                                                 answer_script,
                                                 fax_hangup_script,
                                                 remote_modem_data->serial_input_stream,
                                                 remote_modem_data->serial_output_stream);

                StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL);
                StateKicker_SendMessage (Screen_StateMachine, RM_SC_DIAL_COMPLETE, NULL);
            }
            break;

        case RX_RM_HANGUP:
            *state = Outgoing_TxFinished; /* Already doing hangup */
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            *state = Outgoing_TxFinished;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_DIAL_REJECTED, NULL);
            break;

        default:
            break;
    }

    return e;
}




#if 0
static _kernel_oserror *outgoing_start_answer (const int input,
                                   messageDataBlock *const messageData,
                                               remoteModemDataBlock *const remote_modem_data,
                                               state_RM *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
#if 0
/* @@ Now bypassed */
        case DI_RM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            e = dialler_start_answer_script (1,    /* force modem reset before executing script */
                                             answer_script,
                                             fax_hangup_script,
                                             remote_modem_data->serial_input_stream,
                                             remote_modem_data->serial_output_stream);
            *state = Idle;
            break;

        case RX_RM_HANGUP:
            *state = Outgoing_StartAnswer; /@ Already doing hangup @/
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            *state = Outgoing_StartAnswer;
            StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_DIAL_REJECTED, NULL);
            break;
#endif
        default:
            break;
    }

    return e;
}
#endif



static _kernel_oserror *blocking (const int input,
                          messageDataBlock *const messageData,
                                  remoteModemDataBlock *const remote_modem_data,
                                  state_RM *const state)
{
/* @@@@ Blocking is TBD */
    _kernel_oserror *e = NULL;

    /* special case: check reserved flag first */
    if (g_reserved == FALSE)
    {
        *state = Idle;
        StateKicker_SendMessage (RemXfer_StateMachine, RM_RX_GOING_IDLE, NULL);
        return NULL; /* @@@@ Erm, but the kick will be missed then, no? */
    }

    switch (input)
    {
/* @@@@
        case Modem_Reset: /@ @@ Huh?  This can't happen here, can it? @/
            execute modem remoyte answer script;
*/

        case RX_RM_HANGUP:
            *state = Blocking; /* Would be idle if someone wasn't calling us */
            break;

        case RX_RM_DIAL_FAX: case RX_RM_DIAL_DAYTONA: case RX_RM_DIAL_ISP:
            *state = Blocking; /* Can't dial because someone is calling us */
            break;

        default:
            break;
    }

    return e;
}




extern _kernel_oserror *RemModem_Initialise (void)
{
    _kernel_oserror *e;
    remoteModemDataBlock *const remote_modem_data = &g_remote_modem_data;

    g_remote_modem_data.serial_input_buffer = Modem[REMMODEM].BufferIn;
    g_remote_modem_data.serial_output_buffer = Modem[REMMODEM].BufferOut;
    g_remote_modem_data.serial_input_stream = Modem[REMMODEM].FileIn;
    g_remote_modem_data.serial_output_stream = Modem[REMMODEM].FileOut;

    e = dialler_start_answer_script (1,    /* force modem reset before executing script */
                                     answer_script,
                                     fax_hangup_script,
                                     remote_modem_data->serial_input_stream,
                                     remote_modem_data->serial_output_stream);

    return e;
}



extern void RemModem_Finalise (void)
{
    /* may do something in the future */
}




extern void RemModem_PollStatus(void)
{
    _kernel_oserror  *error;
    unsigned int current_status;

    if ((error = dialler_status(&current_status)) != NULL)
    {
        /*>>>should this be passed as an error to RemModem?*/
    }
    else
    {
        if (last_status != current_status)
        {
            messageDataBlock *sendMessage;

            StateKicker_SendMessage(RemModem_StateMachine, DI_RM_STATUS_CHANGED, &sendMessage);
            sendMessage->data.dialler.status = current_status;

            last_status = current_status;

                    /* deliver the queued messages */
                        while (StateKicker_Deliver() > 1)
                        /* null statement */;
        }
    }

    if (ppp_poll_status)
    {
        StateKicker_SendMessage (RemModem_StateMachine, RM_RM_POLL_PPP, NULL);

        /* deliver the queued messages */
        while (StateKicker_Deliver() > 1)
            /* null statement */;
    }
}




static _kernel_oserror *get_ppp_state (int *const ppp_state)
{
#if SUPPORT_EMAIL
    int s;
    struct ifreq ifr;

    s = socket (PF_INET, SOCK_RAW, 0);
    if (s == -1) return &_inet_error;

    strcpy (ifr.ifr_name, "ppp0");
    if (socketioctl (s, SIOCGIFFLAGS, &ifr) == -1)
        return &_inet_error;

    if (ifr.ifr_ifru.ifru_flags & IFF_UP)
        *ppp_state = 1;
    else
        *ppp_state = 0;

    if (socketclose (s) == -1)
        return &_inet_error;
#endif
    return NULL;
}




static _kernel_oserror *RemoteModem_ResetModem(void)
{
#if 0
    /* Use DTR line which may work */
    return(_swix(DaytonaHW_ResetModem, _INR(0, 1), DaytonaHW_ResetModem_DTR, Modem[REMMODEM].FileOut));
#else
    /* Use hardware reset line - should now work */
    return(_swix(DaytonaHW_ResetModem, _INR (0, 2), DaytonaHW_ResetModem_PIOReg, DaytonaHW_ResetModem_External, Modem[REMMODEM].FileOut));
#endif
}


static void RemModem_SendOSError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber, _kernel_oserror *error)
{
	messageDataBlock *sendMessage;

    StateKicker_SendMessage(StateMachine, messageNumber, &sendMessage);
    sendMessage->data.rm_error.rc = 0;	/*>>>should this be zero???*/
    sendMessage->data.rm_error.err = *error;	/* MUST copy message block rather than pointer (which will be stale when the message arrives)  */
}


static void RemModem_SendRCError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber, const char *text, int rc)
{
	messageDataBlock *sendMessage;

    /* parcel return code up as error message */
    StateKicker_SendMessage(StateMachine, messageNumber, &sendMessage);
    sendMessage->data.rm_error.rc = rc;
    sendMessage->data.rm_error.err.errnum = 0;	/*>>>should this be 'internal' plus rc???*/
    sprintf(sendMessage->data.rm_error.err.errmess, "%s (%d)", text, rc);
}


/* end of RemModem.c */
