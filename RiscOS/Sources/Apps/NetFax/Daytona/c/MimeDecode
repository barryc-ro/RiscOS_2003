/* File:    mimedecode.c
 * Purpose: Daytona MIME decoding
 * Author:  Ben Laughton
 * History:
 *
 * 1997-10-20: BAL
 * Created from MimeQ.c.
 */




/* =============================================================================
 * Include header files
 */

/* CLib */
#include "kernel.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Daytona */
#include "BuildFlags.h"
#include "NFELib.h"
#include "StateKicker.h"
#include "emailrx.h"
#include "MimeIf.h"
#include "MimeQ.h"
#include "PrintQ.h"
#include "RemXfer.h"
#include "FileOps.h"



/* =============================================================================
 * Define types
 */

typedef enum
{
    MD_IDLE,
    MD_PROCESS_DECODE_HDR_RESULT,
    MD_PROCESS_DECODE_MSG_RESULT,
    MD_DECODE_ENTITY_HDR,
    MD_PROCESS_DECODE_MIME_ENTITY_HDR_RESULT,
    MD_PROCESS_DECODE_MIME_ENTITY_BODY_RESULT
} MD_States;




/* =============================================================================
 * Declare function prototypes
 */

static int write_headers (FILE *                   fp,
                          const NFE_header *const  message_header);




/* =============================================================================
 * Define functions
 */

extern void MimeDecode_StateMachine (int messageNumber,
                                     messageDataBlock *messageData)
{
    static char *document_directory;

    static int number_mime_entities;
    static int mime_entity_index;
    static int page;

    static MD_States state = MD_IDLE;
    MD_States nextstate = state;

    static NFE_LIST mime_list;  /* list of mime entities in message */
    static NFE_MIME mime_entity;
    static NFE_msg_class message_class;
    static NFE_NF_msg_class nf_message_class;

    static NFE_header *message_header;
    static FILE *fp;


    switch (state)
    {
        case MD_IDLE:
            switch (messageNumber)
            {
                case RX_MD_DECODE_HDR:
                    MimeIF_decode_RFC822_hdr (
                        messageData->data.decode_header.raw_header,
                        (NFE_header*)
                            messageData->data.decode_header.message_header,
                        messageData->data.decode_header.size,
                        (BOOL) messageData->data.decode_header.file);

                    nextstate = MD_PROCESS_DECODE_HDR_RESULT;
                    break;

                case RX_MD_DECODE_MSG:
                    /* Store pointer to message header data structure for future
                     * reference.  Assumes that all dynamically allocated data
                     * in the message header remains valid for the lifetime of
                     * this MIME decode session.
                     */
                    message_header = (NFE_header *)
                        messageData->data.decode_message.message_header;

                    document_directory =
                        messageData->data.decode_message.document_directory;

                    page = messageData->data.decode_message.start_page;

                    MimeIF_decode_RFC822_msg (
                        messageData->data.decode_message.filename,
                        &mime_list,
                        messageData->data.decode_message.size);

                    nextstate = MD_PROCESS_DECODE_MSG_RESULT;
                    break;

                default:
                    nextstate = MD_IDLE;
                    break;
            }
            break;


        case MD_PROCESS_DECODE_HDR_RESULT:
            switch (messageNumber)
            {
                case MI_MD_DECODE_RFC822_HDR_ERROR:
                {
                    messageDataBlock *send_message;

                    StateKicker_SendMessage (RemXfer_StateMachine,
                                             MD_RX_DECODE_HDR_ERROR,
                                             &send_message);

                    send_message->data = messageData->data;
                    nextstate = MD_IDLE;
                    break;
                }

                case MI_MD_DECODE_RFC822_HDR_DONE:
                    StateKicker_SendMessage (RemXfer_StateMachine,
                                             MD_RX_DECODE_HDR_DONE,
                                             NULL);
                    nextstate = MD_IDLE;
                    break;
            }
            break;


        case MD_PROCESS_DECODE_MSG_RESULT:
            switch (messageNumber)
            {
                case MI_MD_DECODE_RFC822_MSG_ERROR:
                {
                    messageDataBlock *send_message;

                    StateKicker_SendMessage (RemXfer_StateMachine,
                                             MD_RX_DECODE_MSG_ERROR,
                                             &send_message);

                    send_message->data = messageData->data;
                    nextstate = MD_IDLE;
                    break;
                }

                case MI_MD_DECODE_RFC822_MSG_DONE:
                    if (NFE_LIST_getnum (mime_list, &number_mime_entities) ==
                            NFE_COMPLETED)
                    {
                        if (number_mime_entities > 0)
                        {
                            mime_entity_index = 0;

                            StateKicker_SendMessage (MimeDecode_StateMachine,
                                                     MD_MD_DECODE_ENTITY_HDR,
                                                     NULL);
                            nextstate = MD_DECODE_ENTITY_HDR;
                        }
                        else
                        {
                            messageDataBlock *send_message;

                            /* Finished - no message body */
                            StateKicker_SendMessage (RemXfer_StateMachine,
                                                     MD_RX_DECODE_MSG_DONE,
                                                     &send_message);

                            send_message->data.message_decoded.next_page =
                                page;

                            /* Don't leak memory */
                            mime_list = NFE_LIST_destroy (mime_list);

                            nextstate = MD_IDLE;
                        }
                    }
                    else
                    {
                        StateKicker_SendMessage (RemXfer_StateMachine,
                                                 MD_RX_DECODE_MSG_ERROR,
                                                 NULL);
                        nextstate = MD_IDLE;
                    }
                    break;

                default:
                    nextstate = MD_PROCESS_DECODE_MSG_RESULT;
                    break;
            }
            break;


        case MD_DECODE_ENTITY_HDR:
            switch (messageNumber)
            {
                case MD_MD_DECODE_ENTITY_HDR:
                    mime_entity = NFE_LIST_get (mime_entity_index,
                                                mime_list);

                    if (mime_entity == NULL)
                    {
                        StateKicker_SendMessage (RemXfer_StateMachine,
                                                 MD_RX_DECODE_MSG_ERROR,
                                                 NULL);
                        nextstate = MD_IDLE;
                        break;
                    }

                    MimeIF_decode_MIME_hdr (mime_entity,
                                            &message_class,
                                            &nf_message_class);

                    nextstate = MD_PROCESS_DECODE_MIME_ENTITY_HDR_RESULT;
                    break;

                default:
                    nextstate = MD_DECODE_ENTITY_HDR;
                    break;
            }
            break;


        case MD_PROCESS_DECODE_MIME_ENTITY_HDR_RESULT:
            switch (messageNumber)
            {
                case MI_MD_DECODE_MIME_HDR_ERROR:
                {
                    messageDataBlock *send_message;

                    StateKicker_SendMessage (RemXfer_StateMachine,
                                             MD_RX_DECODE_MSG_ERROR,
                                             &send_message);

                    send_message->data = messageData->data;
                    nextstate = MD_IDLE;
                    break;
                }

                case MI_MD_DECODE_MIME_HDR_DONE:
                    ++mime_entity_index;

                    switch (emailrx_check_supported (message_class,
                                                     nf_message_class))
                    {
                        case EmailSupport_Partial:
                        case EmailSupport_Full:
                        {
                            char page_filename[257];

                            sprintf (page_filename,
                                     "%s.%d",
                                     document_directory,
                                     page);

                            fp = fopen (page_filename, "ab");
                            if (fp == NULL)
                            {
                                StateKicker_SendMessage (RemXfer_StateMachine,
                                                         MD_RX_DECODE_MSG_ERROR,
                                                         NULL);
                                nextstate = MD_IDLE;
                                break;
                            }

                            /* We need to print some header information for
                             * certain types of messages:
                             *
                             * All supported non-netfax messages
                             * The following classes of netfax data:
                             *   RText
                             *   Reports
                             *   Logs
                             *   FaxErrors
                             */
                            if (message_class != NFE_MC_NETFAX_DATA ||
                                (nf_message_class & (NFE_NFMC_RTEXT  |
                                                     NFE_NFMC_REPORT |
                                                     NFE_NFMC_LOG    |
                                                     NFE_NFMC_FAXERROR)))
                            {
                                if (write_headers (fp,
                                                   message_header))
                                {
                                    StateKicker_SendMessage (
                                        RemXfer_StateMachine,
                                        MD_RX_DECODE_MSG_ERROR,
                                        NULL);
                                    nextstate = MD_IDLE;
                                    break;
                                }
                            }

                            MimeIF_decode_MIME_body (mime_entity,
                                                     page_filename,
                                                     fp);

                            StateKicker_SendMessage (RemXfer_StateMachine,
                                                     MD_RX_NEW_PAGE,
                                                     NULL);

                            nextstate =
                                MD_PROCESS_DECODE_MIME_ENTITY_BODY_RESULT;
                            break;
                        }

                        default:
                            /* This entity not supported.  Skip it */
                            if (mime_entity_index < number_mime_entities)
                            {
                                StateKicker_SendMessage (
                                    MimeDecode_StateMachine,
                                    MD_MD_DECODE_ENTITY_HDR,
                                    NULL);

                                nextstate = MD_DECODE_ENTITY_HDR;
                            }
                            else
                            {
                                messageDataBlock *send_message;

                                StateKicker_SendMessage (RemXfer_StateMachine,
                                                         MD_RX_DECODE_MSG_DONE,
                                                         &send_message);

                                send_message->data.message_decoded.next_page =
                                    page;

                                /* Don't leak memory */
                                mime_list = NFE_LIST_destroy (mime_list);

                                nextstate = MD_IDLE;
                            }
                            break;
                    }
                    break;

                default:
                    nextstate = MD_PROCESS_DECODE_MIME_ENTITY_HDR_RESULT;
                    break;
            }
            break;


        case MD_PROCESS_DECODE_MIME_ENTITY_BODY_RESULT:
            fclose (fp);

            switch (messageNumber)
            {
                case MI_MD_DECODE_MIME_BODY_ERROR:
                {
                    messageDataBlock *send_message;

                    StateKicker_SendMessage (RemXfer_StateMachine,
                                             MD_RX_DECODE_MSG_ERROR,
                                             &send_message);

                    send_message->data = messageData->data;
                    nextstate = MD_IDLE;
                    break;
                }

                case MI_MD_DECODE_MIME_BODY_DONE:
                {
                    messageDataBlock *send_message;

                    StateKicker_SendMessage (RemXfer_StateMachine,
                                             MD_RX_PAGE_COMPLETE,
                                             &send_message);

                    /*>>>for now, look specifically for faxes or CAS,
                     * treating everything else as text!!!
                     */
                    send_message->data.md_rx_page_complete.pageType =
                        FILETYPE_TEXT;

                    if (message_class == NFE_MC_NETFAX_DATA)
                    {
                        switch (nf_message_class)
                        {
                            case NFE_NFMC_FAX:
                                send_message->data.md_rx_page_complete.pageType
                                    = FILETYPE_TIFF;
                                break;

                            case NFE_NFMC_CONFIG:
                                send_message->data.md_rx_page_complete.pageType
                                    = FILETYPE_CONFIG;
                                break;
                        }
                    }

                    send_message->data.md_rx_page_complete.pageNum = page;
                    ++page;

                    if (mime_entity_index < number_mime_entities)
                    {
                        StateKicker_SendMessage (MimeDecode_StateMachine,
                                                 MD_MD_DECODE_ENTITY_HDR,
                                                 NULL);

                        nextstate = MD_DECODE_ENTITY_HDR;
                    }
                    else
                    {
                        messageDataBlock *send_message;

                        StateKicker_SendMessage (RemXfer_StateMachine,
                                                 MD_RX_DECODE_MSG_DONE,
                                                 &send_message);

                        send_message->data.message_decoded.next_page = page;

                        /* Don't leak memory */
                        mime_list = NFE_LIST_destroy (mime_list);

                        nextstate = MD_IDLE;
                    }

                    break;
                }

                default:
                    nextstate = MD_PROCESS_DECODE_MIME_ENTITY_BODY_RESULT;
                    break;
            }
            break;

        default:
            /* Error: state machine has entered an undefined state,
             * panic and go back to idle
             */
            nextstate = MD_IDLE;
            break;
    }

    state = nextstate;
}




static int write_headers (FILE *                   fp,
                          const NFE_header *const  message_header)
{
    char         text_time[64];
    char *       full_address;
    struct tm *  component_time;


    if (fputs ("From: ",
               fp) == EOF)
        return 1;

    full_address = emailrx_construct_full_address (&message_header->from,
                                                   0);
    if (full_address == NULL)
        return 1;

    if (fputs (full_address,
               fp) == EOF)
    {
        free (full_address);
        return 1;
    }

    free (full_address);

    if (fputc ('\n',
               fp) == EOF)
        return 1;


    if (fputs ("Subject: ",
               fp) == EOF)
    {
        return 1;
    }

    if (message_header->subject)
    {
        if (fputs (message_header->subject,
                   fp) == EOF)
        {
            return 1;
        }
    }

    if (fputc ('\n',
               fp) == EOF)
    {
        return 1;
    }

    if (fputs ("Date: ",
               fp) == EOF)
    {
        return 1;
    }

    component_time = localtime (&message_header->date);

    strftime (text_time,
              sizeof (text_time),
              "%x %X",
              component_time);

    if (fputs (text_time,
               fp) == EOF)
    {
        return 1;
    }

    if (fputs ("\n\n",
               fp) == EOF)
    {
        return 1;
    }

    return 0;
}
