/*
 * PrintQ.c - Daytona Fax and Email Print Queue 
 *
 * R C Manby
 *
 * Started 22 July 1997
 */


#define RECEIVING 1
#define PRINTING  1
#define TEXT2TIFF 1
#define FILECONVERT 1
#define NEWCODE 0

#include "StdTypes.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "kernel.h"

#include "PageList.h"
#include "StateKicker.h"
#include "LogFileIF.h"
#if PRINTING
#include "LocXfer.h"
#endif
#if RECEIVING
#include "RemXfer.h"
#endif

#include "PrintQ.h"
#include "SendQ.h"
#include "Screen.h"
#if SUPPORT_EMAIL
#include "MimeQ.h"
#endif


#include "FileOps.h"
#include "functions.h"
#include "wimp.h"
#include "wimplib.h"
#if TEXT2TIFF
#include "TextTiffIF.h"
#endif

#include "AddrBookIF.h"
#include "QuStruct.h"
#include "QuCommon.h"

#include "NetFax/NFELib/NFELib.h"
#include "CasIF.h"

#include "DebugLib.h"


/*
enum _BOOL { FALSE = 0, TRUE = 1 };
typedef enum _BOOL BOOL;
*/
enum _HL_RC { OK = 0, Error_MultipleNAN, Error_NoMemory, OS_Error };
typedef enum _HL_RC HL_RC;

struct
{
	PhoneConnection Connection;
}
local_fax = { 0 };


#if FILECONVERT
extern void FileConvert_NextFile(Document document);
static void common_fileconvert(Document document);
extern void FileConvert_StateMachine(int messageNumber, messageDataBlock *messageData);
#endif


static void LogRx_failure(messageDataBlock *messageData);
static void LogRx_new_document(PqRxRoute Source);
static void LogRx_document_error(Document document, messageDataBlock *messageData);
static void LogRx_document_complete(Document document);

static void Log_TxConnecting(/*enum _SendRoute route,*/ PhoneConnection *connection);
static void Log_TxConnectingError(/*enum _SendRoute route,*/ PhoneConnection *connection, messageDataBlock *messageData);
static void Log_TxConnectingFailed(/*enum _SendRoute route,*/ PhoneConnection *connection);
static void Log_TxConnected(/*enum _SendRoute route,*/ PhoneConnection *connection);
static void Log_TxConnectedErrorSendingDoc(/*enum _SendRoute route,*/ PhoneConnection *connection, messageDataBlock *messageData, Document document);
static void Log_TxConnectedError(/*enum _SendRoute route,*/ PhoneConnection *connection, messageDataBlock *messageData);
static void Log_TxSentDocument(/*enum _SendRoute route,*/ PhoneConnection *connection, Document document);

/*static BOOL connection_impossible(enum _SendRoute route, PhoneConnection *connection);*/
static BOOL connection_requested_now(/*enum _SendRoute route,*/ PhoneConnection *connection);

static _kernel_oserror *PrintQ_CreateDocument(Document *p_document, PqRxRoute Source);
static void PrintQ_NextDocument(Document *p_document);
static Document document_from_pid(unsigned int pid);

static BOOL maybe_idle = TRUE;	/* strong hint that the local fax may be idle and hence free for printing to */

enum _rx_States { rxIDLE = 0, rxDIRECTCONNECTED };
enum _tx_States { txIDLE = 0, txCONNECTING, txCONNECTED };

typedef enum _rx_States rx_States;
typedef enum _tx_States tx_States;


/*
 * Action messages from LocXfer and RemXfer
 *
 */
extern void PrintQ_MessageHandler(int messageNumber, messageDataBlock *messageData)
{
	static rx_States rx_state = rxIDLE;
	static tx_States tx_state = txIDLE;
	static Document receive_document = NULL;
    static Document print_document = NULL;

	HL_RC status = OK;

	/* Print message number to debug device */
	dprintf((NULL, "PrintQ_MessageHandler: Message => 0x%X\n", messageNumber));

	switch (messageNumber)
	{
#if RECEIVING
/* receiving */
		case RX_PQ_ERROR:
		case RX_PQ_NEW_DOCUMENT:
		case RX_PQ_DOCUMENT_DETAILS:
		case RX_PQ_NEW_PAGE:
		case RX_PQ_PAGE_COMPLETE:
		case RX_PQ_DOCUMENT_COMPLETE:
			{
				rx_States nextstate = rx_state;

				switch (rx_state)
				{
					case rxIDLE:
						switch (messageNumber)
                        {
							case RX_PQ_ERROR:
#if SUPPORT_UI							
								Screen_ReportError("Title_RX_PQ_ERROR", messageData);
								LogRx_failure(messageData);
#else
								Fax_ReportError(REMOTE_ERROR,"Title_RX_PQ_ERROR", messageData,NULL,NULL);
#endif
								break;
								
							case RX_PQ_NEW_DOCUMENT:
								{
                                    /* only accept incoming call if we have a reasonable amount of memory */
                                    switch (HWM_Check(/*DEFAULT_FAX_SIZE*/))
									{
										case 3:
										case 2:
											status = Error_NoMemory;
											break;

										case 1:
											if (PrintQ_CreateDocument(&receive_document, messageData->data.rx_pq_new_document.Source) != NULL)
												status = OS_Error;
											break;
									}
					
									if (status == OK)
									{
										messageDataBlock *sendMessage;
					
										receive_document->ScanState = ScanRUNNING;	/* in progress */
					
					                    /* tell RemXfer where to put the document (fax/text) */
										StateKicker_SendMessage(RemXfer_StateMachine, PQ_RX_NEW_DOCUMENT_DIR, &sendMessage);
										sendMessage->data.new_document_dir.pid = receive_document->ProcessId;
										strcpy(sendMessage->data.new_document_dir.directory, receive_document->Directory);
					
										StateKicker_SendMessage(Screen_StateMachine, PQ_SC_NEW_DOCUMENT, &sendMessage);
										sendMessage->data.pq_sc_new_document.pid = receive_document->ProcessId;

									    LogRx_new_document(messageData->data.rx_pq_new_document.Source);

										nextstate = rxDIRECTCONNECTED;
									}
									else
										StateKicker_SendMessage(RemXfer_StateMachine, PQ_RX_ABORT_INCOMING, NULL);
								}
								break;
                        }
                        break;

					case rxDIRECTCONNECTED:
						switch (messageNumber)
                        {
							case RX_PQ_ERROR:
#if SUPPORT_UI							
								Screen_ReportError("Title_RX_PQ_ERROR", messageData);
								LogRx_document_error(receive_document, messageData);
#else
								Fax_ReportError(REMOTE_ERROR,"Title_RX_PQ_ERROR", messageData,NULL,NULL);
#endif
								break;
#if /*THINK*/ 0
                            case RX_PQ_MAYBE_VOICE:
                            	break;
#endif
							case RX_PQ_NEW_DOCUMENT:
								StateKicker_SendMessage(RemXfer_StateMachine, PQ_RX_ABORT_INCOMING, NULL);
								break;

							case RX_PQ_DOCUMENT_DETAILS:
								{
									messageDataBlock *sendMessage;

									StateKicker_SendMessage(Screen_StateMachine, PQ_SC_DOCUMENT_DETAILS, &sendMessage);
									sendMessage->data.pq_sc_document_details.pid = receive_document->ProcessId;
                                    strcpy(sendMessage->data.pq_sc_document_details.ContactName, receive_document->AddressRecord.ContactName);
								}
								break;

							case RX_PQ_NEW_PAGE:
								{
									/*>>>Trigger page <n> animation*/
									StateKicker_SendMessage(Screen_StateMachine, PQ_SC_NEW_PAGE, NULL);
					
									switch (HWM_Check())					/* returns 1/2/3 OK/Trigger-send/Abort-Rx */
									{
										case 3:
											StateKicker_SendMessage(RemXfer_StateMachine, PQ_RX_ABORT_INCOMING, NULL);
											/* drop into... */
										case 2:
											receive_document->RequestTx = 1;	/* requesting (or in progress) */
										case 1:
											break;
									}
								}
								break;
					
							case RX_PQ_PAGE_COMPLETE:
								{
                                    messageDataBlock *sendMessage;
#if 1
                                    if (messageData->data.rx_pq_page_complete.pageClass == PageClass_SendReceipt)
                                    {
                                        char filename[256];

                                        /* don't count this page! */
                                        
                                        strcpy(filename, receive_document->Directory);
                                        strcat(filename, ".Receipt");

                                        set_filetypeDN(receive_document->Directory, messageData->data.rx_pq_page_complete.pageNum, FILETYPE_TEXT);
                                        renameDNDL(receive_document->Directory, messageData->data.rx_pq_page_complete.pageNum, receive_document->Directory, "Receipt");

                                        receive_document->SendReceipt = TRUE;   /* sent to ReceiptAddress */
                                    }
                                    else
#endif
#if 1
									if (messageData->data.rx_pq_page_complete.pageClass == PageClass_Config)
									{
										char filename[256];

										/* don't count this page! */

										strcpy(filename, receive_document->Directory);
										strcat(filename, ".CasData");

										set_filetypeDN(receive_document->Directory, messageData->data.rx_pq_page_complete.pageNum, FILETYPE_TEXT);
										renameDNDL(receive_document->Directory, messageData->data.rx_pq_page_complete.pageNum, receive_document->Directory, "CasData");

										CasIF_OfferClass(NFE_NFMC_CONFIG, filename);
									}
									else
#endif
					                QuCommon_Page_Complete(receive_document,
					                                        messageData->data.rx_pq_page_complete.pageNum,
					                                        messageData->data.rx_pq_page_complete.pageClass,
					                                        messageData->data.rx_pq_page_complete.pageType,
					                                        messageData->data.rx_pq_page_complete.fileType
					                                       );
					                             
									switch (HWM_Check())					/* returns 1/2/3 OK/Trigger-send/Abort-Rx */
									{
										case 3:
											StateKicker_SendMessage(RemXfer_StateMachine, PQ_RX_ABORT_INCOMING, NULL);
											/* drop into... */
										case 2:
											receive_document->RequestTx = 1;	/* requesting (or in progress) */
										case 1:
											break;
									}

									/* poke the animations */
									StateKicker_SendMessage(Screen_StateMachine, PQ_SC_PAGE_COMPLETE, &sendMessage);
									sendMessage->data.pq_sc_page_complete.ScanCount = receive_document->ScanCount;
								}
								break;
					
							case RX_PQ_DOCUMENT_COMPLETE:
								{
									messageDataBlock *sendMessage;
									
									/* poke the animations */
									StateKicker_SendMessage(Screen_StateMachine, PQ_SC_DOCUMENT_COMPLETE, &sendMessage);
									sendMessage->data.pq_sc_document_complete.ScanCount = receive_document->ScanCount;

                                    /* log the reception */
                                    LogRx_document_complete(receive_document);

									receive_document->ScanState = ScanCOMPLETE;	/* complete (3) */
									receive_document->RequestTx = 1;			/* requesting */
					
									receive_document = NULL;	/* this handler no longer needs to reference this document */
									nextstate = rxIDLE;
								}
								break;

                        }
						break;
				} /* switch (rx_state) */

#if 0
			    /* report PQ_xx_GOING_IDLE if going idle from a non-idle state */
				if ((nextstate == rxIDLE) && (rx_state != rxIDLE))
					StateKicker_SendMessage(Xxxx_MessageHandler, PQ_xx_GOING_IDLE, NULL);
#endif
				rx_state = nextstate;
			}
			break;
/* end of receiving */
#endif

		case LX_PQ_GOING_IDLE:
			/* a scan or a print has just completed */
			maybe_idle = TRUE;	/* tell queue scanner it may like to try printing */
            /* drop into... */
#if PRINTING
/* printing */
		case LX_PQ_AM_IDLE:
		case LX_PQ_PRINT_REJECTED:
		case LX_PQ_PRINT_FAILED:
		case LX_PQ_ERROR:
		case LX_PQ_WHICH_DOCUMENT:
		case LX_PQ_SENDING_PAGE:
		case LX_PQ_PAGE_SENT:
		case LX_PQ_DOCUMENT_SENT:
			{
				tx_States nextstate = tx_state;
				
				switch (tx_state)
				{
	            	case txIDLE:
	                    switch (messageNumber)
						{
							/* some outside code needs to do StateKicker_SendMessage(LocXfer_StateMachine, PQ_LX_QUERY_IDLE, NULL); */
							/* this we be ignored or cause a reply of LX_PQ_AM_IDLE                                                 */
							case LX_PQ_AM_IDLE:
								{
									/* is there anything to print? - find first (oldest) document requesting a print */
					                PrintQ_NextDocument(&print_document);
					
					                if (print_document)
					                {
					                	messageDataBlock *sendMessage;
					                	
                                        /* tell screen that if it receives LM_SC_PRINTING, its for this document */
                                        StateKicker_SendMessage(Screen_StateMachine, PQ_SC_CONTEXT, &sendMessage);
                                        sendMessage->data.pq_sc_context.pid = print_document->ProcessId;
#if FILECONVERT
										/* ensure at least one (or two?) TIFF files waiting in TX directory before !Fax starts printing */
                                        FileConvert_NextFile(print_document);
#endif
										StateKicker_SendMessage(LocXfer_StateMachine, PQ_LX_PRINT_DOCUMENT, NULL);
										Log_TxConnecting(&local_fax.Connection);
										nextstate = txCONNECTING;
							    	}
							    }
								break;
						}
	                    break;
	
					case txCONNECTING:
	                    switch (messageNumber)
						{
							case LX_PQ_PRINT_REJECTED:	/* not idle (incoming fax) NOT counted as a failed connection attempt */
								nextstate = txIDLE;     /* Don't look for LX_PQ_GOING_IDLE (ignoring the one case where it IS sent) */
								break;

							case LX_PQ_PRINT_FAILED:	/* probably means local fax machine isn't connected */
/*>>>put up unconnected screen*/
								Screen_LocalFax_NotConnected();
							    /* wait for LX_PQ_GOING_IDLE */
								break;

							/* Error: unable to connect for printing */
							case LX_PQ_ERROR:
#if SUPPORT_UI							
								Screen_ReportError("Title_LX_PQ_ERROR", messageData);
#else
								dprintf((NULL,"error directory %s ScanCount %d\n",print_document->Directory,print_document->ScanCount));
								Fax_ReportError(LOCAL_ERROR,"Title_LX_PQ_ERROR", messageData,NULL,NULL);
#endif
								Log_TxConnectingError(&local_fax.Connection, messageData);
								/* wait for LX_PQ_GOING_IDLE */
								break;

							case LX_PQ_GOING_IDLE:
								/* the print (send) has completed - should only happen after LX_PQ_PRINT_FAILED or LX_PQ_ERROR */
								/* count a failed connection, calculate when the next attempt should be */
								Log_TxConnectingFailed(&local_fax.Connection);
								print_document = NULL;	/* not valid after a call to Log_TxConnectingFailed */ 
								nextstate = txIDLE;
								break;
								
							case LX_PQ_WHICH_DOCUMENT:
								{
									messageDataBlock *sendMessage;
					
							    	print_document->SendState = SendRUNNING; 	/* in progress (2) */
							    	print_document->RequestTx = FALSE;          /*>>>try this*/
							    	StateKicker_SendMessage(LocXfer_StateMachine, PQ_LX_THIS_DOCUMENT, &sendMessage);
							    	sendMessage->data.this_document.pid = print_document->ProcessId;
                                    sendMessage->data.this_document.loText = 1; /* } ie we never tell LocXfer about text pages */
                                    sendMessage->data.this_document.hiText = 0; /* }    cos we convert them to TIFF for it */
                                    sendMessage->data.this_document.loPage = print_document->SendCount + 1;
                                    sendMessage->data.this_document.hiPage = print_document->ScanCount;
                                    sendMessage->data.this_document.pageStream = (print_document->ScanState != ScanCOMPLETE);
									strcpy(sendMessage->data.this_document.directory, print_document->Directory);
#if FILECONVERT
									sendMessage->data.this_document.loPage = print_document->tx_loTiff;	/* usually 1 */
									strcat(sendMessage->data.this_document.directory, ".TX");
#endif
									Log_TxConnected(&local_fax.Connection);	/* log successful connection to local fax */

									nextstate = txCONNECTED;
								}
								break;
						}
						break;
	
	                case txCONNECTED:
	                    switch (messageNumber)
						{
							case LX_PQ_SENDING_PAGE:
							    {
							        messageDataBlock *sendMessage;
							        
								    /* poke animation */
								    StateKicker_SendMessage(Screen_StateMachine, PQ_SC_PRINTING_FAX, &sendMessage);
								    sendMessage->data.pq_sc_printing_fax.pid     = print_document->ProcessId;
								    sendMessage->data.pq_sc_printing_fax.sending = print_document->SendCount + 1;
#if FILECONVERT
                                    sendMessage->data.pq_sc_printing_fax.sending = print_document->tx_loTiff;   /* 1.. */

                                    LogFileIF_show_decimal_uint(LOG_DEBUG, "LX_PQ_SENDING_PAGE page", messageData->data.lx_pq_sending_page.page);
                                    LogFileIF_show_decimal_uint(LOG_DEBUG, "              tx_loTiff", print_document->tx_loTiff);

								    /* !Fax has started to send a page, so move/generate another into TX directory */
								    FileConvert_NextFile(print_document);
#endif
                                }
								break;
					
							case LX_PQ_PAGE_SENT:
								{
									messageDataBlock *sendMessage;
#if FILECONVERT
                                    LogFileIF_show_decimal_uint(LOG_DEBUG, "LX_PQ_PAGE_SENT page", messageData->data.lx_pq_page_sent.page);
                                    LogFileIF_show_decimal_uint(LOG_DEBUG, "           tx_loTiff", print_document->tx_loTiff);
                                    
									print_document->tx_loTiff += 1;
#else
									print_document->SendCount += 1;
#if 1
									purge_directory(print_document->Directory, print_document->SendCount, print_document->SendCount);	/* use purge_directory to delete one file! */
#endif
#endif
									/* poke animation */
								    StateKicker_SendMessage(Screen_StateMachine, PQ_SC_PAGE_SENT, &sendMessage);
								    sendMessage->data.pq_sc_page_sent.pid = print_document->ProcessId;
								    sendMessage->data.pq_sc_page_sent.pagesSent = print_document->SendCount;
#if FILECONVERT
                                    sendMessage->data.pq_sc_page_sent.pagesSent = print_document->tx_loTiff - 1;    /* NB tx_loTiff is next page to send */
#endif
	                            }
								break;
					
							case LX_PQ_DOCUMENT_SENT:
								{
								    messageDataBlock *sendMessage;
#if 0    
							    	purge_directory(print_document->Directory, 1, print_document->ScanCount);
#endif
									/* poke animation */
									StateKicker_SendMessage(Screen_StateMachine, PQ_SC_PRINTING_COMPLETE, &sendMessage);
			    					sendMessage->data.pq_sc_document_sent.pid = print_document->ProcessId;
			    					sendMessage->data.pq_sc_document_sent.pagesSent = print_document->SendCount;    /* number of files (tiffs and text) */
#if FILECONVERT
			    					sendMessage->data.pq_sc_document_sent.pagesSent = print_document->tx_loTiff - 1;    /* number of tiffs printed (text expands to 1 or more tiffs) */
#endif
									Log_TxSentDocument(&local_fax.Connection, print_document);	/* log printing of document */

									print_document->SendState = SendCOMPLETE;	/* complete (3) */
									print_document = NULL;	/* this handler no longer needs to reference this document */
                                }
								break;

							/* Error: after connection */
							case LX_PQ_ERROR:
#if SUPPORT_UI							
								Screen_ReportError("Title_LX_PQ_ERROR", messageData);
#else
								dprintf((NULL,"error directory %s ScanCount %d\n",print_document->Directory,print_document->ScanCount));
								Fax_ReportError(LOCAL_ERROR,"Title_LX_PQ_ERROR", messageData,NULL,NULL);
#endif
								if (print_document)
									Log_TxConnectedErrorSendingDoc(&local_fax.Connection, messageData, print_document);
								else
									Log_TxConnectedError(&local_fax.Connection, messageData);
								break;
	
	                    	case LX_PQ_GOING_IDLE:
	                    		/* the print has just completed */
	                    		nextstate = txIDLE;
	                    		break;
						}
	                	break;
				} /* switch (tx_state) */
	
#if 0
			    /* report PQ_xx_GOING_IDLE if going idle from a non-idle state */
				if ((nextstate == txIDLE) && (tx_state != txIDLE))
					StateKicker_SendMessage(Xxxx_MessageHandler, PQ_xx_GOING_IDLE, NULL);
#endif
				tx_state = nextstate;
            }
/* end of printing */
#endif
			break;
	}
}


#if FILECONVERT
extern void FileConvert_NextFile(Document document)
{
	common_fileconvert(document);
}

static void common_fileconvert(Document document)
{
  	_kernel_oserror *error = NULL;
	char src_leafname[32];      /* eg "1" */
    char dst_directory[256];    /* eg "...PrintQ.0.TX" */

	sprintf(src_leafname, "%d", document->SendCount + 1);	/* file to move/tiff-convert */	

    strcpy(dst_directory, document->Directory);
    strcat(dst_directory, ".TX");

	if (document->tx_StartLine == 0)
	{
#if 1
/*        BOOL        error;*/
        PageClasses pageClass;
        PageTypes   pageType;
        int         fileType;
        
        if (QuCommon_GetClassAndType(document, document->SendCount + 1, &pageClass, &pageType, &fileType) == 0)
        {
            if (pageClass == PageClass_TIFF)        
#else
		int objecttype, filelength, filetype;

		/* a new source file, does it exist? and what type is it? */
		error = osfile_ReadCatInfoDL(document->Directory, src_leafname, &objecttype, &filelength, &filetype);
					
		if ((error == NULL) && (objecttype == 1/*file found*/))
		{
			if (filetype == FILETYPE_TIFF)
#endif
			{
				char dst_leafname[32];
					        		
				sprintf(dst_leafname, "%d", document->tx_hiTiff + 1);	 /* destination leafname */
				
				error = renameDLDL(document->Directory, src_leafname, dst_directory, dst_leafname);	/* renameDNDN would be nicer */
				if (error == NULL)
				{
					document->tx_hiTiff += 1;	/* count newly moved file */
					document->SendCount += 1;	/* which no longer exists in source directory */		
				}
			}
			else
			{
				document->tx_StartLine = 1;	/* first line in file */
			/*>>>text_document->LogFile = */
				TextTiffIF_ConvertASCII_To_TIFF(FileConvert_StateMachine, document->ProcessId,
						                        document->Directory, src_leafname,
					                            document->tx_StartLine,
						                        dst_directory, 0	/* tuck away as leafname zero, a name we NEVER give to !Fax */
						                       );
			}
	    }
	    else
	    {
	    	/* not found or error */
	    }
    }
    else
    {
		/* part way through converting an ASCII file, so continue from where we left off */
	    /* startline either still 1 or has been updated by TF_CONVERTED_PAGE */
	/*>>>text_document->LogFile = */
		TextTiffIF_ConvertASCII_To_TIFF(FileConvert_StateMachine, document->ProcessId,
						                document->Directory, src_leafname,
					                    document->tx_StartLine,
						                dst_directory, 0
						               );
    }
}


extern void FileConvert_StateMachine(int messageNumber, messageDataBlock *messageData)
{
	switch (messageNumber)
	{
		case TF_ERROR:
            /*>>>*/
            /* DON'T try the normal error copy tricks, cos this block has a pid in it!*/
			break;

		case TF_CONVERTED_PAGE:
		case TF_NORMAL_TERMINATION:
			{
				Document document = document_from_pid(messageData->data.tf_converted_page.pid);	/* NB Assumes tf_converted_page.pid and tf_normal_termination.pid in same place */
	            if (document)
				{
			    	_kernel_oserror *error = NULL;
				    char dst_directory[256];    /* eg "...PrintQ.0.TX" */
	            	char dst_leafname[32];

				    strcpy(dst_directory, document->Directory);
				    strcat(dst_directory, ".TX");
				    
		            sprintf(dst_leafname, "%d", document->tx_hiTiff + 1);	 /* destination leafname */
	
	                error = renameDLDL(dst_directory, "0", dst_directory, dst_leafname);	/* renameDNDN (or renameDLDN) would be nicer */
					if (error == NULL)
					{
	        			document->tx_hiTiff += 1;	/* count newly created file */
	        			document->tx_StartLine = messageData->data.tf_converted_page.nextstartline;	/* part way through, restart from here */
	
						if (messageNumber == TF_NORMAL_TERMINATION)
						{
							char src_leafname[32];      /* eg "1" */
	
							sprintf(src_leafname, "%d", document->SendCount + 1);	/* file to move/tiff-convert */
	
	                        document->tx_StartLine = 0;
							document->SendCount += 1;	/* which no longer exists in source directory */
							remove_fileDL(document->Directory, src_leafname);	
						}
	        		} 
	        	}
	        }
        	break;
    }
}
#endif


/*
 * The following procedures allow EnoteIF, LogFileIF and SendQ (hardcopy)
 * to add a new document to the PrintQ.
 *
 *  PrintQ_ExtIF_NewDocument      - create a new document
 *  PrintQ_ExtIF_FileComplete     - a page has been added to it
 *  PrintQ_ExtIF_FileTake         - move given page into document
 *  PrintQ_ExtIF_DocumentComplete - ready to print
 */

/*
 * Create a new document.
 *
 * Returns document pid (non-zero) and document directory name on success
 *         zero on failure
 */
extern unsigned int PrintQ_ExtIF_NewDocument(char *p_directory)
{
    Document text_document;
	
	switch (HWM_Check())
	{
		case 3:
		case 2:
		case 1:
			if (PrintQ_CreateDocument(&text_document, PqRxINTERNAL) == NULL)
			{
				strcpy(p_directory, text_document->Directory);
				return(text_document->ProcessId);	/* created a new document and passed directory name to caller */
			}
			break;
	}

	return(0);	/* in-sufficient memory */
}


extern void PrintQ_ExtIF_FileComplete(unsigned int pid, const char *leafname, PageClasses pageClass, PageTypes pageType, int fileType)
{
	Document document;

	if ((document = document_from_pid(pid)) != NULL)
	{
		renameDLN(document->Directory, leafname, document->ScanCount + 1);
		QuCommon_Page_Complete(document, document->ScanCount + 1, pageClass, pageType, fileType);
	}
}


extern void PrintQ_ExtIF_FileTake(unsigned int destination_pid, const char *source_directory, unsigned int source_leafnumber, PageClasses pageClass, PageTypes pageType, int fileType)
{
	Document document;

	if ((document = document_from_pid(destination_pid)) != NULL)
	{
		renameDNDN(source_directory, source_leafnumber, document->Directory, document->ScanCount + 1);
		QuCommon_Page_Complete(document, document->ScanCount + 1, pageClass, pageType, fileType);
	}
}


extern void PrintQ_ExtIF_DocumentComplete(unsigned int pid)
{
	Document text_document;

	if ((text_document = document_from_pid(pid)) != NULL)
	{
		text_document->ScanState = ScanCOMPLETE;
		/*>>>do we set TxRequest???*/
	}
}


/*
 * Accumulate call statistics, for LogFile and error reporting
 */


/*
 * Log a failed incoming call - connection not established
 */
static void LogRx_failure(messageDataBlock *messageData)
{
    char buffer[256];

    strcpy(buffer, "Incoming call: ");
    strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));

    LogFileIF_Message(buffer);  /* we need a global flag to indicate if this is actually an ISP retreive problem */
}


/*
 * Connection established - document created in PrintQ
 */
static int LogRX_error_count = 0;

static void LogRx_new_document(PqRxRoute Source)
{
    LogRX_error_count = 0;
}


static void strncat_sender(char *buffer, Document document, int bufsize)
{
    switch (document->ScanSource)
    {
        case PqRxDIRECT:    /* direct fax or ZMODEM link */
            if ((document->AddressRecord.ContactName[0] != '\0') || (document->AddressRecord.DirectPhoneNumber[0] != '\0'))
            {
                strncat(buffer, document->AddressRecord.ContactName, bufsize);
                strncat(buffer, " (", bufsize);
                strncat(buffer, document->AddressRecord.DirectPhoneNumber, bufsize);
                strncat(buffer, ")", bufsize);
            }
            break;

        case PqRxISP:
            if ((document->AddressRecord.ContactName[0] != '\0') || (document->AddressRecord.EmailAddress[0] != '\0'))
            {
                strncat(buffer, document->AddressRecord.ContactName, bufsize);
                strncat(buffer, " (", bufsize);
                strncat(buffer, document->AddressRecord.EmailAddress, bufsize);
                strncat(buffer, ")", bufsize);
            }
            break;
    }
}


static void strncat_page_count(char *buffer, int page_count, int bufsize)
{
    char numbuff[128];

    sprintf(numbuff, "%d page(s)", page_count);
    strncat(buffer, numbuff, bufsize);
}


static void LogRx_document_error(Document document, messageDataBlock *messageData)
{
    char buffer[256];
    
    strcpy(buffer, "R ");
    strncat_sender(buffer, document, sizeof(buffer));
    strncat(buffer, " ", sizeof(buffer));
    strncat_page_count(buffer, document->ScanCount, sizeof(buffer));
    strncat(buffer, " Error ", sizeof(buffer));
    strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));

    LogFileIF_Message(buffer);

    LogRX_error_count++;
}


static void LogRx_document_complete(Document document)
{
    if (LogRX_error_count == 0)
    {
        char buffer[256];
        
        strcpy(buffer, "R ");
        strncat_sender(buffer, document, sizeof(buffer));
        strncat(buffer, " ", sizeof(buffer));
        strncat_page_count(buffer, document->ScanCount, sizeof(buffer));
        strncat(buffer, " OK ", sizeof(buffer));

        LogFileIF_Message(buffer);
    }
}

static int log_tx_error_count = 0;

/*
 * Capture time when dialup started
 */
static void Log_TxConnecting(/*enum _SendRoute route,*/ PhoneConnection *connection)
{
	time_t now = time(NULL);

	connection->TimeDial    = now;
    connection->TimeConnect = now;
    connection->TimeEnd     = now;

	log_tx_error_count = 0;
}


/*
 * Capture the first error that occurs prior to connection
 */
static void Log_TxConnectingError(/*enum _SendRoute route,*/ PhoneConnection *connection, messageDataBlock *messageData)
{
	char buffer[256];
	/* There should be one error report, followed by our going idle */
    /* if multiple errors arrive, we report the first only */
	if (log_tx_error_count == 0)
	{
		strcpy(buffer, "R Error Printing ");
		strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));
    	LogFileIF_Message(buffer);
    }

    log_tx_error_count++;
}


/*
 * Report the failure to connect and the reason
 *
 * Also performs RetryCount-ing operations for the redial logic
 * used by QueueWalker.
 */
static void Log_TxConnectingFailed(/*enum _SendRoute route,*/ PhoneConnection *connection)
{
	time_t now = time(NULL);

	connection->TimeConnect = now;	/* } ie zero connection time */
	connection->TimeEnd     = now;  /* }                         */

	connection->RetryCount += 1;	/* count the dial attempt */	
    connection->RetryTime   = time(NULL) + 20;	/*now() + something(connection->RetryCount);*/

	/*>>>Report the failure to the screen and LogFile */
	/* Fax call to <number> failed <reason> */
    /* ISP dialup on <number> failed <reason> */
    if (log_tx_error_count == 0)
    	LogFileIF_Message("R Error Printing");
}


static void Log_TxConnected(/*enum _SendRoute route,*/ PhoneConnection *connection)
{
	time_t now = time(NULL);

	connection->TimeConnect = now;
	connection->TimeEnd     = now;

	log_tx_error_count = 0;	/* unlikely not to be zero */
}


static void Log_TxConnectedErrorSendingDoc(/*enum _SendRoute route,*/ PhoneConnection *connection, messageDataBlock *messageData, Document document)
{
	char buffer[256];
	
	if (log_tx_error_count == 0)
	{
		strcpy(buffer, "R Error Printing ");
		strncat(buffer, messageData->data.os_error.err.errmess, 128);
    	LogFileIF_Message(buffer);
    }

	log_tx_error_count++;
}


static void Log_TxConnectedError(/*enum _SendRoute route,*/ PhoneConnection *connection, messageDataBlock *messageData)
{
	char buffer[256];

	if (log_tx_error_count == 0)
	{
		strcpy(buffer, "R Error Printing ");
		strncat(buffer, messageData->data.os_error.err.errmess, 128);
    	LogFileIF_Message(buffer);
    }

	log_tx_error_count++;
}


static void Log_TxSentDocument(/*enum _SendRoute route,*/ PhoneConnection *connection, Document document)
{
    /* we report the reception of documents and errors printing */
    /* them but don't bother reporting successful printing */
#if 0
	char buffer[256];

	if (log_tx_error_count == 0)
	{
		strcpy(buffer, "R OK");
		LogFileIF_Message(buffer);
	}
#endif
}


static BOOL connection_requested_now(/*enum _SendRoute route,*/ PhoneConnection *connection)
{
	if (connection->RetryTime <= time(NULL))
		return(TRUE);

	return(FALSE);
}


extern unsigned int UniquePId(void)
{
	static unsigned int last_processid = 0;	/* not a valid pid */

	++last_processid;

	if (last_processid == 0)
		last_processid = 1;		/* never return zero, even if we wrap! */

	return(last_processid);
}


static Document PrintQ_Document_Queue = NULL;

static _kernel_oserror *PrintQ_CreateDocument(Document *p_document, PqRxRoute Source)
{
	static unsigned int dir_num = 0;

	_kernel_oserror    *error = NULL;
	Document 			document = NULL;
	char    			directory[212];

	*p_document = NULL;		/* in case we return an error */	

	/* be tidy, zero the directory name whenever the queue empties */
	if (PrintQ_Document_Queue == NULL)
		dir_num = 0;

	document = malloc(sizeof(DocumentRec));
    if (document)
    {
        memset(document, 0, sizeof(DocumentRec));   /* zero initialise whole block */
        
    	sprintf(directory, "%s.%d", DIRECTORY_PRINTQ, dir_num);
        dir_num++;

        if ((error = os_create_directory(directory)) != NULL)
        {
        	/* unable to create directory */
        	free(document);		/* free the document record we created */
        	return(error);		/* return the error */
        }
    }

	if (document)
	{
		/* created document record and a directory for the document - now fill the record */

    	document->ProcessId = UniquePId();		/* non-zero, unique across both SendQ and PrintQ */
	    strcpy(document->Directory, directory); /* fullname of the directory we created */
    	*document->CapturedPhoneNumber = '\0';  /* not yet captured from fax machine */
    	*document->AddressRecord.DirectPhoneNumber   = '\0';  /* not yet returned by the address book */
    	*document->AddressRecord.ContactName = '\0';          /* not yet returned by the address book */
        document->ScanSource = Source;                  /* PqRxDIRECT, PqRxISP or PqRxINTERNAL */
	    document->ScanState = ScanIDLE;			/* idle (0) */
    	document->ScanCount = 0;                /* no pages received yet */
    	document->PageList  = NULL;				/* so no classes or types */
    	document->TotalSize = 0;                /* no space taken by pages (neglecting directory overheads) */
    	document->BiggestPage = 0;
   	    document->RequestTx = FALSE;
    	document->SendState = SendIDLE;			/* idle (0) */
    	document->SendCount = 0;                /* no pages transmitted yet */
#if 0
	    document->Cancelled = FALSE;
	    document->Suspended = FALSE;
	    document->RetryCount = 3
	    document->RetryTime = 0;
#endif
		document->SearchRef = 0;                /* address book search ref */
#if FILECONVERT
		document->tx_StartLine = 0;				/* don't know what the first file to move/convert is */
		document->tx_loTiff = 1;                /* } nothing in TX directory yet */
		document->tx_hiTiff = 0;                /* }                             */
		strcat(directory, ".TX");
		if ((error = os_create_directory(directory)) != NULL)
        {
        	/* unable to create TX sub-directory */
        	os_destroy_directory(document->Directory);	/* delete the document dir we made earlier */
        	free(document);					/* free the document record we created */
        	return(error);					/* return the error */
        }
#endif
        document->SendReceipt            = FALSE;
        document->ReceiptAddress         = NULL;
        document->ReceiptRealName        = NULL;

        /* link document record to the tail of the queue */
		if (PrintQ_Document_Queue == NULL)
			document->next_document = document;	/* first and only document, so point next field at ourselves */
		else
		{
        	document->next_document = PrintQ_Document_Queue->next_document;	/* point to head of queue */
        	PrintQ_Document_Queue->next_document = document;	/* old last item becomes last-but-one (we are the last) */
        }
        PrintQ_Document_Queue = document;		/* point to tail of queue, our next_document field points to the head */

        *p_document = document;
	}

    return(NULL);
}

static Document sending_already = NULL;
static Document send_next       = NULL;

extern void PrintQ_QueueWalker(void)
{
	sending_already = NULL;
	send_next       = NULL;

	if (PrintQ_Document_Queue)
    {
		/* one or more items in the queue */
    	/* PrintQ_Document_Queue points to the last record in the queue, the last record points at the first (which maybe its-self) */

        Document previous = PrintQ_Document_Queue;		/* last item in queue */
        Document document;
        
		do
			{
				BOOL delete_it = FALSE;
				
				document = previous->next_document;	/* first/next item in queue */

				if (document->SendState == SendCOMPLETE)
				{
		        	if ((document->ScanState == ScanCOMPLETE) && (document->SendCount == document->ScanCount)
#if FILECONVERT
						 && (document->tx_loTiff > document->tx_hiTiff)
#endif
		        	   )
		        		delete_it = TRUE;	/* scan has completed and all scanned pages have been sent */
		            else
		            	document->SendState = SendIDLE; 	/* scan still in progress, or some pages not sent, so allow for later send of rest of document */
		        }
			
				if (document->SendState == SendIDLE)
				{
		        	if ((document->ScanState == ScanCOMPLETE) && (document->SendCount == document->ScanCount)
#if FILECONVERT
						 && (document->tx_loTiff > document->tx_hiTiff)
#endif
		        	   )
		        		delete_it = TRUE;	/* scan has completed, there are no (or no more) pages to send */
		        }

				if (!delete_it)
				{
		        	if (document->SendState == SendRUNNING)
		        		sending_already = document;			/* this document is already being sent */		
		            else
	            	{
	            		if ((document->RequestTx) || ((document->ScanState == ScanCOMPLETE)
	            		                             )
	            		   )
	            		{
	            			if (send_next == NULL)
	            				send_next = document;
	            		}
	            	}
	        	}

#if SUPPORT_EMAIL
                if (delete_it)
                {
                    if ((document->SendReceipt) && (document->ReceiptAddress))
                    {
                        char directory[256];
                        unsigned int SendQ_pid;
                        
                        document->SendReceipt = FALSE;  /* ensure one only sent */

                        /* create a new document then move our receipt into it */                        
                        if ((SendQ_pid = SendQ_ExtIF_NewDocument(directory, document->ReceiptRealName, document->ReceiptAddress, FALSE, FALSE)) != 0)
                        {
                            /* we don't print a hardcopy, nor do we request an acknowledgement of receipt of our receipt */

                            SendQ_ExtIF_Subject(SendQ_pid, "Return receipt");
                            SendQ_ExtIF_FileTake(SendQ_pid, document->Directory, "Receipt", PageClass_SendReceipt, PageType_SendReceipt, FILETYPE_TEXT);
#if 1
                            /* Chucks request: send immediately */
                            SendQ_ExtIF_DocumentComplete(SendQ_pid, TRUE);  /* ready to send - triggers immediate connection */
#else
                            SendQ_ExtIF_DocumentComplete(SendQ_pid, FALSE); /* ready to send - when next connection occurs (ie doesn't trigger connection) */
#endif
                        }
                    }
                }
#endif

				if (delete_it)
				{
	                if (document == previous)
	                {
	                	/* one document only in the queue, and we are deleting it! */
	                    previous = NULL;

	                    if (PrintQ_Document_Queue == document) /* always TRUE */
	                    	PrintQ_Document_Queue = previous;
	                }
	                else
	                {
	                	/* cut document from the circular queue */
	                	previous->next_document = document->next_document;
	                	
	                    if (PrintQ_Document_Queue == document)
	                    	PrintQ_Document_Queue = previous;	/* deleting last item in queue, so point queue at last but one entry */
	                }

					/* remove the TX subdirectory */
					{
						char directory[212];
						strcpy(directory, document->Directory);
						strcat(directory, ".TX");
						os_destroy_directory(directory);
					}

                    /* remove the document directory */
                    os_destroy_directory(document->Directory);

#if SUPPORT_EMAIL
                    /* Dispose of ReturnReceipt resources */
                    remove_fileDL(document->Directory,  "Receipt"); /* Be paranoid, shouldn't be needed */
                    if (document->ReceiptAddress)
                        free(document->ReceiptAddress);             /* MUST dispose of Address string (if any) */
                    if (document->ReceiptRealName)
                        free(document->ReceiptRealName);            /* MUST dispose of RealName string (if any) */
#endif
                    free(document);

                    document = previous;
                }
	            else
	            {
	            	previous = document;	/* ready to go around the loop */
	            }
            }
	    while (document != PrintQ_Document_Queue);    
	}
}

/*
 * PrintQ_NextDocument - identify the next document ready to print on the local fax machine
 */
static void PrintQ_NextDocument(Document *p_document)
{
    *p_document = send_next;	/* maybe NULL */
}


static Document document_from_pid(unsigned int pid)
{
	if (PrintQ_Document_Queue)
	{
		Document document = PrintQ_Document_Queue;		/* last item in queue */
		/* the pid is usually that of the first or last document, so we */
        /* allow our search to start with the tail element, followed by the head element */
        /* instead of the expected head first search */
		do
			{
				if (document->ProcessId == pid)
					return(document);

				document = document->next_document;	/* first/next item in queue */
			}
		while (document != PrintQ_Document_Queue);		
	}

	return(NULL);	/* not found!!! */
}


extern AddressRec *PrintQ_AddressRecord_from_pid(unsigned int pid)
{
	Document document;

	if ((document = document_from_pid(pid)) != NULL)
		return(&document->AddressRecord);

	return(NULL);	/* not found!!! */
}


/* write string to fixed width destination buffer */
static void assign(char *source, char *buffer, int buflen, BOOL truncate, const char *label)
{
    *buffer = '\0';

    /* null pointer sets empty string ("") */
    if (source)
        strncat(buffer, source, buflen);

    if (label)
        LogFileIF_show_string(LOG_DEBUG, label, buffer);
}


#if SUPPORT_UI
/*
 * Attach sender details to an incoming document.
 *   contact_name, fax_number & email_address are used for screen display and loging
 *   receipt_name & receipt_address are used for the user requested return receipt
 */
extern void PrintQ_SenderDetails(unsigned int pid, unsigned int *serial_number, char *contact_name, char *fax_number, char *email_address, char *receipt_name, char *receipt_address)
{
	Document document;

    if ((document = document_from_pid(pid)) != NULL)
    {
        AddressRec *pAddressRecord = &document->AddressRecord;

        LogFileIF_show_decimal_uint(LOG_DEBUG, "SerialNumber", serial_number[0]);
	    assign(contact_name , pAddressRecord->ContactName      , sizeof(pAddressRecord->ContactName)      , TRUE, "Contact");
		assign(fax_number   , pAddressRecord->DirectPhoneNumber, sizeof(pAddressRecord->DirectPhoneNumber), FALSE, "FaxNumber");
		assign(email_address, pAddressRecord->EmailAddress     , sizeof(pAddressRecord->EmailAddress)     , FALSE, "EmailAddress");

        if ((receipt_name) && (*receipt_name != '\0'))
        {
            if ((document->ReceiptRealName = malloc(1 + strlen(receipt_name))) != NULL)
                strcpy(document->ReceiptRealName, receipt_name);
        }

        if ((receipt_address) && (*receipt_address != '\0'))
        {
            if ((document->ReceiptAddress = malloc(1 + strlen(receipt_address))) != NULL)
                strcpy(document->ReceiptAddress, receipt_address);
        } 
    }
}
#endif


extern void PrintQ_TickerHandler(void)
{
	if (1 /*maybe_idle*/)	/* don't use maybe_idle flag until everything reports GOING_IDLE correctly! */
	{
		PrintQ_QueueWalker();

		/* if not already sending, send the next one ready to go */
		if ((sending_already == NULL) && (send_next != NULL) && connection_requested_now(&local_fax.Connection))
		{
			maybe_idle = FALSE;	/* assume no response to message */
  			StateKicker_SendMessage(LocXfer_StateMachine, PQ_LX_QUERY_IDLE, NULL);

	        /* deliver the queued messages */
            while (StateKicker_Deliver() > 1)
    	        /* null statement */;
        }
    }
}


/* end of PrintQ.c */
