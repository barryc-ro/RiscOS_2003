/*
 * LocModem.c - Local modem (local fax-machine) state machine
 *
 * Author: Ben Laughton
 * History: 1997-07-20: BAL: created
 *          1997-07-28: RCM: merged into main !Daytona app.
 */

#define SIMULATE 0 /*>>>should be zero for release*/
#define NEW_HARDWARE /*>>> (new hardware) */

/* =============================================================================
 * Include header files
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>

#include "StdTypes.h"

#include "kernel.h"
#include "swis.h"

#include "toolbox.h"

#include "StateKicker.h"
#include "LocModem.h"
#include "LocXfer.h"
#include "Screen.h"

/* #include "Dialler.h" */
#include "DaytonaHW.h"
#include "Serial.h"

#include "DebugLib.h"

/*#include "wimp.h"*/
/*#include "wimplib.h"*/
/*#include "FaxIF.h"*/


/* =============================================================================
 * Define contants
 */


/* Dialler_Arbitrate entry and exit values */
#define Dialler_Arbitrate_RequestIOAccess       0
#define Dialler_Arbitrate_RelinquishAccess      1
#define Dialler_IOAccessGranted_BlockDrivers    0
#define Dialler_IOAccessGranted_DualSerial      1
#define Dialler_IOAccessDenied_ActiveClient    64
#define Dialler_IOAccessDenied_NotConnected    65

/* Flags used by Dialler_Dial, Dialler_Configure and Dialler_Answering */
#define Dialler_Flags_BlockdriverInMemory     0x01    /* blockdriver only */
#define Dialler_Flags_UseGivenHandles         0x01    /* devicefs only */
#define Dialler_Flags_DialScriptInMemory      0x02
#define Dialler_Flags_AnswerScriptInMemory    0x02
#define Dialler_Flags_HangupScriptInMemory    0x04
#define Dialler_Flags_UseScriptsInSitu        0x08
#define Dialler_Flags_Portnumber              0x10    /* blockdriver only */
#define Dialler_Flags_NoReset                 0x80000000

#define Dialler_Dial_DialScriptInMemory   0x2
#define Dialler_Dial_AnswerScriptInMemory 0x2
#define Dialler_Dial_HangupScriptInMemory 0x4
#define Dialler_Dial_InSitu               0x8


/* Values for r0 reason code on entry to SWI DiallerB_Status */
#define DiallerB_Status_ConnectTime     1
#define DiallerB_Status_String          2

/* Reason code masks */
#define Dialler_MajorReasonCodeMask    0xffff0000
#define Dialler_MinorReasonCodeMask    0x0000ff00
#define Dialler_GeneralInfoMask        0x000000ff

/* Major reason code (top two bytes of status word) */
#define Dialler_StateChanged           0x00010000
#define Dialler_LineDropped            0x00020000
#define DiallerB_StatusStringChanged    0x00040000

/* Minor reason code (2nd byte of status word) */
#define Dialler_ConnectedFlagsMask     0x00000300
#define Dialler_Disconnected           0x00000000
#define Dialler_ConnectionChanging     0x00000100
#define Dialler_Connected              0x00000200
#define Dialler_ConnectedOutgoing      0x00000200
#define Dialler_ConnectedIncoming      0x00000300
#define Dialler_RelinquishAccess       0x00000400
#define Dialler_DiallerDroppedLine     0x00000000
#define Dialler_RemoteDroppedLine      0x00000800

/* General info (1st byte of status word) */
enum
{
    Dialler_ExecutingScript_Dial = 1,
    Dialler_ExecutingScript_Hangup,
    Dialler_ExecutingScript_Answer,
    Dialler_AbortedScript_Syntax,
    Dialler_AbortedScript_Timeout,
    Dialler_AbortedScript_NoCarrier,
    Dialler_AbortedScript_Error,
    Dialler_AbortedScript_NoDialtone,
    Dialler_AbortedScript_Busy,
    Dialler_AbortedScript_NoAnswer
};

#define DiallerB_Dial                  0x050c80
#define DiallerB_HangUp                0x050c81
#define DiallerB_Status                0x050c82
#define DiallerB_Answering             0x050c83
#define DiallerB_Configure             0x050c84
#define DiallerB_Register              0x050c85
#define DiallerB_Arbitrate             0x050c86
#define DiallerB_Timeout               0x050c87
#define DiallerB_ResetCounter          0x050c88



#if 0
enum _BOOL { FALSE = 0, TRUE = 1 };
typedef enum _BOOL BOOL;
#endif
/* Errors */
enum
{
    E_BadState
};

/* States */
enum
{
    Idle,
    Incoming_Start,
    Incoming_AnswerFax,
    Incoming_RxConnected,
    Incoming_Disconnecting,
/*    Incoming_RxFinished, */
    Outgoing_CallFax,
    Outgoing_FaxAnswering,
    Outgoing_TxConnected,
    Outgoing_Disconnecting,
/*    Outgoing_TxFinished, */
    Blocking
};

#define AnswerTimeout 6000           /* 60 seconds in centiseconds - allow fax machine 60 to go off hook after we ring it */

#define FakeExchange_Timeout 3000    /* 30 seconds in centiseconds */
#define FakeExchange_Delay 200       /* 2 seconds in centiseconds */




/* =============================================================================
 * Declare global variables
 */

/*extern*/ static int g_reserved;
/*extern*/ localModemDataBlock g_local_modem_data;

static _kernel_oserror g_error[] =
{
    {-1, "Local modem state machine in unknown state"},
};

static char stash_number[30];   /* to hold captured number from HW_LM_NUMBERCAPTURED for later sending with LM_LX_INCOMING_FAX */
static int timeout_time = 0;

static const char answer_script[] =
    "TIMEOUT 10\n"
    "\"\" ATE0\n"
    "\\r\\nOK\\r\\n AT+FCLASS=1\n"
    "\\r\\nOK\\r\\n ATA\n";
/*    "\\r\\nCONNECT\\r\\n \\c\n"; */ /* Not required: !Fax looks for this */

static const char print_script[] =
    "TIMEOUT 35\n"
    "\"\" ATE0X0\n"
    "\\r\\nOK\\r\\n AT+FCLASS=1\n"
    "\\r\\nOK\\r\\n ATD\n";
/*    "\\r\\nCONNECT\\r\\n \\c\n"; */ /* Not required: !Fax looks for this */

static const char hangup_script[] =
    "\"\" ATH0\n"
    "\\r\\nOK\\r\\n \\c\n";
/*    "\"\" \\c\n"; */




/* =============================================================================
 * Declare function prototypes
 */

static _kernel_oserror *idle (const int input,
                              messageDataBlock *const messageData,
                              localModemDataBlock *const local_modem_data,
                              int *const state);

static _kernel_oserror *incoming_start (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state);

static _kernel_oserror *incoming_answer_fax (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state);

static _kernel_oserror *incoming_rx_connected (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state);

static _kernel_oserror *incoming_disconnecting (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state);

#if 0
static _kernel_oserror *incoming_rx_finished (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state);
#endif

static _kernel_oserror *outgoing_call_fax (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state);

static _kernel_oserror *outgoing_fax_answering (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state);

static _kernel_oserror *outgoing_tx_connected (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state);

static _kernel_oserror *outgoing_disconnecting (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state);

#if 0
static _kernel_oserror *outgoing_tx_finished (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state);
#endif
static _kernel_oserror *blocking (const int input,
                                  messageDataBlock *const messageData,
                                  localModemDataBlock *const local_modem_data,
                                  int *const state);

static _kernel_oserror *LocalModem_ResetModem(void);
static void LocalModem_HookDisable(void);
static void LocalModem_HookEnable(void);

static _kernel_oserror *dialler_status(unsigned int *const dialler_status);

static _kernel_oserror *dialler_start_dial_script (
                            const int force_reset,
                            const char *const dial_script,
                            const char *const hangup_script,
                            const int serial_in,
                            const int serial_out);

static void dialler_monitor_dial_script (int *const state,
                                         const unsigned int dialler_status,
                                         const int executing_state,
                                         const int failed_state,
                                         const int completed_state);

static _kernel_oserror *dialler_start_answer_script (
                            const int force_reset,
                            const char *const answer_script,
                            const char *const hangup_script,
                            const int serial_in,
                            const int serial_out);

static void dialler_monitor_answer_script (int *const state,
                                           const unsigned int dialler_status,
                                           const int executing_state,
                                           const int failed_state,
                                           const int completed_state);

static _kernel_oserror *dialler_start_hangup_script (void);

static void dialler_monitor_hangup_script (int *const state,
                                           const unsigned int dialler_status,
                                           const int executing_state,
                                           const int failed_state,
                                           const int completed_state);

/* =============================================================================
 * Define functions
 */

/* -----------------------------------------------------------------------------
+
-
 */

extern void LocModem_StateMachine(int messageNumber, messageDataBlock *messageData)
{
    static int state = Idle;
    _kernel_oserror *e = NULL;
    localModemDataBlock *local_modem_data = &g_local_modem_data;

    /* Print state machine status */
    dprintf((NULL, "LocModem_StateMachine (entry): State => %d; Message => 0x%X\n", state, messageNumber));

    switch (state)
    {
        case Idle:
            e = idle (messageNumber, messageData, local_modem_data, &state);
            break;

        case Incoming_Start:
            e = incoming_start (messageNumber, messageData, local_modem_data, &state);
            break;

        case Incoming_AnswerFax:
            e = incoming_answer_fax (messageNumber, messageData, local_modem_data, &state);
            break;

        case Incoming_RxConnected:
            e = incoming_rx_connected (messageNumber, messageData, local_modem_data, &state);
            break;

        case Incoming_Disconnecting:
            e = incoming_disconnecting (messageNumber, messageData, local_modem_data, &state);
            break;

#if 0
        case Incoming_RxFinished:
            e = incoming_rx_finished (messageNumber, messageData, local_modem_data, &state);
            break;
#endif

        case Outgoing_CallFax:
            e = outgoing_call_fax (messageNumber, messageData, local_modem_data, &state);
            break;

        case Outgoing_FaxAnswering:
            e = outgoing_fax_answering (messageNumber, messageData, local_modem_data, &state);
            break;

        case Outgoing_TxConnected:
            e = outgoing_tx_connected (messageNumber, messageData, local_modem_data, &state);
            break;

        case Outgoing_Disconnecting:
            e = outgoing_disconnecting (messageNumber, messageData, local_modem_data, &state);
            break;

#if 0
/(        case Outgoing_TxFinished:
            e = outgoing_tx_finished (messageNumber, messageData, local_modem_data, &state);
            break;
#endif
        case Blocking:
            e = blocking (messageNumber, messageData, local_modem_data, &state);
            break;

        default:
            e =  &g_error[E_BadState];
            break;
    }

    /* Print state machine status on exit */
    dprintf((NULL, "LocModem_StateMachine (exit): Next state => %d\n", state));

    if (e != NULL)
    {
        messageDataBlock *message_data;

        StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_ERROR, &message_data);
        message_data->data.lm_error.rc = 0;	/*>>>should rc be zero???*/
        message_data->data.lm_error.err = *e;   /* MUST copy message block rather than pointer (which will be stale when the message arrives)  */
    }
}


/* -----------------------------------------------------------------------------
+
   idle

   Deal with an input to the local modem state machine when its in the idle
   state.  If an error occurs then the state is not changed.

   Inputs
   input: the input to the local modem state machine
   state: pointer to the state of the local modem state machine
-
 */

static _kernel_oserror *idle (const int input,
                              messageDataBlock *const messageData,
                              localModemDataBlock *const local_modem_data,
                              int *const state)
{
    _kernel_oserror *e = NULL;

    stash_number[0] = '\0';

    switch (input)
    {
        case LX_LM_QUERY_IDLE:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_AM_IDLE, NULL);    /*NB don't send LM_LX_GOING_IDLE*/
            *state = Idle;
            break;

        case HW_LM_OFFHOOK:
            if (g_reserved)
                *state = Blocking;
            else
            {
#if 1 /* IF IT'S STILL NOT WORKING!!! */
                /* Set required baudrates (both directions) */
                (void)Serial_Set_Baudrate(LOCMODEM, 115200);

                e = _swix (DaytonaHW_FakeExchange, _INR (0, 7),

                           DaytonaHW_FakeExchange_Start,
                           local_modem_data->serial_input_buffer,
                           local_modem_data->serial_output_buffer,
                           local_modem_data->serial_input_stream,
                           local_modem_data->serial_output_stream,
                           FakeExchange_Timeout,
                           FakeExchange_Delay);
#if SIMULATE
                e = NULL;   /*>>>suppress the error*/
#endif

                if (e == NULL)
                {
                    StateKicker_SendMessage (Screen_StateMachine, LM_SC_OFFHOOK, NULL);
                    *state = Incoming_Start;
                }
#else
                StateKicker_SendMessage (Screen_StateMachine, LM_SC_OFFHOOK, NULL);
                LocalModem_HookDisable();
                e = dialler_start_answer_script (1,    /* force reset */
                                                 answer_script,
                                                 hangup_script,
                                                 local_modem_data->serial_input_stream,
                                                 local_modem_data->serial_output_stream);

#if SIMULATE
            e = NULL;
#endif
            if (e == NULL)
                *state = Incoming_AnswerFax;


#endif
            }
            break;

        case LX_LM_HANGUP:
            /* Idle already, but send LM_LX_GOING_IDLE anyway */
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
            *state = Idle;
            break;

        case LX_LM_PRINT:
            e = _swix (OS_ReadMonotonicTime, _OUT (0), &timeout_time);
            if (e != NULL) break;
            timeout_time += AnswerTimeout;
            e = _swix (DaytonaHW_CallLocalFax, _INR (0, 1),

                       0,
                       DaytonaHW_CallLocalFax_Start);
            if (e != NULL) break;
            *state = Outgoing_CallFax;
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *incoming_start (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
#ifdef NEW_HARDWARE
        /* Belief is that ONHOOK here _could_ be caused by the same spurious hardware feature (on old hardware) */
        case HW_LM_ONHOOK:
                e = _swix (DaytonaHW_FakeExchange, _INR (0, 7),

                           DaytonaHW_FakeExchange_Stop,
                           local_modem_data->serial_input_buffer,
                           local_modem_data->serial_output_buffer,
                           local_modem_data->serial_input_stream,
                           local_modem_data->serial_output_stream,
                           FakeExchange_Timeout,
                           FakeExchange_Delay);
            if (e != NULL) break;

            e = LocalModem_ResetModem();

            StateKicker_SendMessage (Screen_StateMachine, LM_SC_ONHOOK, NULL);
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
            *state = Idle;
            break;
#endif

        case HW_LM_NUMBERCAPTURED:
            /* stash number away so it can added to a later LM_LX_INCOMING_FAX message */
            strcpy(stash_number, messageData->data.numbercaptured.number);

            e = dialler_start_answer_script (1,    /* force reset */
                                             answer_script,
                                             hangup_script,
                                             local_modem_data->serial_input_stream,
                                             local_modem_data->serial_output_stream);
#if SIMULATE
            e = NULL;
#endif
            if (e == NULL)
                *state = Incoming_AnswerFax;
            break;

        case LX_LM_HANGUP:
            e = _swix (DaytonaHW_FakeExchange, _INR (0, 7),

                       DaytonaHW_FakeExchange_Stop,
                       local_modem_data->serial_input_buffer,
                       local_modem_data->serial_output_buffer,
                       local_modem_data->serial_input_stream,
                       local_modem_data->serial_output_stream,
                       FakeExchange_Timeout,
                       FakeExchange_Delay);

            e = LocalModem_ResetModem();
    /*        LocalModem_HookEnable(); RCM 1998/01/09 consulted Ben & Simonthen took this out */

#if 0       /* State removed */
            *state = Incoming_RxFinished;
#else
			StateKicker_SendMessage (Screen_StateMachine, LM_SC_ONHOOK, NULL);	/*>>>RCM says: is this right?, should we wait for HW_LM_ONHOOK???*/
			StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
            *state = Idle;
#endif

            break;

        case LX_LM_PRINT:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_REJECTED, NULL);
            *state = Incoming_Start;
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *incoming_answer_fax (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state)
{
    _kernel_oserror *e = NULL;
    messageDataBlock *message_data;

    switch (input)
    {
#ifdef NEW_HARDWARE
        /* Belief is that ONHOOK here is a spurious hardware feature on the old hardware */
        case HW_LM_ONHOOK:
            e = LocalModem_ResetModem();
            StateKicker_SendMessage (Screen_StateMachine, LM_SC_ONHOOK, NULL);
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
            *state = Idle;
            break;
#endif
        case DI_LM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            dialler_monitor_answer_script (state,
                                          messageData->data.dialler.status,
                                          Incoming_AnswerFax,
                                          Idle,
                                          Incoming_RxConnected);
            /* setup for new state */
            switch (*state)
            {
                case Incoming_RxConnected:
                    /* send message with previously stashed number */
                    StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_INCOMING_FAX, &message_data);
                    strcpy(message_data->data.incoming_fax.number, stash_number);
                    break;

                case Idle:
                    e = LocalModem_ResetModem();
#if 0 /* NEW_HARDWARE */
                    LocalModem_HookEnable();
#endif
                    break;

                default:
                    break;
            }
            break;


        case LX_LM_HANGUP:
            e = dialler_start_hangup_script ();
            *state = Incoming_Disconnecting;
            break;

        case LX_LM_PRINT:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_REJECTED, NULL);
            *state = Incoming_AnswerFax;
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *incoming_rx_connected (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case LX_LM_HANGUP:
            e = dialler_start_hangup_script ();
            *state = Incoming_Disconnecting;
            break;

        case LX_LM_PRINT:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_REJECTED, NULL);
            *state = Incoming_RxConnected;
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *incoming_disconnecting (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case DI_LM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            dialler_monitor_hangup_script (state,
                                          messageData->data.dialler.status,
                                          Incoming_Disconnecting,
                                          Idle,
                                          Idle);
            /* setup for new state */
            if (*state == Idle)
            {
                e = LocalModem_ResetModem();
#if 0 /* Not required */
                LocalModem_HookEnable();
#endif
/*>>>				StateKicker_SendMessage (Screen_StateMachine, LM_SC_ONHOOK, NULL);???*/
				StateKicker_SendMessage (Screen_StateMachine, LM_SC_ONHOOK, NULL);	/*>>>RCM says: is this right?, should we wait for HW_LM_ONHOOK???*/
                StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);   /* Added - see state below */
            }
            break;

        case LX_LM_HANGUP:    /* already doing a hangup */
            *state = Incoming_Disconnecting;
            break;

        case LX_LM_PRINT:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_REJECTED, NULL);
            *state = Incoming_Disconnecting;
            break;

        default:
            break;
    }

    return e;
}




#if 0
/* On hook message arrives in state 4.  The message is redundant: a successful Dialler disconnect will always be accompanied by an
 * om hook message.  This means that this state is no longer necessary - the 'going idle' message is sent in state 4 when the hangup
 * script has finished.
 */
static _kernel_oserror *incoming_rx_finished (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case HW_LM_ONHOOK:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
            *state = Idle;
            break;

        case LX_LM_HANGUP:    /* already disconnected */
            *state = Incoming_RxFinished;
            break;

        case LX_LM_PRINT:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_REJECTED, NULL);
            *state = Incoming_RxFinished;
            break;

        default:
            break;
    }

    return e;
}
#endif



static _kernel_oserror *outgoing_call_fax (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state)
{
    _kernel_oserror *e = NULL;
    /*messageDataBlock *message_data;*/

    switch (input)
    {
        case HW_LM_OFFHOOK:
            e = _swix (DaytonaHW_CallLocalFax, _INR (0, 1),

                       0,
                       DaytonaHW_CallLocalFax_Stop);
            if (e != NULL) break;
            e = dialler_start_dial_script (1,    /* force reset */
                                           print_script,
                                           hangup_script,
                                           local_modem_data->serial_input_stream,
                                           local_modem_data->serial_output_stream);
            if (e == NULL)
                *state = Outgoing_FaxAnswering;
            break;

        case LX_LM_HANGUP:
            e = _swix (DaytonaHW_CallLocalFax, _INR (0, 1),

                       0,
                       DaytonaHW_CallLocalFax_Stop);
            if (e != NULL) break;

            e = LocalModem_ResetModem();
            if (e != NULL) break;

            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
            StateKicker_SendMessage (Screen_StateMachine, LM_SC_PRINT_COMPLETE, NULL);

            *state = Idle;
            break;

        case LX_LM_PRINT:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_REJECTED, NULL);
            *state = Outgoing_CallFax;
            break;

        default:
            break;
    }

    /* If we haven't changed state then check the timeout */
    if (*state == Outgoing_CallFax)
    {
        int t;

        _swix (OS_ReadMonotonicTime, _OUT (0), &t);
        if (t > timeout_time)
        {
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_FAILED, NULL);	/* ie no response from local fax when we 'ring' it */

            e = _swix (DaytonaHW_CallLocalFax, _INR (0, 1),

                       0,
                       DaytonaHW_CallLocalFax_Stop);

            e = LocalModem_ResetModem();

            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
            StateKicker_SendMessage (Screen_StateMachine, LM_SC_PRINT_COMPLETE, NULL);
            *state = Idle;
        }
    }

    return e;
}




static _kernel_oserror *outgoing_fax_answering (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state)
{
    _kernel_oserror *e = NULL;
    /*messageDataBlock *message_data;*/

    switch (input)
    {
        case HW_LM_ONHOOK:    /* dialler will have detected on hook and hung up */
            e = LocalModem_ResetModem();
            if (e != NULL) break;

            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_FAILED, NULL);	/* ie local fax answered our 'ring' then hung-up */

            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
            StateKicker_SendMessage (Screen_StateMachine, LM_SC_PRINT_COMPLETE, NULL);
            *state = Idle;
            break;

        case DI_LM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            dialler_monitor_dial_script (state,
                                         messageData->data.dialler.status,
                                         Outgoing_FaxAnswering,
                                         Idle,
                                         Outgoing_TxConnected);
            /* setup for new state */
            if (*state == Outgoing_TxConnected)
            {
                StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_TXCONNECTED, NULL);
            }
            else if (*state == Idle)
            {
                e = LocalModem_ResetModem();
                StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
                StateKicker_SendMessage (Screen_StateMachine, LM_SC_PRINT_COMPLETE, NULL);
            }
            break;

        case LX_LM_HANGUP:
            e = dialler_start_hangup_script ();
            *state = Outgoing_Disconnecting;
            break;

        case LX_LM_PRINT:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_REJECTED, NULL);
            *state = Outgoing_FaxAnswering;
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_tx_connected (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case LX_LM_HANGUP:
            e = dialler_start_hangup_script ();
            *state = Outgoing_Disconnecting;
            break;

        case LX_LM_PRINT:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_REJECTED, NULL);
            *state = Outgoing_TxConnected;
            break;

        default:
            break;
    }

    return e;
}




static _kernel_oserror *outgoing_disconnecting (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case DI_LM_STATUS_CHANGED:
            dprintf((NULL, "Dialler status: 0x%X\n", messageData->data.dialler.status));

            dialler_monitor_hangup_script (state,
                                         messageData->data.dialler.status,
                                         Outgoing_Disconnecting,
                                         Idle,
                                         Idle);
            /* setup for new state */
            if (*state == Idle)
            {
                e = LocalModem_ResetModem();
                StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
                StateKicker_SendMessage (Screen_StateMachine, LM_SC_PRINT_COMPLETE, NULL);
            }
            break;

        case LX_LM_HANGUP:    /* already doing a hangup */
            *state = Outgoing_Disconnecting;
            break;

        case LX_LM_PRINT:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_REJECTED, NULL);
            *state = Outgoing_Disconnecting;
            break;

        default:
            break;
    }

    return e;
}




#if 0
static _kernel_oserror *outgoing_tx_finished (
                            const int input,
                            messageDataBlock *const messageData,
                            localModemDataBlock *const local_modem_data,
                            int *const state)
{
    _kernel_oserror *e = NULL;

    switch (input)
    {
        case HW_LM_ONHOOK:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
            *state = Idle;
            break;

        case LX_LM_HANGUP:    /* already disconnected */
            *state = Outgoing_TxFinished;
            break;

        case LX_LM_PRINT:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_REJECTED, NULL);
            *state = Outgoing_TxFinished;
            break;

        default:
            break;
    }

    return e;
}
#endif



/* -----------------------------------------------------------------------------
+
   blocking

   Deal with an input to the local modem state machine when its in the blocking
   state.  If an error occurs then the state is not changed.

   Inputs
   input: the input to the local modem state machine
   state: pointer to the state of the local modem state machine
-
 */

static _kernel_oserror *blocking (const int input,
                                  messageDataBlock *const messageData,
                                  localModemDataBlock *const local_modem_data,
                                  int *const state)
{
    _kernel_oserror *e = NULL;


    /* special case: check reserved flag first */
    if (g_reserved == FALSE)
    {
        StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
        *state = Idle;
        return NULL;
    }

    switch (input)
    {
        case HW_LM_ONHOOK:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_GOING_IDLE, NULL);
            *state = Idle;
            break;

        case LX_LM_HANGUP:
            *state = Blocking;
            break;

        case LX_LM_PRINT:
            StateKicker_SendMessage (LocXfer_StateMachine, LM_LX_PRINT_REJECTED, NULL);
            *state = Blocking;
            break;

         default:
            break;
    }

    return e;
}


static unsigned int last_status = 0;
/*
 * Initialise LocModem state machine
 */
extern _kernel_oserror *LocModem_Initialise(void)
{
    _kernel_oserror  *error;

    /* ensures dialler is present, then captures state in last_state */
    /* so that LocModem_PollStatus can report changes              */
    error = dialler_status(&last_status);
#if SIMULATE
    error = NULL;
#endif
    {
        g_local_modem_data.serial_input_buffer  = Modem[LOCMODEM].BufferIn;
        g_local_modem_data.serial_output_buffer = Modem[LOCMODEM].BufferOut;
        g_local_modem_data.serial_input_stream  = Modem[LOCMODEM].FileIn;
        g_local_modem_data.serial_output_stream = Modem[LOCMODEM].FileOut;
    }

    return(error);
}


extern void LocModem_Finalise(void)
{
    /* none currently - may need to drop the line */
}


static _kernel_oserror *LocalModem_ResetModem(void)
{
#if 0
    /* Use DTR line which may work */
    return(_swix(DaytonaHW_ResetModem, _INR(0, 1), DaytonaHW_ResetModem_DTR, Modem[LOCMODEM].FileOut));
#else
    /* Use hardware reset line - should now work */
    return(_swix(DaytonaHW_ResetModem, _INR (0, 2), DaytonaHW_ResetModem_PIOReg, DaytonaHW_ResetModem_Local, Modem[LOCMODEM].FileOut));
#endif
}

static void LocalModem_HookDisable(void)
{
    (void)_swix(DaytonaHW_HookControl, _INR(0, 1), 0/*flags*/, DaytonaHW_HookControl_Disable);
}

static void LocalModem_HookEnable(void)
{
    (void)_swix(DaytonaHW_HookControl, _INR(0, 1), 0/*flags*/, DaytonaHW_HookControl_Enable);
}

extern void LocModem_PollStatus(void)
{
    _kernel_oserror  *error;
    unsigned int current_status;

    if ((error = dialler_status(&current_status)) != NULL)
    {
        /*>>>should this be passed as an error to LocModem?*/
    }
    else
    {
        if (last_status != current_status)
        {
            messageDataBlock *sendMessage;

            StateKicker_SendMessage(LocModem_StateMachine, DI_LM_STATUS_CHANGED, &sendMessage);
            sendMessage->data.dialler.status = current_status;

            last_status = current_status;
        }
        else
        {	/* send a tick message to allow timeout timers to work */
        	StateKicker_SendMessage(LocModem_StateMachine, DI_LM_TICKER, NULL);	/* actually di_lm_status_UNchanged */
        }

		/* deliver the queued messages */
        while (StateKicker_Deliver() > 1)
        	/* null statement */;
    }
}

#if 0
extern int Dialler_pollword_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    messageDataBlock sendMessage;

/*>>>sendMessage.pollword.xx = yy;*/
    /*>>> How do we identify which modem is responding? */

    sendMessage.data.dialler.status = 0;    /*>>>incomplete*/
  /*if ( )*/
        LocModem_StateMachine(DI_LM_STATUS_CHANGED, &sendMessage);
  /*else
        RemModem_StateMachine(DI_RM_STATUS_CHANGED, &sendMessage);
  */

    return(1);  /* processed */
}
#endif


extern int DaytonaHW_WimpMessageHandler(WimpMessage *message, void *handle)
{
        /* Print debugging information */
    dprintf((NULL, "DaytonaHW_WimpMessageHandler: Message => 0x%X\n", message->hdr.action_code));

    switch (message->hdr.action_code)
    {
            case Wimp_MDaytonaHW_LocalFaxReceiver:
                 switch (message->data.words[0])
                 {
                 case DaytonaHW_LocalFaxReceiver_OffHook:
                StateKicker_SendMessage(LocModem_StateMachine, HW_LM_OFFHOOK, NULL);
                break;

                case DaytonaHW_LocalFaxReceiver_OnHook:
                StateKicker_SendMessage(LocModem_StateMachine, HW_LM_ONHOOK, NULL);
                break;
                     }
                     break;

        case Wimp_MDaytonaHW_FakeExchange:
#if 1
                dprintf((NULL, "DaytonaHW_WimpMessageHandler: FakeExchange, reason => %d\n", message->data.words[0]));
            switch (message->data.words[0])
            {
                case DaytonaHW_MFakeExchange_CapturedNumber:
                    {
                        messageDataBlock *sendMessage;

                        StateKicker_SendMessage(LocModem_StateMachine, HW_LM_NUMBERCAPTURED, &sendMessage);
                        strcpy(sendMessage->data.numbercaptured.number, &message->data.bytes[4]);
                        dprintf((NULL, "-- Number captured => %s\n", &message->data.bytes[4]));
                    }
                    break;


                case DaytonaHW_MFakeExchange_Error_DTMFTimeout:
                case DaytonaHW_MFakeExchange_Error_DTMFOverflow:
                case DaytonaHW_MFakeExchange_Error_OSError:
                case DaytonaHW_MFakeExchange_Error_DiallerFailed:
                case DaytonaHW_MFakeExchange_Error_BadFrequency:
                case DaytonaHW_MFakeExchange_Error_DialtoneOverflow:
                /*>>>must pass up the error sometime soon*/
                    break;
            }
#else
            {
            /*>>>will do for now*/
                messageDataBlock *sendMessage;

                StateKicker_SendMessage(LocModem_StateMachine, HW_LM_NUMBERCAPTURED, &sendMessage);
                strcpy(sendMessage->data.numbercaptured.number, "0123498765");
            }
#endif
            break;

    }

    /* deliver the queued messages */
    while (StateKicker_Deliver() > 1)
        /* null statement */;

    return(1);
}



/* Temporary dialler functions to talk to the DiallerB module.  These
 * will need to be removed when the multiport dialler is ready.
 * Looks like no multiport dialler will be produced; leave these as they are...
 */


static _kernel_oserror *dialler_status(unsigned int *const dialler_status)
{
    _kernel_swi_regs  r;
    _kernel_oserror  *error;

    r.r[0] = 0; /* flags - must be zero */
    if ((error = _kernel_swi(DiallerB_Status, &r, &r)) == NULL)
        *dialler_status = r.r[0];

    return(error);
}


static _kernel_oserror *dialler_start_dial_script (
                            const int force_reset,
                            const char *const dial_script,
                            const char *const hangup_script,
                            const int serial_in,
                            const int serial_out)
{
    unsigned int flags;
    _kernel_oserror *e = NULL;


    flags =    Dialler_Flags_UseGivenHandles |
               Dialler_Flags_DialScriptInMemory |
               Dialler_Flags_HangupScriptInMemory;
    if (!force_reset)
        flags |= Dialler_Flags_NoReset;


    e = _swix (DiallerB_Dial, _INR (0, 6),

               flags,
               0,
               dial_script,
               hangup_script,
               0,
               serial_in,
               serial_out);

    return e;
}




static void dialler_monitor_dial_script (int *const state,
                                         const unsigned int dialler_status,
                                         const int executing_state,
                                         const int failed_state,
                                         const int completed_state)
{
    if ((dialler_status & Dialler_Connected) == Dialler_Connected)
        *state = completed_state;

    else if ((dialler_status & Dialler_ConnectedFlagsMask) == Dialler_Disconnected &&
             (dialler_status & Dialler_GeneralInfoMask) !=
             Dialler_ExecutingScript_Dial)
    {
        *state = failed_state;
    }

    else
        *state = executing_state;
}




static _kernel_oserror *dialler_start_answer_script (
                            const int force_reset,
                            const char *const answer_script,
                            const char *const hangup_script,
                            const int serial_in,
                            const int serial_out)
{
    unsigned int flags;
    _kernel_oserror *e = NULL;


    flags =    Dialler_Flags_UseGivenHandles |
               Dialler_Flags_DialScriptInMemory |
               Dialler_Flags_HangupScriptInMemory;
    if (!force_reset)
        flags |= Dialler_Flags_NoReset;

    e = _swix (DiallerB_Answering, _INR (0, 6),

               flags,
               0,
               answer_script,
               hangup_script,
               0,
               serial_in,
               serial_out);
    return e;
}




static void dialler_monitor_answer_script (int *const state,
                                           const unsigned int dialler_status,
                                           const int executing_state,
                                           const int failed_state,
                                           const int completed_state)
{
    if ((dialler_status & Dialler_Connected) == Dialler_Connected)
        *state = completed_state;

    else if ((dialler_status & Dialler_ConnectedFlagsMask) == Dialler_Disconnected &&
             (dialler_status & Dialler_GeneralInfoMask) !=
                 Dialler_ExecutingScript_Answer)
    {
        *state = failed_state;
    }

    else
        *state = executing_state;
}




static _kernel_oserror *dialler_start_hangup_script (void)
{
    _kernel_oserror *e = NULL;


    e = _swix (DiallerB_HangUp, 0);
    return e;
}


static void dialler_monitor_hangup_script (int *const state,
                                           const unsigned int dialler_status,
                                           const int executing_state,
                                           const int failed_state,
                                           const int completed_state)
{
    if ((dialler_status & Dialler_ConnectedFlagsMask) == Dialler_Disconnected &&
        (dialler_status & Dialler_GeneralInfoMask) == 0)
    {
        *state = completed_state;
    }

    else if ((dialler_status & Dialler_GeneralInfoMask) !=
                Dialler_ExecutingScript_Hangup)
    {
        *state = failed_state;
    }

    else
        *state = executing_state;
}


/* end of LocModem.c */
