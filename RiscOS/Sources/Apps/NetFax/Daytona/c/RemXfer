/*
 * RemXfer.c - Remote modem (external phone line) data transfer state machine
 *
 * R C Manby
 * - with additions by S B Forrest
 *
 * Started 29 July 1997
 *
 * 1998-02-25: BAL
 * Fixed bug: original POP3 messages were not being deleted.
 * Made 'Out of memory' error messages be more specific.
 *
 * 1998-03-08: BAL
 * Changed handling of PQ_RX_ABORT_INCOMING message; I had thought that this
 * meant 'drop everything and abort' whereas it really means 'just don't send
 * me any more documents in this session'.
 *
 * Before this was done, PQ_RX_ABORT_INCOMING showed up a fault in the delete
 * list handling: the list data was being destroyed but the indices were not
 * being reset properly.
 *
 * 1998-03-19: BAL
 * If state INCOMING_8e gets message it's not interested in it stays in the
 * same state instead of changing to state INCOMING_8d (copy & paste bug).
 *
 * 1998-03-20 - 1998-03-25: BAL
 * Now copes with messages being deleted from the email account behind Daytona's
 * back.
 *
 * Now copes with lying POP3 servers that report message sizes as being smaller
 * than they really are.
 *
 * Reinstated coping with messages with very large headers (by default we
 * allow 4k for the headers) and fixed a nasty bug in it at the same time (was
 * using the size of the whole message in some places rather than just the size
 * of the headers).
 *
 * A little bit of tidying up, more comments etc.
 */


#include "BuildFlags.h"
#include "StdTypes.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"


#include "swis.h"  /* N.B,  Only required if deletion of ZModem files on TX is enabled
                    * Now required for creation and removal of dynamic areas and POP3 directory as well
                    */


#include "NetFax/NFELib/NFELib.h"
#if SUPPORT_EMAIL
#include "acornpop3.h"
#endif
#include "PageList.h"
#include "StateKicker.h"
#include "PrintQ.h"
#include "SendQ.h"
#include "RemXfer.h"
#include "RemModem.h"
#include "Screen.h"

#include "wimp.h"
#include "Serial.h"
#include "FaxIF.h"
#include "ZmodemIF.h"
#include "SmtpIF.h"


#include "MimeQ.h"

#include "DebugLib.h"
#include "MimeIF.h"

#include "SetupIF.h"
#include "FileOps.h"
#include "AddrFile.h"

#include "list.h"
#include "emailrx.h"

#include "toolbox.h"
#include "msglib.h"

#include "main.h"




#if SUPPORT_EMAIL
#include "Pop3IF.h"
#endif
/*#include "DebugLib.h"*/

/*
 * N.B.  THE FOLLOWING ARE CITED FOR REMOVAL!
 */
/*>>> start of temporary variables/definitions */
static char* LOC_ADDR_BOOK = "RAM::RamDisc0.$.AddrBook.Local";   /* Location of address book details to send to remote Daytona */
static char* REM_ADDR_BOOK = "RAM::RamDisc0.$.AddrBook.Remote";  /* Location to store received address book details */
/*<<< end of temporary variables/definitions */


#if SUPPORT_EMAIL

#define POP3_DEFAULT_HEADER_SIZE 4096

typedef struct
{
    int number_messages;

    MSG_LIST *message_list;
    int message_list_areanum;

    char *message_headers;
    int message_headers_areanum;
    unsigned int message_headers_areasize;

    NFE_header message_header;

    char         **delete_list;
    unsigned int   delete_list_size;

    UID_MSG_LIST *uid_list;
    int           uid_list_areanum;
    int           uid_list_size;

    unsigned int header_index;
    unsigned int message_index;
    unsigned int delete_index;
    unsigned int page_index;
    unsigned int retry;

    document_handle document_handle;
    message_t       *message;

    list_handle      download_list;
    list_iterator_t  download_list_iter;

    list_iterator_t  message_list_iter;

    char *document_directory;
    char *message_filename;
} pop3_data_t;

/* POP3 email retreive */
static pop3_data_t pop3;

#endif

/*
 * Internal states of RemXfer_StateMachine()
 */

enum _States { IDLE = 0,
 /*fax*/       INCOMING_2a, INCOMING_2b, INCOMING_2c, INCOMING_2d,
               INCOMING_SWITCHOVER,
 /*Daytona*/   INCOMING_3a, INCOMING_3b, INCOMING_3c, INCOMING_3d, INCOMING_3e,
 /*fax*/       OUTGOING_4a, OUTGOING_4b, OUTGOING_4c, /*OUTGOING_4d,*/ OUTGOING_4e, OUTGOING_4f,
               OUTGOING_SWITCHOVER,
 /*Daytona*/   OUTGOING_5a, OUTGOING_5b, OUTGOING_5c, OUTGOING_5d, OUTGOING_5e, OUTGOING_5f
#if SUPPORT_EMAIL
             , OUTGOING_6a, OUTGOING_6b, OUTGOING_6c, OUTGOING_6d,
               OUTGOING_7a, OUTGOING_7b, OUTGOING_7c, OUTGOING_7d, OUTGOING_7e,
               OUTGOING_10a,
               INCOMING_8a, INCOMING_8b, INCOMING_8c, INCOMING_8d, INCOMING_8e, INCOMING_8f, INCOMING_8g, INCOMING_8h, INCOMING_8i, INCOMING_8j,
               INCOMING_8k, INCOMING_8l, INCOMING_8m, INCOMING_8n, INCOMING_8o, INCOMING_8p,
               INCOMING_9a, INCOMING_9b, INCOMING_9c
#endif
             };
typedef enum _States States;




/* Declare function prototypes */
#if SUPPORT_EMAIL
static States  get_message (void);
#endif

static void  RemXfer_ForwardError (
                 void                (*StateMachine) (
                                         int                 messageNumber,
                                         messageDataBlock *  messagedata),
                 int                 messageNumber,
                 int                 forwardNumber,
                 messageDataBlock *  forwardData);

#if SUPPORT_EMAIL
static void RemXfer_SendOSError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber, _kernel_oserror *error);

static void RemXfer_SendRCError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber, /*const*/ char *text, int rc);


static void *  create_dynamic_area (const size_t       size,
                                    const char *const  name,
                                    int *const         area_number);
                                    
static _kernel_oserror *  remove_dynamic_area (const int  area_number);

static void  free_header (NFE_header *  header);

static int  messageid_from_uid (char *const     uid,
                                unsigned int *  message_id);

static char *  uid_from_messageid (const unsigned int  message_id);

static int compare_message_id (const void *  key,
                               const void *  uid_list_entry);

static int  delete_next_message (void);

static int  get_next_message (void);

static void  free_pop3_resources (void);

static int  start_message_download (void);

static int send_memory_report_to_printq (const PageClasses  page_class,
                                         const PageTypes    page_type,
                                         char *const        report);

static void memory_report_file_error (void);

static void  send_file_report_to_printq (const PageClasses  page_class,
                                         const PageTypes    page_type,
                                         char *const        filename);

static int do_missing_page_reports (const NFE_address *const  from);

static void  finish_download_session (void);

static void  wipe_pop3_directory (void);
#endif /*support_email*/



extern void RemXfer_StateMachine(int messageNumber, messageDataBlock *messageData)
{
    static States state = IDLE;
    static BOOL   aborting = FALSE;
    static unsigned int stash_Process_Id;
    static char   directory[256];           /* Document directory */
    static unsigned int stash_loPage;
    static unsigned int stash_hiPage;
    static BOOL   stash_pageStream;
    static unsigned int stash_fax_lastpage;
#if SUPPORT_EMAIL
    /* Email send/retrieve variables */
    static BOOL isp_via_dialler = TRUE; /* when FALSE, using LAN */
    static BOOL tx_flag = FALSE;
    static BOOL rx_flag = FALSE;
    static BOOL tx_error = FALSE;
  /*static unsigned int stash_Process_Id = 0;*/
  /*static unsigned int stash_hiPage;*/
    static char stash_to_emailaddress[256];
#endif

    /* ZModem-orientated variables */
    static int  page_counter = 0;        /* Keep account of current page */
    static char pathname[255];           /* Pathname of file to TX/RX */

    States nextstate = state;

    /* Print state machine status */
    dprintf((NULL, "RemXfer_StateMachine (entry): State => %d; Message => 0x%X\n", state, messageNumber));

    /* switch on error suppression if initiating an ABORT */
    if (messageNumber == PQ_RX_ABORT_INCOMING)
        aborting = TRUE;

    /* switch off error suppression on return to IDLE state after ABORT completes */
    if (state == IDLE)
        aborting = FALSE;

    if (state != IDLE)
    {
        /* common code to reject messages that are only acceptable when IDLE */
        switch (messageNumber)
        {
                case SQ_RX_DIAL_FAX:
                case SQ_RX_DIAL_DAYTONA:
#if SUPPORT_EMAIL				
                case SQ_RX_DIAL_ISP:
#if SUPPORT_LAN
                case SQ_RX_DIAL_LAN:
#endif
#endif
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
                    return;

                case RM_RX_INCOMING_FAX:
                case RM_RX_INCOMING_DAYTONA:
                case RM_RX_INCOMING_VOICE:
                    /* we can't handle this, so hangup */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    return;
        }
    }

    /* main state machine and message decoder */
    switch (state)
    {
        case IDLE:
            switch (messageNumber)
            {
                case SQ_RX_QUERY_IDLE:
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_QUERY_IDLE, NULL);
                    nextstate = state;  /* unchanged */
                    break;

                case RM_RX_AM_IDLE:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_AM_IDLE, NULL);     /* idle now, but an incoming call could start before SendQ receives this */
                    nextstate = state;  /* unchanged */
                    break;

                case RM_RX_INCOMING_FAX:
                    {
                        messageDataBlock *sendMessage;

                        /* request creation of a document directory to hold the incoming fax */
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_DOCUMENT, &sendMessage);
                        sendMessage->data.rx_pq_new_document.Source = PqRxDIRECT;
                        nextstate = INCOMING_2a;
                    }
                    break;

                case RM_RX_INCOMING_DAYTONA:
                    {
                        messageDataBlock *sendMessage;

                        /* request creation of a document directory to hold the incoming fax/text */
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_DOCUMENT, &sendMessage);
                        sendMessage->data.rx_pq_new_document.Source = PqRxDIRECT;
                        nextstate = INCOMING_3a;
                    }
                    break;

                case RM_RX_INCOMING_VOICE:
                    /* we can't handle this, so hangup */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;    /* wait for RemModem to go Idle */
                    break;

                case SQ_RX_DIAL_FAX:
                    {
                        messageDataBlock *sendMessage;

                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DIAL_FAX, &sendMessage);
                        strcpy(sendMessage->data.dial.number, messageData->data.dial.number);
                        nextstate = OUTGOING_4a;
                    }
                    break;

                case SQ_RX_DIAL_DAYTONA:
                    {
                        messageDataBlock *sendMessage;

                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DIAL_DAYTONA, &sendMessage);
                        strcpy(sendMessage->data.dial.number, messageData->data.dial.number);
                        nextstate = OUTGOING_5a;
                    }
                    break;
#if SUPPORT_EMAIL
                case SQ_RX_DIAL_ISP:
                    {
                        messageDataBlock *sendMessage;

                        isp_via_dialler = TRUE;
                        tx_flag = messageData->data.sq_rx_dial_isp.tx_flag;
                        rx_flag = messageData->data.sq_rx_dial_isp.rx_flag;
                        tx_error = FALSE;
                        /* tx_flag  rx_flag                                                */
                        /*  TRUE     TRUE   - normal connect, send mail then retrieve mail */
                        /*  TRUE     FALSE  - send only (water mark triggered)             */
                        /*  FALSE    TRUE   - retrieve only                                */
                        if (tx_flag)
                            StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_START, NULL);   /* Kick off the MIME encoding while the dial-up and LogOn happens */

                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DIAL_ISP, &sendMessage);
                        strcpy(sendMessage->data.dial.number, messageData->data.sq_rx_dial_isp.number);
                        nextstate = OUTGOING_6a;
                    }
                    break;
#if SUPPORT_LAN
                /* not quite the right message name, but everything else is SQ_RX_DIAL_xxx */
                case SQ_RX_DIAL_LAN:
                    {
                        isp_via_dialler = FALSE;
                        tx_flag = messageData->data.sq_rx_dial_lan.tx_flag;
                        rx_flag = messageData->data.sq_rx_dial_lan.rx_flag;
                        tx_error = FALSE;

                        if (tx_flag)
                            StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_START, NULL);   /* Kick off the MIME encoding while the dial-up and LogOn happens */

                        StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_START, NULL);
                        StateKicker_SendMessage(RemXfer_StateMachine, RX_RX_TXCONNECTED, NULL); /* if configured for LAN, assume connected */
                        nextstate = OUTGOING_6a;
                    }
                    break;
#endif
#endif
            }
            break;

     /*                               */
     /* Incoming - from a fax machine */
     /*                               */
        case INCOMING_2a:           /* waiting for PrintQ to tell us where to put the fax being received */
            switch (messageNumber)
            {
                case RM_RX_ERROR:
                    /* Be paranoid: It should be impossible for any error to be reported between the sending of */
                    /* RX_PQ_NEW_DOCUMENT and the reply PQ_RX_NEW_DOCUMENT_DIR (or PQ_RX_ABORT_INCOMING).       */
                    /* If it does happen, assume !Fax will report an error, and recover then.                   */
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    break;

                case PQ_RX_ABORT_INCOMING:
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;    /* wait for RemModem to go Idle */
                    break;

                case PQ_RX_NEW_DOCUMENT_DIR:
                    /* Capture PId & directory details */
                    stash_Process_Id = messageData->data.new_document_dir.pid;
                    strcpy(directory, messageData->data.new_document_dir.directory);

                    /* pass modem ownership to !Fax, telling !Fax where to place the scanned pages */
                    FaxIF_ReceiveFax(REMMODEM, messageData->data.new_document_dir.directory);
                    nextstate = INCOMING_2b;
                    break;
            }
            break;

        case INCOMING_2b:
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    /* tell !Fax to abort reception */
                    FaxIF_Abort(REMMODEM);
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;    /* wait for RemModem to go Idle */
                    break;

#if SUPPORT_SWITCHOVER
                case FX_SWITCHOVER:
#if 0
    /*>>>put this in sometime*/
    /*>>>since we don't distinguish between fax in and data in anywhere, this isn't needed */
                    /* Tell PrintQ we are switching to Daytona data transfer mode */
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_SWITCHTO_DAYTONA, NULL);   /* ie tell address book caller is a Daytona */
#endif
                    /* run a dialler script to change from fax to data mode */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DO_SWITCHOVER, NULL);
                    nextstate = INCOMING_SWITCHOVER;
                    break;
#endif
                case FX_ERROR:
                    /*>>>report error to PrintQ if aborting flag is clear */
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
#if /*THINK*/ 1
                    /* A 'T1 Timeout' error after connection & before any data transfer is */
                    /* probably a voice caller (later T1 Timeouts are treated as genuine). */
                    if ((messageData->data.error.ctx == ctx_Fax_OSError) &&
                        (messageData->data.error.rc == 0x011 /*ERROR_T1_TIMEOUT*/)
                       )
                    {
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_MAYBE_VOICE, NULL);    /* Send a supplementary message */
                    }
#endif
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;
                    break;

                case FX_NORMAL_TERMINATION:
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;
                    break;

                case FX_RECEIVING_PAGE:
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_PAGE, NULL);   /* mainly to trigger animations, but may PQ_RX_ABORT_INCOMING if short of memory */
                    nextstate = INCOMING_2c;
                    break;
            }
            break;

        case INCOMING_2c:
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    /* tell !Fax to abort reception */
                    FaxIF_Abort(REMMODEM);
                  /*StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_ABORTED, NULL);*/
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;    /* wait for RemModem to go Idle */
                    break;

                case FX_ERROR:
                    /*>>>report error*/
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                  /*StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_ABORTED, NULL);*/
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;
                    break;

                case FX_RECEIVED_PAGE:
                    {
                        messageDataBlock *sendMessage;

                        /*set_filetypeDN(directory, messageData->data.fx_received_page.lastpage, FILETYPE_TIFF);*/  /*done by PrintQ*/
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_COMPLETE, &sendMessage);
                        sendMessage->data.rx_pq_page_complete.pageNum  = messageData->data.fx_received_page.lastpage;
                        sendMessage->data.rx_pq_page_complete.pageClass = PageClass_TIFF;
                        sendMessage->data.rx_pq_page_complete.pageType = PageType_TIFF_2DMMR;
                        sendMessage->data.rx_pq_page_complete.fileType = FILETYPE_TIFF;

                        nextstate = INCOMING_2b;    /* wait for next page, or end of document */
                    }
                    break;
            }
            break;

        /* also used from state IDLE with message RM_RX_INCOMING_VOICE */
        case INCOMING_2d:           /* waiting for RemModem to disconnect */
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    nextstate = state;      /* doing our best, so ignore */
                    break;

                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;
            }
            break;
#if SUPPORT_SWITCHOVER
        case INCOMING_SWITCHOVER:
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;    /* wait for RemModem to go Idle */
                    break;

                case RM_RX_ERROR:
                    /*>>>report error to PrintQ if aborting flag is clear */
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;
                    break;

                case RM_RX_SWITCHOVER_DONE: /* c.f. INCOMING_3a with PQ_RX_NEW_DOCUMENT_DIR */
                    /* pass modem ownership to ZModem; tell ZModem to send our address book details */
                    {
                        ZModemMessage zmodemtx;

                        /* PId & directory was captured in INCOMING_2a PQ_RX_NEW_DOCUMENT_DIR */

                        /* Reset page counter ready for receipt of new document */
                        page_counter = 1;
                        dprintf((NULL, "ZModem page counter reset\n"));
/*>>>here*/
                        /* Send our address book details and capabilities, so that the remote (caller) machine may identify us */
                        AddrFile_Create_Recipient_AddressRecord(LOC_ADDR_BOOK); /* should already exist, but will re-create if setup has changed */
                        ZModemIF_SendMessage(REMMODEM, LOC_ADDR_BOOK, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = INCOMING_3b;
                    }
                    break;
            }
            break;
#endif

     /*                                 */
     /* Incoming - from another Daytona */
     /*                                 */
        case INCOMING_3a:           /* waiting for PrintQ to tell us where to put the document being received */
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_3e;
                    break;

                case PQ_RX_NEW_DOCUMENT_DIR:
                    /* pass modem ownership to ZModem; tell ZModem to send our address book details */
                    {
                        ZModemMessage zmodemtx;

                        /* Capture PId & directory details */
                        stash_Process_Id = messageData->data.new_document_dir.pid;
                        strcpy(directory, messageData->data.new_document_dir.directory);

                        /* Reset page counter ready for receipt of new document */
                        page_counter = 1;
                        dprintf((NULL, "ZModem page counter reset\n"));
/*>>>here*/
                        /* Send our address book details, so that the remote (caller) machine may identify us */
                        AddrFile_Create_Recipient_AddressRecord(LOC_ADDR_BOOK); /* should already exist, but will re-create if setup has changed */
                        ZModemIF_SendMessage(REMMODEM, LOC_ADDR_BOOK, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = INCOMING_3b;
                    }
                    break;
            }
            break;

        case INCOMING_3b:           /* waiting for ZModem to confirm transmission of local address */
            switch (messageNumber)
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer local address details) */
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_3e;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Sent local address book details OK, so receive senders' */
                    {
                        ZModemMessage zmodemrx;

                        /* Fetch caller's address book details and list of files it wishes to send */
                        ZModemIF_SendMessage(REMMODEM, REM_ADDR_BOOK, WM_ZMODEM_RX, &zmodemrx);  /*>>>receive into directory.Remote*/
                        nextstate = INCOMING_3c;
                    }
                    break;
            }
            break;

        case INCOMING_3c:           /* waiting for ZModem to confirm receipt of remote address */
            switch (messageNumber)
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer remote address details) */
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_3e;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Received remote address book details OK */
                    {
                        ZModemMessage zmodemrx;

                        if (aborting)
                        {
                            remove(REM_ADDR_BOOK);
                            StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                            StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                            nextstate = INCOMING_3e;
                            break;
                        }

                        /* Decode received caller details - add address details to document */
                        if (AddrFile_Decode_Originator_File(REM_ADDR_BOOK, stash_Process_Id))
                        {
                            /*>>>report some sort of incompatibility error*/
                            remove(REM_ADDR_BOOK);
                            StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                            StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                            nextstate = INCOMING_3e;
                            break;
                        }

                        /* tell PrintQ to display received address book details */
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_DETAILS, NULL);

                        /* Having decided to accept the incoming files, open the received filelist, so we can classify */
                        /* each file as it arrives. NB it MUST be closed & deleted on completion or error */
                        AddrFile_Originator_FileList_Open(REM_ADDR_BOOK);
/*>>>we need to decode the file list here? or can we just receive files and let the PrintQ characterise them based on the file list?*/

                        /* Construct the full pathname for the page (file) to receive */
                        sprintf(pathname, "%s.%d", directory, page_counter);

                        /* Tell PrintQ that the receive is about to commence */
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_PAGE, NULL);

                        /* Receive the page using ZModem protocols */
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_RX, &zmodemrx);
                        nextstate = INCOMING_3d;
                    }
                    break;
            }
            break;

        case INCOMING_3d:           /* waiting for ZModem to confirm receipt of page */
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    {
                        ZModemMessage zmodemabort;

                        /* Inform ZModem, asking it to abort the current transfer */
                        ZModemIF_SendMessage(REMMODEM, NULL, WM_ZMODEM_ABORT, &zmodemabort);

                        AddrFile_Originator_FileList_Close(REM_ADDR_BOOK);      /* close filelist (and delete REM_ADDR_BOOK?) */
                        remove(REM_ADDR_BOOK);
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                        nextstate = INCOMING_3e;
                    }
                    break;

                case ZM_RX_ERROR:  /* Error condition (failed to receive page or at end of document) */
#if 0
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
#endif
                  /*StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_ABORTED, NULL);*/
                    AddrFile_Originator_FileList_Close(REM_ADDR_BOOK);      /* close filelist (and delete REM_ADDR_BOOK?) */
                    remove(REM_ADDR_BOOK);
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_3e;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Confirmation that previous page was received OK */
                    {
                        messageDataBlock *sendMessage;
                        ZModemMessage zmodemrx;
                        PageClasses pageClass = PageClass_TIFF;
                        PageTypes pageType = PageType_TIFF_2DMMR;
                        int fileType = FILETYPE_TIFF;

                        AddrFile_Originator_FileList_GetClassAndType(page_counter, &pageClass, &pageType, &fileType);   /*>>>what about errors*/

                        /*>>>NB assume TIFF for now*/
                        /*set_filetypeDN(directory, page_counter, fileType);*/  /*should this be done by PrintQ*/
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_COMPLETE, &sendMessage);
                        sendMessage->data.rx_pq_page_complete.pageNum  = page_counter;
                        sendMessage->data.rx_pq_page_complete.pageClass = pageClass;
                        sendMessage->data.rx_pq_page_complete.pageType = pageType;
                        sendMessage->data.rx_pq_page_complete.fileType = fileType;

                        /* Increment page counter; construct full pathname of next page (file) to receive */
                        page_counter += 1;
                        sprintf(pathname, "%s.%d", directory, page_counter);
                        dprintf((NULL, "ZModem page counter incremented: page => %d\n", page_counter));

                        /* Tell PrintQ that the receive is about to commence */
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_PAGE, NULL);

                        /* Receive the page using ZModem protocols */
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_RX, &zmodemrx);
                        nextstate = state;        /* unchanged */
                    }
                    break;
            }
            break;

        case INCOMING_3e:           /* waiting for RemModem to disconnect */
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    nextstate = state;        /* doing our best, so ignore */
                    break;

                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;
            }
            break;

     /*                             */
     /* Outgoing - to a fax machine */
     /*                             */
        case OUTGOING_4a:           /* waiting for RemModem to connect */
            switch (messageNumber)
            {
                case RM_RX_DIAL_REJECTED:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);   /* because of incoming call */
                    nextstate = IDLE;   /* code below will issue RX_SQ_GOING_IDLE */
                    break;

                case RM_RX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;    /* wait for RM_RX_GOING_IDLE */
                    break;

                case RM_RX_TXCONNECTED:
                    /* When dialling in fax mode, RM_RX_TXCONNECTED is reported when the dial completes, */
                    /* not when a connection has been established */

                    /* ask SendQ which document is to be sent to the number we connected too */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_WHICH_DOCUMENT, NULL);
                    nextstate = OUTGOING_4b;
                    break;
            }
            break;

        case OUTGOING_4b:           /* waiting for SendQ to tell us which document to send */
            switch (messageNumber)
            {
                case SQ_RX_THIS_DOCUMENT:
                    /* Capture details of document (fax or text) to send */
                    stash_Process_Id = messageData->data.this_document.pid;
                    strcpy(directory, messageData->data.this_document.directory);
                    stash_loPage = messageData->data.this_document.loPage;
                    stash_hiPage = messageData->data.this_document.hiPage;
                    stash_pageStream = (BOOL)messageData->data.this_document.pageStream;
                    /* the above is for the benefit of ZMODEM, incase a data switchover occurs */

                    /* pass modem ownership to !Fax, telling !Fax which pages to send */
                    FaxIF_SendFax(REMMODEM, messageData->data.this_document.directory,
                                            messageData->data.this_document.loPage, /* usually 1 */
                                            0,                                      /*>>>what should page range be?*/
                                            TRUE                                    /* delete pages successfully sent */
                                 );

                    nextstate = OUTGOING_4c;
                    break;
            }
            break;
#if /*THINK*/ 0
/*>>>RCM says: should we have a RX_SQ_SENDING_DOCUMENT message (c.f. email send) to indicate */
/*>>>          that fax has connected to something, because at the momemt SendQ thinks !fax */
/*>>>          connected after the dial completes whereas ISP and ZMODEM get a modem 'connect' */
/*>>>          before asking WHICH_DOCUMENT/SENDING_DOCUMENT */
/*>>>          We would send RX_SQ_SENDING_DOCUMENT in OUTGOING_4c on all messages except FX_ERROR*/
/*>>>          Would also need RX_SQ_SENDING_DOCUMENT after WHICH_DOCUMENT for ZMODEM */
#endif
        case OUTGOING_4c:   /* identical to OUTGOING_4d, but handles FX_SWITCHOVER */
            switch (messageNumber)
            {
#if SUPPORT_SWITCHOVER
                case FX_SWITCHOVER:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_CONNECTED, NULL);           /* special frame indicates call answered by a Daytona or TFax */

                    /* Tell SendQ we are switching from fax to Daytona data transfer mode */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SWITCHTO_DAYTONA, NULL);    /* ie tell address book recipient is a Daytona */

                    /* run a dialler script to change from fax to data mode */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DO_SWITCHOVER, NULL);
                    nextstate = OUTGOING_SWITCHOVER;
                    break;
#endif
                case FX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
#if /*THINK*/ 1
                    /* A 'T1 Timeout' error after connection & before any data transfer is */
                    /* probably a voice receiver (later T1 Timeouts are treated as genuine). */
                    if ((messageData->data.error.ctx == ctx_Fax_OSError) &&
                        (messageData->data.error.rc  == 0x011 /*ERROR_T1_TIMEOUT*/)
                       )
                    {
                        /* Remote receiver has answered, but doesn't whistle like a fax machine */
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_MAYBE_VOICE, NULL);             /* give strong hint to SendQ that its not worth redialling */
                    }
#endif
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);               /* we've sent as much of the current document as we can */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

                case FX_NORMAL_TERMINATION:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

                case FX_SENDING_PAGE:
                    {
                        messageDataBlock *sendMessage;

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_CONNECTED, NULL);                   /* connected to a fax machine */

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_DOCUMENT, &sendMessage);    /* starting to send document */
                        sendMessage->data.rx_sq_sending_document.pid = stash_Process_Id;

                        stash_fax_lastpage = messageData->data.fx_sending_page.lastpage;    /* always reports lastpage of zero for sending first page */
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, &sendMessage);
                      /*sendMessage->data.rx_sq_sending_page.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_sending_page.page = stash_loPage;           /* because of redials, first page may not be one, so use loPage we gave to fax */
                        nextstate = OUTGOING_4e;
                    }
                    break;
            }
            break;
#if 0
        case OUTGOING_4d:   /* identical to OUTGOING_4c, but excludes FX_SWITCHOVER */
            switch (messageNumber)
            {
                case FX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);               /* we've sent as much of the current document as we can */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

                case FX_NORMAL_TERMINATION:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

                case FX_SENDING_PAGE:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, NULL);
                    nextstate = OUTGOING_4e;
                    break;
            }
            break;
#endif

        /* NB We don't use the FX_SENT_PAGE message because it is confusing!. */
        /*    Fax sends multiple FX_SENDING_PAGE & FX_SENT_PAGE pairs if the  */
        /*    receiver requests a retransmission of a corrupt page, or if a   */
        /*    large page is chopped into smaller ones for sending.            */
        /*                                                                    */
        /*    Instead, we use the 'lastpage successfully sent' field of the   */
        /*    FX_SENDING_PAGE & FX_NORMAL_TERMINATION messages to determine   */
        /*    when to send our LX_PQ_SENDING_PAGE & LX_PQ_PAGE_SENT messages. */

        case OUTGOING_4e:
            switch (messageNumber)
            {
                case FX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_FAILED, NULL); /*>>>is this used?*/
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

                case FX_NORMAL_TERMINATION:
                    if (stash_fax_lastpage != messageData->data.fx_normal_termination.lastpage)
                    {
                        messageDataBlock *sendMessage;

                        /* fax now reporting a different lastpage, so must have sent a page */
                        stash_fax_lastpage = messageData->data.fx_normal_termination.lastpage;

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_SENT, &sendMessage);
                      /*sendMessage->data.rx_sq_page_sent.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_page_sent.page = stash_fax_lastpage;
                    }

                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

#if 0
                case FX_SENT_PAGE:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_SENT, NULL);
                    nextstate = OUTGOING_4d;
                    break;
#else
                case FX_SENDING_PAGE:
                    if (stash_fax_lastpage != messageData->data.fx_sending_page.lastpage)
                    {
                        messageDataBlock *sendMessage;

                        /* fax now reporting a different lastpage, so must have sent a page */
                        stash_fax_lastpage = messageData->data.fx_sending_page.lastpage;

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_SENT, &sendMessage);
                      /*sendMessage->data.rx_sq_page_sent.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_page_sent.page = stash_fax_lastpage;

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, &sendMessage);
                      /*sendMessage->data.rx_sq_sending_page.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_sending_page.page = stash_fax_lastpage + 1;
                    }
                    nextstate = OUTGOING_4e;
                    break;
#endif
            }
            break;

        case OUTGOING_4f:
            switch (messageNumber)
            {
                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;
            }
            break;
#if SUPPORT_SWITCHOVER
        case OUTGOING_SWITCHOVER:
            switch (messageNumber)
            {
                case RM_RX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

                case RM_RX_SWITCHOVER_DONE: /* c.f. OUTGOING_5b with SQ_RX_THIS_DOCUMENT */
                    {
                        ZModemMessage zmodemrx;

                        /* directory, was set in OUTGOING_4b */

                        /* Reset page counter ready for new document */
                        page_counter = stash_loPage;    /* stashed by OUTGOING_4b message SQ_RX_THIS_DOCUMENT, usually 1 */
                        dprintf((NULL, "ZModem page counter reset\n"));

                        /* Fetch recipients address and capabilities details */
                        ZModemIF_SendMessage(REMMODEM, REM_ADDR_BOOK, WM_ZMODEM_RX, &zmodemrx);
                        nextstate = OUTGOING_5c;
                    }
                    break;
            }
            break;
#endif
     /*                               */
     /* Outgoing - to another Daytona */
     /*                               */
        case OUTGOING_5a:
            switch (messageNumber)
            {
                case RM_RX_DIAL_REJECTED:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);   /* because of incoming call */
                    nextstate = IDLE;   /* code below will issue RX_SQ_GOING_IDLE */
                    break;

                case RM_RX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_5f;    /* wait for RM_RX_GOING_IDLE */
                    break;

                case RM_RX_TXCONNECTED:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_CONNECTED, NULL);

                    /* ask SendQ which document is to be sent to the number we connected to */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_WHICH_DOCUMENT, NULL);
                    nextstate = OUTGOING_5b;
                    break;
            }
            break;

        case OUTGOING_5b:                       /* waiting for SendQ to tell us which document to send */
            switch (messageNumber)
            {
                case SQ_RX_THIS_DOCUMENT:
                    {
                        ZModemMessage zmodemrx;

                        /* Capture details of document (fax or text) to send */
                        stash_Process_Id = messageData->data.this_document.pid;
                        strcpy(directory, messageData->data.this_document.directory);
                        stash_loPage = messageData->data.this_document.loPage;
                        stash_hiPage = messageData->data.this_document.hiPage;
                        stash_pageStream = (BOOL)messageData->data.this_document.pageStream;

                        /* Reset page counter ready for new document */
                        page_counter = stash_loPage;    /*>>>what about text files*/
                        dprintf((NULL, "ZModem page counter reset\n"));

                        /* Fetch recipients address and capabilities details */
                        ZModemIF_SendMessage(REMMODEM, REM_ADDR_BOOK, WM_ZMODEM_RX, &zmodemrx);
                        nextstate = OUTGOING_5c;
                    }
                    break;
            }
            break;

        case OUTGOING_5c:
            switch (messageNumber)          /* waiting for ZModem to confirm receipt of remote address and capabilities details */
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer remote address details) */
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_5f;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Received remote address book capabilities details OK, so send our address and filelist */
                    {
                        ZModemMessage zmodemtx;

                        /*>>>update screen to show recipient details */
#if 1
                        /*>>>decode address book and capabilities, make sure we can talk to the remote recipient*/
                        /*>>>*/
#if 1
                        if (AddrFile_Decode_Recipient_AddressRecord(REM_ADDR_BOOK, stash_Process_Id))
                        {
                            /*>>>report some sort of incompatibility error*/
                            remove(REM_ADDR_BOOK);
                            StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                            StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                            nextstate = OUTGOING_5f;
                            break;
                        }
#endif
                        /* Send our address book details, so that the remote machine may identify us */
                        /* plus a list of the files we are sending ie create and send an originator file */

                        strcpy(pathname, directory);    /* Construct the full pathname of the file */
                        strcat(pathname, ".Local");
                        if (AddrFile_Create_Originator_File(stash_Process_Id, pathname, stash_loPage, stash_hiPage, stash_pageStream))
                        {   /*>>>errors!*/
                            /* unable to create originator file */
                        }
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_TX, &zmodemtx);  /* send file */
#else
                        /* Send our address book details, so that the remote machine may identify us */
                        ZModemIF_SendMessage(REMMODEM, LOC_ADDR_BOOK, WM_ZMODEM_TX, &zmodemtx);
#endif
                        nextstate = OUTGOING_5d;
                    }
                    break;
            }
            break;

        case OUTGOING_5d:
            switch (messageNumber)          /* waiting for ZModem to confirm transmission of local address */
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer local address details) */
                    remove(pathname);   /* delete our originator_File */
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_5f;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Sent local address book details OK */
                    {
                        messageDataBlock *sendMessage;
                        ZModemMessage zmodemtx;

                        remove(pathname);   /* delete our originator file */

                        /* Tell SendQ that the document send is about to commence */
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_DOCUMENT, &sendMessage);
                        sendMessage->data.rx_sq_sending_document.pid = stash_Process_Id;

                        /* Construct the full pathname of the page (file) to send */
                        sprintf(pathname, "%s.%d", directory, page_counter);

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, &sendMessage);
                      /*sendMessage->data.rx_sq_sending_page.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_sending_page.page = page_counter;

                        /* Send the page using ZModem protocols */
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = OUTGOING_5e;
                    }
                    break;
            }
            break;

        case OUTGOING_5e:
            switch (messageNumber)          /* waiting for ZModem to confirm transmission of page */
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer page or at end of document) */
#if 0
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
#endif
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_FAILED, NULL);
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_5f;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Confirmation that previous page was sent OK */
                    {
                        messageDataBlock *sendMessage;
                        ZModemMessage zmodemtx;

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_SENT, &sendMessage);
                      /*sendMessage->data.rx_sq_page_sent.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_page_sent.page = page_counter;

                        /*>>> Delete page <pathname> here if desired, code follows <<<*/
                        #if 0
                        {
                                _kernel_swi_regs reg;

                                reg.r[0] = 6;
                                reg.r[1] = (int)pathname;
                                _kernel_swi(OS_File, &reg, &reg);
                        }
                        #endif

                        /* Increment page counter; construct full pathname of next page (file) to send */
                        page_counter += 1;
                        sprintf(pathname, "%s.%d", directory, page_counter);
                        dprintf((NULL, "ZModem page counter incremented: page => %d\n", page_counter));
#if 0
/* Old code we need to remove */
/*>>>would be a good idea to check if the page exists here!*/
                        /* Tell SendQ that the send is about to commence */
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, &sendMessage);
                      /*sendMessage->data.rx_sq_sending_page.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_sending_page.page = page_counter;

                        /* Send the page using ZModem protocols */
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = state;       /* unchanged */
#else
/* New code that causes a problem at receiver end - so DON'T use yet */
                        /* Check if the page exists */
                        if (stash_pageStream)
                        {
                            /* our stash_hiPage may be out of date now, so refresh it */
                            stash_hiPage = SendQ_QuerryTx_hiPage(stash_Process_Id);
                        }

                        if (page_counter <= stash_hiPage)
                        {
                            /* Tell SendQ that the send is about to commence */
                            StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, &sendMessage);
                          /*sendMessage->data.rx_sq_sending_page.pid = stash_Process_Id;*/
                            sendMessage->data.rx_sq_sending_page.page = page_counter;

                            /* Send the page using ZModem protocols */
                            ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_TX, &zmodemtx);
                            nextstate = state;       /* unchanged */
                        }
                        else
                        {
                            /* we've sent as many pages as the SendQ wants us to */
#if 1
                            /* use a non-existant file to signal the end of transmission */
                            sprintf(pathname, "%s.Stop", directory);
                            ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_TX, &zmodemtx);
                            nextstate = state;       /* unchanged */
#else
                            StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                            StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                            nextstate = OUTGOING_5f;
#endif
                        }
#endif
                    }
                    break;
            }
            break;

        case OUTGOING_5f:
            switch (messageNumber)
            {
                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;
            }
            break;
#if SUPPORT_EMAIL
     /* Connect to ISP                                                          */
     /*   ie Delete emails that were downloaded and printed by the last connect */
     /*      Send queued emails                                                 */
     /*      Download emails for printing                                       */
        case OUTGOING_6a:           /* waiting for RemModem to connect */
            switch (messageNumber)
            {
                case RM_RX_DIAL_REJECTED:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);   /* because of incoming call */

                    if (tx_flag)
                    {
                        StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_STOP, NULL);    /* Kill the MIME encoding */
                        nextstate = OUTGOING_6b;
                        break;
                    }

                    nextstate = IDLE;   /* code below will issue RX_SQ_GOING_IDLE */
                    break;

                case RM_RX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */

                    if (tx_flag)
                    {
                        tx_error = TRUE;
                        StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_STOP, NULL);    /* Kill the MIME encoding */
                        nextstate = OUTGOING_7e;    /* wait for ME_RX_STOPPED, issue HANGUP, wait for RM_RX_GOING_IDLE */
                    }
                    else
                    {
                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                        nextstate = OUTGOING_10a;   /* wait for RM_RX_GOING_IDLE */
                    }
                    break;
#if SUPPORT_LAN
                case RX_RX_TXCONNECTED: /* if configured for LAN, assume connected */
#endif
                case RM_RX_TXCONNECTED: /* dialled ISP and connected */
                    {
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_CONNECTED, NULL);

                        if (tx_flag)
                        {
                            SmtpIF_Register();
                            nextstate = OUTGOING_7a;
                        }
                        else
                        {
                            Pop3IF_Register();
                            nextstate = INCOMING_8a;
                        }
                    }
                    break;
            }
            break;

        case OUTGOING_6b:           /* dial rejected/failed - waiting for MimeEncoder to stop */
            switch (messageNumber)
            {
                case ME_RX_STOPPED:
                    nextstate = IDLE;   /* code below will issue RX_SQ_GOING_IDLE */
                    break;
            }
            break;

        /* Send queued emails */
        case OUTGOING_7a:           /* trying to register with SMTP */
            switch (messageNumber)
            {
                case SP_RX_REGISTER_ERROR:
                    tx_error = TRUE;
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_STOP, NULL);    /* Kill the MIME encoding */
                    nextstate = OUTGOING_7e;    /* wait for MIME encoder to stop, then hang-up */
                    break;

                case SP_RX_REGISTER_DONE:
                    stash_Process_Id = 0;   /* about to start the first document of this batch of emails */
                    StateKicker_SendMessage(MailQ_StateMachine, RX_MQ_WHICH_MAILFILE, NULL);
                    nextstate = OUTGOING_7b;
                    break;
            }
            break;

        case OUTGOING_7b:           /* waiting for a mailfile to send */
            switch (messageNumber)
            {
                case MQ_RX_NO_MORE_MAIL:
                    if (stash_Process_Id != 0)
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);

                    SmtpIF_DeRegister();
                    nextstate = OUTGOING_7d; /* does a redundent RX_ME_PREFETCH_STOP for us */
                    break;

                case MQ_RX_THIS_MAILFILE:
                    {
                        messageDataBlock *sendMessage;

                        if (stash_Process_Id != messageData->data.this_mailfile.pid)
                        {
                            /* different pid, so this mailfile is a new document */

                            /* stash_Process_Id is initialised to zero in OUTGOING_7a, so if now non-zero, this is not the first document */
                            if (stash_Process_Id != 0)
                                StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);   /* previous document has gone */

                            /* First/next document has emerged from the queue */
                            stash_Process_Id = messageData->data.this_mailfile.pid;
                            SendQ_emailaddress_from_pid(stash_to_emailaddress, stash_Process_Id);

                            StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_DOCUMENT, &sendMessage);    /* starting to send first/next document */
                            sendMessage->data.rx_sq_sending_document.pid = stash_Process_Id;
                        }

                        stash_loPage = messageData->data.this_mailfile.loPage;
                        stash_hiPage = messageData->data.this_mailfile.hiPage;
                      /*strcpy(stash_filename, messageData->data.this_mailfile.filename);*/

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE_RANGE, &sendMessage);
                        sendMessage->data.sending_page_range.pid = stash_Process_Id;
                        sendMessage->data.sending_page_range.loPage = stash_loPage;
                        sendMessage->data.sending_page_range.hiPage = stash_hiPage;

                        SmtpIF_SendMail(messageData->data.this_mailfile.filename, stash_to_emailaddress, setup_from_mailaddress, setup_smtp_server);
                        nextstate = OUTGOING_7c;
                    }
                    break;
            }
            break;

        case OUTGOING_7c:           /* SMTP is sending our file */
            switch (messageNumber)
            {
                case SP_RX_SENDMAIL_ERROR:  /* SmtpIF_SendMail failed */
                    tx_error = TRUE;

#if 1
                    /* tell the MailQ to delete the mailfile - MUST do this to allow MailQ to go Idle */
                    /* one could argue that a different message name should be used */
                    StateKicker_SendMessage(MailQ_StateMachine, RX_MQ_MAILFILE_SENT, NULL);
#endif

                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);               /* we've stopped sending current document */
                    SmtpIF_DeRegister();
                    nextstate = OUTGOING_7d; /* does RX_ME_PREFETCH_STOP for us */
                    break;

                case SP_RX_SENDMAIL_DONE:
                    {
                        messageDataBlock *sendMessage;
                        /* tell the SendQ which range of pages were sent */
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_RANGE_SENT, &sendMessage);
                        sendMessage->data.page_range_sent.pid = stash_Process_Id;
                        sendMessage->data.page_range_sent.loPage = stash_loPage;
                        sendMessage->data.page_range_sent.hiPage = stash_hiPage;

                        /* let the MailQ know the MIME mailfile has gone and can be deleted     */
                        /* if the encoding is stalled through lack of space it will now restart */
                        StateKicker_SendMessage(MailQ_StateMachine, RX_MQ_MAILFILE_SENT, NULL);

                        /* ask for the next MIME mailfile holding either more pages of the current */
                        /* document or the first pages of a new document (different Process_Id)    */
                        StateKicker_SendMessage(MailQ_StateMachine, RX_MQ_WHICH_MAILFILE, NULL);
                        nextstate = OUTGOING_7b;
                    }
                    break;
            }
            break;

        case OUTGOING_7d:           /* waiting for DeRegister to complete */
            switch (messageNumber)
            {
                case SP_RX_DEREGISTER_ERROR:    /* we don't care about errors from Smtp_DeRegister, treat as done */
                case SP_RX_DEREGISTER_DONE:
                    StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_STOP, NULL);    /* Kill the MIME encoding */
                    nextstate = OUTGOING_7e;
                    break;
            }
            break;

        case OUTGOING_7e:           /* common 'end of email transmit' handler */
            switch (messageNumber)
            {
                case ME_RX_STOPPED:
                    /* the send process has completed (with or without error) */
                    /* we only do a mail retrieve if the send succeeded and a retreive was requested */
                    if ((tx_error) || (!rx_flag))
                    {
                        if (isp_via_dialler)
                        {
                            StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                            nextstate = OUTGOING_10a;
                        }
                        else
                        {
                            StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_END, NULL);  /* equivalent to RM_SC_DIAL_COMPLETE*/
                            /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                            nextstate = IDLE;
                        }
                    }
                    else
                    {
                        /* Register with AcornPOP3 module as start of retreive operation */
                        Pop3IF_Register();
                        nextstate = INCOMING_8a;
                    }
                    break;
            }
            break;

        case OUTGOING_10a:          /* waiting for dialler hangup */
            switch (messageNumber)
            {
                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;
            }
            break;

#if SUPPORT_EMAIL

        /* Retrieve emails from ISP */
        case INCOMING_8a:
            switch (messageNumber)
            {
                case P3_RX_REGISTER_CALL_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */

                    if (isp_via_dialler)
                    {
                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                        nextstate = INCOMING_9a;
                    }
                    else
                    {
                        StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_END, NULL);  /* equivalent to RM_SC_DIAL_COMPLETE*/
                        /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                        nextstate = IDLE;
                    }
                    break;
                }

                case P3_RX_REGISTER_DONE:
                /*StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_POP3_LOGON, NULL)*/
                    Pop3IF_Logon(setup_username, setup_password, setup_pop3_server);
                    nextstate = INCOMING_8b;
                    break;

                default:
                    nextstate = INCOMING_8a;
                    break;
            }
            break;

        case INCOMING_8b:
            switch (messageNumber)
            {
                case P3_RX_LOGON_CALL_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    /*Pop3IF_Disconnect();*/
                    Pop3IF_DeRegister();
                    nextstate = INCOMING_9b;
                    break;
                }

                case P3_RX_LOGON_PROCESS_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);
                    Pop3IF_ReleaseData();
                    /*Pop3IF_Disconnect();*/
                    Pop3IF_DeRegister();
                    nextstate = INCOMING_9b;
                    break;
                }

                case P3_RX_LOGON_DONE:
                    Pop3IF_ReleaseData();
                    Pop3IF_CountMessages();
                    nextstate = INCOMING_8c;
                    break;

                default:
                    nextstate = INCOMING_8b;
                    break;
            }
            break;

        case INCOMING_8c:
            switch (messageNumber)
            {
                case P3_RX_COUNT_MESSAGES_CALL_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;
                }

                case P3_RX_COUNT_MESSAGES_PROCESS_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);
                    Pop3IF_ReleaseData();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;
                }

                case P3_RX_COUNT_MESSAGES_DONE:
                {
                    pop3.number_messages = messageData->data.pop3_CountMessages_data.num_messages;
                    pop3.uid_list_size   = messageData->data.pop3_CountMessages_data.num_messages;
                    if (pop3.number_messages == 0)
                    {
/*>>>                       StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_POP3_NO_MESSAGES, NULL);
*/                      Pop3IF_ReleaseData();
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_8o;
                        break;
                    }

                    StateKicker_SendMessage(Screen_StateMachine, RX_SC_POP3_MESSAGE_COUNT, NULL);   /* start rummage through mailbox */

                    /* Block of memory passed to AcornPOP3_GetListOfMessages needs to be
                     * in non-paged out area of memory.  Allocate a temporary dynamic area for
                     * the list of messages to avoid RMA fragmentation.
                     */

                    pop3.message_list = create_dynamic_area (
                                        pop3.number_messages * sizeof (MSG_LIST),
                                        "POP3 message list",
                                        &pop3.message_list_areanum);
                    if (pop3.message_list == NULL)
                    {
/*>>>                       StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_NO_MEMORY, NULL);
*/                      Pop3IF_ReleaseData();
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                        break;
                    }

                    /* Block of memory passed to AcornPOP3_GetListOfUniqueIDs needs to be
                     * in non-paged out area of memory.  Allocate a temporary dynamic area for
                     * the list of messages to avoid RMA fragmentation.
                     */
                    pop3.uid_list = create_dynamic_area (
                                        pop3.uid_list_size * sizeof (UID_MSG_LIST),
                                        "POP3 uid list",
                                        &pop3.uid_list_areanum);
                    if (pop3.uid_list == NULL)
                    {
                        free_pop3_resources ();
                        Pop3IF_ReleaseData();
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                        break;
                    }

                    Pop3IF_ReleaseData();
                    Pop3IF_ListUniqueIDs (pop3.uid_list, pop3.number_messages);
                    nextstate = INCOMING_8d;
                    break;
                }

                default:
                    nextstate = INCOMING_8c;
                    break;
            }
            break;

        case INCOMING_8d:
            switch (messageNumber)
            {
                case P3_RX_LIST_UNIQUEIDS_CALL_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_LIST_UNIQUEIDS_PROCESS_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_ReleaseData();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_LIST_UNIQUEIDS_DONE:
                    Pop3IF_ReleaseData();
                    pop3.delete_index = 0;
                    if (delete_next_message ())
                    {
                        nextstate = INCOMING_8e;
                    }
                    else
                    {
                        Pop3IF_ListMessages (pop3.message_list, pop3.number_messages);
                        nextstate = INCOMING_8f;
                    }
                    break;

                default:
                    nextstate = INCOMING_8d;
                    break;
            }
            break;


        case INCOMING_8e:
            switch (messageNumber)
            {
                case P3_RX_DELETE_MESSAGE_CALL_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_DELETE_MESSAGE_PROCESS_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_ReleaseData();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_DELETE_MESSAGE_DONE:
                    Pop3IF_ReleaseData();

                    /* Finished deleting messages */
                    --pop3.number_messages;

                    if (delete_next_message ())
                    {
                        nextstate = INCOMING_8e;
                    }
                    else
                    {
                        /* Destroy old delete list */
                        free (pop3.delete_list);
                        pop3.delete_list = NULL;
                        pop3.delete_list_size = 0;
                        pop3.delete_index = 0;
                        if (pop3.number_messages > 0)
                        {
                            Pop3IF_ListMessages (pop3.message_list, pop3.number_messages);
                            nextstate = INCOMING_8f;
                        }
                        else
                        {
                            remove_dynamic_area (pop3.uid_list_areanum);
                            pop3.uid_list = NULL;
                            Pop3IF_Disconnect ();
                            nextstate = INCOMING_8o;
                        }
                    }
                    break;

                default:
                    nextstate = INCOMING_8e;
                    break;
            }
            break;

        case INCOMING_8f:
            switch (messageNumber)
            {
                case P3_RX_LIST_MESSAGES_CALL_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;
                }

                case P3_RX_LIST_MESSAGES_PROCESS_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_ReleaseData();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;
                }

                case P3_RX_LIST_MESSAGES_DONE:
                    /* Allocate a dynamic area to store the message headers.  Start off
                     * allocating 4k as a reasonable maximum.  If this is ever too short for
                     * a given message's headers then POP3 will return how much memory is
                     * needed, so the area can be reallocated then.
                     */
                    pop3.message_headers_areasize = POP3_DEFAULT_HEADER_SIZE;
                    pop3.message_headers = create_dynamic_area (pop3.message_headers_areasize,
                                                                "POP3 message headers",
                                                                &pop3.message_headers_areanum);
                    if (pop3.message_headers == NULL)
                    {
/*>>>                       StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_NO_MEMORY, NULL);
*/
                        free_pop3_resources ();
                        Pop3IF_ReleaseData();
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                        break;
                    }

                    /* Create new delete list */
                    pop3.delete_list = malloc (pop3.number_messages * sizeof (char *));
                    if (pop3.delete_list == NULL)
                    {
                        free_pop3_resources ();
                        Pop3IF_ReleaseData();
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                        break;
                    }

                    pop3.delete_list_size = 0;
                    pop3.delete_index = 0;
                    pop3.header_index = 0;
                    pop3.retry = 0;
                    Pop3IF_ReleaseData();
                    Pop3IF_GetHeader (pop3.message_headers,
                                      pop3.message_headers_areasize,
                                      pop3.message_list[pop3.header_index].msg_id);
                    nextstate = INCOMING_8g;
                    break;

                default:
                    nextstate = INCOMING_8f;
                    break;
            }
            break;

        case INCOMING_8g:
            switch (messageNumber)
            {
                case P3_RX_GET_HEADER_CALL_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_GET_HEADER_PROCESS_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_ReleaseData();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_GET_HEADER_RETRY:
                    /* There wasn't enough space to store the headers for this message.
                     * Reallocate enough memory and try again.
                     */

                    Pop3IF_ReleaseData();

                    if (pop3.retry)
                    {
                        /* We already have retried, so this would be a retry
                         * of the retry.  Something is clearly very wrong,
                         * so abandon the download.
                         */
                        RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                        free_pop3_resources ();
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                    }
                    else
                    {
                        remove_dynamic_area (pop3.message_headers_areanum);

                        pop3.message_headers = create_dynamic_area (
                                                   messageData->data.pop3_GetHeader_data.message_size,
                                                   "POP3 message headers",
                                                   &pop3.message_headers_areanum);
                        if (pop3.message_headers == NULL)
                        {
    /*>>>                        StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_NO_MEMORY, NULL);
    */
                            free_pop3_resources ();
                            Pop3IF_Disconnect();
                            nextstate = INCOMING_9c;
                            break;
                        }

                        pop3.message_headers_areasize = messageData->data.pop3_GetHeader_data.message_size;
                        Pop3IF_GetHeader (pop3.message_headers,
                                          pop3.message_headers_areasize,
                                          pop3.message_list[pop3.header_index].msg_id);
                        pop3.retry = 1;
                        nextstate = INCOMING_8g;
                    }
                    break;

                case P3_RX_GET_HEADER_DONE:
                {
                    messageDataBlock *send_message;


                    pop3.retry = 0;
                    /* It is absolutely vital that the header structure is cleared before each message fetch
                     * otherwise data from the previous fetch could be picked up.
                     */
                    free_header (&pop3.message_header);

                    StateKicker_SendMessage (MimeDecode_StateMachine, RX_MD_DECODE_HDR, &send_message);
                    send_message->data.decode_header.raw_header = pop3.message_headers;
                    send_message->data.decode_header.message_header = (void*) &pop3.message_header; /*RCM cast NFE_header* to void* */
                    send_message->data.decode_header.size = messageData->data.pop3_GetHeader_data.message_size;
                    send_message->data.decode_header.file = FALSE;
                    Pop3IF_ReleaseData ();
                    nextstate = INCOMING_8h;
                    break;
                }

                default:
                    nextstate = INCOMING_8g;
                    break;
            }
            break;

        case INCOMING_8h:
            switch (messageNumber)
            {
                case MD_RX_DECODE_HDR_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;
                }

                case MD_RX_DECODE_HDR_DONE:
                {
                    int delete_message;
                    int email_new_message_rc;
                    char *  unique_id;

                    unique_id = uid_from_messageid (pop3.message_list[pop3.header_index].msg_id);
                    if (unique_id == NULL)
                    {
                        /* Message has mysteriously disappeared from mailbox.  Skip it and try the next one. */
                        ++pop3.header_index;
                        if (pop3.header_index < pop3.number_messages)
                        {
                            /* More headers to download */
                            pop3.retry = 0;
                            Pop3IF_GetHeader (pop3.message_headers,
                                              pop3.message_headers_areasize,
                                              pop3.message_list[pop3.header_index].msg_id);

                            nextstate = INCOMING_8g;
                        }
                        else
                        {
                            /* No more headers to download */

                            remove_dynamic_area (pop3.message_headers_areanum);
                            pop3.message_headers = NULL;

                            if (start_message_download ())
                            {
                                /* Out of memory */
                                nextstate = INCOMING_9c;
                            }
                            else
                            {
                                nextstate = INCOMING_8i;
                            }
                        }

                        break;
                    }

                    email_new_message_rc = emailrx_new_message (pop3.message_list[pop3.header_index].msg_size,
                                                                &pop3.message_header,
                                                                unique_id,
                                                                &delete_message);
#ifdef TEST
                    emailrx_dump_doc_list_to_file (emailrx_get_doc_list (),
                                                   "ADFS::4.$.doclist");
#endif
                    switch (email_new_message_rc)
                    {
                        case 0:    /* call successfully */
                            /* Check if message should be marked for deletion immediately */
                            if (delete_message)
                            {
                                pop3.delete_list[pop3.delete_list_size] = malloc (strlen (unique_id) + 1);
                                if (pop3.delete_list[pop3.delete_list_size] != NULL)
                                {
                                    strcpy (pop3.delete_list[pop3.delete_list_size],
                                            unique_id);
                                    ++pop3.delete_list_size;
                                }
                            }

                            ++pop3.header_index;
                            if (pop3.header_index < pop3.number_messages)
                            {
                                /* More headers to download */
                                Pop3IF_GetHeader (pop3.message_headers,
                                                  pop3.message_headers_areasize,
                                                  pop3.message_list[pop3.header_index].msg_id);

                                nextstate = INCOMING_8g;
                            }
                            else
                            {
                                /* No more headers to download */

                                remove_dynamic_area (pop3.message_headers_areanum);
                                pop3.message_headers = NULL;

                                if (start_message_download ())
                                {
                                    /* Out of memory */
                                    nextstate = INCOMING_9c;
                                }
                                else
                                {
                                    nextstate = INCOMING_8i;
                                }
                            }
                            break;

                        case 1:    /* couldn't add message, but was able to recover */
                            remove_dynamic_area (pop3.message_headers_areanum);
                            pop3.message_headers = NULL;

                            if (start_message_download ())
                            {
                                /* Out of memory */
                                nextstate = INCOMING_9c;
                            }
                            else
                            {
                                nextstate = INCOMING_8i;
                            }
                            break;

                        default:    /* couldn't add message and couldn't recover */
                        {
#if 1
                            /* RCM says: we MUST use RemXfer_SendRCError (or RemXfer_SendOSError) rather than rolling our own error messages */
                            RemXfer_SendRCError(PrintQ_MessageHandler, RX_PQ_ERROR, "Not enough memory to scan mailbox.", 1);
#else
                            messageDataBlock *send_message;

                            StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_ERROR, &send_message);
                            send_message->data.os_error.err.errnum = 0;
                            strcpy (send_message->data.os_error.err.errmess, "Not enough memory to scan mailbox.");
#endif
                            free_pop3_resources ();
                            Pop3IF_Disconnect();
                            nextstate = INCOMING_9c;
                            break;
                        }
                    }
                    break;
                }

                default:
                    nextstate = INCOMING_8h;
                    break;
            }
            break;


        case INCOMING_8i:
            switch (messageNumber)
            {
                case RX_RX_GET_DOCUMENT:
                    if ((pop3.download_list_iter.finished) (&pop3.download_list_iter))
                    {
                        finish_download_session ();
                        nextstate = INCOMING_8o;
                    }

                    else
                    {
                        messageDataBlock *sendMessage;

                        StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_NEW_DOCUMENT, &sendMessage);
                        sendMessage->data.rx_pq_new_document.Source = PqRxISP;

                        nextstate = INCOMING_8j;
                    }
                    break;

                default:
                    nextstate = INCOMING_8i;
                    break;
            }
            break;


        case INCOMING_8j:
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                {
                    /* The word 'abort' is perhaps a bit strong.  What this really means is that
                     * the PrintQ just wants us to not give it any more stuff, so we just clean
                     * up - anything we throw away will be got in the next session.
                     */
                    finish_download_session ();
                    nextstate = INCOMING_8o;
                    break;
                }

                case PQ_RX_NEW_DOCUMENT_DIR:
                {
                    char report[4097];

                    pop3.document_directory = malloc (strlen (messageData->data.new_document_dir.directory) + 1);
                    if (pop3.document_directory == NULL)
                    {
#if 1
                        /* RCM says: we MUST use RemXfer_SendRCError (or RemXfer_SendOSError) rather than rolling our own error messages */
                        RemXfer_SendRCError(PrintQ_MessageHandler, RX_PQ_ERROR, "Not enough memory to print document.", 2);
#else
                        messageDataBlock *send_message;

                        StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_ERROR, &send_message);
                        send_message->data.os_error.err.errnum = 0;
                        strcpy (send_message->data.os_error.err.errmess, "Not enough memory to print document.");
#endif
                        free_pop3_resources ();
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                        break;
                    }

                    strcpy (pop3.document_directory,
                            messageData->data.new_document_dir.directory);

                    pop3.document_handle = (pop3.download_list_iter.current) (&pop3.download_list_iter);

                    list_initialise_iterator (&pop3.message_list_iter,
                                              emailrx_get_doc_msg_list (pop3.document_handle));

                    (void) (pop3.message_list_iter.reset) (&pop3.message_list_iter);

                    pop3.page_index = 0;

                    {
                        AddrFile_FillAddressRecord(messageData->data.new_document_dir.pid,
                            /* serial number */    pop3.message_header.details.serial_num,
                            /* company name  */    pop3.message_header.config.organisation,
                            /* contact name  */    pop3.message_header.from.real_name,
                            /* fax number    */    pop3.message_header.config.fax_num,     /* NB email format */
                            /* voice number  */    pop3.message_header.config.phone_num,   /* NB email format */
                            /* email address */    pop3.message_header.from.address,
                            /* software rev. */    pop3.message_header.details.software_rev_major, pop3.message_header.details.software_rev_minor,
                            /* device class  */    pop3.message_header.details.device_class,
                            /* receipt_to    */    pop3.message_header.return_receipt_to.real_name,
                            /* receipt_to    */    pop3.message_header.return_receipt_to.address
                                                  );
                    }
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_DETAILS, NULL);

                    StateKicker_SendMessage (RemXfer_StateMachine,
                                             RX_RX_GET_MESSAGE,
                                             NULL);


                    /* Check to see if a cover sheet is required for this document.
                     * This could be a page range report or a document size confirmation message.
                     */
                    if (emailrx_cover_sheet (pop3.document_handle,
                                             report,
                                             sizeof (report),
                                             &pop3.message_header))
                    {
                        ++pop3.page_index;  /*RCM put in to make cover sheet page 1*/

                        if (send_memory_report_to_printq (PageClass_Text,
                                                          PageType_Text_CoverPage,
                                                          report))
                        {
                            /* error occured */
                            nextstate = INCOMING_9c;
                            break;
                        }
                    }

                    ++pop3.page_index;

                    nextstate = INCOMING_8k;
                    break;
                }

                default:
                    nextstate = INCOMING_8j;
                    break;
            }
            break;


        case INCOMING_8k:
            switch (messageNumber)
            {
                case RX_RX_GET_MESSAGE:
                    pop3.message_filename = malloc (strlen (POP3_DIR) + 16);
                        /* more than enough for maximum possible number messages */
                    if (pop3.message_filename == NULL)
                    {
#if 1
                        /* RCM says: we MUST use RemXfer_SendRCError (or RemXfer_SendOSError) rather than rolling our own error messages */
                        RemXfer_SendRCError(PrintQ_MessageHandler, RX_PQ_ERROR, "Not enough memory to download EMail message.", 3);
#else
                        messageDataBlock *send_message;

                        StateKicker_SendMessage (PrintQ_MessageHandler,
                                                 RX_PQ_ERROR,
                                                 &send_message);

                        send_message->data.os_error.err.errnum = 0;
                        strcpy (send_message->data.os_error.err.errmess,
                                "Not enough memory to download EMail message.");
#endif
                        free_pop3_resources ();
                        Pop3IF_Disconnect();
                        wipe_pop3_directory ();
                        nextstate = INCOMING_9c;
                    }
                    else
                    {
                        nextstate = get_message ();
                    }
                    break;

                default:
                    nextstate = INCOMING_8k;
                    break;
            }
            break;

        case INCOMING_8l:
            switch (messageNumber)
            {
                case P3_RX_GET_MESSAGE_CALL_ERROR:
                case P3_RX_GET_X_LINES_OF_MESSAGE_CALL_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_Disconnect();
                    wipe_pop3_directory ();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_GET_MESSAGE_PROCESS_ERROR:
                case P3_RX_GET_X_LINES_OF_MESSAGE_PROCESS_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_ReleaseData();
                    Pop3IF_Disconnect();
                    wipe_pop3_directory ();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_GET_MESSAGE_RETRY:
                    Pop3IF_ReleaseData ();
                    if (pop3.retry)
                    {
                        /* We already have retried, so this would be a retry
                         * of the retry.  Something is clearly very wrong,
                         * so abandon the download.
                         */
                        RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                        free_pop3_resources ();
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                    }
                    else
                    {
                        /* The POP3 server lied about the size of the message.
                         * Find out how large the message really is then try again.
                         */
                        pop3.message->size = messageData->data.pop3_GetMessage_data.message_size;
                        pop3.retry = 1;
                        nextstate = get_message ();
                    }
                    break;

                case P3_RX_GET_X_LINES_OF_MESSAGE_RETRY:
                    Pop3IF_ReleaseData ();
                    if (pop3.retry)
                    {
                        /* We already have retried, so this would be a retry
                         * of the retry.  Something is clearly very wrong,
                         * so abandon the download.
                         */
                        RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                        free_pop3_resources ();
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                    }
                    else
                    {
                        /* The POP3 server lied about the size of the message.
                         * Find out how large the message really is then try again.
                         */
                        pop3.message->size = messageData->data.pop3_GetHeader_data.message_size;
                        pop3.retry = 1;
                        nextstate = get_message ();
                    }
                    break;

                case P3_RX_GET_MESSAGE_DONE:
                case P3_RX_GET_X_LINES_OF_MESSAGE_DONE:
                {
                    messageDataBlock *send_message;

                    pop3.retry = 0;

                    /* It is absolutely vital that the header structure is cleared before each message fetch
                     * otherwise data from the previous fetch could be picked up.
                     */
                    free_header (&pop3.message_header);

                    StateKicker_SendMessage (MimeDecode_StateMachine, RX_MD_DECODE_HDR, &send_message);
                    send_message->data.decode_header.raw_header = pop3.message_filename;
                    send_message->data.decode_header.message_header = (void*) &pop3.message_header; /*RCM cast NFE_header* to void* */
                    send_message->data.decode_header.size = pop3.message->size;
                    send_message->data.decode_header.file = TRUE;
                    Pop3IF_ReleaseData ();
                    nextstate = INCOMING_8m;
                    break;
                }

                default:
                    nextstate = INCOMING_8l;
                    break;
            }
            break;

        case INCOMING_8m:
            switch (messageNumber)
            {
                case MD_RX_DECODE_HDR_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_Disconnect();
                    wipe_pop3_directory ();
                    nextstate = INCOMING_9c;
                    break;
                }

                case MD_RX_DECODE_HDR_DONE:
                {
                    messageDataBlock *send_message;

                    StateKicker_SendMessage (MimeDecode_StateMachine,
                                             RX_MD_DECODE_MSG,
                                             &send_message);
                    send_message->data.decode_message.filename = pop3.message_filename;
                    send_message->data.decode_message.document_directory = pop3.document_directory;
                    send_message->data.decode_message.size = pop3.message->size;
                    send_message->data.decode_message.start_page = pop3.page_index;
                    send_message->data.decode_message.message_header = &pop3.message_header;

                    nextstate = INCOMING_8n;
                    break;
                }

                default:
                    nextstate = INCOMING_8m;
                    break;
            }
            break;


        case INCOMING_8n:
            switch (messageNumber)
            {
                case MD_RX_NEW_PAGE:
                    StateKicker_SendMessage (PrintQ_MessageHandler,
                                             RX_PQ_NEW_PAGE,
                                             NULL);
                    nextstate = INCOMING_8n;
                    break;

                case MD_RX_PAGE_COMPLETE:
                {
                        messageDataBlock *sendMessage;

                        /* You mustn't use pop3.page_index at this point.
                         * pop3.page_index is invalid between RX_MD_DECODE_MSG and MD_RX_DECODE_MSG_DONE.
                         */

                        set_filetypeDN (pop3.document_directory,
                                        messageData->data.md_rx_page_complete.pageNum,
                                        messageData->data.md_rx_page_complete.fileType);    /*>>>should this be done by PrintQ???*/
                        StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_PAGE_COMPLETE, &sendMessage);
                        sendMessage->data.rx_pq_page_complete.pageNum   = messageData->data.md_rx_page_complete.pageNum;
                        sendMessage->data.rx_pq_page_complete.pageClass = messageData->data.md_rx_page_complete.pageClass;
                        sendMessage->data.rx_pq_page_complete.pageType  = messageData->data.md_rx_page_complete.pageType;
                        sendMessage->data.rx_pq_page_complete.fileType  = messageData->data.md_rx_page_complete.fileType; /* FILETYPE_TIFF, FILETYPE_TEXT or FILETYPE_CONFIG */

                        nextstate = INCOMING_8n;
                        break;
                }

                case MD_RX_DECODE_MSG_DONE:
                {
                    /* Check to see if a delivery recepit should be generated for this email
                     * and if so place a tokenised file in the PrintQ.
                     */

                    /* Delete the original message */
#ifndef PRESERVE_POP3
                    _swix (OS_File, _INR (0, 1), 6, pop3.message_filename);
#endif

                    /* Mark the message for deletion from the server on the next connection */
                    pop3.delete_list[pop3.delete_list_size] = malloc (strlen (pop3.message->unique_id) + 1);
                    if (pop3.delete_list[pop3.delete_list_size] != NULL)
                    {
                        strcpy (pop3.delete_list[pop3.delete_list_size], pop3.message->unique_id);
                        ++pop3.delete_list_size;
                    }
                    /* If the above allocation fails then don't panic: all it means is that the message won't
                     * get deleted, and may end up getting downloaded and printed twice.
                     */

                    free (pop3.message_filename);
                    pop3.message_filename = NULL;

                    pop3.page_index = messageData->data.message_decoded.next_page;

                    ++pop3.message_index;
                    (void) (pop3.message_list_iter.next) (&pop3.message_list_iter);
                    StateKicker_SendMessage (RemXfer_StateMachine,
                                             RX_RX_GET_MESSAGE,
                                             NULL);
                    nextstate = INCOMING_8k;
                    break;
                }

                case MD_RX_DECODE_MSG_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    free_pop3_resources ();
                    Pop3IF_Disconnect();
                    wipe_pop3_directory ();
                    nextstate = INCOMING_9c;
                    break;

                default:
                    nextstate = INCOMING_8n;
                    break;
            }
            break;


        case INCOMING_8o:
            switch (messageNumber)
            {
                case P3_RX_DISCONNECT_CALL_ERROR:
                case P3_RX_DISCONNECT_PROCESS_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    /* deliberate drop-through into next case */
                }

                case P3_RX_DISCONNECT_DONE:
                    Pop3IF_DeRegister();
                    nextstate = INCOMING_8p;
                    break;

                default:
                    nextstate = INCOMING_8o;
                    break;
            }
            break;


        case INCOMING_8p:
            switch (messageNumber)
            {
                case P3_RX_DEREGISTER_CALL_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    /* deliberate drop-through into next case */
                }

                case P3_RX_DEREGISTER_DONE:
                {
                    StateKicker_SendMessage(Screen_StateMachine, RX_SC_POP3_DOWNLOAD_COMPLETE, NULL);   /* thumbs up, download complete */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = IDLE;
                    break;
                }

                default:
                    nextstate = INCOMING_8p;
                    break;
            }
            break;

#endif

        case INCOMING_9a:
            switch (messageNumber)
            {
                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;

                default:
                    nextstate = INCOMING_9a;
                    break;
            }
            break;


        case INCOMING_9b:
            switch (messageNumber)
            {
                case P3_RX_DEREGISTER_CALL_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */

                    if (isp_via_dialler)
                    {
                        StateKicker_SendMessage (RemModem_StateMachine, RX_RM_HANGUP, NULL);
                        nextstate = INCOMING_9a;
                    }
                    else
                    {
                        StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_END, NULL);  /* equivalent to RM_SC_DIAL_COMPLETE*/
                        /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                        nextstate = IDLE;
                    }
                    break;

                case P3_RX_DEREGISTER_DONE:
                    if (isp_via_dialler)
                    {
                        StateKicker_SendMessage (RemModem_StateMachine, RX_RM_HANGUP, NULL);
                        nextstate = INCOMING_9a;
                    }
                    else
                    {
                        StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_END, NULL);  /* equivalent to RM_SC_DIAL_COMPLETE*/
                        /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                        nextstate = IDLE;
                    }
                    break;

                default:
                    nextstate = INCOMING_9b;
                    break;
            }
            break;

        case INCOMING_9c:
            switch (messageNumber)
            {
                case P3_RX_DISCONNECT_CALL_ERROR:
                case P3_RX_DISCONNECT_PROCESS_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    /* deliberate drop-through into next case */
                }

                case P3_RX_DISCONNECT_DONE:
                    Pop3IF_DeRegister();
                    nextstate = INCOMING_9b;
                    break;

                default:
                    nextstate = INCOMING_9c;
                    break;
            }
            break;
/*SUPPORT_EMAIL*/ 
#endif
    } /* switch (state) */

    /* report RX_SQ_GOING_IDLE if going idle from a non-idle state */
    if ((nextstate == IDLE) && (state != IDLE))
        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL);

    state = nextstate;

    /* Print state machine status on exit */
    dprintf((NULL, "RemXfer_StateMachine (exit): Next state => %d\n", state));
}


#if SUPPORT_EMAIL

/* -----------------------------------------------------------------------------
   get_message

   Download a message from the POP3 server.

   Returns
   next state for RemXfer state machine
 */

static States get_message (void)
{
    States  nextstate;

    if (get_next_message ())
    {
        /* Message being fetched */
        nextstate = INCOMING_8l;
    }
    else
    {
        char  delivery_conf_report_filename[257];

        /* No more messages for this document */
        pop3.retry = 0;

        /* Check if a missing page report is required for this document */
        if (emailrx_need_missing_page_report (pop3.document_handle))
        {
            if (do_missing_page_reports (&pop3.message_header.from) != 0)
            {
                /* error occured */
                nextstate = INCOMING_9c;
                return nextstate;
            }
        }

        /* Check if a delivery confirmation report is required for this
         * document.
         */
        sprintf (delivery_conf_report_filename,
                 "%s.%d",
                 pop3.document_directory,
                 pop3.page_index);

        if (emailrx_printed_page_report (pop3.document_handle,
                                         delivery_conf_report_filename,
                                         &pop3.message_header) == 1)
        {
            send_file_report_to_printq (PageClass_SendReceipt,
                                        PageType_SendReceipt,
                                        delivery_conf_report_filename);
        }

        StateKicker_SendMessage (PrintQ_MessageHandler,
                                 RX_PQ_DOCUMENT_COMPLETE,
                                 NULL);

        free (pop3.document_directory);
        pop3.document_directory = NULL;

        /* Move onto the next document */
        (void) (pop3.download_list_iter.next) (&pop3.download_list_iter);
        StateKicker_SendMessage (RemXfer_StateMachine,
                                 RX_RX_GET_DOCUMENT,
                                 NULL);
        nextstate = INCOMING_8i;
    }


    return nextstate;
}

#endif


/* -----------------------------------------------------------------------------
   RemXfer_ForwardError

   Forward an error message to another state machine.

   Inputs
   state_machine: state machine to forward error to
   messageNumber: message number to send to state machine
   forwardNumber: unused
   forwardData:   message data to forward to state machine
 */

static void  RemXfer_ForwardError (
                 void                (*StateMachine) (
                                         int                 messageNumber,
                                         messageDataBlock *  messagedata),
                 int                 messageNumber,
                 int                 forwardNumber,
                 messageDataBlock *  forwardData)
{
    messageDataBlock *sendMessage;

    StateKicker_SendMessage(StateMachine, messageNumber, &sendMessage);
    sendMessage->data = forwardData->data;

#if 0 /*THINK*/
    /* Map a small set of Fax errors and a small */
    /* set of modem errors onto common HL_Errors */

    switch (forwardNumber == FX_ERROR)
    {
        case FX_ERROR:
            switch (forwardData->data.fx_error.rc)
            {
                case Error_No_Dialtone:
                = HL_ERROR_NoDialTone;
                    break;

                case Error_Busy:
                = HL_ERROR_LineBusy;
                    break;

                case Error_No_Answer:
                = HL_ERROR_NoAnswer
                    break;

                case Error_No_Carrier:
                = HL_ERROR_NoCarrier
                    break;
            }
            break;

        case RM_RX_ERROR:
            switch (forwardData->data.rm_error.rc)
            {
                case Dialler_AbortedScript_NoDialtone:
                = HL_ERROR_NoDialTone;
                    break;

                case Dialler_AbortedScript_Busy
                = HL_ERROR_LineBusy;
                    break;

                case Dialler_AbortedScript_NoAnswer
                = HL_ERROR_NoAnswer
                    break;

                case Dialler_AbortedScript_NoCarrier
                = HL_ERROR_NoCarrier
                    break;
            }
            break;

    }
#endif
}


#if SUPPORT_EMAIL

/*
 * Send an error of our own
 */
static void RemXfer_SendRCError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber, /*const*/ char *text, int rc)
{
    StateKicker_SendRCError(StateMachine, messageNumber, code_RemXfer_RCError, ctx_RemXfer_RCError, rc, text);
}




static void RemXfer_SendOSError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber, _kernel_oserror *error)
{
    StateKicker_SendOSError(StateMachine, messageNumber, code_RemXfer_OSError, ctx_RemXfer_OSError, error);
}



/* -----------------------------------------------------------------------------
   create_dynamic_area

   Create a dynamic area of a given size.

   Inputs
   size: required size of dynamic area
   name: name to call dynamic area

   Outputs
   area_number: number allocated to dynamic area by OS

   Returns
   success: pointer to start of dynamic area
   failure: NULL
 */

static void *  create_dynamic_area (const size_t       size,
                                    const char *const  name,
                                    int *const         area_number)
{
    void *area_base;

    if (_swix (OS_DynamicArea,
               _INR (0, 8) | _OUT (1) | _OUT (3),

               0,
               -1,
               size,
               -1,
               1<<7,
               size,
               0,
               0,
               name,

               area_number,
               &area_base) != NULL)
    {
        return NULL;
    }

    return area_base;
}




/* -----------------------------------------------------------------------------
   remove_dynamic_area

   Remove a dynamic area.

   Inputs
   area_number: number of dynamic area to remove

   Returns
   success: NULL
   failure: pointer to error block
*/

static _kernel_oserror *  remove_dynamic_area (const int  area_number)
{
    return _swix (OS_DynamicArea,
                  _INR (0, 1),

                  1,
                  area_number);
}




/* -----------------------------------------------------------------------------
   free_header

   Destory an NFE_header data structure.  Relies on unallocated pointers being
   NULL.

   Inputs
   header: pointer to NFE_header data structure
 */

static void  free_header (NFE_header *  header)
{
    if (header->to.address != NULL)
    {
        free (header->to.address);
        header->to.address = NULL;
    }

    if (header->to.real_name != NULL)
    {
        free (header->to.real_name);
        header->to.real_name = NULL;
    }

    if (header->from.address != NULL)
    {
        free (header->from.address);
        header->from.address = NULL;
    }

    if (header->from.real_name != NULL)
    {
        free (header->from.real_name);
        header->from.real_name = NULL;
    }

    if (header->return_receipt_to.address != NULL)
    {
        free (header->return_receipt_to.address);
        header->return_receipt_to.address = NULL;
    }

    if (header->return_receipt_to.real_name != NULL)
    {
        free (header->return_receipt_to.real_name);
        header->return_receipt_to.real_name = NULL;
    }

    header->date = 0;

    if (header->date_hdr != NULL)
    {
        free (header->date_hdr);
        header->date_hdr = NULL;
    }

    if (header->subject != NULL)
    {
        free (header->subject);
        header->subject = NULL;
    }

    header->id.first_page_num = 0;
    header->id.last_page_num = 0;
    header->id.doc_num = 0;
    header->id.msg_num_pages = 0;
    header->id.exact_num_pages = TRUE;

    if (header->id.iap_username != NULL)
    {
        free (header->id.iap_username);
        header->id.iap_username = NULL;
    }

    if (header->details.device != NULL)
    {
        free (header->details.device);
        header->details.device = NULL;
    }

    header->details.device_class = 0;
    memset (header->details.serial_num,
            0,
            SERIAL_LEN);
    header->details.software_rev_major = 0;
    header->details.software_rev_minor = 0;

    if (header->details.encryption != NULL)
    {
        free (header->details.encryption);
        header->details.encryption = NULL;
    }

    if (header->details.encryption_rev != NULL)
    {
        free (header->details.encryption_rev);
        header->details.encryption_rev = NULL;
    }

    if (header->details.domain != NULL)
    {
        free (header->details.domain);
        header->details.domain = NULL;
    }

    if (header->config.fax_num != NULL)
    {
        free (header->config.fax_num);
        header->config.fax_num = NULL;
    }

    if (header->config.phone_num != NULL)
    {
        free (header->config.phone_num);
        header->config.phone_num = NULL;
    }

    if (header->config.organisation != NULL)
    {
        free (header->config.organisation);
        header->config.organisation = NULL;
    }

    header->netfax_msg_class = NFE_NFMC_NONE;
    header->msg_class = NFE_MC_UNKNOWN;
}

#endif


#if SUPPORT_EMAIL


/* -----------------------------------------------------------------------------
   messageid_from_uid

   Find the message ID (as returned by the POP3 LIST command) corresponding to
   the given unique ID (as returned by the POP3 UIDL command).

   Inputs
   uid: unique ID (as returned by the POP3 UIDL command)

   Outputs
   message_id: message ID (as returned by the POP3 LIST command)

   Returns
   1: found message ID corresponding to unique ID
   0: no message ID corresponding to unique ID - no meaningful information in
      message_id output
 */

static int  messageid_from_uid (char *const     uid,
                                unsigned int *  message_id)
{
    int  i;

    /* This bit is potentially inefficient: do a linear search through the
     * unique ID list, doing a strcmp to try to match the unique ID.
     */

    for (i = 0; i < pop3.uid_list_size; i++)
    {
        if (strcmp (uid, pop3.uid_list[i].unique_id) == 0)
        {
            *message_id = pop3.uid_list[i].msg_id;
            return 1;
        }
    }

    return 0;
}




/* -----------------------------------------------------------------------------
   uid_from_messageid

   Get a message's unique ID (as returned by the POP3 UIDL command) from its
   message number (as returned by the POP3 LIST command).

   Inputs
   message_id: message ID, as returned by the POP3 LIST command

   Returns
   pointer to unique ID: found matching unique ID
   NULL:                 no matching unique ID
 */

static char *  uid_from_messageid (const unsigned int  message_id)
{
    UID_MSG_LIST *  uid_msg_entry;

    uid_msg_entry = (UID_MSG_LIST *) bsearch (&message_id,
                                              pop3.uid_list,
                                              pop3.uid_list_size,
                                              sizeof (UID_MSG_LIST),
                                              compare_message_id);
    if (uid_msg_entry)
    {
        return uid_msg_entry->unique_id;
    }

    return NULL;
}




/* -----------------------------------------------------------------------------
   compare_message_id

   Routine suitable for use with C library's bsearch routine, to match a
   message ID (as returned by POP3 LIST command) against an entry in the list of
   message IDs.

   Inputs
   key:            unique ID being searched for
   uid_list_entry: pointer to entry in unique ID list to compare key against

   Returns
   -1: no match - try earlier in the list
    0: successful match
    1: no match - try later in the list
 */


static int compare_message_id (const void *  key,
                               const void *  uid_list_entry)
{
    return *((unsigned int *) key) - ((UID_MSG_LIST *) uid_list_entry)->msg_id;
}




/* -----------------------------------------------------------------------------
   delete_next_message

   Delete the next message in the POP3 delete message.  Skips messages that are
   no longer on the server (ie. that have been deleted behind our back).

   Returns
   0: no more messages to delete
   1: message deleted
 */

static int  delete_next_message (void)
{
    int           message_exists;
    unsigned int  message_id;


    while (pop3.delete_index < pop3.delete_list_size)
    {
        message_exists = messageid_from_uid (
                             pop3.delete_list[pop3.delete_index],
                             &message_id);

        free (pop3.delete_list[pop3.delete_index]);
        ++pop3.delete_index;

        if (message_exists)
        {
            Pop3IF_DeleteMessage (message_id);
            return 1;
        }
    }

    return 0;
}




/* -----------------------------------------------------------------------------
   get_next_message

   Get the next message from the POP3 server and place it in a file.  If the
   message type is only 'partially' supported by Daytona (ie. something it can
   download but not make any sense of eg. a base64 encoded MSWord document)
   then only the first <n> lines of the message are downloaded.  <n> is
   determined elsewhere.

   Inputs
   message:          pointer to data structure describing this message
   message_filename: file to download message into

   Returns
    0: no more messages in this document
    1: started download successfully
 */

static int  get_next_message (void)
{
    unsigned int  message_id;


    sprintf (pop3.message_filename, "%s.%d", POP3_DIR, pop3.message_index);

    while (!(pop3.message_list_iter.finished) (&pop3.message_list_iter))
    {
        pop3.message =
            (pop3.message_list_iter.current) (&pop3.message_list_iter);

        if (messageid_from_uid (pop3.message->unique_id,
                                &message_id))
        {
            /* Increase the size of the message slightly to attempt to cope
             * gracefully with POP3 servers that lie about message sizes.
             * If a POP3 server lies, it is likely that the inaccuracy is
             * caused by it only allowing for one line termination character,
             * whereas it should allow for two (CR+LF).  A reasonable estimate
             * of the number of characters per line is 60, so an approximate
             * allowance is 2%.
             *
             * If we get a message where the lines are much shorter then there
             * is a chance that our allowance may not be enough.  In this case
             * we will know the real size of the message after the first failed
             * attempt, so we can retry.
             */

            pop3.message->size =
                (unsigned int) ((double) pop3.message->size * 1.02);

            /* Message still exists on server, so download it */
            if (pop3.message->flags & MessageFlags_PartialDownload)
            {
                Pop3IF_GetXLinesOfMessage (pop3.message_filename,
                                           pop3.message->size,
                                           message_id,
                                           pop3.message->lines);
            }
            else
            {
                Pop3IF_GetMessage (pop3.message_filename,
                                   pop3.message->size,
                                   message_id);
            }

            return 1;
        }

        /* Try the next message */
        (pop3.message_list_iter.next) (&pop3.message_list_iter);
    }

    /* No more messages for this document */
    return 0;
}




/* -----------------------------------------------------------------------------
   free_pop3_resources

   Free all dynamically allocated resources used by POP3 download, reset
   counters etc.  Relies on unallocated pointers being NULL.
 */

static void  free_pop3_resources (void)
{
    if (pop3.message_headers != NULL)
    {
        remove_dynamic_area (pop3.message_headers_areanum);
        pop3.message_headers = NULL;
        pop3.header_index = 0;
    }

    if (pop3.message_list != NULL)
    {
        remove_dynamic_area (pop3.message_list_areanum);
        pop3.message_list = NULL;
        pop3.number_messages = 0;
        pop3.message_index = 0;
    }

    if (pop3.uid_list != NULL)
    {
        remove_dynamic_area (pop3.uid_list_areanum);
        pop3.uid_list = NULL;
        pop3.uid_list_size = 0;
    }

    if (pop3.delete_list != NULL)
    {
        free (pop3.delete_list);
        pop3.delete_list = NULL;
        pop3.delete_list_size = 0;
        pop3.delete_index = 0;
    }

    if (pop3.download_list != NULL)
    {
        list_destroy (pop3.download_list);
        pop3.download_list = NULL;
    }

    if (pop3.message_filename != NULL)
    {
        free (pop3.message_filename);
        pop3.message_filename = NULL;
    }

    if (pop3.document_directory != NULL)
    {
        free (pop3.document_directory);
        pop3.document_directory = NULL;
    }

    pop3.retry = 0;
}




/* -----------------------------------------------------------------------------
   start_message_download

   Decide what messages we want to download after the POP3 mailbox has been
   scanned and kick off the download process.
 */

static int  start_message_download (void)
{
    unsigned int free_space;

    /* Header download is complete, start downloading fax messages.
     * Messages are downloaded one at a time so the same filename can be used
     * for each message.  However, the amount of space free on the filesystem
     * could change between each call to AcornPOP3_GetMessage so this needs to
     * be checked each time.
     */

    remove_dynamic_area (pop3.message_headers_areanum);
    pop3.message_headers = NULL;
    #if 0
    /* Pop3 directory is created in main.c */
    #else
    /* Ensure that POP3 directory is present */
    _swix (OS_File, _INR (0, 1) | _IN (4), 8, POP3_DIR, 0);
    #endif

    /* Find free space on RAM disc so that emailrx_build_dl_list knows
     * how much work it can do.  Bit brain dead at the moment in that
     * the free space could change after it has been read.
     * Knocks 10k off the free space for safety's sake.
     */
    _swix (OS_FSControl,
           _INR (0, 1) | _OUT (0),

           49,
           "RAM:$",

           &free_space);

#if 0
#ifdef TEST
    emailrx_dump_doc_list_to_file (emailrx_get_doc_list (),
                                   "ADFS::4.$.doclist");
#endif
#endif

    pop3.download_list = emailrx_build_dl_list (free_space);

#ifdef TEST
    if (pop3.download_list)
    {
        emailrx_dump_doc_list_to_file (pop3.download_list,
                                       "ADFS::4.$.dllist");
    }

    emailrx_dump_doc_list_to_file (emailrx_get_doc_list (),
                                   "ADFS::4.$.doclist");
#endif


    if (pop3.download_list == NULL)
    {
        messageDataBlock *send_message;

        StateKicker_SendMessage (PrintQ_MessageHandler,
                                 RX_PQ_ERROR,
                                 &send_message);
        send_message->data.os_error.err.errnum = 0;
        strcpy (send_message->data.os_error.err.errmess,
                "Not enough memory to download EMail messages.");
        free_pop3_resources ();
        Pop3IF_Disconnect();
        return 1;
    }

    pop3.message_index = 0;

    list_initialise_iterator (&pop3.download_list_iter,
                              pop3.download_list);

    pop3.document_handle =
        (pop3.download_list_iter.reset) (&pop3.download_list_iter);
    if (pop3.document_handle != NULL)
    {
        StateKicker_SendMessage (Screen_StateMachine,
                                 RX_SC_POP3_DOWNLOAD_START,
                                 NULL);
    }

    StateKicker_SendMessage (RemXfer_StateMachine,
                             RX_RX_GET_DOCUMENT,
                             NULL);

    return 0;
}




/* -----------------------------------------------------------------------------
   send_memory_report_to_printq

   Send a report (eg. missing page) to the PrintQ that exists in memory
   somewhere.

   Inputs
   page_class: class of report we're putting in the PrintQ
   page_type:  type of report we're putting in the PrintQ
   report:     pointer to zero terminated report in memory
 */

static int send_memory_report_to_printq (const PageClasses  page_class,
                                         const PageTypes    page_type,
                                         char *const        report)
{
    char                report_filename[257];
    FILE *              fp;
    messageDataBlock *  sendMessage;

    StateKicker_SendMessage (PrintQ_MessageHandler,
                             RX_PQ_NEW_PAGE,
                             NULL);

    sprintf (report_filename,
             "%s.%d",
             pop3.document_directory,
             pop3.page_index);

    fp = fopen (report_filename,
                "w");
    if (fp == NULL)
    {
        memory_report_file_error ();
        return 1;
    }

    if (fputs (report,
               fp) == EOF)
    {
        memory_report_file_error ();
        return 1;
    }

    if (fclose (fp) == EOF)
    {
        memory_report_file_error ();
        return 1;
    }

    set_filetypeDN (pop3.document_directory,
                    pop3.page_index,
                    FILETYPE_TEXT); /*>>>should this be done by PrintQ???*/

    StateKicker_SendMessage (PrintQ_MessageHandler,
                             RX_PQ_PAGE_COMPLETE,
                             &sendMessage);

    sendMessage->data.rx_pq_page_complete.pageNum   = pop3.page_index;
    sendMessage->data.rx_pq_page_complete.pageClass = page_class;
    sendMessage->data.rx_pq_page_complete.pageType  = page_type;
    sendMessage->data.rx_pq_page_complete.fileType  = FILETYPE_TEXT;

    return 0;
}




/* -----------------------------------------------------------------------------
   memory_report_file_error

   Handle file operation errors for send_memory_report_to_printq routine.
 */

static void memory_report_file_error (void)
{
    _kernel_oserror *e;

#if 1
    /* RCM says: we MUST use RemXfer_SendRCError (or RemXfer_SendOSError) rather than rolling our own error messages */
    e = _kernel_last_oserror();
    if (e)
        RemXfer_SendOSError(PrintQ_MessageHandler, RX_PQ_ERROR, e);
    else
        RemXfer_SendRCError(PrintQ_MessageHandler, RX_PQ_ERROR, "Unable to open Email report file", 5);
#else
    messageDataBlock *  send_message;
    _kernel_oserror *   e;

    StateKicker_SendMessage (PrintQ_MessageHandler,
                             RX_PQ_ERROR,
                             &send_message);
    e = _kernel_last_oserror ();
    if (e)
    {
        send_message->data.os_error.err = *e;
    }
    else
    {
        strcpy (send_message->data.os_error.err.errmess,
                lookup_message_token (&message_block, "EmailReport_Error"));
    }
#endif

    free_pop3_resources ();
    Pop3IF_Disconnect();
    wipe_pop3_directory ();
}




/* -----------------------------------------------------------------------------
   send_file_report_to_printq

   Send a report (eg. missing page) to the PrintQ that already exists as a file
   somewhere.

   Inputs
   page_class: class of report we're putting in the PrintQ
   page_type:  type of report we're putting in the PrintQ
   filename:   name of report to place in the PrintQ
 */

static void  send_file_report_to_printq (const PageClasses  page_class,
                                         const PageTypes    page_type,
                                         char *const        filename)
{
    messageDataBlock *sendMessage;


    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_PAGE, NULL);

    set_filetypeDN (pop3.document_directory,
                    pop3.page_index,
                    FILETYPE_TEXT); /*>>>should this be done by PrintQ???*/

    StateKicker_SendMessage (PrintQ_MessageHandler,
                             RX_PQ_PAGE_COMPLETE,
                             &sendMessage);

    sendMessage->data.rx_pq_page_complete.pageNum   = pop3.page_index;
    sendMessage->data.rx_pq_page_complete.pageClass = page_class;
    sendMessage->data.rx_pq_page_complete.pageType  = page_type;
    sendMessage->data.rx_pq_page_complete.fileType  = FILETYPE_TEXT;
}





/* -----------------------------------------------------------------------------
   do_missing_page_reports

   Generate missing page reports for the remote and local machines and place
   them in the approproate queues for sending / printing.

   Returns
   -1: failure
    0: success
 */

static int do_missing_page_reports (const NFE_address *const  from)
{
    char          remote_report_filename[257];
    char *        local_report;
    int           rc;
    unsigned int  pid;


    pid = SendQ_ExtIF_NewDocument (remote_report_filename,
                                   from->real_name,
                                   from->address,
                                   FALSE,           /* don't print a hardcopy */
                                   FALSE);          /* don't want a receipt */

    SendQ_ExtIF_Subject (pid,
                         "Missing page report");

    strcat (remote_report_filename,
            "RemMissing");

    local_report = emailrx_generate_missing_page_report (pop3.document_handle,
                                                         remote_report_filename,
                                                         &pop3.message_header);
    if (local_report != NULL)
    {
        /* may need different class and type */
        SendQ_ExtIF_FileComplete (pid,
                                  "RemMissing",
                                  PageClass_Text,
                                  PageType_Text_ENote,
                                  FILETYPE_TEXT);
    }

    /* ready to send - when next connection occurs (ie doesn't trigger
     * connection)
     */
    SendQ_ExtIF_DocumentComplete(pid, FALSE);
    if (local_report == NULL)
    {
        return -1;
    }

    /* call it a cover sheet for now, but ideally it should have its own type */
    rc = send_memory_report_to_printq (PageClass_Text,
                                       PageType_Text_CoverPage,
                                       local_report);
    free (local_report);

    if (rc != 0)
    {
        return -1;
    }
    ++pop3.page_index;

    return 0;
}




/* -----------------------------------------------------------------------------
   finish_download_session

   Clean up when a POP3 message download session has finished.
 */

static void  finish_download_session (void)
{
    remove_dynamic_area (pop3.message_list_areanum);
    pop3.message_list = NULL;

    remove_dynamic_area (pop3.uid_list_areanum);
    pop3.uid_list = NULL;

    list_destroy (pop3.download_list);
    pop3.download_list = NULL;

    Pop3IF_ReleaseData();
    Pop3IF_Disconnect();
}




/* -----------------------------------------------------------------------------
   wipe_pop3_directory

   Delete the contents of the POP3 directory and the directory itself.
 */

static void  wipe_pop3_directory (void)
{
#ifndef PRESERVE_POP3
    _swix (OS_FSControl,
           _INR (0, 1) | _IN (3),

           27,
           POP3_DIR,
           0x3);
#endif
}

/*SUPPORT_EMAIL*/
#endif


/* end of RemXfer.c */
