/*
 * RemXfer.c - Remote modem (external phone line) data transfer state machine
 *
 * R C Manby
 * - with additions by S B Forrest
 *
 * Started 29 July 1997
 */


#include "StdTypes.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"


#include "swis.h"  /* N.B,  Only required if deletion of ZModem files on TX is enabled
                    * Now required for creation and removal of dynamic areas and POP3 directory as well
                    */


#include "NFELib.h"
#include "acornpop3.h"
#include "StateKicker.h"
#include "RemModem.h"
#include "RemXfer.h"
#include "PrintQ.h"
#include "SendQ.h"
#include "Screen.h"

#include "wimp.h"
#include "Serial.h"
#include "FaxIF.h"
#include "ZmodemIF.h"
#include "SmtpIF.h"


#include "MimeQ.h"

#include "DebugLib.h"
#include "NFELib.h"
#include "MimeIF.h"

#include "SetupIF.h"
#include "FileOps.h"


#include "list.h"
#include "emailrx.h"

#include "toolbox.h"
#include "msglib.h"

#include "main.h"


#if 0
typedef struct
{
  unsigned int msg_id;
  unsigned int msg_size;
} MSG_LIST;
#endif


#include "Pop3IF.h"

/*#include "DebugLib.h"*/



/* Declare function prototypes */
static void RemXfer_ForwardError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber,
                                 int forwardNumber, messageDataBlock *forwardData);
static void *create_dynamic_area (const size_t size, const char *const name, int *const area_number);
static _kernel_oserror *remove_dynamic_area (const int area_number);
static void free_header (NFE_header *header);

static int get_message (message_t *message,
                        char *const message_filename);

static void delete_message (char *const uid);

static int messageid_from_uid (char *const  uid,
                               unsigned int *message_id);

static char *uid_from_messageid (const unsigned int  message_id);

static void free_pop3_resources (void);

static int start_message_download (void);

static void file_error (void);

static int send_report_to_printq (char *const report);

/*
 * N.B.  THE FOLLOWING ARE CITED FOR REMOVAL!
 */
/*>>> start of temporary variables/definitions */
static char* LOC_ADDR_BOOK = "RAM::RamDisc0.$.AddrBook.Local";   /* Location of address book details to send to remote Daytona */
static char* REM_ADDR_BOOK = "RAM::RamDisc0.$.AddrBook.Remote";  /* Location to store received address book details */
/*<<< end of temporary variables/definitions */


#if 0

enum _BOOL { FALSE = 0, TRUE = 1 };
typedef enum _BOOL BOOL;
#endif

typedef struct
{
	int number_messages;

	MSG_LIST *message_list;
	int message_list_areanum;

	char *message_headers;
	int message_headers_areanum;

	NFE_header message_header;

	char         **delete_list;
	unsigned int   delete_list_size;

	UID_MSG_LIST *uid_list;
	int           uid_list_areanum;
	int           uid_list_size;

	unsigned int header_index;
	unsigned int message_index;
	unsigned int delete_index;
	unsigned int page_index;

	document_handle document_handle;
	message_t       *message;

	list_handle      download_list;
	list_iterator_t  download_list_iter;

	list_iterator_t  message_list_iter;

	char *document_directory;
	char *message_filename;
} pop3_data_t;

/* POP3 email retreive */
static pop3_data_t pop3;

/*
 *
 *
 */

enum _States { IDLE = 0,
 /*fax*/       INCOMING_2a, INCOMING_2b, INCOMING_2c, INCOMING_2d,
               INCOMING_SWITCHOVER,
 /*Daytona*/   INCOMING_3a, INCOMING_3b, INCOMING_3c, INCOMING_3d, INCOMING_3e,
               OUTGOING_4a, OUTGOING_4b, OUTGOING_4c, OUTGOING_4d, OUTGOING_4e, OUTGOING_4f,
               OUTGOING_SWITCHOVER,
               OUTGOING_5a, OUTGOING_5b, OUTGOING_5c, OUTGOING_5d, OUTGOING_5e, OUTGOING_5f,
               OUTGOING_6a, OUTGOING_6b, OUTGOING_6c, OUTGOING_6d,
               OUTGOING_7a, OUTGOING_7b, OUTGOING_7c, OUTGOING_7d, OUTGOING_7e,
               OUTGOING_10a,
               INCOMING_8a, INCOMING_8b, INCOMING_8c, INCOMING_8d, INCOMING_8e, INCOMING_8f, INCOMING_8g, INCOMING_8h, INCOMING_8i, INCOMING_8j,
               INCOMING_8k, INCOMING_8l, INCOMING_8m, INCOMING_8n, INCOMING_8o, INCOMING_8p,
               INCOMING_9a, INCOMING_9b, INCOMING_9c
             };
typedef enum _States States;

extern void RemXfer_StateMachine(int messageNumber, messageDataBlock *messageData)
{
	static States state = IDLE;
	static BOOL	  aborting = FALSE;
	static char   directory[256];			/* Document directory */
	static unsigned int stash_loPage;

#if SUPPORT_EMAIL
    /* Email send/retrieve variables */
    static BOOL isp_via_dialler = TRUE;	/* when FALSE, using LAN */
    static BOOL tx_flag = FALSE;
    static BOOL rx_flag = FALSE;
    static BOOL tx_error = FALSE;
    static unsigned int stash_Process_Id = 0;
    static unsigned int stash_hiPage;
    static char stash_to_emailaddress[256];
#endif

	/* ZModem-orientated variables */
	static int  page_counter = 0;        /* Keep account of current page */
	static char pathname[255];           /* Pathname of file to TX/RX */

	States nextstate = state;

	/* Print state machine status */
	dprintf((NULL, "RemXfer_StateMachine (entry): State => %d; Message => 0x%X\n", state, messageNumber));

    /* switch on error suppression if initiating an ABORT */
	if (messageNumber == PQ_RX_ABORT_INCOMING)
		aborting = TRUE;

    /* switch off error suppression on return to IDLE state after ABORT completes */
    if (state == IDLE)
    	aborting = FALSE;

	if (state != IDLE)
	{
		/* common code to reject messages that are only acceptable when IDLE */
		switch (messageNumber)
		{
				case SQ_RX_DIAL_FAX:
				case SQ_RX_DIAL_DAYTONA:
				case SQ_RX_DIAL_ISP:
				case SQ_RX_DIAL_ISP_rx:
				case SQ_RX_DIAL_LAN:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
					return;

				case RM_RX_INCOMING_FAX:
				case RM_RX_INCOMING_DAYTONA:
                case RM_RX_INCOMING_VOICE:
                	/* we can't handle this, so hangup */
                	StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					return;
		}
	}

    /* main state machine and message decoder */
	switch (state)
	{
		case IDLE:
			switch (messageNumber)
			{
				case SQ_RX_QUERY_IDLE:
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_QUERY_IDLE, NULL);
					nextstate = state;	/* unchanged */
					break;

				case RM_RX_AM_IDLE:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_AM_IDLE, NULL);		/* idle now, but an incoming call could start before SendQ receives this */
					nextstate = state;	/* unchanged */
					break;

				case RM_RX_INCOMING_FAX:
					/* request creation of a document directory to hold the incoming fax */
					StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_DOCUMENT, NULL);
					nextstate = INCOMING_2a;
					break;

				case RM_RX_INCOMING_DAYTONA:
					/* request creation of a document directory to hold the incoming fax/text */
					StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_DOCUMENT, NULL);
					nextstate = INCOMING_3a;
					break;

                case RM_RX_INCOMING_VOICE:
                	/* we can't handle this, so hangup */
                	StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = INCOMING_2d;	/* wait for RemModem to go Idle */
                	break;

				case SQ_RX_DIAL_FAX:
					{
						messageDataBlock *sendMessage;

						StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DIAL_FAX, &sendMessage);
						strcpy(sendMessage->data.dial.number, messageData->data.dial.number);
						nextstate = OUTGOING_4a;
					}
					break;

				case SQ_RX_DIAL_DAYTONA:
					{
						messageDataBlock *sendMessage;

						StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DIAL_DAYTONA, &sendMessage);
						strcpy(sendMessage->data.dial.number, messageData->data.dial.number);
						nextstate = OUTGOING_5a;
					}
					break;
#if SUPPORT_EMAIL
				case SQ_RX_DIAL_ISP:
					{
						messageDataBlock *sendMessage;

						isp_via_dialler = TRUE;
                        tx_flag = TRUE;
                        rx_flag = FALSE;
                        tx_error = FALSE;
                        /* tx_flag  rx_flag                                                */
                        /*  TRUE     TRUE   - normal connect, send mail then retrieve mail */
                        /*  TRUE     FALSE  - send only (water mark triggered)             */
                        /*  FALSE    TRUE   - retrieve only                                */
						if (tx_flag)
							StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_START, NULL);	/* Kick off the MIME encoding while the dial-up and LogOn happens */

						StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DIAL_ISP, &sendMessage);
						strcpy(sendMessage->data.dial.number, messageData->data.dial.number);
						nextstate = OUTGOING_6a;
					}
					break;

				case SQ_RX_DIAL_ISP_rx:
					{
						messageDataBlock *sendMessage;

						isp_via_dialler = TRUE;
                        tx_flag = FALSE;
                        rx_flag = TRUE;
                        tx_error = FALSE;
                        /* tx_flag  rx_flag                                                */
                        /*  TRUE     TRUE   - normal connect, send mail then retrieve mail */
                        /*  TRUE     FALSE  - send only (water mark triggered)             */
                        /*  FALSE    TRUE   - retrieve only                                */
						if (tx_flag)
							StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_START, NULL);	/* Kick off the MIME encoding while the dial-up and LogOn happens */

						StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DIAL_ISP, &sendMessage);
						strcpy(sendMessage->data.dial.number, messageData->data.dial.number);
						nextstate = OUTGOING_6a;
					}
					break;

#if SUPPORT_LAN
				/* not quite the right message name, but everything else is SQ_RX_DIAL_xxx */
				case SQ_RX_DIAL_LAN:
					{
						isp_via_dialler = FALSE;
                        tx_flag = messageData->data.sq_rx_dial_lan.tx_flag;
                        rx_flag = messageData->data.sq_rx_dial_lan.rx_flag;
                        tx_error = FALSE;
                        					
						if (tx_flag)
							StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_START, NULL);	/* Kick off the MIME encoding while the dial-up and LogOn happens */

						StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_START, NULL);
						StateKicker_SendMessage(RemXfer_StateMachine, RX_RX_TXCONNECTED, NULL);	/* if configured for LAN, assume connected */
						nextstate = OUTGOING_6a;
					}
					break;
#endif
#endif
			}
			break;

	 /*		                          */
	 /* Incoming - from a fax machine */
     /*                               */
		case INCOMING_2a:			/* waiting for PrintQ to tell us where to put the fax being received */
			switch (messageNumber)
			{
				case SQ_RX_DIAL_FAX:
				case SQ_RX_DIAL_DAYTONA:
				case SQ_RX_DIAL_ISP:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
					nextstate = state;
					break;

				case PQ_RX_ABORT_INCOMING:
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = INCOMING_2d;	/* wait for RemModem to go Idle */
					break;

				case PQ_RX_NEW_DOCUMENT_DIR:
					/* Capture directory details */
                    strcpy(directory, messageData->data.new_document_dir.directory);

					/* pass modem ownership to !Fax, telling !Fax where to place the scanned pages */
					FaxIF_ReceiveFax(REMMODEM, messageData->data.new_document_dir.directory);
					nextstate = INCOMING_2b;
					break;
            }
			break;

		case INCOMING_2b:
			switch (messageNumber)
			{
				case SQ_RX_DIAL_FAX:
				case SQ_RX_DIAL_DAYTONA:
				case SQ_RX_DIAL_ISP:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
					nextstate = state;
					break;

				case PQ_RX_ABORT_INCOMING:
					/*>>>tell !Fax to abort reception??? */
					StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = INCOMING_2d;	/* wait for RemModem to go Idle */
					break;

#if SUPPORT_SWITCHOVER
				case FX_SWITCHOVER:
#if 0
	/*>>>put this in sometime*/
	/*>>>since we don't distinguish between fax in and data in anywhere, this isn't needed */
					/* Tell PrintQ we are switching to Daytona data transfer mode */
					StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_SWITCHTO_DAYTONA, NULL);	/* ie tell address book caller is a Daytona */
#endif
					/* run a dialler script to change from fax to data mode */
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DO_SWITCHOVER, NULL);
					nextstate = INCOMING_SWITCHOVER;
					break;
#endif
				case FX_ERROR:
				    /*>>>report error to PrintQ if aborting flag is clear */
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
#if /*THINK*/ 1
					/* A 'T1 Timeout' error after connection & before any data transfer is */
					/* probably a voice caller (later T1 Timeouts are treated as genuine). */
					if (messageData->data.fx_error.rc == 0x011 /*ERROR_T1_TIMEOUT*/)
					{
						StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_MAYBE_VOICE, NULL);	/* Send a supplementary message */
					}
#endif
				    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = INCOMING_2d;
					break;

				case FX_NORMAL_TERMINATION:
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = INCOMING_2d;
					break;

				case FX_RECEIVING_PAGE:
					StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_PAGE, NULL);	/* mainly to trigger animations, but may PQ_RX_ABORT_INCOMING if short of memory */
					nextstate = INCOMING_2c;
					break;
			}
			break;

		case INCOMING_2c:
			switch (messageNumber)
			{
				case SQ_RX_DIAL_FAX:
				case SQ_RX_DIAL_DAYTONA:
				case SQ_RX_DIAL_ISP:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
					nextstate = state;
					break;

				case PQ_RX_ABORT_INCOMING:
					/*>>>tell !Fax to abort reception */
					StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_ABORTED, NULL);
					StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = INCOMING_2d;	/* wait for RemModem to go Idle */
					break;

				case FX_ERROR:
				    /*>>>report error*/
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_ABORTED, NULL);
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;
					break;

				case FX_RECEIVED_PAGE:
					{
						messageDataBlock *sendMessage;

						set_filetypeDN(directory, messageData->data.fx_received_page.lastpage, FILETYPE_TIFF);	/*>>>should this be done by PrintQ???*/
				    	StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_COMPLETE, &sendMessage);
				    	sendMessage->data.rx_pq_page_complete.pageNum  = messageData->data.fx_received_page.lastpage;
				    	sendMessage->data.rx_pq_page_complete.pageType = FILETYPE_TIFF;

				    	nextstate = INCOMING_2b;	/* wait for next page, or end of document */
				    }
					break;
			}
			break;

        /* also used from state IDLE with message RM_RX_INCOMING_VOICE */
		case INCOMING_2d:           /* waiting for RemModem to disconnect */
			switch (messageNumber)
			{
				case SQ_RX_DIAL_FAX:
				case SQ_RX_DIAL_DAYTONA:
				case SQ_RX_DIAL_ISP:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
					nextstate = state;
					break;

				case PQ_RX_ABORT_INCOMING:
					nextstate = state;		/* doing our best, so ignore */
					break;

				case RM_RX_GOING_IDLE:
					/*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
					nextstate = IDLE;
					break;
			}
			break;
#if SUPPORT_SWITCHOVER
		case INCOMING_SWITCHOVER:
			switch (messageNumber)
			{
				case SQ_RX_DIAL_FAX:
				case SQ_RX_DIAL_DAYTONA:
				case SQ_RX_DIAL_ISP:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
					nextstate = state;
					break;

				case PQ_RX_ABORT_INCOMING:
					StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = INCOMING_2d;	/* wait for RemModem to go Idle */
					break;

                case RM_RX_ERROR:
				    /*>>>report error to PrintQ if aborting flag is clear */
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
				    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = INCOMING_2d;
					break;

				case RM_RX_SWITCHOVER_DONE:	/* c.f. INCOMING_3a with PQ_RX_NEW_DOCUMENT_DIR */
                    /* pass modem ownership to ZModem; tell ZModem to send our address book details */
                    {
                        ZModemMessage zmodemtx;

                        /* directory was setup in INCOMING_2a PQ_RX_NEW_DOCUMENT_DIR */

                        /* Reset page counter ready for receipt of new document */
                        page_counter = 1;
                        dprintf((NULL, "ZModem page counter reset\n"));

                        /* Send our address book details, so that the remote machine may identify us */
                        ZModemIF_SendMessage(REMMODEM, LOC_ADDR_BOOK, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = INCOMING_3b;
                    }
					break;
			}
			break;
#endif

     /*                                 */
     /* Incoming - from another Daytona */
     /*                                 */
		case INCOMING_3a:           /* waiting for PrintQ to tell us where to put the document being received */
	        switch (messageNumber)
	        {
                case SQ_RX_DIAL_FAX:
                case SQ_RX_DIAL_DAYTONA:
                case SQ_RX_DIAL_ISP:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
                    nextstate = state;        /* unchanged */
                    break;

                case PQ_RX_ABORT_INCOMING:
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_3e;
                    break;

                case PQ_RX_NEW_DOCUMENT_DIR:
                    /* pass modem ownership to ZModem; tell ZModem to send our address book details */
                    {
                        ZModemMessage zmodemtx;

                        /* Capture directory details */
                        strcpy(directory, messageData->data.new_document_dir.directory);

                        /* Reset page counter ready for receipt of new document */
                        page_counter = 1;
                        dprintf((NULL, "ZModem page counter reset\n"));

                        /* Send our address book details, so that the remote machine may identify us */
                        ZModemIF_SendMessage(REMMODEM, LOC_ADDR_BOOK, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = INCOMING_3b;
                    }
                    break;
	        }
	        break;

		case INCOMING_3b:           /* waiting for ZModem to confirm transmission of local address */
	        switch (messageNumber)
	        {
                case SQ_RX_DIAL_FAX:
                case SQ_RX_DIAL_DAYTONA:
                case SQ_RX_DIAL_ISP:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
                    nextstate = state;        /* unchanged */
                    break;

                case ZM_RX_ERROR:  /* Error condition (failed to transfer local address details) */
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_3e;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Sent local address book details OK, so receive senders' */
                    {
                        ZModemMessage zmodemrx;

                        /* Fetch recipients address book details */
                        ZModemIF_SendMessage(REMMODEM, REM_ADDR_BOOK, WM_ZMODEM_RX, &zmodemrx);  /*>>>receive into directory.Remote*/
                        nextstate = INCOMING_3c;
                    }
                    break;
	        }
	        break;

		case INCOMING_3c:           /* waiting for ZModem to confirm receipt of remote address */
	        switch (messageNumber)
	        {
	            case SQ_RX_DIAL_FAX:
	            case SQ_RX_DIAL_DAYTONA:
	            case SQ_RX_DIAL_ISP:
	                StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
	                nextstate = state;        /* unchanged */
	                break;

	            case ZM_RX_ERROR:  /* Error condition (failed to transfer remote address details) */
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
	                StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
	                StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
	                nextstate = INCOMING_3e;
	                break;

	            case ZM_RX_NORMAL_TERMINATION:  /* Received remote address book details OK */
	                {
	                    ZModemMessage zmodemrx;
/*>>>tell PrintQ about received address book details */
/*>>>we need to decode the file list here? or can we just receive files and let the PrintQ characterise them based on the file list?*/
	                    /* Construct the full pathname for the page (file) to receive */
                        sprintf(pathname, "%s.%d", directory, page_counter);

	                    /* Tell PrintQ that the receive is about to commence */
	                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_PAGE, NULL);

	                    /* Receive the page using ZModem protocols */
	                    ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_RX, &zmodemrx);
	                    nextstate = INCOMING_3d;
	                }
	                break;
	        }
	        break;

		case INCOMING_3d:           /* waiting for ZModem to confirm receipt of page */
	        switch (messageNumber)
	        {
                case SQ_RX_DIAL_FAX:
                case SQ_RX_DIAL_DAYTONA:
                case SQ_RX_DIAL_ISP:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
                    nextstate = state;        /* unchanged */
                    break;

                case PQ_RX_ABORT_INCOMING:
                    {
                        ZModemMessage zmodemabort;

                        /* Inform ZModem, asking it to abort the current transfer */
                        ZModemIF_SendMessage(REMMODEM, NULL, WM_ZMODEM_ABORT, &zmodemabort);

                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                        nextstate = INCOMING_3e;
                    }
                    break;

                case ZM_RX_ERROR:  /* Error condition (failed to receive page or at end of document) */
#if 0
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
#endif
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_ABORTED, NULL);
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_3e;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Confirmation that previous page was received OK */
                    {
                    	messageDataBlock *sendMessage;
                        ZModemMessage zmodemrx;

						/*>>>NB assume TIFF for now*/
                        set_filetypeDN(directory, page_counter, FILETYPE_TIFF);	/*>>>should this be done by PrintQ???*/
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_COMPLETE, &sendMessage);
				    	sendMessage->data.rx_pq_page_complete.pageNum  = page_counter;
				    	sendMessage->data.rx_pq_page_complete.pageType = FILETYPE_TIFF;

                        /* Increment page counter; construct full pathname of next page (file) to receive */
                        page_counter += 1;
                        sprintf(pathname, "%s.%d", directory, page_counter);
                        dprintf((NULL, "ZModem page counter incremented: page => %d\n", page_counter));

                        /* Tell PrintQ that the receive is about to commence */
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_PAGE, NULL);

                        /* Receive the page using ZModem protocols */
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_RX, &zmodemrx);
                        nextstate = state;        /* unchanged */
                    }
                    break;
	        }
	        break;

		case INCOMING_3e:           /* waiting for RemModem to disconnect */
	        switch (messageNumber)
	        {
                case SQ_RX_DIAL_FAX:
                case SQ_RX_DIAL_DAYTONA:
                case SQ_RX_DIAL_ISP:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
                    nextstate = state;        /* unchanged */
                    break;

                case PQ_RX_ABORT_INCOMING:
                    nextstate = state;        /* doing our best, so ignore */
                    break;

                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;
	        }
	        break;

     /*                             */
     /* Outgoing - to a fax machine */
     /*                             */
		case OUTGOING_4a:			/* waiting for RemModem to connect */
			switch (messageNumber)
			{
				case RM_RX_DIAL_REJECTED:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);	/* because of incoming call */
					nextstate = IDLE;	/* code below will issue RX_SQ_GOING_IDLE */
					break;

				case RM_RX_ERROR:
					RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);	/* forward the error to SendQ */
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = OUTGOING_4f;	/* wait for RM_RX_GOING_IDLE */
					break;

				case RM_RX_TXCONNECTED:
					/* ask SendQ which document is to be sent to the number we connected too */
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_WHICH_DOCUMENT, NULL);
					nextstate = OUTGOING_4b;
					break;
			}
			break;

		case OUTGOING_4b:			/* waiting for SendQ to tell us which document to send */
			switch (messageNumber)
			{
				case SQ_RX_THIS_DOCUMENT:
					/* Capture name of directory containing document (fax or text) to send */
                    strcpy(directory, messageData->data.this_document.directory);	/*>>>is directory used???*/
					stash_loPage = messageData->data.this_document.loPage;	/* for the benefit of ZMODEM, capture loPage, incase a data switchover occurs */

					/* pass modem ownership to !Fax, telling !Fax which pages to send */
					FaxIF_SendFax(REMMODEM, messageData->data.this_document.directory,
					                        messageData->data.this_document.loPage, /* usually 1 */
					                        0,                                      /*>>>what should page range be?*/
					                        TRUE									/* delete pages successfully sent */
					             );

					nextstate = OUTGOING_4c;
					break;
			}
			break;
#if /*THINK*/ 0
/*>>>RCM says: should we have a RX_SQ_SENDING_DOCUMENT message (c.f. email send) to indicate */
/*>>>          that fax has connected to something, because at the momemt SendQ thinks !fax */
/*>>>          connected after the dial completes whereas ISP and ZMODEM get a modem 'connect' */
/*>>>          before asking WHICH_DOCUMENT/SENDING_DOCUMENT */
/*>>>          We would send RX_SQ_SENDING_DOCUMENT in OUTGOING_4c on all messages except FX_ERROR*/
/*>>>          Would also need RX_SQ_SENDING_DOCUMENT after WHICH_DOCUMENT for ZMODEM */
#endif
		case OUTGOING_4c:	/* identical to OUTGOING_4d, but handles FX_SWITCHOVER */
			switch (messageNumber)
			{
#if SUPPORT_SWITCHOVER
				case FX_SWITCHOVER:
					/* Tell SendQ we are switching from fax to Daytona data transfer mode */
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SWITCHTO_DAYTONA, NULL);	/* ie tell address book recipient is a Daytona */

					/* run a dialler script to change from fax to data mode */
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DO_SWITCHOVER, NULL);
					nextstate = OUTGOING_SWITCHOVER;
					break;
#endif
				case FX_ERROR:
					RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);	/* forward the error to SendQ */
#if /*THINK*/ 1
					/* A 'T1 Timeout' error after connection & before any data transfer is */
					/* probably a voice receiver (later T1 Timeouts are treated as genuine). */
					if (messageData->data.fx_error.rc == 0x011 /*ERROR_T1_TIMEOUT*/)
					{
						/* Remote receiver has answered, but doesn't whistle like a fax machine */
						StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_MAYBE_VOICE, NULL);				/* give strong hint to SendQ that its not worth redialling */
					}
#endif
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);               /* we've sent as much of the current document as we can */
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = OUTGOING_4f;
					break;

				case FX_NORMAL_TERMINATION:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = OUTGOING_4f;
					break;

				case FX_SENDING_PAGE:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, NULL);
					nextstate = OUTGOING_4e;
					break;
			}
			break;

		case OUTGOING_4d:	/* identical to OUTGOING_4c, but excludes FX_SWITCHOVER */
			switch (messageNumber)
			{
				case FX_ERROR:
					RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);	/* forward the error to SendQ */
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);               /* we've sent as much of the current document as we can */
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = OUTGOING_4f;
					break;

				case FX_NORMAL_TERMINATION:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = OUTGOING_4f;
					break;

				case FX_SENDING_PAGE:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, NULL);
					nextstate = OUTGOING_4e;
					break;
			}
			break;

		case OUTGOING_4e:
			switch (messageNumber)
			{
				case FX_ERROR:
					RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);	/* forward the error to SendQ */
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_FAILED, NULL);
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = OUTGOING_4f;
					break;

				case FX_NORMAL_TERMINATION:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_SENT, NULL);
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = OUTGOING_4f;
					break;

/*if defined(Info_Sent_Page)*/
				case FX_SENT_PAGE:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_SENT, NULL);
					nextstate = OUTGOING_4d;
					break;
/*else*/
				case FX_SENDING_PAGE:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_SENT, NULL);
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, NULL);
					nextstate = OUTGOING_4e;
					break;
/*endif*/
			}
			break;

		case OUTGOING_4f:
			switch (messageNumber)
			{
				case RM_RX_GOING_IDLE:
					/*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
					nextstate = IDLE;
					break;
			}
			break;
#if SUPPORT_SWITCHOVER
		case OUTGOING_SWITCHOVER:
			switch (messageNumber)
			{
				case RM_RX_ERROR:
					RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);	/* forward the error to SendQ */
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = OUTGOING_4f;
					break;

				case RM_RX_SWITCHOVER_DONE:	/* c.f. OUTGOING_5b with SQ_RX_THIS_DOCUMENT */
					{
                        ZModemMessage zmodemrx;

                        /* directory, was set in OUTGOING_4b */

                        /* Reset page counter ready for new document */
                        page_counter = stash_loPage;	/* stashed by OUTGOING_4b message SQ_RX_THIS_DOCUMENT, usually 1 */
                        dprintf((NULL, "ZModem page counter reset\n"));

                        /* Fetch recipients address book details */
                        ZModemIF_SendMessage(REMMODEM, REM_ADDR_BOOK, WM_ZMODEM_RX, &zmodemrx);
						nextstate = OUTGOING_5c;
					}
					break;
			}
			break;
#endif
     /*                               */
     /* Outgoing - to another Daytona */
     /*                               */
		case OUTGOING_5a:
			switch (messageNumber)
			{
				case RM_RX_DIAL_REJECTED:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);	/* because of incoming call */
					nextstate = IDLE;	/* code below will issue RX_SQ_GOING_IDLE */
					break;

				case RM_RX_ERROR:
				    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);	/* forward the error to SendQ */
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = OUTGOING_5f;	/* wait for RM_RX_GOING_IDLE */
					break;

				case RM_RX_TXCONNECTED:
					/* ask SendQ which document is to be sent to the number we connected to */
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_WHICH_DOCUMENT, NULL);
					nextstate = OUTGOING_5b;
					break;
			}
			break;

        case OUTGOING_5b:                       /* waiting for SendQ to tell us which document to send */
            switch (messageNumber)
            {
                case SQ_RX_THIS_DOCUMENT:
                    {
                        ZModemMessage zmodemrx;

                        /* Capture name of directory containing document (fax or text) to send */
                        strcpy(directory, messageData->data.this_document.directory);
                        stash_loPage = messageData->data.this_document.loPage;

                        /* Reset page counter ready for new document */
                        page_counter = stash_loPage;	/*>>>what about text files*/
                        dprintf((NULL, "ZModem page counter reset\n"));

                        /* Fetch recipients address book details */
                        ZModemIF_SendMessage(REMMODEM, REM_ADDR_BOOK, WM_ZMODEM_RX, &zmodemrx);
                        nextstate = OUTGOING_5c;
                    }
                    break;
            }
            break;

        case OUTGOING_5c:
            switch (messageNumber)          /* waiting for ZModem to confirm receipt of remote address */
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer remote address details) */
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);	/* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_5f;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Received remote address book details OK, so send ours */
                    {
                        ZModemMessage zmodemtx;

						/*>>>update screen to show sender details */

                        /* Send our address book details, so that the remote machine may identify us */
                        ZModemIF_SendMessage(REMMODEM, LOC_ADDR_BOOK, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = OUTGOING_5d;
                    }
                    break;
            }
            break;

        case OUTGOING_5d:
            switch (messageNumber)          /* waiting for ZModem to confirm transmission of local address */
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer local address details) */
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);	/* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_5f;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Sent local address book details OK */
                    {
                        ZModemMessage zmodemtx;

                        /* Construct the full pathname of the page (file) to send */
                        sprintf(pathname, "%s.%d", directory, page_counter);

                        /* Tell SendQ that the send is about to commence */
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, NULL);

                        /* Send the page using ZModem protocols */
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = OUTGOING_5e;
                    }
                    break;
            }
            break;

        case OUTGOING_5e:
            switch (messageNumber)          /* waiting for ZModem to confirm transmission of page */
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer page or at end of document) */
#if 0
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);	/* forward the error to SendQ */
#endif
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_FAILED, NULL);
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_5f;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Confirmation that previous page was sent OK */
                    {
                        ZModemMessage zmodemtx;

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_SENT, NULL);
                        /*>>> Delete page <pathname> here if desired, code follows <<<*/
                        #if 0
                        {
                                _kernel_swi_regs reg;

                                reg.r[0] = 6;
                                reg.r[1] = (int)pathname;
                                _kernel_swi(OS_File, &reg, &reg);
                        }
                        #endif

                        /* Increment page counter; construct full pathname of next page (file) to send */
                        page_counter += 1;
                        sprintf(pathname, "%s.%d", directory, page_counter);
                        dprintf((NULL, "ZModem page counter incremented: page => %d\n", page_counter));
/*>>>would be a good idea to check if the page exists here!*/
                        /* Tell SendQ that the send is about to commence */
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, NULL);

                        /* Send the page using ZModem protocols */
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = state;       /* unchanged */
                    }
                    break;
            }
            break;

		case OUTGOING_5f:
			switch (messageNumber)
			{
				case RM_RX_GOING_IDLE:
					/*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
					nextstate = IDLE;
					break;
			}
			break;
#if SUPPORT_EMAIL
     /* Connect to ISP                                                          */
     /*   ie Delete emails that were downloaded and printed by the last connect */
     /*      Send queued emails                                                 */
     /*      Download emails for printing                                       */
		case OUTGOING_6a:			/* waiting for RemModem to connect */
			switch (messageNumber)
			{
				case RM_RX_DIAL_REJECTED:
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);	/* because of incoming call */

					if (tx_flag)
					{
						StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_STOP, NULL);	/* Kill the MIME encoding */
						nextstate = OUTGOING_6b;
						break;
                    }

					nextstate = IDLE;	/* code below will issue RX_SQ_GOING_IDLE */
					break;

				case RM_RX_ERROR:
					RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);	/* forward the error to SendQ */

					if (tx_flag)
					{
						tx_error = TRUE;
						StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_STOP, NULL);	/* Kill the MIME encoding */
						nextstate = OUTGOING_7e;	/* wait for ME_RX_STOPPED, issue HANGUP, wait for RM_RX_GOING_IDLE */
					}
					else
					{
						StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
						nextstate = OUTGOING_10a;	/* wait for RM_RX_GOING_IDLE */
					}
					break;
#if SUPPORT_LAN
				case RX_RX_TXCONNECTED:	/* if configured for LAN, assume connected */
#endif
				case RM_RX_TXCONNECTED:	/* dialled ISP and connected */
					{
						StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_CONNECTED, NULL);
						
						if (tx_flag)
						{
							SmtpIF_Register();
							nextstate = OUTGOING_7a;
						}
						else
						{
							Pop3IF_Register();
							nextstate = INCOMING_8a;
						}
		            }
		            break;
		    }
			break;

        case OUTGOING_6b:			/* dial rejected/failed - waiting for MimeEncoder to stop */
        	switch (messageNumber)
        	{
        		case ME_RX_STOPPED:
        			nextstate = IDLE;	/* code below will issue RX_SQ_GOING_IDLE */
        			break;
        	}
        	break;

        /* Send queued emails */
		case OUTGOING_7a:           /* trying to register with SMTP */
            switch (messageNumber)
            {
            	case SP_RX_REGISTER_ERROR:
            		tx_error = TRUE;
            		RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);	/* forward the error to SendQ */
					StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_STOP, NULL);	/* Kill the MIME encoding */
                    nextstate = OUTGOING_7e;	/* wait for MIME encoder to stop, then hang-up */
            		break;

            	case SP_RX_REGISTER_DONE:
            		stash_Process_Id = 0;	/* about to start the first document of this batch of emails */
            		StateKicker_SendMessage(MailQ_StateMachine, RX_MQ_WHICH_MAILFILE, NULL);
            		nextstate = OUTGOING_7b;
            		break;
            }
			break;

		case OUTGOING_7b:			/* waiting for a mailfile to send */
			switch (messageNumber)
			{
				case MQ_RX_NO_MORE_MAIL:
					if (stash_Process_Id != 0)
						StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);

					SmtpIF_DeRegister();
					nextstate = OUTGOING_7d; /* does a redundent RX_ME_PREFETCH_STOP for us */
					break;

				case MQ_RX_THIS_MAILFILE:
					{
						messageDataBlock *sendMessage;

						if (stash_Process_Id != messageData->data.this_mailfile.pid)
						{
							/* different pid, so this mailfile is a new document */

							/* stash_Process_Id is initialised to zero in OUTGOING_7a, so if now non-zero, this is not the first document */
							if (stash_Process_Id != 0)
								StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);	/* previous document has gone */

							/* First/next document has emerged from the queue */
                            stash_Process_Id = messageData->data.this_mailfile.pid;
                            SendQ_emailaddress_from_pid(stash_to_emailaddress, stash_Process_Id);

                    		StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_DOCUMENT, &sendMessage);	/* starting to send first/next document */
                    		sendMessage->data.sending_document.pid = stash_Process_Id;
                    	}

						stash_loPage = messageData->data.this_mailfile.loPage;
						stash_hiPage = messageData->data.this_mailfile.hiPage;
				      /*strcpy(stash_filename, messageData->data.this_mailfile.filename);*/

                    	StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE_RANGE, &sendMessage);
                    	sendMessage->data.sending_page_range.pid = stash_Process_Id;
						sendMessage->data.sending_page_range.loPage = stash_loPage;
						sendMessage->data.sending_page_range.hiPage = stash_hiPage;

						SmtpIF_SendMail(messageData->data.this_mailfile.filename, stash_to_emailaddress, setup_from_mailaddress, setup_smtp_server);
						nextstate = OUTGOING_7c;
					}
					break;
			}
			break;

		case OUTGOING_7c:			/* SMTP is sending our file */
			switch (messageNumber)
			{
				case SP_RX_SENDMAIL_ERROR:	/* SmtpIF_SendMail failed */
					tx_error = TRUE;
					RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);	/* forward the error to SendQ */
					StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);               /* we've stopped sending current document */
					SmtpIF_DeRegister();
					nextstate = OUTGOING_7d; /* does RX_ME_PREFETCH_STOP for us */
					break;

				case SP_RX_SENDMAIL_DONE:
					{
						messageDataBlock *sendMessage;
						/* tell the SendQ which range of pages were sent */
						StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_RANGE_SENT, &sendMessage);
						sendMessage->data.page_range_sent.pid = stash_Process_Id;
						sendMessage->data.page_range_sent.loPage = stash_loPage;
						sendMessage->data.page_range_sent.hiPage = stash_hiPage;

						/* let the MailQ know the MIME mailfile has gone and can be deleted     */
						/* if the encoding is stalled through lack of space it will now restart */
						StateKicker_SendMessage(MailQ_StateMachine, RX_MQ_MAILFILE_SENT, NULL);

						/* ask for the next MIME mailfile holding either more pages of the current */
						/* document or the first pages of a new document (different Process_Id)    */
						StateKicker_SendMessage(MailQ_StateMachine, RX_MQ_WHICH_MAILFILE, NULL);
						nextstate = OUTGOING_7b;
					}
					break;
			}
			break;

		case OUTGOING_7d:			/* waiting for DeRegister to complete */
			switch (messageNumber)
			{
				case SP_RX_DEREGISTER_ERROR:	/* we don't care about errors from Smtp_DeRegister, treat as done */
				case SP_RX_DEREGISTER_DONE:
					StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_STOP, NULL);	/* Kill the MIME encoding */
                    nextstate = OUTGOING_7e;
					break;
			}
			break;

		case OUTGOING_7e:			/* common 'end of email transmit' handler */
			switch (messageNumber)
			{
				case ME_RX_STOPPED:
					/* the send process has completed (with or without error) */
					/* we only do a mail retrieve if the send succeeded and a retreive was requested */
					if ((tx_error) || (!rx_flag))
					{
						if (isp_via_dialler)
						{
							StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
							nextstate = OUTGOING_10a;
						}
						else
						{
                        	StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_END, NULL);	/* equivalent to RM_SC_DIAL_COMPLETE*/
							/*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
							nextstate = IDLE;
						}
					}
					else
					{
						/* Register with AcornPOP3 module as start of retreive operation */
						Pop3IF_Register();
						nextstate = INCOMING_8a;
					}
					break;
			}
			break;

		case OUTGOING_10a:			/* waiting for dialler hangup */
			switch (messageNumber)
			{
				case RM_RX_GOING_IDLE:
					/*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
					nextstate = IDLE;
					break;
			}
			break;

		/* Retrieve emails from ISP */
		case INCOMING_8a:
			switch (messageNumber)
			{
				case P3_RX_REGISTER_CALL_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */

					if (isp_via_dialler)
					{
						StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
						nextstate = INCOMING_9a;
					}
					else
					{
                    	StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_END, NULL);	/* equivalent to RM_SC_DIAL_COMPLETE*/
						/*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
						nextstate = IDLE;
					}

					break;
				}

				case P3_RX_REGISTER_DONE:
				/*StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_POP3_LOGON, NULL)*/
					Pop3IF_Logon(setup_username, setup_password, setup_pop3_server);
					nextstate = INCOMING_8b;
					break;

				default:
					nextstate = INCOMING_8a;
					break;
			}
			break;

		case INCOMING_8b:
			switch (messageNumber)
			{
				case P3_RX_LOGON_CALL_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					/*Pop3IF_Disconnect();*/
					Pop3IF_DeRegister();
					nextstate = INCOMING_9b;
					break;
				}

				case P3_RX_LOGON_PROCESS_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);
					Pop3IF_ReleaseData();
					/*Pop3IF_Disconnect();*/
					Pop3IF_DeRegister();
					nextstate = INCOMING_9b;
					break;
				}

				case P3_RX_LOGON_DONE:
					Pop3IF_ReleaseData();
					Pop3IF_CountMessages();
					nextstate = INCOMING_8c;
					break;

				default:
					nextstate = INCOMING_8b;
					break;
			}
			break;

		case INCOMING_8c:
			switch (messageNumber)
			{
				case P3_RX_COUNT_MESSAGES_CALL_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					Pop3IF_Disconnect();
					nextstate = INCOMING_9c;
					break;
				}

				case P3_RX_COUNT_MESSAGES_PROCESS_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);
					Pop3IF_ReleaseData();
					Pop3IF_Disconnect();
					nextstate = INCOMING_9c;
					break;
				}

				case P3_RX_COUNT_MESSAGES_DONE:
				{
					pop3.number_messages = messageData->data.pop3_CountMessages_data.num_messages;
					pop3.uid_list_size   = messageData->data.pop3_CountMessages_data.num_messages;
					if (pop3.number_messages == 0)
					{
/*>>>						StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_POP3_NO_MESSAGES, NULL);
*/						Pop3IF_ReleaseData();
						Pop3IF_Disconnect();
						nextstate = INCOMING_8o;
						break;
					}

					StateKicker_SendMessage(Screen_StateMachine, RX_SC_POP3_MESSAGE_COUNT, NULL);	/* start rummage through mailbox */

					/* Block of memory passed to AcornPOP3_GetListOfMessages needs to be
					 * in non-paged out area of memory.  Allocate a temporary dynamic area for
					 * the list of messages to avoid RMA fragmentation.
					 */

					pop3.message_list = create_dynamic_area (
					                    pop3.number_messages * sizeof (MSG_LIST),
					                    "POP3 message list",
					                    &pop3.message_list_areanum);
					if (pop3.message_list == NULL)
					{
/*>>>						StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_NO_MEMORY, NULL);
*/						Pop3IF_ReleaseData();
						Pop3IF_Disconnect();
						nextstate = INCOMING_9c;
						break;
					}

					/* Block of memory passed to AcornPOP3_GetListOfUniqueIDs needs to be
					 * in non-paged out area of memory.  Allocate a temporary dynamic area for
					 * the list of messages to avoid RMA fragmentation.
					 */
					pop3.uid_list = create_dynamic_area (
					                    pop3.uid_list_size * sizeof (UID_MSG_LIST),
					                    "POP3 uid list",
					                    &pop3.uid_list_areanum);
					if (pop3.uid_list == NULL)
					{
						free_pop3_resources ();
						Pop3IF_ReleaseData();
						Pop3IF_Disconnect();
						nextstate = INCOMING_9c;
						break;
					}

					Pop3IF_ReleaseData();
					Pop3IF_ListUniqueIDs (pop3.uid_list, pop3.number_messages);
					nextstate = INCOMING_8d;
					break;
				}

				default:
					nextstate = INCOMING_8c;
					break;
			}
			break;

		case INCOMING_8d:
			switch (messageNumber)
			{
				case P3_RX_LIST_UNIQUEIDS_CALL_ERROR:
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					free_pop3_resources ();
					Pop3IF_Disconnect();
					nextstate = INCOMING_9c;
					break;

				case P3_RX_LIST_UNIQUEIDS_PROCESS_ERROR:
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					free_pop3_resources ();
					Pop3IF_ReleaseData();
					Pop3IF_Disconnect();
					nextstate = INCOMING_9c;
					break;

				case P3_RX_LIST_UNIQUEIDS_DONE:
					Pop3IF_ReleaseData();
					pop3.delete_index = 0;
					if (pop3.delete_list_size > 0)
					{
						delete_message (pop3.delete_list[pop3.delete_index]);
						nextstate = INCOMING_8e;
					}
					else
					{
						Pop3IF_ListMessages (pop3.message_list, pop3.number_messages);
						nextstate = INCOMING_8f;
					}
					break;

				default:
					nextstate = INCOMING_8d;
					break;
			}
			break;


		case INCOMING_8e:
			switch (messageNumber)
			{
				case P3_RX_DELETE_MESSAGE_CALL_ERROR:
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					free_pop3_resources ();
					Pop3IF_Disconnect();
					nextstate = INCOMING_9c;
					break;

				case P3_RX_DELETE_MESSAGE_PROCESS_ERROR:
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					free_pop3_resources ();
					Pop3IF_ReleaseData();
					Pop3IF_Disconnect();
					nextstate = INCOMING_9c;
					break;

				case P3_RX_DELETE_MESSAGE_DONE:
					Pop3IF_ReleaseData();

					free (pop3.delete_list[pop3.delete_index]);
					
					if (++pop3.delete_index < pop3.delete_list_size)
					{
						/* More messages to delete */
						delete_message (pop3.delete_list[pop3.delete_index]);
						nextstate = INCOMING_8e;
					}
					else
					{
						/* Finished deleting messages */
						pop3.number_messages -= pop3.delete_list_size;

						/* Destroy old delete list */
						free (pop3.delete_list);
						pop3.delete_list = NULL;
						pop3.delete_list_size = 0;
						pop3.delete_index = 0;
						if (pop3.number_messages > 0)
						{
							Pop3IF_ListMessages (pop3.message_list, pop3.number_messages);
							nextstate = INCOMING_8f;
						}
						else
						{
							remove_dynamic_area (pop3.uid_list_areanum);
							pop3.uid_list = NULL;
							Pop3IF_Disconnect ();
							nextstate = INCOMING_8o;
						}
					}
					break;

				default:
					nextstate = INCOMING_8d;
					break;
			}
			break;

		case INCOMING_8f:
			switch (messageNumber)
			{
				case P3_RX_LIST_MESSAGES_CALL_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					free_pop3_resources ();
					Pop3IF_Disconnect();
					nextstate = INCOMING_9c;
					break;
				}

				case P3_RX_LIST_MESSAGES_PROCESS_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					free_pop3_resources ();
					Pop3IF_ReleaseData();
					Pop3IF_Disconnect();
					nextstate = INCOMING_9c;
					break;
				}

				case P3_RX_LIST_MESSAGES_DONE:
					/* Allocate a dynamic area to store the message headers.  Start off
					 * allocating 4k as a reasonable maximum.  If this is ever too short for
					 * a given message's headers then POP3 will return how much memory is
					 * needed, so the area can be reallocated then.
					 */
					pop3.message_headers = create_dynamic_area (4096,
					                                            "POP3 message headers",
					                                            &pop3.message_headers_areanum);
					if (pop3.message_headers == NULL)
					{
/*>>>						StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_NO_MEMORY, NULL);
*/
						free_pop3_resources ();
						Pop3IF_ReleaseData();
						Pop3IF_Disconnect();
						nextstate = INCOMING_9c;
						break;
					}

					/* Create new delete list */
					pop3.delete_list = malloc (pop3.number_messages * sizeof (char *));
					if (pop3.delete_list == NULL)
					{
						free_pop3_resources ();
						Pop3IF_ReleaseData();
						Pop3IF_Disconnect();
						nextstate = INCOMING_9c;
						break;
					}

					pop3.delete_list_size = 0;
					pop3.delete_index = 0;

					pop3.header_index = 0;
					Pop3IF_ReleaseData();
					Pop3IF_GetHeader (pop3.message_headers,
					                  pop3.message_list[pop3.header_index].msg_size,
					                  pop3.message_list[pop3.header_index].msg_id);
					nextstate = INCOMING_8g;
					break;

				default:
					nextstate = INCOMING_8f;
					break;
			}
			break;

		case INCOMING_8g:
			switch (messageNumber)
			{
				case P3_RX_GET_HEADER_CALL_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					free_pop3_resources ();
					Pop3IF_Disconnect();
					nextstate = INCOMING_9c;
					break;
				}
#if 0
				case P3_RX_GET_HEADER_PROCESS_ERROR:
				{
/*>>>					AcornPOP3_GetXLinesOfMessage_data *getheader_data =
					    (AcornPOP3_GetXLinesOfMessage_data *) messageData->data.pop3_returned_data;
*/
					switch (getheader_data->error->errnum)
					{
						case ErrorBase_AcornPOP3 + 18:    /* out of memory */
							/* Try to recover - perhaps our default memory allocation was
							 * not enough to store the headers.  Get the actual amount of
							 * memory needed and try to reallocate our buffer.
							 */

							remove_dynamic_area (pop3.message_headers_areanum);

							pop3.message_headers = create_dynamic_area (
							                           getheader_data->message_size,
							                           "POP3 message headers",
							                           &pop3.message_headers_areanum);
							if (pop3.message_headers == NULL)
							{
								StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_NO_MEMORY, NULL);
								free_pop3_resources ();
								Pop3IF_ReleaseData();
								Pop3IF_Disconnect();
								nextstate = INCOMING_9c;
								break;
							}

							Pop3IF_ReleaseData();
							Pop3IF_GetHeader (pop3.message_headers,
							                  pop3.message_list[pop3.header_index].msg_size,
							                  pop3.message_list[pop3.header_index].msg_id);
							nextstate = INCOMING_8g;
							break;

						default:
						{
							RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
							free_pop3_resources ();
							Pop3IF_ReleaseData();
							Pop3IF_Disconnect();
							nextstate = INCOMING_9c;
							break;
						}
					}
					break;
				}
#endif
				case P3_RX_GET_HEADER_DONE:
				{
					messageDataBlock *send_message;

					/* It is absolutely vital that the header structure is cleared before each message fetch
					 * otherwise data from the previous fetch could be picked up.
					 */
					free_header (&pop3.message_header);

					StateKicker_SendMessage (MimeDecode_StateMachine, RX_MD_DECODE_HDR, &send_message);
					send_message->data.decode_header.raw_header = pop3.message_headers;
					send_message->data.decode_header.message_header = (void*) &pop3.message_header;	/*RCM cast NFE_header* to void* */
					send_message->data.decode_header.size = messageData->data.pop3_GetHeader_data.message_size;
					send_message->data.decode_header.file = FALSE;
					Pop3IF_ReleaseData ();
					nextstate = INCOMING_8h;
					break;
				}

				default:
					nextstate = INCOMING_8g;
					break;
			}
			break;

		case INCOMING_8h:
			switch (messageNumber)
			{
				case MD_RX_DECODE_HDR_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					free_pop3_resources ();
					Pop3IF_Disconnect();
					nextstate = INCOMING_9c;
					break;
				}

				case MD_RX_DECODE_HDR_DONE:
				{
					int delete_message;
					int email_new_message_rc;
                    char *  unique_id;

					unique_id = uid_from_messageid (pop3.message_list[pop3.header_index].msg_id);
					if (unique_id == NULL)
					{
						/* Message has mysteriously disappeared from mailbox.  Skip it and try the next one. */
						++pop3.header_index;
						if (pop3.header_index < pop3.number_messages)
						{
							/* More headers to download */
							Pop3IF_GetHeader (pop3.message_headers,
							                  pop3.message_list[pop3.header_index].msg_size,
							                  pop3.message_list[pop3.header_index].msg_id);

							nextstate = INCOMING_8g;
						}
						else
						{
							/* No more headers to download */

							remove_dynamic_area (pop3.message_headers_areanum);
							pop3.message_headers = NULL;

							if (start_message_download ())
							{
								/* Out of memory */
								nextstate = INCOMING_9c;
							}
							else
							{
								nextstate = INCOMING_8i;
							}
						}

						break;
					}
					
					email_new_message_rc = emailrx_new_message (pop3.message_list[pop3.header_index].msg_size,
					                                            &pop3.message_header,
					                                            unique_id,
					                                            &delete_message);
					switch (email_new_message_rc)
					{
						case 0:    /* call successfully */
							/* Check if message should be marked for deletion immediately */
							if (delete_message)
							{
								pop3.delete_list[pop3.delete_list_size] = malloc (strlen (unique_id) + 1);
								if (pop3.delete_list[pop3.delete_list_size] != NULL)
								{
									strcpy (pop3.delete_list[pop3.delete_list_size],
									        unique_id);
									++pop3.delete_list_size;
								}
							}

							++pop3.header_index;
							if (pop3.header_index < pop3.number_messages)
							{
								/* More headers to download */
								Pop3IF_GetHeader (pop3.message_headers,
								                  pop3.message_list[pop3.header_index].msg_size,
								                  pop3.message_list[pop3.header_index].msg_id);

								nextstate = INCOMING_8g;
							}
							else
							{
								/* No more headers to download */

								remove_dynamic_area (pop3.message_headers_areanum);
								pop3.message_headers = NULL;

								if (start_message_download ())
								{
									/* Out of memory */
									nextstate = INCOMING_9c;
								}
								else
								{
									nextstate = INCOMING_8i;
								}
							}
							break;

						case 1:    /* couldn't add message, but was able to recover */
							remove_dynamic_area (pop3.message_headers_areanum);
							pop3.message_headers = NULL;

							if (start_message_download ())
							{
								/* Out of memory */
								nextstate = INCOMING_9c;
							}
							else
							{
								nextstate = INCOMING_8i;
							}
							break;

						default:    /* couldn't add message and couldn't recover */
						{
							messageDataBlock *send_message;

							StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_ERROR, &send_message);
							send_message->data.os_error.err.errnum = 0;
							strcpy (send_message->data.os_error.err.errmess, "Out of memory.");
							free_pop3_resources ();
							Pop3IF_Disconnect();
							nextstate = INCOMING_9c;
							break;
						}
					}
					break;
				}

				default:
					nextstate = INCOMING_8h;
					break;
			}
			break;


		case INCOMING_8i:
			switch (messageNumber)
			{
				case RX_RX_GET_DOCUMENT:
					if ((pop3.download_list_iter.finished) (&pop3.download_list_iter))
					{
						/* Finished decoding messages.  Wipe message download directory */
						remove_dynamic_area (pop3.message_list_areanum);
						pop3.message_list = NULL;

						remove_dynamic_area (pop3.uid_list_areanum);
						pop3.uid_list = NULL;

#ifndef PRESERVE_POP3
						_swix (OS_FSControl, _INR (0, 1) | _IN (3), 27, POP3_DIR, 0x3);
#endif

						list_destroy (pop3.download_list);
						pop3.download_list = NULL;

						Pop3IF_ReleaseData();
						Pop3IF_Disconnect();

						nextstate = INCOMING_8o;
					}

					else
					{
						StateKicker_SendMessage (PrintQ_MessageHandler,
						                         RX_PQ_NEW_DOCUMENT,
						                         NULL);

						nextstate = INCOMING_8j;
					}
					break;

				default:
					nextstate = INCOMING_8i;
					break;
			}
			break;


		case INCOMING_8j:
			switch (messageNumber)
			{
				case PQ_RX_ABORT_INCOMING:
				{
					messageDataBlock *send_message;

					StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_ERROR, &send_message);
					send_message->data.os_error.err.errnum = 0;
					strcpy (send_message->data.os_error.err.errmess, "Out of memory.");
					free_pop3_resources ();
					Pop3IF_Disconnect();
					nextstate = INCOMING_9c;
					break;
				}

				case PQ_RX_NEW_DOCUMENT_DIR:
				{
					char report[4097];


					pop3.document_directory = malloc (strlen (messageData->data.new_document_dir.directory) + 1);
					if (pop3.document_directory == NULL)
					{
						messageDataBlock *send_message;

						StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_ERROR, &send_message);
						send_message->data.os_error.err.errnum = 0;
						strcpy (send_message->data.os_error.err.errmess, "Out of memory.");
						free_pop3_resources ();
						Pop3IF_Disconnect();
						nextstate = INCOMING_9c;
						break;
					}

					strcpy (pop3.document_directory,
					        messageData->data.new_document_dir.directory);

					pop3.document_handle = (pop3.download_list_iter.current) (&pop3.download_list_iter);

					list_initialise_iterator (&pop3.message_list_iter,
					                          emailrx_get_doc_msg_list (pop3.document_handle));

					(void) (pop3.message_list_iter.reset) (&pop3.message_list_iter);

					pop3.page_index = 0;

					StateKicker_SendMessage (RemXfer_StateMachine,
					                         RX_RX_GET_MESSAGE,
					                         NULL);


					/* Check to see if a cover sheet is required for this document.
					 * This could be a page range report or a document size confirmation message.
					 */
					if (emailrx_cover_sheet (pop3.document_handle,
					                         report,
					                         sizeof (report),
					                         &pop3.message_header))
					{
						++pop3.page_index;	/*RCM put in to make cover sheet page 1*/
						
						if (send_report_to_printq (report))
						{
							/* error occured */
							nextstate = INCOMING_9c;
							break;
						}
#if 0
						StateKicker_SendMessage (PrintQ_MessageHandler,
						                         RX_PQ_PAGE_COMPLETE,
						                         NULL);
#endif
					}

					++pop3.page_index;

					nextstate = INCOMING_8k;
					break;
				}

				default:
					nextstate = INCOMING_8j;
					break;
			}
			break;


		case INCOMING_8k:
			switch (messageNumber)
			{
				case RX_RX_GET_MESSAGE:
					if ((pop3.message_list_iter.finished) (&pop3.message_list_iter))
					{
						char local_report[4097];
						char remote_report[4097];

						/* Check if a missing page report is required for this document */
						if (emailrx_missing_page_report (pop3.document_handle,
						                                 local_report,
						                                 remote_report,
						                                 sizeof (local_report),
						                                 sizeof (remote_report),
						                                 &pop3.message_header))
						{
							if (send_report_to_printq (local_report))
							{
								/* error occured */
								nextstate = INCOMING_9c;
								break;
							}
							++pop3.page_index;
						}

						StateKicker_SendMessage (PrintQ_MessageHandler,
						                         RX_PQ_DOCUMENT_COMPLETE,
						                         NULL);

						free (pop3.document_directory);
						pop3.document_directory = NULL;

						(void) (pop3.download_list_iter.next) (&pop3.download_list_iter);
						StateKicker_SendMessage (RemXfer_StateMachine,
						                         RX_RX_GET_DOCUMENT,
						                         NULL);
						nextstate = INCOMING_8i;
					}

					else
					{
						pop3.message_filename = malloc (strlen (POP3_DIR) + 16);    /* more than enough for maximum possible number messages */
						if (pop3.message_filename == NULL)
						{
							messageDataBlock *send_message;

							StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_ERROR, &send_message);
							send_message->data.os_error.err.errnum = 0;
							strcpy (send_message->data.os_error.err.errmess, "Out of memory.");

							free_pop3_resources ();
							Pop3IF_Disconnect();
#ifndef PRESERVE_POP3
							_swix (OS_FSControl, _INR (0, 1) | _IN (3), 27, POP3_DIR, 0x3);		/* wipe POP3 directory */
#endif
							nextstate = INCOMING_9c;
							break;
						}

						sprintf (pop3.message_filename, "%s.%d", POP3_DIR, pop3.message_index);

						pop3.message = (pop3.message_list_iter.current) (&pop3.message_list_iter);
						if (get_message (pop3.message,
						                 pop3.message_filename))
						{
							/* for some strange reason the message has disappeard from
							 * the mailbox since we connected - skip it and move onto
							 * the next one.
							 */
						}
						nextstate = INCOMING_8l;
					}
					break;

				default:
					nextstate = INCOMING_8k;
					break;
			}
			break;

		case INCOMING_8l:
			switch (messageNumber)
			{
				case P3_RX_GET_MESSAGE_CALL_ERROR:
				case P3_RX_GET_X_LINES_OF_MESSAGE_CALL_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					free_pop3_resources ();
					Pop3IF_Disconnect();
#ifndef PRESERVE_POP3
					_swix (OS_FSControl, _INR (0, 1) | _IN (3), 27, POP3_DIR, 0x3);		/* wipe POP3 directory */
#endif
					nextstate = INCOMING_9c;
					break;
				}

				case P3_RX_GET_MESSAGE_PROCESS_ERROR:
				case P3_RX_GET_X_LINES_OF_MESSAGE_PROCESS_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					free_pop3_resources ();
					Pop3IF_ReleaseData();
					Pop3IF_Disconnect();
#ifndef PRESERVE_POP3
					_swix (OS_FSControl, _INR (0, 1) | _IN (3), 27, POP3_DIR, 0x3);		/* wipe POP3 directory */
#endif
					nextstate = INCOMING_9c;
					break;
				}

				case P3_RX_GET_MESSAGE_DONE:
				case P3_RX_GET_X_LINES_OF_MESSAGE_DONE:
				{
					messageDataBlock *send_message;

					/* It is absolutely vital that the header structure is cleared before each message fetch
					 * otherwise data from the previous fetch could be picked up.
					 */
					free_header (&pop3.message_header);

					StateKicker_SendMessage (MimeDecode_StateMachine, RX_MD_DECODE_HDR, &send_message);
					send_message->data.decode_header.raw_header = pop3.message_filename;
					send_message->data.decode_header.message_header = (void*) &pop3.message_header;	/*RCM cast NFE_header* to void* */
					send_message->data.decode_header.size = pop3.message->size;
					send_message->data.decode_header.file = TRUE;
					Pop3IF_ReleaseData ();
					nextstate = INCOMING_8m;
					break;
				}

				default:
					nextstate = INCOMING_8l;
					break;
			}
			break;

		case INCOMING_8m:
			switch (messageNumber)
			{
				case MD_RX_DECODE_HDR_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					free_pop3_resources ();
					Pop3IF_Disconnect();
#ifndef PRESERVE_POP3
					_swix (OS_FSControl, _INR (0, 1) | _IN (3), 27, POP3_DIR, 0x3);		/* wipe POP3 directory */
#endif
					nextstate = INCOMING_9c;
					break;
				}

				case MD_RX_DECODE_HDR_DONE:
				{
					messageDataBlock *send_message;

					StateKicker_SendMessage (MimeDecode_StateMachine,
					                         RX_MD_DECODE_MSG,
					                         &send_message);
					send_message->data.decode_message.filename = pop3.message_filename;
					send_message->data.decode_message.document_directory = pop3.document_directory;
					send_message->data.decode_message.size = pop3.message->size;
					send_message->data.decode_message.start_page = pop3.page_index;
					send_message->data.decode_message.message_header = &pop3.message_header;

					nextstate = INCOMING_8n;
					break;
				}

				default:
					nextstate = INCOMING_8m;
					break;
			}
			break;


		case INCOMING_8n:
			switch (messageNumber)
			{
				case MD_RX_NEW_PAGE:
					StateKicker_SendMessage (PrintQ_MessageHandler,
					                         RX_PQ_NEW_PAGE,
					                         NULL);
					nextstate = INCOMING_8n;
					break;

				case MD_RX_PAGE_COMPLETE:
				{
						messageDataBlock *sendMessage;

						/* You mustn't use pop3.page_index at this point.
						 * pop3.page_index is invalid between RX_MD_DECODE_MSG and MD_RX_DECODE_MSG_DONE.
						 */

						set_filetypeDN (pop3.document_directory,
						                messageData->data.md_rx_page_complete.pageNum,
						                messageData->data.md_rx_page_complete.pageType);	/*>>>should this be done by PrintQ???*/
						StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_PAGE_COMPLETE, &sendMessage);
						sendMessage->data.rx_pq_page_complete.pageNum  = messageData->data.md_rx_page_complete.pageNum;
						sendMessage->data.rx_pq_page_complete.pageType = messageData->data.md_rx_page_complete.pageType; /* FILETYPE_TIFF, FILETYPE_TEXT or FILETYPE_CONFIG */

						nextstate = INCOMING_8n;
						break;
				}

				case MD_RX_DECODE_MSG_DONE:
				{
					pop3.delete_list[pop3.delete_list_size] = malloc (strlen (pop3.message->unique_id) + 1);
					if (pop3.delete_list[pop3.delete_list_size] != NULL)
					{
						strcpy (pop3.delete_list[pop3.delete_list_size], pop3.message->unique_id);
						++pop3.delete_list_size;
					}
					/* If the above allocation fails then don't panic: all it means is that the message won't
					 * get deleted, and may end up getting downloaded and printed twice.
					 */

					free (pop3.message_filename);
					pop3.message_filename = NULL;

					pop3.page_index = messageData->data.message_decoded.next_page;

					/* Delete the original message */
#ifndef PRESERVE_POP3
					_swix (OS_File, _INR (0, 1), 6, pop3.message_filename);
#endif

					++pop3.message_index;
					(void) (pop3.message_list_iter.next) (&pop3.message_list_iter);
					StateKicker_SendMessage (RemXfer_StateMachine,
					                         RX_RX_GET_MESSAGE,
					                         NULL);
					nextstate = INCOMING_8k;
					break;
				}

				case MD_RX_DECODE_MSG_ERROR:
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					free_pop3_resources ();
					Pop3IF_Disconnect();
#ifndef PRESERVE_POP3
					_swix (OS_FSControl, _INR (0, 1) | _IN (3), 27, POP3_DIR, 0x3);		/* wipe POP3 directory */
#endif
					nextstate = INCOMING_9c;
					break;

				default:
					nextstate = INCOMING_8n;
					break;
			}
			break;


		case INCOMING_8o:
			switch (messageNumber)
			{
				case P3_RX_DISCONNECT_CALL_ERROR:
				case P3_RX_DISCONNECT_PROCESS_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					/* deliberate drop-through into next case */
				}

				case P3_RX_DISCONNECT_DONE:
					Pop3IF_DeRegister();
					nextstate = INCOMING_8p;
					break;

				default:
					nextstate = INCOMING_8o;
					break;
			}
			break;


		case INCOMING_8p:
			switch (messageNumber)
			{
				case P3_RX_DEREGISTER_CALL_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					/* deliberate drop-through into next case */
				}

				case P3_RX_DEREGISTER_DONE:
				{
					StateKicker_SendMessage(Screen_StateMachine, RX_SC_POP3_DOWNLOAD_COMPLETE, NULL);	/* thumbs up, download complete */
					StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
					nextstate = IDLE;
					break;
				}

				default:
					nextstate = INCOMING_8p;
					break;
			}
			break;


		case INCOMING_9a:
			switch (messageNumber)
			{
				case RM_RX_GOING_IDLE:
					/*StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_GOING_IDLE, NULL); - use common code below */
					nextstate = IDLE;
					break;

				default:
					nextstate = INCOMING_9a;
					break;
			}
			break;


		case INCOMING_9b:
			switch (messageNumber)
			{
				case P3_RX_DEREGISTER_CALL_ERROR:
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */

					if (isp_via_dialler)
					{
						StateKicker_SendMessage (RemModem_StateMachine, RX_RM_HANGUP, NULL);
						nextstate = INCOMING_9a;
					}
					else
					{
						StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_END, NULL);	/* equivalent to RM_SC_DIAL_COMPLETE*/
						/*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
						nextstate = IDLE;
					}
					break;

				case P3_RX_DEREGISTER_DONE:
					if (isp_via_dialler)
					{
						StateKicker_SendMessage (RemModem_StateMachine, RX_RM_HANGUP, NULL);
						nextstate = INCOMING_9a;
					}
					else
					{
						StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_END, NULL);	/* equivalent to RM_SC_DIAL_COMPLETE*/
						/*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
						nextstate = IDLE;
					}
					break;

				default:
					nextstate = INCOMING_9b;
					break;
			}
			break;

		case INCOMING_9c:
			switch (messageNumber)
			{
				case P3_RX_DISCONNECT_CALL_ERROR:
				case P3_RX_DISCONNECT_PROCESS_ERROR:
				{
					RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);	/* forward the error to PrintQ */
					/* deliberate drop-through into next case */
				}

				case P3_RX_DISCONNECT_DONE:
					Pop3IF_DeRegister();
					nextstate = INCOMING_9b;
					break;

				default:
					nextstate = INCOMING_9c;
					break;
			}
			break;

#endif
	} /* switch (state) */

	/* report RX_SQ_GOING_IDLE if going idle from a non-idle state */
	if ((nextstate == IDLE) && (state != IDLE))
    	StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL);

	state = nextstate;

	/* Print state machine status on exit */
	dprintf((NULL, "RemXfer_StateMachine (exit): Next state => %d\n", state));
}


static void RemXfer_ForwardError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber,
                                 int forwardNumber, messageDataBlock *forwardData)
{
	messageDataBlock *sendMessage;

    StateKicker_SendMessage(StateMachine, messageNumber, &sendMessage);
    sendMessage->data = forwardData->data;
}


static void *create_dynamic_area (const size_t size, const char *const name, int *const area_number)
{
	void *area_base;

	if (_swix (OS_DynamicArea, _INR (0, 8) | _OUT (1) | _OUT (3),

	           0,
	           -1,
	           size,
	           -1,
	           1<<7,
	           size,
	           0,
	           0,
	           name,

	           area_number,
	           &area_base) != NULL)
	{
		return NULL;
	}

	return area_base;
}

static _kernel_oserror *remove_dynamic_area (const int area_number)
{
	return _swix (OS_DynamicArea, _INR (0, 1), 1, area_number);
}


static void free_header (NFE_header *header)
{
	if (header->to.address != NULL)
	{
		free (header->to.address);
		header->to.address = NULL;
	}

	if (header->to.real_name != NULL)
	{
		free (header->to.real_name);
		header->to.real_name = NULL;
	}

	if (header->from.address != NULL)
	{
		free (header->from.address);
		header->from.address = NULL;
	}

	if (header->from.real_name != NULL)
	{
		free (header->from.real_name);
		header->from.real_name = NULL;
	}

	header->date = 0;

	if (header->subject != NULL)
	{
		free (header->subject);
		header->subject = NULL;
	}

	header->id.first_page_num = 0;
	header->id.last_page_num = 0;
	header->id.doc_num = 0;
	header->id.msg_num_pages = 0;
	header->id.exact_num_pages = TRUE;

	if (header->id.iap_username != NULL)
	{
		free (header->id.iap_username);
		header->id.iap_username = NULL;
	}

	if (header->details.device != NULL)
	{
		free (header->details.device);
		header->details.device = NULL;
	}

	header->details.device_class = 0;
	memset (header->details.serial_num,
	        0,
	        SERIAL_LEN);
	header->details.software_rev_major = 0;
	header->details.software_rev_minor = 0;

	if (header->details.encryption != NULL)
	{
		free (header->details.encryption);
		header->details.encryption = NULL;
	}

	if (header->details.encryption_rev != NULL)
	{
		free (header->details.encryption_rev);
		header->details.encryption_rev = NULL;
	}

	if (header->details.domain != NULL)
	{
		free (header->details.domain);
		header->details.domain = NULL;
	}

	if (header->config.fax_num != NULL)
	{
		free (header->config.fax_num);
		header->config.fax_num = NULL;
	}

	if (header->config.phone_num != NULL)
	{
		free (header->config.phone_num);
		header->config.phone_num = NULL;
	}

	if (header->config.organisation != NULL)
	{
		free (header->config.organisation);
		header->config.organisation = NULL;
	}

	header->netfax_msg_class = NFE_NFMC_NONE;
	header->msg_class = NFE_MC_UNKNOWN;
}


static int messageid_from_uid (char *const  uid,
                               unsigned int *message_id)
{
	int i;

	/* This bit is horrendously inefficient: do a linear search through the UniqueID list,
	 * doing a strcmp to try to match the Unique ID.
	 */

	for (i = 0; i < pop3.uid_list_size; i++)
	{
		if (strcmp (uid, pop3.uid_list[i].unique_id) == 0)
		{
			*message_id = pop3.uid_list[i].msg_id;
			return 0;
		}
	}

	return 1;
}


static int compare_message_id (const void *  key,
                               const void *  uid_list_entry)
{
	return *((unsigned int *) key) - ((UID_MSG_LIST *) uid_list_entry)->msg_id;
}


static char *uid_from_messageid (const unsigned int  message_id)
{
	UID_MSG_LIST *  uid_msg_entry;

	uid_msg_entry = (UID_MSG_LIST *) bsearch (&message_id,
	                                          pop3.uid_list,
	                                          pop3.uid_list_size,
	                                          sizeof (UID_MSG_LIST),
	                                          compare_message_id);
	if (uid_msg_entry)
		return uid_msg_entry->unique_id;

	return NULL;
}


static void delete_message (char *const uid)
{
	unsigned int message_id;

	if (!messageid_from_uid (pop3.delete_list[pop3.delete_index],
	                         &message_id))
	{
		Pop3IF_DeleteMessage (message_id);
	}
}

static int get_message (message_t *message,
                        char *const message_filename)
{
	unsigned int message_id;


	if (messageid_from_uid (message->unique_id,
	                        &message_id))
	{
		return 1;
	}

	if (message->flags & MessageFlags_PartialDownload)
	{
		Pop3IF_GetXLinesOfMessage (message_filename,
		                           message->size,
		                           message_id,
		                           message->lines);
	}
	else
	{
		Pop3IF_GetMessage (message_filename,
		                   message->size,
		                   message_id);
	}

	return 0;
}

static void free_pop3_resources (void)
{
	if (pop3.message_headers != NULL)
	{
		remove_dynamic_area (pop3.message_headers_areanum);
		pop3.message_headers = NULL;
	}

	if (pop3.message_list != NULL)
	{
		remove_dynamic_area (pop3.message_list_areanum);
		pop3.message_list = NULL;
	}

	if (pop3.uid_list != NULL)
	{
		remove_dynamic_area (pop3.uid_list_areanum);
		pop3.uid_list = NULL;
	}

	if (pop3.delete_list != NULL)
	{
		free (pop3.delete_list);
		pop3.delete_list = NULL;
	}

	if (pop3.download_list != NULL)
	{
		list_destroy (pop3.download_list);
		pop3.download_list = NULL;
	}

	if (pop3.message_filename != NULL)
	{
		free (pop3.message_filename);
		pop3.message_filename = NULL;
	}

	if (pop3.document_directory != NULL)
	{
		free (pop3.document_directory);
		pop3.document_directory = NULL;
	}
}



static int start_message_download (void)
{
	unsigned int free_space;

	/* Header download is complete, start downloading fax messages.
	 * Messages are downloaded one at a time so the same filename can be used
	 * for each message.  However, the amount of space free on the filesystem
	 * could change between each call to AcornPOP3_GetMessage so this needs to
	 * be checked each time.
	 */

	remove_dynamic_area (pop3.message_headers_areanum);
	pop3.message_headers = NULL;
	#if 0
	/* Pop3 directory is created in main.c */
	#else
	/* Ensure that POP3 directory is present */
	_swix (OS_File, _INR (0, 1) | _IN (4), 8, POP3_DIR, 0);
	#endif
	/* Find free space on RAM disc so that emailrx_build_dl_list knows
	 * how much work it can do.  Bit brain dead at the moment in that
	 * the free space could change after it has been read.
	 * Knocks 10k off the free space for safety's sake.
	 */
	_swix (OS_FSControl,
	       _INR (0, 1) | _OUT (0),

	       49,
	       "RAM:$",

	       &free_space);

	pop3.download_list = emailrx_build_dl_list (free_space);
	if (pop3.download_list == NULL)
	{
		messageDataBlock *send_message;

		StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_ERROR, &send_message);
		send_message->data.os_error.err.errnum = 0;
		strcpy (send_message->data.os_error.err.errmess, "Out of memory.");
		free_pop3_resources ();
		Pop3IF_Disconnect();
		return 1;
	}

	pop3.message_index = 0;

	list_initialise_iterator (&pop3.download_list_iter,
	                          pop3.download_list);

	pop3.document_handle = (pop3.download_list_iter.reset) (&pop3.download_list_iter);
	if (pop3.document_handle != NULL)
	{
		StateKicker_SendMessage (Screen_StateMachine, RX_SC_POP3_DOWNLOAD_START, NULL);
	}

	StateKicker_SendMessage (RemXfer_StateMachine,
	                         RX_RX_GET_DOCUMENT,
	                         NULL);

	return 0;
}


static void file_error (void)
{
	messageDataBlock *send_message;
	_kernel_oserror *e;

	StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_ERROR, &send_message);
	e = _kernel_last_oserror ();
	if (e)
	{
		send_message->data.os_error.err = *e;
	}
	else
	{
		strcpy (send_message->data.os_error.err.errmess,
		        lookup_message_token (&message_block, "EmailReport_Error"));
	}
	free_pop3_resources ();
	Pop3IF_Disconnect();
#ifndef PRESERVE_POP3
	_swix (OS_FSControl, _INR (0, 1) | _IN (3), 27, POP3_DIR, 0x3);		/* wipe POP3 directory */
#endif
}


static int send_report_to_printq (char *const report)
{
	char report_filename[257];
	FILE *fp;
	messageDataBlock *sendMessage;

	/* Report required.  Write report out to PrintQ */
	StateKicker_SendMessage (PrintQ_MessageHandler,
	                         RX_PQ_NEW_PAGE,
	                         NULL);

	sprintf (report_filename,
	         "%s.%d",
	         pop3.document_directory,
	         pop3.page_index);

	fp = fopen (report_filename, "w");
	if (fp == NULL)
	{
		file_error ();
		return 1;
	}

	if (fputs (report,
	           fp) == EOF)
	{
		file_error ();
		return 1;
	}

	if (fclose (fp) == EOF)
	{
		file_error ();
		return 1;
	}

	set_filetypeDN(pop3.document_directory, pop3.page_index, FILETYPE_TEXT);	/*>>>should this be done by PrintQ???*/
	StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_PAGE_COMPLETE, &sendMessage);
	sendMessage->data.rx_pq_page_complete.pageNum  = pop3.page_index;
	sendMessage->data.rx_pq_page_complete.pageType = FILETYPE_TEXT;

	return 0;
}


/* end of RemXfer.c */


