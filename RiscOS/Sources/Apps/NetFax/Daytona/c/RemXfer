/*
 * RemXfer.c - Remote modem (external phone line) data transfer state machine
 *
 * R C Manby
 * - with additions by S B Forrest
 *
 * Started 29 July 1997
 *
 * 1998-02-25: BAL
 * Fixed bug: original POP3 messages were not being deleted.
 * Made 'Out of memory' error messages be more specific.
 *
 * 1998-03-08: BAL
 * Changed handling of PQ_RX_ABORT_INCOMING message; I had thought that this
 * meant 'drop everything and abort' whereas it really means 'just don't send
 * me any more documents in this session'.
 *
 * Before this was done, PQ_RX_ABORT_INCOMING showed up a fault in the delete
 * list handling: the list data was being destroyed but the indices were not
 * being reset properly.
 *
 * 1998-03-19: BAL
 * If state INCOMING_8e gets message it's not interested in it stays in the
 * same state instead of changing to state INCOMING_8d (copy & paste bug).
 *
 * 1998-03-20 - 1998-03-25: BAL
 * Now copes with messages being deleted from the email account behind Daytona's
 * back.
 *
 * Now copes with lying POP3 servers that report message sizes as being smaller
 * than they really are.
 *
 * Reinstated coping with messages with very large headers (by default we
 * allow 4k for the headers) and fixed a nasty bug in it at the same time (was
 * using the size of the whole message in some places rather than just the size
 * of the headers).
 *
 * A little bit of tidying up, more comments etc.
 *
 * 1998-05-06: BAL
 * Email receive changed significantly.  In particular, messages no longer
 * deleted until they have been printed.  Automatically redials if it knows
 * there are more messages on the server to be downloaded.
 *
 * 1998-05-06: BAL
 * Fixed a stupid bug introduced by the new email code - it now 'processes'
 * the document list even if the mailbox is empty; code was assuming that
 * some messages would have been downloaded so was trying to free resources
 * that were never allocated.
 *
 * 1998-05-18: BAL
 * Fixed bug: now send RX_PQ_DOCUMENT_COMPLETE if an error occurs while we're
 * placing a document in the PrintQ.  Without this, the next time we try to
 * put a document in the PrintQ, the PrintQ would reject the request because
 * as far as it is concerned it is still busy.  Fixes PAN-01848.
 *
 * 1998-05-20: BAL
 * Added code to support integration of email receive into High Water-Mark
 * system.
 *
 * 1998-05-21: BAL
 * Fixed bug in new High Water-Mark code: wasn't resetting space_reserved
 * to zero at the start of a new download.
 *
 * 1998-05-26: BAL
 * PAN-02022: creation of delete and print lists is now done right after POP3
 * first connects.  Fixed bug in delete_next_message - wasn't resetting to
 * start of list after creating iterator (how did it ever work at all, I
 * wonder?).
 *
 * 1998-06-08: BAL
 * Added MemCheck support.
 *
 * Fixed high watermark bug - not all memory was being released after a
 * successful download session (was on error though).
 *
 * Removed free_pop3_resources and wipe_pop3_directory calls from places where
 * error is first detected into common exit state for all errors.  (Did same
 * for 'normal' exit path just to be safe).
 */


#include "BuildFlags.h"
#include "StdTypes.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"


#include "swis.h"  /* N.B,  Only required if deletion of ZModem files on TX is enabled
                    * Now required for creation and removal of dynamic areas and POP3 directory as well
                    */

#include "MemCheck/MemCheck.h"

#include "NetFax/NFELib/NFELib.h"
#if SUPPORT_EMAIL
#include "acornpop3.h"
#endif
#include "PageList.h"
#include "StateKicker.h"
#include "PrintQ.h"
#include "SendQ.h"
#include "RemXfer.h"
#include "RemModem.h"
#include "Screen.h"

#include "wimp.h"
#include "Serial.h"
#include "FaxIF.h"
#include "ZmodemIF.h"
#include "SmtpIF.h"

#include "AddrBookIF.h"
#include "QuStruct.h"
#include "QuCommon.h"

#include "MimeQ.h"

#include "DebugLib.h"
#include "MimeIF.h"

#include "SetupIF.h"
#include "FileOps.h"
#include "AddrFile.h"

#include "list.h"
#include "emailrx.h"

#include "toolbox.h"
#include "msglib.h"

#include "main.h"

#define FIX_PAN01827 1  /* Fix suppression of all ZMODEM errors on page receive/send, now suppresses appropriate errors only */ 

#if SUPPORT_EMAIL
BOOL RemXfer_Lockout_Incoming = FALSE;  /* set by PrintQ when it receives RX_PQ_MAIL_WAITING */
                                        /* prevents interleaving of direct incoming faxes with partial email download */
/* when set, RemXfer won't accept incoming calls - Take great care with this!. */

#endif

#if SUPPORT_EMAIL
#include "Pop3IF.h"
#endif
/*#include "DebugLib.h"*/

/*
 * N.B.  THE FOLLOWING ARE CITED FOR REMOVAL!
 */
/*>>> start of temporary variables/definitions */
static char* LOC_ADDR_BOOK = "RAM::RamDisc0.$.AddrBook.Local";   /* Location of address book details to send to remote Daytona */
static char* REM_ADDR_BOOK = "RAM::RamDisc0.$.AddrBook.Remote";  /* Location to store received address book details */
/*<<< end of temporary variables/definitions */


#if SUPPORT_EMAIL

#define POP3_DEFAULT_HEADER_SIZE 4096

typedef struct
{
    int number_messages;

    MSG_LIST *message_list;
    int message_list_areanum;

    char *message_headers;
    int message_headers_areanum;
    unsigned int message_headers_areasize;

    NFE_header message_header;

    list_handle  delete_list;
    list_handle  print_list;

    UID_MSG_LIST *uid_list;
    int           uid_list_areanum;
    int           uid_list_size;

    unsigned int header_index;
    unsigned int message_index;
    unsigned int page_index;
    unsigned int retry;

    document_handle document_handle;
    message_t       *message;

    list_iterator_t  document_list_iter;
    list_iterator_t  message_list_iter;

    char *document_directory;
    char *message_filename;

    unsigned int  space_used;
    unsigned int  space_reserved;

    unsigned int  reconnect;
} pop3_data_t;

typedef struct
{
    unsigned int  pid;
    message_t **  message;
    int           index;
} print_info_t;

/* POP3 email retreive */
static pop3_data_t pop3;

#endif

/*
 * Internal states of RemXfer_StateMachine()
 */

enum _States { IDLE = 0,
 /*fax*/       INCOMING_2a, INCOMING_2b, INCOMING_2c, INCOMING_2d,
               INCOMING_SWITCHOVER,
 /*Daytona*/   INCOMING_3a, INCOMING_3b, INCOMING_3c, INCOMING_3d, INCOMING_3e,
 /*fax*/       OUTGOING_4a, OUTGOING_4b, OUTGOING_4c, /*OUTGOING_4d,*/ OUTGOING_4e, OUTGOING_4f,
               OUTGOING_SWITCHOVER,
 /*Daytona*/   OUTGOING_5a, OUTGOING_5b, OUTGOING_5c, OUTGOING_5d, OUTGOING_5e, OUTGOING_5f
#if SUPPORT_EMAIL
             , OUTGOING_6a, OUTGOING_6b, OUTGOING_6c, OUTGOING_6d,
               OUTGOING_7a, OUTGOING_7b, OUTGOING_7c, OUTGOING_7d, OUTGOING_7e,
               OUTGOING_10a,
               INCOMING_8a, INCOMING_8b, INCOMING_8c, INCOMING_8d, INCOMING_8e, INCOMING_8f, INCOMING_8g, INCOMING_8h, INCOMING_8i, INCOMING_8j,
               INCOMING_8k, INCOMING_8l, INCOMING_8m, INCOMING_8n, INCOMING_8o, INCOMING_8p,
               INCOMING_9a, INCOMING_9b, INCOMING_9c
#endif
             };
typedef enum _States States;




/* Declare function prototypes */
#if SUPPORT_EMAIL
static States  get_message (void);
#endif

static void  RemXfer_ForwardError (
                 void                (*StateMachine) (
                                         int                 messageNumber,
                                         messageDataBlock *  messagedata),
                 int                 messageNumber,
                 int                 forwardNumber,
                 messageDataBlock *  forwardData);

#if SUPPORT_EMAIL
static void RemXfer_SendOSError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber, _kernel_oserror *error);

static void RemXfer_SendRCError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber, /*const*/ char *text, int rc);


static void *  create_dynamic_area (const size_t       size,
                                    const char *const  name,
                                    int *const         area_number);

static _kernel_oserror *  remove_dynamic_area (const int  area_number);

static void  free_header (NFE_header *  header);

static int  messageid_from_uid (char *const     uid,
                                unsigned int *  message_id);

static char *  uid_from_messageid (const unsigned int  message_id);

static int compare_message_id (const void *  key,
                               const void *  uid_list_entry);

static int  delete_next_message (void);

static int  get_next_message (void);

static document_handle  next_document_to_print (void);

static void  free_pop3_resources (void);

static int  start_message_download (void);

static int send_memory_report_to_printq (const PageClasses  page_class,
                                         const PageTypes    page_type,
                                         char *const        report);

static void memory_report_file_error (void);

static void  send_file_report_to_printq (const PageClasses  page_class,
                                         const PageTypes    page_type,
                                         char *const        filename);

static int do_missing_page_reports (const NFE_address *const  from);

static void  finish_download_session (void);

static void  wipe_pop3_directory (void);

static void  add_msg_to_delete_list (const char *const  unique_id);

static void  free_delete_info (void *  data);

static int  add_doc_to_print_list (const unsigned int  pid);

static void  free_print_info (void *  data);

static void  print_confirmed (unsigned int  pid);

static int  match_pid (const void *const  list_item,
                       const void *const  search_data);

#endif /*support_email*/



extern void RemXfer_StateMachine(int messageNumber, messageDataBlock *messageData)
{
    static States state = IDLE;
    static BOOL   aborting = FALSE;
    static unsigned int stash_Process_Id;
    static char   directory[256];           /* Document directory */
    static unsigned int stash_loPage;
    static unsigned int stash_hiPage;
    static BOOL   stash_pageStream;
    static unsigned int stash_fax_lastpage;
#if SUPPORT_EMAIL
    /* Email send/retrieve variables */
    static BOOL isp_via_dialler = TRUE; /* when FALSE, using LAN */
    static BOOL tx_flag = FALSE;
    static BOOL rx_flag = FALSE;
    static BOOL tx_error = FALSE;
  /*static unsigned int stash_Process_Id = 0;*/
  /*static unsigned int stash_hiPage;*/
    static char stash_to_emailaddress[256];
#endif

    /* ZModem-orientated variables */
    static int  page_counter = 0;        /* Keep account of current page */
    static char pathname[255];           /* Pathname of file to TX/RX */

    States nextstate = state;

    /* Print state machine status */
    dprintf((NULL, "RemXfer_StateMachine (entry): State => %d; Message => 0x%X\n", state, messageNumber));

    /* switch on error suppression if initiating an ABORT */
    if (messageNumber == PQ_RX_ABORT_INCOMING)
        aborting = TRUE;

    /* switch off error suppression on return to IDLE state after ABORT completes */
    if (state == IDLE)
        aborting = FALSE;

#if SUPPORT_EMAIL
    if (RemXfer_Lockout_Incoming)
    {
        /* waiting for the PrintQ to empty before resuming an email download,                       */
        /* so refuse any incoming calls to prevent interleaving with partially downloaded documents */
        switch (messageNumber)
        {
            case RM_RX_INCOMING_FAX:
            case RM_RX_INCOMING_DAYTONA:
            case RM_RX_INCOMING_VOICE:
                /* we can't handle this, so hangup */
                StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                return;
        }
    }
#endif

    if (state != IDLE)
    {
        /* common code to reject messages that are only acceptable when IDLE */
        switch (messageNumber)
        {
                case SQ_RX_DIAL_FAX:
                case SQ_RX_DIAL_DAYTONA:
#if SUPPORT_EMAIL
                case SQ_RX_DIAL_ISP:
#if SUPPORT_LAN
                case SQ_RX_DIAL_LAN:
#endif
#endif
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);
                    return;

                case RM_RX_INCOMING_FAX:
                case RM_RX_INCOMING_DAYTONA:
                case RM_RX_INCOMING_VOICE:
                    /* we can't handle this, so hangup */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    return;
        }
    }

    /* Handle asynchronous messages that can occur in any state */
    switch (messageNumber)
    {
#if SUPPORT_EMAIL
        case PQ_RX_PRINT_CONFIRMED:
            print_confirmed (messageData->data.pq_rx_print_confirmed.pid);
            return;
#endif
        default:
            break;
    }


    /* main state machine and message decoder */
    switch (state)
    {
        case IDLE:
            switch (messageNumber)
            {
                case SQ_RX_QUERY_IDLE:
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_QUERY_IDLE, NULL);
                    nextstate = state;  /* unchanged */
                    break;

                case RM_RX_AM_IDLE:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_AM_IDLE, NULL);     /* idle now, but an incoming call could start before SendQ receives this */
                    nextstate = state;  /* unchanged */
                    break;

                case RM_RX_INCOMING_FAX:
                    {
                        messageDataBlock *sendMessage;

                        /* request creation of a document directory to hold the incoming fax */
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_DOCUMENT, &sendMessage);
                        sendMessage->data.rx_pq_new_document.Source = PqRxDIRECT;
                        nextstate = INCOMING_2a;
                    }
                    break;

                case RM_RX_INCOMING_DAYTONA:
                    {
                        messageDataBlock *sendMessage;

                        /* request creation of a document directory to hold the incoming fax/text */
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_DOCUMENT, &sendMessage);
                        sendMessage->data.rx_pq_new_document.Source = PqRxDIRECT;
                        nextstate = INCOMING_3a;
                    }
                    break;

                case RM_RX_INCOMING_VOICE:
                    /* we can't handle this, so hangup */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;    /* wait for RemModem to go Idle */
                    break;

                case SQ_RX_DIAL_FAX:
                    {
                        messageDataBlock *sendMessage;

                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DIAL_FAX, &sendMessage);
                        strcpy(sendMessage->data.dial.number, messageData->data.dial.number);
                        nextstate = OUTGOING_4a;
                    }
                    break;

                case SQ_RX_DIAL_DAYTONA:
                    {
                        messageDataBlock *sendMessage;

                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DIAL_DAYTONA, &sendMessage);
                        strcpy(sendMessage->data.dial.number, messageData->data.dial.number);
                        nextstate = OUTGOING_5a;
                    }
                    break;
#if SUPPORT_EMAIL
                case SQ_RX_DIAL_ISP:
                    {
                        messageDataBlock *sendMessage;

                        isp_via_dialler = TRUE;
                        tx_flag = messageData->data.sq_rx_dial_isp.tx_flag;
                        rx_flag = messageData->data.sq_rx_dial_isp.rx_flag;
                        tx_error = FALSE;
                        /* tx_flag  rx_flag                                                */
                        /*  TRUE     TRUE   - normal connect, send mail then retrieve mail */
                        /*  TRUE     FALSE  - send only (water mark triggered)             */
                        /*  FALSE    TRUE   - retrieve only                                */
                        if (tx_flag)
                            StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_START, NULL);   /* Kick off the MIME encoding while the dial-up and LogOn happens */

                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DIAL_ISP, &sendMessage);
                        strcpy(sendMessage->data.dial.number, messageData->data.sq_rx_dial_isp.number);
                        nextstate = OUTGOING_6a;
                    }
                    break;
#if SUPPORT_LAN
                /* not quite the right message name, but everything else is SQ_RX_DIAL_xxx */
                case SQ_RX_DIAL_LAN:
                    {
                        isp_via_dialler = FALSE;
                        tx_flag = messageData->data.sq_rx_dial_lan.tx_flag;
                        rx_flag = messageData->data.sq_rx_dial_lan.rx_flag;
                        tx_error = FALSE;

                        if (tx_flag)
                            StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_START, NULL);   /* Kick off the MIME encoding while the dial-up and LogOn happens */

                        StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_START, NULL);
                        StateKicker_SendMessage(RemXfer_StateMachine, RX_RX_TXCONNECTED, NULL); /* if configured for LAN, assume connected */
                        nextstate = OUTGOING_6a;
                    }
                    break;
#endif
#endif
            }
            break;

     /*                               */
     /* Incoming - from a fax machine */
     /*                               */
        case INCOMING_2a:           /* waiting for PrintQ to tell us where to put the fax being received */
            switch (messageNumber)
            {
                case RM_RX_ERROR:
                    /* Be paranoid: It should be impossible for any error to be reported between the sending of */
                    /* RX_PQ_NEW_DOCUMENT and the reply PQ_RX_NEW_DOCUMENT_DIR (or PQ_RX_ABORT_INCOMING).       */
                    /* If it does happen, assume !Fax will report an error, and recover then.                   */
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    break;

                case PQ_RX_ABORT_INCOMING:
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;    /* wait for RemModem to go Idle */
                    break;

                case PQ_RX_NEW_DOCUMENT_DIR:
                    /* Capture PId & directory details */
                    stash_Process_Id = messageData->data.new_document_dir.pid;
                    strcpy(directory, messageData->data.new_document_dir.directory);

                    /* pass modem ownership to !Fax, telling !Fax where to place the scanned pages */
                    FaxIF_ReceiveFax(REMMODEM, messageData->data.new_document_dir.directory);
                    nextstate = INCOMING_2b;
                    break;
            }
            break;

        case INCOMING_2b:
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    /* tell !Fax to abort reception */
                    FaxIF_Abort(REMMODEM);  /* should reply with Error_Aborted (FX015) */
                    break;
#if SUPPORT_SLOWDOWN
                case PQ_RX_SLOW_INCOMING:
                    FaxIF_Slow(REMMODEM);
                    break;
#endif
#if SUPPORT_SWITCHOVER
                case FX_SWITCHOVER:
#if 0
    /*>>>put this in sometime*/
    /*>>>since we don't distinguish between fax in and data in anywhere, this isn't needed */
                    /* Tell PrintQ we are switching to Daytona data transfer mode */
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_SWITCHTO_DAYTONA, NULL);   /* ie tell address book caller is a Daytona */
#endif
                    /* run a dialler script to change from fax to data mode */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DO_SWITCHOVER, NULL);
                    nextstate = INCOMING_SWITCHOVER;
                    break;
#endif
                case FX_ERROR:
                    /*>>>report error to PrintQ if aborting flag is clear */
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
#if /*THINK*/ 1
                    /* A 'T1 Timeout' error after connection & before any data transfer is */
                    /* probably a voice caller (later T1 Timeouts are treated as genuine). */
                    if ((messageData->data.error.ctx == ctx_Fax_OSError) &&
                        (messageData->data.error.rc == 0x011 /*ERROR_T1_TIMEOUT*/)
                       )
                    {
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_MAYBE_VOICE, NULL);    /* Send a supplementary message */
                    }
#endif
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;
                    break;

                case FX_NORMAL_TERMINATION:
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;
                    break;

                case FX_RECEIVING_PAGE:
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_PAGE, NULL);   /* mainly to trigger animations, but may PQ_RX_ABORT_INCOMING if short of memory */
                    nextstate = INCOMING_2c;
                    break;
            }
            break;

        case INCOMING_2c:
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    /* tell !Fax to abort reception */
                    FaxIF_Abort(REMMODEM);  /* should reply with Error_Aborted (FX015) */
                    break;
#if SUPPORT_SLOWDOWN
                case PQ_RX_SLOW_INCOMING:
                    FaxIF_Slow(REMMODEM);
                    break;
#endif
                case FX_ERROR:
                    /*>>>report error*/
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                  /*StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_ABORTED, NULL);*/
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;
                    break;

                case FX_RECEIVED_PAGE:
                    {
                        messageDataBlock *sendMessage;

                        /*set_filetypeDN(directory, messageData->data.fx_received_page.lastpage, FILETYPE_TIFF);*/  /*done by PrintQ*/
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_COMPLETE, &sendMessage);
                        sendMessage->data.rx_pq_page_complete.pageNum  = messageData->data.fx_received_page.lastpage;
                        sendMessage->data.rx_pq_page_complete.pageClass = PageClass_TIFF;
                        sendMessage->data.rx_pq_page_complete.pageType = PageType_TIFF_2DMMR;
                        sendMessage->data.rx_pq_page_complete.fileType = FILETYPE_TIFF;

                        nextstate = INCOMING_2b;    /* wait for next page, or end of document */
                    }
                    break;
            }
            break;

        /* also used from state IDLE with message RM_RX_INCOMING_VOICE */
        case INCOMING_2d:           /* waiting for RemModem to disconnect */
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    nextstate = state;      /* doing our best, so ignore */
                    break;

                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;
            }
            break;
#if SUPPORT_SWITCHOVER
        case INCOMING_SWITCHOVER:
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;    /* wait for RemModem to go Idle */
                    break;

                case RM_RX_ERROR:
                    /*>>>report error to PrintQ if aborting flag is clear */
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_2d;
                    break;

                case RM_RX_SWITCHOVER_DONE: /* c.f. INCOMING_3a with PQ_RX_NEW_DOCUMENT_DIR */
                    /* pass modem ownership to ZModem; tell ZModem to send our address book details */
                    {
                        ZModemMessage zmodemtx;

                        /* PId & directory was captured in INCOMING_2a PQ_RX_NEW_DOCUMENT_DIR */

                        /* Reset page counter ready for receipt of new document */
                        page_counter = 1;
                        dprintf((NULL, "ZModem page counter reset\n"));

                        /* Send our address book details and capabilities, so that the remote (caller) machine may identify us */
                        AddrFile_Create_Recipient_AddressRecord(LOC_ADDR_BOOK); /* should already exist, but will re-create if setup has changed */
                        ZModemIF_SendMessage(REMMODEM, LOC_ADDR_BOOK, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = INCOMING_3b;
                    }
                    break;
            }
            break;
#endif

     /*                                 */
     /* Incoming - from another Daytona */
     /*                                 */
        case INCOMING_3a:           /* waiting for PrintQ to tell us where to put the document being received */
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_3e;
                    break;

                case PQ_RX_NEW_DOCUMENT_DIR:
                    /* pass modem ownership to ZModem; tell ZModem to send our address book details */
                    {
                        ZModemMessage zmodemtx;

                        /* Capture PId & directory details */
                        stash_Process_Id = messageData->data.new_document_dir.pid;
                        strcpy(directory, messageData->data.new_document_dir.directory);

                        /* Reset page counter ready for receipt of new document */
                        page_counter = 1;
                        dprintf((NULL, "ZModem page counter reset\n"));

                        /* Send our address book details, so that the remote (caller) machine may identify us */
                        AddrFile_Create_Recipient_AddressRecord(LOC_ADDR_BOOK); /* should already exist, but will re-create if setup has changed */
                        ZModemIF_SendMessage(REMMODEM, LOC_ADDR_BOOK, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = INCOMING_3b;
                    }
                    break;
            }
            break;

        case INCOMING_3b:           /* waiting for ZModem to confirm transmission of local address */
            switch (messageNumber)
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer local address details) */
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_3e;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Sent local address book details OK, so receive senders' */
                    {
                        ZModemMessage zmodemrx;

                        /* Fetch caller's address book details and list of files it wishes to send */
                        ZModemIF_SendMessage(REMMODEM, REM_ADDR_BOOK, WM_ZMODEM_RX, &zmodemrx);  /*>>>receive into directory.Remote*/
                        nextstate = INCOMING_3c;
                    }
                    break;
            }
            break;

        case INCOMING_3c:           /* waiting for ZModem to confirm receipt of remote address */
            switch (messageNumber)
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer remote address details) */
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_3e;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Received remote address book details OK */
                    {
                        ZModemMessage zmodemrx;

                        if (aborting)
                        {
                            remove(REM_ADDR_BOOK);
                            StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                            StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                            nextstate = INCOMING_3e;
                            break;
                        }

                        /* Decode received caller details - add address details to document */
                        if (AddrFile_Decode_Originator_File(REM_ADDR_BOOK, stash_Process_Id))
                        {
                            /*>>>report some sort of incompatibility error*/
                            remove(REM_ADDR_BOOK);
                            StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                            StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                            nextstate = INCOMING_3e;
                            break;
                        }

                        /* tell PrintQ to display received address book details */
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_DETAILS, NULL);

                        /* Having decided to accept the incoming files, open the received filelist, so we can classify */
                        /* each file as it arrives. NB it MUST be closed & deleted on completion or error */
                        AddrFile_Originator_FileList_Open(REM_ADDR_BOOK);
/*>>>we need to decode the file list here? or can we just receive files and let the PrintQ characterise them based on the file list?*/

                        /* Construct the full pathname for the page (file) to receive */
                        sprintf(pathname, "%s.%d", directory, page_counter);

                        /* Tell PrintQ that the receive is about to commence */
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_PAGE, NULL);

                        /* Receive the page using ZModem protocols */
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_RX, &zmodemrx);
                        nextstate = INCOMING_3d;
                    }
                    break;
            }
            break;

        case INCOMING_3d:           /* waiting for ZModem to confirm receipt of page */
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    {
                        ZModemMessage zmodemabort;

                        /* Inform ZModem, asking it to abort the current transfer */
                        ZModemIF_SendMessage(REMMODEM, NULL, WM_ZMODEM_ABORT, &zmodemabort);

                        AddrFile_Originator_FileList_Close(REM_ADDR_BOOK);      /* close filelist (and delete REM_ADDR_BOOK?) */
                        remove(REM_ADDR_BOOK);
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                        nextstate = INCOMING_3e;
                    }
                    break;

                case ZM_RX_ERROR:  /* Error condition (failed to receive page or at end of document) */
#if FIX_PAN01827
                    /* A 'terminated' error is the normal document terminator, anything else is an error to be reported */
                    if (!((messageData->data.error.ctx == ctx_ZModem_RCError) && (messageData->data.error.rc == ZM_ZMODEMTERMINATED)))
                        RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
#endif
                  /*StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_ABORTED, NULL);*/
                    AddrFile_Originator_FileList_Close(REM_ADDR_BOOK);      /* close filelist (and delete REM_ADDR_BOOK?) */
                    remove(REM_ADDR_BOOK);
                    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_COMPLETE, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = INCOMING_3e;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Confirmation that previous page was received OK */
                    {
                        messageDataBlock *sendMessage;
                        ZModemMessage zmodemrx;
                        PageClasses pageClass = PageClass_TIFF;
                        PageTypes pageType = PageType_TIFF_2DMMR;
                        int fileType = FILETYPE_TIFF;

                        AddrFile_Originator_FileList_GetClassAndType(page_counter, &pageClass, &pageType, &fileType);   /*>>>what about errors*/

                        /*>>>NB assume TIFF for now*/
                        /*set_filetypeDN(directory, page_counter, fileType);*/  /*should this be done by PrintQ*/
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_PAGE_COMPLETE, &sendMessage);
                        sendMessage->data.rx_pq_page_complete.pageNum  = page_counter;
                        sendMessage->data.rx_pq_page_complete.pageClass = pageClass;
                        sendMessage->data.rx_pq_page_complete.pageType = pageType;
                        sendMessage->data.rx_pq_page_complete.fileType = fileType;

                        /* Increment page counter; construct full pathname of next page (file) to receive */
                        page_counter += 1;
                        sprintf(pathname, "%s.%d", directory, page_counter);
                        dprintf((NULL, "ZModem page counter incremented: page => %d\n", page_counter));

                        /* Tell PrintQ that the receive is about to commence */
                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_PAGE, NULL);

                        /* Receive the page using ZModem protocols */
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_RX, &zmodemrx);
                        nextstate = state;        /* unchanged */
                    }
                    break;
            }
            break;

        case INCOMING_3e:           /* waiting for RemModem to disconnect */
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                    nextstate = state;        /* doing our best, so ignore */
                    break;

                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;
            }
            break;

     /*                             */
     /* Outgoing - to a fax machine */
     /*                             */
        case OUTGOING_4a:           /* waiting for RemModem to connect */
            switch (messageNumber)
            {
                case RM_RX_DIAL_REJECTED:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);   /* because of incoming call */
                    nextstate = IDLE;   /* code below will issue RX_SQ_GOING_IDLE */
                    break;

                case RM_RX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;    /* wait for RM_RX_GOING_IDLE */
                    break;

                case RM_RX_TXCONNECTED:
                    /* When dialling in fax mode, RM_RX_TXCONNECTED is reported when the dial completes, */
                    /* not when a connection has been established */

                    /* ask SendQ which document is to be sent to the number we connected too */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_WHICH_DOCUMENT, NULL);
                    nextstate = OUTGOING_4b;
                    break;
            }
            break;

        case OUTGOING_4b:           /* waiting for SendQ to tell us which document to send */
            switch (messageNumber)
            {
                case SQ_RX_THIS_DOCUMENT:
                    /* Capture details of document (fax or text) to send */
                    stash_Process_Id = messageData->data.this_document.pid;
                    strcpy(directory, messageData->data.this_document.directory);
                    stash_loPage = messageData->data.this_document.loPage;
                    stash_hiPage = messageData->data.this_document.hiPage;
                    stash_pageStream = messageData->data.this_document.pageStream;
                    /* the above is for the benefit of ZMODEM, incase a data switchover occurs */

                    /* pass modem ownership to !Fax, telling !Fax which pages to send */
                    FaxIF_SendFax(REMMODEM, messageData->data.this_document.directory,
                                            messageData->data.this_document.loPage, /* usually 1 */
                                            0,                                      /*>>>what should page range be?*/
                                            TRUE                                    /* delete pages successfully sent */
                                 );

                    nextstate = OUTGOING_4c;
                    break;
            }
            break;
#if /*THINK*/ 0
/*>>>RCM says: should we have a RX_SQ_SENDING_DOCUMENT message (c.f. email send) to indicate */
/*>>>          that fax has connected to something, because at the momemt SendQ thinks !fax */
/*>>>          connected after the dial completes whereas ISP and ZMODEM get a modem 'connect' */
/*>>>          before asking WHICH_DOCUMENT/SENDING_DOCUMENT */
/*>>>          We would send RX_SQ_SENDING_DOCUMENT in OUTGOING_4c on all messages except FX_ERROR*/
/*>>>          Would also need RX_SQ_SENDING_DOCUMENT after WHICH_DOCUMENT for ZMODEM */
#endif
        case OUTGOING_4c:   /* identical to OUTGOING_4d, but handles FX_SWITCHOVER */
            switch (messageNumber)
            {
#if SUPPORT_SWITCHOVER
                case FX_SWITCHOVER:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_CONNECTED, NULL);           /* special frame indicates call answered by a Daytona or TFax */

                    /* Tell SendQ we are switching from fax to Daytona data transfer mode */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SWITCHTO_DAYTONA, NULL);    /* ie tell address book recipient is a Daytona */

                    /* run a dialler script to change from fax to data mode */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_DO_SWITCHOVER, NULL);
                    nextstate = OUTGOING_SWITCHOVER;
                    break;
#endif
                case FX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
#if /*THINK*/ 1
                    /* A 'T1 Timeout' error after connection & before any data transfer is */
                    /* probably a voice receiver (later T1 Timeouts are treated as genuine). */
                    if ((messageData->data.error.ctx == ctx_Fax_OSError) &&
                        (messageData->data.error.rc  == 0x011 /*ERROR_T1_TIMEOUT*/)
                       )
                    {
                        /* Remote receiver has answered, but doesn't whistle like a fax machine */
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_MAYBE_VOICE, NULL);             /* give strong hint to SendQ that its not worth redialling */
                    }
#endif
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);               /* we've sent as much of the current document as we can */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

                case FX_NORMAL_TERMINATION:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

                case FX_SENDING_PAGE:
                    {
                        messageDataBlock *sendMessage;

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_CONNECTED, NULL);                   /* connected to a fax machine */

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_DOCUMENT, &sendMessage);    /* starting to send document */
                        sendMessage->data.rx_sq_sending_document.pid = stash_Process_Id;

                        stash_fax_lastpage = messageData->data.fx_sending_page.lastpage;    /* always reports lastpage of zero for sending first page */
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, &sendMessage);
                      /*sendMessage->data.rx_sq_sending_page.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_sending_page.page = stash_loPage;           /* because of redials, first page may not be one, so use loPage we gave to fax */
                        nextstate = OUTGOING_4e;
                    }
                    break;
            }
            break;
#if 0
        case OUTGOING_4d:   /* identical to OUTGOING_4c, but excludes FX_SWITCHOVER */
            switch (messageNumber)
            {
                case FX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);               /* we've sent as much of the current document as we can */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

                case FX_NORMAL_TERMINATION:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

                case FX_SENDING_PAGE:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, NULL);
                    nextstate = OUTGOING_4e;
                    break;
            }
            break;
#endif

        /* NB We don't use the FX_SENT_PAGE message because it is confusing!. */
        /*    Fax sends multiple FX_SENDING_PAGE & FX_SENT_PAGE pairs if the  */
        /*    receiver requests a retransmission of a corrupt page, or if a   */
        /*    large page is chopped into smaller ones for sending.            */
        /*                                                                    */
        /*    Instead, we use the 'lastpage successfully sent' field of the   */
        /*    FX_SENDING_PAGE & FX_NORMAL_TERMINATION messages to determine   */
        /*    when to send our LX_PQ_SENDING_PAGE & LX_PQ_PAGE_SENT messages. */

        case OUTGOING_4e:
            switch (messageNumber)
            {
                case FX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_FAILED, NULL); /*>>>is this used?*/
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

                case FX_NORMAL_TERMINATION:
                    if (stash_fax_lastpage != messageData->data.fx_normal_termination.lastpage)
                    {
                        messageDataBlock *sendMessage;

                        /* fax now reporting a different lastpage, so must have sent a page */
                        stash_fax_lastpage = messageData->data.fx_normal_termination.lastpage;

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_SENT, &sendMessage);
                      /*sendMessage->data.rx_sq_page_sent.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_page_sent.page = stash_fax_lastpage;
                    }

                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

#if 0
                case FX_SENT_PAGE:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_SENT, NULL);
                    nextstate = OUTGOING_4d;
                    break;
#else
                case FX_SENDING_PAGE:
                    if (stash_fax_lastpage != messageData->data.fx_sending_page.lastpage)
                    {
                        messageDataBlock *sendMessage;

                        /* fax now reporting a different lastpage, so must have sent a page */
                        stash_fax_lastpage = messageData->data.fx_sending_page.lastpage;

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_SENT, &sendMessage);
                      /*sendMessage->data.rx_sq_page_sent.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_page_sent.page = stash_fax_lastpage;

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, &sendMessage);
                      /*sendMessage->data.rx_sq_sending_page.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_sending_page.page = stash_fax_lastpage + 1;
                    }
                    nextstate = OUTGOING_4e;
                    break;
#endif
            }
            break;

        case OUTGOING_4f:
            switch (messageNumber)
            {
                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;
            }
            break;
#if SUPPORT_SWITCHOVER
        case OUTGOING_SWITCHOVER:
            switch (messageNumber)
            {
                case RM_RX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_4f;
                    break;

                case RM_RX_SWITCHOVER_DONE: /* c.f. OUTGOING_5b with SQ_RX_THIS_DOCUMENT */
                    {
                        ZModemMessage zmodemrx;

                        /* directory, was set in OUTGOING_4b */

                        /* Reset page counter ready for new document */
                        page_counter = stash_loPage;    /* stashed by OUTGOING_4b message SQ_RX_THIS_DOCUMENT, usually 1 */
                        dprintf((NULL, "ZModem page counter reset\n"));

                        /* Fetch recipients address and capabilities details */
                        ZModemIF_SendMessage(REMMODEM, REM_ADDR_BOOK, WM_ZMODEM_RX, &zmodemrx);
                        nextstate = OUTGOING_5c;
                    }
                    break;
            }
            break;
#endif
     /*                               */
     /* Outgoing - to another Daytona */
     /*                               */
        case OUTGOING_5a:
            switch (messageNumber)
            {
                case RM_RX_DIAL_REJECTED:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);   /* because of incoming call */
                    nextstate = IDLE;   /* code below will issue RX_SQ_GOING_IDLE */
                    break;

                case RM_RX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_5f;    /* wait for RM_RX_GOING_IDLE */
                    break;

                case RM_RX_TXCONNECTED:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_CONNECTED, NULL);

                    /* ask SendQ which document is to be sent to the number we connected to */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_WHICH_DOCUMENT, NULL);
                    nextstate = OUTGOING_5b;
                    break;
            }
            break;

        case OUTGOING_5b:                       /* waiting for SendQ to tell us which document to send */
            switch (messageNumber)
            {
                case SQ_RX_THIS_DOCUMENT:
                    {
                        ZModemMessage zmodemrx;

                        /* Capture details of document (fax or text) to send */
                        stash_Process_Id = messageData->data.this_document.pid;
                        strcpy(directory, messageData->data.this_document.directory);
                        stash_loPage = messageData->data.this_document.loPage;
                        stash_hiPage = messageData->data.this_document.hiPage;
                        stash_pageStream = messageData->data.this_document.pageStream;

                        /* Reset page counter ready for new document */
                        page_counter = stash_loPage;    /*>>>what about text files*/
                        dprintf((NULL, "ZModem page counter reset\n"));

                        /* Fetch recipients address and capabilities details */
                        ZModemIF_SendMessage(REMMODEM, REM_ADDR_BOOK, WM_ZMODEM_RX, &zmodemrx);
                        nextstate = OUTGOING_5c;
                    }
                    break;
            }
            break;

        case OUTGOING_5c:
            switch (messageNumber)          /* waiting for ZModem to confirm receipt of remote address and capabilities details */
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer remote address details) */
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_5f;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Received remote address book capabilities details OK, so send our address and filelist */
                    {
                        ZModemMessage zmodemtx;

                        /*>>>update screen to show recipient details */
#if 1
                        /*>>>decode address book and capabilities, make sure we can talk to the remote recipient*/
                        /*>>>*/
#if 1
                        if (AddrFile_Decode_Recipient_AddressRecord(REM_ADDR_BOOK, stash_Process_Id))
                        {
                            /*>>>report some sort of incompatibility error*/
                            remove(REM_ADDR_BOOK);
                            StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                            StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                            nextstate = OUTGOING_5f;
                            break;
                        }
#endif
                        /* Send our address book details, so that the remote machine may identify us */
                        /* plus a list of the files we are sending ie create and send an originator file */

                        strcpy(pathname, directory);    /* Construct the full pathname of the file */
                        strcat(pathname, ".Local");
                        if (AddrFile_Create_Originator_File(stash_Process_Id, pathname, stash_loPage, stash_hiPage, stash_pageStream))
                        {   /*>>>errors!*/
                            /* unable to create originator file */
                        }
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_TX, &zmodemtx);  /* send file */
#else
                        /* Send our address book details, so that the remote machine may identify us */
                        ZModemIF_SendMessage(REMMODEM, LOC_ADDR_BOOK, WM_ZMODEM_TX, &zmodemtx);
#endif
                        nextstate = OUTGOING_5d;
                    }
                    break;
            }
            break;

        case OUTGOING_5d:
            switch (messageNumber)          /* waiting for ZModem to confirm transmission of local address */
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer local address details) */
                    remove(pathname);   /* delete our originator_File */
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_5f;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Sent local address book details OK */
                    {
                        messageDataBlock *sendMessage;
                        ZModemMessage zmodemtx;

                        remove(pathname);   /* delete our originator file */

                        /* Tell SendQ that the document send is about to commence */
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_DOCUMENT, &sendMessage);
                        sendMessage->data.rx_sq_sending_document.pid = stash_Process_Id;

                        /* Construct the full pathname of the page (file) to send */
                        sprintf(pathname, "%s.%d", directory, page_counter);

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, &sendMessage);
                      /*sendMessage->data.rx_sq_sending_page.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_sending_page.page = page_counter;

                        /* Send the page using ZModem protocols */
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = OUTGOING_5e;
                    }
                    break;
            }
            break;

        case OUTGOING_5e:
            switch (messageNumber)          /* waiting for ZModem to confirm transmission of page */
            {
                case ZM_RX_ERROR:  /* Error condition (failed to transfer page or at end of document) */
#if FIX_PAN01827
                    /* A 'file not found' error is the normal document terminator, anything else is an error to be reported */
                    if (!((messageData->data.error.ctx == ctx_ZModem_RCError) && (messageData->data.error.rc == ZM_FILENOTFOUND)))
                        RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
#endif
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_FAILED, NULL);
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = OUTGOING_5f;
                    break;

                case ZM_RX_NORMAL_TERMINATION:  /* Confirmation that previous page was sent OK */
                    {
                        messageDataBlock *sendMessage;
                        ZModemMessage zmodemtx;

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_SENT, &sendMessage);
                      /*sendMessage->data.rx_sq_page_sent.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_page_sent.page = page_counter;

                        /*>>> Delete page <pathname> here if desired, code follows <<<*/
                        #if 0
                        {
                                _kernel_swi_regs reg;

                                reg.r[0] = 6;
                                reg.r[1] = (int)pathname;
                                _kernel_swi(OS_File, &reg, &reg);
                        }
                        #endif

                        /* Increment page counter; construct full pathname of next page (file) to send */
                        page_counter += 1;
                        sprintf(pathname, "%s.%d", directory, page_counter);
                        dprintf((NULL, "ZModem page counter incremented: page => %d\n", page_counter));
#if 0
/* Old code we need to remove */
/*>>>would be a good idea to check if the page exists here!*/
                        /* Tell SendQ that the send is about to commence */
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, &sendMessage);
                      /*sendMessage->data.rx_sq_sending_page.pid = stash_Process_Id;*/
                        sendMessage->data.rx_sq_sending_page.page = page_counter;

                        /* Send the page using ZModem protocols */
                        ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_TX, &zmodemtx);
                        nextstate = state;       /* unchanged */
#else
/* New code that causes a problem at receiver end - so DON'T use yet */
                        /* Check if the page exists */
                        if (stash_pageStream)
                        {
                            /* our stash_hiPage may be out of date now, so refresh it */
                            stash_hiPage = SendQ_QuerryTx_hiPage(stash_Process_Id);
                        }

                        if (page_counter <= stash_hiPage)
                        {
                            /* Tell SendQ that the send is about to commence */
                            StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE, &sendMessage);
                          /*sendMessage->data.rx_sq_sending_page.pid = stash_Process_Id;*/
                            sendMessage->data.rx_sq_sending_page.page = page_counter;

                            /* Send the page using ZModem protocols */
                            ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_TX, &zmodemtx);
                            nextstate = state;       /* unchanged */
                        }
                        else
                        {
                            /* we've sent as many pages as the SendQ wants us to */
#if 1
                            /* use a non-existant file to signal the end of transmission */
                            sprintf(pathname, "%s.Stop", directory);
                            ZModemIF_SendMessage(REMMODEM, pathname, WM_ZMODEM_TX, &zmodemtx);
                            nextstate = state;       /* unchanged */
#else
                            StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);
                            StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                            nextstate = OUTGOING_5f;
#endif
                        }
#endif
                    }
                    break;
            }
            break;

        case OUTGOING_5f:
            switch (messageNumber)
            {
                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;
            }
            break;
#if SUPPORT_EMAIL
     /* Connect to ISP                                                          */
     /*   ie Delete emails that were downloaded and printed by the last connect */
     /*      Send queued emails                                                 */
     /*      Download emails for printing                                       */
        case OUTGOING_6a:           /* waiting for RemModem to connect */
            switch (messageNumber)
            {
                case RM_RX_DIAL_REJECTED:
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DIAL_REJECTED, NULL);   /* because of incoming call */

                    if (tx_flag)
                    {
                        StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_STOP, NULL);    /* Kill the MIME encoding */
                        nextstate = OUTGOING_6b;
                        break;
                    }

                    nextstate = IDLE;   /* code below will issue RX_SQ_GOING_IDLE */
                    break;

                case RM_RX_ERROR:
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */

                    if (tx_flag)
                    {
                        tx_error = TRUE;
                        StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_STOP, NULL);    /* Kill the MIME encoding */
                        nextstate = OUTGOING_7e;    /* wait for ME_RX_STOPPED, issue HANGUP, wait for RM_RX_GOING_IDLE */
                    }
                    else
                    {
                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                        nextstate = OUTGOING_10a;   /* wait for RM_RX_GOING_IDLE */
                    }
                    break;
#if SUPPORT_LAN
                case RX_RX_TXCONNECTED: /* if configured for LAN, assume connected */
#endif
                case RM_RX_TXCONNECTED: /* dialled ISP and connected */
                    {
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_CONNECTED, NULL);

                        if (tx_flag)
                        {
                            SmtpIF_Register();
                            nextstate = OUTGOING_7a;
                        }
                        else
                        {
                            Pop3IF_Register();
                            nextstate = INCOMING_8a;
                        }
                    }
                    break;
            }
            break;

        case OUTGOING_6b:           /* dial rejected/failed - waiting for MimeEncoder to stop */
            switch (messageNumber)
            {
                case ME_RX_STOPPED:
                    nextstate = IDLE;   /* code below will issue RX_SQ_GOING_IDLE */
                    break;
            }
            break;

        /* Send queued emails */
        case OUTGOING_7a:           /* trying to register with SMTP */
            switch (messageNumber)
            {
                case SP_RX_REGISTER_ERROR:
                    tx_error = TRUE;
                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_STOP, NULL);    /* Kill the MIME encoding */
                    nextstate = OUTGOING_7e;    /* wait for MIME encoder to stop, then hang-up */
                    break;

                case SP_RX_REGISTER_DONE:
                    stash_Process_Id = 0;   /* about to start the first document of this batch of emails */
                    StateKicker_SendMessage(MailQ_StateMachine, RX_MQ_WHICH_MAILFILE, NULL);
                    nextstate = OUTGOING_7b;
                    break;
            }
            break;

        case OUTGOING_7b:           /* waiting for a mailfile to send */
            switch (messageNumber)
            {
                case MQ_RX_NO_MORE_MAIL:
                    if (stash_Process_Id != 0)
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);

                    SmtpIF_DeRegister();
                    nextstate = OUTGOING_7d; /* does a redundent RX_ME_PREFETCH_STOP for us */
                    break;

                case MQ_RX_THIS_MAILFILE:
                    {
                        messageDataBlock *sendMessage;

                        if (stash_Process_Id != messageData->data.this_mailfile.pid)
                        {
                            /* different pid, so this mailfile is a new document */

                            /* stash_Process_Id is initialised to zero in OUTGOING_7a, so if now non-zero, this is not the first document */
                            if (stash_Process_Id != 0)
                                StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);   /* previous document has gone */

                            /* First/next document has emerged from the queue */
                            stash_Process_Id = messageData->data.this_mailfile.pid;
                            SendQ_emailaddress_from_pid(stash_to_emailaddress, stash_Process_Id);

                            StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_DOCUMENT, &sendMessage);    /* starting to send first/next document */
                            sendMessage->data.rx_sq_sending_document.pid = stash_Process_Id;
                        }

                        stash_loPage = messageData->data.this_mailfile.loPage;
                        stash_hiPage = messageData->data.this_mailfile.hiPage;
                      /*strcpy(stash_filename, messageData->data.this_mailfile.filename);*/

                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_SENDING_PAGE_RANGE, &sendMessage);
                        sendMessage->data.sending_page_range.pid = stash_Process_Id;
                        sendMessage->data.sending_page_range.loPage = stash_loPage;
                        sendMessage->data.sending_page_range.hiPage = stash_hiPage;

                        SmtpIF_SendMail(messageData->data.this_mailfile.filename, stash_to_emailaddress, setup_from_mailaddress, setup_smtp_server);
                        nextstate = OUTGOING_7c;
                    }
                    break;
            }
            break;

        case OUTGOING_7c:           /* SMTP is sending our file */
            switch (messageNumber)
            {
                case SP_RX_SENDMAIL_ERROR:  /* SmtpIF_SendMail failed */
                    tx_error = TRUE;

#if 1
                    /* tell the MailQ to delete the mailfile - MUST do this to allow MailQ to go Idle */
                    /* one could argue that a different message name should be used */
                    StateKicker_SendMessage(MailQ_StateMachine, RX_MQ_MAILFILE_SENT, NULL);
#endif

                    RemXfer_ForwardError(SendQ_MessageHandler, RX_SQ_ERROR, messageNumber, messageData);    /* forward the error to SendQ */
                    StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_DOCUMENT_SENT, NULL);               /* we've stopped sending current document */
                    SmtpIF_DeRegister();
                    nextstate = OUTGOING_7d; /* does RX_ME_PREFETCH_STOP for us */
                    break;

                case SP_RX_SENDMAIL_DONE:
                    {
                        messageDataBlock *sendMessage;
                        /* tell the SendQ which range of pages were sent */
                        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_PAGE_RANGE_SENT, &sendMessage);
                        sendMessage->data.page_range_sent.pid = stash_Process_Id;
                        sendMessage->data.page_range_sent.loPage = stash_loPage;
                        sendMessage->data.page_range_sent.hiPage = stash_hiPage;

                        /* let the MailQ know the MIME mailfile has gone and can be deleted     */
                        /* if the encoding is stalled through lack of space it will now restart */
                        StateKicker_SendMessage(MailQ_StateMachine, RX_MQ_MAILFILE_SENT, NULL);

                        /* ask for the next MIME mailfile holding either more pages of the current */
                        /* document or the first pages of a new document (different Process_Id)    */
                        StateKicker_SendMessage(MailQ_StateMachine, RX_MQ_WHICH_MAILFILE, NULL);
                        nextstate = OUTGOING_7b;
                    }
                    break;
            }
            break;

        case OUTGOING_7d:           /* waiting for DeRegister to complete */
            switch (messageNumber)
            {
                case SP_RX_DEREGISTER_ERROR:    /* we don't care about errors from Smtp_DeRegister, treat as done */
                case SP_RX_DEREGISTER_DONE:
                    StateKicker_SendMessage(MimeEncode_StateMachine, RX_ME_PREFETCH_STOP, NULL);    /* Kill the MIME encoding */
                    nextstate = OUTGOING_7e;
                    break;
            }
            break;

        case OUTGOING_7e:           /* common 'end of email transmit' handler */
            switch (messageNumber)
            {
                case ME_RX_STOPPED:
                    /* the send process has completed (with or without error) */
                    /* we only do a mail retrieve if the send succeeded and a retreive was requested */
                    if ((tx_error) || (!rx_flag))
                    {
                        if (isp_via_dialler)
                        {
                            StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                            nextstate = OUTGOING_10a;
                        }
                        else
                        {
                            StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_END, NULL);  /* equivalent to RM_SC_DIAL_COMPLETE*/
                            /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                            nextstate = IDLE;
                        }
                    }
                    else
                    {
                        /* Register with AcornPOP3 module as start of retreive operation */
                        Pop3IF_Register();
                        nextstate = INCOMING_8a;
                    }
                    break;
            }
            break;

        case OUTGOING_10a:          /* waiting for dialler hangup */
            switch (messageNumber)
            {
                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;
            }
            break;

#if SUPPORT_EMAIL

        /* Retrieve emails from ISP */
        case INCOMING_8a:
            switch (messageNumber)
            {
                case P3_RX_REGISTER_CALL_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */

                    if (isp_via_dialler)
                    {
                        StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                        nextstate = INCOMING_9a;
                    }
                    else
                    {
                        StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_END, NULL);  /* equivalent to RM_SC_DIAL_COMPLETE*/
                        /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                        nextstate = IDLE;
                    }
                    break;
                }

                case P3_RX_REGISTER_DONE:
                    emailrx_tidy ();
                /*StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_POP3_LOGON, NULL)*/
                    Pop3IF_Logon(setup_username, setup_password, setup_pop3_server);
                    nextstate = INCOMING_8b;
                    break;

                default:
                    nextstate = INCOMING_8a;
                    break;
            }
            break;

        case INCOMING_8b:
            switch (messageNumber)
            {
                case P3_RX_LOGON_CALL_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    /*Pop3IF_Disconnect();*/
                    Pop3IF_DeRegister();
                    nextstate = INCOMING_9b;
                    break;
                }

                case P3_RX_LOGON_PROCESS_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);
                    Pop3IF_ReleaseData();
                    /*Pop3IF_Disconnect();*/
                    Pop3IF_DeRegister();
                    nextstate = INCOMING_9b;
                    break;
                }

                case P3_RX_LOGON_DONE:
                    Pop3IF_ReleaseData();
                    Pop3IF_CountMessages();               /*>>>RCM says: should this be moved after the list creation???*/

                    /* Do one-time initialisation.  This initialisation
                     * will only occur the first time this code is
                     * executed.
                     */
                    if (pop3.delete_list == NULL)
                    {
                        pop3.delete_list = list_create (free_delete_info);
                    }

                    if (pop3.print_list == NULL)
                    {
                        pop3.print_list = list_create (free_print_info);
                    }

                    if (pop3.delete_list == NULL || pop3.print_list == NULL)
                    {
                        RemXfer_SendRCError(PrintQ_MessageHandler, RX_PQ_ERROR, "Not enough memory to scan mailbox.", 1);
                        nextstate = INCOMING_9c;               /*>>>RCM says: should we call Pop3IF_Disconnect(); ???*/
                    }

                    nextstate = INCOMING_8c;
                    break;

                default:
                    nextstate = INCOMING_8b;
                    break;
            }
            break;

        case INCOMING_8c:
            switch (messageNumber)
            {
                case P3_RX_COUNT_MESSAGES_CALL_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;
                }

                case P3_RX_COUNT_MESSAGES_PROCESS_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);
                    Pop3IF_ReleaseData();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;
                }

                case P3_RX_COUNT_MESSAGES_DONE:
                {
                    pop3.number_messages = messageData->data.pop3_CountMessages_data.num_messages;
                    pop3.uid_list_size   = messageData->data.pop3_CountMessages_data.num_messages;
                    if (pop3.number_messages == 0)
                    {
/*>>>                       StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_POP3_NO_MESSAGES, NULL);
*/                      Pop3IF_ReleaseData();
#if 0
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_8o;
#else
                        if (start_message_download ())
                        {
                            /* Out of memory - start_message_download has already called Pop3IF_Disconnect */
                            nextstate = INCOMING_9c;
                        }
                        else
                        {
                            nextstate = INCOMING_8i;
                        }
#endif
                        break;
                    }

                    StateKicker_SendMessage(Screen_StateMachine, RX_SC_POP3_MESSAGE_COUNT, NULL);   /* start rummage through mailbox */

                    /* Block of memory passed to AcornPOP3_GetListOfMessages needs to be
                     * in non-paged out area of memory.  Allocate a temporary dynamic area for
                     * the list of messages to avoid RMA fragmentation.
                     */

                    pop3.message_list = create_dynamic_area (
                                        pop3.number_messages * sizeof (MSG_LIST),
                                        "POP3 message list",
                                        &pop3.message_list_areanum);
                    if (pop3.message_list == NULL)
                    {
/*>>>                       StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_NO_MEMORY, NULL);
*/                      Pop3IF_ReleaseData();
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                        break;
                    }

                    /* Block of memory passed to AcornPOP3_GetListOfUniqueIDs needs to be
                     * in non-paged out area of memory.  Allocate a temporary dynamic area for
                     * the list of messages to avoid RMA fragmentation.
                     */
                    pop3.uid_list = create_dynamic_area (
                                        pop3.uid_list_size * sizeof (UID_MSG_LIST),
                                        "POP3 uid list",
                                        &pop3.uid_list_areanum);
                    if (pop3.uid_list == NULL)
                    {                                 /*>>>RCM says: should we free pop3.message_list here???*/
                        Pop3IF_ReleaseData();
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                        break;
                    }

                    Pop3IF_ReleaseData();
                    Pop3IF_ListUniqueIDs (pop3.uid_list, pop3.number_messages);
                    nextstate = INCOMING_8d;
                    break;
                }

                default:
                    nextstate = INCOMING_8c;
                    break;
            }
            break;

        case INCOMING_8d:
            switch (messageNumber)
            {
                case P3_RX_LIST_UNIQUEIDS_CALL_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_LIST_UNIQUEIDS_PROCESS_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    Pop3IF_ReleaseData();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_LIST_UNIQUEIDS_DONE:
                    Pop3IF_ReleaseData();
                    if (delete_next_message ())
                    {
                        nextstate = INCOMING_8e;
                    }
                    else
                    {
                        Pop3IF_ListMessages (pop3.message_list, pop3.number_messages);
                        nextstate = INCOMING_8f;
                    }
                    break;

                default:
                    nextstate = INCOMING_8d;
                    break;
            }
            break;


        case INCOMING_8e:
            switch (messageNumber)
            {
                case P3_RX_DELETE_MESSAGE_CALL_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_DELETE_MESSAGE_PROCESS_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    Pop3IF_ReleaseData();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_DELETE_MESSAGE_DONE:
                    Pop3IF_ReleaseData();

                    /* Finished deleting messages */
                    --pop3.number_messages;

                    if (delete_next_message ())
                    {
                        nextstate = INCOMING_8e;
                    }
                    else
                    {
                        if (pop3.number_messages > 0)
                        {
                            Pop3IF_ListMessages (pop3.message_list, pop3.number_messages);
                            nextstate = INCOMING_8f;
                        }
                        else
                        {
                            if (pop3.uid_list)
                            {
                                remove_dynamic_area (pop3.uid_list_areanum);
                                pop3.uid_list = NULL;
                            }
#if 1
                            if (start_message_download ())
                            {
                                /* Out of memory - start_message_download has already called Pop3IF_Disconnect */
                                nextstate = INCOMING_9c;
                            }
                            else
                            {
                                nextstate = INCOMING_8i;
                            }
#else
                            Pop3IF_Disconnect ();
                            nextstate = INCOMING_8o;
#endif
                        }
                    }
                    break;

                default:
                    nextstate = INCOMING_8e;
                    break;
            }
            break;

        case INCOMING_8f:
            switch (messageNumber)
            {
                case P3_RX_LIST_MESSAGES_CALL_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;
                }

                case P3_RX_LIST_MESSAGES_PROCESS_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    Pop3IF_ReleaseData();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;
                }

                case P3_RX_LIST_MESSAGES_DONE:
                    /* Allocate a dynamic area to store the message headers.  Start off
                     * allocating 4k as a reasonable maximum.  If this is ever too short for
                     * a given message's headers then POP3 will return how much memory is
                     * needed, so the area can be reallocated then.
                     */
                    pop3.message_headers_areasize = POP3_DEFAULT_HEADER_SIZE;
                    pop3.message_headers = create_dynamic_area (pop3.message_headers_areasize,
                                                                "POP3 message headers",
                                                                &pop3.message_headers_areanum);
                    if (pop3.message_headers == NULL)
                    {
/*>>>                       StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_NO_MEMORY, NULL);
*/
                        Pop3IF_ReleaseData();
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                        break;
                    }

                    pop3.header_index = 0;
                    pop3.retry = 0;
                    Pop3IF_ReleaseData();
                    Pop3IF_GetHeader (pop3.message_headers,
                                      pop3.message_headers_areasize,
                                      pop3.message_list[pop3.header_index].msg_id);
                    nextstate = INCOMING_8g;
                    break;

                default:
                    nextstate = INCOMING_8f;
                    break;
            }
            break;

        case INCOMING_8g:
            switch (messageNumber)
            {
                case P3_RX_GET_HEADER_CALL_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_GET_HEADER_PROCESS_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    Pop3IF_ReleaseData();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_GET_HEADER_RETRY:
                    /* There wasn't enough space to store the headers for this message.
                     * Reallocate enough memory and try again.
                     */

                    Pop3IF_ReleaseData();

                    if (pop3.retry)
                    {
                        /* We already have retried, so this would be a retry
                         * of the retry.  Something is clearly very wrong,
                         * so abandon the download.
                         */
                        RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                    }
                    else
                    {
                        if (pop3.message_headers)
                        {
                            remove_dynamic_area (pop3.message_headers_areanum);
                        }

                        pop3.message_headers = create_dynamic_area (
                                                   messageData->data.pop3_GetHeader_data.message_size,
                                                   "POP3 message headers",
                                                   &pop3.message_headers_areanum);
                        if (pop3.message_headers == NULL)
                        {
    /*>>>                        StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_NO_MEMORY, NULL);
    */
                            Pop3IF_Disconnect();
                            nextstate = INCOMING_9c;
                            break;
                        }

                        pop3.message_headers_areasize = messageData->data.pop3_GetHeader_data.message_size;
                        Pop3IF_GetHeader (pop3.message_headers,
                                          pop3.message_headers_areasize,
                                          pop3.message_list[pop3.header_index].msg_id);
                        pop3.retry = 1;
                        nextstate = INCOMING_8g;
                    }
                    break;

                case P3_RX_GET_HEADER_DONE:
                {
                    messageDataBlock *send_message;


                    pop3.retry = 0;
                    free_header (&pop3.message_header);

                    StateKicker_SendMessage (MimeDecode_StateMachine, RX_MD_DECODE_HDR, &send_message);
                    send_message->data.decode_header.raw_header = pop3.message_headers;
                    send_message->data.decode_header.message_header = (void*) &pop3.message_header; /*RCM cast NFE_header* to void* */
                    send_message->data.decode_header.size = messageData->data.pop3_GetHeader_data.message_size;
                    send_message->data.decode_header.file = FALSE;
                    Pop3IF_ReleaseData ();
                    nextstate = INCOMING_8h;
                    break;
                }

                default:
                    nextstate = INCOMING_8g;
                    break;
            }
            break;

        case INCOMING_8h:
            switch (messageNumber)
            {
                case MD_RX_DECODE_HDR_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;
                }

                case MD_RX_DECODE_HDR_DONE:
                {
                    int delete_message;
                    int email_new_message_rc;
                    char *  unique_id;

                    unique_id = uid_from_messageid (pop3.message_list[pop3.header_index].msg_id);
                    if (unique_id == NULL)
                    {
                        /* Message has mysteriously disappeared from mailbox.  Skip it and try the next one. */
                        ++pop3.header_index;
                        if (pop3.header_index < pop3.number_messages)
                        {
                            /* More headers to download */
                            pop3.retry = 0;
                            Pop3IF_GetHeader (pop3.message_headers,
                                              pop3.message_headers_areasize,
                                              pop3.message_list[pop3.header_index].msg_id);

                            nextstate = INCOMING_8g;
                        }
                        else
                        {
                            /* No more headers to download */

                            if (pop3.message_headers)
                            {
                                remove_dynamic_area (pop3.message_headers_areanum);
                                pop3.message_headers = NULL;
                            }

                            if (start_message_download ())
                            {
                                /* Out of memory - start_message_download has already called Pop3IF_Disconnect */
                                nextstate = INCOMING_9c;
                            }
                            else
                            {
                                nextstate = INCOMING_8i;
                            }
                        }

                        break;
                    }

                    email_new_message_rc = emailrx_new_message (pop3.message_list[pop3.header_index].msg_size,
                                                                &pop3.message_header,
                                                                unique_id,
                                                                HWM_Query_MaxSpace (),
                                                                &delete_message);
#ifdef TEST
                    emailrx_dump_doc_list_to_file (emailrx_get_doc_list (),
                                                   "ADFS::4.$.doclist");
#endif
                    switch (email_new_message_rc)
                    {
                        case 0:    /* call successfully */
                            /* Check if message should be marked for deletion immediately */
                            if (delete_message)
                            {
                                add_msg_to_delete_list (unique_id);
                            }

                            ++pop3.header_index;
                            if (pop3.header_index < pop3.number_messages)
                            {
                                /* More headers to download */
                                Pop3IF_GetHeader (pop3.message_headers,
                                                  pop3.message_headers_areasize,
                                                  pop3.message_list[pop3.header_index].msg_id);

                                nextstate = INCOMING_8g;
                            }
                            else
                            {
                                /* No more headers to download */

                                if (pop3.message_headers)
                                {
                                    remove_dynamic_area (pop3.message_headers_areanum);
                                    pop3.message_headers = NULL;
                                }

                                if (start_message_download ())
                                {
                                    /* Out of memory - start_message_download has already called Pop3IF_Disconnect */
                                    nextstate = INCOMING_9c;
                                }
                                else
                                {
                                    nextstate = INCOMING_8i;
                                }
                            }
                            break;

                        case 1:    /* couldn't add message, but was able to recover */
                            if (pop3.message_headers)
                            {
                                remove_dynamic_area (pop3.message_headers_areanum);
                                pop3.message_headers = NULL;
                            }

                            if (start_message_download ())
                            {
                                /* Out of memory - start_message_download has already called Pop3IF_Disconnect */
                                nextstate = INCOMING_9c;
                            }
                            else
                            {
                                nextstate = INCOMING_8i;
                            }
                            break;

                        default:    /* couldn't add message and couldn't recover */
                        {
#if 1
                            /* RCM says: we MUST use RemXfer_SendRCError (or RemXfer_SendOSError) rather than rolling our own error messages */
                            RemXfer_SendRCError(PrintQ_MessageHandler, RX_PQ_ERROR, "Not enough memory to scan mailbox.", 1);
#else
                            messageDataBlock *send_message;

                            StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_ERROR, &send_message);
                            send_message->data.os_error.err.errnum = 0;
                            strcpy (send_message->data.os_error.err.errmess, "Not enough memory to scan mailbox.");
#endif
                            Pop3IF_Disconnect();
                            nextstate = INCOMING_9c;
                            break;
                        }
                    }
                    break;
                }

                default:
                    nextstate = INCOMING_8h;
                    break;
            }
            break;


        case INCOMING_8i:
            switch (messageNumber)
            {
                case RX_RX_GET_DOCUMENT:
                    pop3.document_handle = next_document_to_print ();
                    if (pop3.document_handle)
                    {
                        messageDataBlock *sendMessage;

                        StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_NEW_DOCUMENT, &sendMessage);
                        sendMessage->data.rx_pq_new_document.Source = PqRxISP;

                        nextstate = INCOMING_8j;
                    }
                    else
                    {
                        finish_download_session ();
                        nextstate = INCOMING_8o;
                    }
                    break;

                default:
                    nextstate = INCOMING_8i;
                    break;
            }
            break;


        case INCOMING_8j:
            switch (messageNumber)
            {
                case PQ_RX_ABORT_INCOMING:
                {
                    /* The word 'abort' is perhaps a bit strong.  What this really means is that
                     * the PrintQ just wants us to not give it any more stuff, so we just clean
                     * up - anything we throw away will be got in the next session.
                     */
                    finish_download_session ();
                    nextstate = INCOMING_8o;
                    break;
                }

                case PQ_RX_NEW_DOCUMENT_DIR:
                {
                    char report[4097];

                    pop3.document_directory = malloc (strlen (messageData->data.new_document_dir.directory) + 1);
                    if (pop3.document_directory == NULL)
                    {
#if 1
                        /* RCM says: we MUST use RemXfer_SendRCError (or RemXfer_SendOSError) rather than rolling our own error messages */
                        RemXfer_SendRCError(PrintQ_MessageHandler, RX_PQ_ERROR, "Not enough memory to print document.", 2);
#else
                        messageDataBlock *send_message;

                        StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_ERROR, &send_message);
                        send_message->data.os_error.err.errnum = 0;
                        strcpy (send_message->data.os_error.err.errmess, "Not enough memory to print document.");
#endif
                        StateKicker_SendMessage (PrintQ_MessageHandler,
                                                 RX_PQ_DOCUMENT_COMPLETE,
                                                 NULL);

                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                        break;
                    }

                    strcpy (pop3.document_directory,
                            messageData->data.new_document_dir.directory);

                    list_initialise_iterator (&pop3.message_list_iter,
                                              emailrx_get_doc_msg_list (pop3.document_handle));

                    M_list_reset (pop3.message_list_iter);

                    pop3.page_index = 0;

                    if (add_doc_to_print_list (messageData->data.new_document_dir.pid))
                    {
                        RemXfer_SendRCError(PrintQ_MessageHandler, RX_PQ_ERROR, "Not enough memory to print document.", 2);
                        StateKicker_SendMessage (PrintQ_MessageHandler,
                                                 RX_PQ_DOCUMENT_COMPLETE,
                                                 NULL);
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                        break;
                    }

                    StateKicker_SendMessage (RemXfer_StateMachine,
                                             RX_RX_GET_MESSAGE,
                                             NULL);


                    /* Check to see if a cover sheet is required for this document.
                     * This could be a page range report or a document size confirmation message.
                     */
                    if (emailrx_cover_sheet (pop3.document_handle,
                                             report,
                                             sizeof (report),
                                             &pop3.message_header))
                    {
                        ++pop3.page_index;  /*RCM put in to make cover sheet page 1*/

                        if (send_memory_report_to_printq (PageClass_Text,
                                                          PageType_Text_CoverPage,
                                                          report))
                        {
                            /* error occured */
                            StateKicker_SendMessage (PrintQ_MessageHandler,
                                                     RX_PQ_DOCUMENT_COMPLETE,
                                                     NULL);
                            Pop3IF_Disconnect();
                            nextstate = INCOMING_9c;
                            break;
                        }
                    }

                    ++pop3.page_index;

                    nextstate = INCOMING_8k;
                    break;
                }

                default:
                    nextstate = INCOMING_8j;
                    break;
            }
            break;


        case INCOMING_8k:
            switch (messageNumber)
            {
                case RX_RX_GET_MESSAGE:
                    pop3.message_filename = malloc (strlen (POP3_DIR) + 16);
                        /* more than enough for maximum possible number messages */
                    if (pop3.message_filename == NULL)
                    {
#if 1
                        /* RCM says: we MUST use RemXfer_SendRCError (or RemXfer_SendOSError) rather than rolling our own error messages */
                        RemXfer_SendRCError(PrintQ_MessageHandler, RX_PQ_ERROR, "Not enough memory to download EMail message.", 3);
#else
                        messageDataBlock *send_message;

                        StateKicker_SendMessage (PrintQ_MessageHandler,
                                                 RX_PQ_ERROR,
                                                 &send_message);

                        send_message->data.os_error.err.errnum = 0;
                        strcpy (send_message->data.os_error.err.errmess,
                                "Not enough memory to download EMail message.");
#endif
                        StateKicker_SendMessage (PrintQ_MessageHandler,
                                                 RX_PQ_DOCUMENT_COMPLETE,
                                                 NULL);
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                    }
                    else
                    {
                        nextstate = get_message ();
                    }
                    break;

                default:
                    nextstate = INCOMING_8k;
                    break;
            }
            break;

        case INCOMING_8l:
            switch (messageNumber)
            {
                case P3_RX_GET_MESSAGE_CALL_ERROR:
                case P3_RX_GET_X_LINES_OF_MESSAGE_CALL_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    StateKicker_SendMessage (PrintQ_MessageHandler,
                                             RX_PQ_DOCUMENT_COMPLETE,
                                             NULL);
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_GET_MESSAGE_PROCESS_ERROR:
                case P3_RX_GET_X_LINES_OF_MESSAGE_PROCESS_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    StateKicker_SendMessage (PrintQ_MessageHandler,
                                             RX_PQ_DOCUMENT_COMPLETE,
                                             NULL);
                    Pop3IF_ReleaseData();
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                case P3_RX_GET_MESSAGE_RETRY:
                    Pop3IF_ReleaseData ();
                    if (pop3.retry)
                    {
                        /* We already have retried, so this would be a retry
                         * of the retry.  Something is clearly very wrong,
                         * so abandon the download.
                         */
                        RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                        StateKicker_SendMessage (PrintQ_MessageHandler,
                                                 RX_PQ_DOCUMENT_COMPLETE,
                                                 NULL);
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                    }
                    else
                    {
                        /* The POP3 server lied about the size of the message.
                         * Find out how large the message really is then try again.
                         */
                        pop3.message->size = messageData->data.pop3_GetMessage_data.message_size;
                        pop3.retry = 1;
                        nextstate = get_message ();
                    }
                    break;

                case P3_RX_GET_X_LINES_OF_MESSAGE_RETRY:
                    Pop3IF_ReleaseData ();
                    if (pop3.retry)
                    {
                        /* We already have retried, so this would be a retry
                         * of the retry.  Something is clearly very wrong,
                         * so abandon the download.
                         */
                        RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                        StateKicker_SendMessage (PrintQ_MessageHandler,
                                                 RX_PQ_DOCUMENT_COMPLETE,
                                                 NULL);
                        Pop3IF_Disconnect();
                        nextstate = INCOMING_9c;
                    }
                    else
                    {
                        /* The POP3 server lied about the size of the message.
                         * Find out how large the message really is then try again.
                         */
                        pop3.message->size = messageData->data.pop3_GetHeader_data.message_size;
                        pop3.retry = 1;
                        nextstate = get_message ();
                    }
                    break;

                case P3_RX_GET_MESSAGE_DONE:
                case P3_RX_GET_X_LINES_OF_MESSAGE_DONE:
                {
                    messageDataBlock *send_message;

                    pop3.retry = 0;
                    emailrx_message_downloaded (pop3.message);


                    /* Space used and space reserved change by different
                     * amounts.  We don't need to worry about space for the
                     * decoded message because we originally reserved enough
                     * space for all the decoded message plus the largest raw
                     * message; a decoded message cannot be larger than a raw
                     * message.
                     */
                    pop3.space_used     += pop3.message->size;
                    pop3.space_reserved -= pop3.message->decoded_size_estimate;
                    HWM_MailRx_Usage (pop3.space_used,
                                      pop3.space_reserved);

                    /* It is absolutely vital that the header structure is cleared before each message fetch
                     * otherwise data from the previous fetch could be picked up.
                     */
                    free_header (&pop3.message_header);

                    StateKicker_SendMessage (MimeDecode_StateMachine, RX_MD_DECODE_HDR, &send_message);
                    send_message->data.decode_header.raw_header = pop3.message_filename;
                    send_message->data.decode_header.message_header = (void*) &pop3.message_header; /*RCM cast NFE_header* to void* */
                    send_message->data.decode_header.size = pop3.message->size;
                    send_message->data.decode_header.file = TRUE;
                    Pop3IF_ReleaseData ();
                    nextstate = INCOMING_8m;
                    break;
                }

                default:
                    nextstate = INCOMING_8l;
                    break;
            }
            break;

        case INCOMING_8m:
            switch (messageNumber)
            {
                case MD_RX_DECODE_HDR_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    StateKicker_SendMessage (PrintQ_MessageHandler,
                                             RX_PQ_DOCUMENT_COMPLETE,
                                             NULL);
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;
                }

                case MD_RX_DECODE_HDR_DONE:
                {
                    messageDataBlock *send_message;

                    /* Now have a valid header for this document.  If this
                     * is the first time that a part of this document has been
                     * seen then send the details of the sender to the address
                     * book.
                     */
                    if (emailrx_is_document_new (pop3.document_handle))
                    {
                        print_info_t *  print_info = list_tail (pop3.print_list);

                        AddrFile_FillAddressRecord(print_info->pid,
                            /* serial number */    pop3.message_header.details.serial_num,
                            /* company name  */    pop3.message_header.config.organisation,
                            /* contact name  */    pop3.message_header.from.real_name,
                            /* fax number    */    pop3.message_header.config.fax_num,     /* NB email format */
                            /* voice number  */    pop3.message_header.config.phone_num,   /* NB email format */
                            /* email address */    pop3.message_header.from.address,
                            /* software rev. */    pop3.message_header.details.software_rev_major, pop3.message_header.details.software_rev_minor,
                            /* device class  */    pop3.message_header.details.device_class,
                            /* receipt_to    */    pop3.message_header.return_receipt_to.real_name,
                            /* receipt_to    */    pop3.message_header.return_receipt_to.address
                                                  );

                        StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_DOCUMENT_DETAILS, NULL);
                    }

                    StateKicker_SendMessage (MimeDecode_StateMachine,
                                             RX_MD_DECODE_MSG,
                                             &send_message);
                    send_message->data.decode_message.filename = pop3.message_filename;
                    send_message->data.decode_message.document_directory = pop3.document_directory;
                    send_message->data.decode_message.size = pop3.message->size;
                    send_message->data.decode_message.start_page = pop3.page_index;
                    send_message->data.decode_message.message_header = &pop3.message_header;

                    nextstate = INCOMING_8n;
                    break;
                }

                default:
                    nextstate = INCOMING_8m;
                    break;
            }
            break;


        case INCOMING_8n:
            switch (messageNumber)
            {
                case MD_RX_NEW_PAGE:
                    StateKicker_SendMessage (PrintQ_MessageHandler,
                                             RX_PQ_NEW_PAGE,
                                             NULL);
                    nextstate = INCOMING_8n;
                    break;

                case MD_RX_PAGE_COMPLETE:
                {
                    messageDataBlock *sendMessage;

                    /* You mustn't use pop3.page_index at this point.
                     * pop3.page_index is invalid between RX_MD_DECODE_MSG and MD_RX_DECODE_MSG_DONE.
                     */

                    set_filetypeDN (pop3.document_directory,
                                    messageData->data.md_rx_page_complete.pageNum,
                                    messageData->data.md_rx_page_complete.fileType);    /*>>>should this be done by PrintQ???*/
                    StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_PAGE_COMPLETE, &sendMessage);
                    sendMessage->data.rx_pq_page_complete.pageNum   = messageData->data.md_rx_page_complete.pageNum;
                    sendMessage->data.rx_pq_page_complete.pageClass = messageData->data.md_rx_page_complete.pageClass;
                    sendMessage->data.rx_pq_page_complete.pageType  = messageData->data.md_rx_page_complete.pageType;
                    sendMessage->data.rx_pq_page_complete.fileType  = messageData->data.md_rx_page_complete.fileType; /* FILETYPE_TIFF, FILETYPE_TEXT or FILETYPE_CONFIG */

                    nextstate = INCOMING_8n;
                    break;
                }

                case MD_RX_DECODE_MSG_DONE:
                {
                    print_info_t *  print_info = list_tail (pop3.print_list);

                    /* Delete the original message */
#ifndef PRESERVE_POP3
                    _swix (OS_File, _INR (0, 1), 6, pop3.message_filename);
#endif

                    pop3.space_used -= pop3.message->size;
                    HWM_MailRx_Usage (pop3.space_used,
                                      pop3.space_reserved);

                    pop3.message->flags.bits.printing = 1;
                    /* Add this message to the current document's list of
                     * messages being printed.
                     */
                    print_info->message[print_info->index++] = M_list_current (pop3.message_list_iter);
                    free (pop3.message_filename);
                    pop3.message_filename = NULL;

                    pop3.page_index = messageData->data.message_decoded.next_page;

                    ++pop3.message_index;
                    M_list_next (pop3.message_list_iter);
                    StateKicker_SendMessage (RemXfer_StateMachine,
                                             RX_RX_GET_MESSAGE,
                                             NULL);
                    nextstate = INCOMING_8k;
                    break;
                }

                case MD_RX_DECODE_MSG_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    StateKicker_SendMessage (PrintQ_MessageHandler,
                                             RX_PQ_DOCUMENT_COMPLETE,
                                             NULL);
                    Pop3IF_Disconnect();
                    nextstate = INCOMING_9c;
                    break;

                default:
                    nextstate = INCOMING_8n;
                    break;
            }
            break;


        case INCOMING_8o:
            switch (messageNumber)
            {
                case P3_RX_DISCONNECT_CALL_ERROR:
                case P3_RX_DISCONNECT_PROCESS_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    /* deliberate drop-through into next case */
                }

                case P3_RX_DISCONNECT_DONE:
                    free_pop3_resources ();
                    wipe_pop3_directory ();
                    HWM_MailRx_Usage (0,
                                      0);
                    emailrx_tidy ();
                    Pop3IF_DeRegister();
                    nextstate = INCOMING_8p;
                    break;

                default:
                    nextstate = INCOMING_8o;
                    break;
            }
            break;


        case INCOMING_8p:
            switch (messageNumber)
            {
                case P3_RX_DEREGISTER_CALL_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    /* deliberate drop-through into next case */
                }

                case P3_RX_DEREGISTER_DONE:
                {
                    StateKicker_SendMessage(Screen_StateMachine, RX_SC_POP3_DOWNLOAD_COMPLETE, NULL);   /* thumbs up, download complete */
                    StateKicker_SendMessage(RemModem_StateMachine, RX_RM_HANGUP, NULL);
                    nextstate = IDLE;
                    break;
                }

                default:
                    nextstate = INCOMING_8p;
                    break;
            }
            break;

#endif

        case INCOMING_9a:
            switch (messageNumber)
            {
                case RM_RX_GOING_IDLE:
                    /*StateKicker_SendMessage (PrintQ_MessageHandler, RX_PQ_GOING_IDLE, NULL); - use common code below */
                    nextstate = IDLE;
                    break;

                default:
                    nextstate = INCOMING_9a;
                    break;
            }
            break;


        case INCOMING_9b:
            switch (messageNumber)
            {
                case P3_RX_DEREGISTER_CALL_ERROR:
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */

                    if (isp_via_dialler)
                    {
                        StateKicker_SendMessage (RemModem_StateMachine, RX_RM_HANGUP, NULL);
                        nextstate = INCOMING_9a;
                    }
                    else
                    {
                        StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_END, NULL);  /* equivalent to RM_SC_DIAL_COMPLETE*/
                        /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                        nextstate = IDLE;
                    }
                    break;

                case P3_RX_DEREGISTER_DONE:
                    if (isp_via_dialler)
                    {
                        StateKicker_SendMessage (RemModem_StateMachine, RX_RM_HANGUP, NULL);
                        nextstate = INCOMING_9a;
                    }
                    else
                    {
                        StateKicker_SendMessage(Screen_StateMachine, RX_SC_LAN_END, NULL);  /* equivalent to RM_SC_DIAL_COMPLETE*/
                        /*StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL); - use common code below */
                        nextstate = IDLE;
                    }
                    break;

                default:
                    nextstate = INCOMING_9b;
                    break;
            }
            break;

        case INCOMING_9c:
            switch (messageNumber)
            {
                case P3_RX_DISCONNECT_CALL_ERROR:
                case P3_RX_DISCONNECT_PROCESS_ERROR:
                {
                    RemXfer_ForwardError(PrintQ_MessageHandler, RX_PQ_ERROR, messageNumber, messageData);   /* forward the error to PrintQ */
                    /* deliberate drop-through into next case */
                }

                case P3_RX_DISCONNECT_DONE:
                    free_pop3_resources ();
                    wipe_pop3_directory ();
                    HWM_MailRx_Usage (0,
                                      0);
                    Pop3IF_DeRegister();
                    nextstate = INCOMING_9b;
                    break;

                default:
                    nextstate = INCOMING_9c;
                    break;
            }
            break;
/*SUPPORT_EMAIL*/
#endif
    } /* switch (state) */

    /* report RX_SQ_GOING_IDLE if going idle from a non-idle state */
    if ((nextstate == IDLE) && (state != IDLE))
        StateKicker_SendMessage(SendQ_MessageHandler, RX_SQ_GOING_IDLE, NULL);

    state = nextstate;

    /* Print state machine status on exit */
    dprintf((NULL, "RemXfer_StateMachine (exit): Next state => %d\n", state));
}


#if SUPPORT_EMAIL

/* -----------------------------------------------------------------------------
   get_message

   Download a message from the POP3 server.

   Returns
   next state for RemXfer state machine
 */

static States get_message (void)
{
    States  nextstate;

    if (get_next_message ())
    {
        /* Message being fetched */
        nextstate = INCOMING_8l;
    }
    else
    {
        /* No more messages for this document */
        pop3.retry = 0;

        /* Check if a missing page report is required for this document */
        if (emailrx_need_missing_page_report (pop3.document_handle))
        {
            if (do_missing_page_reports (&pop3.message_header.from) != 0)
            {
                /* error occured */
                nextstate = INCOMING_9c;
                return nextstate;
            }
        }

        /* Check if a delivery confirmation report is required for this
         * document.
         */
        if (emailrx_need_printed_page_report (pop3.document_handle))
        {
            char  delivery_conf_report_filename[257];

            sprintf (delivery_conf_report_filename,
                     "%s.%d",
                     pop3.document_directory,
                     pop3.page_index);

            if (emailrx_printed_page_report (pop3.document_handle,
                                             delivery_conf_report_filename,
                                             &pop3.message_header) == 0)
            {
                send_file_report_to_printq (PageClass_SendReceipt,
                                            PageType_SendReceipt,
                                            delivery_conf_report_filename);
            }
        }

        StateKicker_SendMessage (PrintQ_MessageHandler,
                                 RX_PQ_DOCUMENT_COMPLETE,
                                 NULL);

        free (pop3.document_directory);
        pop3.document_directory = NULL;

        /* Move onto the next document */
        StateKicker_SendMessage (RemXfer_StateMachine,
                                 RX_RX_GET_DOCUMENT,
                                 NULL);
        nextstate = INCOMING_8i;
    }


    return nextstate;
}

#endif


/* -----------------------------------------------------------------------------
   RemXfer_ForwardError

   Forward an error message to another state machine.

   Inputs
   state_machine: state machine to forward error to
   messageNumber: message number to send to state machine
   forwardNumber: unused
   forwardData:   message data to forward to state machine
 */

static void  RemXfer_ForwardError (
                 void                (*StateMachine) (
                                         int                 messageNumber,
                                         messageDataBlock *  messagedata),
                 int                 messageNumber,
                 int                 forwardNumber,
                 messageDataBlock *  forwardData)
{
    messageDataBlock *sendMessage;

    StateKicker_SendMessage(StateMachine, messageNumber, &sendMessage);
    sendMessage->data = forwardData->data;

#if 0 /*THINK*/
    /* Map a small set of Fax errors and a small */
    /* set of modem errors onto common HL_Errors */

    switch (forwardNumber == FX_ERROR)
    {
        case FX_ERROR:
            switch (forwardData->data.fx_error.rc)
            {
                case Error_No_Dialtone:
                = HL_ERROR_NoDialTone;
                    break;

                case Error_Busy:
                = HL_ERROR_LineBusy;
                    break;

                case Error_No_Answer:
                = HL_ERROR_NoAnswer
                    break;

                case Error_No_Carrier:
                = HL_ERROR_NoCarrier
                    break;
            }
            break;

        case RM_RX_ERROR:
            switch (forwardData->data.rm_error.rc)
            {
                case Dialler_AbortedScript_NoDialtone:
                = HL_ERROR_NoDialTone;
                    break;

                case Dialler_AbortedScript_Busy
                = HL_ERROR_LineBusy;
                    break;

                case Dialler_AbortedScript_NoAnswer
                = HL_ERROR_NoAnswer
                    break;

                case Dialler_AbortedScript_NoCarrier
                = HL_ERROR_NoCarrier
                    break;
            }
            break;

    }
#endif
}

#if SUPPORT_EMAIL


/*
 * Send an error of our own
 */
static void RemXfer_SendRCError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber, /*const*/ char *text, int rc)
{
    StateKicker_SendRCError(StateMachine, messageNumber, code_RemXfer_RCError, ctx_RemXfer_RCError, rc, text);
}




static void RemXfer_SendOSError(void (*StateMachine)(int messageNumber, messageDataBlock *messagedata), int messageNumber, _kernel_oserror *error)
{
    StateKicker_SendOSError(StateMachine, messageNumber, code_RemXfer_OSError, ctx_RemXfer_OSError, error);
}




/* -----------------------------------------------------------------------------
   create_dynamic_area

   Create a dynamic area of a given size.

   Inputs
   size: required size of dynamic area
   name: name to call dynamic area

   Outputs
   area_number: number allocated to dynamic area by OS

   Returns
   success: pointer to start of dynamic area
   failure: NULL
 */

static void *  create_dynamic_area (const size_t       size,
                                    const char *const  name,
                                    int *const         area_number)
{
    void *area_base;

    if (_swix (OS_DynamicArea,
               _INR (0, 8) | _OUT (1) | _OUT (3),

               0,
               -1,
               size,
               -1,
               1<<7,
               size,
               0,
               0,
               name,

               area_number,
               &area_base) != NULL)
    {
        return NULL;
    }

    MemCheck_RegisterMiscBlock (area_base,
                                size);

    return area_base;
}




/* -----------------------------------------------------------------------------
   remove_dynamic_area

   Remove a dynamic area.

   Inputs
   area_number: number of dynamic area to remove

   Returns
   success: NULL
   failure: pointer to error block
*/

static _kernel_oserror *  remove_dynamic_area (const int  area_number)
{
    _kernel_oserror *e;

#ifdef MemCheck_MEMCHECK
    void *  area_base;

    _swix (OS_DynamicArea,
           _INR (0, 1) | _OUT (3),

           2,
           area_number,

           &area_base);
#endif

    e =  _swix (OS_DynamicArea,
                _INR (0, 1),

                 1,
                 area_number);

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock (area_base);
#endif

    return e;
}




/* -----------------------------------------------------------------------------
   free_header

   Destory an NFE_header data structure.  Relies on unallocated pointers being
   NULL.

   Inputs
   header: pointer to NFE_header data structure
 */

static void  free_header (NFE_header *  header)
{
    if (header->to.address != NULL)
    {
        free (header->to.address);
        header->to.address = NULL;
    }

    if (header->to.real_name != NULL)
    {
        free (header->to.real_name);
        header->to.real_name = NULL;
    }

    if (header->from.address != NULL)
    {
        free (header->from.address);
        header->from.address = NULL;
    }

    if (header->from.real_name != NULL)
    {
        free (header->from.real_name);
        header->from.real_name = NULL;
    }

    if (header->return_receipt_to.address != NULL)
    {
        free (header->return_receipt_to.address);
        header->return_receipt_to.address = NULL;
    }

    if (header->return_receipt_to.real_name != NULL)
    {
        free (header->return_receipt_to.real_name);
        header->return_receipt_to.real_name = NULL;
    }

    header->date = 0;

    if (header->date_hdr != NULL)
    {
        free (header->date_hdr);
        header->date_hdr = NULL;
    }

    if (header->subject != NULL)
    {
        free (header->subject);
        header->subject = NULL;
    }

    header->id.first_page_num = 0;
    header->id.last_page_num = 0;
    header->id.doc_num = 0;
    header->id.msg_num_pages = 0;
    header->id.exact_num_pages = TRUE;

    if (header->id.iap_username != NULL)
    {
        free (header->id.iap_username);
        header->id.iap_username = NULL;
    }

    if (header->details.device != NULL)
    {
        free (header->details.device);
        header->details.device = NULL;
    }

    header->details.device_class = 0;
    memset (header->details.serial_num,
            0,
            SERIAL_LEN);
    header->details.software_rev_major = 0;
    header->details.software_rev_minor = 0;

    if (header->details.encryption != NULL)
    {
        free (header->details.encryption);
        header->details.encryption = NULL;
    }

    if (header->details.encryption_rev != NULL)
    {
        free (header->details.encryption_rev);
        header->details.encryption_rev = NULL;
    }

    if (header->details.domain != NULL)
    {
        free (header->details.domain);
        header->details.domain = NULL;
    }

    if (header->config.fax_num != NULL)
    {
        free (header->config.fax_num);
        header->config.fax_num = NULL;
    }

    if (header->config.phone_num != NULL)
    {
        free (header->config.phone_num);
        header->config.phone_num = NULL;
    }

    if (header->config.organisation != NULL)
    {
        free (header->config.organisation);
        header->config.organisation = NULL;
    }

    header->netfax_msg_class = NFE_NFMC_NONE;
    header->msg_class = NFE_MC_UNKNOWN;
}

#endif


#if SUPPORT_EMAIL


/* -----------------------------------------------------------------------------
   messageid_from_uid

   Find the message ID (as returned by the POP3 LIST command) corresponding to
   the given unique ID (as returned by the POP3 UIDL command).

   Inputs
   uid: unique ID (as returned by the POP3 UIDL command)

   Outputs
   message_id: message ID (as returned by the POP3 LIST command)

   Returns
   1: found message ID corresponding to unique ID
   0: no message ID corresponding to unique ID - no meaningful information in
      message_id output
 */

static int  messageid_from_uid (char *const     uid,
                                unsigned int *  message_id)
{
    int  i;

    /* This bit is potentially inefficient: do a linear search through the
     * unique ID list, doing a strcmp to try to match the unique ID.
     */

    for (i = 0; i < pop3.uid_list_size; i++)
    {
        if (strcmp (uid, pop3.uid_list[i].unique_id) == 0)
        {
            *message_id = pop3.uid_list[i].msg_id;
            return 1;
        }
    }

    return 0;
}




/* -----------------------------------------------------------------------------
   uid_from_messageid

   Get a message's unique ID (as returned by the POP3 UIDL command) from its
   message number (as returned by the POP3 LIST command).

   Inputs
   message_id: message ID, as returned by the POP3 LIST command

   Returns
   pointer to unique ID: found matching unique ID
   NULL:                 no matching unique ID
 */

static char *  uid_from_messageid (const unsigned int  message_id)
{
    UID_MSG_LIST *  uid_msg_entry;

    uid_msg_entry = (UID_MSG_LIST *) bsearch (&message_id,
                                              pop3.uid_list,
                                              pop3.uid_list_size,
                                              sizeof (UID_MSG_LIST),
                                              compare_message_id);
    if (uid_msg_entry)
    {
        return uid_msg_entry->unique_id;
    }

    return NULL;
}




/* -----------------------------------------------------------------------------
   compare_message_id

   Routine suitable for use with C library's bsearch routine, to match a
   message ID (as returned by POP3 LIST command) against an entry in the list of
   message IDs.

   Inputs
   key:            unique ID being searched for
   uid_list_entry: pointer to entry in unique ID list to compare key against

   Returns
   -1: no match - try earlier in the list
    0: successful match
    1: no match - try later in the list
 */


static int compare_message_id (const void *  key,
                               const void *  uid_list_entry)
{
    return *((unsigned int *) key) - ((UID_MSG_LIST *) uid_list_entry)->msg_id;
}




/* -----------------------------------------------------------------------------
   delete_next_message

   Delete the next message in the POP3 delete list.  Skips messages that are
   no longer on the server (ie. that have been deleted behind our back).

   Returns
   0: no more messages to delete
   1: message deleted
 */

static int  delete_next_message (void)
{
    char *            unique_id;
    int               message_exists;
    unsigned int      message_id;
    list_item_handle  item;
    list_iterator_t   i;


    list_initialise_iterator (&i,
                              pop3.delete_list);

    M_list_reset (i);

    while (!M_list_finished (i))
    {
        unique_id = M_list_current (i);

        message_exists = messageid_from_uid (unique_id,
                                             &message_id);

        item = M_list_current_item (i);
        M_list_next (i);

        list_remove_item (pop3.delete_list,
                          item);

        if (message_exists)
        {
            Pop3IF_DeleteMessage (message_id);
            return 1;
        }
    }

    return 0;
}




/* -----------------------------------------------------------------------------
   get_next_message

   Get the next message from the POP3 server and place it in a file.  If the
   message type is only 'partially' supported by Daytona (ie. something it can
   download but not make any sense of eg. a base64 encoded MSWord document)
   then only the first <n> lines of the message are downloaded.  <n> is
   determined elsewhere.

   Inputs
   message:          pointer to data structure describing this message
   message_filename: file to download message into

   Returns
    0: no more messages in this document
    1: started download successfully
 */

static int  get_next_message (void)
{
    unsigned int  message_id;


    sprintf (pop3.message_filename, "%s.%d", POP3_DIR, pop3.message_index);

    while (!M_list_finished (pop3.message_list_iter))
    {
        pop3.message = M_list_current (pop3.message_list_iter);

        if (pop3.message->flags.bits.download &&
            messageid_from_uid (pop3.message->unique_id,
                                &message_id))
        {
            /* Increase the size of the message slightly to attempt to cope
             * gracefully with POP3 servers that lie about message sizes.
             * If a POP3 server lies, it is likely that the inaccuracy is
             * caused by it only allowing for one line termination character,
             * whereas it should allow for two (CR+LF).  A reasonable estimate
             * of the number of characters per line is 60, so an approximate
             * allowance is 2%.
             *
             * If we get a message where the lines are much shorter then there
             * is a chance that our allowance may not be enough.  In this case
             * we will know the real size of the message after the first failed
             * attempt, so we can retry.
             */

            pop3.message->size =
                (unsigned int) ((double) pop3.message->size * 1.02);

            /* Message still exists on server, so download it */
            if (pop3.message->flags.bits.partial)
            {
                Pop3IF_GetXLinesOfMessage (pop3.message_filename,
                                           pop3.message->size,
                                           message_id,
                                           pop3.message->lines);
            }
            else
            {
                Pop3IF_GetMessage (pop3.message_filename,
                                   pop3.message->size,
                                   message_id);
            }

            return 1;
        }

        /* Try the next message */
        M_list_next (pop3.message_list_iter);
    }

    /* No more messages for this document */
    return 0;
}




/* -----------------------------------------------------------------------------
   next_document_to_print

   Get the document handle of the next document to print.

   Returns
   no more documents: NULL
   more documents:    document handle of next document
 */

static document_handle  next_document_to_print (void)
{
    int              found = 0;
    document_handle  document = NULL;

    while (!M_list_finished (pop3.document_list_iter) && !found)
    {
        document = M_list_current (pop3.document_list_iter);
        if (emailrx_document_requires_printing (document))
        {
            found = 1;
        }

        M_list_next (pop3.document_list_iter);
    }

    if (found)
    {
        return document;
    }
    else
    {
        return NULL;
    }
}




/* -----------------------------------------------------------------------------
   free_pop3_resources

   Free all dynamically allocated resources used by POP3 download, reset
   counters etc.  Relies on unallocated pointers being NULL.
 */

static void  free_pop3_resources (void)
{
    if (pop3.message_headers != NULL)
    {
        remove_dynamic_area (pop3.message_headers_areanum);
        pop3.message_headers = NULL;
        pop3.header_index = 0;
    }

    if (pop3.message_list != NULL)
    {
        remove_dynamic_area (pop3.message_list_areanum);
        pop3.message_list = NULL;
        pop3.number_messages = 0;
        pop3.message_index = 0;
    }

    if (pop3.uid_list != NULL)
    {
        remove_dynamic_area (pop3.uid_list_areanum);
        pop3.uid_list = NULL;
        pop3.uid_list_size = 0;
    }

#if 0
    if (pop3.document_list != NULL)
    {
        list_destroy (pop3.document_list);
        pop3.document_list = NULL;
    }
#endif

    if (pop3.message_filename != NULL)
    {
        free (pop3.message_filename);
        pop3.message_filename = NULL;
    }

    if (pop3.document_directory != NULL)
    {
        free (pop3.document_directory);
        pop3.document_directory = NULL;
    }

    pop3.retry = 0;

    free_header (&pop3.message_header);
}




/* -----------------------------------------------------------------------------
   start_message_download

   Decide what messages we want to download after the POP3 mailbox has been
   scanned and kick off the download process.
 */

static int  start_message_download (void)
{
#if 0
    unsigned int free_space;
#endif

    /* Header download is complete, start downloading fax messages.
     * Messages are downloaded one at a time so the same filename can be used
     * for each message.  However, the amount of space free on the filesystem
     * could change between each call to AcornPOP3_GetMessage so this needs to
     * be checked each time.
     */

    if (pop3.message_headers)
    {
        remove_dynamic_area (pop3.message_headers_areanum);
        pop3.message_headers = NULL;
    }
    #if 0
    /* Pop3 directory is created in main.c */
    #else
    /* Ensure that POP3 directory is present */
    _swix (OS_File, _INR (0, 1) | _IN (4), 8, POP3_DIR, 0);
    #endif

#if 0
    /* Find free space on RAM disc so that emailrx_build_dl_list knows
     * how much work it can do.  Bit brain dead at the moment in that
     * the free space could change after it has been read.
     */
    _swix (OS_FSControl,
           _INR (0, 1) | _OUT (0),

           49,
           "RAM:$",

           &free_space);

#ifdef TEST
    emailrx_dump_doc_list_to_file (emailrx_get_doc_list (),
                                   "ADFS::4.$.doclist");
#endif
#endif

    pop3.space_used = 0;
    pop3.space_reserved = 0;
    pop3.reconnect = 0;
    if (emailrx_decide_download (&pop3.space_reserved) == 1)
    {
        /* Not enough memory to download whole inbox, so flag that we need
         * to reconnect at some point in the future to get the rest.
         */
        pop3.reconnect = 1;
    }


#if 0
#ifdef TEST
    if (pop3.document_list)
    {
        emailrx_dump_doc_list_to_file (pop3.document_list,
                                       "ADFS::4.$.dllist");
    }

    emailrx_dump_doc_list_to_file (emailrx_get_doc_list (),
                                   "ADFS::4.$.doclist");
#endif


    if (pop3.document_list == NULL)
    {
        messageDataBlock *send_message;

        StateKicker_SendMessage (PrintQ_MessageHandler,
                                 RX_PQ_ERROR,
                                 &send_message);
        send_message->data.os_error.err.errnum = 0;
        strcpy (send_message->data.os_error.err.errmess,
                "Not enough memory to download EMail messages.");
        Pop3IF_Disconnect();
        return 1;
    }
#endif

    pop3.message_index = 0;

    list_initialise_iterator (&pop3.document_list_iter,
                              emailrx_get_doc_list ());

    pop3.document_handle = M_list_reset (pop3.document_list_iter);
    if (pop3.document_handle)
    {
        StateKicker_SendMessage (Screen_StateMachine,
                                 RX_SC_POP3_DOWNLOAD_START,
                                 NULL);
    }

    StateKicker_SendMessage (RemXfer_StateMachine,
                             RX_RX_GET_DOCUMENT,
                             NULL);

    return 0;
}




/* -----------------------------------------------------------------------------
   send_memory_report_to_printq

   Send a report (eg. missing page) to the PrintQ that exists in memory
   somewhere.

   Inputs
   page_class: class of report we're putting in the PrintQ
   page_type:  type of report we're putting in the PrintQ
   report:     pointer to zero terminated report in memory
 */

static int send_memory_report_to_printq (const PageClasses  page_class,
                                         const PageTypes    page_type,
                                         char *const        report)
{
    char                report_filename[257];
    FILE *              fp;
    messageDataBlock *  sendMessage;

    StateKicker_SendMessage (PrintQ_MessageHandler,
                             RX_PQ_NEW_PAGE,
                             NULL);

    sprintf (report_filename,
             "%s.%d",
             pop3.document_directory,
             pop3.page_index);

    fp = fopen (report_filename,
                "w");
    if (fp == NULL)
    {
        memory_report_file_error ();
        return 1;
    }

    if (fputs (report,
               fp) == EOF)
    {
        memory_report_file_error ();
        return 1;
    }

    if (fclose (fp) == EOF)
    {
        memory_report_file_error ();
        return 1;
    }

    set_filetypeDN (pop3.document_directory,
                    pop3.page_index,
                    FILETYPE_TEXT); /*>>>should this be done by PrintQ???*/

    StateKicker_SendMessage (PrintQ_MessageHandler,
                             RX_PQ_PAGE_COMPLETE,
                             &sendMessage);

    sendMessage->data.rx_pq_page_complete.pageNum   = pop3.page_index;
    sendMessage->data.rx_pq_page_complete.pageClass = page_class;
    sendMessage->data.rx_pq_page_complete.pageType  = page_type;
    sendMessage->data.rx_pq_page_complete.fileType  = FILETYPE_TEXT;

    return 0;
}




/* -----------------------------------------------------------------------------
   memory_report_file_error

   Handle file operation errors for send_memory_report_to_printq routine.
 */

static void memory_report_file_error (void)
{
    _kernel_oserror *e;

#if 1
    /* RCM says: we MUST use RemXfer_SendRCError (or RemXfer_SendOSError) rather than rolling our own error messages */
    e = _kernel_last_oserror();
    if (e)
        RemXfer_SendOSError(PrintQ_MessageHandler, RX_PQ_ERROR, e);
    else
        RemXfer_SendRCError(PrintQ_MessageHandler, RX_PQ_ERROR, "Unable to open Email report file", 5);
#else
    messageDataBlock *  send_message;
    _kernel_oserror *   e;

    StateKicker_SendMessage (PrintQ_MessageHandler,
                             RX_PQ_ERROR,
                             &send_message);
    e = _kernel_last_oserror ();
    if (e)
    {
        send_message->data.os_error.err = *e;
    }
    else
    {
        strcpy (send_message->data.os_error.err.errmess,
                lookup_message_token (&message_block, "EmailReport_Error"));
    }
#endif

    Pop3IF_Disconnect();
}




/* -----------------------------------------------------------------------------
   send_file_report_to_printq

   Send a report (eg. missing page) to the PrintQ that already exists as a file
   somewhere.

   Inputs
   page_class: class of report we're putting in the PrintQ
   page_type:  type of report we're putting in the PrintQ
   filename:   name of report to place in the PrintQ
 */

static void  send_file_report_to_printq (const PageClasses  page_class,
                                         const PageTypes    page_type,
                                         char *const        filename)
{
    messageDataBlock *sendMessage;


    StateKicker_SendMessage(PrintQ_MessageHandler, RX_PQ_NEW_PAGE, NULL);

    set_filetypeDN (pop3.document_directory,
                    pop3.page_index,
                    FILETYPE_TEXT); /*>>>should this be done by PrintQ???*/

    StateKicker_SendMessage (PrintQ_MessageHandler,
                             RX_PQ_PAGE_COMPLETE,
                             &sendMessage);

    sendMessage->data.rx_pq_page_complete.pageNum   = pop3.page_index;
    sendMessage->data.rx_pq_page_complete.pageClass = page_class;
    sendMessage->data.rx_pq_page_complete.pageType  = page_type;
    sendMessage->data.rx_pq_page_complete.fileType  = FILETYPE_TEXT;
}





/* -----------------------------------------------------------------------------
   do_missing_page_reports

   Generate missing page reports for the remote and local machines and place
   them in the approproate queues for sending / printing.

   Returns
   -1: failure
    0: success
 */

static int do_missing_page_reports (const NFE_address *const  from)
{
    char          remote_report_pathname[257];
    char *        local_report;
    int           rc;
    unsigned int  pid;


    pid = SendQ_ExtIF_NewDocument (remote_report_pathname,
                                   from->real_name,
                                   from->address,
                                   FALSE,           /* don't print a hardcopy */
                                   FALSE);          /* don't want a receipt */

    SendQ_ExtIF_Subject (pid,
                         "Missing page report");

    strcat (remote_report_pathname,
            ".Missing");

    local_report = emailrx_generate_missing_page_report (pop3.document_handle,
                                                         remote_report_pathname,
                                                         &pop3.message_header);
    if (local_report != NULL)
    {
        /* may need different class and type */
        SendQ_ExtIF_FileComplete (pid,
                                  "Missing",
                                  PageClass_SendReceipt,
                                  PageType_SendReceipt,
                                  FILETYPE_TEXT);
    }

    /* ready to send - when next connection occurs (ie doesn't trigger
     * connection)
     */
    SendQ_ExtIF_DocumentComplete(pid, FALSE);
    if (local_report == NULL)
    {
        return -1;
    }

    /* call it a cover sheet for now, but ideally it should have its own type */
    rc = send_memory_report_to_printq (PageClass_Text,
                                       PageType_Text_CoverPage,
                                       local_report);
    free (local_report);

    if (rc != 0)
    {
        return -1;
    }
    ++pop3.page_index;

    return 0;
}




/* -----------------------------------------------------------------------------
   finish_download_session

   Clean up when a POP3 message download session has finished.
 */

static void  finish_download_session (void)
{
    if (pop3.message_list)
    {
        remove_dynamic_area (pop3.message_list_areanum);
        pop3.message_list = NULL;
    }

    if (pop3.uid_list)
    {
        remove_dynamic_area (pop3.uid_list_areanum);
        pop3.uid_list = NULL;
    }


    if (pop3.reconnect)
    {
        StateKicker_SendMessage (PrintQ_MessageHandler,
                                 RX_PQ_MAIL_WAITING,
                                 NULL);
        pop3.reconnect = 0;
    }

#if 0
    list_destroy (pop3.document_list);
    pop3.document_list = NULL;
#endif

    Pop3IF_ReleaseData();
    Pop3IF_Disconnect();
}




/* -----------------------------------------------------------------------------
   wipe_pop3_directory

   Delete the contents of the POP3 directory and the directory itself.
 */

static void  wipe_pop3_directory (void)
{
#ifndef PRESERVE_POP3
    _swix (OS_FSControl,
           _INR (0, 1) | _IN (3),

           27,
           POP3_DIR,
           0x3);
#endif
}




/* -----------------------------------------------------------------------------
   add_msg_to_delete_list

   Add a message to the list of messages to be deleted from the server.

   Inputs
   unique_id: unique ID of message
 */

static void  add_msg_to_delete_list (const char *const  unique_id)
{
    char *  delete_info;

    delete_info = malloc (strlen (unique_id) + 1);
    if (delete_info)
    {
        strcpy (delete_info,
                unique_id);

        if (list_add_item (pop3.delete_list,
                           delete_info) == NULL)
        {
            free (delete_info);
        }
    }
}




/* -----------------------------------------------------------------------------
   free_delete_info
 */

static void  free_delete_info (void *  data)
{
    free (data);
}




/* -----------------------------------------------------------------------------
   add_doc_to_print_list

   Add a new entry to the list of documents being printed.

   Inputs
   pid: pid supplied by PrintQ to be associated with document

   Returns
   success: 0
   failure: 1
 */

static int  add_doc_to_print_list (const unsigned int  pid)
{
    int             number_messages;
    print_info_t *  print_info;


    print_info = malloc (sizeof (print_info_t));
    if (print_info == NULL)
    {
        return 1;
    }

    if (list_add_item (pop3.print_list,
                       print_info) == NULL)
    {
        free (print_info);
        return 1;
    }


    number_messages = emailrx_get_number_messages (pop3.document_handle,
                                                   MessageFlags_Download,
                                                   MessageFlags_Download);
    if (number_messages == 0)
    {
        free (print_info);
        return 0;
    }

    print_info->message = malloc (sizeof (message_t *) * number_messages);
    if (print_info->message == NULL)
    {
        free (print_info);
        return 1;
    }

    print_info->pid   = pid;
    print_info->index = 0;

    return 0;
}




/* -----------------------------------------------------------------------------
   print_confirmed

   When a print is confirmed as finished by the PrintQ, check if the printed
   document originated as email, and if so update our internal information
   about the document and mark the message(s) for deletion from the server.

   Inputs
   pid: pid supplied by PrintQ associated with document
 */

static void  print_confirmed (unsigned int  pid)
{
    list_item_handle  item;

    item = list_find_item (pop3.print_list,
                           match_pid,
                           &pid);
    if (item)
    {
        int  i;
        print_info_t *    print_info = list_item_data (item);

        for (i = 0; i < print_info->index; ++i)
        {
            emailrx_message_printed (print_info->message[i]);

            /* Mark the message for deletion from the server on the next
             * connection.
             */
            add_msg_to_delete_list (print_info->message[i]->unique_id);
        }

        list_remove_item (pop3.print_list,
                          item);
    }
}




/* -----------------------------------------------------------------------------
   free_print_info
 */

static void  free_print_info (void *  data)
{
    print_info_t *  print_info = (print_info_t *) data;

    if (print_info->message)
    {
        free (print_info->message);
    }
    free (print_info);
}




/* -----------------------------------------------------------------------------
   match_pid
 */

static int  match_pid (const void *const  list_item,
                       const void *const  search_data)
{
    const unsigned int    pid        = *(unsigned int *) search_data;
    const print_info_t *  print_info = (print_info_t *) list_item;

    return (pid == print_info->pid);
}

/*SUPPORT_EMAIL*/
#endif


/* end of RemXfer.c */
