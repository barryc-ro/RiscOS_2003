/* File:    dialler.c
 * Purpose: Dialler state machines
 * Author:  Ben Laughton
 * History: 1997-07-25: BAL: created
 */




/* =============================================================================
 * Include header files
 */

#include "kernel.h"
#include <stddef.h>
#include "swis.h"

#include "dialler.h"
#include "LogFileIF.h"


/* =============================================================================
 * Define constants
 */

/* Dialler_Arbitrate entry and exit values */
#define Dialler_Arbitrate_RequestIOAccess       0
#define Dialler_Arbitrate_RelinquishAccess      1
#define Dialler_IOAccessGranted_BlockDrivers    0
#define Dialler_IOAccessGranted_DualSerial      1
#define Dialler_IOAccessDenied_ActiveClient    64
#define Dialler_IOAccessDenied_NotConnected    65

/* Flags used by Dialler_Dial, Dialler_Configure and Dialler_Answering */
#define Dialler_Flags_BlockdriverInMemory     0x01    /* blockdriver only */
#define Dialler_Flags_UseGivenHandles         0x01    /* devicefs only */
#define Dialler_Flags_DialScriptInMemory      0x02
#define Dialler_Flags_AnswerScriptInMemory    0x02
#define Dialler_Flags_HangupScriptInMemory    0x04
#define Dialler_Flags_UseScriptsInSitu        0x08
#define Dialler_Flags_Portnumber              0x10    /* blockdriver only */
#define Dialler_Flags_NoReset                 0x80000000

#define Dialler_Dial_DialScriptInMemory   0x2
#define Dialler_Dial_AnswerScriptInMemory 0x2
#define Dialler_Dial_HangupScriptInMemory 0x4
#define Dialler_Dial_InSitu               0x8

#ifndef Dialler_Dial
#define Dialler_Dial                    0x04c6c0
#define Dialler_HangUp                  0x04c6c1
#define Dialler_Status                  0x04c6c2
#define Dialler_Answering               0x04c6c3
#define Dialler_Configure               0x04c6c4
#define Dialler_Register                0x04c6c5
#define Dialler_Arbitrate               0x04c6c6
#define Dialler_Timeout                 0x04c6c7
#define Dialler_ResetCounter            0x04c6c8
#endif


/* Values for r0 reason code on entry to SWI Dialler_Status */
#define Dialler_Status_ConnectTime     1
#define Dialler_Status_String          2

/* Reason code masks */
#define Dialler_MajorReasonCodeMask    0xffff0000
#define Dialler_MinorReasonCodeMask    0x0000ff00
#define Dialler_GeneralInfoMask        0x000000ff

/* Major reason code (top two bytes of status word) */
#define Dialler_StateChanged           0x00010000
#define Dialler_LineDropped            0x00020000
#define Dialler_StatusStringChanged    0x00040000

/* Minor reason code (2nd byte of status word) */
#define Dialler_ConnectedFlagsMask     0x00000300
#define Dialler_Disconnected           0x00000000
#define Dialler_ConnectionChanging     0x00000100
#define Dialler_Connected              0x00000200
#define Dialler_ConnectedOutgoing      0x00000200
#define Dialler_ConnectedIncoming      0x00000300
#define Dialler_RelinquishAccess       0x00000400
#define Dialler_DiallerDroppedLine     0x00000000
#define Dialler_RemoteDroppedLine      0x00000800

/* General info (1st byte of status word) */
enum
{
    Dialler_ExecutingScript_Dial = 1,
    Dialler_ExecutingScript_Hangup,
    Dialler_ExecutingScript_Answer,
    Dialler_AbortedScript_Syntax,
    Dialler_AbortedScript_Timeout,
    Dialler_AbortedScript_NoCarrier,
    Dialler_AbortedScript_Error,
    Dialler_AbortedScript_NoDialtone,
    Dialler_AbortedScript_Busy,
    Dialler_AbortedScript_NoAnswer
};




/* =============================================================================
 * Define functions
 */

/* -----------------------------------------------------------------------------
+
-
 */

extern _kernel_oserror *dialler_status(unsigned int *const dialler_status)
{
    _kernel_swi_regs  r;
    _kernel_oserror  *error;

    r.r[0] = 0; /* flags - must be zero */
    if ((error = _kernel_swi(Dialler_Status, &r, &r)) == NULL)
        *dialler_status = r.r[0];

    return(error);
}


extern _kernel_oserror *dialler_start_dial_script (
                            const int force_reset,
                            const char *const dial_script,
                            const char *const hangup_script,
                            const int serial_in,
                            const int serial_out)
{
    unsigned int flags;
    _kernel_oserror *e = NULL;


    LogFileIF_show(LOG_DEBUG, "Starting dial script");

    flags =    Dialler_Flags_UseGivenHandles |
               Dialler_Flags_DialScriptInMemory |
               Dialler_Flags_HangupScriptInMemory;
    if (!force_reset)
        flags |= Dialler_Flags_NoReset;


    e = _swix (Dialler_Dial, _INR (0, 6),

               flags,
               0,
               dial_script,
               hangup_script,
               0,
               serial_in,
               serial_out);

    return e;
}




extern void dialler_monitor_dial_script (int *const state,
                                         const unsigned int dialler_status,
                                         const int executing_state,
                                         const int failed_state,
                                         const int completed_state)
{
    if ((dialler_status & Dialler_Connected) == Dialler_Connected)
        *state = completed_state;

    else if ((dialler_status & Dialler_ConnectedFlagsMask) == Dialler_Disconnected &&
             (dialler_status & Dialler_GeneralInfoMask) !=
             Dialler_ExecutingScript_Dial)
    {
        *state = failed_state;
    }

    else
        *state = executing_state;
}




extern _kernel_oserror *dialler_start_answer_script (
                            const int force_reset,
                            const char *const answer_script,
                            const char *const hangup_script,
                            const int serial_in,
                            const int serial_out)
{
    unsigned int flags;
    _kernel_oserror *e = NULL;


    LogFileIF_show(LOG_DEBUG, "Starting answer script");

    flags =    Dialler_Flags_UseGivenHandles |
               Dialler_Flags_DialScriptInMemory |
               Dialler_Flags_HangupScriptInMemory;
    if (!force_reset)
        flags |= Dialler_Flags_NoReset;

    e = _swix (Dialler_Answering, _INR (0, 6),

               flags,
               0,
               answer_script,
               hangup_script,
               0,
               serial_in,
               serial_out);
    return e;
}




extern void dialler_monitor_answer_script (int *const state,
                                           const unsigned int dialler_status,
                                           const int executing_state,
                                           const int failed_state,
                                           const int completed_state)
{
    if ((dialler_status & Dialler_Connected) == Dialler_Connected)
        *state = completed_state;

    else if ((dialler_status & Dialler_ConnectedFlagsMask) == Dialler_Disconnected &&
             (dialler_status & Dialler_GeneralInfoMask) !=
                 Dialler_ExecutingScript_Answer)
    {
        *state = failed_state;
    }

    else
        *state = executing_state;
}




extern _kernel_oserror *dialler_start_hangup_script (void)
{
    _kernel_oserror *e = NULL;


    LogFileIF_show(LOG_DEBUG, "Starting hangup script");

    e = _swix (Dialler_HangUp, 0);
    return e;
}


extern void dialler_monitor_hangup_script (int *const state,
                                           const unsigned int dialler_status,
                                           const int executing_state,
                                           const int failed_state,
                                           const int completed_state)
{
    if ((dialler_status & Dialler_ConnectedFlagsMask) == Dialler_Disconnected &&
        (dialler_status & Dialler_GeneralInfoMask) == 0)
    {
        *state = completed_state;
    }

    else if ((dialler_status & Dialler_GeneralInfoMask) !=
                Dialler_ExecutingScript_Hangup)
    {
        *state = failed_state;
    }

    else
        *state = executing_state;
}

