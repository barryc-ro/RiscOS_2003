/*
 * QuCommon.c - Queue routines common to both SendQ and PrintQ
 *
 * R C Manby
 *
 * Started 30 January 1998
 *
 */


#include "BuildFlags.h"
#include "StdTypes.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "wimp.h"
#include "wimplib.h"
#include "swis.h"

#include "PageList.h"
#include "AddrBookIF.h"
#include "QuStruct.h"
#include "QuCommon.h"
#include "QuHWM.h"
#include "LogFileIF.h"

#include "FileOps.h"

#if 1 /*normal*/
        /* output debugging info only if LOGFILE_REPORT_LEVEL is LOG_DEBUG */
#define REPORT LOG_DEBUG
#else
        /* output debugging info all the time */
#define REPORT LOG_NORMAL
#endif

#if SUPPORT_EMAIL
struct
{
    int using;                  /* } current requirement is using + reserving */
    int reserving;              /* }                                          */

    int minimum_requirement;    /* we MUST be able to take AT LEAST this much memory to allow the */
                                /* largest known page (of size mailscan.largest_page) to be sent  */ 
} mailsend = { 0, 0 };

struct
{
    int largest_page;
} mailscan = { 0 };


void read_disc_size(int *p_size, int *p_used)
{
    const char *disc = "Ram:$";
    _kernel_swi_regs regs;

    regs.r[0] = 49;
    regs.r[1] = (int)disc;
    _kernel_swi(OS_FSControl, &regs, &regs);
    *p_size = regs.r[2];
    *p_used = (regs.r[2] - regs.r[0]);
}

int max(int a, int b)
{
    if (a > b)
        return(a);
    else
        return(b);
}

int min(int a, int b)
{
    if (a < b)
        return(a);
    else
        return(b);
}

/* Used by SendQ to inform HWM system of the largest known page size. */
/* We then ensure enough space is reserved to allow it to be sent.    */
extern void HWM_MailScan_Usage(int largest)
{
    if (mailscan.largest_page != largest)
    {
        mailscan.largest_page = largest;

        if (largest == 0)
            mailsend.minimum_requirement = 0;
        else
            mailsend.minimum_requirement = MimeQ_QuerySpaceForPage(largest);

        LogFileIF_show_decimal_uint_int(REPORT , "Largest page scanned", largest, "requires", mailsend.minimum_requirement);
    }
}


/* Used by MimeQ to inform HWM system how much space it is currently */
/* using and to confirm its space reservation requirements */
/* Any space used or reserved should have been approved by an earlier */
/* HWM_MailSend_Extra call */
extern void HWM_MailSend_Usage(int using, int reserving)
{
    mailsend.using     = using;
    mailsend.reserving = reserving;
}


/* Used by MimeQ to ask HWM system if it can safely use or reserve more memory */
/* Returns:                                                                    */
/*   0=OK                                                                      */
/*   1=Fail                                                                    */
extern int HWM_MailSend_Extra(int extra_reservation)
{
    int disc_used, disc_size;

    read_disc_size(&disc_size, &disc_used);
    LogFileIF_show_decimal_int(REPORT, "HWM_MailSend_Extra: extra_reservation", extra_reservation);
    LogFileIF_show_decimal_uint_int(REPORT, "disc_size", disc_size, "disc_used", disc_used);
    LogFileIF_show_decimal_uint_int(REPORT, "mailsend using", mailsend.using, "reserving", mailsend.reserving); 

    /* can we fit this in, leaving the minimum of margins? */
    if ((disc_size - disc_used - mailsend.reserving - extra_reservation) < 51200)
    {
        LogFileIF_show(REPORT, "fail (test 1)");
        return(1);  /* no - fail */
    }

    /* yes, so if it's within the reserved minimum allocation (ie the space needed for the largest page), allow it */
    if ((mailsend.using + mailsend.reserving + extra_reservation) <= mailsend.minimum_requirement)
    {
        LogFileIF_show(REPORT, "pass (test 2)");
        return(0);  /* OK */    /* within minimum allocation, which may exceed 50% of memory */
    }

    /* trying to use more than the reserved minimum, which is allowed as long as we */
    /* don't use more than 50% of memory */
    if (2*(mailsend.using + mailsend.reserving + extra_reservation) > disc_size)
    {
        LogFileIF_show(REPORT, "fail (test 3)");
        return(1);  /*fail*/    /* would exceed 50% of memory unnecessarily */
    }

    /* leave at least 200k for the page scan (modest size pages so far) */
    if ((disc_size - disc_used - mailsend.reserving - extra_reservation) < 204800)
    {
        LogFileIF_show(REPORT, "fail (test 4)");
        return(1);  /* fail */
    }

#if 1
    /* for big pages */
    /* HWM_Check() uses a margin 'ensure' of  2 * mailscan.largest_page */
    if ((disc_size - disc_used - mailsend.reserving - extra_reservation) < ((2 * mailscan.largest_page) + 51200)   )
    {
        LogFileIF_show(REPORT, "fail (test 5)");
        return(1);  /* fail */
    } 
#endif

    LogFileIF_show(REPORT, "pass (all tests)");
    return(0);
}


struct
{
    int using;                  /* } current requirement is using + reserving */
    int reserving;              /* }                                          */
} mailreceive = { 0, 0 };


/* Used by email decoder to inform HWM system how much space it is currently */
/* using and to confirm its space reservation requirements */
/* Any space used or reserved should have been approved by an earlier */
/* HWM_MailRx_Extra call */
extern void HWM_MailRx_Usage(int using, int reserving)
{
    LogFileIF_show(REPORT, "HWM_MailRx_Usage");
    LogFileIF_show_decimal_uint_int(REPORT, "mailreceive using", mailreceive.using, "reserving", mailreceive.reserving);
    
    mailreceive.using     = using;
    mailreceive.reserving = reserving;
}

extern int HWM_MailRx_Extra(int extra_reservation)
{
    int disc_used, disc_size;

    read_disc_size(&disc_size, &disc_used);
    LogFileIF_show_decimal_int(REPORT, "HWM_MailRx_Extra: extra_reservation", extra_reservation);
    LogFileIF_show_decimal_uint_int(REPORT, "disc_size", disc_size, "disc_used", disc_used);
    LogFileIF_show_decimal_uint_int(REPORT, "mailreceive using", mailreceive.using, "reserving", mailreceive.reserving); 

    if ((disc_size - disc_used - mailreceive.reserving - extra_reservation) < 204800)
    {
        LogFileIF_show(REPORT, "fail (test 1)");
        return(1);  /* fail */
    }

    LogFileIF_show(REPORT, "pass (all tests)");
    return(0);
}

/* return a guess as to the largest amount of RAMdisc we could take for email download */
extern int HWM_Query_MaxSpace(void)
{
    int disc_used, disc_size;

    read_disc_size(&disc_size, &disc_used);

    /* return best of 3/4 disc_size (ie box is heavily loaded now, but in future this would be available) */
    /*                amount HWM_MailRx_Extra would allow now (ie box lightly loaded)                     */

    return(max((disc_size - disc_size/4),
               (disc_size - disc_used - 204800)    /* c.f. HWM_MailRx_Extra */
              )
          );
}


/*
 * High Water Mark Check
 *
 * In
 *   SQ_NEW_DOCUMENT
 *   SQ_NEW_PAGE
 *   SQ_PAGE_COMPLETE
 *   SQ_DOCUMENT_COMPLETE
 *
 * Returns
 *   1 OK - Below limits
 *   2 Trigger streaming send
 *   4 Try to slow data source
 *   3 Abort receive - out of memory
 */
extern int HWM_Check(void)
{
    int disc_used, disc_size;

    read_disc_size(&disc_size, &disc_used);
    LogFileIF_show(REPORT, "HWM_Check()");
    LogFileIF_show_decimal_uint_int(REPORT, "disc_size", disc_size, "disc_used", disc_used);
    LogFileIF_show_decimal_uint_int(REPORT, "mailsend using", mailsend.using, "reserving", mailsend.reserving); 
    LogFileIF_show_decimal_uint_int(REPORT, "mailreceive using", mailreceive.using, "reserving", mailreceive.reserving); 
    
    /* check for disc full, based on amount used, amount reserved and a margin */
    {
        /* currently only mailsend reserves space, if we add reservation schemes for other purposes, factor the values to hwm_reserved below */
        /* we use mailsend.using in calculations where it really is mail orientied, and hwm_using in places where other reservation values may go */
        int hwm_reserved = 0;
        int ensure   = 2 * mailscan.largest_page;   /* guess that the next page received is less   */
                                                    /* than twice the size of any page seen so far */
#if 1
        ensure = min(ensure, STREAM_300K);              /* trim guess to largest emailable size */
        ensure = max(ensure, mailscan.largest_page);    /* ensuring that isn't less than actual sizes seen */
#endif
#if SUPPORT_EMAIL
#if 1   /*PAN-01734*/
        hwm_reserved += max(mailsend.reserving, mailsend.minimum_requirement - mailsend.using); /* may be high, if entity file or mailfile is being created in the background */
#else
        hwm_reserved += mailsend.reserving; /* may be high, if entity file or mailfile is being created in the background */
#endif
#if 1
        hwm_reserved += mailreceive.reserving;
#endif
#endif
                  /* += other.reserving (in the future) */

        if ((disc_size - disc_used - hwm_reserved) < ensure)
        {
            LogFileIF_show(REPORT, "Abort Rx! (test 1)");
            return(3);    /*ABORT now*/
        }
    }

    /* check for start streaming trigger level */
    {
        int mail_requ = 0;  /* suitable value for NO email support */
        int margin    = 0; 
        int trigger   = 0;
        int hwm_using = 0;
        int docu_used = 0;
#if SUPPORT_SLOWDOWN
        int slowdown  = 0;
#endif

#if SUPPORT_EMAIL
        /* allow MailQ the greater of:            */
        /*   what it's asked for                  */
        /*   amount needed for largest known page */
        mail_requ += max(mailsend.using + mailsend.reserving, mailsend.minimum_requirement);
#endif

#if SUPPORT_EMAIL
        hwm_using += mailsend.using;
#if 1
        hwm_using += mailreceive.using;
#endif
#endif
               /* += other.using (in the future) */

#if SUPPORT_EMAIL
#if 1   /*PAN-01734*/
        /* the value for ensure above guesses that the space needed for the next page is less than twice the size of any page seen so far */
        /* margin triggers streaming when room for around two pages (ie assumes two pages fit in a space three times the largest page seen so far) */
        margin = 3 * mailscan.largest_page; /* should this be four */
#endif
#endif


        /* stream trigger is lower of: */
        /*   2/3 available memory      */
        /*   1/2 disc_size             */

#if SUPPORT_EMAIL
        trigger = min((2*(disc_size - mail_requ))/3, disc_size/2);
#if 1   /*PAN-01734*/
        trigger = min(trigger, (disc_size - mail_requ - margin));   /* for large pages trigger streaming when room to scan at least one more page */
#endif
#else
        trigger = disc_size/2;  /* optimisation, above expression simplifies to this when mail_requ is 0 */
#endif

        /* calculate total document space (PrintQ & SendQ) */
        docu_used = disc_used - hwm_using;  /* not totally accurate, while encoding we are eating into hwm_reserved allocation, so docu_used will */
                                            /* show high (by upto mailsend.reserving) - not really a problem as the encode is probably a streaming email send anyway       */

    /* should we lower the trigger for start of document - probably not */
    /* should we lower the trigger for start of page - probably yes */

    /* if starting a page
    if SQ_WM_NEW_PAGE or PQ_WM_NEW_PAGE
        docu_used += mailscan.largest_page;
    */

#if SUPPORT_SLOWDOWN
        slowdown = trigger + 102400;
        if (docu_used >= slowdown)
        {
            LogFileIF_show(REPORT, "Slow Rx (test 2)");
            return(4);  /* try to slow the sender */
        }
#endif

        if (docu_used >= trigger)
        {
            LogFileIF_show(REPORT, "Stream Rx/Tx (test 3)");
            return(2);  /* start streaming */
        }
    }

    LogFileIF_show(REPORT, "pass (all tests)");
    return(1);  /*OK*/
}

#else
/*
 * High Water Mark Check
 *
 * Returns
 *   1 OK - Below limits
 *   2 Trigger streaming send
 *   4 Try to slow data source
 *   3 Abort receive - out of memory
 */
extern int HWM_Check(void)
{
    int used, size, percentage;
    _kernel_swi_regs regs;
    char *disc = "Ram:$";

    regs.r[0] = 49;
    regs.r[1] = (int)disc;
    _kernel_swi(OS_FSControl, &regs, &regs);
    size = regs.r[2];
    used = (size - regs.r[0]);
    percentage = (int) (((float)used / (float)size) * 100);
  
  /*dprintf((NULL, "free = %d",(size-used)));*/

    /* less than 50% used - OK */
    if (percentage < 50)
        return(1);


    /* only 200k left - abort! */  
    if ((size - used)< 204800)
        return(3);

#if SUPPORT_SLOWDOWN
    /* only 300k left - try to slow the sender */
    if ((size - used)< 307200)
        return(4);
#endif

#if SUPPORT_SLOWDOWN
    /* greater than 50% used but more than 300K left - start streaming */
#else
    /* greater than 50% used but more than 200K left - start streaming */
#endif    
    return(2);
}
#endif


/*
 * Returns 0=OK
 *         non-zero for error
 */

extern int QuCommon_Page_Complete(Document document, unsigned int pageNum, PageClasses pageClass, PageTypes pageType, int fileType)
{
	PageRangeList current;

    set_filetypeDN(document->Directory, pageNum, fileType);

    {
        char current_page_leafname[32];
        _kernel_oserror *error = NULL;
        int objecttype, filelength, filetype;

        sprintf(current_page_leafname, "%d", pageNum);

        if ((error = osfile_ReadCatInfoDL(document->Directory, current_page_leafname, &objecttype, &filelength, &filetype)) == NULL)
        {
            document->TotalSize += filelength;

            if (document->BiggestPage < filelength)
                document->BiggestPage = filelength;
#if SUPPORT_EMAIL
            if (filelength >= STREAM_200K)
                document->RequestTx = TRUE; /* get rid of large pages quickly, even though streaming watermark may not have been hit */
#endif
        }
    }

	document->ScanCount += 1;

    /* if the new page is exactly the same class & type as the old, extend the PageRange already in the PageList */  
	if (document->PageList)
	{
		/* we have one or more PageRange in the PageList */
    	current = document->PageList;	/* last record in the list */

   		if ((current->PageClass == pageClass) &&
   		    (current->PageType == pageType) &&
		    (current->FileType == fileType)
		   )
        {
           	/* same type of page as the last one, so extend the range */
           	current->hiPage = document->ScanCount;
            return(0);
        }
    }

	/* either PageList is empty, or new page is a different type to the last one, so start a new PageRange */
	current = malloc(sizeof(PageRange));
	if (current)
	{
		/* fill in new record */

		current->PageClass = pageClass;
        current->PageType = pageType;
        current->FileType = fileType;

        current->loPage = document->ScanCount;
        current->hiPage = document->ScanCount;
        current->open_ended = FALSE;

		/* add the new record to the end of the list */
		if (document->PageList == NULL)
			current->next_pagerange = current;	/* first and only page range, so point our next field at ourselves */	
		else
		{
			document->PageList->open_ended = FALSE;	/* close old last entry */

			current->next_pagerange = document->PageList->next_pagerange;	/* point to head of list */
			document->PageList->next_pagerange = current;					/* old last item becomes last-but-one (we are last) */
		}	
        document->PageList = current;	/* point to tail of list, our next_pagerange field points to the head of the list */

        return(0);
	}

	/* error: no memory to create a new PageRange record */
	/* the new page has been counted, but we can't recover its type */
	return(1);	/* Error: out of memory */
}


extern int QuCommon_GetClassAndType(Document document, unsigned int pageNum, PageClasses *pPageClass, PageTypes *pPageType, int *pFileType)
{
	if (document)
	{
		if (document->PageList)
		{
			PageRangeList current = document->PageList;
			do
				{
					current = current->next_pagerange;	/* point to first/next entry */

					if ((current->loPage <= pageNum) && (pageNum <= current->hiPage))
					{
						/* pageNum within current range, so return class & type */
						*pPageClass = current->PageClass;
						*pPageType  = current->PageType;
						*pFileType  = current->FileType;

						return(0);	/* OK */
					}
				}
			while (current != document->PageList);
		}
    }

	/*>>>what should we return???*/
	*pPageClass = PageClass_TIFF;
	*pPageType  = PageType_TIFF_2DMMR;
	*pFileType  = FILETYPE_TIFF;
	    
    return(1);	/* Error: pageNum not in PageList */
}


/* end of QuCommon.c */
