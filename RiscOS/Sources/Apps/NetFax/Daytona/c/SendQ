/*
 * SendQ.c - Daytona Fax and Email Send Queue
 *
 * R C Manby
 *
 * Started 22 July 1997
 */


#include "BuildFlags.h"
#include "StdTypes.h"

#define KLUDGE_EMAIL 1
#define SCANNING 1
#define TRANSMITTING 1
#define TEXTUAL_EMAIL 0
#define HARDCOPY_FINISHED 1
#define NEW_CANCEL_CODE 1

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "kernel.h"

#include "LogFileIF.h"

#include "PageList.h"
#include "StateKicker.h"
#include "SendQ.h"
#include "PrintQ.h"
#include "Screen.h"

#if SCANNING
#include "LocXfer.h"
#endif
#if TRANSMITTING
#include "RemXfer.h"
#endif

#if SUPPORT_EMAIL
#include "MimeQ.h"
#endif

#include "functions.h"
#include "wimp.h"
#include "wimplib.h"
#include "AddrBookIF.h"
#include "QuStruct.h"
#include "QuCommon.h"
#include "QuHWM.h"
#include "dialler.h"    /* for dialler status codes */


#include "DebugLib.h"
#include "SetupIF.h"
#include "FileOps.h"

#if SUPPORT_ADDRESSBOOK
#include "NumConvert/NumConvert.h"
#else
#include "TfaxAddr.h"	/* if not using the full address book use the mini address book */ 
#endif

#define SENDQ_RX_DIR_DOC_0 "RAM::RamDisc0.$.SendQ.Doc0"

enum _HL_RC { OK = 0, Error_MultipleNAN, Error_NoMemory, OS_Error };
typedef enum _HL_RC HL_RC;


/* external flags that trigger an immediate dialup (for send then receive) */
BOOL isp_dialup_timer_request = FALSE;      /* } all are cleared as soon as a SQ_RX_DIAL_ISP starts,  */
BOOL isp_dialup_user_request = FALSE;		/* } but we set isp_dialup_redial_needed to cause a later */
BOOL isp_dialup_download_request = FALSE;   /* } redial if the connection fails                       */

/* local flags that trigger a dialup when time() is connection->RetryTime */
static BOOL isp_dialup_redial_needed = FALSE;      /* this should only be cleared when the complete send/receive cycle has happened */
static BOOL isp_dialup_watermark_reached = FALSE;  /* this can be cleared after each complete document has been sent */
                                                   /*>>>RCM says rename this, as it is set when a documents RequestTx flag is set*/
                                                   /*>>>    ie when watermark reached or scan complete and document should be sent immediatly*/

BOOL user_request_cancel_fax = FALSE;


#define ISP_LIST_SIZE 2


struct
{
    int using_now;      /* -1=dormant, 0..(ISP_LIST_SIZE-1) if active */
    int use_next;	/* initialised to -1 meaning rest of structure un-initialised */
	int errors_before;
    PhoneConnection Connection[ISP_LIST_SIZE];
    char           *PhoneNumber[ISP_LIST_SIZE];


}
isp_dialup = { -1, -1 };


#if DAYTONA
static void hardcopy_new_document(Document document);
static void hardcopy_pages_complete(Document document, unsigned int loPage, unsigned int hiPage);
static void hardcopy_document_complete(Document document);
static void unable_to_deliver(Document document);
#endif

static void show_SendRoute(Document document);
static void show_Sending(Document document);

#if SUPPORT_UI
static void show_ContactName(Document document);
static void Log_RxConnectingError(messageDataBlock *messageData);
static void Log_RxConnectedError(messageDataBlock *messageData);
#endif

static void Log_TxConnecting(enum _SendRoute route, PhoneConnection *connection, const char *dial_number);
#if SUPPORT_UI
static void Log_TxConnectingError(enum _SendRoute route, PhoneConnection *connection, messageDataBlock *messageData);
#endif
static void Log_TxConnectingFailed(enum _SendRoute route, PhoneConnection *connection);
static void Log_TxConnected(enum _SendRoute route, PhoneConnection *connection);
static void Log_TxConnectedSentData(enum _SendRoute route, PhoneConnection *connection);
static void Log_TxConnectedErrorSendingDoc(enum _SendRoute route, PhoneConnection *connection, messageDataBlock *messageData, Document document);
static void Log_TxConnectedError(enum _SendRoute route, messageDataBlock *messageData);
#if SUPPORT_UI
static void Log_TxSendDocument(enum _SendRoute route, Document document);
#endif
static void Log_TxSentDocument(enum _SendRoute route, Document document);
#if SUPPORT_UI
static void Log_TxDisconnected(enum _SendRoute route, PhoneConnection *connection);
static void Log_TxEncodingError(enum _SendRoute route, messageDataBlock *messageData, Document document);
#endif
#if SUPPORT_UI
static void Log_TxReRouting(enum _SendRoute route, Document document);
static void Log_TxUnableToDeliver(enum _SendRoute route, Document document);
#endif

static BOOL connection_impossible(enum _SendRoute route, PhoneConnection *connection);
static BOOL connection_requested_now(enum _SendRoute route, PhoneConnection *connection);

static void SendQ_ClearDownSendState(void);
static _kernel_oserror *SendQ_CreateDocument(Document *p_document);
static void SendQ_NextDocument(BOOL *p_email_flag, Document *p_document);
static Document document_from_pid(unsigned int pid);
#if SUPPORT_EMAIL
static Document next_email(Document document);
#endif
static Document document_from_SearchRef(int SearchRef);





#if KLUDGE_NAN
extern int global_forceNAN = 0;	/* 0=>Normal, 1=>ForceNAN */
#endif
#if KLUDGE_ROUTING
extern int global_routing = 0;	/* 0=>Fax, 1=>ZModem */
#endif

static BOOL maybe_idle = TRUE;	/* strong hint that the local fax may be idle and hence free for printing to */

enum _rx_States { rxIDLE = 0, rxCONNECTED };
enum _tx_States { txIDLE = 0, txDIRECTCONNECTING, txDIRECTCONNECTED, txISPCONNECTING, txISPCONNECTED };

typedef enum _rx_States rx_States;
typedef enum _tx_States tx_States;

#define ADDRBOOKIF_SEARCH_FLAGS		(Field_ContactName | Field_EmailAddress | Field_FaxNumber | Field_DeviceClass | Field_RoutingOverride)
#define ADDRBOOKIF_ONESHOT_FLAGS    (Field_EmailAddress | Field_FaxNumber)	/* NB just a tally of data received, so don't try changing to xxxx_OneShot_xxxx */

/*
 * Action messages from LocXfer and RemXfer
 *
 */
extern void SendQ_MessageHandler(int messageNumber, messageDataBlock *messageData)
{
	static rx_States rx_state = rxIDLE;
	static tx_States tx_state = txIDLE;
	static Document scan_document = NULL;	/* Do we KNOW that there can be only one active at a time? */
    static Document transmit_document = NULL;
#if SUPPORT_EMAIL    
    static Document encoding_document = NULL;
    static BOOL download_suppressed = FALSE;    /* set by SendQ when it suppresses an email download - when rx_state goes rxIDLE a redial is triggered */
#endif
    static Document NAN_document = NULL;

	HL_RC status = OK;

    /* Print message number to debug device */
    dprintf((NULL, "SendQ_MessageHandler: Message => 0x%X\n", messageNumber));

	switch (messageNumber)
	{
#if SCANNING
		case LX_SQ_ERROR:
		case LX_SQ_NEW_DOCUMENT:
        case LX_SQ_NEW_PAGE:
        case LX_SQ_PAGE_COMPLETE:
        case LX_SQ_DOCUMENT_COMPLETE:
#if SUPPORT_CHECK_HWM
        case SQ_SQ_CHECK_HWM:
#endif
			{
				rx_States nextstate = rx_state;

				switch (rx_state)
				{
					case rxIDLE:
						switch (messageNumber)
                        {
							case LX_SQ_ERROR:
#if SUPPORT_UI
								Screen_ReportError(LX_SQ_SC_ERROR, "Title_LX_SQ_ERROR", messageData);
								Log_RxConnectingError(messageData);
#endif
								break;

							case LX_SQ_NEW_DOCUMENT:
								{
#if SUPPORT_ADDRESSBOOK
									int interactive = FALSE;
									/*
									 * need:
									 *  setup_configuredNAN             - to determine if NAN was dialled
									 *  setup_external_access_code      }
									 *  setup_international_access_code } to convert number
									 *  setup_national_access_code      } (non-NAN) dialled on fax machine
									 *  setup_fax_country_code          } to internal format
									 *  setup_fax_area_code             }
                                     */

									SetupIF_Read_Phone_Config();

									/*int documentId = NewDocumentId();*/
					                interactive = (strcmp(messageData->data.lx_sq_new_document.number, setup_configuredNAN) == 0);

                                    LogFileIF_show_string(LOG_DEBUG, "Configured NAN", setup_configuredNAN);
			                        LogFileIF_show_string(LOG_DEBUG, "Configured fax number", setup_fax_number);

									/* treat empty number as setup_configuredNAN */
									if (messageData->data.lx_sq_new_document.number[0] == '\0')
										interactive = TRUE;
#if KLUDGE_NAN
									if (global_forceNAN)
									{
										/* force interactive search all the time */
										interactive = TRUE;
									}
#endif

									/* only one interactive search allowed at once */
									if ((interactive) && (AddrBookIF_InteractiveBusy()))
										status = Error_MultipleNAN;
#endif
									if (status == OK)
									{
					                    /* only allow fax scanning if we have a reasonable amount of memory */
					                	switch (HWM_Check(/*DEFAULT_FAX_SIZE*/))
					                	{
					                		case 3:
#if SUPPORT_SLOWDOWN
                                            case 4:
#endif
					                		case 2:
					                			status = Error_NoMemory;
					                			break;
					
					                		case 1:
					                			if (SendQ_CreateDocument(&scan_document) != NULL)
					                				status = OS_Error;
					                			break;
					                	}
									}
					
									if (status == OK)
									{
										messageDataBlock *sendMessage;
					
										scan_document->ScanState = ScanRUNNING;	/* in progress */
										scan_document->RequestReceipt = configured_request_receipt;

					                    /* tell LocXfer where to put the document (fax/text) */
										StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_NEW_DOCUMENT_DIR, &sendMessage);
										sendMessage->data.new_document_dir.pid = scan_document->ProcessId;
										strcpy(sendMessage->data.new_document_dir.directory, scan_document->Directory);
					
					                    /* attach number dialled on fax machine to document */
#if SUPPORT_ADDRESSBOOK
										/* visually cleaner to open address book last rather than risk having to close it if above calls fail */
										/* search may terminate after scan has completed, so document is tied to the search by the SearchRef */
										if (interactive)
										{
											/* interactive (NAN) search, returning contact name, email address, fax number, routing etc */
											/* but user may choose 'One shot' which returns email address and fax number only */
											scan_document->AddressRecord.SearchFlags  = ADDRBOOKIF_SEARCH_FLAGS;
											scan_document->AddressRecord.OneShotFlags = ADDRBOOKIF_ONESHOT_FLAGS;
											AddrBookIF_InteractiveSearch(&scan_document->SearchRef, &scan_document->AddressRecord, ADDRBOOKIF_SEARCH_FLAGS);

										    /* tell Screen a scan has started */
										    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_NEW_DOCUMENT, &sendMessage);
										    sendMessage->data.sq_sc_new_document.pid = scan_document->ProcessId;
										    strcpy(sendMessage->data.sq_sc_new_document.number, messageData->data.lx_sq_new_document.number);
										}
										else
										{
                                            /* we read all the setup_xxx variables we need above */

						                    numconvert_captured_to_internal(messageData->data.lx_sq_new_document.number,
						                                                 	scan_document->CapturedPhoneNumber,   /* internal format */
                                                                            sizeof(scan_document->CapturedPhoneNumber),
						                        							setup_external_access_code,				/* op:	Outside line prefix, eg "" or "9" */
						                        							setup_international_access_code,		/* ip:	International prefix, eg "00" */
						                        							setup_national_access_code,      		/* np:	National prefix, e.g. "0" */
						                        							setup_fax_country_code,                 /* cc:	Country code, e.g. "44" */
						                        							setup_fax_area_code                     /* ac:	Area code, e.g. "1223" */
						                        						   );
					                        /* non interactive search of fax or voice number */
					                        /* returning contact name, email address, fax number, routing etc */
					                        /* 'One shot' not applicable */
											scan_document->AddressRecord.SearchFlags  = ADDRBOOKIF_SEARCH_FLAGS;
											scan_document->AddressRecord.OneShotFlags = ADDRBOOKIF_ONESHOT_FLAGS;
											AddrBookIF_SearchFaxNumber(&scan_document->SearchRef, &scan_document->AddressRecord, ADDRBOOKIF_SEARCH_FLAGS, scan_document->CapturedPhoneNumber);

    										/* tell Screen a scan has started */
    										StateKicker_SendMessage(Screen_StateMachine, SQ_SC_NEW_DOCUMENT, &sendMessage);
    										sendMessage->data.sq_sc_new_document.pid = scan_document->ProcessId;
    										numconvert_internal_to_display(scan_document->CapturedPhoneNumber, /* internal format */
                                                                           sendMessage->data.sq_sc_new_document.number,
                                                                           sizeof(sendMessage->data.sq_sc_new_document.number),
                                                                           setup_international_access_code,     /* ip:	International prefix, eg "00" */
                                										   setup_national_access_code,      	/* np:	National prefix, e.g. "0" */
								                                		   setup_fax_country_code,              /* cc:	Country code, e.g. "44" */
										                                   setup_fax_area_code                  /* ac:	Area code, e.g. "1223" */
										                                  );
										}
#else
										/* no address book, so pretend the search completed, use captured number as direct number */
                        				scan_document->AddressRecord.DeviceClass = DeviceClass_Fax;				   
                        				scan_document->SendRoute = RouteDIRECT;
										scan_document->AddressRecord.SearchFlags = scan_document->AddressRecord.OneShotFlags = 0;
										strcpy(scan_document->CapturedPhoneNumber, messageData->data.lx_sq_new_document.number);
										strcpy(scan_document->AddressRecord.DirectPhoneNumber,   messageData->data.lx_sq_new_document.number);

                                        /* no address book so look up number in mini address book */
                                        if (TFax_NAN(scan_document->CapturedPhoneNumber))
                                        {
										    scan_document->Cancelled=TRUE;
										    nextstate = rxIDLE;   
                                        }
                                        else
                                        {
									   	    if (TFax_addr_lookup(messageData->data.lx_sq_new_document.number))
									   	        scan_document->AddressRecord.DeviceClass = DeviceClass_Daytona;
									   	    else
									   	        scan_document->AddressRecord.DeviceClass = DeviceClass_Fax;
                                        }
										/* tell Screen a scan has started, captured number may be useful for debugging */
										StateKicker_SendMessage(Screen_StateMachine, SQ_SC_NEW_DOCUMENT, &sendMessage);
										sendMessage->data.sq_sc_new_document.pid = scan_document->ProcessId;
										strcpy(sendMessage->data.sq_sc_new_document.number, messageData->data.lx_sq_new_document.number);
#endif
										nextstate = rxCONNECTED;
									}
									else
										StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);
								}
								break;
                        }
                        break;
                    
					case rxCONNECTED:
						switch (messageNumber)
                        {
							case LX_SQ_ERROR:
#if SUPPORT_UI
								Screen_ReportError(LX_SQ_SC_ERROR, "Title_LX_SQ_ERROR", messageData);
								Log_RxConnectedError(messageData);
#else
                                /* don't look at RetryCount cos this is a scanning error */ 
                                Fax_ReportError(LOCAL_ERROR, "Title_RX_SQ_ERROR", messageData, scan_document->Directory, scan_document->SendCount);
#endif
#if 1 /*PAN-00895*/
                                if (messageData->data.error.code == code_RxCancelled)
                                {
                                    /* scan cancelled at the local fax machine (usually means user pressed STOP on fax) */
                                    scan_document->Cancelled = TRUE;
#if NEW_CANCEL_CODE
                                    /* if this is a streaming scan/send, TRY aborting the send */ 
                                    if ((scan_document->SendState != SendIDLE) && (scan_document->SendState != SendCOMPLETE))
                                    {
                                        /* some attempt is being made to send this, either connecting, mime-encoding/mime-encoded or sending */
                                        StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_ABORT_OUTGOING, NULL);  /* abort if possible */
                                    }                                    
#endif
                                }
#endif
								break;

							case LX_SQ_NEW_DOCUMENT:
								StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);
								break;

							case LX_SQ_NEW_PAGE:
								{
									/*>>>Trigger page <n> animation*/
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_NEW_PAGE, NULL);
					
									switch (HWM_Check())					/* returns 1/2/3 OK/Trigger-send/Abort-Rx */
									{
										case 3:
											StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);
											/* drop into... */
#if SUPPORT_SLOWDOWN
                                        case 4:
                                            /* drop into... */
#endif
										case 2:
											scan_document->RequestTx = 1;	/* requesting (or in progress) */
										case 1:
											break;
									}
								}
								break;
#if SUPPORT_CHECK_HWM
                            /* large pages take a long time to scan - watermarks may have been passed long before LX_SQ_PAGE_COMPLETE is received */
						    case SQ_SQ_CHECK_HWM:
						        {
						            if (scan_document)
						            {
                                        switch (HWM_Check())				/* returns 1/2/3 OK/Trigger-send/Abort-Rx */
                                        {
						                    case 3:
#if SUPPORT_SLOWDOWN
                                            case 4:
                                                StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_SLOW_INCOMING, NULL);
		    									/* drop into... */
#endif
						                    case 2:
						                        scan_document->RequestTx = 1;		/* requesting */
						                        break;
						                }
						            }
						        }
						        break;
#endif
							case LX_SQ_PAGE_COMPLETE:
								{
					                messageDataBlock *sendMessage;
					
									QuCommon_Page_Complete(scan_document,
									                       messageData->data.lx_sq_page_complete.pageNum,
									                       messageData->data.lx_sq_page_complete.pageClass,
									                       messageData->data.lx_sq_page_complete.pageType,
									                       messageData->data.lx_sq_page_complete.fileType
									                      );
					
									switch (HWM_Check())					/* returns 1/2/3 OK/Trigger-send/Abort-Rx */
									{
										case 3:
											StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);
											scan_document->RequestTx = 1;	/* requesting (or in progress) */
                                            break;
#if SUPPORT_SLOWDOWN
                                        case 4:
                                            StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_SLOW_INCOMING, NULL);
											/* drop into... */
#endif
										case 2:
											scan_document->RequestTx = 1;	/* requesting (or in progress) */
										case 1:
											break;
									}
					
									/* poke the animations */
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_PAGE_COMPLETE, &sendMessage);
					                sendMessage->data.sq_sc_page_complete.ScanCount = scan_document->ScanCount;
								}
								break;
					
							case LX_SQ_DOCUMENT_COMPLETE:
								{
					                messageDataBlock *sendMessage;
					
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DOCUMENT_COMPLETE, &sendMessage);
					                sendMessage->data.sq_sc_document_complete.ScanCount = scan_document->ScanCount;
					
									scan_document->ScanState = ScanCOMPLETE;	/* complete (3)  */
#if 1
									scan_document->RequestTx = 1;				/* requesting */
#endif
									scan_document = NULL;	/* this handler no longer needs to reference this document */
									nextstate = rxIDLE;
								}
								break;
                        }
                        break;
                } /* switch (rx_state) */

#if SUPPORT_EMAIL
			    /* report SQ_xx_GOING_IDLE if going idle from a non-idle state */
				if ((nextstate == rxIDLE) && (rx_state != rxIDLE))
				{
#if SUPPORT_EMAIL
					if (download_suppressed)
					{
					    download_suppressed = FALSE;
					    
                        /* request immediate ISP connection. we want a receive, but are happy to allow transmit */
                        isp_dialup_download_request = TRUE;
					}    
#endif
#if 0
					StateKicker_SendMessage(Xxxx_MessageHandler, SQ_xx_GOING_IDLE, NULL);
#endif
				}
#endif
				rx_state = nextstate;
            }
            break;
/* end of scanning */
#endif
#if SCANNING
#if SUPPORT_ADDRESSBOOK
/* scanning - address book search */
		case AD_SQ_NOTFOUND:
        case AD_SQ_CANCEL:
		case AD_SQ_FINISH:
			NAN_document = document_from_SearchRef(messageData->data.cancel.searchref);	/*NB assumes data.cancel.searchref data.finish.searchref data.notfound.searchref are overlaid */
		    if (NAN_document)
		    {
	    		switch (messageNumber)
	    		{
	    			/* number dialled on fax machine is not in the address book, so use it, assuming a fax machine will answear */
	    			case AD_SQ_NOTFOUND:
	    				strcpy(NAN_document->AddressRecord.DirectPhoneNumber, NAN_document->CapturedPhoneNumber);	/* internal format */
                        NAN_document->AddressRecord.DeviceClass = DeviceClass_Fax;				   
                        NAN_document->SendRoute = RouteDIRECT;
						scan_document->AddressRecord.SearchFlags = scan_document->AddressRecord.OneShotFlags = 0;	/* pretend the search completed */
	    				break;

                    /* no need to query the user !Address does it for us */
	    			case AD_SQ_CANCEL:
	    			    NAN_document->Cancelled = TRUE;
						scan_document->AddressRecord.SearchFlags = scan_document->AddressRecord.OneShotFlags = 0;	/* pretend the search completed */
	    				break;

					case AD_SQ_FINISH:
						show_ContactName(NAN_document);	/* display debugging/user info */

						/* scan_document->AddressRecord.SearchFlags or scan_document->AddressRecord.OneShotFlags are now zero */

                        /* now that we have the address book data, we may be able to choose the final routing */
                   		if (NAN_document->AddressRecord.EmailAddress[0] == '\0')
                   		{
                   			if (NAN_document->AddressRecord.DirectPhoneNumber[0] == '\0')
                   			{
                   				/* opps, search has completed, without returning a suitable destination */
                   				NAN_document->Cancelled = TRUE;	/*>>>perhaps we should open the NAN window*/
                   			}
                   			else
                   			{
                   				/* have phone number only, DeviceClass may have been set or left at default */
                   				NAN_document->SendRoute = RouteDIRECT;
                   				show_SendRoute(NAN_document);	/* display debugging/user info */
                   			}
                   		}
                   		else
                   		{
                   			if (NAN_document->AddressRecord.DirectPhoneNumber[0] == '\0')
                            {
                               	/* have email address only, DeviceClass may have been set or left at default */
                               	NAN_document->SendRoute = RouteISP;
                               	show_SendRoute(NAN_document);	/* display debugging/user info */
                            }
                            else
                            {
                               	/* ask user which route to use */
                               	Screen_QuerryRoute(NAN_document->ProcessId, NAN_document->AddressRecord.ContactName);
                               	/* SC_SQ_ROUTING with RouteUNKNOWN (ie use global routing), RouteDIRECT or RouteISP will arrive later on */
                            }
                   		}
						break;
	    				
	    		} /*inner switch (messageNumber)*/
		    }
            break;
#endif
		case SC_SQ_ROUTING:
			NAN_document = document_from_pid(messageData->data.deliveryoptions.pid);
		    if (NAN_document)
			{
	    		NAN_document->SendRoute = messageData->data.deliveryoptions.route;	/* RouteUNKNOWN (ie use local routing), RouteDIRECT or RouteISP */

				/* no route chosen, use AddressRecord.LocalRouting */
				if (NAN_document->SendRoute == RouteUNKNOWN)
					NAN_document->SendRoute = NAN_document->AddressRecord.LocalRouting;	/* which may also be RouteUNKNOWN (ie use global routing), RouteDIRECT or RouteISP */

				if (NAN_document->SendRoute == RouteUNKNOWN)
				{
					if (setup_configured_routing == 0)
						NAN_document->SendRoute = RouteISP;
					else
						NAN_document->SendRoute = RouteDIRECT;		
                }                
                show_SendRoute(NAN_document);	/* display debugging/user info */

				/* Since we asked the user to selected the primary route (RouteDIRECT or RouteISP), */
				/* we know that the other route is available as the secondary route */ 
				NAN_document->ReRouteAvailable = TRUE;
			}
       		break;
#if SUPPORT_UI
        case UI_SQ_CANCEL:
#if NEW_CANCEL_CODE
            /* when scanning a document, the user is shown the intended recipient, CANCEL obviously means 'cancel the document being scanned' */
            if (scan_document != NULL)
            {
                scan_document->Suspending = TRUE;   /* indicate that we'd like to suspend & possibly cancel this */

                /* if this is a streaming scan/send, TRY aborting the send */ 
                if ((scan_document->SendState != SendIDLE) && (scan_document->SendState != SendCOMPLETE))
                {
                    /* some attempt is being made to send this, either connecting, mime-encoding/mime-encoded or sending */
                    StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_ABORT_OUTGOING, NULL);  /* abort if possible */
                }
            }
            else
            {
                /* with direct dialled faxes, the user is shown number/recipient dialled, CANCEL must mean 'cancel the document being sent' */
                switch (tx_state)
                {
                    case txDIRECTCONNECTING:
                    case txDIRECTCONNECTED:
                        if (transmit_document)
                        {
                            /* user can see on screen who we are trying to send a document to, so cancel is unambiguous */
                            transmit_document->Suspending = TRUE;   /* indicate that we'd like to suspend & possibly cancel this */
                            StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_ABORT_OUTGOING, NULL);  /* abort if possible */
                        }
                        break;
                }

                /* WE CANNOT CANCEL EMAIL SENDS */

                /* when SendQ_QueueWalker sees document->SendState of SendIDLE or SendCOMPLETE with document->Suspending == TRUE */
                /* and there are actually pages left too cancel, it sets document->Suspended and calls Screen_QuerryCancel       */
            }
#else
            if ((scan_document != NULL) && (scan_document != transmit_document))
            {
                /* not yet sending, so inhibit sending, then                   */
                /* ask user to confirm Cancel button (if not already doing so) */
                if (scan_document->Suspended == FALSE)
                {
                    scan_document->Suspended = TRUE;
                    Screen_QuerryCancel(scan_document->ProcessId);
                }            
            }
#if 0
            else
            {
                if (transmit_document != NULL)
                {
                    StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_ABORT_OUTGOING, NULL);
                    aborting_outgoing = TRUE;
                    transmit_document->aborting;
                }
            }
#endif
#endif
            break;
#endif
        case SC_SQ_CANCEL_CONFIRMED:
            NAN_document = document_from_pid(messageData->data.sc_sq_cancel_confirmed.pid);
            if (NAN_document)
            {
                /* if scanning still in progress, abort it */
                if ((NAN_document == scan_document) &&
                    (NAN_document->ScanState == ScanRUNNING)
                   )
                    StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);

                NAN_document->Cancelled = TRUE;
            }
            break;

        case SC_SQ_CANCEL_REVOKED:
            NAN_document = document_from_pid(messageData->data.sc_sq_cancel_revoked.pid);
            if (NAN_document)
            {
                NAN_document->Suspended = FALSE;
            }
            break;
/* end of scanning - address book search*/
#endif

		case RX_SQ_GOING_IDLE:
			/* a receive or a send has just completed */
			maybe_idle = TRUE;	/* tell queue scanner it may like to try printing */
			/* drop into... */
#if TRANSMITTING
/* transmitting */
		case RX_SQ_AM_IDLE:
		case RX_SQ_DIAL_REJECTED:
#if 0
		case RX_SQ_FAILED:
#endif
		case RX_SQ_ERROR:
	  /*case RX_SQ_WHICH_DOCUMENT: occurs lower down */
		case RX_SQ_SWITCHTO_DAYTONA:
	  	case RX_SQ_CONNECTED:
		case RX_SQ_SENDING_DOCUMENT:
		case RX_SQ_SENDING_PAGE:
		case RX_SQ_PAGE_SENT:
		case RX_SQ_DOCUMENT_SENT:
#if /*THINK*/ 0
		case RX_SQ_MAYBE_VOICE:
#endif
#if SUPPORT_EMAIL
	  /*case ME_SQ_WHICH_DOCUMENT: occurs lower down */
	  /*case ME_SQ_NEXT_DOCUMENT:  occurs lower down */
	  /*case ME_SQ_ERROR: occurs lower down */
		case RX_SQ_SENDING_PAGE_RANGE:
		case RX_SQ_PAGE_RANGE_SENT:
#endif
			{
				tx_States nextstate = tx_state;

				switch (tx_state)
				{
	            	case txIDLE:
	                    switch (messageNumber)
						{
							/* some outside code needs to do StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_QUERY_IDLE, NULL); */
							/* this will be ignored or cause a reply of RX_SQ_AM_IDLE                                               */
							case RX_SQ_AM_IDLE:
								{
									BOOL              email_flag;
									char              show_number[SIZEOF_NUMBER_TO_DISPLAY /*30*/];	/* format we show the user */
									char              dial_number[SIZEOF_NUMBER_TO_DIAL /*30*/];	/* actual number dialled */
									messageDataBlock *sendMessage;
					
									/* is there anything to send? */
					                SendQ_NextDocument(&email_flag, &transmit_document);

					                if ((email_flag == FALSE) && (transmit_document))
					                {
#if SUPPORT_ADDRESSBOOK
										/*
										 * need:
										 *  setup_external_access_code      }
										 *  setup_international_access_code } to convert internal form of number (from fax machine or address book)
										 *  setup_national_access_code      } to dialer format
										 *  setup_fax_country_code          }
										 *  setup_fax_area_code             }
										 */
										SetupIF_Read_Phone_Config(); /*>>>will do for now*/
#endif
					                	if (transmit_document->SendRoute == RouteDIRECT)
						                {
#if SUPPORT_ADDRESSBOOK
											numconvert_internal_to_display(transmit_document->AddressRecord.DirectPhoneNumber,	/* internal format */
											                               show_number,
											                               sizeof(show_number),
											                               setup_international_access_code,		/* ip:	International prefix, eg "00" */
											                               setup_national_access_code,      	/* np:	National prefix, e.g. "0" */
											                               setup_fax_country_code,              /* cc:	Country code, e.g. "44" */
											                               setup_fax_area_code                  /* ac:	Area code, e.g. "1223" */
											                              ); 
											
											/* tell screen that if it receives RM_SC_DIALLING that it's contacting */
											/* transmit_document->AddressRecord.DirectPhoneNumber, transmit_document->AddressRecord.ContactName */
						                    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_CONTEXT_DIRECT, &sendMessage);
						                    sendMessage->data.context_direct.pid = transmit_document->ProcessId;
											strcpy(sendMessage->data.context_direct.number,  show_number);
											strcpy(sendMessage->data.context_direct.contact, transmit_document->AddressRecord.ContactName);
#else
											strcpy(show_number, transmit_document->AddressRecord.DirectPhoneNumber);											
#endif
#if KLUDGE_ROUTING
						                    if (global_routing == 0)
						                        StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_FAX, &sendMessage);
						                    else
						                    	StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_DAYTONA, &sendMessage);
#else
											if (transmit_document->AddressRecord.DeviceClass == DeviceClass_Fax)
												StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_FAX, &sendMessage);
											else
												StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_DAYTONA, &sendMessage);
#endif
#if SUPPORT_ADDRESSBOOK
								    	    numconvert_internal_to_dial(transmit_document->AddressRecord.DirectPhoneNumber,	/* in - internal format */
								    	                                dial_number,        					            /* out - dialler format */
								    	                                sizeof(dial_number),
					                                                    setup__tonepulse,                     	/* pulse/tone */
					                                                    setup_external_access_code,				/* op:	Outside line prefix, eg "" or "9" */
					                                                    setup__external_access_pausewait,		/* opp:	Outside line pause/wait after prefix eg "", "W" */
					                                                    setup_international_access_code,		/* ip:	International prefix, eg "00" */
					                                                    setup__international_access_pausewait,	/* ipp:	International pause/wait after prefix, e.g. "," */
								    	                                setup_national_access_code,      		/* np:	National prefix, e.g. "0" */
					                                                    setup_fax_country_code,                 /* cc:	Country code, e.g. "44" */
					                                                    setup_fax_area_code                     /* ac:	Area code, e.g. "1223" */
					                                                   );
#else
											strcpy(dial_number, transmit_document->AddressRecord.DirectPhoneNumber);
#endif
					                        strcpy(sendMessage->data.dial.number, dial_number);
						                /*	SetupIF_Read_Phone_Config();*/ /*>>>will do for now*/
						                	SetupIF_Read_Email_Config(); /*>>>will do for now*/

											/*REPORT: DirectDial<number>*/
											Log_TxConnecting(RouteDIRECT, &(transmit_document->Connection), show_number);

						                    /* MUST change SendState from SendIDLE because setting Cancelled will delete the document */
						                    transmit_document->SendState = SendRUNNING; /*SendCONNECTING*/

											nextstate = txDIRECTCONNECTING;
								    	}
								    }
#if SUPPORT_EMAIL
								    if ((email_flag == TRUE) && (isp_dialup.use_next >= 0) && (isp_dialup.use_next < ISP_LIST_SIZE)
#if 1 /*PAN-02059*/
                                        /* dial allowed if document to send or scanner idle */
                                        && ((transmit_document != NULL) || (rx_state == rxIDLE))
#endif
								       )
								    {
					                	SetupIF_Read_Phone_Config(); /*>>>will do for now*/
					                	SetupIF_Read_Email_Config(); /*>>>will do for now*/

                                        isp_dialup.using_now = isp_dialup.use_next;
#if SUPPORT_ADDRESSBOOK
										numconvert_internal_to_display(isp_dialup.PhoneNumber[isp_dialup.using_now],  /* in - internal format */
										                               show_number,                             /* out - display format */
										                               sizeof(show_number),
										                               setup_international_access_code,		/* ip:	International prefix, eg "00" */
										                               setup_national_access_code,      	/* np:	National prefix, e.g. "0" */
										                               setup_fax_country_code,              /* cc:	Country code, e.g. "44" */
										                               setup_fax_area_code                  /* ac:	Area code, e.g. "1223" */
										                              );

								    	numconvert_internal_to_dial(isp_dialup.PhoneNumber[isp_dialup.using_now],	/* in - internal format */
								    	                            dial_number,        				    /* out - dialler format */
								    	                            sizeof(dial_number),
					                                                setup__tonepulse,                     	/* pulse/tone */
					                                                setup_external_access_code,				/* op:	Outside line prefix, eg "" or "9" */
					                                                setup__external_access_pausewait,		/* opp:	Outside line pause/wait after prefix eg "", "W" */
					                                                setup_international_access_code,		/* ip:	International prefix, eg "00" */
					                                                setup__international_access_pausewait,	/* ipp:	International pause/wait after prefix, e.g. "," */
								    	                            setup_national_access_code,      		/* np:	National prefix, e.g. "0" */
					                                                setup_fax_country_code,                 /* cc:	Country code, e.g. "44" */
					                                                setup_fax_area_code                     /* ac:	Area code, e.g. "1223" */
					                                               );
#else
                                        strcpy(show_number, isp_dialup.PhoneNumber[isp_dialup.using_now]);
					                	strcpy(dial_number, isp_dialup.PhoneNumber[isp_dialup.using_now]);
#endif

					                	isp_dialup.errors_before = 0;

#if SUPPORT_LAN
										if (setup_Ether_Lan)
										{
               								StateKicker_SendMessage(Screen_StateMachine, SQ_SC_CONTEXT_LAN, NULL);
               								
					                		StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_LAN, &sendMessage);
					                		sendMessage->data.sq_rx_dial_lan.tx_flag = (BOOL)(transmit_document != NULL);
					                		sendMessage->data.sq_rx_dial_lan.rx_flag = (BOOL)(rx_state == rxIDLE);        /* (was rx_flag = TRUE) PAN-02059 don't download while scanning */
										}
										else
#endif
										{
							    			/* transmit_document->SendRoute is RouteISP */
							    			/* tell screen that if it receives RM_SC_DIALLING that it's contacting the ISP  */
					                		StateKicker_SendMessage(Screen_StateMachine, SQ_SC_CONTEXT_ISP, &sendMessage);
					                		strcpy(sendMessage->data.context_isp.number, show_number);

											StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_ISP, &sendMessage);
					                		sendMessage->data.sq_rx_dial_isp.tx_flag = (BOOL)(transmit_document != NULL);
					                		sendMessage->data.sq_rx_dial_isp.rx_flag = (BOOL)(rx_state == rxIDLE);  /* (was rx_flag =TRUE) PAN-02059 don't download while scanning */

					                		strcpy(sendMessage->data.sq_rx_dial_isp.number, dial_number);
										}
										/* no need to call Create_Originator_File() as MimeIF builds that data into email headers */
										/*REPORT: ISPDial<number>*/
										Log_TxConnecting(RouteISP, &isp_dialup.Connection[isp_dialup.using_now], show_number);

                                        if (transmit_document)
                                        {
						                    /* MUST change from SendIDLE because setting Cancelled will delete the document */
						                    transmit_document->SendState = SendRUNNING; /*SendCONNECTING*/
                                        }
#if 1 /*PAN-02059*/
                                        download_suppressed = (BOOL)(rx_state != rxIDLE);   /* PAN-02059 request download when scan completes */
#endif
										nextstate = txISPCONNECTING;
								    }
#endif								    
							    }
								break;
                        }
	            		break;

					case txDIRECTCONNECTING:
	                    switch (messageNumber)
						{
							case RX_SQ_DIAL_REJECTED:	/* not idle after all (incoming call) NOT counted as a failed dial attempt */
								nextstate = txIDLE;     /* Don't look for RX_SQ_GOING_IDLE (ignoring the one case where it IS sent) */
								break;
#if 0
							case RX_SQ_FAILED:
								nextstate = txIDLE;	/*>>>wait for GOING_IDLE???*/
								break;
#endif
							/* Error: unable to connect */
							case RX_SQ_ERROR:
#if 1
                                /* look for dialler errors that suggest a fax machine answered our attempted data dial-up */
								if ((messageData->data.error.ctx == ctx_Dialler_RCError)
								    &&
								    ((messageData->data.error.rc == Dialler_AbortedScript_NoCarrier /*6*/ /*no carrier*/) ||
								     (messageData->data.error.rc == Dialler_AbortedScript_Timeout   /*5*/ /*timeout*/)
								    )
								   )
                                {
									/* we sent SQ_RX_DIAL_DAYTONA, but RemModem cannot detect a carrier, */
									/* so assume the Daytona has been removed and retry as fax */
									transmit_document->AddressRecord.DeviceClass = DeviceClass_Fax;	/* NB may have been answered by voice! */
#if SUPPORT_ADDRESSBOOK
									/* tell address book that we didn't find a Daytona (either a fax machine or voice) */
                                    AddrBookIF_ModifyDeviceClass(transmit_document->AddressRecord.SerialNumber,
                                                                 transmit_document->AddressRecord.DirectPhoneNumber,
                                                                 transmit_document->AddressRecord.EmailAddress,
                                                                 transmit_document->AddressRecord.DeviceClass
                                                                );
#else
									TFax_address_remove(transmit_document->AddressRecord.DirectPhoneNumber);	/* RemModem (sending) didn't find a Daytona */
#endif
#if 1 /* PAN-01713 & PAN-01760 */
                                    /* override the usual THIRTY_SECOND or FIVE_MINUTE delay */
                                    transmit_document->Connection.RedialDelay = ONE_SECOND;   /* re-dial as soon as the hangup completes */

                                    /* a special case, don't count a failed dialup */
                                    transmit_document->Connection.RetryCount -= 1;
#endif
                                    /* override the NoCarrier/Timeout message with a highlevel 'Redialling in fax mode' message */
                                    messageData->data.error.code = code_RetryAsFax; 
                                }
#endif
                                /* now display and log the (possibly adjusted) error message */
#if SUPPORT_UI
								Screen_ReportError(RX_SQ_SC_ERROR, "Title_RX_SQ_ERROR", messageData);
								Log_TxConnectingError(RouteDIRECT, &(transmit_document->Connection), messageData);
#else
			                    if (transmit_document->Connection.RetryCount>= *(transmit_document->Connection.RetryLimit)-1)
			                        Fax_ReportError(REMOTE_ERROR,"Title_RX_SQ_ERROR", messageData,transmit_document->Directory,transmit_document->SendCount);
#endif
								/* we may get more errors before RX_SQ_GOING_IDLE */
								break;

							case RX_SQ_GOING_IDLE:
								/* the send has just completed - should only happen after one or more RX_SQ_ERRORs */
								/* count a failed dialup, calculate when the next attempt should be */
								Log_TxConnectingFailed(RouteDIRECT, &(transmit_document->Connection));
								transmit_document = NULL;	/* not valid after a call to Log_TxConnectingFailed */
	                    		nextstate = txIDLE;
								break;

							case RX_SQ_SWITCHTO_DAYTONA:
								/* we sent SQ_RX_DIAL_FAX, but !Fax detected that the receiver is capable of ZModem transfer and switched over */
								/* if the connection fails, we should re-dial using SQ_RX_DIAL_DAYTONA */
								transmit_document->AddressRecord.DeviceClass = DeviceClass_Daytona;
#if SUPPORT_ADDRESSBOOK
								/* tell address book that we found a Daytona rather than a fax machine */ 
#else
								TFax_address_add(transmit_document->AddressRecord.DirectPhoneNumber);	/* RemXfer (sending) has found a Daytona, add it to the address list */
#endif
								break;

                            case RX_SQ_CONNECTED:
								Log_TxConnected(RouteDIRECT, &(transmit_document->Connection));	/* log successful connection to recipient */
                                nextstate = txDIRECTCONNECTED;
								break;
						}
						break;

	                case txDIRECTCONNECTED:
	                    switch (messageNumber)
						{
							case RX_SQ_SWITCHTO_DAYTONA:
								/* we sent SQ_RX_DIAL_FAX, but !Fax detected that the receiver is capable of ZModem transfer and switched over */
								/* if the connection fails, we should re-dial using SQ_RX_DIAL_DAYTONA */
								transmit_document->AddressRecord.DeviceClass = DeviceClass_Daytona;
#if SUPPORT_ADDRESSBOOK
								/* tell address book that we found a Daytona rather than a fax machine */ 
#else
								TFax_address_add(transmit_document->AddressRecord.DirectPhoneNumber);	/* RemXfer (sending) has found a Daytona, add it to the address list */
#endif
								break;

							case RX_SQ_SENDING_DOCUMENT:
								if (transmit_document)
								{
								    transmit_document->SendState = SendRUNNING; 	/* in progress (2) */
								    transmit_document->ResumeTx  = TRUE;            /* consistant with email, but not really needed? */
					transmit_document->RequestTx = FALSE;	/*>>>try this*/

									/* start screen animations for direct send */
									show_Sending(transmit_document);
							    }
								break;

							case RX_SQ_SENDING_PAGE:
							    {
									messageDataBlock *sendMessage;
#if 0
	/*>>>SQ_SC_SENDING_PAGE is a better name than SQ_SC_SENDING_FAX???*/

									/* poke animation */
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_PAGE, &sendMessage);
								    sendMessage->data.sq_sc_sending_page.pid     = transmit_document->ProcessId;
								    sendMessage->data.sq_sc_sending_page.sending = transmit_document->SendCount + 1;
#else
									/* poke animation */
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_FAX, &sendMessage);
									sendMessage->data.sq_sc_sending_fax.pid     = transmit_document->ProcessId;
									sendMessage->data.sq_sc_sending_fax.sending = transmit_document->SendCount + 1;
#endif
                                    LogFileIF_show_decimal_uint(LOG_DEBUG, "RX_SQ_SENDING_PAGE page", messageData->data.rx_sq_sending_page.page); 
								}
								break;
					
							case RX_SQ_PAGE_SENT:
								{
									messageDataBlock *sendMessage;
					
									transmit_document->SendCount += 1;
#if 1
      								purge_directory(transmit_document->Directory, transmit_document->SendCount, transmit_document->SendCount);	/* use purge_directory to delete one file! */
#endif
									/* poke animation */
								    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_PAGE_SENT, &sendMessage);
								    sendMessage->data.sq_sc_page_sent.pid = transmit_document->ProcessId;
								    sendMessage->data.sq_sc_page_sent.pagesSent = transmit_document->SendCount;
								    
								    LogFileIF_show_decimal_uint(LOG_DEBUG, "RX_SQ_PAGE_SENT page", messageData->data.rx_sq_page_sent.page);
								    LogFileIF_show_decimal_uint(LOG_DEBUG, "           SendCount", transmit_document->SendCount);

                                    Log_TxConnectedSentData(RouteDIRECT, &(transmit_document->Connection));
								}
								break;
					
							case RX_SQ_DOCUMENT_SENT:
								{
									messageDataBlock *sendMessage;
#if 0
							        purge_directory(transmit_document->Directory, 1, transmit_document->ScanCount); /*>>>should this be done by the queue scanner*/
#endif
								    /* poke animation */
								    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DOCUMENT_SENT, &sendMessage);
								    sendMessage->data.sq_sc_document_sent.pid = transmit_document->ProcessId;
								    sendMessage->data.sq_sc_document_sent.pagesSent = transmit_document->SendCount;

                                    /*REPORT: PagesSent & status*/ 
									Log_TxSentDocument(RouteDIRECT, transmit_document);	/* log transmission of document */
#if 1 /* PAN-01708 & PAN-0xxxx */
                                    /* Part of fix for PAN-01708 (T-FAX) & PAN-0xxxx (Daytona equivalant) */
                                    transmit_document->RequestTx = FALSE;   /* if still scanning, don't redial until scan completes or HWM hit again */
#endif
								    transmit_document->SendState = SendCOMPLETE;	/* complete (3) */
								    transmit_document = NULL;	/* this handler no longer needs to reference this document */
#if 0
						NAN_document = NULL;
#endif
					            }
								break;

							/* Error: after connection */
							case RX_SQ_ERROR:
#if SUPPORT_UI		        
								Screen_ReportError(RX_SQ_SC_ERROR, "Title_RX_SQ_ERROR", messageData);
#else
								if(transmit_document->Connection.RetryCount>= *(transmit_document->Connection.RetryLimit)-1)
								    Fax_ReportError(REMOTE_ERROR,"Title_RX_SQ_ERROR", messageData,transmit_document->Directory,transmit_document->SendCount);
#endif
								/*REPORT: Error*/
								if (transmit_document)
									Log_TxConnectedErrorSendingDoc(RouteDIRECT, &(transmit_document->Connection), messageData, transmit_document);
								else
									Log_TxConnectedError(RouteDIRECT, messageData);	
								break;
#if /*THINK*/ 0
							case RX_SQ_MAYBE_VOICE:
								/* a fax error ERROR_T1_TIMEOUT before any data transfer */
								/* is probably means call answered by voice */
								/*>>>set a don't redial flag */ 
								break;
#endif
							case RX_SQ_GOING_IDLE:
								/* the send has just completed */
#if 0
                                /* N.B. transmit_document MUST NOT be used after RX_SQ_DOCUMENT_SENT has been processed */ 
                                if (transmit_document)
                                    Log_TxDisconnected(RouteDIRECT, &(transmit_document->Connection);

#endif
	                    		nextstate = txIDLE;
								break;
						}
						break;
#if SUPPORT_EMAIL
					case txISPCONNECTING:
	                    switch (messageNumber)
						{
							case RX_SQ_DIAL_REJECTED:	/* not idle (incoming call) NOT counted as a failed dial attempt */
								nextstate = txIDLE;     /* Don't look for RX_SQ_GOING_IDLE (ignoring the one case where it IS sent) */
								break;

#if 0
							case RX_SQ_FAILED:
								nextstate = txIDLE;	/*>>>wait for GOING_IDLE???*/
								break;
#endif
							/* Error: unable to connect to ISP */
							case RX_SQ_ERROR:
								Screen_ReportError(RX_SQ_SC_ERROR, "Title_RX_SQ_ERROR", messageData);
								Log_TxConnectingError(RouteISP, &isp_dialup.Connection[isp_dialup.using_now], messageData);
								isp_dialup.errors_before += 1;
								/* we may get more errors before RX_SQ_GOING_IDLE */
								break;

							case RX_SQ_GOING_IDLE:
								/* the send has just completed (ie there is was an error) */
								/* count a failed dialup, calculate when the next attempt should be */
								Log_TxConnectingFailed(RouteISP, &isp_dialup.Connection[isp_dialup.using_now]);
								isp_dialup.using_now = -1;    /* dormant */
								RemXfer_Lockout_Incoming = FALSE;   /* MUST clear any inhibit incoming call flags here */
	                    		nextstate = txIDLE;
								break;

                            case RX_SQ_CONNECTED:
					            Log_TxConnected(RouteISP, &isp_dialup.Connection[isp_dialup.using_now]);	/* log successful connection to ISP */
					            isp_dialup.use_next = -1;   /* if call fails now, reset retry counters, retry with first number */
					            RemXfer_Lockout_Incoming = FALSE;   /* MUST clear any inhibit incoming call flags here */
								nextstate = txISPCONNECTED;
								break;
						}
	                	break;

/*
 * now that we are connected, RemXfer, based on what we told it to do, will now either:
 *  1) Send documents then RX_SQ_GOING_IDLE
 *  2) Receive mail then RX_SQ_GOING_IDLE
 *  3) Send then receive then RX_SQ_GOING_IDLE
 */
					case txISPCONNECTED:
						switch (messageNumber)
						{
							case RX_SQ_SENDING_DOCUMENT:
								/* we send multiple documents per connection, allow animation to show each recipient as emails go out */
								transmit_document = document_from_pid(messageData->data.rx_sq_sending_document.pid);
								if (transmit_document)
								{
                                    transmit_document->SendState = SendRUNNING; 	/* in progress (2) */
                                    transmit_document->ResumeTx  = TRUE;            /* we clear RequestTx on RX_SQ_DOCUMENT_SENT, so ensure that */
                                                                                    /* the tail end of a document that streams gets sent */ 
								    Log_TxSendDocument(RouteISP, transmit_document);

									/* start screen animations for email sending */
									show_Sending(transmit_document);

								    hardcopy_new_document(transmit_document);	/* may need to print (enote or eform) */
					            }
								break;
					
							case RX_SQ_SENDING_PAGE_RANGE:
							    /* poke animation */
								StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_EMAIL, NULL);
								break;
					
							case RX_SQ_PAGE_RANGE_SENT:
								transmit_document->SendCount += messageData->data.page_range_sent.hiPage - messageData->data.page_range_sent.loPage + 1;

								/* if HardCopyRequired (and document creation was successful) move the sent pages into the PrintQ */
                                hardcopy_pages_complete(transmit_document, messageData->data.page_range_sent.loPage, messageData->data.page_range_sent.hiPage);
#if 1
								/* delete pages that failed to move/delete the lot if HardCopy not required */
								purge_directory(transmit_document->Directory, messageData->data.page_range_sent.loPage, messageData->data.page_range_sent.hiPage);
#endif
                                Log_TxConnectedSentData(RouteISP, &isp_dialup.Connection[isp_dialup.using_now]);
								break;

							case RX_SQ_DOCUMENT_SENT:
								{
									messageDataBlock *sendMessage;

									hardcopy_document_complete(transmit_document);	/* can now be printed */
#if 0
							        purge_directory(transmit_document->Directory, 1, transmit_document->ScanCount); /*>>>should this be done by the queue scanner*/
#endif
								    /* poke animation */
								    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DOCUMENT_SENT, &sendMessage);
								    sendMessage->data.sq_sc_document_sent.pid = transmit_document->ProcessId;
								    sendMessage->data.sq_sc_document_sent.pagesSent = transmit_document->SendCount;

									Log_TxSentDocument(RouteISP, transmit_document);
#if 1 /* PAN-0yyyy email version of PAN-01708 & PAN-0xxxx */
                                    /* fix PAN-0yyyy */
                                    transmit_document->RequestTx = FALSE;   /* if still scanning, don't redial until scan completes or HWM hit again */
#endif
								    transmit_document->SendState = SendCOMPLETE;	/* complete (3) */
								    transmit_document = NULL;	/* this handler no longer needs to reference this document */
#if 0
						NAN_document = NULL;
#endif
									/* we clear the isp_dialup_watermark_reached flag each time a document is sent */
									/* it may be set again by the QueueWalker if later documents require it */
									/* this means that if the line drops, we only re-dial if the QueueWalker has set the flag again */
									isp_dialup_watermark_reached = FALSE;
					            }
								break;

							case RX_SQ_ERROR:
								/* error may apply to transmit_document or the isp connection */
#if 0
								/* this tells us that we should re-dial (upto 3 times) to complete the transfer */
								isp_dial.error after connection = TRUE;
#endif
								Screen_ReportError(RX_SQ_SC_ERROR, "Title_RX_SQ_ERROR", messageData);
								if (transmit_document)
									Log_TxConnectedErrorSendingDoc(RouteISP, &isp_dialup.Connection[isp_dialup.using_now], messageData, transmit_document);
								else
									Log_TxConnectedError(RouteISP, messageData);
								break;

							case RX_SQ_GOING_IDLE:
								/* the send (if any) and retrieve (if any) has just completed */
	                    		nextstate = txIDLE;
								Log_TxDisconnected(RouteISP, &isp_dialup.Connection[isp_dialup.using_now]);
								isp_dialup.using_now = -1; /* dormant */
								break;

                        }
						break;
#endif
				} /* switch (tx_state) */

			    /* if going idle from a non-idle state */
				if ((nextstate == txIDLE) && (tx_state != txIDLE))
				{
				    /* loop over the SendQ clearing any document->SendState that isn't SendCOMPLETE back to SendIDLE */
				    SendQ_ClearDownSendState();
#if 0
                    /* report SQ_xx_GOING_IDLE if going idle from a non-idle state */
					StateKicker_SendMessage(Xxxx_MessageHandler, SQ_xx_GOING_IDLE, NULL);
#endif
				}
				tx_state = nextstate;
            }
/* end of transmitting */
#endif
			break;	/* if TRANSMITTING is FALSE, GOING_IDLE still has a break; */

#if TRANSMITTING
        case RX_SQ_WHICH_DOCUMENT:	/* implies that we have connected */
        	{
        		if (transmit_document)
				{
					messageDataBlock *sendMessage;

                    /* MUST change SendState from SendIDLE because setting Cancelled will delete the document */
                    transmit_document->SendState = SendRUNNING; /*SendCONNECTING*/

					StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_THIS_DOCUMENT, &sendMessage);
					sendMessage->data.this_document.pid = transmit_document->ProcessId;
					sendMessage->data.this_document.loText = 1;
					sendMessage->data.this_document.hiText = 0;
					sendMessage->data.this_document.loPage = transmit_document->SendCount + 1;
					sendMessage->data.this_document.hiPage = transmit_document->ScanCount;
					sendMessage->data.this_document.pageStream = (BOOL)(transmit_document->ScanState != ScanCOMPLETE);
					strcpy(sendMessage->data.this_document.directory, transmit_document->Directory);
                }
            }
            break;

#if SUPPORT_EMAIL
		case ME_SQ_WHICH_DOCUMENT:
			{
				encoding_document = transmit_document;
				if (transmit_document)
				{
					messageDataBlock *sendMessage;

                    /* MUST change SendState from SendIDLE because setting Cancelled will delete the document */
                    transmit_document->SendState = SendRUNNING; /*SendENCODING*/

			    	/* send document ProcessId & directory */
			    	StateKicker_SendMessage(MimeEncode_StateMachine, SQ_ME_THIS_DOCUMENT, &sendMessage);
			    	sendMessage->data.this_document.pid = transmit_document->ProcessId;
			    	sendMessage->data.this_document.loText = 1;
			    	sendMessage->data.this_document.hiText = 0;
			    	sendMessage->data.this_document.loPage = transmit_document->SendCount + 1;
			    	sendMessage->data.this_document.hiPage = transmit_document->ScanCount;
			    	sendMessage->data.this_document.pageStream = (BOOL)(transmit_document->ScanState != ScanCOMPLETE);
					strcpy(sendMessage->data.this_document.directory, transmit_document->Directory);
				}
				else
					StateKicker_SendMessage(MimeEncode_StateMachine, SQ_ME_NO_NORE_DOCUMENTS, NULL);
  	      	}
			break;

		case ME_SQ_NEXT_DOCUMENT:
			{
				encoding_document = next_email(encoding_document);
				if (encoding_document)
				{
					messageDataBlock *sendMessage;

                    /* MUST change SendState from SendIDLE because setting Cancelled will delete the document */
                    encoding_document->SendState = SendRUNNING; /*SendENCODING;*/

			    	/* send document ProcessId & directory */
			    	StateKicker_SendMessage(MimeEncode_StateMachine, SQ_ME_THIS_DOCUMENT, &sendMessage);
			    	sendMessage->data.this_document.pid = encoding_document->ProcessId;
			    	sendMessage->data.this_document.loText = 1;
			    	sendMessage->data.this_document.hiText = 0;
			    	sendMessage->data.this_document.loPage = encoding_document->SendCount + 1;
			    	sendMessage->data.this_document.hiPage = encoding_document->ScanCount;
			    	sendMessage->data.this_document.pageStream = (BOOL)(encoding_document->ScanState != ScanCOMPLETE);
					strcpy(sendMessage->data.this_document.directory, encoding_document->Directory);
				}
				else
					StateKicker_SendMessage(MimeEncode_StateMachine, SQ_ME_NO_NORE_DOCUMENTS, NULL);
			}
			break;
			
        case ME_SQ_ERROR:
            {
                Screen_ReportError(ME_SQ_SC_ERROR, "Title_RX_SQ_ERROR", messageData);   /*>>>> Title_ME_SQ_ERROR ??? */
                if (encoding_document)
                    Log_TxEncodingError(RouteISP, messageData, encoding_document);
            }
            break;
#endif
#endif
#if TEXTUAL_EMAIL
		case EC_SQ_NEW_DOCUMENT:
			switch (HWM_Check())
			{
				case 3:
			    case 4:
				case 2:
				case 1:
					if (SendQ_CreateDocument(&text_document) != NULL)
						status = OS_Error;
					break;

			}
			if (status == OK)
			{
				text_document->ScanState = ScanRUNNING;	/* in progress */
				/* tell EmailCreate where to put the document text */
				StateKicker_SendMessage(EmailCreate_StateMachine, SQ_EC_DOCUMENT_DIR, &sendMessage);
				sendMessage->data.new_document_dir.pid = text_document->ProcessId;
				strcpy(sendMessage->data.new_document_dir.directory, text_document->Directory);
			}
			else
				StateKicker_SendMessage(EmailCreate_StateMachine, SQ_EC_ABORT_INCOMING, NULL);	
			break;

		case EC_SQ_NEW_TEXT
			break;

		case EC_SQ_TEXT_COMPLETE:
			text_document->TextCount += 1;
			break;

		case EC_SQ_DOCUMENT_COMPLETE:
			text_document->ScanState = ScanCOMPLETE;
			text_document = NULL;	/* this handler no longer needs to reference this document */
			break;
#endif
	}
}


/*
 * The following procedures allow EnoteIF, LogFileIF and PrintQ (return receipt)
 * to add a new document to the SendQ.
 *
 *  SendQ_ExtIF_NewDocument      - create a new document (with email address and flags: hardcopy_required, request_receipt)
 *  SendQ_ExtIF_Subject          - add email subject field
 *  SendQ_ExtIF_FileComplete     - a page has been added to it
 *  SendQ_ExtIF_FileTake         - move given file into document
 *  SendQ_ExtIF_DocumentComplete - ready to send
 */

/*
 * Create a new document.
 *
 *   email address
 *   hardcopy_required - TRUE if document should be printed after being sent
 *                       N.B. When document transmission starts, a document is created in the PrintQ.
 *                            After each page is sent it is transfered to the document in the PrintQ.
 *                            When the transmission terminates, the document in the PrintQ is allowed to print.
 *                            If the transmission requires re-dials, the hardcopy will print as separate documents
 *                            reflecting the breaks in transmission.
 *
 * Returns: document pid (non-zero) and document directory name on success
 *
 * Returns: zero on failure
 */
extern unsigned int SendQ_ExtIF_NewDocument(char *p_directory, const char *email_realname, const char *email_address, BOOL hardcopy_required, BOOL request_receipt)
{
    Document document;
	
	switch (HWM_Check())
	{
		case 3:
		case 4:
		case 2:
		case 1:
			if (SendQ_CreateDocument(&document) == NULL)
			{
				document->ScanState = ScanRUNNING;	/* in progress */

                /* email realname and address (if any) become ContactName and EmailAddress */
                if (email_realname)
                    strcpy(document->AddressRecord.ContactName, email_realname);

                if (email_address)
				    strcpy(document->AddressRecord.EmailAddress, email_address);

				document->SendRoute = RouteISP;
				document->AddressRecord.SearchFlags = document->AddressRecord.OneShotFlags = 0;
                document->HardCopyRequired = hardcopy_required;
                /*document->HardCopyProcessID = 0; will be already*/
                document->RequestReceipt   = request_receipt;

				strcpy(p_directory, document->Directory);
				return(document->ProcessId);	/* created a new document and passed directory name to caller */
			}
			break;
	}

	return(0);	/* in-sufficient memory */
}


extern void SendQ_ExtIF_Subject(unsigned int pid, const char *email_subject)
{
	Document document;

	if ((document = document_from_pid(pid)) != NULL)
	{
		strcpy(document->EmailSubject, email_subject);
	}
}


extern void SendQ_ExtIF_FileComplete(unsigned int pid, const char *leafname, PageClasses pageClass, PageTypes pageType, int fileType)
{
	Document document;

	if ((document = document_from_pid(pid)) != NULL)
	{
		renameDLN(document->Directory, leafname, document->ScanCount + 1);
		QuCommon_Page_Complete(document, document->ScanCount + 1, pageClass, pageType, fileType);
	}
}


extern void SendQ_ExtIF_FileTake(unsigned int destination_pid, const char *source_directory, const char *source_leafname, PageClasses pageClass, PageTypes pageType, int fileType)
{
	Document document;

	if ((document = document_from_pid(destination_pid)) != NULL)
	{
		renameDLDN(source_directory, source_leafname, document->Directory, document->ScanCount + 1);
		QuCommon_Page_Complete(document, document->ScanCount + 1, pageClass, pageType, fileType);
	}
}


/*
 *
 */
extern void SendQ_ExtIF_DocumentComplete(unsigned int pid, BOOL request_tx)
{
	Document document;

	if ((document = document_from_pid(pid)) != NULL)
	{
		document->ScanState = ScanCOMPLETE;

        /* No valid To: field, so quietly chuck it on the floor */
        /* Our caller should do a similar check and report the error if it wishes too */
        if (document->AddressRecord.EmailAddress[0] == '\0')
            document->Cancelled = TRUE;

        if (request_tx)
        {
            document->RequestTx = 1;				/* requesting */
        }
	}
}


#if DAYTONA
/*
 * Routines to allow SendQ to add a document, page by page to the PrintQ.
 * This allows enotes and eforms to be printed after being sent.
 *
 * The routines are a thin veneer onto PrintQ_ExtIF_NewDocument and
 * PrintQ_ExtIF_DocumentComplete.
 *
 * hardcopy_new_document      - create a document in the PrintQ
 * hardcopy_pages_complete    - move a range of pages into it
 * hardcopy_document_complete - complete and ready to print
 *
 */

static void hardcopy_new_document(Document document)
{
#if HARDCOPY_FINISHED
	char directory[256];

    if (document->HardCopyRequired)
		document->HardCopyProcessID = PrintQ_ExtIF_NewDocument(directory);	/* returns 0 on failure and non-zero PId on success */
#endif	
}


static void hardcopy_pages_complete(Document document, unsigned int loPage, unsigned int hiPage)
{
#if HARDCOPY_FINISHED
/*	_kernel_oserror *error = NULL;*/
	
	if (document->HardCopyProcessID)
	{
		unsigned int i;
		
		for (i=loPage; i<=hiPage; i++)
		{
			PageClasses pageClass;
			PageTypes pageType;
			int fileType;
			
			QuCommon_GetClassAndType(document, i, &pageClass, &pageType, &fileType);
#if 1 /* PAN-01530 */
            /* Fix PAN-01530, prefix first page of enote with destination and subject details */
            if ((i == 1) && (pageType == PageType_Text_ENote))
                PrintQ_ExtIF_FilePrefix(document->HardCopyProcessID, document->Directory, i, pageClass, pageType, fileType,
                                        document->AddressRecord.ContactName, document->AddressRecord.EmailAddress, document->EmailSubject);
            else                            
#endif
			/*>>>error =*/ PrintQ_ExtIF_FileTake(document->HardCopyProcessID, document->Directory, i, pageClass, pageType, fileType);
        }
	}
#endif	
}


static void hardcopy_document_complete(Document document)
{
#if HARDCOPY_FINISHED
	if (document->HardCopyProcessID)
		PrintQ_ExtIF_DocumentComplete(document->HardCopyProcessID);

	document->HardCopyProcessID = 0;	/* finished with this PrintQ document */
#endif	
}
#endif

#if SUPPORT_UI
static void unable_to_deliver(Document document)
{
    unsigned int pid;
    char directory[256];

    if ((pid = PrintQ_ExtIF_NewDocument(directory)) != 0)
    {
        char show_number[64];
        unsigned int loPage;
			PageClasses pageClass;
			PageTypes pageType;
			int fileType;

        show_number[0] = '\0';

#if SUPPORT_ADDRESSBOOK
        if (document->AddressRecord.DirectPhoneNumber[0] != '\0')
            numconvert_internal_to_display(document->AddressRecord.DirectPhoneNumber,	/* internal format */
										   show_number,
										   sizeof(show_number),
										   setup_international_access_code,	    /* ip:	International prefix, eg "00" */
										   setup_national_access_code,      	/* np:	National prefix, e.g. "0" */
										   setup_fax_country_code,              /* cc:	Country code, e.g. "44" */
										   setup_fax_area_code                  /* ac:	Area code, e.g. "1223" */
										  );

#endif

        PrintQ_ExtIF_ErrorPage(pid, show_number, document->AddressRecord.ContactName, document->AddressRecord.EmailAddress, document->EmailSubject);


        loPage = document->SendCount + 1;

        QuCommon_GetClassAndType(document, loPage, &pageClass, &pageType, &fileType);
        PrintQ_ExtIF_FileTake(pid, document->Directory, loPage, pageClass, pageType, fileType);

        PrintQ_ExtIF_DocumentComplete(pid);
    }
}
#endif
#if SUPPORT_ADDRESSBOOK
/*
 * show the ContactName produced by the address book search
 */
static void show_ContactName(Document document)
{
	messageDataBlock *sendMessage;

	/* tell Screen who the fax is for */
    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_CONTACTNAME, &sendMessage);
    sendMessage->data.sq_sc_contactname.pid = document->ProcessId;
    strcpy(sendMessage->data.sq_sc_contactname.ContactName, document->AddressRecord.ContactName);
}
#endif

/*
 * show the route number/address produced by the address book search
 */
static void show_SendRoute(Document document)	/* display debugging/user info */
{
#if SUPPORT_ADDRESSBOOK  
	messageDataBlock *sendMessage;
	
	switch (document->SendRoute)
	{
		case RouteDIRECT:
    		/* tell Screen the phone number */
    		StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DISPLAYNUMBER, &sendMessage);
   		 	sendMessage->data.sq_sc_displaynumber.pid = document->ProcessId;
#if SUPPORT_UI
            numconvert_internal_to_display(document->AddressRecord.DirectPhoneNumber,	/* internal format */
                                           sendMessage->data.sq_sc_displaynumber.DirectPhoneNumber,
                                           sizeof(sendMessage->data.sq_sc_displaynumber.DirectPhoneNumber),
                                           setup_international_access_code,     /* ip:	International prefix, eg "00" */
										   setup_national_access_code,      	/* np:	National prefix, e.g. "0" */
										   setup_fax_country_code,              /* cc:	Country code, e.g. "44" */
										   setup_fax_area_code                  /* ac:	Area code, e.g. "1223" */
										  );
#else
    		strcpy(sendMessage->data.sq_sc_displaynumber.DirectPhoneNumber, document->AddressRecord.DirectPhoneNumber);
#endif
			break;

		case RouteISP:
    		/* tell Screen the email address */
    		StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DISPLAYEMAIL, &sendMessage);
    		sendMessage->data.sq_sc_displayemail.pid = document->ProcessId;
    		strcpy(sendMessage->data.sq_sc_displayemail.EmailAddress, document->AddressRecord.EmailAddress);    
			break;
	}
#endif	
}

/*
 * show start of document transmission
 */
static void show_Sending(Document document)
{
#if SUPPORT_UI  
	messageDataBlock *sendMessage;
	
	StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_DOCUMENT, &sendMessage);
    sendMessage->data.sending_document.pid = document->ProcessId;
    strcpy(sendMessage->data.sending_document.ContactName, document->AddressRecord.ContactName);

	if (sendMessage->data.sending_document.ContactName[0] == '\0')
    {
    	/* ContactName field is empty, so display phone number or email address instead */

		switch (document->SendRoute)
		{
        	case RouteDIRECT:
#if 1
                /* Bug fix: RCM 1998/03/17 */
                /* leave blank, screen displays number passed with SQ_SC_CONTEXT_DIRECT for us */
#else
                /* screen displays 'Fax to 12345 on 12345' */
#if 1
                numconvert_internal_to_display(document->AddressRecord.DirectPhoneNumber,   /* internal format */
                                               sendMessage->data.sending_document.ContactName,
                                               sizeof(sendMessage->data.sending_document.ContactName),
                                               setup_international_access_code,     /* ip:	International prefix, eg "00" */
										       setup_national_access_code,      	/* np:	National prefix, e.g. "0" */
										       setup_fax_country_code,              /* cc:	Country code, e.g. "44" */
										       setup_fax_area_code                  /* ac:	Area code, e.g. "1223" */
										      );
#else
        		strcpy(sendMessage->data.sending_document.ContactName, document->AddressRecord.DirectPhoneNumber);
#endif
#endif
        		break;

            case RouteISP:
                /* ContactName field is empty, so display email address instead */
            	strcpy(sendMessage->data.sending_document.ContactName, document->AddressRecord.EmailAddress);
            	break;
            	
          /*default: string is "" */
        }
    }
#endif    
}


#if SUPPORT_UI
/*
 * Accumulate scanning errors, for LogFile error reporting
 */

static void Log_RxConnectingError(messageDataBlock *messageData)
{
	char buffer[256];

    strcpy(buffer, "Connecting error: ");
    strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));

    LogFileIF_Message(buffer);
}


static void Log_RxConnectedError(messageDataBlock *messageData)
{
	char buffer[256];

    strcpy(buffer, "Scanning error: ");
    strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));

    LogFileIF_Message(buffer);
}
#endif


/*
 * Accumulate call statistics, for LogFile and error reporting
 */

static char log_tx_display_number[SIZEOF_NUMBER_TO_DISPLAY /*30*/] = { 0 };
static int  log_tx_error_count = 0;
static int  log_tx_dataXfer = 0;


/*
 * Capture time when dialup started
 */

static void Log_TxConnecting(enum _SendRoute route, PhoneConnection *connection, const char *dial_number)
{
	char buffer[256];

	time_t now = time(NULL);

	connection->TimeDial    = now;
    connection->TimeConnect = now;
    connection->TimeEnd     = now;

    connection->RedialDelay = 30;   /* a sensible default, may be changed depending on the nature of the error */

	strcpy(log_tx_display_number, dial_number);
	log_tx_error_count = 0;
    log_tx_dataXfer = 0;

	if (route == RouteISP)
	{
        /* we clear all the 'dial now' flags, setting a redial later flag incase the dial fails */
        /* if the dial fails, a redial will occur sometime later, or immediately if one of the  */
        /* 'dial now' flags is set again */
        if (isp_dialup_timer_request || isp_dialup_user_request || isp_dialup_download_request)
            isp_dialup_redial_needed = TRUE;

		isp_dialup_timer_request = FALSE;
	    isp_dialup_user_request = FALSE;
        isp_dialup_download_request = FALSE;

        /* log the connection attempt */
		strcpy(buffer, "Dialling ISP on ");
		strncat(buffer, dial_number, sizeof(buffer));

		LogFileIF_Message(buffer);
	}
}

#if SUPPORT_UI
/*
 * Capture the first error that occurs prior to connection
 */
static void Log_TxConnectingError(enum _SendRoute route, PhoneConnection *connection, messageDataBlock *messageData)
{
	char buffer[256];
	/* There should be one error report, followed by our going idle */
    /* if multiple errors arrive, we capture the first only */
	if (log_tx_error_count == 0)
	{
		if (route == RouteDIRECT)
		{
        	strcpy(buffer, "S ");
			strncat(buffer, log_tx_display_number, sizeof(buffer));

			strncat(buffer, " Error connecting ", sizeof(buffer));
			strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));
        }
        else
        {
			/* ISP phone number already reported */
			
			strcpy(buffer, "Error connecting ");
			strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));        
        }

		LogFileIF_Message(buffer);
	}

    /* set a RedialDelay dependent on the error */
    switch (messageData->data.error.code)
    {
        case code_NoDialTone:
            connection->RedialDelay = FIVE_MINUTES;
            LogFileIF_show_decimal_uint(LOG_DEBUG, "No dial tone, seconds to retry", connection->RedialDelay);
            break;

        case code_LineBusy:
            if (connection->RetryCount == 0)
                connection->RedialDelay = 30;
            else
                connection->RedialDelay = FIVE_MINUTES;

            LogFileIF_show_decimal_uint(LOG_DEBUG, "Line busy, seconds to retry", connection->RedialDelay);    
            break;
            
#if 1 /*PAN-01727*/
        case code_PPP_Connection_Error:
            connection->RedialDelay = FIVE_MINUTES;
            LogFileIF_show_decimal_uint(LOG_DEBUG, "PPP connection error, seconds to retry", connection->RedialDelay);
            break;
#endif
    }

	log_tx_error_count++;	
}
#endif


/*
 * Report the failure to connect and the reason
 *
 * Also performs RetryCount-ing operations for the redial logic
 * used by QueueWalker.
 */
static void Log_TxConnectingFailed(enum _SendRoute route, PhoneConnection *connection)
{
	char buffer[256];

	time_t now = time(NULL);

	connection->TimeConnect = now;	/* } ie zero connection time */
	connection->TimeEnd     = now;  /* }                         */

	connection->RetryCount += 1;	/* count the dial attempt */	
    connection->RetryTime   = now + connection->RedialDelay;    /* usually THIRTY_SCEONDS or FIVE_MINUTES */

	if (route == RouteISP)
	{
        /* if any of the 'dial now' flags were set after dialling started, turn them into dial later request */
        /* the redial will occur sometime later, or immediately if one of the 'dial now' flags is set again */
        if (isp_dialup_timer_request || isp_dialup_user_request || isp_dialup_download_request)
            isp_dialup_redial_needed = TRUE;
            
		isp_dialup_timer_request = FALSE;
	    isp_dialup_user_request = FALSE;
	    isp_dialup_download_request = FALSE;
	}

	/*>>>Report the failure to the screen and LogFile */
	/* Fax call to <number> failed <reason> */
    /* ISP dialup on <number> failed <reason> */

	if (log_tx_error_count == 0)
	{
		if (route == RouteDIRECT)
		{
        	strcpy(buffer, "S ");
			strncat(buffer, log_tx_display_number, sizeof(buffer));

			strncat(buffer, " Error connecting", sizeof(buffer));	/* !!! RX_SQ_GOING_IDLE received, but no error logged !!! */
		}
    	else
		{
			/* ISP phone number already reported */

			strcpy(buffer, "Error connecting");	/* !!! RX_SQ_GOING_IDLE received, but no error logged !!! */
		}

        LogFileIF_Message(buffer);
        log_tx_error_count++;
	}
}


/*
 * ISP dialups generate multiline reports, report the successful connection
 */

static void Log_TxConnected(enum _SendRoute route, PhoneConnection *connection)
{
	time_t now = time(NULL);

	connection->TimeConnect = now;
	connection->TimeEnd     = now;
#if 0 /*PAN-01727*/ /*think about this - delay dangerous when trying to do a streaming send */
    connection->RedialDelay = 30; /*FIVE_MINUTES;*/
    connection->RetryTime   = time(NULL) + connection->RedialDelay;
#endif
	log_tx_error_count = 0;	/* unlikely not to be zero */

	if (route == RouteISP)
	{
#if 1
   /*>>>*/         /* this should only be cleared when the download has finished */
			isp_dialup_redial_needed = FALSE;
#endif                            



		/*>>>Report connection to ISP*/
		/*REPORT <connection->TimeConnect> Connected to ISP*/
	    LogFileIF_show(LOG_VERBOSE, "Connected OK");
	}
}


static void Log_TxConnectedSentData(enum _SendRoute route, PhoneConnection *connection)
{
    log_tx_dataXfer = 1;    
}

static void strncat_recipient(char *buffer, enum _SendRoute route, Document document, int bufsize)
{
    if (document->AddressRecord.ContactName[0] != '\0')
    {
        strncat(buffer, document->AddressRecord.ContactName, bufsize);
        strncat(buffer, " ", bufsize);
    }

    if (route == RouteDIRECT)
    {
        strncat(buffer, "(", bufsize);    
		strncat(buffer, log_tx_display_number, bufsize);
		strncat(buffer, ")", bufsize);
    }
    else
    {
        strncat(buffer, "(", bufsize);
		strncat(buffer, document->AddressRecord.EmailAddress, bufsize);
		strncat(buffer, ")", bufsize);    
    }
}


static void strncat_time(char *buffer, time_t seconds, int bufsize)
{
    char convert[256];

    if (seconds < 60)
        sprintf(convert, "%ds", seconds);
    else
    {
        int minutes = seconds / 60;
        seconds = seconds % 60;

        if (minutes < 60)
            sprintf(convert, "%dm%2ds", minutes, seconds);
        else
        {
            int hours = minutes / 60;
            minutes = minutes % 60;

            sprintf(convert, "%dh%2dm%2ds", hours, minutes, seconds);
        }
    }

    strncat(buffer, convert, bufsize);
}


static void strncat_page_count(char *buffer, int page_count, int bufsize)
{
    char numbuff[128];

    sprintf(numbuff, "%d page(s)", page_count);
    strncat(buffer, numbuff, bufsize);
}


static void Log_TxConnectedErrorSendingDoc(enum _SendRoute route, PhoneConnection *connection, messageDataBlock *messageData, Document document)
{
	char buffer[256];

	if (log_tx_error_count == 0)
	{
		strcpy(buffer, "S ");

        strncat_recipient(buffer, route, document, 128);

		strncat(buffer, " Error ", sizeof(buffer));
		strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));

#if SUPPORT_EMAIL
        if (route == RouteISP)
        {
            document->SMTPSendFailures++;

#if 1 /*PAN-01727*/
      /* when the fault report came back again, I released this CANNOT work, because we've connected, */
      /* which resets various retry counters - see state txISPCONNECTED, message RX_SQ_CONNECTED      */
            connection->RedialDelay = FIVE_MINUTES;
            connection->RetryTime   = time(NULL) + connection->RedialDelay;
#endif
        }    
#endif

        LogFileIF_Message(buffer);
    }

	log_tx_error_count++;
}


static void Log_TxConnectedError(enum _SendRoute route, messageDataBlock *messageData)
{
	char buffer[256];

	if (log_tx_error_count == 0)
	{
		if (route == RouteDIRECT)
		{
        	strcpy(buffer, "S ");
			strncat(buffer, log_tx_display_number, 128);

			strncat(buffer, " Error ", sizeof(buffer));
			strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));
		}
        else
        {
        	strcpy(buffer, "S ");
			strncat(buffer, " Error ", sizeof(buffer));
			strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));        	
        }

        LogFileIF_Message(buffer);
    }

	log_tx_error_count++;
}

#if SUPPORT_UI
static void Log_TxSendDocument(enum _SendRoute route, Document document)
{
    if (route == RouteISP)
    {
        time_t now = time(NULL);

        document->Connection.TimeDial    = isp_dialup.Connection[isp_dialup.using_now].TimeDial;  /* do we care? */
        document->Connection.TimeConnect = now;
        document->Connection.TimeEnd     = now;
    }
}
#endif

static void Log_TxSentDocument(enum _SendRoute route, Document document)
{
	char buffer[256];

	if (log_tx_error_count == 0)
	{
	    time_t now = time(NULL);

        document->Connection.TimeEnd = now;

        strcpy(buffer, "S ");
        strncat_recipient(buffer, route, document, 128);
        strncat(buffer, " ", sizeof(buffer));
        strncat_page_count(buffer, document->SendCount, sizeof(buffer));

        strncat(buffer, " ", sizeof(buffer));
        strncat_time(buffer, document->Connection.TimeEnd - document->Connection.TimeConnect, sizeof(buffer));
        /* above relies on Log_TxSendDocument() setting Connection.TimeConnect to: */
        /*   a (RouteDIRECT) - to time that a connection is established         OR */
        /*   b (RouteISP)    - to time that transmission of this document started  */

		strncat(buffer, " OK", sizeof(buffer));

		LogFileIF_Message(buffer);        			
	}
#if 0
	/* switch in when HANGUP followed by immediate dial failure is fixed */
	connection->RetryTime   = time(NULL) + 30;	/*now() + something(connection->RetryCount);*/	
#endif
    if (route == RouteDIRECT)
    {
        /* if trying to send data, but non went, count the connection as bad */
        if (log_tx_dataXfer == 0)
            document->Connection.BadConnection++;
    }
}

#if SUPPORT_EMAIL
static void Log_TxDisconnected(enum _SendRoute route, PhoneConnection *connection)
{
	time_t now = time(NULL);

	connection->TimeEnd = now;

    if (route == RouteISP)
    {
        char buffer[256];
        
        isp_dialup_timer_request = FALSE;   /* timer and user requests to dial the ISP received  */
        isp_dialup_user_request = FALSE;    /* during a connection to the ISP are ignored        */
      /*NB leave isp_dialup_download_request alone, it must be allowed to trigger a dial if set */  
      /*isp_dialup_redial_needed = FALSE;*/

        strcpy(buffer, "Disconnected from ISP OK");
        strncat(buffer, " ", sizeof(buffer));
        strncat_time(buffer, connection->TimeEnd - connection->TimeConnect, sizeof(buffer));

        LogFileIF_Message(buffer);

        /* if trying to send data, but non went, count the connection as bad */
        if ((log_tx_dataXfer == 0) && (log_tx_error_count != 0))
            connection->BadConnection++;
    }
}
#endif
#if SUPPORT_EMAIL
static void Log_TxEncodingError(enum _SendRoute route, messageDataBlock *messageData, Document document)
{
	char buffer[256];

    strcpy(buffer, "S ");

    strncat_recipient(buffer, route, document, 128);

	strncat(buffer, " Error ", sizeof(buffer));
	strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));

    if (route == RouteISP)
        document->MimeEncodeFailures++;

    LogFileIF_Message(buffer);
}
#endif
#if SUPPORT_UI
/*
 * Log - unable to deliver by given route, trying another
 *
 * route is one that failed, so user is shown it and could check details
 */
static void Log_TxReRouting(enum _SendRoute route, Document document)
{
    char buffer[256];
    
    strcpy(buffer, "S Re-routing ");

    /* show failed route NOT new route */
    strncat_recipient(buffer, route, document, 128);

    LogFileIF_Message(buffer);
}

/*
 * Log - unable to deliver message
 *
 * route is last one tried
 */
static void Log_TxUnableToDeliver(enum _SendRoute route, Document document)
{
    char buffer[256];

    strcpy(buffer, "S UNABLE TO DELIVER ");

    /* show last route (or only route) tried */
    strncat_recipient(buffer, route, document, 128);

    LogFileIF_Message(buffer);
}
#endif

static BOOL connection_impossible(enum _SendRoute route, PhoneConnection *connection)
{
	/* NB we require SetupIF to ensure (*connection->RetryLimit) >= 1 for setup_phone_fax_redial_count */
	if (connection->RetryCount >= (*connection->RetryLimit))
		return(TRUE);	/* exhausted our dial-up limit and still not got through! */

    if (connection->BadConnection >= 3)
        return(TRUE);   /* we can connect, but no data transfer happens */

    return(FALSE);
}


static BOOL connection_requested_now(enum _SendRoute route, PhoneConnection *connection)
{
	if (connection->RetryTime <= time(NULL))
		return(TRUE);

	return(FALSE);
}


/* we assign a unique document number to everything we send */
static unsigned int UniqueDocNo(void)
{
	static unsigned int doc_num = 0;	/* not a valid document number */

#if SUPPORT_EMAIL
    static unsigned int saver = 0;

    /* on first call, retrieve value from EEPROM */
    if (doc_num == 0)
    {
        /* to save EEPROM wear, we write every 100 counts, so..           */
        /* 0..99 documents could have been sent before the power went off */
        SetupIF_Read_EEPROM_Word(EEPROM_DOC_NUM, &doc_num);
        doc_num += 100;                                     /* so increment EEPROM value by 100 now */
        SetupIF_Write_EEPROM_Word(EEPROM_DOC_NUM, doc_num);
    }

    ++doc_num;
    ++saver;

    /* if counter wraps! */
    if (doc_num == 0)
    {
        /* don't leave doc_num on zero, or next call assumes a power cycle */
        ++doc_num;  /* also never return zero */
        ++saver;
    }

    if (saver >= 100)
    {
        /* only write every 100 counts, to save EEPROM wear */
        SetupIF_Write_EEPROM_Word(EEPROM_DOC_NUM, doc_num);
        saver = 0;
    }
#else
	/* assign a unique document number to everything we send */
	++doc_num;
	if (doc_num == 0)
		doc_num = 1;		/* never allocate zero, even if we wrap! */
#endif
    return(doc_num);
}

static Document SendQ_Document_Queue = NULL;

static _kernel_oserror *SendQ_CreateDocument(Document *p_document)
{
	static unsigned int dir_num = 0;

	_kernel_oserror    *error = NULL;
	Document 			document = NULL;
	char    			directory[212];

	*p_document = NULL;		/* in case we return an error */	

	/* be tidy, zero the directory name whenever the queue empties */
	if (SendQ_Document_Queue == NULL)
		dir_num = 0;

	document = malloc(sizeof(DocumentRec));
    if (document)
    {
        memset(document, 0, sizeof(DocumentRec));   /* zero initialise whole block */

    	sprintf(directory, "%s.%d", DIRECTORY_SENDQ, dir_num);
        dir_num++;

        if ((error = os_create_directory(directory)) != NULL)
        {
        	/* unable to create directory */
        	free(document);		/* free the document record we created */
        	return(error);		/* return the error */
        }
    }

	if (document)
	{
		/* created document record and a directory for the document - now fill the record */

    	document->ProcessId = UniquePId();		        /* non-zero, unique across both SendQ and PrintQ */
	    strcpy(document->Directory, directory);         /* fullname of the directory we created */

	    document->DocumentNo = UniqueDocNo();   		/* non-zero, unique to SendQ, no relation to ProcessId */
    	*document->CapturedPhoneNumber = '\0';          /* not yet captured from fax machine */
    	*document->AddressRecord.EmailAddress = '\0';   /* not yet returned by the address book */
#if 0
        /* at Chris Stott's request                  */
        /* 'Nax message'                             */
        /* 'Nax message from <contact>'              */
        /* 'Nax message from <company>'              */
        /* 'Nax message from <contact> of <company>' */
        strcpy(document->EmailSubject, "Nax message");
        if ((setup_contact_name[0] != 0) || (setup_company_name[0] != 0))
        {
            strncat(document->EmailSubject, " from ", sizeof(document->EmailSubject));

            if (setup_contact_name[0] != 0)
                strncat(document->EmailSubject, setup_contact_name, sizeof(document->EmailSubject));

            if ((setup_contact_name[0] != 0) && (setup_company_name[0] != 0))
                strncat(document->EmailSubject, " from ", sizeof(document->EmailSubject));

            if (setup_company_name[0] != 0)
                strncat(document->EmailSubject, setup_company_name, sizeof(document->EmailSubject));
        }
#else
    	strcpy(document->EmailSubject, "Fax from Daytona");	/* a good default */
#endif
    	*document->AddressRecord.DirectPhoneNumber   = '\0';  /* not yet returned by the address book */
    	*document->AddressRecord.ContactName = '\0';          /* not yet returned by the address book */
    	document->AddressRecord.DeviceClass = DeviceClass_Fax;
    	document->AddressRecord.LocalRouting = RouteUNKNOWN;
    	document->SendRoute = RouteUNKNOWN;
    	document->ReRouteAvailable = FALSE;
    	document->ReRouting = FALSE;

        document->HardCopyRequired = FALSE;		/* set TRUE for notes & forms if hardcopy required */
        document->HardCopyProcessID = 0;		/* no PrintQ document */

        document->RequestReceipt = FALSE;       /* set TRUE for notes & forms if receipt required */
        document->MimeEncodeFailures = 0;
        document->SMTPSendFailures = 0;

	    document->ScanState = ScanIDLE;			/* idle (0) */
    	document->ScanCount = 0;				/* no pages received yet */
    	document->PageList  = NULL;				/* so no classes or types */
    	document->TotalSize = 0;                /* no space taken by pages (neglecting directory overheads) */
    	document->BiggestPage = 0;
#if 0
    	document->TextCount = 0;
#endif
   	    document->RequestTx = FALSE;
   	    document->ResumeTx  = FALSE;
    	document->SendState = SendIDLE;			/* idle (0) */
    	document->SendCount = 0;                /* no pages transmitted yet */
	    document->Cancelled = FALSE;
	    document->Suspended = FALSE;
        document->Suspending = FALSE;

	    document->Connection.RetryLimit = &setup_phone_fax_redial_count;	/* address not value, so changes in setup will be seen */
	    document->Connection.RetryCount = 0;	/* not yet tried to direct dial */
	    document->Connection.RetryTime =  0;    /* trigger dial as soon as document needs it *//*PAN-01761 was time(NULL), but this causes problems if user winds the clock back*/	
        document->Connection.BadConnection = 0; /* no connection failures so far */

		document->SearchRef = 0;                /* address book search ref */
#if SUPPORT_ADDRESSBOOK
		document->AddressRecord.SearchFlags  = ADDRBOOKIF_SEARCH_FLAGS;   /* } Search complete when either */
        document->AddressRecord.OneShotFlags = ADDRBOOKIF_ONESHOT_FLAGS;	/* } of these clears to zero     */
#endif

        /* link document record to the tail of the queue */
		if (SendQ_Document_Queue == NULL)
			document->next_document = document;	/* first and only document, so point next field at ourselves */
		else
		{
        	document->next_document = SendQ_Document_Queue->next_document;	/* point to head of queue */
        	SendQ_Document_Queue->next_document = document;	/* old last item becomes last-but-one (we are the last) */
        }
        SendQ_Document_Queue = document;		/* point to tail of queue, our next_document field points to the head */

        *p_document = document;
	}

    return(NULL);
}


/*
 * The heart of the queue.
 *
 * Examine each document and act on significant state changes.
 *   ie Schedule completed documents for delivery (direct call or via ISP) 
 *      Schedule incomplete documents for streamed delivery when watermarks require it
 *      Re-route documents whoses the primary delivery route fails
 *      Delete successfully sent documents
 *      Delete unsent documents when  all available routes haves failed
 *
 *  In:
 *    isp_unavailable - TRUE if emails should be re-routed as faxes
 *
 *  Out:
 *    sending_already - pointer to document being sent (if any)
 *    send_next          - first document scheduled for direct transfer
 *    send_next_RouteISP - first document scheduled for email transfer
 */

static Document sending_already = NULL;
static Document send_next       = NULL;
static Document send_next_RouteISP = NULL;

extern void SendQ_QueueWalker(BOOL isp_unavailable)
{
#if SUPPORT_EMAIL
    int BiggestPage = 0;
    int BiggestMail = 0;
#endif

	sending_already = NULL;
	send_next       = NULL;
	send_next_RouteISP = NULL;

    isp_dialup_watermark_reached = FALSE;
    
	if (SendQ_Document_Queue)
    {
		/* one or more items in the queue */
    	/* SendQ_Document_Queue points to the last record in the queue, the last record points at the first (which maybe its-self) */

        Document previous = SendQ_Document_Queue;		/* last item in queue */
        Document document;
        
		do
			{
				BOOL delete_it = FALSE;
				
				document = previous->next_document;	/* first/next item in queue */

				if (document->SendState == SendCOMPLETE)
				{
		        	if ((document->ScanState == ScanCOMPLETE) && (document->SendCount == document->ScanCount))
		        		delete_it = TRUE;	/* scan has completed and all scanned pages have been sent */
		            else
		            	document->SendState = SendIDLE; 	/* scan still in progress, or some pages not sent, so allow for later send of rest of document */
		        }
			
				if (document->SendState == SendIDLE)
				{
		        	if ((document->ScanState == ScanCOMPLETE) && (document->SendCount == document->ScanCount))
		        		delete_it = TRUE;	/* scan has completed, there are no (or no more) pages to send */

                    if ((document->ScanState == ScanCOMPLETE) && (document->Cancelled))
                    	delete_it = TRUE;	/* scan has completed, and (user has confirmed cancel request or we've decided to cancel) */
		        }

				if (!delete_it)
				{
#if SUPPORT_EMAIL
                    if (BiggestPage < document->BiggestPage)
                        BiggestPage = document->BiggestPage;
#endif
		        	if (document->SendState == SendRUNNING) /*>>>should this be != SendIDLE???*/
		        		sending_already = document;			/* this document is already being sent */		
		            else
		            	{
#if SUPPORT_UI		            	  
#if NEW_CANCEL_CODE
                            if (document->Suspending)
                            {
                                document->Suspending = FALSE;
                                if (document->Suspended == FALSE)
                                {
                                    document->Suspended = TRUE;
                                    Screen_QuerryCancel(document->ProcessId);
                                }    
                            }
#endif
#endif
		            		if (((document->RequestTx) || (document->ScanState == ScanCOMPLETE)) &&
#if 1 /* PAN-01708 & PAN-0xxxx */
                                /* Part of fix for PAN-01708 (T-FAX) & PAN-0xxxx (Daytona equivalant)                                   */
                                /* if a streaming send exhausts and hangs up, don't redial until we have scanned at least one more page */
                                (document->SendCount < document->ScanCount) &&
#endif
		            		    (document->Cancelled == FALSE) && (document->Suspended == FALSE) &&
		            		    ((document->AddressRecord.SearchFlags == 0) || (document->AddressRecord.OneShotFlags == 0))	/* search completed either as expected or as a 'One shot' */
		            		   )
		            		{
								switch (document->SendRoute)
								{
									case RouteDIRECT:
                                        if (connection_impossible(RouteDIRECT, &(document->Connection)))
                                        {
                                        	/* we've dialled document->AddressRecord.DirectPhoneNumber many times and failed to get through */
                                        	if (document->ReRouteAvailable)
                                        	{
#if SUPPORT_UI                                        	
                                        		/*REPORT: unable to direct dial fax, re-rerouting via ISP */
                                                Log_TxReRouting(document->SendRoute, document);
#endif
                                        		document->ReRouteAvailable = FALSE;     /* using */
                                        		document->ReRouting = TRUE;				/* alternate route */
                                        		document->SendRoute = RouteISP;         /* via ISP */
#if 0
                                                isp_dialup_watermark_reached = TRUE;	/* trigger a DIAL_ISP, which will send all the queued emails */
#else
                                        		document->RequestTx = TRUE;             /* sent ASAP */
#endif
                                        	}
                                        	else
                                        	{
#if SUPPORT_UI
                                        		/*REPORT: unable to deliver this*//* alternate route failed */
                                                Log_TxUnableToDeliver(document->SendRoute, document);
                                        		unable_to_deliver(document);
#endif
                                        		document->Cancelled = TRUE;
                                        	}
                                        }
                                        else
                                        {
                                        	if (connection_requested_now(RouteDIRECT, &(document->Connection)))
                                        	{
				            					if (send_next == NULL)
				            						send_next = document;
				            				}
				            			}
				            			break;

#if SUPPORT_EMAIL
				            		case RouteISP:
				            			/* don't use connection_impossible(RouteISP, &isp_dialup.Connection[isp_dialup.use_next] as our   */
				            			/* caller uses it and always leaves structure isp_dialup looking as if connection would work */
										if ((isp_unavailable) || (document->MimeEncodeFailures >= 2) || (document->SMTPSendFailures >= 3)
#if 1
                                            /* if document contains a page bigger than we can encode, try immediate re-route by direct call */
                                            || (document->BiggestPage > STREAM_300K)
#endif
										   )
				            			{
				            				/* we've dialled the ISP many times on many numbers and failed to get through */
				            				if (document->ReRouteAvailable)
				            				{
				            					/*REPORT: unable to contact ISP, re-routing as a direct dial call */
                                                Log_TxReRouting(document->SendRoute, document);
					            				document->ReRouteAvailable = FALSE;     /* using */
                                        		document->ReRouting = TRUE;				/* alternate route */
                                        		document->SendRoute = RouteDIRECT;      /* direct dial */
   				            				}
				            				else
				            				{
                                        		/*REPORT: unable to deliver this*//* alternate route failed */
                                                Log_TxUnableToDeliver(document->SendRoute, document);
                                        		unable_to_deliver(document);
                                        		document->Cancelled = TRUE;
				            				}
				            			}
				            			else
					            		{
					            			if (send_next_RouteISP == NULL)
					            				send_next_RouteISP = document;
	
											if (document->RequestTx)
												isp_dialup_watermark_reached = TRUE;	/* trigger a DIAL_ISP, which will send all the queued emails */

                                            if (document->ResumeTx)
                                                isp_dialup_watermark_reached = TRUE;	/* trigger a DIAL_ISP, which will send all the queued emails */
										}
				            			break;
#endif

				            			
				            	}		
		            		}
		            	}
#if SUPPORT_EMAIL
                    if ((document->SendRoute == RouteDIRECT) && (document->ReRouteAvailable == FALSE))
                    {
                        /* A direct call, with no email re-reroute possible */
                        /* no need to reserve MimeEncoder space for it     */
                    }
                    else
                    {
                        /* route not yet known (so might be email) or route is email or re-route by email allowed */
                        /* so let MimeEncode reserve space */
                        if (BiggestMail < document->BiggestPage)
                            BiggestMail = document->BiggestPage;

                    }
#endif
	        	}

                /* consider deleting pages left by failed or cancelled faxes */
				if (((document->SendState == SendIDLE) && (document->Cancelled)) || delete_it)
				{
                    if (document->SendCount < document->ScanCount)
                    {
                    	document->SendCount++;
                    	remove_fileDN(document->Directory, document->SendCount);
                    	delete_it = FALSE;	/* ensure directory is deleted on the next pass */
                    }

					if ((document->SendCount < document->ScanCount) || (document->ScanState != ScanCOMPLETE))
					{
						/* still files left to delete, or scanning still in progress, so mustn't unlink */
						delete_it = FALSE;
					}
				}

				if (delete_it)
				{
				    /* PAN-01799 */
				    /* Cancelling a scan (SQ_LX_ABORT_INCOMING) may leave a partially */
				    /* complete (and therefore uncounted) page in memory - try deleting it */
				    remove_fileDN(document->Directory, document->ScanCount + 1);

	                if (document == previous)
	                {
	                	/* one document only in the queue, and we are deleting it! */
	                    previous = NULL;

	                    if (SendQ_Document_Queue == document) /* always TRUE */
	                    	SendQ_Document_Queue = previous;
	                }
	                else
	                {
	                	/* cut document from the circular queue */
	                	previous->next_document = document->next_document;
	                	
	                    if (SendQ_Document_Queue == document)
	                    	SendQ_Document_Queue = previous;	/* deleting last item in queue, so point queue at last but one entry */
	                }

                    QuCommon_FreePageList(document);            /* all pages sent or deleted, so free PageList */

                    os_destroy_directory(document->Directory);  /* directory empty, so delete it */
                    free(document);                             /* free the document record */

                    document = previous;
                }
	            else
	            {
	            	previous = document;	/* ready to go around the loop */
	            }
            }
	    while (document != SendQ_Document_Queue);    
	}

#if SUPPORT_EMAIL
    /* Tell HWM system the size of the largest page.    */
    /* This ensures space can be reserved to encode it. */
    HWM_MailScan_Largest(BiggestPage);
    HWM_MailSend_Largest(BiggestMail);
#endif
}


/*
 * After the transmit state machine goes idle, some documents may be marked non-idle or non-complete
 * typically because they had been mimeencoded but the call fail/was cancelled
 */
static void SendQ_ClearDownSendState(void)
{
	if (SendQ_Document_Queue)
    {
		/* one or more items in the queue */
    	/* SendQ_Document_Queue points to the last record in the queue, the last record points at the first (which maybe its-self) */
        Document document = SendQ_Document_Queue;       /* last item in queue */
		do
			{
				document = document->next_document;     /* first/next item in queue */

                if (document->SendState != SendCOMPLETE)
                    document->SendState = SendIDLE;
            }
	    while (document != SendQ_Document_Queue);    
	}
}


/*
 * SendQ_NextDocument - identify the next document ready send
 */
static void SendQ_NextDocument(BOOL *p_email_flag, Document *p_document)
{
#if 1 /*PAN-02059*/
    if (send_next != NULL)
    {
        /* any ISP connections that occur while scanning have the download phase suppressed, to stop the */
        /* downloaded emails taking memory needed for the scan/email-encode */
        /* if the scanned fax is to go direct, give it (or any delayed direct fax) priority over the email connect */ 

		*p_email_flag = FALSE;
    	*p_document = send_next;	/* maybe NULL */

    	return;
    }
#endif
	if (isp_dialup_timer_request || isp_dialup_user_request || isp_dialup_download_request ||
	    ((isp_dialup_redial_needed || isp_dialup_watermark_reached) && connection_requested_now(RouteISP, &isp_dialup.Connection[isp_dialup.use_next]))
	   )
	{
		*p_email_flag = TRUE;
		*p_document   = send_next_RouteISP;	/* maybe NULL */	
    }
    else
    {
		*p_email_flag = FALSE;
    	*p_document = send_next;	/* maybe NULL */
    }
}


static Document document_from_pid(unsigned int pid)
{
	if (SendQ_Document_Queue)
	{
		Document document = SendQ_Document_Queue;		/* last item in queue */
		/* the pid is usually that of the first or last document, so we */
        /* allow our search to start with the tail element, followed by the head element */
        /* instead of the expected head first search */
		do
			{
				if (document->ProcessId == pid)
					return(document);

				document = document->next_document;	/* first/next item in queue */
			}
		while (document != SendQ_Document_Queue);		
	}

	return(NULL);	/* not found!!! */
}


#if SUPPORT_EMAIL
/*
 * Given current document, find the next document to email
 */
static Document next_email(Document document)
{
	if ((document != NULL) && (document != SendQ_Document_Queue))
    {
		do
			{
				document = document->next_document;	/* next item in queue */

				if (document->SendRoute == RouteISP)
					return(document);
			}
		while (document != SendQ_Document_Queue);
    }
    
	return(NULL);	/* no more documents to email */
}
#endif

static Document document_from_SearchRef(int SearchRef)
{
	if (SendQ_Document_Queue)
	{
		Document document = SendQ_Document_Queue;		/* last item in queue */
		/* the SearchRef is usually that of the first or last document, so we */
        /* allow our search to start with the tail element, followed by the head element */
        /* instead of the expected head first search */
		do
			{
				if (document->SearchRef == SearchRef)
					return(document);

				document = document->next_document;	/* first/next item in queue */
			}
		while (document != SendQ_Document_Queue);		
	}

	return(NULL);	/* not found!!! */
}


extern AddressRec *SendQ_AddressRecord_from_pid(unsigned int pid)
{
	Document document;

	if ((document = document_from_pid(pid)) != NULL)
		return(&document->AddressRecord);

	return(NULL);	/* not found!!! */
}


extern AddressRec *SendQ_AddressRecord_from_SearchRef(int SearchRef)
{
	Document document;

	if ((document = document_from_SearchRef(SearchRef)) != NULL)
		return(&document->AddressRecord);

	return(NULL);	/* not found!!! */
}

extern void SendQ_emailaddress_from_pid(char *buffer, unsigned int pid)
{
	Document document;
	
	*buffer = '\0';

	if ((document = document_from_pid(pid)) != NULL)
	{
		strcpy(buffer, document->AddressRecord.EmailAddress);
    }
}


extern void SendQ_contactname_from_pid(char *buffer, unsigned int pid)
{
	Document document;
	
	*buffer = '\0';

	if ((document = document_from_pid(pid)) != NULL)
	{
		strcpy(buffer, document->AddressRecord.ContactName);
    }
}


extern void SendQ_subject_from_pid(char *buffer, unsigned int pid)
{
	Document document;
	
	*buffer = '\0';

	if ((document = document_from_pid(pid)) != NULL)
	{
		strcpy(buffer, document->EmailSubject);
    }
}


extern void SendQ_documentnumber_from_pid(unsigned int *p_document_number, unsigned int pid)
{
	Document document;
	
	*p_document_number = 0; /* not a valid document number */

	if ((document = document_from_pid(pid)) != NULL)
    {
		*p_document_number = document->DocumentNo;
    }
	
}


extern void SendQ_requestreceipt_from_pid(BOOL *p_request_receipt, unsigned int pid)
{
    Document document;

    if ((document = document_from_pid(pid)) != NULL)
    {
        *p_request_receipt = document->RequestReceipt;
    }
}


extern void SendQ_PageList_from_pid(PageRangeList *p_last_entry, unsigned int pid)
{
	Document document;

	*p_last_entry = NULL;	/* not a valid document */

	if ((document = document_from_pid(pid)) != NULL)
		*p_last_entry = document->PageList;
}


extern BOOL SendQ_Page_ClassTypeSize(unsigned int pid, unsigned int pageNum,
                                     PageClasses *pPageClass, PageTypes *pPageType, int *pFileSize)
{
    Document document;

    if ((document = document_from_pid(pid)) != NULL)
    {
        int fileType;
        if (QuCommon_GetClassAndType(document, pageNum, pPageClass, pPageType, &fileType) == 0)
        {
            char current_page_leafname[32];
            _kernel_oserror *error = NULL;
            int objecttype, filetype;

            sprintf(current_page_leafname, "%d", pageNum);            
            error = osfile_ReadCatInfoDL(document->Directory, current_page_leafname, &objecttype, pFileSize, &filetype);    
            if ((error == NULL) && (objecttype == 1/*file found*/))
                return(FALSE);  /* OK - page exists and *pPageClass, *pPageType and *pFileSize filled in */
        }
    }

    return(TRUE);  /* Error: page doesn't exist */
}


/*
 * Return the current scan count for a document
 *
 * This routine is valid for both streaming and non-streaming document sends.
 *
 * Used by RemXfer to querry the current highest page number
 * that it can send whilst streaming.
 *
 * In:
 *   Process Id of document
 *
 * Out:
 *  =0 - document not found or no pages scanned
 *  >0 - number of complete pages scanned (and hence highest page
 *       available to be sent
 */
extern unsigned int SendQ_QuerryTx_hiPage(unsigned int pid)
{
    Document document;

    if ((document = document_from_pid(pid)) != NULL)
    {
        return(document->ScanCount);
    }

    return(0);
}



/*
 * Examine the SendQ plus various flags to determine
 * whether a document send or email retrieve should
 * be attempted.
 */
extern void SendQ_TickerHandler(void)
{
#if SUPPORT_EMAIL
	BOOL isp_unavailable = FALSE;	/* optomistic aren't we */

    if (isp_dialup.using_now <= -1)
    {
        /* not accessing ISP at the moment */
    
       	if (isp_dialup.use_next <= -1)
       	{
       		/* initialise ISP PhoneNumbers, RetryCounts & RetryLimits etc */
       		int i;
       		time_t now = 0; /*PAN-01761 was time(NULL), but winding clock back prevented ISP dialups until time advanced to value captured */
       		
       		for (i = 0; i < ISP_LIST_SIZE; i++)
       		{
       		    switch (i)
       		    {
                    default:
                        /* SHOULD NEVER HAPPEN - ISP_LIST_SIZE is 2 ie 0..1 are valid indexices */
                        /* drop into... */
       		        case 0:
                        isp_dialup.Connection[i].RetryLimit = &setup_ISP_PrimaryRedialCount;
                        isp_dialup.PhoneNumber[i] = setup_ISP_PrimaryPhoneNumber;
                        break;
    
                    case 1:
                        isp_dialup.Connection[i].RetryLimit = &setup_ISP_SecondaryRedialCount;
                        isp_dialup.PhoneNumber[i] = setup_ISP_SecondaryPhoneNumber;
                        break;
                }
       			isp_dialup.Connection[i].RetryCount = 0;	/* haven't tried this number yet */
       			isp_dialup.Connection[i].RetryTime  = now;
       			isp_dialup.Connection[i].BadConnection = 0; /* no bad connections so far */
            }
    
            /* start with the Primary route (first number) */
    		isp_dialup.use_next = 0;
    	}
    
        /*
         * If the first number is viable, stay with it,
         * else consider the next number available.
         */
        isp_dialup.use_next = 0;    /* The user may increment the retry count for the first number while we are waiting to try */
                                    /* the second number. Zeroing this index, allows us to try the first number again. */
        while (isp_dialup.use_next < ISP_LIST_SIZE)
        {
    		if (connection_impossible(RouteISP, &isp_dialup.Connection[isp_dialup.use_next]))
    		{
    			/* try alternate ISP phone number */
    			isp_dialup.use_next++;
    	    }
    	    else
    	    {
    	        /* we have a number we can use */
    	        break;
    	    }
        }
        
    	if (isp_dialup.use_next >= ISP_LIST_SIZE)
    	{
    		/* unable to contact ISP by any of the known routes - send by direct routing if available */
    		isp_dialup.use_next = -1;	/* initialisation required */
    		isp_unavailable = TRUE;
    		RemXfer_Lockout_Incoming = FALSE;   /* MUST clear any inhibit incoming call flags here */
    	}
    }
#if 0
    /* redundent */
	if (isp_dialup.use_next == -1)
    	isp_unavailable = TRUE;	/* despite our best efforts, the ISP is un-useable */
#endif
#else
    BOOL isp_unavailable = TRUE; 
#endif
	if (1 /*maybe_idle*/)	/* don't use maybe_idle flag until everything reports GOING_IDLE correctly! */
	{
		BOOL     email_flag;
		Document send_next;
		
		SendQ_QueueWalker(isp_unavailable); /* if ISP unavailable, email will be re-routed if possible */

		if (isp_unavailable)
		{
            /* MUST clear all the ISP_DIALUP_xxxx flags that SendQ_NextDocument looks at */    
            isp_dialup_timer_request = FALSE;
			isp_dialup_user_request = FALSE;
			isp_dialup_download_request = FALSE;

            isp_dialup_redial_needed = FALSE;
            isp_dialup_watermark_reached = FALSE;   /* incase a direct fax was rerouted as email */   
		}
		
        SendQ_NextDocument(&email_flag, &send_next);
	
		/* if not already sending, send the next one ready to go */
		if ((sending_already == NULL) &&
		    ((send_next != NULL) || (email_flag == TRUE))
		   )
		{
			maybe_idle = FALSE;	/* assume no response to message */
  			StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_QUERY_IDLE, NULL);

	        /* deliver the queued messages */
            while (StateKicker_Deliver() > 1)
    	        /* null statement */;
        }
	}

    if (user_request_cancel_fax)
    {
        user_request_cancel_fax = FALSE;

        StateKicker_SendMessage(SendQ_MessageHandler, UI_SQ_CANCEL, NULL);
        
	    /* deliver the queued messages */
        while (StateKicker_Deliver() > 1)
    	    /* null statement */;
    }

#if SUPPORT_CHECK_HWM
    StateKicker_SendMessage(SendQ_MessageHandler, SQ_SQ_CHECK_HWM, NULL);

    /* deliver the queued messages */
    while (StateKicker_Deliver() > 1)
  	    /* null statement */;
#endif
}







_kernel_oserror *os_create_directory(const char *name)
{
  _kernel_oserror *error;
  _kernel_swi_regs r;

  r.r[0] = 8;           /* Create a directory */
  r.r[1] = (int)name;
  r.r[2] = 0;
  r.r[3] = 0;
  r.r[4] = 76;          /* give us 76 entries (ignored by Filecore) */

  error = _kernel_swi(OS_File, &r, &r);

  return(error);
}


_kernel_oserror *os_destroy_directory(const char *name)
{
	_kernel_oserror *error;
	_kernel_swi_regs r;

	r.r[0] = 6;
	r.r[1] = (int)name;

	error = _kernel_swi(OS_File, &r, &r);
	return(error);
}


extern _kernel_oserror *osfile_ReadCatInfo(const char *fullname, int *pobjecttype, int *pobjectlength, int *pfiletype)
{
  _kernel_swi_regs r;
  _kernel_oserror  *error;

  /* Read catalogue info for named object (no path used) */
  r.r[0] = 23;
  r.r[1] = (int)fullname;
  error = _kernel_swi(OS_File, &r, &r);

  if (error == NULL)
  {
    *pobjecttype   = r.r[0];	/* 0=not found, 1=file found, 2=directory found, 3=image file found */
    *pobjectlength = r.r[4];	/* object length */
    *pfiletype     = r.r[6];	/* object filetype */
  }
  else
  {
  	*pobjecttype   = 0;			/* not found */
  	*pobjectlength = 0;   		/* object length zero bytes */
    *pfiletype     = -1;    	/* untyped */
  }

  return(error);
}


extern _kernel_oserror *osfile_ReadCatInfoDL(const char *directory, const char *leafname, int *pobjecttype, int *pobjectlength, int *pfiletype)
{
	char fullname[256];

  	strcpy(fullname, directory);
  	strcat(fullname, ".");
  	strcat(fullname, leafname);

	return(osfile_ReadCatInfo(fullname, pobjecttype, pobjectlength, pfiletype));
}


extern _kernel_oserror *set_filetype(const char *fullname, int filetype)
{
  _kernel_oserror *error;
  _kernel_swi_regs r;

  r.r[0] = 18;		/* set filetype (and date/time stamp if not set already */
  r.r[1] = (int)fullname;
  r.r[2] = filetype;

  error = _kernel_swi(OS_File, &r, &r);
  return(error);
}


extern _kernel_oserror *set_filetypeDL(const char *directory, const char *leafname, int filetype)
{
  char fullname[256];

  strcpy(fullname, directory);
  strcat(fullname, ".");
  strcat(fullname, leafname);

  return(set_filetype(fullname, filetype));
}


extern _kernel_oserror *set_filetypeDN(const char *directory, const unsigned int leafnumber, int filetype)
{
	char fullname[256];

	sprintf(fullname, "%s.%d", directory, leafnumber);
    return(set_filetype(fullname, filetype));
}


extern _kernel_oserror *renameDLN(const char *directory, const char *from_leafname, const unsigned int to_leafnumber)
{
	char command[256];
	
	sprintf(command, "Rename %s.%s %s.%d", directory, from_leafname, directory, to_leafnumber);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *renameDLDL(const char *from_directory, const char *from_leafname, const char *to_directory, const char *to_leafname)
{
	char command[256];
	
	sprintf(command, "Rename %s.%s %s.%s", from_directory, from_leafname, to_directory, to_leafname);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *renameDNDL(const char *from_directory, const unsigned int from_leafnumber, const char *to_directory, const char *to_leafname)
{
	char command[256];
	
	sprintf(command, "Rename %s.%d %s.%s", from_directory, from_leafnumber, to_directory, to_leafname);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *renameDLDN(const char *from_directory, const char *from_leafname, const char *to_directory, const unsigned int to_leafnumber)
{
	char command[256];
	
    sprintf(command, "Rename %s.%s %s.%d", from_directory, from_leafname, to_directory, to_leafnumber);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *renameDNDN(const char *from_directory, const unsigned int from_leafnumber, const char *to_directory, const unsigned int to_leafnumber)
{
	char command[256];
	
	sprintf(command, "Rename %s.%d %s.%d", from_directory, from_leafnumber, to_directory, to_leafnumber);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *remove_file(const char *fullname)
{
	_kernel_oserror *error;
	_kernel_swi_regs r;

	r.r[0] = 6;
	r.r[1] = (int)fullname;

	error = _kernel_swi(OS_File, &r, &r);
	return(error);
}


extern _kernel_oserror *remove_fileDL(const char *directory, const char *leafname)
{
	char fullname[256];

	sprintf(fullname, "%s.%s", directory, leafname);
	return(remove_file(fullname));
}


extern _kernel_oserror *remove_fileDN(const char *directory, const unsigned int leafnumber)
{
	char fullname[256];

	sprintf(fullname, "%s.%d", directory, leafnumber);
    return(remove_file(fullname));
}


extern void purge_directory(const char *directory, const int loPage, const int hiPage)
{
  int i;
  char command[256];

  for (i=loPage; i<=hiPage; i++)
  {
    sprintf(command, "remove %s.%d", directory, i);
    _kernel_oscli(command);
  }
}


extern int readvareval(const char *name)
{
  _kernel_swi_regs r;
  int result;

  /* Setup registers for SWI call */
  r.r[0] = (int)name;
  r.r[1] = (int)&result;
  r.r[2] = sizeof(int);
  r.r[3] = 0;            /* first call */
  r.r[4] = 1;            /* numeric value expected */

  _kernel_swi(OS_ReadVarVal, &r, &r);

  /* Check validity of result and set return value to 0 if invalid (R2 = 4 if valid) */
  if (r.r[2] == 0)
    result = 0;

  return (result);
}


extern void readvarval(const char *name, char *buffer, int buffmax)
{
  _kernel_swi_regs r;

  r.r[0] = (int)name;
  r.r[1] = (int)buffer;
  r.r[2] = buffmax;
  r.r[3] = 0;		/* first call */
  r.r[4] = 0;

  _kernel_swi(OS_ReadVarVal, &r, &r);

  /* if not a string, pretend it doesn't exist */
  if (r.r[4] != 0)
    r.r[2] = 0;

  buffer[r.r[2]] = '\0';	/* terminate*/
}

#if SUPPORT_EMAIL
#if KLUDGE_EMAIL
void test_emailsend(void)
{
	Document document;

	SendQ_CreateDocument(&document);
	if (document)
	{
		char command[256];
		messageDataBlock *sendMessage;

    	sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.1 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 1, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);

        sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.2 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 2, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);
#if 1
    	sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.3 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 3, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);

        sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.4 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 4, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);

    	sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.5 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 5, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);

        sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.6 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 6, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);

        sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.7 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 7, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);
#endif

		document->ScanState = ScanCOMPLETE;			/* complete (3)  */
		document->RequestTx = 1;			/* requesting */

		document->SearchRef = document->ProcessId; /* good enough (cos its unique) as the message ref when faking messages */

		strcpy(document->AddressRecord.ContactName, "Daytona");
        strcpy(document->AddressRecord.DirectPhoneNumber, "-5337");
#if 0
        strcpy(document->AddressRecord.EmailAddress, "daytona@rwarren.acorn.co.uk");
#else
        strcpy(document->AddressRecord.EmailAddress, "wibble@rwarren.acorn.co.uk");
#endif        
        document->AddressRecord.OneShotFlags = 0;

		StateKicker_SendMessage(SendQ_MessageHandler, AD_SQ_FINISH, &sendMessage);
		sendMessage->data.finish.searchref = document->SearchRef;


    }
}
#endif
#endif


/* end of SendQ.c */


