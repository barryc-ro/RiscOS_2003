/*
 * SendQ.c - Daytona Fax and Email Send Queue
 *
 * R C Manby
 *
 * Started 22 July 1997
 */


#include "BuildFlags.h"
#include "StdTypes.h"

#define KLUDGE_EMAIL 1
#define SCANNING 1
#define TRANSMITTING 1
#define TEXTUAL_EMAIL 0
#define HARDCOPY_FINISHED 1
#define NEWCODE 1

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "kernel.h"

#include "LogFileIF.h"

#include "PageList.h"
#include "StateKicker.h"
#include "SendQ.h"
#include "PrintQ.h"
#include "Screen.h"

#if SCANNING
#include "LocXfer.h"
#endif
#if TRANSMITTING
#include "RemXfer.h"
#endif

#if SUPPORT_EMAIL
#include "MimeQ.h"
#endif

#include "functions.h"
#include "wimp.h"
#include "wimplib.h"
#include "AddrBookIF.h"
#include "QuStruct.h"
#include "QuCommon.h"
#include "dialler.h"    /* for dialler status codes */


#include "DebugLib.h"
#include "SetupIF.h"
#include "FileOps.h"

#if SUPPORT_ADDRESSBOOK
#include "NumConvert/NumConvert.h"
#else
#include "TfaxAddr.h"	/* if not using the full address book use the mini address book */ 
#endif

#define SENDQ_RX_DIR_DOC_0 "RAM::RamDisc0.$.SendQ.Doc0"

enum _HL_RC { OK = 0, Error_MultipleNAN, Error_NoMemory, OS_Error };
typedef enum _HL_RC HL_RC;


/* external flags that trigger in immediate dialup */
BOOL isp_dialup_timer_request = FALSE;      /* } both are cleared as soon as a SQ_RX_DIAL_ISP starts, but we set          */
BOOL isp_dialup_user_request = FALSE;		/* } isp_dialup_redial_needed to cause a later redial if the connection fails */

/* local flags that trigger a dialup when time() is connection->RetryTime */
static BOOL isp_dialup_redial_needed = FALSE;      /* this should only be cleared when the complete send/receive cycle has happened */
static BOOL isp_dialup_watermark_reached = FALSE;  /* this can be cleared after each complete document has been sent */
                                                   /*>>>RCM says rename this, as it is set when a documents RequestTX flag is set*/
                                                   /*>>>    ie when watermark reached or scan complete and document should be sent immediatly*/

BOOL user_request_cancel_fax = FALSE;


#define ISP_LIST_SIZE 2


struct
{
    int using_now;      /* -1=dormant, 0..(ISP_LIST_SIZE-1) if active */
    int use_next;	/* initialised to -1 meaning rest of structure un-initialised */
	int errors_before;
    PhoneConnection Connection[ISP_LIST_SIZE];
    char           *PhoneNumber[ISP_LIST_SIZE];


}
isp_dialup = { -1, -1 };



static void hardcopy_new_document(Document document);
static void hardcopy_pages_complete(Document document, unsigned int loPage, unsigned int hiPage);
static void hardcopy_document_complete(Document document);

static void show_ContactName(Document document);
static void show_SendRoute(Document document);
static void show_Sending(Document document);

static void Log_RxConnectingError(messageDataBlock *messageData);
static void Log_RxConnectedError(messageDataBlock *messageData);

static void Log_TxConnecting(enum _SendRoute route, PhoneConnection *connection, const char *dial_number);
static void Log_TxConnectingError(enum _SendRoute route, PhoneConnection *connection, messageDataBlock *messageData);
static void Log_TxConnectingFailed(enum _SendRoute route, PhoneConnection *connection);
static void Log_TxConnected(enum _SendRoute route, PhoneConnection *connection);
static void Log_TxConnectedErrorSendingDoc(enum _SendRoute route, PhoneConnection *connection, messageDataBlock *messageData, Document document);
static void Log_TxConnectedError(enum _SendRoute route, messageDataBlock *messageData);
static void Log_TxSendDocument(enum _SendRoute route, Document document);
static void Log_TxSentDocument(enum _SendRoute route, Document document);
static void Log_TxDisconnected(enum _SendRoute route, PhoneConnection *connection);
static void Log_TxEncodingError(enum _SendRoute route, messageDataBlock *messageData, Document document); 

static BOOL connection_impossible(enum _SendRoute route, PhoneConnection *connection);
static BOOL connection_requested_now(enum _SendRoute route, PhoneConnection *connection);

static _kernel_oserror *SendQ_CreateDocument(Document *p_document);
static void SendQ_NextDocument(BOOL *p_email_flag, Document *p_document);
static Document document_from_pid(unsigned int pid);
static Document next_email(Document document);
static Document document_from_SearchRef(int SearchRef);





#if KLUDGE_NAN
extern int global_forceNAN = 0;	/* 0=>Normal, 1=>ForceNAN */
#endif
#if KLUDGE_ROUTING
extern int global_routing = 0;	/* 0=>Fax, 1=>ZModem */
#endif

static BOOL maybe_idle = TRUE;	/* strong hint that the local fax may be idle and hence free for printing to */

enum _rx_States { rxIDLE = 0, rxCONNECTED };
enum _tx_States { txIDLE = 0, txDIRECTCONNECTING, txDIRECTCONNECTED, txISPCONNECTING, txISPCONNECTED };

typedef enum _rx_States rx_States;
typedef enum _tx_States tx_States;

#define ADDRBOOKIF_SEARCH_FLAGS		(Field_ContactName | Field_EmailAddress | Field_FaxNumber | Field_DeviceClass | Field_RoutingOverride)
#define ADDRBOOKIF_ONESHOT_FLAGS    (Field_EmailAddress | Field_FaxNumber)	/* NB just a tally of data received, so don't try changing to xxxx_OneShot_xxxx */

/*
 * Action messages from LocXfer and RemXfer
 *
 */
extern void SendQ_MessageHandler(int messageNumber, messageDataBlock *messageData)
{
	static rx_States rx_state = rxIDLE;
	static tx_States tx_state = txIDLE;
	static Document scan_document = NULL;	/* Do we KNOW that there can be only one active at a time? */
    static Document transmit_document = NULL;
    static Document encoding_document = NULL;
    static Document NAN_document = NULL;

	HL_RC status = OK;

    /* Print message number to debug device */
    dprintf((NULL, "SendQ_MessageHandler: Message => 0x%X\n", messageNumber));

	switch (messageNumber)
	{
#if SCANNING
		case LX_SQ_ERROR:
		case LX_SQ_NEW_DOCUMENT:
        case LX_SQ_NEW_PAGE:
        case LX_SQ_PAGE_COMPLETE:
        case LX_SQ_DOCUMENT_COMPLETE:
        case UI_SQ_CANCEL:
			{
				rx_States nextstate = rx_state;

				switch (rx_state)
				{
					case rxIDLE:
						switch (messageNumber)
                        {
							case LX_SQ_ERROR:
								Screen_ReportError("Title_LX_SQ_ERROR", messageData);
								Log_RxConnectingError(messageData);
								break;

							case LX_SQ_NEW_DOCUMENT:
								{
									int interactive = FALSE;
#if SUPPORT_ADDRESSBOOK
									/*
									 * need:
									 *  setup_configuredNAN             - to determine if NAN was dialled
									 *  setup_external_access_code      }
									 *  setup_international_access_code } to convert number
									 *  setup_national_access_code      } (non-NAN) dialled on fax machine
									 *  setup_fax_country_code          } to internal format
									 *  setup_fax_area_code             }
                                     */

									SetupIF_Read_Phone_Config();

									/*int documentId = NewDocumentId();*/
					                interactive = (strcmp(messageData->data.lx_sq_new_document.number, setup_configuredNAN) == 0);

                                    LogFileIF_show_string(LOG_DEBUG, "Configured NAN", setup_configuredNAN);
			                        LogFileIF_show_string(LOG_DEBUG, "Configured fax number", setup_fax_number);

									/* treat empty number as setup_configuredNAN */
									if (messageData->data.lx_sq_new_document.number[0] == '\0')
										interactive = TRUE;
#if KLUDGE_NAN
									if (global_forceNAN)
									{
										/* force interactive search all the time */
										interactive = TRUE;
									}
#endif

									/* only one interactive search allowed at once */
									if ((interactive) && (AddrBookIF_InteractiveBusy()))
										status = Error_MultipleNAN;
#endif
									if (status == OK)
									{
					                    /* only allow fax scanning if we have a reasonable amount of memory */
					                	switch (HWM_Check(/*DEFAULT_FAX_SIZE*/))
					                	{
					                		case 3:
					                		case 2:
					                			status = Error_NoMemory;
					                			break;
					
					                		case 1:
					                			if (SendQ_CreateDocument(&scan_document) != NULL)
					                				status = OS_Error;
					                			break;
					                	}
									}
					
									if (status == OK)
									{
										messageDataBlock *sendMessage;
					
										scan_document->ScanState = ScanRUNNING;	/* in progress */
										scan_document->RequestReceipt = configured_request_receipt;

					                    /* tell LocXfer where to put the document (fax/text) */
										StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_NEW_DOCUMENT_DIR, &sendMessage);
										sendMessage->data.new_document_dir.pid = scan_document->ProcessId;
										strcpy(sendMessage->data.new_document_dir.directory, scan_document->Directory);
					
					                    /* attach number dialled on fax machine to document */
#if SUPPORT_ADDRESSBOOK
										/* visually cleaner to open address book last rather than risk having to close it if above calls fail */
										/* search may terminate after scan has completed, so document is tied to the search by the SearchRef */
										if (interactive)
										{
											/* interactive (NAN) search, returning contact name, email address, fax number, routing etc */
											/* but user may choose 'One shot' which returns email address and fax number only */
											scan_document->AddressRecord.SearchFlags  = ADDRBOOKIF_SEARCH_FLAGS;
											scan_document->AddressRecord.OneShotFlags = ADDRBOOKIF_ONESHOT_FLAGS;
											AddrBookIF_InteractiveSearch(&scan_document->SearchRef, &scan_document->AddressRecord, ADDRBOOKIF_SEARCH_FLAGS);

										    /* tell Screen a scan has started */
										    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_NEW_DOCUMENT, &sendMessage);
										    sendMessage->data.sq_sc_new_document.pid = scan_document->ProcessId;
										    strcpy(sendMessage->data.sq_sc_new_document.number, messageData->data.lx_sq_new_document.number);
										}
										else
										{
                                            /* we read all the setup_xxx variables we need above */

						                    numconvert_captured_to_internal(messageData->data.lx_sq_new_document.number,
						                                                 	scan_document->CapturedPhoneNumber,   /* internal format */
                                                                            sizeof(scan_document->CapturedPhoneNumber),
						                        							setup_external_access_code,				/* op:	Outside line prefix, eg "" or "9" */
						                        							setup_international_access_code,		/* ip:	International prefix, eg "00" */
						                        							setup_national_access_code,      		/* np:	National prefix, e.g. "0" */
						                        							setup_fax_country_code,                 /* cc:	Country code, e.g. "44" */
						                        							setup_fax_area_code                     /* ac:	Area code, e.g. "1223" */
						                        						   );
					                        /* non interactive search of fax or voice number */
					                        /* returning contact name, email address, fax number, routing etc */
					                        /* 'One shot' not applicable */
											scan_document->AddressRecord.SearchFlags  = ADDRBOOKIF_SEARCH_FLAGS;
											scan_document->AddressRecord.OneShotFlags = ADDRBOOKIF_ONESHOT_FLAGS;
											AddrBookIF_SearchFaxNumber(&scan_document->SearchRef, &scan_document->AddressRecord, ADDRBOOKIF_SEARCH_FLAGS, scan_document->CapturedPhoneNumber);

    										/* tell Screen a scan has started */
    										StateKicker_SendMessage(Screen_StateMachine, SQ_SC_NEW_DOCUMENT, &sendMessage);
    										sendMessage->data.sq_sc_new_document.pid = scan_document->ProcessId;
    										numconvert_internal_to_display(scan_document->CapturedPhoneNumber, /* internal format */
                                                                           sendMessage->data.sq_sc_new_document.number,
                                                                           sizeof(sendMessage->data.sq_sc_new_document.number),
                                                                           setup_international_access_code,     /* ip:	International prefix, eg "00" */
                                										   setup_national_access_code,      	/* np:	National prefix, e.g. "0" */
								                                		   setup_fax_country_code,              /* cc:	Country code, e.g. "44" */
										                                   setup_fax_area_code                  /* ac:	Area code, e.g. "1223" */
										                                  );
										}
#else
										/* no address book, so pretend the search completed, use captured number as direct number */
                        				scan_document->AddressRecord.DeviceClass = DeviceClass_Fax;				   
                        				scan_document->SendRoute = RouteDIRECT;
										scan_document->AddressRecord.SearchFlags = scan_document->AddressRecord.OneShotFlags = 0;
										strcpy(scan_document->CapturedPhoneNumber, messageData->data.lx_sq_new_document.number);
										strcpy(scan_document->AddressRecord.DirectPhoneNumber,   messageData->data.lx_sq_new_document.number);

                                        /* no address book so look up number in mini address book */
										if (TFax_addr_lookup(messageData->data.lx_sq_new_document.number))
										   scan_document->AddressRecord.DeviceClass = DeviceClass_Daytona;
										else
										   scan_document->AddressRecord.DeviceClass = DeviceClass_Fax;

										/* tell Screen a scan has started, captured number may be useful for debugging */
										StateKicker_SendMessage(Screen_StateMachine, SQ_SC_NEW_DOCUMENT, &sendMessage);
										sendMessage->data.sq_sc_new_document.pid = scan_document->ProcessId;
										strcpy(sendMessage->data.sq_sc_new_document.number, messageData->data.lx_sq_new_document.number);
#endif
										nextstate = rxCONNECTED;
									}
									else
										StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);
								}
								break;
                        }
                        break;
                    
					case rxCONNECTED:
						switch (messageNumber)
                        {
							case LX_SQ_ERROR:
								Screen_ReportError("Title_LX_SQ_ERROR", messageData);
								Log_RxConnectedError(messageData);
								break;

							case LX_SQ_NEW_DOCUMENT:
								StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);
								break;

							case LX_SQ_NEW_PAGE:
								{
									/*>>>Trigger page <n> animation*/
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_NEW_PAGE, NULL);
					
									switch (HWM_Check())					/* returns 1/2/3 OK/Trigger-send/Abort-Rx */
									{
										case 3:
											StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);
											/* drop into... */
										case 2:
											scan_document->RequestTx = 1;	/* requesting (or in progress) */
										case 1:
											break;
									}
								}
								break;
					
							case LX_SQ_PAGE_COMPLETE:
								{
					                messageDataBlock *sendMessage;
					
									QuCommon_Page_Complete(scan_document,
									                       messageData->data.lx_sq_page_complete.pageNum,
									                       messageData->data.lx_sq_page_complete.pageClass,
									                       messageData->data.lx_sq_page_complete.pageType,
									                       messageData->data.lx_sq_page_complete.fileType
									                      );
					
									switch (HWM_Check())					/* returns 1/2/3 OK/Trigger-send/Abort-Rx */
									{
										case 3:
											StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);
											/* drop into... */
										case 2:
											scan_document->RequestTx = 1;	/* requesting (or in progress) */
										case 1:
											break;
									}
					
									/* poke the animations */
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_PAGE_COMPLETE, &sendMessage);
					                sendMessage->data.sq_sc_page_complete.ScanCount = scan_document->ScanCount;
								}
								break;
					
							case LX_SQ_DOCUMENT_COMPLETE:
								{
					                messageDataBlock *sendMessage;
					
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DOCUMENT_COMPLETE, &sendMessage);
					                sendMessage->data.sq_sc_document_complete.ScanCount = scan_document->ScanCount;
					
									scan_document->ScanState = ScanCOMPLETE;	/* complete (3)  */
#if 1
									scan_document->RequestTx = 1;				/* requesting */
#endif
									scan_document = NULL;	/* this handler no longer needs to reference this document */
									nextstate = rxIDLE;
								}
								break;

                            case UI_SQ_CANCEL:
                                /* ask user to confirm Cancel button (if not already doing so) */
                                if (scan_document->Suspended == FALSE)
                                {
                                    scan_document->Suspended = TRUE;
                                    Screen_QuerryCancel(scan_document->ProcessId);
                                }
                                break;
                        }
                        break;
                } /* switch (rx_state) */

#if 0
			    /* report SQ_xx_GOING_IDLE if going idle from a non-idle state */
				if ((nextstate == rxIDLE) && (rx_state != rxIDLE))
					StateKicker_SendMessage(Xxxx_MessageHandler, SQ_xx_GOING_IDLE, NULL);
#endif
				rx_state = nextstate;
            }
            break;
/* end of scanning */
#endif
#if SCANNING
/* scanning - address book search */
		case AD_SQ_NOTFOUND:
        case AD_SQ_CANCEL:
		case AD_SQ_FINISH:
			NAN_document = document_from_SearchRef(messageData->data.cancel.searchref);	/*NB assumes data.cancel.searchref data.finish.searchref data.notfound.searchref are overlaid */
		    if (NAN_document)
		    {
	    		switch (messageNumber)
	    		{
	    			/* number dialled on fax machine is not in the address book, so use it, assuming a fax machine will answear */
	    			case AD_SQ_NOTFOUND:
	    				strcpy(NAN_document->AddressRecord.DirectPhoneNumber, NAN_document->CapturedPhoneNumber);	/* internal format */
                        NAN_document->AddressRecord.DeviceClass = DeviceClass_Fax;				   
                        NAN_document->SendRoute = RouteDIRECT;
						scan_document->AddressRecord.SearchFlags = scan_document->AddressRecord.OneShotFlags = 0;	/* pretend the search completed */
	    				break;

                    /* no need to query the user !Address does it for us */
	    			case AD_SQ_CANCEL:
	    			    NAN_document->Cancelled = TRUE;
						scan_document->AddressRecord.SearchFlags = scan_document->AddressRecord.OneShotFlags = 0;	/* pretend the search completed */
	    				break;

					case AD_SQ_FINISH:
						show_ContactName(NAN_document);	/* display debugging/user info */

						/* scan_document->AddressRecord.SearchFlags or scan_document->AddressRecord.OneShotFlags are now zero */

                        /* now that we have the address book data, we may be able to choose the final routing */
                   		if (NAN_document->AddressRecord.EmailAddress[0] == '\0')
                   		{
                   			if (NAN_document->AddressRecord.DirectPhoneNumber[0] == '\0')
                   			{
                   				/* opps, search has completed, without returning a suitable destination */
                   				NAN_document->Cancelled = TRUE;	/*>>>perhaps we should open the NAN window*/
                   			}
                   			else
                   			{
                   				/* have phone number only, DeviceClass may have been set or left at default */
                   				NAN_document->SendRoute = RouteDIRECT;
                   				show_SendRoute(NAN_document);	/* display debugging/user info */
                   			}
                   		}
                   		else
                   		{
                   			if (NAN_document->AddressRecord.DirectPhoneNumber[0] == '\0')
                            {
                               	/* have email address only, DeviceClass may have been set or left at default */
                               	NAN_document->SendRoute = RouteISP;
                               	show_SendRoute(NAN_document);	/* display debugging/user info */
                            }
                            else
                            {
                               	/* ask user which route to use */
                               	Screen_QuerryRoute(NAN_document->ProcessId, NAN_document->AddressRecord.ContactName);
                               	/* SC_SQ_ROUTING with RouteUNKNOWN (ie use global routing), RouteDIRECT or RouteISP will arrive later on */
                            }
                   		}
						break;
	    				
	    		} /*inner switch (messageNumber)*/
		    }
            break;

		case SC_SQ_ROUTING:
			NAN_document = document_from_pid(messageData->data.deliveryoptions.pid);
		    if (NAN_document)
			{
	    		NAN_document->SendRoute = messageData->data.deliveryoptions.route;	/* RouteUNKNOWN (ie use local routing), RouteDIRECT or RouteISP */

				/* no route chosen, use AddressRecord.LocalRouting */
				if (NAN_document->SendRoute == RouteUNKNOWN)
					NAN_document->SendRoute = NAN_document->AddressRecord.LocalRouting;	/* which may also be RouteUNKNOWN (ie use global routing), RouteDIRECT or RouteISP */

				if (NAN_document->SendRoute == RouteUNKNOWN)
				{
					if (setup_configured_routing == 0)
						NAN_document->SendRoute = RouteISP;
					else
						NAN_document->SendRoute = RouteDIRECT;		
                }
                show_SendRoute(NAN_document);	/* display debugging/user info */

				/* Since we asked the user to selected the primary route (RouteDIRECT or RouteISP), */
				/* we know that the other route is available as the secondary route */ 
				NAN_document->ReRouteAvailable = TRUE;
			}
       		break;

        case SC_SQ_CANCEL_CONFIRMED:
            NAN_document = document_from_pid(messageData->data.sc_sq_cancel_confirmed.pid);
            if (NAN_document)
            {
                /* if scanning still in progress, abort it */
                if ((NAN_document == scan_document) &&
                    (NAN_document->ScanState == ScanRUNNING)
                   )
                    StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);

                NAN_document->Cancelled = TRUE;
            }
            break;

        case SC_SQ_CANCEL_REVOKED:
            NAN_document = document_from_pid(messageData->data.sc_sq_cancel_revoked.pid);
            if (NAN_document)
            {
                NAN_document->Suspended = FALSE;
            }
            break;
/* end of scanning - address book search*/
#endif

		case RX_SQ_GOING_IDLE:
			/* a receive or a send has just completed */
			maybe_idle = TRUE;	/* tell queue scanner it may like to try printing */
			/* drop into... */
#if TRANSMITTING
/* transmitting */
		case RX_SQ_AM_IDLE:
		case RX_SQ_DIAL_REJECTED:
#if 0
		case RX_SQ_FAILED:
#endif
		case RX_SQ_ERROR:
	  /*case RX_SQ_WHICH_DOCUMENT: occurs lower down */
		case RX_SQ_SWITCHTO_DAYTONA:
	  	case RX_SQ_CONNECTED:
		case RX_SQ_SENDING_DOCUMENT:
		case RX_SQ_SENDING_PAGE:
		case RX_SQ_PAGE_SENT:
		case RX_SQ_DOCUMENT_SENT:
#if /*THINK*/ 0
		case RX_SQ_MAYBE_VOICE:
#endif
#if SUPPORT_EMAIL
	  /*case ME_SQ_WHICH_DOCUMENT: occurs lower down */
	  /*case ME_SQ_NEXT_DOCUMENT:  occurs lower down */
	  /*case ME_SQ_ERROR: occurs lower down */
		case RX_SQ_SENDING_PAGE_RANGE:
		case RX_SQ_PAGE_RANGE_SENT:
#endif
			{
				tx_States nextstate = tx_state;

				switch (tx_state)
				{
	            	case txIDLE:
	                    switch (messageNumber)
						{
							/* some outside code needs to do StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_QUERY_IDLE, NULL); */
							/* this we be ignored or cause a reply of RX_SQ_AM_IDLE                                                 */
							case RX_SQ_AM_IDLE:
								{
									BOOL              email_flag;
									char              show_number[30];	/* format we show the user */
									char              dial_number[30];	/* actual number dialled */
									messageDataBlock *sendMessage;
					
									/* is there anything to send? */
					                SendQ_NextDocument(&email_flag, &transmit_document);

					                if ((email_flag == FALSE) && (transmit_document))
					                {
#if SUPPORT_ADDRESSBOOK
										/*
										 * need:
										 *  setup_external_access_code      }
										 *  setup_international_access_code } to convert internal form of number (from fax machine or address book)
										 *  setup_national_access_code      } to dialer format
										 *  setup_fax_country_code          }
										 *  setup_fax_area_code             }
										 */
										SetupIF_Read_Phone_Config(); /*>>>will do for now*/
#endif
					                	if (transmit_document->SendRoute == RouteDIRECT)
						                {
#if SUPPORT_ADDRESSBOOK
											numconvert_internal_to_display(transmit_document->AddressRecord.DirectPhoneNumber,	/* internal format */
											                               show_number,
											                               sizeof(show_number),
											                               setup_international_access_code,		/* ip:	International prefix, eg "00" */
											                               setup_national_access_code,      	/* np:	National prefix, e.g. "0" */
											                               setup_fax_country_code,              /* cc:	Country code, e.g. "44" */
											                               setup_fax_area_code                  /* ac:	Area code, e.g. "1223" */
											                              ); 
											
											/* tell screen that if it receives RM_SC_DIALLING that it's contacting */
											/* transmit_document->AddressRecord.DirectPhoneNumber, transmit_document->AddressRecord.ContactName */
						                    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_CONTEXT_DIRECT, &sendMessage);
						                    sendMessage->data.context_direct.pid = transmit_document->ProcessId;
											strcpy(sendMessage->data.context_direct.number,  show_number);
											strcpy(sendMessage->data.context_direct.contact, transmit_document->AddressRecord.ContactName);
#else
											strcpy(show_number, transmit_document->AddressRecord.DirectPhoneNumber);											
#endif
#if KLUDGE_ROUTING
						                    if (global_routing == 0)
						                        StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_FAX, &sendMessage);
						                    else
						                    	StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_DAYTONA, &sendMessage);
#else
											if (transmit_document->AddressRecord.DeviceClass == DeviceClass_Fax)
												StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_FAX, &sendMessage);
											else
												StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_DAYTONA, &sendMessage);
#endif
#if SUPPORT_ADDRESSBOOK
								    	    numconvert_internal_to_dial(transmit_document->AddressRecord.DirectPhoneNumber,	/* in - internal format */
								    	                                dial_number,        					            /* out - dialler format */
								    	                                sizeof(dial_number),
					                                                    setup__tonepulse,                     	/* pulse/tone */
					                                                    setup_external_access_code,				/* op:	Outside line prefix, eg "" or "9" */
					                                                    setup__external_access_pausewait,		/* opp:	Outside line pause/wait after prefix eg "", "W" */
					                                                    setup_international_access_code,		/* ip:	International prefix, eg "00" */
					                                                    setup__international_access_pausewait,	/* ipp:	International pause/wait after prefix, e.g. "," */
								    	                                setup_national_access_code,      		/* np:	National prefix, e.g. "0" */
					                                                    setup_fax_country_code,                 /* cc:	Country code, e.g. "44" */
					                                                    setup_fax_area_code                     /* ac:	Area code, e.g. "1223" */
					                                                   );
#else
											strcpy(dial_number, transmit_document->AddressRecord.DirectPhoneNumber);
#endif
					                        strcpy(sendMessage->data.dial.number, dial_number);
						                /*	SetupIF_Read_Phone_Config();*/ /*>>>will do for now*/
						                	SetupIF_Read_Email_Config(); /*>>>will do for now*/

											/*REPORT: DirectDial<number>*/
											Log_TxConnecting(RouteDIRECT, &(transmit_document->Connection), show_number);

											nextstate = txDIRECTCONNECTING;
								    	}
								    }
#if SUPPORT_EMAIL
								    if ((email_flag == TRUE) && (isp_dialup.use_next >= 0) && (isp_dialup.use_next < ISP_LIST_SIZE))
								    {
					                	SetupIF_Read_Phone_Config(); /*>>>will do for now*/
					                	SetupIF_Read_Email_Config(); /*>>>will do for now*/

                                        isp_dialup.using_now = isp_dialup.use_next;
#if SUPPORT_ADDRESSBOOK
										numconvert_internal_to_display(isp_dialup.PhoneNumber[isp_dialup.using_now],  /* in - internal format */
										                               show_number,                             /* out - display format */
										                               sizeof(show_number),
										                               setup_international_access_code,		/* ip:	International prefix, eg "00" */
										                               setup_national_access_code,      	/* np:	National prefix, e.g. "0" */
										                               setup_fax_country_code,              /* cc:	Country code, e.g. "44" */
										                               setup_fax_area_code                  /* ac:	Area code, e.g. "1223" */
										                              );

								    	numconvert_internal_to_dial(isp_dialup.PhoneNumber[isp_dialup.using_now],	/* in - internal format */
								    	                            dial_number,        				    /* out - dialler format */
								    	                            sizeof(dial_number),
					                                                setup__tonepulse,                     	/* pulse/tone */
					                                                setup_external_access_code,				/* op:	Outside line prefix, eg "" or "9" */
					                                                setup__external_access_pausewait,		/* opp:	Outside line pause/wait after prefix eg "", "W" */
					                                                setup_international_access_code,		/* ip:	International prefix, eg "00" */
					                                                setup__international_access_pausewait,	/* ipp:	International pause/wait after prefix, e.g. "," */
								    	                            setup_national_access_code,      		/* np:	National prefix, e.g. "0" */
					                                                setup_fax_country_code,                 /* cc:	Country code, e.g. "44" */
					                                                setup_fax_area_code                     /* ac:	Area code, e.g. "1223" */
					                                               );
#else
                                        strcpy(show_number, isp_dialup.PhoneNumber[isp_dialup.using_now]);
					                	strcpy(dial_number, isp_dialup.PhoneNumber[isp_dialup.using_now]);
#endif

					                	isp_dialup.errors_before = 0;
#if SUPPORT_LAN
										if (setup_Ether_Lan)
										{
               								StateKicker_SendMessage(Screen_StateMachine, SQ_SC_CONTEXT_LAN, NULL);
               								
					                		StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_LAN, &sendMessage);
					                		sendMessage->data.sq_rx_dial_lan.tx_flag = (transmit_document != NULL);
#if 1
					                		sendMessage->data.sq_rx_dial_lan.rx_flag = TRUE;
#else
											sendMessage->data.sq_rx_dial_lan.rx_flag = (transmit_document == NULL);									
#endif
										}
										else
#endif
										{
							    			/* transmit_document->SendRoute is RouteISP */
							    			/* tell screen that if it receives RM_SC_DIALLING that it's contacting the ISP  */
					                		StateKicker_SendMessage(Screen_StateMachine, SQ_SC_CONTEXT_ISP, &sendMessage);
					                		strcpy(sendMessage->data.context_isp.number, show_number);

											StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_ISP, &sendMessage);
					                		sendMessage->data.sq_rx_dial_isp.tx_flag = (BOOL)(transmit_document != NULL);
					                		sendMessage->data.sq_rx_dial_isp.rx_flag = TRUE;
					                		strcpy(sendMessage->data.sq_rx_dial_isp.number, dial_number);
										}
										/* no need to call Create_Originator_File() as MimeIF builds that data into email headers */
										/*REPORT: ISPDial<number>*/
										Log_TxConnecting(RouteISP, &isp_dialup.Connection[isp_dialup.using_now], show_number);

										nextstate = txISPCONNECTING;
								    }
#endif								    
							    }
								break;
                        }
	            		break;

					case txDIRECTCONNECTING:
	                    switch (messageNumber)
						{
							case RX_SQ_DIAL_REJECTED:	/* not idle after all (incoming call) NOT counted as a failed dial attempt */
								nextstate = txIDLE;     /* Don't look for RX_SQ_GOING_IDLE (ignoring the one case where it IS sent) */
								break;
#if 0
							case RX_SQ_FAILED:
								nextstate = txIDLE;	/*>>>wait for GOING_IDLE???*/
								break;
#endif
							/* Error: unable to connect */
							case RX_SQ_ERROR:
#if 1
                                /* look for dialler errors that suggest a fax machine answered our attempted data dial-up */
								if ((messageData->data.error.ctx == ctx_Dialler_RCError)
								    &&
								    ((messageData->data.error.rc == Dialler_AbortedScript_NoCarrier /*6*/ /*no carrier*/) ||
								     (messageData->data.error.rc == Dialler_AbortedScript_Timeout   /*5*/ /*timeout*/)
								    )
								   )
                                {
									/* we sent SQ_RX_DIAL_DAYTONA, but RemModem cannot detect a carrier, */
									/* so assume the Daytona has been removed and retry as fax */
									transmit_document->AddressRecord.DeviceClass = DeviceClass_Fax;	/* NB may have been answered by voice! */
#if SUPPORT_ADDRESSBOOK
									/* tell address book that we didn't find a Daytona (either a fax machine or voice) */
                                    AddrBookIF_ModifyDeviceClass(transmit_document->AddressRecord.SerialNumber,
                                                                 transmit_document->AddressRecord.DirectPhoneNumber,
                                                                 transmit_document->AddressRecord.EmailAddress,
                                                                 transmit_document->AddressRecord.DeviceClass
                                                                );
#else
									TFax_address_remove(transmit_document->AddressRecord.DirectPhoneNumber);	/* RemModem (sending) didn't find a Daytona */
#endif
#if 1 /* PAN-01713 & PAN-01760 */
                                    /* override the usual THIRTY_SECOND or FIVE_MINUTE delay */
                                    transmit_document->Connection.RedialDelay = ONE_SECOND;   /* re-dial as soon as the hangup completes */

                                    /* a special case, don't count a failed dialup */
                                    transmit_document->Connection.RetryCount -= 1;
#endif
                                    /* override the NoCarrier/Timeout message with a highlevel 'Redialling in fax mode' message */
                                    messageData->data.error.code = code_RetryAsFax; 
                                }
#endif
                                /* now display and log the (possibly adjusted) error message */
								Screen_ReportError("Title_RX_SQ_ERROR", messageData);
								Log_TxConnectingError(RouteDIRECT, &(transmit_document->Connection), messageData);
								/* we may get more errors before RX_SQ_GOING_IDLE */
								break;

							case RX_SQ_GOING_IDLE:
								/* the send has just completed - should only happen after one or more RX_SQ_ERRORs */
								/* count a failed dialup, calculate when the next attempt should be */
								Log_TxConnectingFailed(RouteDIRECT, &(transmit_document->Connection));
								transmit_document = NULL;	/* not valid after a call to Log_TxConnectingFailed */
	                    		nextstate = txIDLE;
								break;
/*>>>should we mark transmit_document->Connection when connection finally happens? */ 



							case RX_SQ_SWITCHTO_DAYTONA:
								/* we sent SQ_RX_DIAL_FAX, but !Fax detected that the receiver is capable of ZModem transfer and switched over */
								/* if the connection fails, we should re-dial using SQ_RX_DIAL_DAYTONA */
								transmit_document->AddressRecord.DeviceClass = DeviceClass_Daytona;
#if SUPPORT_ADDRESSBOOK
								/* tell address book that we found a Daytona rather than a fax machine */ 
#else
								TFax_address_add(transmit_document->AddressRecord.DirectPhoneNumber);	/* RemXfer (sending) has found a Daytona, add it to the address list */
#endif
								break;

                            case RX_SQ_CONNECTED:
								Log_TxConnected(RouteDIRECT, &(transmit_document->Connection));	/* log successful connection to recipient */
                                nextstate = txDIRECTCONNECTED;
								break;
						}
						break;

	                case txDIRECTCONNECTED:
	                    switch (messageNumber)
						{
							case RX_SQ_SWITCHTO_DAYTONA:
								/* we sent SQ_RX_DIAL_FAX, but !Fax detected that the receiver is capable of ZModem transfer and switched over */
								/* if the connection fails, we should re-dial using SQ_RX_DIAL_DAYTONA */
								transmit_document->AddressRecord.DeviceClass = DeviceClass_Daytona;
#if SUPPORT_ADDRESSBOOK
								/* tell address book that we found a Daytona rather than a fax machine */ 
#else
								TFax_address_add(transmit_document->AddressRecord.DirectPhoneNumber);	/* RemXfer (sending) has found a Daytona, add it to the address list */
#endif
								break;

							case RX_SQ_SENDING_DOCUMENT:
								if (transmit_document)
								{
									
					transmit_document->SendState = SendRUNNING; 	/* in progress (2) */
					transmit_document->RequestTx = FALSE;	/*>>>try this*/

									/* start screen animations for direct send */
									show_Sending(transmit_document);
							    }
								break;

							case RX_SQ_SENDING_PAGE:
							    {
									messageDataBlock *sendMessage;
#if 0
	/*>>>SQ_SC_SENDING_PAGE is a better name than SQ_SC_SENDING_FAX???*/

									/* poke animation */
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_PAGE, &sendMessage);
								    sendMessage->data.sq_sc_sending_page.pid     = transmit_document->ProcessId;
								    sendMessage->data.sq_sc_sending_page.sending = transmit_document->SendCount + 1;
#else
									/* poke animation */
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_FAX, &sendMessage);
									sendMessage->data.sq_sc_sending_fax.pid     = transmit_document->ProcessId;
									sendMessage->data.sq_sc_sending_fax.sending = transmit_document->SendCount + 1;
#endif
                                    LogFileIF_show_decimal_uint(LOG_DEBUG, "RX_SQ_SENDING_PAGE page", messageData->data.rx_sq_sending_page.page); 
								}
								break;
					
							case RX_SQ_PAGE_SENT:
								{
									messageDataBlock *sendMessage;
					
									transmit_document->SendCount += 1;
#if 1
      								purge_directory(transmit_document->Directory, transmit_document->SendCount, transmit_document->SendCount);	/* use purge_directory to delete one file! */
#endif
									/* poke animation */
								    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_PAGE_SENT, &sendMessage);
								    sendMessage->data.sq_sc_page_sent.pid = transmit_document->ProcessId;
								    sendMessage->data.sq_sc_page_sent.pagesSent = transmit_document->SendCount;
								    
								    LogFileIF_show_decimal_uint(LOG_DEBUG, "RX_SQ_PAGE_SENT page", messageData->data.rx_sq_page_sent.page);
								    LogFileIF_show_decimal_uint(LOG_DEBUG, "           SendCount", transmit_document->SendCount);
								}
								break;
					
							case RX_SQ_DOCUMENT_SENT:
								{
									messageDataBlock *sendMessage;
#if 0
							        purge_directory(transmit_document->Directory, 1, transmit_document->ScanCount); /*>>>should this be done by the queue scanner*/
#endif
								    /* poke animation */
								    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DOCUMENT_SENT, &sendMessage);
								    sendMessage->data.sq_sc_document_sent.pid = transmit_document->ProcessId;
								    sendMessage->data.sq_sc_document_sent.pagesSent = transmit_document->SendCount;

                                    /*REPORT: PagesSent & status*/ 
									Log_TxSentDocument(RouteDIRECT, transmit_document);	/* log transmission of document */

								    transmit_document->SendState = SendCOMPLETE;	/* complete (3) */
								    transmit_document = NULL;	/* this handler no longer needs to reference this document */
#if 0
						NAN_document = NULL;
#endif
					            }
								break;

							/* Error: after connection */
							case RX_SQ_ERROR:
								Screen_ReportError("Title_RX_SQ_ERROR", messageData);
								/*REPORT: Error*/
								if (transmit_document)
									Log_TxConnectedErrorSendingDoc(RouteDIRECT, &(transmit_document->Connection), messageData, transmit_document);
								else
									Log_TxConnectedError(RouteDIRECT, messageData);	
								break;
#if /*THINK*/ 0
							case RX_SQ_MAYBE_VOICE:
								/* a fax error ERROR_T1_TIMEOUT before any data transfer */
								/* is probably means call answered by voice */
								/*>>>set a don't redial flag */ 
								break;
#endif
							case RX_SQ_GOING_IDLE:
								/* the send has just completed */
#if 0
                                if (transmit_document)
                                    Log_TxDisconnected(RouteDIRECT, &(transmit_document->Connection);

#endif
	                    		nextstate = txIDLE;
								break;
						}
						break;
#if SUPPORT_EMAIL
					case txISPCONNECTING:
	                    switch (messageNumber)
						{
							case RX_SQ_DIAL_REJECTED:	/* not idle (incoming call) NOT counted as a failed dial attempt */
								nextstate = txIDLE;     /* Don't look for RX_SQ_GOING_IDLE (ignoring the one case where it IS sent) */
								break;

#if 0
							case RX_SQ_FAILED:
								nextstate = txIDLE;	/*>>>wait for GOING_IDLE???*/
								break;
#endif
							/* Error: unable to connect to ISP */
							case RX_SQ_ERROR:
								Screen_ReportError("Title_RX_SQ_ERROR", messageData);
								Log_TxConnectingError(RouteISP, &isp_dialup.Connection[isp_dialup.using_now], messageData);
								isp_dialup.errors_before += 1;
								/* we may get more errors before RX_SQ_GOING_IDLE */
								break;

							case RX_SQ_GOING_IDLE:
								/* the send has just completed (ie there is was an error) */
								/* count a failed dialup, calculate when the next attempt should be */
								Log_TxConnectingFailed(RouteISP, &isp_dialup.Connection[isp_dialup.using_now]);
								isp_dialup.using_now = -1;    /* dormant */
	                    		nextstate = txIDLE;
								break;

                            case RX_SQ_CONNECTED:
					            Log_TxConnected(RouteISP, &isp_dialup.Connection[isp_dialup.using_now]);	/* log successful connection to ISP */
					            isp_dialup.use_next = -1;   /* if call fails now, reset retry counters, retry with first number */ 
								nextstate = txISPCONNECTED;
								break;
						}
	                	break;

/*
 * now that we are connected, RemXfer, based on what we told it to do, will now either:
 *  1) Send documents then RX_SQ_GOING_IDLE
 *  2) Receive mail then RX_SQ_GOING_IDLE
 *  3) Send then receive then RX_SQ_GOING_IDLE
 */
					case txISPCONNECTED:
						switch (messageNumber)
						{
							case RX_SQ_SENDING_DOCUMENT:
								/* we send multiple documents per connection, allow animation to show each recipient as emails go out */
								transmit_document = document_from_pid(messageData->data.rx_sq_sending_document.pid);
								if (transmit_document)
								{
								    Log_TxSendDocument(RouteISP, transmit_document);
								    
									/* start screen animations for email sending */
									show_Sending(transmit_document);

								    hardcopy_new_document(transmit_document);	/* may need to print (enote or eform) */
					            }
								break;
					
							case RX_SQ_SENDING_PAGE_RANGE:
							    /* poke animation */
								StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_EMAIL, NULL);
								break;
					
							case RX_SQ_PAGE_RANGE_SENT:
								transmit_document->SendCount += messageData->data.page_range_sent.hiPage - messageData->data.page_range_sent.loPage + 1;

								/* if HardCopyRequired (and document creation was successful) move the sent pages into the PrintQ */
                                hardcopy_pages_complete(transmit_document, messageData->data.page_range_sent.loPage, messageData->data.page_range_sent.hiPage);
#if 1
								/* delete pages that failed to move/delete the lot if HardCopy not required */
								purge_directory(transmit_document->Directory, messageData->data.page_range_sent.loPage, messageData->data.page_range_sent.hiPage);
#endif
								break;

							case RX_SQ_DOCUMENT_SENT:
								{
									messageDataBlock *sendMessage;

									hardcopy_document_complete(transmit_document);	/* can now be printed */
#if 0
							        purge_directory(transmit_document->Directory, 1, transmit_document->ScanCount); /*>>>should this be done by the queue scanner*/
#endif
								    /* poke animation */
								    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DOCUMENT_SENT, &sendMessage);
								    sendMessage->data.sq_sc_document_sent.pid = transmit_document->ProcessId;
								    sendMessage->data.sq_sc_document_sent.pagesSent = transmit_document->SendCount;

									Log_TxSentDocument(RouteISP, transmit_document);
									
								    transmit_document->SendState = SendCOMPLETE;	/* complete (3) */
								    transmit_document = NULL;	/* this handler no longer needs to reference this document */
#if 0
						NAN_document = NULL;
#endif
									/* we clear the isp_dialup_watermark_reached flag each time a document is sent */
									/* it may be set again by the QueueWalker if later documents require it */
									/* this means that if the line drops, we only re-dial if the QueueWalker has set the flag again */
									isp_dialup_watermark_reached = FALSE;
					            }
								break;

							case RX_SQ_ERROR:
								/* error may apply to transmit_document or the isp connection */
#if 0
								/* this tells us that we should re-dial (upto 3 times) to complete the transfer */
								isp_dial.error after connection = TRUE;
#endif
								Screen_ReportError("Title_RX_SQ_ERROR", messageData);
								if (transmit_document)
									Log_TxConnectedErrorSendingDoc(RouteISP, &isp_dialup.Connection[isp_dialup.using_now], messageData, transmit_document);
								else
									Log_TxConnectedError(RouteISP, messageData);
								break;

							case RX_SQ_GOING_IDLE:
								/* the send (if any) and retrieve (if any) has just completed */
	                    		nextstate = txIDLE;
								Log_TxDisconnected(RouteISP, &isp_dialup.Connection[isp_dialup.using_now]);
								isp_dialup.using_now = -1; /* dormant */
								break;

                        }
						break;
#endif
				} /* switch (tx_state) */

#if 0
			    /* report SQ_xx_GOING_IDLE if going idle from a non-idle state */
				if ((nextstate == txIDLE) && (tx_state != txIDLE))
					StateKicker_SendMessage(Xxxx_MessageHandler, SQ_xx_GOING_IDLE, NULL);
#endif
				tx_state = nextstate;
            }
/* end of transmitting */
#endif
			break;	/* if TRANSMITTING is FALSE, GOING_IDLE still has a break; */

#if TRANSMITTING
        case RX_SQ_WHICH_DOCUMENT:	/* implies that we have connected */
        	{
        		if (transmit_document)
				{
					messageDataBlock *sendMessage;
					
					StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_THIS_DOCUMENT, &sendMessage);
					sendMessage->data.this_document.pid = transmit_document->ProcessId;
					sendMessage->data.this_document.loText = 1;
					sendMessage->data.this_document.hiText = 0;
					sendMessage->data.this_document.loPage = transmit_document->SendCount + 1;
					sendMessage->data.this_document.hiPage = transmit_document->ScanCount;
					sendMessage->data.this_document.pageStream = (transmit_document->ScanState != ScanCOMPLETE);
					strcpy(sendMessage->data.this_document.directory, transmit_document->Directory);
                }
                
            }
            break;



#if SUPPORT_EMAIL
		case ME_SQ_WHICH_DOCUMENT:
			{
				encoding_document = transmit_document;
				if (transmit_document)
				{
					messageDataBlock *sendMessage;
#if 0
/*>>>definatly NOT needed */
					transmit_document->SendState = SendRUNNING; 	/* in progress (2) */
					transmit_document->RequestTx = FALSE;	/*>>>try this*/
#endif
			    	/* send document ProcessId & directory */
			    	StateKicker_SendMessage(MimeEncode_StateMachine, SQ_ME_THIS_DOCUMENT, &sendMessage);
			    	sendMessage->data.this_document.pid = transmit_document->ProcessId;
			    	sendMessage->data.this_document.loText = 1;
			    	sendMessage->data.this_document.hiText = 0;
			    	sendMessage->data.this_document.loPage = transmit_document->SendCount + 1;
			    	sendMessage->data.this_document.hiPage = transmit_document->ScanCount;
			    	sendMessage->data.this_document.pageStream = (transmit_document->ScanState != ScanCOMPLETE);
					strcpy(sendMessage->data.this_document.directory, transmit_document->Directory);
				}
				else
					StateKicker_SendMessage(MimeEncode_StateMachine, SQ_ME_NO_NORE_DOCUMENTS, NULL);
  	      	}
			break;

		case ME_SQ_NEXT_DOCUMENT:
			{
				encoding_document = next_email(encoding_document);
				if (encoding_document)
					{
						messageDataBlock *sendMessage;

				    	/* send document ProcessId & directory */
				    	StateKicker_SendMessage(MimeEncode_StateMachine, SQ_ME_THIS_DOCUMENT, &sendMessage);
				    	sendMessage->data.this_document.pid = encoding_document->ProcessId;
				    	sendMessage->data.this_document.loText = 1;
				    	sendMessage->data.this_document.hiText = 0;
				    	sendMessage->data.this_document.loPage = encoding_document->SendCount + 1;
				    	sendMessage->data.this_document.hiPage = encoding_document->ScanCount;
				    	sendMessage->data.this_document.pageStream = (encoding_document->ScanState != ScanCOMPLETE);
						strcpy(sendMessage->data.this_document.directory, encoding_document->Directory);
					}
				else
					StateKicker_SendMessage(MimeEncode_StateMachine, SQ_ME_NO_NORE_DOCUMENTS, NULL);
			}
			break;
			
        case ME_SQ_ERROR:
            {
                Screen_ReportError("Title_RX_SQ_ERROR", messageData);   /*>>>> Title_ME_SQ_ERROR ??? */
                if (encoding_document)
                    Log_TxEncodingError(RouteISP, messageData, encoding_document);
            }
            break;
#endif
#endif
#if TEXTUAL_EMAIL
		case EC_SQ_NEW_DOCUMENT:
			switch (HWM_Check())
			{
				case 3:
				case 2:
				case 1:
					if (SendQ_CreateDocument(&text_document) != NULL)
						status = OS_Error;
					break;

			}
			if (status == OK)
			{
				text_document->ScanState = ScanRUNNING;	/* in progress */
				/* tell EmailCreate where to put the document text */
				StateKicker_SendMessage(EmailCreate_StateMachine, SQ_EC_DOCUMENT_DIR, &sendMessage);
				sendMessage->data.new_document_dir.pid = text_document->ProcessId;
				strcpy(sendMessage->data.new_document_dir.directory, text_document->Directory);
			}
			else
				StateKicker_SendMessage(EmailCreate_StateMachine, SQ_EC_ABORT_INCOMING, NULL);	
			break;

		case EC_SQ_NEW_TEXT
			break;

		case EC_SQ_TEXT_COMPLETE:
			text_document->TextCount += 1;
			break;

		case EC_SQ_DOCUMENT_COMPLETE:
			text_document->ScanState = ScanCOMPLETE;
			text_document = NULL;	/* this handler no longer needs to reference this document */
			break;
#endif
	}
}


/*
 * The following procedures allow EnoteIF, LogFileIF and PrintQ (return receipt)
 * to add a new document to the SendQ.
 *
 *  SendQ_ExtIF_NewDocument      - create a new document (with email address and flags: hardcopy_required, request_receipt)
 *  SendQ_ExtIF_Subject          - add email subject field
 *  SendQ_ExtIF_FileComplete     - a page has been added to it
 *  SendQ_ExtIF_FileTake         - move given file into document
 *  SendQ_ExtIF_DocumentComplete - ready to send
 */

/*
 * Create a new document.
 *
 *   email address
 *   hardcopy_required - TRUE if document should be printed after being sent
 *                       N.B. When document transmission starts, a document is created in the PrintQ.
 *                            After each page is sent it is transfered to the document in the PrintQ.
 *                            When the transmission terminates, the document in the PrintQ is allowed to print.
 *                            If the transmission requires re-dials, the hardcopy will print as separate documents
 *                            reflecting the breaks in transmission.
 *
 * Returns: document pid (non-zero) and document directory name on success
 *
 * Returns: zero on failure
 */
extern unsigned int SendQ_ExtIF_NewDocument(char *p_directory, const char *email_realname, const char *email_address, BOOL hardcopy_required, BOOL request_receipt)
{
    Document document;
	
	switch (HWM_Check())
	{
		case 3:
		case 2:
		case 1:
			if (SendQ_CreateDocument(&document) == NULL)
			{
				document->ScanState = ScanRUNNING;	/* in progress */

                /* email realname and address (if any) become ContactName and EmailAddress */
                if (email_realname)
                    strcpy(document->AddressRecord.ContactName, email_realname);

                if (email_address)
				    strcpy(document->AddressRecord.EmailAddress, email_address);

				document->SendRoute = RouteISP;
				document->AddressRecord.SearchFlags = document->AddressRecord.OneShotFlags = 0;
                document->HardCopyRequired = hardcopy_required;
                /*document->HardCopyProcessID = 0; will be already*/
                document->RequestReceipt   = request_receipt;

				strcpy(p_directory, document->Directory);
				return(document->ProcessId);	/* created a new document and passed directory name to caller */
			}
			break;
	}

	return(0);	/* in-sufficient memory */
}


extern void SendQ_ExtIF_Subject(unsigned int pid, const char *email_subject)
{
	Document document;

	if ((document = document_from_pid(pid)) != NULL)
	{
		strcpy(document->EmailSubject, email_subject);
	}
}


extern void SendQ_ExtIF_FileComplete(unsigned int pid, const char *leafname, PageClasses pageClass, PageTypes pageType, int fileType)
{
	Document document;

	if ((document = document_from_pid(pid)) != NULL)
	{
		renameDLN(document->Directory, leafname, document->ScanCount + 1);
		QuCommon_Page_Complete(document, document->ScanCount + 1, pageClass, pageType, fileType);
	}
}


extern void SendQ_ExtIF_FileTake(unsigned int destination_pid, const char *source_directory, const char *source_leafname, PageClasses pageClass, PageTypes pageType, int fileType)
{
	Document document;

	if ((document = document_from_pid(destination_pid)) != NULL)
	{
		renameDLDN(source_directory, source_leafname, document->Directory, document->ScanCount + 1);
		QuCommon_Page_Complete(document, document->ScanCount + 1, pageClass, pageType, fileType);
	}
}


/*
 *
 */
extern void SendQ_ExtIF_DocumentComplete(unsigned int pid, BOOL request_tx)
{
	Document document;

	if ((document = document_from_pid(pid)) != NULL)
	{
		document->ScanState = ScanCOMPLETE;

        /* No valid To: field, so quietly chuck it on the floor */
        /* Our caller should do a similar check and report the error if it wishes too */
        if (document->AddressRecord.EmailAddress[0] == '\0')
            document->Cancelled = TRUE;

        if (request_tx)
        {
            document->RequestTx = 1;				/* requesting */
        }
	}
}


/*
 * Routines to allow SendQ to add a document, page by page to the PrintQ.
 * This allows enotes and eforms to be printed after being sent.
 *
 * The routines are a thin veneer onto PrintQ_ExtIF_NewDocument and
 * PrintQ_ExtIF_DocumentComplete.
 *
 * hardcopy_new_document      - create a document in the PrintQ
 * hardcopy_pages_complete    - move a range of pages into it
 * hardcopy_document_complete - complete and ready to print
 *
 */

static void hardcopy_new_document(Document document)
{
#if HARDCOPY_FINISHED
	char directory[256];

    if (document->HardCopyRequired)
		document->HardCopyProcessID = PrintQ_ExtIF_NewDocument(directory);	/* returns 0 on failure and non-zero PId on success */
#endif	
}


static void hardcopy_pages_complete(Document document, unsigned int loPage, unsigned int hiPage)
{
#if HARDCOPY_FINISHED
/*	_kernel_oserror *error = NULL;*/
	
	if (document->HardCopyProcessID)
	{
		unsigned int i;
		
		for (i=loPage; i<=hiPage; i++)
		{
			PageClasses pageClass;
			PageTypes pageType;
			int fileType;
			
			QuCommon_GetClassAndType(document, i, &pageClass, &pageType, &fileType);
			/*>>>error =*/ PrintQ_ExtIF_FileTake(document->HardCopyProcessID, document->Directory, i, pageClass, pageType, fileType);
		}
	}
#endif	
}


static void hardcopy_document_complete(Document document)
{
#if HARDCOPY_FINISHED
	if (document->HardCopyProcessID)
		PrintQ_ExtIF_DocumentComplete(document->HardCopyProcessID);

	document->HardCopyProcessID = 0;	/* finished with this PrintQ document */
#endif	
}


/*
 * show the ContactName produced by the address book search
 */
static void show_ContactName(Document document)
{
	messageDataBlock *sendMessage;

	/* tell Screen who the fax is for */
    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_CONTACTNAME, &sendMessage);
    sendMessage->data.sq_sc_contactname.pid = document->ProcessId;
    strcpy(sendMessage->data.sq_sc_contactname.ContactName, document->AddressRecord.ContactName);
}


/*
 * show the route number/address produced by the address book search
 */
static void show_SendRoute(Document document)	/* display debugging/user info */
{
	messageDataBlock *sendMessage;
	
	switch (document->SendRoute)
	{
		case RouteDIRECT:
    		/* tell Screen the phone number */
    		StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DISPLAYNUMBER, &sendMessage);
   		 	sendMessage->data.sq_sc_displaynumber.pid = document->ProcessId;
#if 1
            numconvert_internal_to_display(document->AddressRecord.DirectPhoneNumber,	/* internal format */
                                           sendMessage->data.sq_sc_displaynumber.DirectPhoneNumber,
                                           sizeof(sendMessage->data.sq_sc_displaynumber.DirectPhoneNumber),
                                           setup_international_access_code,     /* ip:	International prefix, eg "00" */
										   setup_national_access_code,      	/* np:	National prefix, e.g. "0" */
										   setup_fax_country_code,              /* cc:	Country code, e.g. "44" */
										   setup_fax_area_code                  /* ac:	Area code, e.g. "1223" */
										  );
#else
    		strcpy(sendMessage->data.sq_sc_displaynumber.DirectPhoneNumber, document->AddressRecord.DirectPhoneNumber);
#endif
			break;

		case RouteISP:
    		/* tell Screen the email address */
    		StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DISPLAYEMAIL, &sendMessage);
    		sendMessage->data.sq_sc_displayemail.pid = document->ProcessId;
    		strcpy(sendMessage->data.sq_sc_displayemail.EmailAddress, document->AddressRecord.EmailAddress);    
			break;
	}
}


/*
 * show start of document transmission
 */
static void show_Sending(Document document)
{
	messageDataBlock *sendMessage;
	
	StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_DOCUMENT, &sendMessage);
    sendMessage->data.sending_document.pid = document->ProcessId;
    strcpy(sendMessage->data.sending_document.ContactName, document->AddressRecord.ContactName);

	if (sendMessage->data.sending_document.ContactName[0] == '\0')
    {
    	/* ContactName field is empty, so display phone number or email address instead */

		switch (document->SendRoute)
		{
        	case RouteDIRECT:
#if 1
                /* Bug fix: RCM 1998/03/17 */
                /* leave blank, screen displays number passed with SQ_SC_CONTEXT_DIRECT for us */
#else
                /* screen displays 'Fax to 12345 on 12345' */
#if 1
                numconvert_internal_to_display(document->AddressRecord.DirectPhoneNumber,   /* internal format */
                                               sendMessage->data.sending_document.ContactName,
                                               sizeof(sendMessage->data.sending_document.ContactName),
                                               setup_international_access_code,     /* ip:	International prefix, eg "00" */
										       setup_national_access_code,      	/* np:	National prefix, e.g. "0" */
										       setup_fax_country_code,              /* cc:	Country code, e.g. "44" */
										       setup_fax_area_code                  /* ac:	Area code, e.g. "1223" */
										      );
#else
        		strcpy(sendMessage->data.sending_document.ContactName, document->AddressRecord.DirectPhoneNumber);
#endif
#endif
        		break;

            case RouteISP:
                /* ContactName field is empty, so display email address instead */
            	strcpy(sendMessage->data.sending_document.ContactName, document->AddressRecord.EmailAddress);
            	break;
            	
          /*default: string is "" */
        }
    }
}


/*
 * Accumulate scanning errors, for LogFile error reporting
 */

static void Log_RxConnectingError(messageDataBlock *messageData)
{
	char buffer[256];

    strcpy(buffer, "Connecting error: ");
    strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));

    LogFileIF_Message(buffer);
}


static void Log_RxConnectedError(messageDataBlock *messageData)
{
	char buffer[256];

    strcpy(buffer, "Scanning error: ");
    strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));

    LogFileIF_Message(buffer);
}



/*
 * Accumulate call statistics, for LogFile and error reporting
 */

static char log_tx_dial_number[30] = { 0 };
static int  log_tx_error_count = 0;

/*
 * Capture time when dialup started
 */

static void Log_TxConnecting(enum _SendRoute route, PhoneConnection *connection, const char *dial_number)
{
	char buffer[256];

	time_t now = time(NULL);

	connection->TimeDial    = now;
    connection->TimeConnect = now;
    connection->TimeEnd     = now;

    connection->RedialDelay = 30;   /* a sensible default, may be changed depending on the nature of the error */

	strcpy(log_tx_dial_number, dial_number);
	log_tx_error_count = 0;

	if (route == RouteISP)
	{
        /* we clear all the 'dial now' flags, setting a redial later flag incase the dial fails */
        /* if the dial fails, a redial will occur sometime later, or immediately if one of the  */
        /* 'dial now' flags is set again */
        if (isp_dialup_timer_request || isp_dialup_user_request)
            isp_dialup_redial_needed = TRUE;

		isp_dialup_timer_request = FALSE;
	    isp_dialup_user_request = FALSE;

        /* log the connection attempt */
		strcpy(buffer, "Dialling ISP on ");
		strncat(buffer, dial_number, sizeof(buffer));

		LogFileIF_Message(buffer);
	}
}

/*
 * Capture the first error that occurs prior to connection
 */
static void Log_TxConnectingError(enum _SendRoute route, PhoneConnection *connection, messageDataBlock *messageData)
{
	char buffer[256];
	/* There should be one error report, followed by our going idle */
    /* if multiple errors arrive, we capture the first only */
	if (log_tx_error_count == 0)
	{
		if (route == RouteDIRECT)
		{
        	strcpy(buffer, "S ");
			strncat(buffer, log_tx_dial_number, sizeof(buffer));

			strncat(buffer, " Error connecting ", sizeof(buffer));
			strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));
        }
        else
        {
			/* ISP phone number already reported */
			
			strcpy(buffer, "Error connecting ");
			strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));        
        }

		LogFileIF_Message(buffer);
	}
#if 1
    switch (messageData->data.error.code)
    {
        case code_NoDialTone:
            connection->RedialDelay = FIVE_MINUTES;
            LogFileIF_show_decimal_uint(LOG_DEBUG, "No dial tone, seconds to retry", connection->RedialDelay);
            break;

        case code_LineBusy:
            if (connection->RetryCount == 0)
                connection->RedialDelay = 30;
            else
                connection->RedialDelay = FIVE_MINUTES;

            LogFileIF_show_decimal_uint(LOG_DEBUG, "Line busy, seconds to retry", connection->RedialDelay);    
            break;

    }
#endif
	log_tx_error_count++;	
}


/*
 * Report the failure to connect and the reason
 *
 * Also performs RetryCount-ing operations for the redial logic
 * used by QueueWalker.
 */
static void Log_TxConnectingFailed(enum _SendRoute route, PhoneConnection *connection)
{
	char buffer[256];

	time_t now = time(NULL);

	connection->TimeConnect = now;	/* } ie zero connection time */
	connection->TimeEnd     = now;  /* }                         */

	connection->RetryCount += 1;	/* count the dial attempt */	
    connection->RetryTime   = now + connection->RedialDelay;    /* usually THIRTY_SCEONDS or FIVE_MINUTES */

	if (route == RouteISP)
	{
        /* if any of the 'dial now' flags were set after dialling started, turn them into dial later request */
        /* the redial will occur sometime later, or immediately if one of the 'dial now' flags is set again */
        if (isp_dialup_timer_request || isp_dialup_user_request)
            isp_dialup_redial_needed = TRUE;
            
		isp_dialup_timer_request = FALSE;
	    isp_dialup_user_request = FALSE;
	}

	/*>>>Report the failure to the screen and LogFile */
	/* Fax call to <number> failed <reason> */
    /* ISP dialup on <number> failed <reason> */

	if (log_tx_error_count == 0)
	{
		if (route == RouteDIRECT)
		{
        	strcpy(buffer, "S ");
			strncat(buffer, log_tx_dial_number, sizeof(buffer));

			strncat(buffer, " Error connecting", sizeof(buffer));	/* !!! RX_SQ_GOING_IDLE received, but no error logged !!! */
		}
    	else
		{
			/* ISP phone number already reported */

			strcpy(buffer, "Error connecting");	/* !!! RX_SQ_GOING_IDLE received, but no error logged !!! */
		}

        LogFileIF_Message(buffer);
        log_tx_error_count++;
	}
}


/*
 * ISP dialups generate multiline reports, report the successful connection
 */

static void Log_TxConnected(enum _SendRoute route, PhoneConnection *connection)
{
	time_t now = time(NULL);

	connection->TimeConnect = now;
	connection->TimeEnd     = now;


	log_tx_error_count = 0;	/* unlikely not to be zero */

	if (route == RouteISP)
	{
#if 1
   /*>>>*/         /* this should only be cleared when the download has finished */
			isp_dialup_redial_needed = FALSE;
#endif                            



		/*>>>Report connection to ISP*/
		/*REPORT <connection->TimeConnect> Connected to ISP*/
	    LogFileIF_show(LOG_VERBOSE, "Connected OK");
	}
}


static void strncat_recipient(char *buffer, enum _SendRoute route, Document document, int bufsize)
{
    if (document->AddressRecord.ContactName[0] != '\0')
    {
        strncat(buffer, document->AddressRecord.ContactName, bufsize);
        strncat(buffer, " ", bufsize);
    }

    if (route == RouteDIRECT)
    {
        strncat(buffer, "(", bufsize);    
		strncat(buffer, log_tx_dial_number, bufsize);
		strncat(buffer, ")", bufsize);
    }
    else
    {
        strncat(buffer, "(", bufsize);
		strncat(buffer, document->AddressRecord.EmailAddress, bufsize);
		strncat(buffer, ")", bufsize);    
    }
}


static void strncat_time(char *buffer, time_t seconds, int bufsize)
{
    char convert[256];

    if (seconds < 60)
        sprintf(convert, "%ds", seconds);
    else
    {
        int minutes = seconds / 60;
        seconds = seconds % 60;

        if (minutes < 60)
            sprintf(convert, "%dm%2ds", minutes, seconds);
        else
        {
            int hours = minutes / 60;
            minutes = minutes % 60;

            sprintf(convert, "%dh%2dm%2ds", hours, minutes, seconds);
        }
    }

    strncat(buffer, convert, bufsize);
}


static void strncat_page_count(char *buffer, int page_count, int bufsize)
{
    char numbuff[128];

    sprintf(numbuff, "%d page(s)", page_count);
    strncat(buffer, numbuff, bufsize);
}


static void Log_TxConnectedErrorSendingDoc(enum _SendRoute route, PhoneConnection *connection, messageDataBlock *messageData, Document document)
{
	char buffer[256];

	if (log_tx_error_count == 0)
	{
		strcpy(buffer, "S ");

        strncat_recipient(buffer, route, document, 128);

		strncat(buffer, " Error ", sizeof(buffer));
		strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));

        LogFileIF_Message(buffer);
    }

	log_tx_error_count++;
}


static void Log_TxConnectedError(enum _SendRoute route, messageDataBlock *messageData)
{
	char buffer[256];

	if (log_tx_error_count == 0)
	{
		if (route == RouteDIRECT)
		{
        	strcpy(buffer, "S ");
			strncat(buffer, log_tx_dial_number, 128);

			strncat(buffer, " Error ", sizeof(buffer));
			strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));
		}
        else
        {
        	strcpy(buffer, "S ");
			strncat(buffer, " Error ", sizeof(buffer));
			strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));        	
        }

        LogFileIF_Message(buffer);
    }

	log_tx_error_count++;
}


static void Log_TxSendDocument(enum _SendRoute route, Document document)
{
    if (route == RouteISP)
    {
        time_t now = time(NULL);

        document->Connection.TimeDial    = isp_dialup.Connection[isp_dialup.using_now].TimeDial;  /* do we care? */
        document->Connection.TimeConnect = now;
        document->Connection.TimeEnd     = now;
    }
}


static void Log_TxSentDocument(enum _SendRoute route, Document document)
{
	char buffer[256];

	if (log_tx_error_count == 0)
	{
	    time_t now = time(NULL);

        document->Connection.TimeEnd = now;

        strcpy(buffer, "S ");
        strncat_recipient(buffer, route, document, 128);
        strncat(buffer, " ", sizeof(buffer));
        strncat_page_count(buffer, document->SendCount, sizeof(buffer));

        strncat(buffer, " ", sizeof(buffer));
        strncat_time(buffer, document->Connection.TimeEnd - document->Connection.TimeConnect, sizeof(buffer));
        /* above relies on Log_TxSendDocument() setting Connection.TimeConnect to: */
        /*   a (RouteDIRECT) - to time that a connection is established         OR */
        /*   b (RouteISP)    - to time that transmission of this document started  */

		strncat(buffer, " OK", sizeof(buffer));

		LogFileIF_Message(buffer);        			
	}
#if 0
	/* switch in when HANGUP followed by immediate dial failure is fixed */
	connection->RetryTime   = time(NULL) + 30;	/*now() + something(connection->RetryCount);*/	
#endif
}


static void Log_TxDisconnected(enum _SendRoute route, PhoneConnection *connection)
{
	time_t now = time(NULL);

	connection->TimeEnd = now;

    if (route == RouteISP)
    {
        char buffer[256];
        
        isp_dialup_timer_request = FALSE;   /* timer and user requests to dial the ISP received  */
        isp_dialup_user_request = FALSE;    /* during a connection to the ISP are ignored        */
      /*isp_dialup_redial_needed = FALSE;*/

        strcpy(buffer, "Disconnected from ISP OK");
        strncat(buffer, " ", sizeof(buffer));
        strncat_time(buffer, connection->TimeEnd - connection->TimeConnect, sizeof(buffer));

        LogFileIF_Message(buffer);
    }
}


static void Log_TxEncodingError(enum _SendRoute route, messageDataBlock *messageData, Document document)
{
	char buffer[256];

    strcpy(buffer, "S ");

    strncat_recipient(buffer, route, document, 128);

	strncat(buffer, " Error ", sizeof(buffer));
	strncat(buffer, messageData->data.os_error.err.errmess, sizeof(buffer));

    LogFileIF_Message(buffer);
}


static BOOL connection_impossible(enum _SendRoute route, PhoneConnection *connection)
{
	/* NB we require SetupIF to ensure (*connection->RetryLimit) >= 1 for setup_phone_fax_redial_count */
	if (connection->RetryCount >= (*connection->RetryLimit))
		return(TRUE);	/* exhausted our dial-up limit and still not got through! */

    return(FALSE);
}


static BOOL connection_requested_now(enum _SendRoute route, PhoneConnection *connection)
{
	if (connection->RetryTime <= time(NULL))
		return(TRUE);

	return(FALSE);
}



static Document SendQ_Document_Queue = NULL;

static _kernel_oserror *SendQ_CreateDocument(Document *p_document)
{
	static unsigned int dir_num = 0;
	static unsigned int doc_num = 0;	/* not a valid document number */

	_kernel_oserror    *error = NULL;
	Document 			document = NULL;
	char    			directory[212];

	*p_document = NULL;		/* in case we return an error */	

	/* be tidy, zero the directory name whenever the queue empties */
	if (SendQ_Document_Queue == NULL)
		dir_num = 0;

	document = malloc(sizeof(DocumentRec));
    if (document)
    {
        memset(document, 0, sizeof(DocumentRec));   /* zero initialise whole block */

    	sprintf(directory, "%s.%d", DIRECTORY_SENDQ, dir_num);
        dir_num++;

        if ((error = os_create_directory(directory)) != NULL)
        {
        	/* unable to create directory */
        	free(document);		/* free the document record we created */
        	return(error);		/* return the error */
        }
    }

	if (document)
	{
		/* created document record and a directory for the document - now fill the record */

    	document->ProcessId = UniquePId();		/* non-zero, unique across both SendQ and PrintQ */
	    strcpy(document->Directory, directory); /* fullname of the directory we created */

		/* assign a unique document number to everything we send */
		++doc_num;
		if (doc_num == 0)
			doc_num = 1;		/* never allocate zero, even if we wrap! */

	    document->DocumentNo = doc_num;   		/* non-zero, unique to SendQ, no relation to ProcessId */
    	*document->CapturedPhoneNumber = '\0';  /* not yet captured from fax machine */
    	*document->AddressRecord.EmailAddress = '\0';         /* not yet returned by the address book */
    	strcpy(document->EmailSubject, "Fax from Daytona");	/* a good default */
    	*document->AddressRecord.DirectPhoneNumber   = '\0';  /* not yet returned by the address book */
    	*document->AddressRecord.ContactName = '\0';          /* not yet returned by the address book */
    	document->AddressRecord.DeviceClass = DeviceClass_Fax;
    	document->AddressRecord.LocalRouting = RouteUNKNOWN;
    	document->SendRoute = RouteUNKNOWN;
    	document->ReRouteAvailable = FALSE;
    	document->ReRouting = FALSE;

        document->HardCopyRequired = FALSE;		/* set TRUE for notes & forms if hardcopy required */
        document->HardCopyProcessID = 0;		/* no PrintQ document */

        document->RequestReceipt = FALSE;       /* set TRUE for notes & forms if receipt required */

	    document->ScanState = ScanIDLE;			/* idle (0) */
    	document->ScanCount = 0;				/* no pages received yet */
    	document->PageList  = NULL;				/* so no classes or types */
    	document->TotalSize = 0;                /* no space taken by pages (neglecting directory overheads) */
    	document->BiggestPage = 0;
#if 0
    	document->TextCount = 0;
#endif
   	    document->RequestTx = FALSE;
    	document->SendState = SendIDLE;			/* idle (0) */
    	document->SendCount = 0;                /* no pages transmitted yet */
	    document->Cancelled = FALSE;
	    document->Suspended = FALSE;
	    document->Connection.RetryLimit = &setup_phone_fax_redial_count;	/* address not value, so changes in setup will be seen */
	    document->Connection.RetryCount = 0;	/* not yet tried to direct dial */
	    document->Connection.RetryTime = time(NULL);	/* time now, to trigger dial as soon as document needs it */
		document->SearchRef = 0;                /* address book search ref */
		document->AddressRecord.SearchFlags  = ADDRBOOKIF_SEARCH_FLAGS;   /* } Search complete when either */
        document->AddressRecord.OneShotFlags = ADDRBOOKIF_ONESHOT_FLAGS;	/* } of these clears to zero     */

        /* link document record to the tail of the queue */
		if (SendQ_Document_Queue == NULL)
			document->next_document = document;	/* first and only document, so point next field at ourselves */
		else
		{
        	document->next_document = SendQ_Document_Queue->next_document;	/* point to head of queue */
        	SendQ_Document_Queue->next_document = document;	/* old last item becomes last-but-one (we are the last) */
        }
        SendQ_Document_Queue = document;		/* point to tail of queue, our next_document field points to the head */

        *p_document = document;
	}

    return(NULL);
}


/*
 * The heart of the queue.
 *
 * Examine each document and act on significant state changes.
 *   ie Schedule completed documents for delivery (direct call or via ISP) 
 *      Schedule incomplete documents for streamed delivery when watermarks require it
 *      Re-route documents whoses the primary delivery route fails
 *      Delete successfully sent documents
 *      Delete unsent documents when  all available routes haves failed
 *
 *  In:
 *    isp_unavailable - TRUE if emails should be re-routed as faxes
 *
 *  Out:
 *    sending_already - pointer to document being sent (if any)
 *    send_next          - first document scheduled for direct transfer
 *    send_next_RouteISP - first document scheduled for email transfer
 */

static Document sending_already = NULL;
static Document send_next       = NULL;
static Document send_next_RouteISP = NULL;

extern void SendQ_QueueWalker(BOOL isp_unavailable)
{
	sending_already = NULL;
	send_next       = NULL;
	send_next_RouteISP = NULL;

    isp_dialup_watermark_reached = FALSE;
    
	if (SendQ_Document_Queue)
    {
		/* one or more items in the queue */
    	/* SendQ_Document_Queue points to the last record in the queue, the last record points at the first (which maybe its-self) */

        Document previous = SendQ_Document_Queue;		/* last item in queue */
        Document document;
        
		do
			{
				BOOL delete_it = FALSE;
				
				document = previous->next_document;	/* first/next item in queue */

				if (document->SendState == SendCOMPLETE)
				{
		        	if ((document->ScanState == ScanCOMPLETE) && (document->SendCount == document->ScanCount))
		        		delete_it = TRUE;	/* scan has completed and all scanned pages have been sent */
		            else
		            	document->SendState = SendIDLE; 	/* scan still in progress, or some pages not sent, so allow for later send of rest of document */
		        }
			
				if (document->SendState == SendIDLE)
				{
		        	if ((document->ScanState == ScanCOMPLETE) && (document->SendCount == document->ScanCount))
		        		delete_it = TRUE;	/* scan has completed, there are no (or no more) pages to send */

                    if ((document->ScanState == ScanCOMPLETE) && (document->Cancelled))
                    	delete_it = TRUE;	/* scan has completed, and (user has confirmed cancel request or we've decided to cancel) */
		        }

				if (!delete_it)
				{
		        	if (document->SendState == SendRUNNING)
		        		sending_already = document;			/* this document is already being sent */		
		            else
		            	{
		            		if (((document->RequestTx) || (document->ScanState == ScanCOMPLETE)) &&
		            		    (document->Cancelled == FALSE) && (document->Suspended == FALSE) &&
		            		    ((document->AddressRecord.SearchFlags == 0) || (document->AddressRecord.OneShotFlags == 0))	/* search completed either as expected or as a 'One shot' */
		            		   )
		            		{
								switch (document->SendRoute)
								{
									case RouteDIRECT:
                                        if (connection_impossible(RouteDIRECT, &(document->Connection)))
                                        {
                                        	/* we've dialled document->AddressRecord.DirectPhoneNumber many times and failed to get through */
                                        	if (document->ReRouteAvailable)
                                        	{
                                        		/*REPORT: unable to direct dial fax, re-rerouting via ISP */
                                        		document->ReRouteAvailable = FALSE;     /* using */
                                        		document->ReRouting = TRUE;				/* alternate route */
                                        		document->SendRoute = RouteISP;         /* via ISP */
#if 0
                                                isp_dialup_watermark_reached = TRUE;	/* trigger a DIAL_ISP, which will send all the queued emails */
#else
                                        		document->RequestTx = TRUE;             /* sent ASAP */
#endif
                                        	}
                                        	else
                                        	{
                                        		/*REPORT: unable to deliver this*//* alternate route failed */
                                        		document->Cancelled = TRUE;
                                        	}
                                        }
                                        else
                                        {
                                        	if (connection_requested_now(RouteDIRECT, &(document->Connection)))
                                        	{
				            					if (send_next == NULL)
				            						send_next = document;
				            				}
				            			}
				            			break;

				            		case RouteISP:
				            			/* don't use connection_impossible(RouteISP, &isp_dialup.Connection[isp_dialup.use_next] as our   */
				            			/* caller uses it and always leaves structure isp_dialup looking as if connection would work */
										if (isp_unavailable)
				            			{
				            				
				            				/* we've dialled the ISP many times on many numbers and failed to get through */
				            				if (document->ReRouteAvailable)
				            				{
				            					/*REPORT: unable to contact ISP, re-routing as a direct dial call */
					            				document->ReRouteAvailable = FALSE;     /* using */
                                        		document->ReRouting = TRUE;				/* alternate route */
                                        		document->SendRoute = RouteDIRECT;      /* direct dial */
   				            				}
				            				else
				            				{
                                        		/*REPORT: unable to deliver this*//* alternate route failed */
                                        		document->Cancelled = TRUE;
				            				}
				            			}
				            			else
					            		{
					            			if (send_next_RouteISP == NULL)
					            				send_next_RouteISP = document;
	
											if (document->RequestTx)
												isp_dialup_watermark_reached = TRUE;	/* trigger a DIAL_ISP, which will send all the queued emails */	
										}
				            			break;
				            	}		
		            		}
		            	}
	        	}
#if NEWCODE
				if (((document->SendState == SendIDLE) && (document->Cancelled)) || delete_it)
				{
                    if (document->SendCount < document->ScanCount)
                    {
                    	document->SendCount++;
                    	remove_fileDN(document->Directory, document->SendCount);
                    	delete_it = FALSE;	/* ensure directory is deleted on the next pass */
                    }

					if ((document->SendCount < document->ScanCount) || (document->ScanState != ScanCOMPLETE))
					{
						/* still files left to delete, or scanning still in progress, so mustn't unlink */
						delete_it = FALSE;
					}
				}
#endif

				if (delete_it)
				{
	                if (document == previous)
	                {
	                	/* one document only in the queue, and we are deleting it! */
	                    previous = NULL;

	                    if (SendQ_Document_Queue == document) /* always TRUE */
	                    	SendQ_Document_Queue = previous;
	                }
	                else
	                {
	                	/* cut document from the circular queue */
	                	previous->next_document = document->next_document;
	                	
	                    if (SendQ_Document_Queue == document)
	                    	SendQ_Document_Queue = previous;	/* deleting last item in queue, so point queue at last but one entry */
	                }
/*>>>delete any pages left by failed/cancelled faxes */
                    os_destroy_directory(document->Directory);
                    free(document);

                    document = previous;
                }
	            else
	            {
	            	previous = document;	/* ready to go around the loop */
	            }
            }
	    while (document != SendQ_Document_Queue);    
	}
}

/*
 * SendQ_NextDocument - identify the next document ready send
 */
static void SendQ_NextDocument(BOOL *p_email_flag, Document *p_document)
{

	if (isp_dialup_timer_request || isp_dialup_user_request ||
	    ((isp_dialup_redial_needed || isp_dialup_watermark_reached) && connection_requested_now(RouteISP, &isp_dialup.Connection[isp_dialup.use_next]))
	   )
	{
		*p_email_flag = TRUE;
		*p_document   = send_next_RouteISP;	/* maybe NULL */	
    }
    else
    {
		*p_email_flag = FALSE;
    	*p_document = send_next;	/* maybe NULL */
    }
}


static Document document_from_pid(unsigned int pid)
{
	if (SendQ_Document_Queue)
	{
		Document document = SendQ_Document_Queue;		/* last item in queue */
		/* the pid is usually that of the first or last document, so we */
        /* allow our search to start with the tail element, followed by the head element */
        /* instead of the expected head first search */
		do
			{
				if (document->ProcessId == pid)
					return(document);

				document = document->next_document;	/* first/next item in queue */
			}
		while (document != SendQ_Document_Queue);		
	}

	return(NULL);	/* not found!!! */
}


/*
 * Given current document, find the next document to email
 */
static Document next_email(Document document)
{
	if ((document != NULL) && (document != SendQ_Document_Queue))
    {
		do
			{
				document = document->next_document;	/* next item in queue */

				if (document->SendRoute == RouteISP)
					return(document);
			}
		while (document != SendQ_Document_Queue);
    }
    
	return(NULL);	/* no more documents to email */
}


static Document document_from_SearchRef(int SearchRef)
{
	if (SendQ_Document_Queue)
	{
		Document document = SendQ_Document_Queue;		/* last item in queue */
		/* the SearchRef is usually that of the first or last document, so we */
        /* allow our search to start with the tail element, followed by the head element */
        /* instead of the expected head first search */
		do
			{
				if (document->SearchRef == SearchRef)
					return(document);

				document = document->next_document;	/* first/next item in queue */
			}
		while (document != SendQ_Document_Queue);		
	}

	return(NULL);	/* not found!!! */
}


extern AddressRec *SendQ_AddressRecord_from_pid(unsigned int pid)
{
	Document document;

	if ((document = document_from_pid(pid)) != NULL)
		return(&document->AddressRecord);

	return(NULL);	/* not found!!! */
}


extern AddressRec *SendQ_AddressRecord_from_SearchRef(int SearchRef)
{
	Document document;

	if ((document = document_from_SearchRef(SearchRef)) != NULL)
		return(&document->AddressRecord);

	return(NULL);	/* not found!!! */
}

extern void SendQ_emailaddress_from_pid(char *buffer, unsigned int pid)
{
	Document document;
	
	*buffer = '\0';

	if ((document = document_from_pid(pid)) != NULL)
	{
		strcpy(buffer, document->AddressRecord.EmailAddress);
    }
}


extern void SendQ_contactname_from_pid(char *buffer, unsigned int pid)
{
	Document document;
	
	*buffer = '\0';

	if ((document = document_from_pid(pid)) != NULL)
	{
		strcpy(buffer, document->AddressRecord.ContactName);
    }
}


extern void SendQ_subject_from_pid(char *buffer, unsigned int pid)
{
	Document document;
	
	*buffer = '\0';

	if ((document = document_from_pid(pid)) != NULL)
	{
		strcpy(buffer, document->EmailSubject);
    }
}


extern void SendQ_documentnumber_from_pid(unsigned int *p_document_number, unsigned int pid)
{
	Document document;
	
	*p_document_number = 0; /* not a valid document number */

	if ((document = document_from_pid(pid)) != NULL)
    {
		*p_document_number = document->DocumentNo;
    }
	
}


extern void SendQ_requestreceipt_from_pid(BOOL *p_request_receipt, unsigned int pid)
{
    Document document;

    if ((document = document_from_pid(pid)) != NULL)
    {
        *p_request_receipt = document->RequestReceipt;
    }
}


extern void SendQ_PageList_from_pid(PageRangeList *p_last_entry, unsigned int pid)
{
	Document document;

	*p_last_entry = NULL;	/* not a valid document */

	if ((document = document_from_pid(pid)) != NULL)
		*p_last_entry = document->PageList;
}


extern BOOL SendQ_Page_ClassTypeSize(unsigned int pid, unsigned int pageNum,
                                     PageClasses *pPageClass, PageTypes *pPageType, int *pFileSize)
{
    Document document;

    if ((document = document_from_pid(pid)) != NULL)
    {
        int fileType;
        if (QuCommon_GetClassAndType(document, pageNum, pPageClass, pPageType, &fileType) == 0)
        {
            char current_page_leafname[32];
            _kernel_oserror *error = NULL;
            int objecttype, filetype;

            sprintf(current_page_leafname, "%d", pageNum);            
            error = osfile_ReadCatInfoDL(document->Directory, current_page_leafname, &objecttype, pFileSize, &filetype);    
            if ((error == NULL) && (objecttype == 1/*file found*/))
                return(0);  /* OK - page exists and *pPageClass, *pPageType and *pFileSize filled in */
        }
    }

    return(1);  /* Error: page doesn't exist */
}


/*
 * Return the current scan count for a document
 *
 * This routine is valid for both streaming and non-streaming document sends.
 *
 * Used by RemXfer to querry the current highest page number
 * that it can send whilst streaming.
 *
 * In:
 *   Process Id of document
 *
 * Out:
 *  =0 - document not found or no pages scanned
 *  >0 - number of complete pages scanned (and hence highest page
 *       available to be sent
 */
extern unsigned int SendQ_QuerryTx_hiPage(unsigned int pid)
{
    Document document;

    if ((document = document_from_pid(pid)) != NULL)
    {
        return(document->ScanCount);
    }

    return(0);
}



/*
 * Examine the SendQ plus various flags to determine
 * whether a document send or email retrieve should
 * be attempted.
 */
extern void SendQ_TickerHandler(void)
{
	BOOL isp_unavailable = FALSE;	/* optomistic aren't we */

    if (isp_dialup.using_now <= -1)
    {
        /* not accessing ISP at the moment */
    
       	if (isp_dialup.use_next <= -1)
       	{
       		/* initialise ISP PhoneNumbers, RetryCounts & RetryLimits etc */
       		int i;
       		time_t now = time(NULL);
       		
       		for (i = 0; i < ISP_LIST_SIZE; i++)
       		{
       		    switch (i)
       		    {
                    default:
                        /* SHOULD NEVER HAPPEN - ISP_LIST_SIZE is 2 ie 0..1 are valid indexices */
                        /* drop into... */
       		        case 0:
                        isp_dialup.Connection[i].RetryLimit = &setup_ISP_PrimaryRedialCount;
                        isp_dialup.PhoneNumber[i] = setup_ISP_PrimaryPhoneNumber;
                        break;
    
                    case 1:
                        isp_dialup.Connection[i].RetryLimit = &setup_ISP_SecondaryRedialCount;
                        isp_dialup.PhoneNumber[i] = setup_ISP_SecondaryPhoneNumber;
                        break;
                }
       			isp_dialup.Connection[i].RetryCount = 0;	/* haven't tried this number yet */
       			isp_dialup.Connection[i].RetryTime  = now;
            }
    
            /* start with the Primary route (first number) */
    		isp_dialup.use_next = 0;
    	}
    
        /*
         * If the first number is viable, stay with it,
         * else consider the next number available.
         */
        isp_dialup.use_next = 0;    /* The user may increment the retry count for the first number while we are waiting to try */
                                    /* the second number. Zeroing this index, allows us to try the first number again. */
        while (isp_dialup.use_next < ISP_LIST_SIZE)
        {
    		if (connection_impossible(RouteISP, &isp_dialup.Connection[isp_dialup.use_next]))
    		{
    			/* try alternate ISP phone number */
    			isp_dialup.use_next++;
    	    }
    	    else
    	    {
    	        /* we have a number we can use */
    	        break;
    	    }
        }
        
    	if (isp_dialup.use_next >= ISP_LIST_SIZE)
    	{
    		/* unable to contact ISP by any of the known routes - send by direct routing if available */
    		isp_dialup.use_next = -1;	/* initialisation required */
    		isp_unavailable = TRUE;
    	}
    }
#if 0
    /* redundent */
	if (isp_dialup.use_next == -1)
    	isp_unavailable = TRUE;	/* despite our best efforts, the ISP is un-useable */
#endif

	if (1 /*maybe_idle*/)	/* don't use maybe_idle flag until everything reports GOING_IDLE correctly! */
	{
		BOOL     email_flag;
		Document send_next;
		
		SendQ_QueueWalker(isp_unavailable); /* if ISP unavailable, email will be re-routed if possible */

		if (isp_unavailable)
		{
            /* MUST clear all the ISP_DIALUP_xxxx flags that SendQ_NextDocument looks at */    
            isp_dialup_timer_request = FALSE;
			isp_dialup_user_request = FALSE;

            isp_dialup_redial_needed = FALSE;
            isp_dialup_watermark_reached = FALSE;   /* incase a direct fax was rerouted as email */   
		}
		
        SendQ_NextDocument(&email_flag, &send_next);
	
		/* if not already sending, send the next one ready to go */
		if ((sending_already == NULL) &&
		    ((send_next != NULL) || (email_flag == TRUE))
		   )
		{
			maybe_idle = FALSE;	/* assume no response to message */
  			StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_QUERY_IDLE, NULL);

	        /* deliver the queued messages */
            while (StateKicker_Deliver() > 1)
    	        /* null statement */;
        }
	}

    if (user_request_cancel_fax)
    {
        user_request_cancel_fax = FALSE;

        StateKicker_SendMessage(SendQ_MessageHandler, UI_SQ_CANCEL, NULL);
        
	    /* deliver the queued messages */
        while (StateKicker_Deliver() > 1)
    	    /* null statement */;
    }
}







_kernel_oserror *os_create_directory(const char *name)
{
  _kernel_oserror *error;
  _kernel_swi_regs r;

  r.r[0] = 8;           /* Create a directory */
  r.r[1] = (int)name;
  r.r[2] = 0;
  r.r[3] = 0;
  r.r[4] = 76;          /* give us 76 entries (ignored by Filecore) */

  error = _kernel_swi(OS_File, &r, &r);

  return(error);
}

_kernel_oserror *os_destroy_directory(const char *name)
{
#if NEWCODE
	_kernel_oserror *error;
	_kernel_swi_regs r;

	r.r[0] = 6;
	r.r[1] = (int)name;

	error = _kernel_swi(OS_File, &r, &r);
	return(error);
#else
/*>>>must write this one day*/
	return(NULL);
#endif	
}


extern _kernel_oserror *osfile_ReadCatInfo(const char *fullname, int *pobjecttype, int *pobjectlength, int *pfiletype)
{
  _kernel_swi_regs r;
  _kernel_oserror  *error;

  /* Read catalogue info for named object (no path used) */
  r.r[0] = 23;
  r.r[1] = (int)fullname;
  error = _kernel_swi(OS_File, &r, &r);

  if (error == NULL)
  {
    *pobjecttype   = r.r[0];	/* 0=not found, 1=file found, 2=directory found, 3=image file found */
    *pobjectlength = r.r[4];	/* object length */
    *pfiletype     = r.r[6];	/* object filetype */
  }
  else
  {
  	*pobjecttype   = 0;			/* not found */
  	*pobjectlength = 0;   		/* object length zero bytes */
    *pfiletype     = -1;    	/* untyped */
  }

  return(error);
}


extern _kernel_oserror *osfile_ReadCatInfoDL(const char *directory, const char *leafname, int *pobjecttype, int *pobjectlength, int *pfiletype)
{
	char fullname[256];

  	strcpy(fullname, directory);
  	strcat(fullname, ".");
  	strcat(fullname, leafname);

	return(osfile_ReadCatInfo(fullname, pobjecttype, pobjectlength, pfiletype));
}


extern _kernel_oserror *set_filetype(const char *fullname, int filetype)
{
  _kernel_oserror *error;
  _kernel_swi_regs r;

  r.r[0] = 18;		/* set filetype (and date/time stamp if not set already */
  r.r[1] = (int)fullname;
  r.r[2] = filetype;

  error = _kernel_swi(OS_File, &r, &r);
  return(error);
}


extern _kernel_oserror *set_filetypeDL(const char *directory, const char *leafname, int filetype)
{
  char fullname[256];

  strcpy(fullname, directory);
  strcat(fullname, ".");
  strcat(fullname, leafname);

  return(set_filetype(fullname, filetype));
}


extern _kernel_oserror *set_filetypeDN(const char *directory, const unsigned int leafnumber, int filetype)
{
	char fullname[256];

	sprintf(fullname, "%s.%d", directory, leafnumber);
    return(set_filetype(fullname, filetype));
}


extern _kernel_oserror *renameDLN(const char *directory, const char *from_leafname, const unsigned int to_leafnumber)
{
	char command[256];
	
	sprintf(command, "Rename %s.%s %s.%d", directory, from_leafname, directory, to_leafnumber);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *renameDLDL(const char *from_directory, const char *from_leafname, const char *to_directory, const char *to_leafname)
{
	char command[256];
	
	sprintf(command, "Rename %s.%s %s.%s", from_directory, from_leafname, to_directory, to_leafname);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *renameDNDL(const char *from_directory, const unsigned int from_leafnumber, const char *to_directory, const char *to_leafname)
{
	char command[256];
	
	sprintf(command, "Rename %s.%d %s.%s", from_directory, from_leafnumber, to_directory, to_leafname);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *renameDLDN(const char *from_directory, const char *from_leafname, const char *to_directory, const unsigned int to_leafnumber)
{
	char command[256];
	
    sprintf(command, "Rename %s.%s %s.%d", from_directory, from_leafname, to_directory, to_leafnumber);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *renameDNDN(const char *from_directory, const unsigned int from_leafnumber, const char *to_directory, const unsigned int to_leafnumber)
{
	char command[256];
	
	sprintf(command, "Rename %s.%d %s.%d", from_directory, from_leafnumber, to_directory, to_leafnumber);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *remove_file(const char *fullname)
{
	_kernel_oserror *error;
	_kernel_swi_regs r;

	r.r[0] = 6;
	r.r[1] = (int)fullname;

	error = _kernel_swi(OS_File, &r, &r);
	return(error);
}


extern _kernel_oserror *remove_fileDL(const char *directory, const char *leafname)
{
	char fullname[256];

	sprintf(fullname, "%s.%s", directory, leafname);
	return(remove_file(fullname));
}


extern _kernel_oserror *remove_fileDN(const char *directory, const unsigned int leafnumber)
{
	char fullname[256];

	sprintf(fullname, "%s.%d", directory, leafnumber);
    return(remove_file(fullname));
}


extern void purge_directory(const char *directory, const int loPage, const int hiPage)
{
  int i;
  char command[256];

  for (i=loPage; i<=hiPage; i++)
  {
    sprintf(command, "remove %s.%d", directory, i);
    _kernel_oscli(command);
  }
}


extern int readvareval(const char *name)
{
  _kernel_swi_regs r;
  int result;

  /* Setup registers for SWI call */
  r.r[0] = (int)name;
  r.r[1] = (int)&result;
  r.r[2] = sizeof(int);
  r.r[3] = 0;            /* first call */
  r.r[4] = 1;            /* numeric value expected */

  _kernel_swi(OS_ReadVarVal, &r, &r);

  /* Check validity of result and set return value to 0 if invalid (R2 = 4 if valid) */
  if (r.r[2] == 0)
    result = 0;

  return (result);
}


extern void readvarval(const char *name, char *buffer, int buffmax)
{
  _kernel_swi_regs r;

  r.r[0] = (int)name;
  r.r[1] = (int)buffer;
  r.r[2] = buffmax;
  r.r[3] = 0;		/* first call */
  r.r[4] = 0;

  _kernel_swi(OS_ReadVarVal, &r, &r);

  /* if not a string, pretend it doesn't exist */
  if (r.r[4] != 0)
    r.r[2] = 0;

  buffer[r.r[2]] = '\0';	/* terminate*/
}

#if SUPPORT_EMAIL
#if KLUDGE_EMAIL
void test_emailsend(void)
{
	Document document;

	SendQ_CreateDocument(&document);
	if (document)
	{
		char command[256];
		messageDataBlock *sendMessage;

    	sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.1 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 1, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);

        sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.2 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 2, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);
#if 1
    	sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.3 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 3, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);

        sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.4 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 4, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);

    	sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.5 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 5, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);

        sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.6 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 6, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);

        sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.7 ~cf~v", document->Directory);
        _kernel_oscli(command);
        QuCommon_Page_Complete(document, 7, PageClass_TIFF, PageType_TIFF_2DMMR, FILETYPE_TIFF);
#endif

		document->ScanState = ScanCOMPLETE;			/* complete (3)  */
		document->RequestTx = 1;			/* requesting */

		document->SearchRef = document->ProcessId; /* good enough (cos its unique) as the message ref when faking messages */

		strcpy(document->AddressRecord.ContactName, "Daytona");
        strcpy(document->AddressRecord.DirectPhoneNumber, "-5337");
#if 0
        strcpy(document->AddressRecord.EmailAddress, "daytona@rwarren.acorn.co.uk");
#else
        strcpy(document->AddressRecord.EmailAddress, "wibble@rwarren.acorn.co.uk");
#endif        
        document->AddressRecord.OneShotFlags = 0;

		StateKicker_SendMessage(SendQ_MessageHandler, AD_SQ_FINISH, &sendMessage);
		sendMessage->data.finish.searchref = document->SearchRef;


    }
}
#endif
#endif


/* end of SendQ.c */


