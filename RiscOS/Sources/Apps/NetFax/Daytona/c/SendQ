/*
 * SendQ.c - Daytona Fax and Email Send Queue
 *
 * R C Manby
 *
 * Started 22 July 1997
 */


#include "BuildFlags.h"
#include "StdTypes.h"

#define KLUDGE_EMAIL 1
#define SCANNING 1
#define TRANSMITTING 1
#define TEXTUAL_EMAIL 0
#define HARDCOPY_FINISHED 1

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "kernel.h"

#include "StateKicker.h"
#include "LogFileIF.h"
#if SCANNING
#include "LocXfer.h"
#endif
#if TRANSMITTING
#include "RemXfer.h"
#endif

#include "SendQ.h"
#include "PrintQ.h"
#include "Screen.h"
#if SUPPORT_EMAIL
#include "MimeQ.h"
#endif

#include "functions.h"
#include "wimp.h"
#include "wimplib.h"
#include "AddrBookIF.h"
#include "QuStruct.h"
#include "AddrFile.h"


#include "DebugLib.h"
#include "SetupIF.h"
#include "FileOps.h"

#if SUPPORT_ADDRESSBOOK
#include "numconvert.h"
#else
#include "TfaxAddr.h"	/* if not using the full address book use the mini address book */ 
#endif

#define SENDQ_RX_DIR_DOC_0 "RAM::RamDisc0.$.SendQ.Doc0"

enum _HL_RC { OK = 0, Error_MultipleNAN, Error_NoMemory, OS_Error };
typedef enum _HL_RC HL_RC;

BOOL isp_dialup_user_request = FALSE;		/* this should only be cleared when the complete send/receive cycle has happened */
BOOL isp_dialup_watermark_reached = FALSE;  /* this can be cleared after each complete document has been sent */
BOOL user_request_cancel_fax = FALSE;


#define ISP_LIST_SIZE 1


struct
{
    int use;	/* initialised to -1 meaning rest of structure un-initialised */
	int errors_before; 
    PhoneConnection Connection[ISP_LIST_SIZE];



}
isp_dialup = { -1 };



static void hardcopy_new_document(Document document);
static void hardcopy_pages_complete(Document document, unsigned int loPage, unsigned int hiPage);
static void hardcopy_document_complete(Document document);

extern int HWM_Check(void);
static void show_ContactName(Document document);
static void show_SendRoute(Document document);

static void Log_TxConnecting(enum _SendRoute route, PhoneConnection *connection, const char *dial_number);
static void Log_TxConnectingError(enum _SendRoute route, PhoneConnection *connection, messageDataBlock *messageData);
static void Log_TxConnectingFailed(enum _SendRoute route, PhoneConnection *connection);
static void Log_TxConnected(enum _SendRoute route, PhoneConnection *connection);
static void Log_TxConnectedErrorSendingDoc(enum _SendRoute route, PhoneConnection *connection, messageDataBlock *messageData, Document document);
static void Log_TxConnectedError(enum _SendRoute route, messageDataBlock *messageData);
static void Log_TxSentDocument(enum _SendRoute route, Document document);

static BOOL connection_impossible(enum _SendRoute route, PhoneConnection *connection);
static BOOL connection_requested_now(enum _SendRoute route, PhoneConnection *connection);

static _kernel_oserror *SendQ_CreateDocument(Document *p_document);
static void SendQ_NextDocument(BOOL *p_email_flag, Document *p_document);
static Document document_from_pid(unsigned int pid);
static Document next_email(Document document);
static Document document_from_SearchRef(int SearchRef);





#if KLUDGE_NAN
extern int global_forceNAN = 0;	/* 0=>Normal, 1=>ForceNAN */
#endif
#if KLUDGE_ROUTING
extern int global_routing = 0;	/* 0=>Fax, 1=>ZModem */
#endif

static BOOL maybe_idle = TRUE;	/* strong hint that the local fax may be idle and hence free for printing to */

enum _rx_States { rxIDLE = 0, rxCONNECTED };
enum _tx_States { txIDLE = 0, txDIRECTCONNECTING, txDIRECTCONNECTED, txISPCONNECTING, txISPCONNECTED };

typedef enum _rx_States rx_States;
typedef enum _tx_States tx_States;

#define ADDRBOOKIF_SEARCH_FLAGS		(Field_ContactName | Field_EmailAddress | Field_FaxNumber | Field_DeviceClass | Field_RoutingOverride)
#define ADDRBOOKIF_ONESHOT_FLAGS    (Field_EmailAddress | Field_FaxNumber)	/* NB just a tally of data received, so don't try changing to xxxx_OneShot_xxxx */

/*
 * Action messages from LocXfer and RemXfer
 *
 */
extern void SendQ_MessageHandler(int messageNumber, messageDataBlock *messageData)
{
	static rx_States rx_state = rxIDLE;
	static tx_States tx_state = txIDLE;
	static Document scan_document = NULL;	/* Do we KNOW that there can be only one active at a time? */
    static Document transmit_document = NULL;
    static Document encoding_document = NULL;
    static Document NAN_document = NULL;

	HL_RC status = OK;

    /* Print message number to debug device */
    dprintf((NULL, "SendQ_MessageHandler: Message => 0x%X\n", messageNumber));

	switch (messageNumber)
	{
#if SCANNING
		case LX_SQ_ERROR:
		case LX_SQ_NEW_DOCUMENT:
        case LX_SQ_NEW_PAGE:
        case LX_SQ_PAGE_COMPLETE:
        case LX_SQ_DOCUMENT_COMPLETE:
			{
				rx_States nextstate = rx_state;

				switch (rx_state)
				{
					case rxIDLE:
						switch (messageNumber)
                        {
							case LX_SQ_ERROR:
								Screen_ReportError("Title_LX_SQ_ERROR", messageData);
								break;

							case LX_SQ_NEW_DOCUMENT:
								{
									int interactive = FALSE;
#if SUPPORT_ADDRESSBOOK
									/*
									 * need:
									 *  setup_configuredNAN             - to determine if NAN was dialled
									 *  setup_external_access_code      }
									 *  setup_international_access_code } to convert number
									 *  setup_national_access_code      } (non-NAN) dialled on fax machine
									 *  setup_fax_country_code          } to internal format
									 *  setup_fax_area_code             }
                                     */

									SetupIF_Read_Phone_Config();

									/*int documentId = NewDocumentId();*/
					                interactive = (strcmp(messageData->data.new_document.number, setup_configuredNAN) == 0);
#if 1
		{
			char buffer[256];
			sprintf(buffer, "NAN is '%s'", setup_configuredNAN);
			LogFileIF_Message(buffer);

			sprintf(buffer, "Configured fax number is '%s'", setup_fax_number);
			LogFileIF_Message(buffer);
		}
#endif
									/* treat empty number as setup_configuredNAN */
									if (messageData->data.new_document.number[0] == '\0')
										interactive = TRUE;
#if KLUDGE_NAN
									if (global_forceNAN)
									{
										/* force interactive search all the time */
										interactive = TRUE;
									}
#endif

									/* only one interactive search allowed at once */
									if ((interactive) && (AddrBookIF_InteractiveBusy()))
										status = Error_MultipleNAN;
#endif
									if (status == OK)
									{
					                    /* only allow fax scanning if we have a reasonable amount of memory */
					                	switch (HWM_Check(/*DEFAULT_FAX_SIZE*/))
					                	{
					                		case 3:
					                		case 2:
					                			status = Error_NoMemory;
					                			break;
					
					                		case 1:
					                			if (SendQ_CreateDocument(&scan_document) != NULL)
					                				status = OS_Error;
					                			break;
					                	}
									}
					
									if (status == OK)
									{
										messageDataBlock *sendMessage;
					
										scan_document->ScanState = ScanRUNNING;	/* in progress */
					
					                    /* tell LocXfer where to put the document (fax/text) */
										StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_NEW_DOCUMENT_DIR, &sendMessage);
										sendMessage->data.new_document_dir.pid = scan_document->ProcessId;
										strcpy(sendMessage->data.new_document_dir.directory, scan_document->Directory);
					
					                    /* attach number dialled on fax machine to document */
#if SUPPORT_ADDRESSBOOK
										/* visually cleaner to open address book last rather than risk having to close it if above calls fail */
										/* search may terminate after scan has completed, so document is tied to the search by the SearchRef */
										if (interactive)
										{
											/* interactive (NAN) search, returning contact name, email address, fax number, routing etc */
											/* but user may choose 'One shot' which returns email address and fax number only */
											scan_document->AddressRecord.SearchFlags  = ADDRBOOKIF_SEARCH_FLAGS;
											scan_document->AddressRecord.OneShotFlags = ADDRBOOKIF_ONESHOT_FLAGS;
											AddrBookIF_InteractiveSearch(&scan_document->SearchRef, &scan_document->AddressRecord, ADDRBOOKIF_SEARCH_FLAGS);
										}
										else
										{
                                            /* we read all the setup_xxx variables we need above */

						                    numconvert_captured_to_internal(messageData->data.new_document.number,
						                                                 	scan_document->CapturedPhoneNumber,   /* internal format */
                                                                            sizeof(scan_document->CapturedPhoneNumber),
						                        							setup_external_access_code,				/* op:	Outside line prefix, eg "" or "9" */
						                        							setup_international_access_code,		/* ip:	International prefix, eg "00" */
						                        							setup_national_access_code,      		/* np:	National prefix, e.g. "0" */
						                        							setup_fax_country_code,                 /* cc:	Country code, e.g. "44" */
						                        							setup_fax_area_code                     /* ac:	Area code, e.g. "1223" */
						                        						   );
					                        /* non interactive (NAN) search of fax or voice number */
					                        /* returning contact name, email address, fax number, routing etc */
					                        /* 'One shot' not applicable */
											scan_document->AddressRecord.SearchFlags  = ADDRBOOKIF_SEARCH_FLAGS;
											scan_document->AddressRecord.OneShotFlags = ADDRBOOKIF_ONESHOT_FLAGS;
											AddrBookIF_SearchFaxNumber(&scan_document->SearchRef, &scan_document->AddressRecord, ADDRBOOKIF_SEARCH_FLAGS, scan_document->CapturedPhoneNumber);
										}
#else
										/* no address book, so pretend the search completed, use captured number as direct number */
                        				scan_document->AddressRecord.DeviceClass = DeviceClass_Fax;				   
                        				scan_document->SendRoute = RouteDIRECT;
										scan_document->AddressRecord.SearchFlags = scan_document->AddressRecord.OneShotFlags = 0;
										strcpy(scan_document->CapturedPhoneNumber, messageData->data.new_document.number);
										strcpy(scan_document->AddressRecord.DirectPhoneNumber,   messageData->data.new_document.number);

                                        /* no address book so look up number in mini address book */
										if (TFax_addr_lookup(messageData->data.new_document.number))
										   scan_document->AddressRecord.DeviceClass = DeviceClass_Daytona;
										else
										   scan_document->AddressRecord.DeviceClass = DeviceClass_Fax;
#endif
										/* tell Screen a scan has started, captured number may be useful for debugging */
										StateKicker_SendMessage(Screen_StateMachine, SQ_SC_NEW_DOCUMENT, &sendMessage);
										sendMessage->data.sq_sc_new_document.pid = scan_document->ProcessId;
										strcpy(sendMessage->data.sq_sc_new_document.number, messageData->data.new_document.number);

										nextstate = rxCONNECTED;
									}
									else
										StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);
								}
								break;
                        }
                        break;
                    
					case rxCONNECTED:
						switch (messageNumber)
                        {
							case LX_SQ_ERROR:
								Screen_ReportError("Title_LX_SQ_ERROR", messageData);
								break;

							case LX_SQ_NEW_DOCUMENT:
								StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);
								break;

							case LX_SQ_NEW_PAGE:
								{
									/*>>>Trigger page <n> animation*/
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_NEW_PAGE, NULL);
					
									switch (HWM_Check())					/* returns 1/2/3 OK/Trigger-send/Abort-Rx */
									{
										case 3:
											StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);
											/* drop into... */
										case 2:
											scan_document->RequestTx = 1;	/* requesting (or in progress) */
										case 1:
											break;
									}
								}
								break;
					
							case LX_SQ_PAGE_COMPLETE:
								{
					                messageDataBlock *sendMessage;
					
									scan_document->ScanCount += 1;
					
									switch (HWM_Check())					/* returns 1/2/3 OK/Trigger-send/Abort-Rx */
									{
										case 3:
											StateKicker_SendMessage(LocXfer_StateMachine, SQ_LX_ABORT_INCOMING, NULL);
											/* drop into... */
										case 2:
											scan_document->RequestTx = 1;	/* requesting (or in progress) */
										case 1:
											break;
									}
					
									/* poke the animations */
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_PAGE_COMPLETE, &sendMessage);
					                sendMessage->data.sq_sc_page_complete.ScanCount = scan_document->ScanCount;
								}
								break;
					
							case LX_SQ_DOCUMENT_COMPLETE:
								{
					                messageDataBlock *sendMessage;
					
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DOCUMENT_COMPLETE, &sendMessage);
					                sendMessage->data.sq_sc_document_complete.ScanCount = scan_document->ScanCount;
					
									scan_document->ScanState = ScanCOMPLETE;	/* complete (3)  */
#if 1
									scan_document->RequestTx = 1;				/* requesting */
#endif
									scan_document = NULL;	/* this handler no longer needs to reference this document */
									nextstate = rxIDLE;
								}
								break;

                        }
                        break;
                } /* switch (rx_state) */

#if 0
			    /* report SQ_xx_GOING_IDLE if going idle from a non-idle state */
				if ((nextstate == rxIDLE) && (rx_state != rxIDLE))
					StateKicker_SendMessage(Xxxx_MessageHandler, SQ_xx_GOING_IDLE, NULL);
#endif
				rx_state = nextstate;
            }
            break;
/* end of scanning */
#endif
#if SCANNING
/* scanning - address book search */
		case AD_SQ_NOTFOUND:
        case AD_SQ_CANCEL:
		case AD_SQ_FINISH:
			NAN_document = document_from_SearchRef(messageData->data.cancel.searchref);	/*NB assumes data.cancel.searchref data.finish.searchref data.notfound.searchref are overlaid */
		    if (NAN_document)
		    {
	    		switch (messageNumber)
	    		{
	    			/* number dialled on fax machine is not in the address book, so use it, assuming a fax machine will answear */
	    			case AD_SQ_NOTFOUND:
	    				strcpy(NAN_document->AddressRecord.DirectPhoneNumber, NAN_document->CapturedPhoneNumber);	/* internal format */
                        NAN_document->AddressRecord.DeviceClass = DeviceClass_Fax;				   
                        NAN_document->SendRoute = RouteDIRECT;
						scan_document->AddressRecord.SearchFlags = scan_document->AddressRecord.OneShotFlags = 0;	/* pretend the search completed */
	    				break;

	    			case AD_SQ_CANCEL:
	    			    NAN_document->Cancelled = TRUE;
						scan_document->AddressRecord.SearchFlags = scan_document->AddressRecord.OneShotFlags = 0;	/* pretend the search completed */
	    				break;

					case AD_SQ_FINISH:
						show_ContactName(NAN_document);	/* display debugging/user info */

						/* scan_document->AddressRecord.SearchFlags or scan_document->AddressRecord.OneShotFlags are now zero */

                        /* now that we have the address book data, we may be able to choose the final routing */
                   		if (NAN_document->AddressRecord.EmailAddress[0] == '\0')
                   		{
                   			if (NAN_document->AddressRecord.DirectPhoneNumber[0] == '\0')
                   			{
                   				/* opps, search has completed, without returning a suitable destination */
                   				NAN_document->Cancelled = TRUE;	/*>>>perhaps we should open the NAN window*/
                   			}
                   			else
                   			{
                   				/* have phone number only, DeviceClass may have been set or left at default */
                   				NAN_document->SendRoute = RouteDIRECT;
                   				show_SendRoute(NAN_document);	/* display debugging/user info */
                   			}
                   		}
                   		else
                   		{
                   			if (NAN_document->AddressRecord.DirectPhoneNumber[0] == '\0')
                            {
                               	/* have email address only, DeviceClass may have been set or left at default */
                               	NAN_document->SendRoute = RouteISP;
                               	show_SendRoute(NAN_document);	/* display debugging/user info */
                            }
                            else
                            {
                               	/* ask user which route to use */
                               	Screen_QuerryRoute(NAN_document->ProcessId);
                               	/* SC_SQ_ROUTING with RouteUNKNOWN (ie use global routing), RouteDIRECT or RouteISP will arrive later on */
                            }
                   		}
						break;
	    				
	    		} /*inner switch (messageNumber)*/
		    }
            break;

		case SC_SQ_ROUTING:
			NAN_document = document_from_pid(messageData->data.deliveryoptions.pid);
		    if (NAN_document)
			{
	    		NAN_document->SendRoute = messageData->data.deliveryoptions.route;	/* RouteUNKNOWN (ie use local routing), RouteDIRECT or RouteISP */

				/* no route chosen, use AddressRecord.LocalRouting */
				if (NAN_document->SendRoute == RouteUNKNOWN)
					NAN_document->SendRoute = NAN_document->AddressRecord.LocalRouting;	/* which may also be RouteUNKNOWN (ie use global routing), RouteDIRECT or RouteISP */

				if (NAN_document->SendRoute == RouteUNKNOWN)
				{
					if (setup_configured_routing == 0)
						NAN_document->SendRoute = RouteISP;
					else
						NAN_document->SendRoute = RouteDIRECT;		
                }
                show_SendRoute(NAN_document);	/* display debugging/user info */

				/* Since we asked the user to selected the primary route (RouteDIRECT or RouteISP), */
				/* we know that the other route is available as the secondary route */ 
				NAN_document->ReRouteAvailable = TRUE;
			}
       		break;
/* end of scanning - address book search*/
#endif

		case RX_SQ_GOING_IDLE:
			/* a receive or a send has just completed */
			maybe_idle = TRUE;	/* tell queue scanner it may like to try printing */
			/* drop into... */
#if TRANSMITTING
/* transmitting */
		case RX_SQ_AM_IDLE:
		case RX_SQ_DIAL_REJECTED:
#if 0
		case RX_SQ_FAILED:
#endif
		case RX_SQ_ERROR:
		case RX_SQ_WHICH_DOCUMENT:
		case RX_SQ_SWITCHTO_DAYTONA:
		case RX_SQ_SENDING_PAGE:
		case RX_SQ_PAGE_SENT:
		case RX_SQ_DOCUMENT_SENT:
#if /*THINK*/ 0
		case RX_SQ_MAYBE_VOICE:
#endif
#if SUPPORT_EMAIL
	  /*case ME_SQ_WHICH_DOCUMENT: occurs lower down */
	  /*case ME_SQ_NEXT_DOCUMENT:  occurs lower down */
	  	case RX_SQ_CONNECTED:
		case RX_SQ_SENDING_DOCUMENT:
		case RX_SQ_SENDING_PAGE_RANGE:
		case RX_SQ_PAGE_RANGE_SENT:
#endif
			{
				tx_States nextstate = tx_state;

				switch (tx_state)
				{
	            	case txIDLE:
	                    switch (messageNumber)
						{
							/* some outside code needs to do StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_QUERY_IDLE, NULL); */
							/* this we be ignored or cause a reply of RX_SQ_AM_IDLE                                                 */
							case RX_SQ_AM_IDLE:
								{
									BOOL              email_flag;
									messageDataBlock *sendMessage;
									char              show_number[30];	/* format we show the user */
									char              dial_number[30];	/* actual number dialled */
					
									/* is there anything to send? */
					                SendQ_NextDocument(&email_flag, &transmit_document);

					                if ((email_flag == FALSE) && (transmit_document))
					                {
#if SUPPORT_ADDRESSBOOK
										/*
										 * need:
										 *  setup_external_access_code      }
										 *  setup_international_access_code } to convert internal form of number (from fax machine or address book)
										 *  setup_national_access_code      } to dialer format
										 *  setup_fax_country_code          }
										 *  setup_fax_area_code             }
										 */
										SetupIF_Read_Phone_Config(); /*>>>will do for now*/
#endif
					                	if (transmit_document->SendRoute == RouteDIRECT)
						                {
#if SUPPORT_ADDRESSBOOK
											numconvert_internal_to_display(transmit_document->AddressRecord.DirectPhoneNumber,	/* internal format */
											                               show_number,
											                               sizeof(show_number),
											                               setup_international_access_code,		/* ip:	International prefix, eg "00" */
											                               setup_national_access_code,      	/* np:	National prefix, e.g. "0" */
											                               setup_fax_country_code,              /* cc:	Country code, e.g. "44" */
											                               setup_fax_area_code                  /* ac:	Area code, e.g. "1223" */
											                              ); 
											
											/* tell screen that if it receives RM_SC_DIALLING that it's contacting */
											/* transmit_document->AddressRecord.DirectPhoneNumber, transmit_document->AddressRecord.ContactName */
						                    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_CONTEXT_DIRECT, &sendMessage);
						                    sendMessage->data.context_direct.pid = transmit_document->ProcessId;
											strcpy(sendMessage->data.context_direct.number,  show_number);
											strcpy(sendMessage->data.context_direct.contact, transmit_document->AddressRecord.ContactName);
#else
											strcpy(show_number, transmit_document->AddressRecord.DirectPhoneNumber);											
#endif
#if KLUDGE_ROUTING
						                    if (global_routing == 0)
						                        StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_FAX, &sendMessage);
						                    else
						                    	StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_DAYTONA, &sendMessage);
#else
											if (transmit_document->AddressRecord.DeviceClass == DeviceClass_Fax)
												StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_FAX, &sendMessage);
											else
												StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_DAYTONA, &sendMessage);
#endif
#if SUPPORT_ADDRESSBOOK
								    	    numconvert_internal_to_dial(transmit_document->AddressRecord.DirectPhoneNumber,	/* internal format */
								    	                                dial_number,        					/* dialler format */
								    	                                sizeof(dial_number),
					                                                    "",                                   	/* pulse/tone */
					                                                    setup_external_access_code,				/* op:	Outside line prefix, eg "" or "9" */
					                                                    "",										/* opp:	Outside line pause/wait after prefix eg "", "W" */
					                                                    setup_international_access_code,		/* ip:	International prefix, eg "00" */
					                                                    "",										/* ipp:	International pause/wait after prefix, e.g. "," */
								    	                                setup_national_access_code,      		/* np:	National prefix, e.g. "0" */
					                                                    setup_fax_country_code,                 /* cc:	Country code, e.g. "44" */
					                                                    setup_fax_area_code                     /* ac:	Area code, e.g. "1223" */
					                                                   );
#else
											strcpy(dial_number, transmit_document->AddressRecord.DirectPhoneNumber);
#endif
					                        strcpy(sendMessage->data.dial.number, dial_number);
						                /*	SetupIF_Read_Phone_Config();*/ /*>>>will do for now*/
						                	SetupIF_Read_Email_Config(); /*>>>will do for now*/
						                	
											Create_Originator_File(transmit_document->Directory, "Local", 0/*text_count*/, transmit_document->ScanCount, transmit_document->ScanState != ScanCOMPLETE);
											/*>>>what if Create_Originator_File() fails?*/
											/*REPORT: DirectDial<number>*/
											Log_TxConnecting(RouteDIRECT, &(transmit_document->Connection), show_number);

											nextstate = txDIRECTCONNECTING;
								    	}
								    }
#if SUPPORT_EMAIL
								    if (email_flag == TRUE)
								    {
					                	SetupIF_Read_Phone_Config(); /*>>>will do for now*/
					                	SetupIF_Read_Email_Config(); /*>>>will do for now*/
					                	strcpy(dial_number, setup_ISP_PhoneNumber);

					                	isp_dialup.errors_before = 0;

										if (setup_Ether_Lan)
										{
               								StateKicker_SendMessage(Screen_StateMachine, SQ_SC_CONTEXT_LAN, NULL);
					                		StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_LAN, &sendMessage);
					                		sendMessage->data.sq_rx_dial_lan.tx_flag = (transmit_document != NULL);
#if 0
					                		sendMessage->data.sq_rx_dial_lan.rx_flag = TRUE;
#else
											sendMessage->data.sq_rx_dial_lan.rx_flag = (transmit_document == NULL);									
#endif
										}
										else
										{
							    			/* transmit_document->SendRoute is RouteISP */
							    			/* tell screen that if it receives RM_SC_DIALLING that it's contacting the ISP  */
					                		StateKicker_SendMessage(Screen_StateMachine, SQ_SC_CONTEXT_ISP, &sendMessage);
					                		strcpy(sendMessage->data.context_isp.number, dial_number);

											if (transmit_document)
					                			StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_ISP, &sendMessage);
					                		else
					                			StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_DIAL_ISP_rx, &sendMessage);
					                		
					                		strcpy(sendMessage->data.dial.number, dial_number);
										}
										/* no need to call Create_Originator_File() as MimeIF builds that data into email headers */
										/*REPORT: ISPDial<number>*/
										Log_TxConnecting(RouteISP, &isp_dialup.Connection[isp_dialup.use], dial_number);
										
										nextstate = txISPCONNECTING;
								    }
#endif								    
							    }
								break;
                        }
	            		break;

					case txDIRECTCONNECTING:
	                    switch (messageNumber)
						{
							case RX_SQ_DIAL_REJECTED:	/* not idle after all (incoming call) NOT counted as a failed dial attempt */
								nextstate = txIDLE;     /* Don't look for RX_SQ_GOING_IDLE (ignoring the one case where it IS sent) */
								break;
#if 0
							case RX_SQ_FAILED:
								nextstate = txIDLE;	/*>>>wait for GOING_IDLE???*/
								break;
#endif
							/* Error: unable to connect */
							case RX_SQ_ERROR:
								Screen_ReportError("Title_RX_SQ_ERROR", messageData);
								Log_TxConnectingError(RouteDIRECT, &(transmit_document->Connection), messageData);
#if 1
								if (messageData->data.rm_error.rc == 6 /*no carrier*/)
                                {
									/* we sent SQ_RX_DIAL_DAYTONA, but RemModem cannot detect a carrier, */
									/* so assume the Daytona has been removed and retry as fax */
									transmit_document->AddressRecord.DeviceClass = DeviceClass_Fax;	/* NB may have been answered by voice! */
#if SUPPORT_ADDRESSBOOK
									/* tell address book that we didn't find a Daytona (either a fax machine or voice) */ 
#else
									TFax_address_remove(transmit_document->AddressRecord.DirectPhoneNumber);	/* RemModem (sending) didn't find a Daytona */
#endif
                                }
#endif
								/* we may get more errors before RX_SQ_GOING_IDLE */
								break;

							case RX_SQ_GOING_IDLE:
								/* the send has just completed - should only happen after one or more RX_SQ_ERRORs */
								/* count a failed dialup, calculate when the next attempt should be */
								Log_TxConnectingFailed(RouteDIRECT, &(transmit_document->Connection));
								transmit_document = NULL;	/* not valid after a call to Log_TxConnectingFailed */
	                    		nextstate = txIDLE;
								break;
/*>>>should we mark transmit_document->Connection when connection finally happens? */ 
							case RX_SQ_WHICH_DOCUMENT:	/* implies that we have connected */
								{
									messageDataBlock *sendMessage;
					
							    	transmit_document->SendState = SendRUNNING; 	/* in progress (2) */
							    	transmit_document->RequestTx = FALSE;	/*>>>try this*/
							    	StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_THIS_DOCUMENT, &sendMessage);
							    	sendMessage->data.this_document.pid = transmit_document->ProcessId;
							    	sendMessage->data.this_document.loText = 1;
							    	sendMessage->data.this_document.hiText = 0;
							    	sendMessage->data.this_document.loPage = transmit_document->SendCount + 1;
							    	sendMessage->data.this_document.hiPage = transmit_document->ScanCount;
							    	sendMessage->data.this_document.pageStream = (transmit_document->ScanState != ScanCOMPLETE);
									strcpy(sendMessage->data.this_document.directory, transmit_document->Directory);

									Log_TxConnected(RouteDIRECT, &(transmit_document->Connection));	/* log successful connection to recipient */

									/* start screen animations for direct send */
					                StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_DOCUMENT, &sendMessage);
								    sendMessage->data.sending_document.pid = transmit_document->ProcessId;
								    strcpy(sendMessage->data.sending_document.ContactName, transmit_document->AddressRecord.ContactName);

									nextstate = txDIRECTCONNECTED;
								}
								break;
						}
						break;

	                case txDIRECTCONNECTED:
	                    switch (messageNumber)
						{
							case RX_SQ_SWITCHTO_DAYTONA:
								/* we sent SQ_RX_DIAL_FAX, but !Fax detected that the receiver is capable of ZModem transfer and switched over */
								/* if the connection fails, we should re-dial using SQ_RX_DIAL_DAYTONA */
								transmit_document->AddressRecord.DeviceClass = DeviceClass_Daytona;
#if SUPPORT_ADDRESSBOOK
								/* tell address book that we found a Daytona rather than a fax machine */ 
#else
								TFax_address_add(transmit_document->AddressRecord.DirectPhoneNumber);	/* RemXfer (sending) has found a Daytona, add it to the address list */
#endif
								break;

							case RX_SQ_SENDING_PAGE:
							    {
#if 0
	/*>>>SQ_SC_SENDING_PAGE is a better name than SQ_SC_SENDING_FAX???*/
									messageDataBlock *sendMessage;

									/* poke animation */
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_PAGE, &sendMessage);
								    sendMessage->data.sq_sc_sending_page.pid = transmit_document->ProcessId;
#else
									/* poke animation */
									StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_FAX, NULL);
#endif
								}
								break;
					
							case RX_SQ_PAGE_SENT:
								{
									messageDataBlock *sendMessage;
					
									transmit_document->SendCount += 1;
#if 1
      								purge_directory(transmit_document->Directory, transmit_document->SendCount, transmit_document->SendCount);	/* use purge_directory to delete one file! */
#endif
									/* poke animation */
								    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_PAGE_SENT, &sendMessage);
								    sendMessage->data.sq_sc_page_sent.pid = transmit_document->ProcessId;
								    sendMessage->data.sq_sc_page_sent.pagesSent = transmit_document->SendCount;				
								}
								break;
					
							case RX_SQ_DOCUMENT_SENT:
								{
									messageDataBlock *sendMessage;
#if 0
							        purge_directory(transmit_document->Directory, 1, transmit_document->ScanCount); /*>>>should this be done by the queue scanner*/
#endif
								    /* poke animation */
								    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DOCUMENT_SENT, &sendMessage);
								    sendMessage->data.sq_sc_document_sent.pid = transmit_document->ProcessId;
								    sendMessage->data.sq_sc_document_sent.pagesSent = transmit_document->SendCount;

                                    /*REPORT: PagesSent & status*/ 
									Log_TxSentDocument(RouteDIRECT, transmit_document);	/* log transmission of document */

								    transmit_document->SendState = SendCOMPLETE;	/* complete (3) */
								    transmit_document = NULL;	/* this handler no longer needs to reference this document */
#if 0
						NAN_document = NULL;
#endif
					            }
								break;

							/* Error: after connection */
							case RX_SQ_ERROR:
								Screen_ReportError("Title_RX_SQ_ERROR", messageData);
								/*REPORT: Error*/
								if (transmit_document)
									Log_TxConnectedErrorSendingDoc(RouteDIRECT, &(transmit_document->Connection), messageData, transmit_document);
								else
									Log_TxConnectedError(RouteDIRECT, messageData);	
								break;
#if /*THINK*/ 0
							case RX_SQ_MAYBE_VOICE:
								/* a fax error ERROR_T1_TIMEOUT before any data transfer */
								/* is probably means call answered by voice */
								/*>>>set a don't redial flag */ 
								break;
#endif
							case RX_SQ_GOING_IDLE:
								/* the send has just completed */
	                    		nextstate = txIDLE;
								break;
						}
						break;
#if SUPPORT_EMAIL
					case txISPCONNECTING:
	                    switch (messageNumber)
						{
							case RX_SQ_DIAL_REJECTED:	/* not idle (incoming call) NOT counted as a failed dial attempt */
								nextstate = txIDLE;     /* Don't look for RX_SQ_GOING_IDLE (ignoring the one case where it IS sent) */
								break;

#if 0
							case RX_SQ_FAILED:
								nextstate = txIDLE;	/*>>>wait for GOING_IDLE???*/
								break;
#endif
							/* Error: unable to connect to ISP */
							case RX_SQ_ERROR:
								Screen_ReportError("Title_RX_SQ_ERROR", messageData);
								Log_TxConnectingError(RouteISP, &isp_dialup.Connection[isp_dialup.use], messageData);
								isp_dialup.errors_before += 1;
								/* we may get more errors before RX_SQ_GOING_IDLE */
								break;

							case RX_SQ_GOING_IDLE:
								/* the send has just completed (ie there is was an error) */
								if (isp_dialup.errors_before)
								{
									/* count a failed dialup, calculate when the next attempt should be */
									Log_TxConnectingFailed(RouteISP, &isp_dialup.Connection[isp_dialup.use]);
								}
								else
								{
									/*we'll do a receive now*/
								}
	                    		nextstate = txIDLE;
/*>>>is this correct, given that we start a receive next?*/
								break;

                            case RX_SQ_CONNECTED:
#if 1
   /*>>>*/         /* this should only be cleared when the download has finished */
			isp_dialup_user_request = FALSE;
#endif                            
					            Log_TxConnected(RouteISP, &isp_dialup.Connection[isp_dialup.use]);	/* log successful connection to ISP */
								nextstate = txISPCONNECTED;
								break;
						}
	                	break;

					case txISPCONNECTED:
						switch (messageNumber)
						{
							case RX_SQ_SENDING_DOCUMENT:
								/* we send multiple documents per connection, allow animation to show each recipient as emails go out */
								transmit_document = document_from_pid(messageData->data.sending_document.pid);
								if (transmit_document)
								{
								    messageDataBlock *sendMessage;
								    
									/* start screen animations for email sending */
					                StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_DOCUMENT, &sendMessage);
								    sendMessage->data.sending_document.pid = messageData->data.sending_document.pid;
								    strcpy(sendMessage->data.sending_document.ContactName, transmit_document->AddressRecord.ContactName);

								    hardcopy_new_document(transmit_document);	/* may need to print (enote or eform) */
					            }
								break;
					
							case RX_SQ_SENDING_PAGE_RANGE:
							    /* poke animation */
								StateKicker_SendMessage(Screen_StateMachine, SQ_SC_SENDING_EMAIL, NULL);
								break;
					
							case RX_SQ_PAGE_RANGE_SENT:
								transmit_document->SendCount += messageData->data.page_range_sent.hiPage - messageData->data.page_range_sent.loPage + 1;

								/* if HardCopyRequired (and document creation was successful) move the sent pages into the PrintQ */
                                hardcopy_pages_complete(transmit_document, messageData->data.page_range_sent.loPage, messageData->data.page_range_sent.hiPage);
#if 1
								/* delete pages that failed to move/delete the lot if HardCopy not required */
								purge_directory(transmit_document->Directory, messageData->data.page_range_sent.loPage, messageData->data.page_range_sent.hiPage);
#endif
								break;

							case RX_SQ_DOCUMENT_SENT:
								{
									messageDataBlock *sendMessage;

									hardcopy_document_complete(transmit_document);	/* can now be printed */
#if 0
							        purge_directory(transmit_document->Directory, 1, transmit_document->ScanCount); /*>>>should this be done by the queue scanner*/
#endif
								    /* poke animation */
								    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DOCUMENT_SENT, &sendMessage);
								    sendMessage->data.sq_sc_document_sent.pid = transmit_document->ProcessId;
								    sendMessage->data.sq_sc_document_sent.pagesSent = transmit_document->SendCount;

									Log_TxSentDocument(RouteISP, transmit_document);
									
								    transmit_document->SendState = SendCOMPLETE;	/* complete (3) */
								    transmit_document = NULL;	/* this handler no longer needs to reference this document */
#if 0
						NAN_document = NULL;
#endif
									/* we clear the isp_dialup_watermark_reached flag each time a document is sent */
									/* it may be set again by the QueueWalker if later documents require it */
									/* this means that if the line drops, we only re-dial if the QueueWalker has set the flag again */
									isp_dialup_watermark_reached = FALSE;
					            }
								break;

							case RX_SQ_ERROR:
								/* error may apply to transmit_document or the isp connection */
#if 0
								/* this tells us that we should re-dial (upto 3 times) to complete the transfer */
								isp_dial.error after connection = TRUE;
#endif
								Screen_ReportError("Title_RX_SQ_ERROR", messageData);
								if (transmit_document)
									Log_TxConnectedErrorSendingDoc(RouteISP, &isp_dialup.Connection[isp_dialup.use], messageData, transmit_document);
								else
									Log_TxConnectedError(RouteISP, messageData);
								break;

							case RX_SQ_GOING_IDLE:
								/* the send has just completed */
	                    		nextstate = txIDLE;
/*>>>is this correct, given that we start a receive next?*/
#if 0
								Log_TxDisconnected(RouteISP, &isp_dialup.Connection[isp_dialup.use]);
#endif
								break;

                        }
						break;
#endif
				} /* switch (tx_state) */

#if 0
			    /* report SQ_xx_GOING_IDLE if going idle from a non-idle state */
				if ((nextstate == txIDLE) && (tx_state != txIDLE))
					StateKicker_SendMessage(Xxxx_MessageHandler, SQ_xx_GOING_IDLE, NULL);
#endif
				tx_state = nextstate;
            }
/* end of transmitting */
#endif
			break;	/* if TRANSMITTING is FALSE, GOING_IDLE still has a break; */

#if TRANSMITTING
#if SUPPORT_EMAIL
		case ME_SQ_WHICH_DOCUMENT:
			{
				encoding_document = transmit_document;
				if (transmit_document)
				{
					messageDataBlock *sendMessage;
#if 0
/*>>>definatly NOT needed */
					transmit_document->SendState = SendRUNNING; 	/* in progress (2) */
					transmit_document->RequestTx = FALSE;	/*>>>try this*/
#endif
			    	/* send document ProcessId & directory */
			    	StateKicker_SendMessage(MimeEncode_StateMachine, SQ_ME_THIS_DOCUMENT, &sendMessage);
			    	sendMessage->data.this_document.pid = transmit_document->ProcessId;
			    	sendMessage->data.this_document.loText = 1;
			    	sendMessage->data.this_document.hiText = 0;
			    	sendMessage->data.this_document.loPage = transmit_document->SendCount + 1;
			    	sendMessage->data.this_document.hiPage = transmit_document->ScanCount;
			    	sendMessage->data.this_document.pageStream = (transmit_document->ScanState != ScanCOMPLETE);
					strcpy(sendMessage->data.this_document.directory, transmit_document->Directory);
				}
				else
					StateKicker_SendMessage(MimeEncode_StateMachine, SQ_ME_NO_NORE_DOCUMENTS, NULL);
  	      	}
			break;

		case ME_SQ_NEXT_DOCUMENT:
			{
				encoding_document = next_email(encoding_document);
				if (encoding_document)
					{
						messageDataBlock *sendMessage;

				    	/* send document ProcessId & directory */
				    	StateKicker_SendMessage(MimeEncode_StateMachine, SQ_ME_THIS_DOCUMENT, &sendMessage);
				    	sendMessage->data.this_document.pid = encoding_document->ProcessId;
				    	sendMessage->data.this_document.loText = 1;
				    	sendMessage->data.this_document.hiText = 0;
				    	sendMessage->data.this_document.loPage = 1;
				    	sendMessage->data.this_document.hiPage = encoding_document->ScanCount;
				    	sendMessage->data.this_document.pageStream = (encoding_document->ScanState != ScanCOMPLETE);
						strcpy(sendMessage->data.this_document.directory, encoding_document->Directory);
					}
				else
					StateKicker_SendMessage(MimeEncode_StateMachine, SQ_ME_NO_NORE_DOCUMENTS, NULL);
			}
			break;
#endif
#endif
#if TEXTUAL_EMAIL
		case EC_SQ_NEW_DOCUMENT:
			switch (HWM_Check())
			{
				case 3:
				case 2:
				case 1:
					if (SendQ_CreateDocument(&text_document) != NULL)
						status = OS_Error;
					break;

			}
			if (status == OK)
			{
				text_document->ScanState = ScanRUNNING;	/* in progress */
				/* tell EmailCreate where to put the document text */
				StateKicker_SendMessage(EmailCreate_StateMachine, SQ_EC_DOCUMENT_DIR, &sendMessage);
				sendMessage->data.new_document_dir.pid = text_document->ProcessId;
				strcpy(sendMessage->data.new_document_dir.directory, text_document->Directory);
			}
			else
				StateKicker_SendMessage(EmailCreate_StateMachine, SQ_EC_ABORT_INCOMING, NULL);	
			break;

		case EC_SQ_NEW_TEXT
			break;

		case EC_SQ_TEXT_COMPLETE:
			text_document->TextCount += 1;
			break;

		case EC_SQ_DOCUMENT_COMPLETE:
			text_document->ScanState = ScanCOMPLETE;
			text_document = NULL;	/* this handler no longer needs to reference this document */
			break;
#endif
	}
}


/*
 * The following procedures allow EnoteIF & LogFileIF
 * to add a new document to the SendQ.
 *
 *  SendQ_ExtIF_NewDocument      - create a new document (with email address)
 *  SendQ_ExtIF_Subject          - add email subject field
 *  SendQ_ExtIF_FileComplete     - a page has been added to it
 *  SendQ_ExtIF_DocumentComplete - ready to send
 */

/*
 * Create a new document.
 *
 *   email address
 *   hardcopy_required - TRUE if document should be printed after being sent
 *                       N.B. When document transmission starts, a document is created in the PrintQ.
 *                            After each page is sent it is transfered to the document in the PrintQ.
 *                            When the transmission terminates, the document in the PrintQ is allowed to print.
 *                            If the transmission requires re-dials, the hardcopy will print as separate documents
 *                            reflecting the breaks in transmission.
 *
 * Returns: document pid (non-zero) and document directory name on success
 *
 *
 * Returns: zero on failure
 */
extern unsigned int SendQ_ExtIF_NewDocument(char *p_directory, const char *email_address, BOOL hardcopy_required)
{
    Document text_document;
	
	switch (HWM_Check())
	{
		case 3:
		case 2:
		case 1:
			if (SendQ_CreateDocument(&text_document) == NULL)
			{
				text_document->ScanState = ScanRUNNING;	/* in progress */

				strcpy(text_document->AddressRecord.EmailAddress, email_address);
				text_document->SendRoute = RouteISP;
				text_document->AddressRecord.SearchFlags = text_document->AddressRecord.OneShotFlags = 0;
                text_document->HardCopyRequired = hardcopy_required;
                /*text_document->HardCopyProcessID = 0; will be already*/

				strcpy(p_directory, text_document->Directory);
				return(text_document->ProcessId);	/* created a new document and passed directory name to caller */
			}
			break;
	}

	return(0);	/* in-sufficient memory */
}


extern void SendQ_ExtIF_Subject(unsigned int LogFile_doc_pid, const char *email_subject)
{
	Document text_document;

	if ((text_document = document_from_pid(LogFile_doc_pid)) != NULL)
	{
		strcpy(text_document->EmailSubject, email_subject);
	}
}


extern void SendQ_ExtIF_FileComplete(unsigned int LogFile_doc_pid, const char *leafname, int filetype)
{
	Document text_document;

	if ((text_document = document_from_pid(LogFile_doc_pid)) != NULL)
	{
		text_document->ScanCount += 1;

		set_filetypeDL(text_document->Directory, leafname, filetype);
		renameDLN(text_document->Directory, leafname, text_document->ScanCount);
	}
}


extern void SendQ_ExtIF_DocumentComplete(unsigned int LogFile_doc_pid)
{
	Document text_document;

	if ((text_document = document_from_pid(LogFile_doc_pid)) != NULL)
	{
		text_document->ScanState = ScanCOMPLETE;
		/*>>>do we set TxRequest???*/
#if 1
		text_document->RequestTx = 1;				/* requesting */
#endif
	}
}


/*
 * Routines to allow SendQ to add a document, page by page to the PrintQ.
 * This allows enotes and eforms to be printed after being sent.
 *
 * The routines are a thin veneer onto PrintQ_ExtIF_NewDocument and
 * PrintQ_ExtIF_DocumentComplete.
 *
 * hardcopy_new_document      - create a document in the PrintQ
 * hardcopy_pages_complete    - move a range of pages into it
 * hardcopy_document_complete - complete and ready to print
 *
 */

static void hardcopy_new_document(Document document)
{
#if HARDCOPY_FINISHED
	char directory[256];

    if (document->HardCopyRequired)
		document->HardCopyProcessID = PrintQ_ExtIF_NewDocument(directory);	/* returns 0 on failure and non-zero PId on success */
#endif	
}


static void hardcopy_pages_complete(Document document, unsigned int loPage, unsigned int hiPage)
{
#if HARDCOPY_FINISHED
/*	_kernel_oserror *error = NULL;*/
	
	if (document->HardCopyProcessID)
	{
		unsigned int i;
		
		for (i=loPage; i<=hiPage; i++)
		{
			/*>>>error =*/ PrintQ_ExtIF_FileTake(document->HardCopyProcessID, document->Directory, i);
		}
	}
#endif	
}


static void hardcopy_document_complete(Document document)
{
#if HARDCOPY_FINISHED
	if (document->HardCopyProcessID)
		PrintQ_ExtIF_DocumentComplete(document->HardCopyProcessID);

	document->HardCopyProcessID = 0;	/* finished with this PrintQ document */
#endif	
}


static void show_ContactName(Document document)
{
	messageDataBlock *sendMessage;

	/* tell Screen who the fax is for */
    StateKicker_SendMessage(Screen_StateMachine, SQ_SC_CONTACTNAME, &sendMessage);
    sendMessage->data.sq_sc_contactname.pid = document->ProcessId;
    strcpy(sendMessage->data.sq_sc_contactname.ContactName, document->AddressRecord.ContactName);
}


static void show_SendRoute(Document document)	/* display debugging/user info */
{
	messageDataBlock *sendMessage;
	
	switch (document->SendRoute)
	{
		case RouteDIRECT:
    		/* tell Screen the phone number */
    		StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DISPLAYNUMBER, &sendMessage);
   		 	sendMessage->data.sq_sc_displaynumber.pid = document->ProcessId;
    		strcpy(sendMessage->data.sq_sc_displaynumber.DirectPhoneNumber, document->AddressRecord.DirectPhoneNumber);
			break;

		case RouteISP:
    		/* tell Screen the email address */
    		StateKicker_SendMessage(Screen_StateMachine, SQ_SC_DISPLAYEMAIL, &sendMessage);
    		sendMessage->data.sq_sc_displayemail.pid = document->ProcessId;
    		strcpy(sendMessage->data.sq_sc_displayemail.EmailAddress, document->AddressRecord.EmailAddress);    
			break;
	}
}


/*
 * Accumulate call statistics, for LogFile and error reporting
 */

static char            log_dial_number[30] = { 0 };
static int	           log_error_count = 0;

/*
 * Capture time when dialup started
 */

static void Log_TxConnecting(enum _SendRoute route, PhoneConnection *connection, const char *dial_number)
{
	char buffer[256];

	time_t now = time(NULL);

	connection->TimeDial    = now;
    connection->TimeConnect = now;
    connection->TimeEnd     = now;

	strcpy(log_dial_number, dial_number);
	log_error_count = 0;

	if (route == RouteISP)
	{
		strcpy(buffer, "Dialling ISP on ");
		strcat(buffer, dial_number);

		LogFileIF_Message("");
		LogFileIF_Message(buffer);
	}
}

/*
 * Capture the first error that occurs prior to connection
 */
static void Log_TxConnectingError(enum _SendRoute route, PhoneConnection *connection, messageDataBlock *messageData)
{
	char buffer[256];
	/* There should be one error report, followed by our going idle */
    /* if multiple errors arrive, we capture the first only */
	if (log_error_count == 0)
	{
		if (route == RouteDIRECT)
		{
        	strcpy(buffer, "S ");
			strncat(buffer, log_dial_number, 128);

			strncat(buffer, " Error connecting ",128);
			strncat(buffer, messageData->data.os_error.err.errmess, 128);
        }
        else
        {
			/* ISP phone number already reported */
			
			strcpy(buffer, "Error connecting");
			strncat(buffer, messageData->data.os_error.err.errmess, 128);        
        }

		LogFileIF_Message(buffer);
	}

	log_error_count++;	
}


/*
 * Report the failure to connect and the reason
 *
 * Also performs RetryCount-ing operations for the redial logic
 * used by QueueWalker.
 */
static void Log_TxConnectingFailed(enum _SendRoute route, PhoneConnection *connection)
{
	char buffer[256];

	time_t now = time(NULL);

	connection->TimeConnect = now;	/* } ie zero connection time */
	connection->TimeEnd     = now;  /* }                         */

	connection->RetryCount += 1;	/* count the dial attempt */	
    connection->RetryTime   = time(NULL) + 30;	/*now() + something(connection->RetryCount);*/

	/*>>>Report the failure to the screen and LogFile */
	/* Fax call to <number> failed <reason> */
    /* ISP dialup on <number> failed <reason> */

	if (log_error_count == 0)
	{
		if (route == RouteDIRECT)
		{
        	strcpy(buffer, "S ");
			strncat(buffer, log_dial_number, 128);

			strncat(buffer, " Error connecting", 128);	/* !!! RX_SQ_GOING_IDLE received, but no error logged !!! */
		}
    	else
		{
			/* ISP phone number already reported */

			strcpy(buffer, "Error connecting");	/* !!! RX_SQ_GOING_IDLE received, but no error logged !!! */
		}

        LogFileIF_Message(buffer);
        log_error_count++;
	}
}


/*
 * ISP dialups generate multiline reports, report the successful connection
 */

static void Log_TxConnected(enum _SendRoute route, PhoneConnection *connection)
{
	time_t now = time(NULL);

	connection->TimeConnect = now;
	connection->TimeEnd     = now;


	log_error_count = 0;	/* unlikely not to be zero */

	if (route == RouteISP)
	{
		/*>>>Report connection to ISP*/
		/*REPORT <connection->TimeConnect> Connected to ISP*/
	    LogFileIF_Message("Connected OK");
	}
}


static void Log_TxConnectedErrorSendingDoc(enum _SendRoute route, PhoneConnection *connection, messageDataBlock *messageData, Document document)
{
	char buffer[256];

	if (log_error_count == 0)
	{
		if (route == RouteDIRECT)
		{
        	strcpy(buffer, "S ");

			if (document->AddressRecord.ContactName[0] != '\0')
        		strncat(buffer, document->AddressRecord.ContactName, 15);
        	else
        		strncat(buffer, log_dial_number, 15);

			strncat(buffer, " Error ",128);
			strncat(buffer, messageData->data.os_error.err.errmess, 128);
		}
		else
		{
			strcpy(buffer, "S ");

			if (document->AddressRecord.ContactName[0] != '\0')
    	    	strncat(buffer, document->AddressRecord.ContactName, 15);
        	else
        		strncat(buffer, document->AddressRecord.EmailAddress, 15);

			strncat(buffer, " Error ",128);
			strncat(buffer, messageData->data.os_error.err.errmess, 128);
		}

        LogFileIF_Message(buffer);
    }

	log_error_count++;
}


static void Log_TxConnectedError(enum _SendRoute route, messageDataBlock *messageData)
{
	char buffer[256];

	if (log_error_count == 0)
	{
		if (route == RouteDIRECT)
		{
        	strcpy(buffer, "S ");
			strcat(buffer, log_dial_number);

			strncat(buffer, " Error ",128);
			strncat(buffer, messageData->data.os_error.err.errmess, 128);
		}
        else
        {
        	strcpy(buffer, "S ");
			strncat(buffer, " Error ",128);
			strncat(buffer, messageData->data.os_error.err.errmess, 128);        	
        }

        LogFileIF_Message(buffer);
    }

	log_error_count++;
}


static void Log_TxSentDocument(enum _SendRoute route, Document document)
{
	char buffer[256];

	if (log_error_count == 0)
	{
		if (route == RouteDIRECT)
		{
        	strcpy(buffer, "S ");

			if (document->AddressRecord.ContactName[0] != '\0')
        		strncat(buffer, document->AddressRecord.ContactName, 15);
        	else
        		strcat(buffer, log_dial_number);

			strncat(buffer, " OK", 128);
        }
		else
		{
        	strcpy(buffer, "S ");

			if (document->AddressRecord.ContactName[0] != '\0')
        		strncat(buffer, document->AddressRecord.ContactName, 15);
        	else
        		strncat(buffer, document->AddressRecord.EmailAddress, 15);

			strncat(buffer, " OK", 128);
		}

		LogFileIF_Message(buffer);        			
	}
#if 0
	/* switch in when HANGUP followed by immediate dial failure is fixed */
	connection->RetryTime   = time(NULL) + 30;	/*now() + something(connection->RetryCount);*/	
#endif
}


static BOOL connection_impossible(enum _SendRoute route, PhoneConnection *connection)
{
	/* NB we require SetupIF to ensure (*connection->RetryLimit) >= 1 for setup_phone_fax_redial_count */
	if (connection->RetryCount >= (*connection->RetryLimit))
		return(TRUE);	/* exhausted our dial-up limit and still not got through! */

    return(FALSE);
}


static BOOL connection_requested_now(enum _SendRoute route, PhoneConnection *connection)
{
	if (connection->RetryTime <= time(NULL))
		return(TRUE);

	return(FALSE);
}



static Document SendQ_Document_Queue = NULL;

static _kernel_oserror *SendQ_CreateDocument(Document *p_document)
{
	static unsigned int dir_num = 0;
	static unsigned int doc_num = 0;	/* not a valid document number */

	_kernel_oserror    *error = NULL;
	Document 			document = NULL;
	char    			directory[212];

	*p_document = NULL;		/* in case we return an error */	

	/* be tidy, zero the directory name whenever the queue empties */
	if (SendQ_Document_Queue == NULL)
		dir_num = 0;

	document = malloc(sizeof(DocumentRec));
    if (document)
    {
    	sprintf(directory, "%s.%d", DIRECTORY_SENDQ, dir_num);
        dir_num++;

        if ((error = os_create_directory(directory)) != NULL)
        {
        	/* unable to create directory */
        	free(document);		/* free the document record we created */
        	return(error);		/* return the error */
        }
    }

	if (document)
	{
		/* created document record and a directory for the document - now fill the record */

    	document->ProcessId = UniquePId();		/* non-zero, unique across both SendQ and PrintQ */
	    strcpy(document->Directory, directory); /* fullname of the directory we created */

		/* assign a unique document number to everything we send */
		++doc_num;
		if (doc_num == 0)
			doc_num = 1;		/* never allocate zero, even if we wrap! */

	    document->DocumentNo = doc_num;   		/* non-zero, unique to SendQ, no relation to ProcessId */
    	*document->CapturedPhoneNumber = '\0';  /* not yet captured from fax machine */
    	*document->AddressRecord.EmailAddress = '\0';         /* not yet returned by the address book */
    	strcpy(document->EmailSubject, "Fax from Daytona");	/* a good default */
    	*document->AddressRecord.DirectPhoneNumber   = '\0';  /* not yet returned by the address book */
    	*document->AddressRecord.ContactName = '\0';          /* not yet returned by the address book */
    	document->AddressRecord.DeviceClass = DeviceClass_Fax;
    	document->AddressRecord.LocalRouting = RouteUNKNOWN;
    	document->SendRoute = RouteUNKNOWN;
    	document->ReRouteAvailable = FALSE;
    	document->ReRouting = FALSE;

        document->HardCopyRequired = FALSE;		/* set TRUE for notes & forms if hardcopy required */
        document->HardCopyProcessID = 0;		/* no PrintQ document */

	    document->ScanState = ScanIDLE;			/* idle (0) */
    	document->ScanCount = 0;				/* no pages received yet */
#if 0
    	document->TextCount = 0;
#endif
   	    document->RequestTx = FALSE;
    	document->SendState = SendIDLE;			/* idle (0) */
    	document->SendCount = 0;                /* no pages transmitted yet */
	    document->Cancelled = FALSE;
	    document->Suspended = FALSE;
	    document->Connection.RetryLimit = &setup_phone_fax_redial_count;	/* address not value, so changes in setup will be seen */
	    document->Connection.RetryCount = 0;	/* not yet tried to direct dial */
	    document->Connection.RetryTime = time(NULL);	/* time now, to trigger dial as soon as document needs it */
		document->SearchRef = 0;                /* address book search ref */
		document->AddressRecord.SearchFlags  = ADDRBOOKIF_SEARCH_FLAGS;   /* } Search complete when either */
        document->AddressRecord.OneShotFlags = ADDRBOOKIF_ONESHOT_FLAGS;	/* } of these clears to zero     */

        /* link document record to the tail of the queue */
		if (SendQ_Document_Queue == NULL)
			document->next_document = document;	/* first and only document, so point next field at ourselves */
		else
		{
        	document->next_document = SendQ_Document_Queue->next_document;	/* point to head of queue */
        	SendQ_Document_Queue->next_document = document;	/* old last item becomes last-but-one (we are the last) */
        }
        SendQ_Document_Queue = document;		/* point to tail of queue, our next_document field points to the head */

        *p_document = document;
	}

    return(NULL);
}

static Document sending_already = NULL;
static Document send_next       = NULL;
static Document send_next_RouteISP = NULL;

extern void SendQ_QueueWalker(BOOL isp_unavailable)
{
	sending_already = NULL;
	send_next       = NULL;
	send_next_RouteISP = NULL;

	if (SendQ_Document_Queue)
    {
		/* one or more items in the queue */
    	/* SendQ_Document_Queue points to the last record in the queue, the last record points at the first (which maybe its-self) */

        Document previous = SendQ_Document_Queue;		/* last item in queue */
        Document document;
        
		do
			{
				BOOL delete_it = FALSE;
				
				document = previous->next_document;	/* first/next item in queue */

				if (document->SendState == SendCOMPLETE)
				{
		        	if ((document->ScanState == ScanCOMPLETE) && (document->SendCount == document->ScanCount))
		        		delete_it = TRUE;	/* scan has completed and all scanned pages have been sent */
		            else
		            	document->SendState = SendIDLE; 	/* scan still in progress, or some pages not sent, so allow for later send of rest of document */
		        }
			
				if (document->SendState == SendIDLE)
				{
		        	if ((document->ScanState == ScanCOMPLETE) && (document->SendCount == document->ScanCount))
		        		delete_it = TRUE;	/* scan has completed, there are no (or no more) pages to send */

                    if ((document->ScanState == ScanCOMPLETE) && (document->Cancelled))
                    	delete_it = TRUE;	/* scan has completed, and (user has confirmed cancel request or we've decided to cancel) */
		        }

				if (!delete_it)
				{
		        	if (document->SendState == SendRUNNING)
		        		sending_already = document;			/* this document is already being sent */		
		            else
		            	{
		            		if (((document->RequestTx) || (document->ScanState == ScanCOMPLETE)) &&
		            		    (document->Cancelled == FALSE) && (document->Suspended == FALSE) &&
		            		    ((document->AddressRecord.SearchFlags == 0) || (document->AddressRecord.OneShotFlags == 0))	/* search completed either as expected or as a 'One shot' */
		            		   )
		            		{
#if 0		            		
		            			/*>>>kludge routing here */
                                if (document->AddressRecord.EmailAddress[0] == '\0')
                                	document->SendRoute = RouteDIRECT;
                                else
                                    document->SendRoute = RouteISP;
#endif
								switch (document->SendRoute)
								{
									case RouteDIRECT:
                                        if (connection_impossible(RouteDIRECT, &(document->Connection)))
                                        {
                                        	/* we've dialled document->AddressRecord.DirectPhoneNumber many times and failed to get through */
                                        	if (document->ReRouteAvailable)
                                        	{
                                        		/*REPORT: unable to direct dial fax, re-rerouting via ISP */
                                        		document->ReRouteAvailable = FALSE;     /* using */
                                        		document->ReRouting = TRUE;				/* alternate route */
                                        		document->SendRoute = RouteISP;         /* via ISP */
#if 0
                                                isp_dialup_watermark_reached = TRUE;	/* trigger a DIAL_ISP, which will send all the queued emails */
#else
                                        		document->RequestTx = TRUE;             /* sent ASAP */
#endif
                                        	}
                                        	else
                                        	{
                                        		/*REPORT: unable to deliver this*//* alternate route failed */
                                        		document->Cancelled = TRUE;
                                        	}
                                        }
                                        else
                                        {
                                        	if (connection_requested_now(RouteDIRECT, &(document->Connection)))
                                        	{
				            					if (send_next == NULL)
				            						send_next = document;
				            				}
				            			}
				            			break;

				            		case RouteISP:
				            			/* don't use connection_impossible(RouteISP, &isp_dialup.Connection[isp_dialup.use] as our   */
				            			/* caller uses it and always leaves structure isp_dialup looking as if connection would work */
										if (isp_unavailable)
				            			{
				            				
				            				/* we've dialled the ISP many times on many numbers and failed to get through */
				            				if (document->ReRouteAvailable)
				            				{
				            					/*REPORT: unable to contact ISP, re-routing as a direct dial call */
					            				document->ReRouteAvailable = FALSE;     /* using */
                                        		document->ReRouting = TRUE;				/* alternate route */
                                        		document->SendRoute = RouteDIRECT;      /* direct dial */
   				            				}
				            				else
				            				{
                                        		/*REPORT: unable to deliver this*//* alternate route failed */
                                        		document->Cancelled = TRUE;
				            				}
				            			}
				            			else
					            		{
					            			if (send_next_RouteISP == NULL)
					            				send_next_RouteISP = document;
	
											if (document->RequestTx)
												isp_dialup_watermark_reached = TRUE;	/* trigger a DIAL_ISP, which will send all the queued emails */	
										}
				            			break;
				            	}		
		            		}
		            	}
	        	}

				if (delete_it)
				{
	                if (document == previous)
	                {
	                	/* one document only in the queue, and we are deleting it! */
	                    previous = NULL;

	                    if (SendQ_Document_Queue == document) /* always TRUE */
	                    	SendQ_Document_Queue = previous;
	                }
	                else
	                {
	                	/* cut document from the circular queue */
	                	previous->next_document = document->next_document;
	                	
	                    if (SendQ_Document_Queue == document)
	                    	SendQ_Document_Queue = previous;	/* deleting last item in queue, so point queue at last but one entry */
	                }
/*>>>delete any pages left by failed/cancelled faxes */
                    os_destroy_directory(document->Directory);
                    free(document);

                    document = previous;
                }
	            else
	            {
	            	previous = document;	/* ready to go around the loop */
	            }
            }
	    while (document != SendQ_Document_Queue);    
	}
}

/*
 * SendQ_NextDocument - identify the next document ready send
 */
static void SendQ_NextDocument(BOOL *p_email_flag, Document *p_document)
{
	if ((isp_dialup_user_request || isp_dialup_watermark_reached) && connection_requested_now(RouteISP, &isp_dialup.Connection[isp_dialup.use]))
	{
		*p_email_flag = TRUE;
		*p_document   = send_next_RouteISP;	/* maybe NULL */	
    }
    else
    {
		*p_email_flag = FALSE;
    	*p_document = send_next;	/* maybe NULL */
    }
}


static Document document_from_pid(unsigned int pid)
{
	if (SendQ_Document_Queue)
	{
		Document document = SendQ_Document_Queue;		/* last item in queue */
		/* the pid is usually that of the first or last document, so we */
        /* allow our search to start with the tail element, followed by the head element */
        /* instead of the expected head first search */
		do
			{
				if (document->ProcessId == pid)
					return(document);

				document = document->next_document;	/* first/next item in queue */
			}
		while (document != SendQ_Document_Queue);		
	}

	return(NULL);	/* not found!!! */
}


/*
 * Given current document, find the next document to email
 */
static Document next_email(Document document)
{
	if ((document != NULL) && (document != SendQ_Document_Queue))
    {
		do
			{
				document = document->next_document;	/* next item in queue */

				if (document->SendRoute == RouteISP)
					return(document);
			}
		while (document != SendQ_Document_Queue);
    }
    
	return(NULL);	/* no more documents to email */
}


static Document document_from_SearchRef(int SearchRef)
{
	if (SendQ_Document_Queue)
	{
		Document document = SendQ_Document_Queue;		/* last item in queue */
		/* the SearchRef is usually that of the first or last document, so we */
        /* allow our search to start with the tail element, followed by the head element */
        /* instead of the expected head first search */
		do
			{
				if (document->SearchRef == SearchRef)
					return(document);

				document = document->next_document;	/* first/next item in queue */
			}
		while (document != SendQ_Document_Queue);		
	}

	return(NULL);	/* not found!!! */
}


extern AddressRec *SendQ_AddressRecord_from_pid(unsigned int pid)
{
	Document document;

	if ((document = document_from_pid(pid)) != NULL)
		return(&document->AddressRecord);

	return(NULL);	/* not found!!! */
}


extern AddressRec *SendQ_AddressRecord_from_SearchRef(int SearchRef)
{
	Document document;

	if ((document = document_from_SearchRef(SearchRef)) != NULL)
		return(&document->AddressRecord);

	return(NULL);	/* not found!!! */
}

extern void SendQ_emailaddress_from_pid(char *buffer, unsigned int pid)
{
	Document document;
	
	*buffer = '\0';

	if ((document = document_from_pid(pid)) != NULL)
	{
		strcpy(buffer, document->AddressRecord.EmailAddress);
    }
}


extern void SendQ_contactname_from_pid(char *buffer, unsigned int pid)
{
	Document document;
	
	*buffer = '\0';

	if ((document = document_from_pid(pid)) != NULL)
	{
		strcpy(buffer, document->AddressRecord.ContactName);
    }
}


extern void SendQ_subject_from_pid(char *buffer, unsigned int pid)
{
	Document document;
	
	*buffer = '\0';

	if ((document = document_from_pid(pid)) != NULL)
	{
		strcpy(buffer, document->EmailSubject);
    }
}


extern void SendQ_documentnumber_from_pid(unsigned int *p_document_number, int pid)
{
	Document document;
	
	*p_document_number = 0; /* not a valid document number */

	if ((document = document_from_pid(pid)) != NULL)
    {
		*p_document_number = document->DocumentNo;
    }
	
}


/*
 * Examine the SendQ plus various flags to determine
 * whether a document send or email retrieve should
 * be attempted.
 */
extern void SendQ_TickerHandler(void)
{
	BOOL isp_unavailable = FALSE;	/* optomistic arn't we */

	if (isp_dialup.use >= 0)
    {
		if (connection_impossible(RouteISP, &isp_dialup.Connection[isp_dialup.use]))
		{
			/* try alternate ISP phone number */
			isp_dialup.use++;
			if (isp_dialup.use >= ISP_LIST_SIZE)
			{
				/* unable to contact ISP by any of the known routes */
				/*>>>send by direct routing if available */
				isp_dialup.use = -1;	/* initialisation required */
				isp_unavailable = TRUE;
			}
	    }
    }

   	if (isp_dialup.use == -1)
   	{
   		/* initialise timers etc */
   		int i;
   		time_t now = time(NULL);
   		
   		for (i = 0; i < ISP_LIST_SIZE; i++)
   		{
   			isp_dialup.Connection[i].RetryLimit = &setup_ISP_PrimaryRedialCount;
   			isp_dialup.Connection[i].RetryCount = 0;	/* haven't tried this number yet */
   			isp_dialup.Connection[i].RetryTime  = now;
        }
		isp_dialup.use = 0;
        /*>>>should ensure at least one valid number */
	}

	if (isp_dialup.use == -1)
    	isp_unavailable = TRUE;	/* despite our best efforts, the ISP is un-useable */


	if (1 /*maybe_idle*/)	/* don't use maybe_idle flag until everything reports GOING_IDLE correctly! */
	{
		BOOL     email_flag;
		Document send_next;
		
		SendQ_QueueWalker(isp_unavailable);

		if (isp_unavailable)
		{
			isp_dialup_user_request = FALSE;
			isp_dialup_watermark_reached = FALSE;	
		}
		
        SendQ_NextDocument(&email_flag, &send_next);
	
		/* if not already sending, send the next one ready to go */
		if ((sending_already == NULL) &&
		    ((send_next != NULL) || (email_flag == TRUE))
		   )
		{
			maybe_idle = FALSE;	/* assume no response to message */
  			StateKicker_SendMessage(RemXfer_StateMachine, SQ_RX_QUERY_IDLE, NULL);

	        /* deliver the queued messages */
            while (StateKicker_Deliver() > 1)
    	        /* null statement */;
        }
	}
}





extern int HWM_Check(void)
{
	return(1);
}





/*

Address book interactive search interface

states
  Idle
  Open
  Complete
*/

_kernel_oserror *os_create_directory(const char *name)
{
  _kernel_oserror *error;
  _kernel_swi_regs r;

  r.r[0] = 8;           /* Create a directory */
  r.r[1] = (int)name;
  r.r[2] = 0;
  r.r[3] = 0;
  r.r[4] = 76;          /* give us 76 entries (ignored by Filecore) */

  error = _kernel_swi(OS_File, &r, &r);

  return(error);
}

_kernel_oserror *os_destroy_directory(const char *name)
{
/*>>>must write this one day*/
	return(NULL);
}


extern _kernel_oserror *osfile_ReadCatInfoDL(const char *directory, const char *leafname, int *pobjecttype, int *pobjectlength, int *pfiletype)
{
  _kernel_swi_regs r;
  _kernel_oserror  *error;
  char fullname[256];

  strcpy(fullname, directory);
  strcat(fullname, ".");
  strcat(fullname, leafname);

  /* Read catalogue info for named object (no path used) */
  r.r[0] = 23;
  r.r[1] = (int)fullname;
  error = _kernel_swi(OS_File, &r, &r);

  if (error == NULL)
  {
    *pobjecttype   = r.r[0];	/* 0=not found, 1=file found, 2=directory found, 3=image file found */
    *pobjectlength = r.r[4];	/* object length */
    *pfiletype     = r.r[6];	/* object filetype */
  }
  else
  {
  	*pobjecttype   = 0;			/* not found */
  	*pobjectlength = 0;   		/* object length zero bytes */
    *pfiletype     = -1;    	/* untyped */
  }

  return(error);
}


extern _kernel_oserror *set_filetype(const char *fullname, int filetype)
{
  _kernel_oserror *error;
  _kernel_swi_regs r;

  r.r[0] = 18;		/* set filetype (and date/time stamp if not set already */
  r.r[1] = (int)fullname;
  r.r[2] = filetype;

  error = _kernel_swi(OS_File, &r, &r);
  return(error);
}


extern _kernel_oserror *set_filetypeDL(const char *directory, const char *leafname, int filetype)
{
  char fullname[256];

  strcpy(fullname, directory);
  strcat(fullname, ".");
  strcat(fullname, leafname);

  return(set_filetype(fullname, filetype));
}


extern _kernel_oserror *set_filetypeDN(const char *directory, const unsigned int leafnumber, int filetype)
{
	char fullname[256];

	sprintf(fullname, "%s.%d", directory, leafnumber);
    return(set_filetype(fullname, filetype));
}


extern _kernel_oserror *renameDLN(const char *directory, const char *from_leafname, const unsigned int to_leafnumber)
{
	char command[256];
	
	sprintf(command, "Rename %s.%s %s.%d", directory, from_leafname, directory, to_leafnumber);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *renameDLDL(const char *from_directory, const char *from_leafname, const char *to_directory, const char *to_leafname)
{
	char command[256];
	
	sprintf(command, "Rename %s.%s %s.%s", from_directory, from_leafname, to_directory, to_leafname);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *renameDNDL(const char *from_directory, const unsigned int from_leafnumber, const char *to_directory, const char *to_leafname)
{
	char command[256];
	
	sprintf(command, "Rename %s.%d %s.%s", from_directory, from_leafnumber, to_directory, to_leafname);
    _kernel_oscli(command);
    return(NULL);
}


extern _kernel_oserror *renameDNDN(const char *from_directory, const unsigned int from_leafnumber, const char *to_directory, const unsigned int to_leafnumber)
{
	char command[256];
	
	sprintf(command, "Rename %s.%d %s.%d", from_directory, from_leafnumber, to_directory, to_leafnumber);
    _kernel_oscli(command);
    return(NULL);
}


extern void remove_fileDL(const char *directory, const char *leafname)
{
  char command[256];

  strcpy(command, "remove ");
  strcat(command, directory);
  strcat(command, ".");
  strcat(command, leafname);

  _kernel_oscli(command);
}

extern void purge_directory(const char *directory, const int loPage, const int hiPage)
{
  int i;
  char command[256];

  for (i=loPage; i<=hiPage; i++)
  {
    sprintf(command, "remove %s.%d", directory, i);
    _kernel_oscli(command);
  }
}


extern void readvarval(const char *name, char *buffer, int buffmax)
{
  _kernel_swi_regs r;

  r.r[0] = (int)name;
  r.r[1] = (int)buffer;
  r.r[2] = buffmax;
  r.r[3] = 0;		/* first call */
  r.r[4] = 0;

  _kernel_swi(OS_ReadVarVal, &r, &r);

  /* if not a string, pretend it doesn't exist */
  if (r.r[4] != 0)
    r.r[2] = 0;

  buffer[r.r[2]] = '\0';	/* terminate*/
}

#if SUPPORT_EMAIL
#if KLUDGE_EMAIL
void test_emailsend(void)
{
	Document document;

	SendQ_CreateDocument(&document);
	if (document)
	{
		char command[256];
		messageDataBlock *sendMessage;

    	sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.1 ~cf~v", document->Directory);
        _kernel_oscli(command);
        document->ScanCount += 1;

        sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.2 ~cf~v", document->Directory);
        _kernel_oscli(command);
        document->ScanCount += 1;

#if 1
    	sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.3 ~cf~v", document->Directory);
        _kernel_oscli(command);
        document->ScanCount += 1;

        sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.4 ~cf~v", document->Directory);
        _kernel_oscli(command);
        document->ScanCount += 1;


    	sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.5 ~cf~v", document->Directory);
        _kernel_oscli(command);
        document->ScanCount += 1;

        sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.6 ~cf~v", document->Directory);
        _kernel_oscli(command);
        document->ScanCount += 1;

        sprintf(command, "copy ADFS::RCManby.$.Work.Daytona.Software.TestFiles.1 %s.7 ~cf~v", document->Directory);
        _kernel_oscli(command);
        document->ScanCount += 1;
#endif

		document->ScanState = ScanCOMPLETE;			/* complete (3)  */
		document->RequestTx = 1;			/* requesting */

		document->SearchRef = document->ProcessId; /* good enough (cos its unique) as the message ref when faking messages */

        strcpy(document->AddressRecord.DirectPhoneNumber, "-5337");
#if 0
        strcpy(document->AddressRecord.EmailAddress, "daytona@rwarren.acorn.co.uk");
#else
        strcpy(document->AddressRecord.EmailAddress, "wibble@rwarren.acorn.co.uk");
#endif        
        document->AddressRecord.OneShotFlags = 0;

		StateKicker_SendMessage(SendQ_MessageHandler, AD_SQ_FINISH, &sendMessage);
		sendMessage->data.finish.searchref = document->SearchRef;


    }
}
#endif
#endif

/* end of SendQ.c */


