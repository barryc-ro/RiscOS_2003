/* > plugclient.c

 * Main file for a plugin client

 */

#include <ctype.h>
#include <locale.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "swis.h"

#include "toolbox.h"
#include "window.h"
#include "quit.h"
#include "event.h"

#include "wimplib.h"

#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif

#include "plugin.h"
#include "plugclient.h"
#include "version.h"
#include "clients.h"
#include "ctstypes.h"
#include "ctsintern.h"
#include "ctsbrowser.h"
#include "utils.h"

#include "smartcard.h"
#include "ctsui.h"

/* --------------------------------------------------------------------------------------------- */

#define APP_DIR		            "<"APP_NAME"$Dir>"
#define MESSAGE_BROWSER_OPENURL     0x4AF80
#define POLL_TIME	            100	/* 1 second */
#define MIN_ESC_TIME	            50	/* cs */
#define NCMA_MiscOp                 0x4f001

/* --------------------------------------------------------------------------------------------- */

typedef union
{
  char url[236];
  struct
  {
    int tag;
    plugin_string_value url;
    int flags;
    plugin_string_value body_file;
    plugin_string_value target;
  } indirect;
} openurl_data;

typedef struct pluginclient_instance	pluginclient_instance;

/* --------------------------------------------------------------------------------------------- */

static MessagesFD message_block;    /* declare a message block for use with toolbox initialise */
static IdBlock event_id_block;      /* declare an event block for use with toolbox initialise  */

static int ToolBox_EventList[] =
{
  event_SMARTCARD_INSERTED,
  event_SMARTCARD_BAD_OBJECT_INSERTED,
  event_SMARTCARD_REMOVED,
  event_SMARTCARD_SYS_ERROR,
  event_SMARTCARD_COMMAND_DONE,
  event_SMARTCARD_TRANSACTION_ENDED,
  event_STREAM_DESTROY,
  Quit_Quit,
  0
};

static int Wimp_MessageList[] =

{
    Wimp_MDataOpen,
    Wimp_MTaskCloseDown,
    Wimp_MHelpRequest,
    MESSAGE_BROWSER_OPENURL,
    MESSAGE_PLUGIN_OPEN,
    MESSAGE_PLUGIN_CLOSE,
    MESSAGE_PLUGIN_RESHAPE,
    MESSAGE_PLUGIN_FOCUS,
    MESSAGE_PLUGIN_STREAM_NEW,
    MESSAGE_PLUGIN_STREAM_AS_FILE,
    MESSAGE_PLUGIN_STREAM_DESTROY,
    MESSAGE_PLUGIN_ACTION,
    MESSAGE_PLUGIN_ABORT,
    0
};

static int event_mask =
      Wimp_Poll_PointerLeavingWindowMask
    | Wimp_Poll_PointerEnteringWindowMask
    | Wimp_Poll_PollWord
    | Wimp_Poll_PollWordHighPriority;

/* --------------------------------------------------------------------------------------------- */

static int last_checkpoint = 0;
static int n_instances = 0;

/* cli set values */

static char *cli_filename = NULL;
static int cli_timeout = -1; /* infinite */

/* key handling for moving focus */

static int last_key_code = -1;
static int last_key_time = 0;

/* --------------------------------------------------------------------------------------------- */

//static int browser_closedown_handler(WimpMessage *message, void *handle);
static void close_child_window(pluginclient_instance *plugin);
static void dispose_plugin_info(pluginclient_instance *plugin);
static int immediate_file_play(char *file_name);

/* --------------------------------------------------------------------------------------------- */

/*
 * Signal handling.
 * Output postmortem on error if debugging
 */

#define FATAL_ERROR utils_msgs_lookup("Ewimpt1:%.*s has suffered a fatal internal error (type=%i) and must exit immediately")

static _kernel_oserror	sig_errmsg;
static char		*sig_numspot;
static int		sig_dopostmortem = FALSE;

static void escape_handler(int sig)
{
    (void) signal(sig, &escape_handler);
}

static void handler(int signal)
{
    *sig_numspot = signal + '0';

    wimp_report_error(&sig_errmsg, 0, utils_msgs_lookup("_TaskName"));

    if (sig_dopostmortem) switch (signal)
    {
        case SIGFPE:
        case SIGILL:
        case SIGSEGV:
            return;
    }

    exit(EXIT_FAILURE);
}

static void signal_setup(void)
{
    char *taskname = utils_msgs_lookup("_TaskName");
    size_t len = strcspn(taskname, "\n");

    sig_errmsg.errnum = 0;
    sprintf(sig_errmsg.errmess, FATAL_ERROR, len, taskname, 9);
    sig_numspot = strchr(sig_errmsg.errmess, '9');

    signal(SIGABRT, &handler);
    signal(SIGFPE, &handler);
    signal(SIGILL, &handler);
    signal(SIGINT, &escape_handler);
    signal(SIGSEGV, &handler);
    signal(SIGTERM, &handler);
}

/* --------------------------------------------------------------------------------------------- */

struct pluginclient_instance
{
    pluginclient_instance	*prev, *next;

    void		*parent_instance;
    int			parent_window;
    BBox		parent_box;
    int			parent_task;

    pluginclient_param	*param_list;

    ObjectId		window;
    int			msgref;		/* ref of last message sent */

    int			wimp_window;	/* wimp version of 'window' handle */

    pluginclient        *plugin_fns;    /* functions depending on whether
                                         * codec/replay/midi etc. */

    client_ptr          client_data;    /* client's private data */

    BOOL                helper;         /* Is this a helper or plugin */

    BOOL           closed_message_sent; /* Whether we've sent a closed message
                                         * to browser - so we only send the
                                         * first one, which will be the one with
                                         * the first error
                                         */
};

/* --------------------------------------------------------------------------------------------- */

static pluginclient_instance	*plugin_list = NULL;

/* For new clients increase the size of all_pluginclients
 * and add to function below to get initialised
 */

static pluginclient *all_pluginclients[2];

static void patch_all_pluginclients( void )
{
  all_pluginclients[0] = &pluginclient_cts;
  all_pluginclients[1] = NULL;
}

/* --------------------------------------------------------------------------------------------- */

static pluginclient_instance *find_plugin(ObjectId id, int wimp_window)
{
    pluginclient_instance *plugin;
    for (plugin = plugin_list; plugin; plugin = plugin->next)
    {
	if (id == plugin->window || wimp_window == plugin->wimp_window)
	    break;
    }
    return plugin;
}

/* find the pluginclient that handles this file type, or NULL if not found */
static pluginclient *handle_file_type(int file_type)
{
    int *ft;
    pluginclient **curr_pluginclient;

    for (curr_pluginclient=&all_pluginclients[0]; *curr_pluginclient;
         curr_pluginclient++)
    {
      if (!(*curr_pluginclient)->file_type_list) continue;

      for (ft = (*curr_pluginclient)->file_type_list; *ft != -1; ft++)
	if (*ft == file_type)
	    return *curr_pluginclient;
    } /* for */

    return NULL;
}

/* --------------------------------------------------------------------------------------------- */

/*
 * Read a string from the parameter file
 */

static char *read_string(FILE *f)
{
    int string_size;
    char *string;

    fread(&string_size, 4, 1, f);

    if (string_size == 0)
	return NULL;

    if ((string = malloc(string_size+1)) != NULL)
    {
	fread(string, string_size, 1, f);
	string[string_size] = 0;
    }

    /* word-align pointer */
    fseek(f, (long) (4L - (string_size & 3L)) & 3L, SEEK_CUR);

    return string;
}

/*
 * Read and parse the whole parameter file
 */

static void parse_parameter_file(pluginclient_instance *plugin, const char *file_name)
{
    FILE *f;

    dprintf(("plugclient_1", "parse_parameter_file(): instance %p '%s' length %d\n", plugin, file_name,
      get_file_length(file_name)));

    if ((f = fopen(file_name, "rb")) != NULL)
    {
	plugin_parameter_type type;
	int size, pos = 0;

	do
	{
	    type = plugin_parameter_TERMINATOR;
	    fread(&type, 4, 1, f);

	    dprintf(("plugclient_4", "param: type %d \n", type));

	    if (type != plugin_parameter_TERMINATOR)
	    {
		pluginclient_param *param;

		/* read size of strings */
		fread(&size, 4, 1, f);

		dprintf(("plugclient_4", "param: string size %d \n", size));

		/* read in the strings */
		if ((param = calloc(sizeof(*param), 1)) != NULL)
		{
		    /* store type */
		    param->type = type;

		    /* read strings */
		    param->name = read_string(f);
		    param->value = read_string(f);
		    param->value_type = read_string(f);

		    dprintf(("plugclient_1", "param: '%s' '%s' '%s' \n",
		    	strsafe(param->name), strsafe(param->value), strsafe(param->value_type)));

		    /* attach to list */
		    param->next = plugin->param_list;
		    plugin->param_list = param;
		}

		/* advance to next record */
		pos += 2*4 + ROUND4(size);
		fseek(f, pos, SEEK_SET);

		dprintf(("plugclient_4", "param: skip to %d \n", pos));
	    }
	}
	while (type != plugin_parameter_TERMINATOR);

	fclose(f);
    }
}

/*
 * Dispose of the memory used by a parameter list
 */

static void free_params(pluginclient_param *param)
{
    dprintf(("plugclient_2", "free_params(): %p\n", param));

    while (param)
    {
	pluginclient_param *next = param->next;

	free(param->name);
	free(param->value);
	free(param->value_type);
	free(param);

	param = next;
    }
}

pluginclient_param *pluginclient_param_lookup(pluginclient_instance *plugin, const char *name,
                                              int mask, int case_sensitive)
{
    pluginclient_param *param;

    dprintf(("plugclient_2", "pluginclient_param_lookup(): instance %p name %s mask %x case %d\n",
    	plugin, name, mask, case_sensitive));

    for (param = plugin->param_list; param; param = param->next)
    {
        dprintf(("plugclient_5", "Name=`%s' value=`%s'\n", param->name, strsafe(param->value)));
	if (((1 << param->type) & mask))
	{
	    if (case_sensitive)
	    {
		if (strcmp(name, param->name) == 0)
		    break;
	    }
	    else
	    {
		if (strcasecomp(name, param->name) == 0)
		    break;
	    }
	}
    }

    dprintf(("plugclient_2", "pluginclient_param_lookup(): returns '%s'\n", param ? strsafe(param->value) : ""));

    return param;
}

void pluginclient_decrement_count(void)
{
    n_instances--;
    last_checkpoint = clock()/CLK_TCK;
}

void pluginclient_increment_count(void)
{
    n_instances++;
    last_checkpoint = 0;
}

/* --------------------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------------------- */

typedef struct pluginclient_string_rma_ptr pluginclient_string_rma_ptr;

struct pluginclient_string_rma_ptr
{
    pluginclient_string_rma_ptr *prev, *next;
    pluginclient_instance *pp;
    int msgref;
};

static pluginclient_string_rma_ptr *rma_ptr_list = NULL;

/* ----------------------------------------------------------------------------- */


/*
 * get a ptr to real data from a plugin message.
 * The data may be in the message body or in the RMA.
 */

static char *get_ptr(void *msgdata, plugin_string_value sv)
{
    return sv.offset == 0 ? 0 : sv.offset <= 236 ? (char *)msgdata + sv.offset : sv.ptr;
}

/* --------------------------------------------------------------------------------------------- */

/*
 * Copy the string 's' into a block allocated from the RMA and link it into the
 * list of blocks so allocated.
 */

static void *rma_dup(const char *s)
{
    pluginclient_string_rma_ptr *ptr;
    int len = strlen(s) + 1;

    if ((ptr = rma_alloc(len + sizeof(pluginclient_string_rma_ptr))) == NULL)
	return NULL;

    ptr->prev = NULL;
    ptr->next = rma_ptr_list;
    ptr->msgref = -1;

    if (rma_ptr_list)
	rma_ptr_list->prev = ptr;

    rma_ptr_list = ptr;

    memcpy(ptr+1, s, len);

    return ptr+1;
}

static void free_rma_strings(int msgref, pluginclient_instance *pp)
{
    pluginclient_string_rma_ptr *psrp;
    for (psrp = rma_ptr_list; psrp; psrp = psrp->next)
    {
	/* if either the msgref or pointer match then
	 * remove from the list and free
	 */
	if (psrp->msgref == msgref || psrp->pp == pp)
	{
	    if (psrp->prev)
		psrp->prev->next = psrp->next;
	    if (psrp->next)
		psrp->next->prev = psrp->prev;

	    rma_free(psrp);
	}
    }
}

static void write_string(WimpMessage *mp, plugin_string_value *so, const char *data)
{
    int space_left = sizeof(*mp) - mp->hdr.size;
    int data_len;

    if (data == NULL) {
      so->ptr = NULL;
      return;
    }

    data_len = strlen(data) + 1;

    if (data_len <= space_left)
    {
 	so->offset = mp->hdr.size - sizeof(mp->hdr); /* offset is relative to data start */
	strcpy(mp->data.bytes + so->offset, data);
	mp->hdr.size += data_len;
    }
    else
    {
	/* copy to rma */
	so->ptr = rma_dup(data);
    }
}

static void send_message(WimpMessage *msg, pluginclient_instance *pp)
{
    message_plugin_base *base = (message_plugin_base *)&msg->data;
    pluginclient_string_rma_ptr *psrp;

    dprintf(("plugclient_4", "send_message(%p, %p) [%p] (local variable at %p)\n", msg, pp, pp?pp:0, &base));

    if (!pp || !pp->parent_instance) return;

    dprintf(("plugclient_4", "Sending message to browser\n"));
    base->instance.plugin = pp;
    base->instance.parent = pp->parent_instance;

    msg->hdr.size = ROUND4(msg->hdr.size);

    err_fatal(wimp_send_message(Wimp_EUserMessage, msg, pp->parent_task, -1, NULL));
    pp->msgref = msg->hdr.my_ref;

    /* rma allocated pointers are linked into list, we need to write in the msg reference */
    for (psrp = rma_ptr_list; psrp && psrp->msgref == -1; psrp = psrp->next)
    {
	psrp->msgref = msg->hdr.my_ref;
	psrp->pp = pp;
    }
}

/* --------------------------------------------------------------------------------------------- */

/*
 * Send a message closed to the parent.
 */

void pluginclient_send_closed(pluginclient_instance *plugin, int your_ref,
                              _kernel_oserror *e, int close_now)
{
    WimpMessage message;
    message_plugin_closed *msg = (message_plugin_closed *)message.data.bytes;

    dprintf(("plugclient_4", "pluginclient_send_closed() closed message sent before = %d\n",
           plugin->closed_message_sent));

    if (plugin->closed_message_sent == TRUE) /* don't send >1 closed to browser */
      return;

    message.hdr.your_ref = your_ref;
    message.hdr.action_code = MESSAGE_PLUGIN_CLOSED;
    message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_closed);

    msg->flags = your_ref ? 0 : plugin_closed_NOT_REPLY;
    msg->flags |= close_now ? plugin_closed_EXITING : 0;

    if (e)
    {
	msg->errnum = e->errnum;
	strncpy(msg->errmess, e->errmess, sizeof(msg->errmess));
	msg->errmess[sizeof(msg->errmess)-1] = 0;

	msg->flags |= plugin_closed_ERROR_MSG;
    }

    send_message(&message, plugin);

    plugin->closed_message_sent=TRUE;
}

/*
 * Send a STATUS message
 */

void pluginclient_send_status(pluginclient_instance *plugin, const char *status)
{
    WimpMessage message;
    message_plugin_status *msg = (message_plugin_status *)message.data.bytes;

    message.hdr.your_ref = 0;
    message.hdr.action_code = MESSAGE_PLUGIN_STATUS;
    message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_status);

    write_string(&message, &msg->message, status);

    send_message(&message, plugin);
}

/*
 * Send a FOCUS message
 */

static void pluginclient_send_focus(pluginclient_instance *plugin)
{
    WimpMessage message;

    message.hdr.your_ref = 0;
    message.hdr.action_code = MESSAGE_PLUGIN_FOCUS;
    message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_focus);

    send_message(&message, plugin);
}

/* send a busy message to browser. If no reason, set reason to -1 */
void pluginclient_send_busy(pluginclient_instance *plugin, int busy, int reason)
{
    WimpMessage message;
    message_plugin_busy *busy_mess;

    message.hdr.your_ref = 0;
    message.hdr.action_code = MESSAGE_PLUGIN_BUSY;
    message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_busy);

    busy_mess = (message_plugin_busy *) &message.data;
    busy_mess->flags = (busy ? plugin_busy_flags_BUSY : 0) |
                       (reason != -1 ? plugin_busy_flags_GOT_REASON : 0);
    busy_mess->reason = reason; /* doesn't matter whether -1 or not, as flag means
                                 * it won't be looked at if it is */
    send_message(&message, plugin);

    /* if we've stopped, and we're a -file client, then quit the client */
    if (reason==plugin_busy_STOP && !plugin->parent_instance)
    {
      dprintf(("plugclient_4", "pluginclient_send_busy() noticed STOP with no parent\n"));

      /* call client specific code */
      if (plugin->plugin_fns->client_close)
        plugin->plugin_fns->client_close(plugin->client_data);

      /* dispose of window and plugin info */
      close_child_window(plugin);

      /* dispose of stuff */
      dispose_plugin_info(plugin);
    } /* if */
} /* pluginclient_send_busy */


/* tell the browser to go to the specified url */
void pluginclient_browser_goto_with_target(pluginclient_instance *plugin, const char *url, const char *target)
{
  WimpMessage message;
  openurl_data *data = (openurl_data *) &message.data;
  pluginclient_string_rma_ptr *psrp;

  if (!plugin->parent_task) return;

  dprintf(("plugclient_browser_goto", "pluginclient_browser_goto_with_target: `%s' (`%s')\n", url, strsafe(target)));

  /* If it's not internal (like a dbox open/close, output some logging */
  if (target == NULL)
    log_send_msg (log_ACCESS_WEB_PAGE, strsafe(url));

  message.hdr.size = sizeof(message.hdr);
  message.hdr.your_ref = 0;
  message.hdr.action_code = MESSAGE_BROWSER_OPENURL;

  if (strlen(url) < sizeof(data->url) && target == NULL)
  {
    strcpy(&data->url[0], url);
    message.hdr.size += strlen(url) + 1;
  } /* if */
  else
  {
    data->indirect.tag = 0;
    data->indirect.flags = 0;
    data->indirect.body_file.ptr = NULL;
    message.hdr.size += sizeof(data->indirect);
    write_string(&message, &data->indirect.target, target);
    write_string(&message, &data->indirect.url, url);
  } /* else */

  message.hdr.size = ROUND4(message.hdr.size);

  err_fatal(wimp_send_message(Wimp_EUserMessage, &message, plugin->parent_task,
                              0, NULL));
  plugin->msgref = message.hdr.my_ref;

  /* rma allocated pointers are linked into list, we need to write in the msg reference */
  for (psrp = rma_ptr_list; psrp && psrp->msgref == -1; psrp = psrp->next)
  {
    psrp->msgref = message.hdr.my_ref;
    psrp->pp = plugin;
  } /* for */
} /* pluginclient_browser_goto */

void pluginclient_browser_goto(pluginclient_instance *plugin, const char *url)
{
        pluginclient_browser_goto_with_target(plugin, url, NULL);
}

static char *pluginclient_get_post_data_filename(void)
{
        static char name[L_tmpnam];
	static int first = 1;

	if (first) {
	        first = 0;
	        atexit((void (*)(void))pluginclient_get_post_data_filename);
	}
	else {
	        remove(name);
	}

	tmpnam(name);
	dprintf(("temporary_file", "Temporary filename is `%s'\n", name));
	return name;
}

/* tell the browser to go to the specified url in the specified target */
void pluginclient_browser_access_url(pluginclient_instance *plugin, const char *url, const char *target)
{
    WimpMessage message;
    message_plugin_url_access *msg = (message_plugin_url_access *)message.data.bytes;
    char *query = strchr(url, '?');

    dprintf(("plugclient_browser_access_url", "(1) pluginclient_browser_access_url: `%s' on `%s'\n",
    	strsafe(url), strsafe(target)));

    /* If it's not internal (like a dbox open/close, output some logging */
    if (target == NULL)
      log_send_msg (log_MESSAGE_TO_SERVER, strsafe(url));

    message.hdr.your_ref = 0;
    message.hdr.action_code = MESSAGE_PLUGIN_URL_ACCESS;
    message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_url_access);

    if (target == NULL) {
            	/* Stream data to us - we want to POST */
		msg->flags = plugin_url_access_POST | plugin_url_access_POST_FILE;
		if (query) *query = '\0';
    		write_string(&message, &msg->url, url);
    		if (query) *query++ = '?';
    }
    else {
            /* Dialogue box - don't want a POST */
	    msg->flags = 0;
            query = NULL;
    	    write_string(&message, &msg->url, url);
    }

    write_string(&message, &msg->target, target);
    msg->notify_data = 0;
    if (query) {
            FILE *f;
            char *name = pluginclient_get_post_data_filename();
	    msg->data_len = strlen(query);
	    write_string(&message, &msg->data, name);
	    f = fopen(name, "wb");
	    if (f) {
	            (void) fwrite(query, msg->data_len, 1, f);
	            (void) fclose(f);
	    }
	    else {
	            /* Minor leak - but only on serious failures! */
	            dprintf(("", "FATAL! Unable to open post data file\n"));
		    msg->data_len = 0;
	            msg->data.ptr = NULL;
	    }
    }
    else {
	    msg->data_len = 0;
            msg->data.ptr = NULL;
    }

    dprintf(("plugclient_browser_access_url", "(2) pluginclient_browser_access_url: `%s' on `%s'\n",
    	strsafe(get_ptr(msg, msg->url)), strsafe(get_ptr(msg, msg->target))));

    send_message(&message, plugin);
    dprintf(("plugclient_browser_access_url", "(3) send message has returned\n"));
}

/* --------------------------------------------------------------------------------------------- */

void pluginclient_window_position(pluginclient_instance *plugin, BBox *box, int *xscroll, int *yscroll)
{
    WimpGetWindowStateBlock state;

    state.window_handle = (int)plugin->wimp_window;
    err_fatal(wimp_get_window_state(&state));

    if (box)
	*box = state.visible_area;
    if (xscroll)
	*xscroll = state.xscroll;
    if (yscroll)
	*yscroll = state.yscroll;
}

/* --------------------------------------------------------------------------------------------- */

/*
 * These two routines will handle redraws on a window
 */

_kernel_oserror *pluginclient_redraw(int window_handle,
                                     pluginclient_redraw_handler setup,
                                     pluginclient_redraw_handler draw,
                                     void *cp)
{
    int more;
    _kernel_oserror *e;
    WimpRedrawWindowBlock r;

    r.window_handle = window_handle;
    e = wimp_redraw_window(&r, &more);

    if (!e && more && setup)
    	e = setup(cp, &r, FALSE);

    while (!e && more)
    {
    	if (draw) e = draw(cp, &r, FALSE);
	if (!e) e = wimp_get_rectangle(&r, &more);
    }

    return e;
}

_kernel_oserror *pluginclient_update(WimpUpdateWindowBlock *update,
                                     pluginclient_redraw_handler setup,
                                     pluginclient_redraw_handler draw,
                                     void *cp)
{
    int more;
    _kernel_oserror *e;
    WimpRedrawWindowBlock r;

    r.window_handle = update->window_handle;
    r.visible_area = update->update_area;

    e = wimp_update_window(&r, &more);

    if (!e && more && setup)
    	e = setup(cp, &r, TRUE);

    while (!e && more)
    {
    	if (draw) e = draw(cp, &r, TRUE);
	if (!e) e = wimp_get_rectangle(&r, &more);
    }

    return e;
}

_kernel_oserror *pluginclient_update_area(pluginclient_instance *plugin, const BBox *box)
{
    WimpUpdateWindowBlock update;
    update.window_handle = plugin->wimp_window;
    if (box)
        update.update_area = *box;
    else
    {
      	update.update_area.xmin = update.update_area.ymin = -0x4000;
      	update.update_area.xmax = update.update_area.ymax =  0x4000;
    }

    return pluginclient_update(&update,
    	(pluginclient_redraw_handler)plugin->plugin_fns->client_redraw_setup,
    	(pluginclient_redraw_handler)plugin->plugin_fns->client_redraw, plugin->client_data);
}

/* --------------------------------------------------------------------------------------------- */

/* Window handlers */

static int redraw_handler(int event_code, WimpPollBlock *event, IdBlock *id_block,
                          void *handle)
{
    pluginclient_instance *plugin = handle;
    WimpRedrawWindowRequestEvent *e = &event->redraw_window_request;

    dprintf(("plugclient_4", "redraw_handler(): instance %p\n", plugin));

    err_fatal(pluginclient_redraw(e->window_handle,
                                  (pluginclient_redraw_handler)plugin->plugin_fns->client_redraw_setup,
                                  (pluginclient_redraw_handler)plugin->plugin_fns->client_redraw,
                                  plugin->client_data));

    return 1;
    NOT_USED(id_block);
    NOT_USED(event_code);
}

static int click_handler(int event_code, WimpPollBlock *event, IdBlock *id_block,
                         void *handle)
{
    pluginclient_instance *plugin = handle;
    WimpMouseClickEvent *e = &event->mouse_click;

    dprintf(("plugclient_4", "click_handler(): instance %p\n", plugin));

    if (plugin->plugin_fns->client_click)
      plugin->plugin_fns->client_click(plugin->client_data, e);

    return 1;
    NOT_USED(id_block);
    NOT_USED(event_code);
}

static int key_handler(int event_code, WimpPollBlock *event, IdBlock *id_block,
                       void *handle)
{
    pluginclient_instance *plugin = handle;
    WimpKeyPressedEvent *e = &event->key_pressed;
    int claimed = FALSE;

    if (e->key_code == 27)
    {
	time_t t = clock();

	if (last_key_code == 27 && (t - last_key_time) <= MIN_ESC_TIME)
	{
	    /* pass focus back to browser */
	    pluginclient_send_focus(plugin);

	    claimed = TRUE;
	}

	last_key_time = t;
    }

    last_key_code = e->key_code;

    if (!claimed && plugin->plugin_fns->client_key)
	plugin->plugin_fns->client_key(plugin->client_data, e);

    return 1;
    NOT_USED(id_block);
    NOT_USED(event_code);
}

static int gain_caret_handler(int event_code, WimpPollBlock *event,
                              IdBlock *id_block, void *handle)
{
    pluginclient_instance *plugin = handle;

    if (plugin->plugin_fns->client_focus)
      plugin->plugin_fns->client_focus(plugin->client_data);

    return 1;
    NOT_USED(id_block);
    NOT_USED(event_code);
    NOT_USED(event);
}

static int lose_caret_handler(int event_code, WimpPollBlock *event,
                              IdBlock *id_block, void *handle)
{
    pluginclient_instance *plugin = handle;

    if (plugin->plugin_fns->client_blur)
      plugin->plugin_fns->client_blur(plugin->client_data);

    return 1;
    NOT_USED(id_block);
    NOT_USED(event_code);
    NOT_USED(event);
}

/* --------------------------------------------------------------------------------------------- */

static void add_window_handlers(ObjectId id, void *handle)
{
    /* wimp event handlers */
    dprintf(("plugclient_3", "add_window_handlers: id %08x\n", id));

    err_fatal(event_register_wimp_handler(id, Wimp_ERedrawWindow, redraw_handler, handle));
    err_fatal(event_register_wimp_handler(id, Wimp_EMouseClick, click_handler, handle));
    err_fatal(event_register_wimp_handler(id, Wimp_EKeyPressed, key_handler, handle));
    err_fatal(event_register_wimp_handler(id, Wimp_EGainCaret, gain_caret_handler, handle));
    err_fatal(event_register_wimp_handler(id, Wimp_ELoseCaret, lose_caret_handler, handle));
}

static void remove_window_handlers(ObjectId id, void *handle)
{
    /* wimp event handlers */
    dprintf(("plugclient_3", "remove_window_handlers: id %08x\n", id));

    err_fatal(event_deregister_wimp_handler(id, Wimp_ERedrawWindow, redraw_handler, handle));
    err_fatal(event_deregister_wimp_handler(id, Wimp_EMouseClick, click_handler, handle));
    err_fatal(event_deregister_wimp_handler(id, Wimp_EKeyPressed, key_handler, handle));
    err_fatal(event_deregister_wimp_handler(id, Wimp_EGainCaret, gain_caret_handler, handle));
    err_fatal(event_deregister_wimp_handler(id, Wimp_ELoseCaret, lose_caret_handler, handle));
}

/* --------------------------------------------------------------------------------------------- */

/*
 * open the child window in the parent
 */

static int open_child_window(pluginclient_instance *plugin, BOOL subwindow)
{
    WindowShowObjectBlock full_spec;
    WimpGetWindowStateBlock state;
    int ret_code=0;

    dprintf(("plugclient_4", "open_child_window(): plugin %p subwindow %d\n", plugin, subwindow));
    /* create the window if not already there */
    if (plugin->window == NULL_ObjectId)
    {
	err_fatal(toolbox_create_object(0, OUR_OBJECT, &plugin->window));
    }

    if (subwindow==TRUE)
    {
      /* get the state of the parent */
      state.window_handle = (int)plugin->parent_window;
      err_fatal(wimp_get_window_state(&state));

      /* construct the open details for the plugin */
      full_spec.visible_area.xmin = plugin->parent_box.xmin +
                                    state.visible_area.xmin - state.xscroll;
      full_spec.visible_area.ymin = plugin->parent_box.ymin +
                                    state.visible_area.ymax - state.yscroll;
      full_spec.visible_area.xmax = plugin->parent_box.xmax +
                                    state.visible_area.xmin - state.xscroll;
      full_spec.visible_area.ymax = plugin->parent_box.ymax +
                                    state.visible_area.ymax - state.yscroll;

      /* only show if height and width are both greater than 1 pixel */
      if (((full_spec.visible_area.xmax - full_spec.visible_area.xmin) > 1) &&
    	  ((full_spec.visible_area.ymax - full_spec.visible_area.ymin) > 1))
      {
    	  full_spec.xscroll = 0;
	  full_spec.yscroll = 0;
	  full_spec.behind = -3;
	  full_spec.window_flags = 0;
	  full_spec.parent_window_handle = (int)plugin->parent_window;
	  full_spec.alignment_flags = 0;

	  /* show it */
	  err_fatal(toolbox_show_object(0, //Toolbox_ShowObject_AsSubWindow,
	                                plugin->window, Toolbox_ShowObject_FullSpec,
	                                &full_spec, 0, -1));
	  ret_code=1;
      } /* if */
    } /* if */

    /* if a subwindow, tell the client where it is. If not a subwindow, client
     * takes note and will open window itself later if necessary */
    if (plugin->plugin_fns->client_set_window)
      plugin->plugin_fns->client_set_window(plugin->client_data, plugin->window,
                                            &full_spec.visible_area, subwindow);
    return ret_code;
}

/*
 * dispose of the child window in the parent
 */

static void close_child_window(pluginclient_instance *plugin)
{
    dprintf(("plugclient_4", "close_child_window() : plugin %p\n", plugin));

    remove_window_handlers(plugin->window, plugin);

    /* remove window */
    err_report(toolbox_delete_object(0, plugin->window));
    plugin->window = 0;
}

/* --------------------------------------------------------------------------------------------- */

static void dispose_plugin_info(pluginclient_instance *plugin)
{
    dprintf(("plugclient_1", "dispose_plugin_info(): instance %p\n", plugin));

    /* free memory and zero pointers */
    free_params(plugin->param_list);
    plugin->param_list = NULL;

    free_rma_strings(NULL, plugin);

    /* unlink */
    if (plugin->prev)
	plugin->prev->next = plugin->next;
    else
	plugin_list = plugin->next;

    if (plugin->next)
	plugin->next->prev = plugin->prev;

    /* decrement uses and start exit timer */
    pluginclient_decrement_count();

    /* free */
    free(plugin);
}

/* Check if the browser has deserted us! */
static int browser_closedown_handler(WimpMessage *message, void *handle)
{
  pluginclient_instance *plugin = (pluginclient_instance *) handle;

  if (message->hdr.sender == plugin->parent_task)
  {
    dprintf(("plugclient_1", "browser_closedown_handler\n"));

    err_report(event_deregister_message_handler(Wimp_MTaskCloseDown,
                                                &browser_closedown_handler,
                                                plugin));

    /* dispose of window and plugin info */
    close_child_window(plugin);

    /* call client specific code */
    if (plugin->plugin_fns->client_close)
      plugin->plugin_fns->client_close(plugin->client_data);

    /* dispose of stuff */
    dispose_plugin_info(plugin);

#ifndef MUST_REMOVE_IF_SILLY_TOOLBOX_BUG_SOMEWHERE_FIXED
    {
      pluginclient_instance *next;
      for (plugin = plugin_list; plugin; plugin = next)
      {
        /* closedown other plugins, but only one at a time, otherwise
         * we would free the same ones multiple times */

        next = plugin->next; /* prevent use when free()'d */
        if (message->hdr.sender == plugin->parent_task)
        {
          browser_closedown_handler(message, (void *) plugin);
          break; /* only kill one other plugin */
        } /* if */
      } /* for */
    }
#endif

  } /* if */

  return 0; /* allow other tasks to get message */
} /* browser_closedown_handler */

static void dispose_plugin_all(void)
{
    dprintf(("plugclient_1", "dispose_plugin_all():\n"));
    while (plugin_list)
    {
	/* notify host */
	pluginclient_send_closed(plugin_list, 0, NULL, 0);

        /* don't complain if not registered! */
        event_deregister_message_handler(Wimp_MTaskCloseDown,
                                         &browser_closedown_handler,
                                         plugin_list);

	/* dispose of window and plugin info */
	close_child_window(plugin_list);

	/* call client specific code */
	if (plugin_list->plugin_fns->client_close)
	  plugin_list->plugin_fns->client_close(plugin_list->client_data);

	/* dispose of stuff */
	dispose_plugin_info(plugin_list);
    }
}

static void kill_old_helper(pluginclient_instance *except)
{
  pluginclient_instance *curr_inst;

  for (curr_inst=plugin_list; curr_inst; curr_inst=curr_inst->next)
  {
    if ((curr_inst->helper==TRUE) && (curr_inst != except))
    {
      dprintf(("plugclient_4", "Killing helper %p\n", curr_inst));

      pluginclient_send_closed(curr_inst, 0, NULL, 0);

      if (curr_inst->parent_task)
        err_report(event_deregister_message_handler(Wimp_MTaskCloseDown,
                                                    &browser_closedown_handler,
                                                    curr_inst));

      /* dispose of window and plugin info */
      close_child_window(curr_inst);

      /* call client specific code */
      if (curr_inst->plugin_fns->client_close)
        curr_inst->plugin_fns->client_close(curr_inst->client_data);

      /* dispose of stuff */
      dispose_plugin_info(curr_inst);
    } /* if */
  } /* for */
} /* kill_old_helper */

/* --------------------------------------------------------------------------------------------- */
static int openurl_handler(WimpMessage *message, void *handle)
{
  pluginclient_instance *plugin;
  openurl_data *data = (openurl_data *) &message->data;
  const char *url;
  char *filename = NULL;

  (void) handle;


  if (data->indirect.tag) {
    url = data->url;
  }
  else {
    url = get_ptr(data, data->indirect.url);
    filename = get_ptr(data, data->indirect.body_file);
  }

  dprintf(("plugclient_1", "Message &4AF80 arrives for URL %s\n", url));

  for (plugin = plugin_list; plugin; plugin = plugin->next) {
    /* incoming URL from the browser. eg. user clicked on a button. */
    /* call the client */
    if (plugin->plugin_fns->client_submit && plugin->plugin_fns->client_submit(plugin,
                                            plugin->client_data, url, filename))
    {
      /* acknowledge the message */
      message->hdr.your_ref = message->hdr.my_ref;
      err_fatal(wimp_send_message(Wimp_EUserMessageAcknowledge, message, message->hdr.sender, 0, NULL));
      return 1;
    }
  }

  return 0;
}

/* --------------------------------------------------------------------------------------------- */

/* Broadcast when object is opened initially */

static int plugin_open_handler(WimpMessage *message, void *handle)
{
    message_plugin_open *msg = (message_plugin_open *)message->data.bytes;
    pluginclient_instance *plugin;
    pluginclient *pluginclient_fns;
    int opening_flags;

    dprintf(("plugclient_4", "plugin_open_handler entered\n"));

    /* check type is handled by a pluginclient, and which one it is */
    if ( (pluginclient_fns = handle_file_type(msg->file_type)) == NULL)
	return 0;

    if (plugin_list) {
        dprintf(("plugclient_4", "Not starting plugin - already active\n"));
        return 0;
    }

    /* allocate block */
    if ((plugin = calloc(sizeof(struct pluginclient_instance), 1)) == NULL)
	return 0;

    plugin->plugin_fns = pluginclient_fns;

    pluginclient_increment_count();

    /* add to list */
    plugin->next = plugin_list;
    if (plugin_list)
	plugin_list->prev = plugin;
    plugin_list = plugin;


    /* save info from the open message */
    plugin->helper = msg->flags & plugin_open_HELPER ? TRUE : FALSE;
    plugin->parent_instance = msg->instance.parent;
    plugin->parent_window = (int)msg->window_handle;
    plugin->parent_box = *(BBox *)&msg->box;
    plugin->parent_task = message->hdr.sender;

    if (plugin->helper)
      kill_old_helper(plugin);  /* kills all helpers _except_ plugin */

    /* load up the file details */
    parse_parameter_file(plugin, get_ptr(msg, msg->file_name));

    err_fatal(event_register_message_handler(Wimp_MTaskCloseDown,
                                             &browser_closedown_handler,
                                             plugin));

    dprintf(("plugclient_4", "Calling client_open()\n"));

    /* call the client */
    if (plugin->plugin_fns->client_open && plugin->plugin_fns->client_open(plugin,
                                            &plugin->client_data, &opening_flags))
    {
	/* open the window - must be after client_open() */
	open_child_window(plugin, !plugin->helper);

	err_fatal(window_get_wimp_handle(0, plugin->window, &plugin->wimp_window));

	add_window_handlers(plugin->window, plugin);

	/* send acknowledgement - reuse message block */
	msg->instance.plugin = plugin;
	msg->flags = opening_flags |
	             (plugin->helper ? plugin_opening_MADE_HELPER : 0);

	message->hdr.action_code = MESSAGE_PLUGIN_OPENING;
	message->hdr.your_ref = message->hdr.my_ref;
	message->hdr.size = sizeof(message->hdr) + sizeof(message_plugin_opening);
	wimp_send_message(Wimp_EUserMessage, message, message->hdr.sender, 0, NULL);
    }

    return 1;
    NOT_USED(handle);
}

static int plugin_close_handler(WimpMessage *message, void *handle)
{
    message_plugin_close *msg = (message_plugin_close *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

    dprintf(("plugclient_1", "plugin_close_handler() plugin = %p\n",plugin));

    if (!plugin) /* workaround for browser error */
      return 1;

    cts_ui_close_dbox(plugin);

    /* acknowledge */
    pluginclient_send_closed(plugin, message->hdr.your_ref, NULL,
                             msg->flags & plugin_close_PLEASE_EXIT ? 1 : 0);

    /* stop watching browser */
    err_report(event_deregister_message_handler(Wimp_MTaskCloseDown,
                                                &browser_closedown_handler,
                                                plugin));

    /* call client specific code */
    if (plugin->plugin_fns->client_close)
      plugin->plugin_fns->client_close(plugin->client_data);

    /* dispose of window and plugin info */
    close_child_window(plugin);

    /* dispose of stuff */
    dispose_plugin_info(plugin);

    if (msg->flags & plugin_close_PLEASE_EXIT)
    {
      exit(EXIT_SUCCESS);
    } /* if */

    return 1;
    NOT_USED(handle);
}

static int plugin_reshape_handler(WimpMessage *message, void *handle)
{
    message_plugin_reshape *msg = (message_plugin_reshape *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

    dprintf(("plugclient_1", "plugin_reshape_handler(): plugin %p\n", plugin));

    /* store the new values */
    plugin->parent_window = (int)msg->window_handle;
    plugin->parent_box = *(BBox *)&msg->box;

    /* reopen the window */
    open_child_window(plugin, !plugin->helper);

    return 1;
    NOT_USED(handle);
}

static int plugin_focus_handler(WimpMessage *message, void *handle)
{
    message_plugin_focus *msg = (message_plugin_focus *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

// Think about when one of our things needs focus. Currently it doesn't. By
// rights, the browser shouldn't send this if the flag in plugin opening message
// isn't set, but...
#if 0

    err_report(wimp_set_caret_position(plugin->wimp_window, -1, 0, 0, -1, -1));

    /* acknowledge message - reusing contents */
    message->hdr.your_ref = message->hdr.my_ref;
    err_fatal(wimp_send_message(Wimp_EUserMessageAcknowledge, &message,
                                plugin->parent_task, 0, NULL));
#endif

    return 1;
    NOT_USED(handle);
    NOT_USED(plugin);
}

/* --------------------------------------------------------------------------------------------- */

static int plugin_stream_new_handler(WimpMessage *message, void *handle)
{
    message_plugin_stream_new *msg = (message_plugin_stream_new *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;
    int stype;

    dprintf(("plugclient_1", "plugin_stream_new(): flags %08x\n", msg->flags));
    /* tell client about new stream and get stream type */
    stype = msg->flags & plugin_stream_TYPE;

    if (plugin->plugin_fns->client_stream_new)
      plugin->plugin_fns->client_stream_new(plugin->client_data,
                            get_ptr(msg, msg->mime_type), &msg->stream,
                            msg->flags & plugin_stream_SEEKABLE ? 1 : 0,
                            &stype);
    msg->flags = (msg->flags &~ plugin_stream_TYPE) | (stype & plugin_stream_TYPE);

    /* reply to message with new type - reusing message */
    message->hdr.your_ref = message->hdr.my_ref;
    err_fatal(wimp_send_message(Wimp_EUserMessage, message, plugin->parent_task, -1, NULL));

    return 1;
    NOT_USED(handle);
}

static int plugin_stream_as_file_handler(WimpMessage *message, void *handle)
{
    message_plugin_stream_as_file *msg = (message_plugin_stream_as_file *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

    if (plugin->plugin_fns->client_stream_as_file)
    {
      if (!plugin->plugin_fns->client_stream_as_file(plugin,
                                                     plugin->client_data,
                                                     &msg->stream,
                                                     get_ptr(msg, msg->file_name)))
      {
        /* fatal error, so clean up */
        pluginclient_send_closed(plugin, 0, NULL, 0);

        err_report(event_deregister_message_handler(Wimp_MTaskCloseDown,
                                                    &browser_closedown_handler,
                                                    plugin));

        /* dispose of window and plugin info */
        close_child_window(plugin);

        /* call client specific code */
        if (plugin->plugin_fns->client_close)
          plugin->plugin_fns->client_close(plugin->client_data);

        /* dispose of stuff */
        dispose_plugin_info(plugin);

      } /* if */
    } /* if */

    return 1;
    NOT_USED(handle);
}

static int plugin_stream_destroy_handler(WimpMessage *message, void *handle)
{
    message_plugin_stream_destroy *msg = (message_plugin_stream_destroy *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

    dprintf(("plugclient_1", "Received message from browser to destroy stream\n"));

    if (plugin->plugin_fns->client_stream_destroy)
      plugin->plugin_fns->client_stream_destroy(plugin, plugin->client_data,
                                                &msg->stream, msg->reason);

    return 1;
    NOT_USED(handle);
}

static int plugin_action_handler(WimpMessage *message, void *handle)
{
    message_plugin_action *msg = (message_plugin_action *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

    if (plugin->plugin_fns->client_action)
      if (!plugin->plugin_fns->client_action(plugin->client_data, msg->reason))
      {
        /* fatal error, so clean up */
        pluginclient_send_closed(plugin, 0, NULL, 0);

        err_report(event_deregister_message_handler(Wimp_MTaskCloseDown,
                                                    &browser_closedown_handler,
                                                    plugin));

        /* dispose of window and plugin info */
        close_child_window(plugin);

        /* call client specific code */
        if (plugin->plugin_fns->client_close)
          plugin->plugin_fns->client_close(plugin->client_data);

        /* dispose of stuff */
        dispose_plugin_info(plugin);

      } /* if */

    return 1;
    NOT_USED(handle);
}


static int plugin_abort_handler(WimpMessage *message, void *handle)
{
    message_plugin_abort *msg = (message_plugin_abort *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

    if (plugin->plugin_fns->client_action)
      plugin->plugin_fns->client_action(plugin->client_data, plugin_busy_STOP);

    return 1;
    NOT_USED(handle);
}

/* --------------------------------------------------------------------------------------------- */

static int help_request_handler(WimpMessage *message, void *handle)
{
    WimpHelpRequestMessage *help_request = &message->data.help_request;
    pluginclient_instance *plugin = find_plugin(NULL, help_request->window_handle);

    if (plugin)
    {
	WimpMessage reply;
	WimpHelpReplyMessage *help_reply = &reply.data.help_reply;

	if (plugin->plugin_fns->client_help &&
	    plugin->plugin_fns->client_help(plugin->client_data, help_request,
	                                    help_reply))
	{
	    err_fatal(wimp_send_message(Wimp_EUserMessage, &reply,
	                                message->hdr.sender, 0, NULL));
	    return 1;
	}
    }

    return 0;
    NOT_USED(message);
    NOT_USED(handle);
}

/* --------------------------------------------------------------------------------------------- */

static void cleanup_task(void)
{
    dispose_plugin_all();
}

static void cleanup(void)
{
    pluginclient **curr_pluginclient;

    for (curr_pluginclient=&all_pluginclients[0]; *curr_pluginclient;
         curr_pluginclient++)
    {
      if ( (*curr_pluginclient)->client_shutdown )
        (*curr_pluginclient)->client_shutdown();
    } /* for */

    /* Turn on slot 2 NCMA activity */
    _swix (NCMA_MiscOp, _INR(0,1), 2, 0);

    _swix(Hourglass_Smash, 0);	/* just in case */

#ifdef DEBUGLIB
    {
    time_t tp;
    time(&tp);
    dprintf(("plugclient_1", "*** " APP_NAME " exiting at %s", ctime(&tp)));
    }
#endif
}

static int quit_handler(WimpMessage *message, void *handle)
{
    exit(EXIT_SUCCESS);
    return 1;
    NOT_USED(message);
    NOT_USED(handle);
}

static int quit_handler1(int event_code, ToolboxEvent *event, IdBlock *id_block,
                         void *handle)
{
    quit_handler(NULL, NULL);
    return 1;
    NOT_USED(event_code);
    NOT_USED(event);
    NOT_USED(id_block);
    NOT_USED(handle);
}

static int pollword_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
	(void) event_code;
	(void) event;
	(void) id_block;
	(void) handle;

	cts_sc_pollword_handler();
	return 1;
}

static int null_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    pluginclient_instance *curr_inst;

    if (n_instances == 0 &&
	cli_timeout != -1 &&
	clock()/CLK_TCK >= last_checkpoint + cli_timeout)
    {
        dprintf(("plugclient_4", "Exiting due to inactivity\n"));
	exit(EXIT_SUCCESS);
    }

    for (curr_inst=plugin_list; curr_inst; curr_inst=curr_inst->next)
    {
      if ( curr_inst->plugin_fns->client_idle )
        curr_inst->plugin_fns->client_idle(curr_inst->client_data);
    } /* for */

    return 0;
    NOT_USED(event_code);
    NOT_USED(event);
    NOT_USED(id_block);
    NOT_USED(handle);
}

static int dataopen_handler(WimpMessage *message, void *handle)
{
  WimpDataOpen *msg = (WimpDataOpen *) &message->data;
  WimpMessage reply;

  if (immediate_file_play(&msg->path_name[0]))
  {
    memcpy(&reply, message, sizeof(reply));
    reply.hdr.action_code = Wimp_MDataLoadAck;
    reply.hdr.your_ref = reply.hdr.my_ref;
    err_fatal(wimp_send_message(Wimp_EUserMessage, &reply,
                                reply.hdr.sender, 0, NULL));
    return 1;
  } /* if */
  return 0;

  NOT_USED(handle);
} /* dataopen_handler */

/* --------------------------------------------------------------------------------------------- */

/* Start playing file automatically when we start - I thought about pretending
 * to be a browser and do a plugin_open and plugin_stream things, but it was
 * far too complex in comparison */

static int immediate_file_play(char *file_name)
{
  pluginclient *pluginclient_fns;
  pluginclient_instance *plugin;
  int file_type;

  /* first get file type so we know which client to use */
  file_type = get_file_type(file_name);

  if ( (pluginclient_fns = handle_file_type(file_type)) == NULL)
     return 0; /* not handled */

  dprintf(("plugclient_4", "immediate_file_play(): file type = &%X\n", file_type));

  /* create a plugin so we can close down later in the same way */
  if ((plugin = calloc(sizeof(struct pluginclient_instance), 1)) == NULL)
    return 0;

  plugin->plugin_fns = pluginclient_fns;

  pluginclient_increment_count();

  /* add to list */
  plugin->next = plugin_list;
  if (plugin_list)
    plugin_list->prev = plugin;
  plugin_list = plugin;

  err_fatal(toolbox_create_object(0, OUR_OBJECT, &plugin->window));

  add_window_handlers(plugin->window, plugin);

  kill_old_helper(plugin);  /* kills all helpers _except_ plugin */

  plugin->helper=TRUE;

  plugin->client_data = plugin->plugin_fns->client_play_file(file_name,
                                                             file_type,
                                                             plugin->window,
                                                             plugin);
  if (!plugin->client_data)
  {
    /* dispose of window and plugin info */
    close_child_window(plugin);

    /* call client specific code */
    if (plugin->plugin_fns->client_close)
      plugin->plugin_fns->client_close(plugin->client_data);

    /* dispose of stuff */
    dispose_plugin_info(plugin);
  } /* if */

  return 1;
} /* immediate_file_play */


static void process_args(int argc, char *argv[])
{
    int i; /* boring counter var */

    for (i = 1; i < argc; i++)
    {
        char *s = argv[i];

        dprintf(("plugclient_1", "arg(%d)='%s'\n", i, s));

	if (*s == '-')
	{
	    switch (tolower(*(s+1)))
	    {
    	      case 'd':	    /* output post mortem on abort? */
    	      	  sig_dopostmortem = TRUE;
    	      	  break;

	      case 'f':      /* file to play initially */
	          if (i+1 < argc)
	            cli_filename = strdup(argv[++i]);
	          break;
	      case 't':      /* quit app after <next arg> seconds after last file
	                      * finished if no new file started */
		  if (i+1 < argc)
		    cli_timeout = atoi(argv[++i]);
		  break;
              default:
                  break;
	    } /* switch */
	} /* if */
    } /* for */
    dprintf(("plugclient_4", "process_args result: file=\"%s\", timeout=%d\n",
           strsafe(cli_filename), cli_timeout));
} /* process_args */

static void initialise(int argc, char *argv[])
{
    int current_wimp, task;
    void *sprite;
    pluginclient **curr_pluginclient;

    /* usual library things */
    setlocale(LC_ALL, "");
    setbuf(stderr, NULL);
    atexit(cleanup);

    /* Turn off slot 2 NCMA activity */
    _swix (NCMA_MiscOp, _INR(0,1), 2, 1);

    /* decode args */
    process_args(argc,argv);

    /* initialise toolbox first to get messages file */
    /* Wimp 380 needed for embedded windows */
    if (toolbox_initialise(0, 380, &Wimp_MessageList[0], &ToolBox_EventList[0], APP_DIR,
			      &message_block, &event_id_block,
			      &current_wimp, &task, &sprite) != NULL)
    {
    	/* Wimp 310 needed for other facilities */
 	err_fatal(toolbox_initialise(0, 310, &Wimp_MessageList[0], ToolBox_EventList, APP_DIR,
				     &message_block, &event_id_block,
				     &current_wimp, &task, &sprite));
    }

    /* cleanup that needs task running */
    atexit(cleanup_task);

    /* enabled msgs calls */
    utils_init(&message_block);

    /* Initialise the state machine */
    err_fatal(cts_statetable_init ());

    /* after main and utils init */
    signal_setup();

    /* initiliase event library */
    err_fatal(event_initialise(&event_id_block));

    patch_all_pluginclients();

    /* call clients' init after wimp/toolbox init */
    for (curr_pluginclient=&all_pluginclients[0]; *curr_pluginclient;
         curr_pluginclient++)
    {
      if ( (*curr_pluginclient)->client_init )
        (*curr_pluginclient)->client_init(argc, argv);
    } /* for */

    /* attach quit handlers */
    err_fatal(event_register_message_handler(Wimp_MQuit, quit_handler, NULL));
    err_fatal(event_register_toolbox_handler(-1, Quit_Quit, quit_handler1, NULL));

    /* other general handlers */
    err_fatal(event_register_wimp_handler(0, Wimp_ENull, null_handler, NULL));
    err_fatal(event_register_wimp_handler(0, Wimp_EPollWordNonZero, pollword_handler, NULL));
    err_fatal(event_register_message_handler(Wimp_MDataOpen, dataopen_handler,
                                             NULL));

    /* plugin protocol message handlers */
    err_fatal(event_register_message_handler(MESSAGE_PLUGIN_OPEN, plugin_open_handler, NULL));
    err_fatal(event_register_message_handler(MESSAGE_PLUGIN_CLOSE, plugin_close_handler, NULL));
    err_fatal(event_register_message_handler(MESSAGE_PLUGIN_RESHAPE, plugin_reshape_handler, NULL));
    err_fatal(event_register_message_handler(MESSAGE_PLUGIN_FOCUS, plugin_focus_handler, NULL));
    err_fatal(event_register_message_handler(MESSAGE_PLUGIN_STREAM_NEW, plugin_stream_new_handler, NULL));
    err_fatal(event_register_message_handler(MESSAGE_PLUGIN_STREAM_AS_FILE, plugin_stream_as_file_handler, NULL));
    err_fatal(event_register_message_handler(MESSAGE_PLUGIN_STREAM_DESTROY, plugin_stream_destroy_handler, NULL));
    err_fatal(event_register_message_handler(MESSAGE_PLUGIN_ACTION, plugin_action_handler, NULL));
    err_fatal(event_register_message_handler(MESSAGE_PLUGIN_ABORT, plugin_abort_handler, NULL));

    /* OpenURL handler for handling incoming messages from the browser */
    err_fatal(event_register_message_handler(MESSAGE_BROWSER_OPENURL, openurl_handler, NULL));

    err_fatal(event_register_message_handler(Wimp_MHelpRequest, help_request_handler, NULL));

    /* initialise application components */
}

int main(int argc, char *argv[])
{
    void *pollword = 0;

#ifdef MemCheck_MEMCHECK
    MemCheck_Init();
    MemCheck_RegisterArgs(argc, argv);
    MemCheck_InterceptSCLStringFunctions();
    MemCheck_SetStoreMallocFunctions(1);
    MemCheck_RedirectToFilename ("RAM::0.$.cts_memch");
    atexit (MemCheck_OutputBlocksInfo);
#endif
    debug_initialise("CTSPlugin", "<CTSPlugin$Dir>.^.Errors", "");
    debug_atexit();
    debug_set_device(DEBUGIT_OUTPUT);
    /*debug_set_stamp_debug (TRUE);*/
    dprintf(("", "*** New " APP_NAME " " VERSION_STRING " started\n"));

#ifdef TRACE_ENABLED
    debug_initialise_trace (DEBUGIT_OUTPUT, "");
#endif

    atexit(log_dispose);
    atexit(cts_sc_atexit);
    initialise(argc, argv);

    err_fatal(event_set_mask(event_mask));
    err_fatal(cts_sc_init_lowlevel(&pollword));

    if (cli_filename && cli_filename[0] != '\0')
    {
      immediate_file_play(cli_filename);
    } /* if */

    dprintf(("plugclient_4", "Entering poll loop\n"));
    while (TRUE)
    {
	int event_code;
	WimpPollBlock poll_block;

//      event_poll_idle(&event_code, &poll_block, POLL_TIME, NULL);
        event_poll(&event_code, &poll_block, pollword);

    	if (event_code != 0) {
    	    dprintf(("plugclient_4", "Poll: %d\n", event_code));
    	    if (event_code == Wimp_EUserMessage ||
                    event_code == Wimp_EUserMessageRecorded ||
                    event_code == Wimp_EUserMessageAcknowledge) {
                            dprintf(("plugclient_4", "(Message %08x)\n", poll_block.user_message.hdr.action_code));
                    }
        }

    	/* garbage collect rma strings */
        switch (event_code)
        {
            case Wimp_EUserMessage:
            case Wimp_EUserMessageRecorded:
            	/* if message is replied to */
            	free_rma_strings(poll_block.user_message.hdr.your_ref, NULL);
            	break;
            case Wimp_EUserMessageAcknowledge:
            	/* if message bounces */
            	free_rma_strings(poll_block.user_message.hdr.my_ref, NULL);
            	break;
        }
    }

    return EXIT_SUCCESS;
}

/* eof c.plugclient */
