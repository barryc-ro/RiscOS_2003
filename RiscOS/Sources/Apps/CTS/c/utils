/* > utils.c
 *
 */

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "swis.h"
#include "wimp.h"
#include "wimplib.h"
#include "kernel.h"
#include "version.h"

#include "utils.h"

#include "socklib.h"
#include "inetlib.h"

/* --------------------------------------------------------------------------------------------- */

static void *message_block = NULL;

void utils_init(void *message_ptr)
{
    message_block = message_ptr;
}

/* --------------------------------------------------------------------------------------------- */

static int log_s = -1;

void log_init(char *remotelog)
{
        char *colon;
        if (log_s != -1) {
                return;
        }
        if (remotelog == NULL) {
                return;
        }
        colon = strchr(remotelog, ':');
        if (colon == NULL) {
        	return;
        }
        else {
                *colon++ = '\0';
        }
        log_s = socket(PF_INET, SOCK_STREAM, 0);
        dprintf(("", "log socket creation => %d; host is %s; port is %s\n", log_s, remotelog, colon));
        if (log_s != -1) {
                struct sockaddr_in sin;

                (void) memset(&sin, 0, sizeof(sin));
                sin.sin_family = AF_INET;
                sin.sin_len = sizeof(sin);
                sin.sin_port = (short) strtoul(colon, NULL, 10);
                if (sin.sin_port == 0) {
                        log_dispose();
                }
                else if (!inet_aton(remotelog, &sin.sin_addr)) {
                        dprintf(("", "Host name is not OK\n"));
                        log_dispose();
                }
                else if (connect(log_s, (struct sockaddr *) &sin, sizeof(sin)) < 0) {
                        dprintf(("", "connect failed (%d) %s\n", errno, _inet_err()));
                        log_dispose();
                }
        }
}

void log_dispose(void)
{
        if (log_s != -1) {
                dprintf(("", "Closing log socket %d\n", log_s));
                (void) socketclose(log_s);
                log_s = -1;
        }
}

void log_send(const char *fmt, ...)
{
	if (log_s != -1) {
    		static char buf[BUFSIZ];
    		char *ebuf;
    		va_list ap;

    		ebuf = buf + sprintf(buf, "%d:", clock());
    		va_start(ap, fmt);
    		ebuf += vsprintf(ebuf, fmt, ap);
    		(void) send(log_s, buf, ebuf - buf, 0);
    		va_end(ap);
	}
}

/* --------------------------------------------------------------------------------------------- */

#ifdef DEBUGLIB
static void add_file_and_line(_kernel_oserror *e, const char *file, int line)
{
    int len = strlen(e->errmess);
    sprintf(e->errmess + len, " (%s: %d)", file, line);
}
#endif

#ifdef DEBUGLIB
void err_fatal_(_kernel_oserror *e, const char *file, int line)
#else
void err_fatal(_kernel_oserror *e)
#endif
{
    if (e)
    {
	_kernel_oserror ee = *e;
#ifdef DEBUGLIB
	add_file_and_line(&ee, file, line);
	dprintf(("", "error 0x%x %s\n", ee.errnum, ee.errmess));
#endif
	wimp_report_error(&ee, Wimp_ReportError_OK, APP_NAME " " VERSION_STRING);
	exit(EXIT_FAILURE);
    }
}

#ifdef DEBUGLIB
_kernel_oserror *err_report_(_kernel_oserror *e, const char *file, int line)
#else
_kernel_oserror *err_report(_kernel_oserror *e)
#endif
{
    if (e)
    {
	_kernel_oserror ee = *e;
#ifdef DEBUGLIB
	add_file_and_line(&ee, file, line);
	dprintf(("", "error 0x%x %s\n", ee.errnum, ee.errmess));
#endif
	wimp_report_error(&ee, Wimp_ReportError_OK, APP_NAME " " VERSION_STRING);
    }
    return e;
}

#ifdef DEBUGLIB
void msg_report_(char *s, const char *file, int line)
#else
void msg_report(char *s)
#endif
{
    _kernel_oserror e;

    e.errnum = 0;
    strncpy(e.errmess, s, sizeof(e.errmess));

#ifdef DEBUGLIB
    add_file_and_line(&e, file, line);
    dprintf(("msg", "msg: %s\n", e.errmess));
#endif
    wimp_report_error(&e, Wimp_ReportError_OK, APP_NAME " " VERSION_STRING);
}

/* --------------------------------------------------------------------------------------------- */

char *utils_msgs_lookup(char *tag)
{
    char *result;
    if (message_block &&
	_swix(MessageTrans_Lookup, _INR(0,7) | _OUT(2),
	      message_block, tag, 0, 0, 0, 0, 0, 0,
	      &result) == NULL)
    {
	return result;
    }
    return tag;
}

int strcasecomp (const char *a, const char *b)
{
    const char *p =a;
    const char *q =b;
    for(p=a, q=b; *p && *q; p++, q++) {
	int diff = tolower(*p) - tolower(*q);
	if (diff) return diff;
    }
    if (*p) return 1;	/* p was longer than q */
    if (*q) return -1;	/* p was shorter than q */
    return 0;		/* Exact match */
}

char *strdup(const char *s)
{
    char *ss;

    if (s == NULL)
	return NULL;

    ss = malloc(strlen(s)+1);
    if (ss)
	strcpy(ss, s);

    return ss;
}

const char *strsafe(const char *s)
{
    return s ? s : "<null>";
}

void *rma_alloc(int size)
{
    char *ptr;
    if (_swix(OS_Module, _IN(0)|_IN(3)|_OUT(2),
	      6, size,
	      &ptr) != NULL)
	return NULL;

    return ptr;
}

void rma_free(void *ptr)
{
    _swix(OS_Module, _IN(0)|_IN(2), 7, ptr);
}

/* --------------------------------------------------------------------------------------------- */

static int get_file_attrib(const char *file_name, int attrib)
{
  _kernel_swi_regs regs;

  regs.r[0] = 20;
  regs.r[1] = (int) file_name;

  err_fatal(_kernel_swi(OS_File, &regs, &regs));

  return regs.r[attrib];
}

int get_file_type(const char *file_name)
{
        return get_file_attrib(file_name, 6);
} /* get_file_type */

int get_file_length(const char *file_name)
{
  return get_file_attrib(file_name, 4);
} /* get_file_type */

_kernel_oserror *load_file_at(const char *file_name, void *address)
{
        err_fatal(_swix(OS_File, _INR(0,3), 255, file_name, address, 0));
        return NULL;
}

void set_system_variable(char *var_name, char *value)
{
  _kernel_swi_regs regs;

  regs.r[0] = (int) var_name;
  regs.r[1] = (int) value;
  regs.r[2] = strlen(value);
  regs.r[3] = 0;
  regs.r[4] = 0; /* string type */
  _kernel_swi(OS_SetVarVal, &regs, &regs);

} /* set_system_variable */

/* eof utils.c */
