/*
 *  CTS (statetable.c)
 *
 * Copyright (C) Element 14 Ltd. 1999
 *
 */

#include <stdio.h>
#include <string.h>
#include "ctstypes.h"
#include "ctsbrowser.h"
#include "ctsintern.h"
#include "ctsui.h"
#include "statetable.h"

#include "DebugLib/DebugLib.h"


static cts_statetable_result_errorclose cts_statetable_errorclose_SM (cts_statetable_action action_code,
                                                            cts_browser_message *bm,
                                                            cts_server_message *sm)
{
  cts_statetable_result_errorclose rc;

  static cts_statetable_states_errorclose state = S_ErrorClose_Idle;
  static cts_server_message *errorclose_message = NULL;

  if (action_code == AC_Start)
  {
    /* send close command */
    /* Display processing dialogue */
    errorclose_message = sm;
    state = S_ErrorClose_Closing;
    return RC_ErrorClose_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_ErrorClose_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action, but handle it anyway */
          rc = RC_ErrorClose_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_ErrorClose_Error;
      }
      break;

    /* STATE - Working on "Close" command */
    case S_ErrorClose_Closing:
      switch (action_code)
      {
        case AC_BrowserMessage:
          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Close processing window */
            /* Open cancel confirm dbox */
            rc = RC_ErrorClose_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_ErrorClose_Error;
            state = S_ErrorClose_Idle;
          }
          /* free "bm" */
          /* free "errorclose_message" */
          break;

        case AC_Continue:
          /* if (close complete)
          { */
            /* close processing window */
            /* send result of command (with attached data from "errorclose_message" */
            /* free "errorclose_message" */
            state = S_ErrorClose_Idle;
            rc = RC_ErrorClose_Finished;
       /* }
          else
          {
            Wait around
            rc = RC_ErrorClose_Pending;
          }*/
          break;

        case AC_Cancel:
          /* free "errorclose_message" */
          state = S_ErrorClose_Idle;
          rc = RC_ErrorClose_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_ErrorClose_Idle;
          rc = RC_ErrorClose_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_ErrorClose_Idle;
      rc = RC_ErrorClose_Error;
      break;
  }

  return rc;
}


static cts_statetable_result_verify cts_statetable_verify_SM (cts_statetable_action action_code,
                                                              cts_browser_message *bm,
                                                              cts_server_message *sm)
{
  cts_statetable_result_verify rc;

  static cts_statetable_states_verify state = S_Verify_Idle;
  static cts_server_message *verify_message = NULL;

  if (action_code == AC_Start)
  {
    /* Display password dbox */
    verify_message = sm;
    state = S_Verify_WaitingOKCancel;
    return RC_Verify_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_Verify_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action but handle it anyway */
          rc = RC_Verify_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Verify_Error;
      }
      break;

    /* STATE - Waiting for password window OK or Cancel click */
    case S_Verify_WaitingOKCancel:
      switch (action_code)
      {
        case AC_BrowserMessage:
          if (strcmp (bm->command, "passworddbox_ok") == 0)
          {
            /* Close password dbox */
            /* start send of verify command */
            state = S_Verify_SendingVerify;
            rc = RC_Verify_Pending;
          }
          else if (strcmp (bm->command, "passworddbox_cancel") == 0)
          {
            /* Close password dbox */
            /* free "verify_message" */
            rc = RC_Verify_Terminated;
            state = S_Verify_Idle;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Verify_Error;
            state = S_Verify_Idle;
            /* free "verify_message" */
          }
          /* free "bm" */
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Verify_Pending;
          break;

        case AC_Cancel:
          /* free "verify_message" */
          state = S_Verify_Idle;
          rc = RC_Verify_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Verify_Idle;
          rc = RC_Verify_Error;
      }
      break;

    /* STATE - Waiting for completion of smart card command */
    case S_Verify_SendingVerify:
      switch (action_code)
      {
#if 0
dunno if we should have a processing dbox here
        case AC_BrowserMessage:
          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Close processing window */
            /* Open cancel confirm dbox */
            rc = RC_APDU_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_APDU_Error;
            state = S_APDU_Idle;
          }
          /* free "bm" */
          /* free "apdu_message" */
          break;
#endif
        case AC_Continue:
          /* poll for completion of command send */
          /* if finished
          { */
            state = S_Verify_ReceiveResponse;
            rc = RC_Verify_Pending;
       /* }
          else
          {
            still sending
            rc = RC_Verify_Pending;
          }*/
          break;

        case AC_Cancel:
          /* free "verify_message" */
          state = S_Verify_Idle;
          rc = RC_Verify_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Verify_Idle;
          rc = RC_Verify_Error;
      }
      break;

    /* STATE - Waiting for response to smart card command */
    case S_Verify_ReceiveResponse:
      switch (action_code)
      {
#if 0
dunno if we should have a processing dbox here
        case AC_BrowserMessage:
          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Close processing window */
            /* Open cancel confirm dbox */
            rc = RC_Verify_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Verify_Error;
            state = S_Verify_Idle;
          }
          /* free "bm" */
          /* free "verify_message" */
          break;
#endif
        case AC_Continue:
          /* poll for response completion */
          /* if finished
          {
            if (key lock, or command error)
            {
              close processing window (if there is one)
              display error message 23,24,30
              state = S_Verify_SpecialErrorDialogue;
              rc =  RC_Verify_Pending;
            }
            else if (communication error)
            {
              close processing window (if there is one)
              display error message 03
              free "verify_message"
              rc =  RC_Verify_ErrorDialogue;
              state = S_Verify_Idle;
            }
            else if (key comparison failed)
            {
              display error message 25;
              state = S_Verify_RetryPasswordDialogue;
              rc =  RC_Verify_Pending;
            }
            else
            {
              finished
              send response (includes verify result)
              close processing window (if there is one)
              free "verify_message"
              state = S_Verify_Idle;
              rc = RC_Verify_Finished;
            }
          }
          else
          {  */
            rc = RC_Verify_Pending;
       /* }*/
          break;

      default:
        /* Any other action in this state is illegal */
        state = S_Verify_Idle;
        rc = RC_Verify_Error;
      }
      break;

    /* STATE - Waiting for special error dialogue box to complete */
    case S_Verify_SpecialErrorDialogue:
      switch (action_code)
      {
        case AC_BrowserMessage:
          if (strcmp (bm->command, "verifyspecialdbox_ok") == 0)
          {
            /* Close dbox */
            /* send response (includes verify result) */
            state = S_Verify_Idle;
            rc = RC_Verify_Finished;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Verify_Error;
            state = S_Verify_Idle;
          }
          /* free "bm" */
          /* free "verify_message" */
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Verify_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Verify_Idle;
          rc = RC_Verify_Error;
      }
      break;

    /* STATE - Waiting for retry password dialogue box to complete */
    case S_Verify_RetryPasswordDialogue:
      switch (action_code)
      {
        case AC_BrowserMessage:
          if (strcmp (bm->command, "retrypassworddbox_ok") == 0)
          {
            /* Close dbox */
            /* reopen password dbox */
            state = S_Verify_WaitingOKCancel;
            rc = RC_Verify_Pending;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Verify_Error;
            state = S_Verify_Idle;
            /* free "verify_message" */
          }
          /* free "bm" */
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Verify_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Verify_Idle;
          rc = RC_Verify_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_Verify_Idle;
      rc = RC_Verify_Error;
      break;
  }

  return rc;
}


static cts_statetable_result_apdu cts_statetable_apdu_SM (cts_statetable_action action_code,
                                                          cts_browser_message *bm,
                                                          cts_server_message *sm)
{
  cts_statetable_result_apdu rc;

  static cts_statetable_states_apdu state = S_APDU_Idle;
  static cts_server_message *apdu_message = NULL;

  if (action_code == AC_Start)
  {
    /* Display processing dialogue */
    /* start send of first command */
    apdu_message = sm;
    state = S_APDU_SendingCommand;
    return RC_APDU_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_APDU_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action but handle it anyway */
          rc = RC_APDU_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_APDU_Error;
      }
      break;

    /* STATE - Waiting for completion of smart card command */
    case S_APDU_SendingCommand:
      switch (action_code)
      {
        case AC_BrowserMessage:
          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Close processing window */
            /* Open cancel confirm dbox */
            rc = RC_APDU_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_APDU_Error;
            state = S_APDU_Idle;
          }
          /* free "bm" */
          /* free "apdu_message" */
          break;

        case AC_Continue:
          /* poll for completion of command send */
          /* if finished
          { */
            state = S_APDU_ReceiveResponse;
            rc = RC_APDU_Pending;
       /* }
          else
          {
            still sending
            rc = RC_APDU_Pending;
          }*/
          break;

        case AC_Cancel:
          /* free "apdu_message" */
          state = S_APDU_Idle;
          rc = RC_APDU_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_APDU_Idle;
          rc = RC_APDU_Error;
      }
      break;

    /* STATE - Waiting for response to smart card command */
    case S_APDU_ReceiveResponse:
      switch (action_code)
      {
        case AC_BrowserMessage:
          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Close processing window */
            /* Open cancel confirm dbox */
            rc = RC_APDU_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_APDU_Error;
            state = S_APDU_Idle;
          }
          /* free "bm" */
          /* free "apdu_message" */
          break;

        case AC_Continue:
          /* poll for response completion */
          /* if finished
          {
            if (error)
            {
              close processing window
              display error message 03
              free "apdu_message"
              rc =  RC_APDU_ErrorDialogue;
              state = S_APDU_Idle;
            }
            else
            {
              need to make up list of responses for each command
              if (more commands)
              {
                start send of next command
                state = S_APDU_SendingCommand;
                rc = RC_APDU_Pending;
              }
              else
              {
                finished
                send response (includes close for APDUT case)
                close processing window
                free "apdu_message"
                state = S_APDU_Idle;
                rc = RC_APDU_Finished;
              }
            }
          }
          else
          {  */
            rc = RC_APDU_Pending;
       /* }*/
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_APDU_Idle;
          rc = RC_APDU_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_APDU_Idle;
      rc = RC_APDU_Error;
      break;
  }

  return rc;
}


static cts_statetable_result_text cts_statetable_text_SM (cts_statetable_action action_code,
                                                          cts_browser_message *bm,
                                                          cts_server_message *sm)
{
  cts_statetable_result_text rc;

  static cts_statetable_states_text state = S_Text_Idle;
  static cts_server_message *text_message = NULL;

  if (action_code == AC_Start)
  {
    /* Display processing dialogue */
    text_message = sm;
    state = S_Text_Working;
    return RC_Text_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_Text_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action, but handle it anyway */
          rc = RC_Text_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Text_Error;
      }
      break;

    /* STATE - Working on "Text" command */
    case S_Text_Working:
      switch (action_code)
      {
        case AC_BrowserMessage:
          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Close processing window */
            /* Open cancel confirm dbox */
            rc = RC_Text_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Text_Error;
            state = S_Text_Idle;
          }
          /* free "bm" */
          /* free "text_message" */
          break;

        case AC_Continue:
          /* close processing window */
          /* send result of command */
          /* free "text_message" */
          state = S_Text_Idle;
          rc = RC_Text_Finished;

        case AC_Cancel:
          /* free "text_message" */
          state = S_Text_Idle;
          rc = RC_Text_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Text_Idle;
          rc = RC_Text_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* error */
      state = S_Text_Idle;
      rc = RC_Text_Error;
      break;
  }

  return rc;
}


static cts_statetable_result_open cts_statetable_open_SM (cts_statetable_action action_code,
                                                          cts_browser_message *bm,
                                                          cts_server_message *sm)
{
  cts_statetable_result_open rc;

  static cts_statetable_states_open state = S_Open_Idle;

  if (action_code == AC_Start)
  {
    state = S_Open_Idle;
    return RC_Open_Pending;
  }

  switch (state)
  {
    /* STATE - Card open, but idle */
    case S_Open_Idle:
      switch (action_code)
      {
        /* It's a server message ... */
        case AC_ServerMessage:
          switch (sm->command)
          {
            /* "Text" command */
            case cmd_TEXT:
              cts_statetable_text_SM (AC_Start, NULL, sm);
              state = S_Open_Text;
              rc = RC_Open_Pending;
              break;

            /* "APDU" and "APDUT" commands */
            case cmd_ADPUT:
            case cmd_APDU:
              cts_statetable_apdu_SM (AC_Start, NULL, sm);
              state = S_Open_APDU;
              rc = RC_Open_Pending;
              break;

            /* "Verify" command */
            case cmd_VERIFY:
              cts_statetable_verify_SM (AC_Start, NULL, sm);
              state = S_Open_Verify;
              rc = RC_Open_Pending;
              break;

            /* "Error" command or "Close" command */
            case cmd_ERR:
            case cmd_CLOSE:
              cts_statetable_errorclose_SM (AC_Start, NULL, sm);
              state = S_Open_ErrorClose;
              rc = RC_Open_Pending;
              break;

            case cmd_CHANGE:
            case cmd_BASIC:
              /* do useful stuff */
              rc = RC_Open_Pending;
              break;

            default:
              /* Any other server message in this state is illegal */
              /* free "sm" */
              rc = RC_Open_Error;
              state = S_Open_Idle;
          }
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Open_Pending;
          break;

        case AC_Cancel:
          rc = RC_Open_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Open_Error;
          state = S_Open_Idle;
      }
      break;

    /* STATE - We're executing a "Text" command */
    case S_Open_Text:
    {
      cts_statetable_result_text result;
      result = cts_statetable_text_SM (action_code, bm, sm);
      switch (result)
      {
        case RC_Text_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Pending;
          break;

        case RC_Text_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_Text_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_Text_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_Text_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing an "APDU" command */
    case S_Open_APDU:
    {
      cts_statetable_result_apdu result;
      result = cts_statetable_apdu_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_APDU_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Pending;
          break;

        case RC_APDU_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_APDU_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_APDU_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_APDU_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing a "Verify" command */
    case S_Open_Verify:
    {
      cts_statetable_result_verify result;
      result = cts_statetable_verify_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_Verify_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Pending;
          break;

        case RC_Verify_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_Verify_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_Verify_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_Verify_Terminated:
          state = S_Open_Idle;
          rc = RC_Open_Terminated;
          break;

        case RC_Verify_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing a "Close" command or an "Error" command */
    case S_Open_ErrorClose:
    {
      cts_statetable_result_errorclose result;
      result = cts_statetable_errorclose_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_ErrorClose_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Closed;
          break;

        case RC_ErrorClose_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_ErrorClose_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_ErrorClose_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_ErrorClose_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* INVALID STATE */
    default:
      /* Error */
      state = S_Open_Idle;
      rc = RC_Open_Error;
  }

  return rc;
}


static cts_statetable_result_started cts_statetable_started_SM (cts_statetable_action action_code,
                                                                cts_browser_message *bm,
                                                                cts_server_message *sm)
{
  cts_statetable_result_started rc;

  static cts_statetable_states_started state = S_Started_Idle;
  static cts_server_message* open_message = NULL;

  if (action_code == AC_Start)
  {
    state = S_Started_Idle;
    return RC_Started_Pending;
  }

  switch (state)
  {
    /* STATE - Plugin started, but idle */
    case S_Started_Idle:
      switch (action_code)
      {
        /* It's a server message ... */
        case AC_ServerMessage:
          switch (sm->command)
          {
            /* Open command */
            case cmd_OPEN:
              /* Display processing dialogue */
              open_message = sm;
              state = S_Started_OpeningCard;
              rc = RC_Started_Pending;
              break;

            /* Error command */
            case cmd_ERR:
              /* display error webpage */
              /* free (sm) */
              state = S_Started_Idle;
              rc = RC_Started_Stopped;
              break;

            default:
              /* Any other server message in this state is illegal */
              /* free (sm) */
              state = S_Started_Idle;
              rc = RC_Started_Error;
          }
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Started_Pending;
          break;

        case AC_Cancel:
          rc = RC_Started_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Started_Idle;
          rc = RC_Started_Error;
      }
      break;

    /* STATE - Opening card */
    case S_Started_OpeningCard:
      switch (action_code)
      {
        /* It's a browser message ... */
        case AC_BrowserMessage:
          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Close processing window */
            /* Open cancel confirm dbox */
            rc = RC_Started_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Started_Error;
            state = S_Started_Idle;
          }
          /* free "bm" */
          /* free "open_message" */
          break;

        case AC_Continue:
          /* Check card status, and send S block if
             necessary, blocking in this state */
          /* If error
          {
            display error dbox 03
            state = S_Started_Idle;
            rc = RC_Started_ErrorDialogue;
          }
          else
          {*/
            /* removed processing window */
            /* Send result */
            state = S_Started_Open;
            rc = RC_Started_Pending;
       /* }*/
          /* free "open_message" */
          break;

        case AC_Cancel:
          state = S_Started_Idle;
          rc = RC_Started_Cancelled;
          /* free "open_message" */
          break;

        default:
          /* Any other action in this state is illegal */
          /* free "open_message" */
          rc = RC_Started_Error;
          state = S_Started_Idle;
      }
      break;

    /* STATE - Smart card open */
    case S_Started_Open:
    {
      cts_statetable_result_open result;
      result = cts_statetable_open_SM (action_code, bm, sm);
      switch (result)
      {
        /* The close command and been executed in the open SM,
           we've been closed */
        case RC_Open_Closed:
          state = S_Started_Idle;
          rc = RC_Started_Pending;
          break;

        /* There's been an error in the open SM, and a erro dbox
           has been opened */
        case RC_Open_ErrorDialogue:
          state = S_Started_Idle;
          rc = RC_Started_ErrorDialogue;
          break;

        /* Open SM is working, continue in this state */
        case RC_Open_Pending:
          /* Continue */
          rc = RC_Started_Pending;
          break;

        /* The user's cancelled an operation in the open SM */
        case RC_Open_Cancelled:
          state = S_Started_Idle;
          rc = RC_Started_Cancelled;
          break;

        /* The system has been "terminated", should return to idle asap */
        case RC_Open_Terminated:
          state = S_Started_Idle;
          rc = RC_Started_Stopped;
          break;

        /* Unrecoverable error in Open SM, or invalid return code */
        case RC_Open_Error:
        default:
          /* Error */
          rc = RC_Started_Error;
          state = S_Started_Idle;
      }
      break;
    }

    /* INVALID STATE */
    default:
      /* Error */
      rc = RC_Started_Error;
      state = S_Started_Idle;
  }

  return rc;
}


static cts_statetable_result_base cts_statetable_base_SM (cts_statetable_action action_code,
                                                          cts_browser_message *bm,
                                                          cts_server_message *sm)
{
  cts_statetable_result_base rc;

  static cts_statetable_states_base state = S_Base_Idle;
  static cts_statetable_states_base cancel_state;
  static cts_browser_message* start_message = NULL;

  switch (state)
  {
    /* STATE - Plugin idle */
    case S_Base_Idle:
      switch (action_code)
      {
        /* It's a browser message ... */
        case AC_BrowserMessage:
          if (strcmp (bm->command, "start") == 0)
          {
            /* Start command */
            /* display now processing window */
            start_message = bm;
            state = S_Base_Starting;
            rc = RC_Base_Pending;
          }
          else
          {
            /* Any other browser message is illegal in this state */
            rc = RC_Base_Error;
          }
        break;

        case AC_Continue:
        case AC_Start:
          /* do nothing */
          rc = RC_Base_Pending;
          break;

        default:
          /* Any other action is illegal in this state */
          rc = RC_Base_Error;
      }
      break;

    /* STATE - Starting state machine */
    case S_Base_Starting:
      switch (action_code)
      {
        /* It's a server message ... */
        case AC_ServerMessage:
          switch (sm->command)
          {
            /* Error command */
            case cmd_ERR:
              /* Display error dialogue */
              state = S_Base_ErrorDialogue;
              rc = RC_Base_Pending;
              break;

            /* Other command */
            default:
              /* Any other server message is illegal in this state */
              rc = RC_Base_Error;
              state = S_Base_Idle;
          }
          break;

        /* It's a browser message .. */
        case AC_BrowserMessage:
          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Close processing window */
            /* Open cancel confirm dbox */
            cancel_state = state;
            state = S_Base_CancelDialogue;
            rc = RC_Base_Pending;
          }
          else
          {
            /* Any other browser command in this state is illegal */
            rc = RC_Base_Error;
            state = S_Base_Idle;
          }
          break;

        case AC_Continue:
          /* check for &s ..
          if (&s in user data)
          {
            display error dbox 03
            rc = RC_Base_Pending;
            state = S_Base_ErrorDialogue;
          }
          else
          { */
            /* send start result ... */
            /* Close processing window */
            /* free "start_message" */
            cts_statetable_started_SM (AC_Start, NULL, NULL);
            state = S_Base_Started;
            rc = RC_Base_Pending;
       /* }*/
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Base_Error;
          state = S_Base_Idle;
      }
      break;

    /* STATE - State machine started */
    case S_Base_Started:
    {
      cts_statetable_result_started result;

      result = cts_statetable_started_SM (action_code, bm, sm);
      switch (result)
      {
        /* Started SM has completed, bringing the plugin back to idle */
        case RC_Started_Stopped:
          state = S_Base_Idle;
          rc = RC_Base_Pending;
          break;

        /* Started SM has opened an error dialogue, wait for it to close...*/
        case RC_Started_ErrorDialogue:
          state = S_Base_ErrorDialogue;
          rc = RC_Base_Pending;
          break;

        /* We're paused, waiting for result of cancel dialogue */
        case RC_Started_CancelDialogue:
          cancel_state = state;
          state = S_Base_CancelDialogue;
          rc = RC_Base_Pending;
          break;

        /* Started SM is working, continue in this state */
        case RC_Started_Pending:
          /* continue */
          rc = RC_Base_Pending;
          break;

        /* Unrecoverable error in Started SM, or unknown return code */
        case RC_Started_Error:
        default:
          /* Error */
          rc = RC_Base_Error;
          state = S_Base_Idle;
      }
      break;
    }

    /* STATE - Waiting for error dialogue to complete */
    case S_Base_ErrorDialogue:
      switch (action_code)
      {
        /* It's a browser message ... */
        case AC_BrowserMessage:
          if (strcmp (bm->command, "errordbox_ok") == 0)
          {
            state = S_Base_Idle;
            rc = RC_Base_Pending;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Base_Error;
            state = S_Base_Idle;
          }
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Base_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Base_Error;
          state = S_Base_Idle;
      }
      break;

    /* STATE - Waiting for user to decide whether they want to cancel */
    case S_Base_CancelDialogue:
      switch (action_code)
      {
        /* It's a browser message */
        case AC_BrowserMessage:
          if (strcmp (bm->command, "canceldbox_ok") == 0)
          {
            switch (cancel_state)
            {
              case S_Base_Starting:
                state = S_Base_Idle;
                rc = RC_Base_Pending;
                break;

              case S_Base_Started:
                state = S_Base_Started;
                cts_statetable_started_SM (AC_Cancel, NULL, NULL);
                rc = RC_Base_Pending;
                break;

              default:
                /* error */
                rc = RC_Base_Error;
                state = S_Base_Idle;
            }
          }
          else if (strcmp (bm->command, "canceldbox_cancel") == 0)
          {
            /* Continue operation that's been paused */
            state = cancel_state;
            rc = RC_Base_Pending;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Base_Error;
            state = S_Base_Idle;
          }
          break;

        case AC_Continue:
          /* wait around */
          rc = RC_Base_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Base_Error;
          state = S_Base_Idle;
      }

    /* INVALID STATE */
    default:
      /* Error, invalid state */
      rc = RC_Base_Error;
      state = S_Base_Idle;
  }

  return rc;
}


browser_dispatch_result cts_statetable_dispatch_browser_message (cts_browser_message *m)
{
  cts_browser_parameter *p;

  (void) m;

  dprintf(("statetable_1", "\ncts_statetable_dispatch_browser_message:\n"));
  dprintf(("statetable_1", "  command is %s\n", m->command));
  for (p = m->param_list; p; p=p->next)
  {
    dprintf (("statetable_1", "    Parameter: `%s' = `%s'\n", p->name, p->value));
  }
  dprintf (("statetable_1", "end of message\n\n"));

  /* Returning bdr_FREE makes the caller free the message structure */
  return bdr_FREE;
}


browser_dispatch_result cts_statetable_dispatch_server_message (cts_server_message *m)
{
  cts_command_parameter *p = &m->params[0];
  size_t index;

  (void) m;

  dprintf (("statetable_1", "\ncts_statetable_dispatch_server_message:\n"));
  for (index = 0; index < m->param_count; ++index)
  {
    dprintf(("statetable_1", "    Parameter: `%s' = `%s'\n",
             p[index].name, p[index].value));
  }
  dprintf(("statetable_1", "end of message\n\n"));
  dprintf(("statetable_1", "The command is `%s'\n",
           ctscmd_strings[m->command]));

  /* Kick state machine */
  cts_statetable_base_SM (AC_ServerMessage, NULL, m);

  /* Returning bdr_FREE makes the caller free the message structure */
  return bdr_FREE;
}
