/*
 *  CTS (StateMachine.c)
 *
 * Copyright (C) Element 14 Ltd. 1999
 *
 */

/* ANSI includes */
#include <stdio.h>
#include <string.h>

/* System includes */
#include "toolbox.h"
#include "event.h"
#include "wimplib.h"
#include "DebugLib/DebugLib.h"

/* Local includes */
#include "ctstypes.h"
#include "ctsbrowser.h"
#include "ctsintern.h"
#include "ctsui.h"
#include "utils.h"
#include "plugclient.h"
#include "smartcard.h"
#include "statetable.h"


/*******************/
/* Local variables */

static cts_browser_message *start_message = NULL;


/*****************************/
/* Local auxiliary functions */


static cts_statetable_password_check_result cts_statemachine_aux_check_new_password (const cts_server_message *sm,
                                                                                     const cts_browser_message *bm,
                                                                                     const char **new_password,
                                                                                     const char **old_password,
                                                                                     int *pass_min,
                                                                                     int *pass_max)
{
  const cts_command_parameter *param;
  const cts_browser_parameter *b_param;

  int pass_kind, len;
  const char *step;
  const char *new_pass1, *new_pass2, *old_pass;

  /*  Extract the old password from the dbox message */
  b_param = cts_browser_parameter_lookup_by_tag (bm, btag_OLDPASSWORD);
  old_pass = b_param->value;

  /*  Extract the first new password from the dbox message */
  b_param = cts_browser_parameter_lookup_by_tag (bm, btag_NEWPASSWORD1);
  new_pass1 = b_param->value;

  /*  Extract the second new password from the dbox message */
  b_param = cts_browser_parameter_lookup_by_tag (bm, btag_NEWPASSWORD2);
  new_pass2 = b_param->value;

  /* Extract the "PassMin" from the "change" command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_PASSMIN);
  *pass_min = atoi (param->value);

  /* Extract the "PassMax" from the "change" command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_PASSMAX);
  *pass_max = atoi (param->value);

  /* Extract the "PassKind" from the "change" command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_PASSKIND);
  pass_kind = atoi (param->value);

  if (strcmp (new_pass1, new_pass2) != 0)
    return Password_Different;

  step = new_pass1;

  while (step)
  {
    switch (pass_kind)
    {
      /* Digits, letters and symbols allowed */
      case 2:
        if (*step > '~' || *step < '!')
          return Password_TypeFail_LettersDigitsSymbols;
        break;

      /* Digits and letters allowed */
      case 1:
        if (*step < '0' || (*step > '9' && *step < 'a') || (*step > 'z' && *step < 'A') || *step > 'Z')
          return Password_TypeFail_LettersDigits;
        break;

      /* Only digits allowed */
      case 0:
        if (*step < '0' || *step > '9')
          return Password_TypeFail_Digits;
        break;
    }
    step++;
  };

  len = strlen (new_pass1);

  if (len > *pass_max || len < *pass_min)
  {
    if (pass_min == pass_max)
      return Password_LenFail_EqualLen;
    else
      return Password_LenFail_RangeLen;
  }

  *new_password = new_pass1;
  *old_password = old_pass;

  return Password_OK;
}


static void cts_statemachine_aux_servermessage_addcmd (cts_server_message *sm, cts_commands command)
{
  cts_server_message_add_parameter (sm, ctstag_strings[tag_CMD], sizeof (ctstag_strings[tag_CMD]) - 1,
                                    ctscmd_strings[command], sizeof (ctscmd_strings[command]) - 1);
}


static int cts_statemachine_aux_checkamps (const cts_browser_message *bm)
{
  cts_browser_parameter *step;
  step = bm->param_list;
  while (step)
  {
    if ((Strcmp_ci (step->name, ctstag_strings[tag_SERVICE]) != 0) &&
        (Strcmp_ci (step->name, ctstag_strings[tag_SEQ]) != 0) &&
        (Strcmp_ci (step->name, ctstag_strings[tag_CMD]) != 0))
    {
      if (strchr (step->name, '&') != NULL)
        return 0;
      if (strchr (step->value, '&') != NULL)
        return 0;
    }
    step = step->next;
  };

  /* Return 1 if we've got this far with no ampersands in user data */
  return 1;
}


/* Auxiliary function to send the result of the "basic" command */
static void cts_statetable_aux_sendresult_basic (cts_server_message *sm)
{
  cts_server_message *reply_sm;
  const cts_command_parameter *param;
  char *url, *username, *password;

  reply_sm = cts_server_message_reply_initialise (sm);

  /* Add the "Basic" command */
  cts_statemachine_aux_servermessage_addcmd (reply_sm, cmd_BASIC);

  /* Extract the  username from the "basic" command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_USER);
  username = param->value;

  /* Extract the password from the "basic" command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_PASSWORD);
  password = param->value;

  /* Extract the next URL from the "basic" command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_URL);

  /* Generate the URL to launch */
  url = cts_generate_server_url (reply_sm, param->value, username, password);

  /* Free up the server message */
  cts_server_message_destroy (reply_sm);

  /* And launch it! */
  dprintf (("StateMachine", "SM> ******** Send \"basic\" result, \"%s\"\n", url));
  pluginclient_browser_goto (sm->plugin, url);
  /* Free the URL */
  if (url)
    free (url);
}


/* Auxiliary function to send the result of the "change" command */
static void cts_statetable_aux_sendresult_change (cts_server_message *sm, void *result)
{
  cts_server_message *reply_sm;
  const cts_command_parameter *param;
  char *url;

  reply_sm = cts_server_message_reply_initialise (sm);

  /* Add the change result -- TODO */
  cts_server_message_add_parameter (reply_sm, ctstag_strings[tag_STS], sizeof (ctstag_strings[tag_STS])-1,
                                    "00", sizeof ("00")-1);

  /* Add the "Change" command */
  cts_statemachine_aux_servermessage_addcmd (reply_sm, cmd_CHANGE);

  /* Extract the next URL from the "verify" command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_URL);

  /* Generate the URL to launch */
  url = cts_generate_server_url (reply_sm, param->value, NULL, NULL);

  /* Free up the server message */
  cts_server_message_destroy (reply_sm);

  /* And launch it! */
  dprintf (("StateMachine", "SM> ******** Send \"change\" result, \"%s\"\n", url));
  pluginclient_browser_access_url (sm->plugin, url, NULL);
  /* Free the URL */
  if (url)
    free (url);
}


/* Auxiliary function to send the result of the "error" (or "close") command */
static void cts_statetable_aux_sendresult_errorclose (cts_server_message *sm)
{
  cts_server_message *reply_sm;
  const cts_command_parameter *param;
  char *url;

  reply_sm = cts_server_message_reply_initialise (sm);

  /* Add the appropriate command ("Err" or "Close") */
  cts_statemachine_aux_servermessage_addcmd (reply_sm, sm->command);

  /* Extract the next URL from the "error" (or "close") command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_URL);

  /* Generate the URL to launch */
  url = cts_generate_server_url (reply_sm, param->value, NULL, NULL);

  /* Free up the server message */
  cts_server_message_destroy (reply_sm);

  /* And launch it! */
  dprintf (("StateMachine", "SM> ******** Send \"errorclose\" result, \"%s\"\n", url));
  pluginclient_browser_goto (sm->plugin, url);
  /* Free the URL */
  if (url)
    free (url);
}


/* Auxiliary function to send the result of the "verify" command */
static void cts_statetable_aux_sendresult_verify (cts_server_message *sm, void *result)
{
  cts_server_message *reply_sm;
  const cts_command_parameter *param;
  char *url;

  reply_sm = cts_server_message_reply_initialise (sm);

  /* Add the verify result -- TODO */
  cts_server_message_add_parameter (reply_sm, ctstag_strings[tag_STS], sizeof (ctstag_strings[tag_STS])-1,
                                    "00", sizeof ("00")-1);

  /* Add the "Verify" command */
  cts_statemachine_aux_servermessage_addcmd (reply_sm, cmd_VERIFY);

  /* Extract the next URL from the "verify" command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_URL);

  /* Generate the URL to launch */
  url = cts_generate_server_url (reply_sm, param->value, NULL, NULL);

  /* Free up the server message */
  cts_server_message_destroy (reply_sm);

  /* And launch it! */
  dprintf (("StateMachine", "SM> ******** Send \"verify\" result, \"%s\"\n", url));
  pluginclient_browser_access_url (sm->plugin, url, NULL);
  /* Free the URL */
  if (url)
    free (url);
}


/* Auxiliary function to send the result of the "apdu" (or "apdut") command */
static void cts_statetable_aux_sendresult_apdu (cts_server_message *sm, void *results)
{
  cts_server_message *reply_sm;
  const cts_command_parameter *param;
  char *url;
  const cts_browser_parameter *step;

  reply_sm = cts_server_message_reply_initialise (sm);

  if (sm->command == cmd_APDU)
  {
    /* Add the "APDU" command */
    cts_statemachine_aux_servermessage_addcmd (reply_sm, cmd_APDU);
  }
  else
  {
    /* Add the "APDUT" command */
    cts_statemachine_aux_servermessage_addcmd (reply_sm, cmd_APDUT);

    /* Add the "screen data" */
    step = start_message->param_list;
    while (step)
    {
      if ((Strcmp_ci (step->name, ctstag_strings[tag_SERVICE]) != 0) &&
          (Strcmp_ci (step->name, ctstag_strings[tag_SEQ]) != 0) &&
          (Strcmp_ci (step->name, ctstag_strings[tag_CMD]) != 0))
      {
        cts_server_message_add_parameter (reply_sm, step->name, step->name_length,
                                                    step->value, step->value_length);
      }
      step = step->next;
    };
  }

  /* Extract the next URL from the "APDU" (or "APDUT") command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_URL);

  /* Generate the URL to launch */
  url = cts_generate_server_url (reply_sm, param->value, NULL, NULL);

  /* Free up the server message */
  cts_server_message_destroy (reply_sm);

  /* And launch it! */
  dprintf (("StateMachine", "SM> ******** Send \"apdu(t)\" result, \"%s\"\n", url));
  pluginclient_browser_access_url (sm->plugin, url, NULL);
  /* Free the URL */
  if (url)
    free (url);
}


/* Auxiliary function to send the result of the "text" command */
static void cts_statetable_aux_sendresult_text (cts_server_message *sm)
{
  cts_server_message *reply_sm;
  const cts_command_parameter *param;
  char *url;
  const cts_browser_parameter *step;

  reply_sm = cts_server_message_reply_initialise (sm);

  /* Add the "Text" command */
  cts_statemachine_aux_servermessage_addcmd (reply_sm, cmd_TEXT);

  /* Add the "screen data" */
  step = start_message->param_list;
  while (step)
  {
    if ((Strcmp_ci (step->name, ctstag_strings[tag_SERVICE]) != 0) &&
        (Strcmp_ci (step->name, ctstag_strings[tag_SEQ]) != 0) &&
        (Strcmp_ci (step->name, ctstag_strings[tag_CMD]) != 0))
    {
      cts_server_message_add_parameter (reply_sm, step->name, step->name_length,
                                                  step->value, step->value_length);
    }
    step = step->next;
  }

  /* Extract the next URL from the "text" command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_URL);

  /* Generate the URL to launch */
  url = cts_generate_server_url (reply_sm, param->value, NULL, NULL);

  /* Free up the server message */
  cts_server_message_destroy (reply_sm);

  /* And launch it! */
  dprintf (("StateMachine", "SM> ******** Send \"text\" result, \"%s\"\n", url));
  pluginclient_browser_access_url (sm->plugin, url, NULL);
  /* Free the URL */
  if (url)
    free (url);
}


/* Auxiliary function to send the result of the "error" command */
static void cts_statetable_aux_sendresult_error (cts_server_message *sm)
{
  cts_server_message *reply_sm;
  const cts_command_parameter *param;
  char *url;

  reply_sm = cts_server_message_reply_initialise (sm);

  /* Add the error code */
  param = cts_command_parameter_lookup_by_tag (sm, tag_MSG);
  cts_server_message_add_parameter (reply_sm, param->name, param->name_length, param->value,
                                    param->value_length);

  /* Add the "Err" command */
  cts_statemachine_aux_servermessage_addcmd (reply_sm, cmd_ERR);

  /* Extract the next URL from the error command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_URL);

  /* Generate the URL to launch */
  url = cts_generate_server_url (reply_sm, param->value, NULL, NULL);

  /* Free up the server message */
  cts_server_message_destroy (reply_sm);

  /* And launch it! */
  dprintf (("StateMachine", "SM> ******** Send \"error\" result, \"%s\"\n", url));
  pluginclient_browser_goto (sm->plugin, url);
  /* Free the URL */
  if (url)
    free (url);
}


/* Auxiliary function to send the result of the "open" command */
static void cts_statetable_aux_sendresult_open (cts_server_message *sm, const char *result)
{
  cts_server_message *reply_sm;
  const cts_command_parameter *param;
  char *url;

  reply_sm = cts_server_message_reply_initialise (sm);

  /* Add the smart card open result */
  cts_server_message_add_parameter (reply_sm, ctstag_strings[tag_STS], sizeof (ctstag_strings[tag_STS])-1,
                                    result, strlen (result));

  /* Add the "Open" command */
  cts_statemachine_aux_servermessage_addcmd (reply_sm, cmd_OPEN);

  /* Extract the next URL from the open command message */
  param = cts_command_parameter_lookup_by_tag (sm, tag_URL);

  /* Generate the URL to launch */
  url = cts_generate_server_url (reply_sm, param->value, NULL, NULL);

  /* Free up the server message */
  cts_server_message_destroy (reply_sm);

  /* And launch it! */
  dprintf (("StateMachine", "SM> ******** Send \"open\" result, \"%s\"\n", url));
  pluginclient_browser_access_url (sm->plugin, url, NULL);
  /* Free the URL */
  if (url)
    free (url);
}


/* Auxiliary function to send the result of the "start" command */
static void cts_statetable_aux_sendresult_start (cts_browser_message *bm)
{
  cts_server_message *sm;
  const cts_browser_parameter *param;
  char *url;

  /* Initialise the response message */
  sm = cts_server_message_initialise ();

  /* Extract the service name from the start message and add it to the response */
  param = cts_browser_parameter_lookup_by_tag (bm, btag_SERVICE);
  cts_server_message_add_parameter (sm, param->name, param->name_length, param->value,
                                    param->value_length);

  /* Extract the sequence number from the start message and add it to the response */
  param = cts_browser_parameter_lookup_by_tag (bm, btag_SEQ);
  cts_server_message_add_parameter (sm, param->name, param->name_length, param->value,
                                    param->value_length);

  /* Add the "Start" command */
  cts_statemachine_aux_servermessage_addcmd (sm, cmd_START);

  /* Extract the next URL from the start message */
  param = cts_browser_parameter_lookup_by_tag (bm, btag_URL);

  /* Generate the URL to launch */
  url = cts_generate_server_url (sm, param->value, NULL, NULL);

  /* Free up the server message */
  cts_server_message_destroy (sm);

  /* And launch it! */
  dprintf (("StateMachine", "SM> ******** Send \"start\" result, \"%s\"\n", url));
  pluginclient_browser_access_url (bm->plugin, url, NULL);
  /* Free the URL */
  if (url)
    free (url);
}


/*********************************/
/* Local state machine functions */


/* State machine for "Basic" command handling */
static cts_statetable_result_basic cts_statetable_basic_SM (cts_statetable_action action_code,
                                                            cts_browser_message *bm,
                                                            cts_server_message *sm)
{
  cts_statetable_result_basic rc;

  static cts_statetable_states_basic state = S_Basic_Idle;
  static cts_server_message *basic_message = NULL;

#ifdef DEBUGLIB
  static cts_statetable_states_basic last_state = S_Basic_Idle;
  last_state = state;
#endif

  if (action_code == AC_Start)
  {
    dprintf (("StateMachine", "SM> Basic - Initialising (moving to Closing state)\n"));
    /* Open "accessing smart card" dialogue (code 01-2) */
    cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
    basic_message = sm;
    state = S_Basic_Closing;
    return RC_Basic_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_Basic_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action, but handle it anyway */
          rc = RC_Basic_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Basic_Error;
      }
      break;

    /* STATE - Working on "Close" command */
    case S_Basic_Closing:
      switch (action_code)
      {
#ifdef CANCELACTION_ALLOWED
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "Cancel" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_CANCEL))
            {
              /* Open cancel confirm dbox (code 05) */
              cts_ui_open_dbox (bm->plugin, NULL, ui_code_05);
              rc = RC_Basic_CancelDialogue;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Basic_Error;
              state = S_Basic_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Basic_Error;
            state = S_Basic_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "basic" command message */
          cts_server_message_destroy (basic_message);
          basic_message = NULL;
          break;
#endif
        case AC_Continue:
          if (/*close complete*/1)
          {
            /* Close "accessing smart card" dbox */
            cts_ui_close_dbox (basic_message->plugin);
            /* Open "communicating with server" dbox (code 01-1) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
            /* Send result of command (with attached data from "basic_message" */
            cts_statetable_aux_sendresult_basic (basic_message);
            /* Free the "basic" command message */
            cts_server_message_destroy (basic_message);
            basic_message = NULL;
            state = S_Basic_Idle;
            rc = RC_Basic_Finished;
          }
          else
          {
            /* Wait around */
            rc = RC_Basic_Pending;
          }
          break;

        case AC_Cancel:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (basic_message->plugin);
          /* Free the "basic" command message */
          cts_server_message_destroy (basic_message);
          basic_message = NULL;
          state = S_Basic_Idle;
          rc = RC_Basic_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Basic_Idle;
          rc = RC_Basic_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_Basic_Idle;
      rc = RC_Basic_Error;
      break;
  }

#ifdef DEBUGLIB
  if (last_state != state)
  {
    dprintf (("StateMachine", "SM> Basic - Changed state from %d to %d\n", last_state, state));
    last_state = state;
  }
#endif

  return rc;
  NOT_USED(bm);
}


/* State machine for "Close" command handling */
static cts_statetable_result_change cts_statetable_change_SM (cts_statetable_action action_code,
                                                              cts_browser_message *bm,
                                                              cts_server_message *sm)
{
  cts_statetable_result_change rc;

  static cts_statetable_states_change state = S_Change_Idle;
  static cts_server_message *change_message = NULL;

#ifdef DEBUGLIB
  static cts_statetable_states_change last_state = S_Change_Idle;
  last_state = state;
#endif

  if (action_code == AC_Start)
  {
    dprintf (("StateMachine", "SM> Change - Initialising (moving to WaitingOKCancel state)\n"));
    /* Open "password change" dbox (code 22) */
    cts_ui_open_dbox (sm->plugin, NULL, ui_code_22);
    change_message = sm;
    state = S_Change_WaitingOKCancel;
    return RC_Change_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_Change_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action but handle it anyway */
          rc = RC_Change_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Change_Error;
      }
      break;

    /* STATE - Waiting for password change dbox OK or Cancel click */
    case S_Change_WaitingOKCancel:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close "password change" dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "OK" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_OK))
            {
              /* Compare new passwords, plus check length and type -- TODO */
              if (/*wrong*/0)
              {
                /* Open "confirmation entered wrongly" dbox (code 26) */
                cts_ui_open_dbox (sm->plugin, NULL, ui_code_26);
                state = S_Change_RetryPasswordDialogue;
                rc = RC_Change_Pending;
              }
              else
              {
                /* Open "accessing smart card" dbox (code 01-2)  */
                cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
                /* Send "verify" command -- TODO */
                state = S_Change_ReceiveVerifyResponse;
                rc = RC_Change_Pending;
              }
            }
            else if (cts_browser_parameter_lookup_by_tag (bm, btag_CANCEL))
            {
              /* Free the "change" command message */
              cts_server_message_destroy (change_message);
              change_message = NULL;
              rc = RC_Change_Terminated;
              state = S_Change_Idle;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Change_Error;
              state = S_Change_Idle;
              /* Free the "change" command message */
              cts_server_message_destroy (change_message);
              change_message = NULL;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Change_Error;
            state = S_Change_Idle;
            /* Free the "change" command message */
            cts_server_message_destroy (change_message);
            change_message = NULL;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Change_Pending;
          break;

        case AC_Cancel:
          /* Close "password change" dbox */
          cts_ui_close_dbox (change_message->plugin);
          /* Free the "change" command message */
          cts_server_message_destroy (change_message);
          change_message = NULL;
          state = S_Change_Idle;
          rc = RC_Change_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Change_Idle;
          rc = RC_Change_Error;
      }
      break;


    /* STATE - Waiting for response to "verify" command */
    case S_Change_ReceiveVerifyResponse:
      switch (action_code)
      {
#ifdef CANCELACTION_ALLOWED
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "Cancel" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_CANCEL))
            {
              /* Open cancel confirm dbox (code 05) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_05);
              rc = RC_Change_CancelDialogue;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Change_Error;
              state = S_Change_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Change_Error;
            state = S_Change_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "change" command message */
          cts_server_message_destroy (change_message);
          change_message = NULL;
          break;
#endif
        case AC_Continue:
          /* poll for response completion -- TODO */
          if (/*finished*/1)
          {
            if (/*key lock, or command error*/0)
            {
              ui_code_identifiers code;
              int err_num = 0;

              /* Close "accessing smart card" dbox */
              cts_ui_close_dbox (change_message->plugin);
              if (/*password locked*/0)
                code = ui_code_23;
              else if (/*password wrong and locked*/0)
                code = ui_code_24;
              else
              {
                /* smart card error */
                err_num = /* from smart card ..*/1;
                code = ui_code_30;
              }
              /* Open error message dbox (code 23,24,30) */
              cts_ui_open_dbox (sm->plugin, NULL, code, err_num);
              state = S_Change_SpecialErrorDialogue;
              rc =  RC_Change_Pending;
            }
            else if (/*communication error*/0)
            {
              /* Close "accessing smart card" dbox */
              cts_ui_close_dbox (change_message->plugin);
              /* Open error message dbox (code 03) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_03);
              /* Free the "change" command message */
              cts_server_message_destroy (change_message);
              change_message = NULL;
              rc =  RC_Change_ErrorDialogue;
              state = S_Change_Idle;
            }
            else if (/*key comparison failed*/0)
            {
              /* Open error message dbox (code 25) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_25, /* num of tries left -- TODO */999);
              state = S_Change_RetryPasswordDialogue;
              rc =  RC_Change_Pending;
            }
            else
            {
              /* Finished */
              /* Send "change" command -- TODO */
              state = S_Change_ReceiveChangeResponse;
              rc = RC_Change_Pending;
            }
          }
          else
          {
            rc = RC_Change_Pending;
          }
          break;

        case AC_Cancel:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (change_message->plugin);
          /* Free the "change" command message */
          cts_server_message_destroy (change_message);
          change_message = NULL;
          state = S_Change_Idle;
          rc = RC_Change_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Change_Idle;
          rc = RC_Change_Error;
      }
      break;

    /* STATE - Waiting for response to smart card "ChangeKey" command */
    case S_Change_ReceiveChangeResponse:
      switch (action_code)
      {
#ifdef CANCELACTION_ALLOWED
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "Cancel" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_CANCEL))
            {
              /* Open cancel confirm dbox (code 05) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_05);
              rc = RC_Change_CancelDialogue;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Change_Error;
              state = S_Change_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Change_Error;
            state = S_Change_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "change" command message */
          cts_server_message_destroy (change_message);
          change_message = NULL;
          break;
#endif
        case AC_Continue:
          /* poll for response completion -- TODO */
          if (/*finished*/1)
          {
            /* Close "accessing smart card" dbox */
            cts_ui_close_dbox (change_message->plugin);

            if (/*command error -- TODO */0)
            {
              ui_code_identifiers code;
              int err_num = 0;

              if (/*password locked -- TODO */0)
                code = ui_code_23;
              else if (/*password wrong and locked -- TODO*/0)
                code = ui_code_24;
              else
              {
                /* Smart card error */
                err_num = /* from smart card -- TODO*/1;
                code = ui_code_30;
              }
              /* Open error message dbox (code 23,24,30) */
              cts_ui_open_dbox (sm->plugin, NULL, code, err_num);
              state = S_Change_SpecialErrorDialogue;
              rc =  RC_Change_Pending;
            }
            else if (/*communication error -- TODO */0)
            {
              /* Open error message dbox (code 03) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_03);
              /* Free the "change" command message */
              cts_server_message_destroy (change_message);
              change_message = NULL;
              rc =  RC_Change_ErrorDialogue;
              state = S_Change_Idle;
            }
            else if (/*key change succeeded -- TODO */1)
            {
              /* Finished */
              /* Open "communicating with server" dbox (code 01-1) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
              /* Send response (includes change result) */
              cts_statetable_aux_sendresult_change (change_message, NULL/*TODO*/);
              /* Free the "change" command message */
              cts_server_message_destroy (change_message);
              change_message = NULL;
              state = S_Change_Idle;
              rc = RC_Change_Finished;
            }
          }
          else
          {
            rc = RC_Change_Pending;
          }
          break;

        case AC_Cancel:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (change_message->plugin);
          /* Free the "change" command message */
          cts_server_message_destroy (change_message);
          change_message = NULL;
          state = S_Change_Idle;
          rc = RC_Change_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Change_Idle;
          rc = RC_Change_Error;
      }
      break;

    /* STATE - Waiting for special error dialogue box to complete */
    case S_Change_SpecialErrorDialogue:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "OK" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_OK))
            {
              /* Open "communicating with server" dbox (code 01-1) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
              /* Send response (includes change result) */
              cts_statetable_aux_sendresult_change (change_message, NULL/*TODO*/);
              state = S_Change_Idle;
              rc = RC_Change_Finished;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Change_Error;
              state = S_Change_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Change_Error;
            state = S_Change_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "change" command message */
          cts_server_message_destroy (change_message);
          change_message = NULL;
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Change_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Change_Idle;
          rc = RC_Change_Error;
      }
      break;

    /* STATE - Waiting for retry password dialogue box to complete */
    case S_Change_RetryPasswordDialogue:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "OK" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_OK))
            {
              /* Re-open "password change" dbox (code 22) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_22);
              state = S_Change_WaitingOKCancel;
              rc = RC_Change_Pending;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Change_Error;
              state = S_Change_Idle;
              /* Free the "change" command message */
              cts_server_message_destroy (change_message);
              change_message = NULL;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Change_Error;
            state = S_Change_Idle;
            /* Free the "change" command message */
            cts_server_message_destroy (change_message);
            change_message = NULL;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Change_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Change_Idle;
          rc = RC_Change_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_Change_Idle;
      rc = RC_Change_Error;
      break;
  }

#ifdef DEBUGLIB
  if (last_state != state)
  {
    dprintf (("StateMachine", "SM> Change - Changed state from %d to %d\n", last_state, state));
    last_state = state;
  }
#endif

  return rc;
}


/* State machine for "Error" and "Close" command handling */
static cts_statetable_result_errorclose cts_statetable_errorclose_SM (cts_statetable_action action_code,
                                                            cts_browser_message *bm,
                                                            cts_server_message *sm)
{
  cts_statetable_result_errorclose rc;

  static cts_statetable_states_errorclose state = S_ErrorClose_Idle;
  static cts_server_message *errorclose_message = NULL;

#ifdef DEBUGLIB
  static cts_statetable_states_errorclose last_state = S_ErrorClose_Idle;
  last_state = state;
#endif

  if (action_code == AC_Start)
  {
    dprintf (("StateMachine", "SM> ErrorClose - Initialising (moving to Closing state)\n"));
    /* Open "accessing smart card" dialogue (code 01-2) */
    cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
    /* Send close command -- TODO */
    errorclose_message = sm;
    state = S_ErrorClose_Closing;
    return RC_ErrorClose_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_ErrorClose_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action, but handle it anyway */
          rc = RC_ErrorClose_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_ErrorClose_Error;
      }
      break;

    /* STATE - Working on "Close" command */
    case S_ErrorClose_Closing:
      switch (action_code)
      {
#ifdef CANCELACTION_ALLOWED
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "Cancel" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_CANCEL))
            {
              /* Open cancel confirm dbox (code 05) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_05);
              rc = RC_ErrorClose_CancelDialogue;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_ErrorClose_Error;
              state = S_ErrorClose_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_ErrorClose_Error;
            state = S_ErrorClose_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "errorclose" command message */
          cts_server_message_destroy (errorclose_message);
          errorclose_message = NULL;
          break;
#endif
        case AC_Continue:
          if (/*close complete*/1)
          {
            /* Close "accessing smart card" dbox */
            cts_ui_close_dbox (bm->plugin);
            /* Open "communicating with server" dbox (code 01-1) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
            /* Send result of command (with attached data from "errorclose_message" */
            cts_statetable_aux_sendresult_errorclose (errorclose_message);
            /* Free the "errorclose" command message */
            cts_server_message_destroy (errorclose_message);
            errorclose_message = NULL;
            state = S_ErrorClose_Idle;
            rc = RC_ErrorClose_Finished;
          }
          else
          {
            /* Wait around */
            rc = RC_ErrorClose_Pending;
          }
          break;

        case AC_Cancel:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);
          /* Free the "errorclose" command message */
          cts_server_message_destroy (errorclose_message);
          errorclose_message = NULL;
          state = S_ErrorClose_Idle;
          rc = RC_ErrorClose_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_ErrorClose_Idle;
          rc = RC_ErrorClose_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_ErrorClose_Idle;
      rc = RC_ErrorClose_Error;
      break;
  }

#ifdef DEBUGLIB
  if (last_state != state)
  {
    dprintf (("StateMachine", "SM> ErrorClose - Changed state from %d to %d\n", last_state, state));
    last_state = state;
  }
#endif

  return rc;
}


/* State machine for "Verify" command handling */
static cts_statetable_result_verify cts_statetable_verify_SM (cts_statetable_action action_code,
                                                              cts_browser_message *bm,
                                                              cts_server_message *sm)
{
  cts_statetable_result_verify rc;

  static cts_statetable_states_verify state = S_Verify_Idle;
  static cts_server_message *verify_message = NULL;

#ifdef DEBUGLIB
  static cts_statetable_states_verify last_state = S_Verify_Idle;
  last_state = state;
#endif

  if (action_code == AC_Start)
  {
    dprintf (("StateMachine", "SM> Verify - Initialising (moving to WaitingOKCancel state)\n"));
    /* Open "enter password" dbox (code 21) */
    cts_ui_open_dbox (sm->plugin, NULL, ui_code_21);
    verify_message = sm;
    state = S_Verify_WaitingOKCancel;
    return RC_Verify_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_Verify_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action but handle it anyway */
          rc = RC_Verify_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Verify_Error;
      }
      break;

    /* STATE - Waiting for password window OK or Cancel click */
    case S_Verify_WaitingOKCancel:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close password dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "OK" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_OK))
            {
              /* Open "Accessing smartcard" dialogue (code 01-02) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
              /* send "verify" command -- TODO */
              state = S_Verify_ReceiveResponse;
              rc = RC_Verify_Pending;
            }
            /* Check for "Cancel" action */
            else if (cts_browser_parameter_lookup_by_tag (bm, btag_CANCEL))
            {
              /* Free the "verify" command message */
              cts_server_message_destroy (verify_message);
              verify_message = NULL;
              rc = RC_Verify_Terminated;
              state = S_Verify_Idle;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Verify_Error;
              state = S_Verify_Idle;
              /* Free the "verify" command message */
              cts_server_message_destroy (verify_message);
              verify_message = NULL;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Verify_Error;
            state = S_Verify_Idle;
            /* Free the "verify" command message */
            cts_server_message_destroy (verify_message);
            verify_message = NULL;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Verify_Pending;
          break;

        case AC_Cancel:
          /* Close password dbox */
          cts_ui_close_dbox (bm->plugin);
          /* Free the "verify" command message */
          cts_server_message_destroy (verify_message);
          verify_message = NULL;
          state = S_Verify_Idle;
          rc = RC_Verify_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Verify_Idle;
          rc = RC_Verify_Error;
      }
      break;

    /* STATE - Waiting for response to smart card command */
    case S_Verify_ReceiveResponse:
      switch (action_code)
      {
#ifdef CANCELACTION_ALLOWED
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "Cancel" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_CANCEL))
            {

              /* Open cancel confirm dbox (code 05) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_05);
              rc = RC_Verify_CancelDialogue;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Verify_Error;
              state = S_Verify_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Verify_Error;
            state = S_Verify_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "verify" command message */
          cts_server_message_destroy (verify_message);
          verify_message = NULL;
          break;
#endif
        case AC_Continue:
          /* poll for response completion -- TODO */
          if (/*finished*/1)
          {
            /* Close "accessing smart card" dbox */
            cts_ui_close_dbox (verify_message->plugin);

            if (/*key lock, or command error*/0)
            {
              ui_code_identifiers code;
              int err_num = 0;

              if (/*password locked -- TODO */0)
                code = ui_code_23;
              else if (/*password wrong and locked -- TODO*/0)
                code = ui_code_24;
              else
              {
                /* Smart card error */
                err_num = /* from smart card -- TODO*/1;
                code = ui_code_30;
              }
              /* Open error message dbox (code 23,24,30) */
              cts_ui_open_dbox (sm->plugin, NULL, code, err_num);
              state = S_Verify_SpecialErrorDialogue;
              rc =  RC_Verify_Pending;
            }
            else if (/*communication error*/0)
            {
              /* Open error message dbox (code 03) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_03);
              /* Free the "verify" command message */
              cts_server_message_destroy (verify_message);
              verify_message = NULL;
              rc =  RC_Verify_ErrorDialogue;
              state = S_Verify_Idle;
            }
            else if (/*key comparison failed*/0)
            {
              /* Open error message dbox (code 25) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_25, /* num of tries left -- TODO */999);
              state = S_Verify_RetryPasswordDialogue;
              rc =  RC_Verify_Pending;
            }
            else
            {
              /* Finished */
              /* Open "communicating with server" dbox (code 01-1) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
              /* Send response (includes verify result) */
              cts_statetable_aux_sendresult_verify (verify_message, NULL/*TODO*/);
              /* Free the "verify" command message */
              cts_server_message_destroy (verify_message);
              verify_message = NULL;
              state = S_Verify_Idle;
              rc = RC_Verify_Finished;
            }
          }
          else
          {
            rc = RC_Verify_Pending;
          }
          break;

      default:
        /* Any other action in this state is illegal */
        state = S_Verify_Idle;
        rc = RC_Verify_Error;
      }
      break;

    /* STATE - Waiting for special error dialogue box to complete */
    case S_Verify_SpecialErrorDialogue:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "OK" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_OK))
            {
              /* Open "communicating with server" dbox (code 01-1) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
              /* Send response (includes verify result) */
              cts_statetable_aux_sendresult_verify (verify_message, NULL/*TODO*/);
              state = S_Verify_Idle;
              rc = RC_Verify_Finished;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Verify_Error;
              state = S_Verify_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Verify_Error;
            state = S_Verify_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "verify" command message */
          cts_server_message_destroy (verify_message);
          verify_message = NULL;
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Verify_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Verify_Idle;
          rc = RC_Verify_Error;
      }
      break;

    /* STATE - Waiting for retry password dialogue box to complete */
    case S_Verify_RetryPasswordDialogue:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "OK" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_OK))
            {
              /* Re-open "enter password" dbox (code 21) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_21);
              state = S_Verify_WaitingOKCancel;
              rc = RC_Verify_Pending;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Verify_Error;
              state = S_Verify_Idle;
              /* Free the "verify" command message */
               cts_server_message_destroy (verify_message);
              verify_message = NULL;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Verify_Error;
            state = S_Verify_Idle;
            /* Free the "verify" command message */
            cts_server_message_destroy (verify_message);
            verify_message = NULL;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Verify_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Verify_Idle;
          rc = RC_Verify_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_Verify_Idle;
      rc = RC_Verify_Error;
      break;
  }

#ifdef DEBUGLIB
  if (last_state != state)
  {
    dprintf (("StateMachine", "SM> Verify - Changed state from %d to %d\n", last_state, state));
    last_state = state;
  }
#endif

  return rc;
}


/* State machine for "APDU" and "APDUT" command handling */
static cts_statetable_result_apdu cts_statetable_apdu_SM (cts_statetable_action action_code,
                                                          cts_browser_message *bm,
                                                          cts_server_message *sm)
{
  cts_statetable_result_apdu rc;

  static cts_statetable_states_apdu state = S_APDU_Idle;
  static cts_server_message *apdu_message = NULL;

#ifdef DEBUGLIB
  static cts_statetable_states_apdu last_state = S_APDU_Idle;
  last_state = state;
#endif

  if (action_code == AC_Start)
  {
    dprintf (("StateMachine", "SM> APDU - Initialising (moving to ReceiveResponse state)\n"));
    /* Open "accessing smart card" dialogue */
    cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
    /* Send first command -- TODO */
    apdu_message = sm;
    state = S_APDU_ReceiveResponse;
    return RC_APDU_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_APDU_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action but handle it anyway */
          rc = RC_APDU_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_APDU_Error;
      }
      break;

    /* STATE - Waiting for response to smart card command */
    case S_APDU_ReceiveResponse:
      switch (action_code)
      {
#ifdef CANCELACTION_ALLOWED
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "Cancel" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_CANCEL))
            {
              /* Open cancel confirm dbox (code 05) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_05);
              rc = RC_APDU_CancelDialogue;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_APDU_Error;
              state = S_APDU_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_APDU_Error;
            state = S_APDU_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "apdu" command message */
          cts_server_message_destroy (apdu_message);
          apdu_message = NULL;
          break;
#endif
        case AC_Continue:
          /* poll for response completion -- TODO */
          if (/*finished*/0)
          {
            if (/*error*/0)
            {
              /* Close "accessing smart card" dbox */
              cts_ui_close_dbox (apdu_message->plugin);
              /* Open error message dbox (code 03) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_03);
              /* Free the "apdu" command message */
              cts_server_message_destroy (apdu_message);
              apdu_message = NULL;
              rc =  RC_APDU_ErrorDialogue;
              state = S_APDU_Idle;
            }
            else
            {
              /* need to make up list of responses for each command -- TODO */
              if (/*more commands*/0)
              {
                /* send next command -- TODO */
                rc = RC_APDU_Pending;
              }
              else
              {
                /* finished */
                /* Close "accessing smart card" dbox */
                cts_ui_close_dbox (apdu_message->plugin);
                /* Open "communicating with server" dbox (code 01-1) */
                cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
                /* Send response (includes text for APDUT case) */
                cts_statetable_aux_sendresult_apdu (apdu_message, NULL/*TODO*/);
                /* Free the "apdu" command message */
                cts_server_message_destroy (apdu_message);
                apdu_message = NULL;
                state = S_APDU_Idle;
                rc = RC_APDU_Finished;
              }
            }
          }
          else
          {
            rc = RC_APDU_Pending;
          }
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_APDU_Idle;
          rc = RC_APDU_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_APDU_Idle;
      rc = RC_APDU_Error;
      break;
  }

#ifdef DEBUGLIB
  if (last_state != state)
  {
    dprintf (("StateMachine", "SM> APDU - Changed state from %d to %d\n", last_state, state));
    last_state = state;
  }
#endif

  return rc;
  NOT_USED(bm);
}


/* State machine for "Text" command handling */
static cts_statetable_result_text cts_statetable_text_SM (cts_statetable_action action_code,
                                                          cts_browser_message *bm,
                                                          cts_server_message *sm)
{
  cts_statetable_result_text rc;

  static cts_statetable_states_text state = S_Text_Idle;
  static cts_server_message *text_message = NULL;

#ifdef DEBUGLIB
  static cts_statetable_states_text last_state = S_Text_Idle;
  last_state = state;
#endif

  if (action_code == AC_Start)
  {
    dprintf (("StateMachine", "SM> Text - Initialising (moving to Weoking state)\n"));
    text_message = sm;
    state = S_Text_Working;
    return RC_Text_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_Text_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action, but handle it anyway */
          rc = RC_Text_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Text_Error;
      }
      break;

    /* STATE - Working on "Text" command */
    case S_Text_Working:
      switch (action_code)
      {
#ifdef CANCELACTION_ALLOWED
        case AC_BrowserMessage:
          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "Cancel" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_CANCEL))
            {
              /* Open cancel confirm dbox (code 05) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_05);
              rc = RC_Text_CancelDialogue;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Text_Error;
            state = S_Text_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Text_Error;
            state = S_Text_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "text" command message */
          cts_server_message_destroy (text_message);
          break;
#endif
        case AC_Continue:
          /* Open "communicating with server" dbox (code 01-1) */
          cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
          /* Send result of "text" command */
          cts_statetable_aux_sendresult_text (text_message);
          /* Free the "text" command message */
          cts_server_message_destroy (text_message);
          state = S_Text_Idle;
          rc = RC_Text_Finished;

        case AC_Cancel:
          /* Free the "text" command message */
          cts_server_message_destroy (text_message);
          state = S_Text_Idle;
          rc = RC_Text_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Text_Idle;
          rc = RC_Text_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_Text_Idle;
      rc = RC_Text_Error;
      break;
  }

#ifdef DEBUGLIB
  if (last_state != state)
  {
    dprintf (("StateMachine", "SM> Text - Changed state from %d to %d\n", last_state, state));
    last_state = state;
  }
#endif

  return rc;
  NOT_USED(bm);
}


/* State machine which handles all states of the plugin running and being open */
static cts_statetable_result_open cts_statetable_open_SM (cts_statetable_action action_code,
                                                          cts_browser_message *bm,
                                                          cts_server_message *sm)
{
  cts_statetable_result_open rc;

  static cts_statetable_states_open state = S_Open_Idle;

#ifdef DEBUGLIB
  static cts_statetable_states_open last_state = S_Open_Idle;
  last_state = state;
#endif

  if (action_code == AC_Start)
  {
    dprintf (("StateMachine", "SM> Open - Initialising (moving to Idle state)\n"));
    state = S_Open_Idle;
    return RC_Open_Pending;
  }

  switch (state)
  {
    /* STATE - Card open, but idle */
    case S_Open_Idle:
      switch (action_code)
      {
        /* It's a server message ... */
        case AC_ServerMessage:
          /* Close "communicating with server" dbox (may not always be open...) */
          cts_ui_close_dbox (sm->plugin);
          switch (sm->command)
          {
            /* "Text" command */
            case cmd_TEXT:
              cts_statetable_text_SM (AC_Start, NULL, sm);
              state = S_Open_Text;
              rc = RC_Open_Pending;
              break;

            /* "APDU" and "APDUT" commands */
            case cmd_APDUT:
            case cmd_APDU:
              cts_statetable_apdu_SM (AC_Start, NULL, sm);
              state = S_Open_APDU;
              rc = RC_Open_Pending;
              break;

            /* "Verify" command */
            case cmd_VERIFY:
              cts_statetable_verify_SM (AC_Start, NULL, sm);
              state = S_Open_Verify;
              rc = RC_Open_Pending;
              break;

            /* "Error" command or "Close" command */
            case cmd_ERR:
            case cmd_CLOSE:
              cts_statetable_errorclose_SM (AC_Start, NULL, sm);
              state = S_Open_ErrorClose;
              rc = RC_Open_Pending;
              break;

            /* "Change" command */
            case cmd_CHANGE:
              cts_statetable_change_SM (AC_Start, NULL, sm);
              state = S_Open_Change;
              rc = RC_Open_Pending;
              break;

            /* "Basic" command */
            case cmd_BASIC:
              cts_statetable_basic_SM (AC_Start, NULL, sm);
              state = S_Open_Basic;
              rc = RC_Open_Pending;
              break;

            default:
              /* Any other server message in this state is illegal */
              /* Free the server message */
              cts_server_message_destroy (sm);
              rc = RC_Open_Error;
              state = S_Open_Idle;
          }
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Open_Pending;
          break;

        case AC_Cancel:
          rc = RC_Open_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Open_Error;
          state = S_Open_Idle;
      }
      break;

    /* STATE - We're executing a "Text" command */
    case S_Open_Text:
    {
      cts_statetable_result_text result;
      result = cts_statetable_text_SM (action_code, bm, sm);
      switch (result)
      {
        case RC_Text_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Pending;
          break;

        case RC_Text_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_Text_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_Basic_CancelDialogue:
          rc = RC_Open_CancelDialogue;
          break;

        case RC_Text_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_Text_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing an "APDU" command */
    case S_Open_APDU:
    {
      cts_statetable_result_apdu result;
      result = cts_statetable_apdu_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_APDU_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Pending;
          break;

        case RC_APDU_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_APDU_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_APDU_CancelDialogue:
          rc = RC_Open_CancelDialogue;
          break;

        case RC_APDU_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_APDU_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing a "Verify" command */
    case S_Open_Verify:
    {
      cts_statetable_result_verify result;
      result = cts_statetable_verify_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_Verify_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Pending;
          break;

        case RC_Verify_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_Verify_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_Verify_CancelDialogue:
          rc = RC_Open_CancelDialogue;
          break;

        case RC_Verify_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_Verify_Terminated:
          state = S_Open_Idle;
          rc = RC_Open_Terminated;
          break;

        case RC_Verify_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing a "Close" command or an "Error" command */
    case S_Open_ErrorClose:
    {
      cts_statetable_result_errorclose result;
      result = cts_statetable_errorclose_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_ErrorClose_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Closed;
          break;

        case RC_ErrorClose_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_ErrorClose_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_ErrorClose_CancelDialogue:
          rc = RC_Open_CancelDialogue;
          break;

        case RC_ErrorClose_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_ErrorClose_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing a "Change" command */
    case S_Open_Change:
    {
      cts_statetable_result_change result;
      result = cts_statetable_change_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_Change_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Pending;
          break;

        case RC_Change_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_Change_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_Change_CancelDialogue:
          rc = RC_Open_CancelDialogue;
          break;

        case RC_Change_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_Change_Terminated:
          state = S_Open_Idle;
          rc = RC_Open_Terminated;
          break;

        case RC_Change_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing a "Basic" command */
    case S_Open_Basic:
    {
      cts_statetable_result_basic result;
      result = cts_statetable_basic_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_Basic_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Closed;
          break;

        case RC_Basic_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_Basic_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_Basic_CancelDialogue:
          rc = RC_Open_CancelDialogue;
          break;

        case RC_Basic_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_Basic_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* INVALID STATE */
    default:
      /* Error */
      state = S_Open_Idle;
      rc = RC_Open_Error;
  }

#ifdef DEBUGLIB
  if (last_state != state)
  {
    dprintf (("StateMachine", "SM> Open - Changed state from %d to %d\n", last_state, state));
    last_state = state;
  }
#endif

  return rc;
}


/* State machine which handles all states of the plugin when it is running, but not yet open */
static cts_statetable_result_started cts_statetable_started_SM (cts_statetable_action action_code,
                                                                cts_browser_message *bm,
                                                                cts_server_message *sm)
{
  cts_statetable_result_started rc;
  const cts_command_parameter *param;
  int num;

  static cts_statetable_states_started state = S_Started_Idle;
  static cts_server_message* open_message = NULL;
  static cts_sc_slot_id card_number = cts_sc__general_info;

#ifdef DEBUGLIB
  static cts_statetable_states_started last_state = S_Started_Idle;
  last_state = state;
#endif

  if (action_code == AC_Start)
  {
    dprintf (("StateMachine", "SM> Started - Initialising (moving to Idle state)\n"));
    state = S_Started_Idle;
    return RC_Started_Pending;
  }

  dprintf (("StateMachine", "SM> Started - State = %d\n", state));

  switch (state)
  {
    /* STATE - Plugin started, but idle */
    case S_Started_Idle:
      switch (action_code)
      {
        /* It's a server message ... */
        case AC_ServerMessage:
          dprintf (("StateMachine", "SM> Started - Received server message, command = \"%d\"\n", sm->command));
          /* Close "communicating with server" dbox (may not always be open...) */
          cts_ui_close_dbox (sm->plugin);
          switch (sm->command)
          {
            /* Open command */
            case cmd_OPEN:
              /* Open "Accessing smartcard" dialogue (code 01-02) */
              dprintf (("StateMachine", "SM> Started - Received \"Open\" command.\n"));
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
              open_message = sm;
              /* Extract the port number */
              param = cts_command_parameter_lookup_by_tag (sm, tag_PORT);
              num = atoi (param->value);
              switch (num)
              {
                case 1:
                  card_number = cts_sc_slot1;
                  state = S_Started_OpeningCard;
                  rc = RC_Started_Pending;
                  break;
                case 2:
                  card_number = cts_sc_slot2;
                  state = S_Started_OpeningCard;
                  rc = RC_Started_Pending;
                  break;
                default:
                  /* Any other card number is illegal */
                  /* Free the server message */
                  cts_server_message_destroy (sm);
                  state = S_Started_Idle;
                  rc = RC_Started_Error;
              }
              break;

            /* Error command */
            case cmd_ERR:
              dprintf (("StateMachine", "SM> Started - Received \"Err\" command, display error webpage\n"));
              /* Display error webpage */
              cts_statetable_aux_sendresult_error (sm);
              /* Free the server message */
              cts_server_message_destroy (sm);
              state = S_Started_Idle;
              rc = RC_Started_Stopped;
              break;

            default:
              /* Any other server message in this state is illegal */
              /* Free the server message */
              cts_server_message_destroy (sm);
              state = S_Started_Idle;
              rc = RC_Started_Error;
          }
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Started_Pending;
          break;

        case AC_Cancel:
          rc = RC_Started_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Started_Idle;
          rc = RC_Started_Error;
      }
      break;

    /* STATE - Opening card */
    case S_Started_OpeningCard:
      switch (action_code)
      {
#ifdef CANCELACTION_ALLOWED
        /* It's a browser message ... */
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "Cancel" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_CANCEL))
            {
              /* Open cancel confirm dbox (code 05) */
              cts_ui_open_dbox (bm->plugin, NULL, ui_code_05);
              rc = RC_Started_CancelDialogue;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Started_Error;
              state = S_Started_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Started_Error;
            state = S_Started_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "open" command message */
          cts_server_message_destroy (open_message);
          open_message = NULL;
          break;
#endif
        case AC_Continue:
        {
          cts_sc_type type;
          cts_sc_status status = cts_sc_open (card_number, &type);

          switch (status)
          {
            case cts_sc_status_COMPLETE:
              dprintf (("StateMachine", "SM> Started - Smart card open operation complete\n"));
              /* Remove "accessing smart card dbox */
              cts_ui_close_dbox (bm->plugin);
              /* Open "communicating with server" dbox (code 01-1) */
              cts_ui_open_dbox (bm->plugin, NULL, ui_code_01_1);
              /* Send result */
              cts_statetable_aux_sendresult_open (open_message, "00");
              /* Free the "open" command message */
              cts_server_message_destroy (open_message);
              open_message = NULL;
              state = S_Started_Open;
              rc = RC_Started_Pending;
              break;

            case cts_sc_status_INPROGRESS:
              dprintf (("StateMachine", "SM> Started - Smart card open operation in progress\n"));
              rc = RC_Started_Pending;
              break;

            case cts_sc_status_FAILED:
            {
              cts_sc_sctrans_errors err = cts_sc_get_last_error (NULL);
              if (err == SCI_E_BADCARD)
              {
                dprintf (("StateMachine", "SM> Started - Smart card open operation failed: bad card\n"));
                /* Closedown smartcard software (hopefully) */
                cts_sc_close ();
                /* Open error dbox (code 03) */
                cts_ui_open_dbox (bm->plugin, NULL, ui_code_03);
                state = S_Started_Idle;
                rc = RC_Started_ErrorDialogue;
                /* Free the "open" command message */
                cts_server_message_destroy (open_message);
                open_message = NULL;
              }
              else if (err == SCI_E_OUT)
              {
                dprintf (("StateMachine", "SM> Started - Smart card open operation failed: no card\n"));
                /* Open "insert IC card" dbox -- TODO */
                /*cts_ui_open_dbox (bm->plugin, NULL, ui_code_xx);*/
                state = S_Started_RequestCardDialogue;
                rc = RC_Started_Pending;
              }
              else
              {
                dprintf (("StateMachine", "SM> Started - Smart card open operation failed: other error\n"));
                state = S_Started_Idle;
                rc = RC_Started_Error;
                /* Free the "open" command message */
                cts_server_message_destroy (open_message);
                open_message = NULL;
              }
              break;
            }

            default:
              state = S_Started_Idle;
              rc = RC_Started_Error;
              /* Free the "open" command message */
              cts_server_message_destroy (open_message);
              open_message = NULL;
          }
          break;
        }

        case AC_Cancel:
          /* Closedown smartcard software (hopefully) */
          cts_sc_close ();
          /* Remove "accessing smart card dbox */
          cts_ui_close_dbox (open_message->plugin);
          state = S_Started_Idle;
          rc = RC_Started_Cancelled;
          /* Free the "open" command message */
          cts_server_message_destroy (open_message);
          open_message = NULL;
          break;

        default:
          /* Any other action in this state is illegal */
          /* Free the "open" command message */
          cts_server_message_destroy (open_message);
          open_message = NULL;
          rc = RC_Started_Error;
          state = S_Started_Idle;
      }
      break;

    /* STATE - Smart card open */
    case S_Started_Open:
    {
      cts_statetable_result_open result;
      result = cts_statetable_open_SM (action_code, bm, sm);
      switch (result)
      {
        /* The close command and been executed in the open SM,
           we've been closed */
        case RC_Open_Closed:
          state = S_Started_Idle;
          rc = RC_Started_Pending;
          break;

        /* There's been an error in the open SM, and an error dbox
           has been opened */
        case RC_Open_ErrorDialogue:
          state = S_Started_Idle;
          rc = RC_Started_ErrorDialogue;
          break;

        case RC_Open_CancelDialogue:
          rc = RC_Started_CancelDialogue;
          break;

        /* Open SM is working, continue in this state */
        case RC_Open_Pending:
          /* Continue */
          rc = RC_Started_Pending;
          break;

        /* The user's cancelled an operation in the open SM */
        case RC_Open_Cancelled:
          state = S_Started_Idle;
          rc = RC_Started_Cancelled;
          break;

        /* The system has been "terminated", should return to idle asap */
        case RC_Open_Terminated:
          state = S_Started_Idle;
          rc = RC_Started_Stopped;
          break;

        /* Unrecoverable error in Open SM, or invalid return code */
        case RC_Open_Error:
        default:
          /* Error */
          rc = RC_Started_Error;
          state = S_Started_Idle;
      }
      break;
    }

    /* STATE - Waiting for "request card" dialogue box to complete */
    case S_Started_RequestCardDialogue:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close dbox */
          cts_ui_close_dbox (bm->plugin);

          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "OK" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_OK))
            {
              /* Re-open "Accessing smartcard" dialogue (code 01-02) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
              state = S_Started_OpeningCard;
              rc = RC_Started_Pending;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              /* Closedown smartcard software (hopefully) */
              cts_sc_close ();
              rc = RC_Started_Error;
              state = S_Started_Idle;
              /* Free the "open" command message */
               cts_server_message_destroy (open_message);
              open_message = NULL;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            /* Closedown smartcard software (hopefully) */
            cts_sc_close ();
            rc = RC_Started_Error;
            state = S_Started_Idle;
            /* Free the "open" command message */
            cts_server_message_destroy (open_message);
            open_message = NULL;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Started_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Started_Idle;
          rc = RC_Started_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      rc = RC_Started_Error;
      state = S_Started_Idle;
  }

#ifdef DEBUGLIB
  if (last_state != state)
  {
    dprintf (("StateMachine", "SM> Started - Changed state from %d to %d\n", last_state, state));
    last_state = state;
  }
#endif

  return rc;
}


/* The base state machine */
static cts_statetable_result_base cts_statetable_base_SM (cts_statetable_action action_code,
                                                          cts_browser_message *bm,
                                                          cts_server_message *sm)
{
  cts_statetable_result_base rc;
  const cts_browser_parameter *browser_param;

  static cts_statetable_states_base state = S_Base_Idle;
  static cts_statetable_states_base cancel_state;

#ifdef DEBUGLIB
  static cts_statetable_states_base last_state = S_Base_Idle;
  last_state = state;
#endif

  if (action_code == AC_Start)
  {
    dprintf (("StateMachine", "SM> Base - Initialising (moving to Idle state)\n"));
    state = S_Base_Idle;
    return RC_Base_Pending;
  }

  switch (state)
  {
    /* STATE - Plugin idle */
    case S_Base_Idle:
      switch (action_code)
      {
        /* It's a browser message ... */
        case AC_BrowserMessage:
          /* Check it's a start message */
          if (strcmp (bm->command, "start") == 0)
          {
            /* Extract the command */
            browser_param = cts_browser_parameter_lookup_by_tag (bm, btag_CMD);
            if (browser_param == NULL)
            {
              /* Error, there is no "Cmd" parameter */
              rc = RC_Base_Error;
            }
            else
            {
              if (strcmp (browser_param->value, "Start") == 0)
              {
                /* It's the "Start" command */
                if (start_message != NULL)
                  cts_browser_message_destroy (start_message);
                start_message = bm;
                /* Check for ampersands in user data */
                if (cts_statemachine_aux_checkamps (bm) == 0)
                {
                  /* There are ampersands in the user data ... */
                  /* Open error dbox (code 11) */
                  cts_ui_open_dbox (bm->plugin, NULL, ui_code_11);
                  rc = RC_Base_Pending;
                  state = S_Base_ErrorDialogue;
                }
                else
                {
                  dprintf (("StateMachine", "SM> Base - Moving to \"Started\" state\n"));
                  cts_statetable_started_SM (AC_Start, NULL, NULL);
                  /* Open "communicating with server" dbox (code 01-1) */
                  cts_ui_open_dbox (bm->plugin, NULL, ui_code_01_1);
                  /* Send start result */
                  cts_statetable_aux_sendresult_start (bm);
                  state = S_Base_Started;
                  rc = RC_Base_Pending;
                }
              }
              else
              {
                /* Any other command in this message is illegal */
                rc = RC_Base_Error;
              }
            }
          }
          else
          {
            /* Any other browser message is illegal in this state */
            rc = RC_Base_Error;
          }
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Base_Pending;
          break;

        default:
          /* Any other action is illegal in this state */
          rc = RC_Base_Error;
      }
      break;

    /* STATE - State machine started */
    case S_Base_Started:
    {
      cts_statetable_result_started result;

      result = cts_statetable_started_SM (action_code, bm, sm);
      switch (result)
      {
        /* Started SM has completed, bringing the plugin back to idle */
        case RC_Started_Stopped:
          state = S_Base_Idle;
          rc = RC_Base_Pending;
          break;

        /* Started SM has opened an error dialogue, wait for it to close...*/
        case RC_Started_ErrorDialogue:
          state = S_Base_ErrorDialogue;
          rc = RC_Base_Pending;
          break;

        /* We're paused, waiting for result of cancel dialogue */
        case RC_Started_CancelDialogue:
          cancel_state = state;
          state = S_Base_CancelDialogue;
          rc = RC_Base_Pending;
          break;

        /* Started SM is working, continue in this state */
        case RC_Started_Pending:
          /* Continue */
          rc = RC_Base_Pending;
          break;

        /* Unrecoverable error in Started SM, or unknown return code */
        case RC_Started_Error:
        default:
          /* Error */
          rc = RC_Base_Error;
          state = S_Base_Idle;
      }
      break;
    }

    /* STATE - Waiting for error dialogue to complete */
    case S_Base_ErrorDialogue:
      switch (action_code)
      {
        /* It's a browser message ... */
        case AC_BrowserMessage:
          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "OK" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_OK))
            {
              state = S_Base_Idle;
              rc = RC_Base_Pending;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Base_Error;
              state = S_Base_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Base_Error;
            state = S_Base_Idle;
          }
          /* Close error dbox */
          cts_ui_close_dbox (bm->plugin);
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Base_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Base_Error;
          state = S_Base_Idle;
      }
      break;

#ifdef CANCELACTION_ALLOWED
    /* STATE - Waiting for user to decide whether they want to cancel */
    case S_Base_CancelDialogue:
      switch (action_code)
      {
        /* It's a browser message */
        case AC_BrowserMessage:
          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "OK" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_OK))
            {
              switch (cancel_state)
              {
                case S_Base_Started:
                  /* Call "cancel" on the "started" state machine, so we can clean up
                     after ourselves */
                  cts_statetable_started_SM (AC_Cancel, NULL, NULL);
                  /* Close cancel decision dbox */
                  cts_ui_close_dbox (bm->plugin);
                  /* Open "Cancelled" dbox (code 06) */
                  cts_ui_open_dbox (bm->plugin, NULL, ui_code_06);
                  state = S_Base_CancelledDialogue;
                  rc = RC_Base_Pending;
                  break;

                default:
                  /* Shouldn't have a cancel dialogue in any other state than "Started" */
                  rc = RC_Base_Error;
                  state = S_Base_Idle;
              }
            }
            /* Check for "Cancel" action */
            else if (cts_browser_parameter_lookup_by_tag (bm, btag_CANCEL))
            {
              /* Continue operation that's been paused */
              /* Close cancel decision dbox */
              cts_ui_close_dbox (bm->plugin);
              state = cancel_state;
              rc = RC_Base_Pending;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Base_Error;
              state = S_Base_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Base_Error;
            state = S_Base_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around for the user */
          rc = RC_Base_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Base_Error;
          state = S_Base_Idle;
      }
      break;

    /* STATE - Waiting for user to click OK in "cancelled" dialogue */
    case S_Base_CancelledDialogue:
      switch (action_code)
      {
        /* It's a browser message */
        case AC_BrowserMessage:
          /* Check it's a dbox message */
          if (strcmp (bm->command, "dbox") == 0)
          {
            /* Check for "OK" action */
            if (cts_browser_parameter_lookup_by_tag (bm, btag_OK))
            {
              /* Close cancelled dbox */
              cts_ui_close_dbox (bm->plugin);
              state = S_Base_Idle;
              rc = RC_Base_Pending;
            }
            else
            {
              /* Any other dbox action in this state is illegal */
              rc = RC_Base_Error;
              state = S_Base_Idle;
            }
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Base_Error;
            state = S_Base_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around for the user */
          rc = RC_Base_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Base_Error;
          state = S_Base_Idle;
      }
      break;
#endif
    /* INVALID STATE */
    default:
      /* Error, invalid state */
      rc = RC_Base_Error;
      state = S_Base_Idle;
  }

#ifdef DEBUGLIB
  if (last_state != state)
  {
    dprintf (("StateMachine", "SM> Base - Changed state from %d to %d\n", last_state, state));
    last_state = state;
  }
#endif

  return rc;
}


/* Null poll handler */
static int cts_statetable_null_handler (int event_code, WimpPollBlock *event, IdBlock *id_block,
                                        void *handle)
{
  cts_statetable_result_base result;

  /* Run the state machine */
  result = cts_statetable_base_SM (AC_Continue, NULL, NULL);
  if (result == RC_Base_Error)
    dprintf (("StateMachine", "SM> *********** FATAL ERROR IN STATE MACHINE\n"));

  return 0;
  NOT_USED(event_code);
  NOT_USED(event);
  NOT_USED(id_block);
  NOT_USED(handle);
}


/**********************/
/* Exported functions */


/* Browser message dispatcher */
browser_dispatch_result cts_statetable_dispatch_browser_message (cts_browser_message *m)
{
  cts_browser_parameter *p;

  (void) m;

  dprintf(("StateMachine_1", "\ncts_statetable_dispatch_browser_message:\n"));
  dprintf(("StateMachine_1", "  command is %s\n", m->command));
  for (p = m->param_list; p; p=p->next)
  {
    dprintf (("StateMachine_1", "    Parameter: `%s' = `%s'\n", p->name, p->value));
  }
  dprintf (("StateMachine_1", "end of message\n\n"));

  /* Kick the state machine */
  cts_statetable_base_SM (AC_BrowserMessage, m, NULL);

  /* Returning bdr_KEEP tells the caller not to free the message structure */
  return bdr_KEEP;
}


/* Server message dispatcher */
browser_dispatch_result cts_statetable_dispatch_server_message (cts_server_message *m)
{
  cts_command_parameter *p = &m->params[0];
  size_t index;

  (void) m;
  (void) p;

  dprintf (("StateMachine_1", "\ncts_statetable_dispatch_server_message:\n"));
  for (index = 0; index < m->param_count; ++index)
  {
    dprintf(("StateMachine_1", "    Parameter: `%s' = `%s'\n",
             p[index].name, p[index].value));
  }
  dprintf(("StateMachine_1", "end of message\n\n"));
  dprintf(("StateMachine_1", "The command is `%s'\n",
           ctscmd_strings[m->command]));

  /* Kick the state machine */
  cts_statetable_base_SM (AC_ServerMessage, NULL, m);

  /* Returning bdr_KEEP tells the caller not to free the message structure */
  return bdr_KEEP;
}


/* Initialisation function for state machine system */
_kernel_oserror *cts_statetable_init (void)
{
  _kernel_oserror *er;

  /* Register a null poll handler, to keep the state machine ticking along */
  er = event_register_wimp_handler (0, Wimp_ENull, cts_statetable_null_handler, NULL);
  if (er)
    return er;

  /* Initialise the base state machine */
  cts_statetable_base_SM (AC_Start, NULL, NULL);

  return NULL;
}
