/*
 *  CTS (statetable.c)
 *
 * Copyright (C) Element 14 Ltd. 1999
 *
 */

/* ANSI includes */
#include <stdio.h>
#include <string.h>

/* System includes */
#include "toolbox.h"
#include "event.h"
#include "wimplib.h"
#include "DebugLib/DebugLib.h"

/* Local includes */
#include "ctstypes.h"
#include "ctsbrowser.h"
#include "ctsintern.h"
#include "ctsui.h"
#include "utils.h"
#include "statetable.h"


/*****************************/
/* Local auxiliary functions */


/*********************************/
/* Local state machine functions */


/* State machine for "Basic" command handling */
static cts_statetable_result_basic cts_statetable_basic_SM (cts_statetable_action action_code,
                                                            cts_browser_message *bm,
                                                            cts_server_message *sm)
{
  cts_statetable_result_basic rc;

  static cts_statetable_states_basic state = S_Basic_Idle;
  static cts_server_message *basic_message = NULL;

  if (action_code == AC_Start)
  {
    /* Open "accessing smart card" dialogue (code 01-2) */
    cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
    basic_message = sm;
    state = S_Basic_Closing;
    return RC_Basic_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_Basic_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action, but handle it anyway */
          rc = RC_Basic_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Basic_Error;
      }
      break;

    /* STATE - Working on "Close" command */
    case S_Basic_Closing:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Open cancel confirm dbox (code 05) */
            cts_ui_open_dbox (bm->plugin, NULL, ui_code_05);
            rc = RC_Basic_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Basic_Error;
            state = S_Basic_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "basic" command message */
          cts_server_message_destroy (basic_message);
          basic_message = NULL;
          break;

        case AC_Continue:
          if (/*close complete*/1)
          {
            /* Close "accessing smart card" dbox */
            cts_ui_close_dbox (basic_message->plugin);
            /* Open "communicating with server" dbox (code 01-1) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
            /* Send result of command (with attached data from "basic_message" -- TODO */
            /* Free the "basic" command message */
            cts_server_message_destroy (basic_message);
            basic_message = NULL;
            state = S_Basic_Idle;
            rc = RC_Basic_Finished;
          }
          else
          {
            /* Wait around */
            rc = RC_Basic_Pending;
          }
          break;

        case AC_Cancel:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (basic_message->plugin);
          /* Free the "basic" command message */
          cts_server_message_destroy (basic_message);
          basic_message = NULL;
          state = S_Basic_Idle;
          rc = RC_Basic_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Basic_Idle;
          rc = RC_Basic_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_Basic_Idle;
      rc = RC_Basic_Error;
      break;
  }

  return rc;
}


/* State machine for "Close" command handling */
static cts_statetable_result_change cts_statetable_change_SM (cts_statetable_action action_code,
                                                              cts_browser_message *bm,
                                                              cts_server_message *sm)
{
  cts_statetable_result_change rc;

  static cts_statetable_states_change state = S_Change_Idle;
  static cts_server_message *change_message = NULL;

  if (action_code == AC_Start)
  {
    /* Open "password change" dbox (code 22) */
    cts_ui_open_dbox (sm->plugin, NULL, ui_code_22);
    change_message = sm;
    state = S_Change_WaitingOKCancel;
    return RC_Change_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_Change_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action but handle it anyway */
          rc = RC_Change_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Change_Error;
      }
      break;

    /* STATE - Waiting for password change dbox OK or Cancel click */
    case S_Change_WaitingOKCancel:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close "password change" dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "passwordchangedbox_ok") == 0)
          {
            /* Compare new passwords, plus check length and type -- TODO */
            if (/*wrong*/0)
            {
              /* Open "confirmation entered wrongly" dbox (code 26) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_26);
              state = S_Change_RetryPasswordDialogue;
              rc = RC_Change_Pending;
            }
            else
            {
              /* Open "accessing smart card" dbox (code 01-2)  */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
              /* Send "verify" command -- TODO */
              state = S_Change_ReceiveVerifyResponse;
              rc = RC_Change_Pending;
            }
          }
          else if (strcmp (bm->command, "passwordchangedbox_cancel") == 0)
          {
            /* Free the "change" command message */
            cts_server_message_destroy (change_message);
            change_message = NULL;
            rc = RC_Change_Terminated;
            state = S_Change_Idle;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Change_Error;
            state = S_Change_Idle;
            /* Free the "change" command message */
            cts_server_message_destroy (change_message);
            change_message = NULL;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Change_Pending;
          break;

        case AC_Cancel:
          /* Close "password change" dbox */
          cts_ui_close_dbox (change_message->plugin);
          /* Free the "change" command message */
          cts_server_message_destroy (change_message);
          change_message = NULL;
          state = S_Change_Idle;
          rc = RC_Change_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Change_Idle;
          rc = RC_Change_Error;
      }
      break;


    /* STATE - Waiting for response to "verify" command */
    case S_Change_ReceiveVerifyResponse:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Open cancel confirm dbox (code 05) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_05);
            rc = RC_Change_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Change_Error;
            state = S_Change_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "change" command message */
          cts_server_message_destroy (change_message);
          change_message = NULL;
          break;

        case AC_Continue:
          /* poll for response completion -- TODO */
          if (/*finished*/1)
          {
            if (/*key lock, or command error*/0)
            {
              ui_code_identifiers code;
              int err_num = 0;

              /* Close "accessing smart card" dbox */
              cts_ui_close_dbox (change_message->plugin);
              if (/*password locked*/0)
                code = ui_code_23;
              else if (/*password wrong and locked*/0)
                code = ui_code_24;
              else
              {
                /* smart card error */
                err_num = /* from smart card ..*/1;
                code = ui_code_30;
              }
              /* Open error message dbox (code 23,24,30) */
              cts_ui_open_dbox (sm->plugin, NULL, code, err_num);
              state = S_Change_SpecialErrorDialogue;
              rc =  RC_Change_Pending;
            }
            else if (/*communication error*/0)
            {
              /* Close "accessing smart card" dbox */
              cts_ui_close_dbox (change_message->plugin);
              /* Open error message dbox (code 03) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_03);
              /* Free the "change" command message */
              cts_server_message_destroy (change_message);
              change_message = NULL;
              rc =  RC_Change_ErrorDialogue;
              state = S_Change_Idle;
            }
            else if (/*key comparison failed*/0)
            {
              /* Open error message dbox (code 25) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_25, /* num of tries left -- TODO */999);
              state = S_Change_RetryPasswordDialogue;
              rc =  RC_Change_Pending;
            }
            else
            {
              /* Finished */
              /* Send "change" command -- TODO */
              state = S_Change_ReceiveChangeResponse;
              rc = RC_Change_Pending;
            }
          }
          else
          {
            rc = RC_Change_Pending;
          }
          break;

        case AC_Cancel:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (change_message->plugin);
          /* Free the "change" command message */
          cts_server_message_destroy (change_message);
          change_message = NULL;
          state = S_Change_Idle;
          rc = RC_Change_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Change_Idle;
          rc = RC_Change_Error;
      }
      break;

    /* STATE - Waiting for response to smart card "ChangeKey" command */
    case S_Change_ReceiveChangeResponse:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Open cancel confirm dbox (code 05) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_05);
            rc = RC_Change_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Change_Error;
            state = S_Change_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "change" command message */
          cts_server_message_destroy (change_message);
          change_message = NULL;
          break;

        case AC_Continue:
          /* poll for response completion -- TODO */
          if (/*finished*/1)
          {
            /* Close "accessing smart card" dbox */
            cts_ui_close_dbox (change_message->plugin);

            if (/*command error -- TODO */0)
            {
              ui_code_identifiers code;
              int err_num = 0

              if (/*password locked -- TODO */0)
                code = ui_code_23;
              else if (/*password wrong and locked -- TODO*/0)
                code = ui_code_24;
              else
              {
                /* Smart card error */
                err_num = /* from smart card -- TODO*/1;
                code = ui_code_30;
              }
              /* Open error message dbox (code 23,24,30) */
              cts_ui_open_dbox (sm->plugin, NULL, code, err_num);
              state = S_Change_SpecialErrorDialogue;
              rc =  RC_Change_Pending;
            }
            else if (/*communication error -- TODO */0)
            {
              /* Open error message dbox (code 03) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_03);
              /* Free the "change" command message */
              cts_server_message_destroy (change_message);
              change_message = NULL;
              rc =  RC_Change_ErrorDialogue;
              state = S_Change_Idle;
            }
            else if (/*key change succeeded -- TODO */1)
            {
              /* Finished */
              /* Open "communicating with server" dbox (code 01-1) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
              /* send response (includes change result) -- TODO */
              /* Free the "change" command message */
              cts_server_message_destroy (change_message);
              change_message = NULL;
              state = S_Change_Idle;
              rc = RC_Change_Finished;
            }
          }
          else
          {
            rc = RC_Change_Pending;
          }
          break;

        case AC_Cancel:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (change_message->plugin);
          /* Free the "change" command message */
          cts_server_message_destroy (change_message);
          change_message = NULL;
          state = S_Change_Idle;
          rc = RC_Change_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Change_Idle;
          rc = RC_Change_Error;
      }
      break;

    /* STATE - Waiting for special error dialogue box to complete */
    case S_Change_SpecialErrorDialogue:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "changespecialdbox_ok") == 0)
          {
            /* Open "communicating with server" dbox (code 01-1) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
            /* send response (includes change result) -- TODO */
            state = S_Change_Idle;
            rc = RC_Change_Finished;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Change_Error;
            state = S_Change_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "change" command message */
          cts_server_message_destroy (change_message);
          change_message = NULL;
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Change_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Change_Idle;
          rc = RC_Change_Error;
      }
      break;

    /* STATE - Waiting for retry password dialogue box to complete */
    case S_Change_RetryPasswordDialogue:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "retrypassworddbox_ok") == 0)
          {
            /* Re-open "password change" dbox (code 22) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_22);
            state = S_Change_WaitingOKCancel;
            rc = RC_Change_Pending;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Change_Error;
            state = S_Change_Idle;
            /* Free the "change" command message */
            cts_server_message_destroy (change_message);
            change_message = NULL;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Change_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Change_Idle;
          rc = RC_Change_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_Change_Idle;
      rc = RC_Change_Error;
      break;
  }

  return rc;
}


/* State machine for "Error" and "Close" command handling */
static cts_statetable_result_errorclose cts_statetable_errorclose_SM (cts_statetable_action action_code,
                                                            cts_browser_message *bm,
                                                            cts_server_message *sm)
{
  cts_statetable_result_errorclose rc;

  static cts_statetable_states_errorclose state = S_ErrorClose_Idle;
  static cts_server_message *errorclose_message = NULL;

  if (action_code == AC_Start)
  {
    /* Open "accessing smart card" dialogue (code 01-2) */
    cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
    /* send close command -- TODO */
    errorclose_message = sm;
    state = S_ErrorClose_Closing;
    return RC_ErrorClose_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_ErrorClose_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action, but handle it anyway */
          rc = RC_ErrorClose_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_ErrorClose_Error;
      }
      break;

    /* STATE - Working on "Close" command */
    case S_ErrorClose_Closing:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Open cancel confirm dbox (code 05) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_05);
            rc = RC_ErrorClose_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_ErrorClose_Error;
            state = S_ErrorClose_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "errorclose" command message */
          cts_server_message_destroy (errorclose_message);
          errorclose_message = NULL;
          break;

        case AC_Continue:
          if (/*close complete*/1)
          {
            /* Close "accessing smart card" dbox */
            cts_ui_close_dbox (bm->plugin);
            /* Open "communicating with server" dbox (code 01-1) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
            /* send result of command (with attached data from "errorclose_message" -- TODO */
            /* Free the "errorclose" command message */
            cts_server_message_destroy (errorclose_message);
            errorclose_message = NULL;
            state = S_ErrorClose_Idle;
            rc = RC_ErrorClose_Finished;
          }
          else
          {
            /* Wait around */
            rc = RC_ErrorClose_Pending;
          }
          break;

        case AC_Cancel:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);
          /* Free the "errorclose" command message */
          cts_server_message_destroy (errorclose_message);
          errorclose_message = NULL;
          state = S_ErrorClose_Idle;
          rc = RC_ErrorClose_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_ErrorClose_Idle;
          rc = RC_ErrorClose_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_ErrorClose_Idle;
      rc = RC_ErrorClose_Error;
      break;
  }

  return rc;
}


/* State machine for "Verify" command handling */
static cts_statetable_result_verify cts_statetable_verify_SM (cts_statetable_action action_code,
                                                              cts_browser_message *bm,
                                                              cts_server_message *sm)
{
  cts_statetable_result_verify rc;

  static cts_statetable_states_verify state = S_Verify_Idle;
  static cts_server_message *verify_message = NULL;

  if (action_code == AC_Start)
  {
    /* Open "enter password" dbox (code 21) */
    cts_ui_open_dbox (sm->plugin, NULL, ui_code_21);
    verify_message = sm;
    state = S_Verify_WaitingOKCancel;
    return RC_Verify_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_Verify_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action but handle it anyway */
          rc = RC_Verify_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Verify_Error;
      }
      break;

    /* STATE - Waiting for password window OK or Cancel click */
    case S_Verify_WaitingOKCancel:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close password dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "passworddbox_ok") == 0)
          {
            /* Open "Accessing smartcard" dialogue (code 01-02) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
            /* send "verify" command -- TODO */
            state = S_Verify_ReceiveResponse;
            rc = RC_Verify_Pending;
          }
          else if (strcmp (bm->command, "passworddbox_cancel") == 0)
          {
            /* Free the "verify" command message */
            cts_server_message_destroy (verify_message);
            verify_message = NULL;
            rc = RC_Verify_Terminated;
            state = S_Verify_Idle;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Verify_Error;
            state = S_Verify_Idle;
            /* Free the "verify" command message */
            cts_server_message_destroy (verify_message);
            verify_message = NULL;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Verify_Pending;
          break;

        case AC_Cancel:
          /* Close password dbox */
          cts_ui_close_dbox (bm->plugin);
          /* Free the "verify" command message */
          cts_server_message_destroy (verify_message);
          verify_message = NULL;
          state = S_Verify_Idle;
          rc = RC_Verify_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Verify_Idle;
          rc = RC_Verify_Error;
      }
      break;



    /* STATE - Waiting for response to smart card command */
    case S_Verify_ReceiveResponse:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {

            /* Open cancel confirm dbox (code 05) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_05);
            rc = RC_Verify_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Verify_Error;
            state = S_Verify_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "verify" command message */
          cts_server_message_destroy (verify_message);
          verify_message = NULL;
          break;

        case AC_Continue:
          /* poll for response completion -- TODO */
          if (/*finished*/1)
          {
            /* Close "accessing smart card" dbox */
            cts_ui_close_dbox (verify_message->plugin);

            if (/*key lock, or command error*/0)
            {

              if (/*password locked -- TODO */0)
                code = ui_code_23;
              else if (/*password wrong and locked -- TODO*/0)
                code = ui_code_24;
              else
              {
                /* Smart card error */
                err_num = /* from smart card -- TODO*/1;
                code = ui_code_30;
              }
              /* Open error message dbox (code 23,24,30) */
              cts_ui_open_dbox (sm->plugin, NULL, code, err_num);
              state = S_Verify_SpecialErrorDialogue;
              rc =  RC_Verify_Pending;
            }
            else if (/*communication error*/0)
            {
              ui_code_identifiers code;
              int err_num = 0

              /* Open error message dbox (code 03) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_03);
              /* Free the "verify" command message */
              cts_server_message_destroy (verify_message);
              verify_message = NULL;
              rc =  RC_Verify_ErrorDialogue;
              state = S_Verify_Idle;
            }
            else if (/*key comparison failed*/0)
            {
              /* Open error message dbox (code 25) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_25, /* num of tries left -- TODO */999);
              state = S_Verify_RetryPasswordDialogue;
              rc =  RC_Verify_Pending;
            }
            else
            {
              /* Finished */
              /* Open "communicating with server" dbox (code 01-1) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
              /* send response (includes verify result) -- TODO */
              /* Free the "verify" command message */
              cts_server_message_destroy (verify_message);
              verify_message = NULL;
              state = S_Verify_Idle;
              rc = RC_Verify_Finished;
            }
          }
          else
          {
            rc = RC_Verify_Pending;
          }
          break;

      default:
        /* Any other action in this state is illegal */
        state = S_Verify_Idle;
        rc = RC_Verify_Error;
      }
      break;

    /* STATE - Waiting for special error dialogue box to complete */
    case S_Verify_SpecialErrorDialogue:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "verifyspecialdbox_ok") == 0)
          {
            /* Open "communicating with server" dbox (code 01-1) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
            /* send response (includes verify result) -- TODO */
            state = S_Verify_Idle;
            rc = RC_Verify_Finished;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Verify_Error;
            state = S_Verify_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "verify" command message */
          cts_server_message_destroy (verify_message);
          verify_message = NULL;
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Verify_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Verify_Idle;
          rc = RC_Verify_Error;
      }
      break;

    /* STATE - Waiting for retry password dialogue box to complete */
    case S_Verify_RetryPasswordDialogue:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "retrypassworddbox_ok") == 0)
          {
            /* Re-open "enter password" dbox (code 21) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_21);
            state = S_Verify_WaitingOKCancel;
            rc = RC_Verify_Pending;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Verify_Error;
            state = S_Verify_Idle;
            /* Free the "verify" command message */
            cts_server_message_destroy (verify_message);
            verify_message = NULL;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Verify_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Verify_Idle;
          rc = RC_Verify_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_Verify_Idle;
      rc = RC_Verify_Error;
      break;
  }

  return rc;
}


/* State machine for "APDU" and "APDUT" command handling */
static cts_statetable_result_apdu cts_statetable_apdu_SM (cts_statetable_action action_code,
                                                          cts_browser_message *bm,
                                                          cts_server_message *sm)
{
  cts_statetable_result_apdu rc;

  static cts_statetable_states_apdu state = S_APDU_Idle;
  static cts_server_message *apdu_message = NULL;

  if (action_code == AC_Start)
  {
    /* Open "accessing smart card" dialogue */
    cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
    /* Send first command -- TODO */
    apdu_message = sm;
    state = S_APDU_ReceiveResponse;
    return RC_APDU_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_APDU_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action but handle it anyway */
          rc = RC_APDU_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_APDU_Error;
      }
      break;

    /* STATE - Waiting for response to smart card command */
    case S_APDU_ReceiveResponse:
      switch (action_code)
      {
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Open cancel confirm dbox (code 05) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_05);
            rc = RC_APDU_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_APDU_Error;
            state = S_APDU_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "apdu" command message */
          cts_server_message_destroy (apdu_message);
          apdu_message = NULL;
          break;

        case AC_Continue:
          /* poll for response completion -- TODO */
          if (/*finished*/0)
          {
            if (/*error*/0)
            {
              /* Close "accessing smart card" dbox */
              cts_ui_close_dbox (apdu_message->plugin);
              /* Open error message dbox (code 03) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_03);
              /* Free the "apdu" command message */
              cts_server_message_destroy (apdu_message);
              apdu_message = NULL;
              rc =  RC_APDU_ErrorDialogue;
              state = S_APDU_Idle;
            }
            else
            {
              /* need to make up list of responses for each command -- TODO */
              if (/*more commands*/0)
              {
                /* send next command -- TODO */
                rc = RC_APDU_Pending;
              }
              else
              {
                /* finished */
                /* Close "accessing smart card" dbox */
                cts_ui_close_dbox (apdu_message->plugin);
                /* Open "communicating with server" dbox (code 01-1) */
                cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
                /* send response (includes text for APDUT case) -- TODO */
                /* Free the "apdu" command message */
                cts_server_message_destroy (apdu_message);
                apdu_message = NULL;
                state = S_APDU_Idle;
                rc = RC_APDU_Finished;
              }
            }
          }
          else
          {
            rc = RC_APDU_Pending;
          }
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_APDU_Idle;
          rc = RC_APDU_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_APDU_Idle;
      rc = RC_APDU_Error;
      break;
  }

  return rc;
}


/* State machine for "Text" command handling */
static cts_statetable_result_text cts_statetable_text_SM (cts_statetable_action action_code,
                                                          cts_browser_message *bm,
                                                          cts_server_message *sm)
{
  cts_statetable_result_text rc;

  static cts_statetable_states_text state = S_Text_Idle;
  static cts_server_message *text_message = NULL;

  if (action_code == AC_Start)
  {
    text_message = sm;
    state = S_Text_Working;
    return RC_Text_Pending;
  }

  switch (state)
  {
    /* STATE - Idle */
    case S_Text_Idle:
      switch (action_code)
      {
        case AC_Cancel:
          /* Slightly invalid action, but handle it anyway */
          rc = RC_Text_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Text_Error;
      }
      break;

    /* STATE - Working on "Text" command */
    case S_Text_Working:
      switch (action_code)
      {
        case AC_BrowserMessage:
          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Open cancel confirm dbox (code 05) */
            cts_ui_open_dbox (sm->plugin, NULL, ui_code_05);
            rc = RC_Text_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Text_Error;
            state = S_Text_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "text" command message */
          cts_server_message_destroy (text_message);
          break;

        case AC_Continue:
          /* Open "communicating with server" dbox (code 01-1) */
          cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_1);
          /* send result of "text" command -- TODO */
          /* Free the "text" command message */
          cts_server_message_destroy (text_message);
          state = S_Text_Idle;
          rc = RC_Text_Finished;

        case AC_Cancel:
          /* Free the "text" command message */
          cts_server_message_destroy (text_message);
          state = S_Text_Idle;
          rc = RC_Text_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Text_Idle;
          rc = RC_Text_Error;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error */
      state = S_Text_Idle;
      rc = RC_Text_Error;
      break;
  }

  return rc;
}


/* State machine which handles all states of the plugin running and being open */
static cts_statetable_result_open cts_statetable_open_SM (cts_statetable_action action_code,
                                                          cts_browser_message *bm,
                                                          cts_server_message *sm)
{
  cts_statetable_result_open rc;

  static cts_statetable_states_open state = S_Open_Idle;

  if (action_code == AC_Start)
  {
    state = S_Open_Idle;
    return RC_Open_Pending;
  }

  switch (state)
  {
    /* STATE - Card open, but idle */
    case S_Open_Idle:
      switch (action_code)
      {
        /* It's a server message ... */
        case AC_ServerMessage:
          /* Close "communicating with server" dbox (may not always be open...) */
          cts_ui_close_dbox (sm->plugin);
          switch (sm->command)
          {
            /* "Text" command */
            case cmd_TEXT:
              cts_statetable_text_SM (AC_Start, NULL, sm);
              state = S_Open_Text;
              rc = RC_Open_Pending;
              break;

            /* "APDU" and "APDUT" commands */
            case cmd_ADPUT:
            case cmd_APDU:
              cts_statetable_apdu_SM (AC_Start, NULL, sm);
              state = S_Open_APDU;
              rc = RC_Open_Pending;
              break;

            /* "Verify" command */
            case cmd_VERIFY:
              cts_statetable_verify_SM (AC_Start, NULL, sm);
              state = S_Open_Verify;
              rc = RC_Open_Pending;
              break;

            /* "Error" command or "Close" command */
            case cmd_ERR:
            case cmd_CLOSE:
              cts_statetable_errorclose_SM (AC_Start, NULL, sm);
              state = S_Open_ErrorClose;
              rc = RC_Open_Pending;
              break;

            /* "Change" command */
            case cmd_CHANGE:
              cts_statetable_change_SM (AC_Start, NULL, sm);
              state = S_Open_Change;
              rc = RC_Open_Pending;
              break;

            /* "Basic" command */
            case cmd_BASIC:
              cts_statetable_basic_SM (AC_Start, NULL, sm);
              state = S_Open_Basic;
              rc = RC_Open_Pending;
              break;

            default:
              /* Any other server message in this state is illegal */
              /* Free the server message */
              cts_server_message_destroy (sm);
              rc = RC_Open_Error;
              state = S_Open_Idle;
          }
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Open_Pending;
          break;

        case AC_Cancel:
          rc = RC_Open_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Open_Error;
          state = S_Open_Idle;
      }
      break;

    /* STATE - We're executing a "Text" command */
    case S_Open_Text:
    {
      cts_statetable_result_text result;
      result = cts_statetable_text_SM (action_code, bm, sm);
      switch (result)
      {
        case RC_Text_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Pending;
          break;

        case RC_Text_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_Text_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_Text_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_Text_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing an "APDU" command */
    case S_Open_APDU:
    {
      cts_statetable_result_apdu result;
      result = cts_statetable_apdu_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_APDU_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Pending;
          break;

        case RC_APDU_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_APDU_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_APDU_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_APDU_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing a "Verify" command */
    case S_Open_Verify:
    {
      cts_statetable_result_verify result;
      result = cts_statetable_verify_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_Verify_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Pending;
          break;

        case RC_Verify_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_Verify_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_Verify_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_Verify_Terminated:
          state = S_Open_Idle;
          rc = RC_Open_Terminated;
          break;

        case RC_Verify_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing a "Close" command or an "Error" command */
    case S_Open_ErrorClose:
    {
      cts_statetable_result_errorclose result;
      result = cts_statetable_errorclose_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_ErrorClose_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Closed;
          break;

        case RC_ErrorClose_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_ErrorClose_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_ErrorClose_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_ErrorClose_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing a "Change" command */
    case S_Open_Change:
    {
      cts_statetable_result_change result;
      result = cts_statetable_change_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_Change_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Pending;
          break;

        case RC_Change_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_Change_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_Change_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_Change_Terminated:
          state = S_Open_Idle;
          rc = RC_Open_Terminated;
          break;

        case RC_Change_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* STATE - We're executing a "Basic" command */
    case S_Open_Basic:
    {
      cts_statetable_result_basic result;
      result = cts_statetable_basic_SM (action_code, bm, sm);

      switch (result)
      {
        case RC_Basic_Finished:
          state = S_Open_Idle;
          rc = RC_Open_Closed;
          break;

        case RC_Basic_Pending:
          rc = RC_Open_Pending;
          break;

        case RC_Basic_ErrorDialogue:
          state = S_Open_Idle;
          rc = RC_Open_ErrorDialogue;
          break;

        case RC_Basic_Cancelled:
          state = S_Open_Idle;
          rc = RC_Open_Cancelled;
          break;

        case RC_Basic_Error:
        default:
          state = S_Open_Idle;
          rc = RC_Open_Error;
          break;
      }
      break;
    }

    /* INVALID STATE */
    default:
      /* Error */
      state = S_Open_Idle;
      rc = RC_Open_Error;
  }

  return rc;
}


/* State machine which handles all states of the plugin when it is running, but not yet open */
static cts_statetable_result_started cts_statetable_started_SM (cts_statetable_action action_code,
                                                                cts_browser_message *bm,
                                                                cts_server_message *sm)
{
  cts_statetable_result_started rc;

  static cts_statetable_states_started state = S_Started_Idle;
  static cts_server_message* open_message = NULL;

  if (action_code == AC_Start)
  {
    dprintf (("StateMachine", "SM> Started - Initialising\n"));
    state = S_Started_Idle;
    return RC_Started_Pending;
  }

  dprintf (("StateMachine", "SM> Started - State = %d\n", state));

  switch (state)
  {
    /* STATE - Plugin started, but idle */
    case S_Started_Idle:
      switch (action_code)
      {
        /* It's a server message ... */
        case AC_ServerMessage:
          /* Close "communicating with server" dbox (may not always be open...) */
          cts_ui_close_dbox (sm->plugin);
          switch (sm->command)
          {
            /* Open command */
            case cmd_OPEN:
              /* Open "Accessing smartcard" dialogue (code 01-02) */
              cts_ui_open_dbox (sm->plugin, NULL, ui_code_01_2);
              open_message = sm;
              state = S_Started_OpeningCard;
              rc = RC_Started_Pending;
              break;

            /* Error command */
            case cmd_ERR:
              /* display error webpage -- TODO */
              /* Free the server message */
              cts_server_message_destroy (sm);
              state = S_Started_Idle;
              rc = RC_Started_Stopped;
              break;

            default:
              /* Any other server message in this state is illegal */
              /* Free the server message */
              cts_server_message_destroy (sm);
              state = S_Started_Idle;
              rc = RC_Started_Error;
          }
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Started_Pending;
          break;

        case AC_Cancel:
          rc = RC_Started_Cancelled;
          break;

        default:
          /* Any other action in this state is illegal */
          state = S_Started_Idle;
          rc = RC_Started_Error;
      }
      break;

    /* STATE - Opening card */
    case S_Started_OpeningCard:
      switch (action_code)
      {
        /* It's a browser message ... */
        case AC_BrowserMessage:
          /* Close "accessing smart card" dbox */
          cts_ui_close_dbox (bm->plugin);

          if (strcmp (bm->command, "processingdbox_cancel") == 0)
          {
            /* Open cancel confirm dbox (code 05) */
            cts_ui_open_dbox (bm->plugin, NULL, ui_code_05);
            rc = RC_Started_CancelDialogue;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Started_Error;
            state = S_Started_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          /* Free the "open" command message */
          cts_server_message_destroy (open_message);
          open_message = NULL;
          break;

        case AC_Continue:
          /* Check card status, and send S block if
             necessary, blocking in this state -- TODO */
          if (/*error*/0)
          {
            /* Open error dbox (code 03) */
            cts_ui_open_dbox (bm->plugin, NULL, ui_code_03);
            state = S_Started_Idle;
            rc = RC_Started_ErrorDialogue;
          }
          else
          {
            /* Remove "accessing smart card dbox */
            cts_ui_close_dbox (bm->plugin);
            /* Open "communicating with server" dbox (code 01-1) */
            cts_ui_open_dbox (bm->plugin, NULL, ui_code_01_1);
            /* Send result -- TODO */
            state = S_Started_Open;
            rc = RC_Started_Pending;
          }
          /* Free the "open" command message */
          cts_server_message_destroy (open_message);
          open_message = NULL;
          break;

        case AC_Cancel:
          /* Remove "accessing smart card dbox */
          cts_ui_close_dbox (open_message->plugin);
          state = S_Started_Idle;
          rc = RC_Started_Cancelled;
          /* Free the "open" command message */
          cts_server_message_destroy (open_message);
          open_message = NULL;
          break;

        default:
          /* Any other action in this state is illegal */
          /* Free the "open" command message */
          cts_server_message_destroy (open_message);
          open_message = NULL;
          rc = RC_Started_Error;
          state = S_Started_Idle;
      }
      break;

    /* STATE - Smart card open */
    case S_Started_Open:
    {
      cts_statetable_result_open result;
      result = cts_statetable_open_SM (action_code, bm, sm);
      switch (result)
      {
        /* The close command and been executed in the open SM,
           we've been closed */
        case RC_Open_Closed:
          state = S_Started_Idle;
          rc = RC_Started_Pending;
          break;

        /* There's been an error in the open SM, and a erro dbox
           has been opened */
        case RC_Open_ErrorDialogue:
          state = S_Started_Idle;
          rc = RC_Started_ErrorDialogue;
          break;

        /* Open SM is working, continue in this state */
        case RC_Open_Pending:
          /* Continue */
          rc = RC_Started_Pending;
          break;

        /* The user's cancelled an operation in the open SM */
        case RC_Open_Cancelled:
          state = S_Started_Idle;
          rc = RC_Started_Cancelled;
          break;

        /* The system has been "terminated", should return to idle asap */
        case RC_Open_Terminated:
          state = S_Started_Idle;
          rc = RC_Started_Stopped;
          break;

        /* Unrecoverable error in Open SM, or invalid return code */
        case RC_Open_Error:
        default:
          /* Error */
          rc = RC_Started_Error;
          state = S_Started_Idle;
      }
      break;
    }

    /* INVALID STATE */
    default:
      /* Error */
      rc = RC_Started_Error;
      state = S_Started_Idle;
  }

  return rc;
}


/* The base state machine */
static cts_statetable_result_base cts_statetable_base_SM (cts_statetable_action action_code,
                                                          cts_browser_message *bm,
                                                          cts_server_message *sm)
{
  cts_statetable_result_base rc;

  static cts_statetable_states_base state = S_Base_Idle;
  static cts_statetable_states_base cancel_state;

  if (action_code == AC_Start)
  {
    dprintf (("StateMachine", "SM> Base - Initialising\n"));
    state = S_Base_Idle;
    return RC_Base_Pending;
  }

  dprintf (("StateMachine", "SM> Base - State = %d\n", state));

  switch (state)
  {
    /* STATE - Plugin idle */
    case S_Base_Idle:
      switch (action_code)
      {
        /* It's a browser message ... */
        case AC_BrowserMessage:
          /* .. and it's the start command */
          if (strcmp (bm->command, "start") == 0)
          {
            /* check for &s in user data ..  -- TODO */
            if (/*&s in user data*/0)
            {
              /* Open error dbox (code 03) */
              cts_ui_open_dbox (bm->plugin, NULL, ui_code_03);
              rc = RC_Base_Pending;
              state = S_Base_ErrorDialogue;
            }
            else
            {
              cts_statetable_started_SM (AC_Start, NULL, NULL);
              /* Open "communicating with server" dbox (code 01-1) */
              cts_ui_open_dbox (bm->plugin, NULL, ui_code_01_1);
              /* send start result ... -- TODO */
              state = S_Base_Started;
              rc = RC_Base_Pending;
            }
          }
          else
          {
            /* Any other browser message is illegal in this state */
            rc = RC_Base_Error;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Base_Pending;
          break;

        default:
          /* Any other action is illegal in this state */
          rc = RC_Base_Error;
      }
      break;

    /* STATE - State machine started */
    case S_Base_Started:
    {
      cts_statetable_result_started result;

      result = cts_statetable_started_SM (action_code, bm, sm);
      switch (result)
      {
        /* Started SM has completed, bringing the plugin back to idle */
        case RC_Started_Stopped:
          state = S_Base_Idle;
          rc = RC_Base_Pending;
          break;

        /* Started SM has opened an error dialogue, wait for it to close...*/
        case RC_Started_ErrorDialogue:
          state = S_Base_ErrorDialogue;
          rc = RC_Base_Pending;
          break;

        /* We're paused, waiting for result of cancel dialogue */
        case RC_Started_CancelDialogue:
          cancel_state = state;
          state = S_Base_CancelDialogue;
          rc = RC_Base_Pending;
          break;

        /* Started SM is working, continue in this state */
        case RC_Started_Pending:
          /* Continue */
          rc = RC_Base_Pending;
          break;

        /* Unrecoverable error in Started SM, or unknown return code */
        case RC_Started_Error:
        default:
          /* Error */
          rc = RC_Base_Error;
          state = S_Base_Idle;
      }
      break;
    }

    /* STATE - Waiting for error dialogue to complete */
    case S_Base_ErrorDialogue:
      switch (action_code)
      {
        /* It's a browser message ... */
        case AC_BrowserMessage:
          if (strcmp (bm->command, "errordbox_ok") == 0)
          {
            state = S_Base_Idle;
            rc = RC_Base_Pending;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Base_Error;
            state = S_Base_Idle;
          }
          /* Close error dbox */
          cts_ui_close_dbox (bm->plugin);
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around */
          rc = RC_Base_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Base_Error;
          state = S_Base_Idle;
      }
      break;

    /* STATE - Waiting for user to decide whether they want to cancel */
    case S_Base_CancelDialogue:
      switch (action_code)
      {
        /* It's a browser message */
        case AC_BrowserMessage:
          if (strcmp (bm->command, "canceldbox_ok") == 0)
          {
            switch (cancel_state)
            {
              case S_Base_Started:
                /* Call "cancel" on the "started" state machine, so we can clean up
                   after ourselves */
                cts_statetable_started_SM (AC_Cancel, NULL, NULL);
                /* Close cancel decision dbox */
                cts_ui_close_dbox (bm->plugin);
                /* Open "Cancelled" dbox (code 06) */
                cts_ui_open_dbox (bm->plugin, NULL, ui_code_06);
                state = S_Base_CancelledDialogue;
                rc = RC_Base_Pending;
                break;

              default:
                /* Shouldn't have a cancel dialogue in any other state than "Started" */
                rc = RC_Base_Error;
                state = S_Base_Idle;
            }
          }
          else if (strcmp (bm->command, "canceldbox_cancel") == 0)
          {
            /* Continue operation that's been paused */
            /* Close cancel decision dbox */
            cts_ui_close_dbox (bm->plugin);
            state = cancel_state;
            rc = RC_Base_Pending;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Base_Error;
            state = S_Base_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around for the user */
          rc = RC_Base_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Base_Error;
          state = S_Base_Idle;
      }
      break;

    /* STATE - Waiting for user to click OK in "cancelled" dialogue */
    case S_Base_CancelledDialogue:
      switch (action_code)
      {
        /* It's a browser message */
        case AC_BrowserMessage:
          if (strcmp (bm->command, "cancelleddbox_ok") == 0)
          {
            /* Close cancelled dbox */
            cts_ui_close_dbox (bm->plugin);
            state = S_Base_Idle;
            rc = RC_Base_Pending;
          }
          else
          {
            /* Any other browser message in this state is illegal */
            rc = RC_Base_Error;
            state = S_Base_Idle;
          }
          /* Free the browser message */
          cts_browser_message_destroy (bm);
          break;

        case AC_Continue:
          /* Wait around for the user */
          rc = RC_Base_Pending;
          break;

        default:
          /* Any other action in this state is illegal */
          rc = RC_Base_Error;
          state = S_Base_Idle;
      }
      break;

    /* INVALID STATE */
    default:
      /* Error, invalid state */
      rc = RC_Base_Error;
      state = S_Base_Idle;
  }

  return rc;
}


/* Null poll handler */
static int cts_statetable_null_handler (int event_code, WimpPollBlock *event, IdBlock *id_block,
                                        void *handle)
{
  /* Run the state machine */
  cts_statetable_base_SM (AC_Continue, NULL, NULL);

  return 0;
  NOT_USED(event_code);
  NOT_USED(event);
  NOT_USED(id_block);
  NOT_USED(handle);
}


/**********************/
/* Exported functions */


/* Browser message dispatcher */
browser_dispatch_result cts_statetable_dispatch_browser_message (cts_browser_message *m)
{
  cts_browser_parameter *p;

  (void) m;

  dprintf(("statetable_1", "\ncts_statetable_dispatch_browser_message:\n"));
  dprintf(("statetable_1", "  command is %s\n", m->command));
  for (p = m->param_list; p; p=p->next)
  {
    dprintf (("statetable_1", "    Parameter: `%s' = `%s'\n", p->name, p->value));
  }
  dprintf (("statetable_1", "end of message\n\n"));

  /* Kick the state machine */
  cts_statetable_base_SM (AC_BrowserMessage, m, NULL);

  /* Returning bdr_KEEP tells the caller not to free the message structure */
  return bdr_KEEP;
}


/* Server message dispatcher */
browser_dispatch_result cts_statetable_dispatch_server_message (cts_server_message *m)
{
  cts_command_parameter *p = &m->params[0];
  size_t index;

  (void) m;
  (void) p;

  dprintf (("statetable_1", "\ncts_statetable_dispatch_server_message:\n"));
  for (index = 0; index < m->param_count; ++index)
  {
    dprintf(("statetable_1", "    Parameter: `%s' = `%s'\n",
             p[index].name, p[index].value));
  }
  dprintf(("statetable_1", "end of message\n\n"));
  dprintf(("statetable_1", "The command is `%s'\n",
           ctscmd_strings[m->command]));

  /* Kick the state machine */
  cts_statetable_base_SM (AC_ServerMessage, NULL, m);

  /* Returning bdr_KEEP tells the caller not to free the message structure */
  return bdr_KEEP;
}


/* Initialisation function for state machine system */
_kernel_oserror *cts_statetable_init (void)
{
  _kernel_oserror *er;

  /* Register a null poll handler, to keep the state machine ticking along */
  er = event_register_wimp_handler (0, Wimp_ENull, cts_statetable_null_handler, NULL);
  if (er)
    return er;

  /* Initialise the base state machine */
  cts_statetable_base_SM (AC_Start, NULL, NULL);

  return NULL;
}
