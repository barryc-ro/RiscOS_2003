/*
 *  CTS (smartcard.c)
 *
 * Copyright (C) Element 14 Ltd. 1999
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include "kernel.h"
#include "swis.h"
#include "ctstypes.h"
#include "ctsbrowser.h"
#include "ctsintern.h"
#include "ctsutils.h"
#include "smartcard.h"

#include "SCTransport.h"

#include "DebugLib/DebugLib.h"

/* NOTE: The SWI interface specification for SCTrans was designed by Rich Buckley.
 * Because of this, errors are not returned properly, but are returned in R0 with
 * V clear!  Thus we have to check that the return value of _swix was zero (could
 * be a system error, y'see) and if so, then we check R0.
 */

static int card_handle;
static cts_sc_slot_id slot_id;
static int actual_card_handle;

static int card_handle_valid = 0;

/* Homer says calling the SWI call in SCTrans to get this information is flaky
 * and can mess the module up completely - so we'll cache it here.
 */
static struct {
        cts_sc_sctrans_errors	code;
        _kernel_oserror 	error_block;
} cts_last_error;

/* Pragma switches on _swix checking
 * NOTE: only input and output registers are supported.  _BLOCK is not supported
 * _RETURN is not supported.
 */
#pragma -v4
static cts_sc_status cts_swix(int swi_num, int regs, ...)
{
        _kernel_swi_regs r;
        _kernel_oserror *e, *ose;
        va_list ap;
        int rn;

        va_start(ap, regs);

        for (rn=0; rn<10; ++rn) {
                if (regs & (_IN(rn))) {
                        r.r[rn] = va_arg(ap, int);
                }
        }

	ose = e = _kernel_swi(swi_num, &r, &r);
	if (e == NULL) {
	        /* Now the buggering about to get around Rich Buckley's shit API */
	        e = (_kernel_oserror *) r.r[0];
	        if (e != NULL) {
	                cts_last_error.code = (cts_sc_sctrans_errors) e->errnum;
	        }
	}
	else {
	        cts_last_error.code = SCI_SUCCESS;
	}

        for (rn=0; rn<10; ++rn) {
                if (regs & (_OUT(rn))) {
                        *(va_arg(ap, int *)) = r.r[rn];
                }
        }

	va_end(ap);

	if (e != NULL) {
	        (void) memcpy(&cts_last_error.error_block, e, sizeof(cts_last_error));
	        if (ose == NULL && e->errnum == SCI_E_NODATA) {
	                return cts_sc_status_INPROGRESS;
	        }
	        return cts_sc_status_FAILED;
	}

	return cts_sc_status_COMPLETE;
}
#pragma -v0

enum {
        cts_sc_handle_SLOT2 = -2
};

cts_sc_sctrans_errors cts_sc_get_last_error(_kernel_oserror **e)
{
        if (e != NULL) {
                *e = &cts_last_error.error_block;
        }
	return cts_last_error.code;
}

cts_sc_status cts_sc_open(cts_sc_slot_id card_number,
	cts_slot_status *status, cts_sc_type *type)
{
        static cts_sc_slot_id opened = -1;
        cts_sc_status status;

	if (card_number != opened) {
	        status = cts_swix(SCTransport_Open, _INR(0,1), 0, &card_handle);
        	if (status == cts_sc_status_COMPLETE) {
                        opened = card_number;
                }
                else {
		        /* Daft API - even on errors the handle is allocated! */
		        (void) _swix(SCTransport_Close, _IN(0), card_handle);
                        opened = -1;
                        return status;
                }
	}

        card_handle_valid = 1;
        slot_id = card_number;
        actual_card_handle = slot_id;
        if (slot_id == cts_sc_slot2) {
                actual_card_handle = cts_sc_handle_SLOT2;
        }

        status = cts_swix(SCTransport_SlotInfo, _IN(0)|_OUTR(1,2),
        	card_number, status, type);

	if (status == cts_sc_status_COMPLETE) {
	        switch (*status) {
	                case cts_slot_status_CARD:
	                        if (*type != cts_sc_type_REASONA) {
	                                /* Perhaps send the s-block */
	                        }
	                        break;
	                case cts_slot_status_READING_ATR:
	                        status = cts_sc_status_INPROGRESS;
	                        break;
	                case cts_slot_status_EMPTY:
	                        cts_last_error.code = SCI_E_OUT;
	                        status = cts_sc_status_FAILED;
	                        break;
	                case cts_slot_status_UNIDENTIFIABLE:
	                        cts_last_error.code = SCI_E_BADCARD;
	                        status = cts_sc_status_FAILED;
	                        break;
	        }
	}

        return status;
}

cts_sc_status cts_sc_close(void)
{
        if (card_handle_valid) {
		card_handle_valid = 0;
        	return cts_swix(SCTransport_Close, _IN(0), card_handle);
        }

        return cts_sc_status_COMPLETE;
}

/* APDU buffer on exit is identical to APDU buffer on entry, but is temporarily
 * transformed back into the binary representation of the data for passing on
 * to the SCTrans module.  It is assumed that the APDU is an I-block!
 */
cts_sc_status cts_sc_send_apdu(
	const void *apdu,
	size_t apdu_len)
{
        register char *const apdu_header = (void *) apdu;
        register char *const apdu_data   = apdu_header + 4;
        cts_sc_status res;

        apdu_len >>= 1;

	(void) cts_utils_binary_decode(apdu_header, apdu_header, apdu_len);

        res = cts_swix(SCTransport_IssueCommand, _INR(0,4), actual_card_handle,
        	apdu_header, apdu_len - (apdu_data - apdu_header), apdu_data, 0);

	(void) cts_utils_binary_encode(apdu_header, apdu_header, apdu_len);

	return res;
}

cts_sc_status cts_sc_read_data(
	void *buffer,
	size_t buffer_length,
	size_t *data_size,
	char *sw1sw2_response)
{
        size_t temporary;
        cts_sc_status res;

        if (data_size == NULL) {
                data_size = &temporary;
        }

        *data_size = buffer_length >> 1;

        res = cts_swix(SCTransport_ReadResponse, _INR(0,4), actual_card_handle,
        	buffer, buffer_length, data_size, sw1sw2_response);

	if (res == cts_sc_status_COMPLETE) {
	        if (buffer != NULL) {
		        cts_utils_binary_encode(buffer, buffer, *data_size);
	        }
	}

        *data_size <<= 1;

        return res;
}

void cts_sc_atexit(void)
{
        (void) cts_sc_close();
}
