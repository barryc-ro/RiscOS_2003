/*
 *  CTS (smartcard.c)
 *
 * Copyright (C) Element 14 Ltd. 1999
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h>
#include <signal.h>
#include "kernel.h"
#include "swis.h"
#include "ctstypes.h"
#include "ctsbrowser.h"
#include "ctsintern.h"
#include "ctsutils.h"
#include "smartcard.h"
#include "utils.h"

#include "SCTransport.h"
#include "SCInter.h"

#include "DebugLib/DebugLib.h"
#include "MemCheck:MemCheck.h"

/* NOTE: The SWI interface specification for SCTrans was designed by Rich Buckley.
 * Because of this, errors are not returned properly, but are returned in R0 with
 * V clear!  Thus we have to check that the return value of _swix was zero (could
 * be a system error, y'see) and if so, then we check R0.
 */

static int slot1_card_handle;
static cts_sc_slot_id slot_id;
static int actual_card_handle;

static int card_handle_valid = 0;
static int slot1_events_off = 0;

/* This value is updated by the pollword handler */
static int read_response_available = 0;

/* Homer says calling the SWI call in SCTrans to get this information is flaky
 * and can mess the module up completely - so we'll cache it here.
 * Stewart - please try and distinguish between RL and talkers. Ta. w.
 */
static struct {
        cts_sc_sctrans_errors   code;
        _kernel_oserror         error_block;
} cts_last_error;

/* Pragma switches on _swix checking
 * NOTE: only input and output registers are supported.  _BLOCK is not supported
 * _RETURN is not supported.
 */
#pragma -v4
static cts_sc_status cts_swix(int swi_num, int regs, ...)
{
        _kernel_swi_regs r;
        _kernel_oserror *e, *ose;
        va_list ap;
        int rn;

#ifdef DEBUGLIB
        { static char swi_name[256];
        int len;
        (void) _swix(OS_SWINumberToString, _INR(0,2)|_OUT(2), swi_num, swi_name,
                sizeof(swi_name), &len);
        dprintf(("cts_swix", "SWI %05x (%.*s)\n", swi_num, len, swi_name));
        }
#endif

        va_start(ap, regs);

        dprintf(("cts_swix", " In:\n"));

        for (rn=0; rn<10; ++rn) {
                if (regs & (_IN(rn))) {
                        r.r[rn] = va_arg(ap, int);
                        dprintf(("cts_swix", "  R%d = %8d (%08x)\n", rn, r.r[rn], r.r[rn]));
                }
        }

        cts_last_error.code = SCI_SUCCESS;
        ose = e = _kernel_swi(swi_num, &r, &r);
        if (e == NULL) {
                /* Now the buggering about to get around Rich Buckley's shit API */
                e = (_kernel_oserror *) r.r[0];
                if (e != NULL) {
                        if (r.r[0] < 0x100) {
                                static _kernel_oserror ebuf;
                                ebuf.errnum = r.r[0];
                                ebuf.errmess[0] = '\0';
                                e = &ebuf;
                        }
                        cts_last_error.code = (cts_sc_sctrans_errors) e->errnum;
                }
        }

        dprintf(("cts_swix", " Out:\n"));

        for (rn=0; rn<10; ++rn) {
                if (regs & (_OUT(rn))) {
                        *(va_arg(ap, int *)) = r.r[rn];
                        dprintf(("cts_swix", "  R%d = %8d (%08x)\n", rn, r.r[rn], r.r[rn]));
                }
        }

        va_end(ap);

        dprintf(("cts_swix", "Kernel error -> %p\n", ose));
        dprintf(("cts_swix", "SC error -> %p\n", e));

        if (e != NULL) {
                (void) memcpy(&cts_last_error.error_block, e, sizeof(cts_last_error));
                if (ose == NULL && e->errnum == SCI_E_NODATA) {
                        dprintf(("cts_swix", "SCI_E_NODATA -> INPROGRESS\n"));
                        return cts_sc_status_INPROGRESS;
                }
                return cts_sc_status_FAILED;
        }

        return cts_sc_status_COMPLETE;
}
#pragma -v0

enum {
        cts_sc_handle_SLOT2 = -2
};

cts_sc_sctrans_errors cts_sc_get_last_error(_kernel_oserror **e)
{
        if (e != NULL) {
                *e = &cts_last_error.error_block;
        }
        return cts_last_error.code;
}

cts_sc_status cts_sc_open(cts_sc_slot_id card_number,cts_sc_type *type)
{
        cts_sc_status status;
        cts_slot_status ret_status;
        size_t slot_count;
        _kernel_oserror *e;

        dprintf(("cts_sc", "Opening new card (slot id %d)\n", card_number));
//        card_handle_valid = 0;
        slot_id = card_number;

        if (slot_id == cts_sc_slot2) {
                dprintf(("cts_sc", "Slot 2\n"));
                actual_card_handle = cts_sc_handle_SLOT2;
        }
#ifdef ENABLE_SLOT1SHOPPING
        else if (slot_id == cts_sc_slot1)
        {
          dprintf(("cts_sc", "Slot 1\n"));
          actual_card_handle = slot1_card_handle;
          /** Also switch off slot1 events to SCInterface for the duration */
          _swix(SCInterface_Events, _IN(0)|_IN(1), 0, 1); /** Disable the event system **/
          slot1_events_off = 1;
        }
#endif
        e = _swix(SCTransport_SlotInfo, _IN(0)|_OUTR(0,2),
                card_number, &slot_count, &ret_status, type);
        if (e != NULL) {
                cts_last_error.code = SCI_SUCCESS;
                (void) memcpy(&cts_last_error.error_block, e, sizeof(*e));
                status = cts_sc_status_FAILED;
        }
        else {
                status = cts_sc_status_COMPLETE;
                dprintf(("cts_sc", "There are %d slot%s\n", slot_count,
                        slot_count == 1 ? "" : "s"));
        }

        if (status == cts_sc_status_COMPLETE) {
                dprintf(("cts_sc", "res_status = %d\n", ret_status));
                switch (ret_status) {
                        case cts_slot_status_CARD:
                                dprintf(("cts_sc", "card type = %d\n", *type));
                                if (*type != cts_sc_type_REASONA) {
                                        /* Perhaps send the s-block */
                                }
                                log_send_msg(log_SC_OPENOK);
                                break;
                        case cts_slot_status_READING_ATR:
                                status = cts_sc_status_INPROGRESS;
                                break;
                        case cts_slot_status_EMPTY:
                                cts_last_error.code = SCI_E_OUT;
                                status = cts_sc_status_FAILED;
                                break;
                        case cts_slot_status_UNIDENTIFIABLE:
                                cts_last_error.code = SCI_E_BADCARD;
                                status = cts_sc_status_FAILED;
                                break;
                }
        }

        return status;
}

cts_sc_status cts_sc_close(void)
{
        dprintf(("cts_sc", "cts_sc_close entered\n"));
#ifdef ENABLE_SLOT1SHOPPING
        if (slot_id == cts_sc_slot1)
        {
          /** We've been talking to slot1, so we'll need to tell SCInterface it's ok now. **/
          dprintf(("cts_sc", "Re-enabling the SCInterface event system\n"));
          _swix(SCInterface_Events, _IN(0)|_IN(1), 0, 0); /** Re-enable the event system **/
          dprintf(("cts_sc", "Re-enabled the SCInterface event system\n"));
          slot1_events_off = 0;
        }
#endif
        if (card_handle_valid) {
                card_handle_valid = 0;
                dprintf(("cts_sc", "Closing open stream\n"));
                _swix(SCTransport_EndTrans, _IN(0), slot1_card_handle);
                return cts_swix(SCTransport_Close, _IN(0), slot1_card_handle);
        }

        return cts_sc_status_COMPLETE;
}

/* APDU buffer on exit is identical to APDU buffer on entry, but is temporarily
 * transformed back into the binary representation of the data for passing on
 * to the SCTrans module.  It is assumed that the APDU is an I-block!
 */
cts_sc_status cts_sc_send_apdu(
        const void *apdu,
        const size_t apdu_len)
{
        register char *const apdu_header = (void *) apdu;
        register char *apdu_data   = apdu_header + 4;
        cts_sc_status res;
        size_t Le = 0;
        size_t len;
        const unsigned int bit31 = 0x80000000u;

        read_response_available = 0;

        dprintf(("cts_sc", "Sending APDU ... (length = %d)\n", apdu_len >> 1));

        (void) cts_utils_binary_decode(apdu_header, apdu_header, apdu_len);

        ddumpbuf("cts_sc", apdu_header, apdu_len >> 1, 0);

        /* There are seven possible cases ...
         *
         * 1)  Hdr  Lc  Data  Le
         * 2)  Hdr  Lc  Data
         * 3)  Hdr  Le
         * 4)  Hdr
         * 5)  Hdr  00  LcHi LcLo Data LeHi LeLo
         * 6)  Hdr  00  LcHi LcLo Data
         * 7)  Hdr  00  LeHi LeLo
         */

        /* len is the amount of data excluding the 4 bytes header */
        len = (apdu_len >> 1) - (apdu_data - apdu_header);
        if (len == 0) {
                /* case 4 */
                Le = 0;
                dprintf (("cts_sc", "APDU contains Hdr only\n"));
        }
        else if (len == 1) {
                /* case 3 */
                Le = apdu_data[--len] ^ bit31;
                dprintf (("cts_sc", "APDU contains Hdr Le(%#x)\n", Le));
        }
        else if (apdu_data[0] == '\0' && len < 3) {
                /* Sanity check only */
                dprintf (("cts_sc", "Invalid APDU\n"));
                cts_last_error.code = SCI_E_API;
                return cts_sc_status_FAILED;
        }
        else if (apdu_data[0] == '\0') {
                /* case 5, 6 or 7 */
                unsigned char *lenp = (unsigned char *) apdu_data + 1;
                int val = (lenp[0] << 8) + lenp[1];
                len -= 3;
                apdu_data += 3;
                if (len == 0) {
                        /* case 7 */
                        Le = val ^ bit31;
                        len = bit31;
                }
                else if (len == val) {
                        /* case 6 */
                        Le = 0;
                        len ^= bit31;
                }
                else {
                        /* case 5 */
                        lenp += len;
                        Le = ((lenp[0] << 8) + lenp[1]) ^ bit31;
                        len = (len - 2) ^ bit31;
                }
        }
        else if (apdu_data[0] == len - 1) {
                /* case 2 */
                Le = 0;
                ++apdu_data;
                --len;
                dprintf (("cts_sc", "APDU contains Hdr Lc(%#x) Data\n", len));
        }
        else {
                /* case 1 */
                Le = apdu_data[--len] ^ bit31;
                ++apdu_data;
                --len;
                dprintf (("cts_sc", "APDU contains Hdr Lc(%#x) Data Le(%#x)\n", len, Le));
        }

        log_send_msg(log_SC_COMMAND,
                apdu_header[0], apdu_header[1],
                apdu_header[2], apdu_header[3],
                len & 0xFFFF, Le);

        dprintf (("cts_sc", "APDU Header:\n"));
        ddumpbuf ("cts_sc", apdu_header, 4, 0);
        dprintf (("cts_sc", "Lc = %#x\nAPDU Data:\n", len));
        ddumpbuf ("cts_sc", apdu_data, len & 0xFFFF, 0);
        dprintf (("cts_sc", "Le = %#x\n", Le));

        res = cts_swix(SCTransport_IssueCommand, _INR(0,4), actual_card_handle,
                apdu_header, len, apdu_data, Le);

        (void) cts_utils_binary_encode(apdu_header, apdu_header, apdu_len >> 1);

        return res;
}

cts_sc_status cts_sc_read_data(
        void *buffer,
        size_t buffer_length,
        size_t *data_size,
        char *sw1sw2_response)
{
        static char inbuffer[4096 * 2];
        size_t temporary;
        cts_sc_status res;
        char sw[2];

        if (!read_response_available) {
                return cts_sc_status_INPROGRESS;
        }
        else
        {
                if (cts_last_error.code == SCI_E_SYS)
                {
                      dprintf(("cts_sc_2", "cts_last_error.code == SCI_E_SYS, return error to state machine\n"));
                      return cts_sc_status_SYS_ERROR;
                }
                else if (cts_last_error.code != SCI_SUCCESS)
                {
                      dprintf(("cts_sc_2", "cts_last_error.code != SCI_SUCCESS (is %d)\n",
                              cts_last_error.code));
                      return cts_sc_status_FAILED;
                }
        }

        if (data_size == NULL) {
                data_size = &temporary;
        }

        if (sw1sw2_response == NULL) {
                sw1sw2_response = sw;
        }

        if (buffer == NULL) {
                *data_size = sizeof(inbuffer) >> 1;
        }
        else {
                *data_size = buffer_length >> 1;
        }

        res = cts_swix(SCTransport_ReadResponse, _INR(0,4), actual_card_handle,
                inbuffer, sizeof(inbuffer)>>1, data_size, sw1sw2_response);

        dprintf(("cts_sc", "[SW1:SW2] == [%02x:%02x]; data_size = %d; res=%d; err=%d\n",
                sw1sw2_response[0],
                sw1sw2_response[1],
                *data_size,
                res,
                cts_last_error.code));

        if (*data_size == -1) {
                cts_last_error.code = SCI_SUCCESS;
                res = cts_sc_status_COMPLETE;
                if (buffer != NULL) {
                        dprintf(("cts_sc", "S-block response ([%02x])\n", sw1sw2_response[0]));
                        cts_utils_binary_encode(buffer, sw1sw2_response, 2 + *data_size);
                }
        }
        else if (res == cts_sc_status_COMPLETE) {
                if (buffer != NULL) {
                        dprintf(("cts_sc", "Adding [%02x:%02x] at offset %d in buffer\n",
                                sw1sw2_response[0],
                                sw1sw2_response[1],
                                *data_size));
                        memcpy(&inbuffer[*data_size], sw1sw2_response, 2);
                        cts_utils_binary_encode(buffer, inbuffer, 2 + *data_size);
                        dprintf(("cts_sc", "Encoded response is %.*s\n",
                                (2 + *data_size) << 1, buffer));
                        log_send_msg(log_SC_RESPONSE,
                                sw1sw2_response[0],
                                sw1sw2_response[1],
                                *data_size);

                }
        }
        else if (cts_last_error.code == SCI_E_TRUNC && buffer == NULL) {
                dprintf(("cts_sc", "Truncated error - changing to success\n"));
                cts_last_error.code = SCI_SUCCESS;
                res = cts_sc_status_COMPLETE;
        }

        *data_size = (*data_size + 2) << 1;

        return res;
}

void cts_sc_atexit(void)
{
        (void) cts_sc_close();
}


void *cts_sc_construct_pin_op_apdu(
        cts_sc_pin_op op,
        const char *pin,
        size_t pin_length,
        int keyid,
        size_t *apdu_length)
{
        struct {
                unsigned char cla;
                unsigned char ins;
                unsigned char p1;
                unsigned char p2;
        } sc_header;
        char *result;
        size_t total_length;

        dprintf(("cts_sc", "constructing pin op\n"));

        total_length = sizeof(sc_header) + sizeof(unsigned char) + pin_length;
        dprintf(("cts_sc", "total length is %d + %d + %d = %d\n",
                sizeof(sc_header), sizeof(unsigned char), pin_length,
                sizeof(sc_header) + sizeof(unsigned char) + pin_length));

        /* We must hex encode it as if it had come from the server, so double
         * the buffer size so that there is space to perform the encode operation
         */
        *apdu_length = total_length << 1;

        result = malloc(total_length << 1);
        if (result != NULL) {
                switch (op) {
                        case cts_sc_pin_op_VERIFY:
                                sc_header.cla = 0x00;
                                sc_header.ins = 0x20;
                                sc_header.p1  = 0x00;
                                sc_header.p2  = 0x80 | keyid;
                                break;
                        case cts_sc_pin_op_CHANGE:
                                sc_header.cla = 0x80;
                                sc_header.ins = 0x32;
                                sc_header.p1  = 0x00;
                                sc_header.p2  =0x80 | keyid;
                                break;
                        default:
                                dprintf(("", "Unknown pin_op when building APDU!\n"));
                                free(result);
                                return NULL;
                }
        }
        else {
                return NULL;
        }

        memcpy(result, &sc_header, sizeof(sc_header));
        result[4] = pin_length;
        if (pin_length > 0) {
                memcpy(result+5, pin, pin_length);
        }
        cts_utils_binary_encode(result, result, total_length);

        return result;
}

cts_sc_status cts_sc_pin_op_response(
        cts_sc_pin_op op,
        char *sw1sw2_response,
        cts_sc_pin_op_response_codes *response,
        size_t *retries_remaining)
{
        if (op == cts_sc_pin_op_VERIFY) {
                static const struct {
                        cts_sc_pin_op_response_codes response;
                        char sw1;
                        char sw2;
                } mappings[] = {
                        { pin_op_SUCCESS,               0x90, 0x00 },
                        { pin_op_FAIL_RETRY_INVALID,    0x63, 0x00 },
                        { pin_op_FAIL_NO_EFID,          0x6A, 0x88 },
                        { pin_op_FAIL_NO_EFID,          0x6A, 0x82 },
                        { pin_op_FAIL_WAS_LOCKED,       0x69, 0x84 },
                        { pin_op_FAIL_NOW_LOCKED,       0x63, 0xC0 },
                        { pin_op_FAIL_UNKNOWN,          0xFF, 0xFF }
                };
                const char sw1 = sw1sw2_response[0];
                const char sw2 = sw1sw2_response[1];
                const size_t map_size = sizeof(mappings) / sizeof(*mappings);
                size_t i;

                if (sw1 == 0x63 && sw2 != 0xC0 && (sw2 & 0xF0) == 0xC0) {
                        *response = pin_op_FAIL_RETRY_VALID;
                        *retries_remaining = sw2 & 0xF;
                }
                else for (i=0; i<map_size; ++i) {
                        if (sw1 == mappings[i].sw1 &&
                            sw2 == mappings[i].sw2 ||
                            mappings[i].sw1 == 0xFF) {
                                *response = mappings[i].response;
                                break;
                        }
                }
        }
        else if (op == cts_sc_pin_op_CHANGE) {
                if (sw1sw2_response[0] == '\x90' && sw1sw2_response[1] == '\0') {
                        *response = pin_op_SUCCESS;
                }
                else {
                        *response = pin_op_FAIL_UNKNOWN;
                }
        }
        else {
                /* Unknown verify op! */
                cts_last_error.code = SCI_E_API;
                return cts_sc_status_FAILED;
        }

        return cts_sc_status_COMPLETE;
}

/* The assembler routine */
extern void SCEvent_handler (void);

/* One-time initialisation for getting events out of the smartcard module */
enum {
        Event_Vector = 16,
/*        Event_Expansion = 21, /* Event number */
        EnableEvent = 14, /* OSByte code */
        DisableEvent = 13 /* OSByte code */
};

static int *cts_sc_pollword = NULL;

static void cts_sc_disable_events(void)
{
        (void) _swix(OS_Byte, _INR(0,1), DisableEvent, Event_Expansion);
}

static void cts_sc_release_vector(void)
{
#ifdef ROM
        (void) _swix(OS_Release, _INR(0,2), Event_Vector,
                SCEvent_handler, cts_sc_pollword);
#else
        (void) _swix(OS_Release, _INR(0,2), Event_Vector,
                cts_sc_pollword + 3, cts_sc_pollword);
#endif
}

static void cts_sc_exit_lowlevel(void)
{
        rma_free(cts_sc_pollword);
}


_kernel_oserror *cts_sc_init_lowlevel(void **pollwordp)
{
        _kernel_oserror *e;
        char             tempblock[30];
        int              explen;
#ifdef ROM
        /* RAM or ROM module - we don't need to do the code-copying shenanigans. */
        cts_sc_pollword = rma_alloc(3 * sizeof(int));
        if (cts_sc_pollword == NULL) {
                dprintf(("", "Memory exhaustion!\n"));
                raise(SIGTERM);
        }
        atexit(cts_sc_exit_lowlevel);
        memset(cts_sc_pollword, '\0', 3 * sizeof(int));
        *pollwordp = cts_sc_pollword + 1; /* Must watch the reason code field. */

        e = _swix(OS_Claim, _INR(0,2), Event_Vector, SCEvent_handler, cts_sc_pollword);
#else
        /* These are the addresses of the function within the application code
         * that we are going to copy to RMA to catch events
         */
        /* This isn't done in the case of a RAM/ROM module, because the offsets
           we're working correctly, and we ending up trying to allocate an awful
           lot of memory */
        extern const char *const scevent_code_limit, *scevent_code_base;
        const size_t event_handler_size = scevent_code_limit - scevent_code_base;

        dprintf(("cts_sc", "smartcard low level init: claim %#08x bytes of RMA\n",
                3 * sizeof(int) + event_handler_size));
        dprintf(("cts_sc", "code start at %p; code end at %p\n",
                scevent_code_base, scevent_code_limit));

        cts_sc_pollword = rma_alloc(3 * sizeof(int) + event_handler_size);
        if (cts_sc_pollword == NULL) {
                dprintf(("", "Memory exhaustion!\n"));
                raise(SIGTERM);
        }
        atexit(cts_sc_exit_lowlevel);
        memset(cts_sc_pollword, '\0', 3 * sizeof(int));
        MemCheck_RegisterMiscBlock(scevent_code_base, event_handler_size);
        memcpy(cts_sc_pollword + 3, scevent_code_base, event_handler_size);
        MemCheck_UnRegisterMiscBlock(scevent_code_base);
        *pollwordp = cts_sc_pollword + 1; /* Must watch the reason code field. */

        e = _swix(OS_Claim, _INR(0,2), Event_Vector, cts_sc_pollword + 3, cts_sc_pollword);
#endif
        if (e != NULL) return e;
        atexit(cts_sc_release_vector);
        e = _swix(OS_Byte, _INR(0,1), EnableEvent, Event_Expansion);
        if (e != NULL) {
                dprintf(("", "Unable to enable events\n"));
                raise(SIGTERM);
        }
        atexit(cts_sc_disable_events);

#ifdef ENABLE_SLOT1SHOPPING
        dprintf(("cts_sc", "About to open a channel onto slot1\n"));
        e = _swix(SCTransport_Open, _IN(0)|_IN(1), 0xffffffff, &slot1_card_handle); /** ooh look, a comment **/
        /** The above SWI opens a channel onto slot1 in case the server decides to access it **/
        card_handle_valid = 1; /* So we know to close the channel when we leave! **/
        if(e != 0) return(e); /** No channel available/allowed, so bomb out **/
        dprintf(("cts_sc", "Channel opened. Card handle=%d. Now reading the ATR\n",slot1_card_handle));
        e = _swix(SCTransport_RetrieveATR, _IN(0)|_IN(1)|_IN(2)|_IN(3), slot1_card_handle, tempblock, 30, &explen);
        dprintf(("cts_sc", "RetrieveATR returned %d. Now we lock the channel for the duration.\n",(int)e));
        e = _swix(SCTransport_StartTrans, _IN(0), slot1_card_handle);
        dprintf(("cts_sc", "Channel locked. Returned %d\n",(int)e));
#endif

        return NULL;
}


typedef enum {
        SCI_EV_REMOVED = 1,
        SCI_EV_INSERTED,
        SCI_EV_TRANS_END,
        SCI_EV_CMD_DONE,
        SCI_EV_ERROR,
        SCI_EV_REMOVED2,
        SCI_EV_INSERTED2,
        SCI_EV_BADINSERT,
        SCI_EV_BADINSERT2,
        SCI_EV_CMD_DONE2,
        SCI_EV_ERROR2
} cts_sc_event_reason_codes;

/* The function called when the pollword goes non-zero */
void cts_sc_pollword_handler(void)
{
        ToolboxEvent e;
        int set_read_response_available = 1;

        dprintf(("cts_sc", "pollword handler entered for card %d (need %d) (%d %d)\n",
                cts_sc_pollword[0], actual_card_handle, cts_sc_pollword[1],
                cts_sc_pollword[2]));

        if (cts_sc_pollword[0] != actual_card_handle && cts_sc_pollword[0] != 0xFFFF) {
                cts_sc_pollword[1] = 0;
                return;
        }

        e.hdr.size = sizeof(ToolboxEventHeader);
        e.hdr.reference_number = 0;

        dprintf(("cts_sc", "pollword non-zero reason code = %d\n", cts_sc_pollword[1]));

        switch (cts_sc_pollword[1]) {
                case SCI_EV_REMOVED:
                case SCI_EV_REMOVED2:
                        cts_last_error.code = SCI_E_OUT;
                        e.hdr.event_code = event_SMARTCARD_REMOVED;
                        e.hdr.flags = cts_sc_pollword[1] == SCI_EV_REMOVED ? 1 : 2;
                        dprintf(("cts_sc", "Smartcard removed from slot %d\n", e.hdr.flags));
                        log_send_msg(log_SC_REMOVED, e.hdr.flags);
                #ifdef ENABLE_SLOT1SHOPPING
                        if(slot1_events_off == 0)
                        {
                          dprintf(("cts_sc", "Telling SCInterface about the removal\n"));
                          _swix(SCInterface_Events, _IN(0)|_IN(2)|_IN(3), 1, actual_card_handle, cts_sc_pollword[1]);
                        }
                #endif
                        break;
                case SCI_EV_TRANS_END:
                        set_read_response_available = 0;
                        e.hdr.event_code = event_SMARTCARD_TRANSACTION_ENDED;
                        e.hdr.flags = 0;
                        break;
                case SCI_EV_BADINSERT:
                case SCI_EV_BADINSERT2:
                        cts_last_error.code = SCI_E_BADCARD;
                        e.hdr.event_code = event_SMARTCARD_BAD_OBJECT_INSERTED;
                        e.hdr.flags = cts_sc_pollword[1] == SCI_EV_BADINSERT ? 1 : 2;
                        break;
                case SCI_EV_ERROR:
                case SCI_EV_ERROR2:
                        /*set_read_response_available = 0;*/
                        cts_last_error.code = SCI_E_SYS;
                        e.hdr.event_code = event_SMARTCARD_SYS_ERROR;
                        e.hdr.flags = 0;
                        break;
                case SCI_EV_INSERTED:
                case SCI_EV_INSERTED2:
                        set_read_response_available = 0;
                        cts_last_error.code = SCI_SUCCESS;
                        e.hdr.event_code = event_SMARTCARD_INSERTED;
                        e.hdr.flags = cts_sc_pollword[1] == SCI_EV_INSERTED ? 1 : 2;
                        dprintf(("cts_sc", "Smartcard inserted in slot %d\n", e.hdr.flags));
                        log_send_msg(log_SC_INSERTED, e.hdr.flags);
                        break;
                case SCI_EV_CMD_DONE:
                case SCI_EV_CMD_DONE2:
                        cts_last_error.code = SCI_SUCCESS;
                        e.hdr.event_code = event_SMARTCARD_COMMAND_DONE;
                        e.hdr.flags = cts_sc_pollword[1] == SCI_EV_CMD_DONE ? 1 : 2;
                        break;
                default:
                        /* Unknown event - must ignore this */
                        break;
        }

        toolbox_raise_toolbox_event(0, NULL_ObjectId, NULL_ComponentId, &e);

        if (set_read_response_available) {
                read_response_available = set_read_response_available;
        }

        dprintf(("cts_sc", "read_response_available now = %d\n", read_response_available));

        cts_sc_pollword[1] = 0;
}

cts_sc_status cts_sc_send_sblock(
        size_t len,
        const void *sblock_inf)
{
        dprintf(("cts_sc", "Send s-block to smartcard\n"));
        ddumpbuf("cts_sc", sblock_inf, len, 0);

        read_response_available = 0;
        log_send_msg(log_SC_SBLOCK);

        return cts_swix(SCTransport_IssueCommand, _INR(0,4), actual_card_handle,
                NULL, len, sblock_inf, 0);
}
