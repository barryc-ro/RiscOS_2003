/*
 *  CTS (smartcard.c)
 *
 * Copyright (C) Element 14 Ltd. 1999
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h>
#include <signal.h>
#include "kernel.h"
#include "swis.h"
#include "ctstypes.h"
#include "ctsbrowser.h"
#include "ctsintern.h"
#include "ctsutils.h"
#include "smartcard.h"
#include "utils.h"

#include "SCTransport.h"

#include "DebugLib/DebugLib.h"
#include "MemCheck:MemCheck.h"

/* NOTE: The SWI interface specification for SCTrans was designed by Rich Buckley.
 * Because of this, errors are not returned properly, but are returned in R0 with
 * V clear!  Thus we have to check that the return value of _swix was zero (could
 * be a system error, y'see) and if so, then we check R0.
 */

static int card_handle;
static cts_sc_slot_id slot_id;
static int actual_card_handle;

static int card_handle_valid = 0;


/* This value is updated by the pollword handler */
static int read_response_available = 0;

/* Homer says calling the SWI call in SCTrans to get this information is flaky
 * and can mess the module up completely - so we'll cache it here.
 */
static struct {
        cts_sc_sctrans_errors	code;
        _kernel_oserror 	error_block;
} cts_last_error;

/* Pragma switches on _swix checking
 * NOTE: only input and output registers are supported.  _BLOCK is not supported
 * _RETURN is not supported.
 */
#pragma -v4
static cts_sc_status cts_swix(int swi_num, int regs, ...)
{
        _kernel_swi_regs r;
        _kernel_oserror *e, *ose;
        va_list ap;
        int rn;

#ifdef DEBUGLIB
	{ static char swi_name[256];
        int len;
        (void) _swix(OS_SWINumberToString, _INR(0,2)|_OUT(2), swi_num, swi_name,
        	sizeof(swi_name), &len);
	dprintf(("cts_swix", "SWI %05x (%.*s)\n", swi_num, len, swi_name));
	}
#endif

        va_start(ap, regs);

	dprintf(("cts_swix", " In:\n"));

        for (rn=0; rn<10; ++rn) {
                if (regs & (_IN(rn))) {
                        r.r[rn] = va_arg(ap, int);
                        dprintf(("cts_swix", "  R%d = %8d (%08x)\n", rn, r.r[rn], r.r[rn]));
                }
        }

	cts_last_error.code = SCI_SUCCESS;
	ose = e = _kernel_swi(swi_num, &r, &r);
	if (e == NULL) {
	        /* Now the buggering about to get around Rich Buckley's shit API */
	        e = (_kernel_oserror *) r.r[0];
	        if (e != NULL) {
	                if (r.r[0] < 0x100) {
	                        static _kernel_oserror ebuf;
	                        ebuf.errnum = r.r[0];
	                        ebuf.errmess[0] = '\0';
	                        e = &ebuf;
	                }
	                cts_last_error.code = (cts_sc_sctrans_errors) e->errnum;
	        }
	}

	dprintf(("cts_swix", " Out:\n"));

        for (rn=0; rn<10; ++rn) {
                if (regs & (_OUT(rn))) {
                        *(va_arg(ap, int *)) = r.r[rn];
                        dprintf(("cts_swix", "  R%d = %8d (%08x)\n", rn, r.r[rn], r.r[rn]));
                }
        }

	va_end(ap);

	dprintf(("cts_swix", "Kernel error -> %p\n", ose));
	dprintf(("cts_swix", "SC error -> %p\n", e));

	if (e != NULL) {
	        (void) memcpy(&cts_last_error.error_block, e, sizeof(cts_last_error));
	        if (ose == NULL && e->errnum == SCI_E_NODATA) {
			dprintf(("cts_swix", "SCI_E_NODATA -> INPROGRESS\n"));
	                return cts_sc_status_INPROGRESS;
	        }
	        return cts_sc_status_FAILED;
	}

	return cts_sc_status_COMPLETE;
}
#pragma -v0

enum {
        cts_sc_handle_SLOT2 = -2
};

cts_sc_sctrans_errors cts_sc_get_last_error(_kernel_oserror **e)
{
        if (e != NULL) {
                *e = &cts_last_error.error_block;
        }
	return cts_last_error.code;
}

cts_sc_status cts_sc_open(cts_sc_slot_id card_number,cts_sc_type *type)
{
        static cts_sc_slot_id opened = cts_sc__general_info;
        cts_sc_status status;
        cts_slot_status ret_status;
        size_t slot_count;
        _kernel_oserror *e;

	if (card_number != opened) {
	        dprintf(("cts_sc", "Opening new card (slot id %d)\n", card_number));
	        status = cts_swix(SCTransport_Open, _INR(0,1), 0, &card_handle);
        	if (status == cts_sc_status_COMPLETE) {
                        opened = card_number;
                }
                else {
		        /* Daft API - even on errors the handle is allocated! */
		        (void) _swix(SCTransport_Close, _IN(0), card_handle);
                        opened = cts_sc__general_info;
                        return status;
                }
	}

	dprintf(("cts_sc", "Card is open\n"));
        card_handle_valid = 1;
        slot_id = card_number;
        actual_card_handle = slot_id;
        if (slot_id == cts_sc_slot2) {
                dprintf(("cts_sc", "Slot 2\n"));
                actual_card_handle = cts_sc_handle_SLOT2;
        }

        e = _swix(SCTransport_SlotInfo, _IN(0)|_OUTR(0,2),
        	card_number, &slot_count, &ret_status, type);
        if (e != NULL) {
                cts_last_error.code = SCI_SUCCESS;
                (void) memcpy(&cts_last_error.error_block, e, sizeof(*e));
                status = cts_sc_status_FAILED;
        }
        else {
	        status = cts_sc_status_COMPLETE;
	        dprintf(("cts_sc", "There are %d slot%s\n", slot_count,
	        	slot_count == 1 ? "" : "s"));
        }

	if (status == cts_sc_status_COMPLETE) {
	        dprintf(("cts_sc", "res_status = %d\n", ret_status));
	        switch (ret_status) {
	                case cts_slot_status_CARD:
	                        dprintf(("cts_sc", "card type = %d\n", *type));
	                        if (*type != cts_sc_type_REASONA) {
	                                /* Perhaps send the s-block */
	                        }
	                        log_send_msg(log_SC_OPENOK);
	                        break;
	                case cts_slot_status_READING_ATR:
	                        status = cts_sc_status_INPROGRESS;
	                        break;
	                case cts_slot_status_EMPTY:
	                        cts_last_error.code = SCI_E_OUT;
	                        status = cts_sc_status_FAILED;
	                        break;
	                case cts_slot_status_UNIDENTIFIABLE:
	                        cts_last_error.code = SCI_E_BADCARD;
	                        status = cts_sc_status_FAILED;
	                        break;
	        }
	}

        return status;
}

cts_sc_status cts_sc_close(void)
{
        if (card_handle_valid) {
		card_handle_valid = 0;
        	return cts_swix(SCTransport_Close, _IN(0), card_handle);
        }

        return cts_sc_status_COMPLETE;
}

/* APDU buffer on exit is identical to APDU buffer on entry, but is temporarily
 * transformed back into the binary representation of the data for passing on
 * to the SCTrans module.  It is assumed that the APDU is an I-block!
 */
cts_sc_status cts_sc_send_apdu(
	const void *apdu,
	const size_t apdu_len)
{
        register char *const apdu_header = (void *) apdu;
        register char *apdu_data   = apdu_header + 4;
        cts_sc_status res;
        size_t Le = 0;
        size_t len;

        read_response_available = 0;

        dprintf(("cts_sc", "Sending APDU ... (length = %d)\n", apdu_len >> 1));

	(void) cts_utils_binary_decode(apdu_header, apdu_header, apdu_len);

	ddumpbuf("cts_sc", apdu_header, apdu_len >> 1, 0);

	/* There are seven possible cases ...
	 *
	 * 1)  Hdr  Lc  Data  Le
	 * 2)  Hdr  Lc  Data
	 * 3)  Hdr  Le
	 * 4)  Hdr
	 * 5)  Hdr  00  LcHi LcLo Data LeHi LeLo
	 * 6)  Hdr  00  LcHi LcLo Data
	 * 7)  Hdr  00  LeHi LeLo
	 */

	/* len is the amount of data excluding the 4 bytes header */
	len = (apdu_len >> 1) - (apdu_data - apdu_header);
	if (len == 0) {
	        /* case 4 */
	        Le = 0;
	        dprintf (("cts_sc", "APDU contains Hdr only\n"));
	}
	else if (apdu_data[0] == '\0') {
	        /* case 5, 6 or 7 */
	        const unsigned int bit31 = 0x80000000u;
	        unsigned char *lenp = (unsigned char *) apdu_data + 1;
	        int val = (lenp[1] << 8) + lenp[0];
	        len -= 3;
                apdu_data += 3;
	        if (len == 0) {
	                /* case 7 */
	                Le = val ^ bit31;
	                len = bit31;
	        }
	        else if (len == val) {
	                /* case 6 */
	                Le = 0;
	                len ^= bit31;
	        }
	        else {
	                /* case 5 */
	                lenp += len;
	                Le = ((lenp[1] << 8) + lenp[0]) ^ bit31;
	                len = (len - 2) ^ bit31;
	        }
	}
	else if (len == 1) {
	        /* case 3 */
	        Le = apdu_data[--len];
     	        dprintf (("cts_sc", "APDU contains Hdr Le(%#x)\n", Le));

	}
	else if (apdu_data[0] == len - 1) {
	        /* case 2 */
	        Le = 0;
	        ++apdu_data;
	        --len;
	        dprintf (("cts_sc", "APDU contains Hdr Lc(%#x) Data\n", len));
	}
	else {
	        /* case 1 */
	        Le = apdu_data[--len];
	        ++apdu_data;
	        --len;
	        dprintf (("cts_sc", "APDU contains Hdr Lc(%#x) Data Le(%#x)\n", len, Le));
	}

	log_send_msg(log_SC_COMMAND,
		apdu_header[0], apdu_header[1],
		apdu_header[2], apdu_header[3],
		len & 0xFFFF, Le);

	dprintf (("cts_sc", "APDU Header:\n"));
	ddumpbuf ("cts_sc", apdu_header, 4, 0);
	dprintf (("cts_sc", "Lc = %#x\nAPDU Data:\n", len));
	ddumpbuf ("cts_sc", apdu_data, len & 0xFFFF, 0);
	dprintf (("cts_sc", "Le = %#x\n", Le));

        res = cts_swix(SCTransport_IssueCommand, _INR(0,4), actual_card_handle,
        	apdu_header, len, apdu_data, Le);

	(void) cts_utils_binary_encode(apdu_header, apdu_header, apdu_len >> 1);

	return res;
}

cts_sc_status cts_sc_read_data(
	void *buffer,
	size_t buffer_length,
	size_t *data_size,
	char *sw1sw2_response)
{
        static char inbuffer[4096 * 2];
        size_t temporary;
        cts_sc_status res;
        char sw[2];

	if (!read_response_available) {
	        return cts_sc_status_INPROGRESS;
	}
	else if (cts_last_error.code != SCI_SUCCESS) {
	        dprintf(("cts_sc_2", "cts_last_error.code != SCI_SUCCESS (is %d)\n",
	        	cts_last_error.code));
	        return cts_sc_status_FAILED;
	}

        if (data_size == NULL) {
                data_size = &temporary;
        }

	if (sw1sw2_response == NULL) {
	        sw1sw2_response = sw;
	}

	if (buffer == NULL) {
	        *data_size = sizeof(inbuffer) >> 1;
	}
	else {
	        *data_size = buffer_length >> 1;
	}

        res = cts_swix(SCTransport_ReadResponse, _INR(0,4), actual_card_handle,
        	inbuffer, sizeof(inbuffer)>>1, data_size, sw1sw2_response);

	dprintf(("cts_sc", "[SW1:SW2] == [%02x:%02x]; data_size = %d; res=%d; err=%d\n",
		sw1sw2_response[0],
		sw1sw2_response[1],
		*data_size,
		res,
		cts_last_error.code));

	if (res == cts_sc_status_COMPLETE) {
	        if (buffer != NULL) {
	                dprintf(("cts_sc", "Adding [%02x:%02x] at offset %d in buffer\n",
				sw1sw2_response[0],
				sw1sw2_response[1],
				*data_size));
	                memcpy(&inbuffer[*data_size], sw1sw2_response, 2);
		        cts_utils_binary_encode(buffer, inbuffer, 2 + *data_size);
		        dprintf(("cts_sc", "Encoded response is %.*s\n",
		        	(2 + *data_size) << 1, buffer));
		        log_send_msg(log_SC_RESPONSE,
				sw1sw2_response[0],
				sw1sw2_response[1],
				*data_size);

	        }
	}
	else if (cts_last_error.code == SCI_E_TRUNC && buffer == NULL) {
	        dprintf(("cts_sc", "Truncated error - changing to success\n"));
	        cts_last_error.code = SCI_SUCCESS;
	        res = cts_sc_status_COMPLETE;
	}

        *data_size = (*data_size + 2) << 1;

        return res;
}

void cts_sc_atexit(void)
{
        (void) cts_sc_close();
}


void *cts_sc_construct_pin_op_apdu(
	cts_sc_pin_op op,
	const char *pin,
	size_t pin_length,
	int keyid,
	size_t *apdu_length)
{
        struct {
                unsigned char cla;
                unsigned char ins;
                unsigned char p1;
                unsigned char p2;
        } sc_header;
        char *result;
        size_t total_length;

	dprintf(("cts_sc", "constructing pin op\n"));

        total_length = sizeof(sc_header) + sizeof(unsigned char) + pin_length;
        dprintf(("cts_sc", "total length is %d + %d + %d = %d\n",
        	sizeof(sc_header), sizeof(unsigned char), pin_length,
        	sizeof(sc_header) + sizeof(unsigned char) + pin_length));

        /* We must hex encode it as if it had come from the server, so double
         * the buffer size so that there is space to perform the encode operation
         */
        *apdu_length = total_length << 1;

	result = malloc(total_length << 1);
	if (result != NULL) {
	        switch (op) {
	                case cts_sc_pin_op_VERIFY:
	                        sc_header.cla = 0x00;
	                        sc_header.ins = 0x20;
	                        sc_header.p1  = 0x00;
	                        sc_header.p2  = 0x80 | keyid;
	                        break;
                        case cts_sc_pin_op_CHANGE:
	                        sc_header.cla = 0x80;
	                        sc_header.ins = 0x32;
	                        sc_header.p1  = 0x00;
	                        sc_header.p2  =0x80 | keyid;
                                break;
                        default:
                                dprintf(("", "Unknown pin_op when building APDU!\n"));
                                free(result);
                                return NULL;
	        }
	}
	else {
	        return NULL;
	}

	memcpy(result, &sc_header, sizeof(sc_header));
	result[4] = pin_length;
	memcpy(result+5, pin, pin_length);
	cts_utils_binary_encode(result, result, total_length);

        return result;
}

cts_sc_status cts_sc_pin_op_response(
	cts_sc_pin_op op,
	char *sw1sw2_response,
	cts_sc_pin_op_response_codes *response,
	size_t *retries_remaining)
{
        if (op == cts_sc_pin_op_VERIFY) {
                static const struct {
                        cts_sc_pin_op_response_codes response;
                        char sw1;
                        char sw2;
                } mappings[] = {
                        { pin_op_SUCCESS,		0x90, 0x00 },
			{ pin_op_FAIL_RETRY_INVALID,	0x63, 0x00 },
        		{ pin_op_FAIL_NO_EFID,		0x6A, 0x88 },
        		{ pin_op_FAIL_WAS_LOCKED,	0x69, 0x84 },
        		{ pin_op_FAIL_NOW_LOCKED,	0x63, 0xC0 },
        		{ pin_op_FAIL_UNKNOWN,		0xFF, 0xFF }
                };
                const char sw1 = sw1sw2_response[0];
                const char sw2 = sw1sw2_response[1];
                const size_t map_size = sizeof(mappings) / sizeof(*mappings);
                size_t i;

                if (sw1 == 0x63 && sw2 != 0xC0 && (sw2 & 0xF0) == 0xC0) {
                        *response = pin_op_FAIL_RETRY_VALID;
                        *retries_remaining = sw2 & 0xF;
                }
                else for (i=0; i<map_size; ++i) {
		        if (sw1 == mappings[i].sw1 &&
		            sw2 == mappings[i].sw2 ||
		            mappings[i].sw1 == 0xFF) {
		                *response = mappings[i].response;
		                break;
		        }
		}
        }
        else if (op == cts_sc_pin_op_CHANGE) {
                if (sw1sw2_response[0] == '\x90' && sw1sw2_response[1] == '\0') {
		        *response = pin_op_SUCCESS;
                }
                else {
                        *response = pin_op_FAIL_UNKNOWN;
                }
        }
        else {
                /* Unknown verify op! */
                cts_last_error.code = SCI_E_API;
                return cts_sc_status_FAILED;
        }

        return cts_sc_status_COMPLETE;
}


/* One-time initialisation for getting events out of the smartcard module */
enum {
        Event_Vector = 16,
        Event_Expansion = 21, /* Event number */
        EnableEvent = 14, /* OSByte code */
        DisableEvent = 13 /* OSByte code */
};

static int *cts_sc_pollword = NULL;

static void cts_sc_disable_events(void)
{
	(void) _swix(OS_Byte, _INR(0,1), DisableEvent, Event_Expansion);
}

static void cts_sc_release_vector(void)
{
	(void) _swix(OS_Release, _INR(0,2), Event_Vector,
		cts_sc_pollword + 3, cts_sc_pollword);
}

static void cts_sc_exit_lowlevel(void)
{
        rma_free(cts_sc_pollword);
}

_kernel_oserror *cts_sc_init_lowlevel(void **pollwordp)
{
        /* These are the addresses of the function within the application code
         * that we are going to copy to RMA to catch events
         */
        extern const char *const scevent_code_limit, *scevent_code_base;
        const size_t event_handler_size = scevent_code_limit - scevent_code_base;
        _kernel_oserror *e;

	dprintf(("cts_sc", "smartcard low level init: claim %#08x bytes of RMA\n",
		3 * sizeof(int) + event_handler_size));
	dprintf(("cts_sc", "code start at %p; code end at %p\n",
		scevent_code_base, scevent_code_limit));

        cts_sc_pollword = rma_alloc(3 * sizeof(int) + event_handler_size);
        if (cts_sc_pollword == NULL) {
                dprintf(("", "Memory exhaustion!\n"));
                raise(SIGTERM);
        }
	atexit(cts_sc_exit_lowlevel);
        memset(cts_sc_pollword, '\0', 3 * sizeof(int));
        MemCheck_RegisterMiscBlock(scevent_code_base, event_handler_size);
        memcpy(cts_sc_pollword + 3, scevent_code_base, event_handler_size);
        MemCheck_UnRegisterMiscBlock(scevent_code_base);
        *pollwordp = cts_sc_pollword + 1; /* Must watch the reason code field. */

	e = _swix(OS_Claim, _INR(0,2), Event_Vector, cts_sc_pollword + 3, cts_sc_pollword);
	if (e != NULL) return e;
	atexit(cts_sc_release_vector);
	e = _swix(OS_Byte, _INR(0,1), EnableEvent, Event_Expansion);
	if (e != NULL) {
	        dprintf(("", "Unable to enable events\n"));
	        raise(SIGTERM);
	}
	atexit(cts_sc_disable_events);
	return NULL;
}


typedef enum {
        SCI_EV_REMOVED = 1,
        SCI_EV_INSERTED,
        SCI_EV_TRANS_END,
        SCI_EV_CMD_DONE,
        SCI_EV_ERROR,
        SCI_EV_REMOVED2,
        SCI_EV_INSERTED2,
        SCI_EV_BADINSERT,
        SCI_EV_BADINSERT2,
        SCI_EV_CMD_DONE2
} cts_sc_event_reason_codes;

/* The function called when the pollword goes non-zero */
void cts_sc_pollword_handler(void)
{
        ToolboxEvent e;
        int set_read_response_available = 1;

	dprintf(("cts_sc", "pollword handler entered for card %d (need %d) (%d %d)\n",
		cts_sc_pollword[0], actual_card_handle, cts_sc_pollword[1],
		cts_sc_pollword[2]));

	if (cts_sc_pollword[0] != actual_card_handle && cts_sc_pollword[0] != 0xFFFF) {
	        cts_sc_pollword[1] = 0;
	        return;
	}

        e.hdr.size = sizeof(ToolboxEventHeader);
        e.hdr.reference_number = 0;

	dprintf(("cts_sc", "pollword non-zero reason code = %d\n", cts_sc_pollword[1]));

	switch (cts_sc_pollword[1]) {
	        case SCI_EV_REMOVED:
	        case SCI_EV_REMOVED2:
	                cts_last_error.code = SCI_E_OUT;
                        e.hdr.event_code = event_SMARTCARD_REMOVED;
                        e.hdr.flags = cts_sc_pollword[1] == SCI_EV_REMOVED ? 1 : 2;
	                break;
	        case SCI_EV_TRANS_END:
	                set_read_response_available = 0;
                        e.hdr.event_code = event_SMARTCARD_TRANSACTION_ENDED;
                        e.hdr.flags = 0;
	                break;
	        case SCI_EV_BADINSERT:
	        case SCI_EV_BADINSERT2:
	                cts_last_error.code = SCI_E_BADCARD;
                        e.hdr.event_code = event_SMARTCARD_BAD_OBJECT_INSERTED;
                        e.hdr.flags = cts_sc_pollword[1] == SCI_EV_BADINSERT ? 1 : 2;
	                break;
	        case SCI_EV_ERROR:
	                set_read_response_available = 0;
	                cts_last_error.code = SCI_E_SYS;
                        e.hdr.event_code = event_SMARTCARD_SYS_ERROR;
                        e.hdr.flags = 0;
	                break;
	        case SCI_EV_INSERTED:
	        case SCI_EV_INSERTED2:
	                set_read_response_available = 0;
	                cts_last_error.code = SCI_SUCCESS;
                        e.hdr.event_code = event_SMARTCARD_INSERTED;
                        e.hdr.flags = cts_sc_pollword[1] == SCI_EV_INSERTED ? 1 : 2;
                        dprintf(("cts_sc", "Smartcard inserted in slot %d\n", e.hdr.flags));
                        log_send_msg(log_SC_INSERTED, e.hdr.flags);
	                break;
	        case SCI_EV_CMD_DONE:
	        case SCI_EV_CMD_DONE2:
		        cts_last_error.code = SCI_SUCCESS;
                        e.hdr.event_code = event_SMARTCARD_COMMAND_DONE;
                        e.hdr.flags = cts_sc_pollword[1] == SCI_EV_CMD_DONE ? 1 : 2;
		        break;
	}

        toolbox_raise_toolbox_event(0, NULL_ObjectId, NULL_ComponentId, &e);

        if (set_read_response_available) {
	        read_response_available = set_read_response_available;
        }

	dprintf(("cts_sc", "read_response_available now = %d\n", read_response_available));

        cts_sc_pollword[1] = 0;
}

cts_sc_status cts_sc_send_sblock(
	size_t len,
	const void *sblock_inf)
{
	dprintf(("cts_sc", "Send s-block to smartcard\n"));
	ddumpbuf("cts_sc", sblock_inf, len, 0);

	log_send_msg(log_SC_SBLOCK);

        return cts_swix(SCTransport_IssueCommand, _INR(0,4), actual_card_handle,
        	NULL, len, sblock_inf, 0);
}
