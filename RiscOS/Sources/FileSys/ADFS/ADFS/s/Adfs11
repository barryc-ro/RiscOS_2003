 [ Top16Write
	ASSERT :LNOT: BigDisc
        SUBT    New ST506 Winchester Driver -> Adfs11

; Change record
; =============
;
; CDP - Christopher Partington, Cambridge Systems Design
;
; 25-Oct-90
; ADFS version 2.06
;
; 19-Feb-91  20:00  CDP
; Changes to make ST506 driver work alongsize the new IDE driver.
; 1) When data transfer code is copied into RAM, invalidate the IDE
;    driver's variable that says what code is currently in RAM. The IDE
;    driver currently does the converse when it copies code. This is
;    necessary as the IDE driver must ALWAYS use MEMC1 code and the
;    ST506 driver can use MEMC1A code when it detects the presence of
;    MEMC1A.
; 2) On exit from foreground and background, change the drive number
;    in the disc address (which gets substituted into disc errors)
;    to be that on entry to the low level entry point (elsewhere).
;    The driver in this file is only ever called with a driver number
;    of 0 or 1 (not 4..7).
; Replace CPU timing loop in RestoreCase to a CPU-speed independent
; loop. This now takes longer to execute so it looks as if the original
; timing loop did not take the amount of time that the comments around
; it suggested.
;
; 22-Mar-91  12:12  CDP
; ALowWriteCode and BLowWriteCode were returning R1 pointing 2 bytes
; too far on when the buffer address was halfword-aligned. Now fixed.
; This fix has not been applied to Adfs10 which is no longer used.
;
; 04-Apr-91  16:28  CDP
; Removed Debug20-dependent debug (IDE).
;
; 11-Feb-92  15:24  LRust
; Read and write operations now disable HDC interrupts but ENABLE CPU
; IRQ's during block move operations performed in background.  This REDUCES
; interrupt latency for the system but INCREASES the interrupt service time.
;
; 06-Dec-94 16:17 SBP
; Added assertion at the start to stop this code being used if BigDisc
; was set TRUE - ST506 not supported in conjunction with BigDisc.
;
        GBLL    WinIRQenable
WinIRQenable    SETL {TRUE}     ; True to enable IRQ's in background

        GBLL    RestoreTimeout
RestoreTimeout  SETL {TRUE}
;
;
;*End of change record*


; registers on entry:
; R1  - operation code
; R2  - disc address in bytes from 0
; R3  - store address in bytes, maybe -> list of A-L pairs.
; R4  - total bytes to transfer, (in foreground)
; R5  - disc record
; R6  - defect list
; R12 - static base
; R13 - a full descending stack pointer
; R14 - return link

; operation code:
;    bits 0-3 are the operation:
;        0 - Verify      - the HDC CheckData command
;        1 - Read        - read data into store
;        2 - Write       - write data to disc
;        3 - ReadId
;        4 - WriteTrack  - format a track
;        5 - Seek        - seek for some reason
;        6 - Restore     - restore to track zero
;        ... unknown opcode ...
;       15 - Specify     - set up the hardware.
;
;    bits 4-8 flags
;    bit 4
;    bit 5 address in RAM is a pointer to address-length pairs.
;    bit 6 poll escape every so often, and quit if set.
;    bit 7 timeout of some sort - not implemented for winnies!
;    bit 8 continue transfer in background afterwards until find 0 length pair
;
; Those operations which don't transfer data still take a disc address in
; bytes and use it to define the track to be formatted, track to read Ids
; from, cylinder to seek to or whatever.
; The number of bytes should be set to 512 for ops 3 and 4, 0 for 5 and 6.
;
; If bit 5 is set, the address register points to a list of address length
; pairs, both in bytes.  The lengths will be rounded up to blocks, ie we
; subtract 256 every transfer until the answer is 0 or negative.  The byte
; count supplied is the actual 'boss', so if you don't supply enough A/L
; pairs it'll go wrong.  The last block (according to the byte count) will
; be exactly transfered, like in the ordinary RAM case.
;
;
;
; on exit:
; R0  - completion code
; R2-R4 updated to reflect how far we got in the transfer
; R1,R5-R13 - preserved
;
; completion code is byte value in R0:
;   0 <=> OK.
;
; The data transfer code is copied down into an area of RAM in the static
; storage area, so that it will run faster than it would from ROM.
;
; Defect skipping:  It is possible to skip defects when doing operations
; 0,1,2 (Verify, Read, Write) by providing in R8 the address of a suitable
; list of bad addresses.  If there were bad blocks at say (cylinder 4, head 0
; block 6) and (cyl 6, head 3, block 0) ie addresses when freshly formatted
; 4*4*32+0*32+6 = &20600 in bytes and 6*4*32+3*32+0 = &36000 in bytes, make
; a list containing R8 ->   &20600
;                           &36000
;                        &0FFFFFFF ; for instance, just a big number
;
; then when a request starting at addresses &20600 to &35E00 is made it'll be
; incremented by one to skip the bad area, mapping to blocks &207..&35F on the
; physical disc.  A request starting at address &35F00 and up will be
; incremented by 2 to map onto &36100 up.  The code does split up long
; requests into several shorter ones, so you can say "Read from &20000 up to
; &40000" in one go and the bad blocks will be missed out. (and the last block
; read from the disc is physical block &401, which is logical block &3FF)
;
; If R6 doesn't contain a good address (TSTS R6, #&FC000003 => NE) no defect
; skipping is performed, so supply -1 for instance to turn defect skipping off.
;
; NB if in future anyone wants to do hoopy things like guess where the client
; will want to read next and seek there in advance, it'll still all work,
; though when the actual transfer is performed, an extra step may be needed
; to get to the right track, as seek(&3FF00) may take us to the cylinder before
; the one where logical block &3FF lives, at physical block
; &3FF + (number of defects before &3FF).  All clear?
;

StartOfTheWholeDamnedThing ROUT

;************************************************************************
;*                                                                      *
;*               H A R D W A R E   D E F I N I T I O N                  *
;*                                                                      *
;************************************************************************

 ]
; Where's the hardware?
HDC             RN R11
                ^ -dataRead, HDC
HDCBase         # 0     ;so HDCdataRead comes out 0

HDCcommand      *    0 + HDCBase ;WRITE
HDCparameter    *    4 + HDCBase ;WRITE
HDCdataRead * dataRead + HDCBase ;READ

 [ Top16Write
HDCstatus       *  &20 + HDCBase ;READ
POL     bit 1+8         ;polling
ABN     bit 2+8         ;abnormal end
DER     bit 3+8         ;drive error
SED     bit 4+8         ;seek end
CED     bit 5+8         ;command end
CPR     bit 6+8         ;command parameter rejection
BSY     bit 7+8         ;busy

HDCresult       * &24 + HDCBase ;READ
 ]
HDCdataWrite    * &28 + HDCBase ;WRITE
 [ IOMD
WinnieBits  * IOMD_HardDisc_IRQ_bit
 |


  [ A1            ; irq bits attached to the HDC
WinnieBits  * &08
  |
DataReqBit  * &10
IntReqBit   * &08
WinnieBits  * DataReqBit + IntReqBit
  ]
WinPodIRQrequest bit 0
; Only use the fact that it's requesting something, look in HDCstatus for what.
 ]
 [ Top16Write

; now a number of HDC commands

CAbort          * &F0
CCheckData      * &48
CCheckDrive     * &28
CFormat         * &A3
CPollingOn      * &10
;CPollingOff     * &18
CRead           * &40
CReadId         * &60
CRestore        * &C8
CSeek           * &C0
CSpecify        * &E8
CWrite          * &87
CRecall         * &08

MaxCyls         * 1024  ;the most the HDC can handle

                GBLS    WinIrqRegs
WinIrqRegs      SETS    """R4-R10,PC"""

;************************************************************************
;*                                                                      *
;*         C O D E   S T A R T   -   M I N O R   R O U T I N E S        *
;*                                                                      *
;************************************************************************

; ================
; TestEscapeStatus
; ================

; test escape and return if set, corrupts R0

TestEscapeStatus ROUT
        LDR     R0, opCode
        TSTS    R0, #NoEscape    ;are we ignoring escapes ?
        MOVNES  PC, R14
        MOV     R0, #0
        LDRB    R0, [R0, #ESC_Status]
        TSTS    R0, #EscapeBit
        MOVEQS  PC, R14
        MOV     R0, #IntEscapeErr
        STRB    R0, completion
        B       ContigEnded

; ===============
; SenseController
; ===============

; Test for controller's presence - EQ if present, NE if not
;
; Note that this will abort any pending command

MaxTimeForAbort * 1024*5
CommandAborted * &04

SenseController ROUT
        Push    "r0,r1,lr"

        ; If winnie already specified then no problem
        LDRB    r0, SpecifiedWinnie
        TEQ     r0, #&ff
        MOV     lr, pc
        TEQP    lr, #Z_bit
        Pull    "r0,r1,pc",EQ

        ; Do an abort
        MOV     R0, #CAbort :SHL: 16
        STR     R0, HDCcommand

        MOV     r1, #MaxTimeForAbort

10
        LDR     R0, HDCstatus
        TSTS    R0, #CED :OR: SED :OR: DER :OR: ABN
        BNE     %FT20
        SUBS    r1, r1, #1
        BNE     %BT10

 [ Debug2
        DLINE   "Controller absent - took too long"
 ]

        ; Controller absent - took too long!
        TEQ     pc, #0          ; set NE
        Pull    "r0,r1,pc"

20
        ; Controller responded to Abort - get result
        LDRB    r0, HDCresult
 [ Debug2
        DREG    r0, "Controller result="
 ]
        TEQ     r0, #CommandAborted
 [ fix_10
        TEQNE   r0, #&18
 ]
        Pull    "r0,r1,pc"

; =======
; DoAbort
; =======

;corrupts R0 and flags

DoAbort ROUT
 [ Debug2
        mess    ,"DoAbort",NL
 ]
        LDR     R0, HDCstatus
        TSTS    R0, #CED :OR: SED :OR: DER
 [ Debug6
        Push    LR
        MOVNE   R0, #"a"
        MOVEQ   R0, #"A"
        BL      TubeChar
        Pull    "LR"
 ]
 [ Debug2
        mess    NE, "DONE",NL
 ]
        BNE     %FT30

        MOV     R0, #CAbort :SHL: 16
        STR     R0, HDCcommand
20
        LDR     R0, HDCstatus
        TSTS    R0, #CED :OR: SED :OR: DER :OR: ABN
        BEQ     %BT20
;fall through to GetResult
30
 [ Debug2
        mess    ,"ABORTED",NL
 ]

; =========
; GetResult
; =========

; GetResult
; Get the result of a command into R0
; exit R0 status byte >> 2, NE <=> error
GetResult ROUT
        LDRB    R0, HDCresult

 [ F
        Push    "R0-R2"
 [ Debug2
        mess    ,"*results"
        wrhex   R0
 ]
        MOV     R0, #&FF
        ORR     R0, R0, #&FF00 ; gets &FFFF in R0

        LDR     R1, HDCresult
        LDR     R2, HDCresult
        AND     R1, R1, R0
        ORR     R1, R1, R2, ASL #16
; STR    R1, results
 [ Debug2
        wrhex   R1
 ]

        LDR     R1, HDCresult
        LDR     R2, HDCresult
        AND     R1, R1, R0
        ORR     R1, R1, R2, ASL #16
; STR    R1, results + 4
 [ Debug2
        wrhex   R1
 ]

        LDR     R1, HDCresult
        LDR     R2, HDCresult
        AND     R1, R1, R0
        ORR     R1, R1, R2, ASL #16
; STR    R1, results + 8
 [ Debug2
        wrhex   R1
 ]

        LDR     R1, HDCresult
        AND     R1, R1, R0
; STR    R1, results + 12
 [ Debug2
        wrhex   R1
        mess    ,NL
 ]
        Pull    "R0-R2"
 ]

        MOVS    R0, R0, LSR #2
 [ Debug6
        BEQ     %FT90
        Push    "R0,LR"
        MOV     R0, #"E"
        BL      TubeChar
        LDR     R0, [SP]
        Tword   R0
        LDR     R0, HDCstatus
        Tword   R0
        Pull    "R0,LR"
90
 ]
 [ Debug2
        wrhex   R0
        mess    ,"result",NL
 ]
        MOV     PC, LR


; =========
; StartSeek
; =========

; dest. cylinder in R0, drive in R1
; corrupts R0, R1

StartSeek2 ROUT
        MOV     R0, R6
StartSeek1
        MOV     R1, R3
StartSeek
 [ Debug2
        wrhex   R0
        wrhex   R1
        mess    ,"start seek",NL
 ]
        MOV     R0, R0, ASL #16
        ORR     R0, R0, R1, ASL #8
        STR     R0, parameters
        MOV     R0, #CSeek

;fall through to CommandHDC

; ==========
; CommandHDC
; ==========

; CommandHDC
; Stuff command R0 and parameters up it so it does the biz - uses R0, R1
;
CommandHDC ROUT
 [ Debug2
        mess    ,"*winnie op "
        wrhex  R0
 ]
 [ Debug6
        Tword   R0
 ]
        STRB    R0, command

 [ Debug2
        DLINE   "CommandHDC:Wait for both BSY and POL to clear...",cc
 ]
10
        LDR     R0, HDCstatus
        TSTS    R0, #BSY :OR: POL
        BNE     %BT10
 [ Debug2
        DLINE   "done"
 ]

        TSTS    R0, #CPR
        MOVNE   R0, #CRecall :SHL: 16   ;gets it ready for parameters
        STRNE   R0, HDCcommand
 [ Debug2
        DLINE   "CommandHDC:Wait for BSY to clear...",cc
 ]
20
        LDRNE   R0, HDCstatus
        TSTNES  R0, #BSY
        BNE     %BT20
 [ Debug2
        DLINE   "done"
 ]
        LDR     R0, parameters
 [ Debug6
        Tword   R0
 ]
 [ Debug2
        wrhex   R0
 ]
        MOV     R1, R0, ASL #16
        STR     R1, HDCparameter
        STR     R0, HDCparameter

        LDR     R0, parameters + 4
 [ Debug6
        Tword   R0
 ]
 [ Debug2
        wrhex   R0
 ]
        MOV     R1, R0, ASL #16
        STR     R1, HDCparameter
        STR     R0, HDCparameter
        LDR     R0, parameters + 8
 [ Debug2
        wrhex   R0
 ]
        MOV     R1, R0, ASL #16
        STR     R1, HDCparameter
        STR     R0, HDCparameter

        LDR     R0, parameters + 12
 [ Debug2
        wrhex   R0
        mess    ,NL
 ]
        MOV     R1, R0, ASL #16
        STR     R1, HDCparameter
        STR     R0, HDCparameter

        LDRB    R0, command
        MOV     R0, R0, LSL #16
        STR     R0, HDCcommand

        TEQS    R0, #CSeek :SHL: 16
        TEQNES  R0, #CRestore :SHL: 16
        MOVNES  PC, LR
 [ Debug2
        DLINE   "Seek/Restore BSY clear poll...",cc
 ]
                        ;start polling if seek or restore
30
        LDR     R0, HDCstatus
        TSTS    R0, #BSY
        BNE     %BT30
 [ Debug2
        DLINE   "Done"
 ]
        TSTS    R0, #SED :OR: DER :OR: ABN
        MOVNES  PC, LR

        MOV     R0, #CPollingOn :SHL: 16
        STR     R0, HDCcommand
 [ Debug2
        DLINE   "Seek/Restore 2nd BSY clear poll...",cc
 ]
40
        LDR     R0, HDCstatus
        TSTS    R0, #BSY
        BNE     %BT40
 [ Debug2
        DLINE   "Done"
 ]
        MOVS    PC, LR


; ===================
; WaitForSeekComplete
; ===================

; corrupts R0

WaitForSeekComplete ROUT
        MOV     R9, R14
WaitForSeekCompleteRTSViaR9
 [ Debug2
        mess    ,"*start wait for seek complete",NL
 ]
10
        LDR     R0, HDCstatus
        TSTS    R0, #SED :OR: DER :OR: ABN
        BEQ     %BT10
        TSTS    R0, #BSY
        BNE     %BT10
 [ Debug2
        mess    ,"*seek complete",NL
 ]
        MOVS    PC, R9


; These are parameters for the maximum number of heads and cylinders possible
SpecifyBlock
        =  &C3 ; OM1 or C1 with AMEX = 0
        =  &1F ; OM0 *** was 0F
        =  &00 ; CUL overwritten if drive(s) present
        =  &16 ; SL, step rate code or something *** was 16

        =  (MaxCyls-1) :MOD: &100       ; NCL
        =  (MaxCyls-1)/&100 + &3F:SHL:2 ; TO/NCH
        =  32 - 1                       ; NS
        =  8  - 1                       ; NH

        =  &0A ; GPL1 *** was 0A ***                        *** Marv sez 06
        =  &A9 ; SH/RL, step hi time/Record length = 256 bytes *** was A9
        =  &0C ; GPL3 or 0C if 3 is always added *** was 0F *** Marv sez 09
        =  &0D ; GPL2 or 0A if 3 is always added *** was 0D *** Marv sez 0C

        =  &80 ; LCCL
        =  &00 ; LCCH
        =  &FF ; PCCL *** was FF *** Marv sez 00 for MiniScribe
        =  &03 ; PCCH *** was 03 *** Marv sez 00 for MiniScribe

        ALIGN

Specify ROUT
 [ Debug2
        mess    ,"Specify",NL
 ]
        MOV     R9, LR
        ORR     R0, LR, #I_bit
        TEQP    PC, R0                  ;disable IRQs
        ASSERT  InterruptBits = InterruptPtr + 4
        ADR     R0, InterruptPtr
        LDMIA   R0, {R0,R1}

 [ PodFix

        LDR     R4, = DefaultHDC + dataRead
        TEQS    R4, HDC
        LDREQB  R4, [R0]
        BICEQ   R4, R4, R1
        MOVNE   R4, #0

 |

        LDRB    R4, [R0]
        BIC     R4, R4, R1

 ]

        STRB    R4, [R0]
        TEQP    PC, LR                  ;restore IRQ state

        MOV     R0, #CAbort             ;to avoid write gate assert bug after specify
        BL      CommandHDC
 [ Debug2
        DLINE   "Specify:Wait for BSY to clear...",cc
 ]
05
        LDR     R0, HDCstatus
        TSTS    R0, #BSY
        BNE     %BT05
 [ Debug2
        DLINE   "done"
 ]
        BL      GetResult               ;->/ R0,Z

        baddr   R0, SpecifyBlock
        LDMIA   R0, {R1,R4,LR}
        sbaddr  R0, parameters
        STMIA   R0, {R1,R4,LR}

; now insert the parms we were called with here
        ASSERT  MaxWinnies=2
        TSTS    R2, #DiscBits           ;make CUL
        MOVEQ   R0, #2_0010             ;if drive 0
        MOVHI   R0, #2_0100             ;if any other drive
        STRHSB  R0, parameters+2

        LDRB    R0, WHeads
        CMPS    R0, #8
        MOVHI   R0, #8
        TEQS    R6, #NIL                ;if not mount fill in parms
        SUBNE   R0, R0, #1
        STRNEB  R0, parameters+7        ;heads
        LDRNEB  R0, WSecsPerTrk
        SUBNE   R0, R0, #1
        STRNEB  R0, parameters+6        ;sectors
        ADDNE   R0, R6, #ParkDiscAdd
        LDMNEDB  R0,{R5,R7,R8}          ;misc hardware params
        MOVNE   R5, R5, LSR #24
        STRNEB  R5, parameters+3        ;SL
        BICNE   R7, R7, #&0700          ;force sector size = 256
        ORRNE   R7, R7, #&0100
        STRNE   R7, parameters+8        ;GPL1, SH, GPL3, GPL2
        STRNE   R8, parameters+12       ;LCC, PCC
        MOV     R0, #&FF
        STRB    R0, SpecifiedWinnie
        MOV     R0, #CSpecify
        BL      CommandHDC              ;do the specify command corrupts R0,R1
        MOVNE   R0, R2, LSR #(32-3)     ;Unless mount update specified winnie
        STRNEB  R0, SpecifiedWinnie
 [ Debug2
        DLINE   "Specify:Wait (2) for BSY to clear...",cc
 ]
10
        LDR     R0, HDCstatus
        TST     R0, #BSY
        BNE     %BT10                   ; wait for not busy
 [ Debug2
        DLINE   "done"
 ]
        BL      GetResult               ;->/ R0, Z
        STRB    R0, completion
        MOVS    PC, R9                  ;exit R0 completion code

        LTORG

;************************************************************************
;*                                                                      *
;*             T H E   A C T U A L   E N T R Y   P O I N T              *
;*                                                                      *
;************************************************************************
WinnieDrivers ROUT
 [ Debug5
        SetBorder  &F,0,0
 ]
        MOV     R0, #NormalEntry
        Push    "R0,R7-R11,LR"
 [ Debug6
        MOV     R0, #"("
        BL      TubeChar
 ]
 [ Debug2
        wrhex   R1
        wrhex   R2
        wrhex   R3
        wrhex   R4
        wrhex   R5
        wrhex   R6
        mess    ,"parms",NL
 ]

        LDR     HDC,HDCPtr
 [ Debug2
        wrhex   HDC
        mess    ,"*HDC",NL
 ]

        BL      SenseController
        BNE     ControllerMissing

 [ Debug2
        LDRB    lr, SpecifiedWinnie
        TEQ     lr, #&ff
        BL      SenseController
        BEQ     %FT01
        DLINE   "Controller - what controller?"
        B       %FT02
01
        DLINE   "There's a controller - what a relief!"
02
 ]

        LDRB    R10,[R5, #Zones]
        LDR     R8, [R5, #DiscSize]
        LDR     R5, [R5]
        ASSERT  SecsPerTrk=1
        ASSERT  Heads=2
        ASSERT  (:INDEX: WSecsPerTrk) :MOD: 4 = 1
        ASSERT  WHeads=WSecsPerTrk+1
        STR     R5, WSecsPerTrk-1
        STRB    R10,WZones
        TSTS    R1, #ScatterBit
        ADDEQ   R5, SB, #:INDEX: WScatterRam
        STMEQIA  R5,{R3,R4}
        STREQ   R4, WLength
        MOVNE   R5, R3
        ADR     R0, parms
        ASSERT  opCode      = parms             ;R1
        ASSERT  discAddress = opCode+4          ;R2
        ASSERT  WRemains    = discAddress+4     ;R4
        ASSERT  WScatter    = WRemains+4        ;R5
        ASSERT  WDefectList = WScatter+8        ;R6
        ASSERT  WDiscSize   = WDefectList+4     ;R8
        STMIA   R0!,{R1,R2,R4,R5}
        STMIB   R0, {R6,R8}
        LDRB    LR, SpecifiedWinnie
        TEQS    LR, R2, LSR #(32-3)     ;is correct winnie specified
        MOV     R0, #-1
        STR     R0, dsI         ;flag no defect skipping (yet)
        BEQ     %FT02
        BL      Specify         ;exit R0 completion code
        TEQS    R0, #0
        BNE     TransferEnd
02

; now deal with the defect skipping.

        LDRB    R0, opCode
        AND     R0, R0, #OpMask
        CMPS    R0, #3
        LDRCS   R1, WRemains
        BCS     %FT50           ;it's >= 3, so not Verify, read or write

        RSBS    R1, R0, #ReadSecsOp
        BHI     %FT08           ;verify
                        ;C set <=> read
        ASSERT  Resume = RomReturn + 4
        sbaddr  R1, RomReturn
        ADRCSL  R2, ReadLoopNext
        ADRCSL  R3, BackgroundReadResume
        ADRCCL  R2, WriteLoopNext
        ADRCCL  R3, BackgroundWriteResume
        STMIA   R1, {R2,R3}
        LDRB    R1, WinnieRamOp
        TEQS    R0, R1                          ;preserves C
        BEQ     %FT08
        MOV     R1, #&FF
        STRB    R1, WinnieRamOp

        ADR     R10,LowCodeLocation
 [ MEMC1A
        LDRB    LR, MEMCflag
        TSTS    LR, #1
        BNE     %FT06

        ADRCSL  R9, ALowReadCodeStart
        ADRCCL  R9, ALowWriteCodeStart
        ADDCS   LR, R10,#ALowReadCodeSize
        ADDCC   LR, R10,#ALowWriteCodeSize
        B       %FT07

06
        ADRCSL  R9, BLowReadCodeStart
        ADRCCL  R9, BLowWriteCodeStart
        ADDCS   LR, R10,#BLowReadCodeSize
        ADDCC   LR, R10,#BLowWriteCodeSize
 |
        ADRCSL  R9, LowReadCodeStart
        ADRCCL  R9, LowWriteCodeStart
        ADDCS   LR, R10,#LowReadCodeSize
        ADDCC   LR, R10,#LowWriteCodeSize
 ]
07
        LDMIA   R9!, {R1-R8}
        STMIA   R10!,{R1-R8}
        CMPS    R10,LR
        BLO     %BT07
        STRB    R0, WinnieRamOp

; invalidate IDE driver's variable which tells it what code is currently
; in RAM

        MOV     R1,#&FF
        STRB    R1,WinIDERAMOp

08
        LDRB    R1, WZones
        TEQS    R1, #0          ;IF new format
        LDREQ   R1, WDefectList
        TSTEQS  R1, #PsrMask    ;OR bad address
        LDRNE   R2, discAddress
        LDRNE   R3, WDiscSize
        BNE     %FT45           ;THEN no defect skipping

        MOV     R0, #0
DefectSkipLoopBack
; R0 = dsI, R1 = defectList
        LDR     R2, discAddress
        BIC     LR, R2, #DiscBits
10
        LDR     R3, [R1,R0]
        CMPS    LR, R3
        ADDHS   R0, R0, #4
        ADDHS   LR, LR, #&100   ; one blocksize (skip unit) in bytes
        BHS     %BT10           ; examine next entry
        AND     R2, R2, #DiscBits
        ORR     R2, R2, LR
        STR     R2, discAddress
 [ Debug2
        wrhex   R2
        mess    ,"disc address adjusted for defects",NL
 ]

;[ R1, R0 ] is the address of the first entry > discAddress
        STR     R0, dsI

45
        BIC     LR, R2, #DiscBits
        SUB     LR, R3, LR

        LDR     R1, opCode
        TSTS    R1, #BackgroundOp
        LDREQ   R1, WRemains
        MOVNE   R1, #&40000000

        CMPS    R1, LR
        MOVHI   R1, LR
50
 [ Debug2
        wrhex   R1
        mess    ,"Contig",NL
 ]
        ADD     R1, R2, R1
        STR     R1, ContigEnd
        LDRB    R0, WinnieRetries
        STRB    R0, WRetry

RetryEntryPoint ; where we come to try again!
        MOV     R0, #0
        STRB    R0, completion

        ADR     R0, OpcodeTable
        LDR     R1, opCode
        AND     R1, R1, #OpMask
        CMPS    R1, #OpcodeTableSize
        LDRCC   R1, [ R0, + R1, ASL #2 ] ; take the case if in range
        ADRCCL  R0, StartOfTheWholeDamnedThing
        ADDCC   PC, R0, R1

        CMPS    R1, #SpecifyOp  ; initialise case?
        BLEQ    Specify
        MOVNE   R0, #BadParmsErr
        STRNEB  R0, completion
                        ;fall through to ContigEnded

ContigEnded

;Exodus
        LDRB    R0, completion
        CMPS    R0, #0
        BNE     TransferEnd     ;if there's an error status, don't carry on!
        LDR     R0, dsI
        CMPS    R0, #-1
        BEQ     TransferEnd     ;no defect skipping in progress
        LDR     R1, opCode
        TSTS    R1, #BackgroundOp
        BNE     %FT70

        LDR     R1, WRemains
        CMPS    R1, #0
        BEQ     TransferEnd
        B       %FT80

70
        MOV     R1, PC
        ORR     R9, R1, #I_bit
        TEQP    PC, R9
        LDR     R9, WScatter
        LDR     R2, [R9,#4]
        TEQS    R2, #0
        BEQ     TransferEnd     ;IRQs still disabled
        TEQP    PC, R1

80
        LDR     R1, WDefectList
; R0 = dsI, R1 -> defect list
        B  DefectSkipLoopBack

TransferEnd
;DISABLE HDC IRQs
        MOV     R3, PC
        ORR     R4, R3, #I_bit
        TEQP    PC, R4                  ;disable IRQs
        ASSERT  InterruptBits = InterruptPtr + 4
        ADR     R0, InterruptPtr
        LDMIA   R0, {R0,R1}

 [ PodFix

        LDR     R2, = DefaultHDC + dataRead
        TEQS    R2, HDC
        LDREQB  R2, [R0]
        BICEQ   R2, R2, R1
        MOVNE   R2, #0

 |

        LDRB    R2, [R0]
        BIC     R2, R2, R1

 ]

        STRB    R2, [R0]
        TEQP    PC, R3                  ;restore IRQ state
;TURN LIGHTS OFF BY SELECTING DRIVE 0 WHICH DOESN'T EXIST
        MOV     R0, #0
        STR     R0, parameters
; STR    R0, parameters+4
; STR    R0, parameters+8
; STR    R0, parameters+12
        MOV     R0, #CCheckDrive
        BL      CommandHDC
81
        LDR     R0, HDCstatus
        TSTS    R0, #BSY
        BNE     %BT81           ;wait for not busy, ignoring the resulting error status
        MOV     R8, #BackgroundOp       ;flag will be amending process block if one

BreakOffExit

        ADR     R0, parms
        ASSERT  opCode      = parms             ;R1
        ASSERT  discAddress = opCode+4          ;R2
        ASSERT  WRemains    = discAddress+4     ;R4
        ASSERT  WScatter    = WRemains+4        ;R5
        LDMIA   R0, {R1,R2,R4,R5}               ;get result parms
        LDR     R0, dsI
        CMPS    R0, #-1
;EQ no need to compensate returned disc address for defect skipping
        SUBNE   R2, R2, R0, ASL #(8-2)  ;multiples of 4 to those of 256
        MOV     R3, R5

        TSTS    R1, #ScatterBit
        BNE     %FT83

        TEQS    R4, #0
        TOGPSR  Z_bit, R0
        LDRNE   R0, WLength
        TEQNES  R0, #0
        LDRNE   R3, [R3, #-8]
        LDREQ   R3, [R3]
83

; R2 = disc address
; put logical drive number back into R2

        LDRB    R0,WinLogicalDrive      ; 4..7
        BIC     R2,R2,#DiscBits         ; remove current drive number
        ORR     R2,R2,R0,LSL #(32-3)    ; put in original one

        LDRB    R0, completion          ;IF 0 < error <= MaxDiscErr alter error format
        SUBS    R5, R0, #0              ; also R5 is value for ProcessStatus
        MOVNE   R5, R3
        RSBHIS  LR, R0, #MaxDiscErr+1
        MOVHI   R0, R0, LSL #24
        ORRHI   R0, R0, R2, LSR #8
        ORRHI   R0, R0, #DiscErrorBit

        TSTS    R1, R8                  ;update process block if background op and done
        BEQ     %FT86

        MOV     R7, R3                  ;loop to find start of scatter block
84
        LDR     LR, [R7, #8]!
        TEQS    LR, #0
        BPL     %BT84
        ADD     R7, R7, LR
        STMDB   R7, {R0,R5}     ;set ProcessError and ProcessStatus
                ;THIS ALLOWS RESTARTING SO CAN'T RELY ON WINNIE WORKSPACE
86
        TEQS    PC, PC, LSR #1          ;C=0/1 IRQ/SVC
        BCS     %FT90                   ;if in SVC mode
 [ Debug5
        SetBorder  8,8,8
 ]
 [ Debug6
        MOV     R0, #"]"
        BL      TubeChar
 ]

        TEQP    PC, #I_bit :OR: SVC_mode
        nop
        MOV     R0, LR
        MOV     R1, SB
        LDR     SB, FileCorePrivate
        MOV     LR, PC          ;set return link
        LDR     PC, [R1, #:INDEX: WinnieCallAfter]
        MOV     LR, R0          ;will return here
        TEQP    PC, #IRQ_mode :OR: I_bit
        nop
        Pull    $WinIrqRegs,,^

90
        LDRB    LR, EntryReason
        CMPS    LR, #NormalEntry
        BNE     TimerReturn
        TEQP    PC, #SVC_mode   ;reenable IRQs

        TEQS    R4, #0          ;IF position in transfer is now in background part
        ADDMI   R2, R2, R4      ;(only happens on write foreground part >0, background
        MOVMI   R4, #0          ;part = &100) then adjust to background start
                        ;impossible to adjust R3 and not useful anway
95
        BL      SetVOnR0
        ADD     SP, SP, #4      ;skip stacked entry reason
 [ Debug5
        SetBorder  0,0,0
 ]
 [ Debug6
        Push    "R0"
        MOV     R0, #")"
        BL      TubeChar
        Pull    "R0"
 ]
        Pull    "R7-R11,PC"     ;foreground return

ControllerMissing
        MOV     r0, #BadDriveErr
        B       %BT95

OpcodeTable ROUT
        &  VerifyCase     - StartOfTheWholeDamnedThing ; 0
        &  ReadCase       - StartOfTheWholeDamnedThing ; 1
        &  WriteCase      - StartOfTheWholeDamnedThing ; 2
        &  ReadIdCase     - StartOfTheWholeDamnedThing ; 3
        &  WriteTrackCase - StartOfTheWholeDamnedThing ; 4
        &  SeekCase       - StartOfTheWholeDamnedThing ; 5
        &  RestoreCase    - StartOfTheWholeDamnedThing ; 6
OpcodeTableEnd
OpcodeTableSize * (OpcodeTableEnd - OpcodeTable)/4
        ASSERT  OpcodeTableSize = 7

;  Now various little routines for sharing among the main options

PrepareDriveBlockHeadCylinder ROUT
; exit: R0-R2,R9 corrupt
; R3: drive, R4: start block, R5: head, R6: cylinder
        MOV     R9, LR
        LDR     R2, discAddress
        MOV     R3, R2, LSR #29         ; get the drive number
        ADD     R3, R3, #1              ; so we start at 1, clients start at 0
        BIC     R2, R2, #DiscBits       ; blat the drive number
        MOV     R0, R2, LSR #8          ; block address
        LDRB    R1, WSecsPerTrk
        BL      Divide
        MOV     R4, R1                  ; remainder is start block
        LDRB    R1, WHeads
        BL      Divide
        MOV     R5, R1                  ; remainder is head number
        MOV     R6, R0                  ; result is cylinder number
        MOV     R0, #0
        STRB    R0, NextHead            ;to set pending seek
 [ Debug2
        wrhex   R3
        wrhex   R4
        wrhex   R5
        wrhex   R6
        mess    ,"PrepareDriveBlockHeadCylinder",NL
 ]
        MOVS    PC, R9


; =====================
; WritePrepareNextBlock
; =====================

WritePrepareNextBlock
        LDR     R1, WriteAdjust
 [ Debug2
        wrhex   R2
        wrhex   R1
        mess    ,"WritePrepareNextBlock",NL
 ]
        CMPS    R1, #&200
        ADDLO   R1, R1, R2
        STRLO   R1, WriteAdjust
        MOVLOS  PC, LR
;fall through to PrepareForNextBlock


; ===================
; PrepareForNextBlock
; ===================

;entry R2 = transferred this block
;exit R0,R1,R3-R5 corrupt

PrepareForNextBlock ROUT
 [ Debug2
        wrhex   R2
        mess    ,"PrepareForNextBlock",NL
 ]
        ADR     R5, discAddress
        ASSERT  WRemains = discAddress + 4

        LDMIA   R5, {R0,R3}
        ADD     R0, R0, R2
        SUB     R3, R3, R2
        STMIA   R5, {R0,R3}

        ORR     R5, LR, #I_bit  ;disable IRQs to prevent more pairs being added
        TEQP    PC, R5
        LDR     R5, WScatter
        LDMIA   R5, {R0,R1}
        SUBS    R4, R2, R1
        MOVLS   R3, R2
        MOVHI   R3, R1
        ADD     R0, R0, R3
        SUB     R1, R1, R3
        STMIA   R5!,{R0,R1}
        MOVLOS  PC, LR

        BEQ     %FT70
        LDMIA   R5, {R0,R1}
        TEQS    R0, #0
        ADDMI   R5, R5, R0
        LDMMIIA  R5, {R0,R1}
        ADD     R0, R0, R4
        SUBS    R1, R1, R4
        STRNE   R5, WScatter
        STMIA   R5!,{R0,R1}
        MOVNES  PC, LR

70
        LDR     R0, opCode
        ANDS    R0, R0, #BackgroundOp   ;if background op may need to loop back to
        LDRNE   R1, [R5]                ;start of scatter list
        TSTNES  R1, #bit31
        ADDNE   R5, R5, R1
        STR     R5, WScatter
        TEQS    R0, #BackgroundOp       ;if background op 0 length marks end
        LDREQ   R1, [R5, #4]
        TEQEQS  R1, #0
        MOVNES  PC, LR
        BL      DoAbort                 ;->R0
        B       TransferEnd             ;IRQs still disabled


; =============
; TestContigEnd
; =============

;exit
; if more in this contiguous fragment returns R0 amount left, R1 corrupt
; otherwise jumps to ContigEnded

TestContigEnd ROUT
        LDR     R0, ContigEnd
        LDR     R1, discAddress
        SUBS    R0, R0, R1
        BEQ     ContigEnded
        LDR     R1, opCode
        TSTS    R1, #BackgroundOp
        MOVEQS  PC, LR
                        ;IF BackgroundOp also check for 0 length pair
        ORR     R1, LR, #I_bit
        TEQP    PC, R1          ;disable IRQ to prevent more pairs being added
        LDR     R1, WScatter
        LDR     R1, [R1,#4]
        TEQS    R1, #0
        MOVNES  PC, LR          ;if more return restoring IRQ state
        B       TransferEnd     ;leave IRQs disabled


; ==================
; PrepareForTransfer
; ==================

;entry
; R3 drive
; R4 block
; R5 head
; R6 cylinder

;exit R0-R2,R7,R9,R10 corrupt
;     R8 transfer length

PrepareForTransfer ROUT
 [ Debug2
        wrhex   R3
        wrhex   R4
        wrhex   R5
        wrhex   R6
        mess    ,"PrepareForTransfer",NL
 ]
        MOV     R9, LR
        BL      TestContigEnd           ;doesn't return if end ->R1 / R0
 [ Debug2
        wrhex   R0
        mess    ,"left",NL
 ]
        MOV     R2, #0
        STR     R2, WriteAdjust
        ADD     R2, R0, #255            ; bytes + 255 to round up
        MOV     R2, R2, LSR #8          ; get it into blocks
        BL      TestEscapeStatus        ;doesn't return if escape, ->R0

; R2: remaining blocks to xfer
        STR     R6, Cylinder
        LDRB    R7, NextHead
        RSBS    R7, R7, #0
        BMI     %FT10                   ;no seek needed if not back to head 0

        BL      StartSeek2              ;R3,R6->R0,R1

        LDR     R7, WRemains
        CMPS    R7, #0
        MOVLE   R0, #&FF                ;to prevent another seek
        STRLEB  R0, NextHead

        STRLEB  R4, WBlock
        STRLEB  R5, WHead

        BLLE    BackgroundBreakOff

10
        TEQS    R5, #&FF
        LDRLEB  R4, WBlock
        LDRLEB  R5, WHead

        LDRB    R0, WSecsPerTrk
        LDRB    R8, WHeads
        SUB     R1, R0, R4      ;blocks left on this track (secTrk - block)
        BIC     R10,R5, #7
        ADD     R10,R10,#8
        ADD     R5, R5, #1
        SUB     R8, R8, R5
        MLA     R8, R0, R8, R1  ;blocks left on this cylinder
        SUB     LR, R10,R5
        SUB     R5, R5, #1
        MLA     LR, R0, LR, R1  ;blocks left to next 8 head boundary
        CMPS    R2, R8
        MOVHI   R2, R8          ;blocks = min (blocks left,blocks on cylinder)
        CMPS    R2, LR
        MOVHI   R2, LR          ;if cross 8 head boundary reduce transfer
        MOVLS   R10,#0          ;otherwise next head = 0
        STRB    R10,NextHead
; now set up the parameter block for either read or write data
        MOV     R0, R6, ASL #16         ;cylinder into upper halfword
        ORR     R0, R0, R3, ASL #8      ;insert US = drive number
        ORR     R0, R0, R5              ;insert PHA = head number MOD 8
        BIC     R0, R0, #&F8
        STR     R0, parameters

        MOV     R0, R2, ASL #16         ;block count into upper HW
        ORR     R0, R0, R5, ASL #8      ;LHA = head number
        ORR     R0, R0, R4              ;LSA = start block
        STR     R0, parameters + 4
        MOV     R8, R2, LSL #8          ;so it's available if needs be (in verify)!

        LDR     R0, = DefaultHDC + dataRead
        ORR     R1, R9, #I_bit
        TEQP    PC, R1                  ;disable IRQs
        CMPS    R0, HDC                 ;IF EQ C=1

        AND     R0, R5, #8
        MOVEQ   R1, #HeadSelectBit3
        ASSERT  HeadSelectBit3=bit7
        MOVEQ   R0, R0, LSL #4
        BLEQ    WrSharedLatch
        ASSERT  InterruptBits=InterruptPtr+4
        ADRNE   R1, InterruptPtr
        LDMNEIA  R1, {R1,R2}
        MOVNE   R0, R0, LSL #3
        STRNEB  R0, HeadSelBit3Copy
        TEQNES  PC, PC, LSR #1          ;C=0 <=> IRQ mode, preserves NE
        ORRCC   R0, R0, R2
        STRNEB  R0, [R1]                ;head select 3 is bit 6 on podule
        TEQP    PC, R9                  ;reenable IRQs

        CMPS    R7, #0                  ;did we do a seek ?
        BGT     WaitForSeekCompleteRTSViaR9
        MOVS    PC, R9

        LTORG

; ==========
; WaitForReq
; ==========

WaitForReq ROUT
;exit R0 status, R1,R2 corrupt
 [ Debug2
        mess    ,"*start wait for request"
 ]
        ASSERT  PollBits=PollPtr+4
        ADR     R1, PollPtr
        LDMIA   R1, {R1,R2}
50
        LDRB    R0, [R1]
        TSTS    R0, R2
        BEQ     %BT50
        LDR     R0, HDCstatus
 [ Debug2
        wrhex   R0
        mess    ," *done",NL
 ]
        MOVS    PC, LR


; ===================
; PrepareForNextChunk
; ===================

;exit R0 corrupt
;R3 drive
;R4 block
;R5 head
;R6 cylinder

PrepareForNextChunk ROUT
        MOV     R9, LR
        BL      GetResult       ;-> / R0,Z
        STRB    R0, completion
        BNE     WinnieError

        LDRB    R0, command
        TEQS    R0, #CSeek
        TEQNES  R0, #CRestore
        LDRNEB  R0, WinnieRetries
        STRNEB  R0, WRetry
        LDR     R2, WriteAdjust
        TEQS    R2, #0
        BLNE    PrepareForNextBlock     ;R2 -> R0,R1,R3-R5


VerifyNextChunk         ;enter with return link in R9
        LDR     R3, discAddress
        MOV     R3, R3, LSR #29 ;drive
        ADD     R3, R3, #1
        MOV     R4, #0
        LDRB    R5, NextHead
        LDR     R6, Cylinder

        TEQS    R5, #0
        ADDEQ   R6, R6, #1      ;next cylinder if back to head 0
 [ Debug2
        wrhex   R3
        wrhex   R4
        wrhex   R5
        wrhex   R6
        mess    ,"<PrepareForNextChunk",NL
 ]
        MOVS    PC, R9


; ==================
; BackgroundBreakOff
; ==================

BackgroundBreakOff ROUT
        TEQS    PC, PC, LSR #1          ;C=0/1 IRQ/SVC
 [ Debug5
        SetBorder  8,8,8,CC
 ]
 [ Debug6
        MOVCC   R0, #"]"
        BLCC    TubeChar
 ]
        Pull    $WinIrqRegs,CC,^        ;If in IRQ mode
 [ Debug2
        mess    ,"BackgroundBreakOff",NL
 ]
        LDR     R2, opCode              ;IF background op
        TSTS    R2, #BackgroundOp
        MOVEQS  PC, LR

 [ Debug6
        MOV     R0, #"b"
        BL      TubeChar
 ]
        TEQP    PC, #I_bit :OR: SVC_mode        ;disable IRQs to CPU
        ADD     R0, SB, #:INDEX: InterruptPtr   ;enable IRQs from HDC
        ASSERT  InterruptBits=InterruptPtr+4
        LDMIA   R0, {R0,R1}
        LDR     R2, = DefaultHDC + dataRead
        TEQS    R2, HDC

        LDREQB  R2, [R0]
        LDRNEB  R2, HeadSelBit3Copy
        ORR     R2, R2, R1
 [ Debug2
        wrhex   R0
        wrhex   R1
        wrhex   R2
        mess    ,"Enable HDC IRQ"
 ]
        STRB    R2, [R0]

        LDRB    R2, EntryReason
        CMPS    R2, #NormalEntry
        MOVEQ   R8, #0
        BEQ     BreakOffExit
        BNE     TimerReturn

; >>>>>>>>>
; WinnieIRQ
; >>>>>>>>>

WinnieIRQ ROUT          ;CAN CORRUPT R0-R3,R11,R12
 [ Debug5
        SetBorder  0,&F,0
 ]
        Push    "R4-R10,LR"
 [ Debug6
        MOV     R0, #"["
        BL      TubeChar
 ]
        LDR     HDC,HDCPtr
        LDR     R0, HDCstatus
        LDR     PC, Resume


WinnieError ROUT
 [ Debug5
        SetBorder  &F,&F,&F
 ]
; R0 SSB>>2
        CMPS    R0, #&48 :SHR 2         ;&48 = SSB for corrected ECC
        LDR     R2, opCode
        AND     R2, R2, #OpMask         ; get the opcode
        BNE     %FT10                   ; on the compare with &48
 [ Debug2
        mess    ,"*Corrected ECC ",NL
 ]
        CMPS    R2, #ReadSecsOp         ; is it Read
        MOVEQ   R0, #0                  ; as we're about to carry on, but
        STREQB  R0, completion          ; may have finished already

 [ WTEST
        LDREQ   R0, ECCTotal
        ADDEQ   R0, R0, #1
        STREQ   R0, ECCTotal
 ]
        BEQ     ReadCase        ;carry on where we left off if a corrected ECC
;if it drops through here we got error &48 while not reading!
;This should not happen!  But just in case we'll treat it like any error.
 [ Debug2
        mess    ,"*!!! while not reading !!!",NL
 ]
10
 [ WTEST
        LDR     LR, ErrorTotal
        ADD     LR, LR, #1
        STR     LR, ErrorTotal
 ]
; opcode 0-F in R2
        CMPS    R2, #ReadSecsOp         ;Read?
        CMPNES  R2, #2                  ;or Write? are the only ones I'll retry.
        BNE     %FT90                   ;on the read or write comparison

        LDRB    R2, WRetry
        SUBS    R2, R2, #1
        STRB    R2, WRetry
 [ Debug2
        DREG    r2, "Retries left="
 ]
 [ Debug6
        Tword   R2
 ]
        BMI     %FT90                   ;retrys exhausted - give up!
; here we'll do something clever to make the retrys more effective.
        LDR     R3, discAddress
        MOV     R3, R3, LSR #29 ;drive
        ADD     R3, R3, #1

 [ Debug2
        wrhex   R2
        mess    ,"*Retrying ",NL
 ]
        CMPS    R0, #&20 :SHR: 2
        CMPNES  R0, #&28 :SHR: 2
        BEQ     %FT70                   ;if it's drive been not ready, always restore

        ANDS    R2, R2, #3
        BEQ     %FT70
        CMPS    R2, #3
 [ Debug6
        MOVEQ   R0, #"="
        MOVNE   R0, #"S"
        BL      TubeChar
 ]
        BEQ     RetryEntryPoint

        LDR     R6, Cylinder
        CMPS    R2, #1
        ADDNE   R0, R6, #5              ;a place to seek to
        SUBEQS  R0, R6, #5
        MOVMI   R0, #0
        CMPS    R0, #MaxCyls
        MOVHS   R0, #MaxCyls
        SUBHS   R0, R0, #1
        BL      StartSeek1              ;R0,R3->R0,R1

        LDR     R1, WRemains
        CMPS    R1, #0
        BLGT    WaitForSeekComplete     ;->R0/
        BGT     RetryEntryPoint

        ADR     R2, %FT60
        STR     R2, Resume
        BL      BackgroundBreakOff      ;doesn't return

60
        ; Retry the op
        LDR     R0, opCode
        ASSERT  ReadSecsOp=1
        ASSERT  WriteSecsOp=2
        TSTS    R0, #2
        ADREQ   R0, BackgroundReadResume
        ADRNEL  R0, BackgroundWriteResume
        STR     R0, Resume
        B       RetryEntryPoint

70
        ; Do a restore before having another go

        MOV     R0, R3, ASL #8 ; drive number
        STR     R0, parameters

        ; 2 successful restores before retrying...
        MOV     R8, #2
        STRB    R8, RestoreCount

 [ RestoreTimeout
        ; But not more than 30 seconds worth in any case...
        BL      IntoSVC
        SWI     XOS_ReadMonotonicTime
        BL      OutOfSVC
        BVS     %FT90
        ADD     r0, r0, #188*16 ; = 3008 (about 30 seconds)
        STR     r0, RestoreEndTime
 ]

80
        ; Have a go at a restore...

        ; Stop if escape
        BL      TestEscapeStatus

 [ RestoreTimeout
        ; Stop if run out of time
        BL      IntoSVC
        SWI     XOS_ReadMonotonicTime
        BL      OutOfSVC
        BVS     %FT90
        LDR     r1, RestoreEndTime
  [ Debug2
        DREG    r0, "Time now:",cc
        DREG    r1, " time to end:"
  ]
        CMP     r0, r1
        BHS     %FT90
 ]

81
 [ Debug6
        MOV     R0, #"R"
        BL      TubeChar
 ]
        MOV     R0, #CRestore
        BL      CommandHDC
        LDR     R1, WRemains
        CMPS    R1, #0
        ADRLE   R2, %FT82
        STRLE   R2, Resume
        BLLE    BackgroundBreakOff      ;doesn't return
        BL      WaitForSeekComplete
82
        BL      GetResult               ;-> / R0,Z
        LDRB    R8, RestoreCount

        SUBEQS  R8, R8, #1
 [ Debug6
        MOV     R0, #"r"
        BL      TubeChar
        Tword   R8
 ]
        STRB    R8, RestoreCount
        BEQ     %BT60

        LDR     R0, WRemains
        CMPS    R0, #0
        BGT     %FT86

        MOV     R0, #CRecall :SHL: 16   ;clears interrupt
        BL      CommandHDC              ;(R0->R0,R1)

        MOV     R0, #25                 ;call back after 1/4s
        ADR     R1, %FT85
        MOV     R2, SB

        BL      IntoSVC
        SWI     XOS_CallAfter
        BL      OutOfSVC

        BVS     %FT86
        TEQS    PC, PC, LSR #1          ;C=0/1 IRQ/SVC
 [ Debug5
        SetBorder  8,8,8,CC
 ]
 [ Debug6
        MOVCC   R0, #"]"
        BLCC    TubeChar
 ]
        Pull    $WinIrqRegs,CC,^        ;If in IRQ mode

;fall through to TimerReturn

TimerReturn
        ADD     SP, SP, #4      ;skip stacked entry reason
 [ Debug6
        MOV     R0, #"}"
        BL      TubeChar
 ]
        Pull    "R0-R11,LR"
 [ {TRUE}
        TEQP    PC, R0
        nop
  [ Debug5
        SetBorder  0,0,0
  ]
        Pull    "R0,PC",,^
 |
        TEQP    PC, #IRQ_mode :OR: I_bit
        nop
  [ Debug5
        SetBorder  0,0,0
  ]
        Pull    "PC",,^
 ]

85
 [ Debug5
        SetBorder  0,0,&F
 ]
 [ {TRUE}
        Push    "R0,LR"
        MOV     R0, PC
 |
        Push    "LR"
 ]
        TEQP    PC, #I_bit :OR: SVC_mode
        nop
        Push    "R0-R11,LR"
 [ Debug6
        MOV     R0, #"{"
        BL      TubeChar
 ]
        MOV     R0, #TimerEntry
        Push    "R0"
        LDR     HDC,HDCPtr
        B       %BT81

86
        MOV     R0, #&80000 ;1/2 million
88
        SUBS    R0, R0, #1  ;s + (2s+n) = 5s, * 512k = 2.5M at 8MHz = 5/16 Second delay
        BPL     %BT88
        B       %BT80

90
 [ Debug2
        mess    ,"*Error!",NL
 ]
        B       TransferEnd


;**********   R E A D   C A S E   **********
ReadCase ROUT ; 1 - read data into store
        BL      PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6
        B       %FT10

05
        BL      PrepareForNextChunk     ;->R0 / R3-R6 if not a data transfer
10
        BL      PrepareForTransfer      ;R3-R6 -> R0-R2,R7-R10 may break off
        MOV     R0, #CRead
        BL      CommandHDC
        B       %FT50                   ;skip here for speed

ReadLoopNext
        MOV     R2, #&100
45
 [ WinIRQenable
        Pull    "R0,LR"
        TEQP    PC, R0                  ; Restore CPU mode and IRQ state
        NOP

        ADR     R0, InterruptPtr
        LDMIA   R0, {R0,R1}             ; Get -> Interrupt mask reg and mask
        LDR     R4, = DefaultHDC + dataRead
        TEQS    R4, HDC                 ; Podule controller?
        LDREQB  R4, [R0]                ; No, read IOC
        LDRNEB  R4, HeadSelBit3Copy     ; Else get head select
        ORR     R4, R4, R1              ; Set interrupt mask
        TEQS    PC, PC, LSR #1          ; C=0 <=> IRQ mode, preserves NE
        STRCCB  R4, [R0]                ; Re-enable HDC IRQ's if IRQ mode
 ]
        BL      PrepareForNextBlock     ;R2 -> R0,R1,R3-R5
; now poll the data xfer
50
        LDR     R7, WRemains
        CMPS    R7, #0
        BLLE    BackgroundBreakOff
        BL      WaitForReq              ;->R1,R2 / R0
BackgroundReadResume
        TSTS    R0, #CED :OR: SED :OR: DER :OR: ABN
        BNE     %BT05

 [ WinIRQenable
        ADR     R0, InterruptPtr
        LDMIA   R0, {R0,R1}
        LDR     R4, = DefaultHDC + dataRead
        TEQS    R4, HDC
        LDREQB  R4, [R0]
        LDRNEB  R4, HeadSelBit3Copy
        BIC     R4, R4, R1              ; Clear interrupt mask bit
        STRB    R4, [R0]                ; Disable HDC IRQ's

        MOV     R0, PC
        TEQP    PC,#SVC_mode            ; Re-enable IRQ's during transfer
        NOP
        Push    "R0,LR"                 ; Save CPU mode, interrupt mask and SVC_lr
 ]
        ASSERT  WScatter=WRemains+4
        ADR     R0, WRemains
        LDMIA   R0, {R0,R1}
 [ Debug2
        wrhex   R1
 ]
        LDR     R1, [R1]
        SUBS    R2, R0, #0
        CMPNES  R0, #&100
        MOVCS   R10,    #&0000FF00
        ORRCS   R10,R10,#&00FF0000
 [ Debug2
        wrhex   R0
        wrhex   R1
        mess    CS,"WHOLE",NL
 ]
        ADRCS   PC, LowCodeLocation     ;same as BCS LowCodeLocation

 [ Debug2
        mess    ,"PARTIAL",NL
 ]
;read a fragment
        MOV     R3, #&100
60
        LDR     R4, HDCdataRead
        SUBS    R0, R0, #1
        STRPLB  R4, [R1], #1
        MOV     R4, R4, LSR #8
        SUBS    R0, R0, #1
        STRPLB  R4, [R1], #1
        SUBS    R3, R3, #2
        BGT     %BT60
        B       %BT45

 ]

; this lot will be relocated into RAM at LowCodeLocation
ALowReadCodeStart ROUT
        MOVS    R2, R1, LSL #31         ;NE <=> bit 0, CS <=> bit 1
        BNE     ARead256OddAddress
        BCS     ARead256HalfWordAddress
ARead256WordAddress ROUT
        MOV     R0, #256-4

        Align16  ALowReadCodeStart
10                              ;DONT REORDER, ALIGNMENT MOD 16 TIME CRITICAL
        SUBS    R0, R0, #7*4
        LDR     R2, HDCdataRead
        LDR     LR, HDCdataRead
        AND     R2, R2, R10,LSR #8

        ORR     R2, R2, LR, LSL #16
        LDR     R3, HDCdataRead
        LDR     LR, HDCdataRead
        AND     R3, R3, R10,LSR #8

        ORR     R3, R3, LR, LSL #16
        LDR     R4, HDCdataRead
        LDR     LR, HDCdataRead
        AND     R4, R4, R10,LSR #8

        ORR     R4, R4, LR, LSL #16
        LDR     R5, HDCdataRead
        LDR     LR, HDCdataRead
        AND     R5, R5, R10,LSR #8

        ORR     R5, R5, LR, LSL #16
        LDR     R6, HDCdataRead
        LDR     LR, HDCdataRead
        AND     R6, R6, R10,LSR #8

        ORR     R6, R6, LR, LSL #16
        LDR     R7, HDCdataRead
        LDR     LR, HDCdataRead
        AND     R7, R7, R10,LSR #8

        ORR     R7, R7, LR, LSL #16
        LDR     R8, HDCdataRead
        LDR     LR, HDCdataRead
        AND     R8, R8, R10,LSR #8

        ORR     R8, R8, LR, LSL #16
        STMIA   R1!,{R2-R8}
        BGT     %BT10
        LDR     R8, HDCdataRead

        AND     R8, R8, R10,LSR #8
        LDREQ   LR, HDCdataRead         ;EQ <=> 4n
        ORREQ   R8, R8, LR, LSL #16
        STREQ   R8, [R1], #4

        LDREQ   PC, RomReturn
        STRB    R8, [R1],#1             ;here if 4n+2
        MOV     R8, R8, LSR #8
        STRB    R8, [R1],#1

        LDR     PC, RomReturn

ARead256HalfWordAddress
        LDR     R8, HDCdataRead
        STRB    R8, [R1],#1
        MOV     R8, R8, LSR #8

        STRB    R8, [R1],#1
        MOV     R0, #256-4-2
        B       %BT10


ARead256OddAddress ROUT
        MOV     R0, #(256-4)/12

        MOV     R4, #&FF
        BCS     ARead256at4Nplus3
; so here we know that the address is 4N + 1
        LDR     R8, HDCdataRead
        STRB    R8, [R1], #1

        MOV     R8, R8, LSR #8
        STRB    R8, [R1], #1
        BL      ARead254odd
        LDR     PC, RomReturn

        Align16  ALowReadCodeStart-12
ARead254odd ROUT                ;corrupts R0,R2,R5-R8,LR
        LDR     R8, HDCdataRead
        STRB    R8, [R1],#1
        AND     R5, R4, R8, LSR #8

10                              ;DONT REORDER, ALIGNMENT MOD 16 TIME CRITICAL
        SUBS    R0, R0, #1              ;R5=next byte
        LDR     R2, HDCdataRead         ;xxxxBhBl
        LDR     R6, HDCdataRead         ;xxxxChCl
        AND     R2, R2, R10,LSR #8      ;0000BhBl

        ORR     R2, R2, R6, LSL #16     ;ChClBhBl
        LDR     R7, HDCdataRead         ;xxxxDhDl
        ORR     R6, R5, R2, LSL #8      ;ClBhBlAh
        LDR     R5, HDCdataRead         ;xxxxEhEl

        AND     R7, R10,R7, LSL #8      ;00DhDl00
        LDR     R8, HDCdataRead         ;xxxxFhFl
        ORR     R7, R7, R5, LSL #24     ;ElDhDl00
        ORR     R7, R7, R2, LSR #24     ;ElDhDlCh

        MOV     R5, R5, LSL #16         ;EhEl0000
        LDR     R2, HDCdataRead         ;xxxxGhGl
        AND     R8, R10,R8, LSL #8      ;00FhFl00
        ORR     R8, R8, R2, LSL #24     ;GlFhFl00

        ORR     R8, R8, R5, LSR #24     ;GlFhFlEh
        STMIA   R1!, {R6-R8}
        AND     R5, R4, R2, LSR #8      ;000000Gh
        BNE     %BT10

        STRB    R5, [R1],#1
        MOV     PC, LR

ARead256at4Nplus3 ROUT
; here we know the address is 4N + 3
        BL      ARead254odd
        LDR     R8, HDCdataRead
        STRB    R8, [R1],#1             ;here if 4n+2
        MOV     R8, R8, LSR #8
        STRB    R8, [R1],#1

        LDR     PC, RomReturn

ALowReadCodeEnd
ALowReadCodeSize * ALowReadCodeEnd - ALowReadCodeStart

 [ Top16Write
BLowReadCodeStart ROUT
        ASSERT  :INDEX: HDCdataRead=0
        MOVS    R2, R1, LSL #31         ;NE <=> bit 0, CS <=> bit 1
        BNE     BRead256OddAddress
        BCS     BRead256HalfWordAddress
BRead256WordAddress ROUT
        MOV     R0, #256-4

        Align16  BLowReadCodeStart
10                              ;DONT REORDER, ALIGNMENT MOD 16 TIME CRITICAL
        SUBS    R0, R0, #7*4
        LDMIA   HDC,{R2,LR}
        AND     R2, R2, R10,LSR #8
        LDMIA   HDC,{R3,R9}

        ORR     R2, R2, LR, LSL #16
        LDMIA   HDC,{R4,LR}
        AND     R3, R3, R10,LSR #8
        ORR     R3, R3, R9, LSL #16

        AND     R4, R4, R10,LSR #8
        LDMIA   HDC,{R5,R9}
        ORR     R4, R4, LR, LSL #16
        AND     R5, R5, R10,LSR #8

        ORR     R5, R5, R9, LSL #16
        LDMIA   HDC,{R6,LR}
        AND     R6, R6, R10,LSR #8
        LDMIA   HDC,{R7,R9}

        ORR     R6, R6, LR, LSL #16
        LDMIA   HDC,{R8,LR}
        AND     R7, R7, R10,LSR #8
        ORR     R7, R7, R9, LSL #16

        AND     R8, R8, R10,LSR #8
        ORR     R8, R8, LR, LSL #16
        STMIA   R1!,{R2-R8}
        BGT     %BT10

        LDMEQIA  HDC,{R8,LR}            ;EQ <=> 4n
        ANDEQ   R8, R8, R10,LSR #8
        ORREQ   R8, R8, LR, LSL #16
        STREQ   R8, [R1], #4

        LDREQ   PC, RomReturn
BReadLast2
        LDR     R8, HDCdataRead
        STRB    R8, [R1],#1             ;here if 4n+2
        MOV     R8, R8, LSR #8

        STRB    R8, [R1],#1
        LDR     PC, RomReturn

BRead256HalfWordAddress
        LDR     R8, HDCdataRead
        STRB    R8, [R1],#1

        MOV     R8, R8, LSR #8
        STRB    R8, [R1],#1
        MOV     R0, #256-4-2
        B       %BT10


BRead256OddAddress ROUT
        MOV     R0, #(256-4)/12
        MOV     R4, #&FF
        BCS     BRead256at4Nplus3
; so here we know that the address is 4N + 1
        LDR     R8, HDCdataRead

        STRB    R8, [R1], #1
        MOV     R8, R8, LSR #8
        STRB    R8, [R1], #1
        BL      BRead254odd

        LDR     PC, RomReturn

        Align16  BLowReadCodeStart-12
BRead254odd ROUT                ;corrupts R0,R2,R5-R9,LR
        LDR     R8, HDCdataRead
        STRB    R8, [R1],#1
        AND     R5, R4, R8, LSR #8

10                              ;DONT REORDER, ALIGNMENT MOD 16 TIME CRITICAL
        SUBS    R0, R0, #1              ;R5=next byte
        LDMIA   HDC,{R2,R6}             ;xxxxBhBl xxxxChCl
        AND     R2, R2, R10,LSR #8      ;0000BhBl
        ORR     R2, R2, R6, LSL #16     ;ChClBhBl

        ORR     R6, R5, R2, LSL #8      ;ClBhBlAh
        LDMIA   HDC,{R7,R9}             ;xxxxDhDl xxxxEhEl
        AND     R7, R10,R7, LSL #8      ;00DhDl00
        ORR     R7, R7, R9, LSL #24     ;ElDhDl00

        ORR     R7, R7, R2, LSR #24     ;ElDhDlCh
        LDMIA   HDC,{R2,R8}             ;xxxxFhFl xxxxGhGl
        MOV     R9, R9, LSL #16         ;EhEl0000
        AND     R2, R10,R2, LSL #8      ;00FhFl00

        AND     R5, R4, R8, LSR #8      ;000000Gh
        ORR     R8, R2, R8, LSL #24     ;GlFhFl00
        ORR     R8, R8, R9, LSR #24     ;GlFhFlEh
        STMIA   R1!, {R6-R8}

        BNE     %BT10
        STRB    R5, [R1],#1
        MOV     PC, LR

BRead256at4Nplus3 ROUT
; here we know the address is 4N + 3
        baddr   LR, BReadLast2
        B       BRead254odd

BLowReadCodeEnd
BLowReadCodeSize * BLowReadCodeEnd - BLowReadCodeStart


;**********   W R I T E   C A S E   **********
WriteCase ROUT ; 2 - write data to disc
        BL      PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6
        B       %FT10

05
        BL      PrepareForNextChunk     ;->R0 / R3-R6 if not a data transfer
10
        BL      PrepareForTransfer      ;R3-R6 -> R0-R2,R7,R9,R10 / R8 may break off

        LDR     LR, opCode
        TSTS    LR, #BackgroundOp
        BEQ     %FT40

        MOV     R0, PC                  ;disable IRQs to stop possible extension
        ORR     LR, R0, #I_bit
        TEQP    PC, LR

        MOV     R1, #0                  ;init total write left
        LDR     R2, WScatter
        MOV     R3, R2
        MOV     R4, #NIL                ;init start of block unknown
        B       %FT20

15
        ADD     R1, R1, LR
        CMPS    R1, R8
        BHS     %FT35
        TEQS    R3, R2
        BEQ     %FT22
20
        LDMIA   R3, {R5,LR}
        TEQS    R5, #0
        ADDMI   R3, R3, R5
        ADDMI   R4, R3, #2*4
        BMI     %BT20
        TEQS    LR, #0
        ADD     R3, R3, #2*4
        BNE     %BT15
22
        TEQS    R4, #NIL
        BNE     %FT30
25
        LDMIA   R3!,{R5,LR}
        TEQS    R5, #0
        BPL     %BT25
        ADD     R4, R3, R5
30
 [ Debug6
        Push    "R0"
        MOV     R0, #"W"
        BL      TubeChar
        Tword   R1
        Tword   R8
        Pull    "R0"
 ]
        MOV     LR, #bit31
        STR     LR, [R4, #-(2*4+4)]
        MOV     R1, R1, LSR #8
        STRB    R1, parameters+6
        MOV     R1, R1, LSR #8
        STRB    R1, parameters+7
35
        TEQP    PC, R0
40

        MOV     R0, #CWrite
        BL      CommandHDC
        B       %FT50

WriteLoopNext
        MOV     R2, #&100
45
 [ WinIRQenable
        Pull    "R0,LR"
        TEQP    PC, R0                  ; Restore CPU mode and IRQ state
        NOP

        ADR     R0, InterruptPtr
        LDMIA   R0, {R0,R1}
        LDR     R4, = DefaultHDC + dataRead
        TEQS    R4, HDC
        LDREQB  R4, [R0]
        LDRNEB  R4, HeadSelBit3Copy
        ORR     R4, R4, R1              ; Set interrupt mask
        TEQS    PC, PC, LSR #1          ;C=0 <=> IRQ mode, preserves NE
        STRCCB  R4, [R0]                ; Re-enable HDC IRQ's if IRQ mode
 ]
        BL      WritePrepareNextBlock   ;R2 -> R0,R1,R3-R5
50
        LDR     R7, WRemains
        CMPS    R7, #0
        BLLE    BackgroundBreakOff
        BL      WaitForReq              ;->R1,R2 / R0
BackgroundWriteResume
        TSTS    R0, #CED :OR: SED :OR: DER :OR: ABN
        BNE     %BT05

 [ WinIRQenable
        ADR     R0, InterruptPtr
        LDMIA   R0, {R0,R1}
        LDR     R4, = DefaultHDC + dataRead
        TEQS    R4, HDC
        LDREQB  R4, [R0]
        LDRNEB  R4, HeadSelBit3Copy
        BIC     R4, R4, R1              ; Clear interrupt mask bit
        STRB    R4, [R0]                ; Disable HDC IRQ's

        MOV     R0, PC
        TEQP    PC,#SVC_mode            ; Re-enable IRQ's during transfer
        NOP
        Push    "R0,LR"                 ; Save CPU mode, interrupt mask and SVC_lr
 ]
        ASSERT  WScatter=WRemains+4
        ASSERT  WriteAdjust=WScatter+4
        ADR     R0, WRemains
        LDMIA   R0, {R2-R4}
        SUB     R2, R2, R4
55
        LDMIA   R3, {R1,R5}
        TEQS    R1, #0
        ADDMI   R3, R3, R1
        BMI     %BT55
        ADD     R1, R1, R4
        SUBS    R4, R4, R5
        ADDHS   R3, R3, #8
        BHS     %BT55

        SUBS    R0, R2, #0
        CMPNES  R0, #&100
 [ Debug2
        wrhex   R0
        wrhex   R1
        mess    CS,"WHOLE",NL
 ]
 [ MEMC1A
        ADDCS   R10,HDC,#:INDEX HDCdataWrite
 ]
        ADRCS   PC, LowCodeLocation     ;same as BCS LowCodeLocation

 [ Debug2
        mess    ,"PARTIAL",NL
 ]
;else write a fragment
        MOV     R3, #&100
60
        SUBS    R0, R0, #1
        MOVMI   R4, #0
        LDRPLB  R4, [R1], #1
        MOV     R4, R4, ASL #16
        SUBS    R0, R0, #1
        MOVMI   R8, #0
        LDRPLB  R8, [R1], #1
        ORR     R4, R4, R8, ASL #24
        STR     R4, HDCdataWrite
        SUBS    R3, R3, #2
        BGT     %BT60
        B       %BT45
 ]


 [ :LNOT: Top16Write
; this will all be copied down into RAM at LowCodeLocation
;
; In
;   r1->destination
;   IDE
;   RomReturn (in workspace) (don't use LR)
; Out
;    r1->place after transfer of 256 bytes
;    r0,r2-r9,LR trashed
;
        MACRO
        WriteIDEWord $reg, $treg
        MOV     $treg, $reg, ASL #16
        ORR     $treg, $treg, $treg, LSR #16
        STR     $treg, HDCdataWrite
        MOV     $treg, $reg, LSR #16
        ORR     $treg, $treg, $treg, ASL #16
        STR     $treg, HDCdataWrite
        MEND

ALowWriteCodeStart ROUT
        MOVS    R2, R1, LSL #31         ;NE <=> bit 0, CS <=> bit 1
        BNE     AWrite256OddAddress
        BCS     AWrite256HalfWordAddress

AWrite256WordAddress ROUT
        MOV     R0, #256
        B       %FT15

10
        LDMIA   R1!,{R2-R9}

        WriteIDEWord R2, LR
        WriteIDEWord R3, LR
        WriteIDEWord R4, LR
        WriteIDEWord R5, LR
        WriteIDEWord R6, LR
        WriteIDEWord R7, LR
        WriteIDEWord R8, LR
        WriteIDEWord R9, LR

15
        SUBS    R0, R0, #8*4
        BGE     %BT10

        CMP     R0, #-8*4
        LDREQ   pc, RomReturn

        ; 1/2-word aligned case - transfer the remaining 7 1/2 words
        LDMIA   R1!, {r2-r9}
        WriteIDEWord R2, LR
        WriteIDEWord R3, LR
        WriteIDEWord R4, LR
        WriteIDEWord R5, LR
        WriteIDEWord R6, LR
        WriteIDEWord R7, LR
        WriteIDEWord R8, LR
        MOV     LR, R9, ASL #16
        ORR     LR, LR, LR, LSR #16
        STR     LR, HDCdataWrite
        SUB     R1, R1, #2              ; correction for non-transfered 1/2-word

20
        LDR     PC, RomReturn


AWrite256HalfWordAddress
        BIC     R1, R1, #3

        LDR     R2, [R1], #4
        MOV     R2, R2, LSR #16
        ORR     R2, R2, R2, ASL #16
        STR     R2, HDCdataWrite ; store the odd halfword at the start

        MOV     R0, #256-2
        B       %BT15

AWrite256OddAddress ROUT
        BCS     AWrite256at4Nplus3

; so here we know the address is 4N + 1
        BIC     R1, R1, #3
        LDR     R6, [R1],#4             ; Pick up dcba to transfer dcb.
        MOV     LR, R6, LSR #8
        ORR     LR, LR, LR, ASL #16
        STR     LR, HDCdataWrite        ; Write out .cb. which is in LR as cbcb
        MOV     R6, R6, LSR #24         ; Put d... into r6 as ...d
        BL      AWrite252odd
        LDRB    R7, [R1], #1            ; get the odd byte at the end
        ORR     R2, R6, R7, LSL #8      ; combine it with the odd byte from AWrite256odd
        ORR     R2, R2, R2, ASL #16     ; turn it into dcdc
        STR     R2, HDCdataWrite
        LDR     PC, RomReturn

AWrite256at4Nplus3 ROUT
        LDRB    R6, [R1], #1            ; get the first odd byte
        BL      AWrite252odd
        LDR     R7, [R1], #3            ; Note , #3 to get r1 correctly advanced
        ORR     R2, R6, R7, LSL #8
        WriteIDEWord R2, LR
        LDR     PC, RomReturn

AWrite252odd    ROUT            ;entry/exit next byte in bottom byte of R6
        MOV     R0, #(256-4)/12
10
        SUBS    R0, R0, #1

        LDMIA   R1!,{R7-R9}

        ORR     R6, R6, R7, LSL #8
        WriteIDEWord R6, R2
        MOV     R6, R7, LSR #24

        ORR     R6, R6, R8, LSL #8
        WriteIDEWord R6, R2
        MOV     R6, R8, LSR #24

        ORR     R6, R6, R9, LSL #8
        WriteIDEWord R6, R2
        MOV     R6, R9, LSR #24

        BNE     %BT10
        MOV     PC, LR

ALowWriteCodeEnd
ALowWriteCodeSize * ALowWriteCodeEnd - ALowWriteCodeStart
 |
; this will all be copied down into RAM at LowCodeLocation
ALowWriteCodeStart ROUT
        MOVS    R2, R1, LSL #31         ;NE <=> bit 0, CS <=> bit 1
        BNE     AWrite256OddAddress
        BCS     AWrite256HalfWordAddress

AWrite256WordAddress ROUT
        MOV     R0, #256-4

        Align16  ALowWriteCodeStart
10                              ;DONT REORDER, ALIGNMENT MOD 16 TIME CRITICAL
        SUBS    R0, R0, #7*4

        LDMIA   R1!,{R2-R8}
        MOV     R9, R2, LSL #16
        STR     R9, HDCdataWrite

        MOV     R9, R3, LSL #16
        STR     R2, HDCdataWrite
        STR     R9, HDCdataWrite
        STR     R3, HDCdataWrite

        MOV     R9, R4, LSL #16
        STR     R9, HDCdataWrite
        STR     R4, HDCdataWrite
        MOV     R9, R5, LSL #16

        MOV     LR, R6, LSL #16
        STR     R9, HDCdataWrite
        STR     R5, HDCdataWrite
        STR     LR, HDCdataWrite

        MOV     R9, R7, LSL #16
        STR     R6, HDCdataWrite
        STR     R9, HDCdataWrite
        STR     R7, HDCdataWrite

        MOV     R9, R8, LSL #16
        STR     R9, HDCdataWrite
        STR     R8, HDCdataWrite
        BGT     %BT10

 [ T

; bump buffer pointer by 2 bytes in halfword aligned, not 4 - CDP

        LDRNE   R7,[R1],#2
        LDREQ   R7,[R1],#4
 |
        LDR     R7, [R1], #4
 ]
        MOV     R2, R7, LSL #16
        STR     R2, HDCdataWrite
        STREQ   R7, HDCdataWrite        ;EQ <=> 4n

        LDREQ   PC, RomReturn
        LDR     PC, RomReturn

AWrite256HalfWordAddress
        BIC     R1, R1, #3
        LDR     R2, [R1], #4

        STR     R2, HDCdataWrite ; store the odd halfword at the start
        MOV     R0, #256-4-2
        B       %BT10

AWrite256OddAddress ROUT
        BCS     AWrite256at4Nplus3
; so here we know the address is 4N + 1
        BIC     R1, R1, #3
        LDR     R6, [R1],#4      ;3 odd start bytes
        MOV     R2, R6, LSL #8
        STR     R2, HDCdataWrite
        MOV     R6, R6, LSR #8    ;odd byte in top half R6
        BL      AWrite252odd
        LDRB    R7, [R1], #1      ;get the odd byte at the end
        ORR     R2, R6, R7, LSL #24
        STR     R2, HDCdataWrite
        LDR     PC, RomReturn

AWrite256at4Nplus3 ROUT
        LDRB    R6, [R1],#1     ; get the first odd byte
        MOV     R6, R6, ASL #16
        BL      AWrite252odd
        LDR     R7, [R1],#3
        ORR     R2, R6, R7, LSL #24
        STR     R2, HDCdataWrite
        MOV     R2, R7, LSL #8
        STR     R2, HDCdataWrite
        LDR     PC, RomReturn

        Align16  ALowWriteCodeStart-4
AWrite252odd     ROUT            ;entry/exit next byte in top half R6
        MOV     R0, #(256-4)/12
10                              ;DONT REORDER, ALIGNMENT MOD 16 TIME CRITICAL
        SUBS    R0, R0, #1
        LDMIA   R1!,{R7-R9}
        ORR     R2, R6, R7, LSL #24
        STR     R2, HDCdataWrite

        MOV     R2, R7, LSL #8
        STR     R2, HDCdataWrite
        MOV     R7, R7, LSR #8
        ORR     R2, R7, R8, LSL #24

        MOV     R6, R8, LSL #8
        STR     R2, HDCdataWrite
        STR     R6, HDCdataWrite
        MOV     R8, R8, LSR #8

        ORR     R2, R8, R9, LSL #24
        STR     R2, HDCdataWrite
        MOV     R2, R9, LSL #8
        STR     R2, HDCdataWrite

        MOV     R6, R9, LSR #8
        BNE     %BT10
        MOV     PC, LR

ALowWriteCodeEnd
ALowWriteCodeSize * ALowWriteCodeEnd - ALowWriteCodeStart
 ]

 [ Top16Write

BLowWriteCodeStart ROUT
        MOVS    R2, R1, LSL #31         ;NE <=> bit 0, CS <=> bit 1
        BNE     BWrite256OddAddress
        BCS     BWrite256HalfWordAddress
BWrite256WordAddress ROUT
        MOV     R0, #256-4

        Align16  BLowWriteCodeStart
10                              ;DONT REORDER, ALIGNMENT MOD 16 TIME CRITICAL
        SUBS    R0, R0, #7*4
        LDMIA   R1!,{R3-R9}
        MOV     R2, R3, LSL #16
        STMIA   R10,{R2,R3}

        MOV     R2, R4, LSL #16
        STMIA   R10,{R2,R4}
        MOV     R2, R5, LSL #16
        STMIA   R10,{R2,R5}

        MOV     R2, R6, LSL #16
        STMIA   R10,{R2,R6}
        MOV     R2, R7, LSL #16
        STMIA   R10,{R2,R7}

        MOV     R2, R8, LSL #16
        STMIA   R10,{R2,R8}
        MOV     R2, R9, LSL #16
        STMIA   R10,{R2,R9}

        BGT     %BT10

 [ T

; bump buffer pointer by 2 bytes in halfword aligned, not 4 - CDP

        LDRNE   R7,[R1],#2
        LDREQ   R7,[R1],#4
 |
        LDR     R7, [R1], #4
 ]
        MOV     R2, R7, LSL #16
        STMEQIA  R10,{R2,R7}            ;EQ <=> 4n

        LDREQ   PC, RomReturn
        STR     R2, HDCdataWrite
        LDR     PC, RomReturn

BWrite256HalfWordAddress
        BIC     R1, R1, #3

        LDR     R2, [R1], #4
        STR     R2, HDCdataWrite ; store the odd halfword at the start
        MOV     R0, #256-4-2
        B       %BT10

BWrite256OddAddress ROUT
        BCS     BWrite256at4Nplus3
; so here we know the address is 4N + 1
        BIC     R1, R1, #3
        LDR     R6, [R1],#4      ;3 odd start bytes
        MOV     R2, R6, LSL #8

        STR     R2, HDCdataWrite
        MOV     R6, R6, LSR #8    ;odd byte in top half R6
        BL      BWrite252odd
        LDRB    R7, [R1], #1      ;get the odd byte at the end

        ORR     R2, R6, R7, LSL #24
        STR     R2, HDCdataWrite
        LDR     PC, RomReturn

        Align16  BLowWriteCodeStart-4
BWrite252odd     ROUT            ;entry/exit next byte in top half R6
        MOV     R0, #(256-4)/12
10                              ;DONT REORDER, ALIGNMENT MOD 16 TIME CRITICAL
        SUBS    R0, R0, #1
        LDMIA   R1!,{R7-R9}             ;ClBhBlAh ElDhDlCh GlFhFlEh
        ORR     R2, R6, R7, LSL #24     ;AhAlxxxx
        MOV     R3, R7, LSL #8          ;BhBlAh00

        MOV     R7, R7, LSR #8          ;00ClBhBl
        STMIA   R10,{R2,R3}
        ORR     R2, R7, R8, LSL #24     ;ChClBhBl
        MOV     R3, R8, LSL #8          ;DhDlCh00

        MOV     R8, R8, LSR #8          ;00ElDhDl
        STMIA   R10,{R2,R3}
        ORR     R2, R8, R9, LSL #24     ;EhElDhDl
        MOV     R3, R9, LSL #8          ;FhFlEh00

        MOV     R6, R9, LSR #8          ;00GlFhFl
        STMIA   R10,{R2,R3}
        BNE     %BT10
        MOV     PC, LR

BWrite256at4Nplus3 ROUT
        LDRB    R6, [R1],#1     ; get the first odd byte
        MOV     R6, R6, ASL #16
        BL      BWrite252odd
        LDR     R7, [R1],#3

        ORR     R2, R6, R7, LSL #24
        STR     R2, HDCdataWrite
        MOV     R2, R7, LSL #8
        STR     R2, HDCdataWrite

        LDR     PC, RomReturn

BLowWriteCodeEnd
BLowWriteCodeSize * BLowWriteCodeEnd - BLowWriteCodeStart


        !  0, "MEMC   Read code " :CC: :STR: ALowReadCodeSize
        !  0, "MEMC   Write code " :CC: :STR: ALowWriteCodeSize
        !  0, "MEMC1A Read code " :CC: :STR: BLowReadCodeSize
        !  0, "MEMC1A Write code " :CC: :STR: BLowWriteCodeSize

 ]
 [ ALowWriteCodeSize > ALowReadCodeSize
ALowCodeSize    * ALowWriteCodeSize
 |
ALowCodeSize    * ALowReadCodeSize
 ]
;Claim multiple of 8 words for low code as moved 8 words at a time
 [ ALowCodeSize :MOD: (8*4) = 0
AWorkSize * LowCodeLocation+ALowCodeSize
 |
AWorkSize * LowCodeLocation+ALowCodeSize+8*4-(ALowCodeSize :MOD: (8*4))
 ]
 [ Top16Write

 [ BLowWriteCodeSize > BLowReadCodeSize
BLowCodeSize    * BLowWriteCodeSize
 |
BLowCodeSize    * BLowReadCodeSize
 ]

;Claim multiple of 8 words for low code as moved 8 words at a time
 [ BLowCodeSize :MOD: (8*4) = 0
BWorkSize * LowCodeLocation+BLowCodeSize
 |
BWorkSize * LowCodeLocation+BLowCodeSize+8*4-(BLowCodeSize :MOD: (8*4))
 ]

SeekCase         ROUT ; 5 - seek for some reason
        BL      PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6

        BL      StartSeek2              ;R3,R6 -> R0,R1
        BL      WaitForSeekComplete
        B       TransferEnd


RestoreCase      ROUT ; 6 - restore to track zero
        BL      PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6

        MOV     R0, R3, ASL #8
        STR     R0, parameters
        MOV     R8, #2
        MOV     R7, #30*4       ;retry for 30s
10
        BL      TestEscapeStatus
        MOV     R0, #CRestore
 [ Debug2
        DLINE   "Restore request..."
 ]
        BL      CommandHDC
        BL      WaitForSeekComplete
        BL      GetResult       ;-> / R0,Z

 [ Debug2
        wrhex   R0
 ]

        SUBEQS  R8, R8, #1
        BEQ     TransferEnd

; new delay code code - CPU-independent

        Push    "R0"
        MOV     R0,#&3D000*2    ; 1/2 us units, approx 1/4 second
        BL      DoMicroDelay
        Pull    "R0"

        SUBS    R7, R7, #1      ;count a retry
        BNE     %BT10           ;loop if more retries
        MOV     R0, R0, LSR #2
        B       TransferEnd


VerifyCase ROUT
        BL      PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6
10
        BL      PrepareForTransfer      ;R3-R6 -> R0-R2,R7,R9,R10 / R8=blocks to verify
        MOV     R0, #CCheckData
        BL      CommandHDC

50
        BL      WaitForReq
        BL      GetResult               ;-> / R0,Z
        STRB    R0, completion
        LDR     R3, ContigEnd
        LDR     R2, discAddress
        SUB     R3, R3, R2
        MOV     R2, R8                  ;bytes to verify
        BNE     %FT90                   ;if error

        CMPS    R2, R3
        MOVHI   R2, R3
        BL      PrepareForNextBlock     ;R2 -> R0,R1,R3-R5 / LR
        SUB     R9, LR, #.-%BT10        ;set link for return to 10
        B       VerifyNextChunk         ;-> / R3-R6

90
;Set LS <=> error decrements sector count for error sector ie
;&40 Data field ECC error
;&44 Data field CRC error
;&48 Corrected ECC
;&4C Data field fatal error
;&60 No data address mark

        CMPS    R0, #&4C :SHR: 2
        RSBLSS  LR, R0, #&40 :SHR: 2
        TEQHIS  R0, #&60 :SHR: 2

        LDR     R1, HDCresult
        LDR     R1, HDCresult
        LDR     R1, HDCresult
        LDR     R1, HDCresult           ;result sector count
        BIC     R1, R1, #&00FF0000
        BIC     R1, R1, #&FF000000

        ADDLS   R1, R1, #1              ;adjust if error sector counted
        SUB     R2, R2, R1, LSL #8      ;bytes verified
        CMPS    R2, R3
        MOVHI   R2, R3
        BL      PrepareForNextBlock     ;R2 -> R0,R1,R3-R5
        LDRB    R0, completion
        B       WinnieError


WriteTrackCase   ROUT ; 4 - format a track
        BL      PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6
        BL      PrepareForTransfer              ;R3-R6 -> R0-R2,R7-R10
        LDRB    R0, WSecsPerTrk                 ;number of blocks to format
        AND     R5, R5, #2_111
        ORR     R0, R5, R0, ASL #16
        ORR     R0, R0, R3, ASL #8
        STR     R0, parameters

        MOV     R0, #CFormat
        BL      CommandHDC

; now poll the data xfer - hopefully only two "blocks"
50
        BL      WaitForReq
        TSTS    R0, #CED
        BLNE    PrepareForNextChunk     ;->R0 / R3-R6 if not a data transfer
        BNE     TransferEnd             ; as there's never a next cylinder

        ASSERT  WriteAdjust=WScatter+4
        ADR     R0, WScatter
        LDMIA   R0, {R3,R4}
55
        LDMIA   R3, {R1,R5}
        ADD     R1, R1, R4
        SUBS    R4, R4, R5
        BHS     %BT55

 [ Debug2
        wrhex   R1
        mess    ,"RAM",NL
 ]

        MOV     R0, #256
        MOV     R2, R0
90
        LDRB    R8, [R1], #1
        LDRB    R9, [R1], #1
        ORR     R8, R8, R9, ASL #8
        MOV     R8, R8, ASL #16
        STR     R8, HDCdataWrite
        SUBS    R0, R0, #2
        BGT     %BT90

        BL      WritePrepareNextBlock     ;R2 -> R0,R1,R3-R5
        B       %BT50

ReadIdCase ROUT
        BL      PrepareDriveBlockHeadCylinder   ;->R0-R2,R9 / R3-R6
        BL      PrepareForTransfer              ;R3-R6 -> R0-R2,R7-R10
        LDRB    R0, WSecsPerTrk                 ; number of blocks to read
        STR     R0, parameters + 4
        AND     R5, R5, #2_111
        ORR     R0, R5, R3, ASL #8
        STR     R0, parameters ; US/PHA

        MOV     R0, #CReadId
        BL      CommandHDC

; now poll the data xfer - hopefully only two "blocks" if that.
50
        BL      WaitForReq
        TSTS    R0, #CED
        BLNE    PrepareForNextChunk     ;->R0 / R3-R6 if not a data transfer
        BNE     TransferEnd             ; as there's never a next cylinder

        LDR     R1, WScatter
        LDR     R1, [R1]
        MOV     R0, #256
        MOV     R2, R0
90
        LDR     R9, HDCdataRead
        STRB    R9, [R1], #1
        MOV     R9, R9, LSR #8
        STRB    R9, [R1], #1
        SUBS    R0, R0, #2
        BGT     %BT90

        BL      PrepareForNextBlock     ;R2 -> R0,R1,R3-R5
        B       %BT50

        LTORG

; ===============
; ClaimWinnieIRQs
; ===============

ClaimWinnieIRQs ROUT
        Push    "R0-R4,LR"
        LDRB    R0, Winnies
        TEQS    R0, #0
        BEQ     %FT90
        LDR     R0, HDCPtr
        LDR     LR, = DefaultHDC + dataRead
        TEQS    R0, LR
        TEQNEP  PC, #I_bit :OR: SVC_mode        ;preserves NE
        MOVNE   R0, #IOC
        LDRNEB  LR, [R0, #IOCIRQMSKB]
        ORRNE   LR, LR, #podule_IRQ_bit
        STRNEB  LR, [R0, #IOCIRQMSKB]
 [ IOMD
        MOVEQ   R0, #IOMD_IDE_DevNo
 |
        MOVEQ   R0, #WinnieIRQ_DevNo
 ]
        MOVNE   R0, #Podule_DevNo
        baddr   R1, WinnieIRQ
        MOV     R2, SB
 [ fix_1
        LDRNE   R3, PollPtr
        MOVNE   R4, #WinPodIRQrequest
 |
        ADDNE   R3, SB, #:INDEX: PollPtr
        ASSERT  PollBits = PollPtr + 4
        LDMNEIA  R3, {R3,R4}
 ]
 [ Debug2
        wrhex   R0
        wrhex   R1
        wrhex   R2
        wrhex   R3, NE
        wrhex   R4, NE
 ]
        SWI     XOS_ClaimDeviceVector
 [ Debug2
        wrhex   R0,VS
        mess    ,"Claim IRQ",NL
 ]
        MOVVS   R0, #0
90
        STRB    R0, WinIRQ
        Pull    "R0-R4,PC",,^

        LTORG

; =================
; ReleaseWinnieIRQs
; =================

ReleaseWinnieIRQs ROUT
        Push    "R0-R4,LR"
        LDRB    R0, WinIRQ
 [ IOMD
        ASSERT  Podule_DevNo > IOMD_IDE_DevNo
        CMPS    R0, #IOMD_IDE_DevNo
 |
        ASSERT  Podule_DevNo > WinnieIRQ_DevNo
        CMPS    R0, #WinnieIRQ_DevNo
 ]
        baddr   R1, WinnieIRQ
        MOV     R2, SB
 [ fix_1
        LDRHI   R3, PollPtr
        MOVHI   R4, #WinPodIRQrequest
 |
        ADDHI   R3, SB, #:INDEX: PollPtr
        ASSERT  PollBits = PollPtr + 4
        LDMHIIA  R3, {R3,R4}
 ]
 [ Debug2
        wrhex   R0, HS
        wrhex   R1, HS
        wrhex   R2, HS
        wrhex   R3, HI
        wrhex   R4, HI
        mess    HS, "release IRQ",NL
 ]
        SWIHS   XOS_ReleaseDeviceVector
        MOV     R0, #0
        STRB    R0, WinIRQ
        Pull    "R0-R4,PC",,^

 ]
        END
