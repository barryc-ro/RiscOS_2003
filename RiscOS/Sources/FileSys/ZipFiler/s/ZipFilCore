; Iomega ZIP Driver Front End
;
; (C) ARM Designs for Acorn/VTi
;
; Written by Jason Tribbeck
;
; email: arm.designs@argonet.co.uk
;
; This code is designed to be compiled under AAsm 2.00, NOT ObjAsm.
; As a result, you will need "s.Registers" and "s.SWIs" to be with this file.

	GET	s.AcornHdr			; Use if Acorn is building
;	GET	s.Registers
;	GET	s.SWIs

; Load in some of the Zip driver specific parameters

;	GET	s.Zip
;	GET	s.Version
; Macros

	MACRO
	MENUTTL	$title
	=	"$title",0
	=	7,2,7,0,44,0
	MEND

	MACRO
	MENUITM	$name,$flags,$offset,$iconflags
	=	"$name",0
	ALIGN
	DCD	$flags,$offset,$iconflags
	MEND

; Flags

;EnableAutoBoot	*	0					; AutoBoot code is disabled
;EnableAutoBoot	*	1					; AutoBoot code is enabled

; Declare the variables in r12

	^	0,r12
sor12		#	0
TaskHandle	#	4					; Our task's handle
FormHandle	#	4					; The task handle for the formatter
IconHandle	#	4					; The icon's handle number
NextPollTime	#	4					; Get the next poll time (usually 0.5 second intervals)
OldZipStatus	#	4					; The old Zip status
LastDiscTime	#	4					; This is the time the disc was last inserted in drive
MessageBlock	#	20					; This is the MessageTrans file descriptor and open status
LastDiscBlock	#	52					; This is the previous discs's boot block
ZipDiscName	#	12					; This is the disc name currently in the drive
ZipSpriteName	#	12					; The Zip sprite name ("s<spname>")
MessageMemory	#	4					; This is a pointer to the message memory
EjectCount	#	4					; This is the previous eject count (used to find out about discs being ejected)
DiscPointer	#	4					; This is the pointer to the disc name
OldPercent	#	1					; This is the previous percentage
Dummy		#	3					; Dummy bytes
IconBlock	#	0					; Used to create the icon
MenuBlock	#	28*3+24*12+256				; 3 menus, 12 items, 256 bytes for indirected data
TempBlock	#	512					; Scratch memory (including a sector)
TaskBlock	#	256					; Used for Wimp_Poll
ZipStack	#	256					; A small ZipStack
eor12		#	0

lor12		*	eor12-sor12

; Constants
status_nodrive	*	1
status_nodisc	*	2
status_disc	*	3
status_noformat	*	4
status_printer	*	5
status_format	*	6

; Now the module itself

s
	DCD	start-s						; Start of module
	DCD	init-s						; Module initialisation
	DCD	final-s						; Module finalisation
	DCD	service-s					; Module service
	DCD	title-s						; Module title string
	DCD	help-s						; Module help string
	DCD	hcom-s						; Module *Commands

title	=	"ZipFiler",0
	ALIGN
 [ EnableAutoBoot = 0
help	=	"Zip Filer",9,"$vers ($date)",0
 |
help	=	"Zip Filer",9,"$vers ($date) (Auto-boot enabled)",0
 ]
	ALIGN

hcom	=	"Desktop_ZipFiler",0
	ALIGN
	DCD	desktop_zipfiler-s
	DCD	0
	DCD	zipfiler_help-s
	DCD	zipfiler_help-s
	DCD	0

zipfiler_help
	=	"Do not use *Desktop_ZipFiler, use *Desktop instead",0
	ALIGN

task	=	"TASK"

plor12	DCD	lor12						; Length of block to claim

init	STMFD	r13!,{r14}

	MOV	r0,#6						; Claim RMA
	LDR	r3,plor12					; That amount of memory to claim
	SWI	XOS_Module					; Claim it...
	LDMVSFD	r13!,{pc}					; ...unless there's an error

	STR	r2,[r12]					; Store the pointer
	MOV	r0,#0						; Zero byte

init_l1	STR	r0,[r2],#4					; Clear the allocated RMA space
	SUBS	r3,r3,#4					; Decrement count
	BGT	init_l1						; Until it's all gone
 [ standalonemessages
	BL	init_resfs
 ]
	LDMFD	r13!,{lr}					; Exit...
	BICS	pc,lr,#1<<28					; ...without causing an error

final	STMFD	r13!,{r14}
	LDR	r12,[r12]					; Get private workspace

	LDR	r0,TaskHandle
	CMP	r0,#0						; Have we registered?
	LDRGT	r1,task						; Yes - get TASK...
	SWIGT	XWimp_CloseDown					; ...and quit from the WIMP

	ADR	r0,MessageBlock
	SWI	XMessageTrans_CloseFile				; Close the message block

	LDR	r2,MessageMemory
	TEQ	r2,#0
	MOVNE	r0,#7
	SWINE	XOS_Module
	MOV	r2,#0
	STR	r2,MessageMemory

	SWI	XZipFS_Unlock

 [ standalonemessages
	BL	close_resfs
 ]
	LDMFD	r13!,{lr}
	BICS	pc,lr,#1<<28					; Exit cleanly...

 [ EnableAutoBoot = 0
service	TEQ	r1,#&27						; Is it a reset?
	TEQNE	r1,#&4b						; Or FilerStarting?
	TEQNE	r1,#&4c						; Or FilerStarted?
	TEQNE	r1,#&4f						; Or FilerDying?
	MOVNES	pc,lr						; Exit if any of these aren't occurring

	LDR	r12,[r12]

	TEQ	r1,#&27
	BEQ	service_reset					; If it's reset, do it
	TEQ	r1,#&4b
	BEQ	service_filerstarting				; If the filer's starting, do it
	TEQ	r1,#&4f
	BEQ	service_filerdying				; If the filer's dying, do it
 |
service	TEQ	r1,#&27						; Is it a reset?
	TEQNE	r1,#&49						; Or WimpStart
	TEQNE	r1,#&4a						; Or WimpStarted?
	TEQNE	r1,#&7e						; Or ShutDown
	MOVNES	pc,lr						; Exit if any of these aren't occurring

	LDR	r12,[r12]

	TEQ	r1,#&27
	BEQ	service_reset					; If it's reset, do it
	TEQ	r1,#&49
	BEQ	service_filerstarting				; If the filer's starting, do it
	TEQ	r1,#&7e
	BEQ	service_filerdying				; If the filer's dying, do it
 ]

service_filerstarted
	STMFD	r13!,{r14}
	LDR	r14,TaskHandle
	CMP	r14,#-1
	MOVEQ	r14,#0
	STREQ	r14,TaskHandle
	LDMFD	r13!,{pc}^

service_filerstarting
	STMFD	r13!,{lr}
	LDR	r14,TaskHandle					; Have we already registered?
	TEQ	r14,#0
	MOVEQ	r14,#-1
	STREQ	r14,TaskHandle					; We're about to start
	ADREQ	r0,hcom						; Point to our module's *command...
	MOVEQ	r1,#0						; ...and claim this call
	LDMFD	r13!,{pc}

desktop_zipfiler
	STMFD	r13!,{r14}
	MOV	r2,r0
	ADR	r1,title
	MOV	r0,#2
	SWI	XOS_Module					; Start our little module
	LDMFD	r13!,{pc}

start	LDR	r12,[r12]
	LDR	r0,TaskHandle					; Have we registered?
	CMP	r0,#0
	LDRGT	r1,task
	SWIGT	XWimp_CloseDown					; Yes, so quit now
	MOVGT	r0,#0
	STRGT	r0,TaskHandle

	MOV	r0,#201						; Only cope with RISC OS 2.01 or greater (personal reasons)
	LDR	r1,task
	ADR	r2,help
	SWI	XWimp_Initialise
	SWIVS	XOS_Exit
	STR	r1,TaskHandle					; Store our task handle

	ADRL	r13,ZipStack+256					; Point to end of ZipStack

	ADR	r0,zipfsvarname
	SUB	r1,r13,#256					; The ZipStack hasn't been used yet, so we'll be quite happy here!
	MOV	r2,#(1<<31)
	MOV	r3,#0
	MOV	r4,#3
	SWI	XOS_ReadVarVal					; Read the variable name

	TEQ	r2,#0						; Does it exist?
	BNE	zipfsvar_exists

	ADR	r0,zipfsvarname
	ADR	r1,zipfsvardefault
	MOV	r2,#zipfsvarend-zipfsvardefault
	MOV	r3,#0
	MOV	r4,#0
	SWI	XOS_SetVarVal					; Set the variable name
	MOVVS	r1,#0
	ADRVS	r2,zipfsvarname
	SWIVS	XWimp_ReportError
	ADR	r0,zipfsiconsprites
	SWI	XOS_CLI
	B	zipfsvar_exists

zipfsiconsprites
	=	"IconSprites Resources:Resources.IZipFS.!Sprites",0
zipfsvarname
	=	"IZipFSResources$Path",0
zipfsvardefault
	=	"Resources:Resources.IZipFS.",0
zipfsvarend
	ALIGN

zipfsvar_exists
 [ standalonemessages
	BL	init_resfs				; Initialise our ResourceFS memory
 ]
	ADR	r0,zipsprite
	ADR	r1,ZipSpriteName
	LDMIA	r0,{r2-r6}
	STMIA	r1,{r2-r6}

	MOV	r0,#-1
	STR	r0,IconHandle

	ADR	r0,zipname
	BL	set_icon

	MOV	r0,#0
	STR	r0,FormHandle					; The formatter isn't running

	ADR	r1,message_file
	SWI	XMessageTrans_FileInfo
	BVS	error_exit

	MOV	r3,r2
	MOV	r0,#6
	SWI	XOS_Module
	BVS	error_exit
	STR	r2,MessageMemory

	ADR	r0,MessageBlock
	ADR	r1,message_file
	LDR	r2,MessageMemory
	SWI	XMessageTrans_OpenFile
	BVS	error_exit

	MOV	r0,#1
	STR	r0,MessageBlock+16				; The file is open!

	B	zip_status

message_file
	=	"IZipFSResources:Messages",0
	ALIGN

poll_loop
	LDR	r2,NextPollTime
	ADRL	r1,TaskBlock
	MOV	r0,#0
	SWI	XWimp_PollIdle

	TEQ	r0,#0
	BEQ	zip_status

	TEQ	r0,#6						; Is it a click
	BEQ	icon_click

	TEQ	r0,#9						; Is it a menu clicked on?
	BEQ	menu_handle

	TEQ	r0,#19						; Is it an acknowledgement?
	BEQ	ack_handle

	TEQ	r0,#17
	TEQNE	r0,#18						; Is it any kind of message?
	BNE	poll_loop

	LDR	r2,[r1,#16]					; What message was it?

	SUB	r3,r2,#&40000					; Remove the WIMP SWI chunk
	TEQ	r3,#&c3						; Is it Message_TaskClosedown?
	BEQ	task_closedown					; Yes, so see if it's the formatter

	SUB	r3,r3,#&dd00					; Remove the ZipSWIChunk number
	TEQ	r3,#&80						; Message &4dd80 is disc changed
	BEQ	message_discchanged

	TEQ	r3,#&82						; Message &4dd83 is what is disc status
	BEQ	message_discstatus

	TEQ	r2,#0						; A quit?
	BNE	poll_loop
	B	exit_program

message_discchanged
	MOV	r0,#2
	SWI	XZipFS_DiscStatus
	MOV	r0,#0
	SWI	XZipFS_DiscStatus
	MOV	r0,#0
	STR	r0,LastDiscBlock
	STR	r0,LastDiscBlock+20
	STR	r0,LastDiscBlock+24
	BL	check_discname
	MOV	r1,#-2
;	ADR	r0,LastDiscBlock+22
	LDR	r0,DiscPointer
	BL	set_icon
	B	poll_loop

error_exit
	MOV	r1,#18
	ADR	r2,error_fataltext
	SWI	XWimp_ReportError				; Report the error

exit_program
	SWI	XZipFS_DismountAndEject
;	ADRL	r0,dismount_string
;	SWI	XOS_CLI

	LDR	r0,TaskHandle
	LDR	r1,task
	SWI	XWimp_CloseDown					; Quit the WIMP...
	MOV	r0,#0
	STR	r0,TaskHandle

	ADR	r0,MessageBlock
	SWI	XMessageTrans_CloseFile

	LDR	r2,MessageMemory
	TEQ	r2,#0
	MOVNE	r0,#7
	SWINE	XOS_Module
	MOV	r2,#0
	STR	r2,MessageMemory

;	SWI	XZipFS_Unlock
 [ standalonemessages
	BL	close_resfs
 ]
	SWI	XHourglass_On
	SWI	XZipFS_DismountAndEject
	ADRL	r0,dismount_disc
	SWI	XOS_CLI
	ADRL	r0,zss_closestring
	ADR	r2,TempBlock
	MOV	r3,#255
	BL	strcpy
	LDR	r0,DiscPointer
	MOV	r3,#255
	BL	strcpy
	ADRL	r0,zipfs_string
	MOV	r3,#255
	BL	strcpy
	ADR	r0,TempBlock
	SWI	XOS_CLI
	SWI	XOS_CLI
	SWI	XZipFS_Eject
	SWI	XHourglass_Off

	ADR	r3,ZipModule
	SWI	XOS_ExitAndDie					; ...and die

ZipModule
	=	"IZipFS",0
	ALIGN

zipname
	=	"Zip :0",0
	ALIGN
zipsprite
	=	"snozipdrive",0
	ALIGN

icon_flags
	DCD	&1700310b					; Click, indirect, sprite, text, HCentred
icon_priority
	DCD	&10000000+(ZipFSNumber<<20)

error_fataltext
	=	"Fatal error from "
error_text
	=	"Zip Filer",0
	ALIGN

error_pollok
	MOV	r1,#0
	ADR	r2,error_text
	SWI	XWimp_ReportError				; Produce error, with "OK" box
	B	poll_loop

error_pollcancelHG
	MOV	r11,r0						; Temporarily store r0
	SWI	XHourglass_Off					; Turn off the hourglass
	MOV	r0,r11						; And restore it, ready for error_pollcancel
error_pollcancel
	MOV	r1,#1
	ADR	r2,error_text
	SWI	XWimp_ReportError				; Produce error with "Cancel" box
	B	poll_loop

zipfs_name
	=	":0",0
	ALIGN

zipfs_root
	=	"Filer_OpenDir IZipFS::",0
zipfs_string
	=	".$",0
	ALIGN

check_discname
	STMFD	r13!,{r1-r5,lr}
	MOV	r0,#0
	SWI	XZipFS_DiscStatus
	STR	r3,DiscPointer
	TEQ	r1,#2
	MOVEQ	r0,#0
	TEQ	r0,#2
	MOVNE	r0,#-1
	LDMNEFD	r13!,{r1-r5,pc}

	LDR	r2,EjectCount
	TEQ	r4,r2
	MOVEQ	r0,#0
	LDMEQFD	r13!,{r1-r5,pc}

	STR	r4,EjectCount
	MOV	r0,#1
	LDMFD	r13!,{r1-r5,pc}^

set_icon
	STMFD	r13!,{r0-r9,lr}
	CMP	r1,#-2
	MOVEQ	r9,#10
	MOVNE	r9,#11
	ADR	r1,ZipDiscName
	MOV	r2,#0
	MOV	r5,#0
seticnl	LDRB	r3,[r0,r2]
	TEQ	r2,r9
	MOVEQ	r3,#0
	CMP	r3,#32
	MOVLE	r3,#0
	LDRB	r4,[r1,r2]
	EOR	r4,r4,r3
	ORR	r5,r5,r4
	STRB	r3,[r1,r2]
	ADDGT	r2,r2,#1
	BGT	seticnl

;	TEQ	r5,#0
;	LDMEQFD	r13!,{r0-r9,pc}^

	STMFD	r13!,{r0-r9}
	LDR	r9,OldZipStatus
	STR	r9,TaskBlock+20
	ADR	r0,ZipDiscName
	ADRL	r1,TaskBlock+24
	LDMIA	r0,{r2-r7}
	STMIA	r1,{r2-r7}
	MOV	r0,#40
	STR	r0,TaskBlock
	MOV	r0,#0
	STR	r0,TaskBlock+4
	STR	r0,TaskBlock+8
	STR	r0,TaskBlock+12
	LDR	r0,zipmnumb
	STR	r0,TaskBlock+16
	ADRL	r1,TaskBlock
	MOV	r2,#0
	MOV	r3,#0
	MOV	r0,#17
	SWI	XWimp_SendMessage			; Send a message to say that we've changed status!
	LDMFD	r13!,{r0-r9}

	TEQ	r5,#0
	LDMEQFD	r13!,{r0-r9,pc}^

	MOV	r4,r2,LSL#4

	MOV	r0,#1
	MOV	r2,#0
	SWI	XWimp_TextOp
	MOVVC	r4,r0

	CMP	r4,#96
	MOVLT	r4,#96

	ADR	r1,IconBlock
	MOV	r0,#-1
	STR	r0,[r1]
	LDR	r0,IconHandle
	STR	r0,[r1,#4]
	CMP	r0,#-1
	SWINE	XWimp_DeleteIcon
	MOV	r0,#-6
	ADR	r1,IconBlock
	MOV	r2,#0
	MOV	r3,#-16
	MOV	r5,#60
	LDR	r6,icon_flags
	ADR	r7,ZipDiscName					; "Zip :0"
	ADR	r8,ZipSpriteName				; "Szipdrive"
	MOV	r9,#12						; Length
	STMIA	r1,{r0,r2-r9}
	LDR	r0,icon_priority
	SWI	XWimp_CreateIcon				; Create the icon
	STR	r0,IconHandle

	LDMFD	r13!,{r0-r9,pc}^

icon_click
	LDR	r0,[r1,#8]					; What type of click was it?
	TEQ	r0,#2						; Menu?
	BEQ	icon_menu					; Yup

	LDR	r0,FormHandle					; Is the formatter running?
	TEQ	r0,#0
	BNE	poll_loop					; Yes, so discount this bit

	LDR	r0,OldZipStatus
	TEQ	r0,#status_disc
	BEQ	icon_hd

icon_notready
	CMP	r0,#status_nodisc
	ADREQ	r1,nodisc_str
	ADRLT	r1,nodrive_str
	ADRGT	r1,unform_str
	TEQ	r0,#status_printer
	ADREQ	r1,printer_str
	TEQ	r0,#status_format
	ADREQ	r1,format_str

	ADR	r0,MessageBlock
	MOV	r2,#0
	MOV	r3,#0
	MOV	r4,#0
	MOV	r5,#0
	MOV	r6,#0
	MOV	r7,#0
	SWI	XMessageTrans_Lookup

	SUB	r0,r2,#4
	B	error_pollcancel

nodisc_str
	=	"CNoDisc",0
nodrive_str
	=	"CNoDrive",0
unform_str
	=	"CUnform",0
printer_str
	=	"CPrinter",0
format_str
	=	"CFormat",0
	ALIGN

icon_hd
	SWI	XZipFS_DiscFormat
	CMP	r0,#-1
	MOVEQ	r0,#status_noformat
	BEQ	icon_notready

	BL	check_discname

;	TEQ	r0,#0						; It returns 0 for discs being named the same
;	BLNE	dismount_disc
;	ADRNEL	r0,dismount_string
;	SWINE	XOS_CLI						; Dismount the disc as it's a new disc

;	ADR	r0,zipfs_name
;	ADR	r1,TempBlock+64
;	SWI	XZipFS_DescribeDisc				; Get the disc details (name, etc).
;	BVS	error_pollcancel				; If there's an error, reply it, and then return

	ADR	r2,TempBlock
	ADR	r0,zipfs_root
	MOV	r3,#255
	BL	strcpy						; Copy the string
	LDR	r0,DiscPointer
;	ADRL	r0,TempBlock+22+64
;	MOV	r3,#10
	BL	strcpy						; And the disc name
	ADRL	r0,zipfs_string
	MOV	r3,#255
	BL	strcpy						; And the path name
	ADR	r0,TempBlock
	SWI	XOS_CLI						; Open the disc's root
	BVS	error_pollcancel
	B	poll_loop

service_reset
	STMFD	r13!,{r14}
	MOV	r14,#0
	STR	r14,TaskHandle					; All's fair when the machine's reset
	LDMFD	r13!,{pc}

;service_filerstarted
;	STMFD	r13!,{lr}
;	LDR	r14,TaskHandle
;	CMP	r14,#-1						; Have we tried to register?
;	MOVEQ	r14,#0
;	STREQ	r14,TaskHandle					; Yes - so it must have failed
;	LDMFD	r13!,{pc}

service_filerdying
	STMFD	r13!,{r0-r1,lr}
	LDR	r0,TaskHandle
	CMP	r0,#0
	LDRGT	r1,task
	SWIGT	XWimp_CloseDown					; a la final code
	MOV	r0,#0
	STR	r0,TaskHandle					; Clear TaskHandle as we're no longer registered
	SWI	XZipFS_DismountAndEject				; Dismount the disc while we're at it...
	LDMFD	r13!,{r0-r1,pc}

strcpy
; r0 is ^ source
; r2 is ^ destination
; r3 is max. length to copy
; returns
; r0 as ^ source+1
; r2 as ^ terminating 0 in string
; r3 undefined
	STMFD	r13!,{r14}
strcpyl	LDRB	r14,[r0],#1					; Get the byte
	STRB	r14,[r2],#1					; Store it
	CMP	r14,#32						; Was it a terminator?
	SUBLT	r2,r2,#1					; Make sure it points to terminator
	LDMLTFD	r13!,{pc}
	SUBS	r3,r3,#1					; Decrement number to copy downwards
	BGT	strcpyl						; Until we reach the end
	LDMFD	r13!,{pc}

strcpy2
; As strcpy, but copies upto the first space
	STMFD	r13!,{r14}
strcp2l	LDRB	r14,[r0],#1					; Get the byte
	STRB	r14,[r2],#1					; Store it
	CMP	r14,#32						; Was it a terminator?
	SUBLE	r2,r2,#1					; Make sure it points to terminator
	LDMLEFD	r13!,{pc}
	SUBS	r3,r3,#1					; Decrement number to copy downwards
	BGT	strcp2l						; Until we reach the end
	LDMFD	r13!,{pc}

titledef
	MENUTTL	"MT"
	MENUITM	"M0",0,28*1+24*8,&07000121
	MENUITM	"M1",0,0,&07000121
	MENUITM	"M2",0,0,&07000121
	MENUITM	"M3",0,4,&07400121
	MENUITM	"M4",0,0,&07000121
	MENUITM	"M5",0,28*2+24*9,&07000121
	MENUITM	"M6",0,0,&07000121
	MENUITM	"M7",128,0,&07000121
	MENUTTL	"M0T"
	MENUITM	"M00",132,0,&07000121
	MENUTTL	"M5T"
	MENUITM	"M50",2,0,&07000121
	MENUITM	"M51",0,0,&07000121
	MENUITM	"M52",128,0,&07000121
	DCD	0

icon_menu
	ADRL	r0,TempBlock+480
	STR	r0,MenuBlock+28*2+24*8+12
	ADR	r0,namevalid
	STR	r0,MenuBlock+28*2+24*8+16
	MOV	r0,#11
	STR	r0,MenuBlock+28*2+24*8+20

	ADR	r0,MessageBlock
	ADR	r1,titledef
	ADR	r2,MenuBlock
	MOV	r3,#28*3+24*12+256
	SWI	XMessageTrans_MakeMenus
	BVS	error_pollcancel

	SWI	XZipFS_DiscFormat
	TEQ	r0,#0
	LDRNE	r0,MenuBlock+28*1+24*0+8
	ORRNE	r0,r0,#1<<22
	STRNE	r0,MenuBlock+28*1+24*0+8

	LDR	r0,OldZipStatus
	TEQ	r0,#status_disc
	BNE	im_forcefade

	LDR	r0,FormHandle
	TEQ	r0,#0
	BEQ	im_notfaded

im_forcefade
	ADR	r0,MenuBlock+28*1+24*0+8
	MOV	r1,#6
im_fademenu
	LDR	r2,[r0]
	ORR	r2,r2,#1<<22
	STR	r2,[r0],#24
	SUBS	r1,r1,#1
	BPL	im_fademenu

im_notfaded
	ADR	r0,ZipDiscName
	ADRL	r3,TempBlock+480
	LDMIA	r0,{r0-r2}
	STMIA	r3,{r0-r2}

	MOV	r0,#-1
	SWI	XZipFS_WriteProtect
	CMP	r0,#2
	ADRLT	r0,MenuBlock+28*3+24*9
	ADREQ	r0,MenuBlock+28*3+24*10
	ADRGT	r0,MenuBlock+28*3+24*11
	LDR	r1,[r0]
	ORR	r1,r1,#1
	STR	r1,[r0]

	SWI	XOS_Mouse					; Get mouse coordinates
	SUB	r2,r0,#64					; Left a bit
	MOV	r3,#96+44*8					; 8 items @ 44 pixels each
	ADR	r1,MenuBlock

	SWI	XWimp_CreateMenu				; Create the menu
	BVS	error_pollcancel				; (Whoops!)
	B	poll_loop

namevalid
	=	"a~$&%@^:.#*",34," |",0
	ALIGN

menu_handle
	ADD	r1,r1,#128
	SWI	XWimp_GetPointerInfo
	LDR	r11,[r1,#8]
	SUB	r1,r1,#128

	LDR	r0,[r1,#0]					; Get which item was clicked on
	CMP	r0,#8
	ADDCC	pc,pc,r0,LSL#2					; Jump to the handler
	B	menu_end					; Don't know what happened!

	B	namedisk
	B	dismount
	B	format
;	B	backup
	B	poll_loop
	B	verify
	B	protect
	B	free
	B	exit_program

dismount
;	ADRL	r0,filer_closestring				; Dismount the disc
;	SWI	XOS_CLI
;	MOV	r0,#0
;	ADRL	r1,TaskBlock
;	SWI	XWimp_Poll
;	ADRL	r0,dismount_string				; Dismount the disc
;	SWI	XOS_CLI
;	MOV	r0,#0
;	ADRL	r1,TaskBlock
;	SWI	XWimp_Poll
;	BL	dismount_discclear
;	BVS	error_pollcancel				; Whoops
;	SWI	XZipFS_Eject					; And eject it
;	BVS	error_pollcancel
;	MOV	r1,#status_nodisc
;	BL	zip_setstatus
;	SWI	XOS_ReadMonotonicTime
;	ADD	r0,r0,#200
;	STR	r0,NextPollTime
	SWI	XZipFS_DismountAndEject
	B	menu_end

menu_end
	TEQ	r11,#1						; Was it adjust?
	BNE	poll_loop					; Nope
	B	icon_menu					; Recreate it then!

;zipbackup
;	=	"<ZipFiler$Dir>.!ZipUtils -backup",0
;	ALIGN
zipformat
	=	"IZipFSResources:!ZipUtils -format",0
	ALIGN
zipverify
	=	"IZipFSResources:!ZipUtils -verify",0
	ALIGN

format	ADR	r0,zipformat
	SWI	Wimp_StartTask
	BVS	error_pollcancel
	STR	r0,FormHandle
	B	menu_end

verify	ADR	r0,zipverify
	SWI	Wimp_StartTask
	BVS	error_pollcancel
	STR	r0,FormHandle
	B	menu_end

;backup	ADR	r0,zipbackup
;	SWI	Wimp_StartTask
;	BVS	error_pollcancel
;	STR	r0,FormHandle
;	B	menu_end

diskwp
	ADR	r0,wpe
	B	error_pollcancelHG

wpe	DCD	0
	=	"You cannot change the name of a write-protected Zip disc",0
	ALIGN

zip_name
	=	"-IZipFS-namedisk :0 ",0
	ALIGN

namedisk
	LDR	r0,[r1,#4]					; Was the actual menu item clicked?
	TEQ	r0,#0
	BNE	menu_end

	LDRB	r0,TempBlock+480				; Was a valid string entered
	CMP	r0,#32
	BLT	namedisk_error					; No, so produce an error to that effect

	SWI	XHourglass_On

	MOV	r0,#-1
	SWI	XZipFS_WriteProtect
	TST	r0,#2
	BNE	diskwp

	BL	dismount_discclear
;	ADRL	r0,dismount_string
;	SWI	XOS_CLI						; Dismount the disc
	BVS	error_pollcancelHG

	ADRL	r2,TaskBlock
	ADR	r0,zip_name
	MOV	r3,#255
	BL	strcpy

	ADRL	r0,TempBlock+480
	MOV	r3,#255
	BL	strcpy

	ADRL	r0,TaskBlock
	SWI	XOS_CLI						; Name it
	BVS	error_pollcancelHG

	BL	dismount_discclear
;	ADRL	r0,dismount_string
;	SWI	XOS_CLI						; And dismount it for luck!
	BVS	error_pollcancelHG

	BL	check_discname
	LDR	r0,DiscPointer
;	ADR	r0,LastDiscBlock+22
	MOV	r1,#-2
	BL	set_icon

	SWI	XHourglass_Off

	B	menu_end

namedisk_error
	ADR	r0,namedisk_errorstr
	B	error_pollcancel

namedisk_errorstr
	DCD	0
	=	"Zip disc must be given a name",0
	ALIGN

protect
	LDR	r0,[r1,#4]					; What protection was it?
	TEQ	r0,#0						; Unprotect
	BEQ	uprotect
	TEQ	r0,#1						; Write protect
	BEQ	wprotect
	TEQ	r0,#2						; MIN protect
	BEQ	mprotect
	B	menu_end

protect_error
	ADR	r0,protect_errorstr
	B	error_pollcancel

protect_errorstr
	DCD	0
	=	"The Zip disc has been write protected with a password",0
	ALIGN

wprotect
	MOV	r0,#-1
	SWI	XZipFS_WriteProtect
	BVS	error_pollcancel
	TEQ	r0,#2
	BEQ	menu_end
	TEQ	r0,#3
	BLEQ	MINunprotect
	TEQ	r0,#0
	BNE	protect_error
	MOV	r0,#2
	MOV	r1,#0
	SWI	XZipFS_WriteProtect
	BVS	error_pollcancel
	MOV	r0,#-1
	SWI	XZipFS_WriteProtect
	TEQ	r0,#2
	BNE	protect_error
	B	menu_end

uprotect
	MOV	r0,#-1
	SWI	XZipFS_WriteProtect
	BVS	error_pollcancel
	TEQ	r0,#3
	BLEQ	MINunprotect
	TEQ	r0,#0
	BEQ	menu_end
	MOV	r0,#0
	MOV	r1,#0
	SWI	XZipFS_WriteProtect
	MOV	r0,#-1
	SWI	XZipFS_WriteProtect
	TEQ	r0,#0
	BNE	protect_error
	B	menu_end

mprotect
	MOV	r0,#-1
	SWI	XZipFS_WriteProtect
	BVS	error_pollcancel
	TEQ	r0,#2
	BLEQ	unprotect
	TEQ	r0,#3
	BLEQ	MINunprotect
	TEQ	r0,#0
	BNE	protect_error
	BL	make_minprotect
	MOV	r0,#2
	ADRL	r1,TaskBlock
	SWI	XZipFS_WriteProtect
	MOV	r0,#-1
	SWI	XZipFS_WriteProtect
	TEQ	r0,#3
	BNE	protect_error
	B	menu_end

MINunprotect
	STMFD	r13!,{r14}
	BL	make_minprotect
	ADRL	r1,TaskBlock
	MOV	r0,#0
	SWI	XZipFS_WriteProtect
	LDMVSFD	r13!,{r14}
	BVS	error_pollcancel
	MOV	r0,#-1
	SWI	XZipFS_WriteProtect
	LDMFD	r13!,{pc}^

unprotect
	MOV	r1,#0
	MOV	r0,#0
	SWI	XZipFS_WriteProtect
	BVS	error_pollcancel
	MOV	r0,#-1
	SWI	XZipFS_WriteProtect
	MOVS	pc,lr

make_minprotect
	MOV	r0,#2
	SWI	XOS_ReadSysInfo
	ADRL	r1,TaskBlock
	MOV	r0,r3
	MOV	r2,#12
	SWI	XOS_ConvertHex8
	MOV	r0,r4
	SWI	XOS_ConvertHex2
	MOVS	pc,lr

task_closedown
	LDR	r0,[r1,#4]					; Was it the formatter?
	LDR	r2,FormHandle
	TEQ	r0,r2
	MOVEQ	r0,#0						; Yes, so clear it's state
	STREQ	r0,FormHandle
	B	poll_loop

zip_nodrive
	=	"snozipdrive",0
	ALIGN
zip_nodisc
	=	"snozipdisc",0
	ALIGN
zip_disc
	=	"szipdrive",0
	ALIGN

gs_command
	DCD	&c003
	DCD	255
rc_command
	DCD	&c025
	DCD	0
	DCD	0
rs_command
	DCD	&02c006
	DCD	255

ms_command
	DCD	&d015
	DCD	18

ms_data	DCD	&08000000
	DCD	0
	DCD	&00020000
	DCD	&005c042f
	DCD	0
	ALIGN

zip_status
	MOV	r0,#1
	SWI	XZipFS_DiscStatus
	TEQ	r1,#2
	MOVEQ	r0,#3
	TEQ	r1,#8
	MOVEQ	r0,#4
	STR	r3,DiscPointer
;	MOV	r4,r1

;	TEQ	r4,#0
;	TEQNE	r4,#1
;	BNE	poll_loop

; r0 is 0 for no device
;	1 for no disc
;	2 for disc present

	TEQ	r0,#0
	MOVEQ	r1,#status_nodrive
	TEQ	r0,#1
	MOVEQ	r1,#status_nodisc
	TEQ	r0,#2
	MOVEQ	r1,#status_disc
	TEQ	r0,#3
	MOVEQ	r1,#status_printer
	TEQ	r0,#4
	MOVEQ	r1,#status_format

zip_st	BL	zip_setstatus
	B	poll_loop

zss_closestring
	=	"Filer_CloseDir IZipFS::",0
	ALIGN

zip_setstatus
	STMFD	r13!,{lr}
	SWI	XHourglass_On

	ADR	r0,zip_disc

	TEQ	r1,#status_nodrive
	TEQNE	r1,#status_printer
	TEQNE	r1,#status_format
	ADREQ	r0,zip_nodrive
	TEQ	r1,#status_nodisc
	ADREQ	r0,zip_nodisc
;	TEQ	r1,#status_disc
;	ADREQ	r0,zip_disc
	MOV	r9,r1

;	BNE	zss_nochangecheck

;	STMFD	r13!,{r0}
;	BL	check_discname
;	TEQ	r0,#0
;	LDMFD	r13!,{r0}

;	BNE	zip_statusset0

zss_nochangecheck
	TEQ	r1,#status_format
	BEQ	zss_makeformat

	LDR	r8,OldZipStatus
	TEQ	r8,r1
	BEQ	zip_statusset2

	STR	r1,OldZipStatus

	TEQ	r1,#status_printer
	BNE	zss_notprinter

	STMFD	r13!,{r0-r5}
	ADR	r0,zss_closestring
	ADR	r2,TempBlock
	MOV	r3,#255
	BL	strcpy
	LDR	r0,DiscPointer
	MOV	r3,#255
	BL	strcpy
	ADRL	r0,zipfs_string
	MOV	r3,#255
	BL	strcpy
	ADR	r0,TempBlock
	SWI	XOS_CLI
;	ADRL	r0,dismount_string
;	SWI	XOS_CLI
;	MOV	r0,#2
;	SWI	XZipFS_DiscStatus
	LDMFD	r13!,{r0-r5}

zss_notprinter

;	SWI	&20100+7

;	TEQ	r1,#status_disc
;	SWIEQ	XZipFS_Lock

 [ EnableAutoBoot = 1
	TEQ	r8,#status_disc
	MOVEQ	r2,r0
	SWIEQ	XOS_ReadMonotonicTime
	STREQ	r0,LastDiscTime					; This was when the disc was last in the drive
	MOVEQ	r0,r2
 ]

zip_statusset0
	STR	r1,OldZipStatus
	ADR	r2,ZipSpriteName
	MOV	r3,#32
	BL	strcpy
	LDR	r0,IconHandle
	ADR	r1,TempBlock
	STR	r0,[r1,#4]
	MOV	r0,#-2
	STR	r0,[r1,#0]
	MOV	r0,#0
	STR	r0,[r1,#8]
	STR	r0,[r1,#12]
	SWI	XWimp_SetIconState

	TEQ	r9,#status_disc
	BNE	zip_statusset1

	BL	check_discname

	TEQ	r0,#0
	BLNE	dismount_disc
;	ADRNEL	r0,dismount_string			; Dismount the disc if it's a new disc
;	SWINE	XOS_CLI

 [ EnableAutoBoot = 1

	SWI	XOS_ReadMonotonicTime
	LDR	r1,LastDiscTime
	SUB	r0,r0,r1
	CMP	r0,#1000				; Was the disc inserted before 10 seconds?
	BLT	zip_statusset1				; Yes, so don't check the AutoBoot code

	MOV	r0,#5
	ADRL	r1,zipbootfile
	SWI	XOS_File
	TEQ	r0,#1
	BNE	zip_statusset1

	STMFD	r13!,{r2-r4}				; Store load, exec and length parameters
	MOV	r2,#&c00
	ADR	r3,TempBlock
	MOV	r4,#&200
	SWI	XZipFS_ReadOp				; Read the block at &c00
	LDMFD	r13!,{r2-r4}				; Restore load, exec and length parameters

	LDR	r0,TempBlock+&1b0			; Read the hardware specific information!
	TEQ	r0,r2,ROR#13
	BNE	zip_statusset1				; Oops the load address is incorrect!

	LDR	r0,TempBlock+&1b4
	TEQ	r0,r3,ROR#3
	BNE	zip_statusset1				; Oops the exec address is incorrect!

	LDR	r0,TempBlock+&1b8
	TEQ	r0,r4,ROR#21
	BNE	zip_statusset1				; Oops the length is incorrect!

	ADR	r0,zipbootfile
	SWI	XWimp_StartTask
 ]
zip_statusset1
;	TEQ	r8,#status_disc
;	BNE	zip_statusset
zip_statusset
	MOV	r0,#0
	SWI	XZipFS_BootChanged
	TEQ	r9,#status_disc
	LDREQ	r0,DiscPointer
;	ADREQ	r0,LastDiscBlock+22
	BNE	zss_noname
	LDRB	r1,[r0]
	CMP	r1,#32					; Is okay as a name?
	MOVGT	r1,#-2
	BGT	zss_hasname				; Yup, so continue
	MOV	r9,#status_noformat
zss_noname
	CMP	r9,#status_nodisc
	ADRLTL	r1,nodrive_text
	ADREQL	r1,nodisc_text
	ADRGTL	r1,unformatted_text
	TEQ	r9,#status_printer
	ADREQL	r1,printer_text
	TEQ	r9,#status_format
	BEQ	zss_makeformat
	ADR	r0,MessageBlock
	MOV	r2,#0
	MOV	r3,#0
	MOV	r4,#0
	MOV	r5,#0
	MOV	r6,#0
	MOV	r7,#0
	SWI	XMessageTrans_Lookup
	MOV	r0,r2
zss_hasname
	BL	set_icon
	B	zip_statusset2

zss_makeformat
	MOV	r0,#0
	SWI	XZipFS_DiscStatus
	MOV	r0,#100					; We want it in %ge terms
	MUL	r0,r2,r0
	ADD	r0,r0,#32768
	MOV	r0,r0,LSR#16				; Right shift to make the value from 0 to 100.
;	MOV	r0,r2
	LDRB	r1,OldPercent
	ADD	r2,r0,#100
	TEQ	r2,r1
	STRB	r2,OldPercent
	BEQ	zip_isformatting
	LDRB	r1,OldZipStatus
	TEQ	r1,#status_format
	MOV	r1,#status_format
	STRB	r1,OldZipStatus
	BEQ	zip_changeformat
	ADRL	r1,TempBlock
	MOV	r2,#512
	SWI	XOS_ConvertInteger1
	MOV	r0,#'%'
	STRB	r0,[r1],#1
	MOV	r0,#0
	STRB	r0,[r1],#1
	ADRL	r0,TempBlock
	BL	set_icon
	MOV	r0,#2
	SWI	XZipFS_DiscStatus
zip_isformatting

zip_statusset2
	SWI	XOS_ReadMonotonicTime
	ADD	r0,r0,#25
	STR	r0,NextPollTime

	SWI	XHourglass_Off
	LDMFD	r13!,{pc}

zip_changeformat
	ADRL	r1,ZipDiscName
	MOV	r2,#512
	SWI	XOS_ConvertInteger1
	MOV	r0,#'%'
	STRB	r0,[r1],#1
	MOV	r0,#0
	STRB	r0,[r1],#1
	ADRL	r1,TempBlock
	MOV	r0,#-2
	STR	r0,[r1,#0]
	LDR	r0,IconHandle
	STR	r0,[r1,#4]
	MOV	r0,#0
	STR	r0,[r1,#8]
	STR	r0,[r1,#8]
	SWI	XWimp_SetIconState
	B	zip_isformatting

zipmnumb
	DCD	ZipSWIChunk+1				; &4dd81 is Message_IZipFSStatusChanged

nodrive_text
	=	"NoDrive",0
nodisc_text
	=	"NoDisc",0
unformatted_text
	=	"Unformatted",0
printer_text
	=	"Busy",0

zipbootfile
	=	"IZipFS::0.$.__AutoBoot",0
	ALIGN

free	ADR	r3,reopenblock
	ADRL	r1,TaskBlock
	LDMIA	r3,{r3-r7}
	STMIA	r1,{r3-r7}
	MOV	r0,#18
	MOV	r2,#0
	MOV	r3,#0
	SWI	XWimp_SendMessage
	B	menu_end

reopenblock
	DCD	20,0,0,0,&4dd83

filer_closestring
	=	"Filer_CloseDir IZipFS::0.$",0
	ALIGN

dismount_string
	=	"-IZipFS-Dismount :0",0
	ALIGN

; dismount_discclear clears the disc check buffer, so the next change is forced to be a new disc

dismount_discclear
	STMFD	r13!,{r1-r2}
	ADR	r0,LastDiscBlock
	MOV	r1,#52
	MOV	r2,#0
ddcloop	STR	r2,[r0],#4
	SUBS	r1,r1,#4
	BGT	ddcloop
	MOV	r0,#2
	SWI	XZipFS_DiscStatus
	LDMFD	r13!,{r1-r2}

; dismount_disc just dismounts the disc (removes the icon from the iconbar)

dismount_disc
	ADR	r0,dismount_string
	SWI	XOS_CLI
	MOV	pc,lr

ack_handle
	LDR	r0,[r1,#16]
	SUB	r0,r0,#&40000
	SUB	r0,r0,#&dd00
	TEQ	r0,#&83
	BNE	poll_loop

openfree
	ADR	r0,showfree
	SWI	XWimp_StartTask
	BVS	error_pollcancel
	B	poll_loop

showfree
	=	"IZipFSResources:ZipFree",0
	ALIGN

message_discstatus
;	LDR	r9,OldZipStatus
;	STR	r9,TaskBlock+20
;	ADR	r0,ZipDiscName
;	ADRL	r1,TaskBlock+24
;	LDMIA	r0,{r2-r7}
;	STMIA	r1,{r2-r7}
;	MOV	r0,#40
;	STR	r0,TaskBlock
;	MOV	r0,#0
;	STR	r0,TaskBlock+8
;	STR	r0,TaskBlock+12
;	LDR	r0,zipmnumb
;	STR	r0,TaskBlock+16
;	ADRL	r1,TaskBlock
;	LDR	r2,[r1,#4]
;	MOV	r0,#17
;	SWI	XWimp_SendMessage			; Send a message to say that we've changed status!
	B	poll_loop

 [ standalonemessages
; ResourceFS stuff

init_resfs
	STMFD	r13!,{r0,r14}
	ADR	r0,resfs_data
	SWI	XResourceFS_DeregisterFiles		; Just in case!
	ADR	r0,resfs_data
	SWI	XResourceFS_RegisterFiles		; Register the files
	SWIVS	XWimp_ReportError
	LDMFD	r13!,{r0,pc}^

close_resfs
	STMFD	r13!,{r0,r14}
	ADR	r0,resfs_data
	SWI	XResourceFS_DeregisterFiles		; And deregister them
	LDMFD	r13!,{r0,pc}^

resfs_data
	DCD	resfs_next-resfs_data
	DCD	&ffffff47
	DCD	&256883e1
	DCD	eo_messages-so_messages
	DCD	3
	=	"Resources.IZipFS.Messages",0
	ALIGN
	DCD	eo_messages-so_messages+4
so_messages
	BIN	Resources.<Locale>.Messages
eo_messages
	ALIGN
resfs_next
	DCD	resfs_next2-resfs_next
	DCD	&fffffb47
	DCD	&3aec562f
	DCD	eo_basic-so_basic
	DCD	3
	=	"Resources.IZipFS.ZipFree",0
	ALIGN
	DCD	eo_basic-so_basic+4
so_basic
	BIN	Resources.ZipFree
eo_basic
	ALIGN
resfs_next2
	DCD	resfs_next3-resfs_next2
	DCD	&fffff947
	DCD	&3aec562f
	DCD	eo_spr1-so_spr1
	DCD	3
	=	"Resources.IZipFS.!Sprites",0
	ALIGN
	DCD	eo_spr1-so_spr1+4
so_spr1
	BIN	Resources.!Sprites
eo_spr1
	ALIGN
resfs_next3
	DCD	resfs_next4-resfs_next3
	DCD	&fffff947
	DCD	&3aec562f
	DCD	eo_spr2-so_spr2
	DCD	3
	=	"Resources.IZipFS.!Sprites22",0
	ALIGN
	DCD	eo_spr2-so_spr2+4
so_spr2
	BIN	Resources.!Sprites22
eo_spr2
	ALIGN
resfs_next4
	DCD	0
 ]
	END
