        TTL     DOSFS C Support functions               > s.DOSFSctl
        ; -------------------------------------------------------------------
        ; Copyright (c) 1990, JGSmith
        ; -------------------------------------------------------------------

        AREA    |DOSFS_Support|,CODE,READONLY

        ; -------------------------------------------------------------------

                GBLL    newcode
newcode         SETL    {TRUE}          ; calls not detailed in JRoach docs

        ; -------------------------------------------------------------------

                GBLL    RMAalloc
RMAalloc        SETL    {TRUE}          ; include RMA allocation routines

        ; -------------------------------------------------------------------

        IMPORT  |raise|
        IMPORT  |_Lib$Reloc$Off|
        IMPORT  |Image$$RO$$Base|
        IMPORT  |_syserr|

        EXPORT  |moduleName|
        EXPORT  |moduleBase|
        EXPORT  |writeWORD|
        EXPORT  |loadWORD|
        EXPORT  |library_double_udivide|
        EXPORT  |library_double_subtraction|
        EXPORT  |library_double_addition|

        ; The following functions seem to have prototypes in <kernel.h>, but
        ; do not appear in the Stubs for SharedCLibrary 3.66.
        [       (RMAalloc)
        EXPORT  |_kernel_RMAalloc|
        EXPORT  |_kernel_RMAextend|
        EXPORT  |_kernel_RMAfree|
        ]       ; EOF (RMAalloc)

        ; FileSwitch interface functions
        EXPORT  |DOSFS_Open|
        EXPORT  |DOSFS_GetBytes|
        EXPORT  |DOSFS_PutBytes|
        EXPORT  |DOSFS_Args|
        EXPORT  |DOSFS_Close|
        EXPORT  |DOSFS_File|
        EXPORT  |DOSFS_Func|

        ; -------------------------------------------------------------------

        GET     "Hdr:listopts"
        GET     "Hdr:macros"
        GET     "Hdr:system"
;        GET     "Hdr:File"
        GET     "Hdr:modhand"
        GET     "Hdr:wimp"
        GET     "Hdr:hostfs"
        GET     "Hdr:NdrDebug"
        GET     "Hdr:DDVMacros"
        GET     "s.MFSmacros"

        ; -------------------------------------------------------------------

                GBLL    hostvdu

debug           SETL    false
hostvdu         SETL    false           ; TUBE debugging output

open            SETD    false
bget            SETD    false
bput            SETD    false
close           SETD    false
args            SETD    false
file            SETD    false
func            SETD    false
tmp             SETD    false

        ; -------------------------------------------------------------------

        ; standard C register definitions
a1      RN      0
a2      RN      1
a3      RN      2
a4      RN      3
av      RN      4
v1      RN      5
v2      RN      6
v3      RN      7
v4      RN      8
v5      RN      9

;sl      RN      10
;fp      RN      11
;ip      RN      12
lk      RN      14

        ; standard floating point register definitions
f0      FN      0
f1      FN      1

        ; -------------------------------------------------------------------
        ; ARM processor flags

Nbit    bit     31
Zbit    bit     30
Cbit    bit     29
Vbit    bit     28
Ibit    bit     27
Fbit    bit     26

NegativeBit     *       Nbit
ZeroBit         *       Zbit
CarryBit        *       Cbit
OverflowBit     *       Vbit
FiqBit          *       Fbit
IrqBit          *       Ibit
SVCmode         *       &00000003

bit31   bit     31
bit30   bit     30
bit29   bit     29

null            *       &00
lf              *       &0A
cr              *       &0D
space           *       " "

        ; -------------------------------------------------------------------
        ; Errors
notsupported    *       &D8
nostack         *       &A5
badparargs      *       &00
badparfile      *       &01
badparfunc      *       &02

        ; -------------------------------------------------------------------

spare_word         *    &2053474A                       ; "JGS "

                GBLA    fs_number
fs_number       SETA    0               ; undefined filing system

        ; -------------------------------------------------------------------
        ; private (assembler) data

sl_offset       &       |_Lib$Reloc$Off|        ; stack overflow buffer size
|_errptr|       &       |_syserr|               ; pointer to error block
|moduleBase|    &       |Image$$RO$$Base|       ; module base address

module_name
        =       "DOSFS",null                    ; module name
        [       {FALSE} ; not required
DOS_module_selected
        =       "MultiFS DOS support",null      ; module banner
        ]       ; EOF {boolean}
        ALIGN

        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------
        ; char *moduleName(void)
        ; Return the name of our module to the caller.
moduleName
        ADRL    a1,module_name
        MOVS    pc,link

        ; -------------------------------------------------------------------

        LTORG

        ; -------------------------------------------------------------------
        ; Filing System interface:

        IMPORT  |DOSFS_open_file|      ; open a file
        IMPORT  |DOSFS_get_bytes|      ; read bytes from an open file
        IMPORT  |DOSFS_put_bytes|      ; write bytes to an open file
        IMPORT  |DOSFS_close_file|     ; close an open file

        IMPORT  |DOSFS_write_extent|   ; write file extent 
        IMPORT  |DOSFS_alloc|          ; read size allocated to file 
        IMPORT  |DOSFS_flush|          ; flush file buffer 
        IMPORT  |DOSFS_ensure|         ; ensure file size 
        [       (newcode)
        IMPORT  |DOSFS_write_zeros|    ; write zeros to file
        ]       ; EOF (newcode)
        IMPORT  |DOSFS_read_datestamp| ; read load/exec addresses of open file

        IMPORT  |DOSFS_save_file|      ; save a complete file image
        IMPORT  |DOSFS_read_cat|       ; read catalogue information
        IMPORT  |DOSFS_write_cat|      ; write catalogue information 
        IMPORT  |DOSFS_delete|         ; delete object 
        IMPORT  |DOSFS_create|         ; create file 
        IMPORT  |DOSFS_create_dir|     ; create directory 
        IMPORT  |DOSFS_read_block_size| ; return natural block size for image

        IMPORT  |DOSFS_rename|            ; rename object 
        IMPORT  |DOSFS_read_dir|          ; read directory entries 
        IMPORT  |DOSFS_read_dir_info|     ; read directory entries and info
        IMPORT  |DOSFS_image_open|        ; notification of image file open
        IMPORT  |DOSFS_image_close|       ; notification of image file close
        IMPORT  |DOSFS_defect_list|       ; generate defect list for image
        IMPORT  |DOSFS_add_defect|        ; add a defect into the list
        IMPORT  |DOSFS_read_boot_option|  ; read boot option
        IMPORT  |DOSFS_write_boot_option| ; write boot option
        IMPORT  |DOSFS_used_space_map|    ; generate space map
        IMPORT  |DOSFS_read_free_space|   ; return free space information
        IMPORT  |DOSFS_namedisc|          ; namedisc
        IMPORT  |DOSFS_stampimage|        ; update the image identity
        IMPORT  |DOSFS_objectatoffset|    ; return name of object at offset

        IMPORT  |global_error|            ; generate error message from number
        ; -------------------------------------------------------------------
        ; RISC OS Filing System interface:

DOSFS_Open
        Debug   open,"DOSFS_Open",r0,r1,r6
                        ; a1 == r0      type of open to perform
                        ; a2 == r1      pointer to NULL terminated filename
        MOV     a3,r6   ; a3 == r6      image handle for this file

        Ccall   |DOSFS_open_file|
        ORRVSS  pc,lk,#Vbit             ; error -> r0 = ptr to error block
        LDMIA   r0,{r0-r4}              ; r0 = pointer to information block
        ; r0 == file information word
        ; r1 == filing system handle (0 = "not found")
        ; r2 == buffer size (0 if file is unbuffered, 2^n (n = 6..10))
        ; r3 == file extent (buffered files only)
        ; r4 == current file allocation (in buffer size multiples)
        BICS    pc,lk,#Vbit

        ; -------------------------------------------------------------------

DOSFS_GetBytes
        Debug   bget,"DOSFS_GetBytes",r1,r2,r3,r4
        MOV     a1,r1           ; r1 = filing system handle
        MOV     a2,r2           ; r2 = memory address for data
        MOV     a3,r3           ; r3 = number of bytes to transfer
        MOV     a4,r4           ; r4 = file offset (PTR#)
        Ccall   |DOSFS_get_bytes|
        ; r0 = byte read if unbuffered
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

        ; -------------------------------------------------------------------

DOSFS_PutBytes
        Debug   bput,"DOSFS_PutBytes",r1,r2,r3,r4
        MOV     r7,r0           ; preserve the byte to be written
        MOV     a1,r1           ; r1 = filing system handle
        MOV     a2,r2           ; r2 = memory address of data
        MOV     a3,r3           ; r3 = number of bytes to transfer
        MOV     a4,r4           ; r4 = file offset (PTR#)
        Ccall   |DOSFS_put_bytes|,1,r7
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

        ; -------------------------------------------------------------------

DOSFS_Close
        Debug   close,"DOSFS_Close",r1,r2,r3
        MOV     a1,r1           ; r1 = filing system handle
        MOV     a2,r2           ; r2 = new load address for file
        MOV     a3,r3           ; r3 = new exec address for file
        Ccall   |DOSFS_close_file|
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

        ; -------------------------------------------------------------------

DOSFS_Args
        Debug   args,"DOSFS_Args",r0
        ; r0 reason code:
        ; &03 = write file extent (|DOSFS_write_extent|)
        ;       in:     r1 = filing system handle
        ;               r2 = new file extent
        ;       out:    no conditions
        ;
        ; &04 = read size allocated to file (|DOSFS_alloc|)
        ;       in:     r1 = filing system handle
        ;       out:    r2 = size allocated to file by filing system
        ;
        ; &06 = flush file buffer (|DOSFS_flush|)
        ;       in:     r1 = filing system handle
        ;       out:    r2 = load address of file (or 0)
        ;               r3 = exec address of file (or 0)
        ;
        ; &07 = ensure file size (|DOSFS_ensure|)
        ;       in:     r1 = filing system handle
        ;               r2 = size of file to ensure
        ;       out:    r2 = size of file actually ensured
        ;
        [       (newcode)
        ; &08 = write zeroes to file (|DOS_write_zeros|)
        ;       in:     r1 = file handle
        ;               r2 = file address to write zeros at
        ;               r3 = number of zeros to write
        ]       ; EOF (newcode)
        ;
        ; &09 = read load/exec addresses (|DOS_read_datestamp|)
        ;       in:     r1 = file handle
        ;       out:    r2 = load address of file
        ;               r3 = execute address of file
        ;
        CMP     r0,#args_table_entries
        BGT     DOS_args_badparameter
        ADD     pc,pc,r0,LSL #2
        &       spare_word                      ; DO NOT REMOVE OR ADD CODE
args_table_start
        B       DOS_notsupported                ; 00 / 0
        B       DOS_notsupported                ; 01 / 1
        B       DOS_notsupported                ; 02 / 2
        B       |call_DOSFS_write_extent|       ; 03 / 3
        B       |call_DOSFS_alloc|              ; 04 / 4
        B       DOS_notsupported                ; 05 / 5
        B       |call_DOSFS_flush|              ; 06 / 6
        B       |call_DOSFS_ensure|             ; 07 / 7
        [       (newcode)
        B       |call_DOSFS_write_zeros|        ; 08 / 8
        |
        B       DOS_notsupported                ; 08 / 8
        ]       ; EOF (newcode)
        B       |call_DOSFS_read_datestamp|     ; 09 / 9
args_table_end
args_table_entries      *       ((args_table_end - args_table_start) / 4)

DOS_args_badparameter
        MOV     a1,#badparargs
        Ccall   |global_error|
        ORRS    pc,lk,#Vbit

|call_DOSFS_write_extent|
        MOV     a1,r1                   ; filing system handle
        MOV     a2,r2                   ; new file extent
        Ccall   |DOSFS_write_extent|
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

|call_DOSFS_alloc|
        MOV     a1,r1                   ; filing system handle
        Ccall   |DOSFS_alloc|
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

|call_DOSFS_flush|
        MOV     a1,r1                   ; filing system handle
        Ccall   |DOSFS_flush|
        ORRVSS  pc,lk,#Vbit
        LDMIA   r0,{r2,r3}
        BICS    pc,lk,#Vbit

|call_DOSFS_ensure|
        MOV     a1,r1                   ; filing system handle
        MOV     a2,r2                   ; size to ensure
        Ccall   |DOSFS_ensure|
        ORRVSS  pc,lk,#Vbit
        MOV     r2,a1                   ; actual size ensured
        BICS    pc,lk,#Vbit

        [       (newcode)
|call_DOSFS_write_zeros|
        MOV     a1,r1                   ; filing system handle
        MOV     a2,r2                   ; offset within file
        MOV     a3,r3                   ; number of zeros to write
        Ccall   |DOSFS_write_zeros|
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
        ]       ; EOF (newcode)

|call_DOSFS_read_datestamp|
        MOV     a1,r1                   ; filing system handle
        Ccall   |DOSFS_read_datestamp|
        ORRVSS  pc,lk,#Vbit
        LDMIA   r0,{r2,r3}
        BICS    pc,lk,#Vbit

        ; -------------------------------------------------------------------

DOSFS_File
        Debug   file,"DOSFS_File",r0
        ; r0 reason code:
        ;
        ; &00 = save file (|DOSFS_save_file|)
        ;       in:     r1 = pointer to NULL terminated filename
        ;               r2 = load address of file
        ;               r3 = exec address of file
        ;               r4 = start address in memory of data
        ;               r5 = end address in memory (plus one)
        ;               r6 = filing system image handle
        ;       out:    r6 = pointer to leafname (*OPT 1 n printing)
        ;
        ; &01 = write catalogue information (|DOSFS_write_cat|)
        ;       in:     r1 = pointer to NULL terminated wildcarded filename
        ;               r2 = load address to associate with file
        ;               r3 = exec address to associate with file
        ;               r5 = attributes to associate with file
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &05 = read catalogue information (|DOSFS_read_cat|)
        ;       in:     r1 = pointer to NULL terminated wildcarded filename
        ;               r6 = filing system image handle
        ;       out:    r0 = object type
        ;               r2 = load address
        ;               r3 = exec address
        ;               r4 = file length
        ;               r5 = file attributes
        ;
        ; &06 = delete object (|DOSFS_delete|)
        ;       in:     r1 = pointer to NULL terminated filename
        ;               r6 = filing system image handle
        ;       out:    r0 = object type
        ;               r2 = load address
        ;               r3 = exec address
        ;               r4 = file length
        ;               r5 = file attributes
        ;
        ; &07 = create file (|DOSFS_create|)
        ;       in:     r1 = pointer to NULL terminated filename
        ;               r2 = load address to associate with file
        ;               r3 = exec address to associate with file
        ;               r4 = length
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &08 = create directory (|DOSFS_create_dir|)
        ;       in:     r1 = pointer to NULL terminated directory name
        ;               r2 = load address (new feature)
        ;               r3 = exec address (new feature)
        ;               r4 = number of entries (0 for default)
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &0A = read block size (|DOSFS_read_block_size|)
        ;       in:     r1 = pointer to NULL terminated file name
        ;               r6 = filing system image handle
        ;       out:    r2 = natural block size of the file in bytes
        ;
        CMP     r0,#file_table_entries
        BGT     DOS_file_badparameter
        ADD     pc,pc,r0,LSL #2
        &       spare_word              ; DO NOT REMOVE OR ADD CODE
file_table_start
        B       |call_DOSFS_save_file|          ; 00 / 0
        B       |call_DOSFS_write_cat|          ; 01 / 1
        B       DOS_notsupported                ; 02 / 2
        B       DOS_notsupported                ; 03 / 3
        B       DOS_notsupported                ; 04 / 4
        B       |call_DOSFS_read_cat|           ; 05 / 5
        B       |call_DOSFS_delete|             ; 06 / 6
        B       |call_DOSFS_create|             ; 07 / 7
        B       |call_DOSFS_create_dir|         ; 08 / 8
        B       DOS_notsupported                ; 09 / 9
        B       |call_DOSFS_read_block_size|    ; 0A / 10
file_table_end
file_table_entries      *       ((file_table_end - file_table_start) / 4)

DOS_file_badparameter
        MOV     a1,#badparfile
        Ccall   |global_error|
        ORRS    pc,lk,#Vbit

|call_DOSFS_save_file|
        MOV     a1,r1                      ; filename
        MOV     a2,r2                      ; load address
        MOV     a3,r3                      ; exec address
        MOV     a4,r4                      ; start address
        Ccall   |DOSFS_save_file|,2,r5-r6  ; end addr and filing system ihand
        ORRVSS  pc,lk,#Vbit
        MOV     r6,a1                      ; "*OPT 1 n" leafname
        BICS    pc,lk,#Vbit

|call_DOSFS_write_cat|
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; load address
        MOV     a3,r3                   ; exec address
        MOV     a4,r5                   ; attributes
        Ccall   |DOSFS_write_cat|,1,r6  ; filing system image handle
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

|call_DOSFS_read_cat|
        MOV     a1,r1                   ; filename
        MOV     a2,r6                   ; filing system image handle
        Ccall   |DOSFS_read_cat|
        ORRVSS  pc,lk,#Vbit
        ; r0 = pointer to structure containing return information
        LDMIA   r0,{r0,r2-r5}           ; r6 should be preserved
        BICS    pc,lk,#Vbit

|call_DOSFS_delete|
        MOV     a1,r1                   ; filename
        MOV     a2,r6                   ; filing system image handle
        Ccall   |DOSFS_delete|
        ORRVSS  pc,lk,#Vbit
        ; r0 = pointer to structure containing return information
        LDMIA   r0,{r0,r2-r5}
        BICS    pc,lk,#Vbit

|call_DOSFS_create|
        [       {TRUE}  ; documentation seems to be wrong
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; load address
        MOV     a3,r3                   ; exec address
        MOV     a4,r4                   ; start address
        Ccall   |DOSFS_create|,2,r5-r6  ; end addr and filing system ihand
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
        |
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; load address
        MOV     a3,r3                   ; exec address
        MOV     a4,r4                   ; length
        Ccall   |DOSFS_create|,1,r6     ; filing system image handle
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit
        ]       ; EOF {boolean}

|call_DOSFS_create_dir|
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; r2 = load address
        MOV     a3,r3                   ; r3 = exec address
        MOV     a4,r4                   ; number of entries
        Ccall   |DOSFS_create_dir|,1,r6 ; r6 = filing system image handle
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

|call_DOSFS_read_block_size|
        MOV     a1,r1                   ; filename
        MOV     a2,r6                   ; filing system image handle
        Ccall   |DOSFS_read_block_size|
        ORRVSS  pc,lk,#Vbit
        MOV     r2,r0                   ; block size
        BICS    pc,lk,#Vbit

        ; -------------------------------------------------------------------

DOSFS_Func
        Debug   func,"DOSFS_Func",r0
        ; r0 reason code:
        ;
        ; &08 = rename object (|DOSFS_rename|)
        ;       in:     r1 = pointer to NULL terminated filename
        ;               r2 = pointer to NULL terminated NEW filename
        ;               r6 = filing system image handle
        ;       out:    r1 = rename completion state
        ;
        ; &0E = read directory entries (|DOSFS_read_dir|)
        ;       in:     r1 = pointer to NULL terminated wildcarded dirname
        ;               r2 = data destination memory address
        ;               r3 = number of objects to read
        ;               r4 = offset of first object within directory
        ;               r5 = buffer length
        ;               r6 = filing system image handle
        ;       out:    r3 = number of objects read
        ;               r4 = offset of next item in directory (-1 if end)
        ;
        ; &0F = read directory entries and info. (|DOSFS_read_dir_info|)
        ;       in:     r1 = pointer to NULL terminated wildcarded dirname
        ;               r2 = data destination memory address
        ;               r3 = number of objects to read
        ;               r4 = offset of first object within directory
        ;               r5 = buffer length
        ;               r6 = filing system image handle
        ;       out:    r3 = number of records read
        ;               r4 = offset of next item in directory (-1 if end)
        ;
        ; &15 = notification of new image file (|DOSFS_image_open|)
        ;       in:     r1 = FileSwitch handle for file
        ;               r2 = buffer size for file (0 not known)
        ;       out:    r1 = filing system image handle
        ;
        ; &16 = notification of image file being closed (|DOSFS_image_close|)
        ;       in:     r1 = filing system image handle
        ;       out:    no conditions
        ;
        ; &19 = fill buffer with defect information (|DOSFS_defect_list|)
        ;       in:     r1 = pointer to NULL terminated filename
        ;               r2 = start of buffer in memory
        ;               r5 = buffer length
        ;               r6 = filing system image handle
        ;       out: no conditions
        ;
        ; &1A = add a defect into the image mapping (|DOSFS_add_defect|)
        ;       in:     r1 = ptr to NULL terminated filename in ROOT dir.
        ;               r2 = byte offset to start of defect
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &1B = read boot option (|DOSFS_read_boot_option|)
        ;       in:     r1 = pointer to NULL terminated name of object on
        ;                    thing whose boot option is to be read
        ;               r6 = filing system image handle
        ;       out:    r2 = boot option (as defined in *OPT 4,n)
        ;
        ; &1C = write boot option (|DOSFS_write_boot_option|)
        ;       in:     r1 = pointer to NULL terminated name of object on
        ;                    thing whose boot option is to be written
        ;               r2 = new boot option (as defined in *OPT 4,n)
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &1D = construct used space map (|DOSFS_used_space_map|)
        ;       in:     r2 = buffer for map (pre-filled with 0s)
        ;               r5 = size of buffer
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &1E = read free space (|DOSFS_read_free_space|)
        ;       in:     r6 = filing system image handle
        ;       out:    r0 = free space
        ;               r1 = size of biggest object that can be created
        ;               r2 = size of disc (image)
        ;
        ; &1F = name disc (|DOSFS_namedisc|)
        ;       in:     r2 = pointer to NULL terminated disc name
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &20 = update image identity (DOSFS_stampimage)
        ;       in:     r2 = stamp control information
        ;               r6 = filing system image handle
        ;       out:    no conditions
        ;
        ; &21 = return object identity (DOSFS_objectatoffset)
        ;       in:     r2 = byte offset into image file
        ;               r3 = pointer to buffer to receive object name
        ;               r4 = buffer length
        ;               r6 = filing system image handle
        ;       out:    r2 = type of object found
        ;
        CMP     r0,#func_table_entries
        BGT     DOS_func_badparameter
        ADD     pc,pc,r0,LSL #2
        &       spare_word                      ; DO NOT REMOVE OR ADD CODE
func_table_start
        B       DOS_notsupported                ; 00 / 0
        B       DOS_notsupported                ; 01 / 1
        B       DOS_notsupported                ; 02 / 2
        B       DOS_notsupported                ; 03 / 3
        B       DOS_notsupported                ; 04 / 4
        B       DOS_notsupported                ; 05 / 5
        B       DOS_notsupported                ; 06 / 6
        B       DOS_notsupported                ; 07 / 7
        B       |call_DOSFS_rename|             ; 08 / 8
        B       DOS_notsupported                ; 09 / 9
        B       DOS_notsupported                ; 0A / 10
        B       DOS_notsupported                ; 0B / 11
        B       DOS_notsupported                ; 0C / 12
        B       DOS_notsupported                ; 0D / 13
        B       |call_DOSFS_read_dir|           ; 0E / 14
        B       |call_DOSFS_read_dir_info|      ; 0F / 15
        B       DOS_notsupported                ; 10 / 16
        B       DOS_notsupported                ; 11 / 17
        B       DOS_notsupported                ; 12 / 18
        B       DOS_notsupported                ; 13 / 19
        B       DOS_notsupported                ; 14 / 20
        B       |call_DOSFS_image_open|         ; 15 / 21
        B       |call_DOSFS_image_close|        ; 16 / 22
        B       DOS_notsupported                ; 17 / 23
        B       DOS_notsupported                ; 18 / 24
        B       |call_DOSFS_defect_list|        ; 19 / 25
        B       |call_DOSFS_add_defect|         ; 1A / 26
        B       |call_DOSFS_read_boot_option|   ; 1B / 27
        B       |call_DOSFS_write_boot_option|  ; 1C / 28
        B       |call_DOSFS_used_space_map|     ; 1D / 29
        B       |call_DOSFS_read_free_space|    ; 1E / 30
        B       |call_DOSFS_namedisc|           ; 1F / 31
        B       |call_DOSFS_stampimage|         ; 20 / 32
        B       |call_DOSFS_objectatoffset|     ; 21 / 33
func_table_end
func_table_entries      *       ((func_table_end - func_table_start) / 4)

DOS_func_badparameter
        MOV     r0,#badparfunc
        Ccall   |global_error|
        ORRS    pc,lk,#Vbit

|call_DOSFS_rename|
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; new filename
        MOV     a3,r6                   ; filing system image handle
        Ccall   |DOSFS_rename|
        ORRVSS  pc,lk,#Vbit
        MOV     r1,r0                   ; state
        BICS    pc,lk,#Vbit

|call_DOSFS_read_dir|
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; data destination
        MOV     a3,r3                   ; number of objects
        MOV     a4,r4                   ; object offset
        Ccall   |DOSFS_read_dir|,2,r5-r6
        ORRVSS  pc,lk,#Vbit
        ; r0 = pointer to structure containing return information
        LDMIA   r0,{r3-r4}
        BICS    pc,lk,#Vbit

|call_DOSFS_read_dir_info|
        MOV     a1,r1                   ; filename
        MOV     a2,r2                   ; data destination
        MOV     a3,r3                   ; number of objects
        MOV     a4,r4                   ; object offset
        Ccall   |DOSFS_read_dir_info|,2,r5-r6
        ORRVSS  pc,lk,#Vbit
        ; r0 = pointer to structure containing return information
        LDMIA   r0,{r3-r4}
        BICS    pc,lk,#Vbit

|call_DOSFS_image_open|
        MOV     a1,r1                   ; FileSwitch file handle
        MOV     a2,r2                   ; buffer size
        Ccall   |DOSFS_image_open|
        ORRVSS  pc,lk,#Vbit             ; error return
        ; r0 = filing system image handle
        MOV     r1,r0
        BICS    pc,lk,#Vbit

|call_DOSFS_image_close|
        MOV     a1,r1                   ; filing system image handle
        Ccall   |DOSFS_image_close|
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

|call_DOSFS_defect_list|
        MOV     a1,r1                   ; pointer to filename
        MOV     a2,r2                   ; buffer address
        MOV     a3,r5                   ; buffer length
        MOV     a4,r6                   ; filing system image handle
        Ccall   |DOSFS_defect_list|
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

|call_DOSFS_add_defect|
        MOV     a1,r1                   ; pointer to filename
        MOV     a2,r2                   ; defect address
        MOV     a3,r6                   ; filing system image handle
        Ccall   |DOSFS_add_defect|
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

|call_DOSFS_read_boot_option|
        MOV     a1,r1                   ; filename
        MOV     a2,r6                   ; filing system image handle
        Ccall   |DOSFS_read_boot_option|
        ORRVSS  pc,lk,#Vbit
        MOV     r2,r0                   ; boot option
        BICS    pc,lk,#Vbit

|call_DOSFS_write_boot_option|
        MOV     a1,r1                   ; pointer to filename
        MOV     a2,r2                   ; new boot option
        MOV     a3,r6                   ; filing system image handle
        Ccall   |DOSFS_write_boot_option|
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

|call_DOSFS_used_space_map|
        MOV     a1,r2                   ; buffer start address
        MOV     a2,r5                   ; buffer size
        MOV     a3,r6                   ; filing system image handle
        Ccall   |DOSFS_used_space_map|
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

|call_DOSFS_read_free_space|
        MOV     a1,r6                   ; filing system image handle
        Ccall   |DOSFS_read_free_space|
        ORRVSS  pc,lk,#Vbit
        ; r0 = pointer to structure containing return information
        LDMIA   r0,{r0,r1,r2}
        BICS    pc,lk,#Vbit

|call_DOSFS_namedisc|
        MOV     a1,r2                   ; NULL terminated discname
        MOV     a2,r6                   ; filing system image handle
        Ccall   |DOSFS_namedisc|
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

|call_DOSFS_stampimage|
        MOV     a1,r2                   ; identity update control information
        MOV     a2,r6                   ; filing system image handle
        Ccall   |DOSFS_stampimage|
        ORRVSS  pc,lk,#Vbit
        BICS    pc,lk,#Vbit

|call_DOSFS_objectatoffset|
        MOV     a1,r2                   ; byte offset into image
        MOV     a2,r3                   ; object name buffer
        MOV     a3,r4                   ; buffer length
        MOV     a4,r6                   ; filing system image handle
        Ccall   |DOSFS_objectatoffset|
        ORRVSS  pc,lk,#Vbit
        MOV     r2,r0                   ; object type at entry offset
        BICS    pc,lk,#Vbit

        ; -------------------------------------------------------------------
        ; Called when an unrecognised reason code is presented
DOS_notsupported
        ; There should be no stacked state at this point
        MOV     a1,#notsupported
        Ccall   |global_error|
        ORRS    pc,lk,#Vbit

        ; Called when a "Ccall" will fail due to insufficient stack.
DOS_not_enough_stack
        ; There should be no stacked state at this point
        MOV     a1,#nostack
        Ccall   |global_error|
        ORRS    pc,lk,#Vbit

        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------
        ; Provide a simple function to write a WORD to a non-aligned address
|writeWORD|
        ; in:   r0 = byte aligned address
        ;       r1 = 32bit value to be written
        ANDS    r2,r0,#&03      ; r2 = byte index
        STREQ   r1,[r0,#&00]    ; word-aligned (perform write)
        MOVEQS  pc,lk           ; and exit quickly
        ; non-word aligned data
        STMFD   sp!,{r4,r5,r6,lk}

        BIC     r0,r0,#&03      ; r0 = base word index
        LDMIA   r0,{r4,r5}      ; load the two words our word lives in
        MOV     r2,r2,LSL #3    ; r2 = r2 * 8
        RSB     r3,r2,#32       ; r3 = 32 - r2
        MOV     r4,r4,LSL r3    ; clear the top-bits
        MOV     r6,r1,LSL r2    ; shift up the lo-bits
        ORR     r4,r6,r4,LSR r3 ; re-build the lo-word
        MOV     r5,r5,LSR r2    ; clear the lo-bits
        MOV     r6,r1,LSR r3    ; shift down the top-bits
        ORR     r5,r6,r5,LSL r2 ; re-build the hi-word
        STMIA   r0,{r4,r5}      ; store modified words

        LDMFD   sp!,{r4,r5,r6,pc}^

        ; -------------------------------------------------------------------
        ; Provide a simple function to load a WORD from a non-aligned address
|loadWORD|
        ; in:   r0 = byte aligned address
        ANDS    r2,r0,#&03      ; r2 = byte index
        LDREQ   r0,[r0,#&00]    ; word-aligned (perform read)
        MOVEQS  pc,lk           ; and exit quickly
        ; non-word aligned data
        STMFD   sp!,{r4,lk}

        BIC     r0,r0,#&03      ; r0 = base word index
        LDMIA   r0,{r3,r4}      ; load the two words our word lives in
        MOV     r2,r2,LSL #3    ; r2 = r2 * 8        ; shift amount
        RSB     r1,r2,#32       ; r1 = 32 - r2       ; opposite shift amount
        MOV     r0,r3,LSR r2    ; shift down lo-bits from lo-word
        ORR     r0,r0,r4,LSL r1 ; shift up hi-bits from hi-word

        LDMFD   sp!,{r4,pc}^

        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------
        ; Perform 64bit integer arithmetic.

        ; Internal long remainder function
|x$double_lremainder|
        ; in:   a1 = divisor lo
        ;       a2 = divisor hi
        ;       a3 = dividend lo
        ;       a4 = dividend hi
        ; out:  a1 = quotient lo
        ;       a2 = quotient hi
        ;       a3 = remainder lo
        ;       a4 = remainder hi
        ;
        ; temporary internal usage
        ;       av = shift counter lo
        ;       v1 = shift counter hi
        ;       v2 = quotient lo
        ;       v3 = quotient hi

dvslo   RN      a1
dvshi   RN      a2
dvdlo   RN      a3
dvdhi   RN      a4
scntlo  RN      av
scnthi  RN      v1
quotlo  RN      v2
quothi  RN      v3

        STMFD   sp!,{av-v3,lk}

        TEQ     dvslo,dvshi       ; Z set if identical
        CMPEQS  dvslo,#&00000000  ; and check for being zero
        BEQ     dividebyzero

        MOV     scntlo,#&00000001 ; shift counter lo
        MOV     scnthi,#&00000000 ; shift counter hi
double_urem1
        CMPS    dvshi,#&80000000  ; check for divisor overflow, loword unused
        BLCC    comparison1       ; set C if divisor >= dividend
        BLCC    left_shift1       ; (divisor << 1) preserving C
        BLCC    left_shift2       ; (shift counter << 1) preserving C
        BCC     double_urem1      ; and do it again

        ; divisor has overflowed (or is bigger than dividend)
        MOV     quotlo,#&00000000 ; destination quotient lo
        MOV     quothi,#&00000000 ; destination quotient hi
double_urem2
        BL      comparison2     ; check dividend relation to divisor
        BLCS    subtraction1    ; if >= then dividend = dividend - divisor
        BLCS    addition1       ; and quotient += shift counter

        BL      right_shift1    ; divide shift counter by 2 (updating Z)
        BLNE    right_shift2    ; and if <> 0 then divide divisor by 2
        BNE     double_urem2    ; and go around again

        MOV     a1,quotlo       ; and copy the quotient into the return regs
        MOV     a2,quothi

        LDMFD   sp!,{av-v3,lk}
        MOVS    pc,lk           ; preserve state

comparison1
        ; we know C is clear at entry
        ; set C if divisor >= dividend
        CMPS    dvshi,dvdhi
        MOVCC   pc,lk           ; C clear (a2;a1 smaller)
        ORRNES  pc,lk,#CarryBit ; C set (a2;a1 bigger)
        ; at this point dvshi == dvdhi
        CMPS    dvslo,dvdlo     ; and return with this C state
        MOV     pc,lk           ; return this state

comparison2
        ; set C if dividend >= divisor
        CMPS    dvdhi,dvshi
        MOVCC   pc,lk
        ORRNES  pc,lk,#CarryBit
        ; at this point dvshi == dvdhi
        CMPS    dvdlo,dvslo     ; and return with this C state
        MOV     pc,lk           ; return this state

left_shift1
        ; (divisor << 1) preserving C
        MOVS    dvslo,dvslo,ASL #1 ; (dvslo << 1) generating overflow in C
        MOV     dvshi,dvshi,ASL #1 ; (dvshi << 1)
        ADC     dvshi,dvshi,#0     ; and deal with overflow
        MOVS    pc,lk              ; return preserving state

left_shift2
        ; (shift counter << 1) preserving C
        MOVS    scntlo,scntlo,ASL #1 ; (scntlo << 1) generating overflow in C
        MOV     scnthi,scnthi,ASL #1 ; (scnthi << 1)
        ADC     scnthi,scnthi,#0     ; and deal with overflow
        MOVS    pc,lk                ; return preserving state

subtraction1
        ; dividend = dividend - divisor
        SUBS    dvdlo,dvdlo,dvslo
        SBC     dvdhi,dvdhi,dvshi ; include any carry that occured
        MOVS    pc,lk             ; preserve state

addition1
        ; quotient += shift counter
        ADDS    quotlo,quotlo,scntlo
        ADC     quothi,quothi,scnthi ; include any carry that occured
        MOVS    pc,lk                ; preserve state

right_shift1
        ; divide shift counter by 2 (return Z=1 if zero)
        MOVS    scnthi,scnthi,LSR #1 ; shift down hi
        MOV     scntlo,scntlo,RRX    ; shift in C in lo

        TEQ     scnthi,scntlo        ; Z set if identical
        CMPEQS  scnthi,#&00000000
        MOV     pc,lk                ; Z set if both zero

right_shift2
        ; divide divisor by 2
        MOVS    dvshi,dvshi,LSR #1 ; shift down hi
        MOV     dvslo,dvslo,RRX    ; shift in C in lo
        MOVS    pc,lk              ; preserve state

        ; -------------------------------------------------------------------
        ; Double unsigned division.
        ; in:   a1 = pointer to 64bit unsigned int divisor
        ;       a2 = pointer to 64bit unsigned int dividend
        ; out:  a1 = pointer to 64bit quotient
|library_double_udivide|
        STMFD   sp!,{a2,a3,a4,av,v1,v2,v3,v4,ip,lk}
        MOV     v4,a1            ; remember return data point
        LDMIA   a2,{dvdlo,dvdhi} ; load dividend in a4;a3
        LDMIA   v4,{dvslo,dvshi} ; load divisor in a2;a1
        BL      |x$double_lremainder|
        ; quotient in a2;a1
        STMIA   v4,{a1,a2}
        MOV     a1,v4           ; and return pointer to block
        LDMFD   sp!,{a2,a3,a4,av,v1,v2,v3,v4,ip,lk}
        MOVS    pc,lk

        ; -------------------------------------------------------------------
        ; Double subtraction.
        ; in:   a1 = pointer to 64bit unsigned int "arg1"
        ;       a2 = pointer to 64bit unsigned int "arg2"
        ; out:  a1 = pointer to 64bit unsigned int "arg1 - arg2"
|library_double_subtraction|
        STMFD   sp!,{a2,a3,a4,av,lk}
        MOV     av,a1
        LDMIA   a2,{a3,a4}
        LDMIA   av,{a1,a2}

        SUBS    a1,a1,a3
        SBC     a2,a2,a4        ; include any carry that occured

        STMIA   av,{a1,a2}
        MOV     a1,av           ; and return pointer to block
        LDMFD   sp!,{a2,a3,a4,av,lk}
        MOVS    pc,lk

        ; -------------------------------------------------------------------
        ; Double addition.
        ; in:   a1 = pointer to 64bit unsigned int "arg1"
        ;       a2 = pointer to 64bit unsigned int "arg2"
        ; out:  a1 = pointer to 64bit unsigned int "arg1 + arg2"
|library_double_addition|
        STMFD   sp!,{a2,a3,a4,av,lk}
        MOV     av,a1
        LDMIA   a2,{a3,a4}
        LDMIA   av,{a1,a2}

        ADDS    a1,a1,a3
        ADC     a2,a2,a4

        STMIA   av,{a1,a2}
        MOV     a1,av
        LDMFD   sp!,{a2,a3,a4,av,lk}
        MOVS    pc,lk

        ; -------------------------------------------------------------------
        ; Division by zero generated by one of our extensions. This relies
        ; on knowledge of the C library ("raise" and exception numbers).
dividebyzero
        MOV     a1,#2           ; arithmetic exception
        B       |raise|

        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------

        [       (RMAalloc)
|_kernel_RMAalloc|
        STMFD   sp!,{lk}
        MOVS    r3,a1
        LDMEQFD sp!,{pc}^               ; exit quickly is NULL length
        MOVNE   r0,#ModHandReason_Claim
        SWINE   OS_Module
        MOVVS   a1,#&0000000            ; return NULL if failed to alloc
        MOVVC   a1,r2                   ; otherwise base address
        LDMFD   sp!,{pc}^

        ; -------------------------------------------------------------------

|_kernel_RMAextend|
        CMP     a1,#&00000000
        MOVEQ   a1,a2                   ; NULL pointer, so act as realloc()
        BEQ     |_kernel_RMAalloc|      ; perform an allocation
        CMP     a2,#&00000000
        BEQ     |_kernel_RMAfree|       ; if size is zero, then perform free()
        STMFD   sp!,{lk}
        LDR     r3,[a1,#-4]             ; get length word preceding base
        SUB     r3,r3,a2                ; subtract new length (giving delta)
        MOV     r2,a1                   ; the current base address
        MOV     r0,#ModHandReason_ExtendBlock
        SWI     OS_Module
        MOVVS   a1,#&0000000            ; NULL returned if extend failed
        MOVVC   a1,r2                   ; otherwise base address returned
        LDMFD   sp!,{pc}^

        ; -------------------------------------------------------------------

|_kernel_RMAfree|
        STMFD   sp!,{lk}
        MOVS    r2,a1                   ; base address of allocated memory
        MOVNE   r0,#ModHandReason_Free
        SWINE   OS_Module               ; if not NULL then release memory
        MOV     a1,#&00000000           ; and the address is now NULL
        LDMFD   sp!,{pc}^
        ]       ; EOF (RMAalloc)

        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------
        ; -------------------------------------------------------------------

 [ debug
        InsertNDRDebugRoutines
 ]

        ; -------------------------------------------------------------------

        LTORG

        ; -------------------------------------------------------------------
        END
