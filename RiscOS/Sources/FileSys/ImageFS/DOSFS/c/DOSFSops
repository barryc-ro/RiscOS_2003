/*> c.DOSFSops <*/
/*-------------------------------------------------------------------------*/
/* DOSFS filing system image operations         Copyright (c) 1990 JGSmith */
/*-------------------------------------------------------------------------*/
/* These functions provide the Filing System interface for the image. The
 * image is controlled by FileSwitch. We are given a FileSwitch handle to
 * a buffered file. This is mapped at a lower level onto the actual device.
 * All "pathname" requests should be accompanied by a FileSwitch handle. The
 * "pathname" is relative to the ROOT of the image filesystem.
 *
 * This code does NOT need to deal with disc naming or drive numbering. All
 * pathnames are relative to the ROOT of the image filesystem whose
 * FileSwitch handle is passed to "DOSFS_image_open".
 */
/*-------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "h.ASCII"
#include "h.debug"
#include "h.DOSFS"
#include "h.DOSFSctl"
#include "h.DOSshape"
#include "h.FSerrors"
#include "h.wcompare"
#include "h.DOSnaming"
#include "h.DOSFSops"
#include "h.MultiFS"
#include "h.TIMEconv"
#include "h.DOSmapping"
#include "h.ADFSshape"
#include "h.Statics"

#define ReadOnlyMapsLocked 1
 /* JRS 9/3/92 map DOS ReadOnly bit to RISC OS Locked bit only.
  * This is to fix problem with FilerAction setting access 0 to force-delete.
  * This would get translated into DOS ReadOnly, which would then translate
  * back into Locked and not Write, so the file would end up being locked
  * by setting access 0, which was not the intention.
  */

/*-------------------------------------------------------------------------*/
/* Provide facilities for directory cacheing.                              */
/*-------------------------------------------------------------------------*/
#define CACHED_DIRS 5

static DIR_info *dir_cache[CACHED_DIRS] = { NULL };
static int      next_cache_entry = 0;

static void realloc_dir_cache(DIR_info *oldstruct, DIR_info *newstruct)
{
  int index;
  for (index = 0; index < CACHED_DIRS; index++)
    if (dir_cache[index] == oldstruct) {
      dir_cache[index] = newstruct;
      break;
    }
  /* We don't free the directory name as that is still used by the new directory. */
  free(oldstruct);
}

static void free_dir_cache(char *dirname, DOSdisc *ihand)
{
  int index;
  int namelen = strlen(dirname);
  for (index = 0; index < CACHED_DIRS; index++)
    if (dir_cache[index] != NULL && dir_cache[index]->ihand == ihand) {
      if (!dir_flag_is_set(dir_cache[index], dir_LOCKED)
          && (namelen == 0 || strncmp(dir_cache[index]->dir_name, dirname, namelen) == 0)) {
        char c = *(dir_cache[index]->dir_name + namelen);
        if (c == dir_sep || c == '\0') {
          tracef1("free_dir_cache: freeing '%s'\n", dir_cache[index]->dir_name);
          free(dir_cache[index]->dir_name);
          free(dir_cache[index]);
          dir_cache[index] = NULL;
        }
      }
    }
}

static void flush_dir_cache(DOSdisc *ihand)
{
  int index;
  for (index = 0; index < CACHED_DIRS; index++)
    if (dir_cache[index] != NULL && !dir_flag_is_set(dir_cache[index], dir_LOCKED)
        && (dir_cache[index]->ihand == ihand || ihand == 0)) {
      free(dir_cache[index]->dir_name);
      free(dir_cache[index]);
      dir_cache[index] = NULL;
    }
  tracef0("flush_dir_cache: directory cache flushed\n");
}

/* Find the DIR_info structure in the cache which matches the path name as
 * closely as possible.  If an exact match is not found then the nearest
 * direct ancestor of the directory is returned and nameleft is set to
 * point to the remainder of the path name.  If no match is found at all
 * then NULL is returned.
 */
static DIR_info *match_cached_dir(char *dirpathname, char **nameleft, DOSdisc *ihand)
{
  int match = -1;
  int maxmatch = 0;
  int index;
  for (index = 0; index < CACHED_DIRS; index++)
    if (dir_cache[index] != NULL && dir_cache[index]->ihand == ihand) {
      int len = strlen(dir_cache[index]->dir_name);
      if (len == 0 || strncmp(dirpathname, dir_cache[index]->dir_name, len) == 0) {
        char c = *(dirpathname + len);
        if (c == '\0') {
          tracef1("match_cached_dir: exactly matched '%s'\n", dirpathname);
          *nameleft = NULL;
          return dir_cache[index];
        }
        if ((len == 0 || c == dir_sep) && len >= maxmatch) {
          match = index;
          maxmatch = len;
        }
      }
    }
  *nameleft = dirpathname + maxmatch;

  if (match < 0)
    return NULL;

  tracef2("match_cached_dir: matched '%s' with '%s' left\n", dir_cache[match]->dir_name, *nameleft);
  return dir_cache[match];
}

/* Cache the directory in the next cache slot.
 */
static DIR_info *cache_dir(DIR_info *dirstruct)
{
  int i;

  /* Try to find a free cache entry. */
  for (i = 0; i < CACHED_DIRS; i++)
    if (dir_cache[i] == NULL) {
      dir_cache[i] = dirstruct;
      return dirstruct;
    }

  /* Otherwise try to find one which isn't locked. */
  i = next_cache_entry;
  while (dir_flag_is_set(dir_cache[next_cache_entry], dir_LOCKED)) {
   if (++next_cache_entry == CACHED_DIRS)
     next_cache_entry = 0;
   if (next_cache_entry == i)
    break;
  }

  free(dir_cache[next_cache_entry]->dir_name);
  free(dir_cache[next_cache_entry]);

  /* Cache the directory and return it. */
  dir_cache[next_cache_entry] = dirstruct;
  if (++next_cache_entry == CACHED_DIRS)
    next_cache_entry = 0;

  return dirstruct;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* simple buffer zero function */
static void bzero(char *addr,int nbytes)
{
 for (; (nbytes > 0); nbytes--)
  *addr++ = 0x00 ;
 return ;
}

/*-------------------------------------------------------------------------*/

/* Return mode of access if the given file is open (else return -1). */
static int find_open_file(char *fname, DOS_direntry *dentry, DOSdisc *ihand)
{
  FILEhand *cptr;

  int dcluster = get_FILE_cluster(dentry);

  for (cptr = FILE_list; cptr != NULL; cptr = cptr->next)
    if (cptr->ihand == ihand) {
      if (dcluster == 0) {
        if (wild_card_compare(cptr->fname, fname, ROwcmult, ROwcsing))
          return cptr->opentype;
      } else
        if (dcluster == cptr->startCLUSTER)
          return cptr->opentype;
    }

  tracef1("find_open_file: file \"%s\" not open\n",fname);
  return -1;
}

/*-------------------------------------------------------------------------*/

static int update_imageID(DOSdisc *ihand)
{
 /* At the moment we just calculate a simple additive checksum from the FAT.
  */
 word              cval = 0x00000000 ; /* image ID value */
 int               loop ;
 char             *FATbuffer ;
 _kernel_swi_regs  rset ;
 _kernel_oserror  *rerror ;

 /* Flush the output using OS_Args 255. */
 rset.r[0] = 255;
 rset.r[1] = (word)ihand->disc_fhand;
 if ((rerror = _kernel_swi(OS_Args, &rset, &rset)) != NULL) {
  tracef2("update_imageID: error from OS_Args 255: (&%08X) \"%s\"\n",rerror->errnum,rerror->errmess);
  return_errorX(int,rerror);
 }

 FATbuffer = (char *)&(ihand->disc_FAT) ;

 for (loop = 0; (loop < ihand->disc_FATsize); loop++)
  cval = cval + FATbuffer[loop] ;

 tracef1("update_imageID: sending 0x%x\n", cval);
 rset.r[0] = 8 ; /* update image ID */
 rset.r[1] = (word)ihand->disc_fhand;
 rset.r[2] = cval ; /* and the newly calculated value */
 if ((rerror = _kernel_swi(OS_Args,&rset,&rset)) != NULL)
  {
   tracef2("update_imageID: error from OS_Args 8: (&%08X) \"%s\"\n",rerror->errnum,rerror->errmess) ;
   return_errorX(int,rerror) ;
  }
 ihand->disc_flags &= ~disc_UPDATEID ; /* we have given FileSwitch a new image ID */
 return(0) ;
}

/*-------------------------------------------------------------------------*/

static int DOS_image_RW(int op,word sec,int off,byte *ma,word nbytes,DOSdisc *ihand)
{
 word              discaddress ;
 _kernel_swi_regs  reglist ;
 _kernel_oserror  *rerror ;

 tracef5("DOS_image_RW: %c sec: %d ma: &%08X nbytes: &%08X ihand: &%08X\n",((op == Rdata) ? 'R' : 'W'),sec,ma,nbytes,(word)ihand) ;

 /* read or write a block from the specified image file */
 /* NOTE: the "disc_winioffset" value SHOULD be 0x00000000 for floppies */
 discaddress = ((sec - 1) * DOSsecsize) + ihand->disc_winioffset + off ;

 tracef2("DOS_image_RW: handle = &%08X, disc address = &%08X\n",ihand->disc_fhand,discaddress);

 /* transfer the bytes */
 reglist.r[0] = ((op == Rdata) ? osgbpb_rptr : osgbpb_wptr) ;
 reglist.r[1] = ihand->disc_fhand ; /* FileSwitch handle */
 reglist.r[2] = (word)ma ;
 reglist.r[3] = nbytes ;
 reglist.r[4] = discaddress ;
 reglist.r[5] = NULL ;
 reglist.r[6] = NULL ;

 if ((rerror = _kernel_swi(OS_GBPB,&reglist,&reglist)) != NULL)
  {
   tracef2("DOS_image_RW: (&%08X) \"%s\"\n",rerror->errnum,rerror->errmess) ;
   return_errorX(int,rerror) ;
  }

 tracef1("DOS_image_RW: transfer complete, &%08X bytes left\n",reglist.r[3])

 if (reglist.r[3] != 0)
  {
   return_error0(int,((op == Rdata) ? err_readfailed : err_writefailed)) ;
  }

 /* If this call has written data to the image (op == Wdata) and the new image
  * ID flag is set then we must generate a new disc ID and tell FileSwitch
  * about it.
  *     OS_Args
  *             r0 = 8
  *             r1 = image file handle
  *             r2 = new image identity
  */
 if ((op == Wdata) && (ihand->disc_flags & disc_UPDATEID))
  return(update_imageID(ihand)) ;

 return(0) ;
}

/*---------------------------------------------------------------------------*/

static void read_loadexec(DOS_direntry *dentry,word dosext,time5byte *le)
{
 int value ;

 MSDOStoRISCOS(get_FILE_time(dentry),get_FILE_date(dentry),le) ;
 value = get_FILE_ROStype(dentry) ;
 if (value != 0)
  le->hi = (le->hi & ~ADFStypemask) | (value << 8) ;
 else
  {
   mapentry *cmap ;
   for (cmap = maplist; (cmap); cmap = cmap->next)
   if (cmap->dosext == dosext)
    {
     le->hi = (le->hi & ~ADFStypemask) | (cmap->ROtype << 8) ;
     break ;
    }
  }
 return ;
}

/*---------------------------------------------------------------------------*/

static void update_loadexec(DOS_direntry *dentry,word ld,word ex)
{
 time5byte     updateTIME ; /* local time described in passed addresses */
 int           cROStype = ((ld & ADFStypemask) >> ADFStypeshift) ;

 tracef3("update_loadexec: dentry = &%08X, ld = &%08X, ex = &%08X\n",(word)dentry,ld,ex) ;

 if (cROStype == DOStype)
  {
   erase_ROStype(dentry) ; /* remove any possible RISC OS file-type */
  }
 else
  {
   put_FILE_ROStype(dentry,cROStype) ;
  }

 /* update the timestamp */
 updateTIME.lo = ex ;
 updateTIME.hi = (ld & 0xFF) ;
 put_FILE_time(dentry,RISCOStoTIME(&updateTIME)) ;
 put_FILE_date(dentry,RISCOStoDATE(&updateTIME)) ;

 return ;
}

/*---------------------------------------------------------------------------*/

static int getnextCLUSTER(int cluster,DOSdisc *ihand)
{
 int   nextcluster ;
 word  bitaddress ;
 word  byteaddress ;
 word  shift ;
 word  datavalue ;
 byte *FAT_base_address = (byte *)&(ihand->disc_FAT) ;

 bitaddress = (ihand->disc_FATentry * cluster) ;
 byteaddress = (((bitaddress & 0xFFFFFFF8) >> 3) + (word)FAT_base_address) ;
 shift = (bitaddress & 0x00000007) ;
 datavalue = loadWORD((char *)byteaddress) ;

 nextcluster = (int)((datavalue >> shift) & FAT_entry_mask(ihand)) ;
tracef2("getnextCLUSTER %d -> %d\n", cluster, nextcluster);

 return(nextcluster) ;
}

/*---------------------------------------------------------------------------*/

static int writenextCLUSTER(int cluster,int nextcluster,DOSdisc *ihand)
{
 word  bitaddress ;
 word  byteaddress ;
 word  shift ;
 word  datavalue ;
 byte *FAT_base_address = (byte *)&(ihand->disc_FAT) ;

 tracef2("writenextCLUSTER: cluster = &%03X, nextcluster = &%03X\n",cluster,nextcluster) ;

 bitaddress = (ihand->disc_FATentry * cluster) ;
 byteaddress = (((bitaddress & 0xFFFFFFF8) >> 3) + (word)FAT_base_address) ;
 shift = (bitaddress & 0x00000007) ;
 datavalue = loadWORD((char *)byteaddress) ;
 datavalue &= ~(FAT_entry_mask(ihand) << shift) ;
 datavalue |= ((nextcluster & FAT_entry_mask(ihand)) << shift) ;
 writeWORD((char *)byteaddress,datavalue) ;

 ihand->disc_FATmodified = -1 ; /* the FAT has been updated */
 return(0) ;
}

/*---------------------------------------------------------------------------*/
/* MACROs used to perform sector-to-CLUSTER mappings */

#define CLUSTERtoSECTOR(c,i) ((((c) - CLUSTER_first(i)) * secsalloc(i)) + (i)->disc_startsec)

#define SECTORtoCLUSTER(s,i) ((((s) - (i)->disc_startsec) / secsalloc(i)) + CLUSTER_first(i))

/*---------------------------------------------------------------------------*/
/* findCLUSTERtype:
 * This steps through the FAT looking for a CLUSTER of the specified type.
 *      index         contains the starting point in the FAT
 *      FATlimit      defines the number of CLUSTERs contained in the FAT
 * The last FAT entry looked at is returned in "index". If there are no such
 * CLUSTERs then (-1) is returned.
 */
static int findCLUSTERtype(DOSdisc *ihand,int *index,int type)
{
 fFAT_sector *dFAT = &(ihand->disc_FAT) ;
 int          cluster = -1 ;
 word         bitaddress ;
 word         byteaddress ;
 word         shift ;
 word         datavalue ;
 byte        *FAT_base_address = (byte *)dFAT ;
 /* JRS 2/3/92 Added CLUSTER_first(ihand) */
 int          FATlimit = CLUSTER_first(ihand) + ihand->disc_FATentries;

 while (*index < FATlimit)
  {
   bitaddress = (ihand->disc_FATentry * (*index)) ;
   byteaddress = (((bitaddress & 0xFFFFFFF8) >> 3) + (word)FAT_base_address) ;
   shift = (bitaddress & 0x00000007) ;
   datavalue = loadWORD((char *)byteaddress) ;
   cluster = (int)((datavalue >> shift) & FAT_entry_mask(ihand)) ;

   if (cluster == type)
    return(*index) ;

   /* increment onto the next cluster entry */
   (*index)++ ;
  }

 /* no more CLUSTERs */
 return(-1) ;
}

/*---------------------------------------------------------------------------*/

static int countfreeclusters(DOSdisc *ihand)
{
 int numCLUSTERs = 0 ;
 int clusterINDEX = CLUSTER_first(ihand) ;

 /* returns the number of available clusters */

 while (findCLUSTERtype(ihand,&clusterINDEX,CLUSTER_unused(ihand)) != -1)
  {
   numCLUSTERs++ ;
   clusterINDEX++ ; /* step over the CLUSTER we have just found */
  }

 return(numCLUSTERs) ;
}

/*---------------------------------------------------------------------------*/

static int freeclusters(int startCLUSTER,DOSdisc *ihand)
{
 int lastCLUSTER = startCLUSTER ;
 int nextCLUSTER ;
 int count = 0;

 /* Free the cluster chain addresses by "startcluster" and mark "startcluster"
  * as the end of a chain.
  */
 tracef1("freeclusters: starting at cluster &%03X\n",startCLUSTER) ;

 /* Check that there are indeed CLUSTERs to be free'd */
 if ((startCLUSTER == 0) || (startCLUSTER >= CLUSTER_end(ihand)))
  return(0) ; /* NO CLUSTERs to be released */

 do
  {
   nextCLUSTER = getnextCLUSTER(lastCLUSTER,ihand) ;
   tracef2("freeclusters: lastCLUSTER = &%03X, nextCLUSTER = &%03X\n",lastCLUSTER,nextCLUSTER) ;
   writenextCLUSTER(lastCLUSTER,CLUSTER_unused(ihand),ihand) ;
   lastCLUSTER = nextCLUSTER ;
   if ( (count > ihand->disc_FATentries) || (nextCLUSTER < CLUSTER_first(ihand)) )
     /* JRS 6/3/92 Added test to terminate infinite loop if loop in (bad) FAT */
     { global_error0(err_clusterchain) ; break ; }
   count++;
  } while (nextCLUSTER < CLUSTER_end(ihand));

 ihand->disc_freeclusters += count;
 return(0) ;
}

/*---------------------------------------------------------------------------*/

/* Build free clusters into a chain and return the start cluster. */
static int claimfreeclusters(int required, DOSdisc *ihand)
{
  int index = CLUSTER_first(ihand);
  int first, last;

  if (required <= 0)
    return 0;

  /* Make sure there are enough free clusters. */
  if (required > ihand->disc_freeclusters)
    return_error0(int, err_discfull);

  ihand->disc_freeclusters -= required;

  first = last = findCLUSTERtype(ihand, &index, CLUSTER_unused(ihand));
  while (--required) {
    int next;
    index++;  /* Skip the one we just found. */
    next = findCLUSTERtype(ihand, &index, CLUSTER_unused(ihand));
    writenextCLUSTER(last, next, ihand);
    last = next;
  }
  /* Terminate the chain. */
  writenextCLUSTER(last, CLUSTER_rend(ihand), ihand);

  return first;
}

/*---------------------------------------------------------------------------*/

/* Adjust the length of the given cluster chain and return the start cluster. */
static int adjustusedchain(int start, int required, DOSdisc *ihand)
{
  int next, cluster;

  /* If we are chopping to 0 length then this is really a free. */
  if (required <= 0) {
    freeclusters(start, ihand);
    return 0;
  }

  /* If start is 0 then no space has been allocated for the file yet. */
  if (start == 0)
    return claimfreeclusters(required, ihand);

  /* Follow the current chain until either we don't need any more (we need to chop)
   * or it is exhausted (we need to extend).
   */
  next = start;
  do {
    cluster = next;
    next = getnextCLUSTER(cluster, ihand);
    if (next < CLUSTER_first(ihand)) /* JRS 9/3/92 */
      return_error0(int,err_clusterchain) ;
  } while ( (--required) && (next < CLUSTER_end(ihand)) );

  /* The chain may be of the correct length anyway, hence we check both exit conditions. */
  if (required) {
    int extra;
    /* We need to extend the chain. */
    if ((extra = claimfreeclusters(required, ihand)) < 0)
      return -1;
    /* Tag onto the end of the existing chain. */
    writenextCLUSTER(cluster, extra, ihand);
  } else if (next < CLUSTER_end(ihand)) {
    /* We need to chop the chain. */
    freeclusters(next, ihand);
    /* Terminate the chopped chain. */
    writenextCLUSTER(cluster, CLUSTER_rend(ihand), ihand);
  }

  return start;
}

/*---------------------------------------------------------------------------*/

static int clusterinchain(int cluster, int object, DOSdisc *ihand)
{
  int count = 0;
  do {
    if (cluster == object)
      return 1;
    cluster = getnextCLUSTER(cluster, ihand);
    if ( (++count > ihand->disc_FATentries) || (cluster < CLUSTER_first(ihand)) )
      /* JRS 6/3/92 Added test to terminate loop in bad FAT */
      { global_error0(err_clusterchain) ; return 0 ; }
  } while (cluster < CLUSTER_end(ihand)) ;
  return 0;
}

/*---------------------------------------------------------------------------*/

static int clusterfromoffset(int cluster, word *offset, DOSdisc *ihand)
{
  int count = 0;
  int clustersize = secsalloc(ihand) * DOSsecsize;
  do {
    if (*offset < clustersize)
      return cluster;
    cluster = getnextCLUSTER(cluster, ihand);
    (*offset) -= clustersize;
    if ( (++count > ihand->disc_FATentries) || (cluster < CLUSTER_first(ihand)) )
      /* JRS 6/3/92 Added test to terminate loop in bad FAT */
      return_error0(int,err_clusterchain) ;
  } while (cluster < CLUSTER_end(ihand));
  return_error0(int, err_EOF);
}

/*---------------------------------------------------------------------------*/

static int DOS_FAT_RW(int op, DOSdisc *ihand)
{
  int loop, sec, copies = 0;
  int numFATs = ihand->disc_boot.BOOT_num_fats;
  int sizeinsec = ihand->disc_FATsize / DOSsecsize;

  tracef1("DOS_FAT_RW: op=%c\n",op==Rdata ? 'R' : 'W');

  for (loop = 0, sec = DOS_FAT_sector; loop < numFATs; loop++, sec += sizeinsec) {
    if (op == Wdata) ihand->disc_flags |= disc_UPDATEID;  /* JRS 13/4/92 added to prevent ambiguous disc name error */
    tracef2("DOS_FAT_RW: op = %c, copy = %d\n",(op == Rdata ? 'R' : 'W'), loop);
    if (DOS_image_RW(op, sec, 0, (byte *)&(ihand->disc_FAT), ihand->disc_FATsize, ihand) == 0) {
      copies++;
      if (op == Rdata)
        break;
    }
  }

  if (copies == 0) {
    tracef0("DOS_FAT_RW: operation failed\n");
    return -1;
  }

  ihand->disc_FATmodified = 0;

  if (op == Rdata)
    ihand->disc_freeclusters = countfreeclusters(ihand);

  return 0;
}

/*---------------------------------------------------------------------------*/

static int ensure_FATs(DOSdisc *ihand)
{
 if (ihand->disc_FATmodified)
  return DOS_FAT_RW(Wdata, ihand);

 return(0) ;
}


/*-------------------------------------------------------------------------*/
/* DOS_cluster_RW:
 *  load/save the specified (possibly partial) cluster to/from the given memory address
 *    returns  n : next cluster
 *    returns  0 : no more clusters (cluster 0 never holds data)
 *    returns -1 : failed to load any data
 *  NB. len MUST always be <= the cluster size (in bytes)
 */

static int DOS_cluster_RW(int op,int cluster,int coff,char *memaddr,int len,DOSdisc *ihand)
{
 int           nextcluster = -1 ;
 int           startsector = CLUSTERtoSECTOR(cluster,ihand) ;

 if (DOS_image_RW(op,startsector+(coff>>log2DOSsecsize),coff&(DOSsecsize-1),(byte *)memaddr,len,ihand) < 0)
  return(-1) ;

 nextcluster = getnextCLUSTER(cluster,ihand) ;
 if ( (nextcluster >= CLUSTER_end(ihand)) || (nextcluster < CLUSTER_first(ihand)) )
  return(0) ;

 return(nextcluster) ;
}

/*---------------------------------------------------------------------------*/
/* DOS_multiple_RW:
 *  load/save as many consecutive CLUSTERs as possible, starting at the specified
 *  cluster, to/from the given memory address.
 *  returns  n : next cluster
 *  returns  0 : no more clusters (cluster 0 never holds data)
 *  returns -1 : failed to load all the data
 */

static int DOS_multiple_RW(int op,int cluster,int coff,char *ma,int limit,word *ta,DOSdisc *ihand)
{
 int count = 0;
 int           nextcluster = cluster ;
 int           startsector = CLUSTERtoSECTOR(cluster,ihand) ;
 int           allocsize = (secsalloc(ihand) * DOSsecsize) ;

 *ta = 0 ;      /* number of bytes we are going to transfer */
 /* "limit" is the extent of the maximum amount of data we should transfer */
 limit += coff;
 do
  {
   *ta += allocsize ;   /* this CLUSTER will be included */
   cluster = nextcluster ;
   nextcluster = getnextCLUSTER(cluster,ihand) ;
   if ( (++count > ihand->disc_FATentries) || (nextcluster < CLUSTER_first(ihand)) )
     /* JRS 6/3/92 Added test to terminate loop in bad FAT */
     return_error0(int,err_clusterchain) ;
   if (nextcluster >= CLUSTER_end(ihand))
    {
     nextcluster = 0 ; /* end of cluster chain */
     if (*ta < limit)
      {
       tracef2("DOS_multiple_RW: end of CLUSTER chain reached (&%08X) before limit &%08X)\n",*ta,limit) ;
       return_error0(int,err_clusterchain) ;   /* not all of the file loaded */
      }
    }
  } while ((*ta < limit) && (nextcluster == cluster + 1)) ;

 /* transfer the data */
 if (*ta > limit)
  *ta = limit;
 *ta-=coff;
 if (DOS_image_RW(op,startsector+(coff>>log2DOSsecsize),coff&(DOSsecsize-1),(byte *)ma,*ta,ihand) < 0)
  return(-1) ;

 /* "*ta" is updated to hold the number of bytes actually transferred */
 return(nextcluster) ;
}

/*---------------------------------------------------------------------------*/

static DOS_direntry *getnextDIRentry(DOS_direntry *directory,int dir_size,int *index)
{
 DOS_direntry *dentry ;
 int           entries = (dir_size / sizeof(DOS_direntry)) ;

 /* return the directory entry pointer (or NULL if directory end)
  * NOTE: the index is also set to (-1) if we have reached the end
  */
 if (*index == -1)
  return(NULL) ;

 if (*index >= entries)
  {
   /* End of directory already reached (no last file marker present?) */
   *index = -1 ;
   return(NULL) ;
  }

 dentry = &directory[*index] ;

 /* if this entry has been deleted (or is a directory) then step over it */
 if ((dentry->FILE_status == FILE_deleted) || (dentry->FILE_status == FILE_directory))
  {
   *index += 1 ;
   return(getnextDIRentry(directory,dir_size,index)) ;
  }

 if (dentry->FILE_status == FILE_lastentry)
  {
   *index = -1 ;
   return(NULL) ;
  }

 /* increment the index counter onto the next directory entry */
 *index += 1 ;

 return(dentry) ;
}

/*---------------------------------------------------------------------------*/

static char *buildFILEname(DOS_direntry *dentry,char *name)
{
 char *cptr = (char *)&(dentry->FILE_status) ;
 int   index ;
 int   loop ;

 /* assert(name != NULL);  JRS 5/3/92 removed unnecessary conditional malloc here, name is malloced and tested by all callers */

 /* "dentry" should contain a valid filename */
 /* copy prefix characters (or upto a space) into the filename buffer */
 for (index=0; ((cptr[index] > ' ') && (index < namsize)); index++)
  name[index] = cptr[index] ;

 /* copy suffix characters (or upto a space) into the filename buffer */
 for (loop=0; ((dentry->FILE_extension[loop] > ' ') && (loop < extsize)); loop++)
  {
   if (loop == 0) /* the first character of the extension */
    name[index++] = file_sep ; /* then place in the file_seperator */
   name[index++] = dentry->FILE_extension[loop] ;
  }

 /* terminate the name */
 name[index] = NULL ;

 return(name) ;
}

/*---------------------------------------------------------------------------*/

static DOS_direntry *findemptyDIRentry(DOS_direntry *directory,int dir_size)
{
 DOS_direntry *dentry ;
 int           index ;
 int           entries = (dir_size / sizeof(DOS_direntry)) ;

 /* return the first available directory entry pointer (or NULL if
  * there are no free directory entries)
  */
 for (index=0; (index < entries); index++)
  {
   dentry = &directory[index] ;

   /* if this entry has been deleted then we can use it */
   if (dentry->FILE_status == FILE_deleted)
    return(dentry) ;

   /* if this entry is the last then use it and clear the following */
   if (dentry->FILE_status == FILE_lastentry)
    {
     /* mark the successive entry as the last */
     if (++index < entries)
      directory[index].FILE_status = FILE_lastentry ;
     return(dentry) ;
    }
  }

 /* we could NOT find a free entry in this directory */
 return(NULL) ;
}

/*---------------------------------------------------------------------------*/
/* findDIRentry:
 * find the first object that matches the given wildcarded text
 */

static DOS_direntry *findDIRentry(char *wcname,DOS_direntry *dir,int dir_size,int *index)
{
 DOS_direntry *dentry = NULL ;
 char         *cfile = NULL ;
 char         *nbuff = malloc(DOSnamesize) ;
 if (nbuff == NULL)
  /* JRS changed 5/3/92 to trap out of memory error. Ideally all callers should test
   * this out of memory case, but there is not time to modify, and at least if gives a valid error
   * before doing something invalid! */
  { global_errorT(err_heapexhausted, tok_heapexhausted, 0, 0); return NULL; }

 for (;;)
  {
   dentry = getnextDIRentry(dir,dir_size,index) ;

   if (dentry == NULL)
    break ;

   if ((dentry->FILE_attribute & FILE_volume) != 0)
    continue ;

   cfile = buildFILEname(dentry,nbuff) ;

   if (namematch(wcname,cfile) == TRUE)
    break ;
  }

 if (dentry)
  strcpy(wcname, cfile);

 free(nbuff) ;

 /* will either be NULL (index set to -1), or a valid directory entry */
 return(dentry) ;
}

/*---------------------------------------------------------------------------*/

static DOS_direntry *findSUBDIR(char *wcname,DOS_direntry *dir,int dir_size,int *index)
{
 DOS_direntry *dentry = NULL ;
 char         *nbuff = malloc(DOSnamesize) ;
 char         *cfile;

 if (nbuff == NULL)
  {
   *index = -1 ;
   return(NULL) ;
  }

 do
  {
   dentry = getnextDIRentry(dir,dir_size,index) ;
   cfile = buildFILEname(dentry,nbuff);
  } while ((dentry != NULL) && (((dentry->FILE_attribute & FILE_subdir) == 0) || (namematch(wcname,cfile) != TRUE))) ;

 if (dentry)
  strcpy(wcname, cfile);

 free(nbuff) ;

 /* will either be NULL (index set to -1), or a valid directory entry */
 return(dentry) ;
}

/*---------------------------------------------------------------------------*/

static int DOS_object_RW(int op,int startcluster,char *ma,word bytelength,DOSdisc *ihand)
{
 word allocsize = secsalloc(ihand) * DOSsecsize;
 word tamount ;
 int  nextcluster = startcluster ;

 tracef5("DOS_object_RW: op = %c, startCLUSTER = &%03X, ma = &%08X, bytelength = &%08X, ihand = &%08X\n",(op == Rdata ? 'R' : 'W'),startcluster,(word)ma,bytelength,(word)ihand) ;

 /* load whole clusters directly into memory */
 while ((bytelength != 0) && (nextcluster > 0))
  {
   if (bytelength < allocsize)
    {
     tamount = bytelength ;
     nextcluster = DOS_cluster_RW(op,nextcluster,0,ma,bytelength,ihand) ;
    }
   else
    nextcluster = DOS_multiple_RW(op,nextcluster,0,ma,bytelength,&tamount,ihand) ;

   /* cluster op failure */
   if (nextcluster == -1)
    return(-1) ;       /* assumes error message already defined */

   bytelength -= tamount ;
   ma += tamount ;
  }

 if ((nextcluster != 0) || (bytelength != 0))
  {
   tracef2("DOS_object_RW: FAILURE (nextcluster = &%03X, bytelength = &%08X)\n",nextcluster,bytelength) ;
   return_error0(int,err_clusterchain) ; /* the CLUSTER chain is bad */
  }

 return(0) ;
}

/*---------------------------------------------------------------------------*/

static int ensure_directory(DIR_info *dir)
{
 if (dir_flag_is_set(dir, dir_MODIFIED))
  {
   tracef1("ensure_directory: directory &%08X to be saved\n",(int)dir) ;

   if (dir->dir_root != 0) /* ROOT directory is a special case */
    {
     if (DOS_image_RW(Wdata,dir->dir_sector,0,(byte *)&(dir->dir_entries[0]),dir->dir_size,dir->ihand) < 0)
      return(-1) ; /* error already defined */
    }
   else
    {
     if (DOS_object_RW(Wdata,SECTORtoCLUSTER(dir->dir_sector,dir->ihand),(char *)&(dir->dir_entries[0]),(word)dir->dir_size,dir->ihand) < 0)
      return(-1) ; /* error already defined */
    }

   unset_dir_flags(dir, dir_MODIFIED) ; /* directory has been written successfully */
  }
 return(0) ;
}

/*---------------------------------------------------------------------------*/

/* Set up a DIR_info struct for the given directory and cache it. */
static DIR_info *read_cache_dir(
  char *dirname,
  int is_root,
  word sector,
  word size,
  word parsec,
  word parindex,
  word parsize,
  DOSdisc *ihand
) {
  DIR_info *dirstruct = (DIR_info *)malloc(sizeof(DIR_info) + size - sizeof(DOS_direntry));
  if (dirstruct == NULL) {
   flush_dir_cache(0);   /* Flush every unlocked directory from the cache - we're desperate!! */
   dirstruct = (DIR_info *)malloc(sizeof(DIR_info) + size - sizeof(DOS_direntry));
   if (dirstruct == NULL)
    return_errorT(DIR_info *, err_heapexhausted, tok_heapexhausted, 0, 0);
  }

  dirstruct->ihand = ihand;
  if ((dirstruct->dir_name = malloc(strlen(dirname) + 1)) == NULL) {
    free(dirstruct);
    return_errorT(DIR_info *,err_heapexhausted, tok_heapexhausted, 0, 0);
  }
  strcpy(dirstruct->dir_name, dirname);
  dirstruct->dir_root = is_root;
  dirstruct->dir_sector = sector;
  dirstruct->dir_size = size;
  dirstruct->dir_parentsec = parsec;
  dirstruct->dir_parentindex = parindex;
  dirstruct->dir_parentsize = parsize;
  dirstruct->dir_flags = 0;

  if (is_root) {
    if (DOS_image_RW(Rdata, sector, 0, (byte *)(dirstruct->dir_entries), size, ihand) < 0) {
      free(dirstruct->dir_name);
      free(dirstruct);
      return (DIR_info *)-1;
    }
  } else {
    if (DOS_object_RW(Rdata,SECTORtoCLUSTER(sector, ihand), (char *)(dirstruct->dir_entries), size, ihand) < 0) {
      free(dirstruct->dir_name);
      free(dirstruct);
      return (DIR_info *)-1;
    }
  }

  tracef1("read_cache_dir: read & cached '%s'\n", dirname);
  return cache_dir(dirstruct);
}

/*---------------------------------------------------------------------------*/
/* NOTE: The ROOT directory size is fixed (detailed in BOOT BLOCK).
 *       Sub-directories are special files and hence can grow like files
 *       (when buffering directories we can load the complete "FILE" into
 *       a suitably sized DIR_info buffer).
 */

static DIR_info *loadDIR(char *dirpathname,DOSdisc *ihand)
{
 DIR_info     *dirstruct = NULL ;             /* directory description */
 DOS_direntry *dentry ;                       /* directory entry structure */
 int           index = 0 ;                    /* general directory index */
 char         *tptr ;                         /* temporary pointer */
 char          c ;                            /* character */
 char         *fullname;

 tracef2("loadDIR: \"%s\" ihand = &%08X\n",((dirpathname == NULL) ? "" : dirpathname),(word)ihand) ;

 /* If the disc may have been changed then flush the directory cache. */
 if (ihand->disc_flags & disc_CHANGED) {
  flush_dir_cache(ihand);
  ihand->disc_flags &= ~disc_CHANGED;
 }

 if (dirpathname == NULL)
  dirpathname = "";
 fullname = dirpathname;
 /* Look in the cache for the directory.  If only the nearest ancestor is found then
  * dirpathname is set to point to the remainder of the path name.
  */
 dirstruct = match_cached_dir(fullname, &dirpathname, ihand);
 if (dirpathname == NULL)    /* If none of the path name remains then we've got an exact match. */
  return dirstruct;

 if (dirstruct == NULL) {
  /* Have to descend from the root directory. */

  /* calculate the ROOT directory size in bytes */
  int DIRsize = (ihand->disc_ROOTsize * DOSsecsize) ;

  int numFATs = ihand->disc_boot.BOOT_num_fats ; /* number of FAT copies */

  dirstruct = read_cache_dir("", -1,
                             (((numFATs * ihand->disc_FATsize) + DOSsecsize) / DOSsecsize) + 1,
                             DIRsize, 0, 0, 0, ihand);
 }

 /* actually step down through the directory structure */
 while (*dirpathname)
  {
   while (*dirpathname == dir_sep)    /* step over directory seperators */
    dirpathname++ ;

   tptr = dirpathname ;                  /* start of this directory entry */

   /* step over object looking for terminator */
   while ((*tptr != dir_sep) && (*tptr != '\0'))
    tptr++ ;

   /* SMC_DIR_CACHE: the following moved before writing '\0' to dirpathname */
   if (tptr == dirpathname)
    /* if we haven't moved then we assume "\" means "\." and the last
     * directory we loaded is the desired directory
     */
    break ;

   c = *tptr ;                /* remember character */
   *tptr = '\0' ;             /* and ensure we have a valid terminator */

   /* We must only search for entries that have the "FILE_subdir" flag
    * set.
    * Note: Sub-directories can have file extensions.
    *       Sub-directories are FILEs.
    */

   /* look for "dirpathname" at this directory level */
   index = 0 ;
   if ((dentry = findSUBDIR(dirpathname,&(dirstruct->dir_entries[0]),dirstruct->dir_size,&index)) != NULL)
    {
     int count = 0;
     DIR_info *olddir = dirstruct ;                 /* remember the old directory */
     word      sizedir = 0;
     int       next = get_FILE_cluster(dentry);
     word      allocsize = secsalloc(ihand) * DOSsecsize;

     while (next < CLUSTER_end(ihand)) {
      sizedir += allocsize;
      next = getnextCLUSTER(next, ihand);
      if ( (++count > ihand->disc_FATentries) || (next < CLUSTER_first(ihand)) )
        /* JRS 6/3/92 Added test to terminate loop in bad FAT */
        return_error0(DIR_info *,err_clusterchain) ;
     }

     dirstruct = read_cache_dir(fullname, 0, CLUSTERtoSECTOR(get_FILE_cluster(dentry), ihand),
                                sizedir, olddir->dir_sector, index - 1, olddir->dir_size, ihand);

     if (c == '\0')           /* if last terminator was NULL */
      break ;                 /* we have successfully scanned the tree */

     *tptr = c ;              /* replace character */
     dirpathname = tptr ;     /* and update the path pointer */

     continue ;               /* and continue down the path */
    }
   else
    {
     return_errorT(DIR_info *,err_objectnotfound,tok_objectnotfound,dirpathname,0) ;
    }
  }

 /* we have successfully found and loaded the last entry */
 return(dirstruct) ;
}

/*---------------------------------------------------------------------------*/

static int extend_dir(DIR_info **cdir,DOS_direntry **dentry,DOSdisc *ihand,DIR_info **pdir)
{
 int       startCLUSTER ;   /* start of existing CLUSTER chain */
 DIR_info *newdir ;         /* reference to new directory buffer */
 int       newsize;
 int       CLUSTERsize = cluster_size(&(ihand->disc_boot)) ;
 char     *cptr;

 tracef0("extend_dir: directory needs extending\n") ;

 *pdir = NULL ; /* ensure we do not have a parent directory reference */

 /* If the directory is the ROOT directory or has no parent then it cannot be extended */
 if ((*cdir)->dir_root != 0 || (*cdir)->dir_parentsec == 0)
  {
   return_error0(int,err_dirfull) ;
  }

 /* Load the parent directory for updating (cdir should be locked at a higher level). */
 tracef0("extend_dir: loading parent directory\n");
 cptr = strrchr((*cdir)->dir_name, dir_sep);
 if (cptr == NULL)
  *pdir = loadDIR("", ihand);
 else {
  int index = cptr - (*cdir)->dir_name;
  if ((cptr = malloc(index + 1)) == NULL)
   return_errorT(int, err_heapexhausted, tok_heapexhausted, 0, 0);
  strncpy(cptr, (*cdir)->dir_name, index);
  cptr[index] = '\0';
  *pdir = loadDIR(cptr, ihand);
  free(cptr);
 }
 if ((int)*pdir < 0)
  return -1;

 tracef1("extend_dir: old directory size = &%08X\n",(*cdir)->dir_size) ;
 newsize = (*cdir)->dir_size + CLUSTERsize ;
 tracef1("extend_dir: new directory size = &%08X\n",newsize) ;

 /* Copy the current directory "(*cdir)" into a new (larger) buffer
  * (adding the new CLUSTER).
  */
 newdir = (DIR_info *)malloc(sizeof(DIR_info) + newsize - sizeof(DOS_direntry)) ;
 if (newdir == NULL)
  {
   *pdir = NULL ;
   return_errorT(int,err_heapexhausted, tok_heapexhausted, 0, 0) ;
  }

 memmove((char *)newdir, (char *)(*cdir), (sizeof(DIR_info) + (*cdir)->dir_size - sizeof(DOS_direntry))) ;
 *dentry = (DOS_direntry *)((int)newdir + sizeof(DIR_info) + (*cdir)->dir_size - sizeof(DOS_direntry)) ;
 bzero((char *)*dentry, CLUSTERsize) ;
 (*dentry)->FILE_status = FILE_lastentry ;

 /* JRS 27/3/92 recognising that dentry[0] is about to be used, we should make a
  * new end-of-directory entry. However, the bzero above acheives this as a
  * side-effect since FILE_lastentry=0. */

 /* We've done the main bits that could go wrong so claim the space from the FAT. */
 startCLUSTER = SECTORtoCLUSTER((*cdir)->dir_sector,ihand) ;
 tracef1("extend_dir: Directory start cluster = &%03X\n",startCLUSTER) ;

 if ((startCLUSTER = adjustusedchain(startCLUSTER, newsize / CLUSTERsize, ihand)) < 0) {
   free(newdir);
   *pdir = NULL;
   return -1;
 }

 /* and update the directory pointer */
 realloc_dir_cache(*cdir, newdir);
 *cdir = newdir ;
 (*cdir)->dir_size = newsize;
 set_dir_flags(*cdir, dir_MODIFIED) ; /* directory has been updated */

 /* update the relevant directory entry in the parent */
 ((*pdir)->dir_entries)[(*cdir)->dir_parentindex].FILE_size = newsize;
 set_dir_flags(*pdir, dir_MODIFIED);

 /* and return to the caller */
 return(0) ;
}

/*---------------------------------------------------------------------------*/

static int saveFILE(char *fname,char *leafname,word ld,word ex,char *bs,word len,DIR_info **cdir,DOS_direntry **dentry,int fzero,DOSdisc *ihand)
{
 /* in: fname    : full path name
  *     leafname : NULL terminated filename
  *     ld       : load address
  *     ex       : exec address
  *     bs       : base address
  *     len      : length of data
  *     cdir     : current directory (where file is to be placed)
  *     fzero    : TRUE if we are to zero the data CLUSTERs
  *     ihand    : filesystem image handle
  */
 int           CLUSTERsize ;
 int           CLUSTERs_required ;
 int           loop ;
 int           startCLUSTER ; /* cluster where the file starts */
 time5byte     saveTIME ;     /* local time save started at */
 DIR_info     *pdir = NULL ;  /* parent directory */

 if ((int)len < 0)
   return_error0(int, err_discfull);

 localTIME(&saveTIME) ;

 tracef3("saveFILE: \"%s\" len &%08X (*cdir = &%08X)\n",leafname,len,(int)(*cdir)) ;

 /* calculate the number of complete clusters required to hold the object */
 CLUSTERsize = cluster_size(&(ihand->disc_boot)) ;
 CLUSTERs_required = ((len + (CLUSTERsize - 1)) / CLUSTERsize) ;

 tracef1("saveFILE: CLUSTERs_required = %d\n",CLUSTERs_required) ;

 /* check to see if the file already exists */
 /* start at the beginning of the directory */
 loop = 0 ;
 if ((*dentry = findDIRentry(leafname,&((*cdir)->dir_entries[0]),(*cdir)->dir_size,&loop))!=NULL)
  {
   tracef0("saveFILE: file already exists\n") ;

   /* Make sure that the file is not open. */
   if (find_open_file(fname, *dentry, ihand) >= 0)
    return_error1(int, err_fileopen, fname);

   /* Make sure the file isn't locked. */
   if (((*dentry)->FILE_attribute & FILE_readonly) != 0)
    return_error1(int, err_filelocked, fname);

   startCLUSTER = get_FILE_cluster(*dentry) ;

   if ((startCLUSTER = adjustusedchain(startCLUSTER, CLUSTERs_required, ihand)) < 0)
     return -1;
  }
 else
  {
   tracef0("saveFILE: file does NOT exist\n") ;

   /* find a suitable free directory entry */
   if ((*dentry = findemptyDIRentry(&((*cdir)->dir_entries[0]),(*cdir)->dir_size)) == NULL)
    {
     if (extend_dir(cdir,dentry,ihand,&pdir) < 0)
       return(-1) ; /* error already defined */
    }

   /* "*dentry" = pointer to the directory entry to create */

   if ((startCLUSTER = claimfreeclusters(CLUSTERs_required, ihand)) < 0)
     return -1;
  }

 /* write the information into the directory entry
  *
  * This requires the filename to be split into name and extension fields
  * We fill the name with SPACEs first (the string terminator (NULL) is
  * placed in the attributes field)
  *
  * NOTE: these should be done in this order due to the fact that the
  *       text building function terminates each string with a NUL
  */
 set_dir_flags(*cdir, dir_MODIFIED) ; /* directory updated */
 sprintf((char *)&((*dentry)->FILE_status),"           ") ;
 before((char *)&((*dentry)->FILE_status),leafname,file_sep,1) ;
 after((char *)&((*dentry)->FILE_extension),leafname,file_sep,1) ;
 /* mark the file as suitable for archiving */
 (*dentry)->FILE_attribute = FILE_archive ;
 bzero((char *)&((*dentry)->FILE_reserved),spare1) ; /* ZERO "spare1" bytes */
 put_FILE_time((*dentry),RISCOStoTIME(&saveTIME)) ;
 put_FILE_date((*dentry),RISCOStoDATE(&saveTIME)) ;

 tracef1("saveFILE: startCLUSTER = &%03X\n",startCLUSTER) ;

 put_FILE_cluster((*dentry),startCLUSTER) ;
 (*dentry)->FILE_size = len ;

 /* copy the data from memory into the allocated clusters */
 /* use "saveOBJECT" to perform this */
 if (fzero == 0 && len)
  {
   if (DOS_object_RW(Wdata,startCLUSTER,bs,len,ihand) != 0)
    {
     tracef0("saveFILE: \"saveOBJECT\" call failed\n") ;
     return -1;
    }
  }

 /* Update the load and exec addresses */
 update_loadexec(*dentry, ld, ex);

 if (pdir != NULL) {
  if (ensure_directory(pdir) != 0) {
   return -1;
  }
 }

 /* now ensure all the directory information and FATs onto the disc */
 if ((ensure_directory(*cdir) != 0) || (ensure_FATs(ihand) != 0))
  return(-1) ; /* error already defined */

 /* and we have a nice return */
 return(0) ;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/* attributes: */

static word DOStoRISCOSattributes(DOS_direntry *dentry)
{
 word aval = 0x00000000 ;
 int   loop ;

 /* produce RISC OS type attributes for the given DOS directory entry */

 /* all objects start read/write */
 if ((dentry->FILE_attribute & FILE_subdir) == 0)
  aval |= (ownerread | ownerwrite) ;

 for (loop=0; (loop < 8); loop++)
  {
   if ((dentry->FILE_attribute & (1 << loop)) != 0)
    {
     switch (1 << loop)
      {
       case FILE_readonly :
#if !ReadOnlyMapsLocked /* JRS 9/3/92 map DOS ReadOnly bit to RISC OS Locked bit only */
                            aval &= ~ownerwrite ;
#endif
                            aval |= objectlocked ;
                            break ;

/* JRS: 4/3/92 This conflicts with NetFS use of these bits */
       case FILE_hidden   : if ((dentry->FILE_attribute & NetFSattributebits)==0)
                             aval |= objecthidden ;
                            break ;

       case FILE_system   : if ((dentry->FILE_attribute & NetFSattributebits)==0)
                             aval |= objectsystem ;
                            break ;

       case FILE_archive  : if ((dentry->FILE_attribute & NetFSattributebits)==0)
                             aval |= objectupdated ;
                            break ;

       default            : break ;     /* no action on undefined flags */
      }
    }
  }

 return(aval) ;
}

/*---------------------------------------------------------------------------*/

static unsigned char RISCOStoDOSattributes(word ROSattr)
{
 byte aval = 0x00 ;

 /* produce DOS type attributes for the given RISC OS attribute flags */

 /* NOT owner write then set the readonly flag */
#if ReadOnlyMapsLocked /* JRS 9/3/92 map DOS ReadOnly bit to RISC OS Locked bit only */
 if (ROSattr & objectlocked)
#else
 if ((ROSattr & ownerwrite) == 0 || (ROSattr & objectlocked) != 0)
#endif
  aval |= FILE_readonly ;

 /* JRS: 4/3/92 HORRIBLE! This conficts with NetFS use of these bits
  * Check if the NetFS bits are zero, and assume they are ours if so */
 if ((ROSattr & NetFSattributebits & ~extraDOSattributebits) == 0)
  {
  /* check for the special flags we have placed in the ADFS unused area */
  if ((ROSattr & objecthidden) != 0)
   aval |= FILE_hidden ;

  if ((ROSattr & objectsystem) != 0)
   aval |= FILE_system ;

  if ((ROSattr & objectupdated) != 0)
   aval |= FILE_archive ;
  }

 return(aval) ;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/* resolvePATH: from a given object resolve the actual directory referenced  */
/*              lname is set to point to the leafname part of pname and      */
/*                pname is 0 terminated before the leafname                  */

static int resolvePATH(char *pname,DIR_info **ndir,char **lname,DOSdisc *ihand)
{
 char *cptr = &pname[strlen(pname)] ;

 tracef1("DOSFS: resolvePATH: \"%s\"\n",pname) ;

 /* step backwards looking for directory seperator or beginning */
 for (; ((*cptr != dir_sep) && (cptr != pname)); cptr--) ;

 if (cptr == pname)
  {
   tracef0("DOSFS: resolvePATH: (cptr == pname)\n") ;
   if (*cptr != dir_sep) {
    char c1 = '\0', c2;
    do {
     c2 = *cptr;
     *cptr++ = c1;
     c1 = c2;
    } while (c1 != '\0');
   }
   *cptr = '\0';
   *lname = pname + 1;
  }
 else
  {
   tracef0("DOSFS: resolvePATH: we must resolve the path to the directory\n") ;
   *cptr++ = '\0';
   *lname = cptr ;
  }

 *ndir = loadDIR(pname, ihand) ;
 if ((int)(*ndir) == -1)
  return(-1) ; /* error already defined */

 return(0) ;
}

/*---------------------------------------------------------------------------*/
/* restorePATH: return a pointer to a restored path split by resolvePATH     */

static char *restorePATH(char *pname, char *lname)
{
  if (--lname == pname)
    return ++lname;
  *lname = dir_sep;
  return pname;
}

/*---------------------------------------------------------------------------*/

typedef enum {
              wdi_NONE,    /* should never be used */
              wdi_LOAD,    /* update the load exec with the value given */
              wdi_EXEC,    /* update the exec address with the value given */
              wdi_ATTR,    /* update the attributes with the value given */
              wdi_FLEN,    /* update the filelength with the value given */
              wdi_SCLUSTER /* start CLUSTER of the file image */
             } wdi_flags ;

static int write_dirinfo(char *fname,word bitmap,word loadaddr,word execaddr,word attr,word filelen,int startCLUSTER,DOSdisc *ihand)
{
 DIR_info     *cdir ;       /* directory where "leafname" resides */
 char         *DOSname ;    /* pathname of referenced file */
 char         *leafname ;   /* pointer into "DOSname" of leaf filename */
 int           loop ;       /* general counter */
 DOS_direntry *dentry ;     /* directory entry structure pointer */

 tracef6("write_dirinfo: bitmap &%08X, ld &%08X, ex &%08X, attr &%08X, flen &%08X, sC = &%03X\n",bitmap,loadaddr,execaddr,attr,filelen,startCLUSTER) ;

 /* convert "fname" to DOS path format */
 if ((DOSname = (char *)malloc(MaxString)) == NULL)
  return_errorT(int,err_heapexhausted,tok_heapexhausted,0,0) ;

 if ((int)convertRISCOStoDOS(fname, DOSname) < 0) {
  free(DOSname);
  return -1;
 }

 /* resolve the path (ie. load the directory the file is in) */
 if (resolvePATH(DOSname,&cdir,&leafname,ihand) < 0)
  {
   free(DOSname) ;
   return(-1) ; /* error already defined */
  }

 /* search the directory for the named object */
 loop = 0 ;
 tracef1("write_dirinfo: looking for leafname \"%s\"\n",leafname) ;
 if ((dentry = findDIRentry(leafname,&(cdir->dir_entries[0]),cdir->dir_size,&loop)) != NULL)
  {
   time5byte le ;
   word      dosext = 0x00000000 ;

   /* If changing length or start cluster then make sure that the file is not open. */
   if (bitmap & ((1 << wdi_FLEN) | (1 << wdi_SCLUSTER))) {
     if (find_open_file(fname, dentry, ihand) >= 0) {
       free(DOSname);
       return_error1(int, err_fileopen, fname);
     }
   }

   if (buildFILEname(dentry,DOSname) != NULL)
    (void)after((char *)&dosext,DOSname,file_sep,1) ;

   read_loadexec(dentry,dosext,&le) ;

   /* We read the current load and exec addresses, so that they can be
    * written together, but changed seperately (if required).
    */
   if (bitmap & (1 << wdi_LOAD))
    le.hi = loadaddr ;

   if (bitmap & (1 << wdi_EXEC))
    le.lo = execaddr ;

   update_loadexec(dentry,le.hi,le.lo) ;    /* and update the load/exec info */

   /* preserve directory bit over attr change (should possibly do archive) */
   if (bitmap & (1 << wdi_ATTR)) {
    if ((dentry->FILE_attribute & FILE_subdir) != 0) {
     if ((attr & objectlocked) == 0)
      attr |= ownerwrite;
     dentry->FILE_attribute = RISCOStoDOSattributes(attr) | FILE_subdir;
    } else
     dentry->FILE_attribute = RISCOStoDOSattributes(attr) ;
   }

   if (bitmap & (1 << wdi_FLEN))
    dentry->FILE_size = filelen ;           /* update the length */

   if (bitmap & (1 << wdi_SCLUSTER))
    put_FILE_cluster(dentry,startCLUSTER) ; /* update the starting CLUSTER */

   set_dir_flags(cdir, dir_MODIFIED) ; /* directory entry had been updated */

   if (ensure_directory(cdir) != 0)
    {
     flush_dir_cache(ihand);
     free(DOSname) ;
     return(-1) ; /* error already defined */
    }
  }
 else
  {
   /* file not found in this directory */
   free(DOSname) ;
   return_errorT(int,err_objectnotfound,tok_objectnotfound,fname,0) ;
  }

 free(DOSname) ;
 return(0) ;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

static FS_dir_block *read_dir(int rtype,char *fname,word dest,word num,word off,word blen,DOSdisc *ihand)
{
 /* in:
  *     rtype : leafnames (0) or full information (-1)
  *     fname : NULL terminated ASCII pathname, relative to ROOT of image
  *     dest  : destination memory address for data
  *     num   : number of objects to read
  *     off   : offset into directory
  *     blen  : "dest" buffer length
  *     ihand : filesystem image handle
  */
 char          *DOSname = NULL ;     /* converted pathname */
 DIR_info      *cdir = NULL ;        /* pointer to the loaded directory */
 FS_entry_info *entries = (FS_entry_info *)dest ;
 int            numread = 0 ;
 DOS_direntry  *dentry ;
 char          *nbuff = (char *)malloc(DOSnamesize) ;
 int            loop ;               /* general counter */

 tracef2("read_dir: rtype = %d, ihand = &%08X\n",rtype,(int)ihand) ;
 tracef5("read_dir: \"%s\" (dest = &%08X) num = %d, off = %d, blen = %d\n",((fname == "") ? "NULLptr" : fname),dest,num,off,blen) ;

 /* out:
  *     dblock.objects_read = number of records read
  *     dblock.next_offset  = offset of next item to be read (-1 if end)
  */
 /* default return state */
 dblock.objects_read = 0 ;      /* no records read */
 dblock.next_offset = -1 ;      /* next entry is end of directory */

 if (nbuff == NULL) /* check name buffer allocation */
  return_errorT(FS_dir_block *,err_heapexhausted,tok_heapexhausted,0,0) ;

 /* parse the name and load the relevant directory */
 /* the "(DOSdisc *)ihand" structure references the cached information */
 /* a NULL path refers to the ROOT of the filesystem */
 /* always return ACORN style names (truncated if necessary) */
 /* convert "fname" to DOS path format */
 if ((DOSname = (char *)malloc(MaxString)) == NULL)
  {
   free(nbuff) ;
   return_errorT(FS_dir_block *,err_heapexhausted,tok_heapexhausted,0,0) ;
  }

 if ((int)convertRISCOStoDOS(fname, DOSname) < 0) {
  free(DOSname);
  free(nbuff);
  return (FS_dir_block *)-1;
 }

 /* load the desired directory */
 cdir = loadDIR(DOSname, ihand) ;
 if ((int)cdir == -1)
  {
   tracef0("read_dir: no directory loaded\n") ;
   free(DOSname) ;
   free(nbuff) ;
   return((FS_dir_block *)-1) ; /* error message already defined */
  }

 /* start reading entries from the requested offset */
 loop = off ;
 do
  {
   if ((dentry = getnextDIRentry(&(cdir->dir_entries[0]),cdir->dir_size,&loop)) != NULL)
    {
     /* "getnextDIRentry" returns all FILE types:
      * This includes volume labels and hidden and system files. At the
      * moment we only stop volume labels from being returned.
      */
     tracef1("read_dir: loop = %d\n",loop);
     if ((dentry->FILE_attribute & FILE_volume) == 0)
      {
       /* we have a listable directory entry */
       char *cfile ;
       word  entrysize ;

       if ((cfile = buildFILEname(dentry,nbuff)) != NULL)
        {
         word dosext = 0x00000000 ; /* ensure zero start */

         /* check to see if we have an ".ext" -> RISC OS filetype mapping */
         (void)after((char *)&dosext,cfile,file_sep,1) ;

         if ((int)convertDOStoRISCOS(cfile, DOSname) < 0) {
          free(DOSname) ; /* release converted pathname buffer */
          free(nbuff) ;   /* release converted name buffer */
          return (FS_dir_block *)-1;
         }
         cfile = DOSname ;

         /* calculate the size of this entry (word-aligned) */
         if (rtype)
          {
           entrysize = strlen(cfile) + (sizeof(FS_entry_info) - 3) ;
           entrysize = wordalign(entrysize) ;
          }
         else
          entrysize = strlen(cfile) + 1 ; /* include terminating NULL */

         if (((word)entries + entrysize) <= ((word)dest + blen))
          {
           time5byte le ;

           if (rtype)
            MSDOStoRISCOS(get_FILE_time(dentry),get_FILE_date(dentry),&le) ;

           /* check if the file has RISC OS information in its spare bytes */
           if (rtype)
            {
             int value = get_FILE_ROStype(dentry) ;
             if (value != 0) /* non-NULL then this is the RISC OS filetype */
              le.hi = (le.hi & ~ADFStypemask) | (value << 8) ;
             else
              {
               mapentry *cmap ;
               /* NO so use the calculated DOS extension */
               for (cmap = maplist; (cmap); cmap = cmap->next)
                if (cmap->dosext == dosext)
                 {
                  le.hi = (le.hi & ~ADFStypemask) | (cmap->ROtype << 8) ;
                  break ; /* the for loop */
                 }
              }

             /* RISC OS required information */
             entries->loadaddr = le.hi ;
             entries->execaddr = le.lo ;
             entries->flength = dentry->FILE_size ;
             entries->attributes = DOStoRISCOSattributes(dentry) ;
             entries->type = (((dentry->FILE_attribute & FILE_subdir) == 0) ? object_file : object_dir) ;
            }

           /* copy the filename into the destination structure */
           if (rtype)
            strcpy(entries->fname,cfile) ;
           else
            strcpy((char *)entries,cfile) ;

           /* and update the reference information */
           entries = (FS_entry_info *)((word)entries + entrysize) ;
           numread++ ;        /* count this entry */
          }
         else
          {
           loop-- ; /* we need to re-do this entry on the next call */
           break ;
          }
        }
       else
        {
         free(DOSname) ; /* release converted pathname buffer */
         free(nbuff) ;   /* release converted name buffer */
         return_error0(FS_dir_block *,err_namereadfailed) ;
        }
      }
    }
  } while ((numread < num) && ((dentry != NULL) && (loop >= 0))) ;

 if (numread > 0) {
  dblock.objects_read = numread ;
  dblock.next_offset = loop ;
 }

 free(DOSname) ;        /* release converted pathname buffer */
 free(nbuff) ;          /* release converted name buffer */

 tracef2("read_dir: dblock.objects_read = %d, dblock.next_offset = %d\n",dblock.objects_read,dblock.next_offset);
 return(&dblock) ;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/* findDIRtype:
 * look for the first object with the given attributes flags set
 */

DOS_direntry *findDIRtype(byte ftype,DOS_direntry *directory,int dir_size,int *index)
{
 DOS_direntry *dentry = NULL ;

 tracef3("findDIRtype: ftype &%02X, directory = &%08X, index = %d\n",ftype,(int)directory,*index) ;

 do
  {
   dentry = getnextDIRentry(directory,dir_size,index) ;
  } while ((dentry != NULL) && ((dentry->FILE_attribute & ftype) == 0)) ;

 tracef1("findDIRtype: FILE_attribute = &%02X\n",dentry->FILE_attribute) ;

 /* will either be NULL (index set to -1), or a valid directory entry */
 return(dentry) ;
}

/*-------------------------------------------------------------------------*/
/*-- IMAGE OPEN/CLOSE functions -------------------------------------------*/
/*-------------------------------------------------------------------------*/

DOSdisc *DOSFS_image_open(word fshand,word buffsize)
{
 /* in:
  *     fshand   : FileSwitch handle for new image file
  *     buffsize : buffer size (0 = not known)
  */
 DOS_bootsector   *dboot = NULL ;   /* cached disc boot block */
 DOS_partition    *DOSpart = NULL ; /* winchester partition information */
 byte             *pentry ;         /* wini partition description pointer */
 word              winioffset = 0 ; /* partition start within wini images */
 word              winisize = 0 ;   /* winchester media size */
 DOSdisc          *ddisc = NULL ;   /* cached disc description */
 byte              numFATs ;        /* number of FATs in the image */
 word              FATsize ;        /* size of FAT in bytes */
 word              FATentries ;     /* number of entries in FAT */
 word              numRESVD ;       /* number of reserved (unused) sectors */
 word              ROOTsize ;       /* size of ROOT directory in sectors */
 int               loop ;           /* general counter */
 word              discaddress = 0x00000000 ;
 _kernel_swi_regs  reglist ;        /* for SWI calls */
 _kernel_oserror  *rerror ;         /* for standard RISC OS error structures */

 tracef2("\n\nDOSFS_image_open: fshand = &%08X, buffsize = &%08X\n",fshand,buffsize) ;
 /* We can assume that FileSwitch has only called us with files of the correct
  * type (ie. we need perform no 12bit filetype identification on the passed
  * FileSwitch handle).
  */

 /* Construct an internal file handle structure that contains the FileSwitch
  * handle, plus any other useful information. We will return the pointer to
  * this structure as the image handle.
  *
  * We need to distinguish between DOS and Atari floppies and DOS winchesters
  * (Winchesters use the "disc_winioffset" word, for floppies this needs to
  * be initialised to 0x00000000).
  */

 /* CACHE the "disc" information */
 if ((dboot = (DOS_bootsector *)malloc(sizeof(DOS_bootsector))) == NULL)
  {
   tracef0("DOSFS_image_open: unable to allocate memory for BOOT sector\n") ;
   return_errorT(DOSdisc *,err_heapexhausted,tok_heapexhausted,0,0) ;
  }

 tracef1("DOSFS_image_open: dboot = &%08X\n",(int)dboot) ;

 /* At the moment there is no simple way of differentaiting between winchester
  * partitions and those of floppy images. MS-DOS manages by the explicit
  * drive hardware differences. We are accessing the disc images via the same
  * file interface.
  * The following code performs a few simple checks to differentiate between
  * the image types.
  */

 /* read the BOOT BLOCK from the image */
 /* This code RELIES on (DOS_BOOT_sector == DOS_PARTITION_sector) */
 discaddress = (DOS_BOOT_sector - 1) * DOSsecsize ;
 reglist.r[0] = osgbpb_rptr ;   /* read operation */
 reglist.r[1] = fshand ;        /* FileSwitch handle */
 reglist.r[2] = (word)dboot ;   /* destination address */
 reglist.r[3] = DOSsecsize ;    /* fixed in MS-DOS */
 reglist.r[4] = discaddress ;   /* offset within FileSwitch file */
 reglist.r[5] = NULL ;
 reglist.r[6] = NULL ;
 if ((rerror = _kernel_swi(OS_GBPB,&reglist,&reglist)) != NULL)
  {
   free(dboot) ;
   return_errorX(DOSdisc *,rerror) ;    /* error already defined */
  }

 /* If this doesn't look like a BOOT block then try a partition. */
#if 1 /* PCMCIA */
 if (sector_size(dboot) != DOSsecsize) {
#else
 if (sector_size(dboot) != DOSsecsize || dboot->BOOT_num_fats != 2) {
#endif
  tracef0("DOSFS_image_open: not a BOOT block, could be a partition.\n");
  DOSpart = (DOS_partition *)dboot ;

  /* Look for the partition with the "boot_ind" set to "bootable" */
  pentry = (byte *)&(DOSpart->p0_boot_ind) ;
  for (loop=0; (loop < 4); loop++) {
   if (pentry[0] == bootable)
    break ;
   pentry += sizeof(partition_entry) ;
  }

  if (loop == 4) {
   /* No bootable partition found - try to validify one of the partitions as
    * non-bootable, otherwise this can't be a valid DOS partition.
    */
   tracef0("DOSFS_image_open: not a bootable partition.\n");
   pentry = (byte *)&(DOSpart->p0_boot_ind);
   for (loop = 0; loop < 4; loop++) {
#ifdef OLD_PARTITION_TEST
    if (pentry[4] == partition_DOS || pentry[4] == partition_DR || pentry[4] == partition_NCR)
     break;
#else
    if (pentry[2] != 0) /* If start sector != 0 then we have found a possible partition table entry. */
     break;
#endif
    pentry += sizeof(partition_entry);
   }
  }

  if (loop != 4) {
   tracef1("DOSFS_image_open: partition type %d\n",pentry[4]) ;

   /* The following sector number, should be equivalent to that used to
    * construct the "disc_winioffset" variable.
    * DOS BOOT sector = WiniSector(pentry[3],pentry[1],pentry[2])
    */
   winioffset = ((pentry[8] | (pentry[9] << 8) | (pentry[10] << 16) | (pentry[11] << 24)) * DOSsecsize) ;
   tracef1("DOSFS_image_open: winioffset = &%08X\n",winioffset) ;

   /* Our system can now cope with winchester partitions with more than 0xFFFF
    * sectors
    */
   winisize = (pentry[12] | (pentry[13] << 8) | (pentry[14] << 16) | (pentry[15] << 24)) ;

   /* We could add the following check: (winisize <= "size of FileSwitch file")
    * to further check the validity of the partition information. If the
    * calculated offset is outside the image file then the following BOOT
    * BLOCK load will fail and give the user a "funny" error message, rather
    * than a specific DOSFS one.
    */

   discaddress = ((DOS_BOOT_sector - 1) * DOSsecsize) + winioffset ;
   reglist.r[0] = osgbpb_rptr ;
   reglist.r[1] = fshand ;
   reglist.r[2] = (word)dboot ;
   reglist.r[3] = DOSsecsize ;
   reglist.r[4] = discaddress ;
   reglist.r[5] = NULL ;
   reglist.r[6] = NULL ;
   if ((rerror = _kernel_swi(OS_GBPB,&reglist,&reglist)) != NULL)
    {
     free(dboot) ;
     return_errorX(DOSdisc *,rerror) ;
    }

   /* I am not sure if all MS-DOS BOOT BLOCKs contain a similar signature to
    * that provided in winchester PARTITION BLOCKs. MS-DOS 3.31 seems to do
    * so, and this may form another validation check on the destination BOOT
    * BLOCK. **** research into this ****
    */

#if 1 /* PCMCIA */
   /*if ((sector_size(dboot) != DOSsecsize) || (DOSFS_max_sect(dboot) != winisize))*/
   if (sector_size(dboot) != DOSsecsize)
#else
   if ((sector_size(dboot) != DOSsecsize) || (dboot->BOOT_num_fats != 2) || (DOSFS_max_sect(dboot) != winisize))
#endif
    {
     tracef0("DOSFS_image_open: invalid partition BOOT block\n") ;
     free(dboot) ;
     return_error0(DOSdisc *,err_notDOSimage) ;
    }
  } else {
   tracef0("DOSFS_image_open: image is not a DOS partition (could be 320K or 160K format)\n") ;
   /* Could still be a DOS 320K or 160K format as they do not need a valid boot block,
    * fake the info in the boot block (if it's not one of these then catch it later). */
   dboot->BOOT_secsize = 0x00;
   dboot->BOOT_secsizeHI = 0x02;
   dboot->BOOT_reserved = 0x01;
   dboot->BOOT_reservedHI = 0x00;
   dboot->BOOT_num_fats = 0x02;
   dboot->BOOT_magic = 0x00;
   dboot->BOOT_FAT_size = 0x01;
   dboot->BOOT_FAT_sizeHI = 0x00;
   dboot->BOOT_secstrack = 0x08;
   dboot->BOOT_secstrackHI = 0x00;
   dboot->BOOT_extra.floppy.hidden = 0x00;
   dboot->BOOT_extra.floppy.hiddenHI = 0x00;
  }
 }

 /* number of File Allocation Tables */
 numFATs = dboot->BOOT_num_fats ;
 /* bytesize of a FAT */
 FATsize = (dboot->BOOT_FAT_size | (dboot->BOOT_FAT_sizeHI << 8)) * DOSsecsize ;
 /* number of reserved (unusable) sectors */
 numRESVD = (dboot->BOOT_reserved | (dboot->BOOT_reservedHI << 8)) ;

 tracef1("DOSFS_image_open: numFATs    = %d\n",numFATs) ;
 tracef1("DOSFS_image_open: FATsize    = &%08X\n",FATsize) ;
 tracef1("DOSFS_image_open: numRESVD   = %d\n",numRESVD) ;

 /* allocate a DOS disc description structure large enough to hold a FAT
  * copy. Note: the disc description structure already includes a single "FAT"
  * sector.
  */
 if ((ddisc = (DOSdisc *)malloc(sizeof(DOSdisc) + (FATsize - sizeof(fFAT_sector)))) == NULL)
  {
   tracef0("DOSFS_image_open: unable to allocate memory for disc description\n") ;
   free(dboot) ;
   return_errorT(DOSdisc *,err_heapexhausted,tok_heapexhausted,0,0) ;
  }
 tracef1("DOSFS_image_open: ddisc = &%08X\n",(int)ddisc) ;

 /* remember the FileSwitch handle */
 ddisc->disc_fhand = fshand ;           /* FileSwitch handle of image file */

 ddisc->disc_winioffset = winioffset ;  /* offset into image */

 ddisc->disc_FATsize = FATsize ;       /* remember how big the FAT is */

 /* Copy the boot block into the disc description. */
 ddisc->disc_boot = *dboot ;           /* copy the disc boot sector */

 /* release the copy we originally allocated */
 free(dboot) ;
 /* but keep the pointer around for short-hand work */
 dboot = &(ddisc->disc_boot) ;

 ddisc->disc_FATentries = 0; /* Stop DOS_FAT_RW attempting to count the free clusters. */

 if (DOS_FAT_RW(Rdata, ddisc) < 0)
  {
   tracef0("DOSFS_image_open: unable to load DOS FAT sector(s)\n") ;
   free(ddisc) ;
   /* error message should already be defined */
   return_error0(DOSdisc *, err_fatloadfailed);
  }

 /* If the magic ID in the boot block is 0x00 then this is a 320K or 160K format
  * which needs some info to be filled in depending on the first byte of the FAT.
  */
 if (dboot->BOOT_magic == 0x00) {
  dboot->BOOT_magic = *((char *)&(ddisc->disc_FAT));
  if (dboot->BOOT_magic == 0xFE) {
   dboot->BOOT_secalloc = 0x01;
   dboot->BOOT_root_dir = 0x40;
   dboot->BOOT_root_dirHI = 0x00;
   dboot->BOOT_max_sect = 0x40;
   dboot->BOOT_max_sectHI = 0x01;
   dboot->BOOT_heads = 0x01;
   dboot->BOOT_headsHI = 0x00;
  } else if (dboot->BOOT_magic == 0xFF) {
   dboot->BOOT_secalloc = 0x02;
   dboot->BOOT_root_dir = 0x70;
   dboot->BOOT_root_dirHI = 0x00;
   dboot->BOOT_max_sect = 0x80;
   dboot->BOOT_max_sectHI = 0x02;
   dboot->BOOT_heads = 0x02;
   dboot->BOOT_headsHI = 0x00;
  } else {
   tracef0("DOSFS_image_open: not a valid DOS image\n");
   free(ddisc);
   return_error0(DOSdisc *, err_notDOSimage);
  }
 }

 /* size of the ROOT directory in sectors */
 ROOTsize = ((dboot->BOOT_root_dir | (dboot->BOOT_root_dirHI << 8)) * sizeof(DOS_direntry)) / DOSsecsize ;
 tracef1("DOSFS_image_open: ROOTsize   = &%08X\n",ROOTsize) ;

 /* place remaining information into the disc description record */
 ddisc->disc_ROOTsize = ROOTsize ;      /* in sectors */

 /* the start of the user allocatable sectors */
 ddisc->disc_startsec =  numRESVD + (numFATs * (FATsize / DOSsecsize)) + ROOTsize + 1 ;

 /* calculate the number of clusters available on this disc (use loop as a tmp variable) */
 loop = DOSFS_max_sect(dboot) / dboot->BOOT_secalloc ;

 tracef1("DOSFS_image_open: disc_ROOTsize = %d\n",ROOTsize) ;
 tracef1("DOSFS_image_open: disc_startsec = %d\n",ddisc->disc_startsec) ;
 tracef2("DOSFS_image_open: clusters = %d (&%08X)\n",loop,loop) ;

 /* the size of a FAT entry depends on the number of CLUSTERs */
 ddisc->disc_FATentry = ((loop < FAT_change) ? short_FAT_entry_len : long_FAT_entry_len) ;

 /* calculate the number of available cluster entries */
 /* clarification needed here:
  * DOSFS_max_sect returns the total number of sectors on the disc
  * disc_startsec is the 1-based index of the first sector on the disc used for file storage.
  * Thus the number of sectors available for file storage is (total sectors - (startsec-1))
  * JRS changed 2/3/92 ddisc->disc_startsec to (ddisc->disc_startsec-1)
  */
 FATentries = (DOSFS_max_sect(dboot) - (ddisc->disc_startsec-1)) / dboot->BOOT_secalloc ;
 tracef2("DOSFS_image_open: FATentries = &%x (%d)\n",FATentries,FATentries) ;

 ddisc->disc_FATentries = FATentries ; /* number of cluster entries */

 /* DOS_FAT_RW will not have filled in the disc_freeclusters field so we must do that here. */
 ddisc->disc_freeclusters = countfreeclusters(ddisc);

 /* We have successfully loaded all the information we need */
 ddisc->disc_flags = disc_UPDATEID ; /* next update should generate new disc ID */

 tracef1("DOSFS_image_open: ddisc = &%08X\n",(int)ddisc) ;

 /* out:
  *     return   : image filesystem handle for FileSwitch file
  */
 return(ddisc) ;
 UNUSED(buffsize) ; /* for the moment */
}

/*-------------------------------------------------------------------------*/

int DOSFS_image_close(DOSdisc *ihand)
{
 /* in:
  *     ihand : image filesystem handle for FileSwitch file
  */

 tracef1("\n\nDOSFS_image_close: ihand = &%08X\n",(word)ihand) ;

 /* All files opened onto this image should have been closed. This call
  * should just ensure any buffered data and then release the resources
  * attached to the image.
  */


 /* Flush the directory cache. */
 flush_dir_cache(ihand);

 /* If we just cache the FAT copies (and do not write-back during normal
  * operation) then we should write all the FAT copies to the image at
  * this point. At the moment we always ensure the FAT copies.
  */
 ensure_FATs(ihand);

 free(ihand) ;

 /* out:
  *     no conditions
  */

 return(0) ;
}

/*-------------------------------------------------------------------------*/

/* Extend or truncate the given file to the required length. */
static int DOSFS_ensure_exact(FILEhand *fhand,int ensure)
{
 int  CLUSTERsize ;         /* CLUSTER size in bytes */
 int  CLUSTERs_required ;   /* CLUSTERs required by the ensure operation */
 int  startCLUSTER ;        /* first CLUSTER allocated to file */
 int  newfilelen = ensure ; /* file length after truncation */

 tracef2("DOSFS_ensure_exact: fhand &%08X (fext &%08X)\n",(int)fhand,ensure) ;

 CLUSTERsize = cluster_size(&(fhand->ihand->disc_boot)) ;
 ensure = ((ensure + (CLUSTERsize - 1)) & ~(CLUSTERsize - 1)) ;
 CLUSTERs_required = (ensure / CLUSTERsize) ;

 startCLUSTER = fhand->startCLUSTER ;
 if ((startCLUSTER = adjustusedchain(startCLUSTER, CLUSTERs_required, fhand->ihand)) < 0)
   return -1;

 if (ensure_FATs(fhand->ihand) != 0) {
  /* We've messed up the FAT so re-load it. */
  DOS_FAT_RW(Rdata, fhand->ihand);
  return((word)-1) ; /* error already defined */
 }

 fhand->startCLUSTER = startCLUSTER ;
 fhand->filelen = newfilelen ;

 return(0) ;
}

/*-------------------------------------------------------------------------*/
/*-- IMAGE manipulation functions -----------------------------------------*/
/*-------------------------------------------------------------------------*/

FS_open_block *DOSFS_open_file(word op,char *fname,DOSdisc *ihand)
{
 DIR_info     *cdir ;           /* directory where the leafname resides */
 char         *DOSname ;        /* full DOS pathname */
 char         *leafname ;       /* pointer to the leafname of "DOSname" */
 char         *roname ;         /* original RISC OS name given */
 int           loop ;           /* general index variable */
 int           createfile = 0 ; /* non-zero if we need to create the file */
 DOS_direntry *dentry ;         /* directory entry pointer */
 FILEhand     *fdesc ;          /* file descriptor for open file */
 time5byte     le ;             /* for load/exec address information */
 word          dosext ;         /* DOS/RISC OS filetype extension */
 int           CLUSTERsize ;    /* CLUSTER size (in bytes) for this image */

 tracef3("\n\nDOSFS_open_file: op = %d, fname = \"%s\", ihand = &%08X\n",op,fname,(word)ihand) ;
 CLUSTERsize = cluster_size(&(ihand->disc_boot)) ;

 /* in:
  *     op    : type of open to perform
  *     fname : NULL terminated ASCII pathname, relative to ROOT of image
  *     ihand : filesystem handle onto the image
  *
  * op = 0 -> then open for reading             (error if file doesn't exist)
  * op = 1 -> then open for writing             (create file)
  * op = 2 -> then open for reading and writing (error if file doesn't exist)
  *
  * out:
  *     fblock.information = access flags -> bit 31 WRITE; bit 30 READ
  *     fblock.inhand      = internal filesystem handle for this file
  *     fblock.buffsize    = buffer size of 2^n (n = 6..10))
  *     fblock.fileext     = file length
  *     fblock.falloc      = file allocation (buffer multiple)
  *
  * If the returned internal filesystem handle is 0, then the file open
  * failed.
  *
  * NOTE: The current version of FileSwitch seems to perform a CREATE
  *       operation before performing the open_file. This means that the
  *       create code in this function is probably redundant. However, it
  *       is worth keeping it for the moment.
  */

 /* create a open file descriptor (even though we may fail later) */
 if ((fdesc = (FILEhand *)malloc(sizeof(FILEhand))) == NULL)
  return_errorT(FS_open_block *,err_heapexhausted,tok_heapexhausted,0,0) ;

 /* default return information */
 fblock.inhand = fdesc ;        /* internal file handle */
 fblock.buffsize = 0 ;
 fblock.fileext = 0 ;
 fblock.falloc = 0 ;

 /* default file descriptor information */
 fdesc->ihand = ihand ;       /* handle onto the image */
 fdesc->opentype = op ;       /* type of open operation */
 fdesc->loadaddr = 0 ;        /* current object load address */
 fdesc->execaddr = 0 ;        /* current object exec address */
 fdesc->startCLUSTER = -1 ;   /* this object has no data */
 fdesc->currentCLUSTER = -1 ; /* nor any current data */
 fdesc->filelen = 0 ;         /* current object length */
 fdesc->indexptr = 0 ;        /* sequential pointer */
 fdesc->modified = 0 ;        /* buffer unmodified */
 fdesc->filebuff = NULL ;     /* no data buffer */

 /* convert "fname" to DOS path format */
 if ((DOSname = (char *)malloc(MaxString)) == NULL)
  {
   free(fdesc) ;
   return_errorT(FS_open_block *,err_heapexhausted,tok_heapexhausted,0,0) ;
  }
 if ((roname = (char *)malloc(strlen(fname) + 1)) == NULL)
  {
   free(DOSname) ;
   free(fdesc) ;
   return_errorT(FS_open_block *,err_heapexhausted,tok_heapexhausted,0,0) ;
  }
 strcpy(roname,fname) ;     /* take a copy of the original filename */
 fdesc->fname = roname ;    /* and reference it in the file handle structure */

 if ((int)convertRISCOStoDOS(fname, DOSname) < 0) {
  free(roname);
  free(DOSname);
  free(fdesc);
  return (FS_open_block *)-1;
 }

 /* load the desired directory (also returns the leafname) */
 if (resolvePATH(DOSname,&cdir,&leafname,ihand) < 0)
  {
   free(roname) ;
   free(DOSname) ;
   free(fdesc) ;
   return((FS_open_block *)-1) ; /* error already defined */
  }

 /* if creating then check that "leafname" does NOT contain wildcards */
 if ((op == 1) && (leafname != NULL))
  {
   if (checknotwildcarded(leafname, DOSwcmult, DOSwcsing) != NULL)
    {
     free(roname) ;
     free(DOSname) ;
     free(fdesc) ;
     return_error1(FS_open_block *,err_wildcardedname,fname) ;
    }
  }

 /* search the loaded directory */
 loop = 0 ;
 if ((dentry = findDIRentry(leafname,&(cdir->dir_entries[0]),cdir->dir_size,&loop)) != NULL)
  {
   int mode;
   tracef0("DOSFS_open_file: object exists\n") ;

   /* Check that the file is not open but allow multiple read only opens. */
   if ((mode = find_open_file(fname, dentry, ihand)) >= 0 && (mode + op) > 0) {
    free(roname);
    free(DOSname);
    free(fdesc);
    return_error1(FS_open_block *, err_fileopen, leafname);
   }

   if (!(dentry->FILE_attribute & FILE_subdir) && (op > 0) && (dentry->FILE_attribute & FILE_readonly) != 0) {
    free(roname);
    free(DOSname);
    free(fdesc);
    return_error1(FS_open_block *, err_filelocked, leafname);
   }

   /* get the MSDOS extension characters */
   (void)after((char *)&dosext,leafname,file_sep,1) ;

   /* if "op == 1" then we must delete any old copy of the file first */
   if (op == 1)
    {
     tracef0("DOSFS_open_file: delete existing file\n") ;
     if ((dentry->FILE_attribute & FILE_subdir) != 0)
      {
       free(roname) ;
       free(DOSname) ;
       free(fdesc) ;
       return_errorT(FS_open_block *,err_notfile,tok_notfile,fname,0) ;
      }

     set_dir_flags(cdir, dir_MODIFIED) ;
     dentry->FILE_status = FILE_deleted ;
     freeclusters(get_FILE_cluster(dentry),ihand) ;
     createfile = -1 ; /* we need to create a new file */
    }
  }
 else
  {
   tracef0("DOSFS_open_file: object does not exist\n") ;
   if (op != 1)
    {
     free(roname) ;
     free(DOSname) ;
     free(fdesc) ;
     return_errorT(FS_open_block *,err_objectnotfound,tok_objectnotfound,fname,0) ;
    }

   tracef0("DOSFS_open_file: create operation specified\n") ;
   createfile = -1 ;    /* create option specified */
  }

 if (createfile != 0)
  {
   set_dir_flags(cdir, dir_LOCKED);
   /* generate a directory entry for the file */
   if (saveFILE(fname,leafname,0,0,NULL,0,&cdir,&dentry,1,ihand) < 0)
    {
     /* failed to save the file */
     tracef0("DOSFS_open_file: failed to save empty file\n") ;
     unset_dir_flags(cdir, dir_LOCKED);
     DOS_FAT_RW(Rdata, ihand);
     free_dir_cache(DOSname, ihand);
     free(roname) ;
     free(DOSname) ;
     free(fdesc) ;
     /* the error message should already be defined */
     return((FS_open_block *)-1) ;
    }
   unset_dir_flags(cdir, dir_LOCKED);

   /* get the directory entry for this newly created file */
   loop = 0 ;
   if ((dentry = findDIRentry(leafname,&(cdir->dir_entries[0]),cdir->dir_size,&loop)) == NULL)
    {
     tracef0("DOSFS_open_file: failed to find newly created file\n") ;
     free(roname) ;
     free(DOSname) ;
     free(fdesc) ;
     return_errorT(FS_open_block *,err_objectnotfound,tok_objectnotfound,fname,0) ;
    }
   /* "dentry" for the newly created file */
   if ((ensure_directory(cdir) != 0) || (ensure_FATs(ihand) != 0))
    {
     free(roname) ;
     free(DOSname) ;
     free(fdesc) ;
     return((FS_open_block *)-1) ; /* error already defined */
    }
  }

 if ((dentry->FILE_attribute & FILE_subdir) == 1)
  fblock.information = ((1 << 30) | (1 << 29)) ; /* object is directory */
 else
  fblock.information = ((1 << 30) | ((op != 0) ? ((unsigned)1 << 31) : 0)) ;

 tracef1("DOSFS_open_file: fdesc (before)     = &%08X\n",(int)fdesc) ;
 tracef1("DOSFS_open_file: FILE_list (before) = &%08X\n",(int)FILE_list) ;
 fdesc->next = FILE_list ;    /* reference the current open file list */
 FILE_list = fdesc ;          /* place our handle at the head of the list */
 tracef1("DOSFS_open_file: FILE_list (after)  = &%08X\n",(int)FILE_list) ;

 /* convert the MSDOS timestamp to a RISC OS 5byte value */
 MSDOStoRISCOS(get_FILE_time(dentry),get_FILE_date(dentry),&le) ;
 {
  int value = get_FILE_ROStype(dentry) ;
  if (value != 0)
   le.hi = (le.hi & ~ADFStypemask) | (value << 8) ;
  else
   {
    mapentry *cmap ;
    for (cmap = maplist; (cmap); cmap = cmap->next)
     if (cmap->dosext == dosext)
      {
       le.hi = (le.hi & ~ADFStypemask) | (cmap->ROtype << 8) ;
       break ;
      }
   }
 }
 fdesc->loadaddr = le.hi ; /* load address */
 fdesc->execaddr = le.lo ; /* exec address */

 fdesc->startCLUSTER = get_FILE_cluster(dentry) ;
 fdesc->filelen = dentry->FILE_size ;
 fdesc->indexptr = 0 ;          /* read/write pointer within file */
 fdesc->currentCLUSTER = -1 ;   /* number of currently buffered CLUSTER */
 fdesc->modified = 0 ;          /* wether CLUSTER has been modified */
 fdesc->filebuff = NULL ;       /* CLUSTER buffer pointer */

 /* "dentry" references the directory entry */
 fblock.inhand = fdesc ;
 fblock.buffsize = 0x00000100 ;       /* 256 bytes of buffer */
 fblock.fileext = dentry->FILE_size ;
 fblock.falloc = ((dentry->FILE_size + (CLUSTERsize - 1)) & -CLUSTERsize) ;

 free(DOSname) ;        /* release the translated name buffer */

 tracef3("DOSFS_open_file: fhand &%08X (len &%08X ptr &%08X)\n",(int)fdesc,fdesc->filelen,fdesc->indexptr) ;

 return(&fblock) ;      /* and return the open information */
}

/*-------------------------------------------------------------------------*/

/* Read or write bytes from the offset into the specified file. */
static int DOS_bytes_RW(int op, char *memaddr, word bytes, word foff, FILEhand *fhand)
{
  int clustercount = 0;
  DOSdisc *ihand = fhand->ihand;
  int clustersize, nextcluster;
  word size;
  int zero = 0;
  int result = 0;

  tracef5("DOS_bytes_RW: op = %c, memaddr = &%08X, bytes = %d, foff = %d, fhand = &%08X\n",
          (op == Rdata ? 'R' : 'W'), memaddr, bytes, foff, fhand);

  if (bytes == 0)
    return 0;

  if (op == Wzero) {
    zero = 1;
    op = Wdata;
  }

  /* Check if the request is outside the file. */
  if (foff + bytes > fhand->filelen) {
    if (op == Rdata) {
      /* If reading then generate an error for an offset outside the file but just
       * truncate the request if the requested number of bytes is too large.
       */
      if (foff > fhand->filelen) {
        return_error0(int, err_EOF);
      } else
        bytes = fhand->filelen - foff;
    } else {
      /* If writing then extend the file. */
      if (DOSFS_ensure(fhand, foff + bytes) < (foff + bytes))
        return -1;
    }
  }

  /* Determine which cluster the operation is to start in (on exit foff will contain
   * the offset within that cluster).
   */
  if ((nextcluster = clusterfromoffset(fhand->startCLUSTER, &foff, ihand)) < 0)
    return -1;

  /* If the operation is to write zeros then allocate a suitable block of memory and zero it. */
  clustersize = secsalloc(ihand) * DOSsecsize;
  if (zero) {
    char *cp;
    size = (bytes < clustersize ? bytes : clustersize);
    if ((cp = memaddr = (char *)malloc(size)) == NULL)
      return_errorT(int, err_heapexhausted, tok_heapexhausted, 0, 0);
    while (size--)
      *(cp++) = '\0';
  }

  while (bytes > 0) {
    if (nextcluster >= CLUSTER_end(ihand))
    {
      global_error0(err_EOF);
      result = -1;
      break;
    }
    tracef2("DOS_bytes_RW: cluster offset = %d, bytes left = %d\n",foff,bytes);

    /* Terminate loops in bad FAT. */
    if ( (++clustercount > ihand->disc_FATentries) || (nextcluster < CLUSTER_first(ihand)) )
    {
      global_error0(err_clusterchain);
      result = -1;
      break;
    }

#if 1
    if (bytes > clustersize-foff) {
      /* Try to read/write as much as possible straight to/from memory using a cluster multiple op. */
      size = (zero ? clustersize-foff : bytes);
      tracef2("DOS_bytes_RW: trying %d bytes starting at cluster %d\n",size,nextcluster);
      if ((nextcluster = DOS_multiple_RW(op, nextcluster, foff, memaddr, size, &size, ihand)) < 0)
      {
        result = -1;
        break;
      }
    } else {
      /* Do the last partial cluster. */
      size = bytes;
      tracef2("DOS_bytes_RW: transferring %d bytes in cluster %d\n",size,nextcluster);
      if ((nextcluster = DOS_cluster_RW(op, nextcluster, foff, memaddr, size, ihand)) < 0)
      {
        result = -1;
        break;
      }
    }
    foff = 0;         /* if we go round again then must have stopped at cluster boundary */
#else
    tracef3("DOS_bytes_RW: cluster=%d, offset=%d, bytes left=%d\n",nextcluster,foff,bytes);
    if (nextcluster == fhand->currentCLUSTER) {
      /* If we have the next cluster cached then just copy the data. */
      char *to, *from;
      size = (bytes > clustersize-foff) ? clustersize-foff : bytes;
      from = fhand->filebuff + foff;
      if (op == Rdata) {
        to = memaddr;
      } else {
        to = from;
        from = memaddr;
        fhand->modified = -1;
      }
      tracef1("DOS_bytes_RW: transferring %d bytes to/from cache\n",size);
      memcpy(to, from, size);
      if ((foff += size) == clustersize) {
        /* If we have reached the end of this cluster then move on to the next. */
        nextcluster = getnextCLUSTER(nextcluster, ihand);
        foff = 0;
      }
    } else if (bytes > clustersize-foff) {
      /* We don't have the next cluster cached and we have not reached the last cluster
       * in the transfer so go straight to the disk.
       */
      size = clustersize-foff;
      tracef1("DOS_bytes_RW: transferring %d bytes to/from disk\n",size);
      if ((nextcluster = DOS_cluster_RW(op, nextcluster, foff, memaddr, size, ihand)) < 0)
      {
        result = -1;
        break;
      }
      foff = 0;
    } else {
      /* We have reached the last cluster in the transfer and it's not cached so we
       * try to cache it as it is likely that the next transfer will use it.
       */
      if (fhand->filebuff != NULL) {
        /* Don't cache the next cluster without flushing the cache first!! */
        if (fhand->modified != 0) {
          tracef1("DOS_bytes_RW: flushing cached cluster %d to disk\n",fhand->currentCLUSTER);
          if (DOS_cluster_RW(Wdata,fhand->currentCLUSTER,0,fhand->filebuff,clustersize,ihand) < 0)
          {
            result = -1;
            break;
          }
        }
      } else
        fhand->filebuff = (char *)malloc(clustersize);
      if (fhand->filebuff != NULL) {
        /* We have a cache so cache the next cluster but go round the loop to do the transfer. */
        tracef1("DOS_bytes_RW: caching cluster %d\n",nextcluster);
        fhand->currentCLUSTER = nextcluster;
        if (DOS_cluster_RW(Rdata, nextcluster, 0, fhand->filebuff, clustersize, ihand) < 0)
        {
          result = -1;
          break;
        }
        fhand->modified = 0;
        size = 0;
        --clustercount;         /* Don't count this cluster (transfer happens next time round). */
      } else {
        /* Didn't get a cache so we have to go straight to the disk. */
        size = bytes;
        tracef1("DOS_bytes_RW: no cache so transferring %d bytes to/from disk\n",size);
        if (DOS_cluster_RW(op, nextcluster, foff, memaddr, size, ihand) < 0)
        {
          result = -1;
          break;
        }
      }
    }
#endif
    if (!zero)
      memaddr += size;
    bytes -= size;
  }

  if (zero) free(memaddr);

  return result;
}

/*-------------------------------------------------------------------------*/

int DOSFS_get_bytes(FILEhand *fhand,char *ma,word bytes,word foff)
{
  return DOS_bytes_RW(Rdata, ma, bytes, foff, fhand);
}

/*-------------------------------------------------------------------------*/

int DOSFS_put_bytes(FILEhand *fhand,char *ma,word bytes,word foff,char dummy)
{
  return DOS_bytes_RW(Wdata, ma, bytes, foff, fhand);
  UNUSED(dummy) ;
}

/*-------------------------------------------------------------------------*/

#if 1 /* This call is not mentioned in JRoachs documents. However I have
       * been called through the entry point and so have included the code
       * here.
       */
int DOSFS_write_zeros(FILEhand *fhand,word foff,word bytes)
{
  return DOS_bytes_RW(Wzero, 0, bytes, foff, fhand);
}
#endif /* newcode */

/*-------------------------------------------------------------------------*/

int DOSFS_close_file(FILEhand *fhand,word loadaddr,word execaddr)
{
 /* in:
  *     fhand    : internal filesystem handle for this file
  *     loadaddr : new load address for the file
  *     execaddr : new exec address for the file
  */
 FILEhand *cptr = NULL ;
 FILEhand *last = NULL ;

 tracef3("\n\nDOSFS_close_file: fhand = &%08X, load = &%08X, exec = &%08X\n",(word)fhand,loadaddr,execaddr) ;

 /* NOTEs
  * -----
  * If this file was opened with a create operation (OPENOUT) then we should
  * set the closed length to that of the current file pointer. This may
  * involve releasing allocated CLUSTERs aswell as updating the directory
  * information.
  */

 /* Search for the file descriptor that we are going to remove */
 last = NULL ;
 for (cptr = FILE_list; (cptr != NULL); cptr = cptr->next)
  {
   tracef2("DOSFS_close_file: cptr &%08X ; last &%08X\n",(int)cptr,(int)last) ;
   if (cptr == fhand)
    {
     tracef2("DOSFS_close_file: handle found (filebuff = &%08X, modified = %d)\n",fhand->filebuff,fhand->modified) ;

     /* remove this structure from the list */
     tracef1("DOSFS_close_file: removing handle from active list (last = &%08X)\n",(int)last) ;
     if (last == NULL)
      FILE_list = fhand->next ;
     else
      last->next = fhand->next ;

     /* if file opened for writing then flush the buffer if modified */
     if (fhand->filebuff != NULL)
      {
       if (fhand->modified != 0)
        {
         tracef1("DOSFS_close_file: flushing cached cluster %d to disk\n",fhand->currentCLUSTER);
         DOS_cluster_RW(Wdata,fhand->currentCLUSTER,0,fhand->filebuff,(secsalloc(fhand->ihand) * DOSsecsize),fhand->ihand) ;
         fhand->modified = 0 ;
        }
       free(fhand->filebuff) ;
       fhand->filebuff = NULL ;
      }

     if (fhand->opentype != 0)
      {
       tracef2("DOSFS_close_file: index &%08X (length &%08X)\n",fhand->indexptr,fhand->filelen) ;

       /* update the directory information */
       if (fhand->fname != NULL) /* should never be NULL */
        {
         word bitmap = 0x00000000 ;
         _kernel_swi_regs  rset ;
         _kernel_oserror  *rerror ;

         tracef1("DOSFS_close_file: filename \"%s\"\n",fhand->fname) ;

         /* update the directory entry load and exec addresses */
         if ((loadaddr & ADFStimestamp) == ADFStimestamp)
          bitmap |= ((1 << wdi_LOAD) | (1 << wdi_EXEC)) ;

         /* (re)write the file length aswell */
         bitmap |= (1 << wdi_FLEN) ;

         /* and write the startCLUSTER (in-case this is was an empty file) */
         bitmap |= (1 << wdi_SCLUSTER) ;

         write_dirinfo(fhand->fname,bitmap,loadaddr,execaddr,NULL,fhand->filelen,fhand->startCLUSTER,fhand->ihand) ;

         /* Flush the output using OS_Args 255. */
         rset.r[0] = 255;
         rset.r[1] = (word)((fhand->ihand)->disc_fhand);
         if ((rerror = _kernel_swi(OS_Args, &rset, &rset)) != NULL) {
          tracef2("update_imageID: error from OS_Args 255: (&%08X) \"%s\"\n",rerror->errnum,rerror->errmess);
          return_errorX(int,rerror);
         }
        }
      }

     /* release the filename buffer if allocated */
     if (fhand->fname != NULL)
      {
       tracef1("DOSFS_close_file: releasing filename buffer at &%08X\n",(int)fhand->fname) ;
       free(fhand->fname) ;
       fhand->fname = NULL ; /* ensure accesses will fail */
      }

     /* Check that we have released all allocated, attached memory buffers */
     tracef1("DOSFS_close_file: releasing file handle structure &%08X\n",(int)fhand) ;
     free(fhand) ;
     return(0) ; /* return to the caller */
    }
   last = cptr ;
  }

 tracef0("DOSFS_close_file: file handle not recognised (generate error?)\n") ;
 return(0) ;
}

/*-------------------------------------------------------------------------*/

int DOSFS_write_extent(FILEhand *fhand,word fext)
{
 /* in: fhand : internal filesystem handle for this file
  *     fext  : new file extent
  *
  * Set the extent of a file (usually prior to it being closed).
  */

 /* modify the current file pointer for the given open file */
 tracef2("\n\nDOSFS_write_extent: fhand = &%08X, fext = &%08X\n",fhand,fext) ;

 /* We will fall straight through if the extent is identical to the current
  * file length.
  */
 if (fext > fhand->filelen)
  {
   word indexptr = fhand->indexptr ; /* preserve our position over ensure */
   if (DOSFS_write_zeros(fhand,fhand->filelen,(fext - fhand->filelen)) < 0)
    return((int)-1) ; /* error already defined */
   fhand->indexptr = indexptr ; /* restore file position */
  }
 else
  if (fext < fhand->filelen)
   {
    /* truncate the file to the desired length */
    if (DOSFS_ensure_exact(fhand,fext) < 0)
     return((int)-1) ; /* error already defined */
    fhand->indexptr = fext ; /* new file position */
   }

 tracef3("DOSFS_write_extent: fhand &%08X (len &%08X ptr &%08X)\n",(int)fhand,fhand->filelen,fhand->indexptr) ;
 /* out:
  *     no conditions
  */
 return(0) ;
}

/*-------------------------------------------------------------------------*/

word DOSFS_alloc(FILEhand *fhand)
{
 int CLUSTERsize ;

 /* in: fhand : internal filesystem handle for the file
  */

 tracef1("\n\nDOSFS_alloc: fhand = &%08X\n",fhand) ;

 CLUSTERsize = cluster_size(&(fhand->ihand->disc_boot)) ;

 /* return the disc space allocated to the file */
 /* out:
  *     return : space allocated to the file (rounded up the next allocation
  *              unit)
  */
 tracef3("DOSFS_alloc: fhand &%08X (len &%08X ptr &%08X)\n",(int)fhand,fhand->filelen,fhand->indexptr) ;
 return((fhand->filelen + (CLUSTERsize - 1)) & -CLUSTERsize) ;
}

/*-------------------------------------------------------------------------*/

FS_datestamp *DOSFS_flush(FILEhand *fhand)
{
 /* in: fhand : internal filesystem handle for the file
  *
  * Flush any buffered data to the media.
  */

 tracef1("\n\nDOSFS_flush: fhand = &%08X\n",fhand) ;

 /* flush the file buffer if modified */
 if ((fhand->filebuff != NULL) && (fhand->modified))
  {
   tracef0("DOSFS_flush: buffer needs to be written to the file\n") ;
   DOS_cluster_RW(Wdata,fhand->currentCLUSTER,0,fhand->filebuff,(secsalloc(fhand->ihand) * DOSsecsize),fhand->ihand) ;
   fhand->modified = 0 ; /* clear the modified flag */
  }

 /* The load/exec addresses returned are those currently in the directory
  * entry for the file.
  */
 tstamp.loadaddr = fhand->loadaddr ;
 tstamp.execaddr = fhand->execaddr ;

 tracef3("DOSFS_flush: fhand &%08X (len &%08X ptr &%08X)\n",(int)fhand,fhand->filelen,fhand->indexptr) ;
 /* out:
  *     tstamp.loadaddr = desired load address for the file
  *     tstamp.execaddr = desired exec address for the file
  */
 return(&tstamp) ;
}

/*-------------------------------------------------------------------------*/

word DOSFS_ensure(FILEhand *fhand,word ensure)
{
 /* in:
  *     fhand  : internal filesystem handle for the file
  *     ensure : size of file to ensure
  *
  * Ensure the file can be extended to at least the given size. The extra
  * space need NOT be zeroed.
  */

 tracef2("\n\nDOSFS_ensure: fhand = &%08X, ensure = &%08X\n",fhand,ensure) ;

 /* Set the file length to at least the desired value "ensure". */
 if (fhand->filelen < ensure) {
   if (DOSFS_ensure_exact(fhand, ensure) < 0)
     return -1;
 }

 tracef3("DOSFS_ensure: fhand &%08X (len &%08X ptr &%08X)\n",(int)fhand,fhand->filelen,fhand->indexptr) ;
 /* out:
  *     return : size of file actually ensured
  */
 return(fhand->filelen) ;
}

/*-------------------------------------------------------------------------*/

FS_datestamp *DOSFS_read_datestamp(FILEhand *fhand)
{
 /* in: fhand : internal filesystem handle for the file
  *
  * Return the current load and exec addresses for this file.
  */

 tracef1("\n\nDOSFS_read_datestamp: fhand = &%08X\n",fhand) ;

 /* The load/exec addresses returned are those currently in the directory
  * entry for the file.
  */
 tstamp.loadaddr = fhand->loadaddr ;
 tstamp.execaddr = fhand->execaddr ;

 tracef3("DOSFS_read_datestamp: fhand &%08X (len &%08X ptr &%08X)\n",(int)fhand,fhand->filelen,fhand->indexptr) ;
 /* out:
  *     tstamp.loadaddr = desired load address for the file
  *     tstamp.execaddr = desired exec address for the file
  */
 return(&tstamp) ;
}

/*-------------------------------------------------------------------------*/

char *DOSFS_save_file(char *fn,word ld,word ex,char *bs,char *end,DOSdisc *ih)
{
 DIR_info     *cdir ;     /* directory where the leafname resides */
 char         *DOSname ;  /* full DOS pathname */
 char         *leafname ; /* pointer to the leafname of "DOSname" */
 DOS_direntry *dentry ;   /* directory entry structure pointer */

 /* in:
  *     fn  : NULL terminated ASCII pathname, relative to ROOT of image
  *     ld  : new load address for the file
  *     ex  : new exec address for the file
  *     bs  : base address of data in memory
  *     end : end address of data in memory (plus one)
  *     ih  : filesystem image handle
  */

 tracef1("\n\nDOSFS_save_file: \"%s\"\n",fn) ;

 /* convert "fn" to DOS path format */
 if ((DOSname = (char *)malloc(MaxString)) == NULL)
  return_errorT(char *,err_heapexhausted,tok_heapexhausted,0,0) ;

 if ((int)convertRISCOStoDOS(fn, DOSname) < 0) {
  free(DOSname);
  return (char *)-1;
 }

 /* resolve the path (ie. load the directory the file is in) */
 if (resolvePATH(DOSname,&cdir,&leafname,ih) < 0)
  {
   free(DOSname) ;
   return((char *)-1) ; /* error already defined */
  }

 tracef2("DOSFS_save_file: cdir = &%08X, cdir->ihand = &%08X\n",(int)cdir,(int)(cdir->ihand)) ;

 set_dir_flags(cdir, dir_LOCKED);

 /* create the directory entry and save the file */
 if (saveFILE(fn,leafname,ld,ex,(char *)bs,(word)(end - bs),&cdir,&dentry,0,ih) < 0)
  {
   unset_dir_flags(cdir, dir_LOCKED);
   DOS_FAT_RW(Rdata, ih);
   free_dir_cache(DOSname, ih);
   free(DOSname) ;
   return((char *)-1) ; /* error already defined */
  }
 unset_dir_flags(cdir, dir_LOCKED);

 /* Do this before freeing DOSname. */
 sprintf(tline,"%s",leafname) ;

 free(DOSname) ; /* and the pathname buffer */

 /* out:
  *     Returns the leafname for any "*OPT 1 n" setting
  */
 return(tline) ;
}

/*-------------------------------------------------------------------------*/

int DOSFS_write_cat(char *fname,word ld,word ex,word attr,DOSdisc *ihand)
{
 int state ;

 /* in:
  *     fname : NULL terminated ASCII pathname, relative to ROOT of image
  *     ld    : new load address for the file
  *     ex    : new exec address for the file
  *     attr  : new attributes for the file
  *     ihand : filesystem image handle
  *
  * If the object does not exist, DO NOT return an error. If the object is
  * a directory, and the filesystem does NOT support directory attributes and
  * information, then return an error.
  */

 tracef1("\n\nDOSFS_write_cat: \"%s\"\n",fname) ;

 /* out:
  *     no conditions
  */
 state = write_dirinfo(fname,((1 << wdi_LOAD) | (1 << wdi_EXEC) | (1 << wdi_ATTR)),ld,ex,attr,NULL,NULL,ihand) ;
 if ((state == -1) && ((_syserr->errnum & err_mask) == err_objectnotfound))
  state = 0 ; /* ignore "file not found" error */

 return(state) ;
}

/*-------------------------------------------------------------------------*/

FS_cat_entry *DOSFS_read_cat(char *fname,DOSdisc *ihand)
{
 /* in:
  *     fname : NULL terminated ASCII pathname, relative to ROOT of image
  *     ihand : filesystem image handle
  */
 int           loop ;               /* general loop counter */
 char         *DOSname = NULL ;     /* converted pathname */
 char         *leafname = NULL ;    /* leafname of loaded directory */
 DIR_info     *cdir = NULL ;        /* pointer to the loaded directory */
 DOS_direntry *dentry ;             /* directory entry pointer */

 tracef1("\n\nDOSFS_read_cat: \"%s\"\n",((fname == NULL) ? "" : fname)) ;

 /* defaults */
 fcat.type = no_object ;
 fcat.loadaddr = 0x00000000 ;
 fcat.execaddr = 0x00000000 ;
 fcat.filelen  = 0x00000000 ;
 fcat.fileattr = 0x00000000 ;

 /* convert "fname" to DOS path format */
 if ((DOSname = (char *)malloc(MaxString)) == NULL)
  {
   return_errorT(FS_cat_entry *,err_heapexhausted,tok_heapexhausted,0,0) ;
  }

 if ((int)convertRISCOStoDOS(fname, DOSname) < 0) {
  free(DOSname);
  return &fcat;    /* Just return file not found. */
 }

 /* load the desired directory (also returns the leafname) */
 if (resolvePATH(DOSname,&cdir,&leafname,ihand) >= 0) {

   /* search the directory */
   loop = 0 ;
   if ((dentry = findDIRentry(leafname,&(cdir->dir_entries[0]),cdir->dir_size,&loop)) != NULL)
    {
     time5byte le ;
     word      dosext = 0x00000000 ;

     tracef0("DOSFS_read_cat: file found\n") ;

     if (buildFILEname(dentry,DOSname) != NULL)
      (void)after((char *)&dosext,DOSname,file_sep,1) ;

     read_loadexec(dentry,dosext,&le) ; /* get the load/exec information */

     fcat.type = (((dentry->FILE_attribute & FILE_subdir) == 0) ? object_file : object_dir) ;

     /* construct suitable RISC OS fields */
     fcat.loadaddr = le.hi ;
     fcat.execaddr = le.lo ;
     fcat.filelen  = dentry->FILE_size ;
     fcat.fileattr = DOStoRISCOSattributes(dentry) ;
    }

 }

 free(DOSname) ;

 /* out:
  *     fcat.type     = object type (0 = not found; 1 = file; 2 = directory)
  *     fcat.loadaddr = load address
  *     fcat.execaddr = exec address
  *     fcat.filelen  = length in bytes
  *     fcat.fileattr = attributes
  */
 return(&fcat) ;
}

/*-------------------------------------------------------------------------*/

FS_cat_entry *DOSFS_delete(char *fname,DOSdisc *ihand)
{
 DIR_info     *cdir ;     /* directory where the leafname resides */
 char         *DOSname ;  /* full DOS pathname */
 char         *leafname ; /* pointer to the leafname of "DOSname" */
 DOS_direntry *dentry ;   /* directory entry structure pointer */
 int           loop ;     /* general index counter */
 int           value = 0;    /* general work variable */

 /* in:
  *     fname : NULL terminated ASCII pathname, relative to ROOT of image
  *     ihand : filesystem image handle
  *
  * Delete the object. Do not generate an error if the file does NOT exist.
  */

 tracef1("\n\nDOSFS_delete: \"%s\"\n",fname) ;

 /* convert "fname" to DOS path format */
 if ((DOSname = (char *)malloc(MaxString)) == NULL)
  return_errorT(FS_cat_entry *,err_heapexhausted,tok_heapexhausted,0,0) ;

 if ((int)convertRISCOStoDOS(fname, DOSname) < 0) {
  free(DOSname);
  return (FS_cat_entry *)-1;
 }

 /* resolve the path (ie. load the directory the file is in) */
 if (resolvePATH(DOSname,&cdir,&leafname,ihand) < 0)
  {
   free(DOSname) ;
   return((FS_cat_entry *)-1) ; /* error already defined */
  }

 /* delete the directory entry */
 tracef1("DOSFS_delete: leafname = \"%s\"\n",leafname) ;

 /* search the directory (we do not complain if the file is not found) */
 loop = 0 ;
 if ((dentry = findDIRentry(leafname,&(cdir->dir_entries[0]),cdir->dir_size,&loop)) != NULL)
  {
   time5byte le ;
   word      dosext = 0x00000000 ;

   tracef0("DOSFS_delete: file found\n") ;

   /* Make sure that the file is not open. */
   if (find_open_file(fname, dentry, ihand) >= 0) {
    free(DOSname);
    return_error1(FS_cat_entry *, err_fileopen, fname);
   }

   if ((dentry->FILE_attribute & FILE_readonly) != 0) {
    free(DOSname);
    return_error1(FS_cat_entry *, err_filelocked, fname);
   }

   if ((dentry->FILE_attribute & FILE_subdir) != 0)
    {
     /* check that the directory is empty */
     DIR_info *subdir ;
     char     *subleafname ;

     tracef0("DOSFS_delete: attempt to delete directory\n") ;
     tracef1("DOSFS_delete: DOSname  = \"%s\"\n",DOSname) ;
     tracef1("DOSFS_delete: leafname = \"%s\"\n",leafname) ;

     /* At the moment "resolvePATH" has special code to deal with the
      * single entry in ROOT. We need to simulate that here.
      */
     /* We want to load the directory that is currently our leafname */
     {
      char *s = leafname, *d = DOSname + strlen(DOSname);
      if (d != DOSname)
       *d++ = '\\';
      do {
       *d++ = *s;
      } while (*s++ != '\0');
     }
     strcat(DOSname, "\\*.*");

     tracef1("DOSFS_delete: DOSname  = \"%s\"\n",DOSname) ;

     set_dir_flags(cdir, dir_LOCKED);
     /* load the desired directory, returning the leafname "*.*" */
     if (resolvePATH(DOSname,&subdir,&subleafname,ihand) < 0)
      {
       unset_dir_flags(cdir, dir_LOCKED);
       free(DOSname) ;
       return((FS_cat_entry *)-1) ; /* error already defined */
      }
     unset_dir_flags(cdir, dir_LOCKED);

     loop = 0 ;
     tracef1("DOSFS_delete: subleafname = \"%s\"\n",subleafname) ;
     if (findDIRentry(subleafname,&(subdir->dir_entries[0]),subdir->dir_size,&loop) != NULL)
      {
       tracef0("DOSFS_delete: attempt to delete non-empty directory\n") ;
       free(DOSname) ;
       return_error1(FS_cat_entry *,err_notempty,fname) ;
      }

     /* Remove this directory and any of its children from the directory cache. */
     free_dir_cache(DOSname, ihand);
    }

   /* We have found the file directory entry, so remove the directory entry
    * and then release the cluster chain associated with the object.
    * RISC OS expects a description of the object deleted to be returned.
    */
   (void)buildFILEname(dentry,DOSname) ;
   (void)after((char *)&dosext,DOSname,file_sep,1) ;

   /* construct return information */
   MSDOStoRISCOS(get_FILE_time(dentry),get_FILE_date(dentry),&le) ;

   value = get_FILE_ROStype(dentry) ;
   if (value != 0)
    le.hi = (le.hi & ~ADFStypemask) | (value << 8) ;
   else
    {
     mapentry *cmap ;
     for (cmap = maplist; (cmap); cmap = cmap->next)
      if (cmap->dosext == dosext)
       {
        le.hi = (le.hi & ~ADFStypemask) | (cmap->ROtype << 8) ;
        break ;
       }
    }

   {
     byte status = dentry->FILE_status;
     dentry->FILE_status = FILE_deleted;
     set_dir_flags(cdir, dir_MODIFIED);
     if ((value = ensure_directory(cdir)) == 0) {
       freeclusters(get_FILE_cluster(dentry), ihand);
       if ((value = ensure_FATs(ihand)) == 0) {
         /* construct the return information */
         fcat.type     = (((dentry->FILE_attribute & FILE_subdir) == 0) ? object_file : object_dir) ;
         fcat.loadaddr = le.hi ;
         fcat.execaddr = le.lo ;
         fcat.filelen  = dentry->FILE_size ;
         fcat.fileattr = DOStoRISCOSattributes(dentry) ;
       }
     } else {
       /* If the directory ensure (write) fails eg. because disc is write-protected then
        * we don't free the clusters and don't delete the file.
        */
       flush_dir_cache(ihand);
       dentry->FILE_status = status;
       unset_dir_flags(cdir, dir_MODIFIED);
     }
   }
  }

 free(DOSname) ;

 tracef0("DOSFS_delete: completed OK\n") ;
 /* out:
  *     fcat.type     = object type (0 = not found; 1 = file; 2 = directory)
  *     fcat.loadaddr = load address
  *     fcat.execaddr = exec address
  *     fcat.filelen  = length in bytes
  *     fcat.fileattr = attributes
  */
 if (value)
  return((FS_cat_entry *)-1);
 return(&fcat) ;
}

/*-------------------------------------------------------------------------*/

int DOSFS_create(char *fname,word ld,word ex,char *base,char *end,DOSdisc *ihand)
{
 DIR_info     *cdir ;     /* directory where the leafname resides */
 char         *DOSname ;  /* full DOS pathname */
 char         *leafname ; /* pointer to the leafname of "DOSname" */
 DOS_direntry *dentry ;   /* directory entry structure pointer */
 word          length = ((word)end - (word)base) ;

 /* in:
  *     fname  : NULL terminated ASCII pathname, relative to ROOT of image
  *     ld     : load address to give new file
  *     ex     : exec address to give new file
  *     base   : base address in memory
  *     end    : end address in memory (used with "base" to derive length)
  *     ihand  : filesystem image handle
  *
  * If a file of the specified name already exists, then delete it. An error
  * should be returned if the file cannot be deleted. The new file should
  * have the same attributes as the old file if one existed, otherwise a
  * suitable default value.
  */

 tracef2("\n\nDOSFS_create: base &%08X, end &%08X\n",(word)base,(word)end) ;
 tracef4("DOSFS_create: \"%s\" length &%08X (ld: &%08X ex: &%08X)\n",fname,length,ld,ex) ;

 /* convert "fname" to DOS path format */
 if ((DOSname = (char *)malloc(MaxString)) == NULL)
  return_errorT(int,err_heapexhausted,tok_heapexhausted,0,0) ;

 if ((int)convertRISCOStoDOS(fname, DOSname) < 0) {
  free(DOSname);
  return -1;
 }

 /* resolve the path (ie. load the directory the file is in) */
 if (resolvePATH(DOSname,&cdir,&leafname,ihand) < 0)
  {
   free(DOSname) ;
   return(-1) ; /* error already defined */
  }

 tracef2("DOSFS_create: cdir = &%08X, cdir->ihand = &%08X\n",(int)cdir,(int)(cdir->ihand)) ;

 set_dir_flags(cdir, dir_LOCKED);

 /* create the directory entry (using the "saveFILE" primitive) */
 if (saveFILE(fname,leafname,ld,ex,NULL,length,&cdir,&dentry,1,ihand) < 0)
  {
   unset_dir_flags(cdir, dir_LOCKED);
   DOS_FAT_RW(Rdata, ihand);
   free_dir_cache(DOSname, ihand);
   free(DOSname) ;
   return(-1) ; /* error already defined */
  }
 unset_dir_flags(cdir, dir_LOCKED);

 free(DOSname) ; /* and the pathname buffer */

 /* out:
  *     no conditions
  */
 return(NULL) ;
}

/*-------------------------------------------------------------------------*/

int DOSFS_create_dir(char *fname,word ld,word ex,word size,DOSdisc *ihand)
{
 DIR_info     *cdir ;              /* directory where the leafname resides */
 char         *DOSname ;           /* full DOS pathname */
 char         *leafname ;          /* pointer to the leafname of "DOSname" */
 DOS_direntry *dentry ;            /* directory entry structure pointer */
 DIR_info     *pdir = NULL ;       /* parent directory (if required) */
 char         *memaddr ;           /* memory buffer for new directory image */
 int           CLUSTERsize ;       /* size of a CLUSTER in bytes */
 int           CLUSTERs_required ; /* number of CLUSTERs required for dir */
 int           loop ;              /* general index counter */
 int           startCLUSTER ;      /* CLUSTER where the directory starts */
 time5byte     saveTIME ;          /* time the directory was created */
#if 0 /* JRS 6/3/92 removed this as RISC OS directories are not typed */
 int           cROStype = ((ld & ADFStypemask) >> ADFStypeshift) ;
#endif
 int           ROOTcluster ;       /* CLUSTER for the ROOT of the filesystem */

 /* in:
  *     fname : NULL terminated ASCII pathname, relative to ROOT of image
  *     ld    : load address to give directory
  *     ex    : exec address to give directory
  *     size  : number of directory entries required
  *     ihand : filesystem image handle
  *
  * If the directory already exists, then try renaming it (the case of certain
  * letters in the name may have changed). Do not return an error if the
  * rename fails.
  */

 tracef1("\n\nDOSFS_create_dir: \"%s\"\n",fname) ;

 /* convert "fname" to DOS path format */
 if ((DOSname = (char *)malloc(MaxString)) == NULL)
  return_errorT(int,err_heapexhausted,tok_heapexhausted,0,0) ;

 if ((int)convertRISCOStoDOS(fname, DOSname) < 0) {
  free(DOSname);
  return -1;
 }

 /* resolve the path (ie. load the directory the file is in) */
 if (resolvePATH(DOSname,&cdir,&leafname,ihand) < 0)
  {
   free(DOSname) ;
   return(-1) ; /* error already defined */
  }

 /* create the directory entry */
 tracef2("DOSFS_create_dir: \"%s\" in dir &%08X\n",leafname,(word)cdir) ;

 /* directories are initially given 1 cluster (is this the same as MS-DOS?) */
 CLUSTERsize = cluster_size(&(ihand->disc_boot)) ;
 CLUSTERs_required = 1 ;

 /* If "cdir->dir_root == -1" then the parent DIR is the ROOT directory.
  * The ROOT directory does not live in the normal disc data area (i.e. cluster
  * area). This means that it cannot be allocated a CLUSTER number. It also
  * means that the ROOT directory CANNOT be extended.
  */
 if (cdir->dir_root == -1)
  ROOTcluster = 0 ; /* ROOT directory has CLUSTER 0 (for convenience) */
 else
  ROOTcluster = SECTORtoCLUSTER(cdir->dir_sector,ihand) ;

 tracef1("DOSFS_create_dir: parent directory type = %d\n",cdir->dir_root) ;
 tracef1("DOSFS_create_dir: parent directory sector = %d\n",cdir->dir_sector) ;
 tracef1("DOSFS_create_dir: CLUSTERsize = &%08X\n",CLUSTERsize) ;
 tracef1("DOSFS_create_dir: parent directory cluster = &%03X\n",ROOTcluster) ;

 /* allocate memory buffer for the new directory */
 if ((memaddr = (char *)malloc(CLUSTERs_required * CLUSTERsize)) == NULL)
  {
   free(DOSname) ;
   return_errorT(int,err_heapexhausted,tok_heapexhausted,0,0) ;
  }

 /* check to see if the directory already exists */
 loop = 0 ;
 if ((dentry = findDIRentry(leafname,&(cdir->dir_entries[0]),cdir->dir_size,&loop)) != NULL)
  {
   /* object already exists */
   free(DOSname) ;
   free(memaddr) ;
   if ((dentry->FILE_status != FILE_directory) && ((dentry->FILE_attribute & FILE_subdir) == 0))
    {
     /* object already exists as a file */
     return_errorT(int,err_badtypes,"TypsBad",NULL,NULL) ;
    }
   /* object exists as a directory, do not generate an error */
   /* Since MS-DOS is only upper-case we don't need to worry about preserving
    * the case of the name given on entry.
    */
   return(0) ;
  }

 tracef0("DOSFS_create_dir: does NOT already exist\n") ;

 /* find a suitable free directory entry */
 if ((dentry = findemptyDIRentry(&(cdir->dir_entries[0]),cdir->dir_size)) == NULL)
  {
   set_dir_flags(cdir, dir_LOCKED);
   if (extend_dir(&cdir,&dentry,ihand,&pdir) < 0)
    {
     unset_dir_flags(cdir, dir_LOCKED);
     DOS_FAT_RW(Rdata, ihand);
     flush_dir_cache(ihand);
     free(DOSname) ;
     free(memaddr) ;
     return(-1) ; /* error already defined */
    }
   unset_dir_flags(cdir, dir_LOCKED);
   tracef0("DOSFS_create_dir: directory extended successfully\n") ;
  }

 /* "dentry" = pointer to the directory entry to create */

 if ((startCLUSTER = claimfreeclusters(CLUSTERs_required, ihand)) < 0) {
   free(DOSname);
   free(memaddr);
   return -1;
 }

 /* write the information into the directory entry
  *
  * This requires the filename to be split into name and extension fields
  * We fill the name with SPACEs first (the string terminator (NULL) is
  * placed in the attributes field)
  *
  * NOTE: these should be done in this order due to the fact that the
  *       text building function terminates each string with a NUL
  */
 sprintf((char *)&(dentry->FILE_status),"           ") ;
 before((char *)&(dentry->FILE_status),leafname,file_sep,1) ;
 after((char *)&(dentry->FILE_extension),leafname,file_sep,1) ;
 /* mark the object as a directory */
 dentry->FILE_attribute = FILE_subdir; /* JRS removed (| FILE_archive) here 6/3/92 */
 bzero((char *)&(dentry->FILE_reserved),spare1) ; /* ZERO "spare1" bytes */
 /* use the passed load/exec addresses */
 saveTIME.lo = ex ;
 saveTIME.hi = (ld & 0xFF) ;
 put_FILE_time(dentry,RISCOStoTIME(&saveTIME)) ;
 put_FILE_date(dentry,RISCOStoDATE(&saveTIME)) ;

#if 0 /* JRS 6/3/92 removed this as (1) RISC OS directories are not typed, and 2) it upsets norton DE */
 if (cROStype == DOStype)
  {
   erase_ROStype(dentry) ; /* remove any possible RISC OS file-type */
  }
 else
  {
   put_FILE_ROStype(dentry,cROStype) ; /* place in the specified value */
  }
#endif

 put_FILE_cluster(dentry,startCLUSTER) ;

 dentry->FILE_size = 0; /* JRS 6/3/92 DOS directories have size set to 0. Removed: (CLUSTERs_required * CLUSTERsize) ;*/
 tracef1("DOSFS_create_dir: dir size written = &%08X\n",dentry->FILE_size) ;

 set_dir_flags(cdir, dir_MODIFIED) ; /* directory has been updated */

 /* construct a default directory */
 {
  DOS_direntry *direntries ;

  for (loop=0; (loop < (CLUSTERs_required * CLUSTERsize)); loop++)
   memaddr[loop] = NULL ;

  /* make "." */
  direntries = (DOS_direntry *)&(memaddr[0 * sizeof(DOS_direntry)]) ;
  sprintf((char *)&(direntries->FILE_status),".          ") ;
  direntries->FILE_attribute = FILE_subdir ;
  bzero((char *)&(direntries->FILE_reserved),spare1) ; /* ZERO spare1 bytes */
  put_FILE_time(direntries,RISCOStoTIME(&saveTIME)) ;
  put_FILE_date(direntries,RISCOStoDATE(&saveTIME)) ;
  put_FILE_cluster(direntries,startCLUSTER) ;
  direntries->FILE_size = 0x00000000 ;      /* special directory */

  /* make ".." */
  direntries = (DOS_direntry *)&(memaddr[1 * sizeof(DOS_direntry)]) ;
  sprintf((char *)&(direntries->FILE_status),"..         ") ;
  direntries->FILE_attribute = FILE_subdir ;
  bzero((char *)&(direntries->FILE_reserved),spare1) ; /* ZERO spare1 bytes */
  put_FILE_time(direntries,RISCOStoTIME(&saveTIME)) ;
  put_FILE_date(direntries,RISCOStoDATE(&saveTIME)) ;
  put_FILE_cluster(direntries,ROOTcluster) ;
  direntries->FILE_size = 0x00000000 ;      /* special directory */
 }

 /* copy the data from memory into the allocated clusters */
 /* use "saveOBJECT" to perform this */
 if (DOS_object_RW(Wdata,startCLUSTER,memaddr,(CLUSTERs_required * CLUSTERsize),ihand) != 0)
  {
   DOS_FAT_RW(Rdata, ihand);
   flush_dir_cache(ihand);
   free(DOSname) ;
   free(memaddr) ;
   return -1;
  }

 free(DOSname) ;
 free(memaddr) ;

 if (pdir != NULL) {
  if (ensure_directory(pdir) != 0) {
   return -1;
  }
 }

 if ((ensure_directory(cdir) != 0) || (ensure_FATs(ihand) != 0))
  {
   return(-1) ; /* error already defined */
  }

 /* out:
  *     no conditions
  */
 return(0) ;
 UNUSED(size) ;
}

/*-------------------------------------------------------------------------*/

word DOSFS_read_block_size(char *fname,DOSdisc *ihand)
{
 int CLUSTERsize = cluster_size(&(ihand->disc_boot)) ;
 tracef2("DOSFS_read_block_size: \"%s\"; ihand = &%08X\n",fname,(word)ihand) ;
 return(CLUSTERsize) ;
 UNUSED(fname) ;
}

/*-------------------------------------------------------------------------*/

word DOSFS_rename(char *oldname,char *newname,DOSdisc *ihand)
{
 DIR_info     *cdir ;     /* directory where the original leafname resides */
 DIR_info     *ndir ;     /* directory where the new leafname resides */
 char         *DOSname ;  /* full DOS pathname */
 char         *leafname ; /* pointer to the leafname of "DOSname" */
 DOS_direntry *dentry ;   /* directory entry structure pointer */
 DOS_direntry *found ;    /* directory entry structure pointer */
 int           loop ;     /* general index counter */

 /* in:
  *     oldname : NULL terminated ASCII pathname, relative to ROOT of image
  *     newname : NULL terminated ASCII pathname, relative to ROOT of image
  *     ihand   : filesystem image handle
  *
  * The rename should fail only if the objects are on different image files
  * (Which should not happen with this system).
  */

 tracef2("\n\nDOSFS_rename: \"%s\" --> \"%s\"\n",oldname,newname) ;

 /* convert "oldname" to DOS path format */
 if ((DOSname = (char *)malloc(MaxString)) == NULL)
  return_errorT(int,err_heapexhausted,tok_heapexhausted,0,0) ;
 if ((int)convertRISCOStoDOS(oldname, DOSname) < 0) {
  free(DOSname);
  return (word)-1;
 }
 /* resolve the path (ie. load the directory the file is in) */
 if (resolvePATH(DOSname,&cdir,&leafname,ihand) < 0)
  {
   free(DOSname) ;
   return(-1) ; /* error already defined */
  }

 tracef1("DOSFS_rename: original leafname = \"%s\"\n",leafname) ;
 /* search the directory for the original entry */
 loop = 0 ;
 if ((dentry = findDIRentry(leafname,&(cdir->dir_entries[0]),cdir->dir_size,&loop)) == NULL)
  {
   free(DOSname) ;
   return_errorT(word,err_objectnotfound,tok_objectnotfound,oldname,0) ;
  }
 found = dentry ; /* pointer to "oldname" in directory */


 /* check that no wildcard characters exist in the original leafname */
 if (checknotwildcarded(leafname, DOSwcmult, DOSwcsing) != 0)
  {
   free(DOSname) ;
   return_error1(word,err_wildcardedname,oldname) ;
  }

  /* If the object to be renamed is a directory then we must ensure that there is
   * no copy of it in the cache so that DOSFS doesn't think that it still exists.
   */
 if (found->FILE_attribute & FILE_subdir) {
   /* Reconstruct the full pathname of the directory being renamed. */
   tracef1("DOSFS_rename: removing \"%s\" from the directory cache\n",leafname);
   free_dir_cache(restorePATH(DOSname,leafname), ihand);
 } else {
  /* Its a file, so check if it's open. */
  if (find_open_file(oldname, found, ihand) >= 0) {
   free(DOSname);
   return_error1(int, err_fileopen, oldname);
  }
 }

 if ((int)convertRISCOStoDOS(newname, DOSname) < 0) {
  free(DOSname);
  return (word)-1;
 }

 set_dir_flags(cdir, dir_LOCKED);

 /* resolve the path (ie. load the directory the file is in) */
 if (resolvePATH(DOSname,&ndir,&leafname,ihand) < 0)
  {
   unset_dir_flags(cdir, dir_LOCKED);
   free(DOSname) ;
   return(-1) ; /* error already defined */
  }
 unset_dir_flags(cdir, dir_LOCKED);

 tracef1("DOSFS_rename: new leafname = \"%s\"\n",leafname) ;
 if (checknotwildcarded(leafname, DOSwcmult, DOSwcsing) != 0)
  {
   free(DOSname) ;
   return_error1(word,err_wildcardedname,newname) ;
  }

 /* check to see if we already have a file with the destination name */
 loop = 0 ;
 if ((dentry = findDIRentry(leafname,&(ndir->dir_entries[0]),ndir->dir_size,&loop)) != NULL)
  {
   /* new name already exists in the destination directory */
   free(DOSname) ;
   return_error0(word,err_alreadyexists) ;
  }

 /* check if same or different directories */
 if ((cdir->dir_root!=ndir->dir_root) || (cdir->dir_sector!=ndir->dir_sector))
  {
   /* different directories : copy information between directories */
   int cattr = found->FILE_attribute ;

   /* found = original name entry */
   found->FILE_status = FILE_deleted ;

   if ((dentry = findemptyDIRentry(&(ndir->dir_entries[0]),ndir->dir_size)) == NULL)
    {
#if 0
     free(DOSname) ;
     return_error0(word,err_dirfull) ;
#else  /* JRS 26/3/92 change to extend directory if full */
     DIR_info     *pdir = NULL ;       /* parent directory (not required) */
     set_dir_flags(ndir, dir_LOCKED); /* lock the current directory entry in the cache so it isn't flushed by the extend */
     if (extend_dir(&ndir,&dentry,ihand,&pdir) < 0)
       {
       unset_dir_flags(ndir, dir_LOCKED);
       DOS_FAT_RW(Rdata, ihand); /* error forces re-read of FAT to ensure we are in step with the disc */
       flush_dir_cache(ihand);   /* flush the directory cache to undo any local changes */
       free(DOSname) ;
       return(-1) ; /* error already defined */
       }
     unset_dir_flags(ndir, dir_LOCKED);
     if (ensure_FATs(ihand) != 0) /* the FAT has been modified by extending the directory. Ensure it is written to the disc */
       return(-1) ; /* error already defined */
#endif
    }

   /* place filename and attributes */
   sprintf((char *)&(dentry->FILE_status),"           ") ;
   before((char *)&(dentry->FILE_status),leafname,file_sep,1) ;
   after((char *)&(dentry->FILE_extension),leafname,file_sep,1) ;
   /* copy spare bytes (either JGS info or DRDOS5.0 info) */
   for (loop = 0; (loop < spare1); loop++)
    dentry->FILE_reserved[loop] = found->FILE_reserved[loop] ;
   /* copy file description */
   dentry->FILE_attribute = cattr ;
   dentry->FILE_time = found->FILE_time ;
   dentry->FILE_timeHI = found->FILE_timeHI ;
   dentry->FILE_date = found->FILE_date ;
   dentry->FILE_dateHI = found->FILE_dateHI ;
   dentry->FILE_cluster = found->FILE_cluster ;
   dentry->FILE_clusterHI = found->FILE_clusterHI ;
   dentry->FILE_size = found->FILE_size ;
   set_dir_flags(ndir, dir_MODIFIED) ; /* new directory updated */
  }
 else
  {
   /* same directory : replace the characters in the directory entry */
   /* This is necessary due to sprintf NULL terminating strings */
   int cattr = found->FILE_attribute ;
   sprintf((char *)&(found->FILE_status),"           ") ;
   before((char *)&(found->FILE_status),leafname,file_sep,1) ;
   after((char *)&(found->FILE_extension),leafname,file_sep,1) ;
   found->FILE_attribute = cattr ;
  }
 set_dir_flags(cdir, dir_MODIFIED) ; /* directory updated */

 if ((ensure_directory(cdir) != 0) || (ensure_directory(ndir) != 0))
  {
   flush_dir_cache(ihand);
   free(DOSname) ;
   return(-1) ; /* error already defined */
  }

 free(DOSname) ;
 /* out:
  *     return  : rename status
  */
 return(0) ;
}

/*-------------------------------------------------------------------------*/

FS_dir_block *DOSFS_read_dir(char *fname,word dest,word num,word off,word blen,DOSdisc *ihand)
{
 /* in:
  *     fname : NULL terminated ASCII pathname, relative to ROOT of image
  *     dest  : destination memory address for data
  *     num   : number of objects to read
  *     off   : offset into directory
  *     blen  : "dest" buffer length
  *     ihand : filesystem image handle
  */

tracef5("\n\nDOSFS_read_dir: \"%s\" (dest = &%08X) %d %d %d\n",((fname == "") ? "NULLptr" : fname),dest,num,off,blen) ;

 /* out:
  *     dblock.objects_read = number of records read
  *     dblock.next_offset  = offset of next item to be read (-1 if end)
  */
 return(read_dir(0,fname,dest,num,off,blen,ihand)) ;
}

/*-------------------------------------------------------------------------*/

FS_dir_block *DOSFS_read_dir_info(char *fname,word dest,word num,word off,word blen,DOSdisc *ihand)
{
 /* in:
  *     fname : NULL terminated ASCII pathname, relative to ROOT of image
  *     dest  : destination memory address for data
  *     num   : number of objects to read
  *     off   : offset into directory
  *     blen  : "dest" buffer length
  *     ihand : filesystem image handle
  */
 tracef5("\n\nDOSFS_read_dir_info: \"%s\" (dest = &%08X) %d %d %d\n",((fname == "") ? "NULLptr" : fname),dest,num,off,blen) ;

 /* out:
  *     dblock.objects_read = number of records read
  *     dblock.next_offset  = offset of next item to be read (-1 if end)
  */
 return(read_dir(-1,fname,dest,num,off,blen,ihand)) ;
}

/*-------------------------------------------------------------------------*/

int DOSFS_defect_list(char *fname,word buffer,word blen,DOSdisc *ihand)
{
 int             limit ;                         /* end of list */
 int             index;

 tracef3("DOSFS_defect_list: buffer &%08X (blen &%08X) ihand &%08X\n",buffer,blen,(int)ihand) ;

 /* Fill the supplied buffer with the byte offsets of the defects
  * within the image. The list should be terminated with 0x20000000.
  * It is an error for the specified filename to not be a ROOT object.
  *
  * We should search the FAT for CLUSTER_bad values that are NOT part
  * of a file chain. The offset we return is true byte offset within
  * the image, ie. we count previous bad CLUSTERs as data.
  */

 /* At the moment I ignore the "fname" given. */

 /* Scan the FAT returning information about BAD CLUSTERs */
 /* We must not overflow the buffer... should we return an error instead? */
 limit = (blen / sizeof(int)) - 1 ;

 index = CLUSTER_first(ihand);
 do {
   int secs;
   word addr;
   int cluster = findCLUSTERtype(ihand, &index, CLUSTER_bad(ihand));
   if (cluster < 0)
     break;
   secs = secsalloc(ihand);
   addr = ((cluster - CLUSTER_first(ihand)) * secs + ihand->disc_startsec - 1) *
          DOSsecsize + ihand->disc_winioffset;
   if ((limit -= secs) < 0)
     secs += limit;
   while (secs--) {
     *((word *)buffer) = addr;
     tracef1("DOSFS_defect_list: found &%08X\n", addr);
     addr += DOSsecsize;
     buffer += sizeof(int) ;
   }
   index++;
 } while (limit > 0);

 /* We left enough room (in the calculation above) for the terminator */
 /* NOTE: At the moment we do not generate an error if there are more
  *       BAD CLUSTERs than will fit into the passed buffer.
  */
 *((word *)buffer) = 0x20000000 ; /* terminate the list */
 return(0) ;
 UNUSED(fname) ;
}

/*-------------------------------------------------------------------------*/

int DOSFS_add_defect(char *fname,word offset,DOSdisc *ihand)
{
 int CLUSTER ;
 int nextCLUSTER ;

 tracef2("DOSFS_add_defect: \"%s\" &%08X\n",fname,offset) ;

 /* It is an error for the specified filename to not be a ROOT object
  * an error should be returned if the defect cannot be mapped out.
  *
  * if the CLUSTER is part of a file chain then we cannot map it out
  * if it is CLUSTER_bad then it is already mapped out
  * if it is >= CLUSTER_resvd then we cannot map it out
  *
  * it can only be mapped out if it is CLUSTER_unused
  *
  * All we do to map the CLUSTER out is update the FAT. The FAT will then
  * be un-usable by DOS filing systems.
  */

 /* Convert byte "offset" to CLUSTER address */
 CLUSTER = ((offset - ihand->disc_winioffset) / DOSsecsize - ihand->disc_startsec + 1) /
           secsalloc(ihand) + CLUSTER_first(ihand);

 /* Load the FAT entry at the given CLUSTER */
 nextCLUSTER = getnextCLUSTER(CLUSTER,ihand) ;
 if (nextCLUSTER < CLUSTER_first(ihand)) /* JRS 9/3/92 ensure within FAT */
   return_error0(int,err_clusterchain) ;
 /* If it is CLUSTER_bad then it is already mapped out */
 if (nextCLUSTER != CLUSTER_bad(ihand))
  {
   /* Otherwise check if the CLUSTER is being used */
   if (nextCLUSTER == CLUSTER_unused(ihand))
    {
     writenextCLUSTER(CLUSTER,CLUSTER_bad(ihand),ihand) ;
     if (ensure_FATs(ihand) < 0)
      return((int)-1) ; /* error already defined */
     (ihand->disc_freeclusters)--;
    }
   else
    return_error0(int,err_clusterinuse) ;
  }

 return(0) ;
 UNUSED(fname);
}

/*-------------------------------------------------------------------------*/

word DOSFS_read_boot_option(char *fname,DOSdisc *ihand)
{
 tracef1("DOSFS_read_boot_option: \"%s\" always returning 0\n",fname) ;
 return(0) ;
 UNUSED(fname) ;
 UNUSED(ihand) ;
}

/*-------------------------------------------------------------------------*/

int DOSFS_write_boot_option(char *fname,word newoption,DOSdisc *ihand)
{
 tracef2("DOSFS_write_boot_option: \"%s\" &%02X\n",fname,newoption) ;
 return_error0(int,err_nobootoption) ;
 UNUSED(fname) ;
 UNUSED(newoption) ;
 UNUSED(ihand) ;
}

/*-------------------------------------------------------------------------*/

int DOSFS_used_space_map(char *buffer,word blen,DOSdisc *ihand)
{
 int          loop;
 fFAT_sector *dFAT = &(ihand->disc_FAT);
 word         dval;
 word         mask;
 int         *bufp = (int *)((int)buffer & 0xFFFFFFFC);    /* Points to aligned buffer word. */
 int          offset = ((int)buffer & 0x3) << 3;           /* Initial offset into aligned buffer word. */
 int          secalloc = secsalloc(ihand);

 tracef3("DOSFS_used_space_map: buffer &%08X (blen &%08X) ihand &%08X\n",(word)buffer,blen,(word)ihand) ;

 /* Set all bits and the zero those which correspond to unused sectors.
  * This ensures that things like the FATs and the root directory are copied.
  */
 for (loop = 0; (loop < blen); loop++)
  *buffer++ = 0xFF;
 /* buffer now points to the first byte past the end. */

 /* Create a mask with as many bits set as there are sectors in a cluster. */
 mask = (1 << secalloc) - 1;

 /* Point to the word which contains the 1st bit corresponding to the 1st cluster. */
 offset += ihand->disc_startsec - 1; /* JRS 22/4/92 added -1 since startsec is 1-based, though 0-based is expected for buffer */
 bufp += offset >> 5;
 offset &= 0x1F;

 /* Set bits word by word. */
 dval = *bufp;
 for (loop = CLUSTER_first(ihand); loop < ihand->disc_FATentries; loop++) {
  word bitaddress = (ihand->disc_FATentry * loop) ;
  word byteaddress = ((bitaddress >> 3) + (word)dFAT) ;
  word shift = (bitaddress & 0x00000007) ;
  word datavalue = loadWORD((char *)byteaddress) ;
  int  cluster = (int)((datavalue >> shift) & FAT_entry_mask(ihand)) ;

  if (cluster == CLUSTER_unused(ihand))
   dval &= ~(mask << offset);

  offset += secalloc;
  if (offset >= 32) {
   *bufp++ = dval;
   dval = *bufp;
   offset &= 0x1F;
   if (cluster == CLUSTER_unused(ihand))
    dval &= ~(mask >> (secalloc - offset));
  }

  /* Make sure we don't write past the end of the buffer. */
  if (((int)bufp + (offset >> 3)) >= (int)buffer)
   break;
 }
 *bufp = dval;

 return(0) ;
}

/*-------------------------------------------------------------------------*/

FS_free_space *DOSFS_read_free_space(DOSdisc *ihand)
{
 word            unitsize ;                      /* CLUSTER size */
 DOS_bootsector *DOSboot = &(ihand->disc_boot) ; /* short-hand */

 tracef1("DOSFS_read_free_space: ihand = &%08X\n",(word)ihand) ;

 /* Return the free space information for the given image. */
 unitsize = cluster_size(DOSboot) ;

 fspace.freespace = ihand->disc_freeclusters;
 fspace.freespace *= unitsize ;
 fspace.largestobject = fspace.freespace ;
 fspace.discsize = DOSFS_max_sect(DOSboot) * DOSsecsize ;

 tracef1("DOSFS_read_free_space: returning %d\n", fspace.freespace);
 return(&fspace) ;
}

/*-------------------------------------------------------------------------*/

int DOSFS_namedisc(char *newname,DOSdisc *ihand)
{
 int           numFATs = ihand->disc_boot.BOOT_num_fats ;
 int           FATsize = ihand->disc_FATsize ;
 int           ROOTsize = (ihand->disc_ROOTsize * DOSsecsize) ;
 DOS_direntry *rootdir = NULL ;
 DIR_info *dirstruct;

 tracef2("DOSFS_namedisc: \"%s\" (ihand = &%08X)\n",((newname == NULL)?"<NULL>":newname),(int)ihand) ;

 /* Name the referenced image "newname". Under MS-DOS this involves updating
  * the volume entry in the ROOT directory (or creating a new one).
  */

  {
   int           index ;
   DOS_direntry *dentry ;
   char         *namebuff = NULL ;
   time5byte     nameTIME ;
   int           rootsec = ((((numFATs * FATsize) + DOSsecsize) / DOSsecsize) + 1) ;

   /* Load the ROOT directory */
   if ((int)(dirstruct = loadDIR("", ihand)) < 0)
    return -1;
   rootdir = dirstruct->dir_entries;

   /* Search for a volume entry */
   index = 0 ;
   if ((dentry = findDIRtype((byte)FILE_volume,rootdir,ROOTsize,&index)) == NULL)
    dentry = findemptyDIRentry(rootdir,ROOTsize) ;

   if (dentry == NULL)
    {
     /* There are no free slots in the ROOT directory */
     return_error0(int,err_discfull) ;
    }

   /* zero the directory entry before placing our information */
   for (index = 0; (index < sizeof(DOS_direntry)); index++)
    ((char *)dentry)[index] = '\0' ;

   /* write the given discname into the "dentry" */
   namebuff = (char *)&(dentry->FILE_status) ;
   /* copy upto the first space or NULL character */
   for (index = 0; (index < (namsize + extsize)); index++)
    if (*newname && (*newname != ' '))
     *namebuff++ = *newname++ ;
    else
     break ; /* the for loop */

   /* pad upto the limit with spaces */
   for (; (index < (namsize + extsize)); index++)
    *namebuff++ = ' ' ;

   /* mark the directory entry as a "volume" */
   dentry->FILE_attribute = (FILE_volume | FILE_archive) ;
   localTIME(&nameTIME) ;
   put_FILE_time(dentry,RISCOStoTIME(&nameTIME)) ;
   put_FILE_date(dentry,RISCOStoDATE(&nameTIME)) ;
   put_FILE_cluster(dentry,0x00000000) ;
   dentry->FILE_size = 0x00000000 ; /* labels have no size */

   /* Save the (modified) ROOT directory */
   if (DOS_image_RW(Wdata,rootsec,0,(byte *)rootdir,ROOTsize,ihand) < 0)
    {
     free_dir_cache("", ihand);
     return((int)-1) ; /* error already defined */
    }
  }

 return(0) ;
}

/*-------------------------------------------------------------------------*/

int DOSFS_stampimage(int type,DOSdisc *ihand)
{
 tracef2("DOSFS_stampimage: type %d (ihand = &%08X)\n",type,(int)ihand) ;

 /* type = 0    stamp image on next update
  * type = 1    stamp image now
  *
  * This call should either update the images unique identification number
  * (ie. the value returned in the DiscID field of the disc record on an
  * IdentifyDisc call) immediately or as part of the next image update.
  * This is then used by FileCore to keep track of discs when it performs
  * IdentifyDisc calls. When the identity has been updated we should perform
  * an "OS_Args 8" (OSArgs_ImageStampIs) to inform FileCore of the new ID.
  *     OS_Args
  *             r0 = 8
  *             r1 = image file handle
  *             r2 = new image identity
  */
 if (type == 0) /* stamp image on next update */
  ihand->disc_flags = disc_UPDATEID | disc_CHANGED ;
 else
  return(update_imageID(ihand)) ; /* update image ID immediately */

 return(0) ;
}

/*-------------------------------------------------------------------------*/
/* Read (and scan) directories recursively until we find an object with
 * offCLUSTER contained within it.  namebuff should contain the pathname
 * to start searching from (usually the null string "");
 */
static int findCLUSTER(int offCLUSTER,char *namebuff,int blen,DOSdisc *ihand)
{
 char          *DOSname = NULL ; /* current path position */
 DIR_info      *cdir = NULL ;    /* pointer to the loaded directory */
 int            loop ;           /* general index counter */
 DOS_direntry  *dentry ;         /* directory entry structure pointer */
 char          *nbuff = (char *)malloc(DOSnamesize) ;
 int           leafind;

 tracef3("findCLUSTER: offCLUSTER &%03X, namebuff \"%s\", blen &%08X\n",offCLUSTER,namebuff,blen) ;

 if (nbuff == NULL) /* failed to allocation name buffer */
  return_errorT(int,err_heapexhausted,tok_heapexhausted,0,0) ;

 leafind = strlen(namebuff);

 if ((DOSname = (char *)malloc(MaxString)) == NULL)
  {
   free(nbuff) ;
   return_errorT(int,err_heapexhausted,tok_heapexhausted,0,0) ;
  }

 if ((int)convertRISCOStoDOS(namebuff,DOSname) < 0)
  {
   free(DOSname) ;
   free(nbuff) ;
   return(-1) ; /* error already defined */
  }

 /* load the desired directory */
 cdir = loadDIR(DOSname, ihand) ;
 if ((int)cdir == -1)
  {
   tracef0("findCLUSTER: no directory loaded\n") ;
   free(DOSname) ;
   free(nbuff) ;
   return(-1) ; /* error message already defined */
  }

 /* scan entries from the beginning of this directory */
 loop = 0 ;
 do
  {
   if ((dentry = getnextDIRentry(&(cdir->dir_entries[0]),cdir->dir_size,&loop)) != NULL)
    {
     /* "getnextDIRentry" returns all FILE types: This includes volume labels
      * and hidden and system files. We must scan the allocated CLUSTER chain
      * of every object, recursing into directory objects.
      */
     if ((dentry->FILE_attribute & FILE_volume) == 0)
      {
       /* we have a useable directory entry */
       char *cfile ;
       if ((cfile = buildFILEname(dentry,nbuff)) != NULL)
        {
         int startCLUSTER ;
         if ((int)convertDOStoRISCOS(cfile,DOSname) < 0)
          {
           free(DOSname) ; /* release converted pathname buffer */
           free(nbuff) ;   /* release single level name buffer */
           return(-1) ;    /* error already defined */
          }
         cfile = DOSname ; /* RISC OS name for this object */
         if ((leafind + strlen(cfile) + 1) > blen) {
           /* pathname too long for buffer */
           free(DOSname) ; /* release name buffer */
           free(nbuff) ;   /* release single level name buffer */
           return_errorT(int,err_buftoosmall,tok_buftoosmall,0,0) ;
         }
         sprintf(namebuff + leafind,".%s",cfile) ;
         if ((startCLUSTER = get_FILE_cluster(dentry)) != 0x000)
          {
           if (clusterinchain(startCLUSTER, offCLUSTER, ihand))
            {
             free(DOSname) ; /* release name buffer */
             free(nbuff) ;   /* release single level name buffer */
             return(1) ;     /* CLUSTER has been found */
            }
          }
         if ((dentry->FILE_attribute & FILE_subdir) != 0)
          {
           int state ;
           if (((state = findCLUSTER(offCLUSTER,namebuff,blen,ihand)) == 1) || (state < 0))
            {
             free(DOSname) ; /* release name buffer */
             free(nbuff) ;   /* release single level name buffer */
             if (state < 0)
              return(-1) ;   /* error already defined */
             return(1) ;     /* CLUSTER has been found */
            }
          }
        }
       else
        {
         free(DOSname) ; /* release converted pathname buffer */
         free(nbuff) ;   /* release single level name buffer */
         return_error0(int,err_namereadfailed) ;
        }
      }
      *(namebuff + leafind) = '\0';
    }
  } while ((dentry != NULL) && (loop >= 0)) ;

 free(DOSname) ; /* release converted pathname buffer */
 free(nbuff) ;   /* release single level name buffer */
 return(0) ; /* CLUSTER not found */
}

/*-------------------------------------------------------------------------*/

int DOSFS_objectatoffset(int offset,char *buffer,int blen,DOSdisc *ihand)
{
 int allocsize = (secsalloc(ihand) * DOSsecsize) ; /* size of a CLUSTER */
 int offCLUSTER ;  /* CLUSTER in which the given offset lies */
 int nextCLUSTER ; /* CLUSTER referenced by offset CLUSTER (offCLUSTER) */
 int state ;

 tracef4("DOSFS_objectatoffset: offset &%08X, buffer &%08X (len &%08X) (ihand = &%08X)\n",offset,(int)buffer,blen,(int)ihand) ;

 /* Return the type of the object found at the given image offset. If the
  * object has a suitable path, then it should be returned in passed
  * buffer (with a leading directory seperator "." character).
  *
  * type 0 - offset is free, defect or beyond the end of the image
  *      1 - offset is allocated but not a file/directory (eg. FAT)
  *      2 - offset is in single object
  *      3 - offset is in multiple objects
  *
  * Return codes 2 and 3 should place the object name into the buffer.
  */

 /* For DOS discs we can easily spot the system areas of the image, and
  * areas that have NOT yet been allocated. However, to find the name of
  * an object we will have to scan every directory until we find an
  * object whose chain contains the CLUSTER at the given offset.
  */

 /* CLUSTER align (downwards) the passed offset */
 offCLUSTER = (offset / allocsize) ;
 tracef1("DOSFS_objectatoffset: offCLUSTER = &%03X\n",offCLUSTER) ;

 if (CLUSTERtoSECTOR(offCLUSTER,ihand) < ihand->disc_startsec)
  {
   tracef0("DOSFS_objectatoffset: CLUSTER in system area (returning 1)\n") ;
   return(1) ; /* CLUSTER is in the system area */
  }

 nextCLUSTER = getnextCLUSTER(offCLUSTER,ihand) ;
 if (nextCLUSTER < CLUSTER_first(ihand))  /* JRS 9/3/92 ensure within FAT */
   return_error0(int,err_clusterchain) ;

 if ((nextCLUSTER == CLUSTER_unused(ihand)) || (nextCLUSTER == CLUSTER_bad(ihand)))
  {
   tracef0("DOSFS_objectatoffset: CLUSTER in free or bad (returning 0)\n") ;
   return(0) ; /* CLUSTER is free or bad */
  }

 /* Under DOSFS a CLUSTER can only be used by one object. Therefore we never
  * return reason code 3 (offset used by multiple objects). If we reach here
  * we must place the object name into the passed buffer and return reason
  * code 2.
  */
 /* We need to scan from the root directory all file (and directory) chains,
  * until we find a file which contains a reference to "offCLUSTER".
  */
 *buffer = '\0';    /* Start from root directory. */
 if ((state = findCLUSTER(offCLUSTER,buffer,blen,ihand)) == 0)
  {
   tracef0("DOSFS_objectatoffset: CLUSTER could not be found in a chain\n") ;
   return(0) ; /* We could NOT find the CLUSTER in any chain */
  }
 if (state < 0)
  return(-1) ; /* error already defined */

 /* The above "findCLUSTER" call will have filled the buffer suitably */
 return(2) ; /* CLUSTER is in use */
}

/*-------------------------------------------------------------------------*/
/* Return the maximum number of sectors given a disc's boot block.
 */
word DOSFS_max_sect(DOS_bootsector *bb)
{
        word max_sect = (bb->BOOT_max_sectHI << 8) | (bb->BOOT_max_sect);

        tracef2("DOSFS_max_sect: boot block at &%08X, max_sect = %d\n",bb,max_sect);

        if (max_sect != 0) return max_sect;

        return (bb->BOOT_extra.wini.big_sect3 << 24) | (bb->BOOT_extra.wini.big_sect2 << 16)
                | (bb->BOOT_extra.wini.big_sect1 << 8) | bb->BOOT_extra.wini.big_sect;
}

/*-------------------------------------------------------------------------*/
/*> EOF c.DOSFSops <*/
