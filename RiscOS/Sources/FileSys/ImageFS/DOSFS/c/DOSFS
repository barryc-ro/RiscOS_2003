/*> c.DOSFS <*/
/*-------------------------------------------------------------------------*/
/* DOSFS (MultiFS support module)               Copyright (c) 1990 JGSmith */
/*-------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "ctype.h"

#if 1 /* SMC_FIX */
#undef DOSFS_DiscFormat
#undef DOSFS_LayoutStructure
#endif

#include "h.ASCII"
#include "h.DOSFS"
#include "h.DOSFSctl"
#include "h.debug"
#include "h.DOSFShdr"
#include "h.ADFSshape"
#include "h.DOSshape"
#include "h.FSerrors"
#include "h.DOSmapping"
#include "h.DOSnaming"
#include "h.DOSFSops"
#include "h.MultiFS"
#include "h.wcompare"
#include "h.BOOTBLOCK"  /* for the default BOOT BLOCK structure */
#include "h.TIMEconv"   /* for format time-stamping */
#if 1 /* SMC_FIX_RO_5593 */
  #include "h.MsgTrans"
#endif
#if 1 /* SMC_REDUCE_RMA */
  #include "h.Statics"
#endif

/*-------------------------------------------------------------------------*/

#define imagetype (0xFC8) /* as allocated by Acorn : "MSDOSDSC" */

/*-------------------------------------------------------------------------*/
/* global (static) variables used within the module */

mapentry *maplist = NULL ;      /* DOS/RISC OS filetype mapping chain */
#if 1 /* SMC_TRUNCATE */
int module_flags = 0 ;          /* Global flags */
#endif

/* The following are used for parameter returns to the RISC OS world. They
 * are provided as static structures to ensure they are not de-allocated
 * when we leave the C world (since normal variables are allocated from the
 * stack).
 */
FS_open_block fblock ;
FS_datestamp  tstamp ;
FS_cat_entry  fcat ;
FS_dir_block  dblock ;
FS_free_space fspace ;
char          tline[MaxString] = {0} ; /* static filename return area */

/*-------------------------------------------------------------------------*/

FILEhand *FILE_list = NULL ;  /* open file handle list */

#if 0 /* SMC_REDUCE_RMA */
/***************************************************************************/
/* The following arrays are now defined in s.Statics                       */
/***************************************************************************/
/*-------------------------------------------------------------------------*/
/* DOS logical disc types: */

/* This information used by "DiscFormat" */
/* Table describes PHYSICAL formats supported */
format_spec DOS_formatinfo[] = {
#if 1 /* SMC_NEW_FORMATS */
/* -- MSDOS Q 1.44M double sided, 80 tracks, 18 sectors */
  {DOSsecsize,50,50,22,18,Hdensity,               (o_indexmark | o_alternate),1,1,0,0,0x4E,160,0,0,0,0,0,0,0,0,0},
/* -- MSDOS/Atari M 720K double sided, 80 tracks, 9 sectors */
  {DOSsecsize,50,50,22, 9,Ddensity,               (o_indexmark | o_alternate),1,1,0,0,0x4E,160,0,0,0,0,0,0,0,0,0},
/* -- MSDOS H 1.2M double sided, 80 tracks, 15 sectors */
  {DOSsecsize,50,50,22,15,Hdensity,               (o_indexmark | o_alternate),1,1,0,0,0x4E,160,0,0,0,0,0,0,0,0,0},
/* -- MSDOS N 360K double sided, 40 tracks, 9 sectors */
  {DOSsecsize,50,50,22, 9,Ddensity,(o_indexmark | o_doublestep | o_alternate),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- MSDOS P 180K single sided, 40 tracks, 9 sectors */
  {DOSsecsize,50,50,22, 9,Ddensity,(o_indexmark | o_doublestep | o_side1only),1,1,0,0,0x4E, 40,0,0,0,0,0,0,0,0,0},
/* -- MSDOS T 320K double sided, 40 tracks, 8 sectors */
  {DOSsecsize,50,50,22, 8,Ddensity,(o_indexmark | o_doublestep | o_alternate),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- MSDOS U 160K single sided, 40 tracks, 8 sectors */
  {DOSsecsize,50,50,22, 8,Ddensity,(o_indexmark | o_doublestep | o_side1only),1,1,0,0,0x4E, 40,0,0,0,0,0,0,0,0,0},
/* -- Atari N 360K single sided, 80 tracks, 9 sectors */
  {DOSsecsize,50,50,22, 9,Ddensity,               (o_indexmark | o_side1only),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- Terminator */
  {         0, 0, 0, 0, 0,       0,                                         0,0,0,0,0,0x00,  0,0,0,0,0,0,0,0,0,0}
#else
/* -- single sided 80track/9sectors MS-DOS and Atari -- */
{DOSsecsize,50,50,22, 9,Ddensity,               (o_indexmark | o_side1only),1,1,0,0,0x4E,160,0,0,0,0,0,0,0,0,0},
/* -- double sided 80track/9sectors MS-DOS and Atari -- */
{DOSsecsize,50,50,22, 9,Ddensity,               (o_indexmark | o_alternate),1,1,0,0,0x4E,160,0,0,0,0,0,0,0,0,0},
/* -- single sided 40track/9sectors MS-DOS -- */
{DOSsecsize,50,50,22, 9,Ddensity,(o_indexmark | o_doublestep | o_side1only),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- double sided 40track/9sectors MS-DOS -- */
{DOSsecsize,50,50,22, 9,Ddensity,(o_indexmark | o_doublestep | o_alternate),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- single sided 40track/8sectors MS-DOS -- */
{DOSsecsize,50,50,22, 8,Ddensity,(o_indexmark | o_doublestep | o_side1only),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- double sided 40track/8sectors MS-DOS -- */
{DOSsecsize,50,50,22, 8,Ddensity,(o_indexmark | o_doublestep | o_alternate),1,1,0,0,0x4E, 80,0,0,0,0,0,0,0,0,0},
/* -- double sided 80track/18sectors MS-DOS -- */
{DOSsecsize,50,50,22,18,Hdensity,(o_indexmark | o_doublestep | o_alternate),1,1,0,0,0x4E,160,0,0,0,0,0,0,0,0,0},
/* -- structure terminator -- */
{         0, 0, 0, 0,0,     0,                                            0,0,0,0,0,0x00, 0,0,0,0,0,0,0,0,0,0},
#endif
                            } ;

/* we need a mapping of MAGIC numbers to physical formats */
/* This is nasty since we use ABSOLUTE indices into the above table */
#if 1 /* SMC_FIX_RO_5593 */
DOSdiscinfo DOS_formats[] = {
#if 1 /* SMC_NEW_FORMATS */
             {0xF0, 1, 0, "DOS/Q", "FMT1", "FMTH1"},
             {0xF9, 1, 1, "DOS/M", "FMT2", "FMTH2"},
             {0xF9, 1, 2, "DOS/H", "FMT3", "FMTH3"},
             {0xFD, 1, 3, "DOS/N", "FMT4", "FMTH4"},
             {0xFC, 0, 4, "DOS/P", "FMT5", "FMTH5"},
             {0xFF, 0, 5, "DOS/T", "FMT6", "FMTH6"},
             {0xFE, 0, 6, "DOS/U", "FMT7", "FMTH7"},
             {0xF9, 1, 1, "Atari/M", "FMT8", "FMTH8"},
             {0xF8, 1, 7, "Atari/N", "FMT9", "FMTH9"},
             {0x00, 0, 0, NULL, NULL, NULL}
#else
             {0xFB, 0, "N", "FMT1", "FMTH1"},
             {0xF8, 0, "B", "FMT2", "FMTH2"},
             {0xF9, 1, "M", "FMT3", "FMTH3"},
             {0xF9, 1, "A", "FMT4", "FMTH4"},
             {0xF0, 6, "Q", "FMT5", "FMTH5"},
             {0x00, 0, NULL, NULL, NULL},
#endif
                            } ;
#else
DOSdiscinfo DOS_formats[] = {
             {0xFB,0,"N"," 360K, MS-DOS 3.20 upwards (SS)"},
             {0xF8,0,"B"," 360K, Atari (SS)"},
             {0xF9,1,"M"," 720K, MS-DOS 3.20 upwards (DS)"},
             {0xF9,1,"A"," 720K, Atari (DS)"}, /* same physical format as above */
             {0xF0,6,"Q","1440K, MS-DOS 3.20 upwards (DS)"},
             {0xFC,2,  0," 180K, MS-DOS (SS)"},
             {0xFD,3,  0," 360K, MS-DOS (DS)"},
             {0xFE,4,  0," 160K, MS-DOS (SS)"},
             {0xFF,5,  0," 320K, MS-DOS (DS)"},
             {0x00,  0,NULL},
                            } ;
#endif

#else /* SMC_REDUCE_RMA */
/* These are used to create the MessageTrans tokens for the format menu
 * and help text.
 */
#define FORMAT_FMT     "FMT%d"
#define HELP_FMT       "FMTH%d"
#endif /* SMC_REDUCE_RMA */

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Register our filing system with RISC OS */

static _kernel_oserror *declare_FS(void *private)
{
 _kernel_swi_regs rset ;
#if 1 /* SMC_TRUNCATE */
 _kernel_oserror *err;
#endif
 word             infoblock[9] ; /* nasty constant */

#if 1 /* SMC_TRUNCATE */
 /* Read the CMOS RAM truncate bit state */
#define FileSwitchCMOS 0x1C
#define FileSwitchTruncateNamesCMOSBit 0x01
 rset.r[0] = 161;    /* Reason code "ReadCMOS" */
 rset.r[1] = FileSwitchCMOS;
 if ((err = _kernel_swi(OS_Byte, &rset, &rset)) != NULL)
  return err;
 if (rset.r[2] & FileSwitchTruncateNamesCMOSBit) {
  tracef0("File names will be truncated.\n");
  module_flags |= TRUNCATE_NAMES;
 } else {
  tracef0("Long file names will generate an error.\n");
  module_flags &= ~TRUNCATE_NAMES;
 }
#endif

 /* register our module as a MultiFS filing system support */
 /* "OS_FSControl" reason 35 */
 infoblock[0] = (word)0x00000000 ; /* bit27 is only significant flag */
 infoblock[1] = (word)imagetype ;
 infoblock[2] = ((word)DOSFS_Open     - (word)moduleBase) ;
 infoblock[3] = ((word)DOSFS_GetBytes - (word)moduleBase) ;
 infoblock[4] = ((word)DOSFS_PutBytes - (word)moduleBase) ;
 infoblock[5] = ((word)DOSFS_Args     - (word)moduleBase) ;
 infoblock[6] = ((word)DOSFS_Close    - (word)moduleBase) ;
 infoblock[7] = ((word)DOSFS_File     - (word)moduleBase) ;
 infoblock[8] = ((word)DOSFS_Func     - (word)moduleBase) ;

 rset.r[0] = 35 ; /* reason code "FSControl_AddImage" */
 rset.r[1] = (word)moduleBase ;
 rset.r[2] = ((word)infoblock - (word)moduleBase) ;
 rset.r[3] = (word)private ;

 return(_kernel_swi(OS_FSControl,&rset,&rset)) ;
}

/*-------------------------------------------------------------------------*/
/* select_FS:
 * Select "DOSFS" as the current filing system.
 */
static _kernel_oserror *select_FS(void)
{
 _kernel_swi_regs rset ;

 rset.r[0] = FSControl_SelectFS ;               /* operation */
 rset.r[1] = (unsigned int)moduleName() ;       /* filing system name */
 return(_kernel_swi(OS_FSControl,&rset,&rset)) ;
}

/*-------------------------------------------------------------------------*/

static _kernel_oserror *FSSWI_DiscFormat(_kernel_swi_regs *rset,void *private)
{
 /* in:  r0 = pointer to disc format structure to be filled in
  *      r1 = vetting SWI (normally "ADFS_VetFormat")
  *      r2 = r1 parameter to the vetting SWI
  *      r3 = format specifier
  * out: r0 = pointer to disc format specification structure (updated)
  */
 _kernel_swi_regs  urset ;
 _kernel_oserror  *rerror = NULL ;
 format_spec      *fspec ;

 tracef4("DOSFS: FSSWI_DiscFormat: r0 = &%08X, r1 = &%08X, r2 = &%08X, r3 = &%08X\n",rset->r[0],rset->r[1],rset->r[2],rset->r[3]) ;

 /* see "format_spec" structure in "h.MultiFS" */
 /* place the desired disk format specification into the referenced structure */
 fspec = &(DOS_formatinfo[DOS_formats[rset->r[3]].findex]) ;
 tracef1("DOSFS: FSSWI_DiscFormat: found format_spec &%08X\n",(word)fspec) ;
 (void)memmove((void *)rset->r[0],fspec,sizeof(format_spec)) ;

 tracef1("DOSFS: FSSWI_DiscFormat: fspec->secsize  = %d\n",fspec->secsize) ;
 tracef1("DOSFS: FSSWI_DiscFormat: fspec->secstrk  = %d\n",fspec->secstrk) ;
 tracef1("DOSFS: FSSWI_DiscFormat: fspec->density  = %d\n",fspec->density) ;
 tracef1("DOSFS: FSSWI_DiscFormat: fspec->options  = &%02X\n",fspec->options) ;
 tracef1("DOSFS: FSSWI_DiscFormat: fspec->startsec = %d\n",fspec->startsec) ;
 tracef1("DOSFS: FSSWI_DiscFormat: fspec->tracks   = %d\n",fspec->tracks) ;

 /* "VetFormat" SWI call:
  * in:  r0 = pointer to required format structure
  *      r1 = VetFormat parameter (r2 passed to "DiscFormat")
  * out: registers preserved (but structure possibly upgraded)
  */
 urset.r[0] = rset->r[0] ; /* copy of disc format structure */
 urset.r[1] = rset->r[2] ; /* parameter for the VetFormat call */
 if ((rerror = _kernel_swi((XOS_Bit | rset->r[1]),&urset,&urset)) == NULL)
  {
   /* Re-check that the structure is still acceptable to us:
    *  Fields that cannot change:
    *     fspec->secsize  fspec->secstrk  fspec->density  fspec->options  fspec->startsec  fspec->tracks
    *
    * Fields that can possibly be changed:
    *     fspec->gap1side0  fspec->gap1side1  fspec->gap3
    * Some research is needed here to discover what values are acceptable
    * to standard MS-DOS machines.
    *
    * Fields that are acceptable to change:
    *     fspec->secileave  fspec->sideskew  fspec->trackskew  fspec->fillvalue
    */
   format_spec *rfspec = (format_spec *)urset.r[0] ;
   if ((rfspec->secsize != fspec->secsize) || (rfspec->secstrk != fspec->secstrk) || (rfspec->density != fspec->density) || (rfspec->options != fspec->options) || (rfspec->startsec != fspec->startsec) || (rfspec->tracks != fspec->tracks))
    rerror = global_error(err_badformat) ; /* changes unacceptable to us */
  }

 return(rerror) ;
 UNUSED(private) ;
}

/*-------------------------------------------------------------------------*/
/* NOTE: This code currently only deals with floppy structures             */
/* Updated to support PCMCIA (arbitrary sector-multiple size structures)   */
/* by WT, 27-5-94    */
/* note the addition of r4 as a parameter */

static _kernel_oserror *FSSWI_LayoutStructure(_kernel_swi_regs *rset,void *private)
{
 /* in:  r0 = disc structure identifier (r5 from "Service_IdentifyFormat")
  *      r1 = pointer to -1 terminated list of bad blocks
  *      r2 = pointer to NULL terminated disc name
  *      r3 = file handle of system image
  *      r4 = size of partiton if r0 = pcmcia
  * out:
  */
 _kernel_swi_regs  reglist ;
 _kernel_oserror  *rerror = NULL ;
  char *sector = NULL;

 tracef4("DOSFS: FSSWI_LayoutStructure: r0 = &%08X, r1 = &%08X, r2 = &%08X, r3 = &%08X\n",rset->r[0],rset->r[1],rset->r[2],rset->r[3]) ;

 if(((rset->r[4] % DOSsecsize) != 0) && (rset->r[0] == 9)) { /* Should be a multiple of sectors big for pcmcia*/
     rerror = global_error(err_badformat);
     return(rerror);    /* Quit! */
 }

 /* Place default BOOT BLOCK (shape defined by r0 on entry) */
 if ((sector = (char *)malloc(DOSsecsize)) != NULL)
  {
   DOS_bootsector *dbsector = (DOS_bootsector *)sector; /* BOOT BLOCK for image */
   int findex = DOS_formats[rset->r[0]].findex ;
   int maxsect = (DOS_formatinfo[findex].secstrk * DOS_formatinfo[findex].tracks) ;

   tracef1("Findex = %d\n", findex);

   *dbsector = *(default_dbsector) ; /* copy the structure across */
   /* write format specific information (dictated by entry r0 parameter) */
   dbsector->BOOT_secalloc = DOS_formats[rset->r[0]].secsclus;
   dbsector->BOOT_root_dir = DOS_formats[rset->r[0]].rootsize;
   /* dbsector->BOOT_root_dirHI = 0x00; */
   dbsector->BOOT_max_sect = ((maxsect >> 0) & 0xFF) ;
   dbsector->BOOT_max_sectHI = ((maxsect >> 8) & 0xFF) ;
   dbsector->BOOT_magic = DOS_formats[rset->r[0]].magic_ID ;
   dbsector->BOOT_secstrack = ((DOS_formatinfo[findex].secstrk >> 0) & 0xFF) ;
   dbsector->BOOT_secstrackHI = ((DOS_formatinfo[findex].secstrk >> 8) & 0xFF) ;
   dbsector->BOOT_FAT_size = DOS_formats[rset->r[0]].secsFAT;
   /* dbsector->BOOT_FAT_sizeHI = 0x00; */
   switch (DOS_formatinfo[findex].options & sideinfomask) {
    case o_alternate:
    case o_sequence:
     dbsector->BOOT_heads = 2;
     break;
    default:
     dbsector->BOOT_heads = 1;
   }

#if 1 /* PCMCIA */
   /* Special code for PCMCIA format */
   if((strcmp(DOS_formats[rset->r[0]].idtext,"PCMCIA") == 0)) {
       /* We need to change the max_sect and secsFAT settings */
        maxsect = rset->r[4] / DOSsecsize; /* Should be an integer result */
        dbsector->BOOT_max_sect = ((maxsect >> 0) & 0xFF) ;
        dbsector->BOOT_max_sectHI = ((maxsect >> 8) & 0xFF) ;
        dbsector->BOOT_FAT_size = ((maxsect * 2) + (DOSsecsize / 2))/ DOSsecsize; /* Rounded up */
   }
#endif

   /* Special code for Atari formats */
   if ((strcmp(DOS_formats[rset->r[0]].idtext,"Atari/M") == 0) || (strcmp(DOS_formats[rset->r[0]].idtext,"Atari/N") == 0))
    {
     /* Atari formats have no jump instruction in the boot block */
     sprintf((char *)dbsector->BOOT_JMP,"\0\0NNNNNN") ; /* NULL terminated */
     /* Atari formats have a 24bit volume serial number */
     dbsector->BOOT_OEM[5] = (rand() & 0xFF) ;  /* replace NULL */
     dbsector->BOOT_OEM[6] = (rand() & 0xFF) ;
     dbsector->BOOT_OEM[7] = (rand() & 0xFF) ;
    }

   /* write the BOOT BLOCK into the image */
   reglist.r[0] = osgbpb_wptr ;            /* write operation */
   reglist.r[1] = rset->r[3] ;             /* FileSwitch handle */
   reglist.r[2] = (word)dbsector ;         /* data address */
   reglist.r[3] = DOSsecsize ;             /* amount of data */
   reglist.r[4] = 0x00000000 ;             /* destination image offset */
   reglist.r[5] = NULL ;
   reglist.r[6] = NULL ;
   if ((rerror = _kernel_swi(OS_GBPB,&reglist,&reglist)) == NULL)
    {
     int   FATsize = (dbsector->BOOT_FAT_size|(dbsector->BOOT_FAT_sizeHI<<8));
     int   numFATs = dbsector->BOOT_num_fats;
     word  ROOTsize = ((dbsector->BOOT_root_dir | (dbsector->BOOT_root_dirHI << 8)) * sizeof(DOS_direntry)) / DOSsecsize;
     word offset = ((DOS_FAT_sector - 1) * DOSsecsize) ;
     int  loop ; /* general index counter */

     for (loop = 0; loop < DOSsecsize; loop++)
      sector[loop] = '\0' ; /* zero sector buffer */
     /* Can no longer take data from dbsector. */

     /* Create FATs */
     while (numFATs--) {
      sector[0] = DOS_formats[rset->r[0]].magic_ID ;
      sector[1] = 0xFF ;
      sector[2] = 0xFF ;
      for (loop = 0; loop < FATsize; loop++) {
       reglist.r[0] = osgbpb_wptr ;            /* write operation */
       reglist.r[1] = rset->r[3] ;             /* FileSwitch handle */
       reglist.r[2] = (word)sector ;           /* data address */
       reglist.r[3] = DOSsecsize ;             /* amount of data */
       reglist.r[4] = offset ;                 /* destination image offset */
       reglist.r[5] = NULL ;
       reglist.r[6] = NULL ;
       if ((rerror = _kernel_swi(OS_GBPB,&reglist,&reglist)) != NULL)
        break ; /* out of the FAT writing loop */
       offset += DOSsecsize ;
       if (loop)
        continue;
       sector[0] = sector[1] = sector[2] = 0;
      }
     }

     if (rerror == NULL) {
      DOS_direntry *dentry = (DOS_direntry *)sector ;
      time5byte     formTIME ;

      localTIME(&formTIME) ;

      /* place the default disc name into the first slot */
      put_FILE_time(dentry,RISCOStoTIME(&formTIME)) ;
      put_FILE_date(dentry,RISCOStoDATE(&formTIME)) ;

      /* Deal with the case when no name has been given */
      if (rset->r[2] == NULL) {
       /* Nasty bit of sprintf to create a default disc name of the
        * form HHMMYYMMDD (hours/minutes/year/month/day).
        */
       sprintf((char *)&dentry->FILE_status,"%02d%02d%02d%02d%02d ",((get_FILE_time(dentry) & hour_mask) >> hour_shift),((get_FILE_time(dentry) & min_mask) >> min_shift),((((get_FILE_date(dentry) & year_mask) >> year_shift) + 1980) % 100),((get_FILE_date(dentry) & mon_mask) >> mon_shift),((get_FILE_date(dentry) & day_mask) >> day_shift)) ;
      } else
       strncpy((char *)&(dentry->FILE_status),(char *)rset->r[2],(namsize + extsize)) ;

      /* Either of the above sprintf's will have over-written the
       * attribute flags with their terminating NULL. Since we are a
       * fresh format this should not lose any information.
       */
      dentry->FILE_attribute = (FILE_volume | FILE_archive) ;

      /* Write the root directory. */
      for (loop = 0; loop < ROOTsize; loop++) {
       int i;
       reglist.r[0] = osgbpb_wptr ;   /* write operation */
       reglist.r[1] = rset->r[3] ;    /* FileSwitch handle */
       reglist.r[2] = (word)sector ;  /* data address */
       reglist.r[3] = DOSsecsize ;    /* amount of data */
       reglist.r[4] = offset ;        /* destination image offset */
       reglist.r[5] = NULL ;
       reglist.r[6] = NULL ;
       if ((rerror = _kernel_swi(OS_GBPB,&reglist,&reglist)) != NULL)
        break;
       offset += DOSsecsize;
       if (loop)
        continue;
       for (i = 0; i < sizeof(DOS_direntry); i++)
        sector[i] = 0;
      }
     }
    }
   free(sector) ;
  }
 else
  rerror = global_errorT(err_heapexhausted, tok_heapexhausted, 0, 0) ;

 return(rerror) ;
 UNUSED(private) ;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Vector through to the relevant SWI handler */
_kernel_oserror *fs_swi(int swi_no,_kernel_swi_regs *rset,void *private)
{
 switch(swi_no + DOSFS_00)
  {
   case DOSFS_DiscFormat :
             return(FSSWI_DiscFormat(rset,private)) ;
             break ;

   case DOSFS_LayoutStructure :
             return(FSSWI_LayoutStructure(rset,private)) ;
             break ;

   default : /* unknown */
             tracef1("DOSFS: return unknown SWI (%d) error\n",swi_no) ;
             return global_errorT(err_badswi, tok_badswi, "DOSFS", 0);
             break ;
  }

 return(NULL) ;
}

/*-------------------------------------------------------------------------*/
/* Provide handlers for the services we intercept */

void fs_service(int service_number,_kernel_swi_regs *rset,void *private)
{
 /* Note: We should NOT perform any IO from these functions */
 switch (service_number)
  {
   case 0x11 : /* Service_Memory */
               /* if (rset->r[2] == module base addr) then claim this call */
               if (rset->r[2] == (int)moduleBase)
                {
                 tracef0("DOSFS: Service_Memory (0x11): matched\n") ;
                 rset->r[1] = 0x00000000 ; /* claim this service */
                }
               break ;

   case 0x12 : /* Service_StartUpFS */
               select_FS() ;
               break ;

   case 0x27 : /* Service_Reset */
               tracef0("DOSFS: Service_Reset: called\n") ;
               break ;

   case 0x40 : /* Service_FSRedeclare */
               declare_FS(private) ;
               break ;

   case 0x42 : /* Service_LookupFileType */
               break ;

   case 0x5C : /* Service_WimpSaveDesktop */
               tracef0("DOSFS: Service_WimpSaveDesktop: called\n") ;
               tracef1("DOSFS: WimpSaveDesktop: r0 = &%08X\n",rset->r[0]) ;
               tracef1("DOSFS: WimpSaveDesktop: r1 = &%08X\n",rset->r[1]) ;
               tracef1("DOSFS: WimpSaveDesktop: r2 = &%08X\n",rset->r[2]) ;
               /* r0 = 0x00 */
               /* r1 = 0x5C - Service_WimpSaveDesktop */
               /* r2 = FileSwitch file handle */
               {
                _kernel_oserror  *rerror = NULL ;
                _kernel_swi_regs  reglist ;
                mapentry         *cptr = maplist ;
                char             *tbuff ;

                tbuff = (char *)malloc(strlen("DOSMap DOS FFF\n") + 1) ;
                /* we do not do anything if we failed to alloc memory */
                if (tbuff != NULL)
                 {
                  for (; (cptr != NULL); cptr = cptr->next)
                   {
                    int loop ;
                    sprintf(tbuff,"DOSMap ") ;
                    for (loop = 0; (loop < 3); loop++)
                     {
                      char cchr = ((cptr->dosext >> (loop * 8)) & 0xFF) ;
                      cchr = (((cchr > ' ') && (cchr != 0x7F)) ? cchr : ' ') ;
                      sprintf(&tbuff[strlen(tbuff)],"%c",cchr) ;
                     }
                    sprintf(&tbuff[strlen(tbuff)]," %03X\n",cptr->ROtype) ;
                    reglist.r[0] = osgbpb_write ; /* write operation */
                    reglist.r[1] = rset->r[2] ; /* FileSwitch handle */
                    reglist.r[2] = (word)tbuff ; /* data address */
                    reglist.r[3] = strlen(tbuff) ; /* amount of data */
                    reglist.r[4] = NULL ; /* destination image offset */
                    reglist.r[5] = NULL ;
                    reglist.r[6] = NULL ;
                    if ((rerror = _kernel_swi(OS_GBPB,&reglist,&reglist)) != NULL)
                     {
                      rset->r[0] = (word)rerror ; /* pointer to error block */
                      rset->r[1] = 0x00 ; /* Service_Claimed */
                      break ; /* out of for loop */
                     }
                   }
                  free(tbuff) ;
                 }
               }
               break ;

   case 0x68 : /* Service_CloseFile */
               break ;

   case 0x69 : /* Service_IdentifyDisc */
               /* in:   r1 = Service_IdentifyDisc */
               /*       r2 = Pointer to buffer for format name */
               /*       r3 = Length of format name buffer */
               /*       r5 = pointer to disc record */
               /*       r6 = sector cache handle */
               /*       r8 = pointer to filecore instance private word */
               /* out:  r1 = Service_Serviced (NULL) */
               /*       r2 = filetype number for given disc format */
               /*       r5 = pointer to disc record (possibly updated) */
               /*       r6 = new sector cache handle */
               /*       r8 = preserved */
               tracef3("DOSFS: Service_IdentifyDisc: r5 = &%08X, r6 = &%08X, r8 = &%08X\n",rset->r[5],rset->r[6],rset->r[8]) ;
               {
                ADFS_drecord    *dr = (ADFS_drecord *)rset->r[5] ;

                /* Check the sector size and lowest numbered sector for DOS format */
                /* NOTE: If any of the above fields are zero then we are probably on a hard disc, so ignore
                 *       the fields and continue.
                 */
                tracef1("DOSFS: Service_IdentifyDisc: log2secsize(dr) = %d\n",log2secsize(dr)) ;
                tracef1("DOSFS: Service_IdentifyDisc: secspertrk(dr) = %d\n",secspertrk(dr)) ;
                tracef1("DOSFS: Service_IdentifyDisc: heads(dr) = %d\n",heads(dr));
                tracef1("DOSFS: Service_IdentifyDisc: dr->dr_floppy_density = %d\n",dr->dr_floppy_density) ;
                tracef1("DOSFS: Service_IdentifyDisc: discsize(dr) = &%X\n",discsize(dr));
                tracef1("DOSFS: Service_IdentifyDisc: doublestep(dr) = %d\n",doublestep(dr));
                tracef1("DOSFS: Service_IdentifyDisc: sequence(dr) = %d\n",sequence(dr));
                tracef1("DOSFS: Service_IdentifyDisc: tracklow(dr) = %d\n",tracklow(dr)) ;
                tracef1("DOSFS: Service_IdentifyDisc: trackskew(dr) = %d\n",trackskew(dr)) ;
                tracef1("DOSFS: Service_IdentifyDisc: dr->dr_drive = &%08X\n",dr->dr_drive);

                if ((log2secsize(dr) == log2DOSsecsize || log2secsize(dr) == 0)
                    && tracklow(dr) == 1 && trackskew(dr) == 0)
                 {
                  char             *sector = (char *)malloc(DOSsecsize) ;

                  if (sector != NULL)
                   {
                    _kernel_swi_regs  urset ;
                    _kernel_oserror *rerror = NULL ;
                    DOS_bootsector   *bblock = (DOS_bootsector *)sector;
                    int claimed = 0;
                    int discSize, noSides, dblstep, numFATs, FATsize, numRESVD, ROOTsize, magic;
                    int discID = 0;
                    int Atari = 0;
                    int index;

                    /* Sector 1, track 0 should always be readable regardless of the specific DOS format */
                    /* Use FileCore_DiscOp 9 (option bits 2_01x0) and the alternative disc record we have */
                    /* FileCore_DiscOp
                     *      in:     r1 = bits0-3    reason code 9
                     *                   bits4-7    option bits
                     *                   bits8-31   bits2-25 of pointer to alternative disc record
                     *              r2 = disc address
                     *              r3 = pointer to buffer
                     *              r4 = length (bytes)
                     *              r6 = sector cache handle
                     *              r8 = pointer to FileCore instance private word
                     *      out:    r1 = preserved
                     *              r2 = disc address of next byte to be transferred
                     *              r3 = pointer to next buffer location to be transferred
                     *              r4 = number of bytes NOT transferred
                     *              r6 = new sector cache handle
                     *              r8 = preserved
                     */

                    urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
                    urset.r[2] = dr->dr_rootSIN & 0xE0000000 ;         /* disc address */
                    urset.r[3] = (word)bblock ;                        /* BOOT block buffer */
                    urset.r[4] = sizeof(DOS_bootsector) ;              /* size of the buffer */
                    urset.r[6] = rset->r[6] ;                          /* entry sector cache handle */
                    urset.r[8] = rset->r[8] ;                          /* entry FileCore private word pointer */
                    tracef1("DOSFS: Service_IdentifyDisc: reading sector from &%08X\n",urset.r[2]);
                    if ((rerror = _kernel_swi((XOS_Bit | FileCore_DiscOp),&urset,&urset)) == NULL)
                     {
                      tracef0("DOSFS: Service_IdentifyDisc: sector read\n");
                      /* Can only make sketchy test for a valid boot block, later test should fail
                       * if the boot block is not valid.
                       */
#if 1 /* PCMCIA */
                      if (sector_size(bblock) == DOSsecsize)
#else
                      if (sector_size(bblock) == DOSsecsize || bblock->BOOT_num_fats == 2)
#endif
                       {
                        /* Get number of sectors and number of sectors per track from BOOT block. */
                        int bbsize = DOSFS_max_sect(bblock);
                        int notracks = (bblock->BOOT_secstrackHI << 8) | bblock->BOOT_secstrack;

                        if (notracks > 0) {
                          notracks = bbsize / notracks; /* Calculate number of tracks from BOOT block. */
                          bbsize = bbsize * DOSsecsize; /* Calculate disc size from BOOT block. */

                          /* Calculate disc size to using disc record info. */
                          discSize = (secspertrk(dr) * bytespersec(dr) * notracks) ;

                          tracef1("DOSFS: Service_IdentifyDisc: discSize = &%08X\n",discSize) ;
                          tracef1("DOSFS: Service_IdentifyDisc: check size = &%08X\n",bbsize) ;

#if 1 /* PCMCIA */
                          /* Now have to cope with PCMCIA cards with bits of first track "missing" */
                          if ((bbsize < (discSize + (secspertrk(dr)*bytespersec(dr)))) && (bbsize >= discSize))
#else
                          /* validation : (bbsize == discSize) */
                          if (bbsize == discSize)
#endif
                           {
                            noSides = bblock->BOOT_heads;
                            if (noSides > 0)
                             {
                              /* It's a DOS disc so claim it as one of ours and set up the disc record info. */
                              magic = bblock->BOOT_magic;
                              numFATs = bblock->BOOT_num_fats;
                              FATsize = (bblock->BOOT_FAT_size | (bblock->BOOT_FAT_sizeHI << 8)) * DOSsecsize;
                              numRESVD = (bblock->BOOT_reserved | (bblock->BOOT_reservedHI << 8)) ;
                              ROOTsize = ((bblock->BOOT_root_dir | (bblock->BOOT_root_dirHI << 8)) * sizeof(DOS_direntry)) ;
                              /* If this is an Atari disc then it has no jmp instruction. */
                              Atari = (bblock->BOOT_JMP[0] == 0);
                              dblstep = ((notracks / noSides) == 40);
                              discsize(dr) = discSize;
                              heads(dr) = noSides;
                              claimed = 1;
                             }
                            else
                             {
                              tracef0("DOSFS: Service_IdentifyDisc: Invalid boot block, BOOT_heads = 0\n");
                             }
                           }
                          else
                           {
                            tracef0("DOSFS: Service_IdentifyDisc: FileCore and BOOT BLOCK disc sizes differ\n") ;
                           }
                         }
                        else
                         {
                          tracef0("DOSFS: Service_IdentifyDisc: Invalid boot block, BOOT_secstrack = 0\n");
                         }
                       }
                      else
                       {
                        tracef0("DOSFS: Service_IdentifyDisc: Invalid boot block (could be 320K or 160K)\n");
                       }
                     }
                    else
                     {
                      tracef2("DOSFS: Service_IdentifyDisc: &%08X \"%s\"\n",rerror->errnum,rerror->errmess) ;
                     }

                    /* If we have not claimed the disc then it could still be valid only if it is a 320K or
                     * 160K format, both of which have 8 sectors per track (these old formats need not have a
                     * valid boot block).
                     */
                    if (!claimed) {
                     if (secspertrk(dr) != 8) {
                      tracef0("DOSFS: Service_IdentifyDisc: invalid boot block and not 320K or 160K format\n");
                      free(sector);
                      break;    /* break switch */
                     }
                     /* Defaults for 320K and 160K formats. */
                     dblstep = 1;
                     numFATs = 2;
                     FATsize = DOSsecsize;
                     numRESVD = 1;
                     /* ROOTsize could be 112 or 64 (* sizeof(DOS_direntry)). */
                     /* noSides could be 1 or 2. */
                    }
                    put_doublestep(dr, dblstep);
                    put_sequence(dr, 0);

                    /* Read the FAT.  This will be used to identify a 320K or 160K format if necessary and
                     * also to calculate a disc ID to pass back to FileCore.
                     */
                    tracef0("DOSFS: Service_IdentifyDisc: reading FAT\n");
                    for (index = 0; index < FATsize; index += DOSsecsize) {
                     urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
                     urset.r[2] = (index + DOSsecsize) | (dr->dr_rootSIN & 0xE0000000); /* disc address */
                     urset.r[3] = (word)sector ;
                     urset.r[4] = DOSsecsize ;
                     /* sector cache handle and FileCore private word pointer preserved from above call */

                     if ((rerror = _kernel_swi((XOS_Bit | FileCore_DiscOp),&urset,&urset)) == NULL) {
                      if (!claimed) {
                       /* Check the first byte of the FAT for the 320K or 160K media type. */
                       magic = *sector;
                       if (magic == 0xFE) {
                        claimed = 1;
                        ROOTsize = 64 * sizeof(DOS_direntry);
                        noSides = 1;
                        discSize = 0x28000;
                       } else if (magic == 0xFF) {
                        claimed = 1;
                        ROOTsize = 112 * sizeof(DOS_direntry);
                        noSides = 2;
                        discSize = 0x50000;
                       }
                       discsize(dr) = discSize;
                       heads(dr) = noSides;
                      }

                      /* If this is a DOS disc then calculate a disc ID from the FAT contents. */
                      if (claimed) {
                       int loop;
                       for (loop = 0; loop < DOSsecsize; loop++)
                        discID += sector[loop] ;
                      } else
                       break;
                     } else {
                      tracef1("DOSFS: Service_IdentifyDisc: %s\n",rerror->errmess);
                      break;
                     }
                    }

                    if (claimed) {
                     /* The disc is definitely DOS so we can claim the service and fill in the disc record. */
                     /* Get the default disc name from the Messages file. */
                     char *buf = 0;
                     int bufsz = 0;

                     tracef1("DOSFS: Service_IdentifyDisc: accepted disc type &%02X\n",magic);

                     /* Lookup default disc name. */
                     if ((rerror = msgtrans_lookup("DEFDNM", &buf, &bufsz, 0, 0, 0, 0)) != NULL) {
                      buf = rerror->errmess;
                      bufsz = strlen(buf);
                     }
                     if (bufsz > 9)
                      bufsz = 9;
                     strncpy((char *)(dr->dr_discname), buf, bufsz);
                     dr->dr_discname[bufsz] = '\0';

                     /* Try to find a volume label on the disc. */
                     for (index = 0; index < ROOTsize; index += DOSsecsize) {
                      urset.r[1] = (9 | (4 << 4) | (((int)dr >> 2) << 8)) ;
                      urset.r[2] = ((numFATs * FATsize) + index + DOSsecsize) | (dr->dr_rootSIN & 0xE0000000) ; /* disc address */
                      urset.r[3] = (word)sector ;
                      urset.r[4] = DOSsecsize ;
                      /* sector cache handle and FileCore private word pointer preserved from above call */

                      if ((rerror = _kernel_swi((XOS_Bit | FileCore_DiscOp),&urset,&urset)) == NULL) {
                       int i = 0;
                       DOS_direntry *dentry;

                       if ((dentry = findDIRtype((byte)FILE_volume,(DOS_direntry *)sector,DOSsecsize,&i)) != NULL) {
                        tracef0("DOSFS: Service_IdentifyDisc: volume label found\n") ;
                        memmove((void *)&(dr->dr_discname[0]),(void *)&(dentry->FILE_status),(discnamesize - 1)) ;
#if 0 /* SMC 03-08-94: This terminates past the discname space (currently unused so was OK but no need to do it anyway). */
                        dr->dr_discname[discnamesize - 1] = nul ; /* ensure terminating NUL */
#endif
                        tracef1("DOSFS: Service_IdentifyDisc: volume \"%s\"\n",(char *)dr->dr_discname) ;
                        break;
                       }
                      }
                     }
#ifndef PRE218
                     /* Write format name into buffer. */
                     if (rset->r[2] != 0) {
                      char token[8];
                      for (index = 0; DOS_formats[index].magic_ID != 0; index++)
                       if (magic == DOS_formats[index].magic_ID) {
                        /* If type is &F9 then we need more tests. */
                        if (magic == 0xF9) {
                         if (Atari && strcmp(DOS_formats[index].idtext, "Atari/M"))
                          continue;
                         if (FATsize != DOS_formats[index].secsFAT * DOSsecsize)
                          continue;
                        }
                        break;
                       }
                      sprintf(token, FORMAT_FMT, index + 1);
                      buf = (char *)rset->r[2];
                      bufsz = rset->r[3];
                      if ((rerror = msgtrans_lookup(token, &buf, &bufsz, 0, 0, 0, 0)) != NULL) {
                       bufsz = strlen(rerror->errmess);
                       strncpy(buf, rerror->errmess, bufsz);
                      }
                      buf[bufsz] = '\0';
                      tracef1("Service_IdentifyDisc: format name = \"%s\"\n", buf);
                     }
#endif
                     /* Claim the service and fill in the disc record. */
                     rset->r[1] = 0x00 ;         /* Service_Serviced (claimed) */
                     put_discID(dr, discID);
                     tracef3("DOSFS: Service_IdentifyDisc: heads = %d, dblstep = %d, discID = &%04X\n",
                             noSides, dblstep, discID);
                     rset->r[2] = imagetype ;    /* filetype to be associated with the disc image */
                     rset->r[6] = urset.r[6] ;   /* sector cache handle returned from "FileCore_DiscOp" */
                    } else {
                     tracef0("DOSFS: Service_IdentifyDisc: not a DOS disc\n");
                    }
                    free(sector);
                   }
                  else
                   {
                    tracef0("DOSFS: Service_IdentifyDisc: failed to malloc sector buffer\n") ;
                   }
                 }
               }
               break ;

   case 0x6A : /* Service_EnumerateFormats */
               /* in:   r0 = 0 */
               /*       r1 = Service_EnumerateFormats */
               /* out:  r0 = pointer to linked list of format specifications (as RMA blocks) */
               /*       r1 = preserved */
               {
                format_info **next ;
                int          loop ;

                tracef0("DOSFS: Service_EnumerateFormats: called\n") ;

                /* set next to point to the next place to store a format_info pointer */
                next = (format_info **)&(rset->r[2]);
                while (*next != NULL)
                 next = &((*next)->link);

                /* see "format_info" structure in "h.MultiFS" */
                for (loop = 0; (DOS_formats[loop].magic_ID != 0x00); loop++)
                 if (DOS_formats[loop].idtext != NULL && DOS_formats[loop].in_menu) /* we support this format */
                  {
                   format_info *finfo = (format_info *)_kernel_RMAalloc(sizeof(format_info)) ;
                   char        *menu_text = 0;
                   char        *help_text = 0;
                   int         menusz;
                   int         helpsz;
                   _kernel_oserror *err;
                   char        token[8];

                   if (finfo == NULL)
                     continue;

                   /* get the text from the Messages file - to be safe do the copying here in case */
                   /* message trans uses the same buffer for both calls */
                   sprintf(token, FORMAT_FMT, loop + 1);
                   if ((err = msgtrans_lookup(token, &menu_text, &menusz, 0, 0, 0, 0)) != NULL) {
                     menu_text = err->errmess;
                     menusz = strlen(menu_text);
                   }
                   finfo->menu_text = _kernel_RMAalloc(menusz + 1) ;
                   if (finfo->menu_text != NULL) {
                     strncpy(finfo->menu_text, menu_text, menusz);
                     ((char *)(finfo->menu_text))[menusz] = '\0';
                     sprintf(token, HELP_FMT, loop + 1);
                     if ((err = msgtrans_lookup(token, &help_text, &helpsz, 0, 0, 0, 0)) != NULL) {
                       help_text = err->errmess;
                       helpsz = strlen(help_text);
                     }
                     finfo->help_text = _kernel_RMAalloc(helpsz + 1) ;
                     if (finfo->help_text != NULL) {
                       strncpy(finfo->help_text, help_text, helpsz);
                       ((char *)(finfo->help_text))[helpsz] = '\0';
                       finfo->link = NULL ; /* no next block at the moment */
                       finfo->format_SWI = DOSFS_DiscFormat ;
                       finfo->format_r0 = loop ;
                       finfo->layout_SWI = DOSFS_LayoutStructure ;
                       finfo->layout_r0 = loop ;
                       finfo->flags = EnumFormats_HasFormatParam;
                       finfo->format_desc = DOS_formats[loop].idtext;

                       /* add this description onto the end of the list */
                       *next = finfo;
                       next = &(finfo->link);
                     } else {
                       free(finfo->menu_text);
                       free(finfo);
                     }
                   } else {
                    free(finfo);
                   }
                  }
               }
               break ;

   case 0x6B : /* Service_IdentifyFormat */
               /* in:   r0 = ptr to NULL terminated ASCII format identifier
                *       r1 = Service_IdentifyFormat
                * out:  r0 = preserved
                *       r1 = Service_Serviced (NULL)
                *       r2 = SWI number to call to obtain "DOSFS_DiscFormat"
                *       r3 = r3 parameter to be used for "DOSFS_DiscFormat" SWI
                *       r4 = SWI number to call to obtain "DOSFS_LayoutStructure"
                *       r5 = r0 parameter to be used for "DOSFS_LayoutStructure" SWI
                */
               {
                int loop ;

                tracef1("DOSFS: Service_IdentifyFormat: r0 = \"%s\"\n",(char *)(rset->r[0])) ;

                /* I use my wild-card compare function since it automatically deals with
                 * case equality, where "strcmp" does not.
                 */
                for (loop = 0; (DOS_formats[loop].magic_ID != 0x00); loop++)
                 if (DOS_formats[loop].idtext != NULL)
                  if (wild_card_compare((char *)rset->r[0],DOS_formats[loop].idtext,ROwcmult,ROwcsing))
                   break ;

                if (DOS_formats[loop].magic_ID != 0x00)
                 {
                  tracef1("DOSFS: Service_IdentifyFormat: %s\n",DOS_formats[loop].idtext) ;

                  rset->r[1] = 0x00 ;                   /* Service_Serviced (claimed) */
                  rset->r[2] = DOSFS_DiscFormat ;       /* our format SWI */
                  rset->r[3] = loop ;                   /* "DOS_formats" table index */
                  rset->r[4] = DOSFS_LayoutStructure ;  /* our layout SWI */
                  rset->r[5] = loop ;                   /* "DOS_formats" table index */
                 }
               }
               break ;

   case 0x6C : /* Service_DisplayFormatHelp */
               /* in:   r0 = &00
                *       r1 = Service_HelpFormat
                * out:  NO ERROR : preserved
                *       ERROR    : r0 = pointer to error block
                *                  r1 = Service_Serviced
                *
                * This should list the formats it will respond to in
                * "Service_IdentifyFormat". The listing should be performed
                * using "OS_WriteC", "OS_Write0" or "OS_WriteS".
                */
               tracef0("DOSFS: Service_FormatHelp: called\n") ;
               {
                int               loop ;
                for (loop = 0; (DOS_formats[loop].magic_ID != 0x00); loop++)
                 if (DOS_formats[loop].idtext != NULL)
                  {
                   _kernel_swi_regs  urset ;
                   _kernel_oserror  *rerror ;
#if 1 /* SMC_FIX_RO_5593 */
                   char        *buf = 0;
                   int         bufsz = 0;
                   char        token[8];
#endif

#if 1 /* SMC_FIX_RO_5593 */
                   /* get the text from the Messages file */
                   sprintf(token, HELP_FMT, loop + 1);
                   if ((rerror = msgtrans_lookup(token, &buf, &bufsz, 0, 0, 0, 0)) != NULL) {
                    buf = rerror->errmess;
                    bufsz = strlen(rerror->errmess);
                   }
                   urset.r[0] = (word)buf;
                   urset.r[1] = bufsz;
                   rerror = _kernel_swi((XOS_Bit | OS_WriteN), &urset, &urset);
#else
                   /* nasty way of doing this, but let's get it working first */
                   /* (since printf may be re-directed, etc.) */
                   urset.r[0] = (word)DOS_formats[loop].idtext ;
                   rerror = _kernel_swi((XOS_Bit | OS_Write0),&urset,&urset) ;

                   if (rerror == NULL)
                    {
                     urset.r[0] = (word)" - " ;
                     rerror = _kernel_swi((XOS_Bit | OS_Write0),&urset,&urset) ;
                    }

                   if (rerror == NULL)
                    {
                     urset.r[0] = (word)DOS_formats[loop].description ;
                     rerror = _kernel_swi((XOS_Bit | OS_Write0),&urset,&urset) ;
                    }
#endif

                   if (rerror == NULL)
                    rerror = _kernel_swi((XOS_Bit | OS_NewLine),&urset,&urset) ;

                   if (rerror != NULL)
                    {
                     rset->r[0] = (word)rerror ; /* pointer to standard error block */
                     rset->r[1] = 0x00 ;         /* Service_Serviced */
                     return ;
                    }
                  }
               }
               break ;

   default   : /* unknown - do nothing */
               break ;
  }

 return ;
}

/*-------------------------------------------------------------------------*/

_kernel_oserror *fs_commands(char *argv,int argc,int command,void *private)
{
 _kernel_swi_regs  rset ;
 _kernel_oserror  *rerror = NULL ;

 switch (command)
  {
   case CMD_DOSMap :
             {
              int       loop ;
              word      dosext = 0x00000000 ; /* DOS extension */
              word      ROtype = 0x000 ;      /* RISC OS filetype */
              mapentry *cptr ;
              char     *tptr ;
              char *buf = NULL;
              int bufsz = 0;

              tracef0("fs_command: DOSMap\n") ;
              /* arg0 (optional) : DOS extension */
              /* arg1 (optional) : RISC OS filetype */
              /* If "arg0" is NOT present then we display the current mappings.
               * If "arg1" is NOT present the mapping for the given DOS
               * extension will be removed.
               */

              if (argc == 0) /* display current mappings if no parameters */
               {
                if ((cptr = maplist) == NULL)
                {
                 if ( (rerror = msgtrans_lookup("NOMAP", &buf, &bufsz, NULL, NULL, NULL, NULL)) != NULL )
                 {
                  buf = rerror->errmess;
                  bufsz = strlen( buf );
                 }
                 fwrite( buf, 1, bufsz, stdout );
                 putchar( '\n' );
                }
                else
                 {
                  int exttab, texttab, typetab, linelen;
                  buf = NULL;
                  if ( (rerror = msgtrans_lookup("DOSExt", &buf, &bufsz, NULL, NULL, NULL, NULL)) != NULL )
                  {
                   buf = rerror->errmess;
                   bufsz = strlen( buf );
                  }
                  fwrite( buf, 1, bufsz, stdout );
                  exttab = (bufsz-3)/2;
                  texttab = bufsz-exttab-1;
                  buf = NULL;
                  if ( (rerror = msgtrans_lookup("ROType", &buf, &bufsz, NULL, NULL, NULL, NULL)) != NULL )
                  {
                   buf = rerror->errmess;
                   bufsz = strlen( buf );
                  }
                  printf( "  " );
                  fwrite( buf, 1, bufsz, stdout );
                  putchar( '\n' );
                  if ( bufsz < 12 ) bufsz = 12;
                  typetab = bufsz-11;
                  linelen = exttab+3+texttab+bufsz;
                  for ( loop=linelen; loop--; ) putchar( '-' );
                  putchar('\n');

                  for (; (cptr != NULL); cptr = cptr->next)
                   {
                    for ( loop=exttab; loop--; ) putchar( ' ' );

                    for (loop = 0; (loop < 3); loop++)
                     {
                      char cchr = ((cptr->dosext >> (loop * 8)) & 0xFF) ;
                      putchar( (((cchr > ' ') && (cchr != 0x7F)) ? cchr : ' ') );
                     }

                    for ( loop=texttab; loop--; ) putchar( ' ' );

                    rset.r[0] = FSControl_ReadFileType ;
                    rset.r[2] = (word)cptr->ROtype ;
                    if ((rerror = _kernel_swi((XOS_Bit | OS_FSControl),&rset,&rset)) != NULL)
                     {
                      /* Just print spaces if unknown (or error returned) */
                      rset.r[2] = 0x20202020 ;
                      rset.r[3] = 0x20202020 ;
                     }

                    for (loop = 0; (loop < 4); loop++)
                     printf("%c",(char)((rset.r[2] >> (loop * 8)) & 0xFF)) ;
                    for (loop = 0; (loop < 4); loop++)
                     printf("%c",(char)((rset.r[3] >> (loop * 8)) & 0xFF)) ;

                    for ( loop=typetab; loop--; ) putchar( ' ' );
                    printf("%03X\n",cptr->ROtype) ;
                   }
                  for ( loop=linelen; loop--; ) putchar( '-' );
                  putchar( '\n' );
                 }
               }
              else
               {
                /* convert the DOS extension given to upper-case */
                for (loop=0; (argv[loop] && (argv[loop] != ' ')); loop++)
                 {
#if 1 /* SMC_FIX_RO_8015 */
                  int c = toupper(argv[loop]);
                  if (validchar(valchars,c))
                   dosext = (dosext | (c << (loop * 8))) ;
#else
                  if (validchar(valchars,argv[loop]))
                   dosext = (dosext | (toupper(argv[loop]) << (loop * 8))) ;
#endif
                  else
                   {
                    rerror = global_error(err_invalidchar) ;
                    break ; /* from the "for" loop */
                   }
                 }

                if (!rerror) /* no error defined yet */
                 {
                  if (loop > 3)
                   rerror = global_error(err_toolong) ;
                  else
                   {
                    if (argc == 1)
                     {
                      mapentry *last = maplist ;
                      /* release this mapping */
                      for (cptr = last; (cptr != NULL); cptr = last->next)
                       if (dosext == cptr->dosext)
                        {
                         tracef0("DOSMap: entry found\n") ;
                         /* release this mapping */
                         if (cptr == maplist)
                          maplist = cptr->next ;   /* new root mapping */
                         else
                          last->next = cptr->next ;/* step over this mapping */
                         free(cptr) ;              /* release this mapping */
                         break ;                   /* and exit the for loop */
                        }
                       else
                        last = cptr ;              /* remember this entry */
                     }
                    else
                     {
                      for (; (argv[loop] && (argv[loop] == ' ')); loop++) ;
                      /* convert the RISC OS filetype given to a 12bit number */
                      tptr = &argv[loop] ;
                      for (loop = 0; (tptr[loop]); loop++)
                       if (validchar("0123456789ABCDEFabcdef",tptr[loop]))
                        {
                         int cval ;
                         if (tptr[loop] > '9')
                          cval = (toupper(tptr[loop]) - ('A' - 10)) ;
                         else
                          cval = tptr[loop] ;
                         cval = cval - '0' ;
                         ROtype = (ROtype | (cval << (loop * 8))) ;
                        }
                       else
                        {
                         loop = 0 ;
                         break ;
                        }

                      if (loop == 0)
                       {
                        rset.r[0] = FSControl_FileTypeFromString ;
                        rset.r[1] = (word)tptr ;
                        if ((rerror = _kernel_swi((XOS_Bit | OS_FSControl),&rset,&rset)) == NULL)
                         ROtype = rset.r[2] ;
                       }
                      if (rerror == NULL)
                       {
                        /* check if the DOS extension exists */
                        for (cptr = maplist; (cptr != NULL); cptr = cptr->next)
                         if (dosext == cptr->dosext)
                          {
                           tracef2("DOSMap: resetting &%08X to &%03X\n",dosext,ROtype);
                           cptr->ROtype = ROtype ;   /* replace mapping */
                           break ;                   /* and exit the for loop */
                          }

                        if (cptr == NULL)
                         {
                          mapentry *newmapping ;
                          if ((newmapping = (mapentry *)malloc(sizeof(mapentry))) == NULL)
                           rerror = global_errorT(err_heapexhausted, tok_heapexhausted, 0, 0) ;
                          else
                           {
                            /* insert the mapping into the list */
                            tracef2("DOSMap: newmapping &%08X to &%03X\n",dosext,ROtype) ;
                            newmapping->next = maplist ;
                            newmapping->dosext = dosext ;
                            newmapping->ROtype = ROtype ;
                            maplist = newmapping ;
                           }
                         }
                       }
                     }
                   }
                 }
               }
             }
             break ;

   case CMD_CopyBoot :
             {
              int             loop ;
              char           *cptr ; /* used during arg processing */
              int             srcdrive = -1 ;
              int             destdrive = -1 ;
              DOS_bootsector *srcblock = NULL ;
              DOS_bootsector *destblock = NULL ;
              int             nfloppies = 0 ;

              tracef0("fs_command: CopyBoot\n") ;

              rerror = _kernel_swi((XOS_Bit | ADFS_Drives),&rset,&rset) ;
              if (rerror == NULL)
               {
                nfloppies = rset.r[1] ;

                /* arg0 : source drive */
                /* arg1 : destination drive */

                /* step upto first */
                for (; (*argv && (*argv == ' ')); argv++) ;
                cptr = strtok(argv," \t") ; /* first argument */
                if (cptr != NULL)
                 srcdrive = atoi(cptr) ;
                cptr = strtok(NULL," \t") ; /* second argument */
                if (cptr != NULL)
                 destdrive = atoi(cptr) ;

                if (((srcdrive < 0) || (srcdrive >= nfloppies)) || ((destdrive < 0) || (destdrive >= nfloppies)))
                 {
                  /* Bad drive specifier given (not a valid floppy drive) */
                  rerror = global_error(err_baddrive) ;
                 }
                else
                 {
                  tracef2("CopyBoot: src %d dest %d\n",srcdrive,destdrive) ;

                  srcblock = (DOS_bootsector *)malloc(sizeof(DOS_bootsector)) ;
                  destblock = (DOS_bootsector *)malloc(sizeof(DOS_bootsector)) ;
                  if ((srcblock == NULL) || (destblock == NULL))
                   {
                    if (srcblock != NULL)
                     free(srcblock) ;
                    rerror = global_errorT(err_heapexhausted, tok_heapexhausted, 0, 0) ;
                   }
                  else
                   {
#if 1 /* SMC_FIX */
                    char                 tmpstr[8];
#else
                    char                 tmpstr[4] ; /* temporary "short" string */
#endif
                    int                  fhand = 0 ; /* open file handle */

                    /* Load the BOOT BLOCK from the source drive */
#if 1 /* SMC_FIX */
                    sprintf(tmpstr,"adfs::%d",srcdrive) ;
#else
                    sprintf(tmpstr,":%d",srcdrive) ;
#endif
                    rset.r[0] = 0x40;
                    rset.r[1] = (int)tmpstr;
                    rset.r[2] = 0;
                    rerror = _kernel_swi(OS_Find, &rset, &rset);
                    fhand = rset.r[0];
                    if (rerror != NULL || fhand == 0)
                     {
                      tracef0("CMD_CopyBoot: failed to open source image\n") ;
                      rerror = global_errorT(err_objectnotfound,tok_objectnotfound,tmpstr,0) ;
                     }
                    else
                     {
                      /* read the BOOT BLOCK from the image */
                      rset.r[0] = 3;
                      rset.r[1] = fhand;
                      rset.r[2] = (int)srcblock;
                      rset.r[3] = sizeof(DOS_bootsector);
                      rset.r[4] = 0x00000000;
                      rerror = _kernel_swi(OS_GBPB, &rset, &rset);
                      if (rerror != NULL || rset.r[3] != 0)
                        rerror = global_error(err_readfailed) ;

                      /* close the image file */
#if 1 /* SMC_FIX */
                      rset.r[0] = 0;
                      rset.r[1] = fhand;
                      _kernel_swi(OS_Find, &rset, &rset);
#else
                      _kernel_osfind(0x40,(char *)fhand) ;
#endif

                      if (rerror == NULL)
                       {
                        int bbsize = (srcblock->BOOT_secsize | (srcblock->BOOT_secsizeHI << 8)) ;
#if 0 /* SMC_FIX */
                        for (loop = 0; (DOS_formats[loop].magic_ID != 0x00); loop++)
                         if (DOS_formats[loop].magic_ID == srcblock->BOOT_magic)
                          break ;

                        if ((DOS_formats[loop].magic_ID == 0x00) || (bbsize != DOSsecsize))
                         {
                          tracef0("CMD_CopyBoot: logical disc format not recognised\n") ;
                          rerror = global_error(err_badbootblock) ;
                         }
#endif
                        tracef1("CMD_CopyBoot: source secsize = %d\n", (srcblock->BOOT_secsizeHI << 8)
                                | srcblock->BOOT_secsize);
                        tracef1("CMD_CopyBoot: source secalloc = %d\n", srcblock->BOOT_secalloc);
                        tracef1("CMD_CopyBoot: source reserved = %d\n", (srcblock->BOOT_reservedHI << 8)
                                | srcblock->BOOT_reserved);
                        tracef1("CMD_CopyBoot: source num_fats = %d\n", srcblock->BOOT_num_fats);
                        tracef1("CMD_CopyBoot: source root size = %d\n", (srcblock->BOOT_root_dirHI << 8)
                                | srcblock->BOOT_root_dir);
                        tracef1("CMD_CopyBoot: source max_sect = %d\n", (srcblock->BOOT_max_sectHI << 8)
                                | srcblock->BOOT_max_sect);
                        tracef1("CMD_CopyBoot: source magic = &%02X\n", srcblock->BOOT_magic);
                        tracef1("CMD_CopyBoot: source FAT_size = %d\n", (srcblock->BOOT_FAT_sizeHI << 8)
                                | srcblock->BOOT_FAT_size);
                        tracef1("CMD_CopyBoot: source secstrack = %d\n", (srcblock->BOOT_secstrackHI << 8)
                                | srcblock->BOOT_secstrack);
                        tracef1("CMD_CopyBoot: source heads = %d\n", (srcblock->BOOT_headsHI << 8)
                                | srcblock->BOOT_heads);
                        tracef1("CMD_CopyBoot: source hidden = %d\n", (srcblock->BOOT_extra.floppy.hiddenHI << 8)
                                | srcblock->BOOT_extra.floppy.hidden);

                        if (rerror == NULL)
                         {
                          /* If the source drive and destination drive are the
                           * same then prompt for the disc to be changed.
                           */
                          if (srcdrive == destdrive)
                           {
                            char *buf = NULL;
                            int bufsz;
                            if ( (rerror = msgtrans_lookup("Prompt1", &buf, &bufsz, NULL, NULL, NULL, NULL)) != NULL )
                            {
                             buf = rerror->errmess;
                             bufsz = strlen( buf );
                            }
                            fwrite( buf, 1, bufsz, stdout );
                            /* We need to take account of ESCAPE here */
                            rset.r[0] = 122;
                            do
                             {
                              rerror = _kernel_swi(OS_Byte,&rset,&rset) ;
                             } while ((rerror == NULL) && (rset.r[1] != 98) && (rset.r[1] != 112)) ;
                            putchar( '\n' );
                            if (rerror != NULL)
                             rerror = global_error(err_keyboardread);
                            else if (rset.r[1] == 112) {
                             tracef0("CMD_CopyBoot: Escape\n") ;
                             _gerror.errnum = 17 ; /* NASTY CONSTANT */
                             buf = _gerror.errmess;
                             bufsz = 252;
                             if ( (rerror = msgtrans_lookup("Escape", &buf, &bufsz, NULL, NULL, NULL, NULL)) != NULL )
                             {
                              _gerror.errnum = rerror->errnum;
                              strcpy( _gerror.errmess, rerror->errmess );
                             }
                            }
                           }

                          if (rerror == NULL)
                           {
                            /* Load the BOOT BLOCK from the destination drive */
#if 1 /* SMC_FIX */
                            sprintf(tmpstr,"adfs::%d",destdrive) ;
#else
                            sprintf(tmpstr,":%d",destdrive) ;
#endif
                            rset.r[0] = 0xC0;
                            rset.r[1] = (int)tmpstr;
                            rset.r[2] = 0;
                            rerror = _kernel_swi(OS_Find, &rset, &rset);
                            fhand = rset.r[0];
                            if (rerror != NULL || fhand == 0)
                             {
                              tracef0("CMD_CopyBoot: failed to open dest image\n") ;
                              rerror = global_errorT(err_objectnotfound,tok_objectnotfound,tmpstr,0) ;
                             }
                            else
                             {
                              /* read the BOOT BLOCK from the image */
                              rset.r[0] = 3;
                              rset.r[1] = fhand;
                              rset.r[2] = (int)destblock;
                              rset.r[3] = sizeof(DOS_bootsector);
                              rset.r[4] = 0x00000000;
                              rerror = _kernel_swi(OS_GBPB, &rset, &rset);
                              if (rerror != NULL || rset.r[3] != 0)
                                rerror = global_error(err_readfailed) ;
                              else
                               {
                                bbsize = (destblock->BOOT_secsize | (destblock->BOOT_secsizeHI << 8)) ;
#if 0 /* SMC_FIX */
                                for (loop = 0; (DOS_formats[loop].magic_ID != 0x00); loop++)
                                 if (DOS_formats[loop].magic_ID == destblock->BOOT_magic)
                                  break ;

                                if ((DOS_formats[loop].magic_ID == 0x00) || (bbsize != DOSsecsize))
                                 {
                                  tracef0("CMD_CopyBoot: logical disc format not recognised\n") ;
                                  rerror = global_error(err_badbootblock) ;
                                 }
#endif
                                if (rerror == NULL)
                                 {
                                  /* Copy the 3byte JMP, OEM information and
                                   * 480bytes of boot code from the source to the
                                   * destination buffer.
                                   */
                                  for (loop = 0; (loop < 3); loop++)
                                   destblock->BOOT_JMP[loop] = srcblock->BOOT_JMP[loop] ;

                                  for (loop = 0; (loop < 8); loop++)
                                   destblock->BOOT_OEM[loop] = srcblock->BOOT_OEM[loop] ;

                                  for (loop = 0; (loop < 480); loop++)
                                   destblock->BOOT_extra.floppy.code[loop] = srcblock->BOOT_extra.floppy.code[loop] ;

                                  /* Save the BOOT BLOCK back to the destination drive */
                                  rset.r[0] = 1;
                                  rset.r[1] = fhand;
                                  rset.r[2] = (int)destblock;
                                  rset.r[3] = sizeof(DOS_bootsector);
                                  rset.r[4] = 0x00000000;
                                  if (_kernel_swi(OS_GBPB, &rset, &rset) != NULL)
                                    rerror = global_error(err_writefailed) ;
                                 }
                               }
                              /* close the image file */
#if 1 /* SMC_FIX */
                              rset.r[0] = 0;
                              rset.r[1] = fhand;
                              _kernel_swi(OS_Find, &rset, &rset);
#else
                              _kernel_osfind(0x40,(char *)fhand) ;
#endif
                             }
                           }
                         }
                       }
                     }
                    free(srcblock) ;
                    free(destblock) ;
                   }
                 }
               }
             }
             break ;

   default : /* unknown */
             break ;
  }

 return(rerror) ;
 UNUSED(argv) ;
 UNUSED(argc) ;
 UNUSED(private) ;
}

/*-------------------------------------------------------------------------*/

static void shutdown_fs(void)
{
 _kernel_swi_regs rset ;
 mapentry *cptr ;

 tracef0("DOSFS: shutdown_fs called\n") ;

 /* JRS 26/3/92: free all DOS name mappings */
 while (maplist != NULL)
   {
   cptr = maplist;
   maplist = maplist->next;
   free(cptr) ;
   }

 /* OS_FSControl 36 with image type */
 rset.r[0] = 36 ;               /* reason code "FSControl_RemoveImage"  */
 rset.r[1] = (word)imagetype ;  /* image type we provide support for */

 /* ignore any errors */
 (void)_kernel_swi(OS_FSControl,&rset,&rset) ;

#if 1 /* SMC_FIX_RO_5593 */
 /* Close Messages file. */
 msgtrans_closefile();
#endif

 show_mem_trace();
 trace_off();
 return ;
}

/*-------------------------------------------------------------------------*/

_kernel_oserror *init_fs(char *cmd_tail,int podule_base,void *private)
{
 _kernel_oserror  *syserr ;
 _kernel_swi_regs r;

 tracef0("DOSFS: init_fs: entered\n") ;

 _syserr = &_gerror ;              /* reference the static global error area */

 if ((syserr = declare_FS(private)) != NULL)
  tracef2("DOSFS: init_fs: &%08X \"%s\"\n",syserr->errnum,syserr->errmess) ;

 if (atexit(shutdown_fs) != 0)
  tracef0("DOSFS: init_fs: failed to add shutdown function\n") ;

 r.r[0] = (int)"File$Type_FC8";
 r.r[1] = (int)"DOSDisc";
 r.r[2] = 7;
 r.r[3] = 0;
 r.r[4] = 0;
 /* Ignore error here, if setting the variable fails then "fc8" will be used. */
 (void)_kernel_swi(OS_SetVarVal, &r, &r);

 r.r[0] = (int)"File$Type_FE4";
 r.r[1] = (int)"DOS";
 r.r[2] = 3;
 r.r[3] = 0;
 r.r[4] = 0;
 /* Ignore error here, if setting the variable fails then "fc4" will be used. */
 (void)_kernel_swi(OS_SetVarVal, &r, &r);

 tracef0("DOSFS: init_fs: exiting\n") ;
 return(0) ;
 UNUSED(podule_base) ;
 UNUSED(cmd_tail) ;
}

/*-------------------------------------------------------------------------*/
/*> EOF c.DOSFS <*/
