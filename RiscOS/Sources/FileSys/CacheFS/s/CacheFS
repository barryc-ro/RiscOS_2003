; > s.CacheFS

; *********************************
; ***    C h a n g e   L i s t  ***
; *********************************

; Date       Description
; ----       -----------
; 19-Apr-96     0.16    File created
; 14-May-96     0.17    Alpha release
; 16-May-96     0.18    Use Area_Shrinkable for flags, not zero!
; 16-May-96     0.19    Fix internal file handler pointer relocation
; 16-May-96     0.20    Implement *CacheFS_SetSize and *CacheFS_SetMax commands
; 08-Jan-97     0.23    RML: Added flag MAKERAMFS and associated code to make a RamFS instead of a CacheFS

Module_BaseAddr

        GET     s.Declare

        LEADR   Module_LoadAddr

        ASSERT  (.-Module_BaseAddr) = 0

        DCD     0                    ; CacheFS_Start    - Module_BaseAddr
        DCD     CacheFS_Init     - Module_BaseAddr
        DCD     CacheFS_Die      - Module_BaseAddr
        DCD     CacheFS_Service  - Module_BaseAddr
        DCD     CacheFS_Title    - Module_BaseAddr
        DCD     CacheFS_HelpStr  - Module_BaseAddr
        DCD     CacheFS_HC_Table - Module_BaseAddr
        DCD     0                    ; MySWIBase
        DCD     0                    ; CacheFS_SWIdecode- Module_BaseAddr
        DCD     0                    ; CacheFS_SWInames - Module_BaseAddr
        DCD     0
 [ International_Help <> 0
        DCD     message_filename - Module_BaseAddr
 |
        DCD     0
 ]

CacheFS_Title
      [ MAKERAMFS
        DCB     "RamFS", 0
      |
        DCB     "CacheFS", 0
      ]

CacheFS_HelpStr
      [ MAKERAMFS
        DCB     "RamFS", TAB, TAB, "$VString ($Date)"
      |
        DCB     "CacheFS", TAB, TAB, "$VString ($Date)"
      ]

      [ DEBUGVERSION
        DCB     " - debugging version"
      ]
        DCB     0
        ALIGN

CacheFS_HC_Table
    [ MAKERAMFS
        Command Ram,           0, 0, International_Help
        Command RamFS_SetMax,  1, 1, International_Help
    |
        Command CacheFS,         0, 0, International_Help
        Command CacheFS_SetSize, 1, 1, International_Help
        Command CacheFS_SetMax,  1, 1, International_Help
      [ RELOADCACHE
        Command LoadCache, 1, 1, International_Help
        Command SaveCache, 1, 1, International_Help
      ]
    ]
        DCD     0

 [ MAKERAMFS
Ram_Help      Internat_lf  "HCHCFS",   "*Ram selects the Ram filing system"
Ram_Syntax    Internat     "SCHCFS",   "*Ram"
 |
CacheFS_Help      Internat_lf  "HCHCFS",   "*CacheFS selects the Cache filing system"
CacheFS_Syntax    Internat     "SCHCFS",   "*CacheFS"
 ]

CacheFS_SetSize_Help      Internat_lf  "HCHCFSS",   "*CacheFS_SetSize sets the size of the CacheFS area"
CacheFS_SetSize_Syntax    Internat     "SCHCFSS",   "*CacheFS_SetSize <size>k"

 [ MAKERAMFS
RamFS_SetMax_Help       Internat_lf  "HCHCFSM",   "*RamFS_SetMax sets the maximum size of the RamFS area"
RamFS_SetMax_Syntax     Internat     "SCHCFSM",   "*RamFS_SetMax <size>k"
 |
CacheFS_SetMax_Help       Internat_lf  "HCHCFSM",   "*CacheFS_SetMax sets the maximum size of the CacheFS area"
CacheFS_SetMax_Syntax     Internat     "SCHCFSM",   "*CacheFS_SetMax <size>k"
 ]

      [ RELOADCACHE
LoadCache_Help    Internat_lf  "HCHCLOAD", "*LoadCache loads a previously-saved set of CacheFS files"
LoadCache_Syntax  Internat     "SCHCLOAD", "*LoadCache <inputfile>"

SaveCache_Help    Internat_lf  "HCHCSAVE", "*SaveCache saves the current set of CacheFS files to a single output file"
SaveCache_Syntax  Internat     "SCHCSAVE", "*SaveCache <outputfile>"
      ]

        ALIGN

; *****************************************************************************

 [ MAKERAMFS
StringROM       =       "RAM",0
StringCacheFS   =       "Acorn RamFS",0
 |
StringROM       =       "Cache",0                         ; FS name is "Cache:"
StringCacheFS   =       "Acorn CacheFS",0
 ]
                ALIGN

FSInfoBlock     DCD     StringROM       - Module_BaseAddr ; filing system prefix
                DCD     StringCacheFS   - Module_BaseAddr ; filing system title
                DCD     CacheFS_Open    - Module_BaseAddr ; open files
                DCD     CacheFS_GetByte - Module_BaseAddr ; get byte
                DCD     CacheFS_PutByte - Module_BaseAddr ; put byte
                DCD     CacheFS_Args    - Module_BaseAddr ; OSARGS
                DCD     CacheFS_Close   - Module_BaseAddr ; close files
                DCD     CacheFS_OSFile  - Module_BaseAddr ; osfile etc
fsinfoword      DCD     fsnumber_cachefs :SHL: fsinfo_number_shift
                DCD     CacheFS_FSFunc  - Module_BaseAddr ; fs func
                DCD     CacheFS_GBPB    - Module_BaseAddr ; get/put bytes

; *****************************************************************************
;
;       CacheFS_Init - Initialisation entry
;

CacheFS_Init ENTRY "R4-R8"

        LDR     R2, [R12]               ; have we got workspace yet ?
        TEQ     R2, #0
        BNE     %FT05

        MOV     R0, #ModHandReason_Claim
        MOV     R3, #CacheFS_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

        STR     R2, [R12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05      MOV     R12, R2

        MOVVC   R14,#0
        STRVC   R14,CacheFSAreaNumber
        STRVC   R14,CacheFSFileData
        STRVC   R14,CacheFSRoot
        STRVC   R14,CacheFSRootLock
        STRVC   R14,CacheFSFileSize
        STRVC   R14,CacheFSAreaSize
        STRVC   R14,CacheFSMaxSize
        STRVC   R14,CacheFSHandles
        STRVC   R14,CacheFSFreeNext
        STRVC   R14,CacheFSEnums
        STRVC   R14,CacheFSNextID
      [ USEMESSAGES
        STRVC   R14, MessageFile_Open
      ]

        ADRVC   R14,CacheFSHead         ; set LRU chain to null
        STRVC   R14,CacheFSNext
        STRVC   R14,CacheFSPrevious

; For now, just create our own dynamic area

        MOV     R0,#0                   ; reason code 0 (create)

 [ USEAREAFIVE
        MOV     R1, #5
 |
        MOV     R1,#-1                  ; dynamic area number (-1 => allocate)
 ]
        MOV     R2,#0                   ; initial size
        MOV     R3,#-1                  ; base logical address
        MOV     R4,#AreaFlags_Shrinkable
        MOV     R5,#LIMITAREASIZE       ; maximum size
        Adr     R6,myareahandler        ; handler code for growing/shrinking
        MOV     R7,R12                  ; R12 for handler
        ADR     R8,str_areaname         ; name of area
        SWI     XOS_DynamicArea
        STRVC   R1,CacheFSAreaNumber

        MOVVC   R0,R1
        SWIVC   XOS_ReadDynamicArea
        STRVC   R0,CacheFSFileData
        STRVC   R1,CacheFSAreaSize

        BLVC    CacheFS_Declare         ; call FileSwitch

        EXIT

 [ MAKERAMFS
str_areaname    DCB     "RamFS RAM disc", 0
 |
str_areaname    DCB     "CacheFS RAM disc", 0
 ]
                ALIGN

;..............................................................................

; Declare CacheFS: to FileSwitch (called on Init and Service_FSRedeclare)

CacheFS_Declare ENTRY "R1-R3"

        MOV     R0, #FSControl_AddFS    ; add this filing system
        ADR     R1, Module_BaseAddr
        MOV     R2, #FSInfoBlock-Module_BaseAddr
        MOV     R3, R12
        Trace   "OS_FSControl (AddFS)",X,R0,X,R1,X,R2,X,R3
        SWI     XOS_FSControl

        EXIT

; *****************************************************************************
;
;       CacheFS_Die - Die entry
;
; Deallocate link blocks, issue FSControl_RemoveFS

CacheFS_Die ENTRY

        LDR     R12, [R12]              ; R12 -> workspace

        TEQ     R12, #0
        LDRNE   R2, CacheFSFileData
        TEQNE   R2, #0
        LDRNE   R14, CacheFSFileSize
        TEQNE   R14, #0
        MOVNE   R0, #upfsfile_Delete    ; tell the Filer
        BLNE    modifyingfiles          ; (preserves flags)

        MOV     R0, #FSControl_RemoveFS
        addr    R1, StringROM
        SWI     XOS_FSControl           ; this will close any open files

      [ USEMESSAGES
        CMP     R12,#0
        LDRNE   r0, MessageFile_Open
        CMPNE   r0, #0
        ADRNE   r0, MessageFile_Block
        SWINE   XMessageTrans_CloseFile
      ]

        TEQ     R12, #0
        EXITS   EQ

      [ TRACE
        LDR     R14, CacheFSHandles
        TEQ     R14, #0
        TraceIf NE, "*** BARF: FileSwitch hasn't closed all the files"
      ]

        MOV     R14, #0                 ; allow easy module death!
        STR     R14, CacheFSHandles
        STR     R14, CacheFSFreeNext
        STR     R14, CacheFSFileSize

        ADR     R14, CacheFSHead
        STR     R14, CacheFSNext
        STR     R14, CacheFSPrevious

        ; Delete any remaining emumeration block pointers

        LDR     R1, CacheFSEnums
        B       %FT15

10      LDR     R3, [R1, #CacheEnum_Link]

11      MOV     R2, R1
        LDR     R1, [R2, #CacheEnum_Next]
        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module
        TraceIf VS, "*** BARF: error while freeing enumeration block",X,R2

        CMP     R1, #0
        BNE     %BT11

        MOV     R1, R3

15      CMP     R1, #0
        BNE     %BT10

        MOV     R14, #0
        STR     R14, CacheFSEnums

        ; Finally delete the dynamic area

        LDR     R1,CacheFSAreaNumber
        CMP     R1,#0                   ; clears V
        MOV     R0,#1                   ; remove dynamic area
        SWI     XOS_DynamicArea

        EXITS                           ; return V clear

; *****************************************************************************
;
;       CacheFS_Code - Process *CacheFS command
;
; in:   R0 -> rest of line
;       R1 = number of parameters
;       R12 -> private word
;
; out:  R0-R6, R12 corrupted
;
 [ MAKERAMFS
Ram_Code ENTRY
 |
CacheFS_Code ENTRY
 ]
        MOV     R0, #FSControl_SelectFS
        addr    R1, StringROM           ; ADR or ADRL as appropriate
        SWI     XOS_FSControl           ; select filing system

        EXIT

; *****************************************************************************
;
;       CacheFS_SetSize_Code - Process *CacheFS_SetSize command
;
; in:   R0 -> rest of line
;       R1 = number of parameters
;       R12 -> private word
;
; out:  R0-R6, R12 corrupted
;

CacheFS_SetSize_Code ENTRY

        LDR     R12, [R12]                      ; R12 -> workspace

        MOV     R1, R0
        BL      readsize_in_k                   ; R2 = current size to set
        EXIT    VS

        LDR     R0, CacheFSAreaNumber
        LDR     R14, CacheFSAreaSize
        SUB     R1, R2, R14                     ; R1 = required change in area size
        SWI     XOS_ChangeDynamicArea           ; this could return an error, if there's not enough memory

        EXIT

; *****************************************************************************
;
;       CacheFS_SetSize_Code - Process *CacheFS_SetSize command
;
; in:   R0 -> rest of line
;       R1 = number of parameters
;       R12 -> private word
;
; out:  R0-R6, R12 corrupted
;

 [ MAKERAMFS
RamFS_SetMax_Code ENTRY
 |
CacheFS_SetMax_Code ENTRY
 ]

        LDR     R12, [R12]                      ; R12 -> workspace

        MOV     R1, R0
        BL      readsize_in_k                   ; R2 = max size to set
        STRVC   R2, CacheFSMaxSize              ; 0 => unlimited (just grows as required)

        EXIT

; .............................................................................

; In    R1 -> textual parameter ( hopefully <number>k )
; Out   R1 -> end of parameter
;       R2 = value read (multiplied by 1024)
;       VS => R0 -> error
;       VC => R0 corrupt

readsize_in_k  ENTRY

        MOV     R0, #10

01      LDRB    R14, [R1]
        CMP     R14, #' '
        ADDEQ   R1, R1, #1
        BEQ     %BT01

        SWI     XOS_ReadUnsigned
        EXIT    VS

        LDRB    R14, [R1], #1
        CMP     R14, #'K'
        CMPNE   R14, #'k'
        BNE     %FT90

        MOV     R2, R2, LSL #10                         ; convert to 'k'

        LDRB    R14, [R1]
        CMP     R14, #' '
        EXIT    LE

90      ADR     R0, ErrorBlock_BadParameters
        SetTheError

        EXIT

        MakeErrorBlock BadParameters

; *****************************************************************************
;
;       LoadCache_Code - Process *LoadCache command
;
; in:   R0 -> rest of line
;       R1 = number of parameters
;
; out:  R0-R6, R12 corrupted
;

      [ RELOADCACHE

LoadCache_Code ENTRY

        MOV     R1, R0
        MOV     R0, #OSFind_ReadFile
        SWI     XOS_Find
        EXIT    VS

        LDR     R5, CacheFSFileData
        LDR     R6, CacheFSAreaNumber

        MOV     R1, R0
        MOV     R0, #OSGBPB_ReadFromPTR
        MOV     R2, R12
        MOV     R3, #CacheFS_LoadSize
        SWI     XOS_GBPB
        BVS     %FT90

        LDR     R2, CacheFSFileData
        TEQ     R2, R5
        BNE     %FT95           ; address has changed

        STR     R6, CacheFSAreaNumber

 xxx ; TODO: finish this lot off (if it's still wanted)

        LDR     R0, CacheFSAreaNumber
        SWI     XOS_ChangeDynamicArea
        EXIT    VS

        LDR     R3, CacheFSFileSize
        MOV     R0, #OSGBPB_ReadFromPTR
        SWI     XOS_GBPB

90      MOV     R4, R0
        MOV     R5, PC
        MOV     R0, #0
        SWI     XOS_Find
        MOVVC   R0, R4
        TEQVCP  R5, #0

        EXIT

; *****************************************************************************
;
;       SaveCache_Code - Process *SaveCache command
;
; in:   R0 -> rest of line
;       R1 = number of parameters
;
; out:  R0-R6, R12 corrupted
;

SaveCache_Code ENTRY


        EXIT
      ]

; *****************************************************************************

; Returns a "Cache: does not support this operation" error
; Out:  r0 -> error block, V set

NotSupportedError
        STMDB   sp!, {lr}
        ADR     r0, ErrorBlock_CacheFS_NotSupported
        Adr     r1, StringROM
        SetTheError
        LDMIA   sp!, {lr}
        ORRS    pc, lr, #V_bit

        MakeInternatErrorBlock CacheFS_NotSupported,,BadFSOp

; *****************************************************************************
;
; modifyingfiles - tell the Filer that files are being created / deleted
;
; In    R0 = reason code to pass in R9 to upcall
; Out   UpCall_ModifyingFile called for ""
;       This causes all directories to be re-scanned!
;       It may be hard to work out which directories are being created / deleted

modifyingfiles ENTRY "R1"

        ADR     R1, null                ; R1 -> filename ("") - R2-R5 corrupt
        BL      modifyingfile

        EXIT

null    DCB     0
        ALIGN

; .............................................................................

; In    R0 = reason code to pass in R9 to upcall
;       R1 -> filename being modified
; Out   UpCall_ModifyingFile called for [R1..]

modifyingfile ENTRY "R0-R10"

        LDR     R8, fsinfoword          ; R8 = fs info word
        MOV     R9, R0                  ; R9 = reason code
        ADR     R1, null                ; R1 -> filename ("") - R2-R5 corrupt
        MOV     R6, #0                  ; no special field
        MOV     R0, #UpCall_ModifyingFile
        SWI     XOS_UpCall              ; ignore errors

        EXITS

; *****************************************************************************
;
;       CacheFS_Service - Main entry point for services
;
; in:   R1 = service reason code
;       R2 = sub reason code
;       R3-R5 parameters
;
; out:  R1 = 0 if we claimed it
;       R2 preserved
;       R3-R5 = ???
;

CacheFS_Service ROUT
        TEQ     R1, #Service_FSRedeclare        ; has someone reinited Stu ?
        MOVNE   PC, LR                          ; no, then exit

        LDR     R12, [R12]

svc_fsredeclare ENTRY   "R0-R3"

        BL      CacheFS_Declare                   ; else redeclare myself

        EXITS

; *****************************************************************************
;
; Dynamic area handler - trap PreShrink and free up space in area
;
; In    R0 = reason code (2 for PreShrink)
;       R3 = amount area is shrinking by
;       R4 = current size of area
;       R5 = page size
;       R12 = workspace pointer

myareahandler   ENTRY "R0,R9"

        Trace   "Area handler called with",D,R0

        CMP     R0, #dyn_PreShrink
        BNE     %FT01

; Area is to be shrunk - fold up our stuff out of the way
; NOTE: The amount shrunk must agree with the value returned by TestShrink

      [ TRACE
        LDR     R14, CacheFSAreaSize
        TEQ     R4, R14
        TraceIf NE, "*** Wrong area size passed in!!!",X,R4,S,"but should be",X,R14
      ]

        ; We must rearrange the data to free up the right amount of space

        SUB     R0, R4, R3              ; R0 = desired new file size

        Trace   "Reduce filesize down to",X,R0

        BL      shrinkcache             ; shrinks as far as possible

        LDR     R0, CacheFSFileSize
        Trace   "Filesize",X,R0,S,"AreaSize",X,R4,S,"want shrink",X,R3

        SUB     R0, R4, R0              ; max shrinkable

        CMP     R3, R0
        MOVHI   R3, R0                  ; R3 = amount we can shrink by

10      SUB     R14, R5, #1
        BIC     R3, R3, R14             ; round down to page size (in case caller doesn't do it)

        Trace   "Can shrink by",X,R3

        EXITS

01      CMP     R0, #dyn_TestShrink
        BEQ     %FT02

        CMP     R0, #dyn_PostGrow
        CMPNE   R0, #dyn_PostShrink
        STREQ   R4, CacheFSAreaSize

      [ TRACE
        Trace   "New area size =",X,R4
        LDR     R14, CacheFSFileSize
        CMP     R4, R14
        TraceIf LO, "*** New area size < file data size !!!",X,R4,X,R14
      ]

        EXITS

; Work out how much the area could shrink by

02      BL      TestShrink              ; R3 = amount we can shrink by
        B       %BT10                   ; round down to page size

; *****************************************************************************
;
; In    R2 = desired space at end of file area
; Out   "Out of memory" error if can't be done

ensurecache     ENTRY  "R1,R3-R5"

        Trace   "ensurecache",X,R2

        VerifyAll

        LDR     R4, CacheFSAreaSize
        LDR     R3, CacheFSFileSize
        SUB     R14, R4, R3                     ; current amount of free space
        SUBS    R5, R2, R14                     ; R5 = extra memory required
        EXITS   LS                              ; enough memory already

        Trace   "Extra memory needed",X,R5

        MOV     R0, #6
        Push    "R2"
        SWI     XOS_ReadDynamicArea             ; out: R1 = size of free pool
        Pull    "R2"
        EXIT    VS

      [ LIMITAREASIZE <> -1
        RSBS    R14, R4, #LIMITAREASIZE         ; limit CacheFS size (for testing)
        MOVLT   R14, #0
      |
        LDR     R14, CacheFSMaxSize
        CMP     R14, #0
        MOVEQ   R14, R1                         ; don't grow area beyond the maximum size
        RSBNES  R14, R4, R14
        MOVLT   R14, #0
      ]

        CMP     R1, R14
        MOVHI   R1, R14                         ; pretend there's only this much free

        CMP     R1, R5
        MOVHI   R1, R5                          ; R1 = amount of extra memory to claim

        Trace   "Growing CacheFS area by",X,R1

        CMP     R1, #0
        LDRGT   R0, CacheFSAreaNumber
        SWIGT   XOS_ChangeDynamicArea
        EXIT    VS

        LDR     R14, CacheFSAreaSize
        SUBS    R0, R14, R2                     ; R0 = amount to shrink files down to
        BLO     %FT90                           ; give up if negative

        BL      shrinkcache                     ; get rid of files till there's enough space
        EXIT    VS

        VerifyAll

        LDR     R14, CacheFSAreaSize
        LDR     R3, CacheFSFileSize
        SUB     R14, R14, R3                    ; current amount of free space
        CMP     R2, R14
        EXITS   LS                              ; enough memory already

90      ADR     R0, ErrorBlock_CacheFS_NoRoom
        SetTheError
        EXIT

        MakeErrorBlock CacheFS_NoRoom

; *****************************************************************************
;
; In    R1 -> file header of relevant file
; Out   Spare space at end of file reclaimed

shrinkfile    ENTRY  "R2-R3"

        Trace   "shrinkfile",X,R1

        Verify

        LDR     R2, [R1, #CacheFile_Offset]
        LDR     R3, [R1, #CacheFile_Size]
        ADD     R3, R3, #3
        BIC     R3, R3, #3                      ; round up to whole number of words

        LDR     R14, [R1, #CacheFile_Data]
        SUB     R2, R2, R14                     ; R2 = space currently allocated
        SUB     R2, R2, R3                      ; R2 = amount to shrink by

        CMP     R2, #8                          ; can't remove less than 8 bytes
        EXITS   LT

        LDR     R4, CacheFSRoot
        EORS    R4, R1, R4                      ; R4=0 => this is the root object
        STRNE   R1, RelocateHandle

        ADD     R1, R1, R14
        ADD     R1, R1, R3                      ; R1 -> end of file data

        BL      removespace

        CMP     R4, #0
        LDREQ   R1, CacheFSRoot
        LDRNE   R1, RelocateHandle

        LDR     R14, [R1, #CacheFile_Offset]
        SUB     R14, R14, R2                    ; correct free space indicator
        STR     R14, [R1, #CacheFile_Offset]

        Verify

        EXITS

; *****************************************************************************
;
; In    R1 -> start of memory to be deleted
;       R2 = number of bytes to remove
; Out   Data relocated to delete the indicated area of memory
; NOTE: It is not possible to remove less than 8 bytes, since we need to indicate the link and size of each area.

removespace   ENTRY

        Trace   "removespace",X,R1,X,R2

        MOV     R14, #0
        STMIA   R1, {R2, R14}                   ; store (size, link) in block
        STR     R1, CacheFSFreeNext             ; it's the only one in the chain

        BL      compactcache                    ; compact down the memory

        EXIT

; *****************************************************************************
;
; Out   R3 = amount cache could shrink by, if required
;       Basically we count the size of all the deletable files,
;       plus the spare space in the root object, if any.

TestShrink      ENTRY  "R1,R2,R4"

        LDR     R1, CacheFSFileData             ; R1 -> start of file objects
        LDR     R2, CacheFSFileSize             ; R2 = current size

        LDR     R3, CacheFSAreaSize
        SUB     R3, R3, R2                      ; R3 = amount shrinkable so far
        MOV     R4, #-4                         ; R4 = space required in root object

        ADD     R2, R1, R2                      ; R2 -> end of file objects

        CMP     R1, R2                          ; no files => nothing to delete
        EXITS   HS

01      LDR     R14, [R1, #CacheFile_Attr]
        TST     R14, #locked_attribute

        [ MAKERAMFS
        TST     r14, r14
        ]

        LDREQ   R14, [R1, #CacheFile_Count]
        TEQEQ   R14, #0

        LDR     R14, [R1, #CacheFile_Offset]

        ADDEQ   R3, R3, R14                     ; add size of deletable object
        ADDNE   R4, R4, #4                      ; add size of non-deletable file pointer

        ADD     R1, R1, R14                     ; move on to next object
        CMP     R1, R2
        BLO     %BT01

        ; Now see what happens to the root object (if there is one)

        LDR     R1, CacheFSRoot
        CMP     R1, #0
        EXITS   EQ                              ; no root object

        LDR     R14, CacheFSRootLock
        CMP     R14, #0
        EXITS   GT                              ; root is locked - don't mess with it

        LDR     R2, [R1, #CacheFile_Offset]
        CMP     R4, #0
        TraceIf EQ, "TestShrink: can remove root object"
        ADDEQ   R3, R3, R2                      ; we can delete this too, if it's the only remaining object
        EXITS   EQ

        LDR     R14, [R1, #CacheFile_Data]
        SUB     R2, R2, R14                     ; R2 = space available for data
        SUB     R14, R2, R4                     ; R14 = spare space
        CMP     R14, #ROOTSPACE
        TraceIf HS, "TestShrink: root can free",X,R14
        ADDHS   R3, R3, R14                     ; can remove this too

        EXITS

; *****************************************************************************
;
; In    R0 = desired new max space used for files
; Out   files deleted as required to make room (not necessarily enough)
; Also check that we get rid of the correct amount,
; ie. somewhere between the amount asked for and the maximum amount shrinkable

      [ TRACE

shrinkcache     ENTRY   "R2-R4"

    ;    LDR     R14, CacheFSFileSize
    ;    CMP     R0, R14                 ; nothing to free up
    ;    EXITS   HS

        BL      TestShrink              ; R3 = max amount shrinkable

        LDR     R4, CacheFSAreaSize
        SUB     R4, R4, R0              ; R4 = amount we are being asked to shrink by

        BL      shrinkcache2            ; on exit CacheFSFileSize = new size

        LDR     R2, CacheFSAreaSize
        LDR     R14, CacheFSFileSize
        SUB     R2, R2, R14             ; R2 = amount we actually shrank by

        CMP     R4, R3
        MOVGT   R4, R3                  ; R4 = min amount to shrink by

        CMP     R2, R3                  ; we mustn't free more than is freeable
        CMPLE   R4, R2                  ; or less than we were asked (if it was possible)
        TraceIf GT,"*** BARF: shrinkcache got it wrong: actual/min/max",X,R2,X,R4,X,R3
        ADRGT   R0, %FT01
        SETV    GT
        EXIT    VS

        EXITS

01
        DCD     1
        DCB     "shrinkcache error", 0
        ALIGN

; .............................................................................
;
; In    R0 = desired new max space used for files
; Out   files deleted as required to make room (not necessarily enough)

shrinkcache2    ENTRY "R1-R3,R7-R9"
      |
shrinkcache     ENTRY "R1-R3,R7-R9"
      ]

        VerifyAll

        LDR     R14, CacheFSFileSize

        Trace  "shrinkcache: from",X,R14,S,"to at most",X,R0

        SUBS    R7, R14, R0                     ; R7 = amount of memory we must free up
        EXITS   LS

        STrace  "---- need to delete some files",X,R7

        MOV     R9, #0                          ; backlink in LRU order
        ADR     R8, CacheFSHead
        MOV     R1, R8
        B       %FT20

; Remove next file from LRU chain

01      ADD     R14, R1, #CacheFile_Next
        LDMIA   R14, {R2, R3}                   ; R2 = next, R3 = previous
        STR     R3, [R2, #CacheFile_Previous]
        STR     R2, [R3, #CacheFile_Next]       ; remove from chain

; Scan free block chain till we find the highest one that's lower than us

55      ADR     R2, CacheFSFreeNext
        B       %FT03

02      CMP     R3, R1
        BHI     %FT04
        ADD     R2, R3, #4                      ; R2 -> anchor pointer

03      LDR     R3, [R2]
        TEQ     R3, #0
        BNE     %BT02

; TODO: Try to stick this one on the end of the previous block
;       Also try to stick the next block on the end of this one
;       In either case, we need to detach the block and restart the process

04
        ASSERT  CacheFile_Data = 4
        LDR     R14, [R1, #CacheFile_Data]      ; bodge - keep this, so we can get it back later
        STR     R14, [R1, #CacheFile_Previous]
        STR     R3, [R1, #4]                    ; link in to free chain
        STR     R1, [R2]
        STR     R2, [R1, #CacheFile_Count]      ; backlink in free chain (for removing blocks later)
        TEQ     R3, #0
        ADDNE   R14, R1, #4
        STRNE   R14, [R3, #CacheFile_Count]     ; don't forget the next one's backlink!

        STR     R9, [R1, #CacheFile_WriteCount] ; backlink in LRU order (ditto)
        MOV     R9, R1

        STrace  "shrinkcache: new free block at",X,R1,S,"anchor",X,R2,S,"next",X,R3

        MOV     R0, #upfsfile_Delete
        ADD     R1, R1, #CacheFile_Name
        BL      modifyingfile                   ; file has gone!
        SUB     R1, R1, #CacheFile_Name

        LDR     R14, [R1, #CacheFile_Offset]
        SUBS    R7, R7, R14
        Trace   "Freed",X,R14,S,": to go",X,R7
        BLS     %FT25                           ; have we freed enough?

; Try to find next victim to free (next on LRU chain that isn't marked non-deleteable)

20      LDR     R1, [R1, #CacheFile_Next]
22      TEQ     R1, R8
        BEQ     %FT30
        LDR     R14, [R1, #CacheFile_Count]     ; don't delete open files,
        CMP     R14, #0
        LDREQ   R14, [R1, #CacheFile_Attr]
        TSTEQ   R14, #locked_attribute          ; or locked ones

        [ MAKERAMFS
        TST     r14, r14
        ]

        BEQ     %BT01
        LDR     R1, [R1, #CacheFile_Next]
        B       %BT22

; We've freed enough (or more than enough) to satisfy the shrinkage request.
; If more than enough, we try to reinstate all the files, starting with the last one freed.
; We can assume here that R9 <> 0, since we only get here if we deleted enough files to satisfy the requirements.

25      LDR     R14, [R9, #CacheFile_Offset]
        STrace  "Attempt to reinstate block",X,R9,S,"of size",X,R14,S,"R7 =",X,R7
        CMN     R7, R14
        LDRGT   R9, [R9, #CacheFile_WriteCount]
        BGT     %FT27                           ; too much freed - try next one

        ADD     R7, R7, R14
        LDR     R2, [R9, #CacheFile_Count]      ; R2 = backlink in free chain

        LDR     R3, [R9, #4]
        STR     R3, [R2]                       ; remove from free chain
        TEQ     R3, #0
        STRNE   R2, [R3, #CacheFile_Count]     ; don't forget the next one's backlink!

        STrace  "Reinstated",X,R14,S,": now",X,R7,S,": anchor/next",X,R2,X,R3

        LDR     R14, [R9, #CacheFile_Previous]
        STR     R14, [R9, #CacheFile_Data]      ; put back correct data offset

        MOV     R1, R9
        LDR     R9, [R9, #CacheFile_WriteCount] ; link to next one in LRU chain

        MOV     R14, #0
        STR     R14, [R1, #CacheFile_Count]
        STR     R14, [R1, #CacheFile_WriteCount]

        ADR     R2, CacheFSHead                 ; put at LRU head (NOT the tail)
        LDR     R3, CacheFSNext
        STR     R1, [R2, #CacheFile_Next]
        STR     R1, [R3, #CacheFile_Previous]
        STR     R2, [R1, #CacheFile_Previous]
        STR     R3, [R1, #CacheFile_Next]

      [ STRACE
        ADD     R14, R1, #CacheFile_Name
        STrace  "File reinstated:",C,R14
      ]

27      CMP     R9, #0
        BNE     %BT25

30      BL      compactcache
        BLVC    compactRoot                     ; shrink the root object if too much wasted

        EXIT

; *****************************************************************************

; In    R1 -> file header
; Out   block moved to the end of the LRU chain (if it was on it)

markused  ENTRY  "R2,R3"

        Trace   "markused",X,R1

        ADD     R14, R1, #CacheFile_Next
        LDMIA   R14, {R2, R3}                   ; R2 = next, R3 = previous
        TEQ     R2, #0
        EXITS   EQ                              ; don't do anything if not on chain

        STR     R3, [R2, #CacheFile_Previous]
        STR     R2, [R3, #CacheFile_Next]       ; remove from chain

        ADR     R2, CacheFSHead
        LDR     R3, CacheFSPrevious

        STMIA   R14, {R2, R3}
        STR     R1, [R3, #CacheFile_Next]
        STR     R1, [R2, #CacheFile_Previous]

        EXITS

; *****************************************************************************

; In    R1 -> file header
; Out   block removed from LRU chain (if it was on it)

removeLRU   ENTRY  "R5,R6"

        Trace   "removeLRU",X,R1

        ADD     R14, R1, #CacheFile_Next
        LDMIA   R14, {R5, R6}                   ; R5 = next, R6 = previous
        TEQ     R5, #0
        STRNE   R6, [R5, #CacheFile_Previous]
        STRNE   R5, [R6, #CacheFile_Next]       ; remove from chain
        MOVNE   R14, #0
        STRNE   R14, [R1, #CacheFile_Next]      ; 'next'==0 => not on chain

        EXITS

; *****************************************************************************

; Allocate at least the given buffer size to a file
; Called from OSArgs_EnsureSize, OSFile_Create, and CacheFS_PutByte
;
; In:   R1 -> file header
;       R2 = new extent to ensure
; Out:  R2 = extent actually ensured
;       Error if memory can't be obtained
;
; This one's a bit awkward, as it may need to relocate data upwards.

ensuresize ENTRY "r0,r2-r6"

        Trace   "ensuresize: file",X,R1,S,"size",X,R2

        Verify

        LDR     r14, [r1, #CacheFile_Size]
        CMP     r2, r14
        MOVLO   r2, r14

        ADD     r2, r2, #15                     ; round up to a multiple of 16 bytes
        BIC     r2, r2, #15                     ; r2 = new block size

        LDR     r14, [r1, #CacheFile_Data]
        ADD     r2, r14, r2                     ; r2 = size required for file (including header)

        LDR     r3, [r1, #CacheFile_Offset]
        SUBS    r2, r2, r3                      ; r2 = extra memory required at end

        BLHI    insertspace                     ; r1 -> file header, r2 = space to add, r3 = offset within file to insert at

; Make sure that R2 is correct on exit, whether or not there was an error

        LDR     r2, [r1, #CacheFile_Offset]
        LDR     r14, [r1, #CacheFile_Data]
        SUB     r2, r2, r14
        STR     r2, [sp, #1*4]                  ; R2 on exit = space actually ensured

      [ TRACE
        ADDVS   R14, R0, #4
        TraceIf VS, "*** ensuresize returns error",C,R14
        TraceIf VC, "ensuresize returns R2 =",X,R2
      ]

        Verify

        STRVS   r0, [sp]
        EXIT

; *****************************************************************************

; Insert the required amount of space within the given file
;
; In:   r1 -> file header
;       r2 = amount of space to insert
;       r3 = offset within file's data area to insert data,
;
; Note that the file header itself is not adjusted, so r3 must be >= data offset

insertspace     ENTRY  "r3,r4"

        Trace   "insertspace: file",X,R1,S,"offset",X,R3,S,"addspace",X,R2

        LDR     r14, [r1, #CacheFile_Count]
        ADD     r14, r14, #1                    ; make sure this file isn't deleted
        STR     r14, [r1, #CacheFile_Count]

        STR     r1, RelocateHandle
        BL      ensurecache                     ; allocate space at end of file cache
        LDR     r1, RelocateHandle

        LDR     r14, [r1, #CacheFile_Count]
        SUB     r14, r14, #1                    ; put this back to where it was
        STR     r14, [r1, #CacheFile_Count]

        EXIT    VS                              ; couldn't obtain all the memory

        ; Update all pointers (CacheFSFreeData == 0 => we must be inserting)

        ADD     r3, r1, r3                      ; r3 -> where to copy up from

        LDR     r4, CacheFSFileData
        LDR     r14, CacheFSFileSize
        ADD     r4, r4, r14                     ; r4 -> end of file cache

        CMP     r3, r4
        BEQ     %FT01                           ; no need to copy any data if we're at the end

        Trace   "Copying up from",X,R3,S,"by",X,R2

        STR     r3, CacheFSInsertAt
        STR     r2, CacheFSInsertBy

        BL      relocateall                     ; assume CacheFSFreeData is already null

        ; Now copy the data up

        Push    "r2"
        MOV     r1, r3                          ; r1 = source pointer
        ADD     r2, r1, r2                      ; r2 = destination pointer
        SUB     r3, r4, r1                      ; r3 = byte count
        BL      MoveBytesUp
        Pull    "r2"

; Correct file's allocated space, and the total size of the file cache

01      LDR     r1, RelocateHandle

        LDR     r14, [r1, #CacheFile_Offset]
        ADD     r14, r14, r2                    ; update file's allocated space
        STR     r14, [r1, #CacheFile_Offset]

        LDR     r14, CacheFSFileSize
        ADD     r14, r14, r2                    ; update total size of file cache
        STR     r14, CacheFSFileSize

; Don't verify the cache just yet - if we inserted within the header, it will be temporarily incorrect

        EXIT

; *****************************************************************************
;
; In    CacheFSFreeNext indicates the areas to be deleted
; Out   cache compacted, and any pointers relocated
;
; It's actually easier to relocate all the pointers first, and then copy the data
; We assume that pointers into the RMA are lower than dynamic area addresses

errblock_abort  DCD     1
                DCB     "compactcache aborting", 0
                ALIGN

compactcache    ENTRY  "R1-R6"

        LDR     R1, CacheFSFreeNext
        TEQ     R1, #0
        EXITS   EQ                              ; no free areas to delete

        Trace   "compactcache: freenext =",X,R1

        LDR     R14, [R1, #0]
        LDR     R1, CacheFSFileSize
        STrace  "-- First free block size",X,R14,S,"of",X,R1
        SUBS    R1, R1, R14
        STREQ   R1, CacheFSFileSize
        STREQ   R1, CacheFSFreeNext
        EXITS   EQ                              ; free area equates to entire pool

        BL      relocateall                     ; relocate all pointers

        ; Right - now we can move the actual data

        LDR     R6, CacheFSFileData
        LDR     R14, CacheFSFileSize
        ADD     R6, R6, R14                     ; R6 -> end of file data

        LDR     R2, CacheFSFreeNext             ; R2 = destination pointer
        MOV     R5, R2                          ; R5 = next free area

05      MOV     R14, R5
        LDMIA   R14, {R4, R5}                   ; R4 = size, R5 = link to next
        ADD     R1, R14, R4                     ; R1 = source pointer
        SUBS    R3, R5, #0
        MOVEQ   R3, R6                          ; R3 -> end of source data
        SUBS    R3, R3, R1                      ; R3 = bytes to copy

        ADD     R4, R2, R3                      ; R4 = next destination pointer

        BLGT    MoveBytes                       ; copy data down

        MOV     R2, R4                          ; R2 = next destination pointer
        CMP     R5, #0
        BNE     %BT05

        ; Now correct the free space size and the free area list

        MOV     R14, #0
        STR     R14, CacheFSFreeNext

        LDR     R14, CacheFSFileData
        SUB     R2, R2, R14
        STR     R2, CacheFSFileSize             ; correct end pointer

        STrace  "compactcache finished"

        EXIT

; *****************************************************************************

; Relocate all pointers within the cache

relocateall     ENTRY  "R1-R5"

        ; Relocate pointers within root object, and root pointer itself

        STrace  "relocate root data pointers"

        LDR     R1, CacheFSRoot
        CMP     R1, #0
        BEQ     %FT00

        LDR     R14, [R1, #CacheFile_Data]
        LDR     R3, [R1, #CacheFile_Size]
        ADD     R1, R1, R14                     ; R1 -> start of file pointers
        ADD     R3, R1, R3                      ; R3 -> end of file pointers
        MOV     R4, R1                          ; R4 -> destination
        B       %FT25

20      LDR     R2, [R1], #4
        BL      relocate_before                 ; file header pointer
        CMP     R2, #0
        STRNE   R2, [R4], #4

25      CMP     R1, R3
        BLO     %BT20

        LDR     R2, CacheFSRoot
        LDR     R14, [R2, #CacheFile_Data]
        ADD     R14, R2, R14
        SUB     R4, R4, R14
        STR     R4, [R2, #CacheFile_Size]       ; new size of root object (null pointers eliminated)
        Trace   "New root data size",X,R4
        ADD     R4, R4, #4
        STR     R4, [R14, #CacheFile_SizePlus]  ; keep this kosher

        BL      relocate_before                 ; file header pointer
        STR     R2, CacheFSRoot

        ; Relocate special handle (for temporary pointers)

00
        STrace  "relocate RelocateHandle"

        LDR     R2, RelocateHandle
        BL      relocate_before                 ; file header pointer
        STR     R2, RelocateHandle

        ; Relocate open file handle pointers

        STrace  "relocate open file handles"

        LDR     R1, CacheFSHandles
        B       %FT02

01      LDR     R2, [R1, #CacheHandle_Data]
        BL      relocate_after                  ; file DATA pointer
        STR     R2, [R1, #CacheHandle_Data]

        LDR     R1, [R1, #CacheHandle_Next]
02      TEQ     R1, #0
        BNE     %BT01

        ; Relocate emumeration block pointers

        STrace  "relocate enumeration block pointers"

        LDR     R1, CacheFSEnums
        B       %FT15

10      MOV     R5, R1

11
        STrace   "Relocate enumeration block",X,R1

        ADD     R3, R1, #CacheEnum_Files
        LDR     R4, [R1, #CacheEnum_NextFile]
        ADD     R4, R1, R4

12      LDR     R2, [R3]
        BL      relocate_before                 ; file header pointer
        STR     R2, [R3], #4

        CMP     R3, R4
        BLO     %BT12

        LDR     R1, [R1, #CacheEnum_Next]
        CMP     R1, #0
        BNE     %BT11

        LDR     R1, [R5, #CacheEnum_Link]
15      CMP     R1, #0
        BNE     %BT10

        ; Relocate LRU chain head pointers

        STrace  "relocate LRU chain pointers"

        LDR     R2, CacheFSNext
        BL      relocate_before                 ; file header pointer
        STR     R2, CacheFSNext

        LDR     R2, CacheFSPrevious
        BL      relocate_before                 ; file header pointer
        STR     R2, CacheFSPrevious

        ; Relocate LRU chain pointers within file blocks (don't worry about the free list)

        LDR     R1, CacheFSFileData
        LDR     R3, CacheFSFileSize
        ADD     R3, R1, R3                      ; R3 -> end of file list
        B       %FT04

03      LDR     R2, [R1, #CacheFile_Next]
        BL      relocate_before                 ; file header pointer
        STR     R2, [R1, #CacheFile_Next]

        LDR     R2, [R1, #CacheFile_Previous]
        BL      relocate_before                 ; file header pointer
        STR     R2, [R1, #CacheFile_Previous]

        LDR     R14, [R1, #CacheFile_Offset]
        ADD     R1, R1, R14

04      CMP     R1, R3
        BLO     %BT03

        EXITS

; *****************************************************************************

; In    R2 = pointer into file cache (before compaction)
; Out   R2 = updated pointer (after compaction)
;
; The free list must be scanned to see where the pointer will end up
; NOTE: If the free list is null, we assume we're inserting a block instead
;
; Inserting a block at a pointer moves the pointer up
; Deleting a block at a pointer sets the pointer to zero.

relocate_before  ENTRY  "R1,R3,R4"

        STrace  "relocate",X,R2

        LDR     R3, CacheFSFreeNext
        TEQ     R3, #0
        BNE     %FT01

        ADR     R3, CacheFSInsertAt             ; special case - we're inserting a block
        LDMIA   R3, {R3, R14}
        CMP     R2, R3
        ADDHS   R2, R2, R14

        STrace  "         to",X,R2

        EXITS

01      MOV     R4, R2                          ; need to keep the original pointer!

02      CMP     R3, R4                          ; stop when we get past the original ptr
        MOVEQ   R2, #0                          ; it's being deleted!
        STraceIf HS,"         to",X,R2
        EXITS   HS

        LDMIA   R3, {R1, R3}                    ; R1 = space to be deleted, R3 = next free block
        SUB     R2, R2, R1                      ; correct pointer

        TEQ     R3, #0
        BNE     %BT02

        EXITS

; *****************************************************************************

; In    R2 = pointer into file cache (before compaction)
; Out   R2 = updated pointer (after compaction)
;
; NOTE: This is subtly different to the above, since file handle pointers don't
;       point at the file header, but at the start of the data itself.
;       We therefore must deal differently with inserting/deleting at the pointer.
;
; Inserting a block at a pointer leaves the pointer alone
; Deleting a block at a pointer leaves the pointer alone

relocate_after  ENTRY  "R1,R3,R4"

        STrace  "relocate_after",X,R2

        LDR     R3, CacheFSFreeNext
        TEQ     R3, #0
        BNE     %FT01

        ADR     R3, CacheFSInsertAt             ; special case - we're inserting a block
        LDMIA   R3, {R3, R14}
        CMP     R2, R3
        ADDHI   R2, R2, R14                     ; don't move handle pointer up if equal!

        STrace  "         to",X,R2

        EXITS

01      MOV     R4, R2                          ; need to keep the original pointer!

02      CMP     R3, R4                          ; stop when we get past the original ptr
        STraceIf HS,"         to",X,R2          ; don't delete handle pointer if equal!
        EXITS   HS

        LDMIA   R3, {R1, R3}                    ; R1 = space to be deleted, R3 = next free block
        SUB     R2, R2, R1                      ; correct pointer

        TEQ     R3, #0
        BNE     %BT02

        EXITS

; ..............................................................................

; in:   R1 -> file header
; out:  VS => R0 -> error (file open, or locked), else R0 corrupt

checkdeletable  ENTRY

        LDR     R14, [R1, #CacheFile_Count]
        CMP     R14, #0
        ADREQ   R0, ErrorBlock_CacheFS_ObjectLocked
        TraceIf NE, "checkdeletable -- file open",X,R1
        ADRNE   R0, ErrorBlock_CacheFS_FileOpen

        LDREQ   R14, [R1, #CacheFile_Attr]
        TSTEQ   R14, #locked_attribute
        TraceIf NE, "checkdeletable -- file locked (if not open)",X,R1

        SetTheError NE

        EXIT

        MakeErrorBlock CacheFS_FileOpen
        MakeErrorBlock CacheFS_ObjectLocked

; *****************************************************************************
;
;       CacheFS_OSFile - Entry point for OSFILE operations
;
; in:   R0 = reason code
;       R1-R? parameters
;

CacheFS_OSFile ENTRY "R1,R7,R9"

        Trace   "OSFile",D,R0

        CMP     R0, #fsfile_Load        ; can only load if file closed
        BEQ     %FT10

        CMP     R0, #fsfile_Save        ; can only save if file closed
        BEQ     %FT15

        CMP     R0, #fsfile_ReadInfo
        BEQ     %FT20                   ; read file info

        CMP     R0, #fsfile_ReadInfoNoLen
        BEQ     %FT25                   ; read file info without length

        CMP     r0, #fsfile_Delete      ; delete file
        BEQ     %FT30

        CMP     R0, #fsfile_Create
        BEQ     %FT40

        CMP     R0, #fsfile_CreateDir
        BEQ     gocreatedir

        CMP     R0, #fsfile_ReadBlockSize
        BEQ     goreadblocksize

        MOV     r9, #0
        CMP     r0, #fsfile_WriteInfo
        MOVEQ   r9, #2_111              ; write load, exec, attributes
        CMP     r0, #fsfile_WriteLoad
        MOVEQ   r9, #2_001              ; write load
        CMP     r0, #fsfile_WriteExec
        MOVEQ   r9, #2_010              ; write exec
        CMP     r0, #fsfile_WriteAttr
        MOVEQ   r9, #2_100              ; write attributes

        CMP     r9, #0
        EXITS   EQ                      ; none of the above

        Push    "r0,r2-r6"
        BL      FindFileOrActualDir     ; in: R1 -> filename, out: R1 ->object header
        CMP     r0, #object_nothing
        Pull    "r0,r2-r6"
        EXITS   EQ

        TST     r9, #2_001
        STRNE   r2, [r1, #CacheFile_Load]
        TST     r9, #2_010
        STRNE   r3, [r1, #CacheFile_Exec]
        TST     r9, #2_100
        STRNE   r5, [r1, #CacheFile_Attr]

        EXITS

goreadblocksize
        MOV     r2, #16                 ; file granularity = 16 bytes
        EXITS

; load file
;
; in:   r1 -> filename
;       r2 -> buffer to load file to
; out:  r0 corrupted
;       r2-r5 contain file info
;       r6 -> filename for *OPT 1,1 info

10
        Trace   "Load file",C,R1,S,"to",X,R2

        MOV     r7,r2                    ; r7 = stashed dest
        BL      FindFile
        TEQ     r0,#object_file
        BNE     errnofile2
        MOV     r2,r7                    ; r2 = destination ptr

        LDR     r14,[r1,#CacheFile_WriteCount]
        CMP     r14,#0
        BNE     errflopen

        ADD     r6,r1,#CacheFile_Name
        ADD     r7,r1,#CacheFile_Load

        LDR     r3,[r1,#CacheFile_Size]  ; r3 = byte count
        LDR     r14,[r1,#CacheFile_Data]
        ADD     r1,r1,r14                ; r1 -> file data

        CMP     r3,#0
        BLGT    MoveBytes

        LDMIA   r7,{r2-r3}               ; get load/exec addresses back

        EXIT

errflopen
        ADR     r0, ErrorBlock_CacheFS_FileOpen
        SetTheError
        EXIT


errnofile2
        ADR     r0, ErrorBlock_CacheFS_FileNotFound
        SetTheError
        EXIT

        MakeErrorBlock CacheFS_FileNotFound

; save file
;
; in:   r1 -> filename
;       r2 = new file load address
;       r3 = new file exec address
;       r4 -> start of buffer
;       r5 -> end of buffer
;       r6 -> special field, if any
;
; out:  r6 -> filename for *OPT 1,1 info

15
        Push    "r2,r3"

        Trace   "Save file",C,R1,S,"load/exec",X,R2,X,R3

        SUB     r2, r5, r4              ; new file size
        BL      createCache
        BVS     %FT95

        LDR     r2, [sp]                ; r2 = load address specified
        ADD     r14, r1, #CacheFile_Load
        STMIA   r14, {r2, r3}

        ADD     r6, r1, #CacheFile_Name ; for *OPT 1,1

        LDR     r14, [r1, #CacheFile_Data]
        ADD     r2, r1, r14             ; r2 -> file data

        MOV     r1, r4                  ; r1 -> source data

        SUBS    r3, r5, r4              ; r3 = number of bytes to transfer
        BLHI    MoveBytes
95
        Pull    "r2,r3"

        EXIT

; read file info
; in:   R1 -> wildcarded filename
; out:  R0 = object type
;       R2 = load address
;       R3 = exec address
;       R4 = size
;       R5 = attributes

20
        Push    "r6"
        BL      FindFileOrDirectory
        Pull    "r6"

        Trace   "File info",X,R0,X,R2,X,R3,X,R4

        EXIT

; read file info without length
; in:   R1 -> wildcarded filename
; out:  R0 = object type
;       R2 = load address
;       R3 = exec address
;       R5 = attributes

25
        Push    "r4,r6"
        BL      FindFileOrDirectory
        Pull    "r4,r6"
        EXIT                            ; no need to block since length not returned

; delete file or directory
; in:    R1 -> wildcarded filename
; No error if a non-existent object is deleted.
; Error if a non-empty directory is deleted.
; Note that it's only possible to have an empty directory if it was created explicitly.
; In this case the code assumes that it precedes any child files in the cache.

30
        Push    "R1-R6,R10,R11"

        BL      skipdollar              ; R1 -> rest of filename (without $)

        MOV     R2, R1
        BL      FindFileOrDirPtr        ; R2 -> file pointer, R6 -> end of file pointers

        CMP     R0, #object_file
        BEQ     %FT35
        BLT     %FT36                   ; object_nothing - nothing to delete

        CMP     R0, #object_directory   ; only look at explicit directories
        BNE     %FT37                   ; error if you try to delete an implicit one

        ADD     R14, R2, #4
        CMP     R14, R6                 ; OK if no more entries
        BHS     %FT35

        MOV     R10, R1                 ; just look at the next entry
        LDR     R11, [R2, #4]
        ADD     R11, R11, #CacheFile_Name
        BL      compare_dirnames
        BEQ     %FT37                   ; error if there are child entries

35      LDR     R1, [R2]
        BL      deleteCache

36
        Pull    "R1-R6,R10,R11"
        EXIT

37      ADR     R0, ErrorBlock_CacheFS_DirNotEmpty
        SetTheError
        B       %BT36

        MakeErrorBlock CacheFS_DirNotEmpty

; create file
; in:   R1 -> wildcarded filename
;       R2,R3 = new load/exec addresses
;       R5-R4 = size to create with
; out:  R6 -> filename

40
        Push    "R2"

        SUB     R2, R5, R4              ; R2 = size required
        BL      createCache             ; R1 -> file header

        LDR     R2, [SP]                ; R2,R3 = load/exec addresses
        ADDVC   R14, R1, #CacheFile_Load
        STMVCIA R14, {R2, R3}

        Pull    "R2"

        EXIT

; create directory
; in:   R1 -> wildcarded filename
;       R2,R3 = new load/exec addresses
; If directory doesn't 'exist' already, then a file of the form "<dirname>." is created.
; This has the desired effect of making it seem that the directory exists.

gocreatedir
        Push    "R0-R5"

        BL      FindFile
        CMP     R0, #object_nothing
        BNE     %FT45

        LDR     R1, [SP, #1*4]          ; R1 -> source directory name

        SUB     SP, SP, #MAXFILENAME

        MOV     R2, SP                  ; R2 -> destination
        ADD     R3, R2, #MAXFILENAME-4  ; R3 -> end of buffer
42      LDRB    R14, [R1], #1
        CMP     R14, #32
        CMPHI   R3, R2
        STRHIB  R14, [R2], #1
        BHI     %BT42

        CMP     R2, R3                  ; check for buffer overflow
        BHS     %FT47

        MOV     R14, #'.'
        STRB    R14, [R2], #1           ; append "." on the end of the name
        MOV     R14, #0
        STRB    R14, [R2], #1

        MOV     R1, SP
        MOV     R2, #0                  ; R2 = size required (0)
        BL      createCache             ; R1 -> file header

        ADD     SP, SP, #MAXFILENAME

        MOVVC   R14, #0
        STRVC   R14, [R1, #CacheFile_Attr]      ; directories have no access rights by default

        ADDVC   R14, SP, #2*4
        LDMVCFD R14, {R2, R3}           ; R2,R3 = load/exec addresses
        ADDVC   R14, R1, #CacheFile_Load
        STMVCIA R14, {R2, R3}

45      STRVS   R0, [SP]
        Pull    "R0-R5"
        EXIT

47      ADR     R0, ErrorBlock_BuffOverflow
        SetTheError
        B       %BT45

        MakeInternatErrorBlock BuffOverflow,,M09

; *****************************************************************************
;
;       CacheFS_FSFunc - Various functions
;
; in:   R0 = reason code
;

CacheFS_FSFunc  ROUT

        Trace   "FSFunc",D,R0

        TEQ     R0, #fsfunc_Cat
        BEQ     %FT10

        TEQ     R0, #fsfunc_ReadDirEntries
        TEQNE   R0, #fsfunc_ReadDirEntriesInfo
        BEQ     CacheFS_fsfunc_readdirentries
        ASSERT  CacheFS_fsfunc_readdirentries = CacheFS_fsfunc_readdirentriesinfo

        TEQ     R0,#fsfunc_Rename
        BEQ     func_rename

        TEQ     R0,#fsfunc_ReadDiscName
        BEQ     func_readdiscname

        TEQ     R0,#fsfunc_Dir
        TEQNE   R0,#fsfunc_Lib
        TEQNE   R0,#fsfunc_Ex
        TEQNE   R0,#fsfunc_LCat
        TEQNE   R0,#fsfunc_LEx
        TEQNE   R0,#fsfunc_Info
        TEQNE   R0,#fsfunc_Opt
        TEQNE   R0,#fsfunc_ReadCSDName
        TEQNE   R0,#fsfunc_ReadLIBName
        TEQNE   R0,#fsfunc_PrintBanner
        TEQNE   R0,#fsfunc_SetContexts
        TEQNE   R0,#fsfunc_CatalogObjects
        TEQNE   R0,#fsfunc_FileInfo
        TEQNE   R0,#fsfunc_Access
        BEQ     NotSupportedError

        MOV     PC,LR           ; ignore any other reason codes (unknown)
                                ; ShutDown and Bootup are also ignored

; .............................................................................

; In    R2 -> buffer to contain data
; Out   [R2..] = name length, disc name, boot option

func_readdiscname

        ENTRY   "R0-R3"

        Trace   "ReadDiscName"

        MOV     R0, R2
        ADD     R1, R0, #?data
        SWI     XOS_ValidateAddress
        BCS     %FT90

        ADR     R1, data
        MOV     R3, #?data
        BL      MoveBytes

        EXITS

90      ADR     R0, ErrorBlock_CacheFS_BadAddress
        SetTheError
        STR     R0, [SP]
        EXIT

        MakeErrorBlock  CacheFS_BadAddress

data    DCB     5, "Disc0", 0
        ALIGN

; .............................................................................

; *cat
; in: R1 -> dirname (ignored)

10
        ENTRY

        Trace   "*Cat: R1 =",C,R1

        LDR     R1, CacheFSFileData               ; head of chain
        LDR     R3, CacheFSFileSize
        ADD     R3, R1, R3

20      CMP     R1, R3                            ; no more files?
        EXIT    HS

        ADD     R0, R1, #CacheFile_Name
        SWI     XOS_Write0
        SWIVC   XOS_NewLine

        LDRVC   R14, [R1, #CacheFile_Offset]
        ADDVC   R1, R1, R14
        BVC     %BT20

        EXIT

; .............................................................................

; *rename
; in:   R1 -> old pathname
;       R2 -> new pathname
; out:  R1 = 0 if rename performed (non-0 otherwise)

func_rename  ENTRY  "R0-R6"

        MOV     R1, R2
        BL      FindFileOrDirectory

        Push    "R0,R1"
        LDR     R1, [SP, #3*4]
        BL      FindFileOrDirectory             ; R1 = file header of source
        Pull    "R3,R4"                         ; R3 = dest objtype, R4 = dest fileheader

        LDR     R2, [SP, #2*4]                  ; R2 = new pathname

        TEQ     R3, #object_nothing
        TEQNE   R4, R1
        BNE     %FT90                           ; can't rename (destination exists)

        TEQ     R0, #object_directory           ; R0 = object type of source
        BEQ     %FT40

        TEQ     R0, #object_file
        BNE     %FT90

; Source object is a file - don't allow rename if the file is open or locked

        BL      checkdeletable
        BLVC    renamefile                      ; R1 -> file header, R2 -> new filename
        BVS     %FT90

10      MOV     R1, #0                          ; rename was performed
        STR     R1, [SP, #1*4]

        EXIT

; Source object is a directory - we need to rename all files which match the specification.
; Note that since memory allocation is involved, files could be deleted to make room!

40
        Push    "R1"
        LDR     R1, [SP, #2*4]                  ; R1 -> source filename
        BL      skipdollar
        MOV     R7, R1                          ; R7 -> source filename with "$." stripped
        Pull    "R1"

        MOV     R2, R7
        BL      FindFileOrDirPtr                ; R2 -> root anchor for this directory, R6 -> end of anchors

        CMP     R0, #object_directory           ; treat as unlocked unless it's an explicit directory
        BLEQ    checkdeletable                  ; check that the directory itself isn't locked
        BVS     %FT90

; Mark all objects which match are, or are within, the source directory

42      LDR     R1, [R2], #4                    ; R1 -> next object's header
        MOV     R10, R7                         ; R10 -> name to match
        ADD     R11, R1, #CacheFile_Name        ; R11 -> this object's name
        BL      compare_dirnames                ; EQ => it's within the directory
        BNE     %FT43

        LDR     R14, [R1, #CacheFile_Attr]
        ORR     R14, R14, #rename_attribute     ; mark for renaming
        STR     R14, [R1, #CacheFile_Attr]

        CMP     R2, R6
        BLO     %BT42

; Now rename all the marked objects, altering the marks to show that it's been done

43      LDR     R1, [SP, #1*4]                  ; R1 = source pathname
        LDR     R2, [SP, #2*4]                  ; R2 = destination pathname
        MOV     R3, #rename_attribute
        BL      rename_marked
        BLVC    rename_clearmarks
        BVC     %BT10                           ; rename succeeded

; Error during directory rename - undo the ones that were renamed

        Trace   "**** Rename of directory failed - undoing ****"

        LDR     R1, [SP, #2*4]
        LDR     R2, [SP, #1*4]
        MOV     R3, #renamed_attribute
        BL      rename_marked
        BL      rename_clearmarks

; Error exit - rename was not performed

90      MOV     R1, #1                          ; rename was not performed
        STR     R1, [SP, #1*4]

        STRVS   R0,[SP]
        EXIT

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; In    R1 -> source pathname ( 0 => don't actually rename)
;       R2 -> destination pathname
;       R3 = flag bit to watch for
; Out   Marked filed

rename_marked   ENTRY  "R0-R6"

        BL      skipdollar

        MOV     R4, R1

01      LDRB    R14, [R1], #1
        CMP     R14, #' '
        BHI     %BT01

        SUB     R4, R1, R4
        ADD     R4, R4, #CacheFile_Name - 1     ; R4 = offset to end of prefix to remove

; Scan all files, renaming them

        LDR     R1, CacheFSFileData             ; we can assume that there's at least one file present!

45      LDR     R14, [R1, #CacheFile_Attr]
        TST     R14, R3
        BEQ     %FT70

        Push    "R1"
        LDR     R1, [SP, #3*4]
        BL      skipdollar
        MOV     R2, R1                          ; R2 -> destination prefix
        Pull    "R1"

        SUB     SP, SP, #MAXFILENAME

        MOV     R5, SP                          ; R5 -> start of buffer on stack
        ADD     R6, SP, #MAXFILENAME            ; R6 -> end of buffer on stack

46      LDRB    R14, [R2], #1                   ; copy in destination prefix
        CMP     R14, #32
        CMPHI   R6, R5
        STRHIB  R14, [R5], #1
        BHI     %BT46

        ADD     R2, R1, R4                      ; R2 -> rest of filename

47      LDRB    R14, [R2], #1                   ; copy in rest of source name
        CMP     R14, #32
        CMPHI   R6, R5
        STRHIB  R14, [R5], #1
        BHI     %BT47

        CMP     R5, R6
        ADDHS   SP, SP, #MAXFILENAME
        BHI     %FT95                           ; buffer overflow error

        MOV     R14, #0
        STRB    R14, [R5]

        MOV     R2, SP                          ; R2 -> destination pathname for this file
        BL      renamefile

        ADD     SP, SP, #MAXFILENAME

        STRVS   R0, [SP]
        EXIT    VS

        LDR     R14, [R1, #CacheFile_Attr]
        ORR     R14, R14, #renamed_attribute    ; mark file 'renamed'
        STR     R14, [R1, #CacheFile_Attr]

70      LDR     R14, [R1, #CacheFile_Offset]
        Trace   "renamefile: after rename R1 =",X,R1,S,"offset =",X,R14
        ADD     R1, R1, R14                     ; R1 -> next file header

        LDR     R14, CacheFSFileData
        LDR     R2, CacheFSFileSize
        ADD     R2, R14, R2                     ; R2 -> end of data
        Trace   "renamefile: end of data =",X,R2
        CMP     R1, R2
        BLO     %BT45

        EXITS                                   ; preserve flags (eg. error)

95
        Adr     R0, ErrorBlock_BuffOverflow
        SetTheError
        STR     R0, [SP]
        EXIT

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; Clear out the rename marks in the cache
; Preserves all registers and flags

rename_clearmarks  ENTRY  "R1,R3"

        LDR     R1, CacheFSFileData             ; we can assume that there's at least one file present!

        LDR     R14, CacheFSFileData
        LDR     R3, CacheFSFileSize
        ADD     R3, R14, R3                     ; R3 -> end of data

        Assert  R1, LO, R3, "No files left in rename"

01      LDR     R14, [R1, #CacheFile_Attr]
        BIC     R14, R14, #rename_attributes
        STR     R14, [R1, #CacheFile_Attr]

        LDR     R14, [R1, #CacheFile_Offset]
        ADD     R1, R1, R14
        CMP     R1, R3
        BLO     %BT01

        EXITS                                   ; preserve flags (eg. error)

; .............................................................................

; in:   R1 -> file header
;       R2 -> new pathname
; out:  file renamed (out of memory error is possible)
;       R1 relocated if required

renamefile  ENTRY  "R2-R4,R6-R9"

        Trace   "renamefile",X,R1,C,R2

        Push    "R1"
        MOV     R1, R2
        BL      skipdollar
        MOV     R2, R1                          ; R2 -> new pathname without dollar
        Pull    "R1"

        MOV     R7, R2                          ; R7 -> new pathname

01      LDRB    R14, [R2], #1
        CMP     R14, #32
        BHI     %BT01

        SUB     R2, R2, R7                      ; R2 = filename length (including terminator)
        ADD     R2, R2, #3 - CacheFile_Offback
        BIC     R2, R2, #3                      ; R2 = space required for filename (and offback and sizeplus)

        LDR     R3, [R1, #CacheFile_Data]       ; R3 = current offset to file data
        SUB     R4, R3, #CacheFile_Name         ; R4 = current space for filename

        Trace   "renamefile: new size",X,R2,S,"old size",X,R4

        SUBS    R2, R2, R4                      ; R2 = change in space required

        LDR     R4, [R1, #CacheFile_Size]
        ADD     R4, R4, #4                      ; R4 = new sizeplus value (for later)
        BGT     %FT02

; If filename is getting shorter, we need to find out the anchor pointers NOW

        BL      getanchors                      ; R8 -> old anchor, R9 -> new anchor

        CMP     R2, #-4                         ; oops - we can't delete such a small block,
        MOVEQ   R2, #0                          ; so let's pretend the name didn't get smaller after all!
        BGE     %FT30

; new filename is shorter (by at least 8 bytes)

        STR     R1, RelocateHandle

        ADD     R14, R3, R2                     ; new data offset = old data offset + change in name length
        STR     R14, [R1, #CacheFile_Data]

        ADD     R1, R1, R3
        LDR     R14, [R1, #CacheFile_SizePlus]

        ADD     R1, R1, R2                      ; R1 -> new data address
        STR     R14, [R1, #CacheFile_SizePlus]

        ADD     R14, R3, R2
        RSB     R14, R14, #0
        STR     R14, [R1, #CacheFile_Offback]

        RSB     R2, R2, #0                      ; R2 = number of bytes to remove
        BL      removespace                     ; can't get an error here
        RSB     R2, R2, #0

        LDR     R1, RelocateHandle

        LDR     R14, [R1, #CacheFile_Offset]
        ADD     R14, R14, R2                    ; correct free space indicator
        STR     R14, [R1, #CacheFile_Offset]

        B       %FT10                           ; now adjust header and copy in new filename

; new filename is longer

02      ADD     R3, R3, #CacheFile_Offback
        BL      insertspace                     ; R1 -> file header, R2 = space to add, R3 = offset to end of filename
        SUB     R3, R3, #CacheFile_Offback
        TraceIf VS,"Error from insertspace"
        EXIT    VS

; now that the relocations are out of the way, we can find out where the file's old and new anchors are

        BL      getanchors                      ; R8 -> old anchor, R9 -> new anchor

; adjust file header pointers (no need to update open file handle pointers, as they're done in relocateall)

10      ADD     R3, R3, R2
        STR     R3, [R1, #CacheFile_Data]
        RSB     R14, R3, #0
        ADD     R3, R1, R3                      ; R3 -> start of file's new data

        STR     R14, [R3, #CacheFile_Offback]
        STR     R4, [R3, #CacheFile_SizePlus]   ; keep this correct as well
        MOV     R14, #0
        STR     R14, [R3, #CacheFile_Padding]   ; pad new filename with zeros

        SUB     R4, R3, R2                      ; R4 = old data pointer, R3 = new data pointer

; copy in the new pathname

30      ADD     R2, R1, #CacheFile_Name

        Trace   "Copy filename from",X,R7,S,"to",X,R2

31      LDRB    R14, [R7], #1
        CMP     R14, #32
        STRHIB  R14, [R2], #1
        BHI     %BT31

        MOV     R14, #0
        STRB    R14, [R2]

; Shuffle pointers within the root object

        Trace   "Anchor moved from",X,R8,S,"to",X,R9

        CMP     R9, R8
        BEQ     %FT50                           ; file in same position - nothing to do

        Push    "R1"

        BGT     %FT40

        MOV     R1, R9                          ; R1 -> source data
        SUB     R3, R8, R1                      ; R3 = bytes to copy (non-zero)
        ADD     R2, R1, #4                      ; R2 -> destination
        BL      MoveBytesUp
        B       %FT45

40      SUB     R9, R9, #4                      ; this will move down
        CMP     R9, R8

        ADDGT   R1, R8, #4                      ; R1 -> source data
        SUBGT   R3, R9, R8                      ; R3 = bytes to copy (non-zero)
        MOVGT   R2, R8                          ; R2 -> destination
        BLGT    MoveBytes

45
        Pull    "R1"

        STR     R1, [R9]                        ; new pointer

; Finished - R1 should still point to the file header

50
        Verify

        Trace   "rename done."

        EXIT

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; Helper routine for renamefile - finds the old and new anchor pointers

; In    R1 -> file header, with old filename in it
;       R7 -> new filename
; Out   R8 -> old anchor
;       R9 -> new anchor (insertion point)

getanchors  ENTRY  "R0,R2,R6"

        ADD     R2, R1, #CacheFile_Name
        Trace   "getanchors: old/new =",C,R2,C,R7
        BL      FindFilePtr                     ; R6 -> end of items
        MOV     R8, R2                          ; R8 -> anchor

        MOV     R2, R7
        BL      FindFilePtr                     ; R6 -> end of items
        MOV     R9, R2                          ; R9 -> anchor

        Trace   "getanchors: old/new anchors",X,R8,X,R9

        EXITS

; .............................................................................

; in:   R1 -> directory name (not wildcarded)
;       R2 -> buffer to put data
;       R3 = number of object names to read
;       R4 = offset of first item to read in directory
;       R5 = buffer length
;       R6 -> special field (ignored)
; out:  R3 = number of names read
;       R4 = offset of next item to read (-1 if end)

CacheFS_fsfunc_readdirentries      ROUT
CacheFS_fsfunc_readdirentriesinfo  ROUT

        ENTRY   "R0-R3, R5-R11"

        BL      skipdollar                      ; R1 -> rest of name

        Trace   "==== Enumerate directory",C,R1,S,"R4 =",X,R4

        MOV     R8, R2                          ; R8 -> output data

        SUBS    R7, R3, #0                      ; R7 = number of names left to return
        BLE     %FT90                           ; silly if none

        ; Can't enumerate anything if there's no root object

        LDR     R14, CacheFSRoot                ; can't be any files present
        CMP     R14, #0
        BEQ     %FT90

        ; Check to see whether this is the first time through (R4 = 0)

        CMP     R4, #0
        BLT     %FT90                           ; we've finished - don't try that again!

 [ :LNOT: MAKERAMFS
        BNE     return_fromenumblock            ; check for existing enumeration block

; First time through - we'll need to scan the root directory to find the files
 |

; in the case where it's being RAMFS, we need to skip enumeration entries; R10 will
; be used as a counter to do this

 ]

 [ MAKERAMFS
	MOV	R10, #0				; counter for enumerations
	; leave R4 unmodified as when R10<R4 we want to skip entries
 |
        MOV     R10, #0                         ; no enumeration block needed yet
        MOV     R4, #-1                         ; offset for next time
 ]

        ; Special case - if the target directory is '$', we scan the whole of the root object

        LDRB    R14, [R1]
        CMP     R14, #' '
        LDRLE   R2, CacheFSRoot
        LDRLE   R14, [R2, #CacheFile_Data]
        LDRLE   R6, [R2, #CacheFile_Size]
        ADDLE   R2, R2, R14                     ; R2 -> start of file pointers
        ADDLE   R6, R2, R6                      ; R6 -> end of file pointers
        BLE     %FT00

        ; Using the root object, we first try to find the first entry in the directory

        MOV     R2, R1
        BL      FindFileOrDirPtr                ; R2 -> first potential entry to return
        TEQ     R0, #object_file
        BEQ     %FT95                           ; error if the "directory" was really a file
        TEQ     R0, #object_nothing
        BEQ     %FT90                           ; no objects in a non-existent directory

00      MOV     R9, #0                          ; no names yet

; Enumerate names in the root object that are part of the directory indicated

01
        Trace   "readdirentries: R2/R6",X,R2,X,R6

        CMP     R2, R6
 [ MAKERAMFS
	MOVHS	R4, #-1				; set next offset to be -1
 ]
        BHS     %FT92                           ; we've reached the last file in the cache

        Push    "R10"

        LDR     R3, [R2], #4
        MOV     R10, R1                         ; R10 -> original dirname
        ADD     R11, R3, #CacheFile_Name

        LDRB    R14, [R10]                      ; no need to compare dirnames if this is the root
        CMP     R14, #' '
        BLE     %FT02

        BL      compare_filenames
        BGE     %FT89                           ; GE => can't be in the same directory

        LDRB    R14, [R10, #-1]                 ; must also match whole of dirname
        CMP     R14, #' '
        BGT     %FT89

        LDRB    R14, [R11, #-1]                 ; if target name ended in '.', it's a match
        CMP     R14, #'.'                       ; and R11 now points to the leafname
        BNE     %FT89

02      LDRB    R14, [R11]                      ; skip explicit directory itself (leafname = "")
        CMP     R14, #0
        MOVNE   R10, R9                         ; R10 = previous leafname considered
        MOVNE   R9, R11                         ; R9 = most recent leafname (for next time)
        BLNE    compare_R10_R11

        Pull    "R10"

        BEQ     %BT01                           ; don't return this leafname if it's the same as the last one

 [ MAKERAMFS
	; if R10<R4 then have to go 'round the loop again

	CMPS	R10, R4				; do we want it?
	ADD	R10, R10, #1			; next entry
	BLT	%BT01				; don't return this entry
 ]

 [ MAKERAMFS
; =========== Return a directory entry (if there's room) ============
;
; We have skipped the entries before the one we want
;
; R4 will contain the offset of the first entry to return
; R10 will contain the offset of the current entry

 |
; =========== Return a directory entry (if there's room) ============
;
; We can be in one of 2 states at this point:
;
;    1) First time through, and buffer is not yet full
;    2) First time through, buffer is full, enumeration block is allocated and we're filling it up
;
; Next time we're called, we'll be returning items from the enumeration block.

        CMP     R10, #0                         ; is there already an enumeration block?
        BNE     %FT11
 ]



 [ MAKERAMFS
; have a go at sticking it in the user's buffer
 |
; No enumeration block allocated yet - have a go at sticking it in the user's buffer
 ]

        LDR     R0, [SP, #0*4]
        BL      returndirentry
        BCC     %BT01

        LDR     R14, [SP, #3*4]
        CMP     R7, R14                         ; if we didn't even return one name, return a "Buffer overflow" error
        BEQ     %FT85


 [ MAKERAMFS
	B	%FT92				; return what we did
 |

        B       %FT15                           ; allocate enumeration block and stash this one

; See if we can stick it in the current enumeration block

11      LDR     R14, [R10, #CacheEnum_NextFile]
        CMP     R14, #CacheEnum_Size
        BGE     %FT15

        Trace   "enumdir: stashing directory entry",X,R3,C,R9
        ADD     R14, R10, R14
        SUB     R9, R9, R3
        STMIA   R14!, {R3, R9}                  ; store filename pointer and offset to leafname
        ADD     R9, R3, R9
        SUB     R14, R14, R10
        STR     R14, [R10, #CacheEnum_NextFile]
        B       %BT01                           ; done it - go on to next name

; Allocate new enumeration block and stick it in there

15      STR     R3, RelocateHandle

        Push    "R2"
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #CacheEnum_Size
        SWI     XOS_Module
        MOVVC   R0, R2
        Pull    "R2"
        BVS     return_enumdir_error            ; deletes the blocks allocated so far

        LDR     R3, RelocateHandle              ; note that this file could have been deleted

; Check where we should link this in

        CMP     R10, #0
        LDRNE   R14, [R10, #CacheEnum_Identifier]
        LDREQ   R14, CacheFSNextID
        ADDEQ   R14, R14, #1
        MOVEQ   R14, R14, LSL #33-ENUMSHIFT
        MOVEQ   R14, R14, LSR #33-ENUMSHIFT     ; knock out the top bit of the identifier
        STREQ   R14, CacheFSNextID
        STR     R14, [R0, #CacheEnum_Identifier]

        MOVEQ   R4, R14, LSL #ENUMSHIFT
        ADDEQ   R4, R4, #CacheEnum_Files        ; offset for next time

        LDREQ   R14, CacheFSEnums
        MOVNE   R14, #0
        STR     R14, [R0, #CacheEnum_Link]
        STREQ   R0, CacheFSEnums
        STRNE   R0, [R10, #CacheEnum_Next]
        MOV     R14, #0
        STR     R14, [R0, #CacheEnum_Next]

        MOV     R14, #CacheEnum_Files
        STR     R14, [R0, #CacheEnum_NextFile]

        MOV     R10, R0                         ; R10 -> next enumeration block
        Trace   "enumdir: enumeration block allocated",X,R10
        B       %BT11

 ]

; Enumeration finished - we may or may not have some stuff in enumeration blocks

89
        Pull    "R10"
        B       %FT92

; Abort - indicate we've definitely finished

90      MOV     R4, #-1

; Enumeration finished - R4 is already set up for the return

92      LDR     R14, [SP, #3*4]
        SUB     R14, R14, R7
        STR     R14, [SP, #3*4]                 ; R3 on exit = no of files read

 [ MAKERAMFS
	; need to update R4 to give next offset
	MVNS	R1, R4				; want to check if R4=-1
	ADDNE	R4, R4, R14			; R4+number of entries read=next offset to read
 ]

        Trace   "==== readdirentries returns",X,R14,X,R4

        STRVS   R0, [SP]
        EXIT

; Come here if we ran out of room in the buffer (it's an error if not even one entry can fit)

85      ADRL    R0, ErrorBlock_BuffOverflow
        SetTheError

 [ :LNOT: MAKERAMFS
        B       return_enumdir_error            ; in case we need to delete any blocks
 ]

; Come here if the 'directory' was actually a file

95      ADR     R0, ErrorBlock_CacheFS_IsAFile
        SetTheError
        B       %BT90

        MakeErrorBlock CacheFS_IsAFile

        LTORG

 [ :LNOT: MAKERAMFS
; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; Return directory entries out of a list of enumeration blocks
; In    R4 = 'offset' to next file:
;               bits ENUMSHIFT..30 = identifier of relevant block
;               bits 0..ENUMSHIFT-1 = offset to next file to return within block

return_fromenumblock  ROUT

        ADD     R4, R4, #3                      ; bodge: deal with nasty *Wipe command, which decrements R4 before passing it back in
        BIC     R4, R4, #3

        MOV     R11, R4, LSR #ENUMSHIFT         ; R11 = identifier to search for
        BIC     R2, R4, R11, LSL #ENUMSHIFT     ; R2 = offset to next one

; Find the first block in the chain for this enumeration

        Trace   "enumdir: return from block id/offset",X,R11,X,R2

        LDR     R10, CacheFSEnums
        B       %FT02

01      LDR     R14, [R10, #CacheEnum_Identifier]
        CMP     R11, R14
        TraceIf EQ,"enumdir: found block",X,R10
        BEQ     %FT03

        LDR     R10, [R10, #CacheEnum_Link]
02      CMP     R10, #0
        BNE     %BT01

; Skip earlier blocks in the chain to get to the relevant one

03      CMP     R10, #0
        BEQ     %FT90                           ; no more blocks - we've finished

        CMP     R2, #CacheEnum_Size
        LDRGE   R10, [R10, #CacheEnum_Next]
        SUBGE   R2, R2, #CacheEnum_Size
        TraceIf GE,"enumdir: skipping to block",X,R10,X,R2
        BGE     %BT03

        LDR     R14, [R10, #CacheEnum_NextFile]
        CMP     R2, R14
        BHS     %FT90                           ; no more in this block - we've finished

; Start returning entries from this block

04
        Trace   "enumdir: block/offset",X,R10,X,R2

        ADD     R14, R10, R2
        LDMIA   R14, {R3, R9}
        CMP     R3, #0                          ; watch out for deleted files
        BEQ     %FT05

        LDR     R0, [SP, #0*4]
        ADD     R9, R3, R9                      ; R9 -> leafname
        BL      returndirentry
        BCS     %FT80                           ; doesn't fit - get ready for next time

05      ADD     R4, R4, #8                      ; update counter for next time
        ADD     R2, R2, #8
        CMP     R2, #CacheEnum_Size
        LDRGE   R10, [R10, #CacheFile_Next]
        MOVGE   R2, #CacheEnum_Files
        ADDGE   R4, R4, #CacheEnum_Files

        B       %BT03

; We've finished - R4 is already set up for next time

80      LDR     R14, [SP, #3*4]
        SUB     R14, R14, R7
        STR     R14, [SP, #3*4]                 ; R3 on exit = no of files read

        Trace   "==== readdirentries (from enum block) returns",X,R14,X,R4

        STRVS   R0, [SP]
        EXIT

; We've returned all the entries - delete the enumeration block and return R4 = -1

return_enumdir_error

90
        Push    "R0,PC"

        ADR     R11, CacheFSEnums

92      LDR     R10, [R11]
        CMP     R10, #0
        BEQ     %FT95
        LDR     R14, [R10, #CacheEnum_Identifier]
        CMP     R14, R4, LSR #ENUMSHIFT
        ADDNE   R11, R10, #CacheEnum_Link
        BNE     %BT92

        LDR     R14, [R10, #CacheEnum_Link]
        STR     R14, [R11]

93      MOV     R0, #ModHandReason_Free
        MOV     R2, R10
        LDR     R10, [R2, #CacheEnum_Next]
        SWI     XOS_Module
        TraceIf VC, "enumdir: block freed",X,R2
        TraceIf VS, "*** BARF: error from OS_Module free",X,R2

        CMP     R10, #0
        BNE     %BT93

95
        Pull    "R0,LR"
        TEQP    LR, #0                  ; restore flags (for error case)

        MOV     R4, #-1
        B       %BT80

 ]

; .................................................................................

; In    R0 = reason code (fsfunc_ReadDirEntries/Info)
;       R3 -> file header to return
;       R5 = bytes free in user's buffer
;       R7 = number of names left to return
;       R8 -> next free byte in user's buffer
;       R9 -> leafname
; Out   CS => item wouldn't fit in the buffer
;       CC => item written out, and R5, R7, R8 updated

returndirentry  ENTRY  "R10,R11"

        Trace   "enumdir: return entry",X,R3,C,R9

        CMP     R7, #0
        BLE     %FT90                           ; we've read enough names

        ; count length of leafname and remember terminator

        MOV     R11, R9
04      LDRB    R14, [R11], #1
        CMP     R14, #"."
        CMPNE   R14, #0
        BNE     %BT04                           ; R14 = terminator of leafname
        SUB     R10, R11, R9                    ; R10 = length of leafname, R11 -> next character after R14

        ; calculate space required for this entry and check space left

        TEQ     R0, #fsfunc_ReadDirEntries
        ADDNE   R10, R10, #5*4 + 3
        BICNE   R10, R10, #3                    ; R10 = length of this entry

        Trace   "Space required for entry",X,R10

        SUBS    R5, R5, R10
        BLT     %FT90                           ; won't fit

        ; write out file/dir info if required

        TEQ     R0, #fsfunc_ReadDirEntries
        BEQ     %FT10

        Push    "R0-R5"

        CMP     R14, #"."
        MOVNE   R5, #object_file                ; type = file
        MOVEQ   R5, #object_directory           ; type = directory

        LDREQB  R11, [R11]
        CMPEQ   R11, #0                         ; EQ => this is an explicit directory

        ADD     R1, R3, #CacheFile_Load
        LDMIA   R1, {R1-R4}                     ; R1=load, R2=exec, R3=size, R4=attr

        CMP     R11, #0
        CMPNE   R5, #object_file

        ANDNE   R1, R1, #&FF
        LDRNE   R14, =&FFFFFD00                 ; fake directories always have type 'data'
        ORRNE   R1, R1, R14
        MOVNE   R4, #0                          ; fake directories always have 0 attributes

        Trace   "Return attributes",X,R1,X,R2,X,R3,X,R4,X,R5

        STMIA   R8!, {R1-R5}                    ; load, exec, size, attr, type

        Pull    "R0-R5"
10

; now copy in the leafname, and word-align if R0 = fsfunc_ReadDirEntries

        MOV     R10, R9

03      LDRB    R14, [R10], #1
        CMP     R14, #"."
        CMPNE   R14, #0                         ; zero-terminated in CacheFS:
        MOVEQ   R14, #0
        STRB    R14, [R8], #1
        BNE     %BT03

        TEQ     R0,#fsfunc_ReadDirEntries
        ADDNE   R8, R8, #3
        BICNE   R8, R8, #3

        SUB     R7, R7, #1                      ; one more file read

        PullEnv
        BICS    PC, LR, #C_bit                  ; CC => name was put in

90
        PullEnv
        ORRS    PC, LR, #C_bit                  ; CS => name didn't fit, or count ran out

; *****************************************************************************
;
;       CacheFS_Open - Open a file
;
; in:   R0 = open reason code
;       R1 -> filename
;       R3 = handle
;       R6 -> special field (irrelevant)
; out:  R0 = file information word (not FS info word)
;       R1 = internal file handle
;       R2 = buffer size for FileSwitch (0 if unbuffered)
;       R3 = file extent              ; used for buffered files only
;       R4 = file's allocated space   ;

CacheFS_Open ENTRY "R5-R6"

        Trace   "Open",D,R0

        VerifyAll

        CMP     R0, #fsopen_ReadOnly
        BEQ     openforreading

        CMP     R0, #fsopen_CreateUpdate
        BEQ     openforwriting

        CMP     R0, #fsopen_Update
        BLNE    NotSupportedError
        EXIT    VS

openforupdate
        BL      FindFile
        TEQ     R1,#0
        BEQ     errnofile

        LDR     R14, [R1, #CacheFile_Count]
        CMP     R14, #0
        BGT     errfileopen

        LDR     R0, =fsopen_WritePermission :OR: fsopen_ReadPermission :OR: fsopen_UnbufferedGBPB
        B       openfile

openforwriting
        MOV     R2, #0
        BL      createCache                     ; create empty file (R1 -> file header on exit)
        BVS     errnofile

        ; Ensure the file size is set to zero (no need to shrink the file - wait till it's closed)

        LDR     R14, [R1, #CacheFile_Size]
        CMP     R14, #0
        MOVNE   R2, #0
        TraceIf NE, "CreateUpdate setting file",X,R1,S,"size to",X,R2
        BLNE    setextent                       ; shouldn't give an error, but return if there is one anyway

      [ TRACE
        LDRVC   R14, [R1, #CacheFile_Size]
        TraceIf VC,"New file",X,R1,S,"size is",X,R14
      ]

        LDRVC   R0, =fsopen_WritePermission :OR: fsopen_ReadPermission :OR: fsopen_UnbufferedGBPB
        BVC     openfile

; Don't return errors from this routine - just set R1 = 0 (no file handle)

errnofile
errfileopen
        MOV     R1, #0                          ; no file opened
        MOV     R2, #0
        MOV     R3, #0
        MOV     R4, #0
        EXITS

errnoaccess
        ADR     R0, ErrorBlock_CacheFS_AccessViolation
        SetTheError
        EXIT

        MakeErrorBlock  CacheFS_AccessViolation

openforreading
        BL      FindFile                        ; R1 -> file header on exit
        TEQ     R0,#object_nothing
        BEQ     errnofile

        LDR     R14, [R1, #CacheFile_WriteCount]
        CMP     R14, #0
        BGT     errfileopen

        LDR     R0, =fsopen_ReadPermission :OR: fsopen_UnbufferedGBPB

; Open file handle with (up to) the indicated permissions
;
; In    R0 = file permissions required
;       R1 -> file header
; Out   R0 = file permissions (file information word)
;       R1 = internal file handle (-> block in RMA)
;       R2 = 0 (no FileSwitch buffering)
;       R3,R4 irrelevant if no buffering

openfile
        LDR     R14, [R1, #CacheFile_Attr]      ; reduce access permissions according to file attributes
        TST     R14, #read_attribute
        BICEQ   R0, R0, #fsopen_ReadPermission
        AND     R14, R14, #locked_attribute :OR: write_attribute
        TEQ     R14, #write_attribute           ; must be writable and not locked
        BICNE   R0, R0, #fsopen_WritePermission

        TST     R0, #fsopen_ReadPermission :OR: fsopen_WritePermission
        BEQ     errnoaccess                     ; don't allow a file to be opened with no access

        LDR     R14,[R1,#CacheFile_Count]
        ADD     R14,R14,#1
        STR     R14,[R1,#CacheFile_Count]

        MOV     R4,R0

        TST     R0,#fsopen_WritePermission
        MOVNE   R14,#1
        STRNE   R14,[R1,#CacheFile_WriteCount]

; If we use FileSwitch buffering, the allocated space must be a multiple of the buffer size

      [ BUFFERSIZE > 0
        BEQ     %FT10

        LDR     R2,[R1,#CacheFile_Offset]
        LDR     R14,[R1,#CacheFile_Data]
        SUB     R2,R2,R14                       ; R2 = current allocated space
        MOV     R14,#BUFFERSIZE
        SUB     R14,R14,#1
        TST     R2,R14
        LDRNE   R2,[R1,#CacheFile_Size]
        ADDNE   R2,R2,R14
        BICNE   R2,R2,R14
        BLNE    ensuresize                      ; could give 'out of memory'
        BVS     %FT95                           ; correct counts and return error

        BIC     R4,R4,#fsopen_UnbufferedGBPB    ; use buffering for writing to files
10
      ]

; Right - now allocate the internal file handle

        STR     R1,RelocateHandle               ; in case we need to relocate the file

        MOV     R0,#ModHandReason_Claim
        MOV     R3,#CacheHandle_Size
        SWI     XOS_Module
        BVS     %FT95

        LDR     R1,RelocateHandle               ; get this back

        BL      removeLRU                       ; remove from LRU chain

        LDR     R14,[R1,#CacheFile_Data]
        ADD     R14,R1,R14
        STR     R14,[R2,#CacheHandle_Data]
        STR     R4,[R2,#CacheHandle_Flags]
        MOV     R14,#0
        STR     R14,[R2,#CacheHandle_FilePtr]

        LDR     R14,CacheFSHandles
        STR     R14,[R2,#CacheHandle_Next]
        STR     R2,CacheFSHandles

        MOV     R0,R4                           ; R0 = file information word

        LDR     R3,[R1,#CacheFile_Size]         ; R3 = file extent
        LDR     R4,[R1,#CacheFile_Offset]
        LDR     R14,[R1,#CacheFile_Data]
        SUB     R4,R4,R14                       ; R4 = file's allocated space

        MOV     R1,R2                           ; R1 = internal file handle
      [ BUFFERSIZE > 0
        TST     R0, #fsopen_UnbufferedGBPB
        MOVNE   R2, #0
        MOVEQ   R2, #BUFFERSIZE                 ; use buffering for output due to FileSwitch bug
      |
        MOV     R2,#0                           ; no FileSwitch buffering
      ]

        Trace   "OpenFile returns",X,R0,X,R1,X,R2,X,R3,X,R4

        VerifyAll

        EXIT

; Error while allocating file handle block => correct open handle counts

95      TST     R4,#fsopen_WritePermission
        MOVNE   R14,#0
        STRNE   R14,[R1,#CacheFile_WriteCount]

        LDR     R14,[R1,#CacheFile_Count]
        SUB     R14,R14,#1
        STR     R14,[R1,#CacheFile_Count]

        Verify

        EXIT

; .................................................................................

; in:   R1 -> filename
;       R2 = new extent for file
; out:  R1 -> file header (created if file didn't exist)
;       file is deleted if it's a new one and the required size couldn't be set

createCache  ENTRY  "r1-r6"

        Trace   "createCache",C,R1,S,"size",X,R2

 [ MAKERAMFS
	; check if the parent exists as a directory; if not, then can't have the file

	BL	FindFileParent			; find the parent directory of a file
	CMP	r0, #object_directory
	BEQ	%FT01

	; it's not a directory as a parent, make some sort of complaint

	ADRL    R0, ErrorBlock_CacheFS_IsAFile
        SetTheError
	EXIT

01
 ]

        BL      FindFile
        LDR     r2, [sp, #1*4]
        TEQ     r1, #0
        BEQ     %FT01

        BL      checkdeletable
        BLVC    setextent                       ; error when setting extent => leave file alone

        STRVC   r1, [sp]
        EXIT

01      LDR     r1, [sp]                        ; r1 -> filename
        BL      newCache_linkedin               ; r1 -> file header (if created)
        EXIT    VS

        Trace   "createCache: setting extent to",X,R2
        BL      setextent
        Trace   "createCache: actual new extent",X,R2

        STRVC   r1, [sp]
        EXIT    VC

        Trace   "createCache: deleting file again",X,R1

        SUBS    r2, r0, #0                      ; stash R0, clearing V flag
        BL      deleteCache                     ; error when setting extent => delete file again
        MOV     r0, r2
        SETV                                    ; VS, R0 -> error

        EXIT

; .................................................................................

; in:   R1 -> filename
; out:  R1 -> file header (at end of cache, at LRU tail, with no data allocated)
;       the appropriate file pointer is also set up within the root object

newCache_linkedin ENTRY "R1-R3,R6"

        Trace   "newCache_linkedin",C,R1

        LDR     R1, CacheFSRoot
        CMP     R1, #0
        BLEQ    newRoot

        LDR     R14, CacheFSRootLock
        ADD     R14, R14, #1                    ; >>>> don't remove root object while creating this new one
        STR     R14, CacheFSRootLock

        LDRVC   R2, [R1, #CacheFile_Size]
        ADDVC   R2, R2, #4
        BLVC    ensuresize                      ; make sure there's enough room for this new one

        LDRVC   R1, [sp, #0*4]                  ; in:  R1 -> filename
        BLVC    skipdollar
        BLVC    newCache                        ; out: R1 -> file header of new file

        LDR     R14, CacheFSRootLock
        SUB     R14, R14, #1                    ; <<<< root object can now be removed if empty
        STR     R14, CacheFSRootLock

        BVS     %FT90

      [ TRACE
        LDR     R14, CacheFSRoot
        Assert  R14, NE, #0, "root object deleted"
      ]

        ADD     R2, R1, #CacheFile_Name
        BL      FindFilePtr                     ; R2 -> file pointer within root object, R6 -> end of file pointers

        Push    "R1,R2"

        LDR     R1, CacheFSRoot
        LDR     R2, [R1, #CacheFile_Size]
        ADD     R2, R2, #4
        BL      setextent_nomove                ; can't move, since we've already ensured the space

        LDR     R1, [SP, #1*4]                  ; R1 -> source data
        ADD     R2, R1, #4                      ; R2 -> destination
        SUBS    R3, R6, R1                      ; R3 = number of bytes to copy
        BLGT    MoveBytesUp

        Pull    "R1,R2"

        STR     R1, [R2]                        ; stick link pointer in

        Verify

        BLVC    modifyingCache                  ; R1 -> file header

        STRVC   R1, [SP]
        EXIT

90      BL      compactRoot                     ; error while creating file - get rid of root object
        EXIT

; .................................................................................

; Allocate a new root object (assumes there isn't one already)

newRoot ENTRY

      [ TRACE
        LDR     R14, CacheFSRoot
        Assert  R14, EQ, #0, "newRoot called when root already allocated"
      ]

        ADR     R1, rootname
        BL      newCache
        STRVC   R1, CacheFSRoot

        MOVVC   R14, #locked_attribute
        STRVC   R14, [R1, #CacheFile_Attr]

        EXIT

rootname        DCB     "$.", 0
                ALIGN

; .................................................................................

; If the cache is empty apart from the root object, get rid of all of it.
; Also don't remove the root if we're in the process of creating a file.
; Out   All registers and flags preserved

compactRoot     ENTRY  "R0-R3"

        LDR     R1, CacheFSRoot
        CMP     R1, #0
        EXITS   EQ

        LDR     R14, CacheFSRootLock            ; don't mess with the root if it's locked
        CMP     R14, #0                         ; ie. don't shrink it OR get rid of it
        EXITS   GT

        LDR     R14, [R1, #CacheFile_Size]
        CMP     R14, #0
        BEQ     %FT90

        LDR     R2, [R1, #CacheFile_Offset]
        LDR     R3, [R1, #CacheFile_Data]
        SUB     R3, R2, R3
        SUB     R3, R3, R14                     ; R3 = amount of free space in root object

        CMP     R3, #ROOTSPACE
        TraceIf GE, "==== Root object compacted ===="
        BLGE    shrinkfile                      ; reclaim space if there's too much

        EXITS

; Root object is empty - let's clear the lot out

90
      [ TRACE
        LDR     R1, [R1, #CacheFile_Offset]
        LDR     R14, CacheFSFileSize
        Assert  R1, EQ, R14, "---- root has no files but others exist ----"
      ]

        Trace   "---- Root object removed ----"

        MOV     R14, #0
        STR     R14, CacheFSRoot
        STR     R14, CacheFSFileSize

        ADR     R14, CacheFSHead
        STR     R14, CacheFSNext
        STR     R14, CacheFSPrevious

        EXITS

; .................................................................................

; in:   R1 -> filename
; out:  R1 -> file header (at end of cache, at LRU tail, with no data allocated)

newCache ENTRY "r2-r9"

        Trace   "newCache",C,R1

        VerifyAll

        MOV     R3, R1
01      LDRB    R14, [R3], #1
        CMP     R14, #32
        BHI     %BT01
        SUB     R3, R3, R1                      ; R3 = length of name, including terminator

        ADD     R3,R3,#3
        BIC     R3,R3,#3

        ADD     R2,R3,#CacheFile_Name + 8       ; extra file header required

        BL      ensurecache                     ; make room for this new bit (may delete another file)
        EXIT    VS                              ; may run out of memory

        MOV     R4, R1                          ; R4 -> filename

        LDR     R1,CacheFSFileData
        LDR     R14,CacheFSFileSize
        ADD     R1,R1,R14                       ; R1 -> space at end of cache

        ADD     R5, R1, #CacheFile_Name
02      LDRB    R14, [R4], #1                   ; copy filename over
        CMP     R14, #32
        STRHIB  R14, [R5], #1
        BHI     %BT02
        MOV     R14, #0
        STRB    R14, [R5], #1

03      TST     R5, #3                          ; pad with zeros
        STRNEB  R14, [R5], #1
        BNE     %BT03

        ADD     R5,R5,#8                        ; R5 -> where file data will go

        SUB     R14,R1,R5
        STR     R14,[R5,#CacheFile_Offback]
        MOV     R14,#4
        STR     R14,[R5,#CacheFile_SizePlus]

        ADR     R3, CacheFSHead                 ; put at LRU tail
        LDR     R4, CacheFSPrevious
        STR     R1, [R4, #CacheFile_Next]
        STR     R1, [R3, #CacheFile_Previous]

        SUB     R0,R5,R1                        ; R0 = offset to next file (ie. the end)
        SUB     R2,R5,R1                        ; R2 = offset to file data (same as R0)
        LDR     R6, =&DEADDEAD                  ; initial load/exec addresses = "dead"
        LDR     R7, =&DEADDEAD
        MOV     R8, #0                          ; size = 0
        MOV     R9, #read_attribute :OR: write_attribute
        STMIA   R1, {R0,R2,R3,R4,R6-R9}         ; offset, data, next, prev, load, exec, size, attr
        STR     R8, [R1, #CacheFile_Count]
        STR     R8, [R1, #CacheFile_WriteCount]

        LDR     R14,CacheFSFileData
        SUB     R14,R5,R14
        STR     R14,CacheFSFileSize             ; update end-of-cache pointer

        EXIT

        LTORG

; .................................................................................

; In    R2 -> file name
; Out   R2 -> file link pointer (within root object)
;       R6 -> end of file link pointers
;       EQ => there's an exact match

FindFilePtr     ENTRY  "R1,R3-R5,R10-R11"

        LDR     R6, CacheFSRoot                 ; must exist
        LDR     R14, [R6, #CacheFile_Data]
        ADD     R3, R6, R14                     ; R3 -> start of file pointers
        LDR     R14, [R6, #CacheFile_Size]
        ADD     R6, R3, R14                     ; R6 -> end of file pointers
        MOV     R4, R6                          ; R4 -> end of file pointers

01      CMP     R3, R4
        CMPEQ   R3, #0
        MOVHI   R2, R4
        EXIT    HI                              ; NE => not an exact match

        ADD     R5, R3, R4
        MOV     R5, R5, LSR #1
        BIC     R5, R5, #3                      ; R5 = midpoint between R3 and R4 (rounded down)

        MOV     R10, R2
        LDR     R11, [R5]
        ADD     R11, R11, #CacheFile_Name
        BL      compare_filenames

        ADDGT   R3, R5, #4
        MOVLT   R4, R5
        BNE     %BT01

        MOV     R2, R5                          ; EQ => exact match

        EXIT

; .................................................................................

; In    R2 -> file name
; Out   R0 = object type (object_nothing/file/directory/directory_implicit)
;       R2 -> file link pointer (within root object)
;       R6 -> end of file link pointers

FindFileOrDirPtr     ENTRY  "R1,R3-R5,R7,R10-R11"

        LDR     R6, CacheFSRoot                 ; must exist
        LDR     R14, [R6, #CacheFile_Data]
        ADD     R3, R6, R14                     ; R3 -> start of file pointers
        LDR     R14, [R6, #CacheFile_Size]
        ADD     R6, R3, R14                     ; R6 -> end of file pointers
        MOV     R4, R6                          ; R4 -> end of file pointers

        MOV     R0, #object_nothing
        MOV     R7, #0

01      CMP     R3, R4
        BHS     %FT20

        ADD     R5, R3, R4
        MOV     R5, R5, LSR #1
        BIC     R5, R5, #3                      ; R5 = midpoint between R3 and R4 (rounded down)

        MOV     R10, R2
        LDR     R11, [R5]
        ADD     R11, R11, #CacheFile_Name
        BL      compare_filenames
        MOVEQ   R0, #object_file
        MOVEQ   R2, R5
        EXIT    EQ

        ADDGT   R3, R5, #4
        MOVLT   R4, R5
        BGT     %BT01

        ; Our filename was smaller - check to see if we reached the end

        LDRB    R14, [R10, #-1]
        Trace   "R10 terminator was",X,R14
        CMP     R14, #' '
        MOVLE   R14, #0
        CMP     R14, #0
        Trace   "R11 terminator was",X,R14
        LDREQB  R14, [R11, #-1]
        CMPEQ   R14, #'.'
        BNE     %BT01

        ; Now we've found an implicit or explicit directory - find out which

        LDRB    R14, [R11]
        CMP     R14, #0
        TraceIf EQ, "Explicit directory found",X,R5
        TraceIf NE, "Implicit directory found",X,R5
        MOVEQ   R0, #object_directory
        MOVNE   R0, #object_directory_implicit
        MOV     R7, R5                          ; R7 = stashed file anchor pointer

        BNE     %BT01                           ; keep going if it's only implicit

        ; No exact match - revert to best partial match, or no match

20      MOV     R2, R7                          ; R0 already set up

        Trace   "FindFileOrDirPtr returns",X,R0,X,R2,X,R6

        EXIT

 [ MAKERAMFS

NullString DCD	0

; .................................................................................

; In    R2 -> file name
; Out   R0 = object type (object_nothing/file/directory/directory_implicit)
;       R2 -> file link pointer (within root object)
;       R6 -> end of file link pointers

FindParentPtr     ENTRY  "R1,R3-R5,R7,R9-R11"

; need to find last delimiter in name

	MOV	R9, #0
	MOV	R1, R2

	Trace	"file",C,R1

01
	LDRB	R14, [R1], #1			; get current path byte string
	CMPS	R14, #' '			; is it a terminator
	BLE	%FT02

	CMPS	R14, #'.'			; is it a delimiter?
	SUBEQ	R9, R1, #1			; point r9 at it
	B	%BT01				; next char

02	; path string has terminated, R9 is either pointing at the file or at nothing
	; if it points at nothing then the file has no parent (otherwise it will at
	; least point at the '.' between $ and the file)

	TEQS	R9, #0
	MOVEQ	R0, #object_directory
	MOVEQ	R7, #0
	BEQ	%FT20

        LDR     R6, CacheFSRoot                 ; must exist
        LDR     R14, [R6, #CacheFile_Data]
        ADD     R3, R6, R14                     ; R3 -> start of file pointers
        LDR     R14, [R6, #CacheFile_Size]
        ADD     R6, R3, R14                     ; R6 -> end of file pointers
        MOV     R4, R6                          ; R4 -> end of file pointers

        MOV     R0, #object_nothing
        MOV     R7, #0

01      CMP     R3, R4
        BHS     %FT20

        ADD     R5, R3, R4
        MOV     R5, R5, LSR #1
        BIC     R5, R5, #3                      ; R5 = midpoint between R3 and R4 (rounded down)

	CMPS	R9, #0

	BNE	%FT10

10
	ADR	R10, NullString
        LDR     R11, [R5]
        ADD     R11, R11, #CacheFile_Name
        BL      compare_filenames
	B	%FT15

        MOV     R10, R2
        LDR     R11, [R5]
        ADD     R11, R11, #CacheFile_Name
        BL      compare_filenames_r9_terminated

15
        MOVEQ   R0, #object_file
        MOVEQ   R2, R5
        EXIT    EQ

        ADDGT   R3, R5, #4
        MOVLT   R4, R5
        BGT     %BT01

        ; Our filename was smaller - check to see if we reached the end

	MOV	R14, #0
        Trace   "R10 terminator was",X,R14
        CMP     R14, #0
        Trace   "R11 terminator was",X,R14
        LDREQB  R14, [R11, #-1]
        CMPEQ   R14, #'.'
        BNE     %BT01

        ; Now we've found an implicit or explicit directory - find out which

        LDRB    R14, [R11]
        CMP     R14, #0
        TraceIf EQ, "Explicit directory found",X,R5
        TraceIf NE, "Implicit directory found",X,R5
        MOVEQ   R0, #object_directory
        MOVNE   R0, #object_directory_implicit
        MOV     R7, R5                          ; R7 = stashed file anchor pointer

        BNE     %BT01                           ; keep going if it's only implicit

        ; No exact match - revert to best partial match, or no match

20      MOV     R2, R7                          ; R0 already set up

        Trace   "FindParentPtr returns",X,R0,X,R2,X,R6

        EXIT

 ]

; *****************************************************************************
;
;       CacheFS_Close - Close a file
;
; in:   R1 = file handle (pointer to open file block)
;       R2 = new load address
;       R3 = new exec address
; out:  file closed - if we were writing, then the spare space at the end is also removed

CacheFS_Close ENTRY "R0-R6"

        Trace   "close handle",X,R1,S,"datestamp",X,R2,X,R3

        VerifyAll

        ADR     R3, CacheFSHandles
02      LDR     R14, [R3]
        TEQ     R14, #0
        BEQ     errnohandle
        TEQ     R14, R1
        ADDNE   R3, R14, #CacheHandle_Next
        BNE     %BT02

        MOV     R2, R1                          ; R2 -> file handle block

        LDR     R1, [R2, #CacheHandle_Data]
        LDR     R14, [R1, #CacheFile_Offback]
        ADD     R1, R1, R14                     ; R1 -> file header

        LDR     R6, [R2,#CacheHandle_Flags]
        TST     R6, #fsopen_WritePermission
        BEQ     %FT01

        BL      shrinkfile                      ; reclaim space at end of file
        TraceIf VS,"Error from shrinkfile",X,R0

        MOV     R14, #0
        STR     R14, [R1, #CacheFile_WriteCount]

01      LDR     R14, [R1, #CacheFile_Count]
        SUBS    R14, R14, #1
        STR     R14, [R1, #CacheFile_Count]

        ADREQ   R4, CacheFSHead                 ; put back on chain when last handle is closed
        LDREQ   R5, CacheFSPrevious
        ADDEQ   R14, R1, #CacheFile_Next
        STMEQIA R14, {R4, R5}
        STREQ   R1, [R5, #CacheFile_Next]
        STREQ   R1, [R4, #CacheFile_Previous]

        LDR     R14, [R2, #CacheHandle_Next]    ; remove from list
        STR     R14, [R3]

        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module

        LDMIB   sp, {R0,R2-R3}                  ; update datestamp as indicated

        ORRS    R14, R2, R3                     ; load/exec == 0 => don't restamp (no changes)
        BEQ     %FT02

        ADD     R14, R1, #CacheFile_Load
        LDMIA   R14, {R4,R5}                    ; R4,R5 = old load/exec addresses

        TST     R6, #fsopen_WritePermission
        TEQEQ   R2, R4
        TEQEQ   R3, R5

        STMIA   R14, {R2,R3}                    ; new load/exec addresses

        BLNE    modifyingCache                  ; file has been modified
02
        Trace   "Handle almost closed correctly"
        Verify
        Trace   "Handle closed correctly"

        PullEnv
        BICS    PC, LR, #V_bit

errnohandle
        Trace   "*** Handle not known",X,R1

        ADR     r0, ErrorBlock_CacheFS_Channel
        MOV     r1, #0
        SetTheError
        STR     r0, [sp]
        PullEnv
        ORRS    PC, LR, #V_bit

        LTORG

        MakeErrorBlock CacheFS_Channel

; ..............................................................................

; in:   R1 -> file header
; out:  file deleted, and UpCall_ModifyingFile called

deleteCache ENTRY "R0-R3,R6"

        Trace   "deleteCache",X,R1

        Verify

        BL      checkdeletable
        BVS     %FT90

        STR     R1, RelocateHandle

        LDR     R14, CacheFSRoot                ; no need to deal with root object:
        CMP     R14, #0                         ; if there isn't one,
        CMPNE   R14, R1                         ; or this is it!
        BEQ     %FT10

        ADD     R2, R1, #CacheFile_Name
        BL      FindFilePtr                     ; R2 -> file pointer within root object (if any), R6 -> end of file pointers
        BNE     %FT10

        ADD     R1, R2, #4                      ; R1 -> source data
        SUBS    R3, R6, R1                      ; R3 = number of bytes to copy
        BLGT    MoveBytes                       ; delete the file pointer

        LDR     R1, CacheFSRoot
        LDR     R2, [R1, #CacheFile_Size]
        SUB     R3, R2, #4                      ; update root data size
        STR     R3, [R1, #CacheFile_Size]
        LDR     R14, [R1, #CacheFile_Data]
        ADD     R1, R1, R14
        STR     R2, [R1, #CacheFile_SizePlus]   ; update size without calling setextent (to avoid making certain checks)

        ; Now delete the file itself

10      LDR     R1, RelocateHandle

        MOV     R0, #upfsfile_Delete
        ADD     R1, R1, #CacheFile_Name
        BL      modifyingfile                   ; file has gone!  -- TODO: check it's OK in this order

        LDR     R1, RelocateHandle

        BL      removeLRU                       ; remove from LRU chain

        LDR     R2, [R1, #CacheFile_Offset ]
        BL      removespace

        BL      compactRoot                     ; shrink root object if sufficient space available

        VerifyAll

        EXITS

90      STR     R0, [SP]
        EXIT

; *****************************************************************************
;
;       CacheFS_GetByte
;
; in:   R1 = file handle (points to file handle block)
; out:  R0 = byte read, C clear
;       R0 = undefined, C set if EOF
;

CacheFS_GetByte ENTRY "R2-R4"

      [ BUFFERSIZE > 0
        LDR     R14, [R1, #CacheHandle_Flags]
        TST     R14, #fsopen_UnbufferedGBPB
        BNE     %FT05

        Push    "R0"
        MOV     R0, #fsgbpb_read
        BL      CacheFS_GBPB
        STRVS   R0,[SP]
        Pull    "R0"

        EXIT
05
      ]

        Trace   "GetByte",X,R1

        VerifyAll

        LDR     R2, [R1, #CacheHandle_Data]             ; R2 -> file data
        LDR     R3, [R2, #CacheFile_Offback]
        ADD     R3, R2, R3                              ; R3 -> file header

        LDR     R14, [R1, #CacheHandle_FilePtr]
        LDR     R4, [R3, #CacheFile_Size]
        CMP     R14, R4                                 ; CS => EOF
        LDRCCB  R0, [R2, R14]
        ADDCC   R14, R14, #1
        STRCC   R14, [R1, #CacheHandle_FilePtr]

        EXIT

; .............................................................................

; in:   R1 -> file header
; out:  modifyingfile called with appropriate filename

modifyingCache ENTRY "R0,R1"

        LDR     R0, =upfsopen_Update    ; cause dir recache
        ADD     R1, R1, #CacheFile_Name
        BL      modifyingfile

        EXITS

; *****************************************************************************
;
;       CacheFS_PutByte
;
; in:   R0 = byte to put to file
;       R1 = file handle (points to file handle block in RMA)
;

CacheFS_PutByte ENTRY "R0-R6"

      [ BUFFERSIZE > 0
        MOV     R0,#fsgbpb_write
        BL      CacheFS_GBPB
        STRVS   R0,[SP]
        EXIT
      |
        Trace   "PutByte",X,R1,X,R0

        VerifyAll

        LDR     R2, [R1, #CacheHandle_Data]             ; R2 -> file data
        LDR     R3, [R2, #CacheFile_Offback]
        ADD     R3, R2, R3                              ; R3 -> file header

        LDR     R6, [R1, #CacheHandle_FilePtr]
        LDR     R4, [R3, #CacheFile_Size]
        CMP     R6, R4                                  ; CS => we're at EOF
        BCC     %FT02

        LDR     R5, [R3, #CacheFile_Offset]
        ADD     R5, R3, R5
        SUB     R5, R5, R2                              ; R5 = space available for file data

        CMP     R4, R5
        BHS     %FT03

        ; write byte (at EOF)

01      STRB    R0, [R2, R6]
        ADD     R6, R6, #1
        STR     R6, [R1, #CacheHandle_FilePtr]
        STR     R6, [R3, #CacheFile_Size]

        ADD     R14, R6, #4
        STR     R14, [R2, #CacheFile_SizePlus]

        VerifyAll

        STRVS   R0,[SP]
        EXIT

        ; write byte (not at EOF)

02      STRB    R0, [R2, R6]
        ADD     R6, R6, #1
        STR     R6, [R1, #CacheHandle_FilePtr]

        VerifyAll

        STRVS   R0,[SP]
        EXIT

       ; expand space available to the file

03      MOV     R1, R3                                  ; R1 -> file header
        ADD     R2, R4, #&100                           ; make room for another 256 bytes
        BL      ensuresize                              ; this could cause R1 to be relocated
        STRVS   R0,[SP]
        EXIT    VS

        LDMFD   SP, {R0, R1}                            ; R0 = data byte, R1 -> file handle block
        LDR     R2, [R1, #CacheHandle_Data]             ; R2 -> file data
        LDR     R3, [R2, #CacheFile_Offback]
        ADD     R3, R2, R3                              ; R3 -> file header
        B       %BT01
      ]

; *****************************************************************************
;
;       CacheFS_GBPB
;
; in:   R0 = reason code (1,2,3,4)
;       R1 = internal file handle
;       R2 = pointer to buffer
;       R3 = byte count
;       R4 = file pointer (unless it's option 2 or 4)
; out:  R0,R1 preserved
;       R2 = pointer to one after data read/written
;       R3 = number of bytes not transferred
;       R4 = new file pointer (just after data transferred)

fsgbpb_write      *     1
fsgbpb_writePTR   *     2
fsgbpb_read       *     3
fsgbpb_readPTR    *     4

CacheFS_GBPB    ENTRY  "R0-R2,R5-R6"

        Trace   "GBPB",D,R0,S,"handle/buffer/count/ptr",X,R1,X,R2,X,R3,X,R4

        CMP     R0,#fsgbpb_write
        EXITS   LT

        CMP     R0,#fsgbpb_readPTR
        EXITS   GT

        CMP     R0,#fsgbpb_read
        BGE     %FT50

        TEQ     R0,#fsgbpb_writePTR
        LDREQ   R4,[R1,#CacheHandle_FilePtr]

        LDR     R1, [R1, #CacheHandle_Data]
        LDR     R14, [R1, #CacheFile_Offback]
        ADD     R1, R1, R14                     ; R1 -> file header

        Verify

        ADD     R2, R4, R3              ; R2 = new file extent
        LDR     R6, [R1, #CacheFile_Size]
        Trace   "GBPB write end",X,R2,S,"current end",X,R6
        CMP     R2, R6
        BLHI    setextent               ; extend file as required (NOTE: file could move here!)
        STRVS   R0,[SP]
        EXIT    VS

; Fill with zeros if we're writing off the end of the file

        LDR     R5, [R1, #CacheFile_Data]
        ADD     R5, R1, R5              ; R5 -> start of file data
        ADD     R2, R5, R4              ; R2 -> start of destination for copy

        CMP     R4, R6                  ; are we writing off the end of the file?
        BLS     %FT05

        ADD     R5, R5, R6              ; R5 -> previous end-of-file

        Trace   "Fill with zeros from",X,R5,S,"to",X,R2

        MOV     R14, #0

01      CMP     R5, R2
        BHS     %FT05
        TST     R5, #3
        STRNEB  R14, [R5], #1
        BNE     %BT01

02      CMP     R5, R2
        STRLO   R14, [R5], #1           ; doesn't matter if we write zeros up to the next word boundary
        BLO     %BT02

; Now we can stick the data into the file

05      ADD     R4, R4, R3              ; move file pointer on
        LDR     R1, [SP, #1*4]          ; R1 = internal file handle
        STR     R4, [R1, #CacheHandle_FilePtr]

        LDR     R1, [SP, #2*4]          ; R1 -> source data (R2 on entry)
        ADD     R14, R1, R3
        STR     R14, [SP, #2*4]         ; update R2 on exit

        CMP     R3, #0
        BLGT    MoveBytes               ; R3 is already the byte count

        MOV     R3, #0                  ; all bytes transferred

      [ TRACE
        LDMFD   SP,{R0-R2}
        Trace   "GBPB write exit",D,R0,S,"handle/buffer/count/ptr",X,R1,X,R2,X,R3,X,R4
        VerifyAll
      ]

        EXITS

; Multi-byte read operations (GT => R0 = fsgbpb_ReadPTR)

50      LDRGT   R4, [R1, #CacheHandle_FilePtr]

      [ BUFFERSIZE > 0
        LDR     R5, [R1, #CacheHandle_Flags]
      ]

        LDR     R2, [R1, #CacheHandle_Data]     ; R2 -> source file data
        LDR     R14, [R2, #CacheFile_Offback]
        ADD     R1, R2, R14                     ; R1 -> file header

        Verify

        LDR     R6, [R1, #CacheFile_Size]
      [ BUFFERSIZE > 0
        TST     R5, #fsopen_UnbufferedGBPB      ; for buffered files, we must skip this check
        BEQ     %FT55
      ]
        CMP     R4, R6
      ; MOVHI   R4, R6
        TraceIf HS,"Read outside file",X,R4,X,R6
        EXITS   HS                      ; attempt to read outside file extent

        ADD     R5, R4, R3              ; R5 = file offset of end of data
        SUBS    R5, R5, R6              ; R5 = bytes not transferred

        MOVLT   R5, #0                  ; R5 = bytes not transferred
        SUBGT   R3, R3, R5              ; R3 = bytes to transfer

55      ADD     R1, R2, R4              ; R1 -> source data for copy

        LDR     R2, [SP, #2*4]          ; R1 -> destination data (R2 on entry)
        ADD     R14, R2, R3
        STR     R14, [SP, #2*4]         ; update R2 on exit

        ADD     R4, R4, R3              ; R4 = file pointer after transfer
        LDR     R14, [SP, #1*4]         ; R14 = internal file handle
        STR     R4, [R14, #CacheHandle_FilePtr]

        CMP     R3, #0
        BLGT    MoveBytes               ; R3 is already the byte count

        MOV     R3, R5                  ; R3 = bytes not transferred

      [ TRACE
        LDMFD   SP,{R0-R2}
        Trace   "GBPB read exit",D,R0,S,"handle/buffer/count/ptr",X,R1,X,R2,X,R3,X,R4
        VerifyAll
      ]

        EXITS

; *****************************************************************************
;
;       CacheFS_Args
;
; in:   R0 = reason code
;       R1 = internal file handle
;

CacheFS_Args ROUT

        Trace   "Args",D,R0

        CMP     r0, #fsargs_EOFCheck    ; EOF always
        BEQ     args_eofcheck

        BIC     lr, lr, #(V_bit+Z_bit)

        CMP     r0, #fsargs_Flush       ; nop
        ORREQS  pc, lr, #Z_bit          ; EQ

        CMP     r0, #fsargs_ReadLoadExec
        BEQ     args_readloadexec

        CMP     r0, #fsargs_ReadSize
        BEQ     args_readsize

        CMP     r0, #fsargs_SetEXT
        BEQ     args_setext

        CMP     r0, #fsargs_EnsureSize
        BEQ     args_ensuresize

        CMP     r0, #fsargs_ReadEXT
        BEQ     args_readext

        CMP     r0, #fsargs_ReadPTR
        BEQ     args_readptr

        CMP     r0, #fsargs_SetPTR
        BEQ     args_setptr

      [ BUFFERSIZE > 0
        CMP     r0, #fsargs_WriteZeroes
        BEQ     args_writezeroes
      ]

        MOV     pc, lr                  ; EQ/NE from above

      [ BUFFERSIZE > 0
args_writezeroes
        ENTRY   "r1-r10"
        Trace   "==== WriteZeroes",X,R1,X,R2,X,R3
        LDR     r1, [r1, #CacheHandle_Data]
        ADD     r1, r1, r2
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        MOV     r8, #0
        MOV     r9, #0
        MOV     r10, #0
01      STMIA   r1!, {r2,r4-r10}
        SUBS    r3, r3, #8*4
        BNE     %BT01
        EXIT
      ]

args_readloadexec
        ENTRY   "r1"
        LDR     r1, [r1, #CacheHandle_Data]
        LDR     r14, [r1, #CacheFile_Offback]
        ADD     r1, r1, r14
        ADD     r14, r1, #CacheFile_Load
        LDMIA   r14, {r2, r3}
        EXIT

args_readsize                           ; actually reads space allocated to file
        ENTRY   "r1"
        LDR     r2, [r1, #CacheHandle_Data]
        LDR     r14, [r2, #CacheFile_Offback]
        ASSERT  CacheFile_Offset = 0
        LDR     r2, [r2, r14]           ; R2 = offset from file header to end of space
        ADD     r2, r2, r14             ; R2 = offset from file data to end of space
        EXIT

args_readext                            ; read size of file
        ENTRY   "r1"
        LDR     r1, [r1, #CacheHandle_Data]
        LDR     r14, [r1, #CacheFile_Offback]
        ADD     r1, r1, r14
        LDR     r2, [r1, #CacheFile_Size]
        EXIT

args_readptr                            ; read file pointer
        LDR     r2, [r1, #CacheHandle_FilePtr]
        MOV     pc, lr

args_setptr
        ENTRY   "r1"

        LDR     r4, [r1, #CacheHandle_Data]
        LDR     r14, [r4, #CacheFile_Offback]
        ADD     r4, r4, r14
        LDR     r3, [r4, #CacheFile_Size]

        CMP     r2, r3                  ; is PTR > EXT?
        BLS     %FT01

        LDR     R14, [r1, #CacheHandle_Flags]
        TST     R14, #fsopen_WritePermission
        ADREQ   R0, ErrorBlock_CacheFS_OutsideFile
        SetTheError EQ
        BLVC    args_setext             ; extend the file, padding with zeros

01      STRVC   r2, [r1, #CacheHandle_FilePtr]

        EXIT

        MakeErrorBlock CacheFS_OutsideFile

args_setext
        ENTRY   "r1-r3"                 ; r2 = extent required

        LDR     r14, [r1, #CacheHandle_Flags]
        TST     r14, #fsopen_WritePermission
        BEQ     errnoupdate

        LDR     r14, [r1, #CacheHandle_FilePtr]
        CMP     r14, r2
        MOVHI   r14, r2
        STRHI   r14, [r1, #CacheHandle_FilePtr]         ; keep file ptr within limits

        LDR     r1, [r1, #CacheHandle_Data]
        LDR     r14, [r1, #CacheFile_Offback]
        ADD     r1, r1, r14
        BL      setextent_padding       ; pad with zeros if we expanded the file

        EXIT

errnoupdate
        ADR     r0, ErrorBlock_CacheFS_NotOpenForUpdate
        SetTheError
        EXIT

        MakeErrorBlock CacheFS_NotOpenForUpdate

args_ensuresize
        ENTRY   "r0,r1"
        LDR     r1, [r1, #CacheHandle_Data]
        LDR     r14, [r1, #CacheFile_Offback]
        ADD     r1, r1, r14
        BL      ensuresize              ; on exit R2 = space actually ensured
        STRVS   r0, [sp]
        EXIT

args_eofcheck
        ENTRY   "r1"

        LDR     r2, [r1, #CacheHandle_FilePtr]
        LDR     r1, [r1, #CacheHandle_Data]
        LDR     r14, [r1, #CacheFile_Offback]
        ADD     r1, r1, r14             ; r1 -> file header
        LDR     r14, [r1, #CacheFile_Size]

        CMP     r2, r14

        MOVEQ   r2, #-1                 ; return R2 = -1 for EOF
        MOVNE   r2, #0                  ; return R2 = 0 for not EOF

        MOVS    r14, r2, LSR #1         ; CS <=> R2 = -1

        EXIT

; *****************************************************************************

; In    R1 -> file header
;       R2 = required file size
; Out   file size set (no zeros written at end)

setextent  ENTRY  "R2,R3"

        Trace   "=> setextent",X,R1,X,R2

        BL      ensuresize                      ; make sure we've got enough room for this
        B       setentry2

setextent_nomove  ALTENTRY

        CLRV

setentry2
        LDRVC   r2, [sp, #0*4]                  ; recover original size (updated by ensuresize)
        LDRVC   r14, [r1, #CacheFile_Data]
        ADDVC   r3, r1, r14
        ADDVC   r14, r2, #4
        STRVC   r14, [r3, #CacheFile_SizePlus]

        STRVC   r2, [r1, #CacheFile_Size]       ; update file size

      [ TRACE
        EXIT    VS
        LDR     r14, CacheFSRoot
        Trace   "setextent R1/root",X,R1,X,R14
        CMP     r1, r14
        Verify  NE                              ; don't verify just yet if we're updating the root size
      ]

        Trace   "=< setextent",X,R1,X,R2

        EXIT

; *****************************************************************************

; In    R1 -> file header
;       R2 = required file size
; Out   file size set (zeros written at end if we expanded the file)

setextent_padding  ENTRY  "r2,r3"

        BL      ensuresize                      ; make sure we've got enough room for this
        EXIT    VS

        LDR     r2, [sp, #0*4]                  ; recover original size (updated by ensuresize)

        LDR     r14, [r1, #CacheFile_Data]
        ADD     r3, r1, r14
        ADD     r14, r2, #4
        STR     r14, [r3, #CacheFile_SizePlus]

        LDR     r14, [r1, #CacheFile_Size]
        STR     r2, [r1, #CacheFile_Size]       ; update file size
        CMP     r14, r2
        EXIT    HS

        ADD     r14, r3, r14                    ; r14 -> current end of file data
        ADD     r2, r3, r2                      ; r2 -> new end of file data

        MOV     r1, #0
01      TST     r14,#3                          ; set bytes until we're word-aligned
        STRNEB  r1,[r14],#1
        BNE     %BT01

        CMP     r14, r2
        EXIT    HS

02      STR     r1, [r14], #4
        CMP     r14, r2
        BLO     %BT02

        EXIT

 [ MAKERAMFS
; *****************************************************************************
;
;       FindFileParent - Find the parent object of a dile
;
; in:   R1 ->filename to find (no wildcards,  as FileSwitch does it for us)
;
; out:  R0 = object type (0 => not found, 1 => file, 2 => directory)

FindFileParent	ENTRY	"R1-R6"

	BL	skipdollar
	MOV	R2, R1
	BL	FindParentPtr

	EXIT
 ]

; *****************************************************************************
;
;       FindFile - Find a file of a particular name
;
; in:   R1 -> filename to find (no wildcards, as FileSwitch does it for us)
;
; out:  R0 = object type (0 => not found, 1 => file, 2 => directory)
;       R1 -> file header
;       R2 = load address
;       R3 = exec address
;       R4 = size
;       R5 = attributes
;       R6 -> actual filename

FindFile ENTRY

        BL      skipdollar
        MOV     R2, R1                          ; R2 -> filename

        BL      FindFilePtr
        MOVEQ   R0, #object_file
        MOVNE   R0, #object_nothing

; R0 = object type
; R2 -> file anchor pointer in root object

FindFile_Return
        CMP     R0, #object_nothing
        LDRNE   R1, [R2]                        ; R1 -> file header
        ADDNE   R2, R1, #CacheFile_Load
        LDMNEIA R2, {R2-R5}
        ADDNE   R6, R1, #CacheFile_Name
        EXIT    NE

        MOV     R1, #0                          ; no object found
        MOV     R2, #0
        MOV     R3, #0
        MOV     R4, #0
        MOV     R5, #0
        MOV     R6, #0

        EXIT

; .............................................................................

; Parameters as above, but directories may also be returned

FindFileOrActualDir ALTENTRY

        BL      skipdollar
        MOV     R2, R1                          ; R2 -> filename

        BL      FindFileOrDirPtr
        TEQ     R0, #object_directory_implicit
        MOVEQ   R0, #object_nothing
        B       FindFile_Return

; .............................................................................

; Parameters as above, but implicit directories may also be returned

FindFileOrDirectory ALTENTRY

        BL      skipdollar
        MOV     R2, R1                          ; R2 -> filename

        BL      FindFileOrDirPtr
        TEQ     R0, #object_directory_implicit
        BNE     FindFile_Return

        ; Return implicit directory entry

        MOV     R0, #object_directory
        LDR     R1, [R2]                        ; R1 -> file header
        ADD     R2, R1, #CacheFile_Load
        LDMIA   R2, {R2-R3}

        AND     R2, R2, #&FF
        LDR     R14, =&FFFFFD00                 ; implicit directories are of type 'data'
        ORR     R2, R2, R14

        MOV     R4, #0                          ; length = 0
        MOV     R5, #0                          ; implicit directory attributes = 0

        ADD     R6, R1, #CacheFile_Name

        Verify

        EXIT
        LTORG

;......................................................................

; In    R10 -> filename1
;       R11 -> filename2
; Out   GT if R10 > R11, or (R10 or R11 is null)
;       LE if R10 <= R11
; NB:   Comparisons are case-insensitive (both strings forced to be upper case)

compare_R10_R11 ENTRY "R1,R2"

        RSBS    R14, R10, #1
        RSBLES  R14, R11, #1
        EXIT    GT                      ; GT <= either filename is null

        Trace   "compare ",C,R10,C,R11

10      LDRB    R1, [R10], #1
        LDRB    R2, [R11], #1
        uk_UpperCase R1, R14
        uk_UpperCase R2, R14
        CMP     R1, #"."
        CMPNE   R1, #0
        BEQ     %FT20                   ; filename1 terminated
        CMP     R1, R2
        BEQ     %BT10
        EXIT

20      CMP     R2, #"."
        CMPNE   R2, #0                  ; EQ => same
        CMPNE   R2, #&100000            ; LT <= filename1 shorter
        EXIT

;......................................................................

; In    R10 -> filename1 (space or ctrl-terminated)
;       R11 -> filename2 (zero-terminated)
; Out   LT,EQ,GT as for R10 cmp R11
; NB:   Comparisons are case-insensitive (both strings forced to be upper case)
;       Dots in the filename are equivalent to CHR$(1), ie. less than any other code except terminator

compare_filenames ENTRY "R1,R2"

        Trace   "compare_filenames ",C,R10,C,R11

10      LDRB    R1, [R10], #1
        LDRB    R2, [R11], #1
        uk_UpperCase R1, R14
        uk_UpperCase R2, R14
        CMP     R1, #' '
        MOVLE   R1, #0
        CMP     R1, #"."
        MOVEQ   R1, #1
        CMP     R2, #"."
        MOVEQ   R2, #1

        CMP     R1, R2
        EXIT    NE

        CMP     R1, #0
        BNE     %BT10

        EXIT

 [ MAKERAMFS
;......................................................................


; In    R9  -> termination ptr for filename1
;       R10 -> filename1 (terminated by R9, or zero-terminated if earlier)
;       R11 -> filename2 (zero-terminated)
; Out   LT,EQ,GT as for R10 cmp R11
; NB:   Comparisons are case-insensitive (both strings forced to be upper case)
;       Dots in the filename are equivalent to CHR$(1), ie. less than any other code except terminator

compare_filenames_r9_terminated ENTRY "R1,R2"

        Trace   "compare_filenames ",C,R10,C,R11

10      LDRB    R1, [R10], #1
        LDRB    R2, [R11], #1
        uk_UpperCase R1, R14
        uk_UpperCase R2, R14
        CMP     R1, #' '
        MOVLE   R1, #0
        CMP     R1, #"."
        MOVEQ   R1, #1
        CMP     R2, #"."
        MOVEQ   R2, #1
	CMP	R10, R9
	MOVHI	R1, #0

        CMP     R1, R2
        EXIT    NE

        CMP     R1, #0
        BNE     %BT10

        EXIT
 ]

;......................................................................

; In    R10 -> directory name (space or ctrl-terminated)
;       R11 -> object's name (zero-terminated)
; Out   EQ => R11 was within the R10 directory
;       R10, R11 -> one after the last matching character
; NB:   Comparisons are case-insensitive (both strings forced to be upper case)
;       Dots in the filename are equivalent to CHR$(1), ie. less than any other code except terminator

compare_dirnames ENTRY

        BL      compare_filenames

        LDRB    R14, [R10, #-1]         ; check whether dirname is a leading substring
        CMP     R14, #' '
        MOVLE   R14, #0
        CMP     R14, #0
        LDREQB  R14, [R11, #-1]         ; and the next character is '.'
        CMPEQ   R14, #'.'

        EXIT

;.....................................................................

; in:   R1 -> wildcarded pathname
; out:  R1 -> pathname, with "$.", "@.", "%." or "\." removed

skipdollar ENTRY

        LDRB    R14, [R1]
        CMP     R14, #"$"
        CMPNE   R14, #"@"
        CMPNE   R14, #"%"
        CMPNE   R14, #"\"
        EXIT    NE

        LDRB    R14, [R1, #1]
        CMP     R14, #" "
        ADDLS   R1, R1, #1              ; skip "$"
        CMP     R14, #"."
        ADDEQ   R1, R1, #2              ; skip "$."

        EXIT

; *****************************************************************************

      [ USEMESSAGES

CopyError ENTRY r1-r7
        BL      open_messagefile
        EXIT    VS
      [ TRACE
        ADD     R14, R0, #4
        Trace   "Error: token",C,R14
      ]
        ADR     R1, MessageFile_Block
        MOV     R2, #0
        LDR     R4, [sp]        ; R1 (parameter) -> R4
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
    [ MAKERAMFS
        ;DCB     "Resources:$.Resources.RamFS.Messages", 0
        DCB     "<RamFS$Path>Messages", 0
    |
      [ DEBUGVERSION
        DCB     "ADFS::Neil.$.Projects.CacheFS.Messages", 0
      |
        DCB     "Resources:$.Resources.CacheFS.Messages", 0
      ]
    ]
        ALIGN

open_messagefile ENTRY r0-r3
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     R0, MessageFile_Block
        ADR     R1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT
      ]

; *****************************************************************************

        GET     s.MoveBytes
        GET     s.Test

; *****************************************************************************

        END

