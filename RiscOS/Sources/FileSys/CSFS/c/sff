/*->c.sff */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"


#include "Consts.h"
#include "AllErrs.h"
#include "RMInfo.h"
#include "Statics.h"
#include "veneers.h"
#include "Interface.h"
#include "fsentries.h"
#include "ModuleWrap.h"


#include "h.flex"
#include "h.xstr"

#include "h.str"
#include "h.etc"

#include "h.fs"
#include "h.arcs"
#include "h.arcf"
#include "h.dir"
#include "h.cat"
#include "h.fx"
#include "h.link"

#include "h.sfs"

#include "h.sff"



/*****************************************************************************/



_kernel_oserror * readable(int acn,int fn)
{
 if(!(arc[acn].hdr[fn].acc & OURREAD))  return(&mb_sfserr_Access);
 else                                   return(NULL);
}


_kernel_oserror * writeable(int acn,int fn)
{
 if(arc[acn].ro)                        return(&mb_sfserr_ReadOnlyArc);
 else
 if(!(arc[acn].hdr[fn].acc & OURWRITE)) return(&mb_sfserr_Access);
 else
 if(arc[acn].hdr[fn].fshandle)          return(&mb_sfserr_FileOpen);
 else                                   return(NULL);
}



_kernel_oserror * deleteable(int acn,int fn)
{
 if(arc[acn].ro)                 return(&mb_sfserr_ReadOnlyArc);
 else
 if(arc[acn].hdr[fn].acc & LOCK) return(&mb_sfserr_Locked);
 else
 if(arc[acn].hdr[fn].fshandle)   return(&mb_sfserr_FileOpen);
 else                            return(NULL);
}



static _kernel_oserror * writecatinfo(int acn,int fn)
{
 if(arc[acn].ro) return(&mb_sfserr_ReadOnlyArc);
 else            return(NULL);
 USE(fn);
}



_kernel_oserror * LoadFile(int acn,FSEntry_File_Parameter * parm)
{
 _kernel_oserror * err;
 int               dir;
 char            * load;

 err=findpath(acn,arcpath,&dir,0);
 if(!err)
 {
  if(dir>=0)
  {
   err=readable(acn,dir);
   if(!err)
   {
    load=parm->info.load_exec.load_address;

    /* load file to address */

    err=loadfile(acn,dir,load);

    parm->info.load_exec.load_address=(char*)arc[acn].hdr[dir].load;
    parm->info.load_exec.execute_address=(char*)arc[acn].hdr[dir].exec;
    parm->extras.info.length=arc[acn].hdr[dir].length;
    parm->extras.info.attributes=arc[acn].hdr[dir].acc;

    strcpy(arcname,stringptr(arc[acn].hdr[dir].name)); /* was temp */
    parm->special.special_field=arcname;
   }
  }
 }
 return(err);
}




static void setstat(fstat * stat,FSEntry_File_Parameter * parm)
{
 stat->load=(int)parm->info.load_exec.load_address;
 stat->exec=(int)parm->info.load_exec.execute_address;
 stat->acc=DEFATT;
 stat->length=parm->extras.location.end-parm->extras.location.start;
}



_kernel_oserror * CreateFile(int acn,FSEntry_File_Parameter * parm)
{
 _kernel_oserror * err;
 int               ins;
 int               ow;
 int               ind;
 fstat             stat;
 char            * tempname;

 err=findins(acn,arcpath,&ins,&ow,&ind);
 if(!err && ins>=0)
 {
  if(ow) err=deleteable(acn,ins);
  if(!err)
  {
   setstat(&stat,parm);

   tempname=leaf(arcpath);

   err=createfile(acn,tempname,ins,ow,ind,&stat);

   if(!err)
   {
    parm->special.special_field=tempname;
   }
  }
 }
 return(err);
}



_kernel_oserror * CreateDirectory(int acn,FSEntry_File_Parameter * parm)
{
_kernel_oserror * err;
 int ins;
 int ind;
 int ow;

 err=findins(acn,arcpath,&ins,&ow,&ind);
 if(!err && ins>=0)
 {
  err=createdir(acn,arcpath,ins,ow,ind);
 }
 return(err);
 USE(parm);
}



_kernel_oserror * SaveFile(int acn,FSEntry_File_Parameter * parm)
{
 _kernel_oserror * err;
 int               ins;
 int               ow;
 int               ind; 
 char            * start;
 char            * tempname;
 fstat             stat;

 err=findins(acn,arcpath,&ins,&ow,&ind);
 if(!err && ins>=0)
 {
  if(ow) err=deleteable(acn,ins);
  if(!err)
  {
   setstat(&stat,parm);
   start=parm->extras.location.start;

   tempname=leaf(arcpath);

   err=savefile(acn,tempname,ins,ow,ind,&stat,start);

   if(!err)
   {
    parm->special.special_field=tempname;
   }
  }
 }
 return(err);
}



_kernel_oserror * WriteCatalogueInformation(int acn,
                                            FSEntry_File_Parameter * parm)
{
 _kernel_oserror * err;
 int               dir;

 err=findpath(acn,arcpath,&dir,0);
 if(!err)
 {
  if(dir>=0)   /* don't raise an error if not found */
  {
   err=writecatinfo(acn,dir);
   if(!err)
   {
    arc[acn].hdr[dir].load=(int)parm->info.load_exec.load_address;
    arc[acn].hdr[dir].exec=(int)parm->info.load_exec.execute_address;
    arc[acn].hdr[dir].acc=(int)parm->extras.info.attributes;
    err=updatecat(acn,dir);
    if(!err) updatefsmap(acn,dir);
   }
  }
 }
 return(err);
}





_kernel_oserror * ReadCatalogueInformation(int acn,
                                               FSEntry_File_Parameter * parm)
{
 _kernel_oserror * err;
 int               dir;

 parm->reason=(FSEntry_File_Reason)0;

 err=findpath(acn,arcpath,&dir,0);

#ifdef DODEBUG
 deb("path=%s name=%s dir=%d",arcpath,arcname,dir); 
#endif

 if(!err)
 {
  if(dir<-1) /* not found */
  {
   parm->reason=(FSEntry_File_Reason)0;
  }
  else
  if(dir==-1) /* $ */
  {
   parm->info.load_exec.load_address=parm->info.load_exec.execute_address=0;
   parm->extras.info.length=0;
   parm->extras.info.attributes=DEFATT;
   parm->reason=(FSEntry_File_Reason)2;
  }
  else
  {
   parm->reason=(FSEntry_File_Reason)((arc[acn].hdr[dir].dirn>=0 || 
                                      arc[acn].hdr[dir].dirn==-2)+1);

   parm->info.load_exec.load_address=(char*)arc[acn].hdr[dir].load;
   parm->info.load_exec.execute_address=(char*)arc[acn].hdr[dir].exec;
   parm->extras.info.length=arc[acn].hdr[dir].length;
   parm->extras.info.attributes=arc[acn].hdr[dir].acc;

/*
   deb("res=%d load=%x exec=%d len=%d att=%x imfh=%d",
         parm->reason,parm->info.load_exec.load_address,parm->info.load_exec.execute_address,parm->extras.info.length,parm->extras.info.attributes,parm->special.imfh);
*/

  }
 }
 return(err);
}





_kernel_oserror * DeleteObject(int acn,FSEntry_File_Parameter * parm)
{
 _kernel_oserror * err;
 int dir;

 err=findpath(acn,arcpath,&dir,0);
 if(!err)
 {
  if(dir>=0)
  {
   err=deleteable(acn,dir);
   if(!err)
   {
    parm->info.load_exec.load_address=(char*)arc[acn].hdr[dir].load;
    parm->info.load_exec.execute_address=(char*)arc[acn].hdr[dir].exec;
    parm->extras.info.length=arc[acn].hdr[dir].length;
    parm->extras.info.attributes=arc[acn].hdr[dir].acc;

     /* delete object */

    err=deletefile(acn,dir);
   }
  }
 }
 return(err);
}

