/*->c.update */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"


#include "Consts.h"
#include "RMInfo.h"
#include "veneers.h"
#include "Interface.h"
#include "fsentries.h"
#include "ModuleWrap.h"


#include "h.flex"
#include "h.xstr"
#include "h.csfserr"
#include "h.str"
#include "h.csfs"
#include "h.etc"
#include "h.arcs"
#include "h.dir"
#include "h.cat"
#include "h.fs"
#include "h.sff"
#include "h.sfs"
#include "h.link"
#include "h.mem"
#include "h.fx"
#include "h.scrap"
#include "h.service"
#include "h.serx"
#include "h.mount"



#include "h.update"






#if 0
/*
 * recursive function to dump the contents of the flat file header structure
 * call the function dump_struct
 */
void dump_entries(int acn, int num_entries, int *n,int level);

void
dump_entries (int acn, int num_entries, int *n,int level)
{
  int i=0;
  int j;

  for (j=0; j<level*3; j++)
    printf(" ");

  printf("directory %d entries\n",num_entries);
  while (i<num_entries)
  {
    for (j=0; j<level*3; j++)
      printf(" ");
    printf("%2d : %15s %3d\n",*n,arc[acn].hdr[*n].name,arc[acn].hdr[*n].dirn);
    (*n)++;
    if (arc[acn].hdr[(*n)-1].dirn>0)
      dump_entries(acn, arc[acn].hdr[(*n)-1].dirn, n,level+1);

    i++;
  }
}
void
dump_struct(int acn)
{
  int i=0;

  dump_entries(acn,arc[acn].fmain,&i,0);
}
#endif

/*
 * If a file exists on the server but not in the cache then it is down-loaded
 * to the client.
 *
 * If the date stamp of a cached file is older than the date stamp of the
 * equivalent file on the server then the file is down-loaded to the client.
 *
 * If the -upload flag is used then a cached file which has a date stamp
 * which is later than the date stamp of the equivalent file on the server is
 * uploaded to the server.
 *
 * If the -upload flag is used then a file that exists in the cache and
 * not on the server is uploaded  to the server.
 *
 * If the -upload flag is not used and a file exists in the cache but not
 * on the server. The cache file should be deleted.
 *
 * The operation is recursive across all files. All files down-loaded by
 * the update command are locked against deletion in the underlying cache.
 */


static _kernel_oserror * syncdir(int acn,int dir,int bits)
{
 _kernel_oserror * err;
 heads           * hdr;
 int               size;
 int               i;
 int               j;
 int               n;
 int               code;
 int               incn;
 int               dsize;
 int               check;
 int               name;


/* printf("CSFS: syncronise %s (%d)\n",
          (dir>=0)?stringptr(arc[acn].hdr[dir].name):"$",dir); */

 check=(arc[acn].hdr[dir].dirn!=DFLAT);
 hdr=NULL;

 err=diropen(acn,dir);
 if(!err)
 {
  if(check) err=servicegetdir(acn,dir,&hdr,&size);
 }


 if(!err)
 {
  j=0;
  n=dir+1;
  for(i=0;i<((dir<0)?arc[acn].fmain:arc[acn].hdr[dir].dirn);i++)
  {
   incn=1;

   if(!check) code=0;
   else
   if(j<size)
     code=cstrcmp(stringptr(arc[acn].hdr[n].name),stringptr(hdr[j].name));
   else
     code=-1;

   if(code==0)
   {     /* same names - check time stamps */
/*     printf("CSFS: same\n"); */

    if(arc[acn].hdr[n].dirn==DNFILE && (!check || hdr[j].dirn==DNFILE))
    {
     if(!check) code=-1;
     else
     {
      code=(arc[acn].hdr[n].load & 0xFF)-(hdr[j].load & 0xFF);
      if(!code) code=arc[acn].hdr[n].exec-hdr[j].exec;
     }

     if(code>0) /* client is newer than server */
     {
      if((bits & CSFS_UPDATE) && !(bits & CSFS_REFRESH))
      {
       if(arc[acn].hdr[n].sn) err=serviceputfile(acn,n);
      }
     }
     else
     if(code<0 || !arc[acn].hdr[n].sn) /* client is older than server */
     {
      if(!(bits & CSFS_REFRESH))
      {
       if(!arc[acn].hdr[n].sn) err=sc_create(&arc[acn].hdr[n].sn);
       else                    err=fs_lock(sc_name(arc[acn].hdr[n].sn),DEFATT);
       if(!err) err=servicegetfile(acn,n);
       if(!err) err=fs_lock(sc_name(arc[acn].hdr[n].sn),DEFATT|LOCK);
      }
      else
      if(code<0 && check)
      {
       removesn(acn,n);

       name=arc[acn].hdr[n].name;
       arc[acn].hdr[n]=hdr[j];
       arc[acn].hdr[n].name=name;
      }
     }
    }

    j++;
   }
   else
   if(code>0)
   {
   /* printf("CSFS: insert\n"); */

    dupstring(hdr[j].name,&name);
    insentry(acn,n,dir,1);
    arc[acn].hdr[n]=hdr[j];
    arc[acn].hdr[n].name=name;

    if(arc[acn].hdr[n].dirn==DNFILE)
    {
     if(!(bits & CSFS_REFRESH))
     {
               err=sc_create(&arc[acn].hdr[n].sn);
      if(!err) err=servicegetfile(acn,n);
      if(!err) err=fs_lock(sc_name(arc[acn].hdr[n].sn),DEFATT|LOCK);
     }
    }
    j++;
   }
   else  /* local entry which is not on server */
   {
/*     printf("CSFS: missing\n");  */
    if(bits & CSFS_UPDATE)
    {
     if(arc[acn].hdr[n].dirn==DNFILE)
     {
      if(arc[acn].hdr[n].sn) err=serviceputfile(acn,n);
     }
     else
     {
      err=servicemkdir(acn,n);
     }
    }
    else
    {
     if(arc[acn].hdr[n].dirn>=0) dsize=noindir(acn,n)+1;
     else                        dsize=1;
     scrapentry(acn,n,dsize);
     rementry(&arc[acn],n,dsize);
     i--;
     incn=0;
    }
   }


   if(incn)
   {
    if(arc[acn].hdr[n].dirn>=0)
    {
     n+=noindir(acn,n)+1;
    }
    else
     n++;
   }

   if(err) break;
  }


  if(!err && check)
  {
   while(j<size)
   {
/*     printf("CSFS: adding %s\n",hdr[j].name); */

    dupstring(hdr[j].name,&name);
    insentry(acn,n,dir,1);
    arc[acn].hdr[n]=hdr[j];
    arc[acn].hdr[n].name=name;

    if(arc[acn].hdr[n].dirn==DNFILE)
    {
     if(!(bits & CSFS_REFRESH))
     {
      err=sc_create(&arc[acn].hdr[n].sn);
      if(!err) err=servicegetfile(acn,n);
      if(!err) err=fs_lock(sc_name(arc[acn].hdr[n].sn),DEFATT|LOCK);
     }
    }
    n++;
    j++;
   }
  }
 }

 if(hdr)
 {
  for(i=0;i<size;i++) rmstring(hdr[i].name);
  flex_free((flex_ptr)&hdr);
 }

/*  printf("CSFS: leaving syncdir()\n");  */

 return(err);
}


static _kernel_oserror * updatedir(int acn,int dir,int bits)
{
 _kernel_oserror * err;
 int               i;
 int               level;
 int               ln;
 int               in;
 int               pn;
 int               n;


 err=syncdir(acn,dir,bits);
 if(!err)
 {
  level=1;
  in=0;
  if(dir<0) ln=arc[acn].fmain;
  else      ln=arc[acn].hdr[dir].dirn;
  pn=dir;
  n=dir+1;

  while(level>0)
  {
   for(i=in;i<ln;i++)
   {
    if(arc[acn].hdr[n].dirn>=0 || arc[acn].hdr[n].dirn==DFLAT)
    {
     err=syncdir(acn,n,bits);
     if(err) break;

     posn2[level]=pn;
     lno2[level]=ln;
     fpos2[level]=i;
     pn=n;
     i=0;
     in=0;
     ln=arc[acn].hdr[n].dirn+1;
     levelstackcheck(++level);
    }
    n++;
   }

   if(err) break;

   level--;

   if(level)
   {
    pn=posn2[level];
    ln=lno2[level];
    in=fpos2[level]+1;
   }
  }
 }
 return(err);
}




static _kernel_oserror * updates(char * path,int bits)
{
 _kernel_oserror * err;
 int               acn;
 int               fn;
 char              buffer[NAMELEN];

 err=fs_canonicalpath(path,buffer,sizeof(buffer),NULL,NULL);

 err=makepath(buffer,NULL,1,&acn);
 if(!err)
 {
  err=findpath(acn,arcpath,&fn,0);

  if(fn<-1) err=geterror(err_FileNotFound);  /* Not found */
  if(!err)
  {
   err=updatedir(acn,fn,bits);
   updatedirupcall(acn,fn);
  }
 }

 return(err);
}




/*

CSFS_Update (SWI &4E985)

Make cached file system directory and server directory consistent.


On entry
        R0 = Flags
                Bit     Meaning when set
                0       Upload modified files to server directory
                1-31    Reserved (must be 0)
        R1 = Pointer to null terminated CSFS path
On exit
        All registers preserved


*/



_kernel_oserror * updateswi(_kernel_swi_regs * r)
{
 return(updates((char*)r->r[1],r->r[0]));
}



/* update [-upload] <path> */


_kernel_oserror * updatecommand(char * args[],int argc)
{
 _kernel_oserror * err;
 int               bits;
 int               u0;
 int               u1;

 bits=0;

 u0=!cstrcmp(args[0],"-upload");
 u1=(argc==2) && !cstrcmp(args[1],"-upload");

 if((u0 && u1) || (u0 && argc<2)) err=geterror(err_BadUpdate);
 else
 {
  if(u0 || u1) bits|=CSFS_UPDATE;

  err=updates((u0?args[1]:args[0]),bits);
 }

 return(err);
}





/****************************************************************************/



static _kernel_oserror * releasedir(int acn,int dir)
{
 _kernel_oserror * err;
 int               i;
 int               level;
 int               ln;
 int               in;
 int               pn;
 int               n;
 char            * p;


 err=diropen(acn,dir);
 if(!err)
 {
  level=1;
  in=0;
  if(dir<0) ln=arc[acn].fmain;
  else      ln=arc[acn].hdr[dir].dirn;
  pn=dir;
  n=dir+1;

  while(level>0)
  {
   for(i=in;i<ln;i++)
   {
    if(arc[acn].hdr[n].dirn>=0 || arc[acn].hdr[n].dirn==DFLAT)
    {
     err=diropen(acn,dir);
     if(err) break;

     posn[level]=pn;
     lno[level]=ln;
     fpos[level]=i;
     pn=n;
     i=0;
     in=0;
     ln=arc[acn].hdr[n].dirn+1;
     levelstackcheck(++level);
    }
    else
    if(arc[acn].hdr[n].sn)
    {
     p=sc_name(arc[acn].hdr[n].sn);
     if(fexists(p))
     {
      fs_lock(p,DEFATT);
     }
    }

    n++;
   }

   if(err) break;

   level--;

   if(level)
   {
    pn=posn[level];
    ln=lno[level];
    in=fpos[level]+1;
   }
  }
 }

 return(err);
}








static _kernel_oserror * releases(char * path)
{
 _kernel_oserror * err;
 int               acn;
 int               fn;
 char              buffer[NAMELEN];

 err=fs_canonicalpath(path,buffer,sizeof(buffer),NULL,NULL);

 err=makepath(buffer,NULL,1,&acn);
 if(!err)
 {
  err=findpath(acn,arcpath,&fn,0);

  if(fn<-1) err=geterror(err_FileNotFound);  /* Not found */
  if(!err)
  {
   err=releasedir(acn,fn);
  }
 }

 return(err);
}




/*

CSFS_Release (SWI &4E986) 

Release lock on cached files.


On entry
        R0 = Flags (must be 0)
        R1 = Pointer to null terminated CSFS path
On exit
        All registers preserved

*/



_kernel_oserror * releaseswi(_kernel_swi_regs * r)
{
 return(releases((char*)r->r[1]));
}




/* release <path> */


_kernel_oserror * releasecommand(char * args[],int argc)
{
 return(releases(args[0]));
 USE(argc);
}



/****************************************************************************/



/*

CSFS_ReFresh (SWI &4E987) 

Update directory listing cache.


On entry
        R0 = Flags (must be 0)
        R1 = Pointer to null terminated CSFS path
On exit
        All registers preserved

*/




_kernel_oserror * refreshswi(_kernel_swi_regs * r)
{
 return(updates((char*)r->r[1],CSFS_REFRESH));
}



/* release <path> */


_kernel_oserror * refreshcommand(char * args[],int argc)
{
 return(updates(args[0],CSFS_REFRESH));
 USE(argc);
}




