/*->c.update */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"


#include "Consts.h"
#include "AllErrs.h"
#include "RMInfo.h"
#include "Statics.h"
#include "veneers.h"
#include "Interface.h"
#include "fsentries.h"
#include "ModuleWrap.h"


#include "h.flex"
#include "h.xstr"

#include "h.str"
#include "h.csfs"
#include "h.etc"
#include "h.allerrs"
#include "h.arcs"
#include "h.dir"
#include "h.cat"
#include "h.fs"
#include "h.sff"
#include "h.sfs"
#include "h.link"
#include "h.mem"
#include "h.fx"
#include "h.scrap"
#include "h.service"
#include "h.serx"
#include "h.mount"



#include "h.update"






static _kernel_oserror * scrapentry(int acn,int n,int size)
{
 _kernel_oserror * err;
 char            * p;

 err=NULL;

 while(size--)
 {
  rmstring(arc[acn].hdr[n].name);

  if(arc[acn].hdr[n].sn)
  {
   p=sc_name(arc[acn].hdr[n].sn);
   if(fexists(p))
   {
    fs_lock(p,DEFATT);
    delete(p);
   }
   sc_remove(arc[acn].hdr[n].sn,NULL);
  }
  n++;
 }

 return(err);
}


#if 0
/*
 * recursive function to dump the contents of the flat file header structure
 * call the function dump_struct
 */
void dump_entries(int acn, int num_entries, int *n,int level);

void
dump_entries (int acn, int num_entries, int *n,int level)
{
  int i=0;
  int j;

  for (j=0; j<level*3; j++)
    printf(" ");

  printf("directory %d entries\n",num_entries);
  while (i<num_entries)
  {
    for (j=0; j<level*3; j++)
      printf(" ");
    printf("%2d : %15s %3d\n",*n,arc[acn].hdr[*n].name,arc[acn].hdr[*n].dirn);
    (*n)++;
    if (arc[acn].hdr[(*n)-1].dirn>0)
      dump_entries(acn, arc[acn].hdr[(*n)-1].dirn, n,level+1);

    i++;
  }
}
void
dump_struct(int acn)
{
  int i=0;

  dump_entries(acn,arc[acn].fmain,&i,0);
}
#endif

/*
 * If a file exists on the server but not in the cache then it is down-loaded
 * to the client.
 *
 * If the date stamp of a cached file is older than the date stamp of the
 * equivalent file on the server then the file is down-loaded to the client.
 *
 * If the -upload flag is used then a cached file which has a date stamp
 * which is later than the date stamp of the equivalent file on the server is
 * uploaded to the server.
 *
 * If the -upload flag is used then a file that exists in the cache and
 * not on the server is uploaded  to the server.
 *
 * If the -upload flag is not used and a file exists in the cache but not
 * on the server. The cache file should be deleted.
 *
 * The operation is recursive across all files. All files down-loaded by
 * the update command are locked against deletion in the underlying cache.
 */
static _kernel_oserror * syncdir(int acn,int dir,int bits)
{
 _kernel_oserror * err;
 heads           * hdr;
 int               size;
 int               i;
 int               j;
 int               n;
 int               code;
 int               incn;
 int               dsize;

/* printf("CSFS: syncronise %s (%d)\n",(dir>=0)?arc[acn].hdr[dir].name:"$",dir);*/
 
 err=servicegetdir(acn,dir,&hdr,&size);
/*  dump_struct(acn); */
 if(!err)
 {

  j=0;
  n=dir+1;
  for(i=0;i<((dir<0)?arc[acn].fmain:arc[acn].hdr[dir].dirn);i++)
  {
   incn=1;

   if(j<size)
     code=cstrcmp(stringptr(arc[acn].hdr[n].name),stringptr(hdr[j].name));
   else
     code=-1;

   if(code==0)
   {     /* same names - check time stamps */
/*     printf("CSFS: same\n"); */

    if(arc[acn].hdr[n].dirn==DNFILE && hdr[j].dirn==DNFILE)
    {
     code=(arc[acn].hdr[n].load & 0xFF)-(hdr[j].load & 0xFF);
     if(!code) code=arc[acn].hdr[n].exec-hdr[j].exec;

     if(code>0) /* client is newer than server */
     {
      if(bits & CSFS_UPDATE)
      {
       if(arc[acn].hdr[n].sn) err=serviceputfile(acn,n);
      }
     }
     else
     if(code<0 || !arc[acn].hdr[n].sn) /* client is older than server */
     {
      if(!arc[acn].hdr[n].sn) err=sc_create(&arc[acn].hdr[n].sn);
      else                    err=fs_lock(sc_name(arc[acn].hdr[n].sn),DEFATT);
      if(!err) err=servicegetfile(acn,n);
      if(!err) err=fs_lock(sc_name(arc[acn].hdr[n].sn),DEFATT|LOCK);
     }
    }

    j++;
   }
   else
   if(code>0)
   {
/*     printf("CSFS: insert\n"); */
    insentry(acn,n,dir,1);
    arc[acn].hdr[n]=hdr[j];
    if(arc[acn].hdr[n].dirn==DNFILE)
    {
     err=sc_create(&arc[acn].hdr[n].sn);
     if(!err) err=servicegetfile(acn,n);
     if(!err) err=fs_lock(sc_name(arc[acn].hdr[n].sn),DEFATT|LOCK);
    }
    j++;
   }
   else  /* local entry which is not on server */
   {
/*     printf("CSFS: missing\n"); */
    if(bits & CSFS_UPDATE)
    {
     if(arc[acn].hdr[n].dirn==DNFILE)
     {
      if(arc[acn].hdr[n].sn) err=serviceputfile(acn,n);
     }
     else
     {
      err=servicemkdir(acn,n);
     }
    }
    else
    {
     if(arc[acn].hdr[n].dirn>=0) dsize=noindir(acn,n)+1;
     else                        dsize=1;
     scrapentry(acn,n,dsize);
     rementry(&arc[acn],n,dsize);
     i--;
     incn=0;
    }
   }

   if(incn)
   {
    if(arc[acn].hdr[n].dirn>=0)
    {
     n+=noindir(acn,n)+1;
    }
    else
     n++;
   }

   if(err) break;
  }

  if(!err)
  {
   while(j<size)
   {
/*     printf("CSFS: adding %s\n",hdr[j].name); */
    insentry(acn,n,dir,1);
    arc[acn].hdr[n]=hdr[j];
    if(arc[acn].hdr[n].dirn==DNFILE)
    {
     err=sc_create(&arc[acn].hdr[n].sn);
     if(!err) err=servicegetfile(acn,n);
     if(!err) err=fs_lock(sc_name(arc[acn].hdr[n].sn),DEFATT|LOCK);
    }
    n++;
    j++;
   }
  }
 }

 if(hdr)
 {
  for(i=0;i<size;i++) rmstring(hdr[i].name);
  flex_free((flex_ptr)&hdr);
 }

/*  printf("CSFS: leaving syncdir()\n"); */

 return(err);
}


static _kernel_oserror * updatedir(int acn,int dir,int bits)
{
 _kernel_oserror * err;
 int               i;
 int               level;
 int               ln;
 int               in;
 int               pn;
 int               n;


 err=diropen(acn,dir);
 if (!err)
 {
   err=syncdir(acn,dir,bits);
   if(!err)
   {
    level=1;
    in=0;
    if(dir<0)
      ln=arc[acn].fmain;
    else
      ln=arc[acn].hdr[dir].dirn;
    pn=dir;
    n=dir+1;

    do
    {
/*      printf("CSFS: level=%d in=%d ln=%d\n",level,in,ln);  */

     for(i=in;i<ln;i++)
     {
/*       printf("CSFS: n=%d i=%d fm=%d\n",n,i,arc[acn].fmain); */
      if(arc[acn].hdr[n].dirn>=0 || arc[acn].hdr[n].dirn==DFLAT)
      {
       err=diropen(acn,n);
       if(err) break;

       err=syncdir(acn,n,bits);
       if(err) break;

       posn[level]=pn;
       lno[level]=ln;
       fpos[level]=i;
       pn=n;
       i=0;
       in=0;
       ln=arc[acn].hdr[n].dirn+1;
       level++;
      }
      n++;
     }

     if(err) break;

     level--;
     if(level)
     {
      pn=posn[level];
      ln=lno[level];
      in=fpos[level]+1;
     }
    } while(level>0);
   }
 }

 return(err);
}




static _kernel_oserror * updates(char * path,int bits)
{
 _kernel_oserror * err;
 int               acn;
 int               fn;
 char              buffer[NAMELEN];


 err=fs_canonicalpath(path,buffer,sizeof(buffer),NULL,NULL);

/* printf("path=%s\n",path);
 printf("buffer=%s\n",buffer); */

 err=makepath(buffer,NULL,0,&acn);
 if(!err)
 {
  {
   err=findpath(acn,arcpath,&fn,0);
   if(fn<-1) err=&mb_sfserr_FileNotFound;  /* Not found */
   if(!err)
   {
/*    printf("path=%s name=%s\n",arcpath,arcname);
    printf("acn=%d fn=%d\n",acn,fn); */

    err=updatedir(acn,fn,bits);
    updatedirupcall(acn,fn);
   }
  }
 }

 return(err);
}




/*

CSFS_Update (SWI &4E985)

Make cached file system directory and server directory consistent.


On entry
        R0 = Flags
                Bit     Meaning when set
                0       Upload modified files to server directory
                1-31    Reserved (must be 0)
        R1 = Pointer to null terminated CSFS path
On exit
        All registers preserved


*/



_kernel_oserror * updateswi(_kernel_swi_regs * r)
{
 return(updates((char*)r->r[1],r->r[0]));
}



/* update [-upload] <path> */


_kernel_oserror * updatecommand(char * args[],int argc)
{
 _kernel_oserror * err;
 int               bits;
 int               u0;
 int               u1;

 bits=0;

 u0=!cstrcmp(args[0],"-upload");
 u1=(argc==2) && !cstrcmp(args[1],"-upload");

 if((u0 && u1) || (u0 && argc<2)) err=&mb_sfserr_BadUpdate;
 else
 {
  if(u0 || u1) bits|=CSFS_UPDATE;

  err=updates((u0?args[1]:args[0]),bits);
 }

 return(err);
}




