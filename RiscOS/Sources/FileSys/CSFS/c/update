/*->c.update */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"


#include "Consts.h"
#include "RMInfo.h"
#include "veneers.h"
#include "Interface.h"
#include "fsentries.h"
#include "ModuleWrap.h"


#include "h.flex"
#include "h.xstr"
#include "h.csfserr"
#include "h.str"
#include "h.csfs"
#include "h.etc"
#include "h.arcs"
#include "h.dir"
#include "h.cat"
#include "h.fs"
#include "h.sff"
#include "h.sfs"
#include "h.link"
#include "h.mem"
#include "h.fx"
#include "h.scrap"
#include "h.service"
#include "h.serx"
#include "h.mount"



#include "h.update"






#if 0
/*
 * recursive function to dump the contents of the flat file header structure
 * call the function dump_struct
 */
char dump_tabs[40];

void dump_entries(int acn, int num_entries, int *n,int level);

void
dump_entries (int acn, int num_entries, int *n,int level)
{
  int i=0;
  int j;

  dump_tabs[0]='\0';
  for (j=0; j<level*3; j++)
    strcat(dump_tabs," ");

  debug_printf(db,"(7) %sdirectory %d entries\n",dump_tabs,num_entries);
  while (i<num_entries)
  {
    dump_tabs[0]='\0';
    for (j=0; j<level*3; j++)
      strcat(dump_tabs," ");

    debug_printf(db,"(7) %s%2d : %15s %3d\n",dump_tabs,*n,
    			   stringptr(arc[acn].hdr[*n].name),arc[acn].hdr[*n].dirn);
    (*n)++;
    if (arc[acn].hdr[(*n)-1].dirn>0)
      dump_entries(acn, arc[acn].hdr[(*n)-1].dirn, n,level+1);

    i++;
  }
}
void
dump_struct(int acn)
{
  int i=0;

  dump_entries(acn,arc[acn].fmain,&i,0);
}
#endif

/*
 * If a file exists on the server but not in the cache then it is down-loaded
 * to the client.
 *
 * If the date stamp of a cached file is older than the date stamp of the
 * equivalent file on the server then the file is down-loaded to the client.
 *
 * If the -upload flag is used then a cached file which has a date stamp
 * which is later than the date stamp of the equivalent file on the server is
 * uploaded to the server.
 *
 * If the -upload flag is used then a file that exists in the cache and
 * not on the server is uploaded  to the server.
 *
 * If the -upload flag is not used and a file exists in the cache but not
 * on the server. The cache file should be deleted.
 *
 * The operation is recursive across all files. All files down-loaded by
 * the update command are locked against deletion in the underlying cache.
 */


static _kernel_oserror * syncdir(int acn,int dir,int bits)
{
 _kernel_oserror * err;
 heads           * hdr;
 int               size;
 int               i;
 int               j;
 int               n;
 int               code;
 int               incn;
 int               dsize;
 int               check;
 int               name;

 debug_printf(db,"(7) syncdir");

 check=(arc[acn].hdr[dir].dirn!=DFLAT);
 hdr=NULL;

 err=diropen(acn,dir);
 if(!err)
 {
  if(check) err=servicegetdir(acn,dir,&hdr,&size);
 }


 if(!err)
 {
  j=0;
  n=dir+1;
  for(i=0;i<((dir<0)?arc[acn].fmain:arc[acn].hdr[dir].dirn);i++)
  {
   incn=1;

   if(!check) code=0;
   else
   if(j<size)
     code=cstrcmp(stringptr(arc[acn].hdr[n].name),stringptr(hdr[j].name));
   else
     code=-1;

   if(code==0)
   {     /* same names - check time stamps */
    if(arc[acn].hdr[n].dirn==DNFILE && (!check || hdr[j].dirn==DNFILE))
    {
     if(!check) code=-1;
     else
     {
      code=(arc[acn].hdr[n].load & 0xFF)-(hdr[j].load & 0xFF);
      if(!code) code=arc[acn].hdr[n].exec-hdr[j].exec;
     }

     if(code>0) /* client is newer than server */
     {
      if((bits & CSFS_UPDATE) && !(bits & CSFS_REFRESH))
      {
       if(arc[acn].hdr[n].sn) arc[acn].hdr[n].put=1;
      }
     }
     else
     if(code<0 || !arc[acn].hdr[n].sn) /* client is older than server */
     {
      if(!(bits & CSFS_REFRESH))
      {
       arc[acn].hdr[n].get=1;
      }
      else
      if(code<0 && check)
      {
       removesn(acn,n);

       name=arc[acn].hdr[n].name;
       arc[acn].hdr[n]=hdr[j];
       arc[acn].hdr[n].name=name;
      }
     }
    }

    j++;
   }
   else
   if(code>0)
   {
    debug_printf(db,"(7)  insert somthing");

    dupstring(hdr[j].name,&name);
    insentry(acn,n,dir,1);
    arc[acn].hdr[n]=hdr[j];
    arc[acn].hdr[n].name=name;

    if(arc[acn].hdr[n].dirn==DNFILE)
    {
     if(!(bits & CSFS_REFRESH))
     {
      arc[acn].hdr[n].get=1;
     }
    }
    j++;
   }
   else  /* local entry which is not on server */
   {
    debug_printf(db,"(7)  entry missing");
    if(bits & CSFS_UPDATE)
    {
     if(arc[acn].hdr[n].dirn==DNFILE)
     {
      if(arc[acn].hdr[n].sn) arc[acn].hdr[n].put=1;
     }
     else
     {
      err=servicemkdir(acn,n);
     }
    }
    else
    {
     if(arc[acn].hdr[n].dirn>=0) dsize=noindir(acn,n)+1;
     else                        dsize=1;
     scrapentry(acn,n,dsize);
     rementry(&arc[acn],n,dsize);
     i--;
     incn=0;
    }
   }


   if(incn)
   {
    if(arc[acn].hdr[n].dirn>=0)
    {
     n+=noindir(acn,n)+1;
    }
    else
     n++;
   }

   if(err) break;
  }


  if(!err && check)
  {
   while(j<size)
   {
    debug_printf(db,"(7)  adding %s",stringptr(hdr[j].name));

    dupstring(hdr[j].name,&name);
    insentry(acn,n,dir,1);
    arc[acn].hdr[n]=hdr[j];
    arc[acn].hdr[n].name=name;

    if(arc[acn].hdr[n].dirn==DNFILE)
    {
     if(!(bits & CSFS_REFRESH))
     {
      arc[acn].hdr[n].get=1;
     }
    }
    n++;
    j++;
   }
  }
 }

 if(hdr)
 {
  for(i=0;i<size;i++) rmstring(hdr[i].name);
  flex_free((flex_ptr)&hdr);
 }

/*  printf("CSFS: leaving syncdir()\n");  */

 return(err);
}


static _kernel_oserror * updatedir(int acn,int dir,int bits)
{
 _kernel_oserror * err;
 int               i;
 int               level;
 int               ln;
 int               in;
 int               pn;
 int               n;
 unsigned int      sum;
 int               sn;


 for(i=0;i<arc[acn].nofiles;i++)
 {
  arc[acn].hdr[i].get=arc[acn].hdr[i].put=0;
 }

 debug_printf(db,"(7) updatedir");

 err=syncdir(acn,dir,bits);
 if(!err)
 {
  level=1;
  in=0;
  if(dir<0) ln=arc[acn].fmain;
  else      ln=arc[acn].hdr[dir].dirn;
  pn=dir;
  n=dir+1;

  while(level>0)
  {
   for(i=in;i<ln;i++)
   {
    if(arc[acn].hdr[n].dirn>=0 || arc[acn].hdr[n].dirn==DFLAT)
    {
     err=syncdir(acn,n,bits);
     if(err) break;

     posn2[level]=pn;
     lno2[level]=ln;
     fpos2[level]=i;
     pn=n;
     i=0;
     in=0;
     ln=arc[acn].hdr[n].dirn+1;
     levelstackcheck(++level);
    }
    n++;
   }

   if(err) break;

   level--;

   if(level)
   {
    pn=posn2[level];
    ln=lno2[level];
    in=fpos2[level]+1;
   }
  }
 }


 if(!(bits & CSFS_REFRESH))
 {
  if(!err)
  {
   sum=0;

   for(i=0;i<arc[acn].nofiles;i++)
   {
    if(arc[acn].hdr[i].get) sum+=arc[acn].hdr[i].length;
    if(arc[acn].hdr[i].put) sum+=arc[acn].hdr[i].length;
   }
  }


  if(!err)
  {
    unsigned int sofar=0;
    _swix(Hourglass_On,0);
    for(i=0;i<arc[acn].nofiles;i++)
    {
      if(arc[acn].hdr[i].get)
      {
        if(!arc[acn].hdr[i].sn)
        {
          err=sc_create(&sn);
          arc[acn].hdr[i].sn=sn;
        }
        else
          err=fs_lock(sc_name(arc[acn].hdr[i].sn),DEFATT);

        if(!err) err=servicegetfile(acn,i,sum,&sofar);
        if(!err) err=fs_lock(sc_name(arc[acn].hdr[i].sn),DEFATT|LOCK);
      }
      else                    /* don't put and get */
        if(arc[acn].hdr[i].put)
          err=serviceputfile(acn,i,sum,&sofar);

      if(err) break;
    }
    _swix(Hourglass_Off,0);
  }
 }

 return(err);
}




static _kernel_oserror * updates(char * path,int bits)
{
 _kernel_oserror * err;
 int               acn;
 int               fn;
 char              buffer[NAMELEN];


 err=fs_canonicalpath(path,buffer,sizeof(buffer),NULL,NULL);

 debug_printf(db,"(7) update %s",buffer);

 err=makepath(buffer,NULL,1,&acn);
 if(!err)
 {
  err=findpath(acn,arcpath,&fn,0);

  if(fn<-1) err=geterror(err_FileNotFound);  /* Not found */
  if(!err)
  {
   err=updatedir(acn,fn,bits);
   updatedirupcall(acn,fn);
  }
 }

 return(err);
}




/*

CSFS_Update (SWI &4E985)

Make cached file system directory and server directory consistent.


On entry
        R0 = Flags
                Bit     Meaning when set
                0       Upload modified files to server directory
                1-31    Reserved (must be 0)
        R1 = Pointer to null terminated CSFS path
On exit
        All registers preserved


*/



_kernel_oserror * updateswi(_kernel_swi_regs * r)
{
 return(updates((char*)r->r[1],r->r[0]));
}



/*
 * update [-upload] [<path>]
 *
 * if no path specified, pass down null.
 */
_kernel_oserror * updatecommand(char * args[],int argc)
{
  int first_arg=-1;
  int bits=0;
  int i;

  for (i=0; i<argc; i++)
  {
    if (cstrcmp(args[i],"-upload")==0)  /* option */
      bits|=CSFS_UPDATE;
    else if (*args[i]!='-')             /* non-option */
    {
      first_arg = i;
      break;
    }
  }

  return (updates(first_arg!=-1?args[first_arg]:NULL,bits));
}





/****************************************************************************/



static _kernel_oserror * releasedir(int acn,int dir)
{
 _kernel_oserror * err;
 int               i;
 int               level;
 int               ln;
 int               in;
 int               pn;
 int               n;
 char            * p;


 err=diropen(acn,dir);
 if(!err)
 {
  level=1;
  in=0;
  if(dir<0) ln=arc[acn].fmain;
  else      ln=arc[acn].hdr[dir].dirn;
  pn=dir;
  n=dir+1;

  while(level>0)
  {
   for(i=in;i<ln;i++)
   {
    if(arc[acn].hdr[n].dirn>=0 || arc[acn].hdr[n].dirn==DFLAT)
    {
     err=diropen(acn,dir);
     if(err) break;

     posn[level]=pn;
     lno[level]=ln;
     fpos[level]=i;
     pn=n;
     i=0;
     in=0;
     ln=arc[acn].hdr[n].dirn+1;
     levelstackcheck(++level);
    }
    else
    if(arc[acn].hdr[n].sn)
    {
     p=sc_name(arc[acn].hdr[n].sn);
     if(fexists(p))
     {
      fs_lock(p,DEFATT);
     }
    }

    n++;
   }

   if(err) break;

   level--;

   if(level)
   {
    pn=posn[level];
    ln=lno[level];
    in=fpos[level]+1;
   }
  }
 }

 return(err);
}








static _kernel_oserror * releases(char * path)
{
 _kernel_oserror * err;
 int               acn;
 int               fn;
 char              buffer[NAMELEN];

 err=fs_canonicalpath(path,buffer,sizeof(buffer),NULL,NULL);

 debug_printf(db,"(7) release %s",buffer);

 err=makepath(buffer,NULL,1,&acn);
 if(!err)
 {
  err=findpath(acn,arcpath,&fn,0);

  if(fn<-1) err=geterror(err_FileNotFound);  /* Not found */
  if(!err)
  {
   err=releasedir(acn,fn);
  }
 }

 return(err);
}




/*

CSFS_Release (SWI &4E986)

Release lock on cached files.


On entry
        R0 = Flags (must be 0)
        R1 = Pointer to null terminated CSFS path
On exit
        All registers preserved

*/



_kernel_oserror * releaseswi(_kernel_swi_regs * r)
{
 return(releases((char*)r->r[1]));
}




/*
 * release <path>
 *
 * if no path specified, pass down null.
 */
_kernel_oserror * releasecommand(char * args[],int argc)
{
 return (releases(argc==1?args[0]:NULL));
 USE(argc);
}



/****************************************************************************/



/*

CSFS_ReFresh (SWI &4E987)

Update directory listing cache.


On entry
        R0 = Flags (must be 0)
        R1 = Pointer to null terminated CSFS path
On exit
        All registers preserved

*/




_kernel_oserror * refreshswi(_kernel_swi_regs * r)
{
 return(updates((char*)r->r[1],CSFS_REFRESH));
}



/*
 * release <path>
 *
 * if no path specified, pass down null.
 */
_kernel_oserror * refreshcommand(char * args[],int argc)
{
 return(updates(argc==1?args[0]:NULL,CSFS_REFRESH));
 USE(argc);
}




