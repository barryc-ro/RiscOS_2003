/*->c.mount */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdarg.h>


#include "kernel.h"
#include "swis.h"


#include "inetlib.h"
#include "netdb.h"



#include "h.etc"

#include "h.allerrs"
#include "h.consts"

#include "h.flex"
#include "h.xstr"
#include "h.fs"

#include "h.str"
#include "h.csfs"

#include "h.link"
#include "h.arcs"

#include "h.cat"
#include "h.dir"


#include "h.service"
#include "h.mount"



#define WRITECACHE  0x1
#define NAMEADDRESS 0x2






_kernel_oserror * updatedirupcall(int arcn,int ins)
{
 _kernel_oserror * err;
 _kernel_swi_regs  rx;
 char              temp[NAMELEN];

 err=filepathc(temp,arcn,ins);
 if(!err)
 {
  rx.r[0]=3;
  rx.r[1]=(int)temp;
  rx.r[2]=arc[arcn].hdr[ins].load;
  rx.r[3]=arc[arcn].hdr[ins].exec;
  rx.r[4]=arc[arcn].hdr[ins].dirn;
  rx.r[6]=0;
  rx.r[8]=Information_Word;
  rx.r[9]=9;
   
  err=_kernel_swi(OS_UpCall,&rx,&rx);
 }

 return(err);
}




_kernel_oserror * updatefileupcall(int arcn,int ins)
{
 _kernel_oserror * err;
 _kernel_swi_regs  rx;
 char              temp[NAMELEN];

 err=filepathc(temp,arcn,ins);
 if(!err)
 {
  rx.r[0]=3;
  rx.r[1]=(int)temp;
  rx.r[2]=arc[arcn].hdr[ins].load;
  rx.r[3]=arc[arcn].hdr[ins].exec;
  rx.r[5]=arc[arcn].hdr[ins].acc;
  rx.r[6]=0;
  rx.r[8]=Information_Word;
  rx.r[9]=1;
   
  err=_kernel_swi(OS_UpCall,&rx,&rx);
 }

 return(err);
}









static _kernel_oserror * mounts(int bits,
                                char * host,char * service,
                                char * path,char * name,
                                char * user,char * pass)
{
 _kernel_oserror * err;
 int               arcn;
 int               ins;
 int               ind;
 int               ow;
 fstat             stat;
 int               servicen;
 unsigned long     address;
 struct hostent *  xhost;
 char              nullstring[1];
 int               sbits;
 int               s;


 err=NULL;
 nullstring[0]=0;
 if(!service) service=nullstring;
 if(!host && !(bits & NAMEADDRESS)) host=nullstring;
 if(!path)    path=nullstring;
 if(!name)    name=nullstring;
 if(!user)    user=nullstring;
 if(!pass)    pass=nullstring;


 if(!strlen(service)) err=&mb_sfserr_MountService;
 else
 if(!strlen(name))    err=&mb_sfserr_MountName;

 if(!err) err=findservice(&servicen,&sbits,service);
 if(!err)
 {
  if(!(bits & NAMEADDRESS) && !strlen(host) && (sbits & CSFS_NEEDSERVERNAME))
                                          err=&mb_sfserr_MountHost;
  else
  if((!strlen(user) || !strlen(pass))
                   && (sbits & CSFS_NEEDUSERNAME))
                                          err=&mb_sfserr_MountUser;
  else
  if(!strlen(path) && (sbits & CSFS_NEEDMOUNTPATH))
                                          err=&mb_sfserr_MountPath;

  if(bits & NAMEADDRESS) 
  {
   address=(unsigned long)host; 
   host=nullstring;
  }
  else
  {
   if(strlen(host))
   {
    if((xhost=gethostbyname(host))!=NULL)
    {
     memcpy((char*)&address,xhost->h_addr,4);
     address=htonl(address);     /* put in correct byte order */
    }
    else err=&mb_sfserr_NoResolve;
   }
   else
   {
    address=0;
   }
  }


  gethandle(name,&arcn);   /* don't trap error */
  if(!err && arcn>=0) err=&mb_sfserr_MountName2;
  if(!err)
  {
   gethostpath(host,address,path,user,servicen,&arcn);
   if(arcn>=0) err=&mb_sfserr_MountPath2;
  }
  if(!err) err=getarchandle(&arcn);
  if(!err)
  {
   createstring(name,&arc[arcn].name);
   createstring(path,&arc[arcn].mountpath);
   createstring(user,&arc[arcn].user);
   createstring(pass,&arc[arcn].pass);
   createstring(host,&arc[arcn].hostname); 

   arc[arcn].service=servicen;
   arc[arcn].address=address;

   if(bits & WRITECACHE)  arc[arcn].writecache=1;

   if(!err) err=loadarchive(arcn);
   if(!err)
   {
    err=findins(ROOTN,name,&ins,&ow,&ind);
    if(!err && ins>=0)
    {
     insentry(ROOTN,ins,ind,1);
     err=createstring(name,&s);
     arc[ROOTN].hdr[ins].name=s;
     arc[ROOTN].hdr[ins].dirn=0;

     getdeftime(&stat,DATA);
     arc[ROOTN].hdr[ins].load=stat.load;
     arc[ROOTN].hdr[ins].exec=stat.exec;
     arc[ROOTN].hdr[ins].acc=stat.acc|LOCK;

     err=updatedirupcall(ROOTN,ins);
    }
   }
   if(err) losearc(arcn);
  }
 }

 return(err);
}



/*

 mount -service <service name> -name <mount name>
       [-writecache] [-host <host name>]
       [-path <mount path>] 
       [-user <user name>] [-passwd <password>]


*/


_kernel_oserror * mount(char * args[],int argc)
{
 _kernel_oserror  * err;
 char             * name;
 char             * hostname;
 char             * mountpath;
 char             * user;
 char             * pass;
 char             * service;
 int                i;
 int                bits;

 err=NULL;

 bits=0;
 name=NULL;
 hostname=NULL;
 mountpath=NULL;
 user=NULL;
 pass=NULL;
 service=NULL;

 for(i=0;i<argc;i++)
 {
  if(!cstrcmp("-writecache",args[i]))
  {
   bits|=WRITECACHE;
  }
  else
  {
   if(i>=(argc-1)) err=&mb_sfserr_MountMissing;
   else
   if(args[i+1][0]!='-')
   {
    if(!cstrcmp("-service",args[i]))
    {
     service=args[i+1];
    }                                                                               else
    if(!cstrcmp("-host",args[i]))
    {
     hostname=args[i+1];
    }
    else
    if(!cstrcmp("-path",args[i]))
    {
     mountpath=args[i+1];
    }
    else
    if(!cstrcmp("-name",args[i]))
    {
     name=args[i+1];
    }
    else
    if(!cstrcmp("-user",args[i]))
    {
     user=args[i+1];
    }
    else
    if(!cstrcmp("-passwd",args[i]))
    {
     pass=args[i+1];
    }
    else
    {
     err=&mb_sfserr_BadMountParam;
    }
    i++;
   }
  }
  if(err) break;
 }

 if(!err) err=mounts(bits,hostname,service,mountpath,name,user,pass);

 return(err);
}




/*

CSFS_Mount (SWI &4E983) 

Mounts a server directory as a local file system. The input parameters should be verified against the 
service features mask. If any mandatory fields are missing, a suitable error should be generated. Any fields 
not required by the transport service should be set to 0x0.


On entry
        R0 = Flags
                Bit     Meaning when set
                0       Files are write cached, not write through
                1       R2 is a word containing IP address
                2-31    Reserved (must be 0)
        R1 = Pointer to null terminated CSFS service name
        R2 = if Flags bit 1 clear
                 Pointer to null terminated host name
             if Flags bit 1 set
                 Byte coded host IP address (AA.BB.CC.DD => 0xAABBCCDD)
        R3 = Pointer to null terminated mount path
        R4 = Pointer to null terminated mount name
        R5 = Pointer to null terminated user name
        R6 = Pointer to null terminated password
On exit
        All registers preserved


*/



_kernel_oserror * mountswi(_kernel_swi_regs * r)
{
 _kernel_oserror * err;

 err=mounts(r->r[0],(char*)r->r[2],(char*)r->r[1],
                    (char*)r->r[3],(char*)r->r[4],
                    (char*)r->r[5],(char*)r->r[6]);
 return(err);
}



/**************************************************************************/


_kernel_oserror * dismounti(int arcn) 
{
 _kernel_oserror * err;
 _kernel_swi_regs  rx;
 int               ins;
 int               ow;
 int               ind;
 char              temp[NAMELEN];


 err=findins(ROOTN,stringptr(arc[arcn].name),&ins,&ow,&ind);
 if(!err && ins>=0 && ow)
 {
  filepathc(temp,arcn,ins);

  rx.r[0]=3;
  rx.r[1]=(int)temp;
  rx.r[6]=0;
  rx.r[8]=Information_Word;
  rx.r[9]=6;
   
  _kernel_swi(OS_UpCall,&rx,&rx);

  rmstring(arc[ROOTN].hdr[ins].name);
  rementry(&arc[ROOTN],ins,1);

  losearc(arcn);
 }

 return(err);
}




static _kernel_oserror * dismounts(char * name)
{
 _kernel_oserror * err;

 int               arcn;

 err=gethandle(name,&arcn);
 if(!err) err=dismounti(arcn);

 return(err);
}





/*

CSFS_Dismount (SWI &4E984) 

Dismounts a previously mounted server directory.


On entry
        R0 = Flags (must be 0)
        R1 = Pointer to null terminated mount name
On exit
        All registers preserved

*/



_kernel_oserror * dismountswi(_kernel_swi_regs * r)
{
 return(dismounts((char*)r->r[1]));
}


_kernel_oserror * dismount(char * args[],int argc)
{
 return(dismounts(args[0]));
 USE(args);
 USE(argc);
}







