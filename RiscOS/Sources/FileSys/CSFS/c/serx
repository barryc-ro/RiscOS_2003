/*->c.serx */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>



#include "kernel.h"
#include "swis.h"


#include "Consts.h"
#include "AllErrs.h"
#include "RMInfo.h"
#include "Statics.h"
#include "veneers.h"
#include "Interface.h"
#include "fsentries.h"
#include "ModuleWrap.h"


#include "h.flex"

#include "h.str"
#include "h.etc"
#include "h.scrap"
#include "h.fs"
#include "h.sfs"
#include "h.arcs"
#include "h.cat"
#include "h.fx"
#include "h.dir"

#include "h.csfs"

#include "h.link"
#include "h.serx"
#include "h.service"



static _kernel_oserror * getint(char ** pp,int * lop,int * hip)
{
 char * p;
 int    lo;
 int    hi;
 int    c;

 p=*pp;

 if(*p)
 {
  lo=hi=0;

  while(1)
  {
   c=toupper(*p++);
   if(c=='X')
     lo=0;
   else
   {
     if(c<' ') break;

     if(c>='0' && c<='9') c=c-'0';
     else
     if(c>='A' && c<='F') c=10+c-'A';
     else break;

     hi=(hi<<4)|((lo>>28) & 0xF);
     lo=(lo<<4)|c;
   }
  }
  *pp=p;
  if(lop) *lop=lo;
  if(hip) *hip=hi;
 }

 return(NULL);
}









static _kernel_oserror * getstat(fstat * f,char ** pp)
{
 _kernel_oserror * err;
 char            * p;
 char            * r;


 err=NULL;

 memset(f,0,sizeof(fstat));
 p=*pp;

 while(*p)
 {
  if(*p=='#')
  {
   while(*p++>=' ');
  }
  else
  {
   r=f->name;
   while(1)
   {
    if(*p<=' ')
    {
     p++;
     *r=0;
     break;
    }                                                                               else
     *r++=*p++;
   }

   err=getint(&p,&f->length,NULL);
   err=getint(&p,&f->acc,NULL);
   err=getint(&p,&f->object,NULL);
   err=getint(&p,&f->load,NULL);
   err=getint(&p,&f->exec,NULL);

   break;
  }
 }

 *pp=p;

 return(err);
}




#define HCHUNK (16*sizeof(heads))


/*
 * get the contents of directory specified by ind and fill into a temp
 * buffer.
 */
_kernel_oserror * servicegetdir(int acn,int ind,heads ** hdr,int * size)
{
 _kernel_oserror * err;
 char              arcpath[NAMELEN];
 int               sh;
 fstat             f;
 fstat             f1;
 char            * buffer;
 char            * p;
 int               session;
 int               fn;
 int               n;

/*  printf("CSFS: servicegetdir() dir = %d\n",ind); */
 *hdr=NULL;
 err=filepath(arcpath,acn,ind);
 if(!err)
 {
  err=sc_create(&sh);
  if(!err)
  {
   err=opensession(acn,CSFS_GET,arcpath,sc_name(sh),&session,NULL);
   if(!err)
   {
    err=runsession(acn,session,NULL);
    err=closesession(acn,session,err);

    if(!err)
    {
     err=stat(sc_name(sh),&f1);
     if(!err && f1.object)
     {
      err=flex_alloc((flex_ptr)&buffer,f1.length+1);
      if(!err)
      {
       err=loadblock(sc_name(sh),buffer);
       if(!err)
       {
        buffer[f1.length]=0;
        fn=0;
        n=0;
        err=flex_alloc((flex_ptr)hdr,HCHUNK);
        if(!err)
        {
         while(n<f1.length)
         {
          p=buffer+n;
          err=getstat(&f,&p);
          n=p-buffer;

          if(err) break;
          if(!f.object) break;

          err=flex_chunk((flex_ptr)hdr,sizeof(heads)*(fn+1),HCHUNK);
          if(err) break;

          if(f.object)
          {
           memset((*hdr)+fn,0,sizeof(heads));
           strcpy((*hdr)[fn].name,f.name);
           (*hdr)[fn].dirn=(f.object==1)?DNFILE:DFLAT;
           (*hdr)[fn].load=f.load;
           (*hdr)[fn].exec=f.exec;
           (*hdr)[fn].acc =f.acc;
           (*hdr)[fn].length=f.length;
           fn++;
          }
         }
         *size=fn;
        }
        delete(sc_name(sh));
       }
       flex_free((flex_ptr)&buffer);
      }
     }
    }
   }
   err=sc_remove(sh,err);
  }
 }

 return(err);
}

/*
 * get the contents of directory specified by ind and insert entries into
 * the main file header structure.
 */
_kernel_oserror * serviceopendir(int acn,int ind)
{
 _kernel_oserror * err;
 char              arcpath[NAMELEN];
 int               sh;
 fstat             f;
 fstat             f1;
 char            * buffer;
 char            * p;
 int               session;
 int               fn;
 int               n;


/*  printf("CSFS: serviceopendir() %d,%d\n",acn,ind); */
 if(ind>=0) arc[acn].hdr[ind].dirn=0;
 err=filepath(arcpath,acn,ind);
 if(!err)
 {
  err=sc_create(&sh);
  if(!err)
  {
   err=opensession(acn,CSFS_GET,arcpath,sc_name(sh),&session,NULL);
   if(!err)
   {
    err=runsession(acn,session,NULL);
    err=closesession(acn,session,err);

    if(!err)
    {
     err=stat(sc_name(sh),&f1);
     if(!err && f1.object)
     {
      err=flex_alloc((flex_ptr)&buffer,f1.length+1);
      if(!err)
      {
       err=loadblock(sc_name(sh),buffer);
       if(!err)
       {
        buffer[f1.length]=0;
        fn=ind+1;                    /* nb is OK for fmain == -1 */
        n=0;
        while(n<f1.length)
        {
         p=buffer+n;
         err=getstat(&f,&p);
         n=p-buffer;

         if(err) break;
         if(!f.object) break;

         err=insentry(acn,fn,ind,1);
         if(err) break;

         if(f.object)
         {
          strcpy(arc[acn].hdr[fn].name,f.name);
          arc[acn].hdr[fn].dirn=(f.object==1)?DNFILE:DFLAT;
          arc[acn].hdr[fn].load=f.load;
          arc[acn].hdr[fn].exec=f.exec;
          arc[acn].hdr[fn].acc =f.acc;
          arc[acn].hdr[fn].length=f.length;
         }
         fn++;
        }
        delete(sc_name(sh));
       }
       flex_free((flex_ptr)&buffer);
      }
     }
    }
   }
   err=sc_remove(sh,err);
  }
 }

 return(err);
}





_kernel_oserror * serviceload(int acn)
{
 _kernel_oserror * err;
 err=serviceopendir(acn,-1);
 return(err);
}





_kernel_oserror * servicegetfile(int acn,int fn)
{
 _kernel_oserror * err;
 char              arcpath[NAMELEN];
 int               session;
 int             * r3;
 int               file_type;

 err=filepath(arcpath,acn,fn);
/*  printf("CSFS: getfile %s\n",arcpath); */
 if(!err)
 {
  file_type=filetype(arc[acn].hdr[fn].load);
  err=opensession(acn,CSFS_GET,arcpath,sc_name(arc[acn].hdr[fn].sn),
                                                       &session,&file_type);
  if(!err)
  {
   err=runsession(acn,session,&r3);
   if(r3)
   {
    arc[acn].hdr[fn].length=r3[0];
    arc[acn].hdr[fn].load=r3[2];
    arc[acn].hdr[fn].exec=r3[3];
    arc[acn].hdr[fn].acc=r3[4];
   }
   err=closesession(acn,session,err);
  }
 }

 return(err);
}



_kernel_oserror * serviceputfile(int acn,int fn)
{
 _kernel_oserror * err;
 char              arcpath[NAMELEN];
 int               session;
 int               data[3];

 err=filepath(arcpath,acn,fn);
 if(!err)
 {
  data[0]=arc[acn].hdr[fn].load;
  data[1]=arc[acn].hdr[fn].exec;
  data[2]=arc[acn].hdr[fn].acc;

  err=opensession(acn,CSFS_PUT,arcpath,sc_name(arc[acn].hdr[fn].sn),
                                       &session,data);
  if(!err)
  {
   err=runsession(acn,session,NULL);
   err=closesession(acn,session,err);
  }
 }

 return(err);
}


_kernel_oserror * servicemkdir(int acn,int fn)
{
 _kernel_oserror * err;
 char              arcpath[NAMELEN];
 int               session;

 err=filepath(arcpath,acn,fn);
 if(!err)
 {
  err=opensession(acn,CSFS_MKDIR,arcpath,sc_name(arc[acn].hdr[fn].sn),
                                                        &session,NULL);
  if(!err)
  {
   err=runsession(acn,session,NULL);
   err=closesession(acn,session,err);
  }
 }

 return(err);
}



_kernel_oserror * serviceupdate(int acn,int fn)
{
 _kernel_oserror * err;
 char              arcpath[NAMELEN];

 err=filepath(arcpath,acn,fn);


 return(err);
}



_kernel_oserror * servicedelete(int acn,int fn)
{
 _kernel_oserror * err;
 char              arcpath[NAMELEN];
 int               session;

 err=filepath(arcpath,acn,fn);
 if(!err)
 {
  err=opensession(acn,
                  (arc[acn].hdr[fn].dirn==DNFILE)?CSFS_DELETE:CSFS_RMDIR,
                  arcpath,NULL,&session,NULL);
  if(!err)
  {
   err=runsession(acn,session,NULL);
   err=closesession(acn,session,err);
  }
 }

 return(err);
}



_kernel_oserror * servicerename(int acn,int fn1,int fn2)
{
 _kernel_oserror * err;
 char              oldname[NAMELEN];
 char              newname[NAMELEN];
 int               session;
 int               features;

          err=filepath(oldname,acn,fn1);
 if(!err) err=filepath(newname,acn,fn2);

 if(!err)
 {
  features=servicefeatures(acn);
  if(!(features & CSFS_RENAMESUPPORTED) &&
      (features & CSFS_COPYSUPPORTED) &&
      (features & CSFS_DELETESUPPORTED))
  {
   err=opensession(acn,CSFS_COPY,oldname,newname,&session,NULL);
   if(!err)
   {
    err=runsession(acn,session,NULL);
    err=closesession(acn,session,err);
   }

   if(!err)
   {
    err=opensession(acn,CSFS_DELETE,oldname,NULL,&session,NULL);
    if(!err)
    {
     err=runsession(acn,session,NULL);
     err=closesession(acn,session,err);
    }
   }
  }
  else
  {
   err=opensession(acn,CSFS_RENAME,oldname,newname,&session,NULL);
   if(!err)
   {
    err=runsession(acn,session,NULL);
    err=closesession(acn,session,err);
   }
  }
 }

 return(err);
}


