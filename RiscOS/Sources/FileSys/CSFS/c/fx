/*->c.fx */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>



#include "kernel.h"
#include "swis.h"


#include "Consts.h"
#include "AllErrs.h"
#include "RMInfo.h"
#include "Statics.h"
#include "veneers.h"
#include "Interface.h"
#include "fsentries.h"
#include "ModuleWrap.h"


#include "h.flex"

#include "h.str"

#include "h.arcs"
#include "h.sfs"
#include "h.cat"
#include "h.fx"
#include "h.fs"
#include "h.link"
#include "h.scrap"


/*****************************************************************************/




filestr *   fsmap[MAXFILES];  /* maps file strcuture number to cat + data */
filehandle  fmap[MAXFILES];   /* maps file handles to file structures */



_kernel_oserror * getnewfilehandle(int acn,int fn,int new,int * fh)
{
 _kernel_oserror * err;
 int i;
 int j;
 int fs;

 err=NULL;

 for(i=1;i<MAXFILES;i++) if(!fmap[i].file) break;

 if(i==MAXFILES)
 { 
  /* return too many files open error */ 
  err=&mb_nfserr_TooManyFiles;
 }
 else
 {
  if(arc[acn].hdr[fn].fshandle)  /* the file is already open */
  {
   fmap[i].file=fs=arc[acn].hdr[fn].fshandle;
   fmap[i].pointer=0;
   fsmap[fs]->cat.open++;
  }
  else   /* we have to open the file */
  {
   for(j=1;j<MAXFILES;j++) if(!fsmap[j]) break;

   if(j==MAXFILES) { /* return too many files open error */ }

   err=flex_alloc((flex_ptr)&fsmap[j],sizeof(filestr));
   if(!err)
   {
    arc[acn].files++;
    fmap[i].file=arc[acn].hdr[fn].fshandle=j;
    fmap[i].pointer=0;

    fsmap[j]->cat.load=arc[acn].hdr[fn].load;

    fsmap[j]->cat.exec=arc[acn].hdr[fn].exec;
    fsmap[j]->cat.acc=arc[acn].hdr[fn].acc;
    fsmap[j]->cat.length=arc[acn].hdr[fn].length;
    fsmap[j]->cat.alloc=fsmap[j]->cat.length;
    fsmap[j]->cat.isdir=arc[acn].hdr[fn].dirn>=0 || arc[acn].hdr[fn].dirn==-2;
    fsmap[j]->cat.modded=0;
    fsmap[j]->cat.open=1;
    fsmap[j]->cat.state=OPENPEND;
    fsmap[j]->cat.sh=0;
    fsmap[j]->cat.sn=arc[acn].hdr[fn].sn;
   }
  }
  *fh=i;
 }

 return(err);
}



static void storefshdr(heads * hdr,int fs)
{
 hdr->load=fsmap[fs]->cat.load;
 hdr->exec=fsmap[fs]->cat.exec;
 hdr->acc=fsmap[fs]->cat.acc;
 hdr->length=fsmap[fs]->cat.length;
}


void updatefsmap(int acn,int fn)
{
 int     fs;
 heads * hdr;

 hdr=&arc[acn].hdr[fn];

 if((fs=hdr->fshandle)!=0)
 {
  fsmap[fs]->cat.load=hdr->load;
  fsmap[fs]->cat.exec=hdr->exec;
  fsmap[fs]->cat.acc=hdr->acc;
 }
}



static _kernel_oserror * stashdata(int acn,int fn,int fs)
{
 _kernel_oserror * err;
 heads             hdr;
 int               ind;

 hdr=arc[acn].hdr[fn];
 storefshdr(&hdr,fs);
 ind=parentof(&arc[acn],fn);

 deb("stash data");

 err=savearcfile(acn,&hdr,fn,ind,1,fs,0);

 return(err);
}




_kernel_oserror * closefilehandle(int fh)
{
 _kernel_oserror * err;

 int fs;
 int i;
 int j;

 err=NULL;

 fs=fmap[fh].file;

 if(fsmap[fs]->cat.open==1)
 {
  /* last file handle open on file structure */

  if(fsmap[fs]->cat.state==OPENDISC) 
  {
   close(fsmap[fs]->cat.sh);
   fsmap[fs]->cat.sh=0;
  }

  for(i=0;i<maxarc;i++)
  {
   if(arc[i].inuse && arc[i].files)
   {
    for(j=0;j<arc[i].nofiles;j++)
    {
     if(arc[i].hdr[j].fshandle==fs)
     {
      if(fsmap[fs]->cat.modded)
      {
       err=stashdata(i,j,fs);
      }

      arc[i].hdr[j].fshandle=0;
      arc[i].files--;
     }
    }
   }
  }

  flex_free((flex_ptr)&fsmap[fs]);
 }
 else
 {
  fsmap[fs]->cat.open--;
 }

 fmap[fh].file=0; 

 return(err);
}





/* load/expand the data for the given file */

static _kernel_oserror * loadfiledata(int fs)
{
 _kernel_oserror * err;

 int i;
 int j;

 err=NULL;

 for(i=0;i<maxarc;i++)
 {
  if(arc[i].inuse && arc[i].files)
  {
   for(j=0;j<arc[i].nofiles;j++)
   {
    if(arc[i].hdr[j].fshandle==fs)
    {
     err=loadarcfile(i,j,fs,NULL);
    }
   }
  }
 }

 return(err);
}


/* probably should be part of above ... */

static _kernel_oserror * downloadfile(int fs)
{
 _kernel_oserror * err;

 /* have to load data */

 err=loadfiledata(fs);
 if(err) return(err);

 return(err);
}





_kernel_oserror * getbytes(int fh,char * dest,int n,int offset)
{
 int fs;
 _kernel_oserror * err;

 err=NULL;

 fs=fmap[fh].file;

 if(fsmap[fs]->cat.state==OPENPEND) err=downloadfile(fs);

 if(!err)
 {
  if((offset+n)>fsmap[fs]->cat.length) n=fsmap[fs]->cat.length-offset;


  if(fsmap[fs]->cat.state==OPENDISC)
  {
   err=readat(fsmap[fs]->cat.sh,dest,n,offset);
  }

  deb("gbx");
 }

 return(err);
}




/* it is assumed that file actually exists at this point */

static _kernel_oserror * setextent(int fs,int newlen,int fill,int w)
{
 _kernel_oserror * err;
 int               oldlen;

 err=NULL;

 oldlen=fsmap[fs]->cat.length;

 if((newlen>oldlen) || w)
 {

  if(fsmap[fs]->cat.state==OPENDISC && !err)
  {
   err=setfileextent(fsmap[fs]->cat.sh,newlen);
  }

  if(!err) fsmap[fs]->cat.length=newlen;
 }

 return(err);
}




_kernel_oserror * putbytes(int fh,char * src,int n,int offset)
{
 int fs;
 _kernel_oserror * err;

 err=NULL;

 fs=fmap[fh].file;

 if(fsmap[fs]->cat.state==OPENPEND) err=downloadfile(fs);

 if(!err)
 {
  err=setextent(fs,offset+n,0,0);
  if(!err)
  {
   fsmap[fs]->cat.modded=1;
   if(fsmap[fs]->cat.state==OPENDISC)
   {
    err=writeat(fsmap[fs]->cat.sh,src,n,offset);
   }
  }
 }
 return(err);
}




/* can flag errors outside file... if file is read only */

_kernel_oserror * validextent(int fh,int extent,int write)
{
 int fs;
 _kernel_oserror * err;

 err=NULL;

 fs=fmap[fh].file;

 if(fsmap[fs]->cat.state==OPENPEND) err=downloadfile(fs);

 if(!err) err=setextent(fs,extent,1,write);

 return(err);
}


