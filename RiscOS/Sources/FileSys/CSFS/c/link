/*->c.link */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>



#include "kernel.h"
#include "swis.h"


#include "Consts.h"
#include "RMInfo.h"
#include "veneers.h"
#include "Interface.h"
#include "fsentries.h"
#include "ModuleWrap.h"


#include "h.flex"
#include "h.xstr"

#include "h.str"
#include "h.etc"
#include "h.scrap"
#include "h.fs"
#include "h.sfs"
#include "h.arcs"
#include "h.cat"
#include "h.fx"

#include "h.mount"


#include "h.serx"
#include "h.link"




/*****************************************************************************/



/* this routine is called twice, once with dest set and a bad fs    */
/* and once with dest NULL and a good fs                            */
/* potential bug, is to assume you have a good fs, when dest is set */


/* if there already is a scrap n then see if it exists */
/* else create a scrap n                               */
/* else transport the file                             */
/* if there is a dest load the file to RAM             */
/* else open a handle on the scrap file                */



_kernel_oserror * loadarcfile(int acn,int fn,int fs,char * dest)
{
 _kernel_oserror * err;
 char            * p;
 int               sh;
 heads             hdr;
 int               changed;
 int               changedlength;

 err=NULL;

 changed=changedlength=0;

 if(!arc[acn].hdr[fn].sn)
 {
  err=sc_create(&arc[acn].hdr[fn].sn);
  if(!dest) fsmap[fs].cat.sn=arc[acn].hdr[fn].sn;
 }

 p=sc_name(arc[acn].hdr[fn].sn);
 if(!fexists(p))
 {
  /* get file */
  hdr=arc[acn].hdr[fn];
  err=servicegetfile(acn,fn);
  if(!err)
  {
   changedlength=(arc[acn].hdr[fn].length!=hdr.length);
   changed=arc[acn].hdr[fn].load!=hdr.load ||
           arc[acn].hdr[fn].exec!=hdr.exec ||
           arc[acn].hdr[fn].acc!=hdr.acc   || changedlength;
  }
 }


 if(err)
 {
  removesn(acn,fn);
 }
 else
 {
  if(changed) updatefileupcall(acn,fn);

  p=sc_name(arc[acn].hdr[fn].sn);

  if(dest)
  {
   err=loadblock(p,dest);
  }
  else
  {
   err=open(p,'u',&sh);
   if(!err)
   {
    fsmap[fs].cat.state=OPENDISC;
    fsmap[fs].cat.sh=sh;
   }
  }
 }

 return(err);
}




static _kernel_oserror * stattohdr(int acn,int fn,fstat * stat,char * name)
{
 _kernel_oserror * err;
 int               s;
 heads           * hdr;

 err=NULL;

 hdr=&arc[acn].hdr[fn];

 hdr->load=stat->load;
 hdr->exec=stat->exec;
 hdr->acc =stat->acc;
 hdr->length=stat->length;
 hdr->dirn=DNFILE;
 hdr->fshandle=0;

 if(name)
 {
  s=hdr->name;
  if(s<=0)
  {
   err=createstring(name,&s);
   if(!err) arc[acn].hdr[fn].name=s; /* NB hdr-> probably moved now */
  }
  else
  {
   err=assignstring(s,name);
  }
 }

 return(err);
}




_kernel_oserror * savearcfile(int acn,fstat * stat,char * name,
                              int ins,int ind,int ow,int fs,char * ostart)
{
 _kernel_oserror * err;
 int               sn;

 err=NULL;

 if(ostart)
 {
  if(ow) sn=arc[acn].hdr[ins].sn;
  else
  {
   err=sc_create(&sn);
  }
 }
 else
 {
  if(ow)
  {           /* don't think this can ever happen */
   if(arc[acn].hdr[ins].sn!=fsmap[fs].cat.sn)
   {
    sc_remove(arc[acn].hdr[ins].sn,NULL);
   }
  }
  sn=fsmap[fs].cat.sn;
 }


 if(!err)
 {
  if(ostart)
  {
   fs_lock(sc_name(sn),DEFATT);
   saveblock(sc_name(sn),DATA,ostart,stat->length);
  }

  /* else the file already exists */
 }

 if(!err)
 {
  if(!ow) err=insentry(acn,ins,ind,1);

  err=stattohdr(acn,ins,stat,name);
  arc[acn].hdr[ins].fshandle=fs;
  arc[acn].hdr[ins].sn=sn;

  if(!err)
  {
   if(!arc[acn].writecache)
   {
     err=serviceputfile(acn,ins);
   }
   else
   {
    arc[acn].hdr[ins].writecache=1;
    fs_lock(sc_name(arc[acn].hdr[ins].sn),DEFATT|LOCK);
   }
  }
 }

 return(err);
}



_kernel_oserror * createfilex(int acn,fstat * stat,char * name,
                                                     int ins,int ind,int ow)
{
 _kernel_oserror * err;
 int               sn;

 err=NULL;

 if(!ow || !arc[acn].hdr[ins].sn)
 {
  err=sc_create(&sn);
 }
 else
 {
  sn=arc[acn].hdr[ins].sn;
  fs_lock(sc_name(sn),DEFATT);
 }

 err=fs_create(sc_name(sn),stat->length,DATA);

 if(!err)
 {
  if(!ow) err=insentry(acn,ins,ind,1);
  err=stattohdr(acn,ins,stat,name);
  arc[acn].hdr[ins].sn=sn;
  if(!err)
  {
   if(!arc[acn].writecache)
   {
    if(arc[acn].hdr[ins].load!=0xdeaddead&&arc[acn].hdr[ins].exec!=0xdeaddead)
    {
     err=serviceputfile(acn,ins);
    }
   }
   else
     arc[acn].hdr[ins].writecache=1;
  }
 }

 return(err);
}


_kernel_oserror * createdirx(int acn,fstat * stat,char * name,
                                                  int ins,int ind,int ow)
{
 _kernel_oserror * err;

 err=NULL;

 if(!ow) err=insentry(acn,ins,ind,1);
 err=stattohdr(acn,ins,stat,name);
 if(!err)
 {
  arc[acn].hdr[ins].dirn=0;

  if(!arc[acn].writecache) err=servicemkdir(acn,ins);
  else                     arc[acn].hdr[ins].writecache=1;
 }

 return(err);
}





/* update given catalogue entry */

_kernel_oserror * updatecat(int acn,int fn,fstat * fx)
{
 _kernel_oserror * err;
 settype_info      type;


 type.old=filetype(arc[acn].hdr[fn].load);
 type.new=filetype(fx->load);


 if(type.new!=type.old && type.old!=-1 && type.new!=-1)
 {
  err=serviceupdate(acn,fn,&type);
 }
 else
  err=NULL;


 if(!err)
 {
  arc[acn].hdr[fn].load=fx->load;
  arc[acn].hdr[fn].exec=fx->exec;
  arc[acn].hdr[fn].acc=fx->acc;
 }

 return(err);
}





_kernel_oserror * deletefilex(int acn,int fn)
{
 _kernel_oserror * err;
 char            * p;

 err=NULL;

 if(arc[acn].hdr[fn].sn)
 {
  p=sc_name(arc[acn].hdr[fn].sn);
  if(fexists(p))
  {
   fs_lock(p,DEFATT);
   err=delete(p);
  }

  if(!err)
  {
   err=sc_remove(arc[acn].hdr[fn].sn,NULL);
   arc[acn].hdr[fn].sn=0;
  }
 }

 if(!err)
 {
  if(!arc[acn].writecache) err=servicedelete(acn,fn);
  else                     arc[acn].hdr[fn].writecache=1;
 }

 if(!err)
 {
  rmstring(arc[acn].hdr[fn].name);
  rementry(&arc[acn],fn,1);
 }

 return(err);
}




_kernel_oserror * renamex(int acn,int fn1,int fn2,int ind,int size,char * name)
{
 _kernel_oserror * err;
 int               i;
 int               s;

 /* problem here is renaming a file from one directory to another, whilst
    its position in the archive does not change.
    e.g. !MyApp() !Run => !MyApp(!Run). */

 err=insentry(acn,fn2,ind,size);
 if(fn2<=fn1) fn1+=size;

 for(i=0;i<size;i++)
 {
  arc[acn].hdr[fn2+i]=arc[acn].hdr[fn1+i];
 }

 err=createstring(name,&s);
 if(!err) arc[acn].hdr[fn2].name=s;

 err=servicerename(acn,fn1,fn2);
 if(!err)
 {
  rmstring(arc[acn].hdr[fn1].name);
  rementry(&arc[acn],fn1,size);
  if(fn2>fn1) fn2-=size;
 }
 else
 {
  rmstring(arc[acn].hdr[fn2].name);
  rementry(&arc[acn],fn2,size);
 }

 return(err);
}





/* load archive cat into arcs structure */

_kernel_oserror * loadarchive(int arcn)
{
 _kernel_oserror * err;

 err=serviceload(arcn);

 return(err);
}




_kernel_oserror * diropen(int acn,int dn)
{
 _kernel_oserror * err;

 err=NULL;

 if(arc[acn].hdr[dn].dirn==DFLAT)
 {
  err=serviceopendir(acn,dn);
 }

 return(err);
}


