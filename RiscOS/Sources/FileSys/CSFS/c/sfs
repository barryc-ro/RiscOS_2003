/*->c.sfs */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"


#include "Consts.h"
#include "AllErrs.h"
#include "RMInfo.h"
#include "Statics.h"
#include "veneers.h"
#include "Interface.h"
#include "fsentries.h"
#include "ModuleWrap.h"


#include "h.flex"

#include "h.str"
#include "h.etc"
#include "h.allerrs"
#include "h.arcs"
#include "h.dir"
#include "h.virt"
#include "h.cat"
#include "h.fs"
#include "h.sff"
#include "h.link"
#include "h.mem"
#include "h.fx"
#include "h.scrap"
#include "h.service"

#include "h.sfs"


char arcname[NAMELEN];   /* real name of archive */
char arcpath[NAMELEN];   /* path inside  archive */


static char * csdname;
static char * csdpath;
static char * psdname;
static char * psdpath;
static char * urdname;
static char * urdpath;
static char * libname;
static char * libpath;


/* takes the dirname and special fields, and turns them into full paths */
/* returned in arcname and arcpath                                      */
/* if lib set relative to lib else relative to csd                      */


static char * skipitem(char * p)
{
 while(1)
 {
  if(!*p)       break;
  if(*p++=='.') break;
 }
 return(p);
}


static char * getitem(char * p,char * result)
{
 int    c;
 char * q;

 if(p)
 {
  q=result;
  while(1)
  {
   c=*q=*p++;
   if(c<' ' || c=='.')
   {
    *q=0;
    return(result);
   }
   q++;
  }
 }

 return(NULL);
}



/* return arcname - the mount name                */
/*        arcpath - the path after the mount name */


static _kernel_oserror *  makepathsub(char * dirname,char * spec,int lib)
{
 _kernel_oserror * err;
 int    len;
 char * p;
 char * q;
 char * l1;
 char * l2;
 char * r;
 char   temp[32];

 err=NULL;
 p=q=NULL;


/* printf("dirname=%s spec=%d\n",dirname,spec); */

 if(!cstrncmp(dirname,"CSFS:",5))
 {
  dirname+=4;
 }

 if(*dirname==':') /* we expect $ */
 {
  dirname++;
  if(*dirname!='$') return(&mb_sfserr_BadFileName);
 }


 if(!spec)
 {
  if(dirname && *dirname=='%')
  {
   if(!libname) err=&mb_sfserr_NoLib;
   else         {p=libname;q=libpath;}
   dirname=skipitem(dirname);
  }
  else
  if(dirname && *dirname=='&')
  {
   if(!urdname)
   {
    if(!csdname) err=&mb_sfserr_NoCSD;
    else         {p=csdname;q=csdpath;}
   }
   else          {p=urdname;q=urdpath;}
   dirname=skipitem(dirname);
  }
  else
  if(dirname && *dirname=='\\')
  {
   if(!psdname)
   {
    if(!csdname) err=&mb_sfserr_NoCSD;
    else         {p=csdname;q=csdpath;}
   }
   else          {p=psdname;q=psdpath;}
   dirname=skipitem(dirname);
  }
  else
  if(dirname && *dirname=='@')
  {
   if(!csdname) err=&mb_sfserr_NoCSD;
   else         {p=csdname;q=csdpath;}
   dirname=skipitem(dirname);
  }
  else
  if(dirname && *dirname=='$')
  {
  /* if(!csdname) err=&mb_sfserr_NoCSD;
   else         p=csdname; */

   dirname=skipitem(dirname);
   p=getitem(dirname,temp);
   dirname=skipitem(dirname);

  /* printf("p=%s dr=%s\n",p,dirname); */
  }
  else
  if(lib)
  {
   if(!libname) err=&mb_sfserr_NoLib;
   p=libname;
   q=libpath;
  }
  else
  {
   if(!csdname) err=&mb_sfserr_NoCSD;
   else         {p=csdname;q=csdpath;}
  }

  if(!err)
  {
   strcpy(arcname,p);

   if(q)
   {
    strcpy(arcpath,q);
    if(dirname && *dirname)
    {
     strcat(arcpath,".");
     strcat(arcpath,dirname);
    }
   }
   else
   {
    strcpy(arcpath,dirname);
   }


  }
 }
 else
 {
  strcpy(arcname,spec);
  len=strlen(arcname);

  strcpy(arcpath,dirname);
 }


 for(p=q=arcpath;*p;p++,q++)
 {
  *q=*p;
  if(*p=='^')
  {
   l1=l2=NULL;
   for(r=arcpath;r<q;r++)
   {
    if(*r && *(r+1)=='.') {l2=l1;l1=r;}
   }
   if(l2) q=l2;
   else
   if(l1) q=l1;
  }
 }
 *q=0;

/* printf("path=%s\n",arcpath);
 printf("name=%s\n",arcname); */


 return(err);
}



_kernel_oserror *  makepath(char * dirname,char * spec)
{
 return(makepathsub(dirname,spec,0));
}


static _kernel_oserror *  formpath(FSEntry_Func_Parameter * parm)
{
 return(makepath(parm->first_parameter.name_1,
                 parm->sixth_parameter.special_field_1));
}




static _kernel_oserror *  formpathlib(FSEntry_Func_Parameter * parm)
{
 return(makepathsub(parm->first_parameter.name_1,
                    parm->sixth_parameter.special_field_1,1));
}


static _kernel_oserror *  formpath2(FSEntry_Func_Parameter * parm)
{
 return(makepath(parm->second_parameter.name_2,parm->special_field_2));
}


/*****************************************************************************/


/* print start up banner - this will not be called unless enabled by */
/* setting FS name pointer to -1 in header */

_kernel_oserror * PrintStartUpBanner(FSEntry_Func_Parameter * parm)
{
 parm=parm;

 return(NULL);
}


/*****************************************************************************/

/* only ever called if bit 24 in FS info word is set */

_kernel_oserror * SetDirectoryContexts(FSEntry_Func_Parameter * parm)
{
 parm=parm;
 return(&mb_nfserr_DummyFSDoesNothing);
}

_kernel_oserror * SetFilingSystemOptions(FSEntry_Func_Parameter * parm)
{
 parm=parm;
 return(NULL);
}

_kernel_oserror * BootFilingSystem(FSEntry_Func_Parameter * parm)
{
 parm=parm;
 return(NULL);
}

_kernel_oserror * ReadNameAndBootOptionOfDisc(FSEntry_Func_Parameter * parm)
{
 parm=parm;
 return(&mb_nfserr_DummyFSDoesNothing);
}

/* might be useful */

_kernel_oserror * ShutDown(FSEntry_Func_Parameter * parm)
{
 parm=parm;

 return(NULL);
}

/****************************************************************************/


static _kernel_oserror * swoppath(char ** name1,char ** name2)
{
 char temp[256];

 if(*name1 && *name2)
 {
  strcpy(temp,*name1);
  if(!flex_extend((flex_ptr)name1,strlen(*name2)+1)) strcpy(*name1,*name2);
  if(!flex_extend((flex_ptr)name2,strlen(temp)+1))   strcpy(*name2,temp);
 }
 else
 if((!(*name1)) && *name2)
 {
  if(!flex_alloc((flex_ptr)name1,strlen(*name2)+1)) strcpy(*name1,*name2);
 }
 else
 if(*name1 && (!(*name2)))
 {
  if(!flex_alloc((flex_ptr)name2,strlen(*name1)+1)) strcpy(*name2,*name1);
 }

 return(NULL);
}


static _kernel_oserror * assignpath(char ** namevar,char * name)
{
 int len;
 _kernel_oserror * err;

 len=strlen(name)+1;

 if((*namevar && !flex_extend((flex_ptr)namevar,len)) ||
                 !flex_alloc((flex_ptr)namevar,len) )
 {
  strcpy(*namevar,name);
  err=NULL;
 }
 else
  err=&mb_malloc_failed;

 return(err);
}

static void writename(FSEntry_Func_Parameter * parm,char * path)
{
 char * dest;
 char * p;

 dest=parm->second_parameter.destination_address;

 *dest++=0;

 if(path)
 {
  p=leaf(path);
  *dest++=(char)strlen(p);
  strcpy(dest,p);
 }
 else
 {
  *dest++=5;
  strcpy(dest,"Unset");
 }

 dest+=*dest;
 *dest++=0;
}


_kernel_oserror * SetCurrentDirectory(FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;
 int               acn;
 int               fn;

 err=formpath(parm);

 if(!err)
 {
  err=gethandle(arcname,&acn);
  if(!err)
  {
   err=findpath(acn,arcpath,&fn,0);
   if(fn<-1)  err=&mb_sfserr_FileNotFound;  /* Not found */

   if(!err)
   {
    swoppath(&csdname,&psdname);
    swoppath(&csdpath,&psdpath);
    assignpath(&csdname,arcname);
    assignpath(&csdpath,arcpath);
   }
  }
 }
 return(err);
}


_kernel_oserror * SetLibraryDirectory(FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;

 err=formpath(parm);
 if(!err)
 {
  assignpath(&libname,arcname);
  assignpath(&libpath,arcpath);
 }

 return(err);
}



_kernel_oserror * 
       ReadCurrentDirectoryNameAndPrivilegeByte(FSEntry_Func_Parameter * parm)
{
 writename(parm,csdpath);
 return(NULL);
}



_kernel_oserror * 
       ReadLibraryDirectoryNameAndPrivilegeByte(FSEntry_Func_Parameter * parm)
{
 writename(parm,libpath);
 return(NULL);
}



_kernel_oserror * backcommand(void)
{
 swoppath(&csdname,&psdname);
 swoppath(&csdpath,&psdpath);
 return(NULL);
}



/* have to work out special field ourselves ? */

_kernel_oserror * urdcommand(char * args[],int argc)
{
 args=args;  argc=argc;



 return(NULL);
}



_kernel_oserror * nourdcommand(void)
{
 if(urdname) flex_free((flex_ptr)&urdname);
 if(urdpath) flex_free((flex_ptr)&urdpath);
 return(NULL);
}

_kernel_oserror * nodircommand(void)
{
 if(csdname) flex_free((flex_ptr)&csdname);
 if(csdpath) flex_free((flex_ptr)&csdpath);
 return(NULL);
}


_kernel_oserror * nolibcommand(void)
{
 if(libname) flex_free((flex_ptr)&libname);
 if(libpath) flex_free((flex_ptr)&libpath);
 return(NULL);
}


/*****************************************************************************/

/* 14 */

static _kernel_oserror * ReadDirectoryEntriesSub(int acn,
                                                 FSEntry_Func_Parameter *parm)
{
 _kernel_oserror * err;
 int dir;
 int n;
 int i;
 int p;

 char * dest;
 int    nobjects;
 int    start;
 int    size;
 char * limit;
 int    nwrite;
 int    len;
 int    len1;
 int    next;

 dest=parm->second_parameter.destination_address;
 nobjects=parm->third_parameter.read_number;
 start=parm->read_offset;
 size=parm->buffer_length;
 limit=dest+size;
 nwrite=0;
 next=-1;

 err=finddir(acn,arcpath,&dir,&n);
 if(!err && dir>=0)
 {
  p=dir;

  for(i=0;i<n;i++)
  {
   if(i>=start)
   {
    len1=strlen(arc[acn].hdr[i+p].name)+1;
    len=len1;
    next=i;
    if((limit-dest)<len) break;
    strcpy(dest,arc[acn].hdr[i+p].name);
    deb("read %s",dest);
    dest+=len1;
    nwrite++;
    next++;
    if(nwrite>=nobjects) break;
   }
   if(arc[acn].hdr[i+p].dirn>=0) p+=noindir(acn,i+p);
  }

  if(i>=n) next=-1;

  deb("next=%d nwrite=%d",next,nwrite);

  parm->read_offset=next;
  parm->third_parameter.read_number=nwrite;
 }
 return(err);
}


_kernel_oserror * ReadDirectoryEntries(FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;
 int               acn;

 err=formpath(parm);
 if(!err)
 {
  err=gethandle(arcname,&acn);
  if(!err) err=ReadDirectoryEntriesSub(acn,parm);
 }
 return(err);
}





/* 15 */

static _kernel_oserror * ReadDirectoriesAndInformationSub(int acn,
                                              FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;
 int dir;
 int n;
 int i;
 int p;

 char * dest;
 int    nobjects;
 int    start;
 int    size;
 char * limit;
 int    nwrite;
 int    nread;
 int    next;
 int    len;
 int    len1;

 dest=parm->second_parameter.destination_address;
 nobjects=parm->third_parameter.read_number;
 start=parm->read_offset;
 size=parm->buffer_length;

 limit=dest+size;
 nwrite=0;
 nread=next=-1;

 deb("start=%d",start);

 err=finddir(acn,arcpath,&dir,&n);
 if(!err && dir>=0)
 {
  p=dir;

  for(i=0;i<n;i++)
  {
   if(i>=start)
   {
    len1=strlen(arc[acn].hdr[i+p].name)+1;
    len1=(len1+0x3) & (~0x3);
    len=len1+0x14;

    next=i;

    if((limit-dest)<len) break;

    *((int*)dest)=arc[acn].hdr[i+p].load;
    dest+=4;
    *((int*)dest)=arc[acn].hdr[i+p].exec;
    dest+=4;
    *((int*)dest)=arc[acn].hdr[i+p].length;
    dest+=4;
    *((int*)dest)=arc[acn].hdr[i+p].acc;
    dest+=4;
    *((int*)dest)=(arc[acn].hdr[i+p].dirn>=0 ||arc[acn].hdr[i+p].dirn==-2)+1;
    dest+=4;
    strcpy(dest,arc[acn].hdr[i+p].name);
    dest+=len1;

    deb("readname %s",arc[acn].hdr[i+p].name);

    nwrite++;
    next++;

    if(nwrite>=nobjects) break;
   }
   if(arc[acn].hdr[i+p].dirn>=0) p+=noindir(acn,i+p);
  }

  if(i>=n) next=-1;
 }

 parm->read_offset=next;
 parm->third_parameter.read_number=nwrite;

 return(err);
}



_kernel_oserror * ReadDirectoriesAndInformation(FSEntry_Func_Parameter *parm)
{
 _kernel_oserror * err;
 int               acn;

 err=formpath(parm);
 if(!err)
 {
  err=gethandle(arcname,&acn);
  if(!err) err=ReadDirectoriesAndInformationSub(acn,parm);
 }
 return(err);
}






/* 19 */

_kernel_oserror * 
           ReadDirectoryEntriesAndInformation(FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;
 int acn;
 int dir;
 int n;
 int i;
 int p;

 char * dest;
 int    nobjects;
 int    start;
 int    size;
 char * limit;
 int    nwrite;
 int    len;
 int    len1;
 int    next;

 dest=parm->second_parameter.destination_address;
 nobjects=parm->third_parameter.read_number;
 start=parm->read_offset;
 size=parm->buffer_length;
 limit=dest+size;
 nwrite=0;
 next=-1;

 err=formpath(parm);
 if(!err)
 {
  err=gethandle(arcname,&acn);
  if(!err)
  {
   err=finddir(acn,arcpath,&dir,&n);
   if(!err && dir>=0)
   {
    p=dir;

    for(i=0;i<n;i++)
    {
     if(i>=start)
     {
      len1=strlen(arc[acn].hdr[i+p].name)+1;
      len1=(len1+0x3) & (~0x3);
      len=len1+29;
      next=i;

      if((limit-dest)<len) break;

      *((int*)dest)=arc[acn].hdr[i+p].load;
      dest+=4;
      *((int*)dest)=arc[acn].hdr[i+p].exec;
      dest+=4;
      *((int*)dest)=arc[acn].hdr[i+p].length;
      dest+=4;
      *((int*)dest)=arc[acn].hdr[i+p].acc;
      dest+=4;
      *((int*)dest)=(arc[acn].hdr[i+p].dirn>=0 ||arc[acn].hdr[i+p].dirn==-2)+1;
      dest+=4;
      *((int*)dest)=0;
      dest+=4;

      writetime(dest,arc[acn].hdr[i+p].load,arc[acn].hdr[i+p].exec);
      dest+=5;

      strcpy(dest,arc[acn].hdr[i+p].name);
      dest+=len1;

      nwrite++;
      next++;

      if(nwrite>=nobjects) break;
     }
     if(arc[acn].hdr[i+p].dirn>=0) p+=noindir(acn,i+p);
    }

    if(i>=n) next=-1;

    parm->read_offset=next;
    parm->third_parameter.read_number=nwrite;
   }
  }
 }
 return(err);
}






/*****************************************************************************/


static void writefiletime(char * string,int acn,int fn)
{
 int i;
 int load;
 int exec;
 int len;

 load=arc[acn].hdr[fn].load;
 exec=arc[acn].hdr[fn].exec;
 len=arc[acn].hdr[fn].length;

 if((load  & 0xFFF00000)==0xFFF00000)
 {
  if(arc[acn].hdr[fn].dirn>=0 || arc[acn].hdr[fn].dirn==-2)
                                              strcpy(string,"Directory");
  else                         writetypest(string,(load >> 8) & 0xFFF);

  for(i=strlen(string);i<10;i++) string[i]=32;

  writetimedate(string+10,exec,load & 0xFF);
  for(i=strlen(string);i<30;i++) string[i]=32;

  writens(string+30,len);
 }
 else
  sprintf(string,"%08x %08x",load,exec);
}





static char * accstring(int acn,int fn)
{
 static char string[8];
 int    mask;
 char * p;

 mask=arc[acn].hdr[fn].acc;
 p=string;

 if(arc[acn].hdr[fn].dirn>=0 || arc[acn].hdr[fn].dirn==-2) *p++='D';
 else
 {
  if(mask & LOCK)      *p++='L';
  if(mask & OURWRITE)  *p++='W';
  if(mask & OURREAD)   *p++='R';
  *p++='/';
  if(mask & THEMWRITE) *p++='w';
  if(mask & THEMREAD)  *p++='r';
 }
 *p=0;

 return(string);
}




/* like *cat dir */

static _kernel_oserror * cataloguedirectorysub(void)
{
 _kernel_oserror * err;
 int acn;
 int dir;
 int n;
 int w;
 int i;
 int j;
 int p;

 err=gethandle(arcname,&acn);
 if(!err)                            /* print catalogue */
 {
  err=finddir(acn,arcpath,&dir,&n);
  if(!err && dir>=0)
  {
   w=textwidth()/18;
   j=0;
   p=dir;

   startv();
   for(i=0;i<n;i++)
   {
    writevf("%-12s%-5s",arc[acn].hdr[i+p].name,accstring(acn,i+p));

    if(++j>=w) 
    {
     writevf("\r\n");
     j=0;
    }

    if(arc[acn].hdr[i+p].dirn>=0) p+=noindir(acn,i+p);
   }

   writevf("\r\n");
   endv();
  }
 }
 return(err);
}



_kernel_oserror * CatalogueDirectory(FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;

 err=formpath(parm);
 if(!err) err=cataloguedirectorysub();

 return(err);
}



/* like *EX dir */

static _kernel_oserror * examinedirectorysub(void)
{
 _kernel_oserror * err;
 int               acn;
 int               dir;
 int               n;
 int               i;
 int               p;
 char              tstring[64];

 err=gethandle(arcname,&acn);
 if(!err)
 {
  err=finddir(acn,arcpath,&dir,&n);
  if(!err && dir>=0)
  {
   p=dir;
   startv();
   for(i=0;i<n;i++)
   {
    writefiletime(tstring,acn,i+p);
    writevf("%-12s%-5s %s\r\n",arc[acn].hdr[i+p].name,
                                                  accstring(acn,i+p),tstring);

    if(arc[acn].hdr[i+p].dirn>=0) p+=noindir(acn,i+p);
   }
   endv();
  }
 }
 return(err);
}


_kernel_oserror * ExamineDirectory(FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;

 err=formpath(parm);
 if(!err) err=examinedirectorysub();

 return(err);
}


_kernel_oserror * CatalogueLibraryDirectory(FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;

 err=formpathlib(parm);
 if(!err) err=cataloguedirectorysub();

 return(err);
}


_kernel_oserror * ExamineLibraryDirectory(FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;

 err=formpathlib(parm);
 if(!err) err=examinedirectorysub();

 return(err);
}



/* like *Fileinfo */


_kernel_oserror * OutputFullInformationOnObjects(FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;
 int               acn;
 int               dir;
 char              tstring[64];

 err=formpath(parm);
 if(!err)
 {
  err=gethandle(arcname,&acn);
  if(!err)
  {
   err=findpath(acn,arcpath,&dir,0);
   if(!err)
   {
    startv();
                    /* don't bother with $ */
    while(dir>=0)
    {
     writefiletime(tstring,acn,dir);
     writevf("%-12s%-5s %s\r\n",arc[acn].hdr[dir].name,
                                                  accstring(acn,dir),tstring);

     findpath(acn,arcpath,&dir,dir+1);
    }
    endv();
   }
  }
 }
 return(err);
}



/* like *info */

_kernel_oserror * ExamineObjects(FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;
 int               acn;
 int               dir;
 char              tstring[64];

 err=formpath(parm);
 if(!err)
 {
  err=gethandle(arcname,&acn);
  if(!err)
  {
   err=findpath(acn,arcpath,&dir,0);
   if(dir<-1) err=&mb_sfserr_FileNotFound;

   if(!err)
   {
    startv();

    while(dir>=0)  /* don't bother with $ */
    {
     writefiletime(tstring,acn,dir);
     writevf("%-12s%-5s %s\r\n",arc[acn].hdr[dir].name,
                                                  accstring(acn,dir),tstring);

     findpath(acn,arcpath,&dir,dir+1);
    }
    endv();
   }
  }
 }
 return(err);
}



/*****************************************************************************/


_kernel_oserror * AccessObjects(FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;
 int               acn;
 int               dir;
 int               mask;
 int               slash;
 char *            p;
 int               ch;


 err=formpath(parm);
 if(!err)
 {
  err=gethandle(arcname,&acn);
  if(!err)
  {
   err=findpath(acn,arcpath,&dir,0);
   if(!err && arc[acn].ro) err=&mb_sfserr_ReadOnlyArc;

   if(!err && dir>=0)
   {
    /* sort out access string, which is CTRL code terminated */
    p=parm->second_parameter.access_string;
    mask=0;
    slash=0;
    while((ch=*p++)>31)
    {
     ch=toupper(ch);

     if(ch=='/') slash=1;
     else
     if(slash)
     {
      if(ch=='R') mask|=THEMREAD;
      else
      if(ch=='W') mask|=THEMWRITE;
     }
     else
     {
      if(ch=='R') mask|=OURREAD;
      else
      if(ch=='W') mask|=OURWRITE;
      else
      if(ch=='L') mask|=LOCK;
     }
    }

    while(dir>=0)
    {
     arc[acn].hdr[dir].acc=mask;
     err=updatecat(acn,dir);
     if(!err)updatefsmap(acn,dir);
     if(err) break;
     findpath(acn,arcpath,&dir,dir+1);
    }
   }
  }
 }
 return(err);
}



/*****************************************************************************/

/* rename object1 to object2 */




_kernel_oserror * RenameObject(FSEntry_Func_Parameter * parm)
{
 _kernel_oserror * err;
 int         acn1;
 int         acn2;
 int         fn1;
 int         fn2;
 int         ow;
 int         ind;
 int         size;
 YesNoAnswer result;

 result=Yes;

 err=formpath(parm);

 if(!err)
 {
  err=gethandle(arcname,&acn1);
  if(!err)
  {
   err=findpath(acn1,arcpath,&fn1,0);
   if(fn1<-1)  err=&mb_sfserr_FileNotFound;  /* Not found */
   else
   if(fn1==-1) err=&mb_sfserr_Locked;  /* should flag $ locked */

   if(!err)  
   {
    err=deleteable(acn1,fn1);
    if(!err) err=formpath2(parm);
    if(!err)
    {
     err=gethandle(arcname,&acn2);
     if(!err)
     {
      err=findins(acn2,arcpath,&fn2,&ow,&ind); /* $ OK because ow */
      if(!err)
      {
       if(acn1!=acn2) result=Yes;
       else
       {
        if(ow && fn2!=fn1) err=&mb_sfserr_AlreadyExists; /* Already exists */
        else
        {
         if(arc[acn1].ro) err=&mb_sfserr_ReadOnlyArc;      /* ro */
         else
         {
          if(arc[acn1].hdr[fn1].fshandle) err=&mb_sfserr_FileOpen;
          else
          if(arc[acn1].hdr[fn1].acc & LOCK) err=&mb_sfserr_Locked; /* Locked */
          else
          {
           /* do the rename                       */
           /* consists of moving an object in cat */

           if(arc[acn1].hdr[fn1].dirn>=0) size=noindir(acn1,fn1)+1;
           else                           size=1;

           if(fn2>fn1 && fn2<(fn1+size)) result=Yes;
           else
           {
            err=renamex(acn1,fn1,fn2,ind,size,leaf(arcpath));
            if(!err) result=No;
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }

 parm->first_parameter.rename_invalid=result;

 return(err);
}




/*****************************************************************************/


extern int callback_handler(_kernel_swi_regs * r,void * pw);
extern int callback_entry(_kernel_swi_regs * r,void * pw);


int callback_handler(_kernel_swi_regs * r,void * pw)
{
 _kernel_swi_regs   rx;

 memset(&rx,0,sizeof(_kernel_swi_regs));
 rx.r[1]=Service_CSFSStarting;
 _kernel_swi(OS_ServiceCall,&rx,&rx);

 return(1);

 USE(r);
 USE(pw);
}



/*****************************************************************************/


static void filerclose(void)
{
 oscli("Filer_CloseDir CSFS:$");
}


/* lose memory etc. */

void CSFSFinalise(void)
{
 filerclose();
 scrapfinit();
 memfinish();
}



int privateword;

/* claim memory chunk */

_kernel_oserror * CSFSInitialise(void * pw)
{
 _kernel_oserror  * err;
 _kernel_swi_regs   rx;

 privateword=(int)pw;

 err=meminit();

 if(!err)
 {
  csdname=csdpath=psdname=psdpath=urdname=urdpath=libname=libpath=NULL;

  err=arcsinit();
  if(!err) err=initservice();
  if(!err) scrapinit();
  if(!err)
  {
   rx.r[0]=(int)callback_entry;
   rx.r[1]=(int)privateword;
   _kernel_swi(OS_AddCallBack,&rx,&rx);
  }
 }
 return(err);
}

