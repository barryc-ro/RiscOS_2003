/*->c.modulewrap */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "kernel.h"
#include "swis.h"


#include "Consts.h"
#include "AllErrs.h"
#include "RMInfo.h"
#include "Statics.h"
#include "veneers.h"
#include "Interface.h"
#include "fsentries.h"
#include "modulewrap.h"




#include "h.str"
#include "h.etc"

#include "h.fs"
#include "h.sfs"
#include "h.arcs"
#include "h.cat"
#include "h.link"
#include "h.mem"
#include "h.mount"
#include "h.update"
#include "h.service"






_kernel_oserror *CSFS_swi(int swi_number,_kernel_swi_regs *r,
                                                       void *private_word)
{
 _kernel_oserror * err;

 err=memcheck();
 if(!err)
 {
  switch(swi_number)
  {
   case  0: /*Services */
           err=serviceswi(r);
           break;

   case  1: /*Register*/
           err=regswi(r);
           break;

   case  2: /*DeRegister*/
           err=deregswi(r);
           break;

   case  3: /* Mount */
           err=mountswi(r);
           break;

   case  4: /*Dismount*/
           err=dismountswi(r);
           break;

   case  5: /*Update*/
           err=updateswi(r);
           break;


   default:
           err=&mb_nfserr_DummyFSDoesNothing;
           break;
  }
 }

 return(err);
 USE(private_word);
}





/* This is the finalisation code for DummyFS */

static void CSFS_finalise(void)
{
 _kernel_swi_regs r;


 CSFSFinalise();


 r.r[0]=FSControl_RemoveFilingSystem;
 r.r[1]=(int)FilingSystemName;

 _kernel_swi(XOS_Bit|OS_FSControl,&r,&r);
}





static _kernel_oserror *declare_CSFS(void *private_word)
{
 _kernel_swi_regs r;

 int information_block[Information_Block_Size];

 information_block[0]=(int)FilingSystemName-(int)Image_RO_Base;
 information_block[1]=(int)"CSFS"          -(int)Image_RO_Base;
 information_block[2]=(int)&veneer_fsentry_open-(int)Image_RO_Base;
 information_block[3]=(int)&veneer_fsentry_getbytes-(int)Image_RO_Base;
 information_block[4]=(int)&veneer_fsentry_putbytes-(int)Image_RO_Base;
 information_block[5]=(int)&veneer_fsentry_args-(int)Image_RO_Base;
 information_block[6]=(int)&veneer_fsentry_close-(int)Image_RO_Base;
 information_block[7]=(int)&veneer_fsentry_file-(int)Image_RO_Base;
 information_block[8]=Information_Word;
 information_block[9]=(int)&veneer_fsentry_func-(int)Image_RO_Base;
 information_block[10]=(int)&veneer_fsentry_gbpb-(int)Image_RO_Base;

 r.r[0]=FSControl_AddFilingSystem;
 r.r[1]=(int)Image_RO_Base;
 r.r[2]=(int)information_block-(int)Image_RO_Base;
 r.r[3]=(int)private_word;

 return _kernel_swi(XOS_Bit|OS_FSControl,&r,&r);
}



_kernel_oserror *CSFS_initialise(char *cmd_tail,int podule_base,
                                                   void *private_word)
{
 _kernel_oserror * err;

 err=CSFSInitialise(private_word);

 if(!err)
 {
  err=declare_CSFS(private_word);

  if(!err)
  {
   atexit(CSFS_finalise);
  }
 }

 return(err);
 USE(cmd_tail);
 USE(podule_base);
}





void CSFS_service(int service_number,_kernel_swi_regs *r,
                                                  void *private_word)
{
 r=r;


 switch(service_number)
 {
  case         Service_FSRedeclare:
                                   declare_CSFS(private_word);
                                   break;

  case Service_DyanmicAreaRenumber:
                                   dynamicrenumber(r);
                                   break;
 }
}





/* CSFS command processor */

#define MAXARG 16


_kernel_oserror *CSFS_command(char *arg_string,int argc,int cmd_no,
                                                  void *private_word)
{
 _kernel_oserror *err=NULL;
 _kernel_swi_regs r;
 char * args[MAXARG];
 char * temptr=my_command_parameter_buffer;
 int    i;
 int    whitespace;

 err=memcheck();
 if(err) return(err);

 argc=argc;
 private_word=private_word;

/* Change the control character terminator to a nul terminator */
 for(;temptr-my_command_parameter_buffer<My_Command_Parameter_Buffer_Len && *arg_string >= ' ';
              arg_string++ )
        {
                *(temptr++) = *arg_string;
        }

 *temptr='\0';

 arg_string=my_command_parameter_buffer;

 temptr=my_command_parameter_buffer;
 whitespace=1;
 i=0;

 while(1)
 {
  if(whitespace)
  {
   if(*temptr==0) break;
   else
   if(*temptr!=32)
   {
    args[i++]=temptr;
    whitespace=0;
   }
  }
  else
  {
   if(*temptr==0) break;
   else
   if(*temptr==32) 
   {
    whitespace=1;
    *temptr=0;
   }
  }
  temptr++;
 }


 /* Switch between the commands */

 switch(cmd_no)
 {
  case 0:
         /* *CSFS */
         r.r[0]=FSControl_SelectFilingSystem;
         r.r[1]=(int)FilingSystemName;
         err=_kernel_swi(XOS_Bit | OS_FSControl,&r,&r);
         break;

 case  1: /* CSFS Services */
         err=servicescommand(args,i);
         break;



 /* FS commands */


 case  2: /* Mount */
         err=mount(args,i);
         break;

 case  3: /* Update */
         err=updatecommand(args,i);
         break;

 case  4: /* Dismount */
         err=dismount(args,i);
         break;
 }

 return(err);
}

