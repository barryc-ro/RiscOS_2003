/*->c.fs */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdarg.h>

#include "kernel.h"
#include "swis.h"

#include "Consts.h"
#include "RMInfo.h"
#include "veneers.h"
#include "Interface.h"
#include "fsentries.h"
#include "ModuleWrap.h"

#include "h.str"

#include "h.fs"

/*****************************************************************************/

int 
cstrncmp(char *first, char *second, int n)
{
  int f;
  int s;

  while (n--)
  {
    f = toupper(*first++);
    s = toupper(*second++);
    if (f != s || !f)
      return (f - s);
  }

  return (0);
}

int 
cstrcmp(char *first, char *second)
{
  return (cstrncmp(first, second, -1));
}

char *
xstrcpy(char *s1, const char *s2)
{
  while ((*s1++ = *s2++) >= 32);
  *(s1 - 1) = 0;
  return (s1);
}

/*****************************************************************************/
/* returns 0 ==does not exist  1==file 2==dir */

int
fexists(char *name)
{
  int code;
  _kernel_osfile_block fiblock;

  code = _kernel_osfile(17, name, &fiblock);	/* don't use path */

  return (code);
}

_kernel_oserror *
stat(char *name, fstat * f)
{
  _kernel_oserror *err;
  _kernel_swi_regs rx;

  rx.r[0] = 5;
  rx.r[1] = (int) name;

  err = _kernel_swi(OS_File, &rx, &rx);
  CHK_ERR(err);
  if (err)
    return (err);

  f->object = rx.r[0];
  f->length = rx.r[4];
  f->load = rx.r[2];
  f->exec = rx.r[3];
  f->acc = rx.r[5];

  f->type = filetype(f->load);

  return (NULL);
}

int 
filetype(int load)
{
  if ((load & 0xFFF00000) == 0xFFF00000)
    return ((load >> 8) & 0xFFF);
  else
    return (-1);
}

void 
getdeftime(fstat * stat, int type)
{
  _kernel_swi_regs rx;
  char pblk[32];

  stat->length = 0;
  stat->acc = DEFATT;
  stat->load = 0xFFF00000;
  stat->load |= type << 8;

  pblk[0] = 3;

  rx.r[0] = 14;
  rx.r[1] = (int) pblk;

  _kernel_swi(OS_Word, &rx, &rx);

  stat->exec = *(int *) pblk;
  stat->load |= pblk[4];
}

void 
writetime(char *where, int load, int exec)
{
  if ((load & 0xFFF00000) == 0xFFF00000)
  {
    *((int *) where) = exec;
    *(where + 4) = load & 0xFF;
  }
  else
    memset(where, 0, 5);
}

char *
leaf(char *filename)
{
  char *p;

  p = strrchr(filename, '.');
  if (!p)
    p = filename;
  else
    p += 1;
  return (p);
}

_kernel_oserror *
oscli(char *string)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err;

  rx.r[0] = (int) string;

  err = _kernel_swi(OS_CLI, &rx, &rx);

  return (err);
}

/*
 * open specified file and return file handle
 */
_kernel_oserror *
open(char *name, int mode, int *fh)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  *fh = 0;

/*   debug_printf(db,"(7) open %s for '%c'",name,mode); */

  /*
   * ensure file is unlocked if we are opening for update
   */
  if (mode == 'w' || mode == 'u')
  {
    ERR_GOTO(err, fs_lock(name, DEFATT));
  }

  if (mode == 'r')
    rx.r[0] = 0x4F;
  else if (mode == 'w')
    rx.r[0] = 0x8F;
  else if (mode == 'u')
    rx.r[0] = 0xCF;

  rx.r[1] = (int) name;
  ERR_GOTO(err, _kernel_swi(OS_Find, &rx, &rx));

  *fh = rx.r[0];

exit_gracefully:
  CHK_ERR(err);

  return (err);
}

/*
 * close given file handle
 */
_kernel_oserror *
close(int fh)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  debug_printf(db, "(7) close");

  rx.r[0] = 0;
  rx.r[1] = fh;
  err = _kernel_swi(OS_Find, &rx, &rx);
    CHK_ERR(err);

  return (err);
}

/*
 * read bytes into buffer from open file using specified file pointer
 */
_kernel_oserror *
readat(int fh, void *buffer, int n, int at)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  debug_printf(db, "(7) readat");

  rx.r[0] = 3;
  rx.r[1] = fh;
  rx.r[2] = (int) buffer;
  rx.r[3] = n;
  rx.r[4] = at;

  err = _kernel_swi(OS_GBPB, &rx, &rx);
  CHK_ERR(err);

  return (err);
}

/*
 * write bytes from buffer to an open file using specified file pointer
 */
_kernel_oserror *
writeat(int fh, void *buffer, int n, int at)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  debug_printf(db, "(7) writeat");

  if (!n)
    return (NULL);

  rx.r[0] = 1;
  rx.r[1] = fh;
  rx.r[2] = (int) buffer;
  rx.r[3] = n;
  rx.r[4] = at;

  return (_kernel_swi(OS_GBPB, &rx, &rx));
  CHK_ERR(err);

  return (err);
}

/*
 * write an open files extent
 */
_kernel_oserror *
setfileextent(int fh, int ex)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  debug_printf(db, "(7) setfileextent (%d) %d", fh, ex);

  rx.r[0] = 3;
  rx.r[1] = fh;
  rx.r[2] = ex;

  err = _kernel_swi(OS_Args, &rx, &rx);
  CHK_ERR(err);

  return (err);
}

/*
 * save block of memory as a file
 */
_kernel_oserror *
saveblock(char *name, int type, char *start, int len)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  debug_printf(db, "(7) saveblock %s", name);

  rx.r[0] = 10;
  rx.r[1] = (int) name;
  rx.r[2] = type;
  rx.r[4] = (int) start;
  rx.r[5] = (int) (start + len);

  err = _kernel_swi(OS_File, &rx, &rx);
  CHK_ERR(err);

  return (err);
}

/*
 * load file into memory
 */
_kernel_oserror *
loadblock(char *name, char *start)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  debug_printf(db, "(7) load block %s", name);

  rx.r[0] = 16;
  rx.r[1] = (int) name;
  rx.r[2] = (int) start;
  rx.r[3] = 0;

  err = _kernel_swi(OS_File, &rx, &rx);
  CHK_ERR(err);

  return (err);
}

/*
 * delete specified file
 */
_kernel_oserror *
delete(char *name)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  debug_printf(db, "(7) delete %s", name);

  rx.r[0] = 6;
  rx.r[1] = (int) name;

  err = _kernel_swi(OS_File, &rx, &rx);
  CHK_ERR(err);
  return (err);
}

/*
 * create directory
 */
_kernel_oserror *
fs_cdir(char *name)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  debug_printf(db, "(7) create directory %s", name);

  rx.r[0] = 8;
  rx.r[1] = (int) name;
  rx.r[2] = 0;

  err = _kernel_swi(OS_File, &rx, &rx);
  CHK_ERR(err);
  return (err);
}

/*
 * force a recursive wipe of files
 */
_kernel_oserror *
fs_wipe(char *name)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  rx.r[0] = 27;
  rx.r[1] = (int) name;
  rx.r[2] = 0;
  rx.r[3] = (1 << 1) | (1 << 0);	/* recursive + force */

  err = _kernel_swi(OS_FSControl, &rx, &rx);
  CHK_ERR(err);
  return (err);
}

/*
 * create a typed file
 */
_kernel_oserror *
fs_create(char *name, int length, int type)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  debug_printf(db, "(7) create typed file %s, length %d", name, length);

  rx.r[0] = 0xB;
  rx.r[1] = (int) name;
  if (type == -1)
    type = 0xFFD;
  rx.r[2] = type;
  rx.r[3] = 0;
  rx.r[4] = 0;
  rx.r[5] = length;

  err = _kernel_swi(OS_File, &rx, &rx);
  CHK_ERR(err);
  return (err);
}

_kernel_oserror *
fs_lock(char *name, int bits)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  debug_printf(db, "(7) lock %s %c", name, (bits & 1 << 3) ? 'L' : '-');

  rx.r[0] = 4;
  rx.r[1] = (int) name;
  rx.r[5] = bits;

  err = _kernel_swi(OS_File, &rx, &rx);
  CHK_ERR(err);
  return (err);
}

_kernel_oserror *
fs_unlockall(char *name)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  debug_printf(db, "(7) fs_unlockall");

  rx.r[0] = 24;
  rx.r[1] = (int) name;
  rx.r[2] = (int) "RW";

  err = _kernel_swi(OS_FSControl, &rx, &rx);
  CHK_ERR(err);
  return (err);
}

#ifdef DODEBUG

static int dodebug = 0;

void 
deb(char *format,...)
{
  va_list args;
  char v[256];
  int n;

  if (dodebug)
  {
    va_start(args, format);
    n = vsprintf(v, format, args);

    _kernel_oswrch(4);
    _kernel_oswrch(30);

    printf("deb:%s\n", v);

    _kernel_oswrch(5);

    va_end(args);
  }
}

#endif

_kernel_oserror *
fs_canonicalpath(char *path, char *buffer, int len,
		 char *pathvar, char *pathstring)
{
  _kernel_swi_regs rx;
  _kernel_oserror *err = NULL;

  debug_printf(db, "(7) fs_canonicalpath");

  rx.r[0] = 37;
  rx.r[1] = (int) (path == NULL ? "@" : path);
  rx.r[2] = (int) buffer;
  rx.r[3] = (int) pathvar;
  rx.r[4] = (int) pathstring;
  rx.r[5] = len;

  err = _kernel_swi(OS_FSControl, &rx, &rx);
  CHK_ERR(err);
  return (err);
}
