/*->c.arcf */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>


#include "kernel.h"
#include "swis.h"

#include "Consts.h"
#include "AllErrs.h"
#include "RMInfo.h"
#include "Statics.h"
#include "veneers.h"
#include "Interface.h"
#include "fsentries.h"
#include "ModuleWrap.h"


#include "h.flex"

#include "h.str"

#include "h.fs"
#include "h.sfs"
#include "h.arcs"
#include "h.cat"
#include "h.link"

#include "h.arcf"


/*****************************************************************************/

void copyleaf(char * dest,char * src)
{
 strncpy(dest,src,MNLEN);
 dest[MNLEN-1]=0;
}


static void stattohdr(heads * hdr,fstat * stat,int nx,char * name)
{
 memset(hdr,0,sizeof(heads));

 hdr->load=stat->load;
 hdr->exec=stat->exec;
 hdr->acc =stat->acc;
 hdr->length=stat->length;

 hdr->fp=nx;
 hdr->dirn=-1;

 hdr->fshandle=0;

 copyleaf(hdr->name,name);
}


/* take the file and load it into memory */

_kernel_oserror * loadfile(int acn,int fn,char * address)
{
 _kernel_oserror * err;
 err=loadarcfile(acn,fn,0,address);

 if(err) deb("load file error");
 return(err);
}



static heads temphdr;


_kernel_oserror * createfile(int acn,char * filepath,int ins,int ow,int ind,
                                                                 fstat * stat)
{
 _kernel_oserror * err;
 int               nx;
 int               dest;

 if(arc[acn].ro)                      err=&mb_sfserr_ReadOnlyArc;
 else
 if(ow && arc[acn].hdr[ins].fshandle) err=&mb_sfserr_FileOpen;
 else
 if(ow && (arc[acn].hdr[ins].dirn>=0 || 
           arc[acn].hdr[ins].dirn==-2))  err=&mb_sfserr_TypesDontMatch;
 else
 {
  stattohdr(&temphdr,stat,0,leaf(filepath));
  err=createfilex(acn,&temphdr,ins,ind,ow);
 }
 return(err);
}





/* only called if the directory does not exist! */

_kernel_oserror * createdir(int acn,char * filepath,int ins,int ow,int ind)
{
 _kernel_oserror * err;
 fstat             stat;

 err=NULL;

 if(arc[acn].ro) err=&mb_sfserr_ReadOnlyArc;
 else
 if(ow && (arc[acn].hdr[ins].dirn<0 || 
           arc[acn].hdr[ins].dirn==-2)) err=&mb_sfserr_TypesDontMatch;
 else
 if(!ow)
 {
  getdeftime(&stat,0xFFD);
  stattohdr(&temphdr,&stat,0,leaf(filepath));
  temphdr.dirn=0;
  err=createdirx(acn,&temphdr,ins,ind,ow);
 }

 return(err);
}



/* for sphagetti type reasons, this is passed the file name, not path */


_kernel_oserror * savefile(int acn,char * name,int ins,int ow,int ind,
                                                   fstat * stat,char * start)
{
 _kernel_oserror * err;
 heads             hdr;

 err=NULL;

 if(arc[acn].ro) err=&mb_sfserr_ReadOnlyArc;
 else
 if(ow && arc[acn].hdr[ins].fshandle) err=&mb_sfserr_FileOpen;
 else
 if(ow && (arc[acn].hdr[ins].dirn>=0 ||
           arc[acn].hdr[ins].dirn==-2)) err=&mb_sfserr_TypesDontMatch;
 else
 {
  if(!err)
  {
   stattohdr(&hdr,stat,0,name);
   err=savearcfile(acn,&hdr,ins,ind,ow,0,start);
  }
 }
 return(err);
}



_kernel_oserror * deletefile(int acn,int fn)
{
 _kernel_oserror * err;

 if(arc[acn].ro)               err=&mb_sfserr_ReadOnlyArc;
 else
 if(arc[acn].hdr[fn].fshandle) err=&mb_sfserr_FileOpen;
 else
 if(arc[acn].hdr[fn].dirn>0)   err=&mb_sfserr_DirNotEmpty;
 else
                               err=deletefilex(acn,fn);
 return(err);
}

