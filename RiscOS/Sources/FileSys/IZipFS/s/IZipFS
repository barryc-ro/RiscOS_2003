; Iomega ZIP Driver
;
; (C) ARM Designs for Acorn/VTi
;
; Written by Jason Tribbeck
;
; email: arm.designs@argonet.co.uk
;
; This code is designed to be compiled under AAsm 2.00, NOT ObjAsm.
; As a result, you will need "s.Registers" and "s.SWIs" to be with this file.

; *****************************************************************************
; The following changes have been made to fit these sources in with the RiscOS
; build tree :
;     	1) Header file Zip renamed to IZipFS
;	2) Header file IZipFS exported during make export phase
;	3) Header file Registers replaced with RiscOS system file
;	4) Header file SWIs replaced with RiscOS system files
;	5) Version information split into separate file
; 	6) Rename of VerifyOp to ZipVerifyOp to avoid a clash with a constant

        GET     Hdr:ListOpts
	OPT	OptNoList
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
	GET	Hdr:Parallel
	GET	Hdr:FileCore
	GET	Hdr:Free
        LEADR   Module_LoadAddr
	OPT 	OptList

; Load in some of the Zip driver specific parameters
	GET	Hdr:IZipFS
	GET	Version

; Rich Buckley (07 Apr 1997)
; *****************************************************************************

; In most SWIs, the registers are arranged :
;
; r11 is ^ to printer port
; r10 is delay counter

; Macros...

; SSO is Single Sector Operation, which separates a set of sectors into
; indiviual sector operations. Note that as of 18th March, SSO now performs
; multiple sector operations, upto a certain size.

ppa_ssosize	*	32768				; Optimisation JT Tue 18th March 1997

	MACRO
	SSO

; r2 is ^ disc address
; r3 is ^ memory
; r4 is length of operation

	ROUT

	CMP	r4,#ppa_ssosize
	BLE	%f99					; If we're reading 1 sector or less, just jump it

	STMFD	r13!,{r6,r14}
	MOV	r6,r4

00	CMP	r6,#ppa_ssosize
	MOVGT	r4,#ppa_ssosize
	MOVLE	r4,r6
	SUB	r6,r6,r4				; Decrement the amount to copy

	BL	%f99					; Do the operation
	ADDVS	r4,r4,r6				; If it fails, decrement this bit
	LDMVSFD	r13!,{r6,pc}

	CMP	r6,#0
	BNE	%b00
	LDMFD	r13!,{r6,lr}
	BICS	pc,lr,#1<<28				; Clear V, just in case...

99
	MEND

; Constants

; Sector size - Do not change
ppa_sectorsize	*	512				; This is the length of a sector
ppa_sectorshift	*	9				; How many bits to shift by

; Error status - Do not change
ppa_ok		*	0				; Transfer was okay
ppa_error	*	&100				; PPA error
ppa_noconnect	*	&100				; Device not connected
ppa_timeout	*	&104				; Device timed out
ppa_overrun	*	&108				; Data overrun

; SCSI Host LUN - Do not change
ppa_host	*	7				; Host LUN

; Write protect status
ppa_ukprotected	*	-1				; Write protection of drive is unknown
ppa_unprotected	*	0				; Drive is unprotected
ppa_protected	*	2				; Drive is write-protected
ppa_protpass	*	3				; Drive is protected with a password

; Allocated errors (not yet!)
errorchunk	*	ZipErrorChunk
swichunk	*	ZipSWIChunk

; Disc formats
format_unknown	*	-1
format_acorn	*	0
format_dos	*	1

; The error offsets
error_init0	*	0
error_init1	*	1
error_init2	*	2
error_eject	*	3
error_lock	*	4
error_unlock	*	5
error_read	*	6
error_write	*	7
error_verify	*	8
error_notform	*	9
error_nowp	*	10
error_wpnpass	*	11
error_noprot	*	12
error_writeprot	*	13

; Other errors
;error_writeprotected *	(1<<6)				; FileCore error 64 is write protected
error_writeprotected *	&c9				; FileCore error &c9 is write protected

; Debug flags
Debug		*	0				; Global Debug flags
;Debug		*	1
DebugFile	*	0				; Don't use RAM:$.ZipDebug for debugging - use screen
;DebugFile	*	1				; Use RAM::$.ZipDebug for debug output

 [ Debug = 1
;Debug		*	1
;DebugMiscOp	*	0				; Debug MiscOps
DebugMiscOp	*	1
;DebugDiscOp	*	0				; Debug DiscOps
DebugDiscOp	*	1
;DebugOps	*	0				; Debug sector ops
DebugOps	*	1
;DebugMultiOp	*	0				; Debug multiple DiscOp
DebugMultiOp	*	1
;DebugStatus	*	0				; Debug GetStatus
DebugStatus	*	1
;DebugWriteStatus *	0				; Debug transmitting data block sizes
DebugWriteStatus *	1
 |
DebugMiscOp	*	0				; Debug MiscOps
DebugDiscOp	*	0				; Debug DiscOps
DebugOps	*	0				; Debug sector ops
DebugMultiOp	*	0				; Debug multiple DiscOp
DebugStatus	*	0				; Debug GetStatus
DebugWriteStatus *	0				; Debug transmitting data block sizes
 ]

; NeedConfigureSMC was used in early development. It should not be re-enabled
; here.

NeedConfigureSMC *	0				; We don't do any parallel port operations in this module

InitZipFS	*	1				; If set, initialise ZipFS with FileCore
;InitZipFS	*	0				; Use 0 for testing other bits of code...

; The private workspace

	^	0,r12
sor12		#	0				; Start of the workspace
ParallelAddress	#	4				; Address of the parallel port (always R11)
ErrorCode	#	4				; This is the error code
FC_Instance	#	4				; This is the filecore instance register
LockCounter	#	4				; This is the lock counter
OldCommand	#	4				; This is the old command port value
WriteProtectM	#	4				; This is the write protect flag
OldECPMode	#	4				; This is the old ECP mode flag (which is normally 1)
DiscFormat	#	4				; This is 1 if the disc is DOS format, 0 if it's Acorn, -1 if unknown
BootChanged	#	4				; This is 1 if the boot sector's changed, 0 otherwise
SCSITemp	#	512				; 512 byte temporary workspace
 [ Debug=1
SCSITempW	#	64				; Some temporary printing space
 ]
Stack__Free	#	32				; 32 bytes for free stack
FreeStack	#	96				; Temporary space for Free code
eor12		#	0				; End of the workspace
lor12		*	eor12-sor12			; Length of the workspace

; The printer port

	^	0,r11
DataReg		#	4				; This is the actual data bits to the printer
StatusReg	#	4				; This is the status register
CommandReg	#	4				; This controls the strobe et.al. pins
ECPAddr		#	4				; This is the EPP address port
ECPData0	#	4				; This is the EPP data port 0
ECPData1	#	4				; This is the EPP data port 0
ECPData2	#	4				; This is the EPP data port 0
ECPData3	#	4				; This is the EPP data port 0

; This is the start of the module

s
start							; No start of code
	DCD	start-s					; Module start
	DCD	init-s					; Initialisation
	DCD	final-s					; Finalisation
	DCD	service-s				; Service
	DCD	title-s					; Title string
	DCD	help-s					; Help string
	DCD	hcom-s					; Help and command table
	DCD	swichunk				; SWI number (not allocated)
	DCD	swicode-s				; SWI handler
	DCD	switabl-s				; SWI table
	DCD	0					; No SWI decoding code

title	=	"IZipFS",0
help	=	"IZipFS",9,9,"$vers ($date)",0
	ALIGN

hcom	=	"IZipFS",0
	ALIGN
	DCD	ZipFS-s
	DCD	0
	DCD	zipfs_syntax-s
	DCD	zipfs_help-s
	=	"IZipDevices",0
	ALIGN
	DCD	ZipDevices-s
	DCD	0
	DCD	zipdev_syntax-s
	DCD	zipdev_help-s
	=	"IZipProtect",0
	ALIGN
	DCD	ZipProtect-s
	DCD	&00010000
	DCD	zipprot_syntax-s
	DCD	zipprot_help-s
	=	"IZipUnprotect",0
	ALIGN
	DCD	ZipUnprotect-s
	DCD	&00010000
	DCD	zipunprot_syntax-s
	DCD	zipunprot_help-s
	=	"IZipErase",0
	ALIGN
	DCD	ZipErase-s
	DCD	0
	DCD	ziperase_syntax-s
	DCD	ziperase_help-s
	=	"IZipEject",0
	ALIGN
	DCD	ZipEject-s
	DCD	0
	DCD	zipeject_syntax-s
	DCD	zipeject_help-s
	=	"IZipNoTimeout",0
	ALIGN
	DCD	ZipNoTimeout-s
	DCD	0
	DCD	zipnotimeout_syntax-s
	DCD	zipnotimeout_help-s
	DCD	0

zipnotimeout_help
	=	"*IZipNoTimeout turns off the auto-spin down timer",10,13
zipnotimeout_syntax
	=	"Syntax: *IZipNoTimeout",0
zipfs_help
	=	"*IZipFS selects IZipFS as the current filing system",10,13
zipfs_syntax
	=	"Syntax: *IZipFS",0
zipdev_help
	=	"*IZipDevices lists all the devices connected to the Zip system",10,13
zipdev_syntax
	=	"Syntax: *IZipDevices",0
zipprot_help
	=	"*IZipProtect write-protects the current Zip disc",10,13
zipprot_syntax
	=	"Syntax: *IZipProtect [<password>]",0
zipunprot_help
	=	"*IZipUnprotect removes the write-protection from the current Zip disc",10,13
zipunprot_syntax
	=	"Syntax: *IZipUnprotect [<password>]",0
ziperase_help
	=	"*IZipErase destroys all data on the Zip drive, including write protection. The disc will not be formatted.",10,13
ziperase_syntax
	=	"Syntax: *IZipErase",0
zipeject_help
	=	"*IZipEject dismounts the Zip disc, and ejects the disc from the drive.",10,13
zipeject_syntax
	=	"Syntax: *IZipEject",0
	ALIGN

switabl	=	"IZipFS",0				; SWI Group name
	=	"Initialise",0				; Initialise ZIP drive
	=	"Eject",0				; Eject ZIP drive
	=	"Lock",0				; Lock ZIP drive
	=	"Unlock",0				; Unlock ZIP drive
	=	"SCSICommand",0				; Perform a SCSI command
	=	"DeviceInquiry",0			; Perform SCSI Command &12
	=	"Devices",0				; Display a list of SCSI devices
	=	"Reset",0				; Perform a reset
	=	"ReadOp",0				; Read sector(s)
	=	"WriteOp",0				; Write sector(s)
	=	"DiscOp",0				; FileCore_DiscOp type call
	=	"MiscOp",0				; FileCore_MiscOp
	=	"Drives",0				; FileCore_Drives
	=	"FreeSpace",0				; FileCore_Free
	=	"DescribeDisc",0			; FileCore_DescribeDisc
	=	"GetStatus",0				; Get status
	=	"VerifyOp",0				; Verify sector(s)
	=	"WriteProtect",0			; Write protection status
 [ NeedConfigureSMC = 1
	=	"ConfigureSMC",0			; Configure the SMC device
	=	"ECPMode",0				; Get the ECP mode
 ]
	=	"DiscFormat",0				; Get the disc format
	=	"BootChanged",0				; Check to see if the Boot sector's changed
	=	0
	ALIGN

 [ Debug=1
 [ DebugFile = 0
WriteS
	STMFD	r13!,{r0-r3}
	BIC	r3,lr,#&fc000003			; Clear the status registers
WSL	LDRB	r0,[r3],#1
	TEQ	r0,#0
	SWINE	XOS_WriteC
	BNE	WSL
	ADD	r3,r3,#3
	BIC	r3,r3,#3
	MOV	lr,r3
	LDMFD	r13!,{r0-r3}
	MOV	pc,lr					; Not MOVS, as we don't know what mode we're in...

Write0
; r0 points to string
	STMFD	r13!,{lr}
	SWI	XOS_Write0
	LDMFD	r13!,{pc}^
WriteC
	STMFD	r13!,{lr}
	SWI	XOS_WriteC
	LDMFD	r13!,{pc}^
NewLine
	STMFD	r13!,{lr}
	SWI	XOS_NewLine
	LDMFD	r13!,{pc}^
WriteColon
	STMFD	r13!,{lr}
	SWI	&20100+':'
	LDMFD	r13!,{pc}^
 |

DebugFile
	=	"Ram:$.ZipDebug",0
	ALIGN

OpenFile
	STMFD	r13!,{r0,r2-r6,lr}
	MOV	r0,#5
	ADR	r1,DebugFile
	SWI	XOS_File
	TEQ	r0,#1
	MOVEQ	r0,#192					; Open for update
	MOVNE	r0,#128
	SWI	XOS_Find
	MOVVS	r0,#0
	MOVS	r1,r0
	LDMEQFD	r13!,{r0,r2-r6,pc}^
	MOV	r1,r0
	MOV	r0,#2
	SWI	XOS_Args
	MOV	r0,#1
	SWI	XOS_Args
	LDMFD	r13!,{r0,r2-r6,pc}^

CloseFile
	STMFD	r13!,{r0,lr}
	MOV	r0,#0
	SWI	XOS_Find
	LDMFD	r13!,{r0,pc}^

WriteS
; lr points to string - must increment LR
	STMFD	r13!,{r0-r3}
	BIC	r3,lr,#&fc000003			; Clear the status registers
	BL	OpenFile
WSL	LDRB	r0,[r3],#1
	TEQ	r0,#0
	TEQNE	r1,#0
	SWINE	XOS_BPut
	BNE	WSL
	BL	CloseFile
	ADD	r3,r3,#3
	BIC	r3,r3,#3
	MOV	lr,r3
	LDMFD	r13!,{r0-r3}
	MOV	pc,lr					; Not MOVS, as we don't know what mode we're in...

Write0
; r0 points to string
	STMFD	r13!,{r0-r3,lr}
	MOV	r3,r0
	BL	OpenFile
W0L	LDRB	r0,[r3],#1
	TEQ	r0,#0
	TEQNE	r1,#0
	SWINE	XOS_BPut
	BNE	W0L
	BL	CloseFile
	LDMFD	r13!,{r0-r3,lr}

WriteC
; r0 is character
	STMFD	r13!,{r0-r3,lr}
	MOV	r3,r0
	BL	OpenFile
	MOVS	r0,r3
	TEQ	r1,#0
	SWINE	XOS_BPut
	BL	CloseFile
	LDMFD	r13!,{r0-r3,pc}^

NewLine
	STMFD	r13!,{r0-r3,lr}
	BL	OpenFile
	MOV	r0,#10
	TEQ	r1,#0
	SWINE	XOS_BPut
	BL	CloseFile
	LDMFD	r13!,{r0-r3,pc}^

WriteColon
	STMFD	r13!,{r0-r3,lr}
	BL	OpenFile
	MOV	r0,#':'
	TEQ	r1,#0
	SWINE	XOS_BPut
	BL	CloseFile
	LDMFD	r13!,{r0-r3,pc}^
 ]
 ]

; Module initialisation handler

init	STMFD	r13!,{r1-r9,lr}				; Store R14 (we're calling SWIs here)

	MOV	r3,#lor12				; Size of block

; I can't get the following code to work, so what the heck. Allocate a new block each initialisation
; (it's a very small block, after all!)

;	LDR	r2,[r12]				; Get the pointer
;	TEQ	r2,#0					; Is it a module initialisation, rather than RMTidy?
;	BNE	init_clearmemory			; Yup, so clear it, and set up the pointers

	MOV	r0,#6					; Start of module memory claim
	SWI	XOS_Module				; Claim the memory
	LDMVSFD	r13!,{lr}				; Ooops - can't claim - recall exit
	ORRVSS	pc,lr,#1<<26				; Set V, but preserve other flags

	STR	r2,[r12]				; Store that in the pointer

init_clearmemory
	MOV	r0,#0

	MOV	r7,r12					; We need this for the filing system...
	MOV	r12,r2					; Set R12 to the workspace memory

init_cm1
	STR	r0,[r2],#4
	SUBS	r3,r3,#4
	BGT	init_cm1				; Clear memory loop

	SWI	XParallel_HardwareAddress		; I hope this is on the NC, and the registers are as I hope they are
	STR	r0,ParallelAddress

; Now to create the FileCore filing system

	ADR	r0,FileCore_Header			; Descriptor block
	ADRL	r1,s					; Start of module
	MOV	r2,r7					; Private word
	MOV	r3,#1					; 1 Floppies, 0 hard disc, default drive=0, options=0
;	ORR	r3,r3,#4<<16				; Make it a default drive of 4
	MOV	r4,#16384				; 16K of directory cache
	MOV	r5,#0					; No background transfers
	MOV	r6,#0					; Map size

 [ InitZipFS = 1
	SWI	XFileCore_Create			; Create the filing system
	LDMVSFD	r13!,{r1-r9,lr}
	ORRVSS	pc,lr,#1<<28				; If there's an error....

	STR	r0,FC_Instance				; Store the instance word - the other registers are meaningless. FIQ and background transfers are not done

	LDRB	r0,FileCore_Header+3			; Get the FS number
	ADRL	r1,FreeSpaceH
	ADR	r2,FreeStack
	SWI	XFree_Register
 ]

	MOV	r0,#ppa_ukprotected
	STR	r0,WriteProtectM

	LDMFD	r13!,{r1-r9,lr}				; Read the return register
	BICS	pc,lr,#1<<28				; Clear V, just in case it's been set

FileCore_Header
	=	&98,0,0,111				; This is the Artichoke FS number. MUST NOT BE USED FOR FINAL PRODUCT
	DCD	fstitle-s
	DCD	boot-s
	DCD	discop-s
	DCD	miscop-s

boot	=	"ARM Designs ZIP Driver",0		; Boot up title
	ALIGN

fstitle	=	"IZipFS",0				; This is used by the *ZipFS command
	ALIGN

fskill	=	"FileCore%IZipFS",0			; This is used by the OS_Module 4 to kill ZipFS
	ALIGN

ZipDisc	=	"IZipFS::0",0				; This is the name of a Zip disc
	ALIGN

; Finalisation handler

final	STMFD	r13!,{r14}

; You may want to un-comment out this piece of coding...
;	LDR	r12,[r12]				; Get the pointer
;	BL	Eject					; Eject the drive (if it's there)

 [ InitZipFS = 1
	ADR	r2,ZipDisc
	MOV	r1,#&7d
	SWI	XOS_ServiceCall				; Tell everyone it's closing...

	MOV	r0,#4
	ADR	r1,fskill
	SWI	XOS_Module				; Kill the module

	LDRB	r0,FileCore_Header+3			; Get the FS number
	ADRL	r1,FreeSpaceH
	ADR	r2,FreeStack
	SWI	XFree_DeRegister

 ]

	BL	Unlock					; Unlock the drive

	LDMFD	r13!,{pc}^

ZipFS	STMFD	r13!,{r14}
	MOV	r0,#14					; Select it
	ADR	r1,fstitle				; Point to the title
	SWI	XOS_FSControl				; Select the FS
	LDMFD	r13!,{pc}

; Standard SWI handler

swicode	LDR	r12,[r12]				; Get workspace pointer
	CMP	r11,#(ukswi-swijump)/4			; Is the SWI table too high?
	ADDCC	pc,pc,r11,LSL#2
	BCS	ukswi

swijump	B	Initialise
	B	Eject
	B	Lock
	B	Unlock
	B	SCSICommand
	B	DeviceInquiry
	B	Devices
	B	Reset
	B	ReadOp
	B	WriteOp
	B	DiscOp
	B	MiscOp
	B	Drives
	B	FreeSpace
	B	DescribeDisc
	B	GetStatus
	B	ZipVerifyOp
	B	WriteProtect
 [ NeedConfigureSMC = 1
	B	ConfigureSMC
	B	ECPMode
 ]
	B	GetDiscFormat
	B	BootChangedCode

ukswi	ADR	r0,ukswie				; Point to error
	ORRS	pc,lr,#1<<28				; Set V and exit

ukswie	DCD	&1e6
	=	"Unknown IZipFS operation",0
	ALIGN

; SCSI Initialise - determine if the Zip drive is present, and also if we have to use nybble read-transfers or not.

Initialise
	STMFD	r13!,{r14}
	SWI	XPPADriver_Initialise
	LDMFD	r13!,{pc}^

; Eject a disc

EjectDisc
Eject
	STMFD	r13!,{r0-r3,lr}

	BL	Unlock					; Unlock the drive first
	BVS	EE

	ADR	r0,EjectCommand1
	ADR	r2,SCSITemp
	MOV	r3,#0					; Don't expect any data returned
	MOV	r1,#6					; 6 byte command
	SWI	XPPADriver_SCSICommandRetries

	TEQ	r0,#0
	BVS	EE

	ADR	r0,EjectCommand2
	ADR	r2,SCSITemp
	MOV	r3,#0					; Don't expect any data returned
	MOV	r1,#6					; 6 byte command
	SWI	XPPADriver_SCSICommandRetries

	TEQ	r0,#0
	BVS	EE

	LDMFD	r13!,{r0-r3,lr}
	BICS	pc,lr,#1<<28

EE	LDMFD	r13!,{r0-r3,lr}
	ADR	r0,EDE
	ORRS	pc,lr,#1<<28

EDE	DCD	errorchunk+error_eject
	=	"Unable to eject the drive",0
	ALIGN

EjectCommand1
	=	&1b,&c0,&00,&00
	=	&01,&00
EjectCommand2
	=	&1b,&c0,&00,&00
	=	&02,&00

; Lock a disc

Lock	STMFD	r13!,{r0-r3,lr}
	ADR	r0,LockDrive_Command
	MOV	r1,#6
	MOV	r2,#0
	MOV	r3,#0
	SWI	XPPADriver_SCSICommandRetries
	TEQ	r0,#0
	LDMFD	r13!,{r0-r3,lr}
	BICEQS	pc,lr,#1<<28
	ADR	r0,LDE
	ORRS	pc,lr,#1<<28

LockDrive_Command
	=	&1e,&c0,&00,&00
	=	&01,&00
	ALIGN

LDE	DCD	errorchunk+error_lock
	=	"Unable to lock Zip drive",0
	ALIGN

; Unlock a disc

Unlock	STMFD	r13!,{r0-r3,lr}
	ADR	r0,UnlockDrive_Command
	MOV	r1,#6
	MOV	r2,#0
	MOV	r3,#0
	SWI	XPPADriver_SCSICommandRetries
	TEQ	r0,#0
	LDMFD	r13!,{r0-r3,lr}
	BICEQS	pc,lr,#1<<28
	ADR	r0,UDE
	ORRS	pc,lr,#1<<28

UnlockDrive_Command
	=	&1e,&c0,&00,&00
	=	&00,&00
	ALIGN

UDE	DCD	errorchunk+error_unlock
	=	"Unable to unlock Zip drive",0
	ALIGN

; Resets the ZIP drive

Reset
	MOVS	pc,lr

; SCSICommand sends a SCSI command to the ZIP drive
; r0 is pointer to SCSI command header
; r1 is length of header
; r2 is pointer to Rx/Tx block (can overlap with command)
; r3 is length to Rx/Tx (must be the right size)
; returns r0 as 0 for success, or error type for failure (0-&FF is SCSI status, &100+ is other error)

SCSICommand
	STMFD	r13!,{r14}
	SWI	XPPADriver_SCSICommand
	LDMFD	r13!,{pc}

; GetStatus sends REQUEST_SENSE to the Zip drive in an effort to see what went wrong
; If there's no response, it returns &3A, or DriveEmpty error, otherwise it returns
; the error code in r0

GetStatus
	STMFD	r13!,{r1-r3,lr}
 [ DebugStatus=1
	BL	WriteS
	=	"GetStatus:",0
	ALIGN
 ]
	ADR	r0,RequestSenseCommand			; Point to the command
	MOV	r1,#6					; It's a 6-byte code
	ADR	r2,SCSITemp+256				; Point to a temporary block
	MOV	r3,#255
	SWI	XPPADriver_SCSICommand
	TEQ	r0,#0
	MOVNE	r0,#&3a					; There was a problem - drive is empty!
	LDREQB	r0,SCSITemp+12+256			; Get the sense code
 [ DebugStatus=1
	BL	PrintHex
	SWI	XOS_NewLine
 ]
	LDMFD	r13!,{r1-r3,pc}^			; And exit

RequestSenseCommand
	=	&03,&c0,&00,&00				; Command, LUN=6
	=	&FF,&00					; Read 255 bytes (max)
	ALIGN

; DeviceInquiry sends a IDENTIFY command to the requested LUN

DeviceInquiry
; r0 is LUN
; returns :
; r0 as pointer to manufacturer, or 0 for error occurred
; r1 as pointer to returned block

	STMFD	r13!,{r2-r3,lr}
	MOV	r0,r0,LSL#5+8
	ORR	r0,r0,#&12
	STR	r0,SCSITemp				; Make the first 4 bytes
	MOV	r0,#255
	STR	r0,SCSITemp+4				; And the next two (four)

	ADR	r0,SCSITemp				; Point to command
	MOV	r2,r0					; And to receive block
	MOV	r1,#6					; 6 bytes long Tx
	MOV	r3,#255					; 255 bytes long Rx
	SWI	XPPADriver_SCSICommandRetries

	TEQ	r0,#0					; Did everything go okay?
	MOVNE	r0,#0					; Nope, so return 0
	ADREQ	r1,SCSITemp				; Point to received block (again)
	ADDEQ	r0,r1,#8				; Point to manufacturer

	LDMFD	r13!,{r2-r3,lr}
	BICS	pc,lr,#1<<28

; ZipDevices is the *ZipDevices command code. It uses SCSIZip_Devices.

ZipDevices
	LDR	r12,[r12]

; Devices is the SCSIZip_Devices *command
; Note that in normal ZIP drive operation, device 6 is the ZIP drive, and 7 is the host

Devices
	STMFD	r13!,{r0-r2,lr}
	SWI	XOS_WriteS
	=	"# Type      Vendor   Product          Rev.",10,13,0
	ALIGN
	MOV	r2,#0
DevLoop
	MOV	r0,r2
	BL	DeviceInquiry				; Do the DeviceInqury

	TEQ	r0,#0
	BEQ	D_NoDevice				; There isn't a device there

	MOV	r1,r0

	ADD	r0,r2,#48
	SWI	XOS_WriteC				; Print the device number
	SWI	&20100+' '				; And a space

	MOV	r0,r1

	TEQ	r2,#ppa_host
	BEQ	D_Host
	SWI	XOS_WriteS
	=	"Unknown   ",0				; Print this pseudo-type
	ALIGN
D_RetHost

	MOV	r1,#8
	BL	D_Print					; Print vendor
	SWI	&20100+' '				; Space

	ADD	r0,r0,#8				; Point to next bit (Product)
	MOV	r1,#16
	BL	D_Print					; Print product
	SWI	&20100+' '				; Space

	ADD	r0,r0,#16				; Point to next bit (Product)
	MOV	r1,#4
	BL	D_Print					; Print revision
	SWI	XOS_NewLine				; And a new line

D_NoDevice
	ADD	r2,r2,#1
	TEQ	r2,#8
	BNE	DevLoop					; Go on to the next device

	LDMFD	r13!,{r0-r2,lr}
	BICS	pc,lr,#1<<28

D_Host	SWI	XOS_WriteS
	=	"Host      ",0				; And this is the host card
	ALIGN
	B	D_RetHost

D_Print
	STMFD	r13!,{r0-r2,lr}
	MOV	r2,r0

DP_L	LDRB	r0,[r2],#1				; Get the character

	CMP	r0,#32					; Is it legal?
	BLT	DP_EL					; Nope, so make this the end of line

	SWI	XOS_WriteC				; The character's legal, so print it!

	SUBS	r1,r1,#1
	BGT	DP_L					; Until we've got to the length of the string

	LDMFD	r13!,{r0-r2,pc}

DP_EL	SWI	&20100+' '				; Print a space instead

	SUBS	r1,r1,#1
	BGT	DP_EL					; Until we've reached the length we wanted (either 4, 8 or 16)

	LDMFD	r13!,{r0-r2,pc}

; MakeRWCommand creates a 10-byte read/write command in SCSITemp
; On entry, r0 is command byte (&28 for read, &2a for write)
; On exit, r0 is corrupted

MakeRWCommand
	ORR	r0,r0,#&c000				; Use LUN 6 (Zip)
	STR	r0,SCSITemp+0				; Store the command and LUN
	MOV	r0,#0
	STR	r0,SCSITemp+4				; Some other bits
	STR	r0,SCSITemp+8				; And some more bits
	MOVS	pc,lr

; SetSector sets the 10-byte read/write command's sector
; On entry, r0 is sector number (for Zip, 0->&2ffff)
; On exit, r0 is corrupted

SetSector
	STRB	r0,SCSITemp+5				; LLSB
	MOV	r0,r0,LSR#8
	STRB	r0,SCSITemp+4				; MLSB
	MOV	r0,r0,LSR#8
	STRB	r0,SCSITemp+3				; LMSB
	MOV	r0,r0,LSR#8
	STRB	r0,SCSITemp+2				; MMSB
	MOVS	pc,lr

; SetSectors sets the 10-byte read/write command's number of sectors to read
; On entry, r0 is #sectors 0 to &ffff
; On exit, r0 is corrupted

SetSectors
	STRB	r0,SCSITemp+8				; LSB
	MOV	r0,r0,LSR#8
	STRB	r0,SCSITemp+7				; MSB
	MOVS	pc,lr

; SectorOp performs the read/write sector
; r1 is the number of bytes to transfer
; On exit, r0 is 0 for success, or error code for failure
; r1 is the number of bytes not transferred

SectorOp
	STMFD	r13!,{r2-r4,lr}
	MOV	r2,#0
	STRB	r2,SCSITemp+6
	STRB	r2,SCSITemp+9
	MOV	r4,#5					; 5 retries (if necessary)
	MOV	r2,r0					; Point to data
	MOV	r3,r1					; And the #bytes

SO_Loop	ADR	r0,SCSITemp				; Point to command
	MOV	r1,#10					; 10 byte long command
	SWI	XPPADriver_SCSICommandRetries
	TEQ	r0,#0
	BEQ	SO_OK					; SectorOp performed OK

	STMFD	r13!,{r0-r3}
	SWI	XPPADriver_Initialise			; Clear the failed command
	BL	GetStatus
	LDMFD	r13!,{r0-r3}

	SUBS	r4,r4,#1
	BGT	SO_Loop
	LDMFD	r13!,{r2-r4,lr}
	ORRS	pc,lr,#1<<28

SO_OK	MOVS	r1,r3					; This is how many bytes not read
	MOVMI	r1,#0					; Due to a slight problem with PPA3, an extra byte is read, so cut it out!
	LDMFD	r13!,{r2-r4,pc}^			; Exit (SCSICommand will set up the error)

 [ Debug=1
PrintHex
	STMFD	r13!,{r0-r2,lr}
	MOV	r2,#12
	ADR	r1,SCSITemp+512
	SUB	r1,r1,#12
	SWI	XOS_ConvertHex8
	MOV	r1,#0
	STRB	r1,[r0,#8]
	BL	Write0
	LDMFD	r13!,{r0-r2,pc}^
 ]

; ReadOp is a FileCore_DiscOp compliant sector reader
; On entry:
; r2 is disc address (doesn't have to be sector aligned)
; r3 is pointer to buffer
; r4 is length (doesn't have to be sector aligned, but it helps!)
; On exit:
; r2 as disc address of next byte
; r3 as pointer to next buffer
; r4 as number of bytes not transferred

Read
ReadOp
	CMP	r4,#0					; If there's no data, don't do it
	MOVLES	pc,lr

	STMFD	r13!,{r0,r1,lr}

 [ DebugOps = 1
	BL	WriteS
	=	"ReadOp - ",0
	ALIGN

	MOV	r0,r2
	BL	PrintHex
	BL	WriteColon

	MOV	r0,r3
	BL	PrintHex
	BL	WriteColon

	MOV	r0,r4
	BL	PrintHex
  [ DebugWriteStatus = 0
	BL	NewLine
  ]
 ]

	MOV	r0,#&28
	BL	MakeRWCommand

	MOV	r1,#ppa_sectorsize
	SUB	r1,r1,#1

	BIC	r0,r2,#7<<29				; Mask out drive
	MOV	r0,r0,LSR#ppa_sectorshift
	BL	SetSector				; And make the sector number

	ADD	r0,r4,r1
	BIC	r0,r0,r1				; Round it up
	MOV	r0,r0,LSR#ppa_sectorshift
	BL	SetSectors				; Set how many sectors we're writing

	MOV	r0,r3					; Data pointer
	MOV	r1,r4					; Data length

	ADD	r2,r2,r4				; Add the end
	ADD	r3,r3,r4				; Do the same for the buffer

	BL	SectorOp				; Write the sector(s)
	TEQ	r0,#0
	BNE	RO_Error				; There's an error - put everything back, and make up a response

	SUB	r2,r2,r1				; If any's been unwritten, decrement address
	SUB	r3,r3,r1				; Similarly, for sectors
	MOV	r4,r1
  [ DebugWriteStatus = 1
	BL	NewLine
  ]
	LDMFD	r13!,{r0,r1,lr}
	BICS	pc,lr,#1<<28				; And exit

RO_Error
;
; This code is temporary - I'll produce a proper error code if I need to, later.
;
 [ DebugOps = 1
	BL	PrintHex
	BL	WriteS
	=	"->Read Error",10,13,0
	ALIGN
 ]
	LDMFD	r13!,{r0,r1,lr}
	ADR	r0,ROErr				; Point to error
	ORR	r0,r0,#1<<30
	ORRS	pc,lr,#1<<28				; And exit

ROErr	DCD	errorchunk+error_write
	=	"Read error from Zip drive",0
	ALIGN

; WriteOp is a FileCore_DiscOp compliant sector writer
; On entry:
; r2 is disc address (doesn't have to be sector aligned)
; r3 is pointer to buffer
; r4 is length (doesn't have to be sector aligned, but it helps!)
; On exit:
; r2 as disc address of next byte
; r3 as pointer to next buffer
; r4 as number of bytes not transferred

Write
WriteOp

	STMFD	r13!,{r0,lr}

; First work out if the Boot sector's one of those changed

	CMP	r2,#&e00				; &e00 is above the boot sector
	BGT	WO_NotBoot

	ADD	r0,r2,r4
	CMP	r0,#&c00				; &e00 is still above the boot sector
	MOVGT	r0,#1
	STRGT	r0,BootChanged

WO_NotBoot

	LDR	r0,WriteProtectM
	CMP	r0,#ppa_ukprotected
	BEQ	WO_GetWP				; Well, we don't know if it's protected
	TST	r0,#ppa_protected
	BNE	WO_ProtErr				; Oh dear, it's protected
	BEQ	WO_OK

WO_GetWP
	BL	WP_getprotection
	TST	r0,#ppa_protected
	BEQ	WO_OK					; It is not protected

WO_ProtErr
	LDMFD	r13!,{r0,lr}
	ADR	r0,ZipWPE
	ORR	r0,r0,#1<<30
	ORRS	pc,lr,#1<<28				; Mark the error as write protected
ZipWPE
	DCD	errorchunk+error_writeprot
	=	"The Zip disc has been write protected.",0
	ALIGN

WO_OK	LDMFD	r13!,{r0,lr}

;WO_SK
;	SSO

	CMP	r4,#0					; If there's no data, don't do it
	MOVLES	pc,lr

	STMFD	r13!,{r0,r1,lr}

 [ DebugOps = 1
	BL	WriteS
	=	"WriteOp - ",0
	ALIGN

	MOV	r0,r2
	BL	PrintHex
	BL	WriteColon

	MOV	r0,r3
	BL	PrintHex
	BL	WriteColon

	MOV	r0,r4
	BL	PrintHex
  [ DebugWriteStatus = 0
	BL	NewLine
  ]
 ]

	MOV	r0,#&2a
	BL	MakeRWCommand

	MOV	r1,#ppa_sectorsize
	SUB	r1,r1,#1

	BIC	r0,r2,#7<<29				; Mask out drive
	MOV	r0,r0,LSR#ppa_sectorshift
	BL	SetSector				; And make the sector number

	ADD	r0,r4,r1
	BIC	r0,r0,r1				; Round it up
	MOV	r0,r0,LSR#ppa_sectorshift
	BL	SetSectors				; Set how many sectors we're writing

	MOV	r0,r3					; Data pointer
	MOV	r1,r4					; Data length

	ADD	r2,r2,r4				; Add the end
	ADD	r3,r3,r4				; Do the same for the buffer

	BL	SectorOp				; Write the sector(s)
	TEQ	r0,#0
	BNE	WO_Error				; There's an error - put everything back, and make up a response

	SUB	r2,r2,r1				; If any's been unwritten, decrement address
	SUB	r3,r3,r1				; Similarly, for sectors
	MOV	r4,r1
  [ DebugWriteStatus = 1
	BL	NewLine
  ]
	LDMFD	r13!,{r0,r1,lr}
	BICS	pc,lr,#1<<28				; And exit

WO_Error
;
; This code is temporary - I'll produce a proper error code if I need to, later.
;
 [ DebugOps = 1
	BL	PrintHex
	BL	WriteS
	=	"->Write Error",10,13,0
	ALIGN
 ]
	LDMFD	r13!,{r0,r1,lr}
	ADR	r0,WOErr				; Point to error
	ORR	r0,r0,#1<<30
	ORRS	pc,lr,#1<<28				; And exit

WOErr	DCD	errorchunk+error_write
	=	"Write error from Zip drive",0
	ALIGN

; VerifyOp is basically a read while reading no data. Most of the code is copied from

Verify
ZipVerifyOp
	CMP	r4,#0					; If there's no data, don't do it
	MOVLES	pc,lr

	SSO						; This is gonna be done a sector at a time...

	STMFD	r13!,{r0,r1,r3,lr}

 [ DebugOps = 1
	BL	WriteS
	=	"VerifyOp - ",0
	ALIGN

	MOV	r0,r2
	BL	PrintHex
	BL	WriteColon

	MOV	r0,r4
	BL	PrintHex
	BL	NewLine
 ]

	MOV	r0,#&2F					; Verify instructions
	BL	MakeRWCommand

	MOV	r1,#ppa_sectorsize
	SUB	r1,r1,#1

	BIC	r0,r2,#7<<29				; Mask out drive
	MOV	r0,r0,LSR#ppa_sectorshift
	BL	SetSector				; And make the sector number

	ADD	r0,r4,r1
	MOV	r0,r0,LSR#ppa_sectorshift
	BL	SetSectors				; Set how many sectors we're reading

	MOV	r0,#0
	MOV	r1,#0					; It's pointing to address zero, but we are reading no bytes!

	ADD	r2,r2,r4				; Add the end

	BL	SectorOp				; Read the sector(s)
	TEQ	r0,#0
	BNE	VO_Error				; There's an error - put everything back, and make up a response

	MOV	r4,#0					; I can't see there being any errors
	LDMFD	r13!,{r0,r1,r3,lr}
	BICS	pc,lr,#1<<28				; And exit

VO_Error
;
; This code is temporary - I'll produce a proper error code if I need to, later.
;
 [ DebugOps = 1
	BL	PrintHex
	SWI	XOS_WriteS
	=	"->Verify Error",10,13,0
	ALIGN
 ]
	LDMFD	r13!,{r0,r1,r3,lr}
	ADR	r0,VOErr				; Point to error
	ORR	r0,r0,#1<<30
	ORRS	pc,lr,#1<<28				; And exit

VOErr	DCD	errorchunk+error_verify
	=	"Read error from Zip drive",0
	ALIGN

; DiscOp is the interface to FileCore_DiscOp

DiscOp
	STMFD	r13!,{r8,r14}				; This is copied out of page 2-589 of the PRMs
	LDR	r8,FC_Instance
	SWI	XFileCore_DiscOp
	LDMFD	r13!,{r8,pc}

; MiscOp is the interface to FileCore_MiscOp

MiscOp
	STMFD	r13!,{r8,r14}				; This is copied out of page 2-589 of the PRMs
	LDR	r8,FC_Instance
	SWI	XFileCore_MiscOp
	LDMFD	r13!,{r8,pc}

; Drives is the interface to FileCore_Drives

Drives
	STMFD	r13!,{r8,r14}				; This is copied out of page 2-589 of the PRMs
	LDR	r8,FC_Instance
	SWI	XFileCore_Drives
	LDMFD	r13!,{r8,pc}

; MiscOp is the interface to FileCore_FreeSpace

FreeSpace
	STMFD	r13!,{r8,r14}				; This is copied out of page 2-589 of the PRMs
	LDR	r8,FC_Instance
	SWI	XFileCore_FreeSpace
	LDMFD	r13!,{r8,pc}

; DescribeDisc is the interface to FileCore_DescribeDisc

DescribeDisc
	STMFD	r13!,{r8,r14}				; This is copied out of page 2-589 of the PRMs
	LDR	r8,FC_Instance
	SWI	XFileCore_DescribeDisc
	LDMFD	r13!,{r8,pc}

; discop is what FileCore calls to perform my low-level operations

discop

; We MUST support 0,1,2,5 and 6, ie. Verify, Read, Write, Seek, Restore
	STMFD	r13!,{r0,r1,r5-r12,lr}
	AND	r0,r2,#7<<29
	TEQ	r0,#0<<29				; Is it this disc?
	BNE	ukdiscop				; Nope, so ignore it!

	LDR	r12,[r12]
	LDR	r11,ParallelAddress

	TST	r1,#1<<5				; Is this a list?
	BNE	DiscOpList

 [ DebugDiscOp = 1
	SWI	XOS_WriteS
	=	"DiscOp:",0
	ALIGN

	AND	r0,r1,#7
	ORR	r0,r0,#48
	SWI	XOS_WriteC

	MOV	r0,r2
	BL	PrintHex
	BL	WriteColon
	MOV	r0,r3
	BL	PrintHex
	BL	WriteColon
	MOV	r0,r4
	BL	PrintHex
	BL	WriteColon

	SWI	XOS_NewLine
 ]

	AND	r1,r1,#15
	CMP	r1,#(eodopl-sodopl)/4
	MOV	lr,pc
	ADDCC	pc,pc,r1,LSL#2				; And jump to the operation
	B	eodopl

sodopl	B	Verify					; 0 - Verify
	B	Read					; 1 - Read
	B	Write					; 2 - Write
	B	ukdiscop				; 3 - Read track/Read ID
	B	ukdiscop				; 4 - Write track
	B	Seek					; 5 - Seek
	B	Restore					; 6 - Restore
eodopl							; End of DiscOp list
Seek							; Seek doesn't do anything, as that's organised by the drive itself
Restore							; Neither does restore (I think - I'll look at it later, when it doesn't work!)
ukdiscop
	STRVS	r0,[r13]
	LDMFD	r13!,{r0,r1,r5-r12,lr}
	BICVCS	pc,lr,#1<<28
	ORRVSS	pc,lr,#1<<28

; DiscOpList is called whenever DiscOp is called, with bit 5 of r1 set. It performs pseudo-DiscOps to perform the same operation

DiscOpList
 [ DebugMultiOp = 1
	BL	WriteS
	=	"Bulk DiscOp:",0
	ALIGN
	AND	r0,r1,#15
	ORR	r0,r0,#48
	BL	WriteC
	BL	NewLine
 ]

	MOV	r5,r3					; r5 now points to block
	MOV	r6,r4					; r6 is new length
	AND	r1,r1,#15				; Make it the relevant bits
	MOV	r7,#0					; In case the length is zero!
DOL_Loop
	CMP	r6,#0					; Have we reached the end yet?
	BLE	bulkop_end

	LDMIA	r5,{r3,r4}				; Read the address/length pair
 [ DebugMultiOp = 1
	BL	WriteS
	=	"Multi:",0
	ALIGN
	MOV	r0,r2
	BL	PrintHex
	BL	WriteColon
	MOV	r0,r3
	BL	PrintHex
	BL	WriteColon
	MOV	r0,r4
	BL	PrintHex
	BL	WriteColon
	MOV	r0,r5
	BL	PrintHex
	BL	WriteColon
	MOV	r0,r6
	BL	PrintHex
	BL	NewLine
 ]
	SUBS	r7,r4,r6				; Find out if we're copying too much
	MOVMI	r7,#0					; If we are, don't adjust for it
	MOVPL	r4,r6					; But make sure we do only what is necessary
	SUB	r6,r6,r4				; Set the number of bytes left before operation
	CMP	r1,#(eodlpl-sodlpl)/4			; Too far?
	MOV	lr,pc
	ADDCC	pc,pc,r1,LSL#2				; Shift by 2
	B	eodlpl

sodlpl	B	Verify					; 'Bulk' transfers can only occur for operations 0, 1 or 2
	B	Read
	B	Write

eodlpl	ADDS	r6,r6,r4				; Add any untransferred bytes
	ADD	r7,r7,r4				; Add in the adjustment for any uncopied bytes
	STMIA	r5!,{r3,r7}				; Store the old positions (but only in the last ones)
	TEQ	r4,#0
	BEQ	DOL_Loop

bulkop_end
	TEQ	r7,#0					; Was the last one finished
	SUBNE	r3,r5,#8				; No, so point to it instead
	MOVEQ	r3,r5					; Otherwise, point to the end of the list

	LDMFD	r13!,{r0,r1,r5-r12,pc}^			; Exit the list

; miscop is the FileCore MiscOp handler

miscop
 [ DebugMiscOp =1
	STMFD	r13!,{r14}
	SWI	XOS_WriteS
	=	"MiscOp:Entry",10,13,0
	ALIGN
	BL	miscope
	BVS	misce
	SWI	XOS_WriteS
	=	"MiscOp:Exit",10,13,0
misce	LDMFD	r13!,{pc}

miscope
 ]

	STMFD	r13!,{r11,r12,lr}
	LDR	r12,[r12]
	LDR	r11,ParallelAddress

	TEQ	r1,#0
	BNE	ukmiscop				; Can only handle accesses to our drive
 [ DebugMiscOp = 1
	SWI	XOS_WriteS
	=	"MiscOp:",0
	ALIGN

	ORR	r0,r0,#48
	SWI	XOS_WriteC
	AND	r0,r0,#15

	SWI	XOS_NewLine
 ]

	CMP	r0,#(eomopl-somopl)/4
	LDMCSFD	r13!,{r11,r12,pc}
	MOV	lr,pc					; Fake a link
	ADDCC	pc,pc,r0,LSL#2				; Jump to the right operation
	B	ukmiscop				; And exit
somopl	B	Mount					; 0 - Mount disc (and read information)
	B	PollChanged				; 1 - Poll changed
	B	LockDisc				; 2 - Lock disc
	B	UnlockDisc				; 3 - Unlock disc
	B	PollPeriod				; 4 - Poll period
	B	EjectDisc				; 5 - Eject drive
eomopl							; End of the miscop entry codes
ukmiscop
	LDMFD	r13!,{r11,r12,lr}			; Exit with no fuss
	ORRVSS	pc,lr,#1<<28
	BICS	pc,lr,#1<<28

Disc
	=	"disc",0				; This is the string used when displaying a message to insert disc
	ALIGN

PollPeriod
	MOV	r5,#100
	ADR	r6,Disc
	MOVS	pc,lr

Mount
	STMFD	r13!,{r0-r5,lr}
	MOV	r0,#ppa_ukprotected
	STR	r0,WriteProtectM
	MOV	r0,#format_unknown
	STR	r0,DiscFormat
MountLoop
	MOV	r2,#&c00				; Point to boot block
	ADR	r3,SCSITemp				; Point to temporary memory
	MOV	r4,#512
	BL	ReadOp					; Read the boot block sector
	BVC	Mount0

	BL	GetStatus				; Get the status of the error

	TEQ	r0,#&29					; Has it just powered up?
	TEQEQ	r0,#&28					; Has the medium changed?
	BEQ	MountLoop				; Yes, so try again

	TEQ	r0,#&3a					; Is the drive empty?
	MOVNE	r0,#&9a					; No - it's another error...
	MOVEQ	r0,#&d3					; Yes, so make that error
	LDMFD	r13!,{r0-r5,lr}				; Restore registers
	ORRS	pc,lr,#1<<28				; Exit with error

Mount0
; SCSITemp+&1c0 now has disc record - copy it into r5

;	ADR	r0,NoSpinCommand
;	MOV	r1,#0
;	ADR	r2,SCSITemp
;	MOV	r3,#0
;	SWI	XPPADriver_SCSICommandRetries

; This reads the physical layout of the disc

	LDR	r2,SCSITemp+&1c0
	LDR	r0,TestCheck
	BEQ	isnf

	LDRB	r2,SCSITemp+&1c0			; Read secs_per_track
	TEQ	r2,#9
	BNE	not_formatted

	LDR	r2,SCSITemp+&1d0			; Read disc size
	TEQ	r2,#&06000000				; 100MBytes?
	BNE	not_formatted

	MOV	r0,#format_acorn
	STR	r0,DiscFormat

	MOV	r0,#56
	ADR	r1,SCSITemp+&1c0			; Point to the disc record
MountL0	LDR	r2,[r1,r0]				; Copy the word
	STR	r2,[r5,r0]
	SUBS	r0,r0,#4
	BGE	MountL0					; And the next one!

	LDMFD	r13,{r0-r4}				; re-read the required registers
	BL	ReadOp					; Do the required read operation
	LDMFD	r13!,{r0-r5,lr}				; And exit
	BICS	pc,lr,#1<<28

; This is not an Acorn formatted disc.

not_formatted
	ADR	r1,dos_sector				; If it's not ADFS format, fake a sector type
	MOV	r0,#56
MountL1	LDR	r2,[r1,r0]				; Copy the word
	STR	r2,[r5,r0]
	SUBS	r0,r0,#4
	BGE	MountL1					; And the next one!
	LDMFD	r13,{r0-r4}				; re-read the required registers
	BL	ReadOp					; Do the required read operation
	LDMFD	r13!,{r0-r5,lr}				; And exit
	MOV	r0,#format_acorn
	STR	r0,DiscFormat
	BICS	pc,lr,#1<<28

TestCheck
	=	"©JPT"					; Silly bit of text, really!

; This is the non-formatted exit.

isnf
	LDMFD	r13!,{r0-r5,lr}
	ADR	r0,nf_error
	ORR	r0,r0,#1<<30
	ORRS	pc,lr,#1<<28
nf_error
	DCD	errorchunk+error_notform
	=	"Disc not FileCore formatted",0
	ALIGN

; If it doesn't look like an Acorn disc, then this is how we get the service
; handler to recognise that it's IZipFiler which is requesting
; Service_IdentifyDisc. For some reason, doing it the way I'd expect it to
; work didn't. FileCore didn't pass on the call.

dos_sector
	=	6,16,16,0					; This is a fake DOS disc structure
	=	0,0,0,0
	=	1,0,0,0
	DCD	0
d8183	DCD	&d8183						; This is the size
	%	12
	DCD	0
	%	28
fc8	DCD	&fc8						; Disc type (&FC8 is DOSDisc)
rboot	DCD	&101009						; This is the real DOS structure
FAT16	=	"FAT16"						; And here's how we recognise it
	ALIGN

; This service call is a slight bodge in order to get DOS discs read
; properly.

service
	TEQ	r1,#&69						; Is it a Service_IdentifyDisc?
	MOVNE	pc,lr
	STMFD	r13!,{r0,lr}

	LDR	r0,[r5,#16]
	LDR	lr,d8183
	TEQ	r0,lr
	LDMNEFD	r13!,{r0,pc}

	LDR	r0,[r5]
	LDR	lr,dos_sector
	TEQ	r0,lr
	LDMNEFD	r13!,{r0,pc}

	LDR	r0,[r5,#8]
	TEQ	r0,#1
	LDMNEFD	r13!,{r0,pc}

	LDR	r12,[r12]

	STMFD	r13!,{r1-r7}

	ADR	r3,Stack__Free
	MOV	r2,#&4000
	MOV	r4,#64
	SWI	XZipFS_ReadOp

	ADR	r3,Stack__Free

	ADD	r2,r3,#52
	LDMIA	r2,{r0,r1}
	MOV	r0,r0,LSR#16
	ORR	r0,r0,r1,LSL#16
	MOV	r1,r1,LSR#16
	AND	r1,r1,#&ff
	ADR	r2,FAT16
	LDMIA	r2,{r2,r4}
	TEQ	r2,r0
	TEQEQ	r1,r4
	LDMNEFD	r13!,{r1-r7}
	LDMNEFD	r13!,{r0,pc}

	ADD	r3,r3,#43
	ADD	r4,r5,#22

	LDRB	r0,[r3]
	CMP	r0,#32
	ADRLE	r3,untitled_str

dosname	LDRB	r0,[r3],#1
	CMP	r0,#32
	MOVLE	r0,#0
	STRB	r0,[r4],#1
	BGT	dosname

	LDMFD	r13!,{r1-r7}

	MOV	r1,#0
	LDR	r2,fc8
	STR	r2,[r5,#32]
	MOV	r0,#&30000*512
	STR	r0,[r5,#16]
	LDR	r0,rboot
	STR	r0,[r5,#0]
	MOV	r0,#format_dos
	STRB	r0,DiscFormat
	LDMFD	r13!,{r0,pc}

untitled_str
	=	"Untitled",0
	ALIGN

; PollChanged checks to see if the disc has changed. This isn't really
; useful, as ZipFiler has tight controls over the discs changing, but
; the code's there... This code isn't quite right, as the PRMs are
; a little vague as to the method of doing this, and Acorn's SCSI
; source is a little jumpy for my liking.

PollChanged
	STMFD	r13!,{r0-r2,r4-r8,lr}
	ADR	r0,ReadCapacityCommand			; Point to command to read drive capacity
	MOV	r1,#10					; It's a 10 byte command
	ADR	r2,SCSITemp				; Point to the returned data
	MOV	r3,#255					; And also how many bytes we're going to transfer
	SWI	XPPADriver_SCSICommand

	TEQ	r0,#0					; Was there a problem?
 [ DebugMiscOp = 1
	SWIEQ	&20100+'O'
	SWIEQ	XOS_NewLine
 ]
	MOVEQ	r3,#2_11010001				; Mark it as okay
	LDMEQFD	r13!,{r0-r2,r4-r8,pc}			; And return

PC_Loop
	BL	GetStatus				; Get the SCSI status

	TEQ	r0,#0
 [ DebugMiscOp = 1
	SWIEQ	&20100+'O'
	SWIEQ	XOS_NewLine
 ]
	MOVEQ	r3,#2_11010001				; I don't know what happened here...
	LDMEQFD	r13!,{r0-r2,r4-r8,pc}^			; Oh well, just exit anyway!

	TEQ	r0,#&28					; Is it disc changed?
	BNE	PC_CheckEmpty				; No, so see if it's empty
 [ DebugMiscOp = 1
	SWI	&20100+'C'
	SWI	XOS_NewLine
 ]
;	ADR	r0,dismount_disc
;	SWI	XOS_CLI					; Dismount it
;	ADR	r0,disc
;	ADR	r1,SCSITemp
;	B	DescribeDisc				; Remount it
;	ADR	r0,mount_disc
;	SWI	XOS_CLI					; And remount it...
	MOV	r3,#ppa_ukprotected			; Protection is unknown
	STR	r3,WriteProtectM
	MOV	r3,#2_11010010				; Mark it as changed
	LDMFD	r13!,{r0-r2,r4-r8,pc}^			; Exit

;mount_disc
;	=	"-zipfs-Mount :0",0
;	ALIGN

PC_CheckEmpty
	TEQ	r0,#&3a					; Is the drive is empty?
	BNE	PC_Loop					; Well, we weren't told here...

	MOV	r3,#2_11001000				; It's empty!
 [ DebugMiscOp = 1
	SWI	&20100+'E'
	SWI	XOS_NewLine
 ]
	LDMFD	r13!,{r0-r2,r4-r8,pc}^			; Exit

ReadCapacityCommand
	=	&25,&c0,&00,&00
	=	&00,&00,&00,&00
	=	&00,&00,&00,&00

; These aren't used, as IZipFiler locks and unlocks the disc.

LockDisc
	MOVS	pc,lr

UnlockDisc
	MOVS	pc,lr

; WriteProtect is the code to protect and unprotect the disc.

WriteProtect
; r0 is 0 for unprotect, 2 for protect, -1 for get protection
; r1 is pointer to zero-terminated password, or 0 for none
; returns registers preserved if r0<>-1, or 0 for unprotected, 2 for protected, 3 for password protected

	CMP	r0,#-1
	BEQ	WP_getprotection

	STMFD	r13!,{r0,r1,lr}
	BL	WP_forcegetprotection
	LDMVSFD	r13!,{r0,r1,lr}
	BVS	WP_error

	TEQ	r0,#3
	LDMFD	r13!,{r0,r1,lr}
	TEQEQ	r1,#0
	BEQ	WP_error2				; Write protection needs password

	STMFD	r13!,{r0-r3,lr}

	TEQ	r1,#0
	ORRNE	r0,r0,#1
	TEQ	r0,#1
	MOVEQ	r0,#0
	ORR	r0,r0,#&c0
	MOV	r0,r0,LSL#8
	ORR	r0,r0,#&0c				; Set protection command
	STR	r0,SCSITemp				; Store first four bytes of command

	MOV	r0,#ppa_ukprotected
	STR	r0,WriteProtectM

	MOV	r3,#0
	TEQ	r1,#0
	BEQ	WP_nopass				; If there is no password, don't count it

	ADR	r2,SCSITemp+8
WP_setl	LDRB	r0,[r1,r3]
	CMP	r0,#32
	MOVLT	r0,#0
	STRB	r0,[r2,r3]
	ADD	r3,r3,#1
	BGE	WP_setl					; If there's more to do...

WP_nopass
	STR	r3,SCSITemp+4				; And then the next two bytes
	ADR	r0,SCSITemp
	MOV	r1,#6
	ADR	r2,SCSITemp+8
	MOV	r3,#128
	SWI	XPPADriver_SCSICommand
;	TEQ	r0,#0
;	LDMNEFD	r13!,{r0-r3,lr}
;	BNE	WP_error

	BL	WP_waitwhile
	BL	WP_forcegetprotection
	LDMVSFD	r13!,{r0-r3,lr}
	BVS	WP_error
	AND	r0,r0,#2
	LDR	r1,[r13]
	AND	r1,r1,#2
	TEQ	r0,r1
	LDMFD	r13!,{r0-r3,lr}
	BICEQS	pc,lr,#1<<28

WP_error2
	ADR	r0,WPE2
	ORRS	pc,lr,#1<<28
WPE2	DCD	errorchunk+error_wpnpass
	=	"Write protection password incorrect",0
	ALIGN

WP_waitwhile
	STMFD	r13!,{r0,r1,lr}
	SWI	XOS_ReadMonotonicTime
	ADD	r0,r1,#50
WP_wwl	SWI	XOS_ReadMonotonicTime
	CMP	r0,r1
	BLT	WP_wwl
	LDMFD	r13!,{r0,r1,pc}^

WP_getprotection
	LDR	r0,WriteProtectM
	CMP	r0,#ppa_ukprotected
	MOVNES	pc,lr					; We know what the protection is...

WP_forcegetprotection
	STMFD	r13!,{r1-r3,lr}

	ADR	r0,WP_gpmcmd
	MOV	r1,#6
	ADR	r2,SCSITemp
	MOV	r3,#256
	SWI	XPPADriver_SCSICommandRetries

	LDRB	r0,SCSITemp+21
	AND	r0,r0,#&f
	STR	r0,WriteProtectM
	LDMFD	r13!,{r1-r3,pc}^

WP_gpmcmd
	DCD	&02c006
	DCD	128

WP_error
	ADR	r0,WPE
	ORRS	pc,lr,#1<<28
WPE	DCD	errorchunk+error_nowp
	=	"Unable to read write protection status",0
	ALIGN

 [ NeedConfigureSMC = 1

ConfigureSMC
; r0 is value to write, or -1 to read
; r1 is register number
; returns r0 as value
	STMFD	r13!,{r2,r11,lr}
	LDR	r11,ParallelAddress
	SUB	r11,r11,#&278<<2
	ADD	r11,r11,#&3f0<<2
; r11 is now pointer to configuration mode
	MOV	r2,#&55
	STRB	r2,[r11,#0]				; Initialise configuration status
	STRB	r2,[r11,#0]				; Initialise configuration status
	STRB	r1,[r11,#0]				; Set the register
	CMP	r0,#0
	LDRMIB	r0,[r11,#4]				; Read the register status
	STRPLB	r0,[r11,#4]				; Set the configuration status
	MOV	r2,#&aa
	STRB	r2,[r11,#0]				; Leave the configuration status
	LDMFD	r13!,{r2,r11,pc}^

ECPMode
; r0 is ECP mode to set, or -1 to read
; returns r0 as ECP mode
	STMFD	r13!,{lr}
	LDR	r11,ParallelAddress
	ADD	r11,r11,#&400<<2			; Get to the ECP registers
	CMP	r0,#0
	LDRMIB	r0,[r11,#2<<2]				; Get the ECR register
	MOVMI	r0,r0,LSR#5				; Remove all the associated crap
	LDRPLB	r12,[r11,#2<<2]				; Or get it here (ooh err!)
	BICPL	r12,r12,#&e0				; Clear the unwanted mode registers
	ORRPL	r12,r12,r0,LSL#5			; And set the correct mode
	STRPLB	r12,[r11,#2<<2]				; Or set the ECR register
	LDMFD	r13!,{pc}^
 ]

; ZipProtect is the code for *IZipProtect

ZipProtect
	LDR	r12,[r12]
	STMFD	r13!,{r0-r3,lr}
	TEQ	r1,#1
	BEQ	ProtectPassword
	BL	WP_forcegetprotection
	TEQ	r0,#3
	BEQ	NoProtect
	MOV	r0,#2
	MOV	r1,#0
	BL	WriteProtect
	BVS	NoProtect
	LDMFD	r13!,{r0-r3,lr}
	BICS	pc,lr,#1<<28

NoProtect
	LDMFD	r13!,{r0-r3,lr}
	ADR	r0,NoPEr
	ORRS	pc,lr,#1<<28

NoPEr	DCD	errorchunk+error_noprot
	=	"Unable to set the write protection state - was the password right?",0
	ALIGN

; ProtectPassword protects a disc with a password

ProtectPassword
	BL	WP_forcegetprotection
	TEQ	r0,#2
	BEQ	NoProtect
	MOV	r0,#3
	LDR	r1,[r13]
	BL	WriteProtect
	BVS	NoProtect
	LDMFD	r13!,{r0-r3,lr}
	BICS	pc,lr,#1<<28

; ZipUnprotect is the code for *IZipUnprotect.

ZipUnprotect
	LDR	r12,[r12]
	STMFD	r13!,{r0-r3,lr}
	TEQ	r1,#1
	BEQ	UnprotectPassword
	BL	WP_forcegetprotection
	TEQ	r0,#3
	BEQ	NoProtect
	MOV	r0,#0
	MOV	r1,#0
	BL	WriteProtect
	BVS	NoProtect
	LDMFD	r13!,{r0-r3,lr}
	BICS	pc,lr,#1<<28

; UnprotectPassword unprotects a disc with a password

UnprotectPassword
	BL	WP_forcegetprotection
	TEQ	r0,#2
	BEQ	NoProtect
	MOV	r0,#0
	LDR	r1,[r13]
	BL	WriteProtect
	BVS	NoProtect
	LDMFD	r13!,{r0-r3,lr}
	BICS	pc,lr,#1<<28

; FreeSpaceH is code that was pretty much copied from the Free module.
; However, for some reason, it doesn't work. It has been left here, so that
; when I can get it to work, it's still here.

FreeSpaceH
	STMFD	r12!,{r13}
	MOV	r13,r12
	ADR	r14,Freecnt
	STMFD	r13!,{r14}
	B	Free_DFS				; Do the freespace call
Freecnt	LDMFD	r13,{r13}
	LDMFD	r13!,{pc}

Free_DFS
	TEQ	r0,#1
	BEQ	Free_1104
	TEQ	r0,#2
	BEQ	Free_1144
	TEQ	r0,#3
	BEQ	Free_11f8
	LDMFD	r13!,{pc}

Free_1104
	STMFD	r13!,{r1-r3}
	MOV	r0,r3
	ADD	r1,r12,#4
	SWI	XZipFS_DescribeDisc
	LDMVSFD	r13!,{r1-r3,pc}
	ADD	r4,r1,#22
	MOV	r0,#0

L1104L	LDRB	r3,[r4,r0]
	CMP	r3,#32
	MOVLE	r3,#0
	STRB	r3,[r2,r0]
	ADD	r0,r0,#1
	TEQLE	r3,#0
	LDMLEFD	r13!,{r1-r3,pc}
	TEQ	r0,#10
	BNE	L1104L

	MOV	r3,#0
	STRB	r3,[r2,r0]
	ADD	r0,r0,#1
	LDMFD	r13!,{r1-r3,pc}

Free_1144
	STMFD	r13!,{r1-r3}
	MOV	r0,r3
	ADD	r1,r12,#4
	SWI	XZipFS_DescribeDisc
	LDMVSFD	r13!,{r1-r3,pc}
	LDR	r0,[r1,#16]
	STR	r0,[r2,#0]
	MOV	r0,r3
	SWI	XZipFS_FreeSpace
	STR	r0,[r2,#4]
	LDR	r1,[r2]
	SUB	r1,r1,r0
	STR	r1,[r2,#8]
	MOV	r0,#2
	LDMFD	r13!,{r1-r3,pc}

colon0	=	":0",0

Free_11f8
	STMFD	r13!,{r0-r4,r7}
	ADD	r1,r12,#80

	LDRB	r0,[r2,#0]
	TEQ	r0,#':'
	ADDEQ	r2,r2,#1

L11F8L0	LDRB	r0,[r2],#1
	TEQ	r0,#'.'
	MOVEQ	r0,#0
	STRB	r0,[r1],#1
	TEQ	r0,#0
	BNE	L11F8L0

	MOV	r7,r2
	ADR	r0,colon0
	ADD	r1,r12,#4
	SWI	XZipFS_DescribeDisc
	LDMVSFD	r13!,{r0-r4,r7,pc}
	ADD	r4,r1,#22

	ADD	r2,r12,#80
	LDR	r3,[r13,#12]					; Get the original pointer

	LDRB	r0,[r7],#1					; Skip past the ZipFS:: part

L11f8L	LDRB	r0,[r2],#1
	LDRB	r1,[r3],#1
	TEQ	r0,#0
	TEQEQ	r1,#0
	LDMEQFD	r13!,{r0-r4,r7,pc}

	TEQ	r0,r1
	LDMNEFD	r13!,{r0-r4,r7,pc}

	MOVS	r0,#0
	LDMFD	r13!,{r0-r4,r7,pc}

; ZipErase is the code for *IZipErase

ZipErase
	STMFD	r13!,{r0-r3,lr}
	LDR	r12,[r12]
	ADR	r0,EraseCmd
	MOV	r1,#6
	ADR	r2,SCSITemp
	MOV	r3,#255
	SWI	XPPADriver_SCSICommandRetries
	MOV	r0,#ppa_ukprotected
	STR	r0,WriteProtectM
	LDMFD	r13!,{r0-r3,pc}^

EraseCmd
	DCD	&20c004
	DCD	0

; ZipEject is the code for *IZipEject

ZipEject
	STMFD	r13!,{r0-r3,lr}
	ADR	r0,dismount_disc
	SWI	XOS_CLI
	STRVS	r0,[r13]
	LDMVSFD	r13!,{r0-r3,pc}
	BL	Eject
	STRVS	r0,[r13]
	LDMFD	r13!,{r0-r3,pc}

dismount_disc
	=	"-izipfs-Dismount "
disc	=	":0",0
	ALIGN

GetDiscFormat
	LDR	r0,DiscFormat
	MOVS	pc,lr

BootChangedCode
	CMP	r0,#-1
	LDREQ	r0,BootChanged
	STRNE	r0,BootChanged
	MOVS	pc,lr

; This code was added for the *IZipNoTimeout command. ms_command was copied
; from ZipFilCore.s

ZipNoTimeout
	STMFD	r13!,{r0-r3,r14}
	ADR	r0,ms_command
	MOV	r1,#6
	ADR	r2,ms_data
	MOV	r3,#18
	SWI	XPPADriver_SCSICommandRetries
	STRVS	r0,[r13]
	LDMFD	r13!,{r0-r3,pc}

ms_command
	DCD	&d015
	DCD	18

ms_data	DCD	&08000000
	DCD	0
	DCD	&00020000
	DCD	&005c042f
	DCD	0
	ALIGN

	END
