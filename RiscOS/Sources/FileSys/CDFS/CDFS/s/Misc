; -> Misc            *COMMANDS


; EACH NEW STAR COMMAND ADDED SHOULD USE STASHALL AND GRABALL IF TRAP ERRORS

; Preserve R7 - R11

; CONTAINS:
;          *Back
;          *Buf         only works if 'debug' = ON
;          *Bye
;          *CDDevices
;          *CDFS
;          *CDSpeed
;          *Con. CDROMDrives
;          *Con. CDROMBuffers
;          *Dismount
;          *Drive
;          *EJECT
;          *Lock
;          *Mount
;          *NoDir
;          *NoLib
;          *NoURD
;          *Play
;          *PlayList
;          *PlayMSF
;          *Stop
;          *Supported
;          *Unlock
;          *URD
;          *WhichDisc

 [ RISC_OS = 2
;*************************************************************************
Back                   ; *back
;*************************************************************************

 STASHALL

 ; 1. find start of CSD

 LDR R2, =:INDEX:CSD_path
 ADD R2, R2, R12


 ; 2. find start of old CSD

 LDR R3, =:INDEX:BackPath
 ADD R3, R3, R12


 ; 3. find end of old CSD

 LDR R4, =( MAXLENGTHOFNAME + 1 ) * MAXNUMBEROFPATHS + 2
 ADD R4, R3, R4


load_from_CSD

 ; 4. load from CSD

 LDRB R5, [ R2 ]


 ; 5. load from old CSD

 LDRB R6, [ R3 ]


 ; 6. store CSD at old CSD

 STRB R5, [ R3 ], #1


 ; 7. store old CSD at CSD

 STRB R6, [ R2 ], #1


 ; 8. reached end yet ? No - then goto 4

 CMP R3, R4
 BLE load_from_CSD

; 9. Swap drives


 LDRB R0, CurrentDriveNumber

 LDRB R1, olddrivenumber

 STRB R1, CurrentDriveNumber
 STRB R0, olddrivenumber

;----

 GRABALL

 BICS PC, R14, #Overflow_Flag

 ] ; RISC OS 2 only







 [ bufferlist=ON           ; Only works during debugging

Buf ; Display buffers
;*************************************************************************

 STASHALL

 BL DisplayBuffers

 GRABALL

 BICS PC, R14, #Overflow_Flag

;*************************************************************************

 ]

 LTORG

;*************************************************************************
Bye ROUT ; Closes all files, emptys all drives
;*************************************************************************

 STASHALL

Shutdown

;**********
; Close all files on filing system
;**********

 MOV R0, #0
 MOV R1, #0
 SWI XOS_Find


 GRABALL
 BICS PC, R14, #Overflow_Flag


;*************************************************************************
CDDevices  ROUT                     ; no parameters *CDDevices
;*************************************************************************
; on entry: R1 = number of parameters on line

; on exit : nothing


; layout of display:

;  drive  deviceid     LUN     cardnumber     productid     capacity     Firmware

;   1 + 4  1 + 4        1 + 4   1 + 4          8 + 4         10 + 4       4

; ( + 4 indicates number of spaces )

 STASHALL

 ; R0 -> tempbuffer is used to receive the details of the Inquiry command

 ; R4 = hardspace

 ; R6 -> Buffer is used to hold the characters to be displayed

 ; R7 -> spare control block

 ; R9 = Number of CDROMs found

 MOV R4, #HARDSPACE

 MOV R9, #0

 LDR R6, =:INDEX:buffer
 ADD R6, R12, R6

 [ RISC_OS=2
 addr R0, CDDevicesHeader
 SWI XOS_PrettyPrint
 |
             ADR       r0, message_block
             addr      r1, cddevicesheader_tag
             MOV       r2, r6
             MOV       r3, #128
             SWI       XMessageTrans_GSLookup
             BVS       Error
             MOV       r0, r2
             SWI       XOS_PrettyPrint
 ]


 MOV R11, R6

; ADD R7, R12, #sparecontrolblock_offset

and_why_not


;**************
; Check that device is recognised by CDFS
;**************

 MOV R0, R9
 BL PreConvertDriveNumberToDeviceID ; on VS R0 -> error block
 BVS DisplayDevice               ; No such device

;**************
; Inquiry device
;**************  

 ADD R0, R12, #:INDEX:tempbuffer
 SWI XCD_Inquiry          ; R0 -> where to put data,R7 -> control block
 BVS inquiryerror

;**************
; Drive number, device, card, lun
;**************

;************
; R1 = R9 MOD 10 R4 = R9 DIV 10
;************

 MOV R1, R9

; DivRem R3, R1, #10, R14
 DivideBy10 R1, R3, R14

 ADD R1, R1, #"0"
 STRB R1, [ R6 ], #1
 ADD R3, R3, #"0"
 STRB R3, [ R6 ], #1

 BL space


;************

 STRB R4, [ R6 ], #1

 LDMIA R7, { R1, R2, R10 }

 ADD R1, R1, #"0"         ; device id
 STRB R1, [ R6 ], #1      ;

 BL space                 ; R0 -> place to space, R4 = SPACE


;------------------------------------------------
; The LUN and card number are the wrong way round
;------------------------------------------------

 [ Version >= 218

; the new way

           ADD       r1, r10, #"0"         ; card number
           STRB      r1, [ r6 ], #1

           BL        space

           ADD       r1, r2, #"0"          ; LUN
           STRB      r1, [ r6 ], #1

           BL        space

 |

; the old way
 ADD R1, R2, #"0"         ; LUN
 STRB R1, [ R6 ], #1      ;

 BL space                 ; R0 -> place to space, R4 = SPACE

 ADD R1, R10, #"0"        ; card number
 STRB R1, [ R6 ], #1      ;

 BL space                 ; R0 -> place to space, R4 = SPACE

 ]

;------------------------------------------------

;**************
; Copy 'CDU-xxxx' to print buffer
;**************

 ADD R2, R0, #16           ; CD-ROM CDU 6XXX or LMS 212
 ADD R1, R2, #16

01

 LDRB R14, [ R2 ], #1

 TEQ R14, #SPACE         ; Convert spaces to hard spaces
 MOVEQ R14, #HARDSPACE   ;

 STRB R14, [ R6 ], #1

 TEQ R1, R2
 BNE %BT01

 BL space                ; R0 -> place to space, R4 = SPACE

;*******************
; Disc capacity
;*******************

 ADD R1, R12, #:INDEX:TempArea
 MOV R0, #0

 SWI XCD_DiscUsed

;****** If unknown then 'Unknown'

 ADRVS R2, Unknown          ; capacity is unknown

 ADDVS R1, R2, #?Unknown

02

 LDRVSB R14, [ R2 ], #1   ; Copy Unknown
 STRVSB R14, [ R6 ], #1   ;

 TEQVS R1, R2
 BNE %BT02

 STRVSB R4, [ R6 ], #1    ;
 STRVSB R4, [ R6 ], #1    ;
 MOVVS R1, R6             ;

;****** ELSE convert blocksize to Megabytes

 LDMVCIA R1, { R0, R2 }     ; R0 = number of blocks * size of a block
 MULVC R0, R2, R0           ;

 MOVVC R1, R6               ; R1 -> buffer to put
 MOVVC R2, #20              ; R2 = length of buffer

 SWIVC XOS_ConvertFixedFileSize

 MOV R6, R1                 ; R0 -> null terminating byte

 BL space                   ; R0 -> place to space, R4 = SPACE

 LDR R2, [ R12, #:INDEX:tempbuffer + 32 ];Firmware revision number, eg '2.01'

13
 STRB R2, [ R6 ], #1
 MOVS R2, R2, LSR #8
 BNE %BT13

 MOV R3, #13
 STRB R3, [ R6 ], #1

inquiryerror

 ADD R9, R9, #1
 LDRB R14, numberofdrives; any more drives to look for ?
 CMP R14, R9
 BGE and_why_not         ; [ yes ]

;*********************
; Display number of CDROMs found     R9 = number found
;*********************

DisplayDevice

 TEQ R9, #0

 MOVNE R0, R11
 MOVNE R4, #0
 STRNEB R4, [ R6 ]

 [ RISC_OS=2
 addr R0, NoDrivesFound, EQ
 |
             ADREQ     r0, message_block
             addr      r1, nodrivesfound_tag, EQ
             MOVEQ     r2, r6
             MOVEQ     r3, #128
             SWIEQ     XMessageTrans_Lookup
             MOVEQ     r0, r2
 ]

 SWI XOS_PrettyPrint

 SWIEQ XOS_NewLine

;*********************

 GRABALL

 BICS PC, R14, #Overflow_Flag

Unknown =  " Unknown "

 ALIGN

space
 STRB R4, [ R6 ], #1
 STRB R4, [ R6 ], #1
 STRB R4, [ R6 ], #1
 STRB R4, [ R6 ], #1
 MOVS PC, R14

;----------------------------------------------------------------------------------------------
; *CDSpeed
; If '*CDSpeed' without any parameters, then current speed for current drive returned
; if '*CDSpeed <d>' then current speed for drive 'd' returned
; if '*CDSpeed <d> <s>' then set the speed for drive 'd' to 's'.  If 's' == 255 then set to
;     maximum.  1 is standard, 2 is double.
CDSpeed ROUT
;----------------------------------------------------------------------------------------------
; on entry:
;          r0 -> parameter line
;          r1 =  number of parameters on line

 STASHALL

 MOV         r4, r1

;----------------
; Current drive ?
;----------------
 CMP         r1, #1

 BLGE        atoi
 MOVGT       r3, r0
 MOVGE       r0, r2
 LDRLTB      r0, CurrentDriveNumber

;----------------
; Device number ?
;----------------
 BL          PreConvertDriveNumberToDeviceID        ; R0 = drive number, returns R7 -> block
 BVS         Error

;---------------------
; Get current settings
;---------------------
 ADR         r0, TempArea
 SWI         XCD_GetParameters ; r0->storage area, r7->block
 BVS         Error

;--------------------------
; Display current setting ?
;--------------------------
 CMP         r4, #2
 BGE         %FT01

 MOV         r1, r0
 LDRB        r0, [ r1, #12 ]
 MOV         r2, #4
 SWI         XOS_BinaryToDecimal
 MOV         r0, r1

 [ RISC_OS=2
 SWI         XOS_WriteS
 = "Current speed setting is ",0
 ALIGN
 |
             STASH     r0-r3
             ADR       r0, message_block
             addr      r1, currentspeed_tag
             ADR       r2, TempArea + 100
             MOV       r3, #128
             SWI       XMessageTrans_Lookup
             BVS       Error
             MOV       r0, r2
             SWI       XOS_Write0
             GRAB      r0-r3
 ]


 MOV         r1, r2
 SWI         XOS_WriteN
 SWI         XOS_NewLine
 B           common_end

;--------------
; Set speed
;--------------
01

;------------------------------
; Decode the string to a number
;------------------------------
 MOV         r4, r0
 MOV         r0, r3
 BL          atoi
 STRB        r2, [ r4, #12 ]

;----------------
; Change CD speed
;----------------
 MOV         r0, r4
 SWI         XCD_SetParameters

 B           common_end
 

;*************************************************************************
; This is the *CONFIGURE CDROMBuffers
;*************************************************************************

; on entry:
;          R0 = 0   THEN *CONFIGURE with no option
;          R0 = 1   THEN *STATUS
;          R0 <> 0 AND R0 <> 1 THEN *CONFIGURE R0 -> string

; This works out if a *configure or *status has been performed

Buffers

 LDR R12, [ R12 ]

 STASHALL
                                  ; Just print the configure description
 CMP R0, #1                       ; message

 BGT SetNumberOfBuffers           ;  *CONFIGURE number


 ADRLT R0, ConfigureMessageForBuffers;
                                  ;
 BLT configuredrivesdoesthis


;**************
;StatusMessage                     ;  *STATUS
;**************

; This gets the value stored in CMOS ram
; then prints it in *status format


 ADR R0, ConfigureMessageForBuffers ; Display 'CDROMBuffers '
 MOV R1, #13                        ;
 SWI XOS_WriteN                     ;

 SWI XCDFS_GetBufferSize        ; RETURNS R0 = 0 to 7

 BL ConvertBufferSizeToReal     ; R0 = bit values, RETURNS R1 = buffer actual

 MOV R0, R1

 ADD R1, R12, #:INDEX:TempArea

 MOV R2, #20

 SWI XOS_ConvertCardinal2      ; see page 602  ( integers from 0 to 65535 )

 SWI XOS_PrettyPrint

 SWI XOS_WriteI + "K"

 SWI XOS_NewLine

 GRABALL

 BICS PC, R14, #Overflow_Flag

;**************
SetNumberOfBuffers
;**************

; This gets the value currently stored in CMOS ram
; then combines it with the desired setting, so that the other bits
; in the byte are preserved

 MOV R1, R0                  ; R1 -> string

 MOV R0, #10                 ; base 10

 ; restrict number to be in range 0 - maxnumberofdrivessupported

 ORR R0, R0, #bit_29

 MOV R2, #MAXBUFFERSIZE

 SWI XOS_ReadUnsigned

 GRABALL VS                     ; Indicate 'Parameter too big'
 MOVVS R0, #2                   ;
 ORRVSS PC, R14, #Overflow_Flag ;



 MOV R0, R2

 BL ConvertRealBufferToSize     ; R0 = number of K, RETURNS R1 = bit setting

 MOV R0, R1

 SWI XCDFS_SetBufferSize

; BVS Error                   ; Indicate the unknown error to FS

; GRABALL

; BICS PC, R14, #Overflow_Flag

 B common_end

ConfigureMessage = "CDROMDrives", SPACE, "<D>", 0
ConfigureMessageForBuffers = "CDROMBuffers", SPACE, "<D>[K]", 0

 ALIGN

;*************************************************************************
; This is the *CONFIGURE CDROMDrives
;*************************************************************************

; on entry:
;          R0 = 0   THEN *CONFIGURE with no option
;          R0 = 1   THEN *STATUS
;          R0 <> 0 AND R0 <> 1 THEN *CONFIGURE R0 -> string

; This works out if a *configure or *status has been performed

NumberOfDrives

 LDR R12, [ R12 ]

 STASHALL
                                  ; Just print the configure description
 CMP R0, #1                       ; message

 BGT SetNumberOfDrives            ;  *CONFIGURE number


 ADRLT R0, ConfigureMessage       ;

configuredrivesdoesthis

 SWILT XOS_PrettyPrint            ;
                                  ;
 SWILT XOS_NewLine                ;
                                  ;
 GRABALL LT                       ;
 BICLTS PC, R14, #Overflow_Flag   ;



;**************
;StatusMessage                     ;  *STATUS
;**************

; This gets the value stored in CMOS ram
; then prints it in *status format


 ADR R0, ConfigureMessage      ; Display 'CDFSNumberOfDrives '
 MOV R1, #12
 SWI XOS_WriteN                ;

 SWI XCDFS_GetNumberOfDrives    ; RETURNS R0 = number of drives conf.

 BVS Error

 ADD R1, R12, #:INDEX:TempArea

 MOV R2, #20

 SWI XOS_ConvertCardinal1      ; see page 602

 SWI XOS_PrettyPrint

 SWI XOS_NewLine

 GRABALL

 BICS PC, R14, #Overflow_Flag

;**************
SetNumberOfDrives
;**************

; This gets the value currently stored in CMOS ram
; then combines it with the desired setting, so that the other bits
; in the byte are preserved


;                   Make the string into a real number

 MOV R1, R0                    ; R1 -> string

 MOV R0, #10                   ; base 10

 ; restrict number to be in range 0 - maxnumberofdrivessupported

 ORR R0, R0, #bit_29

 MOV R2, #MAXNUMBEROFDRIVESSUPPORTED

 SWI XOS_ReadUnsigned

 GRABALL VS                     ; Indicate 'Parameter too big'
 MOVVS R0, #2                   ;
 ORRVSS PC, R14, #Overflow_Flag ;


; This gets the value currently stored in CMOS ram

 MOV R0, R2

 SWI XCDFS_SetNumberOfDrives

 STRVS R0, verytemporary        ; Indicate the unknown error to FS
 GRABALL VS                     ;
 LDRVS R0, verytemporary        ;
 ORRVSS PC, R14, #Overflow_Flag ;

 GRABALL

 BICS PC, R14, #Overflow_Flag

;*************************************************************************
Dismount ROUT  ; *Dismount drive number or disc name
;*************************************************************************

; R0 -> parameters passed in
; R1 = number of parameters

 STASHALL

 Debug " *Dismount "
 Debug0

;******************
; Were any parameters following *Dismount ?
;******************

 TEQ R1, #0                          ;
 LDREQB R0, CurrentDriveNumber       ; [ no - so dismount current drive ]
 BEQ %FT04                           ;

;******************
; If a ':' was the first char of the parameter THEN ignore it
;******************

 Debug " Check : "

 STASH R0

 LDRB R1, [ R0 ]
 TEQ R1, #":"
 ADDEQ R0, R0, #1

;******************
; Validate the parameter for valid characters
;******************

 BL CheckDiscName              ; R0 -> string

 GRAB R0

;******************
; Copy parameter into 'TempArea' prefixed with ':' if necessary
;******************

; Make sure that the name or number is prefixed with ":"

 MOV R1, #":"
 ADD R2, R12, #:INDEX:TempArea
 MOV R3, R2

 STRB R1, [ R2 ], #1

 LDRB R1, [ R0 ], #1
 TEQ R1, #":"
 STRNEB R1, [ R2 ], #1


03

 LDRB R1, [ R0 ], #1
 STRB R1, [ R2 ], #1
 TEQ R1, #0

 BNE %BT03

;******************
; Prompt for disc to be inserted ( as it isn't buffered )
;******************

 ADD R0, R3, #1
 BL FindDiscNameInList
 CMP R1, #-1
 SUBEQ R0,R0,#1
; MOV R0, R3
 BLEQ FindDriveNumber             ; R0 -> name or number, RETURNS R1 = drive

;******************
; Now I know the drive number !
;******************

 MOV R0, R1

04

;******************
; R0 = drive number
; IF R0 = current drive number THEN CSD path = '$', 0
;******************

 [ RISC_OS=2

 LDRB R2, CurrentDriveNumber
 TEQ R0, R2
 LDREQ R4, =:INDEX:CSD_path
 MOVEQ R2, #"$"
 STREQ R2, [ R4, R12 ]

 ]

;******************
; Wipe the disc name from the list of discs mounted
;******************

; Version 2.12 needs this back in
; [ RISC_OS =2

 [ debug=ON
 SWI &100+4
 SWI &100+12
 Debug " Wipe name, drive = "
 MOV    R4, R0
 DebugDisplay R4
 ]

 LDR    R2, =:INDEX:DiscNameList
 [      LENGTHOFDISCNAME<>32
 MOV    R3, #LENGTHOFDISCNAME
 MLA    R4, R3, R0, R2
 |
 ADD    R4, R2, R0, LSL #5
 ]
 MOV    R3, #0
 STRB   R3, [ R4, R12 ]!
; STRB   R3, [ R4, #1 ]

 LDR    R14, =:INDEX:discsMounted
 ADD    R14, R14, R12
 STR    R3, [ R14, R0, LSL #2 ]
; ]

;******************
; Remove the disc number from the list of discs mounted
;******************

; Version 2.12 needs this back in
; [ RISC_OS=2
 LDR R14, =:INDEX:ListOfDiscsInDrives
 ADD R14, R14, R12

 LDR    R0, [ R14, R0, LSL #2 ]!
 STR    R3, [ R14 ]
; ]

; ADD R7, R12, #:INDEX:sparecontrolblock
 BL PreConvertDriveNumberToDeviceID
 SWI XCD_DiscHasChanged
 BVS Error

;******************
; Close all the files on the disc
; R0 = unique number
;******************

;**********
; Make sure that all files related to this disc are closed
;**********

; R0 = disc
; R1 = block
; R2 -> buffer list

 LDR R2, pointerToBufferList

;**********
; Close all directory buffers on the disc
;**********

01

 LDMIA R2!, { R1, R4, R5, R6 }    ; R1 = disc, R4 = buffer, R5 = block
                                  ; r6=offset
 TEQ R4, #0                       ; Last entry in list ?
 BEQ %FT02                        ; [ yes ]


 TEQ R1, R0
 BNE %BT01

 MOV R1, R5
 BL DeleteBuffer                   ; R0 = unique number, R1 = block number
; SUB R2, R2, #SIZEOFBUFFERENTRY    ; Move back ( list is shuffled )
 LDR R2, pointerToBufferList       ; start from begining again

 B %BT01

02

;**********
; Close all files on the disc
;**********

; R0 = disc number to look for
; R1 -> current pointer in list
; R2 = number searched so far ( 255 to 0 ) BACKWARDS !
; R3 = disc number of little buffer
; R4 -> little buffer


 LDR R1, =:INDEX:OpenFileList        ; This list contains pointers to small
 ADD R1, R1, R12                     ; buffers for each open file or 0

 MOV R2, #MAXNUMBEROFOPENFILES - 3   ; From 253 to 0

05

 LDR R4, [ R1 ], #4

 SUBS R2, R2, #1                     ; Reached end ?
 GRABALL EQ                          ;
 BICEQS PC, R14, #Overflow_Flag      ; [ yes ]

 TEQ R4, #0                          ; Number not used ?
 BEQ %BT05                           ; [ not used ]

 LDR R3, [ R4, #DISCNUMBEROPEN ]     ; Does this buffer come from this disc ?
                                     ;
 TEQ R3, R0                          ;

 BNE %BT05
                                     ;
 STASH R0-R1                         ; [ yes ] - so close that file

 MOV R0, #0
 LDR R1, [ R4, #FILESWITCHHANDLE ]
 SWI XOS_Find
                                     ;
 GRAB R0-R1

 B %BT05


; This now uses *Mount
 [ Version < 220
;*************************************************************************
; This is the *Drive command
Drive ROUT
;*************************************************************************

; entry
; R0 -> parameters following '*Drive'
; R1 = number of parameters on line


 STASHALL

 MOV R1, R0                      ; R1 -> value to convert

 MOV R0, #10                     ; base 10, use maximum value in R2
 ORR R0, R0, #bit_29             ;

 MOV R2, #MAXNUMBEROFDRIVESSUPPORTED  ; maximum number = 27

 SWI XOS_ReadUnsigned            ; RETURNS R2 = drive number

 [ RISC_OS=2
 ADRVSL R0, BadDrive
 BVS Error
 |
           MOVVS       r0, #ERROR_BADDRIVE
           BVS         Error
 ]

; MOV R3, #LENGTHOFDISCNAME       ; If drive has not been mounted then cannot
; LDR R0, =DiscNameList_offset    ; change to it
; MLA R0, R3, R2, R0              ;
; ADD R0, R0, R12                 ;
; LDRB R1, [ R0 ]                 ;
; TEQ R1, #0                      ;
; GRABALL EQ                      ;
; BICEQS PC, R14, #Overflow_Flag  ;


 STRB R2, CurrentDriveNumber

 ADR R0, root_dir

 [ Version >= 220
       MOV        r6, #0
 ]

 B SetDir_fixed_for_drive

; GRABALL

; BICS PC, R14, #Overflow_Flag

root_dir = "$", 0
 ALIGN

 ]

;*************************************************************************
; This is the *EJECT command
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified

Eject

 STASHALL

 TEQ R1, #1

 ;*****************
 ; Deal with parameter
 ;*****************

 BLEQ atoi
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2

 BL PreConvertDriveNumberToDeviceID        ; R0 = drive number, R7 -> block

 SWIVC XCD_OpenDrawer

; BVS Error

; GRABALL

; BICS PC, R14, #Overflow_Flag
 B common_end

;*************************************************************************
; This is the *LOCK command
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified

Lock

 STASHALL

 TEQ R1, #1

 ;*****************
 ; Deal with parameter
 ;*****************

 BLEQ atoi
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2

 BL PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block

 MOVVC R0, #1

 SWIVC XCD_EjectButton

; BVS Error

; GRABALL

; BICS PC, R14, #Overflow_Flag
 B common_end


; *Drive is now implemented as *Mount
 [ Version >= 220
Drive ROUT
 ]
;*************************************************************************
Mount ROUT     ; *Mount drive number or disc name
;*************************************************************************

; R0 -> parameters passed in ( terminated by a char < 32 )
; R1 = number of parameters

 STASHALL

; IF NOTHING SUPPLIED THEN COPY IN THE CSD DISC NAME/ DRIVE NUMBER

 TEQ R1, #0
 ADREQ R0, BlankPath     ; R0 -> '$'
 [ Version >= 220
       MOVEQ      r6, #0
 ]
 BEQ SetDir_fixed_for_mount

 ;*****************
 ; Deal with parameter
 ;*****************

 ; Make sure that the name or number is prefixed with ":"

 ADD R2, R12, #:INDEX:tempbuffer
 MOV R3, R2

 LDRB R1, [ R0 ]
 TEQ R1, #":"
 MOVNE R1, #":"
 ADDEQ R0, R0, #1
 STRB R1, [ R2 ], #1

01

 LDRB R1, [ R0 ], #1
 CMP R1, #32
 STRGTB R1, [ R2 ], #1
 BGT %BT01

 MOV R1, #"."
 STRB R1, [ R2 ], #1
 MOV R1, #"$"
 STRB R1, [ R2 ], #1
 MOV R1, #0
 STRB R1, [ R2 ], #1

 MOV R0, R3

 [ Version >= 220
       MOV        r6, #0
 ]

 B SetDir_fixed_for_mount          ; R0 -> path

BlankPath = "$", 0

 ALIGN



 [ RISC_OS=2
;*************************************************************************
NoDir ROUT      ; Unset the CSD directory
;*************************************************************************

; R0 -> parameters follwing '*nodir'
; R1 = number of parameters


 LDR R1, =:INDEX:CSD_path
 MOV R0, #"$"
 STR R0, [ R1, R12 ]
 

 BICS PC, R14, #Overflow_Flag

 ]
   



 [ RISC_OS=2

;*************************************************************************
NoLib       ; Unsets the current library directory
;*************************************************************************

; R0 -> parameters follwing '*nodir'
; R1 = number of parameters

; STASHALL

 
;****************
; Blank the first byte of the path for the current library directory to 
; indicate that it is unset
;****************

 LDRB R2, CurrentDriveNumber   ; R3 -> lib and urd buffer + drive * length
 LDR R3, pointertolibandurd    ;
 MOV R4, #LIBLENGTH            ;
 MLA R3, R2, R4, R3            ;

 MOV R2, #0                    ; Unset library
 STRB R2, [ R3 ]               ;

; GRABALL

 BICS PC, R14, #Overflow_Flag

 ]



 [ RISC_OS=2
;*************************************************************************
NoUrd       ; Unset the URD directory
;*************************************************************************

; R0 -> parameters follwing '*nodir'
; R1 = number of parameters

; STASHALL

;****************
; Blank the first byte of the path for the current library directory to 
; indicate that it is unset
;****************

 LDRB R2, numberofdrives       ; R3 -> start of urd buffer
 LDR R3, pointertolibandurd    ;
 MOV R4, #LIBLENGTH            ;
 MLA R3, R2, R4, R3            ;

 [ URDLENGTH <> LIBLENGTH
 MOV R4, #URDLENGTH            ;
 ]
 LDRB R2, CurrentDriveNumber   ; R3 -> correct urd buffer
 MLA R3, R2, R4, R3            ;

 MOV R2, #0                    ; Unset library
 STRB R2, [ R3 ]               ;


; GRABALL

 BICS PC, R14, #Overflow_Flag

 ]




;*************************************************************************
; This is the *PLAY command
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=1 then use current drive,
;          r1=2 then use drive specified

Play

 STASHALL

 TEQ R1, #2

 ;*****************
 ; Deal with parameter
 ;*****************

 BL atoi ; r0->first parameter, RETURNS r0->next param (if any),
         ; RETURNS r2=value, does not return if error (not integer)

 STASH R2

 ;****************
 ; Make sure that that track exists
 ;****************

 ;*****************
 ; Find number of tracks on disc
 ;*****************

 BLEQ atoi
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2

 ADD R1, R12, #:INDEX:TempArea

 BL PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block

; SWI XCD_StopDisc   ; Hitachi doesn't like enquiring while playing audio

 MOVVC R0, #0

 SWIVC XCD_EnquireTrack

 BVS Error

 GRAB R2

 LDRB R6, [ R1, #0 ]  ; start track

 LDRB R14, [ R1, #1 ]  ; end track

 CMP R2, R14                           ; number too big ?

 [ RISC_OS=2
 addr R0, TrackTooBig, GT
 BGT Error
 |
         MOVGT     r0, #ERROR_TOOBIG
         BGT       Error
 ]

 CMP R2, R6                            ; number too small ?

 [ RISC_OS=2
 addr R0, TrackTooSmall, LT
 BLT Error
 |
         MOVLT     r0, #ERROR_TOOSMALL
         BLT       Error
 ]



 ;****************
 ; Play track
 ;****************


 MOV R1, #&FF                          ; R1 = play to end of disc
                                       ; ( or to start of a data track )

 MOV R0, R2                            ; R2 contains the integer result

 SWI XCD_PlayTrack

; BVS Error

; GRABALL

; BICS PC, R14, #Overflow_Flag

 B common_end

;---------------------------------------------------------------------------
atoi        ; convert ascii to integer
;---------------------------------------------------------------------------

; on entry:
;          r0->ascii value
; on exit:
;          r0->next parameter or end_of_string+1
;          r1 corrupted
;          r2=integer
;          V cleared, if error then won't return

; STASH R14
; convert parameter to integer
; SWI XOS_EvaluateExpression
;; addr R0, InvalidParameter, VS ; result is not an integer (or something)
; BVS Error
; Move to next param
;01
; LDRB R1, [ R0 ], #1
; CMP R1, #32
; BGT %BT01
; GRAB R14
; MOVS PC, R14

 STASH "R14"

 MOV R1, R0
 MOV R0, #10
 ORR R0, R0, #(1:SHL:31)  ; make sure terminator is control char or space
 SWI XOS_ReadUnsigned
 BVS Error

 MOV R0, R1

 GRAB PC

;*************************************************************************
; This is the *PlayList command
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified


; R6 = current track
; R7 -> spare control block
; R9 -> current position in buffer
; R10 = start track
; R11 = end track

; temp3 = current track

PlayList

 STASHALL

 TEQ R1, #1

 ;*****************
 ; Deal with parameter(s)
 ;*****************

 BLEQ atoi
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2

 BL PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block


 LDR R1, =:INDEX:buffer
 ADD R1, R12, R1             ; storagea area = buffer

 MOVVC R0, #0

 SWIVC XCD_EnquireTrack

 BVS Error

 LDRB R10, [ R1 ]        ; start track
 LDRB R11, [ R1, #1 ]    ; end track
 MOV R6, R10             ; current track

 MOV R9, R1
             
 [ RISC_OS=2
 SWI XOS_WriteS
 = "Track number, contains, starts from MM:SS:FF", 0
 ALIGN
 |
             ADR       r0, message_block
             addr      r1, playlist_tag
             MOV       r2, r9
             MOV       r3, #128
             SWI       XMessageTrans_Lookup
             BVS       Error
             MOV       r0, r2
             SWI       XOS_Write0
 ]

 SWI XOS_NewLine

PlayListLoop            ; loop

 MOV R0, R6
 ADD R1, R12, #:INDEX:TempArea
 SWI XCD_EnquireTrack
 BVS Error

;****************
; DISPLAY TRACK
;****************

 [ RISC_OS=2
 ADR R3, Track
 LDMIA R3, { R3, R4 }           ; "Track", HARDSPACE
 STMIA R9!, { R3, R4 }          ;
 |
             ADR       r0, message_block
             addr      r1, track_tag
             MOV       r2, r9
             MOV       r3, #128
             SWI       XMessageTrans_GSLookup
             BVS       Error
             ADD       r9, r2, r3
 ]

 MOV R0, R6
 MOV R1, R9
 MOV R2, #255

 CMP R0, #10
 MOVLT R14, #"0"
 STRLTB R14, [ R1 ], #1

 SWI XOS_ConvertCardinal1      ; R0 = value, R1->buffer, R2=buffersize
                               ; RETURNS R0->buffer,R1->end,R2=bytes left

 MOV R9, R1
 MOV R14, #HARDSPACE
12
 TST R9, #3
 STRNEB R14, [ R9 ], #1
 BNE %BT12

 LDRB R14, TempArea + 4        ; If control bits AND 1 = 0 THEN audio
 TST R14, #1                   ; ELSE data

 [ RISC_OS=2
 ADREQ R3, audio
 ADRNE R3, data
 LDMIA R3, { R3, R4 }
 LDR R1, is                   ; " is "
 STMIA R9!, { R1, R3, R4 }
 |
             ADR       r0, message_block
             addr      r1, audio_tag, EQ
             addr      r1, data_tag, NE
             MOV       r2, r9
             MOV       r3, #128
             SWI       XMessageTrans_GSLookup
             BVS       Error
             ADD       r9, r2, r3
 ]

;****************
; MM:SS:FF
;****************

; R5 = LBA of start of track

 LDR R5, TempArea
 ADD R5, R5, #150

; R6 = frames
; R3 = seconds
; R0 = minutes
                                               ; R3 = address DIV 75
                                               ;
 DivRem R3, R5, #MaxNumberOfBlocks + 1, R14    ; R6 = address MOD 75

 DivRem R0, R3, #MaxNumberOfSeconds + 1, R14   ; R0 = ( address / 75 ) / 60
                                               ;
                                               ; R3 = ( address/75 ) MOD 60

 MOV R8, #":"
 MOV R4, #"0"

 MOV R1, R9
; MOV R2, #255
 CMP R0, #10
 STRLTB R4, [ R1 ], #1
 SWI XOS_ConvertCardinal1      ; R0 = value, R1->buffer, R2=buffersize
                              ; RETURNS R0->buffer,R1->end,R2=bytes left

 STRB R8, [ R1 ], #1

 MOV R0, R3
 CMP R0, #10
 STRLTB R4, [ R1 ], #1
 SWI XOS_ConvertCardinal1      ; R0 = value, R1->buffer, R2=buffersize

 STRB R8, [ R1 ], #1

 MOV R0, R5
 CMP R0, #10
 STRLTB R4, [ R1 ], #1
 SWI XOS_ConvertCardinal1      ; R0 = value, R1->buffer, R2=buffersize

 MOV R9, R1

 MOV R0, #HARDSPACE
13
 ADD R14, R9, #1              ; Word align for "Track"
 TST R14, #3
 STRNEB R0, [ R9 ], #1
 BNE %BT13

;****************
; LINE FEED
;****************

 MOV R0, #NEWLINE
 STRB R0, [ R9 ], #1

;****************
; NEXT loop
;****************

 ADD R6, R6, #1               ;  Increment current_track%

 CMP R6, #99                  ;  Make sure that can't infinite loop
 CMPLE R6, R11

 BLE PlayListLoop

;****************
; empty buffer
;****************

 MOV R0, #0                   ; terminator
 STRB R0, [ R9 ]

 LDR R0, =:INDEX:buffer
 ADD R0, R0, R12

 MOV R9, R0

 SWI XOS_PrettyPrint

;***************
; Print "Total of "      ; finish_track% - start_track% + 1; " tracks "
;***************

 [ RISC_OS=2
 SWI XOS_WriteS
 = "Total   ", 0
 ALIGN
 |
             ADR       r0, message_block
             addr      r1, total_tag
             ADR       r2, TempArea
             MOV       r3, #128
             SWI       XMessageTrans_GSLookup
             MOVVC     r0, r2
             ADDVS     r0, r0, #4
             SWI       XOS_Write0
 ]

 SUB R0, R11, R10
 ADD R0, R0, #1
 ADD R1, R12, #:INDEX:TempArea
 CMP R0, #10

 MOV R2, #3

 SWI XOS_ConvertCardinal1

 SWILT &100+"0"
 SWI XOS_Write0

 [ RISC_OS=2
 SWI XOS_WriteS
 = " track(s)     ", 0
 ALIGN
 |
             ADR       r0, message_block
             addr      r1, tracks2_tag
             ADR       r2, TempArea
             MOV       r3, #128
             SWI       XMessageTrans_GSLookup
             MOVVC     r0, r2
             ADDVS     r0, r0, #4
             SWI       XOS_PrettyPrint
 ]


 MOV R0, #1                        ; Get MSF length of disc
 ADD R1, R12, #:INDEX:TempArea     ;
 SWI XCD_DiscUsed                  ;
 BVS Error

 LDR R6, [ R1 ]               ; R0 = end of disc

; LDR R1, =buffer_offset       ; R1 -> buffer for printing
; ADD R1, R1, R12              ;
 MOV R1, R9
 MOV R2, #255
 MOV R7, #":"
 MOV R8, #"0"

;**********************

; MINUTES

 MOV R0, R6, ASR #16          ; MINUTES
 AND R0, R0, #&FF             ;

 CMP R0, #10
 STRLTB R8, [ R1 ], #1        ; '0'

 SWI XOS_ConvertCardinal1     ; R0 = value,R1->buffer,R2=sizeofbuffer
                              ; RETURNS R0 -> buffer,R1->end,R2=bytes left
 STRB R7, [ R1 ], #1          ; ':'

; SECONDS

 MOV R0, R6, ASR #8           ; SECONDS
 AND R0, R0, #&FF             ;

 CMP R0, #10
 STRLTB R8, [ R1 ], #1        ; '0'

 SWI XOS_ConvertCardinal1     ; R0 = value,R1->buffer,R2=sizeofbuffer
                              ; RETURNS R0 -> buffer,R1->end,R2=bytes left
 STRB R7, [ R1 ], #1          ; ':'

; FRAMES

 AND R0, R6, #&FF             ;

 CMP R0, #10
 STRLTB R8, [ R1 ], #1        ; '0'

 SWI XOS_ConvertCardinal1     ; R0 = value,R1->buffer,R2=sizeofbuffer
                              ; RETURNS R0 -> buffer,R1->end,R2=bytes left


; LDR R0, =buffer_offset       ; R0 -> buffer for printing
; ADD R0, R0, R12              ;
 MOV R0, R9
 SWI XOS_Write0

 SWI XOS_NewLine

 GRABALL

 BICS PC, R14, #Overflow_Flag

 [ RISC_OS=2
Track = "Track", HARDSPACE, HARDSPACE, HARDSPACE
is = HARDSPACE,"is",HARDSPACE
audio = "audio",HARDSPACE, HARDSPACE, HARDSPACE
data = "data",HARDSPACE, HARDSPACE, HARDSPACE, HARDSPACE
 ]

;*************************************************************************
PlayMSF ROUT ; Plays from time 1 to time 2
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=2 then use current drive,
;          r1=3 then use drive specified

 STASHALL

;******************
; Check parameters for correctness - should be 'MM:SS:FF'
;******************

 MOV R2, R0

 MOV R5, #2

01

 BL %FT10               ; check for '0' to '9', R4 corrupted

 BL %FT10               ; check for '0' to '9', R4 corrupted

 LDRB R3, [ R2 ], #1                  ;
 TEQ R3, #":"                         ;
 BNE %FT01                            ;

 SUBS R5, R5, #1
 BNE %BT01

 BL %FT10               ; check for '0' to '9', R4 corrupted

 BL %FT10               ; check for '0' to '9', R4 corrupted

 SUB R14, R2, R0                 ; Check the second parameter ?
 CMP R14, #8                     ;
 BLT %BT01                       ; [ yes ]

;******************
; Convert the parameters to numbers and store them in registers
; These are then sent to CD_PlayAudio SWI in MSF form ( mode 1 )
;******************

; R8 = first parameter
; R9 = second parameter

;**************
; Set R8 to imposs. value for first parameter
; This means that a general proc. can be made for converting text to
; digit
;**************

 MOV R8, #-1

;**************
; R2 -> start of parameters following '*PlayMSF'
; This works out from the characters given, to an MSF value
;**************

 MOV R2, R0

;**************

03

 BL %FT20

 ADD R9, R3, R4, ASL #1

 BL %FT20

 ADD R3, R3, R4, ASL #1
 ORR R9, R3, R9, ASL #8

 BL %FT20

 ADD R3, R3, R4, ASL #1
 ORR R9, R3, R9, ASL #8

;*************
; Do the second parameter ?
;*************

 CMP R8, #-1                    ; If R8 = -1 Then do the second parameter
 MOVEQ R8, R9                   ;
 BEQ %BT03                      ;

;*************

; ADD R8, R8, #2:SHL:8           ; The first 2 seconds of a disc are not
; ADD R9, R9, #2:SHL:8           ; accessible


;******************
; Send parameters to current drive number [drive] specified ?
;******************

 TEQ R1, #3
 MOVEQ R0, R2
 BLEQ atoi
 MOVEQ R0, R2
 LDRNEB R0, CurrentDriveNumber

 BL PreConvertDriveNumberToDeviceID

 MOVVC R0, #1
 MOVVC R1, R8
 MOVVC R2, R9

 SWIVC XCD_PlayAudio

 BVS Error

;******************

 B %FT02

;******************
; Resolve digits from characters
;******************

20

 LDRB R4, [ R2 ], #1            ;
 LDRB R3, [ R2 ], #2            ; Move past ':'
 SUB R4, R4, #"0"               ; R4 = M
 SUB R3, R3, #"0"               ; R3 = M

 ADD R4, R4, R4, ASL #2      ; R9 = First digit * 10

 MOV PC, R14

;******************
; Check for a digit
;******************

10

 LDRB R3, [ R2 ], #1
 CMP R3, #"0"
 RSBHSS R4, R3, #"9"+1
 MOVHI PC, R14              ; ALLOW TO RUN ON


 

;******************
01     ; Incorrect syntax on parameter line
;******************

 [ RISC_OS=2
 addr R0, PlayMSFSyntax
 SWI XOS_Write0
 SWI XOS_NewLine
 |
             ADR       r0, message_block
             addr      r1, playmsf_tag
             ADR       r2, TempArea
             MOV       r3, #128
             SWI       XMessageTrans_GSLookup
             BVS       Error
             MOV       r0, r2
             SWI       XOS_PrettyPrint
             SWI       XOS_NewLine
 ]
02
 GRABALL
 BICS PC, R14, #Overflow_Flag


;*************************************************************************
; This is the *STOP command
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified


Stop

 STASHALL


 TEQ R1, #1

 ;*****************
 ; Deal with parameter
 ;*****************

 BLEQ atoi
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2

 BL PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block

 SWIVC XCD_StopDisc

; BVS Error

; GRABALL

; BICS PC, R14, #Overflow_Flag
 B common_end

;*************************************************************************
; This is the *Supported command - lists drives recognized by CDFS
;*************************************************************************

Supported

 STASH  R14

 [ RISC_OS =2
 ADR    R0, drivessupported
 |
 ADR    r0, message_block
 ADR    r1, drivessupported
 ADR    r2, tempbuffer
 MOV    r3, #256
 SWI    XMessageTrans_Lookup
 GRAB   PC,VS
 MOV    r0, r2
 ]
 SWI    XOS_PrettyPrint         ; SMC: Why??
 SWI    XOS_NewLine

 GRAB   R14
 BICS   PC, R14, #Overflow_Flag

 [ RISC_OS = 2
drivessupported = "SONY, LMS, TOSHIBA, HITACHI, CHINON", 0
 |
drivessupported = "dr",0
 ]

 ALIGN

;*************************************************************************
; This is the *UNLOCK command
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified

Unlock

 STASHALL

 TEQ R1, #1

 ;*****************
 ; Deal with parameter
 ;*****************

 BLEQ atoi
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2

 BL PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> control block

 MOVVC R0, #0

 SWIVC XCD_EjectButton

common_end

 BVS Error

 GRABALL

 BICS PC, R14, #Overflow_Flag




 [ RISC_OS=2
;*************************************************************************
Urd ROUT        ; Sets the URD directory
;*************************************************************************

 STASHALL

; entry:
;       R0 -> pointer to wildcarded directory name
;       R1 = number of parameters on line

; exit:
;       ------- nothing


; R6 -> Full pathname

; First move to the correct directory, also expand name to whole path
; eg '%.fred' = '$.image03.fred'

; Then save this whole path as the current directory name IF VALID

 TEQ R1, #0                  ; If no parameter following *URD THEN *URD $
; ADREQL R0, BlankPath        ;
 addr R0, BlankPath, EQ

 BL ValidatePathName         ; R0 -> pathname ( see 'Open' )

;*******************

; R0 -> pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number

 MOV R1, #1        ; Looking for a directory
 BL Dir

;*******************

 TEQ R2, #DIRECTORY          ; If it is a file, or not found then error

 [ RISC_OS=2
 BNE notfound
 |
         MOVNE      r0, #ERROR_NOTFOUND
         BNE        Error
 ]


 ; keep the full pathname, eg :FreddyDisc.$.pathname


;****************
; R1 -> urd path for drive [ R4 ]
;****************

 STASH R0

 LDRB R2, numberofdrives       ; R3 -> start of urd buffer
 LDR R1, pointertolibandurd    ;
 MOV R14, #LIBLENGTH           ;
 MLA R1, R2, R14, R1           ;

 [ URDLENGTH <> LIBLENGTH        ; R3 -> correct urd buffer
 MOV R14, #URDLENGTH           ;
 ]
 MLA R1, R4, R14, R1            ;

;****************

 MOV R0, #":"             ;
 STRB R0, [ R1 ], #1      ;
 MOV R0, R4               ; Keep the name of the URD disc
 MOV R2, R3
 BL GetDiscName           ; R0 = drive, R1 -> place to put name, R2 -> buffer
 MOV R0, R1               ;
 BL CutSpace              ;


 LengthOfString R1, R2, R3
 ADD R1, R1, R2
 MOV R0, #"."
 STRB R0, [ R1, #-1 ]

 GRAB R0

;****************
;2. copy from 'Fullpathname' to 'URDPath'
;****************

; R0 -> FullPathName
; R1 -> URDPath
; R4 = byte



01

 LDRB R4, [ R0 ], #1
 STRB R4, [ R1 ], #1
 TEQ R4, #0

 BNE %BT01


 GRABALL
 BICS PC, R14, #Overflow_Flag

 ]




;*************************************************************************
WhichDisc ROUT        ; displays a unique number for the disc in the drive
;*************************************************************************

; on entry:
;          r0->command tail
;          R1=number of parameters
;          r1=0 then use current drive,
;          r1=1 then use drive specified

 STASHALL

 TEQ R1, #1

 ;*****************
 ; Deal with parameter
 ;*****************

 BLEQ atoi
 LDRNEB R0, CurrentDriveNumber
 MOVEQ R0, R2
 
; MOV R2, #0

 BL PreGetUniqueNumber ;R0 = drive number, RETURNS R1, R2 -> disc name, or 0

 MOV R0, R1                ; R0 = value to be converted
                           ; R1 -> place to put string

 ADD R1, R12, #:INDEX:TempArea

 MOV R2, #255

 SWI XOS_ConvertCardinal4

 TEQ R0, R1

 SWINE XOS_Write0

 SWI XOS_NewLine

 GRABALL

 BICS PC, R14, #Overflow_Flag

;*************************************************************************
;*************************************************************************

; EACH NEW STAR COMMAND ADDED SHOULD USE STASHALL AND GRABALL IF TRAP ERRORS


 LTORG

 END


