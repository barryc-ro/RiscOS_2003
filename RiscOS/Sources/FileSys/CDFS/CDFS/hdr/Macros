; -> macros
; =============================================
; Macros should be kept in ALPHABETICAL order !
; =============================================

        MACRO
        AddError $name,$text,$value
   [    "$value" = ""
ErrorNumber_$name # 1
   |
ErrorNumber_$name * $value
   ]
        GBLS ErrorString_$name
ErrorString_$name SETS "$text"
        MEND

; **************************************************************
; ***  Generate File type name labels assuming ^ type defs   ***
; **************************************************************
;
;          Generates a label of the form "FileType_Text" with the
;       value &FFF, or "FileType_PostScript" with the value &FF5.
;       Also generates a global string variable (GBLS) of the form
;       "FileTypeText_FFF" with the value "Text    ", or 
;       "FileTypeText_FF5" with the value "PoScript".  If the second
;       argument is given then it will be used as the text value, if
;       not then the FileType will be used.

        MACRO
$Value  AddFile  $FileType,$FileTypeName,$PostValue
  [     ("$FileType" = "") :LOR: (("$Value" <> "") :LAND: ("$PostValue" <> ""))
        !       1, "Syntax: [<value>] AddFileAscending <File Type> [< File Type Name>]"
        !       1, "    Or: AddFileAscending <File Type> [< File Type Name> [<value>]]"
        MEXIT
  ]
  [     ("$Value" = "") :LAND: ("$PostValue" = "")
FileType_$FileType # 1
  |
  [     "$Value" = ""
FileType_$FileType * $PostValue
  |
FileType_$FileType * $Value
  ]
  ]
  [     FileType_$FileType > &FFF
        !       1, "Value out of range"
  ]
        LCLS    Number
Number  SETS    (:STR: FileType_$FileType) :RIGHT: 3
        GBLS    FileTypeText_$Number
  [     "$FileTypeName" = ""
FileTypeText_$Number SETS ("$FileType" :CC: "        ") :LEFT: 8
  |
FileTypeText_$Number SETS ("$FileTypeName" :CC: "        ") :LEFT: 8
  ]
        MEND

        MACRO
$Value  AddFileDescending  $FileType,$FileTypeName,$PostValue
  [     ("$FileType" = "") :LOR: (("$Value" <> "") :LAND: ("$PostValue" <> ""))
        !       1, "Syntax: [<value>] AddFileAscending <File Type> [< File Type Name>]"
        !       1, "    Or: AddFileAscending <File Type> [< File Type Name> [<value>]]"
        MEXIT
  ]
  [     ("$Value" = "") :LAND: ("$PostValue" = "")
        #       -1
FileType_$FileType # 1
        #       -1
  |
  [     "$Value" = ""
FileType_$FileType * $PostValue
  |
FileType_$FileType * $Value
  ]
  ]
  [     FileType_$FileType > &FFF
        !       1, "Value out of range"
  ]
        LCLS    Number
Number  SETS    (:STR: FileType_$FileType) :RIGHT: 3
        GBLS    FileTypeText_$Number
  [     "$FileTypeName" = ""
FileTypeText_$Number SETS ("$FileType" :CC: "        ") :LEFT: 8
  |
FileTypeText_$Number SETS ("$FileTypeName" :CC: "        ") :LEFT: 8
  ]
        MEND

; ***************************************************
; ***  Put address of $dest in $reg; $dest > .    ***
; ***  !!! Please use addr wherever possible !!!  ***
; ***************************************************
        MACRO
$label  ADDR    $reg, $dest, $cond
$label  ADR$cond.L $reg, $dest
        MEND

; *****************************************************************************
; ***  Optimising ADR/ADRL for addressing object backwards from current pc  ***
; ***  or register relative symbol. Symbol MUST be defined on first pass    ***
; *****************************************************************************
                GBLA    addr_verbose
addr_verbose    SETA    1

        MACRO
$label  addr    $reg, $object, $cc
        LCLA    value
value   SETA    .-$object+8
        Immediate &$value
 [ immediate
$label  ADR$cc  $reg, $object
  [ addr_verbose :AND: 1 <> 0
 ! 0,"addr saved a word"
  ]
 |
$label  ADR$cc.L $reg, $object
  [ addr_verbose :AND: 2 <> 0
 ! 0,"addr didn't save a word"
  ]
 ]
        MEND

        MACRO
$label  wsaddr    $reg, $object, $cc
        LCLA    value
value   SETA    :INDEX: $object
        Immediate &$value
 [ immediate
$label  ADR$cc  $reg, $object
  [ addr_verbose :AND: 1 <> 0
 ! 0,"wsaddr saved a word"
  ]
 |
$label  ADR$cc.L $reg, $object
  [ addr_verbose :AND: 2 <> 0
 ! 0,"wsaddr didn't save a word"
  ]
 ]
        MEND


; ***************************************************
; ***  Generate SWI labels assuming ^ type defs   ***
; ***  Also assumes the global variable SWIClass  ***
; ***************************************************
        GBLS    SWIClass
        MACRO
        AddSWI  $SWIName,$value
  [     "$value" = ""
$SWIClass._$SWIName # 1
  |
$SWIClass._$SWIName * $value
  ]
X$SWIClass._$SWIName * $SWIClass._$SWIName + Auto_Error_SWI_bit
        MEND


; *******************************************************************
; ***  Align workspace to given power-of-two boundary and offset  ***
; *******************************************************************
        MACRO
$label  AlignSpace $value, $offset
 [ "$value" = ""
$label  #       3 :AND: ($offset-:INDEX: @)
 |
$label  #       (($value)-1) :AND: ($offset-:INDEX: @)
 ]
        MEND


        MACRO
$label  AlignForModule
        ALIGN   16,12                   ; So $label at offset 0 when RMLoaded
$label
        MEND

;*************************************************
; MOVES REGISTER TO NEXT ALIGNMENT OR STAYS WHERE IT IS
; Flags and $temp corrupted
;*************************************************
        MACRO
$label  ALIGNREG $reg
$label  TST $reg, #3
        ADDNE $reg, $reg, #4
        BICNE $reg, $reg, #3
        MEND

        MACRO
$label  ASL     $reg, $val, $cc
$label  MOV$cc  $reg, $reg, ASL #$val
        MEND

        MACRO
$label  ASR     $reg, $val, $cc
$label  MOV$cc  $reg, $reg, ASR #$val
        MEND

; *************************************************
; ***  Put address of $dest in $reg; $dest < .  ***
; *************************************************
        MACRO
$label  BADDR   $reg, $dest, $cond
$label  ADR$cond.L $reg, $dest
        MEND


; ****************************************************
; ***   Macro JSR - Jump to subroutine saving R14  ***
; ****************************************************
        MACRO
$label  JSR     $dest
$label  PUSH    R14
        BL      $dest
        PULL    R14
        MEND

; *******************************
; ***  Add byte to workspace  ***
; *******************************
        MACRO
$label  Byte    $value, $count
  [     "$label" = ""
    [   "$count" = ""
$value  # 1
  |
$value  # ($count)
    ]
  |
    [   "$value" = ""
$label  # 1
    |
$label  # ($value)
    ]
  ]
        MEND

; ********************************************
; ***  Macro BYTEWS - Point to OsbyteVars  ***
; ********************************************
        MACRO
        BYTEWS  $reg
        Immediate OsbyteVars
 [ immediate
        MOV     $reg, #OsbyteVars
 |
        MOV     $reg, #(OsbyteVars :AND: &FF)
        ORR     $reg, $reg, #(OsbyteVars :AND: :NOT: &FF)
 ]
        MEND

        MACRO
$label  CallAVector $cond
     [ AssemblingArthur
$label  B$cond   CallVector
     |
      [ Module
$label  B$cond  %FT10
        PUSH    "R8,R9"
        MOV     R8, PC
        AND     R8, R8, #3              ; just get mode bits
        EOR     R8, R8, #SVC_mode       ; eored with SVC mode
        TEQP    R8, PC
        NOP
        PUSH    R14
        MOV     R9, R10
        SWI     XOS_CallAVector
        PULL    R14
        TEQP    R8, PC
        NOP
        PULL    "R8,R9"
        MOV     PC, R14
10
      |
$label  LDR$cond PC, =CallVecAddr
       [ "$cond" = ""
        LTORG     ; Can't conditionally execute constants ! Use your own LTORG
       ]
      ]
     ]
        MEND

;************************************
; This allows nice errors from CDFS
;************************************
        MACRO
$label  CDFSError $name, $message
$name DCD CDFSErrorNumber
       = "$message"
       = 0
CDFSErrorNumber SETA CDFSErrorNumber + 1
 ALIGN
        MEND

; ******************************************
; Check for ISO / HISIERRA format ( If error THEN B Error )
; ******************************************
; ******************************************

; Check for ISO 9660 / Hi-Sierra disc or unknown format disc
; R0 = drive number, R1 -> start of discbuffer

; R7 -> start of buffer for the disc
; R8 = drive number

       MACRO
$label CheckForISOOrHisierra
$label STASH "R0 - R7"

 MOV R3, R0

 MOV R7, R1

 MOV R8, R0

 MOV R0, #PVD

 MOV R2, #1

 BL PreLoadBlockFromDrive       ; R0 = block, R1 = memory, R2 = no. blocks
                                ; R3 = drive


;****************************  ; Find disc type ( ISO / HISIERRA )

 STASH R1

 ADD R1, R1, #9              ; HISIERRA type

 ADR R0, CDROM                                ; IS IT A HISIERRA DISC ?
                                               ;
 MOV R2, #5                                    ;
                                               ;
 BL CompareStrings                             ; returns 'EQ' or 'NE'
                                               ;
 MOVEQ R3, #HISIERRA                           ;
                                               ;
 BEQ %FT01                                     ; [ yes ]


 SUB R1, R1, #8               ; ISO 9660

 ADRL R0, CD001

 BL CompareStrings            ; returns 'EQ' or 'NE'


 [ RISC_OS=2
 ADRNEL R0, DataModeError     ; Unknown format
 BNE Error                    ;
 |
       MOVNE        r0, #ERROR_NOTISO
       BNE          Error
 ]

 MOV R3, #ISO

01

 STRB R3, [ R7, #DISCTYPEOFFSETINABUFFER ]


 GRAB R1

;*****************************     Find logical 'blocksize'

 TEQ R3, #ISO

; I KNOW THAT THESE LIE ON A WORD BOUNDARY

 LDREQB R4, [ R1, #ISOLOGICALBLOCKSIZEOFFSET ]
 LDREQB R0, [ R1, #ISOLOGICALBLOCKSIZEOFFSET + 1 ]
 LDRNEB R4, [ R1, #HISIERRALOGICALBLOCKSIZEOFFSET ]
 LDRNEB R0, [ R1, #HISIERRALOGICALBLOCKSIZEOFFSET + 1 ]
 ORR R0, R4, R0, ASL #8            ; SEE BELOW IF CHANGE THIS REG
 STR R0, [ R7, #BLOCKSIZEOFFSETINABUFFER ]

; LDREQ R4, [ R1, #ISOLOGICALBLOCKSIZEOFFSET ]
; LDRNE R4, [ R1, #HISIERRALOGICALBLOCKSIZEOFFSET ]
; MOV R4, R4, LSL #16
; MOV R4, R4, LSR #16
; STR R4, [ R7, #BLOCKSIZEOFFSETINABUFFER ]

; TEQ R3, #ISO                       ; KEEP FLAGS ALIVE !!!!!!!!!!

;*****************************  Find LBA of main directory

; I KNOW THAT THESE ARE OFFSET BY 2 BYTES !

 ADDEQ R14, R1, #ISOPOINTERTOROOTDIRECTORYOFFSET
 ADDNE R14, R1, #HISIERRAPOINTERTOROOTDIRECTORYOFFSET

 LDRB R3, [ R14, #0 ]
 LDRB R4, [ R14, #1 ]
 LDRB R5, [ R14, #2 ]
 LDRB R6, [ R14, #3 ]
 ORR R3, R3, R4, LSL #8
 ORR R3, R3, R5, LSL #16
 ORR R3, R3, R6, LSL #24
 LDREQB     r6, [ r1, #ISOPOINTERTOROOTDIRECTORYOFFSET - 1 ]  ; XAR NC and MW
 ADDEQ      r3, r3, r6

 STR R3, [ R7, #LBAOFMAINDIROFFSETINABUFFER ]

; LDMIA R14, { R3, R4 }
; MOV R3, R3, LSL #16
; MOV R4, R4, LSR #16
; MOV R4, R4, LSL #16
; ORR R4, R4, R3, LSR #16
; STR R4, [ R7, #LBAOFMAINDIROFFSETINABUFFER ]

;***************************** ; Size of main directory


 ADDEQ R2, R1, #ISOPOINTERTOSIZEOFMAINDIRECTORY 
 ADDNE R2, R1, #HISIERRAPOINTERTOSIZEOFMAINDIRECTORY 

 LDRB R6, [ R2, #3 ]                 ; R2 -> start of size of main dir
 LDRB R3, [ R2, #2 ]                 ;
 LDRB R4, [ R2, #1 ]                 ;
 LDRB R5, [ R2, #0 ]                 ;
 ORR R6, R6, R3, ASL #8              ;
 ORR R6, R6, R4, ASL #16             ;
 ORR R6, R6, R5, ASL #24             ;

 STR R6, [ R7, #LENGTHOFMAINDIROFFSETINABUFFER ]

;*****************************

 GRAB "R0 - R7"

       MEND

; ******************************************
; ******************************************
;********************

;******************************************
; This is used by CDFS in 'initialisation'
; R2 -> Claimed space
; R3 = size of space
;******************************************
       MACRO
$label ClearLIBandURDSpace
$label ADD R14, R2, R3
       MOV R1, #0
01
       STRB R1, [ R2 ], #1
       CMP R2, R14
       BLE %BT01
       MEND

;******************************************
; This is used by CDFS in 'initialisation'
;******************************************
       MACRO
$label ClaimLIBandURDSpace
$label MOV R0, #6
       MOV R3, #( LIBLENGTH + URDLENGTH )
       AND R14, R9, #BITSUSEDBYDRIVENUMBER    ; If number of drives = 0
       TEQ R14, #0                            ; THEN R14 = 1
       MOVEQ R14, #1                          ;
       MUL R3, R14, R3
       SWI XOS_Module
       GRAB "R7 - R11, R14", VS        ; Could not get the memory needed
       ORRVSS PC, R14, #Overflow_Flag
       LDR R14, [ R12 ]
       STR R2, [ R14, #:INDEX:pointertolibandurd ]
       MEND

;******************************************
; This is used by CDFS in 'initialisation'
;******************************************
       MACRO
$label ClaimWorkspace
$label MOV R0, #6                  ; Reason code
       LDR R3, =SIZEOFRMA          ; Amount of memory required
       SWI XOS_Module
       GRAB "R7 - R11, R14", VS    ; Could not get the memory needed
       ORRVSS PC, R14, #Overflow_Flag
       STR R2, [ R12 ]                 ; Save it in the private word
       MEND

; ******************************************
; ***  Clear carry flag - will set nzcv  ***
; ******************************************
        MACRO
$label  CLC     $cond
$label  CMN$cond PC, #0
        MEND

;**************************************************************************
; This is used by CDFS in 'initialisation'
;**************************************************************************
       MACRO
$label ClearBufferPointerList
$label ADD R3, R3, R2
       MOV R4, #0
       MOV R1, R2
01
       STMIA R1!, { R4 }
       CMP R1, R3
       BLT %BT01
       MEND

;**************************************************************************
; This is used by CDFS in 'initialisation'
;**************************************************************************
       MACRO
$label ClearDiscBufferSpace
$label ADD R3, R3, R2
       MOV R14, #0
01
       STMIA R2!, { R14 }
       CMP R2, R3
       BLT %BT01
       MEND

;**************************************************************************
; This is used by CDFS in 'initialisation'
;**************************************************************************
       MACRO
$label ClearReservedMemory
$label MOV R1, #0
       MOV R0, R2
       LDR R3, =SIZEOFRMA
       ADD R3, R3, R2
01
       STMIA R0!, { R1 }
       CMP R0, R3
       BLE %BT01
       MEND

; **************************************************************************
; ***  Clear bits in PSR from the mask in $bits, using register $regtmp  ***
; **************************************************************************
        MACRO
$label  CLRPSR  $bits, $regtmp, $cond
$label  MVN$cond   $regtmp, #$bits
        TST$cond.P $regtmp, PC
        MEND


;********************************************
;************ Clear the screen **************
;********************************************
        MACRO
$label  CLS
$label  [ debug=ON
        SWI &100 + 12          ; Print character 12 ( Clear screen char )
        ]
        MEND


; *******************************************
; *** Clear overflow flag - will set nzCv ***
; *******************************************
        MACRO
$label  CLV    $cond
$label  CMP$cond PC, #0
        MEND

; *********************************************
; *** Generates a help/syntax/command block ***
; ***    for a Module star command table    ***
; *** Needs a variable Module_BaseAddr set  ***
; *********************************************
        GBLA    Command_LastName ; Offset to command string within module
        MACRO
        Command $cmd, $max, $min, $optbits, $cmdlabel
        LCLA    temp
        LCLS    cmdlab
 [ "$optbits" = ""
temp    SETA    0
 |
temp    SETA    $optbits
 ]
 [ "$cmdlabel" = ""
cmdlab  SETS    "$cmd"
 |
cmdlab  SETS    "$cmdlabel"
 ]
Command_LastName SETA .-Module_BaseAddr
        DCB     "$cmd", 0
        ALIGN
        DCD     $cmdlab._Code  -Module_BaseAddr
        DCD     ($min) + (($max) :SHL: 16) + temp
        DCD     $cmdlab._Syntax-Module_BaseAddr
        DCD     $cmdlab._Help  -Module_BaseAddr
        MEND

;********************************************************
;********************************************************

; This converts an ISO or HISIERRA date to an ARCHY centi-second date

;********************************************************
;********************************************************
; $from -> 6 byte block, $to -> put 5 byte Archy block

        MACRO
$label  ConvertToArchyDate $from, $to, $temp1, $temp2, $temp3, $temp4, $temp5, $temp6
$label  LDRB $temp1, [ $from, #0 ] ; R1 = year ( from 1900 )

 LDR $temp2, =365           ; ( year * 365 ) + ( year DIV 4 )
 MOV $temp4, $temp1, ASR #2 ;
 MLA $temp3, $temp2, $temp1, $temp4         ;

 LDR $temp2, =6 * 15 * 25 * 15  ; result * numberofcentisecondsayear / 256
 MUL $temp3, $temp2, $temp3     ;

 MOV $temp6, $temp3, ASR #24        ; h/b of result ( ignore bits 8 to 31 )

 MOV $temp5, $temp3, ASL #8         ; l/bs of result 

 LDRB $temp1, [ $from, #1 ]        ; month ( 1 to 12 )

 ADRL $temp4, DaysInMonth - 4   ; R3 = cumulative total of days up to that month
 LDR $temp3, [ $temp4, $temp1, ASL #2 ] ;
 LDRB $temp4, [ R0, #2 ]        ; day
 ADD $temp3, $temp3, $temp4             ;
 MUL $temp4, $temp3, $temp2             ; R4 = R3 * 6 * 15 * 15 * 25


 ADD $temp5, $temp5, $temp4, ASL #8     ; l/bs of result
 MOV $temp3, $temp4, ROR #24        ; h/b of result
 AND $temp3, $temp3, #&FF           ;
 ADD $temp6, $temp6, $temp3             ;

 LDRB $temp2, [ $from, #3 ]        ; l/bs hourcentiseconds
 LDR $temp1, =60*60*100         ;
 MLA $temp5, $temp1, $temp2, $temp5         ;

 LDR $temp1, =60*100            ; l/bs minutecentiseconds
 LDRB $temp2, [ $from, #4 ]        ;
 MLA $temp5, $temp1, $temp2, $temp5         ;

 LDRB $temp1, [ $from, #5 ]        ; l/bs of secondcentiseconds
 MOV $temp2, #100               ;
 MLA $temp5, $temp1, $temp2, $temp5         ;

 STR $temp5, [ $to ]
 STRB $temp6, [ $to, #4 ]

       MEND

;********************************************************
;*****************    Crappy copy macro AAAAAAAAAA chuck *****************
; $from -> copy from        ( corrupted )
; $to   -> copy to          ( corrupted )
; $length = length of copy  ( corrupted )
; $temp = garbage           ( corrupted )

; Flags corrupted by this

;********************************************************
;        MACRO
;$label  CopyString $from, $to, $length, $temp
;$label  ADD $length, $from, $length
;01
;        LDRB $temp, [ $from ], #1
;        STRB $temp, [ $to ], #1
;        CMP $from, $length
;        BLE %BT01
;        MOV $temp, #0
;        STRB $temp, [ $to ]           ; Null terminate the string
;        MEND



        MACRO
$label  DEC     $reg,$by
        [ "$by" = ""
$label  SUB     $reg,$reg,#1
        |
$label  SUB     $reg,$reg,#$by
        ]
        MEND

        MACRO
$label  DECS    $reg,$by
        [ "$by" = ""
$label  SUBS    $reg,$reg,#1
        |
$label  SUBS    $reg,$reg,#$by
        ]
        MEND

; **********************************************************
; This will print a message if 'debug' = ON.
; **********************************************************
        MACRO
$label  Debug $string,$nl
$label  [ debug=ON
        STASH R14
         [ hostvdu=ON
        SWI XHostFS_HostVdu
         ]
        SWI XOS_WriteS
        = "$string"
         [ "$nl"="NL"
        = 13,10
         ]
        = 0
        ALIGN
         [ hostvdu=ON
        SWI XHostFS_TubeVdu
         ]
        GRAB R14
        ]
        MEND

; **********************************************************
; This will print a new line if 'debug' = ON.
; **********************************************************
        MACRO
$label  DebugNewLine
$label  [ debug=ON
        STASH R14
         [ hostvdu=ON
        SWI XHostFS_HostVdu
         ]
        SWI XOS_NewLine
         [ hostvdu=ON
        SWI XHostFS_TubeVdu
         ]
        GRAB R14
        ]
        MEND

; **********************************************************
; This will perform a XOS_Write0 if 'debug' = ON.
; **********************************************************
        MACRO
$label  Debug0 $string,$nl
$label  [ debug=ON
        STASH R14
         [ hostvdu=ON
        SWI XHostFS_HostVdu
         ]
        SWI XOS_Write0
         [ "$nl"="NL"
        SWI XOS_NewLine
         ]
         [ hostvdu=ON
        SWI XHostFS_TubeVdu
         ]
        GRAB R14
        ]
        MEND

; **********************************************************
; This will perform a Display if 'debug' = ON.
; **********************************************************
        MACRO
$label  DebugDisplay $string,$nl
$label  [ debug=ON
        STASH R14
         [ hostvdu=ON
        SWI XHostFS_HostVdu
         ]
        Display $string,$nl
         [ hostvdu=ON
        SWI XHostFS_TubeVdu
         ]
        GRAB R14
        ]
        MEND

; **********************************************************
; This will perform a wait-for-key if 'debug' = ON. R14 corrupted !
; **********************************************************

        MACRO
$label  WaitForAKey
$label
        STASH "R0 - R2,R14"
        MOV R0, #122
01
        SWI XOS_Byte
        CMP R1, #&FF
        BEQ %BT01
        GRAB "R0 - R2,R14"
        MEND


; **********************************************************
; This will perform a wait-for-key if 'debug' = ON. R14 corrupted !
; **********************************************************
        MACRO
$label  DebugWaitForAKey
$label  [ debug=ON
        STASH "R0 - R2,R14"
        MOV R0, #122
01
        SWI XOS_Byte
        CMP R1, #&FF
        BEQ %BT01
        GRAB "R0 - R2,R14"
        ]
        MEND

;**********************************************************
; This is used by CDFS in 'initialisation'
;**********************************************************
;       MACRO
;$label DeleteDiscBufferPointer
;$label LDR R2, discbufferpointer
;       MOV R0, #7
;       SWI XOS_Module
;       MOV R2, #0
;       STR R2, discbufferpointer
;       MEND

; **********************************************************
; **********************************************************

;     This macro will display the contents of a register in hex

; Only 8 digits are displayed

; Must have an area setup called 'letters' with "0123456789ABCDEF" in

; **********************************************************
; **********************************************************
        MACRO
$label  Display $reg,$nl

$label  STASH "R0-R3,R14"
        [ $reg <> r1
        MOV R1, $reg
        ]
        ADRL R3, letters
        MOV R2, #8              ; altering this figure affects the number of

01      MOV R1, R1, ROR #28  ; characters displayed
        AND R0, R1, #15

        LDRB R0, [ R0, R3 ]

        SWI XOS_WriteC

        SUBS R2, R2, #1

        BNE %BT01

        [ "$nl"="NL"
        SWI XOS_NewLine
        ]

        GRAB "R0-R3,R14"

        MEND

;**************************************************************************
; This is used by CDFS in 'initialisation'
;**************************************************************************
;       MACRO
;$label DisplayMessageNoBuffers
;$label ADRL R0, NoDiscBuffer
;       SWI XOS_Write0
;       SWI XOS_NewLine
;
;       ;Delay for 2 seconds !!!!!!!!!
;       SWI XOS_ReadMonotonicTime   ; RETURNS R0 = time in centi-seconds since
;                                   ; last hard reset
;       ADD R1, R0, #2*100
;01
;       SWI XOS_ReadMonotonicTime   ; RETURNS R0 = time in centi-seconds since
;                                   ; last hard reset
;       CMP R0, R1
;       BLT %BT01
;       MEND

; **********************************************************
; ***                  Unsigned divide by 10             ***
; on entry:
;          $number = value to divide by 10
; on exit:
;          $number=$number / 10
;          $temp1 =$number MOD 10
; **********************************************************
  MACRO
$label DivideBy10 $number, $temp1, $temp3
$label MOV     $temp1,$number
       MOV     $number,$number,LSR #1
       ADD     $number,$number,$number,LSR #1
       ADD     $number,$number,$number,LSR #4
       ADD     $number,$number,$number,LSR #8
       ADD     $number,$number,$number,LSR #16
       MOV     $number,$number,LSR #3
       ADD     $temp3,$number,$number,LSL #2
       SUB     $temp1,$temp1,$temp3,LSL #1
       CMP     $temp1,#10
       ADDGE   $number,$number,#1
       SUBGE   $temp1,$temp1,#10
  MEND

; **********************************************************
; ***   Macro DIVREM - rc := ra DIV rb; ra := ra MOD rb  ***
; ***   rb preserved, rtemp corrupt                      ***

; IF ra = rb THEN this macro locks up !!!!!!!


; ***   Now up to 37% faster                             ***
; **********************************************************
        MACRO
$label  DivRem  $rc, $ra, $rb, $rtemp
$label
        MOV     $rtemp, $rb
        CMP     $rtemp, $ra, LSR #1
01
        MOVLS   $rtemp, $rtemp, LSL #1
        CMPLS   $rtemp, $ra, LSR #1
        BLS     %BT01
        MOV     $rc, #0
02
        CMP     $ra, $rtemp
        SUBCS   $ra, $ra, $rtemp
        ADC     $rc, $rc, $rc
        MOV     $rtemp, $rtemp, LSR #1
        CMP     $rtemp, $rb
        BCS     %BT02
        MEND

; **********************************************************
; ***   Macro DIVREM - rc := ra DIV rb; ra := ra REM rb  ***
; ***   OLD version NB. rb, rtemp corrupt                ***
; **********************************************************
;        MACRO
;$label  DivRem  $rc, $ra, $rb, $rtemp
;$label  MOV     $rtemp, #1
;01      CMP     $rb, #&80000000
;        CMPCC   $rb, $ra
;        MOVCC   $rb, $rb, ASL #1
;        MOVCC   $rtemp, $rtemp, ASL #1
;        BCC     %BT01
;        MOV     $rc, #0
;02      CMP     $ra, $rb
;        SUBCS   $ra, $ra, $rb
;        ADDCS   $rc, $rc, $rtemp
;        MOVS    $rtemp, $rtemp, LSR #1
;        MOVNE   $rb, $rb, LSR #1
;        BNE     %BT02
;        MEND

        MACRO
$label  DoCallTable $jumpreg, $tablename, $work
$label  PUSH    "$work, PC"
        ADR     $work, $tablename
        LDR     lr, [$work, $jumpreg, LSL #2]
        ADD     $work, $work, lr
        STR     $work, [stack, #4]
        MOV     lr, PC ; ADR lr, %FT99 with correct mode bits
        PULL    "$work, PC"
;                0      4
        ASSERT $jumpreg <> $work
        ASSERT $jumpreg <> lr
        ASSERT $jumpreg <> PC
99 ; Return here from called routine
        MEND

; ****************************************************************************
; ***  Probably the fastest jump table mechanism for PIC - a mere 4S + 2N  ***
; ***  cycles.  Jump table directly follows the macro, and is a list of    ***
; ***  offsets done by eg.  DCD routine_address-table-4. Needs only one    ***
; ***  register temp (Use lr mostly).                                      ***
; ****************************************************************************
        MACRO
$label  DoFastJumpTable $jumpreg, $trash
$label  LDR     $trash, [PC, $jumpreg, LSL #2]
        ADD     PC, PC, $trash
        MEND

; *********************************************
; ***  Jump table preserving all registers  ***
; *********************************************
        MACRO
$label  DoJumpTable $jumpreg, $tablename, $work1, $work2
$label  PUSH    "$work1, $work2, PC"      ; PC is just a dummy reg here
        ADR     $work1, $tablename
        LDR     $work2, [$work1, $jumpreg, LSL #2]
        ADD     $work1, $work1, $work2
        STR     $work1, [stack, #8]
        PULL    "$work1, $work2, PC"
;                0       4       8
        ASSERT $jumpreg <> $work1
        ASSERT $jumpreg <> $work2
        ASSERT $jumpreg <> PC
        MEND

        MACRO
$label  DoSVCCallTable $jumpreg, $tablename
$label  ADR     SVCWK1, $tablename
        LDR     SVCWK0, [SVCWK1, $jumpreg, LSL #2]
        MOV     lr, PC ; ADR lr, %FT99 with correct mode bits
        ADD     PC, SVCWK1, SVCWK0
        ASSERT $jumpreg <> lr
        ASSERT $jumpreg <> PC
99 ; Return here from called routine
        MEND

; ***************************************************************************
; ***  Jump table using SVC mode temporary registers. Use with caution !  ***
; ***************************************************************************
        MACRO
$label  DoSVCJumpTable $jumpreg, $tablename
$label  ADR     SVCWK1, $tablename
        LDR     SVCWK0, [SVCWK1, $jumpreg, LSL #2]
        ADD     PC, SVCWK1, SVCWK0
        ASSERT $jumpreg <> lr
        ASSERT $jumpreg <> PC
        MEND

        MACRO
$label  Error   $errno, $errstr
$label  ADR     R0, %FT01
        SWI     OS_GenerateError
01
        &       $errno
        =       "$errstr", 0
        ALIGN
        MEND

        MACRO
$label  XError     $errsym, $c1, $c2
$label  ADR$c1$c2  R0,ErrorBlock_$errsym
        SETV       $c1
        MEND

; ***********************************************************************
; ***  Exit macro for SWI handlers.                                   ***
; ***  Jump to 17M in the Sam-hacked Brazil, for installed handlers.  ***
; ***  Do it directly if really in system                             ***
; ***********************************************************************
SWIHandlerExit * 17*1024*1024
CallVecAddr    * SWIHandlerExit+4
        MACRO
$label  ExitSWIHandler $cond
        [ AssemblingArthur
$label  B$cond   SLVK
        |
        [ Module
$label  LDR$cond PC, =BranchToSWIExit
        |
$label  MOV$cond PC, #SWIHandlerExit
        ]
        ]
        MEND

;***********************************************************************
; This is used by CDFS in 'FullPathName' ( Directory )
;***********************************************************************
        MACRO
$label  fill_in_up_pathMacro
$label  ; * Yoooouuuuu

 MOV R4, R0

04

 LDRB R1, [ R4 ]               ; Is the char a '^' ? ( move up directory )
 TEQ R1, #"^"                  ;
                               ;
 BLEQ %FT06                    ; [ yes - so shuffle string ]
 BEQ %BT04                     ;

05

 LDRB R1, [ R4 ], #1           ; R0 -> next branch
 TEQ R1, #"."                  ;
 TEQNE R1, #0                  ;
 BNE %BT05                     ;

 TEQ R1, #0                    ; End of string ?
 BNE %BT04                     ; [ no - so check for '^' ]


 GRAB "R1 - R8, PC"


;*********************
; Concetanate string because of '^' in it
;*********************

06

 STASH R4

 SUB R4, R4, #1

;************
; Move back up the branch
;************

07

 LDRB R1, [ R4, #-1 ]!  ; R4 -> "." checked !!!!!!!
 TEQ R1, #"."
 TEQNE R1, #"$"
 BNE %BT07

;************
; If I have moved to the start of the path ( '$' ) then end !
;************

 TEQ R1, #"$"           ; Reached root directory ?
 MOVEQ R1, #0           ; [ yes - so null terminate and end ]
 STREQB R1, [ R4, #1 ]  ;
 GRAB R1, EQ            ;
 MOVEQS PC, R14         ;

;************
; Shuffle string up on branch over the top of '^'
;************

 GRAB R1                ; R1 -> place to copy from
                        ; R0 -> place to copy to
 STASH R4

08

 LDRB R2, [ R1, #1 ]!
 STRB R2, [ R4 ], #1
 TEQ R2, #0
 BNE %BT08

;************
; Return to sender
;************

 GRAB R4

 BICS PC, R14, #Overflow_Flag

       MEND

;***********************************************************************
; This is used by CDFS in 'FullPathName' ( Directory )
;***********************************************************************
       MACRO
$label fill_in_previousMacro
$label ; OOhhhh

;*************
; Copy previously selected directory disc name into a temporary area
;*************

 LDR R1, =:INDEX:BackPath    ; R1 -> current CSD
 ADD R1, R1, R12


 ADD R5, R12, #:INDEX:OpenedOutString

 MOV R0, R5

01
 LDRB R14, [ R1, #1 ]!
 STRB R14, [ R5 ], #1
 TEQ R14, #0
 TEQNE R14, #"."
 BNE %BT01

 TEQ R14, #0
 MOVEQ R3, R1
 ADDNE R3, R1, #1

 MOVNE R14, #0
 STRB R14, [ R5, #-1 ]

;*************
; Find out which drive that disc is in, or failing that prompt for it
;*************

 BL FindDiscNameInList     ; R0 -> disc name, RETURNS R1 = drive, or -1

 CMP R1, #-1               ; Is the disc still mounted ?
                           ;
 LDREQB R1, olddrivenumber ; [ no - so use old drive number ]

 BL PromptForDisc          ; R0 -> disc name, R1 = drive number
                           ; If disc not put in then errored and won't return

;*************
; Copy from $.dsfsd to OpenedOutString
; R0 -> OpenedOutString ( copy to )
; R3 -> $.DSFSD
;*************

02

 LDRB R14, [ R3 ], #1
 STRB R14, [ R0 ], #1
 TEQ R14, #0
 BNE %BT02

 SUB R0, R0, #1

;*************
; Append '\.dada' to OpenedOutString
; R0 -> OpenedOutString ( copy to )
; R6 -> '\'
;*************

03

 LDRB R14, [ R6, #1 ]!
 STRB R14, [ R0 ], #1
 TEQ R14, #0
 BNE %BT03


;*************

 ADD R0, R12, #:INDEX:OpenedOutString

       MEND

;***********************************************************************
; This is used by CDFS in 'FullPathName' ( Directory )
; R6 -> &.dfsd.fsd
; R7 = drive number
; RETURN R0 -> new path
;***********************************************************************
       MACRO
$label fill_in_URDMacro
$label ;* Hello

;******************
; Do I need to make sure that R6 -> '&.sdafds' ?
;******************

; LDRB R5, [ R6 ]
; TEQ R5, #"&"
; ADDEQ R6, R6, #1
; LDREQB R5, [ R6 ]
; TEQEQ R5, #"."
; ADDEQ R6, R6, #1

 ADD R6, R6, #1


;*****************
; R1 must point at user root directory for this drive
;*****************

 LDRB R2, numberofdrives       ; R1 -> start of urd buffer
 LDR R1, pointertolibandurd    ;
 MOV R5, #LIBLENGTH            ;
 MLA R1, R2, R5, R1            ;

 [ URDLENGTH <> LIBLENGTH
 MOV R5, #URDLENGTH            ;
 ]
 MLA R1, R7, R5, R1            ;

 B general_lib_urd

 [ debug=ON
 Debug " URD MUST BE -> "
 MOV R5, R1
 DebugDisplay R5
 ]

;*****************
; R5 -> place to put fully opened string ( without disc name )
;*****************

 ADD R5, R12, #:INDEX:OpenedOutString

;*****************
; Has the urd been set for this drive ?
;*****************

 LDRB R14, [ R1 ]         ; If URD not selected, THEN no disc name will be
 TEQ R14, #0              ; known
 BEQ not_selectedURD       ;

 Debug " URD is selected "

;*****************
; Request the caller to put the correct disc in the selected drive
; It will check to see if it is already in there
;*****************

 ; 1. Copy disc name into nice area
 ; 2. Prompt for the disc

 MOV R4, R5

01                         ; Make sure correct disc is in drive
                           ;
 LDRB R0, [ R1, #1 ]!      ;
 STRB R0, [ R5 ], #1       ;
 TEQ R0, #"."              ;
 TEQNE R0, #0              ;
 BNE %BT01                 ;

 TEQ R0, #0                ; R3 -> start of real path ( $.fjhdfj.fdksn )
 ADDNE R3, R1, #1          ;
 MOVEQ R3, R1              ;

 MOVNE R0, #0              ; Null terminate the disc name
 STRB R0, [ R5, #-1 ]      ;

 [ debug=ON
 Debug " R3 -> "
 MOV R5, R3
 DebugDisplay R5
 ]

 MOV R0, R4
 MOV R1, R7

 [ debug=ON
 Debug " Disc name = "
 STASH R0
 Debug0
 GRAB R0
 ]

 BL PromptForDisc          ; R0 -> disc name, R1 = drive number

;*****************
;*****************

 ADD R5, R12, #:INDEX:OpenedOutString

;*****************
; R1 must point at $.fjsf.fsdhfa
;*****************

 MOV R1, R3

;*****************

not_selectedURD

02
 LDRB R0, [ R1 ], #1       ; Move to end of current URD
 TEQ R0, #0                ;
 STRNEB R0, [ R5 ], #1     ;
 BNE %BT02                 ; R1 -> after null terminator


 LDRB R0, [ R6 ], #1       ; Was path just '%' ?

03
 STRB R0, [ R5 ], #1
 TEQ R0, #0
 LDRNEB R0, [ R6 ], #1
 BNE %BT03


 ADD R0, R12, #:INDEX:OpenedOutString


 [ debug=ON
 Debug " Resultant URD path = "
 MOV R5, R0
 DebugDisplay R5
 ]
     MEND

;***********************************************************************
; This is used by CDFS in 'FullPathName' ( Directory )
;***********************************************************************
       MACRO
$label fill_in_CSDMacro
$label ; * Hi

 LDRB R5, [ R6 ]
 TEQ R5, #"@"
 ADDEQ R6, R6, #1
 LDREQB R5, [ R6 ]
 TEQEQ R5, #"."
 ADDEQ R6, R6, #1

 BEQ normal_CSD


 STASH R0 - R2

;************
; If disc in spec. drive = currentdisc number then use CSDpath
;************

 LDR R2, CSDDiscNumber
 TEQ R2, R8
 GRAB R0 - R2         ; use drive number set by *Dir
 BEQ normal_CSD

;*****
; ELSE
;*****

; GRAB R0 - R2

 MOV R4, R2             ; Use drive number, as given by caller

 addr R1, BlankPath

 ADD R5, R12, #:INDEX:OpenedOutString

 B not_selectedCSD






normal_CSD

; LDR R1, =CSD_path_offset    ; R1 -> current CSD
; ADD R1, R1, R12


; ADD R5, R12, #OpenedOutString_offset


; LDRB R2, CSDSelected      ; If CSD not selected, THEN no disc name will be
; TEQ R2, #SELECTED         ; known
; BNE not_selectedCSD       ;


 ; 1. Copy disc name into nice area
 ; 2. Prompt for the disc

; MOV R4, R5

;find_rightCSD              ; Make sure correct disc is in drive
                           ;
; LDRB R0, [ R1, #1 ]!      ;
; STRB R0, [ R5 ], #1       ;
; TEQ R0, #"."              ;
; TEQNE R0, #0              ;
; BNE find_rightCSD         ;
; MOV R0, #0
; STRB R0, [ R5, #-1 ]


; MOV R0, R4
; LDRB R1, CurrentDriveNumber

; MOV R1, R7
; BL PromptForDisc          ; R0 -> disc name, R1 = drive number

 ADD R5, R12, #:INDEX:OpenedOutString

 LDR R1, =:INDEX:CSD_path
 ADD R1, R1, R12

find_end_CSD_dot           ; Move past disc name
                           ;
 LDRB R0, [ R1 ], #1       ;
 TEQ R0, #"."              ;
 TEQNE R0, #0              ;
 BNE find_end_CSD_dot      ;

not_selectedCSD

find_the_end_CSD
 LDRB R0, [ R1 ], #1       ; Move to end of current CSD
 TEQ R0, #0
 STRNEB R0, [ R5 ], #1
 BNE find_the_end_CSD

                           ; R1 -> after null terminator

 LDRB R0, [ R6 ], #1
 TEQ R0, #0
 MOVNE R1, #DOT
 STRNEB R1, [ R5 ], #1

add_path_CSD
 STRB R0, [ R5 ], #1
 TEQ R0, #0
 LDRNEB R0, [ R6 ], #1
 BNE add_path_CSD

 ADD R0, R12, #:INDEX:OpenedOutString

     MEND

;***********************************************************************
; This is used by CDFS in 'FullPathName' ( Directory )
;***********************************************************************
       MACRO
$label fill_in_parentMacro
$label ; * Goodbye

;*************
; Copy currently selected directory into newpath
;*************

 LDR R1, =:INDEX:CSD_path    ; R1 -> current CSD
 ADD R1, R1, R12

 ADD R5, R12, #:INDEX:OpenedOutString

find_the_end_UP
 LDRB R0, [ R1 ], #1       ; Move to end of current CSD
 STRB R0, [ R5 ], #1
 TEQ R0, #0
 BNE find_the_end_UP

                           ; R1 -> after null terminator
;*************
; Add the rest of the path '^.fsjdhfsd.gfshgs' and let fill_in_pathMacro
; deal with the '^'
;*************

 MOV R0, #"."
 STRB R0, [ R5, #-1 ]

add_path_UP
 LDRB R0, [ R6 ], #1
 STRB R0, [ R5 ], #1
 TEQ R0, #0
 BNE add_path_UP


 ADD R0, R12, #:INDEX:OpenedOutString

     MEND

;***********************************************************************
; This is used by CDFS in 'FullPathName' ( Directory )
;***********************************************************************
       MACRO
$label fill_in_libraryMacro
$label ; * Woooh

 Debug " fill in library "

;***********
; Do I need to check for '%.fdsf' can I not assume it ?
;***********

; LDRB R5, [ R6 ]
; TEQ R5, #"%"
; ADDEQ R6, R6, #1
; LDRB R5, [ R6 ]
; TEQ R5, #"."
; ADDEQ R6, R6, #1

 ADD R6, R6, #1       ; R6 -> '.FSDFDS.FSDF'

;*****************
; R1 must point at library for this drive
;*****************

; R1 = library path buffer + ( drive number * length of lib path )

 LDR R1, pointertolibandurd
 MOV R5, #LIBLENGTH
 MLA R1, R5, R7, R1


;*****************
; R5 -> place to put fully opened string ( without disc name )
;*****************

general_lib_urd

 ADD R5, R12, #:INDEX:OpenedOutString

;*****************
; Has the library been set for this drive ?
;*****************

 LDRB R14, [ R1 ]          ; Is first byte of path = 0 ?
 TEQ R14, #0               ;
 BEQ not_selectedLIB       ; [ yes - then lib not set ]

 Debug " LIB is selected "

;*****************
; Request the caller to put the correct disc in the selected drive
; It will check to see if it is already in there
;*****************

 ; 1. Copy disc name into nice area
 ; 2. Prompt for the disc

 MOV R4, R5

01                         ; Make sure correct disc is in drive
                           ;
 LDRB R0, [ R1, #1 ]!      ;
 STRB R0, [ R5 ], #1       ;
 TEQ R0, #"."              ;
 TEQNE R0, #0              ;
 BNE %BT01                 ;

 TEQ R0, #0                ; R3 -> start of real path ( $.fjhdfj.fdksn )
 ADDNE R3, R1, #1          ;
 MOVEQ R3, R1              ;

 MOVNE R0, #0              ; Null terminate the disc name
 STRB R0, [ R5, #-1 ]      ;

 [ debug=ON
 Debug " R3 -> "
 MOV R5, R3
 DebugDisplay R5
 ]

 MOV R0, R4
 MOV R1, R7

 [ debug=ON
 Debug " Disc name = "
 STASH R0
 Debug0
 GRAB R0
 ]

 BL PromptForDisc          ; R0 -> disc name, R1 = drive number

;*****************
;*****************

 ADD R5, R12, #:INDEX:OpenedOutString

;*****************
; R1 must point at $.fjsf.fsdhfa
;*****************

 MOV R1, R3

;*****************

not_selectedLIB

02
 LDRB R0, [ R1 ], #1       ; Move to end of current CSD
 TEQ R0, #0                ; and save it in the new path
 STRNEB R0, [ R5 ], #1     ;
 BNE %BT02                 ; R1 -> after null terminator


 LDRB R0, [ R6 ], #1       ; Was path just '%' ?

03
 STRB R0, [ R5 ], #1
 TEQ R0, #0
 LDRNEB R0, [ R6 ], #1
 BNE %BT03

 ADD R0, R12, #:INDEX:OpenedOutString

 [ debug=ON
 Debug " Resultant LIB path = "
 MOV R5, R0
 DebugDisplay R5
 ]

    MEND

;***********************************************************************
; This is used by CDFS in 'FullPathName' ( Directory )
;***********************************************************************
       MACRO
$label fill_in_rootMacro
$label ; * Meeee

;***********
; JUST COPY INTO OpenedOutString buffer as no work has to be done apart
; from checking for '^' which is done by fill_in_upMacro
;***********

 ADD R1, R12, #:INDEX:OpenedOutString

 MOV R0, R6
 MOV R6, R1

01

 LDRB R3, [ R0 ], #1
 STRB R3, [ R1 ], #1

 TEQ R3, #0
 BNE %BT01

 MOV R0, R6

      MEND

;***********************************************************************
; This is used by CDFS in 'FullPathName' ( Directory )
;***********************************************************************
;***********************************************************************
; This is used by CDFS in 'FullPathName' ( Directory )
;***********************************************************************

;***********************************************************************
; This is used by CDFS in 'initialisation'
;***********************************************************************
;**************
; Get byte currently in CMOS RAM
;**************

;       MACRO
;$label GetByteFromCMOS
;$label MOV R0, #161                ; Reason code              FOR GET
;       MOV R1, #HARDRAMLOCATION    ; Cmos RAM location
;       SWI XOS_Byte                ; R2 = contents of location
;       MEND

;***********************************************************************
; This pulls from a full-descending stack ( -> R13 )
;***********************************************************************

        MACRO
$label  GRAB    $reglist, $cond, $hat
$label  LDM$cond.FD R13!, {$reglist}$hat
        MEND


        MACRO
$label  GRABALL $cond
$label  LDR$cond R13, stackreturn
        GRAB "R0 - R12, R14", $cond
        MEND

; *****************************************************************************
; ***  PULL registers and restore PSR (if R15 loaded). Use with extreme     ***
; ***  caution : there are bugs in 3um ARM with PSR update in non-USR modes.***
; *****************************************************************************
        MACRO
$label  GRABS   $reglist, $cond
$label  LDM$cond.FD R13!, {$reglist}^
        [ :LEN: "$reglist" <= 3
 ! 0,"GRABS used dangerously - check your code !"
        ]
        MEND

        MACRO
$label  INC     $reg,$by
        [ "$by" = ""
$label  ADD     $reg,$reg,#1
        |
$label  ADD     $reg,$reg,#$by
        ]
        MEND

        MACRO
$label  INCS    $reg,$by
        [ "$by" = ""
$label  ADDS    $reg,$reg,#1
        |
$label  ADDS    $reg,$reg,#$by
        ]
        MEND

; ****************************************************
; ***  Generates the InfoWord for a command table  ***
; ****************************************************
        MACRO
        InfoWord $max, $min, $optbits
 [ "$optbits" = ""
        DCD     ($min) + (($max) :SHL: 16)
 |
        DCD     ($min) + (($max) :SHL: 16) + $optbits
 ]
        MEND

; **********************************************************
; ***  Macro Immediate - set flag if value is immediate  ***
; **********************************************************
        GBLL    immediate

        MACRO
        Immediate $var
immediate SETL  {FALSE}
        LCLA    count
        LCLA    varcopy
varcopy SETA    $var
        WHILE   count <= 30
 [ ((varcopy:SHL:count) + (varcopy:SHR:(32-count))) :AND: (:NOT: &FF) = 0
immediate SETL  {TRUE}
        MEXIT
 ]
count   SETA    count + 2
        WEND
        MEND

; *********************************************
; ***  Macro LDROSB - Load Osbyte variable  ***
; *********************************************
        MACRO
$label  LDROSB  $reg, $var, $cond
$label  MOV$cond $reg, #0
        LDR$cond.B $reg, [$reg, #OsbyteVars+$var-OSBYTEFirstVar]
        MEND

; ******************************************************
; ***  Macro LDW - Load word from unknown alignment  ***
; ******************************************************
        MACRO
$label  LDW     $dest, $addr, $temp1, $temp2
        ASSERT  $dest < $temp2
$label  BIC     $temp1, $addr, #3
        LDMIA   $temp1, {$dest, $temp2}
        AND     $temp1, $addr, #3
        MOVS    $temp1, $temp1, LSL #3
        MOVNE   $dest, $dest, LSR $temp1
        RSBNE   $temp1, $temp1, #32
        ORRNE   $dest, $dest, $temp2, LSL $temp1
        MEND

; ******************************************************
; ***  Macro Find length of null terminated string   ***
; ******************************************************
        MACRO
$label  LengthOfString $name, $length, $temp
        MOV $length, #0
01
$label  LDRB $temp, [ $name, $length ]
        ADD $length, $length, #1
        CMP $temp, #0
        BNE %BT01
        MEND

;--- This is for cdfs to keep a log of calls made

 MACRO
$label log_on
$label
 [ log=ON
 STASH R14
 LDR R14, log_pointer
 STR PC, [ R14 ], #4
 STR R14, log_pointer
 GRAB R14
 ]
 MEND

; ***********************************************************************
; ***  Lowercasing macro. Needs temp register; only lowercases A-Z !  ***
; ***********************************************************************
        MACRO
$label  LowerCase $reg, $wrk
$label  CMP     $reg, #"A"
        RSBGES  $wrk, $reg, #"Z"        ; inverse compare
        ADDGE   $reg, $reg, #"a"-"A"
        MEND

        MACRO
$label  LSL     $reg, $val, $cc
$label  MOV$cc  $reg, $reg, LSL #$val
        MEND

        MACRO
$label  LSR     $reg, $val, $cc
$label  MOV$cc  $reg, $reg, LSR #$val
        MEND

        MACRO
$label  MakeErrorBlock $name, $noalign
        ALIGN
$label
ErrorBlock_$name
        DCD     ErrorNumber_$name
        DCB     ErrorString_$name
        DCB     0
    [   "$noalign" = ""
        ALIGN
    ]
        MEND

;************************************************************
; This is used by CDFS in 'Test' to set up module entry points
;************************************************************
       MACRO
$label ModuleDescriptionHeader
$label
 DCD 0
 DCD initialisingcode - startofheader
 DCD finalisingcode - startofheader
 DCD servicecode - startofheader
 DCD title - startofheader
 DCD help - startofheader
 DCD KeywordTable - startofheader
 DCD CDFSSWIBaseNumber
 DCD CDFSSWIentry - startofheader
 DCD CDFStableofswinames - startofheader
 DCD 0                                   ; decoding code
; DCD 0                                   ; code for command
; DCD 1                                   ; information word
; DCD 0                                   ; syntax message
; DCD 0                                   ; help text
       MEND

;************************************************************

; ****************************************
; ***  Macro MULTIPLY - rc := ra * rb  ***
; ***       NB. ra, rb corrupt         ***
; ****************************************
        MACRO
$label  MULTIPLY $rc, $ra, $rb

    [ {FALSE}                  ; old boring one
$label  MOV     $rc, #0
01      MOVS    $ra, $ra, LSR #1
        ADDCS   $rc, $rc, $rb
        ADD     $rb, $rb, $rb
        BNE     %BT01
    |
$label  MUL     $rc, $rb, $ra ; sexy 2u version with regs in the right order
    ]
        MEND

; *******************************************************
; ***  Sweet FA macro to keep Tutu out of mischief !  ***
; *******************************************************
        MACRO
$label  NOP
;$label  MOVNV   R0, R0       ; according to Acorn cannot use 'NV' !!!!!!!
$label  MOV R0, R0
        MEND



; *******************************************************
; ***     Copies null terminated data ( strings )     ***
; ***     afterwards, $from -> end of from string     ***
; ***     afterwards, $to   -> end of to string       ***
; ***     afterwards, $temp  = 0                      ***

;       EXTREMELY SLOW !!!!!

; *******************************************************
;       MACRO
;$label NullTerminatedCopy $to, $from, $temp
;01
;$label LDRB $temp, [ $from ], #1
;       STRB $temp, [ $to ], #1
;       CMP $temp, #0
;       BNE %BT01
;       MEND


        MACRO
$label  Overlap $master, $slave
  [     "$label" = ""

        ^ :INDEX:$master, wp
$slave  # ?$master
  |
        ! 0, "You what?"
  ]
        MEND

; **********************************************************************
; ***  Disable IRQs, saving an old interrupt state indicator in R14  ***
; ***  NB This macro preserves the C and V flags                     ***
; **********************************************************************
        MACRO
$lab    PHPSEI  $register
  [     "$register" = ""
$lab    MOV     R14, #I_bit
        TST     R14, PC                 ; is I_bit set ?
        TEQEQP  R14, PC                 ; no, then set it (and R14 = I_bit)
        MOVNE   R14, #0                 ; yes, then leave alone (and R14=0)
  |
$lab    MOV     $register, #I_bit
        TST     $register, PC           ; is I_bit set ?
        TEQEQP  $register, PC           ; no, then set it (and $reg. = I_bit)
        MOVNE   $register, #0           ; yes, then leave alone (and R14=0)
  ]
        MEND

; ************************************************************************
; ***  Restore IRQ state from the indicator in R14 (set up by PHPSEI)  ***
; ***  NB This macro preserves the C and V flags                       ***
; ************************************************************************
        MACRO
$lab    PLP     $register
  [     "$register" = ""
$lab    TEQP    R14, PC
  |
$lab    TEQP    $register, PC
  ]
        MEND

; *****************************************
; ***  PULL registers given in reglist  ***
; *****************************************
        MACRO
$label  PULL    $reglist, $cond, $hat
$label  LDM$cond.FD R13!, {$reglist}$hat
        MEND

; *****************************************
; ***  PUSH registers given in reglist  ***
; *****************************************
        MACRO
$label  PUSH   $reglist, $cond
$label  STM$cond.FD R13!, {$reglist}
        MEND

        MACRO
$label  RETURNS $cond
$label  MOV$cond.S PC, lr
        MEND

        MACRO
$label  RTS  $cond
$label  MOV$cond PC, lr
        MEND

        MACRO
$label  ROR     $reg, $val, $cc
$label  MOV$cc  $reg, $reg, ROR #$val
        MEND

; **************************************************
; ***  Set and clear bits in PSR from the masks  ***
; ***  $set, $clr, using register $regtmp        ***
; **************************************************
        MACRO
$label  SCPSR   $set, $clr, $regtmp, $cond
$label  MOV$cond   $regtmp, PC
        ORR$cond   $regtmp, $regtmp, #($set) :OR: ($clr)
        TEQ$cond.P $regtmp, #$clr
        MEND

; ****************************************
; ***  Set carry flag - will set nzCv  ***
; ****************************************
        MACRO
$label  SEC     $cond
$label  CMP$cond PC, #0
        MEND

; ************************************************************************
; ***  Set bits in PSR from the mask in $bits, using register $regtmp  ***
; ************************************************************************
        MACRO
$label  SETPSR  $bits, $regtmp, $cond
$label  MOV$cond   $regtmp, PC
        ORR$cond   $regtmp, $regtmp, #$bits
        TEQ$cond.P $regtmp, #0
        MEND

;*******************************************
; This is used by CDFS in 'initialisation' 
;*******************************************
;       MACRO
;$label SetDiscHasChangedAllDrives
;$label ADD R7, R3, #:INDEX:sparecontrolblock
;       MOV R6, #0
;01
;       SWI XCD_DiscHasChanged
;       ADD R6, R6, #1
;       AND R2, R6, #2_111                ; R2 = device number
;       MOV R3, R6, ASR #3                ; R3 = card number
;       AND R3, R3, #2_11
;       MOV R4, R6, ASR #5                ; R4 = LUN
;       AND R4, R4, #2_11
;       STMIA R7, { R2, R3, R4 }
;       CMP R6, #2_1111111                ; If device =7,LUN=3,card=3 THEN end
;       BLE %BT01
;       MEND

;*******************************************
; This is used by CDFS in 'initialisation' 
;*******************************************
;       MACRO
;$label SetUpModuleAsFilingSystem
;$label MOV R0, #12                ; Reason code to add a filing system
;       ADRL R1, startofheader
;       ADRL R2, InformationBlock
;       SUB R2, R2, R1
;       LDR R3, [ R12 ]            ; Passed in R12 when call to filing system
;       MOV R4, R3
;       SWI XOS_FSControl
;       MEND

; *******************************************
; ***  Set overflow flag - will set NzcV  ***
; *******************************************
        MACRO
$label  SEV    $cond
$label  CMP$cond PC, #&80000000
        MEND

; ************************************************************
; ***  Macro for producing repetitive assembly for spaces  ***
; ************************************************************
;        MACRO
;$label  SpaceMacro $pointer, $temp
;$label
;counter SETA spacesize
;        WHILE counter > 0
;        STRB $temp, [ $pointer ], #1
;counter SETA counter - 1
;        WEND
;        MEND


        MACRO
$label  STASH   $reglist, $cond, $hat
$label  STM$cond.FD R13!, {$reglist}$hat
        MEND


        MACRO
$label  STASHALL $cond
$label  STASH "R0 - R12, R14", $cond
        STR$cond R13, stackreturn
        MEND

; *******************************
; ***  String immediate out.  ***
; *******************************
        MACRO
$label  STRIM   $string
        [ :LEN: "$string" = 1
$label  SWI     XOS_WriteI+"$string"
        |
$label  SWI     XOS_WriteS
        DCB     "$string", 0
        ALIGN
        ]
        MEND

; **********************************************
; ***  Macro STROSB - Store Osbyte variable  ***
; **********************************************
        MACRO
$label  STROSB  $reg, $var, $temp, $cond
$label  MOV$cond $temp, #0
        STR$cond.B $reg, [$temp, #OsbyteVars+$var-OSBYTEFirstVar]
        MEND

; *****************************************
; ***  Macro Swap - Swap two registers  ***
; *****************************************
        MACRO
$label  Swap    $ra, $rb, $cc
$label  EOR$cc  $ra, $ra, $rb
        EOR$cc  $rb, $ra, $rb
        EOR$cc  $ra, $ra, $rb
        MEND

; ***************************************************************************
; ***  Toggle bits in PSR from the mask in $bits, using register $regtmp  ***
; ***************************************************************************
        MACRO
$label  TOGPSR  $bits, $regtmp, $cond
$label  MOV$cond   $regtmp, PC
        TEQ$cond.P $regtmp, #$bits
        MEND

; ***********************************************************************
; ***  Uppercasing macro. Needs temp register; only uppercases a-z !  ***
; ***********************************************************************
        MACRO
$label  UpperCase $reg, $wrk
$label  CMP     $reg, #"a"
        RSBGES  $wrk, $reg, #"z"        ; inverse compare
        SUBGE   $reg, $reg, #"a"-"A"
        MEND

; **********************************************************
; ***  Macro VDWS - Point to our new VduDriverWorkSpace  ***
; **********************************************************
        MACRO
        VDWS    $reg
 [ AssemblingArthur :LOR: Module
        MOV     $reg, #VduDriverWorkSpace
 |
 ! 0, "This is a real waste if using Hdr.NewSpace"
        MOV     $reg, #(VduDriverWorkSpace :AND: &FF000000)
        ORR     $reg, $reg, #(VduDriverWorkSpace :AND: &00FF0000)
        ORR     $reg, $reg, #(VduDriverWorkSpace :AND: &0000FFFF)
 ]
        MEND


;********************************
; **** This waits for a key *****
;********************************
        MACRO
$label  WAITFORKEY
$label  STASH R0 - R2
        MOV R0, #122          ; OS_Byte 122 = keyboard scan
01
        SWI XOS_Byte
        CMP R1, #&FF          ; &FF = no key pressed
        BEQ %BT01
        GRAB R0 - R2
        MEND


; *******************************
; ***  Add word to workspace  ***
; *******************************
        MACRO
$label  Word    $value, $count
  [     ( ( :INDEX: @ ) :AND: 3 ) <> 0
        #       4 - ( ( :INDEX: @ ) :AND: 3 )
  ]
  [     "$label" = ""
    [   "$count" = ""
      [ "$value" = ""
      |
$value  #       4
      ]
    |
$value  #       ($count) * 4
    ]
  |
    [   "$value" = ""
$label  #       4
    |
$label  #       ($value) * 4
    ]
  ]
        MEND

; *************************
; ***  WriteLn a string ***
; *************************
        MACRO
$label  WRLN    $string
$label  SWI     XOS_WriteS
        DCB     "$string", 10,13, 0
        ALIGN
        MEND

; ****************************************************************************
; ***  |#| - macro for allocating workspace downwards rather than upwards  ***
; ****************************************************************************

        MACRO
$var    |#|     $bytes
 [ "$bytes" = ""
        !       1, "Syntax: [<variable>] |#| <bytes>"
        MEXIT
 ]
        #       -($bytes)
 [ "$var" <> ""
$var    #       $bytes          ; Declare correct size
        #       -($bytes)
 ]
        MEND


;        OPT OldOpt




        LTORG

        END
            