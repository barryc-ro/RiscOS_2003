/* swicode.c for CDManager module */


#include "main.h"
#include "swicode.h"
#include "asm.h"



DrivePtr drivelist = NULL;
DrivePtr currdrive = NULL;



/*
 * Converts MSF to LBA:
 *
 *   On entry, msf[0] = mins,  msf[1] = secs,  msf[2] = frames.
 */

static int msf_to_block (char *msf)
{
    return ((msf[0] * 60) + msf[1]) * 75 + msf[2] - 150;
}


#if debugging

/*
 * Auxiliary function to output error return details when debugging.
 */

static void output_error_info (char *allow, Error *err)
{
    int errnum = err->errnum;

    if ((errnum & 0xff) < 128)
        debug_output (allow, "errnum = %d\n", errnum & 0xff);
    else
        debug_output (allow, "errnum = %d: %s\n",
                             errnum & 0xff, err->errmess);

    return;
}

#else

static void output_error_info (char *allow, Error *err)
{
    return;
}

#endif


/*
 * Extracts module version information from the module header.
 *
 * On exit, *n is the version number (as, eg, 345), and *s addresses the
 *  version string (as, eg, "CDManager 3.45 (12 Jan 97)".
 *
 * If any problems arise, the version number and string are given as 0 and
 *  NULL respectively.
 */

static void get_version_info (int *n, char **s)
{
    char *ptr;
    int x, y;
    Error *err;

    /* zero results in case of error */
    *n = 0;
    *s = NULL;

    /* locate module's base address */
    err = _swix (OS_Module, I0|I1|O3, 18, "CDManager", (int) &ptr);

    if (!err)
    {
        /* make ptr address module's help string */
        ptr += *( (int *)(ptr + HELP_STRING_OFFSET) );
        *s = ptr;

        /* locate first control or space character */
        while (*ptr > 0x20)
            ptr++;

        /* skip over tabs or spaces */
        while (*ptr == 0x09 || *ptr == 0x20)
            ptr++;

        /* and expect to find a version number as dd.dd */
        sscanf (ptr, "%d.%d", &x, &y);
        *n = x * 100 + y;
    }

    return;
}


/*
 * This is called from the macro swicode_lookup_drive (drivenum) to look for
 *  the DriveRec for the given logical drive number; if none is found, the
 *  result is NULL.
 *
 * After a successful search, currdrive is updated so that the same drive
 *  will be located immediately next time the macro is called.
 */

DrivePtr swicode_find_drive (int drivenum)
{
    DrivePtr drive = drivelist;

    while (drive)
    {
        if (drive->drivenum == drivenum)
        {
            currdrive = drive;   /* to speed next look-up */
            break;
        }

        drive = drive->next;
    }

    return drive;
}


/*
 * This is called to add a new DriveRec to the list of registered drives,
 *  allocating the next available logical number to it.
 *
 * The drive's logical number is returned as result.
 */

static int swicode_add_drive (DrivePtr drive)
{
    /* is it to go at the front of the list? */
    if (drivelist == NULL || drivelist->drivenum > 0)
    {
        drive->next = drivelist;
        drivelist = drive;

        return 0;
    }

    /* otherwise, insert in correct position internally */
    {
        DrivePtr prevdrive = drivelist;

        while (TRUE)
        {
            DrivePtr nextdrive = prevdrive->next;

            if (nextdrive == NULL ||                            /* the end */
                nextdrive->drivenum > prevdrive->drivenum + 1)  /* a gap */
            {
                drive->next = nextdrive;
                prevdrive->next = drive;

                return prevdrive->drivenum + 1;
            }

            prevdrive = nextdrive;
        }
    }
}


/*
 * This is called to remove the given DriveRec from the list of registered
 *  drives.
 */

static void swicode_remove_drive (DrivePtr drive)
{
    if (drivelist == drive)          /* it's at the head of the list */
        drivelist = drive->next;

    else                             /* it's somewhere in the middle */
    {
        DrivePtr prevdrive = drivelist;

        /* find its predecessor */
        while (prevdrive->next != drive)
            prevdrive = prevdrive->next;

        /* and delink it */
        prevdrive->next = drive->next;
    }

    /* unset "current drive" if necessary */
    if (currdrive == drive)
        currdrive = NULL;

    return;
}


/*
 * Called from a driver to register the drive whose details are given in
 *  'dib'.
 *
 * On exit, 'version' is set to this module's version number * 100.
 */

static Error * swicode_register (DriveInfoPtr dib, int *version)
{
    DrivePtr drive;
    char *s;

DEBUG debug_output (T_REGISTER,
      "CDMgr_Registration: register %s (%s) supporting &%x, dib = &%x; ",
      dib->descr.model, dib->descr.firmware, dib->supported, (int) dib);

    /* set version number */
    get_version_info (version, &s);

    /* no action necessary if drive already registered */
    drive = drivelist;
    while (drive)
    {
        if (drive->dib == dib)
        {

DEBUG debug_output (T_REGISTER, "already registered as logical drive %d\n",
                                drive->drivenum);

            return NULL;
        }

        drive = drive->next;
    }

    /* allocate new drive record */
    drive = (DrivePtr) malloc (sizeof (DriveRec));
    if (drive == 0)
    {

DEBUG debug_output (T_REGISTER, "no space available to register drive\n");

        return msgs_make_error (ERR_NOMEM + PROG_ERR);
    }

    /* register drive in first free slot, and initialise other fields */
    drive->dib = dib;
    drive->drivenum = swicode_add_drive (drive);
    init_seq (drive);

DEBUG debug_output (T_REGISTER, "registered as logical drive %d\n",
                                drive->drivenum);

    return NULL;
}


/*
 * Called from a driver to deregister the drive whose details are given in
 *  'dib'.
 */

static Error * swicode_deregister (DriveInfoPtr dib)
{
    DrivePtr drive;

DEBUG debug_output (T_REGISTER, "De-register %s, dib = &%x; ",
                                dib->descr.model, (int) dib);

    /* locate the drive record */
    drive = drivelist;
    while (drive)
    {
        if (drive->dib == dib)
            break;

        drive = drive->next;
    }

    if (drive)
    {
        /* remove from registered list */
        swicode_remove_drive (drive);

DEBUG debug_output (T_REGISTER, "deregistered from logical number %d\n",
                                drive->drivenum);

        /* free drive record */
        free (drive);
    }
    else    /* no action if drive is not registered */
    {

DEBUG debug_output (T_REGISTER, "no registration found\n");

    }

    return NULL;
}


/*
 * Called to check that any track or session number explicitly requested by
 *  CDMgr_ReadTOC is in range.
 */

static Error * swicode_read_TOC_check_parameters
(
    DrivePtr drive,
    _kernel_swi_regs *r
)
{
    int trackreq = r->r[4];
    int sessionreq = r->r[5];

    if ((r->r[0] & READTOC_TRACKS_FLAG &&
         trackreq > 0 &&
         (trackreq < drive->firsttrack || trackreq > drive->lasttrack)) ||
        (r->r[0] & READTOC_SESSIONS_FLAG &&
         sessionreq > 0 &&
         (sessionreq < drive->firstsession || sessionreq > drive->lastsession)))
        return msgs_make_error (ERR_VALUEOUTOFRANGE + PROG_ERR);

    return NULL;
}


/*
 * This function reads the TOC from the drive.
 *
 * The size of the TOC, and details of the first and last track and session
 *  are cached in the DriveRec for the drive. If necessary, these values are
 *  updated.
 *
 * On exit *buff gives the address of the buffer containing the format 2 TOC;
 *  it is the caller's responsibility to free this buffer after use.
 */

static Error * swicode_read_TOC_from_drive (DrivePtr drive, char **buff)
{
    int size = drive->TOCsize;
    Error *err = NULL;
    char *TOCbuff;
    ReadTocRec p;

    /* determine size of TOC buffer */
    if (size == 0)
    {
        ReadToc2HdrRec tbuff;

        p.buff = (char *) &tbuff;
        p.len = sizeof (ReadToc2HdrRec);
        err = asm_call_driver (drive->dib, OP_READTOC, (int *) &p);
        if (err && (err->errnum & 0xff) != ERR_BUFFERTOOSMALL)
            return err;

        size = (tbuff.len1 << 8) + tbuff.len0 + 2;
    }

    /* allocate buffer */
    TOCbuff = malloc (size);
    if (TOCbuff == NULL)        /* no space left */
        return msgs_make_error (ERR_NOMEM + PROG_ERR);

    /* read TOC into buffer */
    p.buff = TOCbuff;
    p.len = size;
    err = asm_call_driver (drive->dib, OP_READTOC, (int *) &p);
    if (err)
    {
        free (TOCbuff);
        return err;
    }

    /* copy buffer address to *buff so that caller can free it */
    *buff = TOCbuff;

    /* update cached values if necessary */
    if (drive->TOCsize == 0)
    {
        ReadToc2HdrPtr hdr = (ReadToc2HdrPtr) TOCbuff;
        char *trk = (char *) (hdr + 1);
        char mintrack = 255;
        char maxtrack = 0;

        drive->TOCsize = size;
        drive->firstsession = hdr->firstsession;
        drive->lastsession = hdr->lastsession;

        /*
         * Scan TOC to find minimum and maximum real track numbers, being
         *  careful to avoid any multi-session track descriptors, and also
         *  those relating to "special" tracks &a0, &a1 etc.
         */

        while (trk < (TOCbuff + size))
        {
            if ((trk [READTOC_TD_ADRCTRL] & READTOC_ADR_MASK) ==
                                            READTOC_TD_NORMAL)
            {
                char track = bcd_to_bin (trk [READTOC_TD_POINT]);

                if (track < 100)
                {
                    if (track < mintrack)
                        mintrack = track;
                    if (track > maxtrack)
                        maxtrack = track;
                }
            }

            trk += TRACK_DESCRIPTOR_SIZE;
        }

        /* CD-I discs do not record details of any CDI tracks in the TOC */
        if (mintrack == 255)
            maxtrack = 254;

        drive->firsttrack = mintrack;
        drive->lasttrack = maxtrack;
    }

    return NULL;
}


/*
 * Called to implement CDMgr_ReadTOC with R3 = 0.
 *
 * On entry:
 *   r->r[0] = flags (return track info or not, return session info or not)
 *   r->r[4] = 0 => info for all tracks,  n>0 => just track n
 *   r->r[5] = 0 => info for all sessios, n>0 => just session n
 *
 * On exit:
 *   r->r[3] = size of buffer required
 */

static Error * swicode_get_TOC_size (DrivePtr drive, _kernel_swi_regs *r)
{
    int size = sizeof (ReadTocBuffHdrRec);
    int numtracks = 0;
    int numsessions = 0;
    char *TOCbuff = NULL;
    Error *err;

    /*
     * If the cached track count and session count information is invalid,
     *  and we need it to calculate the buffer size needed,
     *  then read the TOC from the drive to update these details.
     */

    if ( drive->TOCsize == 0 &&
         ((r->r[0] & READTOC_TRACKS_FLAG) && (r->r[4] == 0) ||
          (r->r[0] & READTOC_SESSIONS_FLAG) && (r->r[5] == 0)) )
    {
        err = swicode_read_TOC_from_drive (drive, &TOCbuff);
        if (err)
            return err;

        free (TOCbuff);     /* we don't need it anymore */
    }

    /* check parameters are in range */
    err = swicode_read_TOC_check_parameters (drive, r);
    if (err)
        return err;

    /* determine how many tracks-worth of information is requested */
    if (r->r[0] & READTOC_TRACKS_FLAG)
    {
        if (r->r[4] == 0)
            numtracks = drive->lasttrack - drive->firsttrack;

        /* add one for the track requested, and one for the following one */
        numtracks += 2;
    }

    /* determine how many sessions-worth of information is requested */
    if (r->r[0] & READTOC_SESSIONS_FLAG)
    {
        if (r->r[5] == 0)
            numsessions = drive->lastsession - drive->firstsession;
        numsessions++;
    }

    size += (numtracks * sizeof (ReadTocBuffTrackRec) +
             numsessions * sizeof (ReadTocBuffSessionRec));

    r->r[3] = size;

    return NULL;
}


/*
 * Called to implement CDMgr_ReadTOC with R3 != 0.
 *
 * On entry:
 *   r->r[0] = flags (return track info or not, return session info or not)
 *   r->r[3] = address of suitably-sized buffer
 *   r->r[4] = 0 => info for all tracks,  n>0 => just track n
 *   r->r[5] = 0 => info for all sessios, n>0 => just session n
 *
 * On exit:
 *   r->r[3] = address of TOC header
 *   r->r[4] = address of track information
 *   r->r[5] = address of session information
 */

static Error * swicode_get_TOC_details (DrivePtr drive, _kernel_swi_regs *r)
{
    char *TOCbuff;
    Error *err = swicode_read_TOC_from_drive (drive, &TOCbuff);

    /* check parameters are in range */
    if (!err)
        err = swicode_read_TOC_check_parameters (drive, r);

    if (!err)
    {
        ReadTocBuffHdrPtr hdr = (ReadTocBuffHdrPtr) r->r[3];
        ReadTocBuffTrackPtr trackv = (ReadTocBuffTrackPtr) (hdr + 1);
        ReadTocBuffSessionPtr sessionv = (ReadTocBuffSessionPtr) trackv;
        Bool trackinfo = r->r[0] & READTOC_TRACKS_FLAG;
        Bool sessioninfo = r->r[0] & READTOC_SESSIONS_FLAG;
        int trackreq = r->r[4];
        int sessionreq = r->r[5];
        char *td = TOCbuff + sizeof (ReadToc2HdrRec);
        int firsttrack = drive->firsttrack;
        int lasttrack = drive->lasttrack;
        int firstsession = drive->firstsession;
        int lastsession = drive->lastsession;

        /* work out address of any session records to be returned */
        if (sessioninfo && trackinfo)
        {
            int numtracks = 0;

            if (trackreq == 0)
                numtracks += lasttrack - firsttrack;
            numtracks += 2;

            sessionv = (ReadTocBuffSessionPtr) (trackv + numtracks);
        }

        /* fill in return addresses */
        r->r[3] = (int) hdr;
        r->r[4] = trackinfo ? (int) trackv : 0;
        r->r[5] = sessioninfo ? (int) sessionv : 0;

        /* copy across header information from cached details */
        if (firsttrack == 255)   /* no tracks present - eg CD-I */
        {
            hdr->firsttrack = 0;
            hdr->lasttrack = -1;
        }
        else
        {
            hdr->firsttrack = firsttrack;
            hdr->lasttrack = lasttrack;
        }
        hdr->firstsession = firstsession;
        hdr->lastsession = lastsession;

        /* scan TOC descriptors, transferring information requested */
        while (td < TOCbuff + drive->TOCsize)
        {
            /* only examine "normal" track descriptors (ADR = 1) */
            if ((td [READTOC_TD_ADRCTRL] & READTOC_ADR_MASK) ==
                                           READTOC_TD_NORMAL)
            {
                int session = td [READTOC_TD_SESSION];
                int point = td [READTOC_TD_POINT];

                /*
                 * POINT = &A0 for session n gives:
                 *   first track in session n (PMIN)
                 *   disc type for session n  (PSEC)
                 *
                 * We assume disc type for whole disc is that given in the
                 *  &A0 track descriptor for the last session.
                 */

                if (point == 0xa0)
                {
                    /* copy session info if required */
                    if (sessioninfo)
                    {
                        int i = 0;

                        if (sessionreq == 0)
                            i = session - firstsession;

                        if (sessionreq == 0 || sessionreq == session)
                            sessionv[i].firsttrack = td [READTOC_TD_PMIN];
                    }

                    /* note disc type from last session descriptor */
                    if (session == lastsession)
                        hdr->disctype = td [READTOC_TD_PSEC];
                }

                /*
                 * POINT = &A2 for session n gives the start position of
                 *  the lead-out area.
                 *
                 * We use this track descriptor for the last session to
                 *  determine the size of the disc.
                 */

                else if (point == 0xa2 && session == lastsession)
                    hdr->discsize = msf_to_block (td + READTOC_TD_PMIN);

                /*
                 * Copy any genuine track information required.
                 *
                 * Use POINT = &A2 as the track descriptor for the "track
                 *  after the last one".
                 */

                if (trackinfo)
                {
                    int track = bcd_to_bin (point);

                    if (track < 100 || point == 0xa2)
                    {
                        int i = 0;

                        if (point == 0xa2)
                            track = lasttrack + 1;

                        if (trackreq == 0)
                            i = track - firsttrack;
                        else if (track == trackreq + 1)
                            i = 1;

                        if (trackreq == 0 ||
                            track == trackreq ||
                            track == trackreq + 1)
                        {
                            trackv[i].startaddr =
                                    msf_to_block (td + READTOC_TD_PMIN);
                            trackv[i].audiomode = td [READTOC_TD_ADRCTRL] &
                                    READTOC_CTRL_MASK;
                        }
                    }
                }
            }

            td += TRACK_DESCRIPTOR_SIZE;
        }

        /* free the buffer */
        free (TOCbuff);
    }

    return err;
}


/*
 * Called to locate a track descriptor in the TOC.
 *
 * On entry:
 *    trk   -  is the track number (or -1 to locate the &a2 descriptor which
 *               gives the address of the lead-out area).
 *    buff  -  addresses the TOC
 *    top   -  the size of the TOC is (top - buff)
 *
 * The result is the address of the desired track descriptor (or zero if it
 *  does not exist).
 */

static char * swicode_find_track_descriptor (int trk, char *buff, char *top)
{
    ReadToc2HdrPtr hdr = (ReadToc2HdrPtr) buff;
    char *td = (char *) (hdr + 1);

    /* The descriptor for the lead-out area is identified by POINT = &a2 */
    if (trk < 0)
        trk = bcd_to_bin (0xa2);

    while (td < top)
    {
        if (bcd_to_bin (td [READTOC_TD_POINT]) == trk &&
           (td [READTOC_TD_ADRCTRL] & READTOC_ADR_MASK) == READTOC_TD_NORMAL)
                return td;

        td += TRACK_DESCRIPTOR_SIZE;
    }

    return NULL;
}


/*
 * Called to implement CDMgr_AudioOp, PlayTracks, by converting track numbers
 *  into addresses using the TOC.
 */

static Error * swicode_play_tracks
(
    DrivePtr drive,
    int starttrack,
    int endtrack
)
{
    char *buff = NULL;
    char *top;           /* addresses byte beyond end of buffer */
    Error *err;
    char *td;
    PlayRec p;

    /* read the TOC from the drive */
    err = swicode_read_TOC_from_drive (drive, &buff);
    if (err)
        goto ret;

    top = buff + drive->TOCsize;

    /* if necessary, find first audio track */
    if (starttrack == PLAY_DEFAULT)
    {
        ReadToc2HdrPtr hdr = (ReadToc2HdrPtr) buff;
        char *td = (char *) (hdr + 1);

        starttrack = 255;
        while (td < top)
        {
            if ((td [READTOC_TD_ADRCTRL] & READTOC_ADR_MASK) ==
                                                      READTOC_TD_NORMAL)
            {
                char track = bcd_to_bin (td [READTOC_TD_POINT]);

                if (track < 100 &&
                    !(td [READTOC_TD_ADRCTRL] & READTOC_DATA_FLAG) &&
                    track < starttrack)
                        starttrack = track;
            }

            td += TRACK_DESCRIPTOR_SIZE;
        }

        if (starttrack == 255)   /* no audio tracks */
            goto rangeerror;
    }

    /* check or force range limits on requested tracks */
    if (starttrack < drive->firsttrack || starttrack > drive->lasttrack)
        goto rangeerror;
    if (endtrack < starttrack || endtrack >= drive->lasttrack)
        endtrack = PLAY_DEFAULT;
    else
        endtrack++;

    /* check start track is an audio track */
    td = swicode_find_track_descriptor (starttrack, buff, top);
    if (td [READTOC_TD_ADRCTRL] & READTOC_DATA_FLAG)
        goto rangeerror;

    /* get addresses */
    p.startaddr = (td [READTOC_TD_PMIN] * 60 + td [READTOC_TD_PSEC]) * 75 +
                   td [READTOC_TD_PFRM];

    if (starttrack == drive->firsttrack && p.startaddr <= 150) {
      p.startaddr = 0;
    } else {
      p.startaddr -= 150;
    }

    td = swicode_find_track_descriptor (endtrack, buff, top);
    p.stopaddr = (td [READTOC_TD_PMIN] * 60 + td [READTOC_TD_PSEC]) * 75 +
                  td [READTOC_TD_PFRM] - 150 - 1;

    /* and play! */
    err = asm_call_driver (drive->dib, OP_PLAY, (int *) &p);


  ret:
    /* don't forget to free the TOC buffer */
    free (buff);

    return err;


  rangeerror:
    err = msgs_make_error (ERR_TRACKOUTOFRANGE + PROG_ERR);
    goto ret;
}


/*
 * Called to execute the given SWI/reason code combination.
 *
 * On entry, the drive and disc (as required) have been validated.
 */

Error * swicode_execute
(
    DrivePtr drive,
    int swinum,
    int rc,
    _kernel_swi_regs *r
)
{
    Error *err = NULL;

    switch (swinum)
    {
    case SWI_VERSION:

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_Version: flags = &%x\n", r->r[0]);

        get_version_info (&r->r[0], (char **) &r->r[1]);

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_Version: returns R0 = %d, R1 = '%s'\n",
      r->r[0], (char *) r->r[1]);

        return NULL;


    case SWI_GETSUPPORTED:

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_GetSupported: flags = &%x, drive = %d\n", r->r[0], r->r[1]);

        r->r[0] = drive->dib->supported;

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_GetSupported: returns R0 = &%x\n", r->r[0]);

        return NULL;


    case SWI_READTOC:

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_ReadTOC: flags = &%x, drive = %d, seq = %d, buff = %d, track = %d, session = %d\n",
      r->r[0], r->r[1], r->r[2], r->r[3], r->r[4], r->r[5]);

        if (r->r[3] == 0)   /* work out buffer size required */
            err = swicode_get_TOC_size (drive, r);
        else                /* read TOC details - assume buffer ok */
            err = swicode_get_TOC_details (drive, r);

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_ReadTOC: returns R3 = %d, R4 = %d, R5 = %d\n",
      r->r[3], r->r[4], r->r[5]);

        return err;


    case SWI_DRIVEOP:

DEBUG debug_output (T_SWIDETAILS, "CDMgr_DriveOp, ");

        switch (rc)
        {
        case RC_GETSEQUENCENUMBER:

DEBUG debug_output (T_SWIDETAILS,
      "GetSequenceNumber: flags = &%x, drive = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1]);

            err = asm_call_driver (drive->dib, OP_DRIVESTATUS, NULL);
            if (err)
            {
                char errnum = err->errnum;   /* bottom byte only */

                if (errnum == ERR_DISCCHANGED)
                {
                    update_seq (drive);
                    err = NULL;
                }
            }

            if (!err)
                r->r[0] = drive->seq;

DEBUG
{
    debug_output (T_SWIDETAILS, "  GetSequenceNumber: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "R0 = %d\n", r->r[0]);
}

            return err;


        case RC_GETPHYSICALLOCATION:

DEBUG debug_output (T_SWIDETAILS,
      "GetPhysicalLocation: flags = &%x, drive = %d, buff = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1], r->r[2]);

            if (r->r[2] == 0)         /* return buffer size required */
            {
                r->r[2] = strlen (drive->dib->descr.majoraddress) +
                          strlen (drive->dib->descr.interfacetype) +
                          strlen (drive->dib->descr.minoraddress) +
                          strlen (drive->dib->descr.model) +
                          strlen (drive->dib->descr.firmware) +
                          5;
            }

            else                      /* copy strings to buffer */
            {
                strcpy ((char *) r->r[2], drive->dib->descr.majoraddress);
                r->r[3] = r->r[2]+strlen(drive->dib->descr.majoraddress)+1;
                strcpy ((char *) r->r[3], drive->dib->descr.interfacetype);
                r->r[4] = r->r[3]+strlen(drive->dib->descr.interfacetype)+1;
                strcpy ((char *) r->r[4], drive->dib->descr.minoraddress);
                r->r[5] = r->r[4]+strlen(drive->dib->descr.minoraddress)+1;
                strcpy ((char *) r->r[5], drive->dib->descr.model);
                r->r[6] = r->r[5]+strlen(drive->dib->descr.model)+1;
                strcpy ((char *) r->r[6], drive->dib->descr.firmware);
            }

DEBUG
{
    debug_output (T_SWIDETAILS, "  GetPhysicalLocation: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
    {
        if (r->r[2] < 500)  /* assume not a string in this case */
        {
            debug_output (T_SWIDETAILS, "R2 = %d\n", r->r[2]);
        }
        else
        {
            debug_output (T_SWIDETAILS,
                  "R2 = '%s', R3 = '%s', R4 = '%s', R5 = '%s', R6 = '%s'\n",
                  (char *) r->r[2], (char *) r->r[3], (char *) r->r[4],
                  (char *) r->r[5], (char *) r->r[6]);
        }
    }
}

            return NULL;


        case RC_DRIVESTATUS:

DEBUG debug_output (T_SWIDETAILS,
      "DriveStatus: flags = &%x, drive = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1]);

            err = asm_call_driver (drive->dib, OP_DRIVESTATUS, NULL);

            if (err)
            {
                char errnum = err->errnum;   /* bottom byte only */

                /* "Disc changed" error will update seq and retry */
                if (errnum != ERR_DISCCHANGED)
                {
                    r->r[0] = (errnum == ERR_DRIVEEMPTY) ? STATUS_EMPTY :
                              (errnum == ERR_DRIVEBUSY)  ? STATUS_READYING :
                              STATUS_NOTREADY;
                    err = NULL;
                }
            }
            else
            {
                r->r[0] = STATUS_GOOD;
            }

DEBUG
{
    debug_output (T_SWIDETAILS, "  DriveStatus: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "R0 = %d\n", r->r[0]);
}

            return err;


        case RC_GETDRIVESPEED:
            {
                GetDriveSpeedRec p;

DEBUG debug_output (T_SWIDETAILS,
      "GetDriveSpeed: flags = &%x, drive = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1]);

                err = asm_call_driver (drive->dib, OP_GETDRIVESPEED,
                                       (int *) &p);

                if (!err)
                {
                    if (r->r[0] & DRIVESPEED_RAW_FLAG)
                    {
                        r->r[2] = p.currspeed;
                        r->r[3] = p.minspeed;
                        r->r[4] = p.maxspeed;
                    }
                    else
                    {
                        r->r[2] = raw_to_percent (p.currspeed, p.maxspeed);
                        r->r[3] = raw_to_percent (p.minspeed, p.maxspeed);
                        r->r[4] = 100;
                    }
                }

DEBUG
{
    debug_output (T_SWIDETAILS, "  GetDriveSpeed: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "R2 = %d, R3 = %d, R4 = %d\n",
                      r->r[2], r->r[3], r->r[4]);
}

                return err;
            }


        case RC_SETDRIVESPEED:
            {
                SetDriveSpeedRec p1;
                GetDriveSpeedRec p2;

DEBUG debug_output (T_SWIDETAILS,
      "SetDriveSpeed: flags = &%x, drive = %d, speed = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1], r->r[2]);

                if (r->r[0] & DRIVESPEED_RAW_FLAG)
                {
                    p1.speed = r->r[2];
                }
                else
                {
                    err = asm_call_driver (drive->dib, OP_GETDRIVESPEED,
                                           (int *) &p2);
                    if (!err)
                        p1.speed = percent_to_raw (r->r[2], p2.maxspeed);
                }

                if (!err)
                    err = asm_call_driver (drive->dib, OP_SETDRIVESPEED,
                                           (int *) &p1);

                if (!err)
                    err = asm_call_driver (drive->dib, OP_GETDRIVESPEED,
                                           (int *) &p2);

                if (!err)
                {
                    if (r->r[0] & DRIVESPEED_RAW_FLAG)
                        r->r[2] = p2.currspeed;
                    else
                        r->r[2] = raw_to_percent (p2.currspeed, p2.maxspeed);
                }

DEBUG
{
    debug_output (T_SWIDETAILS, "  SetDriveSpeed: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

                return err;
            }


        case RC_GETVOLUME:
            {
                VolumeRec p;

DEBUG debug_output (T_SWIDETAILS,
      "GetVolume: flags = &%x, drive = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1]);

                err = asm_call_driver (drive->dib, OP_GETVOLUME, (int *) &p);
                if (!err)
                {
                    r->r[2] = p.left;
                    r->r[3] = p.right;
                }

DEBUG
{
    debug_output (T_SWIDETAILS, "  GetVolume: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "R2 = %d, R3 = %d\n",
                      r->r[2], r->r[3]);
}

                return err;
            }


        case RC_SETVOLUME:
            {
                VolumeRec p;

DEBUG debug_output (T_SWIDETAILS,
      "SetVolume: flags = &%x, drive = %d, left = %d, right = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1], r->r[2], r->r[3]);

                p.left = r->r[2];
                p.right = (r->r[0] & VOLUME_STEREO_FLAG) ? r->r[3] : p.left;
                err = asm_call_driver (drive->dib, OP_SETVOLUME, (int *) &p);

DEBUG
{
    debug_output (T_SWIDETAILS, "  SetVolume: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

                return err;
            }


        case RC_OPENDRAWER:

DEBUG debug_output (T_SWIDETAILS,
      "OpenDrawer: flags = &%x, drive = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1]);

            err = asm_call_driver (drive->dib, OP_OPENDRAWER, NULL);

DEBUG
{
    debug_output (T_SWIDETAILS, "  OpenDrawer: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

            return err;


        case RC_CLOSEDRAWER:

DEBUG debug_output (T_SWIDETAILS,
      "CloseDrawer: flags = &%x, drive = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1]);

            err = asm_call_driver (drive->dib, OP_CLOSEDRAWER, NULL);

DEBUG
{
    debug_output (T_SWIDETAILS, "  CloseDrawer: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

            return err;


        case RC_GETLOCKEDSTATUS:
            {
                GetLockedStatusRec p;

DEBUG debug_output (T_SWIDETAILS,
      "GetLockedStatus: flags = &%x, drive = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1]);

                err = asm_call_driver (drive->dib, OP_GETLOCKEDSTATUS,
                                       (int *) &p);
                if (!err)
                    r->r[0] = p.locked;

DEBUG
{
    debug_output (T_SWIDETAILS, "  GetLockedStatus: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "R0 = %d\n", r->r[0]);
}

                return err;
            }


        case RC_LOCKDRIVE:

DEBUG debug_output (T_SWIDETAILS,
      "LockDrive: flags = &%x, drive = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1]);

            err = asm_call_driver (drive->dib, OP_LOCKDRIVE, NULL);

DEBUG
{
    debug_output (T_SWIDETAILS, "  LockDrive: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

            return err;


        case RC_UNLOCKDRIVE:

DEBUG debug_output (T_SWIDETAILS,
      "UnlockDrive: flags = &%x, drive = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1]);

            err = asm_call_driver (drive->dib, OP_UNLOCKDRIVE, NULL);

DEBUG
{
    debug_output (T_SWIDETAILS, "  UnlockDrive: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

            return err;


        case RC_ENUMERATEDRIVES:

DEBUG debug_output (T_SWIDETAILS,
      "EnumerateDrives: flags = &%x\n", r->r[0] & ~SWI_RC_MASK);

            /* ask drivers to register their drives */
            _swix (OS_ServiceCall, I0|I1,
                                   drivelist == 0 ? ALL_DRIVES : NEW_DRIVES,
                                   Service_CDNewDrivePoll);

            /* determine maximum logical drive number */
            {
                DrivePtr drive = drivelist;
                int n = -1;

                while (drive)
                {
                    n = drive->drivenum;
                    drive = drive->next;
                }

                r->r[0] = n;
            }

DEBUG debug_output (T_SWIDETAILS,
      "  EnumerateDrives: returns R0 = %d\n", r->r[0]);

            return NULL;


        case RC_BUSYTIMEOUT:

DEBUG debug_output (T_SWIDETAILS,
      "BusyTimeOut: flags = &%x, drive = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1]);

            r->r[0] = drive->dib->timeout;

DEBUG debug_output (T_SWIDETAILS,
      "  BusyTimeOut: returns R0 = %d\n", r->r[0]);

            return NULL;
        }
        break;


    case SWI_READDATA:

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_ReadData: flags = &%x, drive = %d, seq = %d\n",
      r->r[0] & ~SWI_RC_MASK, r->r[1], r->r[2]);

#if DRIVEFLAGS_CONTINUOUS == READ_CONTINUOUS_FLAG
        if (drive->flags & r->r[0] & READ_CONTINUOUS_FLAG)
#else
        if (!(drive->flags & DRIVEFLAGS_CONTINUOUS) ^ !(r->r[0] & READ_CONTINUOUS_FLAG))
#endif
        {
           SetReliabilityRec p;

           p.flags = (r->r[0] & READ_CONTINUOUS_FLAG) ? SETREL_CONTINUOUS : 0;

           err = asm_call_driver (drive->dib, OP_SETRELIABILITY, (int *) &p);
        }


        if (!err) switch (rc)
        {
        case RC_READUSERDATA:

DEBUG debug_output (T_SWIDETAILS,
      "  ReadUserData: buff = %d, sector = %d, numsectors = %d, type = %s\n",
      r->r[3], r->r[4], r->r[5],
      r->r[6] == READ_TYPE_ANY ? "Any" :
      r->r[6] == READ_TYPE_AUDIO ? "Audio" :
      r->r[6] == READ_TYPE_MODE1 ? "Mode 1" :
      r->r[6] == READ_TYPE_MODE2 ? "Mode 2" :
      r->r[6] == READ_TYPE_MODE2FORM1 ? "Mode 2 Form 1" :
      r->r[6] == READ_TYPE_MODE2FORM2 ? "Mode 2 Form 2" :
      r->r[6] == READ_TYPE_ISO9660 ? "ISO9660" : "**Unknown**");

            if (r->r[6] == READ_TYPE_ISO9660)       /* use READ2048 */
            {
                Read2048Rec p;

                p.addr = r->r[4];
                p.numsectors = r->r[5];
                p.buff = (char *) r->r[3];

                err = asm_call_driver (drive->dib, OP_READ2048, (int *) &p);

                if (!err)
                    r->r[0] = p.count;
            }

            else                                    /* use READ CD  */
            {
                ReadCDRec p;

                p.u.flags.type = r->r[6];
                p.u.flags.rawread = FALSE;
                p.addr = r->r[4];
                p.numsectors = r->r[5];
                p.buff = (char *) r->r[3];

                err = asm_call_driver (drive->dib, OP_READCD, (int *) &p);

                if (!err)
                    r->r[0] = p.u.count;
            }

DEBUG
{
    debug_output (T_SWIDETAILS, "  ReadUserData: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "R0 = %d\n", r->r[0]);
}

            return err;


        case RC_READRAWDATA:
            {
                ReadCDRec p;

DEBUG debug_output (T_SWIDETAILS,
      "  ReadRawData: buff = %d, sector = %d, numsectors = %d\n",
      r->r[3], r->r[4], r->r[5]);

                p.u.flags.type = READ_TYPE_ANY;
                p.u.flags.rawread = TRUE;
                p.addr = r->r[4];
                p.numsectors = r->r[5];
                p.buff = (char *) r->r[3];

                err = asm_call_driver (drive->dib, OP_READCD, (int *) &p);

DEBUG
{
    debug_output (T_SWIDETAILS, "  ReadRawData: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

                return err;
            }
        }
        break;


    case SWI_AUDIOOP:

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_AudioOp: flags = &%x, drive = %d, seq = %d: ",
      r->r[0] & ~SWI_RC_MASK, r->r[1], r->r[2]);

        switch (rc)
        {
        case RC_PLAYFROMADDRESS:
            {
                PlayRec p;

DEBUG debug_output (T_SWIDETAILS,
      "PlayFromAddress: from = %d, to = %d\n", r->r[3], r->r[4]);

                p.startaddr = (r->r[3] == PLAY_DEFAULT) ?
                                             PLAY_FROM_CURRENT_POS : r->r[3];
                p.stopaddr = r->r[4];
                err = asm_call_driver (drive->dib, OP_PLAY, (int *) &p);

DEBUG
{
    debug_output (T_SWIDETAILS, "  PlayFromAddress: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

                return err;
            }


        case RC_PLAYTRACKS:

DEBUG debug_output (T_SWIDETAILS,
      "PlayTracks: from = %d, to = %d\n", r->r[3], r->r[4]);

            err = swicode_play_tracks (drive, r->r[3], r->r[4]);

DEBUG
{
    debug_output (T_SWIDETAILS, "  PlayTracks: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

            return err;


        case RC_STOP:

DEBUG debug_output (T_SWIDETAILS, "Stop\n");

            err = asm_call_driver (drive->dib, OP_STOP, NULL);

DEBUG
{
    debug_output (T_SWIDETAILS, "  Stop: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

            return err;


        case RC_PAUSE:

DEBUG debug_output (T_SWIDETAILS, "Pause\n");

            err = asm_call_driver (drive->dib, OP_PAUSE, NULL);

DEBUG
{
    debug_output (T_SWIDETAILS, "  Pause: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

            return err;


        case RC_RESUME:

DEBUG debug_output (T_SWIDETAILS, "Resume\n");

            err = asm_call_driver (drive->dib, OP_RESUME, NULL);

DEBUG
{
    debug_output (T_SWIDETAILS, "  Resume: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

            return err;


        case RC_AUDIOSCANFORWARD:
            {
                AudioScanRec p;

DEBUG debug_output (T_SWIDETAILS, "AudioScanForward from = %d\n", r->r[3]);

                p.addr = r->r[3];
                err = asm_call_driver (drive->dib, OP_AUDIOSCANFORWARD,
                                       (int *) &p);

DEBUG
{
    debug_output (T_SWIDETAILS, "  AudioScanForward: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

                return err;
            }


        case RC_AUDIOSCANREVERSE:
            {
                AudioScanRec p;

DEBUG debug_output (T_SWIDETAILS, "AudioScanReverse from = %d\n", r->r[3]);

                p.addr = r->r[3];
                err = asm_call_driver (drive->dib, OP_AUDIOSCANREVERSE,
                                       (int *) &p);

DEBUG
{
    debug_output (T_SWIDETAILS, "  AudioScanReverse: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

                return err;
            }


        case RC_AUDIOSTATUS:
            {
                AudioStatusRec p;


DEBUG debug_output (T_SWIDETAILS, "AudioStatus\n");

                err = asm_call_driver (drive->dib, OP_AUDIOSTATUS,
                                       (int *) &p);
                if (!err)
                    r->r[0] = p.status;

DEBUG
{
    debug_output (T_SWIDETAILS, "  AudioStatus: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "R0 = %d\n", r->r[0]);
}

                return err;
            }
        }
        break;


    case SWI_CONVERTBLOCKTOMSF:
        {
            int hrs, mins, secs, frms;

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_ConvertBlockToMSF: flags = &%x, sector = %d\n",
      r->r[0], r->r[1]);

            frms = r->r[1] + 150;
            secs = frms / 75;
            frms %= 75;
            mins = secs / 60;
            secs %= 60;

            if (r->r[0] & CONVERT_TIMECODE_FORMAT)
            {
                hrs = mins / 60;
                mins %= 60;

                if (hrs > 63)
                    err = msgs_make_error (ERR_VALUEOUTOFRANGE + PROG_ERR);
                else
                    r->r[0] = to_timecode (hrs, mins, secs, frms);
            }
            else
            {
                r->r[0] = frms;
                r->r[1] = secs;
                r->r[2] = mins;
            }

DEBUG
{
    debug_output (T_SWIDETAILS, "CDMgr_ConvertBlockToMSF: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "R0 = %d (&%x), R1 = %d, R2 = %d\n",
                      r->r[0], r->r[0], r->r[1], r->r[2]);
}

            return err;
        }


    case SWI_CONVERTMSFTOBLOCK:

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_ConvertMSFToBlock: flags = &%x, R1 = %d (&%x), R2 = %d, R3 = %d\n",
      r->r[0], r->r[1], r->r[1], r->r[2], r->r[3]);

        if (r->r[0] & CONVERT_TIMECODE_FORMAT)
        {
            if (r->r[1] & EXTENDED_TIMECODE_FORMAT)
                err = msgs_make_error (ERR_BADTIMECODE + PROG_ERR);
            else
                r->r[0] = from_timecode (r->r[1]) - 150;
        }
        else
        {
            if ( (r->r[1] < 0) || (r->r[1] > 74) ||
                 (r->r[2] < 0) || (r->r[2] > 59) ||
                 (r->r[3] < 0) || (r->r[3] > 99) )
                err = msgs_make_error (ERR_VALUEOUTOFRANGE + PROG_ERR);
            else
                r->r[0] = ((r->r[3] * 60) + r->r[2]) * 75 + r->r[1] - 150;
        }

DEBUG
{
    debug_output (T_SWIDETAILS, "CDMgr_ConvertMSFToBlock: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "R0 = %d\n", r->r[0]);
}

        return err;


    case SWI_MISCOP:

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_MiscOp: flags = &%x, drive = %d, seq = %d: ",
      r->r[0] & ~SWI_RC_MASK, r->r[1], r->r[2]);

        switch (rc)
        {
        case RC_WHICHDISC:
            {
                char *TOCbuff;

DEBUG debug_output (T_SWIDETAILS, "WhichDisc\n");

                err = swicode_read_TOC_from_drive (drive, &TOCbuff);

                if (!err)
                {
                    ReadToc2HdrPtr p = (ReadToc2HdrPtr) TOCbuff;
                    int size = (p->len1 << 8) + p->len0 + 2;
                    unsigned chksum = 0;
                    int i;

                    for (i = 0; i < (size >> 2); i++)
                        chksum += ((int *) TOCbuff) [i];

                    /* don't forget to free the TOC buffer */
                    free (TOCbuff);

                    r->r[0] = chksum;
                }

DEBUG
{
    debug_output (T_SWIDETAILS, "  WhichDisc: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "R0 = %d\n", r->r[0]);
}

                return err;
            }


        case RC_GIVESECTORDATAMODE:
            {
                GiveSectorDataModeRec p;

DEBUG debug_output (T_SWIDETAILS,
      "GiveSectorDataMode: sector = %d\n", r->r[3]);

                p.u.addr = r->r[3];

                err = asm_call_driver (drive->dib, OP_GIVESECTORDATAMODE,
                                       (int *) &p);

                if (!err)
                    r->r[0] = p.u.mode;

DEBUG
{
    debug_output (T_SWIDETAILS, "  GiveSectorDataMode: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "R0 = %d\n", r->r[0]);
}

                return err;
            }


        case RC_SEEK:
            {
                SeekRec p;

DEBUG debug_output (T_SWIDETAILS, "Seek to %d\n", r->r[3]);

                p.addr = r->r[3];
                err = asm_call_driver (drive->dib, OP_SEEK, (int *) &p);

DEBUG
{
    debug_output (T_SWIDETAILS, "  Seek: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "OK\n");
}

                return err;
            }


        case RC_ADDRESS:
            {
                AddressRec p;

DEBUG debug_output (T_SWIDETAILS, "Address\n");

                err = asm_call_driver (drive->dib, OP_ADDRESS, (int *) &p);

                if (!err)
                {
                    r->r[0] = p.info.audiomode;
                    r->r[3] = p.addr;
                    r->r[4] = p.reladdr;
                    r->r[5] = p.info.track;
                    r->r[6] = p.info.index;
                }

DEBUG
{
    debug_output (T_SWIDETAILS, "  Address: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS,
              "R0 = &%x, R3 = %d, R4 = %d, R5 = %d, R6 = %d\n",
              r->r[0], r->r[3], r->r[4], r->r[5], r->r[6]);
}

                return err;
            }
        }
        break;


    case SWI_CALLDEVICEDRIVER:
        {
            int params[9];  /* for R0, R2, ... R9 */
            int i;

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_CallDeviceDriver: drive = %d, R0 = &%x, R2 = %d, R3 = %d, R4 = %d\n   R5 = %d, R6 = %d, R7 = %d, R8 = %d, R9 = %d\n",
      r->r[1], r->r[0], r->r[2], r->r[3], r->r[4],
      r->r[5], r->r[6], r->r[7], r->r[8], r->r[9]);

            params[0] = r->r[0];
            for (i = 2; i <= 9; i++)
                params[i-1] = r->r[i];

            err = asm_call_driver (drive->dib, OP_CALLDEVICEDRIVER, params);

            r->r[0] = params[0];
            for (i = 2; i <= 9; i++)
                r->r[i] = params[i-1];

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_CallDeviceDriver: returns R0 = %d, R2 = %d, R3 = %d, R4 = %d\n   R5 = %d, R6 = %d, R7 = %d, R8 = %d, R9 = %d\n",
      r->r[0], r->r[2], r->r[3], r->r[4],
      r->r[5], r->r[6], r->r[7], r->r[8], r->r[9]);

            return err;
        }


    case SWI_REGISTRATION:

DEBUG debug_output (T_SWIDETAILS,
      "CDMgr_Registration: flags = &%x, dib = &%x\n", r->r[0], r->r[1]);

        if (r->r[0] & BIT(0))
            err = swicode_deregister ((DriveInfoPtr) r->r[1]);
        else
            err = swicode_register ((DriveInfoPtr) r->r[1],
                                     (int *) &r->r[0]);

DEBUG
{
    debug_output (T_SWIDETAILS, "CDMgr_Registration: returns ");
    if (err)
        output_error_info (T_SWIDETAILS, err);
    else
        debug_output (T_SWIDETAILS, "R0 = %d\n", r->r[0]);
}

        return err;
    }


    return msgs_make_error (ERR_BADRC + PROG_ERR, rc, swinum + SWI_BASE);
}



#if ATAPITESTVERSION

/*
 * Issues the Service_CDNewDrivePoll service call with R0 = 'flags'.
 */

Error * swicode_polldrives (int flags)
{
    /* issue service call */
    _swix (OS_ServiceCall, I0|I1, flags, Service_CDNewDrivePoll);

    return NULL;
}


/*
 * Calls a driver entry point with operation code = 'opcode' and parameter
 *  block = 'params'. The driver entry point is found in the DriveInfoRec
 *  registered under the logical drive number 'drivenum'.
 *
 * Returns error +10 if no such drive is registered; otherwise returns any
 *  error returned from the driver, which is checked and looked up if
 *  necessary.
 */

Error * swicode_calldriver
(
    int flags,
    int drivenum,
    int opcode,
    int *params
)
{
    Error *err;
    DrivePtr drive;

    IGNORE (flags);   /* all reserved in this release */

    drive = swicode_lookup_drive (drivenum);
    if (!drive)
        return msgs_make_error (ERR_DRIVENOTKNOWN + PROG_ERR);

    /* call driver entry point using veneer code */
    err = asm_call_driver (drive->dib, opcode, params);

    /* translate error message if returned in CDManager range */
    if (err && (err->errnum & 0xff) < 128)
        return msgs_make_error ((err->errnum & 0xff) + PROG_ERR);

    return err;
}

#endif
