r0      RN      0
a1      RN      0
r1      RN      1
a2      RN      1
r2      RN      2
a3      RN      2
r3      RN      3
a4      RN      3

r4      RN      4
v1      RN      4
r5      RN      5
v2      RN      5
r6      RN      6
v3      RN      6
r7      RN      7
v4      RN      7
r8      RN      8
v5      RN      8
r9      RN      9
v6      RN      9

r10     RN     10
r11     RN     11
r12     RN     12
r13     RN     13

sl      RN     10
fp      RN     11
ip      RN     12
sp      RN     13
lr      RN     14
pc      RN     15

        AREA |C$$code|, CODE, READONLY


        EXPORT  asm_call_driver


; This is the veneer code which CDManager calls to enter a driver; it is
;  called as:
;
;     Error * asm_call_driver (
;       DriverInfoPtr dib,
;       int opcode,
;       int *params
;     );
;


; Driver Information Block Header

DIB_Entry        *  0
DIB_DriveId      *  4
DIB_Flags        *  8
DIB_Special      * 12


; On entry, the following registers are set up:
;
;   a1 = address of driver information block
;   a2 = opcode
;   a3 = params - the address of the parameter block
;

        ALIGN

asm_call_driver

    LDR     ip, [a1, #DIB_Flags]    ; choose appropriate veneer
    MOVS    ip, ip
    BEQ     C_Call


; Veneer to call Assembler driver

A_Call

    STR     lr, [sp, #-4]!         ; other regs preserved by caller or driver

    MOV     a4, a1
    LDR     a1, [a4, #DIB_DriveId] ; R0 = driveid
    LDR     ip, [a4, #DIB_Special] ; R12 = r12

    MOV     lr, pc                 ; Call driver entry point
    LDR     pc, [a4, #DIB_Entry]

    LDR     pc, [sp], #4           ; return


; Veneer to call C driver

C_Call

    STMFD   sp!, {v1, v2, lr}      ; other regs preserved by caller or driver

; Set up relocation offsets for driver module

    SUB     sl, sl, #540           ; sl now addresses base of supervsr stack

    LDMIA   sl, {v1, v2}           ; preserve reloc offsets for this module

    LDR     ip, [a1, #DIB_Special] ; ip = address of driver private word
    LDR     ip, [ip]               ; ip = address of driver workspace

    LDMIB   ip, {ip, lr}           ; load driver reloc offsets to ip, lr
    STMIA   sl, {ip, lr}           ; and store at base of supervisor stack

    ADD     sl, sl, #540           ; restore value of sl

    MOV     ip, a1
    LDR     a1, [ip, #DIB_DriveId] ; a1 = driveid; other params already set

    MOV     lr, pc                 ; Call driver C function
    LDR     pc, [ip, #DIB_Entry]

    SUB     sl, sl, #540           ; restore reloc offsets for this module
    STMIA   sl, {v1, v2}
    ADD     sl, sl, #540

    LDMFD   sp!, {v1, v2, pc}      ; restore and return


    END
