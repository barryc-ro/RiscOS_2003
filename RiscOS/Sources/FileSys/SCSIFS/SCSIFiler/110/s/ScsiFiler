; > Sources.SCSIFiler

;;----------------------------------------------------------------------------
;; SCSI Filer module
;;
;; Change List
;; -----------
;; 12-Jun-89     0.18    File created by modifying ADFSFiler version 0.18
;; 12-Jun-89     0.19    Check for zero drives - close down if so
;;                      (This also copes with SCSIFS not being present
;; 28-Jul-89     0.20    Display disc name under hard disc icons
;;               ----    Conditional version checking introduced
;; 31-Jul-89            If Wimp 2.21 or later, keep icons on left of bar
;;               0.21    When naming discs, keep icon in same place
;;  1-Sep-89     0.22    Use SCSIFS_TestReady before asking for name
;; 15-Apr-91     0.23    Use *ShowFree -FS SCSI <x> for showing free space.
;; 24-Jul-91     0.24    Detects RISC OS version for 'free'    
;; 09-Jan-92 amg 0.25    Hacked the desktop verify from adfsfiler 0.33 into here
;; 13-Jan-92 DDV         Bug fix: Loading templates under Wimp 2.00 and 2.05
;; 13-Jan-92 DDV         Bug fix: Greying menu items so multiple verify on the same device not possible
;; 16-Jan-92 DAR         Changed version number to 1.10 so all modules in SCSI Card at time of release have same version number.
;; 31-Jan-92 DDV         Added interactive help stuff for menu.
;; 01-Feb-92 DDV/DAR     Fixed (if only Mandy knew the truth) the verify bugs.
;; 01-Feb-92 DDV/DAR     Grey out all options when verifying.
;;
;;----------------------------------------------------------------------------

                GBLL    bodgedisc
bodgedisc       SETL    {TRUE}          ; needed for old FileCore modules


Module_BaseAddr

        GET     hdr:ListOpts
        GET     hdr:Macros
        GET     hdr:System
        GET     hdr:ModHand
        GET     hdr:FSNumbers
        GET     hdr:HighFSI
        GET     hdr:NewErrors
        GET     hdr:Wimp
        GET     hdr:WimpSpace
        GET     hdr:Messages
        GET     hdr:Sprite
        GET     hdr:VduExt
        GET     hdr:Proc
        GET     hdr:Services
        GET     hdr:SCSIFS

        GET     Version

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        GBLL    debug
debug   SETL    False

        GET     hdr:Debug
        GET     hdr:HostDebug

        GBLL    debugfo
debugfo SETL    False

        GBLL    debugfom
debugfom SETL   False        
  
                GBLL    debugtask
debugtask       SETL    debug :LAND: False


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Register names
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; sp            RN      r13             ; FD stack
; wp            RN      r12

scy             RN      r11
scx             RN      r10
y1              RN      r9
x1              RN      r8
y0              RN      r7
x0              RN      r6
cy1             RN      r5              ; Order important for LDMIA
cx1             RN      r4
cy0             RN      r3
cx0             RN      r2

; r0,r1 not named

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Macro definitions
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        MACRO
        max     $a, $b
        CMP     $a, $b
        MOVLT   $a, $b
        MEND

        MACRO
        min     $a, $b
        CMP     $a, $b
        MOVGT   $a, $b
        MEND

        MACRO
$label  FixDCB  $n, $string
        ASSERT  ((:LEN:"$string")<$n)
$label  DCB     "$string"
        LCLA    cnt
cnt     SETA    $n-:LEN:"$string"
        WHILE   cnt>0
        DCB     0
cnt     SETA    cnt-1
        WEND
        MEND

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Constants
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

TAB     *       9
LF      *       10
CR      *       13
space   *       32
delete  *       127


bignum          *       &0FFFFFFF

initbrx         *       100
initbry         *       1024-80

brxoffset       *       64
bryoffset       *       64

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data structure offsets
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; format of icon description blocks

                ^       -1
icb_validation  #       1               ; "S" for validation string
icb_drivetype   #       12              ; first byte is "h" or "f"
icb_drivenumber #       3               ; ":n",0

; format of disc name blocks (fixed size, held in main workspace)

                ^       0
drv_number      #       3               ; ":n",0
drv_namelen     #       1               ; length of ":discname"
drv_iconblock   #       4
drv_name        #       24              ; "discname",0
drv_size        #       0
drv_shift       *       5
        ASSERT  drv_size = (1 :SHL: drv_shift)
        ASSERT  (drv_iconblock :AND: 3) = 0

len_colon       *       0               ; don't include ":" in discname
len_mediaprefix *       :LEN:"SCSI::"-len_colon

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Workspace allocation
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                ^       0, wp
mytaskhandle    #       4               ; id so we can kill ourselves
FilerHandle     #       4               ; id so we can contact Filer
privateword     #       4
mywimpversion   #       4               ; another wimp version
        [ Version >= 21
wimpversion     #       4
        ]
        [ Version >= 22
monotonictime   #       4
        ]

mousedata       #       0
mousex          #       4
mousey          #       4
buttonstate     #       4
windowhandle    #       4
iconhandle      #       4

menuhandle      #       4
menudir         #       4
menufileblock   #       4
menufilename    #       4

windowx         #       4
windowy         #       4

relmousex       #       4
relmousey       #       4

ndrives         *       4                ; allow for drives 4..7
iconbaricons    #       ndrives*4        ; associate icon handle with index
discnames       #       ndrives*drv_size ; associate index with drive spec.

matchedindex    #       4               ; index of last icon matched

ram_menustart   #       0
m_floppydisc    #       m_headersize + mi_size*6
m_format        #       m_headersize + mi_size*3
m_namedisc      #       m_headersize + mi_size*1
ram_menuend     #       0

mb_namedisc     #       12              ; aligned, with room for terminator

nfloppies       #       4
oldescape       #       4

        [ Version >= 25
FormatState             #       4
FormatList              #       4
FormatWindows           #       4
FormatMenu              #       4
SWICode                 #       16
MaxFormatBarLength      #       4
DiscRecord              #       &100
formattemplate          #       &160
 
 AlignSpace 64
        ]

dirnamebuffer   #       &100

userdata        #       &100

stackbot        #       &200
stacktop        #       0

SCSIFiler_WorkspaceSize *  :INDEX: @

 ! 0, "SCSIFiler workspace is ":CC:(:STR:(:INDEX:@)):CC:" bytes"


driveno *       m_floppydisc + m_title + :LEN:"SCSI:"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Module header
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        LEADR   Module_LoadAddr

 ASSERT (.=Module_BaseAddr)

        DCD     SCSIFiler_Start        -Module_BaseAddr
        DCD     0 ; SCSIFiler_Init     -Module_BaseAddr
        DCD     SCSIFiler_Die          -Module_BaseAddr
        DCD     SCSIFiler_Service      -Module_BaseAddr
        DCD     SCSIFiler_TitleString  -Module_BaseAddr
        DCD     SCSIFiler_HelpString   -Module_BaseAddr
        DCD     SCSIFiler_CommandTable -Module_BaseAddr


SCSIFiler_HelpString
        DCB     "SCSIFiler"
        DCB     TAB
        DCB     "$VString ($Date)", 0

Desktop_SCSIFiler_Help
        DCB   "The SCSIFiler provides the SCSI icons on the icon bar, and "
        DCB   "uses the Filer to display SCSI directories.",13,10
        DCB   "Do not use *Desktop_SCSIFiler, use *Desktop instead.",0

Desktop_SCSIFiler_Syntax  DCB   "Syntax: *Desktop_"       ; drop through!

SCSIFiler_TitleString     DCB   "SCSIFiler", 0
SCSIFiler_Banner          DCB   "SCSI Filer", 0
                          ALIGN

SCSIFiler_CommandTable      ; Name     Max min

SCSIFiler_StarCommand
        Command Desktop_SCSIFiler,     0, 0

        DCB     0                       ; End of table
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Had *command to enter SCSIFiler, so start up via module handler

Desktop_SCSIFiler_Code ENTRY

        LDR     r14, [r12]
        CMP     r14, #0
        BLE     %FT01

        LDR     r14, [r14, #:INDEX:mytaskhandle]
        CMP     r14, #0
        MOVEQ   r0, #ModHandReason_Enter
        ADREQ   r1, SCSIFiler_TitleString
        SWIEQ   XOS_Module
01
        ADR     r0, ErrorBlock_CantStartSCSIFiler
        SETV
        EXIT

ErrorBlock_CantStartSCSIFiler
        DCD     0
        DCB     "Use *Desktop to start SCSIFiler", 0
        ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SCSIFiler_Service ROUT

        TEQ     r1, #Service_Reset
        BEQ     SCSIFiler_Service_Reset

        TEQ     r1, #Service_FilerDying
        BEQ     SCSIFiler_Service_FilerDying

        TEQ     r1, #Service_StartFiler
        BEQ     SCSIFiler_Service_StartFiler

        TEQ     r1, #Service_StartedFiler
        MOVNE   pc, lr


SCSIFiler_Service_StartedFiler ENTRY

        LDR     r14, [r12]              ; cancel 'don't start' flag
        CMP     r14, #0
        MOVLT   r14, #0
        STRLT   r14, [r12]

        EXIT


SCSIFiler_Service_StartFiler ENTRY "r2,r3,r6"

        LDR     r2, [r12]
        CMP     r2, #0
        EXIT    NE                      ; don't claim service unless = 0

        MOV     r6, r0                  ; Filer task handle
        MOV     r0, #ModHandReason_Claim
        LDR     r3, =SCSIFiler_WorkspaceSize
        SWI     XOS_Module
        MOVVS   r2, #-1                 ; avoid looping
        STR     r2, [r12]

        MOVVC   r0, #0
        
      [ Version >= 25
        STRVC   r0, [r2, #:INDEX:FormatList]
        STRVC   r0, [r2, #:INDEX:FormatState]
        STRVC   r0, [r2, #:INDEX:FormatWindows]
      ]
              
        STRVC   r0, [r2, #:INDEX:mytaskhandle]
        STRVC   r12, [r2, #:INDEX:privateword]
        STRVC   r6, [r2, #:INDEX:FilerHandle]
        ADRVCL  r0, SCSIFiler_StarCommand
        MOVVC   r1, #0                  ; Claim service

        EXIT


SCSIFiler_Service_Reset ENTRY "r0-r6"

        LDR     r2, [r12]               ; cancel 'don't start' flag
        CMP     r2, #0
        MOVLT   r2, #0
        STRLT   r2, [r12]

        MOVGT   wp, r2
        MOVGT   r0, #0                  ; Wimp has already gone bye-bye
        STRGT   r0, mytaskhandle
        BLGT    freeworkspace

        EXITS                           ; Sorry, but no can do errors here


SCSIFiler_Die ROUT

SCSIFiler_Service_FilerDying ENTRY "r0-r6"

        LDR     wp, [r12]
        BL      freeworkspace

        EXITS                           ; Sorry, but no can do errors here

; ******************************************************************************

      [ Version >= 25
        ALIGN
w_format        DCB     "Format",0
                DCD     0,0,0
      ]

; ******************************************************************************


; Corrupts r0-r6

freeworkspace ROUT

        CMP     wp, #0                  ; clears V
        MOVLE   pc, lr

        MOV     r6, lr                  ; can't use stack on exit if USR mode

        LDR     r0, mytaskhandle
        CMP     r0, #0
        LDRGT   r1, taskidentifier
        SWIGT   XWimp_CloseDown         ; ignore errors from this

        MOV     r2, r12
        LDR     r12, privateword
        MOV     r14, #0                 ; reset flag word anyway
        STR     r14, [r12]
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module

        MOV     pc, r6

taskidentifier
        DCB     "TASK"                  ; Picked up as a word
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


CloseDownAndExit ROUT

        BL      freeworkspace
        SWI     OS_Exit

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;                   SCSIFiler application entry point
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ErrorAbort
        MOV     r1, #2_010              ; 'Cancel' button
        BL      ReportError             ; stack is still valid here

Abort
        BL      freeworkspace           ; exits with r12 --> private word
        MOV     r0, #-1
        STR     r0, [r12]               ; marked so doesn't loop

        SWI     OS_Exit
                 
message & Message_HelpRequest
        & 0
        ALIGN

SCSIFiler_Start ROUT

        LDR     wp, [r12]

        CMP     wp, #0
        ADRLE   r0, ErrorBlock_CantStartSCSIFiler
        SWILE   OS_GenerateError

        ADRL    sp, stacktop            ; STACK IS NOW VALID!

        LDR     r0, mytaskhandle        ; close any previous incarnation
        CMP     r0, #0
        LDRGT   r1, taskidentifier
        SWIGT   XWimp_CloseDown         ; ignore errors from this
                     
        ;got to keep this at 200 so it continues to work with RISC OS 2!   
        MOV     r0, #300                ; latest known Wimp version number
        LDR     r1, taskidentifier
        ADRL    r2, SCSIFiler_Banner
        ADR     r3, message             ; -> message list
        SWI     XWimp_Initialise
        STR     r0,mywimpversion        ; store this for RISC OS 3 test
      [ Version >= 21
        STRVC   r0, wimpversion
      ]
        STRVC   r1, mytaskhandle

        BLVC    CopyMenus               ; copy menus into ram
        BVS     ErrorAbort

        ADR     r1, iconbaricons        ; initialise all icon handles to -1
        MOV     r2, #ndrives            ; (used in AddToIconBar)
        MOV     r14, #-1
01      STR     r14, [r1], #4
        SUBS    r2, r2, #1
        BNE     %BT01

        BL      SetUpIconBar
      [ Version >= 22
        SWIVC   XOS_ReadMonotonicTime
        STRVC   r0, monotonictime
      ]
        BVS     ErrorAbort              ; frees workspace but marks it invalid

        LDR     R14,iconbaricons        ; give up if no drives (or error)
        CMP     R14,#-1
        BEQ     Abort
 
      [ Version >= 25                   ; Load templates.
        LDR     R1,mywimpversion
        CMP     R1,#205                 
        BLE     %FT01                   ; Not if running under 2.00 or 2.05 (A1 and Fox releases!)
      [ debug
        SWI     XOS_WriteS
        =       "Bollocks!!!!",13,10,0
      ]

        ADRL    R1,str_templatefile
        SWI     XWimp_OpenTemplate
        BVS     ErrorAbort

        ADRL    r1,formattemplate
        ADRL    r2,userdata
        ADD     r3,r2,#?userdata
        MOV     r4,#-1
        ADR     r5,w_format
        MOV     r6,#0
        SWI     XWimp_LoadTemplate
        BVS     TemplateErrorAbort

; get max size of bar, and mark bar as deleted.

        ADRL    r1,formattemplate+w_icons
        ADD     r1,r1,#3*i_size         ; Third icon is bar.

        LDR     r0,[r1,#i_bbx0]         ; Icon's x0
        LDR     r2,[r1,#i_bbx1]         ; Icon's x1
        SUB     r2,r2,r0
        STR     r2,MaxFormatBarLength
       [ debug
        dreg    r2,"Max format bar length is "
       ]
        SWI     XWimp_CloseTemplate
        BVS     ErrorAbort  
        B       %FT01

TemplateErrorAbort
           
        Push    "r0"
        SWI     XWimp_CloseTemplate
        Pull    "r0"
        SETV
        B       ErrorAbort
01                 
        ]         
; .............................................................................
; The main polling loop!

repollwimp ROUT

        MOVVS   r1, #2_001              ; 'Ok' button
        BLVS    ReportError
        BVS     ErrorAbort              ; error from reporterror!

      [ Version >= 22
        ADR     R0, discnames
        LDRB    r14, [R0,#drv_name]!    ; if any drive's name starts with ":",
        TEQ     r14, #":"
        LDRNEB  r14, [R0,#drv_size]!
        TEQNE   r14, #":"
        LDRNEB  r14, [R0,#drv_size]!
        TEQNE   r14, #":"
        LDRNEB  r14, [R0,#drv_size]!
        TEQNE   r14, #":"

        MOVEQ   r0, #pointerchange_bits ; we want null events to scan discs
        MOVNE   r0, #pointerchange_bits + null_bit
        ADRL    r1, userdata
        LDR     r2, monotonictime
      [ Version >= 25
        LDR     R14,FormatState
        CMP     R14,#0
        BICNE   r0,r0,#null_bit         ; We need null events if formatting
        SWI     XWimp_Poll
      |
        SWI     XWimp_PollIdle
      ]
      |
        MOV     r0, #pointerchange_bits + null_bit
                                        ; disable null events and pointer
        ADRL    r1, userdata            ; entering/leaving window events
        SWI     XWimp_Poll
      ]
        BVS     repollwimp

; In    r1 -> wimp_eventstr

        ADR     lr, repollwimp
       
      [ Version >= 22
      [ Version >= 25
        CMP     r0,#Null_Reason
        BNE     %FT01
        BLEQ    event_null
        ADR     lr,repollwimp
        B       Format_NullEvent      
01
      |
        BEQ     event_null
      ]
      ]
      
      [ Version >= 25
        CMP     r0, #Open_Window_Request
        BNE     %FT01
        SWI     XWimp_OpenWindow
        B       repollwimp
01
        
        CMP     r0,#Close_Window_Request
        BNE     %FT01
        SWI     XWimp_CloseWindow
        ADR     lr, repollwimp
        B       Format_CloseWindow
01
      ]      
        CMP     r0, #Mouse_Button_Change
        BEQ     event_mouse_click

        CMP     r0, #Menu_Select
        BEQ     event_menu_select

        CMP     r0, #User_Message
        CMPNE   r0, #User_Message_Recorded
        BEQ     event_user_message

        B       repollwimp

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; event_null
; ==========
;
; Check to see whether any of the drives have come on stream
; Until then, the drive number is displayed instead of the name
; Note that SCSIFS_TestReady is called twice if the drive is ready
; (once in this routine, and once in AddToIconBar)
;

      [ Version >= 22

event_null ENTRY

        ADR     r2, iconbaricons
        ADR     r3, discnames
        MOV     r4, #0
01
        LDR     r14, [r2, r4, LSL #2]   ; only look at existing icons
        CMP     r14, #0
        LDRGEB  r14, [r3, #drv_name]    ; which have ":n" under them
        CMPGE   r14, #":"
        BNE     %FT02

        LDRB    r1, [r3, #drv_number+1]
        AND     r1, r1, #&F
        SWI     XSCSIFS_TestReady
        EXIT    VS

        CMP     r0, #2
        LDREQ   r1, [r3, #drv_iconblock]
        Push    "r4"
        BLEQ    AddToIconBar            ; get the name this time!
        Pull    "r4"
        EXIT    VS
02
        ADD     r3, r3, #drv_size
        ADD     r4, r4, #1
        CMP     r4, #ndrives
        BLT     %BT01

        SWI     XOS_ReadMonotonicTime   ; R0 = current time
        LDR     r1, monotonictime
03      ADD     r1, r1, #300            ; 3 second delay between retries
        CMP     r1, r0
        BMI     %BT03                   ; just look at sign of result
        STR     r1, monotonictime       ; in case of wraparound

        EXIT
      ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; event_mouse_click
; =================

; In    r1 -> wimp_eventstr
;             [r1, #0]  pointer x
;             [r1, #4]          y
;             [r1, #8]  new button state
;             [r1, #12] window handle (-1 if background/icon bar)
;             [r1, #16] icon handle (-1 if none)

; Out   all regs may be corrupted - going back to PollWimp

event_mouse_click ENTRY

        LDMIA   r1, {r0-r4}             ; set mousex, mousey, buttonstate
        ADR     r14, mousedata          ; windowhandle, iconhandle
        STMIA   r14, {r0-r4}
 [ debug
 dreg r2, "mouse_click: buttonstate ",cc,Word
 dreg r0, ", x ",cc,Integer
 dreg r1, ", y ",cc,Integer
 dreg r3, ", window ",,Word
 ]

        CMP     r3, #iconbar_whandle    ; window handle of icon bar
       [ Version >= 25
        BNE     Format_MouseClick
      |
        EXIT    NE
      ]
        EXIT    NE

        TST     r2, #button_left :OR: button_right ; select or adjust ?
        BNE     click_select_iconbar

        TST     r2, #button_middle      ; menu ?
        BNE     click_menu_iconbar

        EXIT

; .............................................................................
; We get here if the user has double-clicked on a FS icon

; In    lr stacked, Proc_RegList = "lr" for EXIT
;       all regs trashable

click_select_iconbar ROUT

        BL      matchdriveicon          ; r1 -> drive spec, eg. :4
        BLVC    GetMediaName            ; r1 -> media name
        EXIT    VS
        EXIT    NE                      ; user chickened out!

; Try to open dir using Filer

        LDR     r0, =Message_FilerOpenDir
        BL      messagetoFiler
        EXIT

; In    r0 = message action
;       r1 -> media name

messagetoFiler ENTRY

        SUB     sp, sp, #256            ; make temp frame for message
        STR     r0, [sp, #message_action]
        MOV     r2, r1
        ADD     r1, sp, #message_data
        MOV     r14, #fsnumber_SCSIFS   ; FileSystem = SCSI
        STR     r14, [r1], #4
        MOV     r14, #0                 ; bitset = 0
        STR     r14, [r1], #4
        BL      strcpy_advance
        ADR     r2, dotdollar
        BL      strcpy_advance
        ADD     r1, r1, #1
        ADR     r2, dollar
        BL      strcpy_advance
        ADD     r1, r1, #1
        TST     r1, #3                  ; word aligned end ?
        ADDNE   r1, r1, #3              ; round up to word size
        BICNE   r1, r1, #3
        SUB     r1, r1, sp
        STR     r1, [sp, #message_size]
        MOV     r0, #User_Message_Recorded
        MOV     r1, sp
 [ debugtask
 ADD r14, r1, #message_data+8
 dstring r14, "passing dirname to Filer: "
 ]
        LDR     r2, FilerHandle        ; send it to the Filer
 [ debugtask
 BEQ %FT00
 dreg r2, "Filer task handle "
00
 ]
        SWI     XWimp_SendMessage
        ADD     sp, sp, #256            ; free temp frame
        EXIT


dotdollar       DCB     "."             ; share $ with ...
dollar          DCB     "$", 0          ; directory title
                ALIGN


; Offsets of fields in a message block

                ^       0
message_size    #       4
message_task    #       4               ; thandle of sender - filled in by Wimp
message_myref   #       4               ; filled in by Wimp
message_yourref #       4               ; filled in by Wimp
message_action  #       4
message_hdrsize *       @
message_data    #       0               ; words of data to send

; .............................................................................
; In    lr stacked, Proc_RegList = "lr" for EXIT
;       all regs trashable

        MACRO
$l      Shade   $menu, $item, $cc1, $cc2
$l      LDR     r14, m_$menu+m_headersize+mi_size*mo_fl_$item+mi_iconflags
        ORR$cc1 r14, r14, #is_shaded
      [ "$cc1" <> ""
        BIC$cc2 r14, r14, #is_shaded
      ]
        STR     r14, m_$menu+m_headersize+mi_size*mo_fl_$item+mi_iconflags
        MEND

click_menu_iconbar ROUT

        BL      matchdriveicon          ; r1 -> drive number (eg. :0)
        EXIT    VS

      [ Version >= 025
        LDR     R14,[R1,#drv_number+1]  ; get the drive number
        AND     R14,R14,#&F             ; extract only the meaingful bits
        LDR     R2,FormatState
        MOV     R2,R2,LSR R14           ; get bit indicating what is going one
        ANDS    R2,R2,#1                ; are we verifying or not?
        Shade   floppydisc, namedisc, NE, EQ
        Shade   floppydisc, dismount, NE, EQ
        Shade   floppydisc, verify, NE, EQ
      ]

        Shade   floppydisc, format
        Shade   floppydisc, backup

        ADD     r2, r1, #drv_name+len_colon   ; skip ":" if present
        ADR     r1, mb_namedisc
        BL      strcpy

        ADR     r1, m_floppydisc
        BL      CreateMenu
        EXIT

; Entry:  R4 = icon handle (in icon bar)
; Exit:   R1 --> drive spec for this drive

matchdriveicon  ENTRY "r2"

        MOV     r2, #ndrives
        ADR     r1, iconbaricons
01
        LDR     r14, [r1], #4
        TEQ     r14, r4
        RSBEQ   r2, r2, #ndrives
        STREQ   r2, matchedindex            ; needed for namedisc
        ASSERT  drv_number = 0
        ADREQ   r1, discnames + drv_number
        ADDEQ   r1, r1, r2, LSL #drv_shift
        LDREQB  r14, [r1, #drv_number+1]    ; initialise drive number (for menu)
        STREQB  r14, driveno+1
        EXIT    EQ                          ; r1 -> drive spec
        SUBS    r2, r2, #1
        BNE     %BT01
        ADR     r0, err_noicon
        SETV
        EXIT

err_noicon
        DCD     0
        DCB     "Unknown iconbar icon",0
        ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; A menu is created with the title above the x,y values you feed it, with the
; top left hand corner being at the x,y position

CreateMenu ENTRY "r2, r3"

        STR     r1, menuhandle
        LDR     r2, mousex
        SUB     r2, r2, #4*16
        MOV     r3, #96 + 6*44        ; bodge to clear icon bar
        SWI     XWimp_CreateMenu
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        GBLS    menusym
        GBLA    menuwidth
        GBLA    itemnumber

        MACRO
$label  Menu    $title
menusym SETS    "$label._"              ; keep prefix around
menuwidth SETA  (:LEN: "$title")-3      ; allow 3 chars for borders!
itemnumber SETA 0

        ASSERT  (.-rom_menustart) = ($label-ram_menustart)
$menusym.base                           ; a label to get offsets relative to
        FixDCB  12, "$title"            ; title (12 bytes)
        DCB     7, 2, 7, 0              ; colours
        DCD     $menusym.width*16+12    ; char width = 16 always
        DCD     44                      ; item height (chars = 32 always)
        DCD     0                       ; vertical gap between items
        MEND

menuiconflags  *  (0:SHL:ifb_bcol):OR:(7:SHL:ifb_fcol):OR:if_filled:OR:if_text

        MACRO
$label  Item    $name,$submenu,$end
$label  *       itemnumber
itemnumber SETA itemnumber + 1
 [ menuwidth < :LEN:"$name"
menuwidth SETA  :LEN:"$name"
 ]
        LCLA    menuitemflags
menuitemflags SETA 0
 [ "$end"="-"
menuitemflags SETA menuitemflags + mi_it_dotted
 |
  [ "$end"="X"
menuitemflags SETA menuitemflags + mi_it_lastitem
$menusym.width * menuwidth
  ]
 ]
        DCD     menuitemflags
 [ "$submenu"=""
        DCD     -1
 |
        DCD     $submenu._base-rom_menustart
 ]
        DCD     menuiconflags
        FixDCB  12, "$name"             ; item name
        MEND


        MACRO
$label  ItemI   $buffer,$writelen,$writewidth,$submenu,$end,$validation
$label  *       itemnumber
itemnumber SETA itemnumber + 1
  [ menuwidth < $writewidth
menuwidth SETA  $writewidth
  ]
        LCLA    menuitemflags
menuitemflags SETA 0
 [ "$writelen" <> ""
menuitemflags SETA menuitemflags + mi_it_writeable
 ]
 [ "$end"="-"
menuitemflags SETA menuitemflags + mi_it_dotted
 |
  [ "$end"="X"
menuitemflags SETA menuitemflags + mi_it_lastitem
$menusym.width * menuwidth
  ]
 ]
        DCD     menuitemflags
 [ "$submenu"=""
        DCD     -1
 |
        DCD     $submenu._base-rom_menustart
 ]
        DCD     menuiconflags :OR: if_indirected
 [ "$writelen"<>""
        DCD     :INDEX: $buffer         ; offset of string in ws
   [ "$validation"<>""
        DCD     $validation-rom_menustart
   |
        DCD     -1
   ]
        DCD     $writelen
 |
        DCD     $buffer-rom_menustart   ; offset from menu start in ROM
        DCD     0                       ; 0 or -1 both mean no validation
        DCD     1                       ; forget length unless writeable
 ]
        MEND


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Need to put max length names in for indirect objects so we can suss width

mb_fo_l         DCB     "L - 640K, old map",0
mb_fo_d         DCB     "D - 800K, old map",0
mb_fo_e         DCB     "E - 800K, new map",0
                ALIGN

rom_menustart ; Note - must be defined bottom up

; icon bar menu for SCSI floppy discs

m_floppydisc    Menu    "SCSI::n"
mo_fl_namedisc  Item    "Name disc",m_namedisc
mo_fl_dismount  Item    "Dismount"
mo_fl_format    Item    "Format",m_format    ; floppies only
mo_fl_backup    Item    "Backup"             ; floppies only
mo_fl_verify    Item    "Verify"
mo_fl_free      Item    "Free",,X

m_format        Menu    "Format"
mo_fo_l         ItemI   mb_fo_l,,?mb_fo_l-1
mo_fo_d         ItemI   mb_fo_d,,?mb_fo_d-1
mo_fo_e         ItemI   mb_fo_e,,?mb_fo_e-1,,X

m_namedisc      Menu    "Disc name"
mo_nm_newname   ItemI   mb_namedisc,11,10,,X,mv_namedisc

rom_menuend

 ASSERT (rom_menuend-rom_menustart)=(ram_menuend-ram_menustart)

mv_namedisc     DCB     "A~$&%@\\^:.#*""| ", 0   ; disallow funny chars
                ALIGN                            ; must come AFTER menus

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; CopyMenus
; =========

; Copy menu structures into ram, relocating as we go

CopyMenus ENTRY "r0-r11"

        ADR     r1, rom_menustart       ; src^
        ADR     r2, ram_menustart       ; dst^
        MOV     r10, r2                 ; offset to add to submenu ram ptrs
        MOV     r11, r1                 ; offset to add to indirect ROM strings
        ADR     r0, rom_menuend

01      LDMIA   r1!, {r3-r9}            ; menu header (28 bytes)
        STMIA   r2!, {r3-r9}

02      LDMIA   r1!, {r3-r8}            ; menu item (24 bytes)
        CMP     r4, #-1                 ; submenu pointer (-1 -> no submenu)
        ADDNE   r4, r4, r10             ; add menu base address (in ram)
                                        ; to submenu pointer
        TST     r5, #if_indirected
        BEQ     %FT03

        CMP     r7, #0                  ; is it a dynamic string in ws ?
        ADDEQ   r6, r6, r11             ; add offset to string in ROM
        ADDNE   r6, r6, wp              ; add offset to string in ws
        ADDGT   r7, r7, r11             ; r7 --> validation string if present

03      STMIA   r2!, {r3-r8}
        TST     r3, #&80
        BEQ     %BT02

        CMP     r1, r0
        BNE     %BT01

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; event_menu_select
; =================

; In    r1 -> wimp_eventstr

; Out   all regs may be corrupted - going back to PollWimp

event_menu_select ENTRY

        MOV     r2, r1                  ; r2 -> menu selection list
        LDR     r1, menuhandle          ; r1 = menu handle
        BL      DecodeMenu
;
        ADRVCL  r1,userdata             ; check for right-hand button
        SWIVC   XWimp_GetPointerInfo
        EXIT    VS

        LDR     R14,userdata+8          ; get button state
        TST     R14,#&01
        LDRNE   R1, menuhandle
        SWINE   XWimp_CreateMenu        ; here we go again!

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; In     r1 = menu handle
;        r2 -> list of selections

DecodeMenu ENTRY

decodelp
        LDR     r14, [r2], #4            ; r1 = selection no
        ADD     pc, pc, r14, LSL #2
        EXIT

        B       go_fl_namedisc
        B       go_fl_dismount
        B       go_fl_format
        B       go_fl_backup
        B       go_fl_verify
        B       go_fl_free

error_namedisc  DCD     1
                DCB     "Disc name must be at least two characters long"
                DCB     0
                ALIGN

go_fl_namedisc
        LDR     r14, [r2], #4           ; must select submenu
        TEQ     r14, #0
        EXIT    NE

        LDRB    r14, mb_namedisc        ; check that new name is >= 2 chars
        CMP     r14, #32
        LDRHSB  r14, mb_namedisc+1
        CMPHS   r14, #32
        ADRLO   r0, error_namedisc
        SETV    LO
        EXIT    VS

        ADR     r1, driveno             ; re-read media name
        BL      GetMediaName_nochecks   ; can be duplicate
        EXIT    VS

        BL      checkambiguous
        EXIT    NE                      ; some other error

        LDRVC   r0, =Message_FilerCloseDir
        BLVC    messagetoFiler          ; only close if NOT ambiguous already
      ; CLRV

        ADRL    r3, namedisc
        BL      copycommand
        ADR     r2, mb_namedisc
        BL      strcpy
        ADRL    r0, userdata
 [ debug
 dstring r0, "namedisc: "
 ]
        SWI     XOS_CLI
        EXIT    VS

        LDR     r4, matchedindex
        ADR     r1, discnames + drv_iconblock
        LDR     r1, [r1, r4, LSL #drv_shift]
        BL      AddToIconBar

        ADRVC   r1, driveno             ; don't allow this to clash!
        BLVC    GetMediaName            ; delete old/new disc

        EXIT

go_fl_dismount
        ADR     r1, driveno             ; re-read media name
        BL      GetMediaName_nochecks   ; r1 -> "SCSI::discname"
        BLVC    dismountit
        EXIT

go_fl_format
        LDR     r4, [r2], #4            ; L, D or E
        CMP     r4, #0
        MOVLT   r4, #2                  ; default is E format
        ADR     r3, format
        BL      copycommand
        ADR     r14, lde
        LDRB    r14, [r14, r4]          ; add in appropriate option
        STRB    r14, [r1], #1
        MOV     r14, #0
        STRB    r14, [r1]
        B       gocommand_window

SCSIcolon       DCB     "SCSI:",0
namedisc        DCB     "Namedisc n ",0
                ALIGN
dismount        DCB     "Dismount n ",0         ; NB space still needed
format          DCB     "Format :n ",0
backup          DCB     "Backup n ",0           ; NB ':' not accepted here
verify          DCB     "Verify :n ",0
showfree        DCB     "ShowFree -FS SCSI n ",0
free            DCB     "Free :n ",0
lde             DCB     "LDE"                   ; table of 3 bytes
                ALIGN

go_fl_backup
        ADR     r1, driveno             ; stop ambiguous disc names
        BL      GetMediaName
        EXIT    VS
        EXIT    NE

        ADR     r3, backup
        BL      copycommand
        LDRB    r3, driveno+1
        LDR     r14, nfloppies
        CMP     r14, #1                 ; if 1 drive, it must be the same
        BLE     %FT01
        TEQ     r3, #"0"                ; otherwise choose another one
        MOVEQ   r3, #"1"
        MOVNE   r3, #"0"
01
        STRB    r3, [r1], #1
        MOV     r14, #0
        STRB    r14, [r1]
        B       gocommand_window

go_fl_verify
        [ Version >= 25
        LDR     r1,mywimpversion
        CMP     r1,#205
        BGT     Format_GoVerify
        ]
        ADR     r1, driveno             ; stop ambiguous disc names
        BL      GetMediaName
        EXIT    VS
        EXIT    NE
        ADR     r3, verify
        BL      copycommand
        B       gocommand_window

go_fl_free
        ADR     r1, driveno             ; stop ambiguous disc names
        BL      GetMediaName
        EXIT    VS
        EXIT    NE
        LDR     r2,mywimpversion
        CMP     r2,#205
        ADRLE   r3, free
        ADRGT   r3, showfree
        BL      copycommand

gocommand_window
        ADRL    r0, userdata+:LEN:"SCSI:"
        SWI     XWimp_CommandWindow
        EXIT    VS
        ADRL    r0, userdata
 [ debug
 dstring r0, "commandwindow: "
 ]
        SWI     XOS_CLI
        BVC     %FT01

        SWI     XOS_NewLine
        ADD     r0, r0,#4
        SWI     XOS_Write0
        SWI     XOS_NewLine

01
        MOV     r0, #0
        SWI     XWimp_CommandWindow
        EXIT

; In    r1 -> "SCSI::discname"
; Out   dismounted, and any dirs 'SCSI::discname' closed

dismountit ENTRY "r1"
        LDR     r0, =Message_FilerCloseDir
        BL      messagetoFiler
        ADR     r3, dismount
        BL      copycommand
        SUB     r1, r1, #2              ; r1 -> original drive number
        LDR     r2, [sp]                ; r2 -> "SCSI::discname"
        ADD     r2, r2, #:LEN:"SCSI::"  ; r2 -> discname
        BL      strcpy
        ADRL    r0, userdata
 [ debug
 dstring r0, "dismountit: "
 ]
        SWI     XOS_CLI
        EXIT

; In    [driveno+1] = drive number
;       r3 -> prototype command
; Out   [userdata..] = "SCSI:<command> <drive no>"
;       r1 -> terminator (drive number inserted at [r1,#-2])

copycommand ENTRY
        ADRL    r1, userdata
        ADR     r2, SCSIcolon
        BL      strcpy_advance
        MOV     r2, r3
        BL      strcpy_advance
        LDRB    r14, driveno+1          ; get drive number
        STRB    r14, [r1,#-2]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In     r1 -> drive spec eg. :0

; Out    r1 -> media name (in dirnamebuffer) - "SCSI::discname"

GetMediaName ENTRY "r1-r3"

getmedialoop

        BL      GetMediaName_nochecks
        STR     r1, [sp]                ; ensure r1 correct on return

        BL      checkambiguous
        EXIT    VC
        EXIT    NE                      ; V set, so don't worry about Z

; generate suitable warning message for the user

        ADRL    r3, dismount
        BL      copycommand             ; dismount by drive number
        ADRL    r0, userdata
 [ debug
 dstring r0, "ambiguous: "
 ]
        SWI     XOS_CLI
        EXIT    VS

        ADR     r0, err_ambiguous
        MOV     r1, #2_011
        BL      ReportError
        TEQ     r1, #1                  ; did the user say "OK"?
        EXIT    NE                      ; no!

        LDR     r1, [sp]                ; dismount by disc name (inc. dirs)
        BL      dismountit

        ADR     r1, driveno
        B       getmedialoop            ; try again!

      ; NOEXIT


checkambiguous ENTRY "r1-r5"

        MOVVC   r0, #OSFile_ReadInfo    ; see if we get "ambiguous disc name"
        SWIVC   XOS_File
        TEQVC   r0, r0                  ; ensure Z set!
        EXIT    VC

        LDR     r14, [r0]               ; check error number
        LDR     r2, =&1089E             ; "ambiguous disc name"
        TEQ     r14, r2
        EXIT


err_ambiguous
        DCD     1
        DCB     "This disc has a name that has been seen before.  "
        DCB     "Forget the old one?", 0
        ALIGN

      [ bodgedisc

star_dir_SCSI   DCB     "%Dir SCSI:", 0
star_back       DCB     "%Back", 0
                ALIGN
deadvalue       DCD     &DEADDEAD

      ]

GetMediaName_nochecks ENTRY "r1-r7"

        ADR     r1, dirnamebuffer
        ADR     r2, star_dir_SCSI       ; "%dir SCSI:" needed anyway
        BL      strcpy                  ; (even if SCSI_DescribeDisc used)

        LDR     r0, [sp, #0*4]          ; r0 --> disc spec string
        ADRL    r1, userdata + &80
      [ bodgedisc
        LDR     r14, deadvalue
        STR     r14, [r1]               ; check to see if this works
      ]
        SWI     XSCSIFS_DescribeDisc
        EXIT    VS
      [ bodgedisc
        LDR     r0, [r1]
        LDR     r14, deadvalue
        TEQ     r0, r14
        BEQ     useoldmethod
      ]
        MOV     r14, #0
        STRB    r14, [r1, #32]          ; ensure name is terminated

        ADD     r2, r1, #22             ; r2 -> disc name

      [ bodgedisc
        B       gotdiscname

useoldmethod
        MOV     r0, #0                  ; Read current FS
        MOV     r1, #0
        SWI     XOS_Args
        EXIT    VS
        MOV     r6, r0                  ; Preserve FS

        ADR     r1, dirnamebuffer
        LDR     r2, [sp, #0]            ; r1in
        BL      strcat
        MOV     r0, r1
 [ debug
 dstring r0, "XOS_CLI "
 ]
        SWI     XOS_CLI                 ; dir SCSI:<filename>
        EXIT    VS

        ADRL    r2, userdata+&80        ; r2 -> buffer
        MOV     r3, #&80                ; r3 = buffer size
        MOV     r0, #OSGBPB_ReadDiscName
        SWI     XOS_GBPB

        MOV     r3, r0
        MOV     r7, psr
        ADR     r0, star_back           ; issue '%back' always
        SWI     XOS_CLI
        MOV     r4, r0
        MOV     r5, psr
        MOV     r0, #FSControl_SelectFS ; restore FS always
        MOV     r1, r6
        SWI     XOS_FSControl
        MOVVC   r0, r4
        TEQVCP  r5, #0
        MOVVC   r0, r3
        TEQVCP  r7, #0
        EXIT    VS

        ADRL    r2, userdata+&80
        LDRB    r3, [r2], #1            ; length of discname
        MOV     r14, #0                 ; If "Unnamed" SCSI returns null
        STRB    r14, [r2, r3]           ; put in terminator. r2 -> discname

gotdiscname
      ]

        LDRB    r14, [r2]               ; r2 -> disc name
        CMP     r14, #delete            ; (delete or <= space) = terminator
        CMPNE   r14, #space             ; if null, recover drive number instead

        LDRLS   r2, [sp, #0]            ; r1in = ':4' etc
        ADDLS   r2, r2, #1              ; r2 -> '4' etc
 [ debug
 dstring r2, "SCSI returned name "
 ]

        ADR     r3, dirnamebuffer
        ADD     r1, r3, #:LEN:"%dir SCSI:"
        MOV     r14, #":"               ; Append ':'
        STRB    r14, [r1], #1
        BL      strcpy_space            ; Append discname: not strcat !

        ADD     r1, r3, #:LEN:"%dir "
        STR     r1, [sp, #0]            ; return 'SCSI::DiscName' or 'SCSI::4'
 [ debug
 dstring r1, "returns name "
 ]
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Out   cx0, cy0 = coords of mouse pointer
;       other regs corrupt

GetPointerInfo ROUT

        Push    "r1, r2-r6, lr"         ; poke pointer info into stack

        ADD     r1, sp, #4
        SWI     XWimp_GetPointerInfo
        LDMVCIA r1, {cx0, cy0}

        LDR     r1, [sp], #6*4          ; Restore r1, kill temp frame
        Pull    "pc"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Set up icon bar entries for SCSI
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Out   much corruption

        MACRO
$label  IconDef $sprite, $drvspec, $title
        DCB     "   S"             ; for the validation string entry
$label  FixDCB  12, "$sprite"      ; label --> here
        DCB     "$drvspec", 0
        MEND

ic_winnie4      IconDef "harddisc", ":4"
ic_winnie5      IconDef "harddisc", ":5"
ic_winnie6      IconDef "harddisc", ":6"
ic_winnie7      IconDef "harddisc", ":7"
                ALIGN

SetUpIconBar ENTRY

        SWI     XSCSIFS_Drives
        EXITS   VS                      ; r2 := no of winnies
        MOV     r3, r1                  ; r3 := no of floppies
        STR     r3,nfloppies            ; used by *Backup code

        MOV     r4, #0                  ; r4 = icon handle index

        ADR     r1, ic_winnie7
        CMP     r2, #4
        BLGE    AddToIconBar
        EXIT    VS

        ADR     r1, ic_winnie6
        CMP     r2, #3
        BLGE    AddToIconBar
        EXIT    VS

        ADR     r1, ic_winnie5
        CMP     r2, #2
        BLGE    AddToIconBar
        EXIT    VS

        ADR     r1, ic_winnie4
        CMP     r2, #1
        BLGE    AddToIconBar
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> block:
;               12 bytes of sprite name, preceded by 'S' (for the Wimp)
;               3 bytes of drive spec. (eg. ":0", 0)
;       r4 = index of next free item in icon table
;       [iconbaricons,R4,LSL #2] = icon to replace

; Out   r0 = icon handle
;       r4 = index of next free item in icon table

AddToIconBar ENTRY "r1-r3, r5"

      [ Version >= 22
        LDRB    r1, [r1, #icb_drivenumber+1]
        AND     r1, r1, #&F                     ; In:  R1 = drive number (4..7)
        SWI     XSCSIFS_TestReady               ; Out: R0=0 => drive not present
        LDR     r1, [sp]                        ;      R0=1 => drive not ready
        EXIT    VS                              ;      R0=2 => drive ready

        TEQ     R0,#0                           ; should only happen first time
        EXIT    EQ                              ; so no need to deallocate

        ADD     r2, r1, #icb_drivenumber        ; for later

        TEQ     R0,#1                           ; if drive not ready,
        ADDEQ   r3, r1, #icb_drivenumber        ; don't try to read the name
        BEQ     %FT01
        ADD     r1, r1, #icb_drivenumber
      |
        ADD     r1, r1, #icb_drivenumber
        MOV     r2, r1                          ; r2 -> drive number
      ]
        BL      GetMediaName
        EXIT    VS

      [ Version >= 22
        LDRB    r14, [r1, #len_mediaprefix+1]   ; if name is 1 character long,
        CMP     r14, #" "                       ; the disc is in fact unnamed
        ADRLT   r3, unnamed                     ; r3 -> disc name
        ADDGE   r3, r1, #len_mediaprefix        ; must not start with ":"
      |
        ADD     r3, r1, #len_mediaprefix        ; r3 -> disc name
      ]
01
        ADR     r5, discnames
        ADD     r5, r5, r4, LSL #drv_shift
        ADD     r1, r5, #drv_number
        BL      strcpy                          ; copy in drive number
        ADD     r1, r5, #drv_name
        MOV     r2, r3
        BL      strcpy_advance                  ; should be enough room

        SUB     r14, r1, r5
        SUB     r14, r14, #drv_name
        STRB    r14, [r5, #drv_namelen]

        LDR     r1, [sp]                ; r1 -> drive block
        STR     r1, [r5, #drv_iconblock]

        ADR     r2, iconbaricons        ; r2 -> iconbaricons
        LDR     r3, [r2, r4, LSL #2]!   ; r2 -> [icon to open next to]
        BL      AllocateIcon            ; r5 -> drive number/name
        EXIT    VS

        STR     r0, [r2]                ; save new handle
        ADD     r4, r4, #1

        MOV     r1, #-2                 ; delete previous icon, if any
        Push    "r1,r3"
        MOV     r1, sp
        CMP     r3, #0
        SWIGE   XWimp_DeleteIcon
        ADD     sp, sp, #8

        EXIT

      [ Version >= 22
unnamed DCB     "<unnamed>", 0
        ALIGN
      ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> icon description (icb_etc)
;       r2 -> [handle of icon to open next to]
;       r4 = icon index
;       r5 -> drive description (drv_etc)

; Out   r0 = icon handle (created on iconbar)

AllocateIcon ENTRY "r1-r5, x0, y0, x1, y1"

        MOV     r2, r1
        MOV     r0, #SpriteReason_ReadSpriteSize
        SWI     XWimp_SpriteOp                  ; r3, r4 = pixel size

        MOVVC   r0, r6                          ; creation mode of sprite

        MOVVC   r1, #VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   x0, #0
        ADDVC   x1, x0, r3, LSL r2              ; pixel size depends on sprite

        MOVVC   r1, #VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   y0, #20                         ; sprite baseline
        ADDVC   y1, y0, r4, LSL r2
        MOVVC   y0, #-16                        ; text baseline

        EXIT    VS

        ASSERT  x0 > r5
        LDMIA   sp,{r1-r5}                      ; we need r1 and r5

        LDRB    r4, [r5, #drv_namelen]          ; include name in icon
        CMP     x1, r4, LSL #4                  ; 16 OS units per char
        MOVLT   x1, r4, LSL #4

        ADRL    r14, userdata
        MOV     r0, #-2                         ; lhs of icon bar
        STMIA   r14!, {r0, x0, y0, x1, y1}      ; window handle, icon coords
        LDR     r0, iconbariconflags            ; r0 = icon flags
        ADD     r2, r5, #drv_name               ; r2 -> drive name/number
        ADD     r3, r1, #icb_validation         ; r3 -> validation string
        STMIA   r14, {r0, r2-r4}                ; r4 = length of text

        ADRL    r1, userdata
      [ Version >= 21
        LDR     r14, wimpversion        ; if Wimp version 2.21 or later,
        CMP     r14, #221
        BLT     %FT01
        LDMIA   sp, {r0, r2-r4}         ; check previous icon handle
        LDR     r0, [r2]                ; [r2] = previous handle
        CMP     r0, #0                  ; if creating for the first time,
        RSBLTS  r14, r4, #0             ; if this is not the first icon,
        LDRLT   r0, [r2, #-4]           ; open to right of previous icon
        MOVLT   r14, #-4                ; -4 => open to right of icon
        MOVGE   r14, #-3                ; -3 => open to left of icon / iconbar
        STR     r14, [r1, #u_handle]
01
      ]
        SWI     XWimp_CreateIcon
        EXIT                            ; returns r0 = icon handle

iconbariconflags
        DCD     &1700310B       ; text
                                ; sprite
                                ; h-centred
                                ; indirected
                                ; button type 3
                                ; fcol 7, bcol 1

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strcat
; ======
;
; Concatenate two strings

; In    r1, r2 -> CtrlChar/r3 terminated strings

; Out   new string in r1 = "r1" :CC: "r2" :CC: 0

strcat ENTRY "r1-r3"

        MOV     r3, #space-1

05      LDRB    r14, [r1], #1           ; Find where to stick the appendage
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, r3
        BHI     %BT05
        SUB     r1, r1, #1              ; Point back to the term char

10      LDRB    r14, [r2], #1           ; Copy from *r2++
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, r3                 ; Any char <= r3 is a terminator
        MOVLS   r14, #0                 ; Terminate dst with 0
        STRB    r14, [r1], #1           ; Copy to *r1++
        BHI     %BT10

        EXITS

; .............................................................................
;
; strcpy
; ======
;
; Copy a string and terminate with 0

; In    r1 -> dest area, r2 -> CtrlChar/r3 terminated src string

strcpy ALTENTRY

        MOV     r3, #space-1            ; terminate on ctrl-char
        B       %BT10

strcpy_space ALTENTRY

        MOV     r3, #space              ; terminate on space or ctrl-char
        B       %BT10


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strcpy_advance
; ==============

; In    r1 -> dest string
;       r2 -> source string

; Out   r1 -> terminating null

strcpy_advance ENTRY "r2"

10      LDRB    r14, [r2], #1           ; Copy from *r2++
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, #space-1           ; Any char < space is a terminator
        MOVLS   r14, #0                 ; Terminate dst with 0
        STRB    r14, [r1], #1           ; Copy to *r1++
        BHI     %BT10

        SUB     r1, r1, #1
        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; event_user_message (and _recorded)
; ==================

; In    r1 -> wimp_eventstr
;             [r1, #0]     block size
;             [r1, #12]    your ref
;             [r1, #16]    message action
;             [r1, #20...] message data

; Out   all regs may be corrupted - going back to PollWimp

event_user_message

        LDR     r0, [r1, #message_action]
                             
        LDR     R2, =Message_HelpRequest
        TEQ     R0, R2
        BEQ     help                            ; apt really ...

        CMP     r0, #Message_Quit
        MOVNE   PC,LR

        B       CloseDownAndExit

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 = state for ReportError
; Out   r1 = 1 (OK) or 2 (Cancel)

ReportError ENTRY "r2"

        ADRL    r2, SCSIFiler_Banner
        SWI     XWimp_ReportError
        EXIT

        [ Version >= 25
        ; special reversion of message token routines
        
;..............................................................................

; In    r0 -> token string
;       r1 -> buffer to copy message into
;       r2 = size of buffer (including terminator)
;       r3 -> parameter 0
;       [messagedata] -> message file descriptor (0 => not yet loaded)
; Out   message file loaded if not already loaded
;       [r1..] = message, terminated by 0
;       r2 = size of string, including the terminator

lookuperror
lookuptoken ENTRY "r0-r7"

 [ debug
;  dstring r0, "Look up token "
;  dstring r3, "Parameter 0 "
 ]
   ; copy [r0] to [r1] until =0, incrementing r2
   ; if we encounter a %, don't copy it, but copy [r3] until 0
 
        MOV R2,#0
        MOV R5,#0
lookup1
        LDRB R4,[R0,R2]
        STRB R4,[R1,R5]
        ADD R2,R2,#1  
        CMP R4,#'%'
        BEQ lookup2
        ADD R5,R5,#1     ;it's here to ensure that the % gets overwritten

        CMP R4,#0
        BNE lookup1
        STR R5,[sp,#2*4] ;set the length up
        EXIT                               

lookup2
        MOV R6,#0
lookup3
        LDRB R7,[R3,R6]
        STRB R7,[R1,R5]
        ADD R6,R6,#1
        ADD R5,R5,#1
        CMP R7,#0
        BEQ lookup1
        B lookup3
        ]
        
        
        ; Note - use of adfs here *is* intentional!
        [ Version >= 25
str_templatefile DCB     "ADFSFiler:Templates", 0
        ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;..............................................................................

; return interactive help on a menu item/icon.

; in    R1 -> message block
; out   -

help    Push    "R1,LR"
                   
        LDR     R2,[R1,#32]                     ; get the window handle
        CMP     R2,#-2                          ; is it the icon baaah?
        ADREQ   R2,icon                         ; -> message to return
        BEQ     help_returnmessage

        MOV     R0,#1                           ; return list of menu items - as if selected
        LDR     R3,[R1,#36]                     ; get the icon handle
;
        ADR     R1,dirnamebuffer                     
        SWI     XWimp_GetMenuState
        Pull    "R1,PC",VS      
;
        LDR     R0,[R1] 
        ADR     R2,menu00                       ; setup for first layer of menu
;
        CMP     R0,#-1                          ; is there a first item?
        Pull    "R1,PC",EQ,^                    ; don't bother if no items selected
;
        LDR     R14,[R1,#4]
        CMP     R14,#-1                         ; is there a second layer item?
        MOVNE   R0,R14
        ADRNEL  R2,menu10                       ; if there is then point at that list of messages
                        
10      SUBS    R0,R0,#1
        BMI     help_returnmessage              ; have found the token, count has become -1

15      LDRB    R1,[R2],#1
        TEQ     R1,#0
        BNE     %BT15                           ; loop back until the end of the string has been reached
        B       %BT10                      
                        
help_returnmessage
        Pull    "R1"

        ADD     R0,R1,#20
25      LDRB    R3,[R2],#1
        STRB    R3,[R0],#1
        TEQ     R3,#0                           ; have we finished copying the string yet?
        BNE     %BT25                           ; loop back until done then
                            
        SUB     R0,R0,R1                        ; get the size of the message
        ADD     R0,R0,#3
        BIC     R0,R0,#3
        STR     R0,[R1,#ms_size]                ; store size of new message (word aligned)
                                               
        LDR     R0,=Message_HelpReply
        STR     R0,[R1,#ms_action]              ; store the message ID

        LDR     R0,[R1,#ms_myref]
        STR     R0,[R1,#ms_yourref]             ; swap these babys around and send it back!

        MOV     R0,#User_Message
        LDR     R2,[R1,#ms_taskhandle]
        SWI     XWimp_SendMessage               ; suck on this Help task!

        Pull    "PC"                            ; R1 pulled previously
         
icon    = "This is a SCSI Disc drive icon|MClick SELECT to display the root directory of this disc.",0

menu00  = "Move the pointer right to alter the name of this disc.",0
        = "Click SELECT to dismount this disc.",0
        = "Format option.|MTo format a SCSI disc please use the SCSIDM application.",0
        = "Backup option.|MNot supported under SCSIFS.",0
        = "Click SELECT to verify this SCSI disc.|MIf there are any defects found, use the SCSIDM application to map them out.",0
        = "Click SELECT to determine the free space on this disc.",0
        
menu10  = "Enter the new disc name and press Return.",0

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        LTORG
 [ Version >= 25
MenuTitleFlags  DCD     &00070207       ; Flags for menu title
 ]
  
 ; my AASM here can't handle this, so....
 [ 0=1
 [ Version >= 25
CondLink        SETS    " LNK Format"
 ]
$CondLink                                
 ]
          
 LNK s.format

        END
