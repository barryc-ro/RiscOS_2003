/*
 * Title       : module.c
 * Author      :
 * Date        :
 * Description :
 * History     :
 *  20/09/95 RWB, Added STBStateOn command.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>

#include "kernel.h"
#include "swis.h"
#include "time.h"

#undef DEBUG			/* Debug mode */

#define FALSE	0
#define TRUE	(!FALSE)

#define FLASH_INTERVAL	50	/* Flash the leds every 50 centiseconds */
#define TIMEOUT		30	/* Init state times out to fatal after 30s */
#undef TIMEOUT

/*
 * My UpCalls and Services
 */
#define UpCall_Online	13
#define UpCall_Standby	14
#define Service_PreReset	0x45
#define Service_Sleeping	0xb1


/*
 * Other people's things
 */
#ifndef MPEGVideo_CardControl
  #define MPEGVideo_CardControl	0x49305
  #define TVBits (32+64)
#endif

#ifndef Sound_SampleRate
#  define Sound_SampleRate 0x40146
#endif

/*
 * CMOS stuff
 */
#define ReadCMOS	0xA1
#define WriteCMOS	0xA2
#define StartCMOS	0x0B
#define STANDBY_BIT	128
#define CMOS_WIMPMODE  (196)      // CMOS location for WIMP mode

/*
 * Bits in Morris' 8-bit IO port
 */
#define RED_BIT		2
#define GREEN_BIT	4
#define DOG_BIT		128


/*
 * Bits in IRQA mask
 */
#define TIMER_BITS	(64+32)


/*
 * Types
 */
typedef unsigned char byte;
typedef enum { LED_OFF, LED_ON, LED_FLASH } led_t;
typedef enum { DOG_ON=0, DOG_OFF=DOG_BIT } dog_t;
typedef enum { OFF_PT = 0, OFF_LP = 1,
               FATAL = 2, INIT = 4,
               ON = 6,
               NONE = -1 } state_t;
typedef enum { SWI_ON, SWI_OFF, SWI_FATAL, SWI_BUSY, SWI_STANDBY, SWI_STATE,
               SWI_CONTROL } swi_t;


/*
 * Globals (dontcha love em)
 */
volatile byte *io_port = (byte *) 0x320000C;	/* Morris 8-bit I/O port      */
volatile byte *susp_reg = (byte *) 0x320001C;	/* Morris SUSPENDMODE register*/
volatile byte *irqmska = (byte *) 0x3200018;	/* Morris IRQA interrupt mask */
volatile byte *stop_reg = (byte *) 0x320002C;	/* Morris STOPMODE register   */
volatile byte *atodicr = (byte *) 0x32000E0;	/* Morris A2D interrupt ctrl  */
volatile byte *vidcr = (byte *) 0x32001E0;	/* Morris video DMA control   */
volatile unsigned *vid_addr = (unsigned *) 0x3500000;	/* VIDC20 space       */
volatile byte *resettype = (byte *) 0x322;	/* ResetType in PublicWS      */

_kernel_oserror *e;
_kernel_swi_regs regs;
int my_private_word;

byte io_softcopy = 0xff;		/* softcopy of contents of I/O port   */
byte cmospowerdown;
int red_flash = 0, green_flash = 0;	/* non-zero if led should be flashing */
int leds_changing = FALSE;		/* semaphore                          */
state_t state = INIT;			/* The state we're in (man)           */
int timer = 0;				/* timeout timer                      */
int busy_level = 0;			/* Nested Busys, 0 = not busy         */
char tv_var[] = "TVOn";


/*
 * Function declarations
 */
extern void do_reset(void);
extern int STBState_callevery_entry (_kernel_swi_regs *r, void *pw);
_kernel_oserror *STBState_swi (int swi_no, _kernel_swi_regs *r, void *pw);
void STBState_final(void);
void set_io_port(led_t red, led_t green, dog_t watch);
void tv_on(void);
void tv_off(int stop);
void go_on(void);
void go_busy(int r0);
void go_off(void);
void go_pd(void);
void go_lp(void);
void go_pt(void);
void go_fatal(void);


/*
 * Start here
 */
_kernel_oserror *STBState_init (char *cmd_tail, int podule_base, void *pw)
{
  /*
   * Setup a callevery function to flash the leds as required
   */
  regs.r[0] = FLASH_INTERVAL;
  regs.r[1] = (int) STBState_callevery_entry ;
  regs.r[2] = my_private_word = ((int) pw);
  if ((e = _kernel_swi (OS_CallEvery, &regs, &regs)) != NULL)
    return (e);

  /* Display the INIT state */
  set_io_port(LED_ON, LED_FLASH, DOG_ON);

  /* Record state of the CMOS Standby bit */
  regs.r[0] = ReadCMOS;
  regs.r[1] = StartCMOS;
  _kernel_swi (OS_Byte, &regs, &regs);
  cmospowerdown = (!(regs.r[2] & STANDBY_BIT));

  /* Set the STBReset$Type environment variable */
  regs.r[0] = (int) "STBReset$Type";
  regs.r[1] = (int) (((*resettype) & 1) ? "PowerOn" : "Standby");
  regs.r[2] = strlen((char*) (regs.r[1]));	/* length */
  regs.r[3] = 0;
  regs.r[4] = 4;				/* LiteralString */
  _kernel_swi (OS_SetVarVal, &regs, &regs);

  return NULL;
}


/*
 * Called by on module death (which shouldn't usually happen)
 */
void STBState_final(void)
{
  /*
   * Get off callevery
   */
  regs.r[0] = (int) STBState_callevery_entry;
  regs.r[1] = (int) my_private_word;
  _kernel_swi (OS_RemoveTickerEvent, &regs, &regs);
}

/*----------------------------------------------------------------------
    Name : STBState_cli_handler

    Description : Handle command line interface to this module.
----------------------------------------------------------------------*/
_kernel_oserror *STBState_cli_handler(char *arg_string, int arg_count, int cmd_no, void *pw)
{
  if (cmd_no == 0)      /* This is the only command so far but check it anyway */
  {
    /* Do the STBState_On call */
    if ((state == INIT) || (state == OFF_PT)) go_on();

    /* Look at what the configured Wimp mode is */
    regs.r[0] = ReadCMOS;
    regs.r[1] = CMOS_WIMPMODE;
    _kernel_swi(OS_Byte,&regs,&regs);

    /* Change mode to the configured Wimp mode */
    regs.r[0] = 0;
    regs.r[1] = regs.r[2];               /* Copy wimp mode into r1 for next call */
    _kernel_swi(OS_ScreenMode,&regs,&regs);
  }
  return NULL;
}

/*
 * Update the LED and watchdog bits in the IO port
 */
void set_io_port(led_t red, led_t green, dog_t watch)
{
  /* Clear the leds and the watchdog bit */
  int new_io = io_softcopy & ~(RED_BIT | GREEN_BIT | DOG_BIT);
  int old_leds_changing = leds_changing;

  /*
   * Signal that callevery handler shouldn't try to twiddle the leds cos we're
   * twiddling them
   */
  leds_changing = TRUE;

  if (red == LED_FLASH)
  {
    red_flash = TRUE;
    /* toggle RED_BIT in new_io */
    new_io |= (RED_BIT & ~io_softcopy);
  }
  else
  {
    red_flash = FALSE;
    if (red == LED_ON)
      new_io |= RED_BIT;
  }

  if (green == LED_FLASH)
  {
    green_flash = TRUE;
    /* toggle GREEN_BIT in new_io */
    new_io |= (GREEN_BIT & ~io_softcopy);
  }
  else
  {
    green_flash = FALSE;
    if (green == LED_ON)
      new_io |= GREEN_BIT;
  }

  *io_port = io_softcopy = (new_io | watch);
#ifdef DEBUG
  printf("io port = %x\n", io_softcopy);
#endif
  leds_changing = old_leds_changing;
}


/*
 * Flash the LEDs if they need flashing, and check for timeout if in init state
 *
 * Note that there is currently no state which is displayed with both leds
 * flashing simultaneously. If there were, this code and the code in set_io_port
 * might need to be fixed to ensure that the leds flashed in sync rather than
 * alternately
 */
extern int STBState_callevery_handler(_kernel_swi_regs *r, void *pw)
{
  int new_io;

  /*
   * Check timeout
   */
#ifdef TIMEOUT
  if ( (++timer >= TIMEOUT * (100 / FLASH_INTERVAL)) && (state == INIT) )
    go_fatal();
  else
#endif

  /*
   * Check that set_leds isn't twiddling the leds
   */
  if (!leds_changing)
  {
    new_io = io_softcopy;

    if (red_flash)
      new_io = (io_softcopy & ~RED_BIT) | (RED_BIT & ~io_softcopy);

    if (green_flash)
      new_io = (io_softcopy & ~GREEN_BIT) | (GREEN_BIT & ~io_softcopy);

    *io_port = io_softcopy = new_io;
  }

  return 1;
}


/*
 * SWI entry
 */
_kernel_oserror *STBState_swi (int swi_no, _kernel_swi_regs *r, void *pw)
{
  switch (swi_no)
  {
  case SWI_ON:
    if ((state == INIT) || (state == OFF_PT))
      go_on();
    break;

  case SWI_OFF:
    if ((state == INIT) || (state == ON) || (state == OFF_PT))
      go_off();
    break;

  case SWI_FATAL:
    go_fatal();
    break;

  case SWI_BUSY:
    if (state == ON)
      go_busy(r->r[0]);
    break;

  case SWI_STANDBY:
    switch (state)
    {
    case OFF_PT:
      go_on();
      break;

    case FATAL:
    case INIT:
      cmospowerdown = TRUE;
      go_off();

      /* If this fails the only sensible thing to do is to go off */

      /* note fallthrough */
    case ON:
      go_off();
      break;
    }
    break;

  case SWI_STATE:
    r->r[0] = state;
    break;

  case SWI_CONTROL:
      set_io_port((r->r[0] & 1) ? LED_ON : LED_OFF,
                  (r->r[0] & 2) ? LED_ON : LED_OFF, DOG_OFF);
    break;

  default:	/* This never happens, so we're going to ignore it :-) */
    break;
  }
  return NULL;
}


/*
 * Turn the TV display on, either by resetting the MPEGVideo module or by just
 * getting it to twiddle the bits.
 */
void tv_on(void)
{
#ifdef DEBUG
  printf("TV On\n");
#endif
  /* Set the TVOn environment variable */
  regs.r[0] = (int) tv_var;
  regs.r[1] = NULL;
  regs.r[2] = 0;		/* 0 length */
  regs.r[3] = 0;
  regs.r[4] = 4;		/* LiteralString */
  _kernel_swi (OS_SetVarVal, &regs, &regs);

  /* Call the MPEGVideo module to turn the display on, ie set TVBits */
  regs.r[0] = 2;		/* reason code */
  regs.r[1] = TVBits;
  regs.r[2] = ~TVBits;
  _kernel_swi (MPEGVideo_CardControl, &regs, &regs);

  /* Reset the MPEG chips */
  regs.r[0] = 3;		/* reason code */
  regs.r[1] = 0;		/* reset */
  _kernel_swi (MPEGVideo_CardControl, &regs, &regs);
}


/*
 * Turn the TV display off, and optionally tells the MPEGVideo module to stop
 * the MPEG chips.
 */
void tv_off(int stop)
{
#ifdef DEBUG
  printf("TV Off\n");
#else
  /* Unset the TVOn environment variable */
  regs.r[0] = (int) tv_var;
  regs.r[1] = NULL;
  regs.r[2] = -1;		/* unset */
  regs.r[3] = 0;
  regs.r[4] = 4;		/* LiteralString */
  _kernel_swi (OS_SetVarVal, &regs, &regs);

  /* Call the MPEGVideo module to turn the display off */
  regs.r[0] = 2;		/* reason code */
  regs.r[1] = 0;
  regs.r[2] = ~TVBits;
  _kernel_swi (MPEGVideo_CardControl, &regs, &regs);

  if (stop)
  {
    /* Stop the MPEG chips */
    regs.r[0] = 3;		/* reason code */
    regs.r[1] = 1;		/* stop */
    _kernel_swi (MPEGVideo_CardControl, &regs, &regs);
  }
#endif
}


/*
 * Go to On state
 */
void go_on(void)
{
  regs.r[0] = UpCall_Online;
  _kernel_swi(OS_UpCall, &regs, &regs);
  tv_on();

  state = ON;
  busy_level = 0;
  set_io_port(LED_OFF, LED_ON, DOG_ON);
}


/*
 * Adjust the busy state
 *
 * r0 holds 0 to go less busy, 1 to go more busy.
 */
void go_busy(int r0)
{
  if (r0)			/* Get busy ? */
  {
    if (!(busy_level++))	/* Change leds if currently not busy */
      set_io_port(LED_OFF, LED_FLASH, DOG_ON);
  }
  else				/* Get less busy */
  {
    if (busy_level)		/* Don't want negative busy levels */
      if (!(--busy_level))	/* Change leds if no longer busy */
        set_io_port(LED_OFF, LED_ON, DOG_ON);
  }
#ifdef DEBUG
  printf("Busy = %d\n", busy_level);
#endif
}


/*
 * Go to Fatal state
 *
 * Could maybe do some powerdown features here, but since we don't know what
 * went wrong, its probably best not do make any assumptions that other bits
 * of the system are working ?
 */
void go_fatal(void)
{
  tv_on();

  state = FATAL;
  set_io_port(LED_FLASH, LED_OFF, DOG_ON);
}


/*
 * Go to an off state
 */
void go_off(void)
{
  byte save_atodicr, save_vidcr;

  if (state != OFF_PT)
  {
    regs.r[0] = UpCall_Standby;
    _kernel_swi (OS_UpCall, &regs, &regs);

    if (regs.r[0] == 0)
      return;			/* UpCall was claimed */

    tv_off(FALSE);
  }

  if (cmospowerdown)
  {
    /*
     * CMOS says Power Down mode
     */
    regs.r[1] = Service_PreReset;
    _kernel_swi (OS_ServiceCall, &regs, &regs);

    set_io_port(LED_ON, LED_OFF, DOG_OFF);

    /* Stop MPEG chips */
    tv_off(TRUE);

    /* Go into stop mode prior to reset */
    do_reset();
    /* Never gets here */
  }
  else
  {
    /*
     * CMOS says Pass Through mode
     */

    clock_t tick;
    int sound_rate;

    do
    {
#ifdef DEBUG
      printf("%d", state);
#endif
      regs.r[0] = state;
      regs.r[1] = Service_Sleeping;
      _kernel_swi (OS_ServiceCall, &regs, &regs);

      if (regs.r[1] != Service_Sleeping)
      {
        /*
         * Sleeping claimed -> Pass Through mode
         *
	 * Wake things up if we're in low-power mode
	 */
	if (state == OFF_LP)
	{
	  byte block[1];

	  *atodicr = save_atodicr;
          *vidcr = save_vidcr;

  	  /* restore sound sample rate */
          regs.r[0] = 3;
          regs.r[1] = sound_rate;
          _kernel_swi (Sound_SampleRate, &regs, &regs);

          /* Reint the joystick module which uses the A2D */
          regs.r[0] = 3;
          regs.r[1] = (int) "Joystick";
          _kernel_swi (OS_Module, &regs, &regs);

#if 0     /* FIXME to support RTC as well as / instead of E2ROM */
          /* Update the RTC soft copy from the hard copy */
          /* Read the RTC time. This will fail if no RTC fitted */
          block[0] = 1;			/* Address to read from */
          regs.r[0] = 0xA0;		/* Write address */
          regs.r[1] = (int) block;
          regs.r[2] = 1;
          if (! _kernel_swi (IIC_Control, &regs, &regs))
          {
            regs.r[0] = 0xA1;		/* Read */
            regs.r[2] = 6;		/* We want 6 bytes */
            if (! _kernel_swi (IIC_Control, &regs, &regs))
            {
              /* Write RTC time */

              /* Reint the RTCAdjust module which will be sadly confused */
              regs.r[0] = 3;
              regs.r[1] = (int) "RTCAdjust";
             _kernel_swi (OS_Module, &regs, &regs);
            }
          }
#endif
	}

        /*
         * Sleeping claimed -> Pass Through mode
         */
        state = OFF_PT;

#ifdef DEBUG
        printf("PT\n");
#endif

        /* Get screen mode */
	regs.r[0] = 1;
	_kernel_swi (OS_ScreenMode, &regs, &regs);

        /* Set screen mode */
	regs.r[0] = 0;
	_kernel_swi (OS_ScreenMode, &regs, &regs);

        set_io_port(LED_ON, LED_OFF, DOG_OFF);
        *irqmska |= TIMER_BITS;		/* Restore Timers */
#ifdef DEBUG
        printf("STBState_Off returns\n");
#endif
        return;

      } /* (regs.r[1] != Service_Sleeping) */

      /*
       * Sleeping not claimed -> do Low Power stuff if we havn't done it before
       */
      if (state != OFF_LP)
      {

#ifdef DEBUG
        printf("LP\n");
#endif
        state = OFF_LP;
        set_io_port(LED_ON, LED_OFF, DOG_OFF);

        /* Stop MPEG chips */
        tv_off(TRUE);

        /* Save the current sound sample rate and set it to some bogus value */
        regs.r[0] = 1;
        _kernel_swi (Sound_SampleRate, &regs, &regs);
        sound_rate = regs.r[1];

	/* Hack to change sound clock */
        regs.r[0] = 3;
        if ((sound_rate == 7) || (sound_rate == 14) || (sound_rate == 20))
          regs.r[1] = 1;
	else
          regs.r[1] = 7;
        _kernel_swi (Sound_SampleRate, &regs, &regs);

        save_atodicr = *atodicr;
        save_vidcr = *vidcr;

#if 1
	*atodicr = 0;
	*vidcr = 0;
        *vid_addr = 0xC0000003;	/* Video ereg in PowerDown mode */
        *vid_addr = 0xD0004000;	/* Video fsynreg */
        *vid_addr = 0xE0004000;	/* Video conreg */
        *vid_addr = 0xB1000001;	/* Sound control register */
        *atodicr = 0;		/* Stop A2D */
#endif
      }

      /*
       * Wait > 1/100s to ensure that external things have seen us go off
       * (where "external things" is actually the IR micro)
       */
      tick = clock()+2;
      while (clock() <= tick);

#ifdef DEBUG
      *io_port = '\xfb';	/* Red, Dog off */
#endif

      /* Mask off Timers 0 and 1 */
      *irqmska &= ~TIMER_BITS;

      /* Suspend Morris */
      *susp_reg = 0;		/* Stop all: Fclk, Clk2, Clk8, Ref8 and Clk16 */

      /* Event pin, IRQ or FIQ woke us up */

#ifdef DEBUG
      *io_port = '\xff';	/* Red + Green, Dog off */
#endif

      /* Restore Timers */
      *irqmska |= TIMER_BITS;

      /* Loop and re-issue the Sleeping service */
    } while (TRUE);
  }
}
