/*
* registry.c	- List of IR peripherals and manufacturers
*/

/*
* 		Copyright 1996 Acorn Network Computing
*
* This material is the confidential trade secret and proprietary
* information of Acorn Network Computing. It may not be reproduced,
* used, sold, or transferred to any third party without the prior
* written consent of Acorn Network Computing. All rights reserved.
*
*/

#include <stdio.h>
#include <string.h>

#include "utils.h"


#include "registry.h"	/* For device and packet types and registry_t */

/*

static driver_entry_t drivers[] =
{
    {0x00000000,0,"Relative pointer driver",   "IRDrivers:IRRelPtr"},
    {0x00000001,0,"Model 1 A-Z Handset driver","IRDrivers:IRHandset"},
    {0x00000002,0,"Model 1 Keyboard driver",   "IRDrivers:IRKeyboard"},
    {0x00000003,0,"Display dump",              "IRDrivers:IRDisplay"},
    {0x00000004,0,"Generic IR Blasting driver","IRDrivers:IRBlast"},
    {0x00000005,0,"RCA CRK93H1 Handset driver","IRDrivers:CRK93H1"},
    {0x00000006,0,"RCA IR Blasting driver",    "IRDrivers:RCABlast"},
    {0x00000007,0,"Default driver",            "IRDrivers:IRDefault"},
    {0x00010000,0,"Curtis Mathes driver",      "IRDrivers:IRHandsetC"}


};

static registry_entry_t registry[] =
{
    {0x00000000,0x00000001,"Standard A-Z Handset"},
    {0x00000001,0x00000003,"Standard A-Z Handset with I-Point"},
    {0x00000002,0x00000002,"Relative Pointer + Buttons (Navis)"},
    {0x00000003,0x00000003,"A-Z with relative pointer"},
    {0x00000004,0x00000000,"Relative pointer and buttons for Trackboard"},
    {0x00000006,0x00000003,"Akai tablet keyboard"},
    {0x00000008,0x00000003,"Akai Relative pointer & buttons"},
    {0x00000009,0x00000003,"I-Point keyboard"},
    {0x0000000a,0x00000003,"I-Point relative pointer and buttons"},
    {0x0000000b,0x00000003,"Akai multiway switch keyboard"},
    {0x0000000c,0x00000003,"Akai multiway switch relative pointer and buttons"},
    {0x0000000d,0x00000005,"RCA CRK93H1 Handset"},
    {0x0000000e,0x00000003,"RCA IRKB4 Keyboard"},
    {0x0000000f,0x00010000,"Curtis Mathes Handset"}
};
*/



static FILE *fp=NULL;
static registry_file_header_t h;

static unsigned int initialise_local_file(void)
{

    fp = fopen("Resources:$.Resources.IR.registry","rb");

    if (fp == NULL)
    {
        DEBUGFN(3,db_printf("failed to open ir registry file\n"));
        return 0;
    }

    if (fread(&h,sizeof(registry_file_header_t),1,fp) != 1)
    {
        fclose(fp);
        fp = NULL;
        DEBUGFN(3,db_printf("failed to read ir registry header\n"));
        return 0;
    }

    return 1;

}



unsigned int reg_get_device_info(unsigned int registry_number,
                                 unsigned int *driver_number,
                                 char *description)
{
    unsigned int loop;
    registry_entry_t reg;
    unsigned int count;


    if (fp == NULL)
    {
        if (initialise_local_file() == 0)
        {
            DEBUGFN(3,db_printf("reg:initialise_local_file_failed\n"));

            return 0;
        }
    }

    if (fseek(fp,h.reg_offset,SEEK_SET)!= 0)
    {
        DEBUGFN(3,db_printf("reg:seek 1 failed\n"));
        return 0;
    }


    if (fread(&count,sizeof(unsigned int),1,fp) != 1)
    {
        DEBUGFN(3,db_printf("reg:read 1 failed\n"));
        return 0;
    }


    for (loop = 0; loop < count; loop ++)
    {
        if (fread(&reg,sizeof(registry_entry_t),1,fp) != 1)
        {
            DEBUGFN(3,db_printf("reg:read 2 failed\n"));

            return 0;
        }

        if (reg.registry_number == registry_number)
        {
            if (driver_number != NULL)
            {
                *driver_number = reg.driver_number;
            }
            if (description != NULL)
            {
                if (fseek(fp,reg.desc_offset,SEEK_SET)!= 0)
                {
        DEBUGFN(3,db_printf("reg:seek 2 failed\n"));
                    return 0;
                }
                if (fread(description,reg.desc_len,1,fp) != 1)
                {
        DEBUGFN(3,db_printf("reg:read 3 failed\n"));
                    return 0;
                }
            }
            return 1;
        }
    }
    return 0;
}

unsigned int reg_get_driver_info(unsigned int driver_number,
                                 unsigned int *revision_number,
                                 char *description,
                                 unsigned int *location,
                                 char * filename)
{
    unsigned int loop;
    unsigned int count;
    driver_entry_t drv;


    if (fp == NULL)
    {
        if (initialise_local_file() == 0)
        {
            return 0;
        }
    }

    if (fseek(fp,h.drv_offset,SEEK_SET)!= 0)
    {
        return 0;
    }


    if (fread(&count,sizeof(unsigned int),1,fp) != 1)
    {
        return 0;
    }


    for (loop = 0; loop < count; loop ++)
    {
        if (fread(&drv,sizeof(driver_entry_t),1,fp) != 1)
        {
            return 0;
        }

        if (drv.driver_number == driver_number)
        {
            if (revision_number != NULL)
            {
                *revision_number = drv.revision_number;
            }
            if (location != NULL)
            {
                *location = REG_LOCATION_ROM;
            }
            if (description != NULL)
            {
                if (fseek(fp,drv.desc_offset,SEEK_SET)!= 0)
                {
                    return 0;
                }
                if (fread(description,drv.desc_len,1,fp) != 1)
                {
                    return 0;
                }
            }
            if (filename != NULL)
            {
                if (fseek(fp,drv.filename_offset,SEEK_SET)!= 0)
                {
                    return 0;
                }
                if (fread(filename,drv.filename_len,1,fp) != 1)
                {
                    return 0;
                }
            }
            return 1;
        }
    }
    return 0;

}
