/*
* registry.c	- List of IR peripherals and manufacturers
*/

/*
* 		Copyright 1996 Acorn Network Computing
*
* This material is the confidential trade secret and proprietary
* information of Acorn Network Computing. It may not be reproduced,
* used, sold, or transferred to any third party without the prior
* written consent of Acorn Network Computing. All rights reserved.
*
*/

#include <string.h>

#include "utils.h"


#include "registry.h"	/* For device and packet types and registry_t */

static driver_entry_t drivers[] =
{
    {0x00000000,0,"Relative pointer driver",   "IRDrivers:IRRelPtr"},
    {0x00000001,0,"Model 1 A-Z Handset driver","IRDrivers:IRHandset"},
    {0x00000002,0,"Model 1 Keyboard driver",   "IRDrivers:IRKeyboard"},
    {0x00000003,0,"Display dump",              "IRDrivers:IRDisplay"},
    {0x00000004,0,"Generic IR Blasting driver","IRDrivers:IRBlast"},
    {0x00000005,0,"RCA CRK93H1 Handset driver","IRDrivers:CRK93H1"},
    {0x00000006,0,"RCA IR Blasting driver",    "IRDrivers:RCABlast"},
    {0x00000007,0,"Default driver",            "IRDrivers:IRDefault"}

};

static registry_entry_t registry[] =
{
    {0x00000000,0x00000001,"Standard A-Z Handset"},
    {0x00000001,0x00000003,"Standard A-Z Handset with I-Point"},
    {0x00000002,0x00000002,"Relative Pointer + Buttons (Navis)"},
    {0x00000003,0x00000003,"A-Z with relative pointer"},
    {0x00000004,0x00000000,"Relative pointer and buttons for Trackboard"},
    {0x00000006,0x00000003,"Akai tablet keyboard"},
    {0x00000008,0x00000003,"Akai Relative pointer & buttons"},
    {0x00000009,0x00000003,"I-Point keyboard"},
    {0x0000000a,0x00000003,"I-Point relative pointer and buttons"},
    {0x0000000b,0x00000003,"Akai multiway switch keyboard"},
    {0x0000000c,0x00000003,"Akai multiway switch relative pointer and buttons"},
    {0x0000000d,0x00000005,"RCA CRK93H1 Handset"},
    {0x0000000e,0x00000003,"RCA IRKB4 Keyboard"}
};

static unsigned int driver_entry_count = sizeof(drivers) / sizeof(driver_entry_t);
static unsigned int registry_entry_count = sizeof(registry) / sizeof(registry_entry_t);



unsigned int reg_get_device_info(unsigned int registry_number,
                                 unsigned int *driver_number,
                                 char *description)
{
    unsigned int loop;

    for (loop = 0; loop < registry_entry_count; loop ++)
    {
        if (registry[loop].registry_number == registry_number)
        {
            if (driver_number != NULL)
            {
                *driver_number = registry[loop].driver_number;
            }
            if (description != NULL)
            {
                strcpy(description, registry[loop].description);
            }
            return 1;
        }
    }
    return 0;
}

unsigned int reg_get_driver_info(unsigned int driver_number,
                                 unsigned int *revision_number,
                                 char *description,
                                 unsigned int *location,
                                 char * filename)
{
    unsigned int loop;

    for (loop = 0; loop < driver_entry_count; loop ++)
    {
        if (drivers[loop].driver_number == driver_number)
        {
            if (revision_number != NULL)
            {
                *revision_number = drivers[loop].revision_number;
            }
            if (description != NULL)
            {
                strcpy(description, drivers[loop].description);
            }
            if (location != NULL)
            {
                *location = REG_LOCATION_ROM;
            }
            if (filename != NULL)
            {
                strcpy(filename,drivers[loop].filename);
            }
            return 1;
        }
    }
    return 0;
}
