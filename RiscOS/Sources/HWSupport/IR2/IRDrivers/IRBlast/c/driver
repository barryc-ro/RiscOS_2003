/*
 * 	driver.c	- blasting driver code.
 */

/*
 * 		Copyright 1996 Acorn Network Computing
 *
 * This material is the confidential trade secret and proprietary
 * information of Acorn Network Computing. It may not be reproduced,
 * used, sold, or transferred to any third party without the prior
 * written consent of Acorn Network Computing. All rights reserved.
 *
 */

/* From CLib */
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "utils.h"

#include "ir_api.h"
#include "driver.h"
#include "veneers.h"
#include "rcablast.h"


/*
 * Globals
 */
unsigned int ir_driver_id = 0x00000006;
static ir_client_callbacks_t callbacks =
{
    veneer_accept_data_packet,
    veneer_accept_report_packet,
    0
};


/*
    Use a message file thing in future.
*/
static _kernel_oserror errors[]=
{
    {RCAIRBlast_Error_Block + RCAIRBlast_Error_UnknownDevice,"Attempted to blast to unknown device type"},
    {RCAIRBlast_Error_Block + RCAIRBlast_Error_DeviceNumberOutOfRange,"Device number out of range"},
    {RCAIRBlast_Error_Block + RCAIRBlast_Error_CodeNumberOutOfRange,"Code number out of range"}
};

#define NVRAM_Read 0x4ee00
#define NVRAM_Write 0x4ee01

#define NV_IRTVCode    "IRTVCode"
#define NV_IRVCRCode   "IRVCRCode"
#define NV_IRCableCode "IRCableCode"


static code_table_t tv_tables[]=
{
    {0,0,0,0,0}
};

static code_table_t vcr_tables[]=
{
    {0,0,0,0,0}
};

static code_table_t cable_tables[]=
{
    {0,0,0,0,0}
};

#define TOTAL_TV_TABLES (sizeof(tv_tables)/sizeof(code_table_t))
#define TOTAL_VCR_TABLES (sizeof(vcr_tables)/sizeof(code_table_t))
#define TOTAL_CABLE_TABLES (sizeof(cable_tables)/sizeof(code_table_t))


_kernel_oserror *driver_initialise(void *pw,unsigned int reason)
{
    _kernel_oserror *err;

    NOT_USED(reason);

    callbacks.notify_flags.bits.notify_on_comp_status_report=1;

    err = ir_initialise(&callbacks,pw);
    if (!err)
    {
    }
    return err;
}

_kernel_oserror *driver_finalise(void *pw)
{
    _kernel_oserror *err=NULL;
    NOT_USED(pw);

    err = ir_finalise();
    if (!err)
    {
    }
    return err;
}


static _kernel_oserror *blast_to_tv(unsigned int tv_number,
                                    unsigned int code_number,
                                    unsigned int flags)
{
    _kernel_oserror *err=NULL;
    ir_blast_setup_t bs;

    if (tv_number < TOTAL_TV_TABLES)
    {
        bs.word = flags;
    }
    else
    {
        err = &errors[RCAIRBlast_Error_DeviceNumberOutOfRange];
    }

    return err;
}

static _kernel_oserror *blast_to_vcr(unsigned int vcr_number,
                                     unsigned int code_number,
                                     unsigned int flags)
{
    _kernel_oserror *err=NULL;
    ir_blast_setup_t bs;
    if (vcr_number < TOTAL_VCR_TABLES)
    {
        bs.word = flags;
    }
    else
    {
        err = &errors[RCAIRBlast_Error_DeviceNumberOutOfRange];
    }

    return err;
}

static _kernel_oserror *blast_to_cable(unsigned int cable_number,
                                       unsigned int code_number,
                                       unsigned int flags)
{
    _kernel_oserror *err=NULL;
    ir_blast_setup_t bs;
    if (cable_number < TOTAL_CABLE_TABLES)
    {
        bs.word = flags;
    }
    else
    {
        err = &errors[RCAIRBlast_Error_DeviceNumberOutOfRange];
    }
    return err;
}


/*
    SWI Handler for SWI RCAIRBlast_BlastToDevice

    These #define values are for masking out the
    device type and number.
*/
#define BLAST_TO_DEVICE_TYPE_MASK   0xc0000000
#define BLAST_TO_DEVICE_TYPE_SHIFT  30
#define BLAST_TO_DEVICE_NUMBER_MASK 0x3fffffff

_kernel_oserror *swi_blast_to_device(_kernel_swi_regs *r)
{
    _kernel_oserror *err;
    unsigned int type,number;

    type = (r->r[0]&BLAST_TO_DEVICE_TYPE_MASK)>> BLAST_TO_DEVICE_TYPE_SHIFT;
    number = r->r[0]&BLAST_TO_DEVICE_NUMBER_MASK;

    switch(type)
    {
        case 0:
        {
            err = blast_to_tv(number,r->r[1],r->r[2]);
            break;
        }
        case 1:
        {
            err = blast_to_vcr(number,r->r[1],r->r[2]);
            break;
        }
        case 2:
        {
            err = blast_to_cable(number,r->r[1],r->r[2]);
            break;
        }
        default:
        {
            err = &errors[RCAIRBlast_Error_UnknownDevice];
            break;
        }
    }

    return err;
}

/*
    SWI Handler for SWI RCAIRBlast_BlastToTV
*/
_kernel_oserror *swi_blast_to_tv(_kernel_swi_regs *r)
{
    unsigned int tv_number;
    _kernel_oserror *err;

    err = _swix(NVRAM_Read, _INR(0,2), NV_IRTVCode, &tv_number, 0);
    if (!err)
    {
        err = blast_to_tv(tv_number,r->r[0],r->r[1]);
    }

    return err;
}


/*
    SWI Handler for SWI RCAIRBlast_BlastToVCR
*/
_kernel_oserror *swi_blast_to_vcr(_kernel_swi_regs *r)
{
    unsigned int vcr_number;
    _kernel_oserror *err;

    err = _swix(NVRAM_Read, _INR(0,2), NV_IRVCRCode, &vcr_number, 0);
    if (!err)
    {
        err = blast_to_vcr(vcr_number,r->r[0],r->r[1]);
    }

    return err;
}


/*
    SWI Handler for SWI RCAIRBlast_BlastToCable
*/
_kernel_oserror *swi_blast_to_cable(_kernel_swi_regs *r)
{
    unsigned int cable_box_number;
    _kernel_oserror *err;

    err = _swix(NVRAM_Read, _INR(0,2), NV_IRTVCode, &cable_box_number, 0);
    if (!err)
    {
        err = blast_to_cable(cable_box_number,r->r[0],r->r[1]);
    }

    return err;
}









void driver_accept_data_packet(unsigned int registry_number,
                                unsigned char tag_number,
                                unsigned char data[3])
{
    NOT_USED(registry_number);
    NOT_USED(tag_number);
    NOT_USED(data[0]);

}




void driver_accept_report_packet(unsigned char report_code,
                                 unsigned char data[3])
{
    if (report_code == 3)/* completion status */
    {
        if (data[0]&0x20)/* blast complete */
        {
            DEBUGFN(3,db_printf("Blasting complete!\n"));
        }
    }
}


void generic_accept_data_packet(_kernel_swi_regs *r)
{
    unsigned char data[4];
    *(unsigned int *)(data) = r->r[2];

    driver_accept_data_packet((unsigned int)r->r[0],
                              (unsigned char)r->r[1],
                              data);
}



void generic_accept_report_packet(_kernel_swi_regs *r)
{
    unsigned char data[4];
    *(unsigned int *)(data) = r->r[1];
    driver_accept_report_packet((unsigned int)r->r[0],
                                data);
}

