; PPA interface driver
;
; (C) ARM Designs for Acorn/VTi
;
; Written by Jason Tribbeck
;
; email: arm.designs@argonet.co.uk
;
; This code is designed to be compiled under AAsm 2.00, NOT ObjAsm.
; As a result, you will need "s.Registers" and "s.SWIs" to be with this file.

; *****************************************************************************
; The following changes have been made to fit these sources in with the RiscOS
; build tree :
;	1) Header file Registers replaced with RiscOS system file
;	2) Header file SWIs replaced with RiscOS system files
;	3) Version information split into separate file

        GET     Hdr:ListOpts
	OPT	OptNoList
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
	GET	Hdr:Parallel
	GET	Hdr:Buffer
        LEADR   Module_LoadAddr
	OPT 	OptList

; Load in some of the Zip driver specific parameters
	GET	Hdr:IZipFS
	GET	Version

; Rich Buckley (07 Apr 1997)
; *****************************************************************************

; In most SWIs, the registers are arranged :
;
; r11 is ^ to printer port
; r12 is ^ private workspace

; UDELAY delays for several micro-seconds

	MACRO
	UDELAY
;	ROUT
;	LDRB	lr,PPASpeed
00	LDRB	r10,StatusReg
;	SUBS	lr,lr,#1
;	BGT	%b00

	MEND

; UDELAYS is the SPP UDELAY equivalent. It waits for a period of time relative to r10

	MACRO
	UDELAYS

	ROUT
	MOVS	r0,r10
00	LDRNEB	r1,[r11,#4]					; Get status
	SUBS	r0,r0,#1
	BGT	%b00

	MEND

	MACRO
	UDELAYF
	LDRB	r10,StatusReg
	MEND

	MACRO
	UDELAYW
	LDRB	r1,StatusReg
	MEND

; ZCP is a Zip connect pulse

	MACRO
	ZCP	$data

	MOV	r0,#$data
	STRB	r0,DataReg
	UDELAY

	MOV	r0,#&4					; 0100
	STRB	r0,CommandReg
	UDELAY

	MOV	r0,#&6					; 0110 Strobe address
	STRB	r0,CommandReg
	UDELAY

	MOV	r0,#&4					; 0100
	STRB	r0,CommandReg
	UDELAY

	MOV	r0,#&c					; 1100 Strobe data
	STRB	r0,CommandReg
	UDELAY

	MEND

; ZDP is a Zip disconnect pulse

	MACRO
	ZDP	$data

	MOV	r0,#$data
	STRB	r0,DataReg
	UDELAY

	MOV	r0,#&c					; 1100
	STRB	r0,CommandReg
	UDELAY

	MOV	r0,#&e					; 1110
	STRB	r0,CommandReg
	UDELAY

	MOV	r0,#&c					; 1100 Strobe address
	STRB	r0,CommandReg
	UDELAY

	MOV	r0,#&4					; 0100
	STRB	r0,CommandReg
	UDELAY

	MOV	r0,#&c					; 1100 Strobe data
	STRB	r0,CommandReg
	UDELAY

	MEND

; Constants

; The following are tunable - lower values means faster transfer, but problems may occur.
ppa_hspeed	*	3				; High speed (block) transfer (in 0.5us)
ppa_lspeed	*	12				; Slow speed (non-block) transfer (in 0.5us)

ppa_host	*	7				; This is the host of our machine (7)
swichunk	*	PPASWIChunk			; The (unallocated) SWI chunk for PPADriver
errorchunk	*	PPAErrorChunk			; Again, an unallocated error chunk

error_init1	*	0				; Error if it's not possible to connect to the Zip drive
error_read	*	1				; Error if a read operation fails...
error_printer	*	2				; Error if the printer's busy

ppa_sectorshift	*	9				; Shift value for sectors
ppa_sectorsize	*	512				; Size of a sector (used for FAST transfers)

; Error status - Do not change
ppa_ok		*	0				; Transfer was okay
ppa_error	*	&100				; PPA error
ppa_noconnect	*	&100				; Device not connected
ppa_timeout	*	&104				; Device timed out
ppa_overrun	*	&108				; Data overrun

; Flag registers for Tx - Do not change
flag_bulk	*	(1<<0)				; Used if transferring blocks of data to/from the Zip drive
flag_tx		*	(1<<1)				; Used if transmitting to the Zip drive
flag_nybble	*	(1<<2)				; Not used

;cmd_history	*	0
cmd_history	*	1				; Command history flag

cmd_historysize	*	16				; 16 entries per command history

; The private workspace

	^	0,r12
sor12		#	0				; Start of the workspace
ParallelAddress	#	4				; Address of the parallel port (always R11)
OldCR1		#	1				; The old configure register #2
OldCR4		#	1				; The old configure register #4
OldCommand	#	1				; The old command register
PPASpeed	#	1				; PPA Speed
PPAMode		#	1				; PPA Mode (0=SPP, 1=EPP)
OldIOC		#	1				; Old IOC IRQ A mask value
PPAPrinter	#	1				; Printer status
Dummies1	#	1				; Dummy bytes to pad out the registers
SCSITemp	#	512				; Temporary workspace for SCSI commands
 [ cmd_history = 1
History		#	cmd_historysize*32		; 16 bytes header, 16 bytes entry parameters
Commands	#	4				; Number of commands processed
Numbers		#	12				; 12 bytes for numbers
 ]
eor12		#	0				; End of the workspace
lor12		*	eor12-sor12			; Length of the workspace

; The printer port

	^	0,r11
DataReg		#	4				; This is the actual data bits to the printer
StatusReg	#	4				; This is the status register
CommandReg	#	4				; This controls the strobe et.al. pins
ECPAddr		#	4				; This is the EPP address port
ECPData0	#	4				; This is the EPP data port 0
ECPData1	#	4				; This is the EPP data port 0
ECPData2	#	4				; This is the EPP data port 0
ECPData3	#	4				; This is the EPP data port 0

DoReadOp	*	0				; ReadOps are not handled in this version

; This is the start of the module

s
start							; No start of code
service							; No service (yet)
	DCD	start-s					; Module start
	DCD	init-s					; Initialisation
	DCD	final-s					; Finalisation
	DCD	service-s				; Service
	DCD	title-s					; Title string
	DCD	help-s					; Help string
	DCD	hcom-s					; Help and command table
	DCD	swichunk				; SWI number (not allocated)
	DCD	swicode-s				; SWI handler
	DCD	switabl-s				; SWI table
	DCD	0					; No SWI decoding code

title	=	"PPADriver",0
help	=	"PPA Driver",9,"$vers ($date) SPP/EPPx4",0
	ALIGN

hcom	=	"IZipPrinter",0
	ALIGN
	DCD	ppa_setprinterstatus-s			; Point to command handler
	DCD	&010001
	DCD	ppasps_syntax-s				; Syntax error string
	DCD	ppasps_help-s				; Help string
 [ cmd_history = 1
	=	"IZipHistory",0
	ALIGN
	DCD	print_commandhistory-s			; And the same as above...
	DCD	0
	DCD	pch_syntax-s				; Ditto (1)
	DCD	pch_help-s				; Ditto (2)
 ]
	DCD	0

ppasps_help
	=	"IZipPrinter enables or disables the printer support for the Zip drives",10,13
ppasps_syntax
	=	"Syntax: *IZipPrinter on|off",0
 [ cmd_history = 1
pch_help
	=	"IZipHistory displays the last commands sent to the SCSI port",10,13
pch_syntax
	=	"Syntax: *IZipHistory",0
 ]
	ALIGN

switabl	=	"PPADriver",0				; SWI Group name
	=	"Initialise",0				; Initialise ZIP drive
	=	"SCSICommand",0				; Perform a SCSI command
	=	"SCSICommandRetries",0			; Perform a SCSI command with retries
 [ DoReadOp = 1
	=	"ReadOp",0				; Perform a read operation
 ]
	=	0
	ALIGN

; Module initialisation handler

init	STMFD	r13!,{r1-r9,lr}				; Store R14 (we're calling SWIs here)

 [ cmd_history = 0
	MOV	r3,#lor12				; Size of block
 |
	MOV	r3,#lor12:AND:&ff00
	ORR	r3,r3,#lor12:AND:&00ff
 ]

; I can't get the following code to work, so what the heck. Allocate a new block each initialisation
; (it's a very small block, after all!)

;	LDR	r2,[r12]				; Get the pointer
;	TEQ	r2,#0					; Is it a module initialisation, rather than RMTidy?
;	BNE	init_clearmemory			; Yup, so clear it, and set up the pointers

	MOV	r0,#6					; Start of module memory claim
	SWI	XOS_Module				; Claim the memory
	LDMVSFD	r13!,{lr}				; Ooops - can't claim - recall exit
	ORRVSS	pc,lr,#1<<26				; Set V, but preserve other flags

	STR	r2,[r12]				; Store that in the pointer

init_clearmemory
	MOV	r0,#0

	MOV	r7,r12					; We need this for the filing system...
	MOV	r12,r2					; Set R12 to the workspace memory

init_cm1
	STR	r0,[r2],#4
	SUBS	r3,r3,#4
	BGT	init_cm1				; Clear memory loop

	SWI	XParallel_HardwareAddress		; I hope this is on the NC, and the registers are as I hope they are
	STR	r0,ParallelAddress

	MOV	r0,#1
	STRB	r0,PPASpeed				; Set the PPA speed to default values
	STRB	r0,PPAPrinter				; And also the printer status (enabled)

	BL	ConfigureEPP

	LDMFD	r13!,{r1-r9,lr}				; Read the return register
	BICS	pc,lr,#1<<28				; Clear V, just in case it's been set

; Finalisation handler

final	STMFD	r13!,{r14}
	LDR	r12,[r12]

	BL	DeconfigureEPP

	LDMFD	r13!,{pc}

; Standard SWI handler

swicode	LDR	r12,[r12]				; Get workspace pointer
	CMP	r11,#(ukswi-swijump)/4			; Is the SWI table too high?
	ADDCC	pc,pc,r11,LSL#2
	BCS	ukswi

swijump	B	Initialise
	B	SCSICommand
	B	SCSICommandRetries
 [ DoReadOp = 1
	B	ReadOp
	MOVS	pc,lr
 |
	MOVS	pc,lr
	MOVS	pc,lr
 ]

ukswi	ADR	r0,ukswie				; Point to error
	ORRS	pc,lr,#1<<28				; Set V and exit

ukswie	DCD	&1e6
	=	"Unknown PPADriver operation",0
	ALIGN

; SCSI Initialise - determine if the Zip drive is present, and also if we have to use nybble read-transfers or not.

Initialise
	STMFD	r13!,{r0-r3,lr}

	LDR	r11,ParallelAddress


;	BL	WaitPrinter

	BL	DisableIRQ
	STRVS	r0,[r13]
	LDMVSFD	r13!,{r0-r3,pc}

	BL	ZipDisconnect				; Just in case!
	BL	ZipConnectSPP				; Connect to the ZIP drive

	MOV	r0,#6
	STRB	r0,CommandReg

	LDRB	r0,StatusReg				; Get the status register
	AND	r1,r0,#&f0				; Clear bottom 4 bits
	TEQ	r1,#&f0					; If everything else is on, then all is okay!
	BEQ	Initialise_Pass2

; Failure from port - first indication that it's not plugged in

Initialise_Fail1
	BL	EnableIRQ
	LDMFD	r13!,{r0-r3,lr}
	ADR	r0,inite2				; Point to error
	ORRS	pc,lr,#1<<28				; Set V on exit

inite2	DCD	errorchunk+error_init1
	=	"Bad response from Zip Drive - is it plugged in?",0
	ALIGN

Initialise_Pass2
	UDELAY

	MOV	r0,#4
	STRB	r0,CommandReg
	UDELAY

	LDRB	r0,StatusReg
	AND	r1,r0,#&f0
	TEQ	r1,#&80					; If BUSY is high, then it's okay
	BNE	Initialise_Fail1

	UDELAY

;	BL	ZipDisconnect				; Disconnect from Zip drive
	MOV	r0,#&40
	STRB	r0,DataReg
	UDELAY

	MOV	r0,#&8
	STRB	r0,CommandReg
	UDELAY

	MOV	r0,#&c
	STRB	r0,CommandReg
	UDELAY

	BL	ZipDisconnect

	BL	EnableIRQ
	LDMFD	r13!,{r0-r3,lr}
	BICS	pc,lr,#1<<28				; Exit cleanly

; ZipConnect connects using EPP mode

ZipConnect
	STMFD	r13!,{r0-r1,lr}
;	MOV	r0,#1
;	BL	EnsureECPMode
	ZCP	&00
	ZCP	&3c
	ZCP	&20
;	ZCP	&8f
	ZCP	&cf
	LDMFD	r13!,{r0-r1,pc}

; ZipConnectSPP connects using SPP mode

ZipConnectSPP
	STMFD	r13!,{r0-r1,lr}
;	MOV	r0,#1
;	BL	EnsureECPMode
	ZCP	&00
	ZCP	&3c
	ZCP	&20
	ZCP	&8f
	LDMFD	r13!,{r0-r1,pc}

; ZipDisconnect is the generic disconnection code
; All registers are preserved. Status is not.

ZipDisconnect
	STMFD	r13!,{r0-r1,lr}
;	MOV	r0,#1
;	BL	EnsureECPMode
	ZDP	&00
	ZDP	&3c
	ZDP	&20
	ZDP	&0f
	LDMFD	r13!,{r0-r1,pc}

; Select
; This selects the SCSI target of the Zip drive
; r0 is initiator (although not actually used), r1 is target
; Returns r0 as status register from printer port

Select
	STMFD	r13!,{r1-r3,r10,lr}

	MOV	r3,#1<<ppa_host

	MOV	r2,#1
	MOV	r2,r2,LSL r1

	LDRB	r0,StatusReg

	STRB	r2,DataReg				; Target LUN
	UDELAY

	MOV	r2,#&0e					; 1110
	STRB	r2,CommandReg
	UDELAY

	MOV	r2,#&0c					; 1100 Strobe Data
	STRB	r2,CommandReg
	UDELAY

	STRB	r3,DataReg				; Initiator LUN
	UDELAY

	MOV	r2,#&08					; 1000
	STRB	r2,CommandReg
	UDELAY

; The next bit of code is similar to Wait - see the description below...

	MOV	r2,#65536<<2
;	MOV	r2,#16384
Select_Loop1
	LDRB	r0,StatusReg				; Read the status register
	ANDS	r0,r0,#&f0				; Mask off the unwanted bits
	LDMNEFD	r13!,{r1-r3,r10,pc}			; It's okay to proceed...

	SUBS	r2,r2,#1
	BGT	Select_Loop1				; Wait until timeout

	LDMFD	r13!,{r1-r3,r10,pc}

; Wait waits until it gets an acknowledgement from the Zip drive, or until it
; has had enough. The 65536<<2 is a long enough time for a slow command, but
; short enough for the machine not to slow down too much if the drive was
; unplugged in the middle of a transfer

Wait
	STMFD	r13!,{r1-r2,lr}

	MOV	r2,#65536<<2
;	MOV	r2,#16384
Wait_Loop1
	LDRB	r1,StatusReg
	TST	r1,#&80					; Is the high bit set?
	BNE	Wait_Eloop1
	SUBS	r2,r2,#1				; Decrement the timer
	BGT	Wait_Loop1

	BL	ZipDisconnect				; Disconnect
	BL	EnableIRQ
	MOV	r0,#0					; Signal there was a failure
	LDMFD	r13!,{r1,r2,pc}				; Return

Wait_Eloop1
	AND	r0,r1,#&f0				; Mask off the unwanted bits
	LDMFD	r13!,{r1,r2,pc}				; And return

; SCSICommandRetries performs upto 5 SCSICommand calls. Entry and exit
; parameters are the same as SCSICommand

SCSICommandRetries
	STMFD	r13!,{r0-r4,lr}
	MOV	r4,#5

SCRLoop	BL	SCSICommand				; Perform the SCSI command

	TEQ	r0,#2
	BEQ	SCRStat
	TEQ	r0,#0					; Success!
	ADDEQ	r13,r13,#16
	LDMEQFD	r13!,{r4,pc}^

SCRCont	SUBS	r4,r4,#1				; Failure, but if we've done the 5...
	ADDEQ	r13,r13,#16				; ...commands, return back...
	LDMEQFD	r13!,{r4,pc}^				; ...to whence we came...

	BL	Initialise
	SUBS	r4,r4,#1
	LDMIA	r13,{r0-r3}
	B	SCRLoop

StatCmd
	=	3,&c0,0,0
	=	255,0,0,0

SCRStat	ADR	r0,StatCmd
	MOV	r1,#6
	ADR	r2,SCSITemp
	MOV	r3,#255
	BL	SCSICommand

	TEQ	r0,#0
	BNE	SCRCont					; If it didn't succeed, reinitialise...

	SUBS	r4,r4,#1				; Failure, but if we've done the 5...
	ADDEQ	r13,r13,#16				; ...commands, return back...
	LDMEQFD	r13!,{r4,pc}^				; ...to whence we came...

	SUBS	r4,r4,#1
	LDMIA	r13,{r0-r3}
	B	SCRLoop

; SCSICommand sends a SCSI command to the ZIP drive
; r0 is pointer to SCSI command header
; r1 is length of header
; r2 is pointer to Rx/Tx block (can overlap with command)
; r3 is length to Rx/Tx (must be the right size)
; returns r0 as 0 for success, or error type for failure (0-&FF is SCSI status, &100+ is other error)
; returns r2 as pointer to end of Rx/Tx block
; returns r3 as #bytes left to transfer

SCSICommand
	STMFD	r13!,{r1-r10,lr}
 [ cmd_history = 1
	BL	add_history
 ]

	LDR	r11,ParallelAddress

;	BL	WaitPrinter

	LDRB	r9,[r0,#1]				; Get LUN etc.
	MOV	r9,r9,LSR#5				; Mask out the LUN
	TEQ	r9,#ppa_host				; Is it me?
	BEQ	SCSIMeUp				; Then go to it!

	MOV	r6,r0					; Store TX pointer...
	MOV	r7,r1					; ... and length
	MOV	r1,r9					; Get initiator
	MOV	r8,r2					; Store RX pointer...
	MOV	r9,r3					; ... and length

	BL	DisableIRQ

	LDRB	r0,PPAMode
	TEQ	r0,#0					; If it's SPP mode...
	BEQ	SC_SPP					; ...do the SPP transfer

 [ cmd_history = 1
	BLVS	end_command
 ]
	LDMVSFD	r13!,{r1-r10,pc}

; This is the EPP SCSI routine.

	BL	ZipConnect				; Connect to the Zip drive using EPP mode

	MOV	r0,#ppa_host
	BL	Select					; Set the initator and target

	TEQ	r0,#0					; Did the device select?
	BNE	SC_Selected				; Yup, so carry on!
	B	SC_Error

SC_Error4
	MOV	r1,#&0c
	STRB	r1,CommandReg				; We were in non-status mode; return back to normal

SC_Error
	MOV	r0,#1
	STRB	r0,StatusReg				; Cancel the EPP timeout

	BL	ZipDisconnect				; It didn't, so disconnect
	BL	EnableIRQ
	MOV	r0,#ppa_noconnect			; Set error...
 [ cmd_history = 1
	BL	end_command
 ]
	LDMFD	r13!,{r1-r10,pc}^			; ...and exit

SC_Selected
	MOV	r2,#0
	MOV	r0,#1
	STRB	r0,StatusReg				; Cancel any prepending EPP timeout

; This is the EPP SCSI command loop.

SC_CommandLoop
	MOV	r0,#&c
	STRB	r0,CommandReg				; Enter status mode
	BL	Wait
	TEQ	r0,#0
	BEQ	SC_Error				; If the drive hasn't acknowledged, return
	MOV	r0,#&4
	STRB	r0,CommandReg				; Leave status mode
	UDELAY

	LDRB	r0,[r6,r2]
	TEQ	r2,#1
	ANDEQ	r0,r0,#31				; Remove the LUN (the Zip drive doesn't like it!)...
	STRB	r0,ECPData0				; ...and transmit the byte
	UDELAY

	LDRB	r0,StatusReg
	TST	r0,#1
	BNE	SC_Error4

	ADD	r2,r2,#1
	CMP	r2,r7
	BLT	SC_CommandLoop				; If we haven't sent all the bytes, return!

	MOV	r0,#&c
	STRB	r0,CommandReg				; Enter status mode
	UDELAY
	BL	Wait					; Wait for the drive to acknowledge it
	TEQ	r0,#0
	BEQ	SC_Error				; Unless it timed out...

; This is the EPP SCSI command loop. The first few lines checks to see if the
; drive thinks we've finished or not...

SC_CLoop
	AND	r0,r0,#&f0
	TEQ	r0,#&c0
	MOVEQ	r7,#0					; &d0 is READ, &c0 is WRITE, &f0 is status
	MOVNE	r7,#1

SC_Loop
	LDRB	r1,StatusReg
	AND	r0,r1,#&f0
	TEQ	r0,#&c0					; Is it a valid response?
	TEQNE	r0,#&d0
	TEQNE	r0,#&f0
	BNE	SC_Error				; No, so signal an error
	TEQ	r0,#&f0
	BEQ	SC_EndCommand				; If it's the EOC, get the status

SC_SLoop
	CMP	r9,#ppa_sectorsize			; Do we have more than 512 bytes of data to send?
	BLT	SC_DLoop				; Nope, so do a slower transfer

	MOV	r0,#&0c
	STRB	r0,CommandReg				; Enter status mode

	BL	Wait					; Wait for the drive to signal that it is ready
	MOV	r0,#&04
	STRB	r0,CommandReg				; Leave status mode
	UDELAY

	MOV	r6,#ppa_sectorsize			; This is the amount we're going to transfer

	ADR	r4,ECPData0				; Used for optimisation

	TEQ	r7,#1
	BEQ	SC_FRx					; If we're receiving data, receive it

; This is the EPP mode fast Tx. It uses the 4 EPP data registers available
; from the UMC device in order to provide a slight speed increase.

SC_FTx
	LDRB	r0,[r8],#1				; Pity this can't be guaranteed to be word aligned
	LDRB	r1,[r8],#1
	LDRB	r2,[r8],#1
	LDRB	r3,[r8],#1
	STMIA	r4,{r0-r3}				; Use an effectual 32-bit transfer
	SUBS	r9,r9,#4				; 4 bytes at a time...
	SUBS	r6,r6,#4
	BGT	SC_FTx					; ...until we've transmitted one sector
	B	SC_SLoop

; This is the EPP mode fast Rx. It uses the 4 EPP data registers available
; from the UMC device in order to provide a slight speed increase.

SC_FRx
	LDMIA	r4,{r0-r3}				; Read 32-bits
	STRB	r0,[r8],#1
	STRB	r1,[r8],#1
	STRB	r2,[r8],#1
	STRB	r3,[r8],#1				; And store each of them
	SUBS	r9,r9,#4
	SUBS	r6,r6,#4				; Do this for every 4 bytes...
	BGT	SC_FRx					; ...until the sector's done
	B	SC_SLoop

; This is the routine which performs a slower transfer of data from the
; drive, as it waits for an acknowledgement for each piece of data.

SC_DLoop
SC_WLoop2
	MOV	r0,#&0c
	STRB	r0,CommandReg				; Enter status mode

	BL	Wait					; Wait for the drive to become ready
	TEQ	r0,#0
	BEQ	SC_Error

	TST	r0,#1
	BNE	SC_Error4
	TEQ	r0,#&f0
	BEQ	SC_EndDLoop				; If the end is nigh, read the status

	MOV	r0,#&04
	STRB	r0,CommandReg				; Leave status mode

	CMP	r9,#0					; Is there any more to do?
	BLT	SC_FakeTxRx

	TEQ	r7,#1					; If we're in write mode...
	LDRNEB	r0,[r8],#1
	STRNEB	r0,ECPData0				; ...store the byte...
	LDREQB	r0,ECPData0
	STREQB	r0,[r8],#1				; ...otherwise, read the byte

	SUBS	r9,r9,#1

	B	SC_DLoop

; We've run out of data to transfer (either into our buffer, or out from our
; buffer), so do null transfers.

SC_FakeTxRx

	TEQ	r7,#1
	MOVNE	r0,#0
	STRNEB	r0,ECPData0				; Fake a transfer one way...
	LDREQB	r0,ECPData0				; ...or the other

	B	SC_DLoop

; This is the EPP mode end of code routine. It fetches the status byte from
; the drive, so it can determine how the operation went.

SC_EndDLoop
SC_EndCommand
	MOV	r1,#&0c
	STRB	r1,CommandReg				; Status mode...
	UDELAY

	MOV	r0,#4
	STRB	r0,CommandReg				; ...for a bit
	UDELAY

	LDRB	r3,ECPData0				; This is the returned status

	MOV	r0,#&c
	STRB	r0,CommandReg				; Status mode...

	BL	Wait

	MOV	r0,#4
	STRB	r0,CommandReg				; ...again for a bit
	UDELAY

	LDRB	r0,ECPData0				; This is not needed by us, but the drive seems to like it

	MOV	r0,#&c
	STRB	r0,CommandReg				; Enter status mode

	BL	ZipDisconnect				; And disconnect from the Zip drive
	BL	EnableIRQ
	MOV	r0,r3					; Return with the status
 [ cmd_history = 1
	BL	end_command
 ]
	STMIB	r13,{r8,r9}				; Oh, and update the data pointer/length
	LDMFD	r13!,{r1-r10,pc}^

; This is the SPP handler code, migrated from PPADriver 0.80

SC_SPP
	MOV	r10,#ppa_lspeed				; The slow speed for the initial part of transfer
	BL	ZipConnectSPP				; Connect to the Zip drive

	MOV	r0,#ppa_host
	BL	Select					; Set the initator and target

	TEQ	r0,#0					; Did the device select?
	BNE	SC_SelectedSPP				; Yup, so carry on!

	BL	ZipDisconnect				; It didn't, so disconnect
	BL	EnableIRQ
	MOV	r0,#ppa_noconnect			; Set error...
	LDMFD	r13!,{r1-r10,pc}^			; ...and exit

; This is the SPP mode code.

SC_SelectedSPP
	MOV	r3,#&0e
	MOV	r4,#&0c

	STRB	r4,CommandReg
	UDELAY

; The first thing to do is transfer the SCSI command. Then, the data follows.

	MOV	r5,#0					; This is how much we've transmitted
SC_TxHLoop
	BL	Wait

	TEQ	r0,#0					; Did the wait finish successfully?
	MOVEQ	r0,#ppa_timeout				; No - it timed out..
 [ cmd_history = 1
	BLEQ	end_command
 ]
	LDMEQFD	r13!,{r1-r10,pc}^			; ...and exit

	LDRB	r0,[r6,r5]				; Get the byte
	TEQ	r5,#1					; Is it the target byte?
	ANDEQ	r0,r0,#31				; Yes, so mask off the LUN
	STRB	r0,DataReg				; Store it
;	UDELAY

	STRB	r3,CommandReg
	UDELAYS

	STRB	r4,CommandReg				; Tell the port what command it was
	UDELAYS

	ADD	r5,r5,#1
	TEQ	r5,r7					; Have we reached the end yet?
	BNE	SC_TxHLoop

	MOV	r10,#ppa_hspeed				; Gonna do it FAST

	BL	Wait
	TEQ	r0,#0
	MOVEQ	r0,#ppa_timeout
 [ cmd_history = 1
	BLEQ	end_command
 ]
	LDMEQFD	r13!,{r1-r10,pc}^

; r6 and r7 can now be freed for other things...

	LDRB	r2,[r6,#0]				; However, we need to get the command byte
	AND	r2,r2,#31
	TEQ	r2,#&08					; Is it Read_6?
	TEQNE	r2,#&0a					; Or Write_6?
	TEQNE	r2,#&28					; Or Read_10?
	TEQNE	r2,#&2a					; Or Write_10?

	MOVEQ	r7,#flag_bulk				; Yes, so mark the bulk flag
	MOVNE	r7,#0					; Nope - it's an ordinary transfer

	BL	Wait					; Wait for a response
	TEQ	r0,#&c0					; Is it a Tx?
	ORREQ	r7,r7,#flag_tx				; Set the Tx flag then!

	MOVEQ	r3,#&0e					; If it's Tx, then use these two values for pin wiggling
	MOVEQ	r4,#&0c

	MOVNE	r3,#&25					; ...and these two for Rx
	MOVNE	r4,#&27

	TEQ	r0,#0					; This is the reply from the previous Wait call...
SC_TxRxLoopTO
	MOVEQ	r0,#ppa_timeout				; Ooh dear, looks like a timeout...
	LDMEQFD	r13!,{r1-r10,pc}^			; ... so we'd better exit then

	TEQ	r0,#&f0
	BEQ	SC_TxRxEpilogue

; SC_TxRxLoop performs a SCSI data transfer of a certain number of bytes,
; upto a maximum of 1 sector. Above that, the data is transferred a sector at
; a time. If there is less than 1 sector, a slower transfer has to be used.

SC_TxRxLoop
	AND	r1,r0,#&c0
	TEQ	r1,#&c0					; Is everything okay?
	BNE	SC_TxRxOverrun				; We've overstayed our welcome!

	CMP	r9,#0					; Have we gone too far?
	BGT	SC_TxRxOkay				; Nope, so carry on getting/putting data

	SUBS	r9,r9,#1				; Decrement counter

	STRB	r3,CommandReg				; 'Fake' a transfer
	UDELAYS

	STRB	r4,CommandReg				; And the second half
	UDELAYS

	TEQ	r3,#&25
	BNE	SC_TxRxE

	MOV	r0,#&5
	STRB	r0,CommandReg
	UDELAYS

	MOV	r0,#&4
	STRB	r0,CommandReg
	UDELAYS

	MOV	r0,#&c
	STRB	r0,CommandReg
	UDELAYS

	B	SC_TxRxE				; And go on to the next stage

SC_TxRxOverrun
	BL	ZipDisconnect				; Yes, so disconnect from the ZIP drive...
	BL	EnableIRQ
	MOV	r0,#ppa_overrun				; Mark the error...
	LDMFD	r13!,{r1-r10,pc}^			; ...and exit

SC_TxRxOkay

	TST	r7,#flag_bulk				; Is it a bulk transfer?
	BEQ	SC_TxRxNotBulk				; Nope it isn't

	CMP	r9,#ppa_sectorsize			; Is there enough data left to transmit the block?
	BLE	SC_TxRxNotBulk				; No, so do it slowly

	TST	r7,#flag_tx
	BEQ	SC_TxRxFRx				; Do a fast receive of ppa_sectorsize bytes

; SC_TxRxFTxL is a SCSI Tx/Rx command, fast Tx loop. It is only used in SPP
; mode, and works on blocks of 512 bytes (ie. 1 sector)

	MOV	r2,#ppa_sectorsize
SC_TxRxFTxL
	LDRB	r0,[r8],#1				; Get the byte
	STRB	r0,DataReg
	UDELAYS

	STRB	r3,CommandReg
	UDELAYS

	STRB	r4,CommandReg
	UDELAYS

	SUB	r9,r9,#1				; Decrement how many sectors we have to transmit...
	SUBS	r2,r2,#1				; ...and how far we are into this sector...
	BNE	SC_TxRxFTxL				; ...if it's not enough, do some more!

	B	SC_TxRxE				; Skip to the end of the main transfer loop

; SC_TxRxFRx is a SCSI Tx/Rx command, which is a fast Rx. It is used in SPP
; mode only, and works on blocks of 512 bytes.

SC_TxRxFRx
	MOV	r2,#ppa_sectorsize
SC_TxRxFRxL
	STRB	r3,CommandReg
	UDELAYS

	LDRB	r0,DataReg
	STRB	r0,[r8],#1				; Store the received byte

	STRB	r4,CommandReg
	UDELAYW

	MOV	r0,#&5
	STRB	r0,CommandReg
	UDELAYW

	MOV	r0,#&4
	STRB	r0,CommandReg
	UDELAYW

	MOV	r0,#&c
	STRB	r0,CommandReg
	UDELAYW

	SUB	r9,r9,#1				; Decrement how many bytes we have left to receive...
	SUBS	r2,r2,#1				; ...and how far we are into this sector...
	BGT	SC_TxRxFRxL				; ...if it's not enough, do some more!

	B	SC_TxRxE				; Skip to where it waits again

; SC_TxRxNotBulk is a SCSI Tx/Rx command, where the data size is not a sector
; or more in length. It is used in SPP mode only.

SC_TxRxNotBulk
	TST	r7,#flag_tx				; Are we transmitting?
	BEQ	SC_TxRxSRx				; No, so do the receive instead

	LDRB	r0,[r8],#1				; Get the byte
	STRB	r0,DataReg
	UDELAYS

	STRB	r3,CommandReg
	UDELAYS

	STRB	r4,CommandReg
	UDELAYS

	SUB	r9,r9,#1				; Decrement how many we need to do

; The next bit is the bit which slows it down - it waits for the Zip drive to
; acknowledge the byte. For sector size transfers, this only needs to be
; performed each sector.

SC_TxRxE
	BL	Wait					; Wait for a response

	TEQ	r0,#0					; Has it timed out?
	BEQ	SC_TxRxLoopTO				; Yes, it's timed out

	TEQ	r0,#&f0					; Does the Zip drive expect any more data to be transferred?
	BNE	SC_TxRxLoop				; Yes, so give it some more

; This is the SPP mode end of data transmission code. It fetches the status
; byte from the drive.

SC_TxRxEpilogue
	MOV	r10,#ppa_lspeed				; Choose a slower speed

	MOV	r0,#&04
	STRB	r0,CommandReg				; Prepare to get the status byte
	UDELAYS

	LDRB	r2,StatusReg				; Get high nybble

	MOV	r0,#&06
	STRB	r0,CommandReg
	UDELAYS

	LDRB	r3,StatusReg				; Get low nybble

	MOV	r0,#&0c
	STRB	r0,CommandReg
	UDELAYS

	AND	r2,r2,#&f0
	ORR	r3,r2,r3,LSR#4				; Merge the two together...

	MOV	r0,#&0e
	STRB	r0,CommandReg
	UDELAYS

	MOV	r0,#&0c
	STRB	r0,CommandReg
	UDELAYS

	BL	ZipDisconnect

	BL	EnableIRQ
	MOV	r0,r3					; Return status register
 [ cmd_history = 1
	BL	end_command
 ]
	STMIB	r13,{r8,r9}				; Update r2 and r3
	LDMFD	r13!,{r1-r10,pc}^

SC_TxRxSRx
	STRB	r3,CommandReg
	UDELAYS

	LDRB	r0,DataReg
	STRB	r0,[r8],#1				; Store the received byte

	STRB	r4,CommandReg
	UDELAYS

	MOV	r0,#&5
	STRB	r0,CommandReg
	UDELAYS

	MOV	r0,#&4
	STRB	r0,CommandReg
	UDELAYS

	MOV	r0,#&c
	STRB	r0,CommandReg
	UDELAYS

	SUB	r9,r9,#1				; Decrement how many bytes we need to receive
	B	SC_TxRxE

; SCSIMeUp is code that handles SCSI activity to the host (ie ourselves)
; It currently only handles ID.

SCSIMeUp
	LDRB	r9,[r0]					; Find out what command it was
	TEQ	r9,#&12					; Is it device inqury?
	MOVNE	r0,#&fe					; Bad command
	LDMNEFD	r13!,{r1-r10,pc}^
	ADR	r4,MyInquiry
SMU_12L	LDRB	r0,[r4],#1				; Copy the command over...
	STRB	r0,[r2],#1				; ...to the SCSI data buffer
	SUBS	r3,r3,#1
	BGT	SMU_12L
	MOV	r0,#0					; This returned okay
 [ cmd_history = 1
	BL	end_command
 ]
	LDMFD	r13!,{r1-r10,pc}^

; MyInquiry is basically a memory pointer which is a fake SCSI ID result,
; used for the host.

MyInquiry
	=	&7f,&00,&00,&02
	=	MI_End-MI_CPtr
MI_CPtr	=	&00,&00,&00
	=	"ARMDSGNS"
	=	"Acorn ZIP Driver"
	=	"0000"
	=	"© Jason Tribbeck '96"
	%	40
	=	"For Acorn Computers/VTi",0,0
MI_End
	ALIGN

ConfigureEPP
	STMFD	r13!,{r0-r4,r11,lr}
	LDR	r11,ParallelAddress
	ADD	r11,r11,#(&3f0-&278)<<2			; Point to the configuration register
	MOV	r0,#&55
	STRB	r0,[r11,#0]
	STRB	r0,[r11,#0]				; Enter configuration mode

	MOV	r0,#13
	STRB	r0,[r11,#0]
	LDRB	r0,[r11,#4]				; Read register 13 (which is chip ID)
	TEQ	r0,#&66					; &66 is FDC37C666
	TEQNE	r0,#&65					; &65 is FDC37C665

; Although to be strictly speaking, Acorn/NC don't use the 37C666, this code
; would work on it, should it be fitted.

	MOVNE	r0,#0
	MOVEQ	r0,#1
	STRB	r0,PPAMode

	MOV	r0,#&aa
	STRB	r0,[r11,#0]
	LDMFD	r13!,{r0-r4,r11,pc}^

DeconfigureEPP
	MOVS	pc,lr

 [ DoReadOp = 1

; This is not compiled in. There was the potential of having a different boot
; system, where a number of sector would contain some code which would be
; booted. This was removed, when it was found that FileCore would be present
; in the NC release.

; MakeRWCommand creates a 10-byte read/write command in SCSITemp
; On entry, r0 is command byte (&28 for read, &2a for write)
; On exit, r0 is corrupted

MakeRWCommand
	ORR	r0,r0,#&c000				; Use LUN 6 (Zip)
	STR	r0,SCSITemp+0				; Store the command and LUN
	MOV	r0,#0
	STR	r0,SCSITemp+4				; Some other bits
	STR	r0,SCSITemp+8				; And some more bits
	MOVS	pc,lr

; SetSector sets the 10-byte read/write command's sector
; On entry, r0 is sector number (for Zip, 0->&2ffff)
; On exit, r0 is corrupted

SetSector
	STRB	r0,SCSITemp+5				; LLSB
	MOV	r0,r0,LSR#8
	STRB	r0,SCSITemp+4				; MLSB
	MOV	r0,r0,LSR#8
	STRB	r0,SCSITemp+3				; LMSB
	MOV	r0,r0,LSR#8
	STRB	r0,SCSITemp+2				; MMSB
	MOVS	pc,lr

; SetSectors sets the 10-byte read/write command's number of sectors to read
; On entry, r0 is #sectors 0 to &ffff
; On exit, r0 is corrupted

SetSectors
	STRB	r0,SCSITemp+8				; LSB
	MOV	r0,r0,LSR#8
	STRB	r0,SCSITemp+7				; MSB
	MOVS	pc,lr

; SectorOp performs the read/write sector
; r1 is the number of bytes to transfer
; On exit, r0 is 0 for success, or error code for failure
; r1 is the number of bytes not transferred

SectorOp
	STMFD	r13!,{r2-r3,lr}
	MOV	r2,r0					; Point to data
	MOV	r3,r1					; And the #bytes
	ADR	r0,SCSITemp				; Point to command
	MOV	r1,#10					; 10 byte long command
	BL	SCSICommand				; Perform the SCSI command
	MOVS	r1,r3					; This is how many bytes not read
	MOVMI	r1,#0					; Due to a slight problem with PPA3, an extra byte is read
	LDMFD	r13!,{r2-r3,pc}^			; Exit (SCSICommand will set up the error)

; ReadOp is a FileCore_DiscOp compliant sector reader
; On entry:
; r2 is disc address (doesn't have to be sector aligned)
; r3 is pointer to buffer
; r4 is length (doesn't have to be sector aligned, but it helps!)
; On exit:
; r2 as disc address of next byte
; r3 as pointer to next buffer
; r4 as number of bytes not transferred

Read
ReadOp

	CMP	r4,#0					; If there's no data, don't do it
	MOVLES	pc,lr

	STMFD	r13!,{r0,r1,lr}

	MOV	r0,#&28
	BL	MakeRWCommand

	MOV	r1,#ppa_sectorsize
	SUB	r1,r1,#1


	BIC	r0,r2,#7<<29				; Mask out drive
	MOV	r0,r0,LSR#ppa_sectorshift
	BL	SetSector				; And make the sector number

	ADD	r0,r4,r1
	MOV	r0,r0,LSR#ppa_sectorshift
	BL	SetSectors				; Set how many sectors we're reading

	MOV	r0,r3					; Data pointer
	MOV	r1,r4					; Data length

	ADD	r2,r2,r4				; Add the end
	ADD	r3,r3,r4				; Do the same for the buffer

	BL	SectorOp				; Read the sector(s)
	TEQ	r0,#0
	BNE	RO_Error				; There's an error - put everything back, and make up a response

	SUB	r2,r2,r1				; If any's been unread, decrement address
	SUB	r3,r3,r1				; Similarly, for sectors
	MOV	r4,r1
	LDMFD	r13!,{r0,r1,lr}
	BICS	pc,lr,#1<<28				; And exit

RO_Error
;
; This code is temporary - I'll produce a proper error code if I need to, later.
;
	LDMFD	r13!,{r0,r1,lr}
	ADR	r0,ROErr				; Point to error
	ORRS	pc,lr,#1<<28				; And exit

ROErr	DCD	errorchunk+error_read
	=	"Read error from Zip drive",0
	ALIGN

PrintBin
	STMFD	r13!,{r0-r1,lr}
	SWI	&20100+'('
	SWI	&20100+'%'
	MOV	r1,#128
IF1	TST	r0,r1
	SWINE	&20100+'1'
	SWIEQ	&20100+'0'
	MOVS	r1,r1,LSR#1
	BNE	IF1
	SWI	&20100+')'
	LDMFD	r13!,{r0-r1,pc}^
 ]

parallel
	=	"parallel:",0
	ALIGN

; DisableIRQ doesn't actually disable the IRQ - it just waits until the
; printer buffer is empty, up to 5 seconds. It also enables the EPP mode, and
; disables the ECP mode. It used to disable the IRQ, however.

DisableIRQ
	STMFD	r13!,{r0-r4,r11,lr}

	LDRB	r0,CommandReg
	STRB	r0,OldCommand				; Store the old command register

	STMFD	r13!,{r5-r7}
	LDRB	r0,PPAPrinter
	TEQ	r0,#0
	BEQ	EDIL					; If we're not waiting for printers, skip the code

	STMFD	r13!,{r0,r9}
	MOV	r0,#0
	MOV	r9,#0
	SWI	&6144c					; This is PrintQueue_PauseResume - disabling queue
	LDMFD	r13!,{r0,r9}

	SWI	XOS_ReadMonotonicTime
	MOV	r7,r0					; Store the time at which we started doing this call
DIL	MOV	r0,#3
	SWI	XBuffer_GetInfo				; Get the number of characters in the printer buffer
	CMP	r6,#0					; Are there any?
	BEQ	EDIL					; Nope, so we can actually return
	SWI	XOS_ReadMonotonicTime
	SUB	r0,r0,r7
	CMP	r0,#512					; If we haven't cleared the buffer after 5.12 seconds...
	BLT	DIL					; ...try again!

	LDMFD	r13!,{r5-r7}
	LDMFD	r13!,{r0-r4,r11,lr}			; Restore all the registers

	ADR	r0,DI_Error
	ORRS	pc,lr,#1<<28
DI_Error
	DCD	errorchunk+error_printer
	=	"The printer port is busy, and the Zip drive cannot be accessed.",0
	ALIGN

EDIL
	LDMFD	r13!,{r5-r7}

	LDRB	r0,PPAMode
	TEQ	r0,#1					; SPP mode doesn't need reconfiguring each time
	LDMNEFD	r13!,{r0-r4,r11,lr}
	BICNES	pc,lr,#1<<28


	LDR	r11,ParallelAddress
	ADD	r11,r11,#(&3f0-&278)<<2			; Point to the configuration register

	MOV	r0,#&55
	STRB	r0,[r11,#0]
	STRB	r0,[r11,#0]				; Enter configuration mode

	MOV	r0,#1
	STRB	r0,[r11,#0]
	LDRB	r1,[r11,#4]
	STRB	r1,OldCR1
	STRB	r0,[r11,#0]
	ORR	r1,r1,#4
	BIC	r1,r1,#8
	STRB	r1,[r11,#4]				; Store new CR1

	MOV	r0,#4
	STRB	r0,[r11,#0]
	LDRB	r1,[r11,#4]
	STRB	r1,OldCR4
	BIC	r1,r1,#3
	ORR	r1,r1,#&01				; Enable EPP 1.9, and EPP/SPP mode ONLY
	STRB	r0,[r11,#0]
	STRB	r1,[r11,#4]				; Store new CR4

	MOV	r0,#&aa
	STRB	r0,[r11,#0]				; Return the configuration mode back to normal
	LDMFD	r13!,{r0-r4,r11,lr}
	BICS	pc,lr,#1<<28

; Similarly, EnableIRQ doesn't enable the IRQ - it returns the mode back to
; ECP/SPP. For historical reasons it is called EnableIRQ, because that's what
; it did.

EnableIRQ
	STMFD	r13!,{r0-r4,r11,lr}

	LDRB	r0,PPAMode				; What mode are we in?
	TEQ	r0,#0					; SPP mode - we didn't configure it, honest!
	BEQ	EI_NotEPP

	LDR	r11,ParallelAddress
	ADD	r11,r11,#(&3f0-&278)<<2
	MOV	r0,#&55
	STRB	r0,[r11,#0]
	STRB	r0,[r11,#0]				; Enter configuration mode

	MOV	r0,#1
	STRB	r0,[r11,#0]
	LDRB	r1,OldCR1
	STRB	r1,[r11,#4]				; Restore CR1

	MOV	r0,#4
	STRB	r0,[r11,#0]
	LDRB	r1,OldCR4
	STRB	r1,[r11,#4]				; Restore CR4

	MOV	r0,#&aa
	STRB	r0,[r11,#0]				; Leave configuration mode

EI_NotEPP
	LDR	r11,ParallelAddress

	LDRB	r0,OldCommand
	STRB	r0,CommandReg

	STMFD	r13!,{r0,r9}
	MOV	r0,#1
	MOV	r9,#0
	SWI	&6144c					; This is PrintQueue_PauseResume - resuming paused queue
	LDMFD	r13!,{r0,r9}

	LDMFD	r13!,{r0-r4,r11,pc}^

; ppa_setprinterstatus allows the user to turn the printer check on/off.

ppa_setprinterstatus
	LDR	r12,[r12]

;sps_fs1	LDRB	r2,[r0],#1				; Get a character from the buffer
;	CMP	r2,#32
;	BGT	sps_fs1					; If it isn't a space or a control character, repeat...

;	BNE	sps_badsyntax				; If it isn't a space, report an error

sps_fs2	LDRB	r2,[r0],#1				; Get the next character
	CMP	r2,#32
	BEQ	sps_fs2					; If it's a space, continue

	TEQ	r2,#'o'
	TEQNE	r2,#'O'					; If it's 'O' or 'o', it's okay...
	BNE	sps_badsyntax				; ...otherwise, report an error

	LDRB	r2,[r0],#1
	TEQ	r2,#'n'
	TEQNE	r2,#'N'					; If the 2nd character's an 'n' or an 'N', turn the status on
	BEQ	sps_printeron

	TEQ	r2,#'f'
	TEQNE	r2,#'F'
	BNE	sps_badsyntax				; If it's not followed by 'f' or 'F', it's wrong

	LDRB	r2,[r0],#1				; Get the next character

	TEQ	r2,#'f'
	TEQNE	r2,#'F'
	BNE	sps_badsyntax				; If it's not followed by 'f' or 'F', it's wrong

	LDRB	r2,[r0],#1
	CMP	r2,#32
	BGE	sps_badsyntax				; If the terminator isn't there, it's wrong again.

	MOV	r0,#0					; Mark the printer check as being not used
	STRB	r0,PPAPrinter
	MOVS	pc,lr

sps_printeron
	LDRB	r2,[r0],#1
	CMP	r2,#32
	BGE	sps_badsyntax				; If the Arnie isn't there, it's wrong again.

	MOV	r0,#1					; Check for the printer now
	STRB	r0,PPAPrinter
	MOVS	pc,lr

sps_badsyntax
	STMFD	r13!,{r14}
	SWI	&20100+'?'
	LDMFD	r13!,{r14}
	ADR	r0,sps_syntax2
	ORR	pc,lr,#1<<28				; It's an error

sps_syntax2
	DCD	220					; This is the syntax error
	=	"Syntax: *IZipPrinter on|off",0
	ALIGN

 [ cmd_history = 1

; print_commandhistory diplsays the last <cmd_historysize> SCSI commands,
; useful for debugging purposes. There isn't much in the way of comments here
; - it isn't really used for release, but the command is still there.

print_commandhistory
	STMFD	r13!,{r0-r11,lr}
	LDR	r12,[r12]
	SWI	XOS_WriteS
	=	"Total commands :",0
	ALIGN
	LDR	r0,Commands
	ADR	r1,Numbers
	MOV	r2,#12
	SWI	XOS_ConvertInteger4
	SWI	XOS_Write0
	SWI	XOS_NewLine

	SWI	XOS_WriteS
;	=	"00000000001111111111222222222233333333334444444444555555555566"
;	=	"01234567890123456789012345678901234567890123456789012345678901"
	=	"## CmdPtr   CmdLen DataPtr  DataLen  Command 10 bytes max St S2",10,13
	=	"-- -------- ------ -------- -------- -------------------- -- --",10,13
	=	0
;	=	"00 00000000 000000 00000000 00000000 11223344556677889900 00 00"
	ALIGN

; pch_loop loops for all the commands

	MOV	r10,#cmd_historysize
	ADR	r11,History
pch_loop
	LDMIA	r11!,{r5-r8}
	RSB	r0,r10,#cmd_historysize
	ADR	r1,Numbers
	MOV	r2,#12
	SWI	XOS_ConvertHex2
	SWI	XOS_Write0
	SWI	&20120

	MOV	r0,r5
	ADR	r1,Numbers
	MOV	r2,#12
	SWI	XOS_ConvertHex8
	SWI	XOS_Write0
	SWI	&20120

	MOV	r0,r6
	ADR	r1,Numbers
	MOV	r2,#12
	SWI	XOS_ConvertHex6
	SWI	XOS_Write0
	SWI	&20120

	MOV	r0,r7
	ADR	r1,Numbers
	MOV	r2,#12
	SWI	XOS_ConvertHex8
	SWI	XOS_Write0
	SWI	&20120

	MOV	r0,r8
	ADR	r1,Numbers
	MOV	r2,#12
	SWI	XOS_ConvertHex8
	SWI	XOS_Write0
	SWI	&20120

	CMP	r6,#10
	MOVGT	r6,#10

; pch_cmdl displays the SCSI command

	MOV	r5,#0
pch_cmdl
	LDRB	r0,[r11,r5]
	CMP	r5,r6
	ADR	r1,Numbers
	MOV	r2,#12
	SWI	XOS_ConvertHex2
	CMP	r5,r6
	SWIGE	&20100+'-'
	SWIGE	&20100+'-'
	SWILT	XOS_Write0
	ADD	r5,r5,#1
	CMP	r5,#10
	BLT	pch_cmdl
	SWI	&20120

	LDRB	r0,[r11,#14]
	ADR	r1,Numbers
	MOV	r2,#12
	SWI	XOS_ConvertHex2
	SWI	XOS_Write0
	SWI	&20120

	LDRB	r3,[r11,#0]
	TEQ	r3,#&03
	SWINE	&20100+'-'
	SWINE	&20100+'-'
	BNE	pch_nost2
	LDRB	r0,[r11,#15]
	ADR	r1,Numbers
	MOV	r2,#12
	SWI	XOS_ConvertHex2
	SWI	XOS_Write0
pch_nost2
	ADD	r11,r11,#16
	SWI	XOS_NewLine
	SUBS	r10,r10,#1
	BGT	pch_loop
	LDMFD	r13!,{r0-r11,pc}^

; add_history adds a command to the history list. All the commands are
; shuffled, so it gets placed at the bottom.

add_history
	STMFD	r13!,{r0-r11,lr}
;	SWI	&20100+'.'
	LDR	r4,Commands
	ADD	r4,r4,#1
	STR	r4,Commands
	ADR	r11,History
	ADD	r11,r11,#(cmd_historysize-1)*32
	SUB	r10,r11,#32
	MOV	r9,#cmd_historysize-1
;	ADR	r11,History
ah_loop	LDMIA	r10,{r0-r7}
	STMIA	r11,{r0-r7}
	SUB	r10,r10,#32
	SUB	r11,r11,#32
	SUBS	r9,r9,#1
	BGT	ah_loop
	LDMFD	r13,{r0-r3}
	ADR	r10,History
	STMIA	r10!,{r0-r3}
ah_cmdl	LDRB	r2,[r0],#1
	STRB	r2,[r10],#1
	SUBS	r1,r1,#1
	BPL	ah_cmdl
	LDMFD	r13!,{r0-r11,pc}^

end_command
	STMFD	r13!,{r0-r11,lr}
	CMP	r0,#255
	MOVGT	r0,#255
;	SWI	&20100+'.'
	STRB	r0,History+16+14
	LDRB	r1,History+16
	TEQ	r1,#3
	LDREQ	r0,History+8
	LDREQB	r0,[r0,#12]
	STRB	r0,History+16+15
;	MOV	r0,#15
;	STRB	r0,History
	LDMFD	r13!,{r0-r11,pc}^
 ]

	END
