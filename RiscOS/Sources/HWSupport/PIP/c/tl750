/******************************************************************************

      File: tl750.c
   Purpose: tl750 routines
    Author: A.Pirozek
   History: 26-03-98 - AJP Created

 ******************************************************************************/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "kernel.h"
#include "swis.h"
#include "module.h"
#include "msgs.h"
#include "misc.h"
#include "fileops.h"
#include "screen.h"
#include "tl750.h"
#include "podule.h"
#include "cursor.h"
#include "tile.h"

/* a few constants */
uint  podule_base  =( uint)0x88000000, /* podule base */
      tl750_regs   =( uint)0x00400000, /* tl750 registers offset */
      mem_straight =( uint)0x00800000, /* straight through memory */
      mem_swapped  =( uint)0x00c00000, /* swapped memory */
      screen_start =0;
uint *volatile waddr;
static uint *volatile caddr;      /* control register */

/* background source */
typedef struct _bgsource
{
  int     colour;        /* background colour */
  char   *spritefile;    /* name of spritefile */
  int     vsource;       /* video source 0|1|2 */
} bgsource;

/* pip position */
typedef struct _pippos
{
  int     x,
          y;
} pippos;

/* pip size */
typedef struct _pipsize
{
  int     width,
          height;
} pipsize;

/* graphics plane size */
typedef struct _gfxsize
{
  int     width,
          height;
} gfxsize;

/* graphics position, if scaled */
typedef struct _gfxpos
{
  int     x,
          y;
} gfxpos;

typedef struct _piproi
{
  int x, y, w, h;
} piproi;

typedef struct _tl750
{
  bgsource   bg_source;        /* background source */
  int        pip_source;       /* pip source 0|1|2|3 */
  pippos     pip_pos;          /* pip position */
  pipsize    pip_size;         /* pip size */
  piproi     pip_roi;
  gfxsize    gfx_size;         /* scaled graphics size... */
  gfxsize    gfx_fsize;        /* full screen size of graphics plane */
  gfxpos     gfx_fpos;         /* x & y position of fullscreen setup */
  int        gfx_full;         /* ...otherwise full screen */
  gfxpos     gfx_pos;          /* graphics position if scaled */
  int        gfx_alpah;        /* global alpha level 0-128 */
  bgsource   bg_saved;         /* saved state of background */
  int        pip_saved;        /* saved state of pip */
  uint       curs_sa;          /* cursor start address */
  uint       svdo_sa;          /* start address of scaled video */
  uint       svdo_ea;          /* end address of scaled video */
  uint       gfx_sa;           /* start address of graphics plane */
  uint       gfx_screen0;      /* screen address for screen 0 */
  uint       gfx_screen1;      /* screen address for screen 1 */
  int        cursor;           /* 0 - off, 1 - on */
} tl750;

static tl750 tl750_state;
static void *pw;

static uint cursor_clut[] =
{
  0x00000000,
  0xFFFF8080,
  0x40C03030,
  0, 0,	0, 0,
  0, 0,	0, 0,
  0, 0,	0, 0,
  0,
};

static uint fltrSiTable [ 0x20] =
{
  0x00feff00,0x00fdfa01,0x00fbf601,0x00f8f301,
  0x00f4f001,0x00eeee02,0x00e7ed02,0x00e2eb02,
  0x00daeb02,0x00d2ea02,0x00c9ea02,0x00c1ea01,
  0x00b7eb01,0x00abec01,0x009fed01,0x0095ee01,
  0x008cef01,0x0081f101,0x0075f201,0x006af300,
  0x005ff500,0x0055f600,0x004af800,0x0040f900,
  0x0037fa00,0x002efc00,0x0025fd00,0x001dfe00,
  0x0015ff00,0x000fff00,0x00080000,0x00030000
};
static uint fltrSi2Table [ 0x20] =
{
  0x00fe0000,0x00fdfa00,0x00fbf600,0x00f8f400,
  0x00f4f000,0x00eeee02,0x00e7ee02,0x00e2ec02,
  0x00daec02,0x00d2ea02,0x00c9ea02,0x00c1ea00,
  0x00b7ec00,0x00abec00,0x009fee00,0x0095ee00,
  0x008cf000,0x0081f200,0x0075f200,0x006af400,
  0x005ff600,0x0055f600,0x004af800,0x0040fa00,
  0x0037fa00,0x002efc00,0x0025fe00,0x001dfe00,
  0x00150000,0x000f0000,0x00080000,0x00030000
};
static uint fltrSi3Table [ 0x20] =
{
  0x00feff00,0x00fdfa01,0x00fbf601,0x00f8f301,
  0x00f4f001,0x00eeee02,0x00e7ed02,0x00e2eb02,
  0x00daeb02,0x00d2ea02,0x00c9ea02,0x00c1ea01,
  0x00b7eb01,0x00abec01,0x009fed01,0x0095ee01,
  0x008cef01,0x0081f101,0x0075f201,0x006af300,
  0x005ff500,0x0055f600,0x004af800,0x0040f900,
  0x0037fa00,0x002efc00,0x0025fd00,0x001dfe00,
  0x0015ff00,0x000fff00,0x00080000,0x00030000
};
static uint gerardFilterTable [ 0x20] =
{
  0x00ffff00,0x00fefd00,0x00fbfb01,0x00f9f901,
  0x00f5f801,0x00eff701,0x00eaf601,0x00e3f501,
  0x00dcf501,0x00d4f501,0x00c9f501,0x00c1f501,
  0x00b8f501,0x00aff501,0x00a1f601,0x009af600,
  0x008cf700,0x0081f800,0x0075f800,0x006af900,
  0x005ffa00,0x0055fb00,0x004afb00,0x0040fc00,
  0x0037fd00,0x002efd00,0x0025fe00,0x001dfe00,
  0x0015ff00,0x000fff00,0x00080000,0x00030000
};
static uint gerard2FilterTable [ 0x20] =
{
  0x00feff00,0x00fdfd00,0x00fbfb00,0x00f8f900,
  0x00f4f800,0x00eef701,0x00e7f601,0x00e2f501,
  0x00daf501,0x00d2f501,0x00c9f501,0x00c1f500,
  0x00b7f500,0x00abf600,0x009ff600,0x0095f700,
  0x008cf700,0x0081f800,0x0075f900,0x006af900,
  0x005ffa00,0x0055fb00,0x004afc00,0x0040fc00,
  0x0037fd00,0x002efe00,0x0025fe00,0x001dff00,
  0x0015ff00,0x000fff00,0x00080000,0x00030000
};
static uint HalfHalfFilterTable [ 0x20] =
{
  0x00800000,0x00800000,0x00800000,0x00800000,
  0x00800000,0x00800000,0x00800000,0x00800000,
  0x00800000,0x00800000,0x00800000,0x00800000,
  0x00800000,0x00800000,0x00800000,0x00800000,
  0x00800000,0x00800000,0x00800000,0x00800000,
  0x00800000,0x00800000,0x00800000,0x00800000,
  0x00800000,0x00800000,0x00800000,0x00800000,
  0x00800000,0x00800000,0x00800000,0x00800000
};

/*#define CAB_SAT*/
#define NUMFILTERS 2
static uint *filters[ 6];
extern void entry_tick(void);

/******************************************************************************
 read a tl750 register
  parameters: reg_offset - register offset from base
     returns: unsigned int - register value
 ******************************************************************************/
static uint tl750_register_read ( uint reg_offset)
{
  uint *volatile ra;

  ra =( uint *volatile)( podule_base +tl750_regs +( reg_offset *4));
  return *ra;
}

/******************************************************************************
 write a tl750 register
  parameters: reg_offset - register offset from base
              value      - value to write
     returns:
 ******************************************************************************/
static _kernel_oserror *tl750_register_write ( uint reg_offset,
                                               uint value)
{
  uint *volatile wa;

  wa =( uint *volatile)( podule_base +tl750_regs +( reg_offset *4));
  *wa =value;
  return NULL;
}

/******************************************************************************
 program a tl750 register
  parameters: regoff - register offset from base
              and    - and value
              eor    - eor value
     returns: and - old value
              eor - new value
 ******************************************************************************/
_kernel_oserror *tl750_register ( int regoff, int *and, int *eor)
{
  uint *volatile addr, regval, oldval;

  addr =( uint *volatile)( podule_base +tl750_regs +( regoff *4));
  regval =*addr;
  oldval =regval;
  regval =( regval & (*and^0xffffffff))^*eor;
  *addr  =regval;
  *and   =oldval;
  *eor   =*addr;

  return NULL;
}

#ifndef RW_MACRO
/******************************************************************************
 program a tl750 register - write only
  parameters: regoff - register offset from base
              and    - and value
              eor    - eor value
     returns:
 ******************************************************************************/
void tl750_register_wo ( int regoff, int and, int eor)
{
  uint *volatile addr;

   addr =( uint *volatile)( podule_base +tl750_regs +( regoff *4));
  *addr =( *addr & (and^0xffffffff))^eor;
}
#endif

/******************************************************************************
 wait until the beginning of vertical blanking in the second field
  parameters:
     returns:
 ******************************************************************************/
static void tl750_frame_wait ( void)
{
  uint status;
  int time_out =1000000;

  do
  {
    status = tl750_register_read ( DISP_STATUS);
  } while ((( status & 0x6) != 0x4) && (time_out-- > 0));

  do
  {
    status = tl750_register_read ( DISP_STATUS);
  } while ((( status & 0x6) != 0x6) && (time_out-- > 0));
}

/******************************************************************************
 wait until the beginning of vertical blanking in the second field of
 incomming video
  parameters: input - video input to wait for
     returns:
 ******************************************************************************/
static void tl750_vscframe_wait ( int input)
{
  uint status;
  int time_out =1000000;

  do
  {
    status = input ? tl750_register_read ( VSC_B_STATUS):
                     tl750_register_read ( VSC_A_STATUS);
  } while ((( status & 0x3) != 0) && ( time_out-- > 0));

  do
  {
    status = input ? tl750_register_read ( VSC_B_STATUS):
                     tl750_register_read ( VSC_A_STATUS);
  } while ((( status & 0x2) != 0x2) && ( time_out-- > 0));
}

/******************************************************************************
 set the background plane colour
  parameters: colour - new colour of background
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_bgsource_colour ( uint colour)
{
  uint ycbcr;

  rgb2ycbcr ( colour <<8, &ycbcr);
  ycbcr = ycbcr <<8;

  /* disable video source and set the bg colour */
  tl750_register_wo ( DISP_CONFIG, DISP_CONFIG_BG_VIDEO_ENABLE, 0);
  tl750_register_wo ( DISP_BG_CONFIG, DISP_BG_CONFIG_BG_TILE_ENABLE, 0);
  tl750_register_wo ( DISP_BG_CONFIG, DISP_BG_CONFIG_BG_COLOUR,
                      ycbcr & DISP_BG_CONFIG_BG_COLOUR);
  tl750_state.bg_source.colour =colour;
  tl750_state.bg_source.vsource =0;
  return NULL;
}

/******************************************************************************
 set the background to a spritefile
  parameters: spritefile - name of spritefile
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_bgsource_sprite ( char *spritefile)
{
  return tile_tile_sprite ( spritefile);
}

/******************************************************************************
 store the current background source
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_bgsave ( void)
{
  /* what about colour and sprite matey! */
  tl750_state.bg_saved.vsource =tl750_state.bg_source.vsource;
  return NULL;
}

/******************************************************************************
 restore the current background source
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_bgrestore ( void)
{
  return tl750_bgsource_video ( tl750_state.bg_saved.vsource);
}

/******************************************************************************
 set the pip window source
  parameters: source - 0 off, removes PIP from screen
                       1 video input 1
                       2 video input 2
                       3 use current background source in PIP window. If the
                         current background source is not video, then this
                         command sets the source to be that when BGSave was
                         last called.
     returns:
 ******************************************************************************/
/*#define DISABLE_IRQS*/
static void tl750_pipsource2 ( rect *pos, rect *roi, int source,
                               uint buffsize, int resetp)
{
  int x, y, w, h;
  int rx, ry, rw, rh;

  w = pos ->w / 2 * 2;
  h = pos ->h / 2 * 2;
  x = pos ->x / 2 * 2;
  y = pos ->y / 2 * 2;

  rx = roi ->x / 2 * 2;
  ry = roi ->y / 2 * 2;
  rw = roi ->w / 2 * 2;
  rh = roi ->h / 2 * 2;

  if ( w <= 0 || h <=0 || rw <= 0 || rh <= 0)
    return;

  tl750_state.svdo_ea = ( uint)tl750_state.svdo_sa +buffsize -4;
  tl750_vscframe_wait ( 1);

  _kernel_irqs_off();
#ifdef CAB_SAT
  if ( resetp)
  {
    tl750_vscframe_wait ( 1);
    tl750_register_wo ( DISP_CONFIG, DISP_CONFIG_SCALED_VIDEO_ENABLE, 0);
    tl750_register_wo ( VSC_CTRL_REG, VSC_CTRL_REG_ENABLE_PIP, 0);
  }
#endif
#ifdef DISABLE_IRQS
  _kernel_irqs_off();
#endif
  tl750_register_wo ( VSC_BCS_REG, 1<<24, 1<<24);
  tl750_register_wo ( VSC_ROI_HREG, 0xffffffff,
                      (( rw/2)-1)<<16 | ( 0x3ff &-( rx /2)));
  tl750_register_wo ( VSC_ROI_VREG, 0xffffffff,
                      ( rh/2)<<16 | ( 0x3ff &-( ry /2)));
  tl750_register_wo ( VSC_DDA_HREG, 0x000fffff, (( w<<19) +rw-1) /rw);
  tl750_register_wo ( VSC_DDA_VREG, 0x000fffff, (( h<<19) +rh-1) /rh);
  if ( resetp)
  {
    tl750_register_wo ( VSC_DBUF_EADR, 0x00ffffff, tl750_state.svdo_ea);
    tl750_register_wo ( VSC_DBUF_SADR, 0x00ffffff, tl750_state.svdo_sa);
    tl750_register_wo ( VSC_DBUF_WADR, 0x00ffffff, tl750_state.svdo_sa);
    tl750_register_wo ( VSC_CTRL_REG, VSC_CTRL_REG_SOURCE_SELECT,
                                      source ==1?0:2);
    tl750_frame_wait ();
    tl750_register_wo ( VSC_CTRL_REG, VSC_CTRL_REG_ENABLE_PIP,
                                      VSC_CTRL_REG_ENABLE_PIP);
  }
#ifdef DISABLE_IRQS
  _kernel_irqs_on();
#endif
  tl750_frame_wait ();
#ifdef DISABLE_IRQS
  _kernel_irqs_off();
#endif
  tl750_register_wo ( DISP_SVDO_SIZE, DISP_SVDO_SIZE_WIDTH|
                      DISP_SVDO_SIZE_HEIGHT, ( h <<16)| w);
  tl750_register_wo ( DISP_SVDO_POS, DISP_SVDO_POS_X|DISP_SVDO_POS_Y,
                      ( y <<16)|x);
  if ( resetp)
  {
    tl750_register_wo ( DISP_SVDO_EA,  0x00ffffff, tl750_state.svdo_ea);
    tl750_register_wo ( DISP_SVDO_SA,  0x00ffffff, tl750_state.svdo_sa);
    tl750_register_wo ( DISP_SVDO_RPTR,0x00ffffff, tl750_state.svdo_sa);
    tl750_register_wo ( VSC_CTRL_REG, VSC_CTRL_REG_ENABLE_PIP,
                        VSC_CTRL_REG_ENABLE_PIP);
  }
#ifdef DISABLE_IRQS
  _kernel_irqs_on();
#endif
  _kernel_irqs_on();
}

/******************************************************************************
 set the pip window source
  parameters: source - 0 off, removes PIP from screen
                       1 video input 1
                       2 video input 2
                       3 use current background source in PIP window. If the
                         current background source is not video, then this
                         command sets the source to be that when BGSave was
                         last called.
     returns:
 ******************************************************************************/
#define MAXHSIZE 450
#define MAXVSIZE 300
#define SVIDEO_BUFFERSIZE (((MAXVSIZE*MAXHSIZE*3)+255) & 0xFFFFFF00)
static void tl750_pipsource1 ( int source)
{
  int reset =FALSE;/*, oldsource =tl750_state.pip_source;*/
  rect pos, roi;
  int reg;

  reg =tl750_register_read ( DISP_INT_STAT);
  if (( reg & 0x381) | ( source !=tl750_state.pip_source))
    reset =TRUE;

  pos.x =tl750_state.pip_pos.x;
  pos.y =tl750_state.pip_pos.y;
  pos.w =tl750_state.pip_size.width;
  pos.h =tl750_state.pip_size.height;

  roi.x =-((tl750_state.pip_roi.x<<22)>>22)*2;
  roi.y =-((tl750_state.pip_roi.y<<22)>>22)*2;
  roi.w =(tl750_state.pip_roi.w+1)*2;
  roi.h =tl750_state.pip_roi.h*2;

  if ( source ==3)
    source =tl750_state.bg_source.vsource;

  tl750_pipsource2 ( &pos, &roi, source, SVIDEO_BUFFERSIZE, reset);
  tl750_register_wo ( DISP_CONFIG, DISP_CONFIG_SCALED_VIDEO_ENABLE,
                      DISP_CONFIG_SCALED_VIDEO_ENABLE);
  tl750_register_wo ( VSC_CTRL_REG, VSC_CTRL_REG_ENABLE_PIP,
                      VSC_CTRL_REG_ENABLE_PIP);
  tl750_state.pip_source =source;
}

/******************************************************************************
 set the pip window source
  parameters: source - 0 off, removes PIP from screen
                       1 video input 1
                       2 video input 2
                       3 use current background source in PIP window. If the
                         current background source is not video, then this
                         command sets the source to be that when BGSave was
                         last called.
              zoom   - zoom the pip window
     returns:
 ******************************************************************************/
#define HTOVSCALE 2/3
_kernel_oserror *tl750_pipsource ( int source, int zoom)
{
  int w, h;
  int stepsize =( tl750_state.pip_size.width /20) *4;
  rect pos;

  if ( source ==0)
  {
    tl750_register_wo ( DISP_CONFIG, DISP_CONFIG_SCALED_VIDEO_ENABLE, 0);
    tl750_register_wo ( VSC_CTRL_REG, VSC_CTRL_REG_ENABLE_PIP, 0);
    source =tl750_state.pip_source =0;
    return NULL;
  }

  if ( source ==3)
    source =tl750_state.bg_source.vsource;

  stepsize =max ( stepsize, 1);

  pos.x =tl750_state.pip_pos.x;
  pos.y =tl750_state.pip_pos.y;
  pos.w =tl750_state.pip_size.width;
  pos.h =tl750_state.pip_size.height;

  if ( zoom)
  {
    for ( w = pos.w %stepsize; w <= pos.w; w +=stepsize)
    {
      if ( w ==0)
        continue;
      h = ( w *HTOVSCALE) /2 *2;
      tl750_state.pip_pos.x = ( pos.x +( pos.w -w) /2) /2 *2;
      tl750_state.pip_pos.y = ( pos.y +( pos.h -h) /2) /2 *2;
      tl750_state.pip_size.width  =w;
      tl750_state.pip_size.height =h;
      tl750_frame_wait ();
      tl750_pipsource1 ( source);
    }
  }
  else
    tl750_pipsource1 ( source);

  return NULL;
}

/******************************************************************************
 set the background video source
  parameters: vidsource - 0 switch off background video source
                          1 video input 1
                          2 video input 2
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_bgsource_video ( int vidsource)
{
  _kernel_oserror *e =NULL;

  if ( vidsource)
  {
    /* enable background if its off */
    if ( tl750_state.bg_source.vsource ==0)
      tl750_register_wo ( DISP_CONFIG, DISP_CONFIG_BG_VIDEO_ENABLE,
                          DISP_CONFIG_BG_VIDEO_ENABLE);
    switch ( vidsource)
    {
      case 1:
        tl750_register_wo ( DISP_BG_CONFIG, DISP_BG_CONFIG_BG_VIDEO_SELECT, 0);
        tl750_register_wo ( DISP_CONFIG, DISP_CONFIG_BG_VIDEO_ENABLE,
                            DISP_CONFIG_BG_VIDEO_ENABLE);
        break;

      case 2:
        tl750_register_wo ( DISP_BG_CONFIG, DISP_BG_CONFIG_BG_VIDEO_SELECT, 1);
        tl750_register_wo ( DISP_CONFIG, DISP_CONFIG_BG_VIDEO_ENABLE,
                            DISP_CONFIG_BG_VIDEO_ENABLE);
        break;
    }
  }
  else
  {
    tl750_register_wo ( DISP_CONFIG, DISP_CONFIG_BG_VIDEO_ENABLE, 0);
    e =tl750_bgsource_colour ( tl750_state.bg_source.colour);

  }

  tl750_state.bg_source.vsource =vidsource;
  return e;
}

/******************************************************************************
 store current video source for PIP window
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_pipsave ( void)
{
  tl750_state.pip_saved =tl750_state.pip_source;
  return NULL;
}

/******************************************************************************
 restore current video source for PIP window
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_piprestore ( void)
{
  tl750_pipsource ( tl750_state.pip_saved, 0);
  return NULL;
}

/******************************************************************************
 set the width of the pip window
  parameters: width - width
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_pipsize_set_width ( int width)
{
  tl750_state.pip_size.width =( width & 0x3fe);
  if ( tl750_state.pip_source)
    tl750_pipsource ( tl750_state.pip_source, 0);
  else
    tl750_register_wo ( DISP_SVDO_SIZE, DISP_SVDO_SIZE_WIDTH, width & 0x3fe);

  return NULL;
}

/******************************************************************************
 set the height of the pip window
  parameters: height - height
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_pipsize_set_height ( int height)
{
  tl750_state.pip_size.height =height;
  if ( tl750_state.pip_source)
    tl750_pipsource ( tl750_state.pip_source, 0);
  else
    tl750_register_wo ( DISP_SVDO_SIZE, DISP_SVDO_SIZE_HEIGHT,
                        (height <<16) & DISP_SVDO_SIZE_HEIGHT);
  return NULL;
}

/******************************************************************************
 adds width to current width value
  parameters: width  - value to add
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_pipsize_alter_width ( int width)
{
  tl750_frame_wait ();
  tl750_register_wo ( DISP_SVDO_SIZE, DISP_SVDO_SIZE_WIDTH,
                    ( tl750_state.pip_size.width +width) & 0x3fe);
  tl750_state.pip_size.width =(( tl750_state.pip_size.width +width) & 0x3fe);
  return NULL;
}

/******************************************************************************
 adds height to current height value
  parameters: height  - value to add
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_pipsize_alter_height ( int height)
{
  tl750_frame_wait ();
  tl750_register_wo ( DISP_SVDO_SIZE, DISP_SVDO_SIZE_HEIGHT,
       (( tl750_state.pip_size.height +height) <<16) & DISP_SVDO_SIZE_HEIGHT);
  tl750_state.pip_size.height +=height;
  return NULL;
}

/******************************************************************************
 set the current x positon of the pip window
  parameters: x - x value
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_pippos_set_x ( int x)
{
  tl750_frame_wait ();
  tl750_register_wo ( DISP_SVDO_POS, DISP_SVDO_POS_X, ( x & 0x3fe));
  tl750_state.pip_pos.x =x & 0x3fe;

  return NULL;
}

/******************************************************************************
 set the current y positon of the pip window
  parameters: y - y value
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_pippos_set_y ( int y)
{
  tl750_frame_wait ();
  tl750_register_wo ( DISP_SVDO_POS, DISP_SVDO_POS_Y,
                    ( y <<16) & DISP_SVDO_POS_Y);
  tl750_state.pip_pos.y =y;
  return NULL;
}

/******************************************************************************
 adds x to current x value
  parameters: x  - value to add
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_pippos_alter_x ( int x)
{
  tl750_frame_wait ();
  tl750_register_wo ( DISP_SVDO_POS, DISP_SVDO_POS_X,
                    ( tl750_state.pip_pos.x +x) & 0x3fe);
  tl750_state.pip_pos.x =( tl750_state.pip_pos.x +x) & 0x3fe;
  return NULL;
}

/******************************************************************************
 adds y to current x value
  parameters: y  - value to add
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_pippos_alter_y ( int y)
{
  tl750_frame_wait ();
  tl750_register_wo ( DISP_SVDO_POS, DISP_SVDO_POS_Y,
                    (( tl750_state.pip_pos.y +y) <<16) & DISP_SVDO_POS_Y);
  tl750_state.pip_pos.y +=y;
  return NULL;
}

/******************************************************************************
 read the current position of the pip window
  parameters: x - x position
              y - y positin value to add
     returns:
 ******************************************************************************/
void tl750_pip_read_pos ( int *x, int *y)
{
  *x =tl750_state.pip_pos.x;
  *y =tl750_state.pip_pos.y;
}

/******************************************************************************
 read the current position of the pip window
  parameters: w - width
              h - height
     returns:
 ******************************************************************************/
void tl750_pip_read_size ( int *w, int *h)
{
  *h =tl750_state.pip_size.height;
  *w =tl750_state.pip_size.width;
}

/******************************************************************************
 set the x and y position of the pip window
  parameters: x - x position
              y - y position
     returns:
 ******************************************************************************/
void tl750_pip_set_pos ( int x, int y)
{
#ifdef coords
  if ( x<60 || y <30)
    return;
  /*if (( x + tl750_state.pip_size.width > 640) ||
      ( y + tl750_state.pip_size.height > 530))*/
  if (( x + tl750_state.pip_size.width > 672) ||
      ( y + tl750_state.pip_size.height > 550))
    return;
#endif
  if ( x <70)
    x =70;
  if ( y <30)
    y =30;
  if ( x + tl750_state.pip_size.width >=670)
    x =670 -tl750_state.pip_size.width;
  if ( y + tl750_state.pip_size.height >=540)
    y =540 -tl750_state.pip_size.height;
  tl750_frame_wait ();
  tl750_register_wo ( DISP_SVDO_POS, DISP_SVDO_POS_Y|DISP_SVDO_POS_X,
                    ( y <<16) & DISP_SVDO_POS_Y| x & DISP_SVDO_POS_X);
  tl750_state.pip_pos.x =x;
  tl750_state.pip_pos.y =y;
}

/******************************************************************************
 set the width and height of the pip window
  parameters: w - width
              h - height
     returns:
 ******************************************************************************/
void tl750_pip_set_size ( int w, int h)
{
  /*if (( tl750_state.pip_pos.x + w > 640) ||
      ( tl750_state.pip_pos.y + h > 530))
    return;*/
#ifdef coords
  if (( tl750_state.pip_pos.x + w > 672) ||
      ( tl750_state.pip_pos.y + h > 550))
    return;
#endif
  if ( w <40)
    w =40;
  if ( h <30)
    h =30;
  if ( h +tl750_state.pip_pos.y >=540)
    tl750_state.pip_pos.y =540 -h;
  if ( w +tl750_state.pip_pos.x >=670)
    tl750_state.pip_pos.x =670 -w;

  if ( tl750_state.pip_source)
  {
    tl750_state.pip_size.width =w;
    tl750_state.pip_size.height =h;
    tl750_pipsource ( tl750_state.pip_source, FALSE);
  }
  else
  {
    tl750_register_wo ( DISP_SVDO_SIZE,
                        DISP_SVDO_SIZE_HEIGHT|DISP_SVDO_SIZE_WIDTH,
                      ( h <<16) & DISP_SVDO_SIZE_HEIGHT|
                        w & DISP_SVDO_SIZE_WIDTH);
    tl750_state.pip_size.width =w;
    tl750_state.pip_size.height =h;
  }
}

/******************************************************************************
 put pip on top or bottom
  parameters: tb - 1 - put on top
                   0 - put on bottom
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_piptop ( int tb)
{
  tl750_register_wo ( DISP_SGFX_CONFIG, 1<<12, tb<<12);
  return NULL;
}

/******************************************************************************
 set the current width of the graphics plane
  parameters: width - new width
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_gfxsize_set_width ( int width)
{
  tl750_register_wo ( DISP_SGFX_SIZE, DISP_SGFX_SIZE_WIDTH, width);
  tl750_register_wo ( DISP_SGFX_SCSIZE, DISP_SGFX_SIZE_WIDTH, width);
  tl750_state.gfx_size.width =width;

  return NULL;
}

/******************************************************************************
 set the current height of the graphics plane
  parameters: height - new height
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_gfxsize_set_height ( int height)
{
  tl750_register_wo ( DISP_SGFX_SIZE, DISP_SGFX_SIZE_HEIGHT,
                    ( height <<16));
  tl750_register_wo ( DISP_SGFX_SCSIZE, DISP_SGFX_SIZE_HEIGHT,
                    ( height <<16));
  tl750_state.gfx_size.height =height;

  return NULL;
}

/******************************************************************************
 adds width to current width
  parameters: width - value to add
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_gfxsize_alter_width ( int width)
{
  return tl750_gfxsize_set_width ( tl750_state.gfx_size.width +width);
}

/******************************************************************************
 adds height to current height
  parameters: height - value to add
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_gfxsize_alter_height ( int height)
{
  return tl750_gfxsize_set_height ( tl750_state.gfx_size.height +height);
}

/******************************************************************************
 set grphics plane to full screen
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_gfxsize_full_screen ( void)
{
  tl750_register_wo ( DISP_SGFX_SIZE, DISP_SGFX_SIZE_WIDTH,
                      tl750_state.gfx_fsize.width);
  tl750_register_wo ( DISP_SGFX_SCSIZE, DISP_SGFX_SIZE_WIDTH,
                      tl750_state.gfx_fsize.width);
  tl750_state.gfx_size.width =tl750_state.gfx_fsize.width;

  tl750_register_wo ( DISP_SGFX_SIZE, DISP_SGFX_SIZE_HEIGHT,
                    ( tl750_state.gfx_fsize.height <<16));
  tl750_register_wo ( DISP_SGFX_SCSIZE, DISP_SGFX_SIZE_HEIGHT,
                    ( tl750_state.gfx_fsize.height <<16));
  tl750_state.gfx_size.height =tl750_state.gfx_fsize.height;

  tl750_register_wo ( DISP_SGFX_POS, DISP_SGFX_POS_X,
                      tl750_state.gfx_fpos.x);
  tl750_state.gfx_pos.x =tl750_state.gfx_fpos.x;

  tl750_register_wo ( DISP_SGFX_POS, DISP_SGFX_POS_Y,
                      (tl750_state.gfx_fpos.y <<16) & DISP_SGFX_POS_Y);
  tl750_state.gfx_pos.y =tl750_state.gfx_fpos.y;

  return NULL;
}

/******************************************************************************
 set the current x positon of the gfx plane
  parameters: x - x value
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_gfxpos_set_x ( int x)
{
  tl750_register_wo ( DISP_SGFX_POS, DISP_SGFX_POS_X, x);
  tl750_state.gfx_pos.x =x;
  return NULL;
}

/******************************************************************************
 set the current y positon of the gfx plane
  parameters: y - y value
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_gfxpos_set_y ( int y)
{
  tl750_register_wo ( DISP_SGFX_POS, DISP_SGFX_POS_Y,
                      (( y <<16) & DISP_SGFX_POS_Y));
  tl750_state.gfx_pos.y =y;
  return NULL;
}

/******************************************************************************
 adds x to current x value
  parameters: x  - value to add
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_gfxpos_alter_x ( int x)
{
  tl750_gfxpos_set_x ( tl750_state.gfx_pos.x +x);
  return NULL;
}

/******************************************************************************
 adds y to current y value
  parameters: y  - value to add
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_gfxpos_alter_y ( int y)
{
  tl750_gfxpos_set_y ( tl750_state.gfx_pos.y +y);
  return NULL;
}

/******************************************************************************
 set the global alpha level
  parameters: alpha - new alpha level
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_gfxalpha ( int alpha)
{
  if ( alpha <0 || alpha >0x80)
    return NULL;

  tl750_register_wo ( DISP_GALPHA_IBASE, DISP_GALPHA_GLOBAL_ALPHA|0x8000,
                      0x8000|alpha);

  return NULL;
}

/******************************************************************************
 set the global alpha level
  parameters: fade - 0 fade alpha - new alpha level
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_gfxfade ( int fade)
{
  int ctime,
      n,
      galpha,
      regval =0,
      eor =0;

  tl750_register ( DISP_GALPHA_IBASE, &regval, &eor);
  galpha =( regval & DISP_GALPHA_GLOBAL_ALPHA);
  switch ( fade)
  {
    case TL750_ALPHA_FADE_OUT:
      if ( galpha >0)
      {
        for ( n =galpha; n >=0; n--)
        {
          ctime =cstimer ();
          while ( cstimer () < ctime +1);
          tl750_register_wo ( DISP_GALPHA_IBASE,
                              DISP_GALPHA_GLOBAL_ALPHA|0x8000, n|0x8000);
        }
      }
      break;

    case TL750_ALPHA_FADE_IN:
      if ( galpha <0x80)
      {
        for ( n =galpha; n <=0x80; n++)
        {
          ctime =cstimer ();
          while ( cstimer () < ctime +1);
          tl750_register_wo ( DISP_GALPHA_IBASE,
                              DISP_GALPHA_GLOBAL_ALPHA|0x8000, 0x8000|n);
        }
      }
      break;
  }
  return NULL;
}

/******************************************************************************
 write the cursor clut
  parameters: clutaddr - clut address
     returns:
 ******************************************************************************/
static void tl750_write_cursor_clut ( uint *clutaddr)
{
  int n;

  for ( n =0; n <16; n++)
  {
    tl750_register_wo ((DISP_CURS_CLUT_REG +n), 0xffffffff, clutaddr [ n]);
  }
}

/******************************************************************************
 write tables to dpc memory
  parameters: sa     - start address
              length - length of data
              data   - data to write
     returns:
 ******************************************************************************/
static void tl750_writeDPCMem ( uint sa, uint length, const uint *data)
{
  int n;
  const uint *p;

  p = data;
  tl750_register_write ( DISP_MEM_ADDR, sa);
  for ( n = 0; n < length; ++n)
    tl750_register_write ( DISP_MEM_DATA, *p++);
}

/******************************************************************************
 write filter taps to tl750 memory
  parameters:
     returns:
 ******************************************************************************/
static void tl750_write_filter_taps ( void)
{
  int i;

  for (i = 0x100; i < 0x1C0; i+= 0x20)
    tl750_writeDPCMem ( i, 0x20, filters [ 1]);
  tl750_register_wo ( DISP_SGFX_CONFIG, 0x60000|0x8000, 0x60000|0x8000);
  /* enable vertical and horizontal filters */
  tl750_register_wo ( DISP_SGFX_CONFIG, 0x6000, 0x6000);
}

/******************************************************************************
 stop ticker
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_final ( void *mpw)
{
  NOTUSED ( mpw)

  if ( tl750_state.cursor)
    tl750_cursor ( 0);

  return NULL;
}

/******************************************************************************
 initialise the tl750
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_init ( void *mpw)
{
  _kernel_oserror *e =NULL;
  _kernel_swi_regs r;
  int rom_section;

  pw =mpw;
  srand ( time ( 0));
  e =podule_find (( int *) &podule_base, &rom_section);
  if ( e)
    return e;

  if ( podule_base ==0)
  {
    printf ( "PIP card not found\n");
    return NULL;
  }

  tl750_state.gfx_pos.x =40;
  tl750_state.gfx_pos.y =50;
  tl750_state.pip_pos.x =400;
  tl750_state.pip_pos.y =50;
  tl750_state.pip_size.width  =200;
  tl750_state.pip_size.height =200;
  tl750_state.cursor =0;
  tl750_state.pip_saved =2;

  r.r [ 0] =3;
  r.r [ 3] =rom_section;
  e =_kernel_swi ( Podule_SetSpeed, &r, &r);
  if ( e)
    return e;

  /* init filter taps */
  filters [ 0] =fltrSiTable;
  filters [ 1] =HalfHalfFilterTable;
  filters [ 2] =fltrSi2Table;
  filters [ 3] =fltrSi3Table;
  filters [ 4] =gerardFilterTable;
  filters [ 5] =gerard2FilterTable;

  waddr =( uint *volatile)( podule_base +tl750_regs);
  caddr =( uint *volatile)( podule_base);

  *caddr=3;
  return e;
}

/******************************************************************************
 adds y to current x value
  parameters: base - base address of card
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_setbase ( uint base)
{
  podule_base =base;
  return NULL;
}

/******************************************************************************
 write to the control register
  parameters: regoff - register offset from base
              and    - and value
              eor    - eor value
     returns: and - old value
              eor - new value
 ******************************************************************************/
_kernel_oserror *tl750_write_to_base ( uint value)
{
  uint *volatile addr;

  addr =( uint *volatile)( podule_base);
  *addr =value;

  return NULL;
}

/******************************************************************************
 display info about tl750
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_info ( void)
{
  printf ( "Base address of podule:       %x\n", podule_base);
  printf ( "Status and control registers: %x\n", podule_base +0);
  printf ( "PIP registers:                %x\n", podule_base +tl750_regs);
  printf ( "PIP memory straight:          %x\n", podule_base +mem_straight);
  printf ( "PIP memory swapped:           %x\n", podule_base +mem_swapped);
  return NULL;
}

/******************************************************************************
 test memory on tl750 card
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_memtest ( void)
{
  int n;
  uint *volatile addr;

  for ( n =0; n<0x100000; n++)
  {
    addr =( uint *volatile)( podule_base +mem_straight +( n *4));
    *addr =rand();
  }

  for ( n =0; n<0x100000; n++)
  {
    addr =( uint *volatile)( podule_base +mem_straight +( n *4));
    *addr =n;
  }

  for ( n =0; n<0x100000; n++)
  {
    addr =( uint *volatile)( podule_base +mem_straight +( n *4));
    if ( *addr !=n)
    {
      printf ( "Memory test failed at location: %x\n", ( int) addr);
      return NULL;
    }
  }

  printf ( "Memory test passed\n");
  return NULL;
}

/******************************************************************************
 read a set of registers from a file
  parameters: regfile - filename of file
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_read_register_file ( char *regfile)
{
  FILE *rf;
  int  line =0, regi, vali;
  _kernel_oserror *e =NULL;
  char regnum [ 12],
       value  [ 12],
       buffer [ 128];

  if ( fileops_exists ( regfile) ==FALSE)
    return msge_lookup ( ERROR_REGISTER_FILE_NOTFOUND);

  if ( fileops_openrt ( &rf, regfile) ==FALSE)
    return msge_lookup ( ERROR_CANT_OPEN_FILE);

  while ( fileops_readline ( rf, buffer, 63))
  {
    line ++;
    if ( buffer [ 0] !='#')
    {
      to_lower ( buffer);
      if ( sub_stringn ( buffer, regnum, ':', 1) !=TRUE)
      {
        fclose ( rf);
        return msge_make ( ERROR_REGFILE_INVALID_LINE, line);
      }
      if ( sub_stringn ( buffer, value, ':', 2) !=TRUE)
      {
        fclose ( rf);
        return msge_make ( ERROR_REGFILE_INVALID_LINE, line);
      }
      if ( ahtoi ( regnum, &regi) !=TRUE)
      {
        fclose ( rf);
        return msge_make ( ERROR_REGFILE_BAD_REGISTER, line);
      }
      if ( ahtoi ( value, &vali) !=TRUE)
      {
        fclose ( rf);
        return msge_make ( ERROR_REGFILE_BAD_REGVAL, line);
      }
      /* initialise some values from the register file */
      switch ( regi)
      {
        case DISP_SVDO_SIZE:
          tl750_state.pip_size.width  =(vali &0x3fe);
          tl750_state.pip_size.height =((vali >>16) & 0x3ffe);
          break;

        case DISP_SVDO_POS:
          tl750_state.pip_pos.x =(vali &0x3fe);
          tl750_state.pip_pos.y =((vali >>16) & 0x3ffe);
          break;

        case DISP_SVDO_SA:
          tl750_state.svdo_sa =vali;
          break;

        case DISP_SVDO_EA:
          tl750_state.svdo_ea =vali;
          break;

        case DISP_CURS_SA:
          *caddr=0;
          tl750_state.curs_sa =vali;
          cursor_write ( tl750_state.curs_sa);
          tl750_write_cursor_clut ( cursor_clut);
          tl750_register_wo ( DISP_CURS_OFFSET, 0x3f|0x3f<<16,0);
          *caddr=3;
          break;

        case DISP_SGFX_SIZE:
          tl750_state.gfx_fsize.width  =( vali & DISP_SGFX_SIZE_WIDTH);
          tl750_state.gfx_fsize.height =( vali & DISP_SGFX_SIZE_HEIGHT) >>16;
          break;

        case DISP_SGFX_POS:
          tl750_state.gfx_fpos.x =( vali & DISP_SGFX_POS_X);
          tl750_state.gfx_fpos.y =( vali & DISP_SGFX_POS_Y) >>16;
          break;

        case DISP_SGFX_SA:
          tl750_state.gfx_sa =( vali & 0x00ffffff);
          screen_start =( vali & 0x00ffffff);
          tl750_state.gfx_screen0 =tl750_state.gfx_sa;
          tl750_state.gfx_screen1 =tl750_state.gfx_sa +(( 720*576) *4);
          break;

        case VSC_ROI_VREG:
          tl750_state.pip_roi.y =( vali & 0x3ff);
          tl750_state.pip_roi.h =( vali & ( 0x1ff <<16))>>16;
          break;

        case VSC_ROI_HREG:
          tl750_state.pip_roi.x =( vali & 0x3ff);
          tl750_state.pip_roi.w =( vali & ( 0x1ff <<16))>>16;
          break;
      }
      e =tl750_register_write ( regi, vali);
      buffer [ 0]=NULL;
    }
  }
  fclose ( rf);

  tl750_write_filter_taps ();
  return NULL;
}

/******************************************************************************
 save registers to a file
  parameters: regfile - filename of file
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_save_register_file ( char *regfile)
{
  FILE *rf;
  int  n;
  uint *volatile addr;
  char date   [ 40],
       buffer [ 64];

  if ( fileops_open ( &rf, regfile) ==FALSE)
    return msge_lookup ( ERROR_CANT_OPEN_FILE);

  sprintf ( buffer, "#\n# PIP Register file saved %s\n#\n",
            read_date ( "%W3 %DY %MO %YR at %24:%MI", date));
  if ( fileops_write ( rf, buffer) ==FALSE)
  {
    fclose ( rf);
    return msge_lookup ( ERROR_FILE_WRITE_FAILED);
  }
  for ( n =0 ; n <512; n++)
  {
    addr =( uint *volatile)( podule_base +tl750_regs +( n *4));
    sprintf ( buffer, "&%x:&%x\n", n, *addr);
    if ( fileops_write ( rf, buffer) ==FALSE)
    {
      fclose ( rf);
      return msge_lookup ( ERROR_FILE_WRITE_FAILED);
    }
  }
  fclose ( rf);
  return NULL;
}

/******************************************************************************
 handle ticker events
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_tick_handler( _kernel_swi_regs *r, void *pw)
{
  static int entry =0;
  _kernel_swi_regs mr;
  uint *volatile caddr =( uint *volatile)( podule_base);
  _kernel_oserror *e =NULL;
  NOTUSED ( r)
  NOTUSED ( pw)

  if ( entry)
    return NULL;
  entry +=1;
  e =_kernel_swi ( OS_Mouse, &mr, &mr);
  *caddr=0;
  tl750_register_wo ( DISP_CURS_POS,(0x3ff)|(0x3ff<<16),
           (((( mr.r[1] +tl750_state.gfx_fpos.y -150) ^0x3ff) /2) &0x3ff) <<16|
            ((( mr.r[0] +tl750_state.gfx_fpos.x +0) /2) &0x3ff));
  *caddr=3;
  entry -=1;
  return e;
}

/******************************************************************************
 switch the tl750 cursor on or off
  parameters: state - 0 - off
                      1 - on
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_cursor ( int state)
{
  _kernel_swi_regs r;
  _kernel_oserror *e =NULL;

  if ( tl750_state.cursor ==state)
    return NULL;

  switch ( state)
  {
    case 0:
      r.r [ 0] =( int)entry_tick;
      r.r [ 1] =( int)pw;
      e =_kernel_swi ( OS_RemoveTickerEvent, &r, &r);
      if ( e)
        return e;
      tl750_register_wo ( DISP_CONFIG, DISP_CONFIG_CURSOR_ENABLE,0);
      break;

    case 1:
      r.r [ 0] =6;
      r.r [ 1] =( int)entry_tick;
      r.r [ 2] =( int)pw;
      e =_kernel_swi ( OS_CallEvery, &r, &r);
      tl750_register_wo ( DISP_CONFIG, DISP_CONFIG_CURSOR_ENABLE,
                          DISP_CONFIG_CURSOR_ENABLE);
      break;
  }
  tl750_state.cursor =state;
  return e;
}

/******************************************************************************
 switch colour keying on or off
  parameters: state - 0 - off
                      1 - on
     returns:
 ******************************************************************************/
void tl750_gfxkey ( int state)
{
  tl750_register_wo ( DISP_SGFX_CONFIG, DISP_SGFX_CONFIG_KEYING, state<<4);
  tl750_register_wo ( DISP_SGFX_CONFIG, 1<<5, 0);
}

/******************************************************************************
 set colour key max and minimum values
  parameters: min - minimum colour value
              max - maximum colour value
     returns:
 ******************************************************************************/
void tl750_gfx_colour_keys ( uint min, uint max)
{
  tl750_register_wo ( DISP_SGFX_MIN_KEY, 0x00ffffff,
                      (min & 0xff0000)>>16|(min & 0xff)<<16|min & 0xff00);
  tl750_register_wo ( DISP_SGFX_MAX_KEY, 0x00ffffff,
                      (max & 0xff0000)>>16|(max & 0xff)<<16|max & 0xff00);
}

/******************************************************************************
 set the alpha mode
  parameters: mode - 0 global alpha disabled
                     1 global alpha enabled
     returns:
 ******************************************************************************/
void tl750_gfx_alpha_mode ( int mode)
{
  if ( mode)
    tl750_register_wo ( DISP_SGFX_CONFIG, 0x600, 0x200);
  else
    tl750_register_wo ( DISP_SGFX_CONFIG, 0x600, 0x400);
}

/******************************************************************************
 set the format of the graphics plane
  parameters: format -  0 -  8 bit alpha and 24 bit rgb
                        1 - 8 bit alpha and 16 bit rgb
                        2 - 8 bit alpha and 8 bit rgb
                        3 - 8 bit alpha and 8 bit index
                        4 - 24 bit rgb
                        5 - 1 6bit rgb
                        6 - 8 bit egb
                        7 - 8 bit index
                        8 - reserved
                        9 - reserved
                       10 - 4:2:2 CCIR-601 CbYCrY format
                       11 - reserved
                       12 - 4 bit index
                       13 - 4 bit alpha and 12 bit rgb
                       14 - 1 bit alpha and 15 bit rgb
                       15 - reserved
     returns:
 ******************************************************************************/
void tl750_gfxset_format ( int format)
{
  tl750_register_wo ( DISP_SGFX_CONFIG, DISP_SGFX_CONFIG_FORMAT, format);
}

/******************************************************************************
 write the pip card memory to a file
  parameters: memfile - filename to save to
     returns:
 ******************************************************************************/
_kernel_oserror *tl750_savemem ( char *memfile)
{
  FILE *mf;
  int b, i, *tmpbuff;
  _kernel_oserror *e =NULL;
  uint volatile *src;

  if ( fileops_open ( &mf, memfile) ==FALSE)
    return msge_lookup ( ERROR_CANT_OPEN_FILE);

  tmpbuff =( int *)malloc ( 256 * 1024);
  if ( tmpbuff ==NULL)
  {
    fclose ( mf);
    return msge_lookup ( ERROR_MALLOC_FAILED);
  }

  src =( uint *)( podule_base +mem_swapped);
  for ( b =0; b <=15; b++)
  {
    src =( uint *)( podule_base +mem_swapped +( b *( 256 *1024)));
    for ( i =0; i <=(64 *1024) -1; i++)
      *(tmpbuff +i) = *(src +i);
    if ( fileops_writeb ( mf, ( void *)tmpbuff, 256 *1024) !=TRUE)
    {
      fclose ( mf);
      free ( tmpbuff);
      return msge_lookup ( ERROR_FILE_WRITE_FAILED);
    }
  }
  free ( tmpbuff);
  fclose ( mf);

  return e;
}

/******************************************************************************
 write 0's to every pip memory location
  parameters:
     returns:
 ******************************************************************************/
void tl750_clearmem ( void)
{
  int n;
  uint volatile *pm;

  for ( n =0; n<0x100000; n++)
  {
    pm =( uint *)( podule_base +mem_swapped +( n *4));
    *pm =0;
  }
}

/******************************************************************************
 set the anti-flicker filter
  parameters: filtnum - 0 - off
                        1 - on
     returns:
 ******************************************************************************/
void tl750_gfxfilter ( int filtnum)
{
  switch ( filtnum)
  {
    case 0:
      tl750_register_wo ( DISP_SGFX_CONFIG, 0x60000|0x8000, 0);
      tl750_register_wo ( DISP_SGFX_CONFIG, 0x6000, 0);
      break;

    case 1:
      tl750_register_wo ( DISP_SGFX_CONFIG, 0x60000|0x8000, 0x60000|0x8000);
      /* enable vertical and horizontal filters */
      tl750_register_wo ( DISP_SGFX_CONFIG, 0x6000, 0x6000);
      break;
  }
}
