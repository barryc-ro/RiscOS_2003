
#include "modhead.h"
#include "OHCI.h"
#include "swis.h"
#include <string.h>
#include <stdio.h>
#include "debuglib/debuglib.h"
#include <stdlib.h>
#include <time.h>
#include "Global/RISCOS.h"
#include "Global/Keyboard.h"
#include "Global/Pointer.h"
#include "Global/HALEntries.h"
#include "Global/UpCall.h"
#include "callx/callx.h"
#include "devicefs.h"

#define NOTUSED(V) ((V)=(V))

#define PointerDevice_USB 7

#define USB_DELAY_RESET   20
#define USB_DELAY_ADDRESS 1
#define USB_DELAY_CONFIG  1

#define NUM_LOCK 0x01
#define CAPS_LOCK 0x02
#define SCROLL_LOCK 0x04

#ifdef EMULATE
#define OHCIEmulator_GetBus             0x054a80
#define OHCIEmulator_ClaimDeviceVector  0x054a81
#define OHCIEmulator_ReleaseDeviceVector  0x054a82
#define OHCIEmulator_ReadWord           0x054a83
#define OHCIEmulator_WriteWord          0x054a84
#define OREAD(ADDRESS,VALUE) \
_swix (OHCIEmulator_ReadWord, _IN(0) | _OUT(1), ADDRESS, VALUE)

#define OWRITE(ADDRESS,VALUE) \
_swix (OHCIEmulator_WriteWord, _INR(0,1), ADDRESS, VALUE)

#define CLAIM(FUNCTION,WS) \
_swix (OHCIEmulator_ClaimDeviceVector, _INR(1,2), FUNCTION, WS)

#define RELEASE(FUNCTION,WS) \
_swix (OHCIEmulator_ReleaseDeviceVector, _INR(1,2), FUNCTION, WS)

#else
static int* const ohci_base = (int*) 0xf99f6000;
#define OREAD(ADDRESS,VALUE) (*VALUE = ohci_base[ADDRESS / 4])
#define OWRITE(ADDRESS,VALUE) (ohci_base[ADDRESS / 4] = (int) VALUE)

#define CLAIM(FUNCTION,WS) \
_swix (OS_ClaimDeviceVector, _INR(0,2), 34, FUNCTION, WS); \
_swix (OS_Hardware, _IN(0) | _INR(8,9), 34, 0, EntryNo_HAL_IRQEnable)

#define RELEASE(FUNCTION,WS) \
_swix (OS_ReleaseDeviceVector, _INR(0,2), 34, FUNCTION, WS)
#endif

_kernel_oserror* reset_cb (_kernel_swi_regs* r, void* pw, void* data);
_kernel_oserror* pointer_cb (_kernel_swi_regs* r, void* pw, void* data);
_kernel_oserror* set_address_cb (_kernel_swi_regs* r, void* pw, void* data);
_kernel_oserror* set_config_cb (_kernel_swi_regs* r, void* pw, void* data);
static void read_key_data (void);
static void read_mouse_data (void);

static enum state {
    port_detached,
    port_attached,
    port_powered,
    port_default,
    port_address,
    port_configured,
    port_MAX_STATE
} port_state = port_detached;

static char* port_state_str[port_MAX_STATE] =
{
    "Port Detached",
    "Port Attached",
    "Port Powered",
    "Port Default",
    "Port Address",
    "Port Configured",
};

static char* completion_codes[16] =
{
    "NoError (0)",
    "CRC (1)",
    "BitStuffing (2)",
    "DataToggleMismatch (3)",
    "Stall (4)",
    "DeviceNotResponding (5)",
    "PIDCheckFailure (6)",
    "UnexpectedPID (7)",
    "DataOverRun (8)",
    "DataUnderrun (9)",
    "Reserved (10)",
    "Reserved (11)",
    "BufferOverrun (12)",
    "BufferUnderrun (13)",
    "Not Accessed (14)",
    "Not Accessed (15)"
};

static void* vtophys (void* v)
{
    struct {
        uint32_t    page;
        void*       logical;
        void*       physical;
    } block;
    block.logical = v;

    _swix (OS_Memory,

        _INR (0, 2),

        (1<<9) | (1<<13) | (2<<14),
        &block,
        1
        );


    return block.physical;
}


#define RSVD 0xFF     /* Reserved keys that have no mapping */
#define NEQV 0xFF     /* Keys in USB that have no RISC OS equivalent */
#define UDEF 0xFF     /* Keys that are undefined */

#define NKEYCODE 6


static struct {
    uint8_t modifiers;
    uint8_t reserved;
    uint8_t keycode[NKEYCODE];
} data = {0, 0, 0, 0, 0, 0, 0, 0},
  odata = {0, 0, 0, 0, 0, 0, 0, 0};

static struct {
    uint8_t  buttons;
    int8_t   relx;
    int8_t   rely;
    int8_t   relwheel;
} mouse_data;



/* Mapping table from USB keycodes to low-level internal key numbers - see PRM
 * 1-156.  The index into the table is the USB keycode, as defined in the HID
 * Usage tables.  The array starts off a-z, 1-0.
 */
static unsigned char mapping_table[256] = {
RSVD,               RSVD,            RSVD,             RSVD,             /*0*/
KeyNo_LetterA,      KeyNo_LetterB,   KeyNo_LetterC,    KeyNo_LetterD,
KeyNo_LetterE,      KeyNo_LetterF,   KeyNo_LetterG,    KeyNo_LetterH,
KeyNo_LetterI,      KeyNo_LetterJ,   KeyNo_LetterK,    KeyNo_LetterL,
KeyNo_LetterM,      KeyNo_LetterN,   KeyNo_LetterO,    KeyNo_LetterP,    /*1*/
KeyNo_LetterQ,      KeyNo_LetterR,   KeyNo_LetterS,    KeyNo_LetterT,
KeyNo_LetterU,      KeyNo_LetterV,   KeyNo_LetterW,    KeyNo_LetterX,
KeyNo_LetterY,      KeyNo_LetterZ,   KeyNo_Digit1,     KeyNo_Digit2,
KeyNo_Digit3,       KeyNo_Digit4,    KeyNo_Digit5,     KeyNo_Digit6,     /*2*/
KeyNo_Digit7,       KeyNo_Digit8,    KeyNo_Digit9,     KeyNo_Digit0,
KeyNo_Return,       KeyNo_Escape,    KeyNo_BackSpace,  KeyNo_Tab,
KeyNo_Space,        KeyNo_Minus,     KeyNo_Equals,     KeyNo_OpenSquare,
KeyNo_CloseSquare,  KeyNo_BackSlash, KeyNo_BackSlash,  KeyNo_SemiColon,  /*3*/
KeyNo_Tick,         KeyNo_BackTick,  KeyNo_Comma,      KeyNo_Dot,
KeyNo_Slash,        KeyNo_CapsLock,  KeyNo_Function1,  KeyNo_Function2,
KeyNo_Function3,    KeyNo_Function4, KeyNo_Function5,  KeyNo_Function6,
KeyNo_Function7,    KeyNo_Function8, KeyNo_Function9,  KeyNo_Function10, /*4*/
KeyNo_Function11,   KeyNo_Function12,KeyNo_Print,      KeyNo_ScrollLock,
KeyNo_Break,        KeyNo_Insert,    KeyNo_Home,       KeyNo_PageUp,
KeyNo_Delete,       KeyNo_Copy,      KeyNo_PageDown,   KeyNo_CursorRight,
KeyNo_CursorLeft,   KeyNo_CursorDown,KeyNo_CursorUp,   KeyNo_NumLock,    /*5*/
KeyNo_NumPadSlash,  KeyNo_NumPadStar,KeyNo_NumPadMinus,KeyNo_NumPadPlus,
KeyNo_NumPadEnter,  KeyNo_NumPad1,   KeyNo_NumPad2,    KeyNo_NumPad3,
KeyNo_NumPad4,      KeyNo_NumPad5,   KeyNo_NumPad6,    KeyNo_NumPad7,
KeyNo_NumPad8,      KeyNo_NumPad9,   KeyNo_NumPad0,    KeyNo_NumPadDot,  /*6*/
KeyNo_NotFittedLeft,KeyNo_Menu,      NEQV,             KeyNo_NumPadHash,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,             /*7*/
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,             /*8*/
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,             /*9*/
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,
NEQV,               NEQV,            NEQV,             NEQV,             /*a*/
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,             /*b*/
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,             /*c*/
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,             /*d*/
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
KeyNo_CtrlLeft,     KeyNo_ShiftLeft, KeyNo_AltLeft,    KeyNo_AcornLeft,  /*e*/
KeyNo_CtrlRight,    KeyNo_ShiftRight,KeyNo_AltRight,   KeyNo_AcornRight,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,             /*f*/
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD,
RSVD,               RSVD,            RSVD,             RSVD
};

/* bits to keep track of keys currently depressed */
static uint32_t status[8];

/* host controller communications area must be 256 byte aligned */
static OHCI_Hcca hcca[2];
static OHCI_Hcca* hccap;

/* we'll need 4 endpoints and transfer descriptors */
static OHCI_ED ed[5];
static OHCI_ED* edp;
static OHCI_TD td[7];
static OHCI_TD* tdp;
static void* tda[6]; /* physical addresses */

/* statistics */
static volatile int sofs = 0;
static volatile int wdh = 0;
static volatile int rhsc = 0;
static volatile int resets = 0;
static volatile int data_received = 0;
static volatile int request_complete = 0;

static int prev_pointer = 0;
static int state = 0;

static int relx = 0, rely = 0;
static uint8_t buttons;

static struct {
    uint8_t     requestType;
    uint8_t     request;
    uint16_t    value;
    uint16_t    index;
    uint16_t    length;
} setAddress = { 0, 5, 1, 0, 0 },
  setConfig = { 0, 9, 1, 0, 0 },
  setReport = { 0x21, 0x09, 0x0200, 1, 1};

_kernel_oserror *module_init(const char *cmd_tail, int podule_base, void *pw)
{
    int w;
    _kernel_oserror* e = 0;
    NOTUSED(cmd_tail);
    NOTUSED(podule_base);

    /* set up debugging */
    debug_initialise (Module_Title, "", "");
    debug_set_device(FILE_OUTPUT);
    debug_set_unbuffered_files (TRUE);

    dprintf (("Module", "Starting Module\n"));

    callx_init (pw);

    /* Reset the controller, and turn on global power */
    OWRITE(OHCI_COMMAND_STATUS, OHCI_HCR);
    OWRITE(OHCI_RH_STATUS, OHCI_LPSC);

    /* disable all list processing */
    OREAD(OHCI_CONTROL, &w);
    OWRITE(OHCI_CONTROL, w & ~(OHCI_PLE | OHCI_CLE | OHCI_BLE));

    /* HCCA must be 256 byte aligned */
    hccap = (OHCI_Hcca*) (((uintptr_t) &hcca[1]) & ~0xff);
    edp = (OHCI_ED*) (((uintptr_t) &ed[1]) & ~0xf);
    tdp = (OHCI_TD*) (((uintptr_t) &td[1]) & ~0xf);

    memset (hccap, 0, sizeof *hccap);
    memset (&ed[0], 0, sizeof ed);
    memset (&td[0], 0, sizeof td);

    for (w = 0; w < OHCI_NUM_INTERRUPTS; w += 8)
        hccap->interruptTable[w] = vtophys(&edp[0]);

    for (w = 4; w < OHCI_NUM_INTERRUPTS; w += 8)
        hccap->interruptTable[w] = vtophys(&edp[3]);

    OWRITE(OHCI_HCCA, vtophys (hccap));

    /* endpoint[0] is for the keyboard data */
    edp[0].functionAddress = 1;
    edp[0].endpointNumber = 1;
    edp[0].direction = 2;
    edp[0].speed = 1;
    edp[0].skip = 1;
    edp[0].format = 0;
    edp[0].maxPacketSize = 8;
    edp[0].tailPointer = 0;
    edp[0].head.pointer.normal = tda[0] = vtophys (&tdp[0]);
    edp[0].nextED = 0;

    tdp[0].bufferRounding = 1;
    tdp[0].direction = 2;
    tdp[0].conditionCode = OHCI_CC_NOT_ACCESSED;
    tdp[0].nextTD = 0;
    tdp[0].currentBuffer = vtophys (&data);
    tdp[0].bufferEnd = (char*) tdp[0].currentBuffer + sizeof data - 1;

    /* endpoint[1] is for the setting of address */
    edp[1].functionAddress = 0;
    edp[1].endpointNumber = 0;
    edp[1].direction = 0;
    edp[1].speed = 1;
    edp[1].skip = 1;
    edp[1].format = 0;
    edp[1].maxPacketSize = 8;
    edp[1].tailPointer = 0;
    edp[1].head.pointer.normal = tda[1] = vtophys (&tdp[1]);
    edp[1].nextED = vtophys (&edp[2]);

    tdp[1].direction = 0;
    tdp[1].dataToggle = 2; /* force DATA0 */
    tdp[1].conditionCode = OHCI_CC_NOT_ACCESSED;
    tdp[1].nextTD = vtophys (&tdp[3]);
    tdp[1].currentBuffer = vtophys (&setAddress);
    tdp[1].bufferEnd = (char*) tdp[1].currentBuffer + sizeof setAddress - 1;

    /* endpoint[2] is for the setting of configuration */
    edp[2].functionAddress = 1;
    edp[2].endpointNumber = 0;
    edp[2].direction = 0;
    edp[2].speed = 1;
    edp[2].skip = 1;
    edp[2].format = 0;
    edp[2].maxPacketSize = 8;
    edp[2].tailPointer = 0;
    edp[2].head.pointer.normal = tda[2] = vtophys (&tdp[2]);
    edp[2].nextED = 0;

    tdp[2].direction = 0;
    tdp[2].dataToggle = 2; /* force DATA0 */
    tdp[2].conditionCode = OHCI_CC_NOT_ACCESSED;
    tdp[2].nextTD = tda[3] = vtophys (&tdp[3]);
    tdp[2].currentBuffer = vtophys (&setConfig);
    tdp[2].bufferEnd = (char*) tdp[2].currentBuffer + sizeof setConfig - 1;

    /* termination for request transfers */
    tdp[3].direction = 2;
    tdp[3].dataToggle = 3; /* force DATA1 */
    tdp[3].conditionCode = OHCI_CC_NOT_ACCESSED;
    tdp[3].nextTD = 0;
    tdp[3].currentBuffer = 0;
    tdp[3].bufferEnd = 0;

    /* endpoint[3] is for the mouse data */
    edp[3].functionAddress = 1;
    edp[3].endpointNumber = 2;
    edp[3].direction = 2;
    edp[3].speed = 1;
    edp[3].skip = 1;
    edp[3].format = 0;
    edp[3].maxPacketSize = 8;
    edp[3].tailPointer = 0;
    edp[3].head.pointer.normal = tda[5] = vtophys (&tdp[5]);
    edp[3].nextED = 0;

    tdp[5].bufferRounding = 1;
    tdp[5].direction = 2;
    tdp[5].conditionCode = OHCI_CC_NOT_ACCESSED;
    tdp[5].nextTD = 0;
    tdp[5].currentBuffer = vtophys (&mouse_data);
    tdp[5].bufferEnd = (char*) tdp[5].currentBuffer + sizeof mouse_data - 1;


    OWRITE(OHCI_CONTROL_HEAD_ED, vtophys (&edp[1]));

    memset (&status[0], 0, sizeof status);

    buttons = 0;

    CLAIM(usb_irq_entry, pw);

    if (!e) e = _swix (OS_Claim, _INR(0,2), KeyV, keyv_entry, pw);

    if (!e) e = _swix (OS_Claim, _INR(0,2), PointerV, pointerv_entry, pw);

    if (!e) e = _swix (OS_Pointer, _IN(0) | _OUT(0), 0, &prev_pointer);

    /* put the controller into operational mode */
    OWRITE(OHCI_CONTROL, OHCI_HCFS_OPERATIONAL);

    /* enable periodic list processing */
    OREAD(OHCI_CONTROL, &w);
    OWRITE(OHCI_CONTROL, w | OHCI_PLE | OHCI_CLE);

    /* enable hc interrupts */
    OWRITE(OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
    OWRITE(OHCI_INTERRUPT_ENABLE, OHCI_MIE |  OHCI_WDH | OHCI_RHSC | OHCI_SF);

    /* force a port reset so that we latch on (after a delay) */
    callx_add_callafter (USB_DELAY_RESET, reset_cb, 0);

    return e;
}

_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
    int w = 0;
    clock_t t = clock ();
    NOTUSED(fatal);
    NOTUSED(podule);

    OREAD(OHCI_CONTROL, &w);
    OWRITE(OHCI_CONTROL, w & ~(OHCI_PLE | OHCI_CLE | OHCI_BLE));


    _swix (OS_Release, _INR(0,2), KeyV, keyv_entry, pw);
    _swix (OS_Release, _INR(0,2), PointerV, pointerv_entry, pw);

    callx_remove_all_callbacks ();

    /* wait until the next frame, and time out after a centisecond */
    w = sofs;
    while (sofs == w && clock () - t < 1);
    RELEASE(usb_irq_entry, pw);

    /* turn off the controller when we exit */
    OWRITE(OHCI_CONTROL, OHCI_HCFS_RESET);

    /* turn off any keys that are pressed */
    memset (&data, 0, sizeof data);
    memset (&mouse_data, 0, sizeof mouse_data);
    read_key_data ();
    read_mouse_data ();
    _swix (OS_Pointer, _INR(0,1), 1, prev_pointer);

    return 0;
}

static int leds = 0;

int keyv (_kernel_swi_regs* r, void* pw)
{
    static uint8_t res = 0;
    int w;
    NOTUSED(pw);

    switch (r->r[0]) {
    case KeyV_EnableDrivers:
        memset (&status[0], 0, sizeof status);
        break;
    case KeyV_NotifyLEDState:
        if (port_state != port_configured) break;
        leds = r->r[1];
        res = 0;
        if (r->r[1] & KeyV_LED_ScrollLock) res |= SCROLL_LOCK;
        if (r->r[1] & KeyV_LED_NumLock) res |= NUM_LOCK;
        if (r->r[1] & KeyV_LED_CapsLock) res |= CAPS_LOCK;
        request_complete = 0;
        edp[2].head.pointer.normal = tda[2];
        edp[2].skip = 0;

        tdp[2].nextTD = tda[4] = vtophys (&tdp[4]);
        tdp[2].currentBuffer = vtophys (&setReport);
        tdp[2].bufferEnd = tdp[2].currentBuffer + 7;
        tdp[2].dataToggle = 2; /* force DATA0 */
        tdp[2].conditionCode = OHCI_CC_NOT_ACCESSED;
        tdp[2].errorCount = 0;

        tdp[4].direction = 1;
        tdp[4].dataToggle = 3; /* force DATA1 */
        tdp[4].conditionCode = OHCI_CC_NOT_ACCESSED;
        tdp[4].nextTD = tda[3];
        tdp[4].currentBuffer = vtophys (&res);
        tdp[4].bufferEnd = tdp[4].currentBuffer;

        tdp[3].nextTD = 0;
        tdp[3].direction = 2;
        tdp[3].dataToggle = 3; /* force DATA1 */
        tdp[3].conditionCode = OHCI_CC_NOT_ACCESSED;
        tdp[3].errorCount = 0;
        OREAD(OHCI_COMMAND_STATUS, &w);
        OWRITE(OHCI_COMMAND_STATUS, w | OHCI_CLF);

        break;
    }

    return 1;
}

int pointerv (_kernel_swi_regs* r, void* pw)
{
    _kernel_oserror* e;
    NOTUSED(pw);
    switch (r->r[0]) {
    case PointerReason_Request:
        if (r->r[1] == PointerDevice_USB) {
            /* Turn off interrupts while updating */
            _kernel_irqs_off ();
            r->r[2] = relx;
            r->r[3] = rely;
            relx = rely = 0;
            _kernel_irqs_on ();
            }
        break;

#define RECORD "\x0\x0\x0\x0\x0\x0\x0\x0\x4USB Mouse"
    case PointerReason_Identify:
        e = _swix (OS_Module,

            _IN(0) | _IN(3) | _OUT(2),

            6,
            strlen(RECORD)+1,
            r->r + 1
            );

        if (!e) strcpy ((char*) r->r[1], RECORD);
        break;

    case PointerReason_Selected:
        if (r->r[1] == PointerDevice_USB) {
            edp[3].skip = 0;
            state = 1;
            edp[3].head.flags.halted = 0;
            tdp[3].conditionCode = OHCI_CC_NOT_ACCESSED;
            dprintf (("", "USB mouse enabled\n"));
        } else {
            edp[3].skip = 1;
            state = 0;
            dprintf (("", "USB mouse disabled\n"));
        }
        break;
    }

    return 1;
}


_kernel_oserror *module_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
    NOTUSED(arg_string);
    NOTUSED(argc);
    NOTUSED(pw);

    switch (cmd_no) {
    case CMD_USBStatus:
        printf ("Write back done head   : %d\n", wdh);
        printf ("Start of frames        : %d\n", sofs);
        printf ("Root hub status change : %d\n", rhsc);
        printf ("Resets                 : %d\n", resets);
        printf ("Interrupt condition    : %s\n", completion_codes[tdp[0].conditionCode]);
        printf ("Address condition      : %s\n", completion_codes[tdp[1].conditionCode]);
        printf ("Config  condition      : %s\n", completion_codes[tdp[2].conditionCode]);
        printf ("Status condition       : %s\n", completion_codes[tdp[3].conditionCode]);
        printf ("Data received          : %d\n", data_received);
        printf ("Transfers              : %8p\n", tdp);
        printf ("Port status            : %s\n", port_state_str[port_state]);
        printf ("Key status             : %08x %08x %08x %08x\n"
                "                         %08x %08x %08x %08x\n"
                "Modifiers              : %x\n",
                status[0], status[1], status[2], status[3],
                status[4], status[5], status[6], status[7],
                odata.modifiers);
        printf ("LEDs                   : %x\n", leds);
        break;
    case CMD_USBStart:
        CLAIM(usb_irq_entry, pw);

        _swix (OS_Claim, _INR(0,2), KeyV, keyv_entry, pw);

        _swix (OS_CallAVector, _INR(0, 1) | _IN(9),
            KeyV_KeyboardPresent, KeyboardID_PC, KEYV);

        _swix (OS_Claim, _INR(0,2), PointerV, pointerv_entry, pw);


        _swix (OS_Pointer, _IN(0) | _OUT(0), 0, &prev_pointer);

        /* enable periodic list processing */
        OREAD(OHCI_CONTROL, &argc);
        OWRITE(OHCI_CONTROL,argc | OHCI_PLE | OHCI_CLE);
        break;
    }
    return 0;
}

/* Callback function to set the pointer type and declare keybaord */
_kernel_oserror* pointer_cb (_kernel_swi_regs* r, void* pw, void* cur_pointer)
{
    NOTUSED(r);
    NOTUSED(pw);

    _swix (OS_CallAVector, _INR(0, 1) | _IN(9),
        KeyV_KeyboardPresent, KeyboardID_PC, KEYV);

    return _swix (OS_Pointer, _INR(0,1), 1, cur_pointer);
}

_kernel_oserror* reset_cb (_kernel_swi_regs* r, void* pw, void* data)
{
    NOTUSED(r);
    NOTUSED(pw);
    NOTUSED(data);

    OWRITE(OHCI_RH_PORT_STATUS(1), UPS_RESET);
    return 0;
}

_kernel_oserror* set_config_cb (_kernel_swi_regs* r, void* pw, void* data)
{
    int w;
    NOTUSED(r);
    NOTUSED(pw);
    NOTUSED(data);

    edp[2].head.pointer.normal = tda[2];
    edp[2].skip = 0;

    tdp[2].dataToggle = 2; /* force DATA0 */
    tdp[2].errorCount = 0;
    tdp[2].conditionCode = OHCI_CC_NOT_ACCESSED;
    tdp[2].currentBuffer = vtophys (&setConfig);
    tdp[2].nextTD = tda[3];
    tdp[2].bufferEnd = tdp[2].currentBuffer + 7;

    tdp[3].nextTD = 0;
    tdp[3].direction = 2;
    tdp[3].dataToggle = 3; /* force DATA1 */
    tdp[3].conditionCode = OHCI_CC_NOT_ACCESSED;
    tdp[3].errorCount = 0;

    OREAD(OHCI_COMMAND_STATUS, &w);
    OWRITE(OHCI_COMMAND_STATUS, w | OHCI_CLF);

    return 0;
}

_kernel_oserror* set_address_cb (_kernel_swi_regs* r, void* pw, void* data)
{
    int w;
    NOTUSED(r);
    NOTUSED(pw);
    NOTUSED(data);

    edp[1].head.pointer.normal = tda[1];
    edp[1].skip = 0;

    tdp[1].nextTD = tda[3];
    tdp[1].currentBuffer = vtophys (&setAddress);
    tdp[1].bufferEnd = tdp[1].currentBuffer + 7;
    tdp[1].dataToggle = 2; /* force DATA0 */
    tdp[1].conditionCode = OHCI_CC_NOT_ACCESSED;
    tdp[1].errorCount = 0;

    tdp[3].nextTD = 0;
    tdp[3].direction = 2;
    tdp[3].dataToggle = 3; /* force DATA1 */
    tdp[3].conditionCode = OHCI_CC_NOT_ACCESSED;
    tdp[3].errorCount = 0;

    OREAD(OHCI_COMMAND_STATUS, &w);
    OWRITE(OHCI_COMMAND_STATUS, w | OHCI_CLF);
    return 0;
}

static void read_key_data (void) {
    int i;
    int key;
    int bit;
    uint8_t mods = data.modifiers;
    uint8_t omods = odata.modifiers;
    uint8_t moddiff;
    uint32_t newstatus[8];

    /* check for error condition */
    if (data.keycode[0] == 1) return;

    memset (&newstatus[0], 0, sizeof newstatus);

    /* check each bit of the modifier field, if it's changed state,
       report the new state */
    moddiff = mods ^ omods;
    for (i = 0; i < 8; ++i) {
        if (moddiff & (1 << i)) {
            _swix (OS_CallAVector,

                _INR(0,1) | _IN(9),

                (mods & (1 << i))? KeyV_KeyDown: KeyV_KeyUp,
                mapping_table[0xe0 + i],
                KEYV
            );
        }
    }

    /* Scan new keys for key down event.  We have to construct the
    newstatus before we can check for key down. */
    for (i = 0; i < NKEYCODE; ++i) {
        key = mapping_table[data.keycode[i]];
        if (key != RSVD && key != NEQV) {
            bit = 1 << (key % 32);
            newstatus[key / 32] |= bit;
            if ((status[key / 32] & bit) == 0)
                _swix (OS_CallAVector,

                    _INR(0,1) | _IN(9),

                    KeyV_KeyDown,
                    key,
                    KEYV
                );
        }
    }

    /* Scan old keys for key up event */
    for (i = 0; i < NKEYCODE; ++i) {
        key = mapping_table[odata.keycode[i]];
        if (key != RSVD && key != NEQV) {
            bit = 1 << (key % 32);
            if ((newstatus[key / 32] & bit) == 0)
                _swix (OS_CallAVector,

                    _INR(0,1) | _IN(9),

                    KeyV_KeyUp,
                    key,
                    KEYV
                );
        }
    }

    memcpy (status, newstatus, sizeof status);
    odata = data;

    data_received++;
}

static void read_mouse_data (void)
{
    uint8_t change;
    relx += mouse_data.relx;
    rely -= mouse_data.rely;
    data_received++;
    dprintf(("",
     "%d, mouse_data.rely = %d, relx = %d, rely = %d, buttons = %x\n",
        mouse_data.relx, mouse_data.rely, relx, rely, mouse_data.buttons));
    if ((change = buttons ^ mouse_data.buttons) != 0) {
        buttons = mouse_data.buttons;
        if (state == 1) {
            if (change & 1)
                _swix (OS_CallAVector,

                    _INR(0,1) | _IN(9),

                    1 + ((buttons & 1) == 1),
                    0x70,
                    KEYV
                    );

            if (change & 4)
                _swix (OS_CallAVector,

                    _INR(0,1) | _IN(9),

                    1 + ((buttons & 4) == 4),
                    0x71,
                    KEYV
                    );

            if (change & 2)
                _swix (OS_CallAVector,

                    _INR(0,1) | _IN(9),

                    1 + ((buttons & 2) == 2),
                    0x72,
                    KEYV
                    );
        }
    }
}

_kernel_oserror *usb_irq_handler(_kernel_swi_regs *r, void *pw)
{
    int w;
    NOTUSED(pw);
    NOTUSED(r);
    OREAD(OHCI_INTERRUPT_STATUS, &w);

    if (w & OHCI_WDH) {
        OHCI_TD* dh = hccap->donehead.pointer;

        /* we have to clear the bottom bit of the RDH because it signifies
        that there are other interrupts */
        dh = (OHCI_TD*) ((int) dh & ~1);

        wdh++;
        OWRITE(OHCI_INTERRUPT_STATUS, OHCI_WDH);
        dprintf(("", "writeback done, condition = %d\n",
            tdp[0].conditionCode));
        switch (port_state) {
        case port_default:
                if (tdp[3].conditionCode == OHCI_CC_NO_ERROR &&
                    port_state == port_default
                ) {
                    port_state = port_address;
                    /* configure device */
                    callx_add_callafter (USB_DELAY_CONFIG, set_config_cb, 0);
                }
            break;
        case port_address:
            if (tdp[3].conditionCode == OHCI_CC_NO_ERROR &&
                port_state == port_address
            ) {
                port_state = port_configured;
                /* activate keyboard operation */
                edp[0].skip = 0;
                edp[0].head.flags.halted = 0;
                tdp[0].conditionCode = OHCI_CC_NOT_ACCESSED;

                /* select ourselves as a pointer */
                callx_add_callback (pointer_cb, (void*) PointerDevice_USB);
            }
            break;
        case port_configured:

            /* transfer 0 is for the report interrupt */
            if (dh == tda[0] || (dh == tda[2] && tdp[2].nextTD == tda[0])) {
                read_key_data ();
                tdp[0].conditionCode = OHCI_CC_NOT_ACCESSED;
                tdp[0].currentBuffer = (char*) vtophys (&data);
                edp[0].tailPointer = 0;
                edp[0].head.pointer.normal = tda[0];
            }

            /* transfer 5 is for the mouse */
            if (dh == tda[5] || (dh == tda[2] && tdp[2].nextTD == tda[5])) {
                read_mouse_data ();
                tdp[5].conditionCode = OHCI_CC_NOT_ACCESSED;
                tdp[5].currentBuffer = (char*) vtophys (&mouse_data);
                edp[3].tailPointer = 0;
                edp[3].head.pointer.normal = tda[5];
            }

            /* transfer 2 is for the *usbrequest (or LEDs) */
            if (dh == tda[2] || (dh == tda[0] && tdp[0].nextTD == tda[2]))
                request_complete = 1;

            break;
        }
    }

    if (w & OHCI_RHSC) {
        int w;

        /* find out what's happened */
        OREAD(OHCI_RH_PORT_STATUS(1), &w);

        /* turn off the interrupt in case we cause any more */
        OWRITE(OHCI_INTERRUPT_STATUS, OHCI_RHSC);

        /* Reset port (to enable it) if we've connected */
        if (w & UPS_C_CONNECT_STATUS) {
            if (w & UPS_CURRENT_CONNECT_STATUS) {
                port_state = port_powered;
                callx_add_callafter (USB_DELAY_RESET, reset_cb, 0);
            } else {
                /* turn off any keys that are pressed */
                memset (&data, 0, sizeof data);
                memset (&mouse_data, 0, sizeof mouse_data);
                read_key_data ();
                read_mouse_data ();

                port_state = port_detached;
                edp[0].skip = 1;
            }

            OWRITE(OHCI_RH_PORT_STATUS(1), w & UPS_C_CONNECT_STATUS);
        }


        /* Once we've finished resetting, address it */
        if (w & UPS_C_PORT_RESET) { // && (w & UPS_RESET == 0)) {
            resets++;
            tdp[0].conditionCode = OHCI_CC_NOT_ACCESSED;
            tdp[1].conditionCode = OHCI_CC_NOT_ACCESSED;
            tdp[2].conditionCode = OHCI_CC_NOT_ACCESSED;
            tdp[3].conditionCode = OHCI_CC_NOT_ACCESSED;
            port_state = port_default;
            callx_add_callafter (USB_DELAY_ADDRESS, set_address_cb, 0);

            OWRITE(OHCI_RH_PORT_STATUS(1), w & UPS_C_PORT_RESET);
        }

        rhsc++;
    }

    if (w & OHCI_SF) {
        OWRITE(OHCI_INTERRUPT_STATUS, OHCI_SF);
        sofs++;
    }

    return 0;
}
