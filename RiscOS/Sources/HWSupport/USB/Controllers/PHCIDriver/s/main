; Philips 1161 controller

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; module workspace
                        ^ 0, wp
Flags			# 4
BaseAddress             # 4
BuffManWkSpace          # 4	; buffer manager workspace
BuffManService          # 4     ; address of buffer manager routine
MessagesWorkspace       # 16    ; needed for messages routines
DeviceFSBlock		# 4	; address of devicefs registration block
DeviceHandle		# 4	; handle returned from DeviceFS_Register
RHInterruptBuffer       # 4     ; buffer for root hub events
RHControlBufferIn       # 4     ; buffer for root hub control in
RHControlBufferOut      # 4     ; buffer for root hub control out
ClkReadyCount           # 4     ; |
HCSuspendedCount        # 4     ; |
OPR_RegCount            # 4     ; |--- counts for each type of IRQ
AllEOTIntCount          # 4     ; |
ATLIntCount             # 4     ; |
SOFITLIntCount          # 4     ; |
ATLSize                 # 4     ; size of ATL buffer
ATLUsed                 # 4     ; amount of ATL buffer currently used
ITLSize                 # 4     ; size of ITL buffers
ITL0Used                # 4     ; amount of ITL buffer 0 used
ITL1Used                # 4     ; amount of ITL buffer 1 used
TransferList            # 4     ; list of transfers being processed
;OHCIRegs                # OHCI_regs_size
workspace               * :INDEX: @

;
; bit definitions for Flags
;
flag_OwnIRQ             * 1:SHL:2  ; set => IRQ owned for device
flag_HaveMessages	* 1:SHL:3  ; set => opened messages file
flag_Registered         * 1:SHL:4  ; set => registered device

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; port specific workspace

                        ^ 0, r11
InputStream		# 4	; devicefs stream handle
OutputStream		# 4	; devicefs stream handle
InputFSHandle		# 4     ; file switch handle of input stream
OutputFSHandle		# 4     ; file switch handle of output stream
InputBuffer		# 4	; buffer manager handle
OutputBuffer		# 4	; buffer manager handle
InputBufferPrivId      	# 4	; buffer managers private buffer id
OutputBufferPrivId	# 4	; buffer managers private buffer id
InputBufferSize		# 4	; buffer size in bytes
OutputBufferSize	# 4	;
InputBufferThreshold	# 4	; buffer threshold point in bytes
OutputBufferThreshold	# 4	;
port_workspace		* :INDEX: @

;
; bit definitions for ControlLines
;

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; standard module declarations
                AREA  |DualSerial$$Code|, CODE, READONLY, PIC

Module_BaseAddr
module          & 0
                & init    -module               ; => initalise routine
                & final   -module               ; => finalise routine
                & service -module               ; => service trap

                & title -module                 ; => title string
                & help  -module                 ; => help string
                & command_table-module		; => command table

 [ :LNOT: No32bitCode
                & 0
                & 0
                & 0
                & 0
                & 0
                & moduleflags - module          ; => module flags
 ]

title           = "PHCIDriver", 0

help            = "PHCIDriver", 9, 9, "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
                = " $Module_MinorVersion"
 ]
 [ debug
                = " (Debug on)", 0
 ]
                = 0

command_table
                Command PHCIRegs,       0, 0, 0
                Command PHCIWrite,      2, 2, 0
                Command PHCIRead,       1, 1, 0
                Command PHCITest,       2, 2, 0
                Command PHCIReadATL,    1, 0, 0
                Command PDCIWrite,      2, 2, 0
                Command PDCIRead,       1, 1, 0
                Command PHCIDevDesc,    1, 1, 0
                Command PHCIReset,      0, 0, 0
                DCB 0

		ALIGN

 [ :LNOT: No32bitCode
moduleflags     DCD ModuleFlag_32bit
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; debug options
 [ debug
Host_Debug  	SETL 	False
HostDebugViaTML	SETL 	False
Debug_Module	SETL	True
;Debug_File      SETS	"$.Debug"
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Globals

resource_file = "Resources:$.Resources.PHCI.Messages", 0

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Error declarations

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This code handles the startup of the module, the routine must claim the
; required workspace and then initialise the driver.
;
init            Entry	"r7-r11"

                Debug   module, "Initialising PHCIDriver"

                MOV     r0, #ModHandReason_Claim
                LDR     r3, =workspace          ; r3  = amount of workspace

                SWI     XOS_Module
                EXIT    VS                      ; return if didn't work

                STR     r2, [wp]		; wp = r2
                MOV     wp, r2                  ; wp -> workspace

; zero the workspace
                MOV     r0, #0
10
                STR     r0, [r2], #4
                SUBS    r3, r3, #4
                BGT     %b10

 [ standalonemessages
                ADRL    r0, resource_file_block
                SWI     XResourceFS_RegisterFiles
                EXIT    VS
 ]

30
; claim the device vector
		BL 	hardware_claim
                BLVC    register_device
                EXIT

; free workspace up before exit
40
;		BL	hardware_release
 [ standalonemessages
                MOV     r6, r0
                ADRL    r0, resource_file_block
                SWI     XResourceFS_DeregisterFiles
                MOV     r0, r6
 ]
                SETV
                EXIT

bad_hardware
        ADR     r0, ErrorBlock_BadHard
        MOV     r1, #0                          ;only use global message file
        MOV     r2, #0                          ;use MessageTrans buffer
        MOV     r4, #0                          ;don't substitute anything
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        B       %BT40

        MakeErrorBlock  BadHard

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		LTORG
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle module close down.
;

final           Entry	"r0-r1,r11"

                LDR     wp, [r12]               ; wp -> workspace
		BL	hardware_release
                BL      deregister_device

 [ standalonemessages
                ADRL    R0, resource_file_block
                SWI     XResourceFS_DeregisterFiles
 ]
                CLRV
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle service calls received by the module.
;
; Quickly test to see if they are of interest to use and pass on.

                ASSERT  Service_ResourceFSStarting < Service_DeviceFSStarting
                ASSERT  Service_DeviceFSStarting < Service_DeviceFSDying
servicetable    DCD     0
                DCD     serviceentry -module
 [ standalonemessages
                DCD     Service_ResourceFSStarting
 ]
                DCD     Service_DeviceFSStarting
                DCD     Service_DeviceFSDying
                DCD     0

                DCD     servicetable -module
service         ROUT
                MOV     r0, r0
                TEQ     r1, #Service_DeviceFSStarting
                TEQNE   r1, #Service_DeviceFSDying
 [ standalonemessages
                TEQNE   r1, #Service_ResourceFSStarting
 ]
                MOVNE   pc, lr

serviceentry    LDR     wp, [r12]

20
 [ standalonemessages
                TEQ     r1, #Service_ResourceFSStarting
                BNE     %FT30					; no so continue
                Push    "r0-r3,lr"
                ADRL    r0, resource_file_block
                MOV     lr, pc
                MOV     pc, r2
                Pull    "r0-r3,pc"				; and exit
30
 ]
                MOV  	pc, lr

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; free workspace
;
; in  : r11 port workspace pointer
;
free_workspace	Entry	"r0-r2"
		MOVS    r2, r11
		MOVNE	r0, #ModHandReason_Free
		SWINE	XOS_Module
		EXIT
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; establish device
;
; in  : r9 address of devicefs registration block
;       r10 hardware base address
;
; out : r10 address if port is present, 0 otherwise
;       r11 port workspace pointer
;
establish_device Entry "r0-r3"

; we need some workspace
                MOV     r0, #ModHandReason_Claim
                LDR     r3, =port_workspace	; amount of workspace
                SWI     XOS_Module
                STRVS   r0, [sp]
                EXIT    VS                      ; return if didn't work

		MOV	r11, r2			; establish port workspace

		MOV	r0, #0
		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; handle the command *PHCIRegs
;
;
hc_32bit_registers
                DCD     HcRevision
                = "HcRevision           : ", 0
                DCD     HcControl
                = "HcControl            : ", 0
                DCD     HcCommandStatus
                = "HcCommandStatus      : ", 0
                DCD     HcInterruptStatus
                = "HcInterruptStatus    : ", 0
                DCD     HcInterruptEnable
                = "HcInterruptEnable    : ", 0
                DCD     HcInterruptDisable
                = "HcInterruptDisable   : ", 0
                DCD     HcFmInterval
                = "HcFmInterval         : ", 0
                DCD     HcFmRemaining
                = "HcFmRemaining        : ", 0
                DCD     HcFmNumber
                = "HcFmNumber           : ", 0
                DCD     HcLSThreshold
                = "HcLSThreshold        : ", 0
                DCD     HcRhDescriptorA
                = "HcRhDescriptorA      : ", 0
                DCD     HcRhDescriptorB
                = "HcRhDescriptorB      : ", 0
                DCD     HcRhStatus
                = "HcRhStatus           : ", 0
                DCD     HcRhPortStatus1
                = "HcRhPortStatus1      : ", 0
                DCD     HcRhPortStatus2
                = "HcRhPortStatus2      : ", 0

hc_16bit_registers
                DCD     HcHardwareConfiguration
                = "HcHardwareConfig     : ", 0
                DCD     HcDMAConfiguration
                = "HcDMAConfig          : ", 0
                DCD     HcTransferCounter
                = "HcTransferCounter    : ", 0
                DCD     HcuPInterrupt
                = "HcInterrupt          : ", 0
                DCD     HcuPInterruptEnable
                = "HcInterruptEnable    : ", 0
                DCD     HcChipID
                = "HcChipID             : ", 0
                DCD     HcScratch
                = "HcScratch            : ", 0
                DCD     HcITLBufferLength
                = "HcITLBufferLength    : ", 0
                DCD     HcATLBufferLength
                = "HcATLBufferLength    : ", 0
                DCD     HcBufferStatus
                = "HcBufferStatus       : ", 0
hc_reg_end

PHCIRegs_Help   = "*PHCIRegs reads the ISP1161s registers", 0
PHCIRegs_Syntax = "Syntax: *PHCIRegs", 0
PHCIRegs_Code Entry "r1-r5"

                LDR     r12, [r12]
                LDR     r11, BaseAddress

                ADRL    r4, hc_32bit_registers
                ADRL    r3, hc_16bit_registers
                PHPSEI  r5
10
                LDR     r0, [r4], #4
                BL      show_hex2
                MOV     r1, r0
                MOV     R0, #' '
                SWI     XOS_WriteC
                MOV     r0, r4
                SWI     XOS_Write0
                MOV     r4, r0
                MOV     r0, r1
                HCLDR   r0, r0, r2
                BL      show_hex8
                SWI     XOS_NewLine
                CMP     r4, r3
                BLO     %BT10

                ADRL    r3, hc_reg_end
20
                LDR     r0, [r4], #4
                BL      show_hex2
                MOV     r1, r0
                MOV     R0, #' '
                SWI     XOS_WriteC
                MOV     r0, r4
                SWI     XOS_Write0
                MOV     r4, r0
                MOV     r0, r1
                HCLDRH  r0, r0
                BL      show_hex4
                SWI     XOS_NewLine
                CMP     r4, r3
                BLO     %BT20

                PLP     r5

                MACRO
                WRTIRQ  $irq
                SWI     XOS_WriteS
                =       "$irq : ",0
                LDR     R0, $irq.Count
                BL      show_integer
                SWI     XOS_NewLine
                MEND

                WRTIRQ  ClkReady
                WRTIRQ  HCSuspended
                WRTIRQ  OPR_Reg
                WRTIRQ  AllEOTInt
                WRTIRQ  ATLInt
                WRTIRQ  SOFITLInt

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCIWrite
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCIWrite_Help      = "Write to a register in the ISP1161 host", 13
PHCIWrite_Syntax    = "Syntax: *PHCIWrite <register> <value>", 0
PHCIWrite_Code Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
                MOV     r3, r2
10
                LDRB    r0, [r1, #1]!
                TEQ     r0, #" "
                BEQ     %BT10

                MOV     r0, #&10
                SWI     XOS_ReadUnsigned
                EXIT    VS

                CMP     r3, #&20                ; use the call appropriate to the register
                BLHS    %FT20
                HCSTR   r2, r3
                EXIT
20
                HCSTRH  r2, r3
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCIRead
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCIRead_Help      = "Read a register from the ISP1161 host", 13
PHCIRead_Syntax    = "Syntax: *PHCIRead <register>", 0
PHCIRead_Code Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
10
                CMP     r2, #&20                ; use the call appropriate to the register
                BLHS    %FT20
                HCLDR   r0, r2
                BL      show_hex8
                SWI     XOS_NewLine
                EXIT
20
                HCLDRH  r0, r2
                BL      show_hex4
                SWI     XOS_NewLine
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PDCIWrite
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PDCIWrite_Help      = "Write to a register in the ISP1161 device", 13
PDCIWrite_Syntax    = "Syntax: *PDCIWrite <register> <value>", 0
PDCIWrite_Code Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
                MOV     r3, r2
10
                LDRB    r0, [r1, #1]!
                TEQ     r0, #" "
                BEQ     %BT10

                MOV     r0, #&10
                SWI     XOS_ReadUnsigned
                EXIT    VS

                DCSTRH  r2, r3
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PDCIRead
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PDCIRead_Help      = "Read a register in from the ISP1161 device", 13
PDCIRead_Syntax    = "Syntax: *PDCIRead <register>", 0
PDCIRead_Code Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
                MOV     r3, r2

20
                HCLDRH  r0, r3
                BL      show_hex4
                SWI     XOS_NewLine

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCITest
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCITest_Help       = "Send some test data on the bus from memory", 13
PHCITest_Syntax     = "Syntax: *PHCITest <memory> <size>", 0
PHCITest_Code   Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress

                ; Clear the EOT and ATL interrupt bit
                MOV     r3, #HcuPInterrupt
                MOV     r4, #AllEOTInt
                HCSTRH  r4, r3

                ; Allocate all RAM to the ATL buffer
                MOV     r3, #HcATLBufferLength
                MOV     r4, #&1000
                HCSTRH  r4, r3

                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
                MOV     r3, r2
10
                LDRB    r0, [r1, #1]!
                TEQ     r0, #" "
                BEQ     %BT10

                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS

                ; Allocate RAM to the ATL buffer
;                MOV     r0, #HcATLBufferLength
;                HCSTRH  r2, r0

                ; Setup the transfer length
                MOV     r0, #HcTransferCounter
                HCSTRH  r2, r0

                ; Start the transfer
                MOV     r0, #HcATLBufferPort:OR:&80
                STR     r0, HCCommand

                ; Write all the data
                Push    "r2, r3"
20
                LDR     r0, [r3], #2
                STR     r0, HCData
                SUBS    r2, r2, #2
                BHI     %BT20

                ; Wait for the next interrupt
                LDR     R3, ATLIntCount
                SWI     XOS_ReadMonotonicTime
                ADD     R2, R0, #100
                ADR     R1, PHCITest_Code   ; somewhere non-zero
30
                LDR     R4, ATLIntCount
                TEQ     R3, R4
                BNE     %f40
                MOV     R0, #6
                SWI     XOS_UpCall
                SWI     XOS_ReadMonotonicTime
                CMP     R0, R2
                BLT     %b30
                Pull    "r2, r3"
                SWI     OS_WriteS
                =       "Timeout waiting for device reply",10,13,0
                EXIT
40
                ; Read back the data
                Pull    "r2, r3"

                ; Setup the transfer length
                MOV     r0, #HcTransferCounter
                HCSTRH  r2, r0

                ; Start the transfer
                MOV     r0, #HcATLBufferPort
                STR     r0, HCCommand
50
                LDR     r0, HCData
                STRB    r0, [r3], #1
                MOV     r0, r0, LSR#8
                STRB    r0, [r3], #1
                SUBS    r2, r2, #2
                BHI     %BT50

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCIDevDesc
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCIDevDesc_Help       = "Read the device descriptor of the connected device to the memory location specified", 13
PHCIDevDesc_Syntax     = "Syntax: *PHCIDevDesc <memory>", 0
PHCIDevDesc_Code   Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress

                ; Clear the EOT and ATL interrupt bit
                MOV     r3, #HcuPInterrupt
                MOV     r4, #AllEOTInt
                HCSTRH  r4, r3

                ; Allocate all RAM to the ATL buffer
                MOV     r3, #HcATLBufferLength
                MOV     r4, #&1000
                HCSTRH  r4, r3

                MOV     r1, r0                  ; Command tail
                MOV     r0, #&10                ; Base
                SWI     XOS_ReadUnsigned
                EXIT    VS
                MOV     r8, r2                  ; save for later

                ; Wait for the next interrupt
                ADR     R1, SOFITLIntCount
                MOV     r0, #10
                BL      wait_for_interrupt
                EXIT    VS

                ; fill buffer
                ADR     r0, GetDevDesc
                MOV     r1, #16
                BL      write_atl_buffer

                ; Wait for the next interrupt
                ADR     R1, ATLIntCount
                MOV     r0, #10
                BL      wait_for_interrupt
                EXIT    VS

                ; fill buffer
                ADR     r0, read18
                MOV     r1, #26
                BL      write_atl_buffer

                ; Wait for interrupt
                ADR     R1, ATLIntCount
                MOV     r0, #10
                BL      wait_for_interrupt
                EXIT    VS

                ; Read back the data

                ; Setup the transfer length
                MOV     r0, #HcTransferCounter
                MOV     r2, #26
                HCSTRH  r2, r0

                ; Start the transfer
                MOV     r0, #HcATLBufferPort
                STR     r0, HCCommand

                ; Read out header
                LDR     r0, HCData
                LDR     r0, HCData
                LDR     r0, HCData
                LDR     r0, HCData

                ; Read back data
                MOV     r3, r8
                MOV     r2, #18
10
                LDR     r0, HCData
                STRB    r0, [r3], #1
                MOV     r0, r0, LSR#8
                STRB    r0, [r3], #1
                SUBS    r2, r2, #2
                BHI     %BT10

                ; Acknowledge
                ADR     r0, acknowledge
                MOV     r1, #8
                BL      write_atl_buffer

                ; Wait for interrupt
                ADR     R1, ATLIntCount
                MOV     r0, #10
                BL      wait_for_interrupt

                EXIT

GetDevDesc  = &00, &08, &08, &0C, &08, &00, &00, &00, &80, &06, &00, &01, &00, &00, &12, &00
read18      = &00, &0C, &08, &0C, &12, &08, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00, &00
acknowledge = &00, &0C, &08, &0C, &00, &04, &00, &00

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle the * command PHCIReadATL
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PHCIReadATL_Help       = "Dump the contents of the ATL buffer", 13
PHCIReadATL_Syntax     = "Syntax: *PHCIReadATL [<nbytes>]", 0
PHCIReadATL_Code   Entry "r0-r5"
                LDR     r12, [r12]
                LDR     r11, BaseAddress

                PHPSEI  r5

                ; Read command line
                MOV     r1, #0
                MOV     r2, #0
                SWI     XOS_EvaluateExpression
                BVS     %f10
                TEQ     r1, #0
                BNE     %f10

                MOV     r4, r2
                B       %f15
10
                ; Read ATL buffer size
                MOV     r3, #HcATLBufferLength
                HCLDRH  r4, r3
15
                ; Setup the transfer length
                MOV     r0, #HcTransferCounter
                HCSTRH  r4, r0

                ; Start the transfer
                MOV     r0, #HcATLBufferPort
                STR     r0, HCCommand

                ; Read all the data, writing it to screen
                SUB     sp, sp, #8
20
                LDR     r0, HCData
                MOV     r1, r13
                MOV     r2, #8
                SWI     XOS_ConvertHex4
                SWIVC   XOS_Write0

                ; Put a space between each read, and a newline every 8
                SUBS    r4, r4, #2
                BEQ     %FT30

                TST     r4, #&1f
                SWIEQ   XOS_NewLine
                BEQ     %BT20

                MOV     r0, #' '
                SWI     XOS_WriteC
                B       %BT20
30
                ADD     sp, sp, #8
                SWI     XOS_NewLine

                PLP     r5

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Return status info
;

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handles the PHCIReset command
;
PHCIReset_Help      = "Reset the ISP1161 safely", 13
PHCIReset_Syntax    = "Syntax: PHCIReset", 0
PHCIReset_Code
                Entry
                LDR     r12, [r12]
                LDR     r11, BaseAddress
                PHPSEI  r4
                MOV     r0, #HcSoftwareReset:OR:&80
                STR     r0, HCCommand

                MOV     r0, #HcHardwareConfiguration
                LDR     r1, =HcHardConfReserved:OR:EOTInputPolarity:OR:DataBusWidth:OR:InterruptOutputPolarity:OR:InterruptPinEnable
                HCSTRH  r1, r0

                MOV     r0, #HcFmInterval   ; set fs largest packet - needed for low speed as well
                LDR     r1, =&20002edf
                HCSTR   r1, r0

                ; Turn on power
                MOV     r0, #HcRhStatus
                MOV     r1, #&10000
                HCSTR   r1, r0

                ; Turn HC interrupts on
                MOV     R0, #HcuPInterruptEnable
                MOV     R1, #HCAllInts
                HCSTRH  R1, R0

                PLP     r4

                ; Start the controller
                MOV     R3, #HcControl
                SWI     OS_ReadMonotonicTime
                ADD     R2, R0, #100
20
                MOV     R1, #&80
                HCSTR   R1, R3
                SWI     OS_ReadMonotonicTime
                CMP     R0, R2
                BGT     %f30
                HCLDR   R1, R3
                TEQ     R1, #&80
                BNE     %b20
30
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Wait for an ATL interrupt
;
; in:
;    r0 - timeout
;    r1 - pollword (interrupt counter)
; out:
;    V set if timed out, and r0 points to error

wait_for_interrupt
                Entry   "R2,R3"
                MOV     R2, R0
                ; Wait for the next interrupt
                SWI     XOS_ReadMonotonicTime
                ADD     R2, R2, R0
                MOV     R0, #0
                STR     R0, [R1]
10
                LDR     R3, [R1]
                TEQ     R3, #0
                EXIT    NE
;                MOV     R0, #6
;                SWI     XOS_UpCall
                SWI     XOS_ReadMonotonicTime
                CMP     R0, R2
                BLT     %b10

                ADR     R0, ErrorBlock_PHCI_Timeout
                BL      make_error
                EXIT

                MakeErrorBlock  PHCI_Timeout

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Write a buffer to the ATL FIFO
;
; in:
;    r0 - pointer to buffer
;    r1 - number of bytes
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
write_atl_buffer
                Entry   "r0-r2"
                ; Setup the transfer length
                MOV     r2, #HcTransferCounter
                HCSTRH  r1, r2

                ; Start the transfer
                MOV     r2, #HcATLBufferPort:OR:&80
                STR     r2, HCCommand
10
                LDR     r2, [r0], #2
                STR     r2, HCData
                SUBS    r1, r1, #2
                BHI     %b10
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Writes an integer to the screen.
;
; in:
;    r0 - value to be displayed
show_integer	Entry "r1-r2"
        	SUB     r13, r13, #16
        	MOV     r1, r13
        	MOV     r2, #16
        	SWI     XOS_ConvertInteger4
        	SWIVC	OS_Write0
        	ADD     r13, r13, #16
        	EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Routine to write a hex number to the screen
; in:
;    r0 - value to be displayed
show_hex8
        Push    "r1-r2, lr"
        SUB     r13, r13, #16
        MOV     r1, r13
        MOV     r2, #16
        SWI     XOS_ConvertHex8
        SWIVC	OS_Write0
        ADD     r13, r13, #16
        Pull    "r1-r2, pc"
show_hex4
        Push    "r1-r2, lr"
        SUB     r13, r13, #16
        MOV     r1, r13
        MOV     r2, #16
        SWI     XOS_ConvertHex4
        SWIVC	OS_Write0
        ADD     r13, r13, #16
        Pull    "r1-r2, pc"
show_hex2
        Push    "r0-r2, lr"
        SUB     r13, r13, #16
        MOV     r1, r13
        MOV     r2, #16
        SWI     XOS_ConvertHex2
        SWIVC	OS_Write0
        ADD     r13, r13, #16
        Pull    "r0-r2, pc"


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generalised internationalisation routines, these ensure that messages files
; are correctly opened and then return the relevant data.
;
; Attempt to open the messages file.

open_messages   Entry   "r0-r3"
                LDRB    r3, Flags
                TST     r3, #flag_HaveMessages
                EXIT    NE

                ADR     r0, MessagesWorkspace
                ADRL    r1, resource_file     ; -> path to be opened
                MOV     r2, #0                ; allocate some wacky space in RMA
                SWI     XMessageTrans_OpenFile
                LDRVCB  r3, Flags
                ORRVC   r3, r3, #flag_HaveMessages
                STRVCB  r3, Flags
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Attempt to close the messages file.

close_messages  Entry   "r0"
                LDRB    r0, Flags
                TST     r0, #flag_HaveMessages
                EXIT    EQ

                ADR     r0, MessagesWorkspace
                SWI     XMessageTrans_CloseFile
                LDRVCB  r0, Flags
                BICVC   r0, r0, #flag_HaveMessages
                STRVCB  r0, Flags
                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generate an error based on the error token given.  Does not assume that
; the messages file is open.  Will attempt to open it, then look it up.
; if make_error_with_name is called, the module name is substituted in r4

make_error_with_name Entry "r1-r7"
		ADRL	r4, title
		B	make_error_entry

make_error      ALTENTRY
                MOV     r4, #0
make_error_entry
                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BLEQ    open_messages

                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BEQ     make_error_exit

                ADR     r1, MessagesWorkspace
                MOV     r2, #0
                MOV     r3, #0
                MOV     r5, #0
                MOV     r6, #0
                MOV     r7, #0
                SWI     XMessageTrans_ErrorLookup
                BL      close_messages

make_error_exit
                SETV
                EXIT                           ; return, r0 -> block, V set

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This bit of apparently harmless code will bind a messages file into the code
; in the case of a standalone module. The macro ResourceFile will create the
; stuff and the label resource_file is used to point to the block required by
; ResourceFS

 [ standalonemessages
resource_file_block
	ResourceFile $MergedMsgs, Resources.Serial.Messages
	DCD     0
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		END
