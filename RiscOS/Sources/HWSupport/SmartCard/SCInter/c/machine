/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

/*
 * State machine for cards
 *
 * Modification History
 *---------------------
 *
 * 24-Nov-98  AJP,  Split from module.c to accomodate new state machine.
 *                  This file contains 2 state machines, one for the orginal
 *                  NC T=0 cards and a new one to accomodate the Funai3
 *                  T=1 cards.
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "kernel.h"
#include "swis.h"
#include "sctrans.h"
#include "module.h"
#include "irqs.h"
#include "header.h"
#include "scinter.h"
#include "cards.h"
#include "path.h"
#include "records.h"

#include "Debuglib/Debuglib.h"

#ifndef MINIJIS_CARD
/******************************************************************************
  the state machine for Orga, Incard and Schlumberger cards
 ******************************************************************************/
void machine(t_transitions transition, _kernel_swi_regs *r)
{
  static _kernel_swi_regs entry;
  static int files[MAX_SUBDIRS];
  static int num_files;
  static int current_file;
  static int err;
  static int offset;
  static int chunk_size;
  static int status_error = 0;
  static int doing_retry = 0;
  BYTE file_header[25];
  BYTE resp[2];
  int data_length;
  int ret = SCI_SUCCESS;
  int access_condition;

  if (transition!=StatusSWI)
  {
    dprintf(("", "machine (%s)\n",strTransitions[transition]));
  }

  switch (transition)
  {
    case Done :
      switch (state)
      {
        case WaitingOpen :
          err = open_card();
          switch (err)
          {
            case SC_SUCCESS :
              state = WaitingATR;
              break;
	    case SC_UNDERSTAND :
              state = WaitingRemoval;
              break;
          }
          break;
        case WaitingATR :
          if (get_atr() == SC_SUCCESS)
          {
            state = Idle;
            module_notify(Event_CardOK,0);
          }
          else
          {
            state = WaitingRemoval;
            module_notify(Event_CardBad,0);
          }
          break;
	case Idle :
	  /* ingore */
	  break;
	case SelectingDir :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    if (current_file == num_files-1)   /* are we on the leaf name */
	    {
	      switch (entry_trans)
	      {
	        case CreateSWI :
	          state = Creating;
		  ret = (*CurrExports->card_create)(card_handle,
		      	files[current_file++],(entry.r[0]&1<<1)?1:0,entry.r[2],
		      	entry.r[3]);
	          break;
	        case ReadSWI : case WriteSWI :
	        case DeleteSWI : case FileInfoSWI :
    	          state = SelectingFile;
                  ret = (*CurrExports->card_select)(card_handle,
                      	files[current_file++]);
                  break;
                case ChangeCHVSWI :
                case EnableCHVSWI : case UnBlockCHVSWI :
	      	  ret = (*CurrExports->card_select)(card_handle,
	      	      	files[current_file++]);
                  break;
              }
	    }
	    else if (current_file == num_files) /* leaf name was a directory */
	    {
	      switch (entry_trans)
	      {
	        case ChangeCHVSWI :
	          state = ChangingCHV;
  		  ret = (*CurrExports->card_change_chv)(card_handle,
  		      	entry.r[2], (char*)entry.r[3], entry.r[4],
  		      	(char*)entry.r[5], entry.r[6]);
	          break;
                case EnableCHVSWI :
                  state = EnablingCHV;
		  ret = (*CurrExports->card_enable_chv)(card_handle,
		      	entry.r[2],(entry.r[0]&1<<1)?1:0,(char*)entry.r[3],
		      	entry.r[4]);
	          break;
                case UnBlockCHVSWI :
                  state = UnBlockingCHV;
   		  ret = (*CurrExports->card_unblock_chv)(card_handle,
   		      	entry.r[2], (char*)entry.r[3],
   		      	entry.r[4], (char*)entry.r[5], entry.r[6]);
                  break;
                case FileInfoSWI :
	    	  state = GettingResponse;
	    	  ret = (*CurrExports->card_get_response)(card_handle,
	    	      	(int)resp[1]);
                  if (ret == SCI_FAIL)
            	  {
		    err = SC_TRANSPORT;
              	    machine(Error,r);
                  }
                  break;
              }
            }
	    else /* change into next directory in path */
	    {
	      ret = (*CurrExports->card_select)(card_handle,
	      	    files[current_file++]);
	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case SelectingFile :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully selected the file, get header response
	     */
	    dprintf(("", "file selected\n"));
	    state = GettingResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingResponse :
	  err=handle_response(file_header,sizeof(file_header),
	                      &data_length,resp);
	  dprintf(("", "(7) got response, err = %d",err));
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully get the response message, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
	        access_condition = file_header[9]>>4 & 0xf;
                if (access_condition==0) /* no write access cond */
                {
                  state = Deleting;
                  ret = (*CurrExports->card_delete)(card_handle,
                        files[num_files-1]);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;
	      case ReadSWI :
	        access_condition = file_header[8]>>4 & 0xf;
                if (access_condition==0) /* no read access cond */
                {
                  state = ReadingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_read)(card_handle,entry.r[2],
              	      	chunk_size);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else  /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;
	      case WriteSWI:
	        access_condition = file_header[8] & 0xf;
                if (access_condition==0) /* no write access cond */
                {
       	          state = WritingFile;
                  offset = entry.r[2];
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_write)(card_handle, offset,
        	        (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
        	}
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
        	else /* access condition to deal with */
        	{
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
        	}
	        break;
	      case FileInfoSWI :
	        dprintf(("", "(7) FileInfoSWI"));
	      	if (entry.r[0] & 1<<1) /* bit 1 populate structure */
	      	{
	      	  t_sc_stat *stat_ptr = (t_sc_stat*)entry.r[2];

                  stat_ptr->num_files = -1;
                  stat_ptr->num_dirs  = -1;
                  stat_ptr->chv1_attempts = -1;
                  stat_ptr->unblock_chv1_attempts = -1;
	      	  stat_ptr->file = 1;        /* default to file */

	      	  if (ATR.hist[0] == 7) /* schlumberger */
	      	  {
	      	    dprintf(("", "(7)   schlumberger (0x%x)",file_header[6]));
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
		    if (file_header[6] == 0x38 || file_header[6] == 0x02)
		    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = (file_header[18]==0)?0:1;
	      	      stat_ptr->unblock_chv1_enabled = (file_header[19]==0)?0:1;
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18];
  		      stat_ptr->unblock_chv1_attempts= file_header[19];
		    }
	      	  }
	      	  else
	      	  {
	      	    dprintf(("", "(7)   other card (0x%x)",file_header[6]));
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
	      	    if (file_header[6] != 0x04) /* not file */
	      	    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = file_header[18]>>7;
	      	      stat_ptr->unblock_chv1_enabled = file_header[19]>>7;
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18] & 0xf;
  		      stat_ptr->unblock_chv1_attempts= file_header[19] & 0xf;
	      	    }
	      	  }
	      	}
	      	else
	      	{
  	          if (entry.r[3]>sizeof(file_header))
  	            memcpy((char*)entry.r[2],file_header,sizeof(file_header));
  	          else
  	            memcpy((char*)entry.r[2],file_header,entry.r[3]);
                }
                sctransport_end_trans(card_handle);
	    	state = Idle;
	    	module_notify(Event_Complete,SC_SUCCESS);
	        break;
	    }

            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingAuthResponse :
          err=handle_response((BYTE*)entry.r[5],entry.r[6],&data_length,resp);
	  if (err==SC_SUCCESS)
   	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
            module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);
	  break;

	case VerifyingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS || (resp[0]==0x98 && resp[1]==0x08))
	  {
	    dprintf(("", "verified CHV\n"));
	    /*
	     * we have successfully verified the CHV, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
                state = Deleting;
                ret = (*CurrExports->card_delete)(card_handle,
                      files[num_files-1]);
	      case ReadSWI :
	        state = ReadingFile;
	        offset = 0;
	        chunk_size = CurrExports->chunk_size;
	        if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

	        ret = (*CurrExports->card_read)(card_handle,entry.r[2],
	              chunk_size);
	        break;
	      case WriteSWI :
	        state = WritingFile;
	        offset = entry.r[2];
	        chunk_size = CurrExports->chunk_size;
	        if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

	        ret = (*CurrExports->card_write)(card_handle, offset,
	               (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
	        break;
	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case Creating : case Deleting :
	case ChangingCHV : case EnablingCHV : case UnBlockingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
	    module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);

	  break;

	case ReadingFile :
	  err=handle_response((BYTE*)(entry.r[3]+offset),chunk_size,
	     &data_length,resp);
	  if (err == SC_SUCCESS)
	  {
	    offset+=chunk_size;
	    if (offset>=entry.r[4])  /* have we finished reading yet */
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      chunk_size = CurrExports->chunk_size;
	      if (entry.r[4]-offset<chunk_size) chunk_size = entry.r[4]-offset;

	      ret = (*CurrExports->card_read)(card_handle,entry.r[2]+offset,
	      	    chunk_size);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
  	  }
  	  else
  	    machine(Error,r);
	  break;
	case WritingFile :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    offset+=chunk_size;
	    if (offset>=entry.r[4])  /* have we finished writing yet */
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      chunk_size = CurrExports->chunk_size;
	      if (offset+chunk_size>entry.r[4]) chunk_size = entry.r[4]-offset;
	      ret = (*CurrExports->card_write)(card_handle, offset,
	            (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
	  }
	  else
	    machine(Error,r);
	  break;
	case WaitingInternalAuth :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * authentication complete, now need to fetch the stuff
	     */
 	    state = GettingAuthResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;
        default :
          dprintf(("", "Ilegal state (%s) in Done\n",strState[state]));
	  state = Idle;
          break;
      }
      break;
    /*
     * end of Done
     */
    case Error :
      /*
       * special chimpanzee error handling
       */
      if ((err==SC_WRONGCLASS) && (ATR.hist[0]==0x7))
      {
        dprintf(("", "Chimpanzee processing !!!!"));
        switch (entry_trans)
        {
          case ChangeCHVSWI:
            dprintf(("", "   change chv re-direction"));
            state = ChangingCHV;
            ChimpanzeeClassByte = 0xf0;
            ret = (*CurrExports->card_change_chv)(card_handle,entry.r[2],
              (char*)entry.r[3], entry.r[4],(char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
          case UnBlockCHVSWI :
            dprintf(("", "   unblock chv re-direction"));
            state = UnBlockingCHV;
            ChimpanzeeClassByte = 0xf0;
  	    ret = (*CurrExports->card_unblock_chv)(card_handle,entry.r[2],
  	      (char*)entry.r[3], entry.r[4], (char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
        }
        if (ret == SCI_FAIL)
        {
          err = SC_TRANSPORT;
          machine(Error,r);
        }
        break;
      }
      /*
       * otherwise
       */
      if (err == 0)
      {
        err = SC_TRANSPORT;
        ret = sctransport_error(card_handle);
      }

      status_error = err;
      sctransport_end_trans(card_handle);
      sctransport_close(card_handle);
      dprintf(("", "error 0x%x state (%s) entry (%s) ret %d\n",
      	    err,strState[state],strTransitions[entry_trans],ret));
      module_notify(Event_Complete,err);
      state = WaitingOpen;
      machine(Done,r);
      break;

    case Removed :
      module_notify(Event_CardRemoved,0);
      sctransport_close(card_handle);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    case ReStart :
      module_notify(Event_CardRemoved,0);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    case TransEnd :
      switch (state)
      {
        case WaitingTrans :
          state = Idle;
          doing_retry = 1;
          machine(entry_trans,&entry);
          break;
      }
      break;
    case GetATRSWI :
      dprintf(("", "(7) state = %d",state));
      switch (state)
      {
        case WaitingOpen : case WaitingATR :
      	  r->r[0] = SC_NOCARD;
      	  r->r[1] = 0;
      	  break;
      	default :
      	  dprintf(("", "(7) returning atr, atr len = %d",ATR.len));
      	  if (ATR.len>0)
      	  {
      	    int i;
      	    for (i=0; i<ATR.len; i++)
            {
      	      dprintf(("", "(7)    ATR[%d] : 0x%x\n",i,ATR.hist[i]));
            }
      	  }
      	  r->r[0] = SC_SUCCESS;
      	  r->r[1] = (int)&ATR;
      }
      break;
    case CreateSWI : case DeleteSWI : case ReadSWI :  case WriteSWI :
    case EnableCHVSWI : case UnBlockCHVSWI : case FileInfoSWI :
    case ChangeCHVSWI :
      switch (state)
      {
        case Idle :
	  dprintf(("", "entered via %s",strTransitions[transition]));
          entry_trans = transition; /* remember transition for later */
          if (!doing_retry)
            err = path_process((char*)r->r[1],files,&num_files);
          else
            err = SC_SUCCESS;

          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = SelectingDir;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
              current_file = 0;
              ret = (*CurrExports->card_select_root)(card_handle);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;

    case InternalAuthSWI :
      switch (state)
      {
        case Idle :
          entry_trans = transition; /* remember transition for later */
          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = WaitingInternalAuth;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
      	      ret = (*CurrExports->card_internal_auth)(card_handle,
      	      entry.r[2], (BYTE*)entry.r[3], entry.r[4]);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;
    case StatusSWI :
      if (status_error!=0)
        r->r[0] = StatusError;
      else
      {
        switch (state)
        {
          case WaitingOpen : case WaitingATR :
            r->r[0] = StatusNoCard;
            break;
          case Idle :
            r->r[0] = StatusIdle;
            break;
          default :
            r->r[0] = StatusBusy;
        }
      }
      r->r[1] = status_error;
      status_error=0;
      break;
  }
}
#else
/******************************************************************************
  the state machine for Funai3 MiniJIS cards
 ******************************************************************************/
void machine(t_transitions transition, _kernel_swi_regs *r)
{
  static _kernel_swi_regs entry;
  static int files[MAX_SUBDIRS];
  static int num_files;
  static int current_file;
  static int err;
  static int offset;
  static int chunk_size;
  static int status_error = 0;
  static int doing_retry = 0;
  BYTE file_header[25];
  BYTE resp[2];
  int data_length;
  int ret = SCI_SUCCESS;
  int access_condition;

  if (transition!=StatusSWI)
  {
    dprintf(("", "machine(): transition %s\n",strTransitions[transition]));
  }

  switch (transition)
  {
    case Done:
      switch (state)
      {
        case WaitingOpen:
          err = open_card();
          switch (err)
          {
            case SC_SUCCESS:
              state = WaitingATR;
              break;
	    case SC_UNDERSTAND:
              state = WaitingRemoval;
              break;
          }
          break;

        case WaitingATR:
          if (get_atr() == SC_SUCCESS)
          {
            state = Idle;
            module_notify(Event_CardOK,0);
          }
          else
          {
            state = WaitingRemoval;
            module_notify(Event_CardBad,0);
          }
          break;

        case WaitingStandby:
	case Idle:
          dprintf(("", "machine(): Idle state\n"));
	  /* i0ngore */
	  break;

	case SelectingDir:
          dprintf(("", "machine(): Selecting dir 2\n"));
          dprintf(("", "machine(): r3: '%s'\n", (char*)entry.r[3]));
          dprintf(("", "machine(): r5: '%s'\n", (char*)entry.r[5]));
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    if (current_file == num_files-1)   /* are we on the leaf name */
	    {
	      switch (entry_trans)
	      {
	        case CreateSWI :
	          state = Creating;
		  ret = (*CurrExports->card_create)(card_handle,
		      	files[current_file++],(entry.r[0]&1<<1)?1:0,entry.r[2],
		      	entry.r[3]);
	          break;

	        case ReadSWI:
	        case WriteSWI:
	        case DeleteSWI:
	        case FileInfoSWI:
                case ChangeCHVSWI:
                case EnableCHVSWI:
                case UnBlockCHVSWI:
    	          state = SelectingFile;
                  ret = (*CurrExports->card_select)(card_handle,
                      	files[current_file++]);
                  break;
              }
	    }
	    else if (current_file == num_files) /* leaf name was a directory */
	    {
	      switch (entry_trans)
	      {
	        case ChangeCHVSWI:
	          state = ChangingCHV;
  		  ret = (*CurrExports->card_change_chv)(card_handle,
  		      	entry.r[2], (char*)entry.r[3], entry.r[4],
  		      	(char*)entry.r[5], entry.r[6]);
	          break;

                case EnableCHVSWI:
                  state = EnablingCHV;
		  ret = (*CurrExports->card_enable_chv)(card_handle,
		      	entry.r[2],(entry.r[0]&1<<1)?1:0,(char*)entry.r[3],
		      	entry.r[4]);
	          break;

                case UnBlockCHVSWI:
                  state = UnBlockingCHV;
   		  ret = (*CurrExports->card_unblock_chv)(card_handle,
   		      	entry.r[2], (char*)entry.r[3],
   		      	entry.r[4], (char*)entry.r[5], entry.r[6]);
                  break;

                case FileInfoSWI:
	    	  state = GettingResponse;
	    	  ret = (*CurrExports->card_get_response)(card_handle,
	    	      	(int)resp[1]);
                  if (ret == SCI_FAIL)
            	  {
		    err = SC_TRANSPORT;
              	    machine(Error,r);
                  }
                  break;
              }
            }
	    else /* change into next directory in path */
	    {
	      ret = (*CurrExports->card_select)(card_handle,
	      	    files[current_file++]);
	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	  {
	    machine(Error,r);
	  }
	  break;

	case SelectingFile:
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully selected the file, get header response
	     */
	    dprintf(("", "machine(): file selected\n"));
	    state = GettingResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingResponse:
	  err=handle_response(file_header,sizeof(file_header),
	                      &data_length,resp);
	  dprintf(("", "machine(): got response, err = %d",err));
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully get the response message, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
	        access_condition = file_header[9]>>4 & 0xf;
                if (access_condition==0) /* no write access cond */
                {
                  state = Deleting;
                  ret = (*CurrExports->card_delete)(card_handle,
                        files[num_files-1]);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;

	      case ReadSWI :
	        access_condition = file_header[8]>>4 & 0xf;
                if (access_condition==0) /* no read access cond */
                {
                  state = ReadingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_read)(card_handle,entry.r[2],
              	      	chunk_size);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else  /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;

	      case WriteSWI:
	        access_condition = file_header[8] & 0xf;
                if (access_condition==0) /* no write access cond */
                {
       	          state = WritingFile;
                  offset = entry.r[2];
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_write)(card_handle, offset,
        	        (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
        	}
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
        	else /* access condition to deal with */
        	{
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
        	}
	        break;

	      case FileInfoSWI :
	        dprintf(("", "machine(): FileInfoSWI"));
	      	if (entry.r[0] & 1<<1) /* bit 1 populate structure */
	      	{
	      	  t_sc_stat *stat_ptr = (t_sc_stat*)entry.r[2];

                  stat_ptr->num_files = -1;
                  stat_ptr->num_dirs  = -1;
                  stat_ptr->chv1_attempts = -1;
                  stat_ptr->unblock_chv1_attempts = -1;
	      	  stat_ptr->file = 1;        /* default to file */

	      	  if (ATR.hist[0] == 7) /* schlumberger */
	      	  {
	      	    dprintf(("", "(7)   schlumberger (0x%x)",file_header[6]));
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
		    if (file_header[6] == 0x38 || file_header[6] == 0x02)
		    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = (file_header[18]==0)?0:1;
	      	      stat_ptr->unblock_chv1_enabled = (file_header[19]==0)?0:1;
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18];
  		      stat_ptr->unblock_chv1_attempts= file_header[19];
		    }
	      	  }
	      	  else
	      	  {
	      	    dprintf(("", "(7)   other card (0x%x)",file_header[6]));
      	            stat_ptr->size = file_header[2]<<8 | file_header[3];
	      	    if (file_header[6] != 0x04) /* not file */
	      	    {
	      	      stat_ptr->file = 0;        /* directory */
	      	      stat_ptr->chv1_enabled         = file_header[18]>>7;
	      	      stat_ptr->unblock_chv1_enabled = file_header[19]>>7;
      	              stat_ptr->num_dirs  	     = file_header[14];
      	              stat_ptr->num_files 	     = file_header[15];
  		      stat_ptr->chv1_attempts	     = file_header[18] & 0xf;
  		      stat_ptr->unblock_chv1_attempts= file_header[19] & 0xf;
	      	    }
	      	  }
	      	}
	      	else
	      	{
                  dprintf(("", "machine(): Starting r3 copy\n"));
  	          if (entry.r[3]>sizeof(file_header))
  	            memcpy((char*)entry.r[2],file_header,sizeof(file_header));
  	          else
  	            memcpy((char*)entry.r[2],file_header,entry.r[3]);
                }
                sctransport_end_trans(card_handle);
	    	state = Idle;
	    	module_notify(Event_Complete,SC_SUCCESS);
	        break;
	    }

            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingAuthResponse :
          err=handle_response((BYTE*)entry.r[5],entry.r[6],&data_length,resp);
	  if (err==SC_SUCCESS)
   	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
            module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);
	  break;

	case VerifyingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS || (resp[0]==0x98 && resp[1]==0x08))
	  {
	    dprintf(("", "machine(): verified CHV\n"));
	    /*
	     * we have successfully verified the CHV, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
                state = Deleting;
                ret = (*CurrExports->card_delete)(card_handle,
                      files[num_files-1]);
                break;

              /* modified for minijis */
              case FileInfoSWI:
              {
                int *pinc;
                pinc =(int *)entry.r[0];
                dprintf(("", "machine(): End of FileInfo SWI\n"));
                dprintf(("", "machine(): SW1:%x  SW2:%x\n", resp[0],resp[1]));
                switch ( resp [ 1] & 0xff)
                {
                  case 0:
                    dprintf(("", "machine(): Unlimited attempts left (-1)\n"));
                    *pinc =-1;
                    break;

                  case 0xc0:
                    dprintf(("", "machine(): CHV Blocked (0)\n"));
                    *pinc =0;
                    break;

                  default:
                    dprintf(("", "machine(): Attempts left: %d\n", ( resp[1] &0xf)));
                    *pinc =( resp[1] &0xf);
                  break;
                }
                sctransport_end_trans(card_handle);
	    	state = Idle;
	    	module_notify(Event_Complete,SC_SUCCESS);
              }
              break;

	      case ReadSWI:
	        if (resp[0]==0x63 && resp[1]==0x00) /* invalid pin */
	        {
                  dprintf(("", "machine(): bad pin\n"));
                  sctransport_end_trans(card_handle);
                  state = Idle;
	    	  module_notify(Event_Complete,SC_FAILACCESSCODE);
	        }
	        else
	        {
                  minijis_current =1;  /* current record being read */
                  minijis_records =0;  /* number of records on card */

                  state = ReadingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  /*if (chunk_size>entry.r[4])
                    chunk_size = entry.r[4];*/
                  ret = (*CurrExports->card_read)(card_handle,minijis_current,
	                chunk_size);
                dprintf(("", "machine(): 0:issued read for record: %d\n",
                         minijis_current));
	        }
	        break;

	      case WriteSWI:
	        if (resp[0]==0x63 && resp[1]==0x00) /* invalid pin */
	        {
                  dprintf(("", "machine(): bad pin\n"));
                  sctransport_end_trans(card_handle);
                  state = Idle;
	    	  module_notify(Event_Complete,SC_FAILACCESSCODE);
	        }
	        else
	        {
                  minijis_offset   =0;  /* offset into user buffer */
                  minijis_currentw =1;  /* current record being written */
                  memfill ( minijis_buff, 1024, FILL_CHAR);
                  buff_to_records ((char*)entry.r[3], entry.r[4],
                     minijis_buff, minijis_records*27, minijis_records);
                  /*
                  dprintf(("", "machine(): Before reorder:\n");
                  print_buff ( minijis_buff, 7);
                  reorder_buff ( minijis_buff, 27, 7);
                  dprintf(("", "machine(): After reorder:\n");
                  print_buff ( minijis_buff, 7); */

                  state = WritingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  ret = (*CurrExports->card_write)(card_handle, offset,
	                (BYTE*)(minijis_buff+offset), chunk_size);
	        }
	        break;

              case ChangeCHVSWI:
	        if (resp[0]==0x63 && resp[1]==0x00) /* invalid pin */
	        {
                  dprintf(("", "machine(): bad pin\n"));
                  sctransport_end_trans(card_handle);
                  state = Idle;
	    	  module_notify(Event_Complete,SC_FAILACCESSCODE);
	        }
	        else
	        {
                  state = ChangingCHV;
                  ret = (*CurrExports->card_change_chv)(card_handle,
                         entry.r[2], (char*)entry.r[3], entry.r[4],
                         (char*)entry.r[5], entry.r[6]);
	        }
                break;

	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case Creating:
	case Deleting:
	case ChangingCHV:
	case EnablingCHV:
	case UnBlockingCHV:
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
	    module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);
	  break;

	case ReadingFile:
	  dprintf(("", "machine(): ReadingFile\n"));
	  dprintf(("", "machine(): finished reading record: %d\n", minijis_current));
	  //err=handle_response((BYTE*)(entry.r[3]+offset),chunk_size,
	  //   &data_length,resp);
	  err=handle_response((BYTE*)(minijis_buff+offset),chunk_size,
	     &data_length,resp);
	  dprintf(("", "machine(): handle response - data length: %d\n", data_length));
	  dprintf(("", "machine(): handle response result: %d\n", err));
          print_rec ( minijis_buff+offset);
	  if (( err ==SC_SUCCESS) || ( err ==SC_NOTFOUND))
	  {
	    offset+=chunk_size;
            /* have we finished reading yet */
	    //if ((offset>=entry.r[4]) || ( minijis_current>=7))
	    if ( minijis_current>30 || ( resp[0] ==0x6a && resp[1] ==0x83))
	    {
	      dprintf(("", "machine(): 0:Total records read: %d\n", minijis_records));
              dprintf(("", "machine(): Before reorder:\n"));
              print_buff ( minijis_buff, minijis_records);
              reorder_buff ( minijis_buff, 27, minijis_records);
              dprintf(("", "machine(): After reorder:\n"));
              print_buff ( minijis_buff, minijis_records);
              records_to_buff (( char*)entry.r[3], minijis_buff,
                               minijis_records);
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	      dprintf(("", "machine(): 1:Total records read: %d\n", minijis_records));
	    }
	    else
	    {
              minijis_current+=1;
              minijis_records+=1;
	      chunk_size = CurrExports->chunk_size;
	      //if (entry.r[4]-offset<chunk_size) chunk_size = entry.r[4]-offset;
                ret = (*CurrExports->card_read)(card_handle,minijis_current,
	      	       chunk_size);
              dprintf(("", "machine(): 1:issued read for record: %d\n",
                       minijis_current));
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
  	  }
  	  else
          {
            records_to_buff (( char*)entry.r[3], minijis_buff, 7);
  	    machine(Error,r);
          }
	  break;

	case WritingFile:
          err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /* have we finished writing yet */
	    //if (minijis_currentw >=minijis_records)
	      dprintf(("", "machine(): total number of records: %d\n",
	               minijis_records));
	      dprintf(("", "machine(): finished writing: %d\n",
	               minijis_currentw));
	    if (minijis_currentw >=minijis_records)
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      minijis_currentw +=1;
              chunk_size = CurrExports->chunk_size;
	      dprintf(("", "machine(): chunk_size: %d\n", chunk_size));
              offset+=chunk_size;
	      dprintf(("", "machine(): write offset: %d\n", offset));
              ret = (*CurrExports->card_write)(card_handle, offset,
                     (BYTE*)(minijis_buff+offset),chunk_size);
              dprintf(("", "machine(): Writing record: %d\n\n", minijis_currentw));
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
	      }
	    }
	  }
	  else
	    machine(Error,r);
	  break;

	case WaitingInternalAuth :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * authentication complete, now need to fetch the stuff
	     */
 	    state = GettingAuthResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;
        default :
          dprintf(("", "machine(): Ilegal state (%s) in Done\n",strState[state]));
	  state = Idle;
          break;
      }
      break;
    /*
     * end of Done
     */
    case Error :
      /*
       * special chimpanzee error handling
       */
      if ((err==SC_WRONGCLASS) && (ATR.hist[0]==0x7))
      {
        dprintf(("", "machine(): Chimpanzee processing !!!!"));
        switch (entry_trans)
        {
          case ChangeCHVSWI :
            dprintf(("", "machine(): change chv re-direction"));
            state = ChangingCHV;
            ChimpanzeeClassByte = 0xf0;
            ret = (*CurrExports->card_change_chv)(card_handle,entry.r[2],
              (char*)entry.r[3], entry.r[4],(char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
          case UnBlockCHVSWI :
            dprintf(("", "machine(): unblock chv re-direction"));
            state = UnBlockingCHV;
            ChimpanzeeClassByte = 0xf0;
  	    ret = (*CurrExports->card_unblock_chv)(card_handle,entry.r[2],
  	      (char*)entry.r[3], entry.r[4], (char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
        }
        if (ret == SCI_FAIL)
        {
          err = SC_TRANSPORT;
          machine(Error,r);
        }
        break;
      }
      /*
       * otherwise
       */
      if (err == 0)
      {
        err = SC_TRANSPORT;
        ret = sctransport_error(card_handle);
      }

      status_error = err;
      sctransport_end_trans(card_handle);
      sctransport_close(card_handle);
      dprintf(("", "machine(): error 0x%x state (%s) entry (%s) ret %d\n",
      	    err,strState[state],strTransitions[entry_trans],ret));

      module_notify(Event_Complete,err);
      state = WaitingOpen;
      machine(Done,r);
      break;

    case Removed:
      module_notify(Event_CardRemoved,0);
      sctransport_close(card_handle);
      card_handle = -1;
      state = WaitingOpen;
      minijis_current  =0;   /* current record being read */
      minijis_currentw =0;   /* current record being written */
      minijis_records  =0;   /* number of records on card */
      minijis_offset   =0;   /* offset into card buffer */
      machine(Done,r);
      break;

    case ReStart:
      module_notify(Event_CardRemoved,0);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    /* shut scinterface down for now */
    case Shutdown:
      dprintf(("", "machine(): shutdown(1)\n"));
      module_notify(Event_CardRemoved,0);
      sctransport_close(card_handle);
      card_handle = -1;
      state = WaitingStandby;
      minijis_current  =0;   /* current record being read */
      minijis_currentw =0;   /* current record being written */
      minijis_records  =0;   /* number of records on card */
      minijis_offset   =0;   /* offset into card buffer */
      machine(Done,r);
      break;

    /* wake scinterface up after shutdown */
    case Standby:
      dprintf(("", "machine(): standby(1)\n"));
      if (state == WaitingStandby)
      {
        state = WaitingOpen;
        machine(Done,r);
      }
      break;

    case TransEnd :
      switch (state)
      {
        case WaitingTrans :
          state = Idle;
          doing_retry = 1;
          machine(entry_trans,&entry);
          break;
      }
      break;
    case GetATRSWI :
      dprintf(("", "machine(): state = %d",state));
      switch (state)
      {
        case WaitingOpen : case WaitingATR : case WaitingStandby :
      	  r->r[0] = SC_NOCARD;
      	  r->r[1] = 0;
      	  break;
      	default :
      	  dprintf(("", "machine(): returning atr, atr len = %d",ATR.len));
      	  if (ATR.len>0)
      	  {
      	    int i;
      	    for (i=0; i<ATR.len; i++)
            {
      	      dprintf(("", "(7)    ATR[%d] : 0x%x\n",i,ATR.hist[i]));
            }
      	  }
      	  r->r[0] = SC_SUCCESS;
      	  r->r[1] = (int)&ATR;
      }
      break;

    /* first entry point for these swis */
    case ReadSWI:
    case WriteSWI:
    case ChangeCHVSWI:
    case FileInfoSWI:
      switch (state)
      {
        case Idle:
	  dprintf(("", "machine(): 0:entered via %s\n",strTransitions[transition]));
          entry_trans = transition; /* remember transition for later */
          err = SC_SUCCESS;
          doing_retry = 0;

          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            dprintf(("", "machine(): Verifying CHV\n"));
            state = VerifyingCHV;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
              current_file = 0;
              switch ( transition)
              {
                case FileInfoSWI:
                  ret = (*CurrExports->card_verify_chv)(card_handle, 0,NULL,0);
                  break;

                case ChangeCHVSWI:
                  ret = (*CurrExports->card_verify_chv)(card_handle,
                          access_condition,(char*)entry.r[3],entry.r[4]);
                  break;

                default:
                  ret = (*CurrExports->card_verify_chv)(card_handle,
                          access_condition,(char*)entry.r[5],entry.r[6]);
                  //ret = (*CurrExports->card_verify_chv)(card_handle,
                  //        access_condition,(char*)"00000000",8);
                  break;
              }
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                 /* card locked against transactions, back off */
                  state = WaitingTrans;
              }
            }
          }
          break;

        case WaitingOpen : case WaitingATR : case WaitingStandby :
      	  err = SC_NOCARD;
      	  break;

        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;

        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;

    /* first entry point for these swis */
    case CreateSWI:
    case DeleteSWI:
    case EnableCHVSWI:
    case UnBlockCHVSWI:
      switch (state)
      {
        case Idle:
	  dprintf(("", "machine(): 1:entered via %s\n",strTransitions[transition]));
          entry_trans = transition; /* remember transition for later */
          if (!doing_retry)
          {
            err = path_process((char*)r->r[1],files,&num_files);
	    dprintf(("", "machine(): path process result: %d\n", err));
          }
          else
            err = SC_SUCCESS;

          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            if ( transition ==ChangeCHVSWI && current_card_type ==3)
            {
              dprintf(("", "machine(): Verifying CHV\n"));
              state = VerifyingCHV;
            }
            else
              state = SelectingDir;

            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
              current_file = 0;
              if ( transition ==ChangeCHVSWI && current_card_type ==3)
                ret = (*CurrExports->card_verify_chv)(card_handle,
                       access_condition,(char*)entry.r[3],entry.r[4]);
              else
                ret = (*CurrExports->card_select_root)(card_handle);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                 /* card locked against transactions, back off */
                  state = WaitingTrans;
              }
            }
          }
          break;

        case WaitingOpen : case WaitingATR : case WaitingStandby :
      	  err = SC_NOCARD;
      	  break;

        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;

        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;

    case InternalAuthSWI :
      switch (state)
      {
        case Idle :
          entry_trans = transition; /* remember transition for later */
          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = WaitingInternalAuth;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
      	      ret = (*CurrExports->card_internal_auth)(card_handle,
      	      entry.r[2], (BYTE*)entry.r[3], entry.r[4]);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR : case WaitingStandby :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;
    case StatusSWI :
      if (status_error!=0)
        r->r[0] = StatusError;
      else
      {
        switch (state)
        {
          case WaitingOpen : case WaitingATR : case WaitingStandby :
            r->r[0] = StatusNoCard;
            break;
          case Idle :
            r->r[0] = StatusIdle;
            break;
          default :
            r->r[0] = StatusBusy;
        }
      }
      r->r[1] = status_error;
      status_error=0;
      break;
  }
}
#endif
