/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

/*
 * This module provides an abstraction to the smart card transport module by
 * implementing some primitive filing system operations.
 *
 * Modification History
 *---------------------
 *
 * 14-Jun-96  RWB,  Created.
 * 28-Jun-96  RWB,  Fixed a few bugs in the card read/write routines.
 * 07-Aug-96  RWB,  Backoff if SCTransport module not ready yet.
 * 28-Aug-96  RWB,  Removed redundant parameter in unblockchv functions.
 * 28-Aug-96  RWB,  Check for never access condition before a verifychv.
 * 29-Aug-96  RWB,  Added Status swi for polled operation.
 * 08-Oct-96  RWB,  Modified the ordering of InternalAuthenticate
 * 22 May 1997 RWB, get_atr does not check atr length
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "kernel.h"
#include "swis.h"
#include "sctrans.h"
#include "module.h"
#include "irqs.h"
#include "header.h"
#include "scinter.h"
#include "cards.h"
#include "path.h"


/*
 * prototypes
 */
int  get_atr(void);
int  open_card(void);
int  handle_response(BYTE *card_data, int data_len, int *length, BYTE *resp);

void machine(t_transitions transition, _kernel_swi_regs *r);

/*
 * table used to identify which card is present
 */
t_card_exports *CardExports[SUPPORTED_CARDS];
t_card_exports *CurrExports = NULL;

/*
 * special chimpanzee processing
 */
int ChimpanzeeClassByte=0xa0;

#ifdef REMOTE_DEBUG
debug_session *db=NULL;
#endif

/*
 * module housekeeping globals
 */
void   *workspace_pointer = NULL;
#ifdef USE_TINY
static _kernel_oserror *TinyError;
#endif
int card_handle = -1;
static t_card_atr ATR;

#ifdef REMOTE_DEBUG
char *strNotifications[] = {"CardOK","CardBad","CardRemoved","Complete"};
char *strState[] = {"WaitingOpen","WaitingATR","WaitingRemoval","Idle",
"SelectingDir","SelectingFile","GettingResponse","GettingAuthResponse",
"Creating","Deleting","ReadingFile","WritingFile","VerifyingCHV","ChangingCHV",
"EnablingCHV","UnBlockingCHV","WaitingInternalAuth","WaitingTrans"};
char *strTransitions[] = {"Done","Error","Removed","ReStart","TransEnd",
"CreateSWI","DeleteSWI","ReadSWI","WriteSWI","GetATRSWI","ChangeCHVSWI",
"EnableCHVSWI","UnBlockCHVSWI","FileInfoSWI","InternalAuthSWI","StatusSWI"};
#else
char *strNotifications[] = {""};
char *strState[] = {""};
char *strTransitions[] = {""};
#endif
/*
 * event handling globals
 */
t_event Events[MAX_EVENTS];             /* generic event queue */
int next_event = -1;
int free_event = 0;
int flag_event_pending = FALSE;
  static t_states state = WaitingOpen;
  static t_transitions entry_trans;
/*
 * process the asynchronous events
 */
_kernel_oserror *
sc_event_handler(_kernel_swi_regs *r, void *pw)
{
  int  this_event = 0;
  int  this_handle = 0;
  int  old_irqs;

  while (next_event != free_event)
  {
    if (next_event == -1) break;

    /* need to protect against queue changing behind our backs */
    old_irqs = irqs_off();
    this_handle = Events[next_event].handle;
    this_event = Events[next_event].event;
    irqs_on(old_irqs);

    if (this_handle == card_handle)
    {
      switch(this_event)
      {
        case SCI_REMOVED :
          debug_printf(db,"event Removed\n");
          machine(Removed,r);
          break;
        case SCI_TRANS_END :
          debug_printf(db,"trans end\n");
          machine(TransEnd,r);
          break;
        case SCI_CMD_DONE :
          machine(Done,r);
          break;
        case SCI_ERROR :
          debug_printf(db,"event Error\n");
          machine(Error,r);
          break;
      }
    }

    /* need to protect against queue changing behind our backs */
    old_irqs = irqs_off();
    if (next_event>=0) next_event++;
    if (next_event==MAX_EVENTS) next_event=0;
    irqs_on(old_irqs);
  }

  old_irqs = irqs_off();
  flag_event_pending = FALSE;
  next_event = -1;
  irqs_on(old_irqs);

  return (NULL);
}

/*
 * setup a callback to deal with the serial event.
 */
_kernel_oserror *
setup_event(int iHandle, int ithis_event)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;
  int old_irqs;

  if (free_event != next_event)
  {
    old_irqs = irqs_off();
    if (next_event == -1) next_event = free_event;
    Events[free_event].handle = iHandle;
    Events[free_event].event = ithis_event;
    free_event++;
    if (free_event==MAX_EVENTS) free_event=0;
    irqs_on(old_irqs);
    /*
     * see if event handler needs to be established
     */
    if (!flag_event_pending)
    {
      reg.r[0] = (int)sc_event_entry;
      reg.r[1] = (int)workspace_pointer;
      ERR_RETURN(err,_kernel_swi(OS_AddCallBack, &reg, &reg));
      flag_event_pending = TRUE;
    }
  }

  return (NULL);
}


/*
 * handle events, select ones of interest to us
 */
int
event_handler(_kernel_swi_regs *r, void *pw)
{
  if (r->r[0] == Event_Expansion)
  {
    if (r->r[1] == Event_Expansion_SCTransport)
    {
      setup_event(r->r[2],r->r[3]);
    }
  }

  return (1); /* pass on */
}

/*
 * claims vectors and enables the events as required
 */
_kernel_oserror *
claim_vectors(void)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;

  /*
   * claim vectors
   */
  reg.r[0] = EventV;
  reg.r[1] = (int)event_entry;
  reg.r[2] = (int)workspace_pointer;
  ERR_RETURN(err,_kernel_swi(OS_Claim, &reg, &reg));

  /*
   * enable Expansion event
   */
  reg.r[0] = 14;
  reg.r[1] = Event_Expansion;
  ERR_RETURN(err,_kernel_swi(OS_Byte, &reg, &reg));

  return (NULL);
}

/*
 * release vectors, flush any callbacks and disable events
 */
_kernel_oserror *
release_vectors(void)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;

  /*
   * disable event
   */
  reg.r[0] = 13;
  reg.r[1] = Event_Expansion;
  ERR_RETURN(err,_kernel_swi(OS_Byte, &reg, &reg));

  /*
   * release vectors
   */
  reg.r[0] = EventV;
  reg.r[1] = (int)event_entry;
  reg.r[2] = (int)workspace_pointer;
  ERR_RETURN(err,_kernel_swi(OS_Release, &reg, &reg));

  return (NULL);
}

/*
 * module service, only dealing with service_NCTransportStarting
 */
void
module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
  debug_printf(db,"module service %x\n",r->r[0]);
  machine(ReStart,r);
}

/*
 * broadcast a message using the SCInterface event
 */
void
module_notify(int reason,int param)
{
  _kernel_swi_regs reg;

  debug_printf(db,"notify '%s', 0x%x\n",
  	strNotifications[reason],param);

  reg.r[0] = Event_Expansion;
  reg.r[1] = Event_Expansion_SCInterface;
  reg.r[2] = reason;
  reg.r[3] = param;
  _kernel_swi(OS_GenerateEvent,&reg,&reg);
}

/*
 * simple printf without using stdio
 */
void
my_printf(char *format, ...)
{
  _kernel_swi_regs reg;
  char strLine[80];
  va_list list;

  va_start(list, format);
  vsprintf(strLine,format,list);
  va_end(list);

  reg.r[0] = (int)strLine;
  _kernel_swi(OS_Write0,&reg,&reg);
  _kernel_swi(OS_NewLine,&reg,&reg);
}
/*
 * cli_handler
 */
_kernel_oserror *
module_cli(char *arg_string,int arg_count,int cmd_no,void *pw)
{
  switch (cmd_no)
  {
    case CMD_SCInterInfo :
      my_printf("   State       : %d",state);
      my_printf("   Entry trans : %d",entry_trans);

      break;
  }
  return (NULL);
}

/*
 * module finalise
 */
_kernel_oserror *
module_finalise(int fatal, int podule, void *pw)
{
  _kernel_oserror *err = NULL;

  if (card_handle>=0) sctransport_close(card_handle);

  ERR_RETURN(err,release_vectors());

  debug_printf(db,"(5) finalisation");
  remote_debug_close(db);

#ifdef USE_TINY
  if ( TinyError == NULL ) _swix( TinySupport_Die, 0 );
#endif

  return NULL;

  NOT_USED( fatal );
  NOT_USED( podule );
}

/*
 * module initialise
 */
_kernel_oserror *
module_initialise(char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;
  int i;

  workspace_pointer = pw;

#ifdef USE_TINY
  /*
   * try to use TinyStubs if possible.
   */
  reg.r[0] = (int)workspace_pointer;
  TinyError = _kernel_swi(TinySupport_Share, &reg, &reg);
#endif

  /*
   * initialise the event queue
   */
  for (i=0; i<MAX_EVENTS; i++)
  {
    Events[i].handle = 0;
    Events[i].event = 0;
  }

  /*
   * initialise the system
   */
  remote_debug_open(Module_Title,&db);

  ERR_RETURN(err,claim_vectors());

  /*
   * populate array of card exports here and initialise them
   */
  CARDS_POPULATE(CardExports);

  for (i=0; i<SUPPORTED_CARDS; i++)
    (*(CardExports[i])->card_initialise_table)();

  machine(ReStart,&reg);

  return (NULL);
}

/*
 * module swi handler
 */
_kernel_oserror *
module_swi( int swi_no, _kernel_swi_regs *r, void *pw )
{
  switch (swi_no+SCInterface_00)
  {
    case SCInterface_Create :
      if (CurrExports->card_create == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(CreateSWI,r);
      break;
    case SCInterface_Delete :
      if (CurrExports->card_delete == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(DeleteSWI,r);
      break;
    case SCInterface_Read :
      if (CurrExports->card_read == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(ReadSWI,r);
      break;
    case SCInterface_Write :
      if (CurrExports->card_write == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(WriteSWI,r);
      break;
    case SCInterface_GetATR :
      machine(GetATRSWI,r);
      break;
    case SCInterface_ChangeCHV :
      if (CurrExports->card_change_chv == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(ChangeCHVSWI,r);
      break;
    case SCInterface_EnableCHV :
      if (CurrExports->card_enable_chv == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(EnableCHVSWI,r);
      break;
    case SCInterface_UnBlockCHV :
      if (CurrExports->card_unblock_chv == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(UnBlockCHVSWI,r);
      break;
    case SCInterface_FileInfo :
      if (CurrExports->card_get_response == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(FileInfoSWI,r);
      break;
    case SCInterface_InternalAuth :
      if (CurrExports->card_internal_auth == NULL)
        r->r[0] = SC_NOTIMPLEMENTED;
      else
        machine(InternalAuthSWI,r);
      break;
    case SCInterface_Status :
      machine(StatusSWI,r);
      break;
  }
  return (NULL);

  NOT_USED( pw );
}

/*
 * copy the values in r_old into r_new only r0-r10
 */
static void
_copy_regs(_kernel_swi_regs *r_new, _kernel_swi_regs *r_old)
{
  int i=9;
  do { r_new->r[i] = r_old->r[i]; } while (i--);
}

/*
 * implement the state machine
 */
void
machine(t_transitions transition, _kernel_swi_regs *r)
{
  static _kernel_swi_regs entry;
  static int files[MAX_SUBDIRS];
  static int num_files;
  static int current_file;
  static int err;
  static int offset;
  static int chunk_size;
  static int status_error = 0;
  static int doing_retry = 0;
  BYTE file_header[22];
  BYTE resp[2];
  int data_length;
  int ret = SCI_SUCCESS;
  int access_condition;

  if (transition!=StatusSWI)
    debug_printf(db,"machine (%s)\n",strTransitions[transition]);
  switch (transition)
  {
    case Done :
      switch (state)
      {
        case WaitingOpen :
          err = open_card();
          switch (err)
          {
            case SC_SUCCESS :
              state = WaitingATR;
              break;
	    case SC_UNDERSTAND :
              state = WaitingRemoval;
              break;
          }
          break;
        case WaitingATR :
          if (get_atr() == SC_SUCCESS)
          {
            state = Idle;
            module_notify(Event_CardOK,0);
          }
          else
          {
            state = WaitingRemoval;
            module_notify(Event_CardBad,0);
          }
          break;
	case Idle :
	  /* ingore */
	  break;
	case SelectingDir :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    if (current_file == num_files-1)   /* are we on the leaf name */
	    {
	      switch (entry_trans)
	      {
	        case CreateSWI :
	          state = Creating;
		  ret = (*CurrExports->card_create)(card_handle,
		      	files[current_file++],(entry.r[0]&1<<1)?1:0,entry.r[2],
		      	entry.r[3]);
	          break;
	        case ReadSWI : case WriteSWI :
	        case DeleteSWI : case FileInfoSWI :
    	          state = SelectingFile;
                  ret = (*CurrExports->card_select)(card_handle,
                      	files[current_file++]);
                  break;
                case ChangeCHVSWI :
                case EnableCHVSWI : case UnBlockCHVSWI :
	      	  ret = (*CurrExports->card_select)(card_handle,
	      	      	files[current_file++]);
                  break;
              }
	    }
	    else if (current_file == num_files) /* leaf name was a directory */
	    {
	      switch (entry_trans)
	      {
	        case ChangeCHVSWI :
	          state = ChangingCHV;
  		  ret = (*CurrExports->card_change_chv)(card_handle,
  		      	entry.r[2], (char*)entry.r[3], entry.r[4],
  		      	(char*)entry.r[5], entry.r[6]);
	          break;
                case EnableCHVSWI :
                  state = EnablingCHV;
		  ret = (*CurrExports->card_enable_chv)(card_handle,
		      	entry.r[2],(entry.r[0]&1<<1)?1:0,(char*)entry.r[3],
		      	entry.r[4]);
	          break;
                case UnBlockCHVSWI :
                  state = UnBlockingCHV;
   		  ret = (*CurrExports->card_unblock_chv)(card_handle,
   		      	entry.r[2], (char*)entry.r[3],
   		      	entry.r[4], (char*)entry.r[5], entry.r[6]);
                  break;
                case FileInfoSWI :
	    	  state = GettingResponse;
	    	  ret = (*CurrExports->card_get_response)(card_handle,
	    	      	(int)resp[1]);
                  if (ret == SCI_FAIL)
            	  {
		    err = SC_TRANSPORT;
              	    machine(Error,r);
                  }
                  break;
              }
            }
	    else /* change into next directory in path */
	    {
	      ret = (*CurrExports->card_select)(card_handle,
	      	    files[current_file++]);
	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case SelectingFile :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully selected the file, get header response
	     */
	    debug_printf(db,"file selected\n");
	    state = GettingResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingResponse :
	  err=handle_response(file_header,sizeof(file_header),
	                      &data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * we have successfully get the response message, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
	        access_condition = file_header[9]>>4 & 0xf;
                if (access_condition==0) /* no write access cond */
                {
                  state = Deleting;
                  ret = (*CurrExports->card_delete)(card_handle,
                        files[num_files-1]);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;
	      case ReadSWI :
	        access_condition = file_header[8]>>4 & 0xf;
                if (access_condition==0) /* no read access cond */
                {
                  state = ReadingFile;
                  offset = 0;
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_read)(card_handle,entry.r[2],
              	      	chunk_size);
                }
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
                else  /* access condition to deal with */
                {
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
                }
                break;
	      case WriteSWI:
	        access_condition = file_header[8] & 0xf;
                if (access_condition==0) /* no write access cond */
                {
       	          state = WritingFile;
                  offset = entry.r[2];
                  chunk_size = CurrExports->chunk_size;
                  if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

                  ret = (*CurrExports->card_write)(card_handle, offset,
        	        (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
        	}
                else if (access_condition==15) /* never condition */
                {
                  err = SC_NEVERACCESS;
                  machine(Error,r);
                }
        	else /* access condition to deal with */
        	{
                  state = VerifyingCHV;
                  ret = (*CurrExports->card_verify_chv)(card_handle,
              	      	access_condition,(char*)entry.r[5],entry.r[6]);
        	}
	        break;
	      case FileInfoSWI :
	        debug_printf(db,"copying response %d",entry.r[3]);
	        if (entry.r[3]>sizeof(file_header))
  	          memcpy((char*)entry.r[2],file_header,sizeof(file_header));
  	        else
  	          memcpy((char*)entry.r[2],file_header,entry.r[3]);

                sctransport_end_trans(card_handle);
	    	state = Idle;
	    	module_notify(Event_Complete,SC_SUCCESS);
	        break;
	    }

            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case GettingAuthResponse :
          err=handle_response((BYTE*)entry.r[5],entry.r[6],&data_length,resp);
	  if (err==SC_SUCCESS)
   	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
            module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);
	  break;

	case VerifyingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS || (resp[0]==0x98 && resp[1]==0x08))
	  {
	    debug_printf(db,"verified CHV\n");
	    /*
	     * we have successfully verified the CHV, do something
	     */
	    switch (entry_trans)
	    {
              case DeleteSWI :
                state = Deleting;
                ret = (*CurrExports->card_delete)(card_handle,
                      files[num_files-1]);
	      case ReadSWI :
	        state = ReadingFile;
	        offset = 0;
	        chunk_size = CurrExports->chunk_size;
	        if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

	        ret = (*CurrExports->card_read)(card_handle,entry.r[2],
	              chunk_size);
	        break;
	      case WriteSWI :
	        state = WritingFile;
	        offset = entry.r[2];
	        chunk_size = CurrExports->chunk_size;
	        if (chunk_size>entry.r[4]) chunk_size = entry.r[4];

	        ret = (*CurrExports->card_write)(card_handle, offset,
	               (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
	        break;
	    }
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;

	case Creating : case Deleting :
	case ChangingCHV : case EnablingCHV : case UnBlockingCHV :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
            sctransport_end_trans(card_handle);
	    state = Idle;
	    module_notify(Event_Complete,SC_SUCCESS);
	  }
	  else
	    machine(Error,r);

	  break;

	case ReadingFile :
	  err=handle_response((BYTE*)(entry.r[3]+offset),chunk_size,
	     &data_length,resp);
	  if (err == SC_SUCCESS)
	  {
	    offset+=chunk_size;
	    if (offset>=entry.r[4])  /* have we finished reading yet */
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      chunk_size = CurrExports->chunk_size;
	      if (entry.r[4]-offset<chunk_size) chunk_size = entry.r[4]-offset;

	      ret = (*CurrExports->card_read)(card_handle,entry.r[2]+offset,
	      	    chunk_size);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
  	  }
  	  else
  	    machine(Error,r);
	  break;
	case WritingFile :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    offset+=chunk_size;
	    if (offset>=entry.r[4])  /* have we finished writing yet */
	    {
              sctransport_end_trans(card_handle);
	      state = Idle;
	      module_notify(Event_Complete,SC_SUCCESS);
	    }
	    else
	    {
	      chunk_size = CurrExports->chunk_size;
	      if (offset+chunk_size>entry.r[4]) chunk_size = entry.r[4]-offset;
	      ret = (*CurrExports->card_write)(card_handle, offset,
	            (BYTE*)(entry.r[3]+offset-entry.r[2]), chunk_size);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
	    }
	  }
	  else
	    machine(Error,r);
	  break;
	case WaitingInternalAuth :
	  err=handle_response(NULL,0,&data_length,resp);
	  if (err==SC_SUCCESS)
	  {
	    /*
	     * authentication complete, now need to fetch the stuff
	     */
 	    state = GettingAuthResponse;
	    ret = (*CurrExports->card_get_response)(card_handle,(int)resp[1]);
            if (ret == SCI_FAIL)
            {
              err = SC_TRANSPORT;
              machine(Error,r);
            }
	  }
	  else
	    machine(Error,r);
	  break;
        default :
          debug_printf(db,"Ilegal state (%s) in Done\n",strState[state]);
	  state = Idle;
          break;
      }
      break;
    /*
     * end of Done
     */
    case Error :
      /*
       * special chimpanzee error handling
       */
      if ((err==SC_WRONGCLASS) && (ATR.hist[0]==0x7))
      {
        debug_printf(db,"Chimpanzee processing !!!!");
        switch (entry_trans)
        {
          case ChangeCHVSWI :
            debug_printf(db,"   change chv re-direction");
            state = ChangingCHV;
            ChimpanzeeClassByte = 0xf0;
            ret = (*CurrExports->card_change_chv)(card_handle,entry.r[2],
              (char*)entry.r[3], entry.r[4],(char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
          case UnBlockCHVSWI :
            debug_printf(db,"   unblock chv re-direction");
            state = UnBlockingCHV;
            ChimpanzeeClassByte = 0xf0;
  	    ret = (*CurrExports->card_unblock_chv)(card_handle,entry.r[2],
  	      (char*)entry.r[3], entry.r[4], (char*)entry.r[5], entry.r[6]);
            ChimpanzeeClassByte = 0xa0;
            break;
        }
        if (ret == SCI_FAIL)
        {
          err = SC_TRANSPORT;
          machine(Error,r);
        }
        break;
      }
      /*
       * otherwise
       */
      if (err == 0)
      {
        err = SC_TRANSPORT;
        ret = sctransport_error(card_handle);
      }

      status_error = err;
      sctransport_close(card_handle);
      debug_printf(db,"error 0x%x state (%s) entry (%s) ret %d\n",
      	    err,strState[state],strTransitions[entry_trans],ret);

      module_notify(Event_Complete,err);
      state = WaitingOpen;
      machine(Done,r);
      break;

    case Removed :
      module_notify(Event_CardRemoved,0);
      sctransport_close(card_handle);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    case ReStart :
      module_notify(Event_CardRemoved,0);
      card_handle = -1;
      state = WaitingOpen;
      machine(Done,r);
      break;

    case TransEnd :
      switch (state)
      {
        case WaitingTrans :
          state = Idle;
          doing_retry = 1;
          machine(entry_trans,&entry);
          break;
      }
      break;
    case GetATRSWI :
      switch (state)
      {
        case WaitingOpen : case WaitingATR :
      	  r->r[0] = SC_NOCARD;
      	  r->r[1] = 0;
      	  break;
      	default :
      	  r->r[0] = SC_SUCCESS;
      	  r->r[1] = (int)&ATR;
      }
      break;
    case CreateSWI : case DeleteSWI : case ReadSWI :  case WriteSWI :
    case EnableCHVSWI : case UnBlockCHVSWI : case FileInfoSWI :
    case ChangeCHVSWI :
      switch (state)
      {
        case Idle :
	  debug_printf(db,"entered via %s",strTransitions[transition]);
          entry_trans = transition; /* remember transition for later */
          if (!doing_retry)
            err = path_process((char*)r->r[1],files,&num_files);
          else
            err = SC_SUCCESS;

          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = SelectingDir;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
              current_file = 0;
              ret = (*CurrExports->card_select_root)(card_handle);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;

    case InternalAuthSWI :
      switch (state)
      {
        case Idle :
          entry_trans = transition; /* remember transition for later */
          doing_retry = 0;
          if (err == SC_SUCCESS)
          {
            _copy_regs(&entry,r);
            state = WaitingInternalAuth;
            ret = sctransport_start_trans(card_handle);
            if (ret == SCI_SUCCESS)
            {
      	      ret = (*CurrExports->card_internal_auth)(card_handle,
      	      entry.r[2], (BYTE*)entry.r[3], entry.r[4]);
              if (ret == SCI_FAIL)
              {
                err = SC_TRANSPORT;
                machine(Error,r);
              }
            }
            else
            {
              ret = sctransport_error(card_handle);
              if (ret == SCI_E_TRANS)
              {
                /* card locked against transactions, back off */
                state = WaitingTrans;
              }
            }
          }
          break;
        case WaitingOpen : case WaitingATR :
      	  err = SC_NOCARD;
      	  break;
        case WaitingRemoval :
      	  err = SC_UNDERSTAND;
      	  break;
        default :
          err = SC_BUSY;
          break;
      }
      r->r[0] = err;
      break;
    case StatusSWI :
      if (status_error!=0)
        r->r[0] = StatusError;
      else
      {
        switch (state)
        {
          case WaitingOpen : case WaitingATR :
            r->r[0] = StatusNoCard;
            break;
          case Idle :
            r->r[0] = StatusIdle;
            break;
          default :
            r->r[0] = StatusBusy;
        }
      }
      r->r[1] = status_error;
      status_error=0;
      break;
  }
}

/*
 * retrieve the cards ATR and try to obtain a match against the table of known
 * ATRs
 *
 * sets CurrExports if ATR matched.
 *
 * will return SC_SUCCESS if ATR matches, SCFS otherwise
 */
int
get_atr(void)
{
  int iCard,i;
  int iMisMatch;
  int ret;

  ret=sctransport_retrieve_atr(card_handle,ATR.hist,sizeof(ATR.hist),&ATR.len);
  if (ret == SCI_SUCCESS)
  {
    for (iCard=0; iCard<SUPPORTED_CARDS; iCard++)
    {
      iMisMatch = 0;
      i=0;
      while (i<CardExports[iCard]->card_atr->significant && !iMisMatch)
      {
        if (ATR.hist[i]!=CardExports[iCard]->card_atr->hist[i])
          iMisMatch++;
        i++;
      }

      if (iMisMatch == 0)
      {
        CurrExports = CardExports[iCard];
        return (SC_SUCCESS);
      }
    }
  }
  return (SC_UNDERSTAND);
}


/*
 * attempt to open a smart card connection
 *
 * will return SC_SUCCESS for success, SC_TRANSPORT for SCTransport errors,
 * SC_UNDERSTAND for unrecognised card.
 */
int
open_card(void)
{
  int ret;
  int err;

  CurrExports = NULL;

  ret = sctransport_open(1,&card_handle);
  if (ret==SCI_FAIL)
  {
    err = sctransport_error(card_handle);
    if (err==SCI_FAIL)
      return (SC_TRANSPORT);
  }

  debug_printf(db,"opened card channel %d\n",card_handle);

  if (ret==SCI_FAIL && err!=SCI_E_OUT)
  {
    debug_printf(db,"don't understand card\n");
    card_handle = -1;
    return (SC_UNDERSTAND);
  }

  return (SC_SUCCESS);
}

/*
 * does a read response into the given data area and checks the response
 * codes against the ones given. Returns success if response codes match.
 * response code should be -1 to ignore.
 */
int
handle_response(BYTE *card_data, int data_len, int *length, BYTE resp[2])
{
  int ret;
  int i,j;
  int swA;
  int swB;
  int req_match;

  ret=sctransport_read_response(card_handle,card_data,data_len,length,resp);
  if (ret != SCI_SUCCESS)
    return (SC_TRANSPORT);

  debug_printf(db,"received response %02x %02x\n",resp[0],resp[1]);

  swA = resp[0]<<8 | resp[1];

  for (i=0; i<CurrExports->card_num_responses; i++)
  {
    int match = 0;
    j=16;
    req_match = CurrExports->card_responses[i].sw>>16 & 0xff;
    swB = CurrExports->card_responses[i].sw & 0xffff;

    do
    {
      j-=4;
      if ((swB>>j & 0xf) == (swA>>j & 0xf))
        match++;
      else
        break;
    } while (j);
    if (match >= req_match)
      return (CurrExports->card_responses[i].err);
  }
  debug_printf(db,"response 0x%x unknown\n",swA);

  return (SC_UNKNOWNRESP);
}
