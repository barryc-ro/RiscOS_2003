/*-------------------------------------------------------------------------

	File: atr.c

	Purpose:
		To provide the functions for handling card reset and processing
		of the answer-to-reset sequence sent from the card.

---------------------------------------------------------------------------

	Written by A.S.E Consulting for Card Dynamics
	Copyright (c) 1996 A.S.E Consulting  All Rights Reserved.

-------------------------------------------------------------------------*/

#ifdef ARM
#include "arm.h"
#else /* ARM */
#include <windows.h>
#endif /* ARM */

#include <stdio.h>

#include "sci_api.h"
#include "sci_int.h"
#include "atr.h"

static PROT_PARAMS ProtTab[MAX_PROTS];
static BYTE CurrY;
static int AtrState;
static int HistNext;
static int ProtIndex;
static int ProtCount;
static BOOL T0Only;
static int AtrCheck;

static int atr_ProcessByte (BYTE ch);
static int atr_CalcWorkWaitTime (void);
static BOOL atr_SendPtss (void);

/***************************************************************************/
int
atr_HandleInput (BYTE * data, int len)
/***************************************************************************/

{
  int err;

  while (len--)
  {
    if ((err = atr_ProcessByte (*data++)) != SCI_SUCCESS)
    {
      if (AtrState==ATR_PTS_ENDED)
      {
        com_FlushComms();
        break;
      }
      if (err == SCI_E_OUT)
      {
	/* pass TRUE if card in, FALSE if card out */
	t0_CardStatusChange (FALSE);

	return SCI_SUCCESS;
      }
      else
      {
	//DebugPrint ("Exiting atr_HandleInput() via atr_Error()\n");
	return atr_Error (err);
      }
    }
  }

  if ((AtrState != ATR_PTS_ENDED) && (AtrState != ATR_WAIT_PTS_ACK))
  {
    /* going to read more bytes so set wait time */
    //debug DebugPrint("Starting timer ATRHandleInput, state %d\n",AtrState);
    sys_StartWaitTimer (ATR_INIT_WAIT);
  }

  return SCI_SUCCESS;
}

/***************************************************************************/
static int
atr_ProcessByte (BYTE ch)
/***************************************************************************/
{
  int channel;

  //debug DebugPrint ("SCTransport: atr_ProcessByte char %02X\n",ch);

  switch (AtrState)
  {
    case ATR_WAIT_TS:
      /* waiting initial byte, this does not concern API */
      AtrState = ATR_WAIT_T0;

      break;

    case ATR_WAIT_T0:
      /* waiting format character */
      //DebugPrint ("atr_ProcessByte(): T0\n");
      CurrY = ch & ATR_Y_MASK;
      if ((sci_HistLen = (ch & ATR_K_MASK)) > SCI_HIST_LEN)
      {
        return SCI_E_PROTO;
      }

      HistNext = 0;
      ProtIndex = 0;
      AtrCheck = ch;
      T0Only = TRUE;

      if (CurrY)
        ProtCount = 1;
      else
        ProtCount = 0;

      if (CurrY & ATR_TA_MASK)
        AtrState = ATR_WAIT_TA;
      else if (CurrY & ATR_TB_MASK)
        AtrState = ATR_WAIT_TB;
      else if (CurrY & ATR_TC_MASK)
        AtrState = ATR_WAIT_TC;
      else if (CurrY & ATR_TD_MASK)
        AtrState = ATR_WAIT_TD;
      else
      {
        if (sci_HistLen == 0)
        {
  	if (T0Only)
  	  AtrState = ATR_ENDED;
  	else
  	  AtrState = ATR_WAIT_TCK;
        }
        else
  	AtrState = ATR_WAIT_HIST;
      }

      break;

    case ATR_WAIT_TA:

      //DebugPrint ("atr_ProcessByte(): TA\n");
      AtrCheck ^= ch;
      ProtTab[ProtIndex].clk_rate = ch & ATR_F_MASK;
      ProtTab[ProtIndex].bit_rate = ch & ATR_D_MASK;

      if (CurrY & ATR_TB_MASK)
        AtrState = ATR_WAIT_TB;
      else if (CurrY & ATR_TC_MASK)
        AtrState = ATR_WAIT_TC;
      else if (CurrY & ATR_TD_MASK)
        AtrState = ATR_WAIT_TD;
      else
      {
        if (sci_HistLen == 0)
        {
  	if (T0Only)
  	  AtrState = ATR_ENDED;
  	else
  	  AtrState = ATR_WAIT_TCK;
        }
        else
  	AtrState = ATR_WAIT_HIST;
      }

      break;

    case ATR_WAIT_TB:

      //DebugPrint ("atr_ProcessByte(): TB\n");
      AtrCheck ^= ch;
      ProtTab[ProtIndex].pc1 = (ch & ATR_I1_MASK) >> ATR_I1_SHIFT;
      ProtTab[ProtIndex].pc2 = ch & ATR_I2_MASK;

      if (CurrY & ATR_TC_MASK)
        AtrState = ATR_WAIT_TC;
      else if (CurrY & ATR_TD_MASK)
        AtrState = ATR_WAIT_TD;
      else
      {
        if (sci_HistLen == 0)
        {
  	if (T0Only)
  	  AtrState = ATR_ENDED;
  	else
  	  AtrState = ATR_WAIT_TCK;
        }
        else
  	AtrState = ATR_WAIT_HIST;
      }

      break;

    case ATR_WAIT_TC:

      //DebugPrint ("atr_ProcessByte(): TC\n");
      AtrCheck ^= ch;
      ProtTab[ProtIndex].extra_time = ch;

      if (CurrY & ATR_TD_MASK)
        AtrState = ATR_WAIT_TD;
      else
      {
        if (sci_HistLen == 0)
        {
  	if (T0Only)
  	  AtrState = ATR_ENDED;
  	else
  	  AtrState = ATR_WAIT_TCK;
        }
        else
  	AtrState = ATR_WAIT_HIST;
      }

      break;

    case ATR_WAIT_TD:

      //DebugPrint ("atr_ProcessByte(): TD\n");
      AtrCheck ^= ch;
      CurrY = ch & ATR_Y_MASK;
      ProtTab[ProtIndex].type = ch & ATR_T_MASK;
      if ((ch & ATR_T_MASK) != T0_TYPE)
        T0Only = FALSE;

      if (CurrY != 0)
      {
        ProtIndex++;
        ProtCount++;
        if (CurrY & ATR_TA_MASK)
  	AtrState = ATR_WAIT_TA;
        else if (CurrY & ATR_TB_MASK)
  	AtrState = ATR_WAIT_TB;
        else if (CurrY & ATR_TC_MASK)
  	AtrState = ATR_WAIT_TC;
        else
  	AtrState = ATR_WAIT_TD;
      }
      else
      {
        if (sci_HistLen == 0)
  	AtrState = ATR_ENDED;
        else
  	AtrState = ATR_WAIT_HIST;
      }

      break;

    case ATR_WAIT_HIST:

      //DebugPrint ("atr_ProcessByte(): HIST\n");
      AtrCheck ^= ch;

      sci_HistData[HistNext++] = ch;
      if (HistNext == sci_HistLen)
      {
        if (T0Only)
  	AtrState = ATR_ENDED;
        else
  	AtrState = ATR_WAIT_TCK;
      }

      break;

    case ATR_WAIT_TCK:

      //DebugPrint ("atr_ProcessByte(): TCK\n");
      AtrCheck ^= ch;
      if (AtrCheck != 0)
      {
        return SCI_E_PROTO;
      }
      AtrState = ATR_ENDED;

      break;

    case ATR_WAIT_PTS_ACK:

      //DebugPrint ("atr_ProcessByte(): PTS ACK\n");

      if (ch != PTS_ACK)
      {
        return SCI_E_PROTO;
      }

      AtrState = ATR_WAIT_PROT_ECHO;

      break;

    case ATR_WAIT_PROT_ECHO:

      //DebugPrint ("atr_ProcessByte(): protocol echo\n");

      if (ch != T0_TYPE)
      {
        return SCI_E_PROTO;
      }

      AtrState = ATR_WAIT_PROT_ACK;

      break;

    case ATR_WAIT_PROT_ACK:

      //DebugPrint ("atr_ProcessByte(): protocol ack\n");

      if (ch != PTS_ACK)
      {
        return SCI_E_PROTO;
      }

      AtrState = ATR_PTS_ENDED;

      break;

    case ATR_ENDED:
      //DebugPrint("atr_ProcessByte(): ATR_ENDED\n");
    case ATR_PTS_ENDED:

      //DebugPrint ("atr_ProcessByte(): SCI_E_PROTO\n");

      return SCI_E_PROTO;

      break;
  }

  if (AtrState != ATR_ENDED && AtrState != ATR_PTS_ENDED)
  {
    return SCI_SUCCESS;
  }

  if (AtrState == ATR_ENDED)
  {
    /* determine if protocol selection required */
    if (!atr_SendPtss ())
      return SCI_E_COMMS;
  }

  if (AtrState != ATR_PTS_ENDED)
    return SCI_SUCCESS;

  /* ATR received in full successfully */
  sci_State = S_S_OPEN;
  //DebugPrint ("atr_ProcessByte(): signalling apps\n");
  for (channel=0; channel<MAX_CARD_CHANNELS; channel++)
    if (ChannelTable[channel].flags & channel_in_use)
      if (ChannelTable[channel].state == S_C_OPENING)
        sys_SignalTask(channel,SCI_CMD_DONE);

  WorkWaitTime = atr_CalcWorkWaitTime ();

  return (SCI_SUCCESS);
}

/**************************************************************************/
static BOOL
atr_SendPtss (void)
/**************************************************************************/
/*
   This function
   1. determines if it necessary to perform protocol selection
   2. generates protocol selection block
   3. sends protocol selection block
   4. sets next state
   Returns TRUE if everything OK, FALSE if comms error sending PTSS.
   It does not return any indication as to whether PTSS was necessary.
 */

{
  int i;
  BYTE ptss[PTSS_LEN];

  for (i = 0; i < ProtCount; i++)
  {
    if (ProtTab[i].type != T0_TYPE)
      break;
  }
  if (i >= ProtCount)
  {
    /* only protocol types T=0 detected so no PTSS required */
    AtrState = ATR_PTS_ENDED;
    return TRUE;
  }

  i = 0;
  ptss[i++] = PTS_PTSS;
  ptss[i++] = PTS_DEF_PTS0;
  ptss[i++] = PTS_DEF_TCK;

  if (com_SendBytes (ptss, i) != SCI_SUCCESS)
    return FALSE;

  AtrState = ATR_WAIT_PTS_ACK;

  return TRUE;
}

/**************************************************************************/
int
atr_Start (BOOL reset)
/**************************************************************************/

{
  /* if card out do nothing, wait for card in and then do the reset */

  debug DebugPrint("SCTransport: atr_Start, reset %d\n",reset);
  if (com_CardIn())
  {
    if (reset)
    {
      com_FlushComms ();
      sys_DiscardEvents ();

      if (com_SetResetInd () != SCI_SUCCESS)
	return atr_Error (SCI_E_COMMS);

      /*
       * waiting for ATR so set wait time
       */
      sys_StartWaitTimer (ATR_INIT_WAIT);
    }
  }

  AtrState = ATR_WAIT_TS;
  sci_State = S_S_OPENING;

  //debug DebugPrint("SCTransport: finished atrStart\n");

  return SCI_SUCCESS;
}

/**************************************************************************/
int
atr_Error (int err)
/**************************************************************************/

{
  int channel;

  //DebugPrint ("Entering atr_Error()\n");

  /* remember current connection slot */
  /* error condition so signal users and close everything */
  for (channel=0; channel<MAX_CARD_CHANNELS; channel++)
  {
    if (ChannelTable[channel].flags & channel_in_use)
    {
      ChannelTable[channel].state = S_C_FAILED;
      ChannelTable[channel].last_err = err;
      sys_SignalTask(channel,SCI_ERROR);
    }
  }
  /* restore current connection slot */
  com_FlushComms ();

  sci_State = S_S_FAILED;
  sci_Errno = err;

  return (SCI_FAIL);
}

/**************************************************************************/
static int
atr_CalcWorkWaitTime (void)
/**************************************************************************/

{
  int wi;

  /* analyse protocol parameters */
  if (ProtCount < 2)
    /* can't be a TC2 byte */
    wi = ATR_DEFAULT_WI;
  else
  {
    if (ProtTab[0].type == ProtTab[1].type)
      /* protocol with additional parameters */
      wi = ProtTab[1].extra_time;
    else
      wi = ATR_DEFAULT_WI;
  }

  return wi * MS_PER_SEC / 100;	/* centi-seconds */
}
