/*-------------------------------------------------------------------------

	File: t0_sm.c

	Purpose:
	  To implement those functions which handle the smart card protocol
	  T=0. Although not strictly implemented as a state machine it works
	  in a similar way in that each stage sets a state which determines
	  what happens next.

---------------------------------------------------------------------------

	Written by A.S.E Consulting for Card Dynamics
	Copyright (c) 1996 A.S.E Consulting  All Rights Reserved.

        Modification history
          04-Oct-96 Rich  Removed need for t0_HandleInput, event handler
          	    	  now calls t0_ProcessByte directly.

-------------------------------------------------------------------------*/

#ifdef ARM
#include "arm.h"
#else /* ARM */
#include <windows.h>
#endif /* ARM */

#include <string.h>
#include <stdio.h>

#include "sci_api.h"
#include "sci_int.h"
#include "t0_sm.h"

static BYTE *RcvData = NULL;	/* received data buffer */
static int ExpLen;		/* expected data length from current command */
static int ActLen;		/* actual data length from current command */
static int RcvNext;		/* position of next byte in receive buffer */
static RESP_DATA Resp;

static XPORT_HDR CmdHdr;
static BYTE *XmitData = NULL;	/* transmit data buffer */
static int XmitLen;		/* length of data in xmit buffer */
static int XmitNext;		/* position of next byte to xmit */

static int XportType;

int t0_State;

/***************************************************************************/
int
t0_ProcessByte (BYTE ch)
/***************************************************************************/
{
  //debug DebugPrint ("SCTransport: t0_ProcessByte state %d, byte %02X\n", t0_State, ch);

  switch (t0_State)
  {
    case S1_WAIT_PROC1:
      /* we should now be processing a/first procedure byte */
      if (ch == T0_PROC_NULL)
        ; /* do nothing, just present to reset timers */
      else if ((ch & MASK_LSN) == T0_SW1_ERR ||
  	     (ch & MASK_LSN) == T0_SW1_OK)
      {
        Resp.sw1 = ch;
        t0_State = S1_WAIT_PROC2;
      }
      else
      {
        //debug DebugPrint ("Exiting t0_ProcessByte(): SCI_E_PROTO\n");

        return SCI_E_PROTO;
      }

      break;

    case S1_WAIT_PROC2:
      /* we should now be processing the second procedure byte (SW2) */
      Resp.sw2 = ch;
      ActLen = 0;			/* case 1 so can't be any response data */
      sci_State = S_S_USER;
      ChannelTable[current_channel].state = S_C_USER;

      t0_State = S_T0_ENDED;

      break;
  /* case 2 - no data to send, response expected */
    case S2_WAIT_PROC1:
      /* we should now be processing a/first procedure byte */
      if (ch == T0_PROC_NULL)
        /* do nothing, just present to reset timers */
        ;
      else if ((ch & MASK_LSN) == T0_SW1_ERR ||
  	     (ch & MASK_LSN) == T0_SW1_OK)
      {
        Resp.sw1 = ch;
        t0_State = S2_WAIT_PROC2;
      }
      else if (ch == CmdHdr.ins || ch == (CmdHdr.ins + 1))
      {
        /* expect to receive data */
        t0_State = S2_WAIT_RESP_BLOCK;
      }
      else if ((ch & 0xFF) == ((~CmdHdr.ins) & 0xFF) ||
  	     (ch & 0xFF) == ((~(CmdHdr.ins + 1)) & 0xFF))
      {
        /* expect to receive next byte of data */
        t0_State = S2_WAIT_RESP_BYTE;
      }
      else
      {
        //debug DebugPrint ("Exiting t0_ProcessByte(): SCI_E_PROTO\n");
        return SCI_E_PROTO;
      }

      break;

    case S2_WAIT_PROC2:
      /* we should now be processing the second procedure byte (SW2) */
      Resp.sw2 = ch;

      if (Resp.sw1 == T0_C2_LEN_ERR)
      {
        /* set expected length to actual length and re-issue command */
        ActLen = CmdHdr.len = ch;

        t0_State = S2_WAIT_PROC1;
        /* initiate sending of command header */
        //debug DebugPrint ("Exiting t0_ProcessByte() via SendBytes(): ActLen %d\n", ActLen);
        return com_SendBytes ((BYTE *) & CmdHdr, T0_HDR_LEN);
      }
      sci_State = S_S_USER;
      ChannelTable[current_channel].state = S_C_USER;

      //debug DebugPrint ("Exiting t0_ProcessByte() via SignalTask(): ActLen %d\n", ActLen);

      t0_State = S_T0_ENDED;

      break;

    case S2_WAIT_RESP_BLOCK:
      *(RcvData + RcvNext++) = ch;
      if (RcvNext == ActLen)
        t0_State = S2_WAIT_PROC1;

      break;

    case S2_WAIT_RESP_BYTE:
      *(RcvData + RcvNext++) = ch;
      t0_State = S2_WAIT_PROC1;

      break;

  /* case 3 - data to send, no response expected */
    case S3_WAIT_PROC1:
      /* we should now be processing a/first procedure byte */
      if (ch == T0_PROC_NULL)
        /* do nothing, just present to reset timers */
        ;
      else if ((ch & MASK_LSN) == T0_SW1_ERR ||
  	     (ch & MASK_LSN) == T0_SW1_OK)
      {
        Resp.sw1 = ch;
        t0_State = S3_WAIT_PROC2;
      }
      else if (ch == CmdHdr.ins || ch == (CmdHdr.ins + 1))
      {
        /* send command data */
        //debug DebugPrint ("Exiting t0_ProcessByte() via SendBytes(): ActLen %d\n", ActLen);
        return com_SendBytes ((XmitData + XmitNext), XmitLen);
        /* no state change, next byte expected is procedure byte 1 */
      }
      else if ((ch & 0xFF) == ((~CmdHdr.ins) & 0xFF) ||
  	     (ch & 0xFF) == ((~(CmdHdr.ins + 1)) & 0xFF))
      {
        /* send next byte of command data */
        //debug DebugPrint ("Exiting t0_ProcessByte() via SendBytes(): ActLen %d\n", ActLen);
        XmitLen--;
        return com_SendBytes ((XmitData + XmitNext++), 1);
        /* no state change, next byte expected is procedure byte 1 */
      }
      else
      {
        //debug DebugPrint ("Exiting t0_ProcessByte(): SCI_E_PROTO\n");

        return SCI_E_PROTO;
      }

      break;
    case S3_WAIT_PROC2:

      /* we should now be processing the second procedure byte (SW2) */
      Resp.sw2 = ch;

      sci_State = S_S_USER;
      ChannelTable[current_channel].state = S_C_USER;

      //debug DebugPrint ("SCTransport: Exiting t0_ProcessByte via SignalTask: ActLen %d\n", ActLen);

      t0_State = S_T0_ENDED;

      break;

  /* case 4 - data to send, response expected */
    case S4_WAIT_PROC1:
      /* we should now be processing a/first procedure byte */
      if (ch == T0_PROC_NULL)
        /* do nothing, just present to reset timers */
        ;
      else if ((ch & MASK_LSN) == T0_SW1_ERR ||
  	     (ch & MASK_LSN) == T0_SW1_OK)
      {
        Resp.sw1 = ch;
        t0_State = S4_WAIT_PROC2;
      }
      else if (ch == CmdHdr.ins || ch == (CmdHdr.ins + 1))
      {
        /* send command data */
        //debug DebugPrint ("Exiting t0_ProcessByte() via SendBytes(): ActLen %d\n", ActLen);
        return com_SendBytes ((XmitData + XmitNext), XmitLen);
        /* no state change, next byte expected is procedure byte 1 */
      }
      else if ((ch & 0xFF) == ((~CmdHdr.ins) & 0xFF) ||
  	     (ch & 0xFF) == ((~(CmdHdr.ins + 1)) & 0xFF))
      {
        /* send next byte of command data */
        //debug DebugPrint ("Exiting t0_ProcessByte() via SendBytes(): ActLen %d\n", ActLen);
        XmitLen--;
        return com_SendBytes ((XmitData + XmitNext++), 1);
        /* no state change, next byte expected is procedure byte 1 */
      }
      else
      {
        //debug DebugPrint ("Exiting t0_ProcessByte(): SCI_E_PROTO\n");
        return SCI_E_PROTO;
      }

      break;
    case S4_WAIT_PROC2:
      /* we should now be processing the second procedure byte (SW2) */
      Resp.sw2 = ch;

      if ((Resp.sw1 == T0_SW1_OK && Resp.sw2 == T0_SW2_OK))
      {
        /* generate GETRESPONSE command header */
        CmdHdr.cla = GETRESP_CLA;
        CmdHdr.ins = GETRESP_INS;
        CmdHdr.p1 = GETRESP_P1;
        CmdHdr.p2 = GETRESP_P2;

        CmdHdr.len = ExpLen;
        if (ExpLen == SCI_MAX_EXP_LEN)
  	CmdHdr.len = 0;
        else
  	CmdHdr.len = ExpLen;
        /* continue processing as for case 2 */
        t0_State = S2_WAIT_PROC1;
        /* initiate sending of GETRESPONSE command header */
        //debug DebugPrint ("SCTransport: Exiting t0_ProcessByte via SendBytes(): ActLen %d\n", ActLen);
        return com_SendBytes ((BYTE *) & CmdHdr, T0_HDR_LEN);
      }

      if (Resp.sw1 == T0_C4_LEN_ERR)
      {
        /* generate GETRESPONSE command header */
        CmdHdr.cla = GETRESP_CLA;
        CmdHdr.ins = GETRESP_INS;
        CmdHdr.p1 = GETRESP_P1;
        CmdHdr.p2 = GETRESP_P2;
        /* set expected length to actual length */
        if (ch == 0)
  	ActLen = SCI_MAX_EXP_LEN;
        else
  	ActLen = ch;

        CmdHdr.len = (ActLen < ExpLen) ? ActLen : ExpLen;
        if (CmdHdr.len == SCI_MAX_EXP_LEN)
  	CmdHdr.len = 0;
        else
  	CmdHdr.len = ExpLen;
        t0_State = S4_WAIT_2_PROC1;
        /* initiate sending of GETRESPONSE command header */
        //debug DebugPrint ("SCTransport: Exiting t0_ProcessByte via SendBytes(): ActLen %d\n", ActLen);
        return com_SendBytes ((BYTE *) & CmdHdr, T0_HDR_LEN);
      }

      sci_State = S_S_USER;
      ChannelTable[current_channel].state = S_C_USER;

      //debug DebugPrint ("SCTransport: Exiting t0_ProcessByte via SignalTask: ActLen %d\n", ActLen);

      t0_State = S_T0_ENDED;

      break;

    case S4_WAIT_2_PROC1:
      /* we should now be processing a/first procedure byte after
         a GET RESPONSE TPDU with La != Le */
      if (ch == T0_PROC_NULL)
        /* do nothing, just present to reset timers */
        ;
      else if ((ch & MASK_LSN) == T0_SW1_ERR ||
  	     (ch & MASK_LSN) == T0_SW1_OK)
      {
        Resp.sw1 = ch;
        t0_State = S4_WAIT_PROC2;
      }
      else if (ch == CmdHdr.ins || ch == (CmdHdr.ins + 1))
      {
        /* expecting data block */
        t0_State = S4_WAIT_RESP_BLOCK;
      }
      else if ((ch & 0xFF) == ((~CmdHdr.ins) & 0xFF) ||
  	     (ch & 0xFF) == ((~(CmdHdr.ins + 1)) & 0xFF))
      {
        /* expecting data byte */
        t0_State = S4_WAIT_RESP_BYTE;
      }
      else
      {
        //debug DebugPrint ("SCTransport: Exiting t0_ProcessByte(): SCI_E_PROTO\n");
        return SCI_E_PROTO;
      }

      break;

    case S4_WAIT_2_PROC2:
      /* we should now be processing the second procedure byte (SW2)
         after a GET RESPONSE TPDU with La != Le */
      Resp.sw2 = ch;

      sci_State = S_S_USER;
      ChannelTable[current_channel].state = S_C_USER;

      //debug DebugPrint ("SCTransport: Exiting t0_ProcessByte() via SignalTask(): ActLen %d\n", ActLen);

      t0_State = S_T0_ENDED;

      break;

    case S4_WAIT_RESP_BLOCK:
      /* we should now be receiving response data block */
      *(RcvData + RcvNext++) = ch;
      if (RcvNext == ActLen)
        t0_State = S4_WAIT_RES_PROC1;

      break;

    case S4_WAIT_RESP_BYTE:
      /* we should now be receiving one response data byte */
      *(RcvData + RcvNext++) = ch;
      t0_State = S4_WAIT_2_PROC1;

      break;

    case S4_WAIT_RES_PROC1:
      /* we should now be processing a/first procedure byte */
      if (ch == T0_PROC_NULL)
        ;
      else if ((ch & MASK_LSN) == T0_SW1_ERR ||
  	     (ch & MASK_LSN) == T0_SW1_OK)
      {
        Resp.sw1 = ch;
        t0_State = S4_WAIT_RES_PROC2;
      }
      else
      {
        /* protocol error, there is no more data to send or receive */
        //debug DebugPrint ("Exiting t0_ProcessByte(): SCI_E_PROTO\n");
        return SCI_E_PROTO;
      }

      break;
    case S4_WAIT_RES_PROC2:
      /* we should now be processing the second procedure byte (SW2)
         after the response data */
      Resp.sw2 = ch;

      sci_State = S_S_USER;
      ChannelTable[current_channel].state = S_C_USER;

      //debug DebugPrint ("Exiting t0_ProcessByte() via SignalTask(): ActLen %d\n", ActLen);

      t0_State = S_T0_ENDED;

      break;

    default:
      return SCI_E_PROTO;
  }

  if (t0_State == S_T0_ENDED)
    sys_SignalTask(current_channel,SCI_CMD_DONE);

  return (SCI_SUCCESS);
}

/***************************************************************************/
int
t0_StartCommand (BYTE FAR * cmd_hdr, int data_len,
		 BYTE FAR * data, int exp_len)
/***************************************************************************/

{
  //debug DebugPrint ("Entering t0_StartCommand(): ActLen %d\n", ActLen);

  /* determine transport type - case 1, 2, 3 or 4 */
  if (data_len)
  {
    if (exp_len)
      XportType = T0_CASE4;
    else
      XportType = T0_CASE3;
  }
  else
  {
    if (exp_len)
      XportType = T0_CASE2;
    else
      XportType = T0_CASE1;
  }

  /* construct transport header */
  CmdHdr.cla = *cmd_hdr++;
  CmdHdr.ins = *cmd_hdr++;
  CmdHdr.p1 = *cmd_hdr++;
  CmdHdr.p2 = *cmd_hdr++;

  /* add length to header depending on type, and set next state */
  switch (XportType)
  {
  case T0_CASE1:
    CmdHdr.len = 0;
    t0_State = S1_WAIT_PROC1;

    break;

  case T0_CASE2:
    if (exp_len == SCI_MAX_EXP_LEN)
      CmdHdr.len = 0;
    else
      CmdHdr.len = exp_len;
    t0_State = S2_WAIT_PROC1;

    break;

  case T0_CASE3:
    CmdHdr.len = data_len;
    t0_State = S3_WAIT_PROC1;

    break;

  case T0_CASE4:
    CmdHdr.len = data_len;
    t0_State = S4_WAIT_PROC1;

    break;
  }

  if (XportType == T0_CASE3 || XportType == T0_CASE4)
  {
    /* move data to xmit buffer */
    if (data_len)
      memcpy (XmitData, data, data_len);
    XmitLen = data_len;
    XmitNext = 0;
    ActLen = ExpLen = 0;
  }

  if (XportType == T0_CASE2 || XportType == T0_CASE4)
  {
    /* remember expected length, initialise receive buffer index */
    ActLen = ExpLen = exp_len;
    RcvNext = 0;
  }

  /* flush queues */
  com_FlushComms ();

  /* initiate sending of command header */
  //debug DebugPrint ("Exiting t0_StartCommand() via SendBytes(): ActLen %d\n", ActLen);

  return com_SendBytes ((BYTE *) & CmdHdr, T0_HDR_LEN);
}

/***************************************************************************/
int
t0_GetData (BYTE FAR * buff, int buff_len, int FAR * rcv_len, BYTE FAR * resp)
/***************************************************************************/

{
  //debug DebugPrint ("Entering t0_GetData(): ActLen %d\n", ActLen);

  *resp++ = Resp.sw1;
  *resp = Resp.sw2;

  if (buff == NULL || buff_len == 0)
  {
    *rcv_len = ActLen;
    if (ActLen > 0)
    {
      //debug DebugPrint ("Exiting t0_GetData() SCI_E_TRUNC\n");

      return (SCI_E_TRUNC);
    }
    else
    {
      //debug DebugPrint ("Exiting t0_GetData() SCI_E_TRUNC\n");

      return (SCI_SUCCESS);
    }
  }
  else if (ActLen > buff_len)
  {
    memcpy (buff, RcvData, buff_len);
    *rcv_len = ActLen;
    //debug DebugPrint ("Exiting t0_GetData() SCI_E_TRUNC\n");

    return (SCI_E_TRUNC);
  }
  else
  {
    memcpy (buff, RcvData, ActLen);
    *rcv_len = ActLen;
    //debug DebugPrint ("Exiting t0_GetData()\n");

    return SCI_SUCCESS;
  }
}

/*
 * line errors, character framing errors
 */
int
t0_Error (int err)
{
  int channel;

  debug DebugPrint ("SCTransport: t0_Error err = %d\n",err);

  /* error condition so signal users */
  for (channel=0; channel<MAX_CARD_CHANNELS; channel++)
  {
    /* check for allocated slots */
    if (ChannelTable[channel].flags & channel_in_use)
    {
      ChannelTable[channel].state = S_C_FAILED;
      ChannelTable[channel].last_err = err;
      sys_SignalTask(channel,SCI_ERROR);
    }
  }
  /* restore current connection slot */

  sys_DiscardEvents ();
  com_FlushComms ();

  sci_State = S_S_FAILED;
  sci_Errno = err;

  return (SCI_FAIL);
}

/***************************************************************************/
int
t0_CardStatusChange (BOOL card_in)
/***************************************************************************/
/* card state change */

{
  int channel;

  debug DebugPrint("SCTransport: t0_CardStatusChange(): card %s\n",(card_in)?"IN":"OUT");

  if (card_in)
  {
    /* prepare for receipt of ATR */
    if (atr_Start (FALSE) != SCI_SUCCESS)
      return SCI_FAIL;
  }
  else
  {
    for (channel=0; channel<MAX_CARD_CHANNELS; channel++)
    {
      if (ChannelTable[channel].flags & channel_in_use)
      {
	sys_SignalTask(channel,SCI_REMOVED);
	if (ChannelTable[channel].state != S_C_OPENING)
	  ChannelTable[channel].state = S_C_REMOVED;
      }
    }
    sci_State = S_S_REMOVED;
    sci_Locked = FALSE;
    sys_DiscardEvents ();
    com_FlushComms ();
  }

  return (SCI_SUCCESS);
}

/***************************************************************************/
int
t0_ScipError (void)
/***************************************************************************/
/* SCIP detected errors */

{
  return t0_Error (SCI_E_COMMS);
}

/***************************************************************************/
BOOL
t0_Init (void)
/***************************************************************************/

{
  /* allocate buffer for transmitting data */
  if ((XmitData = (BYTE FAR *) sys_Malloc (MAX_XMIT_BUF)) == (BYTE FAR *) NULL)
    return (FALSE);

  /* allocate buffer for receiving data */
  if ((RcvData = (BYTE FAR *) sys_Malloc (MAX_RCV_BUF)) == (BYTE FAR *) NULL)
    return (FALSE);

  return TRUE;
}

/***************************************************************************/
void
t0_Close (void)
/***************************************************************************/

{
  /* free buffer for transmitting data */
  sys_Free (XmitData);

  /* free buffer for receiving data */
  sys_Free (RcvData);

  return;
}
