/************************************************************************/
/* 	        Copyright 1996 Acorn Network Computers		        */
/*									*/
/*  This material is the confidential trade secret and proprietary	*/
/*  information of Acorn Network Computers. It may not be reproduced,   */
/*  used sold, or transferred to any third party without the prior      */
/*  written consent of Acorn Network Computers. All rights reserved.	*/
/* 									*/
/************************************************************************/

/*
 * Contains module specific stuff plus the sys_ os hooks required for the port.
 *
 * The event handling is worth describing as it may seem a little weired.
 * Basically the following events are required by the smart card software :
 * timeouts, serial events and serial data. Under windows, these events are all
 * reported using the messaging system, however under riscos we use
 * os_callafters, events and upcalls. To simplify the porting, we claim all the
 * appropriate riscos stuff, filter it to make sure the events are for us,
 * and setup a generic callback to handle it later based on a global event
 * variable. This event handinng function sc_event_handler() is analogous to
 * the windows message handler.
 *
 * Modification History
 *---------------------
 *
 * 03-Jun-96  RWB,  Created.
 * 01-Jul-96  RWB,  Allowed api call read_response to have null buffer passed
 * 	      	    in as argument when not expecting any return data.
 * 11-Jul-96  RWB,  During rx data event, loop until buffer is empty. Also only
 * 	      	    add rx data events to the queue if there are less than two
 * 	      	    such events pending.
 * 02-Aug-96  RWB,  Converted the discrete integer flags to a bit mask flag.
 * 07-Aug-96  RWB,  Huge amount of faffing about to get it working from ROM.
 * 	      	    Moved initialisation code to Service_PostInit - not sure if
 *		    this is really necessary but it avoids an Abort on Data
 *		    transfer.
 * 09-Aug-96  RWB,  Added debounce of the card in/out signal. This is controled
 * 	      	    by the #define DEBOUNCE_TIME.
 * 06-Sep-96  RWB,  Now perform full initialisation when flag -fullinit is given
 *                  on the command line.
 * 11-Sep-96  RWB,  Made constant strings static.
 * 26-Sep-96  RWB,  Improved the positioning of the timout cancelation calls.
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include "kernel.h"
#include "swis.h"
#include "module.h"
#include "header.h"
#include "arm.h"
#include "sci_api.h"
#include "sci_int.h"
#include "irqs.h"
#include "serial.h"
#include "serial_ven.h"

/*
 * veneers generated by cmhg
 */
extern void sc_event_entry(void);
extern void upcall_entry(void);
extern void event_entry(void);
extern void timer_entry(void);
extern void starting_entry(void);
extern void debounce_entry(void);

/*
 * module housekeeping globals and prototypes
 */
void   *workspace_pointer = NULL;
#ifdef USE_TINY
static _kernel_oserror *TinyError;
#endif
static BYTE	       *pchBuffer = NULL;

/*
 * smart card processing specific globals
 */
#define MAX_EVENTS    (10)
#define DEBOUNCE_TIME (50)

t_sctrans_events Events[MAX_EVENTS];             /* generic event queue */
int next_event = -1;
int free_event = 0;
int iInputStream  = 0;
int iOutputStream = 0;
int num_data_events_pending = 0;
int flags = 0;
int t0_error = 0;
int t0_protocol_location = 0;
int signal_error = 0;
/*
 * error declarations
 */
ERROR_STRUCT(NOTINIT,"SCTransport: Not initialised");
ERROR_STRUCT(MEMFAIL,"SCTransport: Failed memory allocation");

static char *strStates[] = {"","closed","starting","opening","open",
       	    		    "cmd","user","failed","removed"};
#ifdef _DEBUG
char *strNotifications[] = {"","CardRemoved","CardInserted",
     			 "Transaction end","Command complete","Error"};
#endif
/*
 * serial upcall of interest or serial event of interest
 */
int
sc_event_handler(_kernel_swi_regs *r, void *pw)
{
  int len;
  int this_event = 0;
  int old_irqs;
  int i;

  i=i; /* supress warning */

  while (next_event != free_event)
  {
    if (next_event == -1) break;
    this_event = Events[next_event];  /* take a copy since it may change */
    switch(this_event)
    {
      case SC_Event_Timeout :
        debug DebugPrint("SCTransport: event timeout\n");
        if (flags & flag_timeout_to_handle)
        {
          if (sci_State == S_S_OPENING)
          {
	    atr_Error(SCI_E_PROTO);
	  }
          else
          {
	    t0_protocol_location = 1;
 	    t0_Error(SCI_E_PROTO);
          }
        }
        else
          debug DebugPrint("SCTransport: timeout event thrown away\n");
        break;

      case SC_Event_DataPresent :
        num_data_events_pending--;  /* show we are processing one event */
        while (serial_size(iInputStream))
        {
          sys_CancelWaitTimer();
          len = com_ReadBytes(pchBuffer, IN_COMMS_Q);

          debug
          {
            DebugPrint("@");
            //DebugPrint("SCTransport: rx %d bytes\n",len);
            if (0)
            {
              for (i=0; i<len; i++)
                DebugPrint("%s%02x",(i==0)?"":",",pchBuffer[i]);
              DebugPrint("\n");
            }
          }

          if (sci_State == S_S_OPENING)
            atr_HandleInput(pchBuffer, len);
          else
          {
            if (sci_State == S_S_CMD)
              t0_HandleInput(pchBuffer, len);
            else
              debug DebugPrint("SCTransport: throw away bytes\n");
          }
        }
        break;

      case SC_Event_SerialError :
        debug DebugPrint("SCTransport: serial error\n");
        sys_CancelWaitTimer();
        /*
         * don't care about events in initial state
         */
        if (sci_State != S_S_CLOSED && sci_State != S_S_FAILED)
	{
          if (sci_State == S_S_OPENING)
            atr_Error(SCI_E_COMMS);
          else
            t0_Error(SCI_E_COMMS);
        }
        break;

      case SC_Event_CardIn :
        debug DebugPrint("SCTransport: card in\n");
        sys_CancelWaitTimer();
        t0_CardStatusChange(TRUE);
        break;

      case SC_Event_CardOut :
        debug DebugPrint("SCTransport: card out\n");
        sys_CancelWaitTimer();
        t0_CardStatusChange(FALSE);
        break;

      default :
        debug DebugPrint("SCTransport: event %d not handled\n",this_event);
        break;
    }
    old_irqs = irqs_off();
    if (next_event>=0) next_event++;
    if (next_event==MAX_EVENTS) next_event=0;
    irqs_on(old_irqs);
  }

  old_irqs = irqs_off();
  CLEAR_FLAG(flags,flag_event_pending);
  next_event = -1;
  irqs_on(old_irqs);

  return (1);
}

/*
 * setup a callback to deal with the serial event.
 */
_kernel_oserror *
setup_event(t_sctrans_events this_event)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;
  int old_irqs;

  //debug DebugPrint("SCTransport: add event %d\n",this_event);

  if (free_event != next_event)
  {
    old_irqs = irqs_off();
    if (next_event == -1) next_event = free_event;
    Events[free_event++] = this_event;
    if (free_event==MAX_EVENTS) free_event=0;
    irqs_on(old_irqs);
    /*
     * see if event handler needs to be established
     */
    if (!(flags&flag_event_pending))
    {
      reg.r[0] = (int)sc_event_entry;
      reg.r[1] = (int)workspace_pointer;
      ERR_RETURN(err,_kernel_swi(OS_AddCallBack, &reg, &reg));
      SET_FLAG(flags,flag_event_pending);
    }
  }

  return (NULL);
}

/*
 * timeout timer has fired
 */
int
timer_handler(_kernel_swi_regs *r, void *pw)
{
  CLEAR_FLAG(flags,flag_timeout_pending);
  SET_FLAG(flags,flag_timeout_to_handle);
  setup_event(SC_Event_Timeout);

  return (1);
}

/*
 * handle events, select ones of interest to us and setup a callback to handle
 * them later.
 *
 * due to the way received data flushed from the buffer, ingore any rx data
 * events if there is two or more events already pending in the queue.
 */
int
upcall_handler(_kernel_swi_regs *r, void *pw)
{
  switch (r->r[0])
  {
    case UpCall_DeviceRxDataPresent : case UpCall_DeviceThresAbove :
      if (iInputStream>0)
      {
        if (r->r[1]==iInputStream)
        {
          sys_CancelWaitTimer();
          if (num_data_events_pending<2)
          {
            num_data_events_pending++;
            if (flags&flag_debouncing)  /* if currently debouncing, defer */
              SET_FLAG(flags,flag_data_pending);
            else
              setup_event(SC_Event_DataPresent);
          }
        }
      }
      break;
    default :
      return (1); /* pass on */
  }
  return (0); /* handled */
}

/*
 * debounce timer has fired
 */
int
debounce_handler(_kernel_swi_regs *r, void *pw)
{
  if (com_CardIn()==TRUE)        /* dsr currently active */
  {
    if (flags&flag_dsr_state)    /* dsr was previously active */
    {
      //debug DebugPrint("SCTransport: bounce detected\n");
      com_FlushComms();
      sys_DiscardEvents();
    }
    else                         /* dsr has changed */
    {
      SET_FLAG(flags,flag_dsr_state);
      setup_event(SC_Event_CardIn);
      if (flags&flag_data_pending)
        setup_event(SC_Event_DataPresent);
    }
  }
  else                           /* dsr currently inactive */
  {
    if (!(flags&flag_dsr_state)) /* dsr was previously inactive */
    {
      //debug DebugPrint("SCTransport: bounce detected\n");
      com_FlushComms();
      sys_DiscardEvents();
    }
    else                         /* dsr has changed */
    {
      CLEAR_FLAG(flags,flag_dsr_state);
      setup_event(SC_Event_CardOut);
      if (flags&flag_data_pending)
        setup_event(SC_Event_DataPresent);
    }
  }

  CLEAR_FLAG(flags,(flag_data_pending|flag_debouncing));
  num_data_events_pending = 0;

  return (1);
}

/*
 * handle events, select ones of interest to us and setup a callback to handle
 * them later.
 */
int
event_handler(_kernel_swi_regs *r, void *pw)
{
  _kernel_swi_regs reg;

  if (r->r[0] == Event_RS423Error)
  {
    if ((iInputStream>0) && (r->r[2] == iInputStream))
    {
      if (r->r[1] & SerialEvent_Error)
        setup_event(SC_Event_SerialError);
      else if (r->r[1] & SerialEvent_DSR)
      {
        if (!(flags&flag_debouncing))
        {
          reg.r[0] = DEBOUNCE_TIME;
          reg.r[1] = (int)debounce_entry;
          reg.r[2] = (int)workspace_pointer;
          if (_kernel_swi(OS_CallAfter, &reg, &reg) == NULL)
            SET_FLAG(flags,flag_debouncing);
        }
      }
      return (0); /* handled */
    }
  }
  return (1); /* pass on */
}

/*
 * claims vectors and enables the events as required
 */
_kernel_oserror *
claim_vectors(void)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;

  /*
   * claim vectors
   */
  reg.r[0] = EventV;
  reg.r[1] = (int)event_entry;
  reg.r[2] = (int)workspace_pointer;
  ERR_RETURN(err,_kernel_swi(OS_Claim, &reg, &reg));

  reg.r[0] = UpCallV;
  reg.r[1] = (int)upcall_entry;
  reg.r[2] = (int)workspace_pointer;
  ERR_RETURN(err,_kernel_swi(OS_Claim, &reg, &reg));

  /*
   * enable RS423 event
   */
  reg.r[0] = 14;
  reg.r[1] = Event_RS423Error;
  ERR_RETURN(err,_kernel_swi(OS_Byte, &reg, &reg));

  return (NULL);
}

/*
 * release vectors, flush any callbacks and disable events
 */
_kernel_oserror *
release_vectors(void)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;

  /*
   * disable event
   */
  reg.r[0] = 13;
  reg.r[1] = Event_RS423Error;
  ERR_RETURN(err,_kernel_swi(OS_Byte, &reg, &reg));

  /*
   * release vectors
   */
  reg.r[0] = EventV;
  reg.r[1] = (int)event_entry;
  reg.r[2] = (int)workspace_pointer;
  ERR_RETURN(err,_kernel_swi(OS_Release, &reg, &reg));

  reg.r[0] = UpCallV;
  reg.r[1] = (int)upcall_entry;
  reg.r[2] = (int)workspace_pointer;
  ERR_RETURN(err,_kernel_swi(OS_Release, &reg, &reg));

  sys_DiscardEvents();

  return (NULL);
}

/*
 * module service, only dealing with Service_PostInit
 */
void
module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
  _kernel_swi_regs reg;

  if (sci_Init() != SCI_SUCCESS)
    return;
  if (!t0_Init())
    return;
  if (!com_Init())
    return;

  /*
   * send service call round to say we have started, do under callback
   */
  reg.r[0] = (int)starting_entry;
  reg.r[1] = (int)workspace_pointer;
  _kernel_swi(OS_AddCallBack, &reg, &reg);

  SET_FLAG(flags,flag_initialised);
}

/*
 * simple printf without using stdio
 */
void
my_printf(char *format, ...)
{
  _kernel_swi_regs reg;
  char strLine[80];
  va_list list;

  va_start(list, format);
  vsprintf(strLine,format,list);
  va_end(list);

  reg.r[0] = (int)strLine;
  _kernel_swi(OS_Write0,&reg,&reg);
  _kernel_swi(OS_NewLine,&reg,&reg);
}

/*
 * cli_handler
 */
_kernel_oserror *
module_cli(char *arg_string,int arg_count,int cmd_no,void *pw)
{
  int channel;

  switch (cmd_no)
  {
    case CMD_SCTransInfo :
      my_printf("   Flags : 0x%x",flags);
      my_printf("   State : %s",strStates[sci_State]);
      my_printf("   t0 errors        : %d",t0_error);
      my_printf("   t0 protocol loc  : %d",t0_protocol_location);
      my_printf("   signal errors    : %d",signal_error);

      for (channel=0; channel<3; channel++)
      {
        if (ChannelTable[channel].flags & channel_in_use)
        {
          my_printf("   Channel %d",channel);
          my_printf("     State        : %d",
                ChannelTable[channel].state);
          my_printf("     Last error   : %d",ChannelTable[channel].last_err);
          my_printf("     Locked       : %s",
        	(ChannelTable[channel].flags & channel_locked)?"Yes":"No");
          my_printf("     Wait unlock  : %s",
         	(ChannelTable[channel].flags & channel_wait_unlock)?"Yes":"No");
          my_printf("     Async signal : %s",
        	(ChannelTable[channel].flags & channel_async)?"Yes":"No");
        }
      }

      break;
  }
  return (NULL);
}

/*
 * module finalise
 */
_kernel_oserror *
module_finalise(int fatal, int podule, void *pw)
{
  _kernel_oserror *err = NULL;

  sys_CancelWaitTimer();

  t0_Close();  /* de-allocate buffers */

  com_Close();

  sys_Free(pchBuffer);
  ERR_RETURN(err,release_vectors());
#ifdef USE_TINY
  if ( TinyError == NULL ) _swix( TinySupport_Die, 0 );
#endif
  return NULL;

  NOT_USED( fatal );
  NOT_USED( podule );
}

/*
 * module initialise
 */
_kernel_oserror *
module_initialise(char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;
  static char keyword[]="fullinit/s";
  int arg=0;
  int i;

  workspace_pointer = pw;

#ifdef USE_TINY
  /*
   * try to use TinyStubs if possible.
   */
  reg.r[0] = (int)workspace_pointer;
  TinyError = _kernel_swi(TinySupport_Share, &reg, &reg);
#endif

  sci_State = S_S_CLOSED;

  /*
   * initialise the event queue
   */
  for (i=0; i<MAX_EVENTS; i++) Events[i] = SC_Event_Nothing;

  /*
   * initialise the debug system
   */
  debug DebugFileInit(FILENAME_DEBUG);

  ERR_RETURN(err,claim_vectors());

  pchBuffer = (BYTE*)sys_Malloc(IN_COMMS_Q);
  if (pchBuffer == NULL) ERR_RETURN(err,ERROR(MEMFAIL));

  reg.r[0] = (int)keyword;
  reg.r[1] = (int)cmd_tail;
  reg.r[2] = (int)&arg;
  reg.r[3] = sizeof(arg);
  _kernel_swi(OS_ReadArgs, &reg, &reg);

  if (arg==0x7fffffff)
    module_service(0x73,&reg,pw);

  return (NULL);
}

/*
 * module swi handler
 */
_kernel_oserror *
module_swi( int swi_no, _kernel_swi_regs *r, void *pw )
{
  if (!(flags&flag_initialised))
    return ERROR(NOTINIT);

  switch (swi_no+SCTransport_00)
  {
    case SCTransport_Open :
      r->r[0] = sci_Open(r->r[0], (int*)r->r[1]);
      break;
    case SCTransport_RetrieveATR :
      r->r[0] = sci_RetrieveATR(r->r[0],(BYTE*)r->r[1],r->r[2],(int*)r->r[3]);
      break;
    case SCTransport_Close :
      r->r[0] = sci_Close(r->r[0]);
      break;
    case SCTransport_IssueCommand :
      r->r[0] = sci_IssueCommand(r->r[0], (BYTE*)r->r[1],
  	      	r->r[2], (BYTE*)r->r[3], r->r[4]);
      break;
    case SCTransport_ReadResponse :
      r->r[0] = sci_ReadResponse(r->r[0], (BYTE*)r->r[1], r->r[2],
  	      	(int*)r->r[3], (BYTE*)r->r[4]);
      break;
    case SCTransport_StartTrans :
      r->r[0] = sci_StartTrans(r->r[0]);
      break;
    case SCTransport_EndTrans :
      r->r[0] = sci_EndTrans(r->r[0]);
      break;
    case SCTransport_Error :
      r->r[0] = sci_Error(r->r[0]);
      break;
#ifdef _DEBUG
    case SCTransport_GetErrorText :
      r->r[0] = (int)sci_GetErrorText(r->r[0], (BOOL)r->r[1]);
      break;
#endif
  }

  return (NULL);

  NOT_USED( pw );
}
/************************************************************************
 * RiscOS hooks
 *
 * The following functions are expected by the ASE software hence we map
 * them into the way we do things in RiscOS.
 ************************************************************************/

/*
 * broadcast a message using the SCTransport event
 */
int
sys_SignalTask(int channel, int reason)
{
  _kernel_swi_regs reg;

  if (ChannelTable[channel].flags & channel_async)
  {
#ifdef _DEBUG
    debug DebugPrint("SCTransport: signal '%s' on channel %d\n",
    	  strNotifications[reason],channel);
#endif
    if (reason==SCI_ERROR)
      signal_error++;

    reg.r[0] = Event_Expansion;
    reg.r[1] = Event_Expansion_SCTransport;
    reg.r[2] = channel;
    reg.r[3] = reason;
    if (_kernel_swi(OS_GenerateEvent,&reg,&reg)) return (SCI_FAIL);
  }
  else
  {
    debug DebugPrint("SCTransport: signal %d not sent\n",reason);
  }

  return (SCI_SUCCESS);
}

/*
 * veneer to malloc for some reason
 */
BYTE *
sys_Malloc (int len)
{
  return (BYTE *) malloc ((size_t) (((len / 16) + 1) * 16));
}

/*
 * veneer to realloc for some reason
 */
BYTE *
sys_Realloc (BYTE * old, int len)
{
  return (BYTE *) realloc ((void *) old, (size_t) len);
}

/*
 * veneer to free for some reason
 */
void
sys_Free (BYTE * data)
{
  if (data != NULL) free (data);

  return;
}

/*
 * setup a timeout timer
 */
void
sys_StartWaitTimer(int wait_time)
{
  _kernel_swi_regs reg;
  int old_irqs = irqs_off();

  if (!(flags&flag_timeout_pending))
  {
    //debug DebugPrint("SCTransport: starting timer %d cs\n",wait_time);
    reg.r[0] = wait_time;
    reg.r[1] = (int)timer_entry;
    reg.r[2] = (int)workspace_pointer;
    _kernel_swi(OS_CallAfter, &reg, &reg);
    SET_FLAG(flags,flag_timeout_pending);
  }
  irqs_on(old_irqs);

  return;
}

/*
 * cancel a pending timeout timer
 */
void
sys_CancelWaitTimer(void)
{
  _kernel_oserror *err;
  _kernel_swi_regs reg;
  int old_irqs = irqs_off();

  CLEAR_FLAG(flags,flag_timeout_to_handle);

  if (flags&flag_timeout_pending)
  {
    //debug DebugPrint("SCTransport: cancel timer\n");
    reg.r[0] = (int)timer_entry;
    reg.r[1] = (int)workspace_pointer;
    err = _kernel_swi(OS_RemoveTickerEvent, &reg, &reg);

    CLEAR_FLAG(flags,flag_timeout_pending);
  }

  irqs_on(old_irqs);

  return;
}

/*
 * flush any events awaiting to be processed.
 */
void
sys_DiscardEvents(void)
{
  int old_irqs;

  //debug DebugPrint("SCTransport: discard events\n");

  old_irqs = irqs_off();
  next_event = -1;
  irqs_on(old_irqs);
}

/*
 * wait a given number of centiseconds
 */
void
sys_Delay(UINT iTime)
{
  _kernel_swi_regs reg;

  _kernel_swi(OS_ReadMonotonicTime, &reg, &reg);
  iTime+=reg.r[0];
  while(reg.r[0]<iTime)
  {
    _kernel_swi(OS_ReadMonotonicTime, &reg, &reg);
  }
}

/*
 * send service call out to say we are starting
 */
int
starting_handler(_kernel_swi_regs *r, void *pw)
{
  _kernel_swi_regs reg;

  //debug DebugPrint("SCTransport: service starting\n");

  reg.r[1] = Service_SCTransportStarting;
  _kernel_swi(OS_ServiceCall, &reg, &reg);

  return (1);
}
