/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/
/*
 * To provide the top-level API functions.
 */

#include <stdio.h>
#include <string.h>
#include "module.h"

#include "sci_api.h"
#include "sci_int.h"
#include "t1.h"
#include "t0_sm.h"
#include "atr.h"
#include "chan.h"
#include "com.h"

static void sci_ReleaseLock (void);

/*****************************************************************************/
int sci_Open (int msg_id, int *card_channel)
{
  int channel = -1;

#ifdef REMOTE_DEBUG_API
  debug_printf(db,"PROC * sci_Open\n");
#endif
  *card_channel = -1;
  if (sci_State == S_S_CMD || sci_State == S_S_USER)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_Open: invalid state: %d\n", sci_State);
#endif
    RETERR(SCI_E_SEQ);
  }

  if (sci_State == S_S_CLOSED)
    if (sci_Init () != SCI_SUCCESS)
      RETERR(SCI_E_API);

  /*
   * get first free channel
   */
  channel = chan_GetNew();
  if (channel == -1)
    RETERR(SCI_E_TOOMANY);

  switch (sci_State)
  {
    case S_S_CLOSED:
#ifdef REMOTE_DEBUG_API
      debug_printf(db,"sci_Open:switch:S_S_CLOSED\n");
#endif
      /* prepare for receipt of ATR */
      if (atr_Start(FALSE) != SCI_SUCCESS)
        RETERR_CHAN(channel,SCI_E_API);
      break;

    case S_S_OPENING:
#ifdef REMOTE_DEBUG_API
      debug_printf(db,"sci_Open:switch:S_S_OPENING\n");
#endif

    case S_S_REMOVED:
#ifdef REMOTE_DEBUG_API
      debug_printf(db,"sci_Open:switch:S_S_REMOVED\n");
#endif
      sci_State = S_S_OPENING;
      break;

    case S_S_OPEN:
#ifdef REMOTE_DEBUG_API
      debug_printf(db,"sci_Open:switch:S_S_OPEN\n");
#endif
      /*
       * indicate slot allocated and message notification type
       */
      SET_FLAG(ChannelTable[channel].flags,channel_in_use);
      if (msg_id!=0)
        SET_FLAG(ChannelTable[channel].flags,channel_async);

      /* card already open */
      sys_SignalTask(channel,SCI_CMD_DONE);
      break;

    case S_S_STARTING:
#ifdef REMOTE_DEBUG_API
      debug_printf(db,"sci_Open:switch:S_S_STARTING\n");
#endif
    case S_S_FAILED:
#ifdef REMOTE_DEBUG_API
      debug_printf(db,"sci_Open:switch:S_S_FAILED\n");
#endif
      sci_Locked = FALSE;
      /* reset SCIP and prepare for receipt of ATR */
      if (atr_Start (TRUE) != SCI_SUCCESS)
        RETERR_CHAN(channel,SCI_E_COMMS);
      break;
  }

  SET_FLAG(ChannelTable[channel].flags,channel_in_use);
  if (msg_id!=0)
    SET_FLAG(ChannelTable[channel].flags,channel_async);
  ChannelTable[channel].last_err = 0;
  ChannelTable[channel].state = S_C_OPENING;

  *card_channel = channel;
#ifdef REMOTE_DEBUG_API
  debug_printf(db,"(7) allocated channel %d\n",channel);
#endif

  if (!com_CardIn())
    RETERR_CHAN(channel,SCI_E_OUT);

  return (SCI_SUCCESS);
}

/*****************************************************************************/
int sci_RetrieveATR (int channel, BYTE * hist, int hist_len, int * rcv_len)
{
  if (!(ChannelTable[channel].flags & channel_in_use))
    RETERR_CHAN(channel,SCI_E_INVAL);

  if (hist==NULL || rcv_len==NULL)
    RETERR_CHAN(channel,SCI_E_INVAL);

  if (sci_State == S_S_FAILED)
    return (SCI_FAIL);

  if (ChannelTable[channel].state == S_C_FAILED)
    return (SCI_FAIL);

  if (ChannelTable[channel].state != S_C_OPENING)
    RETERR_CHAN(channel,SCI_E_SEQ);

  if (sci_State != S_S_OPEN)
    RETERR(SCI_E_NODATA);

  ChannelTable[channel].state = S_C_OPEN;

  if (sci_HistLen > hist_len)
  {
    memcpy (hist, sci_HistData, hist_len);
    *rcv_len = sci_HistLen;
    RETERR(SCI_E_TRUNC);
  }
  else
  {
    memcpy (hist, sci_HistData, sci_HistLen);
    *rcv_len = sci_HistLen;
  }
#ifdef REMOTE_DEBUG_API
  debug_printf(db,"returning ATR, length %d",sci_HistLen);
  if (sci_HistLen>0)
  {
    int i;
    for (i=0; i<sci_HistLen; i++)
      debug_printf(db,"    ATR[%d] : 0x%x\n",i,sci_HistData[i]);
  }
#endif
  return (SCI_SUCCESS);
}

/*****************************************************************************/
int sci_Close (int channel)
{
  if (!(ChannelTable[channel].flags & channel_in_use))
    RETERR_CHAN(channel,SCI_E_INVAL);

  /* if this connection is holding the lock free it */
  if (ChannelTable[channel].flags & channel_locked)
  {
    sci_Locked = FALSE;
    sci_ReleaseLock();
  }

  /* initialise slot ready for reuse */
  chan_Init(channel);

  /* reset state machine */
  if (com_CardIn())
      sci_State = S_S_OPEN;

  return (SCI_SUCCESS);
}

/*****************************************************************************/
int sci_IssueCommand (int channel, BYTE * cmd_hdr,
                      int data_len, BYTE * data, int exp_len)
{
  int err;
#ifdef REMOTE_DEBUG_API
  debug_printf(db,"PROC * sci_IssueCommand");
#endif

  if (!(ChannelTable[channel].flags & channel_in_use))
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_IssueCommand: channel in use\n");
#endif
    RETERR_CHAN(channel,SCI_E_INVAL);
  }

  if (cmd_hdr==NULL || (data==NULL && data_len>0))
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_IssueCommand: header NULL\n");
#endif
    RETERR_CHAN(channel,SCI_E_INVAL);
  }

  if (data_len > SCI_MAX_DATA_LEN || exp_len > SCI_MAX_EXP_LEN)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_IssueCommand: data length\n");
#endif
    RETERR_CHAN(channel,SCI_E_INVAL);
  }

  if (sci_State == S_S_FAILED)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_IssueCommand: failed state 0\n");
#endif
    return (SCI_FAIL);
  }

  if (sci_State == S_S_REMOVED)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_IssueCommand: card removed\n");
#endif
    RETERR_CHAN(channel,SCI_E_OUT);
  }

  if (sci_State != S_S_OPEN)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_IssueCommand: not open\n");
#endif
    RETERR_CHAN(channel,SCI_E_SEQ);
  }

  if (ChannelTable[channel].state ==S_C_FAILED)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_IssueCommand: failed state 1\n");
#endif
    return (SCI_FAIL);
  }

  /* check if system locked by another connection */
  if (sci_Locked && !(ChannelTable[channel].flags & channel_locked))
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_IssueCommand: channel locked\n");
#endif
    RETERR_CHAN(channel,SCI_E_TRANS);
  }

  sci_State = S_S_CMD;

  // new to select protocol commands
  switch (card_status.protocol)
  {
    case 1 :
#ifdef REMOTE_DEBUG_API
      debug_printf(db,"sci_IssueCommand: t1_StartCommand\n");
#endif
      err=t1_StartCommand(channel,cmd_hdr,data_len,data,exp_len);
      break;

    default :
#ifdef REMOTE_DEBUG_API
      debug_printf(db,"sci_IssueCommand: t0_StartCommand\n");
#endif
      err = t0_StartCommand(cmd_hdr, data_len, data, exp_len);
      break;
  }

  if (err != SCI_SUCCESS)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_IssueCommand: t*_StartCommand failed\n");
#endif
    sci_State = S_S_FAILED;
    ChannelTable[channel].state = S_C_FAILED;
    RETERR_CHAN(channel,err);
  }
#ifdef REMOTE_DEBUG_API
  debug_printf(db,"sci_IssueCommand: t*_StartCommand OK\n");
#endif
  return (SCI_SUCCESS);
}

/*****************************************************************************/
int sci_ReadResponse ( int channel, BYTE * buff,
                       int buff_len, int * rcv_len, BYTE * resp)
{
  int err;

#ifdef REMOTE_DEBUG_API
  debug_printf(db,"PROC * sci_ReadResponse");
#endif

  if (!(ChannelTable[channel].flags & channel_in_use))
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_ReadResponse:failed: SCI_E_INVAL");
#endif
    RETERR_CHAN(channel,SCI_E_INVAL);
  }

  if (rcv_len == NULL)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_ReadResponse:failed: rcv_len == NULL");
#endif
    RETERR_CHAN(channel,SCI_E_INVAL);
  }

  if (sci_State == S_S_REMOVED)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_ReadResponse:failed: card removed");
#endif
    RETERR_CHAN(channel,SCI_E_OUT);
  }

  if (sci_State == S_S_FAILED)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_ReadResponse:failed: connection failed");
#endif
    return (SCI_FAIL);
  }

  if (sci_State == S_S_CMD)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_ReadResponse:failed: command in progress\n");
#endif
    RETERR_CHAN(channel,SCI_E_NODATA);
  }

  if (sci_State != S_S_USER)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_ReadResponse:failed:0: no user data to read");
#endif
    RETERR_CHAN(channel,SCI_E_SEQ);
  }

  if (ChannelTable[channel].state == S_C_FAILED)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_ReadResponse:failed: connection in failed state");
#endif
    return (SCI_FAIL);
  }

  if (ChannelTable[channel].state != S_C_USER)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_ReadResponse:failed:1: no user data to read");
#endif
    RETERR_CHAN(channel,SCI_E_SEQ);
  }

  switch (card_status.protocol)
  {
    case 1 :
#ifdef REMOTE_DEBUG_API
      debug_printf(db,"sci_ReadResponse: t1_getdata\n");
#endif
      err = t1_GetData(buff, buff_len, rcv_len, resp);
      break; /* ? */

    default :
#ifdef REMOTE_DEBUG_API
      debug_printf(db,"sci_ReadResponse: t0_getdata\n");
#endif
      err = t0_GetData(buff, buff_len, rcv_len, resp);
      break;
  }
  if (err != SCI_SUCCESS)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf( db, "error from t%d_GetData\n", card_status.protocol);
#endif
    if (err == SCI_E_TRUNC)
    { /* ensure we go back to correct state */
      sci_State = S_S_OPEN;
    }
    RETERR_CHAN(channel,err);
  }
  sci_State = S_S_OPEN;
#ifdef REMOTE_DEBUG_API
  debug_printf( db, "sci_ReadResponse: SUCCESS\n");
#endif
  return (SCI_SUCCESS);
}

/*****************************************************************************/
int sci_StartTrans (int channel)
{
  if (!(ChannelTable[channel].flags & channel_in_use))
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_StartTrans: invalid card handle\n");
#endif
    RETERR_CHAN(channel,SCI_E_INVAL);
  }

  if (sci_State == S_S_FAILED)
  {
    /* error code should already have been set */
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_StartTrans: S_S_FAILED\n");
#endif
    return (SCI_FAIL);
  }

  if (sci_State == S_S_REMOVED)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_StartTrans: S_S_REMOVED\n");
#endif
    RETERR_CHAN(channel,SCI_E_OUT);
  }

  if (sci_State != S_S_OPEN)
  {
#ifdef REMOTE_DEBUG_API
    debug_printf(db,"sci_StartTrans: S_S_OPEN\n");
#endif
    RETERR_CHAN(channel,SCI_E_SEQ);
  }

  if (sci_Locked)
  {
    /* if this connection has already got lock its an error */
    if (ChannelTable[channel].flags & channel_locked)
    {
      RETERR_CHAN(channel,SCI_E_SEQ);
    }
    else
    {
      /* mark connection as waiting */
      SET_FLAG(ChannelTable[channel].flags,channel_wait_unlock);
      RETERR_CHAN(channel,SCI_E_TRANS);
    }
  }

  /* lock out all connections except this one */
  sci_Locked = TRUE;
  SET_FLAG(ChannelTable[channel].flags,channel_locked);
  CLEAR_FLAG(ChannelTable[channel].flags,channel_wait_unlock);
  current_channel = channel;

  return (SCI_SUCCESS);
}

/*****************************************************************************/
int sci_EndTrans (int channel)
{
  if (!(ChannelTable[channel].flags & channel_in_use))
    RETERR_CHAN(channel,SCI_E_INVAL);

  if (sci_State == S_S_FAILED)
    /* error code should already have been set */
    return (SCI_FAIL);

  if (sci_State == S_S_REMOVED)
    RETERR_CHAN(channel,SCI_E_OUT);

  if (!sci_Locked)
    RETERR_CHAN(channel,SCI_E_SEQ);

  if (sci_State != S_S_OPEN)
    RETERR_CHAN(channel,SCI_E_SEQ);

  /* check that this connection is holding the lock */
  if (!(ChannelTable[channel].flags&channel_locked))
    RETERR_CHAN(channel,SCI_E_SEQ);

  CLEAR_FLAG(ChannelTable[channel].flags,channel_locked);
  current_channel = -1;
  sci_Locked = FALSE;

  /* signal any waiting processes */
  sci_ReleaseLock();

  return (SCI_SUCCESS);
}

/*****************************************************************************
  if caller passes value SCI_FAIL or channel is invalid return last error
  code generated by any process
 */
int sci_Error(int channel)
{
  if (channel == SCI_FAIL || channel==-1)
    return (sci_Errno);
  else
    return (ChannelTable[channel].last_err);
}

/*****************************************************************************
  Called from sci_Open() the very first time open is invoked to initialise
  data areas, open various operating system resources and open a connection
  to the serial communications system.
 */
int sci_Init (void)
{
  int channel;

  sci_Errno = 0;
  sci_Locked = FALSE;
  current_channel = -1;

  /* initialise connection table */
  for (channel=0; channel<MAX_CARD_CHANNELS; channel++)
    chan_Init(channel);

  return (SCI_SUCCESS);
}

/*****************************************************************************
  Called from sci_Close() and sci_CloseTrans() to search the connection table
  for connections which are active and waiting for the transaction lock. The
  owner of each such connection is signalled to indicate that the lock is now
  free.
 */
static void sci_ReleaseLock(void)
{
  int channel;

  /* search connection table for connections waiting for lock */
  for (channel=0; channel<MAX_CARD_CHANNELS; channel++)
  {
    /* look for active slots which are waiting for the lock */
    if (ChannelTable[channel].flags & channel_in_use)
      if (ChannelTable[channel].flags & channel_wait_unlock)
      {
        /*
         * send message to waiting task note that if more than one such channel
         * for the task it will get 1 message per waiting connection
         */
        sys_SignalTask(channel,SCI_TRANS_END);
        CLEAR_FLAG(ChannelTable[channel].flags,channel_wait_unlock);
      }
  }

  return;
}
