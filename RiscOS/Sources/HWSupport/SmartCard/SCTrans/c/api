/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/
/*
 * To provide the top-level API functions.
 */

#include <stdio.h>
#include <string.h>
#include "module.h"

#include "sci_api.h"
#include "sci_int.h"

static void sci_ReleaseLock (void);
/*
 */
int
sci_Open (int msg_id, int *card_channel)
{
  int channel = -1;

  debug_printf(db,"(7) open");

  *card_channel = -1;

  if (sci_State == S_S_CMD || sci_State == S_S_USER)
    RETERR(SCI_E_SEQ);

  if (sci_State == S_S_CLOSED)
    if (sci_Init () != SCI_SUCCESS)
      RETERR(SCI_E_API);

  /*
   * get first free channel
   */
  channel = chan_GetNew();
  if (channel == -1)
    RETERR(SCI_E_TOOMANY);

  switch (sci_State)
  {
    case S_S_CLOSED:
      /* prepare for receipt of ATR */
      if (atr_Start(FALSE) != SCI_SUCCESS)
        RETERR_CHAN(channel,SCI_E_API);
      break;

    case S_S_OPENING: case S_S_REMOVED:
      sci_State = S_S_OPENING;
      break;

    case S_S_OPEN:
      /*
       * indicate slot allocated and message notification type
       */
      SET_FLAG(ChannelTable[channel].flags,channel_in_use);
      if (msg_id!=0)
        SET_FLAG(ChannelTable[channel].flags,channel_async);

      /* card already open */
      sys_SignalTask(channel,SCI_CMD_DONE);

      break;

    case S_S_STARTING: case S_S_FAILED:
      sci_Locked = FALSE;

      /* reset SCIP and prepare for receipt of ATR */
      if (atr_Start (TRUE) != SCI_SUCCESS)
        RETERR_CHAN(channel,SCI_E_COMMS);

      break;
  }

  SET_FLAG(ChannelTable[channel].flags,channel_in_use);
  if (msg_id!=0)
    SET_FLAG(ChannelTable[channel].flags,channel_async);
  ChannelTable[channel].last_err = 0;
  ChannelTable[channel].state = S_C_OPENING;

  *card_channel = channel;
  debug_printf(db,"(7) allocated channel %d\n",channel);

  if (!com_CardIn())
    RETERR_CHAN(channel,SCI_E_OUT);

  return (SCI_SUCCESS);
}

/*
 */
int
sci_RetrieveATR (int channel, BYTE * hist,
		 int hist_len, int * rcv_len)
{
  debug_printf(db,"(7) retrieve ATR on channel %d", channel);

  if (!(ChannelTable[channel].flags & channel_in_use))
    RETERR_CHAN(channel,SCI_E_INVAL);

  if (hist==NULL || rcv_len==NULL)
    RETERR_CHAN(channel,SCI_E_INVAL);

  if (sci_State == S_S_FAILED)
    return (SCI_FAIL);

  if (ChannelTable[channel].state == S_C_FAILED)
    return (SCI_FAIL);

  if (ChannelTable[channel].state != S_C_OPENING)
    RETERR_CHAN(channel,SCI_E_SEQ);

  if (sci_State != S_S_OPEN)
    RETERR(SCI_E_NODATA);

  ChannelTable[channel].state = S_C_OPEN;

  if (sci_HistLen > hist_len)
  {
    memcpy (hist, sci_HistData, hist_len);
    *rcv_len = sci_HistLen;
    RETERR(SCI_E_TRUNC);
  }
  else
  {
    memcpy (hist, sci_HistData, sci_HistLen);
    *rcv_len = sci_HistLen;
  }

  return (SCI_SUCCESS);
}

/*
 */
int
sci_Close (int channel)
{
  debug_printf(db,"(7) close channel %d", channel);

  if (!(ChannelTable[channel].flags & channel_in_use))
    RETERR_CHAN(channel,SCI_E_INVAL);

  /* if this connection is holding the lock free it */
  if (ChannelTable[channel].flags & channel_locked)
  {
    sci_Locked = FALSE;
    sci_ReleaseLock();
  }

  /* initialise slot ready for reuse */
  chan_Init(channel);

  /* reset state machine */
  sci_State = S_S_OPEN;

  return (SCI_SUCCESS);
}

/*
 */
int
sci_IssueCommand (int channel, BYTE * cmd_hdr,
		  int data_len, BYTE * data, int exp_len)
{
  int err;
  debug_printf(db,"(7) issue command (channel %d)",channel);

  if (!(ChannelTable[channel].flags & channel_in_use))
    RETERR_CHAN(channel,SCI_E_INVAL);

  if (cmd_hdr==NULL || (data==NULL && data_len>0))
    RETERR_CHAN(channel,SCI_E_INVAL);

  if (data_len > SCI_MAX_DATA_LEN || exp_len > SCI_MAX_EXP_LEN)
    RETERR_CHAN(channel,SCI_E_INVAL);

  if (sci_State == S_S_FAILED)
    return (SCI_FAIL);

  if (sci_State == S_S_REMOVED)
    RETERR_CHAN(channel,SCI_E_OUT);

  if (sci_State != S_S_OPEN)
    RETERR_CHAN(channel,SCI_E_SEQ);

  if (ChannelTable[channel].state == S_C_FAILED)
    return (SCI_FAIL);

  /* check if system locked by another connection */
  if (sci_Locked && !(ChannelTable[channel].flags & channel_locked))
    RETERR_CHAN(channel,SCI_E_TRANS);

  sci_State = S_S_CMD;

  if ((err = t0_StartCommand(cmd_hdr, data_len, data, exp_len)) != SCI_SUCCESS)
  {
    sci_State = S_S_FAILED;
    ChannelTable[channel].state = S_C_FAILED;
    RETERR_CHAN(channel,err);
  }

  return (SCI_SUCCESS);
}

/*
 */
int
sci_ReadResponse (int channel, BYTE * buff,
		  int buff_len, int * rcv_len, BYTE * resp)
{
  int err;

/*   debug_printf(db,"(7) read response (channel %d)",channel); */

  if (!(ChannelTable[channel].flags & channel_in_use))
    RETERR_CHAN(channel,SCI_E_INVAL);

  if (rcv_len == NULL)
    RETERR_CHAN(channel,SCI_E_INVAL);

  if (sci_State == S_S_REMOVED)
    RETERR_CHAN(channel,SCI_E_OUT);

  if (sci_State == S_S_FAILED)
    return (SCI_FAIL);

  if (sci_State == S_S_CMD)
    RETERR_CHAN(channel,SCI_E_NODATA);

  if (sci_State != S_S_USER)
    RETERR_CHAN(channel,SCI_E_SEQ);

  if (ChannelTable[channel].state == S_C_FAILED)
    return (SCI_FAIL);

  if (ChannelTable[channel].state != S_C_USER)
    RETERR_CHAN(channel,SCI_E_SEQ);

  if ((err = t0_GetData (buff, buff_len, rcv_len, resp)) != SCI_SUCCESS)
  {
    if (err == SCI_E_TRUNC) /* ensure we go back to correct state */
      sci_State = S_S_OPEN;

    RETERR_CHAN(channel,err);
  }
  sci_State = S_S_OPEN;

  return (SCI_SUCCESS);
}

/*
 */
int
sci_StartTrans (int channel)
{
  debug_printf(db,"(7) start trans (channel %d)",channel);

  if (!(ChannelTable[channel].flags & channel_in_use))
    RETERR_CHAN(channel,SCI_E_INVAL);

  if (sci_State == S_S_FAILED)
    /* error code should already have been set */
    return (SCI_FAIL);

  if (sci_State == S_S_REMOVED)
    RETERR_CHAN(channel,SCI_E_OUT);

  if (sci_State != S_S_OPEN)
    RETERR_CHAN(channel,SCI_E_SEQ);

  if (sci_Locked)
  {
    /* if this connection has already got lock its an error */
    if (ChannelTable[channel].flags & channel_locked)
    {
      RETERR_CHAN(channel,SCI_E_SEQ);
    }
    else
    {
      /* mark connection as waiting */
      SET_FLAG(ChannelTable[channel].flags,channel_wait_unlock);
      RETERR_CHAN(channel,SCI_E_TRANS);
    }
  }

  /* lock out all connections except this one */
  sci_Locked = TRUE;
  SET_FLAG(ChannelTable[channel].flags,channel_locked);
  CLEAR_FLAG(ChannelTable[channel].flags,channel_wait_unlock);
  current_channel = channel;

  return (SCI_SUCCESS);
}

/*
 */
int
sci_EndTrans (int channel)
{
  debug_printf(db,"(7) end trans (channel %d)",channel);

  if (!(ChannelTable[channel].flags & channel_in_use))
    RETERR_CHAN(channel,SCI_E_INVAL);

  if (sci_State == S_S_FAILED)
    /* error code should already have been set */
    return (SCI_FAIL);

  if (sci_State == S_S_REMOVED)
    RETERR_CHAN(channel,SCI_E_OUT);

  if (!sci_Locked)
    RETERR_CHAN(channel,SCI_E_SEQ);

  if (sci_State != S_S_OPEN)
    RETERR_CHAN(channel,SCI_E_SEQ);

  /* check that this connection is holding the lock */
  if (!(ChannelTable[channel].flags&channel_locked))
    RETERR_CHAN(channel,SCI_E_SEQ);

  CLEAR_FLAG(ChannelTable[channel].flags,channel_locked);
  current_channel = -1;
  sci_Locked = FALSE;

  /* signal any waiting processes */
  sci_ReleaseLock();

  return (SCI_SUCCESS);
}

/*
 * if caller passes value SCI_FAIL or channel is invalid return last error
 * code generated by any process
 */
int
sci_Error(int channel)
{
  if (channel == SCI_FAIL || channel==-1)
    return (sci_Errno);
  else
    return (ChannelTable[channel].last_err);
}

/*
 * Called from sci_Open() the very first time open is invoked to initialise
 * data areas, open various operating system resources and open a connection
 * to the serial communications system.
 */
int
sci_Init (void)
{
  int channel;

  sci_Errno = 0;
  sci_Locked = FALSE;
  current_channel = -1;

  /* initialise connection table */
  for (channel=0; channel<MAX_CARD_CHANNELS; channel++)
    chan_Init(channel);

  return (SCI_SUCCESS);
}

/*
 * Called from sci_Close() and sci_CloseTrans() to search the connection table
 * for connections which are active and waiting for the transaction lock. The
 * owner of each such connection is signalled to indicate that the lock is now
 * free.
 */
static void
sci_ReleaseLock(void)
{
  int channel;

  /* search connection table for connections waiting for lock */
  for (channel=0; channel<MAX_CARD_CHANNELS; channel++)
  {
    /* look for active slots which are waiting for the lock */
    if (ChannelTable[channel].flags & channel_in_use)
      if (ChannelTable[channel].flags & channel_wait_unlock)
      {
        /*
         * send message to waiting task note that if more than one such channel
         * for the task it will get 1 message per waiting connection
         */
        sys_SignalTask(channel,SCI_TRANS_END);
        CLEAR_FLAG(ChannelTable[channel].flags,channel_wait_unlock);
      }
  }

  return;
}
