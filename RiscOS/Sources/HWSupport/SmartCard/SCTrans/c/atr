/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/
/*
 * To provide the functions for handling card reset and processing of the
 * answer-to-reset sequence sent from the card.
 *
 * Modification History
 *---------------------
 *
 * 04-Oct-96 RWB, Removed need for atr_HandleInput, event handler now
 *                calls atr_ProcessByte directly.
 */

#include <stdio.h>

#include "sci_api.h"
#include "sci_int.h"
#include "com.h"
#include "atr.h"

atr_states_t AtrState;

static PROT_PARAMS ProtTab[MAX_PROTS];
static BYTE CurrY;
static int HistNext;
static int ProtIndex;
static int ProtCount;
static int AtrCheck;

static BOOL T0Only; /* flag to indicate card supports T=0 protocol only */
static BOOL T1Only; /* flag to indicate card supports T=1 protocol only */

static int atr_CalcWorkWaitTime (void);
static BOOL atr_SendPtss (void);

card_state_t card_status;	// storage for card parameters

#ifdef DEBUG
char *atr_state_names[] =
	{ALL_ATR_STATES(ARRAY_ENTRY)};
#endif

/***************************************************************************/
int
atr_ProcessByte (BYTE ch)
/***************************************************************************/
{
  int channel;
#ifdef DEBUG
  printf("(7) atr_ProcessByte state %s, char %02X, protocol %d\n",
  	atr_state_names[AtrState],ch,card_status.protocol);
#endif
  switch (AtrState) {
    case ATR_WAIT_TS:
      /* waiting initial byte, this does not concern API */
      /* may get padding characters, ignore and remain in initial state */
      if (ch == 0x00 || ch == 0xFF) {
	break;
      }
      card_status.TS = ch;
      AtrState = ATR_WAIT_T0;
      break;

    case ATR_WAIT_T0:
      /* waiting format character */
      // printf("(7) atr_ProcessByte(): T0\n");
      CurrY = ch & ATR_Y_MASK;
      if ((sci_HistLen = (ch & ATR_K_MASK)) > SCI_HIST_LEN) {
        return SCI_E_PROTO;
      }
      // printf("(7) atr length %d bytes\n",sci_HistLen);
      
      card_status.T0 = ch;
      HistNext = 0;
      ProtIndex = 0;
      AtrCheck = ch;
      if (card_status.protocol == 0) {
        // printf("(7) setting t0only true (1)\n");
	T0Only = TRUE;
      }

      if (CurrY) {
        ProtCount = 1;
      } else {
        ProtCount = 0;
      }

      if (CurrY & ATR_TA_MASK) {
        AtrState = ATR_WAIT_TA;
      } else if (CurrY & ATR_TB_MASK) {
        AtrState = ATR_WAIT_TB;
      } else if (CurrY & ATR_TC_MASK) {
        AtrState = ATR_WAIT_TC;
      } else if (CurrY & ATR_TD_MASK) {
        AtrState = ATR_WAIT_TD;
      } else {
        if (sci_HistLen == 0) {
	  if (T0Only) {
  	    AtrState = ATR_ENDED;
          } else {
            AtrState = ATR_WAIT_TCK;
          }
        } else {
          AtrState = ATR_WAIT_HIST;
  	}
      }
      break;

    case ATR_WAIT_TA:

      // printf("(7) atr_ProcessByte(): TA\n");
      AtrCheck ^= ch;
      ProtTab[ProtIndex].clk_rate = ch & ATR_F_MASK;
      ProtTab[ProtIndex].bit_rate = ch & ATR_D_MASK;

      switch (ProtIndex) {
	case 0 : /* TA1 */
  	  // printf("(7) atr_ProcessByte(): TA1:%02x\n", ch);
 	  card_status.TA1 = ch;
 	  break;
        case 1 : /* TA2 */
	  // printf("(7) atr_ProcessByte(): TA2:%02x\n", ch);
	  card_status.TA2 = ch;
	  break;
        case 2 : /* TA3 */
	  // printf("(7) atr_ProcessByte(): TA3:%02x\n", ch);
	  card_status.TA3 = ch;
	  card_status.IFSC = card_status.TA3;	/* update IFSC */
	  break;
      }

      if (CurrY & ATR_TB_MASK) {
        AtrState = ATR_WAIT_TB;
      } else if (CurrY & ATR_TC_MASK) {
        AtrState = ATR_WAIT_TC;
      } else if (CurrY & ATR_TD_MASK) {
        AtrState = ATR_WAIT_TD;
      } else {
        if (sci_HistLen == 0) {
          if (T0Only) {
  	    AtrState = ATR_ENDED;
  	  } else {
  	    AtrState = ATR_WAIT_TCK;
  	  }
        } else {
          AtrState = ATR_WAIT_HIST;
        }
      }
      break;

    case ATR_WAIT_TB:

      // printf("(7) atr_ProcessByte(): TB\n");
      AtrCheck ^= ch;
      ProtTab[ProtIndex].pc1 = (ch & ATR_I1_MASK) >> ATR_I1_SHIFT;
      ProtTab[ProtIndex].pc2 = ch & ATR_I2_MASK;
      
      switch (ProtIndex) {
        case 0 : 	/* TB1 */
	  // printf("(7) atr_ProcessByte(): TB1:%02x\n", ch);
	  card_status.TB1 = ch;
	  break;

        case 1 :	/* TB2 */
	  // printf("(7) atr_ProcessByte(): TB2:%02x\n", ch);
	  card_status.TB2 = ch;
	  break;

        case 2 :	/* TB3 */
	  // printf("(7) atr_ProcessByte(): TB3:%02x\n", ch);
	  card_status.TB3 = ch;
	  /* update CWT, used to use pow(2,x) */
	  //printf("(7) atr_ProcessByte(): CWI %d\n",card_status.TB3 & 0x0f);
	  //printf("(7) atr_ProcessByte(): BWI %d\n",(card_status.TB3 & 0xf0)>>4);
	  card_status.CWT = 2<<((card_status.TB3 & 0x0f)-1); 
  	  /* update BWT, used to use pow(2,x) */
 	  card_status.BWT = 
 	    (((((2<<(((card_status.TB3 & 0xf0) >>4)-1))*960))+11)*93)/10000;

  	  // printf("(7) atr_ProcessByte(): CWT:%d\n", card_status.CWT);
	  // printf("(7) atr_ProcessByte(): BWT:%d\n", card_status.BWT);
          break;
      }

      if (CurrY & ATR_TC_MASK) {
        AtrState = ATR_WAIT_TC;
      } else if (CurrY & ATR_TD_MASK) {
        AtrState = ATR_WAIT_TD;
      } else {
        if (sci_HistLen == 0) {
          if (T0Only) {
  	    AtrState = ATR_ENDED;
  	  } else {
  	    AtrState = ATR_WAIT_TCK;
  	  }
        } else {
    	  AtrState = ATR_WAIT_HIST;
    	}
      }
      break;

    case ATR_WAIT_TC:

      // printf("(7) atr_ProcessByte(): TC\n");
      AtrCheck ^= ch;
      ProtTab[ProtIndex].extra_time = ch;
      
      switch (ProtIndex) {
      	case 0 :	/* TC1 */
	  // printf("(7) atr_ProcessByte(): TC1:%02x\n", ch);
	  card_status.TC1 = ch;
	  card_status.N = card_status.TC1;
	  break;
      
        case 1 :	/* TC2 */
	  // printf("(7) atr_ProcessByte(): TC2:%02x\n", ch);
	  card_status.TC2 = ch;
	  card_status.WI = card_status.TC2;
	  break;
      }
      
      if (CurrY & ATR_TD_MASK) {
        AtrState = ATR_WAIT_TD;
      } else {
        if (sci_HistLen == 0) {
  	  if (T0Only) {
   	    AtrState = ATR_ENDED;
   	  } else {
   	    AtrState = ATR_WAIT_TCK;
   	  }
   	} else {
   	  AtrState = ATR_WAIT_HIST;
   	}
      }

      break;

    case ATR_WAIT_TD:

      // printf("(7) atr_ProcessByte(): TD\n");
      AtrCheck ^= ch;
      CurrY = ch & ATR_Y_MASK;
      ProtTab[ProtIndex].type = ch & ATR_T_MASK;
      
      switch (ProtIndex) {
        case 0 : 	/* TD1 */
	  // printf("(7) atr_ProcessByte(): TD1:%02x\n", ch);
	  card_status.TD1 = ch;

	  if ((card_status.TD1 & 0x0F) == 1) {
	    card_status.protocol = 1;	/* update current protocol */
	  }
	  break;
	case 1 :	/* TD2 */
	  // printf("(7) atr_ProcessByte(): TD2:%02x\n", ch);
	  card_status.TD2 = ch;

	  if ((card_status.TD2 & 0x0F) == 1) {
	    /*  Optional protocol, need to do PTS */
	    card_status.optional_protocol = 1;	
	  }
	  
	  //printf("(7) Card Optional protocol: %d\n", card_status.optional_protocol);
	  break;
      }
      
      if ((ch & ATR_T_MASK) != T0_TYPE) {
        // printf("(7) setting t0only false (1)\n");
        T0Only = FALSE;
      }

      if (CurrY != 0) {
        ProtIndex++;
        ProtCount++;
        if (CurrY & ATR_TA_MASK) {
   	  AtrState = ATR_WAIT_TA;
        } else if (CurrY & ATR_TB_MASK) {
  	  AtrState = ATR_WAIT_TB;
        } else if (CurrY & ATR_TC_MASK) {
  	  AtrState = ATR_WAIT_TC;
        } else {
  	  AtrState = ATR_WAIT_TD;
  	}
      } else {
        if (sci_HistLen == 0) {
	  if (T0Only) {
  	    AtrState = ATR_ENDED;
          } else {
            AtrState = ATR_WAIT_TCK;
          }
        } else {
          AtrState = ATR_WAIT_HIST;
        }
      }
      break;

    case ATR_WAIT_HIST:

      // printf("(7) atr_ProcessByte(): HIST %d\n",HistNext);
      AtrCheck ^= ch;

      sci_HistData[HistNext++] = ch;
      if (HistNext == sci_HistLen) {
        if (T0Only) {
          // printf("(7) setting ATR_ENDED\n");
  	  AtrState = ATR_ENDED;
  	} else {
          // printf("(7) setting ATR_WAIT_TCK\n");
  	  AtrState = ATR_WAIT_TCK;
  	}
      }
      break;

    case ATR_WAIT_TCK:

      // printf("(7) atr_ProcessByte(): TCK\n");
      AtrCheck ^= ch;
      if (AtrCheck != 0) {
        return SCI_E_PROTO;
      }
      AtrState = ATR_ENDED;

      break;

    case ATR_WAIT_PTS_ACK:

      // printf("(7) atr_ProcessByte(): PTS ACK\n");

      if (ch != PTS_ACK) {
        return SCI_E_PROTO;
      }
      AtrState = ATR_WAIT_PROT_ECHO;
      break;

    case ATR_WAIT_PROT_ECHO:

      // printf("(7) atr_ProcessByte(): protocol echo\n");

      if (ch != T1_TYPE) {  /* was T0_TYPE only */
        return SCI_E_PROTO;
      }
      AtrState = ATR_WAIT_PROT_ACK;
      break;

    case ATR_WAIT_PROT_ACK:

      // printf("(7) atr_ProcessByte(): protocol ack\n");

      if (ch != PTS_ACK_T1) {  /* was PTS_ACK */
        return SCI_E_PROTO;
      }
      card_status.protocol = 1;

      AtrState = ATR_PTS_ENDED;

      break;

    case ATR_ENDED:
      // printf("(7) atr_ProcessByte(): ATR_ENDED\n");
    case ATR_PTS_ENDED:

      // printf("(7) atr_ProcessByte(): SCI_E_PROTO\n");

      return SCI_E_PROTO;
      /* break; */
  }

  if (AtrState != ATR_ENDED && AtrState != ATR_PTS_ENDED) {
    return SCI_SUCCESS;
  }

  if (AtrState == ATR_ENDED) {
    /* determine if protocol selection required */
    if (!atr_SendPtss ())
      return SCI_E_COMMS;
  }

  if (AtrState != ATR_PTS_ENDED)
    return SCI_SUCCESS;

  /* ATR received in full successfully */
  sci_State = S_S_OPEN;
#if FUNAI_TWINSLOT
//  printf("ATR successfully handled. Card_status at &%08X\n",(int)&card_status);
  com_SendAck();
  g_uc_state = UC_IDLE;

  if(g_card2_insertpending)
  {
//    printf("Dealing with Slot2 pending");
    sys_Delay(100);
//    printf("...\n");
    com_ProcessCardInserted(SLOT_2);
    /** Note, we've not told anyone about slot1 insertion yet. **/
    /** They get told once we've finished messing with slot2   **/
  }
  else
  {
#endif
//  printf("(7) ATR success, signalling apps\n");
    for (channel=0; channel<MAX_CARD_CHANNELS; channel++) {
      if (ChannelTable[channel].flags & channel_in_use) {
        if (ChannelTable[channel].state == S_C_OPENING) {
          sys_SignalTask(channel,SCI_CMD_DONE);
        }
      }
    }
#if FUNAI_TWINSLOT
  }
#endif
  WorkWaitTime = atr_CalcWorkWaitTime ();

  return (SCI_SUCCESS);
}

/**************************************************************************/
static BOOL
atr_SendPtss (void)
/*
   This function
   1. determines if it necessary to perform protocol selection
   2. generates protocol selection block
   3. sends protocol selection block
   4. sets next state
   Returns TRUE if everything OK, FALSE if comms error sending PTSS.
   It does not return any indication as to whether PTSS was necessary.
 */
{
  int i=0;
  BYTE ptss[PTSS_LEN];

  // printf("(7) atr_SendPtss()\n");
  
  if (((card_status.TD1 & 0x0F) == 0) && ((card_status.TD2 & 0x0F) == 1)) {
    
    // printf("(7) atr_SendPtss(): Requesting T=1 Protocol\n");

    ptss[i++] = PTS_PTSS;
    ptss[i++] = PTS_DEF_PTS1;
    ptss[i++] = PTS_ACK_T1;

    if (com_SendBytes(ptss, i) != SCI_SUCCESS) {
      return FALSE;
    } else {
      AtrState = ATR_WAIT_PTS_ACK;
      return TRUE;
    }
  }
  if (card_status.protocol == 0) {
    // printf("(7) setting t0only true (2)\n");
    T0Only = TRUE;
    AtrState = ATR_PTS_ENDED;
    return TRUE;
  }
  if (card_status.protocol == 1) {
    T1Only = TRUE;
    AtrState = ATR_PTS_ENDED;
    return TRUE;
  }

  return TRUE;
}

/**************************************************************************/
int
atr_Start (BOOL reset)
{
  /* if card out do nothing, wait for card in and then do the reset */

  // printf("(7) ATR Start (%s)\n",reset?"reset":"no reset");
  if (com_CardIn()) {
    if (reset) {
      com_FlushComms ();
      sys_DiscardEvents ();

      if (com_SetResetInd () != SCI_SUCCESS) {
	return atr_Error (SCI_E_COMMS);
      }

      /*
       * waiting for ATR so set wait time
       */
      sys_StartWaitTimer (ATR_INIT_WAIT);
    }
  }

  AtrState = ATR_WAIT_TS;
  sci_State = S_S_OPENING;
  card_status.protocol = 0;
  card_status.optional_protocol = 0;
  
  return SCI_SUCCESS;
}

/**************************************************************************/
int
atr_Error (int err)
{
  int channel;

  debug_printf (db,"(7) ATR error\n");

  /* remember current connection slot */
  /* error condition so signal users and close everything */
  for (channel=0; channel<MAX_CARD_CHANNELS; channel++) {
    if (ChannelTable[channel].flags & channel_in_use) {
      ChannelTable[channel].state = S_C_FAILED;
      ChannelTable[channel].last_err = err;
      sys_SignalTask(channel,SCI_ERROR);
    }
  }
  /* restore current connection slot */
  com_FlushComms ();

  sci_State = S_S_FAILED;
  sci_Errno = err;

  return (SCI_FAIL);
}

/**************************************************************************/
static int
atr_CalcWorkWaitTime (void)
{
  int wi;

  /* analyse protocol parameters */
  if (ProtCount < 2) {
    /* can't be a TC2 byte */
    wi = ATR_DEFAULT_WI;
  } else {
    if (ProtTab[0].type == ProtTab[1].type) {
      /* protocol with additional parameters */
      wi = ProtTab[1].extra_time;
    } else {
      wi = ATR_DEFAULT_WI;
    }
  }

  return wi * MS_PER_SEC / 100;	/* centi-seconds */
}
