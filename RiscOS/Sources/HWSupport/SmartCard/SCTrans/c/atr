/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/
/*
 * To provide the functions for handling card reset and processing of the
 * answer-to-reset sequence sent from the card.
 *
 * Modification History
 *---------------------
 *
 * 04-Oct-96 RWB, Removed need for atr_HandleInput, event handler now
 *                calls atr_ProcessByte directly.
 */

#include <stdio.h>

#include "sci_api.h"
#include "sci_int.h"
#include "com.h"
#include "atr.h"

atr_states_t AtrState;

static PROT_PARAMS ProtTab[MAX_PROTS];
static BYTE CurrY;
static int HistNext;
static int ProtIndex;
static int ProtCount;
static int AtrCheck;

static BOOL T0Only; /* flag to indicate card supports T=0 protocol only */
static BOOL T1Only; /* flag to indicate card supports T=1 protocol only */

static int atr_CalcWorkWaitTime (void);
static BOOL atr_SendPtss (void);

card_state_t card_status;	// storage for card parameters

#ifdef DEBUG
char *atr_state_names[] =
	{ALL_ATR_STATES(ARRAY_ENTRY)};
#endif

/*****************************************************************************/
int atr_ProcessByte (BYTE ch)
{
  int channel;

  switch (AtrState)
  {
    case ATR_WAIT_TS:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:WAIT_TS: [%x][%d]", ch, ch);
#endif
      /* waiting initial byte, this does not concern API */
      /* may get padding characters, ignore and remain in initial state */
      if (ch == 0x00 || ch == 0xFF)
	break;
      card_status.TS = ch;
      AtrState = ATR_WAIT_T0;
      break;

    case ATR_WAIT_T0:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:WAIT_T0: [%x][%d]", ch, ch);
#endif
      /* waiting format character */
      CurrY = ch & ATR_Y_MASK;
      if ((sci_HistLen = (ch & ATR_K_MASK)) > SCI_HIST_LEN) {
        return SCI_E_PROTO;
      }
      card_status.T0 = ch;
      HistNext = 0;
      ProtIndex = 0;
      AtrCheck = ch;
      if (card_status.protocol == 0)
      {
#ifdef REMOTE_DEBUG
        debug_printf(db,"- atr:PROT T0only=TRUE\n");
#endif
	T0Only = TRUE;
      }

      if (CurrY)
      {
        ProtCount = 1;
      }
      else
      {
        ProtCount = 0;
      }

      if (CurrY & ATR_TA_MASK) {
        AtrState = ATR_WAIT_TA;
      } else if (CurrY & ATR_TB_MASK) {
        AtrState = ATR_WAIT_TB;
      } else if (CurrY & ATR_TC_MASK) {
        AtrState = ATR_WAIT_TC;
      } else if (CurrY & ATR_TD_MASK) {
        AtrState = ATR_WAIT_TD;
      } else {
        if (sci_HistLen == 0) {
	  if (T0Only) {
  	    AtrState = ATR_ENDED;
          } else {
            AtrState = ATR_WAIT_TCK;
          }
        } else {
          AtrState = ATR_WAIT_HIST;
  	}
      }
      break;

    case ATR_WAIT_TA:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:WAIT_TA: [%x][%d]", ch, ch);
#endif
      AtrCheck ^= ch;
      ProtTab[ProtIndex].clk_rate = ch & ATR_F_MASK;
      ProtTab[ProtIndex].bit_rate = ch & ATR_D_MASK;

      switch (ProtIndex)
      {
	case 0 : /* TA1 */
#ifdef REMOTE_DEBUG
          debug_printf(db,"- atr:WAIT_TA1 [%x][%d]", ch, ch);
#endif
 	  card_status.TA1 = ch;
 	  break;

        case 1 : /* TA2 */
#ifdef REMOTE_DEBUG
          debug_printf(db,"- atr:WAIT_TA2 [%x][%d]", ch, ch);
#endif
	  card_status.TA2 = ch;
	  break;

        case 2 : /* TA3 */
#ifdef REMOTE_DEBUG
          debug_printf(db,"- atr:WAIT_TA3 [%x][%d]", ch, ch);
#endif
	  card_status.TA3 = ch;
	  card_status.IFSC = card_status.TA3;	/* update IFSC */
	  break;
      }

      if (CurrY & ATR_TB_MASK) {
        AtrState = ATR_WAIT_TB;
      } else if (CurrY & ATR_TC_MASK) {
        AtrState = ATR_WAIT_TC;
      } else if (CurrY & ATR_TD_MASK) {
        AtrState = ATR_WAIT_TD;
      } else {
        if (sci_HistLen == 0) {
          if (T0Only) {
  	    AtrState = ATR_ENDED;
  	  } else {
  	    AtrState = ATR_WAIT_TCK;
  	  }
        } else {
          AtrState = ATR_WAIT_HIST;
        }
      }
      break;

    case ATR_WAIT_TB:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:WAIT_TB: [%x][%d]", ch, ch);
#endif
      AtrCheck ^= ch;
      ProtTab[ProtIndex].pc1 = (ch & ATR_I1_MASK) >> ATR_I1_SHIFT;
      ProtTab[ProtIndex].pc2 = ch & ATR_I2_MASK;

      switch (ProtIndex)
      {
        case 0 : 	/* TB1 */
#ifdef REMOTE_DEBUG
          debug_printf(db,"- atr:WAIT_TB1 [%x][%d]", ch, ch);
#endif
	  card_status.TB1 = ch;
	  break;

        case 1 :	/* TB2 */
#ifdef REMOTE_DEBUG
          debug_printf(db,"- atr:WAIT_TB2 [%x][%d]", ch, ch);
#endif
	  card_status.TB2 = ch;
	  break;

        case 2 :	/* TB3 */
#ifdef REMOTE_DEBUG
          debug_printf(db,"- atr:WAIT_TB3 [%x][%d]", ch, ch);
#endif
	  card_status.TB3 = ch;
	  /* update CWT, used to use pow(2,x) */
	  card_status.CWT = 2<<((card_status.TB3 & 0x0f)-1);
  	  /* update BWT, used to use pow(2,x) */
 	  card_status.BWT =
 	    (((((2<<(((card_status.TB3 & 0xf0) >>4)-1))*960))+11)*93)/10000;
#ifdef REMOTE_DEBUG
          debug_printf(db,"BWT: [%d]", card_status.BWT);
#endif
          break;
      }
      if (CurrY & ATR_TC_MASK)
      {
        AtrState = ATR_WAIT_TC;
      }
      else
      {
        if (CurrY & ATR_TD_MASK)
        {
        AtrState = ATR_WAIT_TD;
        }
        else
        {
          if (sci_HistLen == 0)
          {
            if (T0Only)
            {
              AtrState = ATR_ENDED;
  	    }
            else
            {
  	      AtrState = ATR_WAIT_TCK;
  	    }
          }
          else
          {
    	    AtrState = ATR_WAIT_HIST;
    	  }
        }
      }
      break;

    case ATR_WAIT_TC:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:WAIT_TC: [%x][%d]", ch, ch);
#endif
      AtrCheck ^= ch;
      ProtTab[ProtIndex].extra_time = ch;

      switch (ProtIndex)
      {
      	case 0 :	/* TC1 */
#ifdef REMOTE_DEBUG
          debug_printf(db,"- atr:WAIT_TC1 [%x][%d]", ch, ch);
#endif
	  card_status.TC1 = ch;
	  card_status.N = card_status.TC1;
	  break;

        case 1 :	/* TC2 */
#ifdef REMOTE_DEBUG
          debug_printf(db,"- atr:WAIT_TC2 [%x][%d]", ch, ch);
#endif
	  card_status.TC2 = ch;
	  card_status.WI = card_status.TC2;
	  break;
      }

      if (CurrY & ATR_TD_MASK) {
        AtrState = ATR_WAIT_TD;
      } else {
        if (sci_HistLen == 0) {
  	  if (T0Only) {
   	    AtrState = ATR_ENDED;
   	  } else {
   	    AtrState = ATR_WAIT_TCK;
   	  }
   	} else {
   	  AtrState = ATR_WAIT_HIST;
   	}
      }
      break;

    case ATR_WAIT_TD:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:WAIT_TD: [%x][%d]", ch, ch);
#endif
      AtrCheck ^= ch;
      CurrY = ch & ATR_Y_MASK;
      ProtTab[ProtIndex].type = ch & ATR_T_MASK;

      switch (ProtIndex)
      {
        case 0 : 	/* TD1 */
#ifdef REMOTE_DEBUG
          debug_printf(db,"- atr:WAIT_TD1 [%x][%d]", ch, ch);
#endif
	  card_status.TD1 = ch;

	  if ((card_status.TD1 & 0x0F) == 1) {
	    card_status.protocol = 1;	/* update current protocol */
	  }
	  break;

	case 1 :	/* TD2 */
#ifdef REMOTE_DEBUG
          debug_printf(db,"- atr:WAIT_TD2 [%x][%d]", ch, ch);
#endif
	  card_status.TD2 = ch;

	  if ((card_status.TD2 & 0x0F) == 1) {
	    /*  Optional protocol, need to do PTS */
	    card_status.optional_protocol = 1;
	  }
	  break;
      }

      if ((ch & ATR_T_MASK) != T0_TYPE)
      {
#ifdef REMOTE_DEBUG
        debug_printf(db,"- atr:PROT T0only=FALSE\n");
#endif
        T0Only = FALSE;
      }

      if (CurrY != 0) {
        ProtIndex++;
        ProtCount++;
        if (CurrY & ATR_TA_MASK) {
   	  AtrState = ATR_WAIT_TA;
        } else if (CurrY & ATR_TB_MASK) {
  	  AtrState = ATR_WAIT_TB;
        } else if (CurrY & ATR_TC_MASK) {
  	  AtrState = ATR_WAIT_TC;
        } else {
  	  AtrState = ATR_WAIT_TD;
  	}
      } else {
        if (sci_HistLen == 0) {
  	  AtrState = ATR_ENDED;
        } else {
          AtrState = ATR_WAIT_HIST;
        }
      }
      break;

    case ATR_WAIT_HIST:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:WAIT_HIST: [%x][%d]", ch, ch);
#endif
      AtrCheck ^= ch;

      sci_HistData[HistNext++] = ch;
      if (HistNext == sci_HistLen) {
        if (T0Only) {
  	  AtrState = ATR_ENDED;
  	} else {
  	  AtrState = ATR_WAIT_TCK;
  	}
      }
      break;

    case ATR_WAIT_TCK:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:WAIT_TCK: [%x][%d]", ch, ch);
#endif
      AtrCheck ^= ch;
      if (AtrCheck != 0) {
        return SCI_E_PROTO;
      }
      AtrState = ATR_ENDED;
#ifdef REMOTE_DEBUG
      debug_printf(db,"Workwait time: [%d]\n", WorkWaitTime);
#endif
      break;

    case ATR_WAIT_PTS_ACK:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:WAIT_PTS_ACK: [%x][%d]", ch, ch);
#endif
      if (ch != PTS_ACK) {
        return SCI_E_PROTO;
      }
      AtrState = ATR_WAIT_PROT_ECHO;
      break;

    case ATR_WAIT_PROT_ECHO:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:WAIT_PROT_ECHO: [%x][%d]", ch, ch);
#endif
      if (ch != T1_TYPE) {  /* was T0_TYPE only */
        return SCI_E_PROTO;
      }
      AtrState = ATR_WAIT_PROT_ACK;
      break;

    case ATR_WAIT_PROT_ACK:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:WAIT_PROT_ACK: [%x][%d]", ch, ch);
#endif
      if (ch != PTS_ACK_T1) {  /* was PTS_ACK */
        return SCI_E_PROTO;
      }
      card_status.protocol = 1;
      AtrState = ATR_PTS_ENDED;
      break;

    case ATR_ENDED:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:ATR_ENDED: [%x][%d]", ch, ch);
#endif
      return SCI_E_PROTO;

    case ATR_PTS_ENDED:
#ifdef REMOTE_DEBUG
      debug_printf(db,"- atr:ATR_PTS_ENDED: [%x][%d]", ch, ch);
#endif
      return SCI_E_PROTO;
      /* break; */
  }

  if (AtrState != ATR_ENDED && AtrState != ATR_PTS_ENDED)
  {
    return SCI_SUCCESS;
  }

  if (AtrState == ATR_ENDED)
  {
    /* determine if protocol selection required */
    if (!atr_SendPtss ())
      return SCI_E_COMMS;
  }

  if (AtrState != ATR_PTS_ENDED)
    return SCI_SUCCESS;

  /* ATR received in full successfully */
  sci_State = S_S_OPEN;
  for (channel=0; channel<MAX_CARD_CHANNELS; channel++) {
    if (ChannelTable[channel].flags & channel_in_use) {
      if (ChannelTable[channel].state == S_C_OPENING) {
        sys_SignalTask(channel,SCI_CMD_DONE);
      }
    }
  }

  WorkWaitTime = atr_CalcWorkWaitTime ();
  return (SCI_SUCCESS);
}

/*****************************************************************************
   This function
   1. determines if it necessary to perform protocol selection
   2. generates protocol selection block
   3. sends protocol selection block
   4. sets next state
   Returns TRUE if everything OK, FALSE if comms error sending PTSS.
   It does not return any indication as to whether PTSS was necessary.
 */
static BOOL atr_SendPtss (void)
{
  int i=0;
  BYTE ptss[PTSS_LEN];

  if (((card_status.TD1 & 0x0F) == 0) && ((card_status.TD2 & 0x0F) == 1))
  {
    ptss[i++] = PTS_PTSS;
    ptss[i++] = PTS_DEF_PTS1;
    ptss[i++] = PTS_ACK_T1;

    if (com_SendBytes(ptss, i) != SCI_SUCCESS) {
      return FALSE;
    } else {
      AtrState = ATR_WAIT_PTS_ACK;
      return TRUE;
    }
  }
  if (card_status.protocol == 0)
  {
#ifdef REMOTE_DEBUG
    debug_printf(db,"atr_SendPtss: T0only=TRUE\n");
#endif
    T0Only = TRUE;
    AtrState = ATR_PTS_ENDED;
    return TRUE;
  }
  if (card_status.protocol == 1)
  {
    T1Only = TRUE;
    AtrState = ATR_PTS_ENDED;
    return TRUE;
  }

  return TRUE;
}

/*****************************************************************************/
int atr_Start (BOOL reset)
{
  /* if card out do nothing, wait for card in and then do the reset */

  if (com_CardIn()) {
    if (reset) {
      com_FlushComms ();
      sys_DiscardEvents ();

      if (com_SetResetInd () != SCI_SUCCESS) {
	return atr_Error (SCI_E_COMMS);
      }

      /*
       * waiting for ATR so set wait time
       */
      sys_StartWaitTimer (ATR_INIT_WAIT);
    }
  }

  AtrState = ATR_WAIT_TS;
  sci_State = S_S_OPENING;
  card_status.protocol = 0;
  card_status.optional_protocol = 0;

  return SCI_SUCCESS;
}

/*****************************************************************************/
int atr_Error (int err)
{
  int channel;

#ifdef REMOTE_DEBUG
  debug_printf (db,"PROC * atr_Error");
#endif

  /* remember current connection slot */
  /* error condition so signal users and close everything */
  for (channel=0; channel<MAX_CARD_CHANNELS; channel++) {
    if (ChannelTable[channel].flags & channel_in_use) {
      ChannelTable[channel].state = S_C_FAILED;
      ChannelTable[channel].last_err = err;
      sys_SignalTask(channel,SCI_ERROR);
    }
  }
  /* restore current connection slot */
  com_FlushComms ();

  sci_State = S_S_FAILED;
  sci_Errno = err;

  return (SCI_FAIL);
}

/*****************************************************************************/
static int atr_CalcWorkWaitTime (void)
{
  int wi;

  /* analyse protocol parameters */
  if (ProtCount < 2)
  {
    /* can't be a TC2 byte */
    wi = ATR_DEFAULT_WI;
  }
  else
  {
    if (ProtTab[0].type == ProtTab[1].type)
    {
      /* protocol with additional parameters */
      wi = ProtTab[1].extra_time;
    }
    else
    {
      wi = ATR_DEFAULT_WI;
    }
  }
  return wi * MS_PER_SEC / 100;	/* centi-seconds */
}
