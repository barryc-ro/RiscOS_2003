/*-------------------------------------------------------------------------

 File: T1.c

 Purpose:
	To implement those functions which handle the smart card protocol
	T=1.

---------------------------------------------------------------------------

	Written by Applied Card Technologies
	Copyright (c) 1997 Applied Card Technologies All Rights Reserved.

-------------------------------------------------------------------------*/

#ifdef _WINDOWS
#include <windows.h>
#endif
#include <stdio.h>
#include <string.h>
#include "sci_api.h"
#include "sci_int.h"
#include "atr.h"
#include "t1.h"
#include "com.h"

// structures
T1_PCKT Command;
T1_PCKT RXPckt;
T1_RESPDATA Resp;

/* state control variables */
int t1_State;
int TX_SeqNo[3];	// global transmit sequence number variable
int Exp_SeqNo;

static int RXCNT;

static int BUFFERSIZE = 104;	// 104 bytes 

// variables

static int LRC_Len;		// make this a global variable 

static int IFSC;		// global variable for updated IFSC value

static int Retry;		// global variable for retry

int IFS_Count = 0;		// initialise counter

int Alldata;

// flags
BOOL F_IFSC_Updated = FALSE;	// set IFSC_Updated flag to false as default

int SendIBlock(void);
int SendRBlock(int seq_no, BYTE type);

/**************************************************************************/
int 
t1_ProcessByte(BYTE ch)
{
  BYTE Xor_Result;
  int err;

  //printf("Entering t1_ReadResponse()\n");

  switch (t1_State) {

    case T1_NAD:
      RXPckt.NAD = ch;		// store the rec'd NAD byte
      t1_State = T1_PCB;	// update t1_State        
      RXCNT = 0;		// reset counter
      //printf("t1_ReadResponse(), NAD: %02x\n", RXPckt.NAD);
      break;

    case T1_PCB:
      RXPckt.PCB = ch;		// store the rec'd PCB byte
      t1_State = T1_LEN;	// update t1_State       
      //printf("t1_ReadResponse(), PCB: %02x\n", RXPckt.PCB);
      break;

    case T1_LEN:
      RXPckt.LEN = ch;		// store the rec'd LEN byte
      if (RXPckt.LEN) {
        t1_State = T1_DATA;	// update t1_State
      } else {
        t1_State = T1_LRC;	// update t1_State      
      }
      //printf("t1_ReadResponse(), LEN: %02x\n", RXPckt.LEN);
      break;

    case T1_DATA:
      /* tag the data on the end of the buffer */
      RXPckt.DATA[RXCNT + RXPckt.data_start] = ch;
      //printf("t1_ReadResponse(), Data Byte:%02d = %02x\n", (RXCNT + RXPckt.data_start), RXPckt.DATA[RXCNT + RXPckt.data_start]);
      RXCNT++;
      if (RXCNT == RXPckt.LEN) {
        t1_State = T1_LRC;
      }
      break;

    case T1_LRC:
      RXPckt.TCK = ch;		// store the rec'd LRC byte
      t1_State = T1_END;	// block now complete 
      //printf("t1_ReadResponse(), TCK: %02x\n", RXPckt.TCK);
      break;

    case T1_END:
      /* data remaining to be processed but block is complete -  error
       * generate and send error block set state control variables 
       * to expect new I_block 
       */
      return SCI_ERROR;	/* for now */
  }

  if (t1_State != T1_END) {
    /* finished processing buffer but block not complete so
       return and wait for next comms chunk */
    // printf("t1_ReadResponse(), Waiting for more data");
    return SCI_SUCCESS;
  }
  Xor_Result = t1_Check(&RXPckt);	// calculate checksum  

  if (Xor_Result == RXPckt.TCK)	{ // rec'd checksum = calculated checksum?
    //printf("t1_ReadResponse(), Received block correctly\n");
    RXPckt.total_len += RXPckt.LEN;
    RXPckt.data_start += RXPckt.LEN;
    t1_DecodeBlk();		// equal (ie: valid blk rec'd) so decode blk
  } else {			// not equal so construct and send an R-Blk
     //printf("t1_ReadResponse(), Received block, check sum error\n");

    Command.NAD = 0;
    if (Exp_SeqNo == 0) {	// expected sequence number can only be 0 or 1
      Command.PCB = 81;		// PCB - Exp_SeqNo = 0, EDC error
    } else {
      Command.PCB = 91;		// PCB - Exp_SeqNo = 1, EDC error
    }

    Command.LEN = 0;
    LRC_Len = 3;		// NAD,PCB and LEN (no data bytes)
    Xor_Result = t1_Check(&Command);	// go and calculate the checksum 
    Command.TCK = Xor_Result;	// insert the result at the end of the block
    err = SendBlk(&Command);
    
    return err;
  }
  
  return SCI_SUCCESS;
}

/**************************************************************************/
int
t1_StartCommand(int slot, BYTE * cmd_hdr,
		int data_len, BYTE * data, int exp_len, int t1_extended)
{
  static int XportType;
  int i, j;

  // printf("Entering t1_StartCommand()\n");

//  com_FlushComms();		/* clear comms buffers */

  Retry = 0;			// initialise the retry counter 

  Command.slot = slot;
  /* set variables to handle sending I-block(s) */
  Command.len_sent = 0;
  Command.data_start = 0;

  /* set variables to handle reception of following I-block(s) */
  RXPckt.total_len = 0;
  RXPckt.len_sent = 0;
  RXPckt.data_start = 0;

  // determine transport type - case 1, 2, 3 or 4
  // Check for LC=0 (data_len) AND LE=0 (exp_len)   
  if(t1_extended == FALSE)
  {
    if (data_len) {
      if (exp_len) {
        XportType = T1_CASE4;	// Header, Lc, Data, Le
      } else {
        XportType = T1_CASE3;	// Header, Lc, Data
      }
    } else {
      if (exp_len) {
        XportType = T1_CASE2;	// Header, Le 
      } else {
        XportType = T1_CASE1;	// Header
      }
    }
  }
  else /* Extended apdu format */
  {
    if (data_len) {
      if (exp_len) {
        XportType = T1_CASE7;	// Header, Lcx2, Data, Lex2
      } else {
        XportType = T1_CASE6;	// Header, Lcx2, Data
      }
    } else {
      if (exp_len) {
        XportType = T1_CASE5;	// Header, Lex2 
      } else {
        XportType = T1_CASE1;	// Header
      }
    }
  }    

//  printf("XportType = %d\n",XportType);
  exp_len = exp_len & 0xffff; /* Ditch the topbit */

  Command.DATA[0] = *cmd_hdr++;
  Command.DATA[1] = *cmd_hdr++;
  Command.DATA[2] = *cmd_hdr++;
  Command.DATA[3] = *cmd_hdr++;

  switch (XportType) {
    case T1_CASE1:
      Command.total_len = 4;
      break;

    case T1_CASE2:
      Command.total_len = 5;
      Command.DATA[4] = exp_len;
      break;

    case T1_CASE3:
      Command.total_len = 5 + data_len;
      Command.DATA[4] = data_len;

/*      printf("Class: %2x Ins: %2x P1: %2x P2: %2x\n", 
      			Command.DATA[0], Command.DATA[1], 
      			Command.DATA[2], Command.DATA[3]);
*/
      for (i = 5, j = 0; j < data_len; i++, j++) {
	Command.DATA[i] = data[j];
      }
      break;

    case T1_CASE4:
      Command.total_len = 6 + data_len;
      Command.DATA[4] = data_len;

/*      printf("Class: %2x Ins: %2x P1: %2x P2: %2x\n",
		   Command.DATA[0], Command.DATA[1],
		   Command.DATA[2], Command.DATA[3]);
*/
      for (i = 5, j = 0; j < data_len; i++, j++) {
	Command.DATA[i] = data[j];
      }
      Command.DATA[i] = exp_len;
      break;

    case T1_CASE5:
      Command.total_len = 7;
      Command.DATA[4] = 0; /* Indicates extended Le */
      Command.DATA[5] = (exp_len & 0xff00)>>8; /* hibyte */
      Command.DATA[6] = exp_len & 0xff;        /* lobyte */
      break;

    case T1_CASE6:
      Command.total_len = 7 + data_len;
      Command.DATA[4] = 0; /* Indicates extended Lc */
      Command.DATA[5] = (data_len & 0xff00)>>8; /* hibyte */
      Command.DATA[6] = data_len & 0xff;        /* lobyte */

/*      printf("Class: %2x Ins: %2x P1: %2x P2: %2x\n", 
      			Command.DATA[0], Command.DATA[1], 
      			Command.DATA[2], Command.DATA[3]);
*/
      for (i = 7, j = 0; j < data_len; i++, j++) {
	Command.DATA[i] = data[j];
      }
      break;

    case T1_CASE7:
      Command.total_len = 9 + data_len;
      Command.DATA[4] = 0; /* Indicates extended Lc and Le */
      Command.DATA[5] = (data_len & 0xff00)>>8; /* hibyte */
      Command.DATA[6] = data_len & 0xff;        /* lobyte */
      
/*      printf("Class: %2x Ins: %2x P1: %2x P2: %2x\n",
		   Command.DATA[0], Command.DATA[1],
		   Command.DATA[2], Command.DATA[3]);
*/
      for (i = 7, j = 0; j < data_len; i++, j++) {
	Command.DATA[i] = data[j];
      }
      Command.DATA[i] = (exp_len & 0xff00)>>8;
      Command.DATA[i+1] = exp_len & 0xff;
      break;
  }
  // Compare IFSC with Command.LEN for chaining purposes
  if (F_IFSC_Updated == TRUE) {	// Check if IFSC has been updated
    card_status.IFSC = IFSC;	// set IFSC to new value 
    // ** set F_IFSC_Updated flag back to FALSE?? **   
  }

  return SendIBlock();
}

/**************************************************************************/
int 
SendIBlock(void)
{
  int len;
  int err;

  // printf("Entering SendIBlock()\n");

  Command.NAD = 0x10;		// NAD will always be 0 
  Command.PCB = 0x00;

  len = Command.total_len - Command.len_sent;

  if (len > card_status.IFSC) {	// chaining
    Command.chaining = TRUE;	// set chaining flag to true
    Command.LEN = card_status.IFSC;	// set the length to maximum possible
    Command.PCB |= 0x20;
  } else {
    Command.LEN = len;		// set the length to maximum possible
    Command.chaining = FALSE;	// set chaining flag to false
  }
  
  //printf("SendIBlock(slot=%d): total_len:%d  len_sent:%d Len: %d TXSeq=%d\n", Command.slot, Command.total_len, Command.len_sent, Command.LEN,TX_SeqNo[Command.slot]);
  if (TX_SeqNo[Command.slot] != 0) {
    Command.PCB |= 0x40;	// TX_SeqNo = 1 
  }

  Command.TCK = t1_Check(&Command);	// go and calculate the checksum 

  TX_SeqNo[Command.slot] = Binary_Increment(TX_SeqNo[Command.slot]);

  // DS: RXCNT = 0;                                                                       
  //DS: t1_State = T1_NAD;                                                                        // initialise the t1_State 

  err = SendBlk(&Command);	// transmit Blk    

  // printf("Exiting SendIBlock(), returning %d\n", err);

  return err;
}

/**************************************************************************/
int 
Chaining_Sequence(int datalength)
{
  BYTE Xor_Result;
  int err;

  if (Alldata > card_status.IFSC) {
    Command.LEN = card_status.IFSC; // NOTE: Command.chaining remains TRUE here 

    Alldata = Alldata - Command.LEN;
    if (TX_SeqNo[Command.slot] == 0) {
      Command.PCB = 0x20;		// TX_SeqNo = 0   
    } else {
      Command.PCB = 0x60;		// TX_SeqNo = 1 
    }
  } else {
    Command.LEN = Alldata;	// set the length to the number of 
    				// data bytes remaining 
    Command.chaining = FALSE;	// and set chaining flag back to false
    if (TX_SeqNo[Command.slot] == 0) {	// PCB will differ depending on TX_SeqNo
    				// but can only be 0 or 1
      Command.PCB = 0x00;		//PCB set with TX_SeqNo = 0
    } else {
      Command.PCB = 0x40;		//PCB set with TX_SeqNo = 1
    }
  }
  
  LRC_Len = Command.LEN + 3;	   // same regardless of case (1,2,3 or 4) 
  Xor_Result = t1_Check(&Command); // go and calculate the checksum 
  Command.TCK = Xor_Result;	   // insert the result at the end of the block

  TX_SeqNo[Command.slot] = Binary_Increment(TX_SeqNo[Command.slot]);
  err = SendBlk(&Command);	   // transmit Blk

  return err;
}


/**************************************************************************/
void 
t1_DecodeBlk(void)
/**************************************************************************/
{
  //printf("Entering t1_DecodeBlk()\n");
  if ((RXPckt.PCB & 0x80) == 0x00) {	// is it an I-Blk?
    Process_IBlk();
  } else {
    if ((RXPckt.PCB & 0x40) == 0x40) {
      Process_SBlk();
    } else {
      Process_RBlk();		// not I-Blk or R-Blk so must be an S-Blk
    }
  }
}

/*************************************************************************/
BYTE 
t1_Check(T1_PCKT * pkt)
/*************************************************************************/
/* This function calculates a checksum byte which is calculated by performing 
   a bitwise XOR operation on NAD, PCB and all INF bytes in packet */
{
  BYTE Xor_Result;
  int Loopcount;

  Xor_Result = pkt->NAD;
  Xor_Result ^= (BYTE) pkt->PCB;
  Xor_Result ^= pkt->LEN;

  for (Loopcount = 0; Loopcount < pkt->LEN; Loopcount++) {
    Xor_Result ^= pkt->DATA[Loopcount + pkt->data_start];
  }

  return Xor_Result;
}

/********************************************************************************/
int 
Process_IBlk()
/********************************************************************************/
/* rec'd a valid I-Blk */
/* is this a single block or is it chaining? */
/* if it is the last block of a chain (b6 = 0) - need to set Command.chaining back to FALSE */
{
  BYTE seq;

  //printf("Entering Process_IBlk()\n");

  seq = (RXPckt.PCB & 0x40) >> 6;

  if (seq != Exp_SeqNo) {
    debug_printf(db,"Sequence number not as expected, retry count %d\n",Retry);
    if (Retry < 3) {		// respond with R-Blk
      /* send R-block with error type of 2 */
      return SendRBlock(Exp_SeqNo, 2);
    } else {
      return SCI_FAIL;
    }
  }
  Exp_SeqNo = Binary_Increment(Exp_SeqNo);

  if ((RXPckt.PCB & 0x20) == 0x20) {	// chaining??
    /* 
     * this I-block is part of a chain so send an R-block to elicit
     * the next I-block 
     */
    return SendRBlock(Exp_SeqNo, 0);	// generate and transmit R-block
  }
  sci_State = S_S_USER;
  ChannelTable[current_channel].state = S_C_USER;

  /* 
   * we have a complete sequence of I-blocks so extract data 
   * and signal application 
   */
  sys_SignalTask(current_channel,SCI_CMD_DONE);

  //printf("Hurrah, IBlock completed sequence\n");
#if FUNAI_TWINSLOT
  com_SendAck();
  g_uc_state = UC_IDLE; /** Finito, can get insert/remove events now **/
#endif
  return SCI_SUCCESS;
}

/******************************************************************************/
int 
SendRBlock(int seq_no, BYTE type)
{
  T1_PCKT cmd;

  // printf("Entering SendRBlock()\n");

  cmd.data_start = 0;
  cmd.total_len = 0;

  cmd.NAD = 0x00;		// NAD will always be 0 

  if (seq_no == 0) {		// expected sequence number can only be 0 or 1
    cmd.PCB = type | 0x80;	// PCB - Exp_SeqNo = 0, no error
  } else {
    cmd.PCB = type | 0x90;	// PCB - Exp_SeqNo = 1, no error
  }
  cmd.LEN = 0;
  cmd.TCK = t1_Check(&cmd);	// calculate checksum

  return SendBlk(&cmd);
}

/******************************************************************************/
int 
Process_RBlk(void)
{
  int err;

// if response to I-Blk with chaining - need to send another I-Blk
// if it is response to chaining - need to construct another I-Blk to send

//  printf("Entering Process_RBlk()\n");

  LRC_Len = 3;			// NAD, PCB and LEN 

  if (Command.chaining == TRUE) {	// check if response to chaining
    // need to send another I_Blk           
    #if FUNAI_TWINSLOT
      com_SendAck(); /* Ack the last response first! */
      g_uc_state = UC_IDLE; /** Finito, can get insert/remove events now **/
    #endif
    return SendIBlock();
  } else {
    if ((RXPckt.PCB > 80 && RXPckt.PCB < 90) || 
    	(RXPckt.PCB > 90))
    {	// is the R-Blk an error?
//      printf("ERROR seen in RBlk. PCB=&%02X Retry=%d\n",RXPckt.PCB,Retry);
      #if FUNAI_TWINSLOT
        com_SendAck(); /* Ack the last response first! */
        g_uc_state = UC_IDLE; /** Finito, can get insert/remove events now **/
      #endif
      if (Retry < 3)
      {
	Retry++;		// increment retry counter
	// no need to copy info into Command structure as still in there from  
	// when sent the first time
	err = SendBlk(&Command);	// resend the blk
	return err;
      } else {
	return SCI_FAIL;	// respond with error
      }
    } else {			// R-Blk not an error
      return SCI_SUCCESS;	// not an error so return success
    }
  }
}

/******************************************************************************/
int 
Process_SBlk(void)
{
  BYTE Xor_Result;
  int err;

  // printf("Entering Process_SBlk()\n");

  if (RXPckt.PCB >= 0xC0 && RXPckt.PCB < 0xE0) {// S-Blk is a request
    switch (RXPckt.PCB) {
      case 0xC0:		// Resynchronisation request
	Command.NAD = 00;	// NAD will always be 0 
	Command.PCB = 0xE1;	// PCB set for resynchronisation response
	Command.LEN = 0;	// no data 
	LRC_Len = 3;		// NAD, PCB, LEN 
	Xor_Result = t1_Check(&Command); // calculate checksum
	Command.TCK = Xor_Result;	 // add to end of Blk 
        #if FUNAI_TWINSLOT
          com_SendAck(); /* Ack the last response first! */
          g_uc_state = UC_IDLE; /** Finito, can get insert/remove events now **/
        #endif
	err = SendBlk(&Command);	 // transmit blk
	return err;
	//break;

      case 0xC1:		// Information field size request
	if (IFS_Count == 2) {	// 3rd successive time sent?
	  return SCI_FAIL;	// yes
	} else {
	  if (RXPckt.DATA[0] > BUFFERSIZE) {
	    return SCI_FAIL;
	  } else {
	    IFS_Count++;	// increment counter
	    IFSC = RXPckt.DATA[0];	// store the new IFSC
	    F_IFSC_Updated = TRUE;
	    
	    Command.NAD = 00;	// NAD will always be 0 
	    Command.PCB = 0xE1;	// PCB set for IFSC response
	    Command.LEN = 1;
	    Command.DATA[0] = RXPckt.DATA[0];	// size in bytes of new IFSC

	    LRC_Len = 4;	// NAD, PCB, LEN and one DATA 
	    Xor_Result = t1_Check(&Command);	// calculate checksum
	    Command.TCK = Xor_Result;	// add to end of Blk 
            #if FUNAI_TWINSLOT
              com_SendAck(); /* Ack the last response first! */
              g_uc_state = UC_IDLE; /** Finito, can get insert/remove events now **/
            #endif
	    err = SendBlk(&Command);	// transmit S(Response)Blk

	    return err;
	  }
	}
	// break;

      case 0xC2:		// Abort request
	return SCI_FAIL;

      case 0xC3:		// Extension of BWT (SWTX) request
	Command.NAD = 00;	// NAD will always be 0 
	Command.PCB = 0xE3;	// PCB set for SWTX response
	Command.LEN = 1;
	Command.DATA[0] = RXPckt.DATA[0];
	
	LRC_Len = 4;
	Xor_Result = t1_Check(&Command);	// calculate checksum
	Command.TCK = Xor_Result;	// add to end of Blk 
        #if FUNAI_TWINSLOT
          com_SendAck(); /* Ack the last response first! */
          g_uc_state = UC_IDLE; /** Finito, can get insert/remove events now **/
        #endif
	err = SendBlk(&Command);	// transmit Blk

	return err;
	// break;

      case 0xC4:		// VPP error (NOT USED)
	return SCI_FAIL;
	// break;

      default:			// other values RFU
	return SCI_FAIL;
    }
  }

  return (RXPckt.PCB==0xE1)?SCI_SUCCESS:SCI_FAIL; // must be S(response)Blk
}

/******************************************************************************/
int 
SendBlk(T1_PCKT * command)
/******************************************************************************/
{
  int i = 0;
  BYTE blk[1024];
  int len;

  WorkWaitTime = card_status.BWT;	// Setup timeout timer  

  // printf("SendBlk(): WorkWaitTime:%d centi-seconds\n", WorkWaitTime);
  /* should probably calculate outgoing checksum in here as well */
  t1_State = T1_NAD;	//DS: Set-up t1_ReadResponse to expect a block in return

  blk[0] = command->NAD;
  blk[1] = command->PCB;
  blk[2] = len = command->LEN;

  for (i = 0; i < len; i++)
    blk[i + 3] = command->DATA[i + command->data_start];

  blk[len + 3] = command->TCK;
/*
  printf("Sending block: ");
  for (i = 0; i < len + 4; i++) {
     printf("%02X ", blk[i]);
  }
  printf("\n");
*/
  // DS   
  /* bug fix - apirozek - added if statement */
  if ( command->chaining)
  {
    command->data_start += len;
    command->len_sent += len;
  }
  
  #if FUNAI_TWINSLOT
    com_SendFunaiHeader(command->slot, CMD_APDU);
  #endif
  return com_SendBytes(blk, 4 + len);
}

/********************************************************************************/
int 
Binary_Increment(int Seq_Number)
/********************************************************************************/
{
  if (Seq_Number == 0) {
    return Seq_Number = 1;
  } else {
    if (Seq_Number == 1) {
      return Seq_Number = 0;
    } else {
      return SCI_FAIL;
    }
  }
}


/***************************************************************************/
int 
t1_GetData(BYTE * buff, int buff_len, int *rcv_len, BYTE * resp)
/***************************************************************************/

{
  int len;

  // printf("Entering t1_GetData()\n");

  len = RXPckt.total_len - 2;

  Resp.SW1 = RXPckt.DATA[len];
  Resp.SW2 = RXPckt.DATA[len + 1];

  *resp++ = Resp.SW1;
  *resp = Resp.SW2;

  if (buff == NULL || buff_len == 0) {
    *rcv_len = len;
    if (len > 0) {
      // printf("Exiting t1_GetData() SCI_E_TRUNC\n");

      return (SCI_E_TRUNC);
    } else {
      // printf("Exiting t1_GetData() SCI_SUCCESS\n");

      return (SCI_SUCCESS);
    }
  } else if (len > buff_len) {
    memcpy(buff, RXPckt.DATA, buff_len);
    *rcv_len = len;
    // printf("Exiting t1_GetData() SCI_E_TRUNC\n");

    return (SCI_E_TRUNC);
  } else {
    /* memcpy(buff, RcvData, ActLen); */
    memcpy(buff, RXPckt.DATA, len);
    /* *rcv_len = ActLen; */
    *rcv_len = len;
    // printf("Exiting t1_GetData()\n");

    return SCI_SUCCESS;
  }
}
