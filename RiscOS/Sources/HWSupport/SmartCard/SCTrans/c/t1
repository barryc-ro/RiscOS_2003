/*-------------------------------------------------------------------------

 File: T1.c

 Purpose:
	To implement those functions which handle the smart card protocol
	T=1.

---------------------------------------------------------------------------

	Written by Applied Card Technologies
	Copyright (c) 1997 Applied Card Technologies All Rights Reserved.

-------------------------------------------------------------------------*/

#ifdef _WINDOWS
#include <windows.h>
#endif
#include <stdio.h>
#include <string.h>
#include "sci_api.h"
#include "sci_int.h"
#include "atr.h"
#include "t1.h"
#include "com.h"

// structures
T1_PCKT Command;
T1_PCKT RXPckt;
T1_RESPDATA Resp;

/* state control variables */
int t1_State;
static int RXCNT;
static int BUFFERSIZE = 104;	// 104 bytes

// variables
static int TX_SeqNo = 0;	// global transmit sequence number variable
				// ensure that FTT the sequence number is 0
static int Exp_SeqNo = 0;	// global expected sequence number variable
				// initialise the expected sequence number
static int LRC_Len;		// make this a global variable
static int IFSC;		// global variable for updated IFSC value
static int Retry;		// global variable for retry
int IFS_Count = 0;		// initialise counter
int Alldata;

// flags
BOOL F_IFSC_Updated = FALSE;	// set IFSC_Updated flag to false as default

int SendIBlock(void);
int SendRBlock(int seq_no, BYTE type);

/*****************************************************************************/
int t1_ProcessByte(BYTE ch)
{
  BYTE Xor_Result;
  int err;

#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * t1_ProcessByte: [%x][%d]\n", ch, ch);
#endif
  switch (t1_State)
  {
    case T1_NAD:
      RXPckt.NAD = ch;		// store the rec'd NAD byte
      t1_State = T1_PCB;	// update t1_State
      RXCNT = 0;		// reset counter
#ifdef REMOTE_DEBUG_T1
      debug_printf(db, "t1_ProcessByte: T1_NAD\n");
#endif
      break;

    case T1_PCB:
      RXPckt.PCB = ch;		// store the rec'd PCB byte
      t1_State = T1_LEN;	// update t1_State
#ifdef REMOTE_DEBUG_T1
      debug_printf(db, "t1_ProcessByte: T1_PCB\n");
#endif
      break;

    case T1_LEN:
      RXPckt.LEN = ch;		// store the rec'd LEN byte
      if (RXPckt.LEN)
      {
        t1_State = T1_DATA;	// update t1_State
      }
      else
      {
        t1_State = T1_LRC;	// update t1_State
      }
#ifdef REMOTE_DEBUG_T1
      debug_printf(db, "t1_ProcessByte: T1_LEN\n");
#endif
      break;

    case T1_DATA:
      /* tag the data on the end of the buffer */
      RXPckt.DATA[RXCNT + RXPckt.data_start] = ch;
      RXCNT++;
      if (RXCNT == RXPckt.LEN)
      {
        t1_State = T1_LRC;
      }
#ifdef REMOTE_DEBUG_T1
      debug_printf(db, "t1_ProcessByte: T1_DATA\n");
#endif
      break;

    case T1_LRC:
      RXPckt.TCK = ch;		// store the rec'd LRC byte
      t1_State = T1_END;	// block now complete
#ifdef REMOTE_DEBUG_T1
      debug_printf(db, "t1_ProcessByte: T1_LRC\n");
#endif
      break;

    case T1_END:
      /* data remaining to be processed but block is complete -  error
       * generate and send error block set state control variables
       * to expect new I_block
       */
#ifdef REMOTE_DEBUG_T1
      debug_printf(db, "t1_ProcessByte: T1_END - error\n");
#endif
      return SCI_ERROR;	/* for now */
  }

  if (t1_State != T1_END)
  {
    /* finished processing buffer but block not complete so
       return and wait for next comms chunk */
#ifdef REMOTE_DEBUG_T1
    debug_printf(db, "t1_state:0: %d\n", t1_State);
    debug_printf(db, "t1_ProcessByte: incomplete block\n");
#endif
    return SCI_SUCCESS;
  }
  Xor_Result = t1_Check(&RXPckt);	// calculate checksum

  if (Xor_Result == RXPckt.TCK)
  { // rec'd checksum = calculated checksum?
#ifdef REMOTE_DEBUG_T1
    debug_printf(db, "t1_state:1: %d\n", t1_State);
    debug_printf(db, "t1_ProcessByte: received block OK\n");
#endif
    RXPckt.total_len += RXPckt.LEN;
    RXPckt.data_start += RXPckt.LEN;
    t1_DecodeBlk();		// equal (ie: valid blk rec'd) so decode blk
  }
  else
  {			// not equal so construct and send an R-Blk
#ifdef REMOTE_DEBUG_T1
    debug_printf(db, "t1_Check failed: card: %x  xor: %x\n",
                 Xor_Result, RXPckt.TCK);
    debug_printf(db, "t1_ProcessByte: bad block, sending r-block\n");
#endif
    Command.NAD = 0;
    if (Exp_SeqNo == 0)
    {	// expected sequence number can only be 0 or 1
      Command.PCB = 81;		// PCB - Exp_SeqNo = 0, EDC error
    }
    else
    {
      Command.PCB = 91;		// PCB - Exp_SeqNo = 1, EDC error
    }

    Command.LEN = 0;
    LRC_Len = 3;		// NAD,PCB and LEN (no data bytes)
    Xor_Result = t1_Check(&Command);	// go and calculate the checksum
    Command.TCK = Xor_Result;	// insert the result at the end of the block
    err = SendBlk(&Command);

    return err;
  }

#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "t1_state:2: %d\n", t1_State);
  debug_printf(db, "t1_ProcessByte: SUCCESS\n");
#endif
  return SCI_SUCCESS;
}

/*****************************************************************************/
int t1_StartCommand(int card_hnd, BYTE * cmd_hdr,
                    int data_len, BYTE * data, int exp_len)
{
  static int XportType;
  int i, j;

#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * t1_StartCommand\n");
  debug_printf(db, "t1_StartCommand: data_len: %d\n", data_len);
  debug_printf(db, "t1_StartCommand:  exp_len: %d\n", exp_len);
#endif
  com_FlushComms();		/* clear comms buffers */
  Retry = 0;			// initialise the retry counter

  /* set variables to handle sending I-block(s) */
  Command.len_sent = 0;
  Command.data_start = 0;

  /* set variables to handle reception of following I-block(s) */
  RXPckt.total_len = 0;
  RXPckt.len_sent = 0;
  RXPckt.data_start = 0;

  // determine transport type - case 1, 2, 3 or 4
  // Check for LC=0 (data_len) AND LE=0 (exp_len)
  if (data_len)
  {
    if (exp_len)
    {
      XportType = T1_CASE4;	// Header, Lc, Data, Le
    }
    else
    {
      XportType = T1_CASE3;	// Header, Lc, Data
    }
  }
  else
  {
    if (exp_len)
    {
      XportType = T1_CASE2;	// Header, Le
    }
    else
    {
      XportType = T1_CASE1;	// Header
    }
  }

  Command.DATA[0] = *cmd_hdr++;
  Command.DATA[1] = *cmd_hdr++;
  Command.DATA[2] = *cmd_hdr++;
  Command.DATA[3] = *cmd_hdr++;

  switch (XportType)
  {
    case T1_CASE1:
      Command.total_len = 4;
      break;

    case T1_CASE2:
      Command.total_len = 5;
      Command.DATA[4] = exp_len;
      break;

    case T1_CASE3:
      Command.total_len = 5 + data_len;
      Command.DATA[4] = data_len;
      for (i = 5, j = 0; j < data_len; i++, j++)
	Command.DATA[i] = data[j];
      break;

    case T1_CASE4:
      Command.total_len = 6 + data_len;
      Command.DATA[4] = data_len;
      for (i = 5, j = 0; j < data_len; i++, j++) {
	Command.DATA[i] = data[j];
      }
      Command.DATA[i] = exp_len;
      break;
  }
  // Compare IFSC with Command.LEN for chaining purposes
  if (F_IFSC_Updated == TRUE)
  { // Check if IFSC has been updated
    card_status.IFSC = IFSC;	// set IFSC to new value
    // ** set F_IFSC_Updated flag back to FALSE?? **
  }

  return SendIBlock();
}

/*****************************************************************************/
int SendIBlock(void)
{
  int len;
  int err;

#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * SendIBlock\n");
#endif

  Command.NAD = 0x00;		// NAD will always be 0
  Command.PCB = 0x00;

  len = Command.total_len - Command.len_sent;

  if (len > card_status.IFSC)
  {	// chaining
    Command.chaining = TRUE;	// set chaining flag to true
    Command.LEN = card_status.IFSC;	// set the length to maximum possible
    Command.PCB |= 0x20;
  }
  else
  {
    Command.LEN = len;		// set the length to maximum possible
    Command.chaining = FALSE;	// set chaining flag to true
  }

  if (TX_SeqNo != 0)
  {
    Command.PCB |= 0x40;	// TX_SeqNo = 1
  }

  Command.TCK = t1_Check(&Command);	// go and calculate the checksum

  TX_SeqNo = Binary_Increment(TX_SeqNo);

  // DS: RXCNT = 0;
  // DS: t1_State = T1_NAD;
  // initialise the t1_State
#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "SendIBlock:  total_len: %d\n", Command.total_len);
  debug_printf(db, "SendIBlock:   len_sent: %d\n", Command.len_sent);
  debug_printf(db, "SendIBlock: data_start: %d\n", Command.data_start);
  debug_printf(db, "SendIBlock:   chaining: %d\n", Command.chaining);
  debug_printf(db, "SendIBlock:        NAD: %d\n", Command.NAD);
  debug_printf(db, "SendIBlock:        PCB: %d\n", Command.PCB);
  debug_printf(db, "SendIBlock:        LEN: %d\n", Command.LEN);
  debug_printf(db, "SendIBlock:    DATA[0]: %x\n", Command.DATA[0]);
  debug_printf(db, "SendIBlock:    DATA[1]: %x\n", Command.DATA[1]);
  debug_printf(db, "SendIBlock:    DATA[2]: %x\n", Command.DATA[2]);
  debug_printf(db, "SendIBlock:    DATA[3]: %x\n", Command.DATA[3]);
  debug_printf(db, "SendIBlock:        TCK: %d\n", Command.TCK);
#endif

  err = SendBlk(&Command);	// transmit Blk
  return err;
}

/*****************************************************************************/
int Chaining_Sequence(int datalength)
{
  BYTE Xor_Result;
  int err;

#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * Chaining_Sequence\n");
#endif
  if (Alldata > card_status.IFSC) {
    Command.LEN = card_status.IFSC; // NOTE: Command.chaining remains TRUE here

    Alldata = Alldata - Command.LEN;
    if (TX_SeqNo == 0) {
      Command.PCB = 20;		// TX_SeqNo = 0
    } else {
      Command.PCB = 60;		// TX_SeqNo = 1
    }
  } else {
    Command.LEN = Alldata;	// set the length to the number of
    				// data bytes remaining
    Command.chaining = FALSE;	// and set chaining flag back to false
    if (TX_SeqNo == 0) {	// PCB will differ depending on TX_SeqNo
    				// but can only be 0 or 1
      Command.PCB = 00;		//PCB set with TX_SeqNo = 0
    } else {
      Command.PCB = 40;		//PCB set with TX_SeqNo = 1
    }
  }

  LRC_Len = Command.LEN + 3;	   // same regardless of case (1,2,3 or 4)
  Xor_Result = t1_Check(&Command); // go and calculate the checksum
  Command.TCK = Xor_Result;	   // insert the result at the end of the block

  TX_SeqNo = Binary_Increment(TX_SeqNo);
  err = SendBlk(&Command);	   // transmit Blk

  return err;
}

/*****************************************************************************/
void t1_DecodeBlk(void)
{
#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * t1_DecodeBlk\n");
#endif
  if ((RXPckt.PCB & 0x80) == 0x00)
  {	// is it an I-Blk?
#ifdef REMOTE_DEBUG_T1
    debug_printf(db, "t1_DecodeBlk:1: Process_IBlk\n");
#endif
    Process_IBlk();
  }
  else
  {
    if ((RXPckt.PCB & 0x40) == 0x40)
    {
#ifdef REMOTE_DEBUG_T1
      debug_printf(db, "t1_DecodeBlk:2: Process_SBlk\n");
#endif
      Process_SBlk();
    }
    else
    {
#ifdef REMOTE_DEBUG_T1
      debug_printf(db, "t1_DecodeBlk:3: Process_RBlk\n");
#endif
      Process_RBlk();		// not I-Blk or R-Blk so must be an S-Blk
    }
  }
}

/*****************************************************************************
  This function calculates a checksum byte which is calculated by performing
  a bitwise XOR operation on NAD, PCB and all INF bytes in packet
 */
BYTE t1_Check(T1_PCKT * pkt)
{
  BYTE Xor_Result =0;
  int Loopcount;

#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * t1_Check\n");
#endif
  Xor_Result = pkt->NAD;
  Xor_Result ^= (BYTE) pkt->PCB;
  Xor_Result ^= pkt->LEN;

  for (Loopcount = 0; Loopcount < pkt->LEN; Loopcount++)
  {
    Xor_Result ^= pkt->DATA[Loopcount + pkt->data_start];
  }

  return Xor_Result;
}

/*****************************************************************************
  rec'd a valid I-Blk
  is this a single block or is it chaining?
  if it is the last block of a chain (b6 = 0) - need to set Command.chaining
  back to FALSE
 */
int Process_IBlk()
{
  BYTE seq;

#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * Process_IBlk\n");
#endif
  seq = (RXPckt.PCB & 0x40) >> 6;

  if (seq != Exp_SeqNo)
  {
    if (Retry < 3)
    {		// respond with R-Blk
      /* send R-block with error type of 2 */
      return SendRBlock(Exp_SeqNo, 2);
    }
    else
    {
      return SCI_FAIL;
    }
  }
  Exp_SeqNo = Binary_Increment(Exp_SeqNo);

  if ((RXPckt.PCB & 0x20) == 0x20)
  {	// chaining??
    /*
     * this I-block is part of a chain so send an R-block to elicit
     * the next I-block
     */
    return SendRBlock(Exp_SeqNo, 0);	// generate and transmit R-block
  }
  sci_State = S_S_USER;
  ChannelTable[current_channel].state = S_C_USER;

  /*
   * we have a complete sequence of I-blocks so extract data
   * and signal application
   */
  sys_SignalTask(current_channel,SCI_CMD_DONE);
#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "\n");
#endif

  return SCI_SUCCESS;
}

/*****************************************************************************/
int SendRBlock(int seq_no, BYTE type)
{
  T1_PCKT cmd;

#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * SendRBlock\n");
#endif

  cmd.data_start = 0;
  cmd.total_len = 0;

  cmd.NAD = 0x00;		// NAD will always be 0

  if (seq_no == 0) {		// expected sequence number can only be 0 or 1
    cmd.PCB = type | 0x80;	// PCB - Exp_SeqNo = 0, no error
  } else {
    cmd.PCB = type | 0x90;	// PCB - Exp_SeqNo = 1, no error
  }
  cmd.LEN = 0;
  cmd.TCK = t1_Check(&cmd);	// calculate checksum

  return SendBlk(&cmd);
}

/*****************************************************************************/
int Process_RBlk(void)
{
  int err;

// if response to I-Blk with chaining - need to send another I-Blk
// if it is response to chaining - need to construct another I-Blk to send

#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * Process_RBlk\n");
#endif

  LRC_Len = 3;			// NAD, PCB and LEN

  if (Command.chaining == TRUE)
  { // check if response to chaining
    // need to send another I_Blk
#ifdef REMOTE_DEBUG_T1
    debug_printf(db, "Process_RBlk: chaining\n");
#endif
    return SendIBlock();
  }
  else
  {
    if ((RXPckt.PCB > 80 && RXPckt.PCB < 90) ||	(RXPckt.PCB > 90))
    {	// is the R-Blk an error?
#ifdef REMOTE_DEBUG_T1
      debug_printf(db, "Process_RBlk: R-Blk error\n");
      debug_printf(db, "Process_RBlk: RXPckt.PCB: %d\n", RXPckt.PCB);
#endif
      if (Retry < 3)
      {
	Retry++;		// increment retry counter
	// no need to copy info into Command structure as still in there from
	// when sent the first time
	err = SendBlk(&Command);	// resend the blk
	return err;
      } else {
	return SCI_FAIL;	// respond with error
      }
    } else {			// R-Blk not an error
      return SCI_SUCCESS;	// not an error so return success
    }
  }
}

/*****************************************************************************/
int Process_SBlk(void)
{
  BYTE Xor_Result;
  int err;

#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * Process_SBlk\n");
#endif

  if (RXPckt.PCB >= 0xC0 && RXPckt.PCB < 0xE0)
  { // S-Blk is a request
    switch (RXPckt.PCB)
    {
      case 0xC0:		// Resynchronisation request
	Command.NAD = 00;	// NAD will always be 0
	Command.PCB = 0xE1;	// PCB set for resynchronisation response
	Command.LEN = 0;	// no data
	LRC_Len = 3;		// NAD, PCB, LEN
	Xor_Result = t1_Check(&Command); // calculate checksum
	Command.TCK = Xor_Result;	 // add to end of Blk
	err = SendBlk(&Command);	 // transmit blk
	return err;
	break;

      case 0xC1:		// Information field size request
	if (IFS_Count == 2) {	// 3rd successive time sent?
	  return SCI_FAIL;	// yes
	} else {
	  if (RXPckt.DATA[0] > BUFFERSIZE) {
	    return SCI_FAIL;
	  } else {
	    IFS_Count++;	// increment counter
	    IFSC = RXPckt.DATA[0];	// store the new IFSC
	    F_IFSC_Updated = TRUE;

	    Command.NAD = 00;	// NAD will always be 0
	    Command.PCB = 0xE1;	// PCB set for IFSC response
	    Command.LEN = 1;
	    Command.DATA[0] = RXPckt.DATA[0];	// size in bytes of new IFSC

	    LRC_Len = 4;	// NAD, PCB, LEN and one DATA
	    Xor_Result = t1_Check(&Command);	// calculate checksum
	    Command.TCK = Xor_Result;	// add to end of Blk
	    err = SendBlk(&Command);	// transmit S(Response)Blk

	    return err;
	  }
	}
	// break;

      case 0xC2:		// Abort request
	return SCI_FAIL;

      case 0xC3:		// Extension of BWT (SWTX) request
	Command.NAD = 00;	// NAD will always be 0
	Command.PCB = 0xE3;	// PCB set for SWTX response
	Command.LEN = 1;
	Command.DATA[0] = RXPckt.DATA[0];

	LRC_Len = 4;
	Xor_Result = t1_Check(&Command);	// calculate checksum
	Command.TCK = Xor_Result;	// add to end of Blk
	err = SendBlk(&Command);	// transmit Blk

	return err;
	break;

      case 0xC4:		// VPP error (NOT USED)
	return SCI_FAIL;
	break;

      default:			// other values RFU
	return SCI_FAIL;
    }
  }
  return (RXPckt.PCB==0xE1)?SCI_SUCCESS:SCI_FAIL; // must be S(response)Blk
}

/*****************************************************************************/
int SendBlk(T1_PCKT * command)
{
  int i = 0;
  BYTE blk[1024];
  int len;

  WorkWaitTime = card_status.BWT;	// Setup timeout timer

#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * SendBlk\n");
#endif
  /* should probably calculate outgoing checksum in here as well */
  t1_State = T1_NAD;	//DS: Set-up t1_ReadResponse to expect a block in return

  blk[0] = command->NAD;
  blk[1] = command->PCB;
  blk[2] = len = command->LEN;

  for (i = 0; i < len; i++)
    blk[i + 3] = command->DATA[i + command->data_start];

  blk[len + 3] = command->TCK;

  // AJP
  /* bug fix - added if statement */
  if ( command->chaining)
  {
    command->data_start += len;
    command->len_sent += len;
  }

  return com_SendBytes(blk, 4 + len);
}

/*****************************************************************************/
int Binary_Increment(int Seq_Number)
{
#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * Binary_Increment\n");
#endif
  if (Seq_Number == 0)
  {
    return Seq_Number = 1;
  }
  else
  {
    if (Seq_Number == 1)
    {
      return Seq_Number = 0;
    }
    else
    {
      return SCI_FAIL;
    }
  }
}

/*****************************************************************************/
int t1_GetData(BYTE * buff, int buff_len, int *rcv_len, BYTE * resp)
{
  int len;

#ifdef REMOTE_DEBUG_T1
  debug_printf(db, "PROC * t1_GetData\n");
#endif

  len = RXPckt.total_len - 2;
  Resp.SW1 = RXPckt.DATA[len];
  Resp.SW2 = RXPckt.DATA[len + 1];

  *resp++ = Resp.SW1;
  *resp = Resp.SW2;

  if (buff == NULL || buff_len == 0)
  {
    *rcv_len = len;
    if (len > 0)
    {
      return (SCI_E_TRUNC);
    }
    else
    {
      return (SCI_SUCCESS);
    }
  }
  else
    if (len > buff_len)
    {
      memcpy(buff, RXPckt.DATA, buff_len);
      *rcv_len = len;

      return (SCI_E_TRUNC);
    }
    else
    {
      memcpy(buff, RXPckt.DATA, len);
      *rcv_len = len;
      return SCI_SUCCESS;
  }
}
