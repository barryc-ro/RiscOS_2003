/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

/*
 * Provide os specific support to the serial library
 *
 * Modification History
 *---------------------
 *
 * 01-Jul-96 RWB, Fixed card wanking bug due to com_SendBytes fault.
 * 06-Sep-96 RWB, Clear dsr_state flag on com_SetResetInd.
 * 11-Sep-96 RWB, Made constant strings statics.
 * 26-Sep-96 RWB, Increased input buffer size to 256 bytes.
 *
 */

#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "module.h"
#include "sci_api.h"
#include "sci_int.h"
#include "serial.h"
#include "serial_ven.h"
#include "com.h"
#include "t0_sm.h"
#include "t1.h"


static char serial_config[] = "devices#baud9600;data8;stop1;noparity;nohandshake";

#define SERIAL_PORT   "serial2"
#define COM_RESET_PULSE	(1)	/* centi-seconds */

extern int iInputStream;
extern int iOutputStream;
extern int flags;

int l_error_slot;

/*
 * open serial port streams and set ModemStatus to its initial value
 */
int
com_Init(void)
{
  char strConfig[80];

  com_Close();

  sprintf(strConfig,"%s;size300;thres32:$.%s",serial_config,SERIAL_PORT);
  iInputStream  = serial_open_stream(strConfig,SERIAL_INPUT);
  sprintf(strConfig,"%s;size256;thres32:$.%s",serial_config,SERIAL_PORT);
  iOutputStream = serial_open_stream(strConfig,SERIAL_OUTPUT);

  if (!iInputStream || !iOutputStream)
  {
    debug_printf(db,"(7)    failed to open stream");
    serial_close_stream(iInputStream);
    serial_close_stream(iOutputStream);
    return (FALSE);
  }

  com_SetResetInd();

  return (TRUE);
}

/*
 * toggle DTR for 10ms to perform a reset.
 */
int
com_SetResetInd(void)
{
#if FUNAI_TWINSLOT != TRUE
  ioctl_t ioctl_block;
  serial_ctrl_t ctrl;

  debug_printf(db,"(7) resetting card");
  CLEAR_FLAG(flags,flag_dsr_state);

  /* read control lines */
  ioctl_block.reason = IOCTL_CTRL_LINES;
  ioctl_block.write = 0;
  ioctl_block.read = 1;
  ctrl.data = serial_ioctl(iOutputStream,&ioctl_block);

  /* assert dtr */
  ctrl.bits.dtr = 1;
  ioctl_block.write = 1;
  ioctl_block.data = ctrl.data;
  serial_ioctl(iOutputStream,&ioctl_block);

  /* wait 10ms */
  sys_Delay(COM_RESET_PULSE);

  /* clear dtr */
  ctrl.bits.dtr = 0;
  ioctl_block.write = 1;
  ioctl_block.data = ctrl.data;
  serial_ioctl(iOutputStream,&ioctl_block);
#endif
  return (SCI_SUCCESS);
}

/*
 * read bytes into buffer
 */
int
com_ReadBytes(BYTE *data, int len)
{
  return (serial_read_stream(iInputStream, (char*)data, len));
}

/*
 * transmit bytes
 */
int
com_SendBytes(BYTE *data, int len)
{
#if FUNAI_TWINSLOT
//  serial_write_stream(iOutputStream, (char *)data, len);
  while (len--) {
    if(serial_write_byte(iOutputStream, *data) != 1) {
//      printf("Error: Failed to write char\n");
      return(SCI_E_OUT);
    }
    data++;
  }
  return(SCI_SUCCESS);
#else
  ioctl_t ioctl_block;
  serial_ctrl_t ctrl;
  int pause = 0;

  ioctl_block.reason = IOCTL_CTRL_LINES;
  ioctl_block.read = 1;

  while (len--) {
    /*
     * wait for CTS to be set and check that card is still in
     */
    if (serial_write_byte(iOutputStream,*data) != 1) {
      debug_printf(db,"(7) Failed to write char");
      return (SCI_E_OUT);
    }

    switch (pause) {
      case 0:
	/* wait for CTS to go high and check card in */
        do {
          ctrl.data = serial_ioctl(iOutputStream,&ioctl_block);
          if (!ctrl.bits.dsr) {
            goto exit_gracefully;
          }
        } while (!ctrl.bits.cts);
	pause = 1;
	break;

      case 1:
	/* wait for CTS to go low and check card in */
        do {
          ctrl.data = serial_ioctl(iOutputStream,&ioctl_block);
          if (!ctrl.bits.dsr) {
            goto exit_gracefully;
          }
        } while (ctrl.bits.cts);
	pause = 2;
	break;

      case 2:
	/* wait for CTS to go high and check card in */
        do {
          ctrl.data = serial_ioctl(iOutputStream,&ioctl_block);
          if (!ctrl.bits.dsr) {
            goto exit_gracefully;
          }
        } while (!ctrl.bits.cts);

	/* wait for CTS to go low and check card in */
        do {
          ctrl.data = serial_ioctl(iOutputStream,&ioctl_block);
          if (!ctrl.bits.dsr) {
            goto exit_gracefully;
          }
        } while (ctrl.bits.cts);
	pause = 2;
	break;
    }
    /* 
     * replacing delay routine with new funky code
     * sys_Delay(1);
     */
    data++;
  }
  sys_StartWaitTimer((sci_State==S_S_OPENING ) ? ATR_INIT_WAIT : WorkWaitTime);

  return (SCI_SUCCESS);
  
exit_gracefully:
  ctrl.bits.rts = 0;
  ioctl_block.write = 1;
  ioctl_block.data = ctrl.data;
  serial_ioctl(iOutputStream,&ioctl_block);
  return (SCI_E_OUT);
#endif
}

/*
 *
 */
void
com_FlushComms(void)
{
  while(serial_read_byte(iInputStream)!=-1) ;
}

/*
 * look for the presence of DSR
 */
BOOL
com_CardIn(void)
{
#if FUNAI_TWINSLOT
  return(g_card1_in);
#else
  ioctl_t ioctl_block;
  serial_ctrl_t ctrl;

  /* read */
  ioctl_block.reason = IOCTL_CTRL_LINES;
  ioctl_block.write = 0;
  ioctl_block.read = 1;
  serial_ioctl(iOutputStream,&ioctl_block);
  ctrl.data = ioctl_block.data;

  if (ctrl.bits.dsr == 1) return (TRUE);

  return (FALSE);
#endif
}

/*
 * close down streams.
 */
void
com_Close(void)
{
  if (iInputStream)  serial_close_stream(iInputStream);
  if (iOutputStream) serial_close_stream(iOutputStream);
  iInputStream = 0;
  iOutputStream = 0;
}


#if FUNAI_TWINSLOT
/* Funai-uController specific routines */

/*
 * com_ReadFunaiHeader - Reads a reply from the Funai uC, and acts on it
 */ 
void
com_ReadFunaiHeader
(
  void
)
{
  int		readbyte;
  
  if(g_funai_header == NO_HEADER)
  {
    /** First, find out what code we have **/
    readbyte = serial_read_byte(iInputStream);
    if(readbyte == -1) return; /** strangely, there was no-one at the door... **/
    if(readbyte == ACK) return; /** an ACK is an ACK. We're not interested. **/

    g_funai_header = readbyte;
    /** This is all we need to know at the moment... **/
  }
  else
  {
    readbyte = serial_read_byte(iInputStream); /** Normally the slot indicator **/
    switch(g_funai_header)
    {
      case RET_CARDOPEN:   com_ProcessCardOpen(readbyte);
      			   break;
      case RET_APDU:	   com_ProcessAPDU(readbyte);
      			   break;
      case RET_NUMSLOTS:
      			   break;
      case RET_SLOTSTATE:
      			   break;
      case RET_CARDSTATE:
      			   break;
      case MSG_CARDINSERT: com_ProcessCardInserted(readbyte);
      			   break;
      case MSG_CARDREMOVE: com_ProcessCardRemoved(readbyte);
      			   break;
      case RET_ERROR:	   l_error_slot = readbyte; g_funai_header = RET_ERROR2;
      			   return;
      			   break;
      case RET_ERROR2:	   com_ProcessError(readbyte);
      			   break;
      default:				/** Either a duff code, or a 'fail' from serial_read_byte **/
      			   break;
    }
    g_funai_header = NO_HEADER;		/* reset */
  }
}


/*
 *  com_SendFunaiHeader - Sends the specified header to the given slot. Data dealt with by
 *			  the calling routine.
 */ 
void
com_SendFunaiHeader
(
  char	slot,
  char	command
)
{
  /** Code here */
  if(serial_write_byte(iOutputStream, command) != 1) return;
  
  if(slot != NO_SLOT)
  {
    serial_write_byte(iOutputStream, slot);
  }
}


/*
 *  com_SendAck - sends ACK to the uC
 */ 
void
com_SendAck
(
  void
)
{
  serial_write_byte(iOutputStream, ACK);
}


/*
 *  com_ProcessCardInserted - Processes CardInserted events
 */ 
void
com_ProcessCardInserted
(
  int	slot
)
{
  int   a;
  char	command_block[2];

  g_uc_state = UC_BUSY;
  g_slot2_state = WAITING_INSERT; /** Prevents async events **/
  
//  printf("+++ Card inserted in slot %d .Pending=%d\n",slot,g_card2_insertpending);
  
  /** Do the slot-independant stuff here **/
  if(g_card2_insertpending == FALSE) serial_write_byte(iOutputStream, ACK);
//  g_card2_insertpending = FALSE;
//  printf("%d \n",g_card2_insertpending);

  TX_SeqNo[slot] = 0;
  if(slot == SLOT_1)
  {
    Exp_SeqNo = 0; /* Re-init */
//    printf("b\n");
    /* Wait a moment, to see if there's a card2 insert event too */
    sys_Delay(100);
    
    a = serial_read_byte(iInputStream);
//    printf("c a=%d\n",a);

    switch(a)
    {
      case MSG_CARDINSERT: if(serial_read_byte(iInputStream) == SLOT_2)
      			   {
//			     printf("Got slot2 too. Pending set.\n");
		             /* Flag it for later consumption */
		             g_card2_insertpending = TRUE;
			   }
			   /** Can't get a slot1 insert, cos it's already in... **/
 			   serial_write_byte(iOutputStream, ACK); /** Got to ACK it here or it'll be too late... **/
			   break;
      case MSG_CARDREMOVE: if(serial_read_byte(iInputStream) == SLOT_2)
      			   {
      			     g_card2_insertpending = FALSE; /** don't really need this but what the hell **/
 			     serial_write_byte(iOutputStream, ACK); /** Got to ACK it **/
      			   }
      			   else
      			   {
      			     /** Uh oh, card1 removed before we've accepted it... **/
 			     serial_write_byte(iOutputStream, ACK); /** Got to ACK it **/
 			     g_slot2_state = IDLE;
 			     g_uc_state = UC_IDLE;
 			     return;
      			   }
      			   break;
    }
  }
  g_slot2_state = IDLE; /** Re-enable async events **/
  command_block[0] = CMD_CARDOPEN;
  command_block[1] = slot;
  g_uc_state = UC_RET_CARDOPEN; /** Waiting for response **/
  serial_write_stream(iOutputStream, command_block, 2); /** Open the card **/
//  printf("Sent cardopen stream &%02X, &%02X\n",command_block[0],command_block[1]);
}


/*
 *  com_ProcessCardRemoved - Processes CardRemoved events
 */ 
void
com_ProcessCardRemoved
(
  int	slot
)
{
  
//  printf("+++ Card removed from slot %d\n",slot);
  com_SendAck();
  /** Generate card-removed call **/
  /** Note that if BOTH cards are in, and slot 1 removed, we need to generate a card2 removed too **/
  if(slot == SLOT_1)
  {
    t0_CardStatusChange(FALSE); /** Bye bye, Mr Card (sends service) **/
    g_card1_in = FALSE;
    if(g_card2_in == TRUE)
    {
      g_card2_in = FALSE;
      g_slot2datablock_state = SCI_E_OUT;
      g_slot2_state = IDLE;
      /** send card2_removed service **/
      sys_SigBroadcast(SCI_REMOVED2);
    }
  }
  else /** Slot 2 **/
  {
    g_card2_in = FALSE;
    g_slot2datablock_state = SCI_E_OUT;
    g_slot2_state = IDLE;
    /** send card2_removed service **/
    sys_SigBroadcast(SCI_REMOVED2);
  }
}


/*
 *  com_ProcessCardOpen - Processes CardOpen response from uC
 */ 
void
com_ProcessCardOpen
(
  int	slot
)
{
  int channel;
//  printf("CardOpen response from slot %d\n",slot);
  if(slot == SLOT_1)
  {
    g_card1_in = TRUE; /** There's a card in slot 1 now **/
    g_uc_state = UC_BUSY; /** Cos the ATR is streaming in at this point **/
    /** Need to prod the code into reading the ATR **/
    setup_event(SC_Event_CardIn);
    setup_event(SC_Event_DataPresent);
  }
  else
  {
    g_card2_in = TRUE; /** There's a card in slot 2 now **/
    g_uc_state = UC_BUSY; /** Cos the ATR is streaming in at this point **/
    g_slot2_state = GET_ATR; /* Ignore DataPresent events - we're single-tasking */
    /** ditch the ATR as it comes in **/
    if(com_GetATR() == -1)
    {
//      printf("Dodgy ATR\n");
      sys_Delay(50);
      com_FlushComms();
//      printf("END Dodgy ATR\n");
      g_slot2datablock_state = SCI_E_NOTURL; /* ATR stuffed, so not a URL card */
    }
    else
    {
      g_slot2datablock_state = SCI_E_NODATA; /* Default to no URL ready yet */
    }
    serial_write_byte(iOutputStream, ACK); /** Ack the ATR, even if we didn't like it **/
    g_slot2_state = IDLE; /* gotit */
    g_uc_state = UC_IDLE;

    if(g_card2_insertpending)
    {
      for (channel=0; channel<MAX_CARD_CHANNELS; channel++) {
        if (ChannelTable[channel].flags & channel_in_use) {
          if (ChannelTable[channel].state == S_C_OPENING) {
            sys_SignalTask(channel,SCI_CMD_DONE);
          }
        }
      }
      g_card2_insertpending = FALSE;
    }
    sys_SigBroadcast(SCI_INSERTED2);
  }
}


/*
 *  com_ProcessAPDU - Process APDU response from uC
 */ 
void
com_ProcessAPDU
(
  int	slot
)
{
//  printf("++APDU response from slot %d\n",slot);
  g_uc_state = UC_BUSY; /** Cos the APDU response is streaming in **/

  if(slot == SLOT_2)
  {
    com_StartReadSlot2(); /** It's for yooo-hooo! **/
  }
}

int
blocking_readbyte
(
  void
)
{
  int value;
#if FALSE
  unsigned int o_val, n_val;

  _swix(OS_ReadMonotonicTime, _OUT(0), &o_val);

  do {
    value = serial_read_byte(iInputStream);
    _swix(OS_ReadMonotonicTime, _OUT(0), &n_val);
  } while( (value == -1) && ((n_val-o_val) < 100) );
#else
  do {
    value = serial_read_byte(iInputStream);
  } while (value == -1);
#endif
  return(value);
}  


/*
 *  com_ProcessError
 */ 
void
com_ProcessError
(
  int	error
)
{
  int	channel;
  
//  printf("Error - %d in slot %d\n",error, l_error_slot);
  if(l_error_slot == SLOT_1)
  {
    switch(error)
    {
      case UC_ERR_BROKEN:     if(g_card1_in == FALSE) sys_SigBroadcast(SCI_BADINSERT);
      			      break;
      case UC_ERR_NOTPRESENT: g_card1_in = FALSE;
      			      break;
      case UC_ERR_CLOSED:
      			      break;
      case UC_ERR_ACCESS:
      			      break;
    }
    g_card2_insertpending = FALSE; /* May have been pending when it barfed **/
  }
  else
  {
//    printf("tsk. card2 bad.\n");
    if(g_card2_insertpending)
    {
//      printf("Yelling about card1 insert\n");
      for (channel=0; channel<MAX_CARD_CHANNELS; channel++) {
        if (ChannelTable[channel].flags & channel_in_use) {
          if (ChannelTable[channel].state == S_C_OPENING) {
            sys_SignalTask(channel,SCI_CMD_DONE);
          }
        }
      }
    }
    g_card2_insertpending = FALSE; /* May have been pending when it barfed **/
    g_funai_header = NO_HEADER;
    switch(error)
    {
      case UC_ERR_BROKEN:     if(g_card2_in == FALSE) sys_SigBroadcast(SCI_BADINSERT2);
      			      break;
      case UC_ERR_NOTPRESENT: g_card2_in = FALSE;
      			      break;
    }
  }

  com_SendAck();
  g_uc_state = UC_IDLE;
}


/*
 *  com_StartReadSlot2 - Reads the URL info off the card in slot2
 *  This is a fairly detailed and lengthy process...
 */ 
void
com_StartReadSlot2
(
  void
)
{
  BYTE	cmd[4];
  BYTE  block[10];
  int	retval;
  
//  printf("=Entered com_startreadslot2 with g_slot2_state = %d\n",g_slot2_state);
  switch(g_slot2_state)
  {
    case VERIFY_SEND:
                        /** Issue APDU for PIN '00000000' against IEF1 **/
                        cmd[0] = 0x00;
                        cmd[1] = 0x20;
                        cmd[2] = 0x00;
                        cmd[3] = 0x94;
                        strcpy((char *)block, "00000000");
                        g_slot2_state = VERIFY_RESPONSE;
    			g_uc_state = UC_IDLE;
                        t1_StartCommand(SLOT_2, cmd, 8, block, 0);
    			break;

    case VERIFY_RESPONSE:
    			/** Deal with the response from the VERIFY **/
    			retval = com_DealWithVerify();
                        serial_write_byte(iOutputStream, ACK);
/*    			if(retval == -2)
    			{
                          g_slot2_state = VERIFY_RESPONSE;
                          cmd[0] = 0x00;
                          cmd[1] = 0x20;
                          cmd[2] = 0x00;
                          cmd[3] = 0x94;
                          strcpy((char *)block, "00000000");
                          t1_StartCommand(SLOT_2, cmd, 8, block, 0);
    			  g_uc_state = UC_IDLE;
      		 	  break;
    			}
    			else*/ if(retval != 0)
    			{
    			  /** Error of some sort. Tidy up & leave. **/
    			  g_slot2_state = IDLE;
    			  g_uc_state = UC_IDLE;
    			  return;
    			}
    			/** NOTDONE: Check whether there's been a card statechange come in after? **/

    			/** Send a readrecord command **/
    			g_record = 1;
                        cmd[0] = 0x00;
                        cmd[1] = 0xB2;
                        cmd[2] = g_record; /*Record*/
                        cmd[3] = 0xD4;
                        block[0] = 0x1B;
			if(g_slot2_state == IDLE) break; /** Check card in at last possible moment **/
    			g_slot2_state = RECORDREAD_RESPONSE;
    			g_uc_state = UC_IDLE;
                        t1_StartCommand(SLOT_2, cmd, 0, block, 0x1B);
    			break;


    case RECORDREAD_RESPONSE:
    			/** Deal with the response **/
    			retval = com_DealWithReadRecord();
                        serial_write_byte(iOutputStream, ACK);
    			if(retval == -2)
    			{
    			  /** Reissue the last read **/
                          cmd[0] = 0x00;
                          cmd[1] = 0xB2;
                          cmd[2] = g_record; /*Record*/
                          cmd[3] = 0xD4;
                          block[0] = 0x1B;
			  if(g_slot2_state == IDLE) break; /** Check card in at last possible moment **/
    			  g_slot2_state = RECORDREAD_RESPONSE;
      			  g_uc_state = UC_IDLE;
                          t1_StartCommand(SLOT_2, cmd, 0, block, 0x1B);
      			  break;
    			}
    			else if(retval == -1)
    			{
    			  /** Error of some sort. Tidy up and leave **/
    			  g_slot2_state = IDLE;
    			  g_uc_state = UC_IDLE;
    			  return;
    			}

    			g_record++;
    			/** If it was the last one... **/
    			if(g_record == 8)
    			{
    			  g_record = 1; /** Reset :-) */
    			  g_uc_state = UC_IDLE;
    			  g_slot2_state = IDLE;
    			  g_slot2datablock_state = SCI_SUCCESS;
    			}
    			else
    			{
    			  /** Send the next one **/
                          cmd[0] = 0x00;
                          cmd[1] = 0xB2;
                          cmd[2] = g_record; /*Record*/
                          cmd[3] = 0xD4;
                          block[0] = 0x1B;
//                          com_SendFunaiHeader(SLOT_2, CMD_APDU);
			  if(g_slot2_state == IDLE) break; /** Check card in at last possible moment **/
    			  g_slot2_state = RECORDREAD_RESPONSE;
      			  g_uc_state = UC_IDLE;
                          t1_StartCommand(SLOT_2, cmd, 0, block, 0x1B);
    			}
    			break;

    default:
    			break;
  }
}


/*
 *  com_DealWithVerify - Reads the response from the uC to Verify, and decodes
 *  			 it. If it's bad for any reason, returns -1, and sets
 *			 g_slot2datablock_state if required
 */ 
int
com_DealWithVerify
(
  void
)
{
  BYTE	data[5]; /** Max should be 5 **/
  data[0] = blocking_readbyte();
  data[1] = blocking_readbyte();
  data[2] = blocking_readbyte(); /* Length of following data */
//  printf("VERIFY 0,1,2 &%02X, &%02X, &%02X\n",data[0],data[1],data[2]);
  if(data[1] && 0x80)
  {
    /** R-blk, so some sort of error **/
//    printf("Error RBlk\n");
    return(-2);
  }
  if(data[2] != 2)
  {
    /** SHOULD READ THE DATA HERE **/
    g_slot2datablock_state = SCI_E_BADCARD; /* It confused me... */
    return(-1);
  }
  data[3] = blocking_readbyte();
  data[4] = blocking_readbyte();
 // printf("VERIFY 3,4 &%02X, &%02X\n",data[3],data[4]);
  if( (data[3] != 0x90) | (data[4] != 0x00) )
  { 
    g_slot2datablock_state = SCI_E_NOTURL;  /* Didn't like the PIN */
    return(-1);
  }
  return(0);
}


/*
 *  com_DealWithReadRecord - Reads the response from the uC to ReadRecord, and
 *			     decodes it. If it's bad, sets g_slot2datablock_state
 *			     and returns -1
 */ 
int
com_DealWithReadRecord
(
  void
)
{
  BYTE	data[50];
  unsigned char	*dest;
  int	i;

  /** Read the header, and then the rest of the data **/
  data[0] = blocking_readbyte();
  data[1] = blocking_readbyte();
  data[2] = blocking_readbyte(); /* Length of following data */
//  printf("READRECORD 0,1,2 &%02X, &%02X, &%02X\n",data[0],data[1],data[2]);
  if(data[1] > 0x80)
  {
    /** R-blk, so some sort of error **/
//    printf("Error RBlk\n");
    return(-2);
  }
  if(data[2] != 0x1d)
  {
    /** SHOULD READ THE DATA HERE? **/
    
    g_slot2datablock_state = SCI_E_BADCARD;
    return(-1);
  }
  
  for(i=0; i<= 0x1d; i++) /* one extra for the checksum */
  {
    data[i+3] = blocking_readbyte();
//    printf("&%02X ",data[i+3]);
  }
//  printf("i,SW1,SW2: %d,&%02X,&%02X\n",i,data[i],data[i+1]);
  if( (data[i] != 0x90) | (data[i+1] != 0x00) )
  { 
    g_slot2datablock_state = SCI_E_BADCARD;  /* Didn't like the data */
    return(-1);
  }
  /** Header gone, now copy the data across **/
//  printf("g_slot2datablock = &%08X\n",(unsigned int)g_slot2datablock);
  dest = g_slot2datablock + ((7-g_record)*25);
//  printf("dest = &%08X\n",(unsigned int)dest);
  memcpy(dest, data+5, data[2]-4);
  return(0);
}


/*
 *  com_GetATR - Gets the ATR off the card in slot2, and ditches it.
 */ 
int
com_GetATR
(
  void
)
{
#if FALSE
  int	retval = 0;
  
  if( blocking_readbyte()        != 0x3B) retval = -1; /** TS **/
  if( (t0 = blocking_readbyte()) != 0xE0) retval = -1; /** T0 **/

  if(t0 & 0x10)
  {
    /** We read TA1 as next byte **/
    dummy = blocking_readbyte();
    retval = -1; /** No TA1 in the real thing **/
  }
  if(t0 & 0x20)
  {
    /** We read TB1 as next byte **/
    if(blocking_readbyte() != 0x00) retval = -1;
  }
  if(t0 & 0x40)
  {
    /** We read TC1 as next byte **/
    if(blocking_readbyte() != 0xFF) retval = -1;
  }
  if(t0 & 0x80)
  {
    if( (t0 = blocking_readbyte()) != 0x81) retval = -1; /* TD1 */
    tck_exp = (t0 && 0x01); /* T=1 indicates TCK expected at end */
  }
  
  return(retval);
#endif
  if( blocking_readbyte() != 0x3B) return(-1);
  if( blocking_readbyte() != 0xE0) return(-1);
  if( blocking_readbyte() != 0x00) return(-1);
  if( blocking_readbyte() != 0xFF) return(-1);
  if( blocking_readbyte() != 0x81) return(-1);
  if( blocking_readbyte() != 0xB1) return(-1);
  if( blocking_readbyte() != 0x25) return(-1);
  if( blocking_readbyte() != 0x45) return(-1);
  if( blocking_readbyte() != 0x01) return(-1);
  if( blocking_readbyte() != 0x4E) return(-1);

  return(0);
}
#endif
