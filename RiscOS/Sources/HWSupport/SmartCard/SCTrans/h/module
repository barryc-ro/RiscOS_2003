/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

#ifndef __module_h
#define __module_h

#include "kernel.h"
#include "debug/remote.h"

#ifdef REMOTE_DEBUG
extern debug_session *db;
#else
extern void *db;
#endif

#define BOOL   int
#define TRUE   (1)
#define FALSE  (0)
#define DWORD  int
#define WORD   int

/*
 * event handling declarations
 */
#define UpCallV 0x1d
#define EventV	0x10

#define UpCall_DeviceRxDataPresent (15)
#define UpCall_DeviceThresAbove    (16)
#define UpCall_DeviceThresBelow    (17)

#define Event_Expansion		    (21)
#define Event_Expansion_SCTransport (1)
#define Event_RS423Error 	    (7)

#define Service_SCTransportStarting (0xbb)

#define flag_event_pending     (1<<0) /* set when processing events */
#define flag_timeout_pending   (1<<1) /* set when timeout timer is setup */
#define flag_timeout_to_handle (1<<2) /* set, timeout fired but not processed */
#define flag_initialised       (1<<3) /* set, after post-init */
#define flag_debouncing	       (1<<4) /* set if currently debouncing */
#define flag_data_pending      (1<<5) /* set to defer data until after bounce */
#define flag_dsr_state	       (1<<6) /* set when dsr is active */

typedef enum { SC_Event_Nothing,           /* 0 */
	       SC_Event_DataPresent,	   /* 1 */
	       SC_Event_Timeout,	   /* 2 */
	       SC_Event_SerialError,	   /* 3 */
	       SC_Event_CardIn,		   /* 4 */
	       SC_Event_CardOut		   /* 5 */
	       } t_sctrans_events;

#define SerialEvent_Parity         (1<<5)
#define SerialEvent_Overrun	   (1<<4)
#define SerialEvent_Framing	   (1<<3)
#define SerialEvent_DSR		   (1<<2)
#define SerialEvent_DCD		   (1<<1)
#define SerialEvent_Error 	   (SerialEvent_Parity| \
				   SerialEvent_Overrun| \
				   SerialEvent_Framing)

/*
 * normal module junk
 */
#define ERR_RETURN(err,stmt)   {err = (stmt); if (err) return err;}
#define ERR_GOTO(err,stmt)     {err = (stmt); if (err) goto exit_gracefully;}
#define NOT_USED(v)            ((v)=(v))
#define CLEAR_FLAG(f,b)        (f &= ~b)
#define SET_FLAG(f,b)          (f |= b)


#define TinySupport_Init        0x82c40
#define TinySupport_Die         0x82c41
#define TinySupport_Init2       0x82c42
#define TinySupport_Share       0x82c43

#define ERROR_NOTINIT          (SCTransport_00+0)
#define ERROR_MEMFAIL	       (SCTransport_00+1)

#define ERROR_STRUCT(name,text) \
  static struct {int errnum; char errmess[sizeof(text)+1];} name = {ERROR_##name,text}

#define ERROR_EXTERN(name) extern struct {int errnum; char errmess[1];} name

#define ERROR(e)  ((_kernel_oserror *)&(e))

void DebugFileInit(char*filename);

#endif
