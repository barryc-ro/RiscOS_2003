/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

/*
 * To define those constants and data definitions required within the modules
 * comprising this system but not required to be visible to the user of the API.
 */

/* constants */

#define MAX_CARD_CHANNELS 10
#define	SCI_FREE_CHANNEL  -1

/* internal system states */
#define S_S_CLOSED	1	/* waiting for initialisation */
#define S_S_STARTING	2	/* initialised, waiting for first open */
#define S_S_OPENING	3	/* waiting for answer-to-reset */
#define S_S_OPEN	4	/* ATR received and waiting to be read */
#define S_S_CMD		5	/* command in progress */
#define S_S_USER	6	/* response received, waiting for user to read */
#define S_S_FAILED	7	/* system in failed state */
#define S_S_REMOVED	8	/* the card has been removed */

/* internal connection states */
#define S_C_UNUSED	11	/* connection unused */
#define S_C_OPENING	12	/* initiated open */
#define S_C_OPEN	13	/* ATR read by user */
#define S_C_CMD		14	/* command in progress */
#define S_C_USER	15	/* response received, waiting for user to read */
#define S_C_FAILED	16	/* connection in failed state */
#define S_C_REMOVED	17	/* the card has been removed */

#define ATR_INIT_WAIT	100	/* initial max wait time for ATR receipt (cs) */

#define SYS_TIMER_ID	101	/* timer id for SetTimer() */

#define MAX_XMIT_BUF	272	/* transmission buffer length */
#define MAX_RCV_BUF	272	/* reception buffer length */

/* macros */

/* set errno and return an error */
#define RETERR_CHAN(C,X) { sci_Errno = (X);  \
		      if ((C)>-1 && (C)<MAX_CARD_CHANNELS && (ChannelTable[(C)].flags & channel_in_use)) ChannelTable[(C)].last_err = (X);  \
		      return(SCI_FAIL); }

#define RETERR(X)   { sci_Errno = (X); return(SCI_FAIL); }

/* for debugging purposes */
#ifdef _DEBUG
#define debugging	1
#else /* not _DEBUG */
#define debugging	0
#endif /* _DEBUG */
#define debug	if (!debugging); else

/* custom data types */

/* connection data structure */
typedef struct
{
  int  last_err;	/* last error code which occurred on this connection */
  int  state;		/* connection state */
  int  flags;		/* channel flags */
} t_channel;

#define channel_locked      (1<<0) /* is channel holding transaction lock? */
#define channel_wait_unlock (1<<1) /* is channel waiting for unlock */
#define channel_in_use	    (1<<2) /* channel is in use otherwise */
#define channel_async	    (1<<3) /* channel uses async notification */

/* declaration of global data */
extern int sci_Errno;		/* last error code */

/* connection table */
extern t_channel ChannelTable[MAX_CARD_CHANNELS];  /* channel table */
extern int current_channel;	/* connection currently being processed */

extern BOOL sci_Locked;		/* is a protected transaction in progression
				   set by sci_StartTrans() */

extern BYTE sci_HistData[SCI_HIST_LEN];		/* historical data from ATR */
extern int sci_HistLen;		/* length of historical data */
extern int sci_State;		/* system state */
extern int AtrState;
extern int t0_State;

extern int WorkWaitTime;	/* max allowed time between incoming bytes */

#ifdef _WINDOWS
extern HANDLE sci_Instance;
extern HWND sci_Window;

extern char Diag[256];
#endif /* _WINDOWS */

/* declaration of global functions */
/* API initialisation */
int sci_Init (void);

/* functions which invoke operating system services */
int sys_SignalTask (int channel, int reason);
#ifndef ARM
BOOL sys_TaskValid (HTASK task_id);
#endif /* ARM */
BYTE *sys_Malloc (int len);
BYTE *sys_Realloc (BYTE * old, int len);
void sys_Free (BYTE * buff);
int sys_Init (void);
void sys_DiscardEvents (void);
void sys_Delay (UINT n);
void sys_StartWaitTimer (int wait_time);
void sys_CancelWaitTimer (void);

/* functions which handle answer to reset sequence */
int atr_Start (BOOL reset);
int atr_Error (int err);
int atr_ProcessByte (BYTE ch);

/* functions which handle T=0 smart card protocol */
int t0_StartCommand (BYTE FAR * cmd_hdr, int data_len,
		     BYTE FAR * data, int exp_len);
int t0_ProcessByte (BYTE ch);
int t0_GetData (BYTE FAR * buff, int buff_len, int FAR * rcv_len,
		BYTE FAR * resp);
int t0_CardStatusChange (BOOL card_in);
int t0_Error (int err);
int t0_OutputSent (void);
int t0_ScipError (void);
void t0_Close (void);
BOOL t0_Init (void);

/* functions which handle card connections */
void chan_Init(int channel);
int  chan_GetNew(void);

/* functions which interface to the serial communications sub-system */
int com_Init (void);
int com_ReadBytes (BYTE * ch, int len);
int com_SendBytes (BYTE * data, int len);
void com_FlushComms (void);
int com_HandleCommsEvent (int event);
int com_SetResetInd (void);
BOOL com_RestartInvProtocol (void);
BOOL com_CardIn (void);
void com_Close (void);

/* debugging function */
void DebugPrint (char *format,...);
