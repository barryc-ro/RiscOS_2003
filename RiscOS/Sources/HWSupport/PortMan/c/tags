#include <string.h>
#include <stdlib.h>

#include "module.h"
#include "tags.h"
#include "msgfile.h"
#include "PortMan.h"
#include "messages.h"

#define TAGS_FILE "Resources:$.Resources.PortMan.Tags"

static struct msgfile tagsfile = MSGFILE_INIT;

/*
 * Get an integer from *str, updating *str to point to the end.  Returns
 * 1 (true) if an integer was read.
 */
static
int
get_int(const char **str, unsigned long *result)
{
  const char *begin;

  if(*str==NULL)
  {
    *result=0;
    return 0;
  }

  /* Skip whitespace */
  *str+=strspn(*str, " \t");

  switch(**str)
  {
  case '\r': case '\n': case 0:
    *result=0;
    return 0;
  case '&':
    *result=strtoul(begin=*str+1, (char**)str, 16);
    break;
  default:
    *result=strtoul(begin=*str, (char**)str, 0);
    break;
  }
  return *str!=begin;
}

/*
 * Gets a field separator from *str, updating *str to point to the end of
 * the separator.  Returns 1 (true) if a separator was read.  Sets *str
 * to NULL on error.
 */

static
int
get_sep(const char **str)
{
  if(*str==NULL)
    return 0;

  /* Skip whitespace */
  *str+=strspn(*str, " \t");

  switch(**str)
  {
  /* End of line */
  case '\r': case '\n': case 0:
    return 0;
  case ':':
    ++*str;
    return 1;
  default:
    *str=NULL;
    return 0;
  };
}

/* Format of line:
 *   <bit>:[port]:[flags]
 */
 
static
_kernel_oserror *
parse_line(struct bitdef *bit, const char *line)
{
  unsigned long num;

  /* Gobble the bit number */
  if(!get_int(&line, &num))
    return msgfile_error_lookup(&messages, PortMan_BadTag, BadLine);

  bit->num=(int)num;

  /* Fill in the defaults. */
  bit->flags=0;

  /* Gobble the separator */
  if(!get_sep(&line))
  {
    if(line==NULL)
      return msgfile_error_lookup(&messages, PortMan_BadTag, BadLine);
    return NULL;
  }

  /* Get and check port number */
  if(get_int(&line, &num) && num!=0)
  {
    return msgfile_error_lookup(&messages, PortMan_BadTag, BadLine);
  }

  /* Gobble the separator */
  if(!get_sep(&line))
  {
    if(line==NULL)
      return msgfile_error_lookup(&messages, PortMan_BadTag, BadLine);
    return NULL;
  }

  /* Get the flags */
  if(get_int(&line, &num))
    bit->flags=(int)num;

  /* Check for errors at the end of the line */
  get_sep(&line);

  if(line==NULL)
    return msgfile_error_lookup(&messages, PortMan_BadTag, BadLine);
  return NULL;
}

_kernel_oserror *
tag_get(struct bitdef *result, const char *name)
{
  _kernel_oserror *err;
  const char *line;

  err=msgfile_open( &tagsfile, TAGS_FILE );
  if(err)
    return err;

  err=msgfile_lookup( &tagsfile, &line, name );
  if(err)
    return err;

  return parse_line(result, line);
}

void tag_close(void)
{
  msgfile_close( &tagsfile );
}
