/************************************************************************/
/*                  Copyright 1997 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/
#include <stdlib.h>
#include "swis.h"
#include "Global/Services.h"

#ifdef STANDALONE
#include "saheader.h"
#else
#include "header.h"
#endif

#include "resfiles.h"
#include "module.h"
#include "msgfile.h"
#include "tags.h"
#include "PortMan.h"

#if CMHG_VERSION < 516
#define CMHG_CONST
#else
#define CMHG_CONST const
#endif

#define UNUSED(x) ((x)=(x))

#define IOMD_CLINES (*(unsigned int*)0x0320000c)

static int clines_softcopy=0xff;
struct msgfile messages = MSGFILE_INIT;


/**** Port access functions **********************************************/

static unsigned int modify_clines(unsigned int mask, unsigned int toggle)
{
  int res;
  int irq_state=_kernel_irqs_disabled();
  
  /* Turn interrupts off round the atomic bit. */
  _kernel_irqs_off();
  res=clines_softcopy;
  /* Update the soft copy */
  clines_softcopy = ( res & mask ) ^ toggle;
  /* Write to the hardware */
  IOMD_CLINES=clines_softcopy;
  if(!irq_state)
    _kernel_irqs_on();

  /* Return the old value. */
  return res;
}

static _kernel_oserror *modify_bit(int flags, const char *name, int *result)
{
  _kernel_oserror *err;
  struct bitdef bit;
  unsigned int mask=0, toggle=0;
  unsigned int value;
  
  err=tag_get(&bit, name);
  if(err)
    return err;

  if(bit.flags & TAG_FLAGS_OUTPUT)
  {
    mask=flags&PORTMAN_FLAG_CLEAR?1:0;
    toggle=flags&PORTMAN_FLAG_TOGGLE?1:0;
    if((flags & PORTMAN_FLAG_CLEAR) && (bit.flags & TAG_FLAGS_INVERTED))
      toggle^=1;
  }
  value=modify_clines(~(mask<<bit.num), toggle<<bit.num) >> bit.num;
  *result=(value&1) | (((value&!mask)^toggle)<<1);
  return NULL;
}

/**** General module functions *******************************************/

_kernel_oserror *
module_finalise(int fatal, int podule, void *pw)
{
  msgfile_close( &messages );
  tag_close();

#ifdef STANDALONE
  resfiles_final();
#endif

  return NULL;
}

_kernel_oserror *
module_initialise(CMHG_CONST char *cmd_tail, int podule_base, void *pw)
{
  IOMD_CLINES=clines_softcopy;

#ifdef STANDALONE
  resfiles_init();
#endif

  msgfile_open( &messages, Module_MessagesFile );

  return (NULL);
}

_kernel_oserror *
module_swi(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  UNUSED(pw);

  switch(swi_offset+PortMan_00)
  {
  case PortMan_AccessBit:
    return modify_bit(r->r[0], (const char *)(r->r[1]), r->r+0);

  default:
    return error_BAD_SWI;
  }
}

#ifdef STANDALONE
void module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
  UNUSED(pw);

  switch(service_number)
  {
  case Service_ResourceFSStarting:
    resfiles_service(r->r[3], r->r[2]);
    return;

  case Service_ResourceFSStarted:
    msgfile_close( &messages );
    tag_close();
    return;
  }
}
#endif
