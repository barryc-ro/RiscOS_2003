/* > led.c
 *
 *	  LED code.
 */

#include <stdlib.h>
#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "led.h"
#include "veneer.h"
#include "iomd.h"
#include "error.h"


static unsigned int Flags = 0;
static led LEDs[ LED_COUNT ];


static void
SetLED( led *pled )
{
	/* Must only update IOLINES with IRQs off. */
	int old_irqs = veneer_irqs_off();

	/* Get current IOLINES and or in inputs so we don't break anything. */
	int iolines = (*(char *)IOMD_IOLINES) | IOMD_IOLINES_INPUTS;

	/* Set what we think should be the current state. */
	iolines = (pled->flags & LED_ON_FLAG) ? (iolines | pled->control_bit) : (iolines & ~pled->control_bit);

	*(char *)IOMD_IOLINES = iolines;

	/* Restore interrupts. */
	veneer_irqs_on( old_irqs );
}


void
ClaimTicker( void *pw )
{
	/* Claim TickerV if we don't have it already. */
	if ( !(Flags & LED_TICKER_CLAIMED_FLAG) )
	{
		_swix( OS_Claim, _INR(0,2), TICKERV, veneer_ticker, pw );
		Flags |= LED_TICKER_CLAIMED_FLAG;
	}
}


void
ReleaseTicker( void *pw )
{
	/* Release TickerV if we have it claimed. */
	if ( Flags & LED_TICKER_CLAIMED_FLAG )
	{
		_swix( OS_Release, _INR(0,2), TICKERV, veneer_ticker, pw );
		Flags &= ~LED_TICKER_CLAIMED_FLAG;
	}
}


static void
ClaimOrReleaseTicker( void *pw )
{
	int i;
	led *pled;

	/* Check for flashing LEDs and grab TickerV if there are any. */
	for ( i = 0, pled = LEDs; i < LED_COUNT; i++, pled++ )
	{
		/* Only concerned with flashing LEDs with flash_rate > 0. */
		if ( (pled->flags & LED_FLASHING_FLAG) && (pled->flash_rate != 0) )
		{
			ClaimTicker( pw );
			return;
		}
	}
	/* No LEDs flashing so make sure we don't have TickerV. */
	ReleaseTicker( pw );
}


void
led_ticker( _kernel_swi_regs *r, void *pw )
{
	int i;
	led *pled;

	/* Look for flashing LEDs. */
	for ( i = 0, pled = LEDs; i < LED_COUNT; i++, pled++ )
	{
		/* Only concerned with flashing LEDs with flash_rate > 0. */
		if ( (pled->flags & LED_FLASHING_FLAG) && (pled->flash_rate != 0) )
		{
			/* Check if it's time to change. */
			if ( pled->flash_count-- == 0 )
			{
				/* Invert the ON flag, reset the count and set the LED to the new state. */
				pled->flags ^= LED_ON_FLAG;
				pled->flash_count = pled->flash_rate;
				SetLED( pled );
			}
		}
	}
}


_kernel_oserror *
led_initialise( void *pw )
{
#ifdef Boca
	/* Set up data for both LEDs and turn them both off. */
	LEDs[0].flags = 0;
	LEDs[0].control_bit = IOMD_IOLINES_LEFTLED;
	LEDs[0].flash_rate = 0;
	LEDs[0].flash_count = 0;
	SetLED( &LEDs[0] );

	LEDs[1].flags = 0;
	LEDs[1].control_bit = IOMD_IOLINES_RIGHTLED;
	LEDs[1].flash_rate = 0;
	LEDs[1].flash_count = 0;
	SetLED( &LEDs[1] );
#else
        /* Effectively only one LED in model 1 h/w. */
        LEDs[0].flags = 0;
        LEDs[0].control_bit = IOMD_IOLINES_LED;
        LEDs[0].flash_rate = 0;
	LEDs[0].flash_count = 0;
	SetLED( &LEDs[0] );
#endif
	return NULL;
}


void
led_finalise( void *pw )
{
	/* Turn both LEDs off. */
	LEDs[0].flags = 0;
	SetLED( &LEDs[0] );

#ifdef Boca
	LEDs[1].flags = 0;
	SetLED( &LEDs[1] );
#endif

	/* Release TickerV if necessary. */
	ReleaseTicker( pw );
}


_kernel_oserror *
led_control( _kernel_swi_regs *r, void *pw )
{
	/* Make sure LED number is in range. Doesn't seem worth returning an error if not... */
	if ( (unsigned int)r->r[0] < LED_COUNT )
	{
		/* Set new flags and return old flags in r0. */
		led *pled = &LEDs[r->r[0]];
		unsigned int new_flags = (pled->flags & (unsigned int)r->r[1]) | (unsigned int)r->r[2];
		r->r[0] = pled->flags = new_flags;

		/* Set the LED to the new state and claim or release TickerV if necessary. */
		SetLED( pled );
		ClaimOrReleaseTicker( pw );
	}
	return NULL;
}


_kernel_oserror *
led_flashrate( _kernel_swi_regs *r, void *pw )
{
	/* Make sure LED number is in range. Doesn't seem worth returning an error if not... */
	if ( (unsigned int)r->r[0] < LED_COUNT )
	{
		/* Set new rate and return old rate in r1. */
		led *pled = &LEDs[r->r[0]];
		int old_rate = pled->flash_rate;
		if ( r->r[1] != 0 ) pled->flash_count = pled->flash_rate = (unsigned int)r->r[1];
		r->r[1] = old_rate;

		/* Claim or release TickerV if necessary. */
		ClaimOrReleaseTicker( pw );
	}
	return NULL;
}
