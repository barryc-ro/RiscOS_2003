/* > led.c
 *
 *	  LED code.
 */

#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "led.h"
#include "veneer.h"
#include "iomd.h"
#include "error.h"

                                            
static unsigned int Flags = 0;
static led LEDs[ LED_COUNT ];


static void
SetLED( led *pled )
{
	/* Must only update IOLINES with IRQs off. */
	int old_irqs = veneer_irqs_off();

	/* Get current IOLINES and or in inputs so we don't break anything. */
	int iolines = (*(char *)IOMD_IOLINES) | IOMD_IOLINES_INPUTS;

	/* Set what we think should be the current state. */
#if defined (Boca)
	iolines = (pled->flags & LED_ON_PRIVATE) ? (iolines | pled->control_bit) : (iolines & ~pled->control_bit);
#elif defined (Funai)
	/*  Funai NC2 has the sense of the left LED inverted wrt the right LED!
         */
        if (pled == &LEDs[1])
		iolines = (pled->flags & LED_ON_PRIVATE) ? (iolines & ~pled->control_bit) : (iolines | pled->control_bit);
	else
		iolines = (pled->flags & LED_ON_PRIVATE) ? (iolines | pled->control_bit) : (iolines & ~pled->control_bit);
#else
	iolines = (pled->flags & LED_ON_PRIVATE) ? (iolines & ~pled->control_bit) : (iolines | pled->control_bit);
#endif

	*(char *)IOMD_IOLINES = iolines;

	/* Restore interrupts. */
	veneer_irqs_on( old_irqs );
}


void
ClaimTicker( void *pw )
{
	/* Claim TickerV if we don't have it already. */
	if ( !(Flags & LED_TICKER_CLAIMED_FLAG) )
	{
		_swix( OS_Claim, _INR(0,2), TICKERV, veneer_ticker, pw );
		Flags |= LED_TICKER_CLAIMED_FLAG;
	}
}


void
ReleaseTicker( void *pw )
{
	/* Release TickerV if we have it claimed. */
	if ( Flags & LED_TICKER_CLAIMED_FLAG )
	{
		_swix( OS_Release, _INR(0,2), TICKERV, veneer_ticker, pw );
		Flags &= ~LED_TICKER_CLAIMED_FLAG;
	}
}


static void
ClaimOrReleaseTicker( void *pw )
{
	int i;
	led *pled;

	/* Check for flashing LEDs and grab TickerV if there are any. */
	for ( i = 0, pled = LEDs; i < LED_COUNT; i++, pled++ )
	{
		/* Only concerned with flashing LEDs with flash_rate > 0. */
		if ( (pled->flags & LED_FLASHING_FLAG) && (pled->flash_rate != 0) )
		{
			ClaimTicker( pw );
			return;
		}
	}
	/* No LEDs flashing so make sure we don't have TickerV. */
	ReleaseTicker( pw );
}


static char *
SkipSpaces( char *cp )
{
	while ( *cp == ' ' ) cp++;
	return cp;
}


/* Define our own function for lowercasing characters as the __ctype	*/
/* does not seem to be set correctly when sharing C library statics	*/
/* via TinyStubs.							*/
static char
Lower( char c )
{
	return ((c < 'A') || (c > 'Z')) ? c : c - 'A' + 'a';
}

 
/* Perform case insensitive string comparison - returns true if the same */
/**/
static int
StrNoCaseCmp( char *str1, char *str2 )
{
	/* Only need to check for one string terminator as the second condition	*/
	/* catches the other string terminating when the first does not.	*/
	while ( (*str1 != '\0') && (Lower(*str1) == Lower(*str2)) )
	{
		str1++; str2++;
	}

	/* Return true if the strings are the same. */
	return (*str1 == '\0') && (*str2 == '\0');
}


void
led_ticker( _kernel_swi_regs *r, void *pw )
{
	int i;
	led *pled;

	/* Look for flashing LEDs. */
	for ( i = 0, pled = LEDs; i < LED_COUNT; i++, pled++ )
	{
		/* Only concerned with flashing LEDs with flash_rate > 0. */
		if ( (pled->flags & LED_FLASHING_FLAG) && (pled->flash_rate != 0) )
		{
			/* Check if it's time to change. */
			if ( pled->flash_count-- == 0 )
			{
				/* Invert the ON flag, reset the count and set the LED to the new state. */
				pled->flags ^= LED_ON_PRIVATE;
				pled->flash_count = pled->flash_rate;
				SetLED( pled );
			}
		}
	}
}


_kernel_oserror *
led_initialise( void *pw )
{
	/* Set system variable to allow LED control from HTML pages. */
	_swix( OS_SetVarVal, _INR(0,4), LED_VAR, LED_VARVAL, LED_VARVALLEN, 0, 0 );

#if defined(Boca) || defined(Funai)
	/* Set up data for both LEDs and turn them both off. */
	LEDs[0].flags = 0;
	LEDs[0].control_bit = IOMD_IOLINES_LEFTLED;
	LEDs[0].flash_rate = LEDs[0].flash_count = LED_DEFAULT_FLASH_RATE;
	SetLED( &LEDs[0] );

	LEDs[1].flags = 0;
	LEDs[1].control_bit = IOMD_IOLINES_RIGHTLED;
	LEDs[1].flash_rate = LEDs[1].flash_count = LED_DEFAULT_FLASH_RATE;
	SetLED( &LEDs[1] );
#else
        /* Effectively only one LED in model 1 h/w. */
        LEDs[0].flags = 0;
        LEDs[0].control_bit = IOMD_IOLINES_LED;
        LEDs[0].flash_rate = LEDs[0].flash_count = LED_DEFAULT_FLASH_RATE;
	SetLED( &LEDs[0] );
#endif
	return NULL;
}


void
led_finalise( void *pw )
{
	/* Turn both LEDs off. */
	LEDs[0].flags = 0;
	SetLED( &LEDs[0] );

#if defined(Boca) || defined(Funai)
	LEDs[1].flags = 0;
	SetLED( &LEDs[1] );
#endif

	/* Release TickerV if necessary. */
	ReleaseTicker( pw );
}


_kernel_oserror *
led_control( _kernel_swi_regs *r, void *pw )
{
/* On Omega ignore all LED numbers other than 1 and set that to 0. (NB: Standby uses 1) */
#ifdef Omega
	if ((unsigned int)r->r[0] != 1)
		r->r[0] = 1;
	else
		r->r[0] = 0;
#endif
	/* Make sure LED number is in range. Doesn't seem worth returning an error if not... */
	if ( (unsigned int)r->r[0] < LED_COUNT )
	{
		led *pled = &LEDs[r->r[0]];
		unsigned int new_flags, changed;

		/* Make sure we don't change private flags. */
		r->r[1] |= ~LED_PUBLIC_FLAGS;
		r->r[2] &= LED_PUBLIC_FLAGS;

		/* Work out new flags. */
		new_flags = (pled->flags & r->r[1]) | r->r[2];

		/* Work out what has changed. */
		changed = pled->flags ^ new_flags;

		/* Only do low level stuff if any flags have changed. */
		if ( changed )
		{
			/* If ON state changed and not flashing or flashing is turned off */
			/* then reflect ON state in LED immediately.                      */
			if ( ((changed & LED_ON_FLAG) && !(pled->flags & LED_FLASHING_FLAG))
				|| ((changed & LED_FLASHING_FLAG) && !(new_flags & LED_FLASHING_FLAG)) )
			{
				new_flags &= ~LED_ON_PRIVATE;
				if ( new_flags & LED_ON_FLAG ) new_flags |= LED_ON_PRIVATE;
			}

			/* Set new flags. */
			pled->flags = new_flags;

			/* Set the LED to the new state and claim or release TickerV if necessary. */
			SetLED( pled );
			ClaimOrReleaseTicker( pw );
		}

		/* Return new flags in r0. */
		r->r[0] = new_flags & LED_PUBLIC_FLAGS;
	}
	return NULL;
}


_kernel_oserror *
led_flashrate( _kernel_swi_regs *r, void *pw )
{
	/* Make sure LED number is in range. Doesn't seem worth returning an error if not... */
	if ( (unsigned int)r->r[0] < LED_COUNT )
	{
		/* Set new rate and return old rate in r1. */
		led *pled = &LEDs[r->r[0]];
		int old_rate = pled->flash_rate;
		if ( r->r[1] != 0 ) pled->flash_count = pled->flash_rate = (unsigned int)r->r[1];
		r->r[1] = old_rate;

		/* Claim or release TickerV if necessary. */
		ClaimOrReleaseTicker( pw );
	}
	return NULL;
}

void
led_set( char *args, void *pw )
{
	/* Find first parameter. */
	args = SkipSpaces( args );
	if ( *args != '\0' )
	{
		/* First parameter is LED number. */
		int led_no = atoi( args );
		args = strchr( args, ' ' );
		if ( args != NULL )
		{
			/* Find second parameter. */
			args = SkipSpaces( args );

			if ( *args != '\0' )
			{
				_kernel_swi_regs r;

				/* Set up registers for led_control. */
				r.r[0] = led_no;
				r.r[1] = ~LED_ON_FLAG;				/* Assume change on/off state. */
				if ( StrNoCaseCmp(args, "on") )
					r.r[2] = LED_ON_FLAG;			/* Turn LED on. */
				else
				{
					if ( StrNoCaseCmp(args, "off") )
						r.r[2] = 0;			/* Turn LED off. */
					else
					{
						int flash_rate = atoi( args );	/* Read given flash rate. */
						_kernel_swi_regs r2;

						r2.r[0] = led_no;		/* Set flash rate. */
						r2.r[1] = flash_rate;
						led_flashrate( &r2, pw );

						r.r[1] = ~LED_FLASHING_FLAG;	/* Just change flash state. */
						/* Turn off/on flashing appropriately. */
						r.r[2] = (flash_rate == 0) ? 0 : LED_FLASHING_FLAG;
					}
				}
				led_control( &r, pw );
			}
		}
	}
}
