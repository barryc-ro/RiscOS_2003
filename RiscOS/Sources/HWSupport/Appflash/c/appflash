#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "appflash.h"
#include "error.h"

/* The number of words in the flash image */
//#define Flash_Num_Words         0x100000 /* 4 meg */
#define Flash_Num_Words         0x080000u  /* 2 meg */

/* Addresses */
#define Flash_Base   0x03C00000u    /* Address of the base of the flash. Top of ROM 1 space. */
//#define Flash_Base   0x03800000u  /* Address of the base of the flash. Top of ROM 0 space. */

#define ROMCR0       0x03200080u /* Address of the ROMCR0 register */

/* Offsets */
#define Flash_CommandReg1_Offset      (0x5555u << 2)
#define Flash_CommandReg2_Offset      (0x2AAAu << 2)
#define Flash_Manufacturer_ID_Offset   0x0000u
#define Flash_Device_ID_Offset        (0x0001u << 2)

/* 16bit word masks, replicated to 32 bits */
#define DQ7_Top      0x00800000u
#define DQ7_Bottom   0x00000080u
#define DQ5_Top      0x00200000u
#define DQ5_Bottom   0x00000020u

/******************************************************************/
/* 29F800x-compatible commands (16bit-wide, replicated to 32bits) */

/* Command sequence for writing a word of data */
#define Write1       0x00AA00AAu
#define Write2       0x00550055u
#define Write3       0x00A000A0u

/* Command sequence for erasing the whole chip */
#define ChipErase1   0x00AA00AAu
#define ChipErase2   0x00550055u
#define ChipErase3   0x00800080u
#define ChipErase4   0x00AA00AAu
#define ChipErase5   0x00550055u
#define ChipErase6   0x00100010u

/* Command sequence for getting id codes from chip */
#define Autoselect1  0x00AA00AAu
#define Autoselect2  0x00550055u
#define Autoselect3  0x00900090u

/* Command to reset chip to read mode */
#define Reset        0x00F000F0u

/* Assembler routines */
extern void asm_write_enable (void *);
extern void asm_write_disable (void *);

/* Local functions */
static  int appflash_verify_checksum (FILE *, char);
static  int appflash_verify_flash_write (FILE *, char);
static  int appflash_verify_flash_erase (void);
static void appflash_get_id_codes (unsigned int *, unsigned int *, char);
static  int appflash_data_poll (unsigned int *volatile, unsigned int);
static  int appflash_write_image (FILE *fp, char);
static  int appflash_erase (void);
static  int my_printf (char, const char *, ...);

/**********************/
/* Exported functions */

/*
 *
 * SWI Appflash_Checksum (0x50a01)
 *
 * OUT     R0  -  Return code:
 *                    0      OK
 *                    1      Fail
 */
_kernel_oserror *appflash_verify_flashrom_swi (_kernel_swi_regs *r)
{
  int i;

  unsigned int *volatile flash = (unsigned int *) Flash_Base;
  unsigned int sum = 0;

  for (i = 0; i < (Flash_Num_Words - 2); i++)
    sum += flash[i];

  if (sum != 0)
    /* Error */
    r->r[0] = AppFlash_Checksum_Fail;
  else
    /* OK */
    r->r[0] = AppFlash_Checksum_OK;

  return NULL;
}

/*
 *
 * SWI Appflash_Update (0x50a00)
 *
 * IN      R0  -  Pointer to null-terminated string containing
                  the filename of the image to write to the appflash.
 *
 * OUT     R0  -  Return code:
 *                    0      OK
 *                    1      Timeout
 *                    2      WrongManufacturer
 *                    3      WrongDevice
 *                    4      LoadError
 *                    5      EraseFailed
 *                    6      WriteFailed
 *                    7      FileChecksumFail
 */
_kernel_oserror *appflash_update_flash_swi (_kernel_swi_regs *r)
{
  int status;

  status = appflash_writeupdatecmd ((char*)r->r[0], Update, 1);

  r->r[0] = status;

  return NULL;
}


/*
 * *AppFlash_WordWrite
 *
 * Write a word of data to the application flash, at the address specified.
 *
 *   Args:
 *     address_str:  Address to write word to
 *
 */
int appflash_writewordcmd (char *address_str)
{
  int status;
  unsigned int *volatile address;
  unsigned int *volatile commandreg1 = (unsigned int *) (Flash_Base +
                                                         Flash_CommandReg1_Offset);
  unsigned int *volatile commandreg2 = (unsigned int *) (Flash_Base +
                                                         Flash_CommandReg2_Offset);

  /* Enable writes to Flash ROM */
  asm_write_enable ((void *)ROMCR0);

  /* Turn off cache */
  _swix (OS_CLI, _IN (0), "cache off");

  /* Parse the command string */
  address = (unsigned int *) strtol (address_str, NULL, 16);

  printf ("Writing a word at 0x%08p\n", address);

  /* Send commands to the flash */
  *commandreg1 = Write1;
  *commandreg2 = Write2;
  *commandreg1 = Write3;

  /* Followed by the data */
  *address = 0x12345678;

  /* Poll for completion of the write */
  status = appflash_data_poll (address, 0x12345678);

  /* Reset the flash to read mode */
  *address = Reset;

  /* Disable writes to the Flash ROM */
  asm_write_disable ((void *)ROMCR0);

  /* Turn cache back on */
  _swix (OS_CLI, _IN (0), "cache on");

  return status;
}



/*
 * *AppFlash_Update  AND  *AppFlash_Write
 *
 * Update the application flash, with or without erasing it first.
 *
 *   Args:
 *     filename:  Filename of ROM Image
 *
 */
int appflash_writeupdatecmd (char *filename, int mode, char swicall)
{
  /* Address to write reset command to */
  unsigned int *volatile address = (unsigned int *) Flash_Base;
  FILE *fp;
  unsigned int manufacturer_id = 0;
  unsigned int device_id = 0;
  int status;

  my_printf (swicall, "Update AppFlash with ROM Image: \"%s\"\n", filename);

  /* Open ROM Image file */
  fp = fopen (filename, "r");
  if (!fp)
  {
    my_printf (swicall, "Error: Error opening ROM Image file.\n");
    return AppFlash_LoadError;
  }

  my_printf (swicall, "Verifying ROM Image checksum:\n");
  status = appflash_verify_checksum (fp, swicall);

  /* If checksum verification failed, return LoadError status */
  if (status != AppFlash_OK)
  {
    if (fp)
      fclose (fp);
    return status;
  }


  /* Reset the file pointer to the start of the image */
  fseek (fp, 0, 0);

  /* Enable writes to Flash ROM */
  asm_write_enable ((void *)ROMCR0);

  /* Turn off cache */
  _swix (OS_CLI, _IN (0), "cache off");

  appflash_get_id_codes (&manufacturer_id, &device_id, swicall);

  /* No manufacturer ID on chip */
  if (!manufacturer_id)
  {
    my_printf (swicall, "Error: Manufacturer ID not present on flash chip!\n");
    status = AppFlash_WrongManufacturer;
  }

  /* No device ID on chip */
  if (!device_id)
  {
    my_printf (swicall, "Error: Device ID not present on flash chip!\n");
    status = AppFlash_WrongDevice;
  }

  /* If ID codes were returned, continue */
  if (manufacturer_id && device_id)
  {
    my_printf (swicall, "Manufacturer ID = 0x%08x  Device ID = 0x%08x\n", manufacturer_id, device_id);
    if (mode == Update)
    {
      my_printf (swicall, "Chip ID codes OK, erasing flash:\n");
      status = appflash_erase ();

      if (status == AppFlash_Timeout)
        my_printf (swicall, "Error: Timed-out erasing flash, something wrong\nAppFlash: with the flash chip.\n");
      else
      {
        my_printf (swicall, "AppFlash erase finished.\nVerifying AppFlash erasure:\n");

        status = appflash_verify_flash_erase ();

        if (status != AppFlash_OK)
        {
          my_printf (swicall, "AppFlash failed to erase.\n");
        }
        else
        {
          my_printf (swicall, "AppFlash erasure verified.\nWriting AppFlash:\n");

          *address = Reset;
          status = appflash_write_image (fp, swicall);

          if (status == AppFlash_OK)
          {
            my_printf (swicall, "Verifying AppFlash write:\n");

            /* Reset the file pointer to the start of the image */
            fseek (fp, 0, 0);

            status = appflash_verify_flash_write (fp, swicall);

          }
          else if (status == AppFlash_LoadError)
            my_printf (swicall, "Error loading flash image off disk\n");
          else
            my_printf (swicall, "Timed-out writing a word of data\n");
        }
      }
    }
    else
    {
      my_printf (swicall, "Chip IDs OK, writing new image:\n");

      status = appflash_write_image (fp, swicall);

      if (status == AppFlash_OK)
      {
        my_printf (swicall, "Verifying AppFlash write:\n");

        /* Reset the file pointer to the start of the image */
        fseek (fp, 0, 0);

        status = appflash_verify_flash_write (fp, swicall);
      }
      else if (status == AppFlash_LoadError)
        my_printf (swicall, "Error loading flash image off disk\n");
      else
        my_printf (swicall, "Timed-out writing a word of data\n");

    }
  }

  /* Reset the flash to read mode */
  *address = Reset;

  /* Disable writes to the Flash ROM */
  asm_write_disable ((void *)ROMCR0);

  /* Turn cache back on */
  _swix (OS_CLI, _IN (0), "cache on");

  /* Close the ROM image file */
  if (fp)
    fclose (fp);

  /* Return status to *-command handler */
  return status;
}


/*
 * *AppFlash_Erase
 *
 * Erase the application flash.
 *
 */
int appflash_erasecmd (void)
{
  int status;

  /* Address to write reset command to */
  unsigned int *volatile address = (unsigned int *) Flash_Base;
  unsigned int manufacturer_id = 0;
  unsigned int device_id = 0;

  /* Enable writes to Flash ROM */
  asm_write_enable ((void *)ROMCR0);

  /* Turn off cache */
  _swix (OS_CLI, _IN (0), "cache off");

  printf ("Getting ID codes.\n");
  appflash_get_id_codes (&manufacturer_id, &device_id, 1);

  if (manufacturer_id && device_id)
  {
    printf ("Manufacturer ID = 0x%08x  Device ID = 0x%08x\n", manufacturer_id, device_id);
    printf ("ID codes present, erasing flash.\n");

    status = appflash_erase ();
    if (status == AppFlash_Timeout)
      printf ("Error: Timed-out erasing flash, something wrong\nAppFlash: with the flash chip.\n");
    else
    {
      printf ("AppFlash erase finished, verifying erasure.\n");

      status = appflash_verify_flash_erase ();

      if (status == AppFlash_OK)
        printf ("AppFlash erasure verified.\n");
      else
        printf ("AppFlash failed to erase.\n");
    }
  }
  else
    printf ("Error: ID codes not present, aborting.\n");

  *address = Reset;

  /* Disable writes to the Flash ROM */
  asm_write_disable ((void *)ROMCR0);

  /* Turn cache back on */
  _swix (OS_CLI, _IN (0), "cache on");

  return status;
}


/*******************/
/* Local functions */


static int appflash_write_image (FILE *fp, char swicall)
{
  /* Pointer to Flash "array" */
  unsigned int *volatile flash = (unsigned int *) Flash_Base;

  unsigned int *volatile commandreg1 = (unsigned int *) (Flash_Base +
                                                         Flash_CommandReg1_Offset);
  unsigned int *volatile commandreg2 = (unsigned int *) (Flash_Base +
                                                         Flash_CommandReg2_Offset);

  int i, ret, status, k;
  unsigned int word;

  for (i = 0; i < Flash_Num_Words; i++)
  {
    /* Read a word of data from the file */
    ret = fread (&word, sizeof (int), 1, fp);
    if (!ret)
    {
      my_printf (swicall, "Error: Error loading image in write phase.\n");
      return AppFlash_LoadError;
    }

    *commandreg1 = Write1;
    *commandreg2 = Write2;
    *commandreg1 = Write3;

    /* Write thw word to the flash */
    flash[i] = word;

    /* Poll for completion of the word write */
    status = appflash_data_poll (&flash[i], word);

    if (status == AppFlash_Timeout)
      break;

    k = (i % 256);
    if (k == 0)
      my_printf (swicall, "\r%4dk", i / 256);
  }

  if (status == AppFlash_OK)
    my_printf (swicall, "\rAppFlash write finished OK.\n");
  return status;
}



static int appflash_erase (void)
{
  int status;
  /* Pointer to Flash "array" */
  unsigned int *volatile flash = (unsigned int *) Flash_Base;

  unsigned int *volatile commandreg1 = (unsigned int *) (Flash_Base +
                                                         Flash_CommandReg1_Offset);
  unsigned int *volatile commandreg2 = (unsigned int *) (Flash_Base +
                                                         Flash_CommandReg2_Offset);

  *commandreg1 = ChipErase1;
  *commandreg2 = ChipErase2;
  *commandreg1 = ChipErase3;
  *commandreg1 = ChipErase4;
  *commandreg2 = ChipErase5;
  *commandreg1 = ChipErase6;

  /* Poll for completion of the chip erase */
  status = appflash_data_poll (flash, DQ7_Top | DQ7_Bottom);
  *flash = Reset;

  return status;
}

enum {PollStatus_Polling, PollStatus_Timeout, PollStatus_Finished};

static int appflash_data_poll (unsigned int *volatile address, unsigned int data)
{
  int i;
  unsigned int word, dq7_top, dq7_bottom, dq5_top, dq5_bottom, data_bit7_top, data_bit7_bottom;
  int top_status, bottom_status;

  top_status = bottom_status = PollStatus_Polling;

  data_bit7_top = data & DQ7_Top;
  data_bit7_bottom = data & DQ7_Bottom;

  do
  {
    word = *address;
    dq7_top = word & DQ7_Top;
    dq5_top = word & DQ5_Top;
    dq7_bottom = word & DQ7_Bottom;
    dq5_bottom = word & DQ5_Bottom;


    /* Top word */
    if (top_status == PollStatus_Polling)
    {
      if (dq7_top == data_bit7_top)
        top_status = PollStatus_Finished;
      else
      {
        if (dq5_top == DQ5_Top)
          top_status = PollStatus_Timeout;
      }
    }

    /* Bottom word */
    if (bottom_status == PollStatus_Polling)
    {
      if (dq7_bottom == data_bit7_bottom)
        bottom_status = PollStatus_Finished;
      else
      {
        if (dq5_bottom == DQ5_Bottom)
          bottom_status = PollStatus_Timeout;
      }
    }

  }
  while (!((top_status == PollStatus_Finished) && (bottom_status == PollStatus_Finished)) &&
         !(top_status == PollStatus_Timeout) && !(bottom_status == PollStatus_Timeout));

  if ((top_status == PollStatus_Finished) && (bottom_status == PollStatus_Finished))
    return AppFlash_OK;

  /* DQ5 has gone high on at least one of the chips, indicating that
     a chip operation has timed out, so check DQ7 for completion one last time */

  /* A little hack to give the flash time to change state (10 fails) */
  for (i=0; i < 30; i++);

  word = *address;
  dq7_top = word & DQ7_Top;
  dq7_bottom = word & DQ7_Bottom;


  /* Check DQ7 for completion of embedded algorithm */
  if ((dq7_top == data_bit7_top) && (dq7_bottom == data_bit7_bottom))
    return AppFlash_OK;
  else
    return AppFlash_Timeout;
}


static void appflash_get_id_codes (unsigned int *manufacturer_code, unsigned int *device_code,
                                   char swi_call)
{
  unsigned int *volatile manufacturer_id_address=(unsigned int *) (Flash_Base +
                                                  Flash_Manufacturer_ID_Offset);
  unsigned int *volatile device_id_address = (unsigned int *) (Flash_Base +
                                              Flash_Device_ID_Offset);
  unsigned int *volatile commandreg1 = (unsigned int *) (Flash_Base +
                                                         Flash_CommandReg1_Offset);
  unsigned int *volatile commandreg2 = (unsigned int *) (Flash_Base +
                                                         Flash_CommandReg2_Offset);

  *commandreg1 = Autoselect1;
  *commandreg2 = Autoselect2;
  *commandreg1 = Autoselect3;
  *manufacturer_code = *manufacturer_id_address;
  *device_code = *device_id_address;

  /* Reset the flash into read mode */
  *device_id_address = Reset;

}

static int appflash_verify_checksum (FILE *fp, char swicall)
{
  int ret, sum = 0, i, k;
  int word;

  char junk;

  for (i = 0; i < Flash_Num_Words; i++)
  {
    /* Read data from the ROM Image file */
    ret = fread (&word, sizeof (int), 1, fp);

    if (!ret)
    {
      my_printf (swicall, "\nError: ROM Image file is truncated.\n");

      return AppFlash_LoadError;
    }
    if (i < (Flash_Num_Words - 2))
      sum += word;

    k = (i % 256);
    if (k == 0)
      my_printf (swicall, "\r%4dk", i / 256);
  }

  /* Read an extra byte to check for end-of-file */
  junk = fgetc (fp);
  if (!feof(fp))
  {
    /* If we were able to get another byte, file is too long, safer
       to inform the user of this and quit */
    my_printf (swicall, "\nError: ROM Image file is too long.\n");

    return AppFlash_LoadError;
  }

  /* If sum is non-zero then ROM image is corrupt */
  if (sum)
  {
    my_printf (swicall, "\nError: ROM Checksum failed, error in ROM Image.\n");

    return AppFlash_FileChecksumFail;
  }

  my_printf (swicall, "\rROM Image checksum verified OK.\n");
  my_printf (swicall, "Now checking chip ID codes:\n");

  return AppFlash_OK;
}

static int appflash_verify_flash_write (FILE *fp, char swicall)
{
  int count, ret, k;
  unsigned int word;
  unsigned int *volatile flash = (unsigned int *) Flash_Base;

  for (count = 0; count < Flash_Num_Words; count++)
  {
    /* Read data from the ROM Image file */
    ret = fread (&word, sizeof (int), 1, fp);

    if (!ret)
    {
      my_printf (swicall, "\nError: ROM Image file is truncated.\n");

      return AppFlash_LoadError;
    }

    if (word != flash[count])
    {
      my_printf (swicall, "\nError: Image did not write correctly to\nError: flash.\n");
      return AppFlash_WriteFailed;
    }
    k = (count % 256);
    if (k == 0)
      my_printf (swicall, "\r%4dk", count / 256);

  }
  my_printf (swicall, "\rAppFlash verified OK.\n");
  return AppFlash_OK;
}

static int appflash_verify_flash_erase (void)
{
  int count;
  unsigned int *volatile flash = (unsigned int *) Flash_Base;

  for (count = 0; count < Flash_Num_Words; count++)
  {
    if (flash[count] != 0xffffffff)
      return AppFlash_EraseFailed;
  }
  return AppFlash_OK;
}


static int my_printf (char swicall, const char *format, ...)
{
  va_list ap;
  int ret;

  if (swicall)
    return 0;

  va_start (ap, format);
  ret = vprintf (format, ap);
//  va_end ();

  return ret;
}
