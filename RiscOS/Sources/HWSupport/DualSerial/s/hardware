;
; 		Copyright 1996 Acorn Network Computing
;
;  This material is the confidential trade secret and proprietary
;  information of Acorn Network Computing. It may not be reproduced,
;  used, sold, or transferred to any third party without the prior
;  written consent of Acorn Network Computing. All rights reserved.
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                        ^ 0, r10
UART_data_word		# 4	; 0 RX buffer and TX holding buffer DLAB = 0
UART_interrupt_enable	# 4	; 1 IER interrupt enable register
UART_interrupt_ident 	# 4	; 2 IIR interrupt identification register
UART_line_control 	# 4	; 3 LCR line control register
UART_modem_control 	# 4	; 4 MCR modem control register
UART_line_status 	# 4	; 5 LSR line status register
UART_modem_status 	# 4	; 6 MSR modem status register
UART_scratch 		# 4	; 7 SCR scratchpad register

                        ^ 0, r10
UART_baud_divisor_LSB 	# 4	; 0 DLL baud rate divisor latch LSB
UART_baud_divisor_MSB 	# 4	; 1 DLM baud rate divisor latch MSB
UART_FIFO_control	# 4	; 2 FCR FIFO control register (on 550s only)

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Bits in UART_interrupt_enable

IER_receive_available  	* 1 :SHL: 0	; set bit to enable receive interrupts
IER_transmit_empty 	* 1 :SHL: 1   	; set bit to enable transmit interrupts
IER_line_status    	* 1 :SHL: 2   	; set bit to enable error interrupts (Overrun, Parity, Framing, Break)
IER_modem_status    	* 1 :SHL: 3   	; set bit to enable modem line change interrupts

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Bits in UART_FIFO_control

FCR_enable       	* 1:SHL:0	; enable TX and RX FIFOs
FCR_RX_reset      	* 1:SHL:1	; reset RX FIFO
FCR_TX_reset      	* 1:SHL:2	; reset TX FIFO
FCR_RX_trigger_1   	* 2_00:SHL:6	; RX interrupt trigger level
FCR_RX_trigger_4  	* 2_01:SHL:6
FCR_RX_trigger_8   	* 2_10:SHL:6
FCR_RX_trigger_14  	* 2_11:SHL:6

FIFO_size       	* 16			; 16 byte FIFO

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Values from UARTInterruptID

IID_no_interrupt  	* -1		; bit 0 is clear when interrupt pending
IID_line_status   	* 3  		; 0110 highest priority interrupt
IID_RX_full       	* 2  		; 0100 second highest priority interrupt
IID_char_timeout	* 6		; 1100 second highest priotity interrupt
IID_TX_empty      	* 1  		; 0010 third hightst priotity interrupt
IID_modem        	* 0  		; 0000 lowest priority interrupt

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Bits in UART_line_control

LCR_start_bit		* 1 :SHL: 2
LCR_parity_bit		* 1 :SHL: 3
LCR_even_parity		* 1 :SHL: 4
LCR_sticky_parity	* 1 :SHL: 5
LCR_break_enable	* 1 :SHL: 6	; set to enable break signal
LCR_address_divisor	* 1 :SHL: 7	; set to access baud rate divisors

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Bits in UART_modem_control

MCR_DTR_active		* 1 :SHL: 0	; set turn DTR active, clear disable DTR
MCR_RTS_active		* 1 :SHL: 1	; set turn RTS active, clear disable RTS
MCR_out_1         	* 1 :SHL: 2	; control OUT1 line
MCR_out_2         	* 1 :SHL: 3	; control OUT2 line
MCR_loopback     	* 1 :SHL: 4	; turn on loopback facility

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Bits in UART_line_status

LSR_data_ready		* 1 :SHL: 0	; 1 => character is in receive buffer
LSR_overrun		* 1 :SHL: 1	; 1 => overrun error
LSR_parity		* 1 :SHL: 2	; 1 => parity error
LSR_framing		* 1 :SHL: 3	; 1 => framing error
LSR_break		* 1 :SHL: 4	; 1 => break error
LSR_TX_empty		* 1 :SHL: 5	; 1 => tx buffer empty
LSR_TX_shift_empty 	* 1 :SHL: 6	; 1 => tx buffer and shift reg empty

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Bits in UART_modem_status

MSR_CTS_changed		* 1 :SHL: 0	; 1 => CTS has changed state
MSR_DSR_changed		* 1 :SHL: 1	; 1 => DSR has changed state
MSR_TERI_changed	* 1 :SHL: 2	; 1 => TERI has gone from 0 to 1
MSR_DCD_changed		* 1 :SHL: 3	; 1 => DCD has changed state
MSR_CTS_active		* 1 :SHL: 4	; CTS state
MSR_DSR_active		* 1 :SHL: 5	; DSR state
MSR_RI_active		* 1 :SHL: 6	; RI  state
MSR_DCD_active		* 1 :SHL: 7	; DCD state

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_initialise
;
hardware_initialise ENTRY "r0-r1, r9, r10"
		LDR	r9, HAL_StaticBase

; enable FIFOs
                MOV     r1, #1
                CallHAL HAL_UARTFIFOEnable

; check them
                CallHAL HAL_UARTFeatures
                TST     r0, #1
		BEQ	%10				; branch if not present

		LDR	r0, PortFlags
		ORR	r0, r0, #flag_FIFOsPresent
		STR	r0, PortFlags

; reset the FIFOs

                MOV     r1, #3                          ; Clear both fifos
                CallHAL HAL_UARTFIFOClear

		LDR	r0, =default_fifo_trigger
		BL	hardware_set_fifo_trigger
10
		LDR	r0, =default_baud
		BL	hardware_set_baud
		MOV	r0, #default_data
		BL	hardware_set_data
		MOV	r0, #default_stop
		BL	hardware_stop_bit
		MOV	r0, #default_parity
		BL	hardware_parity

; enable all interrupts on port
                MOV     r1, #IER_receive_available:OR:IER_transmit_empty:OR:IER_line_status:OR:IER_modem_status
                CallHAL HAL_UARTInterruptEnable

; does something weird about enabling interrupts...
;                MOV     r0, #MCR_out_2
;                STRB    r0, UART_modem_control

		PHPSEI	lr, r0			; disable interrupts
		LDRB	r0, ControlLines
		ORR	r0, r0, #ctrl_line_dtr:OR:ctrl_line_rts
		STRB	r0, ControlLines
		PLP	lr			; enable interrupts
		BL	hardware_ctrl_lines

                CLRV
		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_remove
;
hardware_remove	ENTRY "r0,r9"

		LDR	r9, HAL_StaticBase

; drop rts and dtr when quitting
		PHPSEI	lr, r0			; disable interrupts
		LDRB	r0, ControlLines
		BIC	r0, r0, #ctrl_line_dtr:OR:ctrl_line_rts
		STRB	r0, ControlLines
		PLP	lr			; enable interrupts
		BL	hardware_ctrl_lines

; disable port interrupts
                MOV     r1, #0				; disable all interrupts
                CallHAL HAL_UARTInterruptEnable

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_claim
;
hardware_claim  ENTRY "r0-r4, r9"
 [ debug
;		DLINE	"claim"
 ]
; claim device vector
                LDR     r3, Flags		; own the vector ?
                TST     r3, #flag_OwnIRQ
                BNE     %10

                CallHAL HAL_UARTDevice
                MOV     r4, r0                  ; save for later
                ADDR    r1, handle_irq
                MOV     r2, wp
                SWI     XOS_ClaimDeviceVector
                STRVS   r0, [sp]
                PullEnv VS
                BVS	make_error

                LDR     r3, Flags		; we now the vector
                ORR     r3, r3, #flag_OwnIRQ
                STR     r3, Flags
10
; serial IRQ bit needs to be set in IOC
                MOV     r0, r4
                MOV     r8, #0
                MOV     r9, #EntryNo_HAL_IRQEnable
                SWI     XOS_Hardware
 [ debug
 ;		DLINE	"claim complete"
 ]
                EXIT                            ; V will be clear after SWI XOS_ClaimDeviceVector

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_release
;
hardware_release ENTRY "r0-r4, r9"

                LDR     r3, Flags
                TST     r3, #flag_OwnIRQ       		; own the vector
                EXIT    EQ

; release the IRQ
		LDR	r9, HAL_StaticBase
                CallHAL HAL_UARTDevice
                MOV     r4, r0
                MOV     r8, #0
                MOV     r9, #EntryNo_HAL_IRQEnable
                SWI     XOS_Hardware
                MOV     r0, r4
                ADDR    r1, handle_irq
                MOV     r2, wp
                SWI     XOS_ReleaseDeviceVector
                STRVS   r0, [sp]
                PullEnv VS
                BVS	make_error

                LDR     r3, Flags
                BIC     r3, r3, #flag_OwnIRQ
                STR     r3, Flags

                EXIT    ; V already clear

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_set_fifo_trigger
;
; in:  r0  = required trigger value
;      r9  = UART static workspace
;
; out: r0  = actual value
;
hardware_set_fifo_trigger ENTRY "r1, r4"

; range check the fifo trigger values
                MOV     r1, r0
                CallHAL HAL_UARTFIFOThreshold   ; returns actual value set

		PHPSEI	r4, r1			; disable interrupts

; ensure fifos are enabled and reset
		LDR	r0, PortFlags
		TST	r0, #flag_FIFOsPresent
                MOV     r1, #1
                CallHAL HAL_UARTFIFOEnable

		PLP	r4			; enable interrupts

                EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_set_baud
;
; in:  r0  = required baud rate
;      r9  = port static workspace
;
; out:
;
hardware_set_baud ENTRY "r1-r3,r10"

		PHPSEI	r10, r2			; disable interrupts
; set DRAB
                MOV     r1, r0, LSL#4
                CallHAL HAL_UARTRate

		PLP	r10			; enable interrupts

		EXIT                            ; V is clear

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_set_data
;
; in:  r0  = data size
;      r9  = HAL static workspace
; out:
;

hardware_set_data ENTRY "r1-r2,r4,r10"

		CMP	r0, #5			; is it less than 5
		BLT	%5
		CMP	r0, #8			; or greater than 8
		BLE	%10

; make an error
5
		ADR	r0, ErrorBlock_Serial_BadData
		PullEnv
		B	make_error

10
		LDR	r1, DataFormat		; stash results away
		BIC	r1, r1, #&ff
		ORR	r1, r1, r0
		STR	r1, DataFormat
		SUB	r4, r0, #5		; 5 maps to 0, 6 to 1, etc

		PHPSEI	r10, r2			; disable interrupts

                MOV     r1, #-1
                CallHAL HAL_UARTFormat

		BIC	r0, r0, #3
                ORR     r1, r0, r4
                CallHAL HAL_UARTFormat

		PLP     r10			; enable interrupts

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	MakeErrorBlock Serial_BadData

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_stop_bit
;
; in:  r0  = number of start/stop bits
;      r9  = HAL static base
; out:
;
hardware_stop_bit ENTRY "r1-r2,r4,r5"

                MOV     r4, r0

		PHPSEI	r5, r1			; disable interrupts

                MOV     r1, #-1
                CallHAL HAL_UARTFormat
                MOV     r1, r0
		CMP	r4, #2			; 2 stop bits ?
		MOVNE	r4, #1			; otherwise 1
		ORREQ	r1, r1, #LCR_start_bit	; 2 stop bits
                BICNE   r1, r1, #LCR_start_bit	; 1 stop bit
                CallHAL HAL_UARTFormat

		PLP	r5			; enable interrupts

; store away now as we may have modded it above
		LDR	r1, DataFormat
		MOV	r2, r4, LSL #8
		BIC	r1, r1, #&ff00
		ORR	r1, r1, r2
		STR	r1, DataFormat


		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_parity
;
; in:  r0  = parity : none=0, even=1, odd=2
;      r9  = HAL static workspace
; out:
;

hardware_parity ENTRY "r1-r2,r4,r10"


; normalise the value
		CMP	r0, #2
		MOVGT	r0, #2
		CMP	r0, #0
		MOVLT	r0, #0

		LDR	r1, DataFormat		; stash results away
		MOV	r2, r0, LSL #16
		BIC	r1, r1, #&ff0000
		ORR	r1, r1, r2
		STR	r1, DataFormat
                MOV     r4, r0

		PHPSEI	r10, r1			; disable interrupts

                MOV     r1, #-1
                CallHAL HAL_UARTFormat

                MOV     r1, r0
		CMP	r4, #0			; no parity ?
		BICEQ	r1, r1, #LCR_parity_bit
                ORRNE   r1, r1, #LCR_parity_bit

		CMP	r4, #1			; even parity ?
		ORREQ	r1, r1, #LCR_even_parity
		BICNE	r1, r1, #LCR_even_parity

                CallHAL HAL_UARTFormat

		PLP	r10			; enable interrupts

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: hardware_ctrl_line
;
; out:
;
; check the dtr and rts bits in the control line flags byte and set hardware
; accordingly.
;
hardware_ctrl_lines ENTRY "r0-r4,r9-r10"

                LDR     r9, HAL_StaticBase
; sort out the read/writables in the modem control register
		PHPSEI	r10, r1			; disable interrupts
		LDRB	r4, ControlLines
                MVN     r2, #MCR_DTR_active:OR:MCR_RTS_active
                MOV     r1, r4
                CallHAL HAL_UARTModemControl

		PLP	r10			; enable interrupts

; now the read onlys in the modem status register
                CallHAL HAL_UARTModemStatus

		TST	r0, #MSR_CTS_active	; check cts
		ORRNE	r4, r4, #ctrl_line_cts
		BICEQ	r4, r4, #ctrl_line_cts
		TST	r0, #MSR_DSR_active	; check dsr
		ORRNE	r4, r4, #ctrl_line_dsr
		BICEQ	r4, r4, #ctrl_line_dsr
		TST	r0, #MSR_RI_active	; check ri
		ORRNE	r4, r4, #ctrl_line_ri
		BICEQ	r4, r4, #ctrl_line_ri
		TST	r0, #MSR_DCD_active	; check dcd
		ORRNE	r4, r4, #ctrl_line_dcd
		BICEQ	r4, r4, #ctrl_line_dcd

		STRB	r4, ControlLines

		EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		END
