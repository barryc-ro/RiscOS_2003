/*name and version number:@(#)dpcntlv.c	1.212*/
/*date of get: 		  01/12/01 11:49:12*/
/*date of delta:	  01/11/01 13:13:55*/
/****************************************************************
File :	dpcntlv.c
Description :
	Functions related to the Venus data pump interface.

Procedures Contained :
	dp_modem_command
	dp_init_modem
	dp_update_modem_options
	venus_init                                     
	dp_ring_detected
	dp_v90_fast_retrain_cmd
	dp_cleardown_cmd
	dp_offhook_cmd
	dp_download_monitor_nc_gain

*****************************************************************/

#if defined(MODEM_Z80) && !defined(USB_MODEM)
# define Z80_DEBUG_THIS_FILE
#endif

#include "llglob_d.h"
#include "atglob.h"
#include "dpglob.h"
#include "sync.h"
#if defined(DC0)
# include "cellular.h"
#endif	// DC0
#include "z80glob.h"
#include "ioglob_d.h"
#include "dpvlongs.h"	// long space disconnect DSP download
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
# include "fax_c2.h"
# if defined(FAX_ECM)
#  include "fax_ecm.h"
# endif
#endif
#if defined(V34_FAX)
# include "faxv34.h"
#endif
#if defined(CS_4)
# include "sa_glob.h"
# include "sa_addr.h"
#endif	// CS_4
#include "allglobs.h"

#if defined(CS_MODEM)
#include "csglob.h"
extern word cs_dpsk_buf[DPSK_BUF_SIZE];
extern word *cs_dpsk_ptr;
#endif

extern byte syncBaudRate;
extern byte syncTimingMode;
extern void dp_run_rom(void);
extern byte dp_56k_map(void);
extern void pita_regwrite(byte reg, byte value);
extern void dp_download_mh(void);


/*****************************************************************************
	Constants for DSP workarounds.
*****************************************************************************/

#if	defined (CS_MODEM) || defined(VENUS_AT_CS)
// monitor nc gain
const word dp_v34dwk[] =
{
	0x0C02, 0x0C1D, 0x1880, 0x3CD0, 0xC171, 0x756E, 0xD002, 0x0C0D, 0xC171,
	0x71A1, 0xD002, 0x0C0D, 0xC000, 0x5000, 0x0827, 0x12DD, 0x6050, 0x609E,
	0x5080, 0x41B5, 0xC300, 0x30CD, 0x789C, 0x5110, 0xDC42, 0x5000, 0x0F20,
	0xA0D0, 0xC000, 0x1880, 0x3CD0, 0xC171, 0x08E2, 0xD003, 0xC000, 0x5000,
	0x0827, 0x12DD, 0x6050, 0x5000, 0x0FB3, 0x1200, 0x708C, 0x6051, 0x5110,
	0x4000, 0xA0D1, 0x708C, 0x6051, 0x7019, 0x5300, 0xABCD, 0x5000, 0x1BF4,
	0xE0D0, 0x19DB, 0x3CD0, 0x5010, 0x1BF5, 0xE0D4, 0x5110, 0xDC42, 0x5000,
	0x0F20, 0xA0D0, 0xC000, 0x1880, 0x3CD0, 0xC171, 0x08EC, 0xD003, 0xC000,
	0x5300, 0x1234, 0x5000, 0x1BF0, 0xE0D0, 0x5000, 0x0827, 0x3CD0, 0x5000,
	0x1BF1, 0xE0D0, 0x5320, 0xFFFE, 0x19DB, 0x3CD0, 0x5010, 0x1BF2, 0xE0D5,
	0x5110, 0x0004, 0x31A0, 0x9BC1, 0xE0D0, 0xE0D4, 0x5110, 0xDC01, 0x5000,
	0x0F20, 0xA0D0, 0xC000
};
#endif	//defined (CS_MODEM) || defined (COPERNICUS)

// This is a v8 workaround.  It is used with 16-bit addressing in this
// file so currently the CONST's from this file must go into the root bank.
const word dp_v8_automode [] =
{
	0x0809, 0x0000, 0xffe7, 0x0000, 0x0000, 0x0000, 0x5080, 0xd834,
	0xc200, 0x1880, 0x3cd0, 0xc171, 0x5af5, 0xd003, 0x0828, 0x5010, 
	0x0b33, 0x3cd4, 0xc171, 0x0003, 0xd003, 0xc000, 0x1800, 0x5020, 
	0x1803, 0x7103, 0xb8d1, 0xa0d9, 0x5300, 0x00ae, 0xc1f1, 0x5bc2, 
	0xe0d4, 0x5000, 0x1806, 0x1c00, 0x7103, 0xb8d1, 0xa0d9, 0xc000, 
	0x5110, 0x8ece, 0x5000, 0x0f20, 0xa0d0, 0x5000, 0x1803, 0x1c00, 
	0x7103, 0xb8d1, 0xa0d9, 0xc000, 0x5080, 0x5d3d, 0xc300, 0x5000, 
	0x0b53, 0x38d0, 0x9fce, 0xd002, 0x08b3, 0x5000, 0x0b35, 0x5080, 
	0x5d9f, 0xc300, 0x5080, 0x5dae, 0xc300, 0xd000, 0x08b3, 0x5000, 
	0x0b4b, 0x38d0, 0x5810, 0x9f2e, 0x20d0, 0xf8c4, 0x31e0, 0xd003, 
	0x08b0, 0x5010, 0x0b55, 0xb8d4, 0x37e0, 0xd010, 0x085f, 0x5110, 
	0xd834, 0x88a5, 0x1200, 0x5000, 0x0b35, 0x6050, 0x08b3, 0x1202, 
	0x5020, 0x1801, 0x6058, 0x5110, 0xd86d, 0x88a5, 0x5000, 0x0b4b, 
	0x5010, 0x0b37, 0x4010, 0x20d0, 0x08b3, 0x5080, 0x5d3d, 0xc300, 
	0x5000, 0x0b53, 0x38d0, 0x9fce, 0xd002, 0x08b3, 0x5000, 0x0b35, 
	0x5080, 0x5d9f, 0xc300, 0x5080, 0x5dae, 0xc300, 0xd000, 0x08b3, 
	0x5000, 0x0b4b, 0x38d0, 0x9f2e, 0x20d0, 0x5010, 0x0b55, 0xb8d4, 
	0x37e0, 0xd011, 0x089d, 0x5000, 0x1801, 0x3cd0, 0xc151, 0x0004, 
	0xd003, 0x0899, 0x5000, 0x1802, 0x38d0, 0x9f2e, 0x20d0, 0xd000, 
	0x089d, 0x8828, 0x5080, 0x5c83, 0xc200, 0x5110, 0xd86d, 0x88a5, 
	0x1200, 0x5000, 0x0b35, 0x6050, 0x08b3, 0x1a01, 0xa0d4, 0x13f6, 
	0x5010, 0x0b34, 0x6054, 0x1201, 0x5010, 0x0b54, 0x6054, 0xc000, 
	0x5080, 0x5cbf, 0xc200, 0x30cd, 0x789c, 0xc000
};

/****************************************************************
Routine : dp_enable_ring_int

	Enable ring interrupt.
*****************************************************************/
void dp_enable_ring_int(void)
{
#if !defined(CS_DIGITAL)
#if defined(PERSEUS_CODEC_CONTROL_H)
    if (G(dp_daa_is_perseus))
    {
		x_debug_msg ("Perseus - clock disabled, idle mode");
		dp_regwrite(PERSEUS_CODEC_CONTROL_H, 0x01);//perseus mode
		dp_regwrite(PERSEUS_CODEC_CONTROL_L, 0x80);//perseus 6-wire
    }
#endif  // PERSEUS

	dp_regwrite(0xd8, 0xff);	// clear all interrupts on camil

	// enable the following : uart, write bank, & ring interrupt
	// **** WARNING **** this should be the last cmd before ring int
	G(dp_bamil_rd7) &= 0xf1 ;	// save 0xd7 register image
	DP_SET_CORE_INTS(G(dp_bamil_rd7));
#endif // !CS_DIGITAL
}

#if !defined( MODEM_Z80 )
/****************************************************************
Routine : dp_sleep_mode
*****************************************************************/
void dp_sleep_mode ( BOOL Interrupt )
{
	(void) Interrupt;	// make warning go away
	x_debug_msg("dp - Simulate enter sleep mode");
}
#else
/****************************************************************
Routine : dp_sleep_mode

    Put DP to sleep.
*****************************************************************/
void dp_sleep_mode ( BOOL Interrupt )
{
	x_debug_msg("dp - enter sleep mode");
	G(dp_sleep) = TRUE;

	// enable ring interrupt so a RING can wake us from sleep.
	dp_enable_ring_int();

	// Correct the codec sleep issue by setting
	// the power down bit to 0 before removing the codec clock.
	// This allows dp_init_modem() at wakeup to correctly sync
	// with the codec.
	dp_change_mercury_gain(0, 0, 0, G(S).ModemOptions.LineGainBLSB);

	// enable parallel phone interrupt - wakeup up on pick-up
	// enable USB Interrupt - wakeup on Int.
# if defined(THUNDER)
	if ( z80_modem_type == USB_INTERFACE )
	{
#  if !defined(TQFP128)				// 144 pin device has int on Bit3
		dp_regwrite ( 0xbe, 0x08 ); // enable bit I/O b3 int level sensitive
		dp_regwrite ( 0xbf, 0x10 ); // enable bit I/O b4 rising edge - high level
		dp_regwrite ( 0xbc, 0xE7 ); // enable bit I/O b4 & b3 interrupt
#  else								// 128 pin TQFP has int on Bit 5
		dp_regwrite ( 0xbe, 0x20 ); // enable bit I/O b5 int level sensitive
		dp_regwrite ( 0xbf, 0x10 ); // enable bit I/O b4 rising edge - high level
		dp_regwrite ( 0xbc, 0xCF ); // enable bit I/O b4 & b5 interrupt
#  endif
	}
	else
	{
		dp_regwrite ( 0xbe, 0x00 ) ; // enable bit I/O b4 int edge sensitive
		dp_regwrite ( 0xbf, 0x10 ) ; // enable bit I/O b4 rising edge - high level
		dp_regwrite ( 0xbc, 0xEF ) ; // enable bit I/O b4 interrupt
	}
# elif defined(USB_MODEM)
#  if !defined(TQFP128)			// 144 pin device has int on Bit3
	dp_regwrite ( 0xbe, 0x08 ); // enable bit I/O b3 int level sensitive
	dp_regwrite ( 0xbf, 0x10 ); // enable bit I/O b4 rising edge - high level
	dp_regwrite ( 0xbc, 0xE7 ); // enable bit I/O b4 & b3 interrupt
#  else							// 128 pin TQFP has int on Bit 5
	dp_regwrite ( 0xbe, 0x20 ); // enable bit I/O b5 int level sensitive
	dp_regwrite ( 0xbf, 0x10 ); // enable bit I/O b4 rising edge - high level
	dp_regwrite ( 0xbc, 0xCF ); // enable bit I/O b4 & b5 interrupt
#  endif
# else	// !USB
	dp_regwrite ( 0xbe, 0x00 ) ; // enable bit I/O b4 int edge sensitive
	dp_regwrite ( 0xbf, 0x10 ) ; // enable bit I/O b4 rising edge - high level
	dp_regwrite ( 0xbc, 0xEF ) ; // enable bit I/O b4 interrupt
# endif	// !THUNDER

	dp_regwrite ( 0xbd, 0xff ) ; // clear all bit I/O interrupts
	dp_regwrite ( 0xbd, 0x00 ) ; // clear all bit I/O interrupts - see spec
	G(dp_bamil_rd7) &= 0xb1 ;	// save 0xd7 register image
	DP_SET_CORE_INTS( G(dp_bamil_rd7) ) ;	// enable master interrupt

	//////////////////////////////////////////////////////
	//WARNING : Do not change the order of following lines
	//////////////////////////////////////////////////////

	//workaround for not invoking CodecInterruptDriver
	//as suggested by Charles Zheng
# if defined(THUNDER)
	if ( z80_modem_type != EXT_INTERFACE )
	{
		dp_write_dsp_ram ( 0x102E, 0x0000 ) ;
		dp_write_dsp_ram ( 0x1071, 0x8ECE ) ;
	}
# elif !defined(EXT_MODEM)
	dp_write_dsp_ram ( 0x102E, 0x0000 ) ;
	dp_write_dsp_ram ( 0x1071, 0x8ECE ) ;
# endif // !THUNDER

	dp_modem_command ( 0x2e, 0, 0 ) ; // kill pll

	dp_modem_command ( 0x2c, 0, 0 ) ; // put dsp in slow clock mode

	// this command is there just to make sure the dsp executed the
	// previous 0x2c command - the next statement is a register write
	dp_modem_idle_cmd();

# if !defined(EXT_MODEM) && !defined(THUNDER)
#  if defined(THUNDER)
	if ( z80_modem_type != EXT_INTERFACE )
#  endif
	{
		// kill bamil clock first - then kill osc :
		// only then we will get int's
#  if defined(PCMCIA_MODEM)
		// kill codec clocks
		dp_regwrite ( 0xcb, BIT3|BIT2|BIT0 ) ;
#  else
		// kill codec & bamil clocks
		dp_regwrite ( 0xcb, BIT3|BIT2|BIT1|BIT0 ) ;
#  endif

#  if defined(PCI_MODEM)
		// Clear any outstanding PITA interrupts
		// INTSRC - clear all bits
		pita_regwrite(0x04,0xFF);

		// Wake up on PCI events of interest to us.
		// INTMSK - wake on PCI reset, read/write
		pita_regwrite(0x05, 0x0f);
#  else
		//oos: PCI requires xtal osc. to avoid sleep/wakeup problem
		// switch to ring oscillator
		output8 ( CKSRC, input8 ( CKSRC ) | 0x08 ) ;
#  endif

		// kill EASCI,PRT,RMP,DMAC
		output8 ( IOCR, input8 ( IOCR ) | 0x30 ) ;
		// cut off MIM_TCLK
		output8( IOBRG, input8 ( IOBRG ) & 0xFE ) ;

#  if !defined(PCI_MODEM)
		//--------------------------------------------------
		// Kill crystal oscillator only if FUGU isn't alive.
		// FUGU won't work if this is killed.
		//--------------------------------------------------
		if ( dp_regread(0xde) & 0x40 )
		{
			// kill crystal oscillator
			dp_regwrite(0xcb, 0x20);
		}
#  endif

		// set to stop Zinger8 & Zeus_int clks & slow system clk
		output8 ( CKSRC, input8 ( CKSRC ) | 0x27 ) ;
	}
# endif // !EXT_MODEM && !THUNDER
}
#endif // if defined( MODEM_Z80 )

#ifdef CS_MODEM
/****************************************************************
Routine : dp_deinit_modem
*****************************************************************/
void dp_deinit_modem ( void )
{
	if ( G(dp_sleep) == FALSE )
		dp_sleep_mode (1) ;
	G(dp_bamil_rd7) = ALLINTS ;
	DP_SET_CORE_INTS( ALLINTS );	// disable all interrupts on camil
	dp_regwrite ( 0xb6, 0xff ) ;	// disable TBDR interrupt
	dp_board_disable () ;
}
#endif //CS_MODEM

#if defined(Z80_DEBUG_PRINT) && !defined(CS_4)
/****************************************************************
Routine : dsp_version_info
	get and print dsp version information
	a la the ap_ver command on DOS batch files
*****************************************************************/
void dsp_version_info(void)
{
	/* read version and stuff */
	word Delta, VerLow, VerHigh, Platform;
	word old3d = dp_read_dsp_ram(0x3d);

	dp_write_dsp_ram(0x3d, 0x4000);
	(void) dp_dsp_version();
	Delta = G(dp_byte_c);
	VerLow = G(dp_byte_d);
	VerHigh = G(dp_byte_e);

	(void) dp_dsp_checksum();
	Platform=G(dp_byte_c);

	sendDecByte((byte) Platform);
	sendDumbChar('.');
	sendDecByte((byte) Delta);
	sendDumbChar('.');
	sendDecByte((byte) VerHigh);
	sendDecByte((byte) VerLow);
#ifdef CS_STARTUP_DELAY
	x_sleep(STARTUP_DELAY); 			
#endif
	x_debug_msg("=DSP Code Version");

	/* restore 0x3d */
	dp_write_dsp_ram(0x3d, old3d);
}
#endif  // Z80_DEBUG_PRINT && !CS_4

/****************************************************************
Routine : venus_init

	Initialize the Venus chip after the DSP has been reset.
*****************************************************************/
void venus_init(void)
{
#if defined(DRAGNET) || !defined(WIN32)
	DP_SET_CORE_INTS( ALLINTS );	// disable all interrupts on camil
	DP_CLR_CORE_INTS( ALLINTS );	// clear all interrupts on camil

# if defined(CS_4)
	G(dp_bamil_re6) = ALLINTS;

	printf("Set pllc=0x%x\n", PLLC70MHz);  
	dp_set_pllc( PLLC70MHz );
	dp_write_dsp_ram( 0x102e, 0x0002 );
# else
	G(dp_sleep) = TRUE;
	dp_venus_wakeup();
# endif
	G(dp_sleep) = FALSE;

# if !defined(CS_DIGITAL)
#  if defined(OPTICAL_DAA)
	// initialize mercury (rather than ISDN mode)
	dp_set_mercury_gain();
#  endif

	// RAM writes for setup
	dp_write_dsp_ram(0x826, 0);
	dp_write_dsp_ram(0x102f, 0);
	dp_write_dsp_ram(0x102e, 1);
# endif	// !CS_DIGITAL
#endif // !WIN32
}

#if !defined(CS_4)

// DSP Clock Speeds follow - pick your clock for your platform
#if defined (VPCM_CLIENT) || defined (VPCM_SERVER)
#if defined(COPERNICUS)
#define VPLL_HI 0x3E
#define VPLL_LO 0x71 // pllc=0x3E71 = 70MHz @ 36 MHz
#elif defined(CS_MODEM)
#define VPLL_HI 0x39									
#define VPLL_LO 0x29 // pllc=0x3929 = 67MHz @ 36 MHz    
#else
//#define PRE_V7_1673
#if defined(PRE_V7_1673) && defined(V34_FAX) && defined(INT_MODEM)
	// slow clock only needed for pre-V7 1673 parts on Yellowstone. jmg 070199
    #define VPLL_HI 0x39
    #define VPLL_LO 0x28   // pllc=0x3928 = 49MHz for V.34 only
	//#define VPLL_HI 0x36
	//#define VPLL_LO 0xE3 // pllc=0x36e3 = 74MHz @ 29
						   // (does not work with Yellowstone)
#else
// Normal client V.90 is here
#define VPLL_HI 0x36
#define VPLL_LO 0xE3 // pllc=0x36e3 = 74MHz @ 29
#endif
#endif
#else
// V.34 only is here
#define VPLL_HI 0x39
#define VPLL_LO 0x28 // pllc=0x3928 = 49MHz for V.34 only
#endif

#define VPLL49_HI 0x39
#define VPLL49_LO 0x28 // pllc=0x3928 = 49MHz for V.34 only

#endif	// !CS_4

/****************************************************************
Routine : dp_venus_wakeup() - wake up from sleep or DSP reset
*****************************************************************/
void dp_venus_wakeup(void)
{
#if !defined(CS_4)
	if (!G(dp_sleep))
		return;	// if not asleep we don't need to wake up

	x_debug_msg("dp_venus_wakeup()");
	dp_modem_command_long(0x31, 0x05, 0x40, 0x0, 0); // powerc=0x4000
	x_sleep(30); //allow some time to stabilize

#ifdef SYNCH_MODE
	if (V42_SYNCH_MODE)
	{
		extern void sync_set_b3c7_out(void);
		extern byte* sync_valv34_core_write(byte*,byte,byte,byte);
		dp_modem_command_long(0x2e, 0x01, VPLL49_HI, VPLL49_LO, 0);
		sync_set_b3c7_out();
		// Mux Venus to DTE
		sync_valv34_core_write(NULL,0x19,0x00,SYNC_Z80_CMD);
	}
	else
#endif
	{
		// set PLL.
        if( G( dp_daa_is_perseus ))
        {
            // pllc=0x3D2F = 83MHz @ 29, 0x3E31 = 93MHz
            dp_modem_command_long(0x2e, 0x01, 0x3d, 0x2f, 0);
        }
        
        else
        {
		dp_modem_command_long(0x2e, 0x01, VPLL_HI, VPLL_LO, 0);
	}
	}

	x_sleep(30); //allow some time to stabilize

	dp_modem_command_long(0x31, 0x05, 0x0, 0x0, 0); // powerc = 0
	x_sleep(30); //allow some time to stabilize

	// 0x102e - Digital Interface Mode Selection
# if !defined(CS_MODEM)
#  if defined(CS_DIGITAL)
	dp_write_dsp_ram(0x102e, 0x0002);
#  else
	dp_write_dsp_ram(0x102e, 0x0001); // suggested by Charles Zheng
#  endif
# endif
#endif // !CS_4
}

extern byte dp_detect_codec(void);			// mercury or perseus codec?

/****************************************************************
Routine : dp_init_modem

	  Called during power-up init, also during wakeup-mode.

	  Return TRUE if successful, FALSE on failure.
*****************************************************************/
byte dp_init_modem(void)
{
	word checksum, dsp_version;

#if defined(HOMOL) && defined(VOICE)
	if( G(dp_polarity_int) == TRUE )   // polarity reversed
	{
		// For polarity detection bypass DSP wakeup as it takes too
		// long - DSP wakeup is done when polarity detection is validated
		// or when ring is detected. Enable board to get next ring interrupt
		// if there is one.
		return TRUE;
	}
#endif
	x_debug_msg("dp_init_modem()");

	dp_venus_wakeup();	// wake up venus if asleep, set PLL

	G(dp_dsp_data_in_progress) = FALSE;
	G(dp_sleep) = FALSE;

#if defined(CS_4)
	G(dp_bamil_re6) = ALLINTS ;
#else
	G(dp_bamil_rd7) = ALLINTS ;
#endif
	DP_SET_CORE_INTS( ALLINTS );	// disable all interrupts on camil
	DP_CLR_CORE_INTS( ALLINTS );	// clear all interrupts on camil

	//////////////////////////////////////////////////////
	//WARNING : Do not change the order of following lines
	// for wakeup
	//////////////////////////////////////////////////////
	// enable all dsp clocks - except audio rrm
#if defined(CS_4)
	// Enable Ring Osc. - BIT7 must be on for sleep mode
	dp_regwrite( 0xcb, 0x88 ) ;
#else
	dp_regwrite( 0xcb, 0x08 ) ;
#endif

	dp_modem_idle_cmd();

	dp_modem_command(ON_HOOK, 0, 0);

	// put the data pump in parallel async mode
	dp_modem_command_long(PDM, ASYNC_MARK, 0x01, 0x87, 0);

#if defined(THUNDER)
	if ( z80_modem_type == USB_INTERFACE )
	{
# if !defined(TQFP128)			// 144 pin device has int on Bit3
		G(dp_bamil_rbc) = 0xf7;	// leave BIT3 enabled for Atlas
# else							// 128 pin TQFP has int on Bit 5
		G(dp_bamil_rbc) = 0xdf;	// leave BIT5 enabled for Atlas
# endif
	}
	else
	{
		G(dp_bamil_rbc) = 0xff;
	}
#elif defined(USB_MODEM)
# if !defined(TQFP128)			// 144 pin device has int on Bit3
	G(dp_bamil_rbc) = 0xf7;		// leave BIT3 enabled for Atlas
# else							// 128 pin TQFP has int on Bit 5
	G(dp_bamil_rbc) = 0xdf;		// leave BIT5 enabled for Atlas
# endif
#else	// !USB
	G(dp_bamil_rbc) = 0xff;
#endif	// !THUNDER

	dp_regwrite(0xbc, G(dp_bamil_rbc)); // disable bio interrupts
	dp_regwrite(0xbd, 0xff);			// clear bio interrupts on camil
	dp_regwrite(0xbd, 0x00);			// reset bio interrupts on camil

	// Register 0xBE determines whether a BIOB interrupt is edge
	// triggered (0) or level sensitive (1).
#if defined(THUNDER)
	if ( z80_modem_type == USB_INTERFACE )
	{
		// USB modem has the Atlas chip on a BIOB interrupt.
# if !defined(TQFP128)				// 144 pin device has int on Bit3
		dp_regwrite(0xbe, 0x08);	// enable bit I/O b int3 level sensitive
# else								// 128 pin TQFP has int on Bit 5
		dp_regwrite(0xbe, 0x20);	// enable bit I/O b int5 level sensitive
# endif
	}
	else
	{
		dp_regwrite(0xbe, 0x00);	// all BIOB interrupts edge triggered
	}
#elif defined(USB_MODEM)
	// USB modem has the Atlas chip on a BIOB interrupt.
# if !defined(TQFP128)				// 144 pin device has int on Bit3
	dp_regwrite(0xbe, 0x08);		// enable bit I/O b int3 level sensitive
# else								// 128 pin TQFP has int on Bit 5
	dp_regwrite(0xbe, 0x20);		// enable bit I/O b int5 level sensitive
# endif
#else	// !USB
	dp_regwrite(0xbe, 0x00);		// all BIOB interrupts edge triggered
#endif	// !THUNDER

#if !defined(CS_4)
	dp_regwrite( 0xb7, 0xff ) ; // clear interrupt NCWTB
	DP_CLR_CORE_INTS( ALLINTS ); // clear all interrupts on camil
#endif

	//-----------------------------------------
	// enable interrupts on DSP
	//-----------------------------------------
#if defined(CS_4)
	G(dp_bamil_re6) = (word)( ~(NCWTB1 | NCRTB1));
	DP_SET_CORE_INTS( G(dp_bamil_re6) );
#else
	//-----------------------------------------
	// enable trigger byte interrupts
	// NCWTB1 & NCRTB1 (data tx & rx)
	//-----------------------------------------
	dp_regwrite( 0xb6, 0xee ) ;

# if defined(THUNDER)
#  if !defined(USB_POLLED_MODE)
	if ( z80_modem_type == USB_INTERFACE )
	{
		G(dp_bamil_rd7) = 0xb3 ;	// enable Atlas Interrupt
	}
	else
	{
		G(dp_bamil_rd7) = 0xf3 ;
	}
#  else
	G(dp_bamil_rd7) = 0xf3 ;
#  endif
# elif defined(USB_MODEM) && !defined(USB_POLLED_MODE)
	// !polled usb mode
	G(dp_bamil_rd7) = 0xb3 ;	// enable Atlas Interrupt
# else	// not USB
	G(dp_bamil_rd7) = 0xf3 ;
# endif

	DP_SET_CORE_INTS( G(dp_bamil_rd7) );
#endif	// !CS_4

	x_sleep(100); // allow time for dsp to stabilize

	// send a few commands to check the hardware
	dp_modem_idle_cmd();
	
	if (!dp_read_dsp_ram(0x42) &&
		G(dp_byte_f) != 0x01 )	// if read_ram command failed
	{
		x_debug_msg("dp_init_modem() - read ram fails");
		return FALSE;
	}

	// switch back to rom before check the dsp checksum
#if defined ( K56FLEX ) || defined( VPCM_CLIENT ) || defined ( VPCM_SERVER )
	if (dp_56k_map())
	{
		dp_run_rom();
		G(dp_56k_state) = DP_56K_INIT ;
	}
#endif

	checksum = dp_dsp_checksum();
	dsp_version = dp_dsp_version();

	if ( ( checksum != DSPCHECKSUM  ) || ( dsp_version != DSPVERSION ) )
	{
#if defined(Z80_DEBUG_PRINT)
		if (checksum != DSPCHECKSUM)
		{
			x_debug_msg("DSP gives checksum="); sendHexWord(checksum);
			x_debug_msg(" expected checksum="); sendHexWord(DSPCHECKSUM);
		}
		if (dsp_version != DSPVERSION)
		{
			x_debug_msg(" DSP gives version="); sendHexWord(dsp_version);
			x_debug_msg(" expected version="); sendHexWord(DSPVERSION);
		}
		sendCrLf();
#endif // Z80_DEBUG_PRINT
#if !defined(DRAGNET)
		return FALSE;
#endif
	}

	// initialize bamil & mercury I/O pins 
	x_output(IO_OUTPUT_INIT);

	// set limits for the valid ring periods
	if ( G(S).ModemOptions.RingDetectType == 0 )			// Half wave 
	{
		dp_write_dsp_ram(0x40, G(S).ModemOptions.MinRingPeriod);
		dp_write_dsp_ram(0x41, G(S).ModemOptions.MaxRingPeriod);
		// reduce ring dtect cycles to 2 to detect 200 ms ring bursts
		dp_write_dsp_ram(0x43, 0x02);
	}
	else
	{
		dp_write_dsp_ram(0x40, (word)(G(S).ModemOptions.MinRingPeriod >> 1));
		dp_write_dsp_ram(0x41, (word)(G(S).ModemOptions.MaxRingPeriod >> 1));
	}

	G(dp_tad_downloaded) = FALSE ;
	G(dp_fax_downloaded) = FALSE ;
#if !defined(CS_MODEM) || defined(CLASS2_FAX)
	dp_init_local_phone_timer () ;	// init when wake up from sleep
	G(last_fax_v17) = NON_V17;
#endif
	G(dp_first_call) = TRUE;

#if defined(THUNDER)
	if ( z80_modem_type == USB_INTERFACE )
	{
		// leave off hook led
		dp_regwrite( 0xc0, dp_regread( 0xc0 ) & 0x0b );
	}
	else
	{
		// get rid of constellation stuff
		dp_regwrite(0xc0, (byte) (dp_regread(0xc0) & 3));
	}
#elif defined(USB_MODEM)
	dp_regwrite(0xc0, dp_regread(0xc0) & 0x0b); // leave off hook led
#else
	// get rid of constellation stuff
	dp_regwrite(0xc0, (byte) (dp_regread(0xc0) & 3));
#endif // !THUNDER

#if defined(Z80_DEBUG_PRINT)
	dsp_version_info();
#endif

#ifdef DC0
	cell_init();				// init. direct connect.
#endif

#if defined(VENUS2)
#if defined(MODEM_Z80)
	// Venus2 init miscellaneous control bits.
	// No extra cycles in the acknowledge of bus agent.
	output8(0xde, 0x10);
#endif

	// set up CSIO to run like the VENUS SIO block
	dp_regwrite(0x12, 0x81);
	dp_regwrite(0x13, 0x80);
	dp_regwrite(0x14, 0x81);
	dp_regwrite(0x15, 0x80);

	dp_regwrite(0x11, dp_regread(0x11) | 0x01);
#endif

#if !defined(CS_DIGITAL)
	dp_detect_codec();			// mercury or perseus codec?
	dp_set_mercury_gain();		// Initialize Mercury gain
#endif

	return TRUE;
}

/****************************************************************
Routine : dp_disable_33600

	Disable 33.6 kbps for those times when it's
	not advisable or not possible.
*****************************************************************/
void dp_disable_33600(void)
{
	dp_write_dsp_ram(DP_V34_SYM_POW, 0x217f); // disable symbol rate 3429

	// disable symbol rate 3424
	dp_write_dsp_ram(DP_V34_SYMBOLRATE, (word)(G(wSymbolRate)&~(0x0400)));

	// Don't show 33.6 in our data rate capability - MP word 2
	dp_write_dsp_ram(DP_V34_DATA_RATE,
					 (word)(dp_read_dsp_ram(DP_V34_DATA_RATE)
							& ~(V34_33600_ONLY)));
}

#if !defined(CS_DIGITAL) && defined(COMPRESS_TABLES) && defined(CALL_WAITING)

/****************************************************************
Routine : dp_recent_call_waiting()
	Return TRUE if there has been a recent call waiting tone
	detected that might affect a retrain in progress.

	This is used by the V.90 fallback routine dp_56k_fallback()
	to determine if it should keep trying for v.90 fallbacks
	rather than going back to V.34.

	Customers can modify this routine to take other things
	into account.

*****************************************************************/
byte dp_recent_call_waiting(void)
{
	return G(vpcm_call_waiting);
}

extern void dp_call_waiting(void);

/****************************************************************
Routine : dp_check_call_waiting()
	Check to see if call waiting was detected for v.90
	or v.34.  If detected, clear the detected bit.

    Return the modified ram3a value.
*****************************************************************/
word dp_check_call_waiting(word ram3a)
{
	if (G(V34Mode) || G(vpcm_mode))
	{
		if (ram3a & 0x8000)
		{
			ram3a &= 0x7fff;
			dp_write_dsp_ram(DSP_STATUS_RAM, ram3a);	// clear cw bit
			dp_call_waiting();
			G(vpcm_call_waiting) = 1;
			x_set_current_time(&G(vpcm_call_wait_timer_long));
		}
		else
		{
			if (G(vpcm_call_waiting) &&
				x_elapsed_long_time(G(vpcm_call_wait_timer_long)) > 600)
			{
				x_debug_msg("done with call waiting - 60 seconds");
				G(vpcm_call_waiting) = 0;
			}
		}
	}

	return ram3a;
}
#endif // CALL_WAITING

/****************************************************************
Routine : dp_v34_workaround - these are the
		startup and data mode workarounds for V.34
*****************************************************************/
byte dp_v34_workaround(void)
{
	word wTmpV, wRSL ;
	int  wClipDiff ;
	word wDspState ;

	wDspState = DP_READ_DSP_SPTR();

#if !defined(CS_DIGITAL) && defined(CALL_WAITING) && defined(COMPRESS_TABLES)
	if (G(dp_CallWaitingEnable) != 2)
	{
		dp_check_call_waiting(dp_read_dsp_ram(DSP_STATUS_RAM));
	}
#endif // CALL_WAITING

#if defined(V34_FAX)
	if( NON_V34 != G(x_fax_v34mode) )	// v.34 fax in progress...
		return (FALSE);					// skip workarounds.
#endif

	// migrating towards a new structure for new workarounds
	if (wDspState != G(oldSPTR))
	{
		G(oldSPTR) = wDspState;

#if defined(CS_DIGITAL) && !defined(CS_4)
		// 3/6 code with these workarounds in the client
		// had bad network coverage results - mah
		switch (G(oldSPTR))
		{
		case 0x0888:
		{
			word symbolrate = (byte)(dp_read_dsp_ram(0x080B));

			if ( (symbolrate == 5) || (symbolrate == 4) )
			{
				word old7f = dp_read_dsp_ram(0x007f);
			
				if (symbolrate == 4)		// Symbol rate is 3200
				{
					old7f = old7f - 1024;
				}
				else						// Symbol rate is 3429
				{
					old7f = old7f - 256;
				}
				dp_write_dsp_ram(0x007f, old7f);
			}
		}
		break;
		case 0x55b1:
		{
			word old7f = dp_read_dsp_ram(0x007f);
			
			old7f = old7f - 1600;
			dp_write_dsp_ram(0x007f, (word) old7f);
		}
		break;
		case TA_INFO1C_RX:		//0x7866
			if ( G(x_modem_originate) == FALSE )
			{
				x_debug_msg("dp - TA_INFO1C_RX mse workaround");
				dp_56k_adjust_mse(1);
			}
			break;
		case TC_B2_3:			//0x7414
			if ( G(x_modem_originate) == TRUE )
			{
				x_debug_msg("dp - TC_B2_3 mse workaround");
				dp_56k_adjust_mse(1);
			}
			break;
		}
#endif  // CS_DIGITAL && !CS_4
	}

	switch ( G(dp_bV34WkState) )
	{
		case WRK_NULL :
			break;

		case WRK_STARTUP:
			if ( dp_read_dsp_ram ( SU_FLAG ) == 1 )
			{
				// Do different things depending on answer or
				// originate.
				if ( ( G(x_modem_originate) == FALSE ) && ( \
					G(S).ModemOptions.V8_Answer == DCE_V8_ANS_ENABLE ) )
					G(dp_bV34WkState) = WRK_V8_ANSW ;
				else
					G(dp_bV34WkState) = WRK_DET_CM ;
			}
			break;

		case WRK_V8_ANSW:
			// V.8 auto CM - get the remote CM so controller can use it
			if ( wDspState == 0x5af5 ) // V8 answer id ( V8_ANSID in DSP )
			{
				dp_disable_workaround();
				dp_write_dsp_array(0x1800, &dp_v8_automode[0],
								   (byte)(sizeof(dp_v8_automode)/sizeof(word)));
				dp_write_dsp_ram ( AP_DPRAM_BAUD, 0xd800 );
				G(dp_bV34WkState) = WRK_V8_ANSW1 ;
				x_debug_msg ("dp - load Venus wrkrdn 017 (v.8)") ;
			}

			break;

		case WRK_V8_ANSW1:
			// check if dsp has received CM twice
			if ( dp_read_dsp_ram ( 0x1801 ) == 2 )
			{
#if defined(V80) && !defined(CS_MODEM)
				dp_detect_cm () ;
#endif
				G(dp_bV34WkState) = WRK_DET_CM ;
			}
			break;

		case WRK_DET_CM:
			if ( G(S).ModemOptions.V8_Orig == DCE_V8_ORIG_ENABLE )
			{
				// if in the CJM state, indicate JM to DTE
				if ( dp_read_dsp_ram ( 0x0b33 ) == 7 )	// cjm_state ( 0xb33 )
				{
#if defined(V80) && !defined(CS_MODEM)
					dp_detect_cm () ;
#endif
					G(dp_bV34WkState) = WRK_DISABLE_3429SYM ;
				}
			}
			else
				G(dp_bV34WkState) = WRK_DISABLE_3429SYM ;

			break;

		case WRK_DISABLE_3429SYM :
#ifdef DC0
			if ( G(cell_active) == TRUE )
			{
				G(dp_bV34WkState) = WRK_CELL_POWER_CNTL ;
			}
			else
#endif
			{
				// 3429 symbol rate disable - workaround only in originate mode
				if ( G(x_modem_originate) == FALSE )
				{
					G(dp_bV34WkState) = WRK_CLIP_FIX ;
				}
				else
				{
					if ( wDspState == TC_LP2 )
					{
						wTmpV = dp_read_dsp_ram ( 0x0cc1 ) ;
						wRSL = (word) ( ( wTmpV & 0x01e0 ) >> 5 ) ;

						// 14 => 33.6, 12 => 28800
						if ( wRSL < 12 )
						{
							dp_write_dsp_ram (0x0cc1, (word)(wTmpV & 0x0fe1f));
							x_debug_msg ("dp - 3429 symbol rate workaround") ;
						}
						G(dp_bV34WkState) = WRK_CLIP_FIX ;
					}
				}
			}
			break ;

		case WRK_CLIP_FIX:
			// See if the receive level is really hot.
			// no difference when there's supposed to be
			// a 6 dB difference between LP1 and LP2.
			//  If this is the case, enable manual power
			// control and drop the remote transmit level.
			if (( wDspState == TA_INFO1C_RX )||( wDspState == TA_INFO1C_TX ))
			{
				wTmpV = dp_read_dsp_ram ( 0x09d2 ) ;
				wClipDiff=wTmpV - dp_read_dsp_ram ( 0x09d0 );
				wRSL = (word) ((wTmpV & 0xff00) >> 8);
				if (( wClipDiff < 0x480 ) && (wRSL > 17) )
				{
#if !defined(CS_MODEM)
					// enable manual power control.
					G(dp_wV34Option) = (word) ((G(dp_wV34Option) & 0xf3ff) |
											   0x0800);
					dp_write_dsp_ram ( 0x0821, G(dp_wV34Option) ) ;
					
					// set 7 db drop.
					wTmpV = dp_read_dsp_ram ( 0x0803 ) ;
					wTmpV = (word) (( wTmpV & 0xffc0 ) | 0x0007);
					dp_write_dsp_ram ( 0x0803, wTmpV ) ;
#else
					//disable power drop for CSM
					G(dp_wV34Option) = ( G(dp_wV34Option) & 0xf3ff ) ;
					dp_write_dsp_ram ( 0x0821, G(dp_wV34Option) ) ;
#endif
					// set rate select threshold to be 
					// more conservative.
					dp_write_dsp_ram(MSE_SCALE, 0x2000);
				
					// force error recovery
					dp_write_dsp_ram ( S_PTR, DSP_ERROR_RECOVERY ) ; 
					x_debug_msg ("dp - request power drop");
				}
				G(dp_bV34WkState) = WRK_NULL ;
			}
			break;

#if defined(DC0) || defined(CS_ETC)
		case WRK_CELL_POWER_CNTL :
			// request remote power drops to try
			// to optimize power level if the receive level
			// isn't to our satisfaction.
			if (( wDspState == TA_INFO1C_RX )||( wDspState == TA_INFO1C_TX ))
			{
				wRSL = dp_read_dsp_ram ( 0x09d2 ) ;
				wRSL = ( (wRSL+0x0080) & 0xff00) >> 8;
				if ( prnC == CELL_NEC )
					wRSL -= 7 ;
				if ( wRSL <= DROP_10DB_THRESHOLD )
				{
					wTmpV = 0x0027 ; // drop 11 db
				}
				else
				{
					switch ( wRSL )
					{
					case DROP_10DB_THRESHOLD :
						wTmpV = 0x001f ; // drop 10 db
						break ;
					case DROP_10DB_THRESHOLD+1 :
						wTmpV = 0x0017 ; // drop 9 db
						break ;
					case DROP_10DB_THRESHOLD+2 :
						wTmpV = 0x0007 ; // drop 7 db
						break ;
					case DROP_10DB_THRESHOLD+3 :
						wTmpV = 0x0005 ; // drop 5 db
						break ;
					case DROP_10DB_THRESHOLD+4 :
						wTmpV = 0x0004 ; // drop 4 db
						break ;
					default :
						wTmpV = 0x0000 ;
					}
				}
				if ( wTmpV )
				{
					// enable manual power control.
					G(dp_wV34Option) = ( G(dp_wV34Option) & 0xf3ff ) | 0x0800 ;
					dp_write_dsp_ram ( 0x0821, G(dp_wV34Option) ) ;
					wTmpV |= ( dp_read_dsp_ram ( 0x0803 ) & 0xffc0 ) ;
					dp_write_dsp_ram ( 0x0803, wTmpV ) ;
					
					// force error recovery
					dp_write_dsp_ram ( S_PTR, DSP_ERROR_RECOVERY ) ; 
					x_debug_msg ("dp - request power drop");
				}
				G(dp_bV34WkState) = WRK_NULL ;
			}
			break;
#endif

		case WRK_RETRAIN :
			break;
	}
	return (FALSE) ;
}

/****************************************************************
Routine : dp_disable_workaround
*****************************************************************/
void dp_disable_workaround ( void )
{
	// disable workarounds that are called on every baud
	dp_write_dsp_ram(AP_DPRAM_BAUD, AP_DSP_NUL);

	// call waiting also has a workaround on the vec1 vector
	// so we need to disable that one as well.
	dp_write_dsp_ram(0x0f22, AP_DSP_NUL);
}

/****************************************************************
Routine : dp_transmit_level

	Write the transmit level.
*****************************************************************/
void dp_transmit_level(byte level)
{
	dp_write_dsp_ram(DP_XMIT_LEVEL_LOC, level);
}

/****************************************************************
Routine : dp_async_user_mode
Description : put in async mode with parity and data bits defined
              by AT commands.
*****************************************************************/
void dp_async_user_mode(void)
{
	byte reg3d = 0x80;

	switch (G(S).ModemOptions.DataBits)
	{
	case 5 :	// 5 data bits
		break ;
	case 6 :	// 6 data bits
		reg3d |= 0x02 ;
		break ;
	case 7 :	// 7 data bits
		reg3d |= 0x04 ;
		break ;
	default :	// 8 data bits
		reg3d |= 0x06 ;
		break ;
	}
	if ( G(S).ModemOptions.StopBits )	// 2 stop bits
	{
			reg3d |= 0x01 ;
	}
	switch ( G(S).ModemOptions.Parity )
	{
	case 1 :	/* odd parity	*/
		reg3d |= 0x38 ;
		break ;
	case 2 :	/* even parity	*/
		reg3d |= 0x30 ;
		break ;
	case 3 :	/* mark parity	*/
		reg3d |= 0x01 ;	/* 2 stop bits */
		break ;
	case 4 :	/* space parity	*/
		reg3d |= 0x28 ;
		break ;
	}
	G(DpIdleFillChar) = 0xff ;  //  idle line (no data) fill character
	dp_modem_command_long ( PDM, ASYNC_MARK, 0x01, reg3d, 0 ) ;
}

// DP RAM location 80D for line rates as shown in comments (auto mode)
const word dp_v34auto[] =
{
	V34_2400,	// 6
	V34_4800,	// 7
	V34_7200,	// 8
	V34_9600,	// 9
	V34_12000,	// 10
	V34_14400,	// 11
	V34_16800,	// 12
	V34_19200,	// 13
	V34_21600,	// 14
	V34_24000,	// 15
	V34_26400,	// 16
	V34_28800,	// 17
	V34_31200,	// 18
	V34_33600	// 19
};

// DP RAM location 80D for line rates as shown in comments (not auto mode)
const word dp_v34noauto[] =
{
	V34_2400_ONLY,	// 6
	V34_4800_ONLY,	// 7
	V34_7200_ONLY,	// 8
	V34_9600_ONLY,	// 9
	V34_12000_ONLY,	// 10
	V34_14400_ONLY,	// 11
	V34_16800_ONLY,	// 12
	V34_19200_ONLY,	// 13
	V34_21600_ONLY,	// 14
	V34_24000_ONLY,	// 15
	V34_26400_ONLY,	// 16
	V34_28800_ONLY,	// 17
	V34_31200_ONLY,	// 18
	V34_33600_ONLY	// 19
};

// DP RAM location 1 for line rates as shown in comments (auto mode)
const word dp_v32auto[] =
{
	V32_4800,	// 7
	V32_7200,	// 8
	V32_9600,	// 9
	V32_12000,	// 10
	V32_14400,	// 11
	V32_16800,	// 12
	V32_19200	// 13
};

// DP RAM location 1 for line rates as shown in comments (not auto mode)
const word dp_v32noauto[] =
{
	V32_4800,		// 7
	V32_7200_ONLY,	// 8
	V32_9600_ONLY,	// 9
	V32_12000_ONLY,	// 10
	V32_14400_ONLY,	// 11
	V32_16800_ONLY,	// 12
	V32_19200_ONLY	// 13
};

/****************************************************************
Routine : dp_update_rate
Description : update line rate info in data pump
		based on current modem options
*****************************************************************/
void dp_update_rate(void)
{
	word ram1_v32Rate = 0, ram2_lsRate = AUTO_MODE, r80d_v34_rate = 0;
	byte maxLineRate = 0;

	G(wSymbolRate) = 0x03ff;	// start by enabling up to 3200

	if (1 & G(S).ModemOptions.AdjustBPS)
	{
		// Force line rate<=DTE rate.  AT\J1
		switch (G(S).ModemOptions.DteRate)
		{
		case DTE_110:
		case DTE_300:
		case DTE_600:
			maxLineRate = 3; break;
		case DTE_1200:
			maxLineRate = 5; break;
		case DTE_2400:
			maxLineRate = 6; break;
		case DTE_4800:
			maxLineRate = 7; break;
		case DTE_9600:
			maxLineRate = 9; break;
		case DTE_14400:
			maxLineRate = 11; break;
		case DTE_19200:
			maxLineRate = 13; break;
			// Since DTE rates higher than 19200 are under
			// the V.34 max rate of 33.6, we don't have to
			// worry about them.
		}
	}

	if ( (maxLineRate==0)||
	     ((G(S).ModemOptions.DialLineRate!=0) &&
		  (maxLineRate>G(S).ModemOptions.DialLineRate)) )
		maxLineRate = G(S).ModemOptions.DialLineRate;

	if (0 == maxLineRate || maxLineRate > 18)
	{
		maxLineRate = 19;				// 33.6 kbps
		if( (G(S).ModemOptions.V42 != V42_LAPM_ONLY) &&
			(G(S).ModemOptions.V42 != V42_LAPM_MNP_DISC) &&
			(G(S).ModemOptions.V42 != V42_LAPM_BUFFER) &&
			(G(S).ModemOptions.V42 != V42_LAPM_MNP_BUFFER) )
		{
			// For configurations where we're not going to do LAPM,
			// we'll eliminate 33600 as a possibility.  Some think
			// that we get too many errors at 33600 to make other
			// error control options useful.
			maxLineRate = 18;
		}
		else
		{
			// we're allowing 33.6 kbps, enable 3429 symbol rate
			G(wSymbolRate) = 0x07ff ;
		}
	}

	switch (maxLineRate)
	{
	case 1:
	case 4:
		maxLineRate = 7;		// just call it 4800
		break;
	case 2 :
		// 1200/75 bps (V.23)
		ram2_lsRate = V23_1200;
		break ;
	case 3 :
		// 300 bps
		if ( G(S).ModemOptions.CommStdSetting == 0 )
		{
			ram2_lsRate = V21_300;		// V.21 300
			// Make the receive threshold 3dB lower for V.21 to be 
			// compatible with other modulations
			if ( G(S).ModemOptions.CountryId == FRANCE )
				dp_write_dsp_ram(0x37,(word)(3+G(S).ModemOptions.RxLevel));
		}
		else
			ram2_lsRate = B103_300;	// Bell 103 300
		break ;
	case 5 :
		// 1200 bps
		ram2_lsRate = V22_1200;
		break ;
	case 6 :
		// 2400 bps
		ram2_lsRate = V22_2400;		// v22bis 2400
		break ;
	}

	G(x_line_rate) = maxLineRate - 1;

	if (maxLineRate > 6)
	{
		// work on ram1_v32Rate
		if (maxLineRate > 13)
			ram1_v32Rate = V32_19200;
		else
		{
			if (G(S).ModemOptions.AutoRate == 0)
				ram1_v32Rate = dp_v32noauto[maxLineRate-7];
			else
				ram1_v32Rate = dp_v32auto[maxLineRate-7];
		}
#if defined(CS_DIGITAL) || defined(CS_MODEM)
		// disable V.32 turbo speeds for Digital
		ram1_v32Rate &= 0x9fff;
#endif
	}

	if (maxLineRate > 5)
	{
		if (G(S).ModemOptions.AutoRate == 0)
			r80d_v34_rate = dp_v34noauto[maxLineRate-6];
		else
			r80d_v34_rate = dp_v34auto[maxLineRate-6];
	}

	/* if automode disabled */
	if ( (G(S).ModemOptions.AutoMode == 0) && (maxLineRate >= 7) )
		ram2_lsRate = 0;

#if defined(DC0) || defined(CS_ETC)
	if ( G(ETC_mode) )
	{
		x_debug_msg("dp - ETC_mode");
		//is this the initial startup?
		if( !(G(ETC_mode) & ETC_MODE_INIT_STARTUP_MASK_BIT) )
		{
			if ( G(S).ModemOptions.ETC == 2 )
			{
				x_debug_msg ("dp - ETC 9600");
				ram1_v32Rate &= V32_9600 ;
				r80d_v34_rate &= V34_9600 ;
			}
			else if ( G(S).ModemOptions.ETC == 1 )
			{
				x_debug_msg ("dp - ETC 4800");
				ram1_v32Rate &= V32_4800 ;
				r80d_v34_rate &= V34_4800 ;
			}
			//set initial start up bit
			G(ETC_mode) |= ETC_MODE_INIT_STARTUP_MASK_BIT ;
		}

		// if not 2400 only symbol rate, use ETC symbol rate. 
		if ( G(wSymbolRate) != 0x0001 )
				G(wSymbolRate) = G(S).ModemOptions.wV34RxSymbol ;
	}
#endif // DC0

	// write V.32 Rate Selection and Automode Selection
	dp_write_dsp_ram(0x01, ram1_v32Rate);

	// write Low-Speed Rate Selection
	dp_write_dsp_ram(0x02, ram2_lsRate);

	// Since we're going to read 0x817 to see if we're in
	// G(V34Mode) in dp_dial_connect_success(), we need to initialize it
	// in case we wind up in V.32 mode.
	dp_write_dsp_ram(0x0817, 0);

	// This is destined for RAM location 0x821, the V.34 Options RAM loc.
	G(dp_wV34Option) = G(S).ModemOptions.wV34Option ;
#if defined(CS_MODEM)
	// disable power drop for CSM
	G(dp_wV34Option) &= 0xF3FF;
#endif
	if ( ram2_lsRate )
		G(dp_wV34Option) |= 0x0008 ; // enable auto rate
	else
		G(dp_wV34Option) &= ~0x0008 ; // disable auto rate

	// disable auto rate bit 12
	G(dp_wV34Option) = (word) (G(dp_wV34Option) & 0xEFFF);

	if ( G(S).ModemOptions.bV34Enable )
	{
		if ( G(x_modem_state) == MS_LOCAL_TEST )
		{
			if ( r80d_v34_rate & 0x3000 ) // if v34bis, enable 3429 symbol rate
			{
				G(dp_wV34Option) |= 0x0800 ; // required for local loopback.
				G(wSymbolRate) = 0x0400 ;
				r80d_v34_rate |= 0x0800 ; // dsp workaround
			}
			else if ( r80d_v34_rate == 1 ) // if 2400 line rate
				G(dp_wV34Option) = 0 ;
			else
				G(wSymbolRate) = 0x0100 ; // 3200 symbol rate
		}

		// in Venus we need to write to 0x80c
		// for a selected rate.
		// bits 5-2 get call to answer rate
		// bits 9-6 get answer to call rate
		if (!ram2_lsRate)
		{
			word mbr = (word) ((G(x_line_rate) - 4) << 2);

			mbr |= (mbr << 4);
			
			// 0x80c - V.34 Max Bit Rates and Modulation Options
			// Requested by Local Modem (MP - Transmit Word 1)
			dp_write_dsp_ram(0x80c, mbr);		// set Max bit rates
		}

		// 0x801 - V.34 Symbol Rate and Power Control for Local Modem
		// (INFO0 - Transmit)
		if ( G(wSymbolRate) & 0x0400 )	// if 3429 symbol rate is enabled
			dp_write_dsp_ram(DP_V34_SYM_POW, 0x21ff);// enable all symbol rates
		else
			dp_write_dsp_ram(DP_V34_SYM_POW, 0x217f); // disable sym rate 3429
#ifdef SYNCH_MODE
		if ( G(S).ModemOptions.V42 == V42_SYNCH_MODE )
		{
			switch (syncBaudRate)	// allows user to force baud rate
			{						// primarily for testing
			case '0':
				break;
			case '1':
				G(wSymbolRate) = 0x0001;	//2400
				break;
			case '2':
				G(wSymbolRate) = 0x0004;	//2743
				break;
			case '3':
				G(wSymbolRate) = 0x0010;	//2800
				break;
			case '4':
				G(wSymbolRate) = 0x0040;	//3000
				break;
			case '5':
				G(wSymbolRate) = 0x0100;	//3200
				break;
			case '6':
				G(wSymbolRate) = 0x0400;	//3429
				break;
			}
		}
#endif
		// 0x823 - V.34 Receive Symbol Rate and Carrier Frequency
		dp_write_dsp_ram(DP_V34_SYMBOLRATE, G(wSymbolRate));
	}
	else
	{
		// V.34 disabled
		r80d_v34_rate = 0;
	}

	// 0x80D - V.34 Data Rate Capability for the Local Modem
	// (MP - Transmit Word 2)
	dp_write_dsp_ram(DP_V34_DATA_RATE, r80d_v34_rate); //set V34 rate and asym

	// 0x821 - V.34 Options
	dp_write_dsp_ram(V34_OPTIONS, G(dp_wV34Option));

	dp_write_dsp_ram ( 0x003c, 0x0122 ) ; //constellation I value
	dp_write_dsp_ram ( 0x0047, 0x0123 ) ; //constellation Q value
}

/****************************************************************
Routine : dp_update_modem_options

Description:
	Set up the data pump for the data mode call.  Normally this is
	called just before a STARTUP command to the DSP.
*****************************************************************/
void dp_update_modem_options(void)
{
	word reg38 ;
	byte c ;

#if defined(V34_FAX)
	/* update options only for data mode and V34 fax mode */
	if( G(x_modem_mode) != MODEM_DATA && NON_V34 == G(x_fax_v34mode) )
		return ;
#else
	/* update options only for data mode */
	if( G(x_modem_mode) != MODEM_DATA )
		return ;
#endif

	x_debug_msg("DP - dp_update_modem_options()");

	dp_write_dsp_ram((word)MP_tx1, 0);

#ifdef V34_FAX
		// trick to prevent clearing of bulk delay RAM in DSP which the
		// DSP is using.
	dp_write_dsp_ram (0xc, (NON_V34 != G(x_fax_v34mode) ) ? 0x0075 : 0x0);
#else
	dp_write_dsp_ram ( 0xc, 0x0 ) ;		/* clear v.17 rate selection*/
#endif

	dp_write_dsp_ram(DP_FAX_OPTIONS_LOC, 0x0);		// clear fax options word
	dp_write_dsp_ram ( 0x48, 2000 ) ;	/* drop out timeout set to 2s  */
	// actual threshold is off by 6dB for the dsp - real value = 43dB
	dp_write_dsp_ram(DP_RSL_THRESH_LOC,
					 G(S).ModemOptions.RxLevel ) ; // rev signal threshold

	// option control word
	reg38 = 0 ;
#if defined (DC0) || defined (CS_ETC)
	if ( G(cell_active) == TRUE )	// disable echo cancellor & freq offset
	{
		reg38 = 0x4000 ;  	// for quick startup
	}
	//clear initial start up bit
	G(ETC_mode) &= ~ETC_MODE_INIT_STARTUP_MASK_BIT ;
#endif

	dp_update_rate();	// set line rate

	switch ( G(S).ModemOptions.DialLineRate )
	{
	case 2 :
		if ( G(S).ModemOptions.V23Reverse )
			reg38 |= 0x0010 ;
		break ;
	case 5 :
		if ( G(S).ModemOptions.CommStdSetting == 1 )
			reg38 |= 0x0001 ;	/* Bell 212A */
		break ;
	}
	switch ( G(S).ModemOptions.GuardTone )
	{
	case 1:
		reg38 |= 0x0002;
		break;
	case 2:
		reg38 |= 0x0004;
		break;
	}
#ifdef SYNCH_MODE
	if (G(S).ModemOptions.V42 == V42_SYNCH_MODE) // Synchronous Mode
	{
		switch (syncTimingMode)
		{
		case '2':				// Slave Timing
			reg38 |= 0x0020;
			break;
		case '3':				// External Timing
			//reg38 |= 0x2000;
			break;
		}
	}
#endif
	dp_write_dsp_ram(DP_OPTIONS_LOC, reg38);

	dp_async_user_mode();

	// BLER threshold - MSE scaling factor
	dp_write_dsp_ram(MSE_SCALE, G(S).ModemOptions.wV34MSEScale);
	c = (byte) (( G(S).ModemOptions.V8_CI_Octet >> 1 ) & 0x70);
	if ( ( G(S).ModemOptions.V42 == V42_LAPM_ONLY     ) ||
		 ( G(S).ModemOptions.V42 == V42_LAPM_BUFFER   ) ||
		 ( G(S).ModemOptions.V42 == V42_LAPM_MNP_DISC ) ||
		 ( G(S).ModemOptions.V42 ==  V42_LAPM_MNP_BUFFER ) )
	{
		// if LAPM enabled
		if (c == 0x60)
			c |= 0x04; // set V.42 bit in CM
	}
#if defined(CS_MODEM)
	else 
#else
	else if ( G(S).ModemOptions.wV34MSEScale == V34_MSE_SCALE )
#endif
	{
		dp_write_dsp_ram(MSE_SCALE, 0x2333); // set bler threshold
	}

#ifdef V34_FAX
		// enable Tx or Rx CM 'option bits' for V.34 Fax.
		// these bits allow flexibility from the answer side to be
		// either Tx or Rx fax.
		// The Tx call function is in bits 4-6 of 0x0822
		// The Rx call options are in bits 7-13 (funtion 0-7, respectively).
	reg38 = (word)c;			// c is a byte stuffed into a word-register.
	reg38 = c | 0x1800;			// set Tx and Rcv-Fax alternate functions
								// bits 11 and 12.
	dp_write_dsp_ram(0x0822, reg38);	// Set CI/CM config and option bits
#else
	dp_write_dsp_ram(0x0822, c);		// Set CI/CM configuration
#endif // V34_FAX

#if !defined(CS_DIGITAL)
	// enable near echo cancellers for non-digital case
	dp_write_dsp_ram(0x0827, (word) (dp_read_dsp_ram(0x0827) | 0x00C0));
	// fine tune the echo cancellers ( system delay ) for v34 and u-test
	dp_write_dsp_ram(0x0ee4, 0x00a0);
	dp_write_dsp_ram(0x0ee5, 0xffa0);
#else
	// for the digital case we write to ee4/ee5 to
	// fine tune the echo cancellers
	dp_write_dsp_ram(0x0ee4, 0x00a0);
	dp_write_dsp_ram(0x0ee5, 0xffa0);
	G(dp_rx_pwr_lvl_high) = 0; 
#if	defined (CS_MODEM) || defined (COPERNICUS)
	if (G(S).ModemOptions.Dummy23) 
		dp_write_dsp_ram(0x0ee4, G(S).ModemOptions.Dummy23);
	if (G(S).ModemOptions.Dummy20) 
		dp_write_dsp_ram(0x0ee5, 0xff00 | G(S).ModemOptions.Dummy20);
#endif	//defined (CS_MODEM) || defined (COPERNICUS)

	// only turn on the near canceller if enabled through s25
	if (G(S).ModemOptions.Dummy25)
		dp_write_dsp_ram(0x0827, dp_read_dsp_ram(0x0827) | 0x0080);
#endif

	if ( ( G(S).ModemOptions.DialLineRate == 2 )		// V.23
		&& ( G(S).ModemOptions.V23Reverse == 1 )		// 75T 
		&& ( G(x_modem_state) == MS_ANSWERING ) )		// answering mode
	{
		dp_transmit_level((byte)(G(S).ModemOptions.TxLevel + 1));
	}
	else
		dp_transmit_level(G(S).ModemOptions.TxLevel);

	dp_write_dsp_ram(DSP_STATUS_RAM, 0); // clear all status bits
	G(oldSPTR) = 0;
	G(dp_bV34WkState) = WRK_STARTUP; // init. workaround state.
}

#if !defined(CS_MODEM)
/****************************************************************
Routine : dp_analog_loopback_cmd
*****************************************************************/
void dp_analog_loopback_cmd ( void )
{
	byte ar, am ;
	
	ar = G(S).ModemOptions.AutoRate ;
	am = G(S).ModemOptions.AutoMode ;
	G(S).ModemOptions.AutoRate = 0 ;
	G(S).ModemOptions.AutoMode = 0 ;
	dp_update_modem_options () ;
	dp_modem_command ( LL_TEST, 0, 0 ) ;
	G(S).ModemOptions.AutoRate = ar ;
	G(S).ModemOptions.AutoMode = am ;
}

/****************************************************************
Routine :
*****************************************************************/
void dp_rem_digital_loop_cmd ( void )
{
	x_send_mail ( DP_IO_V54_ORIGINATE, IO_TASK, NULL, 0 ) ;
}

/****************************************************************
Routine :
*****************************************************************/
void dp_v54_terminate_cmd ( void )
{
	x_send_mail ( DP_IO_V54_TERMINATE, IO_TASK, NULL, 0 ) ;
}
#endif //CS_MODEM

/****************************************************************
Routine : dp_modem_idle_cmd() -
		send the MODEM_IDLE command to the DSP
*****************************************************************/
void dp_modem_idle_cmd ( void )
{
	dp_modem_command(MODEM_IDLE, 0, 0);

	// Backdoor command to write DSP register 0xD1
	// Write default for RRM0. (DSP doesn't program
	// this one in idle command).  This solved the bug
	// where after an 11025 samples per second TAD
	// session everything was messed up.
	dp_modem_command_long(0x03, 0xD1, 0, 0x2A, 0);
}

/****************************************************************
Routine : dp_offhook_cmd()

	Go off hook.
*****************************************************************/
void dp_offhook_cmd(void)
{
#if !defined(CS_DIGITAL)
	word offhook_timer;
#endif // !CS_DIGITAL

#ifdef DC0
	if ( G(cell_active) == TRUE )
		return ;
#endif
	x_output(IO_SHUNT_ON);
	if ( G(S).ModemOptions.SpeakerControl )
	{
		dp_modem_idle_cmd();
		x_output(IO_SPEAKER_ON);		// take care of spk volume, too
	}

#if !defined(CS_DIGITAL)
	// wait for ring to go off
	offhook_timer = x_current_time();
	while ((dp_ring_detected () == TRUE) &&
		   (x_elapsed_time (offhook_timer) < SECOND3))
	{
		;
	}

	// turn-off caller id relay
	x_output (IO_CALLER_ID_OFF);
#endif

	// Turn AC off-hook relay on 
	x_output ( IO_AC_OH_RLY_ON ) ;
	// first connect modem to telco before disconnecting local phone
	x_output ( IO_OFF_HOOK ) ;

	if ( (G(x_modem_mode) == MODEM_VOICE)
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
		 || (G(x_modem_mode) == MODEM_SPEAKER_PHONE)
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
		 )
	{
		x_output ( IO_DV_RLY_OFF ) ;
		// caller id relay - needed to be on for the two relay scheme
		// to monitor local phone during tad & speaker phone operation
#ifdef TWO_RELAY_SCHEME
		x_output ( IO_CALLER_ID_ON ) ;
#endif
	}
	else
	{
		// for data & fax modes - disable local phone
		x_output ( IO_DV_RLY_ON ) ;

#if !defined(CS_MODEM)
		// init ati11 cmd parameters for each new data call
		at_init_diagnostics () ;
#endif
	}

#if !defined(CS_DIGITAL)
#if defined(VENUS_WORLD_DAA)
	offhook_timer = x_current_time();
	while (x_elapsed_time(offhook_timer) <=  
		   (10 * (word)G(S).ModemOptions.OffhookShuntTime))
	{
		;
	}
#endif // VENUS_WORLD_DAA
	x_output ( IO_SHUNT_OFF ) ;
#endif // !CS_DIGITAL

#if !defined(CS_MODEM) || defined(CLASS2_FAX)
	//---------------------------------------
	// Prevent false local phone event
	// caused by modem off-hook switch.
	//---------------------------------------
	dp_init_local_phone_timer () ;
#endif

	//---------------------------------------
	// Turn OFF hook (yellow) LED on
	//---------------------------------------
#if defined(THUNDER)
# if !defined(ATHENA_LEDS)
	if ( z80_modem_type == USB_INTERFACE )
# endif
		x_output( IO_OFF_HOOK_LED_ON ) ;
#elif defined(USB_MODEM) || defined(ATHENA_LEDS)
	x_output( IO_OFF_HOOK_LED_ON ) ;
#endif	// THUNDER
}

/****************************************************************
Routine : dp_update_diagnostics

	Update diagnostics information for ATI11 command.
*****************************************************************/
void dp_update_diagnostics ( void )
{
#if !defined(CS_MODEM)
	if ( G(V34Mode) )
		dp_get_line_rate () ;
	// update 'ati11' diagnostics information
	G(x_status).FinalTransmitRate = (word) G(x_line_rate_tx);
	G(x_status).FinalReceiveRate = (word) G(x_line_rate);
	G(x_status).NoiseLevel = dp_read_dsp_ram(DP_MSE_LOC);
	G(x_status).ReceiveLevel = dp_read_dsp_ram(DP_SIGNAL_LEVEL_LOC);
	G(x_status).TransmitLevel = dp_read_dsp_ram(DP_XMIT_LEVEL_LOC);
	G(x_status).RoundTripDelay = dp_read_dsp_ram(DP_ROUNDTRIPDLY_LOC);
	G(x_status).NearEchoLevel = dp_read_dsp_ram(DP_NEARECHO_LOC);
	G(x_status).FarEchoLevel = dp_read_dsp_ram(DP_FARECHO_LOC);
#endif // !CS_MODEM

}

/****************************************************************
Routine : on hook cmd
*****************************************************************/
void dp_onhook_cmd ( void )
{
#if defined ( K56FLEX ) || defined ( VPCM_CLIENT ) || defined ( VPCM_SERVER )
	// if in K56 mode we need to get back
	// to IROM before we go messing around
	dp_56k_idle();
#endif

#ifdef DC0
	cell_onhook () ;
#endif
	dp_modem_idle_cmd();
	x_output ( IO_SPEAKER_OFF ) ;
	x_output ( IO_AUDIO_CODEC_OFF ) ;
	x_output ( IO_CALLER_ID_OFF ) ;
	// first connect local phone to telco before hanging up modem
	x_output ( IO_DV_RLY_OFF ) ;
	x_output ( IO_SHUNT_OFF ) ;
	if ( G(S).ModemOptions.HangupControl == 0 )
	{
		x_output ( IO_LOCAL_PHONE_OFF ) ;
		x_output ( IO_ON_HOOK ) ;
		// Turn AC off-hook relay off 
		x_output ( IO_AC_OH_RLY_OFF ) ;
	}
	else
	{
		G(S).ModemOptions.HangupControl = 10 ;
	}
	// to restore the orig. code from the V.ib patch
	dp_disable_workaround();

	DP_CLR_CORE_INTS( ALLINTS ) ;

	G(dp_tad_downloaded) = FALSE ;
	G(dp_fax_downloaded) = FALSE ;
#if !defined(CS_MODEM) || defined(CLASS2_FAX)
	G(last_fax_v17) = NON_V17;
#endif

#if defined(V8BIS)
	v8bis_app_reset1 () ;
#endif

#if !defined(CS_MODEM) || defined(CLASS2_FAX)
	// Prevent false local phone event caused by modem off-hook switch.
	dp_init_local_phone_state();
#endif
	G(V34Mode) = 0 ;
	G(dp_first_call) = FALSE ;
#if defined ( VPCM_CLIENT ) || defined ( VPCM_SERVER )
	vpcm_hangup () ;
#endif	// VPCM_CLIENT || VPCM_SERVER

	//---------------------------------------
	// Turn OFF hook (yellow) LED off
	//---------------------------------------
#if defined(THUNDER)
# if !defined(ATHENA_LEDS)
	if ( z80_modem_type == USB_INTERFACE )
# endif
		x_output( IO_OFF_HOOK_LED_OFF ) ;
#elif defined(USB_MODEM) || defined(ATHENA_LEDS)
	x_output( IO_OFF_HOOK_LED_OFF ) ;
#endif	// THUNDER

	G(dp_line_state) = DP_LINE_ON_HOOK ;
}

/****************************************************************
Routine : dp_retrain_cmd

	Do a V.34 or below retrain.
*****************************************************************/
void dp_retrain_cmd ( void )
{
#if !defined(CS_MODEM)
	LOCAL_RET_INCREMENT;
#else
	cs_update_local(RETRAIN);
#endif

	dp_update_rate();
	dp_modem_command(RETRAIN, 0, 0 );
}

/****************************************************************
Routine : dp_fast_retrain_cmd

	Do a V.34 or below fast rate change.  (aka rate renegotiation)
*****************************************************************/
void dp_fast_retrain_cmd ( void )
{
#if !defined(CS_MODEM)
	LOCAL_RR_INCREMENT;
#else
	cs_update_local(FAST_RATE_CHANGE);
#endif

	dp_update_rate();
	dp_modem_command(FAST_RATE_CHANGE, 0, 0 );
	G(dp_line_state) = DP_LINE_RETRAINING;
}

#ifdef VPCM_SERVER
/***************************************************************
Routine : dp_v90_fast_retrain_cmd() - ask for fast rate change
*****************************************************************/
void dp_v90_fast_retrain_cmd ( void )
{
#ifdef CS_MODEM
	cs_k56_remote_or_local(FAST_RATE_CHANGE);
#else
	LOCAL_RR_INCREMENT;
#endif
	x_debug_msg("dp_v90_fast_retrain_cmd()");
	dp_modem_command(FAST_RATE_CHANGE, 0, 0);
	G(dp_56k_state) = VPCM_RATECHANGE;
	dp_write_dsp_ram(0x1ff0, 0x0);	//Host_flg
}
#endif //VPCM_SERVER

/****************************************************************
Routine : dp_cleardown_cmd

	Do a cleardown.
*****************************************************************/
void dp_cleardown_cmd ( void )
{
	G(dp_cleardown_wait) = FALSE;	// assume no cleardown...

#if defined ( K56FLEX ) || defined(VPCM_CLIENT) || defined (VPCM_SERVER)
	if (dp_56k_map())
	{
		// if in K56 mode we need to get back
		// to IROM before we go messing around
		x_debug_msg("DP - cleardown not supported in k56 mode");
		return;
	}
#endif

	if (!(dp_read_dsp_ram(DSP_STATUS_RAM) & 1))	// 1 - status clear down
	{
		/* if we are in V.32 and the remote modem suport V.32bis */
		if ( (G(x_line_rate) >= MR_4800) && 
		     (dp_read_dsp_ram(0x35) & 0x110) )
		{
			x_debug_msg ( "DP - sent clear down sequence" ) ;
			dp_write_dsp_ram ( 0x1, V32_RETRAIN ) ;	// send clear down
			dp_modem_command ( FAST_RATE_CHANGE, 0, 0 ) ;
			// wait for cleardown in DP_DISCONNECT (jmg 121098)
			G(dp_cleardown_wait) = TRUE;
			//dp_modem_command ( RETRAIN, 0, 0 ) ;
		}
		else if ( (G(x_line_rate) >= MR_2400) && G(V34Mode) )
		{
			x_debug_msg ( "DP - sent V34 clear down sequence" ) ;
					// clear bits in V.34 Data rate Capability reg
			dp_write_dsp_ram(DP_V34_DATA_RATE, 0);
			dp_modem_command(FAST_RATE_CHANGE, 0, 0 ) ;
			// wait for cleardown in DP_DISCONNECT (jmg 121098)
			G(dp_cleardown_wait) = TRUE;
		}
		else if ((G(S).ModemOptions.AdjustBPS & 2) &&
				 ((MR_2400 == G(x_line_rate)) ||
				  (MR_1200 == G(x_line_rate))) &&
				 (EC_NO == G(x_modem_ec)))
		{
			dp_modem_command_long(PDM, 0, 0x01, 0x87, 0);
			x_sleep(SECOND4);
			x_output(IO_ON_HOOK);
		}
		else
		{
			x_debug_msg("DP - sent onhook cmd");
			x_output(IO_ON_HOOK);
		}
	}
} // dp_cleardown_cmd()

extern void vpcm_set_calling_mode(void);

/****************************************************************
Routine : dp_originate_cmd()

	This is called when answer tone has been detected long enough to
	begin the (data) startup.  We could be heading for V.34 or V.90.

*****************************************************************/
void dp_originate_cmd(void)
{
#if (defined(CS_CALLBACK) && defined(VPCM_SERVER)) || defined(VPCM_CLIENT)

	// to get to V.90, need S38 non-zero and S109 non-zero
	// and S37 such that we're allowing 4800 or above upstream.
	if (G(S).ModemOptions.Rate56K && G(S).ModemOptions.VpcmOption &&
		((0 == G(S).ModemOptions.DialLineRate) ||
		 (G(S).ModemOptions.DialLineRate > 6))
		)
	{
		vpcm_set_calling_mode();
#if defined(VPCM_CLIENT)
		if (G(S).ModemOptions.VpcmOption)	// V.90 enable
			G(vpcm_mode) = 1;		// V.90 enabled
		else
			G(vpcm_mode) = 0;		// V.90 disabled
#ifdef V92
		if (G(S).ModemOptions.VpcmOption & BIT2)	// V.92 quick connect enable
		{
			//set connection status bit
			G(vpcm_connection_status) = (byte)(G(vpcm_connection_status) | 0x2);
			// set bit 8 in dsp ram 0x1ff2 for QC short phase 1 startup
			dp_write_dsp_ram(K56Opt, (word) (dp_read_dsp_ram(K56Opt) | 0x100));
			x_debug_msg("DP- QC short phase 1 enabled");
		}
		else
		{
			x_debug_msg("DP- do normal v90 connect");
			//set connection status bit
			G(vpcm_connection_status) = (byte) (G(vpcm_connection_status) | 1);
		}
#endif	//V92
		dp_56k_init();
#else
		vpcm_startup();
#endif
		return;
	}
#endif	// V.90

#ifndef CS_MODEM
	G(x_status).ud_CallResult = UD_CS_ANSWER_TONE;
#endif
	dp_modem_idle_cmd();
	dp_update_modem_options () ;

	dp_modem_command(STARTUP, ORIGINATE, 0);

#ifdef CS_MODEM
	while (cs_ack_received() == FALSE)
		;
	cs_compose_cmd( MDM_STATE, 1, 2, 0);
#endif

#if defined(CS_DIGITAL) && defined(CS_MODEM)
	x_sleep ( 100 ) ; //allow some time to stabilize
    dp_write_dsp_ram ( 0x0ee4, 0xa0 ) ;
    dp_write_dsp_ram ( 0x0ee5, 0xffa0 ) ;
#endif

#if defined(V80) && !defined(CS_MODEM)
	dp_v8_originate_msg () ;
#endif
	G(dp_state) = DP_TRAINING ;
}

/****************************************************************
Routine : dp_answer_cmd

	Answer in data mode, V.34 or below.
*****************************************************************/
void dp_answer_cmd ( void )
{
	dp_modem_idle_cmd();
	dp_update_modem_options () ;

#if defined(CS_MODEM)
	// Change pll to lower value for non-k56 startup
	// DSP clock speed = 52.66 MHz @ 36 MHz
	dp_modem_command_long(0x2e, 0x01, 0x3e, 0xb2, 0);
	x_sleep ( 30 ) ; //allow some time to stabilize
#endif

	dp_modem_command(STARTUP, ANSWER, 0);

	G(dp_state) = DP_TRAINING;
	G(dp_line_state) = DP_LINE_TRAINING;

#if defined(CS_MODEM)
	if (v8bisflag != 1) 	// did not send MDM_STATE previously
	{
		while (cs_ack_received() == FALSE)
			;
		cs_compose_cmd( MDM_STATE, 1, 2, 0);
	}
#endif

#if defined(CS_DIGITAL) && defined(CS_MODEM)
	x_sleep(100); //allow some time to stabilize
    dp_write_dsp_ram ( 0x0ee4, 0xa0 ) ;
    dp_write_dsp_ram ( 0x0ee5, 0xffa0 ) ;
#endif
}

/****************************************************************
Routine :
*****************************************************************/
byte dp_line_connect ( void )
{
	// look at bamil register for off hook relay
	if ( ( dp_regread ( 0x19 ) & 0x10 ) ||   // off hook relay active
		 ( dp_regread ( 0x16 ) & 0x04 ) ) // if cd lead (RR) active
		return ( TRUE ) ;
	else
		return ( FALSE ) ;
}

/****************************************************************
Routine : dp_ring_detected()
*****************************************************************/
byte dp_ring_detected(void)
{
	if (dp_read_dsp_ram(DSP_STATUS_RAM) & 0x20)
		return TRUE;
	else
		return FALSE;
}

/****************************************************************
Routine : dp_lapm_capable()

	Return:

	YES - V.8 (or anything else) indicates
	that the remote modem is able to do LAPM protocol.

	NO - indicates the remote modem is not capable
	of doing LAPM protocol now. (perhaps because
	it's so optioned.)

	DONTKNOW - unknown whether the remote modem can
	do LAPM or not.  (old modulations don't give
	this info in startup.)

	This is meant to be called by LAPM functions.
*****************************************************************/
byte dp_lapm_capable(void)
{
	if (
#if !defined(CS_MODEM)
	G(x_status).Connection >= AT_MOD_V34  &&
#endif
		0x0100 == (0x0300 & dp_read_dsp_ram(DP_V8_STATUS))
#if defined (V92) && defined (VPCM_CLIENT)
	 	|| ( (G(S).ModemOptions.VpcmOption & 0x4) &&
			(G(vpcm_remote_qc_parameter) & 0x20) )
	 	|| ( (G(S).ModemOptions.VpcmOption & 0x4) &&
			(G(vpcm_v92_status) & 0x400) )
#endif //defined (V92) && defined (VPCM_CLIENT)
		)
	{
		//x_debug_msg("DP - dp_lapm_capable returns YES");
		return YES;
	}
	else
	{
		//x_debug_msg("DP - dp_lapm_capable returns DONTKNOW");
		return DONTKNOW;
	}
}

/****************************************************************
Routine : dp_init_modem_connection()

		Returns TRUE when we've made it on line.

		Sets up variables to reflect the current operating
		mode:  v34, v32, etc.

		Turns off the speaker if appropriate.
*****************************************************************/
byte dp_init_modem_connection(void)
{
	word temp_wd ;

	G(dp_count) = 0 ;
	if (G(V34Mode))
	{
		dp_get_line_rate();		// set x_line_rate/x_line_rate_tx
		if (G(x_line_rate) == 2)
		{
			x_debug_msg("dp_init_modem_connection x_line_rate = 2");
			return FALSE;
		}

#if !defined(CS_MODEM)
		G(x_status).Connection = AT_MOD_V34;	// v.34 connection
#endif

		temp_wd = (word) (dp_read_dsp_ram(DP_V34_DATA_RATE) & G(V34Mode));
		G(dp_max_line_rate) = MR_33600 ;
		while ( !(temp_wd & 0x2000) && G(dp_max_line_rate) )
		{
			G(dp_max_line_rate) = (MODEM_LINE_RATE)(G(dp_max_line_rate) - 1) ;
			temp_wd <<= 1 ;
		}
	}
	else // V32 (or below) mode
	{
		G(dp_max_line_rate) = G(x_line_rate) ;
		dp_modem_rate();		// set x_line_rate/x_line_rate_tx

		G(x_line_rate_tx) = G(x_line_rate);	// in V.32 tx & rx rates are same

		if ( ( G(S).ModemOptions.AutoMode == 0 ) &&
			( G(S).ModemOptions.AutoRate == 0 ) )
		{
			if ( G(dp_max_line_rate) != G(x_line_rate) )
				return FALSE;
		}
		G(dp_wV32bisRcvRate) = dp_read_dsp_ram(0x35);

#if !defined(CS_MODEM)
		// Fill in x_status.Connection with the current modulation
		switch (G(S).ModemOptions.DialLineRate)
		{
		case 2:
			G(x_status).Connection = AT_MOD_V23C;
			break;
		case 3:
			if (G(S).ModemOptions.CommStdSetting == 0)
				G(x_status).Connection = AT_MOD_V21;
			else
				G(x_status).Connection = AT_MOD_BELL103;
			break;
		default:
			switch (dp_read_dsp_ram(0x3b))
			{
			case 0x2:
			case 0x8:
			case 0x82:
			case 0x87:
				if (G(S).ModemOptions.DialLineRate <= 11)
					G(x_status).Connection = AT_MOD_V32;
				else
					G(x_status).Connection = AT_MOD_V32B;
				break;
			case 0x13:
			case 0x88:
				G(x_status).Connection = AT_MOD_V22B;
				break;
			case 0x11:
			case 0x89:
				if (G(S).ModemOptions.CommStdSetting == 1)
					G(x_status).Connection = AT_MOD_BELL212A;
				else
					G(x_status).Connection = AT_MOD_V22;
				break;
			}
		}
#endif
	}

	// Turn off speaker if options indicate.
	if ( (G(S).ModemOptions.SpeakerControl == 1) ||
	     (G(S).ModemOptions.SpeakerControl == 3) )
		x_output(IO_SPEAKER_OFF);

	if ( G(x_modem_mode) == MODEM_DATA )	// data mode
	{
		if ( (G(S).ModemOptions.DialLineRate == 2) ||
	 		(dp_read_dsp_ram(0x3b) == 0x9) || // auto mode to v.23
	 		(dp_read_dsp_ram(0x3b) == 0x86) ) // auto mode to v.23
			G(S).ModemOptions.V23mode = TRUE ;
		else
		 	G(S).ModemOptions.V23mode = FALSE ;
	}

	if ( ( ( G(S).ModemOptions.V8_Answer == DCE_V8_ANS_ENABLE ) ||
		   ( G(S).ModemOptions.V8_Orig == DCE_V8_ORIG_ENABLE ) ) &&
		 !G(V34Mode) )
	{
		return FALSE;
	}

	if ( (G(wSymbolRate) & 0x0400) != 0 )
	{
#ifdef VPCM_SERVER					
		if(G(vpcm_mode)==0)			
#endif //VPCM_SERVER				
		{						
			dp_disable_33600 () ;
		}							
	}


#if !defined(CS_MODEM)
	// Update 'ati11' diagnostics information for
	// initial transmit and receive rates.
	//
	// this is called when getting
	// out of a retrain so I can't always set
	// the initial rates
	if (MS_ON_DIAL != G(x_modem_state))
	{
		G(x_status).IniTransmitRate = (word) G(x_line_rate_tx) ;
		G(x_status).IniReceiveRate = (word) G(x_line_rate) ;
	}
#endif // CS_MODEM

	dp_lapm_error_check_init(); 	// initialize lapm error checking variables

#if !defined(CS_DIGITAL) && defined(CALL_WAITING) && defined(COMPRESS_TABLES) && !defined(V34_FAX) && !defined(DRAGNET)
	if (G(V34Mode) && G(dp_CallWaitingEnable) != 2)
	{
		// V.34 call waiting detection
		extern void dp_download_call_waiting();

		dp_disable_workaround();		// DPRAM_BAUD(0xf20) = DSP_NUL(0x8ece)
		dp_download_call_waiting();
		dp_write_dsp_ram(AP_DPRAM_BAUD, 0xd820);	// set up for call waiting
	}
#endif

	dp_update_diagnostics();	// x_status info for ATI11
	return TRUE;
}

/****************************************************************
Routine :  dp_dial_connect_success

	See whether we're done training.

	Return TRUE means done, FALSE means not done.
*****************************************************************/
byte dp_dial_connect_success ( void )
{
#if defined(K56FLEX) || defined(VPCM_CLIENT) || defined(VPCM_SERVER) || defined(V34_FAX)
	if (!dp_56k_map())
#endif
		dp_v34_workaround();

	// check DP_RR - carrier detect first before reading dsp ram
	if ( ( dp_regread(DP_EIA_REGISTER) & 0x04 ) == 0 )
		return FALSE;

	if (dp_read_dsp_ram(DSP_STATUS_RAM) & 0x0008)	// data mode
	{
		G(dp_dsp_status) = dp_regread(DP_STATUS_REG);
		if ( (G(dp_dsp_status) & RETRAIN_STATUS) == 0 )	// data mode
		{
			G(dp_bFallForward) = 1; // enable fallforward 
			G(dp_bGoodAuto) = 0;
			G(V34Mode) = dp_read_dsp_ram(0x817); // remote v34 line speed cap

			// In V.34, check that we've really made it to
			// datamode by looking at sptr and rptr
			if (G(V34Mode) && !dp_56k_map() &&
				(( G(dp_s_ptr) != 0x24d5 )			// sptr!=datamode
				 || ( G(dp_r_ptr) != 0xbb53)))		// rptr!=datamode
			{
				return FALSE;
			}
#if defined(DC0) || defined(CS_ETC)
			if ( G(ETC_mode) )
			{
				word temp_wd ;

				// need to do this in case retrain during link negotiation
				G(dp_count) = 0 ;

				if (G(V34Mode))
				{
					temp_wd = dp_read_dsp_ram(DP_V34_DATA_RATE) & V34_4800;
					dp_write_dsp_ram(DP_V34_DATA_RATE, temp_wd);
				}
				else
				{
					temp_wd = dp_read_dsp_ram(0x0001) & V32_4800;
					dp_write_dsp_ram ( 0x0001, temp_wd ) ;
				}
			}
#endif
			return dp_init_modem_connection();
		}
	}

	return FALSE;
}

/****************************************************************
Routine : dp_send_constel_point
Description : Send a constellation point to vconstel.
			  If EchoConstel is set to 2, data will be piped to
			  the debug port.

		Constellation prefix is p.  Point is (x,y)
*****************************************************************/
void dp_send_constel_point(byte p, word x, word y)
{
	if (G(S).ModemOptions.EchoConstel == 2)	// send to debug port
	{
		sendDumbChar(p);
		sendDumbChar((char)(x >> 8));
		sendDumbChar((char)x);
		sendDumbChar((char)(y >> 8));
		sendDumbChar((char)y);
	}
	else	// send to DTE
	{
		io_put_dte_tx_char(p);
		io_put_dte_tx_char((char)(x >> 8));
		io_put_dte_tx_char((char)x);
		io_put_dte_tx_char((char)(y >> 8));
		io_put_dte_tx_char((char)y);
	}
}

extern void ll_newConstelPoint(unsigned short x, unsigned short y); // WIN32

/****************************************************************
Routine : dp_echo_constellation
Description : Read constellation points from dsp and echo it back to conport
*****************************************************************/
void dp_echo_constellation()
{
	word x, y;

	if ( (!G(S).ModemOptions.EchoConstel) || 
		 (x_elapsed_time (G(dp_const_timer)) <
		  (G(S).ModemOptions.EchoConstel))  )
	{
		return;
	}

	x = dp_read_dsp_ram(0x122);
	y = dp_read_dsp_ram(0x123);

	if (y)
	{
#if defined(WIN32)
		if (MS_IDLE != x_modem_state)
			ll_newConstelPoint(x, y);
#else
		dp_send_constel_point(0x1B, x, y);
#endif
	}
	G(dp_const_timer) =  x_current_time();
}

/****************************************************************
Routine : dp_echo_ram
Description : Read ram points from dsp and echo it back to conport
*****************************************************************/
void dp_echo_ram ( void )
{
	word new_ram, ram_add;

	if ( (!G(S).ModemOptions.EchoRam) || 
		(x_elapsed_time(G(dp_ram_timer)) < (8*G(S).ModemOptions.EchoRam)) )
		return;

	ram_add = (word) (G(S).ModemOptions.RamEchoAddrLow +
		0x100*G(S).ModemOptions.RamEchoAddrHigh);
	if (ram_add == 0)
		ram_add = DP_MSE_LOC;	  // default is rmse
	new_ram = dp_read_dsp_ram ( ram_add ) ;
	G(dp_ram_timer) =  x_current_time () ;

#if defined(WIN32)
	if (MS_IDLE != x_modem_state)
		ll_newConstelPoint(0xffff, new_ram);
#else
	if( G(S).ModemOptions.EchoRam == 2 )	// send to Debug port - jmg 100899
	{
		sendDumbChar(0x1C) ;
		sendDumbChar((char)(new_ram >> 8)) ;
		sendDumbChar((char)new_ram) ;
	}
	else	// send to DTE
	{
		io_put_dte_tx_char(0x1C) ;
		io_put_dte_tx_char((char)(new_ram >> 8)) ;
		io_put_dte_tx_char((char)new_ram) ;
	}
#endif
}

/****************************************************************
Routine : dp_echo_trec
Description : Read timing recovery (or other) points from dsp and
		echo it back to be displayed by vconstel
*****************************************************************/
void dp_echo_trec ()
{
#if !defined(WIN32) && defined(Z80_DEBUG_PRINT)
	short new_trec_x, new_trec_y;

	if (MS_IDLE == G(x_modem_state) ||
		!G(S).ModemOptions.EchoConstel || 
		(x_elapsed_time(G(dp_trec_timer)) < (4*G(S).ModemOptions.EchoConstel)))
	{
		return;
	}

	// we can display different things in this window
	switch (G(dp_vc_right).mode)
	{
	case 0:				// normal mode - timing recovery
	default:
		new_trec_x =  (short) dp_read_dsp_ram ( 0x1a7) ;
		new_trec_y =  (short) dp_read_dsp_ram ( 0x1a8) ;
		break;
	case 1:				// transmit constellation
		new_trec_x =  (short) dp_read_dsp_ram ( 0x182);
		new_trec_y =  (short) dp_read_dsp_ram ( 0x183);
		break;
	case 2:				// RAM values - every other loc
		if (x_elapsed_time (G(dp_trec_timer)) < 300)
		{
			return;		// every 500 MS
		}
		{
			word j, k, end=G(dp_vc_right).len*2 + G(dp_vc_right).start;

			// try to get 900 points of data
			word deltaX, ppx = 900 / G(dp_vc_right).len; // points per X

			if (0 == ppx)
				ppx = 1;
			deltaX = 30000 / (ppx * G(dp_vc_right).len);

			if (G(dp_vc_right).current >= end)
				G(dp_vc_right).current = G(dp_vc_right).start;
			k = (G(dp_vc_right).current - G(dp_vc_right).start)/2;
			new_trec_x = -15000 + (k * ppx * deltaX); // start vconstel coords

			// only do a segment of the points this time through, max 100
			k = G(dp_vc_right).current + (100 / ppx);
			if (k < end)
				end = k;		// end DSP RAM location

			for (; G(dp_vc_right).current <= end;
				 G(dp_vc_right).current +=2)
			{
				new_trec_y = (short) dp_read_dsp_ram(G(dp_vc_right).current);
				for (j=0; j<ppx; j++)
				{
					dp_send_constel_point(0x1D, (word) new_trec_x,
										  (word) new_trec_y);
					new_trec_x += deltaX;
				}
			}
		}
		G(dp_trec_timer) = x_current_time();
		return;
	}

	G(dp_trec_timer) = x_current_time();

	if ((G(dp_old_trec_x) == new_trec_x) && (G(dp_old_trec_y) == new_trec_y))
		return;
	G(dp_old_trec_x) = new_trec_x;
	G(dp_old_trec_y) = new_trec_y;

	dp_send_constel_point(0x1D, new_trec_x, new_trec_y);
#endif // Z80_DEBUG_PRINT && !WIN32
}

/****************************************************************
Routine : dp_monitor_frate_timer()

	Has it been 12 seconds since the last fast rate change?
*****************************************************************/
void dp_monitor_frate_timer()
{
	if ((G(dp_frate_timer)) && (x_elapsed_time (G(dp_frate_timer)) > SECOND12))
		G(dp_frate_timer) = 0;
}

/****************************************************************
Routine: dp_rate_change_cmd()

	Initiate retrain or fast rate change.
*****************************************************************/
void dp_rate_change_cmd(byte bFallback)
{
	// disable v.80 dsp patch (or) any other dsp workaround
	dp_disable_workaround () ;

	G(dp_bGoodAuto) = 0 ;
	G(dp_count) = 0 ;

#if !defined(CS_MODEM) && !defined(VPCM_SERVER)
	LOCAL_RET_INCREMENT ;
#endif

#if defined (DC0) || defined (CS_ETC)
	if ( G(cell_active) == TRUE )
	{
		x_debug_msg ( "dp - fast rate change" ) ;
		dp_modem_command ( FAST_RATE_CHANGE, 0, 0 ) ;
		return ;
	}
#endif

	if (( !bFallback ) || (G(dp_frate_timer) == 0))
	{
		// forward is always fast rate change.  fallback coming from a
		// retrain or more than 12 seconds elapsed since last fast
		// rate change in which case dp_monitor_frate_timer will put
		// back G(dp_frate_timer) back to zero
		x_debug_msg ( "dp - fast rate change" ) ;
		dp_modem_command ( FAST_RATE_CHANGE, 0, 0 ) ;
		G(dp_frate_timer) = x_current_time () ;
#ifdef CS_DIGITAL
		G(dp_cs_local_retrain_ratechange) = 3;	   // set to 3 instead of 1
#endif
#if defined(CS_MODEM)
		cs_update_local(FAST_RATE_CHANGE);
#endif
	}
	else
	{
		// fallback logic requires full retrain in case of frequent fast rate change occurrence
		cs_insert_error_tag(0xe600 , 0);
		x_debug_msg ( "dp - retrain cmd" ) ;
		dp_modem_command ( RETRAIN, 0, 0 ) ;
		G(dp_frate_timer) = 0 ;	// next fallback should be a fast rate change.
#ifdef CS_DIGITAL
		G(dp_cs_local_retrain_ratechange) = 3;	   // set to 3 instead of 1	 
#endif
#if defined(CS_MODEM)
		cs_update_local(RETRAIN);
#endif
	}
}

/****************************************************************
Routine : dp_auto_rate()
		Make decisions about falling back or falling
		forward for V.34 mode.
*****************************************************************/
void dp_auto_rate(void)
{
	if (G(dp_dsp_status) & FALLBACK_STATUS)		// high Mean Squared Error
	{
		G(dp_bGoodAuto) = 0;
#if defined(V92_MODEM_ON_HOLD)
		// maybe the bad MSE is due to a modem on hold event on the
		// other side.  if enabled, we need to get ready to do modem
		// on hold procedures.
		if (G(S).ModemOptions.MHOptions & MH_ENABLED
			&& G(S).ModemOptions.MHOptions & MH_GRANT
			&& G(dp_mh_state) == MH_NULL)
		{
			dp_download_mh();
			G(dp_mh_state)=MH_R_INIT; // start respondent mode
			return;
		}
#endif
		cs_insert_error_tag ( 0x4100, 0 );
		x_debug_msg("dp_auto_rate-fallback++...");

		if ( ++G(dp_count) >= 16 ) // fallback in 8 seconds
		{
			G(dp_bFallForward) = 2 ; // indicates a local fallback.
			dp_rate_change_cmd ( 1 ) ;
			cs_insert_error_tag(0xe800 , 0);
			x_debug_msg("dp_auto_rate-*** Fallback ***" ) ;
		}
	}
	else // no fallback indication.
	{
		if ( G(dp_count) >= 1 )
		{
			cs_insert_error_tag ( 0x4000, 0  );
			x_debug_msg("dp_auto_rate-fallback--...");
			G(dp_count)-- ;
			return ;
		}
		if ( G(S).ModemOptions.V42 == V42_SYNC_BUFFERED )
		{
			if ( G(dp_bFallForward) == 0 )
				return ;
		}
		else
		{
			// do not fall forward if there is no error correction - No V.42
			if ( G(x_modem_ec) == EC_NO )
				return ;
		}
		if (G(V34Mode)) // if remote is a V34 modem
		{
			if ((G(x_line_rate) >= G(dp_max_line_rate)) ||
				(!(G(V34Mode) & 0x8000)))
			{
				return;
			}
		}
		// if remote is v32 only modem and not v32 bis
		else if ((( G(dp_wV32bisRcvRate) & 0x0110 ) != 0x0110 ) || \
					( G(dp_bFallForward) == 0 ) ||	\
					( G(x_line_rate) >= MR_14400 ) )
		{
			return ;
		}
		if ( G(dp_dsp_status) & FALLFORWARD_STATUS )
		{
			cs_insert_error_tag ( 0x4200, 0 );
			x_debug_msg ( "dp-fallforward++..." ) ;
			++G(dp_bGoodAuto) ;
		}
		else if ( G(dp_bGoodAuto) )
		{
			cs_insert_error_tag ( 0x4300, 0 );
			x_debug_msg ( "dp-fallforward--..." ) ;
			--G(dp_bGoodAuto) ;
		}
		if ( G(dp_bGoodAuto) >= 40 )
		{
			dp_rate_change_cmd( 0 ) ;
			cs_insert_error_tag ( 0x4400, 0 );
			x_debug_msg ("dp-*** Fallforward ***");
			cs_insert_error_tag(0xe700 , 0);
			G(dp_bFallForward) = 0 ;
		}
	}
}

/****************************************************************
Routine : dp_carrier_loss
		This is called from DP_ON_DIAL state.  We're looking
		to see if we've dropped the line.
		(We're not in K56 or V.90 modes.)
*****************************************************************/
byte dp_carrier_loss ( void )
{
	// check DP_RR - carrier detect
	if ( ( dp_regread ( DP_EIA_REGISTER ) & EIA_DP_RR ) == 0 )
		return TRUE;

	// Check to see if we're on hook.  If we are then we certainly
	// don't see any carrier.  (For direct connect modems we can't do
	// this when we're on the cell phone line.)

#if !defined(CS_DIGITAL)
    if( !G( dp_daa_is_perseus ))
    {
        if (
#ifdef DC0
		    (G(cell_active) == FALSE) &&
#endif
		    !(0x10 & dp_regread(0x19)) )
	    {
		    cs_insert_error_tag ( 0x4500, 0 );
		    x_debug_msg("dp_carrier_loss() detects on hook") ;
		    return TRUE;
	    }
    }
#endif //!CS_DIGITAL

	// Since we need to call a workaround while
	// we're on line and it doesn't seem like
	// Apollo needs to, we'll call it here.
	dp_v34_workaround();

	// if we're in 1200 or 2400bps modes with
	// no error correction we'll look for long
	// space disconnect here.
	if ((G(S).ModemOptions.AdjustBPS & 2) &&
		((MR_2400 == G(x_line_rate)) || (MR_1200 == G(x_line_rate))) &&
		(EC_NO == G(x_modem_ec)))
	{
		// long space disconnect.
		// If the workaround hasn't been downloaded
		// but we're in the G(right) mode.
		// then download and set the workaround vector
		if (0x6aab == dp_read_dsp_ram(rxhdlc_opt))
		{
			word i;

			// download the workaround
			for (i=0; i < wLongSpace[1]; i++)
			{
				dp_write_dsp_ram((word) (wLongSpace[0]+i), wLongSpace[i+3]);
			}
			dp_write_dsp_ram(rxhdlc_opt, LongSpaceStart);
			x_debug_msg("rxhdlc_opt vector set up");

			if (LongSpaceStart != dp_read_dsp_ram(rxhdlc_opt))
			{
				x_debug_msg("dsp is dead");
				G(dp_state) = DP_CALL_FAILURE;
				G(x_dial_residual) = MR_CD_DISCONNECT;
				return FALSE;
			}
		}
		// long space disconnect

		// 600 baud for both 1200 and 2400 bps in V.22 bis
		if (LongSpaceStart == dp_read_dsp_ram(rxhdlc_opt) &&
			(dp_read_dsp_ram(LongSpaceLongest) > 1200))
		{
			x_debug_msg("dp - long space disconnect");
			G(dp_state) = DP_CALL_FAILURE ;
#ifndef CS_MODEM
			G(x_status).ud_TerminationCause = UD_TC_NO_CARRIER;
#endif //CS_MODEM
			G(x_dial_residual) = MR_CD_DISCONNECT ;
		}
	}

	return FALSE;
}

/****************************************************************
Routine : dp_retrain() - return TRUE if we're still retraining

	This presumes that dp_dsp_status contains the contents
	of the CAMIL register DP_STATUS_REG.
*****************************************************************/
byte dp_retrain ( void )
{
	// Retraining if dsp status says so and we're off hook.
	if ((G(dp_dsp_status) & RETRAIN_STATUS ) && (0x10 & dp_regread(0x19)))
		return TRUE;
	else
		return FALSE;
}

/****************************************************************
Routine : dp_modem_rate

	Set dp_dsp_status.

	Other strange stuff for fallforward.
*****************************************************************/
void dp_modem_rate(void)
{
	byte speedReg;

	G(dp_dsp_status) = dp_regread(DP_STATUS_REG);
	if ( G(dp_dsp_status) & RETRAIN_STATUS )
		return ;

	speedReg = (byte) ((G(dp_dsp_status) & 0x0f) + 2);
	if ( G(x_line_rate) != speedReg )
	{
		if ( (G(x_line_rate) < speedReg) || (G(dp_bFallForward) == 2) )
		{
			G(dp_bFallForward) = 1 ;
		}
		else
		{
			G(dp_bFallForward) = 0 ; //remote modem initiates a fallback
		}

		if ( !G(V34Mode) )
		{
			G(x_line_rate) = (MODEM_LINE_RATE)speedReg;

			// in v.32 tx & rx rate is the same
			G(x_line_rate_tx) = G(x_line_rate) ;
			G(dp_bGoodAuto) = 0;
		}
	}
}

/****************************************************************
Routine : dp_hdlc_mode
Description : 
	used by io task in v.42, switch to HDLC mode.
*****************************************************************/
void dp_hdlc_mode ( void )
{
	G(DpIdleFillChar) = 0x7e ;
	dp_modem_command_long ( PDM, HDLC_FLAG, 0x01,
							(byte)(HDLC_DATA_MODE & 0xff), 0);
}

/****************************************************************
Routine : dp_sync_mode
Description : put pump in sync mode - used for fax, sync mode etc
*****************************************************************/
void dp_sync_mode ( void ) 
{
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
	if (CLASS_2_OR_20)         // Class 2/2.0 FAX selected?
	{
	#ifdef FAX_ECM
		if (G(ecm_fax_hdlc))	// Sending fax data using HDLC?
			dp_hdlc_mode ();	// Using ECM, so setup pump for HDLC
		else					// NON-ECM FAX
	#endif
		{
			G(DpIdleFillChar) = 0 ;  // Send zeros during idle period
			dp_modem_command_long ( PDM, G(DpIdleFillChar), 0x01, (byte)SYNC_DATA_MODE, 0);
		}
	}
	else
#endif
	{
		G(DpIdleFillChar) = 0xff ;
		dp_modem_command_long(PDM, ASYNC_MARK, 0x01,
							  (byte)(SYNC_DATA_MODE & 0xff), 0);
	}
}

#if !defined(CS_MODEM)
/****************************************************************
Routine : dp_sync_mode_hdlc
Description : put pump in sync mode (requested by at\n9)
*****************************************************************/
void dp_sync_mode_hdlc ( void ) 
{
	G(DpIdleFillChar) = 0x7e ;
	dp_modem_command_long ( PDM, HDLC_FLAG, 0x01,
							(byte) (SYNC_DATA_MODE & 0xff), 0);
}

/****************************************************************
Routine : dp_sync_mode_mark
*****************************************************************/
void dp_sync_mode_mark ( void )
{
	G(DpIdleFillChar) = 0xff ;
	dp_sync_mode () ;
}
#endif // !CS_MODEM

/****************************************************************
Routine : dp_async_8bit_mode
Description : 
	used by io task in v.42, switch to async 8 bit data mode.
*****************************************************************/
void dp_async_8bit_mode ( void )
{
	G(DpIdleFillChar) = 0xff ;
	dp_modem_command_long ( PDM, ASYNC_MARK, 0x01, 0x87, 0 ) ;
}

/****************************************************************
Routine : dp_hdlc_mode_no_crc
Description : workaround to get last 2 HDLC bytes
			 (requested by sync access mode)
*****************************************************************/
void dp_hdlc_mode_no_crc ( void )
{
	/* 
	 * To comply with V.ib spec., the receiver needs to obtain
	 *      last 2-bytes of HDLC frame.  With this patch, the
	 *      last 2 HDLC bytes follow the current EOF HDLC byte
	 */
	G(DpIdleFillChar) = 0x7e ;
	dp_modem_command_long ( PDM, HDLC_FLAG, 0x01,
							(byte)(HDLC_CRC_DISABLED & 0xff), 0);
	x_debug_msg ( "dp - hdlc no crc" ) ;
}

#if !defined(CS_4)
/****************************************************************
Routine : dp_dsp_version
Description : 
	used by at task in atcmd.c to display the dsp version
*****************************************************************/
word dp_dsp_version ( void )
{
	G(dp_byte_f) = 0 ;
	dp_modem_command ( REPORT_VERSION, 0, 0 ) ;
	G(dp_cmd_timer) = x_current_time () ;
	/* wait for interrupt from dsp - response code = 0x05 */
	while ( ( G(dp_byte_f) != 0x05 ) &&
			( x_elapsed_time (G(dp_cmd_timer)) < MS100 ) )

		DP_CHKDSP() ;

	if ( G(dp_byte_f) == 0x05 )
		return ( (word)((word)(G(dp_byte_e)<<8)|G(dp_byte_d)) ) ;
	else
	{
		x_debug_msg("dp_dsp_version() fails");
		return 0;
	}
}

/****************************************************************
Routine : dp_dsp_regread 
Description : Read from dsp side bamil registers
*****************************************************************/
byte dp_dsp_regread ( byte loc )
{
	// clear core read/write int bank bits
	DP_CLR_CORE_INTS( CWBANK|CRBANK ) ;

	dp_regwrite ( 0x36, loc ) ;
	dp_regwrite ( 0x37, 0x06 ) ;
	G(dp_cmd_timer) = x_current_time () ;

	/* wait for interrupt from dsp - response code = 0x02 */
	G(dp_byte_f) = 0 ;
	while ( ( G(dp_byte_f) == 0 ) &&
			( x_elapsed_time (G(dp_cmd_timer)) <= MS200 ) )
	{
		DP_MQX_CHKTIME( G(dp_cmd_timer) );
		DP_CHKDSP() ;
	}

#if !defined(MODEM_Z80)
    if ( x_elapsed_time (G(dp_cmd_timer)) > MS200 )
	{
		x_debug_msg("DP - Timed out in dp_dsp_regread()") ;
		DP_DELETE_TASK();
	}
#endif

	if ( G(dp_byte_f) != 0x02 )	// if command failed
	{
		x_debug_msg ( "DP - dp_dsp_regread() failure");
		DP_CLR_CORE_INTS( 0xff ) ;
		G(dp_byte_e) = 0 ;
	}

	return G(dp_byte_e);
}

/****************************************************************
Routine : dp_startup_prime_pump()
Description : 'prime the pump' for the startup command
		to the DSP.  These operations are done so that
		the CAMIL is in a state where the DSP will interrupt
		the controller properly on data.
*****************************************************************/
void dp_startup_prime_pump( void )
{
	byte regB5;

	regB5 = dp_dsp_regread( 0xb5 ) ;
	if ( (regB5 & BIT0) == 0 )
	{
		dp_regread( 0xb0 ) ; // set host read triger bit
		x_debug_msg("dp - host read b0") ;
	}
	if ( (regB5 & BIT4) == 0 )
	{
		//---------------------------------------
		// disable New Core Read 0 Trigger Byte
		//---------------------------------------
		dp_regwrite( 0xb6, 0xef ) ;

		// backdoor read of dsp register
		dp_dsp_regread ( 0xb0 ) ;

		// data length of zero to clear interrupt
		x_debug_msg ("dp - host write b0") ;
		dp_regwrite ( 0xb0, 0 ) ;
	}

	//---------------------------------------
	// enable New Core Read Trigger Byte One
	//---------------------------------------
	dp_regwrite( 0xb7, 0xff );
	dp_regwrite( 0xb6, 0xee ) ;

	//-------------------------------------
	// Enable Trigger Byte Int Summary Bit
	//-------------------------------------
#if defined(THUNDER)
# if !defined(USB_POLLED_MODE)
	if ( z80_modem_type == USB_INTERFACE )
	{
		G(dp_bamil_rd7) = 0xb3 ;	// enable Atlas Interrupt
	}
	else
	{
		G(dp_bamil_rd7) = 0xf3 ;
	}
# else
	G(dp_bamil_rd7) = 0xf3 ;
# endif
#elif defined(USB_MODEM) && !defined(USB_POLLED_MODE)
	G(dp_bamil_rd7) = 0xb3 ;
#else
	G(dp_bamil_rd7) = 0xf3 ;
#endif	// !THUNDER

	DP_SET_CORE_INTS( G(dp_bamil_rd7) );

	G(dp_dsp_data_in_progress) = FALSE ;
}

/****************************************************************
Routine : dp_dsp_checksum
Description : 
	used by at task in atcmd.c to display the dsp checksum
*****************************************************************/
word dp_dsp_checksum ( void ) 
{
	if (G(x_modem_state) == MS_ON_DIAL)
		return dp_read_dsp_ram(0x49);
	else
	{
		G(dp_byte_f) = 0 ;
		dp_modem_command(CHECK_DSP, 0, 0);
		G(dp_cmd_timer) = x_current_time () ;
		/* wait for interrupt from dsp - response code = 0x03 */
		while ( ( G(dp_byte_f) != 0x03 ) &&
				( x_elapsed_time (G(dp_cmd_timer)) < MS200 ) )
		{
			DP_CHKDSP();
		}

		if ( G(dp_byte_f) == 0x03 )
		{
			return dp_read_dsp_ram(0x49);
		}
		else
		{
			x_debug_msg("dp_dsp_checksum() fails");
			return 0;
		}
	}
}
#endif // !CS_4

/****************************************************************
Routine : dp_tx_fifo_empty - check if dce transmit queue is empty in dsp
*****************************************************************/
byte dp_tx_fifo_empty ( void )
{
	// for data mode - workaround for dsp data register problem - keep
	// data full in idle mode till this function is called -
	// see dpisr.c
	G(DpIdleFillChar) = 0 ;
	if ( ( G(dp_dsp_data_in_progress) == FALSE ) &&
		 ( dp_read_dsp_ram ( DP_PDM_STATUS ) & PDM_HOST_UNDERRUN ) )
		return TRUE;
	else
		return FALSE;
}


/****************************************************************
Routine : dp_set_mercury_gain 
Description : This function writes mercury gain values set in
		the gain parameters.
*****************************************************************/
void dp_set_mercury_gain(void)
{
	dp_change_mercury_gain(G(S).ModemOptions.LineGainAMSB,	// CIOCA MSB
						   G(S).ModemOptions.LineGainALSB,	// CIOCA LSB
						   G(S).ModemOptions.LineGainBMSB,	// CIOCB MSB
						   G(S).ModemOptions.LineGainBLSB);	// CIOCB LSB
}


#if defined(VENUS_1675)
#include "dp1675.h"
#endif

/****************************************************************
Routine : dp_change_mercury_gain
Description : This function writes mercury gain values passed as
		arguments to this function.
*****************************************************************/
void dp_change_mercury_gain ( byte amsb, byte alsb, byte bmsb, byte blsb )
{
#if !defined(CS_DIGITAL)
    if (!G(dp_daa_is_perseus))
    {
#if defined(VENUS_1675)
	    word csioa = (word) (((word) amsb << 8) | (word) alsb);
	    word csiob = (word) (((word) bmsb << 8) | (word) blsb);

	    // Change this if this file's constants are in other than the
	    // root bank.  This is a somewhat special case since this
	    // array isn't compressed so we can't use the standard macro
	    // if COMPRESS_TABLES is defined.
	    dp_download_dsp((byte *)&wV1675[0],
						(word)(sizeof(wV1675)/sizeof(word)));
	    dp_write_dsp_ram(VINIT_CIOCA_DATA, csioa);
	    dp_write_dsp_ram(VINIT_CIOCB_DATA, csiob);
	    dp_modem_command_long(GOTO_CMD, 0xc5, 0x80, 0, 0);

	    if (amsb || alsb || bmsb)
	    {
		    x_sleep(MS20);

		    // Without this statement here we sometimes seem to go
		    // on too quickly
		    if (dp_dsp_int_regread(8) & 0x0800)
		    {
			    x_debug_msg("dp_change_mercury_gain() - NOT in base map!");
		    }
	    }
#else
		dp_regwrite(0x32, blsb); // CIOCB LSB
		dp_modem_command_long(0x2f, 1, amsb, alsb, bmsb);

		if (amsb || alsb || bmsb)
		{
			dp_read_dsp_ram(DSP_STATUS_RAM);// dummy read to wait
		}
#endif // !VENUS_1675
    }
#endif // !CS_DIGITAL
}

#ifdef CS_ETC
/************************************************************************
*                                                                       *
*       Routine:        etc_save_land_setting                          *
*       Author:         EL                                              *
*                                                                       *
*       Creation Date:  12/16/96                                        *
*                                                                       *
*       Description:							*
*                                                                       *
*       Input: None                                                     *
*       Output: None                                                    *
*                                                                       *
*       Global Variables Changed:					*
*       Users:                                                          * 
*									*
*************************************************************************/
void etc_save_land_setting ( void )
{
	x_debug_msg("dp - ETC save land setting");
	G(TxLevel_buf) = G(S).ModemOptions.TxLevel ;
	G(etc_bNoAnsTimeOut) = G(S).ModemOptions.NoAnsTimeOut ;
	G(etc_bDataCallingTone) = G(S).ModemOptions.DataCallingTone ;
	G(etc_bETC) = G(S).ModemOptions.ETC ;
	G(etc_wV34Option) = G(S).ModemOptions.wV34Option ;
	G(etc_wRxSymbol) = G(S).ModemOptions.wV34RxSymbol ;
	G(etc_wMSEScale) = G(S).ModemOptions.wV34MSEScale ;
	G(etc_bNoCarrierDisc) = G(S).ModemOptions.NoCarrierDisc ;
	G(etc_bBusyPassCount) = G(S).ModemOptions.BusyPassCount ;
	G(etc_bV42) = G(S).ModemOptions.V42 ;
}

/************************************************************************
*                                                                       *
*       Routine:        etc_recall_land_setting                        *
*       Author:         EL                                              *
*                                                                       *
*       Creation Date:  12/16/96                                        *
*                                                                       *
*       Description:							*
*                                                                       *
*       Input: None                                                     *
*       Output: None                                                    *
*                                                                       *
*       Global Variables Changed:					*
*       Users:                                                          * 
*									*
*************************************************************************/
void etc_recall_land_setting ( void )
{
	x_debug_msg("dp - ETC recall land setting");
	G(cell_active) = 0;
	G(ETC_mode) = 0 ;
	G(S).ModemOptions.TxLevel = G(TxLevel_buf) ;
	G(S).ModemOptions.NoAnsTimeOut = G(etc_bNoAnsTimeOut) ;
	G(S).ModemOptions.DataCallingTone = G(etc_bDataCallingTone) ;
	G(S).ModemOptions.ETC = G(etc_bETC) ;
	G(S).ModemOptions.wV34Option = G(etc_wV34Option) ;
	G(S).ModemOptions.wV34RxSymbol = G(etc_wRxSymbol) ;
	G(S).ModemOptions.wV34MSEScale = G(etc_wMSEScale) ;
	G(S).ModemOptions.NoCarrierDisc = G(etc_bNoCarrierDisc) ;
	G(S).ModemOptions.BusyPassCount = G(etc_bBusyPassCount) ;
	G(S).ModemOptions.V42 = G(etc_bV42) ;
	dp_set_mercury_gain();
	dp_write_dsp_ram (0x0004, 0x0004) ; // land line pre-emphasis set 4 db
}


/****************************************************************/
//
//	enable_cell_filter
//
//	Description:  Routine for enabling Transmit de-emphasis on ETC call.
//				  Called at startup and after long retrains.
//
//
/****************************************************************/
void enable_cell_filter(void)
{
	if ( G(cell_active) == TRUE )
	{
		x_debug_msg("cs - ETC Enable Cell Filter") ;
		dp_write_dsp_ram(DEEMPH_COEFF_0, 0xFDBF);
		dp_write_dsp_ram(DEEMPH_COEFF_1, 0x0F69);
		dp_write_dsp_ram(DEEMPH_COEFF_2, 0x3E68);
		dp_write_dsp_ram(DEEMPH_COEFF_3, 0x0F69);
		dp_write_dsp_ram(DEEMPH_COEFF_4, 0xFDBF);
	}
}
#endif

#if defined(CS_MODEM)
/****************************************************************
Routine : dp_get_line_rate () - get line tx and rx rate.
*****************************************************************/
void dp_get_line_rate ( void )
{
	word t, s;

	MODEM_LINE_RATE old_line_rate, old_line_rate_tx;
	old_line_rate = G(x_line_rate);
	old_line_rate_tx = G(x_line_rate_tx);

	t = dp_read_dsp_ram(DP_SPEED_TX);
	s = dp_read_dsp_ram(DP_SPEED_RX);
   	
	G(x_line_rate_tx) = t + 4;
	G(x_line_rate) = s + 4;

	if (dp_56k_map() && ((byte)(dp_read_dsp_ram(0x1ff1))))
	{
		// Venus Central Site
		G(x_line_rate_tx) = dp_read_dsp_ram(DP_SPEED_TX) + MR_33600;
		if(G(vpcm_datamode))											   
			G(x_line_rate_tx) = dp_read_dsp_ram(DP_SPEED_TX) + MRV_28000 - 1; 
		G(x_line_rate) = dp_read_dsp_ram(DP_SPEED_RX) + 4;
	}

	if (cs_rr_rtn->remote_or_local == LOCAL)
	{
		if (G(x_line_rate) > old_line_rate)
			cs_rr_rtn->forward_back = FORWARD;
		else if(G(x_line_rate) == old_line_rate)
		{
			if (G(x_line_rate_tx) > old_line_rate_tx)
				cs_rr_rtn->forward_back = FORWARD;
			else
				cs_rr_rtn->forward_back = BACK;
		}
		else
			cs_rr_rtn->forward_back = BACK;
	}
	else if (cs_rr_rtn->remote_or_local == REMOTE)
	{
		if (G(x_line_rate_tx) > old_line_rate_tx)
			cs_rr_rtn->forward_back = FORWARD;
		else if(G(x_line_rate_tx) == old_line_rate_tx)
		{
			if (G(x_line_rate) > old_line_rate)
				cs_rr_rtn->forward_back = FORWARD;
			else
				cs_rr_rtn->forward_back = BACK;
		}
		else
			cs_rr_rtn->forward_back = BACK;
	}
}
#else // !CS_MODEM
/****************************************************************
Routine : dp_get_line_rate () - get line tx and rx rate.
*****************************************************************/
void dp_get_line_rate(void)
{
#if defined(COPERNICUS) || defined(SA_DIGITAL)
	G(x_line_rate_tx) = (MODEM_LINE_RATE)(dp_read_dsp_ram(DP_SPEED_TX) + 4);
	G(x_line_rate)    = (MODEM_LINE_RATE)(dp_read_dsp_ram(DP_SPEED_RX) + 4);
#else
	// 0x36 - Current Line Operating Speed (for V.34 and below)
	word t = dp_read_dsp_ram(DP_CUR_SPEED_LOC);
	G(x_line_rate_tx) = (MODEM_LINE_RATE)(((t >> 8) & 0x001f) + 2);
	G(x_line_rate) = (MODEM_LINE_RATE)((t & 0x001f) + 2);
#endif
}
#endif // !CS_MODEM

#if defined( CS_ENABLE_DEBUG_LOGGING ) || defined( MTS_DEBUG)
/****************************************************************/
//
//	Routine:	  cs_insert_error_tag()
//
//	Description: Inserts 0x1ff2 and fallback error indicators into the
//			dpsk or MISC2 buffer
//
//
/****************************************************************/
void cs_insert_error_tag ( word error_code, word counter )	  
{
  byte *ptr;
  word temp, x, y;
  word low_byte_error_code, local_debug_buf_size;

  x = 0;
  y = 0;
  temp = 1; //Indicate that we should print 0x1111 because error_code has changed

#ifdef MTS_DEBUG  //Unique to COPERNICUS debugging
	#define	DEBUG_PTR cop_debug_ptr
	#define DEBUG_BUF cop_debug_buf
	local_debug_buf_size = COP_DEBUG_BUF_SIZE;

	if (error_code == ( 0xaaaa )) //Remote Retrain
		x = 0xaa00 + counter;
	else if (error_code == ( 0xbbbb )) //Local Retrain
		x = 0xbb00 + counter;
	else if (error_code == ( 0xeeee )) //Local Ratechange
		x = 0xee00 + counter; 
	else if (error_code == ( 0xffff )) //Remote Ratechange
		x = 0xff00 + counter; 
	else
#else			//Unique to CS_MODEM debugging

	#ifdef CS_MODEM
		#define	DEBUG_PTR cs_dpsk_ptr
		#define DEBUG_BUF cs_dpsk_buf
	#else
		#define	DEBUG_PTR G(cs_dpsk_ptr)
		#define DEBUG_BUF G(cs_dpsk_buf)
	#endif

	local_debug_buf_size = G(cs_misc2_buf_size);

	if(G(cs_rmp_level2_debug_on)) 
		G(cs_misc2_buf_size) = DPSK_BUF_SIZE + DPSPTR_BUF_SIZE;
	else
		G(cs_misc2_buf_size) = DPSK_BUF_SIZE;

	if (error_code == ((word)MODEM_ID))
	{
		DEBUG_BUF[G(cs_misc2_buf_size)-1] = dp_read_dsp_ram (0x2017);
														
		ptr = VERSION_STR;

		// assume here that length of VERSION_PTR is always 6 !!!
		DEBUG_BUF[G(cs_misc2_buf_size)-3] = (word)(cs_atohex(ptr+1) | (cs_atohex(ptr) << 4));  //High Byte
		DEBUG_BUF[G(cs_misc2_buf_size)-2] = (word)(cs_atohex(ptr+5) | (cs_atohex(ptr+4) << 4));// Low Byte		
		DEBUG_BUF[G(cs_misc2_buf_size)-2] = ( DEBUG_BUF[G(cs_misc2_buf_size)-2] | ( ((word)((cs_atohex(ptr+3)) | (((cs_atohex(ptr+2)) << 4))) << 8 ) ) );// Middle Byte
		temp = 0;
	}
	else
#endif		 //Common to all central site debugging
	{
		//Display the lapm_state ccxx so don't update with 0x1ff2.
		if ( G(cs_rmp_level2_debug_on) )
		{
			temp = error_code & 0xFF00;
			low_byte_error_code = error_code & 0x00FF;
			if (temp == 0xcc00)
			{
				x = error_code;
				G(cs_p_error_code) = error_code;	 
			}
			else if ( ( temp >= 0x5000 ) && ( temp < 0x8000 ) ) 
			{
				if ( temp == 0x7200 )
				{
					x = error_code; // Could be 7200 , 7201 , or 7202
					y = G(p_rx_ch);
					G(cs_p_error_code) = error_code;
				}
				else
				{	
					if ( ( error_code != G(cs_p_error_code) ) &&	 
						 ( error_code != 0x6601 ) &&			//Stub out Receive RRs
						 ( error_code != 0x6605 )				//Stub out Receive RNRs
					 )
					{
						G(cs_p_error_code) = error_code;  
						x = error_code;
					}
					else
					{
						temp = 0;	    //Indicate that we should NOT print 0x1111 because error_code has not changed.
					}
				}
			}
			else 
			{
				x = dp_read_dsp_ram(0x1ff2);		// display in lower byte
				x = (x & 0x00FF);	    // display in upper byte
				x = (x | (error_code & 0xFF00));
			}
		}
		else
		{
			x = dp_read_dsp_ram(0x1ff2);		// display in lower byte
			x = (x & 0x00FF);	    // display in upper byte
			x = (x | (error_code & 0xFF00));
		}
	}

	if (x)
	{
		*++DEBUG_PTR = *DEBUG_PTR;		//Copy previous value
		*DEBUG_PTR = x;
		if (DEBUG_PTR == (DEBUG_BUF+(local_debug_buf_size-1)))	
			DEBUG_PTR = DEBUG_BUF-1;
		if ( (x & 0xff00) == 0x7200 )
		{
			if (y)	 // Only print the rx_ch if it's non-zero
			{		 
				*++DEBUG_PTR = y;
				if (DEBUG_PTR == (DEBUG_BUF+(local_debug_buf_size-1)))	
					DEBUG_PTR = DEBUG_BUF-1;
			}		 
		}
	}

	if(temp)
	{	
		*++DEBUG_PTR = 0x1111;  // Indicate last printout
		*DEBUG_PTR--;
	}
   
}
#endif  // CS_ENABLE_DEBUG_LOGGING || MTS_DEBUG

#if	defined(CS_DIGITAL) || defined(VENUS_AT_CS)
/****************************************************************
Routine : dp_download_monitor_nc_gain
          Near Echo cancellor workaround
          
Comments: Used for Cs (numeric), Copernicus, and 
          CS4 build
*****************************************************************/
void dp_download_monitor_nc_gain(word vectorf20)
{
#if !defined(VENUS_AT_CS)
	// download workaround that enables the near canceller
	// after phase 3.
	dp_write_dsp_array(0x1c00, &dp_v34dwk[0],
				   (byte)(sizeof(dp_v34dwk)/sizeof(word)));

	dp_write_dsp_ram(0x0ee4, 0x00a0);
	dp_write_dsp_ram(0x0ee5, 0xffa0);
	dp_write_dsp_ram(AP_DPRAM_BAUD, vectorf20);
	x_debug_msg("dp_download_monitor_nc_gain() DPRAM_BAUD=");
	sendHexWord(vectorf20);sendCrLf();
#endif // !VENUS_AT_CS
}
#endif // CS_DIGITAL || VENUS_AT_CS
