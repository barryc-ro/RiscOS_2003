/*name and version number:@(#)z80serut.c	1.39*/
/*date of get: 		  01/12/01 11:49:17*/
/*date of delta:	  01/11/01 13:14:31*/
/**************************************************************************
File :	z80serut.c
Description :
	Contains z80 utilities and main() for external modem

Procedures Contained :
	PnP_buildit
	PnP_identify
	serMain

Revision History :
	RWF			11/07/95	initial
	RWF			11/10/95	moved eeprom driver to here
	RWF			11/15/95	added z80_PnP_chksum()
	RWF			17/17/96	added page mode serial eeprom routines.
	RWF			02/23/98	moved serial specific stuff to this file
***************************************************************************/

#define Z80_DEBUG_THIS_FILE

#include	"llglob_d.h"

#if defined(EXT_MODEM) || defined(THUNDER)	// {
#include	"iouart_d.h"
#include	"ioglob_d.h"
#include	"atglob.h"
#include	"dpglob.h"
#include	"z80glob.h"
#if defined(TCP_IP)
# include "micronet.h"
#endif

#ifdef KORTEX
#include "AmAtCmd.h"
#define	AM_PNP_WAIT_TIME	1500	
extern word AM_G_PnP_timer;
extern byte am_kb_cnt;
extern void Am_task_load();
extern void Am_task ( MODEM_COMMAND, byte *, word ) ;
extern void AmDoOneTimeWhenDtrOnFinal();
extern void AMDebugPutC( unsigned char ucVal);
#endif	// KORTEX
#ifdef G729A
#include "dpctad.h"
#endif

#include	"allglobs.h"

//----------------------------------------------------------------
//	Externs for the Serial main() routine
//----------------------------------------------------------------
extern BAUD_RATE lst_s_62 ;
extern BOOL	z80_no_more_tx ;
extern BOOL	dtr_from_dte_on ;
extern BOOL	AUTOBAUDING ;
extern BOOL	in_xof_from_dte ;
extern BOOL	brk_to_dte_flg ;
extern word	brk_timer ;
extern word src_c_int ;
extern word	z80_max_dma ;				// size of DMA transfer.

extern void dp_task ( MODEM_COMMAND, byte *, word ) ;
extern void io_task ( MODEM_COMMAND, byte *, word ) ;
extern non_banked void z80_uart_cts_on( void ) ;
#if defined( ATHENA_LEDS )
word z80_athena_datatimer;
#endif

//----------------------------------------------------------------
//	Serial Debug print routine
//----------------------------------------------------------------
#if defined( Z80_DEBUG_PRINT )	// {

#define		FLASH_TIME		(1000)		// flash timer in ms

extern BOOL dmach0Flg, dmach1Flg ;
extern BOOL abon, aboff;
extern BOOL z80_flow_on_flag ;
extern word debug_rx_count ;

/****************************************************************
	Function : z80_dbug_print - External debug routine
*****************************************************************/
static
void z80_dbug_print ( void )
{
	word rx_cnt ;
	static word flash_timer ;			// timer for Break to DTE

	
#if defined( Z80_EASCI_RX_DMA )
	if ( dmach0Flg )
	{
		sendDumbChar('x');
		dmach0Flg = FALSE ;
	}
#endif
#if defined( Z80_EASCI_TX_DMA )
	if ( dmach1Flg )
	{
		sendDumbChar('y');
		dmach1Flg = FALSE ;
	}
#endif

	if ( abon )
	{
		if (!G(venusDebugToDTE))
			sendDumbChar('+');	// Print when not sending debug to DTE,
								// otherwise the screen is filled when
								// doing the constellation display.
		abon = FALSE ;
	}
	if ( aboff )
	{
		if (!G(venusDebugToDTE))
			sendDumbChar('-');
		aboff = FALSE ;
	}

	//------------------------------------------
	// flash CTS led if NOT online
	//------------------------------------------
	if ( z80_modem_state == WAITING_FOR_ONLINE_STATE )
	{
		if ( x_elapsed_time ( flash_timer ) > FLASH_TIME )
		{
			flash_timer = x_current_time () ;
			disable_interrupt () ;
				output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & BIT2 ?
							input8 ( DUMB_MCR ) & ~BIT2 :
							input8 ( DUMB_MCR ) | BIT2 ) ;
			enable_interrupt () ;
		}
	}

	//------------------------------------------
	// new high water mark reached in rx buffer
	//------------------------------------------
	if ( z80_flow_on_flag )
	{
		disable_interrupt () ;
			z80_flow_on_flag = FALSE ;
			rx_cnt = debug_rx_count ;
		enable_interrupt () ;
		x_debug_msg("Cnt="); sendHexWord(rx_cnt); sendCrLf();
	}
}
#endif	// } Z80_DEBUG_PRINT

#if defined( PNPSTRING )	// {
//==========================================================================
//			Time Parameters for Plug and Play
//==========================================================================
#define		MIN_PNP_TIME	(140)		// lower time limit (ms)
//#define		MAX_PNP_TIME	(260)		// upper time limit (ms)
// mah - 5/12/99 - this matches what works in the field,
// even though it doesn't really match the spec.
#define		MAX_PNP_TIME	(900)		// upper time limit (ms)

//==========================================================================
//					Externs for PnP functions
//==========================================================================
extern byte PnPstr [ 256 ] ;
extern word PnP_timer ;
extern PLUGNPLAY PnP_state;
extern word PnP_count ;
extern byte read_eeprom ( word loc ) ;
extern const byte str_convert[];

//================================================================
//		Plug and Play Functions.
//================================================================
// The following functions support the Windows 95 PnP feature
// for the serial modem.  The modem is always monitoring DTR
// and RTS for the following time critical protocol:
//
//	        |<- T1 ->|<- T2 ->|<- T3 ->|
//	        |        |        |        |
//	DTR -------------+        +--------------//
//	                 |        |
//	RTS ----+        +--------+        +-----//
//	        |                          |
//	        +--------------------------+
//
// Once the DCE (modem) sees this protocol, it responds by
// transmitting the stored PnP sequence, if one is available.
//================================================================

/****************************************************************
	Function : Plug & Play Protocol checker.
	If current state is same as input state and elapsed
	time since entering this state is within spec,
	(160 to 240 ms) then transition to next state,
	Otherwise return to initial state.
*****************************************************************/
void PnP_chkstate ( PLUGNPLAY state )
{
	word delta ;

	delta = x_elapsed_time ( PnP_timer ) ;
	PnP_timer = x_current_time () ;
	if ( (PnP_state == state)
		&& (delta > MIN_PNP_TIME) && (delta < MAX_PNP_TIME) )
	{
		PnP_state++;
	}
	else
	{
		PnP_state = T0 ;
	}
}

/****************************************************************
	Function : Plug & Play Protocol Initializer.
	Sets current state to input state and starts timer.
*****************************************************************/
void PnP_setstate ( PLUGNPLAY state )
{
	PnP_state = state ;
	PnP_timer = x_current_time () ;
}

/****************************************************************
	Function : Plug & Play chksum calculation.
*****************************************************************/
byte z80_PnP_chksum ( void )
{
	word loc ;
	byte data ;

	data = 0 ;
	for ( loc=PNP_START_LOC; loc<PNP_CHKSUM; loc++ )
	{
		data += read_eeprom ( loc ) ;
	}
	return data ;
}

/****************************************************************
	Function : Plug & Play builder.
	Builds enumeration sequence from either serial eeprom
	(or default pnp string if eeprom not loaded).
*****************************************************************/
void PnP_buildit ( BOOL ascii )
{
	byte bitmap, chksum, data, extend_flag, i, len ;
	byte dest[80], *bp, *bp1 ;
	word loc, major_num, minor_num ;

	x_debug_msg("PnP_buildit");

	// read current contents of PnP storage
	bitmap = read_eeprom ( PNP_BITMAP ) ;

	///////////////////////////////////////////
	// EISA Mfr ID & Product ID are required
	// fields.  Also check PNP_CHKSUM
	///////////////////////////////////////////
	if (	!(bitmap & PNP_EISA_BIT)
		||	!(bitmap & PNP_PROD_BIT)
		||	(z80_PnP_chksum() != read_eeprom ( PNP_CHKSUM )) )
	{
		///////////////////////////////////////////
		// if not there or corrupted then build
		// default enumeration sequence.
		///////////////////////////////////////////
#ifdef KORTEX
		Am_Get_PnP(PnPstr);
#else
		str_copy( PnPstr, (const byte *)PNPDEFAULT ) ;
#endif
		goto PnPchksum ;
	}

	/////////////////////////////////
	// serial eeprom is good.
	// start building enum seq.
	/////////////////////////////////
	bp = PnPstr ;
	extend_flag = FALSE ;

	*bp++ = S.ModemOptions.CRChar ;
	*bp++ = S.ModemOptions.LFChar ;

	// begin PnP
	*bp++ = '(' ;

	// PnP Revision Code
	str_copy( dest, PNPSTRING ) ;
	bp1 = dest ;
	if ( ascii )
	{
		// PnP Revision Code in human readable form
		for ( i=0; i<5 && *bp1 != 0; i++, bp++ )
		{
			*bp = *bp1++ ;
		}
	}
	else
	{
		// PnP Revision Code (2 6bit chars)
		bp1 += at_atoi ( bp1, &major_num, DECIMAL ) ;
		if ( *bp1++ != '.' )
		{
#ifdef KORTEX
			Am_Get_PnP(PnPstr);
#else
			str_copy( PnPstr, (const byte *)PNPDEFAULT ) ;
#endif
			goto PnPchksum ;
		}

		if ( at_atoi ( bp1, &minor_num, DECIMAL ) != 2 )
		{
#ifdef KORTEX
			Am_Get_PnP(PnPstr);
#else
			str_copy( PnPstr, (const byte *)PNPDEFAULT ) ;
#endif
			goto PnPchksum ;
		}

		major_num *= 100 ;
		major_num += minor_num ;
		*bp = (major_num >> 6) & 0x3f ;
		*(bp+1) = major_num & 0x3f ;
		if (	(*bp == 0x09) || (*(bp+1) == 0x09)
			||	(*bp == 0x29) || (*(bp+1) == 0x29) )
		{
#ifdef KORTEX
			Am_Get_PnP(PnPstr);
#else
			str_copy( PnPstr, (const byte *)PNPDEFAULT ) ;
#endif
			goto PnPchksum ;
		}
		bp += 2 ;
	}

	// EISA Mfr ID (3 chars)
	*bp++ = read_eeprom ( PNP_EISA_ID ) ;
	*bp++ = read_eeprom ( PNP_EISA_ID+1 ) ;
	*bp++ = read_eeprom ( PNP_EISA_ID+2 ) ;

	// Product ID
	data = read_eeprom ( PNP_PROD_ID ) ;
	*bp++ = str_convert[ (byte)((data>>4) & 0xf) ];
	*bp++ = str_convert[ (byte)(data & 0xf) ];
	data = read_eeprom ( PNP_PROD_ID+1 ) ;
	*bp++ = str_convert[ (byte)((data>>4) & 0xf) ];
	*bp++ = str_convert[ (byte)(data & 0xf) ];

	// Serial Number
	*bp++ = '\\' ;
	if ( bitmap & PNP_SERNO_BIT )
	{
		loc = PNP_SERIAL_NO ;
		for ( i=0; i<4; i++ )
		{
			data  = read_eeprom ( loc++ ) ;
			*bp++ = str_convert[ (byte)((data>>4) & 0xf) ];
			*bp++ = str_convert[ (byte)(data & 0xf) ];
		}
	}

	// Class Name
	*bp++ = '\\' ;
	*bp++ = 'M' ;
	*bp++ = 'O' ;
	*bp++ = 'D' ;
	*bp++ = 'E' ;
	*bp++ = 'M' ;

	// Conpatible Driver IDs
	if ( bitmap & PNP_DEVID_BIT )
	{
		*bp++ = '\\' ;
		loc = PNP_DEVICE_ID ;
		for ( i=0; i<40; i++, bp++ )
		{
			*bp = read_eeprom ( loc++ ) ;
			if ( *bp == 0 )
			{
				break ;
			}
		}
	}
	else
	{
		extend_flag = TRUE ;
	}

	// User Name
	if ( bitmap & PNP_USER_BIT )
	{
		if ( extend_flag == TRUE )
		{
			*bp++ = '\\' ;
		}
		*bp++ = '\\' ;
		loc = PNP_USER_NAME ;
		for ( i=0; i<40; i++, bp++ )
		{
			*bp = read_eeprom ( loc++ ) ;
			if ( *bp == 0 )
			{
				break ;
			}
		}
		*bp++ = ';' ;
	}

	// add null char at end for
	//checksum calculations below
	*bp = 0 ;

PnPchksum:
	/////////////////////////////////////////////////
	// Checksum (2 hex chars)
	// from start PnP thru end PnP self exclusive
	/////////////////////////////////////////////////
	chksum = ')' ;
	bp = PnPstr + 2 ; // don't include initial CR LF.
	while ( *bp )
	{
		chksum += *bp++;
	}
	*bp++ = str_convert[ (byte)((chksum>>4) & 0xf) ] ;
	*bp++ = str_convert[ (byte)(chksum & 0xf) ];

	// end PnP
	*bp++ = ')' ;

	*bp++ = S.ModemOptions.CRChar ;
	*bp++ = S.ModemOptions.LFChar ;
	*bp = 0 ;

	if ( !ascii )
	{
		// add 2nd stop bit
		bp = PnPstr ;
		while ( *bp )
		{
			*bp++ |= 0x80 ;
		}
	}

	return ;
}

/****************************************************************
	Function : Plug & Play Identifier.
	Sends enumeration sequence to the DTE.
*****************************************************************/
void PnP_identify ( BOOL ascii )
{
	BAUD_RATE brate ;
	byte *ptr ;
	extern BAUD_RATE s_62 ;

	///////////////////////////////////////////////////////
	// build the enumeration sequence to send to the DTE
	// two versions are supported; a machine readable one
	// and a human readable one.  In the machine case, the
	// link is converted to 1200 baud 7 bit two stop bit.
	//
	// Also in the machine case, the sequence has already
	// been built and stored in PnPstr.
	///////////////////////////////////////////////////////
	if ( ascii )
	{
		PnP_buildit ( TRUE ) ;
	}
	else
	{
		///////////////////////////////////
		//	Machine Enumeration sequence!!
		///////////////////////////////////
		//	format of ID is a ten bit frame:
		//		one start bit;
		//		8 bit frame with MSB=1;
		//		one stop bit.
		//	delivered at 1200 BPS.
		///////////////////////////////////
		disable_interrupt () ;
			brate = s_62 ;
			s_62 = BR1200 ;
			z80_stop_autobaud () ;
			s_62 = brate ;
		enable_interrupt () ;

		// Add parity
		at_parity = 0 ;	// no parity
	}

	ptr = PnPstr ;
	x_send_mail ( AT_IO_DATA, IO_TASK, ptr, x_strlen ( ptr ) ) ;

	// Rebuild the machine readable form.
	if ( ascii )
	{
		PnP_buildit ( FALSE ) ;
	}
}
#endif	// } PNPSTRING

/****************************************************************
	Function : z80_set_ser_wstates
	Set System Wait States.
*****************************************************************/
void z80_set_ser_wstates ( BOOL HighSpeed )
{
	if ( !HighSpeed )
	{
		//--------------------------------------------------------------
		//	Command Mode:
		//--------------------------------------------------------------
		// - SET TO:
		//		 3 ROM wait states
		//		 2 RAM wait states
		//		 3 I/O wait states
		//
		// NOTE: For Autobaud these values cannot be changed
		// without taking a close look at nmiir().  There
		// is precise timing in the code there (down to the
		// number of wait states).
		//--------------------------------------------------------------
		output8 ( WSG, 0x9a ) ;
		output8 ( DCR, 0x2c ) ; // dma ch0=edge sense; dma ch1=edge sense

			// For venus2 silicon, switch back to crystal oscillator
			// for acurate autobauding.
		z80_stop_dpll();
	}
	else
	{
		//--------------------------------------------------------------
		//	On Line Mode:
		//--------------------------------------------------------------
		//			For VENUS
		//--------------------------------------------------------------
		// - SET TO:
		//		 3/2 (if 55nsec ROM) wait states
		//		 0 RAM wait states
		//		 3 I/O wait states
		//--------------------------------------------------------------
		//
		// Notes:	1)	WSG register must be programmed before DCR.
		//			2)	FOR RAM, DCR will override WSG setting if a
		//				higher value is used.
		//--------------------------------------------------------------
#if defined(WAIT_STATE_TWO) || defined(EMULATION)
		// Same as command mode
		return ;
#else
#if !defined(FAST_ROM)
			// Wait State Generator: ROM=3; RAM=Disabled
		output8 ( WSG, 0x0a ) ;
#else
			// Wait State Generator: ROM=2; RAM=Disabled
		output8 ( WSG, 0x09 ) ;
#endif
			// For 80182/89 - I/O Wait State Generator: RAM=0; I/O=3
			// 				  dma ch0=edge sense; dma ch1=edge sense
		output8 ( DCR, 0x2c ) ;

			// For venus2 silicon, switch to dpll for
			// faster clock rate.
		z80_start_dpll();
#endif
	}
}

/****************************************************************
	Function : init_z80_asci
*****************************************************************/
void init_z80_asci ( void )
{
			// reset Rx channel - CTS OFF
	output8 ( ASCI_CTLA0_REG, ASCI_RTS ) ;
			// clear the BRG...
	output8 ( ASCI_TCLO_REG, 0 ) ;
	output8 ( ASCI_TCHI_REG, 0 ) ;
			// select clock source and speed select
			// (not necessary for VENUS)
	output8 ( ASCI_CTLB0_REG, 0 ) ;
			// enable break detection & internal clock;
			// disable auto tx/rx enable (tx enable will
			// be enabled later);
			// select divide by 1 mode for VENUS
	output8 ( ASCI_XCR0_REG, BRK_ENABLE | BRG0_MODE
				 | CTS0_DISABLE | DCD0_DISABLE | X1_BIT_CLK ) ;

			// enable tx & rx to DTE.
			//  (As in the ESCC, our RTS is wired to the DTE CTS
			//  which we want OFF here)
			// clear any errors in rx (frame or overrun)
			// setup mode = 8 data + 1 stop (no parity)
	output8 ( ASCI_CTLA0_REG, TX_ENABLE | RX_ENABLE | MOD_2 | ASCI_RTS ) ;

			// enable additional interrupt sources for VENUS
			// and clear autobaud enable.
	output8 ( A0INTIN, A0INTIN_VAL ) ;
	output8 ( A0NEWCTL , 0 ) ;

			// enable rx interrupts (tx handled by main())
	output8 ( ASCI_STAT0_REG , RX_INT_ENABLE ) ;

#if defined( Z80_EASCI_TX_DMA )
			//-----------------------------------------------------
			// initialize DMA channel 1 for EASCI TX
			// the following registers can be initialized once
			//-----------------------------------------------------
	output8( MAR1B, 0xf ) ;	// high byte of DMA source register
			// Destination register
	output8( IAR1B, 1 ) ;	// selects EASCI TX as destination
	output8( IAR1H, 0 ) ;
	output8( IAR1L, ASCI_TX0_REG ) ;
			// upper byte of count - as long as we keep the packet
			// size to the host below 256 bytes this value should
			// not need reloading.
	output8( BCR1H, 0 ) ;

			//-----------------------------------------------------
			// initialize DMA channel 0 for EASCI TX
			// (for use in SW Flow control)
			//-----------------------------------------------------
			// Upper byte of source register
	output8( SAR0B, (byte)0x00 ) ;
			// Destination register
	output8( DAR0B, 1 ) ;	// selects EASCI TX as destination
	output8( DAR0H, 0 ) ;
	output8( DAR0L, ASCI_TX0_REG ) ;
			// upper byte of count
	output8( BCR0H, 0 ) ;
			// set up dmode register
			//	src = memory++
			//	dst = I/O fixed
	output8 ( DMODE, 0x30 ) ;
	#if 0	// Done in z80_set_ser_wstates()
			//	set ch0 & ch1 dma to edge/lvl sense
			//	dma ch0=edge sense; dma ch1=edge sense
	output8 ( DCR, input8( DCR ) | 0x0c ) ;
	#endif
#endif

	//------------------------------------------
	// for Venus2 load the Exact Count Registers
	//------------------------------------------
	if ( input8( REVR ) )
	{
		//---------------------------------------------
		// Note: there is a bug in Venus2 that prevents
		// the first table location from being loaded
		// into the BRG counter; So we autobaud only
		// with last three table entries
		// (equivalent to the NMI algorithm).
		//---------------------------------------------
		output8( XACTCNT0L, 1 );
		output8( XACTCNT0H, 0 );

		// counter value for 230.4
		output8( XACTCNT1L, BR230400_2 & 0xff );
		output8( XACTCNT1H, BR230400_2 >> 8 );

		// counter value for 115.2
		output8( XACTCNT2L, BR115200_2 & 0xff );
		output8( XACTCNT2H, BR115200_2 >> 8 );

		// counter value for 57.6
		output8( XACTCNT3L, BR57600_2 & 0xff );
		output8( XACTCNT3H, BR57600_2 >> 8 );
	}
}

extern void x_output_init(void);

/****************************************************************
	Function : init_z80_hardware for Serial Modem
*****************************************************************/
static
void init_z80_hardware ( word prt0_time )
{
		//--------------------------------------------------------------
		// Set system Wait States for command mode.
		//--------------------------------------------------------------
	z80_set_ser_wstates(FALSE);

		// Set PRT0 time contant
	prog_timer(prt0_time);

		// initialize the EASCI - only channel 0
		// is used for communications with the DTE
		// (VENUS only has channel 0).
	init_z80_asci();

		// initialize BIO parallel port registers,
	x_output_init();

		// DSR to DTE was just set!
		// So initialize PnP control variables:
#if defined( PNPSTRING )
	PnP_setstate(T0);
#endif

		// Enable DSP - allow time for DSP to initialize the
		// CAMILZ register set then we will set them the way
		// we want them below.
	dp_regwrite(0xde, 0x50);	// Enable DSP

		// disable all interrupts on camil
	dp_regwrite( 0xd7, 0xff ) ;
	dp_regwrite( 0xd8, 0xff ) ;

		// Now set up CAMILZ registers.
	dp_regwrite(0xca, 0x00);	// disable host pc access to MIMIC (MCAD)
								// and DIA (for DSP access)
	dp_regwrite(0xda, 0x16);	// call progress through SIO and
								// IOCS2 for Serial Dumb Terminal
	dp_regwrite(0xc0, 02);		// enable SERIAL Scenario
	dp_regwrite(0xdf, 1);		// enable pin master

	// enable all interrupts
	enable_interrupt();

	// Start the DPLL Zinger clock for VENUS2
	// We will switch to it later in
	// z80_set_ser_wstates() when we go online
	z80_init_venus2();
}

/****************************************************************
	Function : easci BAUD RATE 
*****************************************************************/
void easci_baud_rate ( void )
{
	extern BAUD_RATE s_62 ;

	//------------------------------------------------------
	// set up the baud rate registers based on the dte rate
	//------------------------------------------------------
	switch ( s_62 )
	{
		case BR150 :
		case BR300 :
			S.ModemOptions.DteRate = DTE_300 ;
			break ;
		case BR600 :
			S.ModemOptions.DteRate = DTE_600 ;
			break ;
		case BR1200 :
			S.ModemOptions.DteRate = DTE_1200 ;
			break ;
		case BR2400 :
			S.ModemOptions.DteRate = DTE_2400 ;
			break ;
		case BR4800 :
			S.ModemOptions.DteRate = DTE_4800 ;
			break ;
		case BR9600 :
			S.ModemOptions.DteRate = DTE_9600 ;
			break ;
		case BR14400 :
			S.ModemOptions.DteRate = DTE_14400 ;
			break ;
		case BR19200 :
		default :
			S.ModemOptions.DteRate = DTE_19200 ;
			break ;
		case BR38400 :
			S.ModemOptions.DteRate = DTE_38400 ;
			break ;
		case BR57600 :
			S.ModemOptions.DteRate = DTE_57600 ;
			break ;
		case BR115200 :
			S.ModemOptions.DteRate = DTE_115200 ;
			break ;
		case BR230400 :
			S.ModemOptions.DteRate = DTE_230400 ;
			break ;
	}

	S.ModemOptions.OldLineRate = (byte) s_62;
	x_debug_msg( "New DTErate=" ) ;
	sendHexByte( S.ModemOptions.DteRate ) ; sendCrLf();
}

/****************************************************************
	Function : z80_chk_isr_chg
	Handles things signalled by interrupt. Since we shouldn't call
	apps routines from an ISR we set flags and check them here.
*****************************************************************/
void z80_chk_isr_chg ( void )
{
	extern BOOL brk_from_dte_on, brk_from_dte_off, setXflag;

	//==============================================
	//	Have there been any changes in DTR?
	//==============================================
	//---------------------------------------------
	// For VENUS, DTR changes from host
	// are notified by interrupt and PnP state
	// transitions are handled in the ISR.
	//---------------------------------------------
	if ( !( input8 ( ASCI_STAT0_REG ) & DCD0) )
	{
		// DTR is SET by the DTE !!
		if ( !dtr_from_dte_on )
		{
			dtr_from_dte_on = TRUE ;
			UART_dtr_on () ;
		}
	}
	else
	{
		// DTR is NOT SET !!
		if ( dtr_from_dte_on )
		{
			dtr_from_dte_on = FALSE ;
			UART_dtr_off () ;
		}
	}
	//==============================================
	//	End changes to DTR?
	//==============================================

	//==============================================
	//	Have there been any changes in BRK from DTE?
	//==============================================
	if ( brk_from_dte_on )
	{
		// Yes - DTE has sent a break
		UART_start_break () ;
		brk_from_dte_on = FALSE ;
		// brk_from_dte_off variable used in z80189 mode
		// as "looking for end of break" flag.
		brk_from_dte_off = TRUE ;
	}
	if ( brk_from_dte_off == TRUE )
	{
		// look to see if the Tx from DTE has returned
		// to a high state.
		if ( CAMILZ_REGREAD( 0xBB ) & BIT6 )
		{
			// DTE has cleared the break condition.
			UART_stop_break () ;
			brk_from_dte_off = FALSE ;
			output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & ~BIT3 ) ;
		}
	}

	//================================================
	//	Have there been any changes in SW FC from DTE?
	//================================================
	if ( (z80_modem_state == SW_ON_LINE_STATE) && setXflag )
	{
		if ( in_xof_from_dte )
		{
			// Yes - DTE has sent an XOFF
			UART_xoff_off () ;
		}
		else
		{
			// Yes - DTE has sent an XON
			UART_xoff_on () ;
		}
		setXflag = FALSE ;
	}
}

#if defined(Z80_READ_UART_DEBUG)
void z80_parsechar ( byte ch )
{
	if ( !dumbPortPresent ) return;

	#if defined(ROM_FLASH)
	/* if ^D exit */
	if ( ch == 0x04 )
	{
		x_debug_msg("\r\nback to RRFL Dispatcher");
		z80_jump_abs( *((word *)0x52), 0x00 ) ;
		sendCrLf();
	}
	else
	#endif	// ROM_FLASH

	if ( ch == 'd' )
	{
		x_debug_msg("\r\n\r\n From Host :");
		x_debug_msg("     DTE wp=");  sendHexWord((word)I(io_dte_rx_wptr));
		x_debug_msg("; DTE rp=");    sendHexWord((word)I(io_dte_rx_rptr));

		x_debug_msg("\r\n To Host :");
		x_debug_msg("     DTE wp=");  sendHexWord((word)I(io_dte_tx_wptr));
		x_debug_msg("; DTE rp=");    sendHexWord((word)I(io_dte_tx_rptr));
		sendCrLf();
	}
	else

	#if defined(TCP_IP)
	#if 1
	if ( ch == 't' || ch == 'T' || ch == 'x' || ch == 'X' )
	{
		in_tcp_ip_mode  = in_tcp_ip_mode ? FALSE : TRUE ;
		x_debug_msg("\r\nTCP/IP Mode is ");
		if ( in_tcp_ip_mode )
		{
			x_debug_msg("ON");
		}
		else
		{
			x_debug_msg("OFF");
		}
		sendCrLf();
	}
	else
	#endif // 1
	if ( ch == 'D' || ch == 'd' )
	{
		x_debug_msg("\r\n\r\n From Host :");
		x_debug_msg("HOST wp=");      sendHexWord((word)IO_DTE_RX_WPTR);
		x_debug_msg("; HOST rp=");    sendHexWord((word)IO_DTE_RX_RPTR);
		x_debug_msg(";    DTE wp=");  sendHexWord((word)I(io_dte_rx_wptr));
		x_debug_msg("; DTE rp=");    sendHexWord((word)I(io_dte_rx_rptr));

		x_debug_msg("\r\n To Host :");
		x_debug_msg("HOST wp=");      sendHexWord((word)IO_DTE_TX_WPTR);
		x_debug_msg("; HOST rp=");    sendHexWord((word)IO_DTE_TX_RPTR);
		x_debug_msg(";    DTE wp=");  sendHexWord((word)I(io_dte_tx_wptr));
		x_debug_msg("; DTE rp=");    sendHexWord((word)I(io_dte_tx_rptr));
	}
	else
	#endif	// TCP_IP
	#if defined(FRM_HOST_DMA_TEST)
	if ( ch == 'b' || ch == 'B' )
	{
		dma_test = 0x55;
	}
	else
	if ( ch == 'D' || ch == 'd' )
	{
		x_debug_msg("cnt="); sendHexWord(uart_rx_count);
		x_debug_msg(" wp="); sendHexWord((word)IO_DTE_RX_WPTR);
		x_debug_msg(" rp="); sendHexWord((word)IO_DTE_RX_RPTR);
		x_debug_msg(" dmad=");
		sendHexWord((word)(input8(DAR0L)|(input8(DAR0H)<<8))) ;
		x_debug_msg(" dmac=");
		sendHexWord((word)(input8(BCR0L)|(input8(BCR0H)<<8))) ;
		x_debug_msg(" dstat="); sendHexByte(input8(DSTAT)) ;
		x_debug_msg(" dmode="); sendHexByte(input8(DMODE)) ;
		x_debug_msg(" dcr="); sendHexByte(input8(DCR)) ;
		x_debug_msg(" as_st="); sendHexByte(input8(ASCI_STAT0_REG)) ;
		sendCrLf();
	}
	else
	if ( ch == '+' )
	{
		// do a full (cold) start of DMA
		z80_dte_rx_wptr = IO_DTE_RX_WPTR ;
		z80_rx_dma = FALSE;
		z80_start_rx_dma();
		G(io_at_esc_detect) = TRUE;
		x_send_mail(AT_OK, AT_TASK, 0, 0 );
	}
	else
	#endif // FRM_HOST_DMA_TEST
	{
		while (!(input8(DUMB_LSR) & 0x20))
			;
		output8(DUMB_DATA, ch);
	}
}
#endif	// Z80_READ_UART_DEBUG

/****************************************************************
	Function : Main routine for the Serial modem

	Called once from main() in z80ser.c.  Moved here to save
	code space in RCODE.
*****************************************************************/
void serMain ( void )
{
	word isrTimer;

	z80_modem_state = INITIAL_STATE;
	// init non zero variables
	s_62 = BR19200 ;			// this sreg value is the default baudrate		

	z80_no_more_tx = TRUE ; 	// SCC - dte transmit reset pending bit set
	uart_flow_control = FC_OFF ;

	#if defined( Z80_EASCI_TX_DMA )
	z80_max_dma = Z80_MAX_HW_DMA ;
	#endif
	#if defined(TX_DMA_DEBUG) || defined(RX_DMA_DEBUG)
	z80_dma_debug = TRUE ; // For DEBUG
	#endif
	#if defined(TCP_IP)
	mn_service_mode = NO_OPEN;
	mn_service_type = NO_SERVICE;
	in_tcp_ip_mode = FALSE ;
	mn_tcp_test = TCP_NO_TEST ;
	#endif
	#ifdef G729A
	start_record = FALSE;
	start_play = FALSE;
	#endif
	#ifdef KORTEX
	Am_task_load();
	#endif

	enableDumbPort();

	// init Z80 peripheral's
	init_z80_hardware (PRT0_TIME) ;

	#if !defined( ROM_FLASH ) && defined( ROM )
	x_debug_msg( "Rom Checksum" ) ;
	if ( z80_checksum ( FALSE ) == FALSE )	// rom checksum test
	{
		x_debug_msg( "Rom Failure" ) ;
		#if 0
		str_copy( PnPstr, (const byte *)"Rom Failure" ) ;
		fatal_error ( "Rom Failure" ) ;
		#endif
	}
	#endif

	// init modem task - variables
	x_debug_msg("UART_init");
	if (FAILED == UART_init())
	{
		x_debug_msg("Data Pump Failure");
		str_copy( PnPstr, (const byte *)"Data Pump Failure" ) ;
		fatal_error ( PnPstr ) ;
		// never returns
	}

	if (S.ModemOptions.OldLineRate)
		s_62 = S.ModemOptions.OldLineRate;

	// look at DTR and set variables
	if ( !( input8 ( ASCI_STAT0_REG ) & DCD0) )
	{
		dtr_from_dte_on = TRUE;
		x_debug_msg("Init DTR ON");
		UART_dtr_on();
	}
	else
	{
		dtr_from_dte_on = FALSE;
		x_debug_msg("Init DTR OFF");
		UART_dtr_off();
	}

	z80_uart_cts_on();

	while ( TRUE )           		      // forever loop
	{
		//==============================================
		// call the modem background tasks
		// to execute periodic routines
		//==============================================
		dp_task ( MC_PERIODIC, NULL, 0 ) ;

		io_task ( MC_PERIODIC, NULL, 0 ) ;

		#if defined(TCP_IP)
		mn_service_host();
		#endif // TCP_IP

		#ifdef KORTEX
		if (AM_G_PnP_timer == 0) {
			Am_task ( MC_IDLE, NULL,NULL) ;
		} else {
			if (x_elapsed_time (AM_G_PnP_timer) > AM_PNP_WAIT_TIME) {
				AmDoOneTimeWhenDtrOnFinal();
				AM_G_PnP_timer = 0;
			}
		}
		#endif

		if ( !AUTOBAUDING ) z80_chk_autobaud() ;

		//====================================================
		// IF we go on-line and HW FC is currently selected:
		//	1)	set auto enable mode of EASCI TX channel for
		//		flow control from the host (RTS), and
		//	2)	enable RX DMA on ch0.
		// IF we go on-line and SW FC is in use:
		//	1)	set software flow control flag - used in
		//		serial channel (EASCI/ESCC) RX ISR, and
		//	2)	establish ch0 dma in "to-host" direction for
		//		sending XOFF chars.
		//====================================================
		if ( (x_modem_mode == MODEM_DATA) &&
			 (x_modem_state == MS_ON_DIAL) &&
			 (io_at_esc_detect == FALSE) )
		{
			if ( z80_modem_state == WAITING_FOR_ONLINE_STATE )
			{
				if ( io_uart_status & UART_CD_ON )
				{
					//---------------------------------------------------
					//	turn off Autobauding
					//---------------------------------------------------
					disable_interrupt() ;
						if ( AUTOBAUDING ) z80_stop_autobaud() ;
					enable_interrupt() ;

					if ( S.ModemOptions.FlowControl == SW_FLOWCTRL )
					{
						x_debug_msg("Entering SWFC OnLine");

						z80_modem_state = SW_ON_LINE_STATE ;

						//---------------------------------------------------
						// turn off RTS auto control of TX channel
						//---------------------------------------------------
						output8 ( ASCI_XCR0_REG,
								 input8( ASCI_XCR0_REG ) | CTS0_DISABLE ) ;
						output8 ( A0INTIN,
								input8( A0INTIN ) &
									~(CTS_HL_INT_ENABLE|CTS_LH_INT_ENABLE) ) ;

						#if defined( Z80_EASCI_TX_DMA )
						//---------------------------------------------------
						// set SW FC dma packet size for "to-host" direction.
						//---------------------------------------------------
						z80_max_dma = Z80_MAX_SW_DMA ;
						#endif
					}
					else // if ( S.ModemOptions.FlowControl == HW_FLOWCTRL )
					{
						//---------------------------------------------------
						// HW Flow Control & No Flow Control treated the same
						//---------------------------------------------------
						x_debug_msg("Entering HWFC OnLine");

						z80_modem_state = HW_ON_LINE_STATE ;

						//---------------------------------------------------
						// turn on RTS auto control of TX channel
						//---------------------------------------------------
						output8 ( ASCI_XCR0_REG,
								input8( ASCI_XCR0_REG ) & ~CTS0_DISABLE ) ;

						output8 ( A0INTIN,
								input8( A0INTIN ) &
									~(CTS_HL_INT_ENABLE|CTS_LH_INT_ENABLE) ) ;

						#if defined( Z80_EASCI_TX_DMA )
						//---------------------------------------------------
						// set HW FC dma packet size for "to-host" direction.
						//---------------------------------------------------
						z80_max_dma = Z80_MAX_HW_DMA ;
						#endif

						#if defined( Z80_EASCI_RX_DMA )
						//---------------------------------------------------
						// start up the "from-host" side dma on ch0
						//---------------------------------------------------
						// note: the receive char interrupt is left enabled
						// for it will be blocked in hardware by the DMA
						// request. Errors however, (e.g. frame, break detect)
						// will still cause an interrupt.
						//---------------------------------------------------
						disable_interrupt() ;
							z80_dte_rx_wptr = IO_DTE_RX_WPTR ;
							z80_start_rx_dma() ;
						enable_interrupt() ;
						#endif

						#ifdef SYNCH_MODE
						if ( S.ModemOptions.V42 == V42_SYNCH_MODE )
						{
							extern void valv_setup(void);
							extern void dp_draco_timing_loop(void);
							x_debug_msg("Begin Synchronous Mode");
							valv_setup();
							dp_modem_command_long ( PDM, HDLC_FLAG, 0x01, (byte)SYNC_DATA_MODE, 0);
							dp_draco_timing_loop();
						}
						#endif
					}
				}
			}
		}
		else if ( z80_modem_state != WAITING_FOR_ONLINE_STATE )
		{
			x_debug_msg( "NOT OnLine" ) ;

			z80_modem_state = WAITING_FOR_ONLINE_STATE ;

			//---------------------------------------------------
			// turn off RTS auto control of TX channel
			//---------------------------------------------------
			output8 ( ASCI_XCR0_REG,
						 input8( ASCI_XCR0_REG ) | CTS0_DISABLE ) ;

			//---------------------------------------------------
			// turn on RTS interrupts for PnP
			//---------------------------------------------------
			output8 ( A0INTIN,
						input8( A0INTIN ) |
							(CTS_HL_INT_ENABLE|CTS_LH_INT_ENABLE) ) ;

			//---------------------------------------------------
			// set HW dma packet size for "to-host" direction.
			//---------------------------------------------------
			#if defined( Z80_EASCI_TX_DMA )
			z80_max_dma = Z80_MAX_HW_DMA ;
			#endif

			#if defined( PNPSTRING )
			if ( !io_at_esc_detect )
			{
				//---------------------------------------------------
				// Build the PnP enumeration sequence from the serial
				// eeprom. This string resides in the V42Bis/MNP
				// Dictionary area. Note: V42BIS can recover if this
				// area is corrupted but MNP[4/5] cannot.  Therefore,
				// do not rebuild the PnP string in this area for
				// momentary escapes (+++).
				//---------------------------------------------------
				x_debug_msg( "Rebuild PnP" ) ;
				PnP_buildit ( FALSE ) ;
			}
			#endif

			#if defined( Z80_DEBUG_PRINT )
			debug_rx_count = 0;
			#endif
		}

		//==============================================
		// First we handle the Receive side from the DTE.
		//==============================================
		// If we are on-line, check to see if FlowControl
		// has been set. If we have been on-line and have
		// had flow control set, then check to see if we
		// we can now release it.
		//==============================================
		if ( uart_flow_control != FC_OFF )
		{
			#if !defined( Z80_EASCI_TX_DMA )
			if ( uart_flow_control == FC_OFF_TO_ON )
			{
				// Too many chars rcvd from host - apply back pressure
				// in the form of an XOFF (we are in software flow control).
				io_put_dte_tx_char ( XOFF ) ; 	// XOFF to host - 0x13
				uart_flow_control = FC_ON ;
			}
			else // if ( uart_flow_control == FC_ON )
			#endif
			{
				// IF the DTE IS currently being back pressured AND
				//   we now have room in our Rx buffer THEN undo it!!!
				#ifndef IPGATEWAY
				if ( uart_rx_count <= HOST_RX_BUFF_EMPTY )
				#else
				if ( uart_rx_count <= isr_rx_empty_count )
				#endif
				{
					z80_flow_off();
				}
			}
		}
		else
		{
			// Check for the case of a stalled upload.
			// Has CTS been ON for a while with no
			// data coming from the DTE?
			z80_check_stall();
		}

		//==============================================
		//	Now we handle the transmit side to the DTE
		//==============================================
		// IF there is data to transmit to the DTE AND
		//   the send side of the ESCC/EASCI is IDLE
		// THEN look to restart the transmitter.
		//==============================================
		if ( z80_no_more_tx && (IO_DTE_TX_WPTR != IO_DTE_TX_RPTR) )
		{
			//=================================================
			// IF on-line AND the DTE has entered flow-control
			// THEN do NOT restart transmiting data to the DTE
			//=================================================
			if ( ((S.ModemOptions.FlowControl == HW_FLOWCTRL) &&
					!(input8 ( ASCI_CTLB0_REG ) & ASCI_CTS) )
				|| io_state < IO_ONLINE
				|| io_at_esc_detect
				|| ((S.ModemOptions.FlowControl == SW_FLOWCTRL) &&
					!in_xof_from_dte)
				|| (S.ModemOptions.FlowControl == NO_FLOWCTRL) )
			{
				// Send a character to start the transmit side again
				disable_interrupt () ;
				{
					if ( AUTOBAUDING )
					{
						z80_stop_autobaud () ;
					}
					z80_no_more_tx = FALSE ;
					#if defined( Z80_EASCI_TX_DMA )
					#if defined( TX_DMA_DEBUG )
					if ( z80_dma_debug ) sendDumbChar( 'z' ) ;
					#endif
					// DMA mode
					enable_interrupt () ;
						z80_start_tx_dma() ;
					disable_interrupt () ;
					#else
					// Non DMA mode
					output8( ASCI_STAT0_REG,
							input8( ASCI_STAT0_REG ) | TX_INT_ENABLE ) ;
					output8( ASCI_TX0_REG, *IO_DTE_TX_RPTR ) ;
					if ( ++IO_DTE_TX_RPTR >= IO_DTE_TX_EPTR )
					{
						IO_DTE_TX_RPTR = IO_DTE_TX_SPTR ;
					}
					#endif
				}
				enable_interrupt () ;
			}
		}

		//==============================================
		// Check for Break condition set to DTE
		// and reset after Break time has expired.
		//==============================================
		if ( (brk_to_dte_flg == TRUE)
		 	 && (x_elapsed_time ( brk_timer ) > BRK_TIME) )
		{
			output8( ASCI_XCR0_REG,
						input8( ASCI_XCR0_REG ) & ~SEND_BRK ) ;
			#if defined(Z80_DEBUG_PRINT)
			output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & ~BIT3 ) ;
			#endif

			brk_to_dte_flg = FALSE ;
		}

		#if defined( PNPSTRING )
		//==============================================
		// IF Enumeration sequence has been received
		// from DTE Send PnP COM ID string to DTE
		//==============================================
		if ( PnP_state == T4 )
		{
			PnP_count ++ ;
		
			// Init PnP state
			PnP_setstate ( T0 ) ;

			PnP_identify ( FALSE ) ;
			x_debug_msg( "PnP Sequence Sent" );
		}
		#endif

		if ( isrTimer != x_current_time() )
		{
			z80_chk_isr_chg() ;
			isrTimer = x_current_time();
		}

		if ( s_62 != lst_s_62 )
		{
			easci_baud_rate() ;
			lst_s_62 = s_62 ;
		}

		//------------------------------------------------
		//------------------------------------------------
		if ( src_c_int > 255 )
		{
			if ( (x_modem_mode == MODEM_DATA) &&
				 (x_modem_state == MS_ON_DIAL) )
			{
				// load factory default settings
				x_init_modem_options () ;
				// load settings if saved in eeprom
				ll_load_modem_options () ;
				x_send_mail ( AT_IO_DISCONNECT, IO_TASK, NULL, 0 ) ;
			}
			src_c_int = 0 ;
		}
		else 
		{
			disable_interrupt () ;
				if ( src_c_int ) src_c_int-- ;
			enable_interrupt () ;
		}

		#if defined(Z80_DEBUG_PRINT) && !defined(KORTEX)
		z80_dbug_print() ;
		#endif

		#if defined(ATHENA_LEDS)
		if (x_elapsed_time(z80_athena_datatimer) > MS100)
		{
			if ((IO_DTE_TX_WPTR != IO_DTE_TX_RPTR) ||
				(IO_DTE_RX_WPTR != IO_DTE_RX_RPTR))
			{
				// data in DTE TX or RX buffer means data is flowing
				x_output(IO_DATA_LED_TOGGLE);
			}
  			else
			{
				x_output(IO_DATA_LED_OFF);
			}
	  		z80_athena_datatimer = x_current_time();
		}
		#endif
	}
}
#endif	// } EXT_MODEM
