/*name and version number:@(#)arm_util.c	1.1*/
/*date of get: 		  12/15/00 10:10:56*/
/*date of delta:	  11/30/00 21:20:22*/
/****************************************************************
File :	arm_util.c
Description :
	Contains ARM utilities for external modem

Procedures Contained :

Revision History :
	JA 			11/07/00	initial
*****************************************************************/

#include "llglob_d.h"
#include "arm_glob.h"
#include <string.h>

#if defined( MODEM_ARM )

#include "atglob.h"
#include "dpglob.h"
#include "allglobs.h"

extern const byte str_convert[];
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//		STUBS
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
BOOL	AUTOBAUDING ;
BOOL	brk_to_dte_flg ;
word	brk_timer ;

word z80_checksum ( byte x )
{
	return 0 ;
}
void z80_init_dtr ( void )
{
}
//--------------------------------------------------
// dummy functions for EEPROM
//--------------------------------------------------
byte read_eeprom ( word loc )
{
	return 0;
}
void write_eeprom ( word loc, byte data_value )
{
}
//--------------------------------------------------
// at_percent_f() - dummy function for no at%f
//--------------------------------------------------
void at_percent_f ( void )
{
}
void at_dash_i3(void)
{
	atparse_cmd();
}
void
dumbDisplayMem(void)
{
}
void
dumpDumbInfo(void)
{
}

void output8( char addr, char val )
{
}
void output( char addr, char val )
{
}
byte input8( char addr )
{
	return 0;
}
byte input( char addr )
{
	return 0;
}

void disable_interrupt()
{
}
void enable_interrupt()
{
}

void
_int_disable()
{
}

void
_int_enable()
{
}

/****************************************************************
	Function : z80_uart_break_on
	Break received from far end, Send a break to DTE
	NOTE: main() will be responsible for clearing the
	break condition after 300 ms (see BRK_TIME).
*****************************************************************/
void z80_uart_break_on ( void )
{
	// start Break to DTE
	output8( ASCI_XCR0_REG, input8( ASCI_XCR0_REG ) | SEND_BRK ) ;
	output8 ( DUMB_MCR, input8 ( DUMB_MCR ) | 0x08 ) ;
	brk_to_dte_flg = TRUE ;
	brk_timer = x_current_time () ;
}

/****************************************************************
	Function : z80_uart_cts_on
*****************************************************************/
void z80_uart_cts_on ( void )
{
	// set CTS to DTE
	disable_interrupt();
		output8 ( ASCI_CTLA0_REG, input( ASCI_CTLA0_REG ) & ~ASCI_RTS ) ;
	enable_interrupt();
}

/****************************************************************
	Function : z80_uart_cts_off

		MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void z80_uart_cts_off ( void )
{
	// clear CTS to DTE
	output8( ASCI_CTLA0_REG, input8( ASCI_CTLA0_REG ) | ASCI_RTS ) ;
}

/****************************************************************
	Function : z80_uart_cd_on
*****************************************************************/
void z80_uart_cd_on ( void )
{
	// set DCD to DTE
	disable_interrupt () ;
		x_output( IO_CARRIER_DETECT_ON ) ;
	enable_interrupt () ;
}

/****************************************************************
	Function : z80_uart_cd_off
*****************************************************************/
void z80_uart_cd_off ( void )
{
	// clear DCD to DTE
	disable_interrupt () ;
		x_output( IO_CARRIER_DETECT_OFF ) ;
	enable_interrupt () ;
}

/****************************************************************
	Function : z80_uart_ri_on
*****************************************************************/
void z80_uart_ri_on ( void )
{
	x_output( IO_RING_INDICATE_ON ) ;
}

/****************************************************************
	Function : z80_uart_ri_off
*****************************************************************/
void z80_uart_ri_off ( void )
{
	x_output( IO_RING_INDICATE_OFF ) ;
}

/****************************************************************
	Function : z80_uart_dsr_on
*****************************************************************/
void z80_uart_dsr_on ( void )
{
	x_output( IO_DSR_ON ) ;
	ddputs_nnl( "DSR ON" ) ;
	sendCrLf();
}

/****************************************************************
	Function : z80_uart_dsr_off
*****************************************************************/
void z80_uart_dsr_off ( void )
{
	x_output( IO_DSR_OFF ) ;
	ddputs_nnl( "DSR OFF" ) ;
	sendCrLf();
}

BOOL genpat(void)
{
	return 0;
}
void points_clear()
{
}
/*****************************************************************
	Function : x_sleep_mode
	Put the uC into sleep mode.
******************************************************************/
byte x_sleep_mode ( void )
{
	return TRUE ;
}

//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//		END STUBS
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

/****************************************************************
	Function : init_DSP
*****************************************************************/
void init_DSP ( void )
{
#if defined(CS_4)
	G(dp_bamil_re6) = ALLINTS;
	DP_SET_CORE_INTS( ALLINTS );
	DP_CLR_CORE_INTS( ALLINTS );

	#if 0
	// mux IRQc to BIOC7
	dp_regwrite( 0xc0, dp_regread( 0xc0 ) & ~BIT3 ) ;
	printf( "C0 = %x; ", dp_regread( 0xc0 ) ) ;

	// Select IRQc for RMP / DIA interrupts
	byte reg = dp_regread( 0xcc ) ;
	reg |= BIT3 ;
	reg &= ~(BIT4|BIT2) ;
	dp_regwrite( 0xcc, reg ) ;
	printf( "CC = %x; ", dp_regread( 0xcc ) ) ;

	// Enable IRQc to be driven
	dp_regwrite( 0xd6, 0 ) ;
	printf( "D6 = %x; ", dp_regread( 0xd6 ) ) ;
	#endif
#endif
}
char *arm_board_str[] = {
	"EB40",
	"OCM_something",
};

byte
arm_board_type()
{
	// return board id bits
	return 0;
}

void
arm_uart_init()
{
}

void
arm_timer_init()
{
}

/****************************************************************
	Function : init_SA_hardware
	Initialize EBSA specific hardware (called once)
*****************************************************************/
void init_arm_hardware ( void )
{
	//---------------------------------------
	// initialize debug port
	//---------------------------------------
	arm_uart_init() ;
	printf( "\nBuild Date: %s , Time: %s\n", __DATE__ , __TIME__ ) ;

	//---------------------------------------
	// initialize ARM timer
	//---------------------------------------
	printf("\n\tENABLE TIMER!!!!\n" ) ;
	arm_timer_init();

	// Determine board type dynamically!!!
	printf("Running on %s\n", arm_board_str[ arm_board_type() ]);
}

#if defined( Z80_DEBUG_PRINT )	// {
/*************************************************************************
	The following routines read/write data from the either the
	Development Board debug port or the DTE interface.
*************************************************************************/

/****************************************************************
	Function : sendDumbChar(byte ch)
	Sends a char on the Dumb Serial port
*****************************************************************/
void
sendDumbChar( byte ch )
{
	//eduPutChar( ch ) ;
	putchar(ch);
}

/****************************************************************
	Function : sendHexDigit(byte digit)
	Converts the digit to ASCII and prints it on the debug port
*****************************************************************/
void
sendHexDigit(byte digit)
{
	sendDumbChar((digit > 0x0f) ? 'X' : str_convert[digit]);
}

/****************************************************************
	Function : ddputs_nnl(char *str)
	prints a string on the debug port
*****************************************************************/
void
ddputs_nnl(char *str)
{
	printf( str ) ;
}

/****************************************************************
Routine : sendCrLf - send carriage return line feed to dumb port
*****************************************************************/
void sendCrLf(void)
{
	sendDumbChar(0x0A);
	sendDumbChar(0x0D);
}

/****************************************************************
	Function : ddputs_nnl(char *str)
	prints a string on the debug port
*****************************************************************/
void
x_debug_msg ( char *str )
{
	if ( *(str+strlen(str)-1) == '=' )
		printf( "%s ", str ) ;
	else
		printf( "%s\n", str ) ;
}

/****************************************************************
	Function : ddputs(char *str)
	prints a time stamped string on the debug port with CRLF
*****************************************************************/
void
ddputs(char *str)
{
	word t = x_current_time();

	printf( "0x%x: %s\n", t, str ) ;
}

/****************************************************************
	Function : sendDecByte(byte ch)
	prints a decimal byte
*****************************************************************/
void
sendDecByte(byte ch)
{
	byte x = 0;
	byte y = 0;

	/* hundreds */
	while (ch > 99)
	{
		y++;
		x++;
		ch -= 100;
	}
	if (x)
	{
		sendDumbChar(x + '0');
		x = 0;
	}

	/* tens */
	while (ch > 9)
	{
		x++;
		ch -= 10;
	}
	if (x || y)
	{
		sendDumbChar(x + '0');
		x = 0;
	}

	sendDumbChar(ch + '0');
}

/****************************************************************
	Function : sendHexByte(byte ch)
	prints a hex byte
*****************************************************************/
void
sendHexByte(byte ch)
{
	sendHexDigit( (ch >> 4) & 0x0f );
	sendHexDigit( ch & 0x0f );
}

/****************************************************************
	Function : sendHexWord(word wd)
	prints a hex word
*****************************************************************/
void
sendHexWord(word wd)
{
	byte i;

	for (i=0; i<4; i++)
	{
		sendHexDigit((wd & 0xf000) >> 12);
		wd <<= 4;
	}
}

void
fatal_error(char *str)
{
	sendHexWord( x_current_time() ) ;
	x_debug_msg(": fatal error: ");
	cs_debug_liv(FATAL_ERROR);
	ddputs_nnl(str);
	sendDumbChar(0x0A); sendDumbChar(0x0D);
	while(1)
		;
}
#endif	//  } Z80_DEBUG_PRINT

#endif	// MODEM_ARM
