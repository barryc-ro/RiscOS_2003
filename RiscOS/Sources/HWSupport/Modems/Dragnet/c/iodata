/*name and version number:@(#)iodata.c	1.81*/
/*date of get: 		  05/02/01 16:30:57*/
/*date of delta:	  05/01/01 16:33:26*/
/****************************************************************
File :	iodata.c
Description :
	Contains all routines in data mode to the dce interface.

Procedures Contained :
	io_tx_dte_to_dce_data
	io_tx_dce_to_dte_data
	io_dte_loopback
	io_tx_v54
	io_dce_loopback

Revision History :
	Initials	Date		Change
*****************************************************************/

//#define Z80_DEBUG_THIS_FILE

#include "llglob_d.h"
#include "ioglob_d.h"
#include "iouart_d.h"
#include "z80glob.h"
#include "allglobs.h"

#if defined(IO_SEQUENCE_TEST)
//--------------------------------------------------------
// Uncomment the following #define to test the 511 BER
// (Bit Error Rate) stream generated by test equipment.
// The default test, if "IO_511_TEST" left undefined,
// and "IO_SEQUENCE_TEST" is defined, is the 64 byte
// sequence generated by the test program "sc2" ('0'-'o').
//--------------------------------------------------------
//# define  IO_511_TEST
# if defined(IO_511_TEST)
/****************************************************************
	Array for 511 Bit test.
	This array is exactly the pseudo random bit sequence generated
	by Bit Error Rate test equipment in SysTst.  It is a 511 byte
	array that always starts with 0x55, 0x81, ...
*****************************************************************/
const byte io_seqarray[] =
{
	0x55, 0x81, 0x52, 0x4F, 0x77, 0xE0, 0x5C, 0xF2,
	0xBA, 0x22, 0x61, 0x0E, 0xBD, 0xCD, 0xC2, 0x3D,
	0xFC, 0x07, 0xEF, 0xA3, 0x33, 0x41, 0xCA, 0x2D,
	0x9E, 0xCF, 0x46, 0x25, 0x8E, 0xAD, 0x8E, 0x8C,
	0x08, 0x10, 0x62, 0xC8, 0xA9, 0x86, 0xBD, 0xEC,
	0x44, 0xA1, 0x96, 0xDF, 0x24, 0xED, 0x27, 0x2B,
	0x33, 0x60, 0x4C, 0xB1, 0xF4, 0x17, 0x8D, 0x6B,
	0x9A, 0xC7, 0x77, 0xC1, 0xDA, 0x6E, 0xD0, 0xFA,
	0xAA, 0x40, 0xA9, 0xA7, 0x3B, 0x70, 0x2E, 0x79,
	0x5D, 0x91, 0x30, 0x87, 0xDE, 0x66, 0xE1, 0x1E,
	0xFE, 0x83, 0xF7, 0xD1, 0x99, 0x20, 0xE5, 0x16,
	0xCF, 0x67, 0xA3, 0x12, 0xC7, 0x56, 0x47, 0x46,
	0x04, 0x08, 0x31, 0xE4, 0x54, 0xC3, 0x5E, 0x76,
	0xA2, 0x50, 0xCB, 0x6F, 0x92, 0xF6, 0x93, 0x95,
	0x19, 0x30, 0xA6, 0x58, 0xFA, 0x8B, 0xC6, 0x35,
	0xCD, 0xE3, 0xBB, 0x60, 0x6D, 0x37, 0x68, 0x7D,
	0x55, 0xA0, 0xD4, 0xD3, 0x1D, 0x38, 0x97, 0xBC,
	0xAE, 0x48, 0x98, 0x43, 0x6F, 0xB3, 0x70, 0x0F,
	0xFF, 0xC1, 0xFB, 0xE8, 0x4C, 0x90, 0x72, 0x8B,
	0xE7, 0xB3, 0x51, 0x89, 0x63, 0xAB, 0x23, 0x23,
	0x02, 0x84, 0x18, 0x72, 0xAA, 0x61, 0x2F, 0x3B,
	0x51, 0xA8, 0xE5, 0x37, 0x49, 0xFB, 0xC9, 0xCA,
	0x0C, 0x18, 0x53, 0x2C, 0xFD, 0x45, 0xE3, 0x9A,
	0xE6, 0xF1, 0x5D, 0xB0, 0xB6, 0x1B, 0xB4, 0xBE,
	0x2A, 0x50, 0xEA, 0xE9, 0x0E, 0x9C, 0x4B, 0x5E,
	0x57, 0x24, 0xCC, 0xA1, 0xB7, 0x59, 0xB8, 0x87,
	0xFF, 0xE0, 0x7D, 0x74, 0x26, 0x48, 0xB9, 0xC5,
	0xF3, 0xD9, 0xA8, 0xC4, 0xB1, 0xD5, 0x91, 0x11,
	0x01, 0x42, 0x0C, 0x39, 0xD5, 0xB0, 0x97, 0x9D,
	0x28, 0xD4, 0xF2, 0x9B, 0xA4, 0xFD, 0x64, 0x65,
	0x06, 0x8C, 0x29, 0x96, 0xFE, 0xA2, 0x71, 0x4D,
	0xF3, 0xF8, 0x2E, 0x58, 0xDB, 0x0D, 0x5A, 0x5F,
	0x15, 0x28, 0xF5, 0x74, 0x07, 0xCE, 0x25, 0xAF,
	0x2B, 0x12, 0xE6, 0xD0, 0xDB, 0x2C, 0xDC, 0xC3,
	0x7F, 0xF0, 0x3E, 0x3A, 0x13, 0xA4, 0xDC, 0xE2,
	0xF9, 0x6C, 0x54, 0xE2, 0xD8, 0xEA, 0xC8, 0x88,
	0x00, 0x21, 0x86, 0x9C, 0x6A, 0xD8, 0xCB, 0x4E,
	0x14, 0x6A, 0xF9, 0x4D, 0xD2, 0x7E, 0xB2, 0x32,
	0x03, 0xC6, 0x14, 0x4B, 0x7F, 0xD1, 0xB8, 0xA6,
	0x79, 0x7C, 0x17, 0xAC, 0xED, 0x06, 0xAD, 0xAF,
	0x0A, 0x94, 0x7A, 0xBA, 0x03, 0xE7, 0x92, 0xD7,
	0x15, 0x09, 0x73, 0xE8, 0x6D, 0x16, 0xEE, 0xE1,
	0x3F, 0x78, 0x1F, 0x9D, 0x09, 0x52, 0x6E, 0xF1,
	0x7C, 0x36, 0x2A, 0x71, 0x6C, 0x75, 0x64, 0x44,
	0x80, 0x10, 0x43, 0x4E, 0x35, 0xEC, 0x65, 0x27,
	0x0A, 0xB5, 0xFC, 0x26, 0x69, 0x3F, 0x59, 0x99,
	0x01, 0x63, 0x8A, 0xA5, 0xBF, 0x68, 0x5C, 0xD3,
	0x3C, 0xBE, 0x0B, 0xD6, 0x76, 0x83, 0xD6, 0x57,
	0x05, 0x4A, 0x3D, 0xDD, 0x81, 0x73, 0xC9, 0xEB,
	0x8A, 0x84, 0x39, 0xF4, 0x36, 0x0B, 0xF7, 0xF0,
	0x1F, 0xBC, 0x8F, 0xCE, 0x04, 0x29, 0xB7, 0x78,
	0x3E, 0x1B, 0x95, 0x38, 0xB6, 0x3A, 0x32, 0x22,
	0x40, 0x88, 0x21, 0xA7, 0x1A, 0xF6, 0xB2, 0x13,
	0x85, 0x5A, 0x7E, 0x93, 0xB4, 0x9F, 0xAC, 0xCC,
	0x80, 0x31, 0xC5, 0xD2, 0x5F, 0x34, 0xAE, 0x69,
	0x1E, 0xDF, 0x05, 0x6B, 0xBB, 0x41, 0xEB, 0xAB,
	0x02, 0xA5, 0x9E, 0xEE, 0xC0, 0xB9, 0xE4, 0x75,
	0x45, 0xC2, 0x1C, 0x7A, 0x9B, 0x85, 0x7B, 0xF8,
	0x0F, 0xDE, 0x47, 0x67, 0x82, 0x94, 0x5B, 0x3C,
	0x9F, 0x8D, 0x4A, 0x1C, 0x5B, 0x1D, 0x19, 0x11,
	0x20, 0xC4, 0x90, 0x53, 0x0D, 0x7B, 0xD9, 0x89,
	0x42, 0x2D, 0xBF, 0x49, 0xDA, 0x4F, 0x56, 0x66,
	0xC0, 0x98, 0x62, 0xE9, 0x2F, 0x1A, 0xD7, 0x34,
	0x8F, 0xEF, 0x82, 0xB5, 0xDD, 0xA0, 0xF5
};
#  define LAST_CHAR			0x55
#  define CUR_CHAR			0x81
# else
/****************************************************************
	Array for 64 char sequence test.
	This array is exactly the sequence generated by the program
	"sc2". It consists of the chars '0'-'o' (0x30-0x6f).
*****************************************************************/
const byte io_seqarray[] =
{
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
};
#  define LAST_CHAR			0x30
#  define CUR_CHAR			0x31
# endif	// !IO_511_TEST

# define IO_SEQARRAYSIZE		(sizeof(io_seqarray)/sizeof(byte))

dword io_RXttlchars, io_TXttlchars;
const byte *io_TXseqarray_curp, *io_TXseqarray_endp;
const byte *io_RXseqarray_curp, *io_RXseqarray_endp;
byte io_RXlst16chars[16], *io_RXlstchptr;
byte io_TXlst16chars[16], *io_TXlstchptr;

BOOL io_RXnSync, io_TXnSync;
byte io_RXseqInit, io_TXseqInit;
byte io_RXmaxSequenceErrors, io_TXmaxSequenceErrors;
byte io_RXlineCnt, io_TXlineCnt;
STATIC void io_sequenceInit ( byte );

/****************************************************************
	Function : io_sequencePrint
	This function provides a summary print (and optionally
	reinits the vars) of the last I/O sequence test run.
*****************************************************************/
void io_sequencePrint ( BOOL reinit )
{
	if ( io_RXttlchars )
	{
		x_debug_msg("\r\nTotal RX chars Seq chked=");
		sendHexWord((word)(io_RXttlchars>>16));
		sendHexWord((word)(io_RXttlchars&0xffff));
		x_debug_msg("; RX Seq Errors=");
		sendHexByte(io_RXmaxSequenceErrors);
		sendCrLf();
	}
	if ( io_TXttlchars )
	{
		x_debug_msg("\r\nTotal TX chars Seq chked=");
		sendHexWord((word)(io_TXttlchars>>16));
		sendHexWord((word)(io_TXttlchars&0xffff));
		x_debug_msg("; TX Seq Errors=");
		sendHexByte(io_TXmaxSequenceErrors);
		sendCrLf();
	}
	if ( reinit )
	{
		io_RXseqInit = 0x00;
		io_sequenceInit( RXMTR );
		io_TXseqInit = 0x00;
		io_sequenceInit( TXMTR );
	}
}

/****************************************************************
	Function : io_sequenceInit
	This Function initializes the variables to start a sequence
	test session.
	It can be called in-line with the addition of a little overhead
	(see io_tx_dte_to_dce_data() below), or
	It can be called indirectly by io_sequencePrint() above
	(with a non-zero arg passed to it).
*****************************************************************/
STATIC void io_sequenceInit ( byte dir )
{
	switch ( dir )
	{
	case RXMTR :
		if ( io_RXseqInit == 0x5a ) return;
		io_RXseqInit = 0x5a;
		x_debug_msg("\r\nStart RX Sequence Test");
		io_RXnSync = FALSE;
		io_RXlstchptr = io_RXlst16chars;
		io_RXmaxSequenceErrors = 0;
		io_RXttlchars = 0;
		io_RXseqarray_curp = io_seqarray;
		io_RXseqarray_endp = &io_seqarray[IO_SEQARRAYSIZE];
		io_RXlineCnt = 0;
		break;

	case TXMTR :
		if ( io_TXseqInit == 0x5a ) return;
		io_TXseqInit = 0x5a;

		x_debug_msg("\r\nStart TX Sequence Test");
		io_TXnSync = FALSE;
		io_TXlstchptr = io_TXlst16chars;
		io_TXmaxSequenceErrors = 0;
		io_TXttlchars = 0;

		io_TXseqarray_curp = io_seqarray;
		io_TXseqarray_endp = &io_seqarray[IO_SEQARRAYSIZE];
		io_TXlineCnt = 0;
		break;
	}
}

/****************************************************************
	Function : io_gotError ( byte ch )
	This function blabs to the debug terminal when a sequence
	error occurs (called by io_tstSequence() below).
*****************************************************************/
static void io_gotError ( byte dir, byte inch, byte nxtch )
{
	byte i;
	byte maxSequenceErrors;
	byte *chptr, *sptr, *eptr;

	switch ( dir )
	{
	case RXMTR :
		DP_PUTS("RX:");
		maxSequenceErrors = ++io_RXmaxSequenceErrors;
		chptr = io_RXlstchptr;
		sptr = io_RXlst16chars;
		eptr = &io_RXlst16chars[16];
		io_RXnSync = FALSE;
		break;
	case TXMTR :
		DP_PUTS("TX:");
		maxSequenceErrors = ++io_TXmaxSequenceErrors;
		io_TXnSync = FALSE;
		chptr = io_TXlstchptr;
		sptr = io_TXlst16chars;
		eptr = &io_TXlst16chars[16];
		break;
	}

	x_debug_msg("Seq Error # ="); sendHexByte(maxSequenceErrors);
	x_debug_msg("; Expctd =");  sendHexByte(nxtch);
	x_debug_msg("; Got =");  sendHexByte(inch);

	x_debug_msg("\r\nLast 16 chars :");
	for ( i=0; i<16; i++ )
	{
		// non printable
		send_debug_char('\''); sendHexByte(*chptr); send_debug_char('\'');
		send_debug_char(' ');

		if ( ++chptr >= eptr )
			chptr = sptr;
	}
	sendCrLf();

	io_sequencePrint(0);

	if ( maxSequenceErrors >= 64 )
		x_debug_msg("\tMax Sequence Errors Exceeded (test suspended)");
}

/****************************************************************
		IO_SEQUENCE_TEST Macros (for speed)
*****************************************************************/
#if defined(MODEM_Z80)
# define  sendChar(ch)						\
do {										\
	while (!(input8(DUMB_LSR) & 0x20)) ;	\
	output8(DUMB_DATA, ch);					\
} while(0)
#else
# define  sendChar(ch) send_debug_char(ch)
#endif

extern const byte str_convert[];
#define  sendHex(ch,l)						\
do {										\
	if ( ((l)++ & 0x07) == 0 )				\
	{										\
		sendChar(0x0A); sendChar(0x0D);		\
	}										\
	sendChar(str_convert[(ch>>4) & 0x0f]);	\
	sendChar(str_convert[ch & 0x0f]);		\
	sendChar( ',' );						\
} while(0)

/****************************************************************
	Function : io_tstSequence

	This function tests for a repeating '0'-'o' 64 char
	sequence (from sc2.exe) in either the TX (from host) or
	RX (to host) direction.  On error, it calls io_gotError()
	above to report.

	To call from anywhere, change to non-static (Z80 only) and
	insert a call to this fcn in the data stream.

	For an example from the StrongArm days, see "SA_SEQUENCE_TEST"
	in lapm_dte.c for v42bis/v44 testing in the RX direction.
*****************************************************************/
STATIC void io_tstSequence( byte dir, byte ch )
{
	static byte lstTXch ;
	static byte lstRXch ;

	if ( dir == TXMTR )
	{
		if ( io_TXmaxSequenceErrors >= 64 ) return;
		io_TXttlchars++;

		if ( !io_TXnSync )
		{
			sendHex(ch,io_TXlineCnt);

			if ( (lstTXch == LAST_CHAR) && (ch == CUR_CHAR) )
			{
				//-------------------------------------------
				// got 1st 2 chars of sequence - restart test
				//-------------------------------------------
				io_TXnSync = TRUE;
				io_TXseqarray_curp = &io_seqarray[2];
				io_TXlineCnt = 0;
			}
			else
				lstTXch = ch;
		}
		else if ( *io_TXseqarray_curp == ch )
		{
			//----------------------------------------
			// save last 16 chars for error reporting
			//----------------------------------------
			*io_TXlstchptr = ch;
			if ( ++io_TXlstchptr >= &io_TXlst16chars[16] )
				io_TXlstchptr = io_TXlst16chars;

			if ( ++io_TXseqarray_curp >= io_TXseqarray_endp )
				io_TXseqarray_curp = io_seqarray;
		}
		else
		{
			io_gotError( dir, ch, *io_TXseqarray_curp );
			lstTXch = 0;
		}
	}
	else // ( dir == RXMTR )
	{
		if ( io_RXmaxSequenceErrors >= 64 ) return;
		io_RXttlchars++;

		if ( !io_RXnSync )
		{
			sendHex(ch,io_RXlineCnt);

			if ( (lstRXch == LAST_CHAR) && (ch == CUR_CHAR) )
			{
				//-------------------------------------------
				// got 1st 2 chars of sequence - restart test
				//-------------------------------------------
				io_RXnSync = TRUE;
				io_RXseqarray_curp = &io_seqarray[2];
				io_RXlineCnt = 0;
			}
			else
				lstRXch = ch;
		}
		else if ( *io_RXseqarray_curp == ch )
		{
			//----------------------------------------
			// save last 16 chars for error reporting
			//----------------------------------------
			*io_RXlstchptr = ch;
			if ( ++io_RXlstchptr >= &io_RXlst16chars[16] )
				io_RXlstchptr = io_RXlst16chars;

			if ( ++io_RXseqarray_curp >= io_RXseqarray_endp )
				io_RXseqarray_curp = io_seqarray;
		}
		else
		{
			io_gotError( dir, ch, *io_RXseqarray_curp );
			lstRXch = 0;
		}
	}
	return;
}
#endif	// IO_SEQUENCE_TEST

/****************************************************************
Routine : io_tx_break
Description :
	Send break to remote modem based on io_break_length.

	This function is only called for buffered mode.
	MNP and LAPM have their own ways of getting break
	to the remote modem.
*****************************************************************/
byte io_tx_break(void)
{
	word  count, *wptr;

	if (!(G(io_uart_status) & UART_DTE_BREAK_ON))
		return FALSE;

	count = io_get_dce_tx_count();
	wptr = G(io_dce_tx_wptr);
	if ( G(io_break_length) < count )
		count = G(io_break_length);
	G(io_break_length) = (word) (G(io_break_length) - count);

	if (G(io_break_length) == 0)
		UART_stop_break(); // do not send any break anymore.

	while (count--)
	{
		*wptr++ = HDLC_TX_ANY_CHAR;
		if (wptr >= G(io_dce_tx_eptr))
			wptr = G(io_dce_tx_sptr);
	}
	G(io_dce_tx_wptr) = wptr;
	io_start_dce_transmit();
	return TRUE;
}

/****************************************************************
Routine : io_tx_dte_to_dce_data
Description :
	Transmit data from the dte queue to the dce fifo.
	First check if space is available to write to the dce fifo.
*****************************************************************/
void io_tx_dte_to_dce_data ( void )
{
	word  count,   *dce_tx_wptr;
	volatile byte  *dte_rx_rptr;

	io_sequenceInit( TXMTR );

	if ( io_tx_break() )
		return ;

	count = io_get_dce_tx_count();	// get amount of free space on tx
	dce_tx_wptr = G(io_dce_tx_wptr);
	dte_rx_rptr = I(io_dte_rx_rptr);

	while ( count && !(dte_rx_rptr == I(io_dte_rx_wptr)) )
	{
		io_tstSequence( TXMTR, *dte_rx_rptr );

		*dce_tx_wptr = (word) (*dte_rx_rptr) ;
		if ( ++dce_tx_wptr >= G(io_dce_tx_eptr) )
			dce_tx_wptr = G(io_dce_tx_sptr) ;
		if ( ++dte_rx_rptr >= I(io_dte_rx_eptr) )
			dte_rx_rptr = I(io_dte_rx_sptr);
		--count ;
	}

	if ( G(io_dce_tx_wptr) != dce_tx_wptr )
	{
		G(io_dce_tx_wptr) = dce_tx_wptr ;
		I(io_dte_rx_rptr) = dte_rx_rptr;
		io_start_dce_transmit() ;
	}
}

/****************************************************************
Routine : io_dce_to_dte_data
Description :
	Transmit data from the dce fifo to the dte transmit queue.
	First check if space is available to write to the dte transmit queue.
	Used only for analog loopback.
Parameters in :
	none
Parameters out :
	none
Revision History :
	Initials	Date		Change
*****************************************************************/
void io_dce_to_dte_data ( void )
{
	word  count ;
	volatile byte  *dte_tx_wptr ;
	word  *dce_rx_rptr ;

	io_sequenceInit( RXMTR );

	count = io_get_dte_tx_count();
	dte_tx_wptr = I(io_dte_tx_wptr);
	dce_rx_rptr = G(io_dce_rx_rptr);

	while ( count && (dce_rx_rptr != G(io_dce_rx_wptr)) )
	{
		io_tstSequence( RXMTR, (byte)(*dce_rx_rptr) );

		*dte_tx_wptr = (byte)(*dce_rx_rptr);
		if ( ++dce_rx_rptr >= G(io_dce_rx_eptr) )
			dce_rx_rptr = G(io_dce_rx_sptr);
		if ( ++dte_tx_wptr >= I(io_dte_tx_eptr) )
			dte_tx_wptr = I(io_dte_tx_sptr);
		--count;
	}

	// update read & write ptrs
	I(io_dte_tx_wptr) = dte_tx_wptr;
	G(io_dce_rx_rptr) = dce_rx_rptr;
}

/****************************************************************
Routine : io_tx_dce_to_dte_data
Description :
	Transmit data from the dce fifo to the dte transmit queue.
	First check if space is available to write to the dte transmit queue.
Parameters in :
	none
Parameters out :
	none
Revision History :
	Initials	Date		Change
*****************************************************************/
void io_tx_dce_to_dte_data ( void )
{
	io_dce_to_dte_data () ;
}

/****************************************************************
Routine : io_dte_loopback
Description :
	Transmit data from the dte receive queue to the dte transmit queue.
Parameters in :
	none
Parameters out :
	none
Revision History :
	Initials	Date		Change
*****************************************************************/
void io_dte_loopback ( void )
{
	word  count ;
	byte  *wptr ;

	count = io_get_dte_tx_count () ;
	wptr = (byte *) I(io_dte_tx_wptr);
	while ( !IS_DTE_RX_EMPTY() && ( count-- ) )
	{
#if defined(VENUS2) && defined(IO_CHECK_LOOPBACK_DATA)
		// This checks the loopback data to determine
		// if it's the known pattern that mloop sends.

		static byte lastCh;
		byte ch;
		*wptr++ = ch = *I(io_dte_rx_rptr)++ ;
		if ((lastCh + 1) != ch)
		{
			// no error for wrap around
			if ((lastCh != 0x6f) || (ch != 0x30))
			{
				send_debug_char(ch);send_debug_char(' ');
			}
		}
		lastCh = ch;
#else
		*wptr++ = *I(io_dte_rx_rptr)++ ;
#endif
		DTE_RX_UPDATE();
		if ( wptr >= I(io_dte_tx_eptr) )
			wptr = (byte *) I(io_dte_tx_sptr);
	}
	I(io_dte_tx_wptr) = wptr ;
}

/****************************************************************
Routine : io_tx_v54
Description :
	Transmit V.54 loop2 preparatory pattern and termination pattern
Parameters in :
	data_bit
Parameters out :
	none
Revision History :
	Initials	Date		Change
	J.G(S).Xu		10/02/93	Initial
*****************************************************************/
void io_tx_v54 ( byte data_bit )
{
	byte shift_reg, tx_byte, tx_bit, j ;
	word  *wptr ;
	word byte_count, i ;

	if ( data_bit == 0 )	// preparatory, 2048 bits
		byte_count = 256 ;
	else					// termination, 8192 bits
		byte_count = 1023 ;
	wptr = G(io_dce_tx_wptr) ;
	shift_reg = 0xaa ;
	tx_byte = 0 ;
	for ( i = 0; i < byte_count; i++ )
	{
		for ( j = 0; j < 8; j++ )
		{
			if ( shift_reg & 0x10 )		// bit4
				tx_bit = 1 ;
			else
				tx_bit = 0 ;
			if ( shift_reg & 0x02 ) 	// bit7
				tx_bit = (byte) (tx_bit ^ 1);
			else
				tx_bit = (byte) (tx_bit ^ 0);		// bit4 ^ bit7
			tx_bit = (byte) (tx_bit ^ data_bit);	// tx_bit ^ data_bit
			shift_reg = (byte) (shift_reg >> 1);
			if ( tx_bit )
				shift_reg |= 0x80 ;
			tx_bit = (byte) (tx_bit << 7);
			tx_byte = (byte) (tx_byte >> 1);
			tx_byte |= tx_bit ;
		}
		*wptr++ = (word) (tx_byte | HDLC_TX_ANY_CHAR);
		if ( wptr >= G(io_dce_tx_eptr) )
			wptr = G(io_dce_tx_sptr) ;
	}
	G(io_dce_tx_wptr) = wptr ;
	io_start_dce_transmit () ;
}

/****************************************************************
Routine : io_dce_loopback
Description :
	Transmit data from the dce receive queue to the dce transmit queue.
Parameters in :
	none
Parameters out :
	none
Revision History :
	Initials    Date        Change
	AC          01/30/96    Initial
*****************************************************************/
void io_dce_loopback ( void )
{
	word dce_rx_count, dce_tx_count;
	byte count;

	// # of bytes available to read from dce receive queue
	dce_rx_count = io_get_dce_rx_count() ;

	// # 0f free bytes available in the dce transmit queue
	dce_tx_count = io_get_dce_tx_count() ;

	if ( ( dce_rx_count > 0 ) && ( dce_tx_count > 0 ) )
	{
		if ( dce_rx_count <= dce_tx_count )
			count = (byte) dce_rx_count ;
		else
			count = (byte) dce_tx_count ;

		while ( count-- )
		{
			*G(io_dce_tx_wptr)++ = *G(io_dce_rx_rptr)++ ;
			
			if ( G(io_dce_rx_rptr) >= G(io_dce_rx_eptr) )
				G(io_dce_rx_rptr) = G(io_dce_rx_sptr) ;

			if ( G(io_dce_tx_wptr) >= G(io_dce_tx_eptr) )
				G(io_dce_tx_wptr) = G(io_dce_tx_sptr) ;
		}
		io_start_dce_transmit() ;
	}
}

