/*name and version number:@(#)iofax.c	1.135*/
/*date of get: 		  01/10/01 16:57:56*/
/*date of delta:	  01/04/01 09:29:13*/
/****************************************************************
File :	iofax.c
Description :
	Contains all routines for the data transmition between
	DTE and DCE in the FAX mode.

Procedures Contained :
	io_compute_crc
	io_sub_into_buf
	io_fax_hdlc_dte_to_buf
	io_fax_hdlc_buf_to_dce
	io_fax_hdlc_dce_to_buf
	io_fax_hdlc_buf_to_dte
	ld_trailing_flags
	io_fax_sync_tx_ini
	io_fax_sync_dte_to_dce 
	io_fax_sync_dce_to_dte
	io_fax_init
	io_fax_background
	io_fax_disconnect

Revision History :
	Initials	Date		Change
	J.S.Xu		10/23/92	Initial   
*****************************************************************/
//#define Z80_DEBUG_THIS_FILE

#include "llglob_d.h"
#include "ioglob_d.h"
#include "v42bis.h"		// use the v42bis buffer
//#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
#include "fax_c2.h"
	#ifndef CS_MODEM
		#include "atglob.h"
	#endif                
//#endif

#if defined(V34_FAX)

//#include "dpglob.h"
#include "lapm.h"
#include "faxv34.h"
#endif

void dp_fax_modem_idle_cmd( void );
extern byte dp_regread ( byte ) ;

#include "fax.h"
#include "z80glob.h"
#include "dpglob.h"
#include "allglobs.h"

//#define FRAME_DEB_PRINT		// print frames for debug

#if defined(V34_FAX)
		// max frame in words, plus control, block/page/frame numbers, FCS.
		// also, allow for rcv frames to be 2*256 to accomodate <dle><subs>
		// Caution:  Note WORDS and BYTES.
	#define V34FAX_MAX_FRAME_SIZE	((2*256)+3+3+2+2)
		// make sure there is room for 2 frames (xmit and receive)
	//#if( sizeof(lapm_receive_queue) < (V34FAX_MAX_FRAME_SIZE * 2) )
#if !defined(MODEM_ARM)
	#if( sizeof(G(io_rx_queue)) < (V34FAX_MAX_FRAME_SIZE * 2) )
		#error LAPM Queue Insufficient Size for V34 DTE Frame Buf
	#endif
#endif
#endif // V34_FAX

#define FAX_HDLC_FINAL_FRAME	0x10

#if !defined(CS_MODEM) || defined (CLASS2_FAX)
/*****************************************************************************
	Function : io_compute_crc
	compute 16bit ccitt crc using the shift register method.
	using global variable io_crc.
	io_crc needs to be initialized to 0xffff
	io_crc needs to inverted (1's complement) before sending it out.
*****************************************************************************/
void io_compute_crc ( byte data_byte )
{
	byte i, r1 ;

	i = 8 ;
	do
	{
		r1 = data_byte ^ G(io_crc) ;	// data_byte ^ crc
		G(io_crc) = G(io_crc) >> 1 ;	// crc = crc >> 1
		data_byte = data_byte >> 1 ;	// data_byte = data_byte >> 1
		if ( r1 & 0x01 )				// LSB of (data_byte ^ crc)
			G(io_crc) = G(io_crc) ^ 0x8408 ;	// crc ccitt 16 - feedback mask
	} while ( --i ) ;
}
#endif

#ifndef CS_MODEM

/****************************************************************
Routine : io_fax_sub_to_buf
Description :  Do buffer substitutions as follows:
	DLE to DLE-DLE
	XON to DLE-SUBXON
	XOFF to DLE-SUBXOFF

NOTE:  The buf passed is big enough for any substitutions within an
		HDLC frame.

In Params:
rchar - received char
buf   - pointer to destination buffer for characters
index - index of character in buffer

Out Params:
Returns new buffer index pointing to next available buffer location.
*****************************************************************/
word io_sub_into_buf( const word rchar, word *buf, word index )
{
	if( (byte)rchar == DLE )		// stuff DLE to <DLE><DLE>
	{
		buf[ index++ ] = DLE;
	}
		// Note:  DLEs in the DCE data will expand using the DLE-DLE
		// escape even if there are two DLEs.  The T31A1 spec allows
		// the modem to use a <DLE><SUB> to represent a DLE DLE in the
		// data.  DLE-DLE in the data can also be sent to the host
		// as DLE-DLE-DLE-DLE.

	buf[ index ] = rchar ;	// no index inc here

		// For V.34 Fax, escape XON and XOFF chars in data.
		// These writes will overwrite the XON/XOFF in the buffer.
		// TIA-578B Table D1/ ITU-T.31 Ammend 1, Table B1.
#if defined(CLASS1_DC_SUBS)	// {
	if( !CLASS_2_OR_20 ) // do subs for all Class 1 modulations.
#elif defined(V34_FAX)
	if( (NON_V34 != G(x_fax_v34mode) )     // only sub for v34 modulations.
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
			&& !CLASS_2_OR_20                  // Using Class 1/1.0 FAX interface?
#endif
		)	                                 
#endif	// } CLASS1_DC_SUBS
#if defined(CLASS1_DC_SUBS) || defined(V34_FAX)
	{
		if( XON == (byte)rchar )
		{
			buf[ index++ ] = DLE;
			buf[ index ] = DLE_SUBXON;
		}
		else if( XOFF == (byte)rchar )
		{
			buf[ index++ ] = DLE;
			buf[ index ] = DLE_SUBXOFF;
		}
	}
#endif

	index++;	// increment buffer index
	return index;
}	// io_sub_into_buf()

/****************************************************************
Routine : io_fax_hdlc_dte_to_buf
Description :
	Transmit data from the dte queue to a buffer.
	Removes all character pairs begining with <DLE> and performs
	operations as described in T.31 Ammend 1, Table B1 and TIA-578B Table D1.

Parameters in :
	io_fax_buf[] base address
	io_hdlc_byte_count address

Parameters out :
	TRUE		-	if end of data <DLE> <ETX>
	FALSE		-	otherwise
*****************************************************************/
byte io_fax_hdlc_dte_to_buf ( word * io_fax_buf, word * io_hdlc_byte_count )
{
	byte rx_ch ;
	byte end_of_data;

	end_of_data = FALSE ;
	while ( end_of_data == FALSE && 
	      *io_hdlc_byte_count < (2 * V42bisP1) &&
		  !IS_DTE_RX_EMPTY() )
	{
		rx_ch = *I(io_dte_rx_rptr);                          // Read byte

		if ( (I(io_dte_rx_rptr) + 1) >= I(io_dte_rx_eptr) )  // End of buffer? (Prevent ISR from seeing invalid pointer)
			I(io_dte_rx_rptr) = I(io_dte_rx_sptr);             // Wrap to beginning

		else                                                 // Not end of buffer
    	I(io_dte_rx_rptr)++;                               // Point to next location

		if ( rx_ch == DLE ) 
		{ 
			if ( G(io_dte_rx_last_ch) == DLE )
			{
				io_fax_buf[ (*io_hdlc_byte_count)++] = (word)DLE ;
				G(io_dte_rx_last_ch) = 0 ;
			}
			else
			{
				G(io_dte_rx_last_ch) = DLE ;
			}
		} 
		else if( G(io_dte_rx_last_ch) == DLE )	// <DLE> escape
		{
			switch( rx_ch )
			{
				case ETX :		// end of frame (data) indication <DLE><ETX>
					end_of_data = TRUE ;
					break;

				case DLE_SUB :	// sub 2 DLE chars into data stream <DLE><SUB>
					io_fax_buf[ (*io_hdlc_byte_count)++] = (word)DLE ;
					io_fax_buf[ (*io_hdlc_byte_count)++] = (word)DLE ;
					break;

				case DLE_SUBXON :	// sub one 0x11 (XON) pattern
					io_fax_buf[ (*io_hdlc_byte_count)++] = (word)XON ;
					break;
				case DLE_SUBXOFF :	// sub one 0x13 (XOFF) pattern
					io_fax_buf[ (*io_hdlc_byte_count)++] = (word)XOFF ;
					break;

#if defined(MODEM_Z80)
				case XON :			// <DLE><DC1> - enable SW FC
					z80_swfc_on();
					break;
				case XOFF :			// <DLE><DC3> - disable SW FC
					z80_swfc_off();
					break;
#endif

#if defined(V34_FAX)	// {
				case EOT_V34:	// end of transmission <DLE><EOT>
					x_debug_msg("DLE-EOT");
					G(x_fax_v34channel) = NO_ACTIVE_CHANNEL;	// going to no channel

						// finish sending any outstanding frame
					G(io_timer) = x_current_time() ;
					G(io_fax_state) = IO_V34FAX_FRAMEWAIT ;
					break;

				case CTRL_V34:	// switch to control channel <DLE><CTRL>
						// for now, allow multiple restarts
						// we may have to do a similar thing
						// for rate changes
					x_debug_msg("DLE-CTRL");
					G(x_fax_v34channel) = PRIMARY_CHANNEL;	// debug

						// finish sending any outstanding frame
					G(io_timer) = x_current_time() ;
					G(io_fax_state) = IO_V34FAX_FRAMEWAIT ;
					break;

				case PRI_V34:	// switch to primary channel
						// for now, allow multiple restarts
						// we may have to do a similar thing
						// for rate changes
					x_debug_msg("DLE-PRI");
					G(x_fax_v34channel) = CONTROL_CHANNEL;	// debug

						// finish sending any outstanding frame
					G(io_timer) = x_current_time() ;
					G(io_fax_state) = IO_V34FAX_FRAMEWAIT ;
					break;

				case C12_V34 :	// control channel rate requests
				case C24_V34 :
							// store rate in "+F34" format (1-2).
						G( x_fax_prefc ) = (rx_ch & 0x0F) + 1;
					break;

				case P24_V34 :	// primary channel rate requests
				case P48_V34 :	// 4800bps
				case P72_V34 :	// 7200bps
				case P96_V34 :	// ...
				case P120_V34 :
				case P144_V34 :
				case P168_V34 :
				case P192_V34 :
				case P216_V34 :
				case P240_V34 :
				case P264_V34 :
				case P288_V34 :
				case P312_V34 :
				case P336_V34 :
							// store rate in "+F34" format (1-14).
						G( x_fax_maxp ) = (rx_ch & 0x0F) + 1;
					break;

				case PPH_V34 :	// <pph> - request primary rate reneg
						// set flag to request renegotiation
						// flag will cause update of rate on next CC start-up
						G( x_fax_train ) = RATE_RENEG;
					break;

				case MARK_V34 :	// <mark> - initiate termination of send
								// used for turn-around polling.
					x_debug_msg("DLE-MARK");
					G(x_fax_v34channel) = CONTROL_CHANNEL;	// force FRAMEWAIT to go to SEND1S
					G(io_timer) = x_current_time();
					G(io_fax_state) = IO_V34FAX_FRAMEWAIT ;
					break;

				case RTNC_V34 :	// <rtnc> - request control channel retrain
					// not supported in V1.137 DP release.
					//G( x_fax_train ) = CC_RETRAIN;
					break;

				case RTN_V34 :		// <rtn> - request duplex retrain
					break;

#endif	// V34_FAX }
				default:
#if defined(Z80_DEBUG_PRINT)
					x_debug_msg("iofax-bad DLE escape=") ;
					sendHexByte( rx_ch ); sendCrLf();
#endif
					break;

			} // switch(rx_ch)

			G(io_dte_rx_last_ch) = 0 ;
		}
		else	// neither rx_ch nor last_char is DLE (regular data)
		{
			io_fax_buf[ (*io_hdlc_byte_count)++ ] = (word)rx_ch ;
			G(io_dte_rx_last_ch) = rx_ch;    // Save as last character
		}
	} // while()

	if ( end_of_data == TRUE )
		return ( TRUE ) ;
	else if( *io_hdlc_byte_count >= (2 * V42bisP1) )
		return ( TRUE ) ;
	else
		return ( FALSE ) ;
} // io_fax_hdlc_dte_to_buf()

#endif

#if !defined(CS_MODEM) || defined (CLASS2_FAX)
/****************************************************************
Routine : ld_trailing_flags
Description :
	Load trailing flags into the DCE Tx buffer after a final or
	null frame is received from the DTE if <load> is true. Otherwise,
	return the number of trailing flags for a current data rate.
	The number of flags is based on the data rate:
		300  - 4 flags
	2,400  - 8
	4,800  - 16
	7,200  - 24
	9,600  - 32
	12,000 - 40
	14,400 - 48 flags

Parameters in :
	None
Parameters out :
	None
*****************************************************************/
word ld_trailing_flags (byte load)
{
	word	i;

	if (G(x_fax_rate) == MR_300)
		i = 4;

	else  // 2,400 through 14,400
		i = 8 + 8 * (G(x_fax_rate) - MR_2400);

	if (load)  // Actually load flags?
	{
		word  *wptr;
		wptr = G(io_dce_tx_wptr);

		while (i--)
		{
			*wptr++ = (word) (HDLC_TX_ANY_CHAR | 0x7E);

			if ( wptr >= G(io_dce_tx_eptr) )
				wptr = G(io_dce_tx_sptr);
		}

		G(io_dce_tx_wptr) = wptr;
	}

	return (i);
}

#if (defined (CLASS2_FAX) || defined (CLASS20_FAX)) && !defined (CS_MODEM)
// ------------------------------------------------------------------------------------ //
// Display the contents of a transmitted or received HDLC frame for Class 2/2.0/2.1 FAX //
// ------------------------------------------------------------------------------------ //

void send_fhx (word *rxfrm, word len, char dir)
{
	if (CLASS_2_OR_20 &&      // Using Class 2/2.0/2.1 interface?
			(G(c2p.sbf) & FBUG) ) // Debugging enabled?
	{
		word size = 5;
		byte buf[80];
		byte rb = (G(c2p.dbf) & 0x2000) != 0;  // Save bit order for phase B/D
		byte rx_ch;

		buf[0] = '+';
		buf[1] = 'F';
		buf[2] = 'H';
		buf[3] = dir;
		buf[4] = ':';

		while (len--)
		{
			rx_ch = (byte)*rxfrm++;              // Get a received character

			if (rb)                              // Reverse phase B/D bit order?
				rx_ch = rev_bits (rx_ch);          // Reverse bit order

			size = size + at_itoa (rx_ch, &buf[size], HEX); // Load value into buffer

			if (size >= 77)                      // Buffer almost full?
			{
				at_output_msg (buf, size);         // Send data to DTE now to prevent overflow
				size = 0;                          // Reset length
			}

			else
				buf[size++] = ' ';                 // Separate with spaces
		}

		if (size)                            // Any data still in buffer?
			at_output_msg (buf, size);         // Send data to DTE
	}
}

#else
	#define send_fhx(x, y, z)  // Don't generate any code
#endif

/****************************************************************
Routine : io_fax_hdlc_buf_to_dce
Description :
	Transmit data from the buffer to the dce fifo.
	First check if space is available to write to the dce fifo.
Parameters in :
	io_fax_buf[] base address
Parameters out :
	TRUE		-	if data is written to the transmit dce fifo
	FALSE		-	if no space available in dce fifo.
*****************************************************************/
byte io_fax_hdlc_buf_to_dce ( word * io_fax_buf, word * io_hdlc_byte_count)
{
	word	i;
	word  *wptr ;

	if ( io_get_dce_tx_count() > (*io_hdlc_byte_count + ld_trailing_flags(FALSE) ) )  // Room for frame & trailing flags?
	{
		if ( *io_hdlc_byte_count )
		{
			send_fhx(io_fax_buf, *io_hdlc_byte_count, 'T');  // Send +FHT if enabled

			io_fax_buf[0] |= HDLC_START_OF_FRAME ;
			io_fax_buf[ *io_hdlc_byte_count - 1 ] |= HDLC_END_OF_FRAME ;

			wptr = G(io_dce_tx_wptr) ;

			for ( i = 0 ; i < *io_hdlc_byte_count ; ++i )
			{
				*wptr++ = (word) io_fax_buf[i] ;
				if ( wptr >= G(io_dce_tx_eptr) )
					wptr = G(io_dce_tx_sptr) ;
			}

			G(io_dce_tx_wptr) = wptr;

				// transmit extra flags to make sure data and trailing flags are sent
			if( io_fax_buf[1] & FAX_HDLC_FINAL_FRAME )
				ld_trailing_flags (TRUE);

#ifdef FRAME_DEB_PRINT
			sendDumbChar( 'T' ); sendDumbChar( '(' );
			sendHexWord( *io_hdlc_byte_count );
			sendDumbChar( ')' ); sendDumbChar( ':' );
			if(
#if defined(V34_FAX)
				CONTROL_CHANNEL == G(x_fax_v34channel) || 	// only print CC...
#endif
				MR_300 == G(x_fax_rate) ||
				*io_hdlc_byte_count < 20 )					// and small frames.
			{
				for( i = 0 ; i < *io_hdlc_byte_count ; ++i )
				{
					sendDumbChar(' ');
					sendHexWord( io_fax_buf[i] );
				}
			}
			sendDumbChar(0x0A);
			sendDumbChar(0x0D);
#endif // FRAME_DEB_PRINT

#if defined(V34_FAX)
			if( G(x_fax_v34mode) != NON_V34 )  // Using V.34 modulation?
				*io_hdlc_byte_count = 0 ;        // Clear byte count
#endif
		}
		else  // NULL Frame
			ld_trailing_flags (TRUE);

		io_start_dce_transmit () ; 
		return ( TRUE ) ;
	}
	else
		return (FALSE);

} // io_fax_hdlc_buf_to_dce()

/****************************************************************
Routine : io_fax_sync_tx_ini
Description :
	Transmit 6 bytes of 0xFF in the begining of sync transmision
Parameters in :
	none
Parameters out :
	none
*****************************************************************/
void io_fax_sync_tx_ini ()
{
	word  *wptr ;
	byte   count ;

	wptr = G(io_dce_tx_wptr) ;
	for ( count=0; count<6; count++ )
	{
		*wptr++ = 0xFF ;
		if ( wptr >= G(io_dce_tx_eptr) )
			wptr = G(io_dce_tx_sptr) ;
	}
	G(io_dce_tx_wptr) = wptr ;
}

/****************************************************************
Routine : io_fax_sync_dte_to_dce
Description :
	Transmit data from the dte queue to the dce fifo.
	First check if space is available to write to the dce fifo.
	Removes all undefined character pairs begining with <DLE>
	Recognize <DLE><DLE> and reinsert a single <DLE> in its place
	Recognize <DLE><ETX> as the stream terminator. (Class 2 only)
	Recognize <DLE><SUB> and reinsert two <DLE>s in its place (Class 2.0 only)
	Recognize <DLE><ppm> as the stream terminator (Class 2.0 only)
Parameters in :
	none
Parameters out :
	TRUE		-	end of data - detected <DLE><ETX> (Class 2)
	TRUE     -  end of data - detected <DLE><ppm> (Class 2.0)
	FALSE		-	if more data is available to transmit to the dce
*****************************************************************/
byte io_fax_sync_dte_to_dce ( void )
{
	word  count ;
	byte  rx_ch, end_of_data, i ;
	word  *wptr ;

	count = io_get_dce_tx_count () ;
	if ( count == 0 )
		return ( FALSE ) ;		/* dce fifo is full */

	wptr = G(io_dce_tx_wptr) ;
	end_of_data = FALSE ;
	while ( (end_of_data == FALSE) && (count > 36) &&
				!IS_DTE_RX_EMPTY() )
	{
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)  
		if (CLASS_2_OR_20)         	 // Enforce Minimum Scan Line Time for Class 2/2.0 FAX
		{
			rx_ch = *I(io_dte_rx_rptr);    // Read character, but don't update pointer

			if (chk_mslt (rx_ch))		 // EOL Received and MSLT not met?
				break;					    // Stop until fill chars inserted (in iofax_c2.c)
		}
#endif
		rx_ch = *I(io_dte_rx_rptr);

		if ( (I(io_dte_rx_rptr) + 1) >= I(io_dte_rx_eptr) )
			I(io_dte_rx_rptr) = I(io_dte_rx_sptr);

		else
			I(io_dte_rx_rptr)++;

		if ( rx_ch == DLE )		// got a DLE...
		{
			if ( G(io_dte_rx_last_ch) == DLE )	// process <DLE><DLE>
			{
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
				if ( CLASS_2_OR_20 &&          	   // Class 2/20 FAX?
					 (G(c2p.dbf) & 0x1000) )         // Reverse bit order in phase C?
					*wptr++ = 0x08;	         // Reverse-bit-order DLE
				else
#endif
					*wptr++ = DLE ;

				if ( wptr >= G(io_dce_tx_eptr) )
					wptr = G(io_dce_tx_sptr) ;
				--count ;
				G(io_dte_rx_last_ch) = 0xff ;
			}
			else				// process first <DLE> in pair
			{
				G(io_dte_rx_last_ch) = DLE ;
			}
		}
		else if( DLE == G(io_dte_rx_last_ch) )	// process <DLE><command>
		{
			if( rx_ch == ETX
#if defined(IWF_FAX) || defined(CLASS20_FAX)
				|| rx_ch == DLE_MPS
				|| rx_ch == DLE_EOM
				|| rx_ch == DLE_EOP
#endif
				)
			{

#if defined(IWF_FAX) || defined(CLASS20_FAX)
					// Class 2.0/2.1?
					// Conversion: MPS:0x2C->0; EOM:0x3B->1; EOP:0x2E->2
				if (G(c2p.fclass) == 0x20)
					G(c2p.fet) = (rx_ch >> (rx_ch & 1)) & 3;
#endif
				end_of_data = TRUE ;
				// transmit extra flags to make sure data is sent
				// from the data pump - in sync mode 0's is the fill char
				for( i = 0 ; i < 36 ; i++ )
				{
					*wptr++ = 0x00 ;
					if ( wptr >= G(io_dce_tx_eptr) )
						wptr = G(io_dce_tx_sptr) ;
				}
			}
			else if( rx_ch == DLE_SUB ) // DLE-SUB detected?
			{
				byte d, i = 2;

#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
				if ( CLASS_2_OR_20 &&			// Class 2/20 FAX?
				 	(G(c2p.dbf) & 0x1000) )	// Reverse bit order in phase C?
					d = 0x08;				// Reverse-bit-order DLE
				else
#endif
					d = DLE;               // Write normal DLE

				while (i--)
				{
					*wptr++ = d;                   // Load data into buffer
					--count;                       // Decrement DCE space available

					if ( wptr >= G(io_dce_tx_eptr) )  // End of buffer?
						wptr = G(io_dce_tx_sptr) ;     // Wrap around to beginning
				}

			}
			else if( rx_ch == DLE_SUBXON )	// sub one 0x11 (XON) pattern
			{
					*wptr++ = XON;
					--count;
					if ( wptr >= G(io_dce_tx_eptr) )  // End of buffer?
						wptr = G(io_dce_tx_sptr) ;     // Wrap around to beginning
			}
			else if( rx_ch == DLE_SUBXOFF )	// sub one 0x13 (XOFF) pattern
			{
					*wptr++ = XOFF;
					--count;
					if ( wptr >= G(io_dce_tx_eptr) )  // End of buffer?
						wptr = G(io_dce_tx_sptr) ;     // Wrap around to beginning
			}
			else
			{
#if defined(Z80_DEBUG_PRINT)
				x_debug_msg("iofax-bad DLE escape=") ;
				sendHexByte( rx_ch ); sendCrLf();
#endif
			}

			G(io_dte_rx_last_ch) = 0;	// done processing this <DLE><command>
		}
		else	// neither rx_ch nor last_ch is DLE
		{
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)  
			if (CLASS_2_OR_20 &&               // Class 2/2.0 FAX?
				 (G(c2p.dbf) & 0x1000) )          // Reverse bit order in phase C?
				*wptr++ = rev_bits(rx_ch);     // Reverse-bit-order byte
			else
#endif
				*wptr++ = (word) rx_ch ;

			if ( wptr >= G(io_dce_tx_eptr) )
				wptr = G(io_dce_tx_sptr) ;

			--count ;

			G(io_dte_rx_last_ch) = rx_ch;    // Save as last character
		}
		G(io_dce_tx_wptr) = wptr ;
	}	// while()

	io_start_dce_transmit () ;

	return ( end_of_data ) ;
}
#endif  

#ifndef CS_MODEM   

/****************************************************************
Routine : io_fax_sync_dce_to_dte
Description :
	Transmit data from the dce fifo to the dte transmit queue.
	First check if space is available to write to the dte transmit queue.
Parameters in :
	none
Parameters out :
	TRUE		-	if more data is available in the dce receive fifo.
	FALSE		-	if no more data is available in dce fifo or
					dte transmit queue is full.
*****************************************************************/
byte io_fax_sync_dce_to_dte ( void )
{
	word  count ;
	byte  rx_ch ;
	byte  *ptr ;

	count = io_get_dte_tx_count() ;
	ptr = (byte *) I(io_dte_tx_wptr);

	while ( ( count > 2 ) && ( G(io_dce_rx_rptr) != G(io_dce_rx_wptr) ) )
	{
		rx_ch = (byte)(*G(io_dce_rx_rptr)) ;                // Read byte

		if ( (G(io_dce_rx_rptr) + 1) >= G(io_dce_rx_eptr) ) // End of buffer? (Prevent ISR from seeing invalid pointer)
			G(io_dce_rx_rptr) = G(io_dce_rx_sptr) ;           // Wrap to beginning

		else                                                // Not end of buffer
			G(io_dce_rx_rptr)++;                              // Point to next location

		if ( rx_ch == DLE
#if defined( CLASS1_DC_SUB )
				|| rx_ch == XON || rx_ch == XOFF	// sub XON/XOFFs
#endif
		)
		{
			*ptr++ = DLE ;
			if ( ptr >= I(io_dte_tx_eptr) )
				ptr = (byte *) I(io_dte_tx_sptr);
			--count ;
		}

#if defined( CLASS1_DC_SUB )
		if( rx_ch == XON || rx_ch == XOFF )
			rx_ch |= 0x50;	// convert XON/XOFF into SUB_XON/SUB_XOFF
#endif

		*ptr++ = rx_ch ;
		if ( ptr >= I(io_dte_tx_eptr) )
			ptr = (byte *) I(io_dte_tx_sptr);
		--count ;
	}
	I(io_dte_tx_wptr) = ptr ;

	if ( G(io_dce_rx_rptr) == G(io_dce_rx_wptr) )
		return ( FALSE ) ;		// no more data in dce fifo
	else
		return ( TRUE ) ;
}
#endif 

#if !defined(CS_MODEM) || defined (CLASS2_FAX) 
/****************************************************************
Routine : io_fax_hdlc_dce_to_buf
Description :
	Transmit data from the dce fifo to a holding buf.
Parameters in :
	io_fax_buf[] base address
	*io_hdlc_byte_count - byte count variable address
Parameters out :
	TRUE		-	if a good frame is received 
	FALSE		-	otherwise
Revision History :
	Initials	Date		Change
	J.S.Xu		10/23/92	Initial
	J.S.Xu		11/08/93	Tx data to buf instead of directly to dte,
							for ECM fax.
	JMG			02/24/99	Added full-duplex flexibility.
*****************************************************************/
byte io_fax_hdlc_dce_to_buf(word *io_fax_buf, word *io_hdlc_byte_count)
{
	word rx_ch ;

	while ( G(io_dce_rx_rptr) != G(io_dce_rx_wptr) )
	{
		rx_ch = *G(io_dce_rx_rptr);                          // Read word

		if ( (G(io_dce_rx_rptr) + 1) >= G(io_dce_rx_eptr) )  // End of buffer? (Prevent ISR from seeing invalid pointer)
			G(io_dce_rx_rptr) = G(io_dce_rx_sptr) ;            // Wrap to beginning

		else                                                 // Not end of buffer
    	G(io_dce_rx_rptr)++;                               // Point to next location

		if ( *io_hdlc_byte_count >= (2 * V42bisP1) ||
			 ( rx_ch & HDLC_START_OF_FRAME ) )
		{
			*io_hdlc_byte_count = 0 ;
			G(io_crc) = 0xffff ;		// initalize crc
		}

			// do required DLE-subs
		*io_hdlc_byte_count = io_sub_into_buf( rx_ch, io_fax_buf, *io_hdlc_byte_count);

		io_compute_crc ( (byte) rx_ch ) ;
		if ( rx_ch & HDLC_END_OF_FRAME ) 
		{
			byte frm_stat = TRUE;  // No CRC error

#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
			send_fhx(io_fax_buf, *io_hdlc_byte_count, 'R');  // Display +FHR: is enabled

	#if defined (V34_FAX)
			if( (rx_ch & HDLC_CRC_ERROR) && CLASS_2_OR_20 && (G(x_fax_v34mode) != NON_V34) )  // CRC error using V.34, Class 2/2.0/2.1 interface?
			{
//				x_debug_msg("iofax - HDLC crc error detected") ;
				*io_hdlc_byte_count = 0 ;
				return ( FALSE ) ;        // V.34, Class 2.x should time out for FCS errors
			}
	#endif 
#endif
			G(io_crc) = ~G(io_crc) ;		// 1's complement of crc
				// least significant byte of crc - FCS
				// do required DLE-subs
			*io_hdlc_byte_count =
				io_sub_into_buf( (word) (G(io_crc) & 0x00FF),
							io_fax_buf, *io_hdlc_byte_count);

				// most significant byte of crc - FCS
			G(io_crc) = (byte) (G(io_crc) >> 8) ;
				// do required DLE-subs
			*io_hdlc_byte_count =
				io_sub_into_buf( G(io_crc), io_fax_buf, *io_hdlc_byte_count);

#if defined(V34_FAX)
			if (G(x_fax_v34mode) == NON_V34)  // Class 1, non-V.34?
#endif
			{
				if (rx_ch & HDLC_CRC_ERROR)  // CRC error?
				{
					frm_stat++;  // Indicate CRC error
//					x_debug_msg ("iofax - CRC error");
				}

				rx_ch = rx_ch & ~HDLC_CRC_ERROR;  // Always terminate with a DLE-ETX for non-V.34
			}

				// tack on <DLE><ETX> or <DLE><ferr> to end frame.
			io_fax_buf[ (*io_hdlc_byte_count)++ ] = DLE ;
			if( rx_ch & HDLC_CRC_ERROR )	// bad FCS for frame
			{
				io_fax_buf[ (*io_hdlc_byte_count)++ ] = FERR ;
				sendDumbChar('C');
			}
			else							// good FCS
			{
				io_fax_buf[ (*io_hdlc_byte_count)++ ] = ETX ;
			}

			return (frm_stat);  // Return frame status
		} // if(EOF)
	} // while(space in buffer)
	return( FALSE );
} // io_fax_hdlc_dce_to_buf()
#endif  

#ifndef CS_MODEM  
/****************************************************************
Routine : io_fax_hdlc_buf_to_dte
Description :
	Transmit data from the buffer to the dte fifo.
	First check if space is available to write to the dte fifo.
Parameters in :
	io_fax_buf[] base address
	byte count pointer
Parameters out :
	TRUE		-	if data is written to the transmit dte fifo 
	FALSE		-	if no space available in dce fifo.
*****************************************************************/
byte io_fax_hdlc_buf_to_dte ( word * io_fax_buf, word * io_hdlc_byte_count)
{
#ifdef FRAME_DEB_PRINT
	word i ;
#endif

	if ( io_get_dte_tx_count() >= *io_hdlc_byte_count )
	{
		if ( *io_hdlc_byte_count ) 
		{
			io_write_dte_fifo ( *io_hdlc_byte_count, io_fax_buf ) ;

#ifdef FRAME_DEB_PRINT
			sendDumbChar( 'R' ); sendDumbChar( '(' );
			sendHexWord( *io_hdlc_byte_count );
			sendDumbChar( ')' ); sendDumbChar( ':' );
			if(
#if defined(V34_FAX)
			CONTROL_CHANNEL == G(x_fax_v34channel) || // only print CC...
#endif
				MR_300 == G(x_fax_rate) ||
				*io_hdlc_byte_count < 20 )			// and small frames.
			{
				for( i = 0 ; i < *io_hdlc_byte_count ; ++i )
				{
					sendDumbChar(' ');
					sendHexWord( io_fax_buf[i]);
				}
			}
			sendDumbChar(0x0A);
			sendDumbChar(0x0D);
#endif	// FRAME_DEB_PRINT

			*io_hdlc_byte_count = 0 ;
		}
		return ( TRUE ) ;
	}
	else
		return (FALSE);
} // io_fax_hdlc_buf_to_dte()
#endif  

#if !defined(CS_MODEM) || defined (CLASS2_FAX) 
/****************************************************************
Routine : io_fax_init
Description :
	init routine for fax.
Parameters in :
	none
Parameters out :
	none
*****************************************************************/
void io_fax_init ( FAX_STATE state )
{
	G(io_hdlc_byte_count) = 0 ;
	G(io_fax_buf) = (void *) IO_FAX_BUF_START; // use V.42bis buffer
	G(io_dte_rx_last_ch) = 0xff ;
	G(io_dce_tx_rptr_old) = G(io_dce_tx_rptr) ;
	G(io_timer) = x_current_time() ;

#ifdef V34_FAX
		// use LAPM Receive Queue split between transmit and receive.
		// Use caution as the frame handling is word-wide, while the LAPM
		// buffers are byte-wide.
	G(dte2dce_buf) = (word *) (void *) &LRQ(0);
	G(dce2dte_buf) = G(dte2dce_buf) + V34FAX_MAX_FRAME_SIZE;
	G(tx_frame_in_buf) = G(rx_frame_in_buf) = FALSE;
	G(io_hdlc_tx_count) = G(io_hdlc_rx_count) = 0;
#endif

	switch ( state )
	{
		case FAX_TX:
			io_fax_sync_tx_ini () ;
			G(io_fax_state) = IO_FAX_TX ;
			break;

		case FAX_TX_HDLC:
			G(io_fax_state) = IO_FAX_TX_HDLC_BUF ;
			break;

		case FAX_RX:
			G(io_fax_state) = IO_FAX_RX ;
			break;

		case FAX_RX_HDLC:
			G(io_fax_state) = IO_FAX_RX_HDLC_BUF ;
			break;

		case FAX_RX_START :
			G(io_fax_state) = IO_FAX_RX_START ;
			break ;

#if defined(V34_FAX)
		case V34FAX_CCSTART:
			G(io_fax_state) = IO_V34FAX_CCSTART ;
			break;

		case V34FAX_PRISTART:
			if( V34_SOURCE == G(x_fax_v34mode) )
			{		// delay source 200ms (T.4 A.3.1)
				G(io_fax_state) = IO_V34FAX_PRI_DELAY;
				G(io_timer) = x_current_time();
			}
			else
			{		// receiver starts immediately
				G(io_fax_state) = IO_V34FAX_PRISTART;
			}
			break;

		case V34FAX_EOT:	// issue <DLE><EOT> and idle fax
			G(x_fax_v34channel) = NO_ACTIVE_CHANNEL;
			G(io_fax_state) = IO_V34FAX_FRAMEWAIT;
			break;
#endif // V34_FAX

		default :
			G(io_fax_state) = IO_FAX_IDLE ;
			break ;
	}
}
#endif 

#ifndef CS_MODEM  
/****************************************************************
Routine : io_fax_inactivity_check
Description :
	Monitor data from the DTE during a transmit operation to see
	if 5 seconds of no data have elapsed since the last CONNECT response.
Parameters in :
	none
Parameters out :
	none
*****************************************************************/
void io_fax_inactivity_check ( void )
{
	if ( G(io_dce_tx_rptr_old) == G(io_dce_tx_rptr) )
	{
		if ( x_elapsed_time(G(io_timer)) >= SECOND5 )
		{
			x_debug_msg("IO_FAX_TX - 5 second time out") ;
			x_send_mail (FAX_ERROR, AT_TASK, NULL, 0);
			io_init_dce_tx_fifo () ;	// init dce transmit fifo
			io_init_dce_rx_fifo () ;	// init dce receive  fifo
			G(io_fax_state) = IO_FAX_IDLE ;
		}
	}
	else
	{
		G(io_dce_tx_rptr_old) = G(io_dce_tx_rptr) ;
		G(io_timer) = x_current_time() ;
	}
}

/****************************************************************
Routine : io_fax_monitor_dte
Description :
	Monitor data from the DTE during a receive operation to see
	if the DTE wishes to return to command mode.
Parameters in :
	none
Parameters out :
	none
*****************************************************************/
void io_fax_monitor_dte ( void )
{
	byte dte_rx_char ;

	if ( io_get_dte_rx_char ( &dte_rx_char ) )
	{
		io_put_dte_tx_char (DLE) ;
		io_put_dte_tx_char (ETX) ;
		G(io_fax_state) = IO_FAX_IDLE ;
		x_send_mail ( AT_OK, AT_TASK, NULL, 0 ) ;
		x_send_mail ( FAX_DROP_CARRIER, DP_TASK, NULL, 0 ) ;
	}
}
/****************************************************************
Routine : io_fax_background
Description :
	The periodic routine for fax.
Parameters in :
	none
Parameters out :
	FALSE - if fax state is in IDLE 
	TRUE  - if background task is still processing data
*****************************************************************/
byte io_fax_background ( void )
{
	switch ( G(io_fax_state) )
	{
		case IO_FAX_RX_START :
			io_fax_monitor_dte () ;
			break ;

		case IO_FAX_RX:
			io_fax_sync_dce_to_dte () ;
			io_fax_monitor_dte () ;
			break;

		case IO_FAX_RX_END:
			io_fax_sync_dce_to_dte () ;
			io_put_dte_tx_char (DLE) ;
			io_put_dte_tx_char (ETX) ;
			G(io_fax_state) = IO_FAX_IDLE ;
			x_debug_msg ( "IO - disconnect" ) ;
			x_send_mail ( IO_AT_DISCONNECT, AT_TASK, NULL, 0 ) ;
			break;

		case IO_FAX_RX_HDLC_BUF:
			switch ( io_fax_hdlc_dce_to_buf( G(io_fax_buf), &G(io_hdlc_byte_count)) )
			{
				case TRUE:   // Frame received with no CRC error
					G(io_fax_state) = IO_FAX_RX_HDLC_DTE ;
					G(dp_fax_status) = G(dp_fax_status) | 0x08;  // Wait for another +FRH command
					break;

				case TRUE+1: // Frame received with CRC error
					G(io_fax_state) = IO_FAX_RX_HDLC_DTE_ERR;
					G(dp_fax_status) = G(dp_fax_status) | 0x08;  // Wait for another +FRH command
					break;
			}

			io_fax_monitor_dte () ;
			break;

		case IO_FAX_RX_HDLC_DTE_ERR:
		case IO_FAX_RX_HDLC_DTE :
			if(io_fax_hdlc_buf_to_dte(G(io_fax_buf), &G(io_hdlc_byte_count)) == TRUE )
			{
				if (G(io_fax_state) == IO_FAX_RX_HDLC_DTE)
					x_send_mail (FAX_END_OF_DATA, AT_TASK, NULL, 0) ;

				else
					x_send_mail (AT_ERROR, AT_TASK, NULL, 0) ;  // Send "ERROR"

				G(io_fax_state) = IO_FAX_IDLE ;
			}

			io_fax_monitor_dte () ;
			break ;

		case IO_FAX_TX_HDLC_BUF :
			if( io_fax_hdlc_dte_to_buf( G(io_fax_buf), &G(io_hdlc_byte_count) ) == TRUE )
			{
				G(io_fax_state) = IO_FAX_TX_HDLC_DCE ;
			}
			else if ( IS_DTE_RX_EMPTY() )
			{
				if ( x_elapsed_time(G(io_timer)) >= SECOND5 )
				{
					x_debug_msg("iofax - hdlc 5 seconds time out") ;
					x_send_mail ( FAX_ERROR, AT_TASK, NULL, 0 ) ;
					G(io_fax_state) = IO_FAX_IDLE ;
				}
			}
			else
				G(io_timer) = x_current_time() ;
			break ;

		case IO_FAX_TX_HDLC_DCE :
			if( io_fax_hdlc_buf_to_dce( G(io_fax_buf),&G(io_hdlc_byte_count)) == TRUE )
			{
				// if final frame or a NULL frame, cease transmitting
				if ( (G(io_fax_buf) [1] & FAX_HDLC_FINAL_FRAME) ||
						 (G(io_hdlc_byte_count) == 0) ) 
				{
					G(io_fax_state) = IO_FAX_FIFO_EMPTY ;
					G(io_timer) = x_current_time() ;
				}
				else
				{
					x_send_mail (IO_AT_CONNECT, AT_TASK, NULL, 0);
					G(io_fax_state) = IO_FAX_TX_HDLC_BUF ;
					G(io_timer) = x_current_time() ;
					G(io_hdlc_byte_count) = 0 ;
				}
			}
			break ;

		case IO_FAX_TX:
			if ( io_fax_sync_dte_to_dce() == TRUE )
			{
				G(io_fax_state) = IO_FAX_FIFO_EMPTY ;
				G(io_timer) = x_current_time () ;
			}
			io_fax_inactivity_check () ;
			break ;

		case IO_FAX_FIFO_EMPTY :
			if ( io_dce_tx_fifo_empty () == TRUE )
			{
				x_send_mail ( FAX_END_OF_DATA, AT_TASK, NULL, 0 ) ;
				G(io_fax_state) = IO_FAX_IDLE ;
				G(io_hdlc_byte_count) = 0 ;
			}
			io_fax_inactivity_check () ;
			break ;

#ifdef V34_FAX // {
		case IO_V34FAX_CCSTART :	// control channel started...
				// source modem sends <DLE><pri> on success (T.31A1/B.8.4)
				// (ans sends on attempt in DETECT1S)
			if( V34_SOURCE == G(x_fax_v34mode) )
			{
				io_put_dte_tx_char( DLE );
				io_put_dte_tx_char( CTRL_V34 );
			}
				// send <DLE><prate> to DTE
			io_put_dte_tx_char( DLE );
			G(x_fax_rate) = getActualPRate() ;	// get rate....
			io_put_dte_tx_char( G(x_fax_rate) | 0x70 );
			G(x_fax_rate) += MR_2400 ;			// normalize 0-13 rate.
				// send <DLE><crate> to DTE
			io_put_dte_tx_char( DLE );
			io_put_dte_tx_char( C12_V34 );	// as we only support 1200bps,
											// this response is hardcoded.

			G(io_timer) = x_current_time();			// debug for DETECT1S
			G(io_fax_state) = IO_V34FAX_ONLINE ;	// go online
			break;

		case IO_V34FAX_PRI_DELAY :	// primary channel source delay. (T.4 A.3.1)
			if( x_elapsed_time( G(io_timer) ) > MS200 )
			{
				G(io_fax_state) = IO_V34FAX_PRISTART;
			}
			break;

		case IO_V34FAX_PRISTART :	// primary channel started...
				// source modem sends <DLE><pri> on success (T.31A1/B.8.4)
				// (ans sends on attempt in DETECT1S)
			if( V34_SOURCE == G(x_fax_v34mode) )
			{
				io_put_dte_tx_char( DLE );
				io_put_dte_tx_char( PRI_V34 );
			}
				// send <DLE><prate>
			io_put_dte_tx_char( DLE );
			G(x_fax_rate) = getActualPRate() ;	// get rate....
			io_put_dte_tx_char( G(x_fax_rate) | 0x70 );
			G(x_fax_rate) += MR_2400 ;			// normalize 0-13 rate.

			G(io_fax_state) = IO_V34FAX_ONLINE ;	// go online
			break;

		case IO_V34FAX_ONLINE :
				// Check for loss of carrier.
				// Control Channel will go to command mode (EOT).
				// Primary Channel will attempt to start Control Channel.
			if( !( dp_read_dsp_ram(0x008E) & 0x0002 ) )	// Carrier Detect
			{
				if( G(x_fax_v34channel) == CONTROL_CHANNEL )
				{		// CC dropped.  End of Trans.
						// Return to command mode.
					x_debug_msg("CC Drop");
					G(x_fax_v34channel) = NO_ACTIVE_CHANNEL;
					G(io_fax_state) = IO_V34FAX_FRAMEWAIT;
				}
				else if( V34_RECEIVE == G(x_fax_v34mode) ) // && PRI CHAN
				{		// Rcv. Pri Dropped.  Indicates channel switch.
						// Begin channel switch to CC.
					x_debug_msg("PC Drop");
					x_send_mail(FAXV34_DETECT1S, DP_TASK, NULL, 0);
					G(io_fax_state) = IO_V34FAX_WAIT;
				}
			}

				// -----------------------------------
				// check for DTE to DCE frames (Transmit)
				// dte2dce_buf[] is used for this tranfer direction
				// -----------------------------------
			if( !G(tx_frame_in_buf) )
			{
					// returns TRUE if a frame is written into buffer.
				G(tx_frame_in_buf) =
					io_fax_hdlc_dte_to_buf(G(dte2dce_buf), &G(io_hdlc_tx_count));
			}
			else	// there is a frame in the DTE-to-DCE buffer...
			{
				G(tx_frame_in_buf) =
					io_fax_hdlc_buf_to_dce(G(dte2dce_buf), &G(io_hdlc_tx_count))
									? FALSE : TRUE;
			}

				// -----------------------------------
				// check for DCE to DTE frames (Receive)
				// dce2dte_buf[] is used for this tranfer direction
				// -----------------------------------
			if( !G(rx_frame_in_buf) )
			{
					// returns TRUE if a frame is written into buffer.
				G(rx_frame_in_buf) =
					io_fax_hdlc_dce_to_buf(G(dce2dte_buf), &G(io_hdlc_rx_count));
			}
			else	// there is a frame in the DCE-to-DTE buffer...
			{
				G(rx_frame_in_buf) =
					io_fax_hdlc_buf_to_dte(G(dce2dte_buf), &G(io_hdlc_rx_count))
							? FALSE : TRUE;
			}

				// Monitor 1s detect flag.
				// Only check for 1s detect if frames have been
				// processed (empty frame and DCE-rcv buffers).
			if(	!G(rx_frame_in_buf) && !G(tx_frame_in_buf)
				&& G(io_dce_rx_rptr) == G(io_dce_rx_wptr)
				&& dp_read_dsp_ram( 0x1fff )
			  )
			{
				if( V34_RECEIVE == G(x_fax_v34mode) )
				{		// Receive modem detects channel switch.
					x_debug_msg("goto DETECT1S");
					x_send_mail(FAXV34_DETECT1S, DP_TASK, NULL, 0);
					G(io_fax_state) = IO_V34FAX_WAIT;
				}
				else if( V34_SOURCE == G(x_fax_v34mode) )
				{		// source modem detects turnaround poll.
					x_debug_msg("TurnAround");
					G(x_fax_v34channel) = NO_ACTIVE_CHANNEL;
					G(io_fax_state) = IO_V34FAX_FRAMEWAIT;
				}
				dp_write_dsp_ram( 0x1fff, 0 );		// clear flag
			} // if(1s detect)

			break;

			case IO_V34FAX_FRAMEWAIT :	// wait for DCE buf to empty
				if( io_dce_tx_fifo_empty () == TRUE
					|| x_elapsed_time( G(io_timer) ) > SECOND3 )
				{
					G(io_fax_state) = IO_V34FAX_POSTDELAY;
					G(io_timer) = x_current_time();
				}
				break;

			case IO_V34FAX_POSTDELAY :	// delay before dropping channel
				if( x_elapsed_time( G(io_timer) ) > 20 )
				{
					if( NO_ACTIVE_CHANNEL == G(x_fax_v34channel) )
					{
							// stop carrier transmission
						dp_fax_modem_idle_cmd();
							// issue <DLE><EOT> and "OK" to DTE
						io_put_dte_tx_char(DLE) ;
						io_put_dte_tx_char(EOT_V34) ;
						x_send_mail( AT_OK, AT_TASK, NULL, 0 ) ;
						G(io_fax_state) = IO_FAX_IDLE ; // enter command mode
														// stay on-line
					}
					else	// switching to Control or Primary Channel
					{
							// kick off dp_state to start channel switch
							// x_fax_v34channel is already set to
							// correct channel for dpmain.
						x_send_mail(FAXV34_SEND1S, DP_TASK, NULL, 0);
							// goto V34 fax wait state
						G(io_fax_state) = IO_V34FAX_WAIT;
					}
				}
				break;

			case IO_V34FAX_WAIT :	// wait for channels or disconnect
				if( x_elapsed_time( G(io_timer) ) > 8000 )
				{
					x_debug_msg("Fax Wait...");	// debug
					G(io_timer) = x_current_time();
				}
			break;

#endif // } V34_FAX

	} // switch(io_fax_state)

	if ( G(io_fax_state) == IO_FAX_IDLE )
		return ( FALSE ) ;
	else 
		return ( TRUE ) ;
}
#endif   // #ifndef CS_MODEM

#if !defined(CS_MODEM) || defined (CLASS2_FAX)
/****************************************************************
Routine : io_fax_disconnect
Description :
	Called when carrier is gone and the DCE Rx FIFO is empty.
	For sync receive, continue to read the data in the fifo.
*****************************************************************/
void io_fax_disconnect ( void )
{
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
	if (CLASS_2_OR_20)  // Class 2.x interface?
		return;           // Skip this function
#endif

	if ( G(x_fax_state) == FAX_RX )       // Not receiving HDLC-framed data?
		G(io_fax_state) = IO_FAX_RX_END ;

	else   // Receiving HDLC frames
	{
		if (G(io_fax_state) != IO_FAX_IDLE)  // Executing a AT-command?
		{
			io_put_dte_tx_char (DLE) ;  // Signal host to exit data mode
			io_put_dte_tx_char (ETX) ;
		}

		G(io_fax_state) = IO_FAX_IDLE ;                       // Wait for next command
		x_send_mail ( IO_AT_DISCONNECT, AT_TASK, NULL, 0 ) ;  // Send "No Carrier" resposne
	}
}
#endif

#if defined (CLASS2_FAX) || defined (CLASS20_FAX)

#define ORG14 36    // Note: Also defined in iofax_c2.c.  Must be the same!

// -------------------------------------- //
// Check if Minimum Scan Line Time (MSLT) //
// is met when an EOL is detected         //
// -------------------------------------- //
/*
	G(c2_var1): Number of bytes to send to meet MSLT
	G(c2_var2): Counts the number of consecutive zero bits
	G(c2_var3): Stores number of zero bytes to add to meet MSLT
	G(c2_var4): Counts the number of bytes since last EOL

	Note: The input data to this function must be filtered in similar
	manner described in function pre_scan_tx_data.
*/

byte chk_mslt (byte rx_ch)
{
	byte i, r = 0;
	byte loop = 1;

#if defined(IWF_FAX) || defined(CLASS20_FAX)
	if (G(c2p.sbf) & FND)                  // Sending non-standard data?
		return (0);                      // Don't check MSLT for non-standard data
#endif

	if (G(c2_mslt_last) == DLE)               // Was last byte a DLE?
	{
		if (dle_filter (&rx_ch, &loop))  // DLE filter, End of page?
			return (0);                   // Stop here, let calling function continue

		G(c2_mslt_last) = 0;                   // Start DLE character pair checking all over
	}

	else if (rx_ch == DLE)              // Is current byte a DLE?
	{
		G(c2_mslt_last) = rx_ch;               // Save first part of DLE character pair
		loop = 0;                        // Don't process bits yet
	}

	else                                // Normal T.4 data
		G(c2_mslt_last) = rx_ch;               // Update last byte

	while (loop--)                      // Process 0, 1, or 2 bytes...
	{
		for (i = 1; i; i = i << 1)
		{
			if (rx_ch & i)		            // Bit is a 1?
			{
				if (G(c2_var2) >= 11)            // Preceeded by at least 11 0's (EOL)?
				{
					G(c2_var2) = 0;               // Reset zero count
					G(c2_ps_eol)--;               // Decrement pre-scan EOL count

					if (G(c2_var4) <= 2)          // Consecutive EOLs?
					{
						G(c2_var4) = 0;            // Reset byte count

						if (G(c2p.fclass) == 2)      // Using Class 2 FAX?
						{
							read_dte_fifo (); // Dump character -- Don't pass consecutive EOLs
							r = 1;			   // Finish this byte, but cause calling function to exit
						}
	#if defined(IWF_FAX) || defined(CLASS20_FAX)
						else if ( (G(c2_ps_eol) <= 1) && !(G(c2rf.flag) & END_OF_PAGE) )  // Only 1 EOL and Not end of page?
							return (1);                                      // Wait for another EOL from DTE
	#endif
					}

					else if (G(c2_var4) >= G(c2_var1))  // Has MSLT been met?
					{
						G(c2_var4) = 0;            // Reset the byte count

						if ( (G(c2_ps_eol) <= 1) && !(G(c2rf.flag) & END_OF_PAGE) )  // Only 1 EOL and Not end of page?
							return (1);                                 // Wait for another EOL from DTE
					}

					else                      // Insert zeros to meet MSLT
					{
						G(c2_mslt_last) = G(io_dte_rx_last_ch); // Restore last character (For EOL in middle of DLE-DLE or DLE-SUB)
						G(c2_var3) = G(c2_var1) - G(c2_var4);    // Calculate number of byte to meet MSLT
						G(c2_var4) = 0;              // Reset byte count
						G(c2_sequence_ptr) = ORG14;  // Insert fill characters to meet MSLT
						return (1);			     // Indicate delay for MSLT to calling function
					}
				}

				else                    // Not preceeded by at least 11 zeros
					G(c2_var2) = 0;            // Reset the zero count
			}

			else                     // Bit is zero
				G(c2_var2)++;					 // Update zero count
		}

		G(c2_var4)++;							 // Update byte count by one
	}

	if (G(c2_var2) > 11)					 // Waiting for a 1 bit to complete EOL?
		G(c2_var2) = 11;					 // Prevent overflows

	return (r);						 // Indicate if delay for MSLT
}
#endif
