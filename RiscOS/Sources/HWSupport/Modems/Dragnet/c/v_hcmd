/*name and version number:@(#)v_hcmd.c	1.38*/
/*date of get: 		  09/06/00 16:59:29*/
/*date of delta:	  03/27/00 21:49:15*/
/*****************************************************************************
** File        : v_hcmd.c                                                  *
** Version     : 3.0                                                         *
**---------------------------------------------------------------------------*
** Description :                                                             *
**   Provides a command interface between the Z80 and 2181 (host).
**                                                                           *
**     Function Name            | Access  | Summary                          *
**  ----------------------------+---------+--------------------------------- *
**                                                                           *
**---------------------------------------------------------------------------*
**                               HISTORY                                     *
** Date            Ver   Dev  Comments                                       *
** 15th Oct  1998  1.0   ELS  Initial Revision                               *
**                                                                           *
** 16th Oct  1998  1.1   RGT  Modify DSP transmit interrupt logic state -    *
**                            exchanger (exchange.c) will enable DSP Tx intr *
**                            when sufficient data has been buffered up.     *
**                                                                           *
** 31st Oct  1998  1.2   RGT  Implemented new command interface which has    *
**                            no blocking characteristics and can buffer up  *
**                            and commands until the hardware interface is   *
**                            ready. It also has error detection and recovery*
**                            if the 2181 fails to ACK a Z80 command. Also   *
**                            replaced <header.h> with <host_cmd.h> and got  *
**                            rid of all calls to the ftrace function.       *
**                                                                           *
**  2nd Nov  1998  1.3   RGT  Modification made to call setup messaging to   *
**                            prevent a 486 problem on the PM4. No voice     *
**                            transfer was occuring with just a 1 second     *
**                            delay between states NEGOTIATE and LINE_SPEED. *
**                            Increasing this delay to 4 secs has temporarily*
**                            provided voice transfer on the PM4.            *
**                                                                           *
** 16th Nov  1998  1.4   RGT  Quick hack to put in A-LAW U-LAW parameter     *
**                            extract from answer & originate call commands  *
**                            and send corresponding SELECT_COMPANDER command*
**                            to the DSP.                                    *
**                                                                           *
**[Release 2]----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                       *
** 19th Jan  1999  1.5   RGT  Small mods to call setup handling for new arch.*
**                            Exchanger now enables DSP and examines codec   *
**                            type, a call config structure is used for setup*
**                            information.                                   *
**                                                                           *
** 16th Feb  1999  1.6   RGT  Stack efficiency improvements in answer and    *
**                            originate call command handlers. Also mods in  *
**                            these functions for the new call setup arch.   *
**                            Frms/pkt is no longer passed in this message-  *
**                            it's negotiated. Also, compander & echo cancel *
**                            config is done in these routines rather than   *
**                            in the exchanger. There's a new command handler*
**                            for dealing with negotiated parameters - this  *
**                            is done in a new function.                     *
**                                                                           *
**[Re-architected: Code now meets desired standard]--------------------------*
** 19th Apr  1999  2.0   RGT  Re-architected. Basically re-wrote the receive *
**                            subsystem with a parser and made things a fair *
**                            bit safer. Also added in new DTMF dial string  *
**                            command for T1 CAS.                            *
**                                                                           *
**[Release 3]----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                       *
**  2nd Sep  1999  3.0    JA  CS-4 multi-instance integration                *
**                                                                           *
**[Release 4]----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                       *
**  16th Dec 1999  4.0    JA  Reimplemented for Ascend Voip Interface        *
**                                                                           *
******************************************************************************/
#include <string.h>
#include <v_glob.h>
#include <v_task.h>
#include "v_defs.h"
#include "sa_t1.h"
#include "sa_admin.h"

static void v_start_tone( VGLOB *vglob_ptr, struct V_DTMF_DIGIT_INFO *digit_info );
static void v_enable_dtmf_detection( VGLOB *vglob_ptr );
static void v_disable_dtmf_detection( VGLOB *vglob_ptr );
static void v_set_data_mode( VGLOB *vglob_ptr, int mode );
static void v_set_silence_mode( VGLOB *vglob_ptr, int mode );
static void v_queue_tones( VGLOB *vglob_ptr, uint_8 *digit_ptr, uint_8 num_tones );

/******************************************************************************
** Function : host_command_interface_init                                     *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
** Date            Ver   Dev  Comments                                        *
** 31st Oct  1998  1.0   RGT  Initial Revision                                *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 19th Apr  1999  2.0   RGT  Re-coded using function calls to initialise     *
**                            transmit and receive subsections.               *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function initialises the command interface to the 2181. It should   *
** be called during system initialisation.                                    *
*******************************************************************************
** Arguments :                                                                *
**                NONE                                                        *
**                                                                            *
*******************************************************************************/
void host_command_interface_init(VGLOB *vglob_ptr)
{
	V(config).pnetCodec        = UNINITIALISED;
}

/*
******************************************************************************
* Function : dpv_enable_call
******************************************************************************
* Description :
* Enable Core Trigger Byte interrupt to allow data transfer through dual-port
******************************************************************************
* Arguments :
*                NONE
******************************************************************************
*/
void dpv_enable_call(VGLOB *vglob_ptr)
{
  U8 modem = V(modem_num);
  codecType codec_type = V(config).pnetCodec;
									
#if 0
  printf("dpv_enable_call, modem = %d, rx/tx codec = %x\n",
		 modem, codec_type);
#endif

  // Put DSP in known state
  dp_idle();

  // Init trigger byte interrupts
  dp_startup_prime_pump();

  // Trunk side compander setting
  if (V(config).pstnCompander == V_A_LAW) {
	  // tell DSP about non-default trunk side compander
	  dp_write_dsp_ram (0x826 , dp_read_dsp_ram(0x826) | 0x0400 );
  }
  else {
	  // U-law
	  dp_write_dsp_ram (0x826 , dp_read_dsp_ram(0x826) & ~0x0400 );
  }

  switch (codec_type)
  {
    case G711:
      dp_enter_voice_mode(	V(config).pnetCompander == V_A_LAW ? 0x89 : 0x84,
							0, DSP_LEVEL, DSP_LEVEL, 0x0000);
      break;

    case G729:
      // ignore sampling rate, linear coding
      dp_enter_voice_mode(0x80, !V(config).silenceSupp, DSP_LEVEL, DSP_LEVEL, 0x0000);
      break;

  default:   // default is G711, mu law
	  printf("dpv_enable_call: unknown codec_type=%d, defaulting to G711\n",
			 codec_type);
      codec_type = G711;
      dp_enter_voice_mode(0x84, 0, DSP_LEVEL, DSP_LEVEL, 0x0000);
      break;
  }  // end of switch

#if defined(G729_VIA_CAMIL)
	if (codec_type != G729)
#endif	// G729_VIA_CAMIL
	{
		dpv_init_qmp();
	}

	// Note that first frame sent will set codec type
}

#if 0
void
dpv_enable_dtmf_mode(VGLOB *vglob_ptr)
{
	// Very similar to dpv_enable_call(),
	// except default to G711 mode
	printf("dpv_enable_dtmf_mode: starting core in DTMF mode\n");

	// Put DSP in known state
	dp_idle();

	// Init trigger byte interrupts
	dp_startup_prime_pump();

	// Pick G711-ulaw arbitrary
	dp_enter_voice_mode(0x84, 0, DSP_LEVEL, DSP_LEVEL, 0x0000);

	dpv_init_qmp();
}
#endif
/*
******************************************************************************
* Function : dpv_disable_call
******************************************************************************
* Description :
* Disable Core Trigger Byte interrupt - counterpart of dpv_enable_call
******************************************************************************
* Arguments :
*                NONE
******************************************************************************
*/
void dpv_disable_call(VGLOB *vglob_ptr)
{
  G(dp_bamil_re6) = ALLINTS;
  DP_SET_CORE_INTS( G(dp_bamil_re6) );
}

void
v_set_data_mode( VGLOB *vglob_ptr, int mode )
{
	if (mode == ENABLE) {
		printf("v_set_data_mode: enabling call\n");

		/******************************************
		** Configure the media exchanger core     *
		*******************************************/
		config_call(vglob_ptr);
		if( V(config).pnetCodec == UNINITIALISED ) {
			// Didn't get SET_AUDIO_MODE
			V(config).pnetCodec = Default_Codec_Type;
		}
		set_coder(vglob_ptr, V(config).pnetCodec);

		// Configure the DSP per parameters collected to date
		dpv_enable_call(vglob_ptr);

		if (V(dtmf_detection_enabled)) {
			// DTMF detection was running, restart it
			v_enable_dtmf_detection( vglob_ptr );
		}

		// Init loss-of-traffic alarm
		V(dsp_tx_alarm) = x_current_time();
		V(dsp_rx_alarm) = x_current_time();
	}
	else {
		// disable
	}
}

void
v_set_silence_mode( VGLOB *vglob_ptr, int mode )
{
	if (mode == ENABLE) {
		V(config).silenceSupp = True;
	}
	else {
		// disable
		V(config).silenceSupp = False;
	}

	if ( V(callIsNowActive) ) {
		// Call is already active, must restart to change suppression
		dpv_disable_call(vglob_ptr);
		v_set_data_mode(vglob_ptr, ENABLE);
	}

	printf( "v_set_silence_mode: silence suppression is %s\n",
			V(config).silenceSupp ?
			"ENABLED (G.729AB)" : "DISABLED (G.729A)" );
}

// Coders used in Voip msg num 0x24
static const byte coder_table[] = {
	G711,	// u-law
	G711,	// A-law
	G729,
	G723,
};

void
process_sarm_voip_msg(VGLOB *vglob_ptr, SARM_MSG *msg)
{
	uint_32 ms0 = (uint_32) msg->ms0;
	uint_8 msg_type = MSG_APPTYPE(ms0);

	// Parse SARM Voip messages
	switch ( msg_type ) {
	case VOIP_DATA_MODE:
		v_set_data_mode( vglob_ptr,
					   (ms0 >> 16) == 0x20 ? ENABLE : DISABLE );
		V(callIsNowActive) = True;
		break;

	case VOIP_AUDIO_MODE:
		// set trunk side protocol
		V(config).pstnCompander = ( (ms0 >> 16) == 0x20 ) ? V_A_LAW : V_U_LAW ;

		// set packet network protocol
		byte pkt_protocol = (byte) ( ms0 >> 26);
		if (pkt_protocol < sizeof(coder_table)) {
			codecType coder = coder_table[pkt_protocol];
			V(config).pnetCodec = coder;
			if ( coder == G711 ) {
				V(config).pnetCompander =  coder ? V_A_LAW : V_U_LAW ;
			}
			printf("process_sarm_voip_msg: setting pnetCodec to 0x%x\n", coder);
		}
		else {
			// send error msg
		}
		break;

	case VOIP_FRAMES_PER_PKT:
		// Set number of media framer per RTP packet
		V(config).framesPerPkt = (byte) ( ms0 >> 21);
		printf("process_sarm_voip_msg: set framesPerPkt to %d\n",
				V(config).framesPerPkt );
		break;

	case VOIP_JITTER_BUFFER_MODE:
		// Set up jitter buffer parameters
		// Note that the value in ms0 is number of packets,
		// we store the number of frames.
		V(config).dynamicBuildout = (byte) ( ms0 >> 21) & 0x01;
		V(config).jitterInitial = V(config).framesPerPkt *
			( (byte) ( ms0 >> 22) & 0x1f );
		V(config).jitterMax = V(config).framesPerPkt *
			( (byte) ( ms0 >> 27) );
		V(config).jitterMin = 1;
		printf("process_sarm_voip_msg: Dynamic Buildout %s\n",
			   V(config).dynamicBuildout ? "ENABLED" : "DISABLED");
		printf("process_sarm_voip_msg: jitter Min=%d, Max=%d, Init=%d frames\n",
			   V(config).jitterMin,
			   V(config).jitterMax,
			   V(config).jitterInitial );
		break;

	case VOIP_DTMF_DETECTION:
		if ( (ms0 >> 16) & 0x0020 ) {
			// Get DSP going first if need be
			if ( !V(callIsNowActive) && !V(dtmf_detection_enabled) ) {
				// Get the DSP running first
				v_set_data_mode( vglob_ptr, ENABLE );
			}
			v_enable_dtmf_detection( vglob_ptr );
		}
		else {
			v_disable_dtmf_detection( vglob_ptr );
		}
		break;

	case VOIP_GEN_TONES:
		uint_8 num_tones = MSG_SEQ(msg->ms0);
		uint_8 *digit_ptr = (uint_8 *) &msg->ms1;
		v_queue_tones( vglob_ptr, digit_ptr, num_tones );
		break;

	case VOIP_SILENCE_SUPP_MODE:
		v_set_silence_mode( vglob_ptr,
					   (ms0 >> 16) == 0x20 ? ENABLE : DISABLE );
		break;

	default:
		printf( "process_sarm_voip_msg: UNKNOWN voip msg type 0x%02x, msg: 0x%08x 0x%08x\n",
				msg_type, msg->mh, msg->ms0 );

		break;
	}
}


void
v_queue_tones( VGLOB *vglob_ptr, uint_8 *digit_ptr, uint_8 num_tones )
{
	dtmfQ_t	*dtmfQ = &V(dtmfQ);

	while (num_tones > 0) {
		
		// Allocate next position on queue
		struct V_DTMF_DIGIT_INFO *digit_info = &dtmfQ->digits[ dtmfQ->storeIndex ];
		if (digit_info->state != DTMF_IDLE) {
			printf("v_queue_tones: dtmfQ is FULL!\n");
			return;
		}

		// Load the digit
		digit_info->digit = *digit_ptr++;
		printf("v_queue_tones: queueing 0x%x\n", digit_info->digit );

		// Init on/off durations
		digit_info->onDuration = 100;
		digit_info->offDuration = 100;

		// Init frequencies
		switch ( digit_info->digit )
		{
			case 1:
			case 2:
			case 3:
			case 0x0c: //dtmf digit A
				digit_info->freq1s = F697S8 ;
				digit_info->freq1c = F697C8 ;
				break ;
			case 4:
			case 5:
			case 6:
			case 0x0d: //dtmf digit B
				digit_info->freq1s=F770S8 ;
				digit_info->freq1c=F770C8 ;
				break ;
			case 7:
			case 8:
			case 9:
			case 0x0e: //dtmf digit C
				digit_info->freq1s=F852S8 ;
				digit_info->freq1c=F852C8 ;
				break ;
			case 0x0a: //dtmf digit *
			case 0:
			case 0x0b: //dtmf digit #
			case 0x0f: //dtmf digit D
				digit_info->freq1s=F941S8 ;
				digit_info->freq1c=F941C8 ;
				break ;

		default:
			printf("v_queue_tones: bad digit 0x%x digit\n", digit_info->digit);
			return;
		}

		switch ( digit_info->digit )
		{
			case 1:
			case 4:
			case 7:
			case 0x0a: //dtmf digit *
				digit_info->freq2s = F1209S8 ;
				digit_info->freq2c = F1209C8 ;
				break ;
			case 2:
			case 5:
			case 8:
			case 0: //dtmf digit B
				digit_info->freq2s = F1336S8 ;
				digit_info->freq2c = F1336C8 ;
				break ;
			case 3:
			case 6:
			case 9:
			case 0x0b: //dtmf digit #
				digit_info->freq2s = F1477S8 ;
				digit_info->freq2c = F1477C8 ;
				break ;
			case 0x0c: //dtmf digit A
			case 0x0d: //dtmf digit B
			case 0x0e: //dtmf digit C
			case 0x0f: //dtmf digit D
				digit_info->freq2s = F1633S8 ;
				digit_info->freq2c = F1633C8 ;
				break ;
		default:
			printf("v_queue_tones: bad digit 0x%x digit\n", digit_info->digit);
			return;
		}
		// Change state so v_gen_tones() will process it
		digit_info->state = DTMF_QUEUED;

		// Bump index for next time around
		if ( ++dtmfQ->storeIndex >= CFG_DTMF_QUEUE_SIZE ) {
			dtmfQ->storeIndex = 0;
		}
		num_tones--;
	}

	// Get DSP going first if need be
	if ( !V(callIsNowActive) && !V(polling_enabled) && !V(dtmf_detection_enabled) ) {
		// Get the DSP running first
		v_set_data_mode(vglob_ptr, ENABLE);
	}

	// Make sure v_gen_tones will be called by v_task_main()
	V(polling_enabled) = True;
}

void
v_gen_tones( VGLOB *vglob_ptr)
{
	dtmfQ_t	*dtmfQ = &V(dtmfQ);

	// Sanity test
	if (dtmfQ->playIndex >= CFG_DTMF_QUEUE_SIZE
		|| dtmfQ->storeIndex >= CFG_DTMF_QUEUE_SIZE) {
		// invalid index
		printf("v_gen_tones: invalid dtmfQ index!!!!\n");
		return;
	}


	// Check for work at the current playIndex
	struct V_DTMF_DIGIT_INFO *digit_info = &dtmfQ->digits[ dtmfQ->playIndex ];
	switch ( digit_info->state ) {

	case DTMF_QUEUED:
		v_start_tone( vglob_ptr, digit_info );
		break;

	case DTMF_PLAYING:
		// Check if playing digit is done
		//if ( x_elapsed_time(digit_info->digitTimer) >= digit_info->digitLength ) {
		if ( !( dp_read_dsp_ram(0x3a) & 0x0010 ) ) {
			printf("v_gen_tones: completed, elapsed time = %d\n",
				  x_elapsed_time(digit_info->digitTimer) );
			// Done, make it available again
			digit_info->state = DTMF_IDLE;

			// Check if another is ready to go
			if (++dtmfQ->playIndex >= CFG_DTMF_QUEUE_SIZE) {
				dtmfQ->playIndex  = 0;
				digit_info = &dtmfQ->digits[ dtmfQ->playIndex ];
				if (digit_info->state == DTMF_QUEUED) {
					v_start_tone( vglob_ptr, digit_info );
				}
			}
		}
		break;

	case DTMF_IDLE:
		// Nothing to do
		break;

	default:
		printf("v_gen_tones: bad state %d\n", digit_info->state);
		digit_info->state = DTMF_IDLE;
	}
}

void
v_start_tone( VGLOB *vglob_ptr, struct V_DTMF_DIGIT_INFO *digit_info )
{
	// Start queue digit playing
	printf("v_gen_tones: starting 0x%x, on dur=%d, off dur=%d\n",
		digit_info->digit, digit_info->onDuration, digit_info->offDuration );

	// Set digit length, inter-digit delay
	// For some (unknown!) reason dial speed need to be 4 times
	// higher in G711 mode to get the required on duration
	codecType codec_type  = V(config.pnetCodec) == UNINITIALISED ? G711 : V(config.pnetCodec);
	word onDur = digit_info->onDuration;
	word offDur = digit_info->offDuration;
	if ( codec_type == G711 ) {
		onDur <<= 2;
		onDur += (onDur / 10) ; 	// duration scaled by 8kh/7.2khz
		offDur <<= 2;
		offDur += (offDur / 10) ; 	// duration scaled by 8kh/7.2khz
	}
	else if ( codec_type == G729 ) {
		onDur += (onDur / 10) ; 	// duration scaled by 8kh/7.2khz
		offDur += (offDur / 10) ; 	// duration scaled by 8kh/7.2khz
	}
	dp_write_dsp_ram (0x17, onDur);
	dp_write_dsp_ram (0x18, offDur);

	// Set frequencies
	dp_write_dsp_ram (0x05, digit_info->freq1s) ;
	dp_write_dsp_ram (0x06, digit_info->freq1c) ;
	dp_write_dsp_ram (0x07, digit_info->freq2s) ;
	dp_write_dsp_ram (0x08, digit_info->freq2c) ;

	// Do it
	dp_modem_command ( GENERATE_TONES, 2, 0 ) ;

	// Time it
	digit_info->digitLength = digit_info->onDuration + digit_info->offDuration;
	digit_info->digitTimer = x_current_time();
	digit_info->state = DTMF_PLAYING;
}

void
v_enable_dtmf_detection( VGLOB *vglob_ptr )
{
	// Now turn on the DTMF detection
	//dp_regread(0xb3); 
	//dp_regread(0xb3); 
	dp_write_dsp_ram(0xb2,0x0004); 
	dp_modem_command_long( DETECT_DTMF_TONES,0,0,0,0);

	// Synchronize the trigger byte interrupt handshake
	byte regB5 = dp_dsp_regread( 0xb5 ) ;
	if ( (regB5 & BIT3) == 0 )
	{
		// set host read trigger bit
		printf("dtmf enable - host read b3\n") ;
		dp_regread( 0xb3 ) ;
	}

	// Turn on DTMF trig byte interrupt, leave others alone
	G(dp_bamil_re6) &= (word)(~NCWTB4);
	DP_SET_CORE_INTS( G(dp_bamil_re6) );
	printf("v_enable_dtmf_detection: DTMF detect enabled\n");
	V(dtmf_detection_enabled) = True;
}


void
v_disable_dtmf_detection( VGLOB *vglob_ptr )
{
	/* init dtmf detection */
	if ( V(callIsNowActive) ) {
		// Disallow DTMF interrupts, leave the rest
		G(dp_bamil_re6) |= (word) NCWTB4;
	}
	else {
		// Disallow DTMF interrupts, nothing left
		G(dp_bamil_re6) = ALLINTS;
	}
	DP_SET_CORE_INTS( G(dp_bamil_re6) );
	V(dtmf_detection_enabled) = False;
	printf("v_disable_dtmf_detection: DTMF detect disabled\n");
}
