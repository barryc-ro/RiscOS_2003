/*name and version number:@(#)v110cs.c	1.9*/
/*date of get: 		  12/15/00 10:10:51*/
/*date of delta:	  11/30/00 16:59:51*/
/****************************************************************
File :  v110cs.c

Description :
	Contains functions for ITU-T V.110 rate adaption for a remote access server.

Procedures Contained :

Revision History :
	Initials        Date            Change
   J. Chang     05/12/98       Initial Version

*****************************************************************/
//#define DEBUG			// COMMENT OUT AFTER DEBUGGING !!!
#define INTRPT_DRIVEN	// for interrupt driven dual-port transfers
								// comment out for polling method
#define	Z80_DEBUG_THIS_FILE

#include "llglob_d.h"

#ifdef CS_V110
	#define BYTE unsigned char		// defined in v110sys.h, used in v110il.h
	#define WORD unsigned int
	#define LWORD unsigned long
	#define	B1_CHL 0				// defined in csglob.h
	#define	B2_CHL 1

	#include "v110il.h"
	#include "v110cs.h"
	#include "dpglob.h"
	#include "ioglob_d.h"
	#include "v42bis.h"	// use the V42bis buffer
	#include "z80glob.h"	// needed for x_debug_msg
#if defined(CS_4) // +sjb
 	#include "v110qmp.h" // +sjb
#else                  // +sjb
	#include "v110dsp.h" //jc -2/9/99
#endif                // +sjb
	#include "allglobs.h" //jc -4/28/99

#define V110_T1_TIMER		36		// defined also in v110sys.h
#define V110_RESYNC_TIMER	37		// defined also in v110sys.h

/* -------------------------------------- */
/* Declarations for Structures and Unions */
/* -------------------------------------- */

/* ------------------------------------------------- */
/* Declarations for External Variables and Functions */
/*          not included in header files             */
/* ------------------------------------------------- */

extern LWORD V110EventCallback ( WORD uEvent, BYTE dwMisc);
extern void UART_SetQue ( byte *, word, byte *, word ) ;

// -sjb: jctmp #ifdef CS_MODEM	// not CS_4 and not COPERNICUS
static word index2;
 #ifdef Z80_DEBUG_PRINT
 byte index3;
 #endif
// -sjb: jctmp #endif

// The following is used only in Venus for non-interrupt driven data transfer

#if defined(CS_MODEM) || defined(COPERNICUS)
// important time-critical variables used in dp_dualport_v110_Tx, _Rc.
	word IO_timer, dsp_data_cnt, dprx_count, io_rc_count;
	word 				dsp_space_cnt, dptx_count, io_tx_count;
	byte dsp_tx_ptr, dsp_rx_ptr, b0_count ;

#endif

/***********************************************************/
/*         GENERAL PURPOSE FUNCTIONS RELATED TO V110		  */
/***********************************************************/

/****************************************************************
Routine : v110_free_dce_rx
Description :
	This routine returns the free bytes available on the dce receive queue.
*****************************************************************/
static word v110_free_dce_rx ( void )		//jctmp
{
	word size;
	word count ;
	word  *rptr ;

	rptr = G(io_dce_rx_rptr) ;
	if ( G(io_dce_rx_wptr) >= rptr ) {
		size = G(io_dce_rx_eptr) - G(io_dce_rx_sptr);	// end minus start
		count = ( size - (G(io_dce_rx_wptr) - rptr) ) ;
	}
	else {
		count = (rptr - G(io_dce_rx_wptr) ) ;
	}
	--count;		// count = count - 1 ;
	return ( count ) ;
}

#if defined(CS_MODEM) || defined(COPERNICUS)
/****************************************************************
Routine : dp_dualport_v110_Tx
Description : dp voice transmit samples from dsp - mail box transfers
	The following Transmit and Receive functions are used in V110
*****************************************************************/
static void dp_dualport_v110_Tx (void )
{
	// get number of spaces available on DSP tx FIFO
	dsp_space_cnt = 2 * dp_read_dsp_ram(0xe1) ;
	if (dsp_space_cnt < 300)	// DSP tx FIFO has more than 700 bytes data
		return;

	io_tx_count = io_get_dce_queue_count(); // get amount of bytes on dce_tx que
	
	// transmit: try to fill 70% 0f dsp tx fifo if possible
	dptx_count = (dsp_space_cnt - 300) < io_tx_count ? (dsp_space_cnt-300): io_tx_count ;
								// e.g. io_tx_count = 15

	while( dptx_count >= 16 )
	{
		dsp_tx_ptr = 0x80 ;
		// start transmitting data
		do
		{
			dp_regwrite ( dsp_tx_ptr, (byte)*G(io_dce_tx_rptr));
			if ( ++G(io_dce_tx_rptr) >= G(io_dce_tx_eptr) )
				G(io_dce_tx_rptr) = G(io_dce_tx_sptr) ;
		}
		while ( ++dsp_tx_ptr <= 0x8f );	// max 16 bytes
	
		// Trigger Byte, 16 bytes max
		dp_regwrite ( 0xb0, 16 ) ;

		dptx_count -= 16;
		IO_timer = x_current_time() ;
		
		// Wait for CORE read
		while((dp_regread(0xb7) & 0x1)==0 )	//NCRTB1
		{
		   if ( x_elapsed_time(IO_timer) >= MS50 )
			{
				x_debug_msg("CORE read failure");
			}
		}
	}
}

/****************************************************************
Routine : dp_dualport_v110_RC
Description : dp voice receive samples from dsp - mail box transfers
	The following Transmit and Receive functions are used in v110
*****************************************************************/
static void dp_dualport_v110_Rc ( void )
{
//	byte count ;

	// return if no Core Write (NCWTB1)
	if ((dp_regread(0xb7) & 0x10)==0)  return;

	// get number of bytes available from DSP rx FIFO
	dsp_data_cnt = 2 * dp_read_dsp_ram(0xe7);
	if (dsp_data_cnt < 300)		return;	// less than 300 bytes on DSP rx FIFO

// probably don't need this; if (rx_count < dsp_data_cnt), we are in real trouble
	io_rc_count = v110_free_dce_rx ();	// get space available on dce_rx que

	// count is the smaller of the two
	dprx_count = io_rc_count < (dsp_data_cnt - 300) ? io_rc_count : (dsp_data_cnt-300);

	while ( dprx_count >= 16)
//	while ( dsp_data_cnt >= 16)
	{
		IO_timer = x_current_time() ;

		// Wait for Core Write --->  NCWTB1
		while((dp_regread(0xb7) & 0x10)==0)
		{
		   if ( x_elapsed_time(IO_timer) >= MS50 )
			{
				x_debug_msg("CORE Write failure");
			}
		}
		b0_count = dp_regread ( 0xb0 ) ; //  Read 0xb0 to get dualport tx count
							// this clears NCWTB1
		if (b0_count)
		{
			dsp_rx_ptr = 0x90 ;
			// copy data into fifo
			do
			{
				*G(io_dce_rx_wptr) ++ = dp_regread ( dsp_rx_ptr ) ;
				if ( G(io_dce_rx_wptr) >= G(io_dce_rx_eptr) )
					G(io_dce_rx_wptr) = G(io_dce_rx_sptr) ;

//				if ( G(io_dce_rx_wptr) == G(io_dce_rx_rptr) )
//					sendDumbChar('M');	// dp -read overflow !!
			}
			while ( ++dsp_rx_ptr <= 0x9f ) ;	// max 16 bytes
		}
		dprx_count -= 16;
//		dsp_data_cnt -= 16;
		// Dummy trigger to write more data
		dp_regread ( 0xb0 ) ;
	}
}
#endif	// defined(CS_MODEM) || defined(COPERNICUS)

/**************************************************************************/
void loopback_now(word count)
{		
//	count = 480;	// for every 120 msec 
//	count = 8;		// for every 1mse

	while ( count-- )
	{
		*G(io_dce_rx_wptr)++ = *G(io_dce_tx_rptr)++ ;
			
		if ( G(io_dce_tx_rptr) >= G(io_dce_tx_eptr) )
			G(io_dce_tx_rptr) = G(io_dce_tx_sptr) ;

		if ( G(io_dce_rx_wptr) >= G(io_dce_rx_eptr) )
			G(io_dce_rx_wptr) = G(io_dce_rx_sptr) ;
	}
}
/****************************************************************/
//jcv110-10/9/98
void cs_dtran(void)
{
	// make sure dsp is idle
	dp_modem_command ( MODEM_IDLE, (BYTE)NULL, (BYTE)NULL ) ;

	// download the code at starting addr of 0x0900
	DOWNLOAD_DSP(wDSP_DTRAN);	//download transparent mode dsp code

#if defined(COPERNICUS)
	if (S.ModemOptions.DigitalLoss56K & 1)		// A-law
		dp_write_dsp_ram(0x826, 0x0400);
	else													// u-law
		dp_write_dsp_ram ( 0x826, 0x0000 ) ;//16bits,LSB,u-law,SIO1,B1

#elif defined(ALAW_FORCED) && defined(CS_MODEM)
	if (G(b1_b2_mode) == B1_CHL)					
		dp_write_dsp_ram(0x826, 0x0400);
	else if (G(b1_b2_mode) == B2_CHL)		
		dp_write_dsp_ram(0x826, 0x1400);	

#elif defined(CS_MODEM)
	if (G(S).ModemOptions.DigitalLoss56K & 1)		// A-law
	{
		if ( G(b1_b2_mode) == B1_CHL)				
			dp_write_dsp_ram(0x826, 0x0400);
		else if ( G(b1_b2_mode) == B2_CHL)			
			dp_write_dsp_ram(0x826, 0x1400);	
	}
	else		// u-law
	{
#ifdef CS_STARTUP_DELAY
		x_sleep(STARTUP_DELAY); 			
#endif
		if ( G(b1_b2_mode) == B1_CHL)
			dp_write_dsp_ram ( 0x826, 0x0000 ) ;//16bits,LSB,u-law,SIO1,B1
		else if ( G(b1_b2_mode) == B2_CHL)
			dp_write_dsp_ram ( 0x826, 0x1000 ) ;//16bits,LSB,u-law,SIO1,B2
	}
#elif defined(CS_4) // +sjb
	// +sjb: initialize CSIO for LSB first transmission
	dp_regwrite16( 0xe0, dp_regread16(0xe0) | 0x1000 );	// +sjb: bit 12 set for LSB
#endif

//	dp_write_dsp_ram ( 0x0826, 0x0000 ) ;	// 16bits,LSB,u-law,SIO1,B1
	dp_write_dsp_ram ( 0x102e, 0x02 ) ;	 	// digital modem driver init
#if !defined(CS_4) // +sjb
	dp_write_dsp_ram ( 0x003d, 0x0200 ) ;	// parallel voice mode option

	// enable SIO loopback bit(bit 7 of SIOC reg = 1)
//	dp_modem_command_long(0x31, 0x01, 0x68, 0x80, (BYTE)NULL);

	// read sioc register to ensure no dsp internal loopback of data
	G(dp_byte_f) = 0;
	dp_modem_command_long(0x30, 0x01, 0, 0, (BYTE)NULL);

	// wait until we get the response from dsp
	while (G(dp_byte_f) != 0x0a);
			  
	x_debug_msg("siocL=");	//jctmp
	sendHexByte(dp_regread (0x33) ); 
	x_debug_msg("siocH=");	//jctmp
	sendHexByte(dp_regread (0x34) ); 

	x_debug_msg("yes ! vsio_alert done");	//jctmp

	// both 0xd7 and 0xb6 are zeros
	dp_regwrite ( 0xb7, 0xff );	// clear NCWTB interrupts (2ndary) 
	dp_regwrite ( 0xd8, 0xff ); 	// clear primary intrpts
#endif	// !defined(CS_4) // +sjb

#if !defined( CS_4 )
 #ifdef INTRPT_DRIVEN
	dp_regwrite ( 0xb6, 0xee);		// enable 2ndary intrpt
	G(dp_bamil_rd7) = 0xf3;			// enable primary intrpt: write 0 to bit 2
 #else
	dp_regwrite ( 0xb6, 0xff);		// disable 2ndary intrpt
	G(dp_bamil_rd7) = 0xf7;			// disable primary intrpt: write 1 to bit 2
 #endif
	dp_regwrite ( 0xd7, G(dp_bamil_rd7) ) ; 
#else	// CS_4
	// needs to setup interrupt here for CS_4
#endif

#if !defined(CS_4) // +sjb
	dp_write_dsp_ram ( 0x0c7a, 0x0 ) ;	// set to 0 bit shift initially

	// intermediate rate configure
	if ( G(v110_Ra2Ra1_ratio) == 8)	// 8k int. rate
		dp_regwrite( 0xB1,0x08 );
	else if ( G(v110_Ra2Ra1_ratio) == 4)		// 16k int. rate
		dp_regwrite( 0xB1,0x16 );
	else if ( G(v110_Ra2Ra1_ratio) == 2)		// 32k int. rate
		dp_regwrite( 0xB1,0x32 );
	else if ( G(v110_Ra2Ra1_ratio) == 1)		// 64k int. rate
		dp_regwrite( 0xB1,0x64 );
#else		// CS_4  +sjb: Begin addition...
	dp_write_dsp_ram ( 0x0001, 0x0 ) ;	// set to 0 bit shift initially

	// intermediate rate configure
	if ( G(v110_Ra2Ra1_ratio) == 8)	// 8k int. rate
		dp_write_dsp_ram ( 0x0002, 0x0008 ) ;
	else if ( G(v110_Ra2Ra1_ratio) == 4)		// 16k int. rate
		dp_write_dsp_ram ( 0x0002, 0x0016 ) ;
	else if ( G(v110_Ra2Ra1_ratio) == 2)		// 32k int. rate
		dp_write_dsp_ram ( 0x0002, 0x0032 ) ;
	else if ( G(v110_Ra2Ra1_ratio) == 1)		// 64k int. rate
		dp_write_dsp_ram ( 0x0002, 0x0064 ) ;
#endif // +sjb: End addition.


	// give DSP FIFO command
#if !defined(CS_4)  // +sjb
	dp_regwrite ( 0xD8, 0x18 ) ;	// clear core read/write bank bit - CRBNKI
	dp_regwrite ( 0x30, 0x04 ) ;
	dp_regwrite ( 0x31, 0x0 ) ;
	dp_regwrite ( 0x32, 0x0 ) ;
	dp_regwrite ( 0x33, 0x12 ) ;
	dp_regwrite ( 0x34, 0x12 ) ;
	dp_regwrite ( 0x35, 0x0 ) ;
	dp_regwrite ( 0x36, 0x80 ) ;
	dp_regwrite ( 0x37, 0x20 ) ;		// FIFO comand

	wait_for_core_read () ;

	// Kick of the Data receive for pdm mailbox transfers
	// dp_regread ( 0xb0 ) ;
	dp_regread ( 0xb0 ) ;
#else // +sjb: Begin addition...
	DP_INT_REGREAD( 0xb0 ) ;
	dp_regwrite ( 0x37, 0x20 ) ;		// FIFO comand

	wait_for_core_read () ;
#endif
	x_debug_msg("dtran download done");//jctmp
	x_debug_msg("0x900=");	
	sendHexWord(dp_read_dsp_ram ( 0x0900 )) ;	
	x_debug_msg("0xC0C=");	
	sendHexWord(dp_read_dsp_ram ( 0x0C0C )) ;	
	x_debug_msg("0xC0D=");	
	sendHexWord(dp_read_dsp_ram ( 0x0C0D )) ;	
// +sjb: End addition...
}

/*************************************************************************/
static void v110_timer_check(void)
{
 	if (x_elapsed_time( G(v110_Timer).T1_start_time) >= G(v110_Timer).T1_duration)
	{
		V110Timeout(V110_T1_TIMER);
//jctmp		io_start_dce_transmit ();	// start txt disconnect frame
	}
	else if (x_elapsed_time( G(v110_Timer).Resync_start_time) 
						>= G(v110_Timer).Resync_duration)
	{
		V110Timeout(V110_RESYNC_TIMER );
//jctmp 		io_start_dce_transmit ();	// start txt disconnect frame
	}
}
/*************************************************************************
	This function calculates the number of user bytes that constitutes a 
	frame	given ASYNC user rate as input parameter and returns a value that's
	10 times that number. It assumes one user byte give rise to 10 Data bits
	(1 start and 1 stop bits per user byte).

	NOTE: It does not support for 48k and 56k ! Can be added later.
*************************************************************************/
static byte v110_user_bytes_per_frame(byte user_rate)
{
	byte ret_val;

	switch (user_rate)
	{
		case V110_RATE_600:
			ret_val = 6;
			break;

		case V110_RATE_1200:
			ret_val = 12;
			break;

		case V110_RATE_2400:
			ret_val = 24;
			break;

		case V110_RATE_7200:
		case V110_RATE_14400:
		case V110_RATE_28800:
			ret_val = 36;
			break;

		case V110_RATE_4800:
		case V110_RATE_9600:
		case V110_RATE_19200:
		case V110_RATE_38400:
			ret_val = 48;
			break;

		case V110_RATE_12000:
		case V110_RATE_24000:
			ret_val = 30;
			break;
	}
	return(ret_val);
}
/***************************************************************
	This function finds the v110 speed based on v110_uChannelRate for 
	initial connect and MSI speed displays
****************************************************************/
word cs_v110_speed(void)
{
	word speed;

	if (G(v110_uChannelRate) == V110_RATE_9600)
		speed = 0x3d3d;	//61, 61
	else if (G(v110_uChannelRate) == V110_RATE_19200)
		speed = 0x4040;	//64, 64
	else if (G(v110_uChannelRate) == V110_RATE_38400)
		speed = 0x4343;	//67, 67
	else if (G(v110_uChannelRate) == V110_RATE_4800)
		speed = 0x3b3b;	//59, 59
	else if (G(v110_uChannelRate) == V110_RATE_2400)
		speed = 0x3a3a;	//58, 58

	return(speed);
}

/***************************************************************/
void cs_v110_init(void)
{
	byte temp;
//	word w;
#ifdef CS_4 // +sjb
	byte slot[4], i;  // +sjb
#endif  // +sjb

	UART_SetQue ( (BYTE)NULL, (BYTE)NULL, (BYTE)NULL, (BYTE)NULL ) ; // init dte tx & rx fifo
	io_init_dce_tx_fifo () ;
	io_init_dce_rx_fifo () ;

//jc-1/5/99	G(v110_dce_rx_buf) = (byte *)&symbol[600];	// use V42bis buffer
//	pdata = (PCSV110DATA)&symbol[1024];	// use V42bis buffer

	// Clear V.110 channel control structures, just in case prev connection is LAPM
//	for (w=0; w < 2048; w++)	// jc: this replaces memset function
//		symbol[w] = 0;

#if defined( DEBUG_RCV_RA1 )
	G(v110_wrap_around) = FALSE; // +sjb
	*G(uV110RcvRA1LogBfrIn)=0; // +sjb
#elif defined( DEBUG_RCV_RA2 )
	G(v110_wrap_around) = FALSE; // +sjb
	*G(uV110RcvRA2LogBfrIn)=0;  // +sjb
#elif defined( DEBUG_XMT_RA1 )
	G(v110_wrap_around) = FALSE; // +sjb
	*G(uV110XmtRA1LogBfrIn)=0; // +sjb
#elif defined( DEBUG_XMT_RA2 )
	G(v110_wrap_around) = FALSE; // +sjb
	*G(uV110XmtRA2LogBfrIn)=0; // +sjb	
#endif

#ifdef DEBUG		// use V.42bis buffer
	uV110RcvRA1LogBfrIn = (word *)&right[0];
	ucV110RcvRA1LogBfr  = (byte *)&right[2];
	uV110XmtRA1LogBfrIn = (word *)&right[2048];
	ucV110XmtRA1LogBfr  = (byte *)&right[2050];
	uV110RcvRA2LogBfrIn = (word *)&child[0];
	ucV110RcvRA2LogBfr  = (byte *)&child[2];
	uV110XmtRA2LogBfrIn = (word *)&child[2048];
	ucV110XmtRA2LogBfr  = (byte *)&child[2050];

	*uV110RcvRA1LogBfrIn=0;
	*uV110XmtRA1LogBfrIn=0;
	*uV110RcvRA2LogBfrIn=0;
	*uV110XmtRA2LogBfrIn=0;
#endif

	G(V110IsOpen) = FALSE;	// IAR does not allow we to set it in declaration
	G(V110Active) = FALSE;	//jctmp

	if ((G(v110_uChannelRate) <= V110_RATE_600) && (G(v110_uChannelRate) >= V110_RATE_4800))
	{
		G(v110_Ra2Ra1_ratio) = 8;
//		G(v110_dce_thres) = 240;		// this is for controller-handled RA2
		G(v110_dce_thres) = 30;		// this is for dsp-handled RA2
	}
	else if ((G(v110_uChannelRate) == V110_RATE_7200) || (G(v110_uChannelRate) == V110_RATE_9600))
	{
		G(v110_Ra2Ra1_ratio) = 4;
//		G(v110_dce_thres) = 160;		// this is for controller-handled RA2
		G(v110_dce_thres) = 40;		// -sjb: this is for dsp-handled RA2
// cb+		G(v110_dce_thres) = 500;		// +sjb: this is for dsp-handled RA2
	}
	else if ((G(v110_uChannelRate) <= V110_RATE_12000) && (G(v110_uChannelRate) >= V110_RATE_19200))
	{
		G(v110_Ra2Ra1_ratio) = 2;
//		G(v110_dce_thres) = 160;			// this is for controller-handled RA2
		G(v110_dce_thres) = 80;			// -sjb: this is for dsp-handled RA2
// cb+		G(v110_dce_thres) = 900;			// +sjb: this is for dsp-handled RA2
	}
	else
	{
		G(v110_Ra2Ra1_ratio) = 1;
//		G(v110_dce_thres) = 160;			// this is for controller-handled RA2
		G(v110_dce_thres) = 240;	  		// -sjb: this is for dsp-handled RA2
// cb+		G(v110_dce_thres) = 900;	  		// +sjb: this is for dsp-handled RA2
	}

	// 10 bytes/frame * Num 0f RA2 bytes/RA1 byte
	G(v110_bytes_to_process) = G(v110_Ra2Ra1_ratio) * 10;	// for all rates
	G(v110_bytes_to_store) = 6;		// at most 6 user bytes per frame(ave 4.8 user bytes
			// per frame for the 4 speeds we support)

	temp = v110_user_bytes_per_frame(G(v110_uChannelRate));	

	G(v110_userRa2_ratio) = temp * 24/ G(v110_Ra2Ra1_ratio); // only for
			// the four rates we support

	G(v110_mul_factor) = temp / G(v110_Ra2Ra1_ratio);  // only for four rates
	G(v110_flow_control) = 1;

	G(v110_state) = V110_DETECT_SYNC;

	#if defined(QMP_WRITE_TRACE)  // +sjb: Begin addition...
	G(sa_qmpwrite_trace) = 0x00;
	#endif
	#if defined(QMP_READ_TRACE)
	G(sa_qmpread_trace) = 0x00;
	#endif


#ifdef JIM
//#ifdef CS_4		// for testing only 
	init_SA_v110_test ();	// fake 

	// hard code the time slot
	for (i = 0; i< 4; i++)
		slot[i] = i;

	for ( modemNum=FIRSTMODEM; modemNum<4; modemNum+=4 )
	{
		sa_switchModem( modemNum ) ;

		// write to modem #0
		dp_regwrite16( 0xe2, (slot[1] << 8) + slot[0] + 0x8080);
		dp_regwrite16( 0xf1, (slot[3] << 8) + slot[2] + 0x8080);
		dp_regwrite16( 0xe1, (slot[1] << 8) + slot[0] + 0x8080);
		dp_regwrite16( 0xf0, (slot[3] << 8) + slot[2] + 0x8080);
	}
#endif // +sjb: End addition.
}

/**************************************************************************/

void cs_v110_disconnect(void)
{
	x_debug_msg("in cs_v110_disconnect");	//jctmp
  	G(v110_state) = V110_DISCONNECT;
}

/* --------------------------------- */
/* Main background function for V110 */
/* --------------------------------- */

byte v110_background (void)
{
	// if (dp_read_dsp_ram(0x46) & 0x8000 ) // +sjb
		// sendDumbChar('U');	// +sjb: jctmp: underrun
	// check for DSP Rx FIFO overrun
	if (dp_read_dsp_ram(0x46) & 0x4000 )
	{
//		x_debug_msg("dsp overrun !");
		sendDumbChar('R');
		dp_write_dsp_ram ( 0x46,0x0 ) ; 
	}
	
	switch ( G(v110_state) )
	{
		case V110_IDLE :
			// tell dp to switch to v110 mode: send continuous 1's to B chnl
			//x_send_mail ( DP_V110_MODE, DP_TASK, 0, 0 ) ;
			// receive continuous 1's from B chnl; DSR=CTS=DCD=OFF
			// dont need to disable intrpts
			break;

		case V110_DETECT_SYNC:

			/* Enable V.110 */
			ILV110_Init(V110EventCallback);	//	v110_do_console('I');

			// v110_uChannelRate is initialized in csmain.c
			ILV110_Open( G(v110_uChannelRate), V110_TYPE_ASYNC, V110_DCE, 1, 8,
						V110_T1_DEFAULT, V110_RESYNC_DEFAULT, 24 );
						//	v110_do_console( 'O' );

			G(V110DataTx).ucCircuit105_RTS = V110_CIRCUIT_ON;	// Jeff said to turn on everything
			G(V110DataTx).ucCircuit106_CTS = V110_CIRCUIT_ON;
			G(V110DataTx).ucCircuit107_DSR = V110_CIRCUIT_ON;
			G(V110DataTx).ucCircuit108_DTR = V110_CIRCUIT_ON;
			G(V110DataTx).ucCircuit109_RLSD = V110_CIRCUIT_ON;
			G(V110DataTx).ucData = 0xff;
			ILV110_DataRequest();
			G(V110Active) = TRUE;

#ifndef COPERNICUS
			ILV110_NeedXmtData();	// this fixes 4800 underrun problems
			ILV110_NeedXmtData();
#endif
			dp_offhook_cmd () ;

			// download dsp code
			cs_dtran();

			// tell dsp to start transmit 160 bytes of idle data
		  //	io_start_dce_transmit () ;
#if !defined( INTRPT_DRIVEN ) && !defined( CS_4 )
		  	dp_dualport_v110_Tx () ;	// start to txt
#endif
			// receive raw data from B channel
			v110_rx_frame();

			G(v110_state) = V110_ENGINE;	// start Link Technology's v110 engine
			break;

		case V110_ENGINE:
//x_debug_msg("ram="); // +sjb
//sendHexWord(dp_read_dsp_ram(0xc3fa) ); // +sjb
			v110_rx_frame();
			v110_tx_frame();
//			v110_tx_frame();	//jctmp
//			v110_rx_frame();	//jctmp
			v110_timer_check();	// check for time outs (if timer expires, disconnect)
			break;

		case V110_DISCONNECT:
			ILV110_Close();
			G(V110Active) = FALSE;
			G(V110IsOpen) = FALSE;
			ILV110_Terminate();

#if defined(COPERNICUS)		// no B2 channel is used for Copernicus
			if (S.ModemOptions.DigitalLoss56K & 1)		// A-law
				dp_write_dsp_ram(0x826, 0x0440);
			else													// u-law
				dp_write_dsp_ram ( 0x826, 0x0040 ) ;//16bits,MSB,u-law,SIO1,B1
#elif defined(ALAW_FORCED) && defined(CS_MODEM)
			if ( G(b1_b2_mode) == B1_CHL)					
				dp_write_dsp_ram(0x826, 0x0440);
			else if ( G(b1_b2_mode) == B2_CHL)		
				dp_write_dsp_ram(0x826, 0x1440);	

#elif defined(CS_MODEM)
			if (G(S).ModemOptions.DigitalLoss56K & 1)		// A-law
			{
				if ( G(b1_b2_mode) == B1_CHL)				
					dp_write_dsp_ram(0x826, 0x0440);
				else if ( G(b1_b2_mode) == B2_CHL)			
					dp_write_dsp_ram(0x826, 0x1440);	
			}
			else		// u-law
			{
#ifdef CS_STARTUP_DELAY
				x_sleep(STARTUP_DELAY); 			
#endif
				if ( G(b1_b2_mode) == B1_CHL)
					dp_write_dsp_ram ( 0x826, 0x0040 ) ;//16bits,MSB,u-law,SIO1,B1
				else if ( G(b1_b2_mode) == B2_CHL)
					dp_write_dsp_ram ( 0x826, 0x1040 ) ;//16bits,MSB,u-law,SIO1,B2
			}
#endif

#if !defined(CS_4) // +sjb
			dp_regwrite ( 0xb7, 0xff ); // clear NCWTB interrupts (2ndary) 
			dp_regwrite ( 0xd8, 0xff ); // clear primary intrpts
			dp_regwrite ( 0xb6, 0xee ); // enable 2ndary intrpt: trigger byte b0
#endif  // +sjb

			// this puts dsp back to normal mode
			dp_modem_command ( MODEM_IDLE, (BYTE)NULL, (BYTE)NULL ) ;

#if !defined( CS_4 )
			G(dp_bamil_rd7) = 0xf3;
			dp_regwrite ( 0xd7, G(dp_bamil_rd7) ) ; // enable primary intrpt: write 0 to bit 2
#else			// CS_4
	// need to setup interrupt here for CS_4

#endif

			G(v110_send_connect) = FALSE;

#if defined( DEBUG_RCV_RA1 )
			x_debug_msg("RCV RA1 buffer=");	//jctmp
			for (index2 = 0; index2 <320; index2++)
			{
				sendHexByte(G(ucV110RcvRA1LogBfr)[index2]);  // +sjb
				G(ucV110RcvRA1LogBfr)[index2] = 0;	// +sjb: clear
			}
#elif defined( DEBUG_RCV_RA2 )
			x_debug_msg("RCV RA2 buffer=");	//jctmp
			for (index2 = 0; index2 <320; index2++)
			{
				sendHexByte(G(ucV110RcvRA2LogBfr)[index2]);  // +sjb
				G(ucV110RcvRA2LogBfr)[index2] = 0;	// +sjb: clear
			}
			x_debug_msg("RCV DCE buffer=");	//jctmp
			G(io_dce_rx_rptr) = G(io_dce_rx_sptr);
			for (index2 = 0; index2 <100; index2++)
			{
				for (G(v110_wrap_around) = 0; G(v110_wrap_around) < 10; G(v110_wrap_around)++)  // +sjb
					sendHexByte((byte) (*G(io_dce_rx_rptr)++));
				sendDumbChar('\n');
			}
#elif defined( DEBUG_XMT_RA1 )
			x_debug_msg("XMT RA1 buffer=");	//jctmp
			for (index2 = 0; index2 <320; index2++)
			{
				sendHexByte(G(ucV110XmtRA1LogBfr)[index2]);  // +sjb
				G(ucV110XmtRA1LogBfr)[index2] = 0;	// +sjb: clear
			}
#elif defined( DEBUG_XMT_RA2 )
			x_debug_msg("XMT RA2 buffer=");	//jctmp
			for (index2 = 0; index2 <320; index2++)
			{
				sendHexByte(G(ucV110XmtRA2LogBfr)[index2]);  // +sjb
				G(ucV110XmtRA2LogBfr)[index2] = 0;	// +sjb: clear
			}
			x_debug_msg("XMT DCE buffer=");	// +sjb: jctmp
			G(io_dce_tx_rptr) = G(io_dce_tx_sptr);
			for (index2 = 0; index2 <100; index2++)
			{
				for (G(v110_wrap_around) = 0; G(v110_wrap_around) < 10; G(v110_wrap_around)++) // +sjb
					sendHexByte((byte) (*G(io_dce_tx_rptr)++));
				sendDumbChar('\n');
			}
	x_debug_msg("tx dsp fifo=");	// +sjb: Begin addition... jctmp
	G(v110_wrap_around) = 0;		//jctmp
	for (index2 = 0; index2 < 628; index2 ++)
	{
		sendHexWord(dp_read_dsp_ram ( 0x0c180 + index2 )) ;	
		G(v110_wrap_around)++;
		if (G(v110_wrap_around) == 5)
		{
			G(v110_wrap_around) = 0;
			sendDumbChar('\n');
		}
	} // +sjb: End addition.
#endif

#if defined( Z80_DEBUG_PRINT ) && defined(CS_MODEM)
			x_debug_msg("RCV RA1 buffer=");	//jctmp
			G(io_dce_rx_rptr) = G(io_dce_rx_sptr);
			for (index2 = 0; index2 <50; index2++)
			{
				for (index3 = 0; index3 < 10; index3++)
					sendHexByte((byte) (*G(io_dce_rx_rptr)++));
				sendDumbChar('\n');
			}
#endif
 
			x_send_mail ( MC_DISCONNECT, DP_TASK, 0, 0 ) ; // this changes 
				// dp_state and io_state
			G(v110_state) = V110_EXIT;
			break;

		case V110_EXIT:
			break;
	}

	return ( G(v110_state) ) ;		/* stay in v110 state */
}
/*************************************************************************
** name		: V110EventCallback					
** purpose	: V.110 event callback procedure			
** inputs	: 							
**                .channel						
**                .event						
**                .miscellaneous					
** outputs	: 						
**                .callback event specific return		
**									
*************************************************************************/
LWORD V110EventCallback ( WORD uEvent, BYTE dwMisc)
{
#ifdef DEBUG_XMT_RA2
	WORD uCpySize, uRA2Size;
#endif
#if defined(DEBUG_RCV_RA1) || defined(DEBUG_RCV_RA2) || defined(DEBUG_XMT_RA1)
	WORD uCpySize;
#endif

//	printf( "V110EventCallback %d/%d/%lxH\n", uChannel, uEvent, dwMisc );

	/* Process depending on event */
	switch( uEvent ) {
	case ILV110_EVENT_IN_SYNC:

		/* V.110 channel is now open */
		G(V110IsOpen) = TRUE;
#if defined(COPERNICUS) || defined(CS_4)
		if (G(cs_v110_on) == 1)
#else	// CS_MODEM
		if (!(G(csmain_flag) & 0x01) )	// have not sent MDM_STATE cmd to HOST
#endif
		{
			x_send_mail ( IO_AT_CONNECT, AT_TASK, 0, 0 ) ;
			x_debug_msg ("z80 - start timer now");	//jctmp
			G(v110_send_connect) = TRUE;
		}
		break;

	case ILV110_EVENT_OUT_OF_SYNC:

		/* V.110 channel is now closed */
		G(V110IsOpen) = FALSE;
		break;

	case ILV110_EVENT_DATA_INDICATION:
		// Now save data in buffer -- ignore status circuits in
		//	test program 
		// What if no space available in dte_tx buffer ???
//jctmp		if (I(io_dte_tx_rptr) != I(io_dte_tx_wptr) )
		{
			*I(io_dte_tx_wptr)++ = dwMisc;
//			sendHexByte(dwMisc);	//jctmp

			if ( I(io_dte_tx_wptr) >= I(io_dte_tx_eptr) )
				I(io_dte_tx_wptr) = I(io_dte_tx_sptr) ;
		}
		break;

	case ILV110_EVENT_RA2_BIT_SHIFT:
		// send bit shift amount to dsp
		if (dwMisc != 8)		// if dwMisc is 8, don't do anything
		{
			x_debug_msg("Changing bit shift");
#if !defined(CS_4)  // +sjb
			dp_write_dsp_ram( 0x0c7a, dwMisc ); // re-configure the bit shift
#else  // +sjb
			dp_write_dsp_ram( 0x0001, dwMisc ); // +sjb: re-configure the bit shift
#endif  // +sjb
			io_init_dce_rx_fifo () ;  // clear controller rx FIFO but not tx FIFO
		}
		break;

	case ILV110_EVENT_DISCO:
		G(v110_state) = V110_DISCONNECT;
		break;

//	case ILV110_EVENT_N_BIT_COUNT_DONE:
//		break;

//	case ILV110_EVENT_ERROR:
//		break;

#ifdef DEBUG_RCV_RA1
	case ILV110_EVENT_RCV_RA1_TRACE:
// -sjb:		if (( G(V110IsOpen) ) && (!G(v110_wrap_around)) ){		/* Rcvd a frame of RA1 data; save it */
		if ((!G(v110_wrap_around)) ){		/* +sjb: Rcvd a frame of RA1 data; save it */

		// assign the minimum of the two to uCpySize
		uCpySize = (WORD) (V110_RCV_LOG_BFR_SZ-*G(uV110RcvRA1LogBfrIn)); // +sjb
 		if (uCpySize > V110_FRAME_SIZE_BYTES )
			uCpySize = (WORD) V110_FRAME_SIZE_BYTES;

		x_memcpy( &G(ucV110RcvRA1LogBfr)[*G(uV110RcvRA1LogBfrIn)], (byte *)dwMisc, (word)uCpySize ); // +sjb
		*G(uV110RcvRA1LogBfrIn) += uCpySize;  // +sjb
		if ( *G(uV110RcvRA1LogBfrIn) == V110_RCV_LOG_BFR_SZ ) // +sjb
			*G(uV110RcvRA1LogBfrIn) = 0;  // +sjb
//			G(v110_wrap_around) = TRUE;  // -sjb
		}
		break;
#endif

#ifdef DEBUG_RCV_RA2
	case ILV110_EVENT_RCV_RA2_TRACE:		/* Rcvd a byte of RA2 data; save it */
		if ((!G(v110_wrap_around)) ){		/* +sjb: Rcvd a frame of RA2 data; save it */
		// assign the minimum of the two to uCpySize
		uCpySize = (WORD) (V110_RCV_LOG_BFR_SZ-*G(uV110RcvRA2LogBfrIn));  // +sjb
 		if (uCpySize > 1 )
			uCpySize = (WORD) 1;

		x_memcpy( &G(ucV110RcvRA2LogBfr)[*G(uV110RcvRA2LogBfrIn)], (byte *)dwMisc, (word)uCpySize ); // +sjb
		*G(uV110RcvRA2LogBfrIn) += uCpySize;  // +sjb
		if ( *G(uV110RcvRA2LogBfrIn) == V110_RCV_LOG_BFR_SZ )  // +sjb
			*G(uV110RcvRA2LogBfrIn) = 0;  // +sjb
//			G(v110_wrap_around) = TRUE;  // -sjb			
		}
		break;
#endif

#ifdef DEBUG_XMT_RA1
	case ILV110_EVENT_XMT_RA1_TRACE:
		if ( G(V110IsOpen) ) {		/* Rcvd a frame of RA1 data; save it */

		// assign the minimum of the two to uCpySize
		uCpySize = (WORD) (V110_XMT_LOG_BFR_SZ-*G(uV110XmtRA1LogBfrIn)); // +sjb
		if (uCpySize > V110_FRAME_SIZE_BYTES )
			uCpySize = (WORD) V110_FRAME_SIZE_BYTES;

		x_memcpy( &G(ucV110XmtRA1LogBfr)[*uV110XmtRA1LogBfrIn], (byte *)dwMisc, (word)uCpySize );  // +sjb
		*G(uV110XmtRA1LogBfrIn) += uCpySize;  // +sjb
		if ( *G(uV110XmtRA1LogBfrIn) == V110_XMT_LOG_BFR_SZ )  // +sjb
			{
			*G(uV110XmtRA1LogBfrIn) = 0;  // +sjb
			sendDumbChar('G');
			}
		}
		break;
#endif

#ifdef DEBUG_XMT_RA2
	case ILV110_EVENT_XMT_RA2_TRACE:		/* Xmtd a frame of RA1 data; save it */
    if ((!G(v110_wrap_around)) ){		/* +sjb: Rcvd a frame of RA2 data; save it */

		switch( G(v110_uChannelRate) ) {
		case V110_RATE_19200:
		case V110_RATE_14400:
		case V110_RATE_12000:
			uRA2Size = V110_FRAME_SIZE_BYTES * 2;
			break;

		case V110_RATE_9600:
		case V110_RATE_7200:
		case V110_RATE_3600:
			uRA2Size = V110_FRAME_SIZE_BYTES * 4;
			break;

		case V110_RATE_4800:
		case V110_RATE_2400:
		case V110_RATE_1200:
		case V110_RATE_600:
			uRA2Size = V110_FRAME_SIZE_BYTES * 8;
			break;

		default:
			uRA2Size = V110_FRAME_SIZE_BYTES;
			break;
		}

		// assign the minimum of the two to uCpySize
		uCpySize = (WORD) (V110_XMT_LOG_BFR_SZ-*G(uV110XmtRA2LogBfrIn));  // +sjb
		if (uCpySize > uRA2Size)
			uCpySize = (WORD) uRA2Size;

		x_memcpy( &G(ucV110XmtRA2LogBfr)[*G(uV110XmtRA2LogBfrIn)], (byte *)dwMisc, (word)uCpySize );  // +sjb
		*G(uV110XmtRA2LogBfrIn) += uCpySize;  // +sjb
		if ( *G(uV110XmtRA2LogBfrIn) == V110_XMT_LOG_BFR_SZ )  // +sjb
//			*G(uV110XmtRA2LogBfrIn) = 0;  // -sjb
			G(v110_wrap_around) = TRUE;  // +sjb
	 }
		break;
#endif
	}
	return( 0 );
}

/*************************************************************************/

static void v110_tx_frame(void)
{
	// do we work on all data on dte_rx que at once ???
 	/* Jeff: call DataRequest as soon as there's data on dte buffer
		and empty all of them out ! But if there are too many data on
		dte buffer, might want to set a threshold on amt of bytes to
		pass to DataRequest. The threshold is driven by size of one RA2
		frames to be placed on dce_tx buffer. But I might want to access
		dte_rx que more frequently */
	// in one pass thru of while loop, we have at most 15 msec which
	// gives us 120 RA2 bytes.

	word tx_count, rx_count, count, index;
	signed short user_bytes_needed;
	byte tmp;//jctmp
	tmp = 0;//jctmp

//word jim_timer;// -sjb: jctmp

#ifdef INTRPT_DRIVEN
	#if !defined(CS_4)
		disable_interrupt();
	#else
		_INT_DISABLE() ;  // +sjb
	#endif
#endif
	tx_count = io_get_dce_tx_count (); // get amount of free space on dce_tx que
	rx_count = io_get_dte_rx_bytes (); // get # of bytes available on dte_rx que
#ifdef INTRPT_DRIVEN
	#if !defined(CS_4)
		enable_interrupt();
	#else
		_INT_ENABLE() ;  // +sjb: Begin addition...
	#endif
#endif

//	jim_timer = x_current_time () ; // +sjb: End addition.  jctmp

#if defined( Z80_DEBUG_PRINT )
//	x_debug_msg("dce_tx_free=");
//	sendHexWord(tx_count);
//	x_debug_msg("dte_rx=");
//	sendHexWord(rx_count);

//	x_debug_msg("dsp tx=");
//	sendHexWord(dp_read_dsp_ram(0xe1));	// empty count of tx fifo
#endif

	// figure out how many user bytes needed to expand to tx_count
	// 3 is buffer; there can be at most 25 ra2 byte swing in the 3 rates we support
//	user_bytes_needed = ( (G(v110_userRa2_ratio))/24 * tx_count / 100) - 10; 
	user_bytes_needed = G(v110_mul_factor) * tx_count / 100 - 10;
	if (user_bytes_needed < 0)
		user_bytes_needed = 0;

#if defined( Z80_DEBUG_PRINT )
//	x_debug_msg("usr=");
//	sendHexWord(user_bytes_needed);
#endif

	// count is the smaller of the two
	count = (rx_count < user_bytes_needed) ? rx_count : user_bytes_needed;

	if (G(v110_uChannelRate) == V110_RATE_38400)	// flow control is only for 38400
	{
//		if ( (G(v110_flow_control) < 4) || (G(v110_flow_control) > 9) )
		if ( G(v110_flow_control) < 4)
		{
			while (count--)
			{
				G(V110DataTx).ucData = *I(io_dte_rx_rptr) ++ ;
				ILV110_DataRequest();
				DTE_RX_UPDATE();
			}
		}
		else
		{
			for (tmp=1; tmp<= count/5; tmp++)
				ILV110_NeedXmtData();
		}
	}
	else	// rates other than 38400
	{
		while (count--)
		{
			G(V110DataTx).ucData = *I(io_dte_rx_rptr) ++ ;
			ILV110_DataRequest();
			DTE_RX_UPDATE();
		}
	}
	// check for dce_tx que underrun situation(don't need to check the level
	// of dte_rx que again even though it might change)

	tx_count = io_get_dce_queue_count(); // get amount of bytes on dce_tx que

#if defined( Z80_DEBUG_PRINT )
//	x_debug_msg("dce_tx_byte=");
//	sendHexWord(tx_count);
#endif

	if ( (rx_count < user_bytes_needed) && (tx_count < G(v110_dce_thres))) //assume 15 msec loop
	{
		for (index = tx_count + 10; 
				index <= G(v110_dce_thres); index = index + 10)
		{			 // 240 works well for 4800, 160 for 9600
			// Keep the tranmitter busy 
			ILV110_NeedXmtData();
			tmp++;
		}
//		sendHexByte(tmp);//jctmp
//		x_debug_msg(" ");//jctmp	
//		x_debug_msg("ndXDa"); 
	}
	else
	{
//		x_debug_msg("dce_tx byte =");//jctmp
//		sendHexWord(tx_count);//jctmp
	}
//x_debug_msg("elapsed time=");					// +sjb: jctmp
//sendHexWord( x_elapsed_time ( jim_timer )); // +sjb: jctmp

//	if (rx_count < user_bytes_needed)	//jctmp
#ifdef INTRPT_DRIVEN
	io_start_dce_transmit () ;		// transmit data from dce_tx que to DSP
#elif !defined(CS_4)
		dp_dualport_v110_Tx () ;	// start to txt
#endif
}
/************************************************************************
	This function receives raw data from dce_rx_que ! It first ensures that
	dte_tx_que has enough free space to accept data from dce_rx_que.
	It does NOT support 48k and 56k rates !!!
************************************************************************/
static void v110_rx_frame(void)
{
	word tx_count, rx_count;
	byte index;

#if !defined( INTRPT_DRIVEN ) && !defined(CS_4)
	dp_dualport_v110_Rc () ;	// receive from DSP first
#endif

#if defined( Z80_DEBUG_PRINT )
//	x_debug_msg("dsp rx=");
//	sendHexWord(dp_read_dsp_ram(0xe7));	// full count of rx fifo

//	tx_count = io_get_dte_tx_count () ;	// to see if space available on dte_tx que
//	x_debug_msg("dte_tx=");
//	sendHexWord(tx_count);
#endif

#ifdef INTRPT_DRIVEN
	#if !defined(CS_4)
		disable_interrupt();
	#else
		_INT_DISABLE() ;  // +sjb
	#endif
#endif
	rx_count = io_get_dce_rx_count();	// do we process all data at once ????

#ifdef INTRPT_DRIVEN
	#if !defined(CS_4)
		enable_interrupt();
	#else
		_INT_ENABLE() ;  // +sjb
	#endif
#endif

#if defined( Z80_DEBUG_PRINT )
//	x_debug_msg("dce_rx=");
//	sendHexWord(rx_count);
#endif

	if (G(v110_uChannelRate) == V110_RATE_38400)	// flow control is only for 38400
	{
		if (G(v110_flow_control) < 5)		// turn on end-to-end flow control
		{
			G(V110DataTx).ucCircuit105_RTS = V110_CIRCUIT_OFF;
			G(V110DataTx).ucCircuit106_CTS = V110_CIRCUIT_OFF;
			G(v110_flow_control) ++;
		}
		else if (G(v110_flow_control) < 10)	// v110_flow_control = 10
		{
			G(V110DataTx).ucCircuit105_RTS = V110_CIRCUIT_ON;
			G(V110DataTx).ucCircuit106_CTS = V110_CIRCUIT_ON;
			G(v110_flow_control) ++;
		}
		else
  			G(v110_flow_control) = 0;
	}
	// you can potentially leave 159(80 * 2 = 160) bytes unprocessed from dce_rx que
	// Can be reduce to process one frame at a time if needed.
	while (rx_count >= 30)
	{
		rx_count -= 30;	// can't exceed twice the max RA2 frame size !!!

		// copy to byte array, since io_dce_rx_rptr is word *
		for (index=0; index < 30; index++)	
		{
			G(v110_dce_rx_buf)[index] = (byte) (*G(io_dce_rx_rptr)++) ;

			// update the read pointer
			if ( G(io_dce_rx_rptr) >= G(io_dce_rx_eptr) )
				G(io_dce_rx_rptr) = G(io_dce_rx_sptr) ;
		}
		/* do RA2 processing here 	jc-6/11/99 */
		ILV110_RcvdRawData(G(v110_dce_rx_buf), 30);
	}
//x_debug_msg("rx_frame cnt="); // +sjb: jctmp
//	sendHexWord(rx_count); // +sjb: jctmp
	// process residual bytes on dce_rx que, assuming have enough space on dte_tx
/*	if (rx_count)
	{
		for (index=0; index < rx_count; index++)	
		{
//disable_interrupt();
			G(v110_dce_rx_buf)[index] = (byte) (*G(io_dce_rx_rptr)++) ;

			// update the read pointer
			if ( G(io_dce_rx_rptr) >= G(io_dce_rx_eptr) )
				G(io_dce_rx_rptr) = G(io_dce_rx_sptr) ;
//enable_interrupt();
		}
		ILV110_RcvdRawData(G(v110_dce_rx_buf), rx_count);	//assuming dte_tx que has enough space
	}*/
}

/********************************************************************
// TO be added to main()

	// Check if active call, and if so check B channel xmt queue
	//	and if drops below a threshold, poll the V.110 software so a
	//	new V.110 frame can be generated
	// NOTE: this assumes the B1 channel for V.110

		count = io_get_dce_queue_count();
		if ( V110Active &&  count <= 2 )	// 2 ???
		{
			// Keep the tranmitter busy 
			ILV110_NeedXmtData();
		}
***************************************************************/

#endif   // CS_V110
