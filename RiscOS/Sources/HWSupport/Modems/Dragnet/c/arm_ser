/*name and version number:@(#)arm_ser.c	1.1*/
/*date of get: 		  01/12/01 11:49:20*/
/*date of delta:	  01/12/01 11:25:01*/
/****************************************************************
File :	arm_ser.c
Description :
	Contains the arm main function for the External Modem.
	Also the SCC functions and much of the Autobauding
	functionality.

Procedures Contained :
	main
	PnP_buildit
	PnP_identify


Revision History :
	Initials	Date		Change
	RWF			09/11/95	ext modem
	RWF			10/07/95	PnP
	RWF			10/13/95	eeprom
	RWF			12/07/95	z80189
	RWF			02/07/96	VENUS
	RWF			01/15/97	EASCI TX DMA
	RWF			02/21/97	EASCI RX DMA
	RWF			06/09/97	moved main() to z80util.c
*****************************************************************/
#include <string.h>
#include <stdlib.h>
#include	"llglob_d.h"
#include	"iouart_d.h"
#include	"ioglob_d.h"
#include	"atglob.h"
#include	"dpglob.h"

#ifdef G729A
#include "dpctad.h"
#endif

#include	"arm_glob.h"
#include	"allglobs.h"

#if defined(FRM_HOST_DMA_TEST)
byte dma_test;
#endif

//-----------------------------------------------------------------
// Uncomment the following line for debug of both DMA channels
//-----------------------------------------------------------------
//#define DMA_INT_DEBUG

#if defined(ARM_EASCI_RX_DMA)
//-----------------------------------------------------------------
// Uncomment the following line for state machine debug of RX DMA
// Note: there is an identical symbol in armserut.c that must also
// track this one
//-----------------------------------------------------------------
//# define RX_DMA_DEBUG
BOOL	dmach0Flg ;
#endif	// ARM_EASCI_RX_DMA

#if defined(ARM_EASCI_TX_DMA)
//-----------------------------------------------------------------
// Uncomment the following line for state machine debug of TX DMA
// Note: there is an identical symbol in armserut.c that must also
// track this one
//-----------------------------------------------------------------
//# define	TX_DMA_DEBUG

# define PNPHOSTMODE	// this is the more rigorous PnP algorithm
BOOL	dmach1Flg ;
# endif	// ARM_EASCI_TX_DMA

//==========================================================================
//		ESCC/EASCI Variables/Tables for the Z80182/189/VENUS
//==========================================================================
const word baud_rate_tbl[] = {
	BR75_2,				//     75 bps => 0
	BR150_2,			//    150 bps => 1
	BR300_2,			//    300 bps => 2
	BR600_2,			//    600 bps => 3
	BR1200_2,			//   1200 bps => 4
	BR2400_2,			//   2400 bps => 5
	BR4800_2,			//   4800 bps => 6
	BR7200_2,			//   7200 bps => 7
	BR9600_2,			//   9600 bps => 8
	BR14400_2,			//  14400 bps => 9
	BR19200_2,			//  19200 bps => 10
	BR38400_2,			//  38400 bps => 11
	BR57600_2,			//  57600 bps => 12
	BR115200_2,			// 115200 bps => 13
	BR230400_2
} ;

//-----------------------------------------------------------
//			VENUS delta_tbl[]
//-----------------------------------------------------------
// This is a table of midpoints of BRG values for use in
// table lookup of an exact value from the baud_rate_tbl[]
// above.  The VENUS EASCI hardware measures the start-bit
// and plugs in an approximate value of the start bit.
//-----------------------------------------------------------
const word delta_tbl[] = {
	BR75_2,
	BR150_2,
	0xffff,
	(BR600_2 + BR300_2)/2,
	(BR1200_2 + BR600_2)/2,
	(BR2400_2 + BR1200_2)/2,
	(BR4800_2 + BR2400_2)/2,
	(BR7200_2 + BR4800_2)/2,
	(BR9600_2 + BR7200_2)/2,
	(BR14400_2 + BR9600_2)/2,
	(BR19200_2 + BR14400_2)/2,
	(BR38400_2 + BR19200_2)/2,
	(BR57600_2 + BR38400_2)/2,
	(BR115200_2 + BR57600_2)/2,
	(BR230400_2 + BR115200_2)/2
} ;
//==========================================================================
//			END of EASCI Variables for VENUS
//==========================================================================

//==========================================================================
//					Globals
//==========================================================================
#if defined( ROM_FLASH )
//--------------------------------------------------------------------------
//	The following variables are shared by the Flash Loader 
//	and the baseline.  GotBRGcnt and s_62 are set by nmiir
//	which is in the Flash Loader; and AUTOBAUDING is used
//	to convey information to Flash Loader whem the modem
//	jumps into it do get a new load.
//--------------------------------------------------------------------------
extern	BOOL		GotBRGcnt ;		// baudrate value is known
extern	BAUD_RATE	s_62 ;			// this sreg is the baudrate (actually
									// an index into the baudrate table)
//--------------------------------------------------------------------------
#else
BOOL	GotBRGcnt ;
BAUD_RATE s_62 ;					// this sreg is the baudrate (actually
									//   an index into the baudrate table)
//--------------------------------------------------------------------------
#endif
BAUD_RATE lst_s_62 ;
BOOL	arm_no_more_tx ;			// Bool to determine idle Tx to DTE ch.
BOOL	AUTOBAUDING ;
byte	in_stat ;					// last status read from DTE
byte	in_stat0 ;					// last status read from DTE
word	brgcnt;

#if defined( ARM_EASCI_TX_DMA )
word	arm_max_dma ;				// size of DMA transfer.
byte	*arm_dte_tx_rptr ;			// temp ptr to rx buffer
#endif

#if defined( ARM_EASCI_RX_DMA )
BOOL	arm_rx_dma ;
byte	*arm_dte_rx_wptr ;			// temp ptr to rx buffer
#endif

#if defined( ARM_EASCI_TX_DMA ) || defined( ARM_EASCI_RX_DMA )
BOOL	arm_dma_debug ;
#endif

#if defined( ARM_DEBUG_PRINT )
BOOL	arm_flow_on_flag ;
BOOL	abon, aboff;
//byte	dma_loop_cnt;
word	debug_rx_count ;
word	flash_timer ;			// timer for Break to DTE
#endif

//--------------------------------------------------------------------------
//			Debug tickers
//--------------------------------------------------------------------------
word ext_c_int ;			// scc ext interrupt
word src_c_int ;			// scc src interrupt
word bad_char2;				// scc rx interrupt
word overrun_error;			// scc src interrupt
word framing_error ;		// scc src interrupt

//--------------------------------------------------------------------------
//					Break from/to DTE Variables
//--------------------------------------------------------------------------
word	brk_timer ;					// timer for Break to DTE
BOOL	brk_to_dte_flg ;			// flag set when break in progress to DTE
BOOL	brk_from_dte_flg ;			// flag signalling scc_rx_int() ISR
									// a NULL is in the input fifo
BOOL	brk_from_dte_on ;			// flag set when break rcvd from DTE
BOOL	brk_from_dte_off ;			// flag set when break cleared by DTE

//--------------------------------------------------------------------------
//					DTR from DTE Variables
//--------------------------------------------------------------------------
BOOL	dtr_from_dte_on ;
BOOL	in_xof_from_dte ;
BOOL	setXflag ;

//--------------------------------------------------------------------------
//					Plug & Play Variables
//--------------------------------------------------------------------------
#if defined( PNPSTRING )
PLUGNPLAY PnP_state ;				// state var for Win95 Plug and Play
word PnP_timer ;					// timer for Win95 Plug and Play
word PnP_count ;					// ticker for # sends of string to host
#endif
//
//==========================================================================

//==========================================================================
//			Functions (including ISRs)
//==========================================================================

#if defined(YS)
void
arm_16550_rx_poll()
{
	// get chars from the Mosquito receive buffer
	// put them in the DTE rx buffer
	while( MOS_Ptr->lsr & 1 )
	{
		*io_dte_rx_wptr = MOS_Ptr->a0.rbr ;
		if( ++io_dte_rx_wptr >= io_dte_rx_eptr)
		{
			io_dte_rx_wptr = io_dte_rx_sptr ;
		}
	}
}

void
arm_16550_tx_poll()
{
	// send chars from DTE tx buffer
	// to the Mosquito transmit buffer
	if( MOS_Ptr->lsr & 0x20 ) {
		// 16550 tx fifo is empty, send up to 16 bytes
		byte fifo_cnt;
		byte *rptr = (byte *) I(io_dte_tx_rptr);
		byte *wptr = (byte *) I(io_dte_tx_wptr);
		for ( fifo_cnt = 0; fifo_cnt < 16 && rptr != wptr; fifo_cnt++ ) {
			// send next byte
			MOS_Ptr->a0.thr = *rptr;
			if ( ++rptr >= I(io_dte_tx_eptr) )
			{
				rptr = (byte *) I(io_dte_tx_sptr) ;
			}
		}
		I(io_dte_tx_rptr) = rptr;
	}
}

void
arm_uart_cts_led_on()
{
	MOS_Ptr->mcr |= BIT2;
}

void
arm_uart_cts_led_off()
{
	MOS_Ptr->mcr &= ~BIT2;
}

void
arm_uart_cts_led_toggle()
{
//	output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & BIT2 ?
//				input8 ( DUMB_MCR ) & ~BIT2 :
//				input8 ( DUMB_MCR ) | BIT2 ) ;
	MOS_Ptr->mcr ^= BIT2;
}

void
arm_uart_rts_led_on()
{
	//output8 ( DUMB_MCR, input8 ( DUMB_MCR ) | BIT3 ) ;
#if defined(OCM)
#elif defined(YS)
	MOS_Ptr->mcr |= BIT3;
#endif
}

void
arm_uart_rts_led_off()
{
	//output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & ~BIT3 ) ;
	MOS_Ptr->mcr &= ~BIT3;
}
#elif defined(OCM)
#warn "arm_uart_led_on/off not implemented on OCM"
void arm_uart_cts_led_on() { }
void arm_uart_cts_led_off() { }
void arm_uart_cts_led_toggle() { }
void arm_uart_rts_led_on() { }
void arm_uart_rts_led_off() { }
#else
void arm_uart_cts_led_on() { }
void arm_uart_cts_led_off() { }
void arm_uart_cts_led_toggle() { }
void arm_uart_rts_led_on() { }
void arm_uart_rts_led_off() { }
#endif

//#if defined(OCM)
/****************************************************************
	Function : timer interrupt - set for PRT0_CNT msec intervals

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void arm_timer0_isr ( dword )
{
	#if defined( ARM_EASCI_RX_DMA )
	//---------------------------------------------------------
	// if in on-line mode, and using DMA ch0 for EASCI RX,
	// then update the IO_DTE_RX_WPTR buffer pointer.
	//---------------------------------------------------------
	if ( arm_rx_dma )
	{
		word dmaadr ;
		byte cnt ;

		cnt = 0;
		while ( 1 )
		{
			dmaadr = (word)(input8(DAR0L)|(input8(DAR0H)<<8)) ;
			#if (HOST_RX_BUFF_SIZE & 255) == 0
			# error "HOST_RX_BUFF_SIZE must NOT be Mod 256"
			#endif
			if ( (byte)(dmaadr) == input8(DAR0L) )
			{
				#if defined( DMA_INT_DEBUG )
				if ( IO_DTE_RX_WPTR != (byte *)dmaadr )
				{
					ddputs_nnl("dmaadr -"); sendHexWord(dmaadr);
					sendCrLf();
				}
				#endif

				if ( /* ((byte *)dmaadr >= IO_DTE_RX_SPTR)
					&& */ ((byte *)dmaadr < IO_DTE_RX_EPTR) )
				{
					IO_DTE_RX_WPTR = (byte *)dmaadr ;
				}
				else
				{
					ddputs_nnl("dmaadr Err="); sendHexWord(dmaadr);
					sendCrLf();
					#if defined(FRM_HOST_DMA_TEST)
					if ( dumbPortPresent ) arm_parsechar( 'D' );
					#endif
				}
				break ;
			}

			if ( cnt++ > 4 )
			{
				fatal_error("DMA in prt0");
			}
		}
		// for debug
		//if ( cnt > dma_loop_cnt ) dma_loop_cnt = cnt;
	}
	#endif

#if defined(YS)
	// No 16550 irq until oxygen, must poll here and in main loop
	arm_16550_rx_poll();
	arm_16550_tx_poll();
#endif	// YS

	//---------------------------------------------------------
	// disable ESCC/EASCI interrupt - before calculating no of
	// bytes in queue
	//---------------------------------------------------------
	if ( IO_DTE_RX_WPTR >= IO_DTE_RX_RPTR )
	{
		uart_rx_count = IO_DTE_RX_WPTR - IO_DTE_RX_RPTR ;
	}
	else
	{
		uart_rx_count = (IO_DTE_RX_EPTR - IO_DTE_RX_RPTR)
						 + (IO_DTE_RX_WPTR - IO_DTE_RX_SPTR) ;
	}

	#if defined( ARM_EASCI_RX_DMA )
	// if running ch0 dma then flow control
	if ( arm_rx_dma )
	#endif
	{
		if ( uart_rx_count >= HOST_RX_BUFF_FULL )
		{
			arm_flow_on() ;
		}
	}

	#if defined(ARM_READ_UART_DEBUG)
	if ( dumbPortPresent )
		if ( input8(DUMB_LSR) & BIT0 )
			arm_parsechar( input8(DUMB_DATA) );
	#endif

		// set clock for next period
	x_timer += PRT0_CNT ;

		// finally strobe sanity timer
	#if defined( WATCHDOG_TIMER )
	output8( 0xda, 0x1f ) ;
	output8( 0xdb, 0xe5 ) ;
	#endif
}
#if defined(OCM)

/****************************************************************
Routine : easci_isr
Description :
    C Interrupt Service Routine for the EASCI block (Enhanced
	Asynchronous Serial Communications Interface).
*****************************************************************/
void easci_isr ( void )
{
	byte ch;
	void arm_start_autobaud ( void );

	//----------------------------------------------
	// check for EASCI RX (from host) activity
	//----------------------------------------------
	while ( TRUE )
	{
		in_stat0 = easci_input( ASCI_STAT0_REG );
		//in_stat0 = arm_uart_rx_data_avail();
		if ( !(in_stat0 & 0xf0) ) break;

		//-------------------------------
		// check for RX error
		//-------------------------------
		if ( in_stat0 & 0x70 )
		//if ( arm_uart_error_detected() )
		{
			//-------------------------------
			// got RX error - process it
			//-------------------------------
			asci_rx_error();

			if ( AUTOBAUDING ) arm_start_autobaud();
		}
		else
		{
			//-------------------------------
			// got good char - process it
			//-------------------------------
			ch = easci_input( ASCI_RX0_REG );

			if ( AUTOBAUDING )
			{
				//--------------------------------------
				// is it an 'A' or 'a' ?
				//--------------------------------------
				if ( (ch & 0x5f) != 'A' )
				{
					//-------------------------------
					// nope - try again
					//-------------------------------
					arm_start_autobaud();
					bad_char2++;
					continue;
				}
				else
				{
					//-------------------------------
					// yep - it's an 'A' (or 'a')
					//-------------------------------
					//sendDumbChar('^');
					AUTOBAUDING = 0;
	
					//-----------------------------------
					// Have we already established BRG?
					//-----------------------------------
					if ( !GotBRGcnt )
						asci_set_autobaud();
				}
			}
			else
			{
				//-------------------------------
				// Check for SW flow control
				//-------------------------------
				if ( arm_modem_state == SW_ON_LINE_STATE )
				{
					//-----------------------------
					// Software flow control is set
					//-----------------------------
					if ( ch == XOFF )
					{
						//--------------------------------
						// XOFF received from DTE:
						// Set flag to stop sending to DTE
						//--------------------------------
						arm_swfc_on();
						continue;
					}
					else if ( ch == XON )
					{
						//--------------------------------
						// XON received from DTE:
						// Clr flag to allow sending to DTE
						//--------------------------------
						arm_swfc_off();
						continue;
					}
				}
			}

			//------------------------------------------
			// place char in "from host" dte ring buffer
			// and handle buffer wrap.
			// Flow control is managed in prt0().
			//------------------------------------------
			*io_dte_rx_wptr = ch ;
			if ( ++io_dte_rx_wptr >= io_dte_rx_eptr )
				io_dte_rx_wptr = io_dte_rx_sptr ;
		}
	}

	//-------------------------------------
	// check for empty tx data register
	//-------------------------------------
	if ( !arm_no_more_tx && (in_stat0 & BIT1) )
	//if ( !arm_no_more_tx && (arm_uart_tx_empty()) )
	{
		//---------------------------
		// tx (to host) interrupt
		//---------------------------
		if ( io_dte_tx_rptr != io_dte_tx_wptr )
		{
			//---------------------------
			// send next char
			//---------------------------
			easci_output( ASCI_TX0_REG, *io_dte_tx_rptr ) ;
			if ( ++io_dte_tx_rptr >= io_dte_tx_eptr )
				io_dte_tx_rptr = io_dte_tx_sptr ;
		}
		else
		{
			//--------------------------------------
			// There is NO more data to transmit;
			// Reset TX interrupt enable bit and set
			// arm_no_more_tx to signal main() that
			// tx side has been inhibited.
			//--------------------------------------
			arm_no_more_tx = TRUE;
			easci_output( ASCI_STAT0_REG,
						easci_input( ASCI_STAT0_REG ) & ~TX_INT_ENABLE ) ;
		}
	}

	//---------------------------------------------------------------
	// finally, check for DTR and/or RTS changes
	// (in_stat & in_stat0 are used by called routine on change).
	//---------------------------------------------------------------
	in_stat = easci_input( A0NEWCTL ) & 0xf0 ;
	if ( in_stat )
	{
		//--------------------------------------
		// A change in DTR or RTS has occured;
		//	Go process change via C function
		//	and reset interrupting source(s)
		//--------------------------------------
		asci_ext_int();
	}
}
#endif	// OCM

/*****************************************************************
	Function : x_sleep_mode
	For external modem - sleep only when autobauding.
	Note: Cannot use IOSTOP mode and achieve reliable
	autobauding at lower baudrates.  It seems that the
	channel one timer has trouble getting started again
	after waking up.  Use SLEEP mode instead.
******************************************************************/
byte x_sleep_mode ( void )
{
	return FALSE ;
}


#if defined(OCM)
/****************************************************************
	Function : Extension to asci_int ISR to handle receive errors.
	Handles frame errors, break condition (a frame error with
	zero character) and data overruns.
	Uses common global in_stat.
	MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void asci_rx_error ( void )
{
	byte in_char ;

	sendDumbChar('A'); 

	in_char = easci_input( ASCI_RX0_REG ) ;

#if defined(ARM_DEBUG_PRINT)
	// Check for overrun error
	if ( in_stat0 & BIT6 ) sendDumbChar('o');

	// Check for parity error
	if ( in_stat0 & BIT5 ) sendDumbChar('p');
#endif	// ARM_DEBUG_PRINT

	// Check for framing error/break
	if ( in_stat0 & BIT4 )
	{
		// framing_error
		sendDumbChar('f');

		// was the framing error actually a Break?
		if ( !in_char )
		{
			//========================================
			// Break from DTE detected
			//========================================

			// set flag for task environment
			brk_from_dte_on = TRUE ;

			#if defined(ARM_DEBUG_PRINT)
			if ( dumbPortPresent )
			{
				//output8 ( DUMB_MCR, input8 ( DUMB_MCR ) | 0x08 ) ;
				arm_uart_rts_led_on();
				sendDumbChar('b');
			}
			#endif
		}
	}

	// reset error flag in ctl A reg
	easci_output( ASCI_CTLA0_REG, easci_input( ASCI_CTLA0_REG ) & ~ERROR_RESET ) ;

	// if online bump ticker.
	// unconditionally bump it - rwf - 01/01/01
	//if ( (x_modem_mode == MODEM_DATA) && (x_modem_state == MS_ON_DIAL) )
	{
		src_c_int ++ ;
	}

	sendDumbChar(0x0A); sendDumbChar(0x0D);
}

/****************************************************************
	Function : asci_ext_int()
	Extension to asci_int ISR to handle additional Status
	interrupts for VENUS.  Similar in functionality to
	ESCCs external interrupt handler.  Handles DTR and RTS
	changes from DTE.  Global var in_stat contains A0NEWCTL
	register contents on entry. Bits of interest are:
		DCD_HL_INT_RCVD,
		DCD_LH_INT_RCVD,
		CTS_HL_INT_RCVD, and
		CTS_LH_INT_RCVD

	MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void asci_ext_int ( void )
{
	ext_c_int ++ ;

	sendDumbChar('E');

	//=================================================
	// Now determine what CHANGE caused the interrupt.
	//	Could be:
	//		1) DTR from DTE (our DCD), or
	//		2) RTS from DTE (our CTS)
	//=================================================

	//+++++++++++++++++++++++++++++++++++
	// Check for DTR change
	//+++++++++++++++++++++++++++++++++++
	if ( in_stat & DCD_HL_INT_RCVD )
	{
		// Our DCD has transitioned to LOW which means that
		// DTR has just been SET by the DTE!!
		if ( !(in_stat0 & DCD0) )
		{
#ifdef PNPHOSTMODE
			// PnP: IF in T2 for 200 ms
			// (DTR was cleared by DTE 200ms ago and RTS is still reset)
			// THEN Enter T3
			PnP_chkstate ( T2 ) ;

			// 8/28/98 - mah - add this case
			// If we didn't make it to state T3
			// then if RTS is OFF we should
			// go to state T1
			if ((T0 == PnP_state) &&
				(easci_input ( ASCI_CTLB0_REG ) & ASCI_CTS))
			{
				PnP_setstate ( T1 ) ;
			}
			// 8/28/98 - mah - end of addition
#endif
		}
		sendDumbChar('D');
	}
	if ( in_stat & DCD_LH_INT_RCVD )
	{
		// Our DCD has transitioned to HIGH which means that
		// DTR was just RESET by DTE!!
		if ( in_stat0 & DCD0 )
		{
#ifdef PNPHOSTMODE
			// PnP: IF in T1 for 200 ms
			// (RTS from DTE cleared 200 ms ago)
			// THEN enter T2
			PnP_chkstate ( T1 ) ;
#endif
		}
		sendDumbChar('d');
	}

	//+++++++++++++++++++++++++++++++++++
	// Check for change of RTS from DTE
	//+++++++++++++++++++++++++++++++++++
	if ( in_stat & CTS_HL_INT_RCVD )
	{
		// Our CTS has transitioned to LOW which means that
		// RTS was just SET by DTE!!
		// PnP: IF in T3 for 200 ms
		// THEN respond to DTE by sending
		// the ID information ( sent by main() ).
		if ( !(easci_input ( ASCI_CTLB0_REG ) & ASCI_CTS) )
		{
			PnP_chkstate ( T3 ) ;
		}
		// RTS is SET
		sendDumbChar('R');
	}

	if ( in_stat & CTS_LH_INT_RCVD )
	{
		// Our CTS has transitioned to HIGH which means that
		// RTS was just RESET by DTE!!
		// further transmission of characters.
		if ( easci_input ( ASCI_CTLB0_REG ) & ASCI_CTS )
		{
#ifdef PNPHOSTMODE
			// PnP: If DTR currently set (our DCD)
			// THEN start the Enumeration sequence (enter T1)
			if ( !( easci_input (  ASCI_STAT0_REG ) & DCD0) )
			{
				PnP_setstate ( T1 ) ;
			}
#endif
		}
		// RTS is clear
		sendDumbChar('r');
	}

#ifndef PNPHOSTMODE
	if ( easci_input ( ASCI_CTLB0_REG ) & ASCI_CTS )
	{
		PnP_setstate ( T3 ) ;
	}
#endif

	//++++++++++++++++++++++++++++++++++++++++++++++++++++
	// Finally reset interrupting source(s) by writing a 0
	//++++++++++++++++++++++++++++++++++++++++++++++++++++
	in_stat = (~in_stat & 0xf0) ;
	in_stat |= (easci_input( A0NEWCTL ) & 1) ;
	easci_output( A0NEWCTL, in_stat ) ;
}

/****************************************************************
	Function : asci_set_autobaud()
	Called by: EASCI "from host" ISR which has just found an "a"

	Sets s_62 and modifies actual BRG counter to precise value.
	Since the 16 bit BRG value is calculated by hardware and NOT
	generated by table lookup, the value could be a tick or two
	off of the exact baudrate.  This function corrects that.

	rwf - 01/01/01
	--------------
	Note: For Venus2 at the higher baudrates, the actual value
	is jammed into the BRG from a hardware table.

		MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void asci_set_autobaud ( void )
{
	static const word *deltaptr ;

	// Stop hardware autobauding
	easci_output( A0NEWCTL,
				DCD_HL_INT_RCVD | DCD_LH_INT_RCVD |
				CTS_HL_INT_RCVD | CTS_LH_INT_RCVD ) ;

	// Get actual BRG counter value
	brgcnt = easci_input( ASCI_TCLO_REG ) | (easci_input ( ASCI_TCHI_REG ) << 8) ;

	//---------------------------------------------------------------
	// iterate the highest three baudrates for real-time response
	// -------
	// also for Venus2 hardware autobaud enhancement - rwf - 01/01/01
	//---------------------------------------------------------------
	if ( brgcnt < delta_tbl[ BR230400 ] )
	{
		s_62 = BR230400 ;

		#if defined(ARM_DEBUG_PRINT)
		// test software - test for exact value
		if ( (brgcnt != BR230400_2) )
		{
			sendDumbChar('?'); sendDumbChar('d');
		}
		#endif
	}
	else if ( brgcnt < delta_tbl[ BR115200 ] )
	{
		s_62 = BR115200 ;

		#if defined(ARM_DEBUG_PRINT)
		// test software - test for exact value
		if ( (brgcnt != BR115200_2) )
		{
			sendDumbChar('?'); sendDumbChar('c');
		}
		#endif
	}
	else if ( brgcnt < delta_tbl[ BR57600 ] )
	{
		s_62 = BR57600 ;

		#if defined(ARM_DEBUG_PRINT)
		// test software - test for exact value
		if ( (brgcnt != BR57600_2) )
		{
			sendDumbChar('?'); sendDumbChar('b');
		}
		#endif
	}
	else 
	{
		deltaptr = &delta_tbl[ BR38400 ] ;
		for ( s_62 = BR38400; s_62 > BR150; s_62-- )
		{
			if ( brgcnt < *deltaptr )
			{
				break ;
			}
			deltaptr -- ;
		}
		// Set BRG counter to exact value
		easci_output( ASCI_TCLO_REG, (byte)(baud_rate_tbl[ s_62 ] & 0xFF) ) ;
		easci_output( ASCI_TCHI_REG, (byte)(baud_rate_tbl[ s_62 ] >> 8) ) ;
	}

	GotBRGcnt = TRUE ;
}
#endif // OCM

/****************************************************************
	Function : arm_uart_break_on
	Break received from far end, Send a break to DTE
	NOTE: main() will be responsible for clearing the
	break condition after 300 ms (see BRK_TIME).
*****************************************************************/
void arm_uart_break_on ( void )
{
	// start Break to DTE
#if defined(OCM)
	easci_output( ASCI_XCR0_REG, easci_input( ASCI_XCR0_REG ) | SEND_BRK ) ;
#elif defined(YS)
#endif
	//output8 ( DUMB_MCR, input8 ( DUMB_MCR ) | 0x08 ) ;
	arm_uart_rts_led_on();
	brk_to_dte_flg = TRUE ;
	brk_timer = x_current_time () ;
}

/****************************************************************
	Function : arm_uart_cts_on
*****************************************************************/
void arm_uart_cts_on ( void )
{
	// set CTS to DTE
	disable_interrupt () ;
#if defined(OCM)
	easci_output( ASCI_CTLA0_REG, easci_input( ASCI_CTLA0_REG ) & ~ASCI_RTS ) ;
#elif defined(YS)
	MOS_Ptr->mcr |= BIT1;	// set RTS
	//MOS_Ptr->mcr &= ~BIT1;	// set RTS
#endif
	enable_interrupt () ;
}

/****************************************************************
	Function : arm_uart_cts_off

		MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void arm_uart_cts_off ( void )
{
	// clear CTS to DTE
#if defined(OCM)
	easci_output( ASCI_CTLA0_REG, easci_input( ASCI_CTLA0_REG ) | ASCI_RTS ) ;
#elif defined(YS)
	MOS_Ptr->mcr &= ~BIT1;	// clear RTS
	//MOS_Ptr->mcr |= BIT1;	// clear RTS
#endif
}

/****************************************************************
	Function : arm_uart_cd_on
*****************************************************************/
void arm_uart_cd_on ( void )
{
	// set DCD to DTE
	disable_interrupt () ;
#if defined(OCM)
		x_output( IO_CARRIER_DETECT_ON ) ;
#elif defined(YS)
		//output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) | BIT7 ) ;
		MOS_Ptr->mcr |= BIT3;
#endif
	enable_interrupt () ;
}

/****************************************************************
	Function : arm_uart_cd_off
*****************************************************************/
void arm_uart_cd_off ( void )
{
	// clear DCD to DTE
	disable_interrupt () ;
#if defined(OCM)
		x_output( IO_CARRIER_DETECT_OFF ) ;
#elif defined(YS)
		MOS_Ptr->mcr &= ~BIT3;
#endif
	enable_interrupt () ;
}

/****************************************************************
	Function : arm_uart_ri_on
*****************************************************************/
void arm_uart_ri_on ( void )
{
#if defined(OCM)
	x_output( IO_RING_INDICATE_ON ) ;
#elif defined(YS)
#endif
}

/****************************************************************
	Function : arm_uart_ri_off
*****************************************************************/
void arm_uart_ri_off ( void )
{
#if defined(OCM)
	x_output( IO_RING_INDICATE_OFF ) ;
#elif defined(YS)
#endif
}

/****************************************************************
	Function : arm_uart_dsr_on
*****************************************************************/
void arm_uart_dsr_on ( void )
{
#if defined(OCM)
	x_output( IO_DSR_ON ) ;
#elif defined(YS)
#endif
	ddputs_nnl( "DSR ON" ) ;
	sendCrLf();
}

/****************************************************************
	Function : arm_uart_dsr_off
*****************************************************************/
void arm_uart_dsr_off ( void )
{
#if defined(OCM)
	x_output( IO_DSR_OFF ) ;
#elif defined(YS)
#endif
	ddputs_nnl( "DSR OFF" ) ;
	sendCrLf();
}

#if defined(OCM)
void arm_uart_enable_rts_auto_control()
{
	//---------------------------------------------------
	// turn on RTS auto control of TX channel
	//---------------------------------------------------
	easci_output ( ASCI_XCR0_REG,
			easci_input( ASCI_XCR0_REG ) & ~CTS0_DISABLE ) ;
}
void arm_uart_enable_rts_irq()
{
	//---------------------------------------------------
	// turn on RTS interrupt on TX channel
	//---------------------------------------------------
	easci_output ( A0INTIN,
			easci_input( A0INTIN ) |
				(CTS_HL_INT_ENABLE|CTS_LH_INT_ENABLE) ) ;
}

void arm_uart_disable_rts_auto_control()
{
	//---------------------------------------------------
	// turn off RTS auto control of TX channel
	//---------------------------------------------------
	easci_output ( ASCI_XCR0_REG,
			 easci_input( ASCI_XCR0_REG ) | CTS0_DISABLE ) ;
}
void
arm_uart_disable_rts_irq()
{
	//---------------------------------------------------
	// turn off RTS interrupt on TX channel
	//---------------------------------------------------
	easci_output ( A0INTIN,
			easci_input( A0INTIN ) &
				~(CTS_HL_INT_ENABLE|CTS_LH_INT_ENABLE) ) ;
}

/****************************************************************
	Function : arm_start_autobaud
	Note: this function is called from the serial interface RX
	ISR and is meant to be called with interrupts masked!
	It is also called from the task environment
	(Routine : main() below)

		MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void arm_start_autobaud ( void )
{
	// clear the BRG...
	easci_output ( ASCI_TCLO_REG, 0 ) ;
	easci_output ( ASCI_TCHI_REG, 0 ) ;

	// ...start hardware autobaud...
	easci_output ( A0NEWCTL,
				DCD_HL_INT_RCVD | DCD_LH_INT_RCVD | CTS_HL_INT_RCVD |
				CTS_LH_INT_RCVD | BAUD_DETECT | AUTOBAUD_EN ) ;

	GotBRGcnt = FALSE ;

#if defined( ARM_EASCI_RX_DMA )
	//---------------------------------------------------
	// stop the receive side dma - note: this is done by
	// giving the channel back for use in SW flow control.
	//---------------------------------------------------
	if ( arm_rx_dma )
		arm_stop_rx_dma() ;
#endif
	AUTOBAUDING = TRUE ;

#if defined(ARM_DEBUG_PRINT)
	abon = TRUE ;
#endif
}

word arm_ab_timer; // timer for checking autobaud

/****************************************************************
	Function : arm_stop_autobaud
	Like arm_start_autobaud() above, this function
	is meant to be called with interrupts masked.  It
	is called by main() to send messages to the DTE
	while in autobaud mode.

	We set the bit rate to the value stored in s_62.

		MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void arm_stop_autobaud ( void )
{
	// ...stop hardware autobauding, and...
	easci_output ( A0NEWCTL,
				DCD_HL_INT_RCVD | DCD_LH_INT_RCVD |
				CTS_HL_INT_RCVD | CTS_LH_INT_RCVD ) ;

	// ... and Set baudrate back to previously observed value
				// lower byte
	easci_output ( ASCI_TCLO_REG, (byte)(baud_rate_tbl[ s_62 ] & 0xFF) ) ;
				// upper byte
	easci_output ( ASCI_TCHI_REG, (byte)(baud_rate_tbl[ s_62 ] >> 8) ) ;

	AUTOBAUDING = FALSE;
	arm_ab_timer = x_current_time();

#if defined(ARM_DEBUG_PRINT)
	aboff = TRUE ;
#endif
}

#endif	// OCM


/****************************************************************
	Function : arm_flow_on
	Stop the host from sending
        
		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void arm_flow_on(void)
{
	if ( S.ModemOptions.FlowControl == HW_FLOWCTRL )
	{
		uart_flow_control = FC_ON ;
		arm_uart_cts_off ( ) ;
		//sendDumbChar( 'c' ) ;
	}
	else if ( S.ModemOptions.FlowControl == SW_FLOWCTRL )
	{
		#if defined( ARM_EASCI_TX_DMA )
		extern const byte XOFFchar ;

		//-------------------------------------------------
		// send xoff to the pc using ch0 DMA
		//-------------------------------------------------
		//	load the DMA state for the XOFF char
		output8( SAR0L, (byte)&XOFFchar ) ;
		output8( SAR0H, (byte)((word)&XOFFchar >> 8) ) ;
		output8( BCR0L, 1 ) ;
		//-------------------------------------------------
		//	start the ch0 DMA - no interrupt
		//-------------------------------------------------
		#if defined( DMA_INT_DEBUG )
		ddputs_nnl("6: start ch0 DSTAT-"); sendHexByte(input8( DSTAT ));
		#endif
		output8( DSTAT, (input8( DSTAT ) & 0x08) | 0x61 ) ;
		#if defined( DMA_INT_DEBUG )
		ddputs_nnl(";  DSTAT-"); sendHexByte(input8( DSTAT ));
		sendCrLf();
		#endif
		uart_flow_control = FC_ON ;
		#else
		// send xoff to the pc - later in the background
		uart_flow_control = FC_OFF_TO_ON ;
		#endif
		sendDumbChar('x');
	}

	#if defined(ARM_DEBUG_PRINT)
	// for testing flow control
	// print every new high water mark!!
	if ( uart_rx_count > debug_rx_count )
	{
		debug_rx_count = uart_rx_count ;
		arm_flow_on_flag = TRUE ;
	}
	#endif
}

#if defined(OCM)

/****************************************************************
	Function : arm_chk_autobaud

	Is it time to autobaud?  If so, setup the hardware and the
	software state variables (through arm_start_autobaud()).

*****************************************************************/
void arm_chk_autobaud(void)
{
	//==============================================
	// if in "cmd" mode then wait for all chars in
	// response to previous command to be sent to
	// DTE before restarting autobaud.
	//==============================================
	if ( at_state == AT_IDLE
		 /* new way for autobaud checking..
		  * Is io_state in a state where it could be
		  * sending the next character to AT?
		  */
		 && ((io_state < IO_CD_ON) || (io_at_esc_detect
#if defined ( K56FLEX ) || defined( VPCM_CLIENT ) || defined ( VPCM_SERVER )
					&& !dp_56k_state
#endif
				))
		 // following check needed to prevent autobaud while
		 // on-line in class 1 or class 2 fax
		 && (x_modem_state != MS_ON_DIAL)
		 // following check allows any char to terminate
		 // ata or atdt command.
		 && (x_modem_state != MS_ANSWERING)
		 && (x_modem_state != MS_DIALING)
		 && (IO_DTE_RX_WPTR == IO_DTE_RX_RPTR)
		 && !at_view_more )
	{
		// test for a quiescent "Tx to DTE" channel.
		if ( arm_no_more_tx && IO_DTE_TX_WPTR == IO_DTE_TX_RPTR )
		{
			// (I tried just reading the level of BIOB6
			// but that doesn't work as well as catching the
			// edge as we're doing now. - mah 5/19/00)
			if (//dp_regread(0xbb) & BIT6 &&		// also RxD not active
				easci_input( ASCI_CTLB0_REG ) & ASCI_ALL_SENT )
			{
				if (dp_regread(0xbd) & BIT6)
				{
					// If BIOB6 has had a falling edge then
					// there has been a bit on RxD and we don't
					// want to autobaud for a while.

					// clear all bit I/O interrupts
					dp_regwrite(0xbd, 0xff);
					dp_regwrite(0xbd, 0);
					arm_ab_timer = x_current_time();
				}

				if (
					(x_elapsed_time(arm_ab_timer) >= 10)
#if defined(VOICE)
					// fix bitware bug where we weren't autobauding
					// fast enough to satisfy bitware.  On Win2k
					// Bitware only waits 4-5 ms between the receipt
					// of one command's 'OK' and the 'A' of the next
					// command at a different baud rate.  (not nice.)
					|| (MODEM_VOICE == x_modem_mode &&
						x_elapsed_time(arm_ab_timer) >= 2)
#endif
					)
				{
					// both the software and the hardware concur that
					// all data has been sent.
					disable_interrupt();
					 arm_start_autobaud();
					enable_interrupt();

					dp_regwrite(0xbc, 0xff);	// disable B6 "interrupt"
				}
				else
				{
					// Mask BIO interrupts in primary HOST masking register.
					// We'll poll for these events above and don't want
					// them taking us to the ISR.
					G(dp_bamil_rd7) |= BIT6;
					dp_regwrite(0xd7, G(dp_bamil_rd7));

					// Enable B6 "interrupt" so we can catch
					// falling edges.
					dp_regwrite(0xbc, 0xbf);
				}
				return;
			}
		}
	}
	arm_ab_timer = x_current_time();
}
#endif // OCM

/****************************************************************
	Function : arm_swfc_on
	XOFF received from DTE: Set flag to stop sending to DTE

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void arm_swfc_on ( void )
{
	// XOFF has just been received from the DTE!!
	in_xof_from_dte = TRUE ;
	setXflag = TRUE ;
#if !defined( ARM_EASCI_TX_DMA )
	arm_no_more_tx = TRUE ;
# if defined(OCM)
	easci_output( ASCI_STAT0_REG, easci_input( ASCI_STAT0_REG ) & ~TX_INT_ENABLE ) ;
# elif defined(YS)
# endif
#endif
#if defined( ARM_DEBUG_PRINT )
	//------------------------------------------
	// Turn OFF RTS led - Yellowstone
	//------------------------------------------
	//output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & ~BIT3 ) ;
	arm_uart_rts_led_off();
#endif
}

/****************************************************************
	Function : arm_swfc_off
	XON received from DTE: Clear flag to allow sending to DTE

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void arm_swfc_off ( void )
{
	// XON has just been received from the DTE!!
	in_xof_from_dte = FALSE ;
	setXflag = TRUE ;
#if defined(ARM_DEBUG_PRINT)
	//------------------------------------------
	// Turn ON RTS led - Yellowstone
	//------------------------------------------
	//output8 ( DUMB_MCR, input8 ( DUMB_MCR ) | BIT3 ) ;
	arm_uart_rts_led_on();
#endif
}

#if defined( ARM_EASCI_TX_DMA )
/****************************************************************
	Function : arm_start_tx_dma
	Calculates the number of contiguous bytes available to send
	to the Host and sets up and starts the Channel 1 DMA transfer.
*****************************************************************/
void arm_start_tx_dma ( void )
{
	word count ;

	//-------------------------------------------------
	//		load the starting address
	//-------------------------------------------------
	output8( MAR1L, (byte)IO_DTE_TX_RPTR ) ;
	output8( MAR1H, (byte)((word)IO_DTE_TX_RPTR >> 8) ) ;

	//-------------------------------------------------
	//		load the count
	//-------------------------------------------------
	if ( IO_DTE_TX_WPTR > IO_DTE_TX_RPTR )
	{
		//---------------------------------------------
		// all bytes available are contiguous
		//---------------------------------------------
		count = IO_DTE_TX_WPTR - IO_DTE_TX_RPTR ;
		if ( count > arm_max_dma )
		{
			//---------------------------------------------
			// send only arm_max_dma bytes at a time. this
			// allows the IO_DTE_TX_RPTR to be updated faster
			//---------------------------------------------
			count = arm_max_dma ;
			arm_dte_tx_rptr = IO_DTE_TX_RPTR + arm_max_dma ;
#if defined( TX_DMA_DEBUG ) && defined( notme_rwf )
			if ( arm_dma_debug ) sendDumbChar( '1' ) ;
#endif
		}
		else
		{
			arm_dte_tx_rptr = IO_DTE_TX_WPTR ;
#if defined( TX_DMA_DEBUG )
			if ( arm_dma_debug ) sendDumbChar( '2' ) ;
#endif
		}
	}
	else
	{
		//---------------------------------------------
		// bytes available are non-contiguous
		// just get the upper bytes this time.
		//---------------------------------------------
		count = IO_DTE_TX_EPTR - IO_DTE_TX_RPTR ;
		if ( count > arm_max_dma )
		{
			count = arm_max_dma ;
			arm_dte_tx_rptr = IO_DTE_TX_RPTR + arm_max_dma ;
#if defined( TX_DMA_DEBUG ) && defined( notme_rwf )
			if ( arm_dma_debug ) sendDumbChar( '3' ) ;
#endif
		}
		else
		{
			arm_dte_tx_rptr = IO_DTE_TX_SPTR ;
#if defined( TX_DMA_DEBUG )
			if ( arm_dma_debug ) sendDumbChar( '4' ) ;
#endif
		}
	}

	output8( BCR1L, (byte)count ) ;

	//-------------------------------------------------
	//		Start ch1 DMA and enable CH1 interrupt.
	//-------------------------------------------------
#if defined( DMA_INT_DEBUG )
	ddputs_nnl("1: start ch1 DSTAT-"); sendHexByte(input8( DSTAT ));
#endif

	disable_interrupt();
		output8( DSTAT, (input8( DSTAT ) & 0xdf) | 0x88 ) ;
	enable_interrupt();

#if defined( DMA_INT_DEBUG )
	reg = input8( DSTAT ) ;
	ddputs_nnl("; DSTAT-"); sendHexByte(reg);
	sendCrLf();
#endif
}

/****************************************************************
	Function : dma1ir
	This is the ISR for the DMA Channel 1. It is vectored to
	at the end of a DMA transfer.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void dma1ir ( void )
{
	byte reg ;

	//-------------------------------------------------
	//	stop the DMA on Channel 1
	//-------------------------------------------------
#if defined( DMA_INT_DEBUG )
	ddputs_nnl("2: stop ch1 DSTAT-"); sendHexByte(input8( DSTAT ));
#endif
	reg = input8( DSTAT ) ;
	output8( DSTAT, reg & 0x17 ) ;

#if defined( DMA_INT_DEBUG )
	reg = input8( DSTAT ) ;
	ddputs_nnl("; DSTAT-"); sendHexByte(reg);
	sendCrLf();
#endif

#if defined( TX_DMA_DEBUG )
	if ( arm_dma_debug ) {
		sendDumbChar( 'n' ) ;
		sendCrLf();
	}
#endif

	//----------------------------------------------------
	//	adjust read ptr to reflect just completed DMA
	//----------------------------------------------------
	IO_DTE_TX_RPTR = arm_dte_tx_rptr ;

	//-------------------------------------------------
	//	More data to send?
	//-------------------------------------------------
	if ( (IO_DTE_TX_WPTR != IO_DTE_TX_RPTR)
		 && (((S.ModemOptions.FlowControl == HW_FLOWCTRL) &&
			  !(input8 ( ASCI_CTLB0_REG ) & ASCI_CTS))
			 || ((S.ModemOptions.FlowControl == SW_FLOWCTRL) &&
				 !in_xof_from_dte)) ) {
#if defined( TX_DMA_DEBUG )
		if ( arm_dma_debug ) sendDumbChar( 'i' ) ;
#endif
		arm_start_tx_dma() ;
	}
	else {
		arm_no_more_tx = TRUE ;
	}
}
#endif

#if defined( ARM_EASCI_RX_DMA )
/****************************************************************
	Function : arm_flush_rx_dma
	Called when the application environment flushes the rx queue.
	Allows the ch0 DMA to track the task environment.
*****************************************************************/
void arm_flush_rx_dma ( void )
{
	if ( arm_rx_dma )
	{
		disable_interrupt () ;
			arm_dte_rx_wptr = IO_DTE_RX_WPTR ;
			arm_start_rx_dma() ;
		enable_interrupt () ;

		ddputs_nnl("Flush Ch0");
		sendCrLf();
	}
}

/****************************************************************
	Function : arm_start_rx_dma
	Calculates the number of contiguous bytes available in the
	receive buffer and sets up and starts the Channel 0 DMA transfer.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void arm_start_rx_dma ( void )
{
	word cnt;
	byte reg;

	if ( !arm_rx_dma )
	{
		//----------------------------------------
		//		do the one time stuff
		//----------------------------------------
			// Dest register - upper byte (0x0fxxxx)
		output8( DAR0B, (byte)0x0f ) ;
			// source register
		output8( SAR0B, 1 ) ;	// selects EASCI RX as source
		output8( SAR0L, ASCI_RX0_REG ) ;
		output8( SAR0H, 0 ) ;
			// set up dmode register
			//	src = I/O fixed (0000xx00b)
			//	dst = memory++  (00xx0000b)
		output8 ( DMODE, 0x0c ) ;

			//	set w.s. for on-line mode
		arm_set_wstates( TRUE ) ;

		arm_rx_dma = TRUE ;
		sendDumbChar('#');
	}

		// Destination register - lower 2 bytes
	output8( DAR0L, (byte)arm_dte_rx_wptr ) ;
	output8( DAR0H, (byte)((word)arm_dte_rx_wptr >> 8) ) ;

		// count - to end of buffer
	cnt = (word)(IO_DTE_RX_EPTR - arm_dte_rx_wptr) ;
	output8( BCR0L, (byte)cnt ) ;
	output8( BCR0H, (byte)(cnt>>8) ) ;

	//-------------------------------------------------
	//		Start ch0 DMA and enable CH0 interrupt.
	//-------------------------------------------------
#if defined( DMA_INT_DEBUG )
	ddputs_nnl("3: start ch0 DSTAT-"); sendHexByte(input8( DSTAT ));
#endif

	reg = input8( DSTAT ) ;
	output8( DSTAT, (reg & 0xaf) | 0x44 ) ;

#if defined( DMA_INT_DEBUG )
	reg = input8( DSTAT ) ;
	ddputs_nnl("; DSTAT-"); sendHexByte(reg);
	sendCrLf();
#endif
}

/****************************************************************
	Function : dma0ir
	This is the ISR for the DMA Channel 0. It is vectored to
	at the end of a DMA transfer.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void dma0ir ( void )
{
	byte reg ;

	if ( arm_rx_dma )
	{
		#if defined(FRM_HOST_DMA_TEST)
		if ( dma_test == 0x55 )
		{
			ddputs_nnl("Cause a DMA OVERRUN to occur!"); sendCrLf();
			dma_test = 0;
		}
		#endif // FRM_HOST_DMA_TEST

		//-------------------------------------------------
		//	Set-up for more received data
		//	(i.e. the whole buffer).
		//-------------------------------------------------
		#if 0
		arm_dte_rx_wptr = IO_DTE_RX_SPTR ;
		IO_DTE_RX_WPTR = IO_DTE_RX_SPTR ;
		#else

		// Check for data lingering in EASCI receive FIFO
		arm_dte_rx_wptr = IO_DTE_RX_SPTR ;
		while ( input8( ASCI_STAT0_REG ) & 0x80 ) {
			*arm_dte_rx_wptr++ = input8( ASCI_RX0_REG );
		}
		// Update write pointer
		IO_DTE_RX_WPTR = arm_dte_rx_wptr;
		#endif
		arm_start_rx_dma() ;

#if defined( RX_DMA_DEBUG )
		if ( arm_dma_debug ) sendDumbChar( 'i' ) ;
#endif

	}
	else
	{
		//-------------------------------------------------
		//	stop the DMA on Channel 0
		//-------------------------------------------------
#if defined( DMA_INT_DEBUG )
		ddputs_nnl("4: stop ch0 DSTAT-");
		sendHexByte(input8( DSTAT ));
#endif
		reg = input8( DSTAT ) ;
		output8( DSTAT, reg & 0x2b ) ;

#if defined( DMA_INT_DEBUG )
		ddputs_nnl(";  DSTAT-"); sendHexByte(input8( DSTAT ));
		sendCrLf();
#endif
#if defined( RX_DMA_DEBUG )

		if ( arm_dma_debug )
		{
			sendDumbChar( 'n' ) ;
			sendCrLf();
		}
#endif
	}
}

/****************************************************************
	Function : arm_stop_rx_dma
	returns the DMA channel to the Host TX channel for use with
	Software Flow control.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
void arm_stop_rx_dma ( void )
{
	if ( arm_rx_dma )
	{
		byte reg ;

		//-------------------------------------------------
		//	stop the DMA on Channel 0 and update the
		//	buffer ptr for subsequent EASCI RX interrupts.
		//-------------------------------------------------
#if defined( DMA_INT_DEBUG )
		ddputs_nnl("5: stop ch0 DSTAT-"); sendHexByte(input8( DSTAT ));
#endif
		reg = input8( DSTAT ) ;
		output8( DSTAT, reg & 0xab ) ;

		//-------------------------------------------------
		// if ch0 was active
		// but the ch0 bcr==0 then deactivate ch0
		//-------------------------------------------------
		if ( (reg & 0x40) && !(input8( BCR0H ) | input8( BCR0L )) )
		{
			output8( DSTAT, reg & 0x0f ) ;
#if defined( ARM_EASCI_TX_DMA )
			dmach1Flg = TRUE ;
#endif
		}

#if defined( DMA_INT_DEBUG )
		ddputs_nnl(";  DSTAT-"); sendHexByte(input8( DSTAT ));
		sendCrLf();
#endif
			// Destination register
		output8( DAR0B, 1 ) ;	// selects EASCI TX as destination
		output8( DAR0H, 0 ) ;
		output8( DAR0L, ASCI_TX0_REG ) ;
				// source register
		output8( SAR0B, (byte)0x00 ) ;
			// count
		output8( BCR0H, 0 ) ;
			// set up dmode register
			//	src = memory++
			//	dst = I/O fixed
		output8 ( DMODE, 0x30 ) ;
		arm_rx_dma = FALSE ;

		UART_Flush ( 0 ) ;

			// back to fixed # of w.s.
		arm_set_wstates( FALSE ) ;

		sendDumbChar('_');
	}
}
#endif	//if defined( ARM_EASCI_RX_DMA )

// Map z80_* to arm_*
void z80_uart_cd_off ( void ) { arm_uart_cd_off(); }
void z80_uart_cd_on ( void ) { arm_uart_cd_on(); }
void z80_uart_ri_off ( void ) { arm_uart_ri_off(); }
void z80_uart_ri_on ( void ) { arm_uart_ri_on(); }
void z80_uart_dsr_off ( void ) { arm_uart_dsr_off(); }
void z80_uart_dsr_on ( void ) { arm_uart_dsr_on(); }
void z80_uart_break_on ( void ) { arm_uart_break_on(); }
void z80_flow_on ( void ) { arm_flow_on(); }


//----------------------------------------------------------------
//	Externs for the Serial main() routine
//----------------------------------------------------------------
extern BAUD_RATE lst_s_62 ;
extern BOOL	arm_no_more_tx ;
extern BOOL	dtr_from_dte_on ;
extern BOOL	AUTOBAUDING ;
extern BOOL	in_xof_from_dte ;
extern BOOL	brk_to_dte_flg ;
extern word	brk_timer ;
extern word src_c_int ;
extern word	arm_max_dma ;				// size of DMA transfer.

extern void dp_task ( MODEM_COMMAND, byte *, word ) ;
extern void io_task ( MODEM_COMMAND, byte *, word ) ;
extern non_banked void arm_uart_cts_on( void ) ;
#if defined( ATHENA_LEDS )
word arm_athena_datatimer;
#endif

//----------------------------------------------------------------
//	Serial Debug print routine
//----------------------------------------------------------------
#if defined( ARM_DEBUG_PRINT )	// {

#define		FLASH_TIME		(1000)		// flash timer in ms

extern BOOL dmach0Flg, dmach1Flg ;
extern BOOL abon, aboff;
extern BOOL arm_flow_on_flag ;
extern word debug_rx_count ;

/****************************************************************
	Function : arm_dbug_print - External debug routine
*****************************************************************/
void arm_dbug_print ( void )
{
	word rx_cnt ;
	static word flash_timer ;			// timer for Break to DTE

	
#if defined( ARM_EASCI_RX_DMA )
	if ( dmach0Flg )
	{
		sendDumbChar('x');
		dmach0Flg = FALSE ;
	}
#endif
#if defined( ARM_EASCI_TX_DMA )
	if ( dmach1Flg )
	{
		sendDumbChar('y');
		dmach1Flg = FALSE ;
	}
#endif

	if ( abon )
	{
		if (!G(venusDebugToDTE))
			sendDumbChar('+');	// Print when not sending debug to DTE,
								// otherwise the screen is filled when
								// doing the constellation display.
		abon = FALSE ;
	}
	if ( aboff )
	{
		if (!G(venusDebugToDTE))
			sendDumbChar('-');
		aboff = FALSE ;
	}

	//------------------------------------------
	// flash CTS led if NOT online
	//------------------------------------------
	if ( arm_modem_state == WAITING_FOR_ONLINE_STATE )
	{
		if ( x_elapsed_time ( flash_timer ) > FLASH_TIME )
		{
			flash_timer = x_current_time () ;
			disable_interrupt () ;
				#if 0
				output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & BIT2 ?
							input8 ( DUMB_MCR ) & ~BIT2 :
							input8 ( DUMB_MCR ) | BIT2 ) ;
				#endif
				arm_uart_cts_led_toggle();
			enable_interrupt () ;
		}
	}

	//------------------------------------------
	// new high water mark reached in rx buffer
	//------------------------------------------
	if ( arm_flow_on_flag )
	{
		disable_interrupt () ;
			arm_flow_on_flag = FALSE ;
			rx_cnt = debug_rx_count ;
		enable_interrupt () ;
		x_debug_msg("Cnt="); sendHexWord(rx_cnt); sendCrLf();
	}
}
#endif	// } ARM_DEBUG_PRINT

#if defined( PNPSTRING )	// {
//==========================================================================
//			Time Parameters for Plug and Play
//==========================================================================
#define		MIN_PNP_TIME	(140)		// lower time limit (ms)
//#define		MAX_PNP_TIME	(260)		// upper time limit (ms)
// mah - 5/12/99 - this matches what works in the field,
// even though it doesn't really match the spec.
#define		MAX_PNP_TIME	(900)		// upper time limit (ms)

//==========================================================================
//					Externs for PnP functions
//==========================================================================
/* extern */ byte PnPstr [ 256 ] ;
extern word PnP_timer ;
extern PLUGNPLAY PnP_state;
extern word PnP_count ;
extern byte read_eeprom ( word loc ) ;
extern const byte str_convert[];

//================================================================
//		Plug and Play Functions.
//================================================================
// The following functions support the Windows 95 PnP feature
// for the serial modem.  The modem is always monitoring DTR
// and RTS for the following time critical protocol:
//
//	        |<- T1 ->|<- T2 ->|<- T3 ->|
//	        |        |        |        |
//	DTR -------------+        +--------------//
//	                 |        |
//	RTS ----+        +--------+        +-----//
//	        |                          |
//	        +--------------------------+
//
// Once the DCE (modem) sees this protocol, it responds by
// transmitting the stored PnP sequence, if one is available.
//================================================================

/****************************************************************
	Function : Plug & Play Protocol checker.
	If current state is same as input state and elapsed
	time since entering this state is within spec,
	(160 to 240 ms) then transition to next state,
	Otherwise return to initial state.
*****************************************************************/
void PnP_chkstate ( PLUGNPLAY state )
{
	word delta ;

	delta = x_elapsed_time ( PnP_timer ) ;
	PnP_timer = x_current_time () ;
	if ( (PnP_state == state)
		&& (delta > MIN_PNP_TIME) && (delta < MAX_PNP_TIME) )
	{
		PnP_state++;
	}
	else
	{
		PnP_state = T0 ;
	}
}

/****************************************************************
	Function : Plug & Play Protocol Initializer.
	Sets current state to input state and starts timer.
*****************************************************************/
void PnP_setstate ( PLUGNPLAY state )
{
	PnP_state = state ;
	PnP_timer = x_current_time () ;
}

/****************************************************************
	Function : Plug & Play chksum calculation.
*****************************************************************/
byte arm_PnP_chksum ( void )
{
	word loc ;
	byte data ;

	data = 0 ;
	for ( loc=PNP_START_LOC; loc<PNP_CHKSUM; loc++ )
	{
		data += read_eeprom ( loc ) ;
	}
	return data ;
}
byte z80_PnP_chksum() {
	return arm_PnP_chksum();
}

/****************************************************************
	Function : Plug & Play builder.
	Builds enumeration sequence from either serial eeprom
	(or default pnp string if eeprom not loaded).
*****************************************************************/
void PnP_buildit ( BOOL ascii )
{
	byte bitmap, chksum, data, extend_flag, i;
	byte dest[80], *bp, *bp1 ;
	word loc, major_num, minor_num ;

	x_debug_msg("PnP_buildit");

	// read current contents of PnP storage
	bitmap = read_eeprom ( PNP_BITMAP ) ;

	///////////////////////////////////////////
	// EISA Mfr ID & Product ID are required
	// fields.  Also check PNP_CHKSUM
	///////////////////////////////////////////
	if (	!(bitmap & PNP_EISA_BIT)
		||	!(bitmap & PNP_PROD_BIT)
		||	(arm_PnP_chksum() != read_eeprom ( PNP_CHKSUM )) )
	{
		///////////////////////////////////////////
		// if not there or corrupted then build
		// default enumeration sequence.
		///////////////////////////////////////////
		strcpy( PnPstr, (const byte *)PNPDEFAULT ) ;
		goto PnPchksum ;
	}

	/////////////////////////////////
	// serial eeprom is good.
	// start building enum seq.
	/////////////////////////////////
	bp = PnPstr ;
	extend_flag = FALSE ;

	*bp++ = S.ModemOptions.CRChar ;
	*bp++ = S.ModemOptions.LFChar ;

	// begin PnP
	*bp++ = '(' ;

	// PnP Revision Code
	strcpy( dest, PNPSTRING ) ;
	bp1 = dest ;
	if ( ascii )
	{
		// PnP Revision Code in human readable form
		for ( i=0; i<5 && *bp1 != 0; i++, bp++ )
		{
			*bp = *bp1++ ;
		}
	}
	else
	{
		// PnP Revision Code (2 6bit chars)
		bp1 += at_atoi ( bp1, &major_num, DECIMAL ) ;
		if ( *bp1++ != '.' )
		{
			strcpy( PnPstr, (const byte *)PNPDEFAULT ) ;
			goto PnPchksum ;
		}

		if ( at_atoi ( bp1, &minor_num, DECIMAL ) != 2 )
		{
			strcpy( PnPstr, (const byte *)PNPDEFAULT ) ;
			goto PnPchksum ;
		}

		major_num *= 100 ;
		major_num += minor_num ;
		*bp = (major_num >> 6) & 0x3f ;
		*(bp+1) = major_num & 0x3f ;
		if (	(*bp == 0x09) || (*(bp+1) == 0x09)
			||	(*bp == 0x29) || (*(bp+1) == 0x29) )
		{
			strcpy( PnPstr, (const byte *)PNPDEFAULT ) ;
			goto PnPchksum ;
		}
		bp += 2 ;
	}

	// EISA Mfr ID (3 chars)
	*bp++ = read_eeprom ( PNP_EISA_ID ) ;
	*bp++ = read_eeprom ( PNP_EISA_ID+1 ) ;
	*bp++ = read_eeprom ( PNP_EISA_ID+2 ) ;

	// Product ID
	data = read_eeprom ( PNP_PROD_ID ) ;
	*bp++ = str_convert[ (byte)((data>>4) & 0xf) ];
	*bp++ = str_convert[ (byte)(data & 0xf) ];
	data = read_eeprom ( PNP_PROD_ID+1 ) ;
	*bp++ = str_convert[ (byte)((data>>4) & 0xf) ];
	*bp++ = str_convert[ (byte)(data & 0xf) ];

	// Serial Number
	*bp++ = '\\' ;
	if ( bitmap & PNP_SERNO_BIT )
	{
		loc = PNP_SERIAL_NO ;
		for ( i=0; i<4; i++ )
		{
			data  = read_eeprom ( loc++ ) ;
			*bp++ = str_convert[ (byte)((data>>4) & 0xf) ];
			*bp++ = str_convert[ (byte)(data & 0xf) ];
		}
	}

	// Class Name
	*bp++ = '\\' ;
	*bp++ = 'M' ;
	*bp++ = 'O' ;
	*bp++ = 'D' ;
	*bp++ = 'E' ;
	*bp++ = 'M' ;

	// Conpatible Driver IDs
	if ( bitmap & PNP_DEVID_BIT )
	{
		*bp++ = '\\' ;
		loc = PNP_DEVICE_ID ;
		for ( i=0; i<40; i++, bp++ )
		{
			*bp = read_eeprom ( loc++ ) ;
			if ( *bp == 0 )
			{
				break ;
			}
		}
	}
	else
	{
		extend_flag = TRUE ;
	}

	// User Name
	if ( bitmap & PNP_USER_BIT )
	{
		if ( extend_flag == TRUE )
		{
			*bp++ = '\\' ;
		}
		*bp++ = '\\' ;
		loc = PNP_USER_NAME ;
		for ( i=0; i<40; i++, bp++ )
		{
			*bp = read_eeprom ( loc++ ) ;
			if ( *bp == 0 )
			{
				break ;
			}
		}
		*bp++ = ';' ;
	}

	// add null char at end for
	//checksum calculations below
	*bp = 0 ;

PnPchksum:
	/////////////////////////////////////////////////
	// Checksum (2 hex chars)
	// from start PnP thru end PnP self exclusive
	/////////////////////////////////////////////////
	chksum = ')' ;
	bp = PnPstr + 2 ; // don't include initial CR LF.
	while ( *bp )
	{
		chksum += *bp++;
	}
	*bp++ = str_convert[ (byte)((chksum>>4) & 0xf) ] ;
	*bp++ = str_convert[ (byte)(chksum & 0xf) ];

	// end PnP
	*bp++ = ')' ;

	*bp++ = S.ModemOptions.CRChar ;
	*bp++ = S.ModemOptions.LFChar ;
	*bp = 0 ;

	if ( !ascii )
	{
		// add 2nd stop bit
		bp = PnPstr ;
		while ( *bp )
		{
			*bp++ |= 0x80 ;
		}
	}

	return ;
}

/****************************************************************
	Function : Plug & Play Identifier.
	Sends enumeration sequence to the DTE.
*****************************************************************/
void PnP_identify ( BOOL ascii )
{
	BAUD_RATE brate ;
	byte *ptr ;
	extern BAUD_RATE s_62 ;

	///////////////////////////////////////////////////////
	// build the enumeration sequence to send to the DTE
	// two versions are supported; a machine readable one
	// and a human readable one.  In the machine case, the
	// link is converted to 1200 baud 7 bit two stop bit.
	//
	// Also in the machine case, the sequence has already
	// been built and stored in PnPstr.
	///////////////////////////////////////////////////////
	if ( ascii )
	{
		PnP_buildit ( TRUE ) ;
	}
	else
	{
		///////////////////////////////////
		//	Machine Enumeration sequence!!
		///////////////////////////////////
		//	format of ID is a ten bit frame:
		//		one start bit;
		//		8 bit frame with MSB=1;
		//		one stop bit.
		//	delivered at 1200 BPS.
		///////////////////////////////////
		disable_interrupt () ;
			brate = s_62 ;
			s_62 = BR1200 ;
			#if defined(OCM)
			arm_stop_autobaud () ;
			#endif
			s_62 = brate ;
		enable_interrupt () ;

		// Add parity
		at_parity = 0 ;	// no parity
	}

	ptr = PnPstr ;
	x_send_mail ( AT_IO_DATA, IO_TASK, ptr, x_strlen ( ptr ) ) ;

	// Rebuild the machine readable form.
	if ( ascii )
	{
		PnP_buildit ( FALSE ) ;
	}
}
#endif	// } PNPSTRING


/****************************************************************
	Function : init_arm_asci
*****************************************************************/
void init_arm_asci ( void )
{
#if defined(OCM)
			// reset Rx channel - CTS OFF
	easci_output ( ASCI_CTLA0_REG, ASCI_RTS ) ;
			// clear the BRG...
	easci_output ( ASCI_TCLO_REG, 0 ) ;
	easci_output ( ASCI_TCHI_REG, 0 ) ;
			// select clock source and speed select
			// (not necessary for VENUS)
	easci_output ( ASCI_CTLB0_REG, 0 ) ;
			// enable break detection & internal clock;
			// disable auto tx/rx enable (tx enable will
			// be enabled later);
			// select divide by 1 mode for VENUS
	easci_output ( ASCI_XCR0_REG, BRK_ENABLE | BRG0_MODE
				 | CTS0_DISABLE | DCD0_DISABLE | X1_BIT_CLK ) ;

			// enable tx & rx to DTE.
			//  (As in the ESCC, our RTS is wired to the DTE CTS
			//  which we want OFF here)
			// clear any errors in rx (frame or overrun)
			// setup mode = 8 data + 1 stop (no parity)
	easci_output ( ASCI_CTLA0_REG, TX_ENABLE | RX_ENABLE | MOD_2 | ASCI_RTS ) ;

			// enable additional interrupt sources for VENUS
			// and clear autobaud enable.
	easci_output ( A0INTIN, A0INTIN_VAL ) ;
	easci_output ( A0NEWCTL , 0 ) ;

			// enable rx interrupts (tx handled by main())
	easci_output ( ASCI_STAT0_REG , RX_INT_ENABLE ) ;

#if defined( ARM_EASCI_TX_DMA )
			//-----------------------------------------------------
			// initialize DMA channel 1 for EASCI TX
			// the following registers can be initialized once
			//-----------------------------------------------------
	output8( MAR1B, 0xf ) ;	// high byte of DMA source register
			// Destination register
	output8( IAR1B, 1 ) ;	// selects EASCI TX as destination
	output8( IAR1H, 0 ) ;
	output8( IAR1L, ASCI_TX0_REG ) ;
			// upper byte of count - as long as we keep the packet
			// size to the host below 256 bytes this value should
			// not need reloading.
	output8( BCR1H, 0 ) ;

			//-----------------------------------------------------
			// initialize DMA channel 0 for EASCI TX
			// (for use in SW Flow control)
			//-----------------------------------------------------
			// Upper byte of source register
	output8( SAR0B, (byte)0x00 ) ;
			// Destination register
	output8( DAR0B, 1 ) ;	// selects EASCI TX as destination
	output8( DAR0H, 0 ) ;
	output8( DAR0L, ASCI_TX0_REG ) ;
			// upper byte of count
	output8( BCR0H, 0 ) ;
			// set up dmode register
			//	src = memory++
			//	dst = I/O fixed
	output8 ( DMODE, 0x30 ) ;
	#if 0	// Done in arm_set_wstates()
			//	set ch0 & ch1 dma to edge/lvl sense
			//	dma ch0=edge sense; dma ch1=edge sense
	output8 ( DCR, input8( DCR ) | 0x0c ) ;
	#endif
#endif

	//---------------------------------------------
	// Note: there is a bug in Venus2 that prevents
	// the first table location from being loaded
	// into the BRG counter; So we autobaud only
	// with last three table entries
	// (equivalent to the NMI algorithm).
	//---------------------------------------------
	easci_output( XACTCNT0L, 1 );
	easci_output( XACTCNT0H, 0 );

	// counter value for 230.4
	easci_output( XACTCNT1L, BR230400_2 & 0xff );
	easci_output( XACTCNT1H, BR230400_2 >> 8 );

	// counter value for 115.2
	easci_output( XACTCNT2L, BR115200_2 & 0xff );
	easci_output( XACTCNT2H, BR115200_2 >> 8 );

	// counter value for 57.6
	easci_output( XACTCNT3L, BR57600_2 & 0xff );
	easci_output( XACTCNT3H, BR57600_2 >> 8 );
#endif //OCM
}

#if 0
/****************************************************************
	Function : init_arm_hardware for Serial Modem
*****************************************************************/
void init_arm_hardware ( word prt0_time )
{
		//--------------------------------------------------------------
		// Set system Wait States for command mode.
		//--------------------------------------------------------------
	arm_set_wstates(FALSE);

		// Set PRT0 time contant
	prog_timer(prt0_time);

		// initialize the EASCI - only channel 0
		// is used for communications with the DTE
		// (VENUS only has channel 0).
	init_arm_asci();

		// initialize BIO parallel port registers,
	x_output_init();

		// DSR to DTE was just set!
		// So initialize PnP control variables:
#if defined( PNPSTRING )
	PnP_setstate(T0);
#endif

		// Enable DSP - allow time for DSP to initialize the
		// CAMILZ register set then we will set them the way
		// we want them below.
	dp_regwrite(0xde, 0x50);	// Enable DSP

		// disable all interrupts on camil
	dp_regwrite( 0xd7, 0xff ) ;
	dp_regwrite( 0xd8, 0xff ) ;

		// Now set up CAMILZ registers.
	dp_regwrite(0xca, 0x00);	// disable host pc access to MIMIC (MCAD)
								// and DIA (for DSP access)
	dp_regwrite(0xda, 0x16);	// call progress through SIO and
								// IOCS2 for Serial Dumb Terminal
	dp_regwrite(0xc0, 02);		// enable SERIAL Scenario
	dp_regwrite(0xdf, 1);		// enable pin master

	// enable all interrupts
	enable_interrupt();

	// Start the DPLL Zinger clock for VENUS2
	// We will switch to it later in
	// arm_set_wstates() when we go online
	arm_init_venus2();
}
#endif

#if defined(OCM)
/****************************************************************
	Function : easci BAUD RATE 
*****************************************************************/
void easci_baud_rate ( void )
{
	extern BAUD_RATE s_62 ;

	//------------------------------------------------------
	// set up the baud rate registers based on the dte rate
	//------------------------------------------------------
	switch ( s_62 )
	{
		case BR150 :
		case BR300 :
			S.ModemOptions.DteRate = DTE_300 ;
			break ;
		case BR600 :
			S.ModemOptions.DteRate = DTE_600 ;
			break ;
		case BR1200 :
			S.ModemOptions.DteRate = DTE_1200 ;
			break ;
		case BR2400 :
			S.ModemOptions.DteRate = DTE_2400 ;
			break ;
		case BR4800 :
			S.ModemOptions.DteRate = DTE_4800 ;
			break ;
		case BR9600 :
			S.ModemOptions.DteRate = DTE_9600 ;
			break ;
		case BR14400 :
			S.ModemOptions.DteRate = DTE_14400 ;
			break ;
		case BR19200 :
		default :
			S.ModemOptions.DteRate = DTE_19200 ;
			break ;
		case BR38400 :
			S.ModemOptions.DteRate = DTE_38400 ;
			break ;
		case BR57600 :
			S.ModemOptions.DteRate = DTE_57600 ;
			break ;
		case BR115200 :
			S.ModemOptions.DteRate = DTE_115200 ;
			break ;
		case BR230400 :
			S.ModemOptions.DteRate = DTE_230400 ;
			break ;
	}

	S.ModemOptions.OldLineRate = (byte) s_62;
	x_debug_msg( "New DTErate=" ) ;
	sendHexByte( S.ModemOptions.DteRate ) ; sendCrLf();
}

/****************************************************************
	Function : arm_chk_isr_chg
	Handles things signalled by interrupt. Since we shouldn't call
	apps routines from an ISR we set flags and check them here.
*****************************************************************/
void arm_chk_isr_chg ( void )
{
	extern BOOL brk_from_dte_on, brk_from_dte_off, setXflag;

	//==============================================
	//	Have there been any changes in DTR?
	//==============================================
	//---------------------------------------------
	// For VENUS, DTR changes from host
	// are notified by interrupt and PnP state
	// transitions are handled in the ISR.
	//---------------------------------------------
	if ( !( easci_input ( ASCI_STAT0_REG ) & DCD0) )
	{
		// DTR is SET by the DTE !!
		if ( !dtr_from_dte_on )
		{
			dtr_from_dte_on = TRUE ;
			UART_dtr_on () ;
		}
	}
	else
	{
		// DTR is NOT SET !!
		if ( dtr_from_dte_on )
		{
			dtr_from_dte_on = FALSE ;
			UART_dtr_off () ;
		}
	}
	//==============================================
	//	End changes to DTR?
	//==============================================

	//==============================================
	//	Have there been any changes in BRK from DTE?
	//==============================================
	if ( brk_from_dte_on )
	{
		// Yes - DTE has sent a break
		UART_start_break () ;
		brk_from_dte_on = FALSE ;
		// brk_from_dte_off variable used in z80189 mode
		// as "looking for end of break" flag.
		brk_from_dte_off = TRUE ;
	}
	if ( brk_from_dte_off == TRUE )
	{
		// look to see if the Tx from DTE has returned
		// to a high state.
		if ( dp_regread( 0xBB ) & BIT6 )
		{
			// DTE has cleared the break condition.
			UART_stop_break () ;
			brk_from_dte_off = FALSE ;
			//output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & ~BIT3 ) ;
			arm_uart_rts_led_off();
		}
	}

	//================================================
	//	Have there been any changes in SW FC from DTE?
	//================================================
	if ( (arm_modem_state == SW_ON_LINE_STATE) && setXflag )
	{
		if ( in_xof_from_dte )
		{
			// Yes - DTE has sent an XOFF
			UART_xoff_off () ;
		}
		else
		{
			// Yes - DTE has sent an XON
			UART_xoff_on () ;
		}
		setXflag = FALSE ;
	}
}
#endif

#if defined(ARM_READ_UART_DEBUG)
void arm_parsechar ( byte ch )
{
	if ( !dumbPortPresent ) return;

	#if defined(ROM_FLASH)
	/* if ^D exit */
	if ( ch == 0x04 )
	{
		x_debug_msg("\r\nback to RRFL Dispatcher");
		arm_jump_abs( *((word *)0x52), 0x00 ) ;
		sendCrLf();
	}
	else
	#endif	// ROM_FLASH

	if ( ch == 'd' )
	{
		x_debug_msg("\r\n\r\n From Host :");
		x_debug_msg("     DTE wp=");  sendHexWord((word)I(io_dte_rx_wptr));
		x_debug_msg("; DTE rp=");    sendHexWord((word)I(io_dte_rx_rptr));

		x_debug_msg("\r\n To Host :");
		x_debug_msg("     DTE wp=");  sendHexWord((word)I(io_dte_tx_wptr));
		x_debug_msg("; DTE rp=");    sendHexWord((word)I(io_dte_tx_rptr));
		sendCrLf();
	}
	else

	#if defined(FRM_HOST_DMA_TEST)
	if ( ch == 'b' || ch == 'B' )
	{
		dma_test = 0x55;
	}
	else
	if ( ch == 'D' || ch == 'd' )
	{
		x_debug_msg("cnt="); sendHexWord(uart_rx_count);
		x_debug_msg(" wp="); sendHexWord((word)IO_DTE_RX_WPTR);
		x_debug_msg(" rp="); sendHexWord((word)IO_DTE_RX_RPTR);
		x_debug_msg(" dmad=");
		sendHexWord((word)(input8(DAR0L)|(input8(DAR0H)<<8))) ;
		x_debug_msg(" dmac=");
		sendHexWord((word)(input8(BCR0L)|(input8(BCR0H)<<8))) ;
		x_debug_msg(" dstat="); sendHexByte(input8(DSTAT)) ;
		x_debug_msg(" dmode="); sendHexByte(input8(DMODE)) ;
		x_debug_msg(" dcr="); sendHexByte(input8(DCR)) ;
		x_debug_msg(" as_st="); sendHexByte(easci_input(ASCI_STAT0_REG)) ;
		sendCrLf();
	}
	else
	if ( ch == '+' )
	{
		// do a full (cold) start of DMA
		arm_dte_rx_wptr = IO_DTE_RX_WPTR ;
		arm_rx_dma = FALSE;
		arm_start_rx_dma();
		G(io_at_esc_detect) = TRUE;
		x_send_mail(AT_OK, AT_TASK, 0, 0 );
	}
	else
	#endif // FRM_HOST_DMA_TEST
	{
		while (!(input8(DUMB_LSR) & 0x20))
			;
		output8(DUMB_DATA, ch);
	}
}
#endif	// ARM_READ_UART_DEBUG

/****************************************************************
	Function : Main routine for the Serial modem
*****************************************************************/
#if defined(OCM)
void arm_ser_main ( void )
{
	word isrTimer = 0;

	arm_modem_state = INITIAL_STATE;
	// init non zero variables
	s_62 = BR19200 ;			// this sreg value is the default baudrate		

	arm_no_more_tx = TRUE ; 	// SCC - dte transmit reset pending bit set
	uart_flow_control = FC_OFF ;

	#if defined( ARM_EASCI_TX_DMA )
	arm_max_dma = ARM_MAX_HW_DMA ;
	#endif
	#if defined(TX_DMA_DEBUG) || defined(RX_DMA_DEBUG)
	arm_dma_debug = TRUE ; // For DEBUG
	#endif
	#ifdef G729A
	start_record = FALSE;
	start_play = FALSE;
	#endif

	enableDumbPort();

	// init Z80 peripheral's
	//init_z80_hardware (PRT0_TIME) ;

	// init ARM's peripheral's
	arm_hardware_init ();

	#if !defined( ROM_FLASH ) && defined( ROM )
	x_debug_msg( "Rom Checksum" ) ;
	if ( arm_checksum ( FALSE ) == FALSE )	// rom checksum test
	{
		x_debug_msg( "Rom Failure" ) ;
		#if 0
		strcpy( PnPstr, (const byte *)"Rom Failure" ) ;
		fatal_error ( "Rom Failure" ) ;
		#endif
	}
	#endif

	// init modem task - variables
	x_debug_msg("UART_init");
	if (FAILED == UART_init())
	{
		x_debug_msg("Data Pump Failure");
		strcpy( PnPstr, (const byte *)"Data Pump Failure" ) ;
		fatal_error ( PnPstr ) ;
		// never returns
	}

	if (S.ModemOptions.OldLineRate)
		s_62 = S.ModemOptions.OldLineRate;

	// look at DTR and set variables
	if ( !( easci_input ( ASCI_STAT0_REG ) & DCD0) )
	{
		dtr_from_dte_on = TRUE;
		x_debug_msg("Init DTR ON");
		UART_dtr_on();
	}
	else
	{
		dtr_from_dte_on = FALSE;
		x_debug_msg("Init DTR OFF");
		UART_dtr_off();
	}

	arm_uart_cts_on();

	while ( TRUE )           		      // forever loop
	{
		//==============================================
		// call the modem background tasks
		// to execute periodic routines
		//==============================================
		dp_task ( MC_PERIODIC, NULL, 0 ) ;

		io_task ( MC_PERIODIC, NULL, 0 ) ;

		#if defined(OCM)
		if ( !AUTOBAUDING ) arm_chk_autobaud() ;
		#endif

		//====================================================
		// IF we go on-line and HW FC is currently selected:
		//	1)	set auto enable mode of EASCI TX channel for
		//		flow control from the host (RTS), and
		//	2)	enable RX DMA on ch0.
		// IF we go on-line and SW FC is in use:
		//	1)	set software flow control flag - used in
		//		serial channel (EASCI/ESCC) RX ISR, and
		//	2)	establish ch0 dma in "to-host" direction for
		//		sending XOFF chars.
		//====================================================
		if ( (x_modem_mode == MODEM_DATA) &&
			 (x_modem_state == MS_ON_DIAL) &&
			 (io_at_esc_detect == FALSE) )
		{
			if ( arm_modem_state == WAITING_FOR_ONLINE_STATE )
			{
				if ( io_uart_status & UART_CD_ON )
				{
					//---------------------------------------------------
					//	turn off Autobauding
					//---------------------------------------------------
					disable_interrupt() ;
						if ( AUTOBAUDING ) arm_stop_autobaud() ;
					enable_interrupt() ;

					if ( S.ModemOptions.FlowControl == SW_FLOWCTRL )
					{
						x_debug_msg("Entering SWFC OnLine");

						arm_modem_state = SW_ON_LINE_STATE ;

						#if 0
						//---------------------------------------------------
						// turn off RTS auto control of TX channel
						//---------------------------------------------------
						easci_output ( ASCI_XCR0_REG,
								 easci_input( ASCI_XCR0_REG ) | CTS0_DISABLE ) ;
						easci_output ( A0INTIN,
								easci_input( A0INTIN ) &
									~(CTS_HL_INT_ENABLE|CTS_LH_INT_ENABLE) ) ;
						#else
						arm_uart_disable_rts_auto_control();
						arm_uart_disable_rts_irq();
						#endif

						#if defined( ARM_EASCI_TX_DMA )
						//---------------------------------------------------
						// set SW FC dma packet size for "to-host" direction.
						//---------------------------------------------------
						arm_max_dma = ARM_MAX_SW_DMA ;
						#endif
					}
					else // if ( S.ModemOptions.FlowControl == HW_FLOWCTRL )
					{
						//---------------------------------------------------
						// HW Flow Control & No Flow Control treated the same
						//---------------------------------------------------
						x_debug_msg("Entering HWFC OnLine");

						arm_modem_state = HW_ON_LINE_STATE ;

						#if 0
						//---------------------------------------------------
						// turn on RTS auto control of TX channel
						//---------------------------------------------------
						easci_output ( ASCI_XCR0_REG,
								easci_input( ASCI_XCR0_REG ) & ~CTS0_DISABLE ) ;

						easci_output ( A0INTIN,
								easci_input( A0INTIN ) &
									~(CTS_HL_INT_ENABLE|CTS_LH_INT_ENABLE) ) ;
						#else
						arm_uart_enable_rts_auto_control();
						arm_uart_disable_rts_irq();
						#endif

						#if defined( ARM_EASCI_TX_DMA )
						//---------------------------------------------------
						// set HW FC dma packet size for "to-host" direction.
						//---------------------------------------------------
						arm_max_dma = ARM_MAX_HW_DMA ;
						#endif

						#if defined( ARM_EASCI_RX_DMA )
						//---------------------------------------------------
						// start up the "from-host" side dma on ch0
						//---------------------------------------------------
						// note: the receive char interrupt is left enabled
						// for it will be blocked in hardware by the DMA
						// request. Errors however, (e.g. frame, break detect)
						// will still cause an interrupt.
						//---------------------------------------------------
						disable_interrupt() ;
							arm_dte_rx_wptr = IO_DTE_RX_WPTR ;
							arm_start_rx_dma() ;
						enable_interrupt() ;
						#endif

						#ifdef SYNCH_MODE
						if ( S.ModemOptions.V42 == V42_SYNCH_MODE )
						{
							extern void valv_setup(void);
							extern void dp_draco_timing_loop(void);
							x_debug_msg("Begin Synchronous Mode");
							valv_setup();
							dp_modem_command_long ( PDM, HDLC_FLAG, 0x01, (byte)SYNC_DATA_MODE, 0);
							dp_draco_timing_loop();
						}
						#endif
					}
				}
			}
		}
		else if ( arm_modem_state != WAITING_FOR_ONLINE_STATE )
		{
			x_debug_msg( "NOT OnLine" ) ;

			arm_modem_state = WAITING_FOR_ONLINE_STATE ;

			#if 0
			//---------------------------------------------------
			// turn off RTS auto control of TX channel
			//---------------------------------------------------
			easci_output ( ASCI_XCR0_REG,
						 easci_input( ASCI_XCR0_REG ) | CTS0_DISABLE ) ;

			//---------------------------------------------------
			// turn on RTS interrupts for PnP
			//---------------------------------------------------
			easci_output ( A0INTIN,
						easci_input( A0INTIN ) |
							(CTS_HL_INT_ENABLE|CTS_LH_INT_ENABLE) ) ;
			#else
			arm_uart_disable_rts_auto_control();
			arm_uart_enable_rts_irq();
			#endif

			//---------------------------------------------------
			// set HW dma packet size for "to-host" direction.
			//---------------------------------------------------
			#if defined( ARM_EASCI_TX_DMA )
			arm_max_dma = ARM_MAX_HW_DMA ;
			#endif

			#if defined( PNPSTRING )
			if ( !io_at_esc_detect )
			{
				//---------------------------------------------------
				// Build the PnP enumeration sequence from the serial
				// eeprom. This string resides in the V42Bis/MNP
				// Dictionary area. Note: V42BIS can recover if this
				// area is corrupted but MNP[4/5] cannot.  Therefore,
				// do not rebuild the PnP string in this area for
				// momentary escapes (+++).
				//---------------------------------------------------
				x_debug_msg( "Rebuild PnP" ) ;
				PnP_buildit ( FALSE ) ;
			}
			#endif	// PNPSTRING

			#if defined( ARM_DEBUG_PRINT )
			debug_rx_count = 0;
			#endif
		}

		//==============================================
		// First we handle the Receive side from the DTE.
		//==============================================
		// If we are on-line, check to see if FlowControl
		// has been set. If we have been on-line and have
		// had flow control set, then check to see if we
		// we can now release it.
		//==============================================
		if ( uart_flow_control != FC_OFF )
		{
			#if !defined( ARM_EASCI_TX_DMA )
			if ( uart_flow_control == FC_OFF_TO_ON )
			{
				// Too many chars rcvd from host - apply back pressure
				// in the form of an XOFF (we are in software flow control).
				io_put_dte_tx_char ( XOFF ) ; 	// XOFF to host - 0x13
				uart_flow_control = FC_ON ;
			}
			else // if ( uart_flow_control == FC_ON )
			#endif
			{
				// IF the DTE IS currently being back pressured AND
				//   we now have room in our Rx buffer THEN undo it!!!
				if ( uart_rx_count <= HOST_RX_BUFF_EMPTY )
				{
					arm_flow_off();
				}
			}
		}
		else
		{
			// Check for the case of a stalled upload.
			// Has CTS been ON for a while with no
			// data coming from the DTE?
			arm_check_stall();
		}

		//==============================================
		//	Now we handle the transmit side to the DTE
		//==============================================
		// IF there is data to transmit to the DTE AND
		//   the send side of the ESCC/EASCI is IDLE
		// THEN look to restart the transmitter.
		//==============================================
		if ( arm_no_more_tx && (IO_DTE_TX_WPTR != IO_DTE_TX_RPTR) )
		{
			//=================================================
			// IF on-line AND the DTE has entered flow-control
			// THEN do NOT restart transmiting data to the DTE
			//=================================================
			if ( ((S.ModemOptions.FlowControl == HW_FLOWCTRL) &&
					!(easci_input ( ASCI_CTLB0_REG ) & ASCI_CTS) )
				|| io_state < IO_ONLINE
				|| io_at_esc_detect
				|| ((S.ModemOptions.FlowControl == SW_FLOWCTRL) &&
					!in_xof_from_dte)
				|| (S.ModemOptions.FlowControl == NO_FLOWCTRL) )
			{
				// Send a character to start the transmit side again
				disable_interrupt () ;
				{
					if ( AUTOBAUDING )
					{
						arm_stop_autobaud () ;
					}
					arm_no_more_tx = FALSE ;
					#if defined( ARM_EASCI_TX_DMA )
					#if defined( TX_DMA_DEBUG )
					if ( arm_dma_debug ) sendDumbChar( 'z' ) ;
					#endif
					// DMA mode
					enable_interrupt () ;
						arm_start_tx_dma() ;
					disable_interrupt () ;
					#else
					// Non DMA mode
					easci_output( ASCI_STAT0_REG,
							easci_input( ASCI_STAT0_REG ) | TX_INT_ENABLE ) ;
					easci_output( ASCI_TX0_REG, *IO_DTE_TX_RPTR ) ;
					if ( ++IO_DTE_TX_RPTR >= IO_DTE_TX_EPTR )
					{
						IO_DTE_TX_RPTR = IO_DTE_TX_SPTR ;
					}
					#endif
				}
				enable_interrupt () ;
			}
		}

		//==============================================
		// Check for Break condition set to DTE
		// and reset after Break time has expired.
		//==============================================
		if ( (brk_to_dte_flg == TRUE)
		 	 && (x_elapsed_time ( brk_timer ) > BRK_TIME) )
		{
			easci_output( ASCI_XCR0_REG,
						easci_input( ASCI_XCR0_REG ) & ~SEND_BRK ) ;
			#if defined(ARM_DEBUG_PRINT)
			//output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & ~BIT3 ) ;
			arm_uart_rts_led_off();
			#endif

			brk_to_dte_flg = FALSE ;
		}

		#if defined( PNPSTRING )
		//==============================================
		// IF Enumeration sequence has been received
		// from DTE Send PnP COM ID string to DTE
		//==============================================
		if ( PnP_state == T4 )
		{
			PnP_count ++ ;
		
			// Init PnP state
			PnP_setstate ( T0 ) ;

			PnP_identify ( FALSE ) ;
			x_debug_msg( "PnP Sequence Sent" );
		}
		#endif	// PNPSTRING

		if ( isrTimer != x_current_time() )
		{
			arm_chk_isr_chg() ;
			isrTimer = x_current_time();
		}

		if ( s_62 != lst_s_62 )
		{
			easci_baud_rate() ;
			lst_s_62 = s_62 ;
		}

		//------------------------------------------------
		//------------------------------------------------
		if ( src_c_int > 255 )
		{
			if ( (x_modem_mode == MODEM_DATA) &&
				 (x_modem_state == MS_ON_DIAL) )
			{
				// load factory default settings
				x_init_modem_options () ;
				// load settings if saved in eeprom
				ll_load_modem_options () ;
				x_send_mail ( AT_IO_DISCONNECT, IO_TASK, NULL, 0 ) ;
			}
			src_c_int = 0 ;
		}
		else 
		{
			disable_interrupt () ;
				if ( src_c_int ) src_c_int-- ;
			enable_interrupt () ;
		}

		#if defined(ARM_DEBUG_PRINT)
		arm_dbug_print() ;
		#endif

		#if defined(ATHENA_LEDS)
		if (x_elapsed_time(arm_athena_datatimer) > MS100)
		{
			if ((IO_DTE_TX_WPTR != IO_DTE_TX_RPTR) ||
				(IO_DTE_RX_WPTR != IO_DTE_RX_RPTR))
			{
				// data in DTE TX or RX buffer means data is flowing
				x_output(IO_DATA_LED_TOGGLE);
			}
  			else
			{
				x_output(IO_DATA_LED_OFF);
			}
	  		arm_athena_datatimer = x_current_time();
		}
		#endif	// ATHENA_LEDS
	}
}
#endif // OCM

// ********************************************
// These next variables are used
// for the upload stuck while CTS
// ON workaround implemented in z80_flow_off()
word	io_flow_on_timestamp;
volatile byte	*io_dte_rx_wptr_fix;
BOOL	io_check_flow_off2on_stall;
// ********************************************
#if !defined(CS_MODEM)	// {
#if !defined(USB_MODEM)	// {
/****************************************************************
	Function : arm_check_stall

	Check to see if the host has stalled with CTS ON.
	If so, assume it is stuck and give it a kick by
	toggling CTS.

	Precondition:
		uart_flow_control == FC_OFF - not backpressuring the
			DTE, (not telling it it can't send us more characters)

*****************************************************************/
void arm_check_stall(void)
{
	if ( io_check_flow_off2on_stall &&
		 (MODEM_DATA == G(x_modem_mode)) &&
			 (G(S).ModemOptions.FlowControl == HW_FLOWCTRL) )
	{
		if ( x_elapsed_time(io_flow_on_timestamp) > MS500 )
		{
			io_check_flow_off2on_stall = FALSE;
			if ( io_dte_rx_wptr_fix == I(io_dte_rx_wptr) )
			{
				// It's been 500 ms since we set CTS and the
				// app hasn't sent any data yet.  Assume it is
				// stuck and give it a kick.
				disable_interrupt () ;
					arm_uart_cts_off();
				enable_interrupt () ;
				printf("\n*** Toggle CTS ***\r\n");
				x_sleep(MS75);
				arm_uart_cts_on();
			}
		}
	}
}
#endif // } !USB_MODEM

/****************************************************************
	Function : arm_flow_off
	Allow the host to send again.
*****************************************************************/
void arm_flow_off ( void )
{
#if defined(USB_MODEM)
	byte ndx ;

	output8( PEND_USB, 1 ) ;
		output8( SBIE_USB, input8( SBIE_USB ) | SBI_RX_2 ) ;
		ndx = input8( EPINDEX_USB ) ;
		output8( EPINDEX_USB, 2 ) ;
		if ( (input8( RXFLG_USB ) & (RX_FIF1|RX_FIF0)) &&
			!(input8( SBI_USB ) & SBI_RX_2) )
		{
			// cause a USB ep2 interrupt
			output8( SBI_USB, input8( SBI_USB ) | SBI_RX_2 ) ;
			lstusbEvent = ~USB_EVENT() ;
			//sendDumbChar( '_' );  // mah 9/10 don't need this debug
		}
		output8( EPINDEX_USB, ndx ) ;
	output8( PEND_USB, 0 ) ;

	uart_flow_control = FC_OFF ;	// turn off unconditionally for USB MR238
#endif // USB

	if ( G(S).ModemOptions.FlowControl == NO_FLOWCTRL )
	{
		return ;
	}
	uart_flow_control = FC_OFF ;
	if ( G(S).ModemOptions.FlowControl == SW_FLOWCTRL )
	{
		io_put_dte_tx_char ( 0x11 ) ;	// XON host
		sendDumbChar( 'X' ) ;
	}
	else // if ( G(S).ModemOptions.FlowControl == HW_FLOWCTRL )
	{
		arm_uart_cts_on () ;

#if !defined(USB_MODEM)
		// Record current time and dte_rx_wptr for later checking
		io_flow_on_timestamp = x_current_time();
		io_dte_rx_wptr_fix = I(io_dte_rx_wptr);
		io_check_flow_off2on_stall = TRUE;
#endif

//		sendDumbChar( 'C' ) ;
	}
#if defined(UART_DEBUG_PRINT) && (defined(INT_MODEM) || defined(PCMCIA_MODEM))
	if ( dumbPortPresent )
	{
		//output8 ( DUMB_MCR, input8 ( DUMB_MCR ) | BIT3 ) ;
		MOS_Ptr->mcr |= BIT3;
	}
#endif
}

#endif // } !CS_MODEM

