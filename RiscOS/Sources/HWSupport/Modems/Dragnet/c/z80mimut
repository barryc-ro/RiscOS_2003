/*name and version number:@(#)z80mimut.c	1.17*/
/*date of get: 		  09/12/00 15:00:06*/
/*date of delta:	  09/12/00 14:32:37*/
/****************************************************************
File :	z80MIMUT.C
Description :
	Contains z80 utilities for external modem

Procedures Contained :
	init_z80_hardware
	mimic_baud_int
	mimic_control_registers
	venusPnPCheck

Revision History :
	RWF			11/07/95	initial
	RWF			11/10/95	moved eeprom driver to here
	RWF			11/15/95	added z80_PnP_chksum()
	RWF			17/17/96	added page mode serial eeprom routines.
	RWF			02/23/98	moved mimic stuff to this file.
*****************************************************************/

#include	"llglob_d.h"

#if defined( INT_MODEM ) || defined( PCMCIA_MODEM )
#include	"iouart_d.h"
#include	"ioglob_d.h"
#include	"atglob.h"
#include	"dpglob.h"
#include	"z80glob.h"

#ifdef CS_DEBUG
 #include "z80mimut.h"
#endif
#include	"allglobs.h"

#if defined( Z80_DEBUG_PRINT )
void checkDCAD(void)
{
	if (dp_regread(0xCA) & 1)
	{
		x_debug_msg("DCAD=");
		sendHexByte(dp_regread(0xC6));
		sendHexByte(dp_regread(0xC5));
		sendDumbChar(' ');
	}
	else
	{
		x_debug_msg("DIA/RMP (DCAD) not enabled in CAMIL 0xCA");
	}
}
#else
#define checkDCAD()
#endif

#if defined( COPERNICUS ) || defined( CS_MODEM )
#define Z80_CLOCK	36864
#else
#define	Z80_CLOCK	29491
#endif

#if defined( Z80_DEBUG_PRINT )	// {
#define		FLASH_TIME		(1000)		// flash timer in ms
/****************************************************************
	Function : z80_dbug_print - Internal debug routine
*****************************************************************/
void z80_dbug_print ( void )
{
	static word flash_timer ;			// timer for Break to DTE

	//------------------------------------------
	// flash CTS led if NOT online
	//------------------------------------------
	if ( io_state < IO_ONLINE )
	{
		if ( x_elapsed_time( flash_timer ) > FLASH_TIME )
		{
			flash_timer = x_current_time () ;
			disable_interrupt () ;
				output8( DUMB_MCR, input8( DUMB_MCR ) & BIT2 ?
							input8( DUMB_MCR ) & ~BIT2 :
							input8( DUMB_MCR ) | BIT2 ) ;
			enable_interrupt () ;
		}
	}

#if defined(STRONG_ARM_LIKE_DEBUG)
	// ***************************************************************
	// mah 9/29 - print idle time counter as in StrongArm
	{
		static word idle_time_wdcount, idle_time_wdcount1, idle_time;
#define		IDLE_TIME	MINUTE1

		idle_time_wdcount++;
		if ( !idle_time_wdcount )
		{
			idle_time_wdcount1++;
		}

		if ( x_elapsed_time( idle_time ) > IDLE_TIME )
		{

			DP_PUTS("Idle time wdcnt = ");
			dp_puts_dec(idle_time_wdcount1);
			dp_puts_dec(idle_time_wdcount);
			sendCrLf();

			idle_time = x_current_time () ;
			idle_time_wdcount = 0;
			idle_time_wdcount1 = 0;
		}
	}
	// mah 9/29 - end **************************************************
#endif // STRONG_ARM_LIKE_DEBUG
}
#endif	// } Z80_DEBUG_PRINT

#if defined( Z80_MIMIC_DMA )	// {
/****************************************************************
	Function : init_z80_DMA for MIMIC
*****************************************************************/
void init_z80_DMA ( void )
{
			//-----------------------------------------------------
			// initialize DMA channel 1 for MIMIC RX
			// the following registers can be initialized once
			//-----------------------------------------------------
			// Destination register
	output8( IAR1B, 7 ) ;	// selects MIMIC RX as destination
	output8( IAR1H, 0 ) ;
	output8( IAR1L, MIMIC_RBR ) ;
			// upper byte of count - as long as we keep the packet
			// size to the host below 256 bytes this value should
			// not need reloading.
	output8( BCR1H, 0 ) ;
			// set up dmode register
			//	src = memory++
			//	dst = I/O fixed
	output8 ( DMODE, 0x30 ) ;
			// Convert Ch1 DMA to Edge sense (only mode that works
			// when FCR BIT0 == 0).
	output8( DCR, input8( DCR ) | BIT3 ) ;

			//-------------------------------------------------
			//	stop the DMA on Channel 1
			//-------------------------------------------------
	output8( DSTAT, 0x10 ) ;
}
#endif	// } Z80_MIMIC_DMA

/****************************************************************
	Function : z80_init_dtr
*****************************************************************/
void z80_init_dtr ( void )
{
	// init DTR
	if ( input8 ( MIMIC_MCR ) & BIT0 )
	{
		x_debug_msg( "Init DTR ON" ) ;
		cs_debug_liv(INIT_DTR_ON);
		UART_dtr_on () ;
	}
	else
	{
		x_debug_msg( "Init DTR OFF" ) ;
		cs_debug_liv(INIT_DTR_OFF);
		UART_dtr_off () ;
	}
}

#define	RTCR_115200	0x30
#define	RTCR_57600	0x30
#define	RTCR_38400	0x30
#define	RTCR_19200	0x20
#define RTCR_9600	0x10    // Lotus Notes okay
#define RTCR_4800	0x05
#define RTCR_2400	0x05    // AOL okay
#define RTCR_1200	0x05
#define RTCR_600	0x01	// untested
#define RTCR_300	0x01	// untested
#define RTCR_110	0x01	// untested

/****************************************************************
	Function : init_z80_hardware for ISA/PcCard Modem
*****************************************************************/
void init_z80_hardware ( void )
{
	byte reg ;
	extern void x_output_init ( void ) ;
	extern void setComPort ( void ) ;

	prog_timer((word) (Z80_CLOCK/20));	// 1 msec intervals
	
	//-------------------------------------------------------
	// Use seperate WSG (0xD8) in conjunction with
	// DCNTL (0x32) for improved tuning of RAM/ROM
	// Wait States.
	// - for VENUS set to:
	//		 3 ROM wait states
	//		 0 RAM wait states
	//		 3 I/O wait states (actually a don''t care)
	//-------------------------------------------------------
#if defined(WAIT_STATE_TWO) || defined(EMULATION)
	// For 80182/89 - Wait State Generator
	output8( WSG, 0x9a ) ; // ROM=3, RAM=2
	// For 80182/89 - I/O Wait State Generator: RAM=n/a; I/O=3
	output8( DCR, 0xA0 ) ;
#else

#if !defined(FAST_ROM )
		// Wait State Generator: ROM=3; RAM=Disabled
	output8 ( WSG, 0x0a ) ;
#else
		// Wait State Generator: ROM=2; RAM=Disabled
	output8 ( WSG, 0x09 ) ;
#endif
	// I/O Wait State Generator: RAM=0; I/O=3
	output8( DCR, 0x20 ) ;
#endif

	// Baud Rate Generator for VENUS
	output8( BRGL, 0x08 ) ;		// 	time constant low - in theory 115.2k
	output8( BRGH, 0x00 ) ;		// 	time constant high

	// set BRGEN
	output8( IOBRG, 0x01 ) ;

#if defined( Z80_MIMIC_DMA )
	// initialize DMA channels
	init_z80_DMA() ;
#endif

	// initialize parallel port registers, all output pins on camil etc.
#if defined (VENUS_WORLD_DAA)
	x_output_init(); //for Magellan G.L.
#else	
	x_output ( IO_OUTPUT_INIT ) ;
#endif

	// initialize UART MIMIC registers
#if defined( Z80_MIMIC_DMA )		// mimic master control register
	output8( MIMIC_MMC, BIT4|BIT3|BIT0 ) ;
#else
	output8( MIMIC_MMC, BIT0 ) ;
#endif
	output8( MIMIC_IVEC, 0x00 ) ;	// interrupt vector register
#if !defined(CS_MODEM)
	output8( MIMIC_TTCR, 0x05 ) ;
	output8( MIMIC_RTCR, RTCR_115200); // bit-rate specific in mimic_baud_int
	output8( MIMIC_TTTC, 0x20 ) ;	// tx timeout timer
	output8( MIMIC_RTTC, 0x00 ) ;	// rx timeout timer
	output8( MIMIC_FSCR, 0x20 ) ;	// fifo status and control register
	output8( MIMIC_MSR, 0x30 ) ;	// modem status reg - set DSR & CTS
	output8( MIMIC_MMC,				// MMC register - enable timers
			 input8( MIMIC_MMC ) | (BIT7|BIT6) ) ;
#else //CS_MODEM
 #ifdef IPGATEWAY
	output8(ENHR, 0x1C);	    // enhancement register -  enable 32 deep FIFO mode, uC write SCR
	output8(MIMIC_RTCR, 10);  // PC Int delay timer = 86.8us
 #else
	output8( ENHR, 0x04 )		;	// enhancement register -  enable 32 deep FIFO mode
 #endif
	output8( BRGX, 0x0F )		;	// First divider     - divide by 16
	output8( BRGL, 0x08 )		;	// time constant low - divide by 8
	output8( BRGH, 0x00 )		;	// time constant hi	-> 29.4912Mhz / 256 = 115.2Kbps

//	output8( MIMIC_RTTC, 0x20 ) ;	// rx timeout timer - 
	output8( MIMIC_RTTC, 0x00 ) ;	// rx timeout timer -  kyvo
	output8( MIMIC_TTTC, 0x20 ) ;	// tx timeout timer -
//	output8( MIMIC_TTTC, 10 ) ;	  // Tx timeout timer - 86.8us @115.2Kbps

	output8( MIMIC_FSCR, 0xF0 ) ;	// fifo status and control register - FIFO 30, tx & rx timeout
	output8( MIMIC_MSR, 0x00 )	;	// modem status reg - used for m2h int
 #ifdef IPGATEWAY
	output8( MIMIC_MMC, 0x41 )	;	// master control register - no char delay
 #else
	output8( MIMIC_MMC, 0x01 )	;	// master control register - no char delay
 #endif
#endif
	output8( MIMIC_IUS, 0x80 ) ;	// clear interrupt source
#if !defined(CS_MODEM)
	output8( MIMIC_IE,  0x00 ) ;	// interrupt enable register
#else
	output8( MIMIC_IE,  0x88 ) ;	// MCR int. is enabled (mdm_rdy)
#endif
	output8( MIMIC_IUS, 0x80 ) ;	// clear interrupt source

#if defined( PCMCIA_MODEM )
#if defined( MULTI_FUNCTION )
	//	Set the interrupt sharing bits in the FCRs
	dp_regwrite(0x41, 0x01);
	dp_regwrite(0x44, 0x01);
	dp_regwrite(0x47, 0x01);
	dp_regwrite(0x4d, 0x01);
#endif
		//	Set the scenario bits in the MMI Cntrl Register
	dp_regwrite( 0xc0, 0x01 ) ;
		// Set READY to host
	dp_regwrite( 0x57, 0x01 ) ;
#else	// ISA
	dp_regwrite(0xCA, 0x41);	// enable host pc access to MIMIC (MCAD)
								// and DIA (for DSP access)
#if !defined(CS_MODEM)
 #if defined(COPERNICUS)
	dp_regwrite(0xC3, 0xF8);	// MCAD COM port decode (lower byte)
	dp_regwrite(0xC4, 0x03);	// MCAD COM1 port decode (upper byte)
	dp_regwrite(0xcc, 0x0A);	// Assign MIMIC Irq C
	dp_regwrite(0xd6, 0x0B);	// IRQ C Driven always
 #elif defined (PCI_MODEM)
	// set up MCAD to so that Pita can talk to MIMIC
	dp_regwrite(0xC3, 0x20);	// MCAD port decode (lower byte)
	dp_regwrite(0xC4, 0x00);	// MCAD port decode (upper byte)
  #if defined (TQFP128)
	dp_regwrite(0xcc, 0x0D);	// Assign MIMIC Irq B=3
	dp_regwrite(0xd6, 0x2D);	// IRQ B Driven always
  #else
	dp_regwrite(0xcc, 0x0C);	// Assign MIMIC Irq A=4
	dp_regwrite(0xd6, 0x1E);	// IRQ A Driven always
  #endif
 #else
	// (normal ISA case)
	dp_regwrite(0xC3, 0xf8);	// MCAD COM port decode (lower byte)
	dp_regwrite(0xC4, 0x02);	// MCAD COM2 port decode (upper byte)
	dp_regwrite(0xcc, 0x0D);	// Assign MIMIC Irq B=3
	dp_regwrite(0xd6, 0x0D);	// IRQ B Driven always
//	dp_regwrite(0xcc, 0x0C);	// Assign MIMIC Irq A=4
//	dp_regwrite(0xd6, 0x0E);	// IRQ A Driven always
 #endif
	dp_regwrite(0xc0, 0x00);	// no eye pattern junk
#else
	dp_regwrite(0xC3, (dp_regread(0xC5)+8));// MCAD = DCAD + 8
	dp_regwrite(0xC4, (dp_regread(0xC6)));

	dp_regwrite(0xcc, 0x0E);	// Assign MIMIC IRQC=7
	dp_regwrite(0xd6, 0x0B);	// IRQC Driven always
#endif //!CSMODEM
#endif	// ISA/PCMCIA

#if defined(COPERNICUS)
	dp_regwrite(0xda, 0x14);	// enable IOCS2N. SIO2 goes to
								// multi-processor mode
#else
#if defined(CS_DIGITAL)
  #if defined(CS_RMP_DEBUG)
	dp_regwrite(0xda, 0x14);	// enable IOCS2N. SIO2 goes to
								// multi-processor mode
  #else
	dp_regwrite(0xda, 0x04);	// SIO2 goes to multi-processor mode
  #endif
  #if !defined(CS_MODEM)
	dp_regwrite(0xDE, 0x40);	// disable FUGU
  #endif
#else
  #if defined(DUMB_IOCS2)
	dp_regwrite(0xda, 0x16);	// call progress through SIO/USE IOCS2
  #else
	dp_regwrite(0xda, 0x06);	// call progress through SIO
  #endif
#endif
#endif

// mah 3/19/99 - took out "defined(PCI_MODEM) &&" on this
// #ifdef, (as suggested by Shawn Antol).
#if defined(TQFP128) 
	// Select smaller package size.
	// Tri-state all output signals not available.
	dp_regwrite(0xda, (dp_regread(0xda)|0x08)); 
#endif

	dp_regwrite(0xd7, 0xff);
	dp_regwrite(0xd8, 0xff);

	checkDCAD();

#if (!defined(PCMCIA_MODEM) && !defined(COMM_DECODE) && !defined(CS_MODEM)) || defined(COPERNICUS)
	setComPort();		// set up MCAD for Copernicus/jumper PnP
#endif

#if defined(Z80_DEBUG_PRINT)
	{
#if !defined(VENUS2)
		// Can't do this test with venus2
		// since it uses this register for other things.

		// see if we've been through a hardware reset
		// and print accordingly
		byte dc = input8(0xDC);	// bits 4-6 should be 0 if HW reset

		if (dc & 0x70)
		{
			x_debug_msg("looks like SW reset!!");
			cs_debug_liv(LOOKS_LIKE_SW_RESET);
			x_debug_msg("TSTMR 0xDC=");
			cs_debug_liv(TSTMR_DC);
			sendHexByte(dc);
			cs_debug_liv(dc | 0x2000);
			sendCrLf();
		}
		output8(0xDC, 0xF0);	// So we can do the test next time
#endif // !VENUS2

		// see if QMP module is present
		if (!(input8(0x3E) & 1))
		{
			x_debug_msg("QMP present");
			cs_debug_liv(QMP_PRESENT);
		}
		else
		{
			x_debug_msg("No QMP, older chip");
			cs_debug_liv(NO_QMP_OLDER_CHIP);
		}
	}
#endif

	// enable all interrupts
	enable_interrupt();

	// start the digital PLL for venus 2
	z80_init_venus2();
}

#if !defined( CS_MODEM )	// {

non_banked void z80_start_dma(void);
extern byte uart_lcr_reg, uart_fcr_reg, uart_mcr_reg, uart_loopback;
extern byte	uart_baud_reg, z80_mimic_rate;
extern BOOL FCR_changed, MCR_changed, LCR_changed;

#if defined( Z80_MIMIC_DMA )
extern BOOL	z80_no_more_tx;
#else
extern byte	uart_tx_count ;
#endif

#define		MIMIC_115200	(0x08)
#define		MIMIC_57600		(MIMIC_115200*2)
#define		MIMIC_38400		(MIMIC_57600*3/2)
#define		MIMIC_19200		(MIMIC_38400*2)
#define		MIMIC_9600		(MIMIC_19200*2)
#define		MIMIC_4800		(MIMIC_9600*2)
#define		MIMIC_2400		(MIMIC_4800*2)
#define		MIMIC_1200		(MIMIC_2400*2)
#define		MIMIC_600		(MIMIC_1200*2)
#define		MIMIC_300		(MIMIC_600*2)
#define		MIMIC_110		(MIMIC_300*2)

/****************************************************************
	Function : mimic BAUD RATE (DLL/DLM)
*****************************************************************/
void mimic_baud_int ( void )
{
	word brg ;
	byte reg, rtcr;

	// read divisor latch LS - DLL
	uart_baud_reg = input8( MIMIC_DLL ) ;
	reg = uart_baud_reg ;

#if !defined( Z80_MIMIC_DMA )
	if ( uart_baud_reg >= 23 ) 		// all dte rates below 9600
		uart_tx_count = 1 ;
	else if( uart_fcr_reg & 0x01 )	// check FCR reg for FIFO enable.
	{
		// (dte rates at or above 9600)

		// If FIFOs are not enabled, the FCR_changed flag
		// will set uart_tx_count to 1 in
		// mimic_control_registers().
		uart_tx_count = 30 ;
	}
#endif

	//------------------------------------------------------
	// if modem is in voice mode - set to 115K dte rate for
	// dle shielded voice samples thru the comm port
	//------------------------------------------------------
	if ( x_modem_mode == MODEM_VOICE )
		reg = 1 ;	// 115200

	//------------------------------------------------------
	// set up the baud rate registers based on the dte rate
	//------------------------------------------------------
	switch ( reg )
	{
		case 1 :
		default :
			brg = MIMIC_115200 ;	// actual 115.2k
			S.ModemOptions.DteRate = DTE_115200 ;
			rtcr = RTCR_115200;
			break ;
		case 2 :
			brg = MIMIC_57600 ;
			S.ModemOptions.DteRate = DTE_57600 ;
			rtcr = RTCR_57600;
			break ;
		case 3 :
			brg = MIMIC_38400 ;
			S.ModemOptions.DteRate = DTE_38400 ;
			rtcr = RTCR_38400;
			break ;
		case 6 :
			brg = MIMIC_19200 ;
			S.ModemOptions.DteRate = DTE_19200 ;
			rtcr = RTCR_19200;
			break ;
		case 12 :
			brg = MIMIC_9600 ;
			S.ModemOptions.DteRate = DTE_9600 ;
			rtcr = RTCR_9600;
			break ;
		case 24 :
			brg = MIMIC_4800 ;
			S.ModemOptions.DteRate = DTE_4800 ;
			rtcr = RTCR_4800;
			break ;
		case 48 :
			brg = MIMIC_2400 ;
			S.ModemOptions.DteRate = DTE_2400 ;
			rtcr = RTCR_2400;
			break ;
		case 96 :
			brg = MIMIC_1200 ;
			S.ModemOptions.DteRate = DTE_1200 ;
			rtcr = RTCR_1200;
			break ;
		case 192 :
			brg = MIMIC_600 ;
			S.ModemOptions.DteRate = DTE_600 ;
			rtcr = RTCR_600;
			break ;
		case 128 :
			brg = MIMIC_300 ;
			S.ModemOptions.DteRate = DTE_300 ;
			rtcr = RTCR_300;
			break ;
		case 23 :
			brg = MIMIC_110 ;
			S.ModemOptions.DteRate = DTE_110 ;
			rtcr = RTCR_110;
			break ;
	}

	if ( S.ModemOptions.MimicFIFOrate )
	{
		brg *= 2 ;
		x_debug_msg( "Doubling brg=" ) ; sendHexWord( brg ) ;
		cs_debug_liv(DOUBLING_BRG);
		cs_debug_liv(brg | 0x2000);
		sendDumbChar(0x0A); sendDumbChar(0x0D);

	}

	// Receive Time Constant Register (RTCR).
	output8(MIMIC_RTCR, rtcr);

	// MIMIC Baud Rate Generator
	output8( BRGL, (byte)brg ) ;		// 		time constant low
	output8( BRGH, (byte)((word)(brg >> 8)) ) ;	// 	time constant high

	// read divisor latch MS - DLM
	reg = input8( MIMIC_DLM ) ;

	x_debug_msg( "DLM=" ) ; sendHexByte( reg ) ;
	cs_debug_liv(MIMIC_BAUD_INT_DLM);
	cs_debug_liv(reg | 0x2000);
	x_debug_msg( "; DLL=" ) ; sendHexByte( uart_baud_reg ) ;
	cs_debug_liv(MIMIC_BAUD_INT_DLL);
	cs_debug_liv(uart_baud_reg | 0x2000);
	sendDumbChar(0x0A); sendDumbChar(0x0D);
}

//#define OLD_WAY_FOR_PRE_CHARTERED_PARTS
/****************************************************************
	Function : mimic_control_registers
		check if any uart mimic control registers changed
*****************************************************************/
void mimic_control_registers ( void )
{
	static byte reg ;
	static byte last_ier_reg, oldFIFORate ;
#if defined( RMP_CAMILZ_ACCESS )
	extern void RMPCAMILZaccess ( void ) ;
#endif

#if defined( Z80_DEBUG_PRINT )
	//------------------------------------------------
	//	Host IER register has changed ?
	//------------------------------------------------
	reg = input8( MIMIC_IER ) ;
	if ( (last_ier_reg & ~BIT1) != (reg & ~BIT1) )
	{
		x_debug_msg( "IER=" ) ;
		sendHexByte( last_ier_reg ) ;
		sendDumbChar(0x0A); sendDumbChar(0x0D);
		last_ier_reg = reg ;
	}
#endif

	//------------------------------------------------
	//	LCR register has changed ?
	//------------------------------------------------
	if ( LCR_changed )
	{
		BOOL DalbSet; // Divisor Latch Access Bit

		disable_interrupt () ;
			reg = input8( MIMIC_LCR ) ;
			if ( reg & BIT7 )
			{
				// -----------------------------------------
				// Host has LCR register locked right now
				// Wait for host to release the LCR register
				// before we use the updated values.
				// -----------------------------------------
				DalbSet = TRUE;
			}
			else
			{
				// DALB is not set //
				uart_lcr_reg = reg ;
				LCR_changed = FALSE ;
				DalbSet = FALSE;
			}
		enable_interrupt () ;

		//--------------------------------------------
		//	set data bits, partiy, and stop bit
		//--------------------------------------------
		if ( !DalbSet )
		{
			switch ( reg & 0x03 )
			{
				case 0:
					UART_data_bits ( 5 ) ;
					sendDumbChar('5');
					break ;
				case 1:
					UART_data_bits ( 6 ) ;
					sendDumbChar('6');
					break ;
				case 2:
					UART_data_bits ( 7 ) ;
					sendDumbChar('7');
					break ;
				default:
					UART_data_bits ( 8 ) ;
					sendDumbChar('8');
					break ;
			}

			//-----------------------------------
			//	BIT5	BIT4	BIT3
			//	----	----	----
			//	 x		 x		 0		No parity
			//	 0		 0		 1		Odd parity
			//	 0		 1		 1		Evn parity
			//	 1		 0		 1		Mrk parity
			//	 1		 1		 1		Spc parity
			//-----------------------------------
			if ( !( reg & BIT3 ) )
			{
				// no parity
				UART_parity ( 0 ) ;
				sendDumbChar('N');
			}
			else if ( !(reg & 0x30) )
			{
				// odd parity
				UART_parity ( 1 ) ;
				sendDumbChar('O');
			}
			else if ( ( reg & 0x30 ) == 0x10 )
			{
				// even parity
				UART_parity ( 2 ) ;
				sendDumbChar('E');
			}
			else if ( ( reg & 0x30 ) == 0x20 )
			{
				// mark parity
				UART_parity ( 3 ) ;
				sendDumbChar('M');
			}
			else // if ( ( reg & 0x30 ) == 0x30 )
			{
				// space parity
				UART_parity ( 4 ) ;
				sendDumbChar('S');
			}

			// set stop bits - after data & parity - cmd is sent to dsp
			if ( reg & 0x04 )
			{
				UART_stop_bits ( 1 ) ;
				sendDumbChar('2');
			}
			else
			{
				UART_stop_bits ( 0 ) ;
				sendDumbChar('1');
			}

			// Check for Break set
			if ( reg & 0x40 )
			{
				UART_start_break () ;
				sendDumbChar('B');
			}
			else
			{
				UART_stop_break () ;
			}

			x_debug_msg( "-LCR=" ) ;
			cs_debug_liv(MIMIC_CONTROL_REGS_LCR);
			sendHexByte( uart_lcr_reg ) ;
			cs_debug_liv(uart_lcr_reg | 0x2000);
			sendDumbChar(0x0A); sendDumbChar(0x0D);
		}
	}

	//------------------------------------------------
	// Unfortuantely, we have to poll for DTR changes
	// for some Aps (Hyperterm) have an uncanny ability
	// to change the MCR register and not cause an interrupt.
	//------------------------------------------------
	if ( MCR_changed || (input8( MIMIC_MCR ) != uart_mcr_reg ))
	{
		disable_interrupt () ;
			uart_mcr_reg = input8(MIMIC_MCR);
			MCR_changed = FALSE ;
		enable_interrupt () ;

#if defined(HP_PALMTOP_FIX)
		// This allows the
		if (uart_mcr_reg & BIT1)
		{
			z80_uart_dsr_off();
		}
		else
		{
			z80_uart_dsr_on();
		}
#endif // HP_PALMTOP_FIX


		if ( uart_mcr_reg & BIT0 )
		{
			UART_dtr_on () ;
		}
		else
		{
			UART_dtr_off () ;
		}

			// stay in this loop - till loopback over (from ISR)
		while ( input8(MIMIC_MCR) & BIT4 )
		{
			if ( (io_dte_rx_rptr != io_dte_rx_wptr)
#if defined( Z80_MIMIC_DMA )
				&& z80_no_more_tx 
#endif
				)
			{
#if defined( Z80_MIMIC_DMA )
				// DMA mode
				z80_no_more_tx = FALSE ;
				z80_start_dma() ;
#else
				// Non DMA mode
				output ( MIMIC_RBR, *io_dte_rx_rptr++ ) ;
				if ( io_dte_rx_rptr >= io_dte_rx_eptr )
					io_dte_rx_rptr = io_dte_rx_sptr ;
				output ( MIMIC_IUS, 0x80 ) ;	// clear interrupt source
#endif
			}
		}
		x_debug_msg( "MCR=" ) ;
		cs_debug_liv(MIMIC_CONTROL_REGS_MCR);
		sendHexByte( uart_mcr_reg ) ;
		cs_debug_liv(uart_mcr_reg | 0x2000);
		sendDumbChar(0x0A); sendDumbChar(0x0D);
	}

	//------------------------------------------------
	//	FCR register has changed ?
	//------------------------------------------------
	if ( FCR_changed )
	{
		disable_interrupt () ;
			reg = uart_fcr_reg ;
			FCR_changed = FALSE ;
		enable_interrupt () ;

		//-------------------------------------------------
		// add tx overrun stuff here
		//-------------------------------------------------

#if defined( OLD_WAY_FOR_PRE_CHARTERED_PARTS )
		//-------------------------------------------------
		// Check host settings of RX FIFO trigger levels.
		// In RX DMA mode, if the host sets a non-zero
		// RX trigger level, and does not set the DMA mode
		// select bit (FCR bit 3), then the way the MIMIC
		// hardware is currently designed, we will suffer
		// the RTTC delay for every char DMAed.  Therefore
		// adjust the RTTC delay accordingly.
		//-------------------------------------------------
		if ( (uart_fcr_reg & (BIT7|BIT6)) &&
			!(uart_fcr_reg & BIT3) )
		{
			output8( MIMIC_RTTC, 0x04 ) ;
		}
		else
		{
			output8( MIMIC_RTTC, 0x20 ) ;
		}
#endif

#if !defined( Z80_MIMIC_DMA )
		uart_tx_count = 1 ;
		if ( reg & 0x01 )      	// if fifo mode enabled
		{
//			reg &= 0xC0 ;		// isolate receive trigger level
//			if ( reg == 0xC0 )
//				uart_tx_count = 14 ;
//			else if ( reg == 0x80 )
//				uart_tx_count = 8 ;
//			else if ( reg == 0x40 )
//				uart_tx_count = 4 ;

			uart_tx_count = 30 ;
		}
#endif
		x_debug_msg( "FCR=" ) ;
		cs_debug_liv(MIMIC_CONTROL_REGS_FCR);
		sendHexByte( uart_fcr_reg ) ;
		cs_debug_liv(uart_fcr_reg | 0x2000);
		sendDumbChar(0x0A); sendDumbChar(0x0D);
	}

	//------------------------------------------------
	//	LS register has changed ?
	//------------------------------------------------
	if ( (uart_baud_reg != input8( MIMIC_DLL ))
		|| (S.ModemOptions.MimicFIFOrate != oldFIFORate)
		|| ((x_modem_mode == MODEM_VOICE)
			&& (S.ModemOptions.DteRate != DTE_115200)) )
	{
		mimic_baud_int () ;
		oldFIFORate = S.ModemOptions.MimicFIFOrate ;
	}

#if defined( RMP_CAMILZ_ACCESS )
	RMPCAMILZaccess() ;
#endif

#if defined( Z80_DEBUG_PRINT )
	z80_dbug_print () ;
#endif
}
#endif // } !CS_MODEM

#if defined( PCMCIA_MODEM )	// {
/****************************************************************
	Function : z80_poll_pcmcia
	poll PCMCIA interface for FCR updates and ring interrupt.
*****************************************************************/
void z80_poll_pcmcia ( void )
{
	byte fcsrReg ;
	word rst_timer ;
	static word poll_timer ;
	static enum
	{
		INITIAL_STATE,
		ACTIVE_STATE,
		POLLING_STATE
	} poll_state ;
	extern BOOL z80_ring_int ;

	switch ( poll_state )
	{
		case INITIAL_STATE :
		case ACTIVE_STATE :
			if ( x_modem_state == MS_IDLE )
			{
				poll_timer = x_current_time() ;
				poll_state = POLLING_STATE ;
			}
			break ;
		
		case POLLING_STATE :
			if ( x_modem_state != MS_IDLE )
			{
				poll_state = ACTIVE_STATE ;
			}
			else if ( x_elapsed_time( poll_timer ) >= MS100 )
			{
				disable_interrupt() ;
					Attribute_memory_write() ;
				enable_interrupt() ;
				poll_timer = x_current_time() ;
			}
			break ;
	
		default :
			break ;
    }

	if ( z80_ring_int )
	{
		//------------------------------------
		// do we wish to generate a STSCHG#
		// signal to the host?
		//------------------------------------
		fcsrReg = dp_regread( 0x41 ) ;

		if ( fcsrReg & BIT1 )
		{

			z80_ring_int = FALSE ;

			//------------------------------
			// INTR bit (BIT1) is set
			// toggle SigChg (BIT6) of FCSR
			//------------------------------
			dp_regwrite ( 0x41, fcsrReg | BIT6 ) ;

			rst_timer = x_current_time() ;
			while ( x_elapsed_time(rst_timer) <= 30 )
				;

			dp_regwrite ( 0x41, fcsrReg & ~BIT6 ) ;

			ddputs_nnl( "\r\n1st intr1: fcsr = " ) ;
			sendHexByte( fcsrReg  ) ; ddputs_nnl( "\r\n" ) ;
		}
	}
}
#endif	// } PCMCIA_MODEM

#if defined( INT_MODEM ) && !defined( CS_MODEM )	// {
#if !defined( COMM_DECODE )	// {
const byte venusPnPdata[] =
{
0x22, 0x6d, 0x2, 0x40, 0x0, 0x1, 0x0, 0x0, 0x62, 0xa, 0x10, 0x1, 0x82, 
0x13, 0x0, 0x4c, 0x75, 0x63, 0x65, 0x6e, 0x74, 0x20, 0x56, 0x65, 0x6e, 0x75, 
0x73, 0x20, 0x4d, 0x6f, 0x64, 0x65, 0x6d, 0x0, 0x16, 0x22, 0x6d, 0x2, 0x40, 
0x2, 0x0, 0x30, 
0x47, 0x1, 0xf8, 0x3, 0xf8, 0x3, 0x8, 0x8, 0x23, 0x10, 0x0, 0x1, 0x30, 
0x47, 0x1, 0xf8, 0x2, 0xf8, 0x2, 0x8, 0x8, 0x23, 0x8, 0x0, 0x1, 0x30, 
0x47, 0x1, 0xe8, 0x3, 0xe8, 0x3, 0x8, 0x8, 0x23, 0x10, 0x0, 0x1, 0x30, 
0x47, 0x1, 0xe8, 0x2, 0xe8, 0x2, 0x8, 0x8, 0x23, 0x8, 0x0, 0x1, 0x30, 
0x47, 0x1, 0xf8, 0x3, 0xf8, 0x3, 0x8, 0x8, 0x23, 0x98, 0x84, 0x1, 0x30, 
0x47, 0x1, 0xf8, 0x2, 0xf8, 0x2, 0x8, 0x8, 0x23, 0x98, 0x84, 0x1, 0x30, 
0x47, 0x1, 0xe8, 0x3, 0xe8, 0x3, 0x8, 0x8, 0x23, 0x98, 0x84, 0x1, 0x30, 
0x47, 0x1, 0xe8, 0x2, 0xe8, 0x2, 0x8, 0x8, 0x23, 0x98, 0x84, 0x1, 0x30, 
0x47, 0x1, 0x0, 0x1, 0xf8, 0x3, 0x8, 0x8, 0x23, 0x98, 0x84, 0x1, 0x38, 
0x47, 0x1, 0x0, 0x1, 0xf8, 0x3, 0x8, 0x8, 0x79, 0xc8
};

/****************************************************************

	Function : BOOL pnpEEcheck( void )
	check the ISA stored PnP data.

	layout of ISA EEPROM (512x8) is :

							     ADDR
		+--------------------+   ----
		|         o          |     0
		|         o          |     .
		|        ISA         |     .
		|     Plug&Play      |     .
		|       DATA         |     .
		|      (len=n)       |     .
		|         o          |     .
		|         o          |    n-1
		+--------------------+
		|         o          |     .
		|         o          |     .
		|    Unused Area     |     .
		|         o          |     .
		|         o          |     .
		+--------------------+
		|    control flag    |    250 (COUNTRY_ID - 3)
		+--------------------+
		|      checksum      |    251 (COUNTRY_ID - 2)
		+--------------------+
		| size of struct (n) |    252 (COUNTRY_ID - 1)
		+--------------------+

	the checksum protects 0 to n-1.

*****************************************************************/

BOOL pnpEEcheck( void )
{
	byte MySReg[ COUNTRY_ID ] ;
	byte i, slen;
	byte chksum ;

	//-------------------------------------------
	// check for presence of control fields
	// (see if control flag is set)
	//
	// 8/27/98
	// james k. has done work that shows at least
	// with ISA one read doesn't always work.
	// We'll read up to three times before we
	// declare the EEPROM uninitialized.
	//-------------------------------------------
	for (i=0; i<3; i++)
	{
		if (read_eeprom(ISA_PNP_FLAG) == ISA_CNTRL_FLAG)
		{
			break;
		}
	}

	if (3 == i)
	{
		// we tried reading three times but didn't
		// see the control flag.
		x_debug_msg( "No PnP Control Flag" ) ;
		return FALSE ;
	}

	//-------------------------------------------
	// get length of stored PnP struct
	//-------------------------------------------
	slen = read_eeprom( ISA_PNP_LEN ) ;

	//-----------------------------------------------
	//	retrieve stored ISA PnP data
	//-----------------------------------------------
	read_eeprom_pg( 0, MySReg, slen ) ;

	//------------------------------------------------
	// calculate chksum
	//------------------------------------------------
	chksum = 0 ;
	for ( i=0; i<slen; i++ )
	{
		chksum += MySReg[ i ] ;
	}

	//------------------------------------------------
	// compare checksums
	//------------------------------------------------
	if ( chksum != read_eeprom( ISA_PNP_CKSUM ) )
	{
		x_debug_msg( "ISA PnP Chksum BAD" ) ;
		return FALSE ;
	}
	return TRUE ;
}

/****************************************************************
	Function : pnpEEmatch()
	check to see if EEPROM matches default PnP data
*****************************************************************/
BOOL pnpEEmatch( void )
{
	byte myData[ (sizeof venusPnPdata) ] ;
	byte i;

	read_eeprom_pg( 0, myData, (sizeof venusPnPdata) ) ;

	for ( i=0; i < (sizeof venusPnPdata); i++ )
	{
		if ( venusPnPdata[i] != myData[i] )
		{
			return FALSE ;
		}
	}
	return TRUE ;
}

/****************************************************************
	Function : venusPnPCheck()
	Verifies Manufacturer PnP Data.
*****************************************************************/
BOOL venusPnPCheck( void )
{
	byte i ;
	byte cksum ;

	//---------------------------------------------
	// verify manufacturers PnP data
	//---------------------------------------------
	if ( pnpEEcheck() )
	{
		x_debug_msg( "EEPROM O.K." ) ;
		return TRUE ;
	}

	//---------------------------------------------
	// Not valid.. check for legacy case
	// (default struct venusPnPdata[] is present)
	//---------------------------------------------
	cksum = 0 ;
	if ( !pnpEEmatch() )
	{
		x_debug_msg( " EEPROM doesn't match, programming...");

		//---------------------------------------------
		// EEPROM doesn't currently match.
		// Let's try to program it.
		//---------------------------------------------
		for ( i=0; i < (sizeof venusPnPdata); i++ )
		{
			sendDumbChar('.');
			write_eeprom( i, venusPnPdata[ i ] ) ;
			cksum += venusPnPdata[ i ] ;
		}

		if ( !pnpEEmatch() )
		{
			x_debug_msg( "EEPROM programming failure" ) ;
			return FALSE;
		}
	}
	else
	{
		for ( i=0; i < (sizeof venusPnPdata); i++ )
		{
			cksum += venusPnPdata[ i ] ;
		}
	}

	//---------------------------------------------
	// Finally Add new control fields
	//---------------------------------------------
	x_debug_msg( "Add Control Fields" );
	write_eeprom( ISA_PNP_FLAG, ISA_CNTRL_FLAG ) ;
	write_eeprom( ISA_PNP_CKSUM, cksum ) ;
	write_eeprom( ISA_PNP_LEN, (sizeof venusPnPdata) ) ;

	return TRUE ;
}
#endif	// } !COMM_DECODE
#endif	// } INT_MODEM && !CS_MODEM
#endif	// } INT_MODEM || PCMCIA_MODEM
