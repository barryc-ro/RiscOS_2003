/*name and version number:@(#)v110.c	1.9*/
/*date of get: 		  12/15/00 10:10:50*/
/*date of delta:	  11/30/00 16:59:46*/
/****************************************************************/
/*
(C) Copyright 1996-1998 Link Technology, Inc.  All Rights Reserved Worldwide.

THIS SOFTWARE CONTAINS TRADE SECRETS OF LINK TECHNOLOGY INC.  NO DISCLOSURE,
COPYING OR USE OF WHOLE OR ANY PART THEREOF MAY BE MADE WITHOUT WRITTEN
PERMISSION.

Licensed Material - Program Property of Link Technology, Inc.

THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Link Technology, Inc.
The copyright notice above does not evidence any actual or intended
publication of such source code.
*/
/*
	$Header$

	History:
	$Log$
*/
/*************************************************************************
**									**
** name		: v110.c						**
** purpose	: V.110 state machine and API support			**
**									**
*************************************************************************/
#define	Z80_DEBUG_THIS_FILE

#ifdef _DOS
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <conio.h>
#include <dos.h>
#include <bios.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#endif

#include "llglob_d.h"

#if defined(CS_V110)		// jc-4/20/99

#include "v110sys.h"		/*System definitions*/
#include "v110syif.h"		/*system interface definitions*/
#include "v110ltos.h"		/*LTOS Exec defines*/
//jc #include "sysfncts.h"		/*Function prototypes*/
#include "v110il.h"		/*ILV110API definitions*/
#include "v110.h"		/*V.110 definitions*/
#include "v110cs.h"	//jc
#ifndef MODEM_ARM
	#include "intrz80.h"			//jc-9/18/98
#endif
#include "allglobs.h"			//jc-4/28/99
#include "ioglob_d.h"			// cb 08-04-00


/*externals used*/

extern non_banked word  io_get_dce_tx_count ( void ) ;	//jc
//extern word  *io_dce_tx_sptr ;
//extern word  *io_dce_tx_eptr ;
//extern word  *io_dce_tx_wptr ;

/*locals used externally*/                                           
#ifdef V110_LOG_DEBUG
/*v.110 log buffer related*/
WORD uV110LogIn=0;			/*next free v.110 trace log entry*/ 
BYTE ucV110LogBfr[V110_LOG_SIZE];	/*v.110 trace log buffer*/
#endif

/*locals*/
#if !defined( NOT_FAST ) && !defined( CS_4 )
static BYTE v110_ucTmpByte;			/* Temporary byte */
static BYTE v110_ucBytesDecoded;		/* # RA2 bytes decoded */
static BYTE v110_ucLoop1;			/* Loop counter */
static BYTE v110_ucLoop2;			/* Loop counter */
static BYTE *v110_pRA2Bytes;			/* Bytes to decode pointer */
static BYTE v110_ucRA2Bytes2Decode;		/* Bytes to decode pointer */
static BOOLEAN v110_bAdjustRA2Pointer;	/* Adjust RA2 pointer flag */
static BOOLEAN v110_bSyncFound;		/* Synchronization found flag */
static BYTE v110_ucDataByte;			/* Data byte being converted */
static int v110_iBytesProcessed;		/* # RA2 bytes processed */
static BYTE *v110_pRet;			/* Return byte pointer */
static BYTE *v110_pRetByte;			/* Serial decode return byte pointer */
static BYTE v110_ucBits;			/* Contains bits decoding */
static BOOLEAN v110_bInsertedStartBit;	/* Inserted start bit flag */
static BYTE v110_ucStopBitsInserted;		/* # stop bits inserted in current byte */
static BOOLEAN v110_bReplicate;		/* Replicate bit flag */
static BYTE v110_ucRepCount;			/* Data bit replication count */
static BYTE v110_ucRepBit;			/* Replicate this bit */
#endif 	//!defined( NOT_FAST ) && !defined( CS_4 )

#if !defined( CS_4 )
BYTE v110_ucRA1Byte;		/* RA1 converted byte */ 
	//jc-1/8/99 used by V110GetRA2Byte() to replace *pResultByte parameter
	//jc-4/29/99 struct v110timer v110_Timer;
static word v110_SendRawDataCnt;		// used in SendRawData only

	//jc static struct timer_id_s *pv110T1Tid[MAX_V110_CHANNELS];/* T1 timer id */
	//jc static struct timer_id_s *pv110ResyncTid[MAX_V110_CHANNELS];/* Resync timer id */
V110CONTROL_S V110Control;	//jc
	//jc V110CONTROL_S V110Control[MAX_V110_CHANNELS];	/* V.110 channel control structures */
V110DATA_S V110Data;	//jeff, jc-1/9/99 V110Data is for Rx
	//jc-4/29/99 V110DATA_S V110DataTx;

	//jc static V110DATA_S V110Data[MAX_V110_CHANNELS];		/* Build new rcvd data here */

union RCVD_OCTETS	v110_rx_octets;
byte v110_shift_amount;	// jc-5/13/99
word v110_uRA1ByteCnt;		// jc-6/11/99
byte v110_uRA2BitShiftFound;	// jc-6/11/99
byte v110_bPrevSyncFound;	//jc-6/18/99

#endif

/* application event callback procedure */
//jc static LWORD (*V110EventCallback)(WORD uChannel, WORD uEvent, LWORD dwMisc) = NULL;
static LWORD (*V110EventCallback)(WORD uEvent, BYTE dwMisc);	//jc - 1/6/99

extern non_banked word dp_read_dsp_ram ( word loc ) ; // cb 08-11-00

/* V.110 Miscellaneous Support Procedures */

/*************************************************************************
**									**
** name		: v110StopT1						**
** purpose	: stop timer T1						**
** inputs	:							**
**		.none							**
** outputs	:							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110StopT1( void )	//jc
{
	/* If T1 is running, stop it */
	if ( G(v110_Timer).T1_start_time != (word)NULL) 
		G(v110_Timer).T1_start_time = (word)NULL;
}

/*************************************************************************
**									**
** name		: v110StartT1						**
** purpose	: start timer T1					**
** inputs	:							**
**		.none							**
** outputs	:							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110StartT1( void )		//jc
{
	/* Make sure T1 is stopped */
	v110StopT1();

	G(v110_Timer).T1_duration = G(V110Control).uTimer_T1_Value ;
	G(v110_Timer).T1_start_time = x_current_time();	
}

/*************************************************************************
**									**
** name		: v110StopResync					**
** purpose	: stop timer Resync					**
** inputs	:							**
**		.none							**
** outputs	:							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110StopResync( void )	//jc
{
	/* If Resync is running, stop it */
	if ( G(v110_Timer).Resync_start_time != (word)NULL) 
		G(v110_Timer).Resync_start_time = (word)NULL;
}

/*************************************************************************
**									**
** name		: v110StartResync					**
** purpose	: start timer Resync					**
** inputs	:							**
**		.none							**
** outputs	:							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110StartResync( void )		//jc
{
	/* Make sure Resync is stopped */
	v110StopResync();

	G(v110_Timer).Resync_duration = G(V110Control).uTimer_Resync_Value ;
	G(v110_Timer).Resync_start_time = x_current_time();
}

/*************************************************************************
**									**
** name		: v110GetRA2Byte					**
** purpose	: Build V.110 byte from RA2 data			**
** inputs	: 							**
**		.frame buffer address					**
**		.frame byte size					**
** outputs	: 							**
**		.# of RA2 bytes processed to create V.110 byte		**
**									**
*************************************************************************/
non_banked static int v110GetRA2Byte( BYTE *pFrameData,
			   BYTE ucFrameByteCnt )
{
#if defined( NOT_FAST )
	BYTE v110_ucDataByte;	/* Data byte being converted */
	BYTE v110_ucLoop1;		/* Loop counter */
	int v110_iBytesProcessed=0;	/* # RA2 bytes processed */
#else
	G(v110_iBytesProcessed) = 0;
#endif

/*ltprintf( "v110GetRA2Byte cnt=%d cycles=%d bits=%d mask=%xH\n", ucFrameByteCnt, V110Control.ucCycles, V110Control.ucBitsPerOctet, V110Control.ucMask );*/

#if defined(DEBUG_RCV_RA2) || defined( NOT_FAST )
	/* Tell application */
	(*V110EventCallback)( ILV110_EVENT_RCV_RA2_TRACE,
			      (LWORD)(LWORD *)(pFrameData) );
#endif

	/* Check if RA2 bit addition is necessary */
	if ( G(V110Control).uRA2Rate == V110_RA2_NONE ) {

		/* Just pull out one raw frame byte - no RA2 */
		G(v110_ucRA1Byte) = *pFrameData;
		G(v110_iBytesProcessed) = 1;
	}
	else {

		/* Make sure enough RA2 bytes are available to create an RA1
			byte */
if (0) {
		if ( ucFrameByteCnt >= G(V110Control).ucCycles  ) {

			/* Now convert all bits in the byte */
			G(v110_ucRA1Byte) = 0;
			for ( G(v110_ucLoop1)=0; G(v110_ucLoop1)<G(V110Control).ucCycles; ++G(v110_ucLoop1) ) {

				/* Fetch new data byte to convert */
				G(v110_ucDataByte) = *(pFrameData+G(v110_ucLoop1));

				/* Convert next batch of bits */
//				G(v110_ucRA1Byte) = ((G(v110_ucRA1Byte)) << G(V110Control).ucBitsPerOctet) |
//						(G(v110_ucDataByte) & G(V110Control).ucMask);
				G(v110_ucRA1Byte) |= ((G(v110_ucDataByte) & G(V110Control).ucMask) 
								<< (G(v110_ucLoop1)*G(V110Control).ucBitsPerOctet));
/*ltprintf( "%x(%x) ", G(v110_ucDataByte), G(v110_ucRA1Byte) );*/
			}

			/* Set # RA2 bytes processed */
			G(v110_iBytesProcessed) = G(V110Control).ucCycles;
/*ltprintf( "result RA2 decoded %02x cnt=%d\n", G(v110_ucRA1Byte), G(v110_iBytesProcessed) );*/

		}
		else {

/*ltprintf( "not enough RA2 bytes\n" );*/
			/* Not enough RA2 bytes to create full RA1 byte */
			G(v110_iBytesProcessed) = -1;
		} 
}	// if (0)

		G(v110_ucRA1Byte) = *pFrameData;
		G(v110_iBytesProcessed) = 1;
		if (( G(V110Control).uState < V110_STATE_DATA_XFER ) 
			&& (!(G(v110_uRA2BitShiftFound))) )	// jc-6/11/99

		{
			if (++G(v110_uRA1ByteCnt) > 800)   // 100 v110 frames
			{
				G(v110_uRA1ByteCnt) = 0;
				G(v110_bPrevSyncFound) = 0;
				G(v110_rx_octets).w = 0xffff;	// initialize it
				G(V110Control).uState = V110_STATE_AWAIT_SYNC;

				// change shift amount from initial value of 8
				G(v110_shift_amount) = G(v110_shift_amount) - 1;
				if (G(v110_shift_amount) == 0)
					G(v110_shift_amount) = 8;
#if defined( Z80_DEBUG_PRINT )
				x_debug_msg("shift=");
				sendHexByte(G(v110_shift_amount));
#endif
			}
			G(v110_rx_octets).w = G(v110_rx_octets).w >> (8-G(v110_shift_amount));
			G(v110_rx_octets).b[1] = G(v110_ucRA1Byte);	// new byte processed
			G(v110_rx_octets).w = (G(v110_rx_octets).w >> G(v110_shift_amount)); 
			G(v110_ucRA1Byte) = G(v110_rx_octets).b[0];
		}
	}

	return( G(v110_iBytesProcessed) );
}

/*************************************************************************
**									**
** name		: v110SendRA2Frame					**
** purpose	: Build and send V.110 RA2 frame			**
** inputs	: 							**
**		.frame buffer address					**
**		.frame byte size					**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110SendRA2Frame( BYTE *pFrameData,
			      BYTE ucFrameByteCnt )
{
	BYTE ucDataByte;	/* Data byte being converted */
	BYTE ucRA2DataByte;	/* Converted RA2 data byte */
	BYTE ucRA2DataIndex;	/* Index into RA2 data buffer */
	BYTE ucLoop1, ucLoop2;	/* Loop counters */


#if defined(DEBUG_XMT_RA1) || defined( NOT_FAST )
	/* Tell application */
	(*V110EventCallback)( ILV110_EVENT_XMT_RA1_TRACE,
			      (LWORD)(LWORD *)(pFrameData) );
#endif

	/* Check if RA2 bit addition is necessary */
//	if ( G(V110Control).uRA2Rate == V110_RA2_NONE ) {
	if (1) {

		/* Just send out raw frame bytes */
		ILV110_SendRawData( pFrameData,
				    ucFrameByteCnt );
	}
	else {

		/* Convert RA1 data to RA2 data depending on rate */
		for ( ucLoop1=0, ucRA2DataIndex=0; ucLoop1<ucFrameByteCnt;
		++ucLoop1 ) {

			/* Fetch new data byte to convert */
			ucDataByte = *(pFrameData+ucLoop1);

			/* Now convert all bits in the byte */
			for ( ucLoop2=0; ucLoop2<G(V110Control).ucCycles; ++ucLoop2 ) {

				/* Convert next batch of bits */
				ucRA2DataByte = (ucDataByte & G(V110Control).ucMask) | ~G(V110Control).ucMask;

				/* Save RA2 data byte */
				G(V110Control).ucXmtRA2Data[ucRA2DataIndex++] = ucRA2DataByte;

				/* Shift next batch of bits to bottom of byte */
				ucDataByte >>= G(V110Control).ucBitsPerOctet;
			}
		}

		/* Now send out RA2 adapted bytes */
		ILV110_SendRawData( &G(V110Control).ucXmtRA2Data[0],
				    ucRA2DataIndex );

#if defined(DEBUG_XMT_RA2) || defined( NOT_FAST )
		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_XMT_RA2_TRACE,
				      (LWORD)(LWORD *)(&G(V110Control).ucXmtRA2Data[0]) );
#endif
	}
}

/*************************************************************************
**									**
** name		: v110SetStatusBits					**
** purpose	: Set status bits for V.110 frame			**
** inputs	: 							**
**		.octet number						**
** outputs	: 							**
**		.byte with status bits set				**
**									**
*************************************************************************/
non_banked static BYTE v110SetStatusBits( WORD uByteNumber ) // jc-rel-41
{
	BYTE ucStatusByte;	/* Status byte to return */

/*ltprintf( "SetStatusBits %d DSR=%xH DTR=%xH\n",  uByteNumber, G(V110DataTx).ucCircuit107_DSR << 7, G(V110DataTx).ucCircuit108_DTR << 7 );*/
	/* Insert S and X status bits depending on byte number */
	if ( uByteNumber == 1 ) {
		if ( G(V110Control).uDTEDCE == V110_DTE )
			ucStatusByte = G(V110DataTx).ucCircuit108_DTR;
		else
			ucStatusByte = G(V110DataTx).ucCircuit107_DSR;
	}
	else if ( uByteNumber == 2 ) {
		if ( G(V110Control).uDTEDCE == V110_DCE )
			ucStatusByte = G(V110DataTx).ucCircuit106_CTS;
		else
			ucStatusByte = V110_CIRCUIT_ON;
	}
	else if ( uByteNumber == 3 ) {
		if ( G(V110Control).uDTEDCE == V110_DTE )
			ucStatusByte = G(V110DataTx).ucCircuit108_DTR;
		else
			ucStatusByte = G(V110DataTx).ucCircuit107_DSR;
	}
	else if ( uByteNumber == 4 ) {
		if ( G(V110Control).uDTEDCE == V110_DTE )
			ucStatusByte = G(V110DataTx).ucCircuit105_RTS;
		else
			ucStatusByte = G(V110DataTx).ucCircuit106_CTS;
	}
	else if ( uByteNumber == 6 ) {
		if ( G(V110Control).uDTEDCE == V110_DTE )
			ucStatusByte = G(V110DataTx).ucCircuit108_DTR;
		else
			ucStatusByte = G(V110DataTx).ucCircuit107_DSR;
	}
	else if ( uByteNumber == 7 ) {
		if ( G(V110Control).uDTEDCE == V110_DCE )
			ucStatusByte = G(V110DataTx).ucCircuit106_CTS;
		else
			ucStatusByte = V110_CIRCUIT_ON;
	}
	else if ( uByteNumber == 8 ) {
		if ( G(V110Control).uDTEDCE == V110_DTE )
			ucStatusByte = G(V110DataTx).ucCircuit108_DTR;
		else
			ucStatusByte = G(V110DataTx).ucCircuit107_DSR;
	}
	else if ( uByteNumber == 9 ) {
		if ( G(V110Control).uDTEDCE == V110_DTE )
			ucStatusByte = G(V110DataTx).ucCircuit105_RTS;
		else
			ucStatusByte = G(V110DataTx).ucCircuit106_CTS;
	}

	return( ucStatusByte );
}

/*************************************************************************
**									**
** name		: v110InsertData600_1200_2400				**
** purpose	: Insert data for 600, 1200, 2400 RA1 rate V.110 frame	**
** inputs	: 							**
**		.data byte						**
**		.replication count maximum				**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110InsertData600_1200_2400( BYTE ucRepCountMax )
{
#if defined( NOT_FAST )
	BYTE v110_ucLoop1;			/* Loop counter */
	BOOLEAN v110_bInsertedStartBit=FALSE;/* Inserted start bit flag */
	BYTE v110_ucStopBitsInserted=0;	/* # stop bits inserted in current byte */
	BOOLEAN v110_bReplicate=FALSE;	/* Replicate bit flag */
	BYTE v110_ucRepCount=0;		/* Data bit replication count */
	BYTE v110_ucRepBit=0;		/* Replicate this bit */
#else
	G(v110_bInsertedStartBit) = FALSE;
	G(v110_ucStopBitsInserted) = 0;
	G(v110_bReplicate) = FALSE;
	G(v110_ucRepCount) = 0;
	G(v110_ucRepBit) = 0;
#endif

/*ltprintf( "insert 600/1200/2400 (%xH) cnt=%d max=%d\n", G(V110DataTx).ucData, V110Control.ucXmtFrameByteCnt, ucRepCountMax );*/

	/* Check if starting new frame */
	if ( G(V110Control).ucXmtFrameByteCnt == 0 ) {

		/* Insert framing byte */
		G(V110Control).ucXmtFrameData[0] = 0;

		/* One frame byte */
		G(V110Control).ucXmtFrameByteCnt = 1;
	}

	/* Insert all bits */
	G(v110_ucLoop1) = 0;
	while( 1 ) {

/*ltprintf( "bit cnt=%d\n", G(V110Control).ucXmtBitCount );*/
		/* Check if current byte is complete; already added status bit
			 so check for 7 bits long */
		if ( G(V110Control).ucXmtBitCount == 7 ) {

/*ltprintf( "formed new xmt byte %xH\n", G(V110Control).ucCurrentXmtByte );*/
			/* Setup for next byte */
			G(V110Control).ucXmtBitCount = 0;

			/* Insert byte in frame */
			G(V110Control).ucXmtFrameData[G(V110Control).ucXmtFrameByteCnt] =
				G(V110Control).ucCurrentXmtByte;
			G(V110Control).ucCurrentXmtByte = 0;

			/* Check if current frame is complete */
			if ( ++G(V110Control).ucXmtFrameByteCnt ==
			     V110_FRAME_SIZE_BYTES ) {

				/* Now send frame through RA2 stage */
				v110SendRA2Frame( &G(V110Control).ucXmtFrameData[0],
					V110_FRAME_SIZE_BYTES );

				/* Insert framing byte */
				G(V110Control).ucXmtFrameData[0] = 0;

				/* One frame byte */
				G(V110Control).ucXmtFrameByteCnt = 1;
			}
			else if ( G(V110Control).ucXmtFrameByteCnt == 5 ) {

				/* No data bits in byte 5 */
				G(V110Control).ucXmtFrameData[5] =
					G(V110Control).uEbits |
					G(V110Control).uCbits |
					G(V110Control).uE7bit |
					0x01;
				++G(V110Control).ucXmtFrameByteCnt;
			}
		}

		/* Check if beginning of new byte */
		if ( G(V110Control).ucXmtBitCount == 0 ) {

			/* Set the status bits depending on byte # */
			G(V110Control).ucCurrentXmtByte = v110SetStatusBits( G(V110Control).ucXmtFrameByteCnt );
/*ltprintf( "status bits only byte=%xH\n", G(V110Control).ucCurrentXmtByte );*/

			/* Insert the framing bit */
			G(V110Control).ucCurrentXmtByte |= 1;
			G(V110Control).ucXmtBitCount = 1;
		}

		/* Check if replicating a bit */
		if ( G(v110_bReplicate) ) {

			/* Insert replicated bit */
			G(V110Control).ucCurrentXmtByte |=
				(G(v110_ucRepBit) << G(V110Control).ucXmtBitCount);
/*ltprintf( "rep data bit=%d\n", G(v110_ucRepBit) );*/

			/* One more bit */
			++G(V110Control).ucXmtBitCount;

			/* Check if replicated all */
			if ( ++G(v110_ucRepCount) == ucRepCountMax )
				G(v110_bReplicate) = FALSE;
		}

		else {

		/* Check if start bit was inserted */
		if ( !G(v110_bInsertedStartBit) ) {
/*ltprintf( "Start bit\n" );*/

			/* Set the start bit */
			G(V110Control).ucCurrentXmtByte &= ~(1 << G(V110Control).ucXmtBitCount);

			/* Inserted start bit */
			G(v110_bInsertedStartBit) = TRUE;
			++G(V110Control).ucXmtBitCount;
			G(v110_ucRepCount) = 1;
			G(v110_bReplicate) = TRUE;
			G(v110_ucRepBit) = 0;
		}
		/* Check if processed all data bits */
		else if ( G(v110_ucLoop1) == 8 ) {

			/* Check for stop bits */
			if ( G(v110_ucStopBitsInserted) != G(V110Control).uStopBits ) {

/*ltprintf( "Stop bit\n" );*/
				/* Insert stop bit */
				G(V110Control).ucCurrentXmtByte |= (1) << G(V110Control).ucXmtBitCount;

				/* One more stop bit inserted */
				++G(v110_ucStopBitsInserted);
				++G(V110Control).ucXmtBitCount;
				G(v110_ucRepCount) = 1;
				G(v110_bReplicate) = TRUE;
				G(v110_ucRepBit) = 1;
			}
			else {

				/* Finished with this byte */
				break;
			}
		}
		else {

			/* Encode next bit */
			G(v110_ucRepBit) = G(V110DataTx).ucData & 1;
			G(V110Control).ucCurrentXmtByte |=
				(G(v110_ucRepBit) << G(V110Control).ucXmtBitCount);
/*ltprintf( "new data bit=%d\n", G(v110_ucRepBit) );*/

			/* One more bit processed */
			G(V110DataTx).ucData >>= 1;
			++G(V110Control).ucXmtBitCount;
			++G(v110_ucLoop1);
			G(v110_ucRepCount) = 1;
			G(v110_bReplicate) = TRUE;
		}
/*ltprintf( "Current Byte=%xH\n", G(V110Control).ucCurrentXmtByte );*/
		}
	}
}

/*************************************************************************
**									**
** name		: v110InsertData3600_12000				**
** purpose	: Insert data for 3600, 12000 RA1 rate V.110 frame	**
** inputs	: 							**
**		.data byte						**
**		.rate 12000 indicator flag				**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110InsertData3600_12000( BOOLEAN b12000 )
{
#if defined( NOT_FAST )
	BYTE v110_ucLoop1;			/* Loop counter */
	BOOLEAN v110_bInsertedStartBit=FALSE;/* Inserted start bit flag */
	BYTE v110_ucStopBitsInserted=0;	/* # stop bits inserted in current byte */
#else
	G(v110_bInsertedStartBit) = FALSE;
	G(v110_ucStopBitsInserted) = 0;
#endif

/*ltprintf( "insert 3600,12000 (%xH) cnt=%d 12000=%d\n", G(v110_ucDataByte), V110Control.ucXmtFrameByteCnt, b12000 );*/

	/* Check if starting new frame */
	if ( G(V110Control).ucXmtFrameByteCnt == 0 ) {

		/* Insert framing byte */
		G(V110Control).ucXmtFrameData[0] = 0;

		/* One frame byte */
		G(V110Control).ucXmtFrameByteCnt = 1;
	}

	/* Insert all bits */
	G(v110_ucLoop1) = 0;
	while( 1 ) {

/*ltprintf( "bit cnt=%d\n", G(V110Control).ucXmtBitCount );*/
		/* Check if current byte is complete; already added status bit
			 so check for 7 bits long */
		if ( G(V110Control).ucXmtBitCount == 7 ) {

/*ltprintf( "formed new xmt byte %xH\n", G(V110Control).ucCurrentXmtByte );*/
			/* Setup for next byte */
			G(V110Control).ucXmtBitCount = 0;

			/* Insert byte in frame */
			G(V110Control).ucXmtFrameData[G(V110Control).ucXmtFrameByteCnt] =
				G(V110Control).ucCurrentXmtByte;
			G(V110Control).ucCurrentXmtByte = 0;

			/* Check if current frame is complete */
			if ( ++G(V110Control).ucXmtFrameByteCnt ==
			     V110_FRAME_SIZE_BYTES ) {

				/* Now send frame through RA2 stage */
				v110SendRA2Frame( &G(V110Control).ucXmtFrameData[0],
					V110_FRAME_SIZE_BYTES );

				/* Insert framing byte */
				G(V110Control).ucXmtFrameData[0] = 0;

				/* One frame byte */
				G(V110Control).ucXmtFrameByteCnt = 1;
			}
			else if ( G(V110Control).ucXmtFrameByteCnt == 5 ) {

				/* No data bits in byte 5 */
				G(V110Control).ucXmtFrameData[5] =
					G(V110Control).uEbits |
					G(V110Control).uCbits |
					G(V110Control).uE7bit |
					0x01;
				++G(V110Control).ucXmtFrameByteCnt;
			}
		}

		/* Check if beginning of new byte */
		if ( G(V110Control).ucXmtBitCount == 0 ) {

			/* Set the status bits depending on byte # */
			G(V110Control).ucCurrentXmtByte = v110SetStatusBits( G(V110Control).ucXmtFrameByteCnt );
/*ltprintf( "status bits only byte=%xH\n", G(V110Control).ucCurrentXmtByte );*/

			/* Insert the framing bit */
			G(V110Control).ucCurrentXmtByte |= 1;
			G(V110Control).ucXmtBitCount = 1;
		}

		/* Check for fill F bits */
		if ( (G(V110Control).ucXmtFrameByteCnt == 2 &&
		      (G(V110Control).ucXmtBitCount == 5 ||
		       G(V110Control).ucXmtBitCount == 6)) ||
		     (G(V110Control).ucXmtFrameByteCnt == 3 &&
		      (G(V110Control).ucXmtBitCount == 3 ||
		       G(V110Control).ucXmtBitCount == 4)) ||
		     (G(V110Control).ucXmtFrameByteCnt == 4 &&
		      ((b12000 &&
			(G(V110Control).ucXmtBitCount == 1 ||
			 G(V110Control).ucXmtBitCount == 2 ||
			 G(V110Control).ucXmtBitCount == 4 ||
			 G(V110Control).ucXmtBitCount == 5 ||
			 G(V110Control).ucXmtBitCount == 6)) ||
		       (!b12000 &&
			(G(V110Control).ucXmtBitCount == 1 ||
			 G(V110Control).ucXmtBitCount == 2)))) ||
		     (G(V110Control).ucXmtFrameByteCnt == 7 &&
		      (G(V110Control).ucXmtBitCount == 5 ||
		       G(V110Control).ucXmtBitCount == 6)) ||
		     (G(V110Control).ucXmtFrameByteCnt == 8 &&
		      (G(V110Control).ucXmtBitCount == 3 ||
		       G(V110Control).ucXmtBitCount == 4)) ||
		     (G(V110Control).ucXmtFrameByteCnt == 9 &&
		      ((b12000 &&
			(G(V110Control).ucXmtBitCount == 1 ||
			 G(V110Control).ucXmtBitCount == 2 ||
			 G(V110Control).ucXmtBitCount == 4 ||
			 G(V110Control).ucXmtBitCount == 5 ||
			 G(V110Control).ucXmtBitCount == 6)) ||
		       (!b12000 &&
			(G(V110Control).ucXmtBitCount == 1 ||
			 G(V110Control).ucXmtBitCount == 2)))) ) {

			/* Insert fill F bit */
			G(V110Control).ucCurrentXmtByte |= (1) << G(V110Control).ucXmtBitCount;

			/* One bit inserted */
			++G(V110Control).ucXmtBitCount;
		}
		else {

		/* Check if start bit was inserted */
		if ( !G(v110_bInsertedStartBit) ) {
/*ltprintf( "Start bit\n" );*/

			/* Set the start bit */
			G(V110Control).ucCurrentXmtByte &= ~(1 << G(V110Control).ucXmtBitCount);

			/* Inserted start bit */
			G(v110_bInsertedStartBit) = TRUE;
			++G(V110Control).ucXmtBitCount;
		}
		/* Check if processed all data bits */
		else if ( G(v110_ucLoop1) == 8 ) {

			/* Check for stop bits */
			if ( G(v110_ucStopBitsInserted) != G(V110Control).uStopBits ) {

/*ltprintf( "Stop bit\n" );*/
				/* Insert stop bit */
				G(V110Control).ucCurrentXmtByte |= (1) << G(V110Control).ucXmtBitCount;

				/* One more stop bit inserted */
				++G(v110_ucStopBitsInserted);
				++G(V110Control).ucXmtBitCount;
			}
			else {

				/* Finished with this byte */
				break;
			}
		}
		else {

			/* Encode next bit */
			G(V110Control).ucCurrentXmtByte |= (G(V110DataTx).ucData&1) << G(V110Control).ucXmtBitCount;
/*ltprintf( "new data bit=%d\n", G(V110DataTx).ucData&1 );*/

			/* One more bit processed */
			G(V110DataTx).ucData >>= 1;
			++G(V110Control).ucXmtBitCount;
			++G(v110_ucLoop1);
		}
/*ltprintf( "Current Byte=%xH\n", G(V110Control).ucCurrentXmtByte );*/
		}
	}
}

/*************************************************************************
**									**
** name		: v110InsertData4800					**
** purpose	: Insert data for 4800 RA1 rate V.110 frame		**
** inputs	: 							**
**		.data byte						**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110InsertData4800( void )
{
#if defined( NOT_FAST )
	BYTE v110_ucLoop1;			/* Loop counter */
	BOOLEAN v110_bInsertedStartBit=FALSE;/* Inserted start bit flag */
	BYTE v110_ucStopBitsInserted=0;	/* # stop bits inserted in current byte */
#else
	G(v110_bInsertedStartBit) = FALSE;
	G(v110_ucStopBitsInserted) = 0;
#endif

/*ltprintf( "insert 4800 (%xH) cnt=%d\n", G(V110DataTx).ucData, G(V110Control).ucXmtFrameByteCnt );*/

	/* Check if starting new frame */
	if ( G(V110Control).ucXmtFrameByteCnt == 0 ) {

		/* Insert framing byte */
		G(V110Control).ucXmtFrameData[0] = 0;

		/* One frame byte */
		G(V110Control).ucXmtFrameByteCnt = 1;
	}

	/* Insert all bits */
	G(v110_ucLoop1) = 0;
	while( 1 ) {

/*ltprintf( "bit cnt=%d\n", G(V110Control).ucXmtBitCount );*/
		/* Check if current byte is complete; already added status bit
			 so check for 7 bits long */
		if ( G(V110Control).ucXmtBitCount == 7 ) {

/*ltprintf( "formed new xmt byte %xH\n", G(V110Control).ucCurrentXmtByte );*/
			/* Setup for next byte */
			G(V110Control).ucXmtBitCount = 0;

			/* Insert byte in frame */
			G(V110Control).ucXmtFrameData[G(V110Control).ucXmtFrameByteCnt] =
				G(V110Control).ucCurrentXmtByte;
			G(V110Control).ucCurrentXmtByte = 0;

			/* Check if current frame is complete */
			if ( ++G(V110Control).ucXmtFrameByteCnt ==
			     V110_FRAME_SIZE_BYTES  ) {

				/* Now send frame through RA2 stage */
				// x_debug_msg("CB - Calling SendRA2");
				v110SendRA2Frame( &G(V110Control).ucXmtFrameData[0],
					V110_FRAME_SIZE_BYTES );

				/* Insert framing byte */
				G(V110Control).ucXmtFrameData[0] = 0;

				/* One frame byte */
				G(V110Control).ucXmtFrameByteCnt = 1;
			}
			else if ( G(V110Control).ucXmtFrameByteCnt == 5 ) {

				/* No data bits in byte 5 */
				G(V110Control).ucXmtFrameData[5] =
					G(V110Control).uEbits |
					G(V110Control).uCbits |
					G(V110Control).uE7bit |
					0x01;
				++G(V110Control).ucXmtFrameByteCnt;
				// x_debug_msg("CB - Inside Elseif clause.");
			}
			// x_debug_msg("CB - None of the above!");
		}

		/* Check if beginning of new byte */
		if ( G(V110Control).ucXmtBitCount == 0 ) {

			/* Set the status bits depending on byte # */
			G(V110Control).ucCurrentXmtByte = v110SetStatusBits( G(V110Control).ucXmtFrameByteCnt );
/*ltprintf( "status bits only byte=%xH\n", G(V110Control).ucCurrentXmtByte );*/

			/* Insert the framing bit */
			G(V110Control).ucCurrentXmtByte |= 1;
			G(V110Control).ucXmtBitCount = 1;
		}

		/* Check if start bit was inserted */
		if ( !G(v110_bInsertedStartBit) ) {
/*ltprintf( "Start bit\n" );*/

			/* Set the start bit */
			G(V110Control).ucCurrentXmtByte &= ~(1 << G(V110Control).ucXmtBitCount);
/*ltprintf( "start bit in %xH\n", G(V110Control).ucCurrentXmtByte );*/

			/* Inserted start bit */
			G(v110_bInsertedStartBit) = TRUE;
			++G(V110Control).ucXmtBitCount;
		}
		/* Check if processed all data bits */
		else if ( G(v110_ucLoop1) == 8 ) {

			/* Check for stop bits */
			if ( G(v110_ucStopBitsInserted) != G(V110Control).uStopBits ) {

/*ltprintf( "Stop bit\n" );*/
				/* Insert stop bit */
				G(V110Control).ucCurrentXmtByte |= (1) << G(V110Control).ucXmtBitCount;

				/* One more stop bit inserted */
				++G(v110_ucStopBitsInserted);
				++G(V110Control).ucXmtBitCount;
			}
			else {

				/* Finished with this byte */
				break;
			}
		}
		else {

			/* Encode next bit */
			G(V110Control).ucCurrentXmtByte |= (G(V110DataTx).ucData&1) << G(V110Control).ucXmtBitCount;
/*ltprintf( "new data bit=%d\n", G(V110DataTx).ucData&1 );*/

			/* One more bit processed */
			G(V110DataTx).ucData >>= 1;
			++G(V110Control).ucXmtBitCount;
			++G(v110_ucLoop1);
		}
/*ltprintf( "Current Byte=%xH\n", G(V110Control).ucCurrentXmtByte );*/
	}
}

/*************************************************************************
**									**
** name		: v110InsertData					**
** purpose	: Insert data to fresh V.110 RA1 frame			**
** inputs	: 							**
**		.data byte						**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110InsertData( void )
{

	/* Insert depending on RA2 rate */
	switch ( G(V110Control).uRA2Rate ) {
	case V110_RA2_8K:
	case V110_RA2_16K:
	case V110_RA2_32K:

		/* Process depending on the RA1 adaption rate */
		switch ( G(V110Control).uEbits ) {
		case V110_EBITS_600:
			v110InsertData600_1200_2400( 8 );
			break;

		case V110_EBITS_1200:
			v110InsertData600_1200_2400( 4 );
			break;

		case V110_EBITS_2400:
			v110InsertData600_1200_2400( 2 );
			break;

		case V110_EBITS_3600:
			v110InsertData3600_12000( FALSE );			break;

		case V110_EBITS_4800:
			v110InsertData4800();
			break;

		case V110_EBITS_12000:
			v110InsertData3600_12000( TRUE );
			break;
		}
		break;

	case V110_RA2_NONE:
		/* Insert depending on rate */
		switch ( G(V110Control).uRate ) {
		case V110_RATE_56000:
//			v110InsertData56000();
			break;

		case V110_RATE_48000:
//			v110InsertData48000();
			break;

		case V110_RATE_38400:
			v110InsertData4800();
			break;

		case V110_RATE_28800:
			v110InsertData3600_12000( FALSE );
			break;

		case V110_RATE_24000:
			v110InsertData3600_12000( TRUE );			break;
		}
		break;
	}
}

/*************************************************************************
**									**
** name		: v110SerialDecode					**
** purpose	: Decode serial V.110 data				**
** inputs	: 							**
**		.init local controls flag; TRUE=init			**
**		.bit to decode						**
** outputs	: 							**
**		.pointer to decoded BYTE, or NULL if none yet		**
**									**
*************************************************************************/
non_banked static BYTE *v110SerialDecode( BOOLEAN bInit,
					BYTE ucBit )
{
	static BYTE ucSerialByte;	/* Serial byte decoded */
	static BYTE ucBitCount;		/* Bit count of current serial byte */
	static BOOLEAN bFoundStartBit;	/* Found start bit flag */
	static BYTE ucInitNextCycle;		/* Init next cycle flag */
	static BYTE ucStopBitsFound;	/* # stop bits found in current byte */
#if defined( NOT_FAST )
	BYTE *v110_pRet=NULL;			/* Return byte pointer */
#else
	G(v110_pRet) = NULL;
#endif

	/* Check if initializing local controls */
	if ( bInit || ucInitNextCycle ) {

		/* Initialize */
		ucSerialByte = 0;
		ucBitCount = 0;
		ucStopBitsFound = 0;

		/* Clear found start bit flag only if a stop bit wasn't
			detected in it's place and the start bit would have
			been the last bit processed last cycle */
		if ( ucInitNextCycle == 1 )
			bFoundStartBit = FALSE;
		ucInitNextCycle = 0;
	}

	/* One-time initialization, just return */
	if ( bInit )
		return( NULL );

	/* Check if start bit found */
	if ( bFoundStartBit ) {

		/* Check if found all data bits */
		if ( ucBitCount == 8 ) {

/*ltprintf( "Stop bit\n" );*/
			/* Stop bit found */
			if ( ++ucStopBitsFound ==
				G(V110Control).uStopBits ||
				ucBit == 0 ) {

				/* Check if rolled right into start bit without
					a stop bit */
				if ( ucBit == 0 ) {
/*ltprintf( "No stop bit!! Simulating\n" );*/
					ucInitNextCycle = 2;
				}
				else {
					ucInitNextCycle = 1;
				}
				/* Byte completed */
				G(v110_pRet) = &ucSerialByte;
/*ltprintf( "complete byte=%xH\n", ucSerialByte );*/
			}
		}
		else {

			/* Shift new data bit */
			ucSerialByte = ucSerialByte |
				(ucBit << ucBitCount);
			++ucBitCount;
/*ltprintf( "bit=%d byte=%xH bit #s=%d\n", ucBit, ucSerialByte, ucBitCount );*/
		}
	}
	else {

		/* Check for Start bit */
		if ( !ucBit ) {
/*ltprintf( "Start bit\n" );*/
			bFoundStartBit = TRUE;
		}

		/* Just ignore start bit */
		G(v110_pRet) = NULL;
	}

	return( G(v110_pRet) );
}

/*************************************************************************
**									**
** name		: v110ExtractStatusBits					**
** purpose	: Extract status bits from V.110 frame			**
** inputs	: 							**
**		.octet number						**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110ExtractStatusBits( WORD uByteNumber )
{
	/* Pull S and X status bits from the frame and save them */
	if ( uByteNumber == 1 ) {
		if ( G(V110Control).uDTEDCE == V110_DTE )
			G(V110Data).ucCircuit108_DTR =
				G(V110Control).ucRcvFrameData[1] & 0x80;
		else
			G(V110Data).ucCircuit107_DSR =
				G(V110Control).ucRcvFrameData[1] & 0x80;
	}
	else if ( uByteNumber == 2 ) {
		if ( G(V110Control).uDTEDCE == V110_DCE )
			G(V110Data).ucCircuit106_CTS =
				G(V110Control).ucRcvFrameData[2] & 0x80;
	}
	else if ( uByteNumber == 3 ) {
		if ( G(V110Control).uDTEDCE == V110_DTE )
			G(V110Data).ucCircuit108_DTR =
				G(V110Control).ucRcvFrameData[3] & 0x80;
		else
			G(V110Data).ucCircuit107_DSR =
				G(V110Control).ucRcvFrameData[3] & 0x80;
	}
	else if ( uByteNumber == 4 ) {
		if ( G(V110Control).uDTEDCE == V110_DTE )
			G(V110Data).ucCircuit105_RTS =
				G(V110Control).ucRcvFrameData[4] & 0x80;
		else
			G(V110Data).ucCircuit106_CTS =
				G(V110Control).ucRcvFrameData[4] & 0x80;
	}
	else if ( uByteNumber == 6 ) {
		if ( G(V110Control).uDTEDCE == V110_DTE )
			G(V110Data).ucCircuit108_DTR =
				G(V110Control).ucRcvFrameData[6] & 0x80;
		else
			G(V110Data).ucCircuit107_DSR =
				G(V110Control).ucRcvFrameData[6] & 0x80;
	}
	else if ( uByteNumber == 7 ) {
		if ( G(V110Control).uDTEDCE == V110_DCE )
			G(V110Data).ucCircuit106_CTS =
				G(V110Control).ucRcvFrameData[7] & 0x80;
	}
	else if ( uByteNumber == 8 ) {
		if ( G(V110Control).uDTEDCE == V110_DTE )
			G(V110Data).ucCircuit108_DTR =
				G(V110Control).ucRcvFrameData[8] & 0x80;
		else
			G(V110Data).ucCircuit107_DSR =
				G(V110Control).ucRcvFrameData[8] & 0x80;
	}
	else if ( uByteNumber == 9 ) {
		if ( G(V110Control).uDTEDCE == V110_DTE )
			G(V110Data).ucCircuit105_RTS =
				G(V110Control).ucRcvFrameData[9] & 0x80;
		else
			G(V110Data).ucCircuit106_CTS =
				G(V110Control).ucRcvFrameData[9] & 0x80;
	}
}

/*************************************************************************
**									**
** name		: v110SupplyByte					**
** purpose	: Supply rcvd byte to application			**
** inputs	: 							**
**		.byte							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110SupplyByte( WORD uByteValue )
{
	/* Save byte */
	G(V110Data).ucData = uByteValue;

	/* Tell application */
	(*V110EventCallback)( ILV110_EVENT_DATA_INDICATION,
			      G(V110Data).ucData );
}

/*************************************************************************
**									**
** name		: v110ExtractData600					**
** purpose	: Extract data for 600 RA1 rate V.110 frame		**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110ExtractData600( void )
{
#if defined( NOT_FAST )
	BYTE v110_ucLoop1;			/* Loop counter */
	BYTE *v110_pRetByte;			/* Serial decode return byte pointer */
	BYTE v110_ucBits;			/* Contains bits decoding */
#endif

/*ltprintf( "extract 600\n" );*/

	/* Convert all data bits to bytes, and in the process strip out
		the start and stop bits */
	for( G(v110_ucLoop1)=1; G(v110_ucLoop1)<10; ++G(v110_ucLoop1) ) {

		/* Skip bytes */
		if ( G(v110_ucLoop1) == 3 || G(v110_ucLoop1) == 5 || G(v110_ucLoop1) == 8 )
			continue;

		/* Extract the status bits depending on Byte # */
		v110ExtractStatusBits( G(v110_ucLoop1) );

		/* Next Byte */
		if ( G(v110_ucLoop1) == 2 ) {

			/* Get D2 */
			G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 3;
		}
		else if ( G(v110_ucLoop1) == 7 ) {

			/* Get D5 */
			G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 3;
		}
		else {

			/* Get Dx */
			G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 1;
		}

		/* Decode the bit */
		G(v110_pRetByte) = v110SerialDecode( FALSE,
					     (BYTE)(G(v110_ucBits)&1) );

		/* Check if completed byte */
		if ( G(v110_pRetByte) != NULL ) {

/*ltprintf( "saving %xH\n", *G(v110_pRetByte) );*/
			/* Supply byte to application */
			v110SupplyByte( *G(v110_pRetByte) );
		}
	}
}

/*************************************************************************
**									**
** name		: v110ExtractData1200					**
** purpose	: Extract data for 1200 RA1 rate V.110 frame		**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110ExtractData1200( void )
{
#if defined( NOT_FAST )
	BYTE v110_ucLoop1;			/* Loop counter */
	BYTE *v110_pRetByte;			/* Serial decode return byte pointer */
	BYTE v110_ucBits;			/* Contains bits decoding */
#endif

/*ltprintf( "extract 1200\n" );*/

	/* Convert all data bits to bytes, and in the process strip out
		the start and stop bits */
	for( G(v110_ucLoop1)=1; G(v110_ucLoop1)<10; ++G(v110_ucLoop1) ) {

		/* Skip byte 5 */
		if ( G(v110_ucLoop1) == 5 )
			continue;

		/* Extract the status bits depending on Byte # */
		v110ExtractStatusBits( G(v110_ucLoop1) );

		/* Next Byte */
		if ( G(v110_ucLoop1) == 3 ) {

			/* Get D3 */
			G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)-1] >> 3;

			/* Decode the bit */
			G(v110_pRetByte) = v110SerialDecode( FALSE,
						     (BYTE)(G(v110_ucBits)&1) );

			/* Check if completed byte */
			if ( G(v110_pRetByte) != NULL ) {

/*ltprintf( "saving %xH\n", *G(v110_pRetByte) );*/
				/* Supply byte to application */
				v110SupplyByte( *G(v110_pRetByte) );
			}

			/* Get D4 */
			G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 1;
		}
		else if ( G(v110_ucLoop1) == 4 ) {

			/* Get D5 */
			G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 1;

			/* Decode the bit */
			G(v110_pRetByte) = v110SerialDecode( FALSE,
						     (BYTE)(G(v110_ucBits)&1) );

			/* Check if completed byte */
			if ( G(v110_pRetByte) != NULL ) {

/*ltprintf( "saving %xH\n", *G(v110_pRetByte) );*/
				/* Supply byte to application */
				v110SupplyByte( *G(v110_pRetByte) );
			}

			/* Get D6 */
			G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 3;
		}
		else if ( G(v110_ucLoop1) == 8 ) {

			/* Get D9 */
			G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)-1] >> 3;

			/* Decode the bit */
			G(v110_pRetByte) = v110SerialDecode( FALSE,
						     (BYTE)(G(v110_ucBits)&1) );

			/* Check if completed byte */
			if ( G(v110_pRetByte) != NULL ) {

/*ltprintf( "saving %xH\n", *G(v110_pRetByte) );*/
				/* Supply byte to application */
				v110SupplyByte( *G(v110_pRetByte) );
			}

			/* Get D10 */
			G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 1;
		}
		else if ( G(v110_ucLoop1) == 9 ) {

			/* Get D11 */
			G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 1;

			/* Decode the bit */
			G(v110_pRetByte) = v110SerialDecode( FALSE,
						     (BYTE)(G(v110_ucBits)&1) );

			/* Check if completed byte */
			if ( G(v110_pRetByte) != NULL ) {

/*ltprintf( "saving %xH\n", *G(v110_pRetByte) );*/
				/* Supply byte to application */
				v110SupplyByte( *G(v110_pRetByte) );
			}

			/* Get D12 */
			G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 3;
		}
		else {

			/* Get Dx */
			G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 1;
		}

		/* Decode the bit */
		G(v110_pRetByte) = v110SerialDecode( FALSE,
					     (BYTE)(G(v110_ucBits)&1) );

		/* Check if completed byte */
		if ( G(v110_pRetByte) != NULL ) {

/*ltprintf( "saving %xH\n", *G(v110_pRetByte) );*/
			/* Supply byte to application */
			v110SupplyByte( *G(v110_pRetByte) );
		}
	}
}

/*************************************************************************
**									**
** name		: v110ExtractData2400					**
** purpose	: Extract data for 2400 RA1 rate V.110 frame		**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110ExtractData2400( void )
{
#if defined( NOT_FAST )
	BYTE v110_ucLoop1;			/* Loop counter */
	BYTE *v110_pRetByte;			/* Serial decode return byte pointer */
	BYTE v110_ucBits;			/* Contains bits decoding */
#endif

/*ltprintf( "extract 2400\n" );*/

	/* Convert all data bits to bytes, and in the process strip out
		the start and stop bits */
	for( G(v110_ucLoop1)=1; G(v110_ucLoop1)<10; ++G(v110_ucLoop1) ) {

		/* Skip byte 5 */
		if ( G(v110_ucLoop1) == 5 )
			continue;

		/* Extract the status bits depending on Byte # */
		v110ExtractStatusBits( G(v110_ucLoop1) );

		/* Next Byte */
		G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 1;

		/* Decode the bit */
		G(v110_pRetByte) = v110SerialDecode( FALSE,
					     (BYTE)(G(v110_ucBits)&1) );

		/* Check if completed byte */
		if ( G(v110_pRetByte) != NULL ) {

/*ltprintf( "saving %xH\n", *G(v110_pRetByte) );*/
			/* Supply byte to application */
			v110SupplyByte( *G(v110_pRetByte) );
		}
		G(v110_ucBits) >>= 2;

		/* Decode the bit */
		G(v110_pRetByte) = v110SerialDecode( FALSE,
					     (BYTE)(G(v110_ucBits)&1) );

		/* Check if completed byte */
		if ( G(v110_pRetByte) != NULL ) {

/*ltprintf( "saving %xH\n", *G(v110_pRetByte) );*/
			/* Supply byte to application */
			v110SupplyByte( *G(v110_pRetByte) );
		}
		G(v110_ucBits) >>= 2;

		/* Decode the bit */
		G(v110_pRetByte) = v110SerialDecode( FALSE,
					     (BYTE)(G(v110_ucBits)&1) );

		/* Check if completed byte */
		if ( G(v110_pRetByte) != NULL ) {

/*ltprintf( "saving %xH\n", *G(v110_pRetByte) );*/
			/* Supply byte to application */
			v110SupplyByte( *G(v110_pRetByte) );
		}
	}
}

/*************************************************************************
**									**
** name		: v110ExtractData3600					**
** purpose	: Extract data for 3600 RA1 rate V.110 frame		**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110ExtractData3600( void )
{
#if defined( NOT_FAST )
	BYTE v110_ucLoop1, v110_ucLoop2;		/* Loop counters */
	BYTE *v110_pRetByte;			/* Serial decode return byte pointer */
	BYTE v110_ucBits;			/* Contains bits decoding */
#endif

/*ltprintf( "extract 3600\n" );*/

	/* Convert all data bits to bytes, and in the process strip out
		the start and stop bits */
	for( G(v110_ucLoop1)=1; G(v110_ucLoop1)<10; ++G(v110_ucLoop1) ) {

		/* Skip byte 5 */
		if ( G(v110_ucLoop1) == 5 )
			continue;

		/* Extract the status bits depending on Byte # */
		v110ExtractStatusBits( G(v110_ucLoop1) );

		/* Next Byte */
		G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 1;
		for( G(v110_ucLoop2)=0; G(v110_ucLoop2)<6; ++G(v110_ucLoop2) ) {
/*ltprintf( "v110_ucBits=%xH\n", G(v110_ucBits) );*/

			/* Check for F bit presence */
			if ( G(v110_ucLoop1) == 2 &&
			     (G(v110_ucLoop2) == 4 || G(v110_ucLoop2) == 5) ) {

				continue;
			}
			else if ( G(v110_ucLoop1) == 3 &&
				  (G(v110_ucLoop2) == 2 || G(v110_ucLoop2) == 3) ) {

				/* Move to next bit */
				G(v110_ucBits) >>= 1;
				continue;
			}
			else if ( G(v110_ucLoop1) == 4 &&
				  (G(v110_ucLoop2) == 0 || G(v110_ucLoop2) == 1) ) {

				/* Move to next bit */
				G(v110_ucBits) >>= 1;
				continue;
			}
			else if ( G(v110_ucLoop1) == 7 &&
				  (G(v110_ucLoop2) == 4 || G(v110_ucLoop2) == 5) ) {

				continue;
			}
			else if ( G(v110_ucLoop1) == 8 &&
				  (G(v110_ucLoop2) == 2 || G(v110_ucLoop2) == 3) ) {

				/* Move to next bit */
				G(v110_ucBits) >>= 1;
				continue;
			}
			else if ( G(v110_ucLoop1) == 9 &&
				  (G(v110_ucLoop2) == 0 || G(v110_ucLoop2) == 1) ) {

				/* Move to next bit */
				G(v110_ucBits) >>= 1;
				continue;
			}

			/* Decode the bit */
			G(v110_pRetByte) = v110SerialDecode( FALSE,
				(BYTE)(G(v110_ucBits)&1) );

			/* Check if completed byte */
			if ( G(v110_pRetByte) != NULL ) {

/*ltprintf( "saving %xH\n", *G(v110_pRetByte) );*/
				/* Supply byte to application */
				v110SupplyByte( *G(v110_pRetByte) );
			}

			/* Move to next bit */
			G(v110_ucBits) >>= 1;
		}
	}
}

/*************************************************************************
**									**
** name		: v110ExtractData4800					**
** purpose	: Extract data for 4800 RA1 rate V.110 frame		**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110ExtractData4800( void )
{
#if defined( NOT_FAST )
	BYTE v110_ucLoop1, v110_ucLoop2;		/* Loop counters */
	BYTE *v110_pRetByte;			/* Serial decode return byte pointer */
	BYTE v110_ucBits;			/* Contains bits decoding */
#endif

/*ltprintf( "extract 4800\n" );*/

	/* Convert all data bits to bytes, and in the process strip out
		the start and stop bits */
	for( G(v110_ucLoop1)=1; G(v110_ucLoop1)<10; ++G(v110_ucLoop1) ) {

		/* Skip byte 5 */
		if ( G(v110_ucLoop1) == 5 )
			continue;

		/* Extract the status bits depending on Byte # */
		v110ExtractStatusBits( G(v110_ucLoop1) );

		/* Next Byte */
		G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 1;
		for( G(v110_ucLoop2)=0; G(v110_ucLoop2)<6; ++G(v110_ucLoop2) ) {
/*ltprintf( "v100_ucBits=%xH\n", G(v110_ucBits) );*/

			/* Decode the bit */
			G(v110_pRetByte) = v110SerialDecode( FALSE,
				(BYTE)(G(v110_ucBits)&1) );

			/* Check if completed byte */
			if ( G(v110_pRetByte) != NULL ) {

/*ltprintf( "saving %xH\n", *G(v110_pRetByte) );*/
				/* Supply byte to application */
				v110SupplyByte( *G(v110_pRetByte) );
			}

			/* Move to next bit */
			G(v110_ucBits) >>= 1;
		}
	}
}

/*************************************************************************
**									**
** name		: v110ExtractData12000					**
** purpose	: Extract data for 12000 RA1 rate V.110 frame		**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110ExtractData12000( void )
{
#if defined( NOT_FAST )
	BYTE v110_ucLoop1, v110_ucLoop2;		/* Loop counters */
	BYTE *v110_pRetByte;			/* Serial decode return byte pointer */
	BYTE v110_ucBits;			/* Contains bits decoding */
#endif

/*ltprintf( "extract 12000\n" );*/

	/* Convert all data bits to bytes, and in the process strip out
		the start and stop bits */
	for( G(v110_ucLoop1)=1; G(v110_ucLoop1)<10; ++G(v110_ucLoop1) ) {

		/* Skip byte 5 */
		if ( G(v110_ucLoop1) == 5 )
			continue;

		/* Extract the status bits depending on Byte # */
		v110ExtractStatusBits( G(v110_ucLoop1) );

		/* Next Byte */
		G(v110_ucBits) = G(V110Control).ucRcvFrameData[G(v110_ucLoop1)] >> 1;
		for( G(v110_ucLoop2)=0; G(v110_ucLoop2)<6; ++G(v110_ucLoop2) ) {
/*ltprintf( "v110_ucBits=%xH\n", G(v110_ucBits) );*/

			/* Check for F bit presence */
			if ( G(v110_ucLoop1) == 2 &&
			     (G(v110_ucLoop2) == 4 || G(v110_ucLoop2) == 5) ) {

				continue;
			}
			else if ( G(v110_ucLoop1) == 3 &&
				  (G(v110_ucLoop2) == 2 || G(v110_ucLoop2) == 3) ) {

				/* Move to next bit */
				G(v110_ucBits) >>= 1;
				continue;
			}
			else if ( G(v110_ucLoop1) == 4 &&
				  (G(v110_ucLoop2) == 0 || G(v110_ucLoop2) == 1 ||
				   G(v110_ucLoop2) == 3 || G(v110_ucLoop2) == 4 ||
				   G(v110_ucLoop2) == 5) ) {

				/* Move to next bit */
				G(v110_ucBits) >>= 1;
				continue;
			}
			else if ( G(v110_ucLoop1) == 7 &&
				  (G(v110_ucLoop2) == 4 || G(v110_ucLoop2) == 5) ) {

				continue;
			}
			else if ( G(v110_ucLoop1) == 8 &&
				  (G(v110_ucLoop2) == 2 || G(v110_ucLoop2) == 3) ) {

				/* Move to next bit */
				G(v110_ucBits) >>= 1;
				continue;
			}
			else if ( G(v110_ucLoop1) == 9 &&
				  (G(v110_ucLoop2) == 0 || G(v110_ucLoop2) == 1 ||
				   G(v110_ucLoop2) == 3 || G(v110_ucLoop2) == 4 ||
				   G(v110_ucLoop2) == 5) ) {

				/* Move to next bit */
				G(v110_ucBits) >>= 1;
				continue;
			}

			/* Decode the bit */
			G(v110_pRetByte) = v110SerialDecode( FALSE,
				(BYTE)(G(v110_ucBits)&1) );

			/* Check if completed byte */
			if ( G(v110_pRetByte) != NULL ) {

/*ltprintf( "saving %xH\n", *G(v110_pRetByte) );*/
				/* Supply byte to application */
				v110SupplyByte( *G(v110_pRetByte) );
			}

			/* Move to next bit */
			G(v110_ucBits) >>= 1;
		}
	}
}

/*************************************************************************
**									**
** name		: v110ExtractData48000					**
** purpose	: Extract data for 48000 RA1 rate V.110 frame		**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110ExtractData48000( void )
{
	/* Check if sync or async */
	if ( G(V110Control).uSyncAsync == V110_TYPE_SYNC ) {

		/* D bits are all data */
		/* Fetch byte */
		G(V110Data).ucData = 
			((G(V110Control).ucRcvFrameData[0]&0x7e)>>1) |
			((G(V110Control).ucRcvFrameData[1]&0x06)<<6);

		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_DATA_INDICATION,
				      G(V110Data).ucData );

		/* Fetch byte */
		G(V110Data).ucData = 
			((G(V110Control).ucRcvFrameData[1]&0x78)>>3) |
			((G(V110Control).ucRcvFrameData[2]&0x1e)<<3);

		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_DATA_INDICATION,
				      G(V110Data).ucData );

		/* Fetch byte */
		G(V110Data).ucData = 
			((G(V110Control).ucRcvFrameData[2]&0x30)>>5) |
			((G(V110Control).ucRcvFrameData[3]&0x7e)<<1);

		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_DATA_INDICATION,
				      G(V110Data).ucData );
	}
	else {
		/* 48000 only for synchronous */
	}
}

/*************************************************************************
**									**
** name		: v110ExtractData56000					**
** purpose	: Extract data for 56000 RA1 rate V.110 frame		**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110ExtractData56000( void )
{
	/* Check if sync or async */
	if ( G(V110Control).uSyncAsync == V110_TYPE_SYNC ) {

		/* D bits are all data */
		/* Fetch byte */
		G(V110Data).ucData = 
			(G(V110Control).ucRcvFrameData[0]&0x7f) |
			((G(V110Control).ucRcvFrameData[1]&0x01)<<7);

		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_DATA_INDICATION,
				      G(V110Data).ucData );

		/* Fetch byte */
		G(V110Data).ucData = 
			((G(V110Control).ucRcvFrameData[1]&0x7e)>>1) |
			((G(V110Control).ucRcvFrameData[2]&0x03)<<6);

		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_DATA_INDICATION,
				      G(V110Data).ucData );

		/* Fetch byte */
		G(V110Data).ucData = 
			((G(V110Control).ucRcvFrameData[2]&0x7c)>>2) |
			((G(V110Control).ucRcvFrameData[3]&0x07)<<5);

		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_DATA_INDICATION,
				      G(V110Data).ucData );

		/* Fetch byte */
		G(V110Data).ucData = 
			((G(V110Control).ucRcvFrameData[3]&0x78)>>3) |
			((G(V110Control).ucRcvFrameData[4]&0x0f)<<4);

		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_DATA_INDICATION,
				      G(V110Data).ucData );

		/* Fetch byte */
		G(V110Data).ucData = 
			((G(V110Control).ucRcvFrameData[4]&0x70)>>4) |
			((G(V110Control).ucRcvFrameData[5]&0x1f)<<3);

		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_DATA_INDICATION,
				      G(V110Data).ucData );

		/* Fetch byte */
		G(V110Data).ucData = 
			((G(V110Control).ucRcvFrameData[5]&0x60)>>5) |
			((G(V110Control).ucRcvFrameData[6]&0x3f)<<2);

		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_DATA_INDICATION,
				      G(V110Data).ucData );

		/* Fetch byte */
		G(V110Data).ucData = 
			((G(V110Control).ucRcvFrameData[6]&0x40)>>6) |
			((G(V110Control).ucRcvFrameData[7]&0x7f)<<1);

		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_DATA_INDICATION,
				      G(V110Data).ucData );
	}
	else {
		/* 56000 only for synchronous */
	}
}

/*************************************************************************
**									**
** name		: v110ExtractData					**
** purpose	: Extract data from fresh V.110 RA1 frame		**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110ExtractData( void )
{
	/* Extract depending on RA2 rate */
	switch ( G(V110Control).uRA2Rate ) {
	case V110_RA2_8K:
	case V110_RA2_16K:
	case V110_RA2_32K:

		/* Process depending on the RA1 adaption rate */
		switch ( G(V110Control).uEbits ) {
		case V110_EBITS_600:
			v110ExtractData600();
			break;

		case V110_EBITS_1200:
			v110ExtractData1200();
			break;

		case V110_EBITS_2400:
			v110ExtractData2400();
			break;

		case V110_EBITS_3600:
			v110ExtractData3600();
			break;

		case V110_EBITS_4800:
			v110ExtractData4800();
			break;

		case V110_EBITS_12000:
			v110ExtractData12000();
			break;
		}
		break;

	case V110_RA2_NONE:
		/* Extract depending on rate */
		switch ( G(V110Control).uRate ) {
		case V110_RATE_56000:
			v110ExtractData56000();
			break;

		case V110_RATE_48000:
			v110ExtractData48000();
			break;

		case V110_RATE_38400:
			v110ExtractData4800();
			break;

		case V110_RATE_28800:
			v110ExtractData3600();
			break;

		case V110_RATE_24000:
			v110ExtractData12000();
			break;
		}
		break;
	}
}

/*************************************************************************
**									**
** name		: v110SetStatusBitsOn					**
** purpose	: Set all S/X bits in frame to ON			**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110SetStatusBitsOn( void )
{
	/* Setup xmt frame - all S/X bits on */
	G(V110Control).ucXmtFrameData[0] = 0;
	G(V110Control).ucXmtFrameData[1] = 0x7f;
	G(V110Control).ucXmtFrameData[2] = 0x7f;
	G(V110Control).ucXmtFrameData[3] = 0x7f;
	G(V110Control).ucXmtFrameData[4] = 0x7f;

	G(V110Control).ucXmtFrameData[5] =
		G(V110Control).uEbits |
		G(V110Control).uCbits |
		G(V110Control).uE7bit |
		0x01;
	G(V110Control).ucXmtFrameData[6] = 0x7f;
	G(V110Control).ucXmtFrameData[7] = 0x7f;
	G(V110Control).ucXmtFrameData[8] = 0x7f;
	G(V110Control).ucXmtFrameData[9] = 0x7f;
}

/*************************************************************************
**									**
** name		: v110SetUpEmptyDataFrame				**
** purpose	: Set all S/X bits in frame to current values and all	**
**			ones for data					**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110SetUpEmptyDataFrame( void )
{
	/* Setup xmt frame - all S/X bits on */
	G(V110Control).ucXmtFrameData[0] = 0;
	G(V110Control).ucXmtFrameData[1] = v110SetStatusBits( 1 ) | 0x7f;
	G(V110Control).ucXmtFrameData[2] = v110SetStatusBits( 2 ) | 0x7f;
	G(V110Control).ucXmtFrameData[3] = v110SetStatusBits( 3 ) | 0x7f;
	G(V110Control).ucXmtFrameData[4] = v110SetStatusBits( 4 ) | 0x7f;

	G(V110Control).ucXmtFrameData[5] =
		G(V110Control).uEbits |
		G(V110Control).uCbits |
		G(V110Control).uE7bit |
		0x01;
	G(V110Control).ucXmtFrameData[6] = v110SetStatusBits( 6 ) | 0x7f;
	G(V110Control).ucXmtFrameData[7] = v110SetStatusBits( 7 ) | 0x7f;
	G(V110Control).ucXmtFrameData[8] = v110SetStatusBits( 8 ) | 0x7f;
	G(V110Control).ucXmtFrameData[9] = v110SetStatusBits( 9 ) | 0x7f;
}

/*************************************************************************
**									**
** name		: v110SetStatusXBitsOff					**
** purpose	: Set all X bits in frame to OFF			**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110SetStatusXBitsOff( void )
{
	/* Setup xmt frame - all X bits off */
	G(V110Control).ucXmtFrameData[0] = 0;
	G(V110Control).ucXmtFrameData[1] = 0x7f;
	G(V110Control).ucXmtFrameData[2] = 0xff;
	G(V110Control).ucXmtFrameData[3] = 0x7f;
	G(V110Control).ucXmtFrameData[4] = 0x7f;

	G(V110Control).ucXmtFrameData[5] =
		G(V110Control).uEbits |
		G(V110Control).uCbits |
		G(V110Control).uE7bit |
		0x01;
	G(V110Control).ucXmtFrameData[6] = 0x7f;
	G(V110Control).ucXmtFrameData[7] = 0xff;
	G(V110Control).ucXmtFrameData[8] = 0x7f;
	G(V110Control).ucXmtFrameData[9] = 0x7f;
}

/*************************************************************************
**									**
** name		: v110SendIdleFrame					**
** purpose	: Build and send V.110 idle frame			**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110SendIdleFrame( void )
{
	/* Build idle frame */
	G(V110Control).ucXmtFrameData[0] = 0;
	G(V110Control).ucXmtFrameData[1] = 0xff;
	G(V110Control).ucXmtFrameData[2] = 0xff;
	G(V110Control).ucXmtFrameData[3] = 0xff;
	G(V110Control).ucXmtFrameData[4] = 0xff;
	G(V110Control).ucXmtFrameData[5] =
		G(V110Control).uEbits |
		G(V110Control).uCbits |
		G(V110Control).uE7bit |
		0x01;
	G(V110Control).ucXmtFrameData[6] = 0xff;
	G(V110Control).ucXmtFrameData[7] = 0xff;
	G(V110Control).ucXmtFrameData[8] = 0xff;
	G(V110Control).ucXmtFrameData[9] = 0xff;

	/* Now send frame through RA2 stage */
	v110SendRA2Frame( &G(V110Control).ucXmtFrameData[0],
			  V110_FRAME_SIZE_BYTES );
}

/*************************************************************************
**									**
** name		: v110SendDiscoFrame					**
** purpose	: Build and send V.110 disconnect frame			**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110SendDiscoFrame( void )
{
	/* Build disconnect frame */
	G(V110Control).ucXmtFrameData[0] = 0;
	G(V110Control).ucXmtFrameData[1] = 0x81;
	G(V110Control).ucXmtFrameData[2] = 0x80;
	G(V110Control).ucXmtFrameData[3] = 0x81;
	G(V110Control).ucXmtFrameData[4] = 0x81;
	G(V110Control).ucXmtFrameData[5] =
		G(V110Control).uEbits |
		G(V110Control).uCbits |
		G(V110Control).uE7bit |
		0x01;
	G(V110Control).ucXmtFrameData[6] = 0x81;
	G(V110Control).ucXmtFrameData[7] = 0x80;
	G(V110Control).ucXmtFrameData[8] = 0x81;
	G(V110Control).ucXmtFrameData[9] = 0x81;

	/* Now send frame through RA2 stage */
	v110SendRA2Frame( &G(V110Control).ucXmtFrameData[0],
			  V110_FRAME_SIZE_BYTES );
}

/*************************************************************************
**									**
** name		: V110Timeout						**
** purpose	: process a V.110 timeout				**
** inputs	:							**
**		.timeout timer id					**
** outputs	:							**
**		.none							**
**									**
*************************************************************************/
non_banked void V110Timeout( WORD uUserTid )
{
	/*process depending upon state*/
	switch( uUserTid ) {
	case V110_T1_TIMER:

		V110_LOG( V110_LOG_T1_TIMEOUT );
		//x_debug_msg ("V110 - T1_TIMEOUT");	//jc

		/* Clear timer pointer */
		//jc pv110T1Tid[uChannel] = NULL;
		G(v110_Timer).T1_start_time = (word)NULL;		//jc

		/* Process depending on state */
		switch ( G(V110Control).uState ) {
		case V110_STATE_AWAIT_SYNC:	/* Awaiting synchronization */
		case V110_STATE_AWAIT_STATUS_BITS:/* Awaiting status S/X bits ON */
			/* Send disconnect frame */
			v110SendDiscoFrame();
		x_debug_msg ("V110 - T1_timeout");	//jc
			/* State now Disco Pending */
			V110_LOG( V110_LOG_NEW_STATE );
			V110_LOG( V110_STATE_DISCO_PENDING );
			G(V110Control).uState = V110_STATE_DISCO_PENDING;

			/* Tell application */
			(*V110EventCallback)( ILV110_EVENT_OUT_OF_SYNC, 0 );
			break;
		}
		break;

	case V110_RESYNC_TIMER:

		V110_LOG( V110_LOG_RESYNC_TIMEOUT );
//		x_debug_msg ("V110 - RESYNC_TIMEOUT");	//jc

		/* Clear timer pointer */
		//jc pv110ResyncTid[uChannel] = NULL;
		G(v110_Timer).Resync_start_time = (word)NULL;		//jc

		/* Process depending on state */
		switch ( G(V110Control).uState ) {
		case V110_STATE_RESYNC:		/* Resynchronizing */
	x_debug_msg ("V110 - RESYNC_TIMEOUT");	//jc

			/* Send disconnect frame */
			v110SendDiscoFrame();

			/* State now Disco Pending */
			V110_LOG( V110_LOG_NEW_STATE );
			V110_LOG( V110_STATE_DISCO_PENDING );
			G(V110Control).uState = V110_STATE_DISCO_PENDING;

			/* Tell application */
			(*V110EventCallback)( ILV110_EVENT_OUT_OF_SYNC, 0 );
			break;
		}
		break;
	}
}


/* V.110 State Machine Procedures for API events */

/*************************************************************************
**									**
** name		: v110_AwaitSyncRtnAPI					**
** purpose	: V110_STATE_AWAIT_SYNC state processing		**
** inputs	: 							**
**		.R interface data structure address			**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110_AwaitSyncRtnAPI( void )
{
/*ltprintf( "ST: AwaitSyncAPI\n" );*/

	/* Copy R interface data to channel structure */
/*jc-1/4/99	G(V110Control).ucCircuit105_RTS = G(V110DataTx).ucCircuit105_RTS;
	G(V110Control).ucCircuit106_CTS = G(V110DataTx).ucCircuit106_CTS;
	G(V110Control).ucCircuit107_DSR = G(V110DataTx).ucCircuit107_DSR;
	G(V110Control).ucCircuit108_DTR = G(V110DataTx).ucCircuit108_DTR;
	G(V110Control).ucCircuit109_RLSD = G(V110DataTx).ucCircuit109_RLSD;	*/

#ifdef V110TEST		// jc-rel-41
	/* Insert new data */
	v110InsertData();
#endif
}

/*************************************************************************
**									**
** name		: v110_AwaitStatusBitsRtnAPI				**
** purpose	: V110_STATE_AWAIT_STATUS_BITS state processing		**
** inputs	: 							**
**		.R interface data structure address			**
**		.V.110 raw data address					**
**		.V.110 raw data size					**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110_AwaitStatusBitsRtnAPI( void )
{
/*ltprintf( "ST: AwaitStatusBitsAPI\n" );*/
	/* Copy R interface data to channel structure */
/*jc-1/4/99		G(V110Control).ucCircuit105_RTS = G(V110DataTx).ucCircuit105_RTS;
	G(V110Control).ucCircuit106_CTS = G(V110DataTx).ucCircuit106_CTS;
	G(V110Control).ucCircuit107_DSR = G(V110DataTx).ucCircuit107_DSR;
	G(V110Control).ucCircuit108_DTR = G(V110DataTx).ucCircuit108_DTR;
	G(V110Control).ucCircuit109_RLSD = G(V110DataTx).ucCircuit109_RLSD;
*/
#ifdef V110TEST
	/* Insert new data */
	v110InsertData();
#else
	/* Set S/X bits accordingly */
	if ( G(V110DataTx).ucCircuit108_DTR == V110_CIRCUIT_ON ||
	     G(V110Control).uDTEDCE == V110_DCE ) {

		/* Setup xmt frame - all S/X bits on */
		v110SetStatusBitsOn();

		/* Now send frame through RA2 stage */
		v110SendRA2Frame( &G(V110Control).ucXmtFrameData[0],
				  V110_FRAME_SIZE_BYTES );
	}
#endif
}

/*************************************************************************
**									**
** name		: v110_DataXferRtnAPI					**
** purpose	: V110_STATE_DATA_XFER state processing			**
** inputs	: 							**
**		.R interface data structure address			**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110_DataXferRtnAPI( void )
{
/*ltprintf( "ST: DataXferAPI\n" );*/

	/* Copy R interface data to channel structure */
/*jc-1/4/99		G(V110Control).ucCircuit105_RTS = G(V110DataTx).ucCircuit105_RTS;
	G(V110Control).ucCircuit106_CTS = G(V110DataTx).ucCircuit106_CTS;
	G(V110Control).ucCircuit107_DSR = G(V110DataTx).ucCircuit107_DSR;
	G(V110Control).ucCircuit108_DTR = G(V110DataTx).ucCircuit108_DTR;
	G(V110Control).ucCircuit109_RLSD = G(V110DataTx).ucCircuit109_RLSD;
*/
	/* Insert new data */
	v110InsertData();
}

/*************************************************************************
**									**
** name		: v110_ResyncRtnAPI					**
** purpose	: V110_STATE_RESYNC state processing			**
** inputs	: 							**
**		.R interface data structure address			**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110_ResyncRtnAPI( void )
{
/*ltprintf( "ST: ResyncAPI\n" );*/

	/* Ignore */
}

/*************************************************************************
**									**
** name		: v110_DiscoPendingRtnAPI				**
** purpose	: V110_STATE_DISCO_PENDING state processing		**
** inputs	: 							**
**		.R interface data structure address			**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110_DiscoPendingRtnAPI( void )
{
/*ltprintf( "ST: DiscoPendingAPI\n" );*/

	/* Ignore */
}


/* V.110 State Machine Procedures for Network events */

/*************************************************************************
**									**
** name		: v110ProcessRcvdDataFrame				**
** purpose	: process valid rcvd V.110 frame			**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110ProcessRcvdDataFrame( void )
{
	/* Check for disconnect sequence;
	S bits OFF, X bits ON, D bits 0 */
	if ( ( (G(V110Control).ucRcvFrameData[1] & 0x81) == 0x81 &&
	       (G(V110Control).ucRcvFrameData[2] & 0x80) == 0x80 &&
	       (G(V110Control).ucRcvFrameData[3] & 0x81) == 0x81 &&
	       (G(V110Control).ucRcvFrameData[4] & 0x81) == 0x81 &&
	       (G(V110Control).ucRcvFrameData[6] & 0x81) == 0x81 &&
	       (G(V110Control).ucRcvFrameData[7] & 0x80) == 0x80 &&
	       (G(V110Control).ucRcvFrameData[8] & 0x81) == 0x81 &&
	       (G(V110Control).ucRcvFrameData[9] & 0x81) == 0x81) &&
	     ( (G(V110Control).ucRcvFrameData[1] & 0x7e) == 0 &&
	       (G(V110Control).ucRcvFrameData[2] & 0x7e) == 0 &&
	       (G(V110Control).ucRcvFrameData[3] & 0x7e) == 0 &&
	       (G(V110Control).ucRcvFrameData[4] & 0x7e) == 0 &&
	       (G(V110Control).ucRcvFrameData[6] & 0x7e) == 0 &&
	       (G(V110Control).ucRcvFrameData[7] & 0x7e) == 0 &&
	       (G(V110Control).ucRcvFrameData[8] & 0x7e) == 0 &&
	       (G(V110Control).ucRcvFrameData[9] & 0x7e) == 0) ) {

		V110_LOG( V110_LOG_DISCO_RCVD );
		x_debug_msg ("V110 - DISCO_RCVD");	//jc

		/* Start counting valid frames */
		G(V110Control).bRcvFrameValidCnt = 0;

		/* Send disconnect frame */
		v110SendDiscoFrame();

		/* State now Disco Pending */
		V110_LOG( V110_LOG_NEW_STATE );
		V110_LOG( V110_STATE_DISCO_PENDING );
		G(V110Control).uState = V110_STATE_DISCO_PENDING;
		x_debug_msg("STATE_DISCO_PENDING");	//jc

		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_OUT_OF_SYNC, 0 );
	}
	else {

		/*  Extract valid data */
		v110ExtractData();
	}
}

/*************************************************************************
**									**
** name		: v110_SyncCheck					**
** purpose	: verify V.110 synchronization is found or still exists	**
** inputs	: 							**
**		.V.110 raw data address					**
**		.V.110 raw data size					**
** outputs	: 							**
**		.TRUE=in sync, FALSE=out of sync			**
**									**
*************************************************************************/
non_banked static BOOLEAN v110_SyncCheck( BYTE *pRawData,
			       BYTE ucDataSz )
{
#if defined( NOT_FAST )
	BYTE v110_ucTmpByte;			/* Temporary byte */
	BYTE v110_ucBytesDecoded=0;		/* # RA2 bytes decoded */
	BYTE v110_ucLoop1=0;			/* Loop counter */
	BYTE *v110_pRA2Bytes=pRawData;	/* Bytes to decode pointer */
	BYTE v110_ucRA2Bytes2Decode=ucDataSz;/* Bytes to decode pointer */
	BOOLEAN v110_bAdjustRA2Pointer=FALSE;/* Adjust RA2 pointer flag */
	BOOLEAN v110_bSyncFound=FALSE;	/* Synchronization found flag */
#else
	G(v110_ucBytesDecoded) = 0;
	G(v110_ucLoop1) = 0;
	G(v110_pRA2Bytes) = pRawData;
	G(v110_ucRA2Bytes2Decode) = ucDataSz;
	G(v110_bAdjustRA2Pointer) = FALSE;
	G(v110_bSyncFound) = FALSE;
#endif

/*ltprintf( "v110_SyncCheck\n" );*/
	/* Check all RA2 bytes */
	G(V110Control).ucRcvFrameErrors = 0;
	while ( G(v110_ucRA2Bytes2Decode) != 0 ) {

		/* Check for left over bytes from last buffer */
		if ( G(V110Control).ucRcvRA2DataByteCnt > 0 ) {

			/* Use left over bytes from last buffer with
			enough bytes from this buffer to decode an
			RA2 byte */
			G(v110_ucTmpByte) = G(V110Control).ucCycles -
				    G(V110Control).ucRcvRA2DataByteCnt;
			x_memcpy( &G(V110Control).ucRcvRA2Data[G(V110Control).ucRcvRA2DataByteCnt], 
				pRawData, 
				(word) G(v110_ucTmpByte) );	//jc

			/* Now adjust the original buffer pointer and cnt */
			pRawData += G(v110_ucTmpByte);
			ucDataSz -= G(v110_ucTmpByte);
			G(V110Control).ucRcvRA2DataByteCnt = 0;

			/* Now adjust the pointer to where decoding should occur */
			G(v110_pRA2Bytes) = &G(V110Control).ucRcvRA2Data[0];
			G(v110_ucRA2Bytes2Decode) = G(V110Control).ucCycles;
			G(v110_bAdjustRA2Pointer) = TRUE;
		}
		else if ( G(v110_bAdjustRA2Pointer) ) {

			/* Set the pointer back to the original buffer, which
				will be past the bytes appended to the prior
				partial RA2 buffer just processed */
			G(v110_bAdjustRA2Pointer) = FALSE;
			G(v110_pRA2Bytes) = pRawData;
			G(v110_ucRA2Bytes2Decode) = ucDataSz;
/*ltprintf( "adjusting back ... cnt=%d\n", G(v110_ucRA2Bytes2Decode) );*/
		}

		/* Check if we are still hunting for the zero Byte */
		if ( G(V110Control).ucRcvFrameByteCnt == 0 ) {
/*ltprintf( "!found 0 byte yet\n" );*/

			/* Fetch RA1 byte and check if it's zero */
			if ( (G(v110_ucBytesDecoded)=v110GetRA2Byte( G(v110_pRA2Bytes),
				G(v110_ucRA2Bytes2Decode)
				)) > 0 ) {

				/* One more byte decoded and checked */
				++G(V110Control).uNumBytesChecked;

				/* Check for zero byte */
				/* If past initial framing search,
				allow 3 frames with framing errors */
				if ( G(v110_ucRA1Byte) == 0 ||
				     G(V110Control).uState ==
				     V110_STATE_AWAIT_STATUS_BITS ||
				     G(V110Control).uState ==
				     V110_STATE_DATA_XFER ) {

/*ltprintf( "found 0 at %d\n", v110_ucLoop1 );*/
/*					V110_LOG( V110_LOG_FOUND_ZERO );*/

					/* Check if allowing framing error */
					if ( G(v110_ucRA1Byte) != 0 ) {

						/* One more framing error */
						++G(V110Control).ucRcvFrameErrors;
					}

					/* Save this byte */
					G(V110Control).ucRcvFrameData[0] =
						0;

					/* Start counting RA1 frame bytes */
					G(V110Control).ucRcvFrameByteCnt = 1;

					/* Account for RA2 bytes decoded */
					/* Don't adjust if just processed left
					over data bytes; this will reset the
					pointer and count at the top of the
					loop */
					if ( !G(v110_bAdjustRA2Pointer) ) {

						G(v110_pRA2Bytes) += G(v110_ucBytesDecoded);
						G(v110_ucRA2Bytes2Decode) -= G(v110_ucBytesDecoded);
					}
					G(v110_ucLoop1) += G(v110_ucBytesDecoded);
				}
				else {

					/* Need to slide one byte at a time
						while looking for the starting
						zero byte */
					/* Don't adjust if just processed left
					over data bytes; this will reset the
					pointer and count at the top of the
					loop */
					if ( !G(v110_bAdjustRA2Pointer) ) {

						++G(v110_pRA2Bytes);
						--G(v110_ucRA2Bytes2Decode);
					}
					++G(v110_ucLoop1);
				}
			}
			else {
/*ltprintf( "Defer 1!!  not enough RA2 bytes supplied; saving %d bytes\n", G(v110_ucRA2Bytes2Decode) );*/

				/* Save what's left and process next time */
				x_memcpy( &G(V110Control).ucRcvRA2Data[0], 
					G(v110_pRA2Bytes), 
					(word) G(v110_ucRA2Bytes2Decode) );	//jc
				G(V110Control).ucRcvRA2DataByteCnt =
					G(v110_ucRA2Bytes2Decode);

				break;
			}
		}
		else {

			/* Make sure enough RA2 bytes are available to create
				an RA1 byte */
			if ( G(v110_ucRA2Bytes2Decode) >= G(V110Control).ucCycles  ) {

				/* Fetch RA1 byte and check if it's zero */
				G(v110_ucBytesDecoded) = v110GetRA2Byte( G(v110_pRA2Bytes),
					G(v110_ucRA2Bytes2Decode) );

				/* One more byte decoded and checked */
				++G(V110Control).uNumBytesChecked;

				/* Verify framing bit */
				if ( (G(v110_ucRA1Byte) & 0x01) ||
				     G(V110Control).uState ==
				     V110_STATE_AWAIT_STATUS_BITS ||
				     G(V110Control).uState ==
				     V110_STATE_DATA_XFER ) {

					/* Check if allowing framing error */
					if ( !(G(v110_ucRA1Byte) & 0x01) ) {

						/* One more framing error */
						++G(V110Control).ucRcvFrameErrors;
					}

					/* Save this byte */
					G(V110Control).ucRcvFrameData[G(V110Control).ucRcvFrameByteCnt] =
						G(v110_ucRA1Byte);

					/* One  more RA1 frame byte */
					/* Check if we've received a full
						V.110 RA1 frame */
					if ( ++G(V110Control).ucRcvFrameByteCnt == V110_FRAME_SIZE_BYTES ) {

/*ltprintf( "framed up\n" );*/
					/* Clear byte check counter */
					G(V110Control).uNumBytesChecked = 0;

					/* Sync found */
					G(v110_bSyncFound) = TRUE;
					G(v110_bPrevSyncFound) ++;
					if ( ( G(V110Control).uState == V110_STATE_AWAIT_STATUS_BITS )
						&& !(G(v110_uRA2BitShiftFound)) )
					{
							G(v110_uRA2BitShiftFound) = 1;	// set the flag
#if defined( Z80_DEBUG_PRINT )
							x_debug_msg("sync found shift="); 	sendHexByte(G(v110_shift_amount));
#endif
							if (G(v110_shift_amount) != 8)
							{
							 	// take the v110_shift_amount pass to the wrapper code.
								(*V110EventCallback)( ILV110_EVENT_RA2_BIT_SHIFT,
					      	 (LWORD) G(v110_shift_amount));
								G(V110Control).uState = V110_STATE_AWAIT_SYNC;
								// clear rcv buffers
						      G(V110Control).ucRcvFrameByteCnt = 0;
								G(V110Control).ucRcvRA2DataByteCnt = 0;
								return ( FALSE );
							}
					}

					/* One frame in buffer */
					G(V110Control).bRcvFrameValid =
						TRUE;

					/* If in Data Xfer state, process
						rcvd frame */
					if ( G(V110Control).uState ==
					     V110_STATE_DATA_XFER ) {

						/* Process the frame */
						v110ProcessRcvdDataFrame();
					}

#if defined(DEBUG_RCV_RA1) || defined( NOT_FAST )
					/* Tell application */
					(*V110EventCallback)( ILV110_EVENT_RCV_RA1_TRACE,
						(LWORD)(LWORD *)(&G(V110Control).ucRcvFrameData[0]) );
#endif

					/* Start with new frame */
					G(V110Control).ucRcvFrameByteCnt = 0;

					/* Check if any framing errors rcvd */
					if ( G(V110Control).ucRcvFrameErrors ) {

#if defined(DEBUG_RCV_RA1) || defined( NOT_FAST )
						/* Tell application */
						(*V110EventCallback)( ILV110_EVENT_RCV_RA1_TRACE,
							(LWORD)(LWORD *)(&G(V110Control).ucRcvFrameData[0]) );
#endif

						/* Only allow 3 consecutive
							errant frames */
						if ( ++G(V110Control).ucConsecutiveFrameErrors == 3 ) {

							/* Lost framing */
							G(V110Control).ucRcvFrameByteCnt = 0;

							/* Sync not found */
							G(v110_bSyncFound) = FALSE;
							G(v110_bPrevSyncFound) = 0;	// clear prev sync found
							x_debug_msg("LOST sync");
						}
					}
					else {

						G(V110Control).ucConsecutiveFrameErrors = 0;
					}
					}
				}
				/* Mis-framed */
				/* Check for zero byte */
				else if ( G(v110_ucRA1Byte) == 0 ) {

/*ltprintf( "mis-framed; new zero byte\n" );*/
					/* Save this byte */
					G(V110Control).ucRcvFrameData[0] =
							0;

					/* Start counting RA1 frame bytes */
					G(V110Control).ucRcvFrameByteCnt = 1;
				}
				else {

/*ltprintf( "mis-framed\n" );*/
					/* Start looking for a zero byte */
					G(V110Control).ucRcvFrameByteCnt = 0;
				}

				/* Account for RA2 bytes decoded */
				/* Don't adjust if just processed left
				over data bytes; this will reset the
				pointer and count at the top of the
				loop */
				if ( !G(v110_bAdjustRA2Pointer) ) {

					G(v110_pRA2Bytes) += G(v110_ucBytesDecoded);
					G(v110_ucRA2Bytes2Decode) -= G(v110_ucBytesDecoded);
				}
				G(v110_ucLoop1) += G(v110_ucBytesDecoded);
			}
			else {
/*ltprintf( "Defer 2!!  not enough RA2 bytes supplied; saving %d bytes\n", G(v110_ucRA2Bytes2Decode) );*/

				/* Save what's left and process next time */
				x_memcpy( &G(V110Control).ucRcvRA2Data[0], 
					G(v110_pRA2Bytes), 
					(word) G(v110_ucRA2Bytes2Decode) );		//jc
				G(V110Control).ucRcvRA2DataByteCnt =
					G(v110_ucRA2Bytes2Decode);

				break;
			}
		}
	}

	/* Return sync status */
/*ltprintf( "sync=%d cnt=%d\n", G(v110_bSyncFound), G(V110Control).ucRcvFrameByteCnt );*/
	if ( G(v110_bSyncFound) ||
	     ( (G(V110Control).uState == V110_STATE_DATA_XFER ||
		G(V110Control).uState == V110_STATE_AWAIT_STATUS_BITS) &&
	       G(V110Control).ucRcvFrameByteCnt > 0 ) ) {
		return ( TRUE );
	}
	else {
//		V110_LOG( V110_LOG_OUT_OF_SYNC );
		return ( FALSE );
	}
}

/*************************************************************************
**									**
** name		: v110_AwaitSyncRtnNET					**
** purpose	: V110_STATE_AWAIT_SYNC state processing		**
** inputs	: 							**
**		.V.110 raw data address					**
**		.V.110 raw data size					**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110_AwaitSyncRtnNET( BYTE *pRawData,
				  BYTE ucDataSz )
{
/*ltprintf( "ST: AwaitSyncNET\n" );*/
	/* Check for synchronization */
//	if ( v110_SyncCheck( pRawData, ucDataSz ) ) {
	if ( v110_SyncCheck( pRawData, ucDataSz ) && (G(v110_bPrevSyncFound) >= 5) ) {

x_debug_msg("move to await status bits");
		/* Set S/X bits accordingly */
		if ( G(V110DataTx).ucCircuit108_DTR == V110_CIRCUIT_ON ||
		     G(V110Control).uDTEDCE == V110_DCE ) {

			/* Setup xmt frame - all S/X bits on */
			v110SetStatusBitsOn();

			/* Now send frame through RA2 stage */
			v110SendRA2Frame( &G(V110Control).ucXmtFrameData[0],
					  V110_FRAME_SIZE_BYTES );
		}

		/* State now Await Status Bits */
		V110_LOG( V110_LOG_NEW_STATE );
		V110_LOG( V110_STATE_AWAIT_STATUS_BITS );
		x_debug_msg ("V110 - STATE_AWAIT_STATUS_BITS");	//jc
		G(V110Control).uState = V110_STATE_AWAIT_STATUS_BITS;
	}
}

/*************************************************************************
**									**
** name		: v110_AwaitStatusBitsRtnNET				**
** purpose	: V110_STATE_AWAIT_STATUS_BITS state processing		**
** inputs	: 							**
**		.V.110 raw data address					**
**		.V.110 raw data size					**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110_AwaitStatusBitsRtnNET( BYTE *pRawData,
					BYTE ucDataSz )
{
/*ltprintf( "ST: AwaitStatusBitsNET\n" );*/
	/* Check for synchronization */
	if ( v110_SyncCheck( pRawData, ucDataSz ) ) {

		/* Set S/X bits accordingly */
		if ( G(V110DataTx).ucCircuit108_DTR == V110_CIRCUIT_ON ||
		     G(V110Control).uDTEDCE == V110_DCE ) {

			/* Setup xmt frame - all S/X bits on */
			v110SetStatusBitsOn();
		}

		/* Check if valid frame has been received */
		if ( G(V110Control).bRcvFrameValid ) {

			/* Clear for next valid frame */
			G(V110Control).bRcvFrameValid = FALSE;

			/* Check if S/X bits are ON */
			if ( !(G(V110Control).ucRcvFrameData[1] & 0x80) &&
			     !(G(V110Control).ucRcvFrameData[2] & 0x80) &&
			     !(G(V110Control).ucRcvFrameData[3] & 0x80) &&
			     !(G(V110Control).ucRcvFrameData[4] & 0x80) &&
			     !(G(V110Control).ucRcvFrameData[6] & 0x80) &&
			     !(G(V110Control).ucRcvFrameData[7] & 0x80) &&
			     !(G(V110Control).ucRcvFrameData[8] & 0x80) &&
			     !(G(V110Control).ucRcvFrameData[9] & 0x80) ) {

				V110_LOG( V110_LOG_SX_BITS_ON );
				x_debug_msg ("V110 - SX_BITS_ON");	//jc

				/* S/X bits are all ON */
				/* Stop T1 timer */
				v110StopT1();

				/* Init serial decoder for new frame data */
				v110SerialDecode( TRUE, 0 );

				/* State now Data Xfer */
				V110_LOG( V110_LOG_NEW_STATE );
				V110_LOG( V110_STATE_DATA_XFER );
				x_debug_msg ("V110 - STATE_DATA_XFER");	//jc
				G(V110Control).uState = V110_STATE_DATA_XFER;

				V110_LOG( V110_LOG_IN_SYNC );
				x_debug_msg ("V110 - IN_SYNC");	//jc

/* test; set one data byte to '1' */
//G(V110Control).ucXmtFrameData[1] = 0x45;
//G(V110Control).ucXmtFrameData[2] = 0x73;

				/* Tell application */
/* Application should, upon receipt of this event, turn on 107 if a DCE */
				(*V110EventCallback)( ILV110_EVENT_IN_SYNC, 0 );

/* N_BIT_COUNT_DONE event will be issued when N bits are sent, and then
application should, upon receipt of this event, turn on 106 */

/* TBS - what "bits" are actually counted later in data xfer state?? */
				/* Clear N bit counter */
				G(V110Control).ucNCount = 0;
			}
		}
	}
}

/*************************************************************************
**									**
** name		: v110_DataXferRtnNET					**
** purpose	: V110_STATE_DATA_XFER state processing			**
** inputs	: 							**
**		.V.110 raw data address					**
**		.V.110 raw data size					**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110_DataXferRtnNET( BYTE *pRawData,
				 BYTE ucDataSz )
{
/*ltprintf( "ST: DataXferNET\n" );*/

	/* Check for synchronization */
	if ( v110_SyncCheck( pRawData, ucDataSz ) ) {
/*ltprintf( "still in sync\n" );*/

		/* Check if valid frame has been received */
		if ( G(V110Control).bRcvFrameValid ) {

			/* Clear for next valid frame */
			G(V110Control).bRcvFrameValid = FALSE;

			/* Frame processed in v110ProcessRcvdDataFrame */
		}
	}
	else {
/*ltprintf( "LOST SYNC\n" );*/

		/* Start sending frames with X bits off */
		v110SetStatusXBitsOff();

		/* Start resync timer */
		v110StartResync();

		/* Tell application */	// jc-rel-12
		(*V110EventCallback)( ILV110_EVENT_RESYNC_IN_PROGRESS,
				      0 );

		/* State now Resynchronizing */
		V110_LOG( V110_LOG_NEW_STATE );
		V110_LOG( V110_STATE_RESYNC );
		x_debug_msg ("V110 - STATE_RESYNC");	//jc
#if defined( Z80_DEBUG_PRINT )
		sendHexByte(*pRawData);	//jc
#endif
		G(V110Control).uState = V110_STATE_RESYNC;
	}
}

/*************************************************************************
**									**
** name		: v110_ResyncRtnNET					**
** purpose	: V110_STATE_RESYNC state processing			**
** inputs	: 							**
**		.V.110 raw data address					**
**		.V.110 raw data size					**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110_ResyncRtnNET( BYTE *pRawData,
			       BYTE ucDataSz )
{
/*ltprintf( "ST: ResyncNET\n" );*/

	/* Check for synchronization */
	if ( v110_SyncCheck( pRawData, ucDataSz ) ) {
/*ltprintf( "back in sync\n" );*/

		/* Stop resync timer */
		v110StopResync();

		/* Turn on all status/X bits */
		v110SetStatusBitsOn();

		/* Init serial decoder for new frame data */
		v110SerialDecode( TRUE, 0 );

		/* Tell application */	// jc -rel-12
		(*V110EventCallback)( ILV110_EVENT_RESYNC_COMPLETE,
				      0 );

		/* State now Data Xfer */
		V110_LOG( V110_LOG_NEW_STATE );
		V110_LOG( V110_STATE_DATA_XFER );
		x_debug_msg ("V110 - STATE_DATA_XFER");	//jc
		G(V110Control).uState = V110_STATE_DATA_XFER;
	}
/*jc-rel-13
	else {
//ltprintf( "still out of SYNC\n" );

		// Send disconnect frame 
		v110SendDiscoFrame();

		// State now Disco Pending 
		V110_LOG( V110_LOG_NEW_STATE );
		V110_LOG( V110_STATE_DISCO_PENDING );
		G(V110Control).uState = V110_STATE_DISCO_PENDING;
	x_debug_msg("still out of sync");	//jc
		// Still out of sync; fail this connection
		// Tell application 
		(*V110EventCallback)( ILV110_EVENT_OUT_OF_SYNC, 0 );
	}	  jc-rel-13 */
}

/*************************************************************************
**									**
** name		: v110_DiscoPendingRtnNET				**
** purpose	: V110_STATE_DISCO_PENDING state processing		**
** inputs	: 							**
**		.V.110 raw data address					**
**		.V.110 raw data size					**
** outputs	: 							**
**		.none							**
**									**
*************************************************************************/
non_banked static void v110_DiscoPendingRtnNET( BYTE *pRawData,
				     BYTE ucDataSz )
{
/*ltprintf( "ST: DiscoPendingNET\n" );*/
	/* Check for synchronization */
	if ( v110_SyncCheck( pRawData, ucDataSz ) ) {
/*ltprintf( "still in sync\n" );*/

		/* Check if valid frame has been received */
		if ( G(V110Control).bRcvFrameValid ) {

			/* One more valid frames; 3 and disconnect is complete */
			if ( ++G(V110Control).bRcvFrameValidCnt == 3 ) {

				/* Tell application */
				(*V110EventCallback)( ILV110_EVENT_DISCO, 0 );

				/* State now Idle */
				V110_LOG( V110_LOG_NEW_STATE );
				V110_LOG( V110_STATE_IDLE );
				x_debug_msg ("V110 - STATE_IDLE1");	//jc
				G(V110Control).uState = V110_STATE_IDLE;
			}
		}
	}
	else {

		/* Tell application */
		(*V110EventCallback)( ILV110_EVENT_DISCO, 0 );

		/* State now Idle */
		V110_LOG( V110_LOG_NEW_STATE );
		V110_LOG( V110_STATE_IDLE );
		x_debug_msg ("V110 - STATE_IDLE2");	//jc
		G(V110Control).uState = V110_STATE_IDLE;
	}
}


/* ILAPI Procedures */

/*************************************************************************
**									**
** name		: ILV110_Init						**
** purpose	: V.110 initialization procedure			**
** inputs	: 							**
**		.address of application callback procedure		**
** outputs	: 							**
**		.ILAPI status						**
**									**
*************************************************************************/
non_banked ILV110STATUS ILV110_Init( LWORD (*EventCallback)(WORD uEvent, BYTE dwMisc) )
{
	ILV110STATUS RetStatus=ILV110STATUS_OK;	/* Return status */
	BYTE ucLoop1;			/* Loop counter */

	V110EventCallback = NULL; //jc
//jeff	G(V110Data) = (PV110DATA_S)&symbol[0];	//jc-use V.42bis buffer
//jc-1/5/99	G(V110Control) = (PG(V110CONTROL)_S)&symbol[10];	// jc-use V.42bis buffer

	V110_LOG( V110_LOG_INIT );
	x_debug_msg ("V110 - INIT");	//jc

	/* Verify */
	if ( V110EventCallback != NULL ) {

		RetStatus = ILV110STATUS_BAD_STATE;
	}
	else if ( EventCallback == NULL ) {

		RetStatus = ILV110STATUS_BAD_PARAMETER;
	}
	else {

		/* Save application callback procedure address */
		V110EventCallback = EventCallback;

		/* All channels are now initialized */
		for ( ucLoop1=0; ucLoop1<MAX_V110_CHANNELS; ++ucLoop1 ) {

			/* State now Idle */
			G(V110Control).uState = V110_STATE_IDLE;	//jc-1/5/99
		}
		//jc-1/4/99
		G(V110Control).ucCircuit105_RTS = V110_CIRCUIT_ON;
		G(V110Control).ucCircuit106_CTS = V110_CIRCUIT_ON;
		G(V110Control).ucCircuit107_DSR = V110_CIRCUIT_ON;
		G(V110Control).ucCircuit108_DTR = V110_CIRCUIT_ON;
		G(V110Control).ucCircuit109_RLSD = V110_CIRCUIT_ON;
	}

	G(v110_shift_amount) = 8;	// jc-5/13/99
	G(v110_rx_octets).w = 0;	// initialize previously received RA2 byte to be zero
	G(v110_uRA1ByteCnt) = 0;	// jc-6/11/99
	G(v110_uRA2BitShiftFound) = 0; // jc-6/11/99
	G(v110_bPrevSyncFound) = 0;	// clear prev sync found
	
	return( RetStatus );
}

/*************************************************************************
**									**
** name		: ILV110_Terminate					**
** purpose	: V.110 termination procedure				**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.ILAPI status						**
**									**
*************************************************************************/
non_banked ILV110STATUS ILV110_Terminate( void )
{
	ILV110STATUS RetStatus=ILV110STATUS_OK;	/* Return status */
	BYTE ucLoop1;			/* Loop counter */

	V110_LOG( V110_LOG_TERM );
	x_debug_msg ("V110 - TERM");	//jc

	/* Verify */
	if ( V110EventCallback == NULL ) {

		RetStatus = ILV110STATUS_BAD_STATE;
	}
	else {

		/* Clear application callback procedure address */
		V110EventCallback = NULL;

		/* All channels are now not initialized */
		for ( ucLoop1=0; ucLoop1<MAX_V110_CHANNELS; ++ucLoop1 ) {

			/* State now Uninitialized */
			G(V110Control).uState = V110_STATE_UNINITED;	// jc-1/5/99
		}
	}

	return( RetStatus );
}

/*************************************************************************
**									**
** name		: ILV110_Open						**
** purpose	: V.110 open channel procedure				**
** inputs	: 							**
**		.v110 rate						**
**		.sync or async specifier				**
**		.DTE or DCE end specifier				**
**		.# of stop bits						**
**		.# of data bits						**
**		.T1 timer value						**
**		.Resync timer value					**
**		.N count						**
** outputs	: 							**
**		.ILAPI status						**
**									**
*************************************************************************/
non_banked ILV110STATUS ILV110_Open( WORD uRate,
			  WORD uSyncAsync,
			  WORD uDTEDCE,
			  WORD uStopBits,
			  WORD uDataBits,
			  WORD uTimer_T1_Value,
			  WORD uTimer_Resync_Value,
			  WORD uN_Value  )
{
	ILV110STATUS RetStatus=ILV110STATUS_OK;	/* Return status */

	V110_LOG( V110_LOG_OPEN );
	x_debug_msg ("V110 - OPEN");	//jc

	/* Verify */
	if ( V110EventCallback == NULL ) {

			RetStatus = ILV110STATUS_BAD_STATE;
	}
	else if ( (uRate < V110_RATE_38400 || uRate > V110_RATE_600) ||
	     (uSyncAsync != V110_TYPE_SYNC && uSyncAsync != V110_TYPE_ASYNC) ||
	     (uDTEDCE != V110_DTE && uDTEDCE != V110_DCE) ) {
/* add back when 56000 & 48000 supported	     (uRate < V110_RATE_56000 || uRate > V110_RATE_600) ||*/

		RetStatus = ILV110STATUS_BAD_PARAMETER;
	}
	else if ( G(V110Control).bOpen ) {
		x_debug_msg("ILV110STATUS_BAD_STATE");	//jctmp
		RetStatus = ILV110STATUS_BAD_STATE;
	}
	else {

		/* Clear V.110 channel control structures */
//		for (w=0; w < 2048; w++)	// jc: this replaces memset function
//		{
//			symbol[w] = 0;
//		}

		/* Fill in channel control data */
//		G(V110Control).uChannel = uChannel;
		G(V110Control).uRate = uRate;
		G(V110Control).uSyncAsync = uSyncAsync;
		G(V110Control).uDTEDCE = uDTEDCE;
		G(V110Control).uStopBits = uStopBits;
		G(V110Control).uDataBits = uDataBits;
		G(V110Control).uTimer_T1_Value = uTimer_T1_Value;
		G(V110Control).uTimer_Resync_Value = uTimer_Resync_Value;
		G(V110Control).uN_Value = uN_Value;

		/* Set E-bits and RA2 intermediate rate */
		switch( uRate ) {
		case V110_RATE_56000:
			break;

		case V110_RATE_48000:
			break;

		case V110_RATE_38400:
			G(V110Control).uRA2Rate = V110_RA2_NONE;
			G(V110Control).uEbits = V110_EBITS_4800;
			break;

		case V110_RATE_28800:
			G(V110Control).uRA2Rate = V110_RA2_NONE;
			G(V110Control).uEbits = V110_EBITS_3600;
			break;

		case V110_RATE_24000:
			G(V110Control).uRA2Rate = V110_RA2_NONE;
			G(V110Control).uEbits = V110_EBITS_12000;
			break;

		case V110_RATE_19200:
			G(V110Control).uRA2Rate = V110_RA2_32K;
			G(V110Control).uEbits = V110_EBITS_4800;
			break;

		case V110_RATE_9600:
			G(V110Control).uRA2Rate = V110_RA2_16K;
			G(V110Control).uEbits = V110_EBITS_4800;
			break;

		case V110_RATE_4800:
			G(V110Control).uRA2Rate = V110_RA2_8K;
			G(V110Control).uEbits = V110_EBITS_4800;
			break;

		case V110_RATE_14400:
			G(V110Control).uRA2Rate = V110_RA2_32K;
			G(V110Control).uEbits = V110_EBITS_3600;
			break;

		case V110_RATE_7200:
			G(V110Control).uRA2Rate = V110_RA2_16K;
			G(V110Control).uEbits = V110_EBITS_3600;
			break;

		case V110_RATE_3600:
			G(V110Control).uRA2Rate = V110_RA2_16K;
			G(V110Control).uEbits = V110_EBITS_3600;
			break;

		case V110_RATE_12000:
			G(V110Control).uRA2Rate = V110_RA2_32K;
			G(V110Control).uEbits = V110_EBITS_12000;
			break;

		case V110_RATE_2400:
			G(V110Control).uRA2Rate = V110_RA2_8K;
			G(V110Control).uEbits = V110_EBITS_2400;
			break;

		case V110_RATE_1200:
			G(V110Control).uRA2Rate = V110_RA2_8K;
			G(V110Control).uEbits = V110_EBITS_1200;
			break;

		case V110_RATE_600:
			G(V110Control).uRA2Rate = V110_RA2_8K;
			G(V110Control).uEbits = V110_EBITS_600;
			break;

		default:
			/* Ebits are actual data for higher rates */
			G(V110Control).uRA2Rate = V110_RA2_NONE;
			G(V110Control).uEbits = V110_EBITS_NONE;
			break;
		}
		
		/* Set C-bits -- unused until NIC is supported */
		G(V110Control).uCbits = 0x70;

		/* Set E7 bit -- unused until 600 MF is supported */
		G(V110Control).uE7bit = 0x80;

		/* Set RA2 conversion controls */
		/* Compute the conversion controls */
		if ( G(V110Control).uRA2Rate == V110_RA2_8K ) {

			/* Data bit mask */
			G(V110Control).ucMask = 0x01;
			/* Data bits per RA2 byte */
			G(V110Control).ucBitsPerOctet = 1;
			/* # cycles per data octet */
//			G(V110Control).ucCycles = 8;
			G(V110Control).ucCycles = 1;
		}
		else if ( G(V110Control).uRA2Rate == V110_RA2_16K ) {

			/* Data bit mask */
			G(V110Control).ucMask = 0x03;
			/* Data bits per RA2 octet */
			G(V110Control).ucBitsPerOctet = 2;
			/* # cycles per data octet */
//			G(V110Control).ucCycles = 4;
			G(V110Control).ucCycles = 1;
		}
		else if ( G(V110Control).uRA2Rate == V110_RA2_32K ) {//jc rel-12

			/* Must be 32K */
			/* Data bit mask */
			G(V110Control).ucMask = 0x0f;
			/* Data bits per RA2 octet */
			G(V110Control).ucBitsPerOctet = 4;
			/* # cycles per data octet */
//			G(V110Control).ucCycles = 2;
			G(V110Control).ucCycles = 1;
		}
		else {	// jc rel-12

			/* Must be None */
			/* Data bit mask */
			G(V110Control).ucMask = 0xff;
			/* Data bits per RA2 octet */
			G(V110Control).ucBitsPerOctet = 8;
			/* # cycles per data octet */
			G(V110Control).ucCycles = 1;
		}

		/* Channel now open */
		G(V110Control).bOpen = TRUE;

		/* Initialize timer id structure pointers */
		//jc pv110T1Tid[uChannel] = pv110ResyncTid[uChannel] = NULL;
		G(v110_Timer).T1_start_time = (word)NULL;			//jc
		G(v110_Timer).Resync_start_time = (word)NULL;	//jc

		/* Start T1 timer */
		v110StartT1();
		x_debug_msg("T1 timer started");	//jc

		/* State now Awaiting Synchronization */
		V110_LOG( V110_LOG_NEW_STATE );
		V110_LOG( V110_STATE_AWAIT_SYNC );
		x_debug_msg ("V110 - STATE_AWAIT_SYNC");	//jc-6/10/99
		G(V110Control).uState = V110_STATE_AWAIT_SYNC;

		/* Prime the transmitter with idle frames to start */
		/* Will send 160 bytes regardless of RA2 rate */
		if ( G(V110Control).uRA2Rate == V110_RA2_32K ) {
			v110SendIdleFrame();
			v110SendIdleFrame();
			v110SendIdleFrame();
			v110SendIdleFrame();
			v110SendIdleFrame();
			v110SendIdleFrame();
		}
		else if ( G(V110Control).uRA2Rate == V110_RA2_16K ) {
			v110SendIdleFrame();
			v110SendIdleFrame();
		}
		v110SendIdleFrame();
		v110SendIdleFrame();
	}

	return( RetStatus );
}

/*************************************************************************
**									**
** name		: ILV110_Close						**
** purpose	: V.110 closed previously opened channel procedure	**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.ILAPI status						**
**									**
*************************************************************************/
non_banked ILV110STATUS ILV110_Close( void )
{
	ILV110STATUS RetStatus=ILV110STATUS_OK;	/* Return status */

	V110_LOG( V110_LOG_CLOSE );
	x_debug_msg ("V110 - CLOSE");	//jc

	/* Verify */
	if ( V110EventCallback == NULL ||
	     !G(V110Control).bOpen ) {

		RetStatus = ILV110STATUS_BAD_STATE;
	}
	else {

		/* Stop all timers */
		v110StopT1();
		v110StopResync();

		/* Channel now closed */
		G(V110Control).bOpen = FALSE;
	}

	return( RetStatus );
}
/*************************************************************************
**									**
** name		: ILV110_SendRawData					**
** purpose	: send raw V.110 rate adapted data to network		**
** inputs	: 							**
**                .channel number					**
**                .V.110 raw data address				**
**                .V.110 raw data size					**
** outputs	: 							**
**                .ILAPI status						**
**									**
*************************************************************************/
non_banked ILV110STATUS ILV110_SendRawData( BYTE *pRawData,
				 BYTE ucDataSz )
{
	word *wptr;

/* do ra2 processing here */
	wptr = G(io_dce_tx_wptr) ;		// save io_dce_tx_wptr
	G(v110_SendRawDataCnt) = io_get_dce_tx_count () ;	// get amount of free space on tx que

	if (G(v110_SendRawDataCnt) < ucDataSz) // ucCpySize = (count < ucDataSz) ? count : ucDataSz;
	{
		x_debug_msg ("V110 - no enough on dce_tx");
#if defined( Z80_DEBUG_PRINT )
		sendHexWord(ucDataSz - G(v110_SendRawDataCnt));	//jctmp
#endif
	}

	// Size of bytes to move; it's 10 to 80 bytes in most cases
	while( ucDataSz ) 
	{
		// Move data into buffer
		*G(io_dce_tx_wptr) ++ = (word)(*pRawData++);

		// update the pointer
		if (G(io_dce_tx_wptr) >= G(io_dce_tx_eptr))
			G(io_dce_tx_wptr) = G(io_dce_tx_sptr);

		ucDataSz --;
	}

/*	if ( G(io_dce_tx_wptr) != wptr )	// if there is data on dce tx que
	{
		io_start_dce_transmit () ;
	}
	 don't do this because this is inefficient !  dp_isr transfers 16 bytes
	 at a time to dpram. By doing this way you could be calling dp_isr when
	 you only have 10 bytes(one frame of 38400 rate!) But this is better
	 than transfer one byte at a time !!!
*/

	return( ILV110STATUS_OK );
}
/*************************************************************************
**									**
** name		: ILV110_DataRequest					**
** purpose	: send R interface data as V.110 rate adapted data	**
** inputs	: 							**
**		.R interface data structure address			**
** outputs	: 							**
**		.ILAPI status						**
**									**
*************************************************************************/
non_banked ILV110STATUS ILV110_DataRequest( void )
{
	ILV110STATUS RetStatus=ILV110STATUS_OK;	/* Return status */

/*	V110_LOG( V110_LOG_DATAREQ );*/

/*ltprintf( "ILV110_DataRequest st:%d ch=%xH\n", G(V110Control).uState, G(V110DataTx).ucData );*/

	/* Verify */
	if ( G(V110Control).uState < V110_STATE_AWAIT_SYNC ) {

		RetStatus = ILV110STATUS_BAD_STATE;
	}
	else {

		/* Process depending on state */
		switch ( G(V110Control).uState ) {
		case V110_STATE_AWAIT_SYNC:	/* Awaiting synchronization */
			v110_AwaitSyncRtnAPI();
			break;

		case V110_STATE_AWAIT_STATUS_BITS:/* Awaiting status S/X bits ON */
			v110_AwaitStatusBitsRtnAPI();
			break;

		case V110_STATE_DATA_XFER:	/* Data transfer */
			v110_DataXferRtnAPI();
			break;

		case V110_STATE_RESYNC:		/* Resynchronizing */
			v110_ResyncRtnAPI();
			break;

		case V110_STATE_DISCO_PENDING:	/* Disconnect pending */
			v110_DiscoPendingRtnAPI();
			break;
		}
	}

	return( RetStatus );
}

/*************************************************************************
**									**
** name		: ILV110_RcvdRawData					**
** purpose	: process received raw V.110 rate adapted data		**
** inputs	: 							**
**		.V.110 raw data address					**
**		.V.110 raw data size					**
** outputs	: 							**
**		.ILAPI status						**
**									**
*************************************************************************/
non_banked ILV110STATUS ILV110_RcvdRawData( BYTE *pRawData,
				 BYTE ucDataSz )
{
	ILV110STATUS RetStatus=ILV110STATUS_OK;	/* Return status */

/*	V110_LOG( V110_LOG_RCVDRAWDATA );*/

	/* Verify */
	if ( G(V110Control).uState < V110_STATE_AWAIT_SYNC ) {
//jc rel-12 printf( "ST=%d\n", G(V110Control).uState );

		RetStatus = ILV110STATUS_BAD_STATE;
	}
	else {

		/* Process depending on state */
		switch ( G(V110Control).uState ) {
		case V110_STATE_AWAIT_SYNC:	/* Awaiting synchronization */
			v110_AwaitSyncRtnNET( pRawData, ucDataSz );
			break;

		case V110_STATE_AWAIT_STATUS_BITS:/* Awaiting status S/X bits ON */
			v110_AwaitStatusBitsRtnNET( pRawData, ucDataSz );
			break;

		case V110_STATE_DATA_XFER:	/* Data transfer */
			v110_DataXferRtnNET( pRawData, ucDataSz );
			break;

		case V110_STATE_RESYNC:		/* Resynchronizing */
			v110_ResyncRtnNET( pRawData, ucDataSz );
			break;

		case V110_STATE_DISCO_PENDING:	/* Disconnect pending */
			v110_DiscoPendingRtnNET( pRawData, ucDataSz );
			break;
		}
	}

	return( RetStatus );
}

/*************************************************************************
**									**
** name		: ILV110_GetStatusInfo					**
** purpose	: get V.110 status information				**
** inputs	: 							**
**		.status information structure address			**
** outputs	: 							**
**		.ILAPI status						**
**									**
*************************************************************************/
non_banked ILV110STATUS ILV110_GetStatusInfo( PV110STATUS_INF_S pStatusInfo )
{
	ILV110STATUS RetStatus=ILV110STATUS_OK;	/* Return status */

	V110_LOG( V110_LOG_GETSTATUS );

	/* Fill in data fields */
	pStatusInfo->uILV110State = G(V110Control).uState;
	pStatusInfo->uILError = G(V110Control).uILLastError;

	return( RetStatus );
}

/*************************************************************************
**									**
** name		: ILV110_NeedXmtData					**
** purpose	: request from application to send V.110 data to keep	**
**			transmitter busy with frames; send last known	**
**			good frame					**
** inputs	: 							**
**		.none							**
** outputs	: 							**
**		.ILAPI status						**
**									**
*************************************************************************/
non_banked ILV110STATUS ILV110_NeedXmtData( void )
{
	BYTE ucLoop1;			/* Loop counter */
	ILV110STATUS RetStatus=ILV110STATUS_OK;	/* Return status */


	/* Verify */
	if ( G(V110Control).uState < V110_STATE_AWAIT_SYNC ) {

		RetStatus = ILV110STATUS_BAD_STATE;
	}
	else {

//		V110_LOG( V110_LOG_NEEDXMTDATA );

		/* Process depending on state */
		switch ( G(V110Control).uState ) {
		case V110_STATE_DATA_XFER:	/* Data transfer */

			/* Complete partial frame with ones */
			/* Complete byte first */
			if ( G(V110Control).ucXmtBitCount > 0 ) {

				/* Insert all ones */
				for ( ucLoop1=G(V110Control).ucXmtBitCount; ucLoop1<7; ++ucLoop1 ) {

					G(V110Control).ucCurrentXmtByte |=
						(1 << ucLoop1);
				}

				/* Setup for next byte */
				G(V110Control).ucXmtBitCount = 0;

				/* Insert byte in frame */
				G(V110Control).ucXmtFrameData[G(V110Control).ucXmtFrameByteCnt++] =
					G(V110Control).ucCurrentXmtByte;
			}

			/* Now check for partial frame */
			if ( G(V110Control).ucXmtFrameByteCnt == 0 ) {
			// Begin cb debug ....
			// If too much data is already in the DSP fifo
			// don't add any more IDLE frames.
			// This value of 450 is purely an empirical guess...
			// It may need further fine tuning...
				if((dp_read_dsp_ram(0xe1)) < 450 )
					return;
			// End cb debug ....

				/* Send clean frame */
				v110SetUpEmptyDataFrame();
			}
			else {
				// x_debug_msg("CB - Finish partial frame.");

				/* Now insert rest of the bytes */
				while ( G(V110Control).ucXmtFrameByteCnt <
				     V110_FRAME_SIZE_BYTES ) {

					if ( G(V110Control).ucXmtFrameByteCnt == 5 ) {

						/* No data bits in byte 5 */
						G(V110Control).ucXmtFrameData[5] =
							G(V110Control).uEbits |
							G(V110Control).uCbits |
							G(V110Control).uE7bit |
							0x01;
					}
					else {

						/* Insert all ones along with
						the current status bit */
						G(V110Control).ucXmtFrameData[G(V110Control).ucXmtFrameByteCnt] =
							v110SetStatusBits( G(V110Control).ucXmtFrameByteCnt ) | 0x7f;
					}

					/* One more byte */
					++G(V110Control).ucXmtFrameByteCnt;
				}
			}
			break;
		}

		/* Send last built frame through RA2 stage */
		v110SendRA2Frame( &G(V110Control).ucXmtFrameData[0],
				  V110_FRAME_SIZE_BYTES );

		/* No more data bytes in frame */
		G(V110Control).ucXmtFrameByteCnt = 0;
	}

	return( RetStatus );
}

#ifdef V110TEST
test_extract()
{
	v110SerialDecode( TRUE, 0 );
	G(V110Control)[0].ucRcvFrameData[0] = 0x00;
	G(V110Control)[0].ucRcvFrameData[1] = 0x45;
	G(V110Control)[0].ucRcvFrameData[2] = 0x13;
	G(V110Control)[0].ucRcvFrameData[3] = 0x33;
	G(V110Control)[0].ucRcvFrameData[4] = 0x35;
	G(V110Control)[0].ucRcvFrameData[5] = 0xfd;
	G(V110Control)[0].ucRcvFrameData[6] = 0x4d;
	G(V110Control)[0].ucRcvFrameData[7] = 0x51;
	G(V110Control)[0].ucRcvFrameData[8] = 0x53;
	G(V110Control)[0].ucRcvFrameData[9] = 0x35;
	v110ExtractData4800( 0 );
	G(V110Control)[0].ucRcvFrameData[0] = 0x00;
	G(V110Control)[0].ucRcvFrameData[1] = 0x65;
	G(V110Control)[0].ucRcvFrameData[2] = 0x4d;
	G(V110Control)[0].ucRcvFrameData[3] = 0x7f;
	G(V110Control)[0].ucRcvFrameData[4] = 0x7f;
	G(V110Control)[0].ucRcvFrameData[5] = 0xfd;
	G(V110Control)[0].ucRcvFrameData[6] = 0x7f;
	G(V110Control)[0].ucRcvFrameData[7] = 0x45;
	G(V110Control)[0].ucRcvFrameData[8] = 0x13;
//	G(V110Control)[0].ucRcvFrameData[7] = 0x7f;
//	G(V110Control)[0].ucRcvFrameData[8] = 0x7f;
	G(V110Control)[0].ucRcvFrameData[9] = 0x7f;
	v110ExtractData4800( 0 );
}
#endif
#endif	// defined(CS_V110)
