/********************
 * File : riscosutil.c
 * riscos version of winutil.c
 ********************/



#include "kernel.h"
#include "swis.h"

#include <stdio.h>

#include "llglob_d.h"	// modify this loc as needed
#include "iouart_d.h"
#include "ioglob_d.h"
#include "dpglob.h"
#include "z80flash.h"
#if defined(HDLC_FRAMES_BY_REFERENCE)
# include "lapm.h"
#endif
#include "allglobs.h"

#include "riscos.h" /* led functions etc */

#include "debuglib/debuglib.h"



//extern void riscos_enable_interrupt(void);


/////////////////////////////////////////////////////////////////////////////////
//msm:timing debug
#define TIMING_ARRAY_SIZE 2048
static int  timing_array_start[TIMING_ARRAY_SIZE];
static int *timing_array_end = timing_array_start+TIMING_ARRAY_SIZE;
static int *timing_array_current = timing_array_start;
static word timing_clock = 0;
//static TIME_MIN_SEC timing_clock;
static int timing_array_lock = 0;

static void timing_clock_start(void)
{
  if (!timing_array_lock)
  {
    timing_clock = x_current_time();
//x_set_current_time ( &timing_clock );
  }
}

static void timing_clock_stop(void)
{
  if (!timing_array_lock)
  {
    *timing_array_current++ = (int)x_elapsed_time( timing_clock )/10;
//    *timing_array_current++ = (int)x_elapsed_long_time( timing_clock );
    if (timing_array_current > timing_array_end )
      timing_array_current = timing_array_start;
  }
}

void timing_stats(void)
{
  int *ip = timing_array_start;

  timing_array_lock = 1; // lock array
 
  for ( ; ip < timing_array_end ; ip++ )
  {
    if (ip==timing_array_current)
      printf("[%i] ",*ip );
    else
      printf("%i ",*ip);
  }
  printf("\n");
  
  timing_array_lock = 0; // unlock array
}

//msm:end
/////////////////////////////////////////////////////////////////////////////////






extern int RO_cts;
extern int RO_dcd;
extern int RO_dsr;
extern int RO_ring;



typedef unsigned int U32;

//extern void output8(int address, int value);
//extern int input8(int address);


int BaseAddress       =0;			// variable BaseAddress
int BaseAddressData   =0;
int BaseAddress2      =0;


static firstTime = 1;
byte dpFailure = 0;
byte winFailure = 0;
//msm// word BaseAddressIndex;
byte BaseValue;



void debug_putc(byte ch)
{
  dprintf(("","%c",ch));
}
byte debug_puts(char *str)
{
  dprintf(("","%s",str));
  while(*str)
    str++;
  return *(str-1); // this is used to spot '=' signs //
}
word x_current_time(void)
{
  int time;

  _swix(OS_ReadMonotonicTime, _OUT(0), &time);
  return (word)(time*10);
}


void x_debug_msg ( char *message )
{
	if(ddputs_nnl(message) != '=')
	{
		sendCrLf();
	}
}

/****************************************************************
	Function : sendDecByte(byte ch)
	prints a decimal byte
*****************************************************************/
void sendDecByte(byte ch)
{
	byte x = 0;
	byte y = 0;

	/* hundreds */
	while (ch > 99)
	{
		y++;
		x++;
		ch -= 100;
	}
	if (x)
	{
		sendDumbChar((byte) (x + '0'));
		x = 0;
	}

	/* tens */
	while (ch > 9)
	{
		x++;
		ch -= 10;
	}
	if (x || y)
	{
		sendDumbChar((byte) (x + '0'));
		x = 0;
	}

	sendDumbChar((byte) (ch + '0'));
}

/****************************************************************
	Function : ddputs(char *str)
	prints a time stamped string on the debug port with CRLF
*****************************************************************/
void ddputs(char *str)
{
	ddputs_nnl(str);

	sendCrLf();
}

extern byte debug_puts(char *str);

/****************************************************************
	Function : ddputs_nnl(char *str)
	prints a string on the debug port
*****************************************************************/
byte ddputs_nnl(char *str)
{
#if defined(OLD_WAY)
	while (*str)
	{
		sendDumbChar(*str++);
	}

	return *(str-1);
#endif
	return debug_puts(str);
}

extern const byte str_convert[];

/****************************************************************
	Function : sendHexDigit(byte digit)
	Converts the digit to ASCII and prints it on the debug port
*****************************************************************/
void sendHexDigit(byte digit)
{
	sendDumbChar((byte) ((digit > 0x0f) ? 'X' : str_convert[digit]));
}

/****************************************************************
Routine : sendCrLf - send carriage return line feed to dumb port
*****************************************************************/
void sendCrLf(void)
{
	sendDumbChar(0x0D);	// CR - '\r'
	sendDumbChar(0x0A);	// LF - nl - '\n'
}

extern void debug_putc(byte ch);

/****************************************************************
	Function : sendDumbChar(byte ch)
	Sends a char on the Dumb Serial port
*****************************************************************/
void sendDumbChar(byte ch)
{
	debug_putc(ch);
}

/****************************************************************
	Function : sendHexByte(byte ch)
	prints a hex byte
*****************************************************************/
void sendHexByte(byte ch)
{
	sendHexDigit( (byte) ((ch >> 4) & 0x0f));
	sendHexDigit( (byte) (ch & 0x0f ));
}

/****************************************************************
	Function : sendHexWord(word wd)
	prints a hex word
*****************************************************************/
void sendHexWord(word wd)
{
	byte i;

	for (i=0; i<4; i++)
	{
		sendHexDigit((byte) ((wd & 0xf000) >> 12));
		wd <<= 4;
	}
}

void fatal_error(char *str)
{
	sendHexWord( x_current_time() ) ;
	x_debug_msg(": fatal error: ");
	ddputs_nnl(str);
	sendCrLf();
	while(1)
		;
}

/*****************************************************************
	Function : x_sleep_mode
	Put the uC into sleep mode.
******************************************************************/
byte x_sleep_mode ( void )
{
	return TRUE ;
}

/****************************************************************
	Function : z80_flow_on
	used by voice isr in z80dsp.c file 
	we may need to turn cts off during voice block transfer
*****************************************************************/
void z80_flow_on ( void )
{
}

/****************************************************************
	Function : z80_uart_break_on
	received break from dce
*****************************************************************/
void z80_uart_break_on ( void )
{
}

/****************************************************************
	Function : z80_uart_break_off
	received break from dce
*****************************************************************/
void z80_uart_break_off ( void )
{
}

/****************************************************************
	Function : z80_uart_cts_on
*****************************************************************/
void z80_uart_cts_on ( void )
{
  RO_cts=1;
}

/****************************************************************
	Function : z80_uart_cts_off
*****************************************************************/
void z80_uart_cts_off ( void )
{
  RO_cts=0;
}

/****************************************************************
	Function : z80_uart_cd_on
*****************************************************************/
void z80_uart_cd_on ( void )
{
  //msm dcd==cd ?
  RO_dcd=1;
}

/****************************************************************
	Function : z80_uart_cd_off
*****************************************************************/
void z80_uart_cd_off ( void )
{
  //msm dcd==cd ?
  RO_dcd=0;
}

/****************************************************************
	Function : z80_uart_dsr_on
*****************************************************************/
void z80_uart_dsr_on ( void )
{
  RO_dsr=1;
}

/****************************************************************
	Function : z80_uart_dsr_off
*****************************************************************/
void z80_uart_dsr_off ( void )
{
  RO_dsr=0;
}
 
/****************************************************************
	Function : z80_uart_ri_on
*****************************************************************/
void z80_uart_ri_on ( void )
{
  RO_ring=1;
}

/****************************************************************
	Function : z80_uart_ri_off
*****************************************************************/
void z80_uart_ri_off ( void )
{
  RO_ring=0;
}

/****************************************************************
*       at_percent_f() - dummy function for no at%f
*****************************************************************/
void at_percent_f ( void )
{
}

void at_dash_i3(void)
{
}

void z80_swfc_on(void)
{
}

void z80_swfc_off(void)
{
}

word z80_checksum ( byte x )
{
	x=x;
	return 0 ;
}

//--------------------------------------------------
// dummy functions for EEPROM
//--------------------------------------------------
byte read_eeprom ( word loc )
{
  if (loc==COUNTRY_ID)
    return UK;
  
        loc=loc;	// get rid of warning
	return 0;
}
void write_eeprom ( word loc, byte data_value )
{
	loc=loc;
	data_value=data_value;	// get rid of warnings
}

// these next two were added on advice from Ben.
dword x_current_time_long ( void )
{
        return ( (dword)x_current_time() ) ;
}

dword x_elapsed_time_long ( dword timer )
{
        return ( (dword) (x_current_time() - (word)timer) ) ;
}

/****************************************************************
Routine : x_elapsed_time
Description :
	Used to determine the time elapsed since the timer was started.
Parameters in : timer	- start time
Parameters out : time elapsed in millseconds since start time.
*****************************************************************/
word x_elapsed_time ( word timer )
{
	DP_CHKDSP() ;

	return ( (word) (x_current_time() - timer) ) ;
}

#if defined( DSP_POLLED_MODE )
#define DP_INT_REGREAD(reg) dp_regread(reg)
#define DP_INT_REGREAD2(reg) dp_regread(reg)
#define DP_INT_REGWRITE(reg, value)	dp_regwrite(reg, value)

#else
#define DP_INT_REGREAD( reg )			\
  (output8( BaseAddress, (reg) ),		\
	input8(  BaseAddressData ) )

#define DP_INT_REGREAD2( reg )			\
  (output8( BaseAddress2, (reg) ),		\
	input8(  BaseAddressData ) )

//------------------------------------------------------
//		Write CAMILZ register MACRO
//------------------------------------------------------
#define DP_INT_REGWRITE( reg, value )	\
do										\
{										\
  output8( BaseAddress, (reg) ) ;		\
  output8( BaseAddressData, (value) ) ;	\
} while ( 0 )
#endif

byte dp_isr_regb0, *datap ;
word firstWord;

/****************************************************************
Routine : dual_port_tx ( void )
****************************************************************/
non_banked void dual_port_tx ( void )
{
	byte dp_isr_count, dp_dsp_tx_ptr ;

	//---------------------------------------------------
	// Look in DCE Ring Buffer for next frame to send.
	//---------------------------------------------------
	if ( io_dce_tx_rptr != io_dce_tx_wptr )
	{
		firstWord = *io_dce_tx_rptr;

		#if defined(HDLC_FRAMES_BY_REFERENCE)
		//------------------------------------------------
		// There is a frame present; is it an I Frame,
		// Supervisor Frame, or Unnumbered frame?
		//------------------------------------------------
		if ( firstWord & HDLC_IFRAME_PLACEHLDR )
		{
			word *hiWordDatapp, *loWordDatapp;

			/*********************************************
			**			It's an I Frame.
			**********************************************
			** A three word structure in the DCE ring
			** buffer actually represents the frame.
			** The format of an I Frame placeholder is:
			**	1st wd:		( FLAG(s) | count )
			**	2nd wd:		(upper data ptr)
			**	3rd wd:		(lower data ptr)
			*********************************************/

			//------------------------------------------
			// Get the count from the DCE ring buffer.
			//------------------------------------------
			dp_isr_count = (byte) firstWord;

			//------------------------------------------
			// Get the I Frame data ptr from DCE ring
			// buffer (must handle end of buffer wrap).
			//------------------------------------------
			//--------------------------------------
			// get data pointer from DCE ring buffer
			//--------------------------------------
			hiWordDatapp = G(io_dce_tx_rptr) + 1;
			if ( hiWordDatapp >= G(io_dce_tx_eptr) )
				hiWordDatapp = G(io_dce_tx_sptr);
			loWordDatapp = hiWordDatapp + 1;
			if ( loWordDatapp >= G(io_dce_tx_eptr) )
				loWordDatapp = G(io_dce_tx_sptr) ;
			datap = (byte *)((*hiWordDatapp)<<16 | *loWordDatapp);

			//-------------------------------------------
			// If new frame signal DSP to start a new
			// HDLC frame, and clear flag for LAPM layer.
			//-------------------------------------------
			if ( firstWord & HDLC_START_OF_FRAME )
			{
				dp_isr_regb0 = 0x40 ;
				*(datap-1) = 0;
			}
			else
			{
				dp_isr_regb0 = 0 ;
			}

			//------------------------------------------
			// Copy data into TX Mailbox area (80-8f)
			//------------------------------------------
			if ( dp_isr_count >= 16 )
			{
				//-----------------------------------------------
				// Send full 16 bytes and .....
				//-----------------------------------------------
				DP_INT_REGWRITE( 0x80, *datap        ) ;
				DP_INT_REGWRITE( 0x81, *(datap+0x01) ) ;
				DP_INT_REGWRITE( 0x82, *(datap+0x02) ) ;
				DP_INT_REGWRITE( 0x83, *(datap+0x03) ) ;

				DP_INT_REGWRITE( 0x84, *(datap+0x04) ) ;
				DP_INT_REGWRITE( 0x85, *(datap+0x05) ) ;
				DP_INT_REGWRITE( 0x86, *(datap+0x06) ) ;
				DP_INT_REGWRITE( 0x87, *(datap+0x07) ) ;

				DP_INT_REGWRITE( 0x88, *(datap+0x08) ) ;
				DP_INT_REGWRITE( 0x89, *(datap+0x09) ) ;
				DP_INT_REGWRITE( 0x8a, *(datap+0x0a) ) ;
				DP_INT_REGWRITE( 0x8b, *(datap+0x0b) ) ;

				DP_INT_REGWRITE( 0x8c, *(datap+0x0c) ) ;
				DP_INT_REGWRITE( 0x8d, *(datap+0x0d) ) ;
				DP_INT_REGWRITE( 0x8e, *(datap+0x0e) ) ;
				DP_INT_REGWRITE( 0x8f, *(datap+0x0f) ) ;
				dp_dsp_tx_ptr = 0x90 ;

				//-----------------------------------------------
				// ...check for End of Frame....
				//-----------------------------------------------
				if ( dp_isr_count > 16 )
				{
					//-----------------------------------------------
					// .... NOT Done with this frame yet;
					//-----------------------------------------------
					// adjust the count and datap in the
					// two word DCE ring Buffer structure
					// (removing the SOF flag).
					//-----------------------------------------------
					*io_dce_tx_rptr = (word)(HDLC_IFRAME_PLACEHLDR
												| (dp_isr_count-16));
					datap += 16;
					*hiWordDatapp = (word) ((U32)datap>>16);
					*loWordDatapp = (word) (unsigned long) (datap);
				}
				else
				{
					//-----------------------------------------------
					// .... Done with this frame
					//-----------------------------------------------
					// ..... skip over two word structure
					//  and set EOF in the trigger byte
					//  (done below)
					//-----------------------------------------------
					dp_isr_count = 0;
				}
			}
			else
			{
				//-----------------------------------------------
				// Done with this frame;
				// Send remaining (up to 15) bytes and .....
				//-----------------------------------------------
				dp_dsp_tx_ptr = 0x80;
				while ( dp_isr_count )
				{
					DP_INT_REGWRITE( dp_dsp_tx_ptr++, *datap++ ) ;
					dp_isr_count-- ;
				}
			}

			//-----------------------------------------------
			// Done with this frame ??
			//-----------------------------------------------
			if ( dp_isr_count == 0 )
			{
				//-----------------------------------------------
				//		Yes ...
				//-----------------------------------------------
				// ..... skip over three word structure
				//  and set EOF in the trigger byte
				//-----------------------------------------------
				if ( ++loWordDatapp >= io_dce_tx_eptr )
					io_dce_tx_rptr = io_dce_tx_sptr ;
				else
					io_dce_tx_rptr = loWordDatapp;

				//---------------------------------------
				// Signal to DSP end of the HDLC frame
				//---------------------------------------
				dp_isr_regb0 |= 0x80 ;

				//---------------------------------------
				// Signal lapm task to place another
				// iframep in DCE Ring Buffer.
				// Chk for zero is sanity test - should
				// never happen.
				//---------------------------------------
				if ( lapm_max_iframes ) lapm_max_iframes -- ;
			}
		}
		else
		#endif	// HDLC_FRAMES_BY_REFERENCE
		{
			dp_dsp_tx_ptr = 0x80;

			if ( firstWord & HDLC_TX_ANY_CHAR )
			{
				dp_isr_count = 0x85 ; // send max. 6 bytes
				dp_isr_regb0 = 0x20 ;
			}
			else
			{
				dp_isr_count = 0x8f ; // send max. 16 bytes
				dp_isr_regb0 = (byte) (firstWord & HDLC_START_OF_FRAME ? 0x40 : 0);
			}

			while ( (dp_dsp_tx_ptr <= dp_isr_count)
					&& (io_dce_tx_rptr != io_dce_tx_wptr) )
			{
				DP_INT_REGWRITE( dp_dsp_tx_ptr++, (byte)*io_dce_tx_rptr ) ;
				if ( *io_dce_tx_rptr & HDLC_END_OF_FRAME )
				{
					if ( ++io_dce_tx_rptr >= io_dce_tx_eptr )
						io_dce_tx_rptr = io_dce_tx_sptr ;
					dp_isr_regb0 |= 0x80 ;
					break ;
				}
				if ( ++io_dce_tx_rptr >= io_dce_tx_eptr )
					io_dce_tx_rptr = io_dce_tx_sptr ;

				// check SOF for V.80 support - needed
				// for framed mode without CRC
				if ( *io_dce_tx_rptr & HDLC_START_OF_FRAME )
				{
					break ;
				}
			}
		}

		dp_dsp_data_in_progress = TRUE ;
		DP_INT_REGWRITE( 0xb0, (byte)(dp_isr_regb0|(dp_dsp_tx_ptr-0x80)) );
	}
	else
	{
		dp_dsp_data_in_progress = FALSE ;
		DP_INT_REGWRITE( 0xb7, 0x01 ) ; // clear tx interrupt
	}
}

/****************************************************************
Routine : dual_port_rx ( void )
****************************************************************/
non_banked void dual_port_rx ( void )
{
	byte dp_isr_regb0, dp_isr_count, dp_rx_ptr ;
	unsigned short *first_ptr, *last_ptr = NULL;

	dp_isr_regb0 = DP_INT_REGREAD( 0xb0 ) ;

	dp_isr_count = (byte) (dp_isr_regb0 & 0x1f); // count
	if ( dp_isr_count == 0 )
	{
		x_debug_msg ( "DP - illegal rx status 0xb0" ) ;
	}
	else
	{
		dp_rx_ptr = 0x90 ;
		first_ptr = io_dce_rx_wptr ;
		// copy data into fifo
		while ( dp_isr_count-- )
		{
			*io_dce_rx_wptr = DP_INT_REGREAD2( (byte)(dp_rx_ptr++) ) ;

			last_ptr = io_dce_rx_wptr++ ;
			if ( io_dce_rx_wptr >= io_dce_rx_eptr )
				io_dce_rx_wptr = io_dce_rx_sptr ;

			if ( io_dce_rx_wptr == io_dce_rx_rptr )
                            x_debug_msg ("dual_port_rx - read overflow!!");
		}
		if ( dp_isr_regb0 & 0xe0 ) // crc error or start/end of frame
		{
			if ( dp_isr_regb0 & 0x20 ) // if start-of-frame
				*first_ptr |= HDLC_START_OF_FRAME ;
			if ( dp_isr_regb0 & 0xc0 )	// EOF (or) crc error
			{
				*last_ptr |= HDLC_END_OF_FRAME ;
				if ( dp_isr_regb0 & 0x40 ) // crc error (or) abort
				{
					*last_ptr |= HDLC_CRC_ERROR;
					//x_debug_msg("dp_bad_crc_count++");
					dp_bad_crc_count++;
				}
			}
		}
	}

	// 2nd dummy read to trigger dsp to write more data
	(void)DP_INT_REGREAD( 0xb0 ) ;
}

#if defined( DSP_POLLED_MODE )
/****************************************************************
Routine : dp_dsp_polled
Description :
    pseudo-interrupt handler.  looking for events
	that would have been interrupts had interrupts
	been enabled.

	assume interrupts are not disabled
*****************************************************************/
void dp_dsp_polled ( byte dp_isr_regd7 )
{
	byte dp_isr_regb6 ;

	dp_regwrite( 0xd7, 0xff ) ;

	//---------------------------------------------
	// ring edge interrupt ?
	//---------------------------------------------
	if ( dp_isr_regd7 & BIT1 )
	{
		// clear all interrupts on camil
		dp_regwrite( 0xd8, 0xff ) ;

		// ignore first 2 ring interrupts
		if ( G(dp_ring_int_count) > 1 )
		{
			x_debug_msg ( "dp - int : ring" ) ;
			G(dp_ring_int) = TRUE ;

			//-----------------------------------------
			// disable ring interrupt after first edge
			//-----------------------------------------
			G(dp_bamil_rd7) |= BIT1 ;

			// init when wake up from sleep
			dp_init_local_phone_timer () ;
		}

		// increment ring interrupt count
		G(dp_ring_int_count)++  ;
	}

	//---------------------------------------------
	// write bank interrupt ?
	//---------------------------------------------
	if ( dp_isr_regd7 & BIT3 )
	{
		//---------------------------------------------
		// this is a response to a command - clr CWBANK
		//---------------------------------------------
		dp_regwrite( 0xd8, 0x08 ) ;
		G(dp_byte_c) = dp_regread( 0x32 ) ;
		G(dp_byte_d) = dp_regread( 0x33 ) ;
		G(dp_byte_e) = dp_regread( 0x34 ) ;
		G(dp_byte_f) = dp_regread( 0x35 ) ;
	}

	//---------------------------------------------
	// dual-port data interrupt ?
	//---------------------------------------------
	if ( dp_isr_regd7 & BIT2 )
	{
		dp_isr_regb6 = dp_regread( 0xb6 ) ;

		if ( dp_isr_regb6 & BIT4 )
		{
			//----------------------
			// Receive data from DSP
			//----------------------
			dual_port_rx () ;
		}

		if ( dp_isr_regb6 & BIT0 )
		{
			//----------------------
			// Transmit data to DSP
			//----------------------
			dual_port_tx () ;
		}
	}
}

#else // not in dsp_polled_mode

/****************************************************************
Routine : dp_dsp_isr
Description :
    interrupt service routine for the dsp16a data pump
*****************************************************************/
void dp_dsp_isr ( void )
{
	byte dp_isr_regd7, dp_isr_status, dp_isr_regbc ;
#if defined(PCMCIA_MODEM)
	extern BOOL z80_ring_int;
#endif

#if !defined(EXT_MODEM) && !defined(USB_MODEM) && !defined(THUNDER)
	if (dp_sleep == TRUE)
	{
		// restore codec & bamil clocks and crystal oscillator
		DP_INT_REGWRITE(0xcb, 0);
//msm//		Oscr_delay(); // allow time to stabilize
	}
#endif //if !EXT_MODEM && !USB_MODEM && !THUNDER

	// find source of camil interrupt
	dp_isr_regd7 = DP_INT_REGREAD2( 0xd7 ) ;

	// disable all interrupts on camil
	DP_INT_REGWRITE(0xd7, 0xff);
//m        while ( DP_INT_REGREAD2( 0xd7 ) != 0 ) {} ;


//	#if defined(EXT_MODEM) || defined(THUNDER)
//	#if defined(THUNDER)
//	if ( z80_modem_type == EXT_INTERFACE )
//	#endif
//		enable_interrupt();
//	#endif

//m        _kernel_irqs_on();

	if (dp_isr_regd7 & BIT1)      // ring edge interrupt
	{
		// clear all interrupts on camil
		DP_INT_REGWRITE( 0xd8, 0xff ) ;
		if ( dp_ring_int_count > 1 )	// ignore first 2 ring interrupts 
		{
//#if defined(HOMOL) && defined(VOICE)
//			if ( dp_ring_int_count > 2 )
//				dp_polarity_int = FALSE;
//#endif

			x_debug_msg ( "dp - int : ring" ) ;
			dp_ring_int = TRUE ;
//#if defined(PCI_MODEM)
//			{
//				// Power management for pita/PCI
//				byte pitaData = pita_regread(0x12) & 0x03;//read power state
//				if (pitaData & 0x02) // only assert PME when in D2 or D3 modes
//				{
//					pitaData = pita_regread(0x13) | 0x80;
//					pita_regwrite(0x13, pitaData);
//
//					//  Interrupts are currently disabled, so just
//					//  loop here. Read the Power State in power
//					//  status configuration register.  If under
//					//  normal power it should be in D0 state (0x00).
//					//  Wait for this state to occur
//					while (pita_regread(0x12) & 0x03)
//					{
//						;	// do nothing
//					}
//				}
//			}
//#endif // PCI_MODEM
//
//#if defined(PCMCIA_MODEM)
//			z80_ring_int = TRUE ;
//#endif
			// disable ring interrupt after first edge
			dp_bamil_rd7 |= BIT1 ;
#if !defined(CS_MODEM) || defined(CLASS2_FAX) //ky+ 0413fix
			dp_init_local_phone_timer () ;	// init when wake up from sleep
#endif
            if( G( dp_daa_is_perseus ))
            {
			    dp_modem_command(GOTO_CMD,PERSEUS_BASE,PERSEUS_RING_EN);// dsp ram 0x3A bit 5 set on ring
            }
		}
		else
		{
			dp_ring_int_count++  ;	// increment ring interrupt count
#if defined (VOICE) && defined (HOMOL)
# ifdef CALLER_ID
			if ( (dp_ring_int_count == 1) 	// first interrupt
				 && ( S.ModemOptions.CallerId )      // CID enabled
			 && ( ((0x0f & S.ModemOptions.CallerIdType) == 1 ) // Japna cid
			 	|| ((0x0f & S.ModemOptions.CallerIdType) == 2 )) // UK cid (SIN 242)
				 && ( x_elapsed_time ( dp_timer ) >= MS50 ) ) // True pol rev
			{
				dp_polarity_int = TRUE ;
				dp_timer1 = x_current_time () ;
				x_debug_msg ( "dp - int : pol rev set TRUE" ) ;
			}
# endif	//CALLER_ID

			if ( ( dp_sleep == TRUE ) && ( dp_ring_int_count == 1 ) ) 	// first interrupt
			{
				// we need to turn on clocks - to get next ring int.
				// enable all dsp clocks - except audio rrm
				dp_regwrite ( 0xcb, 0x08 ) ;
			}
# ifdef CALLER_ID
			if ( ( S.ModemOptions.CallerId )      // CID enabled
			 && ( ((0x0f & S.ModemOptions.CallerIdType) == 1 ) // Japna cid
			 	|| ((0x0f & S.ModemOptions.CallerIdType) == 2 )) // UK cid (SIN 242)
				 && ( x_elapsed_time ( dp_timer ) >= MS50 ) ) // True pol rev
				dp_venus_wakeup();
# endif	//CALLER_ID
#endif //#if defined (VOICE) && defined (HOMOL)
		}
	}

#if !defined(DC0) && !defined(USB_MODEM)
//	#if defined(THUNDER)
//	if ( z80_modem_type == EXT_INTERFACE )
//	#endif
	if (dp_isr_regd7 & BIT6)	// local handset offhook (BIOB)
	{
		x_debug_msg("dp-int BIOB(local phone)");
		// clear all interrupts on camil
		DP_INT_REGWRITE( 0xd8, 0xff ) ;
		// disable local phone interrupt after first edge
		dp_bamil_rd7 |= BIT6;
		#if !defined(CS_MODEM) || defined(CLASS2_FAX)
		dp_init_local_phone_timer();	// init when wake up from sleep
		#endif

//		#if defined(PCI_MODEM)
//		// clear any PITA interrupt that caused this
//		pita_regwrite(0x04, 0xFF);		//Clear all INTSRC bits
//
//		// Don't interrupt on PCI events while awake
//		pita_regwrite(0x05, 0x00);
//		#endif

		#if defined (VOICE) && defined (HOMOL) && defined(CALLER_ID)
		// With some hardware we get false handset interrupt first
		// and never get the polarity reversal interrupt.
		// To overcome this problem if CID is enabled and pol rev
		// detect is enabled treat handset interrupt as pol rev
		// interrupt also. Under these conditions when there is
		// handset iterrupt we will wait to detect the CAR ring
		// for about 1-2 sec and then go back to idle state.
		if ((S.ModemOptions.CallerId )      // CID enabled
			&& (((0x0f & S.ModemOptions.CallerIdType) == 1)		// Japna cid
			 	|| ((0x0f & S.ModemOptions.CallerIdType) == 2))	// UK cid
			&& (x_elapsed_time(dp_timer) >= MS50)) // True pol rev
		{
			dp_polarity_int = TRUE;
			dp_timer1 = x_current_time();
			x_debug_msg("dp - int : pol rev set TRUE");
			dp_venus_wakeup();
		}
		#endif // VOICE && HOMOL && CALLER_ID
	}
#endif

#if defined(DC0) || ( !defined(USB_POLLED_MODE) && \
						(defined(USB_MODEM) || defined(THUNDER)) )
//# if defined(THUNDER)
//	if ( z80_modem_type == USB_INTERFACE )
//# endif
	//-----------------------------------
	// is it a BIOB interrupt ?
	//-----------------------------------
	if ( dp_isr_regd7 & BIT6 )
	{
		dp_isr_regbc = DP_INT_REGREAD( 0xbc ) ;

# if defined(DC0)
		if ( dp_isr_regbc & BIT4 )
		{
			// process cellular interrupt
			cell_isr () ;
		}
# else
	//-----------------------------------------
	// Since DC0 is PCMCIA only, it must be USB
	//-----------------------------------------
#  if !defined(TQFP128)	// 144 pin has int on Bit3
		if ( dp_isr_regbc & BIT3 )
#  else					// 128 pin has int on Bit5
		if ( dp_isr_regbc & BIT5 )
#  endif
		{
			//------------------------------------
			// process USB interrupt. Since the USB
			// interrupt must be level triggered,
			// clear the interrupt only after the
			// call to the ISR.
			//------------------------------------
			z80_usbir();
		}
# endif

		// clear & reset bio interrupt
		DP_INT_REGWRITE( 0xbd, dp_isr_regbc ) ;
		// note that we're writing 1's to reserved bits here.
		DP_INT_REGWRITE( 0xbd, ~dp_isr_regbc ) ;
	}
#endif	// DC0 || "USB in int mode"

	if ( dp_isr_regd7 & BIT3 )	// write bank interrupt
	{
		// this is a response to a command
		DP_INT_REGWRITE( 0xd8, 0x08 ) ; //clear CWBANK
		dp_byte_c = DP_INT_REGREAD( 0x32 ) ;
		dp_byte_d = DP_INT_REGREAD( 0x33 ) ;
		dp_byte_e = DP_INT_REGREAD( 0x34 ) ;
		dp_byte_f = DP_INT_REGREAD( 0x35 ) ;
	}

	if ( dp_isr_regd7 & BIT2 ) // dual-port data interrupt
	{
		dp_isr_status = DP_INT_REGREAD( 0xb6 ) ;

		if ( dp_isr_status & 0x10 ) //if receive data transfer
		{
			dual_port_rx () ;
		}
		if ( dp_isr_status & 0x01 ) // Tx request.
		{
			dual_port_tx () ;
		}
	} // dual-port interrupt


//	#if defined(EXT_MODEM) || defined(THUNDER)
//	#if defined(THUNDER)
//	if ( z80_modem_type == EXT_INTERFACE )
//	#endif
//		disable_interrupt() ;
//	#endif
  
//m        _kernel_irqs_off();

	// enable camil interrupts
	DP_INT_REGWRITE( 0xd7, dp_bamil_rd7 ) ;
}

#endif

/****************************************************************
Routine : dp_regwrite
	Write a CAMILZ register - it's ok if interrupts are
		enabled or disabled.  Can't be called from the dp
		interrupt handler.
*****************************************************************/
/*msm
void dp_regwrite ( byte reg, byte value )
{
	// BaseValue is saved so that if this is interrupted
	// we can put back the proper value into the index register
	// and write the correct value.
	BaseValue = reg ;

//msm//	BaseAddressIndex = BaseAddress ;
	output8( BaseAddress, reg ) ;
	output8( BaseAddressData, value ) ;
}
msm*/
void dp_regwrite ( byte reg, byte value )
{
  _kernel_irqs_off();
    output8( BaseAddress, reg ) ;
    output8( BaseAddressData, value ) ;
  _kernel_irqs_on();
}



/****************************************************************
Routine : dp_regread
	read a CAMILZ register - it's ok if interrupts are
		enabled or disabled.  Can't be called from
		the dp interrupt handler.

	For bamil register read,
		if register <= 0x7f
		or register >= 0xa0 && <= 0xcf
			Index Address = BaseAddress + 0
			Data  Address = BaseAddress + 1

		if register >= 0x80 && <= 0x9f
		or register >= 0xd0
			Index Address = BaseAddress + 2
			Data  Address = BaseAddress + 1
*****************************************************************/
/*msm
byte dp_regread ( byte reg )
{
	// BaseValue is saved so that if this is interrupted
	// we can put back the proper value into the index register
	// and write the correct value.
	BaseValue = reg ;

	if ( ( reg <= 0x7f ) || ( ( reg >= 0xa0 ) && ( reg <= 0xcf ) ) )
	{
		output8( BaseAddress, reg ) ;
//msm//		BaseAddressIndex = BaseAddress ;
	}
	else 
	{
		output8( BaseAddress2, reg ) ;
//msm//		BaseAddressIndex = BaseAddress2 ;
	}
	
	return  (byte) input8( BaseAddressData  ) ;
}
msm*/
byte dp_regread ( byte reg )
{
  byte value;

  if ( ( reg <= 0x7f ) || ( ( reg >= 0xa0 ) && ( reg <= 0xcf ) ) )
  {
    _kernel_irqs_off();
      output8( BaseAddress, reg ) ;
      value = input8( BaseAddressData ) ;
    _kernel_irqs_on();
  }
  else 
  {
    _kernel_irqs_off();
      output8( BaseAddress2, reg ) ;
      value = input8( BaseAddressData ) ;
    _kernel_irqs_on();
  }
  return value;
}


//#define	QMP_PRESENT		// This (venus/cs4) chip has QMP (not Apollo)
#define QMP_FIFO_WORDS	64

extern void w_trace(char *);

#if defined(QMP_PRESENT)
/****************************************************************
Routine : qmp_write
	Write words of data to external memory using QMP mode.

	This is the fastest way to do downloads.  Some parts, however,
	don't have the QMP block, so this isn't possible.

*****************************************************************/
void qmp_write ( word *srcp, U32 dstLoc, byte wdcnt )
{
	word t;

	if ( wdcnt > QMP_FIFO_WORDS )
	{
		x_debug_msg("Bad WordCnt");
		return;
	}

	//------------------------------------
	// Enable QMP and 16 bit access
	// Must Enable RMP first!!
	//------------------------------------
	_outp(RMPMR, 0);			// Enable RMP
	_outp(RMPMR, BIT0);			// Enable QMP
	_outp(QMPHCS, BIT1|BIT0);	// Enable 16-bit access

	//------------------------------------
	// Clear TX fifo and select transmit
	// register bank (and 1 ws)
	//------------------------------------
	_outp(QMPACS, BIT6|BIT3|BIT2 ) ;

	t = x_current_time();

	//------------------------------------
	// wait for completion of write.
	//------------------------------------
	while ( !(_inp( QMPHI ) & BIT1) )
	{
		if (x_elapsed_time(t) > MS100)
		{
			w_trace("QMP - TX TIMEOUT (first wait)");

			//------------------------------------
			// Put host interface back in DIA mode
			// (going first back to RMP mode)
			// Note: Don't change the 8 bit / 16
			// bit switch!!!
			//------------------------------------
			_outp( QMPHCS, BIT1 ) ;
			_outp( RMPMR, BIT7 ) ;
			dpFailure = 1;
			return;
		}
	}

	//------------------------------------
	// Clear host interrupts
	//------------------------------------
//	_outp(QMPHI, 0 ) ;

	//------------------------------------
	// set TX address register
	//------------------------------------
	_outpw(QMPAL, (word)((U32)dstLoc&0xffff) ) ;
	_outpw(QMPAM, (word)((U32)dstLoc>>16) ) ;

	//------------------------------------
	// Enable Xmit DMA with one wait state		// can rcv be hurt?
	//------------------------------------
	_outp(QMPACS, BIT3|BIT2|BIT1 ) ;

	//------------------------------------
	// load the TX fifo
	//------------------------------------
	while ( wdcnt-- )
	{
		_outpw( QMPD, (word) *srcp++);
	}

	//------------------------------------
	//  start the transfer
	//------------------------------------
	_outp( QMPHCS, BIT3|BIT1|BIT0 ) ;

	t = x_current_time();

	//------------------------------------
	// wait for completion of write.
	//------------------------------------
	while ( !(_inp( QMPHI ) & BIT1) )
	{
		if (x_elapsed_time(t) > MS100)
		{
			w_trace("QMP - TX TIMEOUT (second wait)");
			break ;
		}
	}

	//------------------------------------
	// Put host interface back in DIA mode
	// (going first back to RMP mode)
	// Note: Don't change the 8 bit / 16
	// bit switch!!!
	//------------------------------------
	_outp( QMPHCS, BIT3|BIT1);
	_outp( RMPMR, BIT7 );
}
#endif

//#define VERIFY_DOWNLOAD

#if !defined(DRAGNET)
/****************************************************************
Routine : rmp_write
	Write words of data to external memory using RMP mode.

*****************************************************************/
void rmp_write ( word *srcp, U32 dstLoc, byte wdcnt )
{
	dstLoc <<= 1;		// convert address from words to bytes

	// RMP mode
	_outp(RMPMR, 0);			// Enable RMP

	// address
	_outp(RMPAL, (byte)(dstLoc & 0xff) ) ;
	_outp(RMPAM, (byte)((dstLoc>>8) & 0xff) ) ;
	_outp(RMPAH, (byte)((dstLoc>>16) & 0x0f) ) ;

	// auto increment write to memory
	_outp(RMPMR, BIT6|BIT4);

	while (wdcnt--)
	{
		byte b0 = (byte) (*srcp & 0xff);
		byte b1 = (byte) ((*srcp >> 8) & 0xff);
		word t = x_current_time();

		// write first data byte of this word
		_outp(RMPD, b1);

		// poll 'til it's done
		//------------------------------------
		// wait for completion of write.
		//------------------------------------
		while (_inp( RMPMR ) & BIT5)
		{
#if defined(VERIFY_DOWNLOAD)
			if (x_elapsed_time(t) > MS100)
			{
				w_trace("RMP - TX TIMEOUT (first wait)");

				//------------------------------------
				// Put host interface back in DIA mode
				//------------------------------------
				_outp( RMPMR, BIT7 ) ;
				dpFailure = 1;
				return;
			}
#endif
		}

		// write second data byte of this word
		_outp(RMPD, b0);

		// poll 'til it's done
		//------------------------------------
		// wait for completion of write.
		//------------------------------------
		while (_inp( RMPMR ) & BIT5)
		{
#if defined(VERIFY_DOWNLOAD)
			if (x_elapsed_time(t) > MS100)
			{
				w_trace("RMP - TX TIMEOUT (first wait)");

				//------------------------------------
				// Put host interface back in DIA mode
				//------------------------------------
				_outp( RMPMR, BIT7 ) ;
				dpFailure = 1;
				return;
			}
#endif
		}
		srcp++;			// next word to download
	}

	//------------------------------------
	// Put host interface back in DIA mode
	//------------------------------------
	_outp( RMPMR, BIT7 ) ;
}

#endif

void dsp_clear_interrupts(void)
{
  DP_INT_REGWRITE(0xd8,0xff); // clear
}
void dsp_disable_interrupts(void)
{
  DP_INT_REGWRITE(0xd8,0xff); // clear
  DP_INT_REGWRITE(0xd7,0xff); // disable
}


#if defined(COMPRESS_TABLES)

#include "cplut.h"

word cp_flag;
short cp_cur;
short cp_next;
char cp_zero_zone;
char cp_cur_flag_ctr;

word *pcp_pcnt;
word *pcp_pflag;
unsigned char *pcp_pcode;

/****************************************************************
Routine : decode_word()
Description :
	Decode the next word of the compressed DSP code.
*****************************************************************/
short decode_word(word *ptr)
{
	if ((cp_cur--) <= cp_next)
	{
		cp_next = *pcp_pcnt++;
		cp_zero_zone = (char) (!cp_zero_zone);
	}
	if (cp_cur < 0)
		return 0;

	if (cp_zero_zone)
		*ptr = 0;		// zero's are treated as a special case
	else
	{
		if (!cp_cur_flag_ctr)
		{
			cp_cur_flag_ctr = 16;
			cp_flag = *pcp_pflag++;
		}
		cp_cur_flag_ctr--;
		if (cp_flag&0x1)
		{
			*ptr = cplut[*pcp_pcode++];
		}
		else
		{
			*ptr = *(unsigned short *) pcp_pcode;
			pcp_pcode += 2;
		}
			
		cp_flag >>=1;
	}

	return 1;
}

/****************************************************************
Routine : init_ptrs_long()
Description :
	Initialize the pointers to begin the decompression
	of the DSP code.
*****************************************************************/
void init_ptrs(word *in)
{
  pcp_pcnt = in;
  cp_cur = *pcp_pcnt++; 
  cp_next = *pcp_pcnt++;   

  while (*in++)
	  ;
  pcp_pcode = (unsigned char *) (in + *in + 1 );
  pcp_pflag = in+1;

  if (cp_cur & 0x8000)
  {
	  cp_cur = (short int) (cp_cur & 0x7FFF);
	  cp_zero_zone = 1;
  }
  else
	  cp_zero_zone = 0;
  cp_cur_flag_ctr = 0;

}

/****************************************************************
Routine : dp_download_dsp
Description : download dsp code by using dsp download command
		through mailbox - 6 bytes at a time.
*****************************************************************/
void dp_download_dsp(const byte *addr)
{
	word bPtrBuf[3];
	byte *bPtr ;
	word wCntr ;
	byte i, k, tmp_rd7 ;

	tmp_rd7 = G(dp_bamil_rd7) ;

dprintf(("","dp_download_dsp():"));

	G(dp_bamil_rd7) = 0xff ;
	dp_regwrite ( 0xd8, 0xff ) ;	// clear all interrupts on camil
	dp_regwrite ( 0xd7, 0xff ) ;	// disable all interrupts on camil

	// disable parallel data mode
	dp_modem_command_long(PDM, 0, 0, 0, 0);
	dp_write_dsp_ram(0x39, 0x0);		// clear fax options word

	init_ptrs((word *) addr);
	
	while (    decode_word(&bPtrBuf[0]) &&
		   decode_word(&bPtrBuf[1]) &&
		   decode_word(&bPtrBuf[2])    )
	{
		bPtr = (byte *)bPtrBuf ;
		wCntr = ((DspFileHdr *)bPtr)->wFileSize ;

		// copy address, length and checksum.
		dp_regwrite ( 0x30, 0x01 ) ; // for external ram download set to 1
		for (i = 0; i < 6 ; i++ )
		{	
			dp_regwrite ( (byte)(i+0x31), *bPtr++ );
		}
		dp_regwrite ( 0xd8, 0x18 ) ;	// clear core read/write bank bit - CRBNKI
		dp_regwrite ( 0x37, 0x1a ); // initial program download.
		wait_for_core_read () ;

		while ( wCntr )
		{
			if ( wCntr >= 3 )
			{
				k = 6 ;
				wCntr -= 3 ;
			}
			else
			{
				k = (byte)(2*wCntr) ;
				wCntr = 0 ;
			}
		
			bPtr = (byte *)bPtrBuf ;
			for (i = 0; i < (k>>1) ; i++ )
			{
				decode_word(&bPtrBuf[i]);
			}

			// copy 6 bytes of data
			for (i = 0; i < k ; i++ )
			{
				dp_regwrite ( (byte)(0x30+i), *bPtr++ ) ;
			}
			dp_regwrite ( 0xd8, 0x18 ) ; // clear core read/write bank bit - CRBNKI
			if ( wCntr )
			{
				dp_regwrite ( 0x37, (byte)(0xc0|k) ) ;
			}
			else
			{
				dp_regwrite ( 0x37, (byte)(0xc8|k) ) ;//end of section
			}
			wait_for_core_read () ;
		}
	}
        dp_regwrite ( 0xb7, 0xff ) ; // clear interrupt NCWTB
	dp_regwrite ( 0xd8, 0xff ) ;	// clear all interrupts on camil

	// enable the dsp interrupts
	G(dp_bamil_rd7) = tmp_rd7 ;
	dp_regwrite ( 0xd7, G(dp_bamil_rd7) ) ;
dprintf(("","ok"));
}

/****************************************************************
Routine : dp_download_dspk56_long
Description : download dsp code into external RAM.
*****************************************************************/
void dp_download_dspk56( word *addr, byte dstBank )
{
	word t = x_current_time();
	word d, loc = (word) (((dstBank - BBR0) * 0x800) + 0x8000);
	word i, first0Loc = loc;

#if defined(DRAGNET)
	dp_regwrite( 0xda, 0x00);

	// set ioc register for external ram with address 15 always high
	dp_dsp_int_regwrite( 1, 0x0808 );
#endif
	init_ptrs(addr);

	while (decode_word(&d))	   // get decompressed word
	{
#if !defined(NO_SAVE_UP_ZEROS)
		// if we've been saving up zeros then deal with them
		if (d)
		{
			// Skip long strings of zeros
			for (i=first0Loc; i<loc; i++)
			{
				dp_write_dsp_ram(i, (word) 0);
			}
			dp_write_dsp_ram(loc++, d);
			first0Loc = loc;
		}
		else
		{
			loc++;
			// if it's been 127 zeros then send these using DSP command
			// (127 is the most this DSP command can handle)
			if (loc - first0Loc > 126)
			{
				// DSP Fill command fills RAM with value
				dp_apollo_command(0x33, 127,
								  (byte) (first0Loc >> 8), (byte) first0Loc,
								  (byte) 0, (byte) 0,
								  (byte) 0, (byte) 0);

				first0Loc += 127;
			}
		}
#else
		dp_write_dsp_ram(loc++, d);		// old way (no zero skip)
#endif
	}

	x_debug_msg("dp_download_dspk56 time=");
	dp_puts_dec(x_elapsed_time(t));
	sendCrLf();
}
#else // (not COMPRESS_TABLES) ********************

/****************************************************************
Routine : dp_download_dspk56_long
Description : download dsp code into external RAM.
*****************************************************************/
void dp_download_dspk56_long ( word *sourcep, word count, byte dstBank )
{
	word t = x_current_time();

#if defined(QMP_PRESENT) || !defined(DRAGNET)
	word *sp = sourcep;
	word cnt = count;
	
	U32 dstLoc;

	//--------------------------------------------------
	// For compatibility with Zinger8 loads, convert
	// the BBR value, offset pair into a DSP external
	// memory word ptr.
	//--------------------------------------------------
	dstLoc = (U32)(((U32)dstBank*0x1000 + BANKOFFSET) >> 1);

#if defined(VERIFY_DOWNLOAD)
	// initialize
	{
		word i, loc;

		loc = ((dstBank - BBR0) * 0x800) + 0x8000;
		for (i=0; i < count; i++)
		{
			dp_write_dsp_ram(loc++, 0);
		}
	}
#endif

	while ( count >= QMP_FIFO_WORDS )
	{
#if defined(QMP_PRESENT)
		qmp_write(sourcep, dstLoc, QMP_FIFO_WORDS);
#else
		rmp_write(sourcep, dstLoc, QMP_FIFO_WORDS);
#endif
		sourcep += QMP_FIFO_WORDS ;
		dstLoc += QMP_FIFO_WORDS ;
		count -= QMP_FIFO_WORDS ;
	}

	if ( count )
	{
#if defined(QMP_PRESENT)
		qmp_write(sourcep, dstLoc, (byte) count);
#else
		rmp_write(sourcep, dstLoc, (byte) count);
#endif
	}

#if defined(VERIFY_DOWNLOAD)
	// verify
	{
		word i, loc;


		loc = ((dstBank - BBR0) * 0x800) + 0x8000;
		for (i=0; i < cnt; i++)
		{
			if (dp_read_dsp_ram(loc) != *sp)
			{
				x_debug_msg("download verify fails loc=");
				dp_puts_hex(loc);
				x_debug_msg("read_dsp_ram=");dp_puts_hex(dp_read_dsp_ram(loc));
				x_debug_msg("actual=");		 dp_puts_hex(*sp);
				sendCrLf();
				break;
			}
			loc++;
			sp++;
		}
	}
#endif

#else
	// no RMP or QMP, use write_ram's
	word i;
	word loc = ((dstBank - BBR0) * 0x800) + 0x8000;

dprintf(("","uncompressed download:"));
#if defined(DRAGNET)
	dp_regwrite( 0xda, 0x00);

	// set ioc register for external ram with address 15 always high
	dp_dsp_int_regwrite( 1, 0x0808 );
#endif

	for (i=0; i < count; i++)
	{
		dp_write_dsp_ram(loc++, *sourcep++);
	}
#endif // QMP or DRAGNET

	x_debug_msg("done with dp_download_dspk56_long time=");
	dp_puts_dec(x_elapsed_time(t));
	sendCrLf();
dprintf(("","ok\n"));
}
#endif // COMPRESS_TABLES

/****************************************************************
Routine : dp_start_transmit
Description :
    start the data transmission if idle. enable transmit interrupt.
*****************************************************************/
void dp_start_transmit ( void )
{
	if ( G(dp_dsp_data_in_progress) == FALSE )
	{
		G(dp_dsp_data_in_progress) = TRUE ;
		dp_regwrite( 0xb0, 0 ) ;	// kick off transmit
	}
}

// return whether modem's CTS is on or off.
int UART_cts(void)
{
	return (io_uart_status & UART_CTS_ON) ? TRUE : FALSE;
}

extern void dp_task(MODEM_COMMAND cmd, byte *text_ptr, word text_len);
extern void io_task(MODEM_COMMAND cmd, byte *text_ptr, word text_len);
//extern void consoleStrOut(char *str, int len);	// send to console window
extern int consoleCharOut(byte ch);	// send character to console window
static int winOffHook = 0;
dword ll_dumpchar_timer = 0;
int ll_dumpchar_count;

/****************************************************************
Routine : win_hangup
Description :
    hang up the modem
*****************************************************************/
void win_hangup(void)
{
	x_debug_msg("win_hangup");

	if (x_modem_state != MS_IDLE)
	{
		x_send_mail(MC_DISCONNECT, DP_TASK, 0, 0);
	}
}

//msm// extern BOOL genpat(void);
//msm// extern void points_clear();

/****************************************************************
Routine : ll_periodic
Description :
    periodic operations needed for maintenance of the modem
*****************************************************************/
void ll_periodic(void)
{
//timing_clock_stop();
//timing_clock_start();
        if (firstTime)
	{
		// if the modem hasn't been initialized...
		firstTime = 0;

		dp_regwrite(0xde, 0x01);
		dp_regwrite(0xde, 0x00);

		if (FAILED == UART_init())
		{
			x_debug_msg("Data Pump Failure");
			dpFailure = 1;
		}

#ifdef PODULEBASED
  venusDebugToDTE = 3; //msm//
#endif
	}
	else
	{
                if (winFailure)
		{
			x_debug_msg("winFailure");

			// something failed under windows.
			// Try to hang up if we're off hook.
			if (x_modem_state != MS_IDLE)
			{
				win_hangup();
			}
			else
			{
				winFailure = 0;
			}
		}

		if (!winOffHook && x_modem_state != MS_IDLE)
		{
//msm//			points_clear();
		}
		winOffHook = (x_modem_state != MS_IDLE);


//                if (!dpFailure)
		  dp_task(MC_PERIODIC, 0, 0);

		io_task(MC_PERIODIC, 0, 0);


		// Check to see if input buffer is full enough that
		// we should backpressure incoming characters.
		if ( io_dte_rx_wptr >= io_dte_rx_rptr )
		{
			uart_rx_count = (word) (io_dte_rx_wptr - io_dte_rx_rptr);
		}
		else
		{
			uart_rx_count = (word) ((io_dte_rx_eptr - io_dte_rx_rptr)
				+ (io_dte_rx_wptr - io_dte_rx_sptr));
		}

		if ( uart_rx_count >= IO_DTE_RX_BUFF_FULL )
		{
			UART_cts_off();
		}
		else
		{
			UART_cts_on();
		}

	}
//timing_clock_stop();
//timing_clock_start();
}

// Handle incoming characters from the DTE
// coming towards the modem.
void consoleCharIn(char ch)
{
	if (firstTime || (NULL == io_dte_rx_wptr))
		return;

	*I(io_dte_rx_wptr)++ = ch;
	if ( I(io_dte_rx_wptr) >= I(io_dte_rx_eptr) )
	{
		I(io_dte_rx_wptr) = I(io_dte_rx_sptr) ;
	}
}

/****************************************************************
Routine : ll_periodic
Description :
    shutting down the modem.
*****************************************************************/
void ll_shutdown(void)
{
	if (firstTime)
		return;

//msm//	x_debug_msg("ll_shutdown");

	firstTime = 1;

#if !defined(DRAGNET)
	// back to RMP mode
	_outp(RMPMR, 0);
#endif
}

