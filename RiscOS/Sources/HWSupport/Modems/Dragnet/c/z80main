/*name and version number:@(#)z80main.c	1.229*/
/*date of get: 		  01/10/01 16:57:53*/
/*date of delta:	  12/19/00 09:49:42*/
/****************************************************************
File :	z80main.c
Description :
	Contains the z80 main function.
	Also the uart mimic functions and the mimic interrupt handler.
	Some MIMIC handlers moved to cstartup.asm

Procedures Contained :
	main

Revision History :
	Initials	Date		Change
	VR     		10/12/93	Initial
	RWF			02/04/97	Added DMA in RX direction
	RWF			06/10/97	Added RRFL
*****************************************************************/

#include	"llglob_d.h"
#include	"iouart_d.h"
#include	"ioglob_d.h"
#include	"z80glob.h"
#include    "dpglob.h"
#include    "z80flash.h"
#include	"allglobs.h"

extern void dp_task ( MODEM_COMMAND, byte *, word ) ;
extern void io_task ( MODEM_COMMAND, byte *, word ) ;
extern void pciInit(void), z80_poll_pita(void);
extern byte XOFFchar ;

sfr bank_port=0x39;

#if defined( Z80_MIMIC_DMA ) && defined( TEST_COMMANDS )
//-----------------------------------------------------------------
// Uncomment the following line for state machine debug of DMA
//-----------------------------------------------------------------
//#define	DMA_DEBUG
#endif

#if defined( PCMCIA_MODEM )
//---------------------------------------------------------------
//					PCMCIA
//---------------------------------------------------------------
//-----------------------------------
//		PCMCIA variables
//-----------------------------------
//
byte	last_mimic_cor ;
byte	last_mimic_fcsr ;
byte	last_mimic_prr ;
byte	last_mimic_baselo ;
byte	last_mimic_basehi ;
#if defined(MULTI_FUNCTION)
byte	last_rmp_cor;
byte	last_rmp_fcsr;
byte	last_rmp_prr;
#endif

BOOL	z80_ring_int ;
//
//---------------------------------------------------------------
//				END PCMCIA variables
//---------------------------------------------------------------
#endif

//==========================================================================
//					Globals
//==========================================================================
byte	uart_baud_reg ;
byte	uart_fcr_reg ;
byte	uart_ie_reg ;
byte	uart_lcr_reg ;
byte	uart_mcr_reg ;
byte	last_mcr_reg ;
BOOL	FCR_changed ;
BOOL	MCR_changed ;
BOOL	LCR_changed ;

BOOL	xof_from_dte_rcvd ;

#if defined( Z80_MIMIC_DMA )
BOOL	sendAnXOFF ;
BOOL	z80_no_more_tx ;			// Bool to determine idle Tx to DTE ch.
BOOL	z80_dma_debug ;
BOOL	z80_dma1_stopped ;
byte	*z80_dte_tx_rptr ;
word	z80_max_dma ;
#else
byte	uart_tx_count ;
#endif


/****************************************************************
	Function : timer interrupt - set for 20 msec intervals

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void prt0ir ( void )
{
	x_timer = x_timer + 1 ;		// 1 msec for constellation/debug

#if defined( WATCHDOG_TIMER )
	// strobe sanity timer
	output8( 0xda, 0x1f ) ;
	output8( 0xdb, 0xe5 ) ;
#endif

		// clear interrupt
	input8( TCR );			//read timer 0 control register - reset timers
	input8( TMDR0L );		//read timer 0 data register low
}

/****************************************************************
	Function : mimic FCR interrupt

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void fcrir ( void )
{
	output8( MIMIC_IUS, 0x80 ) ;	// clear interrupt source

	uart_fcr_reg = input8( MIMIC_FCR ) ;
	FCR_changed = TRUE ;
}

/****************************************************************
	Function : mimic LCR interrupt

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void lcrir ( void )
{
	output8( MIMIC_IUS, 0x80 ) ;			// clear interrupt source
	uart_lcr_reg = input8( MIMIC_LCR ) ;	// read line control register
	LCR_changed = TRUE ;
	sendDumbChar('l');
}

/****************************************************************
	Function : MIMIC MCR interrupt

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void mcrir ( void )
{
#if defined(Z80_MIMIC_DMA)
	static byte dstat_reg;
#endif

	output8( MIMIC_IUS, 0x80 ) ;	// clear interrupt source

	uart_mcr_reg = input8(MIMIC_MCR);	// read modem control register

#if defined( Z80_MIMIC_DMA )
		// check for RTS
	if ( (uart_mcr_reg & BIT1) && !(last_mcr_reg & BIT1) )
	{
		//--------------------
		// RTS was just SET
		//--------------------
		if ( z80_dma1_stopped )
		{
			//-----------------------------------------
			// DMA Channel 1 was stopped - restart it.
			//-----------------------------------------
			dstat_reg = input8( DSTAT ) ;
			output8( DSTAT, (dstat_reg & 0xdf) | 0x88 ) ;
			//sendDumbChar( '+' ) ;
			output8 ( DUMB_MCR, input8 ( DUMB_MCR ) | BIT3 ) ;

			z80_dma1_stopped = FALSE ;
		}
	}
	else if ( !(uart_mcr_reg & BIT1) && (last_mcr_reg & BIT1) )
	{
		if ( !z80_dma1_stopped
				&& (S.ModemOptions.FlowControl == HW_FLOWCTRL) )
		{
				// RTS is not set
			if ( !z80_no_more_tx && input8( BCR1L ) > 8 )
			{
				//-------------------------------------------------
				//		DMA on Ch1 is running - stop it!
				//-------------------------------------------------
				// this is a 2 step process:
				//	1) stop both channels, and
				//	2) restart ch0, as appropriate.
				//-------------------------------------------------
				dstat_reg = input8( DSTAT ) ;
				output8( DSTAT, 0x00 ) ;

				z80_dma1_stopped = TRUE ;
				output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & ~BIT3 ) ;
				//sendDumbChar( '-' ) ;

				//-------------------------------------------------
				//	if ch0 was active and BCR0 non zero
				//	then re-activate ch0
				//-------------------------------------------------
				if ( (dstat_reg & 0x40) &&
						(input8( BCR0L ) || input8( BCR0H )) )
				{
					output8( DSTAT, 0x44 ) ;
					//sendDumbChar( '/' ) ;
				}
			}
		}
	}
#else	// not Z80_MIMIC_DMA
	if ((HW_FLOWCTRL == S.ModemOptions.FlowControl) &&
		( !(uart_mcr_reg & BIT1) && (last_mcr_reg & BIT1) ))
	{
		// Hardware flow control and host just turned its
		// RTS off, indicating it doesn't want any more characters.
		// We need to disable the MIMIC RBR interrupt
		// if it isn't already disabled.

		// (Interrupts are already disabled here so we don't
		// have to worry about disabling an interrupt that's
		// halfway in progress. [venus chip bug])
		byte ie = input8(MIMIC_IE);

		output8(MIMIC_IE, ie & MIMIC_RBR_DISABLE);

		// debug just to see if we're toggling
		sendDumbChar('B');
	}

#endif

	//----------------------------------------------------
	// preclude RTS changes from reporting to task
	//----------------------------------------------------
	if ( (last_mcr_reg & ~BIT1) != (uart_mcr_reg & ~BIT1) )
	{
			// set BOOLEAN for task
		MCR_changed = TRUE ;

	}
	last_mcr_reg = uart_mcr_reg ;

	// ralph - please don't put this in sccs
//	sendDumbChar('m');
}

/****************************************************************
	Function : mimic interrupt - no irq int.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void mimicir ( void )
{
	output8( MIMIC_IUS, 0x80 ) ;	// clear interrupt source
	sendDumbChar('i');
}

/****************************************************************
	Function : dll/dlm interrupt - only action here is to clear
	the interrupt.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void dllir ( void )
{
	byte scratch;

	output8( MIMIC_IUS, 0x80 ) ;	// clear interrupt source
	scratch = input8( MIMIC_DLL ) ;
	scratch = input8( MIMIC_DLM ) ;
	sendDumbChar('D');
}

#if defined( PCMCIA_MODEM )
/****************************************************************
	Function : attribute Memory write interrupt

		CALLED WITH INTERRUPTS DISABLED!
	Note: This ISR handles Host configuration in real-time.  It
	was found in OSR2 that the PC resets the PC Bus each time
	an application addresses the modem.  There is now (with
	table decompression added) too much overhead before we start
	polling the FCRs, so until we start polling in the background,
	we will run interrupt mode.
*****************************************************************/
non_banked
interrupt void attmwrtir ( void )
{
	extern non_banked void Attribute_memory_write ( void ) ;

	// process any host attribute memory writes
	Attribute_memory_write( ) ;
}

/****************************************************************
	Function : attribute Memory Access interrupt

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void attmaccir ( void )
{
	//------------------------------
	// Disable Attmem access interupts
	//------------------------------
	WRITE_CAMILZ( 0x56, BIT3 ) ;

	//-------------------------------------------------------
	// this routine doesn't have to do much for it is only a
	// target for sleep revival.
	//-------------------------------------------------------
	sendDumbChar( 'A' ) ;
}
#endif

/*****************************************************************
	Function : venus_wake_from_sleep
	Wake up from sleep for Venus.
******************************************************************/
non_banked void venus_wake_from_sleep(void)
{
	// restore CPUSTOP & clk divisors
	output8 ( CKSRC, input8 ( CKSRC ) & 0xD8 ) ;
	// restore codec & bamil clocks 
	dp_regwrite ( 0xcb, 0x00 ) ;// and crystal oscillator 
	Oscr_delay () ;				// allow to stabilize

	output8 ( IOBRG, input8 ( IOBRG ) | 0x01 );	// restore MIM_TCLK
	output8 ( IOCR, input8 ( IOCR ) & 0x00 ); 	// restore EASCI,PRT,RMP,DMAC
	output8 ( CKSRC, input8 ( CKSRC ) & 0xF7 );	// switch to crystal osc.

	output8 ( TCR, input8 ( TCR ) | 0x10 ) ; // enable Timer0 interrupt
	output8 ( TCR, input8 ( TCR ) | TCR_TDE0_BIT ) ; // start Timer0
	enable_interrupt () ;

	dp_venus_wakeup();
}

/*****************************************************************
	Function : x_sleep_mode
	Put the uC into sleep mode.
******************************************************************/
non_banked byte x_sleep_mode ( void )
{
	extern byte dp_count ;
	extern void dp_reset_venus(void);

	sendDumbChar( 'S' ) ;

	disable_interrupt () ;
		// Can we go to sleep ?
		if ( dp_ring_int || (io_dte_rx_wptr != io_dte_rx_rptr) )
		{
			// No...
			enable_interrupt () ;
			if ( dp_ring_int )
			{
				ddputs_nnl( "Ring Active" );
			}
			else
			{
				ddputs_nnl( " Incoming chars..." );
			}
			ddputs_nnl( " w \n\r" );
			return TRUE ;
		}

#if defined( Z80_MIMIC_DMA )
		//----------------------------------------------
		// If we still have more to send to the host but
		// they have gone away (Toshiba Techra does this
		// when you close Hyperterm) then clear the DMA
		// channel and go to sleep.
		//----------------------------------------------
		if ( !z80_no_more_tx && !(uart_mcr_reg & BIT0) )
		{
			extern void init_z80_DMA ( void ) ;

			init_z80_DMA() ;
			z80_no_more_tx = TRUE ;
			ddputs_nnl( "Clearing DMA\n\r" );
		}
#endif

		//------------------------------
		// Place Datapump in sleep mode
		//------------------------------
		dp_state = DP_WAIT_FOR_RING ;
		dp_count = 0 ;
		dp_calling_tone_disable = FALSE ;
		dp_sleep_mode (1) ;

#if defined( PCMCIA_MODEM )
		//----------------------------------------------
		// Enable all Attribute Memory Access interupts
		//----------------------------------------------
		dp_regwrite( 0x56, BIT3|BIT2|BIT1|BIT0 ) ;
#endif
		//---------------------------------------------
		// stop Timer0 and disable Timer0 interrupt
		//---------------------------------------------
		output8 ( TCR, input8 ( TCR ) & ~TCR_TDE0_BIT ) ;
		output8 ( TCR, input8 ( TCR ) & 0xEF ) ;

	enable_interrupt () ;
	sleep () ;					// put Zinger into sleep mode
	disable_interrupt () ;

		//---------------------------------------------
		// enable Timer0 interrupt and start Timer0
		//---------------------------------------------
		output8 ( TCR, input8 ( TCR ) | 0x10 ) ;
		output8 ( TCR, input8 ( TCR ) | TCR_TDE0_BIT ) ;

#if defined( PCMCIA_MODEM )
		//----------------------------------------------
		// Disable all Attribute Memory Access interupts
		//----------------------------------------------
//		dp_regwrite( 0x56, 0 ) ;
		dp_regwrite( 0x56, BIT3 ) ;
#endif
		// restore CPUSTOP & clk divisors
		output8 ( CKSRC, input8 ( CKSRC ) & 0xD8 ) ;
		// restore codec & bamil clocks 
		dp_regwrite ( 0xcb, 0x00 ) ;// and crystal oscillator 
		Oscr_delay () ;				// allow to stabilize

		output8 ( IOBRG, input8 ( IOBRG ) | 0x01 ) ;	// restore MIM_TCLK
		output8 ( IOCR, input8 ( IOCR ) & 0x00 ) ; 	// restore EASCI,PRT,RMP,DMAC
		output8 ( CKSRC, input8 ( CKSRC ) & 0xF7 ) ;	// switch to crystal osc.
	enable_interrupt () ;

	sendDumbChar( 'W' ) ;
	return TRUE ;
}

/****************************************************************
	Function : z80_flow_on
	used by voice isr in z80dsp.c file 
	we may need to turn cts off during voice block transfer
*****************************************************************/
non_banked void z80_flow_on ( void )
{
}

/****************************************************************
	Function : z80_uart_break_on
*****************************************************************/
non_banked void z80_uart_break_on ( void )
{
		// set break interrupt
	output8 ( MIMIC_LSR, input8 ( MIMIC_LSR ) | BIT4 ) ;
	output8 ( MIMIC_RBR, 0x00 ) ;
}

/****************************************************************
	Function : z80_uart_cts_on
*****************************************************************/
non_banked void z80_uart_cts_on ( void )
{
		// set CTS
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) | BIT4 ) ;
}

/****************************************************************
	Function : z80_uart_cts_off
*****************************************************************/
non_banked void z80_uart_cts_off ( void )
{
		// clear CTS
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) & ~BIT4 ) ;
}

/****************************************************************
	Function : z80_uart_cd_on
*****************************************************************/
non_banked void z80_uart_cd_on ( void )
{
		// set DCD
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) | BIT7 ) ;
}

/****************************************************************
	Function : z80_uart_cd_off
*****************************************************************/
non_banked void z80_uart_cd_off ( void )
{
		// clear DCD
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) & ~BIT7 ) ;
}

/****************************************************************
	Function : z80_uart_dsr_on
*****************************************************************/
non_banked void z80_uart_dsr_on ( void )
{
		// set RI
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) | BIT5 ) ;
}

/****************************************************************
	Function : z80_uart_dsr_off
*****************************************************************/
non_banked void z80_uart_dsr_off ( void )
{
		// clear RI
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) & ~BIT5 ) ;
}
 
/****************************************************************
	Function : z80_uart_ri_on
*****************************************************************/
non_banked void z80_uart_ri_on ( void )
{
		// set RI
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) | BIT6 ) ;
}

/****************************************************************
	Function : z80_uart_ri_off
*****************************************************************/
non_banked void z80_uart_ri_off ( void )
{
		// clear RI
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) & ~BIT6 ) ;
}

/****************************************************************
	Function : z80_dte_rx_count
	return the number of bytes on the dte receive queue
    Note the side effect of setting uart_rx_count.
*****************************************************************/
non_banked void z80_dte_rx_count ( void )
{
	// disable all interrupts - before calculating no of bytes in queue
	disable_interrupt () ;
		if ( io_dte_rx_wptr >= io_dte_rx_rptr )
		{
			uart_rx_count = io_dte_rx_wptr - io_dte_rx_rptr ;
		}
		else
		{
			uart_rx_count = (io_dte_rx_eptr - io_dte_rx_rptr)
							 + (io_dte_rx_wptr - io_dte_rx_sptr) ;
		}
	enable_interrupt () ;
}

#if defined( Z80_MIMIC_DMA )
/****************************************************************
	Function : z80_SendXOFF
	send a single XOFF char to the DTE

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_SendXOFF ( void )
{
	//----------------------------------------------------
	//	save current dte read ptr
	//----------------------------------------------------
//	z80_dte_tx_rptr = io_dte_tx_rptr ;

	//-------------------------------------------------
	//		load the starting address
	//-------------------------------------------------
	output8( MAR1B, (byte)0 ) ;
	output8( MAR1H, (byte)((word)&XOFFchar >> 8) ) ;
	output8( MAR1L, (byte)&XOFFchar ) ;

	//-------------------------------------------------
	//		load the count
	//-------------------------------------------------
	output8( BCR1L, 1 ) ;

	//-------------------------------------------------
	//		Start the DMA and enable CH1 interrupt.
	//-------------------------------------------------
	output8( DSTAT, 0x98 ) ;

	//-------------------------------------------------
	//		clear the boolean to allow regular data
	//		to be sent (e.g an XON char).
	//-------------------------------------------------
	sendAnXOFF = FALSE ;
}

/****************************************************************
	Function : z80_start_dma
	Calculates the number of contiguous bytes available to send
	to the Host and sets up and starts the Channel 1 DMA transfer.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_start_dma ( void )
{
	word count ;

	//-------------------------------------------------
	//		load the starting address
	//-------------------------------------------------
	output8(MAR1B, (byte)(CBR_REG >> 4));
	output8(MAR1H, (byte)((word)io_dte_tx_rptr >> 8));
	output8(MAR1L, (byte)io_dte_tx_rptr ) ;

	//-------------------------------------------------
	//		load the count
	//-------------------------------------------------
	if ( io_dte_tx_wptr > io_dte_tx_rptr )
	{
		//---------------------------------------------
		// all bytes available are contiguous
		//---------------------------------------------
		count = io_dte_tx_wptr - io_dte_tx_rptr ;
		if ( count > z80_max_dma )
		{
			//---------------------------------------------
			// send only z80_max_dma bytes at a time. this
			// allows the io_dte_tx_rptr to be updated faster
			//---------------------------------------------
			count = z80_max_dma ;
			z80_dte_tx_rptr = io_dte_tx_rptr + z80_max_dma ;
#if defined( DMA_DEBUG )
			if ( z80_dma_debug ) sendDumbChar( '1' ) ;
#endif
		}
		else
		{
			z80_dte_tx_rptr = io_dte_tx_wptr ;
#if defined( DMA_DEBUG )
			if ( z80_dma_debug ) sendDumbChar( '2' ) ;
#endif
		}
	}
	else
	{
		//---------------------------------------------
		// bytes available are non-contiguous
		// just get the upper bytes this time.
		//---------------------------------------------
		count = io_dte_tx_eptr - io_dte_tx_rptr ;
		if ( count > z80_max_dma )
		{
			count = z80_max_dma ;
			z80_dte_tx_rptr = io_dte_tx_rptr + z80_max_dma ;
#if defined( DMA_DEBUG )
			if ( z80_dma_debug ) sendDumbChar( '3' ) ;
#endif
		}
		else
		{
			z80_dte_tx_rptr = io_dte_tx_sptr ;
#if defined( DMA_DEBUG )
			if ( z80_dma_debug ) sendDumbChar( '4' ) ;
#endif
		}
	}

	output8( BCR1L, (byte)count ) ;

	//-------------------------------------------------
	//		Start the DMA and enable CH1 interrupt.
	//-------------------------------------------------
	output8( DSTAT, 0x98 ) ;
}

/****************************************************************
	Function : dma1ir
	This is the ISR for the DMA Channel 1. It is vectored to
	at the end of a DMA transfer.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void dma1ir ( void )
{
	//----------------------------------------------------
	//	adjust read ptr to reflect just completed DMA
	//----------------------------------------------------
	io_dte_tx_rptr = z80_dte_tx_rptr ;

	//-------------------------------------------------
	//	XOFF Control char to send?
	//-------------------------------------------------
	if ( sendAnXOFF )
	{
		z80_SendXOFF() ;
#if defined( DMA_DEBUG )
		if ( z80_dma_debug ) sendDumbChar( 'x' ) ;
#endif
	}

	//-------------------------------------------------
	//	More data to send?
	//-------------------------------------------------
	else if ( (io_dte_tx_wptr != io_dte_tx_rptr)
		&& (((S.ModemOptions.FlowControl == HW_FLOWCTRL) &&
				(input8( MIMIC_MCR ) & BIT1))
			|| ((S.ModemOptions.FlowControl == SW_FLOWCTRL) &&
				!(xof_from_dte_rcvd))) )
	{
#if defined( DMA_DEBUG )
		if ( z80_dma_debug ) sendDumbChar( 'i' ) ;
#endif
		z80_start_dma() ;
	}
	else
	{
		//-------------------------------------------------
		//	stop the DMA on Channel 1
		//-------------------------------------------------
		output8( DSTAT, 0x10 ) ;

		z80_no_more_tx = TRUE ;
#if defined( DMA_DEBUG )
		if ( z80_dma_debug )
		{
			ddputs_nnl( "n\r\n" ) ;
		}
#endif
	}
}
#endif

/****************************************************************
	Function : z80_pc_flow_control
	Flow control to the pc - called from THR interrupt 
	Turn Off Cts or send xoff to the PC
        
		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_pc_flow_control ( void )
{
	{
		if ( S.ModemOptions.FlowControl == HW_FLOWCTRL )
		{
			uart_flow_control = FC_ON ;
			z80_uart_cts_off() ;
			//sendDumbChar( 'c' ) ;
		}
		else if ( S.ModemOptions.FlowControl == SW_FLOWCTRL )
		{
#if defined( Z80_MIMIC_DMA )
			//-------------------------------------------------
			// send xoff to the pc using ch1 DMA
			//-------------------------------------------------
			if ( z80_no_more_tx )
			{
				z80_no_more_tx = FALSE ;
				z80_SendXOFF() ;
			}
			else
			{
				sendAnXOFF = TRUE ;
				sendDumbChar( '.' ) ;
			}
			uart_flow_control = FC_ON ;
#else
			// send xoff to the pc - later in the background
			uart_flow_control = FC_OFF_TO_ON ;
#endif
			sendDumbChar( 'x' ) ;
		}
#if defined(UART_DEBUG_PRINT)
		if ( dumbPortPresent )
		{
			output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & ~BIT3 );
		}
#endif
	}
}

/****************************************************************
	Function : z80_swfc_on
	XOFF received from DTE: Set flag to stop sending to DTE
	(SW equiv. of RTS OFF)

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_swfc_on ( void )
{
	// XOFF has just been received from the DTE!!
	xof_from_dte_rcvd = TRUE ;
#if defined(UART_DEBUG_PRINT)
	if ( dumbPortPresent )
		output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & ~BIT2 ) ;
	sendDumbChar( 's' ) ;
#endif
}

/****************************************************************
	Function : z80_swfc_off
	XON received from DTE: Clear flag to allow sending to DTE
	For DMA mode, allow dma stream again.
	(SW equiv. of RTS ON)

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_swfc_off ( void )
{
	// XON has just been received from the DTE!!
	xof_from_dte_rcvd = FALSE ;
#if defined( UART_DEBUG_PRINT )
	if ( dumbPortPresent )
		output8 ( DUMB_MCR, input8 ( DUMB_MCR ) | BIT2 ) ;
		sendDumbChar( 'S' ) ;
#endif
}

#if defined( PCMCIA_MODEM )
/****************************************************************
	Function : COR_update
	Device Configuration Option Register has been updated

	CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
void COR_update ( byte device, byte cor )
{
	static byte index ;
	byte prr, bafcr ;
	word baddr ;

	// was it a device reset?
	if ( cor & COR_SRESET_BIT )
	{
		word i ;

		//------------------------------------
		// Yes - device has been reset!!
		// wait for host to clear this bit..
		//------------------------------------
		i = 0;
		while ( (cor & COR_SRESET_BIT) &&
				(i < 0xfff0) )
		{
			cor = READ_CAMILZ( device ) ;
			i++ ;
		}
		// ..and pull the plug
		// reset VENUS - NOT device!!!
		ddputs_nnl( "*** RESET ****\r\n" ) ;
		WRITE_CAMILZ( 0x57, 2 ) ;
		// should not get here
	}

	// get the index to the CIS config table entry and
	// program the I/O Base address.
	index = (cor & COR_INDEX_BITS) >> 3 ;
	switch ( device )
	{
		case 0x40:	// MIMIC
			ddputs_nnl("MIMIC");
			bafcr = 0xc3 ;
			break ;
#if defined( MULTI_FUNCTION )
		case 0x43:	// RMP
			ddputs_nnl("RMP");
			index |= 0x10 ;
			bafcr = 0xc5 ;
			break ;
		default :
			ddputs_nnl("????");
#endif
	}
	ddputs_nnl( " index = " ) ; sendHexByte( index ) ;

	baddr =  z80_base_adr ( index ) ;
	WRITE_CAMILZ( bafcr,   (byte)baddr ) ;
	WRITE_CAMILZ( bafcr+1, (byte)(baddr >> 8) ) ;

	ddputs_nnl( "; LO = " ) ; sendHexByte( (byte)baddr ) ;
	ddputs_nnl( "; HI = " ) ; sendHexByte( (byte)(baddr >> 8) ) ;
	sendDumbChar(0x0A); sendDumbChar(0x0D);

	// Set the Pin Replacement Register
	// WP=0, Ready, BVD1=BVD2=1
	// For now, READY is always set.
	prr = 0x0e ;
	WRITE_CAMILZ( device+2, prr ) ;

#if defined( MULTI_FUNCTION )
	// If multiple devices are supported on the card
	// then Set the int sharing bits in the FCSR.
	WRITE_CAMILZ( device+1, READ_CAMILZ( device+1 ) | 1 ) ;
#endif

	ddputs_nnl( "COR = " ) ; sendHexByte( cor ) ;
	sendDumbChar(0x0A); sendDumbChar(0x0D);
}

/****************************************************************
	Function : FCSR_update
	Device Configuration Option Register has been updated
*****************************************************************/
non_banked void FCSR_update ( byte device, byte fcsr )
{
	//--------------------------------------------------------------------
	//		Function Cofiguration & Status Register
	//--------------------------------------------------------------------
	// Report function for now.
	// Bits of concern in this register include:
	//	bit0:	IntrAck	- Set to 1 for interrupt sharing on MF PC Cards.
	//					  (done in COR_update).
	//	bit1:	Intr	- Interrupt pending bit (cleared by interrupting
	//					  HW in SF; host in MF).
	//	bit2:	PwrDown	- Set by host when a power down mode is desired.
	//	bit3:	Audio	- Enables audio output onto pin 62 of PC Card Bus.
	//	bit4:			- Unused
	//	bit5:	IOis8	- Set by host for 8 bit xfers only.
	//	bit6:	SigChg	- Set by host to enable STSCHG# pin on PC Bus.
	//	bit7:	Changed	- Set by HW if CREADY in the PRR is set.
	//--------------------------------------------------------------------
	if ( fcsr & BIT2 )
	{
		ddputs( "Power Down Mode Requested by Host!!" ) ;
	}

	if ( fcsr & BIT5 )
	{
		ddputs( "Host has 8 bit bus." ) ;
	}

	if ( fcsr & BIT6 )
	{
		ddputs( "Host has Enable SigChg!" ) ;
	}

	ddputs_nnl( "FCSR = " ) ; sendHexByte( fcsr ) ;
	sendDumbChar(0x0A); sendDumbChar(0x0D);
}

non_banked
void SaveCOR ( void )
{
	extern byte corFlag ;
	extern byte corValue ;

	ddputs_nnl( "saving COR\n\r" ) ;
	corFlag = 0x55 ;
	corValue = last_mimic_cor ;
}

// called with interrupts disabled at initialization time
non_banked
void LoadCOR ( void )
{
	extern byte corFlag ;
	extern byte corValue ;

	ddputs_nnl( "corFlag = " ) ;
	sendHexByte( corFlag ) ;
	ddputs_nnl( "; corValue = " ) ;
	sendHexByte( corValue ) ;
	ddputs_nnl( "\n\r" ) ;
	if ( corFlag == 0x55 )
	{
		corValue &= ~COR_SRESET_BIT ;
		dp_regwrite( 0x40, corValue ) ;
		dp_regwrite( 0x42, 0xee ) ;
		COR_update( 0x40, corValue ) ;
	}
}

/****************************************************************
	Function : Attribute_memory_write
		Process the host Attribute Memory (FCRs and CIS) writes.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
void Attribute_memory_write ( void )
{
	byte camilreg;

	// check the MIMIC COR
	camilreg = READ_CAMILZ( 0x40 ) ;
	if ( last_mimic_cor != camilreg )
	{
		COR_update( 0x40, camilreg ) ;
		last_mimic_cor = camilreg ;
		SaveCOR () ;
	}

	// check the MIMIC FCSR
	camilreg = READ_CAMILZ( 0x41 ) ;
	if ( last_mimic_fcsr != camilreg )
	{
		FCSR_update( 0x41, camilreg ) ;
		last_mimic_fcsr = camilreg ;
	}

	// check the MIMIC PRR
	camilreg = READ_CAMILZ( 0x42 ) ;
	if ( last_mimic_prr != camilreg )
	{
		ddputs_nnl( "M PRR = " ) ;
		sendHexByte( camilreg ) ;
		ddputs_nnl( "\n\r" ) ;
		last_mimic_prr = camilreg ;
	}

#if defined( MULTI_FUNCTION )
	// check the RMP COR
	camilreg = READ_CAMILZ( 0x43 ) ;
	if ( last_rmp_cor != camilreg )
	{
		COR_update( 0x43, camilreg ) ;
		last_rmp_cor = camilreg ;
	}

	// check the RMP FCSR
	camilreg = READ_CAMILZ( 0x44 ) ;
	if ( last_rmp_fcsr != camilreg )
	{
		FCSR_update( 0x44, camilreg ) ;
		last_rmp_fcsr = camilreg ;
	}

	// check the RMP PRR
	camilreg = READ_CAMILZ( 0x45 ) ;
	if ( last_rmp_prr != camilreg )
	{
		ddputs_nnl( "RMP PRR = " ) ;
		sendHexByte( camilreg ) ;
		sendDumbChar(0x0A); sendDumbChar(0x0D);
		last_rmp_prr = camilreg ;
	}
#endif
}
#endif //defined(PCMCIA_MODEM)

#if defined (K56FLEX) || defined (VPCM_CLIENT) || defined (VPCM_SERVER)
#if defined(TEST_COMMANDS) && defined(MORE_MORE_DEBUG)
/****************************************************************
	Function : z80_display_ext_ram
	support routine for z80_memory
*****************************************************************/
non_banked
void z80_display_ext_ram ( byte DestBank, byte max, byte *loc )
{
	byte i, cnt, *bp, data, str[120];
	extern const byte str_convert[] ;
	byte bankvar;
	byte *BankDataPtr;

	for ( i=0, bp=str, cnt=0; i<max; i++, cnt++ )
	{
		if ( !(cnt % 16) )
		{
			*bp++ = S.ModemOptions.CRChar;
			*bp++ = S.ModemOptions.LFChar;
			*bp++ = 0 ;
			ddputs_nnl( str ) ;
			{
				x_send_mail ( AT_IO_DATA, IO_TASK, str, bp - str ) ;
			}
			cnt = 0 ;
			str[0]  = str_convert[  (byte)(((word)loc & 0xF000)>>12) ] ;
			str[1]  = str_convert[  (byte)(((word)loc & 0xF00)>>8) ] ;
			str[2]  = str_convert[  (byte)(((word)loc & 0xF0)>>4) ] ;
			str[3]  = str_convert[  (byte)((word)loc & 0xF) ] ;
			str[4]  = ':' ;
			str[5]  = ' ' ;
			bp = &str[6] ;
		}
		bankvar = bank_port;	// save old bank pointer
		bank_port=DestBank;
		data =  *loc++ ;
		bank_port = bankvar;		// restore bank pointer		
		*bp++ = str_convert[ ((data>>4) & 0xf) ];
		*bp++ = str_convert[ (data & 0xf) ];
		*bp++ = ' ' ;
	}

	*bp++ = S.ModemOptions.CRChar;
	*bp++ = S.ModemOptions.LFChar;
//#if defined( Z80_DEBUG_PRINT )
	
		*bp++ = 0 ;
		ddputs_nnl( str ) ;
	
	
//#endif
	{
		x_send_mail ( AT_IO_DATA, IO_TASK, str, bp - str ) ;
	}
}
#endif
#endif //K56FLEX || VPCM_CLIENT || VPCM_SERVER

extern void init_z80_hardware(void);
extern void mimic_control_registers(void);
extern void z80_init_dtr ( void );

/************** Digital Operation Setup *************/
#if defined(CS_DIGITAL)
non_banked void cs_init_digital(void)
{

	/*1.Increase DSP internal clock speed to > 51.5MHz*/
	/*  Setup PLL for 53.0842MHz. (this is done in dp_venus_wakeup()) */
//	dp_modem_command_long ( 0x2e , 0x01, 0x3d, 0x70, 0 ) ;

	/*2.Setup 0x826 (options) */

	//10   :00=16bits, 11=8bits
	//5-2  :reserved
	//6    :0=LSB first, 1=MSB first
	//9-7  :reserved
	//10   :0=u-law, 1=a-law
	//11   :0=SIO1, 1=SIO2
	//12   :0=B1, 1=B2
	//15-13:reserved
#if defined(ALAW_FORCED)
	dp_write_dsp_ram(0x826, 0x0440);
#else
	if (S.ModemOptions.DigitalLoss56K & 1)
	{
		x_debug_msg("dp - A-law");
		dp_write_dsp_ram(0x826, 0x0440);
	}
	else
	{
		x_debug_msg("dp - u-law");
		dp_write_dsp_ram(0x826, 0x0040);
	}
#endif

	/*3.Set to modem I/O */
    dp_write_dsp_ram ( 0x102f, 0x00 ) ;

	/*4.Enable ISDN emulation */
    dp_write_dsp_ram ( 0x102e, 0x02 ) ;//Digital mode 8Ksamples

	/*5.Enable NEC (CS/RAM827=0x80) after issuing startup.
	  Performed in DPCNTL.C (dp_originate/answer_cmd)   */

}		
#endif		

#if defined( PCMCIA_MODEM ) && defined( DIA_MODE )

BOOL RMPFlag ;

non_banked
void rmpCapture ( void )
{
	byte reg ;

	ddputs_nnl( "Switching MIMIC port to RMP\n\r" ) ;

	//--------------------------------------------
	// read the MIMIC Base Address register
	// and write it to the RMP BAR.
	//--------------------------------------------
	reg = dp_regread( 0xc3 ) ;
	dp_regwrite( 0xc5, reg ) ;
	reg = dp_regread( 0xc4 ) ;
	dp_regwrite( 0xc6, reg ) ;

	//--------------------------------------------
	// read the MIMIC FCRs
	// and write to RMP FCRs
	//--------------------------------------------
	reg = dp_regread( 0x40 ) ;
	dp_regwrite( 0x43, reg ) ;
	reg = dp_regread( 0x41 ) ;
	dp_regwrite( 0x44, reg ) ;
	reg = dp_regread( 0x42 ) ;
	dp_regwrite( 0x45, reg ) ;

	//--------------------------------------------
	// clear the MIMIC FCRs
	//--------------------------------------------
	dp_regwrite( 0x40, 0 ) ;
	dp_regwrite( 0x41, 0 ) ;
	dp_regwrite( 0x42, 0 ) ;

	//--------------------------------------------
	// Now clear the MIMIC Base Address register
	//--------------------------------------------
	dp_regwrite( 0xc3, 0 ) ;
	dp_regwrite( 0xc4, 0 ) ;
}
#endif

extern void pciInit(void);

/****************************************************************
	Function : Main
*****************************************************************/
non_banked void main ( void )
{
#if defined(INT_MODEM) && !defined( COMM_DECODE )
	extern BOOL venusPnPCheck( void ) ;
#endif

	// init non-zero variables
#if defined( Z80_MIMIC_DMA )
	z80_max_dma = Z80_MAX_HW_DMA ;
	z80_no_more_tx = TRUE ;
	sendAnXOFF = FALSE ;
#if defined( DMA_DEBUG )
	z80_dma_debug = TRUE ;
#endif
#else
	uart_tx_count = 1 ; 		// mimic - dte transmit data count
#endif
	uart_flow_control = FC_OFF ;

	enableDumbPort();

#if defined(PCMCIA_MODEM)
	ddputs_nnl( "CIS init\n\r" ) ;
	z80_cis_load() ;
	LoadCOR () ;
	//----------------------------------------------
	// Enable FCR Attribute Memory Write interupts
	//----------------------------------------------
	dp_regwrite( 0x56, BIT3 ) ;
#endif
#if defined(PCI_MODEM)
	pciInit();	// initialize Pita things
#endif

	// This is here as a result of the CNTL-ALT-DEL
	// problem with certain BIOS's that caused us to
	// reset in Plug and Play mode
	venus_wake_from_sleep();

	ddputs_nnl( "HW init\n\r" ) ;
	init_z80_hardware () ;					// init Z80 peripheral's

#if defined(INT_MODEM) && !defined( COMM_DECODE )
	// Check the PnP Structure integrity
	if ( !venusPnPCheck() )
	{
		//----------------------------------------------
		// PnP Structure integrity is corrupted
		// fall back to non-fugu mode
		//----------------------------------------------
		ddputs_nnl( "Fugu PnP structure is corrupt\n\r" ) ;
		dp_regwrite( 0xde, dp_regread( 0xde ) | 0x40 ) ;
	}
#endif

#if !defined( ROM_FLASH ) && defined( ROM )
	if ( z80_checksum ( FALSE ) == FALSE )	// rom checksum test
	{
		ddputs_nnl( "ROM Failure\n\r" ) ;
//		fatal_error ( "Rom Failure" ) ;
	}
#endif

	ddputs_nnl( "UART_init\n\r" ) ;
	if ( UART_init () == FAILED )           // init modem task - variables
	{
		ddputs("DataPump Failure\n");
		fatal_error ( "Data Pump Failure" ) ;
	}

#if defined(CS_DIGITAL)
	cs_init_digital();
#endif

	z80_init_dtr();

	// For venus2, switch to digital PLL for faster clock rate.
	z80_start_dpll();

	while ( 1 )           		      // forever loop
	{
		// call the modem background tasks
		// {send mail to} execute periodic routines
		dp_task ( MC_PERIODIC, NULL, 0 ) ;
		io_task ( MC_PERIODIC, NULL, 0 ) ;

		//---------------------------------------------------
		// START UART MIMIC PROCESSING
		//---------------------------------------------------

		//---------------------------------------------------
		// set software flow control - used in cstartup.asm
		// see mimic thr interrupt
		//---------------------------------------------------
		if ( (S.ModemOptions.FlowControl == SW_FLOWCTRL) &&
		 	 (x_modem_mode == MODEM_DATA) &&
			 (x_modem_state == MS_ON_DIAL) &&
			 (io_at_esc_detect == FALSE) )
		{
#if defined( Z80_MIMIC_DMA )
				//---------------------------------------------------
				// set SW FC dma packet size for "to-host" direction.
				//---------------------------------------------------
				z80_max_dma = Z80_MAX_SW_DMA ;
#endif
#if defined( Z80_DEBUG_PRINT )
			if ( !z80_sw_flow_on )
			{
				ddputs_nnl("\n\rEntering SW FC\n\r");
			}
#endif
			z80_sw_flow_on = TRUE ;
		}
		else
		{
#if defined( Z80_MIMIC_DMA )
				//---------------------------------------------------
				// set HW FC dma packet size for "to-host" direction.
				//---------------------------------------------------
				z80_max_dma = Z80_MAX_HW_DMA ;
#endif
#if defined( Z80_DEBUG_PRINT )
			if ( z80_sw_flow_on )
			{
				ddputs_nnl("\n\rExiting SW FC\n\r");
			}
#endif
			z80_sw_flow_on = FALSE ;
			xof_from_dte_rcvd = FALSE ;
		}

		z80_dte_rx_count() ;
		if ( uart_flow_control == FC_OFF )
		{
			// set mimic interrupt enable register
			uart_ie_reg = MIMIC_THR_ENABLE | MIMIC_FCR_ENABLE
						| MIMIC_LCR_ENABLE | MIMIC_MCR_ENABLE
						| MIMIC_DLL_ENABLE ;

			z80_check_stall();	// check to see if we're stuck with CTS ON
		}
		else
		{
			uart_ie_reg = MIMIC_FCR_ENABLE | MIMIC_DLL_ENABLE
						| MIMIC_LCR_ENABLE | MIMIC_MCR_ENABLE ;
#if !defined( Z80_MIMIC_DMA )
			if ( uart_flow_control == FC_OFF_TO_ON )
			{
				// Too many chars rcvd from host - apply back pressure
				// in the form of an XOFF (we are in software flow control).
				io_put_dte_tx_char ( XOFF ) ; 	// XOFF to host - 0x13
				uart_flow_control = FC_ON ;
			}
			else
#endif
				// Assertion => uart_flow_control = FC_ON
			if ( uart_rx_count <= IO_DTE_RX_BUFF_EMPTY )
			{
				// IF the DTE IS currently being back pressured AND
				// we now have room in our input buffer THEN undo it!!!
				z80_flow_off();
				uart_ie_reg = MIMIC_THR_ENABLE | MIMIC_FCR_ENABLE
							| MIMIC_LCR_ENABLE | MIMIC_MCR_ENABLE
							| MIMIC_DLL_ENABLE ;
			}
		}

		//==============================================
		// IF there is data to transmit to the DTE AND
		//   the send side of the MIMIC is IDLE
		// THEN look to restart the RX side of MIMIC.
		//==============================================
		if (
#if defined( Z80_MIMIC_DMA )
				z80_no_more_tx  &&
#endif
				(io_dte_tx_rptr != io_dte_tx_wptr) )
		{
			//=================================================
			// IF on-line AND the DTE has entered flow-control
			// THEN do NOT restart transmiting data to the DTE
			//=================================================
			if ( ((S.ModemOptions.FlowControl == HW_FLOWCTRL) &&
					(input8( MIMIC_MCR ) & BIT1))
				|| io_state < IO_ONLINE
				|| io_at_esc_detect
				|| ((S.ModemOptions.FlowControl == SW_FLOWCTRL) &&
					!(xof_from_dte_rcvd))
				|| (S.ModemOptions.FlowControl == NO_FLOWCTRL) )
			{
#if defined( Z80_MIMIC_DMA )
#if defined( DMA_DEBUG )
				if ( z80_dma_debug ) sendDumbChar( 'z' ) ;
#endif
				// restart DMA on ch1
				disable_interrupt();
					z80_no_more_tx = FALSE ;
					z80_start_dma() ;
				enable_interrupt();
#else
				// enable RBR interrupt
				uart_ie_reg |= MIMIC_RBR_ENABLE ;
#endif
			}
		}

		// The disable/enable interrupts around this are
		// a workaround for VENUS.  When this write to
		// the MIMIC IE on VENUS is interrupted there's
		// a problem.
		disable_interrupt();
			// write to mimic interrupt enable register
			output8 ( MIMIC_IE, uart_ie_reg ) ;
		enable_interrupt();

		// check if any uart mimic control registers changed
		mimic_control_registers () ;

		// END UART MIMIC PROCESSING

#if defined(PCI_MODEM)
		z80_poll_pita();
#endif

#if defined( PCMCIA_MODEM )
		//-------------------------------------------------------
		// It appears that Venus sometimes fails to interrupt us
		// on attribute memory writes, so we continue to poll
		// as long as we're in idle state.
		//-------------------------------------------------------
		z80_poll_pcmcia();

#if defined( DIA_MODE )
		// commandeer the MIMC port for RMP
		if ( (RMPFlag == TRUE) && (input8( 0xf7 ) == 0x55) )
		{
			RMPFlag = FALSE ;
			rmpCapture () ;
			disable_interrupt() ;
			while ( TRUE )
			{
#if defined( WATCHDOG_TIMER )
				// strobe sanity timer
				output8( 0xda, 0x1f ) ;
				output8( 0xdb, 0xe5 ) ;
#endif // WATCHDOG
			}
		}
#endif // DIA_MODE
#endif // PCMCIA_MODEM
	}
}

