/*name and version number:@(#)v_xchg.c	1.18*/
/*date of get: 		  09/06/00 16:59:30*/
/*date of delta:	  05/10/00 14:58:17*/
/*****************************************************************************
** File        : v_xchg.c                                                    *
** Version     : 3.0                                                         *
**---------------------------------------------------------------------------*
** Description :                                                             *
**                                                                           *
**     Function Name            | Access  | Summary                          *
**  ----------------------------+---------+--------------------------------- *
**  exchanger_init              | GLOBAL  | Initialises system at boot time  *
**  config_call                 | GLOBAL  | Configures a new call's params   *
**  media_tx                    | GLOBAL  | Moves data from MIMIC to DSP i/f *
**  queue_frame                 | GLOBAL  | Jitter buffering for the DSP     *
**  set_buildout                | GLOBAL  | Sets the buildout (delay)        *
**  set_coder                   | GLOBAL  | Allows coder to be selected      *
**  select_library              | GLOBAL  | Selects RTP/IFP library modules  *
**  media_rx                    | GLOBAL  | Moves data from DSP i/f to MIMIC *
**  send_packet_to_network      | GLOBAL  | Queues packets for xfer to PNET  *
**                                                                           *
**---------------------------------------------------------------------------*
**                               HISTORY                                     *
** Date            Ver   Dev  Comments                                       *
** 15th Oct  1998  1.0   RGT  Initial Revision                               *
**                                                                           *
** 16th Oct  1998  1.1   RGT  Implement simple delay/jitter buffer in mediaTx*
**                                                                           *
** 31st Oct  1998  1.2   RGT  Tuning improvement to reduce delay to DSP      *
**                                                                           *
**[Release 2]----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                       *
** 19th Jan  1999  2.0   RGT  Re-coded for new architecture. We now have     *
**                            better queueing and delay/buildout management. *
**                            Also, media libraries are called via function  *
**                            pointers that can be switched on the fly.      *
**                                                                           *
** 31st Jan  1999  2.1   RGT  Bug fix in queue_frame algorithm 4 (reverse-   *
**                            time queue) and selection of algorithm 2 rather*
**                            than 4 if frameID=lastFrameID. Also attempting *
**                            early tx SM codec selection in select_library. *
**                                                                           *
** 16th Feb  1999  2.2   RGT  Removed the setting of compander type and also *
**                            echo cancellation in the call_config module.   *
**                            Architecture changes with call setup have made *
**                            this function be called twice during call setup*
**                            Because we don't want echo or compander types  *
**                            to be selected twice per call, the associated  *
**                            code has been moved into the host command      *
**                            interface. Also removed the coder selection    *
**                            'hacks' that were based on address 0x38000.    *
**                                                                           *
** 20th Apr  1999  2.3   RGT  Minor mods for the new stats engine plus some  *
**                            more extensive changes for new functionality.  *
**                            We've improved library transitions with the    *
**                            intro of a function capable of determining the *
**                            protocol type of a packet and added a protocol *
**                            independant jitter calculation module.         *
**                                                                           *
** 5th  May  1999  2.4   RGT  Very minor mod to the jitter calculation module*
**                            for keeping track of the peak jitter observed. *
**                            This is used purely for dynamic buildout in    *
**                            non-silence suppression mode. NOTE only RTP,   *
**                            not IFP, implements this dynamic buildout.     *
**                                                                           *
**[Release 3]----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                       *
**  2   Sep  1999  3.0   JA    CS4 multi-instance integration on SA          *
******************************************************************************/

#include <v_glob.h>
#include <memory.h>

static non_banked Boolean protocol_is(VGLOB *, packet_t *, libraryType);

/*****************************************************************************
             ###   #      ###   ####    ###   #     ####
            #      #     #   #  #   #  #   #  #    #
            #  ##  #     #   #  ####   #####  #     ####  
            #   #  #     #   #  #   #  #   #  #         #  
             ###   #####  ###   ####   #   #  ##### ####
******************************************************************************/

/*****************************************************************************
      ##### #   #  #   #   ####  #####  ###   ###   #    #  ####
      #     #   #  ##  #  #        #     #   #   #  ##   # #
      ####  #   #  # # #  #        #     #   #   #  # #  #  ####
      #     #   #  #  ##  #        #     #   #   #  #   ##      #
      #      ####  #   #   ####    #    ###   ###   #    #  ####
******************************************************************************/

/******************************************************************************
** Function : exchanger_init                                                  *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
** Date            Ver   Dev  Comments                                        *
**  9th Dec  1998  1.0   RGT  Initial Revision                                *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 19th Jan  1999  2.0   RGT  New arch. Added function pointers for library   *
**                            selection (voice, FAX, etc).                    *
**                                                                            *
** 20th Apr  1999  2.1   RGT  Removed init for discard element - this feature *
**                            is no longer present. Also, added in some dumb  *
**                            inits for some of the call config elements to   *
**                            prevent meaningless warnings.                   *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function initialises the core exchanger's master state structures   *
** and setups the default media library to be voice (RTP).                    *
**                                                                            *
*******************************************************************************
** Arguments :                                                                *
**                NONE                                                        *
**                                                                            *
*******************************************************************************/
non_banked void exchanger_init(VGLOB *vglob_ptr)
{
	rxExchangerInfo_t	* SMr;
	txExchangerInfo_t	* SMt;

	SMr=&V(exchangerSM).rx;
	SMr->pktIndex     = 0;
	SMr->frameIndex   = 0;
	SMr->lib          = rtp_rx;				// test_rx;
	SMr->config       = rtp_rx_config;		// test_rx_config;

	SMt=&V(exchangerSM).tx;
	SMt->pktIndex     = 0;
	SMt->frameIndex   = 0;
	SMt->lib          = rtp_tx;				// test_tx;
	SMt->config       = rtp_tx_config;		// test_tx_config;

	/**********************************************************
	** We put arbitrary non-zero initialisers here to prevent *
	** extraneous WARNINGS from being generated prior to the  *
	** receipt of the negotiated parameters.                  *
	***********************************************************/
	V(config).framesPerPkt  = 2;
	V(config).faxBuildOut   = 2;
	V(config).faxPayloadMax = 2;

	V(callIsNowActive)   = False;
}


/******************************************************************************
** Function : config_call                                                     *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 19th Jan  1999  2.0   RGT  Initial Revision                                *
**                                                                            *
** 16th Feb  1999  2.1   RGT  Removed the setting of compander type and also  *
**                            echo cancellation in the call_config module.    *
**                            Architecture changes with call setup have made  *
**                            this function be called twice during call setup *
**                            Because we don't want echo or compander types   *
**                            to be selected twice per call, the associated   *
**                            code has been moved into the host command       *
**                            interface.                                      *
**                                                                            *
** 20th Apr  1999  2.2   RGT  Minor mods in support of new select_library     *
**                            argument spec and the library transition        *
**                            retardation. Also added checks to some of the   *
**                            parameters passed down from the host.           *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function gets called twice per call setup. It keeps a copy of the   *
** host command interface's configuration structure so that libraries may be  *
** transitioned and re-configured on the fly. A call is made to select library*
** with the media type VOICE - all calls are initially brought up in voice    *
** mode. The call to select_library() causes invokation of the rtp config     *
** modules.                                                                   *
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type         |  arg name  | Description                              |  *
**  |--------------+------------+------------------------------------------|  *
**  | callConfig * |   call     | Pointer to call configuration information|  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************/
non_banked void config_call(VGLOB *vglob_ptr)
{
	/*******************************************************************
	** Make sure we don't allow the min jitter to be less than 1 frame *
	********************************************************************/
	if (V(config).jitterMin == 0) {
		WARNING(vglob_ptr, WARN_EXCH_ZERO_MIN_J);
		V(config).jitterMin = 1;
	}

	/*******************************************************************
	** Make sure we don't allow the max jitter to be less than 1 frame *
	********************************************************************/
	if (V(config).jitterMax == 0) {
		WARNING(vglob_ptr, WARN_EXCH_ZERO_MAX_J);
		V(config).jitterMax = DEFAULT_JITTER_DELAY;
	}

	/*******************************************************************
	** Make sure we don't allow the initial jitter to be less than 1 frame *
	********************************************************************/
	if (V(config).jitterInitial == 0) {
		WARNING(vglob_ptr, WARN_EXCH_ZERO_INIT_J);
		V(config).jitterInitial = DEFAULT_JITTER_DELAY;
	}

	/**************************************************************
	** Make sure we don't allow less than 1 frame of FAX buildout *
	***************************************************************/
	if (V(config).faxBuildOut == 0) {
		WARNING(vglob_ptr, WARN_EXCH_ZERO_FAX_BLDOUT);
		V(config).faxBuildOut = 1;
	}

	/*************************************************
	** WARN if we get passed a zero FAX payload size *
	**************************************************/
	if (V(config).faxPayloadMax == 0)
		WARNING(vglob_ptr, WARN_EXCH_ZERO_FAX_PAYLOAD);

	/********************************************
	** Select and configure the default library *
	*********************************************/
	select_library(vglob_ptr, V_RTP);
	V(exchangerSM).tx.pnetTransDelay = 0;	// to allow immediate switch if reqd
}


/******************************************************************************
** Function : select_library                                                  *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 19th Jan  1999  2.0   RGT  Initial Revision                                *
**                                                                            *
** 31st Jan  1999  2.1   RGT  Added in coder selection for library switches   *
**                            this should make VOICE/FAX and FAX/VOICE trans- *
**                            itions possible.                                *
**                                                                            *
** 16th Feb  1999  2.2   RGT  Removed codec selection hacks based on address  *
**                            0x38000 - codec selection is auto-update via    *
**                            host command interface and call config structure*
**                                                                            *
** 20th Apr  1999  2.3   RGT  Changed argument to function to better reflect  *
**                            function's role. Also added initialiser for the *
**                            new back-transition facility.                   *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This swaps the core's media library function pointers to the appropriate *
** media library and calls their configuration modules. From this point forth *
** all core library transactions use the new exchanger library.               *
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type         |  arg name  | Description                              |  *
**  |--------------+------------+------------------------------------------|  *
**  | libraryType  |   type     | Type of library/protocol (RTP/IFP) reqd  |  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************/
non_banked void select_library(VGLOB *vglob_ptr, libraryType type)
{
	switch (type) {
	case V_RTP:
		V(exchangerSM).tx.lib    = rtp_tx;
		V(exchangerSM).tx.config = rtp_tx_config;
		V(exchangerSM).rx.lib    = rtp_rx;
		V(exchangerSM).rx.config = rtp_rx_config;
		V(camilSM).tx.codec      = V(config).pnetCodec;
		break;

	case V_IFP:
		V(exchangerSM).tx.lib    = ifp_tx;
		V(exchangerSM).tx.config = ifp_tx_config;
		V(exchangerSM).rx.lib    = ifp_rx;
		V(exchangerSM).rx.config = ifp_rx_config;
		V(camilSM).tx.codec      = DEMOD;
		break;

	default:
		/*** ERROR ***/
	case V_TEST:
		V(exchangerSM).tx.lib    = test_tx;
		V(exchangerSM).tx.config = test_tx_config;
		V(exchangerSM).rx.lib    = test_rx;
		V(exchangerSM).rx.config = test_rx_config;
		V(camilSM).tx.codec      = V(config).pnetCodec;
		break;
	}

	/*********************************************************************
	** Do not allow another library transition unless the newly selected *
	** library has received at least 100 packets.                        *
	**********************************************************************/
	V(exchangerSM).tx.pnetTransDelay = 100;

	/**********************************************************
	** Call the newly selected library configuration routines *
	***********************************************************/
	V(exchangerSM).rx.config(vglob_ptr);
	V(exchangerSM).tx.config(vglob_ptr);
}


/******************************************************************************
** Function : media_tx                                                        *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
** Date            Ver   Dev  Comments                                        *
** 15th Oct  1998  1.0   RGT  Initial Revision                                *
**                                                                            *
** 16th Oct  1998  1.1   RGT  Implement simple delay/jitter buffer            *
**                                                                            *
** 31st Oct  1998  1.2   RGT  Moved check on buffer status into data transfer *
**                            loop to reduce delay and avoid starving DSP if  *
**                            we receive a very large block of data from the  *
**                            2181 (ie network side).                         *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 19th Jan  1999  2.0   RGT  Re-codec using function pointers.               *
**                                                                            *
** 20th Apr  1999  2.1   RGT  Improved library transition code plus minor mods*
**                            for the new stats engine.                       *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function implements the core exchanger's transmit section. It sits  *
** waiting for a packet from the network. Once a packet arrives, it is passed *
** to the appropriate library for processing and queueing via a function pntr *
** dereference.                                                               *
*******************************************************************************
** Arguments :                                                                *
**                NONE                                                        *
**                                                                            *
*******************************************************************************/
non_banked void media_tx(VGLOB *vglob_ptr, packet_t *pkt)
{

	/*****************************************************************
	** Grab a handle on the transmit state machine and the packet it *
	** is currently indexing in the packet pool.                     *
	******************************************************************/
	txExchangerInfo_t	* SM  = &V(exchangerSM).tx;

	if (pkt == NULL) {
		return;
	}

	/*****************************************************************
	** If we don't have a packet to process, return to the main loop *
	******************************************************************/
	if (pkt->status == V_FULL) {

/************************************************************************
** EXCHANGER LIBRARY CALL BY FUNCTION POINTER DEREFERENCE               *
*************************************************************************/
		SM->lib(vglob_ptr, pkt);

		switch (V(TX_RETVAL)) {
		case IFP_BAD_PKT:
			/**********************************************************
			** The IFP library has received a bad packet check to see *
			** if it's RTP. If it is, however, don't transition to    *
			** voice if we've just transitioned to IFP.               *
			***********************************************************/
			if (protocol_is(vglob_ptr, pkt, V_RTP)) {
				if (!SM->pnetTransDelay) {
					WARNING(vglob_ptr, WARN_EXCH_PNET_VOICE_TRANS);
					select_library(vglob_ptr, V_RTP);
					SM->lib(vglob_ptr, pkt);
				} else 
					SM->pnetTransDelay --;
			} else {
				WARNING(vglob_ptr, WARN_EXCH_UNKNOWN_PROTOCOL);
				WARNING(vglob_ptr, pkt->media[0]);
				WARNING(vglob_ptr, pkt->media[1]);
				WARNING(vglob_ptr, pkt->media[2]);
				WARNING(vglob_ptr, pkt->media[3]);
				WARNING(vglob_ptr, pkt->media[4]);
				WARNING(vglob_ptr, pkt->media[5]);
				WARNING(vglob_ptr, pkt->media[6]);
				WARNING(vglob_ptr, pkt->media[7]);
			}
			break;

		case RTP_BAD_PKT:
			/********************************************************
			** RTP has received a bad packet - check to see if it's *
			** IFP. If it is, however, don't transition to FAX if   *
			** we've only just transitioned to voice!               *
			*********************************************************/
			if (protocol_is(vglob_ptr, pkt,V_IFP)) {
				if (!SM->pnetTransDelay) {
					WARNING(vglob_ptr, WARN_EXCH_PNET_FAX_TRANS);
					select_library(vglob_ptr, V_IFP);
					SM->lib(vglob_ptr, pkt);
				} else 
					SM->pnetTransDelay --;
			} else {
				WARNING(vglob_ptr, WARN_EXCH_UNKNOWN_PROTOCOL);
				WARNING(vglob_ptr, pkt->media[0]);
				WARNING(vglob_ptr, pkt->media[1]);
				WARNING(vglob_ptr, pkt->media[2]);
				WARNING(vglob_ptr, pkt->media[3]);
				WARNING(vglob_ptr, pkt->media[4]);
				WARNING(vglob_ptr, pkt->media[5]);
				WARNING(vglob_ptr, pkt->media[6]);
				WARNING(vglob_ptr, pkt->media[7]);
			}
			break;
		}

		/****************************************************************
		** Immediately free the packet in case the MIMIC ISR wants it ! *
		*****************************************************************/
		pkt->status = V_EMPTY;
		V(stats).tx.bufferedPkts--;

		/*******************************************************
		** Select the next packet element in the transmit pool *
		********************************************************/
		if (++SM->pktIndex >= V(mimicSM).tx.numPkts)
			SM->pktIndex = 0;
	}
}



/******************************************************************************
** Function : protocol_is                                                     *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 20th Apr  1999  2.0   RGT  Initial Revision.                               *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function was added to improve library transitions based on protocol *
** switches over the packet network. The caller passes a pointer to the packet*
** and the protocol type to check for. The routine returns true if the packet *
** is of the protocol specified.                                              *
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type        | argName | Description                                  |  *
**  |-------------+---------+----------------------------------------------|  *
**  | packet_t *  |   pkt   | Pointer to a packet structure for testing    |  *
**  |-------------+---------+----------------------------------------------|  *
**  | libraryType |  type   | The protocol/library type to check for       |  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************/
static non_banked Boolean protocol_is(VGLOB *vglob_ptr, packet_t *pkt, libraryType type)
{
	if (type == V_RTP)
		return rtp_process_packet(vglob_ptr, pkt);

	if (type == V_IFP)
		return ifp_process_packet(vglob_ptr, pkt);

	return False;
}

	

/******************************************************************************
** Function : media_rx                                                        *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
** Date            Ver   Dev  Comments                                        *
** 15th Oct  1998  1.0   RGT  Initial Revision                                *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 19th Jan  1999  2.0   RGT  Re-coded using function pointers.               *
**                                                                            *
** 20th Apr  1999  2.1   RGT  Minor Mods for new stats engine                 *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function implements the exchanger core receive side. It scans the   *
** frame pool from the DSP waiting for a frame to arrive. Once this occurs,   *
** the frame is passed to an exchanger library via function pointer deref.    *
** Stats are gathered to log sucessful transfer, but the FAX transition stub  *
** has negative capability.                                                   *
*******************************************************************************
** Arguments :                                                                *
**                NONE                                                        *
**                                                                            *
*******************************************************************************/

Boolean
media_rx(VGLOB *vglob_ptr)
{
	frame_t				* frame;
	rxExchangerInfo_t	* SM;


	SM    = &V(exchangerSM).rx;
	frame = &V(rxFramePool[SM->frameIndex]);

	/***********************************************************
	** See if we have a whole frame to transfer to the network *
	************************************************************/
	if (frame->status == V_FULL) {
		V(stats).rx.bufferedFrames--;

		#if 0
		printf("media_rx: frame %d at 0x%x, %d bytes\n",
			SM->frameIndex, frame->media, frame->length);
		#endif

/************************************************************************
** EXCHANGER LIBRARY CALL BY FUNCTION POINTER DEREFERENCE               *
*************************************************************************/
		SM->lib(vglob_ptr, frame);

		switch (V(RX_RETVAL)) {
		case PSTN_FAX_TRANS:
			WARNING(vglob_ptr, WARN_EXCH_PSTN_FAX_TRANS);
			select_library(vglob_ptr, V_IFP);
			SM->lib(vglob_ptr, frame);
			break;
		}
		

		/************************************************************
		** Immediately release the frame - the dsp recevier process *
		** may need it !                                            *
		*************************************************************/
		frame->status = V_EMPTY;

		/***********************************************
		** Okay, onto the next slot in the packet pool *
		************************************************/
		if (++SM->frameIndex >= V(camilSM).rx.numFrames)
			SM->frameIndex = 0;

		return True;
	}
	else {
		return False;
	}

}



/******************************************************************************
** Function : queue_frame                                                     *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
** Date            Ver   Dev  Comments                                        *
**  9th Dec  1998  1.0   RGT  Initial Revision                                *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 19th Jan  1999  2.0   RGT  Interface mods (virtual re-code) for new arch.  *
**                                                                            *
** 31st Jan  1999  2.1   RGT  Bug fix in reverse-time queue (algorithm 4).    *
**                            Also use algorithm 2 instead of 4 for duplicate *
**                            frameID. Note this should *never* fire anyway.  *
**                                                                            *
** 20th Apr  1999  2.2   RGT  Minor mods for new stats engine.                *
**                                                                            *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function is intended for use by the exchanger libraries. It offers  *
** a simple, consistent (media-independent) interface to the DSP. Frames are  *
** queued for transmission to the DSP based upon a 'frame ID' which is linked *
** to the DSP clock. Frames that are too old are not queued but the function  *
** returns status information indicating queue failure. For safety's sake, the*
** function never queues less than 1 frame ahead of the DSP read head. This   *
** introduces an intrinsic delay of 1 frame in time (10msec voice, 30msec FAX)*
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type     |  arg name  | Description                                  |  *
**  |----------+------------+----------------------------------------------|  *
**  | frame_t *| frame      | Pointer to the frame structure for queueing  |  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************/

non_banked byte queue_frame(VGLOB *vglob_ptr, frame_t * frame, byte * frameMediaPtr)
{
	txExchangerInfo_t	* SM;
	frame_t				* accessor;
	stats_t				* stats;
	Boolean				  positiveQueue;
	word				  seqDiff;

	/*********************************************************
	** Grab a handle on the exchanger transmit state machine *
	**********************************************************/
	SM = &V(exchangerSM).tx;
	stats = &V(stats);

	stats->tx.mediaBytes += frame->length;
	stats->tx.rcvdFrames++;

	/*******************************************************************
	** Firstly, make sure we don't try to queue a frame that's "older" *
	** that what the DSP currently wants.                              *
	********************************************************************/
	_int_disable();
	if (frame->ID <= V(camilSM).tx.frameID) { // could occur due to 16-bit wrap
		if (V(camilSM).tx.frameID - frame->ID < 0xFF) {
			stats->tx.oldFrames ++;
			_int_enable();
			return TOO_OLD;
		}
	}
	_int_enable();
	
	/*************************************************************
	** Now calculate the signed offset of the current frame from *
	** the last processed by this routine.                       *
	**************************************************************/
	if (frame->ID >= SM->lastFrameID) {
		if (frame->ID - SM->lastFrameID > 0x0FFF)	{
			/****[ Assuming 16-bit negative Wrap ]****/
			seqDiff = SM->lastFrameID + 1 + (MAX_WORD - frame->ID) ;
			positiveQueue = False;
		} else {
			seqDiff = frame->ID - SM->lastFrameID;
			positiveQueue = True;
		}
	} else {
		if (SM->lastFrameID - frame->ID > 0x0FFF) {
			/****[ Assuming 16-bit positive Wrap ]****/
			seqDiff = (MAX_WORD - SM->lastFrameID) + frame->ID + 1;
			positiveQueue = True;
		} else {
			seqDiff = SM->lastFrameID - frame->ID;
			positiveQueue = False;
		}
	}
	SM->lastFrameID = frame->ID;

	/*************************************************************
	** Translate this difference in frame IDs to a difference in *
	** slot numbering in the transmit frame pool.                *
	**************************************************************/
	seqDiff %= V(camilSM).tx.numFrames;

	/**************************************************************
	** Now calculate which slot to use for the new frame - taking *
	** positive and negative wrapping into account.               *
	***************************************************************/
	if (positiveQueue)
		SM->frameIndex += seqDiff;
	else
		SM->frameIndex -= seqDiff;

	if (SM->frameIndex >= V(camilSM).tx.numFrames) 
		if (positiveQueue) {				// queueing forwards in time
			SM->frameIndex -= V(camilSM).tx.numFrames;
		} else {						// queueing backwards in time
			SM->frameIndex= (V(camilSM).tx.numFrames-1)-(MAX_BYTE-SM->frameIndex);
		}


	/*******************************************************************
	** Okay, before we write any data, check the status of the indexed *
	** frame - we don't want to overwrite it !                         *
	********************************************************************/
	accessor = &V(txFramePool[SM->frameIndex]);
	if (accessor->status == V_FULL) { 		// problem ?
		if (frame->ID == accessor->ID) {	// duplicate frame (for FAX MODE)
			stats->tx.duplicateFrames++;
			// printf("DUPLICATE: exchangeSM: frameIndex=%d, frameID=%d, lastFrameID=%d; camilSM: frameIndex=%d, frameID=%d\n", SM->frameIndex, frame->ID, SM->lastFrameID, V(camilSM).tx.frameIndex, V(camilSM).tx.frameID);
			return DUPLICATE;
		}
		else if (txframe_pool_full_count(vglob_ptr) > CFG_CAML_TX_LUT_SZ - 4) {
			// frame pool almost full
			WARNING(vglob_ptr, WARN_PSTN_OUTBUF);
			printf("OVERLOAD: exchangeSM: frameIndex=%d, frameID=%d, lastFrameID=%d; camilSM: frameIndex=%d, frameID=%d\n", SM->frameIndex, frame->ID, SM->lastFrameID, V(camilSM).tx.frameIndex, V(camilSM).tx.frameID);
			stats->tx.droppedFrames++;
			dump_txframe_pool(vglob_ptr);
			dump_rxframe_pool(vglob_ptr);
			audit_frame_pools(vglob_ptr);
			return OVERLOAD;
		}
		else {
			// Stray V_FULL frame?
			// Possibly can happen when jitter after buildout adjustment
			// Pool not full, go ahead and load the frame
		}
	}
		// Copy the frame header info
		accessor->ID = frame->ID;
		accessor->codec = frame->codec;
		accessor->status = frame->status;
		accessor->length = frame->length;

		/******************************************
		** Now write the data into the frame pool *
		*******************************************/
		if (accessor->length == 2) {
			// SID frames require last 4 words == 0 for correct playback
			accessor->media[0] = frameMediaPtr[0];
			accessor->media[1] = frameMediaPtr[1];
			for (int j = 2; j < G729_FRAME_SZ; j++) {
				accessor->media[j] = 0;
			}
			accessor->length = G729_FRAME_SZ;
		}
		else {
			memcpy(&accessor->media[0], frameMediaPtr, accessor->length);
		}

/****************************************************************************
** Protected Section :                                                      *
**********                                                                  *
		** Must ensure interrupts are disabled during these few instructions*
		** to prevent DSP reading beyond the frame (sending FRAME ERASURE)  *
		** then the main task setting the frame location to "V_FULL" - this *
		** action later causes another frame erasure because queue_frames   *
		** sees a full frame that can't be overwritten that the DSP doesn't *
		** want. (This isn't explained well, re-word it later!!)            *
		*********************************************************************/
		_int_disable();
		if (frame->ID <= V(camilSM).tx.frameID) { // could occur due 2 16-bit wrap
			if (V(camilSM).tx.frameID - frame->ID < 0xFF) {
				stats->tx.oldFrames++;
				_int_enable();
				return TOO_OLD;
			}
		} 
		accessor->status = V_FULL;

		_int_enable();

		stats->tx.queuedFrames++;
		return QUEUED;
}


/******************************************************************************
** Function : set_buildout                                                    *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
** Date            Ver   Dev  Comments                                        *
**[Release 2]-----------------------------------------------------------------*
** 19th Jan  1999  2.0   RGT  Initial Revision                                *
**                                                                            *
** 27th Apr  1999  2.1   RGT  Added in statistic for buildout setting in frms *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function may be called by any system module but should really only  *
** be used by the exchanger libraries to control the buildout delay to the    *
** PSTN. The buildout is specified in frames rather than msecs to make the    *
** routine frame-size independant.                                            *
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type     |  arg name  | Description                                  |  *
**  |----------+------------+----------------------------------------------|  *
**  | byte     | numFrames  | The number of frames of delay to insert      |  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************/
non_banked word set_buildout(VGLOB *vglob_ptr, byte numFrames)
{
	// Prevent camilSM from changing while we access it
	_int_disable();

	txExchangerInfo_t	* SM = &V(exchangerSM).tx;
	byte oldIndex =  SM->frameIndex;

	// Update frame ID, index
	SM->lastFrameID = V(camilSM).tx.frameID + (numFrames - 1);
	SM->frameIndex  = V(camilSM).tx.frameIndex + (numFrames - 1);

	// Check for wrap in frameIndex
	// ITS: if (V(exchangerSM).tx.frameIndex > V(camilSM).tx.numFrames)
	if (SM->frameIndex >= V(camilSM).tx.numFrames)
		SM->frameIndex -= V(camilSM).tx.numFrames;

	#if 0	// Not clear that we need this
	if (numFrames < V(stats).tx.buildout) {
		// Buildout is decreasing
		// Dump V_FULL frames outside of new buildout
		// The hope is prevent WARN_PSTN_OUTBUF in queue_frame()
		byte index = SM->frameIndex;
		while(index != oldIndex) {
			// Increment index, checking for wrap
			if (++index >= V(camilSM).tx.numFrames) {
				index -= V(camilSM).tx.numFrames;
			}

			// Mark buffer available
			V(txFramePool[index]).status = V_EMPTY;
			// printf("set_buildout: dumped txFrame, index=%d\n", index);
		}
	}
	#endif

	V(stats).tx.buildout = numFrames;

	_int_enable();
	return (SM->lastFrameID + 1);
}


/******************************************************************************
** Function : set_coder                                                       *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
** Date            Ver   Dev  Comments                                        *
**[Release 2]-----------------------------------------------------------------*
** 19th Jan  1999  2.0   RGT  Initial Revision                                *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function may be called by any system module to set the codec type   *
** to be used in both transmit and receive direction. It's only real use is   *
** during call setup. It cannot reliably enforce a transition since the DSP   *
** always follows what is being fed to it from the packet network.            *
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type     |  arg name  | Description                                  |  *
**  |----------+------------+----------------------------------------------|  *
**  | codecType| coder      | The type of coder to select (G711, G729, FAX)|  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************/
non_banked void set_coder(VGLOB *vglob_ptr, codecType coder)
{
	V(camilSM).tx.codec = coder;
	V(camilSM).rx.codec = coder;
	#if 0
	printf("set_coder, modem = %d, coder=0x%x, tx.codec=0x%x, rx.codec=0x%x\n", V(modem_num), coder, V(camilSM).tx.codec, V(camilSM).rx.codec);
	#endif
}


/******************************************************************************
** Function : send_packet_to_network                                          *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
** Date            Ver   Dev  Comments                                        *
**  9th Dec  1998  1.0   RGT  Initial Revision                                *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 19th Jan  1999  2.0   RGT  Re-write. Introduced protocol for ensuring frm  *
**                            alignment and for in-band commands (DTMF etc.)  *
**                                                                            *
** 20th Apr  1999  2.1   RGT  Minor mod for new stats engine. Also added a    *
**                            check on the packet passed to the function to   *
**                            ensure we don't queue a packet with a silly     *
**                            length to the network.                          *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**                                                                            *
**                                                                            *
** <----2 bytes----> <--- length bytes ---> <-------  4 stop bytes ------->   *
** [marker & length] [        media       ] [ 0x00 ] [ 0x00 ] .... [ 0x00 ]   *
**                                                                            *
**                                                                            *
**  _______________________________________________________________           *
** | 15| 14| 13| 12| 11| 10| 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |          *
** |---+---+-------+-----------------------------------------------|          *
** | 0 | 1 | TYPE  |                LENGTH                         |          *
**  ---------------------------------------------------------------           *
**                                                                            *
** TYPE VALUE   DESCRIPTION                                                   *
**   0 0          Normal media (RTP,FAX, etc) from the packet network.        *
**   0 1          Raw (zero-protocol) media from a voice announcement.        *
**   1 0          An in-band command.                                         *
**                                                                            *
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type     |  arg name  | Description                                  |  *
**  |----------+------------+----------------------------------------------|  *
**  | byte *   | buffer     | Pointer to start of packet to send to PNET   |  *
**  |----------+------------+----------------------------------------------|  *
**  | word     | length     | The length of the packet                     |  *
**  |----------+------------+----------------------------------------------|  *
**  | byte     | type       | The type of packet (command or media)        |  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************/
packet_t *
next_rx_media_packet ( VGLOB *vglob_ptr )
{
	rxExchangerInfo_t	* SM  = &V(exchangerSM).rx;
	packet_t			* pkt = &V(rxPacketPool[SM->pktIndex]);

	/*****************************************************
	** Move to the next packet position in the pool.     **
	******************************************************/
	if (++SM->pktIndex >= V(mimicSM).rx.numPkts)
		SM->pktIndex = 0;

	/*****************************************************************
	** Check to see that the currently indexed packet in the pool is *
	** available for use. If not, just return NULL                   *
	******************************************************************/
	if (pkt->status == V_EMPTY) {		// okay to write !
		// Initialize fields
		pkt->type   = PNET_MEDIA;
		return pkt;
	}
	else {
		return NULL;
	}
}

non_banked byte send_packet_to_network(VGLOB *vglob_ptr, packet_t *inPkt, byte type)
{
	/*************************************************************
	** Grab a handle on the mimic receiver state machine and the *
	** packet it currently addresses in the packet pool.         *
	**************************************************************/
	packet_t			* pkt = inPkt;

	/*******************************************************************
	** Mark packet as full so v_media_write_to_host will take it.           *
	********************************************************************/
	pkt->status = V_FULL;
	V(stats).rx.queuedPkts++;
	if (++V(stats).rx.bufferedPkts > V(stats).rx.maxBufferedPkts)
		V(stats).rx.maxBufferedPkts = V(stats).rx.bufferedPkts;

	// Tell to_host_task about rx packet traffic
	host_send_voice_data(VOICE_DATA_MSG, V(modem_num), (uint_32) pkt);

	return 1;
}


/******************************************************************************
** Function : init_jitter_clock                                               *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 20th Apr  1999  2.0   RGT  Initial Revision                                *
**                                                                            *
*******************************************************************************
** Description :                                                              *
*******************************************************************************
** Arguments :                                                                *
**                NONE                                                        *
**                                                                            *
*******************************************************************************/
non_banked void init_jitter_clock(VGLOB *vglob_ptr)
{
	V(hiGran) = MACRO_GET_TIME();
}


/******************************************************************************
** Function : update_jitter_calc                                              *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
** Date            Ver   Dev  Comments                                        *
**[Release 2]-----------------------------------------------------------------*
** 20th Apr  1999  2.0   RGT  Initial Revision                                *
**                                                                            *
** 7th  May  1999  2.1   RGT  Added in peak jitter tracker for dynamic bldout *
**                            in non-silence suppression environments.        *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function implements a protocol independant jitter calculation for   *
** both RTP and IFP. It accepts one argument specifying the period of time    *
** that elapsed between two sucessive packets AS SPECIFIED BY THE PROTOCOL IN *
** USE (units of msecs). It looks at the local time difference and computes   *
** the network/system jitter.                                                 *
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type     |  arg name  | Description                                  |  *
**  |----------+------------+----------------------------------------------|  *
**  | word     | txTime     | Time diff at the transmitter (ms units)      |  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************/
non_banked void update_jitter_calc(VGLOB *vglob_ptr, word txTime)
{
	word			diff;
	word	actual;

	/**************************************************************
	** Basically, because of clock skew, we won't perform jitter  *
	** calculations if the implied time difference is larger than *
	** half a second - this is overly cautious but shouldn't cause*
	** the system measurement to degrade.                         *
	***************************************************************/
	if (txTime < 500) {
		actual = MACRO_ELAPSED_TIME(V(hiGran));
		if (txTime >= actual)
			diff = txTime - actual;
		else
			diff = actual - txTime;

		V(exchangerSM).tx.jitter += diff - ((V(exchangerSM).tx.jitter + 8) >> 4);
	}

	/********************************************************************
	** Keep a track of the peak jitter encountered for dynamic buildout *
	** in non-silence suppression environments.                         *
	*********************************************************************/
	if (V(exchangerSM).tx.jitter > V(exchangerSM).tx.peakJitter)
		V(exchangerSM).tx.peakJitter = V(exchangerSM).tx.jitter;

	V(hiGran) = MACRO_GET_TIME();
}


/*********************[ FUNCTION VERSION VERSION TRACKING ]********************

 _____________________________________________________________________________
|                            |            exchange.obj  Version               |
|   Function Name            |  2.0 |  2.1 |  2.2 |  2.3 |  2.4 |  2.5 |  2.6 | 
|----------------------------+------+------+------+------+------+------+------|
| exchanger_init             |  2.0 |      |      |  2.1 |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| config_call                |  2.0 |      |  2.1 |  2.2 |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| select_library             |  2.0 |  2.1 |  2.2 |  2.3 |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| protocol_is                |>>>>>>|>>>>>>|>>>>>>|  2.0 |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| media_tx                   |  2.0 |      |      |  2.1 |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| media_rx                   |  2.0 |      |      |  2.1 |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| set_buildout               |  2.0 |      |      |  2.1 |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| set_coder                  |  2.0 |      |      |      |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| queue_frame                |  2.0 |  2.1 |      |  2.2 |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| send_packet_to_network     |  2.0 |      |      |  2.1 |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| init_jitter_clock          |>>>>>>|>>>>>>|>>>>>>|  2.0 |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| update_jitter_calc         |>>>>>>|>>>>>>|>>>>>>|  2.0 |  2.1 |      |      |
 -----------------------------------------------------------------------------

**********************[ FUNCTION VERSION VERSION TRACKING ]********************/
