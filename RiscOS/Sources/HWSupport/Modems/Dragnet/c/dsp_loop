/*name and version number:@(#)dsp_loop.c	1.1*/
/*date of get: 		  09/06/00 16:59:39*/
/*date of delta:	  09/02/99 21:19:48*/
/*********************************************************************
* DSP Loop Back Driver - a task that will pull frames out of the      *
* txFramePool like dsp_media_write() would, and turn them around and *
* stuff them back into the rxFramePool like dsp_media_read() would.  *
*********************************************************************/


#include <stdio.h>
#include <v_glob.h>

int dsp_frame_loop(VGLOB *vglob_ptrvoid);

int
dsp_frame_loop(VGLOB *vglob_ptr) {
	int numBytes;

	/****************************************************************
	** Grab a handle on the receiver state machine and the frame it *
	** currently indexes in the receiver frame pool.                *
	*****************************************************************/
	stateInfo_t	* SMr         = &V(camilSM).rx;
	frame_t		* frame      = &V(rxFramePool).frame[SMr->frameIndex];

	/***********************************************
	** Grab a handle on the transmit state machine *
	************************************************/
	stateInfo_t		* SMt		= &V(camilSM).tx;

/***********************************************************************
*     Allow for jitter build out when looking for frames to loop back, *
*     assume a fixed value for our test call                           *
***********************************************************************/
	word myIndex = SMt->frameIndex + 10;
	if (myIndex >= SMt->numFrames)
		myIndex -= SMt->numFrames;
	SMt->frame = &V(txFramePool).frame[myIndex];
       
	/* Nothing to do if no receive frames available */
	if (frame->status != EMPTY) {	
		return False;
	}

	/* Nothing to do if no transmit frame ready to go */
	if (SMt->frame->status != FULL) {
		return False;
	}

	/* Copy ID, codec, length */
	frame->ID = SMt->frameID++;
	frame->codec = SMt->frame->codec;
	frame->length = SMt->frame->length;
	numBytes = SMt->frame->length;

	/* Copy media bytes */
	SMr->byteOffset = 0;
	frame->media = SMr->nextFreeByte;


	/* The regular definition refers to SM, we have SMr :-( */
#define LOCAL_MACRO_RX_FRAME_FREE()	(&V(rxFramePool).data[CFG_CAML_RX_POOL_SZ-1] - \
									V(rxFramePool).frame[SMr->frameIndex].media)

	if (LOCAL_MACRO_RX_FRAME_FREE() < frame->length)
		frame->media = V(rxFramePool).data;

	// printf("dsp_loop: looping tx frame of %d bytes at 0x%x to rx frame at 0x%x\n", numBytes, (unsigned) SMt->frame->media, (unsigned) frame->media);

	SMt->byteOffset = 0;
	while (numBytes-- && SMr->byteOffset < frame->length) {
		frame->media[SMr->byteOffset++] = SMt->frame->media[SMt->byteOffset++];
	}

	/* Clean up transmit frame pool */
	if (++SMt->frameIndex >= SMt->numFrames)
		SMt->frameIndex=0;
	SMt->frame->status = EMPTY;

	/* Clean up receive pool */
	SMr->nextFreeByte = &frame->media[SMr->byteOffset];
	if (++SMr->frameIndex >= SMr->numFrames)
		SMr->frameIndex = 0;
	frame->status = FULL;

	return True;
}

