/*name and version number:@(#)iomain.c	1.237*/
/*date of get: 		  12/15/00 10:10:34*/
/*date of delta:	  11/30/00 16:58:18*/
/****************************************************************
File :	iomain.c
Description :
	The main entry routine for io task.

Procedures Contained :
	io_periodic_task
	io_init_task
	io_task

Revision History :
	Initials	Date		Change
*****************************************************************/
#define Z80_DEBUG_THIS_FILE

#include "llglob_d.h"
#include "atglob.h"
#include "dpglob.h"
#include "ioglob_d.h"
#include "iouart_d.h"
#include "lapm.h"
#include "mnp.h"
#ifdef V80
#include "sync.h"
#endif
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
#include "fax_c2.h"
#endif

#if defined(V34_FAX)
#include "faxv34.h"
#endif

#include "z80glob.h"
#ifdef KORTEX			
#include "AmUpdate.h"
#endif
#ifdef AM_DEBUG
#include "amdebug.h"
#endif
#ifdef CS_V110
#include "v110sys.h"
#include "v110il.h"
#include "v110cs.h"
#endif
#if defined(SA_DIGITAL)
# include "sa_t1.h"
#endif
#include "allglobs.h"

/****************************************************************
Routine : io_detect_inactivity
Description :
		Detect inactivity	
Parameters in :
	none
Parameters out :
	none
Revision History :
	Initials	Date		Change
*****************************************************************/
void io_detect_inactivity( void ) 
{
	if ( G(S).ModemOptions.InactivityTimer == 0 )
		return ;
	if ( ( G(io_dte_rx_old_ptr) == I(io_dte_rx_wptr) ) &&
		  ( G(io_dte_tx_old_ptr) == I(io_dte_tx_wptr) ) )
	{
		if ( x_elapsed_minutes ( G(io_dte_inact_timer) ) >= G(S).ModemOptions.InactivityTimer ) 
		{
			G(x_status).ud_TerminationCause = UD_TC_INACT_TIME_OUT;
			x_debug_msg ( "IO - inactivity disconnect" ) ;
			x_send_mail ( V42_LOCAL_DISC, DP_TASK, NULL, 0 ) ;
			x_set_current_time ( &G(io_dte_inact_timer) ) ;
		}
	}
	else
	{
		G(io_dte_rx_old_ptr) = (byte *) I(io_dte_rx_wptr) ;
		G(io_dte_tx_old_ptr) = (byte *) I(io_dte_tx_wptr) ;
		x_set_current_time ( &G(io_dte_inact_timer) ) ;
	}
}

/****************************************************************
Routine : io_init_task
Description :
	Init variables and hardware for io task.
Parameters in :
	none
Parameters out :
	none
Revision History :
	Initials	Date		Change
*****************************************************************/
void io_init_task ( void ) 
{
	G(io_state) = IO_IDLE ;
	G(io_old_state) = IO_IDLE ;
	G(io_uart_status) = 0 ;
	G(io_uart_msr) = 0 ;
	G(io_remote_control_mode) = FALSE;
	G(io_at_esc_detect) = FALSE ;
	G(io_at_esc_state) = AT_ESC_INIT_STATE ;

	UART_SetQue ( NULL, 0, NULL, 0 ) ; // init dte tx & rx fifo
	io_init_dce_tx_fifo () ;	// init dce transmit fifo
	io_init_dce_rx_fifo () ;	// init dce receive  fifo

	G(io_dtr_timer) = 0 ;		// jmg 112398

	// Reset EIA leads.
	// They will later be set correctly based
	// on the modem options after the data pump
	// has been initialized. (MC_OPTION_CHANGE)
	UART_ri_off () ;
	UART_cts_on () ;
	UART_cd_off () ;
	#if defined(CLAUDIA)
	if ( !G(S).ModemOptions.DSRControl )
	{
		UART_dsr_on () ;
	}
	#else
		UART_dsr_on () ;
	#endif

#ifdef V80
	io_sync_power_up_init () ;
#endif
	G(io_send_break_to_remote) = FALSE ;
}

/****************************************************************
Routine : io_sleep
*****************************************************************/
void io_sleep ( void )
{
   	// Put DSP to sleep
#if !defined( MODEM_Z80 )
	x_send_mail ( DP_SLEEP, DP_TASK, NULL, 0 ) ;
#endif
	G(io_state) = IO_SLEEP_BLACKLIST ;
}
/****************************************************************
Routine : io_send_break
Description :
	Send break for all modes.
*****************************************************************/
const word io_line_rate[] =
	{
	 0, 75, 300, 600, 1200, 2400, 4800, 7200, 9600,
	12000, 14400, 16800, 19200, 21600, 24000, 26400, 28800,
	31200, 33600, 32000, 34000, 36000, 38000, 40000, 42000,
	44000, 46000, 48000, 50000, 52000, 54000, 56000, 58000, 60000,
	// VPCM rates
	28000, 29333, 30666, 32000, 33333, 34666, 36000, 37333,
	38666, 40000, 41333, 42666, 44000, 45333, 46666, 48000,
	49333, 50666, 52000, 53333, 54666, 56000
	};

void io_send_break ( void )
{
	G(io_send_break_to_remote) = TRUE ;
	G(io_break_length) = (word)((G(S).ModemOptions.BreakLength * io_line_rate[ G(x_line_rate)])/80);

	G(io_uart_status) |= UART_DTE_BREAK_ON ;

	if ( G(x_modem_state) == MS_ON_DIAL )
	{
		if ( G(io_at_esc_detect) == FALSE )
		{
			switch ( G(S).ModemOptions.BreakControl )
			{
				case 0:
				case 2:
				case 4:
					x_debug_msg ( "IO - at escape seq - break on" ) ;
					G(io_send_break_to_remote) = FALSE ;
					G(io_at_esc_detect) = TRUE ;
					x_send_mail ( AT_OK, AT_TASK, NULL, 0 ) ;
					break;
				case 1:
					io_init_dce_tx_fifo () ;
					UART_Flush ( 0 ) ;
				case 3:
				case 5:
					break ;
			}
		}
		else
		{
			if ( (G(S).ModemOptions.BreakControl == 0) ||
			     (G(S).ModemOptions.BreakControl == 1) )
				io_init_dce_tx_fifo () ;
		}
		if ( G(io_send_break_to_remote) )
		{
			if ( G(io_state) == IO_ONLINE )	// buffer mode
			{
				io_tx_break () ;
			}
			else if ( G(io_state) == IO_V42 )
			{
				lapm_tx_break () ;
			}
			else if ( G(io_state) == IO_MNP )	// MNP
			{
				mnp_tx_break() ;
			}
		}
	}
}
/****************************************************************
Routine : io_periodic_task
Description :
	The periodic routine for io task.
Parameters in :
	none
Parameters out :
	none
Revision History :
	Initials	Date		Change
*****************************************************************/
void io_periodic_task ( void )
{
	byte new_state ;
#ifdef HOMOL 
	byte blacklist_status ;
#endif

	// Check the G(io_dtr_timer).  (jmg 112398)
	// If non-zero, we are processing a DTR disconnect.
	// Wait until the DTE-DCE-DP buffers are empty before
	// disconnecting, or a max of 2 seconds.
	if( G(io_dtr_timer) != 0 )
	{
		if( x_elapsed_time( G(io_dtr_timer) ) >= SECOND2
			|| ( IS_DTE_RX_EMPTY() && DCE_TX_EMPTY() ) )
		{
			// disable timer and send disconnect
			G(io_dtr_timer) = 0;
			x_send_mail ( AT_IO_DISCONNECT, IO_TASK, NULL, 0 ) ;
		}
	}

	switch ( G(io_state) )
	{
		case IO_IDLE :
			G(io_timer) = x_current_time () ;
			G(io_state) = IO_IDLE_AWAKE ;
			break ;

		case IO_IDLE_AWAKE :
			//>>***
#ifdef KORTEX			
			if (bAmUpdateState)
			{
				break;
			}
#endif
			// send data byte received from dte to at task
			while ( io_get_dte_rx_char ( &G(io_dte_rx_last_ch) ) )
			{
				x_send_mail ( IO_AT_DATA, AT_TASK, &G(io_dte_rx_last_ch), 1 ) ;
				G(io_timer) = x_current_time () ;
			}
#ifdef DC0
			if ( (G(x_modem_state) != MS_IDLE) ||
				 (G(x_modem_mode) == MODEM_RADISH) ||
				 (G(cell_active) == TRUE) )
#else
			if ( (G(x_modem_state) != MS_IDLE) ||
				 (G(x_modem_mode) == MODEM_RADISH) )
#endif
				G(io_timer) = x_current_time () ;

			if ( G(S).ModemOptions.SleepModeTimer && (x_elapsed_time(G(io_timer)) >= 
						(word)(1000*G(S).ModemOptions.SleepModeTimer)) )
			{
				io_sleep () ;
			}
			break ;

		case IO_WAKEUP :
			if ( G(x_modem_state) == MS_IDLE )
				x_send_mail ( DP_WAKEUP, DP_TASK, NULL, 0 ) ;
			G(io_timer) = x_current_time () ;
			G(io_state) = IO_IDLE ;
			break ;

		case IO_SLEEP :
			if ( io_get_dte_rx_char ( &G(io_dte_rx_last_ch) ) )
			{
				x_send_mail ( DP_WAKEUP, DP_TASK, NULL, 0 ) ;
				x_send_mail ( IO_AT_DATA, AT_TASK, &G(io_dte_rx_last_ch), 1 ) ;
				G(io_state) = IO_IDLE ;
				G(io_timer) = x_current_time () ;
			}
			break ;

		case IO_SLEEP_BLACKLIST :
#ifdef HOMOL 
			{
				blacklist_status = FALSE ;
				x_send_mail(DP_BLACKLIST_STATUS, DP_TASK,
							&blacklist_status, 1);
				// Put VxD to sleep only if blacklist is empty.
				if ( blacklist_status == FALSE )
				{
#endif
					if ( x_sleep_mode () )
					{
						// Z80 just slept and awoke.  Awaken DP and
						// reset timer so uC stays awake for a while.
						G(io_state) = IO_WAKEUP ;
					}
					else
					{
						G(io_state) = IO_SLEEP ;
					}
#ifdef HOMOL 
				}
				if ( io_get_dte_rx_char ( &G(io_dte_rx_last_ch) ) )
				{
					x_send_mail ( DP_WAKEUP, DP_TASK, NULL, 0 ) ;
					x_send_mail ( IO_AT_DATA, AT_TASK,
								  &G(io_dte_rx_last_ch), 1 ) ;
					G(io_state) = IO_IDLE ;
					G(io_timer) = x_current_time () ;
				}
			}
#endif
			break ;

		case IO_DCE_LOOPBACK :  // local dte loopback and remote data loopback
			/* send dce receive byte to dce transmit queue */
			io_dce_loopback () ;
			/* send dte receive byte to at task */
			if ( io_get_dte_rx_char ( &G(io_dte_rx_last_ch) ) )
				x_send_mail ( IO_AT_DATA, AT_TASK, &G(io_dte_rx_last_ch), 1 );
			break;

		case IO_DTE_LOOPBACK :	// local dte loopback
			if ( G(io_at_esc_detect) )
			{
				/* send dte receive byte to at task */
				if ( io_get_dte_rx_char ( &G(io_dte_rx_last_ch) ) )
					x_send_mail(IO_AT_DATA, AT_TASK, &G(io_dte_rx_last_ch), 1);
			}
			else
			{
				/* send dte receive byte to dte transmit queue */
				io_dte_loopback () ;
				/* check for at escape sequence */
				io_at_esc_seq_detected();
			}
			break ;

		case IO_ANALOG_LOOPBACK :	// local analog loopback
			if ( G(io_at_esc_detect) )
			{
				/* send dte receive byte to at task */
				if ( io_get_dte_rx_char ( &G(io_dte_rx_last_ch) ) )
					x_send_mail(IO_AT_DATA, AT_TASK, &G(io_dte_rx_last_ch), 1);
			}
			else
			{
				/* transmit dce data in fifo to dte */
				io_dce_to_dte_data () ;
				/* transmit dte data in queue to dce */
				io_tx_dte_to_dce_data () ;
				/* check for at escape sequence */
				io_at_esc_seq_detected();
			}
			break ;

		case IO_DIAL_OR_ANSWER:
			/* dialing or answering data call.
			 * We're working on a startup now.  Any incoming
			 * characters from DTE mean we should stop the startup.
			 * I (mah) moved this code here from atmain.c so
			 * that this would be a separate G(io_state).  We don't
			 * want to autobaud here.
			 */
			if (MS_ANSWERING != G(x_modem_state) &&
				MS_DIALING != G(x_modem_state))
			{
				/* if we're no longer answering or
				 * dialing then we shouldn't be in
				 * this state any longer.  Go back to
				 * idle.
				 */
				G(io_state) = IO_IDLE;
				break;
			}
			if (!io_get_dte_rx_char(&G(io_dte_rx_last_ch)))
			{
				/* No new characters typed, don't do anything. */
				break;
			}

			if ( x_elapsed_time(G(io_timer)) >= 125 )
			{
				MODEM_MODE modemMode = G(x_modem_mode);
				G(x_status).ud_TerminationCause = UD_TC_ANY_KEY_ABORT;
				x_debug_msg("IO - call aborted");

				x_send_mail(MC_ONHOOK, DP_TASK, NULL, 0);
				G(x_modem_mode) = modemMode;

				// set to voice mode after aborting a speaker phone call
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
				if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
					G(x_modem_mode) = MODEM_VOICE ;
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM

				// Send NO CARRIER result
				G(x_dial_residual) = MR_CD_DISCONNECT ;

				x_send_mail(IO_AT_DISCONNECT, AT_TASK, NULL, 0);
				G(io_state) = IO_IDLE;
			}
			break;

		case IO_ONLINE :	// on dial lines - buffered mode
			if ( G(io_at_esc_detect) )
			{
#if defined(DP_BASHER_TEST)
				extern void dp_basher_test(void);
				if (G(dp_basher_test_enabled))
				{
					dp_basher_test();
				}
#else
				if (G(io_remote_control_mode))
				{
					word w;

					/* send dce receive byte to at task */
					if (io_read_dce_fifo(1, &w))
					{
						G(io_dte_rx_last_ch) = (byte) w;

						x_send_mail(IO_AT_DATA, AT_TASK,
									&G(io_dte_rx_last_ch), 1);
					}
				}
				else
#endif // DP_BASHER_TEST
				{
					/* send dte receive byte to at task */
					if ( io_get_dte_rx_char ( &G(io_dte_rx_last_ch) ) )
						x_send_mail(IO_AT_DATA, AT_TASK,
									&G(io_dte_rx_last_ch), 1);
					if ( G(io_send_break_to_remote) )
						io_tx_break () ;
				}
			}
			else
			{
				/* transmit dce data in fifo to dte */
				io_tx_dce_to_dte_data () ;
				/* transmit dte data in queue to dce */
				io_tx_dte_to_dce_data () ;

				/* check for at escape sequence */
				io_at_esc_seq_detected();
				io_detect_inactivity () ;
			}
			break ;

#if defined(CS_V110)
		case IO_V110:			// online for v110
			if ( G(io_at_esc_detect) )
			{
				/* send dte receive byte to at task */
				if ( io_get_dte_rx_char ( &G(io_dte_rx_last_ch) ) )
					x_send_mail(IO_AT_DATA, AT_TASK, &G(io_dte_rx_last_ch), 1);

				if (G(v110_state) == V110_DISCONNECT)	// for ath command
				{
					v110_background();	
					G(io_at_esc_detect) = FALSE;
				}
			}
			else
			{
				/* transmit dce data in fifo to dte */
				if ( v110_background() == V110_EXIT )
				{
					x_debug_msg("IO - msg: go to IO_IDLE state" ) ;	// jctmp
					G(io_state) = IO_IDLE;
				}

				/* check for at escape sequence */
				if ( ( io_at_esc_seq_detected () ) == TRUE )
				{
					x_debug_msg ( "IO - at escape sequence detected" ) ;
					G(io_at_esc_detect) = TRUE ;
					x_send_mail ( AT_OK, AT_TASK, NULL, 0 ) ;
				}
				io_detect_inactivity () ;
			}
			break;
#endif

#ifdef V80
		case IO_SYNC :	// on dial lines - sync access mode
			io_sync_background () ;
			break ;
#endif

		case IO_FAX :
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
			if (CLASS_2_OR_20)
			{
				if (io_fax_c2_background () == FALSE)  // class 2 bg task
					G(io_state) = IO_IDLE;           // Set to idle when done
				break;
			}
#endif
			if ( io_fax_background () == FALSE )
				G(io_state) = IO_IDLE ;
			break ;

#if defined(VPCM_CLIENT)
		case IO_RETRAINING:
			// Don't let anything happen while we're retraining so
			// that slicer tables won't get messed up.
			if ( G(io_at_esc_detect) )
			{
				/* send dte receive byte to at task */
				if ( io_get_dte_rx_char ( &G(io_dte_rx_last_ch) ) )
					x_send_mail(IO_AT_DATA, AT_TASK, &G(io_dte_rx_last_ch), 1);
			}
			else
			{
				/* check for at escape sequence */
				io_at_esc_seq_detected();
				io_detect_inactivity();
			}
			break;
#endif

		case IO_V42 :
			// Get rid of unknown dlci values - voice frames for lapm data
			lapm_clean_rcv_frame();

			// handle lapm data frames
			new_state = lapm_background(LAPM_KEEP_STATE);
			if ( new_state == LAPM_TO_BUFFERED_MODE )
			{
				// LAPM negotiation failed.
				if ( G(x_modem_originate) == TRUE &&
					 (V42_MNP_BIT & G(S).ModemOptions.V42))
				{
					mnp_init();			// try MNP
				}
				else if (!(G(S).ModemOptions.V42 & V42_BUFFER_BIT))
				{
					// Buffered mode not allowed, send NO CARRIER.
					G(io_state) = IO_IDLE ;
					x_send_mail ( V42_REMOTE_DISC, DP_TASK, NULL, 0 ) ;
					G(x_status).TerminationCause = 4 ;	// protocol failure
				}
				else
				{
					// go to buffered mode (no EC)
					G(io_state) = IO_ONLINE ;
					G(lapm_state) = LAPM_IDLE ;
					/* put back in async user mode */
					x_send_mail ( DP_ASYNC_USER_MODE, DP_TASK, NULL, 0 ) ;
					x_send_mail ( IO_AT_CONNECT, AT_TASK, NULL, 0 ) ;
				}
			}
			if ( G(io_at_esc_detect) )
			{
				/* send dte receive byte to at task */
				if ( io_get_dte_rx_char ( &G(io_dte_rx_last_ch) ) )
					x_send_mail(IO_AT_DATA, AT_TASK, &G(io_dte_rx_last_ch), 1);
			}
			else
			{
				/* check for at escape sequence */
				io_at_esc_seq_detected();
				// Inactivity TimeOut in LAPM
				io_detect_inactivity () ;
			}
			break ;

		case IO_MNP :
			if ( mnp_background() == FALSE )
			{
				if (!(G(S).ModemOptions.V42 & V42_BUFFER_BIT))
				{
					G(io_state) = IO_IDLE ;
					// send NO CARRIER
					x_send_mail ( V42_REMOTE_DISC, DP_TASK, NULL, 0 ) ;
					G(x_status).TerminationCause = 4 ;	// protocol failure
				}
				else
				{
					G(io_state) = IO_ONLINE ;
					G(mnp_state) = MNP_IDLE ;
					/* put back in async user mode */
					x_send_mail ( DP_ASYNC_USER_MODE, DP_TASK, NULL, 0 ) ;
					x_send_mail ( IO_AT_CONNECT, AT_TASK, NULL, 0 ) ;
				}
			}
			if ( G(io_at_esc_detect) )
			{
				/* send dte receive byte to at task */
				if ( io_get_dte_rx_char ( &G(io_dte_rx_last_ch) ) )
					x_send_mail(IO_AT_DATA, AT_TASK, &G(io_dte_rx_last_ch), 1);
			}
			else
			{
				/* check for at escape sequence */
				io_at_esc_seq_detected();
				// Inactivity TimeOut in MNP
				io_detect_inactivity () ;
			}
			break ;

		case IO_CD_ON :
			// turn on the cd after the connect message is sent thru
			// serial port
#if defined(CS_4)
			if ( TRUE )     // turn on cd when data is written to app's buffer
#else
			if ( I(io_dte_tx_rptr) == I(io_dte_tx_wptr) )
#endif
			{
				// clear data in dce rx buffer - garbage for V.34 async
				// connection - workaround for dsp
				if ( (G(io_old_state) == IO_ONLINE) && G(V34Mode) )
					io_init_dce_rx_fifo () ; // init dce receive fifo
				if ( G(io_timer) != x_current_time () )
				{
					if (G(S).ModemOptions.CDControl == 1) // CD follows RS-232
						UART_cd_on () ;
#ifdef V80
					if ( G(S).ModemOptions.V42 == V42_SYNC_BUFFERED )
						io_sync_init () ;
#endif
					G(io_state) = G(io_old_state) ;
				}
				x_set_current_time ( &G(io_dte_inact_timer) ) ;
			 	G(io_dte_rx_old_ptr) = (byte *) I(io_dte_rx_wptr) ;
			 	G(io_dte_tx_old_ptr) = (byte *) I(io_dte_tx_wptr) ;
			}
			else
			{
				G(io_timer) = x_current_time () ;
			}
			break ;

#ifdef VOICE
#ifdef CALLER_ID
		case IO_CID :		/* receive caller id information */
			if ( io_rx_cid () == FALSE )
			{
				G(io_state) = IO_IDLE ;
				x_send_mail ( CALLER_ID_END, DP_TASK, NULL, 0 ) ;
			}
			break ;
#endif	//CALLER_ID

		case IO_VOICE :
			if ( io_voice_background () == FALSE )
			{
				G(io_state) = IO_IDLE ;
				x_send_mail ( VOICE_END, DP_TASK, NULL, 0 ) ;
				/* send OK, return back to voice cmd */
				x_send_mail ( AT_OK, AT_TASK, NULL, 0 ) ;
			}
			break ;
#endif
		case IO_DTE_INACTIVITY :
			// send data byte received from dte to at task
			if ( io_get_dte_rx_char ( &G(io_dte_rx_last_ch) ) )
			{
				x_send_mail ( IO_AT_DATA, AT_TASK, &G(io_dte_rx_last_ch), 1 ) ;
				G(io_state) = IO_IDLE ;
				x_debug_msg("io - idle from DTE_INACTIVITY") ;
			}
			else if (x_elapsed_time(G(io_timer))>
					 (1000*G(S).ModemOptions.DteInactivityTimer))
			{
				G(x_status).ud_TerminationCause = UD_TC_INACT_TIME_OUT;
				x_debug_msg("io - Dte Inactivity Timer expired") ;
				x_send_mail ( MC_ONHOOK, DP_TASK, NULL, 0 ) ;
				G(io_state) = IO_IDLE ;
			}
			break ;
#if defined(Z80_DEBUG_PRINT)
	case IO_DUMP_DSP:
		// need to shoot out DSP RAM to DTE
	{
		byte i, buf[8];
		word c = 0;
		dsp_ram dpram;

		// Delay so we don't overwhelm the DTE
		if (x_elapsed_time(G(io_dumpRamState).time) < 40)
			break;

		// print each DSP RAM location.  Assume that we'll
		// be able to spit out at least 16 every time
		// we get here.
		while (c < 0x10 && G(io_dumpRamState).ram.val)
		{
			// read DSP RAM (by asking DP to do it)
			dpram.loc = G(io_dumpRamState).ram.loc++;
			x_send_mail(DSP_READ_RAM, DP_TASK,
						(byte *)&dpram, sizeof(dsp_ram));

			// print it out as four hex digits
			buf[0] = '0';
			buf[1] = '0';
			i = (unsigned char) at_itoa(dpram.val, &buf[2], HEX);
			buf[2+i] = ' ';
			buf[3+i] = 0;
			if (2 == i)
			{
				// print leading zeros
				x_send_at_io_data(buf);
			}
			else
			{
				x_send_at_io_data(&buf[2]);
			}

			if (0 == (G(io_dumpRamState).ram.loc & 0x0f))
			{
				x_send_at_io_crlf();	// new line every 16 words
			}

			G(io_dumpRamState).ram.val--;
			c++;
		}
		if (!G(io_dumpRamState).ram.val)
		{
			// we're done with the dump.
			x_send_at_io_crlf();
			G(io_state) = G(io_old_state);		// restore IO_STATE
		}
		else
		{
			G(io_dumpRamState).time = x_current_time();
		}
	}
	break;
#endif
	}
}

/****************************************************************
Routine : io_task
Description :
	The main entry routine for io task.
Parameters in :
	cmd     	-	the modem command to execute
	mail_ptr	-	mail text pointer (parameters)
	mail_len	-	length of text
Parameters out :
	none
Revision History :
	Initials	Date     	Change
*****************************************************************/
void io_task ( MODEM_COMMAND cmd, byte *mail_ptr, word mail_len )
{
	switch ( cmd )
	{
		case MC_INIT :
			/* initialize variables */
			x_debug_msg ( "IO - received init command" ) ;
			io_init_task () ;
			break ;

		case MC_RESET :
			UART_ri_off () ;
			UART_cts_off () ;
			UART_cd_off () ;
			UART_dsr_off () ;
			G(io_uart_status) = 0 ;
			break ;

		case MC_PERIODIC :	/* call the periodic function */
			io_periodic_task () ;
			break ;

		case MC_OPTION_CHANGE :
			if ( G(S).ModemOptions.CDControl == 0 )  // CD always on
			{
				UART_cd_on () ;
			}
			else if ( G(S).ModemOptions.CDControl == 1)  // CD follows RS-232
			{
				if ( G(x_modem_state) == MS_ON_DIAL )
					UART_cd_on () ;  // cd ON when online or escape mode
				else 
					UART_cd_off () ;
			}
			if ( G(S).ModemOptions.DSRControl == 0 )	// force on
				UART_dsr_on () ;
			else
			{
				if ( G(x_modem_state) == MS_ON_DIAL )
					UART_dsr_on () ;
				else
					UART_dsr_off () ;
			}
			// - for buffered mode let the dsp do parity insertion & deletion
	   		// - for fax no parity
	   		// - for v42 mode the host does the parity insertion & deletion
			if ( G(io_state) == IO_ONLINE
					&& G(S).ModemOptions.V42 != V42_SYNC_BUFFERED )
			{
				x_send_mail ( MC_OPTION_CHANGE, DP_TASK, NULL, 0 ) ;
			}
			break ;

		case AT_IO_DATA :
			if (G(io_remote_control_mode))
			{
				word w;

				while (mail_len--)
				{
					w = (word) *mail_ptr++;
					io_write_dce_fifo(1, &w);
				}
			}
			else
			{
				while ( mail_len )
				{
					io_put_dte_tx_char ( *mail_ptr++ ) ;
					--mail_len ;
				}
			}
			break ;

		case DP_IO_CONNECT :
			if ( G(S).ModemOptions.DSRControl == 1 )
				UART_dsr_on () ;

#if defined(V34_FAX)
			if ( G(x_modem_mode) == MODEM_FAX
					&& NON_V34 == G(x_fax_v34mode) ) // V.17 fax mode
#else
			if ( G(x_modem_mode) == MODEM_FAX )		// fax mode
#endif // V34_FAX
			{
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
				if (CLASS_2_OR_20)
					signal_class2 (); // Inform class 2 bg task of connect
				else
#endif
				io_fax_init ( G(x_fax_state) ) ;
				if (G(x_fax_rate) == G(x_line_rate))
				{
					G(io_state) = IO_FAX ;
				}
				else
				{
					G(io_state) = IO_IDLE ;
					x_debug_msg ( "IO - rate mismatch" ) ;
				}
				x_send_mail ( IO_AT_CONNECT, AT_TASK, NULL, 0 ) ;
			}
#if defined(V34_FAX)
			else if( NON_V34 != G(x_fax_v34mode) )
			{
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
				if (CLASS_2_OR_20)
					signal_class2 ();                        // Inform class 2 background task of connect
				else
#endif                                            
				io_fax_init( G(x_fax_state) ) ;
				G(io_state) = IO_FAX ;
				x_send_mail( IO_AT_CONNECT, AT_TASK, NULL, 0 ) ;
			}
#endif // V34_FAX
			else
			{
				G(x_modem_ec) = EC_NO ;
				G(io_at_esc_detect) = FALSE ;
				G(io_at_esc_state) = AT_ESC_INIT_STATE ;
				if ( G(x_modem_state) == MS_DTE_LOOPBACK )
				{
					G(io_state) = IO_DTE_LOOPBACK ;
					x_send_mail ( IO_AT_CONNECT, AT_TASK, NULL, 0 ) ;
				}
				else if ( G(x_modem_state) == MS_DCE_LOOPBACK )
				{
					G(io_state) = IO_DCE_LOOPBACK ;
				}
				else if ( G(x_modem_state) == MS_LOCAL_TEST )
				{
					G(io_state) = IO_ANALOG_LOOPBACK ;
					io_init_dce_rx_fifo () ;	// init dce receive  fifo
					x_send_mail ( IO_AT_CONNECT, AT_TASK, NULL, 0 ) ;
				}
				// no EC for <= 300 bps, and v.23
				else if ( (G(x_line_rate) <= MR_300) ||
						  (G(S).ModemOptions.V23mode == TRUE) )
				{
					// disconnect if reliable mode - V42 or MNP
					if (!(G(S).ModemOptions.V42 & V42_BUFFER_BIT))
					{
						G(io_state) = IO_IDLE ;
						// send NO CARRIER
						x_send_mail ( V42_REMOTE_DISC, DP_TASK, NULL, 0 ) ;
					}
					else
					{
						G(io_state) = IO_ONLINE ;
						x_send_mail ( IO_AT_CONNECT, AT_TASK, NULL, 0 ) ;
					}
				}
				else
				{
					if (G(S).ModemOptions.V42 & V42_LAPM_BIT)
					{
						//G(io_state) = IO_V42 ; /* done in lapm_init */
 						lapm_init () ;
					}
					else if (G(S).ModemOptions.V42 & V42_MNP_BIT)
					{
						//G(io_state) = IO_MNP ; /* done in mnp_init */
						mnp_init() ;
					}
#ifdef V80
					else if ( G(S).ModemOptions.V42 == V42_SYNC_BUFFERED )
					{
						G(io_state) = IO_SYNC ;
						x_send_mail ( IO_AT_CONNECT, AT_TASK, NULL, 0 ) ;
					}
#endif
					else
					{
						G(io_state) = IO_ONLINE ;
						x_send_mail ( IO_AT_CONNECT, AT_TASK, NULL, 0 ) ;
					}
				}
			}
			break ;

		case DP_IO_RETRAIN_OVER :
#ifdef V80
			// send <EM><rate> message after retrain for sync mode
			if ( G(io_state) == IO_SYNC )
			{
				io_sync_retrain_done ( TRUE ) ;
			}
#endif

#if defined(VPCM_CLIENT)
			if (IO_RETRAINING == G(io_state))
			{
				x_debug_msg("io_state = io_old_state");
				G(io_state) = G(io_old_state);
			}
#endif

			// reset lapm timer each time we finish retrain - see lapm
			// connect state
			lapm_reset_timer () ;		// reset timer T401
			break ;

		case DP_IO_RETRAIN_START :
#ifdef V80
			// send <EM><retrain> message before retrain for sync mode
			if ( G(io_state) == IO_SYNC )
			{
				io_sync_retrain_done ( FALSE ) ;
			}
#endif

#if defined(VPCM_CLIENT)
			if (IO_RETRAINING != G(io_state))
			{
				x_debug_msg("io_state = IO_RETRAINING");
				G(io_old_state) = G(io_state);
				G(io_state) = IO_RETRAINING;
			}
#endif
			break ;

		case AT_IO_ON_LINE :
			// do not send connect message after retrain for sync mode
#ifdef V80
			if ( G(io_state) == IO_SYNC )
			{
				io_sync_on_line () ;
			}
			else
#endif
#if defined(V34_FAX)
			if( NON_V34 != G(x_fax_v34mode) )
			{
					// starting the CM/JM exhange without ANSam
				x_send_mail( FAXV34_NO_ANSAM_START, DP_TASK, NULL, 0 ) ;
			}
			else
#endif
			{
				G(io_at_esc_detect) = FALSE ;
				G(io_at_esc_state) = AT_ESC_INIT_STATE ;
				x_send_mail ( IO_AT_CONNECT, AT_TASK, NULL, 0 ) ;
			}
			break ;

		case AT_IO_DISCONNECT :
			G(io_dtr_timer) = 0;		// ensure G(io_dtr_timer) is inactive
			G(x_status).ud_TerminationCause = UD_TC_DTE_HANDUP;
#if defined(V34_FAX)
			if ( G(x_modem_mode) == MODEM_FAX
					&& NON_V34 == G(x_fax_v34mode) ) // V.17 fax mode
#else
			if ( G(x_modem_mode) == MODEM_FAX )		// fax mode
#endif // V34_FAX
			{
//				io_fax_disconnect () ;
				x_send_mail ( MC_DISCONNECT, DP_TASK, NULL, 0 ) ;
			}
			else if ( G(io_state) == IO_V42 )
				lapm_disconnect () ;
			else if ( G(io_state) == IO_MNP )
				mnp_disconnect () ;
#if defined(CS_V110)
			else if ( G(io_state) == IO_V110 )	// V110
				cs_v110_disconnect();
#endif
			else
				x_send_mail ( MC_DISCONNECT, DP_TASK, NULL, 0 ) ;
			break ;

		case DP_IO_DISCONNECT :
			x_debug_msg("DP_IO_DISCONNECT");
			G(io_remote_control_mode) = 0;
			io_init_dce_tx_fifo () ;	// init dce transmit fifo
			io_init_dce_rx_fifo () ;	// init dce receive  fifo
			UART_Flush ( 0 ) ;      	// init dte receive  fifo
			// do not flush dte transmit fifo - problems in V.80
#ifdef V80
			if ( G(io_state) == IO_SYNC )
			{
				G(io_state) = IO_IDLE ;
				io_sync_disconnect () ;
				G(x_dial_residual) = MR_CD_DISCONNECT ;
			}
			else
#endif
			{
				UART_Flush(1);     	// init dte transmit fifo
			}

			G(io_state) = IO_IDLE ;
			if ( G(S).ModemOptions.CDControl == 0 )
				UART_cd_on () ;
			else
				UART_cd_off () ;
			if ( G(S).ModemOptions.DSRControl == 1 )
				UART_dsr_off () ;
			UART_xoff_off () ;
#if defined ROME
			printf("Calling t1_modem_onhook( ModemNum =0x%x)\n",ModemNum);
			t1_modem_onhook( ModemNum );
#endif
			x_send_mail ( IO_AT_DISCONNECT, AT_TASK, NULL, 0 ) ;
			break ;

		case DP_IO_FAX_CARRIER_LOSS :
			io_fax_disconnect () ;
			if ( G(S).ModemOptions.CDControl == 0 )
				UART_cd_on () ;
			else
				UART_cd_off () ;
			if ( G(S).ModemOptions.DSRControl == 1 )
				UART_dsr_off () ;
			break ;

		case DP_IO_V54_ORIGINATE :
			io_tx_v54 ( 0 ) ;
			break ;

		case DP_IO_V54_TERMINATE :
			io_tx_v54 ( 1 ) ;
			break ;

		case AT_IO_CD_ON :		// turn on cd after the connect message
			if (IO_RETRAINING != G(io_state))
			{
				G(io_old_state) = G(io_state) ;
				G(io_state) = IO_CD_ON ;
				G(io_timer) = x_current_time () ;
			}
			break ;

		case IO_IDLE_STATE :		// set G(io_state) to idle 
			G(io_state) = IO_IDLE ;
			G(io_timer) = x_current_time () ;
			break ;

		case AT_IO_FAX_STATE :		// set G(io_state) to IO_FAX
			G(io_state) = IO_FAX ;
			io_fax_init ( FAX_RX_START ) ;
			G(io_timer) = x_current_time () ;
			break ;

		case IO_WAKEUP_CMD :
			x_send_mail ( DP_WAKEUP, DP_TASK, NULL, 0 ) ;
			G(io_state) = IO_IDLE ;
			G(io_timer) = x_current_time () ;
			break ;

		case IO_SLEEP_CMD :
			io_sleep () ;
			break ;

#ifdef VOICE
		case DP_RING :
			x_debug_msg("io - DP_RING") ;
#ifdef CALLER_ID
			io_cid_init () ;
			G(io_state) = IO_CID ;
#endif	//CALLER_ID
			break ;

		case VOICE_START :
			io_start_dce_transmit () ;
			break ;

		case VOICE_TX :
			G(io_state) = IO_VOICE ;
			io_voice_init ( IO_VOICE_TX ) ;
			break ;

		case VOICE_RX :
			G(io_state) = IO_VOICE ;
			io_voice_init ( IO_VOICE_RX ) ;
			break ;

		case VOICE_DUALPLEX_TX_RX :
			G(io_state) = IO_VOICE ;
			io_voice_init(IO_VOICE_DUALPLEX_TX_RX);
			break;

		case VOICE_END :
			x_debug_msg ( "IO - VOICE_END" ) ;
			io_init_dce_tx_fifo () ;	// init dce transmit fifo
			io_init_dce_rx_fifo () ;	// init dce receive  fifo
			UART_Flush ( 0 ) ;      	// init dte receive  fifo
			// do not flush dte transmit fifo
			G(io_state) = IO_IDLE ;
			break ;
#endif

#ifdef RADISH
		case RADISH_IO_TASK :
			IoRadishTask ( mail_len, mail_ptr ) ;
			break ;
#endif

		case IO_LOOPBACK_ABORT :
			G(io_at_esc_detect) = TRUE ;
			G(io_state) = IO_ONLINE ;
			break ;

		case IO_INACTIVITY_STATE :
			x_debug_msg("IO_INACTIVITY_STATE") ;
			G(io_timer) = x_current_time () ;
			G(io_state) = IO_DTE_INACTIVITY ;
			break ;

		case DP_IO_DIAL_OR_ANSWER :
			x_debug_msg ( "DP_IO_DIAL_OR_ANSWER" ) ;
			G(io_state) = IO_DIAL_OR_ANSWER;
			G(io_timer) = x_current_time () ;
			break ;

#if defined(Z80_DEBUG_PRINT)
		// we want to dump DSP memory.
		case IO_DUMP_DSP_MEM:
			// we're using the same variable as IO_RETRAINING to save
			// the state we're going back to.  If we retrain while
			// dumping this memory, there could be problems.
			if (IO_RETRAINING == G(io_state))
				break;

			// save old IO state so we can go back.
			G(io_old_state) = G(io_state);
			G(io_dumpRamState).ram = *((dsp_ram *) mail_ptr);
			x_debug_msg("ram.val =");
			sendHexWord(G(io_dumpRamState).ram.val);
			x_debug_msg("      ram.loc =");
			sendHexWord(G(io_dumpRamState).ram.loc);sendCrLf();
			G(io_dumpRamState).time = x_current_time();
			G(io_state) = IO_DUMP_DSP;
			break;
#endif // Z80_DEBUG_PRINT
#if defined(CS_V110)
		case DP_IO_V110:
			x_debug_msg ( "IO - msg DP_IO_V110" ) ;
			G(io_state) = IO_V110;
			G(io_at_esc_detect) = FALSE ;
			G(io_at_esc_state) = AT_ESC_INIT_STATE ;
			break;
#endif

		case AT_IO_BREAK :
			io_send_break () ;
			break ;
		default :
			x_debug_msg("IO - received unknown mail");
			break ;
	}
}
