/*name and version number:@(#)dpvoice.c	1.379*/
/*date of get: 		  09/11/00 16:48:52*/
/*date of delta:	  09/11/00 13:58:45*/
/****************************************************************
File :	dpvoice.c
Description :
	Contains all voice and speaker phone functions related to the
	dsp16a data pump interface.

Procedures Contained :
	dp_start_tad
	dp_download_tad
	dp_tones_detected
	dp_silence_detected
	dp_generate_tones
	dp_cid_cmd
	dp_cid_disable
	dp_dron
	dp_drof
	dp_ring_report
	dp_synth_ring_freq1
	dp_synth_ring_freq2
	dp_synth_ring_init
	dp_synth_ring_on
	dp_synth_ring_off
	dp_voice_ring
	dp_voice_ring_init
	dp_ch_playback
Revision History :
	Initials	Date		Change
*****************************************************************/

//#define Z80_DEBUG_THIS_FILE
#include "llglob_d.h"

#ifdef VOICE
#include "dpglob.h"
#include "ioglob_d.h"
#include "z80glob.h"
#include "v42bis.h"

#ifdef AM_DEBUG
#include "amdebug.h"
#endif
#ifdef KORTEX
#include "AMGLOB_D.H"
time_t kx_timer;
#endif
#ifdef G729A
#include "dpctad.h"
#endif
#include "allglobs.h"

/****************************************************************
	Global variables
*****************************************************************/
extern word at_itoa( word num, byte *str, byte format);
extern byte convert_dtmf_digit ( byte *ptr, byte *dtmf_digit ) ;

const word dp_tone_freqcoef[] = {
		F300S, F300C, F400S, F400C, F500S, F500C, 
		F600S, F600C, F700S, F700C, F800S, F800C, 
		F900S, F900C, F1000S, F1000C, F1100S, F1100C, 
		F1200S, F1200C, F1300S, F1300C, F1400S, F1400C,
		F1500S, F1500C, F1600S, F1600C, F1700S, F1700C, 
		F1800S, F1800C, F1900S, F1900C, F2000S, F2000C, 
		F2100S, F2100C, F2200S, F2200C, F2300S, F2300C, 
		F2400S, F2400C, F2500S, F2500C, F2600S, F2600C, 
		F2700S, F2700C, F2800S, F2800C, F2900S, F2900C, 
		F3000S, F3000C 
} ;

const word dp_voice_f11khz[] = {
		0x5700 ,	/* K - iir1    BPF */

		0xc7c9 ,	/*d(1,1) - iir1*/
		0x287a ,	/*d(1,2) - iir1*/
		0x0000 ,	/*n(1,1) - iir1*/
		0xef6b ,	/*n(1,2) - iir1*/
		0x1095 ,	/*n(1,0) - iir1*/

		0xff27 ,	/*d(2,1) - iir1*/
		0x3517 ,	/*d(2,2) - iir1*/
		0x0c47 ,	/*n(2,1) - iir1*/
		0x0b5d ,	/*n(2,2) - iir1*/
		0x0b5d ,	/*n(2,0) - iir1*/

		0x9ab2 ,	/*d(3,1) - iir1*/
		0x39b6 ,	/*d(3,2) - iir1*/
		0x83bc ,	/*n(3,1) - iir1*/
		0x4192 ,	/*n(3,2) - iir1*/
		0x4192 ,	/*n(3,0) - iir1*/

		0x2240 ,	/*K - iir2     LPF */

		0x8a33 ,	/*d(1,1) - iir2*/
		0x3711 ,	/*d(1,2) - iir2*/
		0xfb91 ,	/*n(1,1) - iir2*/
		0x046c ,	/*n(1,2) - iir2*/
		0x046c ,	/*n(1,0) - iir2*/

		0x8930 ,	/*d(2,1) - iir2*/
		0x3bea ,	/*d(2,2) - iir2*/
		0xeeec ,	/*n(2,1) - iir2*/
		0x099f ,	/*n(2,2) - iir2*/
		0x099f ,	/*n(2,0) - iir2*/

		0x8833 ,	/*d(3,1) - iir2*/
		0x3f0b ,	/*d(3,2) - iir2*/
		0xb02e ,	/*n(3,1) - iir2*/
		0x2b56 ,	/*n(3,2) - iir2*/
		0x2b56 		/*n(3,0) - iir2*/
} ;

const word dp_dtmf_f11khz[] = {
		F1209C11,	/* ram1c-DTMF high 1*/
		F1336C11,	/* ram1d-DTMF high 2*/
		F1477C11,	/* ram1e-DTMF high 3*/
		F1633C11, 	/* ram1f-DTMF high 4*/
		F697C11,	/* ram20-DTMF low 1 */
		F770C11, 	/* ram21-DTMF low 2 */
		F852C11, 	/* ram22-DTMF low 3 */
		F941C11, 	/* ram23-DTMF low 4	*/
		F1100C11, 	/* ram24-fax calling tone */
		F1300C11 	/* ram25-v25 data calling tone */
} ;

const word dp_dtmf_f8khz[] = {
		F1209C8,	/* ram1c-DTMF high 1*/
		F1336C8,	/* ram1d-DTMF high 2*/
		F1477C8,	/* ram1e-DTMF high 3*/
		F1633C8, 	/* ram1f-DTMF high 4*/
		F697C8, 	/* ram20-DTMF low 1 */
		F770C8, 	/* ram21-DTMF low 2 */
		F852C8, 	/* ram22-DTMF low 3 */
		F941C8, 	/* ram23-DTMF low 4	*/
		F1100C8,  	/* ram24-fax calling tone */
		F1300C8 	/* ram25-v25 data calling tone */
} ;

const word dp_voice_f8khz[] = {
		0x4200,	/* K - iir1    BPF */

		0xf601,	/*d(1,1) - iir1*/
		0x20e7,	/*d(1,2) - iir1*/
		0x0000,	/*n(1,1) - iir1*/
		0xf30f,	/*n(1,2) - iir1*/
		0x0cf1,	/*n(1,0) - iir1*/

		0x40f7,	/*d(2,1) - iir1*/
		0x345c,	/*d(2,2) - iir1*/
		0x4231,	/*n(2,1) - iir1*/
		0x2263,	/*n(2,2) - iir1*/
		0x2263,	/*n(2,0) - iir1*/

		0xaf78,	/*d(3,1) - iir1*/
		0x35a8,	/*d(3,2) - iir1*/
		0x99d8,	/*n(3,1) - iir1*/
		0x3463,	/*n(3,2) - iir1*/
		0x3463,	/*n(3,0) - iir1*/

		0x2210,	/*K - iir2     LPF */

		0x8eb3,	/*d(1,1) - iir2*/
		0x33b2,	/*d(1,2) - iir2*/
		0xfdc6,	/*n(1,1) - iir2*/
		0x0541,	/*n(1,2) - iir2*/
		0x0541,	/*n(1,0) - iir2*/

		0x8f39,	/*d(2,1) - iir2*/
		0x3a55,	/*d(2,2) - iir2*/
		0xf06b,	/*n(2,1) - iir2*/
		0x09d9,	/*n(2,2) - iir2*/
		0x09d9,	/*n(2,0) - iir2*/

		0x8ef3,	/*d(3,1) - iir2*/
		0x3ea9,	/*d(3,2) - iir2*/
		0xb1b5,	/*n(3,1) - iir2*/
		0x2df6,	/*n(3,2) - iir2*/
		0x2df6 	/*n(3,0) - iir2*/
};

#ifdef CALLER_ID
#ifdef KORTEX
const word caller_id_tab[] = {
	0x1c, 0x00,
	0x1d, 0x00,
	0x1e, 0x00,
	0x1f, 0x00,
	0x20, 0x00,
	0x21, 0x00,
	0x22, 0x00,
	0x23, 0x00,
	0x24, 0x00,
	0x25, 0x00,
	0x01, 0x00,	// clear v32 rates
	0x02, 0x08,	// selecting bell 202 1200 bits/s
	0x0c, 0x00,	// clear v.17 rate selection
	0x3d, 0x186	// clear parallel data mode
};

const word v23_cid_tab[] = {
	0xeca, 0x118c,
	0xecb, 0x3cd0,
	0xecc, 0xc171,
	0xecd, 0x00f8,
	0xece, 0xd000,
	0xecf, 0xc000,
	0xed0, 0x5050,
	0xed1, 0x0138,
	0xed2, 0x6050,
	0xed3, 0xc000,
	0xf20, 0xceca
};
#else
const word caller_id_tab[] = {
	0x1c, 0x00,
	0x1d, 0x00,
	0x1e, 0x00,
	0x1f, 0x00,
	0x20, 0x00,
	0x21, 0x00,
	0x22, 0x00,
	0x23, 0x00,
	0x24, 0x00,
	0x25, 0x00,
	0x01, 0x00,	// clear v32 rates
	0x02, 0x08,	// selecting bell 202 1200 bits/s
	0x0c, 0x00,	// clear v.17 rate selection
	0x3d, 0x00	// clear parallel data mode
};

#ifdef HOMOL
const word v23_cid_tab[] = {
	0xeca, 0x118c,
	0xecb, 0x3cd0,
	0xecc, 0xc171,
	0xecd, 0x00f8,
	0xece, 0xd000,
	0xecf, 0xc000,
	0xed0, 0x5050,
	0xed1, 0x0138,
	0xed2, 0x6050,
	0xed3, 0xc000,
	0xf20, 0xceca
};
#endif
#endif
#endif	//CALLER_ID

const word energy_threshold[] = {
	41,		// -58dB
	46,		// -57dB
	52,		// -56dB
	58,		// -55dB
	65,		// -54dB
	73,		// -53dB
	80,		// -52dB
	92,		// -51dB
	103,	// -50dB
	116,	// -49dB
	130,	// -48dB
	146,	// -47dB
	164,	// -46dB
	184,	// -45dB
	206,	// -44dB
	231, 	// -43dB
	260 	// -42dB
};

/****************************************************************
Routine : dp_set_iirs
Description :set the two iir filters for CO tones and trouble tone
             detection
*****************************************************************/
void dp_set_iirs ( void )
{
	word tmp ;

	/* set iir coefficients, iir1 is 1 - 2.8 khz BPF, iir2 is 600 LPF */
#ifdef KORTEX
	// iir1, filtre large bande, -6-38 dBm */
	// iir2, filtre de detection de l'occupation.
	// Programmation du seuil de detection.
	if (G(S).ModemOptions.CountryId == ITALY)
	{
		// Seuil de detection de l'occupation selon les registres italiens
		dp_write_dsp_ram (IIR1_THRESHOLD_ADDR, 30) ;	//iir1 threshold, -6-38dB
		dp_write_dsp_ram (IIR2_THRESHOLD_ADDR, 37) ;	//iir2 threshold, -6-38dB
	}
	else
	{
		dp_write_dsp_ram (IIR1_THRESHOLD_ADDR, 22) ;	/*iir1 threshold, -25dB */
		dp_write_dsp_ram (IIR2_THRESHOLD_ADDR, 29) ;	/*iir2 threshold, -27dB */
	}
#else
	dp_write_dsp_ram (IIR1_THRESHOLD_ADDR, 15) ;	/*iir1 threshold, -17dB */
	dp_write_dsp_ram (IIR2_THRESHOLD_ADDR, 22) ;	/*iir2 threshold, -24dB */
#endif	//KORTEX

	if ( G(S).ModemOptions.VoiceSamplingRate == VSM_11KHZ )
	{
		dp_write_dsp_array ( IIR1_K_ADDR, (word *)dp_voice_f11khz,
							(byte)(sizeof(dp_voice_f11khz)/sizeof(word)) ) ;
	}
	else		// assume 8KHZ, 7.2Khz also uses this filter
	{
		dp_write_dsp_array ( IIR1_K_ADDR, (word *)dp_voice_f8khz,
							(byte)(sizeof(dp_voice_f8khz)/sizeof(word)) ) ;
	}
	tmp = (word) (0x0020 | dp_read_dsp_ram(0x86));	// turn on IIR filters
	dp_write_dsp_ram ( 0x86, tmp ) ;

	// initialize timers
	G(dp_busy_cnt) = 0 ;
	G(dp_busy_on_cadence) = 0 ;
	G(dp_busy_off_cadence) = 0 ;
	G(dp_busy_state) = DP_ENERGY_OFF ;
	G(dp_busy_tone_timer) = x_current_time () ;

	G(dp_trouble_cnt) = 0 ;
	G(dp_trouble_on_cadence) = 0 ;
	G(dp_trouble_off_cadence) = 0 ;
	G(dp_trouble_state) = DP_ENERGY_OFF ;
	G(dp_trouble_tone_timer) = x_current_time () ;

	G(dp_dial_tone_timer) = x_current_time () ;
	G(dp_timer) = x_current_time () ;
#ifdef KORTEX
	kx_timer = AmStartSecondTimer(12);	// Reset du timer de detect. du silence
#endif
}

word dp_set_threshold ()
{
	/*
	 * set in-band energy threshold for silence detection,
	 * dB value of 46 corresponding to linear value of 80,
	 * and is -52dB on the codec
	 */
	if ( (G(S).ModemOptions.SilenceSensitivity >= 122) &&
	     (G(S).ModemOptions.SilenceSensitivity <= 138) )
		return ( (word)(174-G(S).ModemOptions.SilenceSensitivity) ) ;
	else
		return ( 46 ) ;
}

/****************************************************************
Routine : dp_detect_dtmf
Description : Detect DTMF tones and fax and data calling tones.
*****************************************************************/
void dp_detect_dtmf ( void )
{
	word threshold ;

#ifdef KORTEX
	if (G(S).ModemOptions.CountryId == ITALY)
	{
		dp_write_dsp_ram ( 0x37, 20) ;		// Le seuil du silence
	}
	else
	{
		threshold = dp_set_threshold () ;
		dp_write_dsp_ram ( 0x37, threshold ) ;
	}
#else
	threshold = dp_set_threshold () ;
	dp_write_dsp_ram ( 0x37, threshold ) ;
#endif

	// set the two iir filters for CO tones and trouble tone detection
	dp_set_iirs () ;

	 // set up parameters for tone detectors
	dp_write_dsp_ram (0x27, 0x0) ;		// ram27-clr number_of_tones to 0
	dp_write_dsp_ram (0x28, 0x0) ;		// ram28-clr tones_found to 0

#ifdef KORTEX
	dp_write_dsp_ram (0x26, 45) ;		// ram26-rcv threshold -45dB
#else
	dp_write_dsp_ram (0x26, 30) ;		// ram26-rcv threshold -36dB
#ifdef HOMOL
	if ( G(S).ModemOptions.CountryId == FRANCE )
		dp_write_dsp_ram (0x26, 47) ;		// ram26-rcv threshold -45dB
#endif	// HOMOL
#endif	// KORTEX

	if ( G(S).ModemOptions.VoiceSamplingRate == VSM_11KHZ )
	{
		dp_write_dsp_array ( 0x1c, (word *)dp_dtmf_f11khz,
							(byte)(sizeof(dp_dtmf_f11khz)/sizeof(word)) ) ;
		dp_write_dsp_ram (0xfc0, F1100C11); 	/* ramfc0-additional fax calling tone detector*/
#ifdef HOMOL
		if ( G(S).ModemOptions.CountryId == FRANCE ) 
		{
			dp_write_dsp_ram (0x24, F1081C11); 	/* ram24-fax calling-1081*/
			dp_write_dsp_ram (0xfc0, F1119C11); 	/* ramfc0-additional fax calling tone detector*/
		}
#endif
	}

	else	// assume it is 8kHz
	{
		dp_write_dsp_array ( 0x1c, (word *)dp_dtmf_f8khz,
							(byte)(sizeof(dp_dtmf_f8khz)/sizeof(word)) ) ;
		dp_write_dsp_ram (0xfc0, F1100C8); 	/* ramfc0-additional fax calling tone detector*/
#ifdef HOMOL
		if ( G(S).ModemOptions.CountryId == FRANCE ) 
		{
			dp_write_dsp_ram (0x24, 0x2a49); 	/* ram24-fax calling-1081*/
			dp_write_dsp_ram (0xfc0, 0x28d5); 	/* ramfc0-additional fax calling tone detector*/
		}
#endif
	}

	dp_modem_command ( DETECT_TONES, 11, 0 ) ;
#ifdef KORTEX
	dp_regandor (0xDA, 0xef, 0x10) ;	// ICS2 commute en BIOA5 petit bug qui
										//  rend les boutons inaccessibles
#endif

	G(dp_voice_timer1) = x_current_time () ;
	G(dp_voice_timer2) = x_current_time () ;
	G(dp_voice_timer3) = x_current_time () ;
	G(dp_fax_tone_on) = 0 ;
	G(dp_fax_tone_off) = 0 ;
	G(dp_data_tone_on) = 0 ;
	G(dp_data_tone_off) = 0 ;
	G(dp_fax_tone_state) = DP_ENERGY_OFF ;
	G(dp_data_tone_state) = DP_ENERGY_OFF ;
	if ( G(dp_tad_downloaded) == FALSE )
	{
		G(dp_dtmf_end) = TRUE ;
		G(dp_dtmf_digit) = FALSE ;
		G(dp_dtmf_old) = FALSE ;
	}
	G(dp_dtmf_state) = DP_ENERGY_OFF ;
}

/****************************************************************
Routine : dp_fax_tone_detected
Description : See if fax calling tone (1100Hz) detected
*****************************************************************/
byte dp_fax_tone_detected ( void )
{
	if ( ! (G(S).ModemOptions.VoiceEventMask & EVENT_FAX_CALLING_TONE) )
		return ( FALSE ) ;

	switch ( G(dp_fax_tone_state) )
	{
		case DP_ENERGY_ON :
			if ( !(G(dp_reg16) & 0x21) )
			{
				//x_debug_msg("FAX_ON") ;
				G(dp_fax_tone_on) = x_elapsed_time(G(dp_voice_timer1)) ;
				G(dp_voice_timer1) = x_current_time () ;
				G(dp_fax_tone_state) = DP_ENERGY_OFF ;
			}
			break ;
		case DP_ENERGY_OFF :
			if ( G(dp_reg16) & 0x21)
			{
				//x_debug_msg("FAX_OFF") ;
#ifdef HOMOL
				if ( ( G(S).ModemOptions.CountryId != FRANCE )
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
					 || ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
					 || ( dp_read_dsp_ram (0x31) > 500 )
					|| ( dp_read_dsp_ram (0xfd8) > 500 ) )
#endif
				{
					G(dp_fax_tone_off) = x_elapsed_time(G(dp_voice_timer1));
					G(dp_voice_timer1) = x_current_time () ;
					G(dp_fax_tone_state) = DP_ENERGY_ON ;
				}
			}
			break ;
	}

	// fax calling tone is 500msec on and 3.5sec off(or 2.5sec)
	if ( (G(dp_fax_tone_on) >= 400)&&(G(dp_fax_tone_on) <= 700)
#ifdef KORTEX						//SES - loosen requirements for tone_off
	   && (G(dp_fax_tone_off) >= 500)	//detect for Kortex.  Playing the greeting
#else								//seems to interfere with tone_off detection.
	   && (G(dp_fax_tone_off) >= 1500)
#endif
	   &&(G(dp_fax_tone_off) <= 4000) )
	{
		G(dp_fax_tone_on) = 0 ;	// reset cadence
		G(dp_fax_tone_off) = 0 ;
		return ( TRUE ) ;
	}

	return ( FALSE ) ;
}

/****************************************************************
Routine : dp_data_tone_detected
Description : See if data calling tone (1300Hz) detected
*****************************************************************/
byte dp_data_tone_detected ( void )
{
	if ( !(G(S).ModemOptions.VoiceEventMask & EVENT_DATA_CALLING_TONE) )
		return ( FALSE ) ;
	switch ( G(dp_data_tone_state) )
	{
		case DP_ENERGY_ON :
			if ( !(G(dp_reg16) & 0x02) )
			{
			//	x_debug_msg("DATA_ON") ;
				G(dp_data_tone_on) = x_elapsed_time(G(dp_voice_timer2)) ;
				G(dp_voice_timer2) = x_current_time () ;
				G(dp_data_tone_state) = DP_ENERGY_OFF ;
			}
			break ;
		case DP_ENERGY_OFF :
			if ( G(dp_reg16) & 0x02 )
			{
			//	x_debug_msg("DATA_OFF") ;
				G(dp_data_tone_off) = x_elapsed_time(G(dp_voice_timer2));
				G(dp_voice_timer2) = x_current_time () ;
				G(dp_data_tone_state) = DP_ENERGY_ON ;
			}
			break ;
	}

	/* data calling tone is 0.5sec-0.7sec on and 1.5sec-2s off */
	if ( (G(dp_data_tone_on) >= 450)&&(G(dp_data_tone_on) <= 750)
       &&(G(dp_data_tone_off) >= 1450)&&(G(dp_data_tone_off) <= 2050) )
	{
		G(dp_data_tone_on) = 0 ; 	// reset cadence
		G(dp_data_tone_off) = 0 ;
		return ( TRUE ) ;
	}

	return ( FALSE ) ;
}

/****************************************************************
Routine : dp_validate_dtmf
Description : Validate the detected dtmf digits
*****************************************************************/
byte dp_validate_dtmf ( void )
{
	word high_power, low_power, loc ;
	word energy1, energy2 ;
	word ratio, low_tone_limit, high_tone_limit ;

	high_power = 0 ;
	low_power = 0 ;
	loc = 0 ;
	switch ( G(dp_reg20) & 0xf )
	{
		case 0x1:
			loc = 0x29 ;
			break ;
		case 0x2:
			loc = 0x2A ;
			break ;
		case 0x4:
			loc = 0x2B ;
			break ;
		case 0x8:
			loc = 0x2C ;
			break ;
	}
	if ( loc != 0 )
		high_power = dp_read_dsp_ram ( loc ) ;

	loc = 0 ;
	switch ( G(dp_reg20) & 0xf0 )
	{
		case 0x10 :
			loc = 0x2D ;
			break ;
		case 0x20 :
			loc = 0x2E ;
			break ;
		case 0x40 :
			loc = 0x2F ;
			break ;
		case 0x80 :
			loc = 0x30 ;
			break ;
	}
	if ( loc != 0 )
		low_power = dp_read_dsp_ram ( loc ) ;
	energy1 = dp_read_dsp_ram (IIR1_ENERGY_ADDR) ;
	energy2 = dp_read_dsp_ram (IIR2_ENERGY_ADDR) ;
	if ( ( energy1 < 500 ) || ( energy1 > 4000 ) )
		ratio = 6 ;
	else
		ratio = 10 ;

	low_tone_limit = 250 ;
	high_tone_limit = 350 ;
	if (( G(dp_vt_cntrl) == TAD_NEAR_RECORD )
		||( G(dp_vt_cntrl) == TAD_NEAR_PLAYBACK ))
	{
		ratio = 4 ;
		low_tone_limit = 150 ;
		high_tone_limit = 100 ;
	}

#ifdef HOMOL
	if ( G(S).ModemOptions.CountryId == FRANCE )
	{
		low_tone_limit = 150 ;
		high_tone_limit = 100 ;
	}
#endif

	if ( ( high_power < high_tone_limit ) || ( low_power < low_tone_limit )
		|| (( G(dp_vsp)== FALSE) && ( energy1 / (1+energy2) < ratio )) )
		return ( FALSE ) ;
	return ( TRUE ) ;
}

/****************************************************************
Routine : dp_get_dtmf_digit
Description : return dtmf char.
*****************************************************************/
byte dp_get_dtmf_digit(void)
{
	byte digit = FALSE;

	switch (G(dp_reg20))
	{
	case 0x82 :		// 0
		digit = '0' ;
		break ;
	case 0x11 :		// 1
		digit = '1' ;
		break ;
	case 0x12 :		// 2
		digit = '2' ;
		break ;
	case 0x14 :		// 3
		digit = '3' ;
		break ;
	case 0x21 :		// 4
		digit = '4' ;
		break ;
	case 0x22 :		// 5
		digit = '5' ;
		break ;
	case 0x24 :		// 6
		digit = '6' ;
		break ;
	case 0x41 :		// 7
		digit = '7' ;
		break ;
	case 0x42 :		// 8
		digit = '8' ;
		break ;
	case 0x44 :		// 9
		digit = '9' ;
		break ;
	case 0x81 :		// *
		digit = '*' ;
		break ;
	case 0x84 :		// #
		digit = '#' ;
		break ;
	case 0x18 :		// A
		digit = 'A' ;
		break ;
	case 0x28 :		// B
		digit = 'B' ;
		break ;
	case 0x48 :		// C
		digit = 'C' ;
		break ;
	case 0x88 :		// D
		digit = 'D' ;
		break ;
	}
	return digit;
}

/****************************************************************
Routine : dp_dtmf_detected
Description : See if dtmf digits are detected
*****************************************************************/
byte dp_dtmf_detected ( void )
{
	if ( ! (G(S).ModemOptions.VoiceEventMask & EVENT_DTMF) ) 
		return ( FALSE ) ;
	switch ( G(dp_dtmf_state) )
	{
		case DP_ENERGY_OFF :
			G(dp_dtmf_digit) = dp_get_dtmf_digit () ;
			if ( G(dp_dtmf_digit) )
			{
				G(dp_dtmf_state) = DP_ENERGY_ON ;
				G(dp_voice_timer3) = x_current_time () ;
			}
			break ;

		case DP_ENERGY_ON :
			if ( dp_get_dtmf_digit() != G(dp_dtmf_digit) )
			{
				G(dp_dtmf_state) = DP_ENERGY_OFF ;
			}
			// dtmf ON duration - atleast 20 msec - to avoid false detection
			else if ( ( x_elapsed_time (G(dp_voice_timer3)) >= 20 ) ||
					  ( G(S).ModemOptions.CountryId == FRANCE ) )
			{
				if ( dp_validate_dtmf() == TRUE )
				{
					if ( G(dp_dtmf_end) == TRUE )
					{
						x_debug_msg("dp - dtmf detected") ;
#ifdef KORTEX
						if (AM_G_DTR == AM_G_DTR_ON_STATE)
#endif
						{
							dp_report_voice_event ( '/' ) ;	// start of dtmf
							dp_report_voice_event ( G(dp_dtmf_digit) ) ;
						}
					}
					else if ( G(dp_dtmf_digit) != G(dp_dtmf_old) )
					{
#ifdef KORTEX
						if (AM_G_DTR == AM_G_DTR_OFF_STATE)
						{
							dp_report_voice_event ( G(dp_dtmf_old) ) ;
						}
						else
#endif
						{
							dp_report_voice_event ('~') ;	//end of the previous digit
							x_debug_msg("dp - dtmf detected") ;
							dp_report_voice_event ( '/' ) ;	// start of a new dtmf
							dp_report_voice_event ( G(dp_dtmf_digit) ) ;
						}
					}
					G(dp_dtmf_old) = G(dp_dtmf_digit) ;
					/* go to look for the end of the digit */
					G(dp_dtmf_state) = DP_ENERGY_VALID ;
					G(dp_voice_timer3) = x_current_time () ;
					/* reset silence detection timer, and busy cnt */
#ifdef KORTEX
					kx_timer = AmStartSecondTimer(12);
#endif
					G(dp_timer) = x_current_time () ;
					G(dp_busy_cnt) = 0 ;
					G(dp_trouble_cnt) = 0 ;
					G(dp_dial_tone_timer) = x_current_time () ;
					G(dp_dtmf_end) = FALSE ;
				}
				else
				{
					G(dp_dtmf_state) = DP_ENERGY_OFF ;
				}
			}
			break ;

		case DP_ENERGY_VALID :
			if ( dp_get_dtmf_digit() != G(dp_dtmf_digit) )
			{
				G(dp_dtmf_state) = DP_ENERGY_OFF ;
#ifdef KORTEX
				if (AM_G_DTR == AM_G_DTR_OFF_STATE)
				{
					dp_report_voice_event ( G(dp_dtmf_digit) ) ;
				}
				else
#endif
				{
					dp_report_voice_event ('~') ;	// on to off transition
				}
				G(dp_dtmf_end) = TRUE ;
			}
			else if ( x_elapsed_time(G(dp_voice_timer3)) >= 70 )
			{
				G(dp_voice_timer3) = x_current_time () ;
				return ( TRUE ) ;
			}
			break ;
	}

	return ( FALSE ) ;
}

/****************************************************************
Routine : dp_tones_detected
Description : Report DLE shielded tones event codes to DTE
	G(dp_reg16) :	bit 0 : tone detectore 9 (fax calling tone)
				bit 1 : tone detectore 10 (data calling tone)
				bit 2 : IIR 1
				bit 3 : IIR 2
				bit 4 : TBE
				bit 5 : tone detector 11 (fax calling tone2 for France)

*****************************************************************/
byte dp_tones_detected ( void )
{
	G(dp_reg20) = dp_regread ( 0x30 ) ;					// dtmf tones
	G(dp_reg16) = (byte) (0x03 & dp_regread(0x31));		// t9 & t10
	G(dp_reg16) = (byte) (G(dp_reg16) | (0x0c & dp_regread(0x32)));	// IIR1 and IIR2
	G(dp_reg16) = (byte) (G(dp_reg16) | ( 0x10 & (dp_regread(0x32)<<4)));	//TBE 
	G(dp_reg16) = (byte) (G(dp_reg16) | (0x20 & (dp_regread(0x31) << 3))) ;// t11

#ifdef KORTEX
	if ((dp_dtmf_detected () == TRUE ) && (AM_G_DTR == AM_G_DTR_ON_STATE))
	{
		dp_report_voice_event ( G(dp_dtmf_digit) ) ;
	}
	if ( dp_fax_tone_detected () == TRUE )
#else
	if ( dp_dtmf_detected () == TRUE )
	{
		dp_report_voice_event ( G(dp_dtmf_digit) ) ;
	}
	else if ( dp_fax_tone_detected () == TRUE )
#endif	// KORTEX
	{
		x_debug_msg("dp - fax_tone_detected") ;
		dp_report_voice_event ( 0x63 ) ; 	//"c"
	}
	else if ( dp_data_tone_detected () == TRUE )
	{
		x_debug_msg("dp - data_tone_detected") ;
		dp_report_voice_event ( 0x65 ) ; 	//"e"
	}
	else
		return ( FALSE ) ;

	return ( TRUE ) ;
}

/****************************************************************
Routine : dp_voice_dialtone_detected
Description : dial tone detection in line record
*****************************************************************/
byte dp_voice_dialtone_detected ( void )
{
	word total_energy, iir2_energy ;
	// to avoid false detection of dial tone during music on hold
//	if ( (G(dp_vt_cntrl)==TAD_LINE_PLAYBACK)||(G(dp_vt_cntrl)==TAD_SCREEN_OUT) )
//	{
//		G(dp_dial_tone_timer) = x_current_time() ;
//		return ( FALSE ) ;
//	}

//	if ( G(dp_dialtone_enable) == FALSE )
//		return ( FALSE ) ;

	/* if continuous dial tone on for atleast 3 seconds */
	if ( (G(dp_reg16) & 0x08) && (!(G(dp_reg16) & 0x04)) ) // IIR2=1,IIR1=0
	{
		if ( x_elapsed_time(G(dp_dial_tone_timer)) >= SECOND3 )
		{
			total_energy = dp_read_dsp_ram ( TOTAL_ENERGY_ADDR ) ;
			iir2_energy = dp_read_dsp_ram ( IIR2_ENERGY_ADDR) ;
			if ( (total_energy != 0) && (iir2_energy != 0) )
			{
				if ( total_energy >= iir2_energy )
					total_energy = (word) (total_energy / iir2_energy) ;
				else
					total_energy = (word) (iir2_energy / total_energy) ;
				if ( total_energy == 1 )
				{
					G(dp_dial_tone_timer) = x_current_time () ;
					return ( TRUE ) ;
				}
			}
			/*
			 * if we see IIR2 is set for 3sec, but IIR2 energy is not close
			 * to the total inband energy, it is false detection, disable
			 * dialtone detection till next time issue start_tad again
			 */
			G(dp_dialtone_enable) = FALSE ;
			G(dp_dial_tone_timer) = x_current_time () ;
		}
	}
	else
		G(dp_dial_tone_timer) = x_current_time() ;
	return ( FALSE ) ;
}

/****************************************************************
Routine : dp_voice_busytone_detected
Description : busy tone detection in line record
*****************************************************************/
byte dp_voice_busytone_detected ( void )
{
#ifdef KORTEX
	byte am_congestion;
	am_congestion = FALSE;
#endif
	/* if energy in high pass filter, no busy tone */
	if ( G(dp_reg16) & 0x04 ) // IIR1=1
	{
		G(dp_busy_cnt) = 0 ;
		return ( FALSE ) ;
	}
	switch ( G(dp_busy_state) )
	{
		case DP_ENERGY_ON :
			if ( !(G(dp_reg16) & 0x08) ) //IIR2=0
			{
				//x_debug_msg("BUSY OFF") ;
				G(dp_busy_on_cadence) = x_elapsed_time(G(dp_busy_tone_timer)) ;
				G(dp_busy_tone_timer) = x_current_time () ;
				G(dp_busy_state) = DP_ENERGY_OFF ;

				if ( G(S).ModemOptions.MaxBusyCadenceOn )	// country specific 
				{
					if ((G(dp_busy_on_cadence) >= (word)(10*G(S).ModemOptions.MinBusyCadenceOn))
					&& (G(dp_busy_on_cadence) <= (word)(10*G(S).ModemOptions.MaxBusyCadenceOn))
					&& (G(dp_busy_off_cadence) >= (word)(10*G(S).ModemOptions.MinBusyCadenceOff))
					&& (G(dp_busy_off_cadence) <= (word)(10*G(S).ModemOptions.MaxBusyCadenceOff)))
					{
						G(dp_busy_cnt)++ ; 
						G(dp_busy_on_cadence) = 0 ;	/* set on duration to 0 */
						G(dp_busy_off_cadence) = 0 ;	/* set off duration to 0 */
					}
#ifdef KORTEX
					else if ((G(S).ModemOptions.CountryId == ITALY)
							&& (G(dp_busy_on_cadence) >= 100)
							&& (G(dp_busy_on_cadence) <= 300)
							&& (G(dp_busy_off_cadence) >= 100)
							&& (G(dp_busy_off_cadence) <= 300))
					{
						G(dp_busy_cnt)++ ; 
						G(dp_busy_on_cadence) = 0 ;	/* set on duration to 0 */
						G(dp_busy_off_cadence) = 0 ;	/* set off duration to 0 */
						am_congestion = TRUE;
					}
#endif
					else
					{
						G(dp_busy_cnt) = 0 ;
					}
				}
				else 
				{
					if ( (G(dp_busy_on_cadence) >= 130) 
							&& (G(dp_busy_on_cadence) <= 800) 
							&& (G(dp_busy_off_cadence) <= 800)  )
					{
						if ( ((G(dp_busy_on_cadence) <= 150)
							&& (G(dp_busy_on_cadence) + G(dp_busy_off_cadence) > 250))
							|| ((G(dp_busy_on_cadence) >= 150)
							&& (G(dp_busy_on_cadence) <= (G(dp_busy_off_cadence) +
				    		(G(dp_busy_off_cadence) >> 1) + 25))) )
						{
							G(dp_busy_cnt)++ ; 
							G(dp_busy_on_cadence) = 0 ;	/* reset on duration */
							G(dp_busy_off_cadence) = 0 ;	/* reset off duration */
						}
						else G(dp_busy_cnt) = 0 ;
					}
					else G(dp_busy_cnt) = 0 ;
				}

#ifdef KORTEX
				if (((am_congestion == FALSE)
					 && (G(dp_busy_cnt) >= G(S).ModemOptions.BusyPassCount))
					 || ((am_congestion == TRUE) && (G(dp_busy_cnt) >= 8)))
				{
					G(dp_busy_cnt) = 0 ;
					return ( TRUE ) ;
				}
#else
				if ( G(dp_busy_cnt) >= 6 )
				{
					G(dp_busy_cnt) = 0 ;
					return ( TRUE ) ;
				}
#endif	// KORTEX
			}
			break ;
		case DP_ENERGY_OFF :
			if ( G(dp_reg16) & 0x08 ) // IIR2=1
			{
				//x_debug_msg("BUSY ON") ;
				G(dp_busy_off_cadence) = x_elapsed_time(G(dp_busy_tone_timer));
				G(dp_busy_tone_timer) = x_current_time () ;
				G(dp_busy_state) = DP_ENERGY_ON ;
			}
			break ;
	}

	return ( FALSE ) ;
}

/****************************************************************
Routine : dp_voice_troubletone_detected
Description : trouble tone detection in line record
*****************************************************************/
byte dp_voice_troubletone_detected ( void )
{
	switch ( G(dp_trouble_state) )
	{
		case DP_ENERGY_ON :
			if ( !(G(dp_reg16) & 0x04) ) //IIR1=0
			{
				//x_debug_msg("OFF") ;
				G(dp_trouble_on_cadence) = x_elapsed_time(G(dp_trouble_tone_timer)) ;
				G(dp_trouble_tone_timer) = x_current_time () ;
				G(dp_trouble_state) = DP_ENERGY_OFF ;
				/*
	 			 * trouble tones are ON for 100msec and OFF for 100msec.
	 			 */
				if ( (G(dp_trouble_on_cadence) >= 40)  &&
	     			 (G(dp_trouble_on_cadence) <= 200) &&
		 			 (G(dp_trouble_off_cadence) >= 40) &&
		 			 (G(dp_trouble_off_cadence) <= 200) )
				{
					/*
					 * if trouble tone present for 5 contiguous cycle,
					 * return true
					 */
					if ( ++G(dp_trouble_cnt) >= 5 )
					{
						x_debug_msg("dp - trouble tone detected") ;
						G(dp_trouble_cnt) = 0 ;
						return ( TRUE ) ;
					}
				}
				else
					G(dp_trouble_cnt) = 0 ;
			}
			break ;
		case DP_ENERGY_OFF :
			if ( G(dp_reg16) & 0x04 ) // IIR1=1
			{
				//x_debug_msg("ON") ;
				G(dp_trouble_off_cadence) = x_elapsed_time(G(dp_trouble_tone_timer));
				G(dp_trouble_tone_timer) = x_current_time () ;
				G(dp_trouble_state) = DP_ENERGY_ON ;
			}
			break ;
	}

	return ( FALSE ) ;
}
/****************************************************************
Routine : dp_silence_detected
Description : Remote line termination detection
*****************************************************************/
void dp_silence_detected ( void )
{
	if ( dp_voice_dialtone_detected () == TRUE )
	{
		G(dp_timer) = x_current_time () ;
		dp_report_voice_event ( 'd' ) ;
	}
	else if ( (dp_voice_busytone_detected () == TRUE) ||
	          (dp_voice_troubletone_detected () == TRUE ) )
	{
		G(dp_timer) = x_current_time () ;
		dp_report_voice_event ( 'b' ) ;
	}
	else if ( ((G(dp_reg16) & 0x10)==0x00) && 
	          (G(S).ModemOptions.SilenceDetectTimer!=0) )
	{
		if ( x_elapsed_time(G(dp_timer)) >= 
		     (100*(word)G(S).ModemOptions.SilenceDetectTimer) )
		{
			G(dp_timer) = x_current_time () ;
			dp_report_voice_event ( 's' ) ;
		}
	}
	else
	{
		G(dp_timer) = x_current_time () ;
	}
}

//*****************************************************************************
// Routine : dp_generate_tones
// Description : Generate up to 2 tones
//
// Revision History :
//	Initials	Date		Change
//	  Eli T.       12/8/94          Now function will wait until tone 
//                                      genration is over before exiting. Also,
//                                      in case both tones are defined as ZERO
//                                      the function will wait for the duration
//                                      specified by the BeepToneTimer before
//                                      exiting.
//****************************************************************************/
void dp_generate_tones ( word tone1, word tone2 )
{
	byte tone_cnt=0, tone1indx=0, tone2indx=0;

#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
	if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
		return ;
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM

	if ( tone1 != 0 )
	{
		tone1indx = (byte) (2*(((tone1+50)/100) - 3)) ;
		tone_cnt++ ;
	}
	if ( tone2 != 0 )
	{
		tone2indx = (byte) (2*(((tone2+50)/100) - 3)) ;
		tone_cnt++ ;
	}
	if ( tone_cnt != 0 )
	{
		dp_stop_tad ( ) ; 

		dp_write_dsp_ram (0x17, (word)(10*G(S).ModemOptions.BeepToneTimer) ) ;
		dp_write_dsp_ram (0x11, (word)G(S).ModemOptions.TxLevel) ;/* tone1 power */
		dp_write_dsp_ram (0x12, (word)(G(S).ModemOptions.TxLevel + 2));/* tone2 power */
		dp_write_dsp_ram (0x05, dp_tone_freqcoef [tone1indx] ) ;
		dp_write_dsp_ram (0x06, dp_tone_freqcoef [tone1indx + 1] ) ;
		if ( tone_cnt == 2 )
		{
			dp_write_dsp_ram (0x07, dp_tone_freqcoef [tone2indx] ) ;
			dp_write_dsp_ram (0x08, dp_tone_freqcoef [tone2indx + 1] ) ;
		}
		dp_modem_command ( GENERATE_TONES, tone_cnt, 0 );
	}
}

/****************************************************************
Routine : dp_set_tad_mic_gain
Description : Set volume gain levels for near recording mic
*****************************************************************/
void dp_set_tad_mic_gain ( void )
{
	/*
	 * adjust near record volume from the Mic
	 * scale of 0-18-63 converted from +VGR scale of 255-128-0
	 */
	if ( G(dp_vt_cntrl) == TAD_NEAR_RECORD )
	{
		x_debug_msg ("dp_set_tad_mic_gain - TAD_NEAR_RECORD") ;

		if ( G(S).ModemOptions.VoiceMicGainControl >= 128 )
		{
			dp_write_dsp_ram( TAD_MIC_GAIN_ADDR,
		  		 (word)((255-G(S).ModemOptions.VoiceMicGainControl)/7));
		}
		else
		{
			dp_write_dsp_ram( TAD_MIC_GAIN_ADDR, 
		 	  (word)(18+((128-G(S).ModemOptions.VoiceMicGainControl)/3)) ) ;
		}
	}
}

/****************************************************************
Routine : dp_set_tad_speaker_gain
Description : Set volume gain levels for speaker
*****************************************************************/
void dp_set_tad_speaker_gain ( void )
{
	word addr ;
	word gainval ;
	/*
	 * Set playback volume to the speaker.
	 * DSP scale of 0 to 63 gives +18 dB to -45 dB for V.34,
	 *                            +12 dB to -51 dB for MS DSP.
	 * Map +VGT=1 to 255 linearly to digital gain, pinning 255 at
	 * +6 dB.  Give 30 dB range.  Make +VGT=0 as quiet as possible.
	 */

	if ( G(dp_vt_cntrl) == TAD_SCREEN_IN )
		addr = TAD_SPKR_GAIN2_ADDR ;
	else
		addr = TAD_SPKR_GAIN1_ADDR ;

	if ( (G(dp_vt_cntrl) == TAD_NEAR_PLAYBACK) || (G(dp_vt_cntrl) == TAD_NEAR_FULL_DUPLEX) ||
	     (G(dp_vt_cntrl) == TAD_SCREEN_OUT) || (G(dp_vt_cntrl) == TAD_SCREEN_IN) )
	{
		if ( G(S).ModemOptions.VoiceVolumeControl == 0 )
			gainval = 63;	// very low volume

#define MAXGAIN 6	/* +12 dB digital gain in V.34 DSP */
#define MINGAIN (MAXGAIN + 30)	/* 30 dB range of volume control */

		else
		{
			if( G(S).ModemOptions.VoiceVolumeControl < 170 )
			{
				gainval = (word) ((((MAXGAIN - MINGAIN) * 170 ) / 255) + MINGAIN
				+ ( ((MINGAIN - MAXGAIN - 15) * ( 170 - G(S).ModemOptions.VoiceVolumeControl ) )/170));
			}
			else
			{
				gainval = (word) ((((MAXGAIN - MINGAIN) * 170 ) / 255) + MINGAIN
				- ( (3 * ( G(S).ModemOptions.VoiceVolumeControl - 170 ) )/85));
			}
		}

		dp_write_dsp_ram ( addr, gainval ) ;
	}
}

/****************************************************************
Routine : dp_tad_monitor_hec
*****************************************************************/
void dp_tad_monitor_hec ( void )
{
	if ( G(dp_monitor_hec) )
	{
		// 0xC0 corresponds to a value of 18 db cancellation
		// if we do get 18 db cancellation for 10 times - freeze the taps
		if ( (G(dp_reg16) & 0xC0) == 0xC0 )
			++G(dp_monitor_hec) ;
		else
			G(dp_monitor_hec) = 1 ;
		if ( G(dp_monitor_hec) >= 30 )
		{
			// freeze hybrid echo cancellor tap update
			dp_write_dsp_ram ( 0x85, 0x1205 ) ; 	// no HEC update
			G(dp_monitor_hec) = 0 ;
		}
	}
}

/****************************************************************
Routine : dp_tad_idle
Description : Switch from Tad playback or record to TAD IDLE mode
              without executing Modem Idle Command (0x13).
*****************************************************************/
void dp_tad_idle ( void )
{
	dp_write_dsp_ram ( PLAY_REC_FLG, 0x0 ) ;
	dp_write_dsp_ram ( TAD_SPTR, TAD_R0 ) ;
}

/****************************************************************
Routine : dp_start_tad
Description : Enter TAD mode.
*****************************************************************/
void dp_start_tad ( byte vt_cntrl )
{
	byte fdsp_cntl ;

	if (G(dp_sleep) == TRUE)
		dp_init_modem();

	dp_modem_command(MODEM_IDLE, 0, 0);
	G(dp_vt_cntrl) = vt_cntrl ;
	x_sleep(50) ;
	
	if (( G(dp_tad_downloaded) == FALSE )
		&&(G(S).ModemOptions.VoiceCompression != VCM_G729))
	{
		x_output ( IO_SPEAKER_OFF ) ;
		dp_modem_command ( MODEM_IDLE, 0, 0 ) ;
		x_debug_msg ( "dp - downloading tad dsp code" ) ;
		dp_download_tad () ;
		G(dp_vsp) = FALSE ;
	}
#ifdef G729A
	else if (G(S).ModemOptions.VoiceCompression == VCM_G729)
	{
		x_output ( IO_SPEAKER_OFF ) ;
		dp_modem_command ( MODEM_IDLE, 0, 0 ) ;
		if ((G(dp_vt_cntrl) == TAD_LINE_RECORD)||(G(dp_vt_cntrl) == TAD_NEAR_RECORD)
			|| (G(dp_vt_cntrl) == TAD_SCREEN_IN))
			dp_enc_ctad_download () ; 		// Load Encode Compressed TAD G.729 DSP Module
		else if ((G(dp_vt_cntrl) == TAD_LINE_PLAYBACK)||(G(dp_vt_cntrl) == TAD_NEAR_PLAYBACK)
				 || (G(dp_vt_cntrl) == TAD_SCREEN_OUT))
			dp_dec_ctad_download () ;		// Load Decode Compressed TAD G.729 DSP Module
		G(dp_vsp) = FALSE ;
	}
#endif
	if ((TAD_NEAR_PLAYBACK ==G(dp_vt_cntrl))
		||(TAD_SCREEN_OUT ==G(dp_vt_cntrl))
		||(TAD_SCREEN_IN ==G(dp_vt_cntrl))
		||(TAD_NEAR_LOOPBACK ==G(dp_vt_cntrl))
		||(FDSP_UNMUTE ==G(dp_vt_cntrl)))
	{
		if ((TAD_NEAR_LOOPBACK == G(dp_vt_cntrl)) ||
			(G(S).ModemOptions.VoiceLineSelection > 3))
		{
			x_output(IO_EXT_SPEAKER_ON);
			x_debug_msg("Tad speak_on");
		}
	}
	else
	{
		x_output ( IO_EXT_SPEAKER_OFF );
	}
	dp_write_dsp_ram (0x0e, 0x8ece) ;

	G(dp_dialtone_enable) = TRUE ;
	G(dp_monitor_hec) = 0 ;	// do not monitor hybrid echo cancellor

	// Set the Non DMA bit in DSP RAM - set only for playback (or) record
	if (G(dp_vt_cntrl) != TAD_IDLE)
	{
		dp_write_dsp_ram ( 0x3d, 0x200 ) ;
		dp_regwrite ( 0xb6, 0xff ) ; // disable the data interrupts
		// Kick of the Data receive for pdm mailbox transfers
		dp_regread ( 0xb0 ) ;
		dp_regread ( 0xb0 ) ;
	}

	switch ( G(S).ModemOptions.VoiceCompression )
	{
		case VCM_ULAW8:
			x_debug_msg ("DP-8bit mulaw") ;
			vt_cntrl |= 0x04 ;
			break ;
		case VCM_ALAW8:
			x_debug_msg ("DP-8bit alaw ")  ;
			vt_cntrl |= 0x09 ;
			break ;
		case VCM_LINEAR8 :
			x_debug_msg ("DP-8bit linear") ;
			vt_cntrl |= 0x0E ;
			break ;
		case VCM_LINEAR16:
		/* For IMA ADPCM the data pump is working
		 * with 16-bit linear samples.  It doesn't
		 * have a clue what's going on.
		 */
		case VCM_IMA_ADPCM:
		default:
			x_debug_msg ("DP-16bit linear") ;
			break ;
	}

	if ( G(S).ModemOptions.VoiceSamplingRate == VSM_8KHZ )
	{
		x_debug_msg ("DP-sampling rate 8khz") ;
		fdsp_cntl = 0x4 ;
	}
	else if ( G(S).ModemOptions.VoiceSamplingRate == VSM_11KHZ )
	{
		x_debug_msg ("DP-sampling rate 11khz") ;
		fdsp_cntl = 0x8 ;
	}
	else
	{
		x_debug_msg ("DP-sampling rate 7.2khz") ;
		fdsp_cntl = 0x0 ;
	}

	/*
	 * Line playback level  : 0dB AGC, tx level <=-10dB for US
	 * Screen out line level: 0dB AGC, tx level <=-10dB for US
	 * Line recording level : 6dB AGC, 11dB fixed gain
	 * Screen in line level : 6dB AGC, 11dB fixed gain
	 */
	dp_apollo_command ( VOICE_THRU,	
	                    vt_cntrl,					//vt_cntrl high byte
						0,							//vt_cntrl low byte
						7,							// 7dB fixed gain
#ifdef KORTEX
						(byte)(G(S).ModemOptions.TadTxLevel),
#else
						(byte)(G(S).ModemOptions.TadTxLevel - 3),
#endif
						0,							//translation mode 
						0,							//fdsp_cntl high byte
						fdsp_cntl ) ;				//fdsp_cntl low byte
	dp_set_tad_speaker_gain () ;			// set speaker gian 
	dp_set_tad_mic_gain () ;

	// do DTMF detection always - for local or line - ignored during local
	dp_detect_dtmf () ;
	// set up tones detection word to register 0x30 and 0x31
	dp_write_dsp_ram ( 0x3c, 0x28 ) ;

	if( ((G(dp_vt_cntrl)==TAD_LINE_PLAYBACK)||(G(dp_vt_cntrl)==TAD_SCREEN_OUT)
		||( G(dp_vt_cntrl) == TAD_NEAR_PLAYBACK )
		|| (G(dp_vt_cntrl) == TAD_LINE_FULL_DUPLEX)) )
	{
		dp_write_dsp_ram (0x85, 0x0105) ;	// clear HEC taps
		dp_write_dsp_ram (0x85, 0x1305) ;	// train HEC
	}
	else
	{
		dp_write_dsp_ram (0x85, 0x1205) ; 	// no HEC update
	}

	/* 
	 * line playback : 0dB AGC
	 * screen out  : 0dB AGC on the line side
	 * line record : 6dB AGC
	 * screen in   : 6dB AGC on the line side
	 * line full duplex : 0dB AGC
	 * other: disable AGC
	 */
	if ( G(dp_vt_cntrl) & 0x80 )
	{
		if ((G(dp_vt_cntrl)==TAD_LINE_RECORD)||(G(dp_vt_cntrl)==TAD_SCREEN_IN))
		{
			dp_write_dsp_ram ( TAD_AGC_CNTR, 0xa000 ) ;	// 12 dB AGC
#ifdef G729A
			if (G(S).ModemOptions.VoiceCompression == VCM_G729)
				dp_write_dsp_ram ( TAD_SPKR_GAIN1_ADDR, 0x0c) ;	// +6 dB post AGC record gain - SES
#endif
		}
		else
			dp_write_dsp_ram ( TAD_AGC_CNTR, 0x8000 ) ;	// 0 dB AGC
		/*
	 	 * Set the initial gain to be high, so that the first few seconds 
	 	 * of voice will not be too weak.
	  	 */
		dp_write_dsp_ram ( TAD_AGC_GN, 0x3000 ) ;
	}
	else
	{
		dp_write_dsp_ram ( TAD_AGC_CNTR, 0x0000 ) ;	// disable AGC 
	}

	// reset download variable in  on-hook function,
	// power-up and in speakerphone command
	G(dp_tad_downloaded) = TRUE ;
	G(dp_dsp_data_in_progress) = FALSE ;
}

/****************************************************************
Routine : dp_stop_tad
Description : stop TAD mode.
*****************************************************************/
void dp_stop_tad ( void )
{
	dp_modem_command ( MODEM_IDLE, 0, 0 ) ;
	G(dp_tad_downloaded) = FALSE ;     // reset tad download module
	// enable data bank interrupts - NCWTB1 & NCRTB1 - data tx & rx
	dp_regwrite ( 0xb6, 0xee ) ;	// enable interrupt bit 0 & 4
}

#ifdef CALLER_ID

#define DP_CID_TYPE		(G(S).ModemOptions.CallerIdType)
/****************************************************************
Routine : dp_cid_cmd
Description : setup caller id relay & tell dsp to start caller id
*****************************************************************/
void dp_cid_cmd(void)
{
#ifdef HOMOL
 	if ((DP_CID_TYPE == 1)		// Japan cid
		|| (DP_CID_TYPE == 2)	// UK cid (SIN 242)
		)
	{
		x_output(IO_OFF_HOOK);
	}
	else
#endif	// HOMOL
	{
		x_output(IO_CALLER_ID_ON);	// activate cid relay
	}
	dp_modem_command ( MODEM_IDLE, 0, 0 ) ;
	dp_write_dsp_block((word *)caller_id_tab,
					   (word)(sizeof(caller_id_tab)/(2*sizeof(word))) );
	dp_write_dsp_ram ( 0x80d, 0x00 ) ;	// clear V.34 rates

#ifdef HOMOL
	//workaround for v23 to work with short mark periods.
 	if ((DP_CID_TYPE == 1)			// Japan cid
		|| (DP_CID_TYPE == 2)		// UK cid (SIN 242)
		|| (DP_CID_TYPE == 4)		// French cid
		)
	{
		dp_write_dsp_block((word *)v23_cid_tab,
						   (word)(sizeof(v23_cid_tab)/(2*sizeof(word))));
	}
#endif	// HOMOL

	dp_modem_command ( STARTUP, ANSWER, 0 ) ;
	dp_write_dsp_ram ( 0x3d, 0x186 ) ;	// async data mode

#ifdef HOMOL
 	if ((DP_CID_TYPE == 1)			// Japan cid
		|| (DP_CID_TYPE == 2)		// UK cid (SIN 242)
		|| (DP_CID_TYPE == 4)		// French CID
		)
	{
		dp_write_dsp_ram(0x1f, 0x1ae1);	//overwrite B202 mark.
	}
#endif	// HOMOL

	x_debug_msg("dp_cid_cmd()");
}
/****************************************************************
Routine : dp_cid_disable
Description : disable caller id relay
*****************************************************************/
void dp_cid_disable(void)
{
	dp_modem_command(MODEM_IDLE, 0, 0);

 	if ((DP_CID_TYPE == 1)			// Japan cid
		|| (DP_CID_TYPE == 2)		// UK cid (SIN 242)
		)
	{
		x_output(IO_ON_HOOK);
	}
	else
	{
		x_output(IO_CALLER_ID_OFF);		// deactivate cid relay
	}

 	if ((DP_CID_TYPE == 1)			// Japan cid
		|| (DP_CID_TYPE == 2)		// UK cid (SIN 242)
		|| (DP_CID_TYPE == 4)		// French CID
		)
	{
		dp_write_dsp_ram(AP_DPRAM_BAUD, AP_DSP_NUL);
	}
}
#endif	//CALLER_ID

/****************************************************************
Routine : dp_dron
Description : Report distictive ring on period.
*****************************************************************/
void dp_dron ( void )
{
	word on_time ;

	G(dp_report_ring) = 1;
	on_time = ( x_elapsed_time ( G(dp_voice_timer2) ) ) ;
	*G(dp_ring_ptr)++ = 'D' ;
	*G(dp_ring_ptr)++ = 'R' ;
	*G(dp_ring_ptr)++ = 'O' ;
	*G(dp_ring_ptr)++ = 'N' ;
	*G(dp_ring_ptr)++ = '=' ;
	G(dp_ring_ptr) += (byte) at_itoa( (word)((on_time+55)/100), G(dp_ring_ptr),DECIMAL);
	*G(dp_ring_ptr)++ = G(S).ModemOptions.CRChar ;
	*G(dp_ring_ptr)++ = G(S).ModemOptions.LFChar ;
	G(dp_voice_timer2) = x_current_time () ;
}

/****************************************************************
Routine : dp_drof
Description : Report distictive ring off period.
*****************************************************************/
void dp_drof ( void )
{
	word off_time ;

	off_time = ( x_elapsed_time ( G(dp_voice_timer2) ) ) ;
	*G(dp_ring_ptr)++ = 'D' ;
	*G(dp_ring_ptr)++ = 'R' ;
	*G(dp_ring_ptr)++ = 'O' ;
	*G(dp_ring_ptr)++ = 'F' ;
	*G(dp_ring_ptr)++ = '=' ;
	G(dp_ring_ptr) += (byte) at_itoa( (word)((off_time+55)/100), G(dp_ring_ptr),DECIMAL);
	*G(dp_ring_ptr)++ = G(S).ModemOptions.CRChar ;
	*G(dp_ring_ptr)++ = G(S).ModemOptions.LFChar ;
	G(dp_voice_timer2) = x_current_time () ;
}

/****************************************************************
Routine : dp_ring_report
Description : Report distictive ring ringing event.
*****************************************************************/
void dp_ring_report	( void )
{
	byte del_shld[5];

	if ( ( G(dp_report_ring) == 1 ) &&
		 ( x_elapsed_time ( G(dp_voice_timer2) ) >=
		 	(word) 100*G(S).ModemOptions.RingReportInterval ) )
	{
		G(dp_report_ring) = 0;
		*G(dp_ring_ptr)++ = 'R' ;
		*G(dp_ring_ptr)++ = 'I' ;
		*G(dp_ring_ptr)++ = 'N' ;
		*G(dp_ring_ptr)++ = 'G' ;
		*G(dp_ring_ptr)++ = G(S).ModemOptions.CRChar ;
		*G(dp_ring_ptr)++ = G(S).ModemOptions.LFChar ;
		*G(dp_ring_ptr) = 0 ;
		if ( G(x_modem_mode) == MODEM_VOICE )
		{
			del_shld[0] = '\020' ;
			del_shld[1] = 'X' ;
			del_shld[2] =  G(S).ModemOptions.CRChar ;
			del_shld[3] =  G(S).ModemOptions.LFChar ;
			del_shld[4] =  0 ;
			x_send_mail ( AT_IO_DATA, IO_TASK, del_shld, 5 ) ;
		}
		x_send_mail ( AT_IO_DATA, IO_TASK, (byte *) V42BIS_MEM_START,
									x_strlen( (byte *) V42BIS_MEM_START ) ) ;
		if ( G(x_modem_mode) == MODEM_VOICE )
		{
			del_shld[1] = '.' ;
			x_send_mail ( AT_IO_DATA, IO_TASK, del_shld, 5 ) ;
		}
		G(dp_ring_ptr) = (byte *) V42BIS_MEM_START;
	}
	G(voice_ring_count)++ ;
	G(dp_ring_ptr) = (byte *) V42BIS_MEM_START;
}

/****************************************************************
Routine : dp_synth_ring_freq1
Description : Set systhesized ring frequency 1
*****************************************************************/
void dp_synth_ring_freq1 ( void )
{
	word sinevalue, cosvalue ;

	sinevalue = 0 ;
	cosvalue = 0 ;
	switch ( G(S).ModemOptions.SynRingFreq )
	{
		case 1:
			sinevalue = F600S ;
			cosvalue = F600C ;
			break;
		case 2:
			sinevalue = F500S ;
			cosvalue = F500C ;
			break;
		case 3:
			sinevalue = F400S ;
			cosvalue = F400C ;
			break;
		case 4:
			sinevalue = F500S ;
			cosvalue = F500C ;
			break;
		case 5:
			sinevalue = F700S ;
			cosvalue = F700C ;
			break;
	}
	if ( sinevalue )
	{
		dp_write_dsp_ram ( 0x05, sinevalue ) ;
		dp_write_dsp_ram ( 0x06, cosvalue ) ;
	}
}

/****************************************************************
Routine : dp_synth_ring_freq2
Description : Set systhesized ring frequency 2
*****************************************************************/
void dp_synth_ring_freq2 ( void )
{
	word sinevalue, cosvalue ;

	sinevalue = 0 ;
	cosvalue = 0 ;
	switch ( G(S).ModemOptions.SynRingFreq )
	{
		case 1:
			sinevalue = F800S ;
			cosvalue = F800C ;
			break;
		case 2:
			sinevalue = F700S ;
			cosvalue = F700C ;
			break;
		case 3:
			sinevalue = F600S ;
			cosvalue = F600C ;
			break;
		case 4:
			sinevalue = F800S ;
			cosvalue = F800C ;
			break;
		case 5:
			sinevalue = F900S ;
			cosvalue = F900C ;
			break;
	}
	if ( sinevalue )
	{
		dp_write_dsp_ram ( 0x05, sinevalue ) ;
		dp_write_dsp_ram ( 0x06, cosvalue ) ;
	}
}

/****************************************************************
Routine : dp_synth_ring_init
Description : Initialize systhesized ring tone
*****************************************************************/
void dp_synth_ring_init ( void )
{
	G(dp_voice_timer3) = x_current_time () ;
	dp_write_dsp_ram ( 0x11, (word)(G(S).ModemOptions.SynRingVolume + 6) ) ;
	dp_modem_command ( MODEM_IDLE, 0, 0 ) ;
	dp_download_tad();
	dp_write_dsp_ram ( 0x85, 0x00 ) ;

	dp_apollo_command ( VOICE_THRU, TAD_NEAR_LOOPBACK, 0, 0, 0, 0, 0, 0x40 ) ;
	x_output ( IO_AUDIO_CODEC_ON ) ;

	dp_modem_command ( GENERATE_TONES, 1, 0 ) ;
	dp_write_dsp_ram ( 0x17, 3000 ) ;
	dp_synth_ring_freq1 ( ) ;
	dp_write_dsp_ram ( 0x85, 0x0020 ) ;
	G(dp_synth_ring_state) = 2 ;
	x_output ( IO_AUDIO_CODEC_ON ) ;
	dp_enable_ring_int () ;
}

/****************************************************************
Routine : dp_synth_ring_on
Description : Send systhesized ring tone
*****************************************************************/
void dp_synth_ring_on ( void )
{
	if ( ( x_elapsed_time ( G(dp_voice_timer3) ) < 40 ) )
		return ;
	G(dp_voice_timer3) = x_current_time () ;
	dp_write_dsp_ram ( 0x11, (word)G(S).ModemOptions.SynRingVolume ) ;
	switch ( G(dp_synth_ring_state) )
	{
		case 1:
			dp_synth_ring_freq1 () ;
			G(dp_synth_ring_state) = 2 ;
			break;
		case 2:
			dp_synth_ring_freq2 () ;
			G(dp_synth_ring_state) = 1 ;
			break;
	}
}

/****************************************************************
Routine : dp_synth_ring_off
Description : Stop systhesized ring tone
*****************************************************************/
void dp_synth_ring_off ( void )
{
	dp_write_dsp_ram ( 0x85, 0 ) ;
	dp_modem_command ( MODEM_IDLE, 0, 0 ) ;
	x_output ( IO_AUDIO_CODEC_OFF ) ;
}

/****************************************************************
Routine : dp_voice_ring
Description : Processes ringing for ring cadence reporting
				and synthesized ring
*****************************************************************/
void dp_voice_ring ( void )
{
	if ( ! (G(S).ModemOptions.VoiceEventMask & EVENT_DISTINCTIVE_RING) )
		return ;
	
	switch ( G(dp_voice_ring_state) )
	{
	case DP_VOICE_RING_ON :
		if ( ( dp_ring_detected () ) == TRUE )
		{
			if ( G(S).ModemOptions.DistinctiveRing == 1 )
				dp_drof ();
			if ( G(S).ModemOptions.SynRingFreq != 0)
				dp_synth_ring_init ();
			G(dp_voice_ring_state) = DP_VOICE_RING_OFF ;
		}
		else if ( ( G(S).ModemOptions.DistinctiveRing == 1 )
				  && ( x_elapsed_time ( G(dp_voice_timer2) ) >=
					   (word) 100*G(S).ModemOptions.RingReportInterval))
		{
			dp_ring_report () ;
		}
		break;
	case DP_VOICE_RING_OFF :
		if ( dp_ring_detected () == FALSE )
		{
			if ( G(S).ModemOptions.SynRingFreq != 0 )
				dp_synth_ring_off ();

			if ( G(S).ModemOptions.DistinctiveRing == 1 )
				dp_dron ();
			G(dp_voice_ring_state) = DP_VOICE_RING_ON ;
		}
		else if ( G(S).ModemOptions.SynRingFreq != 0 )
			dp_synth_ring_on () ;
		break;
	}
}

/****************************************************************
Routine : dp_voice_ring_init
Description : Initialize variables for cadence reporting
*****************************************************************/
void dp_voice_ring_init ( void )
{
	G(voice_ring_count) = 0 ;
	G(dp_ring_ptr) = (byte *) V42BIS_MEM_START;
	G(dp_voice_timer2) = x_current_time () ;
	G(dp_voice_ring_state) = DP_VOICE_RING_ON ;
	dp_voice_ring () ;
}

/****************************************************************
Routine : dp_dualport_vc_RC
Description : dp voice transmit samples from dsp - mail box transfers
	The following Transmit and Receive functions are used in IS101
*****************************************************************/
byte dp_dualport_vc_Tx (void )
{
	word io_voice_count_max, IO_timer ;
	byte dsp_tx_ptr, *ptr ;
#if defined(G729A)
	byte header;
#endif // G729A

	if( dp_read_dsp_ram(0xe1) < (VOICE_PLAY_DSP_XFR_CNT+128)/2) return FALSE ;

	io_voice_count_max = G(io_voice_count)  ;
	ptr = (byte *) G(io_dce_rx_sptr) ; //get the pointer

#ifdef G729A
	if (( io_voice_count_max < 11 )
		&&(G(S).ModemOptions.VoiceCompression == VCM_G729))
		return FALSE;

	if (G(S).ModemOptions.VoiceCompression == VCM_G729)
	{
		while((io_voice_count_max <= VOICE_G729_DSP_XFR_CNT)
		&&(io_voice_count_max > 0))
		{
			// G.729A uses only the first 11 bytes of the
			// 16 available via the dual-port registers.  The
			// first byte is the header
			
			if (start_play == TRUE) {	//dump 11 bytes at a time
				byte i = 0;
				header = 0x01;
				do {
					if(*ptr++ == 0xff)
						header &= 0x01;
					else
						header &= 0x00;
				} while (++i < 11);
				io_voice_count_max -=11;
				if (header==0x01)
					start_play = FALSE;
			} else {
				dsp_tx_ptr = 0x80 ;
				// start transmitting data
				do {
					dp_regwrite ( dsp_tx_ptr, *ptr++ ) ;
				} while ( ++dsp_tx_ptr <= 0x8a ) ;	// 11 bytes
				// Trigger Byte, 16 bytes max
				dp_regwrite ( 0xb0, 16 ) ;
				io_voice_count_max -= 11 ; // decrement the overall count
			}
			IO_timer = x_current_time() ;
		
			// Wait for CORE read
			while((dp_regread(0xb7) & 0x1)==0 )
			{
			    if ( x_elapsed_time(IO_timer) >= MS50 )
				{
					x_debug_msg("CORE read failure");
					G(io_voice_count) = io_voice_count_max ;
					return FALSE ; // Return false only if incomplete
				}
			}
		}
	}
	else
#endif

	{
		while(io_voice_count_max)
		{
			{
				dsp_tx_ptr = 0x80 ;
				// start transmitting data
				do
				{
					dp_regwrite ( dsp_tx_ptr, *ptr++ ) ;
				}
				while ( ++dsp_tx_ptr <= 0x8f ) ;	// max 16 bytes
	
				// Trigger Byte, 16 bytes max
				dp_regwrite ( 0xb0, 16 ) ;

				io_voice_count_max -= 16 ; // decrement the overall count
			}
			IO_timer = x_current_time() ;
		
			// Wait for CORE read
			while((dp_regread(0xb7) & 0x1)==0 )
			{
			    if ( x_elapsed_time(IO_timer) >= MS50 )
				{
					x_debug_msg("CORE read failure");
					G(io_voice_count) = io_voice_count_max ;
					return FALSE ; // Return false only if incomplete
				}
			}
		}
	}
	
#ifdef G729A
	G(io_voice_count) = 0;
#else

	G(io_voice_count) = io_voice_count_max ;

#endif

	return TRUE ;  // Return True if done
}

/****************************************************************
Routine : dp_dualport_vc_RC
Description : dp voice receive samples from dsp - mail box transfers
	The following Transmit and Receive functions are used in IS101
*****************************************************************/
byte dp_dualport_vc_Rc ( void )
{
	word count ,IO_timer ;
	word io_rec_count = 0 ;
	byte dsp_rx_ptr , *wptr ;
	
	if((dp_read_dsp_ram(0xe7) < (1600+VOICE_RECORD_DSP_XFR_CNT)/2)
		&& (G(S).ModemOptions.VoiceCompression != VCM_G729))
	{
		return FALSE ;
	}

	wptr = (byte *) G(io_dce_rx_sptr) ; //get the pointer

	while ( io_rec_count < VOICE_RECORD_DSP_XFR_CNT )
	{
		IO_timer = x_current_time() ;

		// Wait for Core Write
		while((dp_regread(0xb7) & 0x10)==0)
		{
		    if ( x_elapsed_time(IO_timer) >= MS50 )
			{
				x_debug_msg("CORE Write failure");
				G(io_voice_count) = io_rec_count ; // copy the count
				return FALSE ; // Return false only if incomplete
			}
		}
		count = dp_regread ( 0xb0 ) ; //  Read 0xb0 to 
		if(count != 0)
		{
			
#ifdef G729A
			if(G(S).ModemOptions.VoiceCompression == VCM_G729)
			{
				// G.729A uses only the first 11 bytes of the
				// 16 available via the dual-port registers.  The
				// first byte is the header
				
				dsp_rx_ptr = 0x90 ;
				// copy data into fifo
				if(start_record == TRUE) {
					do {
						*wptr++ = 0xff;
					} while (++dsp_rx_ptr <= 0x9a);
					start_record = FALSE;
				} else {
					do {
						*wptr++ = dp_regread ( dsp_rx_ptr ) ;
					} while ( ++dsp_rx_ptr <= 0x9a ) ;	// 11 bytes
				}
				io_rec_count += 11 ;     // Increment the overall count
			} else
#endif

		 	{
				dsp_rx_ptr = 0x90 ;
				// copy data into fifo
				do
				{
					*wptr++ = dp_regread ( dsp_rx_ptr ) ;
				}
				while ( ++dsp_rx_ptr <= 0x9f ) ;	// max 16 bytes
				io_rec_count += 16 ;     // Increment the overall count
			}
		}
	// Dummy trigger to write more data
	    dp_regread ( 0xb0 ) ;
	}

	G(io_voice_count) = io_rec_count ; // copy the count
	return(TRUE);  // Return True if done
}
#endif // End of VOICE define
