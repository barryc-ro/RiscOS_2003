/*name and version number:@(#)ioradish.c	1.44*/
/*date of get: 		  09/06/00 16:59:16*/
/*date of delta:	  01/05/99 15:04:21*/
//****************************************************************************
// File :	ioradish.c
// Description :
//	Contains all banked routines for the data transmition between
//	DTE and DCE in the RADISH mode.
//
// Functions Contained :
//
//   InitRadishVars
//   TxCapFrame
//   TxControlFrame
//   TxControlFrame(byte cmd, byte cr, byte pf)
//   RadishAsmIframe(void)
//   RadishTxHdlcFrame(void)
//   SendFlags
//   ProcessRr
//   IoRadishTask
//   io_radish_bg(void);
//
//
//
//
// Revision History :
//	Initials	Date		Change
//	Eli.T	       10/20/94         Initial
//****************************************************************************

#include "llglob_d.h"

#ifdef RADISH
#include "ioglob_d.h"
#include "iouart_d.h"
#include "lapm.h"
#include "radish.h"
#include "allglobs.h"
#define TALKSHOP_FILE_XFER_BUG

//-----------------------------------------------------------------------------
//  function prototypes
//-----------------------------------------------------------------------------
void InitRadishVars(void);
void TxControlFrame(byte cmd, byte cr, byte pf);
void RadishAsmIframe(void);
byte RadishTxHdlcFrame(void);
void SendFlags(void);
void ProcessRr(void);

void IoRadishTask(RADISH_TASK cmd, byte *resp);
byte io_radish_bg(void);

//-----------------------------------------------------------------------------
//  private variables
//-----------------------------------------------------------------------------

IO_RADISH_STATE  IoRadishState;
RADISH_RX_FRAME RadishRxFrame;

byte at_sac_executed;
byte FrameCount;
byte RadishSentFirstBlock;
byte RadishRcvFirstBlock;
byte RcvFrameCount;
byte TransmitBlock;
byte RnrRecovery;
byte RrCount;
byte dte_rcv_str[2];
byte retransmit;
byte radish_last_tx_char;
byte radish_last_rx_char;
byte tx_long_cap;
byte retransmit_count;
//-----------------------------------------------------------------------------
//   global variables
//-----------------------------------------------------------------------------
MODE_INDICATOR_TYPE ModeInd[NUM_OF_MODE_INDICATORS];
RADISH_STATE x_radish_state;
RADISH_RATE x_radish_rate;
RADISH_STATUS x_radish_status;
TERMINATION_CHAR Tx_TermChar,Rx_TermChar,AltLink;


//----------------------------------------------------------------------------
//   external functions
//----------------------------------------------------------------------------
extern void ReportEvent(RADISH_EVENT event);
extern word at_itoa( word num, byte *str, byte format);

// For ROM_FLASH, this module is too big to reside in BANK2
// and must be placed in another bank.  Therefore, the calls
// to the lapm fcns must be made banked.
#if defined( MODEM_Z80 ) && defined( ROM_FLASH )

extern void Rapm_init_variables ( void ) ;
extern LAPM_FRAME* Rapm_next_tx_wframe ( void ) ;
extern LAPM_FRAME* Rapm_next_tx_rframe ( void ) ;
extern byte Rapm_process_ack ( byte lapm_nr ) ;
#define LAPM_INIT_VARIABLES()	Rapm_init_variables()
#define LAPM_NEXT_TX_WFRAME()	Rapm_next_tx_wframe()
#define LAPM_NEXT_TX_RFRAME()	Rapm_next_tx_rframe()
#define LAPM_PROCESS_ACK(x)		Rapm_process_ack(x)

#else

#define LAPM_INIT_VARIABLES()	lapm_init_variables()
#define LAPM_NEXT_TX_WFRAME()	lapm_next_tx_wframe()
#define LAPM_NEXT_TX_RFRAME()	lapm_next_tx_rframe()
#define LAPM_PROCESS_ACK(x)		lapm_process_ack(x)

#endif

//****************************************************************************
// Routine : InitRadishVars
// Description :
//      Initialize radish variables
//
// Parameters in :
//	none
// Parameters out :
//      none
//
// Revision History :
//	Initials	Date		Change
//	  Eli T.       09/30/94         Initial
//****************************************************************************
void InitRadishVars(void)
{
  //io_init_dce_tx_fifo();       // init dce transmit fifo
  //io_init_dce_rx_fifo();       // init dce receive  fifo
  LAPM_INIT_VARIABLES();

  dte_rcv_str[0]=dte_rcv_str[1]=0;             // clear temp buf
  lapm_k = K;                  // window size
  Tx_TermChar = Rx_TermChar = NUL;              // termination char
  AltLink = NUL;               // alternate link
  FrameCount = 0;              // num of frames sent
  RrCount = 0;                 // num of RR to be transmitted in RNR recovery
  at_ssq_rcvd= FALSE;
  at_svv_rcvd= FALSE;
  at_sda_rcvd= FALSE;
  at_sfx_rcvd= FALSE;
  tx_long_cap = FALSE;
  at_sac_executed = FALSE;
  x_modem_originate = FALSE;
  RadishRcvFirstBlock = RadishSentFirstBlock = FALSE;
  TransmitBlock = FALSE;
  RnrRecovery = FALSE;
  retransmit = FALSE;
  radish_last_tx_char = FALSE;
  radish_last_rx_char = FALSE;
  x_radish_status = RADISH_STATUS_IDLE;
  x_radish_state = RADISH_NULL;
  retransmit_count = 0;	//total number of retransmits in current data exchange
}


//****************************************************************************
// Routine : TxCapFrame
// Description :
//      Assemble CAPABILITIES information in an UI type frame and
//      send it.
//
// Revision History :
//	Initials	Date		Change
//	  Eli T.       09/30/94         Initial
//****************************************************************************
void TxCapFrame(void)
{
  byte i;
  word  *wptr;

   wptr = io_dce_buf;

  //----------------- flags first
  for (i = 0; i <3; ++i)
      *wptr++ = (word) (HDLC_TX_ANY_CHAR | 0x7e) ;

  //----------------- then data and trailing flags.
  *wptr++ = (word)((x_modem_originate) ? 0x03 : 0x01) | HDLC_START_OF_FRAME;
  if ( x_modem_originate )
     *wptr++ = 0x13;
  else
     *wptr++ = RadishOptions.QueryResponseControl ? 0x13 : 0x03;

  for (i = 0; i < RadishOptions.ScdData[1]+2; ++i)
       *wptr++ = (word)RadishOptions.ScdData[i];

  *(wptr-1) |= HDLC_END_OF_FRAME;


  //----------------- flags last
  for (i = 0; i <3; ++i)
      *wptr++ = (word) (HDLC_TX_ANY_CHAR | 0x7e);

  io_write_dce_fifo ( (byte)(wptr - io_dce_buf), io_dce_buf ) ;
}



//****************************************************************************
// Routine : TxModeIndFrame
// Description :
//      Assemble the right Mode Indicator Frame according to the 'speed'
//      parameter in an UI type frame and send it.
//
// Parameters in :
//      speed - Mode Indicator bytes are set according the speed.
// Parameters out :
//      none
//
// Revision History :
//	Initials	Date		Change
//	  Eli T.       09/30/94         Initial
//****************************************************************************
void TxModeIndFrame(byte speed)
{
   byte i;
   word  *wptr ;

   wptr = io_dce_buf;

   //---------- send flags first
   for (i = 0; i <3; ++i)
     *wptr++ = (word) (HDLC_TX_ANY_CHAR | 0x7e);

   // --------- then Mode Ind data and trailing flags.

   *wptr++ = (word)ModeInd[speed].byte1 | HDLC_START_OF_FRAME;
   *wptr++ = (word)ModeInd[speed].byte2 | HDLC_END_OF_FRAME;

   //---------- trailing flags
   for (i = 0; i <3; ++i)
       *wptr++ = (word) (HDLC_TX_ANY_CHAR | 0x7e);

   io_write_dce_fifo(8,io_dce_buf);
}



//****************************************************************************
// Routine : TxControlFrame
// Description :
//      Assemble the right control frame according to the 'cmd' 'cr' and 'pf'
//      parameters and send it.
//
// Parameters in :
//      cmd - RR,RNR,UA and DISC frames.
//      cr  - command/response bit in the address byte.
//      pf  - poll/final bit.
// Parameters out :
//      none
//
// Revision History :
//	Initials	Date		Change
//	  Eli T.       09/30/94         Initial
//****************************************************************************
void TxControlFrame(byte cmd, byte cr, byte pf)
{
   byte i;
   word *wptr ;

   wptr = io_dce_buf;

   //---------------- flags first
   for (i = 0; i <3; ++i)
      *wptr++ = (word) (HDLC_TX_ANY_CHAR | 0x7e) ;

   //---------------- address byte
   if ( cr )
     *wptr++ = (word)(( x_modem_originate ) ? 0x03 : 0x01) | HDLC_START_OF_FRAME;
   else
     *wptr++ = (word)(( x_modem_originate ) ? 0x01 : 0x03) | HDLC_START_OF_FRAME;

   // unnumbered and supervisory frames.
   switch ( cmd )
   {
     case RR:
     case RNR:
        *wptr++ = cmd;
        *wptr++ = (word)(lapm_vr << 1) | HDLC_END_OF_FRAME;      // nr = vr;
        if ( pf )
          *(wptr-1) |= PF;
        break;

     case UA:
     case DISC:
        *wptr++ = (word)(cmd & 0xEF) | HDLC_END_OF_FRAME;
        break;
   }

   //---------------- trailing flags
   for (i = 0; i <3; ++i)
      *wptr++ = (word) (HDLC_TX_ANY_CHAR | 0x7e) ;

   io_write_dce_fifo ( (byte)(wptr - io_dce_buf), io_dce_buf ) ;
}




//****************************************************************************
// Routine : RadishAsmIframe
// Description :
//      Assemble an I frame to transmit to DCE.
//
//
// Revision History :
//	Initials	Date		Change
//	  Eli T.       09/30/94         Initial
//****************************************************************************
void RadishAsmIframe(void)
{
	byte RcvdChar;

	// if there isn't enough room in the dce buffer then return.
	if ( io_get_dce_tx_count() < ALLOC_TX_FRAME_SIZE+25 )    // N201+3+6FLAGS
        {
                //x_debug_msg("radish - waiting for dce room");
                io_timer = x_current_time();
		return;
        }


	// This if statement must be here, otherwise if there is no data in dte,
	// we'll keep calling lapm_next_tx_wframe although the previous one was
	// not closed yet which in turn increment lapm_vs.
	if (lapm_iframe_ptr == NULL)
	{
		// Get next frame pointer to build i-frame.
		// Return if no buffers available.
		if ( !(lapm_iframe_ptr = LAPM_NEXT_TX_WFRAME()) )
			return;
		lapm_data_ptr = &(lapm_iframe_ptr->data[3]);
	}


	// Assembling the frame
        if(!IS_DTE_RX_EMPTY())
                io_timer = x_current_time();
	while ( ( lapm_iframe_ptr->len < N201 ) &&
			!IS_DTE_RX_EMPTY() )
	{

		// read data from dte receive queue
		RcvdChar = *io_dte_rx_rptr++;
#ifdef DEBUGGING
     //sprintf(szBuffer,"TxChar = %x",RcvdChar);
     //x_debug_msg(szBuffer);
#endif

		if (radish_last_tx_char == DLE)
		{
			switch ( RcvdChar )
			{
			case CAN:
                                Tx_TermChar = DLE_CAN;
				break;

			case ETX:
				Tx_TermChar = DLE_ETX;
				break;

			case ETB:
				Tx_TermChar = DLE_ETB;
				break;

			case EOT:
				Tx_TermChar = DLE_EOT;
				break;

			case ESC:
				Tx_TermChar = DLE_ESC;
				break;

				// insert extra DLE ahead of an DLE char.
			case DLE:
				Tx_TermChar = DLE_DLE;
				x_debug_msg("IO- got escaped DLE");
				break;

			default:
				x_debug_msg("IO- got illegal DLE sequence");
				break;
			}
		}
		if(Tx_TermChar == DLE_DLE)
		{
			radish_last_tx_char = FALSE;	//make sure we don't get fooled on second DLE
			Tx_TermChar = NUL;
		}
		else
		{
			radish_last_tx_char = RcvdChar;
		}
		*lapm_data_ptr++ = RcvdChar;	// save char in the frame.

		lapm_iframe_ptr->len++;
		DTE_RX_UPDATE();

		// if a terminator character then get out of loop
		if ( Tx_TermChar )
			break;
	}

	// Do not send partial frames at
	// all.  With the serial modem, we don't get in all
	// the characters fast enough.
	if (Tx_TermChar || lapm_iframe_ptr->len >= N201)
	{
		lapm_iframe_ptr->status = FULL;
		lapm_iframe_ptr->len += 3;
		FrameCount++;                       // num of frames sent.

		// set P bit if end of block or a termination char.
		if (( Tx_TermChar ) || ( FrameCount == K )) // || (lapm_iframe_ptr->len < N201) )
		{
			lapm_iframe_ptr->data[2] = 0x01;
			TransmitBlock = TRUE;
		}
		else
			lapm_iframe_ptr->data[2] = 0;

#ifdef DEBUGGING
		sprintf(szBuffer, "ns=%x ",lapm_iframe_ptr->data[1]);
		x_debug_msg(szBuffer);
		sprintf(szBuffer, "addr=%x",lapm_iframe_ptr->data[0]);
		x_debug_msg(szBuffer);
		sprintf(szBuffer,"len = %d ",lapm_iframe_ptr->len);
		x_debug_msg(szBuffer);
		sprintf(szBuffer,"TermChar = %x",Tx_TermChar);
		x_debug_msg(szBuffer);
		x_debug_msg("IO - closed frame");
#endif

		lapm_iframe_ptr = NULL;
	}
}



//****************************************************************************
// Routine : RadishTxHdlcFrame
// Description :
//      Transmit HDLC frame to DCE
//
//
// returns  TRUE      frame was transmitted
//          FALSE     frame was not transmitted
//
// Revision History :
//	Initials	Date		Change
//	  Eli T.       09/30/94         Initial
//****************************************************************************
byte RadishTxHdlcFrame(void)
{
	LAPM_FRAME *iframe;


	// if there is a frame to transmit then transmit it.
	if ( iframe = LAPM_NEXT_TX_RFRAME() )
	{
        io_tx_hdlc_frame ( iframe->len, iframe->data );
        SendFlags();

        io_timer = x_current_time();        // reset T303

#ifdef DEBUGGING
        sprintf(szBuffer,"IO - sent frame %d ",FrameCount);
        x_debug_msg(szBuffer);
        sprintf(szBuffer,"IO - poll=%x ",iframe->data[2]);
        x_debug_msg(szBuffer);
        sprintf(szBuffer,"IO - ns=%x",iframe->data[1]);
        x_debug_msg(szBuffer);
        sprintf(szBuffer,"len=%x",iframe->len);
        x_debug_msg(szBuffer);
#endif
        return (TRUE);
	}
	return (FALSE);
}


//****************************************************************************
// Routine : SendFlags
// Description :
//      Transmit V21 flags after each frame
//
// Revision History :
//	Initials	Date		Change
//	  Eli T.       09/30/94         Initial
//****************************************************************************
void SendFlags(void)
{

   io_dce_buf[0]= (word) (HDLC_TX_ANY_CHAR | 0x7e);
   io_dce_buf[1]= (word) (HDLC_TX_ANY_CHAR | 0x7e);
   io_dce_buf[2]= (word) (HDLC_TX_ANY_CHAR | 0x7e);
   io_dce_buf[3]= (word) (HDLC_TX_ANY_CHAR | 0x7e);
   io_dce_buf[4]= (word) (HDLC_TX_ANY_CHAR | 0x7e);
   io_dce_buf[5]= (word) (HDLC_TX_ANY_CHAR | 0x7e);
   io_write_dce_fifo(6,io_dce_buf);

}

//****************************************************************************
// Routine : ProcessRr
// Description :
//      Process the RR response from the far end modem.
//
//
//
// Revision History :
//	Initials	Date		Change
//	  Eli T.       09/30/94         Initial
//****************************************************************************
void ProcessRr(void)
{
	if ( LAPM_PROCESS_ACK ( RadishRxFrame.data[2] ) == FALSE )
	{
		RadishOptions.ErrorReport = RECEIVE_SEQ_ERROR;
		if(Tx_TermChar)
		{
			x_radish_state = RADISH_TX_DISC_ERROR_OUT;
		}
		else
		{
			x_radish_state = RADISH_TX_DISC_ERROR_OUT_WAIT_EOT;
		}

              x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX_RESPONSE);
              IoRadishState = IO_RADISH_NULL;
		return;
	}
   lapm_retransmit = 0;	//since we received an RR we can clear retransmit
   // if not all frames in the block acknowledged then retransmit
   if (lapm_ns != lapm_va)
   {
	    x_debug_msg("radish - ******** retransmitting ******");
        lapm_ns = lapm_va;
        retransmit = TRUE;
        IoRadishState = IO_RADISH_UPDATE_RETRANSMIT_VALUE;
        return;
   }
   //make sure we fall through to set TransmitBlock and IoRadishState
   if ((Tx_TermChar == DLE_CAN) || (Tx_TermChar == DLE_EOT))
   {
        x_radish_state = RADISH_TX_DISC;
        x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX_RESPONSE);
   }

   else if ((Tx_TermChar == DLE_ETB) || (Tx_TermChar == DLE_ETX))
   {
             at_sac_executed = TRUE;
             FrameCount = 0;
             AltLink = Tx_TermChar;
             Tx_TermChar = NUL;
	     x_radish_state = RADISH_RX_MODE_IND;
             x_send_mail(RADISH_DP_TASK, DP_TASK,0,RADISH_STARTUP_RX_EXPEDITE);
   }

   else // if (FrameCount == K) otherwise we need to keep sending
   {
             FrameCount = 0;
             x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX_MODE_IND);
   }
   TransmitBlock = FALSE;
   IoRadishState = IO_RADISH_NULL;

}



//****************************************************************************
// Routine : IoRadishTask
// Description :
//          IO tasks
//
//
// Revision History :
//	Initials	Date		Change
//	  Eli T.       09/30/94         Initial
//****************************************************************************
void IoRadishTask(RADISH_TASK task, byte *resp)
{
    switch ( task )
    {

       case RADISH_INIT_VARS:
               InitRadishVars();
               break;

       case RADISH_RETURN_IO_STATE_TO_IDLE:
               io_state = IO_IDLE;
               break;

       case RADISH_START_IO_TIMER:
               io_timer = x_current_time();
               break;

       case RADISH_IS_WAITING_FOR_ATSAC:
               *resp = (IoRadishState == IO_RADISH_WAIT_FOR_ATSAC_CMD )
                       ? TRUE : FALSE;
               break;

       case RADISH_ATSAC_RCVD:
               IoRadishState = IO_RADISH_ATSAC_CMD_RCVD;
               break;

       case RADISH_IO_CONNECT:
               InitIoRadishState();
               io_state = IO_RADISH_BG;
               if( (at_svv_rcvd) && (x_radish_state == RADISH_TX_DATA))
               {
                    x_send_mail ( RADISH_AT_TASK, AT_TASK, 0, RADISH_AT_CONNECT );
                    at_svv_rcvd = FALSE;
               }
               break;

	case RADISH_IO_DISCONNECT:
		IoRadishState = IO_RADISH_DISCONNECT;	//if still in IO get out gracefully
		break;
    }

}



//****************************************************************************
// Routine : io_radish_bg
// Description :
//      The io background routine for the VoiceView protocol.
//
//
// Revision History :
//	Initials	Date		Change
//	  Eli T.       09/30/94         Initial
//****************************************************************************
byte io_radish_bg(void)
{
  byte FrameType,DataSpeed;
  byte silence;
  MODE_IND_RESULT mode_ind_result;
  switch (IoRadishState)
  {

	  //------------------------------------------------------------------------
	  //   Transmit & Receive of CAPABILITIES info.
	  //------------------------------------------------------------------------

  case IO_RADISH_TX_CAP:
	  x_debug_msg("IO - transmitting CAP frame");
	  if( (4 + RadishOptions.ScdData[1]) > 37)
	  {
		  tx_long_cap=TRUE;
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX_MODE_IND);
		  IoRadishState = IO_RADISH_NULL;
		  break;
	  }
	  //caution falling through!!!!!!!!!!!!!!!!!
  case IO_RADISH_TX_LONG_CAP:
	  tx_long_cap=FALSE;
	  TxCapFrame();
	  IoRadishState = IO_RADISH_WAIT_FOR_END_TX_CAP;
	  break;


  case IO_RADISH_WAIT_FOR_END_TX_CAP:
	  if ( io_dce_tx_fifo_empty() )
	  {

		  x_debug_msg("IO - done transmitting CAP frame");

		  if ( !x_modem_originate )
		  {
			  if ( RadishOptions.QueryResponseControl )
			  {
				  io_timer = x_current_time();                    // start T301 timer for io
				  IoRadishState = IO_RADISH_NULL;
				  x_radish_state = RADISH_RX_CAP;
				  x_radish_rate = VV_V21_300;
				  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_RX_EXPEDITE);
				  return (TRUE);
			  }

			  // if sqr == 0 then RTV
			  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_RETURN_TO_VOICE);
			  return (FALSE);
		  }

		  RadishOptions.ErrorReport = NO_ERROR;
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_RETURN_TO_VOICE);
		  x_send_mail(AT_OK,AT_TASK,0,0);
		  return (FALSE);
	  }
	  break;


  case IO_RADISH_RX_CAP:
	  RadishRxHdlcFrame();
	  FrameType = RadishRxFrameType();
	  switch ( FrameType )
	  {
	  case UI:
	  case (UI | U_PF):
		  x_debug_msg("IO - received CAP frame");
		  if(RadishRxFrame.data[3] > 254)
		  {
			  break;	//ignore if too long or bogus length field
		  }			
		  ReportCap();                           // report CAP to DTE
		  RadishOptions.ErrorReport = NO_ERROR;
		  if ( x_modem_originate )
		  {
			  //------  2 way CAP exchange ----------
			  if (RadishRxFrame.data[1] & 0x10)   // is poll bit set
			  {
				  ReportEvent(EV_SRQ);
				  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX_CAP);
				  IoRadishState = IO_RADISH_NULL;
				  return (TRUE);
			  }

			  x_send_mail(AT_OK,AT_TASK,0,0);
		  }

		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_RETURN_TO_VOICE);
		  return (FALSE);

	  case DISC_FRM:
		  x_debug_msg("IO - received DISC frame");
		  RadishOptions.ErrorReport = UNEXPECTED_DISC_RXD;
		  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
		  return (TRUE);

	  default:
		  if(RadishRxFrame.len == 2)
		  {
			  x_debug_msg("IO-got MI instead of CAP");
			  mode_ind_result = ProcessModeInd(&DataSpeed);
			  if( ( mode_ind_result == VALID_MODE_IND ) )
			  {
				  x_radish_state = RADISH_RX_CAP;
				  x_radish_rate = DataSpeed;
				  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_RX_EXPEDITE);
				  IoRadishState = IO_RADISH_NULL;
				  return(TRUE);
			  }
		  }
		  break;
	  }

	  if ( x_elapsed_time(io_timer) > T301 )      // T301 = 2 sec
	  {
		  x_debug_msg("IO - T301 elapsed");
		  RadishOptions.ErrorReport = ( x_modem_originate ) ?
			  TIMEOUT_RESP_TO_CAP_QUERY :
			  TIMEOUT_RESP_TO_CAP_EXCHANGE_REQ;
		  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
	  }
	  break;


	  //------------------------------------------------------------------------
	  //   Transmit & Receive of the MODE INDICATOR.
	  //------------------------------------------------------------------------

  case IO_RADISH_TX_MODE_IND:
	  if(at_sda_rcvd)
	  {
		  x_radish_rate = VV_MODEM;
	  }
	  else if(at_sfx_rcvd)
	  {
		  x_radish_rate = VV_FAX;
	  }
	  else if(tx_long_cap)
	  {
		  x_radish_rate = (byte)RadishOptions.TxSpeed.Recovery;
	  }
	  else
	  {
		  if(retransmit_count < 2)
		  {
			  x_radish_rate = (byte)RadishOptions.TxSpeed.Priority;
		  }
		  else
		  {
			  x_radish_rate = (byte)RadishOptions.TxSpeed.Recovery;
		  }
	  }
	  x_debug_msg("IO - Transmitting Mode Ind...");
	  TxModeIndFrame((byte)x_radish_rate);
	  IoRadishState = IO_RADISH_WAIT_FOR_END_TX_MODE_IND;
	  break;


  case IO_RADISH_WAIT_FOR_END_TX_MODE_IND:
	  if ( io_dce_tx_fifo_empty() )
	  {
		  x_debug_msg("IO - Done Transmitting Mode Ind...");
          io_timer = x_current_time();
		  if(at_sda_rcvd || at_sfx_rcvd)
		  {
			  x_radish_rate = VV_V21_300;
			  x_radish_state = RADISH_WAIT_FOR_DATA_MODE_RESPONSE;
			  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_RX_EXPEDITE);
		  }
		  else if(tx_long_cap)
		  {
			  x_radish_rate = (byte)RadishOptions.TxSpeed.Recovery;
			  x_radish_state = RADISH_TX_LONG_CAP;
			  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX);
		  }
		  else
		  {
			  x_radish_state = (retransmit) ? RADISH_RETRANSMIT : RADISH_TX_DATA;
			  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX);
		  }
		  IoRadishState = IO_RADISH_NULL;

	  }
	  break;


  case IO_RADISH_RX_MODE_IND:
	  RadishRxHdlcFrame();
	  FrameType = RadishRxFrameType();
	  switch ( FrameType )
	  {
	  case TEST:	//got mode indicator
		  IoRadishState = IO_RADISH_PROCESS_MODE_IND;
		  x_radish_status = RADISH_STATUS_DATA;
		  return(TRUE);

	  case DISC_FRM:
		  ReportEvent(EV_CAN);
		  RadishOptions.ErrorReport = UNEXPECTED_DISC_RXD;
		  x_send_mail(RADISH_AT_TASK,AT_TASK,0,RADISH_ERROR);
		  return (FALSE);

	  case EMPTY_FRM:
		  break;

	  default:
		  if(x_radish_status == RADISH_STATUS_IDLE)
		  {
			  ReportEvent(EV_STO);
			  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_RETURN_TO_VOICE);
			  return(FALSE);
		  }
		  break;
	  }
	  if(x_radish_status == RADISH_STATUS_IDLE)
	  {
		  if ( x_elapsed_time(io_timer) > 350 )	//8 flags+MI+1 flag
		  {
			  ReportEvent(EV_STO);
			  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_RETURN_TO_VOICE);
			  return(FALSE);
		  }
	  }
	  else
	  {
		  if(x_elapsed_time(io_timer) > (T203))
		  {
			  // if(RadishSentFirstBlock||RadishRcvFirstBlock)
			  ReportEvent(EV_CAN);
			  RadishOptions.ErrorReport = TIMEOUT_VALID_DFRAME;
			  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
		  }
	  }
	  break;


  case IO_RADISH_PROCESS_MODE_IND:
	  x_debug_msg("IO - processing Mode Ind frame");
	  mode_ind_result = ProcessModeInd(&DataSpeed);
	  //--------------------------------------------------------------
	  // if unsupported mode, wait until the carrier is
	  // dropped and then tx a DISC frame and then RTV.
	  // If NON_ACTIVE or UNSUPPORTED ProcessModeInd will
	  // give the correct DTE response.
	  //--------------------------------------------------------------
	  if ( (mode_ind_result == NON_ACTIVE_MODE_IND)
		   || (mode_ind_result == UNSUPPORTED_MODE_IND) )
	  {
		  if( !(RadishSentFirstBlock||RadishRcvFirstBlock) )
		  {
//			if(mode_ind_result == NON_ACTIVE_MODE_IND)
//			{
//				ReportEvent(EV_SSV);	//need to do this in accordance to 4.2.9.3 of VV 1.11
//			}
			  x_radish_state = RADISH_TX_DISC_AND_GET_OUT;
			  IoRadishState = IO_RADISH_WAIT_FOR_SILENCE;
			  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_DETECT_TONES);
			  io_timer = x_current_time();   // start silence timer (T203)
			  return (TRUE);
		  }
		  else
		  {
			  IoRadishState = IO_RADISH_DISC_CAN;
			  return(TRUE);
		  }
	  }


	  //--------------------------------------------------------------
	  // supported Mode Indicator
	  //--------------------------------------------------------------
	  if ( (DataSpeed == VV_MODEM) || (DataSpeed==VV_FAX) )
	  {
		  if(DataSpeed == VV_MODEM)
			  ReportEvent(EV_SMD);
		  else
			  ReportEvent(EV_SFA);
		  x_radish_state = RADISH_TX_UA_DATA_MODE_RESPONSE;
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX_RESPONSE);
	  }
	  else
	  {
		  x_radish_state = RADISH_RX_DATA;
		  x_radish_rate = DataSpeed;
		  RcvFrameCount = 0;
		  //--------------------------------------------------------------
		  // if at_sac command hasn't been excuted yet, then go
		  // wait for at_sac command.
		  //--------------------------------------------------------------
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_RX_EXPEDITE);
		  if (!at_sac_executed)
		  {
			  ReportEvent(EV_SSV);
			  x_debug_msg("IO- report SVV");
			  x_radish_state = RADISH_WAIT_FOR_ATSAC_CMD;
			  IoRadishState = IO_RADISH_WAIT_FOR_ATSAC_CMD;
			  io_timer = x_current_time ();
			  return(TRUE);
		  }
		  //--------------------------------------------------------------
		  // if at_sac_excuted then we are in data mode already, so
		  // do Startup answer for the speed indicated in the Mode Ind.
		  //--------------------------------------------------------------
	  }
	  IoRadishState = IO_RADISH_NULL;
	  break;




	  //------------------------------------------------------------------------
	  //   DATA MODE - Transmit
	  //------------------------------------------------------------------------

  case IO_RADISH_TX_DATA:
	  RadishAsmIframe();
	  RadishTxHdlcFrame();
	  if ( TransmitBlock )
		  IoRadishState = IO_RADISH_WAIT_FOR_END_TX_DATA;

          else if (x_elapsed_time(io_timer) > T303) //fixes bug#169
	  {
		  if(AltLink == NUL)
			  //add on some more delay if not doing a turn around
			  //due to when applications start timers and
			  //when we actually send out message to DCE
		  {
			  if( x_elapsed_time(io_timer) <= T303-500 )
				  break;
		  }		
		  x_debug_msg("No data from Host");
		  RadishOptions.ErrorReport = TIMEOUT_DATA_FROM_DTE;
		  IoRadishState = IO_RADISH_RETURN_TO_VOICE_FROM_DATA_MODE;
	  }
	  break;


  case IO_RADISH_WAIT_FOR_END_TX_DATA:
	  if ( io_dce_tx_fifo_empty() )
	  {
		  // a whole block has been transmitted. If Tx_TermChar == DLE_ESC
		  // RTV, otherwise switch to receive mode and await ack.

#ifdef DEBUGGING
		  sprintf(szBuffer,"FrameCount = %d ",FrameCount);
		  x_debug_msg(szBuffer);
		  sprintf(szBuffer,"TermChar = %x",Tx_TermChar);
		  x_debug_msg(szBuffer);
#endif

		  switch ( Tx_TermChar )
		  {
		  case DLE_ESC:
			  RadishOptions.ErrorReport = NO_ERROR;
			  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_RETURN_TO_VOICE);
			  x_send_mail(AT_OK,AT_TASK,0,0);
			  return (FALSE);


		  case NULL:          // this state is true when FrameCount=K (1 block)
		  case DLE_CAN:
		  case DLE_EOT:
		  case DLE_ETX:
		  case DLE_ETB:
			  io_timer = x_current_time();			
			  x_radish_state = RADISH_WAIT_FOR_ACK;
			  x_radish_rate = VV_V21_300;
			  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_RX_EXPEDITE);
			  IoRadishState = IO_RADISH_NULL;
			  break;
		  }
	  }
	  break;


  case IO_RADISH_WAIT_FOR_ACK:
	  RadishRxHdlcFrame();
	  FrameType = RadishRxFrameType();
	  switch ( FrameType )
	  {
	  case UA_FRM:
		  // retransmit even if first block
		  RadishSentFirstBlock = TRUE;	//since there was a response to our I frame, keep trying
		  retransmit = TRUE;
		  lapm_ns = lapm_va;
		  IoRadishState = IO_RADISH_UPDATE_RETRANSMIT_VALUE;
		  return (TRUE);

	  case RR:
                  x_debug_msg("radish- recvd RR");
		  retransmit = FALSE;
		  if ( !RadishSentFirstBlock )
			  RadishSentFirstBlock = TRUE;

		  ProcessRr();
		  return (TRUE);


	  case RNR:
                  x_debug_msg("radish- recvd RNR");
		  if ( !RnrRecovery )
		  {
			  if ( LAPM_PROCESS_ACK ( RadishRxFrame.data[2] ) == FALSE )
			  {
				  RadishOptions.ErrorReport = RECEIVE_SEQ_ERROR;
				  if(Tx_TermChar)
				  {
					  x_radish_state = RADISH_TX_DISC_ERROR_OUT;
				  }
				  else
				  {
					  x_radish_state = RADISH_TX_DISC_ERROR_OUT_WAIT_EOT;
				  }
				  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX_RESPONSE);
				  IoRadishState = IO_RADISH_NULL;
				  return(TRUE);
			  }

			  io_timer = x_current_time();            // start T200 timer
			  IoRadishState = IO_RADISH_RNR_RECOVERY;
			  RnrRecovery = TRUE;
			  return (TRUE);
		  }
		  break;

	  case DISC_FRM:
		  ReportEvent(EV_CAN);
		  RadishOptions.ErrorReport = UNEXPECTED_DISC_RXD;
                  Rx_TermChar = DLE_CAN;
                  //-----------------------------------------------
                  //This can be done since the only state to process
                  //Rx_TermChar will be
                  //IO_RADISH_WAITING_FOR_RESP_FROM_HOST or
                  //IO_RADISH_ERROR_RETURN_TO_VOICE before the link
                  //is dropped.  That is, don't let 
                  //IO_RADISH_RX_PROCESS_TERM_CHAR_AND_POLL be entered!!
                  //-----------------------------------------------
#ifndef TALKSHOP_FILE_XFER_BUG
                  if(Tx_TermChar)
		  {
			  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
		  }
                  else
#endif
                  {
                          IoRadishState = IO_RADISH_WAITING_FOR_RESP_FROM_HOST;
                          io_timer = x_current_time();        // start T310;
                  }
		  return (TRUE);

	  default:
		  break;
	  }
	  // no acknowledgment received from the far end modem
	  if ( x_elapsed_time(io_timer) > T200 )
	  {

           x_debug_msg("radish - ******* no ack timeout *******");
		  // if no ACK or UA received for the first block then RTV. Do not retransmit.
		  if ( !RadishSentFirstBlock )
		  {
			  ReportEvent(EV_CAN);
			  RadishOptions.ErrorReport = TIMEOUT_FAR_END_RESP_TO_DMODE_START;
			  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
		  }

		  // if not the first block then retransmit
		  else
		  {
			  lapm_ns = lapm_va;
			  retransmit = TRUE;
			  IoRadishState = IO_RADISH_UPDATE_RETRANSMIT_VALUE;
		  }
	  }
	  break;



	  //------------------------------------------------------------------------
	  //   DATA MODE -  RNR recovery  ( send periodic RR and wait for RR )
	  //------------------------------------------------------------------------
  case IO_RADISH_RX_RNR_RECOVERY:
  case IO_RADISH_RNR_RECOVERY:
	  RadishRxHdlcFrame();
	  FrameType = RadishRxFrameType();
	  switch ( FrameType )
	  {
	  case RR:
                  x_debug_msg("radish- recvd RR");
		  RnrRecovery = FALSE;
		  RrCount = 0;
		  ProcessRr();
		  return (TRUE);

	  case DISC_FRM:
		  ReportEvent(EV_CAN);
		  RadishOptions.ErrorReport = UNEXPECTED_DISC_RXD;
                  Rx_TermChar = DLE_CAN;
                  //-----------------------------------------------
                  //This can be done since the only state to process
                  //Rx_TermChar will be
                  //IO_RADISH_WAITING_FOR_RESP_FROM_HOST or
                  //IO_RADISH_ERROR_RETURN_TO_VOICE before the link
                  //is dropped.  That is, don't let 
                  //IO_RADISH_RX_PROCESS_TERM_CHAR_AND_POLL be entered!!
                  //-----------------------------------------------
#ifndef TALKSHOP_FILE_XFER_BUG
		  if(Tx_TermChar)
		  {
			  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
		  }
                  else
#endif
		  {
			  IoRadishState = IO_RADISH_WAITING_FOR_RESP_FROM_HOST;
		  }
		  x_send_mail(RADISH_AT_TASK,AT_TASK,0,RADISH_ERROR);
		  return (FALSE);

	  default:
		  break;
	  }
	  if (x_elapsed_time(io_timer) > T200)           // T200 = 2sec
	  {
		  ++RrCount;
		  if ( RrCount >= RR_COUNT_MAX )
		  {
			  RadishOptions.ErrorReport=TIMEOUT_FAR_END_REMOVE_FLOW_CTL;
			  if(Tx_TermChar)
			  {
				  x_radish_state = RADISH_TX_DISC_ERROR_OUT;
			  }
			  else
			  {
				  x_radish_state = RADISH_TX_DISC_ERROR_OUT_WAIT_EOT;
			  }
		  }
		  // send another RR to remote modem.
		  else
			  x_radish_state = RADISH_TX_RR;

		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX_RESPONSE);
		  IoRadishState = IO_RADISH_NULL;
		  io_timer = x_current_time();              // start T200

	  }
	  break;



	  //------------------------------------------------------------------------
	  //   DATA MODE -  retransmission
	  //------------------------------------------------------------------------

  case IO_RADISH_UPDATE_RETRANSMIT_VALUE:
	  if (lapm_retransmit == N200)
	  {
		  RadishOptions.ErrorReport = MAX_RETRANS_EXCEEDED;
		  if(Tx_TermChar)
		  {
			  x_radish_state = RADISH_TX_DISC_ERROR_OUT;
		  }
		  else
		  {
			  x_radish_state = RADISH_TX_DISC_ERROR_OUT_WAIT_EOT;
		  }
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX_RESPONSE);
	  }
	  else
	  {
		  ++lapm_retransmit;
		  retransmit_count++;
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX_MODE_IND);
	  }
	  IoRadishState = IO_RADISH_NULL;
	  break;


  case IO_RADISH_RETRANSMIT:
	  //x_debug_msg("retransmitting...");
	  // if there isn't enough room in the dce buffer then return.
	  if ( io_get_dce_tx_count() < ALLOC_TX_FRAME_SIZE+6 )                  // N201+3+6FLAGS
		  break;

	  if ( !RadishTxHdlcFrame() )
		  IoRadishState = IO_RADISH_WAIT_FOR_END_TX_DATA;
	  break;


	  //------------------------------------------------------------------------
	  //   DATA MODE -  Receive
	  //------------------------------------------------------------------------

  case IO_RADISH_RX_DATA:

	  // check for a message event from the host
          if (!x_modem_originate)
          {
                if ( RcvdEventFromDte(DLE_CAN) )
                {
                          x_debug_msg("radish- got host DLE_CAN");
////gfh                          IoRadishState = IO_RADISH_WAIT_FOR_SILENCE;
////gfh                          x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_DETECT_TONES);
//gfh                          IoRadishState = IO_RADISH_WAIT_FOR_CARRIER_LOSS;
//gfh                          io_timer = x_current_time(); 
//gfh                          return (TRUE);
                        Tx_TermChar = DLE_CAN;
                  }
          }
	  RadishRxHdlcFrame();
	  FrameType = RadishRxFrameType();
	  switch ( FrameType )
	  {
	  case IFRM:
                  if(Tx_TermChar == DLE_CAN)
                  {
                        x_radish_state = RADISH_TX_DISC_AND_SEND_EOT_TO_DTE;
                        IoRadishState = IO_RADISH_WAIT_FOR_CARRIER_LOSS;
                        io_timer = x_current_time();      // start T203 for silence
                        return(TRUE);
                  }
		  if(RadishRxFrame.status == RADISH_RX_FRAME_STATUS_LONG)
		  {
			  RadishOptions.ErrorReport = MAX_OCTETS_EXCEEDED;
			  x_radish_state = RADISH_TX_DISC_ERROR_OUT;
			  IoRadishState = IO_RADISH_WAIT_FOR_CARRIER_LOSS;
			  io_timer = x_current_time();      // start T203 for silence
			  return(TRUE);
		  }
		  if ( !ProcessIFrame() )
		  {
			  x_debug_msg("partial I frame...");
			  if(RadishRcvFirstBlock == FALSE)
			  {
				  x_radish_state = RADISH_TX_UA;
			  }
			  else
			  {
				  x_radish_state = RADISH_TX_RR;
				  RadishRcvFirstBlock = TRUE;
			  }
//                          IoRadishState = IO_RADISH_WAIT_FOR_SILENCE;
//                          x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_DETECT_TONES);
                          IoRadishState = IO_RADISH_WAIT_FOR_CARRIER_LOSS;
			  io_timer = x_current_time();	//wait for a legal frame
		  }
		  else
		  {
			  RadishRcvFirstBlock = TRUE;
			  RcvFrameCount++;
			  io_timer = x_current_time();              // reset T203 timer
			  IoRadishState = IO_RADISH_RX_PROCESS_TERM_CHAR_AND_POLL;
		  }
		  return (TRUE);

	  case DISC_FRM:
		  ReportEvent(EV_CAN);
		  RadishOptions.ErrorReport = UNEXPECTED_DISC_RXD;
		  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
		  return (TRUE);

	  case EMPTY_FRM:
		  break;

	  default:
		  x_radish_state = RADISH_TX_UA;
		  IoRadishState = IO_RADISH_WAIT_FOR_CARRIER_LOSS;
		  io_timer = x_current_time();	
		  break;
	  }

	  // if timeout, append <DLE><CAN> to data
	  if (x_elapsed_time(io_timer) > T203)           // T203 = 15sec
	  {
		  ReportEvent(EV_CAN);
		  RadishOptions.ErrorReport = TIMEOUT_VALID_DFRAME;
		  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;

	  }
	  break;


  case IO_RADISH_RX_PROCESS_TERM_CHAR_AND_POLL:
#ifdef DEBUGGING
	  sprintf(szBuffer,"processing Term char...%x ",Rx_TermChar);
	  x_debug_msg(szBuffer);
	  sprintf(szBuffer,"lapm_poll=%x",lapm_poll);
	  x_debug_msg(szBuffer);
#endif
	  if( (RcvFrameCount == K) && (!lapm_poll) )
	  {
		  //if we get here the remote is trying to send too many I frames
		  RadishOptions.ErrorReport = MAX_I_FRAMES_EXCEEDED;
		  x_radish_state = RADISH_TX_DISC_ERROR_OUT;
		  IoRadishState = IO_RADISH_WAIT_FOR_CARRIER_LOSS;
		  io_timer = x_current_time();      // start T203 for silence
		  return(TRUE);
	  }
	  switch (Rx_TermChar)
	  {
	  case DLE_ESC:
		  RadishOptions.ErrorReport = NO_ERROR;
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_RETURN_TO_VOICE);
		  x_send_mail(AT_OK,AT_TASK,0,0);
		  return (FALSE);

	  case DLE_CAN:
		  if(!RadishOptions.SequenceResponseControl)
		  {
			  RadishOptions.ErrorReport = INVALID_TERMINATOR_CHAR;
			  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
			  return(TRUE);
		  }
	  case DLE_EOT:
		  io_timer = x_current_time();      // start T200
		  x_radish_state = RADISH_TX_RR_AND_WAIT_FOR_DISC;
		  IoRadishState = IO_RADISH_WAIT_FOR_CARRIER_LOSS;
		  return (TRUE);

	  case DLE_ETB:
	  case DLE_ETX:
#ifndef MS_RADISH_TEST_APPL
		  if (AltLink == DLE_ETB)
		  {
			  RadishOptions.ErrorReport = INVALID_TERMINATOR_CHAR;
			  x_radish_state = RADISH_TX_DISC_ERROR_OUT;
			  IoRadishState = IO_RADISH_WAIT_FOR_CARRIER_LOSS;
		  }

		  // turn the link around
		  else
#endif
		  {
			  AltLink = Rx_TermChar;
			  Rx_TermChar = NUL;
			  x_radish_state = RADISH_TX_RR_AND_TX_MODE_IND;
			  IoRadishState = IO_RADISH_WAIT_FOR_CARRIER_LOSS;
		  }
		  io_timer = x_current_time();      // start T203 for silence
		  return (TRUE);
	  }
	  // if poll bit is set then send RR
	  if ( lapm_poll )
	  {	
		  if(!RadishOptions.SequenceResponseControl)
		  {
			  ReportEvent(EV_CAN);
			  RadishOptions.ErrorReport = INVALID_TERMINATOR_CHAR;
			  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
			  return(TRUE);
		  }

		  x_radish_state = RADISH_TX_RR;
		  IoRadishState = IO_RADISH_WAIT_FOR_CARRIER_LOSS;
		  io_timer = x_current_time();      // start T203 for silence
	  }
	  else
		  IoRadishState = IO_RADISH_RX_DATA;
	  break;


  case IO_RADISH_TX_RESPONSE:
	  // if SSR is set to 0 then send no response.
	  if ( RadishOptions.SequenceResponseControl )
	  {

		  switch (x_radish_state)
		  {
		  case RADISH_TX_DISC_AND_SEND_EOT_TO_DTE:
		  case RADISH_TX_DISC:
		  case RADISH_TX_DISC_ERROR_OUT:
		  case RADISH_TX_DISC_AND_GET_OUT:
		  case RADISH_TX_DISC_ERROR_OUT_WAIT_EOT:
			  x_debug_msg("IO - Transmitted DISC frame");
			  TxControlFrame(DISC,TRUE,FALSE);
			  break;

		  case RADISH_TX_UA:
		  case RADISH_TX_UA_DATA_MODE_RESPONSE:
			  x_debug_msg("IO - Transmitted UA frame");
			  TxControlFrame(UA,FALSE,FALSE);
			  break;

		  case RADISH_TX_RR:
		  case RADISH_TX_RR_AND_TX_MODE_IND:
		  case RADISH_TX_RR_AND_WAIT_FOR_DISC:
		  case RADISH_TX_RR_AND_WAIT_FOR_MODE_IND:
			  x_debug_msg("IO - Transmitted RR frame");
			  (RnrRecovery) ? TxControlFrame(RR,TRUE,TRUE)
				  : TxControlFrame(RR,FALSE,TRUE);
			  lapm_poll = 0;
			  break;

		  case RADISH_TX_RNR:
			  x_debug_msg("IO - Transmitted RNR frame");
			  TxControlFrame(RNR,FALSE,TRUE);
			  break;
		  }
	  }
	  IoRadishState = IO_RADISH_WAIT_FOR_END_TX_RESPONSE;
	  break;


  case IO_RADISH_WAIT_FOR_END_TX_RESPONSE:
	  if (!io_dce_tx_fifo_empty() )
		  break;

	  switch (x_radish_state)
	  {
	  case RADISH_TX_DISC_AND_SEND_EOT_TO_DTE:
		  ReportEvent(EV_EOT);

	  case RADISH_TX_DISC:
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_RETURN_TO_VOICE);
		  x_send_mail(AT_OK,AT_TASK,0,0);
		  return (FALSE);

	  case RADISH_TX_RR:
		  if ( RnrRecovery )
		  {
			  x_radish_state = RADISH_RX_RNR_RECOVERY;
			  x_radish_rate = VV_V21_300;
			  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_RX_EXPEDITE);
			  break;
		  }

	  case RADISH_TX_RNR:
	  case RADISH_TX_UA:
	  case RADISH_TX_RR_AND_WAIT_FOR_MODE_IND:
		  x_radish_state = RADISH_RX_MODE_IND;
		  x_radish_rate = VV_V21_300;
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_RX_EXPEDITE);
		  break;

	  case RADISH_TX_RR_AND_TX_MODE_IND:
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX_MODE_IND_IDLE);
		  break;

	  case RADISH_TX_RR_AND_WAIT_FOR_DISC:
		  x_debug_msg("IO - Go and wait for DISC...");
		  x_radish_state = RADISH_WAIT_FOR_DISC_FRAME;
		  x_radish_rate = VV_V21_300;
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_RX_EXPEDITE);
		  break;

	  case RADISH_TX_UA_DATA_MODE_RESPONSE:
	  case RADISH_TX_DISC_AND_GET_OUT:
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_RETURN_TO_VOICE);
		  return(FALSE);

	  case RADISH_TX_DISC_ERROR_OUT:
		  ReportEvent(EV_CAN);
		  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
		  return(TRUE);

	  case RADISH_TX_DISC_ERROR_OUT_WAIT_EOT:
		  ReportEvent(EV_CAN);
		  IoRadishState = IO_RADISH_WAITING_FOR_RESP_FROM_HOST;
		  io_timer = x_current_time();        // start T310;
		  return(TRUE);


	  }
	  IoRadishState = IO_RADISH_NULL;
	  return (TRUE);


  case IO_RADISH_WAIT_FOR_DISC_FRAME:
	  RadishRxHdlcFrame();
	  FrameType = RadishRxFrameType();
	  switch ( FrameType )
	  {

	  case DISC_FRM:
		  RadishOptions.ErrorReport = NO_ERROR;
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_RETURN_TO_VOICE);
		  x_send_mail(AT_OK,AT_TASK,0,0);
		  return (FALSE);

	  default:
		  break;
	  }
	  if (x_elapsed_time(io_timer) > T200)           // T200 = 2sec
	  {
		  ReportEvent(EV_CAN);
		  RadishOptions.ErrorReport = TIMEOUT_FAR_END_RESP_TO_DMODE_START;
		  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
	  }

	  break;


  case IO_RADISH_WAIT_FOR_SILENCE:
  case IO_RADISH_WAIT_FOR_CARRIER_LOSS:
          if(IoRadishState == IO_RADISH_WAIT_FOR_SILENCE) 
          {
                  x_send_mail(RADISH_DP_TASK,DP_TASK,&silence,RADISH_CHECK_FOR_SILENCE);
          }
          else
	  {
		  x_send_mail(RADISH_DP_TASK,DP_TASK,&silence,RADISH_CHECK_FOR_CARRIER_LOSS);
	  }
	  if ( silence && (x_elapsed_time(io_timer) > 100) )
	  {
		  x_debug_msg("silence...");
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_STARTUP_TX_RESPONSE);
		  IoRadishState = IO_RADISH_NULL;
	  }
	  else if ( (x_elapsed_time(io_timer) > T203) )           // T203 = 15sec
	  {
		  RadishOptions.ErrorReport = TIMEOUT_VALID_DFRAME;
		  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
	  }
	  break;


  case IO_RADISH_WAIT_FOR_ATSAC_CMD:
	  if ( io_get_dte_rx_char ( &io_dte_rx_last_ch ) )
	  {
		  x_send_mail ( IO_AT_DATA, AT_TASK, &io_dte_rx_last_ch, 1 );
		  io_timer = x_current_time ();
	  }
	  else if ( x_elapsed_time(io_timer) > T310 )   // T310=1sec
	  {
		  RadishOptions.ErrorReport = TIMEOUT_RESP_FROM_DTE_AFTER_EVENT;
		  x_radish_state = RADISH_TX_DISC_ERROR_OUT;
		  IoRadishState = IO_RADISH_WAIT_FOR_CARRIER_LOSS;

		  // start silence timer (T203)
		  io_timer = x_current_time();
	  }
	  break;


  case IO_RADISH_ATSAC_CMD_RCVD:
	  at_sac_executed = TRUE;
	  x_send_mail(RADISH_AT_TASK, AT_TASK, 0, RADISH_AT_CONNECT);
	  x_radish_state = RADISH_RX_DATA;	//in case we connect after receiving AT-SAC command
	  RcvFrameCount = 0;
	  IoRadishState = IO_RADISH_RX_DATA;
	  break;


  case IO_RADISH_RETURN_TO_VOICE_FROM_DATA_MODE:
	  if ( Tx_TermChar )
		  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;

	  // if host is still sending data then stop it by sending
	  // <DLE><CAN>. Wait for <DLE><EOT> from host before RTV.
	  else
	  {
		  ReportEvent(EV_CAN);
		  IoRadishState = IO_RADISH_WAITING_FOR_RESP_FROM_HOST;
		  io_timer = x_current_time();        // start T310;
	  }
	  break;


  case IO_RADISH_WAITING_FOR_RESP_FROM_HOST:
	  if ( RcvdEventFromDte(DLE_EOT) )
	  {
                  x_debug_msg("IO-got EOT msg");
                  if(Rx_TermChar == DLE_CAN)
                  {
                        RadishOptions.ErrorReport = NO_ERROR;
                        x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_RETURN_TO_VOICE);
                        x_send_mail(AT_OK,AT_TASK,0,0);
                        return (FALSE);
                  }
                  else
                  {
                        IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
                  }
	  }
	  else if ( x_elapsed_time(io_timer) > T310 )
	  {
		  x_debug_msg("IO-never got EOT msg");
		  RadishOptions.ErrorReport = TIMEOUT_RESP_FROM_DTE_AFTER_EVENT;
		  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
	  }
	  break;


  case IO_RADISH_WAIT_FOR_DATA_MODE_RESPONSE:
	  RadishRxHdlcFrame();
	  FrameType = RadishRxFrameType();
	  switch ( FrameType )
	  {
	  case UA_FRM:
		  RadishOptions.ErrorReport = NO_ERROR;
		  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_RETURN_TO_VOICE);
		  x_send_mail(AT_OK,AT_TASK,0,0);
		  return(FALSE);

	  case DISC_FRM:
		  RadishOptions.ErrorReport = UNEXPECTED_DISC_RXD;
		  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
		  x_debug_msg("IO- got disc from mode ind.");
		  return(TRUE);

	  default:
		  break;
	  }
	  if (x_elapsed_time(io_timer) > T200)           // T200 = 2sec
	  {
		  RadishOptions.ErrorReport = TIMEOUT_FAR_END_RESP_TO_DMODE_START;
		  IoRadishState = IO_RADISH_ERROR_RETURN_TO_VOICE;
	  }

	  break;

  case IO_RADISH_ERROR_RETURN_TO_VOICE:
	  x_send_mail(RADISH_AT_TASK,AT_TASK,0,RADISH_ERROR);
	  return (FALSE);

  case IO_RADISH_DISCONNECT:
	  return(FALSE);

  case IO_RADISH_DISC_CAN:
	  RadishOptions.ErrorReport = CANT_INIT_DMODE_CAP_INACTIVE;
	  x_radish_state = RADISH_TX_DISC_ERROR_OUT;
	  IoRadishState = IO_RADISH_WAIT_FOR_SILENCE;
	  x_send_mail(RADISH_DP_TASK,DP_TASK,0,RADISH_DETECT_TONES);
	  io_timer = x_current_time();   // start silence timer (T203)
	  break;

  case IO_RADISH_NULL:
	  break;

  }

  return (TRUE);
}
#endif
