/*name and version number:@(#)dpcall.c	1.324*/
/*date of get: 		  12/15/00 10:10:19*/
/*date of delta:	  11/29/00 10:19:02*/
/****************************************************************
File :	dpcall.c
Description :
	Contains all functions related to call progress for the data pump.

Procedures Contained :
	dp_DTMF_dial_cmd
	dp_pulse_dial_cmd
	dp_set_lb_filter
	dp_detect_tones_cmd
	dp_dial_tone_detected
	dp_answer_tone_detected
	dp_busy_tone_detected
	dp_quiet_answer_detected
	dp_calling_tone_cmd
	dp_dial

Revision History :
	Initials	Date		Change
	VR      	06/17/93	Initial
	AV			02/25/94	Added calling tone function
	AV			03/07/94	Modified & moved dp_dial from dpmain
						ANS waiting changed to 500 from 100
	AV			04/11/94	Added ringback detetcion
	AV			05/13/94	Modified set_lb_filter, detetct_tones &
						busy_tone_detected for homolgation
	AV			06/29/94	Added blacklisting functions
*****************************************************************/

#include "llglob_d.h"
#include "dpglob.h"
#if defined(V80) || defined(V8BIS) || defined (V92)
#include "sync.h"
#endif	//V80 || V8BIS || V92
#ifdef DC0
#include "cellular.h"
#endif	// DC0

#if defined(CS_MODEM)
#include "csglob.h"
#endif
#include "allglobs.h"

#define	LISTFULL 0xfe
#define	NOTFOUND 0xff
#define BLACK_LISTED 0
#define DE_LAYED 1
#define FAILEDCALL 2
#define BLANK "                                "

/*****************************************************************************
	External Variables
*****************************************************************************/
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
extern const word dp_voice_f8khz[] ;
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif
#ifdef IWF_DATA
extern byte cs_2nd_dialtone_detect; 
#endif

extern word at_itoa( word num, byte *str, byte format) ;
extern byte dp_voice_dialtone_detected ( void ) ;

#ifndef HOMOL
static const word filter_tab[] = {
	IIR1_K_ADDR, 0x3150,	/*K - iir1     */

	IIR1_D11_ADDR, 0x91ed,	/*d(1,1) - iir1*/
	IIR1_D12_ADDR, 0x3704,	/*d(1,2) - iir1*/
	IIR1_N11_ADDR, 0x0000,	/*n(1,1) - iir1*/
	IIR1_N12_ADDR, 0xf84e,	/*n(1,2) - iir1*/
	IIR1_N10_ADDR, 0x07b2,	/*n(1,0) - iir1*/

	IIR1_D21_ADDR, 0x97ae,	/*d(2,1) - iir1*/
	IIR1_D22_ADDR, 0x3ab5,	/*d(2,2) - iir1*/
	IIR1_N21_ADDR, 0xfa26,	/*n(2,1) - iir1*/
	IIR1_N22_ADDR, 0x0505,	/*n(2,2) - iir1*/
	IIR1_N20_ADDR, 0x0505,	/*n(2,0) - iir1*/

	IIR1_D31_ADDR, 0x8763,	/*d(3,1) - iir1*/
	IIR1_D32_ADDR, 0x3d3d,	/*d(3,2) - iir1*/
	IIR1_N31_ADDR, 0xb7b4,	/*n(3,1) - iir1*/
	IIR1_N32_ADDR, 0x2491,	/*n(3,2) - iir1*/
	IIR1_N30_ADDR, 0x2491	/*n(3,0) - iir1*/
};
#endif

#ifdef HOMOL
const word iircoef[]={
			0x2480, 0x8f16, 0x39a8, 0x0000, 0xfbf0, 0x0410, 0x91aa, 0x3cd5,
			0xed1d, 0x0bd4, 0x0bd4, 0x878e, 0x3dfe, 0xa5c3, 0x2e40, 0x2e40,

			0x1f60, 0x8a1b, 0x3d11, 0x0000, 0xfd50, 0x02b0, 0x8bf1, 0x3e72,
			0xeeda, 0x0a48, 0x0a48, 0x862a, 0x3ee6, 0xa53e, 0x2e43, 0x2e43,

			0x2480, 0x8b07, 0x3ce9, 0x0000, 0xfe10, 0x01e3, 0x8ce3, 0x3e6a,
			0xe94c, 0x0d71, 0x0d71, 0x8834, 0x3ebe, 0xb32a, 0x27a3, 0x27a3,

			0x3180, 0x8b5f, 0x3b2a, 0x0000, 0xfc37, 0x03c9, 0x8d40, 0x3d2a,
			0xf9a6, 0x04a0, 0x04a0, 0x8613, 0x3e2b, 0xb62b, 0x2536, 0x2536,

			0x0a00, 0x8a5b, 0x3ebf, 0x0000, 0xff53, 0x00ad, 0x8aba, 0x3f5e,
			0xe42e, 0x0fc4, 0x0fc4, 0x88de, 0x3f6c, 0xb3bd, 0x27db, 0x27db,

			0x3150, 0x91ed, 0x3704, 0x0000, 0xf84e, 0x07b2, 0x97ae, 0x3ab5,
			0xfa26, 0x0505, 0x0505, 0x8763, 0x3d3d, 0xb7b4, 0x2491, 0x2491,

			0x1f60, 0x8d12, 0x3c01, 0x0000, 0xfdc2, 0x023e, 0x8e96, 0x3e45,
			0xdeb8, 0x1353, 0x1353, 0x87e6, 0x3ebd, 0x82c3, 0x4116, 0x4116
#ifdef DC0
			// 310 - 1150 BPF
			,0x8140, 0x9fee, 0x2f93, 0x0000, 0xee26, 0x11da, 0xbcae, 0x37e6,
			0xfe51, 0x03d5, 0x03d5, 0x87b3, 0x3d2d, 0xaad0, 0x2b58, 0x2b58
#endif
			};

/*****************************************************************************
	Function : dp_get_delay
			  Returns value of delay in effect
*****************************************************************************/
byte dp_get_delay( byte index )
{
	byte delay ;

	switch( G(dp_blacklist)[index].status_code )
	{
		case TROUBLE :
			delay = G(S).ModemOptions.TroubleCallDelay ;
			break ;
		case ERRONEOUS :
			delay = G(S).ModemOptions.ErroneousCallDelay ;
			break ;
		default:
			delay = 0 ;

	}

	return (delay) ;
}
/****************************************************************
	Function : dp_init_blacklist
	Description : Initialize blacklist
*****************************************************************/
void dp_init_blacklist()
{
	byte i ;
	BLACKLIST_RECORD *blp;

	G(dp_failures) = 0 ;		
	G(dp_blacklist_calls) = 0 ;
	for ( i=0; i < BLACKLIST_SIZE ; i++ )
	{
		blp = &G(dp_blacklist)[i];

		blp->tel_number[0] = 0 ;
		blp->status_code = DP_SUCCESS ;
		blp->attempts = 0 ;
	}
}

/*****************************************************************************
	Function :  dp_filter_modifiers
			 Filters all dial modifiers in the string 
*****************************************************************************/
void dp_filter_modifiers ( byte *number )
{
	byte i=0 ;
	while( (*number != 0) && ( i < MAX_DIGITS ) )
	{
		if ( ((*number >= '0') && (*number <= '9')) 
			|| (*number == '*') || (*number == '#') 
			|| (*number == 'A') || (*number == 'B') 
			|| (*number == 'C') || (*number == 'D') )
		{
			*(G(dialed_number) + i) = *number; 
			i++;
		}
		number++;
	}
	*(G(dialed_number) + i) = 0 ;
}

/*****************************************************************************
	Function :  dp_search_list
				Returns index of the entry in the list if the number is
				blacklisted, LISTFULL if the entry is not found and the
				list is full, NOTFOUND otherwise.
*****************************************************************************/
byte dp_search_list( byte *number )
{
	byte i,j ;
	byte *ptr, *num ;
	byte listfull ;

	if ( *number == 0 )		// just atd, no digits
		return ( NOTFOUND ) ;

	listfull = TRUE ;

	for ( i=0; i < BLACKLIST_SIZE ; i++ )
	{
		ptr = G(dp_blacklist)[i].tel_number ;
		num = number ;
		j=0 ;
		if (*ptr == 0)
			listfull = FALSE ;
		else
		{
			while((*num == *ptr) && (*num != 0) && (*ptr != 0) && ( j < MAX_DIGITS ) )
			{
				num++ ;
				ptr++ ;
				j++ ;
			}
			if ( ( (*num == 0) && (*ptr == 0) ) || (j == MAX_DIGITS) )
				return (i) ;
		}
	}

	if (listfull)
		return ( LISTFULL ) ;
	else
		return ( NOTFOUND ) ;

}

/*****************************************************************************
	Function : dp_check_delay
			  Returns TRUE if number is delayed, FALSE otherwise.
*****************************************************************************/
byte dp_check_delay( byte index)
{
	if ( G(dp_blacklist)[index].attempts <= G(S).ModemOptions.DelayAttempts ) 
		return ( FALSE ) ;	// delay not ineffect
	else if ( x_elapsed_minutes(G(dp_blacklist)[index].time_listed) >=
													(word) dp_get_delay(index) )
		return ( FALSE ) ;	// delay not ineffect
	return ( TRUE ) ;	// delay ineffect
}

/*****************************************************************************
	Function : dp_check_list
			  Returns TRUE if number is blacklisted or delayed
			  or list is full, FALSE otherwise.
*****************************************************************************/
byte dp_check_list( byte *dialstring)
{
	byte i ;

	if ( ( G(S).ModemOptions.MaxAttempts != 255 )  
		&& ( G(dp_failures) >= G(S).ModemOptions.MaxAttempts ) ) 
	{
		G(x_dial_residual) = MR_BLACKLISTED ;
		x_debug_msg("DP - Blacklisted - max failures exceeded");
		return ( TRUE ) ;
	}

	dp_filter_modifiers( dialstring ) ;
	i = dp_search_list( G(dialed_number) ) ;

	if ( i == NOTFOUND )
		return ( FALSE ) ;

	if ( i == LISTFULL )
	{
		G(x_dial_residual) = MR_BLACKLIST_FULL ;
		x_debug_msg("DP - Blacklist full");
		return ( TRUE ) ;
	}

	if ( G(dp_blacklist)[i].attempts >= G(S).ModemOptions.MaxCallAttempts) // blacklisted
	{
		G(x_dial_residual) = MR_BLACKLISTED ;
		x_debug_msg("DP - Blacklisted");
		return ( TRUE ) ;
	}
	else if ( dp_check_delay(i) ) // delayed
	{
		G(x_dial_residual) = MR_DELAYED ;
		x_debug_msg("DP - Delayed");
		return ( TRUE ) ;
	}

	return ( FALSE ) ; //temporarily listed, neither blacklisted or delayed
}

/*****************************************************************************
	Function : dp_update_blacklist
				Adds, deletes, updates entry in the blacklist.
*****************************************************************************/
void dp_update_blacklist( byte *dialstring, byte code )
{
	byte i ;
	BLACKLIST_RECORD *blp;

	if ( G(S).ModemOptions.MaxAttempts != 255 )  
	{
		if ( ( code != DP_SUCCESS ) 		// unsuccessfull
			&& (++G(dp_failures) >= G(S).ModemOptions.MaxAttempts) ) 
		{
		 	G(dp_time_blacklisted).minutes = G(x_minute_count) ;
		 	G(dp_time_blacklisted).mseconds = (word) x_elapsed_time(G(x_minute_timer)) ;
		}
		else if ( code == DP_SUCCESS ) 		// successful
			G(dp_failures) = 0 ;		
	}

	dp_filter_modifiers( dialstring ) ;
	i = dp_search_list( G(dialed_number) ) ;
	if ( *G(dialed_number) == 0 ) // no digits, just ATD, nothing to blacklist
		return ;

	blp = &G(dp_blacklist)[i];

	if ( i != NOTFOUND ) // currently in the list 
	{
		if ( code == DP_SUCCESS )
		{
			blp->tel_number[0] = 0 ;
			blp->status_code = DP_SUCCESS ;
			blp->attempts = 0 ;
			G(dp_blacklist_calls)-- ;
		}
		else
		{
			if ( blp->attempts == G(S).ModemOptions.DelayAttempts ) 
				G(dp_blacklist_calls)++ ;

			blp->status_code = (CALL_STATUS_CODE) code ;
			if ( code == ERRONEOUS )
				blp->attempts = (byte) (blp->attempts + G(S).ModemOptions.ErrorCallWeight);	
			else
				blp->attempts++ ;
			if ( G(S).ModemOptions.CountryId != JAPAN )
			{
		 		blp->time_listed.minutes = G(x_minute_count) ;
		 		blp->time_listed.mseconds =
					(word) x_elapsed_time(G(x_minute_timer)) ;
			}
		}
	}
	else if ( code != DP_SUCCESS ) // currently not in the list & unsuccessfull
	{
		for ( i=0; i < BLACKLIST_SIZE ; i++ )
		{
			blp = &G(dp_blacklist)[i];

			if ( blp->tel_number[0] == 0 )
			{
				x_strcpy( blp->tel_number, G(dialed_number) ) ;
				blp->status_code = (CALL_STATUS_CODE)code ;
				if ( code == ERRONEOUS )
					blp->attempts = G(S).ModemOptions.ErrorCallWeight ;	
				else
					blp->attempts = 1 ;
		 		blp->time_listed.minutes = G(x_minute_count) ;
		 		blp->time_listed.mseconds =
					(word) x_elapsed_time(G(x_minute_timer)) ;
				if ( G(S).ModemOptions.DelayAttempts == 0 ) 
					G(dp_blacklist_calls)++ ;
				return ;
			}
		}
	}
}

/*****************************************************************************
	Function : dp_blacklist_periodic
				Clears entries in the blacklist if the blacklist time
				is expired. Also increments the minute counter.
*****************************************************************************/
void dp_blacklist_periodic( void )
{
	byte i ;
	word period ;

	if ( G(S).ModemOptions.BlackListPeriod == 255 )
		return ;

	if ( G(S).ModemOptions.CountryId == JAPAN )
		period = (word) (G(S).ModemOptions.BlackListPeriod) ;	// in minutes
	else
		period = (word) (10 * G(S).ModemOptions.BlackListPeriod) ; // in minutes

	if ( G(S).ModemOptions.MaxAttempts != 255 )  
	{
		if ( ( G(dp_failures) >= G(S).ModemOptions.MaxAttempts )  
			 && ( x_elapsed_minutes(G(dp_time_blacklisted)) >= period ) )
			G(dp_failures) = 0 ;		
	}
	// update blacklist

	for ( i=0; i < BLACKLIST_SIZE ; i++ )
	{
		// clear blacklist entries if delay is not in effect and past
		// blacklisting period
		if ( (G(dp_blacklist)[i].tel_number[0] != 0) && (!dp_check_delay(i))
			 && ( x_elapsed_minutes(G(dp_blacklist)[i].time_listed) >= period ) )

		{
			G(dp_blacklist)[i].tel_number[0] = 0 ;
			G(dp_blacklist)[i].status_code = DP_SUCCESS ;
			G(dp_blacklist)[i].attempts = 0 ;
			G(dp_blacklist_calls)-- ;
		}
	}
}

/****************************************************************************
	Function : dp_display_number
				this function displays delayed number
*****************************************************************************/
void dp_display_number(byte list_type, byte i)
{
	byte msg[5] ;
	word duration ;
	word seconds ;
	word minutes ;
	BLACKLIST_RECORD *blp = &G(dp_blacklist)[i];

	x_send_at_io_data(blp->tel_number);

	x_send_mail( AT_IO_DATA, IO_TASK, (byte *) BLANK,
				(byte)(30 - x_strlen(blp->tel_number)) ) ;

	seconds = (word) x_elapsed_time(G(x_minute_timer)) ;
	if ( seconds > blp->time_listed.mseconds)
		seconds = (word)(60000 - seconds
						+ blp->time_listed.mseconds) ;
	else
		seconds = (word) (blp->time_listed.mseconds - seconds) ;

	if( list_type == DE_LAYED )
		duration = (word) dp_get_delay(i) ;
	else
	{
		if ( G(S).ModemOptions.CountryId == JAPAN )
			duration = (word) (G(S).ModemOptions.BlackListPeriod) ; // minutes
		else
			duration = (word) (10 * G(S).ModemOptions.BlackListPeriod) ; // minutes
	}

	if ( blp->attempts > G(S).ModemOptions.DelayAttempts ) 
	{
		if ( (list_type == BLACK_LISTED) &&
			( G(S).ModemOptions.BlackListPeriod == 255 ) )  // forever
		{
			x_send_at_io_data((byte *) "Forever");
		}
		else
		{
			minutes = (word)( duration - x_elapsed_minutes(blp->time_listed) ) ;
			if ( seconds != 0)
				minutes -= 1 ;
			at_itoa ( minutes, msg, DECIMAL);
			x_send_at_io_data(msg);
			x_send_at_io_data((byte *) ":");
			if ( (!minutes) && (seconds < 1000) )
				seconds = 1000 ;
			at_itoa ( (word)(seconds/1000), msg,DECIMAL);
			x_send_at_io_data(msg);
			x_send_at_io_data((byte *) " min");
		}
	}

	x_send_at_io_crlf();
}

/****************************************************************************
	Function : dp_show_nubers
				this function displays blacklisted or delayed numbers
*****************************************************************************/
void dp_show_numbers( byte list_type )
{
	byte i ;
	byte str[4] ;
	byte title_displayed ;
	BLACKLIST_RECORD *blp;

	str[0] = G(S).ModemOptions.CRChar ;
	str[1] = G(S).ModemOptions.LFChar ;
	str[2] = 0 ;


	title_displayed = FALSE ;

	for ( i=0; i < BLACKLIST_SIZE ; i++ )
	{
		blp = &G(dp_blacklist)[i];

		if ( blp->tel_number[0] != 0 )
		{
			if ( (list_type == BLACK_LISTED)
					&& (blp->attempts >= G(S).ModemOptions.MaxCallAttempts) )
			{
				if (title_displayed == FALSE )
				{
					x_send_at_io_data((byte *) "Blacklisted:");
					x_send_at_io_data(str);
					title_displayed = TRUE ;
				}
				dp_display_number(BLACK_LISTED, i) ;
			}
			else if ( (list_type == DE_LAYED) 	// display delayed numbers
					&& (blp->attempts < G(S).ModemOptions.MaxCallAttempts) //not blacklisted
				 	&& ( dp_check_delay(i) ) )	 // delayed
			{
				if (title_displayed == FALSE )
				{
					x_send_at_io_data((byte *) "Delayed:");
					x_send_at_io_data(str);
					title_displayed = TRUE ;
				}
				dp_display_number(DE_LAYED, i) ;
			}
			else if ( (list_type == FAILEDCALL) 	// display failed numbers
					&& (blp->attempts < G(S).ModemOptions.MaxCallAttempts) //not blacklisted
				 	&& ( !dp_check_delay(i) ) )	 // not delayed, failed
			{
				if (title_displayed == FALSE )
				{
					x_send_at_io_data((byte *) "Failed:");
					x_send_at_io_data(str);
					title_displayed = TRUE ;
				}
				x_send_at_io_data(blp->tel_number);
				x_send_at_io_data(str);
			}
		}
	}
}

/****************************************************************************
	Function : dp_show_blacklist
				this function displays blacklisted & delayed numbers
*****************************************************************************/
void dp_show_blacklist( void )
{
	x_send_at_io_crlf();
	if ( ( G(S).ModemOptions.MaxAttempts != 255 )
		&& ( G(dp_failures) >= G(S).ModemOptions.MaxAttempts ) )
	{
		x_send_at_io_data((byte *) "Blacklisted");
		x_send_at_io_crlf();
		return ;
	}
	dp_show_numbers( BLACK_LISTED ) ;
	dp_show_numbers( DE_LAYED ) ;
	dp_show_numbers( FAILEDCALL ) ;
}

#ifdef VOICE
#ifdef CALLER_ID
/*****************************************************************************
	Function : dp_japan_alert_init ( )
	Initialize Japan caller id ring detection
	NOTE: Since ring back detection is not required when detecting
	CID ring the ring back detection variables are used here for
	CAR ring detection.
*****************************************************************************/
void dp_japan_alert_init ( void )
{
	G(dp_ringback_on_timer) = x_current_time () ;
	G(dp_ringback_off_timer) = x_current_time () ;
	G(dp_ringback_state) = DP_ENERGY_OFF ;
	G(dp_ringback_on_cadence) = 0 ;
	G(dp_ringback_off_cadence) = 0 ;
	G(dp_ringback_cycles) = 0 ;
}

/*****************************************************************************
	Function : dp_uk_alert_init
	Initialize uk caller id alert signal detection
*****************************************************************************/
void dp_uk_alert_init ( void )
{
	x_output ( IO_CALLER_ID_ON ) ;	// send command to activate cid relay
	dp_write_dsp_ram (0x26, 40);              // Detect threshold -40 dbm
	dp_write_dsp_ram (0x1C, 0xef65);	      // 2100 Hz
	dp_write_dsp_ram (0x1D, 0xedc8);	      // 2130 Hz
	dp_write_dsp_ram (0x1E, 0xec2e);	      // 2160 Hz
	dp_write_dsp_ram (0x1F, 0xd1ec);	      // 2720 Hz
	dp_write_dsp_ram (0x20, 0xd0c7);	      // 2750 Hz
	dp_write_dsp_ram (0x21, 0xcfa9);	      // 2780 Hz
	dp_modem_command (DETECT_TONES, 6, 0); // Detect 6 tones
	G(dp_ringback_on_timer) = x_current_time () ;
}

/*****************************************************************************
	Function : dp_cid_alert_init
	Initialize caller id alert signal detection
*****************************************************************************/
void dp_cid_alert_init ( void )
{
	if ( (0x0f & G(S).ModemOptions.CallerIdType) == 1 ) // Japan CID
		dp_japan_alert_init ( ) ;
	else if ( (0x0f & G(S).ModemOptions.CallerIdType) == 2 ) // UK (SIN242)
		dp_uk_alert_init ( ) ;
}

/*****************************************************************************
	Function : dp_japan_alert_detect
	Detect Japan caller id ring
*****************************************************************************/
byte dp_japan_alert_detect ( void )
{
	byte transition = FALSE ;

	switch ( G(dp_ringback_state) )
	{
		case DP_ENERGY_ON :
			if ( dp_ring_detected () == FALSE )
			{
				G(dp_ringback_on_cadence) =
					x_elapsed_time(G(dp_ringback_on_timer)) ;
				G(dp_ringback_off_timer) = x_current_time () ;
				transition = TRUE ;
				G(dp_ringback_state) = DP_ENERGY_OFF ;
			}
			G(dp_ringback_off_timer) = x_current_time () ;
			break ;

		case DP_ENERGY_OFF :
			if ( dp_ring_detected () == TRUE )
			{
				G(dp_ringback_off_cadence) =
					x_elapsed_time(G(dp_ringback_off_timer));
				G(dp_ringback_on_timer) = x_current_time () ;
				transition = TRUE ;
				G(dp_ringback_state) = DP_ENERGY_ON ;
			}
			break ;
	}

	if( transition == TRUE )
	{
		if ( ((G(dp_ringback_on_cadence) > MS400)
			&& (G(dp_ringback_on_cadence) < MS600 ))
			&& ((G(dp_ringback_off_cadence) > MS400)
			&& (G(dp_ringback_off_cadence) < MS600)) )
		{
			G(dp_ringback_cycles)++ ;
		}
	}
	if ( ( G(dp_ringback_cycles) > 0 )	// At least 1 cycle
		&& ( dp_ring_detected () == FALSE ) )
	{
		x_debug_msg("CAR ring detected");
		return( TRUE ) ;
	}

	return( FALSE ) ;
}
/*****************************************************************************
	Function : dp_uk_alert_detect
	Detect UK caller id alert signal
*****************************************************************************/
byte dp_uk_alert_detect ( void )
{
	if ( !(dp_read_dsp_ram (0x28) & 0x0007)  // no low tone
		|| !(dp_read_dsp_ram (0x28) & 0x0038) )  // no high tone
		G(dp_ringback_on_timer) = x_current_time () ; //reset timer

	if ( x_elapsed_time(G(dp_ringback_on_timer)) >= 30 ) // at least 30 ms
		return( TRUE ) ;
		

	return( FALSE ) ;
}

/*****************************************************************************
	Function : dp_cid_alert_detect
	Initialize caller id alert signal detection
*****************************************************************************/
byte dp_cid_alert_detect ( void )
{
	if ( (0x0f & G(S).ModemOptions.CallerIdType) == 1 ) // Japan CID
	{
		return ( dp_japan_alert_detect ( ) ) ;
	}
	else if ( (0x0f & G(S).ModemOptions.CallerIdType) == 2 ) // UK (SIN242)
	{
		return ( dp_uk_alert_detect ( ) ) ;
	}
	else
	{
		return ( FALSE ) ;
	}
}
#endif	//CALLER_ID
#endif //VOICE
#endif // HOMOL

/*****************************************************************************
	Function : dp_DTMF_dial_cmd

	Dial a DTMF digit.
*****************************************************************************/
void dp_DTMF_dial_cmd ( byte digit )
{
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
	word freq1s, freq1c, freq2s, freq2c ;
	word duration ;

	if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
	{
		switch ( digit )
		{
			case 1:
			case 2:
			case 3:
			case 0x0c: //dtmf digit A
				freq1s = F697S8 ;
				freq1c = F697C8 ;
				break ;
			case 4:
			case 5:
			case 6:
			case 0x0d: //dtmf digit B
				freq1s=F770S8 ;
				freq1c=F770C8 ;
				break ;
			case 7:
			case 8:
			case 9:
			case 0x0e: //dtmf digit C
				freq1s=F852S8 ;
				freq1c=F852C8 ;
				break ;
			case 0x0a: //dtmf digit *
			case 0:
			case 0x0b: //dtmf digit #
			case 0x0f: //dtmf digit D
				freq1s=F941S8 ;
				freq1c=F941C8 ;
				break ;
		}

		switch ( digit )
		{
			case 1:
			case 4:
			case 7:
			case 0x0a: //dtmf digit *
				freq2s = F1209S8 ;
				freq2c = F1209C8 ;
				break ;
			case 2:
			case 5:
			case 8:
			case 0: //dtmf digit B
				freq2s = F1336S8 ;
				freq2c = F1336C8 ;
				break ;
			case 3:
			case 6:
			case 9:
			case 0x0b: //dtmf digit #
				freq2s = F1477S8 ;
				freq2c = F1477C8 ;
				break ;
			case 0x0c: //dtmf digit A
			case 0x0d: //dtmf digit B
			case 0x0e: //dtmf digit C
			case 0x0f: //dtmf digit D
				freq2s = F1633S8 ;
				freq2c = F1633C8 ;
				break ;
		}
		dp_write_dsp_ram (0x05, freq1s) ;
		dp_write_dsp_ram (0x06, freq1c) ;
		dp_write_dsp_ram (0x07, freq2s) ;
		dp_write_dsp_ram (0x08, freq2c) ;

		dp_write_dsp_ram (0x14, G(dp_dtmf_low_level)) ; //low tone linear power 
		dp_write_dsp_ram (0x15, G(dp_dtmf_high_level)) ; //high tone linear power 
		// For some (unknown!) reason dial speed need to be 4 times
		// higher in speaker phone mode to get the required on duration
		duration = (word) (G(S).ModemOptions.DtmfDialSpeed << 2);
		duration = (word) (duration + (duration / 10)); 	// duration scaled by 8kh/7.2khz
		dp_write_dsp_ram (0x17, duration ) ;
		dp_write_dsp_ram (0x18, 100) ;	// interdigit delay, does not
										// have any effect, bug in DSP
		dp_write_dsp_ram (NUM_TONES_ADDR, 0xffff) ; //1 minus # of tones (-1 for dtmf)
		dp_write_dsp_ram (FDSP_TONE_PWR_ADDR1, 0x2d41) ;
		dp_write_dsp_ram (FDSP_TONE_PWR_ADDR2, 0x2d41) ;
		dp_write_dsp_ram (FDSP_TONE_PWR_ADDR3, 0x2d41) ;
		dp_write_dsp_ram (FDSP_TONE_PWR_ADDR4, 0x2d41) ;
		dp_write_dsp_ram (FDSP_TONE_PWR_ADDR5, 0x2d41) ;
		dp_write_dsp_ram (FDSP_TONE_PWR_ADDR6, 0x2d41) ;
		dp_write_dsp_ram (TONE_OFFTIME_ADDR, 0) ;
		dp_write_dsp_ram (TONE_ONTIME_ADDR, 0) ;
		dp_write_dsp_ram (TONE_ONFLAG_ADDR, 1) ;
		dp_write_dsp_ram ( TRAIN_GAIN_ADDR, 0x0800 ) ;
		dp_write_dsp_ram ( 0x85, 0x0225 ) ;
	}
	else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif
	{
		/* tone on duration, 95ms for US */
		dp_write_dsp_ram (0x17, (word)G(S).ModemOptions.DtmfDialSpeed) ;
		dp_write_dsp_ram (0x18, (word)G(S).ModemOptions.DtmfDialSpeed) ;
#ifdef DC0
		if ( G(cell_active) == TRUE ) // lower tone for cell call
		{
			dp_write_dsp_ram (0x11, G(S).ModemOptions.DtmfLevel + 5) ; // tone1 power 
			dp_write_dsp_ram (0x12, (word)(G(S).ModemOptions.DtmfLevel + 5 + G(S).ModemOptions.DtmfToneDiff) ) ;	// tone2 power
		}
		else
#endif
		{
		dp_write_dsp_ram (0x11, (word)G(S).ModemOptions.DtmfLevel) ; 	// tone1 power
		dp_write_dsp_ram (0x12, (word)(G(S).ModemOptions.DtmfLevel + G(S).ModemOptions.DtmfToneDiff) ) ;	// tone2 power
		}
		dp_modem_command ( DTMF_DIALING, digit, 0 ) ;
	}
}

/*****************************************************************************
	Function : dp_pulse_dial_cmd
*****************************************************************************/
void dp_pulse_dial_cmd ( byte digit )
{
	byte maketime, breaktime ;

	maketime = G(S).ModemOptions.PulseTimeMake ;	// make time
	breaktime = G(S).ModemOptions.PulseTimeBreak ;	// break time

    if ( G(S).ModemOptions.PulseDial20pps & 0x40 )        // bit 6 set to 1
    {
		maketime = (byte) ((maketime / 2) + 1);	// make time
		breaktime = (byte) (50 - maketime);	// break time
    }

	dp_write_dsp_ram (0x19, (word) maketime ) ;	// make time
	dp_write_dsp_ram (0x1a, (word) breaktime ) ;	// break time

	if ( ( G(S).ModemOptions.CountryId == FRANCE )
		|| ( G(S).ModemOptions.CountryId == ITALY ) 
		|| ( G(S).ModemOptions.CountryId == AUSTRIA ) )
		dp_write_dsp_ram (0x1b, 900 ) ;			// interdigit delay 900 ms 
	else
		dp_write_dsp_ram (0x1b, 755 ) ;			// interdigit delay 755 ms 

    if( G( dp_daa_is_perseus ))
    {
	dp_modem_command_long(GOTO_CMD,PERSEUS_BASE,PERSEUS_PULSE_DIAL,digit,0); // use perseus pulse dial driver
    }
    else
    {
	dp_modem_command ( PULSE_DIALING, digit, 0 ) ;
    }
}

/*****************************************************************************
	Function : dp_set_lb_filter( void )
*****************************************************************************/
void dp_set_lb_filter( void )
{
#ifdef HOMOL
	byte i, index ;

	if (G(dp_threshold) < 35 )
		dp_write_dsp_ram (IIR1_THRESHOLD_ADDR, (word)(G(dp_threshold) + 2) ) ;
	else
		dp_write_dsp_ram (IIR1_THRESHOLD_ADDR, (word)(G(dp_threshold) + 4) ) ;

	switch ( G(S).ModemOptions.FilterIndex )
	{
		case 0 : 		// CPF4 340 - 560 Hz BPF
			index = 0;
			break ;
		case 2 : 		// CPF2 363-502 Hz BPF
			index = 32;
			break ;
		case 3 :		// CPF3 276-504 Hz BPF
			index = 48;
			break ;
		case 4 :		// CPF4 415-460 Hz BPF
			index = 64;
			break ;
		case 5 :		// CPF5 310-640 Hz BPF
			index = 80;
			break ;
		case 6 :		// CPF5 370-530 Hz BPF
			index = 96;
			break ;
		case 1 :		// CPF1 310-485 Hz BPF
		default:
			index = 16;
			break ;
	}

#ifdef DC0
	if ( prnC ) // cell call
		index = 112 ;
#endif

	for(i=0; i < 16; i++)
		dp_write_dsp_ram ((word)(IIR1_K_ADDR + i), iircoef[index + i]) ;	
#else
	dp_write_dsp_ram (IIR1_THRESHOLD_ADDR, (word)G(S).ModemOptions.CallProgressThreshold) ;

	// 310-640 Hz BPF
	dp_write_dsp_block (filter_tab, sizeof(filter_tab)/(2*sizeof(word))) ;
#endif
}

// coefficients for dp_detect_tones_cmd (below)
static const word dp_dt_coef_tab[] =
{
	F941C,	// ram1c-bong tone1 941 Hz
	F1477C,	// ram1d-bong tone2 1477 Hz
	F350C,	// ram1e-bong tone3 350 Hz
	F440C, 	// ram1f-bong tone4 440 Hz
	F1650C,	// ram20-answer tone 1650 Hz

	F2060C,	// ram21-answer tone 2060 Hz
	F2130C,	// ram22-answer tone 2130 Hz
	F2100C,	// ram23-answer tone 2100 Hz
	F2225C,	// ram24-answer tone 2225 Hz
	F2250C 	// ram25-answer tone 2250 Hz
};

/*****************************************************************************
	Function : dp_detect_tones_cmd

	Set up DSP to detect tones:  Answer tone, bong tone
*****************************************************************************/
void dp_detect_tones_cmd ( void )
{
	dp_set_lb_filter();

	/* set threshold */
	dp_write_dsp_ram (0x26, (word)G(S).ModemOptions.ToneThreshold);

	// Load filter coefficients into DSP
	dp_write_dsp_array(0x1c,
					   dp_dt_coef_tab,
					   sizeof(dp_dt_coef_tab)/sizeof(word));

#if defined (V8BIS) || defined (V92)
	if ( G(S).ModemOptions.V42 != V42_GMUX ) 
	{
		x_debug_msg ( "dpcall - setup to detect v8bis init. dual tones" );
		dp_write_dsp_ram (0xFC0, F_1375_C) ;  // v8bis dual tone 1375 hz
		dp_write_dsp_ram (0xFC1, F_2002_C) ;  // v8bis dual tone 2002 hz
		dp_modem_command ( DETECT_TONES, 12, 0 ) ;
	}
	else
#endif	//V8BIS || V92
	{
		dp_modem_command ( DETECT_TONES, 10, 0 ) ;
	}
	G(dp_dial_tone_timer) =
	G(dp_quiet_answer_timer) =
	G(dp_busy_tone_timer) = x_current_time() ;

	G(dp_busy_state) = DP_ENERGY_INIT ;
	G(dp_tone_state) = DP_ENERGY_INIT ;
	G(peak_energy) = 0 ;
	G(peak_busy_energy) = 0 ;
}

/*****************************************************************************
	Function : dp_dial_tone_detected
*****************************************************************************/
byte dp_dial_tone_detected ( void )
{
	byte transition = FALSE ;
	word total_energy, iir1_energy ;
	word hole ;

	total_energy = dp_read_dsp_ram ( TOTAL_ENERGY_ADDR ) ;
	iir1_energy = dp_read_dsp_ram ( IIR1_ENERGY_ADDR ) ;

	switch ( G(dp_tone_state) )
	{
		case DP_ENERGY_INIT :
			if ( dp_read_dsp_ram ( 0x3a ) & 0x1000 )
			{
				G(dp_tone_on_time) = 0 ;
				G(dp_tone_off_time) = 0 ;
				G(dp_dialtone_cycles) = 0 ;
				G(dp_tone_timer) = x_current_time () ;
				G(dp_tone_state) = DP_ENERGY_ON ;
			}
			G(dp_dial_tone_timer) = x_current_time () ;
			break ;

		case DP_ENERGY_ON :
			if ( ( !( dp_read_dsp_ram ( 0x3a ) & 0x1000 ) )
				|| ( iir1_energy < ( G(peak_energy) >> 1 ) ) )
			{
				G(dp_tone_on_time) = x_elapsed_time(G(dp_tone_timer)) ;
				G(dp_tone_state) = DP_ENERGY_OFF ;
				transition = TRUE ;
			}
			if (G(S).ModemOptions.CountryId != ITALY )
			{	// following is code required to avoid false dialtone 
				// detection with strong out of band tones or noise.
				if ( ( iir1_energy > ( G(peak_energy) >> 2 ) ) 
					&& ( ( total_energy / (iir1_energy+1) ) > 5 ) )
				{
					G(dp_dial_tone_timer) = x_current_time() ;
					G(peak_energy) = iir1_energy ;
				}
			}
			if ( iir1_energy > G(peak_energy) )
				G(peak_energy) = iir1_energy ;
			break ;

		case DP_ENERGY_OFF :
			if ( dp_read_dsp_ram ( 0x3a ) & 0x1000 )
			{
				if ( iir1_energy > ( G(peak_energy) >> 1 ) )
				{
					G(dp_tone_off_time) = x_elapsed_time(G(dp_tone_timer)) ;
					G(dp_tone_state) = DP_ENERGY_ON ;
					G(peak_energy) =  0 ;
					transition = TRUE ;
				}
					// reset peak to avoid locking with dialtone
					// with large initial peak and dialtone holes.
				else if ( ( G(S).ModemOptions.CountryId != NETHERLANDS )
						&& ( G(S).ModemOptions.CountryId != ITALY )  
				 		&& ( x_elapsed_time(G(dp_tone_timer)) > MS500 ) )
					G(peak_energy) = iir1_energy ;
			}
			else 
			{
				hole = x_elapsed_time(G(dp_tone_timer))  ;
				if ( ( ( G(S).ModemOptions.CountryId != ITALY )
					&& ( hole > (word)G(S).ModemOptions.DialToneHole ) )
					|| ( hole > 1250 ) )
					G(dp_dial_tone_timer) = x_current_time() ;
			}
			break ;
	}

	if( transition == TRUE )
	{
		G(dp_tone_timer) = x_current_time () ;
		if ( G(dp_tone_off_time) > (word)G(S).ModemOptions.DialToneHole )
		{
			if (G(S).ModemOptions.CountryId == ITALY )
			{
				if (((G(dp_tone_off_time) > 210) && (G(dp_tone_off_time) < 830))
				|| (G(dp_tone_off_time) < 180) || (G(dp_tone_off_time) > 1155)
				|| ((G(dp_tone_on_time) > 230) && (G(dp_tone_on_time) < 530))
				|| (G(dp_tone_on_time) < 190) || (G(dp_tone_on_time) > 680) )
				{
					G(dp_dial_tone_timer) = x_current_time() ;
				}
				if ( ((G(dp_tone_off_time) > 180) && (G(dp_tone_off_time) < 220))
				     || (G(dp_tone_on_time) > 180) && (G(dp_tone_on_time) < 220) )
					G(dp_dialtone_cycles)++ ;
			}
			else
			{
				G(dp_dial_tone_timer) = x_current_time() ;
			}
		}
	}
	if ( x_elapsed_time(G(dp_dial_tone_timer)) >= 
		 (word)( 100 * G(S).ModemOptions.DialToneValidTime ) )
	{
		if ( ( dp_read_dsp_ram ( 0x3a ) & 0x1000 )
			 && (iir1_energy > (word)(10 * G(S).ModemOptions.DialToneLevel)))
		{
			if ( (G(S).ModemOptions.CountryId == ITALY ) &&
				 ( G(dp_dialtone_cycles) > 2 ) )
			{
#ifdef CS_DTMF_DIALOUT
				return TRUE;
#else
				return FALSE;
#endif
			}
				return TRUE;
		}
	}
#ifdef CS_DTMF_DIALOUT
 	return TRUE;
#else
	return FALSE;
#endif
}

/*****************************************************************************
	Function : dp_fax_dial_init
*****************************************************************************/

#if defined CLASS2_FAX && defined CS_MODEM
void dp_fax_dial_init (void)
{
	G(dp_busy_cycles) = 0 ;
	G(dp_answer_state) = DP_ENERGY_INIT ;
	G(dp_max_pause) = 0 ;
	G(dp_continous_busy_timer) = x_current_time () ;
}
#endif

/*****************************************************************************
	Function : dp_answer_tone_detected
*****************************************************************************/
byte dp_answer_tone_detected ( void )
{
	switch ( G(dp_answer_state) )
	{
	case DP_ENERGY_INIT :
		if ( dp_read_dsp_ram ( 0x28 ) & ANSWER_TONES )
		{
			G(dp_answer_on_timer) = x_current_time () ;
			G(dp_answer_off_timer) = x_current_time () ;
			G(dp_answer_state) = DP_ENERGY_ON ;
		}
		break ;
	case DP_ENERGY_ON :
		if ( dp_read_dsp_ram ( 0x28 ) & ANSWER_TONES )
		{
#ifdef	V92
			if ( ( G(S).ModemOptions.VpcmOption )	//s109 for V90,V92
				&& ( G(S).ModemOptions.Rate56K != 0 ) )		//s38 for 56k
			{
				if ( x_elapsed_time(G(dp_answer_on_timer)) >= 200 )
					return ( TRUE ) ;
			}
			else
#endif	//V92
			{
			if (
#ifdef	V8BIS
				( ( G(S).ModemOptions.V8bis == V8BIS_DTE_CONTROL )
				  && ( x_elapsed_time(G(dp_answer_on_timer)) >= 100 ) )
				||
#endif	//V8BIS
				( x_elapsed_time(G(dp_answer_on_timer)) >=
				  (10 * (word)G(S).ModemOptions.AnsToneValidTime) ) )
				return ( TRUE ) ;
			}
		}
		else
		{
			G(dp_answer_off_timer) = x_current_time () ;
			G(dp_answer_state) = DP_ENERGY_OFF ;
		}
		break ;
	case DP_ENERGY_OFF :
		/*
		 * look for answer tone, if the off "hole"<=MS50, ignore
		 */
		if ( dp_read_dsp_ram ( 0x28 ) & ANSWER_TONES )
		{
			if ( x_elapsed_time(G(dp_answer_off_timer)) > MS50 )
				G(dp_answer_on_timer) = x_current_time () ;
			G(dp_answer_state) = DP_ENERGY_ON ;
		}
		break ;
	}
	return ( FALSE ) ;
}


/*****************************************************************************
	Function : dp_busy_tone_detected

	Check for busy tone.  return TRUE iff busy tone is detected.
*****************************************************************************/
byte dp_busy_tone_detected ( void )
{
	byte transition = FALSE ;
	word total_energy, iir1_energy ;

	total_energy = dp_read_dsp_ram ( TOTAL_ENERGY_ADDR ) ;
	iir1_energy = dp_read_dsp_ram ( IIR1_ENERGY_ADDR ) ;

	switch ( G(dp_busy_state) )
	{
	case DP_ENERGY_INIT :
		if (x_elapsed_time(G(dp_busy_tone_timer)) > 3 )
		{
			if ( ( dp_read_dsp_ram ( 0x3a ) & 0x1000) )
			{
				G(dp_busy_state) = DP_ENERGY_ON ;
				G(dp_busy_on_cadence) = 0 ;		/* set on duration to 0 */
				G(dp_busy_off_cadence) = 1 ;		/* set off duration to 1 */
			}
			else
			{
				G(dp_busy_state) = DP_ENERGY_OFF ;
				G(dp_busy_on_cadence) = 1 ;		/* set on duration to 1 */
				G(dp_busy_off_cadence) = 0 ;		/* set off duration to 0 */
			}
		}
		break ;

	case DP_ENERGY_ON :
		if ( ( ( !( dp_read_dsp_ram ( 0x3a ) & 0x1000) )
			   || ( iir1_energy < ( G(peak_busy_energy) >> 1 ) ) )
			 && (x_elapsed_time(G(dp_busy_tone_timer)) > MS30) ) //ignore holes
		{
			G(dp_busy_on_cadence) = x_elapsed_time(G(dp_busy_tone_timer)) ;
			G(dp_busy_state) = DP_ENERGY_OFF ;
			transition = TRUE ;
		}
		else
		{
			if ( (G(x_modem_mode) != MODEM_VOICE ) 
				 && (G(S).ModemOptions.DataCallingTone == 1)    
				 && ( G(dp_calling_tone_disable) == FALSE)  
				 && ( x_elapsed_time (G(dp_timer1)) >= 1800 ) )
			{
				G(dp_busy_on_cadence) = x_elapsed_time(G(dp_busy_tone_timer)) ;
				transition = TRUE ;
			}
			if ( total_energy > (iir1_energy + (iir1_energy << 1)) )
				G(dp_continous_busy_timer) = x_current_time () ;
		}
		break ;

	case DP_ENERGY_OFF :
		if ( ( dp_read_dsp_ram ( 0x3a ) & 0x1000) 
			 && ( iir1_energy > ( G(peak_busy_energy) >> 1 ) ) )
		{
			G(dp_busy_off_cadence) = x_elapsed_time(G(dp_busy_tone_timer));
			G(dp_busy_state) = DP_ENERGY_ON ;
			transition = TRUE ;
		}
		else G(dp_continous_busy_timer) = x_current_time () ;
		break ;
	}

	// reset if no transition in past 900 msec, i.e, cadance > 900 msec

	if ( x_elapsed_time(G(dp_busy_tone_timer)) > 900 )
	{
		G(dp_busy_cycles) = 0 ;
		G(dp_busy_on_cadence) = 0 ;		/* set on duration to 0 */
		G(dp_busy_off_cadence) = 0 ;		/* set off duration to 0 */

		// Need to reset G(peak_busy_energy) to prevent any incoming
		// signal between dialing and BUSY from affecting qualification
		// of a subsequent valid BUSY.
		G(peak_busy_energy) = 0 ;
	}
	if ( transition == TRUE )
	{
		G(dp_busy_tone_timer) = x_current_time () ;

		if ( G(S).ModemOptions.CountryId == NA 
			 || G(S).ModemOptions.CountryId == CANADA)
		{
			if (((G(dp_busy_on_cadence) >= 195)&&(G(dp_busy_on_cadence) <= 305)
				  &&(G(dp_busy_off_cadence) >= 195)&&(G(dp_busy_off_cadence) <= 305))
				  ||((G(dp_busy_on_cadence) >= 420)&&(G(dp_busy_on_cadence) <= 580)
		   		  &&(G(dp_busy_off_cadence) >= 420)&&(G(dp_busy_off_cadence) <= 580)))
			{
				G(dp_busy_cycles)++ ;
				G(dp_busy_on_cadence) = 0 ;
				G(dp_busy_off_cadence) = 0 ;
			}
		}
		else
		{
			if ( G(S).ModemOptions.MaxBusyCadenceOn )	//country specific detection
			{
				if ((G(dp_busy_on_cadence) >=
					 (word)(10*G(S).ModemOptions.MinBusyCadenceOn))
					&& (G(dp_busy_on_cadence) <=
						(word)(10*G(S).ModemOptions.MaxBusyCadenceOn))
					&& (G(dp_busy_off_cadence) >=
						(word)(10*G(S).ModemOptions.MinBusyCadenceOff))
					&& (G(dp_busy_off_cadence) <=
						(word)(10*G(S).ModemOptions.MaxBusyCadenceOff)))
					{
						G(dp_busy_cycles)++ ;
						G(dp_busy_on_cadence) = 0 ;	/* set on duration to 0 */
						G(dp_busy_off_cadence) = 0 ;	/* set off duration to 0 */
					}
			}
			else if ((G(dp_busy_on_cadence) >= 100) && (G(dp_busy_on_cadence) <= 850))
			{ /* standard busy detection algorithm */
				if ( ((G(dp_busy_on_cadence) <= 150)
					&& (G(dp_busy_on_cadence) + G(dp_busy_off_cadence) > 250))
					|| ((G(dp_busy_on_cadence) >= 150)
					&& (G(dp_busy_on_cadence) <= (G(dp_busy_off_cadence) +
					    (G(dp_busy_off_cadence) >> 1) + 75))) )
					{
						G(dp_busy_cycles)++ ;
						G(dp_busy_on_cadence) = 0 ;	/* set on duration to 0 */
						G(dp_busy_off_cadence) = 0 ;	/* set off duration to 0 */
					}
			}
		}

	}

	if ( G(dp_busy_cycles) >= G(S).ModemOptions.BusyPassCount )
	{
		x_debug_msg("DP - busy detected");
		G(dp_busy_cycles) = 0;
		G(x_dial_residual) = MR_BUSY_SIGNAL ;
#if defined(CS_MODEM)
		disconnect_reason = BUSY;
#endif
		return TRUE;
	}

	if ( iir1_energy > G(peak_busy_energy) )
		G(peak_busy_energy) = iir1_energy ;

	return FALSE;
}

#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
/*****************************************************************************
	Function : dp_set_filters
				Set filters for ringback detection in speakerphone
*****************************************************************************/
void dp_set_filters ( void )
{
	dp_write_dsp_ram (IIR1_THRESHOLD_ADDR, 40) ;	/*iir1 threshold*/
	dp_write_dsp_ram (IIR2_THRESHOLD_ADDR, 40) ;	/*iir2 threshold*/
	dp_write_dsp_array ( IIR1_K_ADDR, (word *)dp_voice_f8khz, 32 ) ;
	dp_write_dsp_ram ( 0x86, 0x20 ) ;// enable IIRs
}
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif

/*****************************************************************************
	Function : dp_ringback_init
*****************************************************************************/
void dp_ringback_init ( void )
{
	G(dp_no_ringback_timer) = x_current_time () ;
	G(dp_ringback_on_timer) = x_current_time () ;
	G(dp_ringback_off_timer) = x_current_time () ;
	G(dp_ringback_state) = DP_ENERGY_OFF ;
	G(dp_ringback_on_cadence) = 0 ;
	G(dp_ringback_off_cadence) = 0 ;
	G(dp_ringback_cycles) = 0 ;
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
	if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE ) 
		dp_set_filters ( ) ;
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif
}

/*****************************************************************************
	Function : dp_ringback_detected
*****************************************************************************/
byte dp_ringback_detected ( void )
{
	byte transition = FALSE ;
	word tone_on, tone_off ;

#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
	if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE ) 
	{
		word iir1energy, iir2energy;

		iir1energy = dp_read_dsp_ram ( IIR1_ENERGY_ADDR ) ;
		iir2energy = dp_read_dsp_ram ( IIR2_ENERGY_ADDR ) ;
		tone_on = (word) (( iir1energy < 100 ) && ( iir2energy > 500 ));
		tone_off =  (word) (( iir1energy < 50 ) && ( iir2energy < 50 ));
	}
	else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif
	{
		tone_on = (word) (( dp_read_dsp_ram ( 0x3a ) & 0x1000));
		tone_off = (word) (!tone_on);
	}

	switch ( G(dp_ringback_state) )
	{
		case DP_ENERGY_ON :
			if ( tone_off )
			{
				G(dp_ringback_on_cadence) = x_elapsed_time(G(dp_ringback_on_timer)) ;
				G(dp_ringback_state) = DP_ENERGY_OFF ;
				transition = TRUE ;
				G(dp_ringback_on_timer) = x_current_time () ;
			}
			if ( x_elapsed_time(G(dp_ringback_on_timer)) > MS200 ) 
				G(dp_ringback_off_timer) = x_current_time () ;
			break ;

		case DP_ENERGY_OFF :
			if ( tone_on )
			{
				G(dp_ringback_off_cadence) = x_elapsed_time(G(dp_ringback_off_timer));
				if ( G(dp_ringback_off_cadence) > MS500 )
					G(dp_ringback_on_timer) = x_current_time () ;
				G(dp_ringback_state) = DP_ENERGY_ON ;
				transition = TRUE ;
				G(dp_ringback_off_timer) = x_current_time () ;
			}
			break ;
	}

	if( transition == TRUE )
	{
		/* ringback tones are ON for > 800msec and OFF for > 1000msec */
		if (((G(dp_ringback_on_cadence) > MS800)
			&& (G(dp_ringback_on_cadence) < SECOND3 ))
			&& (G(dp_ringback_off_cadence) > SECOND1))
			G(dp_ringback_cycles)++ ;
	}

	if (( G(dp_ringback_cycles) > 0 ) &&
		(x_elapsed_time(G(dp_ringback_off_timer)) >
			(100*(word)G(S).ModemOptions.RingbackGoAway + 150)))
	{
		return( TRUE ) ;
	}
	else if (( G(dp_ringback_cycles) == 0 ) &&
		(x_elapsed_time(G(dp_no_ringback_timer)) >
			(1000*(word)G(S).ModemOptions.RingbackNeverCame)))
	{
		return( TRUE ) ;
	}
	return( FALSE ) ;
}

/*****************************************************************************
	Function : dp_quiet_answer_detected
*****************************************************************************/
byte dp_quiet_answer_detected ( void )
{
	/* quiet answer - no tones for 5 seconds */
	if ( dp_read_dsp_ram ( 0x27 ) != 0 )
	{
		G(dp_quiet_answer_timer) = x_current_time() ;
		return ( FALSE ) ;
	}

	if ( x_elapsed_time(G(dp_quiet_answer_timer)) >= SECOND5 )
		return ( TRUE ) ;
	return ( FALSE ) ;
}

/*****************************************************************************
	Function : dp_calling_tone_cmd  (atv 2/25/94)
*****************************************************************************/
void dp_calling_tone_cmd ( void )
{
#ifdef V80
	if ( ( G(S).ModemOptions.V8_Orig == DCE_V8_ORIG_ENABLE ) ||
		 ( G(S).ModemOptions.DsvdVoiceCallFirst == TRUE ) )
	{
#ifdef V8BIS
		if ( G(S).ModemOptions.V42 == V42_GMUX )
		{
			return ;
		}
		else
#endif	//V8BIS
		{
 #if !defined(CS_MODEM)
			v8_ci_orig () ; // do v.8 ci calling tone for dsvd & video
 #endif
			return ;
		}
	}
#endif

	/* ram05 - sin(k), ram06 - cos(k), k=2PI*f/7200, f=1300Hz */
	if ( (G(ETC_mode) & ETC_MODE_MASK) == ETC_MODE_CELL_MASK_BIT )
	{
		x_debug_msg ("dp - set ETC tone") ;
		dp_write_dsp_ram (0x5, F1500S) ;
		dp_write_dsp_ram (0x6, F1500C) ;
	}
	else
	{
		dp_write_dsp_ram (0x5, F1300S) ;
		dp_write_dsp_ram (0x6, F1300C) ;
	}

	dp_write_dsp_ram (0x17, 0x262) ;	/* reg17 - tone duration=0.6sec*/
	dp_write_dsp_ram (0x11, (word)G(S).ModemOptions.TxLevel) ; /* tone power */

	dp_modem_command ( GENERATE_TONES, 1, 0 ) ;
}

#ifdef VOICE
/*****************************************************************************
	Function : dp_spkpn_onhook (atv 11/11/94, work around)
*****************************************************************************/
void dp_spkpn_onhook ( void )
{
	// change the off-hook relay state
	// read modify write command - change dsp core register
	dp_modem_command_long ( 0x03, 0x19, 0xEF,0x00, 0 ) ;
}

/*****************************************************************************
	Function : dp_spkpn_offhook (atv 11/11/94, work around)
*****************************************************************************/
void dp_spkpn_offhook ( void )
{
	// change the off-hook relay state
	// read modify write command - change dsp core register
	dp_modem_command_long ( 0x03, 0x19, 0xFF,0x10, 0 ) ;
}
#endif

#if !defined(CS_MODEM)
/*****************************************************************************
	Function : dp_stored_number 
			Get stored numbers, if any.
			Returns FALSE if requested stored number is empty, FALSE otherwise. 
*****************************************************************************/
byte dp_stored_number( byte *tmpstr )
{
	word index ;

	while(*tmpstr != 0)
	{
		if ( (*tmpstr == 'S') && (*(tmpstr+1) == '=') ) 
		{
	    	/* copy number into dial string */
			index = (word)(*(tmpstr + 2) - '0') ;
	    	load_number( index, (tmpstr + 1) ) ; 
			if ( *(tmpstr+1) == 0 )
				return ( FALSE ) ;
		}
		tmpstr++;
	}
	return ( TRUE ) ;
}
#endif //CS_MODEM

/*****************************************************************************
	Function : dp_test_dialstring (mah 03/22/2000)

	Returns TRUE if atleast one valid digit found 
	in the string, FALSE otherwise. 
*****************************************************************************/
byte dp_test_dialstring(byte *str)
{
	const byte *cp;
	static const byte valid_digits[] = "0123456789*#ABCDPT!;,@>^VW";

	while (*str != 0)
	{
		for (cp=valid_digits; *cp; cp++)
		{
			if (*str == *cp)
			{
				return TRUE;
			}
		}
		str++;
	}
	return FALSE; 
}

/********************************************************************************
Routine : convert_dtmf_digit
Description :
	Take a character and converts it to corresponding 'DTMF digit'
	that the DSP uses for its internal format.
	(optimized for Z80 - 3/22/2000 - mah)
*********************************************************************************/
byte convert_dtmf_digit ( byte *ptr, byte *dtmf_digit )
{
	register byte d = *ptr;

	switch (d)
	{
	case '*':
		d = 0x0a;
		break;
	case '#':
		d = 0x0b;
		break;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
		d = (byte) (d - 0x35);
		break;
	default:
		if ( ( d < '0' ) || ( d > '9' ) )
			return FALSE;
		break;
	}

	*dtmf_digit = (byte) (d & 0x0f);
	return TRUE;
}

/*****************************************************************************
	Function : dp_bong_tone_detected
*****************************************************************************/
byte dp_bong_tone_detected ( void )
{
	if ( dp_read_dsp_ram ( 0x28 ) & BONG_TONES1 )
		G(dp_bong_tone1_on_time) =  x_elapsed_time ( G(dp_dial_timer) ) ;
	else
	if ( dp_read_dsp_ram ( 0x28 ) & BONG_TONES2 ) 
	{
		if ( (G(dp_bong_tone1_on_time) >= MS50) && 
		   (( x_elapsed_time(G(dp_dial_timer)) - G(dp_bong_tone1_on_time)) >= MS100) )
			return( TRUE ) ;
	}
	return( FALSE ) ;
}

#ifdef DC0
/****************************************************************
Routine : dp_dial_modify_check ()
Description : 
*****************************************************************/
byte dp_dial_modify_check ( byte bNumber )
{
	switch( bNumber )
	{
		case ',' :
			// delay longer for the 1st ',' if dial to a Motorola phone
			if ( prnC == CELL_MOTOROLA )
				G(dp_dial_pause) = 3000 *
					(word)G(S).ModemOptions.DialPauseTime;
			else // default delay
				G(dp_dial_pause) = 1000 *
					(word)G(S).ModemOptions.DialPauseTime;
			G(dp_dial_state) = DP_DIAL_PAUSE ;
			break ;
		case ';' :
			if ( ( G(dp_dialing_status) != DP_VOICE_DIAL )
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
				&& (G(x_modem_mode) != MODEM_SPEAKER_PHONE )
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
				)
			{
				cell_send () ;
				G(x_modem_state) = MS_OFFHOOK ;
				x_send_mail ( DP_AT_DIALDONE, AT_TASK, NULL, 0 );
				return TRUE ;
			}
			break ;

		case '$' :
			G(dp_bong_tone1_on_time) = 0  ;
			dp_detect_tones_cmd () ;
			G(dp_dial_state) = DP_BONG ;
			break ;

		default :
			return FALSE ;
	}
	cell_send () ;
	return TRUE ;
}
#endif

/****************************************************************
Routine : dp_dial()
Description : dialing state machine.
		Called from dp_periodic_task() when G(dp_state)==DP_DIAL.

		The first time this is called, G(dp_dial_state)==DP_DIAL_START.

Return Values:
		DIAL_RETURN_OK: - continue dialing
		DIAL_RETURN_IDLE - after ';', continue with call
				in command mode.
		DIAL_RETURN_NULL - continue on to call progress
		DIAL_RETURN_FAILURE - dialing has failed, abort the call
*****************************************************************/
DIAL_RETURN  dp_dial ( void )
{
	byte dial_digit ;

	switch ( G(dp_dial_state) )
	{
		case DP_DIAL_START :
			G(dp_busy_cycles) = 0 ;
			G(dp_answer_state) = DP_ENERGY_INIT ;
			G(dp_max_pause) = 0 ;
			G(dp_continous_busy_timer) = x_current_time () ;

#if !defined(CS_MODEM)
			if ( !dp_stored_number( G(dp_dial_string) ) )
			{
				//Invalid - requested stored number empty
				G(x_dial_residual) = MR_OK ;
				return (DIAL_RETURN_FAILURE) ;
			}
#endif

			G(dp_dial_ptr) = G(dp_dial_string) ;
			if ( G(S).ModemOptions.RestrictDial == 1 ) 
			{
				if ( !dp_test_dialstring ( G(dp_dial_string) ) )
					G(dp_dial_string)[0] = 0 ;
				G(dp_dial_ptr) = G(dp_dial_string) ;

    				// Remove leading commas if any
				while ( (( *G(dp_dial_ptr) == 'T' ) || ( *G(dp_dial_ptr) == 'P' )
					 || ( *G(dp_dial_ptr) == ',' ))
					&& (*(G(dp_dial_ptr)+1) == ',') )
				{
					*(G(dp_dial_ptr) + 1) = *G(dp_dial_ptr) ;
					G(dp_dial_ptr)++ ;
				}
				if( *G(dp_dial_ptr) == ',' )
					G(dp_dial_ptr)++ ;
			}

			// Following code required to remember Tone/Pulse for next call
			// when dial aborted before dailtone detection
			if ( *G(dp_dial_ptr) == 'T' )
				G(S).ModemOptions.DialMode = 1 ; //Tone

			if ( (*G(dp_dial_ptr) == 'P') && (G(S).ModemOptions.PulseDialPermited == 0) )	// allowed
				G(S).ModemOptions.DialMode = 0 ; // Pulse

#ifdef HOMOL
			if ( ( G(dp_dialing_status) == DP_INITIAL_DIAL )
					&& (( G(x_modem_mode) == MODEM_DATA ) 	 //and in data
					    || ( G(x_modem_mode) == MODEM_FAX )) )   //or fax mode
			{
				// check if blacklisted
				if (G(S).ModemOptions.BlackListFlag
					&& dp_check_list(G(dp_dial_string)))
				{
					return DIAL_RETURN_FAILURE;
				}

				// check if delay between attempts is at least 5 sec, except NA
				// and if the call is made within 500 ms just after wakep to
				//ignore this delay for the 1st call after wakeup.
				if ( ( G(S).ModemOptions.CountryId != NA )  
						&& ( G(dp_first_call) == FALSE )
				    	&& ( x_elapsed_time(G(dp_timer1)) < SECOND5 ) )
					return ( DIAL_RETURN_OK ) ;
			}
#endif
			G(dp_dial_timer) = x_current_time () ;
#ifdef DC0		// if direct connect
			if ( cell_originate () == TRUE )	// check if phone is present
				G(dp_dial_state) = DP_DIAL_DIGIT ;
			else
#endif

#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			// in speaker phone mode we are already offhook
			if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
			{
				// Wait before dialing first digit, treat as blind dialing
				if ( ( G(dp_dialing_status) != DP_INITIAL_DIAL )
						|| ( *G(dp_dial_ptr) == 0 ) )	//ATD, no digits
				{
					G(dp_dialing_status) = DP_SUBSEQUENT_DIAL ;
					G(dp_dial_state) = DP_DIAL_DIGIT ;
				}
				else
				{
					if (x_elapsed_time ( G(dp_timer1) ) >
						(word)( 100 * G(S).ModemOptions.DialToneValidTime ) )
					{
						G(dp_dial_state) = DP_DIAL_DIGIT ;

						G(dp_dialing_status) = DP_SUBSEQUENT_DIAL ;
						G(dp_timer1) = x_current_time () ; 	
					}
				}
			}
			else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif
			{
				if ( G(dp_dialing_status) == DP_INITIAL_DIAL )
				{
					dp_offhook_cmd () ;
					G(dp_dialing_status) = DP_SUBSEQUENT_DIAL ;
					if ( G(S).ModemOptions.LoopSenseWaitTime != 0 )
					{
						G(dp_timer1) = x_current_time () ; 	
						G(dp_dial_state) = DP_LOOPSENSE ;
					}
					else
						G(dp_dial_state) = DP_DIAL_OFFHOOK ;
				}
				else if ( G(dp_dialing_status) == DP_V8_DIAL )
				{
					dp_offhook_cmd () ;
					G(dp_dialing_status) = DP_SUBSEQUENT_DIAL ;
					G(dp_dial_state) = DP_DIAL_DIGIT ;
				}
				else
				{
#ifdef	V8BIS
					if ( G(S).ModemOptions.V8bis == V8BIS_DTE_CONTROL )
						dp_offhook_cmd () ;
#endif	//V8BIS
					// following code required when switching from
					// speakerphone mode to data/fax mode 
					if ( G(x_modem_mode) != MODEM_VOICE )
					{
						if ( G(S).ModemOptions.SpeakerControl )
							x_output ( IO_SPEAKER_ON ) ;
						x_output ( IO_CALLER_ID_OFF ) ;
						x_output ( IO_DV_RLY_ON ) ;
					}

					G(dp_dial_state) = DP_DIAL_DIGIT ;
				}
			}
			G(dp_dial_timer) = x_current_time () ;
			/* turn speaker off while dialing */
			if ( G(S).ModemOptions.SpeakerControl == 3 )
				x_output ( IO_SPEAKER_OFF ) ;
			break ;

		case DP_DIAL_OFFHOOK :
			// wait for off-hook relay to settle down && turn off
			// shunt relay, if activated
			if ( x_elapsed_time ( G(dp_dial_timer) ) >= MS55 )
			{
				if ( ( *G(dp_dial_ptr) == 0 ) || ( *G(dp_dial_ptr) == ';') )
				{
					if ( *G(dp_dial_ptr) == ';' )
						G(dp_dialing_status) = DP_INITIAL_DIAL ; // detect dialtone for following ATDxx
					G(dp_dial_state) = DP_DIAL_DIGIT ; // do not detect dialtone 
				}
				else
				{
					dp_detect_tones_cmd () ;
					G(dp_dial_state) = DP_DIALTONE ;
					G(dp_dial_timer) = x_current_time () ;
				}
			}
			break ;

		case DP_LOOPSENSE:
		 	if ( !x_input(IO_OVERCURRENT_DET) )  // No over current 
			{
				if ( x_elapsed_time ( G(dp_dial_timer) ) >= MS60 )
				{
					G(dp_dial_timer) = x_current_time () ;
					if ( *G(dp_dial_ptr) == 0 )
						G(dp_dial_state) = DP_DIAL_DIGIT ;
					else
					{
						dp_detect_tones_cmd () ;
						G(dp_dial_state) = DP_DIALTONE ;
					}
				}
				if ( x_elapsed_time ( G(dp_timer1) ) >= MS10 ) // ignore holes
					G(dp_timer1) = x_current_time () ; 	
			}
			else // Over current
			{
				G(dp_dial_timer) = x_current_time () ;
				if ( x_elapsed_time ( G(dp_timer1) ) >=
							(10 * (word)G(S).ModemOptions.LoopSenseWaitTime) )
				{
		 			x_debug_msg("DP - Over current detected");
					G(x_dial_residual) = MR_NO_DIAL_TONE ;
#if defined(CS_MODEM)
					disconnect_reason = NODIALTONE;	//jc-3/17/98
#endif
					return (DIAL_RETURN_FAILURE) ;
				}
			}
			break ;

		case DP_DIALTONE :
			// The call has begun and we're off hook, normally we will
			// wait for dial tone.
			if ( ! ( G(S).ModemOptions.DialToneDetect )
					&& ( G(S).ModemOptions.BlindDialPermited != 0 ) )
			{
				// We're doing blind dialing, wait as required
				// then go on to dial the number.
				if ( x_elapsed_time ( G(dp_dial_timer) ) >
				 	( 1000 * (word)G(S).ModemOptions.BlindDialPause ) )
				{
					if ( ( G(S).ModemOptions.BlindDialPermited == 2 ) //spk on
						&& (( G(x_modem_mode) == MODEM_DATA ) 	 //and in data
						 || ( G(x_modem_mode) == MODEM_FAX )) ) //or fax mode
						 x_output( IO_SPEAKER_ON ) ;

					G(dp_timer) = x_current_time () ;
					G(dp_dial_state) = DP_DIAL_DIGIT ;
					x_debug_msg ( "DP - Dial Tone Detect Disabled" ) ;
				}
			}
			else if ( ( x_elapsed_time ( G(dp_dial_timer) ) >
				 	  ( 10 * (word)G(S).ModemOptions.DialToneDelay) )
					&& ( dp_dial_tone_detected () == TRUE ) )
			{
				x_debug_msg ( "DP - detected dial tone" ) ;
				G(dp_dial_state) = DP_DIAL_DIGIT ;
			}
			else if ( ( G(S).ModemOptions.BusyToneDetect ) &&
					  ( G(S).ModemOptions.DialBusyDetect ) && 
			          ( dp_busy_tone_detected () == TRUE ) )
			{
				// BUSY!
#ifdef  HOMOL
				if ( ( G(S).ModemOptions.BlackListFlag )
					 && ( G(x_modem_mode) != MODEM_SPEAKER_PHONE ))
					dp_update_blacklist( G(dp_dial_string), TROUBLE ) ;
#endif
				return(DIAL_RETURN_FAILURE) ;
			}
			else if ( ( x_elapsed_time ( G(dp_dial_timer) ) >= SECOND10 )
					|| ( ( G(S).ModemOptions.CountryId == AUSTRIA )
						&& ( x_elapsed_time ( G(dp_dial_timer) ) >= SECOND6 ) ) )
			{
				x_debug_msg ( "DP - no dial tone" ) ;
				G(x_dial_residual) = MR_NO_DIAL_TONE ;
#if defined(CS_MODEM)
				disconnect_reason = NODIALTONE;
#endif
#ifdef  HOMOL
				if ( ( G(S).ModemOptions.BlackListFlag )
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
				 	&& ( G(x_modem_mode) != MODEM_SPEAKER_PHONE )
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
					)
					dp_update_blacklist( G(dp_dial_string), TROUBLE ) ;
#endif
				return(DIAL_RETURN_FAILURE) ;
			}
			break ;

		case DP_WAIT_DIAL :
			// We got here with a 'W' in the dial string.
			// Wait for another dial tone before processing
			// the dial string.
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
			{
				if ( x_elapsed_time ( G(dp_dial_timer) ) >
					 (word)( 100 * G(S).ModemOptions.DialToneValidTime ) )
					G(dp_dial_state) = DP_DIAL_DIGIT ;
			}
			else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif
			{
				if ( ( G(S).ModemOptions.WaitDialTimeOut >= 
							G(S).ModemOptions.NoAnsTimeOut ) 
					&& ( dp_busy_tone_detected () == TRUE ) )
				{
					// BUSY!
#if defined(CS_MODEM)
					disconnect_reason = BUSY;
#ifdef IWF_DATA
					G(dp_state) = DP_IDLE;
					while (cs_ack_received() == FALSE)
						;
						cs_compose_cmd (MDM_STATE , 1, 7, 3);
#endif
#endif
					return(DIAL_RETURN_FAILURE) ;
				}
				else if ( dp_dial_tone_detected () == TRUE )
				{
					x_debug_msg ( "DP - detected dial tone" ) ;
					if ( G(S).ModemOptions.DialMode == 0 ) // pulse dial
					{
							x_output(IO_SHUNT_ON);
							x_debug_msg("Wait dial - Shunt relay turned on");
					}
#ifdef IWF_DATA
					if(cs_2nd_dialtone_detect)
					{
						cs_2nd_dialtone_detect = 0;
						while (cs_ack_received() == FALSE)
							;
							cs_compose_cmd (MDM_STATE , 1, 7, 9);
					}
#endif
					G(dp_dial_state) = DP_DIAL_DIGIT ;
				}
				else if ( x_elapsed_time ( G(dp_dial_timer) ) >=
				        ( 1000 * (word)G(S).ModemOptions.WaitDialTimeOut ) )
				{
					x_debug_msg ( "DP - no dial tone" ) ;
					G(x_dial_residual) = MR_NO_DIAL_TONE ;
#if defined(CS_MODEM)
					disconnect_reason = NODIALTONE;
#ifdef IWF_DATA
					if(cs_2nd_dialtone_detect)
					{
						cs_2nd_dialtone_detect = 0;
						x_debug_msg("DP - no 2nd dial tone detected");
					}
#endif
#endif
					return(DIAL_RETURN_FAILURE) ;
				}
			}
			break ;

		case DP_HOOKFLASH_ON :
			if ( x_elapsed_time ( G(dp_dial_timer) ) >
							10 * (word)G(S).ModemOptions.HookFlashTime )
			{
				x_debug_msg("DP - end hook flash pulse");
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
				if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
					dp_spkpn_offhook () ;
				else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif
					x_output( IO_OFF_HOOK ) ;
				G(dp_dial_state) = DP_HOOKFLASH_OFF ;
				x_output ( IO_SHUNT_ON ) ;
				G(dp_dial_timer) = x_current_time () ;

			}
			break ;

		case DP_HOOKFLASH_OFF :
			if ( ( x_elapsed_time ( G(dp_dial_timer) ) > 20 )
			 	&& ( x_elapsed_time ( G(dp_dial_timer) ) < 50 ) )
				x_output ( IO_SHUNT_OFF ) ;
			if ( x_elapsed_time ( G(dp_dial_timer) ) >
							10 * (word)G(S).ModemOptions.HookFlashTime )
			{
				x_debug_msg("DP - end hook flash");
				G(dp_dial_state) = DP_DIAL_DIGIT ;
			}
			break ;

		case DP_QUIET_ANSWER :
			// Got here with a '@' in the dial string.
			// Wait for 5 seconds of silence after
			// dialing the number.  If silence is not
			// detected, give 'NO ANSWER' back to user.
			if ( ( dp_busy_tone_detected () ) == TRUE )
			{
				// BUSY!!
#if defined(CS_MODEM)
				disconnect_reason = BUSY;
	#ifdef IWF_DATA
				G(dp_state) = DP_IDLE;
				while (cs_ack_received() == FALSE)
					;
					cs_compose_cmd (MDM_STATE , 1, 7, 3);
	#endif
#endif
				return(DIAL_RETURN_FAILURE) ;
			}
			else if ( ( dp_dial_tone_detected () == TRUE ) ||
			          ( dp_answer_tone_detected () == TRUE ) )
			{
				x_debug_msg ( "DP - tones detected while quiet answer" ) ;
				G(x_dial_residual) = MR_NO_ANSWER_TONE ;
				return(DIAL_RETURN_FAILURE) ;
			}
			else if ( ( dp_quiet_answer_detected () ) == TRUE )
			{
#ifdef IWF_DATA
				while (cs_ack_received() == FALSE)
				;
					cs_compose_cmd (MDM_STATE , 1, 7, 11);
#endif
				G(dp_dial_state) = DP_DIAL_DIGIT ;
				x_debug_msg ( "DP - quiet answer done" ) ;
			}
			else
			{
		 		if ( x_elapsed_long_time( G(dp_long_timer) ) >= 
							( 10 * (word)G(S).ModemOptions.NoAnsTimeOut ) )
				{
					G(x_dial_residual) = MR_NO_ANSWER_TONE ;
					return (DIAL_RETURN_FAILURE) ;
				}
			}
			break ;

		case DP_BONG :
			// Got here with a '$' in the dial string.
			// Wait for bong tone.
			if ( dp_busy_tone_detected () == TRUE ) 
			{
				// BUSY !!
#if defined(CS_MODEM)
				disconnect_reason = BUSY;
	#ifdef IWF_DATA
				G(dp_state) = DP_IDLE;
				while (cs_ack_received() == FALSE)
					;
					cs_compose_cmd (MDM_STATE , 1, 7, 3);
	#endif
#endif
				return(DIAL_RETURN_FAILURE) ;
			}
			else if ( dp_bong_tone_detected () == TRUE )
			{
				x_debug_msg ( "DP - detected bong tone" ) ;
				// Pause for a while before sending further digits.
				// If there was false bong detection while a network
				// greeting message being played this pause avoids
				// sending digits while message is being played.
#ifdef IWF_DATA
				while (cs_ack_received() == FALSE)
				;
					cs_compose_cmd (MDM_STATE , 1, 7, 8);
#endif
				G(dp_dial_pause) = SECOND1 ;
				G(dp_dial_state) = DP_DIAL_PAUSE ;
			}
			else if ( x_elapsed_time ( G(dp_dial_timer) ) >= SECOND50 ) 
			{
				x_debug_msg ( "DP - no bong tone" ) ;
				G(x_dial_residual) = MR_NO_DIAL_TONE ;
#if defined(CS_MODEM)
				disconnect_reason = NODIALTONE;
#endif
				return(DIAL_RETURN_FAILURE) ;
			}
			break ;

		case DP_DIAL_DIGIT :
			// Dial the digits of the dial string.
			if ( (G(dp_redial) == TRUE) && G(S).ModemOptions.EchoToDTE)
			{
				/* display the dial string */
				G(dp_redial) = FALSE ;
				x_send_at_io_crlf();
				x_send_at_io_data((byte *) "Dialing...");
				x_send_at_io_data(G(dp_dial_ptr));
			}
			G(dp_dial_timer) = x_current_time () ;
			switch ( *G(dp_dial_ptr) )
			{
				case 'T' :
					if ( ( *G(dp_dial_string) == 'T' ) 
						|| (!G(S).ModemOptions.PulseTonePermited ) )	// permited 
						G(S).ModemOptions.DialMode = 1 ;
					break ;

				case 'P' :
					if ( ( G(S).ModemOptions.PulseDialPermited == 0 )	// allowed 
						 && (( *G(dp_dial_string) == 'P' ) 
							|| (!G(S).ModemOptions.PulseTonePermited)) )// permited
					{
						G(S).ModemOptions.DialMode = 0 ;
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
						if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
						{
							// Following is a workaround for pulse dialing in
							// speakerphone mode.
							dp_save_aec_coef() ;	// save aec taps
							G(dp_dialing_status) = DP_VOICE_DIAL ;
							G(x_modem_mode) = MODEM_DATA ;
							x_output ( IO_SPEAKER_ON ) ;
						}
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif	//VOICE
#ifdef HOMOL
						x_output(IO_SHUNT_ON);
						if ( ( G(S).ModemOptions.CountryId == NETHERLANDS )
							|| ( G(S).ModemOptions.CountryId == AUSTRIA ) )
						{
							G(dp_dial_pause) = 250 ;// wait before 1st digit
							G(dp_dial_state) = DP_DIAL_PAUSE ;
						}
#endif
					}
					break ;

				case ',' :
#ifndef HOMOL
					G(dp_dial_pause) = (word) (1000 * G(S).ModemOptions.DialPauseTime);
#endif
#ifdef HOMOL
					if ( G(S).ModemOptions.MaxCommaPauseTime == 255 )
						G(dp_dial_pause) = (word) (1000 * G(S).ModemOptions.DialPauseTime);
					else if ( G(dp_max_pause) < 1000 * (word)G(S).ModemOptions.MaxCommaPauseTime )
					{
						G(dp_dial_pause) = (word) (1000 * G(S).ModemOptions.DialPauseTime);
						G(dp_max_pause) = (word) (G(dp_max_pause) + G(dp_dial_pause));
					}
					else G(dp_dial_pause) = 0 ;
#endif
					G(dp_dial_state) = DP_DIAL_PAUSE ;
					break ;

				case '!' :			// Hook flash.  Go on hook then
									// return to off-hook.
					if ( ( G(S).ModemOptions.HookFlashTime ) &&
						 ( ( G(S).ModemOptions.DialMode != 0 )  //not pulse dialing
			 			|| ( G(S).ModemOptions.CountryId == NA ) ) )
					{
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
						if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
							dp_spkpn_onhook () ;
						else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif
							x_output( IO_ON_HOOK ) ;
						G(dp_dial_state) = DP_HOOKFLASH_ON ;
						x_debug_msg("DP - start hook flash");
					}
					break ;

				case 'W' :			// Wait for dial tone.
#ifdef IWF_DATA
					cs_2nd_dialtone_detect = 1;
#endif
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
					if ( G(x_modem_mode) != MODEM_SPEAKER_PHONE )
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
					{
						dp_detect_tones_cmd () ;
						if ( G(S).ModemOptions.DialMode == 0 ) // pulse dial
							x_output(IO_SHUNT_OFF);
					}
					G(dp_dial_state) = DP_WAIT_DIAL ;
					break ;

				case '@' :			// Wait for quiet answer.
					dp_detect_tones_cmd () ;
					G(dp_dial_state) = DP_QUIET_ANSWER ;
					x_set_current_time ( &G(dp_long_timer) ) ;
					break ;

				case ';' :
					// return to command mode
					// without disconnecting the call.
#ifdef HOMOL
					if ( G(S).ModemOptions.DialMode == 0 ) // pulse dial
						x_output(IO_SHUNT_OFF);
#endif
					// ignore ; in speakerphone and voice dialing
					if ( ( G(dp_dialing_status) != DP_VOICE_DIAL )
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
						&& (G(x_modem_mode) != MODEM_SPEAKER_PHONE )
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
						)
					{
						G(x_modem_state) = MS_OFFHOOK ;
						x_send_mail ( DP_AT_DIALDONE, AT_TASK, NULL, 0 ) ;
						return (DIAL_RETURN_IDLE) ;
					}
					break ;

				case '^' :			// Disable data calling tone.
					if ( G(S).ModemOptions.CallingToneFlag == 1 )
						G(dp_calling_tone_disable) = TRUE ;
					break ;

#if defined(VOICE)
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
				case 'V' :
					// Switch to speakerphone mode
					// and dial the number.
					G(dp_dialing_status) = DP_VOICE_DIAL;
					break;
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif

				case '$' :			// Wait for bong tone.
					G(dp_bong_tone1_on_time) = 0  ;
					dp_detect_tones_cmd () ;
					G(dp_dial_state) = DP_BONG ;
					break ;

				case 0 :
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
					if ( ( G(dp_dialing_status) == DP_VOICE_DIAL )
						&& (G(x_modem_mode) != MODEM_SPEAKER_PHONE )
						)
					{
						G(x_modem_mode) = MODEM_SPEAKER_PHONE ;
						// start speakerphone  without calling offhook since
						// modem is already offhook
						x_send_mail ( VOICE_SPEAKER_PHONE, DP_TASK, NULL, 1 );
						G(dp_dialing_status) = DP_SUBSEQUENT_DIAL ;
					}
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif
#ifdef DC0
					if ( G(cell_active) == TRUE )
						cell_send () ;
#endif
					return DIAL_RETURN_NULL;	// done dialing
					//break ;

#if !defined(CS_MODEM)
				case 'S' :			// Dial stored phone number.
					if ( *(G(dp_dial_ptr) + 1) == '=' )
					{
						word index ;
	    				/* copy number into dial string */
						index = (word)(*(G(dp_dial_ptr) + 2) - '0') ;
	    				load_number( index, (G(dp_dial_ptr) + 1) ) ; 
					}
					G(dp_redial) = TRUE ;
					break ;
#endif

				case '0' :
				case '1' :
				case '2' :
				case '3' :
				case '4' :
				case '5' :
				case '6' :
				case '7' :
				case '8' :
				case '9' :
				case 'A' :
				case 'B' :
				case 'C' :
				case 'D' :
				case '*' :
				case '#' :
					if ( ( G(S).ModemOptions.DissableABCD ) // ABCD not permited 
						&& ( (*G(dp_dial_ptr) >= 'A') && (*G(dp_dial_ptr) <= 'D') ) )
					{
						++G(dp_dial_ptr) ;
						return ( DIAL_RETURN_OK ) ;
					}
#ifdef DC0
					if ( prnC && ( cell_state_online () == FALSE ) )
					{
						G(dp_dial_timer) = x_current_time () ;
						while ( *G(dp_dial_ptr) != 0 )
						{
							if ( dp_dial_modify_check ( *G(dp_dial_ptr) ) == FALSE )
							{
                                if ( *G(dp_dial_ptr) != '-' )
                                    cell_dial ( *G(dp_dial_ptr)++ ) ;
                                else
                                    G(dp_dial_ptr)++ ;
							}
							else if ((*G(dp_dial_ptr)++  == ';' )
								 && ( G(dp_dialing_status) != DP_VOICE_DIAL )
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
								 && (G(x_modem_mode) != MODEM_SPEAKER_PHONE )
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
							)
								return (DIAL_RETURN_IDLE) ;
							else
								return ( DIAL_RETURN_OK ) ;
						}
						return ( dp_dial () ) ;
					}
#endif
					if ( G(S).ModemOptions.DialMode == 0 )
					{ 	// pulse dialing
						if ( ( *G(dp_dial_ptr) >= '0' ) &&
						 	( *G(dp_dial_ptr) <= '9' ) )
						{
							dial_digit = (byte) (*G(dp_dial_ptr) & 0x0f);

							switch ( G(S).ModemOptions.PulseDigitPattern )
							{
							case 2 : //Sweden
								if ( dial_digit == 9 )
									dial_digit = 10 ;
								else dial_digit= (byte) (dial_digit+1);
								break;
							case 3 : //Norway
								if ( dial_digit == 0 )
									dial_digit = 10 ;
								else dial_digit = (byte) (10-dial_digit);
								break;
							case 1:	// normal
							default:
								if ( dial_digit == 0 )
									dial_digit = 10 ;
								break;
							}

							G(dp_dial_timer) = x_current_time () ;
							dp_pulse_dial_cmd ( dial_digit ) ;
							G(dp_dial_state) = DP_DIGIT_PAUSE ;
						}
					}
					else	// default DTMF dialing
					{
						// drop volume for buzzer - to prevent clipping
#if (DATAFAXONLY==1)
						dp_write_dsp_ram(0x0D, 0x90);
#endif
						convert_dtmf_digit(G(dp_dial_ptr), &dial_digit) ;
						dp_DTMF_dial_cmd ( dial_digit ) ;
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
						if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
						{
							G(dp_dial_pause) = (word)(G(S).ModemOptions.DtmfDialSpeed << 1);
							G(dp_dial_state) = DP_DIAL_PAUSE ;
						}
						else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif
							G(dp_dial_state) = DP_DIGIT_PAUSE ;
					}
					break ;
			}
			if ( *G(dp_dial_ptr) != 0 )
				++G(dp_dial_ptr) ;
			break ;

		case DP_DIAL_PAUSE :
			// we're pausing in the midst of
			// dialing.  got a ',' or '#' character
			// or between DTMF digits
			if ( ( x_elapsed_time ( G(dp_dial_timer) ) >= G(dp_dial_pause) )
				|| ( x_elapsed_time ( G(dp_timer) ) > 0xfff5 ) )
			{
				G(dp_dial_state) = DP_DIAL_DIGIT ;
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
				if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
					dp_write_dsp_ram ( TRAIN_GAIN_ADDR, 0x0200 ) ;
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif
#ifdef HOMOL
				if ( ( G(S).ModemOptions.DialMode == 0 ) // pulse dial
			 			&& ((*G(dp_dial_ptr) == 0) || (*G(dp_dial_ptr) == 'T')) )
					x_output(IO_SHUNT_OFF);
#endif
			}
			break ;

		case DP_DIGIT_PAUSE :
			if ( !( dp_read_dsp_ram(0x3a) & 0x10 )  )
			{
				if ( ( G(S).ModemOptions.DialMode == 0 ) // pulse dial
			 			&& ((*G(dp_dial_ptr) == 0) || (*G(dp_dial_ptr) == 'T')) )
				{
					if ( G(S).ModemOptions.CountryId == FRANCE )
						G(dp_dial_pause) = 900 ; 
					else if ( G(S).ModemOptions.CountryId == AUSTRIA )
						G(dp_dial_pause) = 300 ; 
					else
						G(dp_dial_pause) = 750 ; 
					G(dp_dial_timer) = x_current_time () ;
					G(dp_dial_state) = DP_DIAL_PAUSE ;
				}
				else
					G(dp_dial_state) = DP_DIAL_DIGIT ;
			}
			break ;

	}

	return DIAL_RETURN_OK;		// continue dialing
}

