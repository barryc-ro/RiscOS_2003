/*name and version number:@(#)faxecm.c	1.30*/
/*date of get: 		  12/15/00 10:10:45*/
/*date of delta:	  11/30/00 19:25:14*/
/****************************************************************
File :	faxecm.c

Description :
	Contains all the functions for Class 2 & 2.0 Error Correction
	Mode (ECM).

Procedures Contained :

Revision History :
	Initials	        Date		  Change
	SJ Busak				09/17/99	  Initial
	SJ Busak        11/05/99    Add changes for CS-4
  SJ Busak        12/01/99    Add changes to use a 64K buffer for CS-4 builds

*****************************************************************

	A fragmented, 16k buffer consists of the following unused (during
	FAX mode that is) RAM areas:

		byte symbol[]       // V.42bis RAM -- 2048 bytes
		word right []       // V.42bis RAM -- 4096 bytes
		word child []       // V.42bis RAM -- 4096 bytes
		byte parent []      // V.42bis RAM -- 2048 bytes
		lapm_transmit_frame // LAPM RAM    -- 2349 bytes  2048 used

		io_dte_tx_buff []   // DTE Tx RAM  -- 2500 bytes, 2048 used for FAX Tx
				 or
		io_dte_rx_buff []   // DTE Rx RAM  -- 3900 bytes, 2048 used for FAX Rx

	For transmit, this buffer is used to buffer a partial page until the
	receiving FAX acknowledges error-free receipt of the data.  Also, the
	last 2K bytes of the buffer during transmit will be io_dte_tx_buff.

	During receive, io_dte_rx_buff will be used as the last 2K bytes of buffer.
	Data will only need to be buffered on receive if errors occur.  All frame
	up to the one with errors will be sent directly to the DTE.
*/

//#define PC_DEBUG         // ***DEBUG*** -- Uncomment to debug code on PC without modem
//#define TEST_RR_RNR      // ***DEBUG*** -- Uncomment to test Rx RR/RNR sequence
//#define TEST_CTC_CTR     // ***DEBUG*** -- Uncomment to test CTC/CTR sequence
//#define TEST_EOR_ERR     // ***DEBUG*** -- Uncomment to test EOR/ERR sequence
//#define BAD_FRM_NUM 102  // ***DEBUG*** -- Specify frame number to force bad FCS (0 - 255)
//#define DISPLAY_ABORT    // ***DEBUG*** -- Uncomment to display aborted state & sub-state values
//#define DISPLAY_TIMEOUT  // ***DEBUG*** -- Uncomment to display timed out state & sub-state values

#if defined(PC_DEBUG)
	#define FAX_ECM
	#include "misc.h"
#else
	#include "llglob_d.h"
	#include "ioglob_d.h"
	#include "dpglob.h"
	#include "z80glob.h"
	#include "lapm.h"
	#include "v42bis.h"
#endif

#ifdef FAX_ECM
	#include "fax_c2.h"
	#include "fax_ecm.h"
	#include "atglob.h"
	#ifdef V34_FAX
		#include "faxv34.h"
	#endif
	#ifdef CS_4
		#include <mqx.h>
	#endif
	#include "allglobs.h"

//	#define x_debug_msg(x) (ddputs_24l(x))  // ***DEBUG***

typedef	int* fptr;

#define DLE_DLE 0x10
#define DLE_PRI 0x21
#define DLE_BCC 0x2F
#define DLE_ETX 0x03
#define FET     3

/* ---------------------------------- */
/* Declaration of function prototypes */  
/* ---------------------------------- */

static void write_ecm_buf       (byte);
static void tx_pp_setup         (void);
static word read_ecm_buf        (void);
static void init_ecm_buf        (byte);
static void load_ecm_frame      (byte, byte);

static void load_rtc            (void);
static void tx_pp_cl2_fecm2     (void);
static void tx_cl20_ecm         (void);
static void send_ecm_pms        (void);
static void process_pmr         (void);

static void resend_err_frames   (void);
static void init_next_tx        (byte);
static void ecm_buf_ctrl        (void);
static void ld_64byte_frm       (void);
static void send_rr             (void);

static void get_rr_rsp          (void);
static void send_ctc            (void);
static void get_ctc_rsp         (void);
static void send_eor            (void);
static void get_eor_rsp         (void);

static void chk_phcto           (void);
static void get_ecm_pmr         (void);
static byte ecm_response_rx     (void);
static void ecm_dcn             (void);
static void reset_ecm           (void);

static void dte_response_tx     (byte);
static void check_response      (byte);
static void setup_rx_response   (void);
static void restore_dte_buffers (void);
static void cl20_end_pg         (byte);

static void chk_ecm_timeout     (byte);
static void reset_ecm_timer     (void);
static void chk_ecm_abort       (byte);

static void init_rx_blk         (void);
static void rx_pp_setup         (void);
static void rx_ecm_frms         (void);
static byte set_ecm_wptr        (void);

static void send_to_dte         (void);
static void get_ecm_rsp         (void);
static void process_pps         (void);
static void send_mcf_rsp        (void);
static void send_rnr_rsp        (void);

static void chk_rnr_rsp         (void);
static void send_ppr_rsp        (void);
static void set_fet             (void);
static void send_ctr_err        (void);
static void send_t30_rsp        (byte);

static void next_rx_state       (void);
static void exit_ecm_rx         (void);
static byte rx_ready            (void);
static void dte_end_of_page     (void);
struct ECM_PPR;
static byte load_frm_data       (struct ECM_PPR*);

static void remove_dle_dle      (word*);
static void set_non_ecm         (void);
static byte proc_v34_fax_rsp    (void);
static byte carrier_detected    (void);
static void load_dce_fifo       (word);

/* ------------------------ */
/* Declaration of variables */
/* ------------------------ */

#if defined(TEST_CTC_CTR) || defined(TEST_EOR_ERR)
	byte bad_fcs;
#endif

struct ECM_PPR
{
	byte rcvd_frm[32];  // Bit map for 256 frames: 0 indicates frame has been received (right to left order)
	byte bad_frm[32];   // Bit map for 256 frames: 1 indicates frame was received with errors (right to left order)
	byte idx;           // Index into bit maps
	byte mask;          // Mask for bit maps
	byte rcp;           // Number of consecutive RCP frames received
	byte zeros;         // Count '0' bits when detecting EOLs
	byte eol;           // Number of consecutive EOLs detected in data stream
	word line_cnt;      // Number of lines received
	byte frm_cnt;       // Number of frames received
	byte dte_xfer;      // State variable for DCE-DTE data transfers
	byte dte_cnt;       // Number of frame bytes to send to DTE
	byte last_rsp;      // Last response sent
};

#ifdef TEST_RR_RNR // ***DEBUG***
	byte rr_cnt;     // ***DEBUG***
#endif             // ***DEBUG***

/* Definition of bits in ecm_stat:

	b7: 1: Wait for the +FET=n command from the DTE (Class 2)
	b6: 1: Time-out during phase C
	b5: 1: Hang up the call; don't send DCN
	b4: 1: RTC split over two blocks (Class 2)
	b3: 1: DLE-SUB split between two blocks (Class 2.0)
	b2: 1: The end of the page is in the ECM buffer
	b1: 1: Expecting EOR after flow control (RR/RNR)
	b0: 1: ECM Tx/Rx is active
*/

/* Masks used for variable: ecm_stat */

#define LOST_RTC   0x4000   // 1: RTC may have been lost after EOR using 256-byte frames
#define ECM_64K    0x2000   // 1: Using 64K ECM buffer (CS-4);  0: Using 16K fragmented buffer
#define ECM_REPT   0x1000   // 1: Remote DCE repeating ECM command; 0: Remote DCE repeating non-ECM command
#define FDR_RCVD   0x0800   // 1: +FDR received from host
#define EOR_RCVD   0x0400   // 1: EOR received from remote DCE
#define DC2_RCVD   0x0200   // 0: Wait for DC2; 1: Don't wait for DC2
#define FRM_256    0x0100   // 0: 64-byte ECM frames; 1: 256-byte ECM frames

#define NEED_FET   0x80
#define ECM_PHCTO  0x40
#define HANG_UP    0x20
#define RTC_SPLIT  0x10
#define DLE_SPLIT  0x08
#define END_PAGE   0x04
#define EXPECT_ERR 0x02
#define ECM_ACTIVE 0x01

#define FRAME_SIZE (G(ecm_stat) & FRM_256 ? 256 : 64)
#define V42BIS_FRAG_SIZE	(12*1024)	// Need at least 12K from v42bis mem
#define NUM_BUF_FRAGS	(sizeof(sbuf_tx)/sizeof(const byte *))
#define LAST_BUF_FRAG	(NUM_BUF_FRAGS - 1)

#ifdef SA_MULTI_INSTANCE
	#define G_VAR(x) ( ((GLOBALS*)0)->x )
	#define B_VAR(x) ( ((BGLOBALS*)0)->x )
	#define BUFF(x)  ( &BGlobArray[ModemNum].x[0] )
	#define RD_BASE  (G(ecm_buf.idx_rd) == LAST_BUF_FRAG ? (unsigned long)&BGlobArray[ModemNum] : (unsigned long)GlobPtr) +
	#define WR_BASE  (G(ecm_buf.idx_wr) == LAST_BUF_FRAG ? (unsigned long)&BGlobArray[ModemNum] : (unsigned long)GlobPtr) +
	#define V42BIS_FRAG_START	( G_VAR(v42bis_tree) )
#else
	#define G_VAR(x) x
	#define B_VAR(x) x
	#define BUFF(x)  x    
	#define RD_BASE
	#define WR_BASE  
	#define V42BIS_FRAG_START	( V42BIS_MEM_START )
#endif

/* ------------------------ */
/* Declaration of constants */
/* ------------------------ */
#if defined(MODEM_ARM)
	#define FRAGMENT_END 2047
#else
// Check if 16K of RAM is available for the ECM buffer (See comment at beginning of file)
// *** NOTE: For CS-4, there's enough memory to create a 64K byte buffer using a heap ***
	#if ( (sizeof (G_VAR(lapm_transmit_frame)) >= 2048) &&  \
			(sizeof (B_VAR(io_dte_tx_buff)) >= 2100) && \
			(sizeof (B_VAR(io_dte_rx_buff)) >= 2100) && \
			(V42BIS_MEM_SIZE >= V42BIS_FRAG_SIZE) )

		#define FRAGMENT_END 2047

	#else
		#error "Insufficient RAM for FAX ECM buffer!"

	#endif
#endif                          

static const byte* const sbuf_tx [] =  /* Starting address of fragments for TX */
{
	(const byte*) V42BIS_FRAG_START,
	(const byte*) G_VAR(lapm_transmit_frame),
	(const byte*) B_VAR(io_dte_tx_buff)         /* NOTE: Use DTE Tx buffer when transmitting a FAX */
};

static const byte* const ebuf_tx [] =  /* Ending address of fragments for TX */
{
	(const byte*) V42BIS_FRAG_START + V42BIS_FRAG_SIZE - 1,
	(const byte*) G_VAR(lapm_transmit_frame) + FRAGMENT_END,
	(const byte*) B_VAR(io_dte_tx_buff) + FRAGMENT_END
};

static const byte* const sbuf_rx [] =  /* Starting address of fragments for RX */
{
	(const byte*) V42BIS_FRAG_START,
	(const byte*) G_VAR(lapm_transmit_frame),
	(const byte*) B_VAR(io_dte_rx_buff)         /* NOTE: Use DTE Rx buffer when receiving a FAX */
};

static const byte* const ebuf_rx [] =  /* Ending address of fragments for RX */
{
	(const byte*) V42BIS_FRAG_START + V42BIS_FRAG_SIZE - 1,
	(const byte*) G_VAR(lapm_transmit_frame) + FRAGMENT_END,
	(const byte*) B_VAR(io_dte_rx_buff) + FRAGMENT_END
};

/* -------------------------------- */
/* State Table for ECM Transmission */
/* -------------------------------- */

static const fptr ecm_tx [] = /* States for Transmission using ECM */
{
	(fptr) tx_pp_setup,         /* ECM_ORG1:  0-Setup to transmit a partial page       */
	(fptr) ecm_buf_ctrl,        /* ECM_ORG3:  1-Xfer data between DTE/ECM/DCE buffers  */
	(fptr) send_ecm_pms,        /* ECM_ORG5:  2-Send post-message status               */
	(fptr) get_ecm_pmr,         /* ECM_ORG4:  3-Get the post-message response          */
	(fptr) tx_pp_setup,         /* ECM_ORG2:  4-Setup to re-transmit a partial page    */
	(fptr) resend_err_frames,   /*            5-Resend error frames                    */
	(fptr) send_rr,             /* ECM_ORG6:  6-Send the RR query to the remote FAX    */
	(fptr) get_rr_rsp,          /*            7-Get response to RR query               */
	(fptr) send_ctc,            /* ECM_ORG7:  8-Send the CTC command to remote FAX     */
	(fptr) get_ctc_rsp,         /*            9-Get response to CTC command            */
	(fptr) send_eor,            /* ECM_ORG8: 10-Send the EOR command to remote FAX     */
	(fptr) get_eor_rsp,         /* ECM_ORG10:11-Get response to EOR command            */
	(fptr) ecm_dcn              /* ECM_ORG9: 12-Return to state machine in iofax_c2.c  */
};

/* Labels for various ECM Transmit states */

#define ECM_ORG1  0
#define ECM_ORG2  4
#define ECM_ORG3  1
#define ECM_ORG4  3
#define ECM_ORG5  2
#define ECM_ORG6  6
#define ECM_ORG7  8
#define ECM_ORG8  10
#define ECM_ORG9  12
#define ECM_ORG10 11

// ----------------------------- //
// State Table for ECM Reception //
// ----------------------------- //

static const fptr ecm_rx [] =
{
	(fptr) rx_pp_setup,      // ECM_ANS1: 0: Set pump to receive ECM frames
	(fptr) rx_ecm_frms,      //           1: Receive ECM frames
	(fptr) get_ecm_rsp,      // ECM_ANS6: 2: Wait for the post-message status
	(fptr) process_pps,      //           3: Process the post-message status
	(fptr) send_mcf_rsp,     // ECM_ANS4: 4: Send MCF response to remote FAX modem

	(fptr) send_ppr_rsp,     // ECM_ANS2: 5: Send partial-page report to remote FAX modem
	(fptr) get_ecm_rsp,      // ECM_ANS7: 6: Get CTC or EOR command
	(fptr) send_ctr_err,     // ECM_ANS5: 7: Send CTR or ERR response

	(fptr) send_rnr_rsp,     // ECM_ANS3: 8: Do RNR/RR flow control sequence
	(fptr) get_ecm_rsp,      //           9: Get response to RNR
	(fptr) chk_rnr_rsp,      //          10: Process response to RNR

	(fptr) exit_ecm_rx       // ECM_ANSX:11: Return to Class 2/2.0 non-ECM state machine
};

#define ECM_ANS1 0
#define ECM_ANS2 5
#define ECM_ANS3 8
#define ECM_ANS4 4
#define ECM_ANS5 7
#define ECM_ANS6 2
#define ECM_ANS7 6
#define ECM_ANSX 11

#ifdef ECM_64K_BUFF
	#define B1AR      0x19
	#define B1BR      0x11
	#define EN_BANK1  0x83
	#define DIS_BANK1 0x00

/* ------------------------------------------- */
/* Write a byte into the 64K Bank 1 ECM buffer */
/* ------------------------------------------- */

void write_ecm_buf (byte data)
{
	disable_interrupt ();               // The ISR doesn't need to bother with Bank 1
	output8 (B1AR, EN_BANK1);           // Map Bank 1 area into top 4K of Bank 0 area
	output8 (B1BR, G(ecm_buf.idx_wr));  // Set "adder" to access current 4K segment

	*G(ecm_buf.wptr)++ = data;          // Store the data into the buffer

	output8 (B1AR, DIS_BANK1);          // Disable Bank 1 area; restore Bank 0 to 12K
	enable_interrupt ();                // Allow interrupts

	G(ecm_buf.count)++;                 // Add 1 to the byte total
	G(ecm_buf.rd_cnt)++;                // Add 1 to read count

	if (G(ecm_buf.wptr) >= (byte*)0x4000) // End of 4K segment?
	{
		G(ecm_buf.wptr) = (byte*)0x3000;    // Reset pointer to beginning of 4K segment
		G(ecm_buf.idx_wr)++;                // Next 4K segment
	}
}

/* ------------------------------------------ */
/* Read a byte from the 64K Bank 1 ECM buffer */
/* ------------------------------------------ */

word read_ecm_buf (void)
{
	byte data;

	disable_interrupt ();               // The ISR doesn't need to bother with Bank 1
	output8 (B1AR, EN_BANK1);           // Map Bank 1 area into top 4K of Bank 0 area
	output8 (B1BR, G(ecm_buf.idx_rd));  // Set "adder" to access current 4K segment

	data = *G(ecm_buf.rptr)++;          // Read data from the buffer

	output8 (B1AR, DIS_BANK1);          // Disable Bank 1 area; restore Bank 0 to 12K
	enable_interrupt ();                // Allow interrupts

	G(ecm_buf.rd_cnt)--;                // Subtract 1 from read count

	if (G(ecm_buf.rptr) >= (byte*)0x4000) // End of 4K segment?
	{
		G(ecm_buf.rptr) = (byte*)0x3000;    // Reset pointer to beginning of 4K segment
		G(ecm_buf.idx_rd)++;                // Next 4K segment
	}

	return ((word)data);
}

/* ------------------------------------------------ */
/* Initialize the structure used for the ECM buffer */
/* ------------------------------------------------ */

void init_ecm_buf (byte num)
{
	num++;         // NOP -- prevent compiler warning
	reset_ecm ();  // Initialize ECM structure
}

/* ------------------------------------------- */
/* Reset the ECM buffer for the next 64K block */
/* ------------------------------------------- */

void reset_ecm (void)
{
	G(ecm_buf.idx_rd) = 0xBD;  // 0xBD000 + 0x03000 = 0xC0000 ; Physical address
	G(ecm_buf.idx_wr) = 0xBD;
	G(ecm_buf.count)  = 0;
	G(ecm_buf.rd_cnt) = 0;
	G(ecm_buf.rptr) = (byte*)0x3000;
	G(ecm_buf.wptr) = (byte*)0x3000;
}
#endif   // ifdef ECM_64K_BUFF

/* ------------------------------------ */
/* Main Class 2/2.0 FAX ECM Tx function */
/* ------------------------------------ */

byte fax_ecm_tx (void)
{
	CALL(ecm_tx [G(ecm_state)]);         // Run current state machine
	return (G(ecm_stat) & ECM_ACTIVE);   // Return status of ECM
}

/* ---------------------------------------- */
/* Initialization for FAX, ECM Transmission */
/* ---------------------------------------- */
/* NOTE: Called only before entering phase C.
				 Variable ecm_pc is initialize in function org_init in
				 iofax_c2.c
*/

void ecm_tx_init (byte clr_pc)
{
	if (clr_pc)                        // Just clear page count?
		G(ecm_pc) = 0;                      // Clear page count

	else                               // Initialization before Tx?
	{
		init_ecm_buf (1);                /* Initialize ECM buffers for transmission */
		reset_ecm_timer ();
		dte_response_tx (0xFF);          /* Reset DTE response sequencer */

		G(ecm_state)   = 0;                 // Reset state machine
		G(ecm_ss)      = 0;                 // Reset sub-state variable
	#if defined(CS_4) || defined(ECM_64K_BUFF)
		G(ecm_stat) = (G(ecm_stat) & ECM_64K) | ECM_ACTIVE;  // Preserve ECM buffer size; set ECM active; clear other flags
	#else
		G(ecm_stat)    = ECM_ACTIVE;        // Indicate ECM is active; clear other status
	#endif                            
		dte_at_cmd ();                   // Clear DTE command register
		G(ecm_ppr_cnt)     = 0;                 // Clear partial-page response count
		G(ecm_bc)      = 0;                 // Clear block count
		G(ecm_fc)      = 0;                 // Clear frame count
		G(ecm_rsp_state)   = 0;                 // DTE Response receive state
		G(ecm_rsp_seq)     = 0;                 // DTE Response sequence pointer

#if defined(TEST_CTC_CTR) || defined(TEST_EOR_ERR)          // ***DEBUG***
		bad_fcs = 0;                     // Generate a bad FCS  // ***DEBUG***
#endif                                                      // ***DEBUG***
	}
}

/* -------------------------------- */
/* Setup to transmit a partial page */
/* -------------------------------- */
/*
	 Sub-state 0,5: Turn on transmitter using short/long train
	 Sub-state 1:   Wait until the pump is ready, then
									- Start 200ms delay (synchronization sequence) and
									- Send CONNECT and <XON> to the DTE
	 Sub-state 2:   Wait for 200ms delay to expire, then send page data
	 Sub-state 3,4: T.30 Silence time wait before short/long train startup
*/

void  tx_pp_setup (void)
{
	switch (G(ecm_ss))
	{
	 /*******/
		case 0:   // Setup modem to transmit synchronous data, short train for V.17
		case 5:   // Use long train if using V.17
	 /*******/
#ifdef V34_FAX
			if (G(x_fax_v34mode) == NON_V34)  // Not using V.34 modulation?
#endif
			{
				G(ecm_fax_hdlc) = 1;                   // HDLC mode for ECM; idle char = 0x7E

				if (!G(ecm_ss))                    // Use short train?
					set_train (V17_SHORT_TRAIN);

				else                            // Use long train
					set_train (V17_LONG_TRAIN);
			}

			setup_sync_tx ();               // Turn on transmitter
			G(ecm_ss) = 1;                     // Wait until modem is ready
			reset_ecm_timer ();
			break;

	 /*******/
		case 1:   /* Wait until the modem is ready */
	 /*******/
			if (fax_tx_rdy ())  // Is transmitter ready for data?
			{
				reset_ecm_timer ();
				dte_response_tx (0);           // Send "CONNECT" & <XON> to DTE
				G(ecm_ss)++;                      // Wait for 200 ms delay to expire
			}

			else
			{
				chk_ecm_abort ('T');
				chk_ecm_timeout ('T');
			}

			break;

	 /*******/
		case 2:   /* Send flags (0x7E) for 200ms */
	 /*******/
			if (x_elapsed_time (G(ecm_timer)) >= ecm_flag_time ())
			{
				reset_ecm_timer ();
				G(ecm_ss) = 0;                      // Reset sub-state
				G(ecm_state)++;                     // Next state

				if (!G(ecm_bc) &&                     // Beginning of page? (Block #0)?
						((G(ecm_state) - 1) == ECM_ORG1)) // First tranmission of this block?
					G(io_dte_rx_last_ch) = 0;         // Initialize last byte for DLE filtering

				reset_phcto ();                  // Reset phase C timer
			}

			break;

	/********/
		case 3:    // Wait for T.30 Silence time (55ms to 6000ms) between pages and partial pages
		case 4:    // Use long train if V.17 is used
	/********/
			if (x_elapsed_time (G(ecm_timer)) >= 60)       //
				G(ecm_ss) = G(ecm_ss) == 3 ? 0 : 5;             // Use short/long train on startup

			break;

	 /********/
		default:
	 /********/
			chk_ecm_timeout ('T');
	}
}

/* ---------------------------------------------------- */
/* Control transfer of data between DTE/ECM/DCE buffers */
/* ---------------------------------------------------- */

void ecm_buf_ctrl (void)
{
#if defined(IWF_FAX) || defined(CLASS20_FAX)
	if (G(c2p.fclass) == 0x20)                 /* Class 2.0? */
		tx_cl20_ecm ();                  // Use Class 2.0 DTE interface

	else
#endif
		tx_pp_cl2_fecm2 ();              /* DCE buffering */

	chk_phcto ();                      /* Check if Phase C timed out */
}

#if defined(IWF_FAX) || defined(CLASS20_FAX)
/* ---------------------------------------------------- */
/* Send a partial page using a Class 2.0, DTE interface */
/* ---------------------------------------------------- */
/* NOTE: Venus 2 required for Client to use 256-byte frames; 64-byte frames otherwise.
         64- or 256-byte frames allowed for CS-4  */

void tx_cl20_ecm (void)
{
	word i;
	byte data;
	#if defined(CS_4) || defined(ECM_64K_BUFF)
		long buf_full = G(ecm_stat) & ECM_64K ? 0x10000 : 0x4000;
	#endif

	/* Load the ECM buffer with 16K/64K of filtered data */
	/* ------------------------------------------------- */

	i = io_get_dte_rx_bytes ();   /* Number of bytes in buffer */

	#if defined(CS_4) || defined(ECM_64K_BUFF)
		while ( i-- && (G(ecm_buf.count) < buf_full) && (!(G(ecm_stat) & END_PAGE) ) )
	#else
		while ( i-- && (G(ecm_buf.count) < 0x4000) && (!(G(ecm_stat) & END_PAGE) ) )
	#endif            
	{
		data = (byte) read_dte_fifo ();

		if (G(io_dte_rx_last_ch) == DLE)
		{
			switch (data)
			{
			 /*************/
				case DLE_SUB:   /* Substitute two DLE patterns */
			 /*************/
					write_ecm_buf (DLE);

	#if defined(CS_4) || defined(ECM_64K_BUFF)
					if (G(ecm_buf.count) == buf_full)  /* No more room in ECM buffer? */
	#else
					if (G(ecm_buf.count) == 0x4000)  /* No more room in ECM buffer? */
	#endif                  
					{
						G(ecm_stat) = G(ecm_stat) | DLE_SPLIT;  /* DLE-SUB split over two blocks -- Thanks ITU! */
						break;
					}

					/* Fall through */

			 /*************/
				case DLE_DLE:   /* Substitute one DLE pattern */
			 /*************/
					write_ecm_buf (DLE);
					break;

			 /*************/
				case DLE_MPS:   /* End of page, more to follow */
			 /*************/
					cl20_end_pg (0);  // Set +FET=0, END_PAGE and fill frame
					break;

			 /*************/
				case DLE_EOM:   /* End of document, more to follow */
			 /*************/
					cl20_end_pg (1);  // Set +FET=1, END_PAGE and fill frame
					break;

			 /*************/
				case DLE_EOP:   /* End of procedure and session */
			 /*************/
					cl20_end_pg (2);  // Set +FET=2, END_PAGE and fill frame
					break;

			 /*************/
				case DLE_PRI:   /* Request a procedure interrupt */
			 /*************/
					;             /* To be implemented */

			 /*************/
				case DLE_BCC:   /* Buffer credit check */
			 /*************/
					;             /* To be implemented */

			 /*************/
				case DLE_ETX:   /* Acknowledge DCE CANCEL request */
			 /*************/
					;             /* To be implemented */

			 /********/
				default:        /* Transmit-Data-Format commands ignored */
			 /********/
					;             /* Ignore DLE-<any byte> */
			}

			data = 0;
		}

		else if (data != DLE)
			write_ecm_buf ((byte)data);

		G(io_dte_rx_last_ch) = data;
		ld_64byte_frm ();     /* Fill the DCE Tx Buffer with 64/256-byte ECM frames */
	}

	ld_64byte_frm ();   /* Fill the DCE Tx Buffer with 64/256-byte ECM frames */
}

// ----------------------------------------- //
//  Common, Class 2.0 End of Page Processing //
// ----------------------------------------- //

void cl20_end_pg (byte ppm)
{
	#if defined(CS_4) || defined(ECM_64K_BUFF)
		long frm_size = G(ecm_stat) & ECM_64K ? 256 : 64;
	#endif

	G(c2p.fet) = ppm;                    // Set +FET value
	G(ecm_stat) = G(ecm_stat) | END_PAGE;   // Indicate end of page

	#if defined(CS_4) || defined(ECM_64K_BUFF)
		while (G(ecm_buf.count) % frm_size)
	#else
		while (G(ecm_buf.count) % 64)        // Add '0's to make a complete frame
	#endif                          
			write_ecm_buf (0);
}
#endif

/* --------------------------------------------- */
/* Send a partial page for Class 2 and +FECM = 2 */
/* --------------------------------------------- */
/* NOTE: Venus 2 required for Client to use 256-byte frames; otherwise 64-byte frames used
				 64- or 256-byte frame size allowed for CS-4.
				 	
				 DLE-DLE replaced with one DLE
				 DLE-ETX signals end of page
				 DLE-<any other byte> is discarded.
*/

void tx_pp_cl2_fecm2 (void)
{
#if defined(CS_4) || defined(ECM_64K_BUFF)
	long buf_size = G(ecm_stat) & ECM_64K ? 0x10000 : 0x4000;
	long frm_size = G(ecm_stat) & ECM_64K ? 256 : 64;
#endif
	byte data;
	word i;

	i = io_get_dte_rx_bytes ();   // Number of bytes in DTE Rx buffer

#if defined(CS_4) || defined(ECM_64K_BUFF)
	while ( i-- && (G(ecm_buf.count) < buf_size) && (!(G(ecm_stat) & END_PAGE)) )
#else
	while ( i-- && (G(ecm_buf.count) < 0x4000) && (!(G(ecm_stat) & END_PAGE)) )
#endif
	{
		data = (byte) read_dte_fifo ();

		if (G(io_dte_rx_last_ch) == DLE)
		{
			if (data == DLE)
				write_ecm_buf (data);  /* Send a single DLE */

			else if (data == ETX)
			{
				G(ecm_stat) = G(ecm_stat) | (END_PAGE+NEED_FET);  /* End of partial page, wait for +FET */
#if defined(CS_4) || defined(ECM_64K_BUFF)
				while (G(ecm_buf.count) % frm_size)   /* Fill rest of frame with '0's */
#else
				while (G(ecm_buf.count) % 64)         /* Fill rest of frame with '0's */
#endif 
					write_ecm_buf (0);
			}

			data = 0;
		}

		else if (data != DLE)
			write_ecm_buf (data);

		G(io_dte_rx_last_ch) = data;
		ld_64byte_frm ();   /* Fill the DCE Tx Buffer with 64/256-byte ECM frames if ready */
	}

	ld_64byte_frm ();   /* Fill the DCE Tx Buffer with 64/256-byte ECM frames when ready */
}

/* ------------------------------------ */
/* Check the Time-out Timer for Phase C */
/* ------------------------------------ */

void chk_phcto (void)
{
	if (G(io_dce_tx_wptr) != G(io_dce_tx_rptr))          // DCE Tx buffer not empty
		reset_phcto ();                              // Reset phase C timer

	else if (check_phcto ())                       // Phase C time-out?
	{
		load_rtc ();                                 // Send RTC & null frame, followed by RCP
		G(c2p.fet) = 2;                                 // Force +FET=2 -- EOP
		G(c2p.faxerr) = 43;                             // DTE to DCE underflow
		G(ecm_stat) = G(ecm_stat) | (END_PAGE+ECM_PHCTO);  // Force end of page; indicate phase C time-out
		G(ecm_stat) = G(ecm_stat) & ~(RTC_SPLIT+DLE_SPLIT+NEED_FET); // Clear these to hang-up now
		reset_ecm_timer ();
		reset_phcto ();                              // Reset phase C timer
	}
}

/* --------------------------------------------------- */
/* Load the DCE Tx Buffer with a 64/256-byte ECM frame */
/* --------------------------------------------------- */

void ld_64byte_frm (void)  
{
#if defined(CS_4) || defined(ECM_64K_BUFF)
	long buf_size = G(ecm_stat) & ECM_64K ? 0x10000 : 0x4000;

	if (G(ecm_stat) & ECM_64K)                    // Using 64K buffer (256-byte frames)?
	{
		while ( (G(ecm_buf.rd_cnt) >= 256 ) &&      /* At least 256 bytes in ECM buffer? */
						(io_get_dce_tx_count () >= 263 ) )  /* At least 263 bytes free in DCE Tx buffer? */
			load_ecm_frame (G(ecm_fc)++, 255);        /* Frame size-1 */
	}
	else   // Using 16K buffer (64-byte frames)
#endif
	{
		while ( (G(ecm_buf.rd_cnt) >= 64 ) &&       /* At least 64 bytes in ECM buffer? */
						(io_get_dce_tx_count () >= 71 ) )   /* At least 71 bytes free in DCE Tx buffer? */
			load_ecm_frame (G(ecm_fc)++, 64-1);       /* Frame size-1 */
	}

	/* Check if end of block (256 frames) */
#if defined(CS_4) || defined(ECM_64K_BUFF)
	if ( ( (G(ecm_buf.count) == buf_size) || (G(ecm_stat) & END_PAGE) ) &&  // ECM Buffer full or end of page?
#else
	if ( ( (G(ecm_buf.count) == 0x4000) || (G(ecm_stat) & END_PAGE) ) &&  // ECM Buffer full or end of page?
#endif
				 !G(ecm_buf.rd_cnt))                                         // All data in ECM buffer framed?
	{
		G(ecm_rsp_cnt) = 3;           // Send post-message status up to 3 times
		G(ecm_state) = ECM_ORG5;  // Set state to send post-message status
		G(ecm_ss) = 0;            // Reset sub-state variable
	}
}

/* ---------------------------------------------------- */
/* Load the Return to Control (RTC) into the ECM Buffer */
/* ---------------------------------------------------- */

void load_rtc (void)
{
	byte i = 9;
	word d = 0x0800;
#if defined(CS_4) || defined(ECM_64K_BUFF)
	word limit = G(ecm_stat) & ECM_64K ? 0xFF00 : 0x3FC0;  // Room for one more frame
	long frm_size = G(ecm_stat) & ECM_64K ? 256 : 64;
#else
	word limit = 0x3FC0;
#endif

	if (G(ecm_buf.count) > limit)             // Not enough room for RTC?
		G(ecm_stat) = G(ecm_stat) | RTC_SPLIT;  // Put in next block

	else
	{
		if ( (G(c2p.fdcs.ps.df) == 1) || (G(c2p.fdcs.ps.df) == 2) )  // MR, 2D encoding?
		{
			for (i = 0; i < 6; i++)  // Load 6 EOL+T
			{
				write_ecm_buf (0x00);
				write_ecm_buf (0xC0);  // Bit reversed
			}
		}

		else
		{
			if (G(c2p.fdcs.ps.df) == 3)  // MMR encoding?
				i = 3;                     // Send just 2 EOLs

			while (i--)
			{
				write_ecm_buf ((byte)d);    // Pattern: 00 08 80 ...
				d = d << 4;                 // Make next data pattern

				if (d == 0x8000)            // End of cycle?
					d = 0x08;                 // Restart cycle
			}
		}
	}

#if defined(CS_4) || defined(ECM_64K_BUFF)
	while (G(ecm_buf.count) % frm_size) /* Fill rest of frame with '0's */
#else
	while (G(ecm_buf.count) % 64)       /* Fill rest of frame with '0's */
#endif
		write_ecm_buf (0);
}

/* ------------------------------------ */
/* Send the Post-Message Status for ECM */
/* ------------------------------------ */
/*
	 Sub-state 0: Determine next sub-state, send "OK" if end of a complete page
	 Sub-state 1: Wait for a DTE command

	 Sub-state 2: Load RTC block into DCE Tx buffer
	 Sub-state 3: Load the RCP into the ECM Buffer
	 Sub-state 4: Wait until the DCE Tx Buffer is empty
	 Sub-state 5: Send flags for 40ms, turn off Tx
	 Sub-state 6: T.30 delay, Turn on HDLC Tx

	 Sub-state 7: Send the Post-message status
	 Sub-state 8: Wait until DCE Tx buffer is empty, turn off Tx
*/

void send_ecm_pms (void)
{
	byte cmd;
	static const byte pps_msg [] =
	{
		PPS_MPS, PPS_EOM, PPS_EOP, PPS_NULL,
		PPS_PRI_MPS, PPS_PRI_EOM, PPS_PRI_EOP, CTC  
	};

	switch (G(ecm_ss))
	{
	 /*******/
		case 0:   /* Determine the next sub-state */
	 /*******/
			if (G(ecm_stat) & NEED_FET)           // Need post-page message from DTE for G(c2p.fclass) 2?
			{
				dte_response_tx (1);             /* Send "OK" to last +FDT command */
				G(ecm_stat) = G(ecm_stat) & ~NEED_FET; // Clear flag
				G(ecm_ss)++;                        /* Wait for another DTE command */
			}

			else                // Class 2.0 or Not end of page
				G(ecm_ss) = 3;       // Don't wait for a DTE command */

			reset_ecm_timer ();
			break;

	 /*******/
		case 1:   /* Wait for a command from the DTE (Class 2 only) */
	 /*******/
			chk_at_cmd ();        // Process AT-commands
			cmd = dte_at_cmd ();  // Check for Class 2/2.0 commands

			if (!cmd)  // No command yet?
				break;   // Break

			else if (cmd == DTE_FET)  // +FET=n command?
			{
				load_rtc ();                  /* Load RTC frame into ECM buffer */

				if (!(G(ecm_stat) & RTC_SPLIT))  /* Room for RTC frame in ECM buffer? */
					G(ecm_ss)++;                   /* Transfer from ECM buffer to DCE Tx buffer */

				else
					G(ecm_ss) = 3;                 /* Send RTC in next block, load RCP */

				reset_ecm_timer ();
			}

			else if ( (cmd == DTE_FK) ||           // Kill command?
								(x_elapsed_time (G(ecm_timer)) > 5000) )  // Time-out?
			{
				G(ecm_stat) = G(ecm_stat) | (END_PAGE+ECM_PHCTO);  // Force end of page; indicate phase C time-out
				G(ecm_ss) = 2;                                  // Load RTC
				G(c2p.fet) = 2;                                 // Force +FET=2 -- EOP
				G(c2p.faxerr) = cmd == DTE_FK ? 2 : 50;         // Abort or Phase D error
				G(ecm_stat) = G(ecm_stat) & ~(RTC_SPLIT+DLE_SPLIT+NEED_FET); // Clear these to hang-up now
			}

			break;

	 /*******/
		case 2:   /* Wait for room in the DCE Tx buffer for RTC block */
	 /*******/
#if defined(CS_4) || defined(ECM_64K_BUFF)
			if (G(ecm_stat) & ECM_64K)  // Using 64K buffer?
			{
				if (io_get_dce_tx_count () >= 263)     // At least 263 bytes free in DCE Tx buffer?
				{
					load_ecm_frame (G(ecm_fc)++, 255);   // Load into DCE Tx buffer (frame size - 1)
					G(ecm_ss)++;                         // Load RCP frames next
					reset_ecm_timer ();
				}

				else
					chk_ecm_timeout ('T');
			}
			else
#endif
			if (io_get_dce_tx_count () >= 71)   /* At least 71 bytes free in DCE Tx buffer? */
			{
				load_ecm_frame (G(ecm_fc)++, 64-1);   /* Load into DCE Tx buffer */
				G(ecm_ss)++;
				reset_ecm_timer ();
			}

			else
				chk_ecm_timeout ('T');

			break;

	 /*******/
		case 3:   /* Load the RCP into the DCE Tx buffer */
	 /*******/
			if (io_get_dce_tx_count () >= 20)
			{
				byte i;

				for (i = 0; i < 3; i++)     // Send 3 RCP frames
				{
					G(io_crc) = 0xFFFF;					  /* Initialize CRC */

					load_dce_fifo (0x00FF | HDLC_START_OF_FRAME);
					io_compute_crc (0xFF);

					load_dce_fifo (0x03);      /* Control field */
					io_compute_crc (0x03);

					load_dce_fifo (0x86);      /* RCP - Return to control for partial page */
					io_compute_crc (0x86);

					G(io_crc) = ~G(io_crc);
					load_dce_fifo ((byte) (G(io_crc) & 0x00FF) );
					load_dce_fifo ((byte) (G(io_crc) >> 8) );
				}

				io_start_dce_transmit ();
				G(ecm_ss)++;
				reset_ecm_timer ();
			}

			else
				chk_ecm_timeout ('T');

			break;

	 /*******/
		case 4:   /* Wait for the DCE Tx buffer to empty */
	 /*******/
			if (io_dce_tx_fifo_empty ())
			{
				reset_ecm_timer ();
				G(ecm_ss)++;
			}
#ifndef CS_4
			else
				chk_ecm_timeout ('T');
#else              
			else
			{
				if ( !G(c2p.fdcs.ps.br) )   // Using 2,400 bps?
				{
					if (x_elapsed_time ( G(ecm_timer) ) < 7500)  // Longer time needed for CS-4, 2,400 bps
						break;
				}

				chk_ecm_timeout ('T');
			}
#endif
			break;

	 /*******/
		case 5:   /* Send 40ms of flags, turn off transmitter */
	 /*******/
			if (x_elapsed_time (G(ecm_timer)) >= 40)
			{
#ifdef V34_FAX
				if (G(x_fax_v34mode) != NON_V34)   // Using V.34 modulation?
				{
					setup_hdlc_tx ();                // Switch back to control channel now
					G(ecm_ss) = 7;                      // Send PPS when channel is ready
				}
				else                               // Using non-V.34 modulation
#endif
				{
					x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0);
					G(ecm_ss)++;
				}

				reset_ecm_timer ();
			}

			break;

	 /*******/
		case 6:   /* T.30 silence of 75ms +/- 20ms */
	 /*******/
		if (x_elapsed_time (G(ecm_timer)) >= 60)
		{
#ifdef V34_FAX
			if (G(x_fax_v34mode) == NON_V34)   // Not using V.34 modulation?
#endif                                  
				setup_hdlc_tx ();    // Setup to transmit T.30 command

			G(ecm_ss)++;          // PPS-XXX or PPS-PRI-XXX
			reset_ecm_timer ();
		}

		break;

	 /*******/
		case 7:   /* Send PPS-XXX or PPS-PRI-XXX */
	 /*******/
			if (fax_tx_rdy ())              // Is transmitter ready for data?
			{
				G(io_fax_buf) = (void *) &LRQ(0);   /* Move buffer to unused RAM */

				G(io_fax_buf[0]) = 0xFF;    /* Address */
				G(io_fax_buf[1]) = 0x13;    /* Control and final frame */
				G(io_fax_buf[2]) = PPS | get_t30_bit ();     /* Partial page segment - PPS */

				if ( (G(ecm_stat) & (END_PAGE+RTC_SPLIT+DLE_SPLIT) ) == END_PAGE)  /* All data sent? */
					G(io_fax_buf[3]) = pps_msg [G(c2p.fet)];   /* Post page punctuation */

				else
					G(io_fax_buf[3]) = PPS_NULL;             /* End of partial page */

				G(io_fax_buf[4]) = G(ecm_pc);   /* Page count  */
				G(io_fax_buf[5]) = G(ecm_bc);   /* Block count */
				G(io_fax_buf[6]) = (byte)(G(ecm_fc) - 1); // (This compiler really sucks!) Frame count-1

				G(io_hdlc_byte_count) = 7;
				io_fax_hdlc_buf_to_dce( G(io_fax_buf), &G(io_hdlc_byte_count));
#ifdef V34_FAX 
				if (G(x_fax_v34mode) != NON_V34)   // Using V.34 modulation?
				{
					G(ecm_ss) = 0;
					G(ecm_state)++;            // Get Post-message response on control channel
				}
				else
#endif
					G(ecm_ss)++;

				reset_ecm_timer ();
			}

			else
				chk_ecm_timeout ('T');

			break;

	 /*******/
		case 8:   /* Wait until the buffer is empty, turn off modem */
	 /*******/
			if (io_dce_tx_fifo_empty ())        // Has all data been sent?
			{
				x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0);
				G(ecm_ss) = 0;
				G(ecm_state)++;            /* Get Post-message response */
				reset_ecm_timer ();
			}

			else
				chk_ecm_timeout ('T');

			break;

	 /********/
		default:
	 /********/
			chk_ecm_timeout ('T');  // Just time-out
	}

	if (G(ecm_ss) >= 2)
		chk_ecm_abort ('T');
}

/* ------------------------------------------------------- */
/* Get the Post-Message Response from the Remote FAX Modem */
/* ------------------------------------------------------- */
/* Sub-state 0: Turn on HDLC receiver
	 Sub-state 1: Wait for a message, turn off receiver
	 Sub-state 2: Process the post-message response
	 Sub-state 3: Wait for a DTE command
*/

void get_ecm_pmr (void)
{
	byte cmd;

	switch (G(ecm_ss))
	{
	 /*******/
		case 0:    /* Setup to receive the post-message response */
	 /*******/
			setup_rx_response ();
			break;

	 /*******/
		case 1:    /* Wait for a response or time-out */
	 /*******/
			check_response (6);   // Check for a response; Go to sub-state 6 of last state if time-out
			chk_ecm_abort ('T');
			break;

	 /*******/
		case 2:    /* Process the response from remote FAX */
	 /*******/
			remove_dle_dle (G(io_fax_buf));       // Remove DLE-DLE expansion

			if (G(ecm_stat) & ECM_PHCTO)         /* Phase C time-out? */
				G(io_fax_buf[2]) = (word)MCF;     /* Force call to terminate */

			process_pmr ();                 /* Process response */
			break;

	 /*******/
		case 3:   /* Wait for command from DTE */
	 /*******/
			chk_at_cmd ();
			cmd = dte_at_cmd ();

			if (cmd == DTE_FDT)  // Transmit command?
			{
				G(ecm_ss) = 3;            // Wait T.30 silence time
				G(ecm_state) = ECM_ORG1;  /* Setup to transmit a partial page */
			}

			else if ( (cmd == DTE_FK) ||
								(x_elapsed_time (G(ecm_timer)) > 5000) )   /* No DTE command? */
			{
				G(c2p.faxerr) = cmd == DTE_FK ? 2 : 50;  // Set correct error code
				G(ecm_state) = ECM_ORG9;                 // Send DCN and hangup */
			}

			break;

	 /********/
		default:
	 /********/
			chk_ecm_timeout ('T');
	}
}

/* --------------------------------- */
/* Process the Post Message Response */
/* --------------------------------- */
// Note: RTP & RTN are not applicable to ECM

void process_pmr (void)
{
	byte i;

	switch (G(io_fax_buf[2]) & 0x00FE)   /* FIF field of response */
	{
	 /*********/
		case PIP:    /* Procedure Interrupt -- Positive */
	 /*********/
		case PIN:    /* Procedure Interrupt -- Negative */
	 /*********/
			if (!(G(ecm_stat) & END_PAGE))   /* Not end of a complete page? */
			{
				G(c2p.faxerr) = 58;           // Unable to continue after PIN or PIP
				G(ecm_state) = ECM_ORG9;      //  at partial page, send DCN & hangup
				break;
			}

			/* ******************************************************* */
			/* Fall thourgh -- Treat PIP & PIN the same as MCF for now */
			/* ******************************************************* */

	 /*********/
		case MCF:    /* Message Confirmation */
	 /*********/
			G(ecm_ppr_cnt) = 0;   /* Reset consecutive PPR count */
																/* ********************* */
			if (G(ecm_stat) & END_PAGE)  /* End of complete page? */
			{                         /* ********************* */
				if (G(ecm_stat) & RTC_SPLIT)   /* RTC didn't fit in last block? */
				{
					G(ecm_stat) = G(ecm_stat) & ~RTC_SPLIT;  /* Clear flag */
					init_next_tx (ANOTHER_PP);         /* Another partial page */
					load_rtc ();                       /* Send one block with RTC */
				}

				else   /* Set next state based on post-page status */
				{
					G(ecm_stat) = G(ecm_stat) & ~END_PAGE;  /* Clear flag */
					dte_response_tx (2);              /* Send "+FPTS:n & OK to DTE */

					switch (G(c2p.fet))   /* Post page status? */
					{
					 /*******/
						case 0:   /* PPR-MPS */
					 /*******/
							init_next_tx (NEW_PAGE);   /* Start new page */
							break;

					 /*******/
						case 1:   /* PPR-EOM */
					 /*******/
							G(ecm_pc)++;                           // Increment page count
							goto_phase_b ();                    // Re-negotiate parameters */
							restore_dte_buffers ();             
							G(ecm_stat) = G(ecm_stat) & ~ECM_ACTIVE;  // Clear active flag
							break;

					 /*******/
						case 2:   /* PPR-EOP */
					 /*******/
							if (!(G(ecm_stat) & ECM_PHCTO)) // No time-out or abort?
								G(c2p.faxerr) = 0;            // Normal termination

							G(ecm_state) = ECM_ORG9;        // Sends DCN and hangup
							break;

						default:  /* Any invalid +FET */
					 /*******/
							G(c2p.faxerr) = 51;   // RSPREC error
							G(ecm_state) = ECM_ORG9;   /* Sends DCN and hangup */
					}
				}
			}
							/* ********************* */
			else    /* End of a Partial Page */
			{				/* ********************* */
				init_next_tx (ANOTHER_PP);   /* Next partial page */

				if (G(ecm_stat) & DLE_SPLIT)    /* DLE-SUB split over two blocks? */
				{
					write_ecm_buf (DLE);               /* Load 2nd DLE as 1st character */
					G(ecm_stat) = G(ecm_stat) & ~DLE_SPLIT;  /* Clear flag */
				}
			}

		break;

	 /*********/
		case PPR:   /* Partial Page Report */
	 /*********/
			for (i = 0; i < 32; i++)                 // For each byte of the bit map...
				G(ecm_ppr_buf[i]) = (byte) G(io_fax_buf[i+3]);  // Save in PPR buffer

			G(ecm_ppr_mask) = 1;                            // Mask for checking bits
			G(ecm_ppr_fc) = 0;                              // Number of frames resent
			G(ecm_ppr_idx) = 0;                             // Index into ecm_ppr_buf[]
			G(ecm_ss) = 0;                              // Reset sub-state variable
			G(ecm_fc) = 0;                              // Reset frame count
			G(ecm_buf.rd_cnt) = G(ecm_buf.count);          // Reset read counter

#ifdef ECM_64K_BUFF
			G(ecm_buf.idx_rd) = 0xBD;
			G(ecm_buf.rptr) = (byte*)0x3000;
#else              
			G(ecm_buf.idx_rd) = 0;                      // Reset read pointer
	#ifdef CS_4
			if (!(G(ecm_stat) & ECM_64K))   // Not using 64K buffer?
	#endif
				G(ecm_buf.rptr) = RD_BASE (byte*) *(G(ecm_buf.sptr) + G(ecm_buf.idx_rd));
#endif
			G(ecm_ppr_cnt)++;                               // Increment consecutive-PPRs-received count

#ifdef V34_FAX
			if ( (G(x_fax_v34mode) != NON_V34) &&    // Using V.34 modulation?
					 (G(ecm_ppr_cnt) & 1) )                  // 2nd or 4th attempt?
			{
				G(x_fax_maxp) = G(x_fax_maxp) != 1 ? G(x_fax_maxp) - 1 : G(x_fax_maxp);  // Step down rate in not at lowest
				G(x_fax_train) = RATE_RENEG;        // Indicate Rate change (step down rate)
			}
#endif
			if (!(G(ecm_ppr_cnt) % 4))       /* 4th or 8th consecutive PPR? */
				G(ecm_state) = ECM_ORG7;   /* Do the continue-to-correct sequence */

			else
			{
				G(ecm_state) = ECM_ORG2;   /* Resend frames reported with errors */
				G(ecm_ss) = 3;             // T.30 silence delay
			}

			break;

	 /*************/
		case RNR_FAX:   /* Receiver Not Ready */
	 /*************/
			G(ecm_timer_t5) = x_current_time ();
			G(ecm_rsp_cnt) = 3;            /* No response count for RR */
			G(ecm_ss) = 0;
			G(ecm_state) = ECM_ORG6;   /* Execute RNR/RR sequence */
			break;

	 /********/
		default:
	 /********/
			G(c2p.faxerr) = 51;        // RSPREC error
			G(ecm_state) = ECM_ORG9;   // Send DCN & hangup
	}
}

/* ------------------------------------- */
/* Initialization for next page or block */
/* ------------------------------------- */

void init_next_tx (byte s)
{
	reset_ecm ();              // Reset ECM buffer pointers & counters
	G(ecm_fc) = 0;             // Reset frame count

	if (s)                     /* Another partial page? */
	{
		G(ecm_bc)++;                // Increment block count
		G(ecm_state) = ECM_ORG1;    // Turn on high speed transmitter
		G(ecm_ss) = 3;
	}

	else                       /* New page */
	{
		G(ecm_ss)++;                // Wait for another +FDT
		dte_response_tx (0xFF);  // Reset DTE response sequence
		G(ecm_bc) = 0;              // Reset block count
		G(ecm_pc)++;                // Increment page count
	}
}

/* ---------------------------------------------------------- */
/* Retransmit frames reported with errors by the PPR response */
/* ---------------------------------------------------------- */

void resend_err_frames (void)
{
#if defined(CS_4) || defined(ECM_64K_BUFF)
	word frm_size = G(ecm_stat) | ECM_64K ? 256 : 64;

	while ( (G(ecm_buf.rd_cnt)) && (io_get_dce_tx_count () > (frm_size+7) ) )
#else
	while ( (G(ecm_buf.rd_cnt)) && (io_get_dce_tx_count () > 71) )
#endif
	{
		if (G(ecm_ppr_buf[G(ecm_ppr_idx)]) & G(ecm_ppr_mask))   /* Resend this frame? */
		{
#if defined(CS_4) || defined(ECM_64K_BUFF)
			load_ecm_frame (G(ecm_ppr_fc), (byte)(frm_size - 1) );   /* Frame size-1 */
#else
			load_ecm_frame (G(ecm_ppr_fc), 64-1);   /* Frame size-1 */
#endif
			G(ecm_fc)++;                        /* Count frames sent */
			reset_ecm_timer ();
		}

		else  // Frame was received with no errors
		{
#ifdef ECM_64K_BUFF  // Venus 2 Client
			G(ecm_buf.rd_cnt) = G(ecm_buf.rd_cnt) - frm_size;  // Subtract frame from read count
			G(ecm_buf.rptr) = G(ecm_buf.rptr) + frm_size;      // Point to next frame

			if (G(ecm_buf.rptr) >= (byte*)0x4000)
			{
				G(ecm_buf.rptr) = (byte*)0x3000;
				G(ecm_buf.idx_rd)++;
			}
#else  // CS-4 or Client, 16K fragmented buffer
	#ifdef CS_4
			G(ecm_buf.rd_cnt) = G(ecm_buf.rd_cnt) - frm_size;  // Subtract frame from read count
			G(ecm_buf.rptr) = G(ecm_buf.rptr) + frm_size;      // Point to next frame

			if (!(G(ecm_stat) & ECM_64K) )  // Not using 64K buffer?
	#else
			G(ecm_buf.rd_cnt) = G(ecm_buf.rd_cnt) - 64;  /* Subtract frame from read count */
			G(ecm_buf.rptr) = G(ecm_buf.rptr) + 64;      // Point to next frame
	#endif
			{
				if (G(ecm_buf.rptr) > RD_BASE (byte*) *(G(ecm_buf.eptr) + G(ecm_buf.idx_rd)))  /* Past end of fragment? */
				{
					G(ecm_buf.idx_rd)++;         /* Index to next fragment in list */

					if (G(ecm_buf.idx_rd) > LAST_BUF_FRAG)   /* End of list? */
						G(ecm_buf.idx_rd) = 0;     /* Wrap around to beginning */

					G(ecm_buf.rptr) = RD_BASE (byte*) *(G(ecm_buf.sptr) + G(ecm_buf.idx_rd));  /* Get beginning of next fragment */
				}
			}
#endif 
		}

		G(ecm_ppr_fc)++;
		G(ecm_ppr_mask) = G(ecm_ppr_mask) << 1;

		if (!G(ecm_ppr_mask))
		{
			G(ecm_ppr_mask) = 0x01;
			G(ecm_ppr_idx)++;
		}
	}

	if (!G(ecm_buf.rd_cnt))      /* End of partial page? */
	{
		G(ecm_ss) = 3;             /* Sub-state: Load RCP */
		G(ecm_state) = ECM_ORG5;   /* Load RCP into the DCE Tx buffer */
	}

	chk_ecm_timeout ('T');
	chk_ecm_abort ('T');
}

/* -------------------------------------------------------------- */
/* Send the Receiver Ready (RR) Query Command to Remote FAX Modem */
/* -------------------------------------------------------------- */
/*
	 Sub-state 0: Initialization & turn on transmitter
	 Sub-state 2: After preamble, send the RR Query command
	 Sub-state 3: Wait for the DCE Tx fifo to empty & turn off transmitter
*/

void send_rr (void)
{
	switch (G(ecm_ss))
	{
	 /*******/
		case 0:
	 /*******/
#ifdef V34_FAX
			if (G(x_fax_v34mode) == NON_V34) // Not using V.34 modulation
#endif
				setup_hdlc_tx ();  /* Turn on the selected modulation */

			G(ecm_ss)++;
			break;

	 /*******/
		case 1:
	 /*******/
			if (fax_tx_rdy ())              //  Is transmitter ready for data?
			{
				G(io_fax_buf) = (void *) &LRQ(0);   /* Move buffer to unused RAM */

				G(io_fax_buf[0]) = 0xFF;    /* Address */
				G(io_fax_buf[1]) = 0x13;    /* Control and final frame */
				G(io_fax_buf[2]) = RR_FAX | get_t30_bit ();      /* Receiver Ready query */
				G(io_hdlc_byte_count) = 3;
				io_fax_hdlc_buf_to_dce( G(io_fax_buf), &G(io_hdlc_byte_count));
				G(ecm_ss)++;
			}
			break;

	 /*******/
		case 2:
	 /*******/
			if (io_dce_tx_fifo_empty ())
			{
#ifdef V34_FAX
			if (G(x_fax_v34mode) == NON_V34) // Not using V.34 modulation
#endif
					x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0);

				reset_ecm_timer ();
				G(ecm_ss) = 0;
				G(ecm_state)++;   /* Get response */
			}
			break;

	 /********/
		default:
	 /********/
			chk_ecm_timeout ('T');
	}

	chk_ecm_abort ('T');
}

/* ----------------------------------------------------------- */
/* Look for a Response from the Remote FAX Modem to a RR Query */
/* ----------------------------------------------------------- */
/*
	 Sub-state 0: Initialization & turn on the receiver
	 Sub-state 1: Wait for a message & monitor T4 & T5 timers
	 Sub-state 2: Process the received message & turn off receiver
*/

void get_rr_rsp (void)
{
	switch (G(ecm_ss))
	{
	 /*******/
		case 0:   /* Setup modem to receive */
	 /*******/
			setup_rx_response ();
			break;

	 /*******/
		case 1:   /* Wait for a response from remote modem */
	 /*******/
			check_response (0);  // Check for a response; return to sub-state 0 of last state on time-out
			chk_ecm_abort ('T');
			break;

	 /*******/
		case 2:   /* Process the response */
	 /*******/
			if (x_elapsed_time (G(ecm_timer_t5)) >= 60000)  //  T5 = 60 sec +/- 5 sec
			{
				G(c2p.faxerr) = 50;       // Unspecified Transmit Phase D error
				G(ecm_state) = ECM_ORG9;  // Send DCN and hangup
				break;                    // Exit now
			}

			remove_dle_dle (G(io_fax_buf));   // Remove DLE-DLE expansion
			G(ecm_rsp_cnt) = 3;               // Reset no response counter

			switch (G(io_fax_buf[2]) & 0x00FE)
			{
			 /*************/
				case RNR_FAX:   /* Receiver is still not ready */
			 /*************/
					G(ecm_ss) = 0;
					G(ecm_state) = ECM_ORG6;   /* Send RR command again */
					break;

			 /*********/
				case MCF:   /* List of valid responses to RR */
				case ERR:
				case PIP:
				case PIN:
			 /*********/
					if (G(ecm_stat) & EXPECT_ERR)  /* Was RR/RNR sequence started after EOR sent? */
					{
						G(ecm_stat) = G(ecm_stat) & ~EXPECT_ERR;  /* Clear flag */
						G(ecm_ss) = 2;                         /* Set state to process response after EOR */
						G(ecm_state) = ECM_ORG10;              /* Process response in function: get_eor_rsp () */
					}

					else                // Not a response to EOR
					{
						G(ecm_state) = ECM_ORG4;  // Restore state machine to process post-page response
						G(ecm_ss) = 2;
						process_pmr ();   /* Process non-RNR, post-message response */
					}

					break;

			 /********/
				default:    /* Invalid response */
			 /********/
					G(c2p.faxerr) = 50;        // Unspecified Transmit Phase D error
					G(ecm_state) = ECM_ORG9;   // Send DCN and hangup
			}

			break;

	 /********/
		default:  /* ECM sub-state variable invalid */
	 /********/
			chk_ecm_timeout ('T');
	}
}

/* ------------------------------------------------------------ */
/* Send the Continue to Correct (CTC) Command to the remote FAX */
/* ------------------------------------------------------------ */
/*
	 Sub-state 0: Initialization & turn on transmitter
	 Sub-state 1: When transmitter is ready, send the message
	 Sub-state 2: Wait until the DCE Tx FIFO is empty & turn off transmitter
*/

void send_ctc (void)
{
	switch (G(ecm_ss))
	{
	 /*******/
		case 0:
	 /*******/
#ifdef V34_FAX
			if (G(x_fax_v34mode) != NON_V34)    // Using V.34 modulation?
			{
				G(ecm_state) = ECM_ORG8;             // Do end-of-retransmission sequence (CTC/CTR not used for V.34 -- T.30 F.3.2 Note 1)
				send_eor ();                      // Execute first sub-state now
			}
			else
#endif
			if ( (G(ecm_ppr_cnt) / 4) > G(c2p.fctcrty))   // Tried all "attempt blocks?"
				G(ecm_state) = ECM_ORG8;             // Do end-of-retransmission sequence

			else                                 // Try additional "attempt blocks"
			{                   
				setup_hdlc_tx ();                  // Turn on the selected modulation

				if (G(c2p.fdcs.ps.br) > G(c2p.fminsp))   // Are lower rates allowed?
					G(c2p.fdcs.ps.br)--;                // Select next lowest rate

				G(ecm_ss)++;                          // Assemble CTC HDLC frame
				reset_ecm_timer ();
			}

			break;

	 /*******/
		case 1:
	 /*******/
			if (fax_tx_rdy ())                // Has preamble been sent and XMTR ready for data?
			{
				G(io_fax_buf) = (void *) &LRQ(0);   /* Move buffer to unused RAM */

				G(io_fax_buf[0]) = 0xFF;                 /* Address */
				G(io_fax_buf[1]) = 0x13;                 /* Control and final frame */
				G(io_fax_buf[2]) = CTC | get_t30_bit (); /* Continue to Correct */

				G(io_fax_buf[3]) = 0x02;                 /* 64-byte frames */
				G(io_fax_buf[4]) = get_ctc_rate ();      /* New data rate */

				G(io_hdlc_byte_count) = 5;
				io_fax_hdlc_buf_to_dce( G(io_fax_buf), &G(io_hdlc_byte_count));

				G(ecm_ss)++;
				reset_ecm_timer ();
			}

			else
				chk_ecm_timeout ('T');

			break;

	 /*******/
		case 2:
	 /*******/
			if (io_dce_tx_fifo_empty ())
			{
				x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0);
				reset_ecm_timer ();
				G(ecm_ss) = 0;
				G(ecm_state)++;   /* Get response */
				reset_ecm_timer ();
			}

			else
				chk_ecm_timeout ('T');

			break;

	 /********/
		default:
	 /********/
			chk_ecm_timeout ('T');  // Just time-out
	}

	chk_ecm_abort ('T');
}

/* ---------------------------------------------------------- */
/* Look for a Response from the Remote FAX to the CTC Command */
/* ---------------------------------------------------------- */
/*
	 Sub-state 0: Initialization & turn on receiver
	 Sub-state 1: Wait for message & monitor T4
	 Sub-state 2: Process response & turn off receiver
	 Sub-state 3: T.30 delay
*/

void get_ctc_rsp (void)
{
	switch (G(ecm_ss))
	{
	 /*******/
		case 0:
	 /*******/
			setup_rx_response ();
			break;

	 /*******/
		case 1:
	 /*******/
			check_response (0);
			chk_ecm_abort ('T');
			break;

	 /*******/
		case 2:
	 /*******/
			remove_dle_dle (G(io_fax_buf));       // Remove DLE-DLE expansion

			if ( (G(io_fax_buf[2]) & 0x00FE) == CTR)
			{
				G(ecm_state) = ECM_ORG2;  // Re-send error frames
				G(ecm_ss) = 4;            // Use long train if V.17 is used
#ifdef TEST_CTC_CTR
				bad_fcs = 1;    // Don't force a bad FCS anymore
#endif
			}

			else                     // Invalid response
			{
				G(c2p.faxerr) = 50;           // Unspecified Transmit Phase D error
				G(ecm_state) = ECM_ORG9;      /* Send DCN and hangup */
			}

			break;

	 /********/
		default:
	 /********/
			chk_ecm_timeout ('T');
	}
}

/* ---------------------------------------------------------------- */
/* Send the End-of-Retransmission (EOR) Command to Remote FAX Modem */
/* ---------------------------------------------------------------- */
/*
	 Sub-state 0: Initialization & turn on transmitter
	 Sub-state 1: After preamble, send EOR command
	 Sub-state 2: Wait until the DCE Tx FIFO is empty, then turn off transmitter
*/

void send_eor (void)
{
	static const byte eor_cmd [] = {EOR_MPS, EOR_EOM, EOR_EOP};

	switch (G(ecm_ss))
	{
	 /*******/
		case 0:
	 /*******/
#ifdef V34_FAX
			if (G(x_fax_v34mode) == NON_V34) // Not using V.34 modulation?
#endif
				setup_hdlc_tx ();              // Turn on the selected modulation

			G(ecm_ss)++;
			reset_ecm_timer ();
			break;

	 /*******/
		case 1:
	 /*******/
			if (fax_tx_rdy ())              // Is the transmitter ready for data?
			{
				G(io_fax_buf) = (void *) &LRQ(0);   /* Move buffer to unused RAM */

				G(io_fax_buf[0]) = 0xFF;    /* Address */
				G(io_fax_buf[1]) = 0x13;    /* Control and final frame */
				G(io_fax_buf[2]) = EOR | get_t30_bit ();

				if (G(ecm_stat) & END_PAGE)      /* At end of partial page? */
					G(io_fax_buf[3]) = eor_cmd[G(c2p.fet)];

				else
					G(io_fax_buf[3]) = EOR_NULL;

				G(io_hdlc_byte_count) = 4;
				io_fax_hdlc_buf_to_dce( G(io_fax_buf), &G(io_hdlc_byte_count));

				G(ecm_ss)++;
				reset_ecm_timer ();
			}

			else
				chk_ecm_timeout ('T');

			break;

	 /*******/
		case 2:
	 /*******/
			if (io_dce_tx_fifo_empty ())
			{
#ifdef V34_FAX
				if (G(x_fax_v34mode) == NON_V34)    // Not using V.34 modulation?
#endif
					x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0);

				reset_ecm_timer ();
				G(ecm_ss) = 0;
				G(ecm_state)++;   /* Get response */
				reset_ecm_timer ();
				G(ecm_timer_t5) = x_current_time ();  // Reset T5 timer
			}

			else
				chk_ecm_timeout ('T');

			break;

	 /********/
		default:
	 /********/
			chk_ecm_timeout ('T');
	}

	chk_ecm_abort ('T');
}

/* -------------------------------------- */
/* Wait for a Response to the EOR Command */
/* -------------------------------------- */
/*
	 Sub-state 0: Initialization & turn on receiver
	 Sub-state 1: Wait for message & monitor T4
	 Sub-state 2: Process response
*/

void get_eor_rsp (void)
{
	switch (G(ecm_ss))
	{
	 /*******/
		case 0:    /* Setup modem to receive response */
	 /*******/
			setup_rx_response ();
			break;

	 /*******/
		case 1:    /* Wait for response or time-out */
	 /*******/
			check_response (0);
			chk_ecm_abort ('T');
			break;

	 /*******/
		case 2:    /* Process the response */
	 /*******/
			remove_dle_dle (G(io_fax_buf));       // Remove DLE-DLE expansion

			switch (G(io_fax_buf[2]) & 0x00FE)
			{
			 /*********/
				case PIN:
			 /*********/
				if (!(G(ecm_stat) & END_PAGE))  /* Not end of a page? */
				{
					G(c2p.faxerr) = 50;          // Unspecified Transmit Phase D error
					G(ecm_state) = ECM_ORG9;     // PIN not allowed after EOR-NULL, Tx DCN */
					break;
				}
				/**** FALL THROUGH -- Treat (PIN & !END_PAGE) like ERR for now ****/

			 /*********/
				case ERR:
			 /*********/
#ifdef TEST_EOR_ERR
					bad_fcs = 1;   // Don't force a bad FCS anymore
#endif
#ifdef V34_FAX
					if (G(x_fax_v34mode) != NON_V34)    // Not using V.34 modulation?
						G(ecm_ppr_cnt) = 0;                   // Prevent "if" below from being TRUE
#endif
					if ( (G(ecm_ppr_cnt) >= 8) &&                  // Tried at least 8 times?
							 (G(c2p.fdcc.ps.br) == G(c2p.fminsp)) )   // At lowest, allowable speed?
					{
						G(c2p.faxerr) = 40;        // Unspecified Transmit Phase C error
						G(ecm_state) = ECM_ORG9;   // Send DCN and hangup
					}

					else if (G(ecm_stat) & END_PAGE) /* End of a complete page? */
					{
						dte_response_tx (2);        // Send "+FPTS:n & OK to DTE
						G(io_fax_buf[2]) = MCF;        // Treat ERR the same as MCF
						G(ecm_state) = ECM_ORG4;       // Process Post-message response (MCF)
						G(ecm_ss) = 2;                 //   through normal path
					}

					else                          // End of partial page
						init_next_tx (ANOTHER_PP);  // Setup for another partial page

					G(ecm_ppr_cnt) = 0;                  // Reset number of consecutive PPRs received

					break;

			 /*************/
				case RNR_FAX:
			 /*************/
					G(ecm_stat) = G(ecm_stat) | EXPECT_ERR;  /* Come back here after flow control */
					G(ecm_ss) = 0;
					G(ecm_state) = ECM_ORG6;              /* Do RR/RNR sequence */
					break;

			 /********/
				default:
			 /********/
					G(c2p.faxerr) = 50;       // Unspecified Transmit Phase D error
					G(ecm_state) = ECM_ORG9;  // Send DCN and hangup
			}

			break;

	 /********/
		default:    /* Invalid value for sub-state variable */
	 /********/
			chk_ecm_timeout ('T');
	}
}

/* --------------------------------------- */
/* Load an ECM frame into the DCE Tx Queue */
/* --------------------------------------- */
/* Note: This function assumes sufficient space is available
	 in the DCE Tx queue.  Therefore, it must be checked
	 before this function is called.

	 A frame number and frame size are passed to the function.
*/

void load_ecm_frame (byte fn, byte size)
{
	byte data;
  byte rb = (G(c2p.dbf) & 0x1000) != 0;  // Convert reverse-bit order parameter to TRUE/FALSE

	G(io_crc) = 0xFFFF;					   /* Initialize CRC */

	load_dce_fifo (0x00FF | HDLC_START_OF_FRAME);  // Address
	io_compute_crc (0xFF);

	load_dce_fifo (0x03);        /* Control field */
	io_compute_crc (0x03);

	load_dce_fifo (0x06);        /* FCD - Facsimile Coded Data frame */
	io_compute_crc (0x06);

	load_dce_fifo (fn);          /* Frame number */
	io_compute_crc (fn);         /* Update frame number */

	do              
	{
		data = read_ecm_buf ();    // Read data byte from fragmented ECM buffer

		if (rb)                    // Reverse phase C bit order?
			data = rev_bits (data);  // Reveres data bits

		load_dce_fifo (data);      // Load data into DCE Tx buffer
		io_compute_crc (data);     // Compute CRC for this frame
	}
		while (size--);

#if defined(TEST_CTC_CTR) || defined(TEST_EOR_ERR)
	if (!bad_fcs && !G(ecm_pc) && !G(ecm_bc) && (fn == BAD_FRM_NUM) ) // Corrupt this frame's CRC?
		G(io_crc) = ~G(io_crc);                                         // Invert it
#endif

	G(io_crc) = ~G(io_crc);
	load_dce_fifo ((byte)  G(io_crc) );        // Low byte of FCS first
	load_dce_fifo ((byte) (G(io_crc) >> 8) );
	io_start_dce_transmit ();
}

// --------------------------------- //
// Write a word into the DCE Tx FIFO //
// --------------------------------- //

void load_dce_fifo (word val)
{
	*G(io_dce_tx_wptr) = val;  		               // Load word into FIFO

	if ( (G(io_dce_tx_wptr) + 1) >= G(io_dce_tx_eptr) ) // Last location in buffer? (Prevent ISR from seeing invalid pointer)
		G(io_dce_tx_wptr) = G(io_dce_tx_sptr);            // Wrap to beginning of buffer

	else                                                // Not last location
		G(io_dce_tx_wptr)++;                              // Point to next location
}

/* ----------------------------------------------------------- */
/* Exit ECM and Cause a DCN to be Sent to the Remote FAX Modem */
/* ----------------------------------------------------------- */

void ecm_dcn (void)
{
	if (I(io_dte_tx_rptr) != I(io_dte_tx_wptr))  // Wait for DTE Tx buffer to clear
	{
		if (x_elapsed_time (G(ecm_timer) < 700))
			return;
	}

	set_non_ecm ();

	if (G(ecm_stat) & HANG_UP)   // Just hang up?
		ecm_hang_up ();

	else                     // Send DCN, then hang up
		exit_state ();         // Located in iofax_c2.c
}

/* -------------------------------------------------------- */
/* ECM Response Received -- From T.30 Figure A-23 Flowchart */
/* -------------------------------------------------------- */
/* 0: No decision yet
	 1: Decision is "No"
	 2: Decision is "Yes"

	 Refer to T.30 flowchart A-23/T.30
*/

byte ecm_response_rx (void)
{
	byte decision = 0;        // Initialize to "No decision yet"

	switch ( io_fax_hdlc_dce_to_buf( G(io_fax_buf), &G(io_hdlc_byte_count) ) )
	{
		case TRUE:  // Valid frame received
			G(ecm_rsp_state) = 3;                     /* Check if DCN or CRP before leaving */
			break;

		case TRUE+1:  // FCS error
#ifdef V34_FAX
			if (G(x_fax_v34mode) != NON_V34)          // Using V.34 modulation?
			{
				G(ecm_rsp_state) = 0;  // Reset state machine
				return (1);            // Return a "NO" decision
			}

			else
#endif
				G(ecm_rsp_state) = 1;  // Wait until carrier is gone for 200 ms

			break;
	}

	switch (G(ecm_rsp_state))
	{
	 /*******/
		case 0:   /* Monitor T4 timer & look for HDLC flags */
	 /*******/
			if ( (dp_regread (DP_EIA_REGISTER) & 0x04)  /* Carrier detected? */
#ifdef V34_FAX
					 || (G(x_fax_v34mode) != NON_V34)          // Using V.34 modulation?
#endif
				 )
			{
				G(ecm_rsp_state)++;                      // Wait for response while carrier is on
				G(ecm_timer) = x_current_time ();        // Start 3 second timer
			}

			else if (x_elapsed_time (G(ecm_timer)) > 3000)  /* T4 timer expired? */
				decision = 1;   /* Respond with "No" */

			break;

	 /*******/
		case 1:   /* Monitor 3 second timer while signal is active */
	 /*******/
			if (x_elapsed_time (G(ecm_timer)) > 3000)  /* Three seconds expired? */
			{
				G(c2p.faxerr) = 50;         // Unspecified Phase D error
				G(ecm_state) = ECM_ORG9;    // Send DCN and hang up
			}

			else if (!(dp_regread (DP_EIA_REGISTER) & 0x04)   /* Carrier gone? */
#ifdef V34_FAX
					 && (G(x_fax_v34mode) == NON_V34)             // Not using V.34 modulation?
#endif
							)
			{
				G(ecm_rsp_state)++;                      // Check for 200 ms of carrier gone
				G(ecm_timer2) = x_current_time ();   // Start 200 ms timer; Don't reset 3 second timer (G(ecm_timer))
				reset_ecm_timer ();
			}

			break;

	 /*******/
		case 2:   /* Monitor 200 ms timer after signal goes away */
	 /*******/
			if (x_elapsed_time (G(ecm_timer2)) > 200)
				decision = 1;

			else if (dp_regread (DP_EIA_REGISTER) & 0x04)  /* Carrier acitve? */
				G(ecm_rsp_state)--;    // Continue waiting up to 3 seconds for a response

			break;

	 /*******/
		case 3:   /* Check if CRP response or DCN command */
	 /*******/
			switch (G(io_fax_buf[2]) & 0x00FE)
			{
				case DCN:                 // Disconnect
					G(c2p.faxerr) = 0;         // Normal and proper termination
					G(ecm_stat) = G(ecm_stat) | HANG_UP;      // Indicate just hang-up, don't send DCN
					G(ecm_state) = ECM_ORG9;   // Hang up and don't transmit DCN to remote fax
					break;

				case CRP:                 // Repeat command
					G(ecm_rsp_state) = 1;          // Wait until signal is gone for 200ms
					decision = proc_v34_fax_rsp ();    // Process V.34 Responses differently
					break;

				default:           // All other responses
					G(ecm_rsp_state)++;       // Wait for carrier to go away; Keep 3 second timer running (G(ecm_timer))
					decision = proc_v34_fax_rsp (); // Process V.34 Responses differently
			}

			break;

	 /*******/
		case 4:   // Wait for carrier to go away
	 /*******/
			if (!(dp_regread (DP_EIA_REGISTER) & 0x04))  // Carrier gone?
				decision = 2;                              // Return "Yes"

			else if (x_elapsed_time (G(ecm_timer)) > 3000)    // Carrier stuck on?
				G(ecm_rsp_state) = 1;                               // Cause DCN to be sent and disconnect

			break;

	 /********/
		default:
	 /********/
			chk_ecm_timeout ('T');
	}

	return (decision);
}

// ------------------------------------------------------ //
// Check if a Response was Received Using V.34 Modulation //
// ------------------------------------------------------ //

byte proc_v34_fax_rsp (void)
{
#ifdef V34_FAX
	if (G(x_fax_v34mode) != NON_V34)  // Using V.34 modulation?
	{
		G(ecm_rsp_state) = 0;
		return (2);     // Decision is "Yes"
	}
#endif

	return (0);       // No decision yet
}

/* ------------------------------------------------- */
/* Setup to receive a response from the remote modem */
/* ------------------------------------------------- */

void setup_rx_response (void)
{
#ifdef V34_FAX
	if (G(x_fax_v34mode) == NON_V34) // Not using V.34 modulation
#endif
		setup_hdlc_rx ();                // Setup pump to receive HDLC @ 300 bps

	reset_ecm_timer ();
	G(ecm_ss)++;                        // Next sub-state in calling function
	G(ecm_rsp_state) = 0;                   //
}

/* ------------------------------------------ */
/* Check for a response from the remote modem */
/* ------------------------------------------ */

void check_response (byte sub_state)
{
	byte i;

	i = ecm_response_rx ();  /* T.30 Response Received function */

	if (i)   /* Response or time-out? */
	{
#ifdef V34_FAX
		if (G(x_fax_v34mode) == NON_V34) // Not using V.34 modulation
#endif
			x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0);

		reset_ecm_timer ();

		if (i == 2)        /* "Yes" response? */
			G(ecm_ss)++;        /* Process response */

		else               // Time-out
		{
			if (--G(ecm_rsp_cnt))        // Haven't tried 3 times yet?
			{
				G(ecm_ss) = sub_state; // Set proper sub-state
				G(ecm_state)--;        // Send Post-Message Status again
			}

			else                  // Third attempt
			{
				G(c2p.faxerr) = 52;
				G(ecm_state) = ECM_ORG9;   /* Send DCN and hangup */
			}
		}
	}
}

/* ---------------------------------------------- */
/* Sequencer to manages responses to DTE commands */
/* ---------------------------------------------- */
/* The sequence of events/responses is as follows:
	 TRANSMIT:
	 0: First carrier detected after +FDT:     CONNECT   <XON>
	 1: Last block of a page sent after +FDT:  OK
	 2: MCF received after +FET=n:             +FPTS:n   OK

	 RECEIVE:
	 10: First carrier detected after +FDR:    CONNECT
	 11: Post-page status:                     +FPTS:n +FET=n, OK
*/

void dte_response_tx (byte type)
{
	if (type == 0xFF)       // Reset sequence for Tx?
		G(ecm_rsp_seq) = 0;

	else if (type == 0xEE)  // Reset sequence for Rx?
		G(ecm_rsp_seq) = 10;

	else if (type == G(ecm_rsp_seq))  // Next response in sequence?
	{
		switch (G(ecm_rsp_seq))
		{
		 /*******/
			case 0:   /* CONNECT and <XON> after +FDT */
		 /*******/
				send_mdm_stat (CONNECT);         // Send "CONNECT" to the DTE
		#if defined(IWF_FAX) || defined(CLASS20_FAX)
				if (G(c2p.fclass) == 2)
		#endif
					io_put_dte_tx_char (XON);      /* Signal DTE to send page data */

				G(ecm_rsp_seq) = (G(c2p.fclass) == 0x20) ? 2 : 1;  // Class 2.0 doesn't use +FET; skip next state if G(c2p.fclass) 2.0
				break;

		 /*******/
			case 1:   /* OK after last block sent, prompt DTE for +FET command */
		 /*******/
				send_mdm_stat (OK);                                 // Send "READY/OK" to DTE
				G(ecm_rsp_seq)++;
				break;

		 /*******/
			case 2:   /* +FPTS:n OK after MCF received */
		 /*******/
				G(c2p.fpts) = 1;                    /* Always MCF for now */

		#if defined(IWF_FAX) || defined(CLASS20_FAX)
				if (G(c2p.fclass) == 2)
		#endif
					send_fpts ();                 // Send +FPTS:n to DTE

				if (G(c2p.fet) <= 1)               // Not end of procedure?
					send_mdm_stat (OK);           // Send "READY/OK" to DTE

				G(ecm_rsp_seq)++;
				break;

			case 10:
				send_mdm_stat (CONNECT);         // Send "CONNECT" to the DTE
				G(ecm_rsp_seq)++;
				break;

			case 11:                           // Send +FPTS:n; +FET:n; "OK"
			{                 
				word buf[5];
				struct ECM_PPR *pp = (void *) &G(lapm_receive_frame);    // Pointer to frame bit maps

				buf[0] = G(c2p.fpts);
				buf[1] = pp->line_cnt;       // Number of lines received
				buf[2] = 0;
				buf[3] = 0;
				buf[4] = 0;
				load_rsp_fpts (buf);
				load_rsp_stat (FET, G(c2p.fet)); // Display +FET:n
				send_mdm_stat (OK);           // Send "READY/OK" to DTE
				G(ecm_rsp_seq)++;
				break;
			}

		 /********/
			default:    // Stay here until reset
		 /********/
				break;
		}
	}
}

// ---------------------------------- //
// Check if a state machine timed out //
// ---------------------------------- //

void chk_ecm_timeout (byte state)   
{
	if (x_elapsed_time (G(ecm_timer)) >= 5000)  // Over 5 seconds?
	{
#ifdef DISPLAY_TIMEOUT
		x_debug_msg("\nECM Time-out!");   // ***DEBUG***
		ddputs_nnl("state & substate: "); // ***DEBUG***
		sendDecByte(G(ecm_state));           // ***DEBUG***
		sendDumbChar (' ');               // ***DEBUG***
		sendDecByte(G(ecm_ss));              // ***DEBUG***
		x_debug_msg(" ");                 // ***DEBUG***
#endif

		G(ecm_stat) = G(ecm_stat) | HANG_UP;  // Just hang up; don't send/receive DCN

		if (state == 'T')               // ECM Tx?
			G(ecm_state) = ECM_ORG9;         // Exit state for ECM Tx

		else                            // ECM Rx
		{
			G(c2p.faxerr) = 100;
			G(ecm_state) = ECM_ANSX;         // Exit state for ECM Rx
		}

		reset_ecm_timer ();             // Reset the timer
	}
}

// ------------------------------------------------------------ //
// Reset the time-out timer used for various ECM state machines //
// ------------------------------------------------------------ //

void reset_ecm_timer (void)
{
	G(ecm_timer) = x_current_time ();  // Reset the timer
}

// ---------------------------------------- //
// Check if the DTE wants to abort the call //
//  --------------------------------------- //

void chk_ecm_abort (byte state)
{
	if (state == 'T')                       // ECM Tx?
	{
		if ( (G(ecm_stat) & END_PAGE) &&             // End of a page?
				 (I(io_dte_rx_rptr) != I(io_dte_rx_wptr)) ) // At least one character in DTE Rx buffer?
		{
#ifdef DISPLAY_ABORT
			x_debug_msg("\nECM Aborted!");    // ***DEBUG***
			ddputs_nnl("state & substate: "); // ***DEBUG***
			sendDecByte(G(ecm_state));           // ***DEBUG***
			sendDumbChar (' ');               // ***DEBUG***
			sendDecByte(G(ecm_ss));              // ***DEBUG***
			x_debug_msg(" ");                 // ***DEBUG***
#endif
			I(io_dte_rx_rptr) = I(io_dte_rx_wptr);        // Flush DTE Rx buffer
			G(c2p.faxerr) = 2;                         // Abort code
			G(ecm_state) = ECM_ORG9;                   // Exit state
		}
	}

	else  // ECM Rx
	{
		byte data;

		while (I(io_dte_rx_rptr) != I(io_dte_rx_wptr))
		{
			data = (byte) read_dte_fifo ();

			if ( (data != XON) && (data != XOFF) )    // Not S/W flow control
			{
#ifdef DISPLAY_ABORT
				x_debug_msg("\nECM Aborted!");    // ***DEBUG***
				ddputs_nnl("state & substate: "); // ***DEBUG***
				sendDecByte(G(ecm_state));           // ***DEBUG***
				sendDumbChar (' ');               // ***DEBUG***
				sendDecByte(G(ecm_ss));              // ***DEBUG***
				x_debug_msg(" ");                 // ***DEBUG***
#endif
				G(c2p.faxerr) = 2;                   // Abort code
				G(ecm_stat) = G(ecm_stat) | HANG_UP;    // Don't wait for DCN
				G(ecm_state) = ECM_ANSX;             // Set state machine to exit ECM Rx
				reset_ecm_timer ();
				break;
			}
		}
	}
}

// ****************************************************************************************
// *********************************** ECM RECEIVE FUNCTIONS ******************************
// ****************************************************************************************

// ------------------------------------ //
// Main background task for ECM receive //
// ------------------------------------ //

byte fax_ecm_rx (void)
{
	CALL(ecm_rx [G(ecm_state)]);         // Run current state machine
	return (G(ecm_stat) & ECM_ACTIVE);   // Return status of ECM
}

// ------------------------------------- //
// Initialization for FAX, ECM Reception //
// ------------------------------------- //

void ecm_rx_init (byte frm_size)  // frm_size -- 1: 64-byte frames; 0: 256-byte frames
{
	G(io_fax_buf) = (void *) &LRQ(0);                // Use this RAM for T.30 HDLC commands
#if defined(CS_4) || defined(ECM_64K_BUFF)
	G(ecm_stat) = G(ecm_stat) | ECM_ACTIVE | (frm_size == 0 ? FRM_256 : 0);   // Save negotiated frame size
#else
	G(ecm_stat) = ECM_ACTIVE | (frm_size == 0 ? FRM_256 : 0);   // Save negotiated frame size
#endif
  G(ecm_stat) = G(ecm_stat) | END_PAGE;     // Don't send DLE-ETX if DCN received before page data   
	G(ecm_state) = 0;      // Reset state variable
	G(ecm_ss) = 1;         // Set sub-state variable to wait for carrier detect
	G(c2p.fet) = 0;        // Cause init_rx_blk to clear DC2_RCVD and LOST_RTC flags
	init_ecm_buf (0);   // Initialize ECM buffer for receive
	init_rx_blk ();     // Initialize parameters to receive a block
	dte_at_cmd ();      // Clear DTE command register
	reset_ecm_timer (); // Reset time-out timer

#ifdef TEST_RR_RNR   // ***DEBUG***
	rr_cnt = 3;        // ***DEBUG***
#endif               // ***DEBUG***
}

// ---------------------------------------------- //
// Initialize variables to receive the next block //
// ---------------------------------------------- //

void init_rx_blk (void)
{
	struct ECM_PPR *pp = (void *)&G(lapm_receive_frame);    // Pointer to frame bit maps
	byte i;

	G(ecm_ppr_fc) = 0;               // Reset frame number to send to DTE
	G(ecm_ppr_cnt) = 0;              // Reset "attempt block" counter
	G(ecm_stat) = G(ecm_stat) & ~(FDR_RCVD | EOR_RCVD);  // Clear these flags between blocks
	G(c2p.fpts) = 1;             // Always "Good" for ECM

	if (G(c2p.fet) != 3)         // Not end of a partial page?
	{
		G(ecm_stat) = G(ecm_stat) & ~(DC2_RCVD | LOST_RTC); // Wait for <DC2> from host; Assume RTC will be received
		pp->dte_xfer = 0;       // Reset DCE-DTE transfer state variable
		dte_response_tx (0xEE); // Reset AT-response sequence for Rx
	}

	reset_ecm ();             // Reset the ECM receive buffer
	pp->rcp = 0;              // Reset consecutive RCP counter

	for (i = 0; i < 32; i++)  // For each frame's bit map...
	{
		pp->rcvd_frm[i] = 0xFF; // Set all frames as not received
		pp->bad_frm[i] = 0xFF;  // Set all frames as bad
	}
}

// ---------------------------------------------------- //
// Load a one-byte T.30 response into the DCE Tx buffer //
// ---------------------------------------------------- //

void send_t30_rsp (byte rsp)
{
	G(io_fax_buf[0]) = 0xFF;                 // HDLC address
	G(io_fax_buf[1]) = 0x13;                 // Control and final frame
	G(io_fax_buf[2]) = rsp | get_t30_bit (); // T.30 response and dynamic bit
	G(io_hdlc_byte_count) = 3;               // Number of bytes in message
	io_fax_hdlc_buf_to_dce( G(io_fax_buf), &G(io_hdlc_byte_count));
}

// -------------------------------------------- //
// Set the data pump to receive high-speed data //
// -------------------------------------------- //

void rx_pp_setup (void)
{
	switch (G(ecm_ss))
	{
 // ************************************************************************* //
		case 0:  // Setup modem to receive synchronous data, short train for V.17 //
		case 5:  // Use long train if using V.17                                  //
 // ************************************************************************* //
#ifdef V34_FAX
			if (G(x_fax_v34mode) != NON_V34)     // Using V.34 modulation?
			{
				if (!dp_read_dsp_ram (0x1FFF))  // Did not detect 1s?
				{
					chk_ecm_abort ('R');         // Check receive abort
					chk_ecm_timeout ('R');       // Check receive time-out
					break;                       // Wait until 1s detected
				}
			}
			else
#endif
			{
				G(ecm_fax_hdlc) = 1;                   // HDLC mode for ECM; idle char = 0x7E

				if (!G(ecm_ss))                    // Use short train?
					set_train (V17_SHORT_TRAIN);

				else                            // Use long train
					set_train (V17_LONG_TRAIN);
			}

			setup_sync_rx ();               // Turn on receiver
			G(ecm_ss) = 1;                     // Wait until modem is ready
			reset_ecm_timer ();
			break;

 // *********************************** //
		case 1:  // Wait for carrier detect //
 // *********************************** //
#ifdef V34_FAX
			if (G(x_fax_v34mode) == NON_V34)   // Not using V.34 modulation?
#endif
			{
				if (dp_read_dsp_ram (0x3B) & 0x0800)     // V.21 detected?
				{
					G(ecm_ss) = 0;                            // Reset sub-state variable
					get_ecm_rsp ();                        // Setup to receive HDLC command

					if (G(ecm_stat) & ECM_REPT)               // Remote DCE repeating an ECM command?
					{
						struct ECM_PPR *pp = (void *)&G(lapm_receive_frame);    // Pointer to frame bit maps

						pp->last_rsp = G(io_fax_buf[2]) & 0xFE;

						if ( (pp->last_rsp == CTR) || (pp->last_rsp == ERR) )  // CTR or ERR last sent?
							G(ecm_state) = ECM_ANS7;              // Receive CTC, EOR-nnn or CRP

						else  // MCF, PPR or RNR last sent
						{
							G(ecm_state) = ECM_ANS6;              // Receive PPS-nnn or CRP

							if (pp->last_rsp == PPR)           // Last sent PPR?
								G(ecm_ppr_cnt)--;                       // Retry count should remain the same after resent
						}
					}

					else   // Repeating TSI/DCS
					{
						G(ecm_stat) = G(ecm_stat) & ~ECM_ACTIVE;  // Clear active flag
						set_rx_dcs ();                      // Set G(c2p.fclass) 2/2.0 state machine to receive TSI/DCS
					}

					break;
				}
			}

			if (carrier_detected ())        // Phase C carrier present?
			{
				G(ecm_stat) = G(ecm_stat) | ECM_REPT; // Remote DCE repeats ECM commands from now on
				reset_ecm_timer ();
				reset_phcto ();      // Reset timer used in Class 2/2.0 background task
				dte_response_tx (10);         // Send "CONNECT" to host

				if (G(ecm_stat) & DC2_RCVD)      // Don't wait for <DC2>?
				{
					G(ecm_ss) = 0;                 // Receive ECM data frames
					G(ecm_state)++;
				}

				else
					G(ecm_ss) = 2;                // Wait for <DC2> from host
			}

			else                           // No carrier detected
			{
				chk_ecm_abort ('R');         // Check receive abort
				chk_ecm_timeout ('R');       // Check receive time-out
			}

			break;

 // ************************** //
		case 2:  // Wait for <DC2> //
 // ************************** //
			while (I(io_dte_rx_rptr) != I(io_dte_rx_wptr))
			{
				byte ch;

				ch = *I(io_dte_rx_rptr);                             // Get received character

				if ( (I(io_dte_rx_rptr) + 1) >= I(io_dte_rx_eptr) )  // Last location in buffer? (Prevent ISR from seeing invalid pointer)
					I(io_dte_rx_rptr) = I(io_dte_rx_sptr);             // Wrap around to beginning

				else                                                 // Not last location
					I(io_dte_rx_rptr)++;                               // Point to next location

				if (ch == 0x12)  // <DC2> from host?
				{
					G(ecm_stat) = G(ecm_stat) | DC2_RCVD;
					G(ecm_stat) = G(ecm_stat) & ~END_PAGE;  // Send DLE-ETX if DCN received
					reset_ecm_timer ();
					G(ecm_state)++;
					G(ecm_ss) = 0;
					break;
				}
			}

			chk_ecm_abort ('R');
			chk_ecm_timeout ('R');
			break;

 // ************************* //
		default: // Invalid value //
 // ************************* //
			G(ecm_ss) = 1;  // Wait for carrier or time-out
	}
}

// --------------------------- //
// Check if Carrier is Present //
// --------------------------- //

byte carrier_detected (void)
{
#ifdef V34_FAX
	if (G(x_fax_v34mode) != NON_V34)                   // Using V.34 modulation?
		return (fax_tx_rdy ());                       // V.34 channel ready?
	else
#endif
		return (dp_regread (DP_EIA_REGISTER) & 0x04); // Non-V.34 carrier present?
}

// ------------------------------------------ //
// Receive ECM Frames and Store in ECM Buffer //
// ------------------------------------------ //

void rx_ecm_frms (void)
{
	word cnt = io_get_dce_rx_count ();               // Number of bytes received
	word data;
	struct ECM_PPR *pp = (void *) &G(lapm_receive_frame);    // Pointer to frame bit maps

	if (cnt)               // Any data received from remote fax modem?
		reset_phcto ();      // Reset timer used in Class 2/2.0 background task

	while (cnt--)
	{
		data = *G(io_dce_rx_rptr);				                  // Read word

		if ( (G(io_dce_rx_rptr) + 1) >= G(io_dce_rx_eptr))  // Last location? (Prevent ISR from seeing invalid pointer)
			G(io_dce_rx_rptr) = G(io_dce_rx_sptr);            // Wrap to beginning

		else                                                // Not last location
    	G(io_dce_rx_rptr)++;                              // Point to next location

		switch (G(ecm_ss))
		{
	 // ************************************** //
			case 0: // Look for HDLC Start Address //
	 // ************************************** //
				if (data == (HDLC_START_OF_FRAME | 0xFF))
					G(ecm_ss) = 1;            // Look for control field

				break;

	 // ************************************** //
			case 1: // Look for HDLC Control Field //
	 // ************************************** //
				data = data & 0x00EF;     //  Mask upper bit info; convert to non-final frame

				if (data == 0x0003)       // Control field?
					G(ecm_ss) = 2;             // Get HDLC command

				else                      // Out of sync with frame
					G(ecm_ss) = 0;             // Look for start address again

				break;

	 // ******************************** //
			case 2: // Look for HDLC Command //
	 // ******************************** //
				if ((byte)data == 0x06)       // ECM frame?
				{
					pp->rcp = 0;          // Reset RCP count
					G(ecm_ss) = 3;           // Get frame number
				}

				else if ((byte)data == 0x86)  // RCP frame?
				{
					pp->rcp++;            // Increment RCP count

					if (pp->rcp == 3) // End of this block?
					{
#ifdef V34_FAX
						if (G(x_fax_v34mode) != NON_V34)  // Using V.34 modulation?
						{
							cnt = 0;                       // Exit while loop now
							G(ecm_ss) = 7;                    // Ignore data while waiting until 1s detected
							break;                         // Exit "case 2:"
						}
						else
#endif
						{
							G(ecm_state)++;         // Get post-message status
							G(ecm_ss) = 0;          // Reset sub-state variable
							return;              // Exit function now
						}
					}

					G(ecm_ss) = 0;
				}

				else                    // Invalid HDLC command during phase C
					G(ecm_ss) = 0;           // Look for start address again

				break;

	 // *********************************** //
			case 3: // Get the ECM Frame Number //
	 // *********************************** //
				G(ecm_fc) = (byte)data;             // Save frame number
				pp->idx = G(ecm_fc) / 8;            // Locate byte in PPR bit maps
				pp->mask = 1 << (G(ecm_fc) % 8);    // Locate bit in that byte

				if ((pp->rcvd_frm[pp->idx] | pp->bad_frm[pp->idx]) & pp->mask ) // New frame or resent bad frame?
				{
					pp->rcvd_frm[pp->idx] = pp->rcvd_frm[pp->idx] & ~pp->mask;    // Indicate frame was received

					if (set_ecm_wptr ())           // Point to storage for this frame; room for data?
						G(ecm_ss) = 4;                  // Save the ECM frame data

					else                           // Buffer is full and using 256-byte frames
						G(ecm_ss) = 6;                  // Dump the data
				}

				else                             // Frame already received in good condition; probably bad frame number
					G(ecm_ss) = 6;                    // Ignore this frame

				break;

	 // ********************************** //
			case 4: // Save the ECM Frame Data //
	 // ********************************** //
				write_ecm_buf ((byte)data);     // Store data in ECM buffer

				if (data >= HDLC_END_OF_FRAME)  // Last byte of frame received?
				{
					pp->frm_cnt++;                // Increment the number of data frames received

					if ( (data & HDLC_CRC_ERROR) != HDLC_CRC_ERROR) // Good frame?
						pp->bad_frm[pp->idx] = pp->bad_frm[pp->idx] & ~pp->mask;  // Indicate data frame was received okay

					else                                            // FCS error
						G(ecm_buf.rd_cnt) = G(ecm_buf.rd_cnt) - FRAME_SIZE; // Remove this frame from read count

					G(ecm_ss) = 0;          // Look for HDLC address
					send_to_dte ();      // Send "good" data to DTE
				}

				break;

	 // ************************************************* //
			case 6: // Dump Frame Data Because Buffer is Full //
	 // ************************************************* //
				if (data >= HDLC_END_OF_FRAME)    // Last byte of frame received?
					G(ecm_ss) = 0;                     // Look for HDLC address

				break;

#ifdef V34_FAX
	 // ************************************** //
			case 7: // Wait until V.34 1s Detected //
	 // ************************************** //
				cnt = 0;                         // Ignore all data after RCP
				break;
#endif

	 // **************************************************** //
			default: // State Variable Contains an Invalid Value //
	 // **************************************************** //
				G(ecm_ss) = 0;              // Look for HDLC address
		}
	}

#ifdef V34_FAX
	if (G(x_fax_v34mode) != NON_V34)  // Using V.34 modulation?
	{
		if ( (dp_read_dsp_ram (0x1FFF)) &&               // 1s detected?
				 (!io_get_dce_rx_count () || (G(ecm_ss) == 7)) ) // DCE Rx buffer empty or RCP received?
		{
			dp_write_dsp_ram (0x1FFF, 0);	// Clear detect 1s flag
			setup_hdlc_rx ();             // Switch to control channel
			G(ecm_state)++;                  // Get post-message status
			G(ecm_ss) = 0;                   // Reset sub-state variable
		}
	}
	else
#endif
	if (!(dp_regread (DP_EIA_REGISTER) & 0x04) &&  // Carrier gone?
			!io_get_dce_rx_count () )                  // DCE Rx buffer empty?
	{
		G(ecm_state)++;         // Get post-message status
		G(ecm_ss) = 0;          // Reset sub-state variable
	}

	chk_ecm_abort ('R');      // Check for application abort
	check_phcto ();           // Check for Phase C time-out
}

// ------------------------------------------------------ //
// Set the ECM Buffer Write Pointer based on Frame Number //
// ------------------------------------------------------ //
/*                                   64-Byte    256-Byte
		Fragment:            Size:       Frames:     Frames:
		symbol               2048        0 - 31        8
		right                4096       32 - 95       16
		child                4096       96 - 159      16
		parent               2048      160 - 191       8
		lapm_transmit_frame  2048      192 - 223       8
		io_dte_rx_buff       2048      224 - 255       8

		Implementation Note:  64-byte frames have absolute locations
		in the ECM buffer while the 64 most recent 256-byte frames are
		put in a "circular" ECM buffer relative to other frames received.
		If a 256-byte frame is received with errors, the buffer fills up
		and all other 256-byte frames are then ignored.

		In CS-4 applications, 256-byte frames can be received using either a 16K or 64K
		byte buffer.  If a 64K byte buffer is used, the frames have an absolute location.
		Otherwise, the most recent, good data is stored in the 16K ECM buffer using the circular
		buffer scheme explained above.
*/

byte set_ecm_wptr (void)
{
	byte result = 1;

#ifdef ECM_64K_BUFF  // Venus 2 Client
	word offset;

	offset = (word)G(ecm_fc) * (G(ecm_stat) & FRM_256 ? 256 : 64);  // Frame number * frame size
	G(ecm_buf.idx_wr) = (byte)(offset / 0x1000) + 0xBD;     // Locate 4K segment
	G(ecm_buf.wptr) = (byte*)((offset % 0x1000) + 0x3000);  // Location in that segment

#else  // CS-4 or Client, 16K Fragmented Buffer
	#ifdef CS_4
	if (G(ecm_stat) & ECM_64K)                                      // Using a 64K buffer?
		G(ecm_buf.wptr) = G(ecm_64k_buf) + (256L * (long)G(ecm_fc));  // Offset from beginning of buffer

	else
#endif
	if (G(ecm_stat) & FRM_256)              // Using 256-byte frames?
	{
		if ( (G(ecm_fc) - G(ecm_ppr_fc)) < 64)       // Is there a place in the ECM buffer for this frame?
		{
			byte frms = G(ecm_fc) - G(ecm_ppr_fc);     // Current frame relative to first frame in buffer (number of frames)
			byte empty;

			G(ecm_buf.idx_wr) = G(ecm_buf.idx_rd); // Set wptr to begining of fragmented, circular buffer
			G(ecm_buf.wptr) = WR_BASE (byte*) *(G(ecm_buf.sptr) + G(ecm_buf.idx_rd));  // Initially set to beginning of fragment
#ifndef CS_4
			G(ecm_buf.wptr) = G(ecm_buf.wptr) + ((G(ecm_buf.rptr) - G(ecm_buf.wptr)) & 0xFF00); // Move to beginning of current frame boundary
#else
			G(ecm_buf.wptr) = G(ecm_buf.wptr) + ((G(ecm_buf.rptr) - G(ecm_buf.wptr)) & 0xFFFFFF00); // Move to beginning of current frame boundary
#endif
			while (1)                        // Until current frame's location is found...
			{
				empty = (WR_BASE (byte*) *(G(ecm_buf.eptr) + G(ecm_buf.idx_wr)) - G(ecm_buf.wptr)) / 256; // Number of empty frame locations - 1

				if (frms > empty)              // Frame doesn't go in this fragment?
				{
					frms = frms - (empty + 1);   // Subtract empty frames from relative position
					G(ecm_buf.idx_wr)++;            // Index to next fragment in lists

					if (G(ecm_buf.idx_wr) > LAST_BUF_FRAG)      // End of list?
						G(ecm_buf.idx_wr) = 0;        // Wrap around to beginning

					G(ecm_buf.wptr) = WR_BASE (byte*) *(G(ecm_buf.sptr) + G(ecm_buf.idx_wr));  // Get beginning of next fragment
				}

				else  // Frame is stored in this fragment
				{
					G(ecm_buf.wptr) = G(ecm_buf.wptr) + (256 * frms); // Position pointer in fragment
					break;                                      // Exit while loop
				}
			}
		}

		else                     // Buffer is full
			result = 0;            // Cause calling function to dump data
	}

	else  // Using 64-byte frames
	{
		static const byte max_fn [] = {191, 223, 255};  // Highest frame number per fragment
		byte i;
		byte min_fn = 0;             // Lowest frame number per fragment

		for (i = 0; i < 3; i++)      // For each buffer fragment...
		{
			if (G(ecm_fc) <= max_fn[i])   // Is this frame stored in this fragment?
				break;                   // Correct fragment has been identified

			min_fn = max_fn[i] + 1;    // Lowest frame number stored in next fragment
		}

		G(ecm_buf.wptr) = WR_BASE (byte*) *(G(ecm_buf.sptr) + i);             // Get base address of buffer fragment
		G(ecm_buf.wptr) = G(ecm_buf.wptr) + (64 * (G(ecm_fc) - min_fn)); // Offset from base address based on frame number
	}
#endif  // ECM_64K_BUFF

	return (result);               // 0: Buffer full (256-byte frames only) 1: Pointer into ECM buffer set
}

// ----------------------- //
// Send "Good" Data to DTE //
// ----------------------- //

void send_to_dte (void)
{
	byte idx, mask;
	byte loop = 1;
	byte frms = G(ecm_stat) & FRM_256 ? 4 : 16;   // Limit data to DTE to 1K per function call
	struct ECM_PPR *pp = (void *) &G(lapm_receive_frame); // Pointer to frame bit maps & misc variables

	while (loop)
	{
		switch (pp->dte_xfer)
		{
	 // ************************************************ //
			case 0:  // Check if next frame is ready to send //
	 // ************************************************ //
				loop = 0;                              // In case any "if" statements are false

				if (G(ecm_buf.rd_cnt) == 0)               // Is the ECM buffer empty?
				{
					if ( (G(ecm_stat) & FRM_256) &&         // Using 256-byte frames?
							 (G(ecm_stat) & LOST_RTC) )         // EOR received at end of a page?
					{
						pp->dte_xfer = 3;                  // Send DLE-ETX now, RTC was probably lost
						loop = 1;                          // Set TRUE to loop around
					}
				}

				else                                   // ECM buffer is not empty
				{
					idx = G(ecm_ppr_fc) / 8;                    // Locate byte in bit map for current frame
					mask = 1 << (G(ecm_ppr_fc) % 8);            // Locate bit in byte for current frame

					if (!(pp->rcvd_frm[idx] & mask))     // Has the frame been received yet?
					{
						if (!(pp->bad_frm[idx] & mask))    // Is the data error-free?
						{
							pp->dte_cnt = FRAME_SIZE - 1;    // Number of byte in a frame
							pp->dte_xfer = 1;                // Load frame data into DTE buffer
							loop = 1;                        // Set TRUE to loop around
						}
					}
				}

				break;

	 // *********************************** //
			case 1:  // Send frame data to host //
	 // *********************************** //
				loop = load_frm_data (pp);           // Load data into the io_dte_tx_buf[]; save DTE-not-full status
				frms--;                              // Decrement number of frames sent
				loop = loop && frms;                 // Terminate loop if DTE buffer full or frame limit reached
				break;

	 // ******************************************** //
			case 2:  // Flush "zero padding" from buffer //
	 // ******************************************** //
				while (G(ecm_buf.rd_cnt))
					read_ecm_buf ();

				pp->dte_xfer = 3;  // Send DLE-ETX

				break;

	 // ******************************** //
			case 3:  // Send DLE-ETX to host //
	 // ******************************** //
				if (io_get_dte_tx_count () >= 2)
				{
					write_dte_fifo (0x10);                 // Write DLE-ETX
					write_dte_fifo (0x03);
					G(ecm_stat) = G(ecm_stat) | END_PAGE;        // Indicte DLE-ETX sent
					pp->zeros = 0;                         // Reset EOL/RTC detection
					pp->eol = 0;
					pp->dte_xfer = 4;                      // Set to idle
				}

			//  *** FALL THROUGH ***

	 // ************************************************************* //
			case 4:  // Wait until reception of next block is initialized //
	 // ************************************************************* //
				loop = 0;
				break;

	 // ************************* //
			default: // Invalid value //
	 // ************************* //
				pp->dte_xfer = 0;  // Check for frame to send to DTE
		}
	}
}

// ------------------------------------------ //
// Load ECM frame data into the DTE Tx Buffer //
// ------------------------------------------ //

byte load_frm_data (struct ECM_PPR *pp)
{
	byte data, m;                        // Variables used to search for EOLs
	word room = io_get_dte_tx_count ();  // Empty locations in io_dte_tx_buf[]
#ifdef IWF_FAX
	byte rb = (G(c2p.dbf) & 0x1000) != 0;   // Reverse bit order status (According to spec)
#else
	byte rb = !(G(c2p.dbf) & 0x1000);       // Reverse bit order status (Industry implementation)
#endif
	byte zeros = pp->zeros;              // Number of consecutive '0' bits (Faster access as local variable)
	byte eol = pp->eol;                  // Number of consecutive EOLs found in data (Faster access ...)
	byte dte_cnt = pp->dte_cnt;          // Number of byte in current frame to send to DTE (Faster access...)
	byte df = G(c2p.fdcs.ps.df);            // Results of negotiated 2D encoding 

	while (room >= 2)            // Room for, at minimum, one DLE-DLE expansion?
	{
		data = (byte)read_ecm_buf ();  // Get byte from ECM frame

#ifdef CLASS20_FAX
		if (G(c2p.fdcs.ps.jp))    // Color negotiated?
		{
			byte temp = data;

			if (rb)                    // Reverse bit order?
				data = rev_bits (data);  // Reverse bit order

			if (data == 0x10)          // DLE pattern?
			{
				write_dte_fifo (data);   // Expand to DLE-DLE
				room--;
			}

			write_dte_fifo (data);     // Load data into DTE buffer
			room--;

			if ( (eol == 0xFF) && (data == 0xD9) )  // End of image (EOI)?
			{
				pp->dte_xfer = 2;                 // Set state to flush ECM buffer
				break;                            // Exit while loop
			}

			eol = temp;
		}

		else
#endif
		{
			for (m = 1; m; m = m << 1)// For each bit in data byte... (Looking for EOLs)
			{
				if (data & m)           // Bit is a '1'?
				{
					if (zeros >= 11)      // Preceeded by at least 11 '0's? (EOL detected?)
					{
						eol++;              // Increment consecutive EOL count
						pp->line_cnt++;     // Increment total line count
					}

					else
						eol = df && !zeros ? eol : 0;  // Don't reset after EOL+1 if using 2D encoding

					zeros = 0;            // Reset consecutive zero count
				}

				else                    // Bit is a '0'
					zeros++;              // Increment consecutive '0's count
			}

			if (zeros > 11)           // Waiting for first '1'?
				zeros = 11;             // Prevent count rollover

			if ((eol < 2) || (G(c2p.fclass) != 2)) // Continue sending frame data to DTE
			{
				if (rb)                    // Reverse bit order?
					data = rev_bits (data);  // Reverse bit order

				if (data == 0x10)          // DLE pattern?
				{
					write_dte_fifo (data);   // Expand to DLE-DLE
					room--;
				}

				write_dte_fifo (data);     // Load data into DTE buffer
				room--;

				if ( (eol >= 6) ||                    // Stop AFTER 6 consecutive EOLs for Class 2.0?
						 ( (df == 3) && (eol == 2) ) )    // Stop AFTER 2 consecutive EOLs for Class 2.0 MMR?
				{
					pp->dte_xfer = 2;                 // Set state to flush ECM buffer
					break;                            // Exit while loop
				}
			}

			else if ( (eol >= 6) ||                  // Stop AFTER 6 consecutive  EOLs for Class 2 (only send 2 EOLs to host)
								( (df == 3) && (eol == 2) ) )  // Stop AFTER 2 consecutive EOLs for Class 2 MMR?
			{
				pp->dte_xfer = 2;  // Set state to flush ECM buffer
				break;             // Exit while loop
			}
		}

		if (!dte_cnt--) // End of this frame's data?
		{
			G(ecm_ppr_fc)++;          // Point to next frame
			pp->dte_xfer = 0;  // Check if next frame is ready to send
			break;             // Exit while loop
		}
	}

	pp->dte_cnt = dte_cnt; // Save number of bytes in frame to send to DTE
	pp->zeros = zeros;     // Save number of consecutive '0's
	pp->eol = eol;         // Save number of consecutive EOLs
	return (room > 2);
}

// --------------------------- //
// Get the Post-Message Status //
// --------------------------- //
// Refer to flowchart A-22/T.30.

void get_ecm_rsp (void)
{
	send_to_dte ();       // Send "good" data to DTE

	switch (G(ecm_ss))
	{
 // ************************************* //
		case 0: // Setup pump to receive HDLC //
 // ************************************* //
			setup_rx_response ();             // Setup to receive HDLC; increment variable: G(ecm_ss)
			G(ecm_timer2) = x_current_time ();   // Start T2 timer
			break;

 // ********************************************* //
		case 1: // Wait for HDLC flags or T2 Time-out //
 // ********************************************* //
			if (carrier_detected ())
			{
				G(ecm_timer2) = x_current_time ();    // Restart T2 timer
				G(ecm_ss)++;                          // Receive an HDLC frame
			}

			break;

 // ************************************************ //
		case 2: // Wait for an HDLC Frame to be Received //
 // ************************************************ //
			if(io_fax_hdlc_dce_to_buf( G(io_fax_buf), &G(io_hdlc_byte_count)) == TRUE )
			{
				byte cmd;

				remove_dle_dle (G(io_fax_buf));       // Remove DLE-DLE expansion
				cmd = (byte)G(io_fax_buf[2]) & 0xFE;  // Save command received

				if (cmd == DCN)                              // Remote sent DCN?
				{
					G(ecm_stat) = G(ecm_stat) | HANG_UP;             // Don't wait for DCN again
					G(ecm_state) = ECM_ANSX;                      // Set state machine to exit ECM Rx
					G(ecm_ss) = 0;
					G(c2p.faxerr) = 100;                          // Unspecified Phase D error
          reset_ecm_timer ();
				}

				else if (cmd == CRP)                         // Repeat last response?
				{
					struct ECM_PPR *pp = (void *) &G(lapm_receive_frame);    // Pointer to frame bit maps

					switch (pp->last_rsp)
					{
						case PPR:
							G(ecm_ss) = 0;
							G(ecm_state) = ECM_ANS2;
							break;

						case CTR:
							G(ecm_ss) = 1;
							G(ecm_state) = ECM_ANS5;
							break;

						case ERR:
							G(ecm_ss) = 5;
							G(ecm_state) = ECM_ANS5;
							break;

						case RNR_FAX:
						case MCF:
						default:
							G(ecm_ss) = 0;
							G(ecm_state) = ECM_ANS4;
					}
				}

				else                                         // PPS-<nnn> command
					G(ecm_ss) = 4;              // Wait until carrier is gone
			}

			else if ( !(dp_regread (DP_EIA_REGISTER) & 0x04)    // Carrier gone?
#ifdef V34_FAX
								&& (G(x_fax_v34mode) == NON_V34)
#endif
							)
			{
				reset_ecm_timer ();  // Start 200ms timer
				G(ecm_ss) = 3;          // Wait for timer to expire
			}

			break;

 // ********************************************* //
		case 3:  // Wait 200 ms for Carrier to Return //
 // ********************************************* //
			if (dp_regread (DP_EIA_REGISTER) & 0x04)  // Carrier present?
				G(ecm_ss) = 2;                             // Continue looking for HDLC frames

			else if (x_elapsed_time (G(ecm_timer)) > 200) // 200ms expired?
				G(ecm_ss) = 1;                              // Look for HDLC flags again

			break;

 // ***************************************************************** //
		case 4:  // Wait until the carrier is gone after command received //
 // ***************************************************************** //
			if (  !(dp_regread (DP_EIA_REGISTER) & 0x04)    // Carrier gone?
#ifdef V34_FAX
					|| (G(x_fax_v34mode) != NON_V34)             // Using V.34 modulation?
#endif
				 )
			{
				reset_ecm_timer ();                        // Reset time-out timer
				G(ecm_state)++;                               // Process post-page status
				G(ecm_ss) = 0;
			}

			break;

 // **************************************************** //
		default: // State machine contains an invalid number //
 // **************************************************** //
			break;   // Wait for T2 to expire
	}

	if (x_elapsed_time (G(ecm_timer2)) > 6000)  // Timer T2 expired?
	{
		G(ecm_stat) = G(ecm_stat) | HANG_UP;         // Just hang up; don't receive DCN
		G(c2p.faxerr) = 100;                      // Unspecified Phase D error
		G(ecm_state) = ECM_ANSX;                  // Set state machine to exit ECM Rx
		G(ecm_ss) = 0;
    reset_ecm_timer ();
	}

//	chk_ecm_abort ('R');     // Check for Rx abort
}

// ------------------------------------------------- //
// Remove DLE-DLE Expansion from Received HDLC Frame //
// ------------------------------------------------- //

void remove_dle_dle (word* p)
{
	word *src  = p;
	word *dest = p;
	byte limit = 100;

	while (limit--)        // Until DLE-ETX encounted or limit reached...
	{
		if ((byte)*src == DLE)     // Pointing to first part of DLE-DLE or DLE-ETX pair?
		{
			src++;             // Point to second part of pair

			if ((byte)*src == DLE)   // DLE-DLE pair?
				*dest = *src;    // Save only one DLE

			else               // Assume it must be DLE-ETX
				break;           // Stop un-filtering DCE message
		}

		else                 // Not DLE pair
			*dest = *src;      // Shift bytes as necessary

		dest++;              // Next destination location
		src++;               // Next source location
	}
}

// ------------------------------- //
// Process the post-message status //
// ------------------------------- //

void process_pps (void)
{
	byte i, bad;
	struct ECM_PPR *pp = (void *)&G(lapm_receive_frame);    // Pointer to frame bit maps

	if ((((byte)G(io_fax_buf[2]) & 0xFE) == CTC) ||  // Did Tel"bug"ra foolishly send a CTC at wrong time? (See OVER-505)
			(((byte)G(io_fax_buf[2]) & 0xFE) == EOR) )   // Even dumber, did they send a EOR at the wrong time? (See OVER-507)
	{
		G(ecm_state) = ECM_ANS5;                   // Respond with CTR/ERR -- Because GOD (i.e. Telegra) said so!
		G(ecm_ss) = 0;
		return;
	}

	if ( ((byte)G(io_fax_buf[2]) & 0xFE) != PPS)   // Invalid response?
	{
		G(ecm_state) = ECM_ANS6;                     // Ignore, wait for another response
		G(ecm_ss) = 0;
		return;
	}

	set_fet ();                 // Save post-message response
	bad = 0;                    // Assume no frames are bad
	pp->frm_cnt--;              // Number of frames received - 1

	for (i = 0; i < 32; i++)    // For each frame bit map...
		bad = bad | (pp->rcvd_frm[i] ^ pp->bad_frm[i]);  // Check if received frames were bad

	if (bad || ((byte)G(io_fax_buf[6]) > pp->frm_cnt))  // Bad or missing frames?
	{
		G(ecm_ss) = 0;
		G(ecm_state) = ECM_ANS2;           // Send PPR to remote modem
	}

	else     // All received frames are error-free
	{
		G(ecm_state)++;              // Send MCF
		G(ecm_ss) = 0;
	}

	pp->frm_cnt = 0;            // Reset number of frames received
	reset_ecm_timer ();         // Reset time-out timer
}

// --------------------------------------------------- //
// Send Message-Confirmation Response to Calling Modem //
// --------------------------------------------------- //

void send_mcf_rsp (void)
{
	send_to_dte ();                     // Send "good" data to DTE

	switch (G(ecm_ss))
	{
 // ****************************** //
		case 0: // Set pump to Tx HDLC //
 // ****************************** //
#ifdef V34_FAX
			if (G(x_fax_v34mode) != NON_V34)   // Using V.34 modulation?
			{
				dte_end_of_page ();           // Interaction with host at end of page

				if (x_elapsed_time (G(ecm_timer)) < 75)  // Allow some time to send data to DTE before MCF
					break;                              // Keep waiting
			}
			else
#endif
				setup_hdlc_tx ();    // Setup to transmit T.30 command

			G(ecm_ss)++;            // Load MCF into buffer
			reset_ecm_timer ();
			break;

 // ****************************************** //
		case 1: // Wait until transmitter is ready //
 // ****************************************** //
			if (fax_tx_rdy ())              // HDLC flags sent?
			{
				if (rx_ready ())              // Receiver ready for next block?
				{
					send_t30_rsp (MCF);
					init_rx_blk ();             // Initialize ECM buffer for next block
					reset_ecm_timer ();         // Reset time-out timer
					G(ecm_ss) = 2;                 // Wait until message is sent
				}

				else                          // Not ready for next block
				{
					G(ecm_state) = ECM_ANS3;       // Send RNR to remote modem
					G(ecm_ss) = 0;
				}
			}

			else
				dte_end_of_page ();           // Interaction with host at end of page

			break;

 // *********************************** //
		case 2: // Wait for buffer to empty //
 // *********************************** //
			if (io_dce_tx_fifo_empty ())        // Has all data been sent?
			{
#ifdef V34_FAX
				if (G(x_fax_v34mode) == NON_V34)  // Not using V.34 modulation?
#endif
					x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0);

				reset_ecm_timer ();
				next_rx_state ();      // Set next state based on received PPM
				G(ecm_ss) = 0;
			}

			break;

 // *************************************************** //
		default: // State machine contains an invalid state //
 // *************************************************** //
			;   // Just time-out
	}

	chk_ecm_timeout ('R');
}

// ---------------------------------------------- //
// Set next receive state after the end of a page //
// ---------------------------------------------- //

void next_rx_state (void)
{
	if ( !G(c2p.fet) || (G(c2p.fet) == 3) )     // PPS-NULL or MPS?
		G(ecm_state) = ECM_ANS1;

	else if (G(c2p.fet) == 1)                // PPS-EOM?
	{
		goto_phase_b ();                    // Re-negotiate parameters
		set_non_ecm ();
	}

	else                                  // PPS-EOP
	{
		G(c2p.faxerr) = 0;
		G(ecm_state) = ECM_ANSX;               // Exit ECM
	}
}

// ------------------------------------ //
// Interaction with host at end of page //
// ------------------------------------ //

void dte_end_of_page (void)
{
	byte cmd;

	if ( (G(c2p.fet) != 3) &&        // Not end of partial page? (End of page?)
			 !(G(ecm_stat) & FDR_RCVD) ) // MCF hasn't been released?
	{
		if (!G(ecm_buf.rd_cnt))        // Buffer empty?
		{
			struct ECM_PPR *pp = (void *) &G(lapm_receive_frame);    // Pointer to line count

			dte_response_tx (11);  // Send +FPTS:n, +FET:n and "OK" to DTE
			pp->line_cnt = 0;      // Reset line count
		}

		chk_at_cmd ();           // Do AT-command processing
		cmd = dte_at_cmd ();     // Check if an AT+F command was issued

		if (cmd == DTE_FDR)      // Release MCF?
			G(ecm_stat) = G(ecm_stat) | FDR_RCVD;  // Indicate MCF can be sent

		else if (cmd == DTE_FK)  // Host abort?
		{
			G(c2p.faxerr) = 2;        // Set hang-up code
			G(ecm_state) = ECM_ANSX; // Disconnect
			reset_ecm_timer ();
		}
	}
}

// ------------------------------------------------- //
// Check if the receiver is ready for the next block //
// ------------------------------------------------- //

byte rx_ready (void)
{
#ifdef TEST_RR_RNR // ***DEBUG***
	if (rr_cnt)      // ***DEBUG***
		return (0);    // ***DEBUG***

	else             // ***DEBUG***
		rr_cnt = 3;    // ***DEBUG***
#endif             // ***DEBUG***

	if ( !G(ecm_buf.rd_cnt) &&           // All data sent to DTE?
				( (G(c2p.fet) == 3) ||         // End of partial page?
					(G(ecm_stat) & FDR_RCVD) ) ) // MCF released at end of page?
		return (1);                     // Receiver is ready

	else
		return (0);                     // Receiver is not ready
}


// ------------------------------------------ //
// Send a Partial-Page Report to Remote Modem //
// ------------------------------------------ //

void send_ppr_rsp  (void)
{
	send_to_dte ();       // Send "good" data to DTE

	switch (G(ecm_ss))
	{
 // ****************************** //
		case 0: // Set pump to Tx HDLC //
 // ****************************** //
#ifdef V34_FAX
			if (G(x_fax_v34mode) == NON_V34)  // Not using V.34 modulation?
#endif
				setup_hdlc_tx ();    // Setup to transmit T.30 command

			G(ecm_ss) = 1;          // Load MCF into buffer
			reset_ecm_timer ();
			break;

 // **************************** //
		case 1: // Send PPR response //
 // **************************** //
			if (fax_tx_rdy ())
			{
				byte i, bad;
				struct ECM_PPR *pp = (void *) &G(lapm_receive_frame);    // Pointer to frame bit maps

				G(io_fax_buf[0]) = 0xFF;   // HDLC address
				G(io_fax_buf[1]) = 0x13;   // Control and final frame
				G(io_fax_buf[2]) = PPR | get_t30_bit ();  // Partial-page report

				for (i = 0, bad = 3; i < 32; i++)      // For each frame bit map...
					G(io_fax_buf[bad++]) = pp->bad_frm[i];  // Load into PPR command

				G(io_hdlc_byte_count) = bad;     // Number of bytes in message
				io_fax_hdlc_buf_to_dce( G(io_fax_buf), &G(io_hdlc_byte_count));

				G(ecm_ppr_cnt)++;                    // Increment number of consecutive PPR commands sent
				G(ecm_ss) = 2;
			}

			break;

 // *********************************** //
		case 2: // Wait for buffer to empty //
 // *********************************** //
			if (io_dce_tx_fifo_empty ())        // Has all data been sent?
			{
#ifdef V34_FAX
			if (G(x_fax_v34mode) == NON_V34)  // Not using V.34 modulation?
#endif
					x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0);

				reset_ecm_timer ();
				G(ecm_ss) = 0;

				if (!(G(ecm_ppr_cnt) % 4))           // End of an "attempt block?"
					G(ecm_state)++;                // Wait for CTC or EOR response

				else
					G(ecm_state) = ECM_ANS1;       // Get retransmitted frames
			}

			break;

 // ************************************************** //
		default:  // State machine set to an invalid state //
 // ************************************************** //
			;        // Wait for time-out
	}

	chk_ecm_timeout ('R');
	chk_ecm_abort ('R');     // Check for Rx abort
}

// ------------------------------------------ //
// Send a CTR or ERR Response to Remote Modem //
// ------------------------------------------ //

void send_ctr_err (void)
{
	send_to_dte ();       // Send "good" data to DTE

	switch (G(ecm_ss))
	{
 // ************************************ //
		case 0: // Check for a valid command //
 // ************************************ //
			if ( ((byte)G(io_fax_buf[2]) & 0xFE) == CTC)       // Transmitter will continue to correct?
			{
				set_ctc_rate ((byte)G(io_fax_buf[4]));  // Set new bit rate value (BR)
				G(ecm_ss) = 1;                          // State sequence for CTC
			}

			else if ( ((byte)G(io_fax_buf[2]) & 0xFE) == EOR)  // Transmitter gave up re-transmitting?
			{
				byte i, bad;
				struct ECM_PPR *pp = (void *) &G(lapm_receive_frame);    // Pointer to frame bit maps

				for (i = 0; i < 32; i++)                                 // For all bits in bit map...
				{
					bad = pp->bad_frm[i] ^ pp->rcvd_frm[i];             // Flag bad frames

					if (bad)                                            // Any bad frames in this group?
					{
						byte m;

						for (m = 1; m; m = m << 1)                        // For each frame in this group...
						{
							if (m & bad)                                    // Is this frame bad?
							{
								G(ecm_buf.rd_cnt) = G(ecm_buf.rd_cnt) + FRAME_SIZE; // Add back into read count
								pp->bad_frm[i] = pp->bad_frm[i] & ~m;         // Clear "bad" flag
	#if defined(CS_4) || defined(ECM_64K_BUFF)
								if (G(ecm_stat) & ECM_64K)  // Using 64K buffer?
									;                         // Skip checking count

								else
	#endif
								if (G(ecm_buf.rd_cnt) > 0x3FFF)  // Buffer full
								{
									i = 32;                     // Exit outside "for" loop
									break;                      // Exit inside "for" loop
								}
							}
						}
					}

					else
						pp->bad_frm[i] = pp->rcvd_frm[i] & pp->bad_frm[i];  // Clear error flag for all received frames
				}

				G(ecm_stat) = G(ecm_stat) | EOR_RCVD;  // Indicate an EOR was received for RNR/RR
				set_fet ();                      // Set +FET parameter based on FIF2 value
	#if defined(CS_4) || defined(ECM_64K_BUFF)
				if (G(ecm_stat) & ECM_64K)  // Using 64K buffer?
					;                         // Skip checking count

				else
	#endif
				if ( (G(c2p.fet) != 3) && G(ecm_buf.rd_cnt) > 0x3FFF)  // End of page and buffer is full?
					G(ecm_stat) = G(ecm_stat) | LOST_RTC; // Indicate RTC may have been lost

				G(ecm_ss) = 5;                      // State sequence for EOR
			}

			else  // Invalid command after an "attempt block"
			{
				G(ecm_ss) = 0;
				G(c2p.faxerr) = 102;
				G(ecm_stat) = G(ecm_stat) | HANG_UP;
				G(ecm_state) = ECM_ANSX;   // Disconnect
				reset_ecm_timer ();
			}

			break;

 // ******************************************** //
		case 1: // Set pump to Tx HDLC, CTC received //
		case 5: // Set pump to Tx HDLC, EOR received //
 // ******************************************** //
 #ifdef V34_FAX
			if (G(x_fax_v34mode) != NON_V34)   // Using V.34 modulation?
			{
				dte_end_of_page ();           // Interaction with host at end of page

				if (x_elapsed_time (G(ecm_timer)) < 75)  // Allow some time to send data to DTE before CTR/ERR
					break;                              // Keep waiting
			}
			else
#endif
				setup_hdlc_tx ();    // Setup to transmit T.30 command

			G(ecm_ss)++;            // Wait until HDLC flags are sent
			reset_ecm_timer ();
			break;

 // ************************************************ //
		case 2: // Send CTR in response to a CTC command //
 // ************************************************ //
			if (fax_tx_rdy ())                      // HDLC flags sent?
			{
				send_t30_rsp (CTR);
				G(ecm_ss) = 10;                          // Wait until message is sent, CTR state sequence
			}

			break;

 // ************************************************* //
		case 6: // Send ERR in response to an EOR command //
 // ************************************************* //
			if (fax_tx_rdy ())                       // HDLC flags sent?
			{
				if (rx_ready ())                       // Receiver ready for next block?
				{
					send_t30_rsp (ERR);
					init_rx_blk ();                      // Initialize ECM buffer for next block
					G(ecm_ss) = 11;                         // Wait until message is sent, ERR state sequence
				}

				else                                   // Receiver is not ready for next block
				{
					G(ecm_state) = ECM_ANS3;                // Send RNR
					G(ecm_ss) = 0;
				}
			}

			else
				dte_end_of_page ();                    // Interaction with host at end of page

			break;

 // ********************************************** //
		case 10: // Wait for buffer to empty, CTR sent //
		case 11: // Wait for buffer to empty, ERR sent //
 // ********************************************** //
			if (io_dce_tx_fifo_empty ())        // Has all data been sent?
			{
#ifdef V34_FAX
				if (G(x_fax_v34mode) == NON_V34)  // Not using V.34 modulation?
#endif
					x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0);

				reset_ecm_timer ();

				if (G(ecm_ss) == 10)          // Received a CTC command?
				{
					G(ecm_state) = ECM_ANS1;    // Continue to received re-transmitted frames
					G(ecm_ss) = 5;              // Use long train after CTR
				}

				else                       // Received an EOR command
				{
					next_rx_state ();        // Next state based on EOR-nnn received
					G(ecm_ss) = 0;
				}
			}

			break;

 // ************************************************ //
		default: // Invalid state for this state machine //
 // ************************************************ //
			;   // Wait for timeout
	}

	chk_ecm_timeout ('R');   // Check for time-out
}

// -------------------------------------------------------- //
// Set parameter +FET based on a PPS-nnn or EOR-nnn Command //
// -------------------------------------------------------- //

void set_fet (void)
{
	switch ((byte)G(io_fax_buf[3]))
	{
 // ************** //
		case PPS_NULL:
 // ************** //
			G(c2p.fet) = 3;
			break;

 // ***************** //
		case PPS_MPS:
		case PPS_PRI_MPS:
 // ***************** //
			G(c2p.fet) = 0;
			break;

 // ***************** //
		case PPS_EOM:
		case PPS_PRI_EOM:
 // ***************** //
			G(c2p.fet) = 1;
			break;

 // ***************** //
		case PPS_EOP:
		case PPS_PRI_EOP:
		default:          // Invalid command
 // ***************** //
			G(c2p.fet) = 2;  // Disconnect
	}
}

// ---------------------------------------- //
// Perform the RNR/RR Flow Control Sequence //
// ---------------------------------------- //

void send_rnr_rsp (void)
{
	switch (G(ecm_ss))
	{
 // ******************************************** //
		case 0: // Send RNR response to remote modem //
 // ******************************************** //
 #ifdef TEST_RR_RNR // ***DEBUG***
			rr_cnt--;     // ***DEBUG***
 #endif             // ***DEBUG***

			send_t30_rsp (RNR_FAX);     // Send T.30 RNR response (receiver not ready)
			reset_ecm_timer ();         // Restart time-out timer
			G(ecm_ss) = 1;              // Wait until message is sent
			break;

 // *********************************** //
		case 1: // Wait for buffer to empty //
 // *********************************** //
			if (io_dce_tx_fifo_empty ()) // Has all data been sent?
			{
#ifdef V34_FAX
				if (G(x_fax_v34mode) == NON_V34)  // Not using V.34 modulation?
#endif
					x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0);  // Turn off pump

				reset_ecm_timer ();        // Reset time-out timer
				G(ecm_ss) = 0;                // Get response to RNR
				G(ecm_state)++;
			}

			break;

 // ************************************************ //
		default: // State machine is in an invalid state //
 // ************************************************ //
			break;        // Wait for time-out
	}

	chk_ecm_timeout ('R');             // Check for time-out
//	chk_ecm_abort ('R');     // Check for Rx abort
}

// ------------------------------------------------- //
// Process the Response from Remote FAX Modem to RNR //
// ------------------------------------------------- //

void chk_rnr_rsp (void)
{
	G(ecm_ss) = 0;

	if ( ( ((byte)G(io_fax_buf[2]) & 0xFE) == PPS) ||  // Valid command during flow control?
			 ( ((byte)G(io_fax_buf[2]) & 0xFE) == RR_FAX)
		 )
	{
		G(ecm_state) = G(ecm_stat) & EOR_RCVD ? ECM_ANS5 : ECM_ANS4;     // Return to send ERR or MCF
		G(ecm_ss) = G(ecm_stat) & EOR_RCVD ? 5 : 0;                      // Sub-state for ERR or MCF
	}

	else                         // Invalid command for flow control
	{
		G(c2p.faxerr) = 102;               // COMREC -- Invalid command received
		G(ecm_stat) = G(ecm_stat) | HANG_UP;  // Just hang-up
		G(ecm_state) = ECM_ANSX;           // Disconnect
	}

	reset_ecm_timer ();          // Reset time-out timer
}

// ----------------------------------- //
// Set the modem for non-ECM operation //
// ----------------------------------- //

void set_non_ecm (void)
{
	restore_dte_buffers ();            // Restore DTE buffers for non-ECM
	G(ecm_stat) = G(ecm_stat) & ~ECM_ACTIVE; // Clear active flag
	G(io_fax_buf) = (word *) IO_FAX_BUF_START;                // Restore pointer for FAX HDLC frames
	I(io_dte_rx_wptr) = I(io_dte_rx_rptr);   // Flush DTE Rx buffer
	I(io_dte_tx_wptr) = I(io_dte_tx_rptr);   // Flush DTE Tx buffer
	reset_phcto ();                    // Reset timer used in Class 2/2.0 background task
}

// ------------------------------------------------------------- //
// Exit from ECM receive and return to class 2/2.0 state machine //
// ------------------------------------------------------------- //

void exit_ecm_rx (void)
{
	send_to_dte ();       // Send any remaining "good" data to DTE

	if (G(ecm_stat) & END_PAGE)             // Host not waiting for DLE-ETX?
	{
		if ( (I(io_dte_tx_wptr) == I(io_dte_tx_rptr) ) ||  // DTE Tx buffer empty?
				 (x_elapsed_time (G(ecm_timer)) > 6000) )      // Waited long enough?
		{
			set_non_ecm ();                    // Restore Non-ECM operation

			if (G(ecm_stat) & HANG_UP)            // Just hang up?
				ecm_hang_up ();

			else                               // Wait for DCN
				set_rx_dcn ();                   // Set non-ECM state machine to receive DCN
		}
	}

	else if (io_get_dte_tx_count () >= 2)    // Room for DLE-ETX?
	{
		write_dte_fifo (0x10);                 // Write DLE-ETX
		write_dte_fifo (0x03);
		G(ecm_stat) = G(ecm_stat) | END_PAGE;        // Exit ECM
	}

	else if (x_elapsed_time (G(ecm_timer)) > 500)  // Waited long enough?
		G(ecm_stat) = G(ecm_stat) | END_PAGE;           // Exit now
}

/* ******************************************************************** */
/* **************** ECM BUFFER RELATED FUNCTIONS ********************** */
/* ******************************************************************** */
/*
		Different versions of these functions are located at the beginning
		of this module and are used when 64K ECM buffer is used for Venus 2
		client.  They were moved to the beginning of the module so the
		linker will put them at the beginning of a bank.  For Venus 2, the
		bank 1 area is used to access the additional RAM.  The bank 1 area is
		mapped into the last 4K of the 12K bank 0 area.  Therefore, functions
		which access bank 1 must not be in the last 4K of bank 0.
*/
#ifndef ECM_64K_BUFF 
/* ----------------------------------------------- */
/* Write a byte into the fragmented 16K ECM buffer */
/* ----------------------------------------------- */

void write_ecm_buf (byte data)
{
	*G(ecm_buf.wptr)++ = data;  /* Store the data into the buffer */
	G(ecm_buf.count)++;         /* Add 1 to the byte total */
	G(ecm_buf.rd_cnt)++;        /* Add 1 to read count */

#ifdef CS_4  
	if (!(G(ecm_stat) & ECM_64K))  // Not using 64K ECM buffer?
#endif
	{
		if (G(ecm_buf.wptr) > WR_BASE (byte*) *(G(ecm_buf.eptr) + G(ecm_buf.idx_wr))) /* Past end of fragment? */
		{
			G(ecm_buf.idx_wr)++;      /* Index to next fragment in lists */

			if (G(ecm_buf.idx_wr) > LAST_BUF_FRAG)   /* End of list? */
				G(ecm_buf.idx_wr) = 0;     /* Wrap around to beginning */

			G(ecm_buf.wptr) = WR_BASE (byte*) *(G(ecm_buf.sptr) + G(ecm_buf.idx_wr));  /* Get beginning of next fragment */
		}
	}
}

/* ---------------------------------------------- */
/* Read a byte from the fragmented 16K ECM buffer */
/* ---------------------------------------------- */
/* Upper byte is 0x00XX if data is available */

word read_ecm_buf (void)
{
	byte data;

	if (G(ecm_buf.rd_cnt))           /* Any data in buffer? */
	{
		data = *G(ecm_buf.rptr)++;     /* Current byte to temporary storage */
		G(ecm_buf.rd_cnt)--;           /* Subtract 1 from the read count */

#ifdef CS_4 
		if (!(G(ecm_stat) & ECM_64K))  // Not using 64K ECM buffer?
#endif
		{
			if (G(ecm_buf.rptr) > RD_BASE (byte*) *(G(ecm_buf.eptr) + G(ecm_buf.idx_rd)))  /* Past end of fragment? */
			{
				G(ecm_buf.idx_rd)++;         /* Index to next fragment in list */

				if (G(ecm_buf.idx_rd) > LAST_BUF_FRAG)   /* End of list? */
					G(ecm_buf.idx_rd) = 0;     /* Wrap around to beginning */

				G(ecm_buf.rptr) = RD_BASE (byte*) *(G(ecm_buf.sptr) + G(ecm_buf.idx_rd));  /* Get beginning of next fragment */
			}
		}

		return ((word)data);
	}

	return (0x8000);              /* Indicate no data was read */
}

/* ------------------------------------------------ */
/* Initialize the structure used for the ECM buffer */
/* ------------------------------------------------ */

void init_ecm_buf (byte num)
{
#ifdef CS_4 
	if (G(ecm_stat) & ECM_64K)  // Using 64K buffer from heap?
	{
		I(io_dte_tx_wptr) = I(io_dte_tx_sptr);      // Flush & reset the DTE buffers
		I(io_dte_tx_rptr) = I(io_dte_tx_sptr);
		I(io_dte_rx_wptr) = I(io_dte_rx_sptr);
		I(io_dte_rx_rptr) = I(io_dte_rx_sptr);
	}
	else                        // Using fragmented 16K buffer
#endif
	{
	#ifndef CS_4
		disable_interrupt ();
	#else
		_int_disable();
	#endif

		if (num)    /* TRUE = Tx,  FALSE = Rx */
		{
			G(ecm_buf.sptr) = (byte**)sbuf_tx;
			G(ecm_buf.eptr) = (byte**)ebuf_tx;
			I(io_dte_tx_sptr) = BUFF(io_dte_tx_buff) + 2048;  /* Shrink DTE Tx buffer */
			I(io_dte_tx_wptr) = I(io_dte_tx_sptr);
			I(io_dte_tx_rptr) = I(io_dte_tx_sptr);
		}

		else
		{
			G(ecm_buf.sptr) = (byte**)sbuf_rx;
			G(ecm_buf.eptr) = (byte**)ebuf_rx;
			I(io_dte_rx_sptr) = BUFF(io_dte_rx_buff) + 2048;  /* Shrink DTE Rx buffer */
			I(io_dte_rx_wptr) = I(io_dte_rx_sptr);
			I(io_dte_rx_rptr) = I(io_dte_rx_sptr);
		}

	#ifndef CS_4
		enable_interrupt ();
	#else
		_int_enable();
	#endif
	}

	reset_ecm ();
}

/* ------------------------------------------- */
/* Reset the ECM buffer for the next 16K block */
/* ------------------------------------------- */

void reset_ecm (void)
{
	G(ecm_buf.idx_rd) = 0;
	G(ecm_buf.idx_wr) = 0;
	G(ecm_buf.count)  = 0;
	G(ecm_buf.rd_cnt) = 0;
#ifdef CS_4
	if (G(ecm_stat) & ECM_64K)  // Using a 64K buffer?
	{
		G(ecm_buf.rptr) = G(ecm_64k_buf);  // Set pointers to beginning of 64K buffer in heap
		G(ecm_buf.wptr) = G(ecm_64k_buf);
	}
	else
#endif
	{
		G(ecm_buf.rptr) = RD_BASE (byte*) *(G(ecm_buf.sptr) + G(ecm_buf.idx_rd));  /* Load beginning of 1st fragment */
		G(ecm_buf.wptr) = WR_BASE (byte*) *(G(ecm_buf.sptr) + G(ecm_buf.idx_wr));  /* Load beginning of 1st fragment */
	}
}
#endif   // ifndef ECM_64K_BUFF
// ----------------------------------------------- //
// Restore the DTE Buffers to their Original Sizes //
// ----------------------------------------------- //

void restore_dte_buffers (void)
{
#ifdef CS_4 
	if (G(ecm_stat) & ECM_64K)     // Using 64K buffer?
		_mem_free (G(ecm_64k_buf));  // Free allocated memory
#endif
	I(io_dte_tx_sptr) = BUFF(io_dte_tx_buff);   // Restore buffers to original size
	I(io_dte_rx_sptr) = BUFF(io_dte_rx_buff);
}

	#if defined(CS_4) || defined(ECM_64K_BUFF)
// ------------------------------------------------------------- //
// Allocate 64K bytes from heap for an ECM session, if available //
// ------------------------------------------------------------- //

byte use_64k_bufr (void)
{
	byte result = 0;                        // Default to 16K fragmented buffer

		#ifdef CS_4
			G(ecm_64k_buf) = (byte*)_mem_alloc (0x10000);  // Request 64K bytes from heap
			G(ecm_stat) = 0;                               // Clear all ECM status

			if (G(ecm_64k_buf) != 0)                // Is memory available?
			{
				G(ecm_stat) = G(ecm_stat) | ECM_64K;  // Indicate 64K buffer used
				result = 1;
			}

		#else
			G(ecm_stat) = ECM_64K;                         // Clear all ECM status; Indicate 64K buffer used
			result = 1;                                    // Indicate 64K ECM buffer used
		#endif   

	return (result);                        // Inform calling function which buffer is used
}

// ------------------------------------------------------------- //
// Free the 64K bytes from heap, if allocated but not negotiated //
// ------------------------------------------------------------- //

void dont_use_64k (void)
{
		#ifdef CS_4
			if (G(ecm_stat) & ECM_64K)     // Using 64K buffer?
				_mem_free (G(ecm_64k_buf));  // Free allocated memory
		#endif

			G(ecm_stat) = G(ecm_stat) & ~ECM_64K;  // Clear flag
}
	#endif // CS_4 || ECM_64K_BUFF

// ----------------------------------------- //
// Check if Fax Transmiter is Ready for Data //
// ----------------------------------------- //

byte fax_tx_rdy (void)
{
	return ( (G(c2s.flag) & CARRIER_DET) != 0);  // Transmitter-Ready status flag
}

// -------------------------------------------------------------------- //
// Read and Clear the Command Received from atfax_c2.c (AT+Fxx command) //
// -------------------------------------------------------------------- //

byte dte_at_cmd (void)
{
	byte cmd = G(c2s.dte_cmd);

	G(c2s.dte_cmd) = 0;  // Clear the command
	return (cmd);     // Return command received, if any
}
#endif   // FAX_ECM
