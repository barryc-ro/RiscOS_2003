/*name and version number:@(#)z80go.c	1.6*/
/*date of get: 		  12/15/00 10:10:36*/
/*date of delta:	  11/28/00 13:31:28*/
/* ----------------------------------------------------- */
/* Parse the llglob_d.h file and make up
 * a go.bat file that matches it for Z80
 */
#include <windows.h>
#include <winbase.h>
#include <winreg.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>


#define ZGO_VER	"2.2"
int nesting = 0;

/* parse the llglob_d.h file and produce go.bat
 * which calls makez80 ....
 */

/* All #defines are evaluated between #ifdef MODEM_Z80
 * and its #endif.
 */

struct lldef
{
	char *name;
	char *makez80;
	enum {
		LL_PLATFORM,
		LL_ROMRAM,
		LL_ROMFLASH,
		LL_LAST
	} defineType;	/* defines of this type are mutually exclusive */
};

char *commandLineStrings[LL_LAST];	/* This points to the strings
									 * that will eventually go
									 * on the makez80 command line
									 */
char flashRomString[8];

struct lldef lldefs[] =
{
	{ "EXT_MODEM",    "ser", LL_PLATFORM },
	{ "INT_MODEM",    " ",   LL_PLATFORM },
	{ "PCMCIA_MODEM", "pcm", LL_PLATFORM },
	{ "USB_MODEM",    "usb", LL_PLATFORM },

	{ "ROM",       "rom", LL_ROMRAM },
	{ "EMULATION", " ",   LL_ROMRAM },

	{ "ROM_FLASH", " ",   LL_ROMFLASH },
};

#define NUMDEFS	((sizeof lldefs) / (sizeof (struct lldef)))

int platform = 1;	/* index into lldefs of the platform found */

void errorFailure(char *msg)
{
	char title[50];
	
	fprintf(stderr, "%s\n", msg);
	remove("go.bat");
	sprintf(title, "ZGO ver %s - ERROR", ZGO_VER);
	MessageBox(NULL, msg, title, MB_ICONSTOP|MB_OK);
	exit(-1);
}

enum ATOM {
	A_IFDEF,
	A_ENDIF,
	A_DEFINE,
	A_EOF,
	A_OTHER
};

char inputLine[300];

// Get and parse the next line from the
// llglob_d.h file.
enum ATOM nextLine(FILE *f)
{
	if (feof(f))
		return A_EOF;

	fgets(inputLine, 299, f);

	if (inputLine == strstr(inputLine, "#endif"))
		return A_ENDIF;
	if (inputLine == strstr(inputLine, "#if"))
		return A_IFDEF;
	if (strstr(inputLine, "#define"))
		return A_DEFINE;

	return A_OTHER;
}

/* OK, we've found a define.  Take care of it. */
void processDefine()
{
	char *cp = inputLine;
	int len, i, totalLineLen;

	totalLineLen = strlen(inputLine);

	/* first skip leading whitespace then the characters '#define' */
	cp += strspn(cp, " \t");
	cp += 7;

	/* next skip whitespace after #define */
	cp += strspn(cp, " \t"); 

	/* find the length of the symbol */
	len = strcspn(cp, " \t\n/");

	cp[len] = 0;

	/* now see if cp is in our list of notable defines.
	 * if we're not in a nested situation.
	 */
	for (i=0; nesting < 2 && i<NUMDEFS; i++)
	{
		if (0 == strcmp(cp, lldefs[i].name))
		{
			int d = lldefs[i].defineType;

			if (commandLineStrings[d])
			{
				fprintf(stderr, "%s", cp);
				errorFailure(" conflicts with previous define");
				return;
			}

			if (LL_PLATFORM == d)
				platform = i;
			commandLineStrings[d] = lldefs[i].makez80;
			printf("   Found %s -> '%s'\n", cp, lldefs[i].makez80);
			return;
		}
	}

	if ((nesting < 3) && 0 == strcmp(cp, "ROM_FLASH"))
	{
		int sector;

		// special case of ROM_FLASH, we must get the value
		if (&inputLine[totalLineLen] == &cp[len])
		{
			fprintf(stderr, "%s", inputLine);
			errorFailure("ROM_FLASH must have value");
			return;
		}
		cp = &cp[len+1];
		
		sector = atoi(cp);
		if (!sector)
		{
			fprintf(stderr, "%s", inputLine);
			errorFailure("ROM_FLASH must have non-zero value");
			return;
		}
		printf("Found ROM_FLASH %d\n", sector);

		for (i=0; i<8; i++)
			flashRomString[i] = 0;
		sprintf(flashRomString, "%d", sector);
		commandLineStrings[LL_ROMFLASH] = &flashRomString[0];
	}
}

/* read the file until we come to a MATCHING endif.
 * if there are #if's of #ifdef's then we
 * nest correctly.
 * process defines appropriately.
 */
void readTilEndif(FILE *f)
{
	nesting++;

	while (1)
	{
		switch (nextLine(f))
		{
		case A_IFDEF:
			/* anther ifdef, now we read to its endif */
			readTilEndif(f);
		case A_OTHER:
			break;
		case A_DEFINE:
			processDefine();
			break;
		case A_EOF:
		case A_ENDIF:
			nesting--;
			return;
		}
	}
}


/* search through the file until we've read
 * the #ifdef MODEM_Z80 line
 */
int findModemZ80(FILE *f)
{
	int linesRead = 0;
	enum ATOM l = A_IFDEF;

	while(A_EOF != l)
	{
		l = nextLine(f);
		linesRead++;

		/* is this the right line */
		if (A_IFDEF == l && strstr(inputLine, "ifdef MODEM_Z80"))
			return 1;
	}

	fprintf(stderr, "%d lines read\n", linesRead);
	errorFailure("Didn't find #ifdef MODEM_Z80 in llglob_d.h");
	return 0;
}

// make the go.bat file containing 'makez80 ....'
void makez80()
{
	FILE *mFile = fopen("go.bat", "w");
	int er, i, j;
	char buf[100], sbuf[100];

	er = 0;
	strcpy(buf, "makez80");

	/* first check that all parameters were specified */
	for (i=0; i<LL_LAST; i++)
	{
		if (commandLineStrings[i])
		{
			strcat(buf, " ");
			strcat(buf, commandLineStrings[i]);
		}
		else
		{
			er = 1;
			fprintf(stderr, "Must specify one of\n");
			for (j=0; j<NUMDEFS; j++)
			{
				if (i == lldefs[j].defineType)
					fprintf(stderr, "\t%s\n", lldefs[j].name);
			}
		}
	}

	fprintf(mFile, buf);
	fprintf(mFile, "\n");
	fclose(mFile);

	sprintf(sbuf, "zgo %s   %s  ----- %s", ZGO_VER, lldefs[platform].name, buf);
	SetConsoleTitle(sbuf);

	if (er)
	{
		errorFailure("Missing define from llglob_d.h");
	}
}

// execute go.bat with either command.com or current shell
void tryCmd(void)
{
	OSVERSIONINFO os;
	char cmd[80];

	cmd[0] = 0;

	os.dwOSVersionInfoSize = sizeof(os);
	// see if this is Windows NT or other windows.
	if (GetVersionEx((LPOSVERSIONINFO) &os) &&
		(os.dwPlatformId & VER_PLATFORM_WIN32_NT))
	{
		strcpy(cmd, "go.bat");
	}
	else
	{
		// assume windows, try finding system root.
		HKEY key;
		DWORD regType;
		BYTE dir[200];
		DWORD dirSize = 200;

		if (ERROR_SUCCESS !=
			RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					 "Software\\Microsoft\\Windows\\CurrentVersion",
					 0,
					 KEY_READ,
					 &key))
		{
			printf("RegOpenKey fails\n");
		}

		// Try to find system root so we can give an explicit
		// path name for command.com.
		if (key && ERROR_SUCCESS ==
			RegQueryValueEx(key,
							"SystemRoot",
							NULL,
							&regType,
							(LPBYTE) dir,
							&dirSize))
		{
			if (dirSize < 30)
			{
				strcpy(cmd, (const char *) dir);
				strcat(cmd, (const char *) "\\");
			}
			else
			{
				printf("dirSize too big\n");
			}
		}
		else
		{
			printf("RegQueryValue fails.\n");
		}

		// I'll allocate environment space here so I don't get Out of
		// environment space errors.
		strcat(cmd, "command /e:1024 /c go.bat");
	}

	system(cmd);
}

void main()
{
	int i;

	FILE *lFile = fopen("llglob_d.h", "r");

	for (i=0; i<LL_LAST; i++)
		commandLineStrings[i] = NULL;

	commandLineStrings[LL_ROMFLASH] = &flashRomString[0];
	flashRomString[0] = ' ';
	flashRomString[1] = 0;

	if (!lFile)
	{
		errorFailure("Couldn't open file llglob_d.h");
		return;
	}

	printf("zgo - version %s - Processing llglob_d.h...\n", ZGO_VER);

	if (!findModemZ80(lFile))
		return;

	readTilEndif(lFile);

	fclose(lFile);

	makez80();

	printf("zgo - Done.\n");

	tryCmd();
}
