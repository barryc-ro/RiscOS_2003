/*name and version number:@(#)samdmtsk.c	1.31*/
/*date of get: 		  12/15/00 10:10:50*/
/*date of delta:	  11/30/00 16:59:41*/
/*****************************************************************************
** File        : samdmtsk.c                                                  *
** Version     : 1.0                                                         *
**---------------------------------------------------------------------------*
** Description : Strong ARM message queues tasks and command parser.         *
**                                                                           *
**     Function Name    | Access  | Summary                                  *
** ---------------------+---------+----------------------------------------- *
** sa_modem_task_cleanup
** sa_modem_task_init
** io_dte_rx_buff_avail 
** io_dte_tx_fifo_count 
** sa_scan_tx_dte_task 
** sa_modem_receive_msg 
** sa_modem_data_read_from_host 
** sa_modem_data_write_to_host 
** sa_modem_send_data
** sa_modem_send_fast_rate_change_msg
** sa_modem_send_msg
** sa_hmsg_dsp_read
** sa_hmsg_dsp_write
**                                                                           *
**---------------------------------------------------------------------------*
**                               HISTORY                                     *
**	072699				Initial					KDV							 *
**	122399				Ascend interface        JA                           *
**	012400				Event driven            JA                           *
**	032000				Add DSP read/write      JA                           *
**                                                                           *
******************************************************************************/


#include	"llglob_d.h"

#if defined( CS_4 )
# include	"iouart_d.h"
# include	"ioglob_d.h"
# include    "dpglob.h"
# include    "sa_glob.h"
# include    "sa_addr.h"
# include	"string.h"
# include	"pci.h"
# include	<mqx.h>
# include	<event.h>
# include	<stdlib.h>
# include	"v_task.h"
# include	"sa_mqx.h"
# include	"sa_host.h"
# include	"sa_dte_s.h"
# include	"sa_dte.h"
# include	"samdmtsk.h"
#endif

#include	"allglobs.h"

static void sa_modem_task_cleanup(void);
static word io_dte_tx_fifo_count ( void );

// Message queue functions
void
sa_modem_send_msg(SARM_MSG *smsg)
{
	// Send the given PCI message to the modem task command queue
	INTERNAL_MSG *msg = _msg_alloc(G(modem_msg_pool));
	if (msg == NULL) {
		host_print_msg("sa_modem_send_msg", &msg->host_msg);
		printf("sa_modem_send_msg: dp %d: msg_alloc failed, id=0x%x, errno=0x%x, msg: %08x %08x\n",
			   ModemNum, G(modem_msg_pool), _task_get_error(),
			   smsg->mh, smsg->ms0 );
		return;
	}

	// Init MQX header
	msg->mqx_hdr.TARGET_QID = G(modem_queue);
	msg->mqx_hdr.SIZE = sizeof(INTERNAL_MSG);

	// Load user section
	msg->host_msg.mh = smsg->mh;
	msg->host_msg.ms0 = smsg->ms0;

	uint_32 words_remaining = MSG_LEN(smsg->mh) - 2;
	if ( words_remaining > 0) {
		int *param_ptr = &msg->host_msg.ms1;
		int *smsg_ptr = &smsg->ms1;
		while ( words_remaining-- > 0 ) {
			*param_ptr++ = *smsg_ptr++;
		}
	}

	// host_print_msg("sa_modem_send_msg", &msg->host_msg);

	// And away it goes to the modem task
    // Give commands higher priority than media traffic
	if (_msgq_send_priority(msg,1) != TRUE) {
		printf("could not send modem command\n");
		if (_task_get_error() == MSGQ_INVALID_MESSAGE) {
			_msg_free(msg);
		}
	}
}

static uint_32 sa_dte_rx_threshold = 0xffff;	// 0xffff -> OFF

void
sa_modem_set_dte_rx_threshold( uint_16 val )
{
	sa_dte_rx_threshold = val;
	printf("Setting sa_dte_rx_threshold to %d\n", val);
}

void
sa_modem_data_read_from_host ( struct ChannelContext *vars )
{
	// Read bytes from host shared mem interface
	// Push bytes into internal DTE buff
	int taggedByte;
	byte *wptr = (byte *) I(io_dte_rx_wptr);
	byte *eptr = (byte *) I(io_dte_rx_eptr);
	while ( ( taggedByte = getDteByte(vars) ) >= 0 ) {
		*wptr = (byte) taggedByte ;
		if ( ++wptr >= eptr ) {
			wptr = (byte *) I(io_dte_rx_sptr) ;
		}
	}
	// May have valid byte along with negative ret code
	if ( ( taggedByte & GET_DTE_BYTE_RET_CODE_MASK ) != TRANSMIT_DATA_EXHAUSTED) {
		*wptr = (byte) taggedByte ;
		if ( ++wptr >= eptr ) {
			wptr = (byte *) I(io_dte_rx_sptr) ;
		}
	}
	I(io_dte_rx_wptr) = wptr;

	#if 0
	if ( sa_dte_rx_threshold < 0xfffe) {
		// Figure out byte count in DTE rx buffer
		byte *rptr = (byte *) I(io_dte_rx_rptr);
		uint_32 count;
		if ( wptr >= rptr )
			count =   wptr - rptr ;
		else
			count =  (I(io_dte_rx_eptr) - rptr) + (wptr - I(io_dte_rx_sptr)) ;

		// Wake up task if worth the trouble
		if ( count > sa_dte_rx_threshold
			 #if 0
			 ||  ( (G(v42bis_P0) & ENCODER) && G(v42bis_EnTransparent) ) // v42bis trans mode
			 || !(G(v42bis_P0) & ENCODER) // v42bis off
			 #endif
			) {
			// Wake up sa_modem task
			SARM_MSG msg;
			msg.mh = MSG_HEADER(MODEM_DATA_MSG, 2, ModemNum, 0 );
			msg.ms0 = 0;
			sa_modem_send_msg( &msg );
		}
	}
	#endif
}

void
sa_modem_data_write_to_host ()
{
	byte * rptr = ( byte * ) I(io_dte_tx_rptr);
	byte * eptr = ( byte * ) I(io_dte_tx_eptr);
	uint_16 count = io_dte_tx_fifo_count();

	if ( count == 0 ) {
		return;
	}

#if defined(SA_PCI_DMA)
	// Don't fill the Ascend DTE buffer more than once,
	// there is only one place to DMA out of.
	if ( count > DTE_BUFFER_LEN_BYTES ) {
		count = DTE_BUFFER_LEN_BYTES;
	}
#endif // SA_PCI_DMA

//	printf("write_to_host: %d bytes\n", count);
	struct ChannelContext * vars = &channelContext [ ModemNum ];

	while ( count-- > 0 ) {
		// sendDumbChar ( *rptr );

		// Push out next byte from circular buffer
		if ( putDteByte( vars, *rptr) != SUCCESS ) {
			return;
		}
		if ( ++rptr >= eptr )
			rptr = ( byte *) I(io_dte_tx_sptr);
	}

	I(io_dte_tx_rptr) = rptr;;

#if !defined(SA_MODEM_DEFERRED_FLUSH)
	// Force partial descriptor to go
	flushDteReceiveBuffer(vars); 
#endif	// SA_MODEM_DEFERRED_FLUSH

}

void
sa_modem_receive_msg ()
{
	// Block on message queue
	G(msg) = _msgq_receive( G(modem_queue), G(mqxTimeDelay) );
	INTERNAL_MSG *msg = G(msg);

	if ( msg == NULL) {
		uint_32 errno =_task_get_error();
		if ( errno == MSGQ_MESSAGE_NOT_AVAILABLE ) {
			// Timed out
			return;
		}
		else {
			printf("sa_modem_receive_msg: errno=0x%08x after _msgq_receive\n", errno );
			_mqx_exit(0);
		}
	}

	host_print_msg("sa_modem_receive_msg", &msg->host_msg);

	int msgNum = MSG_NUM(msg->host_msg.mh);
	int chanNum = MSG_CHAN(msg->host_msg.mh);

	switch ( msgNum ) {
	case MODEM_DATA_MSG:
		//if message is data,
		// no action, circ. buffer will be polled anyway
		break;

	case HMSG_OPEN_CHANNEL:
        int appType = MSG_OPEN_APP_TYPE( msg->host_msg.ms0 );
		if ( appType == VOIP ) {
			sa_switchDebugTerminal( ALLMODEMS ) ;
			// Requeue the msg for v_task to deal with
			// High priority ensures it will be read first
			_msgq_send_priority( msg, 10 );
			G(sa_data_polling_enabled) = FALSE;
			v_task_main( ModemNum );	// no return
			printf("\t\tsa_modem_receive_msg: v_task_main returned!!!\n");
			_mqx_exit(0);
		}
		else
		{
			// Let the sa_modem task go active
			become_data_call ( chanNum );

			// Send reply to host
			struct SarmMessage msgOut;
			msgOut.mh  = msg->host_msg.mh;
			msgOut.ms0 = SMSG_SUCCESS;  /* default return code */
			host_send_sarm_msg ( &msgOut );
		}
		break;

	case HMSG_CLOSE_CHANNEL:
		// just set the flag, sa_timeToRenew() does the rest
		#if defined(SA_CIRCULAR_BUFFER_HOST)
			// Circular buffer host might require soft reset
			if ( MSG_SEQ(msg->host_msg.ms0) != UNSOLICITED_SEQ_NUM
				 && G(sa_kill_me) == RUNNING ) {
				// Use soft reset to wind down with USR client in ST lab
				printf("Signal Hangup on Modem %d\n", chanNum);
				G(sa_kill_me) = SOFT_RESET;
			}   
			else
		#endif	// SA_CIRCULAR_BUFFER_HOST
			{
				printf("Signal final exit for modem %d\n", chanNum);

				// Tell host we are closing
				msg->host_msg.ms0 = SMSG_SUCCESS;
				host_send_sarm_msg ( &msg->host_msg );

				// Normal task respin
				G(sa_kill_me) = HARD_RESET;
			}
		break;

	case HMSG_READ_DSP_MEM:
		sa_hmsg_dsp_read( &msg->host_msg );
		break;

	case HMSG_WRITE_DSP_MEM:
		sa_hmsg_dsp_write( &msg->host_msg );
		break;

	default:
		// Unknown msg
		host_print_msg("sa_modem_receive_msg UNKNOWN", &msg->host_msg);
		break;

	}

	// Release message back to system pool
	_msg_free(msg);
	G(msg) = NULL;
}


/****************************************************************
Routine : sa_scan_tx_dte_task
//This routine should be called from the background task of each modem to 
//see if there is data that needs to be fed to PCI shared memory (RX) from
//the DTE TX fifo.
*****************************************************************/
void sa_scan_tx_dte_task (void)
{
	if ( I(io_dte_tx_rptr) != I(io_dte_tx_wptr) ) {
		// Tell to_host_task to send more data
		host_send_modem_data( MODEM_DATA_MSG, ModemNum, 0 );
		#if defined(SA_MODEM_DEFERRED_FLUSH)
		G(dte_flush_timer) = x_current_time();
		#endif	// SA_MODEM_DEFERRED_FLUSH
	}
#if defined(SA_MODEM_DEFERRED_FLUSH)
	else if ( x_elapsed_time( G(dte_flush_timer) ) > 40 ) {
		// No more data, tell to_host_task to flush partial desc
		host_send_modem_data( MODEM_FLUSH_MSG, ModemNum, 0 );
		G(dte_flush_timer) = x_current_time();
	}
#endif	// SA_MODEM_DEFERRED_FLUSH
}

/****************************************************************
Routine : io_dte_tx_fifo_count
Description :
	Calculates the number of bytes that need to be read from the DTE TX FIFO
Parameters in :
	none
Parameters out :
	count -	the number of bytes available to read
Revision History :
	Initials	Date		Change
*****************************************************************/
_Inline static
word io_dte_tx_fifo_count ( void )
{
	byte *rptr, *wptr ;
	// if on-line and RTS if off - flow control - do not transmit
	// data to the dte if hardware flow control is selected
#if 0
	if ( (G(x_modem_state) == MS_ON_DIAL) && (G(x_modem_mode) == MODEM_DATA)
	  && (G(io_at_esc_detect) == FALSE) &&
		(G(S).ModemOptions.V42 != V42_SYNC_BUFFERED )
		 )
	{
		 if ( ( G(S).ModemOptions.FlowControl == HW_FLOWCTRL ) &&
		 	  ( !(G(io_uart_status) & UART_RTS_ON) ) ) // if RTS off
			return ( 0 ) ;
		 else if ( ( G(S).ModemOptions.FlowControl == SW_FLOWCTRL ) &&
		 	  ( G(io_uart_status) & UART_XOFF_ON ) ) // if received xoff
			return ( 0 ) ;
	}
#endif

	rptr = (byte *) I(io_dte_tx_rptr);
	wptr = (byte *) I(io_dte_tx_wptr);
	if ( wptr >= rptr )
		return ( wptr - rptr ) ;
	else
		return ((I(io_dte_tx_eptr) - rptr) + (wptr - I(io_dte_tx_sptr))) ;
}

// Calculate the space available in the dte receive circular buffer
word
io_dte_rx_buff_avail ( void )
{
	byte *rptr = (byte *) I(io_dte_rx_rptr);
	byte *wptr = (byte *) I(io_dte_rx_wptr);

	if ( wptr >= rptr ) {
		return ( I(io_dte_rx_eptr) - I(io_dte_rx_sptr) ) -
				 ( wptr - rptr ) - 1;
	}
	else {
		return (rptr - wptr) - 1;
	}
}

void
sa_modem_task_init()
{
	// Set up exit handler to release resources when task dies
	_task_set_exit_handler(_task_get_id(), sa_modem_task_cleanup);

	// Transmit side resource init
	G(modem_msg_pool) = _msgpool_create(sizeof(INTERNAL_MSG), 4*DESC_PER_DP, 0, 0);
	if (G(modem_msg_pool) == MSGPOOL_NULL_POOL_ID) {
		// create failed
		printf("sa_modem_task_init: modem %d msgpool_create failed, errno=0x%x\n",
			ModemNum, _task_get_error());
		_mqx_exit(0);
	}

	// Msg queue used by others to send events
	G(modem_queue) = _msgq_open(MSGQ_FREE_QUEUE, 0);
	if (G(modem_queue) == 0) {
		// open failed
		printf("sa_modem_task_init: msgq_open failed, errno=0x%x\n", _task_get_error());
		_mqx_exit(0);
	}

	// No msg currently being processed
	G(msg) = NULL;

	// Ensure we can get an OPEN cmd on the msg queue
	channelContext[GET_MODEM()].channelState = CLOSED;

}

void
sa_modem_task_cleanup()
{
	INTERNAL_MSG *msg;
	uint_32 result;

	G(sa_kill_me) = RUNNING;
	G(sa_data_polling_enabled) = FALSE;

	// Note that all MQX purports to automatically clean up
	// all resources owned by a task when it is destroyed.
	// However, we must account for 2 caveats:
	// 1) any non-MQX resources
	// 2) As a design decision, MQX does not destroy message pools,
	//	since other tasks might be using the pool.
	//
	// Also, there is the possibility that this mess might one day be
	// ported to some other RTOS that does not support automatic cleanup....
	//
	// Therefore, we clean up everything ourselves, as usual.....

	// Clean up voice call resources
	v_task_cleanup();

#if defined(V44)
	// Clean up V.44 memory allocation
	if ( G(v44_en_history) !=  NULL ) {
		_mem_free( G(v44_en_history) );
	}
#endif // V44

	// Release current msg 
	if ( G(msg) !=  NULL ) {
		_msg_free( G(msg) );
		G(msg) = NULL;
	}

	// Flush the incoming message queue associated with our task
	while ((msg = _msgq_poll(G(modem_queue))) != NULL) {
		_msg_free(msg);		// dump the message
	}

	// Release the resources established by sa_modem_task_init()
	result = _msgpool_destroy(G(modem_msg_pool));
	if ( result != MQX_OK ) {
		printf("\n\n\tsa_modem_task_cleanup: msgpool_destroy FAILED, result=0x%x, errno=0x%x\n\n",
				result, _task_get_error());
	}
	result = _msgq_close(G(modem_queue));
	if ( result != TRUE ) {
		printf("\n\n\tsa_modem_task_cleanup: msgq_close FAILED, result=0x%x, errno=0x%x\n\n",
				result, _task_get_error());
	}

	// Create replacement task
	if (_task_create(0, SA_MODEM, _task_get_parameter()) == MQX_NULL_TASK_ID) {
		printf("\n\n\tsa_modem_task_cleanup: task_create FAILED, errno=0x%x\n\n",
				_task_get_error());
	}
	else {
		printf("sa_modem_task_cleanup: successful re-create, modem %d\n",
			   ModemNum );
	}
}

void
sa_hmsg_dsp_read( SARM_MSG *smsg )
{
	word readAddr = (word) smsg->ms0;
	byte nWords = smsg->ms0 >> 24;
	_int_disable();
	sa_overridePrnting++;
	_int_enable();
	while (nWords > 0) {
		printf("[%02d] %04x: %04x\n",
			   ModemNum,
			   readAddr,
			   dp_read_dsp_ram(readAddr) );
		readAddr++;
		nWords--;
	}
	_int_disable();
	if (sa_overridePrnting) sa_overridePrnting--;
	_int_enable();
}

void
sa_hmsg_dsp_write( SARM_MSG *smsg )
{
	word writeAddr = (word) smsg->ms0;
	uint_32 nWords = smsg->ms0 >> 24;
	int *valPtr = &smsg->ms1;
	_int_disable();
	sa_overridePrnting++;
	_int_enable();
	while (nWords > 0) {
		dp_write_dsp_ram(writeAddr, (uint_16) *valPtr);
		printf("[%02d] %04x: %04x\n",
			   ModemNum,
			   writeAddr,
			   dp_read_dsp_ram(writeAddr) );
		valPtr++;
		writeAddr++;
		nWords--;
	}
	_int_disable();
	if (sa_overridePrnting) sa_overridePrnting--;
	_int_enable();
}
