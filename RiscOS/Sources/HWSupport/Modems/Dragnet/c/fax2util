/*name and version number:@(#)fax2util.c	1.24*/
/*date of get: 		  12/15/00 10:10:33*/
/*date of delta:	  11/30/00 19:24:50*/
/****************************************************************

File :  fax2util.c
Description :
	Contains utility functions for Class 2/2.0/2.1 FAX.  

Procedures Contained :
	chk_rx_qual ()
	get_qc_cnts ()   
	cnvt_bit_rate ()
	cnvt_scan_time ()
	smaller ()
	initialize_c2p ()
	save_remote_vr ()
	save_remote_df ()
	negotiate_vr ()
	negotiate_df ()
	dcs2vr ()
	dcs2df ()
  send_white_line ()  

Revision History :
	Initials        Date            Change
	S.J. Busak     05/07/97         Initial Version
	S.J. Busak     11/18/98         Use ANSI form for function
	S.J. Busak		 09/13/99					Move functions for iofax_c2.c here
	S.J. Busak     05/26/00         Add quality checking for MR encoded lines

*****************************************************************/

#include "llglob_d.h"

#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
	#include "ioglob_d.h"
	#include "v42bis.h"
	#include "atglob.h"
	#include "dpglob.h"
	#include "fax_c2.h"

	#ifdef MODEM_Z80
		#include "z80glob.h"
	#endif

	#ifdef V34_FAX
		#include "faxv34.h"
	#endif

	#include "allglobs.h"   // MUST BE LAST IN #include LIST!

/*
	The following table contains T.4 codewords sorted in ascending order.  Sorting
	the codewords this way is better suited for decoding then a table sorted by run length
	as in the T.4 specification.


	White       Code      Code      Black       Code      Code
 Run Len      Word     Length    Run Len      Word     Length  Index
		 EOL 000000000001   12           EOL 000000000001     12      0
		1792 00000001000    11          1792 00000001000      11      1
		1984 000000010010   12          1984 000000010010     12      2
		2048 000000010011   12          2048 000000010011     12      3
		2112 000000010100   12          2112 000000010100     12      4
		2176 000000010101   12          2176 000000010101     12      5
		2240 000000010110   12          2240 000000010110     12      6
		2304 000000010111   12          2304 000000010111     12      7
		1856 00000001100    11          1856 00000001100      11      8
		1920 00000001101    11          1920 00000001101      11      9
		2368 000000011100   12          2368 000000011100     12     10
		2432 000000011101   12          2432 000000011101     12     11
		2496 000000011110   12          2496 000000011110     12     12
		2560 000000011111   12          2560 000000011111     12     13
			29 00000010        8            18 0000001000       10     14
			30 00000011        8            52 000000100100     12     15
			45 00000100        8           640 0000001001010    13     16
			46 00000101        8           704 0000001001011    13     17
			22 0000011         7           768 0000001001100    13     18
			23 0000100         7           832 0000001001101    13     19
			47 00001010        8            55 000000100111     12     20
			48 00001011        8            56 000000101000     12     21
			13 000011          6          1280 0000001010010    13     22
			20 0001000         7          1344 0000001010011    13     23
			33 00010010        8          1408 0000001010100    13     24
			34 00010011        8          1472 0000001010101    13     25
			35 00010100        8            59 000000101011     12     26
			36 00010101        8            60 000000101100     12     27
			37 00010110        8          1536 0000001011010    13     28
			38 00010111        8          1600 0000001011011    13     29
			19 0001100         7            24 00000010111      11     30
			31 00011010        8            25 00000011000      11     31
			32 00011011        8          1664 0000001100100    13     32
			 1 000111          6          1728 0000001100101    13     33
			12 001000          6           320 000000110011     12     34
			53 00100100        8           384 000000110100     12     35
			54 00100101        8           448 000000110101     12     36
			26 0010011         7           512 0000001101100    13     37
			39 00101000        8           576 0000001101101    13     38
			40 00101001        8            53 000000110111     12     39
			41 00101010        8            54 000000111000     12     40
			42 00101011        8           896 0000001110010    13     41
			43 00101100        8           960 0000001110011    13     42
			44 00101101        8          1024 0000001110100    13     43
			21 0010111         7          1088 0000001110101    13     44
			28 0011000         7          1152 0000001110110    13     45
			61 00110010        8          1216 0000001110111    13     46
			62 00110011        8            64 0000001111       10     47
			63 00110100        8            13 00000100          8     48
			 0 00110101        8            23 00000101000      11     49
		 320 00110110        8            50 000001010010     12     50
		 384 00110111        8            51 000001010011     12     51
			10 00111           5            44 000001010100     12     52
			11 01000           5            45 000001010101     12     53
			27 0100100         7            46 000001010110     12     54
			59 01001010        8            47 000001010111     12     55
			60 01001011        8            57 000001011000     12     56
		1472 010011000       9            58 000001011001     12     57
		1536 010011001       9            61 000001011010     12     58
		1600 010011010       9           256 000001011011     12     59
		1728 0100110110     10            16 0000010111       10     60
			18 0100111         7            17 0000011000       10     61
			24 0101000         7            48 000001100100     12     62
			49 01010010        8            49 000001100101     12     63
			50 01010011        8            62 000001100110     12     64
			51 01010100        8            63 000001100111     12     65
			52 01010101        8            30 000001101000     12     66
			25 0101011         7            31 000001101001     12     67
			55 01011000        8            32 000001101010     12     68
			56 01011001        8            33 000001101011     12     69
			57 01011010        8            40 000001101100     12     70
			58 01011011        8            41 000001101101     12     71
		 192 010111          6            22 00000110111      11     72
		1664 011000          6            14 00000111          8     73
		 448 01100100        8            10 0000100           7     74
		 512 01100101        8            11 0000101           7     75
		 704 011001100       9            15 000011000         9     76
		 768 011001101       9           128 000011001000     12     77
		 640 01100111        8           192 000011001001     12     78
		 576 01101000        8            26 000011001010     12     79
		 832 011010010       9            27 000011001011     12     80
		 896 011010011       9            28 000011001100     12     81
		 960 011010100       9            29 000011001101     12     82
		1024 011010101       9            19 00001100111      11     83
		1088 011010110       9            20 00001101000      11     84
		1152 011010111       9            34 000011010010     12     85
		1216 011011000       9            35 000011010011     12     86
		1280 011011001       9            36 000011010100     12     87
		1344 011011010       9            37 000011010101     12     88
		1408 011011011       9            38 000011010110     12     89
		 256 0110111         7            39 000011010111     12     90
			 2 0111            4            21 00001101100      11     91
			 3 1000            4            42 000011011010     12     92
		 128 10010           5            43 000011011011     12     93
			 8 10011           5             0 0000110111       10     94
			 9 10100           5            12 0000111           7     95
			16 101010          6             9 000100            6     96
			17 101011          6             8 000101            6     97
			 4 1011            4             7 00011             5     98
			 5 1100            4             6 0010              4     99
			14 110100          6             5 0011              4    100
			15 110101          6             1 010               3    101
			64 11011           5             4 011               3    102
			 6 1110            4             3 10                2    103
			 7 1111            4             2 11                2    104

* ********************************************** *
* HOW THIS IMPLEMENTATION OF T.4 DECODING WORKS: *
* ********************************************** *

		On a very high level, decoding works in the following manner.  White and black
	decoding are the same.  White will be used for this example.  Two pointers are
	utilized: a high pointer and a low pointer.  Before a codeword is decoded, the
	high pointer is set to 104 (Index for the bottom of the table) and the low pointer
	is set to zero (Index for the top of the table).  The first bit received is
	a '1'.  Using the above table, only codeword from index 92 to 104 begin with
	'1', so the low pointer is moved to 92.  The next bit received is a '0'.  From the
	table, it's determined that codewords between 92 and 98 begin with "10" so the high
	pointer is moved to 98.  Next, a '1' is received.  The low pointer is moved to 95.
	Another '1' bit is received, so the low pointer is moved to 98 which is the same as
	the high pointer.  When the pointers are equal, a codeword has been decoded and the
	index value in the pointer is used to determine the run length.  In this case, four
	white pels.  Decoding will now be explained at a lower level.

		Looking at the above table, notice that all "white" runs are at least four bits
	in length.  So, when decoding a white run length, the first four bits need to
	be received to determine which group is used to initialize the high and low pointers.
	The above procedure is then used until the indexes are equal.  Again, looking at the
	table, notice that all but the last two black runs begin with leading '0's. So, when
	decoding a black run length, the number of leading '0's are counted to determine which
	group is used to initialize the high and low pointers.  In the case of the last two
	black codewords, the number of '0's is zero, and is treated as a separate group.

		Once a group has been determined, it is used to set the high and low pointers, and
	as an index into a link-list pointer array.  Each subsequent bit received is used to traverse
	the link list until the high and low pointers are equal.  The value of the pointer is
	used as an index into a run length array giving the length of the decoded run.

		A specific, detailed example follows for white.  The first four bits received are 1010.
	Using this as an index into w_range[0xA][n], the low and high pointers are set to 95 and 97
	respectively.  Using the same 1010 (0xA) as an index into wll_tbl[0xA], the link list to
	traverse is w1010.  Graphically, that particular link list has the following structure:

										L = 95
		 _____'0' _____ H = 97 _____'1'_____
		|                [0]                |
	L = 95                _____'0'_____ L = 96 _____ '1' _____
	H = 95               |              H = 97                |
										 L = 96            [1]                L = 97
										 H = 96                               H = 97

		Ideally, it is represented in an array of structures using the following format:

		struct LINK_LIST
		{
			const byte nh;    // New high value of search range
			const byte nl;		// New low value of search range
			const byte n0;    // Next branch if zero
			const byte n1;    // Next branch if one
		};

		The structure array to describe the w1010 link list is given below:

		static const struct LINK_LIST w1010 [2] =
		{
			95, 96, 0, 1,    // Idx 0: End of '0' branch
			96, 97, 1, 1     // Idx 1: End of '1' branch
		};

			The next bit received	determines which pointer get changed and which branch
		becomes active.  When a '0' is received, the high pointer is set to the nh value
		in the table;  the low pointer is set to the nl value if a '1' is received.
		Likewise, the next branch is n0 if a '0' is received and n1 if a '1' is received.

			The example continues and shows how to use the w1010 link list.  As stated earlier, the
		high and low pointers were pre-set to 95 and 97 respectively.  An index into w1010[] is
		set to zero to point to the first branch.  Assume that the next bit received is a '1'.
		The low pointer changes to 96 while the high pointer remains set to 97.  The pointer
		are not equal, so a valid code word has not been decoded yet.  So, the table tells us
		that branch 1 (bracketed number in graphic above) becomes active.  The index into w1010[]
		is set to the value of n1 which is 1.  Now, assume that the next bit received is a '0'.
		From w1010[1], we see that the high pointer should be set to 96 (nh).  Since the high and low
		pointers are now equal, we know that a codeword has been decoded.  Also, the fact that
		both n0 and n1 point to branch 1, indicates the end of a search (the branch points to itself).

			Next, either the high or low pointer must be used to convert the codeword to a pel
		run length.  Since we are decoding white run lengths, either pointer is used to
		index in white_run_len [] array.  From that table we see that white_run_len [96]
		indicate a run length of 16 white pels (9 down, 6 across) for the codeword 101010.
		If codeword 10100 were received, both pointers become equal at 95 (run=9).  Codeword 101011
		makes both pointers equal at 97 (run=17).  These are the three possible codewords in the 1010 group.

			Notice also that some entries in white_run_len[] are greater than 64.  These are make-up
		codewords.  The upper-most bit, b7, is set to indicate a make-up code.  They are
		converted to run lengths by multiplying the lower 7 bits by 64.  When bit 7 is cleared,
		the run length is contained in the lower 7 bits.

			The same procedure is used for black, except that the black versions of the above
		arrays are used.  Decoding 2D exclusively uses 2D_decode[] and is the only array
		needed.

			One other implementation note.  The value of nl in structure LINK_LIST will always be
		one greater than nh.  So, to save code space, the LINK_LIST arrays were implemented
		with three element structures and the code adds 1 to nh to get nl.  The w1010[] array
		in the last example would look like the following:

		struct LINK_LIST
		{
			const byte nh;    // New high value of search range
												// New low value of search range = nh + 1
			const byte n0;    // Next branch if zero
			const byte n1;    // Next branch if one
		};

		static const struct LINK_LIST w1010 [2] =
		{
			95, 0, 1,    // Idx 0: End of '0' branch
			96, 1, 1     // Idx 1: End of '1' branch
		};

			The end of line (EOL) is a special case because there is no run length associated with
		it.  When an EOL is decoded, the high and low pointer will converge at zero.  This is
		easily tested.  For both black and white, the link list search ends after receiving eight
		leading zeros because no other codes are possible.  A separate state is used to see
		if the remaining 0001 pattern is received.  Otherwise, an error is recorded and the
    state machine re-synchs on the next EOL.
*/

/* ------------------- */
/* Function Prototypes */
/* ------------------- */

void init_newline     (void);
void qc_error         (void);
void update_code_line (void);
void proc_mr_code     (void);
void adv_ref_ptr      (void);
void init_mr_decode   (void);
void set_b1_pos       (void);

/*
	Definitions for qc.status (8-bits):

	b5: 0: End of Horizontal mode;  1: Horizontal mode active  
	b4: 0: right[] = code line, child [] = ref_line;  1: Vise-versa  

	b3: 0: MH encoding;  1: MR encoding 
	b2: 0: No code words since last EOL;  1: Code words rcvd since last EOL
	b1: 0: Previous line was ok;  1: Previous line had a bad PEL count
	b0: 0: Look for white run length;  1: Look for black run length
*/

/* -------------------- */
/* Constant Definitions */
/* -------------------- */

/* ........................................................... */
/*                                                             */
/* Tables & Link Lists Related to White Run Lengths Code Words */
/* ........................................................... */

/* Note: Make-up codes have bit 7 set. To get the run length,
				 multiply the lower 7 bits by 64.  Terminating codes
				 have bit 7 cleared.  The lower 7 bits represents the
				 run length.  The EOL (End of line) is stored as 0.
				 The table order coresponds to an ascending sort of T.4
				 white code words.  */

static const byte white_run_len [] =   /* Converts pointer value to white run length */
{
		 0, 0x9C, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0x9D, 0x9E,
	0xA5, 0xA6, 0xA7, 0xA8,   29,   30,   45,   46,   22,   23,
		47,   48,   13,   20,	  33,   34,   35,   36,   37,   38,
		19,   31,   32,    1,   12,   53,   54,   26,   39,   40,
		41, 	42,   43,   44,   21,   28,   61,   62,   63,    0,
	0x85, 0x86,   10,   11,   27,   59,   60, 0x97, 0x98, 0x99,
	0x9B,   18,   24,   49,   50,   51,   52,   25,   55,   56,
		57,   58, 0x83, 0x9A, 0x87, 0x88, 0x8B, 0x8C, 0x8A, 0x89,
	0x8D, 0x8E,	0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
	0x84,    2,    3, 0x82,	   8,    9,   16,   17,    4,    5,
		14,   15, 0x81,    6,    7
};

static const struct LINK_LIST w0000 [22] =  /* White code words beginning with 0000 */
{
	18,  1, 19,    /* Node  0: */
	15,  2, 17,    /* Node  1: */
	13,  3, 16,    /* Node  2: */
	 0,  3,  4,    /* Node  3: End of '0' branch */
	 7,  5, 11,    /* Node  4: */
	 3,  6,  8,    /* Node  5: */
	 1,  6,  7,    /* Node  6: End of '0' branch */
	 2,  7,  7,    /* Node  7: End of '0' & '1' branches */
	 5,  9, 10,    /* Node  8: */
	 4,  9,  9,    /* Node  9: End of '0' & '1' branches */
	 6, 10, 10,    /* Node 10: End of '0' & '1' branches */
	 9, 12, 13,    /* Node 11: */
	 8, 12, 12,    /* Node 12: End of '0' & '1' branches */
	11, 14, 15,    /* Node 13: */
	10, 14, 14,    /* Node 14: End of '0' & '1' branches */
	12, 15, 15,    /* Node 15: End of '0' & '1' branches */
	14, 16, 16,    /* Node 16: End of '0' & '1' branches */
	17, 18, 17,    /* Node 17: End of '1' branch */
	16, 18, 18,    /* Node 18: End of '0' & '1' branches */
	21, 20, 19,    /* Node 19: End of '1' branch */
	19, 20, 21,    /* Node 20: End of '0' branch */
	20, 21, 21     /* Node 21: End of '0' & '1' branches */
};

static const struct LINK_LIST w0001 [10] = /* White code words beginning with 0001 */
{
	29,  1,  7,    /* Node 0: */
	25,  2,  4,    /* Node 1: */
	23,  2,  3,    /* Node 2: End of '0' branch */
	24,  3,  3,    /* Node 3: End of '0' & '1' branches */
	27,  5,  6,    /* Node 4: */
	26,  5,  5,    /* Node 5: End of '0' & '1' branches */
	28,  6,  6,    /* Node 6: End of '0' & '1' branches */
	32,  8,  7,    /* Node 7: End of '1' branch */
	30,  8,  9,    /* Node 8: End of '0' branch */
	31,  9,  9     /* Node 9: End of '0' & '1' branches */
};

static const struct LINK_LIST w0010 [10] =
{
	37,  1,  4,    /* Node 0: */
	34,  1,  2,    /* Node 1: End of '0' branch */
	36,  3,  2,    /* Node 2: End of '1' branch */
	35,  3,  3,    /* Node 3: End of '0' & '1' branches */
	41,  5,  8,    /* Node 4: */
	39,  6,  7,    /* Node 5: */
	38,  6,  6,    /* Node 6: End of '0' & '1' branches */
	40,  7,  7,    /* Node 7: End of '0' & '1' branches */
	43,  9,  8,    /* Node 8: End of '1' branch */
	42,  9,  9     /* Node 9: End of '0' & '1' branches */
};

static const struct LINK_LIST w0011 [7] =
{
	51,  1,  0,    /* Node 0: End of '1' branch */
	47,  2,  4,    /* Node 1: */
	45,  2,  3,    /* Node 2: End of '0' branch */
	46,  3,  3,    /* Node 3: End of '0' & '1' branches */
	49,  5,  6,    /* Node 4: */
	48,  5,  5,    /* Node 5: End of '0' & '1' branches */
	50,  6,  6     /* Node 6: End of '0' & '1' branches */
};

static const struct LINK_LIST w0100 [8] =
{
	53,  0,  1,    /* Node 0: */
	56,  2,  4,    /* Node 1: */
	54,  2,  3,    /* Node 2: End of '0' branch */
	55,  3,  3,    /* Node 3: End of '0' & '1' branches */
	60,  5,  4,    /* Node 4: End of '1' branch */
	58,  6,  7,    /* Node 5: */
	57,  6,  6,    /* Node 6: End of '0' & '1' branches */
	59,  7,  7     /* Node 7: End of '0' & '1' branches */
};

static const struct LINK_LIST w0101 [10] =
{
	67,  1,  6,    /* Node 0: */
	64,  2,  4,    /* Node 1: */
	62,  2,  3,    /* Node 2: End of '0' branch */
	63,  3,  3,    /* Node 3: End of '0' & '1' branches */
	66,  5,  4,    /* Node 4: End of '1' branch */
	65,  5,  5,    /* Node 5: End of '0' & '1' branches */
	71,  7,  6,    /* Node 6: End of '1' branch */
	69,  8,  9,    /* Node 7: */
	68,  8,  8,    /* Node 8: End of '0' & '1' branches */
	70,  9,  9     /* Node 9: End of '0' & '1' branches */
};

static const struct LINK_LIST w0110 [17] =
{
	78,  1,  6,    /* Node  0: */
	73,  1,  2,    /* Node  1: End of '0' branch */
	75,  3,  4,    /* Node  2: */
	74,  3,  3,    /* Node  3: End of '0' & '1' branches */
	77,  5,  4,    /* Node  4: End of '1' branch */
	76,  5,  5,    /* Node  5: End of '0' & '1' branches */
	85,  7, 13,    /* Node  6: */
	81,  8, 10,    /* Node  7: */
	79,  8,  9,    /* Node  8: End of '0' branch */
	80,  9,  9,    /* Node  9: End of '0' & '1' branches */
	83, 11, 12,    /* Node 10: */
	82, 11, 11,    /* Node 11: End of '0' & '1' branches */
	84, 12, 12,    /* Node 12: End of '0; & '1' branches */
	89, 14, 13,    /* Node 13: End of '1' branch */
	87, 15, 16,    /* Node 14: */
	86, 15, 15,    /* Node 15: End of '0' & '1' branches */
	88, 16, 16     /* Node 16: End of '0' & '1' branches */
};

static const struct LINK_LIST w1001 [1] =
{
	93,  0,  0,    /* Idx 0: */
};

static const struct LINK_LIST w1010 [2] =
{
	95,  0,  1,    /* Idx 0: End of '0' branch */
	96,  1,  1     /* Idx 1: End of '1' branch */
};

static const struct LINK_LIST w1101 [2] =
{
	101, 1, 0,   /* Idx 0: End of '1' branch */
	100, 1, 1    /* Idx 1: End of '0' branch */
};

/*
	Note: Code words beginning with 0x7, 0x8, 0xB, 0xC, 0xE & 0xF
				have no link lists associated with them.  The link list for
				0x9 will be used as a place holder in the table below.
*/

#ifdef MODEM_Z80
static const struct LINK_LIST* const wll_tbl [] =
#else
static const struct LINK_LIST* wll_tbl [] =
#endif
{
	w0000, w0001, w0010, w0011,
	w0100, w0101, w0110, w1001,
	w1001, w1001, w1010, w1001,
	w1001, w1101, w1001, w1001
};

static const byte w_range [16][2] =
{
	 0,  22,      /* Index ranges between 0 & 22 in white_run_len  (0000xxxx) */
	23,  33,      /* Index ranges between 23 & 33 in white_run_len (0001xxxx) */
	34,  44,      /* etc */
	45,  52,
	53,  61,
	62,  72,
	73,  90,
	91,  91,
	92,  92,
	93,  94,
	95,  97,
	98,  98,
	99,  99,
	100, 102,
	103, 103,
	104, 104      /* Index ranges between 104 & 104 in white_run_len  (1111) */
};

/* ........................................................... */
/*                                                             */
/* Tables & Link Lists Related to Black Run Lengths Code Words */
/* ........................................................... */

static const byte black_run_len [] =
{
		 0, 0x9C, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0x9D, 0x9E,
		0xA5, 0xA6, 0xA7, 0xA8,   18,   52, 0x8A, 0x8B, 0x8C, 0x8D,
		55,   56, 0x94, 0x95,	0x96, 0x97,   59,   60, 0x98, 0x99,
		24,   25, 0x9A, 0x9B, 0x85, 0x86, 0x87, 0x88, 0x89,   53,
		54, 0x8E, 0x8F, 0x90, 0x91, 0x92, 0x93, 0x81,   13,   23,
		50,   51,   44,   45,   46,   47,   57,   58,   61, 0x84,
		16,   17,   48,   49,   62,   63,   30,   31,   32,   33,
		40,   41,   22,   14,   10,   11,   15, 0x82, 0x83,   26,
		27,   28,	  29,   19,   20,   34,   35,   36,   37,   38,
		39,   21,   42,   43,	   0,   12,    9,    8,    7,    6,
		 5,    1,    4,    3,    2
};

static const struct LINK_LIST b1x [1] =
{
	103, 0, 0    /* Node 0: End of '0' & '1' branches */
};

static const struct LINK_LIST b01x [1] =
{
	101, 0, 0    /* Node 0: End of '0' & '1' branches */
};

static const struct LINK_LIST b001x [1] =
{
	99, 0,  0     /* Node 0: End of '0' & '1' branches */
};

static const struct LINK_LIST b0001x [2] =
{
	97,  1,  0,     /* Node 0: End of '1' branch */
	96,  1,  1      /* Node 1: End of '0' & '1' branches */
};

static const struct LINK_LIST b00001x [21] =
{
	75,  1,  2,     /* Node  0: */
	74,  1,  1,     /* Node  1: End of '0' & '1' branches */
	94,  3,  2,     /* Node  2: End of '1' branch */
	83,  4, 11,     /* Node  3: */
	76,  4,  5,     /* Node  4: End of '0' branch */
	80,  6,  9,     /* Node  5: */
	78,  7,  8,     /* Node  6: */
	77,  7,  7,     /* Node  7: End of '0' & '1' branches */
	79,  8,  8,     /* Node  8: End of '0' & '1' branches */
	82, 10,  9,     /* Node  9: End of '1' branch */
	81, 10, 10,     /* Node 10: End of '0' & '1' branches */
	90, 12, 18,     /* Node 11: */
	86, 13, 15,     /* Node 12: */
	84, 13, 14,     /* Node 13: End of '0' branch */
	85, 14, 14,     /* Node 14: End of '0' & '1' branches */
	88, 16, 17,     /* Node 15: */
	87, 16, 16,     /* Node 16: End of '0' & '1' branches */
	89, 17, 17,     /* Node 17: End of '0' & '1' branches */
	93, 19, 18,     /* Node 18: End of '1' branch */
	91, 19, 20,     /* Node 19: End of '0' branch */
	92, 20, 20,     /* Node 20: End of '0' & '1' branches */
};

static const struct LINK_LIST b000001x [25] =
{
	60,  1, 13,     /* Node  0: */
	48,  1,  2,     /* Node  1: End of '0' branch */
	55,  3,  9,     /* Node  2: */
	51,  4,  6,     /* Node  3: */
	49,  4,  5,     /* Node  4: End of '0' branch */
	50,  5,  5,     /* Node  5: End of '0' & '1' branches */
	53,  7,  8,     /* Node  6: */
	52,  7,  7,     /* Node  7: End of '0' & '1' branches */
	54,  8,  8,     /* Node  8: End of '0' & '1' branches */
	59, 10,  9,     /* Node  9: End of '1' branch */
	57, 11, 12,     /* Node 10: */
	56, 11, 11,     /* Node 11: End of '0' & '1' branches */
	58, 12, 12,     /* Node 12: End of '0' & '1' branches */
	72, 14, 13,     /* Node 13: End of '1' branch */
	65, 15, 19,     /* Node 14: */
	61, 15, 16,     /* Node 15: End of '0' branch */
	63, 17, 18,     /* Node 16: */
	62, 17, 17,     /* Node 17: End of '0' & '1' branches */
	64, 18, 18,     /* Node 18: End of '0' & '1' branches */
	69, 20, 23,     /* Node 19: */
	67, 21, 22,     /* Node 20: */
	66, 21, 21,     /* Node 21: End of '0' & '1' branches */
	68, 22, 22,     /* Node 22: End of '0' & '1' branches */
	71, 24, 23,     /* Node 23: End of '1' branch */
	70, 24, 24      /* Node 24: End of '0' & '1' branches */
};

static const struct LINK_LIST b0000001x [33] =
{
	30,  1, 17,     /* Node  0: */
	20,  2,  8,     /* Node  1: */
	14,  2,  3,     /* Node  2: End of '0' branch */
	17,  4,  6,     /* Node  3: */
	15,  4,  5,     /* Node  4: End of '0' branch */
	16,  5,  5,     /* Node  5: End of '0' & '1' branches */
	19,  7,  6,     /* Node  6: End of '1' branch */
	18,  7,  7,     /* Node  7: End of '0' & '1' branches */
	26,  9, 14,     /* Node  8: */
	23, 10, 12,     /* Node  9: */
	21, 10, 11,     /* Node 10: */
	22, 11, 11,     /* Node 11: End of '0' & '1' branches */
	25, 13, 12,     /* Node 12: End of '1' branch */
	24, 13, 13,     /* Node 13: End of '0' & '1' branches */
	29, 15, 14,     /* Node 14: End of '1' branch */
	27, 15, 16,     /* Node 15: End of '0' branch */
	28, 16, 16,     /* Node 16: End of '0' & '1' branch */
	39, 18, 26,     /* Node 17: */
	34, 19, 22,     /* Node 18: */
	31, 19, 20,     /* Node 19: End of '0' branch */
	33, 21, 20,     /* Node 20: End of '1' branch */
	32, 21, 21,     /* Node 21: End of '0' & '1' branches */
	36, 23, 24,     /* Node 22: */
	35, 23, 23,     /* Node 23: End of '0' & '1' branches */
	38, 25, 24,     /* Node 24: End of '1' branch */
	37, 25, 25,     /* Node 25: End of '0' & '1' branches */
	46, 27, 26,     /* Node 26: End of '1' branch */
	42, 28, 30,     /* Node 27: */
	40, 28, 29,     /* Node 28: End of '0' branch */
	41, 29, 29,     /* Node 29: End of '0' & '1' branches */
	44, 31, 32,     /* Node 30: */
	43, 31, 31,     /* Node 31: End of '0' & '1' branches */
	45, 32, 32      /* Node 32: End of '0' & '1' branches */
};

static const struct LINK_LIST b00000001x [12] =
{
	 7,  1,  7,     /* Node  0: */
	 3,  2,  4,     /* Node  1: */
	 1,  2,  3,     /* Node  2: End of '0' branch */
	 2,  3,  3,     /* Node  3: End of '0' & '1' branches */
	 5,  5,  6,     /* Node  4: */
	 4,  5,  5,     /* Node  5: End of '0' & '1' branches */
	 6,  6,  6,     /* Node  6: End of '0' & '1' branches */
	 9,  8,  9,     /* Node  7: */
	 8,  8,  8,     /* Node  8: End of '0' & '1' branches */
	11, 10, 11,     /* Node  9: */
	10, 10, 10,     /* Node 10: End of '0' & '1' branches */
	12, 11, 11      /* Node 11: End of '0' & '1' branches */
};

#ifdef MODEM_Z80
static const struct LINK_LIST* const bll_tbl [] =	// Declaration locates table in ROM
#else
static const struct LINK_LIST* bll_tbl [] =
#endif
{
	b1x,     b01x,     b001x,     b0001x,
	b00001x, b000001x, b0000001x, b00000001x
};

static const byte b_range [8][2] =
{
	103, 104,      /* Index ranges between elements 103 & 104 in black_run_len (1x) */
	101, 102,      /* Index ranges between elements 101 & 102 in black_run_len (01x) */
	 99, 100,      /* etc */
	 96, 98,
	 74, 95,
	 48, 73,
	 14, 47,
		1, 13
};

static const struct LINK_LIST decode_2D [10] =
{
	 9,  1,  0,     /* Node  0: End of '1' branch */
	 7,  3,  2,     /* Node  1: */
	 8,  2,  2,     /* Node  2: End of '0' & '1' branches */
	 6,  4,  3,     /* Node  3: End of '1' branch */
	 5,  5,  4,     /* Node  4: End of '1' branch */
	 3,  7,  6,     /* Node  5: */
	 4,  6,  6,     /* Node  6: End of '0' & '1' branches */
	 1,  9,  8,     /* Node  7: */
	 2,  8,  8,     /* Node  8: End of '0' & '1' branches */
	 0,  9,  9,     /* Node  9: End of '0' & '1' branches*/
};

/* ------------------------------------------- */
/* Initialization for Receive Quality Checking */
/* ------------------------------------------- */

void init_qc (void)
{
	G(c2qc.stat)     = 0;  /* Status byte */
	G(c2qc.state)    = 0;  /* Active state of state machine */
	G(c2qc.acc)      = 0;  /* Bits of code word currently being used */
	G(c2qc.idx)      = 4;  /* Index into link lists */
	G(c2qc.pel_cnt)  = 0;  /* Number of PEL on a line */
	G(c2qc.badline)  = 0;  /* Number of bad lines received */
	G(c2qc.multline) = 0;  /* Current number of consecutive bad lines received */
	G(c2qc.maxmult)  = 0;  /* Maximum number of consecutive bad lines received */

	if (G(c2p.fdcs.ps.df) > 0)  /* MR and uncompressed format? */
	{
		G(c2qc.stat)      = 0x08;      /* Indicate MR/Uncompressed encoding */
		G(c2qc.code_line) = (byte*)V42BIS_MEM_START;
		G(c2qc.ref_line)  = (byte*)V42BIS_MEM_START + 5000;  
		G(c2qc.run)       = 0;
		G(c2qc.ref_cnt) = 0;
	}
}

/* ----------------------------------- */
/* Main receive quality check function */
/* ----------------------------------- */

void chk_rx_qual (byte rxd)
{
	byte rxd_cnt = 8;
	byte pels;

	while (rxd_cnt)
	{
		switch (G(c2qc.state))
		{
	 // ************************************************************************************ //
			case 20: // Get the first four bits of a white code word -- MR Horizontal mode //
			case 0:  // Get first four bits of white code word                                   //
	 // ************************************************************************************ //
				while (rxd_cnt)
				{
					G(c2qc.acc) = (G(c2qc.acc) << 1) + (rxd & 0x01);
					G(c2qc.idx)--;
					rxd = rxd >> 1;
					rxd_cnt--;

					if (!G(c2qc.idx))  /* All four bits loaded into G(c2qc.acc)? */
					{
						G(c2qc.ll_ptr) = (struct LINK_LIST*) wll_tbl [G(c2qc.acc)];
						G(c2qc.low)  = w_range [G(c2qc.acc)] [0];
						G(c2qc.high) = w_range [G(c2qc.acc)] [1];
						G(c2qc.state)++;   /* Next state */
						break;
					}
				}
				break;

	 // *********************************************************************************** //
			case 21: /* Search a link list for the decode index -- MR Horizontal mode */
			case 1:  /* Search a link list for the decode index */
   // *********************************************************************************** //
				while (G(c2qc.low) != G(c2qc.high))
				{
					if (rxd_cnt)
					{
						if (rxd & 0x01)
						{
							G(c2qc.low) = (G(c2qc.ll_ptr) + G(c2qc.idx))->nh + 1;
							G(c2qc.idx) = (G(c2qc.ll_ptr) + G(c2qc.idx))->n1;
						}

						else
						{
							G(c2qc.high) = (G(c2qc.ll_ptr) + G(c2qc.idx))->nh;
							G(c2qc.idx)  = (G(c2qc.ll_ptr) + G(c2qc.idx))->n0;
						}

						rxd = rxd >> 1;
						rxd_cnt--;
					}

					else
						return;   /* Runs over into next byte */
				}

				if (G(c2qc.stat) & 0x01)         /* Decoding black code word? */
					pels = black_run_len[G(c2qc.low)];  // Get number of black pels in this run
				else
					pels = white_run_len[G(c2qc.low)];  // Get number of white pels in this run

				if (G(c2qc.state) == 1)   // Normal MH decoding?
				{
					if ( (G(c2qc.stat) & 0x08) &&  // Decoding MR?
							 (G(c2qc.low) != 0) )      // Not first part of EOL?
					{

						if (pels >= 64)
							G(c2qc.run) = G(c2qc.run) + (((word)pels & 0x3F) << 6);

						else
						{
							G(c2qc.run) = G(c2qc.run) + ((word)pels & 0x3F);
							update_code_line ();
							G(c2qc.stat) = G(c2qc.stat) ^ 1;  // Restore pel color
							G(c2qc.run) = 0;
						}
					}

					if (pels >= 64)     /* Make-up code word? */
						G(c2qc.pel_cnt) = G(c2qc.pel_cnt) + (word)((pels & 0x7F) << 6); 

					else /* Terminating code word */
					{
						G(c2qc.pel_cnt) = G(c2qc.pel_cnt) + (word)pels;
						G(c2qc.stat) = G(c2qc.stat) ^ 0x01;   /* Look for opposite color run length */
					}

					if (G(c2qc.low))       /* Index points to a run length? */
					{
						G(c2qc.stat) = G(c2qc.stat) | 0x04;  /* Indicate code word since last EOL */
						G(c2qc.state) = (G(c2qc.stat) & 0x01) << 2;  /* Decode next code word (State 0 or 4 based on color) */
					}

					else
					{  
						G(c2qc.acc) = 0;    // Counts '0's until a '1' is found
						G(c2qc.state) = 3;   /* Pending EOL, wait for 3 '0's and a '1' */
					}  
				}

				else  // Horizontal mode for MR decoding
				{
					if (pels >= 64) // Make-up code word? */
						G(c2qc.run) = G(c2qc.run) + (word)((pels & 0x3F) << 6); // Add to current run length

					else            // Terminating code word
					{
						G(c2qc.run) = G(c2qc.run) + (word)(pels & 0x3F);        // Add to current run length
						G(c2qc.pel_cnt) = G(c2qc.pel_cnt) + G(c2qc.run);        // Add to total pels on coding line
						update_code_line ();                                    // Add to coding line
						G(c2qc.run) = 0;                                        // Start a new horizontal run

						if (!(G(c2qc.stat) & 0x20))  // Horizontal mode inactive?
						{
							init_mr_decode ();
							break;                    // Skip rest of this "case"
						}

						G(c2qc.stat) = G(c2qc.stat) & ~0x20;  // Horizontal mode inactive next time through
					}

					G(c2qc.state) = G(c2qc.stat) & 0x01 ? 24 : 20;  // Next run is black/white
				}

				G(c2qc.acc) = 0;       // White: accumulates 1st four bits;  Black: count leading '0's
				G(c2qc.idx) = 4;       // White: down counter;  Black: overwritten with current bit
				break;

	 // ********************************************************************** //
   		case 23: // Check for an EOL on an MR encoded line //
			case 3:  /* Wait for the next '1' and decide if an EOL was received */
	 // ********************************************************************** //
				while (rxd_cnt)
				{
					if (rxd & 0x01)      /* A '1' bit? */
					{
						if (G(c2qc.acc) >= 3)   /* Valid EOL? */
						{
							if (G(c2qc.stat) & 0x04)  /* Any code words since last EOL? */
							{
								if (G(c2qc.pel_cnt) != page_wd ())  // Check if line has correct number of pels
									qc_error ();                      // Update error statistics

								else                                   // Correct number of pels on line
									G(c2qc.stat) = G(c2qc.stat) & ~0x02; // Clear bad line indicator
							}

							G(c2qc.stat) = G(c2qc.stat) & ~0x04;   // Indicate no code words since this EOL (i.e. start new line)
							init_newline ();
						}

						else if ( (G(c2qc.state) == 3) &&   // Decoding one-dimension line?
											(G(c2qc.acc) == 0) )      // First '1' after 8 '0'?
						{
							G(c2qc.acc) = 0;  // Count '1' bits
							G(c2qc.state) = 10;  // Look for switch to 1D, uncompressed mode
						}

						else  /* Invalid code word or EOL */
						{
							qc_error ();
							G(c2qc.acc) = 0;
							G(c2qc.state) = 5;   /* Re-sync with data */
						}

						rxd = rxd >> 1;  /* Update variables for next bit */
						rxd_cnt--;
						break;           /* Exit while loop */
					}

					else
						G(c2qc.acc)++;      /* Count zero bits */

					rxd = rxd >> 1;  /* Get next bit */
					rxd_cnt--;
				}

				if (G(c2qc.acc) > 3)
					G(c2qc.acc) = 3;     /* Prevent overflow */

				break;

	 // *************************************************************************************** //
			case 24:  /* Count the leading zeros of a black code word -- MR Horizontal mode*/
			case 4:   /* Count the leading zeros of a black code word */
	 // *************************************************************************************** //
				while (rxd_cnt)
				{
					G(c2qc.idx) = !(rxd & 0x01);
					rxd = rxd >> 1;
					rxd_cnt--;

					if (G(c2qc.idx))     /* '0' received? */
					{
						G(c2qc.acc)++;     /* Count '0's */

						if (G(c2qc.acc) == 8) /* Eight consecutive '0's (beginning of EOL)? */
						{
							G(c2qc.acc) = 0;    // Counts '0's until a '1' is found
							G(c2qc.state) = 3;  /* Expect an EOL */
							break;
						}
					}

					else
					{
						G(c2qc.ll_ptr) = (struct LINK_LIST*) bll_tbl [G(c2qc.acc)];
						G(c2qc.low)  = b_range [G(c2qc.acc)] [0];
						G(c2qc.high) = b_range [G(c2qc.acc)] [1];
						G(c2qc.state) = G(c2qc.state) == 24 ? 21 : 1;  // Set state to search link list
						break;
					}
				}

				break;

	 // ************************************************** //
			case 5:  /* Wait for next EOL to re-synchronize */
	 // ************************************************** //
				while (rxd_cnt)
				{
					if (!(rxd & 0x01))   // Bit is a '0'?
						G(c2qc.acc)++;     // Add to consecutive '0' count

					else  // Bit is a '1'
					{
						if (G(c2qc.acc) >= 11)  // Found an EOL? (at least 11 '0' followed by a '1')
						{                 
							init_newline ();
							rxd = rxd >> 1;  // Get next bit
							rxd_cnt--;       // Update loop counter
							break;           // Exit while loop
						}                 

						else   // Pattern was not an EOL
							G(c2qc.acc) = 0; // Count consecutive '0's again
					}

					rxd = rxd >> 1;  /* Get next bit */
					rxd_cnt--;
				}

				if (G(c2qc.acc) > 11)   /* Prevent overflow */
					G(c2qc.acc) = 11;

				break;

	 // ***************************************************** //
			case 6:  /* Check Tag bit after EOL for MR encoding */
	 // ***************************************************** //
				if (rxd_cnt)
				{
					if (rxd & 0x01)  // EOL+1 (next line is MH encoded?)
						G(c2qc.state) = 0;  // Decode MH encoded data

					else  // Next line is MR encoded
						init_mr_decode ();

					rxd = rxd >> 1;  /* Get next bit */
					rxd_cnt--;
				}

				break;

	 // ************************************ //
			case 7:  /* Decode MR encoded data */
	 // ************************************ //
				while (G(c2qc.low) != G(c2qc.high))
				{
					if (rxd_cnt)
					{
						if (rxd & 0x01)
						{
							G(c2qc.low) = (G(c2qc.ll_ptr) + G(c2qc.idx))->nh + 1;
							G(c2qc.idx) = (G(c2qc.ll_ptr) + G(c2qc.idx))->n1;
						}

						else
						{
							G(c2qc.high) = (G(c2qc.ll_ptr) + G(c2qc.idx))->nh;
							G(c2qc.idx)  = (G(c2qc.ll_ptr) + G(c2qc.idx))->n0;
						}

						rxd = rxd >> 1;
						rxd_cnt--;
					}

					else
						return;   /* Runs over into next byte */
				}

				proc_mr_code ();  // Process the MR code word
				break;

	 // ***************************************************** //
			case 30:  // Look for switch to 2D, uncompressed mode //
			case 10:  // Look for switch to 1D, uncompressed mode //
	 // ***************************************************** //
				while (rxd_cnt)
				{
					byte bit;

					bit = rxd & 0x01;
					rxd = rxd >> 1;  /* Update variables for next bit */
					rxd_cnt--;

					if (bit)      /* A '1' bit? */
					{
						G(c2qc.acc)++;

						if (G(c2qc.acc) == 3)   /* Switch to uncompressed mode? */
						{
							G(c2qc.acc) = 0;
							G(c2qc.state)++;
							break;           /* Exit while (rxd_cnt) loop */
						}
					}

					else  /* Invalid code word */
					{
						qc_error ();
						G(c2qc.acc) = 0;
						G(c2qc.state) = 5;   /* Re-sync with data */
						break;   // Exit while (rxd_cnt) loop
					}
				}

				break;

	 // ********************************************** //
			case 31: // Process uncompressed 2D code words //
			case 11: // Process uncompressed 1D code words //
	 // ********************************************** //
				while (rxd_cnt)
				{
					byte bit;

					bit = rxd & 0x01;
					rxd = rxd >> 1;  /* Update variables for next bit */
					rxd_cnt--;

					if (bit)  // '1' bit?
					{
						if (G(c2qc.acc) <= 4)  // 1 to 4 white pels followed by single black pel?
							G(c2qc.run) = G(c2qc.run) + G(c2qc.acc);

						else if (G(c2qc.acc) == 5)  // Run of five white pels?
						{
							G(c2qc.run) = G(c2qc.run) + 5;
							G(c2qc.stat) = G(c2qc.stat) & ~1;  // Five white pels
						}

						else if (G(c2qc.acc) <= 10)  //  1 to 4 white pels and exit?
						{
							G(c2qc.run) = G(c2qc.run) + G(c2qc.acc) - 6;     // Number of white pels
							G(c2qc.stat) = G(c2qc.stat) & ~1;  // Force white pels
						}

						else  // Must be an EOL
						{
							if ( G(c2qc.pel_cnt) != page_wd ())  // Correct line width?
								qc_error ();

							else
								G(c2qc.stat) = G(c2qc.stat) & ~0x02; /* Clear bad line indicator */

							G(c2qc.stat) = G(c2qc.stat) & ~0x04;   /* Indicate no code words since this EOL */
							init_newline ();
							break;  // Exit while loop
						}

						if (G(c2qc.acc) <= 4)  // Black and white pels?
						{
							if (G(c2qc.run))       // Any leading white pels?
							{
								G(c2qc.pel_cnt) = G(c2qc.pel_cnt) + G(c2qc.run);  // Add to total pels on coding line
								G(c2qc.stat) = G(c2qc.stat) & ~1;     // Indicate white pels
								update_code_line ();                  // Add to coding line
							}

							G(c2qc.run) = 1;       // Single black pel
							G(c2qc.stat) = G(c2qc.stat) | 1;  // Indicate black pel
							update_code_line ();   // Add to coding line
							G(c2qc.pel_cnt)++;     // Add to total pels for coding line
							G(c2qc.run) = 0;       // Start new run length
						}

						if (G(c2qc.acc) > 5)   // Exit from uncompressed mode?
						{
							G(c2qc.pel_cnt) = G(c2qc.pel_cnt) + G(c2qc.run);  // Update pel total with white pels in exit code
							G(c2qc.state)++;     // Get tag bit for next color
							break;               // Exit while loop
						}

						G(c2qc.acc) = 0;       // Reset for next code word
					}

					else
						G(c2qc.acc)++;  // Count leading '0's
				}

				break;

	 // *********************************************************************** //
			case 32:  // Get the tag bit of next run following uncompressed 2D mode //
			case 12:  // Get the tag bit of next run following uncompressed 1D mode //
	 // *********************************************************************** //
				if (rxd_cnt)
				{
					if (rxd & 0x01)  // Next run will be black?
					{
						if (G(c2qc.run))  // Any white pels with/before exit code word?
						{
							G(c2qc.stat) = G(c2qc.stat) & ~1;     // Indicate white pels
							update_code_line ();                  // Add to coding line
							G(c2qc.run) = 0;
						}

						G(c2qc.stat) = G(c2qc.stat) | 1;  // Set next pel run as black
						G(c2qc.state) = G(c2qc.state) == 12 ? 4 : 7;
					}

					else  // Next run is White
					{
						G(c2qc.stat) = G(c2qc.stat) & ~1;  // Set next pel run as white
						G(c2qc.state) = G(c2qc.state) == 12 ? 0 : 7;
					}

					rxd = rxd >> 1;  /* Update variables for next bit */
					rxd_cnt--;

					if (G(c2qc.state) == 7)  // Continuing with 2D?
						init_mr_decode ();

					else                     // Continue with 1D
					{
						G(c2qc.acc) = 0;       // White: accumulates 1st four bits;  Black: count leading '0's
						G(c2qc.idx) = 4;       // White: down counter;  Black: overwritten with current bit
					}
				}

				break;

	 // *********************************** //
			default:  /* Something went wrong */
	 // *********************************** //
				G(c2qc.acc) = 0;     /* Count '0's */
				G(c2qc.state) = 5;   /* Re-sync */
		}
	}
}

/* ------------------------------------------- */
/* Update counters when a bad line is received */
/* ------------------------------------------- */

void qc_error (void)
{
	G(c2qc.badline)++;        /* Increment the bad line count */

	if (!G(c2qc.multline))    // Not already counting consecutive line errors?
		G(c2qc.multline)++;     // Start consecutive line count with this bad line

	if (G(c2qc.stat) & 0x02)  /* Previous line had error? */
	{
		G(c2qc.multline)++;     /* Update consecutive line error count */
											 /* Save largest consecutive line error count */
		G(c2qc.maxmult) = G(c2qc.multline) > G(c2qc.maxmult) ? G(c2qc.multline) : G(c2qc.maxmult);
	}

	else
		G(c2qc.multline) = 0;   // First bad line after a good line

	G(c2qc.stat) = G(c2qc.stat) | 0x02;  /* Indicate line error */
}

/* -------------------------------- */
/* Initialization for each new line */
/* -------------------------------- */

void init_newline (void)
{
	G(c2qc.stat)    = G(c2qc.stat) & ~0x01;   /* Look for white line */
	G(c2qc.acc)     = 0;
	G(c2qc.state)   = 0;
	G(c2qc.pel_cnt) = 0;
	G(c2qc.idx)     = 4;
	G(c2qc.ref_cnt) = 0;

	if (G(c2qc.stat) & 0x08)  // MR encoding?
	{
		G(c2qc.state) = 6;                   // Check tag bit after EOL
		*G(c2qc.code_line) = 0xFF;           // Put EOL in code line buffer
		G(c2qc.stat) = G(c2qc.stat) ^ 0x10;  // Invert code line/reference line flag
		G(c2qc.run) = 0;                     // Clear pel total of current run

		if (G(c2qc.stat) & 0x10) //  Set child[] = code line, right[] = ref_line?
		{
			G(c2qc.code_line) = (byte*)V42BIS_MEM_START + 5000;
			G(c2qc.ref_line)  = (byte*)V42BIS_MEM_START; 
		}

		else
		{
			G(c2qc.code_line) = (byte*)V42BIS_MEM_START;
			G(c2qc.ref_line)  = (byte*)V42BIS_MEM_START + 5000;  
		}
	}
}

/* -------------------------------------------------------------- */
/* Send the quality checking results to page_end () in iofax_c2.c */
/* -------------------------------------------------------------- */

void get_qc_cnts (word* bl, word* cbl)
{
	*bl  = G(c2qc.badline);
	*cbl = G(c2qc.maxmult);
}

// ------------------------------------------- //
// Initialization to Decode an MR Encoded Line //
// ------------------------------------------- //

void init_mr_decode (void)
{
	G(c2qc.ll_ptr) = (struct LINK_LIST*) decode_2D;  // Point to 2D decode table
	G(c2qc.idx)   = 0;        // Point to 1st node in table
	G(c2qc.low)   = 0;        // Set low index to beginning of table
	G(c2qc.high)  = 10;       // Set high index to end of table
	G(c2qc.state) = 7;        // State to decode MR data
	set_b1_pos ();          // Advance position of reference line to b1
}

// ----------------------------------------------- //
// Update coding line information with current run //
// ----------------------------------------------- //

void update_code_line (void)
{
	byte color = G(c2qc.stat) & 1 ? 0x80 : 0;
	word run = G(c2qc.run);

	if (run >= 64)  // Need a make-up code?
	{
		*G(c2qc.code_line)++ = color | 0x40 | (byte)(run >> 6);  // Save make-up code
		run = run % 64;                                          // Number of pel remaining
	}

	*G(c2qc.code_line)++ = color | run;                        // Save terminating code
	G(c2qc.stat) = G(c2qc.stat) ^ 1;                           // Invert color
}

// ---------------------------------------------------------------------- //
// Add the next run on the reference line to the reference line pel total //
// ---------------------------------------------------------------------- //

void adv_ref_ptr (void)
{
	byte ref_code = *G(c2qc.ref_line);

	if (ref_code != 0xFF)   // Not EOL? 
	{
		G(c2qc.ref_line)++;

		if (ref_code & 0x40)  // Make-up code?
		{
			G(c2qc.ref_cnt) += ( (ref_code & 0x3F) << 6);
			ref_code = *G(c2qc.ref_line)++;  // Get terminating code
		}

		G(c2qc.ref_cnt) += (ref_code & 0x3F);
	}
}

// ------------------------------ //
// Process a decoded MR code word //
// ------------------------------ //
/*
		*c2qc.ref_line - points to current location on reference line
		*c2qc.code_line - points to next location to save code line info.
		c2qc.run - accumulate number of pels for the current run
		c2qc.pel_cnt - accumulate number of pels on code line
*/

void proc_mr_code (void)
{
	byte dif = 1;

	G(c2qc.idx) = 0;           // Point to 1st node in table again

	if (G(c2qc.low) > 1)  // Not EOL or switch to uncompressed mode?
		G(c2qc.stat) = G(c2qc.stat) | 0x04;  // Indicate code word since last EOL

	switch ( G(c2qc.low) )
	{
		case 0:  // Possible EOL
			G(c2qc.acc) = 0;    // Counts '0's until a '1' is found
			G(c2qc.state) = 23;
			break;

		case 1:  // Possible switch to 2D uncompressed mode
			G(c2qc.acc) = 0;   // Look for 3 additional '1's
			G(c2qc.state) = 30;
			break;

		case 2:  // VL(3)
			dif++;
		case 4:  // VL(2)
			dif++;
		case 8:  // VL(1)
			G(c2qc.run) = G(c2qc.ref_cnt) - G(c2qc.pel_cnt) - dif;  // Calculate run length
			update_code_line ();                              // Add run to coding line
			G(c2qc.pel_cnt) = G(c2qc.pel_cnt) + G(c2qc.run);  // Add run to pel total
			set_b1_pos ();                                  // Advance position of reference line
			G(c2qc.run) = 0;                                  // Set run to zero in case Horizontal mode is next
			break;

		case 3:  // VR(3)
			dif++;
		case 5:  // VR(2)
			dif++;
		case 9:  // VR(1)
			G(c2qc.run) = G(c2qc.ref_cnt) - G(c2qc.pel_cnt) + dif;  // Calculate run length
			update_code_line ();                              // Add run to coding line
			G(c2qc.pel_cnt) = G(c2qc.pel_cnt) + G(c2qc.run);  // Add run to pel total
			set_b1_pos ();                                  // Advance position of reference line
			G(c2qc.run) = 0;                                  // Set run to zero in case Horizontal mode is next
			break;

		case 6:  // Pass Mode
			adv_ref_ptr ();          // Add run on reference line to code line
			G(c2qc.run) = G(c2qc.ref_cnt) - G(c2qc.pel_cnt);  // Save run length in case Horizontal mode is next
			adv_ref_ptr ();          // Add next code on reference line to run length
			break;

		case 7:  // Horizontal Mode
			G(c2qc.stat) = G(c2qc.stat) | 0x20;  // Horizontal mode is now active

			if (G(c2qc.stat) & 0x01)  // Next run is black?
			{
				G(c2qc.acc) = 0;        // Count leading '0's
				G(c2qc.state) = 24;     // State to decode MH black code words (horizontal mode)
			}

			else  // Next run is white
			{
				G(c2qc.acc) = 0;        // Accumulate 1st four bits here
				G(c2qc.idx) = 4;        // Select link list based on 1st four bits (bit counter)
				G(c2qc.state) = 20;     // State to decode MH white code words (horizontal mode)
			}

			break;

		case 10:  // V(0)
			G(c2qc.run) = G(c2qc.ref_cnt) - G(c2qc.pel_cnt);  // Calculate run length
			update_code_line ();                              // Add run to coding line
			G(c2qc.pel_cnt) = G(c2qc.pel_cnt) + G(c2qc.run);  // Add run to pel total
			set_b1_pos ();                                  // Advance position of reference line
			G(c2qc.run) = 0;                                  // Set run to zero in case Horizontal mode is next
			break;

		default:  // Something is wrong
			G(c2qc.acc) = 0;
			G(c2qc.state) = 5;  // Re-sync with EOL
	}

	G(c2qc.low)   = 0;                               // Set low index to beginning of table
	G(c2qc.high)  = 10;                              // Set high index to end of table
}

// -------------------------------------------------------------- //
// Set the pointer for the reference line to the next b1 position //
// -------------------------------------------------------------- //
/*
		According to T.4 section 4.2.1.3.2, "b1   The first changing element on the reference line
		to the right of a0 and of opposite colour to a0."
*/
void set_b1_pos (void)
{
	byte color = G(c2qc.stat) & 0x01;  // Color to decode: 0 - white, 1 - black
	byte next;

	while (*G(c2qc.ref_line) != 0xFF)  // Don't go past EOL
	{
		next = *G(c2qc.ref_line) & 0x80 ? 1 : 0;  // Color of next run

		if (!(color ^ next) ||                        // Same colors?
				(G(c2qc.ref_cnt) <= G(c2qc.pel_cnt) ) )   // Reference line is behind coding line?
			adv_ref_ptr ();    // Advance position of reference pointer

		else        // Reference line is correctly positioned
			break;    // Exit loop
	}
}

// ---------------------------------------- //
// Convert DIS bit rate to +FDIS code value //
// ---------------------------------------- //

byte cnvt_bit_rate (word val)
{
#ifdef V34_FAX
	if (G(x_fax_v34mode) != NON_V34)   // Using V.34 modulation?
		return (getActualPRate ());  // Set remote capabilities to actual V.34 primary channel rate

	else
#endif

	switch ((val & 0x003C) >> 2)
	{
		case 0x02: return (1);  // 4,800 bps

		case 0x01:
		case 0x03: return (3);  // 9,600 bps

		case 0x0B:
		case 0x07: return (5);  // 14,400 bps

		case 0x00: return (0);  // 2,400

		default: return (0xFF);   // Invalid
	}
}

// ----------------------------------------- //
// Convert DIS scan time to +FDIS code value //
// ----------------------------------------- //

byte cnvt_scan_time (word val)
{
	static const byte tbl[] = {5,1,3,4,7,6,2,0};

	return ( tbl [(val & 0x0070) >> 4] );
}

// ---------------------------------------- //
// Compare two bytes and return the smaller //
// ---------------------------------------- //

byte smaller (byte n1, byte n2)
{
	if (n1 <= n2)
		return (n1);
	else
		return (n2);
}

// --------------------------------------------------------------//
// Initialization for the c2p structure used for Class 2/2.0/2.1 //
// ------------------------------------------------------------- //

void initialize_c2p (void)
{
	static const byte ifdcc [] = {1, 5, 0, 2, 0, 0, 0, 0};   // Class 2 default settings
	byte i;

	for (i=0; i<8; i++)       // Initialize all 8 components of +FDCC (CLASS 2.0:+FCC) and +FDIS (CLASS 2.0:+FIS)
	{
		G(c2p.fdcc.pa[i]) = ifdcc[i];          // +FDCC (+FCC)
		G(c2p.fdis.pa[i]) = G(c2p.fdcc.pa[i]); // +FDIS (+FIS)
		G(c2p.fdcs.pa[i]) = 0;                 // +FDCS (+FCS)
	}

#ifdef CLASS20_FAX
		G(c2p.fdcc.ps.jp) = 0;  // Initial color parameters to defaults
		G(c2p.fdis.ps.jp) = 0;
		G(c2p.fdcs.ps.jp) = 0;
#endif

	for (i=0; i<20; i++)        // Store NULL string in +FLID (+FLI)
	{
		G(c2p.flid[i]) = ' ';		     // Fill with blanks
		G(c2p.fcig[i]) = ' ';        // +FCIG (+FPI) Polling ID
		G(c2p.fnss[i]) = 0;          // +FNSS (+FNS) Non-Standard Facilities
#if defined (IWF_FAX) || defined (CLASS20_FAX)
		G(c2p.fpa[i])  = ' ';        // Class 2.0 Selective Polling Address
		G(c2p.fpw[i])  = ' ';        // Class 2.0 Password
		G(c2p.fsa[i])  = ' ';        // Class 2.0 Destination Sub-Address
#endif
	}

	G(c2p.fnss_idx) = 0;         // Index into c2p.fnss[]
	G(c2p.fpts)     = 1;         // (+FPS)
	G(c2p.fphcto)   = 30;        // +FPHCTO = 3 seconds, (+FCT = 30 seconds)
	G(c2p.faxerr)   = 0;         // (+FHS)
	G(c2p.fminsp)   = 0;         // (+FMS)
	G(c2p.fet)      = 0;         // (+FET)
#ifdef FAX_ECM
	G(c2p.fctcrty)  = 0;         // (+FCTCRTY)
#endif
	G(c2p.fbadmul)  = 20;        // Receive error rate of 5%  (+FRQ.pgl)
	G(c2p.fbadlin)  = 5;         // Consecutive bad line: VR=0:5 lines; VR=1:10 lines (+FRQ.cbl)
	G(c2p.sbf)      = 0x10;      // +FCR=1 -- Able to receive FAXs
	G(c2p.dbf)      = 0;

#if defined (IWF_FAX) || defined (CLASS20_FAX)
	#ifdef V34_FAX
		G(x_fax_maxp)  = 5;    // Default to V.17, 14,400 BPS
		G(x_fax_minp)  = 0;    // No preferred minimum primary channel rate
		G(x_fax_prefc) = 0;    // No preferred control channel rate
	#endif

	if (G(c2p.fclass) != 0x20)    // +FIP should not change +FCLASS (if not 2.0, must be 0 or junk on PWR UP)
#endif
		G(c2p.fclass) = 0;					 // Default to data mode

#if defined (IWF_FAX) || defined (CLASS20_FAX)
	if (G(c2p.fclass) == 0x20)      // Class 2.0 set?
	{
		G(c2p.fbadmul) = 95;     // (+FRQ.pgl) 95 percent good lines needed for "good" page
		G(c2p.fbadlin) = 6;      // (+FRQ.cbl) Less than 6 consecutive bad lines for "good" page
		G(c2p.dbf)     = 0x0100; // Enable receive quality checking
	}

	G(c2p.db)  = 0;        // Dummy byte for +FAP & +FFC
	G(c2p.fnr) = 0;        // Don't display FTI, FCI, FCS or FIS information
	G(c2p.fap) = 0;        // Disable address & polling capabilities
#endif
}

// --------------------------------------- //
// Save Remote FAX Modem's VR Capabilities //
// --------------------------------------- //
// NOTE: Class 2 only supports VR = 0 or 1

void save_remote_vr (void)
{
#ifdef CLASS20_FAX
	if ( (G(c2p.fclass) == 0x20) &&       // Class 2.0/2.1 interface?
			 (G(io_hdlc_byte_count) >= 9) &&  // Bits for additional VR received?
			 (G(c2_dce_buf_ptr[8]) & 0x3F) )  // Additional VR bits not zero?
	{
		byte vr;
		byte bits = G(c2_dce_buf_ptr[8]) & 0x3F;  // Save extended VR bits

		vr =      bits & 0x01 ? 0x02 : 0x00;   // R8 x 15.4 l/mm?
		vr = vr | (bits & 0x02 ? 0x40 : 0x00);   // 300 x 300 pels/in?

		if (G(c2_dce_buf_ptr[4]) & 0x40)       // Bit 15 (R8 x 7.7 l/mm) set?
		{
			vr = vr | (bits & 0x08 ? 0x10 : 0x00); // 200 x 200 pels/in?
			vr = vr | (bits & 0x10 ? 0x01 : 0x00); // R8 x 7.7 l/mm?
		}

		else if (bits & 0x08)  // Inches preferred?
			vr = vr | 0x08;      // 200 x 100 pels/in

		if (bits & 0x04)  // Bit 43 (R16 x 15.4 l/mm) set?
		{
			vr = vr | (bits & 0x08 ? 0x20 : 0x00);  // 400 x 400 pels/in?
			vr = vr | (bits & 0x10 ? 0x04 : 0x00);  // R16 x 15.4 l/mm?
		}

		G(c2rf.dis.ps.vr) = vr;  // Save remote's VR capabilities
		G(c2rf.flag) = G(c2rf.flag) | ((G(c2_dce_buf_ptr[8]) & 0x20) ? MSLT_15_4 : 0);  // MSLT for higher VRs
	}

	else
#endif
		G(c2rf.dis.ps.vr) = (G(c2_dce_buf_ptr[4]) & 0x40) == 0x40;     // VR: Vertical resolution
}

// --------------------------------------- //
// Save Remote FAX Modem's DF Capabilities //
// --------------------------------------- //

void save_remote_df (void)
{
	byte df = 0;                      // 1D encoding

	if (G(c2_dce_buf_ptr[4]) & 0x80)  // 2D encoding?
		df = 1;

	if (G(io_hdlc_byte_count) > 6)
	{
		if (G(c2_dce_buf_ptr[6]) & 0x02)  // 2D uncompressed mode?
			df = 2;

		if (G(c2_dce_buf_ptr[6]) & 0x40)  // MMR (T.6) encoding?
			df = 3;
	}

	G(c2rf.dis.ps.df) = df;           // Save remote's capabilities
}

// --------------------------------- //
// Negotiate the appropriate VR value //
// --------------------------------- //

void negotiate_vr (void)
{
	byte vr = G(c2p.fdis.ps.vr) & G(c2rf.dis.ps.vr);  // Save compatible VRs
	byte dcs;

	if (vr & 0x20)       // 400 x 400 pels/in?
		dcs = 0x0C;        // 400 x 400; inches

	else if (vr & 0x04)  // R16 x 15.4?
		dcs = 0x04;        // R16 x 15.4; metric

	else if (vr & 0x02)  // R8 x 15.4?
		dcs = 0x01;        // R8 x 15.4; metric

	else if (vr & 0x40)  // 300 x 300 pels/in?
		dcs = 0x0A;        // 300 x 300; inches

	else if (vr & 0x11)  // 200 x 200 or R8 x 7.7?
	{
		G(c2_dce_buf_ptr[4]) = G(c2_dce_buf_ptr[4]) | 0x40;  // 200 x 200 pels/in or R8 x 7.7
		dcs = vr & 0x10 ? 0x08 : 0x00;  // inches : metric
	}

	else                 // 200 x 100 or R8 x 3.85
		dcs = vr & 0x08 ? 0x08 : 0x00;  // inches : metric

	G(c2_dce_buf_ptr[8]) = dcs;  // Send negotiated VR value

	if ( (G(c2rf.flag) & MSLT_15_4) &&   // T15.4 = 1/2 T7.7?
			 (dcs & 0x05) &&                 // Negotiated 15.4 l/mm or 400 lpi?
			!(G(c2_dce_buf_ptr[5]) & 0x10) ) // Not 0ms or 5ms MSLT?
	{
		byte mslt = G(c2_dce_buf_ptr[5]) & 0x70;  // Isolate MSLT

		if (mslt == 0x40)      // 40 ms negotiated?
			mslt = 0x00;         // Specify 20ms

		else if (mslt == 0x00) // 20ms negotiated?
			mslt = 0x20;         // Specify 10 ms

		else                   // 10ms negotiated
			mslt = 0x10;         // Specify 5ms

		G(c2_dce_buf_ptr[5]) = (G(c2_dce_buf_ptr[5]) & 0x8F) | mslt;  // Update MSLT for higher VR
	}
}

// --------------------------------- //
// Negotiate the appropriate DF value //
// --------------------------------- //

void negotiate_df (void)
{
	byte df = G(c2p.fdis.ps.df) < G(c2rf.dis.ps.df) ? G(c2p.fdis.ps.df) : G(c2rf.dis.ps.df);  // Save lower capabilities

	if ( (df == 3) &&                     // Both support MMR
			 (G(c2_dce_buf_ptr[6]) & 0x04) )  // ECM negotiated?
		G(c2_dce_buf_ptr[6]) = G(c2_dce_buf_ptr[6]) | 0x40;  // Select MMR

	else if (df >= 2)  // Support for 2D, uncompressed mode?
	{
		G(c2_dce_buf_ptr[6]) = G(c2_dce_buf_ptr[6]) | 0x02;  // Select 2D, uncompressed mode
		G(c2_dce_buf_ptr[4]) = G(c2_dce_buf_ptr[4]) | 0x80;  // Select 2D encoding also
	}

	else if (df == 1)  // 2D encoding; no uncompressed mode?
		G(c2_dce_buf_ptr[4]) = G(c2_dce_buf_ptr[4]) | 0x80;  // Select 2D encoding only
}

// ---------------------------- //
// Convert DCS bits to VR value //
// ---------------------------- //

void dcs2vr (void)
{
	#if defined(IWF_FAX) || defined(CLASS20_FAX)
		byte dcs = G(io_hdlc_byte_count) > 8 ? G(c2_dce_buf_ptr[8]) : 0;  // Get higher VR bits
		byte v77 = G(c2_dce_buf_ptr[4]) & 0x40;  // Save R8 x 7.7 bit
		byte vr;

		if (G(c2p.fclass) == 0x20)  // Using Class 2.0/2.1 interface?
		{
			if (dcs & 0x08)  // Inches specifed
			{
				vr = !v77 ? 0x00 : 0x10;                // 200 x 200?
				vr = vr | ((dcs & 0x02) ? 0x40 : 0x00); // 300 x 300?
				vr = vr | ((dcs & 0x04) ? 0x20 : 0x00); // 400 x 400?

				if (!vr)                                // No higher resolutions used?
					vr = 0x08;                            // 200 x 100
			}

			else  // Metric
			{
				vr = !v77 ? 0x00 : 0x01;                // R8 x 7.7
				vr = vr | ((dcs & 0x01) ? 0x02 : 0x00); // R8 x 15.4
				vr = vr | ((dcs & 0x04) ? 0x04 : 0x00); // R16 x 15.4
			}

			G(c2rf.dcs.ps.vr) = vr;   // Save negotiated VR
		}

		else
	#endif
			G(c2rf.dcs.ps.vr) = (G(c2_dce_buf_ptr[4]) & 0x40) == 0x40;       // VR: Vertical resolution
}

// ---------------------------- //
// Convert DCS bits to DF value //
// ---------------------------- //

void dcs2df (void)
{
	byte df = 0;

	if (G(c2_dce_buf_ptr[4]) & 0x80)  // 2D encoding selected?
		df = 1;

	if (G(io_hdlc_byte_count) > 6)  
	{
		if (G(c2_dce_buf_ptr[6]) & 0x02)  // 2D uncompressed mode?
			df = 2;

		if (G(c2_dce_buf_ptr[6]) & 0x40)  // MMR (T.6) encoding?
			df = 3;
	}

	G(c2rf.dcs.ps.df) = df;           // Save DF
}

// ---------------------------------------------------------------------- //
// Send a "white" line to remote FAX after 5 seconds of no data from host //
// ---------------------------------------------------------------------- //

void send_white_line (void)
{
	static const byte wl_1728[] = {0xB2, 0x59, 0x01};  // 01001101 1-0011010 1000 0000   1,728 pels per line
	static const byte wl_2048[] = {0x80, 0xCC, 0x0A};  // 00000001 0011-0011 0101 0000
	static const byte wl_2432[] = {0x80, 0xCB, 0x0A};  // 00000001 1101-0011 0101 0000
	static const byte wl_2592[] = {0x80, 0x8F, 0x0D};  // 00000001 1111-0001 1011 0000
	static const byte wl_3456[] = {0x80, 0x6F, 0x19};  // 00000001 1111-0110 1001 1000
	static const byte wl_4096[] = {0x80, 0x2F, 0x13};  // 00000001 1111-0100 1100 1000
	static const byte wl_4864[] = {0x80, 0x0F, 0xE8};  // 00000001 1111-0000 0001 0111   4,864 pels per line
	byte *ptr = (byte*)wl_1728;  // Default to 1,728 pels per line
	word pels = page_wd ();      // Get negotiated number of pels per line

	switch (pels)  // Set "white" line pointer based on negotiated pels per line
	{
		case 1728:
			ptr = (byte*)wl_1728;
			break;

		case 2048:
			ptr = (byte*)wl_2048;
			break;

		case 2432:
			ptr = (byte*)wl_2432;
			break;

		case 2592:
			ptr = (byte*)wl_2592;
			break;

		case 3456:
			ptr = (byte*)wl_3456;
			break;

		case 4096:
			ptr = (byte*)wl_4096;
			break;

		case 4864:
			ptr = (byte*)wl_4864;
			break;
	}

	write_dce_fifo (0x80);                      // Send EOL (NOTE: Assume after 5 seconds, DCE buffer is not full)

	write_dce_fifo (ptr[0]);                    // Send a "white" line
	write_dce_fifo (ptr[1]);
	write_dce_fifo (ptr[2]);
	write_dce_fifo (0x00);                      // Ensure any DTE data sent after this is seen as an EOL
	write_dce_fifo (0x00);

	if (G(c2_var1) > 5)                         // More than 5 bytes needed to meet MSLT?
	{
		G(c2_var3) = io_get_dce_tx_count ();      // Get space in DCE Tx queue (should be plenty)

		if (G(c2_var3) > (G(c2_var1) - 5) )       // Enough room in queue? (Don't overflow queue, MSLT errors can be tolarated)
			G(c2_var3) = G(c2_var1) - 5;            // Number of extra zero bytes to meet MSLT

		while (G(c2_var3)--)                      // Until enough fill characters are written to meet MSLT...
			write_dce_fifo (0x00);                  // Write fill characters
	}
}

// ----------------------------------- //
// Returns the number of PELs per line //
// ----------------------------------- //
/*
				WD          R8     R16     200     300     400
		A4 (215 mm)    1728   3456    1728    2592    3456
		B4 (255 mm)    2048   4096    2048     --      --
		A3 (303 mm)    2432   4864    2432     --      --
*/

word page_wd (void)
{
	byte vr = G(c2p.fdcs.ps.vr);  // Negotiated vertical resolution
	byte wd = G(c2p.fdcs.ps.wd);  // Negotiated page width
	word ppl = 1728;              // Default to R8 and A4
	static const word r8 [] = {1728, 2048, 2432};  // Number of pels per line for R8 based on page width
	static const word r16[] = {3456, 4096, 4864};  // Number of pels per line for R16 based on page width

	if ( (vr & 0x1B) || (vr == 0) ) // R8 or 200 dpi?
		ppl = r8[wd];

	else if (vr & 0x04)  // R16?
		ppl = r16[wd];

	else if (vr & 0x40)  // 300 dpi?
		ppl = 2592;

	else if (vr & 0x20)  // 400 dpi?
		ppl = 3456;

	return (ppl);
}

/* ----------------------------------------- */
/* Process Phase C Time-out for Transmission */
/* ----------------------------------------- */
/*
	Since the software timer is limited to 65.535 seconds and the phase C time-out can
	be up to 255 seconds, time greater than 65 seconds will be accumulated in variable
	c2_fct_accm in 65 second increments.  This accumulated time is subtracted from the phase
	C time-out value.  When the remaining time (difference) of the phase C time-out is
	less than 65 seconds, it is compared against the software timer for a time-out.
*/

byte check_phcto (void)
{
	byte r = 0;

#if defined(IWF_FAX) || defined(CLASS20_FAX)
	if (G(c2p.fclass) == 0x20)
	{
		if (G(c2p.fphcto))                            // Phase C time-out timer enabled?
		{
			byte adj_time = G(c2p.fphcto) - G(c2_fct_accm);  // Adjust phase C time-out timer

			if (G(c2p.fphcto) < 5)                     // Less than 5 seconds?
				adj_time = 5;                        // Minimum is 5 seconds of no data

			if ( adj_time < 65)                     // Less than 65 seconds left of Phase C time-out?
			{
				if (x_elapsed_time (G(c2s.timer)) > ( (word)adj_time * 1000) )  // Phase C time-out occured?
					r++;                              // Indicate Phase C time-out
			}

			else if (x_elapsed_time (G(c2s.timer)) > 65000 )  // Has 65 seconds expired?
			{
				G(c2s.timer) = x_current_time ();              // Reset 65 second timer
				G(c2_fct_accm) = G(c2_fct_accm) + 65;                // Update accumulated time
			}
		}
	}

	else
#endif
	{
		if (x_elapsed_time (G(c2s.timer)) >= 30000)  // 30 seconds expired?
			r++;                                       // Indicate Phase C time-out
	}

	return (r);	 // Return results
}

/* -------------------------------- */
/* Reset the Phase C Time-Out Timer */
/* -------------------------------- */

void reset_phcto (void)
{
#if defined(IWF_FAX) || defined(CLASS20_FAX)
	G(c2_fct_accm) = 0;                   // Reset the accumulated time
#endif
	G(c2s.timer) = x_current_time ();  // Reset the software timer
}

// ---------------------- //
// End of page processing //
// ---------------------- //

void page_end (void)
{
	word qc_bl;    // Bad line count from QC check function
	word qc_cbl;	 // Consecutive bad line count from QC check function
	word pbl;      // Bad line percent error
	word cblt;		 // Consecutive bad line threshold
	word buf[6];

	write_dte_fifo (DLE);               // Indicate end of page to DTE
	write_dte_fifo (ETX);
	G(c2p.fpts) = 1;					         // Assume page good for now

	if ( (G(c2p.dbf) & FCQ) &&
			(G(c2p.fbadmul) || G(c2p.fbadlin)) ) // Quality checking enabled?
	{
		get_qc_cnts (&qc_bl, &qc_cbl);   // Get bad lines and consecutive bad lines
#if defined(IWF_FAX) || defined(CLASS20_FAX)  
		if (G(c2p.fclass) == 2)
#endif
		{
			pbl = qc_bl * G(c2p.fbadmul);       // Calculate the percent of line error per page
			cblt = (word)G(c2p.fbadlin);	      // Threshold for normal resolution

			if (G(c2rf.dcs.ps.vr))	               // High resolution?
				cblt = cblt << 1;             // Double the threshold for high res.
		}
#if defined(IWF_FAX) || defined(CLASS20_FAX)  
		else
		{
			if (G(c2p.fbadmul) == 100)          // 100% good lines required? (Also, avoid divide by 0 below)
			{
				if (qc_bl)                    // Any errors in received data?
					pbl = G(c2_tcf_error_cnt);       // Cause a RTN (store line count)

				else
					pbl = 0;                   // Prevent RTP & RTN (no errors)
			}

			// Note: Class 2 formula: if (bad_lines_rcvd * fbadmul < total_lines) then page is good.
			// fbadmul = 1/percent_bad_lines  e.g.: for <5% bad lines, set +fbadmul = 20
			// However, Class 2.0 requires percent good lines to be specifed.  So, to minimize code changes,
			// percent good lines will be converted to a percent-bad-lines multiplier and used as with Class 2.
			// The following formula is used:  percent_bad_lines_multiplier = 100 / (100 - percent_good_lines)

			else
				pbl = (word)(((long)qc_bl * 100L ) /        // Bad lines in received FAX times 100
									(long)(100 - G(c2p.fbadmul)) );  // Convert to 1/percent_bad_line

			cblt = (word)G(c2p.fbadlin);        // Get tolerable, consecutive-bad-line threshold
		}
#endif
		if ( (G(c2p.fbadmul) && 							// Check bad lines enabled?
				(pbl >= (G(c2_tcf_error_cnt) >> 1) ) ) ||	// Half the allowable bad lines?
				(G(c2p.fbadlin) &&								// Check consecutive bad lines enabled?
				(qc_cbl >= (cblt >> 1) ) ) )		   // Half the allowable consecutive line error?
			G(c2p.fpts) = 3;                     // Page is good but request re-train (RTP)

		if ( (G(c2p.fbadmul) &&					  // Check bad lines enabled?
				(pbl >= G(c2_tcf_error_cnt)) ) ||  // Percent of bad lines too high?
				(G(c2p.fbadlin) &&					  // Check consecutive bad lines enables?
				(qc_cbl >= cblt) )	)		  // Consecutive bad lines too high?
			G(c2p.fpts) = 2;            // Page is bad; request re-train (RTN)
	}

	buf[0] = G(c2p.fpts);             // Load page status
	buf[1] = G(c2_tcf_error_cnt) - 2;    // Save number of lines (RTC adds 2 lines)
	buf[2] = 0;
	buf[3] = 0;

	if ( (G(c2p.dbf) & FCQ) &&
			(G(c2p.fbadmul) || G(c2p.fbadlin)) )         // Quality checking enabled?
	{
		if (G(c2p.fbadmul))                         // Bad line checking enabled?
			buf[2] = qc_bl;                        // Number of bad lines

		if (G(c2p.fbadlin))                          // Consecutive bad line checking enabled?
			buf[3] = qc_cbl;                        // Number of consecutive bad lines

		if (G(c2rf.flag) & CARRIER_GAP)  // Was there a gap in the carrier?
		{
			G(c2p.fpts) = 2;        // Force RTN when quality checking in on and there were carrier gaps
			buf[0] = G(c2p.fpts);   // Load new page status
		}
	}

#if defined(IWF_FAX) || defined(CLASS20_FAX)
	if (G(c2p.fclass) == 0x20)
		buf[4] = G(c2_ovr_cnt);
#endif

	load_rsp_fpts (buf);                    // Send +FPTS(+FPS) response to DTE
	G(c2p.faxerr) = 100;						            // Unspecified Receive Phase D error
}

// ------------------------------------------------------- //
// Filter the DLE-DLE expansion from a received HDLC frame //
// ------------------------------------------------------- //

void filter_rx_hdlc (void)
{
	word *src  = G(c2_dce_buf_ptr);
	word *dest = G(c2_dce_buf_ptr);
	byte cnt = 0;

	while (cnt < G(io_hdlc_byte_count))      // Until DLE-ETX encountered or end of message...
	{
		if (*src == DLE)                  // Pointing to first part of DLE-DLE or DLE-ETX pair?
		{
			src++;                         // Point to second part of pair

			if (*src == DLE)               // DLE-DLE pair?
				*dest = *src;               // Save only one DLE

			else                           // Assume it must be DLE-ETX
				break;                      // Stop un-filtering DCE message
		}

		else                              // Not DLE pair
			*dest = *src;                  // Shift bytes as necessary

		cnt++;                           // Increment number of bytes received
		dest++;                           // Next destination location
		src++;                            // Next source location
	}

	G(io_hdlc_byte_count) = cnt - 2;   // Subtract out FCS from count
}

#ifdef CLASS20_FAX
// ------------------------------------------------------------------------ //
// Check if Polling capability should be added to DCS/DTC command FIF field //
// ------------------------------------------------------------------------ //

byte chk_poll (byte mask, byte* ptr)
{
	byte rslt = 0;

	if (G(c2p.fap) & mask)        // Polling feature enabled?
	{
		byte j;

		for (j = 0; j < 20; j++)    // For each character of polling string...
		{
			if (ptr[j] != ' ')       // String programmed?
			{
				rslt = 1;              // Indicate feature enabled
				break;                 // Stop now
			}
		}
	}

	return (rslt);
}
#endif

// -------------------------------------- //
// Convert DIS scan time to DCS scan time //
// -------------------------------------- //

byte dcs_scan (void)
{
	static const byte scan [] =    {7,1,2,2,0,0,4,4};	 // Encode DCS scan time for 2.85 lines/mm
	static const byte scan1[] =    {7,1,1,2,2,0,0,4};  // Encode DCS scan time for 7.7 lines/mm
	byte i;

	if (G(c2rf.dis.ps.st) >= G(c2p.fdis.ps.st))	 // Select larger minimum scan line time
		i = G(c2rf.dis.ps.st);				 // Use remote FAX modem minimum scan line time
	else
		i = G(c2p.fdis.ps.st);				 // Use local FAX modem minimum scan line time

	if (G(c2rf.dis.ps.vr) & G(c2p.fdis.ps.vr))   // Vertical resolution 7.7 lines/mm?
		return (scan1[i] << 4);			 // Convert to high resolution min. scan line time
	else
		return (scan [i] << 4);			 // Convert to low resolution min. scan line time
}

// ---------------------------------------------------------- //
// Pre-Scan the DTE Tx data for End of lines (EOL) or DLE-ETX //
// ---------------------------------------------------------- //
/*
	T.4 encoding only allows insertion of "padding" (zero bytes)
	before the EOL pattern (000000000001) is sent.  Since the
	pump is setup to send 0x00 as the idle character, padding
	doesn't need to be written to the DCE Tx Buffer.  However,
	to insure that padding isn't inserted in the middle of a line,
	due to a momentary pause in DTE data, the next complete line must
	be in the buffer before an EOL is sent for the current line.  This
2	function pre-scans the DTE Tx data for EOLs and DLE-ETX (DLE-<ppm>)
	data patterns.

	The DTE data must also be filtered before EOLs are searched for. The
	following data pairs are filtered:

	DLE-DLE = DLE
	DLE-SUB = DLE-DLE (Class 2.0 only)
	DLE-MPS = Class 2.0 end of page, another follows
	DLE-EOM = Class 2.0 end of page, another follows with new parameters
	DLE-EOP = Class 2.0 end of page, end of session
	DLE-<xxx> = Unimplemented in-line control code, discarded

	Variable "rtc" stores the number of EOLs found in the DTE Rx buffer.
	Variable "G(c2_ps_rptr)" is the read pointer for scanning the DTE Rx buffer.
	Variable "G(c2_tcf_error_cnt)" is used to save the last byte scanned
	Variable "G(c2_tcf_zeros_needed)" is used to count consecutive '0' bits
	Bit "G(c2rf.flag){3}" indicates if a DLE-ETX was found.
*/

void pre_scan_tx_data (void)
{
	byte data, mask, loop, last_byte, zeros;

#if defined(IWF_FAX) || defined(CLASS20_FAX)
	if (G(c2p.sbf) & FND)                         // Sending non-standard data?
	{
		if (I(io_dte_rx_wptr) != I(io_dte_rx_rptr))    // Any data from DTE?
			G(c2_ps_eol) = 2;                            // Cause data to be transmitted now

		else
			G(c2_ps_eol) = 0;                            // Cause time-out timer to be checked

		return;
	}
#endif
	last_byte = (byte)G(c2_tcf_error_cnt);         // Get previous byte from last time (more meaningful name & use byte ops)
	zeros = (byte)G(c2_tcf_zeros_needed);          // Get previous number of consecutive 0's (Save as above)

	while (G(c2_ps_rptr) != I(io_dte_rx_wptr))        // Until all new bytes are checked...
	{
		data = *G(c2_ps_rptr)++;                    // Get Tx byte, increment pointer
		loop = 1;                             // Assume only 8 bits of data will be checked

		if (G(c2_ps_rptr) >= I(io_dte_rx_eptr))        // Wrap around to beginning?
			G(c2_ps_rptr) = (byte*)I(io_dte_rx_sptr);    // Set pointer to beginning of buffer

		if (last_byte == DLE)                 // Was previous byte a DLE?
		{
			if (dle_filter (&data, &loop))     // DLE filter, End of page?
			{
				G(c2rf.flag) = G(c2rf.flag) | END_OF_PAGE; // Indicate end of page is in buffer
				break;                           // Stop pre-scanning
			}

			last_byte = 0;                     // Make sure previous byte is not a DLE
		}

		else if (data == DLE)                 // Is the current byte a DLE?
		{
			loop = 0;                          // Don't process bits yet
			last_byte = data;                  // Update previous byte
		}

		else                                  // Not processing DLE-<xxx> pair
			last_byte = data;                  // Update previous byte

		while (loop--)                        // Check 0, 1 or 2 bytes
		{
			for (mask = 1; mask; mask = mask << 1)  // For each bit, right to left...
			{
				if (data & mask)                // '1' bit?
				{
					if (zeros >= 11)             // At least 11 zeros preceeded this '1' bit?
						G(c2_ps_eol)++;                 //

					zeros = 0;                   // Reset '0' bit counter
				}

				else                            // '0' bit
					zeros++;                     // Increment '0' bit counter
			}
		}

		if (zeros > 11)  // Limit number of consecutive '0's
			zeros = 11;
	}

	G(c2_tcf_error_cnt) = (word)last_byte;         // Save previous byte
	G(c2_tcf_zeros_needed) = (word)zeros;          // Save consecutive zero bits
}

// --------------------------------------- //
// Check for and Process a Receive Overrun //
// --------------------------------------- //

void chk_rx_overrun (void)
{
#if defined(IWF_FAX) || defined(CLASS20_FAX)
	word v1, cnt;

	if (G(c2p.fclass) == 0x20)
	{
		cnt = io_get_dte_tx_count();       // Number of empty locations left in DTE Tx buffer
		v1 = io_get_dce_rx_count ();       // Number of byte left in the DCE Rx queue

		if (v1 > cnt)                      // DCE FIFO backing up?
		{
			if (!(G(c2rf.flag) & 2))                // Overrun marker not sent to DTE yet?
			{
				G(c2rf.flag) = G(c2rf.flag) | 2;          // Indicate overrun marker has been sent to DTE
				write_dte_fifo (DLE);	        // Insert overrun error marker in data stream
				write_dte_fifo ('O');
			}

			G(c2_ovr_cnt) = G(c2_ovr_cnt) + v1;         // Update number of bytes lost due to overrun
#ifndef CS_4
			disable_interrupt ();
#else
			_int_disable();
#endif
			io_init_dce_rx_fifo ();         // Flush "newest" data in DCE Rx queue
#ifndef CS_4
			enable_interrupt ();
#else
			_int_enable();
#endif
		}
	}
#endif
}

// ----------------------------------- //
// Perform DLE-<xxx> filtering on data //
// ----------------------------------- //

byte dle_filter (byte* cptr, byte* lptr)
{
	byte data = *cptr;

	if (data != DLE)                // Is character pair not DLE-DLE?
	{
		if ( (data == ETX)           // End of page for Class 2?
	#if defined(IWF_FAX) || defined(CLASS20_FAX)
			|| (data == DLE_MPS)      // End of page for Class 2.0?
			|| (data == DLE_EOM)
			|| (data == DLE_EOP)
	#endif
			)
				return (1);            // Indicate end of page to calling function

	#if defined(IWF_FAX) || defined(CLASS20_FAX)
		else if (data == DLE_SUB)    // Class 2.0 DLE-SUB character pair?
		{
			*cptr = DLE;              // Change SUB to DLE (DLE-SUB expands to DLE-DLE)
			*lptr = 2;                // Process twice
		}
	#endif

		else                         // DLE-<yyy>: Un-implemented in-band control
			*lptr = 0;                // Ignore it
	}

	return (0);                     // Indicate not end of page
}

// ------------------------------------ //
// Signal Class 2 from IO_MAIN function //
// ------------------------------------ //

void signal_class2 (void)
{
	G(c2s.flag) = G(c2s.flag) | CARRIER_DET;   // Indicate preamble sent
}

// ------------------------------------------------ //
// Receive action command from ATFAX_C2 () function //
// ------------------------------------------------ //

void send_cl2_cmd (byte cmd)
{
	G(c2s.dte_cmd) = cmd;	 // Save the command in buffer
	G(c2s.flag) = G(c2s.flag) & ~AT_ENABLE;  // Disable AT-Command processing
}

// ------------------------------------------ //
// Set State of Dynamic Bit for T.30 Commands //
// ------------------------------------------ //

void set_t30_bit (byte state)
{
	G(c2rf.flag) = 0;

	if (state)                             // Originate mode?
		G(c2rf.flag) = G(c2rf.flag) | T30_BIT;   // Dynamic bit is 1

	else                                   // Answer mode
		G(c2rf.flag) = G(c2rf.flag) & ~T30_BIT;  // Dynamic bit is 0
}
#endif  // CLASS2_FAX || CLASS20_FAX

