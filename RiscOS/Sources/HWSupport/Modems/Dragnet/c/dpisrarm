/*name and version number:@(#)dpisrarm.c	1.1*/
/*date of get: 		  12/15/00 10:10:56*/
/*date of delta:	  11/30/00 21:21:28*/
/****************************************************************
File :	dpisrarm.c
Description :

Revision History :
*****************************************************************/

#include "llglob_d.h"	// modify this loc as needed
#include "iouart_d.h"
#include "ioglob_d.h"
#include "dpglob.h"
#include "z80glob.h"
#include "z80flash.h"
#if defined(HDLC_FRAMES_BY_REFERENCE)
# include "lapm.h"
#endif
#include "allglobs.h"

//#define BaseAddress		0x108
#if defined(DRAGNET)
unsigned short BaseAddress=0x260;			// variable BaseAddress
#else
unsigned short BaseAddress=0x108;			// variable BaseAddress
#endif
#define BaseAddressData	((unsigned short) (BaseAddress+1))
#define BaseAddress2	((unsigned short) (BaseAddress+2))

static byte dp_isr_regb0;
word BaseAddressIndex;
byte BaseValue;
byte *datap ;
word firstWord;

/****************************************************************
Routine : dual_port_tx ( void )
****************************************************************/
void dual_port_tx ( void )
{
	byte dp_isr_count, dp_dsp_tx_ptr ;

	//---------------------------------------------------
	// Look in DCE Ring Buffer for next frame to send.
	//---------------------------------------------------
	if ( io_dce_tx_rptr != io_dce_tx_wptr )
	{
		firstWord = *io_dce_tx_rptr;

		#if defined(HDLC_FRAMES_BY_REFERENCE)
		//------------------------------------------------
		// There is a frame present; is it an I Frame,
		// Supervisor Frame, or Unnumbered frame?
		//------------------------------------------------
		if ( firstWord & HDLC_IFRAME_PLACEHLDR )
		{
			word *hiWordDatapp, *loWordDatapp;

			/*********************************************
			**			It's an I Frame.
			**********************************************
			** A three word structure in the DCE ring
			** buffer actually represents the frame.
			** The format of an I Frame placeholder is:
			**	1st wd:		( FLAG(s) | count )
			**	2nd wd:		(upper data ptr)
			**	3rd wd:		(lower data ptr)
			*********************************************/

			//------------------------------------------
			// Get the count from the DCE ring buffer.
			//------------------------------------------
			dp_isr_count = (byte) firstWord;

			//------------------------------------------
			// Get the I Frame data ptr from DCE ring
			// buffer (must handle end of buffer wrap).
			//------------------------------------------
			//--------------------------------------
			// get data pointer from DCE ring buffer
			//--------------------------------------
			hiWordDatapp = G(io_dce_tx_rptr) + 1;
			if ( hiWordDatapp >= G(io_dce_tx_eptr) )
				hiWordDatapp = G(io_dce_tx_sptr);
			loWordDatapp = hiWordDatapp + 1;
			if ( loWordDatapp >= G(io_dce_tx_eptr) )
				loWordDatapp = G(io_dce_tx_sptr) ;
			datap = (byte *)((*hiWordDatapp)<<16 | *loWordDatapp);

			//-------------------------------------------
			// If new frame signal DSP to start a new
			// HDLC frame, and clear flag for LAPM layer.
			//-------------------------------------------
			if ( firstWord & HDLC_START_OF_FRAME )
			{
				dp_isr_regb0 = 0x40 ;
				*(datap-1) = 0;
			}
			else
			{
				dp_isr_regb0 = 0 ;
			}

			//------------------------------------------
			// Copy data into TX Mailbox area (80-8f)
			//------------------------------------------
			if ( dp_isr_count >= 16 )
			{
				//-----------------------------------------------
				// Send full 16 bytes and .....
				//-----------------------------------------------
				DP_INT_REGWRITE( 0x80, *datap        ) ;
				DP_INT_REGWRITE( 0x81, *(datap+0x01) ) ;
				DP_INT_REGWRITE( 0x82, *(datap+0x02) ) ;
				DP_INT_REGWRITE( 0x83, *(datap+0x03) ) ;

				DP_INT_REGWRITE( 0x84, *(datap+0x04) ) ;
				DP_INT_REGWRITE( 0x85, *(datap+0x05) ) ;
				DP_INT_REGWRITE( 0x86, *(datap+0x06) ) ;
				DP_INT_REGWRITE( 0x87, *(datap+0x07) ) ;

				DP_INT_REGWRITE( 0x88, *(datap+0x08) ) ;
				DP_INT_REGWRITE( 0x89, *(datap+0x09) ) ;
				DP_INT_REGWRITE( 0x8a, *(datap+0x0a) ) ;
				DP_INT_REGWRITE( 0x8b, *(datap+0x0b) ) ;

				DP_INT_REGWRITE( 0x8c, *(datap+0x0c) ) ;
				DP_INT_REGWRITE( 0x8d, *(datap+0x0d) ) ;
				DP_INT_REGWRITE( 0x8e, *(datap+0x0e) ) ;
				DP_INT_REGWRITE( 0x8f, *(datap+0x0f) ) ;
				dp_dsp_tx_ptr = 0x90 ;

				//-----------------------------------------------
				// ...check for End of Frame....
				//-----------------------------------------------
				if ( dp_isr_count > 16 )
				{
					//-----------------------------------------------
					// .... NOT Done with this frame yet;
					//-----------------------------------------------
					// adjust the count and datap in the
					// two word DCE ring Buffer structure
					// (removing the SOF flag).
					//-----------------------------------------------
					*io_dce_tx_rptr = (word)(HDLC_IFRAME_PLACEHLDR
												| (dp_isr_count-16));
					datap += 16;
					*hiWordDatapp = (word) ((uint_32)datap>>16);
					*loWordDatapp = (word) (unsigned long) (datap);
				}
				else
				{
					//-----------------------------------------------
					// .... Done with this frame
					//-----------------------------------------------
					// ..... skip over two word structure
					//  and set EOF in the trigger byte
					//  (done below)
					//-----------------------------------------------
					dp_isr_count = 0;
				}
			}
			else
			{
				//-----------------------------------------------
				// Done with this frame;
				// Send remaining (up to 15) bytes and .....
				//-----------------------------------------------
				dp_dsp_tx_ptr = 0x80;
				while ( dp_isr_count )
				{
					DP_INT_REGWRITE( dp_dsp_tx_ptr++, *datap++ ) ;
					dp_isr_count-- ;
				}
			}

			//-----------------------------------------------
			// Done with this frame ??
			//-----------------------------------------------
			if ( dp_isr_count == 0 )
			{
				//-----------------------------------------------
				//		Yes ...
				//-----------------------------------------------
				// ..... skip over three word structure
				//  and set EOF in the trigger byte
				//-----------------------------------------------
				if ( ++loWordDatapp >= io_dce_tx_eptr )
					io_dce_tx_rptr = io_dce_tx_sptr ;
				else
					io_dce_tx_rptr = loWordDatapp;

				//---------------------------------------
				// Signal to DSP end of the HDLC frame
				//---------------------------------------
				dp_isr_regb0 |= 0x80 ;

				//---------------------------------------
				// Signal lapm task to place another
				// iframep in DCE Ring Buffer.
				// Chk for zero is sanity test - should
				// never happen.
				//---------------------------------------
				if ( lapm_max_iframes ) lapm_max_iframes -- ;
			}
		}
		else
		#endif	// HDLC_FRAMES_BY_REFERENCE
		{
			dp_dsp_tx_ptr = 0x80;

			if ( firstWord & HDLC_TX_ANY_CHAR )
			{
				dp_isr_count = 0x85 ; // send max. 6 bytes
				dp_isr_regb0 = 0x20 ;
			}
			else
			{
				dp_isr_count = 0x8f ; // send max. 16 bytes
				dp_isr_regb0 = (byte) (firstWord & HDLC_START_OF_FRAME ? 0x40 : 0);
			}

			while ( (dp_dsp_tx_ptr <= dp_isr_count)
					&& (io_dce_tx_rptr != io_dce_tx_wptr) )
			{
				DP_INT_REGWRITE( dp_dsp_tx_ptr++, (byte)*io_dce_tx_rptr ) ;
				if ( *io_dce_tx_rptr & HDLC_END_OF_FRAME )
				{
					if ( ++io_dce_tx_rptr >= io_dce_tx_eptr )
						io_dce_tx_rptr = io_dce_tx_sptr ;
					dp_isr_regb0 |= 0x80 ;
					break ;
				}
				if ( ++io_dce_tx_rptr >= io_dce_tx_eptr )
					io_dce_tx_rptr = io_dce_tx_sptr ;

				// check SOF for V.80 support - needed
				// for framed mode without CRC
				if ( *io_dce_tx_rptr & HDLC_START_OF_FRAME )
				{
					break ;
				}
			}
		}

		dp_dsp_data_in_progress = TRUE ;
		DP_INT_REGWRITE( 0xb0, (byte)(dp_isr_regb0|(dp_dsp_tx_ptr-0x80)) );
	}
	else
	{
		dp_dsp_data_in_progress = FALSE ;
		DP_INT_REGWRITE( 0xb7, 0x01 ) ; // clear tx interrupt
	}
}

/****************************************************************
Routine : dual_port_rx ( void )
****************************************************************/
void dual_port_rx ( void )
{
	byte dp_isr_regb0, dp_isr_count, dp_rx_ptr ;
	unsigned short *first_ptr, *last_ptr = NULL;

	dp_isr_regb0 = DP_INT_REGREAD( 0xb0 ) ;

	dp_isr_count = (byte) (dp_isr_regb0 & 0x1f); // count
	if ( dp_isr_count == 0 )
	{
		x_debug_msg ( "DP - illegal rx status 0xb0" ) ;
	}
	else
	{
		dp_rx_ptr = 0x90 ;
		first_ptr = io_dce_rx_wptr ;
		// copy data into fifo
		while ( dp_isr_count-- )
		{
			*io_dce_rx_wptr = DP_INT_REGREAD2( (byte)(dp_rx_ptr++) ) ;

			last_ptr = io_dce_rx_wptr++ ;
			if ( io_dce_rx_wptr >= io_dce_rx_eptr )
				io_dce_rx_wptr = io_dce_rx_sptr ;

			if ( io_dce_rx_wptr == io_dce_rx_rptr )
    			x_debug_msg ("dual_port_rx - read overflow!!");
		}
		if ( dp_isr_regb0 & 0xe0 ) // crc error or start/end of frame
		{
			if ( dp_isr_regb0 & 0x20 ) // if start-of-frame
				*first_ptr |= HDLC_START_OF_FRAME ;
			if ( dp_isr_regb0 & 0xc0 )	// EOF (or) crc error
			{
				*last_ptr |= HDLC_END_OF_FRAME ;
				if ( dp_isr_regb0 & 0x40 ) // crc error (or) abort
				{
					*last_ptr |= HDLC_CRC_ERROR;
					//x_debug_msg("dp_bad_crc_count++");
					dp_bad_crc_count++;
				}
			}
		}
	}

	// 2nd dummy read to trigger dsp to write more data
	DP_INT_REGREAD( 0xb0 ) ;
}

#if defined( DSP_POLLED_MODE )
/****************************************************************
Routine : dp_dsp_polled
Description :
    pseudo-interrupt handler.  looking for events
	that would have been interrupts had interrupts
	been enabled.

	assume interrupts are not disabled
*****************************************************************/
void
dp_dsp_polled ( byte dp_isr_regd7 )
{
	byte dp_isr_regb6 ;

	dp_regwrite( 0xd7, 0xff ) ;

	//---------------------------------------------
	// ring edge interrupt ?
	//---------------------------------------------
	if ( dp_isr_regd7 & BIT1 )
	{
		// clear all interrupts on camil
		dp_regwrite( 0xd8, 0xff ) ;

		// ignore first 2 ring interrupts
		if ( G(dp_ring_int_count) > 1 )
		{
			x_debug_msg ( "dp - int : ring" ) ;
			G(dp_ring_int) = TRUE ;

			//-----------------------------------------
			// disable ring interrupt after first edge
			//-----------------------------------------
			G(dp_bamil_rd7) |= BIT1 ;

			// init when wake up from sleep
			dp_init_local_phone_timer () ;
		}

		// increment ring interrupt count
		G(dp_ring_int_count)++  ;
	}

	//---------------------------------------------
	// write bank interrupt ?
	//---------------------------------------------
	if ( dp_isr_regd7 & BIT3 )
	{
		//---------------------------------------------
		// this is a response to a command - clr CWBANK
		//---------------------------------------------
		dp_regwrite( 0xd8, 0x08 ) ;
		G(dp_byte_c) = dp_regread( 0x32 ) ;
		G(dp_byte_d) = dp_regread( 0x33 ) ;
		G(dp_byte_e) = dp_regread( 0x34 ) ;
		G(dp_byte_f) = dp_regread( 0x35 ) ;
	}

	//---------------------------------------------
	// dual-port data interrupt ?
	//---------------------------------------------
	if ( dp_isr_regd7 & BIT2 )
	{
		dp_isr_regb6 = dp_regread( 0xb6 ) ;

		if ( dp_isr_regb6 & BIT4 )
		{
			//----------------------
			// Receive data from DSP
			//----------------------
			dual_port_rx () ;
		}

		if ( dp_isr_regb6 & BIT0 )
		{
			//----------------------
			// Transmit data to DSP
			//----------------------
			dual_port_tx () ;
		}
	}
}
#endif

/****************************************************************
Routine : dp_regwrite
	Write a CAMILZ register - it's ok if interrupts are
		enabled or disabled.  Can't be called from the dp
		interrupt handler.
*****************************************************************/
void dp_regwrite ( byte reg, byte value )
{
	// BaseValue is saved so that if this is interrupted
	// we can put back the proper value into the index register
	// and write the correct value.
	BaseValue = reg ;

	BaseAddressIndex = BaseAddress ;
	* ( (byte *) BaseAddress )  = reg;
	* ( (byte *) BaseAddressData )  = value;
}

/****************************************************************
Routine : dp_regread
	read a CAMILZ register - it's ok if interrupts are
		enabled or disabled.  Can't be called from
		the dp interrupt handler.

	For bamil register read,
		if register <= 0x7f
		or register >= 0xa0 && <= 0xcf
			Index Address = BaseAddress + 0
			Data  Address = BaseAddress + 1

		if register >= 0x80 && <= 0x9f
		or register >= 0xd0
			Index Address = BaseAddress + 2
			Data  Address = BaseAddress + 1
*****************************************************************/
byte dp_regread ( byte reg )
{
	// BaseValue is saved so that if this is interrupted
	// we can put back the proper value into the index register
	// and write the correct value.
	BaseValue = reg ;

	if ( ( reg <= 0x7f ) || ( ( reg >= 0xa0 ) && ( reg <= 0xcf ) ) )
	{
		* ( (byte *) BaseAddress )  = reg;
		BaseAddressIndex = BaseAddress ;
	}
	else 
	{
		* ( (byte *) BaseAddress2 )  = reg;
		BaseAddressIndex = BaseAddress2 ;
	}
	
	return  ( * (byte *) ( BaseAddressData  ) ) ;
}


//#define	QMP_PRESENT		// This (venus/cs4) chip has QMP (not Apollo)
#define QMP_FIFO_WORDS	64

extern void w_trace(char *);

#if defined(QMP_PRESENT)
/****************************************************************
Routine : qmp_write
	Write words of data to external memory using QMP mode.

	This is the fastest way to do downloads.  Some parts, however,
	don't have the QMP block, so this isn't possible.

*****************************************************************/
void
qmp_write ( word *srcp, U32 dstLoc, byte wdcnt )
{
	word t;

	if ( wdcnt > QMP_FIFO_WORDS )
	{
		x_debug_msg("Bad WordCnt");
		return;
	}

	//------------------------------------
	// Enable QMP and 16 bit access
	// Must Enable RMP first!!
	//------------------------------------
	_outp(RMPMR, 0);			// Enable RMP
	_outp(RMPMR, BIT0);			// Enable QMP
	_outp(QMPHCS, BIT1|BIT0);	// Enable 16-bit access

	//------------------------------------
	// Clear TX fifo and select transmit
	// register bank (and 1 ws)
	//------------------------------------
	_outp(QMPACS, BIT6|BIT3|BIT2 ) ;

	t = x_current_time();

	//------------------------------------
	// wait for completion of write.
	//------------------------------------
	while ( !(_inp( QMPHI ) & BIT1) )
	{
		if (x_elapsed_time(t) > MS100)
		{
			w_trace("QMP - TX TIMEOUT (first wait)");

			//------------------------------------
			// Put host interface back in DIA mode
			// (going first back to RMP mode)
			// Note: Don't change the 8 bit / 16
			// bit switch!!!
			//------------------------------------
			_outp( QMPHCS, BIT1 ) ;
			_outp( RMPMR, BIT7 ) ;
			dpFailure = 1;
			return;
		}
	}

	//------------------------------------
	// Clear host interrupts
	//------------------------------------
//	_outp(QMPHI, 0 ) ;

	//------------------------------------
	// set TX address register
	//------------------------------------
	_outpw(QMPAL, (word)((U32)dstLoc&0xffff) ) ;
	_outpw(QMPAM, (word)((U32)dstLoc>>16) ) ;

	//------------------------------------
	// Enable Xmit DMA with one wait state		// can rcv be hurt?
	//------------------------------------
	_outp(QMPACS, BIT3|BIT2|BIT1 ) ;

	//------------------------------------
	// load the TX fifo
	//------------------------------------
	while ( wdcnt-- )
	{
		_outpw( QMPD, (word) *srcp++);
	}

	//------------------------------------
	//  start the transfer
	//------------------------------------
	_outp( QMPHCS, BIT3|BIT1|BIT0 ) ;

	t = x_current_time();

	//------------------------------------
	// wait for completion of write.
	//------------------------------------
	while ( !(_inp( QMPHI ) & BIT1) )
	{
		if (x_elapsed_time(t) > MS100)
		{
			w_trace("QMP - TX TIMEOUT (second wait)");
			break ;
		}
	}

	//------------------------------------
	// Put host interface back in DIA mode
	// (going first back to RMP mode)
	// Note: Don't change the 8 bit / 16
	// bit switch!!!
	//------------------------------------
	_outp( QMPHCS, BIT3|BIT1);
	_outp( RMPMR, BIT7 );
}
#endif

//#define VERIFY_DOWNLOAD

#if !defined(DRAGNET)
/****************************************************************
Routine : rmp_write
	Write words of data to external memory using RMP mode.

*****************************************************************/
void
rmp_write ( word *srcp, U32 dstLoc, byte wdcnt )
{
	dstLoc <<= 1;		// convert address from words to bytes

	// RMP mode
	_outp(RMPMR, 0);			// Enable RMP

	// address
	_outp(RMPAL, (byte)(dstLoc & 0xff) ) ;
	_outp(RMPAM, (byte)((dstLoc>>8) & 0xff) ) ;
	_outp(RMPAH, (byte)((dstLoc>>16) & 0x0f) ) ;

	// auto increment write to memory
	_outp(RMPMR, BIT6|BIT4);

	while (wdcnt--)
	{
		byte b0 = (byte) (*srcp & 0xff);
		byte b1 = (byte) ((*srcp >> 8) & 0xff);
		word t = x_current_time();

		// write first data byte of this word
		_outp(RMPD, b1);

		// poll 'til it's done
		//------------------------------------
		// wait for completion of write.
		//------------------------------------
		while (_inp( RMPMR ) & BIT5)
		{
#if defined(VERIFY_DOWNLOAD)
			if (x_elapsed_time(t) > MS100)
			{
				w_trace("RMP - TX TIMEOUT (first wait)");

				//------------------------------------
				// Put host interface back in DIA mode
				//------------------------------------
				_outp( RMPMR, BIT7 ) ;
				dpFailure = 1;
				return;
			}
#endif
		}

		// write second data byte of this word
		_outp(RMPD, b0);

		// poll 'til it's done
		//------------------------------------
		// wait for completion of write.
		//------------------------------------
		while (_inp( RMPMR ) & BIT5)
		{
#if defined(VERIFY_DOWNLOAD)
			if (x_elapsed_time(t) > MS100)
			{
				w_trace("RMP - TX TIMEOUT (first wait)");

				//------------------------------------
				// Put host interface back in DIA mode
				//------------------------------------
				_outp( RMPMR, BIT7 ) ;
				dpFailure = 1;
				return;
			}
#endif
		}
		srcp++;			// next word to download
	}

	//------------------------------------
	// Put host interface back in DIA mode
	//------------------------------------
	_outp( RMPMR, BIT7 ) ;
}

#endif

#if defined(COMPRESS_TABLES)

#include "cplut.h"

word cp_flag;
short cp_cur;
short cp_next;
char cp_zero_zone;
char cp_cur_flag_ctr;

word *pcp_pcnt;
word *pcp_pflag;
unsigned char *pcp_pcode;

/****************************************************************
Routine : decode_word()
Description :
	Decode the next word of the compressed DSP code.
*****************************************************************/
short decode_word(word *ptr)
{
	if ((cp_cur--) <= cp_next)
	{
		cp_next = *pcp_pcnt++;
		cp_zero_zone = (char) (!cp_zero_zone);
	}
	if (cp_cur < 0)
		return 0;

	if (cp_zero_zone)
		*ptr = 0;		// zero's are treated as a special case
	else
	{
		if (!cp_cur_flag_ctr)
		{
			cp_cur_flag_ctr = 16;
			cp_flag = *pcp_pflag++;
		}
		cp_cur_flag_ctr--;
		if (cp_flag&0x1)
		{
			*ptr = cplut[*pcp_pcode++];
		}
		else
		{
			*ptr = *(unsigned short *) pcp_pcode;
			pcp_pcode += 2;
		}
			
		cp_flag >>=1;
	}

	return 1;
}

/****************************************************************
Routine : init_ptrs_long()
Description :
	Initialize the pointers to begin the decompression
	of the DSP code.
*****************************************************************/
void init_ptrs(word *in)
{
  pcp_pcnt = in;
  cp_cur = *pcp_pcnt++; 
  cp_next = *pcp_pcnt++;   

  while (*in++)
	  ;
  pcp_pcode = (unsigned char *) (in + *in + 1);
  pcp_pflag = in+1;

  if (cp_cur & 0x8000)
  {
	  cp_cur = (short int) (cp_cur & 0x7FFF);
	  cp_zero_zone = 1;
  }
  else
	  cp_zero_zone = 0;
  cp_cur_flag_ctr = 0;

}

/****************************************************************
Routine : dp_download_dsp
Description : download dsp code by using dsp download command
		through mailbox - 6 bytes at a time.
*****************************************************************/
void
dp_download_dsp(const byte *addr)
{
	word bPtrBuf[3];
	byte *bPtr ;
	word wCntr ;
	byte i, k, tmp_rd7 ;

	tmp_rd7 = G(dp_bamil_rd7) ;

	G(dp_bamil_rd7) = 0xff ;
	dp_regwrite ( 0xd8, 0xff ) ;	// clear all interrupts on camil
	dp_regwrite ( 0xd7, 0xff ) ;	// disable all interrupts on camil

	// disable parallel data mode
	dp_modem_command_long(PDM, 0, 0, 0, 0);
	dp_write_dsp_ram(0x39, 0x0);		// clear fax options word

	init_ptrs((word *) addr);
	
	while (decode_word(&bPtrBuf[0]) &&
		   decode_word(&bPtrBuf[1]) &&
		   decode_word(&bPtrBuf[2]))
	{
		bPtr = (byte *)bPtrBuf ;
		wCntr = ((DspFileHdr *)bPtr)->wFileSize ;
		
		// copy address, length and checksum.
		dp_regwrite ( 0x30, 0x01 ) ; // for external ram download set to 1
		for (i = 0; i < 6 ; i++ )
		{	
			dp_regwrite ( (byte)(i+0x31), *bPtr++ );
		}
		dp_regwrite ( 0xd8, 0x18 ) ;	// clear core read/write bank bit - CRBNKI
		dp_regwrite ( 0x37, 0x1a ); // initial program download.
		wait_for_core_read () ;

		while ( wCntr )
		{
			if ( wCntr >= 3 )
			{
				k = 6 ;
				wCntr -= 3 ;
			}
			else
			{
				k = (byte)(2*wCntr) ;
				wCntr = 0 ;
			}
		
			bPtr = (byte *)bPtrBuf ;
			for (i = 0; i < (k>>1) ; i++ )
			{
				decode_word(&bPtrBuf[i]);
			}

			// copy 6 bytes of data
			for (i = 0; i < k ; i++ )
			{
				dp_regwrite ( (byte)(0x30+i), *bPtr++ ) ;
			}
			dp_regwrite ( 0xd8, 0x18 ) ; // clear core read/write bank bit - CRBNKI
			if ( wCntr )
			{
				dp_regwrite ( 0x37, (byte)(0xc0|k) ) ;
			}
			else
			{
				dp_regwrite ( 0x37, (byte)(0xc8|k) ) ;//end of section
			}
			wait_for_core_read () ;
		}
	}

	dp_regwrite ( 0xb7, 0xff ) ; // clear interrupt NCWTB
	dp_regwrite ( 0xd8, 0xff ) ;	// clear all interrupts on camil

	// enable the dsp interrupts
	G(dp_bamil_rd7) = tmp_rd7 ;
	dp_regwrite ( 0xd7, G(dp_bamil_rd7) ) ;
}

/****************************************************************
Routine : dp_download_dspk56_long
Description : download dsp code into external RAM.
*****************************************************************/
void
dp_download_dspk56( word *addr, byte dstBank )
{
	word t = x_current_time();
	word d, loc = (word) (((dstBank - BBR0) * 0x800) + 0x8000);
	word i, first0Loc = loc;

#if defined(DRAGNET)
	dp_regwrite( 0xda, 0x00);

	// set ioc register for external ram with address 15 always high
	dp_dsp_int_regwrite( 1, 0x0808 );
#endif
	init_ptrs(addr);

	while (decode_word(&d))	   // get decompressed word
	{
#if !defined(NO_SAVE_UP_ZEROS)
		// if we've been saving up zeros then deal with them
		if (d)
		{
			// Skip long strings of zeros
			for (i=first0Loc; i<loc; i++)
			{
				dp_write_dsp_ram(i, (word) 0);
			}
			dp_write_dsp_ram(loc++, d);
			first0Loc = loc;
		}
		else
		{
			loc++;
			// if it's been 127 zeros then send these using DSP command
			// (127 is the most this DSP command can handle)
			if (loc - first0Loc > 126)
			{
				// DSP Fill command fills RAM with value
				dp_apollo_command(0x33, 127,
								  (byte) (first0Loc >> 8), (byte) first0Loc,
								  (byte) 0, (byte) 0,
								  (byte) 0, (byte) 0);

				first0Loc += 127;
			}
		}
#else
		dp_write_dsp_ram(loc++, d);		// old way (no zero skip)
#endif
	}

	x_debug_msg("dp_download_dspk56 time=");
	dp_puts_dec(x_elapsed_time(t));
	sendCrLf();
}
#else

// (not COMPRESS_TABLES) ********************

/****************************************************************
Routine : dp_download_dspk56_long
Description : download dsp code into external RAM.
*****************************************************************/
void
dp_download_dspk56_long ( word *sourcep, word count, byte dstBank )
{
	word t = x_current_time();

#if defined(QMP_PRESENT) || !defined(DRAGNET)
	word *sp = sourcep;
	word cnt = count;
	
	U32 dstLoc;

	//--------------------------------------------------
	// For compatibility with Zinger8 loads, convert
	// the BBR value, offset pair into a DSP external
	// memory word ptr.
	//--------------------------------------------------
	dstLoc = (U32)(((U32)dstBank*0x1000 + BANKOFFSET) >> 1);

#if defined(VERIFY_DOWNLOAD)
	// initialize
	{
		word i, loc;

		loc = ((dstBank - BBR0) * 0x800) + 0x8000;
		for (i=0; i < count; i++)
		{
			dp_write_dsp_ram(loc++, 0);
		}
	}
#endif

	while ( count >= QMP_FIFO_WORDS )
	{
#if defined(QMP_PRESENT)
		qmp_write(sourcep, dstLoc, QMP_FIFO_WORDS);
#else
		rmp_write(sourcep, dstLoc, QMP_FIFO_WORDS);
#endif
		sourcep += QMP_FIFO_WORDS ;
		dstLoc += QMP_FIFO_WORDS ;
		count -= QMP_FIFO_WORDS ;
	}

	if ( count )
	{
#if defined(QMP_PRESENT)
		qmp_write(sourcep, dstLoc, (byte) count);
#else
		rmp_write(sourcep, dstLoc, (byte) count);
#endif
	}

#if defined(VERIFY_DOWNLOAD)
	// verify
	{
		word i, loc;


		loc = ((dstBank - BBR0) * 0x800) + 0x8000;
		for (i=0; i < cnt; i++)
		{
			if (dp_read_dsp_ram(loc) != *sp)
			{
				x_debug_msg("download verify fails loc=");
				dp_puts_hex(loc);
				x_debug_msg("read_dsp_ram=");dp_puts_hex(dp_read_dsp_ram(loc));
				x_debug_msg("actual=");		 dp_puts_hex(*sp);
				sendCrLf();
				break;
			}
			loc++;
			sp++;
		}
	}
#endif

#else
	// no RMP or QMP, use write_ram's
	word i;
	word loc = ((dstBank - BBR0) * 0x800) + 0x8000;

#if defined(DRAGNET)
	dp_regwrite( 0xda, 0x00);

	// set ioc register for external ram with address 15 always high
	dp_dsp_int_regwrite( 1, 0x0808 );
#endif

	for (i=0; i < count; i++)
	{
		dp_write_dsp_ram(loc++, *sourcep++);
	}
#endif // QMP or DRAGNET

	x_debug_msg("done with dp_download_dspk56_long time=");
	dp_puts_dec(x_elapsed_time(t));
	sendCrLf();
}
#endif // COMPRESS_TABLES

/****************************************************************
Routine : dp_start_transmit
Description :
    start the data transmission if idle. enable transmit interrupt.
*****************************************************************/
void
dp_start_transmit ( void )
{
	if ( G(dp_dsp_data_in_progress) == FALSE )
	{
		G(dp_dsp_data_in_progress) = TRUE ;
		dp_regwrite( 0xb0, 0 ) ;	// kick off transmit
	}
}

