/*name and version number:@(#)z80ser.c	1.140*/
/*date of get: 		  01/12/01 11:49:13*/
/*date of delta:	  01/11/01 13:14:26*/
/****************************************************************
File :	z80ser.c
Description :
	Contains the z80 main function for the External Modem.
	Also the SCC functions and much of the Autobauding
	functionality.

Procedures Contained :
	main

Revision History :
	Initials	Date		Change
	RWF			09/11/95	ext modem
	RWF			10/07/95	PnP
	RWF			10/13/95	eeprom
	RWF			12/07/95	z80189
	RWF			02/07/96	VENUS
	RWF			01/15/97	EASCI TX DMA
	RWF			02/21/97	EASCI RX DMA
	RWF			06/09/97	moved main() to z80util.c
*****************************************************************/
#include	"llglob_d.h"
#include	"iouart_d.h"
#include	"ioglob_d.h"
#include	"atglob.h"
#include	"z80glob.h"
#include	"dpglob.h"
#if defined(KORTEX)
# include	"amkb.h"
# include	"AmTime.h"
# include	"AmUpdate.h"
#endif		// KORTEX
#include	"allglobs.h"



#if defined(FRM_HOST_DMA_TEST)
byte dma_test;
#endif

//-----------------------------------------------------------------
// Uncomment the following line for debug of both DMA channels
//-----------------------------------------------------------------
//#define DMA_INT_DEBUG

#if defined(Z80_EASCI_RX_DMA)
//-----------------------------------------------------------------
// Uncomment the following line for state machine debug of RX DMA
// Note: there is an identical symbol in z80serut.c that must also
// track this one
//-----------------------------------------------------------------
//# define RX_DMA_DEBUG
BOOL	dmach0Flg ;
#endif	// Z80_EASCI_RX_DMA

#if defined(Z80_EASCI_TX_DMA)
//-----------------------------------------------------------------
// Uncomment the following line for state machine debug of TX DMA
// Note: there is an identical symbol in z80serut.c that must also
// track this one
//-----------------------------------------------------------------
//# define	TX_DMA_DEBUG

# define PNPHOSTMODE	// this is the more rigorous PnP algorithm
BOOL	dmach1Flg ;
# endif	// Z80_EASCI_TX_DMA

// background routines
extern void z80_set_ser_wstates(BOOL HighSpeed);
extern void PnP_chkstate ( PLUGNPLAY state );
extern void PnP_setstate(PLUGNPLAY state);

//==========================================================================
//		ESCC/EASCI Variables/Tables for the Z80182/189/VENUS
//==========================================================================
const word baud_rate_tbl[] = {
	BR75_2,				//     75 bps => 0
	BR150_2,			//    150 bps => 1
	BR300_2,			//    300 bps => 2
	BR600_2,			//    600 bps => 3
	BR1200_2,			//   1200 bps => 4
	BR2400_2,			//   2400 bps => 5
	BR4800_2,			//   4800 bps => 6
	BR7200_2,			//   7200 bps => 7
	BR9600_2,			//   9600 bps => 8
	BR14400_2,			//  14400 bps => 9
	BR19200_2,			//  19200 bps => 10
	BR38400_2,			//  38400 bps => 11
	BR57600_2,			//  57600 bps => 12
	BR115200_2,			// 115200 bps => 13
	BR230400_2
} ;

//-----------------------------------------------------------
//			VENUS delta_tbl[]
//-----------------------------------------------------------
// This is a table of midpoints of BRG values for use in
// table lookup of an exact value from the baud_rate_tbl[]
// above.  The VENUS EASCI hardware measures the start-bit
// and plugs in an approximate value of the start bit.
//-----------------------------------------------------------
const word delta_tbl[] = {
	BR75_2,
	BR150_2,
	0xffff,
	(BR600_2 + BR300_2)/2,
	(BR1200_2 + BR600_2)/2,
	(BR2400_2 + BR1200_2)/2,
	(BR4800_2 + BR2400_2)/2,
	(BR7200_2 + BR4800_2)/2,
	(BR9600_2 + BR7200_2)/2,
	(BR14400_2 + BR9600_2)/2,
	(BR19200_2 + BR14400_2)/2,
	(BR38400_2 + BR19200_2)/2,
	(BR57600_2 + BR38400_2)/2,
	(BR115200_2 + BR57600_2)/2,
	(BR230400_2 + BR115200_2)/2
} ;
//==========================================================================
//			END of EASCI Variables for VENUS
//==========================================================================

//==========================================================================
//					Globals
//==========================================================================
#if defined( ROM_FLASH )
//--------------------------------------------------------------------------
//	The following variables are shared by the Flash Loader 
//	and the baseline.  GotBRGcnt and s_62 are set by nmiir
//	which is in the Flash Loader; and AUTOBAUDING is used
//	to convey information to Flash Loader whem the modem
//	jumps into it do get a new load.
//--------------------------------------------------------------------------
extern	BOOL		GotBRGcnt ;		// baudrate value is known
extern	BAUD_RATE	s_62 ;			// this sreg is the baudrate (actually
									// an index into the baudrate table)
//--------------------------------------------------------------------------
#else
BOOL	GotBRGcnt ;
BAUD_RATE s_62 ;					// this sreg is the baudrate (actually
									//   an index into the baudrate table)
//--------------------------------------------------------------------------
#endif
BAUD_RATE lst_s_62 ;
BOOL	z80_no_more_tx ;			// Bool to determine idle Tx to DTE ch.
BOOL	AUTOBAUDING ;
byte	in_stat ;					// last status read from DTE
byte	in_stat0 ;					// last status read from DTE
word	brgcnt;

#if defined( Z80_EASCI_TX_DMA )
word	z80_max_dma ;				// size of DMA transfer.
byte	*z80_dte_tx_rptr ;			// temp ptr to rx buffer
#endif

#if defined( Z80_EASCI_RX_DMA )
BOOL	z80_rx_dma ;
byte	*z80_dte_rx_wptr ;			// temp ptr to rx buffer
#endif

#if defined( Z80_EASCI_TX_DMA ) || defined( Z80_EASCI_RX_DMA )
BOOL	z80_dma_debug ;
#endif

#if defined( Z80_DEBUG_PRINT )
BOOL	z80_flow_on_flag ;
BOOL	abon, aboff;
//byte	dma_loop_cnt;
word	debug_rx_count ;
word	flash_timer ;			// timer for Break to DTE
#endif

//--------------------------------------------------------------------------
//			Debug tickers
//--------------------------------------------------------------------------
word ext_c_int ;			// scc ext interrupt
word src_c_int ;			// scc src interrupt
word bad_char2;				// scc rx interrupt
word overrun_error;			// scc src interrupt
word framing_error ;		// scc src interrupt

//--------------------------------------------------------------------------
//					Break from/to DTE Variables
//--------------------------------------------------------------------------
word	brk_timer ;					// timer for Break to DTE
BOOL	brk_to_dte_flg ;			// flag set when break in progress to DTE
BOOL	brk_from_dte_flg ;			// flag signalling scc_rx_int() ISR
									// a NULL is in the input fifo
BOOL	brk_from_dte_on ;			// flag set when break rcvd from DTE
BOOL	brk_from_dte_off ;			// flag set when break cleared by DTE

//--------------------------------------------------------------------------
//					DTR from DTE Variables
//--------------------------------------------------------------------------
BOOL	dtr_from_dte_on ;
BOOL	in_xof_from_dte ;
BOOL	setXflag ;

//--------------------------------------------------------------------------
//					Plug & Play Variables
//--------------------------------------------------------------------------
#if defined( PNPSTRING )
PLUGNPLAY PnP_state ;				// state var for Win95 Plug and Play
word PnP_timer ;					// timer for Win95 Plug and Play
word PnP_count ;					// ticker for # sends of string to host
#endif
//
//==========================================================================

//==========================================================================
//			Functions (including ISRs)
//==========================================================================

#ifdef KORTEX
byte amTimeCnt;
byte am_kb_cnt;
byte am_kb_switch;

/****************************************************************
	Function : kortexKeyboardStatus

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
void kortexKeyboardStatus ( void )
{
	if (amTimeCnt < AM_TIME_TIME_ADD)
	{
		amTimeCnt ++;
	}
	else
	{
		amTimeCnt = 0;
		amTimeDate ++;  // Incrementer date reelle toute les secondes
	}

	if ((am_kb_cnt < AM_KBD_TIME_READ)
		&&(S.ModemOptions.VoiceCompression != VCM_G729))
	{
		//SES - this condition allows for more
		//frequent reads of keyboard status
		//during G.729 messages for faster button
		//reaction time.
		am_kb_cnt++;
	}
	else
	{
		am_kb_cnt = 0;
	
		am_kb_write_reg &= ~AM_KB_OUT_ROW0_OFF;
		am_kb_write_reg |= AM_KB_OUT_ROW1_OFF;
		output8(AM_KB_WRITE_REG, am_kb_write_reg);
		am_kb_reg0 = (input8(AM_KB_READ_REG) & AM_KB_KEY_NOT_PRESSED);

		am_kb_write_reg &= ~AM_KB_OUT_ROW1_OFF;
		am_kb_write_reg |= AM_KB_OUT_ROW0_OFF;
		output8(AM_KB_WRITE_REG, am_kb_write_reg);
		am_kb_reg1 = (input8(AM_KB_READ_REG) & AM_KB_KEY_NOT_PRESSED);

		if (am_kb_switch == 0) {
			am_kb_state_machine = AM_KB_TEST_ROW0;
		} else {
			am_kb_state_machine = AM_KB_TREAT_END_KB_PRESSED;
		}
	}
}
#endif	// KORTEX

/****************************************************************
	Function : timer interrupt - set for PRT0_CNT msec intervals

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void prt0ir ( void )
{
		// clear interrupt
	input8( TCR );
	input8( TMDR0L );

	#if defined( Z80_EASCI_RX_DMA )
	//---------------------------------------------------------
	// if in on-line mode, and using DMA ch0 for EASCI RX,
	// then update the IO_DTE_RX_WPTR buffer pointer.
	//---------------------------------------------------------
	if ( z80_rx_dma )
	{
		word dmaadr ;
		byte cnt ;

		//--------------------------------------------
		// interrupts must NOT be disabled "too long"
		// when using from host DMA!!!
		//--------------------------------------------
		enable_interrupt() ;

		cnt = 0;
		while ( 1 )
		{
			disable_interrupt() ;
			dmaadr = (word)(input8(DAR0L)|(input8(DAR0H)<<8)) ;
			enable_interrupt() ;
			#if (HOST_RX_BUFF_SIZE & 255) == 0
			# error "HOST_RX_BUFF_SIZE must NOT be Mod 256"
			#endif
			if ( (byte)(dmaadr) == input8(DAR0L) )
			{
				#if defined( DMA_INT_DEBUG )
				if ( IO_DTE_RX_WPTR != (byte *)dmaadr )
				{
					ddputs_nnl("dmaadr -"); sendHexWord(dmaadr);
					sendCrLf();
				}
				#endif

				if ( /* ((byte *)dmaadr >= IO_DTE_RX_SPTR)
					&& */ ((byte *)dmaadr < IO_DTE_RX_EPTR) )
				{
					IO_DTE_RX_WPTR = (byte *)dmaadr ;
				}
				else
				{
					ddputs_nnl("dmaadr Err="); sendHexWord(dmaadr);
					sendCrLf();
					#if defined(FRM_HOST_DMA_TEST)
					if ( dumbPortPresent ) z80_parsechar( 'D' );
					#endif
				}
				break ;
			}

			if ( cnt++ > 4 )
			{
				fatal_error("DMA in prt0");
			}
		}
		// for debug
		//if ( cnt > dma_loop_cnt ) dma_loop_cnt = cnt;

		disable_interrupt() ;
	}
	#endif

	//---------------------------------------------------------
	// disable ESCC/EASCI interrupt - before calculating no of
	// bytes in queue
	//---------------------------------------------------------
	if ( IO_DTE_RX_WPTR >= IO_DTE_RX_RPTR )
	{
		uart_rx_count = IO_DTE_RX_WPTR - IO_DTE_RX_RPTR ;
	}
	else
	{
		uart_rx_count = (IO_DTE_RX_EPTR - IO_DTE_RX_RPTR)
						 + (IO_DTE_RX_WPTR - IO_DTE_RX_SPTR) ;
	}

	enable_interrupt() ;
	if ( uart_rx_count >= HOST_RX_BUFF_FULL )
	{
		disable_interrupt () ;
		z80_flow_on() ;
		enable_interrupt() ;
	}
	disable_interrupt () ;

	#if defined(Z80_READ_UART_DEBUG)
	if ( dumbPortPresent )
		if ( input8(DUMB_LSR) & BIT0 )
			z80_parsechar( input8(DUMB_DATA) );
	#endif

	#ifdef KORTEX
	kortexKeyboardStatus();
	#endif

		// set clock for next period
	x_timer += PRT0_CNT ;

		// finally strobe sanity timer
	#if defined( WATCHDOG_TIMER )
	output8( 0xda, 0x1f ) ;
	output8( 0xdb, 0xe5 ) ;
	#endif
}

/****************************************************************
Routine : easci_isr
Description :
    C Interrupt Service Routine for the EASCI block (Enhanced
	Asynchronous Serial Communications Interface).
*****************************************************************/
non_banked
interrupt
void easci_isr ( void )
{
	byte ch;
	extern non_banked void z80_start_autobaud ( void );

	//----------------------------------------------
	// check for EASCI RX (from host) activity
	//----------------------------------------------
	while ( TRUE )
	{
		in_stat0 = input8( ASCI_STAT0_REG );
		if ( !(in_stat0 & 0xf0) ) break;

		//-------------------------------
		// check for RX error
		//-------------------------------
		if ( in_stat0 & 0x70 )
		{
			//-------------------------------
			// got RX error - process it
			//-------------------------------
			asci_rx_error();

			if ( AUTOBAUDING ) z80_start_autobaud();
		}
		else
		{
			//-------------------------------
			// got good char - process it
			//-------------------------------
			ch = input8( ASCI_RX0_REG );

			if ( AUTOBAUDING )
			{
				//--------------------------------------
				// is it an 'A' or 'a' ?
				//--------------------------------------
				if ( (ch & 0x5f) != 'A' )
				{
					//-------------------------------
					// nope - try again
					//-------------------------------
					z80_start_autobaud();
					bad_char2++;
					continue;
				}
				else
				{
					//-------------------------------
					// yep - it's an 'A' (or 'a')
					//-------------------------------
					//sendDumbChar('^');
					AUTOBAUDING = 0;
	
					//-----------------------------------
					// Have we already established BRG
					// (by NMI) ?
					//-----------------------------------
					if ( !GotBRGcnt )
						asci_set_autobaud();
				}
			}
			else
			{
				//-------------------------------
				// Check for SW flow control
				//-------------------------------
				if ( z80_modem_state == SW_ON_LINE_STATE )
				{
					//-----------------------------
					// Software flow control is set
					//-----------------------------
					if ( ch == XOFF )
					{
						//--------------------------------
						// XOFF received from DTE:
						// Set flag to stop sending to DTE
						//--------------------------------
						z80_swfc_on();
						continue;
					}
					else if ( ch == XON )
					{
						//--------------------------------
						// XON received from DTE:
						// Clr flag to allow sending to DTE
						//--------------------------------
						z80_swfc_off();
						continue;
					}
				}
			}

			//------------------------------------------
			// place char in "from host" dte ring buffer
			// and handle buffer wrap.
			// Flow control is managed in prt0().
			//------------------------------------------
			*io_dte_rx_wptr = ch ;
			if ( ++io_dte_rx_wptr >= io_dte_rx_eptr )
				io_dte_rx_wptr = io_dte_rx_sptr ;
		}
	}

#if !defined( Z80_EASCI_TX_DMA )
	//-------------------------------------
	// check for empty tx data register
	//-------------------------------------
	if ( !z80_no_more_tx && (in_stat0 & BIT1) )
	{
		//---------------------------
		// tx (to host) interrupt
		//---------------------------
		if ( io_dte_tx_rptr != io_dte_tx_wptr )
		{
			//---------------------------
			// send next char
			//---------------------------
			output8( ASCI_TX0_REG, *io_dte_tx_rptr ) ;
			if ( ++io_dte_tx_rptr >= io_dte_tx_eptr )
				io_dte_tx_rptr = io_dte_tx_sptr ;
		}
		else
		{
			//--------------------------------------
			// There is NO more data to transmit;
			// Reset TX interrupt enable bit and set
			// z80_no_more_tx to signal main() that
			// tx side has been inhibited.
			//--------------------------------------
			z80_no_more_tx = TRUE;
			output8( ASCI_STAT0_REG,
						input8( ASCI_STAT0_REG ) & ~TX_INT_ENABLE ) ;
		}
	}
#endif	// ! Z80_EASCI_TX_DMA

	//---------------------------------------------------------------
	// finally, check for DTR and/or RTS changes
	// (in_stat & in_stat0 are used by called routine on change).
	//---------------------------------------------------------------
	in_stat = input8( A0NEWCTL ) & 0xf0 ;
	if ( in_stat )
	{
		//--------------------------------------
		// A change in DTR or RTS has occured;
		//	Go process change via C function
		//	and reset interrupting source(s)
		//--------------------------------------
		asci_ext_int();
	}
}

/*****************************************************************
	Function : x_sleep_mode
	For external modem - sleep only when autobauding.
	Note: Cannot use IOSTOP mode and achieve reliable
	autobauding at lower baudrates.  It seems that the
	channel one timer has trouble getting started again
	after waking up.  Use SLEEP mode instead.
******************************************************************/
non_banked byte x_sleep_mode ( void )
{
	return FALSE ;
}

/****************************************************************
	Function : Extension to asci_int ISR to handle receive errors.
	Handles frame errors, break condition (a frame error with
	zero character) and data overruns.
	Uses common global in_stat.
	MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void asci_rx_error ( void )
{
	byte in_char ;

	sendDumbChar('A'); 

	in_char = input8( ASCI_RX0_REG ) ;

#if defined(Z80_DEBUG_PRINT)
	// Check for overrun error
	if ( in_stat0 & BIT6 ) sendDumbChar('o');

	// Check for parity error
	if ( in_stat0 & BIT5 ) sendDumbChar('p');
#endif	// Z80_DEBUG_PRINT

	// Check for framing error/break
	if ( in_stat0 & BIT4 )
	{
		// framing_error
		sendDumbChar('f');

		// was the framing error actually a Break?
		if ( !in_char )
		{
			//========================================
			// Break from DTE detected
			//========================================

			// set flag for task environment
			brk_from_dte_on = TRUE ;

			#if defined(Z80_DEBUG_PRINT)
			if ( dumbPortPresent )
			{
				output8 ( DUMB_MCR, input8 ( DUMB_MCR ) | 0x08 ) ;
				sendDumbChar('b');
			}
			#endif
		}
	}

	// reset error flag in ctl A reg
	output8( ASCI_CTLA0_REG, input8( ASCI_CTLA0_REG ) & ~ERROR_RESET ) ;

	// if online bump ticker.
	// unconditionally bump it - rwf - 01/01/01
	//if ( (x_modem_mode == MODEM_DATA) && (x_modem_state == MS_ON_DIAL) )
	{
		src_c_int ++ ;
	}

	sendDumbChar(0x0A); sendDumbChar(0x0D);
}

/****************************************************************
	Function : asci_ext_int()
	Extension to asci_int ISR to handle additional Status
	interrupts for VENUS.  Similar in functionality to
	ESCCs external interrupt handler.  Handles DTR and RTS
	changes from DTE.  Global var in_stat contains A0NEWCTL
	register contents on entry. Bits of interest are:
		DCD_HL_INT_RCVD,
		DCD_LH_INT_RCVD,
		CTS_HL_INT_RCVD, and
		CTS_LH_INT_RCVD

	MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void asci_ext_int ( void )
{
	ext_c_int ++ ;

	sendDumbChar('E');

	//=================================================
	// Now determine what CHANGE caused the interrupt.
	//	Could be:
	//		1) DTR from DTE (our DCD), or
	//		2) RTS from DTE (our CTS)
	//=================================================

	//+++++++++++++++++++++++++++++++++++
	// Check for DTR change
	//+++++++++++++++++++++++++++++++++++
	if ( in_stat & DCD_HL_INT_RCVD )
	{
		// Our DCD has transitioned to LOW which means that
		// DTR has just been SET by the DTE!!
		if ( !(in_stat0 & DCD0) )
		{
#ifdef PNPHOSTMODE
			// PnP: IF in T2 for 200 ms
			// (DTR was cleared by DTE 200ms ago and RTS is still reset)
			// THEN Enter T3
			PnP_chkstate ( T2 ) ;

			// 8/28/98 - mah - add this case
			// If we didn't make it to state T3
			// then if RTS is OFF we should
			// go to state T1
			if ((T0 == PnP_state) &&
				(input8 ( ASCI_CTLB0_REG ) & ASCI_CTS))
			{
				PnP_setstate ( T1 ) ;
			}
			// 8/28/98 - mah - end of addition
#endif
		}
		sendDumbChar('D');
	}
	if ( in_stat & DCD_LH_INT_RCVD )
	{
		// Our DCD has transitioned to HIGH which means that
		// DTR was just RESET by DTE!!
		if ( in_stat0 & DCD0 )
		{
#ifdef PNPHOSTMODE
			// PnP: IF in T1 for 200 ms
			// (RTS from DTE cleared 200 ms ago)
			// THEN enter T2
			PnP_chkstate ( T1 ) ;
#endif
		}
		sendDumbChar('d');
	}

	//+++++++++++++++++++++++++++++++++++
	// Check for change of RTS from DTE
	//+++++++++++++++++++++++++++++++++++
	if ( in_stat & CTS_HL_INT_RCVD )
	{
		// Our CTS has transitioned to LOW which means that
		// RTS was just SET by DTE!!
		// PnP: IF in T3 for 200 ms
		// THEN respond to DTE by sending
		// the ID information ( sent by main() ).
		if ( !(input8 ( ASCI_CTLB0_REG ) & ASCI_CTS) )
		{
			PnP_chkstate ( T3 ) ;
		}
		// RTS is SET
		sendDumbChar('R');
	}

	if ( in_stat & CTS_LH_INT_RCVD )
	{
		// Our CTS has transitioned to HIGH which means that
		// RTS was just RESET by DTE!!
		// further transmission of characters.
		if ( input8 ( ASCI_CTLB0_REG ) & ASCI_CTS )
		{
#ifdef PNPHOSTMODE
			// PnP: If DTR currently set (our DCD)
			// THEN start the Enumeration sequence (enter T1)
			if ( !( input8 (  ASCI_STAT0_REG ) & DCD0) )
			{
				PnP_setstate ( T1 ) ;
			}
#endif
		}
		// RTS is clear
		sendDumbChar('r');
	}

#ifndef PNPHOSTMODE
	if ( input8 ( ASCI_CTLB0_REG ) & ASCI_CTS )
	{
		PnP_setstate ( T3 ) ;
	}
#endif

	//++++++++++++++++++++++++++++++++++++++++++++++++++++
	// Finally reset interrupting source(s) by writing a 0
	//++++++++++++++++++++++++++++++++++++++++++++++++++++
	in_stat = (~in_stat & 0xf0) ;
	in_stat |= (input8( A0NEWCTL ) & 1) ;
	output8( A0NEWCTL, in_stat ) ;
}

/****************************************************************
	Function : asci_set_autobaud()
	Called by: EASCI "from host" ISR which has just found an "a"

	Sets s_62 and modifies actual BRG counter to precise value.
	Since the 16 bit BRG value is calculated by hardware and NOT
	generated by table lookup, the value could be a tick or two
	off of the exact baudrate.  This function corrects that.

	rwf - 01/01/01
	--------------
	Note: For Venus2 at the higher baudrates, the actual value
	is jammed into the BRG from a hardware table.

		MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void asci_set_autobaud ( void )
{
	static word *deltaptr ;

	// Stop hardware autobauding
	output8( A0NEWCTL,
				DCD_HL_INT_RCVD | DCD_LH_INT_RCVD |
				CTS_HL_INT_RCVD | CTS_LH_INT_RCVD ) ;

	// Get actual BRG counter value
	brgcnt = input8( ASCI_TCLO_REG ) | (input8 ( ASCI_TCHI_REG ) << 8) ;

	//---------------------------------------------------------------
	// iterate the highest three baudrates for real-time response
	// -------
	// also for Venus2 hardware autobaud enhancement - rwf - 01/01/01
	//---------------------------------------------------------------
	if ( brgcnt < delta_tbl[ BR230400 ] )
	{
		// Set BRG counter to exact value if not using Venus2 table
		if ( !z80_venus2 )
		{
			output8( ASCI_TCLO_REG, (byte)(baud_rate_tbl[ BR230400 ] & 0xFF) ) ;
			output8( ASCI_TCHI_REG, (byte)(baud_rate_tbl[ BR230400 ] >> 8) ) ;
		}
		s_62 = BR230400 ;

		#if defined(Z80_DEBUG_PRINT)
		// test software - test for exact value
		if ( z80_venus2 && (brgcnt != BR230400_2) )
		{
			sendDumbChar('?'); sendDumbChar('d');
		}
		#endif
	}
	else if ( brgcnt < delta_tbl[ BR115200 ] )
	{
		// Set BRG counter to exact value if not using Venus2 table
		if ( !z80_venus2 )
		{
			output8( ASCI_TCLO_REG, (byte)(baud_rate_tbl[ BR115200 ] & 0xFF) );
			output8( ASCI_TCHI_REG, (byte)(baud_rate_tbl[ BR115200 ] >> 8) );
		}
		s_62 = BR115200 ;

		#if defined(Z80_DEBUG_PRINT)
		// test software - test for exact value
		if ( z80_venus2 && (brgcnt != BR115200_2) )
		{
			sendDumbChar('?'); sendDumbChar('c');
		}
		#endif
	}
	else if ( brgcnt < delta_tbl[ BR57600 ] )
	{
		// Set BRG counter to exact value if not using Venus2 table
		if ( !z80_venus2 )
		{
			output8( ASCI_TCLO_REG, (byte)(baud_rate_tbl[ BR57600 ] & 0xFF) ) ;
			output8( ASCI_TCHI_REG, (byte)(baud_rate_tbl[ BR57600 ] >> 8) ) ;
		}
		s_62 = BR57600 ;

		#if defined(Z80_DEBUG_PRINT)
		// test software - test for exact value
		if ( z80_venus2 && (brgcnt != BR57600_2) )
		{
			sendDumbChar('?'); sendDumbChar('b');
		}
		#endif
	}
	else 
	{
		deltaptr = &delta_tbl[ BR38400 ] ;
		for ( s_62 = BR38400; s_62 > BR150; s_62-- )
		{
			if ( brgcnt < *deltaptr )
			{
				break ;
			}
			deltaptr -- ;
		}
		// Set BRG counter to exact value
		output8( ASCI_TCLO_REG, (byte)(baud_rate_tbl[ s_62 ] & 0xFF) ) ;
		output8( ASCI_TCHI_REG, (byte)(baud_rate_tbl[ s_62 ] >> 8) ) ;
	}

	GotBRGcnt = TRUE ;
}

/****************************************************************
	Function : z80_uart_break_on
	Break received from far end, Send a break to DTE
	NOTE: main() will be responsible for clearing the
	break condition after 300 ms (see BRK_TIME).
*****************************************************************/
non_banked void z80_uart_break_on ( void )
{
	// start Break to DTE
	output8( ASCI_XCR0_REG, input8( ASCI_XCR0_REG ) | SEND_BRK ) ;
	output8 ( DUMB_MCR, input8 ( DUMB_MCR ) | 0x08 ) ;
	brk_to_dte_flg = TRUE ;
	brk_timer = x_current_time () ;
}

/****************************************************************
	Function : z80_uart_cts_on
*****************************************************************/
non_banked void z80_uart_cts_on ( void )
{
	// set CTS to DTE
	disable_interrupt () ;
		output8( ASCI_CTLA0_REG, input( ASCI_CTLA0_REG ) & ~ASCI_RTS ) ;
	enable_interrupt () ;
}

/****************************************************************
	Function : z80_uart_cts_off

		MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_uart_cts_off ( void )
{
	// clear CTS to DTE
	output8( ASCI_CTLA0_REG, input8( ASCI_CTLA0_REG ) | ASCI_RTS ) ;
}

/****************************************************************
	Function : z80_uart_cd_on
*****************************************************************/
non_banked void z80_uart_cd_on ( void )
{
	// set DCD to DTE
	disable_interrupt () ;
		x_output( IO_CARRIER_DETECT_ON ) ;
	enable_interrupt () ;
}

/****************************************************************
	Function : z80_uart_cd_off
*****************************************************************/
non_banked void z80_uart_cd_off ( void )
{
	// clear DCD to DTE
	disable_interrupt () ;
		x_output( IO_CARRIER_DETECT_OFF ) ;
	enable_interrupt () ;
}

/****************************************************************
	Function : z80_uart_ri_on
*****************************************************************/
non_banked void z80_uart_ri_on ( void )
{
	x_output( IO_RING_INDICATE_ON ) ;
}

/****************************************************************
	Function : z80_uart_ri_off
*****************************************************************/
non_banked void z80_uart_ri_off ( void )
{
	x_output( IO_RING_INDICATE_OFF ) ;
}

/****************************************************************
	Function : z80_uart_dsr_on
*****************************************************************/
non_banked void z80_uart_dsr_on ( void )
{
	x_output( IO_DSR_ON ) ;
	ddputs_nnl( "DSR ON" ) ;
	sendCrLf();
}

/****************************************************************
	Function : z80_uart_dsr_off
*****************************************************************/
non_banked void z80_uart_dsr_off ( void )
{
	x_output( IO_DSR_OFF ) ;
	ddputs_nnl( "DSR OFF" ) ;
	sendCrLf();
}

/****************************************************************
	Function : z80_start_autobaud
	Note: this function is called from the serial interface RX
	ISR and is meant to be called with interrupts masked!
	It is also called from the task environment
	(Routine : main() below)

		MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_start_autobaud ( void )
{
	// clear the BRG...
	output8 ( ASCI_TCLO_REG, 0 ) ;
	output8 ( ASCI_TCHI_REG, 0 ) ;

	// ...start hardware autobaud...
	output8 ( A0NEWCTL,
				DCD_HL_INT_RCVD | DCD_LH_INT_RCVD | CTS_HL_INT_RCVD |
				CTS_LH_INT_RCVD | BAUD_DETECT | AUTOBAUD_EN ) ;

	GotBRGcnt = FALSE ;

	// enable NMI
	if ( !z80_venus2 ) WRITE_CAMILZ( 0x61, 0x01 ) ;

#if defined( Z80_EASCI_RX_DMA )
	//---------------------------------------------------
	// stop the receive side dma - note: this is done by
	// giving the channel back for use in SW flow control.
	//---------------------------------------------------
	if ( z80_rx_dma )
		z80_stop_rx_dma() ;
#endif
	AUTOBAUDING = TRUE ;

#if defined(Z80_DEBUG_PRINT)
	abon = TRUE ;
#endif
}

word z80_ab_timer; // timer for checking autobaud

/****************************************************************
	Function : z80_stop_autobaud
	Like z80_start_autobaud() above, this function
	is meant to be called with interrupts masked.  It
	is called by main() to send messages to the DTE
	while in autobaud mode.

	We set the bit rate to the value stored in s_62.

		MUST BE CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_stop_autobaud ( void )
{
	// Disable NMI...
	if ( !z80_venus2 ) WRITE_CAMILZ( 0x61, 0x00 ) ;

	// ...stop hardware autobauding, and...
	output8 ( A0NEWCTL,
				DCD_HL_INT_RCVD | DCD_LH_INT_RCVD |
				CTS_HL_INT_RCVD | CTS_LH_INT_RCVD ) ;

	// ... and Set baudrate back to previously observed value
				// lower byte
	output8 ( ASCI_TCLO_REG, (byte)(baud_rate_tbl[ s_62 ] & 0xFF) ) ;
				// upper byte
	output8 ( ASCI_TCHI_REG, (byte)(baud_rate_tbl[ s_62 ] >> 8) ) ;

	AUTOBAUDING = FALSE;
	z80_ab_timer = x_current_time();

#if defined(Z80_DEBUG_PRINT)
	aboff = TRUE ;
#endif
}

/****************************************************************
	Function : z80_flow_on
	Stop the host from sending
        
		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_flow_on(void)
{
	if ( S.ModemOptions.FlowControl == HW_FLOWCTRL )
	{
		uart_flow_control = FC_ON ;
		z80_uart_cts_off ( ) ;
		//sendDumbChar( 'c' ) ;
	}
	else if ( S.ModemOptions.FlowControl == SW_FLOWCTRL )
	{
		#if defined( Z80_EASCI_TX_DMA )
		extern const byte XOFFchar ;

		//-------------------------------------------------
		// send xoff to the pc using ch0 DMA
		//-------------------------------------------------
		//	load the DMA state for the XOFF char
		output8( SAR0L, (byte)&XOFFchar ) ;
		output8( SAR0H, (byte)((word)&XOFFchar >> 8) ) ;
		output8( BCR0L, 1 ) ;
		//-------------------------------------------------
		//	start the ch0 DMA - no interrupt
		//-------------------------------------------------
		#if defined( DMA_INT_DEBUG )
		ddputs_nnl("6: start ch0 DSTAT-"); sendHexByte(input8( DSTAT ));
		#endif
		output8( DSTAT, (input8( DSTAT ) & 0x08) | 0x61 ) ;
		#if defined( DMA_INT_DEBUG )
		ddputs_nnl(";  DSTAT-"); sendHexByte(input8( DSTAT ));
		sendCrLf();
		#endif
		uart_flow_control = FC_ON ;
		#else
		// send xoff to the pc - later in the background
		uart_flow_control = FC_OFF_TO_ON ;
		#endif
		sendDumbChar('x');
	}

	#if defined(Z80_DEBUG_PRINT)
	// for testing flow control
	// print every new high water mark!!
	if ( uart_rx_count > debug_rx_count )
	{
		debug_rx_count = uart_rx_count ;
		z80_flow_on_flag = TRUE ;
	}
	#endif
}

/****************************************************************
	Function : z80_chk_autobaud

	Is it time to autobaud?  If so, setup the hardware and the
	software state variables (through z80_start_autobaud()).

*****************************************************************/
non_banked void z80_chk_autobaud(void)
{
	//==============================================
	// if in "cmd" mode then wait for all chars in
	// response to previous command to be sent to
	// DTE before restarting autobaud.
	//==============================================
	if ( at_state == AT_IDLE
		 /* new way for autobaud checking..
		  * Is io_state in a state where it could be
		  * sending the next character to AT?
		  */
		 && ((io_state < IO_CD_ON) || (io_at_esc_detect
#if defined ( K56FLEX ) || defined( VPCM_CLIENT ) || defined ( VPCM_SERVER )
					&& !dp_56k_state
#endif
				))
		 // following check needed to prevent autobaud while
		 // on-line in class 1 or class 2 fax
		 && (x_modem_state != MS_ON_DIAL)
		 // following check allows any char to terminate
		 // ata or atdt command.
		 && (x_modem_state != MS_ANSWERING)
		 && (x_modem_state != MS_DIALING)
		 && (IO_DTE_RX_WPTR == IO_DTE_RX_RPTR)
#ifdef KORTEX
		 && !bAmUpdateState
#endif
		 && !at_view_more )
	{
		// test for a quiescent "Tx to DTE" channel.
		if ( z80_no_more_tx && IO_DTE_TX_WPTR == IO_DTE_TX_RPTR )
		{
			// (I tried just reading the level of BIOB6
			// but that doesn't work as well as catching the
			// edge as we're doing now. - mah 5/19/00)
			if (//dp_regread(0xbb) & BIT6 &&		// also RxD not active
				input8( ASCI_CTLB0_REG ) & ASCI_ALL_SENT )
			{
				if (dp_regread(0xbd) & BIT6)
				{
					// If BIOB6 has had a falling edge then
					// there has been a bit on RxD and we don't
					// want to autobaud for a while.

					// clear all bit I/O interrupts
					dp_regwrite(0xbd, 0xff);
					dp_regwrite(0xbd, 0);
					z80_ab_timer = x_current_time();
				}

				if (
					(x_elapsed_time(z80_ab_timer) >= 10)
#if defined(VOICE)
					// fix bitware bug where we weren't autobauding
					// fast enough to satisfy bitware.  On Win2k
					// Bitware only waits 4-5 ms between the receipt
					// of one command's 'OK' and the 'A' of the next
					// command at a different baud rate.  (not nice.)
					|| (MODEM_VOICE == x_modem_mode &&
						x_elapsed_time(z80_ab_timer) >= 2)
#endif
					)
				{
					// both the software and the hardware concur that
					// all data has been sent.
					disable_interrupt();
					 z80_start_autobaud();
					enable_interrupt();

					dp_regwrite(0xbc, 0xff);	// disable B6 "interrupt"
				}
				else
				{
					// Mask BIO interrupts in primary HOST masking register.
					// We'll poll for these events above and don't want
					// them taking us to the ISR.
					G(dp_bamil_rd7) |= BIT6;
					dp_regwrite(0xd7, G(dp_bamil_rd7));

					// Enable B6 "interrupt" so we can catch
					// falling edges.
					dp_regwrite(0xbc, 0xbf);
				}
				return;
			}
		}
	}
	z80_ab_timer = x_current_time();
}

/****************************************************************
	Function : z80_swfc_on
	XOFF received from DTE: Set flag to stop sending to DTE

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_swfc_on ( void )
{
	// XOFF has just been received from the DTE!!
	in_xof_from_dte = TRUE ;
	setXflag = TRUE ;
#if !defined( Z80_EASCI_TX_DMA )
	z80_no_more_tx = TRUE ;
	output8( ASCI_STAT0_REG, input8( ASCI_STAT0_REG ) & ~TX_INT_ENABLE ) ;
#endif
#if defined( Z80_DEBUG_PRINT )
	//------------------------------------------
	// Turn OFF RTS led - Yellowstone
	//------------------------------------------
	output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & ~BIT3 ) ;
#endif
}

/****************************************************************
	Function : z80_swfc_off
	XON received from DTE: Clear flag to allow sending to DTE

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_swfc_off ( void )
{
	// XON has just been received from the DTE!!
	in_xof_from_dte = FALSE ;
	setXflag = TRUE ;
#if defined(Z80_DEBUG_PRINT)
	//------------------------------------------
	// Turn ON RTS led - Yellowstone
	//------------------------------------------
	output8 ( DUMB_MCR, input8 ( DUMB_MCR ) | BIT3 ) ;
#endif
}

#if defined( Z80_EASCI_TX_DMA )
/****************************************************************
	Function : z80_start_tx_dma
	Calculates the number of contiguous bytes available to send
	to the Host and sets up and starts the Channel 1 DMA transfer.
*****************************************************************/
non_banked void z80_start_tx_dma ( void )
{
	word count ;

	//-------------------------------------------------
	//		load the starting address
	//-------------------------------------------------
	output8( MAR1L, (byte)IO_DTE_TX_RPTR ) ;
	output8( MAR1H, (byte)((word)IO_DTE_TX_RPTR >> 8) ) ;

	//-------------------------------------------------
	//		load the count
	//-------------------------------------------------
	if ( IO_DTE_TX_WPTR > IO_DTE_TX_RPTR )
	{
		//---------------------------------------------
		// all bytes available are contiguous
		//---------------------------------------------
		count = IO_DTE_TX_WPTR - IO_DTE_TX_RPTR ;
		if ( count > z80_max_dma )
		{
			//---------------------------------------------
			// send only z80_max_dma bytes at a time. this
			// allows the IO_DTE_TX_RPTR to be updated faster
			//---------------------------------------------
			count = z80_max_dma ;
			z80_dte_tx_rptr = IO_DTE_TX_RPTR + z80_max_dma ;
#if defined( TX_DMA_DEBUG ) && defined( notme_rwf )
			if ( z80_dma_debug ) sendDumbChar( '1' ) ;
#endif
		}
		else
		{
			z80_dte_tx_rptr = IO_DTE_TX_WPTR ;
#if defined( TX_DMA_DEBUG )
			if ( z80_dma_debug ) sendDumbChar( '2' ) ;
#endif
		}
	}
	else
	{
		//---------------------------------------------
		// bytes available are non-contiguous
		// just get the upper bytes this time.
		//---------------------------------------------
		count = IO_DTE_TX_EPTR - IO_DTE_TX_RPTR ;
		if ( count > z80_max_dma )
		{
			count = z80_max_dma ;
			z80_dte_tx_rptr = IO_DTE_TX_RPTR + z80_max_dma ;
#if defined( TX_DMA_DEBUG ) && defined( notme_rwf )
			if ( z80_dma_debug ) sendDumbChar( '3' ) ;
#endif
		}
		else
		{
			z80_dte_tx_rptr = IO_DTE_TX_SPTR ;
#if defined( TX_DMA_DEBUG )
			if ( z80_dma_debug ) sendDumbChar( '4' ) ;
#endif
		}
	}

	output8( BCR1L, (byte)count ) ;

	//-------------------------------------------------
	//		Start ch1 DMA and enable CH1 interrupt.
	//-------------------------------------------------
#if defined( DMA_INT_DEBUG )
	ddputs_nnl("1: start ch1 DSTAT-"); sendHexByte(input8( DSTAT ));
#endif

	disable_interrupt();
		output8( DSTAT, (input8( DSTAT ) & 0xdf) | 0x88 ) ;
	enable_interrupt();

#if defined( DMA_INT_DEBUG )
	reg = input8( DSTAT ) ;
	ddputs_nnl("; DSTAT-"); sendHexByte(reg);
	sendCrLf();
#endif
}

/****************************************************************
	Function : dma1ir
	This is the ISR for the DMA Channel 1. It is vectored to
	at the end of a DMA transfer.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void dma1ir ( void )
{
	byte reg ;

	//-------------------------------------------------
	//	stop the DMA on Channel 1
	//-------------------------------------------------
#if defined( DMA_INT_DEBUG )
	ddputs_nnl("2: stop ch1 DSTAT-"); sendHexByte(input8( DSTAT ));
#endif
	reg = input8( DSTAT ) ;

#if defined(VENUS2)
	if ( z80_venus2 ) {
		//-------------------------------------------------
		//-------------------------------------------------
		// For Venus II, the DMA Master enable no longer
		// gets knocked down by Disabling a single channel
		// - so, the following single line can replace the
		// more convoluted work-around.
		//-------------------------------------------------
		//-------------------------------------------------
		output8( DSTAT, reg & 0x17 ) ;
	}
	else
#endif
	{
		output8( DSTAT, reg & 0x67 ) ;

		//-------------------------------------------------
		// if ch0 was active
		// but the ch0 bcr==0 then deactivate ch0
		//-------------------------------------------------
		if ( (reg & 0x40) && !(input8( BCR0H ) | input8( BCR0L )) ) {
		//if ( (reg & 0x40) && !input8( BCR0H ) && !input8( BCR0L ) ) {
			output8( DSTAT, reg & 0x0f ) ;
			dmach1Flg = TRUE ;
		}
	}

	// Don't keep interrupts off any longer than need be,
	// may cause dma0ir to not run "soon enough"
	enable_interrupt();

#if defined( DMA_INT_DEBUG )
	reg = input8( DSTAT ) ;
	ddputs_nnl("; DSTAT-"); sendHexByte(reg);
	sendCrLf();
#endif

#if defined( TX_DMA_DEBUG )
	if ( z80_dma_debug ) {
		sendDumbChar( 'n' ) ;
		sendCrLf();
	}
#endif

	//----------------------------------------------------
	//	adjust read ptr to reflect just completed DMA
	//----------------------------------------------------
	IO_DTE_TX_RPTR = z80_dte_tx_rptr ;

	//-------------------------------------------------
	//	More data to send?
	//-------------------------------------------------
	if ( (IO_DTE_TX_WPTR != IO_DTE_TX_RPTR)
		 && (((S.ModemOptions.FlowControl == HW_FLOWCTRL) &&
			  !(input8 ( ASCI_CTLB0_REG ) & ASCI_CTS))
			 || ((S.ModemOptions.FlowControl == SW_FLOWCTRL) &&
				 !in_xof_from_dte)) ) {
#if defined( TX_DMA_DEBUG )
		if ( z80_dma_debug ) sendDumbChar( 'i' ) ;
#endif
		z80_start_tx_dma() ;
	}
	else {
		z80_no_more_tx = TRUE ;
	}
	disable_interrupt();
}
#endif

#if defined( Z80_EASCI_RX_DMA )
/****************************************************************
	Function : z80_flush_rx_dma
	Called when the application environment flushes the rx queue.
	Allows the ch0 DMA to track the task environment.
*****************************************************************/
non_banked void z80_flush_rx_dma ( void )
{
	if ( z80_rx_dma )
	{
		disable_interrupt () ;
			z80_dte_rx_wptr = IO_DTE_RX_WPTR ;
			z80_start_rx_dma() ;
		enable_interrupt () ;

		ddputs_nnl("Flush Ch0");
		sendCrLf();
	}
}

/****************************************************************
	Function : z80_start_rx_dma
	Calculates the number of contiguous bytes available in the
	receive buffer and sets up and starts the Channel 0 DMA transfer.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_start_rx_dma ( void )
{
	word cnt;
	byte reg;

	if ( !z80_rx_dma )
	{
		//----------------------------------------
		//		do the one time stuff
		//----------------------------------------
			// Dest register - upper byte (0x0fxxxx)
		output8( DAR0B, (byte)0x0f ) ;
			// source register
		output8( SAR0B, 1 ) ;	// selects EASCI RX as source
		output8( SAR0L, ASCI_RX0_REG ) ;
		output8( SAR0H, 0 ) ;
			// set up dmode register
			//	src = I/O fixed (0000xx00b)
			//	dst = memory++  (00xx0000b)
		output8 ( DMODE, 0x0c ) ;

			//	set w.s. for on-line mode
		z80_set_ser_wstates( TRUE ) ;

		z80_rx_dma = TRUE ;
		sendDumbChar('#');
	}

		// Destination register - lower 2 bytes
	output8( DAR0L, (byte)z80_dte_rx_wptr ) ;
	output8( DAR0H, (byte)((word)z80_dte_rx_wptr >> 8) ) ;

		// count - to end of buffer
	cnt = (word)(IO_DTE_RX_EPTR - z80_dte_rx_wptr) ;
	output8( BCR0L, (byte)cnt ) ;
	output8( BCR0H, (byte)(cnt>>8) ) ;

	//-------------------------------------------------
	//		Start ch0 DMA and enable CH0 interrupt.
	//-------------------------------------------------
#if defined( DMA_INT_DEBUG )
	ddputs_nnl("3: start ch0 DSTAT-"); sendHexByte(input8( DSTAT ));
#endif

	reg = input8( DSTAT ) ;
	output8( DSTAT, (reg & 0xaf) | 0x44 ) ;

#if defined( DMA_INT_DEBUG )
	reg = input8( DSTAT ) ;
	ddputs_nnl("; DSTAT-"); sendHexByte(reg);
	sendCrLf();
#endif
}

/****************************************************************
	Function : dma0ir
	This is the ISR for the DMA Channel 0. It is vectored to
	at the end of a DMA transfer.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void dma0ir ( void )
{
	byte reg ;

	if ( z80_rx_dma )
	{
		#if defined(FRM_HOST_DMA_TEST)
		if ( dma_test == 0x55 )
		{
			ddputs_nnl("Cause a DMA OVERRUN to occur!"); sendCrLf();
			dma_test = 0;
		}
		#endif // FRM_HOST_DMA_TEST

		//-------------------------------------------------
		//	Set-up for more received data
		//	(i.e. the whole buffer).
		//-------------------------------------------------
		#if 0
		z80_dte_rx_wptr = IO_DTE_RX_SPTR ;
		IO_DTE_RX_WPTR = IO_DTE_RX_SPTR ;
		#else

		// Check for data lingering in EASCI receive FIFO
		z80_dte_rx_wptr = IO_DTE_RX_SPTR ;
		while ( input8( ASCI_STAT0_REG ) & 0x80 ) {
			*z80_dte_rx_wptr++ = input8( ASCI_RX0_REG );
		}
		// Update write pointer
		IO_DTE_RX_WPTR = z80_dte_rx_wptr;
		#endif
		z80_start_rx_dma() ;

#if defined( RX_DMA_DEBUG )
		if ( z80_dma_debug ) sendDumbChar( 'i' ) ;
#endif

	}
	else
	{
		//-------------------------------------------------
		//	stop the DMA on Channel 0
		//-------------------------------------------------
#if defined( DMA_INT_DEBUG )
		ddputs_nnl("4: stop ch0 DSTAT-");
		sendHexByte(input8( DSTAT ));
#endif
		reg = input8( DSTAT ) ;

#if defined(VENUS2)
		if ( z80_venus2 )
		{
			//-------------------------------------------------
			//-------------------------------------------------
			// For Venus II, the DMA Master enable no longer
			// gets knocked down by Disabling a single channel
			//- so, the following single line can replace the
			// more convoluted work-around.
			//-------------------------------------------------
			//-------------------------------------------------
			output8( DSTAT, reg & 0x2b ) ;
		}
		else
#endif
		{
			output8( DSTAT, reg & 0xab ) ;

			//-------------------------------------------------
			// if ch1 was active
			// but the ch1 bcr is now 0 then deactivate ch1
			//-------------------------------------------------
			if ( (reg & 0x80) && !(input8( BCR1H ) | input8( BCR1L )) )
			{
				output8( DSTAT, reg & 0x0f ) ;
				dmach0Flg = TRUE ;
			}
		}
#if defined( DMA_INT_DEBUG )
		ddputs_nnl(";  DSTAT-"); sendHexByte(input8( DSTAT ));
		sendCrLf();
#endif
#if defined( RX_DMA_DEBUG )

		if ( z80_dma_debug )
		{
			sendDumbChar( 'n' ) ;
			sendCrLf();
		}
#endif
	}
}

/****************************************************************
	Function : z80_stop_rx_dma
	returns the DMA channel to the Host TX channel for use with
	Software Flow control.

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_stop_rx_dma ( void )
{
	if ( z80_rx_dma )
	{
		byte reg ;

		//-------------------------------------------------
		//	stop the DMA on Channel 0 and update the
		//	buffer ptr for subsequent EASCI RX interrupts.
		//-------------------------------------------------
#if defined( DMA_INT_DEBUG )
		ddputs_nnl("5: stop ch0 DSTAT-"); sendHexByte(input8( DSTAT ));
#endif
		reg = input8( DSTAT ) ;
		output8( DSTAT, reg & 0xab ) ;

		//-------------------------------------------------
		// if ch0 was active
		// but the ch0 bcr==0 then deactivate ch0
		//-------------------------------------------------
		if ( (reg & 0x40) && !(input8( BCR0H ) | input8( BCR0L )) )
		{
			output8( DSTAT, reg & 0x0f ) ;
#if defined( Z80_EASCI_TX_DMA )
			dmach1Flg = TRUE ;
#endif
		}

#if defined( DMA_INT_DEBUG )
		ddputs_nnl(";  DSTAT-"); sendHexByte(input8( DSTAT ));
		sendCrLf();
#endif
			// Destination register
		output8( DAR0B, 1 ) ;	// selects EASCI TX as destination
		output8( DAR0H, 0 ) ;
		output8( DAR0L, ASCI_TX0_REG ) ;
				// source register
		output8( SAR0B, (byte)0x00 ) ;
			// count
		output8( BCR0H, 0 ) ;
			// set up dmode register
			//	src = memory++
			//	dst = I/O fixed
		output8 ( DMODE, 0x30 ) ;
		z80_rx_dma = FALSE ;

		UART_Flush ( 0 ) ;

			// back to fixed # of w.s.
		z80_set_ser_wstates( FALSE ) ;

		sendDumbChar('_');
	}
}
#endif	//if defined( Z80_EASCI_RX_DMA )

#if 0	// for debug of v42bis
non_banked void PrntECM ( void )
{
	while (!(input8(DUMB_LSR) & 0x20)) ;
	output8(DUMB_DATA, 'E');
	while (!(input8(DUMB_LSR) & 0x20)) ;
	output8(DUMB_DATA, 'C');
	while (!(input8(DUMB_LSR) & 0x20)) ;
	output8(DUMB_DATA, 'M');
	while (!(input8(DUMB_LSR) & 0x20)) ;
	output8(DUMB_DATA, ' ');
}

non_banked void PrntETM ( void )
{
	while (!(input8(DUMB_LSR) & 0x20)) ;
	output8(DUMB_DATA, 'E');
	while (!(input8(DUMB_LSR) & 0x20)) ;
	output8(DUMB_DATA, 'T');
	while (!(input8(DUMB_LSR) & 0x20)) ;
	output8(DUMB_DATA, 'M');
	while (!(input8(DUMB_LSR) & 0x20)) ;
	output8(DUMB_DATA, ' ');
}
#endif

/****************************************************************
	Function : Main
*****************************************************************/
non_banked void main ( void )
{
	void serMain ( void ) ;
	serMain() ;
}
