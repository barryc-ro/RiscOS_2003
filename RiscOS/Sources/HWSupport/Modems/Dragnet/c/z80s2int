/*name and version number:@(#)z80s2int.c	1.17*/
/*date of get: 		  09/06/00 16:59:21*/
/*date of delta:	  01/05/99 15:22:27*/
/****************************************************************
File :  z80s2int.c
Description :
    Contains the function to convert the Z80 output file in Motorola 
    S-Record Format to Intel Format.
    The function first converts the Motorola S-Record Format to binary
    format, then converts the binary format to Intel format.
    The function fill's all unused space to 0xff.
    The function is defined for 128K * 8 rom. 
    This may be extended to 256K * 8 rom.
    Input - modem.hex   Output - modemi.hex

Procedures Contained :
    main

Revision History :
    Initials    Date        Change
    RJ          20/03/95    Initial
    mah		6/20/96	    convert to use 32bit mode (DOS-extender)
						compile with:
								wcl386 /l=dos4g z80s2int /oxt
						then make sure dos4gw.exe is in the path.
	mah		8/7/96		also allow Win32 console compilation
						with MSVC 4.x

	mah			5/2/97  add optional paramter to account
						for boot-block flash loader
*****************************************************************/

#if defined(_MSC_VER)
#include <windows.h>
#else
#include <i86.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SHORT_ADD 4
#define LONG_ADD 6 
//#define PRINT_TIME_DEBUG

typedef unsigned char byte;
typedef unsigned short word;
typedef unsigned long dword;

char record_buf[100];

void fatalError(char *msg)
{
#if defined(_WIN32)
	MessageBox(NULL, msg, "z80s2int error", MB_OK|MB_ICONSTOP);
#else
	fprintf(stderr, "%s\n", msg);
#endif
	exit(-1);
}


/*************************************************/
/* Convert ASCII HEX character hexch to its
 * binary value.
 *
 * (This only takes care of uppercase A-F characters)
 */
byte hex_to_bin(char hexch)
{
	if (hexch <= '9' && hexch >= '0')
		return hexch - '0';

	if (hexch <= 'F' && hexch >= 'A')
		return hexch - 'A' + 10;

	{
		char buf[80];

		sprintf(buf, "illegal value in hex_to_bin 0x%0X", hexch);
		fatalError(buf);
	}
	return 1;
}

int imageError = 0;

/*************************************************/
/* put value in its place in the array.
 * Do a check to make sure nothing's there already.
 */
void add_to_image(byte *bp, int loc, byte bin_value)
{
	if ((0xff != bp[loc]) && ((loc < imageError) || (!imageError)))
	{
		imageError = loc;
		if (!loc)
			imageError = 1;
	}
	bp[loc] = bin_value;
}

/***********************************************/
byte get_bin_value (char ch1, char ch2 )
{
	byte temp1, temp2;

	temp1 = hex_to_bin(ch1);
	temp2 = hex_to_bin(ch2);

	return (temp1<<4) + temp2;
}

char hextable[]="0123456789ABCDEF";

/*******************************************
 * put_bin_value - convert value to two-digit
 * hex string and place at outstr
 */
void put_bin_value(byte *outstr, byte value)
{
	outstr[1] = hextable[value & 0x0F];
	value >>= 4;
	outstr[0] = hextable[value];
}
/***********************************************/
/* Retrieve an address from an S-record.
 * The address is key bytes long and starts
 * at byte 4 of record_buf[]
 */
long  get_add (int key )
{
	long value = 0L;
	int i;

	for (i=0; i < key; i++)
	{
		value <<= 4;
		value += hex_to_bin(record_buf[4+i]);
	}

	return value;
}

long checksum_loc;		// where to put the checksum
						// if this is zero that means
						// do things the old way and put
						// the checksum and the end of the
						// used space (1M 2M 4M space completely filled)

long file_length;		// length of current file (kBytes)
long max_length;		// maximum allowed file length (kBytes)
#define MAXEVERBYTES		((long) (max_length * 1024L))
#define FILEMAXBYTES		((long) (file_length * 1024L))
#define CHECKSUM_LOC	 (checksum_loc ? checksum_loc : FILEMAXBYTES - 2)
#define BB_CHECKSUM_LOC	 0x1C

void checkAddress(const long address)
{
	if (address > FILEMAXBYTES)
	{
		if (address <= MAXEVERBYTES)
		{
			if (checksum_loc)
			{
				// make sure the file length is enough to
				// handle this guy
				file_length = (address >> 10) + 1;
			}
			else
			{
				long new = 256;

				if (256 == file_length)
					new = 512;
				fprintf(stdout, "Warning, more than %ld k bytes, now assuming %ld k part\n",
						file_length, new);
				file_length = new;
			}
			return;
		}
		fatalError("**** File too big! ****\n(Too much ROM used in modem.hex file.)");
	}
}

/***********************************************/
/***********************************************/

#if defined(__WATCOMC__)
#define	DOSTIME	((dword) *((dword __far *) MK_FP(0x40, 0x6c)))
#endif

#if defined(_MSC_VER)
#define	DOSTIME	GetTickCount()
#endif

void main(int argc, char *argv[])
{
	FILE *in_hex, *out_intel;
	long i, index, address;
	byte bin_value, length, end_of_file, seg, *bp, *bp2;
	byte no_of_64k_segments = 2;
	char intel_data_record[77] ;
	char intel_seg_record[] = ":02000002000000\n";
	char intel_eof_record[] = ":00000001FF\n";
	int checksum;
	word rom_checksum;
	dword bytesUsed = 0;
	div_t cc;
	short basic_sum;
#if defined(PRINT_TIME_DEBUG)
	dword beginTime = DOSTIME;	/* this is for timing optimization */
#endif

	seg = 0;
	file_length = 128;
	max_length = 512;	// handle up to a 4M-bit (512k byte) part

	bp = malloc(MAXEVERBYTES);
	if (NULL == bp)
	{
		fatalError("Couldn't malloc space");
	}

	// Optional first argument is checksum location in kbytes.
	// If this argument is filled in non-zero then we will only
	// calculate the checksum on the bytes above the checksum
	// location.  We will then also fill in the checksum
	// location+2 with the length of the image in paragraphs.
	checksum_loc = 0;
	if (2 == argc)
	{
		checksum_loc = strtoul(argv[1], NULL, 0) << 10;
	}

	intel_data_record[0] = ':';
	intel_data_record[1] = '2';
	intel_data_record[2] = '0';
	intel_data_record[7] = '0';
	intel_data_record[8] = '0';
	intel_data_record[75] = '\n';
	intel_data_record[76] = (char) 0;

	/* Fill image space with fill byte - 0xff */
	bp2 = bp;
	for (index=0; index < MAXEVERBYTES; index++)
	{
		*bp2++ = 0xff;
	}
   
	/* Open (input) Hex file modem.hex */
	if ( (in_hex = fopen("modem.hex", "rt")) == NULL)
	{
		fatalError("Couldn't open modem.hex");
	}

	fprintf(stdout, "z80s2int - Version 2.51\n");

	end_of_file=0;

	/* Read first 10 characters for each line */
	while (end_of_file==0)
	{
		fgets(record_buf, 98, in_hex);
        
		if  (record_buf[0] =='S')
		{
			/* Find record length */
			length = get_bin_value(record_buf[2], record_buf[3]);
            
			switch (record_buf[1])
			{
			case '0' : //First record contains file name.
				//Nothing to write in binary file.
				break;

			case '1' : //Data record 
				//Get Address
				address = get_add(SHORT_ADD);
				checkAddress(address+length-3);
                        
				for (i=0; i<(length-3); i++)
				{       
					bin_value = 
						get_bin_value(record_buf[8+2*i],
									  record_buf[9+2*i]);
					add_to_image(bp, address+i, bin_value);
				}
				bytesUsed += length - 3;
				break;

			case '2' : //Data record 
				//Get Address
				address = get_add (LONG_ADD );
				checkAddress(address+length-4);
                        
				for (i=0; i<(length-4); i++)
				{       
					bin_value = get_bin_value(record_buf[10+2*i],
											  record_buf[11+2*i]);
					add_to_image(bp, address+i, bin_value);
				}
				bytesUsed += length - 4;
				break;

			case '3' : //End of File record - 16 bit program entry
			case '8' : //End of File record - 24 bit program entry
			case '9' : //End of File record - 16 bit program entry
				end_of_file=1;
				break;

			default:
				fatalError("Error!  Unknown S-Record type!\n");
				exit(-1);
				break;

			} /* Switch */

		} /* Sfile */
		else
			end_of_file=1;
	} /* while  */
	fclose(in_hex);

	if (imageError)
	{
		char buf[80];

		sprintf(buf, "Multiple bytes assigned to the same place in ROM.\n\
First overlapping location is 0x%05X", imageError);
		fatalError(buf);
	}

	/* fill checksum loc */
	bp[CHECKSUM_LOC] = 0;
	bp[CHECKSUM_LOC+1] = 0;

	// fill in length if this is
	// a boot block loader case.
	if (checksum_loc)
	{
		word l = (word) (file_length << 6);

		bp[checksum_loc+2] = (byte) (l & 0xff);
		bp[checksum_loc+3] = (byte) ((l & 0xff00) >> 8);


		// Calculate boot block checksum.  This is so
		// the loader can know if the boot block it is
		// about to download is identical to the one already
		// on the modem.

		// Initialize RRFL checksum to zero.
		bp[BB_CHECKSUM_LOC] = bp[BB_CHECKSUM_LOC+1] = 0;
		bp2 = &bp[0];
		rom_checksum = 0;
		for (index=checksum_loc; index > 0 ; index--)
		{
			rom_checksum += *bp2++; 
		}

		/* Write the bb checksum into its place */
		bp[BB_CHECKSUM_LOC] = (byte) (rom_checksum & 0xff);
		bp[BB_CHECKSUM_LOC+1] = (byte) ((rom_checksum & 0xff00) >> 8 );
	}

	/* Calculate rom checksum */
	bp2 = &bp[checksum_loc];
	rom_checksum = 0;
	for (index=FILEMAXBYTES; index > checksum_loc ; index--)
	{
		rom_checksum += *bp2++; 
	}

	if (checksum_loc)
	{
		fprintf(stdout,
				"Used %ldk bytes (top address 0x%lXXXX)\n", (bytesUsed/1024)+1,
				FILEMAXBYTES >> 12);
	}
	else
	{
		fprintf(stdout,
				"Used %ld bytes (out of %ld)\n", bytesUsed, FILEMAXBYTES);
	}
  
	/* Write the checksum into its place */
	bp[CHECKSUM_LOC] = (byte) (rom_checksum & 0xff);
	bp[CHECKSUM_LOC+1] = (byte) ((rom_checksum & 0xff00) >> 8 );

	/* add in the checksum bytes themselves so we'll have
	 * the checksum of the ROM.  This is what the ati1 command
	 * calculates.  z80_checksum(TRUE).
	 */
	rom_checksum += bp[CHECKSUM_LOC];
	rom_checksum += bp[CHECKSUM_LOC+1];

	fprintf(stdout, "ROM checksum (ati1) is %04X.  \n", rom_checksum);

	/* ---------------- now on to the output file ------------ */

	if ( (out_intel = fopen("modemi.hex", "w+t")) == NULL)
	{
		fatalError("Error opening modemi.hex\n");
	}

	no_of_64k_segments = file_length / 64;

	if (file_length & 0x003f)
		no_of_64k_segments++;		// not integer number of 64k segments

	while (seg < no_of_64k_segments)
	{
		long last_adr = 0xffe0;

		// for segments that aren't wholely filled we need
		// to calculate just how much needs to be spit out.
		if ((file_length & 0x003f) && (seg == no_of_64k_segments-1))
		{
			last_adr = (file_length << 10) - 0x20;
			last_adr &= 0xffe0;
		}

		for (address = 0; address<=last_adr; address=address+0x20)
		{
			int mustPrint;

			basic_sum = 0;
			mustPrint = 0;

			/* Convert binary values to hex and put into record */
			for (index=0; index<32; index++)
			{
				bin_value = bp[((long) seg * 64L * 1024L) +
								  address + index];
				/* add to checksum for this line */
				basic_sum += bin_value;

				if (0xff != bin_value)
					mustPrint = 1;

				put_bin_value(&intel_data_record[9+ (2*index)], bin_value);

			} /* index loop  */

			// skip line if all FF's
			if (!mustPrint)
				continue;
             
			/* Convert address to hex and put into record */
			put_bin_value(&intel_data_record[5], (byte) (address & 0xff));
			put_bin_value(&intel_data_record[3],
						  (byte) (address >> 8));

			/* Calculate checksum.  We've already done
			 * some work calculating basic_sum above.
			 */
			/* Add sum of address bytes and constant 0x20 */
			basic_sum = basic_sum + 0x20  
				+ get_bin_value(intel_data_record[3],intel_data_record[4])
				+ get_bin_value(intel_data_record[5],intel_data_record[6]);
			cc = div(basic_sum, 256);
			if (cc.rem ==0)
				checksum=0;
			else
				checksum = 256 - cc.rem;

			/* Convert checksum to hex and put in record */
			put_bin_value(&intel_data_record[73], (byte) checksum);
			fputs(intel_data_record, out_intel);
	      
		} /* address loop */
		seg++;
		if (seg < no_of_64k_segments) /* Don't update for last seg */
		{
			/* Enter a segment record with updated segment */
			intel_seg_record[9] = hextable[seg];

			/* Sum of data bytes */
			basic_sum = 0x02 + 0x02 + (seg<<4);
			cc = div(basic_sum, 256);
			if (cc.rem ==0)
				checksum=0;
			else
				checksum = 256 - cc.rem;

			/* Convert checksum to hex and put in record */
			put_bin_value(&intel_seg_record[13], (byte) checksum);
			fputs(intel_seg_record, out_intel);
		}
	} /* segment loop */

	/* Enter End of file record */
	fputs(intel_eof_record, out_intel);

	fclose(out_intel);

	free(bp);
#if defined(PRINT_TIME_DEBUG)
	fprintf(stdout, "Time elapsed for conversion is %ld ticks (%6.1f ms)\n",
			DOSTIME - beginTime, (DOSTIME - beginTime) * 1.0
#if defined(__WATCOMC__)
			* 54.9
#endif
			);
#endif
	exit(0);
}

