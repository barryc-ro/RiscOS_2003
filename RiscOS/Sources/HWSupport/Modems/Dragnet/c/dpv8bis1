/*name and version number:@(#)dpv8bis1.c	1.135*/
/*date of get: 		  12/15/00 10:10:28*/
/*date of delta:	  11/30/00 16:57:38*/
/****************************************************************
File :	dpv8bis1.c
Description :
	Contains all functions related to the V.8bis for dce originate
	and answer negotiation state machine. K56FLEX

Procedures Contained :

Revision History :
	Initials	Date		Change
*****************************************************************/

#define Z80_DEBUG_THIS_FILE

#include "llglob_d.h"

#if defined (V8BIS) || defined (V92)
#include "dpglob.h"
#include "lapm.h"
#include "v42bis.h"
#include "ioglob_d.h"
#include "sync.h"
#include "z80glob.h"

#if !defined(CS_MODEM) && defined(Z80_DEBUG_PRINT) && !defined(USB_MODEM)
  #define MODEM_Z80_V8BIS_DEBUG
  #define	V8BIS_DEBUG
#endif	//CS_MODEM && Z80_DEBUG_PRINT && USB_MODEM

#if (defined(V8BIS_DEBUG) || defined(MODEM_ARM)) && !defined(MODEM_Z80)
# if defined(MODEM_ARM)
#  define V8BIS_DEBUG
#  define V8BIS_PRINTF(m,v) 	\
	do { printf( (m), (v) ); sendCrLf(); } while(0)
# else
#  include <stdio.h>
   static byte szBuffer[80];
#  define V8BIS_PRINTF(m,v)		\
	do { sprintf( szBuffer, (m), (v) ); x_debug_msg( szBuffer ); } while(0)
# endif	//CS_4
#else
# define V8BIS_PRINTF(m,v)
#endif	//V8BIS_DEBUG || CS_4

#ifdef CS_DEBUG
 #include "dpv8bis1.h"
#endif	//CS_DEBUG
#include "allglobs.h"

extern void vpcm_set_calling_mode (void) ;
extern void vpcm_set_answering_mode (void) ;
#if defined (V92)			//pwwlkl
byte dp_v8bis_v92_options_check(void) ;
#endif			//	pwwlkl
/**************************************************************************
	Global Variables
***************************************************************************/
#define	F_ESi_S		0x3051			// ESi 980 Hz
#define	F_ESi_C		0x29F9
#define F_980_S		0x3051			// initiating preamble tone 980 Hz
#define	F_980_C		0x29f9
#define F_1650_S	0x3f75			// responding preamble tone 1650 Hz
#define	F_1650_C	0x0851
#define MS280		280

/****************************************************************
Routine : dp_v8bis_originate
Description :

	Originating modem: check whether we should negotiate v8bis for
	datacall first.
*****************************************************************/
byte dp_v8bis_originate(void)
{
	if ((G(S).ModemOptions.V8bis != V8BIS_DCE_CONTROL)
#if defined(DC0) || defined(CS_ETC)
		|| (G(cell_active) == TRUE)
#endif	//DCO || CS_ETC
		)
		return FALSE;

#ifdef V8BIS
#if defined (VENUS_AT_CS) || defined (CS_DIGITAL)
	return FALSE;		// CS can't originate K56FLEX

#else	// !VENUS_AT_CS && !CS_DIGITAL

#ifdef VPCM_CLIENT
	// bypass v8bis to test dsp quick connect
	if (G(S).ModemOptions.VpcmOption & 0x80)
	{
		// bypass v8bis to test dsp quick connect
		if (G(S).ModemOptions.VpcmOption & BIT2)	// V.92 quick connect enable
		{
			//set connection status bit
			G(vpcm_connection_status) = G(vpcm_connection_status) | 0x2;
			// set bit 8 in dsp ram 0x1ff2 for DSP QC short phase 1 startup
			dp_write_dsp_ram(0x1ff2, (word) (dp_read_dsp_ram(0x1ff2) | 0x100) );
			x_debug_msg("DP- force QC short phase 1 enabled, no v8bis");
			return FALSE;
		}
		else
		{
			// no K56FLEX or V.92 quick connect enabled.
			// stay in same state to detect answer tone.
			// need to setup tone detector again
			x_debug_msg("DP-no FLEX or quick connect enabled");
			return FALSE;
		}
	}
#endif // VPCM_CLIENT

	if (G(S).ModemOptions.Rate56K == 0)
	{
		x_debug_msg("DP-V.90 disabled");
		return FALSE;
	}
#if defined (V92)				//pwwlkl
	if (dp_v8bis_v92_options_check() == TRUE )
	{
		x_debug_msg("dp_v8bis_originate()=TRUE");
		return TRUE;
	}
#endif							//pwwlkl
	else
	{
		return FALSE;
	}
	return TRUE;
#endif // central site
#endif	//V8BIS
}
/*******************************************************************
Routine : dp_v8bis_singletone_detect
Description : look for v8bis single tone
********************************************************************/
word dp_v8bis_singletone_detect(byte param1)
{
	byte temp = 0;

	switch (dp_read_dsp_ram(0x28))
	{
		case 0x0001:
			temp = 1;
			break;
		case 0x0002:
			if ( param1 == 0 )	// look for initiating tones
				temp = 2;
			else
				temp = 7;	
			break;
		case 0x0004:
			temp = 3;
			break;
		case 0x0008:
			if ( param1 == 0 )	// look for initiating tones
				temp = 5;
			else
				temp = 9;
			break;
		case 0x0010:
			temp = 6;
			break;
		case 0x0020:
			temp = 10;
			break;
		default:
			break;
	}
	if ( temp != 0 )
	{
		if ( x_elapsed_time ( G(dp_v8bis_timer1) ) > MS50 )
		{
			return temp;
		}
	}
	else
	{
		G(dp_v8bis_timer1) = x_current_time();
	}
	return 0;
}
/****************************************************************
Routine : dp_v8bis_v21_startup
*****************************************************************/
void dp_v8bis_v21_startup ( byte param1,  byte param2 )
{
	// param1 = 0 => initiating satation,  = 1 => responding station
	// param2 = 0 => tx mode,              = 1 => rx mode

	byte set_mode ;
	byte total_tones_to_look_for ;

#if defined (VENUS_AT_CS) || defined (CS_DIGITAL)
	total_tones_to_look_for = 1;
#else
	total_tones_to_look_for = 0;
#endif //defined (VENUS_AT_CS) || defined (CS_DIGITAL)

	dp_modem_idle_cmd () ;
	io_init_dce_tx_fifo () ;
	io_init_dce_rx_fifo () ;

#ifdef V8BIS_DEBUG
	x_debug_msg("v8bis - download v8bis 1");
#endif
	dp_download_V8bis ();

	dp_write_dsp_ram ( 0x080d, 0x0000 ) ;
	dp_write_dsp_ram ( 0x01, 0x0 ) ;	// clear v.32 rate selection
	dp_write_dsp_ram ( 0x2, 0x0 ) ;		// clear low-speed
	dp_write_dsp_ram ( 0xc, 0x0 ) ;		// clear v.17 rate selection
	// set dsp for quick v.21 startup - bit 13
	dp_write_dsp_ram ( 0x39, 0x2800) ;	// set DP_RTS to be H_RTS
	dp_write_dsp_ram ( 0x48, 2000) ;	// drop out timeout set to 2 secs
	dp_write_dsp_ram ( 0x37, 40) ;		// rev signal threshold 
#if defined(VENUS_AT_CS) || defined(CS_MODEM)
	dp_transmit_level ( G(S).ModemOptions.TxLevel ) ;
#else
	dp_transmit_level ( 10 ) ;
#endif
	dp_write_dsp_ram ( 0x2, FAX_300 ) ;	// low-speed rate selection
	G(dp_dsp_data_in_progress) = FALSE ;

	if ( param2 == 0 )
	{
		if ( param1 == 1 )
		{
			// it is responding station, tx mode
			set_mode = 3;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - v21= resp. station tx mode (3) - V21 (H)" );
#endif
		}
		else
		{
			// it is initiating station, tx mode
			set_mode = 0;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - v21= init. station tx mode (0) - V21 (L)" );
#endif
		}
		dp_async_8bit_mode () ;
	}	
	else
	{
		if ( param1 == 1 )
		{
			// it is responding station, rx mode
			set_mode = 2;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - v21= resp. station rx mode (2) - V21 (L)" );
#endif
		}
		else
		{
			// it is initiating station, rx mode
			set_mode = 1;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - v21= init. station rx mode (1) - V21 (H)" );
#endif
		}
		dp_hdlc_mode () ;
	}
	G(x_line_rate) = MR_300 ;
	dp_modem_command_long ( V8BIS_V21_CMD, V8BIS_V21_ADDR_HIGH,
							V8BIS_V21_ADDR_LOW, set_mode,
							total_tones_to_look_for );
	LRF.status = EMPTY ;
	LRF.len = 0 ;
}
/****************************************************************
Routine : dp_v8bis_preamble_tone_tx_setup
Description : setup to xmit preamble tone
*****************************************************************/
void dp_v8bis_preamble_tone_tx_setup ( byte param1 )
{
	// param1 = 0 => initiating satation,  = 1 => responding station
	// param2 = 0 => tx mode,              = 1 => rx mode

	dp_v8bis_v21_startup ( param1,  0 ) ;
}
/******************************************************************
Routine : dp_v8bis_msg_xmit 
*******************************************************************/
void dp_v8bis_msg_xmit ( byte param1 )
{
	byte *ptr ;
	
	// if param1 == 1 : transmit 56k CL message
	// if param1 == 2 : transmit ACK message
	// if param1 == 3 : transmit NAK message
	// if param1 == 6 : transmit v92 QC2a message
	// if param1 == 7 : transmit v92 QCA2d message
		
	dp_hdlc_mode () ;

	G(io_dce_buf)[ 0 ] = (word) (HDLC_TX_ANY_CHAR | 0x7e) ;
	G(io_dce_buf)[ 1 ] = (word) (HDLC_TX_ANY_CHAR | 0x7e) ;
	G(io_dce_buf)[ 2 ] = (word) (HDLC_TX_ANY_CHAR | 0x7e) ;
	G(io_dce_buf)[ 3 ] = (word) (HDLC_TX_ANY_CHAR | 0x7e) ;
	// transmit 3 flags at begining
	io_write_dce_fifo ( 3, G(io_dce_buf) ) ;

	ptr = (byte *) &(G(io_dce_buf)[20]) ;
	switch ( param1 )
	{
#ifdef V8BIS
#if defined (K56FLEX)
#if defined(VENUS_AT_CS) || defined(CS_MODEM)
		case 1 :
			// xmit 56k CL msg
			*ptr++ = 0x12 ;		// rev.1, CL type
			*ptr++ = 0xc1 ;		// identification field NPar1, non-standard, V8
			*ptr++ = 0x80 ;		// identification field SPar1, no parameters
			*ptr++ = 0x80 ;		// standard information field NPar1, no parameters
			*ptr++ = 0x80 ;		// standard information field SPar1, no parameters
			*ptr++ = 0x09 ;		// non-standard information length = 9
			*ptr++ = 0xB5 ;		// country code = US
			*ptr++ = 0x02 ;		// provider code length = 2
			*ptr++ = 0x00 ;		// Lucent
			*ptr++ = 0x94 ;		// K56flex (generic)
			*ptr++ = 0x01 ;		// manufacturer - Lucent Microelectronics
#ifdef VPCM_SERVER
			if ( G(S).ModemOptions.VpcmOption & 1 ) 
				*ptr++ = 0x83 ;		// Product Capabilities - K56FLEX + v.90
			else
				*ptr++ = 0x81 ;		// Product Capabilities - K56FLEX
#else
			*ptr++ = 0x81 ;		// Product Capabilities - K56FLEX
#endif	// VPCM_SERVER

			*ptr++ = 0x43 ;		// k56 version 1.1 + 1.0

			*ptr++ = 0x55 ;		// DSP version (arbitrary, can't set bit 7)

			// For central site A-law is indicated
			// by S108 bit 1
			if (G(S).ModemOptions.DigitalLoss56K & 1)
			{
				*ptr++ = 0xE1 ;		// Alaw
			}
			else
			{
				*ptr++ = 0xC1 ;		// ulaw
			}
			
			ptr = (byte *) &(G(io_dce_buf)[20]) ;
			io_tx_hdlc_frame ( 15, ptr ) ;
			x_debug_msg ( "v8bis - transmit 56k CL message" );
			break ;
		case 2 :
			// xmit ACK msg
			*ptr++ = 0x14 ;		// rev.1, ACK type
			ptr = (byte *) &(G(io_dce_buf)[20]) ;
			io_tx_hdlc_frame ( 1, ptr ) ;
			x_debug_msg ( "v8bis - transmit ACK message" );
			break ;

		case 3 :
			// xmit NAK msg
			*ptr++ = 0x1A ;		// rev.1, NAK type
			ptr = (byte *) &(G(io_dce_buf)[20]) ;
			io_tx_hdlc_frame ( 1, ptr ) ;
			x_debug_msg ( "v8bis - transmit NAK message" );
			break ;
#endif // Central Site - VENUS_AT_CS or CS_MODEM
#endif	//K56FLEX
#endif	//V8BIS
#if defined (VPCM_CLIENT)
		case 6 :
			// xmit v92 QC2a msg
			*ptr++ = 0x2d ;		// message type and rev. no.
			if (G(S).ModemOptions.V42 & V42_LAPM_BIT)
			{
				*ptr++ = 0x20 ;		// parameter field with v42
			}
			else
			{
				*ptr++ = 0x00 ;		// parameter field without v42
			}
			ptr = (byte *) &(G(io_dce_buf)[20]) ;
			io_tx_hdlc_frame ( 2, ptr ) ;
			x_debug_msg("v8bis - transmit v92 QC2a message");
			break ;
#endif //defined (VPCM_CLIENT)
#if defined (VENUS_AT_CS) || defined (CS_DIGITAL)
		case 7 :
			// xmit v92 QCA2d msg
			*ptr++ = 0x2d ;		// message type and rev. no.
			if (G(S).ModemOptions.V42 & V42_LAPM_BIT)
			{
				*ptr++ = 0xE0 ;		// parameter field with v42
			}
			else
			{
				*ptr++ = 0xC0 ;		// parameter field without v42
			}
			ptr = (byte *) &(G(io_dce_buf)[20]) ;
			io_tx_hdlc_frame ( 2, ptr ) ;
			x_debug_msg("v8bis - transmit v92 QCA2d message");
			break ;
#endif //defined (VENUS_AT_CS) || defined (CS_DIGITAL)
	}

	// transmit 3 flags to make sure data is sent
	io_write_dce_fifo ( 4, G(io_dce_buf) ) ;
}
/****************************************************************
Routine : dp_v8bis_get_rx_msg
Description :
	Get one HDLC frame from the LAPM receive frame queue.
*****************************************************************/
byte dp_v8bis_get_rx_msg ( void )
{
	lapm_rx_hdlc_frame();
	if (LRF.status == FULL)
	{
		if ( ( LRF.len == 1 ) && ( LRF.data[0] == 0xfc ) )
		{
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - got 1 byte error" ) ;
#endif
			LRF.status = EMPTY;
			LRF.len = 0;
			return FALSE;
		}
		else
		{
#ifdef V8BIS_DEBUG
			x_debug_msg("v8bis received hdlc frame");
#endif
			return TRUE;
		}
	}
	return FALSE;
}
#endif	//V8BIS || V92

#ifdef V8BIS
/****************************************************************
		routines for central / callee / answer site
*****************************************************************/

#if defined(VENUS_AT_CS) || defined(CS_MODEM)
/****************************************************************
Routine : dp_v8bis_answer
Description :
  Answering modem: check whether we should negotiate v8bis
*****************************************************************/
byte dp_v8bis_answer(void)
{
	// Rate56K - default central site value is 200
	if (G(S).ModemOptions.Rate56K >= 100)
	{
		if (G(S).ModemOptions.Rate56K == 250)
		{
			// set s38 = 250 to skip v8bis for 56k testing
			G(S).ModemOptions.Enabled56K = TRUE;
			x_debug_msg("v8bis - skip v8bis to 56k");
			G(dp_v8bis_state) = DP_V8BIS_ANS_PHASE1;
		}
		else
		{
			x_debug_msg("v8bis answer enabled");
			G(dp_v8bis_state) = DP_V8BIS_ANS_INIT;
			#if defined(CS_4)
			G(sa_v8bisDnload) = FALSE;
			#endif
		}
		return TRUE;
	}
	return FALSE;
}
/*****************************************************************
Routine : dp_v8bis_CRe_dual_tone_xmit
Description : xmit v8bis dual tone
******************************************************************/
void dp_v8bis_CRe_dual_tone_xmit ( byte param1 )
{
	word loc5, loc6, loc7, loc8 ;
	word V8bis_Sig_TxLevel ;
	
	if (G(S).ModemOptions.DigitalLoss56K & 1)		//a-law
		V8bis_Sig_TxLevel = G(S).ModemOptions.TxLevel ;
	else
		V8bis_Sig_TxLevel = 30 ;
	
	// ram05 - sin(k), ram06 - cos(k), k=2PI*f/7200, f= 1375 Hz
	// ram07 - sin(j), ram08 - cos(j), j=2PI*f/7200, f= 2002 Hz

	switch ( param1 )
	{
		case V8BIS_SIG_INIT_MRe:
		case V8BIS_SIG_INIT_CRe_LOW:
		case V8BIS_SIG_INIT_CRe_HIGH:
			loc5 = F_1375_S ;
			loc6 = F_1375_C ;
			loc7 = F_2002_S ;
			loc8 = F_2002_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - send v8bis 1375+2002 Hz init dual tones" );
#endif
			break ;

		case V8BIS_SIG_INIT_MRd:
		case V8BIS_SIG_INIT_CRd:
		case V8BIS_SIG_INIT_ESi:
			loc5 = F_1375_S ;
			loc6 = F_1375_C ;
			loc7 = F_2002_S ;
			loc8 = F_2002_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - send v8bis 1375+2002 Hz init dual tones" );
#endif
			break ;

		case V8BIS_SIG_RESP_MRd_LOW:
		case V8BIS_SIG_RESP_MRd_HIGH:
		case V8BIS_SIG_RESP_CRd:
		case V8BIS_SIG_RESP_ESr:
			loc5 = F_1529_S ;
			loc6 = F_1529_C ;
			loc7 = F_2225_S ;
			loc8 = F_2225_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - send v8bis 1529+2225 Hz resp dual tones" );
#endif
			break ;

		default:
		case V8BIS_SIG_NONE:
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - no v8bis tone" );
#endif
			break;
	}
	
	dp_write_dsp_ram (0x5, loc5 ) ;
	dp_write_dsp_ram (0x6, loc6 ) ;
	dp_write_dsp_ram (0x7, loc7 ) ;
	dp_write_dsp_ram (0x8, loc8 ) ;
	dp_write_dsp_ram (0x17, 0) ;	// reg17 - tone duration=0 mS
	dp_write_dsp_ram (0x11, (word)V8bis_Sig_TxLevel ) ; // tone power
	dp_write_dsp_ram (0x12, (word)V8bis_Sig_TxLevel ) ; // tone power
	dp_modem_command ( GENERATE_TONES, 2, 0 ) ;
}

/*****************************************************************
Routine : dp_v8bis_CRe_single_tone_xmit
Description : xmit v8bis single tone
******************************************************************/
void dp_v8bis_CRe_single_tone_xmit ( byte param1 )
{
	word V8bis_Sig_TxLevel;
	word loc5, loc6 ;

	if (G(S).ModemOptions.DigitalLoss56K & 1)		//a-law
		V8bis_Sig_TxLevel = G(S).ModemOptions.TxLevel ;
	else
		V8bis_Sig_TxLevel = 27 ;

	// ram05 - sin(k), ram06 - cos(k), k=2PI*f/7200,
   	//	f= ( V8bis_Signal_Subparameter ) Hz

	switch ( param1 )
	{
		case V8BIS_SIG_INIT_MRe:
			loc5 = F_MRe_S ;
			loc6 = F_MRe_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_init_MRe tone" );
#endif
			break ;

		case V8BIS_SIG_INIT_MRd:
			loc5 = F_MRd_S ;
			loc6 = F_MRd_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_init_MRd tone" );
#endif
			break ;

		case V8BIS_SIG_INIT_CRe_LOW:
		case V8BIS_SIG_INIT_CRe_HIGH:
			loc5 = F_CRe_S ;
			loc6 = F_CRe_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_init_CRe tone" );
#endif
			break ;

		case V8BIS_SIG_INIT_CRd:
			loc5 = F_CRd_S ;
			loc6 = F_CRd_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_init_CRd tone" );
#endif
			break ;

		case V8BIS_SIG_INIT_ESi:
			loc5 = F_ESi_S ;
			loc6 = F_ESi_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_init_ESi tone" );
#endif
			break ;
	
		case V8BIS_SIG_RESP_MRd_LOW:
		case V8BIS_SIG_RESP_MRd_HIGH:
			loc5 = F_MRd_S ;
			loc6 = F_MRd_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_resp_MRd tone" );
#endif
			break ;

		case V8BIS_SIG_RESP_CRd:
			loc5 = F_CRd_S ;
			loc6 = F_CRd_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_resp_CRd tone" );
#endif
			break ;

		case V8BIS_SIG_RESP_ESr:
			loc5 = F_ESr_S ;
			loc6 = F_ESr_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_resp_ESr tone" );
#endif
			break ;

		default:
		case V8BIS_SIG_NONE:
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - no v8bis tone" );
#endif
			break;
	}

	dp_write_dsp_ram (0x5, loc5 ) ;
	dp_write_dsp_ram (0x6, loc6 ) ;
	dp_write_dsp_ram (0x17, 105) ;	// reg17 - tone duration=100 mS
	dp_write_dsp_ram (0x11, (word)V8bis_Sig_TxLevel) ; // tone power

	dp_modem_command ( GENERATE_TONES, 1, 0 ) ;
}

/*****************************************************************
Routine : dp_v8bis_dual_tone_xmit 
Description : xmit v8bis dual tone
******************************************************************/
void dp_v8bis_dual_tone_xmit ( byte param1 )
{
	word loc5, loc6, loc7, loc8 ;
	word V8bis_Sig_TxLevel ;

#if !defined(MODEM_Z80)
	loc5 = loc6 = loc7 = loc8 = 0 ;
#endif

	V8bis_Sig_TxLevel = G(S).ModemOptions.TxLevel;
	
	// ram05 - sin(k), ram06 - cos(k), k=2PI*f/7200, f= 1375 Hz
	// ram07 - sin(j), ram08 - cos(j), j=2PI*f/7200, f= 2002 Hz

	switch ( param1 )
	{
		case V8BIS_SIG_INIT_MRe:
		case V8BIS_SIG_INIT_CRe_LOW:
		case V8BIS_SIG_INIT_CRe_HIGH:
			loc5 = F_1375_S ;
			loc6 = F_1375_C ;
			loc7 = F_2002_S ;
			loc8 = F_2002_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - send v8bis 1375+2002 Hz init dual tones" );
#endif
			break ;

		case V8BIS_SIG_INIT_MRd:
		case V8BIS_SIG_INIT_CRd:
		case V8BIS_SIG_INIT_ESi:
			loc5 = F_1375_S ;
			loc6 = F_1375_C ;
			loc7 = F_2002_S ;
			loc8 = F_2002_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - send v8bis 1375+2002 Hz init dual tones" );
#endif
			break ;

		case V8BIS_SIG_RESP_MRd_LOW:
		case V8BIS_SIG_RESP_MRd_HIGH:
		case V8BIS_SIG_RESP_CRd:
		case V8BIS_SIG_RESP_ESr:
			loc5 = F_1529_S ;
			loc6 = F_1529_C ;
			loc7 = F_2225_S ;
			loc8 = F_2225_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - send v8bis 1529+2225 Hz resp dual tones" );
#endif
			break ;

		default:
		case V8BIS_SIG_NONE:
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - no v8bis tone" );
#endif
			break;
	}
	
	dp_write_dsp_ram (0x5, loc5 ) ;
	dp_write_dsp_ram (0x6, loc6 ) ;
	dp_write_dsp_ram (0x7, loc7 ) ;
	dp_write_dsp_ram (0x8, loc8 ) ;
	dp_write_dsp_ram (0x17, 0) ;	// reg17 - tone duration= contineous
	dp_write_dsp_ram (0x11, (word)V8bis_Sig_TxLevel ) ; // tone power
	dp_write_dsp_ram (0x12, (word)V8bis_Sig_TxLevel ) ; // tone power
	dp_modem_command ( GENERATE_TONES, 2, 0 ) ;
}

/*****************************************************************
Routine : dp_v8bis_single_tone_xmit
Description : xmit v8bis single tone
******************************************************************/
void dp_v8bis_single_tone_xmit ( byte param1 )
{
	word V8bis_Sig_TxLevel;
	word loc5, loc6 ;

#if !defined(MODEM_Z80)
	loc5 = loc6 = 0 ;
#endif

	dp_modem_idle_cmd ();
	
	V8bis_Sig_TxLevel = G(S).ModemOptions.TxLevel ;	// default  TxLevel = -9 dBm

	// ram05 - sin(k), ram06 - cos(k), k=2PI*f/7200,
   	//	f= ( V8bis_Signal_Subparameter ) Hz

	switch ( param1 )
	{
		case V8BIS_SIG_INIT_MRe:
			loc5 = F_MRe_S ;
			loc6 = F_MRe_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_init_MRe tone" );
#endif
			break ;

		case V8BIS_SIG_INIT_MRd:
			loc5 = F_MRd_S ;
			loc6 = F_MRd_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_init_MRd tone" );
#endif
			break ;

		case V8BIS_SIG_INIT_CRe_LOW:
		case V8BIS_SIG_INIT_CRe_HIGH:
			loc5 = F_CRe_S ;
			loc6 = F_CRe_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_init_CRe tone" );
#endif
			break ;

		case V8BIS_SIG_INIT_CRd:
			loc5 = F_CRd_S ;
			loc6 = F_CRd_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_init_CRd tone" );
#endif
			break ;

		case V8BIS_SIG_INIT_ESi:
			loc5 = F_ESi_S ;
			loc6 = F_ESi_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_init_ESi tone" );
#endif
			break ;
	
		case V8BIS_SIG_RESP_MRd_LOW:
		case V8BIS_SIG_RESP_MRd_HIGH:
			loc5 = F_MRd_S ;
			loc6 = F_MRd_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_resp_MRd tone" );
#endif
			break ;

		case V8BIS_SIG_RESP_CRd:
			loc5 = F_CRd_S ;
			loc6 = F_CRd_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_resp_CRd tone" );
#endif
			break ;

		case V8BIS_SIG_RESP_ESr:
			loc5 = F_ESr_S ;
			loc6 = F_ESr_C ;
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - gen. v8bis_resp_ESr tone" );
#endif
			break ;

		default:
		case V8BIS_SIG_NONE:
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - no v8bis tone" );
#endif
			break;
	}

	dp_write_dsp_ram (0x5, loc5 ) ;
	dp_write_dsp_ram (0x6, loc6 ) ;
	dp_write_dsp_ram (0x17, 105) ;	// reg17 - tone duration=100 mS
	dp_write_dsp_ram (0x11, (word)V8bis_Sig_TxLevel) ; // tone power

	dp_modem_command ( GENERATE_TONES, 1, 0 ) ;
}

#endif	//VENUS_AT_CS || CS_MODEM

#if defined(K56FLEX) && (defined(VENUS_AT_CS) || defined(CS_MODEM))
/*****************************************************************************
Routine : dp_v8bis_resp_dtones_detect_setup
*****************************************************************************/
void dp_v8bis_resp_dtones_detect_setup ( void )
{
	dp_write_dsp_ram (0x26, 40);		// set threshold to -40 dBm

#ifdef V8BIS_DEBUG	
	x_debug_msg ( "v8bis - setup to detect resp. dual tones" );
#endif

	dp_write_dsp_ram (0x1c, F_1529_C) ;  // v8bis dual tone 1529 hz
	dp_write_dsp_ram (0x1d, F_2225_C) ;  // v8bis dual tone 2225 hz

	dp_modem_command ( DETECT_TONES, 2, 0 ) ;
}

/****************************************************************
Routine : dp_v8bis_resp_dtones_detect
*****************************************************************/
byte dp_v8bis_resp_dtones_detect ( void )
{
#if defined (V92) && defined (VPCM_SERVER)
	if ((dp_read_dsp_ram(0x28) & 0x03) != 0x0)
#else
	if ((dp_read_dsp_ram(0x28) & 0x03) == 0x03)
#endif //defined (V92) && defined (VPCM_SERVER)
	{
		if ( x_elapsed_time ( G(dp_v8bis_timer1) ) > MS150 )
		{
#ifdef V8BIS_DEBUG
			x_debug_msg ( "v8bis - detected resp. dualtone" ) ;
#endif
			return ( TRUE ) ;
		}
	}
	else
	{
		G(dp_v8bis_timer1) = x_current_time() ;
	}
	return ( FALSE ) ;
}

/*******************************************************************
Routine : dp_v8bis_ans_rx_setup
Description : setup receive mode to get resp. v8bis msg
********************************************************************/
void dp_v8bis_ans_rx_setup ( void )
{
	// param1 = 0 => initiating satation,  = 1 => responding station
	// param2 = 0 => tx mode,              = 1 => rx mode

	dp_v8bis_v21_startup ( 0, 1 ) ;	// set to init. station, rx mode
}

/****************************************************************
Routine : dp_process_v8bis_std_msg
Description : process v8bis standard msg
*****************************************************************/
byte dp_process_v8bis_std_msg(byte id_std_npar1, byte no_data_remain,
						   byte id_std)
{
	byte temp ;
	byte id_std_info_field_spar1 ;
	byte temp1, temp2, temp3, temp4, i, j, k, m ;
	byte no_of_spar1, no_of_spar2 ;

	temp = id_std_npar1 ;

	// process all npar1 here
	while ( ( ( temp & 0x80 ) != 0x80 ) && ( no_data_remain ) )
	{
		temp = (*G(dpv8bis1Ptr)++) ;
		no_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("next id_std_info_field_npar1 = ");
		sendHexWord(temp);
#endif	//MODEM_Z80_V8BIS_DEBUG
	}
	if ( no_data_remain == 0 )
	{
		return ( FALSE ) ;
	}

	//clear all spar's arrays
	for (i=0; i<5; i++)
	{
		G(spar1_array)[i] = 0 ;
		G(spar2_array)[i] = 0 ;
	}
	no_of_spar1 = 0 ;
	no_of_spar2 = 0 ;

	// process id/std_info field here
	id_std_info_field_spar1 = (*G(dpv8bis1Ptr)++) ;
	no_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
	sendCrLf();
	DP_PUTS("id_std_info_field_spar1=");
	sendHexWord(id_std_info_field_spar1);
#endif
	// parse all std_info_field_spar1 here
	temp = id_std_info_field_spar1 ;
	G(spar1_array)[no_of_spar1] = temp ;
	while ( ( ( temp & 0x80 ) != 0x80 ) && ( no_data_remain ) )
	{
		temp = (*G(dpv8bis1Ptr)++) ;
		no_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("no_of_spar1 = ");
		sendHexWord(no_of_spar1);sendDumbChar(' ');
		sendCrLf();
		DP_PUTS("next id_std_info_field_spar1 = ");
		sendHexWord(temp);sendDumbChar(' ');
#endif
		no_of_spar1++ ;
		G(spar1_array)[no_of_spar1] = temp ;
	}
	if ( no_data_remain == 0 )
	{
		return ( FALSE ) ;
	}

	for (k=0; k<5; k++)
	{
		temp2 = G(spar1_array)[k] ;
		if ( ( temp2 & 0x3f ) != 0x0 )
		{
			temp1 = 1 ;
			for (i=0; i<7; i++)
			{
				if ( ( temp2 & temp1 ) == temp1 )
				{
					// extra byte ( id_std_info_field_npar2 ) is expected
#ifdef MODEM_Z80_V8BIS_DEBUG
					sendCrLf();
					switch ( k )
					{
					case 0:
					{
						switch (i)
						{
						case 0:
							if ( id_std == 1 )
							{
								DP_PUTS("std_info_field_spar1 - bit0 (data)");
							}
							else
							{
								DP_PUTS("id_field_spar1 - bit0 (network type) ");
							}
							break ;
						case 1:
							if ( id_std == 1 )
							{
								DP_PUTS("std_info_field_spar1 - bit1 (dsvd)");
							}
							else
							{
								DP_PUTS("id_field_spar1 - bit ");
								sendHexWord(i);sendDumbChar(' ');
							}
							break ;
						case 2:
							if ( id_std == 1 )
							{
								DP_PUTS("std_info_field_spar1 - bit2 (H.324 terminal)");
							}
							else
							{
								DP_PUTS("id_field_spar1 - bit ");
								sendHexWord(i);sendDumbChar(' ');
							}
							break ;
						case 3:
							if ( id_std == 1 )
							{
								DP_PUTS("std_info_field_spar1 - bit3 (V.18 text phone)");
							}
							else
							{
								DP_PUTS("id_field_spar1 - bit ");
								sendHexWord(i);sendDumbChar(' ');
							}
							break ;
						case 4:
							if ( id_std == 1 )
							{
								DP_PUTS("std_info_field_spar1 - bit4 (T.30 facsimile)");
							}
							else
							{
								DP_PUTS("id_field_spar1 - bit ");
								sendHexWord(i);sendDumbChar(' ');
							}
							break ;
						case 5:
							if ( id_std == 1 )
							{
								DP_PUTS("std_info_field_spar1 - bit5 (analogue telephony)");
							}
							else
							{
								DP_PUTS("id_field_spar1 - bit ");
								sendHexWord(i);sendDumbChar(' ');
							}
							break ;
						case 6:
							if ( id_std == 1 )
							{
								DP_PUTS("std_info_field_spar1 - bit6 (T.101 videotex terminal)");
							}
							else
							{
								DP_PUTS("id_field_spar1 - bit ");
								sendHexWord(i);sendDumbChar(' ');
							}
							break ;
						}
					}
					break;
					case 1:
					{
						switch (i)
						{
						case 0:
							if ( id_std == 1 )
							{
								DP_PUTS("std_info_field_spar1 - bit0 (H324 multilink)");
							}
							else
							{
								DP_PUTS("id_field_spar1 - bit ");
								sendHexWord(i);sendDumbChar(' ');
							}
							break ;
						case 1:
							if ( id_std == 1 )
							{
								DP_PUTS("std_info_field_spar1 - bit1 (H324 additional)");
							}
							else
							{
								DP_PUTS("id_field_spar1 - bit ");
								sendHexWord(i);sendDumbChar(' ');
							}
							break ;
						default:
							if ( id_std == 1 )
							{
								DP_PUTS("std_info_field_spar1 - bit");
								sendHexWord(i);sendDumbChar(' ');
							}
							else
							{
								DP_PUTS("id_field_spar1 - bit ");
								sendHexWord(i);sendDumbChar(' ');
							}
							break ;
						}
					}
					break ;
					default:
					{
						DP_PUTS("std_info_field_spar1 - byte");
						sendHexWord(k);sendDumbChar(' ');
					}
					break ;
					}
#endif
					temp = (*G(dpv8bis1Ptr)++) ;
					no_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
					sendCrLf();
					DP_PUTS("std_npar2 = ");
					sendHexWord(temp);sendDumbChar(' ');
#endif
					while ( ( ( temp & 0xc0 ) != 0xc0 ) && ( no_data_remain ) )
					{
						while ( ( ( ( temp & 0xc0 ) == 0x0 )
							|| ( ( temp & 0xc0 ) == 0x80 ) )
							&& ( no_data_remain ) )
						{
							// more std_info_field_npar2
							temp = (*G(dpv8bis1Ptr)++) ;
							no_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
							sendCrLf();
							DP_PUTS("next std_npar2 = ");
							sendHexWord(temp);sendDumbChar(' ');
#endif
						}
						if ( ( ( temp & 0xc0 ) == 0x40 ) && ( no_data_remain ) )
						{
							temp = (*G(dpv8bis1Ptr)++) ;
							no_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
							sendCrLf();
							DP_PUTS("id_std_field_spar2 = ");
							sendHexWord(temp);sendDumbChar(' ');
#endif
							G(spar2_array)[no_of_spar2] = temp ;
							while ( ( ( temp & 0xc0 ) == 0x0 )
								&& ( no_data_remain ) )
							{
								// more id_field_spar2
								temp = (*G(dpv8bis1Ptr)++) ;
								no_data_remain-- ;
								no_of_spar2++ ;
								G(spar2_array)[no_of_spar2] = temp ;
#ifdef MODEM_Z80_V8BIS_DEBUG
								sendCrLf();
								DP_PUTS("no_of_spar2 = ");
								sendHexWord(no_of_spar2);
								sendCrLf();
								DP_PUTS("next id_std_field_spar2 = ");
								sendHexWord(temp);
#endif		
								if ( no_of_spar2 > 5 )
								{
									return ( FALSE ) ;
								}
							}
							for ( m=0; m<5 ; m++ )
							{
								temp4 = G(spar2_array)[m] ;
#ifdef MODEM_Z80_V8BIS_DEBUG
								sendCrLf();
								DP_PUTS("recall id_std_spar2 = ");
								sendHexWord(temp4);sendDumbChar(' ');
#endif
								if ( ( temp4 & 0x3f ) != 0x0 )
								{
									temp3 = 1 ;
									for (j=0; j<6; j++)
									{
										if ( ( temp4 & temp3 ) == temp3 )
										{
#ifdef MODEM_Z80_V8BIS_DEBUG
											sendCrLf();
											DP_PUTS("id_std_field_spar2 - bit ");
											sendHexWord(j);
#endif
											temp = (*G(dpv8bis1Ptr)++ ) ;
											no_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
											sendCrLf();
											DP_PUTS("id_std_field_npar3_bit = ");
											sendHexWord(temp);
#endif
											while ( ( ( temp & 0xc0 ) != 0xc0 ) && ( no_data_remain ) )
											{
												temp = (*G(dpv8bis1Ptr)++) ;
												no_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
												sendCrLf();
												DP_PUTS("next id_std_field_npar3_bit = ");
												sendHexWord(temp);
#endif
											}
										}

										// check next field
										temp3 = (byte) (temp3 << 1);
									}
								}
							}
						}
					}
				}
				// check next field
				temp1 = (byte) (temp1 << 1);
			}
		}
		if ( no_data_remain == 0 )
		{
			return ( FALSE ) ;
		}
		if ( k == 4 )
		{
			return ( TRUE ) ;
		}
	}
	return ( FALSE ) ;
}

/****************************************************************
Routine : get_56k_v8bis_ms_msg
Description : check if got valid ms msg
*****************************************************************/
byte get_56k_v8bis_ms_msg ( void )
{
	byte temp ;
	byte msg_type ;
	byte id_field_npar1 ;
	byte std_info_field_npar1 ;
	byte length ;
	byte country_code ;
	byte provider_code_length ;
	byte manuf_id_1st_byte ;
	byte no_of_data_remain ;

	no_of_data_remain = (byte) LRF.len ;
	LRF.status = EMPTY ;
	LRF.len = 0 ;
	G(dpv8bis1Ptr) = &LRF.data[0] ;

	msg_type = (byte) ((*G(dpv8bis1Ptr)++) & 0x0f);
#ifdef MODEM_Z80_V8BIS_DEBUG
	sendCrLf();
	DP_PUTS("msg_type = "); sendHexWord(msg_type);
	sendCrLf();
	DP_PUTS("LRF.data[0] = "); sendHexWord(LRF.data[0]);
#endif

	if ( msg_type != 1 )
		return ( FALSE ) ;	// not ms msg, return FALSE

	// msg type is MS
	id_field_npar1 = (byte) ((*G(dpv8bis1Ptr)++) & 0xfd);
#ifdef MODEM_Z80_V8BIS_DEBUG
	sendCrLf();
	DP_PUTS("id_field_npar1 = "); sendHexWord(id_field_npar1);
#endif

	if ( ( id_field_npar1 & 0xc0 ) != 0xc0 )
		return ( FALSE ) ;

	// got non-standard optional
#ifdef V8BIS_DEBUG
	x_debug_msg ( "dp - 56k - got non-standard option" );
#endif

	if ( dp_process_v8bis_std_msg ( id_field_npar1, no_of_data_remain, 0 )
		 == FALSE )
	{
		return ( FALSE ) ;
	}

	// process std info field here
	std_info_field_npar1 = (*G(dpv8bis1Ptr)++) ;
	no_of_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
	sendCrLf();
	DP_PUTS("std_info_field_npar1 = "); sendHexWord(std_info_field_npar1);
#endif

	if ( dp_process_v8bis_std_msg ( std_info_field_npar1, no_of_data_remain, 1 ) == FALSE )
	{
		return ( FALSE ) ;
	}

	// process non-standard information here
		length = (*G(dpv8bis1Ptr)++) ;
		no_of_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("length = "); sendHexWord(length);
#endif
			
		country_code = (*G(dpv8bis1Ptr)++) ;
		no_of_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("country_code = "); sendHexWord(country_code);
#endif
		if ( country_code != 0xb5 )
			return ( FALSE ) ;	// incorrect country code
			
		provider_code_length = (*G(dpv8bis1Ptr)++) ;
		no_of_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("provider_code_length = ");
		sendHexWord(provider_code_length);
#endif
		if ( provider_code_length != 2 )
			return ( FALSE ) ;	// incorrect provider code
			
		manuf_id_1st_byte = (*G(dpv8bis1Ptr)++) ;
		no_of_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("manuf_id_1st_byte = ");
		sendHexWord(manuf_id_1st_byte);
#endif

		G(manuf_id_2nd_byte) = (*G(dpv8bis1Ptr)++) ;
		no_of_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("manuf_id_2nd_byte = ");
		sendHexWord(G(manuf_id_2nd_byte));
#endif
		V8BIS_PRINTF("manuf_id_2nd_byte = %x ", G(manuf_id_2nd_byte));

		if ( ( G(manuf_id_2nd_byte) != 0x94 ) && ( G(manuf_id_2nd_byte) != 0x4a ) )
		{
			// G(manuf_id_2nd_byte) == 4a : LT
			// G(manuf_id_2nd_byte) == 94 : K56flex
			return ( FALSE ) ;	// incorrect manufacture id
		}

		G(division_code) = (*G(dpv8bis1Ptr)++) ;
		no_of_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("division_code = ");
		sendHexWord(G(division_code));
		sendCrLf();
#endif

		// check for old Lucent client
		if ( G(manuf_id_2nd_byte) == 0x4a )
		{
			if ( G(division_code) != 0x01 )
			{
				// invalid Lucent division code
				return ( FALSE ) ;
			}
			else
			{
				x_debug_msg ( "dp - got old lucent client" );
				G(rx_manuf_id_2nd_byte) = 0x4a ;	// indicate it is old Lucent
			}
		}

		// check for new K56flex id client
		if ( G(manuf_id_2nd_byte) == 0x94 )
		{
			G(rx_manuf_id_2nd_byte) = 0x94 ;	// generic k56flex
			// got K56flex id
			if ( G(division_code) == 0x01 )
			{
				cs_insert_error_tag (0xd900 , 0);
				x_debug_msg ( "dp - new lucent client" );
			}
			else
			{
				cs_insert_error_tag (0xda00 , 0);
#ifdef HCF_WORKAROUND
				G(dp_v8bis_rockwell_client) = 1; 
				G(p_rock_client) = 1; 
#endif
				x_debug_msg ( "dp - rockwell client" );
			}
		}

		G(product_capabilities) = (*G(dpv8bis1Ptr)++) ;

		no_of_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("product_capabilities = ");
		sendHexWord(G(product_capabilities));
#endif
#ifdef VPCM_SERVER
		if ( G(S).ModemOptions.VpcmOption & 1 )
		{
			if ( ( G(product_capabilities) & 0x03 ) == 0x0 )
				return ( FALSE ) ;	// both v90 and K56flex capabilities bit not set
		}
		else
#endif	// VPCM_SERVER
		{
			if ( ( G(product_capabilities) & 0x01 ) != 0x01 )
				return ( FALSE ) ;	// K56flex capabilities bit not set
		}
			
		// K56flex capability bit ( bit 0 ) is set
		temp = G(product_capabilities) ;
		while ( ( ( temp & 0x80 ) == 0x0 ) && (  no_of_data_remain ) )
		{
			temp = (*G(dpv8bis1Ptr)++ ) ;
			no_of_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
			sendCrLf();
			DP_PUTS("more product_capabilities = ");
			sendHexWord(temp);
#endif
		}

		G(k56_version_octet) = (*G(dpv8bis1Ptr)++) ;
		no_of_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("k56_version_octet = ");
		sendHexWord(G(k56_version_octet));
#endif
		V8BIS_PRINTF("k56_version_octet = %x ", G(k56_version_octet) ) ;

		temp = G(k56_version_octet) ;
		while ( ( ( temp & 0x80 ) != 0x80 ) && ( no_of_data_remain ) )
		{
			temp = (*G(dpv8bis1Ptr)++) ;
			no_of_data_remain-- ;
#ifdef MODEM_Z80_V8BIS_DEBUG
			sendCrLf();
			DP_PUTS("next k56_version byte = ");
			sendHexWord(temp);
#endif
		}
		// only one byte for k56_version_octet
		G(k56_version) = (byte) (G(k56_version_octet) & 0x3f);

		if ( ( G(k56_version_octet) & 0x40 ) == 0x0 )
		{
			// remote is analog
			x_debug_msg ( "dp - 56k - got MS msg" );
			LRF.status = EMPTY ;
			LRF.len = 0 ;

			// if remote is old lucent client - then use extra bits in
			// version field only for proprietery info. in version 1.0 
			if ( ( G(manuf_id_2nd_byte) == 0x4a ) &&
				( G(division_code) == 0x01 ) &&
				( ( G(k56_version) & 0x20 ) == 0 ) )
			{
				x_debug_msg ( "v8bis - old lucent client" ) ;
			}

			// if remote is new Lucent client and manuf_id_1st_byte is non-zero
			//		- then use manuf_id_1st_byte for proprietery info.
			//      in version 1.0 
			if ( ( G(manuf_id_2nd_byte) == 0x94 ) &&
				( G(division_code) == 0x01 ) )
			{
				if ( ( G(k56_version) & 0x02 ) == 0x02 )
				{
					x_debug_msg ( "v8bis - new lucent client ver 1.1" ) ;
				}
				else
				{
					// Don't do this now since it's causing us to
					// fail in Alaw mode with clients that set the 1.0
					// plus prototype bit
					x_debug_msg ( "v8bis - new lucent client ver 1.0" ) ;
				}
			}

			return ( TRUE ) ;
		}
	return ( FALSE ) ;
}

/****************************************************************
Routine : dp_ms_msg_nak_required
Description : check if nak required to send for invalid ms msg
*****************************************************************/
byte dp_ms_msg_nak_required ( void )
{
	byte msg_type ;
	byte id_field_npar1 ;
	byte *ptr ;
	
	LRF.status = EMPTY ;
	LRF.len = 0 ;

	ptr = &LRF.data[0] ;

	msg_type = (byte) ((*ptr++) & 0x0f);

	V8BIS_PRINTF("msg_type = %x ", msg_type);
	V8BIS_PRINTF("LRF.data[0] = %x ", LRF.data[0]);

	if ( msg_type == 1 )  ;
	{
		// msg type is MS
		id_field_npar1 = (*ptr++) ;

		V8BIS_PRINTF("id_field_npar1 = %x ", id_field_npar1);

		if ( id_field_npar1 & 0x08 )
		{
			x_debug_msg ( "v8bis - NAK required" );
			return ( TRUE ) ;
		}
	}
	return ( FALSE ) ;
}

#endif	// K56FLEX && central site - VENUS_AT_CS or CS_MODEM

#if defined(VENUS_AT_CS) || defined(CS_MODEM)
#if defined (V92) && defined (VPCM_SERVER)
/****************************************************************
Routine : dp_get_v8bis_v92_qc2a_msg
Description : check if got valid ack msg
*****************************************************************/
byte dp_get_v8bis_v92_qc2a_msg ( void )
{
	byte msg_type ;
	byte parameter_field ;

	if ( LRF.len == 4 )
	{
		msg_type = (byte) (LRF.data[0] & 0x0f);

#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("msg_type = ");
		sendHexWord(msg_type);
#endif	//MODEM_Z80_V8BIS_DEBUG

		parameter_field = (byte) (LRF.data[1] & 0xff );

#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("parameter_field = ");
		sendHexWord(parameter_field);
		sendCrLf();
#endif	//MODEM_Z80_V8BIS_DEBUG

		if ( ( msg_type == 0xd ) && ( ( parameter_field & 0xd0 ) == 0x0 ) )
		{
			x_debug_msg ( "v8bis - got QC2a message" );
			LRF.status = EMPTY ;
			LRF.len = 0 ;
			G(vpcm_remote_qc_parameter) = parameter_field ;
			return ( TRUE ) ;
		}
	}
	LRF.status = EMPTY ;
	LRF.len = 0 ;
	return ( FALSE ) ;
}
#endif	//v92 || VPCM_SERVER

/****************************************************************
Routine : dp_v8bis_ans_background
Description : data call first, DCE control, answer background states.
				This state machine will initiate v8bis
				transaction #12 by default. It can switch to
				transaction #5 in the DP_V8BIS_ANS_INIT state manually
*****************************************************************/
byte dp_v8bis_ans_background ( void )
{
	word temp ;
#if defined(VENUS_AT_CS) || defined(CS_MODEM)
	word CRe_tone_time;
#endif

	switch ( G(dp_v8bis_state) )
	{
		default :
		case DP_V8BIS_ANS_INIT :
			// init. variables
			G(S).ModemOptions.Enabled56K = FALSE ;
			// clear all dsp RAM required for v8bis
			v8bis_clear_dsp_ram_from_vcid();
			G(dp_v8bis_state) = DP_V8BIS_ANS_WITH_TRANSACTION_12 ;	// ans w/ #12
			G(dp_v8bis_timer) = x_current_time () ;
#ifdef VPCM_SERVER
			if (0 == (G(S).ModemOptions.VpcmOption & 1))
			{
				G(S).ModemOptions.Enabled56K = TRUE ;
				x_debug_msg("v8bis - k56flex disabled, do V.90 (ans phase 1)");
				G(dp_v8bis_state) = DP_V8BIS_ANS_PHASE1;
			}
#endif	//VPCM_SERVER
			break ;

		case DP_V8BIS_ANS_WITH_TRANSACTION_5 :
			// ****** use transaction # 5 here ***********
			// setup to xmit dualtone
			// setup timer
			dp_v8bis_dual_tone_xmit ( V8BIS_SIG_INIT_ESi ) ;
			G(dp_v8bis_timer) = x_current_time () ;
			G(dp_v8bis_state) = DP_V8BIS_ANS_TX_ESi_DUALTONE ;
#ifdef V8BIS_DEBUG
			x_debug_msg ("v8bis - tx init. ESi dualtone " );
#endif
			break ;

		case DP_V8BIS_ANS_TX_ESi_DUALTONE :
			// if tx done, setup to xmit ESi single tone
			//			   setup timer 
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS400 )
			{
				dp_v8bis_single_tone_xmit ( V8BIS_SIG_INIT_ESi ) ;
				G(dp_v8bis_timer) = x_current_time ();
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - tx ESi tone " );
#endif
				G(dp_v8bis_state) = DP_V8BIS_ANS_TX_ESi_TONE ;
			}
			break ;

		case DP_V8BIS_ANS_TX_ESi_TONE :
			// if tx done, setup to xmit CL msg
			//			   setup timer
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS100 )
			{
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - tx preamble tone and CL" ) ;
#endif
				dp_v8bis_preamble_tone_tx_setup (0) ;
				G(dp_v8bis_state) = DP_V8BIS_ANS_TX_CL_MSG ;
			}
			break ;
		
		case DP_V8BIS_ANS_WITH_TRANSACTION_12 :
			// ****** use transaction # 12 here **********
			// setup to xmit dualtone
			// setup timer
			// need silent for at least 200ms
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS200 )
			{
#if defined(VENUS_AT_CS) || defined(CS_MODEM)
				dp_v8bis_CRe_dual_tone_xmit ( V8BIS_SIG_INIT_CRe_LOW ) ;
#else
				dp_v8bis_dual_tone_xmit ( V8BIS_SIG_INIT_CRe_LOW ) ;
#endif
				G(dp_v8bis_timer) = x_current_time () ;
				G(dp_v8bis_state) = DP_V8BIS_ANS_TX_DUALTONE ;
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - tx init. CRe dualtone " );
#endif
			}
			break ;

		case DP_V8BIS_ANS_TX_DUALTONE :
			// if tx done, setup to xmit CRe single tone
			//			   setup timer 
			if (G(S).ModemOptions.DigitalLoss56K & 1)		//a-law
				CRe_tone_time = MS400;
			else
				CRe_tone_time = MS280;

			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= CRe_tone_time )
			{
				dp_v8bis_CRe_single_tone_xmit ( V8BIS_SIG_INIT_CRe_LOW ) ;
				G(dp_v8bis_timer) = x_current_time ();
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - tx CRe tone " );
#endif
				G(dp_v8bis_state) = DP_V8BIS_ANS_TX_CRe_TONE ;
			}
			break ;

		case DP_V8BIS_ANS_TX_CRe_TONE :
			// if tx done, setup to detect CRd dualtone
			//			   setup timer
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS100 )
			{
				dp_v8bis_resp_dtones_detect_setup () ;
				G(dp_v8bis_timer) = x_current_time () ;
				G(dp_v8bis_timer1) = x_current_time () ;
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - wait for CRd tone " );
#endif
				G(dp_v8bis_state) = DP_V8BIS_ANS_DUALTONE_DET ;
#if defined (V92) && defined (VPCM_SERVER)
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - setup to receive QC2a msg" ) ;
#endif
				dp_v8bis_ans_rx_setup () ;
#endif //defined (V92) && defined (VPCM_SERVER)
			}
			break ;

		case DP_V8BIS_ANS_DUALTONE_DET :
			// wait for v8bis resp. CRd dualtone
			// if CRd tone detected within 0.6 second, look for CRd single tone
			// if timeout, go back to V34
			if ( dp_v8bis_resp_dtones_detect () == TRUE )
			{
				v8bis_single_tone_detect_setup () ;
				G(dp_v8bis_timer) = x_current_time () ;
				G(dp_v8bis_timer1) = x_current_time () ;
				G(dp_v8bis_state) = DP_V8BIS_ANS_CRd_TONE_DET ;
			}
			else
			{
#if defined (V92) && defined (VPCM_SERVER)
				// need 3 seconds timeout here according to the v92 spec.
				if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= SECOND3 )
#else
				if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS800 )
#endif //defined (V92) && defined (VPCM_SERVER)
				{
#if defined (V92) && defined (VPCM_SERVER)
					x_debug_msg ("v8bis - CRd tone/ QC2a msg timer expired" ) ;
#else
					x_debug_msg ("v8bis - CRd tone timer expired" ) ;
#endif //defined (V92) && defined (VPCM_SERVER)
					G(dp_v8bis_state) = DP_V8BIS_ANS_BACK_TO_V34 ;
				}
			}
#if defined (V92) && defined (VPCM_SERVER)
			if ( dp_read_dsp_ram ( 0x3a ) & 0x0008 )	// data mode
			{
				// download patch code
				dp_hdlc_mode_no_crc () ;
				G(dp_v8bis_state) = DP_V8BIS_V92_ANS_GET_QC2a;
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - data mode wait for QC2a msg" ) ;
#endif
			}
#endif //defined (V92) && defined (VPCM_SERVER)
			break ;

		case DP_V8BIS_ANS_CRd_TONE_DET :
			// look for v8bis resp. CRd single tone
			// if got CRd single tone, setup to tx CL msg
			temp = dp_v8bis_singletone_detect (1) ;
			if ( temp != 0 )
			{
				if ( temp == V8BIS_SIG_RESP_CRd )
				{
#ifdef V8BIS_DEBUG
					x_debug_msg ( "v8bis - detected resp. CRd tone" ) ;
#endif
					G(dp_v8bis_timer) = x_current_time () ;
					G(dp_v8bis_state) = DP_V8BIS_ANS_CL_TX_SETUP_WAIT ;
				}
			}
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS800 )
			{
				x_debug_msg ("v8bis - CRd tone timer expired" ) ;
				G(dp_v8bis_state) = DP_V8BIS_ANS_BACK_TO_V34 ;
			}
			break ;

		case DP_V8BIS_ANS_CL_TX_SETUP_WAIT :
			// need 50 ms wait due to :
			//	 we only check for 50 ms of the 100 ms single tone
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS200 )
			{
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - tx preamble tone and CL" ) ;
#endif
				dp_v8bis_preamble_tone_tx_setup (0) ;
				G(dp_v8bis_timer) = x_current_time () ;
				G(dp_v8bis_state) = DP_V8BIS_ANS_TX_CL_MSG ;
			}
			break ;
			
		case DP_V8BIS_ANS_TX_CL_MSG :
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS100 )
			{
				dp_v8bis_msg_xmit(1);	// transmit 56k CL message
				G(dp_v8bis_timer) = x_current_time () ;
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - wait for fifo empty" ) ;
#endif
				G(dp_v8bis_state) = DP_V8BIS_ANS_WAIT_FOR_TX_CL_DONE ;
			}
			break ;

		case DP_V8BIS_ANS_WAIT_FOR_TX_CL_DONE :
			// if tx done, setup to look for MS mag
			//			   setup timer for MS msg
			if ( io_dce_tx_fifo_empty () == TRUE )
			{
				G(dp_v8bis_timer) = x_current_time () ;
				dp_v8bis_ans_rx_setup () ;
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - fifo empty, wait for MS msg" ) ;
#endif
				G(dp_v8bis_state) = DP_V8BIS_ANS_WAIT_FOR_MS_DATA_MODE ;
			}
			else if ( x_elapsed_time ( G(dp_v8bis_timer) ) > SECOND2 )
			{
				x_debug_msg ( "v8bis - error xmit timeout, back to v34" ) ;
				G(dp_v8bis_state) = DP_V8BIS_ANS_BACK_TO_V34 ;
			}
			break ;

		case DP_V8BIS_ANS_WAIT_FOR_MS_DATA_MODE :
			// wait for data mode bit set before download 1 / 2 bytes patch
			// if timeout, go back to V.34
			if ( dp_read_dsp_ram ( 0x3a ) & 0x0008 )	// data mode
			{
				// download patch code
				dp_hdlc_mode_no_crc () ;
				G(dp_v8bis_state) = DP_V8BIS_ANS_GET_MS;
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - data mode wait for MS msg" ) ;
#endif
			}
			else
			{
				if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= SECOND5 )
				{
					x_debug_msg ("v8bis - MS timer expired" ) ;
					G(dp_v8bis_state) = DP_V8BIS_ANS_BACK_TO_V34 ;
				}
			}
			break ;

		case DP_V8BIS_ANS_GET_MS :
			// wait for msg
			// if timeout, go back to V.34
			// if got msg, decode the received msg
			// if msg is invalid, go back to V.34
			// if got valid MS msg, setup xmit preamle tone
			if ( dp_v8bis_get_rx_msg () == TRUE )
			{
#if defined (K56FLEX)
				// 56k is enabled
				if ( get_56k_v8bis_ms_msg () == TRUE )
				{
					G(S).ModemOptions.Enabled56K = TRUE ;
					dp_v8bis_preamble_tone_tx_setup (0) ;
					G(dp_v8bis_timer) = x_current_time () ;
#ifdef V8BIS_DEBUG
					x_debug_msg ("v8bis - rx MS, tx preamble tone" ) ;
#endif
					G(dp_v8bis_state) = DP_V8BIS_ANS_TX_PREAMBLE_TONE ;
				}
				else
				{
					if ( dp_ms_msg_nak_required () == TRUE )
					{
						dp_v8bis_preamble_tone_tx_setup (0) ;
						G(dp_v8bis_timer) = x_current_time () ;
#ifdef V8BIS_DEBUG
						x_debug_msg("tx preamble tone for NAK");
#endif
						G(dp_v8bis_state) = DP_V8BIS_ANS_TX_PREAMBLE_FOR_NAK ;
					}
				}
#endif	//K56FLEX
			}
			else
			{
				if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= SECOND5 )
				{
					x_debug_msg ("v8bis - MS timer expired" ) ;
					G(dp_v8bis_state) = DP_V8BIS_ANS_BACK_TO_V34 ;
				}
			}
			break ;

		case DP_V8BIS_ANS_TX_PREAMBLE_TONE :
			// xmit preamble tone for 100 ms
			// if tx done, setup to xmit ACK msg
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS100 )
			{
				G(dp_v8bis_timer) = x_current_time () ;
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - tx ACK msg" ) ;
#endif
				G(dp_v8bis_state) = DP_V8BIS_ANS_TX_ACK ;
			}
			break ;

		case DP_V8BIS_ANS_TX_ACK :
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS10 )
			{
				dp_v8bis_msg_xmit ( 2 ) ;	// transmit ACK message
				G(dp_v8bis_timer) = x_current_time () ;
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - wait for fifo empty" ) ;
#endif
				G(dp_v8bis_state) = DP_V8BIS_ANS_WAIT_FOR_TX_ACK_DONE ;
			}
			break ;

		case DP_V8BIS_ANS_TX_PREAMBLE_FOR_NAK :
			// xmit preamble tone for 100 ms
			// if tx done, setup to xmit NAK msg
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS100 )
			{
				G(dp_v8bis_timer) = x_current_time () ;
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - tx NAK msg" ) ;
#endif
				G(dp_v8bis_state) = DP_V8BIS_ANS_TX_NAK ;
			}
			break ;

		case DP_V8BIS_ANS_TX_NAK :
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS10 )
			{
				dp_v8bis_msg_xmit ( 3 ) ;	// transmit NAK message
				G(dp_v8bis_timer) = x_current_time () ;
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - wait for fifo empty" ) ;
#endif
				G(dp_v8bis_state) = DP_V8BIS_ANS_WAIT_FOR_TX_NAK_DONE ;
			}
			break ;

		case DP_V8BIS_ANS_WAIT_FOR_TX_ACK_DONE :
			// wait for tx done
			// if tx done, reset tx and wait for 30 ms
			if ( io_dce_tx_fifo_empty () == TRUE )
			{
#ifdef V8BIS_DEBUG
				x_debug_msg("v8bis - tx ACK done, wait 30 ms");
#endif
				G(dp_v8bis_timer) = x_current_time () ;
				dp_v8bis_ans_rx_setup () ;
				G(dp_v8bis_state) = DP_V8BIS_ANS_WAIT_30MS ;
			}
			else if ( x_elapsed_time ( G(dp_v8bis_timer) ) > SECOND2 )
			{
				x_debug_msg("v8bis - error xmit timeout, back to v34");
				G(dp_v8bis_state) = DP_V8BIS_ANS_BACK_TO_V34 ;
			}
			break ;

		case DP_V8BIS_ANS_WAIT_30MS :
			// if 30 ms timeout , go back to send answer tone
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) > MS30 )
			{
				x_debug_msg ( "v8bis - go to ans phase 1" ) ;
				G(dp_v8bis_state) = DP_V8BIS_ANS_PHASE1 ;
			}
			break ;

		case DP_V8BIS_ANS_WAIT_FOR_TX_NAK_DONE :
			// wait for tx done
			// if tx done, reset tx and wait for 30 ms
			if ( io_dce_tx_fifo_empty () == TRUE )
			{
#ifdef V8BIS_DEBUG
				x_debug_msg ( "v8bis - tx NAK done, wait 30 ms" ) ;
#endif
				G(dp_v8bis_timer) = x_current_time () ;
				dp_v8bis_ans_rx_setup () ;
				G(dp_v8bis_state) = DP_V8BIS_ANS_WAIT_NAK_30MS ;
			}
			else if ( x_elapsed_time ( G(dp_v8bis_timer) ) > SECOND2 )
			{
				x_debug_msg("v8bis - error xmit timeout, back to v34");
				G(dp_v8bis_state) = DP_V8BIS_ANS_BACK_TO_V34 ;
			}
			break ;

		case DP_V8BIS_ANS_WAIT_NAK_30MS :
			// if 30 ms timeout , go back to send answer tone
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) > MS30 )
			{
				x_debug_msg ( "v8bis - go to ANS_BACK_TO_V34" ) ;
				G(dp_v8bis_state) = DP_V8BIS_ANS_BACK_TO_V34 ;
			}
			break ;

		case DP_V8BIS_ANS_BACK_TO_V34 :
#ifdef VPCM_SERVER
#ifdef CS_V23_MODULATION
			if ((!G(cs_atb2_flag)) && (!G(cs_atb3_flag)))		
#endif // CS_V23
			{
#ifdef CS_CALLBACK
				vpcm_set_answering_mode () ;
#endif
				vpcm_startup () ;
			}
#endif	//VPCM_SERVER
			G(dp_v8bis_state) = DP_V8BIS_ANS_BACK_TO_V34_1 ;
			break ;
			
		case DP_V8BIS_ANS_BACK_TO_V34_1 :
			x_debug_msg("v8bis - back to v34/v90");
			return FALSE;
			
		case DP_V8BIS_ANS_PHASE1 :
			if ( G(S).ModemOptions.Enabled56K == TRUE )
			{
#ifdef VPCM_SERVER
				if ((((G(product_capabilities) & 0x03 ) == 0x01 )
					 && (G(k56_version_octet) != 0 ) )
					|| (G(S).ModemOptions.VpcmOption == 0 ) )
				{
       		                        // for PcTel - P bit => V90
					if ( ( ( G(k56_version_octet) & 0x20 ) == 0x20 )
						&& ( G(division_code) == 0x8e ) )
					{
						// client indicated V.90 capability
#ifdef CS_CALLBACK
						vpcm_set_answering_mode () ;
#endif
						vpcm_startup () ;
						x_debug_msg("v8bis - ANS_VPCM_PHASE1");
						G(dp_v8bis_state) = DP_V8BIS_ANS_VPCM_PHASE1 ;
					}
					else
					{
						dp_56k_init () ;
					}
				}
				else
				{
					// client indicated V.90 capability
#ifdef CS_CALLBACK
					vpcm_set_answering_mode();
#endif
					vpcm_startup();
					x_debug_msg("goto ANS_VPCM_PHASE1");
					G(dp_v8bis_state) = DP_V8BIS_ANS_VPCM_PHASE1;
				}
#endif // VPCM_SERVER
			}
			break ;
			
		case DP_V8BIS_ANS_VPCM_PHASE1 :
			break ;

		case DP_V8BIS_IDLE :
			break ;
		case DP_V8BIS_END :
			break ;

#if defined (V92) && defined (VPCM_SERVER)
		case DP_V8BIS_V92_ANS_GET_QC2a:
			// wait for QC2a msg
			// if timeout, go back to V.90
			// if got msg, decode the received msg
			// if msg is invalid, go back to V.90
			// if got valid QC2a msg, tx QcA2d msg
			if ( dp_v8bis_get_rx_msg () == TRUE )
			{
				if ( dp_get_v8bis_v92_qc2a_msg () == TRUE )
				{
#ifdef V8BIS_DEBUG
					x_debug_msg ("v8bis - rx QC2a msg" ) ;
#endif
					dp_v8bis_preamble_tone_tx_setup (0) ;
					G(dp_v8bis_state) = DP_V8BIS_V92_ANS_TX_PREAMBLE_TONE ;
				}
			}
			else
			{
				// need 3 seconds timeout here according to the v92 spec.
				//if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= SECOND5 )
				if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= SECOND3 )
				{
					x_debug_msg ("v8bis - QC2a msg timer expired, fallback" ) ;
					G(dp_v8bis_state) = DP_V8BIS_V92_ANS_FALLBACK ;
				}
			}
			break;
		case DP_V8BIS_V92_ANS_TX_PREAMBLE_TONE :
			// xmit preamble tone for 100 ms
			// if tx done, setup to xmit QCA2d msg
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS100 )
			{
				G(dp_v8bis_timer) = x_current_time () ;
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - tx QCA2d msg" ) ;
#endif
				G(dp_v8bis_state) = DP_V8BIS_V92_ANS_TX_QCA2d ;
			}
			break ;

		case DP_V8BIS_V92_ANS_TX_QCA2d :
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) >= MS100 )
			{
				dp_v8bis_msg_xmit ( 7 ) ;	// transmit QCA2d message
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - wait for fifo empty" ) ;
#endif
				G(dp_v8bis_timer) = x_current_time () ;
				G(dp_v8bis_state) = DP_V8BIS_V92_ANS_WAIT_FOR_TX_QCA2d_DONE ;
			}
			break ;

		case DP_V8BIS_V92_ANS_WAIT_FOR_TX_QCA2d_DONE :
			// wait for tx done
			// if tx done, reset tx and wait for 75 ms
			if ( io_dce_tx_fifo_empty () == TRUE )
			{
#ifdef V8BIS_DEBUG
				x_debug_msg("v8bis - tx QCA2d done");
#endif
				G(dp_v8bis_timer) = x_current_time () ;
				G(dp_v8bis_state) = DP_V8BIS_V92_ANS_QUICK_CONNECT ;
			}
			else if ( x_elapsed_time ( G(dp_v8bis_timer) ) > SECOND2 )
			{
				x_debug_msg("v8bis - error xmit timeout, fallback" );
				G(dp_v8bis_state) = DP_V8BIS_V92_ANS_FALLBACK ;
			}
			break ;

		case DP_V8BIS_V92_ANS_FALLBACK :
			//if ( x_elapsed_time ( G(dp_v8bis_timer) ) > MS30 )
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) > MS75 )
			{
				x_debug_msg("v8bis - v92 fails, fallback to v90");
				G(S).ModemOptions.Enabled56K = TRUE ;
#ifdef CS_CALLBACK
				vpcm_set_answering_mode () ;
#endif
				vpcm_startup () ;
#ifdef V8BIS_DEBUG
				x_debug_msg("v8bis - ANS_VPCM_PHASE1");
#endif
				G(dp_v8bis_state) = DP_V8BIS_ANS_VPCM_PHASE1 ;
			}
			break ;

		case DP_V8BIS_V92_ANS_QUICK_CONNECT :
			// need 75ms silent here
			//if ( x_elapsed_time ( G(dp_v8bis_timer) ) > MS30 )
			if ( x_elapsed_time ( G(dp_v8bis_timer) ) > MS75 )
			{
#ifdef V8BIS_DEBUG
				x_debug_msg("v8bis - tx QCA2d done");
#endif
				//*********** need real v92 quick connect here ********
				G(S).ModemOptions.Enabled56K = TRUE ;
#ifdef CS_CALLBACK
				vpcm_set_answering_mode () ;
#endif
				vpcm_startup () ;
				x_debug_msg("v8bis - ANS_VPCM_PHASE1");
				G(dp_v8bis_state) = DP_V8BIS_ANS_VPCM_PHASE1 ;
			}
			break ;
#endif //defined (V92) && defined (VPCM_SERVER)
	}
	return TRUE;
}
#endif // central site - VENUS_AT_CS || CS_MODEM 

#endif	//V8BIS

#if defined (VPCM_CLIENT) && defined (V92)		//pwwlkl
/****************************************************************
    *************** V92 BACKGROUND ***************
*****************************************************************/

/****************************************************************
Routine : dp_v8bis_otimer_expires()
Description : 

	For the originator, if the timer expires, timeout,
	go to the failure state, and return TRUE.

	If the timer hasn't expired, return FALSE.
*****************************************************************/
byte dp_v8bis_otimer_expires(word timeout)
{
	if (x_elapsed_time(G(dp_v8bis_timer) ) >= timeout)
	{
		G(dp_v8bis_timer) = x_current_time();
		x_debug_msg("dp_v8bis_timer_expires() - try v90.");
		// setup to do v92 quick connect here
		G(dp_v8bis_state) = DP_V8BIS_V92_ORIG_FALLBACK ;
		return TRUE;
	}
	return FALSE;
}

/****************************************************************
Routine : dp_v8bis_v21_startup_v92_rx
*****************************************************************/
void dp_v8bis_v21_startup_v92_orig_rx (void)
{
	dp_modem_idle_cmd () ;
	G(dp_dsp_data_in_progress) = FALSE ;

#ifdef V8BIS_DEBUG
	x_debug_msg ( "v8bis - v21= resp. station rx mode (2) - V21 (L)" );
#endif
	dp_hdlc_mode () ;
	G(x_line_rate) = MR_300 ;
	dp_modem_command_long ( V8BIS_V21_CMD, V8BIS_V21_ADDR_HIGH,
							V8BIS_V21_ADDR_LOW, 2,
							0 );
	LRF.status = EMPTY ;
	LRF.len = 0 ;
}
/****************************************************************
Routine : dp_get_v8bis_qca2d_msg
Description : check if got valid ack msg
*****************************************************************/
byte dp_get_v8bis_qca2d_msg ( void )
{
	byte msg_type ;
	byte parameter_field ;

	if ( LRF.len == 4 )
	{
		msg_type = (byte) (LRF.data[0] & 0x0f);

#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("msg_type = ");
		sendHexWord(msg_type);
#endif	//MODEM_Z80_V8BIS_DEBUG

		parameter_field = (byte) (LRF.data[1] & 0xff );

#ifdef MODEM_Z80_V8BIS_DEBUG
		sendCrLf();
		DP_PUTS("parameter_field = ");
		sendHexWord(parameter_field);
		sendCrLf();
#endif	//MODEM_Z80_V8BIS_DEBUG

		if ( ( msg_type == 0xd ) && ( ( parameter_field & 0xd0 ) == 0xc0 ) )
		{
			x_debug_msg ( "v8bis - got QCA2d message" );
			LRF.status = EMPTY ;
			LRF.len = 0 ;
			G(vpcm_remote_qc_parameter) = parameter_field ;
			return ( TRUE ) ;
		}
	}
	LRF.status = EMPTY ;
	LRF.len = 0 ;
	return ( FALSE ) ;
}
/****************************************************************
Routine : dp_v8bis_v92_orig_background
Description : v92 originate background states.
*****************************************************************/
byte dp_v8bis_v92_orig_background ( void )
{
	word temp ;

	switch ( G(dp_v8bis_state) )
	{
		default :
		case DP_V8BIS_V92_ORIG_INIT :
			// init variables
			G(S).ModemOptions.Enabled56K = FALSE ;
			G(dp_v8bis_state) = DP_V8BIS_V92_ORIG ;
			break ;

		case DP_V8BIS_V92_ORIG :
			// detected dualtone, setup to detect single tone 
			// setup timer
			v8bis_single_tone_detect_setup () ;
			G(dp_v8bis_timer) = x_current_time () ;
			G(dp_v8bis_timer1) = x_current_time () ;
#ifdef V8BIS_DEBUG
			x_debug_msg("v8bis - det. init. dualtone, wait for CRe tone");
#endif
			G(dp_v8bis_state) = DP_V8BIS_V92_ORIG_CRe_TONE_DET ;
			break ;

		case DP_V8BIS_V92_ORIG_CRe_TONE_DET :
			if (dp_v8bis_otimer_expires(MS600))
				break;

			// look for v8bis init. CRe tone
			// if get CRe tone, setup to tx QC2a msg, and setup timer
			temp = dp_v8bis_singletone_detect (0) ;
			if ( temp != 0 )
			{
				if ( ( temp == V8BIS_SIG_INIT_CRe_LOW ) ||
					( temp == V8BIS_SIG_INIT_CRe_HIGH ) )
				{
#ifdef V8BIS_DEBUG
					x_debug_msg ( "v8bis - detected CRe tone" ) ;
#endif
					G(dp_v8bis_timer) = x_current_time () ;
					G(dp_v8bis_state) = DP_V8BIS_V92_ORIG_TX_QC2a_SETUP ;
				}
			}
			break ;

		case DP_V8BIS_V92_ORIG_TX_QC2a_SETUP :
#ifdef V8BIS_DEBUG
			x_debug_msg ("v8bis - setup to tx QC2a msg" ) ;
#endif
			dp_v8bis_preamble_tone_tx_setup(1);
			G(dp_v8bis_timer) = x_current_time();
			G(dp_v8bis_state) = DP_V8BIS_V92_ORIG_TX_PREAMBLE_TONE;
			break ;

		case DP_V8BIS_V92_ORIG_TX_PREAMBLE_TONE :
			// xmit preamble tone for 100 ms
			// if tx done, setup to xmit QC2a msg
			if (dp_v8bis_otimer_expires(MS100))
			{
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - tx QC2a msg" ) ;
#endif
				G(dp_v8bis_state) = DP_V8BIS_V92_ORIG_TX_QC2a ;
			}
			break ;

		case DP_V8BIS_V92_ORIG_TX_QC2a :
			// tx QC2a msg
			if (dp_v8bis_otimer_expires(MS100))
			{
				dp_v8bis_msg_xmit(6);	// transmit v92 QC2a message
#ifdef V8BIS_DEBUG
				x_debug_msg ("v8bis - wait for fifo empty" ) ;
#endif
				G(dp_v8bis_state) = DP_V8BIS_V92_ORIG_WAIT_TX_FIFO_EMPTY ;
				G(dp_v8bis_timer) = x_current_time () ;
			}
			break ;

		case DP_V8BIS_V92_ORIG_WAIT_TX_FIFO_EMPTY :
			if (dp_v8bis_otimer_expires(SECOND2))
			{
#ifdef V8BIS_DEBUG
				x_debug_msg ("2 sec expired for fifo empty" ) ;
#endif
				break;
			}

			// wait for tx done
			// if tx done, wait for QCA2d msg
			if ( io_dce_tx_fifo_empty () == TRUE )
			{
#ifdef V8BIS_DEBUG
				x_debug_msg ( "v8bis - QC2a msg xmit done, setup to receive QCA2d" ) ;
#endif
				dp_v8bis_v21_startup_v92_orig_rx() ;	// set to resp. station, rx mode
				G(dp_v8bis_timer) = x_current_time () ;
				G(dp_v8bis_state) = DP_V8BIS_V92_ORIG_WAIT_FOR_QCA2d ;
			}
			break ;

		case DP_V8BIS_V92_ORIG_WAIT_FOR_QCA2d :
			// download patch code
			dp_hdlc_mode_no_crc () ;
			G(dp_v8bis_timer) = x_current_time () ;
			G(dp_v8bis_state) = DP_V8BIS_V92_ORIG_GET_QCA2d ;
#ifdef V8BIS_DEBUG
			x_debug_msg ("v8bis - data mode wait for QCA2d" ) ;
#endif
			break ;

		case DP_V8BIS_V92_ORIG_GET_QCA2d :
			// cannot be long, server will timeout for JM
			if (dp_v8bis_otimer_expires(SECOND1))
			{
				x_debug_msg ("1 sec expired for QCA2d msg, fallback" ) ;
				G(dp_v8bis_state) = DP_V8BIS_V92_ORIG_FALLBACK ;
				break;
			}

			// wait for QCA2d msg
			// if got msg, decode the received msg
			// if msg is invalid, go back to V.90
			// if got QCA2d msg, go to do V.92
			if ( dp_v8bis_get_rx_msg () == TRUE )
			{
				if ( dp_get_v8bis_qca2d_msg () == TRUE )
				{
#ifdef V8BIS_DEBUG
					x_debug_msg("v8bis - got QCA2d " ) ;
#endif
					G(dp_v8bis_state) = DP_V8BIS_V92_ORIG_QUICK_CONNECT ;
				}
				else
				{
					x_debug_msg ("v8bis - no QCA2d rec'd, fallback" ) ;
					G(dp_v8bis_state) = DP_V8BIS_V92_ORIG_FALLBACK ;
				}
			}
			break ;

		case DP_V8BIS_V92_ORIG_FALLBACK :
			x_debug_msg("V.8bis QC fails - try V.90");
			G(S).ModemOptions.Enabled56K = TRUE;
			vpcm_set_calling_mode();
			vpcm_startup();
			break ;

		case DP_V8BIS_V92_ORIG_QUICK_CONNECT :
			// V92 quick connect passes
			x_debug_msg("v8bis-V.92 after QC V.8bis"); 
			G(S).ModemOptions.Enabled56K = TRUE;
			vpcm_set_calling_mode();
			//set connection status bit - other side has V.8bis QC
			G(vpcm_connection_status) = G(vpcm_connection_status) | 0x10;

			// tell DSP, V.8bis Quick Connect done
			dp_write_dsp_ram(0x1ff2, (word) (dp_read_dsp_ram(0x1ff2) | 0x200));
			vpcm_startup();
	}
	return TRUE;
}
/****************************************************************
Routine : dp_v8bis_v92_options_check
Description : v92 originate check VpcmOption
*****************************************************************/
byte dp_v8bis_v92_options_check(void)
{
	x_debug_msg("dp_v8bis_v92_options_check()");

	// check if we want to do v92 quick connect
	if (0x14 == (G(S).ModemOptions.VpcmOption & 0x14))
	{
		// We'll do v92 quick connect here
		x_debug_msg("DP-try v92 quick connect");
		//set connection status bit
		G(vpcm_connection_status) = G(vpcm_connection_status) | 0x8;
		G(dp_state) = DP_V8BIS_V92_DCE_ORIG;
		G(dp_v8bis_state) = DP_V8BIS_V92_ORIG_INIT;
		return TRUE;
	}
	else
	{
		x_debug_msg("DP- do normal v90 connect");
		//set connection status bit
		G(vpcm_connection_status) = G(vpcm_connection_status) | 0x1;
		return FALSE;
	}
}
#endif //defined (VPCM_CLIENT)
