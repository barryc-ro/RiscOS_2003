/*name and version number:@(#)iodte1.c	1.89*/
/*date of get: 		  01/12/01 11:49:15*/
/*date of delta:	  01/11/01 13:14:20*/
/****************************************************************
File :	iodte1.c
Description :
	Contains all hardware interface routines for the dte (UART interface).

Procedures Contained :
	UART_dsr_on
	UART_dsr_off
	UART_cts_off
	UART_cts_on
	UART_cd_off
	UART_cd_on
	UART_ri_off
	UART_ri_on
	UART_dtr_off
	UART_dtr_on
	UART_dtr_blocked
	UART_start_break
	UART_stop_break
	UART_dce_break_on
	UART_data_bits
	UART_stop_bits
	UART_parity
	UART_xoff_on
	UART_xoff_off

Revision History :
	Initials	Date		Change
*****************************************************************/

#include "llglob_d.h"
#include "ioglob_d.h"
#include "iouart_d.h"
//msm// #include "z80glob.h"
//msm// #include "z80usb.h"
#include "allglobs.h"


/****************************************************************
Routine : UART_dsr_on
Description :
	turn DSR ON.
*****************************************************************/
void UART_dsr_on ( void )
{

#if !defined(CS_MODEM)
	if ( ! ( G(io_uart_status) & UART_DSR_ON ) ) // if DSR was OFF previously
	{
		G(io_uart_status) |= UART_DSR_EVENT ;
		G(io_uart_msr) |= MSR_DELTA_DSR ;
	}
	G(io_uart_status) |= UART_DSR_ON ;
	G(io_uart_msr) |= MSR_DSR_STAT ;

	z80_uart_dsr_on () ;
#endif

}

/****************************************************************
Routine : UART_dsr_off
Description :
	turn DSR OFF.
*****************************************************************/
void UART_dsr_off ( void )
{

#if !defined(CS_MODEM)
	if ( G(io_uart_status) & UART_DSR_ON ) // if DSR was ON previously
	{
		G(io_uart_status) |= UART_DSR_EVENT ;
		G(io_uart_msr) |= MSR_DELTA_DSR ;
	}
	G(io_uart_status) &= ~UART_DSR_ON ;
	G(io_uart_msr) &= ~MSR_DSR_STAT ;

	z80_uart_dsr_off () ;
#endif

}

/****************************************************************
Routine : UART_cts_off
Description :
	turn CTS OFF.
*****************************************************************/
void UART_cts_off ( void )
{
#if !defined(CS_MODEM)
	if ( G(io_uart_status) & UART_CTS_ON ) // if CTS was ON previously
	{
		G(io_uart_status) |= UART_CTS_EVENT ;
		G(io_uart_msr) |= MSR_DELTA_CTS ;
	}
	G(io_uart_status) &= ~UART_CTS_ON ;
	G(io_uart_msr) &= ~MSR_CTS_STAT ;
#endif
}

/****************************************************************
Routine : UART_cts_on
Description :
	turn CTS ON.
*****************************************************************/
void UART_cts_on ( void )
{
#if !defined(CS_MODEM)
	if ( ! ( G(io_uart_status) & UART_CTS_ON ) ) // if CTS was OFF previously
	{
		G(io_uart_status) |= UART_CTS_EVENT ;
		G(io_uart_msr) |= MSR_DELTA_CTS ;
	}
	G(io_uart_status) |= UART_CTS_ON ;
	G(io_uart_msr) |= MSR_CTS_STAT ;
#endif
}

/****************************************************************
Routine : UART_cd_off
Description :
	turn CD OFF.
*****************************************************************/
void UART_cd_off ( void )
{
#if !defined(CS_MODEM)
	if ( G(io_uart_status) & UART_CD_ON ) // if CD was ON previously
	{
		G(io_uart_status) |= UART_CD_EVENT ;
		G(io_uart_msr) |= MSR_DELTA_DCD ;
	}
	G(io_uart_status) &= ~UART_CD_ON ;
	G(io_uart_msr) &= ~MSR_DCD_STAT;

	z80_uart_cd_off () ;
#endif
}

/****************************************************************
Routine : UART_cd_on
Description :
	turn CD ON.
*****************************************************************/
void UART_cd_on ( void )
{
#if !defined(CS_MODEM)
	if ( ! ( G(io_uart_status) & UART_CD_ON ) ) // if CD was OFF previously
	{
		G(io_uart_status) |= UART_CD_EVENT ;
		G(io_uart_msr) |= MSR_DELTA_DCD ;
	}
	G(io_uart_status) |= UART_CD_ON ;
	G(io_uart_msr) |= MSR_DCD_STAT;

	z80_uart_cd_on () ;
#endif
}

/****************************************************************
Routine : UART_ri_off
Description :
	turn RING INDICATE OFF.
*****************************************************************/
void UART_ri_off ( void )
{
#if !defined(CS_MODEM)
	if ( G(io_uart_status) & UART_RING_ON )	// if RING was ON previously
	{
		G(io_uart_status) |= UART_RING_EVENT ;
		G(io_uart_msr) |= MSR_TRAIL_RING ;
	}
	G(io_uart_status) &= ~UART_RING_ON ;
	G(io_uart_msr) &= ~MSR_RI_STAT ;

	z80_uart_ri_off () ;
#endif
}

/****************************************************************
Routine : UART_ri_on
Description :
	turn RING INDICATE ON.
*****************************************************************/
void UART_ri_on ( void )
{
#if !defined(CS_MODEM)
	if ( ! (G(io_uart_status) & UART_RING_ON) )	// if RING was OFF previously
	{
		G(io_uart_status) |= UART_RING_EVENT ;
		G(io_uart_msr) |= MSR_TRAIL_RING ;
	}
	G(io_uart_status) |= UART_RING_ON ;
	G(io_uart_msr) |= MSR_RI_STAT ;

	z80_uart_ri_on () ;
#endif
}

/****************************************************************
Routine : UART_dtr_off
Description :
	dte - dtr status OFF.
*****************************************************************/
void UART_dtr_off ( void )
{
#if !defined(CS_MODEM)
	if ( G(io_uart_status) & UART_DTR_ON )
	{
		if ( ( G(x_modem_state) != MS_IDLE )
			&& ( G(x_modem_state) != MS_RING_INDICATE ) )  
		{
			switch ( G(S).ModemOptions.DTRControl )
			{
				case 1:
				if ( ( G(x_modem_mode) == MODEM_DATA ) &&
					 ( G(io_at_esc_detect) == FALSE ) )
				{
					x_debug_msg ( "IO - at escape seq - dtr commanded" ) ;
					G(io_at_esc_detect) = TRUE ;
					x_send_mail ( AT_OK, AT_TASK, 0, 0 ) ;
				}
				break;

				case 2:
				x_debug_msg ( "IO-dtr disconnect" ) ;
				// x_send_mail ( AT_IO_DISCONNECT, IO_TASK, 0, 0 ) ;
					// start timer to delay DTR action until DTE buff
					// is empty (jmg 112398)
				G(io_dtr_timer) = x_current_time ();
				break;
			}
		}

		if (3 == G(S).ModemOptions.DTRControl)
		{
			x_debug_msg("IO - dtr disconnect - resetting");
			// load factory default settings
			x_init_modem_options () ;
			// load settings if saved in eeprom
			ll_load_modem_options () ;
			x_send_mail ( AT_IO_DISCONNECT, IO_TASK, 0, 0 ) ;
		}

		G(io_uart_status) &= ~UART_DTR_ON ;
	}
#endif
}
/****************************************************************
Routine : UART_dtr_on
Description :
	dte - dtr status ON.
*****************************************************************/
void UART_dtr_on ( void )
{
#if !defined(CS_MODEM)
	G(io_uart_status) |= UART_DTR_ON ;
#endif
}
/****************************************************************
Routine : UART_dtr_blocked
Description :
	returns DTR status.  TRUE means DTR is blocking us.
*****************************************************************/
BOOL UART_dtr_blocked ( void )
{
#if defined(THUNDER)
	if ( !((z80_modem_type == EXT_INTERFACE)
			&& ((G(io_uart_status) & UART_DTR_ON)
				|| (G(S).ModemOptions.DTRControl != 2))) )

	{
		return TRUE ;
	}
#elif !defined(VENUS) || defined(EXT_MODEM)
	if ( !((G(io_uart_status) & UART_DTR_ON)
			|| (G(S).ModemOptions.DTRControl != 2)) )
	{
		return TRUE ;
	}
#endif
	return FALSE;
}

/****************************************************************
Routine : UART_start_break
Description :
	received break from dte
*****************************************************************/
void UART_start_break ( void )
{
#if !defined(CS_MODEM)
	x_debug_msg("UART_start_break") ;
	x_send_mail ( AT_IO_BREAK, IO_TASK, 0, 0 ) ;
#endif
}

/****************************************************************
Routine : UART_stop_break
Description :
	clear break received from dte
*****************************************************************/
void UART_stop_break ( void )
{
#if !defined(CS_MODEM)
	x_debug_msg("UART_stop_break") ;
	G(io_uart_status) &= ~UART_DTE_BREAK_ON ;

#if defined( CS_4 )
	z80_uart_break_off () ;
#endif
#endif
}

/****************************************************************
Routine : UART_dce_break_on
Description :
	received break from dce
*****************************************************************/
void UART_dce_break_on ( void )
{
#if !defined(CS_MODEM)
	if ( (G(S).ModemOptions.BreakControl == 0) ||
	     (G(S).ModemOptions.BreakControl == 1) )
		UART_Flush ( 1 ) ;
	G(io_uart_status) |= UART_DCE_BREAK_ON ;
	// write a null (zero) character to the dte transmit queue - to the pc
	io_put_dte_tx_char ( 0 ) ;

	z80_uart_break_on () ;
#endif
}

/****************************************************************
Routine : UART_data_bits
Description :
	set # of data bits
*****************************************************************/
void UART_data_bits ( byte data_bits )
{
	G(S).ModemOptions.DataBits = data_bits ;
}

/****************************************************************
Routine : UART_parity
Description :
	set parity bit
*****************************************************************/
void UART_parity ( byte parity )
{
	G(S).ModemOptions.Parity = parity ;
}

/****************************************************************
Routine : UART_stop_bits
Description :
	set # of stop bits
*****************************************************************/
void UART_stop_bits ( byte stop_bits )
{
	G(S).ModemOptions.StopBits = stop_bits ;
	x_send_mail ( MC_OPTION_CHANGE, IO_TASK, 0, 0 ) ;
}

/****************************************************************
Routine : UART_xoff_off
Description :
        software flow control from dte off - received xon
*****************************************************************/
void UART_xoff_off ( void )
{
#if !defined(CS_MODEM)
	G(io_uart_status) &= ~UART_XOFF_ON ;
#endif
}

/****************************************************************
Routine : UART_xoff_on
Description :
        software flow control from dte on - received xoff
*****************************************************************/
void UART_xoff_on ( void )
{
#if !defined(CS_MODEM)
	G(io_uart_status) |= UART_XOFF_ON ;
#endif
}
