/*name and version number:@(#)dpcmd1.c	1.106*/
/*date of get: 		  11/15/00 11:36:52*/
/*date of delta:	  11/15/00 11:16:23*/
/****************************************************************
File :	dpcmd1.c
Description :
	Contains all command functions related to the dsp16a data pump interface.

Procedures Contained :
	dp_modem_command
	dp_write_dsp_ram
	dp_read_dsp_ram
	dp_write_dsp_block
	dp_write_dsp_array
	dp_download_dsp
	dp_regandor
	dp_read_constellation
	dp_dsp_int_regread
	dp_dsp_int_regwrite

Revision History :
	Initials	Date		Change
	EL		11/15/95	Modified for Apollo data pump
*****************************************************************/

#include "llglob_d.h"
#include "dpglob.h"
#if defined(CS_MODEM)
#include "csglob.h"	
#endif
//msm// #include "z80glob.h"

#ifdef CS_DEBUG
 #include "dpcmd1.h"
#endif
#include "allglobs.h"

#if !defined(COMPRESS_TABLES)
/****************************************************************
Routine : dp_download_dsp
Description : download dsp code by using dsp download command
		through mailbox - 6 bytes at a time.
*****************************************************************/
void dp_download_dsp(const byte *DspFilePtr, word wSize)
{
  word t = x_current_time();//msm//
  
	byte *bPtr = (byte *) DspFilePtr ;
	word wCntr ;
	byte i, k, tmp_rd7 ;

	tmp_rd7 = G(dp_bamil_rd7) ;

	G(dp_bamil_rd7) = 0xff ;
	dp_regwrite ( 0xd8, 0xff ) ;	// clear all interrupts on camil
	dp_regwrite ( 0xd7, 0xff ) ;	// disable all interrupts on camil

	// disable parallel data mode
	dp_modem_command_long ( PDM, 0, 0, 0, 0 ) ;
	dp_write_dsp_ram ( 0x39, 0x0 ) ;		// clear fax options word

	
	while (wSize)
	{
		wCntr = ((DspFileHdr *)bPtr)->wFileSize ;
		wSize -= (wCntr+3) ;
		// copy address, length and checksum.
		dp_regwrite ( 0x30, 0x01 ) ; // for external ram download set to 1
		for (i = 0; i < 6 ; i++ )
		{	
			dp_regwrite ( (byte)(i+0x31), *bPtr++ ) ;
		}
		dp_regwrite ( 0xd8, 0x18 ) ;	// clear core read/write bank bit - CRBNKI
		dp_regwrite ( 0x37, 0x1a ); // initial program download.
		wait_for_core_read () ;

		while ( wCntr )
		{
			if ( wCntr >= 3 )
			{
				k = 6 ;
				wCntr -= 3 ;
			}
			else
			{
				k = (byte)(2*wCntr) ;
				wCntr = 0 ;
			}
		
			// copy 6 bytes of data
			for (i = 0; i < k ; i++ )
			{
				dp_regwrite ( (byte)(0x30+i), *bPtr++ ) ;
			}
			dp_regwrite ( 0xd8, 0x18 ) ; // clear core read/write bank bit - CRBNKI
			if ( wCntr )
			{
				dp_regwrite ( 0x37, (byte)(0xc0|k) ) ;
			}
			else
			{
				dp_regwrite ( 0x37, (byte)(0xc8|k) ) ;//end of section
			}
			wait_for_core_read () ;
		}
//msm//
x_debug_msg("dsp_download_thingy()=");
sendHexWord(x_elapsed_time(t));
sendCrLf();
	}

	dp_regwrite ( 0xb7, 0xff ) ;	// clear interrupt NCWTB
	dp_regwrite ( 0xd8, 0xff ) ;	// clear all interrupts on camil

	// enable the dsp interrupts
	G(dp_bamil_rd7) = tmp_rd7 ;
	dp_regwrite ( 0xd7, G(dp_bamil_rd7) ) ;

	DP_WRITE_IOC();		// set ioc back to correct value for venus
}
#endif //!COMPRESS_TABLES

/****************************************************************
Routine : wait_for_core_read()
Description :

    Wait for the DSP to read the command.

    This command silently (with a debug print)
	times out on failure.
*****************************************************************/
non_banked void wait_for_core_read(void)
{
	// one quick read since usually the
	// DSP is done before we're able to even
	// check its response.
 	if (DP_IS_CORE_RD_INT(CRBANK))
	{
		//DP_CHKDSP();
		return;
	}

	G(dp_cmd_timer) = x_current_time () ;

 	while ( !DP_IS_CORE_RD_INT( CRBANK ) &&
			(x_elapsed_time( G(dp_cmd_timer) ) < MS200) )
	{
		DP_MQX_CHKTIME( G(dp_cmd_timer) );
	}

	DP_CHKDSP();

#if defined(Z80_DEBUG_THIS_FILE) || !defined(MODEM_Z80)
	if ( x_elapsed_time ( G(dp_cmd_timer) ) >= MS200 )
	{
		x_debug_msg ( "DP - wait_for_core_read failure" ) ;

		DP_DELETE_TASK();

#if defined(WIN32)
		{
			extern byte dpFailure, winFailure;

			winFailure = dpFailure = 1;
		}
#endif
	}
#endif
}

/****************************************************************
Routine : dp_modem_command
Description : Send a command to the modem.
Parameters in : command	-	the command to be executed
		param1	-	the first parameter for the command
		param2	-	the second parameter for the command
*****************************************************************/
non_banked void dp_modem_command ( byte command, byte param1, byte param2 )
{
	if ( ( command == STARTUP ) || ( command == LL_TEST ) )
	{
		dp_startup_prime_pump();		// Get CAMIL ready for data intrpts
	}

	// clear core read/write int bank bits
	DP_CLR_CORE_INTS( CWBANK|CRBANK ) ;

	dp_regwrite ( 0x35, param2 ) ;
	dp_regwrite ( 0x36, param1 ) ;
	dp_regwrite ( 0x37, command ) ;

#if defined(CS_MODEM)
#if defined(CS_ENABLE_DEBUG_LOGGING)
	// copy the command to the debug buffer
	cs_log_dp_cmds (command);	
#endif	//CS_ENABLE_DEBUG_LOGGING
#endif

	wait_for_core_read () ;
}

/****************************************************************
Routine : dp_modem_command_long
Description : Send a command to the modem.
Parameters in : command	-	the command to be executed
		param1	-	the first parameter for the command
		param2	-	the second parameter for the command
		param3	-	the third parameter for the command
		param4	-	the fourth parameter for the command
*****************************************************************/
non_banked void dp_modem_command_long ( byte command, byte param1, byte param2,byte param3, byte param4)
{
	// clear core read/write int bank bits
	DP_CLR_CORE_INTS( CWBANK|CRBANK ) ;

	dp_regwrite ( 0x33, param4 ) ;
	dp_regwrite ( 0x34, param3 ) ;
	dp_modem_command(command, param1, param2);
}

#if !defined(CS_MODEM)
/****************************************************************
Routine : dp_apollo_command
Description : Send a command to the modem.
Parameters in : command	-	the command to be executed, register 0x37
		p1	-	writes to register 0x36
		p2	-	writes to register 0x35
		p3	-	writes to register 0x34
		p4	-	writes to register 0x33
		p5	-	writes to register 0x32
		p6	-	writes to register 0x31
		p7	-	writes to register 0x30
*****************************************************************/
non_banked void dp_apollo_command(byte command, byte p1, byte p2, byte p3,
								  byte p4, byte p5, byte p6, byte p7)
{
	DP_CLR_CORE_INTS( CWBANK|CRBANK ) ;
	dp_regwrite ( 0x30, p7 ) ;
	dp_regwrite ( 0x31, p6 ) ;
	dp_regwrite ( 0x32, p5 ) ;
	dp_modem_command_long(command, p1, p2, p3, p4);
}
#endif //CS_MODEM


/****************************************************************
Routine : dp_write_dsp_ram
Description : Write a word 'value' to DSP RAM location 'loc'
*****************************************************************/
non_banked void dp_write_dsp_ram(word loc, word value)
{
	DP_CLR_CORE_INTS( CWBANK|CRBANK ) ;
	dp_regwrite(0x32, (byte) value ) ;
	dp_regwrite(0x33, (byte) (value >> 8) ) ;
	dp_regwrite(0x34, (byte) loc ) ;
	dp_regwrite(0x35, (byte) (loc >> 8) ) ;
	dp_regwrite(0x37, 0x01 ) ;
	wait_for_core_read();
}

/****************************************************************
Routine : dp_read_dsp_ram
Description : Read from dsp ram location
*****************************************************************/
non_banked word dp_read_dsp_ram ( word loc )
{
//msm:begin//
//x_debug_msg("dp_read_dsp_ram() loc=");
//sendHexWord(loc);
////x_debug_msg(" lo=");
////sendHexWord((word)((byte)loc));
////x_debug_msg(" hi=");
////sendHexWord((word)((byte)(loc>>8)));
//msm:end//
  
	G(dp_byte_f) = 0 ;

	DP_CLR_CORE_INTS( CWBANK|CRBANK ) ;
	dp_regwrite ( 0x34, (byte) loc ) ;
	dp_regwrite ( 0x35, (byte) (loc >> 8) ) ;
	dp_regwrite ( 0x37, 0x04 ) ;
	G(dp_cmd_timer) = x_current_time () ;

	/* wait for interrupt from dsp - response code = 0x01 */
	while ( ( G(dp_byte_f) == 0 ) &&
			( x_elapsed_time (G(dp_cmd_timer)) <= MS200 ) )
	{
		DP_MQX_CHKTIME( G(dp_cmd_timer) );
		DP_CHKDSP() ;
	}

	if ( G(dp_byte_f) != 0x01 )	// if command failed
	{
#if !defined(MODEM_Z80)
		if ( x_elapsed_time (G(dp_cmd_timer)) > MS200 )
		{
			x_debug_msg("DP - Timed out in dp_read_dsp_ram()") ;
		}
#endif
#if defined(Z80_DEBUG_PRINT) || !defined(MODEM_Z80)
		x_debug_msg("dp_read_dsp_ram() failure.  addr=");
		sendHexWord(loc);
		sendCrLf();
		DP_DELETE_TASK();
#endif
#if defined(WIN32)
		{
			extern byte dpFailure, winFailure;
			winFailure = dpFailure = 1;
		}
#endif
		DP_CLR_CORE_INTS( 0xff ) ;
		G(dp_byte_e) = 0 ;
		G(dp_byte_d) = 0 ;
	}
//msm:begin//
//x_debug_msg(" returns=");
//sendHexWord(   (word) ((((word)G(dp_byte_e)) << 8 ) | G(dp_byte_d)) );
//sendCrLf();
//msm:end//	
	return (word) ((((word)G(dp_byte_e)) << 8 ) | G(dp_byte_d));
}

#if defined(KORTEX)
/****************************************************************
Routine : dp_regandor
	Modify BAMIL Register
		And with and mask then
		Or with or mask
*****************************************************************/
non_banked void dp_regandor ( byte reg, byte and_mask, byte or_mask )
{
	byte tmp ;

	tmp = dp_regread ( reg ) ;
	tmp = tmp & and_mask ;
	tmp = tmp | or_mask ;
	dp_regwrite ( reg, tmp ) ;
}
#endif // KORTEX

/****************************************************************
Routine : dp_dsp_int_regread
This command is used to read the internal dsp register
and the only parameter tells which dsp register to read
and the codes are
	0 - mwait
	1 - ioc
	2 - pioc
	3 - inc
	4 - pllc
	5 - powerc
	6 - spkr
*****************************************************************/
non_banked word	dp_dsp_int_regread ( byte reg )
{
	G(dp_byte_f) = 0 ;
	dp_regwrite(0x36,reg);
	dp_regwrite(0x37,0x30);
	G(dp_cmd_timer) = x_current_time () ;

	/* wait for interrupt from dsp - response code = 0xA */
	while ( ( G(dp_byte_f) == 0 ) &&
			( x_elapsed_time (G(dp_cmd_timer)) <= MS200 ) )
	{
		DP_MQX_CHKTIME( G(dp_cmd_timer) );
		DP_CHKDSP() ;
	}

	if ( G(dp_byte_f) != 0xa )	// if command failed
	{
		x_debug_msg ( "DP - dp_dsp_int_regread() failure" ) ;
		cs_debug_liv(DP_INTERNAL_DSPREG_READ_FAILURE);
		DP_CLR_CORE_INTS( 0xff ) ;
		DP_DELETE_TASK();
		G(dp_byte_e) = 0 ;
		G(dp_byte_d) = 0 ;
	}

	return (word) ((((word)G(dp_byte_e)) << 8 ) | G(dp_byte_d)) ;
}

/****************************************************************
Routine : dp_dsp_int_regwrite
This command is used to write the internal dsp register
and the first parameter tells which dsp register to read
and the codes are
	0 - mwait
	1 - ioc
	2 - pioc
	3 - inc
	4 - pllc
	5 - powerc
	6 - spkr
and the second parameter is value to write in the dsp register
*****************************************************************/
non_banked void dp_dsp_int_regwrite ( byte reg, word value )
{
	// clear core read/write int bank bits
	DP_CLR_CORE_INTS( CWBANK|CRBANK ) ;
	dp_regwrite ( 0x34, (byte) value ) ;
	dp_regwrite ( 0x35, (byte) (value >> 8) ) ;
	dp_regwrite(0x36,reg);
	dp_regwrite(0x37,0x31);

	wait_for_core_read();
}
