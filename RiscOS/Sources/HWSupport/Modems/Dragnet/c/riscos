/*****************************************************************************
*
* File: riscos.c
*
* Author(s):  MSM, KJB
* Project(s): Martha (ALBA2)
*
* ----------------------------------------------------------------------------
* Copyright [2000] Pace Micro Technology PLC.  All rights reserved.
*
* The copyright in this material is owned by Pace Micro Technology PLC
* ("Pace").  This material is regarded as a highly confidential trade secret
* of Pace.  It may not be reproduced, used, sold or in any other way exploited
* or transferred to any third party without the prior written permission of
* Pace.
*
* ----------------------------------------------------------------------------
* Purpose: Controllerless modem driver for Lucent Dragnet chipset
*
* ----------------------------------------------------------------------------
* History: See source control system log
*
*****************************************************************************/


/*****************************************************************************
* Include header files
*****************************************************************************/


#include "llglob_d.h"
#include "ioglob_d.h"
#include "allglobs.h"  // for modem ring buffer stuff

#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"
#include "DebugLib/DebugLib.h"

#include "riscos.h"
#include "modulehdr.h"


/*****************************************************************************
* MACROS
*****************************************************************************/


#ifdef PODULEBASED
  //Podule build specific
  #define IOC            ((volatile unsigned char *)0x03200000)
  #define IOC_IRQMSKB    ((volatile unsigned char *)IOC+40)
  #define podule_IRQ_bit (1<<5)

#else // ALBA2
  //ALBA2 build specific
  #include "global/HALEntries.h"
#endif


#define MIN( X , Y )  ( (X)<(Y) ? (X) : (Y) )

#ifndef PollPeriod
#define PollPeriod 5 /* centiseconds */
#endif


//#define RISCOS_Country           7
#define Service_PreReset         0x45
#define Service_DeviceFSStarting 0x70

#define PODULE_IRQ_NUMBER        13
#define PODULE_INTERRUPT_BASE    0x0 // offset where dsp interrupt status bit lurks
#define PODULE_INTERRUPT_MASK    0x1 // bit 1 is interrupt status
#define PODULE_GPIO_W_BASE       0x800000
#define   PODULE_GPIO_LED          (1<<7)
#define   PODULE_GPIO_DON          (1<<4)
#define   PODULE_GPIO_TRIGGER      (1<<3)
#define PODULE_MODEM_BASE        0x400000

#define ALBA2_HARDWARE_BASE      0x2c000000      // cs3
#define ALBA2_IRQ_NUMBER         33
#define ALBA2_LED_BASE           0x34000000      // cs5
#define ALBA2_SWITCH_BASE        0x30000000      // cs4
#define ALBA2_LED_CALLEVERY      (1<<6)
#define ALBA2_LED_INTERRUPT      (1<<0)
#define ALBA2_SMC_BASE        0x80080000
#define ALBA2_SMC_LOCK        (ALBA2_SMC_BASE+0x0144)
#define ALBA2_SMC_KEY         0xAA
#define ALBA2_SMCCR0          (ALBA2_SMC_BASE+0)
#define ALBA2_SMCCR1          (ALBA2_SMC_BASE+4)
#define ALBA2_SMCCR2          (ALBA2_SMC_BASE+8)
#define ALBA2_SMCCR3          (ALBA2_SMC_BASE+12)
#define ALBA2_SMCCR4          (ALBA2_SMC_BASE+16)
#define ALBA2_SMCCR5          (ALBA2_SMC_BASE+20)
#define ALBA2_SMCCR6          (ALBA2_SMC_BASE+24)
#define ALBA2_SMCCR7          (ALBA2_SMC_BASE+28)

#define SMC_WORD(AT,MW,BM,WP,WPERR,BUSER,WST2,RBLE,WST1,IDCY) ((unsigned int)( ((AT&3)<<30)| ((MW&3)<<28)| ((BM&1)<<27)| ((WP&1)<<26)| ((WPERR&1)<<25)| ((BUSER&1)<<24)| ((WST2&31)<<11)| ((RBLE&1)<<10)| ((WST1&31)<<5)| ((IDCY&15)<<0) ))

#define ALBA2_SMC_WORD_MODEM    SMC_WORD(0,2,0,0,0,0,1,1,1,0)
#define ALBA2_SMC_WORD_LED      SMC_WORD(0,2,0,0,0,0,0,1,0,0)



/*****************************************************************************
* New type definitions
*****************************************************************************/

typedef unsigned char ubyte; /* MSM */


/*****************************************************************************
* File scope Global variables
*****************************************************************************/

static void                 *private_word               = NULL;
static volatile int          poll_loop_threaded         = 0;
static volatile int          interrupt_handler_threaded = 0;
static int                   active_streams             = 0;
static volatile int          polling_semaphore          = 0;    //msm needed?
static int                   polling_period             = PollPeriod;

static unsigned char        *hardware_base_address      = NULL;
static unsigned char        *podule_base_address        = NULL;
static unsigned char         podule_gpio_state          = \
                                  ( PODULE_GPIO_TRIGGER | !PODULE_GPIO_DON | PODULE_GPIO_LED );

int RO_dcd;
int RO_cts;
int RO_ring;
int RO_dsr;
int RO_dtr;

static volatile unsigned int callbacks       = 0;
static volatile unsigned int total_irq_count = 0;
static volatile unsigned int reentrancy_count = 0;
static volatile unsigned int bytes_rx_count  = 0;
static volatile unsigned int bytes_tx_count  = 0;


//
// External data declarations
//

extern int BaseAddress;    // lucent modem hardware base
extern int BaseAddressData;
extern int BaseAddress2;



//
// External prototypes (to go to header files eventually)
//

extern void ll_periodic( void );
extern void ll_shutdown( void );
extern void consoleCharIn( char c );

extern void dsp_clear_interrupts(void);
extern void dsp_disable_interrupts(void);
extern void dp_dsp_isr ( void );

//extern void output8(int address, int value);
//extern int  input8 (int address);


//
// Local prototypes
//

static _kernel_oserror *riscos_start_polling(void *pw);
static void riscos_stop_polling(void *pw);




/*****************************************************************************
* Functions
*****************************************************************************/


#ifdef PODULEBASED // Podule based build specific stuff


  //
  // Function: find_podule_base
  //
  // Finds podule hardware base address
  //   <podulebase> : base address is written to pointer pointed to by <podulebase>
  //   <card_id> : Podule card ID to look for
  // Returns OS Error block or NULL
  //
  static void *find_podule_base( unsigned char **podulebase, int card_id )
  {
    _kernel_oserror *e = NULL;
    int slot,id;

  
    *podulebase = NULL;
    for ( slot=0 ; slot<=7 ; slot++ )
    {
      e=_swix( Podule_ReadID, _IN(3)|_OUT(0), slot, &id );
      if ( !e && (( id & 0x78 ) == ( card_id<<3 )) )
      {
        e=_swix( Podule_ReadInfo, _INR(0,3), (1<<9), podulebase, sizeof(*podulebase),slot );
        break;
      }
    }
    return e;
  }

  //
  // Function: led_set
  //
  // Dummy function in podule build
  //
  void led_set( unsigned char bitmask )
  {
    bitmask = bitmask;
  }

  
  //
  // Function: led_clear
  //
  // Dummy function in podule build
  //
  void led_clear( unsigned char bitmask )
  {
    bitmask = bitmask;
  }

  
#else // ALBA2 based hardware build stuff


  //
  // Function: find_alba2_base
  //
  // Finds alba2 hardware base address (allocated a permanent logical address) 
  //   <podulebase> : base address is written to pointer pointed to by <podulebase>
  // Returns OS Error block or NULL
  //
  static void *find_alba2_base( unsigned char **hardwarebase )
  {
    _kernel_oserror *e = NULL;


    *hardwarebase = NULL;

    // OS_Memory 13 to map our modem into permanent logical space
    e=_swix( OS_Memory, _INR(0,2)|_OUT(3), 13|(0<<8) , ALBA2_HARDWARE_BASE , 4*4, hardwarebase );
    if (e) *hardwarebase = NULL;

    return e;
  }

  static unsigned char alba2_led_state = 0;

  //
  // Function: alba2_led_set
  //
  // Sets alba2 hardware led control byte to <value>
  //
  void alba2_led_set(unsigned char value)
  {
    static void *ledaddress = NULL;
    _kernel_oserror *e;

    if (!ledaddress)
    {
    // OS_Memory 13 to map our modem into permanent logical space
      e=_swix( OS_Memory, _INR(0,2)|_OUT(3), 13|(0<<8) , ALBA2_LED_BASE , 4, &ledaddress );
      if (e)
        ledaddress = NULL;
    }
    if( ledaddress )
      *(unsigned char *)ledaddress = value;
  }


  //
  // Function: led_set
  //
  // Set alba2 leds on according to bitmask
  //
  void led_set( unsigned char bitmask )
  {
    alba2_led_state |= bitmask;
    alba2_led_set(alba2_led_state);
  }

  
  //
  // Function: led_clear
  //
  // Clear alba2 leds on according to bitmask
  //
  void led_clear( unsigned char bitmask )
  {
    alba2_led_state &= ~bitmask;
    alba2_led_set(alba2_led_state);
  }


  //
  // Function: hardware_physical_write_word
  //
  // Write <value> to physical location <address>
  // Returns OS error block pointer or NULL
  //
  _kernel_oserror *hardware_physical_write_word(void *address, unsigned int value)
  {
    volatile void *logicaladdr = NULL;
    void *originaladdr = NULL;
    _kernel_oserror *e = NULL;
  

    e=_swix( OS_Memory, _INR(0,1)|_OUTR(2,3), 14|(0<<8) , address , &logicaladdr , &originaladdr);

    if (!e)
    {
      *(volatile unsigned int*)logicaladdr = value;  
      e=_swix( OS_Memory, _INR(0,1), 15 , originaladdr );
    }

    return e;
  }


  //
  // Function: alba2_delay
  //
  // Do nothing for <delay> centiseconds
  // Returns OS error block or NULL
  //
  _kernel_oserror *alba2_delay(int delay)
  {
    _kernel_oserror *e;
    int now,then;
    
    e = _swix(OS_ReadMonotonicTime,_OUT(0),&now);
    if (!e)
    {
      then = now+delay;
      do
      {
        e = _swix(OS_ReadMonotonicTime,_OUT(0),&now);
      }
      while ( !e && now<then );
    }
    return e;
  }


  //
  // Function: alba2_set_speed
  //
  // Set ALBA2 hardware access speeds by tweaking static memory control register
  // Returns OS error block or NULL
  //
  _kernel_oserror *alba2_set_speed(void)
  {
    _kernel_oserror *e = NULL;
  
  _kernel_irqs_off();
  
    if (!e) e=hardware_physical_write_word( (void*)ALBA2_SMC_LOCK, ALBA2_SMC_KEY ); //unlock regs
    if (!e) e=hardware_physical_write_word( (void*)ALBA2_SMCCR5, ALBA2_SMC_WORD_LED); // set led speed

    if (!e) e=hardware_physical_write_word( (void*)ALBA2_SMC_LOCK, ALBA2_SMC_KEY ); //unlock regs
    if (!e) e=hardware_physical_write_word( (void*)ALBA2_SMCCR3, ALBA2_SMC_WORD_MODEM ); // set modem speed

  _kernel_irqs_on();

    return e;  
  }


  //
  // Function: alba2_test
  //
  // Quick test of alba 2 hardware; currently just flashes the LED's a bit
  // Returns OS error block or NULL
  //
  _kernel_oserror *alba2_test(void)
  {
    _kernel_oserror *e;
    int i;
  
    for( i=1; !e && i<129 ; i=i<<1 )
    {
      if (!e) e=hardware_physical_write_word( (void*)ALBA2_LED_BASE, i);
      if (!e) e=alba2_delay(8);
    }
    if (!e) e=hardware_physical_write_word( (void*)ALBA2_LED_BASE, 0xff);
    if (!e) e=alba2_delay(8);
    if (!e) e=hardware_physical_write_word( (void*)ALBA2_LED_BASE, 0);

    return e;
  }


#endif // Podule or alba2 hardware based build specific stuff



//
// Function: podule_led_off
//
// Turn podule led off
//
void podule_led_off(void)
{
//led_clear(1<<2);
  if (podule_base_address)
  {
    podule_gpio_state|=PODULE_GPIO_LED;
//  output8( (int)podule_base_address+PODULE_GPIO_W_BASE, podule_gpio_state );
    *(unsigned char *)(podule_base_address+PODULE_GPIO_W_BASE) = podule_gpio_state;
  }
}


//
// Function: podule_led_on
//
// Turn podule led on
//
void podule_led_on(void)
{
//led_set(1<<2);
  if (podule_base_address)
  {
    podule_gpio_state&=(~PODULE_GPIO_LED);
//    output8( (int)podule_base_address+PODULE_GPIO_W_BASE, podule_gpio_state );
    *(unsigned char *)(podule_base_address+PODULE_GPIO_W_BASE) = podule_gpio_state;
  }
}



//////////////////////////////////
// Floating point context stuff //
//////////////////////////////////

static void *fp_context_block = NULL;
static void *fp_context_previous = NULL;

//
// Function: fp_context_begin
//
// Begin our FP context (having first allocated and initialised it, if required)
//
// Context system is reset if an error occurs, the subsequent context start call
// will reallocate and initialise a new block.  This system will survive the 
// FPEmulator module being replaced whilst this module is active.
//
void fp_context_begin(void)
{
  if (!fp_context_block)
  {
    int context_length = 0;
    
    if ( _swix( FPEmulator_ContextLength, _OUT(0), &context_length ) == NULL )
    {
      if ( (fp_context_block = malloc( context_length ) ) != NULL )
      {
        _swix( FPEmulator_InitContext, _IN(0), fp_context_block );
        dprintf(("","Allocated and initialised %i bytes for FP context at %p\n",context_length,fp_context_block));
      }
    }
  }
  if( fp_context_block )
  {
    if ( _swix(FPEmulator_ChangeContext,_IN(0)|_OUT(0), fp_context_block,&fp_context_previous)!=NULL )
    {
      free(fp_context_block);
      fp_context_block = NULL;
      dprintf(("","FP switch error: resetting context system\n"));
    }
  }
}


//
// Function: fp_context_end
//
// End's our FP context.  
// 
// If an error occurs then reset the context system to allow subsequent recovery by
// the context start routine.
//
void fp_context_end(void)
{
  if ( fp_context_block && (_swix(FPEmulator_ChangeContext,_IN(0),fp_context_previous)!=NULL) )
  {
    free(fp_context_block);
    fp_context_block = NULL;
    dprintf(("","FP context error: resetting\n"));
  }
}

/////////////////////////////
// End of FP context stuff //
/////////////////////////////




//
// Function: bufferman_used_space
//
// Returns used space in given buffer
//
int bufferman_used_space( int buffer_id )
{
  _kernel_swi_regs r;

  r.r[0] = BM_UsedSpace;
  r.r[1] = buffer_id;
  CallBufMan(&r);
  return r.r[2];
}


//
// Function: bufferman_free_space
//
// Returns free space in given buffer
//
int bufferman_free_space( int buffer_id )
{
  _kernel_swi_regs r;

  r.r[0] = BM_FreeSpace;
  r.r[1] = buffer_id;
  CallBufMan(&r);
  return r.r[2];
}


//
// Function: bufferman_remove_block
//
// Move at most <dest_size> characters from buffer <buffer_id> to <dest>
// Returns number of characters moved (0 if none moved e.g. buffer empty)
//
int bufferman_remove_block( int buffer_id, char *dest, int dest_size )
{
  _kernel_swi_regs r;
  int chars_in_buffer = bufferman_used_space(buffer_id);
  int chars_to_move   = MIN( chars_in_buffer , dest_size );

   if( chars_to_move )      // something to get from buffer
   {
     r.r[0] = BM_RemoveBlock;
     r.r[1] = buffer_id;
     r.r[3] = chars_to_move;
     r.r[2] = (int)dest;
     CallBufMan(&r);
   }
   return chars_to_move;
}


//
// Function: bufferman_insert_block
//
// Copy at most <source_size> characters from <source> into buffer <buffer_id>
// Returns number of characters copied (0 if none copied e.g. buffer full)
//
int bufferman_insert_block( int buffer_id, char *source, int source_size )
{
  _kernel_swi_regs r;
  int chars_free_in_buffer = bufferman_free_space(buffer_id);
  int chars_to_move   = MIN( chars_free_in_buffer , source_size );

   if( chars_to_move )      // something to put into buffer
   {
     r.r[0] = BM_InsertBlock;
     r.r[1] = buffer_id;
     r.r[3] = chars_to_move;
     r.r[2] = (int)source;
     CallBufMan(&r);
   }
   return chars_to_move;
}


//
// Function: modem_transmit_buffer_write
//
// Checks for data in softmodem output stream and transfers as much of it as possible
//  to the modems io_dte_rx ring buffer.
// Returns number of bytes left to write in output stream.
//
int modem_transmit_buffer_write(void)
{
    int chars_in_buffer = 0;
    static volatile writing = 0;

  
    if (!writing && active_streams && OutputStream.devicefs_stream)
    { // consume characters
      writing = 1;
        if( (chars_in_buffer=bufferman_used_space(OutputStream.buffer_privid)) > 0 )
        {
            char *block_1, *block_2;
            int  len_1, len_2, count;
              
            if ( io_dte_rx_wptr >= io_dte_rx_rptr )
            {
                block_1 = (char*)io_dte_rx_wptr;
                len_1   = io_dte_rx_eptr - io_dte_rx_wptr;
                block_2 = (char*)io_dte_rx_sptr;
                len_2   = io_dte_rx_rptr - io_dte_rx_sptr;
            }
            else
            {
                block_1 = (char*)io_dte_rx_wptr;
                len_1   = io_dte_rx_rptr - io_dte_rx_wptr;
                block_2 = NULL;
                len_2   = 0;
            }

            if (block_1 && len_1 && (count=MIN( len_1, chars_in_buffer ))!=0 )
            {
                bufferman_remove_block(OutputStream.buffer_privid,block_1,count);
                chars_in_buffer -= count;
                bytes_tx_count  += count;
                io_dte_rx_wptr   = (byte*) block_1 + count;
            }
            if (block_2 && len_2 && (count=MIN( len_2, chars_in_buffer ))!=0 )
            {
                bufferman_remove_block(OutputStream.buffer_privid,block_2,count);
                chars_in_buffer -= count;
                bytes_tx_count  += count;
                io_dte_rx_wptr   = (byte*) block_2 + count;
            }
        } 
      writing = 0;
    }
    return chars_in_buffer;
}


//
// Function: modem_receive_buffer_read
//
// Checks for data in the modems io_dte_tx buffer and transfers as much as possible
//  to the softmodem input stream.
//
void modem_receive_buffer_read(void)        
{
  int chars_free_in_buffer = 0;
  static volatile int reading = 0;
  
  if (!reading && active_streams && InputStream.devicefs_stream)
    { // produce characters
      reading = 1;
        if( (chars_free_in_buffer=bufferman_free_space(InputStream.buffer_privid)) > 0 )
        {
            char *block_1, *block_2;
            int  len_1, len_2, count;
          
            if ( io_dte_tx_wptr >= io_dte_tx_rptr )
            {
                block_1 = (char*)io_dte_tx_rptr;
                len_1   = io_dte_tx_wptr - io_dte_tx_rptr;
                block_2 = NULL;
                len_2   = 0;
            }
            else
            {
                block_1 = (char*)io_dte_tx_rptr;
                len_1   = io_dte_tx_eptr - io_dte_tx_rptr;
                block_2 = (char*)io_dte_tx_sptr;
                len_2   = io_dte_tx_wptr - io_dte_tx_sptr;
            }
            if (block_1 && len_1 && ( count=MIN( len_1 , chars_free_in_buffer ) )!=0 )
            {
                bufferman_insert_block(InputStream.buffer_privid,block_1,count);
                chars_free_in_buffer -= count;
                bytes_rx_count       += count;
                io_dte_tx_rptr        = (byte*) block_1 + count;
            }
            if (block_2 && len_2 && ( count=MIN( len_2 , chars_free_in_buffer ) )!=0 )
            {
                bufferman_insert_block(InputStream.buffer_privid,block_2,count);
                chars_free_in_buffer -= count;
                bytes_rx_count       += count;
                io_dte_tx_rptr        = (byte*) block_2 + count;
            }
        }
      reading = 0;
    }
}



//
// Function: init_ports
//
// Initialise control line values for virtual serial port
//
void init_ports(void)
{
  RO_dtr = RO_cts = 1;
  RO_dcd = RO_ring = 0;
}


//
// Function: module_initialise
//
// Module initialisation entrypoint handler
//
_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base, void *pw)
{
    _kernel_oserror *e;
    _kernel_swi_regs r;


    private_word = pw;

    /* set up debugging */
    debug_initialise (Module_Title, "", "");
#ifdef PODULEBASED
    debug_set_device(DEBUGIT_OUTPUT);
#else
    debug_set_device(PRINTF_OUTPUT);
#endif
    debug_set_unbuffered_files (TRUE);
    dprintf (("Module", "Starting Module\n"));

#ifdef PODULEBASED

    // discover hardware address and init pointers with it
    e=find_podule_base( &hardware_base_address, 0xf );
    if (e) return e;

    BaseAddress     = (int)hardware_base_address + PODULE_MODEM_BASE + 0;
    BaseAddressData = (int)hardware_base_address + PODULE_MODEM_BASE + 4;
    BaseAddress2    = (int)hardware_base_address + PODULE_MODEM_BASE + 8;

    podule_base_address = hardware_base_address;
    podule_led_off(); // proves we found the right address

#else // ALBA2

    // discover hardware address and init pointers with it
    e=find_alba2_base(&hardware_base_address);
    if (e) return e;

    BaseAddress     = (int)hardware_base_address + 0;
    BaseAddressData = (int)hardware_base_address + 4;
    BaseAddress2    = (int)hardware_base_address + 8;

    led_clear(0xff);

#endif

    /* _kernel_swi, because _swix won't fill in R2 on exit if an error is returned */
    r.r[0] = (int) "CtrlsModem$Path";
    r.r[2] = 1U<<31;
    r.r[3] = 0;
    _kernel_swi(OS_ReadVarVal, &r, &r);
    if (r.r[2] == 0)
    {
        r.r[0] = (int) "CtrlsModem$Path";
        r.r[1] = (int) "Resources:$.Resources.CtrlsModem.";
        r.r[2] = strlen((char *) r.r[1]);
        r.r[3] = 0;
        r.r[4] = 0;
        e = _kernel_swi(OS_SetVarVal, &r, &r);
        if (e) return e;
    }

    e = register_with_devicefs();
    if (e) return e;

//printf("after devicefs stuff\n");

//    dsp_disable_interrupts();


#ifdef PODULEBASED

  #ifndef DSP_POLLED_MODE
  
    e = _swix(OS_ClaimDeviceVector, _INR(0,4), PODULE_IRQ_NUMBER, interrupt_veneer, pw, \
               podule_base_address+PODULE_INTERRUPT_BASE, PODULE_INTERRUPT_MASK);

    *IOC_IRQMSKB |= podule_IRQ_bit;    //enable podule bus irq
  #endif
    
#else // ALBA2

    e = alba2_set_speed();
    if (!e) e=alba2_test();

  #ifndef DSP_POLLED_MODE

    if (!e) e=_swix(OS_ClaimDeviceVector, _INR(0,4), ALBA2_IRQ_NUMBER, interrupt_veneer, pw, 0, 0 );
    if (!e) e=_swix(OS_Hardware, _IN(0)|_INR(8,9) , ALBA2_IRQ_NUMBER, 0, EntryNo_HAL_IRQEnable );   

  #endif

#endif

  if (e)
    deregister_from_devicefs();


    return e;
}


//
// Function: module_finalise
//
// Module finalisation entrypoint handler
//
_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{


#ifdef PODULEBASED

  #ifndef DSP_POLLED_MODE

    _swix(OS_ReleaseDeviceVector, _INR(0,4), PODULE_IRQ_NUMBER, interrupt_veneer, pw, \
            podule_base_address+PODULE_INTERRUPT_BASE, PODULE_INTERRUPT_MASK);
  #endif

#else //ALBA2

  #ifndef DSP_POLLED_MODE

    _swix(OS_ReleaseDeviceVector, _INR(0,4), ALBA2_IRQ_NUMBER, interrupt_veneer, pw, 0, 0 );

  #endif

#endif
  

    if(polling_semaphore)
    { 
      polling_semaphore = 1;
      riscos_stop_polling(pw);
    }

    deregister_from_devicefs();

    ll_shutdown();

    return NULL;
}


void module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
    switch (service_number)
    {
      case Service_PreReset:
        if (active_streams)
        {
//            Remove_Int();
            riscos_stop_polling(pw);
        }
        break;
      case Service_DeviceFSStarting:
        register_with_devicefs();
        break;
    }
}



//
// Function: modem_send_string
//
// Send given string to modem's input buffer
//
int modem_send_string( char *string )
{
  char *str = string;

  for ( ; *str ; str++)
      consoleCharIn(*str);
  return 1;
}

extern void timing_stats(void);


//
// Function: module_command
//
// Module star command entrypoint handler
//
_kernel_oserror *module_command(const char *arg_string, int argc, int cmd_no, void *pw)
{
  switch (cmd_no)
    {
    case CMD_ModemStats:
      
      printf("Hardware\n--------\n");
#ifdef PODULEBASED
      printf("Podule based build\n");
#else // ALBA2
      printf("** ALBA2 IAC based build **\n");
#endif
      printf("Hardware base    = %p\n",hardware_base_address);

      printf("\nModemStats\n----------\n");
      printf("callbacks        = %i\n",callbacks);
      printf("total_irq_count  = %i\n",total_irq_count);
      printf("reentrancy_count = %i\n",reentrancy_count);
      printf("bytes_tx_count   = %i\n",bytes_tx_count);
      printf("bytes_rx_count   = %i\n",bytes_rx_count);
      printf("polling period   = %i centiseconds\n",polling_period);
      printf("\n");

//      timing_stats();
//      printf("\n");

#ifdef DSP_POLLED_MODE
       printf("Polled DSP mode\n");
#else
       printf("Interrupt driven DSP mode\n");
#endif
#ifdef COMPRESS_TABLES
       printf("DSP code tables are compressed\n");
#else
       printf("DSP code tables are not compressed\n");
#endif
#ifdef V34ONLY
       printf("56K rates are not supported\n");
#else
       printf("56K rates are supported\n");
#endif
       printf("\n");

       printf("Control line status: ");
       printf("%s ",RO_dcd?"DCD":"dcd");
       printf("%s ",RO_cts?"CTS":"cts");
       printf("%s ",RO_dsr?"DSR":"dsr");
       printf("%s ",RO_ring?"RING":"ring");
       printf("\n\n");

//printf("IO_DTE_RX_BUFF_SIZE = %i\n",IO_DTE_RX_BUFF_SIZE);
//printf("IO_DTE_TX_BUFF_SIZE = %i\n",IO_DTE_TX_BUFF_SIZE);

       break;

    case CMD_ModemInit:
      {      
        int x = 5;    /* poll x times to allow state machine to process startup */

        while (x--) 
        {
          word t;
          
          ll_periodic();
          t = x_current_time();
          while ( x_elapsed_time( t ) < MS200 )
          { ; }
        }
      }      
      break;

    case CMD_ModemPollPeriod:
      {
        int i = 0;
        
        i = atoi (arg_string);
        
        if( i<2 || i>20 )
        {
          printf("Pollperiod should be in the range 2 through 20 inclusive\n");
          break;
        }
        
dprintf(("","pollperiod=%i\n",i));

        polling_period = i;

        //
        // reset polling callback using new poll period
        //
        if (polling_semaphore > 0)
        {
           i = polling_semaphore;
           polling_semaphore = 1;
           riscos_stop_polling(pw);
           riscos_start_polling(pw);
           polling_semaphore = i;
         }

      }
      break;

    case CMD_ModemStart:
      if (!polling_semaphore)
        riscos_start_polling(pw);
      break;
      
    case CMD_ModemStop:
      if (polling_semaphore)
        riscos_stop_polling(pw);
      break;
      
    case CMD_ModemSend:
          {
            static char buffer[4096+1] = "";
            char *cpin = (char*)arg_string;
            char *cpout = buffer;

            while ( *cpin && *cpin!='\n' && *cpin!=' ' && *cpin!='\r' ) 
            {
              *cpout++ = *cpin++; 
            }
            *cpout=0;

            modem_send_string((char*)buffer);
            modem_send_string("\r");
          }
      break;
      
    case CMD_ModemLEDOn:
      podule_led_on();
      break;

    case CMD_ModemLEDOff:
      podule_led_off();
      break;

    default:
      break;
    }
    return NULL;
}


////////////////////////////////////////////////////////////////////////////////////////////
/*****************/
/* DEVICEFS BITS */
/*****************/

#define ControlLine_DTR     (1u<<0)
#define ControlLine_RTS     (1u<<1)   /* Not implemented - read as 1 */
#define ControlLine_CTS     (1u<<16)  /* Not implemented - read as 1 */
#define ControlLine_DSR     (1u<<17)
#define ControlLine_RI      (1u<<18)
#define ControlLine_DCD     (1u<<19)
#define ControlLine_FifosOn (1u<<20)  /* Not implemented - read as 1 */

#define BM_InsertByte      0
#define BM_InsertBlock     1
#define BM_RemoveByte      2
#define BM_RemoveBlock     3
#define BM_ExamineByte     4
#define BM_ExamineBlock    5
#define BM_UsedSpace       6
#define BM_FreeSpace       7
#define BM_PurgeBuffer     8
#define BM_NextFilledBlock 9

#define TickerV 0x1C


typedef struct ioctl_t
{
    unsigned int reason   : 16;
    unsigned int group    : 8;
    unsigned int          : 6;
    unsigned int read     : 1;
    unsigned int write    : 1;
    unsigned int data;
} ioctl_t;

/*
 * The structure describing our special field
 */
typedef struct sfblock
{
    unsigned int size;
    unsigned int thresh;
} sfblock;

/*
 * Parameters for device_create_[tx|rx]_buffer
 */
typedef struct bufparams
{
    Stream *stream;
    int flags;
    int size;
    int handle;
    int threshold;
} bufparams;

extern void devicefs_entry(void);
extern void tickerv_veneer(void);
extern void tickerv_veneer2(void);
extern void callevery_veneer(void);
extern void maincallback_veneer(void);





static int device_handle;
Stream InputStream;  /* Stream state information */
Stream OutputStream; /* Stream state information */
void (*BuffManService)(void);
void *BuffManWS;
static volatile int devicefs_handler_threaded;

//ubyte sys_intr_disabled = TRUE;



static _kernel_oserror *device_initialise(int stream, int flags, int fileswitch_handle, sfblock *specialfield, int *ourstream);
static _kernel_oserror *device_finalise(Stream *stream, void *pw);
static _kernel_oserror *device_wakeupfortx(Stream *stream, void *pw);
static _kernel_oserror *device_create_tx_buffer(bufparams *params);
static _kernel_oserror *device_create_rx_buffer(bufparams *params);
static _kernel_oserror *device_halt(Stream *stream);
static _kernel_oserror *device_resume(Stream *stream);
static _kernel_oserror *device_stream_created(Stream *stream, int buffer, void *pw);
static _kernel_oserror *device_ioctl(Stream *stream, ioctl_t *param);
static _kernel_oserror *ioctl_control_lines(ioctl_t *param);
static _kernel_oserror *ioctl_buffer_size(Stream *stream, ioctl_t *param);
static _kernel_oserror *ioctl_buffer_threshold(Stream *stream, ioctl_t *param);
static _kernel_oserror *riscos_start_polling(void *pw);
#if PollPeriod == 1
// int callevery_handler(_kernel_swi_regs *r, void *pw);
 _kernel_oserror *callevery_handler(_kernel_swi_regs *r, void *pw);
#else
 _kernel_oserror *callevery_handler(_kernel_swi_regs *r, void *pw);
#endif





_kernel_oserror *register_with_devicefs(void)
{
    typedef struct device
    {
        ptrdiff_t name;
        int flags;
        int rxflags, rxsize;
        int txflags, txsize;
        int reserved;
    } device;
    static struct
    {
        device device1;
        int end;
    }
    device_list =
    {
        {
            0,
            1,              /* Buffered, no "SoftModem$Path" */
            8, 256,         /* Enable upcalls */
            8, 256,         /* Enable upcalls */
            0
        },
        0
    };

    /* This is an offset, not an address (yuck)! */
    device_list.device1.name = "SoftModem" - (char *) &device_list.device1;

    return _swix(DeviceFS_Register, _INR(0,7)|_OUT(0),
                                    2|16, /* Full duplex character device, buffer thresholding */
                                    &device_list,
                                    devicefs_entry,
                                    0,
                                    private_word,
                                    "size/Nthresh/N",
                                    1, /* 1 input stream */
                                    1, /* 1 output stream */
                                    &device_handle);
}


_kernel_oserror *deregister_from_devicefs(void)
{
    return _swix(DeviceFS_Deregister, _IN(0), device_handle);
}


_kernel_oserror *devicefs_handler(_kernel_swi_regs *r, void *pw)
{
#ifdef TMLDEBUG
    Printf("\021\006devicefs_handler: r0=%d\021\007\n", r->r[0]);
#endif

    switch (r->r[0])
    {
      case 0:
        return device_initialise(r->r[2], r->r[3], r->r[4], (sfblock *)r->r[6], &r->r[2]);
      case 1:
        return device_finalise((Stream *)r->r[2], pw);
      case 2:
        return device_wakeupfortx((Stream *)r->r[2], pw);
      case 3: /* Wake up for RX */
      case 4: /* Sleep RX */
      case 5: /* EnumDir */
        return NULL;
      case 6:
        return device_create_tx_buffer((bufparams *)&r->r[2]);
      case 7:
        return device_create_rx_buffer((bufparams *)&r->r[2]);
      case 8:
        return device_halt((Stream *)r->r[2]);
      case 9:
        return device_resume((Stream *)r->r[2]);
      case 10:
        return NULL;
      case 11:
        return device_stream_created((Stream *)r->r[2], r->r[3], pw);
      case 14:
        return device_ioctl((Stream *)r->r[2], (ioctl_t *)r->r[3]);
      default:
        return (_kernel_oserror *) "\0\0\0\0Bad devicefs call"; /* Fix this */
    }
}

/*
 * DeviceDriver_Entry 0 : Initialise
 *
 * In: stream       = DeviceFS stream handle
 *     flags        = flags for opening the stream (bit 0 -> TX/~RX)
 *     specialfield = pointer to special field control block (PRM 2-422)
 *
 * Out: ourstream = our internal stream handle
 *
 * This routine is called as a stream is being opened onto the device by
 * DeviceFS. It must store the relevant handles and setup the device.
 *
 * The special field control block will consist of a number of words each
 * corresponding to the field in the device open string.
 */
_kernel_oserror *device_initialise(int devicefs_stream, int flags, int fileswitch_handle, sfblock *specialfield, int *ourstream)
{
    Stream *stream = (flags & 1) ? &OutputStream : &InputStream;

    *ourstream = (int) stream;

    devicefs_handler_threaded = 1;

    stream->devicefs_stream = devicefs_stream;
    stream->fileswitch_handle = fileswitch_handle;

    if (specialfield->size != 0xDEADDEAD)
        stream->buffersize = specialfield->size;

    if (specialfield->thresh != 0xDEADDEAD)
        stream->bufferthreshold = specialfield->thresh;

    devicefs_handler_threaded = 0;

    return NULL;
}

/*
 * DeviceDriver_Entry 1 : Finalise
 *
 * In: stream       = internal stream handle (or 0 for all)
 *
 * This routine is called when a stream is being closed by DeviceFS. When
 * received then we should halt the relevant transmission type until the stream
 * is re-opened.
 */
static _kernel_oserror *device_finalise(Stream *stream, void *pw)
{
    if (stream == NULL)
    {
        device_finalise(&InputStream, pw);
        device_finalise(&OutputStream, pw);
    }
    else
    {
        if (stream->devicefs_stream == 0)
            return NULL;

        devicefs_handler_threaded = 1;

        stream->devicefs_stream=0;
        stream->buffer=0;
        stream->buffer_privid=-1;

        /* If this is the last stream, shut down the hardware */
        if (--active_streams == 0)
        {
             riscos_stop_polling(pw);
        }

        devicefs_handler_threaded = 0;
    }

    return NULL;
}

static _kernel_oserror *device_wakeupfortx(Stream *stream, void *pw)
{
  devicefs_handler_threaded = 1;
  modem_transmit_buffer_write();
  devicefs_handler_threaded = 0;
  
  return NULL;
}

/*
 * DeviceDriver_Entry 6 : Create buffer for TX
 *
 * In: stream       = internal stream handle
 *     flags        = suggested flags for buffer being created
 *     size         = suggested size for buffer
 *     handle       = suggested buffer handle (-1 for unique generated one)
 *     threshold    = suggested threshold for buffer
 *
 * Out: flags, size, handle, threshold modified as required
 *
 * This routine is called before the buffer is actually created, it allows the
 * device to change the values and then return.
 */
static _kernel_oserror *device_create_tx_buffer(bufparams *params)
{
    if (OutputStream.buffersize)
        params->size = OutputStream.buffersize;
    else
        OutputStream.buffersize = params->size;

    if (OutputStream.bufferthreshold)
        params->threshold = OutputStream.bufferthreshold;
    else
        OutputStream.bufferthreshold = params->threshold;

    return NULL;
}

/*
 * DeviceDriver_Entry 7 : Create buffer for RX
 *
 * In: stream       = internal stream handle
 *     flags        = suggested flags for buffer being created
 *     size         = suggested size for buffer
 *     handle       = suggested buffer handle (-1 for unique generated one)
 *     threshold    = suggested threshold for buffer
 *
 * Out: flags, size, handle, threshold modified as required
 *
 * This routine is called before the buffer is actually created, it allows the
 * device to change the values and then return.
 */
_kernel_oserror *device_create_rx_buffer(bufparams *params)
{
    if (InputStream.buffersize)
        params->size = InputStream.buffersize;
    else
        InputStream.buffersize = params->size;

    if (InputStream.bufferthreshold)
        params->threshold = InputStream.bufferthreshold;
    else
        InputStream.bufferthreshold = params->threshold;

    return NULL;
}

static _kernel_oserror *device_halt(Stream *stream)
{
    return NULL;
}

static _kernel_oserror *device_resume(Stream *stream)
{
    return NULL;
}

/*
 * DeviceDriver_Entry 11 : Stream created
 *
 * In: stream       = internal stream handle
 *     handle       = buffer handle (-1 if none)
 *     threshold    = suggested threshold for buffer
 *
 * This routine is called after the stream has been created, it gives me a chance
 * to setup the device correctly and start transmission etc, etc...
 */
static _kernel_oserror *device_stream_created(Stream *stream, int buffer, void *pw)
{
    _kernel_oserror *e;

    e = _swix(Buffer_InternalInfo, _IN(0)|_OUTR(0,2), buffer,
                                                      &stream->buffer_privid,
                                                      &BuffManService,
                                                      &BuffManWS
             );
    if (e) return e;

    stream->buffer = buffer;

    /* If this is the first stream, lets kick the thing into life */
    if (active_streams++ == 0)
    {
        #ifdef DEBUG
        InitPktDescriptors();
        init_trace();
        #endif

        e = riscos_start_polling(pw);
        if (e) return e;

#ifdef TMLDEBUG
        Printf("riscos_start_polling called\n");
#endif
    }


    return NULL;
}

/*
 * DeviceDriver_Entry 14 : IOCtl
 *
 * In: stream       = internal stream handle
 *     param        = IOCtl parameter block as passed in R2 of OS_Args call
 *
 * This call is dispatched to the underlying device driver whenever the OS_Args IOCtl SWI is
 * called or the SWI DeviceFS_CallDevice (14) is called.
 */
static _kernel_oserror *device_ioctl(Stream *stream, ioctl_t *param)
{
    switch (param->group)
    {
      case 0:
        switch (param->reason)
        {
          case 4:
            return ioctl_buffer_size(stream, param);
          case 5:
            return ioctl_buffer_threshold(stream, param);
          case 6:
            return ioctl_control_lines(param);
        }
    }
    return NULL;
}

static _kernel_oserror *ioctl_buffer_size(Stream *stream, ioctl_t *param)
{
    if (param->write)
    {
        stream->buffersize = param->data;
    }

    if (param->read)
    {
        param->data = stream->buffersize;
    }

    return NULL;
}

static _kernel_oserror *ioctl_buffer_threshold(Stream *stream, ioctl_t *param)
{
    if (param->write)
    {
        _kernel_oserror *e = _swix(Buffer_Threshold, _INR(0,1), stream->buffer, param->data);
        if (e) return e;
        stream->bufferthreshold = param->data;
    }

    if (param->read)
    {
        param->data = stream->bufferthreshold;
    }

    return NULL;
}

static _kernel_oserror *ioctl_control_lines(ioctl_t *param)
{
    if (param->write)
    {
        RO_dtr = param->data & ControlLine_DTR;
    }
    if (param->read)
    {
        unsigned int out = ControlLine_CTS | ControlLine_FifosOn;

        if (RO_dtr)
            out |= ControlLine_DTR;

        if (RO_dcd)
            out |= ControlLine_DCD;

        if (RO_ring)
            out |= ControlLine_RI;

        if (RO_dsr)
            out |= ControlLine_DSR;

        param->data = out;

    }

    return NULL;
}

#define Event_RS423Error    7

#define SerialEvent_Parity  (1U<<5)
#define SerialEvent_Overrun (1U<<4)
#define SerialEvent_Framing (1U<<3)
#define SerialEvent_DSR     (1U<<2)
#define SerialEvent_DCD     (1U<<1)

void send_riscos_serial_event()
{
    unsigned int flags = 0;

    if (RO_dsr)
        flags |= SerialEvent_DSR;

    if (RO_dcd)
        flags |= SerialEvent_DCD;

    _swix(OS_GenerateEvent, _INR(0,2), Event_RS423Error, flags, InputStream.fileswitch_handle);
}


/************************/
/* END OF DEVICEFS BITS */
/************************/
////////////////////////////////////////////////////////////////////////////////////////////




static _kernel_oserror *riscos_start_polling(void *pw)
{
  _kernel_oserror *e=NULL;

  polling_semaphore++;

  if(polling_semaphore == 1)
  {
    e=_swix(OS_CallEvery, _INR(0,2), polling_period-1, callevery_veneer, pw);
  }
  return e;
}


static void riscos_stop_polling(void *pw)
{
  polling_semaphore--;

  if ( polling_semaphore == 0 )
  {
    _swix(OS_RemoveTickerEvent, _INR(0,1), callevery_veneer, pw);
  }
}



extern void call_in_user(void *);

//
// Function: callevery_handler
//
// This function is invoked to handle callbacks.  The main modem codebase is
//  polled from this routine.  A safe floating point context is placed around the
//  modem codebase call as Dragnet uses FP in a couple of locations.  IRQs are
//  enabled during the Dragnet call to reduce latency as it occasionally requires
//  significant time to complete the call.
//
_kernel_oserror *callevery_handler(_kernel_swi_regs *r, void *pw)
{
    if (!poll_loop_threaded && !interrupt_handler_threaded && !devicefs_handler_threaded)
    {
        poll_loop_threaded = 1;
        callbacks++;
        led_set(ALBA2_LED_CALLEVERY);
        podule_led_on();

        modem_transmit_buffer_write();    // move input stream contents to modem
        fp_context_begin();               // begin our own fp context

        _kernel_irqs_on();

          ll_periodic();                  // poll modem state machine
//debug          call_in_user ( (void*)ll_periodic );

        _kernel_irqs_off();

        fp_context_end();                 // end our own fp context
        modem_receive_buffer_read();      // move modem output to output stream

        podule_led_off();
        led_clear(ALBA2_LED_CALLEVERY);
        poll_loop_threaded = 0;
    }

    return NULL;
}



#ifndef DSP_POLLED_MODE // Polled only DSP build specific stuff

  //
  // Function: interrupt_handler
  //
  // This function is invoked to handle interrupts raised by the Dragnet DSP
  //
  _kernel_oserror *interrupt_handler(_kernel_swi_regs *r, void *pw)
  {
    if (interrupt_handler_threaded)
    {
      reentrancy_count++;
      return NULL;
    }
      
    if ( !devicefs_handler_threaded )
    {
      interrupt_handler_threaded=1;
      total_irq_count++;
  
      led_set(ALBA2_LED_INTERRUPT);
      dp_dsp_isr();
      led_clear(ALBA2_LED_INTERRUPT);
  
      interrupt_handler_threaded=0;
    }
    return NULL;
  }

  
#else // Interrupt driven DSP build specific stuff


  //
  // Function: interrupt_handler
  //
  // Dummy function in non interrupt driven build
  //
  _kernel_oserror *interrupt_handler(_kernel_swi_regs *r, void *pw)
  {
    return NULL;  // dummy function to keep cmhg linking happy
  }


#endif // Polled only DSP or Interrupt driven DSP build specific stuff


/*****************************************************************************
* END OF FILE
*****************************************************************************/
