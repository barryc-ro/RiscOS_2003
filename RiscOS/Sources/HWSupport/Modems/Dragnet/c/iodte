/*name and version number:@(#)iodte.c	1.124*/
/*date of get: 		  12/15/00 10:10:36*/
/*date of delta:	  11/30/00 16:57:57*/
/****************************************************************
File :	iodte.c
Description :
	Contains all the functions for the dte interface.

Procedures Contained :
	UART_Flush
	UART_SetRxQue
	UART_SetTxQue
	UART_SetQue
	io_get_dte_rx_char
	io_at_esc_seq_detected
	io_get_dte_tx_count
	io_put_dte_tx_char
	io_write_dte_fifo
	io_get_dte_rx_bytes
	UART_CommReadCount
	UART_CommWriteCount

Revision History :
	Initials	Date		Change
	VR      	09/24/92	Initial
*****************************************************************/

#include "llglob_d.h"
#include "ioglob_d.h"
#include "iouart_d.h"

#if defined( Z80_EASCI_RX_DMA )
#include "z80glob.h"
//#define x_debug_msg(strp) ddputs(strp)
#endif
#include "allglobs.h"


/****************************************************************
Routine : UART_Flush
Description :
	Initialize the read the write dte pointers.
	Flush the transmit and receive queues for windows.
Parameters in :
	queue - specifies the queue to be flushed
		  - 0 = transmit queue
		  - 1 = receive queue
Parameters out :
	none
Revision History :
	Initials	Date		Change
*****************************************************************/
void UART_Flush ( word queue )
{
	if ( queue == 0 )
	{
		// if same queue for app and modem
		I(io_dte_rx_wptr) = I(io_dte_rx_sptr) ;
		I(io_dte_rx_rptr) = I(io_dte_rx_sptr) ;
		#if defined(TCP_IP)
		host_rx_wptr = host_rx_sptr ;
		host_rx_rptr = host_rx_sptr ;
		#endif
		#if defined(Z80_EASCI_RX_DMA)
		z80_flush_rx_dma ( ) ;
		#endif
	}
	if ( queue == 1 )
	{
		I(io_dte_tx_wptr) = I(io_dte_tx_sptr) ;
		I(io_dte_tx_rptr) = I(io_dte_tx_sptr) ;
		#if defined(TCP_IP)
		host_tx_wptr = host_tx_sptr ;
		host_tx_rptr = host_tx_sptr ;
		#endif
	}
}

/****************************************************************
Routine : UART_SetRxQue
Description :
	Set the receive buffer pointers for windows. Remember,
	what windows receives, we transmit.
Parameters in :
	pqRx	-	points to the receive queue.
	cbqRx	-	size in bytes of the receive queue.
Parameters out :
	none
Revision History :
	Initials	Date		Change

		(note that in the venus environment this function
		simply initializes pointers to their buffers,
		the concept of application buffers as in windows
		doesn't make sense.)
*****************************************************************/
void UART_SetRxQue ( byte *pqRx, word cbqRx )
{
#if defined( SA_MULTI_INSTANCE )
	I(io_dte_tx_sptr) = &BGlobArray[ ModemNum ].io_dte_tx_buff[0] ;
	I(io_dte_tx_eptr) = I(io_dte_tx_sptr) + IO_DTE_TX_BUFF_SIZE ;
#else
	io_dte_tx_sptr = io_dte_tx_buff ;
	io_dte_tx_eptr = io_dte_tx_buff + IO_DTE_TX_BUFF_SIZE ;
	#if defined(TCP_IP)
	host_tx_sptr = host_tx_buff ;
	host_tx_eptr = host_tx_buff + HOST_TX_BUFF_SIZE ;
	#endif
#endif	// SA_MULTI_INSTANCE

	UART_Flush ( 1 ) ;
}

/****************************************************************
Routine : UART_SetTxQue
Description :
	Set the transmit buffer pointers for windows. Remember,
	what windows transmits, we receive.
Parameters in :
	pqTx	-	points to the transmit queue.
	cbqTx	-	size in bytes of the transmit queue.
Parameters out :
	none
Revision History :
	Initials	Date		Change

		(note that in the venus environment this function
		simply initializes pointers to their buffers,
		the concept of application buffers as in windows
		doesn't make sense.)
*****************************************************************/
void UART_SetTxQue ( byte *pqTx, word cbqTx )
{
#if defined( SA_MULTI_INSTANCE )
	I(io_dte_rx_sptr) =  &BGlobArray[ ModemNum ].io_dte_rx_buff[0] ;
	I(io_dte_rx_eptr) = I(io_dte_rx_sptr) + IO_DTE_TX_BUFF_SIZE ;
#else
	io_dte_rx_sptr = io_dte_rx_buff ;
	io_dte_rx_eptr = io_dte_rx_buff + IO_DTE_RX_BUFF_SIZE ;
	#if defined(TCP_IP)
	host_rx_sptr = host_rx_buff ;
	host_rx_eptr = host_rx_buff + HOST_RX_BUFF_SIZE ;
	#endif
#endif	// SA_MULTI_INSTANCE

	UART_Flush(0);
	G(io_esc_dte_wptr) = (byte *) I(io_dte_rx_wptr) ;
}

/****************************************************************
Routine : UART_SetQue
Description :
	Set the transmit and receive buffer pointers for windows.
Parameters in :
	pqTx	-	points to the transmit queue.
	cbqTx	-	size in bytes of the transmit queue.
	pqRx	-	points to the receive queue.
	cbqRx	-	size in bytes of the receive queue.
Parameters out :
	none
Revision History :
	Initials	Date		Change

		(note that in the venus environment this function
		simply initializes pointers to their buffers,
		the concept of application buffers as in windows
		doesn't make sense.)
*****************************************************************/
void UART_SetQue ( byte *pqTx, word cbqTx, byte *pqRx, word cbqRx )
{
	UART_SetRxQue ( pqRx, cbqRx ) ;
	UART_SetTxQue ( pqTx, cbqTx ) ;
}

/****************************************************************
Routine : io_get_dte_rx_char
Description :
	This routine is called to get the next byte from dte receive queue.
Parameters in :
	&rdata_ptr	-	pointer to byte received from the dte
Parameters out :
	TRUE		-	if data is available
	FALSE		-	if no data available
Revision History :
	Initials	Date		Change
*****************************************************************/
byte io_get_dte_rx_char ( byte *rdata_ptr )
{
	if ( !IS_DTE_RX_EMPTY() )
	{
		*rdata_ptr = *I(io_dte_rx_rptr)++ ;
		DTE_RX_UPDATE() ;
		return ( TRUE ) ;
	}
	else
	{
		return ( FALSE ) ;
	}
}

/****************************************************************
Routine : io_at_esc_seq_detected
Description :
	This routine checks for the at escape sequence.
Parameters in :
	none
Parameters out :
	TRUE		-	if "+++" escape sequence is detected with atleast
					1sec guard time
	FALSE		-	if escape not detected
Revision History :
	Initials	Date		Change
*****************************************************************/
byte io_at_esc_seq_detected ( void )
{
#if !defined(CS_MODEM)
	switch ( G(io_at_esc_state) )
	{
		case AT_ESC_INIT_STATE :
			if ( G(S).ModemOptions.EscapeChar <= 127 )
			{
				G(io_esc_dte_wptr) = (byte *) I(io_dte_rx_wptr) ;
				G(io_at_esc_timer) = x_current_time () ;
				G(io_at_esc_state) = AT_ESC_STATE1 ;
				#if !defined( CS_4 )
				x_debug_msg ( "IO - at escape state1" ) ;
				#endif
			}
			break ;

		case AT_ESC_STATE1 :
			// compare dte receive buffer pointers
			if ( I(io_dte_rx_wptr) != G(io_esc_dte_wptr) )
			{
				// check escape character - remove parity bit
				if ( (byte) (*G(io_esc_dte_wptr) & 0x7f) == G(S).ModemOptions.EscapeChar )
				{
					if ( (x_elapsed_time (G(io_at_esc_timer))) >=
		   				(word)(20*(word)G(S).ModemOptions.EscapeGuardTime - 100) )
					{
						G(io_at_esc_state) = AT_ESC_STATE2 ;
						x_debug_msg ( "IO - at escape state2" ) ;
						G(io_at_esc_timer) = x_current_time () ;
						if ( ++G(io_esc_dte_wptr) >= I(io_dte_rx_eptr) )
							G(io_esc_dte_wptr) = (byte *) I(io_dte_rx_sptr);
					}
					else
						G(io_at_esc_state) = AT_ESC_INIT_STATE ;
				}
				else
				{
					G(io_esc_dte_wptr) = (byte *) I(io_dte_rx_wptr);
					G(io_at_esc_timer) = x_current_time () ;
				}
			}
			break ;

		case AT_ESC_STATE2 :
		case AT_ESC_STATE3 :
			if ( I(io_dte_rx_wptr) != G(io_esc_dte_wptr) )
			{
				if ( (byte) (*G(io_esc_dte_wptr) & 0x7f) == G(S).ModemOptions.EscapeChar )
				{
//					++G(io_at_esc_state) ;
					G(io_at_esc_state) = (AT_ESC_STATE)((byte)G(io_at_esc_state) + 1);
					x_debug_msg ( "IO - at escape state 3-4" ) ;
					G(io_at_esc_timer) = x_current_time () ;
					if ( ++G(io_esc_dte_wptr) >= I(io_dte_rx_eptr) )
						G(io_esc_dte_wptr) = (byte *) I(io_dte_rx_sptr);
				}
				else
					G(io_at_esc_state) = AT_ESC_INIT_STATE ;
			}
			else
			{
				if ( (x_elapsed_time (G(io_at_esc_timer))) >=
		   				(word)(20*(word)G(S).ModemOptions.EscapeGuardTime + 500) )
					G(io_at_esc_state) = AT_ESC_INIT_STATE ;
			}
			break ;

		case AT_ESC_STATE4 :
			if ( I(io_dte_rx_wptr) == G(io_esc_dte_wptr) )
			{
				if ( (x_elapsed_time (G(io_at_esc_timer))) >=
		   			(word)((20*(word)G(S).ModemOptions.EscapeGuardTime)-100) )
				{
					G(io_at_esc_state) = AT_ESC_INIT_STATE ;
					if ( G(S).ModemOptions.FlowControl == SW_FLOWCTRL )
					{
						UART_xoff_off () ;	// Clear XOFF
						UART_Flush ( 1 ) ;	// flush applications' receive queue
					}

					// mah - 11/16/98 - moved this code here
					// from the repeated places in iomain.c
					x_debug_msg("IO - at escape sequence detected");
					G(io_at_esc_detect) = TRUE;
					x_send_mail(AT_OK, AT_TASK, 0, 0 );
					return TRUE;
				}
			}
			else
			{
				G(io_at_esc_state) = AT_ESC_INIT_STATE ;
			}
			break ;
	}
#endif //CS_MODEM

	return ( FALSE ) ;
}

/****************************************************************
Routine : io_get_dte_tx_count
Description :
	This routine returns the free bytes available on the dte transmit queue.
Parameters in :
	none
Parameters out :
	bytes available on tx queue to be written
Revision History :
	Initials	Date		Change
*****************************************************************/
word io_get_dte_tx_count ( void )
{
	byte *rptr, *wptr ;

	rptr = (byte *) I(io_dte_tx_rptr);
	wptr = (byte *) I(io_dte_tx_wptr);
	if ( wptr >= rptr )
		return ((I(io_dte_tx_eptr) - I(io_dte_tx_sptr)) - (wptr - rptr) - 1) ;
	else
		return ((rptr - wptr) - 1) ;
}

/****************************************************************
Routine : io_put_dte_tx_char
Description :
	This routine is called to put a byte on the dte transmit queue.
Parameters in :
	tx_byte	-	byte to put on the transmit queue
Parameters out :
	none
Revision History :
	Initials	Date		Change
*****************************************************************/
void io_put_dte_tx_char ( byte tx_byte )
{
	byte *wptr ;

	wptr = (byte *) I(io_dte_tx_wptr);
	*wptr++ = tx_byte ;
	if ( wptr >= I(io_dte_tx_eptr) )
		wptr = (byte *) I(io_dte_tx_sptr);
	I(io_dte_tx_wptr) = wptr ;
}

/****************************************************************
Routine : io_write_dte_fifo
Parameters in :
	from -	pointer to write data 
	count-	count of bytes to write 
Parameters out :
	none
Revision History :
	Initials	Date		Change
*****************************************************************/
void io_write_dte_fifo ( word count, word* from )
{
	byte *wptr ;

	wptr = (byte *) I(io_dte_tx_wptr);
	while ( count-- )
	{
		*wptr++ = (byte) (*from++) ;
		if ( wptr >= I(io_dte_tx_eptr) )
			wptr = (byte *) I(io_dte_tx_sptr);
	}
	I(io_dte_tx_wptr) = wptr ;
}

/****************************************************************
Routine : io_get_dte_rx_bytes
Description :
	Calculates the number of bytes available in the modem's dte
	receive queue.
Parameters in :
	none
Parameters out :
	count -	the number of bytes available to transmit to the line
Revision History :
	Initials	Date		Change
*****************************************************************/
word io_get_dte_rx_bytes ( void )
{
	byte *wptr, *rptr ;
	word count ;

	rptr = (byte *) I(io_dte_rx_rptr);
	wptr = (byte *) I(io_dte_rx_wptr);
	if ( wptr >= rptr )
		count = ( wptr - rptr ) ;
	else
		count = ( (I(io_dte_rx_eptr) - rptr) + (wptr - I(io_dte_rx_sptr)) ) ;
	return ( count ) ;
}

#if !(defined(MODEM_Z80) || defined(MODEM_ARM)) || defined(CS_MODEM)
/****************************************************************
Routine : UART_CommReadCount
Description :
	Calculates the number of bytes available to read.
Parameters in :
	none
Parameters out :
	count -	the number of bytes available to read
Revision History :
	Initials	Date		Change
*****************************************************************/
word UART_CommReadCount ( void )
{
	byte *rptr, *wptr ;

#if !defined(CS_MODEM)
	// if on-line and RTS if off - flow control - do not transmit
	// data to the dte if hardware flow control is selected
	if ( (G(x_modem_state) == MS_ON_DIAL) && (G(x_modem_mode) == MODEM_DATA)
	  && (G(io_at_esc_detect) == FALSE) &&
		(G(S).ModemOptions.V42 != V42_SYNC_BUFFERED )
#ifdef DSVD	  
		 &&  ( x_dsvd_connect == FALSE )
#endif
		 )
	{
		 if ( ( G(S).ModemOptions.FlowControl == HW_FLOWCTRL ) &&
		 	  ( !(G(io_uart_status) & UART_RTS_ON) ) ) // if RTS off
			return ( 0 ) ;
		 else if ( ( G(S).ModemOptions.FlowControl == SW_FLOWCTRL ) &&
		 	  ( G(io_uart_status) & UART_XOFF_ON ) ) // if received xoff
			return ( 0 ) ;
	}
#endif

	rptr = (byte *) I(io_dte_tx_rptr);
	wptr = (byte *) I(io_dte_tx_wptr);
	if ( wptr >= rptr )
		return ( wptr - rptr ) ;
	else
		return ((I(io_dte_tx_eptr) - rptr) + (wptr - I(io_dte_tx_sptr))) ;
}
#endif	// !(MODEM_Z80 || MODEM_ARM) || CS_MODEM
