/*name and version number:@(#)dpmain.c	1.776*/
/*date of get: 		  05/02/01 16:50:22*/
/*date of delta:	  05/02/01 16:44:15*/
/****************************************************************
File:  dpmain.c
Description:
	The main entry routine for dp task.  

Procedures Contained:
	dp_task
	dp_periodic_task
	dp_init_variables
	dp_fax_modem_idle_cmd

Revision History:
	Initials    Date        Change
*****************************************************************/
#define Z80_DEBUG_THIS_FILE

#include "llglob_d.h"
#include "dpglob.h"
#include "ioglob_d.h"
#include "iouart_d.h"
#include "sync.h"
#ifdef DC0
# include "cellular.h"
#endif
#if defined(V34_FAX)
# include "faxv34.h"
#endif
#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
	#include "fax_c2.h"
	#if defined(SA_DIGITAL)
		#include "sa_t1.h"  
	#endif
#endif // CLASS2 || CLASS20
#if defined(CS_DIGITAL)
# include "dpv17idl.h"
# define DP_DOWNLOAD_GLITCHLESS_IDLE()	DOWNLOAD_DSP(wV17_IDLE)
#else
# define DP_DOWNLOAD_GLITCHLESS_IDLE()
#endif
#include "atglob.h"
#include "z80glob.h"
#include "v42bis.h"
#include "allglobs.h"

extern byte q2Dial;
extern byte q3Dial;
extern void sync_q2q3_dial_loop(void);

/****************************************************************
	functions used by dp task
*****************************************************************/
extern byte lapm_disconnecting(void);
extern void dp_reset_venus(void);
extern void x_set_hardware_options(void);
extern void dp_copernicus_dial(void);
extern void dp_copernicus_ring(void);
extern byte dp_copernicus_hangup(void);
extern void dp_print_state_pointers(void);
void dp_fax_modem_idle_cmd (void);
void dp_sdr_ring(void);
extern void dp_sdr_report(void);
extern void dp_sdr_ring_init(void);
extern void vpcm_set_answering_mode(void);
extern void dp_first_init_perseus(void);

#define CHK_VF_PP	0xdc01	//chk_VF_PP

extern void dp_enable_call_waiting(void);
extern byte dp_check_call_waiting(void);
extern void dp_mh_bg(void);

byte dp_invalid_count;
word dp_invalid_timer;

/****************************************************************
Routine: dp_init_variables
Description: Initialize all variables used by dp task and variables 
		  that are defined in llglob_x.h
*****************************************************************/
void dp_init_variables(void)
{   
	// init global variables for DP task
	G(x_modem_state) = MS_IDLE;
	G(x_dial_residual) = MR_OK;
	G(dp_state) = DP_IDLE;
	G(dp_line_state) = DP_LINE_ON_HOOK;
	G(dp_calling_tone_disable) = FALSE;
	G(dp_wDspRetrainState) = 0;
	G(DpIdleFillChar) = 0x00;  //  idle line (no data) fill character
	G(dp_fax_status) = 0;
	G(dp_fax_dropout_time) = 2000;  // FAX dropout time, default to 2 seconds	     

#if defined(V34_FAX)
	G(x_fax_v34mode) = NON_V34;
#endif

#if defined(SDR_RING_DETECT)
	G(SDR_Ring_Select) = 0;
#endif

#ifdef HOMOL 
	dp_init_blacklist();
#ifdef VOICE
	G(dp_polarity_int) = FALSE;
#endif
#endif
	// Initialize local phone state and timer
	G(dp_tad_downloaded) = FALSE;
	G(dp_fax_downloaded) = FALSE;
	dp_init_local_phone_state();
	G(last_fax_v17) = NON_V17;
#ifdef VOICE
	G(dp_vt_cntrl) = TAD_IDLE;
#endif
	G(dp_fdsp_record) = FALSE;
#if defined (V8BIS)
	v8bis_power_up_init();
#endif	//V8BIS
	G(dp_redial) = FALSE;
#if defined(VPCM_CLIENT) || defined(VPCM_SERVER)
	G(vpcm_mode) = 0;		// 0 = K56FLEX, 1 = VPCM
#endif	// VPCM_CLIENT || VPCM_SERVER
#if defined(V92_MODEM_ON_HOLD)
	G(dp_mh_state) = MH_NULL;
#endif
}

// -------------------------------------------- //
// Set FAX Mode for V.34 or Non-V.34 Modulation //
// -------------------------------------------- //

void set_fax_modulation(void)
{
#ifdef V34_FAX
	#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
	if (CLASS_2_OR_20)                  // Using 2, 2.0 or 2.1 interface?
	{
		#ifdef TEST_V34_FAX_WITH_WINFAX80
		// Shift rate to 16.8 - 28.8 range
		G(c2p.fdis.ps.br) = G(c2p.fdis.ps.br) + 6;
		G(c2p.fdis.ps.ec) = 1;                   // Enable ECM, T.30, Annex A
		G(c2p.dbf) = (G(c2p.dbf) & ~FECM) | 0x0800; // DCE handles ECM alone

		if (G(S).ModemOptions.V8_CI_Octet != 0xA1)
			G(S).ModemOptions.V8_CI_Octet = 0x81;

			G(S).ModemOptions.AdaptiveAnswer = TRUE; // enabled
		#else
		if ((G(c2p.fdis.ps.br) <= 5) ||    // 14,400 or lower data rate?
				 (G(c2p.fclass) == 2))     // Using Class 2 interface?
			G(x_fax_v34mode) = NON_V34;     // Use V.17, V.33, V.29 or V.27

		else                                  // Data rate greater than 14,400
		#endif
		{
			G(x_fax_v34mode) = V34_SOURCE;      // Use V.34 modulation
			// Update maximum V.34 primary channel data rate
			G(x_fax_maxp) = G(c2p.fdis.ps.br) + 1;
			G(x_fax_minp) = 1;     // Set minimum primary channel rate to 2,400

			if (G(S).ModemOptions.V8_CI_Octet != 0xA1)
				G(S).ModemOptions.V8_CI_Octet = 0x81;
		}
	}
	#endif
#endif
}

// ----------------------------------------------------------- //
// Determine the Preamble time for the selected FAX modulation //
// ----------------------------------------------------------- //
word dp_preamble_time(void)
{
	// In milliseconds
	static const word non_v17_times [] = {1383, 1158, 478, 478, 1836, 1836};
	word time = MS850;  // Default to V.21 HDLC (850 ms)

	if (G(x_fax_rate) != MR_300)
	{
		if (G(x_fax_v17) == V17_SHORT_TRAIN)     // Short train used?
			time = 585;              // Delay for V.17 modulation, short train

		else if (G(x_fax_v17) == V17_LONG_TRAIN)
			time = 1836;             // Delay for V.17 modulation, long train

		else if ((G(x_fax_rate) >= MR_2400) && (G(x_fax_rate) <= MR_14400))
			time = non_v17_times [G(x_fax_rate)-5];
	}

	return time;
}

// ------------------------------------------------------------ //
// Check if the datapump is not receiving the correct data rate //
// ------------------------------------------------------------ //
/*
	 Return TRUE: Incorrect data rate was detected or still qualifing signal
	 Return FALSE: Incorrect data rate was not detected
*/
byte dp_wrong_speed(void)
{
	byte chk = FALSE;

#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
	if (!CLASS_2_OR_20)  // Not using Class 2.x interface?
#endif
	{
		// V.21 detected in non-V.21 mode?
		if (dp_read_dsp_ram(0x3B) & 0x0800)
		{
			// Indicate incorrect data rate or signal is still being qualified
			chk = TRUE;

			// Initialize signal qualification?
			if (G(dp_fax_status) & START_V21_DEBOUNCE)
			{
				G(dp_fax_status) = G(dp_fax_status) & ~START_V21_DEBOUNCE;  // Clear flag
				// Start timer
				shared_ram.dp_wrong_speed_timer = x_current_time();
			}
			else if (x_elapsed_time (shared_ram.dp_wrong_speed_timer) > 60)
			{
				// Signal present for 60 ms
				x_debug_msg("DP - wrong_speed");
				G(dp_state) = DP_NULL;
				// Make rates different; causes +FCERROR response
				G(x_line_rate) = (MODEM_LINE_RATE) ~G(x_fax_rate); //msm//
				G(x_modem_state) = MS_ON_DIAL;
				// Send +FCERROR to host
				x_send_mail(DP_IO_CONNECT, IO_TASK, NULL, 0);
			}
		}
	}

	return chk;
}

// ---------------------------------------------- //
// Program DSP IIR filter #1 as a bandpass filter //
// ---------------------------------------------- //
/*
		This filter design is taken from "Appendix
		B. Design/Application Information" of some unknown Lucent (old
		AT&T) Document.

		Type: Bandpass
		Order: 6th
		Low Freq: 1,400 Hz
		High Freq: 2,200 Hz
		Min. Threshold: -43 dbm

		Use: Monitor the absence or presence of FAX V.27ter, V.29,
		V.17 or V.33 carriers in response to an AT+FRS=n command used
		with a Class 1 interface.
*/

void prog_bp_filter(void)
{
	static const word coef_tab[] =
	{
		IIR1_K_ADDR, 	 0x3932,	// K

		IIR1_D11_ADDR, 0x0000,	// d(1,1)
		IIR1_D12_ADDR, 0x2367,	// d(1,2)
		IIR1_N11_ADDR, 0x0000,	// n(1,1)
		IIR1_N12_ADDR, 0xF9A7,	// n(1,2)
		IIR1_N10_ADDR, 0x0659,	// n(1,0)

		IIR1_D21_ADDR, 0x2AE0,	// d(2,1)
		IIR1_D22_ADDR, 0x37CD,	// d(2,2)
		IIR1_N21_ADDR, 0x322E,	// n(2,1)
		IIR1_N22_ADDR, 0x3215,	// n(2,2)
		IIR1_N20_ADDR, 0x3215,	// n(2,0)

		IIR1_D31_ADDR, 0xD520,	// d(3,1)
		IIR1_D32_ADDR, 0x37CD,	// d(3,2)
		IIR1_N31_ADDR, 0xA053,	// n(3,1)
		IIR1_N32_ADDR, 0x5F7C,	// n(3,2)
		IIR1_N30_ADDR, 0x5F7C	  // n(3,0)
	};

	// Indicate receive silence wait
	G(dp_fax_status) = G(dp_fax_status) | RECEIVE_SILENCE;
	dp_write_dsp_ram(IIR1_THRESHOLD_ADDR, 43);	// Detect threshold @ -43 dbm

	// Load filter coefficients into DSP
	dp_write_dsp_block(coef_tab, sizeof(coef_tab)/(2*sizeof(word)));
	dp_modem_command(DETECT_TONES, 1, 0);		// Start bandpass filter
}

// ------------------------------------------------------ //
// Initialize to look for CI after fallback from V.34 FAX //
// ------------------------------------------------------ //
/*
		V.21 Channel 1: 980 Hz - 1,180 Hz (Data)
		V.21 Channel 2: 1,650 Hz - 1,850 Hz  (Fax)

		Type: Bandpass
		Order: 6th
		Low Freq:    980 Hz (Ch 1), 1,650 (Ch 2)
		High Freq: 1,180 Hz (Ch 1), 1,850 Hz (Ch 2)
		Min. Threshold: -43 dbm

V.21 Channel 1:  K = .1316207877

i				 n[i,0]      n[i,1]       n[i,2]       d[i,0]       d[i,1]       d[i,2]
1			.1316207877 -.2632415753  .1316207877           1   -1.131156     .917114
2			.1316207877            0 -.1316207877           1   -1.282149     .960506
3			.1316207877  .2632415753  .1316207877           1   -1.012331     .955449


V.21 Channel 2:  K = .1316173314

i				 n[i,0]      n[i,1]       n[i,2]       d[i,0]       d[i,1]       d[i,2]
1			.1316173314 -.2632346628  .1316173314           1    -.083944     .917117
2			.1316173314            0 -.1316173314           1    -.249909     .958127
3			.1316173314  .2632346628  .1316173314           1    -.079634     .957824

*/

#ifdef V34_FAX
void init_fax_ci_det (void)
{
	static const word ch1_tab[] =
	{
		IIR1_K_ADDR, 	 0x086C,	// K

		IIR1_D11_ADDR, 0xB79B,  // d(1,1)
		IIR1_D12_ADDR, 0x3AB2,	// d(1,2)
		IIR1_N11_ADDR, 0xEF27,	// n(1,1)
		IIR1_N12_ADDR, 0x086C,	// n(1,2)
		IIR1_N10_ADDR, 0x086C,	// n(1,0)

		IIR1_D21_ADDR, 0xADF1,	// d(2,1)
		IIR1_D22_ADDR, 0x3D79,	// d(2,2)
		IIR1_N21_ADDR, 0x0000,	// n(2,1)
		IIR1_N22_ADDR, 0xF794,	// n(2,2)
		IIR1_N20_ADDR, 0x086C,	// n(2,0)

		IIR1_D31_ADDR, 0xBF36,	// d(3,1)
		IIR1_D32_ADDR, 0x3D26,	// d(3,2)
		IIR1_N31_ADDR, 0x10D9,	// n(3,1)
		IIR1_N32_ADDR, 0x086C,	// n(3,2)
		IIR1_N30_ADDR, 0x086C	  // n(3,0)
	};
	static const word ch2_tab[] =
	{
		IIR2_K_ADDR, 	 0x086C,	// K

		IIR2_D11_ADDR, 0xFAA1,  // d(1,1)
		IIR2_D12_ADDR, 0x3AB2,	// d(1,2)
		IIR2_N11_ADDR, 0xEF27,	// n(1,1)
		IIR2_N12_ADDR, 0x086C,	// n(1,2)
		IIR2_N10_ADDR, 0x086C,	// n(1,0)

		IIR2_D21_ADDR, 0xF001,	// d(2,1)
		IIR2_D22_ADDR, 0x3D52,	// d(2,2)
		IIR2_N21_ADDR, 0x0000,	// n(2,1)
		IIR2_N22_ADDR, 0xF794,	// n(2,2)
		IIR2_N20_ADDR, 0x086C,	// n(2,0)

		IIR2_D31_ADDR, 0xFAE7,	// d(3,1)
		IIR2_D32_ADDR, 0x3D4D,	// d(3,2)
		IIR2_N31_ADDR, 0x10D9,	// n(3,1)
		IIR2_N32_ADDR, 0x086C,	// n(3,2)
		IIR2_N30_ADDR, 0x086C	  // n(3,0)
	};

	G(dp_fax_status) = G(dp_fax_status) & ~ENABLE_FAX_CI_DETECT;

	dp_write_dsp_ram (IIR1_THRESHOLD_ADDR, 43);                         // Detect threshold @ -43 dbm
	dp_write_dsp_block (ch1_tab, sizeof(ch1_tab)/(2*sizeof(word)) );    // Load filter coefficients into DSP

	dp_write_dsp_ram (IIR2_THRESHOLD_ADDR, 43);                         // Detect threshold @ -43 dbm
	dp_write_dsp_block (ch2_tab, sizeof(ch2_tab)/(2*sizeof(word)) );    // Load filter coefficients into DSP

	dp_modem_command (DETECT_TONES, 2, 0);	                            // Start bandpass filters
	G(dp_state) = DP_V34FAX_LOOK_FOR_CI;
}
#endif

/****************************************************************
Routine: dp_psd_chk
Description: returns 0 if no parallel set offhook was detected
*****************************************************************/
byte dp_psd_chk(void)
{
	short temp;

	// enable ring detection
	dp_modem_command(GOTO_CMD,PERSEUS_BASE,PERSEUS_RING_EN);
	// enable parallel set detection
	dp_modem_command(GOTO_CMD, PERSEUS_BASE, PERSEUS_PSD_EN);

	// disable parallel set detection
	dp_modem_command(GOTO_CMD, PERSEUS_BASE, PERSEUS_PSD_DIS);
	x_sleep(30); // allow circuit to settle value
	temp = dp_read_dsp_ram(0x19f2 + DP_PERSEUS_RAM_OFFSET);
	x_debug_msg("dp_psd_chk() value=");
	sendHexWord(temp);
	sendCrLf();
	if (temp > 0x5000)
	{
		return 1;
	}
	return 0;
}

/****************************************************************
Routine: dp_dsp_sptr_check
Description: check whether dsp is insane
*****************************************************************/
void dp_dsp_sptr_check(void)
{
	// read retrain state pointer of dsp - if it stays the
	// same for too long then disconnect
	if ((G(dp_wDspRetrainState) == dp_read_dsp_ram(S_PTR)) ||
		 (x_elapsed_time (G(dp_timer)) >= SECOND30))
	{
		word failTime = SECOND10;
		word s10Time = (word) (100 * G(S).ModemOptions.NoCarrierDisc);

		// Honor the S10 no carrier disconnect time
		// so we don't hang up too soon
		if ((G(S).ModemOptions.CountryId == NA) &&
			(s10Time > failTime))
		{
			failTime = s10Time;
		}

		if (x_elapsed_time(G(dp_timer1)) >= failTime)
		{
			if (G(dp_state) == DP_V34_RETRAIN)
			{
				x_debug_msg("DP_V34_RETRAIN failure");
				G(x_status).ud_TerminationCause = UD_TC_RETRAIN_FAIL;
			}
			else
			{
				x_debug_msg("DP_TRAINING failure");
				G(x_status).TerminationCause = 3;	// training failure
			}
			G(dp_state) = DP_CALL_FAILURE;
			G(x_dial_residual) = MR_CD_DISCONNECT;
		}
	}
	else
	{
		G(dp_wDspRetrainState) = dp_read_dsp_ram(S_PTR);
		G(dp_timer1) = x_current_time();
	}
}

/****************************************************************
Routine: dp_periodic_task
Description: The periodic routine for dp task.
*****************************************************************/
void dp_periodic_task(void) 
{
	word minutes1, delta;
	word minutes;
#if defined(V34_FAX)
	word wtemp;
#endif

	// In the serial modem we were seeing problems where autobauding
	// was seemingly coliding with dp_read_dsp_ram().  Whatever it was
	// was causing us to not respond to AT commands every once in a
	// while.  This 'if' statement is a band-aid for the problem, as
	// we don't really understand what's happening (yet).
#if defined(THUNDER) || defined(MODEM_ARM)
	if ((dte_modem_type != EXT_INTERFACE) || !AUTOBAUDING)
#elif defined(EXT_MODEM)
	if (!AUTOBAUDING)
#endif
	{
		// Vconstel goodies
		dp_echo_ram();
		dp_echo_trec();
		dp_echo_constellation();

		// fast rate change timer
		dp_monitor_frate_timer();	

		// update and print S-pointer, etc.
		dp_print_state_pointers();
	}

	// update minute counter 
	minutes = (word) x_elapsed_time_long(G(x_minute_timer_long));
	if (minutes >= MINUTE1)
	{
		minutes1 = (word)(minutes / MINUTE1);
		G(x_minute_count) = (word) (G(x_minute_count) + minutes1);
		delta = (word) (minutes - (MINUTE1*minutes1));
		G(x_minute_timer_long) = x_current_time_long() - delta;
		G(x_minute_timer) = (word) (x_current_time() - delta);
	}

#if defined(COPERNICUS)
	dp_copernicus_hangup();
#endif
#if defined(V92_MODEM_ON_HOLD)
	// if MOH is enabled, call MoH state machine
	if (G(S).ModemOptions.MHOptions & MH_ENABLED)
		dp_mh_bg();
#endif

	switch (G(dp_state))
	{
		case DP_IDLE:
			if (G(S).ModemOptions.HangupControl == 10)
			{
				/* Disable automatic hangup control for nextime */
				G(S).ModemOptions.HangupControl = 0;
				x_send_mail(IO_INACTIVITY_STATE, IO_TASK, NULL, 0);
				G(dp_state) = DP_NULL;
				G(S).ModemOptions.VoiceLineSelection = 1;
				G(x_modem_state) = MS_OFFHOOK;
			}
			else
			{
				#if defined(COPERNICUS)
				if (G(dp_s37_changed))			
				{							
					G(S).ModemOptions.DialLineRate = 0; 
					G(dp_s37_changed) = 0;		
				}							
				G(vpcm_ratechange_count) = 0;
				#endif  // COPERNICUS

				G(dp_dialing_status) = DP_INITIAL_DIAL;
				G(S).ModemOptions.RingCount = 0;  // initialize rings detected
				G(dp_state) = DP_WAIT_FOR_RING;
				G(dp_ring_int) = FALSE;
				G(dp_count) = 0;
				G(dp_ring_int_count) = 0;
				G(dp_calling_tone_disable) = FALSE;
				G(dp_timer1) = x_current_time();
				G(dp_threshold) = G(S).ModemOptions.DialToneThreshold;
				dp_enable_ring_int();

                if (G(dp_daa_is_perseus))
                {
				    dp_invalid_count = 0;  
                }
			}
			break;

		case DP_WAIT_FOR_RING:
#if defined(COPERNICUS)
			dp_copernicus_ring();
#elif defined(SA_CIRCULAR_BUFFER_HOST)
			sa_boardwalk_ring();
#else
#if defined(HOMOL) && defined(VOICE)
#ifdef	CALLER_ID
			if ((G(S).ModemOptions.CallerId)      // CID enabled
				 && ((G(S).ModemOptions.CallerIdType == 1) // detect pol rev
				 || (G(S).ModemOptions.CallerIdType == 2))  //UK (SIN 242)
				 && (G(dp_polarity_int) == TRUE))  // polarity reversed
			{
				G(dp_polarity_int) = FALSE;
				if ((G(S).ModemOptions.SleepModeTimer) &&
					 (G(dp_sleep) == TRUE))
					dp_init_modem();  // initialize data pump - wakeup mode
				x_send_mail(IO_IDLE_STATE, IO_TASK, NULL, 0);
				dp_cid_alert_init();
				G(x_modem_state) = MS_RING_INDICATE;
				G(dp_timer) = x_current_time();
				G(dp_state) = DP_CID_ALERT;
				break;
			}
#endif	//CALLER_ID
#endif	// HOMOL && VOICE

			if (G(dp_ring_int) == TRUE)
			{
				x_debug_msg("DP-periodic sees dp_ring_int");
				#if defined(MODEM_ARM)
				// added from the dp_dsp_isr
				if (G(dp_daa_is_perseus))
				{
					// DSP RAM 0x3A bit 5 set on ring
					dp_modem_command(GOTO_CMD, PERSEUS_BASE, PERSEUS_RING_EN);
				}
				#endif // MODEM_ARM
				if (G(S).ModemOptions.SleepModeTimer &&
					(G(dp_sleep) == TRUE))
				{
					dp_init_modem();  // initialize data pump - wakeup mode
				}
				x_send_mail(IO_IDLE_STATE, IO_TASK, NULL, 0);
				G(dp_state) = DP_RING_INIT;
				G(dp_timer) = x_current_time();
				G(dp_dialing_status) = DP_SUBSEQUENT_DIAL; //for ans with ATD
			}
#ifdef DC0
			else if (G(cell_ring_int) == TRUE)
			{
				x_debug_msg("DP - cell ring interrupt");
				if (G(S).ModemOptions.SleepModeTimer)
					dp_init_modem();  // initialize data pump - wakeup mode
				x_send_mail(IO_IDLE_STATE, IO_TASK, NULL, 0);
				G(dp_state) = DP_CELL_RING_ON;
				x_send_mail(DP_RING, AT_TASK, NULL, 0);
				G(S).ModemOptions.RingCount = 1;  
				G(dp_timer) = G(dp_timer1) = x_current_time();
			}
#endif // DC0
#ifdef VOICE
			// Local phone hook condition detection in voice mode.
			// Important to place this after (G(dp_ring_int) == TRUE)
			// block above since G(dp_local_phone_timer) is reset
			// there.
			else if ((G(x_modem_mode) == MODEM_VOICE) &&
				 (dp_local_phone_detect() == TRUE))
			{
				G(dp_state) = DP_LOCAL_PHONE_INIT;
			}
#endif  // VOICE
#ifdef HOMOL
			if (G(S).ModemOptions.BlackListFlag) 
				dp_blacklist_periodic();
#endif // HOMOL
#endif // COPERNICUS
			break;

		case DP_RING_INIT:
			// look for ring - read dsp status ram location for true ring
			if (dp_ring_detected())
			{
				G(dp_timer) = G(dp_timer1) = x_current_time();
				G(dp_state) = DP_RING_ON;
				G(x_modem_state) = MS_RING_INDICATE;
#ifdef VOICE
				if ((G(S).ModemOptions.DistinctiveRing != 0)
					 || (G(S).ModemOptions.SynRingFreq != 0))
				{
					dp_voice_ring_init();
				}
#endif

#if defined(SDR_RING_DETECT)
				if (G(SDR_Ring_Select) != 0)
				{
					dp_sdr_ring_init();
				}
#endif
				x_debug_msg("Real ring detected");
			}
			else
			{
#ifdef VOICE
				// local phone hook condition detection in voice mode
				if (G(x_modem_mode) == MODEM_VOICE) 
					dp_local_phone_detect();
#endif
				if (x_elapsed_time (G(dp_timer)) >= MS500 )
				{
					G(dp_state) = DP_IDLE;
					G(x_modem_state) = MS_IDLE;
				}
			}

			break;

		case DP_RING_OFF:
#ifdef VOICE
			if ((G(S).ModemOptions.DistinctiveRing != 0)
				 || (G(S).ModemOptions.SynRingFreq!= 0))
			{
				dp_voice_ring();
			}
#endif

#if defined(SDR_RING_DETECT)
			if (G(SDR_Ring_Select) != 0)
				dp_sdr_ring();
#endif

			if (!dp_ring_detected())
			{
				// check for min ring off period
				if (x_elapsed_time (G(dp_timer1))
					 >= (word)(20 * G(S).ModemOptions.RingCadenceOff))
				{
					G(S).ModemOptions.RingCount++; // inc. rings detected
#ifdef VOICE
					if ((G(S).ModemOptions.DistinctiveRing == 0) ||
						((G(S).ModemOptions.VoiceEventMask &
						  EVENT_DISTINCTIVE_RING) == 0))
#endif // VOICE
					{

#if defined(SDR_RING_DETECT)
						if (G(SDR_Ring_Select) != 0)
							dp_sdr_report();
						else
#endif
						{
							x_send_mail(DP_RING, AT_TASK, NULL, 0);
						}

                        if (G(dp_daa_is_perseus))
                        {
						    // RING was detected, enable again
						    dp_enable_ring_int();
                        }
					}
#ifdef VOICE
#ifdef CALLER_ID
					if ((G(S).ModemOptions.VoiceEventMask & EVENT_CALLER_ID) &&
						 (G(S).ModemOptions.CallerId) && 
#ifdef HOMOL
						 (G(S).ModemOptions.CallerIdType == 0) &&
#endif // HOMOL
						 (G(S).ModemOptions.RingCount == 1))    
					{
						if ((G(S).ModemOptions.DistinctiveRing != 0)
							 || (G(S).ModemOptions.SynRingFreq!= 0))
						{
							dp_voice_ring();
						}
						dp_cid_cmd();
#if defined(SDR_RING_DETECT)
						if (G(SDR_Ring_Select) != 0)
							dp_sdr_report();
						else
#endif
							x_send_mail(DP_RING, IO_TASK, NULL, 0);
						G(dp_state) = DP_NULL;
					}
					else
#endif	//CALLER_ID
#endif  // VOICE
					{
						G(dp_state) = DP_RING_ON;
						if ((G(S).ModemOptions.AutoAnswer) &&
							 (G(S).ModemOptions.RingCount
							  >= G(S).ModemOptions.AutoAnswer) &&
							 !UART_dtr_blocked())
						{
							// auto answer
							G(x_modem_state) = MS_ANSWERING;
							G(dp_state) = DP_ANSWERING;
						}
					}
					UART_ri_off();
					G(dp_timer) = G(dp_timer1) = x_current_time();
				}
			}
			else	// ring detected w/ short off time.
			{
				G(dp_timer1) = x_current_time();
			}

			break;

		case DP_RING_ON:
#ifdef VOICE
			if ((G(S).ModemOptions.DistinctiveRing != 0)
			   || (G(S).ModemOptions.SynRingFreq!= 0))
				dp_voice_ring();
#endif

#if defined(SDR_RING_DETECT)
			if (G(SDR_Ring_Select) != 0)
				dp_sdr_ring();
#endif

			if (dp_ring_detected())
			{
				G(dp_timer) = x_current_time();
			}
			else
			{
#ifdef VOICE
				// local phone hook condition detection in voice mode
				if (G(x_modem_mode) == MODEM_VOICE) 
					 dp_local_phone_detect();
#endif
				delta = x_elapsed_time(G(dp_timer1));
				G(dp_timer1) = x_current_time();

#if defined(VOICE) && defined(HOMOL)
#ifdef CALLER_ID
				// French Caller ID
				if ((G(S).ModemOptions.CountryId == FRANCE)
					&& (G(S).ModemOptions.VoiceEventMask & EVENT_CALLER_ID)
					&& G(S).ModemOptions.CallerId
					&& (G(S).ModemOptions.RingCount == 0)
					&& (delta > 175) && (delta < 325))
				{
					// Accept French Caller ID
					dp_cid_cmd();

					// set up IO to parse CID info
#if defined(SDR_RING_DETECT)
					if (G(SDR_Ring_Select) != 0)
						dp_sdr_report();
					else
#endif
						x_send_mail(DP_RING, IO_TASK, NULL, 0);

					// wait for IO to get us out of this state
					// with CALLER_ID_END command
					G(dp_state) = DP_NULL;
				}
#endif	//CALLER_ID
#endif // VOICE && HOMOL

				if ((delta >= (word) 10*G(S).ModemOptions.RingCadenceOn) &&
					(delta <= SECOND5))
				{
					if ((G(S).ModemOptions.CountryId == JAPAN) &&
						(delta > MS400) && (delta < MS600))
					{
						G(dp_timer1) = x_current_time();
						break;
					}

					G(dp_timer) = x_current_time();
					G(dp_state) = DP_RING_OFF;
#if defined(SDR_RING_DETECT)
					if (G(SDR_Ring_Select) != 0)
					{
						if (G(sdr_ring_valid) != 0)
						{
							x_debug_msg("RI ON");
							UART_ri_on();
						}
					}
					else	// SDR not active...do normal RI
#endif
					{
						UART_ri_on();
					}
				}

				if (x_elapsed_time(G(dp_timer)) >= 
					(100 * (word)G(S).ModemOptions.RingCountNullDelay))
				{
					G(dp_state) = DP_IDLE;
					G(x_modem_state) = MS_IDLE;
					UART_ri_off();
				}
			}
			break;

#ifdef DC0
		case DP_CELL_RING_OFF:
			if (x_elapsed_time(G(dp_timer)) > SECOND10 + SECOND4)
			{
				G(cell_ring_int) = FALSE;
				G(dp_state) = DP_IDLE;
			}
			break;

		case DP_CELL_RING_ON:
			if (G(S).ModemOptions.AutoAnswer
				&& (G(S).ModemOptions.RingCount >=
					G(S).ModemOptions.AutoAnswer))
			{
				G(x_modem_state) = MS_ANSWERING;
				G(dp_state) = DP_ANSWERING;
				G(cell_ring_int) = TRUE;
			}
			else if (x_elapsed_time (G(dp_timer)) >= SECOND4)
			{
				if (G(cell_ring_int) == TRUE)
				{
					G(dp_timer) = x_current_time();
					G(S).ModemOptions.RingCount++; 
					x_send_mail(DP_RING, AT_TASK, NULL, 0);
				}
				else
					G(dp_state) = DP_IDLE;
			}
			else if (G(S).ModemOptions.RingCount >= 10)
			{
				G(cell_ring_int) = FALSE;
				G(dp_state) = DP_IDLE;
			}
			break;
#endif // DC0

		case DP_DIAL:
			// Dialing, got to this state with MC_DIAL command.
			// It's up to the logic in dp_dial() to get us
			// through the dial string found in dp_dial_string[].
			switch (dp_dial())
			{
			case DIAL_RETURN_OK:	// continue dialing
				break;

			case DIAL_RETURN_IDLE:		// continue in command mode
#ifdef V8BIS
				if (G(S).ModemOptions.V8bis == V8BIS_DTE_CONTROL)
					G(dp_state) = DP_NULL;
				else
#endif	//V8BIS
					G(dp_state) = DP_WAIT_V8_ANSWER;
				break;

			case DIAL_RETURN_NULL:		// done dialing (successfully)
#ifdef VPCM_CLIENT
#ifdef QUICK_CONNECT_TIME_DEBUG
				x_debug_msg("\r\n***done dialing");
#endif	// QUICK_CONNECT_TIME_DEBUG

				if ((MODEM_VOICE != G(x_modem_mode)) &&
					(MODEM_SPEAKER_PHONE != G(x_modem_mode)) &&
					(G(S).ModemOptions.VpcmOption))
				{
					// Download V.90 code.
					vpcm_download_client();
				}
#endif	//VPCM_CLIENT
				G(dp_timer) = x_current_time();
				G(dp_threshold) = G(S).ModemOptions.CallProgressThreshold;   
				G(dp_state) = DP_CALL_PROGRESS;
				x_set_current_time (&G(dp_long_timer));
				/* turn on speaker after dialing */
				if (G(S).ModemOptions.SpeakerControl == 3)
					x_output(IO_SPEAKER_ON);
				break;

			case DIAL_RETURN_FAILURE:
				G(dp_state) = DP_CALL_FAILURE; // dialing has failed
				break;
			}
			break;

		case DP_CALL_PROGRESS:
			// Originate mode - dialing was successful.
			if (G(x_modem_mode) == MODEM_FAX)		// fax mode (V.17 or V.34)
			{
				DP_DOWNLOAD_GLITCHLESS_IDLE();	// DSP workaround for CS_DIGITAL

				dp_ringback_init();
				dp_fax_cng_tone_cmd();
				G(dp_state) = DP_FAX_CNG_TONE;
				G(dp_timer1) = x_current_time();
			}
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			else if (G(x_modem_mode) == MODEM_SPEAKER_PHONE)
			{
				G(x_modem_state) = MS_OFFHOOK;
				if ((dp_read_dsp_ram(FDSP_CNTRL_ADDR) & 0x4000) == 0)// in hdsp
				{
					// turn on the tone detectors
					dp_write_dsp_ram(0x85, 0x9205);
					dp_ringback_init();
				}
				else
					dp_write_dsp_ram(0x85, 0x1205);

				if (dp_local_phone_detect()== FALSE) // on-hook
				{
					//speaker agc threshold
					dp_write_dsp_ram(SPKR_THRESHOLD_ADDR, 0x40);
					G(dp_state) = DP_SPEAKER_PHONE_HDX; 
				}
				else
				{
					G(dp_state) = DP_SPEAKER_PHONE_WAIT;
				}
				x_send_mail(AT_OK, AT_TASK, NULL, 0);
			}
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			else if (G(x_modem_mode) == MODEM_VOICE)
			{
				if ((G(dp_dial_string)[0] == 0)
					 || (((G(dp_dial_string)[0] == 'T')
						  ||(G(dp_dial_string)[0] == 'P'))
						 && (G(dp_dial_string)[1] == 0)))
				{
					G(S).ModemOptions.VoiceLineSelection = 1;
					G(x_modem_state) = MS_TAD_FAR;
					dp_start_tad(TAD_IDLE);
					G(dp_state) = DP_VOICE;
					x_send_mail(AT_OK, AT_TASK, NULL, 0);
					G(dp_timer) = x_current_time();
				}
				else
				{
					dp_detect_tones_cmd();
					dp_ringback_init();
					G(dp_state) = DP_RINGBACK;
					G(dp_timer1) = x_current_time();
				}
			}
#endif  // VOICE
			else /* data mode */
			{
				// download V32bis turbo1, turbo2, turbo3 code not in ROM
				dp_download_V32Turbo();

				if (G(S).ModemOptions.DataCallingTone	// s35=1
					&& !G(dp_calling_tone_disable))		// '^' disabled
				{
					dp_detect_tones_cmd();
					dp_ringback_init();
					x_debug_msg("DP - xmiting calling tone");
					dp_calling_tone_cmd();
					if (G(S).ModemOptions.V42 == V42_SYNC_BUFFERED) 
						G(dp_state) = DP_DATA_CALL_TONE;
					else
						G(dp_state) = DP_ANSWERTONE;
				}
				else    
				{
					// Not sending data calling tone.
					dp_detect_tones_cmd();
					dp_ringback_init();
					x_debug_msg("DP - going to detect answertone");
					G(dp_state) = DP_ANSWERTONE;
				}
				G(dp_timer1) = x_current_time();
			}
			break;

#ifdef VOICE
		case DP_RINGBACK:
			if (dp_ringback_detected()== TRUE)
			{
				G(S).ModemOptions.VoiceLineSelection = 1;
				G(x_modem_state) = MS_TAD_FAR;
				dp_start_tad(TAD_IDLE);
				G(dp_state) = DP_VOICE;
				x_send_mail(AT_OK, AT_TASK, NULL, 0);
				G(dp_timer) = x_current_time();
			}
			else if ((G(S).ModemOptions.BusyToneDetect) &&
					  (dp_busy_tone_detected()== TRUE)) 
			{
				G(dp_state) = DP_CALL_FAILURE;
				G(x_dial_residual) = MR_BUSY_SIGNAL;
			}
			else if (x_elapsed_long_time(G(dp_long_timer)) >=
							(10 * (word)G(S).ModemOptions.NoAnsTimeOut))
			{
				x_debug_msg("DP - no answer");
				G(dp_state) = DP_CALL_FAILURE;
				G(x_dial_residual) = MR_NO_ANSWER_TONE;
			}
			break;
#endif
		case DP_DATA_CALL_TONE:                
			if (x_elapsed_time (G(dp_timer1)) >= MS600)
			{
				dp_detect_tones_cmd();
				G(dp_state) = DP_ANSWERTONE;
				G(dp_timer1) = x_current_time();
			}
			break;

		case DP_ANSWERTONE:
			// We are originating modem waiting for answer tone.
			if (G(dp_ringback_cycles) == 0)
			{
				 dp_ringback_detected();
			}
			if ((((G(S).ModemOptions.DataCallingTone == 0)
				  || (G(S).ModemOptions.V42 == V42_SYNC_BUFFERED))
				 && (dp_answer_tone_detected()== TRUE))
				||
				((x_elapsed_time (G(dp_timer1)) >= MS600)
				  && (dp_answer_tone_detected()== TRUE)))
			{
				x_debug_msg("DP - answer tone detected");
#ifdef QUICK_CONNECT_TIME_DEBUG
				x_debug_msg("\r\n***dp_time_to_connect_time=");
				dp_puts_dec(x_elapsed_time(G(dp_time_to_connect_timer)));
				sendCrLf();
#endif	// QUICK_CONNECT_TIME_DEBUG

				dp_originate_cmd();
#ifdef HOMOL
				dp_update_blacklist(G(dp_dial_string), DP_SUCCESS);
#endif
			}
			else if (G(S).ModemOptions.BusyToneDetect &&
					 (dp_busy_tone_detected()== TRUE))
			{
				G(dp_state) = DP_CALL_FAILURE;
				G(x_dial_residual) = MR_BUSY_SIGNAL;
#ifdef HOMOL
				dp_update_blacklist(G(dp_dial_string), TROUBLE);
#endif
			}
			else if (x_elapsed_long_time(G(dp_long_timer)) >= 
					 (10 * (word)G(S).ModemOptions.NoAnsTimeOut))
			{
				x_debug_msg("DP - no answer tone");
				G(x_status).TerminationCause = 2;	// no answer tone
#if defined(V80)
				dp_v8_orig_no_ans_msg();
#endif //v80
				G(dp_state) = DP_CALL_FAILURE;
				G(x_dial_residual) = MR_CD_DISCONNECT;
#ifdef HOMOL
				if (G(dp_ringback_cycles) > 0)   // ring back detected
				{
					dp_update_blacklist(G(dp_dial_string), ERRONEOUS);
				}
				else
				{
					dp_update_blacklist(G(dp_dial_string), TROUBLE);
				}
#endif
			}
#if defined (V8BIS)
			else if ((v8bis_datacall_dualtones_detect() == TRUE)
					 || (G(S).ModemOptions.Rate56K == 250))
			{
				// set s38 = 250 to skip v8bis for 56k testing
				x_debug_msg("dp - detected V.8bis dual tones");
				if (dp_v8bis_originate() == FALSE)
				{
					// stay in same state to detect answer tone
					// need to setup tone detector again
					dp_detect_tones_cmd();
				}
#ifdef QUICK_CONNECT_TIME_DEBUG
				else
				{
					x_debug_msg("\r\n***dp_time_to_connect_time=");
					dp_puts_dec(x_elapsed_time(G(dp_time_to_connect_timer)));
					sendCrLf();
				}
#endif	// QUICK_CONNECT_TIME_DEBUG
			}
#endif	//V8BIS
#if defined(V80)
			else if ((((G(S).ModemOptions.V42 == V42_SYNC_BUFFERED)
						&& (G(S).ModemOptions.DataCallingTone))
					)
					&& (x_elapsed_time (G(dp_timer1)) >= SECOND2))
			{
					x_debug_msg("DP - xmiting calling tone");
					dp_calling_tone_cmd();
					G(dp_state) = DP_DATA_CALL_TONE;
					G(dp_timer1) = x_current_time();
			}
#endif // V80
			else if (x_elapsed_time (G(dp_timer1)) >= SECOND2_6)
			{
				// if data calling tone (or) v.8 ci tone
				if (G(S).ModemOptions.DataCallingTone		  // s35=1
					&& (G(dp_calling_tone_disable) == FALSE)) // '^' disabled
				{
					x_debug_msg("DP - xmiting calling tone");
					dp_calling_tone_cmd();
					G(dp_timer1) = x_current_time();
				}
			}
			break;

		case DP_ANSWERING:
			// Answering modem:  usually get here from MC_ANSWER cmd.
			// download V.32bis turbo1, turbo2, turbo3 code not in ROM
			dp_download_V32Turbo();
#ifdef DC0
			cell_answer(); // if direct connect, send response.
#endif
#if defined(PERSEUS_PSD)
            if (G(dp_daa_is_perseus))
            {
			    if (dp_psd_chk())
			    {
				    G(dp_state) = DP_CALL_FAILURE;
				    // user action aborted call
				    G(x_status).ud_TerminationCause = UD_TC_ANY_KEY_ABORT;
				    G(x_dial_residual) = MR_CD_DISCONNECT;
				    break;
			    }
            }
#endif // PERSEUS_PSD
			dp_offhook_cmd();
			G(x_modem_originate) = FALSE;
			UART_ri_off();
			// Start billing delay timer here, do auto-answer &
			// billing delay in parallel
			G(dp_timer) = x_current_time();
			dp_init_cng_detect();		          // Start CNG detect if enabled
			G(dp_state) = DP_AUTO_ANSWER;
			break;

		case DP_AUTO_ANSWER:
			if (!dp_look_4_cng())    // Still looking for CNG tone?
			{
				// Wait up to 10 seconds for any carrier
				if (x_elapsed_time (G(dp_timer)) >= 10000)
				{
					G(dp_state) = DP_CALL_FAILURE;
					G(x_dial_residual) = MR_CD_DISCONNECT;
				}

				break;	// Wait until call type (FAX/DATA) is determined
			}
			if (G(x_modem_mode) == MODEM_FAX) // fax mode
			{
				// Initialize V.21 Rx threshold to 0
				G(dp_v21_rx_thresh) = 0x0000;
				DP_DOWNLOAD_GLITCHLESS_IDLE();	// DSP workaround for CS_DIGITAL
#if defined(V34_FAX)
				set_fax_modulation(); // Set mod. for Class 2/2.0/2.1 FAX

				if (NON_V34 != G(x_fax_v34mode)) // V.34 fax mode
				{
					// look for abort
					x_send_mail(DP_IO_DIAL_OR_ANSWER, IO_TASK, NULL, 0);
					G(dp_state) = DP_DATA_WAIT;
					x_set_current_time (&G(dp_long_timer));
				}
				else	// V.17 Fax...continue as usual
#endif // V34_FAX
					G(dp_state) = DP_FAX_WAIT;
			}
#ifdef VOICE
			else if (G(x_modem_mode) == MODEM_VOICE)
			{
				G(S).ModemOptions.VoiceLineSelection = 1;
				G(x_modem_state) = MS_TAD_FAR;
				dp_start_tad(TAD_IDLE);
				G(dp_state) = DP_VOICE;
				x_send_mail(AT_OK, AT_TASK, NULL, 0);
			}
#endif
			else    // data mode
			{
				x_send_mail(DP_IO_DIAL_OR_ANSWER, IO_TASK, NULL, 0);
				G(dp_state) = DP_DATA_WAIT;
				x_set_current_time (&G(dp_long_timer));
			}
			break;

		case DP_DATA_WAIT:
			// Answering modem - wait, then send answer tone, etc.
			if ((x_elapsed_time(G(dp_timer)) >= SECOND2)
				|| (G(S).ModemOptions.bV34Enable == 0))
			{
#if defined(V8BIS) && defined(VENUS_AT_CS)
				if (dp_v8bis_answer() == TRUE)
				{
					// This is the normal path for
					// central site with K56FLEX enabled.
					G(dp_state) = DP_V8BIS_DCE_ANS;
				}
				else
#endif	//V8BIS
				{
					#ifdef VPCM_CLIENT	
					if (G(S).ModemOptions.Rate56K
						#if defined(V34_FAX)
						&& NON_V34 == G(x_fax_v34mode)
						#endif
						&& (G(S).ModemOptions.VpcmOption & BIT1))
					{
						x_debug_msg("DP - vpcm set answering mode");
						vpcm_set_answering_mode();
						vpcm_startup();
						G(dp_state) = DP_56K;
					}
					else
					#endif	//VPCM_CLIENT
					#if defined(V34_FAX)
					if (NON_V34 != G(x_fax_v34mode))	// V.34 Fax mode
					{
						x_debug_msg("dp-V34Fax Ans");
						// wait for CM startup
						G(dp_fax_status) = ENABLE_FAX_CI_DETECT;  // Look for CI if fallback to non-V34 modulation
						G(dp_state) = DP_V34FAX_ANS_DELAY;
						G(dp_timer) = x_current_time();
					}
					else
					#endif // V34_FAX
					{
						#if	defined(CS_DIGITAL)
						if (G(S).ModemOptions.Rate56K == 0)
						{
							dp_download_monitor_nc_gain(0xdc00);
						}
						#endif	// CS_DIGITAL
						dp_answer_cmd();
						x_debug_msg("dp- send answer tone");
					}
				}
			}
			break;

		case DP_RETRAIN_START:
			// User has requested a retrain with ato1 or ato3.
			if (x_elapsed_time (G(dp_timer)) >= MS100)
			{
				 // in case we did not catch the retrain state for fast rate
				 // renegotiation, go back to ON_DIAL after 100 ms 
				G(dp_state) = DP_RETRAIN; 
				G(dp_bV34WkState) = WRK_RETRAIN; //retrain wkarnd state. 
			}
			/* 
			 * need this line here to make sure that we have the correct
			 * G(dp_dsp_status) for the next state
			 */
			G(dp_dsp_status) = dp_regread (DP_STATUS_REG);

			G(dp_line_state) = DP_LINE_RETRAINING;
			break;

		case DP_RETRAIN:
			// User has requested a retrain with ato1 or ato3.
			dp_v34_workaround();
			G(dp_dsp_status) = dp_regread(DP_STATUS_REG);
			if (dp_retrain() == FALSE)
			{
				// retrain finished
				G(dp_state) = DP_RETRAIN_OVER;
				G(dp_count) = 1;
				G(dp_timer) = x_current_time();
			}
			else if (x_elapsed_time (G(dp_timer)) >= SECOND30) 
			{
				x_debug_msg("DP_RETRAIN failure");
				G(dp_state) = DP_CALL_FAILURE;
				G(x_status).ud_TerminationCause = UD_TC_RETRAIN_FAIL;
				G(x_dial_residual) = MR_CD_DISCONNECT;
			}
			break;

#if defined(V34_FAX) // {
		case DP_V34FAX_ANS_WAIT:	// wait for correct answer tone

			wtemp = dp_read_dsp_ram(0x0831);	// get tone detect status

			if (wtemp == 0x01)			// ANSam tone
			{
				x_debug_msg("ANSam Detected");
				at_v25a8a_ind(0x01);	// Report ANSam detection
				G(dp_state) = DP_V34FAX_V8WAIT;
				G(dp_timer1) = x_current_time();	// for debug timer
				G(dp_timer) = x_current_time();
			}
			else if (wtemp == 0x02)	// CED tone
			{
					// start V.17 fax recv to get DIS
				x_debug_msg("CED Detected");
				at_v25a8a_ind(0x02);		// Report CED detection
				dp_v34fax_to_v17rx();		// get ready to rcv 300bps.
			}
			else if (x_elapsed_time(G(dp_timer)) > 10000)	// timeout
			{
				G(dp_state) = DP_CALL_FAILURE;
			}
			break;

		case DP_V34FAX_ANS_DELAY:	// wait before sending ANSam
			if (x_elapsed_time(G(dp_timer)) > 1000)
			{
				dp_write_dsp_ram(0x1fd9, 0x0);	// detect ANSam mode
				dp_v34fax_ans();					// start v34 answer
				G(dp_state) = DP_V34FAX_CMWAIT;		// wait for CM/JM exchange
				G(dp_timer) = x_current_time();
				G(dp_timer1) = x_current_time();	// for debug timer
			}
			break;

		case DP_V34FAX_CMWAIT:	// started ANSam generation...wait for CM
								// DP has a .2 second startup delay for ANSam.
								// Send 5 seconds of ANSam (V.8 s8.2.2).
			if (x_elapsed_time(G(dp_timer)) > (5200))
			{
				x_debug_msg("\n\rNo V8.\n\r");
				dp_v34fax_to_v17tx();	// get ready to send DIS.
			}
			else if (dp_read_dsp_ram(DSP_STATUS_RAM) & 0x8000) // V.8 Started
			{
				x_debug_msg("\n\rV8 Neg Start");
				G(dp_state) = DP_V34FAX_V8WAIT;
				G(dp_timer) = x_current_time();
			}
			break;

		case DP_V34FAX_V8WAIT:		// wait for V.8 Neg to complete
			wtemp = dp_read_dsp_ram(DP_V8_STATUS);	// get V8 status
			if (wtemp & 0x8000)	// bit 15 indicates v8 complete
			{
				x_debug_msg("\n\rV8 Complete=");
				sendHexWord(wtemp);
				sendCrLf();

				G(dp_state) = DP_V34FAX_PHASE3;	// assume we are V34 fax
				G(dp_timer) = x_current_time();

						// Determine final call function.
				G(x_fax_v34mode) = NON_V34;
				if ((wtemp & 0x0007) == 4) // Calling Terminal Transmits
				{
					G(x_fax_v34mode) =
						G(x_modem_originate) ? V34_SOURCE: V34_RECEIVE;
				}
				else if ((wtemp & 0x0007) == 5) // Calling Terminal Receives
				{
					G(x_fax_v34mode) =
						G(x_modem_originate) ? V34_RECEIVE: V34_SOURCE;
				}
				else
				{
					G(dp_state) = DP_CALL_FAILURE; // Bad Call Funct - Not Fax
				}

				if (G(x_fax_v34mode) != NON_V34)	// Call Funct OK...
				{			// check for V34 fax (or v17 fax)
					if ((wtemp & 0x00f0) != 0x0020)	// not V34 fax?
					{
						if (TRUE == G(x_modem_originate))
							dp_v34fax_to_v17rx();	// start V17 rcv to get DIS
						else
							dp_v34fax_to_v17tx();	// start V17 xmit to send DIS
					}
				}
				at_v25a8m_ind();	// echo V.8 option reg to DTE
			}

			else if (x_elapsed_time(G(dp_timer)) > 10000)	// 10 seconds (V.8 time-out?)
			{
				x_debug_msg("Fallback to non-V.34 FAX");

				if (TRUE == G(x_modem_originate))
					dp_v34fax_to_v17rx();	// Start V17 receive to get DIS

				else
					dp_v34fax_to_v17tx();	// Start V17 transmit to send DIS
			}

			break;

		case DP_V34FAX_PHASE3:
				// Phase3 was started in either dp_v34fax_orig() or
				// dp_v34fax_ans().  This state waits for the DSP to
				// complete phase 3 training as indicated by the ST flag.
				//
				// Answer Side: If no ST flag within 20s, abort the call.
			if (dp_read_dsp_ram(0x1fd8)) // short train flag
			{
				x_debug_msg("\r\nV34p3 End=");
				sendHexWord(x_elapsed_time(G(dp_timer)));
				sendCrLf();

				dp_download_v34p2();		// download Phase4 code
				dp_hdlc_mode();				// set for HDLC mode

				G(x_fax_v34channel) = CONTROL_CHANNEL;
				G(x_fax_train) = SHORT_TRAIN;		// default to STs
				G(x_fax_state) = FAX_IDLE;			// trigger CONNECT message
				G(dp_timer1) = x_current_time();	// debug
				G(dp_timer) = x_current_time();
				G(dp_state) = DP_V34FAX_DATAWAIT;
			}
			else if (x_elapsed_time(G(dp_timer)) > 20000)	// 20 seconds
			{
				// (This should never happen).
				// Note that all fallbacks from V34 Fax to V17 fax will
				// occur based on the V8 negotiation, above.  Once the
				// code gets to looking for the ST flag, we *are* V34 Fax.
				// A failure of ST flag is a total call failure.
				x_debug_msg("\r\nNo ST Flag...Phase 2 Failed!\r\n");
				G(dp_state) = DP_CALL_FAILURE; // Bad Call Funct - Not Fax
			}
			break;

		case DP_V34FAX_SEND_CI_WAIT:  // Silence before sending CI
			if (x_elapsed_time (G(dp_timer)) >= 1000)  // One second of silence?
			{
				v8_ci_orig ();                           // Startup V.21 and send CI
				G(dp_state) = DP_V34FAX_SEND_CI;         // Wait for data to be sent
				G(dp_timer) = x_current_time ();
			}

			break;

		case DP_V34FAX_SEND_CI:  // Wait for CI to clear DCE buffer before looking for ANSam
			if (!io_get_dce_queue_count () ||            // CI cleared DSP?
					(x_elapsed_time (G(dp_timer)) > 6000) )  // Waited long enough?
			{
//				x_debug_msg ("Look for ANSam");
				G(x_fax_v34mode) = V34_SOURCE;    // Enable V.34 FAX again
				dp_detect_tones_cmd () ;
				G(dp_state) = DP_V34FAX_RESTART_V8;
				G(dp_ringback_cycles) = 1;         // Disable ringback checking
				G(dp_timer1) = x_current_time () ; // Reset CNG timer (3 seconds)
				x_set_current_time ( &G(dp_long_timer) );  // Restart no-answer time-out
			}

			break;

		case DP_V34FAX_LOOK_FOR_CI:  // Look for either CI or T.30 signals
			if (dp_read_dsp_ram (0x003A) & 0x2000)         // V.21 Ch 2 (FAX)?
			{
//				x_debug_msg ("V.21 Ch 2 (FAX)");
				dp_v34fax_to_v17rx ();                       // Continue with non-V.34 FAX
				G(dp_timer) = x_current_time ();
			}

			else if (dp_read_dsp_ram (0x003A) & 0x1000)    // V.21 Ch 1 (CI)?
			{
//				x_debug_msg ("V.21 Ch 1 (CI)");
				v8_ci_ans_init ();                 // startup V.21 Ch 1
				G(dp_state) = DP_V34FAX_RECV_CI;
				G(dp_timer) = x_current_time ();
			}

			else if (x_elapsed_time (G(dp_timer)) > 3000)  // Nothing within 3 seconds
			{
				dp_v34fax_to_v17rx ();                       // Continue with non-V.34 FAX
				G(dp_timer) = x_current_time ();
			}

			break;

		case DP_V34FAX_RECV_CI:   // Look for a valid CI signal
			while (io_get_dce_rx_count ())    // For any characters received...
			{
				if (v8_ci_sequence_detected ())     // Receive and processed CI?
				{
					G(dp_state) = DP_V34FAX_GOT_CI;   // Now, wait for DTE to abort last command
					G(dp_timer) = x_current_time ();
					break;                            // Ignore remaining data in DCE Rx buffer
				}
			}

			if (x_elapsed_time (G(dp_timer)) > 3000)  // Nothing within 3 seconds
			{
				dp_v34fax_to_v17rx ();                       // Continue with non-V.34 FAX
				G(dp_timer) = x_current_time ();
			}

			break;

		case DP_V34FAX_GOT_CI:  // CI received and reported; wait for AT-command
			if (io_get_dte_rx_bytes ())       // Abort last AT command?
			{
				byte dummy;

				io_get_dte_rx_char (&dummy);                     // Read and discard "abort" character
				x_send_mail ( AT_OK, AT_TASK, NULL, 0);          // "OK" for abort
				x_send_mail ( IO_IDLE_STATE, IO_TASK, NULL, 0);  // Process AT-commands

				dp_fax_modem_idle_cmd();                         // Turn off pump
				G(io_dce_rx_rptr) = G(io_dce_rx_wptr);           // Flush DCE buffer
				G(dp_state) = DP_NULL;                           // Do nothing; wait for AT-command
			}

			if (x_elapsed_time (G(dp_timer)) > 3000)  // Nothing within 3 seconds
			{
				dp_v34fax_to_v17rx ();                       // Continue with non-V.34 FAX
				G(dp_timer) = x_current_time ();
			}

			break;

		case DP_V34FAX_TEST_ANSam:
			// V25_counter almost equal to 12?
			if (dp_read_dsp_ram(0x00B7) >= 10)
				dp_write_dsp_ram(0x00B7, 0);      // Reset to zero
			break;
#endif // } V34_FAX

		case DP_TRAINING:
			// We come here in answer or originate mode for V.34 and
			// below data.  Training in first time startup.  Connect
			// message has not been given yet.  STARTUP command has
			// already been given to the data pump.  We'll wait for
			// the data pump to connect or a time out.
			#if defined(SA_QMP_RX_PATCH)
			sa_dspInitQMP(V34_MODE);
			#endif

			if (dp_dial_connect_success() == TRUE)
			{
				G(dp_state) = DP_ON_DIAL;
				G(dp_line_state) = DP_LINE_CONNECTED;  // done with training
				G(x_modem_state) = MS_ON_DIAL;
				G(dp_timer1) = G(dp_timer) = x_current_time();
				x_send_mail(DP_IO_CONNECT, IO_TASK, NULL, 0);
#ifdef HOMOL
				dp_update_blacklist(G(dp_dial_string), DP_SUCCESS);
#endif
			}
			else if (x_elapsed_long_time(G(dp_long_timer)) >=
						  (10 * (word)G(S).ModemOptions.NoAnsTimeOut))
			{
				x_debug_msg("DP_TRAINING failure");
				G(x_status).TerminationCause = 3;	// training failure
				G(dp_state) = DP_CALL_FAILURE;
				G(x_dial_residual) = MR_CD_DISCONNECT;
			}
			dp_dsp_sptr_check();
			break;

		case DP_RETRAIN_OVER:
			// We get here from either DP_RETRAIN
			// or DP_V34_RETRAIN when we've made it
			// back into data mode.
		{
			byte old_dp_count = G(dp_count);
			dp_v34_workaround();
			if ((x_elapsed_time (G(dp_timer)) >= MS200)
				 && dp_init_modem_connection()
				)
			{
				// dp_init_modem_connection() cleared
				G(dp_count) = old_dp_count;

				dp_modem_rate();
				if (G(dp_count))
				{
					// Send CONNECT message (with potentially new line
					// rates) to DTE.
					dp_get_line_rate();
					x_send_mail(AT_IO_ON_LINE, IO_TASK, NULL, 0);
				}

				// send mail for io-sync mode - after line rate is set
				x_send_mail(DP_IO_RETRAIN_OVER, IO_TASK, NULL, 0);
				G(dp_state) = DP_ON_DIAL;
				G(dp_line_state) = DP_LINE_CONNECTED;
				x_debug_msg("dp - on-dial state");
			}
			else
			{
				G(dp_count) = old_dp_count;
			}
			break;
		}

		case DP_V34_RETRAIN:
			// V.34 retrain NOT initiated by the user.
			// Could be because remote side issued retrain
			// or because we're retraining due to line conditions.
#if	defined(COPERNICUS)
			dp_write_dsp_ram(AP_DPRAM_BAUD, CHK_VF_PP);
#endif	// COPERNICUS
			dp_v34_workaround();
			G(dp_dsp_status) = dp_regread(DP_STATUS_REG);
#if defined(CALL_WAITING)
			if (G(dp_CallWaitingEnable) != 2)
				dp_write_dsp_ram(BR_PTR,DSP_CW_INIT_V34); // re-init CW
#endif
			if (dp_retrain() == FALSE)
			{
				G(dp_timer) = x_current_time();
				G(dp_state) = DP_RETRAIN_OVER;
				G(dp_count) = 0;
			}
			else
				dp_dsp_sptr_check();
			break;

		case DP_ON_DIAL:
			// for Dragnet in polled mode - check for DSP I/O
			DP_CHKDSP();

#if !defined(CS_DIGITAL) && defined(COMPRESS_TABLES) && defined(CALL_WAITING)
			if (G(dp_CallWaitingEnable) != 2)
			{
				if (dp_check_call_waiting()) break;
			}
#endif

			// Fallback if there are too many lapm errors.
			if (dp_lapm_error_check())
			{
				// Receive side needs ratechange
#if defined(SA_DIGITAL)
				word reg, drate;

				// Turn off automatic bit rate selection...
				reg = dp_read_dsp_ram(V34_OPTIONS);		// 0x821
				reg |= BIT12;
				reg &= ~BIT3;
				dp_write_dsp_ram(V34_OPTIONS, reg);

				// ...and reduce received bitrate
				reg = dp_read_dsp_ram(MP_tx1);			// 0x80c
				drate = ((reg & 0x003c) >> 2);
				drate = (drate == 14) ? 12: drate-1;
				reg &= 0xffc3;
				reg |= (drate<<2);
				dp_write_dsp_ram(MP_tx1, reg);

				x_debug_msg("dp - slapping him back, too many CRC's");
				G(dp_line_state) = DP_LINE_RETRAINING;
				G(dp_state) = DP_V34_RETRAIN;
				G(dp_timer) = x_current_time();
				dp_modem_command (FAST_RATE_CHANGE, 0, 0);
#else
				G(dp_bFallForward) = 2; // indicates a local fallback.
				dp_rate_change_cmd(1);
#endif
				break;
			}

#if defined(COPERNICUS)
			if (dp_tx_lapm_error_check())
			{
				dp_lapm_error_check_init(); 
				// Fallback if there are too many lapm transmit errors.
				G(dp_cs_local_retrain_ratechange) = 1;
				G(dp_s37_changed) = 1;
				G(S).ModemOptions.DialLineRate =
					((dp_read_dsp_ram(DP_CUR_SPEED_LOC) & 0x1f00)>>8)+2;
				dp_fast_retrain_cmd();
				G(dp_state) = DP_V34_RETRAIN;
				G(dp_timer) = x_current_time();
				break;
			}
#endif //COPERNICUS
			if (x_elapsed_time (G(dp_timer)) >= MS500)
			{
				// normal periodic things we do while on dial.
				dp_modem_rate();
				if (dp_retrain() == TRUE)		// retraining??
				{
					// If we're in the middle of V.42 disconnect
					// then we'll assume that this retrain
					// isn't real.  Probably the other end hung
					// up on us before it acknowledged the DISC
					// command.
					if (lapm_disconnecting())
					{
						x_debug_msg("dp - retrain lapm_disconnecting()");
						G(dp_state) = DP_DISCONNECT;	// don't do cleardown
						x_send_mail_dp1(V42_LOCAL_DISC);
					}
					else
					{
						// disable v.80 dsp patch (or) any other dsp workaround
						dp_disable_workaround();
#ifdef DC0
						enable_cell_filter();
#endif
#if defined(COPERNICUS) || defined(SA_DIGITAL)
						if (G(dp_cs_local_retrain_ratechange))
						{
							LOCAL_RR_INCREMENT;
							G(dp_cs_local_retrain_ratechange) = 0;
						}
						else									
#endif
						{										
							// retrain 
							if (dp_read_dsp_ram(DSP_STATUS_RAM) & 0x2)
							{
								REMOTE_RET_INCREMENT;
								#if defined(CS_DIGITAL)
								// near canceller workaround
								dp_download_monitor_nc_gain(0xdc01);
								#endif // CS_DIGITAL
							}
							else
								REMOTE_RR_INCREMENT;
						}
						 //retrain wkarnd state.
						G(dp_bV34WkState) = WRK_RETRAIN;
						G(dp_count) = 1;
						G(dp_state) = DP_V34_RETRAIN;
						G(dp_line_state) = DP_LINE_RETRAINING;
						G(dp_timer1) = x_current_time();
						// send mail for io-sync mode - indicate retrain
						x_send_mail(DP_IO_RETRAIN_START, IO_TASK, NULL, 0);
						x_debug_msg("dp - retrain detected");
					}
				}
				else if (dp_carrier_loss() == TRUE)
				{
					if (lapm_disconnecting())
					{
						x_debug_msg("dp-assume remote disconnect(cl)");
						G(dp_state) = DP_DISCONNECT;	// don't do cleardown
						x_send_mail_dp1(V42_LOCAL_DISC);
					}
					else if (x_elapsed_time (G(dp_timer)) >= 
							  (100 * (word)G(S).ModemOptions.NoCarrierDisc))
					{
						x_debug_msg("dp - lost carrier");
						G(dp_state) = DP_CALL_FAILURE;
						G(x_status).ud_TerminationCause = UD_TC_NO_CARRIER;
						G(x_dial_residual) = MR_CD_DISCONNECT;
						G(x_status).TerminationCause = 1;	// remote terminate
					}
				}
				else
				{   
					if (G(S).ModemOptions.AutoRate == 1)
					{
						// Consider shifting rates up or down because
						// of good or bad MSE.
						dp_auto_rate();

						// If we have bad MSE and we're in the
						// middle of disconnecting then
						// it's likely that the remote end has
						// dropped the line.  Hang up.
						if (G(dp_count) && lapm_disconnecting())
						{
							x_debug_msg("dp-assume remote disconnect(mse)");
							G(dp_state) = DP_DISCONNECT; // don't do cleardown
							x_send_mail_dp1(V42_LOCAL_DISC);
						}
					}
					G(dp_timer) = x_current_time();
				}
			}
			break;

		case DP_CALL_FAILURE:
			G(dp_state) = DP_DISCONNECT;
			dp_onhook_cmd();
			G(dp_timer) = x_current_time();
			break;

		case DP_DISCONNECT:
#ifdef CLAUDIA
	#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
			if ((G(x_modem_mode) == MODEM_FAX)
				 && (G(x_modem_originate) == TRUE))
			{
				// Originated a FAX call
				// Wait for other side to hangup
				if (x_elapsed_time(G(dp_timer)) > 5000)
				{
					// Disconnect call
					t1_transmit_onhook(ModemNum);
				}

				else
					break;
			}
	#endif
#endif
			// before disconnecting, make sure at least one of the
			// following is true:
			//	- the line has dropped
			//	- not waiting for a cleardown and 50ms has elapsed
			//	- 1 second has elapsed since entering this state.
			if ((dp_line_connect() == FALSE)
				|| (!G(dp_cleardown_wait)
					 && x_elapsed_time(G(dp_timer)) > MS50)
				|| (x_elapsed_time(G(dp_timer)) > SECOND1))
			{
				/* do an on hook again to make sure the dsp did go to its
				idle state */
				G(dp_cleardown_wait) = FALSE;	// cleardown wait
				dp_onhook_cmd();
				G(x_modem_state) = MS_IDLE;
				G(dp_state) = DP_IDLE;
				x_send_mail(DP_IO_DISCONNECT, IO_TASK, NULL, 0);
			}
			break;

		case DP_FAX_CNG_TONE:
			if (x_elapsed_time (G(dp_timer1)) >= MS500)
			{
				dp_detect_tones_cmd();
				G(dp_state) = DP_FAX_ANSWER_TONE;
				G(dp_timer1) = x_current_time();
			}
			break;

		case DP_V34FAX_RESTART_V8:
		case DP_FAX_ANSWER_TONE:
			if (G(dp_ringback_cycles) == 0)
			{
				dp_ringback_detected();
			}

			if ((dp_answer_tone_detected()) == TRUE)
			{
				G(dp_v21_rx_thresh) = 0x0000;  // Initialize V.21 Rx threshold to 0
				G(x_status).ud_CallResult = UD_CS_ANSWER_TONE;
				x_debug_msg("DP - CED/answer tone detected");
#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
				set_t30_bit (TRUE);  // Indicate Orig. mode in T.30 commands
#endif
#if defined(V34_FAX)
				// Set modulation for Class 2/2.0/2.1 FAX
				set_fax_modulation();

				// Set for V.34 Fax mode?
				if ((NON_V34 != G(x_fax_v34mode))	&&
					 // V.21 Ch 2 Mark frequency detected?
					 (dp_read_dsp_ram(0x28) & 0x0010))
				{
					//x_debug_msg("DP - very old FAX!");
					G(x_fax_rate) = MR_300;			// Go to 300 bps V.21
					G(x_fax_state) = FAX_RX_HDLC;   // Receive V.21 HDLC
					// Fallback to V.33, V.17, V.29 or V.27
					G(x_fax_v34mode) = NON_V34;
				}

				if (NON_V34 != G(x_fax_v34mode))	// V.34 Fax Start-up
				{
					// The DP has detected some 2100Hz tone.
					// Start the V34 Orig to determine if it is
					// ANSam or CED.
					dp_write_dsp_ram(0x1fd9, 0x0);	// set ANSam detect mode
					dp_v34fax_orig();
					G(dp_state) = DP_V34FAX_ANS_WAIT;
				}
				else	// V.17 fax start-up
#endif	// V34_FAX
				{
					dp_fax_startup (0);
					G(dp_state) = DP_FAX_STARTUP_RX;
					// Ignore V.21 preamble dropouts
					G(dp_fax_status) = IGNORE_V21_PREAMBLE;
				}

#ifdef HOMOL
				dp_update_blacklist(G(dp_dial_string), DP_SUCCESS);
#endif
				G(dp_timer) = x_current_time();
			}
			else if ((G(S).ModemOptions.BusyToneDetect) &&
					  (dp_busy_tone_detected()== TRUE)) 
			{
				x_debug_msg("DP - busy tone detected");
				G(dp_state) = DP_CALL_FAILURE;
				G(x_dial_residual) = MR_BUSY_SIGNAL;
#ifdef HOMOL
				dp_update_blacklist(G(dp_dial_string), TROUBLE);
#endif
			}
			else if (x_elapsed_long_time(G(dp_long_timer)) >=
					 (10 * (word)G(S).ModemOptions.NoAnsTimeOut))
			{
#if defined(V34_FAX)
				// failed to detect ANS tone. report +A8A:0.
				at_v25a8a_ind(0x00);	// no answer tone detected
#endif
				x_debug_msg("DP - no answer tone");
				G(dp_state) = DP_CALL_FAILURE;
				G(x_dial_residual) = MR_CD_DISCONNECT;
#ifdef HOMOL
				if (G(dp_ringback_cycles) > 0)   // ring back detected
				{
					dp_update_blacklist(G(dp_dial_string), ERRONEOUS);
				}
				else
				{
					dp_update_blacklist(G(dp_dial_string), TROUBLE);
				}
#endif
			}
			/* the CNG off timer used to be 3.5sec */
			else if (x_elapsed_time (G(dp_timer1)) >= SECOND3)
			{
				if (G(dp_state) != DP_V34FAX_RESTART_V8)
				{ 
					dp_fax_cng_tone_cmd();
					G(dp_state) = DP_FAX_CNG_TONE;
				}

				G(dp_timer1) = x_current_time();
			}
			break;

		case DP_FAX_STARTUP_RX:         /* receive mode */
			if (dp_wrong_speed())       // Wrong data rate detected?
				break;                  // DP state is now idle

			if (dp_regread (DP_EIA_REGISTER) & 0x04)   // Carrier detected?
			{
				// Make rates identical; suppresses +FCERROR message
				G(x_line_rate) = G(x_fax_rate);
#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
				if (CLASS_2_OR_20)
				{
					// Make rates identical; suppresses +FCERROR message
					//G(x_line_rate) = G(x_fax_rate);
					G(dp_state) = DP_NULL;
				}

				else
#endif
					G(dp_state) = DP_FAX_RECEIVE;

				if (G(x_fax_rate) == MR_300)                          // V.21 Receive?
					G(dp_v21_rx_thresh) = dp_read_dsp_ram (0x5E) >> 2;  // Set V.21 threshold based on Rx level

				G(x_modem_state) = MS_ON_DIAL;
				// Send "CONNECT" to host
				x_send_mail(DP_IO_CONNECT, IO_TASK, NULL, 0);
				// Start timer for preamble delay
				G(dp_timer) = x_current_time();
			}

			else  // Waiting for carrier
			{
				word time_out = SECOND10;  // Class 1, not SPAIN
#ifdef HOMOL
				// Country code is SPAIN?
				if (G(S).ModemOptions.CountryId == SPAIN)
					time_out = 35000;                      // Use 35 seconds
#endif
#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
				if (CLASS_2_OR_20)		// Class 2/2.0/2.1 interface?
					time_out = 35000;	// Use 35 seconds (T.30 timer T1)
#endif
				// Time-out waiting for FAX HDLC flags?
				if (x_elapsed_time (G(dp_timer)) >= time_out)
				{
					x_debug_msg("DP - Time-out waiting for FAX HDLC flags");
					G(x_modem_state) = MS_ON_DIAL;
					G(x_dial_residual) = MR_CD_DISCONNECT;
					G(dp_state) = DP_NULL;
					x_send_mail(DP_IO_DISCONNECT, IO_TASK, NULL, 0);
				}
			}
			break;

		case DP_FAX_CONTINUE_RX:  // Continue to receive after carrier detected
			if (dp_wrong_speed())     // Modulation changes?
				break;                // Go to DP_IDLE state

			else
			{
				// Send "CONNECT" to host
				x_send_mail(DP_IO_CONNECT, IO_TASK, NULL, 0);
				// Monitor carrier gone
				G(dp_state) = DP_FAX_RECEIVE;
			}

			// ***** FALL THROUGH *****

		case DP_FAX_RECEIVE:
			if ( (G(dp_fax_status) & WAIT_FOR_FRH) ||           // Waiting for another +FRH command?
					 ( (G(dp_fax_status) & IGNORE_V21_PREAMBLE) &&  // Ignoring preamble and
						 (x_elapsed_time (G(dp_timer)) < 850)         //  delay has not expired?
					 )
				 )
				break;

			if (dp_fax_carrier_loss ())  // End of signal detected?
			{
				x_debug_msg("DP - fax lost carrier");
				dp_fax_modem_idle_cmd();
				G(dp_state) = DP_NULL;
				G(x_status).ud_TerminationCause = UD_TC_NO_CARRIER;
				G(x_dial_residual) = MR_CD_DISCONNECT;
				x_send_mail(DP_IO_FAX_CARRIER_LOSS, IO_TASK, NULL, 0);
			}
			// NOTE: dp_timer1 is used by dp_fax_carrier_loss()
			break;

		case DP_FAX_WAIT:
			// It's necessary to download FAX to the DSP at this point
			// so the time delay between CED and CSI/DIS doesn't exceed
			// 75ms, +/- 20ms, as required by ITU T.30.
			if (!G(dp_fax_downloaded))	// Need to download FAX to DSP?
			{
				dp_download_fax();		// Download FAX code to DSP
				// Don't download in dp_fax_startup()
				G(dp_fax_downloaded) = TRUE;
			}

			if (x_elapsed_time (G(dp_timer)) >= SECOND2)
			{
				dp_fax_ced_tone_cmd();
				G(dp_state) = DP_FAX_CED_TONE;
				G(dp_timer) = x_current_time();
			}
			break;

		case DP_FAX_CED_TONE:
			if (x_elapsed_time (G(dp_timer)) >= SECOND3)
			{
				x_debug_msg("DP - sent CED Tone for 3 seconds");

#if defined(CLASS2_FAX) || defined(CLASS20_FAX)  
				if (CLASS_2_OR_20)                        
					set_t30_bit(FALSE);	// Indicate Answer mode in T.30
#endif
					G(dp_state) = DP_FAX_CED_TONE_WAIT;

				dp_fax_modem_idle_cmd();
				G(dp_timer) = x_current_time();
			}
			break;

		case DP_FAX_CED_TONE_WAIT:
			if (x_elapsed_time (G(dp_timer)) >= MS75)
			{
				G(dp_state) = DP_FAX_STARTUP_TX;
				G(dp_timer) = x_current_time();
			}
			break;

		case DP_FAX_STARTUP_TX:         /* transmit mode */
			dp_fax_startup (0);
			G(x_modem_state) = MS_ON_DIAL;
			G(x_line_rate) = G(x_fax_rate);
			if ((G(S).ModemOptions.SpeakerControl == 1) ||
					 (G(S).ModemOptions.SpeakerControl == 3))
				x_output (IO_SPEAKER_OFF);

			// Datapump set to Tx HDLC frames?
			if ((G(x_fax_state) == FAX_TX_HDLC)
#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
				// Not transmitting Class 2/2.0 ECM frames?
				&& !(CLASS_2_OR_20 && (G(x_fax_rate) > MR_300))
#endif
				)
			{
				G(dp_state) = DP_FAX_TRANSMIT_WAIT;
				G(dp_timer) = x_current_time();
			}
			else
			{
				G(dp_state) = DP_NULL;
				x_send_mail(DP_IO_CONNECT, IO_TASK, NULL, 0);
			}
			break;

		case DP_FAX_TRANSMIT_WAIT:      /* transmit mode */
			// Preamble delay expired?
			if (x_elapsed_time (G(dp_timer)) >= dp_preamble_time())
			{
				G(dp_state) = DP_NULL;
				x_send_mail(DP_IO_CONNECT, IO_TASK, NULL, 0);
			}
			break;

		case DP_FAX_WAIT_SILENCE_THEN_TX:
		case DP_FAX_WAIT_SILENCE_THEN_RX:  
		case DP_FAX_WAIT_SILENCE:
			if ((G(dp_fax_status) & RECEIVE_SILENCE) &&  // Receiving silence?
				 (dp_read_dsp_ram(DSP_STATUS_RAM) & 0x1000))// tones detected?
			{
				G(dp_timer) = x_current_time();	// Restart Recv silence timer
			}

			if (x_elapsed_time (G(dp_timer)) >= G(ci_timer1))
			{
				if (G(dp_state) == DP_FAX_WAIT_SILENCE_THEN_TX)
				{
					// Force startup command to execute now
					G(dp_state) = DP_NULL;
					x_send_mail_dp1(FAX_STARTUP_TRANSMIT);
				}

				else if (G(dp_state) == DP_FAX_WAIT_SILENCE_THEN_RX)
				{
					// Force startup command to execute now
					G(dp_state) = DP_NULL;
					x_send_mail_dp1(FAX_STARTUP_RECEIVE);
				}

				else
				{
					G(dp_state) = DP_NULL;
					x_send_mail(AT_OK, AT_TASK, NULL, 0);
					x_send_mail(IO_IDLE_STATE, IO_TASK, NULL, 0);
				}
			}
			break;

		case DP_NULL:      // doing nothing
			break;

		case DP_PERSEUS_NULL:      // doing nothing
			if ((dp_invalid_count == 0)	&&
				// valid data adc_sat_num
				(dp_read_dsp_ram(0x1a00+DP_PERSEUS_RAM_OFFSET) == 0))
			{
				x_send_mail_dp1(MC_OFFHOOK);
			}

			if (dp_invalid_count > 0)		// detect invalid data
			{
				if (dp_read_dsp_ram(0x1a00+DP_PERSEUS_RAM_OFFSET) > 3)    // invalid data
					dp_invalid_count++;
				else
					dp_invalid_count = 1;
			}

			if (dp_invalid_count > 5)
			{
				x_debug_msg("Invalid data detected");
				//Enable buzzaro mode
				if ((x_elapsed_time (dp_invalid_timer) >= 15)
					&& (x_elapsed_time (dp_invalid_timer) <= 100))
				{
					x_debug_msg("Perseus - BIO2 off");
					// Control Reg #1 with BIO2 off
					dp_write_dsp_ram((0x1a3f+DP_PERSEUS_RAM_OFFSET), 0x1000);
					dp_modem_command (OFF_HOOK, 0, 0);
					dp_invalid_count = 0;  // invalid line conditions
				}
			}
			break;

		case DP_WAIT:      // waiting for timer to expire
			if (x_elapsed_long_time(G(dp_long_timer)) >= 
					(10 * (word)G(S).ModemOptions.NoAnsTimeOut))
			{
				G(dp_state) = DP_DISCONNECT;
				dp_onhook_cmd();
				G(dp_timer) = x_current_time();
			}
			break;

		case DP_OVERCURRENT:
		 	if (!x_input(IO_OVERCURRENT_DET))  // No over current 
			{
				if (x_elapsed_time (G(dp_timer)) >= MS50)
				{
					G(dp_timer) = x_current_time();
					G(dp_timer1) = x_current_time(); 	
#ifdef VOICE
					if (G(x_modem_mode) == MODEM_VOICE)
						G(dp_state) = DP_VOICE;
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
					else if (G(x_modem_mode) == MODEM_SPEAKER_PHONE)
						G(dp_state) = DP_SPEAKER_PHONE_WAIT;
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
					else
#endif 
					if (G(S).ModemOptions.OffHookRestrict != 0)
					{
						G(dp_state) = DP_WAIT;
						x_set_current_time (&G(dp_long_timer));
					}
					else
						G(dp_state) = DP_NULL;
				}
				if (x_elapsed_time (G(dp_timer1)) >= MS10) // ignore holes
					G(dp_timer1) = x_current_time(); 	
			}
			else // Over current
			{
				G(dp_timer) = x_current_time();
				if (x_elapsed_time (G(dp_timer1)) >=
					(10 * (word)G(S).ModemOptions.LoopSenseWaitTime))
				{
		 			x_debug_msg("DP - Over current detected");
					G(x_modem_state) = MS_IDLE;
#ifdef VOICE
					if ((G(x_modem_mode) == MODEM_VOICE) ||
						(G(x_modem_mode) == MODEM_SPEAKER_PHONE))
					{
						byte dp_event_code[3];

						dp_event_code[0] = 0x10;   // DLE
						dp_event_code[1] = 'H';
						dp_event_code[2] = 0;
						x_send_at_io_data(dp_event_code);
					}
#endif // VOICE
					x_send_mail_dp1(MC_ONHOOK);
				}
			}
			break;

		case DP_ANALOG_LOOPBACK:
			if (dp_read_dsp_ram(DSP_STATUS_RAM) & 8)    // (3A) data mode
			{
				// delay to clear garbage characters of startup
				// iomain.c clear dce rx fifo
				if (x_elapsed_time(G(dp_timer)) >= SECOND1)
				{
					G(dp_state) = DP_NULL;
					x_send_mail(DP_IO_CONNECT, IO_TASK, NULL, 0);
				}
			}
			else
			{
				G(dp_timer) = x_current_time();
			}
			break;

#ifdef VOICE
		case DP_VOICE:     // for voice line mode 
			// send detected tones and local hook condition to DTE
			if (dp_tones_detected() == TRUE)
			{
				G(dp_timer) = x_current_time();
			}
			else
			{
				dp_silence_detected(); // silence detection 
			}
			dp_local_phone_detect();
			dp_tad_monitor_hec();
			break;

#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
		case DP_SPEAKER_PHONE_WAIT:
#ifdef V80
#ifdef V8BIS
			if (v8bis_dualtones_detect()== TRUE)
			{
				G(dp_state) = DP_V8BIS;
				x_debug_msg("dp - go to DP_V8BIS state");
			}
#endif	//V8BIS
			if (dp_v8_tone_detected()== TRUE)
			{
				G(dp_state) = DP_V8_RX_INIT_SPKR;
			}
#endif // V80
			if ((G(S).ModemOptions.RingCount > 0)       // incoming call
				 && (x_elapsed_time (G(dp_timer1)) < SECOND10))
				dp_detect_fax_data();
			// wait for local phone to go on-hook
			if (dp_local_phone_detect() == FALSE)
			{
				//speaker agc threshold
				dp_write_dsp_ram(SPKR_THRESHOLD_ADDR, 0x40);
				G(dp_state) = DP_SPEAKER_PHONE_HDX;
				x_debug_msg("DP - Local phone on_hook, switching mode");
			}
			break;

		case DP_SPEAKER_PHONE_HDX:
#ifdef V80
#ifdef V8BIS
			if (v8bis_dualtones_detect()== TRUE)
			{
				G(dp_state) = DP_V8BIS;
				x_debug_msg("dp - go to DP_V8BIS state");
			}
#endif	//V8BIS
			if (dp_v8_tone_detected()== TRUE)
			{
				G(dp_state) = DP_V8_RX_INIT_SPKR;
			}
#endif // V80
			dp_detect_fax_data();
			if (dp_local_phone_detect() == TRUE)
			{
				dp_stop_fdsp();
				G(dp_state) = DP_LOCAL_PHONE_INIT;
			}
			else
			{
				G(dp_state) = DP_SPEAKER_PHONE_CANCEL;
			}
			break;

		case DP_SPEAKER_PHONE_CANCEL:
#ifdef V80
#ifdef V8BIS
			if (v8bis_dualtones_detect()== TRUE)
			{
				G(dp_state) = DP_V8BIS;
				x_debug_msg("dp - go to DP_V8BIS state");
			}
#endif	//V8BIS
			if (dp_v8_tone_detected()== TRUE)
			{
				G(dp_state) = DP_V8_RX_INIT_SPKR;
			}
#endif
			if (dp_local_phone_detect() == TRUE)
			{
				dp_stop_fdsp();
				G(dp_state) = DP_LOCAL_PHONE_INIT;
			}
			if (G(S).ModemOptions.SpeakerPhoneMode < 2)  //FDX
			{
				dp_detect_fax_data();
				if (dp_cancellation())
				{
					dp_switch_fdsp();     // fdsp mode
					G(dp_state) = DP_SPEAKER_PHONE;
				}
			}
			else
			{
				dp_switch_hdsp();     // hdsp mode with aec cleared
				G(dp_state) = DP_SPEAKER_PHONE;
#ifdef V8BIS
				if (G(S).ModemOptions.V8bis == V8BIS_DTE_CONTROL)
				{
					// DTE controlled V.8bis negotiation enabled
					v8bis_init();
				}
#endif //V8BIS
			}
			break;

		case DP_SPEAKER_PHONE:
#ifdef V80
#ifdef V8BIS
			if (v8bis_dualtones_detect()== TRUE)
			{
				G(dp_state) = DP_V8BIS;
				x_debug_msg("dp - go to DP_V8BIS state");
			}
#endif	//V8BIS
			if (dp_v8_tone_detected()== TRUE)
			{
				G(dp_state) = DP_V8_RX_INIT_SPKR;
			}
#endif  // V80
			dp_detect_fax_data();
			// detect local phone hook condition
			if (dp_local_phone_detect() == TRUE)
			{
				dp_stop_fdsp();
				G(dp_state) = DP_LOCAL_PHONE_INIT;
			}
			else
			{
				dp_spk_echotest();
			}
			break;
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM

		case DP_LOCAL_PHONE_INIT:
			dp_onhook_cmd();
			G(dp_state) = DP_LOCAL_PHONE_DETECT;
			G(x_modem_state) = MS_OFFHOOK;
			G(S).ModemOptions.VoiceLineSelection = 0;
			// Stay in VOICE mode after we stop fdsp
			G(x_modem_mode) = MODEM_VOICE;
			break;

		case DP_LOCAL_PHONE_DETECT:
			// wait till the local phone goes onhook - before going to
			// idle and then to sleep
			if (dp_local_phone_detect() == FALSE)
			{
				G(x_modem_state) = MS_IDLE;
				G(dp_state) = DP_IDLE;
			}
			break;

		case DP_GENERATE_TONES:
			if (G(dp_count) == TRUE)
			{
				if (x_elapsed_time (G(dp_timer)) >
					10 * (word)G(S).ModemOptions.HookFlashTime)
				{
					x_debug_msg("DP - end hook flash pulse");
					dp_spkpn_offhook();
					G(dp_count) = DONTKNOW;
					G(dp_timer) = x_current_time();
				}
			}
			else if (G(dp_count) == DONTKNOW)
			{
				if (x_elapsed_time (G(dp_timer)) >
					 10 * (word)G(S).ModemOptions.HookFlashTime)
				{
					x_debug_msg("DP - waiting after flash pulse");
					G(dp_count) = FALSE;
					/* keep processing VTS string */
					G(dp_timer) = x_current_time();
					dp_vts();
				}
			}
			else  if (x_elapsed_time (G(dp_timer)) >= 
					  (10*G(S).ModemOptions.BeepToneTimer+
					   G(S).ModemOptions.DtmfDialSpeed))
			{
				/* keep processing VTS string */
				G(dp_timer) = x_current_time();
				dp_vts();
			}
			break;
#endif // VOICE

#if defined(V8BIS)
#if defined(VENUS_AT_CS)
		case DP_V8BIS_DCE_ANS:
			if (dp_v8bis_ans_background()== FALSE)
			{
				x_debug_msg("dp-back to v.34 answer");
				dp_answer_cmd();
			}
			break;
#endif // Central Site
#endif	//V8BIS

#if defined (VPCM_CLIENT)
		case DP_V8BIS_V92_DCE_ORIG:
			if (dp_v8bis_v92_orig_background()== FALSE)
			{
				x_debug_msg("dp-back to look for answer tone");
				dp_detect_tones_cmd();
				G(dp_state) = DP_ANSWERTONE;
			}
			break;
#endif // VPCM_CLIENT

#if defined(VPCM_CLIENT) || defined(VPCM_SERVER)
		case DP_56K:
			dp_56k_background();
			break;
#endif  // K56FLEX or V.90

#if defined(HOMOL) && defined(VOICE)
#ifdef CALLER_ID
		case DP_CID_ALERT: 
			if (dp_cid_alert_detect() == TRUE)
			{
				dp_cid_cmd();
				x_send_mail(DP_RING, IO_TASK, NULL, 0);
				G(dp_state) = DP_NULL;
			}

			if (((G(S).ModemOptions.CallerIdType == 1) // Japan CID
				  && (x_elapsed_time (G(dp_timer)) >= SECOND3))
				 || (x_elapsed_time (G(dp_timer)) >= SECOND2))
			{
			    x_debug_msg("DP- cid - ring int or past 3sec");
				dp_cid_disable();
				//x_output (IO_CALLER_ID_OFF);	// de-activate cid relay
				G(dp_timer) = x_current_time();
				G(x_modem_state) = MS_IDLE;
				G(dp_state) = DP_IDLE;
			}
			break;
#endif	//CALLER_ID
#endif	// HOMOL && VOICE

#if defined(V34_FAX) // {
		case DP_V34FAX_STARTCHANNEL:	// start V34 Fax Channel
			// Interphase delay (70ms) done in DSP.
			// StartChannel state will start the opposite channel
			// that is currently running.
			//
			// Pri to CC.
			if (PRIMARY_CHANNEL == G(x_fax_v34channel))
			{
				// in Primary, switch to Control Channel
				dp_fax_modem_idle_cmd();	// idle DSP before CC start
				if (RATE_RENEG == G(x_fax_train))	// check for Rate Change
				{
					// set new Pri rate.
					// setCCRate() will follow when implemented
					setPRate((signed char)G(x_fax_maxp) - 1,
							 (signed char)G(x_fax_minp) - 1);
				}

				if (TRUE == G(x_modem_originate))
				{
					x_debug_msg("CC Orig");
					dp_modem_command_long(GOTO_CMD,
									  0xe0, 0x00, ORIGINATE, G(x_fax_train));
				}
				else	// answer side
				{
					x_debug_msg("CC Ans");
					dp_modem_command_long(GOTO_CMD,
										  0xe0, 0x00, ANSWER, G(x_fax_train));
				}
				G(x_fax_train) = SHORT_TRAIN;	// always return to STs
				G(x_fax_v34channel) = CONTROL_CHANNEL;
			}
			else if (CONTROL_CHANNEL == G(x_fax_v34channel))	// CC to Pri
			{
				if (V34_SOURCE == G(x_fax_v34mode))
				{
					x_debug_msg("Pri Tx");
					// Tx Jam Command
					dp_write_dsp_ram(AP_DPRAM_BAUD, 0xd804);
					
					// debug....null out Vec1
					// to stop retrain detection.
					dp_write_dsp_ram(0x0f22, AP_DSP_NUL);
				}
				else // if (V34_RECEIVE == G(x_fax_v34mode))
				{
					x_debug_msg("Pri Rx");
					dp_write_dsp_ram(AP_DPRAM_BAUD, 0xd805); // Tx Jam Command
				}
				G(x_fax_v34channel) = PRIMARY_CHANNEL;
			}

			dp_hdlc_mode();						// set for HDLC mode
			G(dp_timer1) = x_current_time();	// debug wait...
			G(dp_timer) = x_current_time();
			G(dp_state) = DP_V34FAX_DATAWAIT;	// wait for data mode

			break;

		case DP_V34FAX_DATAWAIT:	// wait for data mode...
			// CC must wait for both Rcvr and Transmitter (DM and RR)
			// Pri channel only waits for transmitter (DM only)
			// Data Mode Flag -> 0x003a goes to 0x0008
			// Scrambled Ones Detect Flag (0x07D1) goes non-zero
			if ((PRIMARY_CHANNEL == G(x_fax_v34channel)
				 && dp_read_dsp_ram(DSP_STATUS_RAM) & 8)
				||
				(CONTROL_CHANNEL == G(x_fax_v34channel)
				 && (dp_read_dsp_ram(DSP_STATUS_RAM) & 8)
				 && dp_read_dsp_ram(0x07D1))
				)
			{
				if (CONTROL_CHANNEL == G(x_fax_v34channel))
				{
					x_debug_msg("CC DataMode");
				}
				else
				{
					x_debug_msg("PRI DataMode");
				}

				dp_v34fax_dump();	// debug prints

#if defined(CS_4)
				//-----------------------------------------------------
				// will not work for CS-4: Compile error will cause
				// re-design when this feature is desired in CS-4
				//-----------------------------------------------------
# error "Feature not available on CS_4"
#else
				dp_regwrite(0xd7, G(dp_bamil_rd7) | BIT2);	// disable Ints
				G(io_dce_rx_rptr) = G(io_dce_rx_wptr);	// flush rx buf
				G(io_dce_tx_rptr) = G(io_dce_tx_wptr);	// flush tx buf
				dp_regwrite(0xd7, G(dp_bamil_rd7));	// (re)enable Ints

				// check DSP intr to allow rcv data interrupts.
				dp_regread(0xb0);
				if (dp_regread(0xb7) & 0x10)	// CWTB1 set?
				{
					dp_regread(0xb0);	// double read to set HWTB1 Int
				}
#endif
#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
				if (CLASS_2_OR_20)     // Using Class 2/2.0/2.1 interface?
					signal_class2();    // Inform class 2/2.0/2.1 background task of connect
#endif

				if (CONTROL_CHANNEL == G(x_fax_v34channel))
				{
					// only send CONNECT on initial CC start-up.
					if (FAX_IDLE == G(x_fax_state))
						// Start FAX state machine
						x_send_mail(DP_IO_CONNECT, IO_TASK, NULL, 0);

					G(x_fax_state) = V34FAX_CCSTART;	// go to CC startup
				}
				else
				{
					G(x_fax_state) = V34FAX_PRISTART;	// go to PRI startup
				}
				io_fax_init(G(x_fax_state));	// init fax HDLC handlers

				// turn off speaker
				if ((G(S).ModemOptions.SpeakerControl == 1) ||
					(G(S).ModemOptions.SpeakerControl == 3))
					x_output(IO_SPEAKER_OFF);

				G(x_modem_state) = MS_ON_DIAL;
				G(dp_state) = DP_NULL;	// idle DP layer
			} // if (data mode)

			if (!dp_read_dsp_ram(0x1fd8)) // short train flag
			{
				x_debug_msg("\r\nPhase 3 Err Recovery=");
				sendHexWord(x_elapsed_time(G(dp_timer)));
				sendCrLf();
				G(dp_timer) = x_current_time();	// restart Phase3 timer
				G(dp_state) = DP_V34FAX_PHASE3;	// back to phase3 ST wait
			}

			if (x_elapsed_time(G(dp_timer)) >= SECOND1)
			{
				G(dp_timer) = x_current_time();
				dp_v34fax_dump();
			}

			if (x_elapsed_time(G(dp_timer1)) >= SECOND10)
			{
				G(dp_timer1) = x_current_time();
				x_debug_msg("DataMode Failed!");
					// send <DLE><EOT> to DTE (T.31A1 B.9.4)
				io_put_dte_tx_char(DLE);
				io_put_dte_tx_char(EOT_V34);
				dp_fax_modem_idle_cmd();
				G(dp_state) = DP_DISCONNECT;
			}
			break;

		case DP_V34FAX_SILENCEWAIT:
					// For Pri to CC switch:
					//		send 1s for 35ms 
					// For CC to Pri switch:
					//		send 40 1s (35ms @ 1200bps) then send 1s until
					//		silence is detected.
			if ((PRIMARY_CHANNEL == G(x_fax_v34channel)
					&& x_elapsed_time(G(dp_timer)) > 35)
					||
				(CONTROL_CHANNEL == G(x_fax_v34channel)
					&& x_elapsed_time(G(dp_timer)) > 35
					&& !(dp_read_dsp_ram(0x008E) & 0x0002))	// Carrier Detect
					||
				(x_elapsed_time(G(dp_timer)) > 500)
			 )
			{
				dp_write_dsp_ram(0x3f, 0x01);	// mute transmitter

				x_debug_msg("SWait=");
				sendHexWord(x_elapsed_time(G(dp_timer)));
				sendCrLf();

						// turn off Ints for PDM
#if defined(CS_4)
				//-----------------------------------------------------
				// will not work for CS-4: Compile error will cause
				// re-design when this feature is desired in CS-4
				//-----------------------------------------------------
# error "Feature not available on CS_4"
#else
				dp_regwrite(0xd7, G(dp_bamil_rd7) | BIT2);
#endif
				if (V34_SOURCE == G(x_fax_v34mode))
				{
					// jump to channel start-up
					G(dp_state) = DP_V34FAX_STARTCHANNEL;
				}
				else // if (V34_RECEIVE)	turnaround poll
				{
					// slam io_fax_background() into EOT
					io_fax_init(V34FAX_EOT);
					G(dp_state) = DP_NULL;
				}
			}
			break;

		case DP_V34FAX_DETECT1S:
			dp_write_dsp_ram(0x3f, 0x01);	// mute transmitter
			x_debug_msg("Detect 1s");

			// turn off Ints for PDM
#if defined(CS_4)
			//-----------------------------------------------------
			// will not work for CS-4: Compile error will cause
			// re-design when this feature is desired in CS-4
			//-----------------------------------------------------
# error "Feature not available on CS_4"
#else
			dp_regwrite(0xd7, G(dp_bamil_rd7) | BIT2);
#endif
			G(dp_state) = DP_V34FAX_STARTCHANNEL;	// jump to channel start-up
			break;

#endif	// } V34_FAX

	} // switch(dp_state)
} // dp_periodic_task()

/****************************************************************
Routine: dp_task
Description: The main entry routine for dp task.
Parameters in:
		cmd			-   the DP_TASK command to execute
		mail_ptr    -   mail text pointer (parameters)
		mail_len    -   length of the mail
*****************************************************************/
void dp_task(MODEM_COMMAND cmd, byte *mail_ptr, word mail_len)
{
	switch (cmd)
	{
		case MC_INIT:
			x_debug_msg("DP - received init command");
			dp_init_variables();				// initialize variables
			if (dp_init_modem() == TRUE)		// initialize data pump
			{
				*mail_ptr = TRUE;
				dp_update_modem_options();
				if (G(dp_daa_is_perseus))
				{
					// load perseus code and measure line
					dp_first_init_perseus();
				}

#if defined(CS_4)
				sa_dspInitQMP(ROM_MODE);
				sa_dspInitAUX();
#endif
			}
			else
			{
				*mail_ptr = FALSE;             // hardware failure
			}
			break;

		case MC_PERIODIC:      // call the periodic function
			dp_periodic_task();
#ifdef DC0
			cellular_bg();
#endif
			break;

		case MC_OPTION_CHANGE:
			// called in buffered mode by iomain for option
			// changes.  could be break, async char change.
			dp_async_user_mode();
			break;

		case MC_OFFHOOK:   /* off hook command     */
			x_debug_msg("DP - received offhook command");
#ifdef DC0
			cell_answer(); // if direct connect, send response.
#endif
			dp_offhook_cmd();
			G(x_modem_state) = MS_OFFHOOK;
#ifdef VOICE
			if (G(x_modem_mode) == MODEM_VOICE)
			{
				G(x_modem_state) = MS_TAD_FAR;
				dp_start_tad(TAD_IDLE);
			}
#endif
			// Over current sense on
			if (G(S).ModemOptions.LoopSenseWaitTime != 0)
			{
				G(dp_timer) = x_current_time();
				G(dp_timer1) = x_current_time();
				G(dp_state) = DP_OVERCURRENT;
			}
			else
			{
#ifdef VOICE
				if (G(x_modem_mode) == MODEM_VOICE)
					G(dp_state) = DP_VOICE;
				else
#endif 
				if (G(S).ModemOptions.OffHookRestrict != 0)
				{
					G(dp_state) = DP_WAIT;
					x_set_current_time (&G(dp_long_timer));
				}
				else
 
                if (G(dp_daa_is_perseus))
				{
					dp_invalid_timer = x_current_time();
					dp_invalid_count = 1;
					G(dp_state) = DP_PERSEUS_NULL;
				}
                else
                {
					G(dp_state) = DP_NULL;
                }
			}
			break;

		case MC_ONHOOK:    /* on hook command */
			x_debug_msg("DP - received onhook command");
#ifdef HOMOL 
			if (G(x_modem_state) == MS_DIALING)
			{
				dp_update_blacklist(G(dp_dial_string), TROUBLE);
			}
#endif // HOMOL
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if (G(x_modem_mode) == MODEM_SPEAKER_PHONE)
			{
				dp_stop_fdsp();
				G(x_modem_mode) = MODEM_DATA;
			}
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif // VOICE
			dp_onhook_cmd();
#ifdef VOICE
			if (G(x_modem_mode) == MODEM_VOICE)
			{
				//NOTE: stop_tad should follow onhook_cmd - do not change order
				dp_stop_tad();	
				G(x_modem_mode) = MODEM_DATA;
			}
#endif
			G(S).ModemOptions.VoiceLineSelection = 0;
			G(x_modem_state) = MS_IDLE;
			G(dp_state) = DP_IDLE;
			G(x_fax_state) = FAX_IDLE;
			// Set hardware dependant settings correctly following AT&F
			x_set_hardware_options();
			break;

		case MC_DISCONNECT:
			x_debug_msg("DP - received disconnect command");
#if defined(V92_MODEM_ON_HOLD)
			if ((G(dp_mh_state) == MH_I_IDLE) || (G(dp_mh_state) == MH_R_IDLE))
			{
				// If we were in modem-on-hold states, get DSP
				// back to known state before continuing.
				G(dp_mh_state)=MH_DROP_DATA;
				dp_mh_bg();
			}
#endif

#ifdef HOMOL 
			if (G(x_modem_state) == MS_DIALING)
			{
				dp_update_blacklist(G(dp_dial_string), TROUBLE);
			}
#endif // HOMOL

#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if (G(x_modem_mode) == MODEM_SPEAKER_PHONE)
			{
#ifdef VOICE
				dp_stop_fdsp();
#endif
				dp_onhook_cmd();
				G(x_modem_mode) = MODEM_DATA;
				G(x_modem_state) = MS_IDLE;
				G(dp_state) = DP_IDLE;
			}
			else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			{
				if ((G(x_modem_state) == MS_ON_DIAL) && 
					  (G(x_modem_mode) == MODEM_DATA) &&
					  (G(S).ModemOptions.HangupControl == 0))
					dp_cleardown_cmd();
				else 
					dp_onhook_cmd();
				G(dp_state) = DP_DISCONNECT;
				G(x_dial_residual) = MR_OK;
				G(dp_timer) = x_current_time();	// start timer for clear down
			}
			G(x_fax_state) = FAX_IDLE;
			break;

		case V42_LOCAL_DISC:
			DP_PUTS("V42_LOCAL_DISC-");
		case V42_REMOTE_DISC:
			x_debug_msg("DP - V42 disc cmd");
			if ((G(S).ModemOptions.HangupControl == 0) &&
				(DP_ON_DIAL == G(dp_state)))
			{
				dp_cleardown_cmd();
			}
			else
			{
				dp_onhook_cmd();
			}
			G(dp_state) = DP_DISCONNECT;
			/* if local sent disconnect command - ath cmd - then dial
			   residual is OK - if remote issued v42 disconnect then
			   dial residual is NO CARRIER */
			if (cmd == V42_LOCAL_DISC)
				G(x_dial_residual) = MR_OK;
			else
			{
				G(x_dial_residual) = MR_CD_DISCONNECT;
				G(x_status).TerminationCause = 1;	// remote terminate
			}
			G(dp_timer) = x_current_time();
			break;

		case MC_DIAL:
			// Dial command - probably from ATDxxx
			// At this point we assume it's OK to dial
			// and just do it!
			x_debug_msg("\r\nDP - MC_DIAL");

#ifdef QUICK_CONNECT_TIME_DEBUG
			x_debug_msg("DP - start dp_time_to_connect_timer");
#endif	// QUICK_CONNECT_TIME_DEBUG
#ifdef VPCM_CLIENT
			G(dp_time_to_connect_timer) = x_current_time();
			G(dp_connect_time) = 0;
#endif	// VPCM_CLIENT

#if defined(PERSEUS_PSD)
            if (G(dp_daa_is_perseus))
            {
			    if (dp_psd_chk()) // if parallel set offhook, then abort call
			    {
				    G(dp_state) = DP_CALL_FAILURE;
				    G(x_dial_residual) = MR_BUSY_SIGNAL;
				    break;
			    }
            }
#endif // PERSEUS_PSD
			G(dp_state) = DP_DIAL;
			G(dp_dial_state) = DP_DIAL_START;
			G(x_modem_state) = MS_DIALING;
			G(x_modem_originate) = TRUE;
			if ((*mail_ptr == 'L') && (*(mail_ptr + 1) == 0))
			{
				// Redial last phone number dialed.
				if (G(dp_dial_string)[0] != 0)
				{
					// redial, do not copy the dial new string
					G(dp_redial) = TRUE;
				}
			}
			else
			{
				// The phone number the user wants to dial.
				x_strcpy(G(dp_dial_string), mail_ptr);
			}
			G(dp_timer) = x_current_time();
			x_send_mail(DP_IO_DIAL_OR_ANSWER, IO_TASK, NULL, 0);
			dp_copernicus_dial();
			break;

		case MC_ANSWER:
			// command to answer the call.
			x_debug_msg("DP - received answer command");
			G(dp_line_state) = DP_LINE_TRAINING;
#ifdef DC0
			if (G(dp_state) == DP_CELL_RING_ON)
				G(cell_ring_int) = TRUE;
#endif
#if defined(SA_DIGITAL) && !defined(FORUM)
			G(sa_framer_state) = T0_ON_LINE;
#endif
			G(dp_state) = DP_ANSWERING;
			G(x_modem_state) = MS_ANSWERING;
			G(dp_timer) = x_current_time();
			break;

		case MC_ANALOG_LOOPBACK:
			x_debug_msg("DP - received analog loopback command");
			G(x_modem_state) = MS_LOCAL_TEST;
			G(dp_state) = DP_ANALOG_LOOPBACK;
			dp_analog_loopback_cmd();
			dp_async_8bit_mode();
			break;

		case MC_LOC_DIGITAL_LOOPBACK:
		{
			byte usingDTE = G(S).ModemOptions.ConnectDteRate;

			x_debug_msg("DP - local digital loopback command");
			G(x_modem_state) = MS_DTE_LOOPBACK;
			G(dp_state) = DP_NULL;

			// for connect message, show DTE rate.
			G(S).ModemOptions.ConnectDteRate = 1;
			x_send_mail(DP_IO_CONNECT, IO_TASK, NULL, 0);
			G(S).ModemOptions.ConnectDteRate = usingDTE;		// restore
		}
		break;

		case MC_REM_DATA_LOOPBACK:
			x_debug_msg("DP - remote data loopback ");
			G(x_modem_state) = MS_DCE_LOOPBACK;
			x_send_mail(DP_IO_CONNECT, IO_TASK, NULL, 0);
			break;

		case MC_REM_DIGITAL_LOOPBACK:
			x_debug_msg("DP - remote digital loopback command");
			G(x_modem_state) = MS_REM_TEST;
			dp_rem_digital_loop_cmd();
			break;

		case MC_ABORT_TEST:
			if ((G(x_modem_state) == MS_LOCAL_TEST) ||
				 (G(x_modem_state) == MS_DTE_LOOPBACK))
			{
				G(x_modem_state) = MS_IDLE;
				G(dp_state) = DP_DISCONNECT;
				G(x_dial_residual) = MR_OK;
				dp_modem_idle_cmd();
			}
			else if (G(x_modem_state) == MS_REM_TEST)
			{
				G(x_modem_state) = MS_ON_DIAL;
				dp_v54_terminate_cmd();
			}
			else if (G(x_modem_state) == MS_DCE_LOOPBACK)
			{
				x_debug_msg("dp - abort test in data mode");
				G(x_modem_state) = MS_ON_DIAL;
				x_send_mail(IO_LOOPBACK_ABORT, IO_TASK, NULL, 0);
			}
			break;

		case MC_SPEAKER_ON:
			x_output(IO_SPEAKER_ON);
			break;

		case MC_SPEAKER_OFF:
			x_output(IO_SPEAKER_OFF);
			break;

		case MC_SPEAKER_LOW:
		case MC_SPEAKER_MEDIUM:
		case MC_SPEAKER_HIGH:
			// These DP commands are obsolete.  Speaker volume is
			// based on S.ModemOptions.SpeakerVolume.
			x_output(IO_SPEAKER_HIGH);
			break;

		case FAX_STARTUP_TRANSMIT:
			x_debug_msg("DP - fax startup transmit");

			// Not executing +FTS or +FRS command?
			if (G(dp_state) != DP_FAX_WAIT_SILENCE)
			{
				dp_fax_modem_idle_cmd();
				G(dp_state) = DP_FAX_STARTUP_TX;
				G(dp_timer) = x_current_time();
			}

			else
				G(dp_state) = DP_FAX_WAIT_SILENCE_THEN_TX;

			break;

		case FAX_STARTUP_RECEIVE:
// Note: Debug commands here cause Class 1, ECM to lag too much for serial modems. Disable them if you
//       see +FCERROR near the end of page data.
#ifndef EXT_MODEM
			x_debug_msg("DP - fax startup receive");
#endif
			// Not executing +FTS or +FRS command?
			if (G(dp_state) != DP_FAX_WAIT_SILENCE)
			{
				// Initally, assume no preamble delay; not waiting for +FRH
				G(dp_fax_status) = G(dp_fax_status) &
						~(IGNORE_V21_PREAMBLE | WAIT_FOR_FRH);

				// Qualify V.21 detect in non-V.21 modes
				G(dp_fax_status) = G(dp_fax_status) | START_V21_DEBOUNCE;

				// Turn direction around to receive?
				if ((G(dp_state) != DP_FAX_RECEIVE) ||
					(G(x_line_rate) != G(x_fax_rate)))    // New rate?
				{
					dp_fax_modem_idle_cmd();
#ifdef V34_FAX
					if (G(dp_fax_status) & ENABLE_FAX_CI_DETECT)
						init_fax_ci_det (); // Look for CI if fallback to non-V.34?
					else
#endif
					{
						dp_fax_startup(0);

#ifndef EXT_MODEM 
						x_debug_msg("DP - startup fax receiver from idle");
#endif
						// Starts from idle must have DCE buffer cleared
						io_init_dce_rx_fifo();
						G(dp_state) = DP_FAX_STARTUP_RX;
						// Start with dropout flag cleared
						G(dp_fax_status) = G(dp_fax_status) & ~DROPOUT_FLAG;
						 // V.21 detect debounce timer in dp_fax_carrier_loss ()
						G(dp_timer1) = x_current_time ();

						// Starting V.21, 300 bps?
						if (G(x_fax_rate) == MR_300)
						{
							// Ignore carrier drop-outs during preamble
							G(dp_fax_status) =
								G(dp_fax_status) | IGNORE_V21_PREAMBLE;
						}
					}
				}
				else  // Continue to receive
				{
#ifndef EXT_MODEM
					x_debug_msg("DP - fax continue to receive");
#endif
					G(dp_state) = DP_FAX_CONTINUE_RX;
				}

				G(dp_timer) = x_current_time();
			}
			else
				G(dp_state) = DP_FAX_WAIT_SILENCE_THEN_RX;

			break;

		case FAX_DROP_CARRIER:
			x_debug_msg("DP - received fax_drop_carrier command");
			G(dp_state) = DP_NULL;
			G(x_fax_state) = FAX_IDLE;
			dp_fax_modem_idle_cmd();
			G(dp_timer) = x_current_time();	// used by DP_FAX_STARTUP_TX
			if (G(S).ModemOptions.CDControl == 0)
				UART_cd_on();
			else
				UART_cd_off();
			break;

		case FAX_WAIT_SILENCE:
			x_debug_msg("dp - fax wait silence command");
			dp_fax_modem_idle_cmd();			// Put datapump in idle mode

			if (G(x_fax_state) == FAX_RX_START)   // +FRS command?
			{
				// Configure DP IIR filter #1 as a bandpass filter & listen
				prog_bp_filter();
			}
			else  // +FTS=n Command
			{
				// Indicate transmit silence wait
				G(dp_fax_status) = G(dp_fax_status) & ~RECEIVE_SILENCE;
			}
			
			G(dp_state) = DP_FAX_WAIT_SILENCE;
			G(dp_timer) = x_current_time();
			G(ci_timer1) = (word) (10 * (*mail_ptr));

			if (G(x_fax_state) == FAX_TX)  // Transmitting silence?
			{
				// Allow for delays in system
				G(ci_timer1) =
					(word) (G(ci_timer1) <= 20 ? 0: G(ci_timer1) - 20);
			}
			break;

#if defined(V34_FAX) // {
		case FAXV34_DETECT1S:	// receiver has seen start of 1s
			G(dp_timer) = x_current_time();
			G(dp_state) = DP_V34FAX_DETECT1S;
			break;

		case FAXV34_SEND1S: // Send all 1s in channel.
			// Set PDM Idle char to 0xFF.
			dp_write_dsp_ram(0x46, dp_read_dsp_ram(0x46) | 0x00ff);
			G(dp_timer) = x_current_time();
			G(dp_state) = DP_V34FAX_SILENCEWAIT;
			break;

		case FAXV34_NO_ANSAM_START:	// start-up V34 fax w/o ANSam
			x_debug_msg("dp-phase3 w/o ANSam");
			dp_write_dsp_ram(0x1fd9, 0x0001);	// set No ANSam detect mode
			x_set_current_time (&G(dp_long_timer));
			if (TRUE == G(x_modem_originate))
			{
				dp_v34fax_orig();	// update regs and start orignator
				G(dp_state) = DP_V34FAX_PHASE3;
			}
			else
			{
				dp_v34fax_ans();	// or answer side.
				G(dp_state) = DP_V34FAX_CMWAIT;	// wait for CM startup
			}
			G(dp_timer) = x_current_time();
			G(dp_timer1) = x_current_time();	// for debug timer
			break;

		case FAXV34_RESTART_V8_ORG:
//			x_debug_msg ("Restart V.8...");

			dp_fax_modem_idle_cmd();
			G(x_fax_v34mode) = V34_SOURCE;            // Enable V.34 FAX again

			if (G(x_fax_v34channel) == NO_ACTIVE_CHANNEL)  // Originate turn-around polling?
			{
//				x_debug_msg ("Restart V.8 Org");

				G(S).ModemOptions.V8_CI_Octet = 0xA1;  // Calling modem receives a FAX
				dp_v34fax_orig ();                     // Re-start V.8 for Originate
				G(dp_state) = DP_V34FAX_V8WAIT;        // Wait for V.8 to complete
			}

			else                                     // Re-start V.8 by sending CI
			{
//				x_debug_msg ("Sending CI");
				G(dp_state) = DP_V34FAX_SEND_CI_WAIT;  // Wait before sending CI
			}

			G(dp_timer) = x_current_time ();
			break;

		case FAXV34_RESTART_V8_ANS:
			if (G(x_fax_v34channel) == NON_V34_CHANNEL)  // Restart after CI detected?
			{
//				x_debug_msg ("Restart ANSam after CI");
				x_send_mail (DP_IO_DIAL_OR_ANSWER, IO_TASK, NULL, 0);
				G(x_fax_v34mode) = V34_SOURCE;            // Enable V.34 FAX again
				G(dp_state) = DP_V34FAX_ANS_DELAY;        // Send ANSam again after 1 second
				G(dp_timer) = x_current_time ();          // Start 1 seconds timer
			}

			else  // Turn-around polling
			{
//				x_debug_msg ("Restart V.8 Ans");

/* Begin TEST!!!
				x_send_mail (DP_IO_DIAL_OR_ANSWER, IO_TASK, NULL, 0);
				G(x_fax_v34mode) = V34_SOURCE;            // Enable V.34 FAX again
				dp_write_dsp_ram (0x1FD9, 0x0001);	   // Set No ANSam detect mode
				G(S).ModemOptions.V8_CI_Octet = 0xA1;  // Receive fax at "Call Terminal"
				dp_v34fax_ans ();
				G(dp_timer) = x_current_time ();
				G(dp_state) = DP_V34FAX_CMWAIT;
	 End TEST!!!  */

// Begin TEST!!! -- THIS WORKS, BUT ANSam IS SENT AGAIN!!!
				G(S).ModemOptions.V8_CI_Octet = 0xA1;  // Receive fax at "Call Terminal"
				x_send_mail (DP_IO_DIAL_OR_ANSWER, IO_TASK, NULL, 0);  // Monitor data from DTE (DTE abort)
				G(x_fax_v34mode) = V34_SOURCE;            // Enable V.34 FAX again
				G(dp_state) = DP_V34FAX_ANS_DELAY;        // Send ANSam again after 1 second
				G(dp_timer) = x_current_time ();          // Start 1 seconds timer
			}

			break;

		case V34FAX_DATAWAIT:
//			x_debug_msg ("CC Retrain");

			if (G(dp_fax_status) & DO_CC_RETRAIN)  // Initiate a CC retrain?
			{
				G(dp_fax_status) = G(dp_fax_status) & ~DO_CC_RETRAIN;  // Clear flag
				dp_modem_command_long (GOTO_CMD, 0xE0, 0x00, G(x_modem_originate) ? 1 : 0 , 0x03);  // CC Retrain command
			}

			G(dp_timer) = x_current_time () ;
			G(dp_state) = DP_V34FAX_DATAWAIT;
			break;
#endif // } V34_FAX

		case IO_DP_RETRAIN:  // used by lapm
			// Instructions from LAPM to DP to do a retrain.
			// Probably LAPM isn't happy with the way its
			// data is not getting through and wants to try
			// something drastic.
			x_debug_msg("IO initiates DP retrain");
			if (
#if defined(VPCM_CLIENT) || defined(VPCM_SERVER)
				(G(dp_56k_state) == VPCM_DATA_MODE)	||
				(G(dp_56k_state) == DP_56K_DATA_MODE) ||
#endif
				(G(dp_state) == DP_ON_DIAL))
			{
#if defined(VPCM_CLIENT) || defined(VPCM_SERVER)
				if (dp_56k_retrain_cmd(0) == FALSE)
#endif
				{
					if ((G(x_line_rate) >= MR_2400) &&
#if defined(DC0)
						(G(cell_active) == FALSE) &&
#endif
						(G(dp_state) == DP_ON_DIAL))
					{
						dp_rate_change_cmd(1);
					}
				}
			}
			break;

		case DSP_RETRAIN:  // used by at task, ato1 cmd
			x_debug_msg("dp - retrain command (ato1)");

			if (G(x_line_rate) >= MR_2400)
			{
#if defined(VPCM_CLIENT) || defined(VPCM_SERVER)
				if (dp_56k_retrain_cmd(1) == FALSE)
#endif
				{
					dp_retrain_cmd();
					G(dp_state) = DP_RETRAIN_START;
				}
				G(dp_timer) = x_current_time();
			}
			break;

		case UPDATE_MODEM_RATE:  // used by IO task
			x_debug_msg("dp - update modem rate");
			dp_update_rate();
			dp_init_modem_connection();
			break;

		case DSP_FAST_RETRAIN: // used by at task, ato3 cmd
			x_debug_msg("dp-DSP_FAST_RETRAIN");

			if (G(x_line_rate) >= MR_4800)
			{
#if defined(VPCM_CLIENT) || defined(VPCM_SERVER)
				if (dp_56k_retrain_cmd(2) == FALSE)
#endif
				{
					dp_fast_retrain_cmd();
					G(dp_state) = DP_RETRAIN_START;
				}
				G(dp_timer) = x_current_time();
			}
			break;

		case DSP_VERSION:  // used by at task, get dsp version 
			*((word *)mail_ptr) = dp_dsp_version();
			if (G(dp_state) == DP_WAIT_FOR_RING)
				G(dp_state) = DP_IDLE;
			break;

		case DSP_CHECKSUM: // used by at task, get dsp checksum
			*((word *)mail_ptr) = dp_dsp_checksum();
			if (G(dp_state) == DP_WAIT_FOR_RING)
				G(dp_state) = DP_IDLE;
			break;

		case DP_TEST_CMD:  // used by at task, all homologation test cmds
			// disable sleep for test commands
		{
			DP_STATE reg = G(dp_state);

			G(S).ModemOptions.SleepModeTimer = 0;
			G(SaveDPState) = 0;
			((dsp_ram *) mail_ptr)->val=
				dp_test_cmd(mail_len, ((dsp_ram *) mail_ptr));

			if (G(SaveDPState))
			{
				G(dp_state) = reg;
			}
		}
		break;

		case DP_SLEEP:  // put dsp in sleep mode 
			x_debug_msg("DP_SLEEP");
			G(dp_count) = 0; // reset ring interrupt count
			G(dp_state) = DP_WAIT_FOR_RING;
			G(dp_ring_int) = FALSE;
			G(dp_calling_tone_disable) = FALSE;
			dp_enable_ring_int();
			dp_sleep_mode(TRUE);
			break;

		case DP_WAKEUP:  // wakeup dsp 
			x_debug_msg("DP_WAKEUP");
			dp_init_modem();  // initialize data pump
#ifdef DC0
			if (G(cell_ring_int) == TRUE)
			{
				// we got a cell ring - wait for ata command from app
				G(dp_state) = DP_CELL_RING_OFF;
			}
			else
#endif
			{
				if (G(dp_ring_int) == FALSE)
					G(dp_state) = DP_IDLE;
			}
			break;

		case DP_READ_REG: //used by at task, read interface register
			((dsp_ram *) mail_ptr)->val =
				(word) dp_regread((byte) ((dsp_ram *) mail_ptr)->loc);
			break;
			
		case DP_WRITE_REG:  //used by at task, write DSP RAM
			dp_regwrite((byte) ((dsp_ram *) mail_ptr)->loc,
						(byte) ((dsp_ram *) mail_ptr)->val);
			break;

		case DSP_READ_RAM: //used by at task, read DSP RAM
			((dsp_ram *) mail_ptr)->val = 
				dp_read_dsp_ram(((dsp_ram *) mail_ptr)->loc);
			break;
			
		case DSP_WRITE_RAM:  //used by at task, write interface register
			dp_write_dsp_ram(((dsp_ram *) mail_ptr)->loc, 
							 ((dsp_ram *) mail_ptr)->val);
			if (G(dp_state) == DP_WAIT_FOR_RING)
				G(dp_state) = DP_IDLE;
			break;

		case DP_RESUME:    // initialize data pump
			// This code is also executed by the ATZ command
			x_debug_msg("DP_RESUME");
#if defined(VPCM_CLIENT) || defined(VPCM_SERVER)
			dp_reset_venus();
#endif // VPCM_CLIENT || VPCM_SERVER
			dp_init_modem();
			dp_enable_ring_int();
			break;

#ifdef HOMOL
		case DP_SHOW_BLACKLIST:
			dp_show_blacklist();
			break;

		case DP_BLACKLIST_STATUS:
			if (G(dp_blacklist_calls))
				*mail_ptr = TRUE;
			else
				*mail_ptr = FALSE;
			break;
#endif // HOMOL

		case DP_START_TRANSMIT:    // used by io task
			dp_start_transmit();
			break;

		case DP_ASYNC_8BIT_MODE:   // used by lapm and mnp
			dp_async_8bit_mode();
			break;

		case DP_ASYNC_USER_MODE:   // used by lapm and mnp
			x_debug_msg("DP_ASYNC_USER_MODE");
			dp_async_user_mode();
			break;

		case DP_SYNC_MODE:  
			 // set a synchronous buffered mode (at+es=6)
			 // requested from DP_IO_CONNECT
			dp_sync_mode_hdlc();
			break;

		case DP_SYNC_MODE_MARK:  
			dp_sync_mode_mark();
			break;

		case DP_HDLC_MODE:     // used by lapm and mnp
			x_debug_msg("dp - set hdlc mode");
			dp_hdlc_mode();
			break;

#ifdef V80
		case DP_HDLC_MODE_NO_CRC:
			dp_hdlc_mode_no_crc();
			break;

#ifdef V8BIS
		case DP_SEND_A8T_CMD:
			G(dp_state) = DP_V8BIS;
			v8bis_new_cmd();
			break;

		case DP_V8BIS_DETECTION:
			v8bis_rx_reset();
			break;

		case DP_A8T_CMD:
			x_debug_msg("dp - got DP_A8T_CMD mail");
			if (G(S).ModemOptions.V8bis == V8BIS_DTE_CONTROL)
			{
				if ((G(x_modem_mode) == MODEM_DATA) &&
					(G(x_modem_state) == MS_OFFHOOK) &&
					(G(dp_state) != DP_V8BIS) &&
					(G(dp_state) != DP_V8_TONE_DETECT_INIT_HANDSET))
				{
					v8bis_dte_cmd_tones_detection_setup();
					G(dp_state) = DP_V8BIS;
					x_debug_msg("dp - go to DP_V8BIS state");
				}
				else
					v8bis_in_cmd_state();
			}
			break;
#endif //V8BIS
#endif // V80

		case DP_TX_FIFO_EMPTY:
			if (dp_tx_fifo_empty()== TRUE)
				*mail_ptr = TRUE;
			else
				*mail_ptr = FALSE;
			break;

#ifdef VOICE

		case DP_DPORT_TX:    // used by io task for IS101
			*mail_ptr = dp_dualport_vc_Tx(); // used in IS101
			break;

		case DP_DPORT_RX:    // used by io task for IS101
			*mail_ptr = dp_dualport_vc_Rc();
			break;

		case VOICE_END:
			x_debug_msg("dp - voice end");
			//SpeakerPhone mode:
			//recording - stop recording,stay in speaker phone mode
			//otherwise - end tad, go back to speaker phone mode
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if (G(x_modem_mode) == MODEM_SPEAKER_PHONE)
			{
				if (G(dp_fdsp_record) == TRUE)
					x_send_mail_dp1(VOICE_SPKR_PHONE_RECORD_STOP);
				else
					x_send_mail_dp1(VOICE_SPEAKER_PHONE);
			}
			else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if (G(x_modem_state) == MS_TAD_FAR)
			// if we were previously offhook - then go back to looking
			// for tones in voice idle mode
			{
				dp_tad_idle();
				G(dp_state) = DP_VOICE;
			}
			else
			{
				dp_stop_tad();
				G(x_modem_state) = MS_IDLE;
				G(dp_state) = DP_IDLE;
				x_output (IO_AUDIO_CODEC_OFF);
			}
			G(dp_vt_cntrl) = TAD_IDLE;
			break;

		case VOICE_IDLE:
			x_debug_msg("DP - voice idle command");
			// this command is called in voice mode - to switch to fax
			// or data mode after receiving a calling tone - we wait for
			// the Application to switch us to the proper mode using
			// at+fclass=x command
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if (G(x_modem_mode) == MODEM_SPEAKER_PHONE)
			{
				dp_stop_fdsp();
				G(dp_state) = DP_NULL;
			}
			else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if ((G(x_modem_mode) == MODEM_VOICE) )
			{
				dp_stop_tad(); 
				if ((G(x_modem_state) == MS_TAD_NEAR) ||
					 (G(x_modem_state) == MS_TAD_FAR))
					G(dp_state) = DP_NULL;
			}
			// do not reset the modem state - we could be getting
			// rings (G(x_modem_state) = x_ring_indicate) and then the
			// fax package does an at+fclass=1, then an 'ata' command
			if (G(x_modem_state) != MS_RING_INDICATE)
				G(x_modem_state) = MS_IDLE;
			x_output (IO_AUDIO_CODEC_OFF);
			break;

		case VOICE_NEAR_LOOPBACK:
			x_debug_msg("dp - voice near loopback");
			dp_start_tad (TAD_NEAR_LOOPBACK);
			G(x_modem_state) = MS_TAD_LOOPBACK;
			G(dp_state) = DP_NULL;
			break;

		case VOICE_LINE_LOOPBACK:
			x_debug_msg("dp - voice line loopback");
			dp_start_tad (TAD_LINE_LOOPBACK);
			G(x_modem_state) = MS_TAD_LOOPBACK;
			G(dp_state) = DP_NULL;
			break;

		case VOICE_NEAR_PLAYBACK:
			x_debug_msg("dp - voice near playback");
			dp_start_tad (TAD_NEAR_PLAYBACK);
#ifdef G729A //workaround for initial playback issue
			dp_start_tad (TAD_NEAR_PLAYBACK);
#endif
			G(x_modem_state) = MS_TAD_NEAR;
			G(dp_state) = DP_NULL;
			break;

		case VOICE_NEAR_RECORD:
			x_debug_msg("dp - voice near record");
			dp_start_tad (TAD_NEAR_RECORD);
			G(x_modem_state) = MS_TAD_NEAR;
			G(dp_state) = DP_NULL;
			break;

		case VOICE_LINE_RECORD:
			x_debug_msg("dp - voice line record");
			dp_start_tad (TAD_LINE_RECORD);
			G(x_modem_state) = MS_TAD_FAR;
			G(dp_state) = DP_VOICE;
			G(dp_timer) = x_current_time();
			break;

		case VOICE_LINE_PLAYBACK:
			x_debug_msg("dp - voice line playback");
			dp_start_tad (TAD_LINE_PLAYBACK);
#ifdef G729A //workaround for initial playback issue
			dp_start_tad (TAD_LINE_PLAYBACK);
#endif
			G(x_modem_state) = MS_TAD_FAR;
			G(dp_state) = DP_VOICE;
			break;

		case VOICE_LOCAL_PHONE_CONNECT:
		case VOICE_LOCAL_PHONE_PLAYBACK:
		case VOICE_LOCAL_PHONE_RECORD:
			if (cmd == VOICE_LOCAL_PHONE_RECORD)
			{
				x_debug_msg("dp - voice local phone record");
				dp_start_tad (TAD_NEAR_RECORD);
			}
			else
			{
				x_debug_msg("dp - voice local phone playback");
				dp_start_tad (TAD_NEAR_PLAYBACK);
#ifdef G729A //workaround for initial playback issue
				dp_start_tad (TAD_NEAR_PLAYBACK);
#endif
			}
			G(x_modem_state) = MS_TAD_FAR;
			G(dp_state) = DP_VOICE;
			G(dp_timer) = x_current_time();
			// diconnect local phone from T&R and connect
			// local phone power source.
			x_output (IO_DV_RLY_ON);

			// don't want any sound coming out
			// of the local speaker
			x_output (IO_EXT_SPEAKER_OFF);

			// connect local phone to audio codec
			x_output (IO_LOCAL_PHONE_ON);
			break;

		case VOICE_SCREEN_OUT:
			x_debug_msg("dp - voice screen out");
			dp_start_tad (TAD_SCREEN_OUT);
			G(x_modem_state) = MS_TAD_FAR;
			G(dp_state) = DP_VOICE;
			break;

		case VOICE_SCREEN_IN:
			x_debug_msg("dp - voice screen in");
			dp_start_tad (TAD_SCREEN_IN);
			G(x_modem_state) = MS_TAD_FAR;
			G(dp_state) = DP_VOICE;
			G(dp_timer) = x_current_time();
			break;

		case VOICE_GENERATE_TONES:
			x_debug_msg("dp - voice gen tones command");
			x_strcpy (G(dp_dial_string), mail_ptr);
			G(dp_vts_ptr) = G(dp_dial_string);
			G(dp_timer) = x_current_time();
			dp_vts();
			break;

#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
		case VOICE_SPEAKER_PHONE:
			x_debug_msg("dp - voice start speaker phone");
			dp_stop_tad(); 
			G(dp_timer1) = x_current_time();
#ifdef DC0
			cell_answer(); // if direct connect, send response.
#endif
			if (mail_len != 1)
				dp_offhook_cmd();
			dp_start_hdsp_tone_det();
			G(S).ModemOptions.DsvdVoiceCallFirst = TRUE;
			if (G(S).ModemOptions.LoopSenseWaitTime != 0)  // Over current sense on
			{
				G(dp_timer) = x_current_time();
				G(dp_state) = DP_OVERCURRENT;
			}
			else
				G(dp_state) = DP_SPEAKER_PHONE_WAIT;
			break;

		case VOICE_STOP_SPKR_PHONE:
			x_debug_msg("dp - voice stop speaker phone and switch to TAD");
			dp_stop_fdsp();
			G(x_modem_state) = MS_TAD_FAR;
			G(x_modem_mode) = MODEM_VOICE;
			dp_start_tad(TAD_IDLE);
			G(dp_state) = DP_VOICE;
			break;

		case VOICE_MUTE_SPKR_PHONE:
			x_debug_msg("dp - voice mute speaker phone");
			dp_mute_fdsp (FDSP_MUTE);  
			break;

		case VOICE_UNMUTE_SPKR_PHONE:
			x_debug_msg("dp - voice unmute speaker phone");
			dp_mute_fdsp (FDSP_UNMUTE);
			break;
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
		
		case VOICE_GAIN_CONTROL:
			x_debug_msg("dp - voice set speaker gain control level");
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if (G(x_modem_mode) == MODEM_SPEAKER_PHONE)
			{
				//no spkr gain adjustment, while VLS=5
				if (G(S).ModemOptions.VoiceLineSelection !=5)
					dp_set_speakerphone_gain();
			}
			else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			{
				if (G(x_modem_mode) == MODEM_VOICE)
				{
					dp_set_tad_speaker_gain();
					// if we get +VGT during playback is in progress
					// Kick DSP after command.
					if ((G(dp_vt_cntrl) == TAD_NEAR_PLAYBACK) ||
						(G(dp_vt_cntrl) == TAD_SCREEN_OUT))
						dp_start_transmit();
				}
			}
			break;

		case VOICE_MIC_GAIN_CONTROL:
			x_debug_msg("dp - voice set mic gain control level");
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if (G(x_modem_mode) == MODEM_SPEAKER_PHONE)
			{
				//no spkr gain adjustment, while VLS=5
				if (G(S).ModemOptions.VoiceLineSelection !=5)
					dp_set_spk_mic_gain();
			}
			else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
				dp_set_tad_mic_gain();
			break;

#ifdef CALLER_ID
		case CALLER_ID_END:
			x_debug_msg("DP - cid disable cmd");
			dp_cid_disable();
			G(dp_state) = DP_RING_ON;     // go back to ring on state
			break;
#endif	//CALLER_ID
#endif

#if defined(CALL_WAITING)
		case DP_ENABLE_CW:
			G(vpcm_call_waiting) = 0;	// no call waiting in progress now
			dp_enable_call_waiting();
			break;
#endif

#if defined(VENUS_AT_CS)
		case A_LAW_SELECTED:
			x_debug_msg("dp - selected A-law");
			dp_write_dsp_ram(0x826, 0x0440);
			break;

		case MU_LAW_SELECTED:
			x_debug_msg("dp - selected u-law");
			dp_write_dsp_ram(0x826, 0x0040);
			break;
#endif	// VENUS_AT_CS

		default:
			x_debug_msg("DP - received unknown mail");
			break;
	}
}

// ---------------------------------------- //
// Command the DSP to an Idle State for FAX //
// ---------------------------------------- //
// Apparently, there's a bug in the DSP such that
// when the transmitter goes to an idle state, a
// noise impulse is generated.  In Central Site application only,
// this impulse causes problems such that the receiving modem
// doesn't recognize the echo protection tone nor the long
// training before TCF.
void dp_fax_modem_idle_cmd(void)
{
#if defined(CS_DIGITAL)
	// DSP workaround has already been downloaded, execute it.
	dp_modem_command(GOTO_CMD, 0xD8, 0x00);  // Workaround for CS modems
#else

#if defined(V34_FAX)
	if (NON_V34 != G(x_fax_v34mode))
		dp_write_dsp_ram(AP_DPRAM_BAUD, AP_DSP_NUL);	// "null" out DPRAM baud
#endif

	if (G(x_fax_v17) != NON_V17)	// stop tone detect and dropout wrkarnd
	{
		dp_disable_workaround();
	}

	dp_modem_idle_cmd();   // DSP, ROM-resident modem idle command

#endif // CS_DIGITAL
}
