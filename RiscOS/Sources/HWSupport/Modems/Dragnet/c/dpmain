/*name and version number:@(#)dpmain.c	1.752*/
/*date of get: 		  01/12/01 11:49:14*/
/*date of delta:	  01/11/01 14:04:42*/
/****************************************************************
File :  dpmain.c
Description :
	The main entry routine for dp task.  

Procedures Contained :
	dp_task
	dp_periodic_task
	dp_init_variables
	dp_fax_modem_idle_cmd

Revision History :
	Initials    Date        Change
*****************************************************************/
#define Z80_DEBUG_THIS_FILE

#include "llglob_d.h"
#include "dpglob.h"
#include "ioglob_d.h"
#include "iouart_d.h"
#if defined(V34_FAX)
#include "faxv34.h"
#endif

#ifdef KORTEX
#include "amautodf.h"
#include "ammain.h"
#endif
#if defined (V80) || defined (V8BIS) || defined(VPCM_CLIENT)
#include "sync.h"
#endif	//V80 || V8BIS || VPCM_CLIENT
#ifdef DC0
#include "cellular.h"
#endif
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
	#include "fax_c2.h"
	#if defined (SA_DIGITAL)
		#include "sa_t1.h"  
	#endif
#else
	#define CLASS_2_OR_20 1    
#endif
#if defined (COPERNICUS) || defined (SA_DIGITAL)
  #include "dpv17idl.h"
#endif
#include "atglob.h"
#include "z80glob.h"
#include "v42bis.h"
#include "allglobs.h"

#ifdef CS_MODEM
#include "csglob.h"
#endif

#ifdef SYNCH_MODE
extern byte q2Dial;
extern byte q3Dial;
extern void sync_q2q3_dial_loop(void);
#endif
extern byte lapm_disconnecting(void);
extern void dp_reset_venus(void);

/****************************************************************
	functions used by dp task
*****************************************************************/
extern void x_set_hardware_options(void);
extern void dp_copernicus_dial(void);
extern void dp_copernicus_ring(void);
extern byte dp_copernicus_hangup(void);
extern void dp_print_state_pointers(void);
extern void dp_fax_silence_detect (void) ;
void dp_fax_modem_idle_cmd (void);
extern void	vpcm_download_phase1_phase2(void);
extern void cs_v110_init( void );
void dp_sdr_ring(void);
extern void dp_sdr_report(void);
extern void dp_sdr_ring_init(void);
extern void init_cng_detect (void);
extern byte look_4_cng      (void);
extern void vpcm_set_answering_mode (void) ;

#define CHK_VF_PP	0xdc01	//chk_VF_PP

// Bit definitions for G(dp_fax_status):
#define IGNORE_V21_PREAMBLE 1
#define RECEIVE_SILENCE     2
#define START_V21_DEBOUNCE  4
#define WAIT_FOR_FRH        8  

extern word dp_check_call_waiting(word ram3a);
extern void dp_mh_bg(void);

byte dp_invalid_count;
word dp_invalid_timer;

/****************************************************************
Routine : dp_init_variables
Description : Initialize all variables used by dp task and variables 
		  that are defined in llglob_x.h
*****************************************************************/
void dp_init_variables(void)
{   
	// init global variables for DP task
	G(x_modem_state) = MS_IDLE;
	G(x_dial_residual) = MR_OK;
	G(dp_state) = DP_IDLE;
	G(dp_line_state) = DP_LINE_ON_HOOK;
	G(dp_calling_tone_disable) = FALSE;
	G(dp_wDspRetrainState) = 0;
	G(DpIdleFillChar) = 0x00;  //  idle line (no data) fill character
	G(dp_fax_status) = 0;     

#if defined(V34_FAX)
	G(x_fax_v34mode) = NON_V34;
#endif

#if defined(SDR_RING_DETECT)
	G(SDR_Ring_Select) = 0;
#endif

#ifdef HOMOL 
	dp_init_blacklist();
#ifdef VOICE
	G(dp_polarity_int) = FALSE ;
#endif
#endif
	// Initialize local phone state and timer
	G(dp_tad_downloaded) = FALSE ;
	G(dp_fax_downloaded) = FALSE ;
#if defined(CLASS2_FAX)	 || !defined(CS_MODEM)
	dp_init_local_phone_state () ;
	G(last_fax_v17) = NON_V17;
#endif
#ifdef VOICE
	G(dp_vt_cntrl) = TAD_IDLE ;
#endif
	G(dp_fdsp_record) = FALSE ;
#if defined (V8BIS) || defined (VPCM_CLIENT)
	v8bis_power_up_init ();
#endif	//V8BIS || VPCM_CLIENT
	G(dp_redial) = FALSE ;
#if defined ( VPCM_CLIENT ) || defined ( VPCM_SERVER )
	G(vpcm_mode) = 0 ;		// 0 = K56FLEX, 1 = VPCM
#endif	// VPCM_CLIENT || VPCM_SERVER
#if defined(V92_MODEM_ON_HOLD)
	G(dp_mh_state) = MH_NULL;
#endif
}

// -------------------------------------------- //
// Set FAX Mode for V.34 or Non-V.34 Modulation //
// -------------------------------------------- //

void set_fax_modulation (void)
{
#ifdef V34_FAX
	#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
	if (CLASS_2_OR_20)                  // Using 2, 2.0 or 2.1 interface?
	{
		#ifdef TEST_V34_FAX_WITH_WINFAX80
		G(c2p.fdis.ps.br) = G(c2p.fdis.ps.br) + 6;  // Shift rate to 16.8 - 28.8 range
		G(c2p.fdis.ps.ec) = 1;                   // Enable ECM, T.30, Annex A
		G(c2p.dbf) = (G(c2p.dbf) & ~FECM) | 0x0800; // DCE handles ECM alone

		if( G(S).ModemOptions.V8_CI_Octet != 0xA1 )
			G(S).ModemOptions.V8_CI_Octet = 0x81;

			G(S).ModemOptions.AdaptiveAnswer = TRUE; // enabled
		#else
		if ( (G(c2p.fdis.ps.br) <= 5) ||    // 14,400 or lower data rate?
				 (G(c2p.fclass) == 2) )     // Using Class 2 interface?
			G(x_fax_v34mode) = NON_V34;     // Use V.17, V.33, V.29 or V.27

		else                                  // Data rate greater than 14,400
		#endif
		{
			G(x_fax_v34mode) = V34_SOURCE;      // Use V.34 modulation
			G(x_fax_maxp) = G(c2p.fdis.ps.br) + 1; // Update maximum V.34 primary channel data rate
			G(x_fax_minp) = 1;     // Set minimum primary channel rate to 2,400

			if( G(S).ModemOptions.V8_CI_Octet != 0xA1 )
				G(S).ModemOptions.V8_CI_Octet = 0x81;      
		}
	}
	else
	#endif
	{
		G(x_fax_v34mode) = V34_SOURCE;

		if( G(S).ModemOptions.V8_CI_Octet != 0xA1 )
			G(S).ModemOptions.V8_CI_Octet = 0x81;
	}
#endif
}

// ----------------------------------------------------------- //
// Determine the Preamble time for the selected FAX modulation //
// ----------------------------------------------------------- //

word preamble_time (void)
{
	// In milliseconds
	static const word non_v17_times [] = {1383, 1158, 478, 478, 1836, 1836};
	word time = MS850;  // Default to V.21 HDLC (850 ms)

	if (G(x_fax_rate) != MR_300)
	{
		if (G(x_fax_v17) == V17_SHORT_TRAIN)     // Short train used?
			time = 585;              // Delay for V.17 modulation, short train

		else if (G(x_fax_v17) == V17_LONG_TRAIN)
			time = 1836;             // Delay for V.17 modulation, long train

		else if ( (G(x_fax_rate) >= MR_2400) && (G(x_fax_rate) <= MR_14400) )
			time = non_v17_times [G(x_fax_rate)-5];
	}

	return (time);
}

// ------------------------------------------------------------ //
// Check if the datapump is not receiving the correct data rate //
// ------------------------------------------------------------ //
/*
	 Return TRUE: Incorrect data rate was detected or still qualifing signal
	 Return FALSE: Incorrect data rate was not detected
*/
byte wrong_speed (void)
{
	byte chk = FALSE;

#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
	if (!CLASS_2_OR_20)  // Not using Class 2.x interface?
#endif
	{
		if (dp_read_dsp_ram (0x3B) & 0x0800)  // V.21 detected in non-V.21 mode?
		{
			word *p = (word*) V42BIS_MEM_START; // Put a timer in un-used RAM

			chk = TRUE;  // Indicate incorrect data rate or signal is still being qualified

			if (G(dp_fax_status) & START_V21_DEBOUNCE)  // Initialize signal qualification?
			{
				G(dp_fax_status) = (byte) (G(dp_fax_status) & ~START_V21_DEBOUNCE);  // Clear flag
				*p = x_current_time ();  // Start timer
			}

			else if (x_elapsed_time (*p) > 60)  // Signal present for 60 ms?
			{
				x_debug_msg("DP - wrong_speed");
				G(dp_state) = DP_NULL;
				G(x_line_rate) = ~G(x_fax_rate);    // Make rates different; causes +FCERROR response
				G(x_modem_state) = MS_ON_DIAL ;     // ????
				x_send_mail ( DP_IO_CONNECT, IO_TASK, NULL, 0 );  // Send +FCERROR to host
			}
		}
	}

	return (chk);
}

// ---------------------------------------------- //
// Program DSP IIR filter #1 as a bandpass filter //
// ---------------------------------------------- //
/*
		This filter design is taken from "Appendix
		B. Design/Application Information" of some unknown Lucent (old
		AT&T) Document.

		Type: Bandpass
		Order: 6th
		Low Freq: 1,400 Hz
		High Freq: 2,200 Hz
		Min. Threshold: -43 dbm

		Use: Monitor the absence or presence of FAX V.27ter, V.29,
		V.17 or V.33 carriers in response to an AT+FRS=n command used
		with a Class 1 interface.
*/

void prog_bp_filter (void)
{
	static const word coef_tab[] =
	{
		IIR1_K_ADDR, 	 0x3932,	// K

		IIR1_D11_ADDR, 0x0000,	// d(1,1)
		IIR1_D12_ADDR, 0x2367,	// d(1,2)
		IIR1_N11_ADDR, 0x0000,	// n(1,1)
		IIR1_N12_ADDR, 0xF9A7,	// n(1,2)
		IIR1_N10_ADDR, 0x0659,	// n(1,0)

		IIR1_D21_ADDR, 0x2AE0,	// d(2,1)
		IIR1_D22_ADDR, 0x37CD,	// d(2,2)
		IIR1_N21_ADDR, 0x322E,	// n(2,1)
		IIR1_N22_ADDR, 0x3215,	// n(2,2)
		IIR1_N20_ADDR, 0x3215,	// n(2,0)

		IIR1_D31_ADDR, 0xD520,	// d(3,1)
		IIR1_D32_ADDR, 0x37CD,	// d(3,2)
		IIR1_N31_ADDR, 0xA053,	// n(3,1)
		IIR1_N32_ADDR, 0x5F7C,	// n(3,2)
		IIR1_N30_ADDR, 0x5F7C	  // n(3,0)
	};

	G(dp_fax_status) = (byte) (G(dp_fax_status) | RECEIVE_SILENCE);     // Indicate receive silence wait
	dp_write_dsp_ram (IIR1_THRESHOLD_ADDR, 43);                         // Detect threshold @ -43 dbm
	dp_write_dsp_block (coef_tab, sizeof(coef_tab)/(2*sizeof(word)) );  // Load filter coefficients into DSP
	dp_modem_command (DETECT_TONES, 1, 0);	                            // Start bandpass filter
}

/****************************************************************
Routine : dp_psd_chk
Description : returns 0 if no parallel set offhook was detected
*****************************************************************/
byte dp_psd_chk(void)
{
	short temp;

	// enable ring detection
	dp_modem_command(GOTO_CMD,PERSEUS_BASE,PERSEUS_RING_EN);
	// enable parallel set detection
	dp_modem_command ( GOTO_CMD, PERSEUS_BASE, PERSEUS_PSD_EN ) ;

	// disable parallel set detection
	dp_modem_command ( GOTO_CMD, PERSEUS_BASE, PERSEUS_PSD_DIS ) ;
	x_sleep(30); // allow circuit to settle value
	temp=dp_read_dsp_ram(0x19f2);
	if (temp>0x5000)
	{
		x_debug_msg("Parallel set off-hook detected value=");
		sendHexWord(temp);
		sendCrLf();
		return 1;
	}
	x_debug_msg("PSD value=");
	sendHexWord(temp);
	sendCrLf();
	return 0;
}

/****************************************************************
Routine : dp_dsp_sptr_check
Description : check whether dsp is insane
*****************************************************************/
void dp_dsp_sptr_check(void)
{
	// read retrain state pointer of dsp - if it stays the
	// same for too long then disconnect
	if ( (G(dp_wDspRetrainState) == dp_read_dsp_ram ( S_PTR )) ||
		 ( x_elapsed_time ( G(dp_timer) ) >= SECOND30 ) )
	{
		word failTime = SECOND10;
		word s10Time = (word) (100 * G(S).ModemOptions.NoCarrierDisc);

		// Honor the S10 no carrier disconnect time
		// so we don't hang up too soon
		if ((G(S).ModemOptions.CountryId == NA) &&
			(s10Time > failTime))
		{
			failTime = s10Time;
		}

		if ( x_elapsed_time(G(dp_timer1)) >= failTime )
		{
			if ( G(dp_state) == DP_V34_RETRAIN )
			{
				cs_insert_error_tag (0xdc00 , 0);
				x_debug_msg("DP_V34_RETRAIN failure");
#if !defined (CS_MODEM)
				G(x_status).ud_TerminationCause = UD_TC_RETRAIN_FAIL;
#endif
			}
			else
			{
				cs_insert_error_tag (0xde00 , 0);
				x_debug_msg("DP_TRAINING failure");
#if !defined (CS_MODEM)
				G(x_status).TerminationCause = 3 ;	// training failure
#endif
			}
			G(dp_state) = DP_CALL_FAILURE;
			G(x_dial_residual) = MR_CD_DISCONNECT;
		}
	}
	else
	{
		G(dp_wDspRetrainState) = dp_read_dsp_ram(S_PTR);
		G(dp_timer1) = x_current_time();
	}
}

/****************************************************************
Routine : dp_periodic_task
Description : The periodic routine for dp task.
*****************************************************************/
void dp_periodic_task(void) 
{
	word minutes1, delta ;
	word minutes ;
#if defined(V34_FAX) || defined(CIDCW)
	word wtemp;
#endif
#if defined(EXT_MODEM) || defined(THUNDER)
	extern BOOL	AUTOBAUDING;
#endif

#if defined(CS_V110)
	if (!G(cs_v110_on) )
#endif

#if defined(EXT_MODEM) || defined(THUNDER)
	// In the serial modem we were seeing problems where autobauding
	// was seemingly coliding with dp_read_dsp_ram().  Whatever it was
	// was causing us to not respond to AT commands every once in a
	// while.  This 'if' statement is a band-aid for the problem, as
	// we don't really understand what's happening (yet).
# if defined(THUNDER)
	if ( z80_modem_type == EXT_INTERFACE )
# endif
	if ( !AUTOBAUDING )
#endif
	{
	  dp_echo_ram();
	  dp_echo_trec();
	  dp_echo_constellation ();

	  dp_monitor_frate_timer();	
	  dp_print_state_pointers();
	}

	cs_log_state_pointers();

	// update minute counter 
	minutes = (word) x_elapsed_time_long(G(x_minute_timer_long)) ;
	if ( minutes >= MINUTE1 )
	{
		minutes1 = (word)(minutes / MINUTE1) ;
		G(x_minute_count) = (word) (G(x_minute_count) + minutes1);
		delta = (word) (minutes - (MINUTE1*minutes1)) ;
		G(x_minute_timer_long) = x_current_time_long() - delta ;
		G(x_minute_timer) = (word) (x_current_time() - delta);
	}

#if defined(COPERNICUS)
#if defined(CS_V110)
  if (!G(cs_v110_on) )
#endif
	dp_copernicus_hangup();
#endif
#if defined (V92_MODEM_ON_HOLD)
	// if MOH is enabled, call state machine
	if (G(S).ModemOptions.MHOptions & MH_ENABLED)
		dp_mh_bg();
#endif

	switch ( G(dp_state) )
	{
		case DP_IDLE :
			if ( G(S).ModemOptions.HangupControl == 10 )
			{
				/* Disable automatic hangup control for nextime */
				G(S).ModemOptions.HangupControl = 0 ;
				x_send_mail ( IO_INACTIVITY_STATE, IO_TASK, NULL, 0 ) ;
				G(dp_state) = DP_NULL ;
				G(S).ModemOptions.VoiceLineSelection = 1 ;
				G(x_modem_state) = MS_OFFHOOK ;
			}
			else
			{
				#if defined (COPERNICUS)
				if (G(dp_s37_changed))			
				{							
					G(S).ModemOptions.DialLineRate = 0; 
					G(dp_s37_changed) = 0;		
				}							
				G(vpcm_ratechange_count) = 0;
				#endif  // COPERNICUS

				G(dp_dialing_status) = DP_INITIAL_DIAL ;
				G(S).ModemOptions.RingCount = 0 ;  // initialize rings detected
				G(dp_state) = DP_WAIT_FOR_RING ;
				G(dp_ring_int) = FALSE ;
				G(dp_count) = 0 ;
				G(dp_ring_int_count) = 0 ;
				G(dp_calling_tone_disable) = FALSE ;
				G(dp_timer1) = x_current_time () ;
				G(dp_threshold) = G(S).ModemOptions.DialToneThreshold ;
				dp_enable_ring_int () ;

                if( G( dp_daa_is_perseus ))
                {
				    dp_invalid_count = 0 ;  
                }
			}
			break ;

		case DP_WAIT_FOR_RING :
#ifdef SYNCH_MODE
			// Dialing options for synch mode.
			// If user chooses one of these dialing options, modem will stay in
			// this mode until HW reset.
			if ((q2Dial||q3Dial) &&	(G(S).ModemOptions.V42 == V42_SYNCH_MODE))
			{
				sync_q2q3_dial_loop();
				break;
			}
#endif  // SYNC_MODE

#if defined(COPERNICUS) && !defined(CS_MODEM)
			dp_copernicus_ring();
#elif defined(SA_CIRCULAR_BUFFER_HOST)
			sa_boardwalk_ring() ;
#else
#if defined (HOMOL) && defined (VOICE)
#ifdef	CALLER_ID
			if ( ( G(S).ModemOptions.CallerId )      // CID enabled
				 && ((G(S).ModemOptions.CallerIdType == 1 ) // detect pol rev
				 || (G(S).ModemOptions.CallerIdType == 2 ))  //UK (SIN 242)
				 && ( G(dp_polarity_int) == TRUE )   // polarity reversed
				 && ( x_elapsed_time(G(dp_timer1)) >= 80 ) ) // True pol rev
			{
				G(dp_polarity_int) = FALSE ;
				if ((G(S).ModemOptions.SleepModeTimer) &&
					 (G(dp_sleep) == TRUE))
					dp_init_modem () ;  // initialize data pump - wakeup mode
				x_send_mail ( IO_IDLE_STATE, IO_TASK, NULL, 0 ) ;
				dp_cid_alert_init() ;
				G(x_modem_state) = MS_RING_INDICATE ;
				G(dp_timer) = x_current_time () ;
				G(dp_state) = DP_CID_ALERT;
				break;
			}
#endif	//CALLER_ID
#endif	// HOMOL && VOICE

			if ( G(dp_ring_int) == TRUE )
			{
				x_debug_msg("DP-periodic sees dp_ring_int");
				if ((G(S).ModemOptions.SleepModeTimer) &&
					(G(dp_sleep) == TRUE))
				{
					dp_init_modem();  // initialize data pump - wakeup mode
				}
				x_send_mail(IO_IDLE_STATE, IO_TASK, NULL, 0);
				G(dp_state) = DP_RING_INIT;
				G(dp_timer) = x_current_time () ;
				G(dp_dialing_status) = DP_SUBSEQUENT_DIAL; //for ans with ATD
			}
#ifdef DC0
			else if ( G(cell_ring_int) == TRUE )
			{
				x_debug_msg("DP - cell ring interrupt");
				if (G(S).ModemOptions.SleepModeTimer)
					dp_init_modem () ;  // initialize data pump - wakeup mode
				x_send_mail ( IO_IDLE_STATE, IO_TASK, NULL, 0 ) ;
				G(dp_state) = DP_CELL_RING_ON ;
				x_send_mail ( DP_RING, AT_TASK, NULL, 0 ) ;
				G(S).ModemOptions.RingCount = 1 ;  
				G(dp_timer) = G(dp_timer1) = x_current_time () ;
			}
#endif // DC0
#ifdef VOICE
			// Local phone hook condition detection in voice mode.
			// Important to place this after (G(dp_ring_int) == TRUE )
			// block above since G(dp_local_phone_timer) is reset
			// there.
			else if ( ( G(x_modem_mode) == MODEM_VOICE ) &&
				 ( dp_local_phone_detect() == TRUE ) )
				G(dp_state) = DP_LOCAL_PHONE_INIT ;
#endif  // VOICE
#ifdef HOMOL
			if ( G(S).ModemOptions.BlackListFlag ) 
				dp_blacklist_periodic () ;
#endif // HOMOL
#endif // COPERNICUS && !CS_MODEM
			break ;

		case DP_RING_INIT :
			// look for ring - read dsp status ram location for true ring
			if (dp_ring_detected ())
			{
				G(dp_timer) = G(dp_timer1) = x_current_time ();
				G(dp_state) = DP_RING_ON ;
				G(x_modem_state) = MS_RING_INDICATE ;
#ifdef VOICE
				if ( ( G(S).ModemOptions.DistinctiveRing != 0 )
				   || ( G(S).ModemOptions.SynRingFreq!= 0 ) )
					dp_voice_ring_init () ;
#endif

#if defined( SDR_RING_DETECT )
				if( G(SDR_Ring_Select) != 0 )
				{
					dp_sdr_ring_init();
				}
#endif
				x_debug_msg ("Real ring detected");
			}
			else
			{
#ifdef VOICE
				// local phone hook condition detection in voice mode
				if ( G(x_modem_mode) == MODEM_VOICE ) 
					dp_local_phone_detect() ;
#endif
				if ( x_elapsed_time ( G(dp_timer) ) >= MS500  )
				{
					G(dp_state) = DP_IDLE ;
					G(x_modem_state) = MS_IDLE ;
				}
			}

			break ;

		case DP_RING_OFF :
#ifdef VOICE
			if ( ( G(S).ModemOptions.DistinctiveRing != 0 )
			   || ( G(S).ModemOptions.SynRingFreq!= 0 ) )
				dp_voice_ring () ;
#endif

#if defined( SDR_RING_DETECT )
			if( G(SDR_Ring_Select) != 0 )
				dp_sdr_ring();
#endif

			if (!dp_ring_detected())
			{
				// check for min ring off period
				if ( x_elapsed_time ( G(dp_timer1) )
						>= (word)(20 * G(S).ModemOptions.RingCadenceOff) )
				{
					G(S).ModemOptions.RingCount++; // inc. rings detected
#ifdef VOICE
					if ( (G(S).ModemOptions.DistinctiveRing == 0) ||
						 ((G(S).ModemOptions.VoiceEventMask&
						   EVENT_DISTINCTIVE_RING)==0))
#endif // VOICE
					{

#if defined( SDR_RING_DETECT )
						if( G(SDR_Ring_Select) != 0 )
							dp_sdr_report();
						else
#endif
						x_send_mail ( DP_RING, AT_TASK, NULL, 0 ) ;

                        if( G( dp_daa_is_perseus ))
                        {
						    // RING was detected, enable again
						    dp_enable_ring_int () ;
                        }
					}
#ifdef VOICE
#ifdef CALLER_ID
					if ( (G(S).ModemOptions.VoiceEventMask&EVENT_CALLER_ID) &&
						 ( G(S).ModemOptions.CallerId ) && 
#ifdef HOMOL
						 ( (0x0f & G(S).ModemOptions.CallerIdType) == 0 ) &&
#endif // HOMOL
						 ( G(S).ModemOptions.RingCount == 1 ) )    
					{
						if ( ( G(S).ModemOptions.DistinctiveRing != 0 )
							 || ( G(S).ModemOptions.SynRingFreq!= 0 ) )
						{
							dp_voice_ring();
						}
						dp_cid_cmd();
#if defined( SDR_RING_DETECT )
						if( G(SDR_Ring_Select) != 0 )
							dp_sdr_report();
						else
#endif
						x_send_mail(DP_RING, IO_TASK, NULL, 0);
						G(dp_state) = DP_NULL ;
					}
					else
#endif	//CALLER_ID
#endif  // VOICE
					{
						G(dp_state) = DP_RING_ON;
						if ( (G(S).ModemOptions.AutoAnswer) &&
							 (G(S).ModemOptions.RingCount
							  >= G(S).ModemOptions.AutoAnswer) &&
							 !UART_dtr_blocked () )
						{
							// auto answer
							G(x_modem_state) = MS_ANSWERING;
							G(dp_state) = DP_ANSWERING;
						}
					}
					UART_ri_off();
					G(dp_timer) = G(dp_timer1) = x_current_time();
				}
			}
			else	// ring detected w/ short off time.
			{
				G(dp_timer1) = x_current_time () ;
			}

			break ;

		case DP_RING_ON :
#ifdef VOICE
			if ( ( G(S).ModemOptions.DistinctiveRing != 0 )
			   || ( G(S).ModemOptions.SynRingFreq!= 0 ) )
				dp_voice_ring () ;
#endif

#if defined( SDR_RING_DETECT )
			if( G(SDR_Ring_Select) != 0 )
				dp_sdr_ring();
#endif

			if (dp_ring_detected())
			{
				G(dp_timer) = x_current_time();
			}
			else
			{
#ifdef VOICE
				// local phone hook condition detection in voice mode
				if ( G(x_modem_mode) == MODEM_VOICE ) 
					 dp_local_phone_detect() ;
#endif
				delta = x_elapsed_time(G(dp_timer1));
				G(dp_timer1) = x_current_time();

#if defined(VOICE) && defined(HOMOL)
#ifdef CALLER_ID
				// French Caller ID
				if ((G(S).ModemOptions.CountryId == FRANCE)
					&& (G(S).ModemOptions.VoiceEventMask & EVENT_CALLER_ID)
					&& G(S).ModemOptions.CallerId
					&& (G(S).ModemOptions.RingCount == 0 )
					&& (delta > 175) && (delta < 325) )
				{
					// Accept French Caller ID
					dp_cid_cmd();

					// set up IO to parse CID info
#if defined( SDR_RING_DETECT )
					if( G(SDR_Ring_Select) != 0 )
						dp_sdr_report();
					else
#endif
					x_send_mail(DP_RING, IO_TASK, NULL, 0);

					// wait for IO to get us out of this state
					// with CALLER_ID_END command
					G(dp_state) = DP_NULL;
				}
#endif	//CALLER_ID
#endif // VOICE && HOMOL

				if ((delta >= (word) 10*G(S).ModemOptions.RingCadenceOn) &&
					(delta <= SECOND5))
				{
					if ((G(S).ModemOptions.CountryId == JAPAN) &&
						(delta > MS400) && (delta < MS600))
					{
						G(dp_timer1) = x_current_time () ;
						break ;
					}

					G(dp_timer) = x_current_time();
					G(dp_state) = DP_RING_OFF;
#if defined(SDR_RING_DETECT)
					if( G(SDR_Ring_Select) != 0 )
					{
						if( G(sdr_ring_valid) != 0 )
						{
							x_debug_msg("RI ON");
							UART_ri_on();
						}
					}
					else	// SDR not active...do normal RI
#endif
					UART_ri_on();
				}

				if (x_elapsed_time(G(dp_timer)) >= 
					(100 * (word)G(S).ModemOptions.RingCountNullDelay))
				{
					G(dp_state) = DP_IDLE;
					G(x_modem_state) = MS_IDLE;
					UART_ri_off();
				}
			}
			break ;

#ifdef DC0
		case DP_CELL_RING_OFF:
			if ( x_elapsed_time(G(dp_timer)) > SECOND10 + SECOND4 )
			{
				G(cell_ring_int) = FALSE ;
				G(dp_state) = DP_IDLE ;
			}
			break;

		case DP_CELL_RING_ON:
			if ( G(S).ModemOptions.AutoAnswer
				&& (G(S).ModemOptions.RingCount >=
					G(S).ModemOptions.AutoAnswer) )
			{
				G(x_modem_state) = MS_ANSWERING ;
				G(dp_state) = DP_ANSWERING ;
				G(cell_ring_int) = TRUE ;
			}
			else if ( x_elapsed_time ( G(dp_timer) ) >= SECOND4 )
			{
				if ( G(cell_ring_int) == TRUE )
				{
					G(dp_timer) = x_current_time () ;
					G(S).ModemOptions.RingCount++ ; 
					x_send_mail (DP_RING, AT_TASK, NULL, 0);
				}
				else
					G(dp_state) = DP_IDLE ;
			}
			else if ( G(S).ModemOptions.RingCount >= 10 )
			{
				G(cell_ring_int) = FALSE ;
				G(dp_state) = DP_IDLE ;
			}
			break;
#endif // DC0

		case DP_DIAL :
			// Dialing, got to this state with MC_DIAL command.
			// It's up to the logic in dp_dial() to get us
			// through the dial string found in dp_dial_string[].
			switch (dp_dial())
			{
			case DIAL_RETURN_OK:	// continue dialing
				break ;

			case DIAL_RETURN_IDLE:		// continue in command mode
#ifdef V8BIS
				if ( G(S).ModemOptions.V8bis == V8BIS_DTE_CONTROL )
					G(dp_state) = DP_NULL ;
				else
#endif	//V8BIS
					G(dp_state) = DP_WAIT_V8_ANSWER ;
				break ;

			case DIAL_RETURN_NULL:		// done dialing (successfully)
				G(dp_timer) = x_current_time () ;
				G(dp_threshold) = G(S).ModemOptions.CallProgressThreshold ;   
				G(dp_state) = DP_CALL_PROGRESS ;
				x_set_current_time ( &G(dp_long_timer) ) ;
				/* turn on speaker after dialing */
				if ( G(S).ModemOptions.SpeakerControl == 3 )
					x_output(IO_SPEAKER_ON);
				break ;

			case DIAL_RETURN_FAILURE:
				G(dp_state) = DP_CALL_FAILURE; // dialing has failed
				break ;
			}
			break ;

		case DP_CALL_PROGRESS :
			// Originate mode - dialing was successful.
			if ( G(x_modem_mode) == MODEM_FAX )		// fax mode (V.17 or V.34)
			{
#if defined (CLASS2_FAX) || !defined (CS_MODEM)
#if defined (COPERNICUS) || defined (SA_DIGITAL)
				// Download glitchless IDLE workaround
				DOWNLOAD_DSP(wV17_IDLE);
#endif
#if !defined (CS_MODEM)
				dp_ringback_init( ) ;
#endif
				dp_fax_cng_tone_cmd () ;
				G(dp_state) = DP_FAX_CNG_TONE ;
				G(dp_timer1) = x_current_time () ;
#endif // CLASS2_FAX
			}
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			else if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
			{
				G(x_modem_state) = MS_OFFHOOK ;
				if ((dp_read_dsp_ram(FDSP_CNTRL_ADDR) & 0x4000) == 0)// in hdsp
				{
					// turn on the tone detectors
					dp_write_dsp_ram ( 0x85, 0x9205 ) ;
					dp_ringback_init( ) ;
				}
				else
					dp_write_dsp_ram ( 0x85, 0x1205 ) ;

				if ( dp_local_phone_detect () == FALSE ) // on-hook
				{
					//speaker agc threshold
					dp_write_dsp_ram ( SPKR_THRESHOLD_ADDR, 0x40 ) ;
					G(dp_state) = DP_SPEAKER_PHONE_HDX ; 
				}
				else
				{
					G(dp_state) = DP_SPEAKER_PHONE_WAIT ;
				}
				x_send_mail ( AT_OK, AT_TASK, NULL, 0 ) ;
			}
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			else if ( G(x_modem_mode) == MODEM_VOICE )
			{
				if ( (G(dp_dial_string)[0] == 0)
					 || (((G(dp_dial_string)[0] == 'T')
						  ||(G(dp_dial_string)[0] == 'P'))
						 && (G(dp_dial_string)[1] == 0)) )
				{
					G(S).ModemOptions.VoiceLineSelection = 1 ;
					G(x_modem_state) = MS_TAD_FAR ;
					dp_start_tad( TAD_IDLE ) ;
					G(dp_state) = DP_VOICE ;
					x_send_mail ( AT_OK, AT_TASK, NULL, 0 ) ;
					G(dp_timer) = x_current_time () ;
				}
				else
				{
					dp_detect_tones_cmd () ;
					dp_ringback_init( ) ;
					G(dp_state) = DP_RINGBACK ;
					G(dp_timer1) = x_current_time () ;
				}
			}
#endif  // VOICE
			else /* data mode */
			{
				// download V32bis turbo1, turbo2, turbo3 code not in ROM
				dp_download_V32Turbo();

				if (G(S).ModemOptions.DataCallingTone	// s35=1
					&& !G(dp_calling_tone_disable))		// '^' disabled
				{
					dp_detect_tones_cmd () ;
					dp_ringback_init () ;
					x_debug_msg ( "DP - xmiting calling tone" ) ;
					dp_calling_tone_cmd () ;
					if ( G(S).ModemOptions.V42 == V42_SYNC_BUFFERED ) 
						G(dp_state) = DP_DATA_CALL_TONE ;
					else
						G(dp_state) = DP_ANSWERTONE ;
				}
				else    
				{
					// Not sending data calling tone.
					dp_detect_tones_cmd();
					dp_ringback_init( ) ;
					x_debug_msg("DP - going to detect answertone");
					cs_debug_liv(DP_GOING_TO_DETECT_ANSWER_TONE);
					G(dp_state) = DP_ANSWERTONE ;
				}
				G(dp_timer1) = x_current_time () ;
			}
			break ;

#ifdef VOICE
		case DP_RINGBACK :
			if ( dp_ringback_detected () == TRUE )
			{
				G(S).ModemOptions.VoiceLineSelection = 1 ;
				G(x_modem_state) = MS_TAD_FAR ;
				dp_start_tad( TAD_IDLE ) ;
				G(dp_state) = DP_VOICE ;
				x_send_mail ( AT_OK, AT_TASK, NULL, 0 ) ;
				G(dp_timer) = x_current_time () ;
			}
			else if ( ( G(S).ModemOptions.BusyToneDetect ) &&
					  ( dp_busy_tone_detected () == TRUE ) ) 
			{
				G(dp_state) = DP_CALL_FAILURE ;
				G(x_dial_residual) = MR_BUSY_SIGNAL ;
			}
			else if ( x_elapsed_long_time( G(dp_long_timer) ) >=
							( 10 * (word)G(S).ModemOptions.NoAnsTimeOut ) )
			{
				x_debug_msg ( "DP - no answer" ) ;
				G(dp_state) = DP_CALL_FAILURE ;
				G(x_dial_residual) = MR_NO_ANSWER_TONE;
			}
			break ;
#endif
		case DP_DATA_CALL_TONE :                
			if ( x_elapsed_time ( G(dp_timer1) ) >= MS600 )
			{
				dp_detect_tones_cmd () ;
				G(dp_state) = DP_ANSWERTONE ;
				G(dp_timer1) = x_current_time () ;
			}
			break ;

		case DP_ANSWERTONE :
			// We are originating modem waiting for answer tone.
			if ( G(dp_ringback_cycles) == 0 )
			{
				 dp_ringback_detected ();
			}
			if ((((G(S).ModemOptions.DataCallingTone == 0)
				  || (G(S).ModemOptions.V42 == V42_SYNC_BUFFERED))
				 && ( dp_answer_tone_detected () == TRUE) )
				||
				( (x_elapsed_time (G(dp_timer1)) >= MS600)
				  && (dp_answer_tone_detected () == TRUE) ) )
			{
				x_debug_msg("DP - answer tone detected");
				cs_debug_liv(DP_ANS_TONE_DETECTED);
				dp_originate_cmd();
#ifdef HOMOL
				if ( G(S).ModemOptions.BlackListFlag )
					dp_update_blacklist( G(dp_dial_string), DP_SUCCESS ) ;
#endif
			}
			else if (G(S).ModemOptions.BusyToneDetect &&
					 (dp_busy_tone_detected () == TRUE) )
			{
				G(dp_state) = DP_CALL_FAILURE;
				G(x_dial_residual) = MR_BUSY_SIGNAL;
#ifdef HOMOL
				if ( G(S).ModemOptions.BlackListFlag ) 
				{
					x_debug_msg("DP - data call busy: ineffective call") ;
					dp_update_blacklist( G(dp_dial_string), TROUBLE ) ;
				}
#endif
			}
			else if (x_elapsed_long_time(G(dp_long_timer)) >= 
					 (10 * (word)G(S).ModemOptions.NoAnsTimeOut) )
			{
				x_debug_msg("DP - no answer tone");
				cs_debug_liv(DP_NO_ANS_TONE);
#if !defined (CS_MODEM)
				G(x_status).TerminationCause = 2 ;	// no answer tone
#endif
#if defined (V80) && !defined (CS_MODEM)
				dp_v8_orig_no_ans_msg () ;
#endif //v80
				G(dp_state) = DP_CALL_FAILURE ;
				G(x_dial_residual) = MR_CD_DISCONNECT ;
#ifdef HOMOL
				if ( G(S).ModemOptions.BlackListFlag ) 
				{
					if ( G(dp_ringback_cycles) > 0 )   // ring back detected
					{
						dp_update_blacklist( G(dp_dial_string), ERRONEOUS);
					}
					else
					{
						dp_update_blacklist( G(dp_dial_string), TROUBLE);
					}
				}
#endif
			}
#if defined (V8BIS) || defined(VPCM_CLIENT)
			else if ((v8bis_datacall_dualtones_detect() == TRUE)
					 || (G(S).ModemOptions.Rate56K == 250))
			{
				// set s38 = 250 to skip v8bis for 56k testing
				x_debug_msg("dp - detected V.8bis dual tones");
				if (dp_v8bis_originate() == FALSE)
				{
					// stay in same state to detect answer tone
					// need to setup tone detector again
					dp_detect_tones_cmd();
				}
			}
#endif	//V8BIS
#if defined(V80)
			else if ( ( ( ( G(S).ModemOptions.V42 == V42_SYNC_BUFFERED )
						&& ( G(S).ModemOptions.DataCallingTone ) )
					)
					&& ( x_elapsed_time (G(dp_timer1)) >= SECOND2 ) )
			{
					x_debug_msg ( "DP - xmiting calling tone" ) ;
					dp_calling_tone_cmd () ;
					G(dp_state) = DP_DATA_CALL_TONE ;
					G(dp_timer1) = x_current_time () ;
			}
#endif // V80
			else if ( x_elapsed_time (G(dp_timer1)) >= SECOND2_6 )
			{
				// if data calling tone (or) v.8 ci tone
				if (G(S).ModemOptions.DataCallingTone		  // s35=1
					&& (G(dp_calling_tone_disable) == FALSE)) // '^' disabled
				{
					x_debug_msg("DP - xmiting calling tone");
					dp_calling_tone_cmd();
					G(dp_timer1) = x_current_time();
				}
			}
			break ;

#if defined(CS_V110)
		case DP_V110_START:
			G(x_modem_originate) = FALSE;
			x_send_mail(DP_IO_V110, IO_TASK, NULL, 0);
			G(dp_state) = DP_V110_DATA ;
			G(dp_timer) = x_current_time () ;
			cs_v110_init();
			G(x_modem_state) = MS_ON_DIAL ; 
			break;

		case DP_V110_DATA:
			break;
#endif	// CS_V110

		case DP_ANSWERING :
			// Answering modem:  usually get here from MC_ANSWER cmd.
			// download V.32bis turbo1, turbo2, turbo3 code not in ROM
			dp_download_V32Turbo();
#ifdef DC0
			cell_answer(); // if direct connect, send response.
#endif
            if( G( dp_daa_is_perseus ))
            {
			    if (dp_psd_chk())
			    {
				    G(dp_state) = DP_CALL_FAILURE ;
				    // user action aborted call
				    G(x_status).ud_TerminationCause = UD_TC_ANY_KEY_ABORT;
				    G(x_dial_residual) = MR_CD_DISCONNECT ;
				    break;
			    }
            }
			dp_offhook_cmd();
			G(x_modem_originate) = FALSE;
			UART_ri_off();
			// Start billing delay timer here, do auto-answer &
			// billing delay in parallel
#if defined (CLASS2_FAX) || !defined (CS_MODEM)
			G(dp_timer) = x_current_time();
			init_cng_detect ();		          // Start CNG detect if enabled
			G(dp_state) = DP_AUTO_ANSWER;
			break;

		case DP_AUTO_ANSWER:
			if ( !look_4_cng () )    // Still looking for CNG tone?
			{
				if (x_elapsed_time (G(dp_timer)) >= 10000)    // Wait up to 10 seconds for any carrier
				{
					G(dp_state) = DP_CALL_FAILURE ;
					G(x_dial_residual) = MR_CD_DISCONNECT ;
				}

				break;	// Wait until call type (FAX/DATA) is determined
			}
#endif
			if ( G(x_modem_mode) == MODEM_FAX ) // fax mode
			{
#if defined(COPERNICUS) || defined(SA_DIGITAL)
				DOWNLOAD_DSP(wV17_IDLE);      // Download Glitchless IDLE workaround
#endif
#if defined(V34_FAX)
				set_fax_modulation (); // Set mod. for Class 2/2.0/2.1 FAX

				if( NON_V34 != G(x_fax_v34mode) ) // V.34 fax mode
				{
					// look for abort
					x_send_mail(DP_IO_DIAL_OR_ANSWER, IO_TASK, NULL, 0);
					G(dp_state) = DP_DATA_WAIT ;
					x_set_current_time ( &G(dp_long_timer) ) ;
				}
				else	// V.17 Fax...continue as usual
#endif // V34_FAX
					G(dp_state) = DP_FAX_WAIT;
			}
#ifdef VOICE
			else if (G(x_modem_mode) == MODEM_VOICE)
			{
				G(S).ModemOptions.VoiceLineSelection = 1 ;
				G(x_modem_state) = MS_TAD_FAR ;
				dp_start_tad( TAD_IDLE ) ;
				G(dp_state) = DP_VOICE ;
				x_send_mail ( AT_OK, AT_TASK, NULL, 0 ) ;
			}
#endif
			else    // data mode
			{
				x_send_mail(DP_IO_DIAL_OR_ANSWER, IO_TASK, NULL, 0);
				G(dp_state) = DP_DATA_WAIT ;
				x_set_current_time ( &G(dp_long_timer) ) ;
			}
			break ;

		case DP_DATA_WAIT :
			// Answering modem - wait, then send answer tone, etc.
			if ((x_elapsed_time(G(dp_timer)) >= SECOND2)
				|| (G(S).ModemOptions.bV34Enable == 0))
			{
#if defined(V8BIS) && (defined(VENUS_AT_CS) || defined(CS_MODEM))
				if (dp_v8bis_answer() == TRUE)
				{
					// This is the normal path for
					// central site with K56FLEX enabled.
					G(dp_state) = DP_V8BIS_DCE_ANS;
				}
				else
#endif	//V8BIS
				{
					#ifdef VPCM_CLIENT	
					if (G(S).ModemOptions.Rate56K
						#if defined(V34_FAX)
						&& NON_V34 == G(x_fax_v34mode)
						#endif
						&& (G(S).ModemOptions.VpcmOption & BIT1))
					{
						x_debug_msg("DP - vpcm set answering mode");
						vpcm_set_answering_mode();
						vpcm_startup();
						G(dp_state) = DP_56K;
					}
					else
					#endif	//VPCM_CLIENT
					#if defined(V34_FAX)
					if( NON_V34 != G(x_fax_v34mode) )	// V.34 Fax mode
					{
						x_debug_msg("dp-V34Fax Ans");
						G(dp_state) = DP_V34FAX_ANS_DELAY;	// wait for CM startup
						G(dp_timer) = x_current_time () ;
					}
					else
					#endif // V34_FAX
					{
						#if	defined(CS_DIGITAL)
						if ( G(S).ModemOptions.Rate56K == 0 )
						{
							dp_download_monitor_nc_gain(0xdc00);
						}
						#endif	// CS_DIGITAL
						dp_answer_cmd();
						x_debug_msg("dp- send answer tone");
					}
				}
			}
			break ;

		case DP_RETRAIN_START :
			// User has requested a retrain with ato1 or ato3.
			if ( x_elapsed_time (G(dp_timer)) >= MS100 )
			{
				 // in case we did not catch the retrain state for fast rate
				 // renegotiation, go back to ON_DIAL after 100 ms 
				G(dp_state) = DP_RETRAIN ; 
				G(dp_bV34WkState) = WRK_RETRAIN ; //retrain wkarnd state. 
			}
			/* 
			 * need this line here to make sure that we have the correct
			 * G(dp_dsp_status) for the next state
			 */
			G(dp_dsp_status) = dp_regread ( DP_STATUS_REG ) ;

			G(dp_line_state) = DP_LINE_RETRAINING ;
			break ;

		case DP_RETRAIN :
			// User has requested a retrain with ato1 or ato3.
			dp_v34_workaround();
			G(dp_dsp_status) = dp_regread(DP_STATUS_REG);
			if ( dp_retrain() == FALSE )
			{
				// retrain finished
				G(dp_state) = DP_RETRAIN_OVER;
				G(dp_count) = 1 ;
				G(dp_timer) = x_current_time();
			}
			else if ( x_elapsed_time ( G(dp_timer) ) >= SECOND30 ) 
			{
				cs_insert_error_tag (0xdd00 , 0);
				x_debug_msg("DP_RETRAIN failure");
				G(dp_state) = DP_CALL_FAILURE ;
#if !defined (CS_MODEM)
				G(x_status).ud_TerminationCause = UD_TC_RETRAIN_FAIL;
#endif
				G(x_dial_residual) = MR_CD_DISCONNECT;
			}
			break ;

#if defined(V34_FAX) // {
		case DP_V34FAX_ANS_WAIT:	// wait for correct answer tone

			wtemp = dp_read_dsp_ram( 0x0831 );	// get tone detect status

			if( wtemp == 0x01 )			// ANSam tone
			{
				x_debug_msg( "ANSam Detected" );
				at_v25a8a_ind( 0x01 );	// Report ANSam detection
				G(dp_state) = DP_V34FAX_V8WAIT;
				G(dp_timer1) = x_current_time();	// for debug timer
				G(dp_timer) = x_current_time();
			}
			else if( wtemp == 0x02 )	// CED tone
			{
					// start V.17 fax recv to get DIS
				x_debug_msg( "CED Detected" );
				at_v25a8a_ind( 0x02 );		// Report CED detection
				dp_v34fax_to_v17rx();		// get ready to rcv 300bps.
			}
			else if( x_elapsed_time( G(dp_timer) ) > 10000 )	// timeout
			{
				G(dp_state) = DP_CALL_FAILURE;
			}
			break;

		case DP_V34FAX_ANS_DELAY:	// wait before sending ANSam
			if( x_elapsed_time( G(dp_timer) ) > 1000 )
			{
				dp_write_dsp_ram( 0x1fd9, 0x0 );	// detect ANSam mode
				dp_v34fax_ans();					// start v34 answer
				G(dp_state) = DP_V34FAX_CMWAIT;		// wait for CM/JM exchange
				G(dp_timer) = x_current_time();
				G(dp_timer1) = x_current_time();	// for debug timer
			}
			break;

		case DP_V34FAX_CMWAIT:	// started ANSam generation...wait for CM
								// DP has a .2 second startup delay for ANSam.
								// Send 5 seconds of ANSam (V.8 s8.2.2).
			if( x_elapsed_time( G(dp_timer) ) > (5200) )
			{
				x_debug_msg("\n\rNo V8.\n\r");
				dp_v34fax_to_v17tx();	// get ready to send DIS.
			}
			else if( dp_read_dsp_ram(0x3a) & 0x8000 ) // V.8 Sequence Started
			{
				x_debug_msg("\n\rV8 Neg Start");
				G(dp_state) = DP_V34FAX_V8WAIT;
				G(dp_timer) = x_current_time();
			}
			break;

		case DP_V34FAX_V8WAIT :		// wait for V.8 Neg to complete
			wtemp = dp_read_dsp_ram( 0x0800 );	// get V8 status
			if( wtemp & 0x8000 )	// bit 15 indicates v8 complete
			{
				x_debug_msg("\n\rV8 Complete=");
				sendHexWord( wtemp );
				sendCrLf();

				G(dp_state) = DP_V34FAX_PHASE3;	// assume we are V34 fax
				G(dp_timer) = x_current_time();

						// Determine final call function.
				G(x_fax_v34mode) = NON_V34 ;
				if( (wtemp & 0x0007) == 4 ) // Calling Terminal Transmits
				{
					G(x_fax_v34mode) =
						G(x_modem_originate) ? V34_SOURCE : V34_RECEIVE;
				}
				else if( (wtemp & 0x0007) == 5 ) // Calling Terminal Receives
				{
					G(x_fax_v34mode) =
						G(x_modem_originate) ? V34_RECEIVE : V34_SOURCE;
				}
				else
				{
					G(dp_state) = DP_CALL_FAILURE; // Bad Call Funct - Not Fax
				}

				if( G(x_fax_v34mode) != NON_V34 )	// Call Funct OK...
				{			// check for V34 fax (or v17 fax)
					if( (wtemp & 0x00f0) != 0x0020 )	// not V34 fax?
					{
						if( TRUE == G(x_modem_originate) )
							dp_v34fax_to_v17rx();	// start V17 rcv to get DIS
						else
							dp_v34fax_to_v17tx();	// start V17 xmit to send DIS
					}
				}
				at_v25a8m_ind();	// echo V.8 option reg to DTE
			}

			else if( x_elapsed_time(G(dp_timer)) > 10000 )	// 10 seconds (V.8 time-out?)
			{
				x_debug_msg ("Fallback to non-V.34 FAX");

				if( TRUE == G(x_modem_originate) )
					dp_v34fax_to_v17rx ();	// Start V17 receive to get DIS

				else
					dp_v34fax_to_v17tx ();	// Start V17 transmit to send DIS
			}

			break;

		case DP_V34FAX_PHASE3:
				// Phase3 was started in either dp_v34fax_orig() or
				// dp_v34fax_ans().  This state waits for the DSP to
				// complete phase 3 training as indicated by the ST flag.
				//
				// Answer Side: If no ST flag within 20s, abort the call.
			if( dp_read_dsp_ram(0x1fd8) ) // short train flag
			{
				x_debug_msg( "\r\nV34p3 End=" ) ;
				sendHexWord( x_elapsed_time(G(dp_timer)) );
				sendCrLf();

				dp_download_v34p2();		// download Phase4 code
				dp_hdlc_mode();				// set for HDLC mode

				G(x_fax_v34channel) = CONTROL_CHANNEL;
				G(x_fax_train) = SHORT_TRAIN;		// default to STs
				G(x_fax_state) = FAX_IDLE;			// trigger CONNECT message
				G(dp_timer1) = x_current_time() ;	// debug
				G(dp_timer) = x_current_time();
				G(dp_state) = DP_V34FAX_DATAWAIT;
			}
			else if( x_elapsed_time(G(dp_timer)) > 20000 )	// 20 seconds
			{
				// (This should never happen).
				// Note that all fallbacks from V34 Fax to V17 fax will
				// occur based on the V8 negotiation, above.  Once the
				// code gets to looking for the ST flag, we *are* V34 Fax.
				// A failure of ST flag is a total call failure.
				x_debug_msg("\r\nNo ST Flag...Phase 2 Failed!\r\n");
				G(dp_state) = DP_CALL_FAILURE; // Bad Call Funct - Not Fax
			}
			break;

		case DP_V34FAX_TEST_ANSam:
			if (dp_read_dsp_ram (0x00B7) >= 10)  // V25_counter almost equal to 12?
				dp_write_dsp_ram (0x00B7, 0);      // Reset to zero

			break;
#endif // } V34_FAX

		case DP_TRAINING :
			// We come here in answer or originate mode for V.34 and
			// below data.  Training in first time startup.  Connect
			// message has not been given yet.  STARTUP command has
			// already been given to the data pump.  We'll wait for
			// the data pump to connect or a time out.
			#if defined(SA_QMP_RX_PATCH)
			sa_dspInitQMP( V34_MODE );
			#endif

			if (dp_dial_connect_success() == TRUE)
			{
				G(dp_state) = DP_ON_DIAL;
				G(dp_line_state) = DP_LINE_CONNECTED;  // done with training
				G(x_modem_state) = MS_ON_DIAL;
				G(dp_timer1) = G(dp_timer) = x_current_time () ;
				x_send_mail ( DP_IO_CONNECT, IO_TASK, NULL, 0 ) ;
#ifdef HOMOL
				if (G(S).ModemOptions.BlackListFlag)
					dp_update_blacklist(G(dp_dial_string), DP_SUCCESS);
#endif
			}
			else if (x_elapsed_long_time(G(dp_long_timer)) >=
						  (10 * (word)G(S).ModemOptions.NoAnsTimeOut) )
			{
				cs_insert_error_tag (0xde00 , 0);
				x_debug_msg("DP_TRAINING failure");
#if !defined (CS_MODEM)
				G(x_status).TerminationCause = 3 ;	// training failure
#endif
				G(dp_state) = DP_CALL_FAILURE;
				G(x_dial_residual) = MR_CD_DISCONNECT;
			}
			dp_dsp_sptr_check();
			break ;

		case DP_RETRAIN_OVER :
			// We get here from either DP_RETRAIN
			// or DP_V34_RETRAIN when we've made it
			// back into data mode.
		{
			byte old_dp_count = G(dp_count);
			cs_msi_update();// Update the Modem Status Indicator to the HOST
			dp_v34_workaround();
			if ( (x_elapsed_time ( G(dp_timer) ) >= MS200)
				 && dp_init_modem_connection()
				)
			{
				// dp_init_modem_connection() cleared
				G(dp_count) = old_dp_count;

				dp_modem_rate();
				if (G(dp_count))
				{
					// Send CONNECT message (with potentially new line
					// rates) to DTE.
					dp_get_line_rate();
					x_send_mail(AT_IO_ON_LINE, IO_TASK, NULL, 0);
				}

				// send mail for io-sync mode - after line rate is set
				x_send_mail(DP_IO_RETRAIN_OVER, IO_TASK, NULL, 0);
				G(dp_state) = DP_ON_DIAL;
				G(dp_line_state) = DP_LINE_CONNECTED;
				x_debug_msg("dp - on-dial state");
			}
			else
			{
				G(dp_count) = old_dp_count;
			}
			break;
		}

		case DP_V34_RETRAIN :
			// V.34 retrain NOT initiated by the user.
			// Could be because remote side issued retrain
			// or because we're retraining due to line conditions.
#if	defined (CS_MODEM) || defined (COPERNICUS)
			dp_write_dsp_ram(AP_DPRAM_BAUD, CHK_VF_PP);
#endif	//defined (CS_MODEM) || defined (COPERNICUS)
			dp_v34_workaround();
			G(dp_dsp_status) = dp_regread(DP_STATUS_REG);
			if ( dp_retrain() == FALSE )
			{
				G(dp_timer) = x_current_time();
				G(dp_state) = DP_RETRAIN_OVER;
				G(dp_count) = 0;
			}
			else
				dp_dsp_sptr_check();
			break ;

		case DP_ON_DIAL :
			// for Dragnet in polled mode - check for DSP I/O
			DP_CHKDSP() ;

#if defined(CIDCW)
			if (G(dp_CallWaitingEnable) != 2)
			{
				if ((wtemp = dp_read_dsp_ram(0x003a)) & 0x8000)
					dp_check_call_waiting(wtemp);
			}
#endif

			// Fallback if there are too many lapm errors.
			if (dp_lapm_error_check())
			{
				// Receive side needs ratechange
#if defined(SA_DIGITAL)
				word reg, drate;

				// Turn off automatic bit rate selection...
				reg = dp_read_dsp_ram(0x0821);
				//printf("Before: 0x0821 = 0x%x\n", reg);
				reg |= BIT12;
				reg &= ~BIT3;
				dp_write_dsp_ram(0x0821, reg);
				//printf("After:  0x0821 = 0x%x\n", reg);

				// debug
				//reg = dp_read_dsp_ram(0x080d);
				//printf("0x080d = 0x%x\n", reg);

				// ...and reduce received bitrate
				reg = dp_read_dsp_ram(0x080c);
				//printf("Before: 0x080c = 0x%x\n", reg);
				drate = ((reg & 0x003c) >> 2);
				drate = (drate == 14) ? 12 : drate-1;
				reg &= 0xffc3;
				reg |= (drate<<2);
				dp_write_dsp_ram(0x080c, reg);
				//printf("After:  0x080c = 0x%x\n", reg);

				x_debug_msg("dp - slapping him back, too many CRC's");
				G(dp_line_state) = DP_LINE_RETRAINING ;
				G(dp_state) = DP_V34_RETRAIN;
				G(dp_timer) = x_current_time () ;
				dp_modem_command ( FAST_RATE_CHANGE, 0, 0 ) ;
#else
				G(dp_bFallForward) = 2 ; // indicates a local fallback.
				dp_rate_change_cmd(1);
#endif
				cs_insert_error_tag ( 0xed00 , 0 );
				break;
			}

#if defined (COPERNICUS) // || defined (SA_DIGITAL)
			if (dp_tx_lapm_error_check())
			{
				dp_lapm_error_check_init (); 
				// Fallback if there are too many lapm transmit errors.
				G(dp_cs_local_retrain_ratechange) = 1;
				G(dp_s37_changed) = 1;
				G(S).ModemOptions.DialLineRate = ((dp_read_dsp_ram(0x36) & 0x1f00)>>8)+2;
				dp_fast_retrain_cmd () ;
				G(dp_state) = DP_V34_RETRAIN;
				G(dp_timer) = x_current_time () ;
				cs_insert_error_tag ( 0xec00 , 0 );
				break;
			}
#endif //COPERNICUS
			if (x_elapsed_time ( G(dp_timer) ) >= MS500 )
			{
				// normal periodic things we do while on dial.
				dp_modem_rate();
				if (dp_retrain() == TRUE)		// retraining??
				{
					// If we're in the middle of V.42 disconnect
					// then we'll assume that this retrain
					// isn't real.  Probably the other end hung
					// up on us before it acknowledged the DISC
					// command.
					if (lapm_disconnecting())
					{
						x_debug_msg("dp - retrain lapm_disconnecting()");
						G(dp_state) = DP_DISCONNECT;	// don't do cleardown
						x_send_mail_dp1(V42_LOCAL_DISC);
					}
					else
					{
						// disable v.80 dsp patch (or) any other dsp workaround
						dp_disable_workaround () ;
#ifdef DC0
						enable_cell_filter() ;
#endif
#ifdef CS_ETC
						if(G(cell_active))
							enable_cell_filter();
#endif
#if defined (COPERNICUS) || defined (SA_DIGITAL)
						if (G(dp_cs_local_retrain_ratechange))
						{
							LOCAL_RR_INCREMENT;
							G(dp_cs_local_retrain_ratechange) = 0;
						}
						else									
#endif
						{										
							if (dp_read_dsp_ram(0x3a) & 0x2) // retrain 
							{
#if !defined (CS_MODEM)
								REMOTE_RET_INCREMENT ;
#endif
								#if defined(CS_DIGITAL)
								// near canceller workaround
								dp_download_monitor_nc_gain(0xdc01);
								#endif
							}
#if !defined (CS_MODEM)
							else
								REMOTE_RR_INCREMENT;
#endif
						}
						 //retrain wkarnd state.
						G(dp_bV34WkState) = WRK_RETRAIN ;
						G(dp_count) = 1 ;
						G(dp_state) = DP_V34_RETRAIN ;
						G(dp_line_state) = DP_LINE_RETRAINING ;
						G(dp_timer1) = x_current_time () ;
						// send mail for io-sync mode - indicate retrain
						x_send_mail ( DP_IO_RETRAIN_START, IO_TASK, NULL, 0 );
						x_debug_msg ( "dp - retrain detected" ) ;
					}
				}
				else if (dp_carrier_loss() == TRUE)
				{
					if (lapm_disconnecting())
					{
						x_debug_msg("dp-assume remote disconnect(cl)");
						G(dp_state) = DP_DISCONNECT;	// don't do cleardown
						x_send_mail_dp1(V42_LOCAL_DISC);
					}
					else if (x_elapsed_time ( G(dp_timer) ) >= 
							  ( 100 * (word)G(S).ModemOptions.NoCarrierDisc ))
					{
						cs_insert_error_tag ( 0xdb00 , 0 );
						x_debug_msg("dp - lost carrier");
						G(dp_state) = DP_CALL_FAILURE ;
#if !defined (CS_MODEM)
						G(x_status).ud_TerminationCause = UD_TC_NO_CARRIER;
#endif
						G(x_dial_residual) = MR_CD_DISCONNECT ;
#if !defined (CS_MODEM)
						G(x_status).TerminationCause = 1 ;	// remote terminate
#endif
					}
				}
				else
				{   
					if ( G(S).ModemOptions.AutoRate == 1 )
					{
						// Consider shifting rates up or down because
						// of good or bad MSE.
						dp_auto_rate();

						// If we have bad MSE and we're in the
						// middle of disconnecting then
						// it's likely that the remote end has
						// dropped the line.  Hang up.
						if (G(dp_count) && lapm_disconnecting())
						{
							x_debug_msg("dp-assume remote disconnect(mse)");
							G(dp_state) = DP_DISCONNECT; // don't do cleardown
							x_send_mail_dp1(V42_LOCAL_DISC);
						}
					}
					G(dp_timer) = x_current_time () ;
				}
			}
			break ;

		case DP_CALL_FAILURE :
			G(dp_state) = DP_DISCONNECT ;
			dp_onhook_cmd () ;
			G(dp_timer) = x_current_time () ;
			break ;

		case DP_DISCONNECT :
#ifdef CLAUDIA
	#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
			if ( (G(x_modem_mode) == MODEM_FAX)
				 && (G(x_modem_originate) == TRUE) )
			{
				// Originated a FAX call
				// Wait for other side to hangup
				if ( x_elapsed_time(G(dp_timer)) > 5000 )
				{
					// Disconnect call
					t1_transmit_onhook(ModemNum);
				}

				else
					break;
			}
	#endif
#endif
			// before disconnecting, make sure at least one of the
			// following is true:
			//	- the line has dropped
			//	- not waiting for a cleardown and 50ms has elapsed
			//	- 1 second has elapsed since entering this state.
			if ( (dp_line_connect() == FALSE)
				|| (!G(dp_cleardown_wait)
					 && x_elapsed_time(G(dp_timer)) > MS50)
				|| (x_elapsed_time(G(dp_timer)) > SECOND1) )
			{
				/* do an on hook again to make sure the dsp did go to its
				idle state */
#ifdef CS_ETC
				if (G(cell_active))
					etc_recall_land_setting ()	;
#endif
				G(dp_cleardown_wait) = FALSE;	// cleardown wait (jmg 121098)
				dp_onhook_cmd () ;
				G(x_modem_state) = MS_IDLE ;
				G(dp_state) = DP_IDLE ;
				x_send_mail ( DP_IO_DISCONNECT, IO_TASK, NULL, 0 ) ;
			}
			break ;
#if defined (CLASS2_FAX) || !defined (CS_MODEM)

		case DP_FAX_CNG_TONE :
			if ( x_elapsed_time ( G(dp_timer1) ) >= MS500 )
			{
				dp_detect_tones_cmd () ;
				G(dp_state) = DP_FAX_ANSWER_TONE ;
				G(dp_timer1) = x_current_time () ;
			}
			break ;

		case DP_FAX_ANSWER_TONE :
			if ( G(dp_ringback_cycles) == 0 )
			{
				dp_ringback_detected () ;
			}

			if ( ( dp_answer_tone_detected () ) == TRUE )
			{
#if !defined (CS_MODEM)
				G(x_status).ud_CallResult = UD_CS_ANSWER_TONE;
#endif
				x_debug_msg ( "DP - CED/answer tone detected" ) ;
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
				set_t30_bit (TRUE);  // Indicate Orig. mode in T.30 commands
#endif
#if defined(V34_FAX)
				set_fax_modulation ();  // Set modulation for Class 2/2.0/2.1 FAX

				if ( (NON_V34 != G(x_fax_v34mode) )	&&    // Set for V.34 Fax mode?
						 (dp_read_dsp_ram (0x28) & 0x0010) )  // V.21 Ch 2 Mark frequency detected?
				{
//					x_debug_msg ("DP - very old FAX!");
					G(x_fax_rate)    = MR_300;				// Go to 300 bps V.21
					G(x_fax_state)   = FAX_RX_HDLC;   // Receive V.21 HDLC
					G(x_fax_v34mode) = NON_V34;			  // Fallback to V.33, V.17, V.29 or V.27
				}

				if( NON_V34 != G(x_fax_v34mode) )	// V.34 Fax Start-up
				{
						// The DP has detected some 2100Hz tone.
						// Start the V34 Orig to determine if it is
						// ANSam or CED.
					dp_write_dsp_ram( 0x1fd9, 0x0 );	// set ANSam detect mode
					dp_v34fax_orig();
					G(dp_state) = DP_V34FAX_ANS_WAIT;
					G(dp_timer) = x_current_time () ;
				}
				else	// V.17 fax start-up
#endif	// V34_FAX
				{
					dp_fax_startup ( 0 ) ;
					G(dp_state) = DP_FAX_STARTUP_RX ;
					G(dp_fax_status) = IGNORE_V21_PREAMBLE;  // Ignore V.21 preamble dropouts
				}

#ifdef HOMOL
				if ( G(S).ModemOptions.BlackListFlag )
					dp_update_blacklist( G(dp_dial_string), DP_SUCCESS ) ;
#endif
				G(dp_timer) = x_current_time () ;
			}
			else if ( ( G(S).ModemOptions.BusyToneDetect ) &&
					  ( dp_busy_tone_detected () == TRUE ) ) 
			{
				x_debug_msg ( "DP - busy tone detected" ) ;
				G(dp_state) = DP_CALL_FAILURE ;
				G(x_dial_residual) = MR_BUSY_SIGNAL ;
#ifdef HOMOL
				if ( G(S).ModemOptions.BlackListFlag ) 
				{
					x_debug_msg("DP - fax call busy: ineffective call") ;
					dp_update_blacklist( G(dp_dial_string), TROUBLE ) ;
				}
#endif
			}
			else if( x_elapsed_long_time( G(dp_long_timer) ) >=
						( 10 * (word)G(S).ModemOptions.NoAnsTimeOut ) )
			{
#if defined(V34_FAX)
					// failed to detect ANS tone. report +A8A:0.
				at_v25a8a_ind( 0x00 );	// no answer tone detected
#endif
				x_debug_msg ( "DP - no answer tone" ) ;
				G(dp_state) = DP_CALL_FAILURE ;
				G(x_dial_residual) = MR_CD_DISCONNECT ;
#ifdef HOMOL
				if ( G(S).ModemOptions.BlackListFlag ) 
				{
					if ( G(dp_ringback_cycles) > 0 )   // ring back detected
					{
						x_debug_msg("DP - fax call no answer: erroneous call") ;
						dp_update_blacklist( G(dp_dial_string), ERRONEOUS ) ;
					}
					else
					{
						x_debug_msg("DP - fax call no answer: ineffective call") ;
						dp_update_blacklist( G(dp_dial_string), TROUBLE ) ;
					}
				}
#endif
			}
			/* the CNG off timer used to be 3.5sec */
			else if ( x_elapsed_time (G(dp_timer1)) >= SECOND3 )
			{
				dp_fax_cng_tone_cmd () ;
				G(dp_state) = DP_FAX_CNG_TONE ;
				G(dp_timer1) = x_current_time () ;
			}
			break ;

		case DP_FAX_STARTUP_RX :         /* receive mode */
			if (wrong_speed ())       // Wrong data rate detected?
				break;                  // DP state is now idle

			if (dp_regread (DP_EIA_REGISTER) & 0x04)   // Carrier detected?
			{
				G(x_line_rate) = G(x_fax_rate);  // Make rates identical; suppresses +FCERROR message
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
				if (CLASS_2_OR_20)
				{
//					G(x_line_rate) = G(x_fax_rate);  // Make rates identical; suppresses +FCERROR message
					G(dp_state) = DP_NULL;
				}

				else
#endif
					G(dp_state) = DP_FAX_RECEIVE ;

				G(x_modem_state) = MS_ON_DIAL ;
				x_send_mail ( DP_IO_CONNECT, IO_TASK, NULL, 0 ) ;  // Send "CONNECT" to host
				G(dp_timer) = x_current_time ();	                 // Start timer for preamble delay
			}

			else  // Waiting for carrier
			{
				word time_out = SECOND10;  // Class 1, not SPAIN
#ifdef HOMOL
				if (G(S).ModemOptions.CountryId==SPAIN)  // Country code is SPAIN?
					time_out = 35000;                      // Use 35 seconds
#endif
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
				if (CLASS_2_OR_20)                       // Class 2/2.0/2.1 interface?
					time_out = 35000;                      // Use 35 seconds (T.30 timer T1)
#endif
				if (x_elapsed_time (G(dp_timer)) >= time_out)  // Time-out waiting for FAX HDLC flags?
				{
					x_debug_msg ("DP - Time-out waiting for FAX HDLC flags");
					G(x_modem_state) = MS_ON_DIAL ;
					G(x_dial_residual) = MR_CD_DISCONNECT ;
					G(dp_state) = DP_NULL ;
					x_send_mail ( DP_IO_DISCONNECT, IO_TASK, NULL, 0 ) ;
				}
			}
			break ;

		case DP_FAX_CONTINUE_RX:  // Continue to receive after carrier detected
			if (wrong_speed ())     // Modulation changes?
				break;                // Go to DP_IDLE state

			else
			{
				x_send_mail ( DP_IO_CONNECT, IO_TASK, NULL, 0 ) ;  // Send "CONNECT" to host
				G(dp_state) = DP_FAX_RECEIVE;                      // Monitor carrier gone
			}

			// ***** FALL THROUGH *****

		case DP_FAX_RECEIVE :
			if (G(dp_fax_status) & WAIT_FOR_FRH)  // Waiting for another +FRH command?
				break;                              // Don't monitor carrier or preamble

			if ( (G(dp_fax_status) & IGNORE_V21_PREAMBLE) &&  // Ignoring preamble?
					 (x_elapsed_time (G(dp_timer)) < 850) )       // Delay expired?
				break;           

			if ( ( !(dp_regread (DP_EIA_REGISTER) & 0x04) ||
				   dp_read_dsp_ram (0x1AD) ) &&  // Carrier gone?
				 (io_get_dce_rx_count () == 0 ) )// DCE Rx buffer is empty
			{
				x_debug_msg ( "DP - fax lost carrier" ) ;
				dp_fax_modem_idle_cmd();
				G(dp_state) = DP_NULL ;
#if !defined (CS_MODEM)
				G(x_status).ud_TerminationCause = UD_TC_NO_CARRIER;
#endif
				G(x_dial_residual) = MR_CD_DISCONNECT ;
				x_send_mail ( DP_IO_FAX_CARRIER_LOSS, IO_TASK, NULL, 0 ) ;
			}
			// NOTE: dp_timer1 is used by dp_fax_carrier_loss()
			break ;

		case DP_FAX_WAIT :
// It's necessary to download FAX to the DSP at this point
// so the time delay between CED and CSI/DIS doesn't exceed
// 75ms, +/- 20ms, as required by ITU T.30.

			if (!G(dp_fax_downloaded))      // Need to download FAX to DSP?
			{
				dp_download_fax ();           // Download FAX code to DSP
				G(dp_fax_downloaded) = TRUE;  // Don't download in dp_fax_startup ()
			}

			if ( x_elapsed_time ( G(dp_timer) ) >= SECOND2 )
			{
				dp_fax_ced_tone_cmd () ;
				G(dp_state) = DP_FAX_CED_TONE ;
				G(dp_timer) = x_current_time () ;
			}
			break ;

		case DP_FAX_CED_TONE :
			if ( x_elapsed_time ( G(dp_timer) ) >= SECOND3 )
			{
				x_debug_msg ( "DP - sent CED Tone for 3 seconds" ) ;

#if defined (CLASS2_FAX) || defined (CLASS20_FAX)  
				if (CLASS_2_OR_20)                        
					set_t30_bit(FALSE);	// Indicate Answer mode in T.30
#endif
					G(dp_state) = DP_FAX_CED_TONE_WAIT ;

				dp_fax_modem_idle_cmd();
				G(dp_timer) = x_current_time () ;
			}
			break ;

		case DP_FAX_CED_TONE_WAIT :
			if ( x_elapsed_time ( G(dp_timer) ) >= MS75 )
			{
				G(dp_state) = DP_FAX_STARTUP_TX ;
				G(dp_timer) = x_current_time () ;
			}
			break ;

		case DP_FAX_STARTUP_TX :         /* transmit mode */
			dp_fax_startup ( 0 ) ;
			G(x_modem_state) = MS_ON_DIAL ;
			G(x_line_rate) = G(x_fax_rate) ;
			if ( (G(S).ModemOptions.SpeakerControl == 1) ||
					 (G(S).ModemOptions.SpeakerControl == 3) )
				x_output ( IO_SPEAKER_OFF ) ;

			if ( (G(x_fax_state) == FAX_TX_HDLC)  // Datapump set to Tx HDLC frames?
#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
				 && !(CLASS_2_OR_20 && (G(x_fax_rate) > MR_300)) // Not transmitting Class 2/2.0 ECM frames?
#endif
				 )
			{
				G(dp_state) = DP_FAX_TRANSMIT_WAIT ;
				G(dp_timer) = x_current_time () ;
			}
			else
			{
				G(dp_state) = DP_NULL ;
				x_send_mail ( DP_IO_CONNECT, IO_TASK, NULL, 0 ) ;
			}
			break ;

		case DP_FAX_TRANSMIT_WAIT :      /* transmit mode */
			if ( x_elapsed_time (G(dp_timer)) >= preamble_time () )  // Preamble delay expired?
			{
				G(dp_state) = DP_NULL ;
				x_send_mail ( DP_IO_CONNECT, IO_TASK, NULL, 0 ) ;
			}
			break ;

		case DP_FAX_WAIT_SILENCE_THEN_TX:
		case DP_FAX_WAIT_SILENCE_THEN_RX:  
		case DP_FAX_WAIT_SILENCE :
			if ( (G(dp_fax_status) & RECEIVE_SILENCE) &&  // Receiving silence?
					 (dp_read_dsp_ram (0x3A) & 0x1000) )      // Any tones detected?
				G(dp_timer) = x_current_time () ;           // Restart Recv silence timer

			if ( x_elapsed_time (G(dp_timer)) >= G(ci_timer1) )
			{
				if (G(dp_state) == DP_FAX_WAIT_SILENCE_THEN_TX)
				{
					G(dp_state) = DP_NULL;   // Force startup command to execute now
					x_send_mail_dp1(FAX_STARTUP_TRANSMIT);
				}

				else if (G(dp_state) == DP_FAX_WAIT_SILENCE_THEN_RX)
				{
					G(dp_state) = DP_NULL;  // Force startup command to execute now
					x_send_mail_dp1(FAX_STARTUP_RECEIVE);
				}

				else
				{
					G(dp_state) = DP_NULL ;
					x_send_mail ( AT_OK, AT_TASK, NULL, 0 ) ;
					x_send_mail ( IO_IDLE_STATE, IO_TASK, NULL, 0 ) ;
				}
			}
			break ;
#endif	// CLASS2_FAX

		case DP_NULL :      // doing nothing
			break ;

		case DP_PERSEUS_NULL :      // doing nothing
			if ((dp_invalid_count == 0)	&&
				(dp_read_dsp_ram(0x1a00) == 0))    //valid data adc_sat_num
				x_send_mail_dp1(MC_OFFHOOK);

			if (dp_invalid_count > 0)		// detect invalid data
			{
				if (dp_read_dsp_ram(0x1a00) > 3)    //invalid data
					dp_invalid_count++ ;
				else
					dp_invalid_count = 1 ;
			}

			if ( dp_invalid_count > 5 )
			{
				x_debug_msg("Invalid data detected") ;
				//Enable buzzaro mode
				if ( ( x_elapsed_time ( dp_invalid_timer ) >= 15 )
					&& ( x_elapsed_time ( dp_invalid_timer ) <= 100 ) )
				{
					x_debug_msg("Perseus - BIO2 off");
					// Control Reg #1 with BIO2 off
					dp_write_dsp_ram ( 0x1a3f, 0x1000) ;
					dp_modem_command ( OFF_HOOK, 0, 0 ) ;
					dp_invalid_count = 0 ;  // invalid line conditions
				}
			}
			break ;

		case DP_WAIT :      // waiting for timer to expire
			if ( x_elapsed_long_time( G(dp_long_timer) ) >= 
					( 10 * (word)G(S).ModemOptions.NoAnsTimeOut ) )
			{
				G(dp_state) = DP_DISCONNECT ;
				dp_onhook_cmd () ;
				G(dp_timer) = x_current_time () ;
			}
			break ;

		case DP_OVERCURRENT :
		 	if ( !x_input(IO_OVERCURRENT_DET) )  // No over current 
			{
				if ( x_elapsed_time ( G(dp_timer) ) >= MS50 )
				{
					G(dp_timer) = x_current_time () ;
					G(dp_timer1) = x_current_time () ; 	
#ifdef VOICE
					if ( G(x_modem_mode) == MODEM_VOICE )
						G(dp_state) = DP_VOICE ;
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
					else if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
						G(dp_state) = DP_SPEAKER_PHONE_WAIT ;
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
					else
#endif 
					if ( G(S).ModemOptions.OffHookRestrict != 0 )
					{
						G(dp_state) = DP_WAIT ;
						x_set_current_time ( &G(dp_long_timer) ) ;
					}
					else
						G(dp_state) = DP_NULL ;
				}
				if ( x_elapsed_time ( G(dp_timer1) ) >= MS10 ) // ignore holes
					G(dp_timer1) = x_current_time () ; 	
			}
			else // Over current
			{
				G(dp_timer) = x_current_time () ;
				if ( x_elapsed_time ( G(dp_timer1) ) >=
							(10 * (word)G(S).ModemOptions.LoopSenseWaitTime) )
				{
		 			x_debug_msg("DP - Over current detected");
					G(x_modem_state) = MS_IDLE ;
#ifdef VOICE
					if ( ( G(x_modem_mode) == MODEM_VOICE ) ||
						 ( G(x_modem_mode) == MODEM_SPEAKER_PHONE ) )
					{
						byte dp_event_code[3];

						dp_event_code[0] = 0x10;   // DLE
						dp_event_code[1] = 'H';
						dp_event_code[2] = 0;
						x_send_at_io_data(dp_event_code);
					}
#endif 
					x_send_mail_dp1(MC_ONHOOK);
				}
			}
			break ;

		case DP_ANALOG_LOOPBACK :
			if ( dp_read_dsp_ram ( 0x3a ) & 0x0008 )    // data mode
			{
				// delay to clear garbage characters of startup
				// iomain.c clear dce rx fifo
				if ( x_elapsed_time ( G(dp_timer) ) >= SECOND1 )
				{
					G(dp_state) = DP_NULL ;
					x_send_mail ( DP_IO_CONNECT, IO_TASK, NULL, 0 ) ;
				}
			}
			else
			{
				G(dp_timer) = x_current_time () ;
			}
			break ;

#ifdef VOICE
		case DP_VOICE :     // for voice line mode 
			// send detected tones and local hook condition to DTE
			if ( dp_tones_detected() == TRUE )
			{
				G(dp_timer) = x_current_time () ;
			}
			else
			{
				dp_silence_detected() ; // silence detection 
			}
			dp_local_phone_detect() ;
			dp_tad_monitor_hec () ;
			break ;

#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
		case DP_SPEAKER_PHONE_WAIT :
#ifdef V80
#ifdef V8BIS
			if ( v8bis_dualtones_detect () == TRUE )
			{
				G(dp_state) = DP_V8BIS ;
				x_debug_msg ("dp - go to DP_V8BIS state" );
			}
#endif	//V8BIS
			if ( dp_v8_tone_detected () == TRUE )
			{
				G(dp_state) = DP_V8_RX_INIT_SPKR ;
			}
#endif // V80
			if ( ( G(S).ModemOptions.RingCount > 0 )       // incoming call
				 && ( x_elapsed_time ( G(dp_timer1) ) < SECOND10 ) )
				dp_detect_fax_data () ;
			// wait for local phone to go on-hook
			if ( dp_local_phone_detect() == FALSE )
			{
				//speaker agc threshold
				dp_write_dsp_ram ( SPKR_THRESHOLD_ADDR, 0x40 );
				G(dp_state) = DP_SPEAKER_PHONE_HDX ;
				x_debug_msg("DP - Local phone on_hook, switching mode") ;
			}
			break ;

		case DP_SPEAKER_PHONE_HDX :
#ifdef V80
#ifdef V8BIS
			if ( v8bis_dualtones_detect () == TRUE )
			{
				G(dp_state) = DP_V8BIS ;
				x_debug_msg ("dp - go to DP_V8BIS state" );
			}
#endif	//V8BIS
			if ( dp_v8_tone_detected () == TRUE )
			{
				G(dp_state) = DP_V8_RX_INIT_SPKR ;
			}
#endif // V80
			dp_detect_fax_data () ;
			if ( dp_local_phone_detect() == TRUE )
			{
				dp_stop_fdsp () ;
				G(dp_state) = DP_LOCAL_PHONE_INIT ;
			}
			else
			{
				G(dp_state) = DP_SPEAKER_PHONE_CANCEL ;
			}
			break ;

		case DP_SPEAKER_PHONE_CANCEL :
#ifdef V80
#ifdef V8BIS
			if ( v8bis_dualtones_detect () == TRUE )
			{
				G(dp_state) = DP_V8BIS ;
				x_debug_msg ("dp - go to DP_V8BIS state" );
			}
#endif	//V8BIS
			if ( dp_v8_tone_detected () == TRUE )
			{
				G(dp_state) = DP_V8_RX_INIT_SPKR ;
			}
#endif
			if ( dp_local_phone_detect() == TRUE )
			{
				dp_stop_fdsp () ;
				G(dp_state) = DP_LOCAL_PHONE_INIT ;
			}
			if ( G(S).ModemOptions.SpeakerPhoneMode < 2 )  //FDX
			{
				dp_detect_fax_data () ;
				if ( dp_cancellation() )
				{
					dp_switch_fdsp () ;     // fdsp mode
					G(dp_state) = DP_SPEAKER_PHONE ;
				}
			}
			else
			{
				dp_switch_hdsp () ;     // hdsp mode with aec cleared
				G(dp_state) = DP_SPEAKER_PHONE ;
#ifdef V8BIS
				if ( G(S).ModemOptions.V8bis == V8BIS_DTE_CONTROL )
				{
					// DTE controlled V.8bis negotiation enabled
					v8bis_init () ;
				}
#endif //V8BIS
			}
			break ;

		case DP_SPEAKER_PHONE :
#ifdef V80
#ifdef V8BIS
			if ( v8bis_dualtones_detect () == TRUE )
			{
				G(dp_state) = DP_V8BIS ;
				x_debug_msg ("dp - go to DP_V8BIS state" );
			}
#endif	//V8BIS
			if ( dp_v8_tone_detected () == TRUE )
			{
				G(dp_state) = DP_V8_RX_INIT_SPKR ;
			}
#endif  // V80
			dp_detect_fax_data () ;
			// detect local phone hook condition
			if ( dp_local_phone_detect() == TRUE )
			{
				dp_stop_fdsp () ;
				G(dp_state) = DP_LOCAL_PHONE_INIT ;
			}
			else
			{
				dp_spk_echotest () ;
			}
			break ;
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM

		case DP_LOCAL_PHONE_INIT :
			dp_onhook_cmd () ;
			G(dp_state) = DP_LOCAL_PHONE_DETECT ;
			G(x_modem_state) = MS_OFFHOOK ;
			G(S).ModemOptions.VoiceLineSelection = 0 ;
			// Stay in VOICE mode after we stop fdsp
			G(x_modem_mode) = MODEM_VOICE ;
			break ;

		case DP_LOCAL_PHONE_DETECT :
			// wait till the local phone goes onhook - before going to
			// idle and then to sleep
			if ( dp_local_phone_detect() == FALSE )
			{
				G(x_modem_state) = MS_IDLE ;
				G(dp_state) = DP_IDLE ;
			}
			break ;

		case DP_GENERATE_TONES :
			if (G(dp_count) == TRUE)
			{
				if (x_elapsed_time ( G(dp_timer) ) >
					10 * (word)G(S).ModemOptions.HookFlashTime )
				{
					x_debug_msg("DP - end hook flash pulse");
					dp_spkpn_offhook () ;
					G(dp_count) = DONTKNOW ;
					G(dp_timer) = x_current_time () ;
				}
			}
			else if ( G(dp_count) == DONTKNOW )
			{
				if ( x_elapsed_time ( G(dp_timer) ) >
					 10 * (word)G(S).ModemOptions.HookFlashTime )
				{
					x_debug_msg("DP - waiting after flash pulse");
					G(dp_count) = FALSE ;
					/* keep processing VTS string */
					G(dp_timer) = x_current_time () ;
					dp_vts () ;
				}
			}
			else  if (x_elapsed_time (G(dp_timer)) >= 
					  (10*G(S).ModemOptions.BeepToneTimer+
					   G(S).ModemOptions.DtmfDialSpeed))
			{
				/* keep processing VTS string */
				G(dp_timer) = x_current_time () ;
				dp_vts () ;
			}
#ifdef KORTEX
			// SES - if getting remote access
			else if	(am_g_owner_state == AM_OWNER_GET_PWD)
			{					// password, don't wait after beep
				G(dp_timer) = x_current_time();		// to accept dtmf digits.
				dp_vts () ;
			}
#endif // KORTEX
			break ;
#endif // VOICE

#if defined(V8BIS)
#if defined(VENUS_AT_CS) || defined(CS_MODEM)
		case DP_V8BIS_DCE_ANS :
			if (dp_v8bis_ans_background () == FALSE)
			{
				x_debug_msg("dp-back to v.34 answer");
				dp_answer_cmd();
			}
			break ;
#endif // Central Site
#endif	//V8BIS

#if defined (VPCM_CLIENT) && defined (V92)			//pwwlkl
		case DP_V8BIS_V92_DCE_ORIG :
			if (dp_v8bis_v92_orig_background () == FALSE)
			{
				x_debug_msg("dp-back to look for answer tone");
				dp_detect_tones_cmd();
				G(dp_state) = DP_ANSWERTONE;
			}
			break ;
#endif // VPCM_CLIENT

#if defined ( K56FLEX ) || defined ( VPCM_CLIENT ) || defined ( VPCM_SERVER )
		case DP_56K :
			dp_56k_background () ;
			break ;
#endif  // K56FLEX or V.90

#if defined (HOMOL) && defined (VOICE)
#ifdef CALLER_ID
		case DP_CID_ALERT : 
			if (dp_cid_alert_detect() == TRUE)
			{
				x_output(IO_CALLER_ID_OFF);	// de-activate cid relay
				dp_cid_cmd();
				x_send_mail ( DP_RING, IO_TASK, NULL, 0 ) ;
				G(dp_state) = DP_NULL ;
			}

			if ( ((G(S).ModemOptions.CallerIdType == 1 ) // Japan CID
				  && ( x_elapsed_time (G(dp_timer)) >= SECOND3 ))
				 || ( x_elapsed_time (G(dp_timer)) >= SECOND5 ) )
			{
			    x_debug_msg("DP- cid - ring int or past 3sec");
				x_output ( IO_CALLER_ID_OFF ) ;	// de-activate cid relay
				G(dp_timer) = x_current_time () ;
				G(x_modem_state) = MS_IDLE ;
				G(dp_state) = DP_IDLE ;
			}
			break;
#endif	//CALLER_ID
#endif	// HOMOL && VOICE

#if defined(V34_FAX) // {
		case DP_V34FAX_STARTCHANNEL :	// start V34 Fax Channel

					// Interphase delay (70ms) done in DSP.
					// StartChannel state will start the opposite channel
					// that is currently running.
					//
					// Pri to CC.
			if( PRIMARY_CHANNEL == G(x_fax_v34channel) )
			{
					// in Primary, switch to Control Channel
				dp_fax_modem_idle_cmd();	// idle DSP before CC start
				if( RATE_RENEG == G( x_fax_train ) )	// check for Rate Change
				{
						// set new Pri rate.
						// setCCRate() will follow when implemented
					setPRate( (signed char)G(x_fax_maxp) - 1, (signed char)G(x_fax_minp) - 1 );
				}

				if( TRUE == G(x_modem_originate) )
				{
// force Long Trains until fixed in DP
//if( G(S).ModemOptions.Dummy20 == 1 && G(x_fax_train) == SHORT_TRAIN )
//G( x_fax_train ) = LONG_TRAIN;
					x_debug_msg("CC Orig");
					dp_modem_command_long(GOTO_CMD,
								0xe0, 0x00, ORIGINATE, G( x_fax_train ));
				}
				else	// answer side
				{
//if( G(S).ModemOptions.Dummy20 == 1 && G(x_fax_train) == SHORT_TRAIN )
//G( x_fax_train ) = LONG_TRAIN;
					x_debug_msg("CC Ans");
					dp_modem_command_long(GOTO_CMD,
								0xe0, 0x00, ANSWER, G( x_fax_train ));
				}
				G( x_fax_train ) = SHORT_TRAIN ;	// always return to STs
				G(x_fax_v34channel) = CONTROL_CHANNEL;
			}
			else if( CONTROL_CHANNEL == G(x_fax_v34channel) )	// CC to Pri
			{
				if( V34_SOURCE == G(x_fax_v34mode) )
				{
					x_debug_msg("Pri Tx");
					dp_write_dsp_ram( 0x0f20, 0xd804 );	// Tx Jam Command

						// debug....null out Vec1
						// to stop retrain detection.
					dp_write_dsp_ram( 0x0f22, 0x8ECE );
				}
				else // if( V34_RECEIVE == G(x_fax_v34mode) )
				{
					x_debug_msg("Pri Rx");
					dp_write_dsp_ram( 0x0f20, 0xd805 );		// Tx Jam Command
				}
				G(x_fax_v34channel) = PRIMARY_CHANNEL;
			}

			dp_hdlc_mode();						// set for HDLC mode
			G(dp_timer1) = x_current_time();	// debug wait...
			G(dp_timer) = x_current_time();
			G(dp_state) = DP_V34FAX_DATAWAIT;	// wait for data mode

			break;

		case DP_V34FAX_DATAWAIT :	// wait for data mode...
				// CC must wait for both Rcvr and Transmitter (DM and RR)
				// Pri channel only waits for transmitter (DM only)
				// Data Mode Flag -> 0x003a goes to 0x0008
				// Scrambled Ones Detect Flag (0x07D1) goes non-zero
			if( (PRIMARY_CHANNEL == G(x_fax_v34channel)
					&& dp_read_dsp_ram( 0x3a ) & 0x0008 )
				||
				( CONTROL_CHANNEL == G(x_fax_v34channel)
					&& (dp_read_dsp_ram( 0x3a ) & 0x0008)
					&& dp_read_dsp_ram( 0x07D1 ) )
			  )
			{
				if( CONTROL_CHANNEL == G(x_fax_v34channel) )
				{
					x_debug_msg("CC DataMode");
				}
				else
				{
					x_debug_msg("PRI DataMode");
				}

				dp_v34fax_dump();	// debug prints

#if defined(CS_4)
				//-----------------------------------------------------
				// will not work for CS-4: Compile error will cause
				// re-design when this feature is desired in CS-4
				//-----------------------------------------------------
# error "Feature not available on CS_4"
#else
				dp_regwrite( 0xd7, G(dp_bamil_rd7) | BIT2 ) ;	// disable Ints
					G(io_dce_rx_rptr) = G(io_dce_rx_wptr);	// flush rx buf
					G(io_dce_tx_rptr) = G(io_dce_tx_wptr);	// flush tx buf
				dp_regwrite( 0xd7, G(dp_bamil_rd7) ) ;	// (re)enable Ints

						// check DSP intr to allow rcv data interrupts.
				dp_regread( 0xb0 );
				if( dp_regread ( 0xb7 ) & 0x10 )	// CWTB1 set?
				{
					dp_regread( 0xb0 );	// double read to set HWTB1 Int
				}
#endif
#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
				if (CLASS_2_OR_20)     // Using Class 2/2.0/2.1 interface?
					signal_class2 ();    // Inform class 2/2.0/2.1 background task of connect
#endif

				if( CONTROL_CHANNEL == G(x_fax_v34channel) )
				{
						// only send CONNECT on initial CC start-up.
					if( FAX_IDLE == G(x_fax_state) )
					{
						x_send_mail ( DP_IO_CONNECT, IO_TASK, NULL, 0 ) ;  // Start FAX state machine
								// receive (answer) side sends <DLE><CTRL>
								// here on initial start-up.
						if ((V34_RECEIVE == G(x_fax_v34mode)) &&
								!CLASS_2_OR_20)                        // Class 1.0 interface?
						{
							io_put_dte_tx_char( DLE );
							io_put_dte_tx_char( CTRL_V34 );
						}
					}
					G(x_fax_state) = V34FAX_CCSTART ;	// go to CC startup
				}
				else
				{
					G(x_fax_state) = V34FAX_PRISTART ;	// go to PRI startup
				}
				io_fax_init( G(x_fax_state) );	// init fax HDLC handlers

					// turn off speaker
				if( (G(S).ModemOptions.SpeakerControl == 1) ||
	     			 (G(S).ModemOptions.SpeakerControl == 3) )
						x_output( IO_SPEAKER_OFF ) ;

				G(x_modem_state) = MS_ON_DIAL;
				G(dp_state) = DP_NULL;	// idle DP layer
			} // if(data mode)

			if( !dp_read_dsp_ram(0x1fd8) ) // short train flag
			{
				x_debug_msg( "\r\nPhase 3 Err Recovery=" ) ;
				sendHexWord( x_elapsed_time(G(dp_timer)) );
				sendCrLf();
				G(dp_timer) = x_current_time();	// restart Phase3 timer
				G(dp_state) = DP_V34FAX_PHASE3;	// back to phase3 ST wait
			}

			if( x_elapsed_time(G(dp_timer)) >= SECOND1 )
			{
				G(dp_timer) = x_current_time();
				dp_v34fax_dump();
			}

			if( x_elapsed_time(G(dp_timer1)) >= SECOND10 )
			{
				G(dp_timer1) = x_current_time();
				x_debug_msg("DataMode Failed!");
					// send <DLE><EOT> to DTE (T.31A1 B.9.4)
				io_put_dte_tx_char( DLE );
				io_put_dte_tx_char( EOT_V34 );
				dp_fax_modem_idle_cmd();
				G(dp_state) = DP_DISCONNECT ;
			}
			break;

		case DP_V34FAX_SILENCEWAIT:
					// For Pri to CC switch:
					//		send 1s for 35ms 
					// For CC to Pri switch:
					//		send 40 1s (35ms @ 1200bps) then send 1s until
					//		silence is detected.
			if( ( PRIMARY_CHANNEL == G(x_fax_v34channel)
					&& x_elapsed_time( G(dp_timer) ) > 35 )
					||
				( CONTROL_CHANNEL == G(x_fax_v34channel)
					&& x_elapsed_time( G(dp_timer) ) > 35
					&& !(dp_read_dsp_ram(0x008E) & 0x0002))	// Carrier Detect
					||
				( x_elapsed_time( G(dp_timer) ) > 500 )
			  )
			{
				dp_write_dsp_ram(0x3f, 0x01);	// mute transmitter

				x_debug_msg("SWait=");
				sendHexWord( x_elapsed_time(G(dp_timer)) );
				sendCrLf();

						// turn off Ints for PDM
#if defined(CS_4)
				//-----------------------------------------------------
				// will not work for CS-4: Compile error will cause
				// re-design when this feature is desired in CS-4
				//-----------------------------------------------------
# error "Feature not available on CS_4"
#else
				dp_regwrite( 0xd7, G(dp_bamil_rd7) | BIT2 ) ;
#endif
				if( V34_SOURCE == G(x_fax_v34mode) )
				{
					G(dp_state) = DP_V34FAX_STARTCHANNEL ;	// jump to channel start-up
				}
				else // if( V34_RECEIVE )	turnaround poll
				{
							// slam io_fax_background() into EOT
					io_fax_init( V34FAX_EOT );
					G(dp_state) = DP_NULL;
				}
			}
			break;

		case DP_V34FAX_DETECT1S:
			dp_write_dsp_ram(0x3f, 0x01);	// mute transmitter
			x_debug_msg("Detect 1s");

				// turn off Ints for PDM
#if defined(CS_4)
			//-----------------------------------------------------
			// will not work for CS-4: Compile error will cause
			// re-design when this feature is desired in CS-4
			//-----------------------------------------------------
# error "Feature not available on CS_4"
#else
			dp_regwrite( 0xd7, G(dp_bamil_rd7) | BIT2 ) ;
#endif

				// Receive DCE is switching channels.
				// Indicate start of switch to DTE.
				// If in CC, Pri is coming up.
				// If in Pri, CC is coming up.
#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
			if (!CLASS_2_OR_20)     // Not Class 2/2.0 interface?
#endif
			{
				io_put_dte_tx_char( DLE );
				if( CONTROL_CHANNEL == G(x_fax_v34channel) )	// CC to Pri
				{
					io_put_dte_tx_char( PRI_V34 );	// send <DLE><pri>
				}
				else	// in PC, switching from Primary to Control
				{
					io_put_dte_tx_char( CTRL_V34 );	// send <DLE><ctrl>
				}
			}

			G(dp_state) = DP_V34FAX_STARTCHANNEL ;	// jump to channel start-up
			break;

#endif	// } V34_FAX

	} // switch(dp_state)
} // dp_periodic_task()

/****************************************************************
Routine : dp_task
Description : The main entry routine for dp task.
Parameters in : cmd     -   the modem command to execute
		mail_ptr    -   mail text pointer (parameters)
		mail_len    -   length of text
*****************************************************************/

void dp_task ( MODEM_COMMAND cmd, byte *mail_ptr, word mail_len )
{
	switch ( cmd )
	{
		case MC_INIT :
			x_debug_msg("DP - received init command");
			dp_init_variables();				// initialize variables
			if (dp_init_modem() == TRUE)		// initialize data pump
			{
				*mail_ptr = TRUE ;
				dp_update_modem_options();
				#if defined(CS_4)
				sa_dspInitQMP(ROM_MODE);
				sa_dspInitAUX();
				#endif
			}
			else
			{
				*mail_ptr = FALSE ;             // hardware failure
			}
			break ;

		case MC_PERIODIC :      // call the periodic function
			dp_periodic_task();
#ifdef DC0
			cellular_bg () ;
#endif
			break ;

		case MC_OPTION_CHANGE :
			// called in buffered mode by iomain for option
			// changes.  could be break, async char change.
			dp_async_user_mode();
			break ;

		case MC_OFFHOOK :   /* off hook command     */
			x_debug_msg ( "DP - received offhook command" ) ;
#ifdef DC0
			cell_answer () ; // if direct connect, send response.
#endif
			dp_offhook_cmd () ;
			G(x_modem_state) = MS_OFFHOOK ;
#ifdef VOICE
			if ( G(x_modem_mode) == MODEM_VOICE )
			{
				G(x_modem_state) = MS_TAD_FAR ;
				dp_start_tad( TAD_IDLE ) ;
			}
#endif
			if ( G(S).ModemOptions.LoopSenseWaitTime != 0 )  // Over current sense on
			{
				G(dp_timer) = x_current_time () ;
				G(dp_timer1) = x_current_time () ;
				G(dp_state) = DP_OVERCURRENT ;
			}
			else
			{
#ifdef VOICE
				if ( G(x_modem_mode) == MODEM_VOICE )
					G(dp_state) = DP_VOICE ;
				else
#endif 
				if ( G(S).ModemOptions.OffHookRestrict != 0 )
				{
					G(dp_state) = DP_WAIT ;
					x_set_current_time ( &G(dp_long_timer) ) ;
				}
				else
 
                if( G( dp_daa_is_perseus ))
				{
					dp_invalid_timer = x_current_time () ;
					dp_invalid_count = 1 ;
					G(dp_state) = DP_PERSEUS_NULL ;
				}
                else
                {
					G(dp_state) = DP_NULL ;
                }
			}
			break ;

		case MC_ONHOOK :    /* on hook command */
			x_debug_msg ( "DP - received onhook command" ) ;
#ifdef HOMOL 
			if ( ( G(S).ModemOptions.BlackListFlag ) 
				 && ( G(x_modem_mode) != MODEM_SPEAKER_PHONE ) 
				 && ( G(x_modem_state) == MS_DIALING ) ) 
				dp_update_blacklist( G(dp_dial_string), TROUBLE ) ;
#endif
#ifdef VOICE
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
			{
				dp_stop_fdsp () ;
				G(x_modem_mode) = MODEM_DATA ;
			}
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
#endif
			dp_onhook_cmd () ;
#ifdef VOICE
			if ( G(x_modem_mode) == MODEM_VOICE )
			{
				//NOTE: stop_tad should follow onhook_cmd - do not change order
				dp_stop_tad () ;	
				G(x_modem_mode) = MODEM_DATA ;
			}
#endif
			G(S).ModemOptions.VoiceLineSelection = 0 ;
			G(x_modem_state) = MS_IDLE ;
			G(dp_state) = DP_IDLE ;
			G(x_fax_state) = FAX_IDLE ;
			// Set hardware dependant settings correctly following AT&F
			x_set_hardware_options () ;
			break ;

		case MC_DISCONNECT :
			x_debug_msg ( "DP - received disconnect command" ) ;
#if defined(V92_MODEM_ON_HOLD)
			if ((G(dp_mh_state) == MH_I_IDLE) || (G(dp_mh_state) == MH_R_IDLE))
			{
				// If we were in modem-on-hold states, get DSP
				// back to known state before continuing.
				G(dp_mh_state)=MH_DROP_DATA;
				dp_mh_bg();
			}
#endif
#ifdef HOMOL 
			if ( ( G(S).ModemOptions.BlackListFlag ) 
				 && ( G(x_modem_mode) != MODEM_SPEAKER_PHONE ) 
				 && ( G(x_modem_state) == MS_DIALING ) ) 
				dp_update_blacklist( G(dp_dial_string), TROUBLE ) ;
#endif
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
			{
#ifdef VOICE
				dp_stop_fdsp () ;
#endif
				dp_onhook_cmd () ;
				G(x_modem_mode) = MODEM_DATA ;
				G(x_modem_state) = MS_IDLE ;
				G(dp_state) = DP_IDLE ;
			}
			else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			{
				if ( ( G(x_modem_state) == MS_ON_DIAL ) && 
					  ( G(x_modem_mode) == MODEM_DATA ) &&
					  ( G(S).ModemOptions.HangupControl == 0 ) )
					dp_cleardown_cmd () ;
				else 
					dp_onhook_cmd () ;
				G(dp_state) = DP_DISCONNECT ;
				G(x_dial_residual) = MR_OK ;
				G(dp_timer) = x_current_time () ;	// start timer for clear down
			}
			G(x_fax_state) = FAX_IDLE ;
			break ;

		case V42_LOCAL_DISC :
			DP_PUTS("V42_LOCAL_DISC-");
		case V42_REMOTE_DISC :
			x_debug_msg("DP - V42 disc cmd");
			if ((G(S).ModemOptions.HangupControl == 0) &&
				(DP_ON_DIAL == G(dp_state)))
			{
				dp_cleardown_cmd () ;
			}
			else
			{
				dp_onhook_cmd () ;
			}
			G(dp_state) = DP_DISCONNECT ;
			/* if local sent disconnect command - ath cmd - then dial
			   residual is OK - if remote issued v42 disconnect then
			   dial residual is NO CARRIER */
			if ( cmd == V42_LOCAL_DISC )
				G(x_dial_residual) = MR_OK ;
			else
			{
				G(x_dial_residual) = MR_CD_DISCONNECT ;
#if !defined (CS_MODEM)
				G(x_status).TerminationCause = 1 ;	// remote terminate
#endif
			}
			G(dp_timer) = x_current_time () ;
			break ;

		case MC_DIAL :
#ifdef CLAUDIA
	#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
			if (CLASS_2_OR_20)               // Using 2, 2.0 or 2.1 interface?
			{
				G(x_modem_state) = MS_DIALING ;
				G(x_modem_originate) = TRUE ;
				x_send_mail(DP_IO_DIAL_OR_ANSWER, IO_TASK, NULL, 0);

				G(dp_timer) = x_current_time () ;
				G(dp_threshold) = G(S).ModemOptions.CallProgressThreshold ;
				G(dp_state) = DP_CALL_PROGRESS ;
				x_set_current_time ( &G(dp_long_timer) ) ;
//				G(data_call) = 0;   // Prevents DSP reset in SA_MAIN.C:sa_modem()
				t1_transmit_offhook (ModemNum);
				break;
			}
	#endif
#endif // CLAUDIA
			// Dial command - probably from ATDxxx
			// At this point we assume it's OK to dial
			// and just do it!
			x_debug_msg("\r\nDP - received MC_DIAL command");
#ifdef VPCM_CLIENT
			if ((MODEM_VOICE != G(x_modem_mode)) &&
				(MODEM_SPEAKER_PHONE != G(x_modem_mode)) &&
				(G(S).ModemOptions.VpcmOption ) )
			{
				// Download V.90 code.
				vpcm_download_client();
			}
#endif	//VPCM_CLIENT
            if( G( dp_daa_is_perseus ))
            {
			    if (dp_psd_chk()) // if parallel set offhook, then abort call
			    {
				    G(dp_state) = DP_CALL_FAILURE ;
				    G(x_dial_residual) = MR_BUSY_SIGNAL ;
				    break;
			    }
            }

			G(dp_state) = DP_DIAL ;
			G(dp_dial_state) = DP_DIAL_START ;
			G(x_modem_state) = MS_DIALING ;
			G(x_modem_originate) = TRUE ;
			if ( (*mail_ptr == 'L') && (*(mail_ptr + 1) == 0) )
			{
				// Redial last phone number dialed.
				if( G(dp_dial_string)[0] != 0 )
					G(dp_redial) = TRUE;   // redial, do not copy the dial new string
			}
			else
			{
				// The phone number the user wants to dial.
				x_strcpy(G(dp_dial_string), mail_ptr);
			}
			G(dp_timer) = x_current_time () ;
			x_send_mail(DP_IO_DIAL_OR_ANSWER, IO_TASK, NULL, 0);
			dp_copernicus_dial();
			break ;

		case MC_ANSWER :
			// command to answer the call.
			x_debug_msg ( "DP - received answer command" ) ;
			G(dp_line_state) = DP_LINE_TRAINING;
#ifdef DC0
			if ( G(dp_state) == DP_CELL_RING_ON )
				G(cell_ring_int) = TRUE ;
#endif
#if defined(SA_DIGITAL) && !defined(FORUM)
			G(sa_framer_state) = T0_ON_LINE ;
#endif
			G(dp_state) = DP_ANSWERING;
			G(x_modem_state) = MS_ANSWERING;
			G(dp_timer) = x_current_time();
			break ;

#if defined(CS_V110)
		case MC_V110_ANSWER:
			G(dp_state) = DP_V110_START ;
			break;
#endif

#if !defined (CS_MODEM)
		case MC_ANALOG_LOOPBACK :
			x_debug_msg ( "DP - received analog loopback command" ) ;
			G(x_modem_state) = MS_LOCAL_TEST ;
			G(dp_state) = DP_ANALOG_LOOPBACK ;
			dp_analog_loopback_cmd () ;
			dp_async_8bit_mode () ;
			break ;

		case MC_LOC_DIGITAL_LOOPBACK :
		{
			byte usingDTE = G(S).ModemOptions.ConnectDteRate;

			x_debug_msg("DP - local digital loopback command");
			G(x_modem_state) = MS_DTE_LOOPBACK;
			G(dp_state) = DP_NULL;

			// for connect message, show DTE rate.
			G(S).ModemOptions.ConnectDteRate = 1;
			x_send_mail(DP_IO_CONNECT, IO_TASK, NULL, 0);
			G(S).ModemOptions.ConnectDteRate = usingDTE;		// restore
		}
		break ;

		case MC_REM_DATA_LOOPBACK :
			x_debug_msg ( "DP - remote data loopback " ) ;
			G(x_modem_state) = MS_DCE_LOOPBACK ;
			x_send_mail ( DP_IO_CONNECT, IO_TASK, NULL, 0 ) ;
			break ;

		case MC_REM_DIGITAL_LOOPBACK :
			x_debug_msg ( "DP - remote digital loopback command" ) ;
			G(x_modem_state) = MS_REM_TEST ;
			dp_rem_digital_loop_cmd () ;
			break ;

		case MC_ABORT_TEST :
			if ( ( G(x_modem_state) == MS_LOCAL_TEST ) ||
				 ( G(x_modem_state) == MS_DTE_LOOPBACK ) )
			{
				G(x_modem_state) = MS_IDLE ;
				G(dp_state) = DP_DISCONNECT ;
				G(x_dial_residual) = MR_OK ;
				dp_modem_idle_cmd () ;
			}
			else if ( G(x_modem_state) == MS_REM_TEST )
			{
				G(x_modem_state) = MS_ON_DIAL;
				dp_v54_terminate_cmd () ;
			}
			else if ( G(x_modem_state) == MS_DCE_LOOPBACK )
			{
				x_debug_msg ("dp - abort test in data mode") ;
				G(x_modem_state) = MS_ON_DIAL;
				x_send_mail ( IO_LOOPBACK_ABORT, IO_TASK, NULL, 0 ) ;
			}
			break ;

		case MC_SPEAKER_ON :
			x_output(IO_SPEAKER_ON);
			break;

		case MC_SPEAKER_OFF :
			x_output(IO_SPEAKER_OFF);
			break;

		case MC_SPEAKER_LOW :
		case MC_SPEAKER_MEDIUM :
		case MC_SPEAKER_HIGH :
			// These DP commands are obsolete.  Speaker volume is
			// based on S.ModemOptions.SpeakerVolume.
			x_output(IO_SPEAKER_HIGH);
			break ;
#endif	// end if !(CS_MODEM)

#if defined (CLASS2_FAX) || !defined (CS_MODEM)
		case FAX_STARTUP_TRANSMIT :
			x_debug_msg("DP - fax startup transmit");

			// Not executing +FTS or +FRS command?
			if (G(dp_state) != DP_FAX_WAIT_SILENCE)
			{
				dp_fax_modem_idle_cmd();
				G(dp_state) = DP_FAX_STARTUP_TX ;
				G(dp_timer) = x_current_time () ;
			}

			else
				G(dp_state) = DP_FAX_WAIT_SILENCE_THEN_TX;

			break ;

		case FAX_STARTUP_RECEIVE :
			x_debug_msg ( "DP - fax startup receive" ) ;

			// Not executing +FTS or +FRS command?
			if (G(dp_state) != DP_FAX_WAIT_SILENCE)
			{
				G(dp_fax_status) = (byte) (G(dp_fax_status) & ~(IGNORE_V21_PREAMBLE | WAIT_FOR_FRH));  // Initally, assume no preamble delay; not waiting for +FRH
				G(dp_fax_status) = (byte) (G(dp_fax_status) | START_V21_DEBOUNCE);    // Qualify V.21 detect in non-V.21 modes

				if ( ( G(dp_state) != DP_FAX_RECEIVE ) ||   // Turn direction around to receive?
					 ( G(x_line_rate) != G(x_fax_rate) ) )    // New rate?
				{
					dp_fax_modem_idle_cmd();
					dp_fax_startup ( 0 ) ;
					x_debug_msg("DP - startup fax receiver from idle") ;
					io_init_dce_rx_fifo ();  // Starts from idle must have DCE buffer cleared
					G(dp_state) = DP_FAX_STARTUP_RX ;

					if (G(x_fax_rate) == MR_300)     // Starting V.21, 300 bps?
						G(dp_fax_status) = (byte) (G(dp_fax_status) | IGNORE_V21_PREAMBLE);  // Ignore carrier drop-outs during preamble
				}

				else  // Continue to receive
				{
					x_debug_msg ("DP - fax continue to receive");
					G(dp_state) = DP_FAX_CONTINUE_RX;
				}

				G(dp_timer) = x_current_time () ;
			}

			else
				G(dp_state) = DP_FAX_WAIT_SILENCE_THEN_RX;

			break ;

		case FAX_DROP_CARRIER :
			x_debug_msg ( "DP - received fax_drop_carrier command" ) ;
			G(dp_state) = DP_NULL ;
			G(x_fax_state) = FAX_IDLE ;
			dp_fax_modem_idle_cmd();
			G(dp_timer) = x_current_time () ;	// used by DP_FAX_STARTUP_TX
			if ( G(S).ModemOptions.CDControl == 0 )
				UART_cd_on () ;
			else
				UART_cd_off () ;
			break ;

#endif // CLASS2_FAX
		case FAX_WAIT_SILENCE :
			x_debug_msg ("dp - fax wait silence command") ;
			dp_fax_modem_idle_cmd();			// Put datapump in idle mode

			if ( G(x_fax_state) == FAX_RX_START )   // +FRS command?
				prog_bp_filter();  // Configure DP IIR filter #1 as a bandpass filter & listen

			else  // +FTS=n Command
				G(dp_fax_status) = (byte) (G(dp_fax_status) & ~RECEIVE_SILENCE);  // Indicate transmit silence wait

			G(dp_state) = DP_FAX_WAIT_SILENCE ;
			G(dp_timer) = x_current_time () ;
			G(ci_timer1) = (word) (10 * (*mail_ptr));

			if (G(x_fax_state) == FAX_TX)  // Transmitting silence?
				G(ci_timer1) = (word) (G(ci_timer1) <= 20 ? 0 : G(ci_timer1) - 20);  // Allow for delays in system

			break ;

#if defined(V34_FAX) // {
		case FAXV34_DETECT1S :	// receiver has seen start of 1s
			G(dp_timer) = x_current_time () ;
			G(dp_state) = DP_V34FAX_DETECT1S ;
			break;

		case FAXV34_SEND1S : // Send all 1s in channel.
					// Set PDM Idle char to 0xFF.
			dp_write_dsp_ram( 0x46, dp_read_dsp_ram(0x46) | 0x00ff );
			G(dp_timer) = x_current_time () ;
			G(dp_state) = DP_V34FAX_SILENCEWAIT ;
			break;

		case FAXV34_NO_ANSAM_START :	// start-up V34 fax w/o ANSam
			x_debug_msg ("dp-phase3 w/o ANSam") ;
			dp_write_dsp_ram( 0x1fd9, 0x0001 );	// set No ANSam detect mode
			x_set_current_time ( &G(dp_long_timer) ) ;
			if( TRUE == G(x_modem_originate) )
			{
				dp_v34fax_orig();	// update regs and start orignator
				G(dp_state) = DP_V34FAX_PHASE3;
			}
			else
			{
				dp_v34fax_ans();	// or answer side.
				G(dp_state) = DP_V34FAX_CMWAIT;	// wait for CM startup
			}
			G(dp_timer) = x_current_time () ;
			G(dp_timer1) = x_current_time();	// for debug timer
			break;

#endif // } V34_FAX

		case IO_DP_RETRAIN :  // used by lapm
			// Instructions from LAPM to DP to do a retrain.
			// Probably LAPM isn't happy with the way its
			// data is not getting through and wants to try
			// something drastic.
			x_debug_msg("IO_DP_RETRAIN");
			if (
#if defined (K56FLEX) || defined (VPCM_CLIENT) || defined (VPCM_SERVER)
				(G(dp_56k_state) == VPCM_DATA_MODE)	||
				(G(dp_56k_state) == DP_56K_DATA_MODE)	||
#endif
				(G(dp_state) == DP_ON_DIAL) )
			{
#if defined (COPERNICUS) || defined (SA_DIGITAL)
				LOCAL_RET_INCREMENT ; // update the retrain status
#endif
#if defined (K56FLEX) || defined (VPCM_CLIENT) || defined (VPCM_SERVER)
				if (dp_56k_retrain_cmd(0) == FALSE)
#endif
				{
					if ( ( G(x_line_rate) >= MR_2400 ) &&
						 ( G(dp_state) == DP_ON_DIAL ) )
					{
#if defined (DC0) || defined(CS_ETC)
						if ( G(cell_active) == FALSE )
#endif
							dp_rate_change_cmd(1);
					}
				}
			}
			break;

#if defined(CS_DIGITAL)
		case IO_DP_V90_CS_RETRAIN: //used by lapm
			x_debug_msg ("IO_DP_V90_CS_RETRAIN");
			if (G(dp_lapm_re_tx_RR_once)) // already tried one RR
			{
				cs_insert_error_tag ( 0xdf00 , 0 );
				x_send_mail_dp1(IO_DP_RETRAIN);    // then retrain
			}
			else
			{
				cs_insert_error_tag ( 0xe000 , 0 );
				G(dp_lapm_re_tx_RR_once) = 1;
				// otherwise just do a fast rate change
				dp_v90_fast_retrain_cmd();	
			}
			break ;
#endif // CS_DIGITAL

		case DSP_RETRAIN :  // used by at task, ato1 cmd
			x_debug_msg ("dp - retrain command (ato1)") ;

			if ( G(x_line_rate) >= MR_2400 )
			{
#if defined(K56FLEX) || defined(VPCM_CLIENT) || defined(VPCM_SERVER)
				if (dp_56k_retrain_cmd(1) == FALSE)
#endif
				{
#if	defined (CS_MODEM) || defined (COPERNICUS)
					if (G(S).ModemOptions.Dummy23) 
						dp_write_dsp_ram(0x0ee4, G(S).ModemOptions.Dummy23);
					if (G(S).ModemOptions.Dummy20) 
						dp_write_dsp_ram(0x0ee5, 0xff00 | G(S).ModemOptions.Dummy20);
#endif	//defined (CS_MODEM) || defined (COPERNICUS)
					dp_retrain_cmd();
					G(dp_state) = DP_RETRAIN_START;
				}
				G(dp_timer) = x_current_time () ;
			}
			break ;

		case UPDATE_MODEM_RATE :  // used by IO task
			x_debug_msg ("dp - update modem rate") ;
			dp_update_rate();
			dp_init_modem_connection();
			break ;

		case DSP_FAST_RETRAIN : // used by at task, ato3 cmd
			x_debug_msg("dp-DSP_FAST_RETRAIN");

			if ( G(x_line_rate) >= MR_4800 )
			{
#if defined(K56FLEX) || defined(VPCM_CLIENT) || defined(VPCM_SERVER)
				if ( dp_56k_retrain_cmd(2) == FALSE )
#endif
				{
					dp_fast_retrain_cmd () ;
					G(dp_state) = DP_RETRAIN_START ;
				}
				G(dp_timer) = x_current_time () ;
			}
			break ;

		case DSP_VERSION :  // used by at task, get dsp version 
			*((word *)mail_ptr) = dp_dsp_version () ;
			if ( G(dp_state) == DP_WAIT_FOR_RING )
				G(dp_state) = DP_IDLE ;
			break ;

		case DSP_CHECKSUM : // used by at task, get dsp checksum
			*((word *)mail_ptr) = dp_dsp_checksum () ;
			if ( G(dp_state) == DP_WAIT_FOR_RING )
				G(dp_state) = DP_IDLE ;
			break ;

#if !defined(CS_MODEM)
		case DP_TEST_CMD :  // used by at task, all homologation test cmds
			// disable sleep for test commands
		{
			DP_STATE reg = G(dp_state);

			G(S).ModemOptions.SleepModeTimer = 0 ;
			G(SaveDPState) = 0 ;
			((dsp_ram *) mail_ptr)->val=
				dp_test_cmd ( mail_len, ((dsp_ram *) mail_ptr) ) ;

			if (G(SaveDPState))
			{
				G(dp_state) = reg ;
			}
		}
		break ;
#endif

		case DP_SLEEP :  // put dsp in sleep mode 
			x_debug_msg("DP_SLEEP") ;
			G(dp_count) = 0 ; // reset ring interrupt count
			G(dp_state) = DP_WAIT_FOR_RING ;
			G(dp_ring_int) = FALSE ;
			G(dp_calling_tone_disable) = FALSE ;
			dp_enable_ring_int();
			dp_sleep_mode(TRUE);
			break ;

		case DP_WAKEUP :  // wakeup dsp 
			x_debug_msg ("DP_WAKEUP") ;
			dp_init_modem();  // initialize data pump
#ifdef DC0
			if ( G(cell_ring_int) == TRUE )
			{
				// we got a cell ring - wait for ata command from app
				G(dp_state) = DP_CELL_RING_OFF ;
			}
			else
#endif
			{
				if ( G(dp_ring_int) == FALSE )
					G(dp_state) = DP_IDLE ;
			}
			break ;

		case DP_READ_REG: //used by at task, read interface register
			((dsp_ram *) mail_ptr)->val =
				(word) dp_regread((byte) ((dsp_ram *) mail_ptr)->loc);
			break ;
			
		case DP_WRITE_REG:  //used by at task, write DSP RAM
			dp_regwrite((byte) ((dsp_ram *) mail_ptr)->loc,
						(byte) ((dsp_ram *) mail_ptr)->val);
			break ;

		case DSP_READ_RAM: //used by at task, read DSP RAM
			((dsp_ram *) mail_ptr)->val = 
				dp_read_dsp_ram ( ((dsp_ram *) mail_ptr)->loc ) ;
			break ;
			
		case DSP_WRITE_RAM:  //used by at task, write interface register
			dp_write_dsp_ram ( ((dsp_ram *) mail_ptr)->loc, 
							   ((dsp_ram *) mail_ptr)->val ) ;
			if ( G(dp_state) == DP_WAIT_FOR_RING )
				G(dp_state) = DP_IDLE ;
			break ;

		case DP_RESUME :    // initialize data pump
			x_debug_msg ("DP_RESUME") ;
			// This code is also executed by the ATZ command
#if defined (K56FLEX) || defined (VPCM_CLIENT) || defined (VPCM_SERVER)
			dp_reset_venus();
#endif
			dp_init_modem();
			dp_enable_ring_int();
			break ;

#ifdef HOMOL
		case DP_SHOW_BLACKLIST :
			dp_show_blacklist () ;
			break ;

		case DP_BLACKLIST_STATUS :
			if ( G(dp_blacklist_calls) )
				*mail_ptr = TRUE ;
			else
				*mail_ptr = FALSE ;
			break ;
#endif

		case DP_START_TRANSMIT :    // used by io task
			dp_start_transmit () ;
			break ;

		case DP_ASYNC_8BIT_MODE :   // used by lapm and mnp
			dp_async_8bit_mode () ;
			break ;

		case DP_ASYNC_USER_MODE :   // used by lapm and mnp
			x_debug_msg ("DP_ASYNC_USER_MODE");
			dp_async_user_mode () ;
			break ;

#if !defined(CS_MODEM)
		case DP_SYNC_MODE:  
			 // set a synchronous buffered mode (at+es=6)
			 // requested from DP_IO_CONNECT
			dp_sync_mode_hdlc () ;
			break ;

		case DP_SYNC_MODE_MARK:  
			dp_sync_mode_mark () ;
			break ;
#endif //!CS_MODEM

		case DP_HDLC_MODE :     // used by lapm and mnp
			x_debug_msg ("dp - set hdlc mode") ;
			cs_debug_liv(DP_SET_HDLC_MODE);
			dp_hdlc_mode () ;
			break ;

#ifdef V80
		case DP_HDLC_MODE_NO_CRC :
			dp_hdlc_mode_no_crc () ;
			break ;

#ifdef V8BIS
		case DP_SEND_A8T_CMD:
			G(dp_state) = DP_V8BIS;
			v8bis_new_cmd ();
			break;

		case DP_V8BIS_DETECTION:
			v8bis_rx_reset ();
			break;

#if !defined (CS_MODEM)
		case DP_A8T_CMD:
			x_debug_msg ("dp - got DP_A8T_CMD mail") ;
			if ( G(S).ModemOptions.V8bis == V8BIS_DTE_CONTROL )
			{
				if ( ( G(x_modem_mode) == MODEM_DATA ) &&
					( G(x_modem_state) == MS_OFFHOOK ) &&
					( G(dp_state) != DP_V8BIS ) &&
					( G(dp_state) != DP_V8_TONE_DETECT_INIT_HANDSET ) )
				{
					v8bis_dte_cmd_tones_detection_setup ();
					G(dp_state) = DP_V8BIS;
					x_debug_msg ("dp - go to DP_V8BIS state") ;
				}
				else
					v8bis_in_cmd_state ();
			}
			break;
#endif  //!CS_MODEM
#endif //V8BIS
#endif

		case DP_TX_FIFO_EMPTY :
			if ( dp_tx_fifo_empty () == TRUE )
				*mail_ptr = TRUE ;
			else
				*mail_ptr = FALSE ;
			break ;

#ifdef VOICE

		case DP_DPORT_TX:    // used by io task for IS101
			*mail_ptr = dp_dualport_vc_Tx () ; // used in IS101
			break ;

		case DP_DPORT_RX :    // used by io task for IS101
			*mail_ptr = dp_dualport_vc_Rc () ;
			break ;

		case VOICE_END :
			x_debug_msg ("dp - voice end") ;
			//SpeakerPhone mode:
			//recording - stop recording,stay in speaker phone mode
			//otherwise - end tad, go back to speaker phone mode
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
			{
				if ( G(dp_fdsp_record) == TRUE )
					x_send_mail_dp1(VOICE_SPKR_PHONE_RECORD_STOP);
				else
					x_send_mail_dp1(VOICE_SPEAKER_PHONE);
			}
			else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if ( G(x_modem_state) == MS_TAD_FAR )
			// if we were previously offhook - then go back to looking
			// for tones in voice idle mode
			{
				dp_tad_idle () ;
				G(dp_state) = DP_VOICE ;
			}
			else
			{
				dp_stop_tad () ;
				G(x_modem_state) = MS_IDLE ;
				G(dp_state) = DP_IDLE ;
				x_output ( IO_AUDIO_CODEC_OFF ) ;
			}
			G(dp_vt_cntrl) = TAD_IDLE ;
			break ;

		case VOICE_IDLE :
			x_debug_msg ( "DP - voice idle command" ) ;
			// this command is called in voice mode - to switch to fax
			// or data mode after receiving a calling tone - we wait for
			// the Application to switch us to the proper mode using
			// at+fclass=x command
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
			{
				dp_stop_fdsp () ;
				G(dp_state) = DP_NULL ;
			}
			else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if ( ( G(x_modem_mode) == MODEM_VOICE )  )
			{
				dp_stop_tad () ; 
				if ( ( G(x_modem_state) == MS_TAD_NEAR ) ||
					 ( G(x_modem_state) == MS_TAD_FAR ) )
					G(dp_state) = DP_NULL ;
			}
			// do not reset the modem state - we could be getting
			// rings (G(x_modem_state) = x_ring_indicate) and then the
			// fax package does an at+fclass=1, then an 'ata' command
			if ( G(x_modem_state) != MS_RING_INDICATE )
				G(x_modem_state) = MS_IDLE ;
			x_output ( IO_AUDIO_CODEC_OFF ) ;
			break ;

		case VOICE_NEAR_LOOPBACK :
			x_debug_msg ("dp - voice near loopback") ;
			dp_start_tad ( TAD_NEAR_LOOPBACK ) ;
			G(x_modem_state) = MS_TAD_LOOPBACK ;
			G(dp_state) = DP_NULL ;
			break ;

		case VOICE_LINE_LOOPBACK :
			x_debug_msg ("dp - voice line loopback") ;
			dp_start_tad ( TAD_LINE_LOOPBACK ) ;
			G(x_modem_state) = MS_TAD_LOOPBACK ;
			G(dp_state) = DP_NULL ;
			break ;

		case VOICE_NEAR_PLAYBACK :
			x_debug_msg ("dp - voice near playback") ;
			dp_start_tad ( TAD_NEAR_PLAYBACK ) ;
#ifdef G729A //workaround for initial playback issue - 9/3/98 ses
			dp_start_tad ( TAD_NEAR_PLAYBACK ) ;
#endif
			G(x_modem_state) = MS_TAD_NEAR ;
			G(dp_state) = DP_NULL ;
			break ;

		case VOICE_NEAR_RECORD :
			x_debug_msg ("dp - voice near record") ;
			dp_start_tad ( TAD_NEAR_RECORD ) ;
			G(x_modem_state) = MS_TAD_NEAR ;
			G(dp_state) = DP_NULL ;
			break ;

		case VOICE_LINE_RECORD :
			x_debug_msg ("dp - voice line record") ;
			dp_start_tad ( TAD_LINE_RECORD ) ;
			G(x_modem_state) = MS_TAD_FAR ;
			G(dp_state) = DP_VOICE ;
			G(dp_timer) = x_current_time () ;
			break ;

		case VOICE_LINE_PLAYBACK :
			x_debug_msg ("dp - voice line playback") ;
			dp_start_tad ( TAD_LINE_PLAYBACK ) ;
#ifdef G729A //workaround for initial playback issue - 9/3/98 ses
			dp_start_tad ( TAD_LINE_PLAYBACK ) ;
#endif
			G(x_modem_state) = MS_TAD_FAR ;
			G(dp_state) = DP_VOICE ;
			break ;

		case VOICE_LOCAL_PHONE_CONNECT :
		case VOICE_LOCAL_PHONE_PLAYBACK :
		case VOICE_LOCAL_PHONE_RECORD :
			if ( cmd == VOICE_LOCAL_PHONE_RECORD )
			{
				x_debug_msg ("dp - voice local phone record") ;
				dp_start_tad ( TAD_NEAR_RECORD ) ;
			}
			else
			{
				x_debug_msg ("dp - voice local phone playback") ;
				dp_start_tad ( TAD_NEAR_PLAYBACK ) ;
#ifdef G729A //workaround for initial playback issue - 9/3/98 ses
				dp_start_tad ( TAD_NEAR_PLAYBACK ) ;
#endif
			}
			G(x_modem_state) = MS_TAD_FAR ;
			G(dp_state) = DP_VOICE ;
			G(dp_timer) = x_current_time () ;
			// diconnect local phone from T&R and connect
			// local phone power source.
			x_output ( IO_DV_RLY_ON ) ;

			// don't want any sound coming out
			// of the local speaker
			x_output ( IO_EXT_SPEAKER_OFF ) ;

			// connect local phone to audio codec
			x_output ( IO_LOCAL_PHONE_ON ) ;
			break ;

		case VOICE_SCREEN_OUT :
			x_debug_msg ("dp - voice screen out") ;
			dp_start_tad ( TAD_SCREEN_OUT ) ;
			G(x_modem_state) = MS_TAD_FAR ;
			G(dp_state) = DP_VOICE ;
			break ;

		case VOICE_SCREEN_IN :
			x_debug_msg ("dp - voice screen in") ;
			dp_start_tad ( TAD_SCREEN_IN ) ;
			G(x_modem_state) = MS_TAD_FAR ;
			G(dp_state) = DP_VOICE ;
			G(dp_timer) = x_current_time () ;
			break ;

		case VOICE_GENERATE_TONES :
			x_debug_msg ("dp - voice gen tones command") ;
			x_strcpy ( G(dp_dial_string), mail_ptr ) ;
			G(dp_vts_ptr) = G(dp_dial_string) ;
			G(dp_timer) = x_current_time () ;
			dp_vts () ;
			break ;

#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
		case VOICE_SPEAKER_PHONE:
			x_debug_msg ("dp - voice start speaker phone") ;
			dp_stop_tad () ; 
			G(dp_timer1) = x_current_time () ;
#ifdef DC0
			cell_answer () ; // if direct connect, send response.
#endif
			if ( mail_len != 1 )
				dp_offhook_cmd () ;
			dp_start_hdsp_tone_det();
			G(S).ModemOptions.DsvdVoiceCallFirst = TRUE ;
			if ( G(S).ModemOptions.LoopSenseWaitTime != 0 )  // Over current sense on
			{
				G(dp_timer) = x_current_time () ;
				G(dp_state) = DP_OVERCURRENT ;
			}
			else
				G(dp_state) = DP_SPEAKER_PHONE_WAIT ;
			break ;

		case VOICE_STOP_SPKR_PHONE:
			x_debug_msg ("dp - voice stop speaker phone and switch to TAD") ;
			dp_stop_fdsp () ;
			G(x_modem_state) = MS_TAD_FAR ;
			G(x_modem_mode) = MODEM_VOICE;
			dp_start_tad( TAD_IDLE ) ;
			G(dp_state) = DP_VOICE ;
			break ;

		case VOICE_MUTE_SPKR_PHONE:
			x_debug_msg ("dp - voice mute speaker phone") ;
			dp_mute_fdsp ( FDSP_MUTE ) ;  
			break ;

		case VOICE_UNMUTE_SPKR_PHONE :
			x_debug_msg ("dp - voice unmute speaker phone") ;
			dp_mute_fdsp ( FDSP_UNMUTE ) ;
			break ;
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
		
		case VOICE_GAIN_CONTROL :
			x_debug_msg ("dp - voice set speaker gain control level") ;
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
			{
				//no spkr gain adjustment, while VLS=5
				if (G(S).ModemOptions.VoiceLineSelection !=5)
					dp_set_speakerphone_gain () ;
			}
			else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			{
				if ( G(x_modem_mode) == MODEM_VOICE )
				{
					dp_set_tad_speaker_gain () ;
					// if we get +VGT during playback is in progress
					// Kick DSP after command.
					if ( ( G(dp_vt_cntrl) == TAD_NEAR_PLAYBACK ) ||
						( G(dp_vt_cntrl) == TAD_SCREEN_OUT ) )
						dp_start_transmit () ;
				}
			}
			break ;

		case VOICE_MIC_GAIN_CONTROL:
			x_debug_msg ("dp - voice set mic gain control level") ;
#if (DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
			if ( G(x_modem_mode) == MODEM_SPEAKER_PHONE )
			{
				//no spkr gain adjustment, while VLS=5
				if (G(S).ModemOptions.VoiceLineSelection !=5)
					dp_set_spk_mic_gain () ;
			}
			else
#endif //(DATA_FAX_TAM!=1)		// speakerphone for data/fax/TAM
				dp_set_tad_mic_gain () ;
			break ;

#ifdef CALLER_ID
		case CALLER_ID_END :
			x_debug_msg ( "DP - cid disable cmd" ) ;
			dp_cid_disable () ;
			G(dp_state) = DP_RING_ON ;     // go back to ring on state
			break ;
#endif	//CALLER_ID
#endif

#if defined(VENUS_AT_CS) || defined(CS_MODEM) || defined(VPCM_SERVER)
		case A_LAW_SELECTED :
			x_debug_msg("dp - user selected A-law in K56FLEX  VPCM_SERVER");
			dp_write_dsp_ram ( 0x826, 0x0440 )	;
			break ;

		case MU_LAW_SELECTED :
			x_debug_msg("dp - user selected u-law in K56FLEX  VPCM_SERVER");
			dp_write_dsp_ram ( 0x826, 0x0040 )	;
			break ;
#endif	// K56FLEX || VPCM_SERVER

		default :
			x_debug_msg ( "DP - received unknown mail" ) ;
			break ;
	}
}

// ---------------------------------------- //
// Command the DSP to an Idle State for FAX //
// ---------------------------------------- //
// Apparently, there's a bug in the DPS such that
// when the transmitter goes to an idle state, a
// noise impulse is generated.  In Central Site application only,
// this impulse causes problems such that the receiving modem
// doesn't recognize the echo protection tone nor the long
// training before TCF.

void dp_fax_modem_idle_cmd ()
{
#if defined (COPERNICUS) || defined (SA_DIGITAL)
  dp_modem_command(GOTO_CMD, 0xD8, 0x00);  // Workaround for CS modems

#else

#if defined( V34_FAX )
	if( NON_V34 != G(x_fax_v34mode))
		dp_write_dsp_ram( 0x0F20, 0x8ECE);	// "null" out DPRAM baud
#endif

	if( G(x_fax_v17) != NON_V17 )	// stop tone detect and dropout wrkarnd
	{
		dp_write_dsp_ram( 0x0F20, 0x8ECE);
		dp_write_dsp_ram( 0x0F22, 0x8ECE);
	}

  dp_modem_idle_cmd();   // DSP, ROM-resident modem idle command

#endif
}
