/*name and version number:@(#)v_ifp.c	1.6*/
/*date of get: 		  09/06/00 16:59:31*/
/*date of delta:	  01/27/00 15:55:33*/
/*****************************************************************************
** File        : v_ifp.c                                                       *
** Version     : 3.0                                                         *
**---------------------------------------------------------------------------*
** Description :                                                             *
**                                                                           *
**     Function Name    | Access  | Summary                                  *
**  --------------------+---------+----------------------------------------- *
**  ifp_rx_config       | GLOBAL  | configs rx side (frms per packet etc)    *
**  ifp_rx              | GLOBAL  | takes data from DSP, creates pnet packet *
**  assemble_header     | STATIC  | assembles IFP header for a packet        *
**                      |         |                                          *
**  ifp_tx_config       | GLOBAL  | configs tx side (jitter etc)             *
**  ifp_tx              | GLOBAL  | takes data from PNET, extracts frames    *
**  ifp_process_packet  | STATIC  | processes IFP header, extracts seq       *
**                                                                           *
**---------------------------------------------------------------------------*
**                               HISTORY                                     *
**[Release 2]----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                       *
** 19th Jan  1999  2.0   RGT  Initial Revision (stubs - negative capability) *
**                                                                           *
** 20th Apr  1999  2.1   RGT  Full FAX capability with silence suppression.  *
**                                                                           *
**[Release 3]----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                       *
**  2nd Sep  1999  3.0    JA  CS-4 multi-instance integration                *
**                                                                           *
******************************************************************************/
#include <v_glob.h>


/****************************************************************************
              ####  #####   ###   #####  ###   ####   ####
             #        #    #   #    #     #   #      #
              ####    #    #####    #     #   #       ####
                  #   #    #   #    #     #   #           #
              ####    #    #   #    #    ###   ####   ####
*****************************************************************************/
	static Boolean assemble_header   (VGLOB *);
	       Boolean ifp_process_packet(VGLOB *, packet_t *);


/*****************************************************************************
      ##### #   #  #   #   ####  #####  ###   ###   #    #  ####
      #     #   #  ##  #  #        #     #   #   #  ##   # #
      ####  #   #  # # #  #        #     #   #   #  # #  #  ####
      #     #   #  #  ##  #        #     #   #   #  #   ##      #
      #      ####  #   #   ####    #    ###   ###   #    #  ####
******************************************************************************/


					/*****************************
					       RECEIVER ROUTINES
					       RECEIVER ROUTINES
					       RECEIVER ROUTINES
					       RECEIVER ROUTINES
					*****************************/

/******************************************************************************
** Function : ifp_rx_config                                                   *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 25th Jan  1999  2.0   RGT  Initial Revision (stub - negative capability)   *
**                                                                            *
** 20th Apr  1999  2.1   RGT  Added in code to initialise rx FAX section.     *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**  This function initialises the receiver section of the FAX library. There  *
** are two user-defined parameters to be uploaded and checked for sanity, and *
** a packet assembly memory space to be initialised.                          *
**                                                                            *
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type           | arg name | Description                              |  *
**  |----------------+----------+------------------------------------------|  *
**  | callConfig_t * | cfg      | Pointer to rx configuration parameters   |  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************/
void ifp_rx_config(VGLOB *vglob_ptr)
{

/****************************************************************************
** ERROR CORECTIVE CONSTRAINT SETUP:                                        *
******                                                                      *
	** Limits the number of error corrective frames assembled per packet.   *
	**                                                                      *
	** Minimum requirement = 1                                              *
	** Maximum requirement = IFP_MAX_FRAMES_PER_PACKET                      *
	*************************************************************************/
	V(ifpRxInf).frmsPerPkt  = V(config).faxFramesMax;
	if (V(ifpRxInf).frmsPerPkt > IFP_MAX_FRAMES_PER_PKT || V(ifpRxInf).frmsPerPkt < 1) {
		WARNING(vglob_ptr,WARN_IFP_BAD_FRMS_PER_PKT);
		WARNING(vglob_ptr,V(ifpRxInf).frmsPerPkt);
		V(ifpRxInf).frmsPerPkt = IFP_DEFAULT_FRAMES_PER_PKT;
		WARNING(vglob_ptr,V(ifpRxInf).frmsPerPkt);
	}

/*****************************************************************************
** BANDWIDTH UTILISATION CONSTRAINT SETUP:                                   *
******                                                                       *
	** Limits the amount of network bandwidth used by the FAX library.       *
	**                                                                       *
	**   IP/UDP Bandwidth (kbits/sec) = (28 + maxPayload) * 33 * 8 / 1000    *
	** Ethernet Bandwidth (kbits/sec) = (42 + mayPayload) * 33 * 8 / 1000    *
	**                                                                       *
	** Minimum requirement = 14.400 kbit/sec FAX transport (4 + 60 Bytes)    *
	** Maximum allowed     = MAX_PKT_SIZE                                    *
	**************************************************************************/
	V(ifpRxInf).maxPayload  = V(config).faxPayloadMax;
	if (V(ifpRxInf).maxPayload < MIN_PAYLOAD || V(ifpRxInf).maxPayload > CFG_MAX_PKT_SZ) {
		WARNING(vglob_ptr,WARN_IFP_BAD_MAX_PAYLOAD);
		WARNING(vglob_ptr,V(ifpRxInf).maxPayload);
		V(ifpRxInf).maxPayload = DEFAULT_MAX_PAYLOAD;
		WARNING(vglob_ptr,V(ifpRxInf).maxPayload);
	}
		
/****************************************************************************
** RECEIVER SYSTEM INITIALISATION: MEMORY MANAGEMENT                        *
******                                                                      *
	** Sets up the packet store for assembling packets prior to submission  *
	** to the network, and an assembly stack for holding error protection.  *
	*************************************************************************/
	V(ifpRxInf).pkt = next_rx_media_packet( vglob_ptr) ;
	V(ifpRxInf).topStack    = 0;

}


/******************************************************************************
** Function : ifp_rx                                                          *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 25th Jan  1999  2.0   RGT  Initial Revision (stub - negative capability)   *
**                                                                            *
** 20th Apr  1999  2.1   RGT  Added in code to take frames & create IFP pkts. *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function takes frames from the DSP, checks to ensure they are of    *
** type FAX, and assembles them into packets for transmission to the network. *
** Error corrective frames are assembled to compensate for network packet loss*
** and the original ITS-SP bandwidth controls are in place to avoid excessive *
** resource usage. Silence suppression has also been implemented to further   *
** reduce the bandwidth requirements of the system.                           *
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type       | arg name | Description                                  |  *
**  |------------+----------+----------------------------------------------|  *
**  | frame_t *  | frame    | Pntr to frame to be assembled into a packet  |  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************/
void ifp_rx(VGLOB *vglob_ptr, frame_t *frame)
{
	byte		  L1;			// For Loop Control
	byte		  redundancy;	// Used to insert redundant frames into pkt
	frame_t		* frmCopy;		// Used in copy of frames to the assembly stack
	Boolean		  busy;
	faxSig		  sigType;

	V(RX_RETVAL) = OKAY;

	if (frame->codec != DEMOD) {
		WARNING(vglob_ptr,WARN_IFP_BAD_FRAME);
		WARNING(vglob_ptr,frame->codec);
		V(RX_RETVAL) = IFP_BAD_FRAME;
		goto emergency_exit;
	}

	/*******************************************************************
	** Firstly, log where redundant frames begin in the assembly stack *
	********************************************************************/
	redundancy = (V(ifpRxInf).topStack - 1) & (ASSEMBLY_STACK_SIZE -1);

	/***********************************************************
	** Now push this new frame's media onto the assembly stack *
	************************************************************/
	frmCopy         = &V(ifpRxInf).frmStack[V(ifpRxInf).topStack];
	*frmCopy        = *frame;
	frmCopy->status = V_FULL;

	V(ifpRxInf).topStack++ ;
	V(ifpRxInf).topStack &= (ASSEMBLY_STACK_SIZE - 1);	// must be power of two

	/****************************************************
	** Find out what the length of this frame really is *
	*****************************************************/
	frmCopy->length = MACRO_FAX_FRAME_LEN(frmCopy->media);
	sigType         = MACRO_FAX_SIG_TYPE(frmCopy->media);
	if (sigType < SILENCE || sigType > T30_DCN) {
		WARNING(vglob_ptr,WARN_IFP_PSTN_BAD_SIG_TYPE);
		*(lword *)frmCopy->media = (lword)SILENCE;
	}

	/****************************************
	** Update this packet's sequence number *
	*****************************************/
	V(ifpRxInf).sequence += (frame->ID - V(ifpRxInf).lastFrmID);
	V(ifpRxInf).lastFrmID = frame->ID;

	/********************************************************************
	** Now begin inserting frames into the packet ahead of the protocol *
	** header. Do this until we hit a maximum packet size or numFrames  *
	*********************************************************************/
	busy              = True;
	V(ifpRxInf).offset      = IFP_HDR_LEN;
	V(ifpRxInf).frmsIns     = 0;
	V(ifpRxInf).silenceFrms = 0;

/*************************************************************************
** THE FRAME INSERTION LOOP                                              *
****** This inserts as many frames as allowed by the MAX frames per pkt  *
	** constraint unless a bandwidth contraint is hit beforehand.        *
	**********************************************************************/
	do {
		/**************************************************************
		** Okay, insert this selected frame into the packet structure *
		***************************************************************/
		for (L1 = 0; L1 < frmCopy->length; L1++)
			V(ifpRxInf).pkt->media[V(ifpRxInf).offset++] = frmCopy->media[L1];
		V(ifpRxInf).frmsIns ++;

		/******************************************************************
		** Log the number of silence frames we insert - this will control *
		** whether silence suppression is active or not.                  *
		*******************************************************************/
		if (MACRO_FAX_SIG_TYPE(frmCopy->media) == SILENCE)
			V(ifpRxInf).silenceFrms++;

		/****************************************************************
		** Now grab a new redundant frame for insertion into the packet *
		*****************************************************************/
		frmCopy = &V(ifpRxInf).frmStack[redundancy--];
		redundancy &= (ASSEMBLY_STACK_SIZE - 1);

		/*******************************************************************
		** Make certain this (redundant) frame contains data - if not, set *
		** busy indicator to False to terminate the frame insertion loop   *
		********************************************************************/
		if (frmCopy->status != V_FULL) {
			busy = False;
		}

		/*************************************************************
		** Similarly, make sure the insertion of this frame will not *
		** violate our bandwidth or MAX error protection constraints *
		**************************************************************/
		if (frmCopy->length + V(ifpRxInf).offset > V(ifpRxInf).maxPayload || 
		    V(ifpRxInf).frmsIns >= V(ifpRxInf).frmsPerPkt) {
			busy = False;
		}

	} while (busy);

	/******************************************************************
	** Provided that not all frames are of type silence, assemble an  *
	** IFP header and write the completed packet to the network queue *
	*******************************************************************/
	if (V(ifpRxInf).frmsIns > V(ifpRxInf).silenceFrms) {
		/*****************************************
		** Now stick an IFP header on the packet *
		******************************************/
		assemble_header(vglob_ptr);

		/************************************************************
		** Set the packet's length and send it to the network queue *
		*************************************************************/
		V(ifpRxInf).pkt->length = V(ifpRxInf).offset;
		send_packet_to_network(vglob_ptr, V(ifpRxInf).pkt, PNET_MEDIA);

		// Allocate new packet for next time
		V(ifpRxInf).pkt = next_rx_media_packet( vglob_ptr );

	} else 
		V(stats).rx.silencePkts++;


emergency_exit:
	L1 = 0;
}

/******************************************************************************
** Function : assemble_header                                                 *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 25th Jan  1999  2.0   RGT  Initial Revision (stub - negative capability)   *
**                                                                            *
** 20th Apr  1999  2.1   RGT  Added in IFP header generation code.            *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**  This function generates a header for the start of an IFP packet. All the  *
** dynamic information required (sequence number, number of frames, and any   *
** control information, etc) is passed in the receiver structure.             *
*******************************************************************************
** Arguments :                                                                *
**                NONE                                                        *
**                                                                            *
*******************************************************************************/
Boolean assemble_header(VGLOB *vglob_ptr)
{
	ifpHeader_t	* header;

	header = (ifpHeader_t *)V(ifpRxInf).pkt->media;

	header->control   = 0x00;
	header->sequence  = htons(V(ifpRxInf).sequence);
	header->numFrames = V(ifpRxInf).frmsIns;
	return True;
}



					/*****************************
					       TRANSMIT ROUTINES
					       TRANSMIT ROUTINES
					       TRANSMIT ROUTINES
					       TRANSMIT ROUTINES
					*****************************/

/******************************************************************************
** Function : ifp_tx_config                                                   *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 25th Jan  1999  2.0   RGT  Initial Revision (stub - negative capability)   *
**                                                                            *
** 20th Apr  1999  2.1   RGT  Added in code to initialised tx FAX section.    *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function initialises the FAX exchanger library transmit section.    *
**                                                                            *
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type           | arg name | Description                              |  *
**  |----------------+----------+------------------------------------------|  *
**  | callConfig_t * | cfg      | Pointer to tx configuration parameters   |  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************/
void ifp_tx_config(VGLOB *vglob_ptr)
{
	V(ifpTxInf).initialPkt = True;
	V(ifpTxInf).lastSig    = UNINITIALISED;

	V(ifpTxInf).slipDelay = V(config).faxBuildOut;
	if (V(ifpTxInf).slipDelay < 1 || V(ifpTxInf).slipDelay > MAX_SLIP_DELAY) {
		WARNING(vglob_ptr,WARN_IFP_BAD_BUILDOUT);
		WARNING(vglob_ptr,V(ifpTxInf).slipDelay);
		V(ifpTxInf).slipDelay = DEFAULT_SLIP_DELAY;
		WARNING(vglob_ptr,V(ifpTxInf).slipDelay);
	}

}


/******************************************************************************
** Function : ifp_tx                                                          *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 25th Jan  1999  2.0   RGT  Initial Revision (stub - negative capability)   *
**                                                                            *
** 20th Apr  1999  2.1   RGT  Added full IFP depacketisation & frame queue.   *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function implements the transmit direction of the FAX exchanger     *
** library. It takes packets from the network and makes tests to ensure that  *
** they are of type IFP (beyond reasonable doubt). If these tests fail, the   *
** packet is discarded. If, however, all tests are passed, then each frame    *
** is extracted from the packet and passed to the DSP driver.                 *
**                                                                            *
**   The code attempts to minimise CPU usage by only performing queueing      *
** calculations when necessary. It also attempts to maintain a steady buildout*
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type       | arg name | Description                                  |  *
**  |------------+----------+----------------------------------------------|  *
**  | packet_t * | pkt      | Pointer to packet structure for processing   |  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************/
void ifp_tx(VGLOB *vglob_ptr, packet_t *pkt)
{
	byte L1;
	byte L2;
	word temp;
	faxSig	sigType;

	/********************************************************************
	** Firstly, process the packet assuming it's an IFP header - if the *
	** function called does not see valid data, it shall return False.  *
	** Get out of the function quick and return to the calling context  *
	** if this occurs, we may be seeing voice packets.                  *
	*********************************************************************/
	if (!ifp_process_packet(vglob_ptr, pkt)) {		// returns True if valid IFP packet
		WARNING(vglob_ptr,WARN_IFP_BAD_HEADER);
		V(TX_RETVAL) = IFP_BAD_PKT;
		goto emergency_exit;
	}


/**************************************************************************
** QUEUEING CALCULATION SECTION                                           *
**  QUEUEING CALCULATION SECTION                                          *
**   QUEUEING CALCULATION SECTION                                         *
***************************************************************************/


	/***********************************************************************
	** If this is an initial packet (or start of new signal burst after a  *
	** silence period), bypass the queueing calculations and set the delay *
	** to the value specified at configuration time.                       *
	************************************************************************/
	if (V(ifpTxInf).initialPkt) {
		init_pkt_loss_stats(vglob_ptr, V(ifpTxInf).sequence);
		V(ifpTxInf).frame.ID   = set_buildout(vglob_ptr, V(ifpTxInf).slipDelay);
		V(ifpTxInf).initialPkt = False;
		init_jitter_clock(vglob_ptr);
	} else {
		update_pkt_loss_stats(vglob_ptr, V(ifpTxInf).sequence);
		update_jitter_calc(vglob_ptr, V(ifpTxInf).txTime*30);

		/***************************************************************
		** Now, calculate the correct frame ID for the first frame in  *
		** the packet based upon the last frame ID used and the time   *
		** difference between the respective packets at the transmitter*
		****************************************************************/
		if (V(ifpTxInf).positiveQueue)
			V(ifpTxInf).frame.ID = V(ifpTxInf).lastFrmID + V(ifpTxInf).txTime;
		else
			V(ifpTxInf).frame.ID = V(ifpTxInf).lastFrmID - V(ifpTxInf).txTime;
	}
			

	/*********************************************************************
	** Store the last frame's ID and sequence of the last packet so that *
	** we can perform a relative queue on the next received packet.      *
	**********************************************************************/
	V(ifpTxInf).lastFrmID = V(ifpTxInf).frame.ID;
	V(ifpTxInf).lastSeq   = V(ifpTxInf).sequence;


/**************************************************************************
** FRAME EXTRACTION AND TRANSFER OF DATA TO DSP DRIVER                    *
**  FRAME EXTRACTION AND TRANSFER OF DATA TO DSP DRIVER                   *
**   FRAME EXTRACTION AND TRANSFER OF DATA TO DSP DRIVER                  *
***************************************************************************/

	/******************************************
	** Cycle through each frame in the packet *
	*******************************************/
	for (L1 = 0; L1 < V(ifpTxInf).numFrames; L1 ++) {

		/************************************************************
		** Check the signal type of the current frame - if it's not *
		** valid, get out quick!                                    *
		*************************************************************/
		sigType = MACRO_FAX_SIG_TYPE(pkt->media + V(ifpTxInf).offset);
		if (sigType < 0x200 || sigType > 0x21F) {
			WARNING(vglob_ptr,WARN_IFP_PNET_BAD_SIG_TYPE);
			V(TX_RETVAL) = IFP_BAD_PNET_FRAME;
			goto emergency_exit;
		}

		/**** Store the signal type if it differs from the last ****/
		if (sigType != V(ifpTxInf).lastSig)
			V(ifpTxInf).lastSig = sigType;

		/**** Count the number of silence frames in the packet ****/
		if (sigType == SILENCE)
			V(ifpTxInf).silenceFrms ++;

		/**************************************************************
		** Extract and check the size of the currently indexed frame, *
		** if it's too big, then quit depacketisation and queueing    *
		***************************************************************/
		temp = MACRO_FAX_FRAME_LEN(pkt->media + V(ifpTxInf).offset);
		if (temp > FRAME_LEN_14_4) {
			WARNING(vglob_ptr,WARN_IFP_BAD_FRAME_LEN);
			V(TX_RETVAL) = IFP_BAD_PNET_FRAME;
			goto emergency_exit;
		}

		/**********************************************************
		** Copy in the valid media (ie length of frame) then fill *
		** the remaining 80 bytes with zeros.                     *
		***********************************************************/
		for (L2 = 0; L2 < temp; L2 ++) {
			V(ifpTxInf).frame.media[L2] = pkt->media[V(ifpTxInf).offset++];
			if (V(ifpTxInf).offset > pkt->length) {
				WARNING(vglob_ptr,WARN_IFP_BAD_PAYLOAD);
				V(TX_RETVAL) = IFP_BAD_PNET_FRAME;
				goto emergency_exit;
			}
		}

		/***********************************************************
		** Clear out the remaining portion of the frame that'll be *
		** passed to the DSP - we don't want to confuse the remod. *
		************************************************************/
		for (L2 = temp; L2 < 80; L2++)	// FAX_FRAME_LEN
			V(ifpTxInf).frame.media[L2] = 0x00;

		/***********************************************************
		** Okay, now finish setting up the frame by setting the    *
		** length and the codec type before passing to queue_frame *
		************************************************************/
		V(ifpTxInf).frame.length = 80;	// FAX_FRAME_LEN
		V(ifpTxInf).frame.codec  = DEMOD;

		/*********************************************************
		** Check what queue_frame() returns - we'll insert stats *
		** logging in here later!                                *
		**********************************************************/
		switch( queue_frame(vglob_ptr, &V(ifpTxInf).frame, V(ifpTxInf).frame.media) ) {
		case TOO_OLD:
			break;
		case OVERLOAD:
			break;
		case DUPLICATE:
			break;
		case QUEUED:
			break;
		}

		/**********************************************************
		** Subsequent frames will be redundant and therefore must *
		** be passed with lower frame IDs.                        *
		***********************************************************/
		V(ifpTxInf).frame.ID--;
	}

	/******************************************************************
	** Silence burst has been received - buildout may be recalibrated *
	** on next received packet.                                       *
	*******************************************************************/
	if (V(ifpTxInf).silenceFrms && V(ifpTxInf).silenceFrms >= V(ifpTxInf).numFrames - 1)
		V(ifpTxInf).initialPkt = True;

	V(TX_RETVAL) = OKAY;

emergency_exit:	// used to get out quick in the event of a bad packet
	L1 = 0;		// need this dummy instruction to stop compiler complaining
}


/******************************************************************************
** Function : ifp_process_packet                                              *
*******************************************************************************
** Modification History :                                                     *
**                                                                            *
**[Release 2]-----------------------------------------------------------------*
** Date            Ver   Dev  Comments                                        *
** 25th Jan  1999  2.0   RGT  Initial Revision (stub - negative capability)   *
**                                                                            *
** 20th Apr  1999  2.1   RGT  Added in IFP header processing code.            *
**                                                                            *
*******************************************************************************
** Description :                                                              *
**   This function attempts to read and parse through an IFP header, assumed  *
** to be located at the start of the packet it is passed. If it does not      *
** "believe" that the data presented is from an IFP packet, it returns False. *
**                                                                            *
*******************************************************************************
** Arguments :                                                                *
**   ______________________________________________________________________   *
**  | Type       | arg name | Description                                  |  *
**  |------------+----------+----------------------------------------------|  *
**  | packet_t * | pkt      | Pointer to packet structure for processing   |  *
**   ----------------------------------------------------------------------   *
**                                                                            *
*******************************************************************************
** Return Values: type Boolean                                                *
**                                                                            *
**    False   If a Bad RTP header is encountered, or an unsupported payload   *
**    True    otherwise                                                       *
*******************************************************************************/
Boolean ifp_process_packet(VGLOB *vglob_ptr, packet_t *pkt)
{
	ifpHeader_t		* header;

	header = (ifpHeader_t *)pkt->media;

	if (header->control != 0x00)
		return False;

	V(ifpTxInf).sequence  = ntohs(header->sequence);

/*****************************************************************************
** Queueing and Jitter Calculation Section :                                 *
****** Let us begin by assuming normal positive queue (i.e. that the current *
	** sequence is "newer" than the last). We must now check to ensure that  *
	** we know exactly where to store this new packet's data relative to the *
	** media from the last packet.                                           *
	**************************************************************************/
	V(ifpTxInf).positiveQueue = True;

	/*** Relative time difference calculation with 16-bit wraparound ***/
	if (V(ifpTxInf).sequence - V(ifpTxInf).lastSeq < 1000)
		V(ifpTxInf).txTime = V(ifpTxInf).sequence - V(ifpTxInf).lastSeq;
	else
		/*** Probably 16-bit sequence wrap - check to make certain ***/
		if (V(ifpTxInf).lastSeq - V(ifpTxInf).sequence < 1000) {
			V(ifpTxInf).positiveQueue = False;
			V(ifpTxInf).txTime = V(ifpTxInf).lastSeq - V(ifpTxInf).sequence;
		} else
			V(ifpTxInf).initialPkt = True;

	if ((V(ifpTxInf).numFrames = header->numFrames) > IFP_MAX_FRAMES_PER_PKT)
		return False;

	/*****************************************************
	** Perform basic sanity check on the first FAX frame *
	******************************************************/
	if (MACRO_FAX_SIG_TYPE(pkt->media+4) < 0x200 || 
	    MACRO_FAX_SIG_TYPE(pkt->media+4) > 0x21F ||
		MACRO_FAX_FRAME_LEN(pkt->media+4) > 60)
		return False;

	/*********************************************************************
	** Set up the offset for frame extraction, ie skip over the header   *
	** we've just finished processing. Also reset the silence frames     *
	** counter to zero ready for the assembler - for silence suppression *
	**********************************************************************/
	V(ifpTxInf).offset      = 4; // IFP_HDR_SIZE !!!
	V(ifpTxInf).silenceFrms = 0;

	return True;	// good IFP packet !
}



/*********************[ FUNCTION VERSION VERSION TRACKING ]********************

 _____________________________________________________________________________
|                            |            exchange.obj  Version               |
|   Function Name            |  2.0 |  2.1 |  2.2 |  2.3 |  2.4 |  2.5 |  2.6 | 
|----------------------------+------+------+------+------+------+------+------|
| ifp_rx_config              |  2.0 |  2.1 |      |      |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| ifp_rx                     |  2.0 |  2.1 |      |      |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| assemble_header            |  2.0 |  2.1 |      |      |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| ifp_tx_config              |  2.0 |  2.1 |      |      |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| ifp_tx                     |  2.0 |  2.1 |      |      |      |      |      |
|----------------------------+------+------+------+------+------+------+------|
| ifp_process_packet         |  2.0 |  2.1 |      |      |      |      |      |
 ----------------------------------------------------------------------------- 

**********************[ FUNCTION VERSION VERSION TRACKING ]********************/
