/*name and version number:@(#)dpvmax1.c	1.23*/
/*date of get: 		  09/06/00 16:59:06*/
/*date of delta:	  03/02/00 10:03:33*/
/****************************************************************
File :	dpvmax1.c
Description :
	Contains all functions related to the dsp16a v.flex2 data pump interface.

Procedures Contained :

Revision History :
	Initials	Date		Change
	J.S.Xu		12/02/96	Created
*****************************************************************/

#include "llglob_d.h"
#ifdef K56FLEX
#define DSP1643
#include "dpglob.h"
#include "dpvmax.h"
#include "allglobs.h"

extern int diag_log_opt;

extern void s_printf(byte *dest, const byte *src1, int flag, const byte *src2,
		 const byte *src3, word val) ;
extern byte readbio ( word portbit ) ;
extern void dp_vmax_init(void);
extern byte dp_vmax_training(void);

extern int dp_vmax_log_DSP_data(unsigned char* fname);
extern TIME_MIN_SEC  dp_long_timer ;       // Timer for s7


/******************************************************************
	V.MAX defines
*******************************************************************/
#define VMAX_IDLE			0x32

#define CHOCMODE		0x0000
#define WAIT_DSP_RAM	0x0092
#define WAIT_DSP_VAL	0x7fff
#define STEP1_RAM		0x4000
#define DOWNSTREAM_STATUS	0x3a
#define UPSTREAM_STATUS		0x3b

#define FLAG_NONE   0
#define FLAG_STRING 1
#define FLAG_INT    2
#define FLAG_HEX	3

typedef enum {
	DP_VMAX_INIT,
	DP_VMAX_TRAINING,
	DP_VMAX_WAIT_FOR_DATA,
	DP_VMAX_ON_DIAL,
	DP_VMAX_FAIL,
	DP_VMAX_RING
} DP_VMAX_BG_STATE ;


/**************************************************************************
	Global Variables
***************************************************************************/

byte dp_run_vmax ;
DP_VMAX_BG_STATE dp_vmax_bg_state ;
VMAX_STATUS dp_vmax_status ;
byte ring_flag = 0 ;
byte carrier_flag = 0 ;
word ring_timer ;
byte s_print_flag = 0;
byte flag_3com_56k = FALSE;
const word wDspMjFir[] =	/* download to DPRAM */
{
0x1B34, 0x0072, 0xCD4C, /* Address, size, checksum */
0x0000, 0x0000, 0x0003,
0xFFFF, 0xFFF5, 0xFFE7,
0xFFDB, 0xFFDC, 0xFFF2,
0x001C, 0x0045, 0x0054,
0x0034, 0xFFE6, 0xFF8D,
0xFF5C, 0xFF80, 0xFFFC,
0x00A0, 0x0112, 0x0100,
0x0054, 0xFF4C, 0xFE6E,
0xFE43, 0xFF0B, 0x0086,
0x0206, 0x02B7, 0x0213,
0x0033, 0xFDDE, 0xFC33,
0xFC27, 0xFE04, 0x0131,
0x0468, 0x063C, 0x05B1,
0x02A8, 0xFDEB, 0xF8D5,
0xF4CC, 0xF2BF, 0xF2E7,
0xF4D1, 0xF7AB, 0xFA98,
0xFCFE, 0xFE9D, 0xFF81,
0xFFE3, 0x0025, 0x006F,
0x000E, 0x0037, 0x0032,
0x003C, 0x0042, 0x004A,
0x0051, 0x0058, 0x0060,
0x0067, 0x006F, 0x0076,
0x007D, 0x0083, 0x0089,
0x008F, 0x0093, 0x0097,
0x009A, 0x009B, 0x009C,
0x009A, 0x0098, 0x0093,
0x008D, 0x0085, 0x007B,
0x006E, 0x0060, 0x004E,
0x003A, 0x0024, 0x000A,
0xFFEE, 0xFFCE, 0xFFAC,
0xFF86, 0xFF5E, 0xFF32,
0xFF02, 0xFECF, 0xFE99,
0xFE60, 0xFE23, 0xFDE3,
0xFDA0, 0xFD5A, 0xFD10,
0xFCC3, 0xFC73, 0xFC20,
0xFBCB, 0xFB72, 0xFB17,
0xFABA, 0xFA5A, 0xF9F7,
0xF993, 0xF92D, 0x3C1F
};

const word wDspV34Fall[] =	/* download to DPRAM */
{
0x1800, 0x003F, 0x02EB, /* Address, size, checksum */
0x5200, 0x0000, 0x30C0,
0x30C0, 0x30C0, 0x30C0,
0x30C0, 0x46A0, 0xC1D1,
0xFDFF, 0x4AA0, 0x52C0,
0xC03D, 0x5080, 0x4F9E,
0xC300, 0xC1D1, 0xFFF7,
0x52C0, 0xC000, 0x7082,
0x30C0, 0x52E0, 0x00E1,
0x30C0, 0x1E71, 0x8832,
0x52C0, 0xC000, 0x7082,
0x30C0, 0x52E0, 0x00E1,
0x30C0, 0x52C0, 0xC001,
0x7082, 0x30C0, 0x52E0,
0x001E, 0x30C0, 0x5080,
0x40DF, 0xC300, 0x5080,
0x7614, 0xC300, 0x5080,
0x4011, 0xC200, 0x1400,
0x5070, 0x1800, 0x5150,
0xFFD0, 0x1200, 0x1C00,
0x70FF, 0x6059, 0xD00B,
0x0839, 0x1600, 0xC000
};

const word wDspV34LeaseLine[] =
{
0x1900, 0x0034, 0x9FF6, /* Address, size, checksum */
0x1880, 0x38D0, 0xC371,
0x5AED, 0xD002, 0x0919,
0xC371, 0x744C, 0xD002,
0x0919, 0xC371, 0x958C,
0xD002, 0x0913, 0xC371,
0x91CA, 0xD002, 0x0916,
0xC000, 0x5110, 0x95A0,
0x0932, 0x5110, 0x91DE,
0x0932, 0x609E, 0x5080,
0x5EDE, 0xC300, 0x30CD,
0x789C, 0x5110, 0x0060,
0x5000, 0x082F, 0xA0D0,
0x5110, 0xFF10, 0x187F,
0xA0D1, 0x1A83, 0x3CD4,
0x99CE, 0xD002, 0x0930,
0x5110, 0x9182, 0x0932,
0x5110, 0x9541, 0xA0D0,
0xC000
};

/****************************************************************
Routine : dp_56k_originate
*****************************************************************/
byte dp_56k_originate ( void )
{
	if ( S.ModemOptions.Dummy111 != 1  && flag_3com_56k == FALSE)
	{
		x_debug_msg("56k-originate: return FALSE ") ;
		return ( FALSE ) ;
	}

	if ( (S.ModemOptions.Rate56K) != 0 )
	{
		x_debug_msg ( "dp - 56k originate cmd" ) ;
		dp_state = DP_56K ;
		dp_vmax_bg_state = DP_VMAX_INIT ;
		return ( TRUE ) ;
	}
	else
	{
		return ( FALSE ) ;
	}
}
/****************************************************************
Routine : dp_56k_answer
*****************************************************************/
byte dp_56k_answer ( void )
{
	if ( S.ModemOptions.Dummy111 != 1 )
		return ( FALSE ) ;
	if ( (S.ModemOptions.Rate56K) != 0 )
	{
		x_debug_msg ( "dp - 56k answer cmd" ) ;
		dp_state = DP_56K ;
		dp_vmax_bg_state = DP_VMAX_INIT ;
		return ( TRUE ) ;
	}
	else
	{
		return ( FALSE ) ;
	}
}
/****************************************************************
Routine :
*****************************************************************/
void dp_vmax_originate_cmd ( void )
{
	x_debug_msg ( "vmax - set chocmod" ) ;
	dp_write_dsp_ram ( CHOCMODE, 0x0000) ;
	x_debug_msg ( "vmax - offhook" ) ;
	dp_regwrite (0x37, 0x11);
	x_debug_msg ( "vmax - turn on interrupt") ;
	dp_modem_command ( 0x35, 0x01, 0 );

	if( S.ModemOptions.Dummy111 == 0){//reduce dsp waiting time 10sec only for 3com
		x_debug_msg("vmax - write 0x01 to loc 0x36");
		dp_write_dsp_ram (0x36, 0x01);
	}
	
	x_debug_msg ( "vmax - run choc dsp" ) ;
	dp_modem_command ( VMAX_STARTUP, 0, 0 ) ;
}

/****************************************************************
Routine :
*****************************************************************/
void dp_vmax_answer_cmd ( void )
{
	if ( S.ModemOptions.Rate56K == 200 )	// ISDN side
	{
		x_debug_msg ( "vmax - set chocmod to +1" ) ;
		dp_write_dsp_ram ( CHOCMODE, 0x0001) ;
	}
	else
	{
		x_debug_msg ( "vmax - set chocmod to -1" ) ;
		dp_write_dsp_ram ( CHOCMODE, 0xffff) ;
	}
	x_debug_msg ( "vmax - offhook" ) ;
	dp_regwrite (0x37, 0x11);
	x_debug_msg ( "vmax - turn on interrupt") ;
	dp_modem_command ( 0x35, 0x01, 0 ) ;
	x_debug_msg ( "vmax - run choc dsp" ) ;
	dp_modem_command ( VMAX_STARTUP, 0, 0 ) ;
}


void dp_vmax_set_line_rate ( void )
{
	byte number_of_levels ;
	byte rate ;
	word dmin_inp;
	byte s38;


	s38 = S.ModemOptions.Rate56K;
	if ( s38 >= 100 )
		s38 = S.ModemOptions.Rate56K - 100 ;
	//WZ001	
	switch ( s38 )
	{
		case 1:
			dmin_inp = 0;
			break;
		case 2:
			dmin_inp = 200;
			break;
		case 3:
			dmin_inp = 500;
			break;
		default:
			dmin_inp = 0;
			break;	

	}

#if 0	//for debug
	if( s38 > 3 && s38 != 200 && s38 != 100)
		dmin_inp = 2*s38;
#endif	
	
	x_debug_msg("vmax - set block rate to 6/7") ;
	dp_write_dsp_ram ( 0x004e, 0xffff) ;

	if(s38 !=200)
	{
		// use the dmin_inp to  ram 0xd
		dp_write_dsp_ram ( 0x0d, dmin_inp) ;	// dmin
		fprintf(szBuffer, "vmax - write loc 0x0d val %d", dmin_inp);
		x_debug_msg(szBuffer);
	}
	
	dp_write_dsp_ram (0x0e, 0x0);	//always write 0 to 0x0e, level selection
	dp_write_dsp_ram (0x39, 0x3);	// 8 levels for the Upstream

	//dp_write_dsp_ram ( 0x000e, number_of_levels) ;	// set level selection
}


void dp_init_vmax_dsp ( void )
{
	dp_vmax_set_line_rate ();
	// Set some Ram locations 
	x_debug_msg("vmax - ram0x0008=0x0800") ;
	dp_write_dsp_ram ( 0x0008,0x0800) ;		// mj_gain
	x_debug_msg("vmax - ram0x001b=0x0006") ;
	dp_write_dsp_ram ( 0x001b, 0x0006 ) ;	// upstream ec training delay
	if ( (S.ModemOptions.Rate56K & 0x64) == 0x64 )	// 100
	{
		// back to back testing
		x_debug_msg("vmax - ram0x0013=0x000e") ;
		dp_write_dsp_ram ( 0x0013, 0x000e ) ;	// upstream training delay
	}
	else
	{
		x_debug_msg("vmax - ram0x0013=0x0006") ;
		dp_write_dsp_ram ( 0x0013, 0x0006 ) ;	// upstream training delay
	}
	if ( x_modem_originate == FALSE ) // answer mode
	{
		x_debug_msg("vmax - ram0x0025=0x0040") ;
		dp_write_dsp_ram ( 0x0025, 0x0040 ) ;	// vec step size

		if (S.ModemOptions.Rate56K == 200)
		{
			// box side
			x_debug_msg("vmax - Initialize box ISDN hardware") ;
			dp_regwrite (0xba, 0x40) ;
			dp_regwrite (0xbb, 0x44) ;
		}
	}
	else
	{
		// modem side
		x_debug_msg("vmax - ram0x0025=0x0100") ;
		dp_write_dsp_ram ( 0x0025, 0x0100 ) ;	// vec step size
		x_debug_msg("vmax - ram0x003e=0x4650") ;
		dp_write_dsp_ram ( 0x003e, 0x4650 ) ;	// vec training length
	}
	x_debug_msg( "vmax - set pll") ;
//	dp_modem_command_long ( 0x2e, 0x01, 0x33, 0xe2, 0 ) ;	// 44Mhz
//	dp_modem_command_long ( 0x2e, 0x01, 0x38, 0x07, 0 ) ;	// 49Mhz
	dp_modem_command_long ( 0x2e, 0x01, 0x32, 0x0b, 0 ) ;	// 71.8848Mhz
	if ( S.ModemOptions.Rate56K == 200 )
	{
		x_debug_msg( "vmax - set SIO") ;
//		dp_modem_command_long( 0x1b, 0x10, 0x20, 0, 0 ) ;
		dp_modem_command ( 0x34, 0, 0 ) ;
	}
	else
	{
		x_debug_msg( "vmax - set murcury") ;
		if ( (S.ModemOptions.Rate56K & 0x64) == 0x64 )	// 100
		{
			// back to back testing
			dp_regwrite ( 0x32, 0x0e ) ;
			dp_modem_command_long( 0x2f, 0x01, 0xc9, 0x90, 0xfe ) ;
		}
		else
		{
			// real network client side
			dp_regwrite ( 0x32, 0x0e ) ;
			dp_modem_command_long( 0x2f, 0x01, 0xc9, 0x90, 0xcd ) ;
		}
	}
	x_debug_msg( "vmax - use EROM") ;
	dp_modem_command_long( 0x31, 0x01, 0x42, 0x8, 0) ;
}
void dp_download_mjfir ( void )
{
	x_debug_msg("vmax - download Mj Filter") ;
	dp_download_dsp ( (byte *)&wDspMjFir[0], (word)(sizeof(wDspMjFir)/sizeof(word)) ) ;
}
void dp_download_Vflex2Dperom( void )
{
	x_debug_msg("vmax - download Vflex2 .dperom") ;
	dp_download_dsp ( (byte *)&wDspVflex2Dperom[0], (word)(sizeof(wDspVflex2Dperom)/sizeof(word)) ) ;
}
#ifdef DSP1643
void dp_run_rom ( void )
{
	x_debug_msg("vmax - download V.34 Fallback workaround") ;
	dp_download_dsp ( (byte *)&wDspV34Fall[0], (word)(sizeof(wDspV34Fall)/sizeof(word)) ) ;
	dp_modem_command ( 0x1b, 0xd8, 0 ) ;

	dp_run_vmax = FALSE ;
	dp_modem_command ( MODEM_IDLE, 0, 0 ) ;
	// Initialize Mercury gains
	dp_set_mercury_gain ( ) ;
}
void dp_download_vmax ( void )
{
	x_debug_msg("vmax - download V.flex2 dsp code") ;
	dp_download_dsp ( (byte *)&wDspVflex2[0], (word)(sizeof(wDspVflex2)/sizeof(word)) ) ;
}
void dp_run_ram ( void )
{
	if ( dp_run_vmax == FALSE )
	{
		dp_download_vmax ();

		//download Vflex2 .dperom section
		dp_download_Vflex2Dperom();
		
		// 0x7d is main_vec to run idle function like tone det etc.
		// init it to a NULL return value
		dp_write_dsp_ram ( 0x7d, 0x42f8 ) ;
		// Power up value for IOC is 0x4008,
		// Turn on IROM32K to switch memory map
		dp_modem_command_long( 0x31, 0x01, 0x42, 0x8, 0) ;
		// Jump to 0x8000 to run choc
		dp_modem_command ( 0x1b, 0x80, 0 ) ;
		dp_run_vmax = TRUE ;

		dp_download_mjfir () ;
		//REM use 0 wait state ERAM
		//dp_modem_command_long ( 0x31, 0,0,0,0 ) ;
		//use 1 wait sate ERAM
		dp_modem_command_long ( 0x31, 0x00, 0x11, 0x11, 0 ) ;
	}
}
#else	// for DSP1640 and DSP1642
void dp_run_rom ( void )
{
	byte regde ;

	regde = dp_regread ( 0xde ) ;
	regde = regde | 0x01 ;
	regde = regde & 0xdf ;
	dp_regwrite ( 0xde, regde ) ;
	// sleep for a while
	x_sleep (50) ;
	regde = regde & 0xfe ;
	dp_regwrite ( 0xde, regde ) ;
	dp_run_vmax = FALSE ;

	dp_init_modem () ;
	dp_init_modem () ;	// run twice
}
void dp_run_ram ( void )
{
	byte regde ;

	if ( dp_run_vmax == FALSE )
	{
		regde = dp_regread ( 0xde ) ;
		regde = regde | 0x21 ;
		dp_regwrite ( 0xde, regde ) ;
		// sleep for a while
		x_sleep (50) ;
		regde = regde & 0xfe ;
		dp_regwrite ( 0xde, regde ) ;
		dp_run_vmax = TRUE ;

		dp_download_mjfir () ;
		//REM use 0 wait state ERAM
		dp_modem_command_long ( 0x31, 0,0,0,0 ) ;
	}
}
void dp_download_vmax ( void )
{
}
#endif
void dp_init_status ( void )
{
	dp_vmax_status.Connection = FALSE;
	dp_vmax_status.DownstreamRate = FALSE;
	dp_vmax_status.UpstreamRate = FALSE;
	dp_vmax_status.ChannelModeling = FALSE;
	dp_vmax_status.Equalizer1 = FALSE;
	dp_vmax_status.Equalizer2 = FALSE;
	dp_vmax_status.Equalizer3 = FALSE;
	dp_vmax_status.Equalizer4 = FALSE;
	dp_vmax_status.Equalizer5 = FALSE;
	dp_vmax_status.Equalizer6 = FALSE;
	dp_vmax_status.RobbedBitPattern = FALSE;
	dp_vmax_status.RobbedBitType = FALSE;
	dp_vmax_status.ChocRMS = 0;
	dp_vmax_status.TimingMSE = FALSE;
	dp_vmax_status.EchoMSE = FALSE;
	dp_vmax_status.EchoAvg = 0;
	dp_vmax_status.RobLvlTotl = 0;
	dp_vmax_status.RoblvlTotlA = 0;
	dp_vmax_status.MdmTxDelay = 0;
	dp_vmax_status.BoxRtDelay = 0;
	dp_vmax_status.MdmRtDelay = 0;
	dp_vmax_status.ChocRcvLvl = 0;
	dp_vmax_status.Sptr = 0;
	dp_vmax_status.SPtrTx = 0;
	dp_vmax_status.DownstreamLevels = FALSE;
	dp_vmax_status.UpstreamLevels = FALSE;
	dp_vmax_status.DigitalLoss = FALSE;
	dp_vmax_status.FailureCode = TRUE; //FALSE;
}
void dp_vmax_update_status ( void )
{
	dp_vmax_status.Connection = (dp_vmax_status.FailureCode == FALSE) ? TRUE : FALSE;

	if(dp_vmax_status.FailureCode == FALSE)
	{
		dp_vmax_status.DownstreamLevels = (byte)dp_read_dsp_ram ( 0x34 ) ;

		switch( dp_vmax_status.DownstreamLevels )
		{
		case 16:
			x_line_rate = MR_26400 ;
			dp_vmax_status.DownstreamRate = 27400 ;
			break;
		case 22:
			x_line_rate = MR_31200 ;
			dp_vmax_status.DownstreamRate = 30600 ;
			break;
		case 32:
			x_line_rate = MR_34000 ;
			dp_vmax_status.DownstreamRate = 34300 ;
			break;
		case 44:
			x_line_rate = MR_36000 ;
			dp_vmax_status.DownstreamRate = 37400 ;
			break;
		case 64:
			x_line_rate = MR_40000 ;
			dp_vmax_status.DownstreamRate = 41100 ;
			break;
		case 80:
			x_line_rate = MR_42000 ;
			dp_vmax_status.DownstreamRate = 43400 ;
			break;
		case 96:
			x_line_rate = MR_44000 ;
			dp_vmax_status.DownstreamRate = 45100 ;
			break;
		case 102:
			x_line_rate = MR_46000 ;
			dp_vmax_status.DownstreamRate = 45700 ;
			break;
		default:
			x_line_rate = MR_48000 ;
			dp_vmax_status.DownstreamRate = 47100 ;
			break;

		}
	}else{
		dp_vmax_status.DownstreamLevels = 0;
		dp_vmax_status.DownstreamRate = 0;
	}

	if ( x_modem_originate == FALSE )
		x_line_rate = MR_19200 ;

	dp_vmax_status.UpstreamRate = (dp_vmax_status.FailureCode == TRUE)? 0 : 20500;
	dp_vmax_status.RobbedBitPattern = (byte)dp_read_dsp_ram(0xc);
	dp_vmax_status.RobbedBitType = (byte)dp_read_dsp_ram(0x2e);
	dp_vmax_status.ChocRMS = dp_read_dsp_ram(0x2);
	dp_vmax_status.TimingMSE = dp_read_dsp_ram(0x37);
	dp_vmax_status.EchoMSE = dp_read_dsp_ram(0x21);
	dp_vmax_status.EchoAvg = dp_read_dsp_ram(0x1e);
	dp_vmax_status.RobLvlTotl = dp_read_dsp_ram(0x32);
	dp_vmax_status.RoblvlTotlA = dp_read_dsp_ram(0x33);
	dp_vmax_status.MdmTxDelay = dp_read_dsp_ram(0x3f);
	dp_vmax_status.BoxRtDelay = dp_read_dsp_ram(0x4f);
	dp_vmax_status.MdmRtDelay = dp_read_dsp_ram(0x50);
	dp_vmax_status.ChocRcvLvl = dp_read_dsp_ram(0x60);
	dp_vmax_status.Sptr = dp_read_dsp_ram(0x80);
	dp_vmax_status.SPtrTx = dp_read_dsp_ram(0x4b);
	dp_vmax_status.UpstreamLevels = (dp_vmax_status.FailureCode == TRUE)? 0 : 8;
	dp_vmax_status.DigitalLoss = (byte)dp_read_dsp_ram(0x30);
}

/****************************************************************
Routine : dp_lease_line_startup
*****************************************************************/
void dp_lease_line_startup ( void )
{
	x_debug_msg("vmax - lease line mode") ;
//	S.ModemOptions.VmaxDialLineRate = 0 ;	// disable V.flex2
	S.ModemOptions.Rate56K = 0 ;	// disable V.flex2
	// download patch for V34 Lease Line Mode
	dp_download_dsp ( (byte *)&wDspV34LeaseLine[0], (word)(sizeof(wDspV34LeaseLine)/sizeof(word)) ) ;
	// Activate DPRAM_baud
	dp_write_dsp_ram ( 0x0f20, 0xd900 ) ;
	if ( x_modem_originate == FALSE ) // answer mode
	{
		x_debug_msg("vmax - startup lease line V34 answer") ;
		dp_answer_cmd ();
	}
	else
	{
		x_debug_msg("vmax - startup lease line V34 originate") ;
		dp_originate_cmd ();
	}
}
void dp_diagnostics ( void )
{
	byte msg[70], *src;
	byte *sVMAX[] =
	{
		"LastVflex - ",	  /* line 0 */
		"DnRate ",		  /* line 1 */
		"UpRate ", 		  /* line 2 */
		"ChanMdl ", 	  /* line 3 */
		"Eq1 SNR ", 	  /* line 4 */
		"Eq2 SNR ", 	  /* line 5 */
		"Eq3 SNR ", 	  /* line 6 */
		"Eq4 SNR ", 	  /* line 7 */
		"Eq5 SNR ", 	  /* line 8 */
		"Eq6 SNR ", 	  /* line 9 */
		"RobPtn  ",       /* line 10 */
		"RobType ", 	  /* line 11 */
		"ChocRMS ",       /* line 12 */	
		"TimeMSE ",		  /* line 13 */
		"EchoMSE ", 	  /* line 14 */
		"EchoAvg ",       /* line 15 */
		"RobLvl  ",       /* line 16 */
		"RobLvlA ",       /* line 17 */
		"MdmTxAvg ",      /* line 18 */
		"BoxRtDly ",      /* line 19 */
		"MdmRtDly ",      /* line 20 */
		"ChcRxLvl ",      /* line 21 */
		"S Ptr    ",      /* line 22 */
		"S Ptr TX ",      /* line 23 */
		"D Lvls ", 		  /* line 24 */
		"U Lvls ", 		  /* line 25 */
		"DigLoss ", 	  /* line 26 */
		"FailCode " 	  /* line 27 */
	};

	//src = "Description   Status " ;

	//s_printf(msg, src, FLAG_NONE, NULL, NULL, 0);
	//src = "-----------   ----------- ";
	//s_printf(msg, src, FLAG_NONE, NULL, NULL, 0);

	src = (dp_vmax_status.Connection) ? "Successful" : "Failure";
	s_printf(msg,sVMAX[0],FLAG_STRING, src, NULL, 0);
	s_printf(msg,sVMAX[1],FLAG_INT,NULL,NULL,(dp_vmax_status.DownstreamRate));
	s_printf(msg,sVMAX[2],FLAG_INT,NULL,NULL,(dp_vmax_status.UpstreamRate));
	s_printf(msg,sVMAX[3],FLAG_INT,NULL,NULL,(dp_vmax_status.ChannelModeling));

	s_printf(msg,sVMAX[4],FLAG_INT,NULL,NULL,(dp_vmax_status.Equalizer1));
	s_printf(msg,sVMAX[5],FLAG_INT,NULL,NULL,(dp_vmax_status.Equalizer2));
	s_printf(msg,sVMAX[6],FLAG_INT,NULL,NULL,(dp_vmax_status.Equalizer3));
	s_printf(msg,sVMAX[7],FLAG_INT,NULL,NULL,(dp_vmax_status.Equalizer4));
	s_printf(msg,sVMAX[8],FLAG_INT,NULL,NULL,(dp_vmax_status.Equalizer5));
	s_printf(msg,sVMAX[9],FLAG_INT,NULL,NULL,(dp_vmax_status.Equalizer6));

	s_printf(msg,sVMAX[10],FLAG_HEX,NULL,NULL,(dp_vmax_status.RobbedBitPattern));
	s_printf(msg,sVMAX[11],FLAG_HEX,NULL,NULL,(dp_vmax_status.RobbedBitType));
	s_printf(msg,sVMAX[12],FLAG_HEX,NULL,NULL,(dp_vmax_status.ChocRMS));
	
	s_printf(msg,sVMAX[13],FLAG_HEX,NULL,NULL,(dp_vmax_status.TimingMSE));
	s_printf(msg,sVMAX[14],FLAG_HEX,NULL,NULL,(dp_vmax_status.EchoMSE));
	s_printf(msg,sVMAX[15],FLAG_HEX,NULL,NULL,(dp_vmax_status.EchoAvg));
	s_printf(msg,sVMAX[16],FLAG_HEX,NULL,NULL,(dp_vmax_status.RobLvlTotl));
	s_printf(msg,sVMAX[17],FLAG_HEX,NULL,NULL,(dp_vmax_status.RoblvlTotlA));
	s_printf(msg,sVMAX[18],FLAG_HEX,NULL,NULL,(dp_vmax_status.MdmTxDelay));
	s_printf(msg,sVMAX[19],FLAG_HEX,NULL,NULL,(dp_vmax_status.BoxRtDelay));
	s_printf(msg,sVMAX[20],FLAG_HEX,NULL,NULL,(dp_vmax_status.MdmRtDelay));
	s_printf(msg,sVMAX[21],FLAG_HEX,NULL,NULL,(dp_vmax_status.ChocRcvLvl));

	s_printf(msg,sVMAX[22],FLAG_HEX,NULL,NULL,(dp_vmax_status.Sptr));
	s_printf(msg,sVMAX[23],FLAG_HEX,NULL,NULL,(dp_vmax_status.SPtrTx));
	s_printf(msg,sVMAX[24],FLAG_INT,NULL,NULL,(dp_vmax_status.DownstreamLevels));
	s_printf(msg,sVMAX[25],FLAG_INT,NULL,NULL,(dp_vmax_status.UpstreamLevels));
	s_printf(msg,sVMAX[26],FLAG_HEX,NULL,NULL,(dp_vmax_status.DigitalLoss));
//	s_printf(msg,sVMAX[27],FLAG_INT,NULL,NULL,(dp_vmax_status.FailureCode));
}

byte dp_vmax_ring ( void )
{
	if ( x_elapsed_time ( ring_timer ) < MS500 )
		return ( FALSE ) ;
	if ( readbio ( 0x110 ) == 0 )
	{
		carrier_flag = 0 ;
		ring_flag = 0 ;
	}
	else
	{
		if ( ring_flag == 0 )
		{
			ring_flag = 1 ;
			return ( TRUE ) ;
		}
	}
	return ( FALSE ) ;
}
void dp_56k_ring ( void )
{
	if ( (S.ModemOptions.Rate56K == 200) && ( dp_vmax_ring () ) )
	{
		x_debug_msg ( "vmax - ring detected" ) ;
		x_send_mail ( DP_RING, AT_TASK, NULL, 0 ) ;
		dp_timer = x_current_time () ;
		dp_state = DP_56K ;
		S.ModemOptions.RingCount = 1 ;  
		dp_vmax_bg_state = DP_VMAX_RING ;
	}
}

/****************************************************************
Routine : dp_56k_disconnect
*****************************************************************/
void dp_56k_disconnect ( void )
{
	byte regde ;

	x_debug_msg("vmax - disconnect command") ;

	// initialize bamil & mercury I/O pins
	x_output ( IO_OUTPUT_INIT ) ;

	// reset the dsp to run from rom
	regde = dp_regread ( 0xde ) ;
	regde = regde | 0x01 ;
	regde = regde & 0xdf ;
	dp_regwrite ( 0xde, regde ) ;
	// sleep for a while
	x_sleep (50) ;
	regde = regde & 0xfe ;
	dp_regwrite ( 0xde, regde ) ;
	x_sleep (50) ;
	dp_run_vmax = FALSE ;

	dp_init_modem () ;
	dp_init_modem () ;	// run twice
	x_line_rate = MR_300 ;	// so that we will not send a clear down cmd.
	ring_timer = x_current_time () ;
	dp_state = DP_DISCONNECT ;
	x_dial_residual = MR_CD_DISCONNECT ;
	x_modem_state = MS_IDLE ;
	dp_timer = x_current_time () ;
	dp_run_vmax = FALSE ;
}

/****************************************************************
Routine : dp_56k_idle
*****************************************************************/
void dp_56k_idle ( void )
{
	if ( dp_run_vmax == TRUE )
	{
		x_debug_msg("vmax - idle command") ;
		dp_modem_command ( VMAX_IDLE, 0, 0 ) ;
		x_modem_state = MS_IDLE ;
		dp_run_rom () ;
		x_line_rate = MR_300 ;	// so that we will not send a clear down cmd.
	}
	ring_timer = x_current_time () ;
}

/****************************************************************
Routine : dp_vmax_background
*****************************************************************/
void dp_56k_background ( void )
{
	switch ( dp_vmax_bg_state )
	{
		case DP_VMAX_INIT :
			/* switch to Ram */
			dp_run_ram () ;
			dp_init_status () ;
			dp_init_vmax_dsp () ;
			// Initialize training parameters and state
			dp_vmax_init () ;
			if ( x_modem_originate == FALSE ) // answer mode 
				dp_vmax_answer_cmd () ;
			else	//originate mode
				dp_vmax_originate_cmd () ;
			// set state to do dsp training
			dp_vmax_bg_state = DP_VMAX_TRAINING ;
			x_debug_msg ( "vmax - wait for DSP" ) ;
			dp_timer = x_current_time () ;
			break ;

		case DP_VMAX_TRAINING :
			if (dp_vmax_training () == TRUE )
			{
				// finished training
				if ( dp_vmax_status.FailureCode == TRUE )
				{
					x_debug_msg("vmax - training failed") ;
					dp_vmax_bg_state = DP_VMAX_FAIL ;
				}
				else
				{
					x_debug_msg("vmax - go to wait for data mode") ;
					//put FailureCode back to TRUE because it still could be
					//failed during waiting for mode. 
					dp_vmax_status.FailureCode = TRUE;
					dp_vmax_bg_state = DP_VMAX_WAIT_FOR_DATA ;
					dp_timer = x_current_time () ;
					dp_async_8bit_mode () ;
				}
			}
			else if ( x_elapsed_time (dp_timer) >= SECOND50 )
			{
				x_debug_msg("vmax - training timer expired") ;
				dp_vmax_bg_state = DP_VMAX_FAIL ;
			}
			break ;
		case DP_VMAX_WAIT_FOR_DATA :
			if ( ( dp_read_dsp_ram(DOWNSTREAM_STATUS)&0x8 ) &&
				 ( dp_read_dsp_ram(UPSTREAM_STATUS)&0x8) )
			{
				x_debug_msg("vmax - data mode") ;
				//put False
				dp_vmax_status.FailureCode = FALSE;
				dp_vmax_update_status () ;
				dp_timer = x_current_time () ;
				dp_vmax_bg_state = DP_VMAX_ON_DIAL ;
				x_send_mail ( DP_IO_CONNECT, IO_TASK, NULL, 0 ) ;
				x_debug_msg("vmax - go to connect state") ;
		  		x_modem_state = MS_ON_DIAL ;
				carrier_flag = 1 ;

				x_debug_msg("vmax - dumping DSPdata after data mode");
				if(diag_log_opt == TRUE){
					dp_vmax_log_DSP_data("c:\\vmaxdsp2.log");
				}
			}
			else if ( x_elapsed_time (dp_timer) >= SECOND50 )
			{
				x_debug_msg("vmax - wait for data mode timer expired") ;
				dp_vmax_bg_state = DP_VMAX_FAIL ;
				x_debug_msg("vmax - dumping DSPdata");
				if(diag_log_opt == TRUE){
					dp_vmax_log_DSP_data("c:\\vmaxdsp2.log");
				}
			}
			break ;
		case DP_VMAX_ON_DIAL :
			//carrier loss detection
			dp_vmax_ring () ;
			if ( (S.ModemOptions.Rate56K == 200) && (carrier_flag==0) )
			{
				if ( x_elapsed_time (dp_timer) >= SECOND1 )
				{
					dp_56k_idle () ;
					dp_state = DP_DISCONNECT ;
					x_dial_residual = MR_CD_DISCONNECT ;
					dp_timer = x_current_time () ;
				}
			}
			else
				dp_timer = x_current_time () ;
			break ;
		case DP_VMAX_FAIL :
			x_debug_msg("vmax - fail, fallback to V.34") ;
			dp_vmax_status.FailureCode = TRUE ;
			dp_vmax_update_status();	//before switch to ROM update status
			dp_56k_idle () ;
			dp_vmax_bg_state = DP_VMAX_FAIL ;
			x_set_current_time ( &dp_long_timer ) ;
			dp_timer = x_current_time () ;
			if ( S.ModemOptions.Dummy111 == 1 )
			{
				dp_state = DP_DISCONNECT ;
				x_dial_residual = MR_CD_DISCONNECT ;
			}
			else
			{
				dp_lease_line_startup () ;
				dp_state = DP_TRAINING ;
			}
			break ;
		case DP_VMAX_RING :
			if ( x_elapsed_time (dp_timer) >= SECOND5 )
			{
				x_send_mail ( DP_RING, AT_TASK, NULL, 0 ) ;
				dp_timer = x_current_time () ;
				S.ModemOptions.RingCount++ ;    // increment rings detected 
				if ( (S.ModemOptions.AutoAnswer) &&
				 (S.ModemOptions.RingCount >= S.ModemOptions.AutoAnswer) )
				{
					x_modem_state = MS_ANSWERING ;
					dp_state = DP_ANSWERING ;
				}
			}
			if ( ring_flag == 0 )
			{
				S.ModemOptions.RingCount = 0 ;  
				dp_state = DP_WAIT_FOR_RING ;
			}
			break ;
	}
}
#endif
