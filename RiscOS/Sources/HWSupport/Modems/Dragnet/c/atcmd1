/*name and version number:@(#)atcmd1.c	1.255*/
/*date of get: 		  01/12/01 11:49:11*/
/*date of delta:	  01/11/01 13:13:36*/
/****************************************************************
File : atcmd1.c
Description :
	This file contains the following at command codes :

Procedures Contained :
	at_and_t	=> 		at&t 	- test commands
	at_and_v	=>		at&v	- view command
	at_and_and	=>		at&&?	- debug commands

Revision History :
	Initials	Date		Change
	J.S.Xu		10/07/92	Initial
	MB     		11/15/93	Initial
	AV     		03/26/94 	Added at&&n
	AV     		04/01/94 	Added at&&d, at&&t, at&&u, at&&w
	AV     		05/24/94  	Modified at%t
	RWF			11/07/95	Added at_percent_p() for support of
							PnP on external modems
							(emulation mode only).
	MAH			11/17/95	optimize at_view() for size
	JMG			06/17/98	add ATMEL non-sector-erase device support
*****************************************************************/

#include "llglob_d.h"
#include "atglob.h"
#include "dpglob.h"
#include "ioglob_d.h"
#include "lapm.h"		// extern lapm_n401 for #ud command
#include "z80glob.h"
#if defined(USB_MODEM) || defined(THUNDER)
# include "z80usb.h"
#endif
#include "sync.h"
#include "allglobs.h"

/****************************************************************
Routine : at_and_t
Description :
	This function process the AT&T command
*****************************************************************/
void at_and_t(void)
{
	switch( *G(at_cmd_ptr)++ )
	{
		case '0':			// abort
		case  0 :
			// if remote digital loopback - send OK here
			// for local analog loopback & local digital loopback - the
			// cmd from dptask is sent to IO task and finally an OK is sent
			if ( ( G(x_modem_state) != MS_LOCAL_TEST ) &&
				 ( G(x_modem_state) != MS_DTE_LOOPBACK ) )
			{
				G(at_result_code) = OK;
				at_output_msg(NULL, 0);
			}
			x_send_mail ( MC_ABORT_TEST, DP_TASK, NULL, 0);
			break;
		case '1':			// Local Analog Loop
			if ( G(x_modem_state) == MS_IDLE )
			{
				x_send_mail ( MC_ANALOG_LOOPBACK, DP_TASK, NULL, 0);
			}
			else
				at_cmd_err_ret ();
			break;
		case '3':			// Local Digital Loopback
			if ( G(x_modem_state) == MS_IDLE )
				x_send_mail ( MC_LOC_DIGITAL_LOOPBACK, DP_TASK, NULL, 0);
			else
			if ( (G(x_modem_state) == MS_ON_DIAL) &&
				 (G(x_modem_mode) == MODEM_DATA) && (G(x_modem_ec) == EC_NO) )
			{
				G(at_result_code) = OK;           
				at_output_msg(NULL, 0);        
				x_send_mail ( MC_REM_DATA_LOOPBACK, DP_TASK, NULL, 0);
				x_debug_msg("ATCMD1 - get AT&T3 cmd in data mode");
			}
			else
				at_cmd_err_ret ();
			break;
		case '6':			// Remote Digital Loopback test
			if ( (G(x_modem_state) == MS_ON_DIAL) &&
			     (G(x_modem_mode) == MODEM_DATA) && (G(x_modem_ec) == EC_NO) )
			{
				x_send_mail ( MC_REM_DIGITAL_LOOPBACK, DP_TASK, NULL, 0);
				x_send_mail ( AT_IO_ON_LINE, IO_TASK, NULL, 0) ;
			}
			else
				at_cmd_err_ret ();
			break;
		default :
			at_cmd_err_ret () ;
			break ;
	}
}

extern const byte str_convert[];
const byte str_blanks[] = "               ";
const byte str_enable[] = "Enabled";
const byte str_disable[] = "Disabled";
const byte str_stdrs232[] = "Standard RS232";
const byte str_x[] = "X";
const byte str_msec[] = "msec";
const byte str_V42bis[] = "V42bis";
const byte str_V42V44[] = "V44";
const byte str_MNP5[] = "MNP5";

// str_sec uses the 'msec' string but leaves off the 'm'
#define str_sec (str_msec+1)

#define FLAG_NONE   0
#define FLAG_STRING 1
#define FLAG_INT    2
#define FLAG_HEX	3
#define FLAG_STRING_NO_SPACES	4

/* s_printf() prints one line of the at_view() stuff.
 *
 * This is the most general form.  For almost all the
 * lines, we make use of one of the printViewLine...() functions.
 * These functions make use of the viewLine[] table
 * and other regularities of the output to reduce the
 * code size for these set of routines.
 */
void s_printf(const byte *src1, int flag, const byte *src2,
		 const byte *src3, word val)
{
	byte dest[80], *msg;
	word i ;

	msg = dest;
	dest[0] = 0;
	if (src1 != NULL)
	{
		x_send_at_io_data((byte *) (str_blanks + 11));	/* put 4 blanks */
		x_send_at_io_data((byte *) src1);
	}

	i = 0;
	switch (flag)
	{
	case FLAG_HEX:
	case FLAG_INT:
		i = at_itoa( val, msg, (byte) (FLAG_INT == flag ? DECIMAL : HEX));
		msg += i ;
		*msg++ = ' ' ;
		*msg++ = '\0' ;
		x_send_at_io_data(dest);
		if (src2 == NULL)
		{
			x_send_at_io_data((byte *) (str_blanks+i));
			break;
		}
		i++;
		/* drop thru - no BREAK */
	case FLAG_STRING:
		x_send_at_io_data((byte *) src2);
		/* pad with spaces if necessary */
		x_send_at_io_data((byte *) (str_blanks + i - 1 + x_strlen(src2)));
		break;

	case FLAG_STRING_NO_SPACES:
		x_send_at_io_data((byte *) src2);
		break;
	}
                
	if (src3 != NULL)
		x_send_at_io_data((byte *) src3);

	x_send_at_io_crlf();
}

/* Bits per second corresponding to the dial line rates
 * in the S37 register.
 */
const unsigned int at_dialLineRates[] =
{
		33600,	/* 0 */
		0,
		0,
		300,	/* 3 */
		0,
		1200,	/* 5 */
		2400,	/* 6 */
		4800,	/* 7 */
		7200,	/* 8 */
		9600,	/* 9 */
		12000,	/* 10 */
		14400,	/* 11 */
		16800,	/* 12 */
		19200,	/* 13 */
		21600,	/* 14 */
		24000,	/* 15 */
		26400,	/* 16 */
		28800,	/* 17 */
		31200,  /* 18 */
		33600,  /* 19 */
};

typedef const byte *CBP;

/* This table is used for the at_view() stuff.
 * The first member is the option name, the second
 * is the AT command associated with the option.
 */
struct one_line_str
{
	const byte *optionName;		/* name of the option */
	const byte *src3;			/* AT Cmd								*/
};

const struct one_line_str viewLine[] =
{
	{ (CBP) "Comm Standard", (CBP) "B" },		/* line 0 */
	{ (CBP) "CommandCharEcho", (CBP) "E" },		/* line 1 */
	{ (CBP) "Speaker Volume", (CBP) "L" },		/* line 2 */
	{ (CBP) "Speaker Control", (CBP) "M" },		/* line 3 */
	{ (CBP) "Result Codes", (CBP) "Q" },		/* line 4 */

	{ (CBP) "Dialer Type", (CBP) "T/P" },		/* line 5 */
	{ (CBP) "ResultCode Form", (CBP) "V" },		/* line 6 */
	{ (CBP) "ExtendResultCode", str_x },		/* line 7 */
	{ (CBP) "DialTone Detect", str_x },			/* line 8 */
	{ (CBP) "BusyTone Detect", str_x },			/* line 9 */

	{ (CBP) "LSD Action", (CBP) "&C" },			/* line 10 */
	{ (CBP) "DTR Action", (CBP) "&D" },			/* line 11 */
	{ (CBP) "V22b Guard Tone", (CBP) "&G" },	/* line 12 */
	{ (CBP) "Flow Control", (CBP) "&K" },		/* line 13 */
	{ (CBP) "Error Control Mode   ", (CBP) "\\N" },	// line 14 - used directly

	{ (CBP) "Data Compression", (CBP) "%C" },	/* line 15 */
	{ (CBP) "AutoAnswerRing#", (CBP) "S0" },	/* line 16 */
	{ (CBP) "AT Escape Char", (CBP) "S2" },		/* line 17 */
	{ (CBP) "CarriageReturn Char", (CBP) "S3" },/* line 18 */
	{ (CBP) "Linefeed Char", (CBP) "S4" },		/* line 19 */

	{ (CBP) "Backspace Char", (CBP) "S5" },		/* line 20 */
	{ (CBP) "Blind Dial Pause", (CBP) "S6" },	/* line 21 */
	{ (CBP) "NoAnswer Timeout", (CBP) "S7" },	/* line 22 */
	{ (CBP) "\",\" Pause Time", (CBP) "S8" },	/* line 23 */
	{ (CBP) "No Carrier Disc", (CBP) "S10" },	/* line 24 */

	{ (CBP) "DTMF Dial Speed", (CBP) "S11" },		/* line 25 */
	{ (CBP) "Escape GuardTime", (CBP) "S12" },		/* line 26 */
	{ (CBP) "Data Calling Tone", (CBP) "S35" },		/* line 27 */
	{ (CBP) "Line Rate", (CBP) "S37" }				/* line 28 */
};

/* Print one line of the at_view() stuff using the information
 * in the viewLine[] table.
 * flag, src, and val are passed directly along to
 * s_printf() and the other parameters to s_printf()
 * we obtain directly from viewLine[ G(at_currentViewLine)]
 *
 * This function pads the name with trailing blanks to fill
 * up the 21 characters reserved for this field.
 */
void printViewLine(int flag, const byte *src2, word val)
{
	byte paddedName[30], i;
	struct one_line_str *vl =
		(struct one_line_str *)&viewLine[ G(at_currentViewLine)++];

	x_strcpy(paddedName, vl->optionName);
	for (i = (byte) x_strlen(paddedName); i<21; i++) paddedName[i] = ' ';
	paddedName[i] = '\0';

	s_printf(paddedName, flag, src2, vl->src3, val);
}

extern void printViewLineStr(void);
extern void printViewLineED(byte val);
extern void printViewLineComp(void);

/* print one string line - line number G(at_currentViewLine) with variable
 * string G(at_printCp).
 */
void printViewLineStr()
{
	printViewLine(FLAG_STRING, (CBP) G(at_printCp), 0);
}

/* print an enable or disable line based on val
 * val = TRUE -> enabled
 * val = FALSE -> disabled
 */
void printViewLineED(byte val)
{
	G(at_printCp) = (char *)(val ? str_enable : str_disable);
	printViewLineStr();
}

/* print the data compression(s) enabled based on current
 * compression option.
 */
void printViewLineComp(void)
{
	byte buf[40];

	G(at_printCp) = (char *) str_disable;

	if (G(S).ModemOptions.Compression)
	{
		G(at_printCp) = (char *) buf;
		buf[0] = 0;

#if defined(V44)
		if (G(S).ModemOptions.Compression & V44_COMP)
			x_strcpy(buf, (CBP) "V44 ");
#endif // V44
		if (G(S).ModemOptions.Compression & V42BIS_COMP)
			x_strcat(buf, (CBP) "V42bis ");
		if (G(S).ModemOptions.Compression & MNP_COMP)
			x_strcat(buf, str_MNP5);
	}

	printViewLineStr();
}

/* print one units number line - line number at_currentViewLine with variable
 * integer val and units string src2
 */
void printViewLineUnNum(const char *src2, word val)
{
	printViewLine(FLAG_INT, (CBP) src2, val);
}


/* print one number line - line number at_currentViewLine with variable
 * integer val.
 */
void printViewLineNum(word val)
{
	printViewLineUnNum(NULL, val);
}

/****************************************************************
Routine : at_output_hex()
Description :
	Send CR, LF, then hex word 'w' out to the DTE.
*****************************************************************/
void at_output_hex(word w)
{
	x_send_at_io_crlf();
	s_printf(NULL, FLAG_HEX, NULL, NULL, w);
}

/***************************************************************
Routine : at_putsCrLf()
Description :
	Send to the DTE 4 blanks, the string cp, then CR/LF.
*****************************************************************/
void
at_putsCrLf(const char *cp)
{
	s_printf((const byte *) cp, FLAG_NONE, NULL, NULL, 0);
}

/*  at_init_diagnostics: Initialize diagnostic structure */
void at_init_diagnostics ( void )
{
	byte i, *bp = (byte *) &G(x_status);

	// initialize the whole x_status struct to 0.
	for (i=0; i< sizeof(G(x_status)); i++)
	{
		*bp++ = 0;
	}

#ifdef V8BIS
	G(product_capabilities) = 0 ;
	G(k56_version_octet) = 0 ;
	G(code_version_no) = 0 ;
	G(cl_msg_mu_law) = 0 ;
#endif
}

extern word dp_lin_to_db( void ) ;
static const byte * const sDiag[] =
{
	(CBP) "Last Connection",							/* 0 */
	(CBP) "Initial Transmit Carrier Rate",				/* 1 */
	(CBP) "Initial Receive  Carrier Rate",				/* 2 */
	(CBP) "Final   Transmit Carrier Rate",				/* 3 */
	(CBP) "Final   Receive  Carrier Rate",				/* 4 */
	(CBP) "Protocol Negotiation Result",				/* 5 */
	(CBP) "Data Compression Result",					/* 6 */
	(CBP) "Estimated Noise Level",						/* 7 */
	(CBP) "Receive  Signal Power Level  (-dBm)",		/* 8 */
	(CBP) "Transmit Signal Power Level  (-dBm)",		/* 9 */
	(CBP) "Round Trip Delay             (msec)",		/* 10 */
	(CBP) "Near Echo Level              (-dBm)",		/* 11 */
	(CBP) "Far  Echo Level              (-dBm)",		/* 12 */
	(CBP) "Transmit Frame Count",						/* 13 */
	(CBP) "Transmit Frame Error Count",					/* 14 */
	(CBP) "Receive  Frame Count",						/* 15 */
	(CBP) "Receive  Frame Error Count",					/* 16 */
	(CBP) "Retrain by Local  Modem",					/* 17 */
	(CBP) "Retrain by Remote Modem",					/* 18 */
	(CBP) "Rate Renegotiation by Local Modem",			/* 19 */
	(CBP) "Rate Renegotiation by Remote Modem",			/* 20 */
	(CBP) "Call Termination Cause",						/* 21 */
	(CBP) "Robbed-Bit Signaling",						/* 22 */
	(CBP) "Digital Loss                   (dB)",		/* 23 */
	(CBP) "Remote Server ID",							/* 24 */
	(CBP) "Last PCM S PTR"								/* 25 */
};

// Print one line from the ati11 results.
//
//   First field is sDiag[at_currentViewLine].  This
//   is padded.
//
//   Other fields are sent as is to s_printf
//
// Preconditions:
//		G(at_currentViewLine) is the line number we want to print.
void at_print_sDiag(int flag, const byte *src2,
					const byte *src3, word val)
{
	byte paddedName[70], i;

	x_strcpy(paddedName, sDiag[G(at_currentViewLine)++]);
	for (i = (byte) x_strlen(paddedName); i<36; i++)
		paddedName[i] = ' ';
	paddedName[i] = '\0';

	s_printf(paddedName, flag, src2, src3, val);
}

// Print one integer line from the ati11 results.
// Preconditions:
//		G(at_currentViewLine) is the line number we want to print.
void at_print_int_diag(word val)
{
	at_print_sDiag(FLAG_INT, NULL, NULL, val);
}

// Print string line from the ati11 results.
// Preconditions:
//		G(at_currentViewLine) is the line number we want to print.
void at_print_str_diag(char *str)
{
	at_print_sDiag(FLAG_STRING, (CBP) str, NULL, 0);
}

// Print "NA" (not available) line from the ati11 results.
// Preconditions:
//		G(at_currentViewLine) is the line number we want to print.
void at_print_na_diag()
{
	at_print_str_diag("NA");
}

// print the "press any key to continue..." string
// and take care of associated actions
void at_any_key_to_continue()
{
	byte mess[40];

	G(at_view_more)++ ;
	x_strcpy(mess, (CBP) "Press any key to continue; ESC to quit.");
	x_send_at_io_data(mess);
}

#ifdef MTS_DEBUG
void at_print_cop_debug_buffer(void)
{
	byte j;
	at_putsCrLf(NULL);
	at_putsCrLf("Debug Buffer");
	at_putsCrLf("============");
	for (j=0;j<COP_DEBUG_BUF_SIZE;j++)
	{
		if (G(cop_debug_buf)[j])
			s_printf(NULL,FLAG_HEX,NULL,NULL, G(cop_debug_buf[j]));
		else
			j=COP_DEBUG_BUF_SIZE;
		x_sleep(100);
	}
}
#endif

extern void dp_hex_to_hexascii(char *chBuffPtr, byte bHex );
#if defined(MODEM_Z80)
 #define TMPI	(G(x_scratch)[0])
 #define DEFTMPI
#else
 #define TMPI	(i)
 #define DEFTMPI		byte i;
#endif

extern const word io_line_rate[];

/* Print diagnostic information for ati11.*/
void at_diagnostics ( void )
{
	byte *cp;
	DEFTMPI
#if defined(V8BIS)
	byte *chMsgPtr = &G(x_scratch)[5];
#endif	// (V8BIS)

	at_putsCrLf(NULL);
	at_putsCrLf(NULL);
	at_putsCrLf("Description                         Status");
	at_putsCrLf("---------------                     ------------ ");

	if ( G(x_modem_state) == MS_ON_DIAL )
		dp_update_diagnostics () ;

	switch ( G(at_view_more) )
	{
	case 10 :
	{
		byte buf[25];

		// get current modulation string.
		(void) at_current_mod(buf);
		G(at_printCp) = (char *) buf;
	}
	G(at_currentViewLine) = 0;
	at_print_str_diag(G(at_printCp));		// line 0
	if ( G(x_status).Connection == AT_MOD_FAIL )
	{
		for ( G(at_currentViewLine)=1; G(at_currentViewLine)<10; )
			at_print_na_diag();
	}
	else
	{
		at_print_int_diag(io_line_rate[G(x_status).IniTransmitRate]);// 1
		at_print_int_diag(io_line_rate[G(x_status).IniReceiveRate]);// 2
		at_print_int_diag(io_line_rate[G(x_status).FinalTransmitRate]);//3
		at_print_int_diag(io_line_rate[G(x_status).FinalReceiveRate]);// 4

		switch ( G(x_modem_ec) )
		{
		case EC_V42V44:
		case EC_V42B:
		case EC_V42:
			if (EC_V42V44 == G(x_modem_ec))
				G(at_printCp) = (char *) str_V42V44;
			else if (EC_V42B == G(x_modem_ec))
				G(at_printCp) = (char *) str_V42bis;
			else
				G(at_printCp) = "NONE";

			// Indicate Selective Reject if appropriate
			if (G(lapm_srej_negotiated))
				cp = (byte *) "LAPM/SREJ";
			else
				cp = (byte *) "LAPM";

			break;
		case EC_MNP5:
			G(at_printCp) = (char *) str_MNP5;
			cp = (byte *) "MNP";
			break;
		case EC_MNP4:
		case EC_MNP3:
		case EC_MNP2:
			G(at_printCp) = (char *) "NONE" ;
			cp = (byte *) "MNP";
			break;
		default:
			G(at_printCp) = "NONE" ;
			cp = (byte *) G(at_printCp);			// also 'NONE'
		}
		at_print_str_diag((char *) cp);				// 5
		at_print_str_diag(G(at_printCp));			// 6
		at_print_int_diag(G(x_status).NoiseLevel);	// 7
		if (((G(x_status).Connection == AT_MOD_K56)
#if defined(VPCM_SERVER)
			 || (G(x_status).Connection == AT_MOD_V90)
#endif
			) && !G(V34Mode))
		{
			// V.90 server or k56flex we convert linear to dB
			TMPI = (byte) dp_lin_to_db();
		}
		else
		{
			// for v90 connection, dsp gives us the right receive level
			if (G(x_status).Connection >= AT_MOD_V90)
				TMPI = (byte) (G(x_status).ReceiveLevel>>8);
			else
				TMPI = (byte) (4 + (G(x_status).ReceiveLevel>>8));
		}

		at_print_int_diag((word) TMPI);
		at_print_int_diag(G(x_status).TransmitLevel);
	}
	if (G(x_status).Connection == AT_MOD_FAIL)
		at_print_na_diag();
	else
		at_print_int_diag(G(x_status).RoundTripDelay);
	break ;
	case 11 :
	default :
		if ( (G(x_status).Connection >= AT_MOD_K56) ||
			 (G(x_status).Connection == AT_MOD_FAIL) )
		{
			for ( G(at_currentViewLine)=11; G(at_currentViewLine)<13; )
				at_print_na_diag();
		}
		else
		{
			G(at_currentViewLine) = 11;
			at_print_int_diag((word) (G(x_status).NearEchoLevel>>8));
			at_print_int_diag((word) (G(x_status).FarEchoLevel>>8));
		}
		G(at_currentViewLine) = 13;
		at_print_int_diag(G(x_status).TxFrameCount);
		at_print_int_diag(G(x_status).TxErrorCount);
		at_print_int_diag(G(x_status).RxFrameCount);
		at_print_int_diag(G(x_status).RxErrorCount);
		at_print_int_diag(G(x_status).LocalRetrain);
		at_print_int_diag(G(x_status).RemoteRetrain);
		at_print_int_diag(G(x_status).LocalRR);      //19
		at_print_int_diag(G(x_status).RemoteRR);		  //20
		at_print_int_diag(G(x_status).TerminationCause);

		if (G(x_status).Connection >= AT_MOD_K56)
		{
			at_print_sDiag(FLAG_HEX,NULL,NULL,
						   G(x_status).RobbedBitPattern);
#if defined(VPCM_SERVER)
			if (G(x_status).Connection == AT_MOD_K56)
				at_print_int_diag(G(x_status).DigitalLoss);
			else
				at_print_na_diag();
#else
			// For Client we'll print digital loss for
			// V.90 as well as k56flex.
			at_print_int_diag(G(x_status).DigitalLoss);
#endif
		}
		else
		{
			// For non-PCM connections we don't know
			// digital loss or robbed bit pattern.
			for ( G(at_currentViewLine)=22; G(at_currentViewLine)<24; )
			{
				at_print_na_diag();
			}
		}
			
#if defined(V8BIS)
		if ( ( G(k56_version_octet) != 0x0 )
			 || ( G(product_capabilities) != 0x0 )
			 || ( G(cl_msg_mu_law) != 0x0 )
			 || ( G(code_version_no) != 0x0 ) )
		{
			// use x_scratch[] for temp space.  This
			// lets Z80 compiler use global, which it
			// does much better than stack variables.
			G(x_scratch)[0] = G(product_capabilities);
			G(x_scratch)[1] = G(k56_version_octet);
			G(x_scratch)[2] = G(code_version_no);
			G(x_scratch)[3] = G(cl_msg_mu_law);

			// use x_scratch[4] as for loop control variable.
			// converted characters start at x_scratch[5].
			for (G(x_scratch)[4]=0; G(x_scratch)[4]<4;
				 G(x_scratch)[4]++)
			{
				dp_hex_to_hexascii(
					(char *) chMsgPtr,
					G(x_scratch)[G(x_scratch)[4]]);
				chMsgPtr += 2;
			}

			*chMsgPtr = 0 ;
			at_print_sDiag(FLAG_STRING_NO_SPACES, &G(x_scratch)[5],
						   NULL, 0);
		}
		else
#endif
		{
			at_print_na_diag();
		}

		// Debugging of last valid G(S) ptr in PCM mode.
		at_print_sDiag(FLAG_HEX,NULL,NULL, G(x_status).lastPCMSptr);
		break;
	}
	if ( G(at_view_more) == 11 ) //must be testing for LAST case...
	{
		G(at_view_more)++  ; // will be reset in at_view
		atparse_cmd() ;
		return ;
	}

	at_any_key_to_continue();
}
/* Print a screen full of text for the at&v command output.
 * The G(at_view_more) global should be set to which
 * screen we're currently on.
 */
void at_view( void )
{
	DEFTMPI
	word j;
	const byte *cmdp;
	byte msg[70] ;


	if ( G(at_view_more) >= 10 )
	{
		at_diagnostics () ;
		return ;
	}
	at_putsCrLf(NULL);
	at_putsCrLf(NULL);

	if (G(at_view_more) != 3)
	{
		at_putsCrLf("Option               Selection       AT Cmd");
		at_putsCrLf("---------------      ------------    --------");
	}
	else
	{
		at_putsCrLf("Stored Phone Numbers");
		at_putsCrLf("--------------------");
	}

	switch ( G(at_view_more) ) {
	case 0:
		G(at_currentViewLine) = 0;
			
		/* line 0 */
		G(at_printCp) = G(S).ModemOptions.CommStdSetting ? "Bell" : "CCITT";
		printViewLineStr();
		
		/* line 1 */
		printViewLineED(G(S).ModemOptions.EchoToDTE);

		/* line 2 */
		switch ( G(S).ModemOptions.SpeakerVolume ) {
		case 0:
		case 1:
			G(at_printCp) = "Low";
			break;
		case 3:
			G(at_printCp) = "High";
			break;
		default:
			G(at_printCp) = "Medium";
		}
		printViewLineStr();

		/* line 3 */
		switch ( G(S).ModemOptions.SpeakerControl ) {
		case 0:
			G(at_printCp) = "Off";
			break;
		case 2:
			G(at_printCp) = "On";
			break;
		default:
			G(at_printCp) = "OnUntilCarrier";
		}
		printViewLineStr();

		/* line 4 */
		printViewLineED((byte)(!G(S).ModemOptions.ResultCode));

		/* line 5 */
		G(at_printCp) = G(S).ModemOptions.DialMode ? "Tone" : "Pulse";
		printViewLineStr();

		/* line 6 */
		G(at_printCp) = G(S).ModemOptions.ResultCodeFormat ? "Text" : "Number";
		printViewLineStr();

		/* line 7 */
		printViewLineED(G(S).ModemOptions.ExtResultCode);

		/* line 8 */
		printViewLineED(G(S).ModemOptions.DialToneDetect);

		/* line 9 */
		printViewLineED(G(S).ModemOptions.BusyToneDetect);

		/* line 10 */
		G(at_printCp) = (char*)(G(S).ModemOptions.CDControl
					? (char *)str_stdrs232
					: "Always On");
		printViewLineStr();

		/* line 11 */
		if ( G(S).ModemOptions.DTRControl == 1 )
			G(at_printCp) = "Command Mode";
		else if ( G(S).ModemOptions.DTRControl == 2 )
			G(at_printCp) = (char *)str_stdrs232;
		else if ( G(S).ModemOptions.DTRControl == 3 )
			G(at_printCp) = "Off=Reset" ;
		else
			G(at_printCp) = "Ignore";
		printViewLineStr();
		break ;
	case 1:	/* line 12 */
		if ( G(S).ModemOptions.GuardTone == 1 )
			G(at_printCp) = "550 Hz";
		else if ( G(S).ModemOptions.GuardTone == 2 )
			G(at_printCp) = "1800 Hz";
		else
			G(at_printCp) = (char *)str_disable;
		printViewLineStr();

		/* line 13 */
		if ( G(S).ModemOptions.FlowControl == SW_FLOWCTRL )
			G(at_printCp) = "Software";
		else if ( G(S).ModemOptions.FlowControl == HW_FLOWCTRL )
			G(at_printCp) = "Hardware";
		else
			G(at_printCp) = (char *)str_disable;
		printViewLineStr();

		/* line 14 */
		cmdp = viewLine[14].src3;
		switch ( G(S).ModemOptions.V42 ) {
		case V42_BUFFER_MODE:
			G(at_printCp) = "BufferMode";
			break;
		case V42_MNP_DISC:
			G(at_printCp) = "MNP or Disc.";
			break;
		case V42_LAPM_ONLY:
			G(at_printCp) = "V42 or Disc.";
			break;
        case V42_LAPM_MNP_DISC:
            G(at_printCp) = "V42,MNP";
			break;
		case V42_SYNC_BUFFERED:
			G(at_printCp) = "SyncBuffered";
			cmdp = (CBP) "+ES";
			break;
		default:
			G(at_printCp) = "V42,MNP,Buffer";
		}
		s_printf(viewLine[14].optionName, FLAG_STRING,
				 (CBP) G(at_printCp), cmdp, 0);

		G(at_currentViewLine) = 15;

		/* line 15 */
        printViewLineComp();

		/* line 16 */
		printViewLineNum(G(S).ModemOptions.AutoAnswer);

		/* line 17 */
		printViewLineNum(G(S).ModemOptions.EscapeChar);

		/* line 18 */
		printViewLineNum(G(S).ModemOptions.CRChar);

		/* line 19 */
		printViewLineNum(G(S).ModemOptions.LFChar);

		/* line 20 */
		printViewLineNum(G(S).ModemOptions.BSChar);

		/* line 21 */
		printViewLineUnNum((const char *) str_sec, G(S).ModemOptions.BlindDialPause);

		/* line 22 */
		printViewLineUnNum((const char *) str_sec, G(S).ModemOptions.NoAnsTimeOut);

		/* line 23 */
		printViewLineUnNum((const char *) str_sec, G(S).ModemOptions.DialPauseTime);
		break ;
	case 2:	/* line 24 */
		G(at_currentViewLine) = 24;
		printViewLineUnNum((const char *) str_msec,(word) (G(S).ModemOptions.NoCarrierDisc*100));

		/* line 25 */
		printViewLineUnNum((const char *) str_msec, G(S).ModemOptions.DtmfDialSpeed);

		/* line 26 */
		printViewLineUnNum((const char *) str_msec,(word)(G(S).ModemOptions.EscapeGuardTime*20));


		/* line 27 */
		printViewLineED(G(S).ModemOptions.DataCallingTone);

		/* line 28 */
		// use x_scratch for temporary storage
		G(at_printCp) = (char *) &G(x_scratch)[0];
		if ( !G(S).ModemOptions.bV34Enable && !G(S).ModemOptions.DialLineRate)
		{
			(void)at_itoa((word)at_dialLineRates[13],
						  G(x_scratch), DECIMAL);
		}
		else
		{
			(void)at_itoa(
				(word)at_dialLineRates[G(S).ModemOptions.DialLineRate],
				G(x_scratch),
				DECIMAL);
            
            // at_dialLineRates [] is an array of word, so we directly copy
            // the string "1200/75"
        	if (G(S).ModemOptions.DialLineRate == 2)
            	  x_strcpy(G(x_scratch), (CBP) "1200/75");
		}    	  
					   
		switch ( G(S).ModemOptions.DialLineRate ) {
		case 3:
		case 5:
			if (G(S).ModemOptions.CommStdSetting == 0)
				x_strcat(G(x_scratch), (CBP) "(V22)");
			else
				x_strcat(G(x_scratch), (CBP) "(Bell)");
			break;
		}
		printViewLineStr();
		break ;

	case 3:	/* Stored phone numbers */

		for (TMPI=0; TMPI<MAX_PHONE_NUMBERS; TMPI++)
		{
			j=0;
			while (j < 10) msg[j++]=' ';
			while (j < MAX_PHONE_LENGTH+14) msg[j++]=0;
			msg[5] = '&';
			msg[6] = 'Z';
			msg[7] = (byte) (TMPI + '0');
			msg[8] = '=';

			// Check to see that we do have numbers stored
			load_number ( TMPI, msg + 10 ) ;
			msg[x_strlen(msg)] = 0 ;
			x_send_at_io_data(msg);
			x_send_at_io_crlf();
		}
		break ;

	default:
		break ;

	} //end switch

	if ( G(at_view_more) == 3 ) //must be testing for LAST case...
	{
		G(at_view_more) = 0 ; //reset...
		atparse_cmd() ;
		return ;
	}

	at_any_key_to_continue();
}

/****************************************************************/
void at_and_v(void)
{
	switch(*G(at_cmd_ptr))
	{
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			at_cmd_err_ret ();
			return;
		case '0':
			G(at_cmd_ptr)++ ;
		default:
			G(at_view_more) = 0 ;
			at_view () ;
			break;
	}
}

/***************************************************************
Routine : at_and_and routines
Description :
	These are for the "at&&" testing and debugging commands.
*****************************************************************/

// Convert a nibble between 0 & 15 to an ASCII hex character
// 0 -> 0x30 ('0')
byte decdigit_to_hexchar(byte nibble)
{
	if ( nibble <= 15 )
		return str_convert[nibble];
	return 0;
}

// Convert ascii hex strings to decimal integer values.
// String 'str' must be zero-terminated.
//
// Returns FALSE if the string contains any non-hex
// characters, otherwise TRUE.
byte at_atohex(byte str[], word *num)
{
	byte l = (byte) at_atoi(str, num, HEX);

	if (str[l])
		return FALSE;

	return TRUE;
}

#ifdef FLASH_LOADER
//***************************************************************************
void at_and_and_f()
{
	byte string[5], str[20], len;
	word reg_word ;
	byte *addr_pointer;
	int num_bytes, i;
	word addr_offset;
	byte record_type;
	byte chk_sum;

	// check if null - to start the flash loader code
	if ( *G(at_cmd_ptr) == 0 )
	{
		atparse_cmd() ;
		return ;
	}

	if ( *G(at_cmd_ptr) != ':' )
#if !defined( ROM_FLASH ) || defined( ATMEL_NOBOOT )
	{
		at_cmd_err_ret ();
		return;
	}
#else
	{
		//-----------------------------------------------------
		// This section supports additional at&&f commands
		// for the FLASH Loader.
		//-----------------------------------------------------
		// at&&ffl
		if ( (*G(at_cmd_ptr) == 'F') && (*(G(at_cmd_ptr)+1) == 'L') )
		{
			extern word fl_chksum ;

			//-------------------------------------------------
			// Got a query - is there a ROM Resident Flash
			// Loader present ?  Reply with "OK".
			//-------------------------------------------------
			x_debug_msg( "Got at&&ffl command\r\n" ) ;

			//-------------------------------------------------
			// report RRFL chksum & 1st sector size
			//-------------------------------------------------
			G(at_result_code) = OK;
			len = (byte)at_itoa( fl_chksum, str, HEX ) ;
			while ( len < 4 )
			{
				str[3] = str[2]; str[2] = str[1];
				str[1] = str[0]; str[0] = '0' ;
				len++ ;
			}
#if ROM_FLASH == 16
			x_strcpy( &str[4], ",10,\n\n\rOK\r\n" ) ;
#endif
#if ROM_FLASH == 64
			x_strcpy( &str[4], ",40,\n\n\rOK\r\n" ) ;
#endif
			at_output_msg( str, x_strlen( str ) ) ;
			return ;
		}

		//-----------------------------------------------------
		// Address 300 hex contains a jump table to entry
		// points in the FLASH Loader.
		//-----------------------------------------------------
		// at&&fgo
		if ( (*G(at_cmd_ptr) == 'G') && (*(G(at_cmd_ptr)+1) == 'O') )
		{
			x_debug_msg( "Got at&&fgo command\r\n" ) ;
			//-------------------------------------------------
			// Got a request to fall back into the FLASH LOADER
			// program.
			//-------------------------------------------------
			z80_jump_abs( *((word *)0x50), 0x00 ) ;
		}

		// at&&fcd
		if ( (*G(at_cmd_ptr) == 'C') && (*(G(at_cmd_ptr)+1) == 'D') )
		{
			x_debug_msg( "Got at&&fcd command\r\n" ) ;
			//-------------------------------------------------
			// Got a request to fall back into the FLASH LOADER
			// command dispatcher.
			//-------------------------------------------------
			z80_jump_abs( *((word *)0x52), 0x00 ) ;
		}
#ifdef RAW_FLASHER
		//-----------------------------------------------------
		// New command to support simple data download
		// to the FLASH Loader.
		//-----------------------------------------------------
		// at&&fraw
		if ((*G(at_cmd_ptr)=='R') &&
			(*(G(at_cmd_ptr)+1)=='A') &&
			(*(G(at_cmd_ptr)+2)=='W'))
		{
			x_debug_msg( "Got at&&fraw command\r\n" ) ;
			G(S).ModemOptions.FlowControl = HW_FLOWCTRL ;
			x_strcpy( str, "START DOWNLOAD AFTER <OK> IS DISPLAYED!\r\n" ) ;
			z80_jump_abs( *((word *)0x54), 0x00 ) ; //call raw_prog
		}
#endif // RAW_FLASHER
		at_cmd_err_ret ();
		return;
	}
#endif
	G(at_cmd_ptr)++ ;
	chk_sum = 0;

	//	Get the number of bytes First
	string[0] = *G(at_cmd_ptr)++ ;
	string[1] = *G(at_cmd_ptr)++ ;
	string[2] = '\0' ;

	if ( at_atohex(string, &reg_word) == FALSE )
	{
		at_cmd_err_ret ();
		return;
	}

	num_bytes = (int) reg_word;

	chk_sum += (byte) reg_word;
	
	addr_pointer = (byte *) 0xCC00;
	
	//	Get the address offset Higher byte
	string[0] = *G(at_cmd_ptr)++ ;
	string[1] = *G(at_cmd_ptr)++ ;
	string[2] = '\0' ;

	if ( at_atohex(string, &reg_word) == FALSE )
	{
		at_cmd_err_ret ();
		return;
	}
	
	addr_offset = reg_word;
	chk_sum += (byte) reg_word;

	//	Get the address offset Lower byte
	string[0] = *G(at_cmd_ptr)++ ;
	string[1] = *G(at_cmd_ptr)++ ;
	string[2] = '\0' ;

	if ( at_atohex(string, &reg_word) == FALSE )
	{
		at_cmd_err_ret ();
		return;
	}

	chk_sum += (byte) reg_word;

	addr_offset = (addr_offset * 256 ) + reg_word - 0xCC00;
	
	//	Get the record type
	string[0] = *G(at_cmd_ptr)++ ;
	string[1] = *G(at_cmd_ptr)++ ;
	string[2] = '\0' ;

	if ( at_atohex(string, &reg_word) == FALSE )
	{
		at_cmd_err_ret ();
		return;
	}

	chk_sum += (byte) reg_word;

	record_type = (byte) reg_word;

	switch (record_type)
	{

	case 0:
		for (i=0; i<num_bytes; i++)
		{
			//		Get the next byte
			string[0] = *G(at_cmd_ptr)++ ;
			string[1] = *G(at_cmd_ptr)++ ;
			string[2] = '\0' ;

			if ( at_atohex(string, &reg_word) == FALSE )
			{
				at_cmd_err_ret ();
				return;
			}

			chk_sum += (byte) reg_word;

			addr_pointer[addr_offset++] = (byte) reg_word;
		}

		break;
	//	Accept these records but do nothing
	case 1:
		if ((addr_offset + 0xCC00) == 0)
		{
			// We are at the end of the file, and we got the last record
			while ( *G(at_cmd_ptr) != 0 ) G(at_cmd_ptr)++ ;	// Clean the input Queu

				//	Start The downloader Execution
#if defined(THUNDER)
			//	Run time decision
			if ( z80_modem_type == EXT_INTERFACE )
			{
				z80_jump_abs( 0xCC00, 0x82 ) ;		// EASCI
			}
			else if (z80_modem_type == USB_INTERFACE)
			{
				if( DEV_CONFIG() == MCCI_CONFIG )
				{
					z80_jump_abs( 0xCC00, 0x83 ) ;	// MCCI_USB
				}
				else // if( DEV_CONFIG() == CDC_CONFIG )
				{
					z80_jump_abs( 0xCC00, 0x84 ) ;	// CDC_USB
				}
			}
			else
			{
				// illegal modem type
				at_cmd_err_ret ();
				return;
			}
#elif defined( EXT_MODEM )
			z80_jump_abs( 0xCC00, 0x82 ) ;			// EASCI
#elif defined( USB_MODEM )
			if( DEV_CONFIG() == MCCI_CONFIG )
			{
				z80_jump_abs( 0xCC00, 0x83 ) ;		// MCCI_USB
			}
			else // if( DEV_CONFIG() == CDC_CONFIG )
			{
				z80_jump_abs( 0xCC00, 0x84 ) ;		// CDC_USB
			}
#else
			z80_jump_abs( 0xCC00, 0x80 ) ;			// MIMIC
#endif	// THUNDER
		}
		break;
	default:
		at_output_msg ( "Record != 0 found", 18 ) ;
		return;
	}

	//	Get the Checksum Byte Now
	string[0] = *G(at_cmd_ptr)++ ;
	string[1] = *G(at_cmd_ptr)++ ;
	string[2] = '\0' ;

	if ( at_atohex(string, &reg_word) == FALSE )
	{
		at_cmd_err_ret ();
		return;
	}

	chk_sum += (byte) reg_word;

	if (chk_sum != (byte) 0)
	{
		at_output_msg ( "CHECKSUM ERROR", 18 ) ;
		return;
	}

	while ( *G(at_cmd_ptr) != 0 ) G(at_cmd_ptr)++ ;

	atparse_cmd() ;
}
#endif

#ifdef TEST_COMMANDS
/****************************************************************
Routine : at_and_and_rc() - handle &&R and &&C commands
Description :
	&&R - read/write DSP RAM
	&&C - read/write CAMIL register
*****************************************************************/
void at_and_and_rc(byte ram)
{
	byte i;
	dsp_ram dsp_ramreg ;

	// read DSP RAM location from AT command line (first parameter)
	if (0 == (i = (byte) at_atoi(G(at_cmd_ptr), &dsp_ramreg.loc, HEX)))
	{
		at_cmd_err_ret ();
		return;
	}
	G(at_cmd_ptr) += i;

	if ( *G(at_cmd_ptr) == ',' )
	{
		// read DSP RAM/reg value from AT command line (second parameter)
		G(at_cmd_ptr)++ ;

		if (0 == (i = (byte) at_atoi(G(at_cmd_ptr), &dsp_ramreg.val, HEX)))
		{
			at_cmd_err_ret ();
			return;
		}
		G(at_cmd_ptr) += i;

		// Ask dp to write DSP RAM/reg
		x_send_mail(ram ? DSP_WRITE_RAM : DP_WRITE_REG, DP_TASK,
					(byte *)&dsp_ramreg, sizeof(dsp_ram));
	}
	else
	{
		// Ask dp to read DSP RAM/reg
		x_send_mail(ram ? DSP_READ_RAM : DP_READ_REG, DP_TASK,
							(byte *)&dsp_ramreg, sizeof(dsp_ram));

		// DISPLAY RESULT
		at_output_hex(dsp_ramreg.val);
	}
	atparse_cmd() ;
}

#if defined(MODEM_Z80) && defined(Z80_DEBUG_PRINT)
//***************************************************************************
//this function reads from/writes to z80 memory (byte)
void at_and_and_v()
{
	byte string[5] ;
	dsp_ram	test_data;	// location/value data
	byte *bptr;

	string[0] = *G(at_cmd_ptr)++ ;
	string[1] = *G(at_cmd_ptr)++ ;
	string[2] = *G(at_cmd_ptr)++ ;
	string[3] = *G(at_cmd_ptr)++ ;
	string[4] = '\0' ;
	if( at_atohex(string, &test_data.loc) == FALSE )	// get addr from 1st 4 chars
	{
		at_cmd_err_ret ();
		return;
	}
	bptr = (byte *)test_data.loc;	// save pointer as byte pointer

	if( *G(at_cmd_ptr) == ',' )	// if comma, get value
	{
		G(at_cmd_ptr)++ ;
		string[0] = *G(at_cmd_ptr)++ ;
		string[1] = *G(at_cmd_ptr)++ ;
		string[2] = *G(at_cmd_ptr)++ ;
		string[3] = *G(at_cmd_ptr)++ ;
		string[4] = '\0' ;
		if( at_atohex(string, &test_data.val) == FALSE )
		{
			at_cmd_err_ret ();
			return;
		}
		else	// write value to memory
		{
			*bptr = (byte)test_data.val;
		}
	}
	else
	{
		// Read Z80 memory.
		test_data.val =(word)*bptr;

		at_output_hex(test_data.val);
	}
	atparse_cmd() ;
} // at_and_and_v()
#endif // MODEM_Z80 && Z80_DEBUG_PRINT
#endif  // TEST_COMMANDS

#ifdef VOICE
//***************************************************************************
//line to line loopback
void at_and_and_l()
{
	x_send_mail ( VOICE_LINE_LOOPBACK, DP_TASK, NULL, 0 ) ;
	atparse_cmd() ;

}

//***************************************************************************
//speaker codec loopback
void at_and_and_s()
{
	x_send_mail ( VOICE_NEAR_LOOPBACK, DP_TASK, NULL, 0 ) ;
	atparse_cmd() ;
}
#endif  // VOICE

//***************************************************************************
void at_and_and_n(void)
{
	if ( *G(at_cmd_ptr) == '?' )
	{
		G(at_cmd_ptr)++ ;
		at_output_hex((word) (0x100 | G(S).ModemOptions.CountryId));
	}
	atparse_cmd() ;
}
//***************************************************************************
void at_and_and (void)
{
	switch(*G(at_cmd_ptr)++)
	{
#ifdef FLASH_LOADER
		case 'F':
			at_and_and_f(); break;
#endif
#ifdef TEST_COMMANDS
		case 'C':
			at_and_and_rc(0); break;
		case 'R':
			at_and_and_rc(1); break;
#if defined(MODEM_Z80) && defined(Z80_DEBUG_PRINT)
		case 'V':
			at_and_and_v(); break;
#endif // MODEM_Z80 && Z80_DEBUG_PRINT
#endif // TEST_COMMANDS
#ifdef VOICE
		case 'L':
			at_and_and_l(); break;
		case 'S':
			at_and_and_s(); break;
#endif
		case 'N':
			at_and_and_n(); break;
		default:
			at_cmd_err_ret();
			break;
	}
}

#ifdef SYNCH_MODE
	extern byte* at_draco_valv_test(byte*);
	extern byte* at_draco_apollo_test(byte*);
	extern byte* at_synch_timing(byte*);
	extern byte* at_synch_baud(byte*);
#endif
/****************************************************************
Routine : at_percent_t	=>	AT%T0, AT%T1, etc.
Description :
	All test commands for homologation.
	Update the document for each command we add.
*****************************************************************/
void at_percent_t(void)
{
	word test_num ;
	byte i;
	dsp_ram  test_data ;

	/* val is used for passing data as well as for receiving response */
	/* val initialized to 0xffff asuming that a valid resonse will not */
	/* match this value */

	test_data.val = 0xffff ;

#ifdef SYNCH_MODE
	if ( *G(at_cmd_ptr) == 'T' )
	{
		G(at_cmd_ptr)++;
		G(at_cmd_ptr) = at_synch_timing(G(at_cmd_ptr));
		atparse_cmd () ;
		return;
	}
	if ( *G(at_cmd_ptr) == 'B' )
	{
		G(at_cmd_ptr)++;
		G(at_cmd_ptr) = at_synch_baud(G(at_cmd_ptr));
		atparse_cmd () ;
		return;
	}
#endif

	// Read test number
	G(at_cmd_ptr) += at_atoi(G(at_cmd_ptr), &test_num, DECIMAL);

	if ( *G(at_cmd_ptr) == ',' )
	{
		G(at_cmd_ptr)++ ;
		if (0 == (i = (byte) at_atoi(G(at_cmd_ptr), &test_data.loc, HEX)))
		{
			at_cmd_err_ret ();
			return;
		}
		G(at_cmd_ptr) += i;
	}
	if ( *G(at_cmd_ptr) == ',' )
	{
		G(at_cmd_ptr)++ ;
		if (0 == (i = (byte) at_atoi(G(at_cmd_ptr), &test_data.val, HEX)))
		{
			at_cmd_err_ret ();
			return;
		}
		G(at_cmd_ptr) += i;
	}

	// Do the test - dptest.c
	x_send_mail(DP_TEST_CMD, DP_TASK, (byte *) &test_data, test_num);

	if ( test_data.val != 0xffff )
	{
		at_output_hex(test_data.val);
	}
	atparse_cmd () ;
}

#if defined(PNPSTRING) && !defined(ROM)

byte PnPstring[ 50 ] ; // defined global for debug (and speed of execution)

void at_none ( void )
{
	x_strcpy(PnPstring, "None" ) ;
	PnPstring[4] = 0 ;
	at_output_msg ( PnPstring, 4 ) ;
}

/****************************************************************
Routine : at_percent_p	=>	AT%P0, AT%P1, etc.
Description :
	All PnP commands for reading/writing PnP fields from/to EEPROM
*****************************************************************/
void at_percent_p ( void )
{
	word cmd_num, loc ;
	byte bitmap, data ;
	byte i, j ;
	byte *bp;
	char hex_char ;

	//===================================================================
	// get the command, currently support 0-4 as follows:
	//	0) EISA Mfr ID - a 3 char string. This is a required field;
	//	1) Product ID - a 4 digit (hex) number. This is a required field;
	//		all other fields are optional:
	//	2) Serial Number - an 8 digit number uniquely identifying
	//		a modem.
	//	3) Compat. Device IDs - a comma seperated list of up to
	//		5 7-character strings identifying compatible devices, and
	//	4) Name - up to 40 character string with anything the
	//		manufacturer wishes to place in here.
	//	5) Erase PnP
	//===================================================================
	G(at_cmd_ptr) += at_atoi ( G(at_cmd_ptr), &cmd_num, DECIMAL ) ;

	// assume no input parameter, we read the eeprom value
	i = 0 ;

	// read current contents of PnP storage
	bitmap = read_eeprom ( PNP_BITMAP ) ;

	// get the input parameter, if one is present
	// if not then test checksum
	if ( *G(at_cmd_ptr) == ',' )
	{
		G(at_cmd_ptr)++ ;
		for ( bp=PnPstring; i<50 && *G(at_cmd_ptr) != 0; i++ )
		{
			*bp++ = *G(at_cmd_ptr)++ ;
		}
		*bp = 0 ;
	}
	else
	{
		if ( bitmap )
		{
			// PnP parameters are present, check validity
			if ( z80_PnP_chksum() != read_eeprom ( PNP_CHKSUM ) )
			{
				bitmap = 0 ;
				write_eeprom ( PNP_BITMAP, 0 ) ;
			}
	
			i = 0 ;
		}
	}

	// execute cmd
	switch ( cmd_num )
	{
	case 5:		// Erase PnP
		bitmap = 0 ;
		write_eeprom ( PNP_BITMAP, 0 ) ;
		break ;

	case 0:		// EISA MFR ID
		bp=PnPstring ;
		if ( !i )
		{
			// read EISA Mfr ID (if one present)
			if ( bitmap & PNP_EISA_BIT )
			{
				*bp = read_eeprom ( PNP_EISA_ID ) ;
				*(bp+1) = read_eeprom ( PNP_EISA_ID+1 ) ;
				*(bp+2) = read_eeprom ( PNP_EISA_ID+2 ) ;
				*(bp+3) = 0 ;
				at_output_msg ( bp, 4 ) ;
			}
			else
			{
				at_none() ;
			}
		}
		// EISA Mfr ID parameter present, write it
		else if ( i != 3 )
		{
			goto atp_err_xit ;
		}
		else
		{
			// write the parameter to EEPROM
			write_eeprom ( PNP_EISA_ID, *bp ) ;
			write_eeprom ( PNP_EISA_ID+1, *(bp+1) ) ;
			write_eeprom ( PNP_EISA_ID+2, *(bp+2) ) ;
			bitmap |= PNP_EISA_BIT ;
		}
		break ;

	case 1:		// PRODUCT ID
		bp=PnPstring ;
		if ( !i )
		{
			// read Product ID (if one present)
			if ( bitmap & PNP_PROD_BIT )
			{
				data = read_eeprom ( PNP_PROD_ID ) ;
				*(bp) = str_convert[ (byte)((data>>4) & 0xf) ];
				*(bp+1) = str_convert[ (byte)(data & 0xf) ];
				data = read_eeprom ( PNP_PROD_ID+1 ) ;
				*(bp+2) = str_convert[ (byte)((data>>4) & 0xf) ];
				*(bp+3) = str_convert[ (byte)(data & 0xf) ];
				at_output_msg ( bp, 4 ) ;
			}
			else
			{
				at_none() ;
			}
		}
		// Product ID parameter present, write it
		else if ( i != 4 )
		{
			goto atp_err_xit ;
		}
		else
		{
			// write the parameter to EEPROM
			loc = PNP_PROD_ID ;
			data = 0 ;
			for ( i=0; i<4 ; i++ )
			{
				hex_char = *bp++ ;
				if ( (hex_char >= '0') && (hex_char <= '9') )
				{
					data |= hex_char & 0x0f ;
				}
				else if (	((hex_char >= 'A') && (hex_char <= 'F'))
						 || ((hex_char >= 'a') && (hex_char <= 'f')) )
				{
					data |= ((hex_char & 0x0f) + 9) ;
				}
				if ( i & 1 )
				{
					write_eeprom ( loc++, data ) ;
					data = 0 ;
				}
				else
				{
					data <<= 4 ;
				}
			}
			bitmap |= PNP_PROD_BIT ;
		}
		break ;

	case 2:		// SERIAL NUMBER
		loc = PNP_SERIAL_NO ;
		if ( !i )
		{
			// read compressed ascii serial # (if one present)
			if ( bitmap & PNP_SERNO_BIT )
			{
				PnPstring[8] = 0 ;
				bp = PnPstring ;
				for ( i=0; i<4; i++ )
				{
					data  = read_eeprom ( loc++ ) ;
					*bp++ = str_convert[ (byte)((data>>4) & 0xf) ];
					*bp++ = str_convert[ (byte)(data & 0xf) ];
				}
				at_output_msg ( PnPstring, 8 ) ;
			}
			else
			{
				at_none() ;
			}
		}
		else if ( i != 8 )
		{
			goto atp_err_xit ;
		}
		else
		{
			// write the compressed ascii serial # to EEPROM
			write_eeprom ( PNP_BITMAP, bitmap & ~PNP_SERNO_BIT ) ;
			data = 0 ;
			bp = PnPstring ;
			for ( i=0; i<8; i++ )
			{
				hex_char = *bp++ ;
				if ( (hex_char >= '0') && (hex_char <= '9') )
				{
					data |= hex_char & 0x0f ;
				}
				else if ( ((hex_char >= 'A') && (hex_char <= 'F')) ||
							((hex_char >= 'a') && (hex_char <= 'f')) )
				{
					data |= ((hex_char & 0x0f) + 9) ;
				}
				else
				{
					goto atp_err_xit ;
				}
				if ( i & 1 )
				{
					write_eeprom ( loc++, data ) ;
					data = 0 ;
				}
				else
				{
					data <<= 4 ;
				}
			}
			bitmap |= PNP_SERNO_BIT ;
		}
		break ;

	case 3:		// Compatible Device IDs
		loc = PNP_DEVICE_ID ;
		bp = PnPstring ;
		if ( !i )
		{
			// read Device IDs (if present)
			if ( bitmap & PNP_DEVID_BIT )
			{
				for ( i=0; i<40; i++ )
				{
					*bp = read_eeprom ( loc++ ) ;
					if ( *bp++ == 0 )
					{
						at_output_msg ( PnPstring, i+1 ) ;
						break ;
					}
				}
			}
			else
			{
				at_none() ;
			}
		}
		else if ( i > 40 )
		{
			goto atp_err_xit ;
		}
		else
		{
			// write the Device IDs to EEPROM
			// (up to 5 comma seperated 7 char strings)
			write_eeprom ( PNP_BITMAP, bitmap & ~PNP_DEVID_BIT ) ;
			for ( i=0; i<5; i++ )
			{
				for ( j=0; j<7; j++ )
				{
					if ( *bp )
					{
						write_eeprom ( loc++, *bp++ ) ;
					}
					else
					{
						goto atp_err_xit ;
					}
				}
				write_eeprom ( loc++, *bp ) ;
				if ( *bp == 0 )
				{
					break ;
				}
				else if ( *bp++ != ',' )
				{
					goto atp_err_xit ;
				}
			}
			bitmap |= PNP_DEVID_BIT ;
		}
		break ;

	case 4:		// User Name
		loc = PNP_USER_NAME ;
		bp = PnPstring ;
		if ( !i )
		{
			// read User Name (if present)
			if ( bitmap & PNP_USER_BIT )
			{
				for ( i=0; i<40; i++ )
				{
					*bp = read_eeprom ( loc++ ) ;
					if ( *bp++ == 0 )
					{
						// we're done
						at_output_msg ( PnPstring, i+1 ) ;
						break ;
					}
				}
			}
			else
			{
				at_none() ;
			}
			break ;
		}
		else if ( i > 40 )
		{
			goto atp_err_xit ;
		}
		else
		{
			// write the User Name to EEPROM
			write_eeprom ( PNP_BITMAP, bitmap & ~PNP_USER_BIT ) ;
			for ( i=0; i<40; i++ )
			{
				write_eeprom ( loc++, *bp ) ;
				if ( *bp++ == 0 )
				{
					break ;
				}
			}
			bitmap |= PNP_USER_BIT ;
		}
		break ;
	default:
	atp_err_xit:
		at_cmd_err_ret();
		return; 
	}

	// finally calculate new chksum
	if ( i )
	{
		write_eeprom ( PNP_BITMAP, bitmap ) ;
		write_eeprom ( PNP_CHKSUM, z80_PnP_chksum () ) ;
	}

	// Ignore any characters following at%p command
	G(at_result_code) = OK;
	at_output_msg(NULL, 0);
}

#elif defined(PCMCIA_MODEM)

byte CISstring[ 50 ] ; // defined global for debug (and speed of execution)

void at_none ( void )
{
	x_strcpy(CISstring, "None" ) ;
	CISstring[4] = 0 ;
	at_output_msg ( CISstring, 4 ) ;
}

// PCMCIA Serial EEPROM definitions
#define CIS_TPLMID_MANF_BIT		(1<<0)
#define CIS_TPLMID_CARD_BIT		(1<<1)
#define CIS_TPLLV1_INFO_BIT		(1<<2)

#define CIS_START_LOC			(0)
#define CIS_BITMAP				(CIS_START_LOC)
#define CIS_TPLMID_MANF_CODE	(CIS_BITMAP + 1)
#define CIS_TPLMID_CARD_CODE	(CIS_TPLMID_MANF_CODE +2 )
#define CIS_TPLLV1_INFO_SIZE	(CIS_TPLMID_CARD_CODE +2 )
#define CIS_TPLLV1_INFO_DATA	(CIS_TPLLV1_INFO_SIZE +1 )
#define CIS_CHKSUM				(CIS_TPLLV1_INFO_DATA +134 )

/****************************************************************
Routine : at_percent_p	=>	AT%P0, AT%P1, etc.
Description :
	All CIS commands for reading/writing CIS fields from/to EEPROM
*****************************************************************/
void at_percent_p ( void )
{
	word cmd_num, loc ;
	byte bitmap, data ;
	byte i, j ;
	byte *bp;
	char hex_char ;
	extern byte z80_CIS_eeprom( void ) ;
	extern byte z80_CIS_chksum( void ) ;

	//===================================================================
	// get the command, currently support 0-3 as follows:
	//	0) TPLMID_MANF - a 2 digit (hex) number.
	//	1) TPLMID_CARD - a 2 digit (hex) number.
	//	2) Name - up to 40 character string for testing only.
	//	3) Erase CIS
	//===================================================================
	G(at_cmd_ptr) += at_atoi ( G(at_cmd_ptr), &cmd_num, DECIMAL ) ;

	// assume no input parameter, we read the eeprom value
	i = 0 ;

	// read current contents of CIS storage
	bitmap = z80_CIS_eeprom() ;

	// get the input parameter, if one is present
	// if not then test checksum
	if ( *G(at_cmd_ptr) == ',' )
	{
		G(at_cmd_ptr)++ ;
		for ( bp=CISstring; i<50 && *G(at_cmd_ptr) != 0; i++ )
		{
			*bp++ = *G(at_cmd_ptr)++ ;
		}
		*bp = 0 ;
	}
	else if ( !bitmap )
	{
		i = 0 ;
	}

	// execute cmd
	bp = CISstring ;
	switch ( cmd_num )
	{
	case 0:		// TPLMID_MANF - a one word (4 hex digit) number.
		if ( !i )
		{
			// read TPLMID_MANF param (if one present)
			if ( bitmap & CIS_TPLMID_MANF_BIT )
			{
				data = read_eeprom ( CIS_TPLMID_MANF_CODE+1 ) ;
				*(bp) = str_convert[ (byte)((data>>4) & 0xf) ];
				*(bp+1) = str_convert[ (byte)(data & 0xf) ];
				data = read_eeprom ( CIS_TPLMID_MANF_CODE ) ;
				*(bp+2) = str_convert[ (byte)((data>>4) & 0xf) ];
				*(bp+3) = str_convert[ (byte)(data & 0xf) ];
				at_output_msg ( bp, 4 ) ;
			}
			else
			{
				at_none() ;
			}
		}
		else if ( i != 4 )
		{
			// Error in input, bail out
			goto atp_err_xit ;
		}
		else
		{
			// write the TPLMID_MANF parameter to EEPROM
			// in litle endian format (lsb first)
			loc = CIS_TPLMID_MANF_CODE+1 ;
			data = 0 ;
			for ( i=0; i<4 ; i++ )
			{
				hex_char = *bp++ ;
				if ( (hex_char >= '0') && (hex_char <= '9') )
				{
					data |= hex_char & 0x0f ;
				}
				else if (	((hex_char >= 'A') && (hex_char <= 'F'))
						 || ((hex_char >= 'a') && (hex_char <= 'f')) )
				{
					data |= ((hex_char & 0x0f) + 9) ;
				}
				if ( i & 1 )
				{
					write_eeprom ( loc--, data ) ;
					data = 0 ;
				}
				else
				{
					data <<= 4 ;
				}
			}
			bitmap |= CIS_TPLMID_MANF_BIT ;
		}
		break ;

	case 1:		// TPLMID_CARD - a one word (4 hex digit) number.
		if ( !i )
		{
			// read TPLMID_CARD param (if one present)
			if ( bitmap & CIS_TPLMID_CARD_BIT )
			{
				data = read_eeprom ( CIS_TPLMID_CARD_CODE+1 ) ;
				*(bp) = str_convert[ (byte)((data>>4) & 0xf) ];
				*(bp+1) = str_convert[ (byte)(data & 0xf) ];
				data = read_eeprom ( CIS_TPLMID_CARD_CODE ) ;
				*(bp+2) = str_convert[ (byte)((data>>4) & 0xf) ];
				*(bp+3) = str_convert[ (byte)(data & 0xf) ];
				at_output_msg ( bp, 4 ) ;
			}
			else
			{
				at_none() ;
			}
		}
		else if ( i != 4 )
		{
			// Error in input, bail out
			goto atp_err_xit ;
		}
		else
		{
			// write the TPLMID_CARD parameter to EEPROM
			loc = CIS_TPLMID_CARD_CODE+1 ;
			data = 0 ;
			for ( i=0; i<4 ; i++ )
			{
				hex_char = *bp++ ;
				if ( (hex_char >= '0') && (hex_char <= '9') )
				{
					data |= hex_char & 0x0f ;
				}
				else if (	((hex_char >= 'A') && (hex_char <= 'F'))
						 || ((hex_char >= 'a') && (hex_char <= 'f')) )
				{
					data |= ((hex_char & 0x0f) + 9) ;
				}
				if ( i & 1 )
				{
					write_eeprom ( loc--, data ) ;
					data = 0 ;
				}
				else
				{
					data <<= 4 ;
				}
			}
			bitmap |= CIS_TPLMID_CARD_BIT ;
		}
		break ;


	case 2:		// Manufacturer Info
		loc = CIS_TPLLV1_INFO_DATA ;
		if ( !i )
		{
			// read User Name (if present)
			if ( bitmap & CIS_TPLLV1_INFO_BIT )
			{
				byte size ;
				size = read_eeprom ( CIS_TPLLV1_INFO_SIZE ) ;
				for ( i=0; i<size; i++ )
				{
					*bp = read_eeprom ( loc++ ) ;
					if ( *bp++ == 0xff )
					{
						// we're done
						at_output_msg ( CISstring, i+1 ) ;
						break ;
					}
				}
			}
			else
			{
				at_none() ;
			}
			break ;
		}
		else if ( i > 40 )
		{
			// Error in input, bail out
			goto atp_err_xit ;
		}
		else
		{
			// write the manufacturer info to EEPROM
			write_eeprom ( CIS_BITMAP, bitmap & ~CIS_TPLLV1_INFO_BIT ) ;
			for ( i=0; i<50; i++ )
			{
				write_eeprom ( loc++, *bp ) ;
				if ( *bp++ == 0 )
				{
					write_eeprom ( loc, 0xff ) ;
					break ;
				}
			}
			write_eeprom ( CIS_TPLLV1_INFO_SIZE, i+2 ) ;
			bitmap |= CIS_TPLLV1_INFO_BIT ;
		}
		break ;
	case 3:		// Erase CIS
		bitmap = 0 ;
		write_eeprom ( CIS_BITMAP, 0 ) ;
		break ;

	default:
atp_err_xit:
		at_cmd_err_ret();
		return; 
	}

	// finally calculate new chksum
	if ( i )
	{
		write_eeprom ( CIS_BITMAP, bitmap ) ;
		write_eeprom ( CIS_CHKSUM, z80_CIS_chksum () ) ;
	}

	// Ignore any characters following at%p command
	G(at_result_code) = OK;
	at_output_msg(NULL, 0);
}
#endif

#ifdef DC0
extern byte cell_at_prnC ( byte * ) ;
/****************************************************************
at_prn() - processes the AT)Cn command - for direct connect phones
*****************************************************************/
void at_prn(void)
{
	if ( *G(at_cmd_ptr)++ == 'C' )
	{
		if ( cell_at_prnC ( G(at_cmd_ptr) ) == TRUE )
		{
			*G(at_cmd_ptr)++;
			atparse_cmd() ;
			return ;
		}
	}
	at_cmd_err_ret() ;
}
#endif	// DC0

// define the ErrorControl and Compression constants
#define	V42LAMP	1
#define	MNP	0x2
#define	NONE_PN	0
#define	V42BIS	1
#define	MNP5	0x80

//define the Key constant
#define UD_0 0x0
#define UD_1 0x1
#define UD_2 0x2
#define UD_3 0x3
#define UD_10 0x10
#define UD_11 0x11
#define UD_12 0x12
#define UD_14 0x14
#define UD_15 0x15
#define UD_17 0x17
#define UD_20 0x20
#define UD_21 0x21
#define UD_22 0x22
#define UD_23 0x23
#define UD_26 0x26
#define UD_27 0x27
#define UD_32 0x32
#define UD_33 0x33
#define UD_34 0x34
#define UD_35 0x35
#define UD_40 0x40
#define UD_41 0x41
#define UD_42 0x42
#define UD_43 0x43
#define UD_44 0x44
#define UD_56 0x56
#define UD_57 0x57
#define UD_58 0x58
#define UD_59 0x59
#define UD_60 0x60

#define UD_V32 0x0a
#define UD_V34 0x0c
#define UD_K56 0x81
#define UD_V90 0x0e

#define UD_CS_NO_DIAL_TONE		0x1
#define UD_CS_BUSY_TONE			0x3
#define UD_CS_REORDER_TONE		0x2
#define	UD_CS_NO_ANSWER			0x4

#define	UD_INTERFACE_FRAMED_MODE	0x1
#define	UD_INTERFACE_TRANS_MODE	0x2
#define	UD_INTERFACE_ASYNC_MODE	0

#define UD_VERSION	0x09

extern void at_ud_response(void);

/****************************************************************
Routine : at_pound
Description : 
	This routine process the ( at"#XX" ) commands. 

*****************************************************************/
void at_pound(void)
{
	switch(*G(at_cmd_ptr)++)
	{
		case 'U':
			switch(*G(at_cmd_ptr)++)
			{
				case 'D':
					at_ud_response();
					break;
				default:
					at_cmd_err_ret();
					break;
			}
			break;
		default:
			at_cmd_err_ret();
			break;
	}
}

extern word at_dtoa(dword,byte*,byte);

/****************************************************************
Routine : at_ud_display
Description :
	Display the status in AT#UD format.
	It will display the AT#UD response format: DIAG <2A4d3263 key = value>.
	The Value String will be displyed if the str is not NULL, 
	otherwise it will display the value in Hex format.
arguments:
	byte key:		the key in the AT#UD format.
	dword value:	the value of the key.
	
*****************************************************************/
void at_ud_display(byte key, dword value)
{
	byte	msg[70],*dest;
	dest = msg;
	*msg = '\0'; 

	// put the AT#UD response header into buffer
	x_strcat(msg, (CBP) "DIAG <2A4D3263 ");
	dest = msg + x_strlen(msg) ;
	at_dtoa(key, dest, HEX);				// put the Key into the buffer  
	x_strcat(msg, (CBP) " = ");
	dest = msg + x_strlen(msg); 

	if (at_dtoa(value, dest, HEX))
	{	// if the value is a valid one,
		// finish the buffer according to the AT#UD format
		x_strcat(msg, (CBP) ">");
		x_send_at_io_data(msg);
		x_send_at_io_crlf();
	}
}
	
/****************************************************************
Routine : at_ud_display_next
Description :
		display one keys

		at_currentViewLine - key number.  incremented after display
	
*****************************************************************/
void at_ud_display_next(word val)
{
	at_ud_display(G(at_currentViewLine)++, (dword) val);
}

// Call Termination Cause
static const byte T_Cause[] =
{
	0,0,UD_TC_CALL_SETUP_TIME_OUT,UD_TC_TRAINING_FAIL,
	UD_TC_E_CONTROL_FAIL	
};

// This maps our MR_XXX x_dial_residual
// values into the Call Setup Result codes for #UD
// (The two things don't map very well.)
static const byte ud_CS[] =
{
	0,						//MR_OK,
	0,						//MR_NO_DIAL_DTR,
	UD_CS_NO_DIAL_TONE,		//MR_NO_DIAL_TONE,
	UD_CS_BUSY_TONE,		//MR_BUSY_SIGNAL,
	0,						//MR_TRUNK_BUSY,
	0,						//MR_NO_ANSWER_TONE,
	0,						//MR_NO_QUIET_DETECTED,
	0,						//MR_REMOTE_DISCONNECT,
	0,						//MR_DTR_DISCONNECT,
	0,						//MR_CD_DISCONNECT,
	0,						//MR_EC_DISCONNECT,
	0,						//MR_LONG_SPACE_DISC,
	0,						//MR_NO_DATA_DISC,
	0,						//MR_DELAYED,
	0,						//MR_BLACKLISTED,
	0,						//MR_BLACKLIST_FULL
	0,						//MODEM_DIAL_RESIDUAL ;
};

// Table of the V.34 symbol rates from the
// values in DSP RAM locations 0x80A and 0x80B.
static const word ud_SYM_RATE[] =
{
	2400,2743,2800,3000,3200,3429
};

/****************************************************************
Routine : at_ud_response
Description :
	Reponse to the AT#UD command depends on the status.

	We're trying to conform here to the "Unimodem Diagnostics
	Command Reference Specification" from Microsoft.

*****************************************************************/
void at_ud_response(void)
{
	word i;

	at_putsCrLf(NULL);
	if ( G(x_modem_state) == MS_ON_DIAL )
		dp_update_diagnostics () ;		 	//update the status

	//translate the G(x_status) parameters into the #UD format
	G(at_currentViewLine) = 0;
	at_ud_display_next(UD_VERSION);		// 0 - Cmd spec revision number
	if (G(x_status).Connection == AT_MOD_FAIL)
	{	//Call Setup Result Code for the failing call 
		if(G(x_dial_residual) == MR_OK)
			at_ud_display_next(0);	// 1 - No Previous Call
		else if(ud_CS[ G(x_dial_residual)] != 0)
		{
			at_ud_display_next(ud_CS[ G(x_dial_residual)]); // 1
		}
		else if(G(x_status).TerminationCause == 2)
			at_ud_display_next(UD_CS_NO_ANSWER); // 1
	}
	else
	{
		if(G(x_status).ud_CallResult != 0)
			at_ud_display_next(G(x_status).ud_CallResult); // 1

		G(at_currentViewLine) = 2;
		// 2 - multi-media mode
		if(G(x_modem_mode) == MODEM_FAX)
			at_ud_display_next(1);
		else if(G(x_modem_mode) == MODEM_DATA)
			at_ud_display_next(0);

		G(at_currentViewLine) = 3;
		// 3 - DTE-DCE interface mode
#ifdef V80
		if(G(V80_Options).FrameIdle == SYNC_V80_FRAME_MODE)
			at_ud_display_next(UD_INTERFACE_FRAMED_MODE);
		else
			at_ud_display_next(UD_INTERFACE_TRANS_MODE);
#else
		at_ud_display_next(UD_INTERFACE_ASYNC_MODE);	
#endif

		i = (word) (4 + (G(x_status).ReceiveLevel>>8));
		if (G(x_status).Connection == AT_MOD_K56 && !G(V34Mode))
		{
			i = dp_lin_to_db();
		}	
		G(at_currentViewLine) = UD_10;
		at_ud_display_next(i);			// 0x10 - Receive Level
		at_ud_display_next(G(x_status).TransmitLevel);	// 0x11 - Xmit Level
		at_ud_display_next(G(x_status).NoiseLevel);		// 0x12 - Noise Level
		if (!(G(x_status).Connection >= AT_MOD_K56) ||
			(G(x_status).Connection == AT_MOD_FAIL))
		{	//Near and Far End Echo Loss
			G(at_currentViewLine) = UD_14;
			at_ud_display_next((word) (G(x_status).NearEchoLevel>>8));
			at_ud_display_next((word) (G(x_status).FarEchoLevel>>8));
		}
		at_ud_display(UD_17,G(x_status).RoundTripDelay);	//Round Trip Delay

		G(at_currentViewLine) = UD_20;
		switch(G(x_status).Connection)		//Modulation Scheme
		{
		case AT_MOD_V32:
		case AT_MOD_V32B:
			at_ud_display_next(UD_V32);
			at_ud_display_next(UD_V32);
			break;
		case AT_MOD_V34:
			at_ud_display_next(UD_V34);
			at_ud_display_next(UD_V34);

			i =	dp_read_dsp_ram(0x080a);	// V.34 symbol rate - transmit
			if (i <= 5)
				at_ud_display(UD_22,ud_SYM_RATE[i]);
			i =	dp_read_dsp_ram(0x080b);	// V.34 symbol rate - receive
			if (i <= 5)
				at_ud_display(UD_23,ud_SYM_RATE[i]);
			break;
		case AT_MOD_K56:	// K56FLEX
			at_ud_display_next(UD_V34);
			at_ud_display_next(UD_K56);
			break;
		case AT_MOD_V90:
			at_ud_display_next(UD_V34);		// xmit carrier
			at_ud_display_next(UD_V90);		// receive carrier
			at_ud_display_next(3200);			// xmit symbol rate
			at_ud_display_next(3200);			// receive symbol rate
			break;
		}

		G(at_currentViewLine) = UD_26;

		// 26H - Initial Tx Rate
		at_ud_display_next(io_line_rate[ G(x_status).IniTransmitRate]);
		// 27H - Initial Rx Rate
		at_ud_display_next(io_line_rate[ G(x_status).IniReceiveRate]);

		G(at_currentViewLine) = UD_32;
		// 32H - Number of Local Retrains
		at_ud_display_next(G(x_status).LocalRetrain);
		// 33H - Number of Remote Retrains
		at_ud_display_next(G(x_status).RemoteRetrain);
		// 34H - Final Tx Rate
		at_ud_display_next(io_line_rate[ G(x_status).FinalTransmitRate]);
		// 35H - Final Rx Rate
		at_ud_display_next(io_line_rate[ G(x_status).FinalReceiveRate]);

		G(at_currentViewLine) = UD_40;
		switch ( G(x_modem_ec) )
		{	//Error Correction and Data Compression Scheme
		case EC_V42V44:
		case EC_V42B:
			at_ud_display_next(V42LAMP);		// protocol
			at_ud_display_next(G(lapm_n401));		// frame size
			at_ud_display_next(G(x_status).ud_RetransmitCount);
			at_ud_display_next(G(x_status).TxErrorCount);
			at_ud_display_next(V42BIS);		// compression
			break;
		case EC_V42:
			at_ud_display_next(V42LAMP);
			at_ud_display_next(G(lapm_n401));
			at_ud_display_next(G(x_status).ud_RetransmitCount);
			at_ud_display_next(G(x_status).TxErrorCount) ;
			at_ud_display_next(NONE_PN) ;
			break;
		case EC_MNP5:
			at_ud_display_next(MNP);
			at_ud_display_next(G(lapm_n401));
			at_ud_display_next(G(x_status).ud_RetransmitCount);
			at_ud_display_next(G(x_status).TxErrorCount);
			at_ud_display_next(MNP5);
			break;
		case EC_MNP4:
		case EC_MNP3:
		case EC_MNP2:
			at_ud_display_next(MNP) ;
			at_ud_display_next(NONE_PN) ;
			at_ud_display_next(G(x_status).ud_RetransmitCount);
			at_ud_display_next(G(x_status).TxErrorCount) ;
			at_ud_display_next(NONE_PN) ;
			break;
		default:
			at_ud_display_next(NONE_PN);
			at_ud_display(UD_44,NONE_PN) ;
		}

		G(at_currentViewLine) = UD_56;
		at_ud_display_next(G(x_status).TxFrameCount);		//Tx Frame Count
		at_ud_display_next(G(x_status).RxFrameCount);		//Rx Frame Count
		at_ud_display_next(G(x_status).TxErrorCount);		//Tx Error Frame
		at_ud_display_next(G(x_status).RxErrorCount);		//Tx Error Frame
    }
	if (G(x_modem_state) != MS_IDLE)
	{
		G(x_status).ud_TerminationCause = UD_TC_ON_PROGRESS;
    }
	else if (T_Cause[ G(x_status).TerminationCause] != 0)
	{
    	G(x_status).ud_TerminationCause =
			T_Cause[G(x_status).TerminationCause];	//Termination Cause
	}
	else if (G(x_status).Connection == AT_MOD_FAIL &&
			 G(x_dial_residual) == MR_OK)
	{
		G(x_status).ud_TerminationCause=UD_TC_NO_CALL;// No previous call case
	}
	at_ud_display(UD_60,G(x_status).ud_TerminationCause);		
   
	G(at_result_code) = OK;									//output "OK"
	at_output_msg(NULL, 0);
}

#if defined (V25TER) && defined (VPCM_CLIENT)
/****************************************************************
Routine : at_v90
Description :
	process the AT-V90  command to control the V.90 and K56Flex 
	capabilities 

arguments:
	none
return:
	none		
*****************************************************************/
#define	AT_V90_MAX	23
void at_v90()
{
	word at_v90_val;
	DEFTMPI

	switch (*G(at_cmd_ptr)++)
	{
	case '=':
		if (*G(at_cmd_ptr) == '?')
		{
			x_send_at_io_crlf();
			x_send_at_io_data((byte *) "[0-23]");
			x_send_at_io_crlf();
			G(at_cmd_ptr)++ ;
		}
		else
		{
			TMPI = (byte) at_atoi(at_cmd_ptr, &at_v90_val, DECIMAL);
			if (TMPI != 0 && at_v90_val <= AT_V90_MAX)
			{
				// valid at-v90= command	
				G(S).ModemOptions.Rate56K = (byte) at_v90_val;
				G(at_cmd_ptr) += TMPI;
			}
			else
			{
				at_cmd_err_ret();
				return;
			}
		}
		break;
	case '?':
		if (G(S).ModemOptions.Rate56K > AT_V90_MAX)
			G(S).ModemOptions.Rate56K = 1;	//in case the rate is out of range

		// normal speeds, form the string manually
		x_send_at_io_crlf();
		(void) at_itoa(G(S).ModemOptions.Rate56K, G(x_scratch), DECIMAL);
		x_send_at_io_data(G(x_scratch));
		x_send_at_io_data((byte *) "  (");
		
		if (0 == G(S).ModemOptions.Rate56K)
		{
			x_send_at_io_data((byte *) "Disabled");
		}
		else if	(1 == G(S).ModemOptions.Rate56K)
		{
			x_send_at_io_data((byte *) "Auto Rate");
		}
		else
		{
			(void) at_itoa(io_line_rate[MRV_28000+G(S).ModemOptions.Rate56K-1],
						   G(x_scratch), DECIMAL);
			x_send_at_io_data(G(x_scratch));
		}

		x_send_at_io_data((byte *) ")");
		x_send_at_io_crlf();
		break;
	default:
		at_cmd_ptr--;
	}
	atparse_cmd();
}
#endif	//V25TER || VPCM_CLIENT

#if defined( SDR_RING_DETECT )
/****************************************************************
Routine : at_minus_sdr()
Description :
	This routine parses the Special Distinctive Ring commands.

	AT-SDR=n - Enable/Disable Distinctive Ring
	This command enables or disables detection and reporting of
	distinctive ring.

	The syntax is AT-SDR=n, where n is a number from 0 to 7.
	One, two, or three distinctive ring types can be simultaneously
	enabled depending upon the value of n (bit mapped).
	-SDR=0    Disables Distinctive Ring.
				Any valid ring detected is reported as RING (default).
	-SDR=1    Enables Distinctive Ring Type 1.
	-SDR=2    Enables Distinctive Ring Type 2.
	-SDR=3    Enables Distinctive Ring Type 1 and 2.
	-SDR=4    Enables Distinctive Ring Type 3.
	-SDR=5    Enables Distinctive Ring Type 1 and 3.
	-SDR=6    Enables Distinctive Ring Type 2 and 3.
	-SDR=7    Enables Distinctive Ring Type 1, 2, and 3.

	- Result Codes:
		OK        n = 0 to 7.
		ERROR     Otherwise.

****************************************************************/
void at_minus_sdr()
{
		if ( *G(at_cmd_ptr)++ == 'D'
			&& *G(at_cmd_ptr)++ == 'R'
			&& *G(at_cmd_ptr)++ == '='
			&& *G(at_cmd_ptr) >= '0'
			&& *G(at_cmd_ptr) <= '7' )
		{
			SDR_Ring_Select = *G(at_cmd_ptr)++ - '0';
		}
		else
		{
			at_cmd_err_ret();
			return;
		}
		atparse_cmd();
}
#endif
