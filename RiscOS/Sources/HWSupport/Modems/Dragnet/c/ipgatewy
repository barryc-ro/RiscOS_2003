/*name and version number:%W%*/
/*date of get: 		  %H% %T%*/
/*date of delta:	  %G% %U%*/
/****************************************************************
File :  ipgatewy.c

Description :
	Contains functions for an IP gateway to a remote access server.

Procedures Contained :

Revision History :
	Initials        Date            Change
	S.J. Busak     09/22/97       Initial Version
   S.J. Busak     11/18/98       Use looping for PPP/SLIP transmit; increase Tx performance

*****************************************************************/

/*#define DEBUG */   /* COMMENT OUT AFTER DEBUGGING */

#ifndef DEBUG
	#include "llglob_d.h"
	#include "ioglob_d.h"
	#include "z80glob.h"
#else                   /* FOR DEBUGGING ONLY */
	#include "debug.h"
	#include <\mtc\ppp09127\ipgw.h>
#endif

#ifdef IPGATEWAY
	#define IP_FRAME_SIZE (1550+3)	/* Maximum IP frame size supported + start byte + FCS */
	#define MSR_DCD 0x80
	#define DECLARE                 /* Declare variables in ipgw.h to be in this module */
	#include "ipgw.h"
	#include "allglobs.h"


/* ------------------------------------------ */
/* Declarations for Local-Function Prototypes */
/* ------------------------------------------ */

static void write_ip_tx      (byte);
static void write_dte_rx     (byte);
static byte read_dte_tx      (void);
static byte read_ip_rx       (void);
static void ppp_filter       (byte);

static void proc_rx_byte     (byte);
static void look4_frm_size   (void);
static void end_of_frm       (void);
static void set_ppp_state    (void);
static void use_full_bufr    (void);

static void split_bufr       (void);
static void chk_tx_timeout   (void);
static void reset_tx         (void);
static void reset_rx         (void);
static void chk_rx_timeout   (void);

static void chk_reset        (void);
static void ppp_h2m          (void);
static void ppp_m2h          (void);
static void slip_h2m         (void);
static void slip_m2h         (void);

static word dte_tx_bytes     (void);
static word ip_tx_space      (void);
static word dte_rx_space     (void);
static void init_dpq         (void); 

/* -------------------------------------- */
/* Declarations for Structures and Unions */
/* -------------------------------------- */

struct DLY_RX
{
	byte full;
	byte d1;
	byte d2;
};

/* -------------------------------- */
/* Declarations for Local Variables */
/* -------------------------------- */

static struct DLY_RX drx;  

static byte   ip_next_mode;      		
static byte   *ip_dte_rx_wptr;			
static byte   *ip_dte_rx_rptr;
static byte   *ip_dte_rx_sptr;
static byte   *ip_dte_rx_eptr;

static byte   h2m_state;
static byte   m2h_state;
static word   tx_size;
static word   last_byte;
static word   rx_timer;

static word   tx_timer;  
static word   rx_crc;
static word   tx_crc;

byte   *ip_dte_tx_sptr;						
byte   *ip_dte_tx_eptr;				 

/* ------------------------------------------------- */
/* Declarations for External Variables and Functions */
/*          not included in header files             */
/* ------------------------------------------------- */

void chk_esc_seq   (void);	  							   /* ip_fcs.c */

extern byte *CMD_TO_M;                             /* csmain.c */
extern volatile byte io_dte_tx_buff [IO_DTE_TX_BUFF_SIZE];  /* iodte.c  */
extern volatile byte io_dte_rx_buff [IO_DTE_RX_BUFF_SIZE];  /* iodte.c  */
extern word compute_crc (byte, word);              /* ip_fcs.c */
extern byte esc_state;										/* ip_fcs.c */

/****************************************************************/
/*         GENERAL PURPOSE FUNCTIONS RELATED TO IP GATEWAY      */
/****************************************************************/

/* ----------------------- */
/* Initialization function */
/* ----------------------- */

void ip_init ()
{
	byte i;

	h2m_state       = 0;
	m2h_state       = 0;
	cbq_init ();                 // Initialize code byte queue
	ip.host_status  = 0;			  // Disable code-byte I/F
	rx_isr_state    = 0;         // RBR IE state machine variable used in csz80man.c
	ip.status       = 0x01;      // Set host ACK to a code byte
	esc_state       = 0;         /* State: Look for 1 seconds of no data */
	tx_accm.flag    = 0;         /* No new Tx ACCM map */
	rx_accm.flag    = 0;         /* No new Rx ACCM map */
	ip_mode         = 0;         /* Character mode */
	drx.full        = 0;         /* Indicate Rx shift register is empty */
	ip_next_mode    = 0xFF;      /* No pending mode change */
	ip.shr_flg_tmr  = 1000;      /* Set shared flag timer to 1 seconds */

	use_full_bufr ();            /* Allocate all buffer space to ISRs */
	chk_buffers ();

	for (i = 0; i < 4; i++)      /* Initialize ACCM maps to all 1's */
	{
		tx_accm.cur_map [i] = 0xFF;
		rx_accm.cur_map [i] = 0xFF;
	}
}

// -------------------------------- //
// Initialize the DTE Pointer Queue //
// -------------------------------- //

void init_dpq ()
{
  dpq.cnt     = 0;
  dpq.ip_idx  = 0;
  dpq.isr_idx = 0;
  dpq.fcs     = 0;
  dpq.eof     = 0;
}

/* --------------------------------------- */
/* Main background function for IP gateway */
/* --------------------------------------- */

void ip_background ()
{
	if (ip_mode == 2)       /* PPP mode? */
	{
		chk_reset ();			/* Check if host wants to reset state machines */
		ppp_h2m ();          /* Frame data from DTE */
		ppp_m2h ();          /* Un-frame data to DTE */
	}

	else if (ip_mode == 3)  /* SLIP mode? */
	{
		chk_reset ();        /* Check if host wants to reset state machines */
		slip_h2m ();			/* Frame data from DTE */
		slip_m2h ();			/* Un-frame data to DTE */
	}

	else							/* Character mode */
		chk_esc_seq ();      /* Check for "escape sequence" */
}

/* -------------------------------------------------- */
/* Split the DTE buffer area into two sets of buffers */
/* -------------------------------------------------- */
/*
	 For each buffer, the shrunken DTE buffers will occupy
	 the first part of the original buffer.  The ISRs and
	 IP tasks will uses the last part of the original buffer.
*/

void split_bufr ()
{
	byte ie_save;

	disable_interrupt ();          /* +c-5/12: BUG workaround */
	ie_save = input8 (MIMIC_IE);   /* Save MIMIC interrupt enables */
	output8 (MIMIC_IE, 0);         /* +c-7/06: Disable all interrupts */
	enable_interrupt ();           /* +c-5/12: BUG workaround */

	init_dpq ();

	isr_dte_tx_rptr = (byte**) &ip_dte_tx_rptr;  /* Point to read pointer */
	isr_dte_tx_wptr = (byte**) &dpq.ptr[0];      // +c-7/06
	isr_dte_rx_wptr = (byte**) &ip_dte_rx_wptr;  /* Point to write pointer */

	io_dte_tx_wptr = io_dte_tx_buff;    /* Point to beginning of buffer */
	io_dte_tx_rptr = io_dte_tx_buff;
	io_dte_tx_sptr = io_dte_tx_buff;
	io_dte_tx_eptr = io_dte_tx_buff + (IO_DTE_TX_BUFF_SIZE - IP_FRAME_SIZE);  /* 1st part of buffer */

	io_dte_rx_wptr = io_dte_rx_buff;    /* Point to beginning of buffer */
	io_dte_rx_rptr = io_dte_rx_buff;
	io_dte_rx_sptr = io_dte_rx_buff;
	io_dte_rx_eptr = io_dte_rx_buff + (IO_DTE_RX_BUFF_SIZE - IP_FRAME_SIZE);  /* 1st part of buffer */

	ip_dte_tx_wptr = io_dte_tx_buff + (IO_DTE_TX_BUFF_SIZE - IP_FRAME_SIZE);  /* Point to 2nd part of buffer */
	ip_dte_tx_rptr = ip_dte_tx_wptr;
	ip_dte_tx_sptr = ip_dte_tx_wptr;
	ip_dte_tx_eptr = io_dte_tx_buff + IO_DTE_TX_BUFF_SIZE; /* End of original buffer */

	isr_dte_tx_sptr = (word) ip_dte_tx_sptr;     /* Start of buffer */
	isr_dte_tx_eptr = (word) ip_dte_tx_eptr;     /* End of buffer */

	ip_dte_rx_wptr = io_dte_rx_buff + (IO_DTE_RX_BUFF_SIZE - IP_FRAME_SIZE);  /* Point to 2nd part of buffer */
	ip_dte_rx_rptr = ip_dte_rx_wptr;
	ip_dte_rx_sptr = ip_dte_rx_wptr;
	ip_dte_rx_eptr = io_dte_rx_buff + IO_DTE_RX_BUFF_SIZE; /* End of original buffer */

	isr_dte_rx_sptr = (word) ip_dte_rx_sptr;         /* Start of buffer */
	isr_dte_rx_eptr = (word) ip_dte_rx_eptr;         /* End of buffer */
	isr_rx_full_count = IP_FRAME_SIZE - 196;         /* Flow control, full threshold */
	isr_rx_empty_count = isr_rx_full_count - 128;    /* Flow control, empty threshold */

  dpq.ptr[0]  = ip_dte_tx_wptr;  // +c-7/06

	disable_interrupt ();          /* +c-5/12: BUG workaround */
	output8 (MIMIC_IE, ie_save);   /* Restore MIMIC IE register */
	enable_interrupt ();           /* +c-5/12: BUG workaround */
}

/* ----------------------------------------------------------- */
/* Allocate all DTE buffer space to Interrupt Service Routines */
/* ----------------------------------------------------------- */

void use_full_bufr ()
{
	byte ie_save;

	disable_interrupt ();          /* +c-5/12: BUG workaround */
	ie_save = input8 (MIMIC_IE);   /* +c-7/06: Save MIMIC interrupt enables */
	output8 (MIMIC_IE, 0);         /* Disable all interrupts */
	enable_interrupt ();           /* +c-5/12: BUG workaround */

	io_dte_tx_wptr = io_dte_tx_buff;
	io_dte_tx_rptr = io_dte_tx_buff;
	io_dte_tx_sptr = io_dte_tx_buff;
	io_dte_tx_eptr = io_dte_tx_buff + IO_DTE_TX_BUFF_SIZE;

	isr_dte_tx_rptr = (byte**) &io_dte_tx_rptr;
	isr_dte_tx_wptr = (byte**) &io_dte_tx_wptr;
	isr_dte_tx_sptr = (word) io_dte_tx_sptr;
	isr_dte_tx_eptr = (word) io_dte_tx_eptr;

	io_dte_rx_wptr = io_dte_rx_buff;
	io_dte_rx_rptr = io_dte_rx_buff;
	io_dte_rx_sptr = io_dte_rx_buff;
	io_dte_rx_eptr = io_dte_rx_buff + IO_DTE_RX_BUFF_SIZE;

	isr_dte_rx_wptr = (byte**) &io_dte_rx_wptr;
	isr_dte_rx_sptr = (word) io_dte_rx_sptr;
	isr_dte_rx_eptr = (word) io_dte_rx_eptr;
	isr_rx_full_count = IO_DTE_RX_BUFF_FULL;     /* Restore flow control threshold */
	isr_rx_empty_count = IO_DTE_RX_BUFF_EMPTY;

	rx_isr_state = 0;              /* RBR IE state machine variable used in csz80man.c */
	disable_interrupt ();          /* +c-5/12: BUG workaround */
	output8 (MIMIC_IE, ie_save);   /* Restore MIMIC IE register */
	enable_interrupt ();           /* +c-5/12: BUG workaround */
}

/* ---------------------------------- */
/* Read a byte from the DTE Tx Buffer */
/* ---------------------------------- */

byte read_dte_tx ()
{
	byte data;

	data = *io_dte_tx_rptr++;

	if (io_dte_tx_rptr >= io_dte_tx_eptr)     // +c-5/12: changed from == to >=
		io_dte_tx_rptr = io_dte_tx_sptr;

	return (data);
}

/* -------------------------------- */
/* Write a byte to the IP Tx Buffer */
/* -------------------------------- */

void write_ip_tx (data)
byte data;
{
	byte *wptr;

	wptr = dpq.ptr [dpq.ip_idx];
	*wptr++ = data;

	if (wptr >= ip_dte_tx_eptr)
		wptr = ip_dte_tx_sptr;

	dpq.ptr [dpq.ip_idx] = wptr;
}

/* --------------------------------- */
/* Read a byte from the IP Rx Buffer */
/* --------------------------------- */

byte read_ip_rx ()
{
	byte data;

	data = *ip_dte_rx_rptr++;

	if (ip_dte_rx_rptr >= ip_dte_rx_eptr)
		ip_dte_rx_rptr = ip_dte_rx_sptr;

	return (data);
}

/* --------------------------------- */
/* Write a byte to the DTE Rx Buffer */
/* --------------------------------- */

void write_dte_rx (data)
byte data;
{
	*io_dte_rx_wptr++ = data;

	if (io_dte_rx_wptr >= io_dte_rx_eptr)
		io_dte_rx_wptr = io_dte_rx_sptr;
}

/* --------------------------------------------------------- */
/* Return the number of bytes available in the DTE Tx buffer */
/* --------------------------------------------------------- */

word dte_tx_bytes ()
{
	if (io_dte_tx_wptr >= io_dte_tx_rptr)
		return (io_dte_tx_wptr - io_dte_tx_rptr);

	else
		return ( (io_dte_tx_eptr - io_dte_tx_sptr) -		/* Buffer size minus */
						 (io_dte_tx_rptr - io_dte_tx_wptr) );		/* Buffer space available */
}

/* -------------------------------------------------------- */
/* Return the number of empty locations in the IP Tx buffer */
/* -------------------------------------------------------- */

word ip_tx_space ()
{
	word space;
	byte *wptr;

	disable_interrupt ();
	wptr = dpq.ptr [dpq.ip_idx];

  if (wptr >= ip_dte_tx_rptr)
		space = ( (ip_dte_tx_eptr - ip_dte_tx_sptr) -
					 (wptr - ip_dte_tx_rptr) - 1);

	else
		space = (ip_dte_tx_rptr - wptr - 1);

	enable_interrupt ();
	return (space);
}

// ---------------------------------------------- //
// Return the number of bytes in the IP Tx buffer //
// ---------------------------------------------- //

word ip_tx_bytes ()
{
	word num;

	disable_interrupt ();

	if (*isr_dte_tx_wptr >= *isr_dte_tx_rptr)
		num = *isr_dte_tx_wptr - *isr_dte_tx_rptr;

	else
		num = (isr_dte_tx_eptr - isr_dte_tx_sptr) -
					(*isr_dte_tx_rptr - *isr_dte_tx_wptr);

	enable_interrupt ();
	return (num);
}

/* -------------------------------------------------------- */
/* Return the number of bytes available in the IP Rx buffer */
/* -------------------------------------------------------- */

word ip_rx_bytes ()
{
	word num;

	disable_interrupt ();

	if (ip_dte_rx_wptr >= ip_dte_rx_rptr)
		num = (ip_dte_rx_wptr - ip_dte_rx_rptr);

	else
		num = ( (ip_dte_rx_eptr - ip_dte_rx_sptr) -    /* Buffer size minus */
					  (ip_dte_rx_rptr - ip_dte_rx_wptr) );	 /* Buffer space available */

	enable_interrupt ();
	return (num);
}

/* --------------------------------------------------------- */
/* Return the number of empty locations in the DTE Rx buffer */
/* --------------------------------------------------------- */

word dte_rx_space ()
{
	if (io_dte_rx_wptr >= io_dte_rx_rptr)
		return ( (io_dte_rx_eptr - io_dte_rx_sptr) - 		  /* Buffer size minus */
						 (io_dte_rx_wptr - io_dte_rx_rptr) - 1 );	/* Bytes in buffer less 1 */

	else
		return (io_dte_rx_rptr - io_dte_rx_wptr - 1);
}

/* ------------------------------------------------ */
/* Look for in-band transmission sequence from host */
/* ------------------------------------------------ */

void look4_frm_size ()
{
	byte data;

	while (ip_rx_bytes () >= 3)        /* +c-7/09: Sync character + 2 byte length? */
	{
		data = read_ip_rx ();          /* Get 1st byte of block */

		if (data == 0xAA)	           /* Sync character? */
		{
			tx_size = read_ip_rx ();                  /* Get MSB of length */
			tx_size = (tx_size << 8) + read_ip_rx (); /* Get LSB of length */
			tx_timer = x_current_time ();     		  /* Start time-out timer */
			h2m_state++;
			ip.status = ip.status & ~LOST_SYNC;       // +c-7/09: Clear flag
			break;                                    // +c-7/09: Exit while loop & return
		}

		else if (!(ip.status & LOST_SYNC))      // +c-7/09
		{
			load_cbq (LOSS_OF_SYNC);            /* Inform the host */
			ip.status = ip.status | LOST_SYNC;  // +c-7/09: Don't send any more codebytes until sync'd again
		}
	}
}

/* -------------------------------------------- */
/* Signal Rx ISR that a frame has been received */
/* -------------------------------------------- */

void end_of_frm ()
{
	byte *wptr;

	wptr = dpq.ptr [dpq.ip_idx];              // Save current pointer for later use
	disable_interrupt ();                     // Don't allow MIMIC (any) interrupts

	if (ip_dte_tx_rptr == wptr)               // Current (also last) buffer empty?
	{
		load_cbq (END_OF_FRM | 					   // End of frame code byte
					((dpq.fcs << (6-dpq.isr_idx)) & FCS_BAD) | 30);  // FCS status plus byte count

		output8 (MIMIC_IE, input8 (MIMIC_IE) & ~0x10);  // Mask RBR Interrupts until EOF acked
		ip.status = ip.status | EOF_EMPTY;              // Set diagnostic indicator
	}

	else
	{
		dpq.eof = dpq.eof | (1 << dpq.ip_idx); // Set EOF flag for this frame
		dpq.cnt++;                             // Update frame count in DTE Pointer Queue

		if (++dpq.ip_idx >= 5)                 // Is next location is queue above upper limit?
			dpq.ip_idx = 0;                     // Wrap around to 0

		if (dpq.cnt < 5)                       // Don't need the ISR to initialize this pointer (queue not full)?
			dpq.ptr [dpq.ip_idx] = wptr;        // Initialize next start-pointer to last end-pointer
	}                                         

	enable_interrupt ();
}

/* ------------------------------------------------ */
/* Check if the host wants to reset a state machine */
/* ------------------------------------------------ */

void chk_reset ()
{
	if ( (ip.host_status & (RESET_TX | RESET_RX)) == 	// Both reset active?
		  (RESET_TX | RESET_RX) )
		cbq_init ();																		// Clear code byte queue too

	if (ip.host_status & RESET_TX)
	{
		ip.host_status = ip.host_status & ~RESET_TX;
		reset_tx ();
	}

	if (ip.host_status & RESET_RX)
	{
		ip.host_status = ip.host_status & ~RESET_RX;
		reset_rx ();
	}
}

/* --------------------------------------------- */
/* Check for time-out while waiting for DTE data */
/* --------------------------------------------- */

void chk_tx_timeout ()
{
	if (ip_rx_bytes () )							// Any data in buffer?
		tx_timer = x_current_time ();   // Reset time-out timer

	else if (x_elapsed_time (tx_timer) > 30000)  // +c-5/12: No data for 30 seconds?
	{
		reset_tx ();										  /* Reset transmit task */
		load_cbq (TX_TIMEOUT);            /* Inform the host */
	}
}

/* ------------------------------------ */
/* Reset the PPP/SLIP Tx state machines */
/* ------------------------------------ */

void reset_tx ()
{
	disable_interrupt ();
	ip_dte_rx_rptr = ip_dte_rx_wptr;

	io_dte_rx_rptr = io_dte_rx_wptr;	   // Clear DTE Rx buffer
	io_dce_tx_rptr = io_dce_tx_wptr;   	 // Clear DCE Rx buffer
	uart_rx_count = 0;							     // Clear DTE Tx count

	while (!(input8(MIMIC_LSR) & 0x20))	 // Flush TxFIFO
		input8(MIMIC_THR);

	enable_interrupt ();
	h2m_state = 0;
}

/* -------------------------------------------------------------- */
/* Check for a time-out while receiving a frame from a remote DCE */
/* -------------------------------------------------------------- */

void chk_rx_timeout ()
{
	if (dte_tx_bytes ())										/* Data from remote DCE? */
		rx_timer = x_current_time ();					/* Restart time-out timer */

	else if (x_elapsed_time (rx_timer) > 30000)	/* +c-5/12: 30 seconds of no data? */
	{
		load_cbq (RX_TIMEOUT);                /* Signal the host */

		if (ip_mode == 2)										 // PPP mode?
		{
			proc_rx_byte (0);									 // Push last type bytes out of shift register,
			proc_rx_byte (0);									 //  Shift in FCS of 0x0000
			*io_dte_tx_wptr++ = 0x7E;					 // Stuff	ending flag in buffer
		}

		else																 // SLIP mode
			*io_dte_tx_wptr++ = END;           // Stuff ending character in buffer

		if (io_dte_tx_wptr >= io_dte_tx_eptr)
			io_dte_tx_wptr = io_dte_tx_sptr;

		last_byte = 0;                       // Make sure ending character isn't filtered
	}
}

/* ------------------------------------ */
/* Reset the PPP/SLIP Rx state machines */
/* ------------------------------------ */

void reset_rx ()
{
	disable_interrupt ();
	ip_dte_tx_rptr = dpq.ptr[dpq.ip_idx];                  /* Flush buffer */

	ip.status = ip.status & ~MCR_EN_RBR;                   // Don't have MCR ISR enable RBR interrupts
	io_dte_tx_rptr = io_dte_tx_wptr;							 	 /* Clear DTE Tx buffer */
	io_dce_rx_rptr = io_dce_rx_wptr;							 	 /* Clear DCE Rx buffer */
	enable_interrupt ();
	m2h_state = 0;                                         /* Look for start character */
}

/****************************************************************/
/*                 FUNCTIONS RELATED TO PPP                     */
/****************************************************************/

/* ------------------------------------------------------- */
/* PPP -- Transfer Data from IP Rx Buffer to DTE Rx Buffer */
/* ------------------------------------------------------- */

void ppp_h2m ()
{
	byte data;
	byte loop = 1; 

	while (loop)
	{              
		switch (h2m_state)
		{
		 /*******/
			case 0:  /* Check for Tx frame size */
		 /*******/
				look4_frm_size ();
				loop = (h2m_state == 1);  // Continue if state set to 1
				break;

		 /*******/
			case 1:  /* Send beginning flag */
		 /*******/
				if (dte_rx_space ())	      /* Room in buffer? */
				{
					write_dte_rx (0x7E);	    /* Starting flag */
					tx_crc = 0xFFFF;			    /* Initialize CRC */
					h2m_state++;					    /* Filter & send frame data */
				}

				else         
					loop = 0; 

				break;

		 /*******/
			case 2:  /* Filter and send frame data */
		 /*******/
				chk_tx_timeout ();			/* Check for Tx Time-out */

				while (ip_rx_bytes () && (dte_rx_space () >= 2) )
				{
					data = read_ip_rx ();
					ppp_filter (data);
					tx_crc = compute_crc (data, tx_crc);

					if (!(--tx_size))
					{
						h2m_state++;
						break;
					}
				}

				if (!(ip_rx_bytes () && (dte_rx_space () >= 2)) && tx_size)
					loop = 0;                                                  

				break;

		 /*******/
			case 3:  /* Send FCS and ending flag */
		 /*******/
				if (dte_rx_space () >= 5)
				{
					tx_crc = ~tx_crc;
					ppp_filter ((byte) (tx_crc & 0x00FF));
					ppp_filter ((byte) (tx_crc >> 8));
					write_dte_rx (0x7E);
					h2m_state = 0;

					if (tx_accm.flag)  /* New ACCM map? */
					{
						byte i;

						for (i = 0; i < 4; i++)
							tx_accm.cur_map [i] = tx_accm.new_map [i];

						tx_accm.flag = 0;
					}
				}

				else
					loop = 0; 

				break;

		 /********/
			default:
		 /********/
				reset_tx ();
				load_cbq (TX_SM_ERR);
		}
	}    
}

/* ------------------------------------------------------- */
/* PPP -- Transfer Data from DTE Tx Buffer to IP Tx Buffer */
/* ------------------------------------------------------- */

void ppp_m2h ()
{
	byte data;
	byte loop;         // +c-7/06

	if (dpq.cnt >= 5)  // +c-7/06: DTE pointer queue full?
		loop = 0;        // +c-7/06: Disable PPP Rx processing

  else               // +c-7/06:
	 loop = 1;        // +c-7/06: Enable PPP Rx processing

  while (loop)       // +c-7/06
  {                  // +c-7/06
	  switch (m2h_state)
	  {
	  /*******/
		  case 0:		/* Look for initial starting flag */
	  /*******/
		  if (dte_tx_bytes () )        // +c-7/06: Any data received from client?
			  {
				  if (read_dte_tx () == 0x7E)  // Starting flag?
				  {
						rx_crc = 0xFFFF;
						last_byte = 0;
						drx.full = 0;
						rx_timer = x_current_time ();
						m2h_state++;
				  }
			  }

		  else         // +c-7/06
			 loop = 0;  // +c-7/06

			  break;

	  /*******/
		  case 1:		/* Receive & filter message, look for ending flag */
	  /*******/
			  chk_rx_timeout ();

			  if (dte_tx_bytes () && !ip_tx_space () &&   // Overrun?
					 !(ip.status & RX_OVR) )								  // Not reported to host?
			  {
				  load_cbq (RX_OVERRUN);                    // Signal host
				  ip.status = ip.status | RX_OVR | FCS_BAD; // Save condition, bad FCS is no flag detected
//	 ????  	  ip.status = ip.status | RX_OVR;                     // Indicate receive overrun
//	 ????		  dpq.fcs = dpq.fcs | (FCS_BAD >> (6 - dpq.ip_idx));  // Set FCS flag in case ending flag not detected
			  }

			  while (dte_tx_bytes () && ip_tx_space ())
			  {
				  data = read_dte_tx ();

				  if (last_byte == 0x7D)
				  {
					  data = data ^ 0x20;
					  proc_rx_byte (data);
					  data = 0;              /* Prevent last_byte from being set to 0x7D below */
				  }

				  else if (data < 0x20)
				  {
					  if ( !(rx_accm.cur_map [data/8] & (0x01 << (data % 8))) )
						  proc_rx_byte (data);
				  }

				  else if (data == 0x7E)	/* Ending flag */
				  {
						rx_crc = compute_crc (drx.d2, rx_crc);
						rx_crc = compute_crc (drx.d1, rx_crc);

					  if (rx_crc == 0xF0B8)  /* "Good" FCS? */
						  dpq.fcs = dpq.fcs & (~FCS_BAD >> (6 - dpq.ip_idx)); // +c-7/06
//	 ????				  dpq.fcs = dpq.fcs & ~(FCS_BAD >> (6 - dpq.ip_idx)); // Indicate bad FCS for this frame

					  else
						  dpq.fcs = dpq.fcs | (FCS_BAD >> (6 - dpq.ip_idx));  // +c-7/06

					  end_of_frm ();	 /* Signal end of frame to host */
					  m2h_state++;
					  break;
				  }

				  else if (data != 0x7D)
					  proc_rx_byte (data);

				  last_byte = data;
			  }

			  if (!dte_tx_bytes () || !ip_tx_space ())    // +c-7/06: Not data or space?
				 loop = 0;                                 // +c-7/06: Terminate PPP processing

			  break;

	  /*******/
		  case 2:		/* Determine what state to go to next */
	  /*******/
				ip.status = ip.status & ~RX_OVR;  // Clear overrun flag is set

				if (dte_tx_bytes () )		       /* More data in buffer? */
				{                                 // +c-7/06
					set_ppp_state ();				    /* Set state based on next character */

					if (dpq.cnt >= 5)              // +c-7/06: DTE pointer queue full?
						loop = 0;                   // +c-7/06: Disable PPP Rx processing
				}                                 // +c-7/06

				else
				{
					rx_timer = x_current_time ();	 /* Start receive timer */
					m2h_state++;						 /* Wait programmed time for new data */
					loop = 0;                      // +c-7/06
				}

				if (rx_accm.flag)  /* New ACCM map? */
				{
					byte i;

					for (i = 0; i < 4; i++)
						rx_accm.cur_map [i] = rx_accm.new_map [i];

					rx_accm.flag = 0;
				}

				break;

	  /*******/
		  case 3:		/* Wait programmed time for new data using shared flags */
	  /*******/
			  if ( (x_elapsed_time (rx_timer) > ip.shr_flg_tmr) &&  /* Shared flag timer expired? */
					 (ip.shr_flg_tmr) )                               /* Timer is non-zero? (enabled)*/
				  m2h_state = 0;											     /* Must receive an opening flag now! */

			  else if (dte_tx_bytes ())			        /* Data received? */
				  set_ppp_state ();										/* Set state based on next character */

			  else         // +c-7/06
				 loop = 0;  // +c-7/06

			  break;

	  /********/
		  default:
	  /********/
			  reset_rx ();
			  load_cbq (RX_SM_ERR);
	  }
  }   // +c-7/06
}

/* -------------------------- */
/* Set next PPP Receive state */
/* -------------------------- */

void set_ppp_state ()
{
	if (*io_dte_tx_rptr == 0x7E)	/* Is next byte a flag? */
		m2h_state = 0;              /* Receive next flag */

	else	                        /* Assume shared flag */
	{
		rx_crc = 0xFFFF;						/* Init CRC */
		last_byte = 0;							/* Init last byte */
		drx.full = 0;               // Indicate Rx shift register is empty
		m2h_state = 1;							/* Receive data */
	}
}

/* --------------------------------------------------- */
/* Process a valid byte received from the remote modem */
/* --------------------------------------------------- */

void proc_rx_byte (data)
byte data;
{
	if (drx.full < 2)
		drx.full++;

	else
	{
		write_ip_tx (drx.d2);
		rx_crc = compute_crc (drx.d2, rx_crc);
	}  

	drx.d2 = drx.d1;
	drx.d1 = data;
}

/* ------------------------------------------------- */
/* Filter data for PPP and output character sequence */
/* ------------------------------------------------- */

void ppp_filter (data)
byte data;
{
	if ( (data == 0x7E) || (data == 0x7D) )
	{
		write_dte_rx (0x7D);
		write_dte_rx (data ^ 0x20);
	}

	else if (data < 0x20)
	{
		if (tx_accm.cur_map [data/8] & (0x01 << (data % 8)) )
		{
			write_dte_rx (0x7D);
			write_dte_rx (data ^ 0x20);
		}

		else
			write_dte_rx (data);
	}

	else
		write_dte_rx (data);
}

/****************************************************************/
/*                FUNCTIONS RELATED TO SLIP                     */
/****************************************************************/

/* -------------------------------------------------------- */
/* SLIP -- Transfer Data from IP Rx Buffer to DTE Rx Buffer */
/* -------------------------------------------------------- */

void slip_h2m ()
{
	byte data;
	byte loop = 1;    

	while (loop)     
	{                 
		switch (h2m_state)
		{
		/*******/
			case 0:  /* Check for Tx frame size */
		/*******/
				look4_frm_size ();          /* Check if a frame size is available */
				loop = (h2m_state == 1);    // Continue if state set to 1
				break;

		/*******/
			case 1:  /* Send start character -- END */
		/*******/
				if (dte_rx_space ())	/* Room in buffer? */
				{
					write_dte_rx (END);	      /* Start character */
					h2m_state++;					    /* Filter & send data */
				}

				else                     
					loop = 0;             

				break;

		/*******/
			case 2:  /* Transfer block from IP Rx buffer to DTE Rx buffer */
		/*******/
				chk_tx_timeout ();			/* Check for Tx Time-out */

				while (ip_rx_bytes () && (dte_rx_space () >= 2))
				{
					data = read_ip_rx ();

					switch (data)
					{
						case END:
							write_dte_rx (ESC);
							write_dte_rx (ESC_END);
							break;

						case ESC:
							write_dte_rx (ESC);
							write_dte_rx (ESC_ESC);
							break;

						default:
							write_dte_rx (data);
					}

					if (!(--tx_size))
					{
						h2m_state++;
						break;
					}
				}

				if (!(ip_rx_bytes () && (dte_rx_space () >= 2)) && tx_size)  
					loop = 0;                                                

				break;

		/*******/
			case 3:	 /* Send END character -- END */
		/*******/
				if (dte_rx_space () )	/* Room in buffer? */
				{
					write_dte_rx (END);	      /* End character */
					h2m_state = 0;				    /* Send next frame, if available */
				}

				else          
					loop = 0;  

				break;

		/********/
			default:
		/********/
				reset_tx ();
				load_cbq (TX_SM_ERR);
		}
	}
}

/* -------------------------------------------------------- */
/* SLIP -- Transfer Data from DTE Tx Buffer to IP Tx Buffer */
/* -------------------------------------------------------- */

void slip_m2h ()
{
	byte data;
  byte loop;         // +c-7/06

  if (dpq.cnt >= 5)  // +c-7/06: DTE pointer queue full?
	 loop = 0;        // +c-7/06: Disable PPP Rx processing

  else               // +c-7/06:
	 loop = 1;        // +c-7/06: Enable PPP Rx processing

  while (loop)       // +c-7/06
  {                  // +c-7/06
	  switch (m2h_state)
	  {
	  /*******/
		  case 0:		/* Look for start character -- END */
	  /*******/
		  if (dte_tx_bytes ())       // +c-7/06
			  {
				  if (read_dte_tx () == END)
				  {
					  last_byte = 0;
					  rx_timer = x_current_time ();
					  m2h_state++;
				  }
			  }

		  else         // +c-7/06
			 loop = 0;  // +c-7/06

			  break;

	  /*******/
		  case 1:		/* Receive & filter data, look for end character */
	  /*******/
			  chk_rx_timeout ();

			  if (dte_tx_bytes () && !ip_tx_space () &&  // Overrun?
					 !(ip.status & RX_OVR) )							   // Not reported to host
			  {
				  load_cbq (RX_OVERRUN);                   // Signal host
				  ip.status = ip.status & ~FCS_BAD;        // FCS not used for SLIP
//	 ????		  dpq.fcs = 0;                             // FCS not used for SLIP
				  ip.status = ip.status | RX_OVR;			 // Indicate overrun
			  }

			  while (dte_tx_bytes () && ip_tx_space () )
			  {
				  data = read_dte_tx ();

				  if (last_byte == ESC)
				  {
					  switch (data)
					  {
					  /*************/
						  case ESC_END:
					  /*************/
							  write_ip_tx (END);
							  break;

					  /*************/
						  case ESC_ESC:
					  /*************/
							  write_ip_tx (ESC);
							  break;

					  /********/
						  default:
					  /********/
							  write_ip_tx (data);
					  }
				  }

				  else if (data == END)
				  {
						end_of_frm ();   /* Signal end of frame to host */
						dpq.fcs = dpq.fcs & (~FCS_BAD >> (6 - dpq.ip_idx)); // +c-7/06
//  ????				dpq.fcs = 0;              // FCS not used for SLIP
						m2h_state++;
						break;
				  }

				  else if (data != ESC)
					  write_ip_tx (data);

				  last_byte = data;
			  }

			  if (!dte_tx_bytes () || !ip_tx_space ())    // +c-7/06: Not data or space?
					loop = 0;                                 // +c-7/06: Terminate SLIP processing

		  break;

	  /*******/
		  case 2:		/* Wait for host to ACK received frame */
	  /*******/
		  m2h_state = 0;
		  ip.status = ip.status & ~RX_OVR;    // Clear overrun is set

		  if (dpq.cnt >= 5)  // +c-7/06: DTE pointer queue full?
			 loop = 0;        // +c-7/06: Disable PPP Rx processing

		  break;

	  /********/
		  default:
	  /********/
		  reset_rx ();
		  load_cbq (RX_SM_ERR);
	  }
  }
}

/****************************************************************/
/*         BACKGROUND TASKS ASSOCIATED WITH IP GATEWAY          */
/****************************************************************/

/* ------------------------------ */
/* Check if all buffers are empty */
/* ------------------------------ */
// ???? Check Tx/Rx resets here????

void chk_buffers ()
{
	byte i;

	i = (io_dte_rx_rptr == io_dte_rx_wptr) +
			(io_dte_tx_rptr == io_dte_tx_wptr);

	if (ip_mode)   /* PPP or SLIP? */
		i = i +
		  (ip_dte_rx_rptr == ip_dte_rx_wptr) +
		  (ip_dte_tx_rptr == dpq.ptr[dpq.ip_idx]); // +c-7/06

	else           /* Character mode */
		i = i +
				(io_dce_rx_rptr == io_dce_rx_wptr) +
				(io_dce_tx_rptr == io_dce_tx_wptr);

	if (i != 4)   /* Any buffer not empty? */
		ip.modem_status = ip.modem_status & ~BUFFERS_EMPTY;

	else
	{
		ip.modem_status = ip.modem_status | BUFFERS_EMPTY;

		if (ip_next_mode != 0xFF)   /* Mode change? */
		{
			ip_mode = ip_next_mode;  /* Update mode to new value */

			if (ip_mode)             /* PPP or SLIP? */
				split_bufr ();        /* Split the DTE buffers */

			else                     /* Character mode */
				use_full_bufr ();     /* Use complete DTE buffer for ISRs */

			ip_next_mode = 0xFF;     /* Indicate no new mode */
			m2h_state = 0;           // Reset the Rx state machine
			h2m_state = 0;           // Reset the Tx state machine
		}
	}
}

/****************************************************************/
/*            FUNCTIONS TO IMPLEMENT GATEWAY COMMANDS           */
/****************************************************************/

/* ----------------------------------------------- */
/* Select PPP, SLIP or character transmission mode */
/* ----------------------------------------------- */
/*
	 Valid mode: 0 -- Character mode (default)
					 1 -- Synchronous PPP  (not implemented)
					 2 -- Asynchronous PPP
					 3 -- SLIP
*/

byte ppp_on_off (val)
byte val;
{
	if (val > 3)              /* Valid mode? */
		return (1);             /* Indicate error to calling function */

	ip_next_mode = val;       /* Save pending mode change */
	return (0);               /* Update error variable in calling function */
}

/* --------------------------------------------------------- */
/* Load a new Tx/Rx Asyncronous Control-Character Map (ACCM) */
/* --------------------------------------------------------- */

byte load_accm (len, dest)
byte len, dest;
{
	byte i;
	byte *ptr;

	if (len != 5)                             /* Invalid length? */
		return (1);                            /* Indicate error to calling function */

	else                                      /* Valid length */
	{
		if (dest)                              /* Tx ACCM? */
		{
			if (h2m_state)                      /* Sending a frame? */
			{
				ptr = (byte*) &tx_accm.new_map;  /* Point to Tx ACCM temporary storage */
				tx_accm.flag = 0xFF;             /* Indicate new Tx ACCM map */
			}

			else
				ptr = (byte*) &tx_accm.cur_map;  /* Point to current Tx ACCM map */
		}

		else                                   /* Rx ACCM */
		{
			if (m2h_state == 1)                 /* Receiving a frame? */
			{
				ptr = (byte*) &rx_accm.new_map;  /* Point to Rx ACCM temporary storage  */
				rx_accm.flag = 0xFF;             /* Indicate new Rx ACCM map */
			}

			else                                /* Not receiving a frame */
				ptr = (byte*) &rx_accm.cur_map;  /* Point to current Rx ACCM map */
		}

		for (i = 0; i < 4; i++)
			ptr[i] = *(CMD_TO_M++);             /* Copy new map to destination */

		return (0);
	}
}
#endif   /* IPGATEWAY */
