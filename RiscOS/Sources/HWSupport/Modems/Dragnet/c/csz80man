/*name and version number:@(#)csz80man.c	1.20*/
/*date of get: 		  11/06/00 11:32:26*/
/*date of delta:	  11/03/00 11:05:02*/
/****************************************************************
File :	z80main.c
Description :
	Contains the z80 main function.
	Also the uart mimic functions and the mimic interrupt handler.
	Some MIMIC handlers moved to cstartup.asm

Procedures Contained :
	main

Revision History :
	Initials	Date		Change
	VR     		10/12/93	Initial
	M. Begi		01/23/97	Central Site Initial
*****************************************************************/
#if defined(MODEM_Z80)
//#define x_debug_msg(x) (ddputs_24l(x))
#endif

#include	"llglob_d.h"
#include	"iouart_d.h"
#include	"ioglob_d.h"
#include	"z80glob.h"
#include    "dpglob.h"

extern void dp_task ( MODEM_COMMAND, byte *, word ) ;
extern void io_task ( MODEM_COMMAND, byte *, word ) ;
extern byte dumbPortPresent;
extern byte XOFFchar ;
non_banked void z80_pc_flow_control (void);  // +c-6/19

sfr bank_port=0x39;

#if defined( VENUS_FLASH )
extern non_banked void z80_enable_int0 ( void ) ;
extern non_banked void z80_disable_int0 ( void ) ;
#else
#define	 z80_enable_int0()
#define	 z80_disable_int0()
#endif

#if defined(CS_MODEM)
#include    "csglob.h"
#ifdef IPGATEWAY
	#include "ipgw.h"
	static word rx_isr_tmr;   // +c2:
  static byte tto_state;    // +c-6/19
  static byte tto_flag;     // +c-6/19
  static word tto_timer;    // +c-6/19
#endif

#ifdef CS_DEBUG
 #include "csz80man.h"
#endif
#include "allglobs.h"

byte io_h2m_cmd_detected ; 
byte io_h2m_ack_detected ; 
byte mcr_image ; 
#endif

#if defined(PCMCIA_MODEM)
//---------------------------------------------------------------
//					PCMCIA
//---------------------------------------------------------------
//-----------------------------------
//		PCMCIA variables
//-----------------------------------
//
byte last_mimic_cor ;
byte last_mimic_fcsr ;
byte last_mimic_prr ;
byte last_mimic_baselo ;
byte last_mimic_basehi ;
#if defined(MULTI_FUNCTION)
byte	last_rmp_cor;
byte	last_rmp_fcsr;
byte	last_rmp_prr;
#endif
//
//---------------------------------------------------------------
//				END PCMCIA variables
//---------------------------------------------------------------
#endif

extern non_banked void	mimic_thr_or_tto_int (void) ;
extern non_banked void	mimic_rbr_int (void) ;

//==========================================================================
//					Globals
//==========================================================================
byte	uart_baud_reg ;
byte	uart_fcr_reg ;
byte	uart_ie_reg ;
byte	uart_lcr_reg ;
byte	uart_mcr_reg ;
byte	last_mcr_reg ;


byte	uart_tx_count;
#if !defined(CS_MODEM)
byte	z80_sw_flow_on;
#endif

typedef enum
{
	FC_OFF,
	FC_OFF_TO_ON,	// software flow control only
	FC_ON
} FLOW_CONTROL;		// DO NOT add any new states without careful review!!!
FLOW_CONTROL uart_flow_control;

extern byte *io_esc_dte_wptr ;

/****************************************************************
	Function : timer interrupt - set for 20 msec intervals

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void prt0ir ( void )
{
	x_timer = x_timer + 1 ;		// 1 msec 

#if defined( WATCHDOG_TIMER )
	// strobe sanity timer
	output8( 0xda, 0x1f ) ;
	output8( 0xdb, 0xe5 ) ;
#endif

	// clear interrupt
	input8( TCR );			//read timer 0 control register - reset timers
	input8( TMDR0L );		//read timer 0 data register low
}

#if defined( PCMCIA_MODEM )
/****************************************************************
	Function : attribute Memory Access interrupt

		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked
interrupt void attmaccir ( void )
{
	//------------------------------
	// Disable Attmem access interupts
	//------------------------------
	DP_REGWRITE( 0x56, 0 ) ;

	//-------------------------------------------------------
	// this routine doesn't have to do much for it is only a
	// target for sleep revival.
	//-------------------------------------------------------
	sendDumbChar( 'A' ) ;
}
#endif

/*****************************************************************
	Function : venus_wake_from_sleep
	Wake up from sleep for Venus.
******************************************************************/
non_banked void venus_wake_from_sleep(void)
{
	// restore CPUSTOP & clk divisors
	output8 ( CKSRC, input8 ( CKSRC ) & 0xD8 ) ;
	// restore codec & bamil clocks 
	dp_regwrite ( 0xcb, 0x00 ) ;// and crystal oscillator 
	Oscr_delay () ;				// allow to stabilize

	output8 ( IOBRG, input8 ( IOBRG ) | 0x01 );	// restore MIM_TCLK
	// EASCI is permanently killed, RMP is permanently enabled
	output8 ( IOCR, (input8 ( IOCR ) & 0x20) | 0x20 ); // restore PRT,RMP,DMAC
//	output8 ( IOCR, input8 ( IOCR ) & 0x00 ); 	// restore EASCI,PRT,RMP,DMAC
	output8 ( CKSRC, input8 ( CKSRC ) & 0xF7 );	// switch to crystal osc.

//	disable_interrupt () ;
	output8 ( TCR, input8 ( TCR ) | 0x10 ) ; // enable Timer0 interrupt
	output8 ( TCR, input8 ( TCR ) | TCR_TDE0_BIT ) ; // start Timer0
	enable_interrupt () ;

	dp_venus_wakeup();
}

/*****************************************************************
	Function : x_sleep_mode
	Put the uC into sleep mode.
******************************************************************/
non_banked byte x_sleep_mode ( void )
{
	extern byte dp_count ;
	extern void dp_reset_venus(void);

	sendDumbChar( 'S' ) ;

//	dp_reset_venus();	// When this is here, seems to cause lockups

	disable_interrupt () ;
		// Can we go to sleep ?
		if ( dp_ring_int || (io_dte_rx_wptr != io_dte_rx_rptr) )
		{
			// No...
			enable_interrupt () ;
			if ( dp_ring_int )
			{
				ddputs_nnl( "Ring Active" );
			}
			else
			{
				ddputs_nnl( " Incoming chars..." );
			}
			ddputs_nnl( " w \n\r" );
			return TRUE ;
		}

#if defined( Z80_MIMIC_DMA )
		//----------------------------------------------
		// If we still have more to send to the host but
		// they have gone away (Toshiba Techra does this
		// when you close Hyperterm) then clear the DMA
		// channel and go to sleep.
		//----------------------------------------------
		if ( !z80_no_more_tx && !(uart_mcr_reg & BIT0) )
		{
			extern void init_z80_DMA ( void ) ;

			init_z80_DMA() ;
			z80_no_more_tx = TRUE ;
			ddputs_nnl( "Clearing DMA\n\r" );
		}
#endif

		//------------------------------
		// Place Datapump in sleep mode
		//------------------------------
		dp_state = DP_WAIT_FOR_RING ;
		dp_count = 0 ;
		dp_calling_tone_disable = FALSE ;
		dp_sleep_mode (1) ;

#if defined( PCMCIA_MODEM )
		//----------------------------------------------
		// Enable all Attribute Memory Access interupts
		//----------------------------------------------
		DP_REGWRITE( 0x56, BIT3|BIT2|BIT1|BIT0 ) ;
#endif
		//---------------------------------------------
		// stop Timer0 and disable Timer0 interrupt
		//---------------------------------------------
		output8 ( TCR, input8 ( TCR ) & ~TCR_TDE0_BIT ) ;
		output8 ( TCR, input8 ( TCR ) & 0xEF ) ;

	enable_interrupt () ;
	sleep () ;					// put Zinger into sleep mode
	disable_interrupt () ;

		//---------------------------------------------
		// enable Timer0 interrupt and start Timer0
		//---------------------------------------------
		output8 ( TCR, input8 ( TCR ) | 0x10 ) ;
		output8 ( TCR, input8 ( TCR ) | TCR_TDE0_BIT ) ;

#if defined( PCMCIA_MODEM )
		//----------------------------------------------
		// Disable all Attribute Memory Access interupts
		//----------------------------------------------
//		DP_REGWRITE( 0x56, 0 ) ;
		DP_REGWRITE( 0x56, BIT3 ) ;
#endif
		// restore CPUSTOP & clk divisors
		output8 ( CKSRC, input8 ( CKSRC ) & 0xD8 ) ;
		// restore codec & bamil clocks 
		dp_regwrite ( 0xcb, 0x00 ) ;// and crystal oscillator 
		Oscr_delay () ;				// allow to stabilize

		output8 ( IOBRG, input8 ( IOBRG ) | 0x01 ) ;	// restore MIM_TCLK
		// EASCI is permanently killed, RMP is permanently enabled
		output8 ( IOCR, (input8 ( IOCR ) & 0x20) | 0x20 ); // restore PRT,RMP,DMAC
//		output8 ( IOCR, input8 ( IOCR ) & 0x00 ) ; 	// restore EASCI,PRT,RMP,DMAC
		output8 ( CKSRC, input8 ( CKSRC ) & 0xF7 ) ;	// switch to crystal osc.
	enable_interrupt () ;

	sendDumbChar( 'W' ) ;
	return TRUE ;
}

#ifdef	CORONA
/****************************************************************
	Function	: delay_50ms
	used by the function dsp_reset in module cstartup.asm
*****************************************************************/
non_banked void delay_50ms ( void )
{
	word	reset_delayTmr;

	reset_delayTmr = x_current_time ();
	while ( x_elapsed_time ( reset_delayTmr ) < MS50 );
}	
#endif	//CORONA

/****************************************************************
	Function : z80_flow_on
	used by voice isr in z80dsp.c file 
	we may need to turn cts off during voice block transfer
*****************************************************************/
non_banked void z80_flow_on ( void )
{
}

/****************************************************************
	Function : z80_uart_break_on
*****************************************************************/
non_banked void z80_uart_break_on ( void )
{
		// set break interrupt
	output8 ( MIMIC_LSR, input8 ( MIMIC_LSR ) | 0x10 ) ;
	output8 ( MIMIC_RBR, 0x00 ) ;
}

/****************************************************************
	Function : z80_uart_cts_on
*****************************************************************/
non_banked void z80_uart_cts_on ( void )
{
#if !defined(CS_MODEM)
	// set CTS
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) | 0x10 ) ;
#endif
}

/****************************************************************
	Function : z80_uart_cts_off
*****************************************************************/
non_banked void z80_uart_cts_off ( void )
{
#if !defined(CS_MODEM)
		// clear CTS
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) & 0xEF ) ;
#endif
}

/****************************************************************
	Function : z80_uart_cd_on
*****************************************************************/
non_banked void z80_uart_cd_on ( void )
{
#if !defined(CS_MODEM)
		// set DCD
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) | 0x80 ) ;
#endif
}

/****************************************************************
	Function : z80_uart_cd_off
*****************************************************************/
non_banked void z80_uart_cd_off ( void )
{
#if !defined(CS_MODEM)
		// clear DCD
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) & 0x7F ) ;
#endif
}

/****************************************************************
	Function : z80_uart_ri_on
*****************************************************************/
non_banked void z80_uart_ri_on ( void )
{
#if !defined(CS_MODEM)
	// set RI
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) | 0x40 ) ;
#endif
}

/****************************************************************
	Function : z80_uart_ri_off
*****************************************************************/
non_banked void z80_uart_ri_off ( void )
{
#if !defined(CS_MODEM)
		// clear RI
	output8 ( MIMIC_MSR, input8 ( MIMIC_MSR ) & 0xBF ) ;
#endif
}

/****************************************************************
	Function : z80_dte_rx_count
	return the number of bytes on the dte receive queue
    Note the side effect of setting uart_rx_count.
*****************************************************************/
non_banked void z80_dte_rx_count ( void )
{
	// disable all interrupts - before calculating no of bytes in queue
	disable_interrupt () ;
       // +c2: Begin addition
#ifdef IPGATEWAY
	if (ip_mode)											 // Split buffer for PPP or SLIP?
		uart_rx_count = ip_rx_bytes ();  // Get bytes in ip_dte_rx_buff

	else
#endif
	{    // +c2: End addition
		if ( io_dte_rx_wptr >= io_dte_rx_rptr )
		{
			uart_rx_count = io_dte_rx_wptr - io_dte_rx_rptr ;
		}
		else
		{
			uart_rx_count = (io_dte_rx_eptr - io_dte_rx_rptr)
							 + (io_dte_rx_wptr - io_dte_rx_sptr) ;
		}
	}    // +c2
	enable_interrupt () ;
}

// +c-6/19: Begin addition
#ifdef IPGATEWAY

/**************************************************************
  Function: Unload TxFIFO
***************************************************************/
// NOTE: MIMIC interrupts should be disabled.

non_banked void unload_thr ()
{
  byte *ptr;

  ptr = (byte*) *isr_dte_rx_wptr;

  while ( !(input8 (MIMIC_LSR) & 0x20) )  // Until TxFIFO is empty
  {
    *ptr++ = input8 (MIMIC_THR);

    if (ptr >= (byte*) isr_dte_rx_eptr)
      ptr = (byte*) isr_dte_rx_sptr;

    uart_rx_count++;
  }

  *isr_dte_rx_wptr = ptr;

  if (uart_rx_count > isr_rx_full_count)
  {
    z80_pc_flow_control ();
    output8 (MIMIC_IE, input8 (MIMIC_IE) & 0x9B);  // Disable THR, THO & LCR
  }
}

/*****************************************************************
  Function: Unload TxFIFO when requested by host (Hayes CS I/F)
******************************************************************/

non_banked void mimic_lcr_int ()
{
  input8 (MIMIC_LCR);           // Read and discard LCR register

  if (ip.host_status & 0x01)    // Using "Hayes" CS interface?
  {
    unload_thr ();              // Unload not-full TxFIFO as requested by host
    tto_flag = 0;               // Stop background timer
  }

  output ( MIMIC_LSR, 0x40 ) ;	// line status register - set TEMT
 	output ( MIMIC_IUS, 0x80 ) ;	// clear interrupt source
}

#endif
// +c-6/19: End addition

/****************************************************************
	Function : mimic MCR interrupt
*****************************************************************/
non_banked void mimic_mcr_int ( void )
{
#if defined(CS_MODEM)
	byte cmd_or_ack;
	byte cmd_xor_ack;

	cmd_or_ack = input(MIMIC_MCR);

	cmd_xor_ack = (cmd_or_ack ^ mcr_image);

	if ( cmd_xor_ack & MCR_CMD_INT )	//MCR cmd int
	{
		io_h2m_cmd_detected = TRUE;
		x_debug_msg ("CS - rcvd cmd int");
		cs_debug_liv(CS_RCVD_CMD_INT);
	}

	if ( cmd_xor_ack & MCR_ACK_INT)		//MCR ack int
	{
		if (G(mdm_rdy))
		{
			G(mdm_rdy) = 0;
			*(byte*)0x00020 = 0xFF; // +c-6/19: Restore byte used to signal host
			dp_regwrite(0xDC,0x00);	//Reset BIOC7=0
			dp_regwrite(0xC0,0x20);	//Mux IRQ7 IN, and BIOC7 OUT
			x_debug_msg ("CS - rcvd G(mdm_rdy) ack");
			cs_debug_liv(CS_RCVD_G(mdm_rdy)_ACK);
		}

		io_h2m_ack_detected = TRUE;
		x_debug_msg ("CS - rcvd ack int");
		cs_debug_liv(CS_RCVD_ACK_INT);
	}

#ifdef IPGATEWAY
	if (cmd_xor_ack & MCR_CBA_INT)                          // Host ACK for code byte?
	{
		ip.status = ip.status | SCR_ACK;                     // Signal code byte function

		if (input8 (MIMIC_SCR) >= 0x80)                      // End-of-frame codebyte Acked?
		{
			ip.status = ip.status & ~EOF_ACK_WAIT;            // Clear wait flag

			if (ip.status & MCR_EN_RBR)                       // Enable RBR interrupts after EOF Ack?
				output8 (MIMIC_IE, input8 (MIMIC_IE) | 0x10);  // Unmask RBR Interrupts
		}                                                    

		load_scr ();											        // Send another code byte if queued
	}
#endif

	mcr_image = cmd_or_ack;
	output ( MIMIC_LSR, 0x40 ) ;	// line status register - set TEMT
	output ( MIMIC_IUS, 0x80 ) ;	// clear interrupt source

#else
	input ( MIMIC_MCR ) ;	// read modem control register
	if ( io_uart_status & UART_CD_ON )
		output ( MIMIC_MSR, 0xB0 ) ;	// set DSR & CTS & DCD
	else
		output ( MIMIC_MSR, 0x30 ) ;	// set DSR & CTS
#endif
}

#if !defined(CS_MODEM)
/****************************************************************
	Function : mimic LCR interrupt
*****************************************************************/
non_banked void mimic_lcr_int ( void )
{
	input ( MIMIC_LCR ) ;	// read line control register
}

/****************************************************************
	Function : mimic BAUD RATE (DLL/DLM) interrupt
			 : mimic FCR interrupt
*****************************************************************/
non_banked void mimic_fcr_and_baud_int ( void )
{
	word brg ;

	uart_fcr_reg = input ( MIMIC_FCR ) ;	// fifo control register
	uart_tx_count = 1 ;
	if ( uart_fcr_reg & 0x01 )      	// if fifo mode enabled
	{
		uart_fcr_reg = uart_fcr_reg & 0xC0 ;	// receive trigger level
		if ( uart_fcr_reg == 0xC0 )
			uart_tx_count = 14 ;
		else if ( uart_fcr_reg == 0x80 )
			uart_tx_count = 8 ;
		else if ( uart_fcr_reg == 0x40 )
			uart_tx_count = 4 ;
	}

	uart_baud_reg = input ( MIMIC_LS ) ;	// read divisor latch LS - DLL
	// Windows puts the mimic in non-fifo mode if dte rate <= 2400
	// - we need to transmit only 1 byte at a time to the dte
	if ( uart_baud_reg >= 23 ) 		// all dte rates below 4800
		uart_tx_count = 1 ;

	// if modem is in voice mode - set to 115K dte rate for dle shielded 
	// voice samples thru the comm port
	if ( x_modem_mode == MODEM_VOICE )
		uart_baud_reg = 1 ;	// 115200

	// set up the baud rate registers based on the dte rate
	switch ( uart_baud_reg )
	{
		case 1 :
		default :
			brg = 0x20 ;	// 115200
			S.ModemOptions.DteRate = DTE_115200 ;
			break ;
		case 2 :
			brg = 0x40 ;	// 57600
			S.ModemOptions.DteRate = DTE_57600 ;
			break ;
		case 3 :
			brg = 0x70 ;	// 38400
			S.ModemOptions.DteRate = DTE_38400 ;
			break ;
		case 6 :
			brg = 0x80 ;	// 19200
			S.ModemOptions.DteRate = DTE_19200 ;
			break ;
		case 12 :
			brg = 0x100 ;	// 9600
			S.ModemOptions.DteRate = DTE_9600 ;
			break ;
		case 24 :
			brg = 0x200 ;	// 4800
			S.ModemOptions.DteRate = DTE_4800 ;
			break ;
		case 48 :
			brg = 0x400 ;	// 2400
			S.ModemOptions.DteRate = DTE_2400 ;
			break ;
		case 96 :
			brg = 0x800 ;	// 1200
			S.ModemOptions.DteRate = DTE_1200 ;
			break ;
		case 192 :
			brg = 0x1000 ;	// 600
			S.ModemOptions.DteRate = DTE_600 ;
			break ;
		case 128 :
			brg = 0x2000 ;	// 300
			S.ModemOptions.DteRate = DTE_300 ;
			break ;
		case 23 :
			brg = 0x4000 ;	// 110
			S.ModemOptions.DteRate = DTE_110 ;
			break ;
	}

#ifdef Z182
	// Baud Rate Generator on the SCC
	output ( 0xE2, 0x0c ) ;		// select reg. 12 - timer low
	output ( 0xE2, (byte) brg ) ;		// 		time constant
	output ( 0xE2, 0x0d ) ;		// select reg. 13 - timer high
	output ( 0xE2, (byte) ((word)(brg >> 8)) ) ;	// 	time constant
#endif
	// Baud Rate Generator for the Z80187
	output ( 0xE0, (byte) brg ) ;		// 		time constant low
	output ( 0xE1, (byte) ((word)(brg >> 8)) ) ;	// 	time constant high

	uart_baud_reg = input ( MIMIC_MS ) ;	// read divisor latch MS - DLM
}
#endif// !defined(CS_MODEM)

/****************************************************************
	Function : mimic interrupt
*****************************************************************/
#if !defined(CS_MODEM)
non_banked void mimic_int ( void )
{
	// read IUS Register - interrupt source
	// dte receive data - THR (or) TTO interrupt
	if ( input ( MIMIC_IUS ) & 0x60 )
		mimic_thr_or_tto_int () ;

	// dte transmit data - RBR interrupt
	if ( input ( MIMIC_IUS ) & 0x10 )
		mimic_rbr_int () ;

	// modem control register - MCR interrupt
	if ( input ( MIMIC_IUS ) & 0x08 )
		mimic_mcr_int () ;

	// line control register - LCR interrupt
	if ( input ( MIMIC_IUS ) & 0x04 )
		mimic_lcr_int () ;

	// DLL/DLM baud rate interrupt
	// fifo control register - FCR interrupt
	if ( input ( MIMIC_IUS ) & 0x03 )
		mimic_fcr_and_baud_int () ;

	output ( MIMIC_LSR, 0x40 ) ;	// line status register - set TEMT
	output ( MIMIC_IUS, 0x80 ) ;	// clear interrupt source
}
#else

non_banked void mimic_int ( void )
{
	byte intId ; 
	byte intPend ;

	// Nested (non-vectored) mimic interrupts 
	do
	{
		intId = input(MIMIC_IUS) ;
		if((intPend = intId & 0x80) == 0 )
			return ;
			
		// read IUS Register - interrupt source
		// Transmit data from host - THR (or) TTO interrupt
		if ( intId & 0x60 )
    {                            // +c-6/19
			mimic_thr_or_tto_int () ;
#ifdef IPGATEWAY                 // +c-6/19
      tto_flag = 0;              // +c-6/19: Stop background timer
#endif                           // +c-6/19
    }                            // +c-6/19

		// Receiver ready from host - RBR interrupt
		else if ( intId & 0x10 )
			mimic_rbr_int () ;

		// cmd and ack interrupts - MCR interrupt
		else if ( intId & 0x08 )
			mimic_mcr_int () ;

// +c-6/19: Begin addition
#ifdef IPGATEWAY
   
    else if (intId & 0x04)  // Host indicated partial TxFIFO (Hayes CS Interface)?
      mimic_lcr_int ();

#endif
// +c-6/19: End addition

	} while (intPend);		//redo if there's pending ints

}
#endif


/****************************************************************
	Function : z80_flow_off
	Allow the host to send again
*****************************************************************/
non_banked void z80_flow_off ( void )
{
#if defined(CS_MODEM)
	uart_flow_control = FC_OFF ;
#else
	if ( S.ModemOptions.FlowControl == NO_FLOWCTRL )
	{
		return ;
	}
	uart_flow_control = FC_OFF ;
	if ( S.ModemOptions.FlowControl == SW_FLOWCTRL )
	{
		io_put_dte_tx_char ( 0x11 ) ;	// XON host
		sendDumbChar( 'X' ) ;
	}
	else // if ( S.ModemOptions.FlowControl == HW_FLOWCTRL )
	{
		z80_uart_cts_on () ;
		//sendDumbChar( 'C' ) ;
	}
#if defined(UART_DEBUG_PRINT)
	if ( dumbPortPresent )
	{
		output8 ( DUMB_MCR, input8 ( DUMB_MCR ) | BIT3 ) ;
	}
#endif
#endif
}

/****************************************************************
	Function : z80_pc_flow_control
	Flow control to the pc - called from THR interrupt 
	Turn Off Cts or send xoff to the PC
        
		CALLED WITH INTERRUPTS DISABLED!
*****************************************************************/
non_banked void z80_pc_flow_control ( void )
{
	{
#if defined(CS_MODEM)
		uart_flow_control = FC_ON ;
#else
		if ( S.ModemOptions.FlowControl == HW_FLOWCTRL )
		{
			uart_flow_control = FC_ON ;
			z80_uart_cts_off() ;
			//sendDumbChar( 'c' ) ;
		}
		else if ( S.ModemOptions.FlowControl == SW_FLOWCTRL )
		{
#if defined( Z80_MIMIC_DMA )
			//-------------------------------------------------
			// send xoff to the pc using ch1 DMA
			//-------------------------------------------------
			if ( z80_no_more_tx )
			{
				z80_no_more_tx = FALSE ;
				z80_SendXOFF() ;
			}
			else
			{
				sendAnXOFF = TRUE ;
				sendDumbChar( '.' ) ;
			}
			uart_flow_control = FC_ON ;
#else
			// send xoff to the pc - later in the background
			uart_flow_control = FC_OFF_TO_ON ;
#endif
			sendDumbChar( 'x' ) ;
		}
#if defined(UART_DEBUG_PRINT)
		if ( dumbPortPresent )
		{
			output8 ( DUMB_MCR, input8 ( DUMB_MCR ) & ~BIT3 );
		}
#endif
#endif		// CS_MODEM
	}
}

#if defined(PCMCIA_MODEM)
/****************************************************************
	Function : COR_update
	Device Configuration Option Register has been updated
*****************************************************************/
non_banked void COR_update ( byte device, byte cor )
{
	static byte index ;
	byte prr, bafcr ;
	word baddr, rst_timer ;

	// was it a device reset?
	if ( cor & COR_SRESET_BIT )
	{
		// Yes - device has been reset!!
		// wait for host to clear this bit..
		rst_timer = x_current_time () ;
		while ( (cor & COR_SRESET_BIT) &&
				(x_elapsed_time(rst_timer) <= 30) )
		{
			cor = CAMILZ_REGREAD( device ) ;
		}
		// ..and pull the plug
		// reset VENUS - NOT device!!!
		ddputs( "*** RESET ****" ) ;
		sendDumbChar(0x0A); sendDumbChar(0x0D);
		CAMILZ_REGWRITE( 0x57, 2 ) ;
		// should not get here
	}

	// get the index to the CIS config table entry and
	// program the I/O Base address.
	index = (cor & COR_INDEX_BITS) >> 3 ;
	switch ( device )
	{
		case 0x40:	// MIMIC
			bafcr = 0xc3 ;
			break ;
#if defined( MULTI_FUNCTION )
		case 0x43:	// RMP
			ddputs_nnl("RMP");
			index |= 0x10 ;
			bafcr = 0xc5 ;
			break ;
		default :
			ddputs_nnl("????");
#endif
	}
	ddputs_nnl( " index = " ) ; sendHexByte( index ) ;

	baddr =  z80_base_adr ( index ) ;
	CAMILZ_REGWRITE( bafcr,   (byte)baddr ) ;
	CAMILZ_REGWRITE( bafcr+1, (byte)(baddr >> 8) ) ;

	ddputs_nnl( "; LO = " ) ;
	sendHexByte( (byte)baddr ) ;
	ddputs_nnl( "; HI = " ) ;
	sendHexByte( (byte)(baddr >> 8) ) ;
	sendDumbChar(0x0A); sendDumbChar(0x0D);

	// Set the Pin Replacement Register
	// WP=0, Ready, BVD1=BVD2=1
	// For now, READY is always set.
	prr = 0x0e ;
	CAMILZ_REGWRITE( device+2, prr ) ;

#if defined( MULTI_FUNCTION )
	// If multiple devices are supported on the card
	// then Set the int sharing bits in the FCSR.
	CAMILZ_REGWRITE( device+1, 1 ) ;
#endif

	ddputs_nnl( "COR = " ) ; sendHexByte( cor ) ;
	sendDumbChar(0x0A); sendDumbChar(0x0D);
}

/****************************************************************
	Function : FCSR_update
	Device Configuration Option Register has been updated
*****************************************************************/
non_banked void FCSR_update ( byte device, byte fcsr )
{
	//--------------------------------------------------------------------
	//		Function Cofiguration & Status Register
	//--------------------------------------------------------------------
	// Report function for now.
	// Bits of concern in this register include:
	//	bit0:	IntrAck	- Set to 1 for interrupt sharing on MF PC Cards.
	//					  (done in COR_update).
	//	bit1:	Intr	- Interrupt pending bit (cleared by interrupting
	//					  HW in SF; host in MF).
	//	bit2:	PwrDown	- Set by host when a power down mode is desired.
	//	bit3:	Audio	- Enables audio output onto pin 62 of PC Card Bus.
	//	bit4:			- Unused
	//	bit5:	IOis8	- Set by host for 8 bit xfers only.
	//	bit6:	SigChg	- Set by host to enable STSCHG# pin on PC Bus.
	//	bit7:	Changed	- Set by HW if CREADY in the PRR is set.
	//--------------------------------------------------------------------

	if ( fcsr & (1<<2) )
	{
		ddputs( "Power Down Mode Requested by Host!!" ) ;
	}

	if ( fcsr & (1<<5) )
	{
		ddputs( "Host has 8 bit bus." ) ;
	}

	if ( fcsr & (1<<6) )
	{
		ddputs( "Host has Enable SigChg!" ) ;
	}

	ddputs_nnl( "FCSR = " ) ;
	sendHexByte( fcsr ) ;
	sendDumbChar(0x0A); sendDumbChar(0x0D);
}

non_banked void SaveCOR ( void )
{
	extern byte corFlag ;
	extern byte corValue ;

	ddputs_nnl( "saving COR\n\r" ) ;
	corFlag = 0x55 ;
	corValue = last_mimic_cor ;
}

non_banked void LoadCOR ( void )
{
	extern byte corFlag ;
	extern byte corValue ;

	ddputs_nnl( "corFlag = " ) ;
	sendHexByte( corFlag ) ;
	ddputs_nnl( "; corValue = " ) ;
	sendHexByte( corValue ) ;
	ddputs_nnl( "\n\r" ) ;
	if ( corFlag == 0x55 )
	{
		corValue &= ~COR_SRESET_BIT ;
		DP_REGWRITE( 0x40, corValue ) ;
		DP_REGWRITE( 0x42, 0xee ) ;
		COR_update( 0x40, corValue ) ;
	}
}

/****************************************************************
	Function : Attribute_memory_write
		Process the host Attribute Memory (FCRs and CIS) writes.
*****************************************************************/
non_banked void Attribute_memory_write ( void )
{
	byte camilreg, device ;

	// check the MIMIC COR
	camilreg = CAMILZ_REGREAD( 0x40 ) ;
	if ( last_mimic_cor != camilreg )
	{
		COR_update( 0x40, camilreg ) ;
		last_mimic_cor = camilreg ;
		SaveCOR();
	}

	// check the MIMIC FCSR
	camilreg = CAMILZ_REGREAD( 0x41 ) ;
	if ( last_mimic_fcsr != camilreg )
	{
		FCSR_update( 0x41, camilreg ) ;
		last_mimic_fcsr = camilreg ;
	}

	// check the MIMIC PRR
	camilreg = CAMILZ_REGREAD( 0x42 ) ;
	if ( last_mimic_prr != camilreg )
	{
		ddputs_nnl( "M PRR = " ) ;
		sendHexByte( camilreg ) ;
		ddputs_nnl( "\n\r" ) ;
		last_mimic_prr = camilreg ;
	}

#if defined( MULTI_FUNCTION )
	// check the RMP COR
	camilreg = CAMILZ_REGREAD( 0x43 ) ;
	if ( last_rmp_cor != camilreg )
	{
		COR_update( 0x43, camilreg ) ;
		last_rmp_cor = camilreg ;
	}

	// check the RMP FCSR
	camilreg = CAMILZ_REGREAD( 0x44 ) ;
	if ( last_rmp_fcsr != camilreg )
	{
		FCSR_update( 0x44, camilreg ) ;
		last_rmp_fcsr = camilreg ;
	}

	// check the RMP PRR
	camilreg = CAMILZ_REGREAD( 0x45 ) ;
	if ( last_rmp_prr != camilreg )
	{
		ddputs_nnl( "RMP PRR = " ) ;
		sendHexByte( camilreg ) ;
		sendDumbChar(0x0A); sendDumbChar(0x0D);
		last_rmp_prr = camilreg ;
	}
#endif
}
#endif //defined(PCMCIA_MODEM)

//#if defined(TEST_COMMANDS) && defined(K56FLEX) && defined(MORE_MORE_DEBUG)
#if defined (K56FLEX) || defined (VPCM_CLIENT) || defined (VPCM_SERVER)
#if defined(TEST_COMMANDS) && defined(MORE_MORE_DEBUG)

/****************************************************************
	Function : z80_display_ext_ram
	support routine for z80_memory
*****************************************************************/
non_banked
void z80_display_ext_ram ( byte DestBank, byte max, byte *loc )
{
	byte i, cnt, *bp, data, str[120];
	extern const byte str_convert[] ;
	byte bankvar;
	byte *BankDataPtr;

	for ( i=0, bp=str, cnt=0; i<max; i++, cnt++ )
	{
		if ( !(cnt % 16) )
		{
			*bp++ = S.ModemOptions.CRChar;
			*bp++ = S.ModemOptions.LFChar;
			*bp++ = 0 ;
			ddputs_nnl( str ) ;
			{
				x_send_mail ( AT_IO_DATA, IO_TASK, str, bp - str ) ;
			}
			cnt = 0 ;
			str[0]  = str_convert[  (byte)(((word)loc & 0xF000)>>12) ] ;
			str[1]  = str_convert[  (byte)(((word)loc & 0xF00)>>8) ] ;
			str[2]  = str_convert[  (byte)(((word)loc & 0xF0)>>4) ] ;
			str[3]  = str_convert[  (byte)((word)loc & 0xF) ] ;
			str[4]  = ':' ;
			str[5]  = ' ' ;
			bp = &str[6] ;
		}
		bankvar = bank_port;	// save old bank pointer
		bank_port=DestBank;
		data =  *loc++ ;
		bank_port = bankvar;		// restore bank pointer		
		*bp++ = str_convert[ ((data>>4) & 0xf) ];
		*bp++ = str_convert[ (data & 0xf) ];
		*bp++ = ' ' ;
	}

	*bp++ = S.ModemOptions.CRChar;
	*bp++ = S.ModemOptions.LFChar;
//#if defined( Z80_DEBUG_PRINT )
	
		*bp++ = 0 ;
		ddputs_nnl( str ) ;
	
	
//#endif
	{
		x_send_mail ( AT_IO_DATA, IO_TASK, str, bp - str ) ;
	}
}
#endif
#endif	// K56FLEX || VPCM_CLIENT || VPCM_SERVER

#if defined(Z80_DEBUG_PRINT)
#if !defined(CS_MODEM)	//jc-5/18/99
/****************************************************************
	Function : ddputs_24_nnl -
		print to debug port the message - no CR/LF appended.
	return last character sent
*****************************************************************/
non_banked byte ddputs_24_nnl(long adr24)
{
	byte *ptr = (byte *) adr24;
	byte bankvar = bank_port;	// save old bank pointer
	byte rv;

	bank_port = adr24 >> 16;	// switch to correct bank

	while (*ptr)
		sendDumbChar(*ptr++);

	rv =*(ptr-1);

	bank_port = bankvar;		// restore bank pointer

	return rv;
}

/****************************************************************
	Function : ddputs_24 - print message, append CR/LF if
		the message doesn't end in an '=' character.
*****************************************************************/
non_banked void ddputs_24(long adr24)
{
	if(ddputs_24_nnl(adr24) != '=')
	{
		sendDumbChar(0x0A); sendDumbChar(0x0D);
	}
}
#endif	// !defined(CS_MODEM)   jc-5/18/99

#if !defined(HOMOL) && !defined(CS_MODEM)
/****************************************************************
	Function : ddgets_24 -
*****************************************************************/
non_banked
void ddgets_24 ( long adr24 )
{
	byte *ptr = (byte *)adr24;	// get loc in bank
	byte bankvar = bank_port;	// save old bank pointer
	byte i ;

	// switch to correct bank
	bank_port = adr24 >> 16;	// switch to correct bank

	for ( i=0; i<32; i++ )
	{
		sendHexByte( *ptr++ ) ;		// print loc
	}

	bank_port = bankvar;		// restore bank pointer

	sendDumbChar(0x0A);
	sendDumbChar(0x0D);
}
#endif
#endif

#if !defined(CS_MODEM)
/****************************************************************
	Function : strputs_24
*****************************************************************/
non_banked
void strputs_24 ( long str )
{
#if defined( Z80_DEBUG_PRINT )
	ddputs_24( str ) ;
#else
	byte i, lclstr[80];
	byte *ptr = (byte *)str;	// get loc in bank
	byte bankvar = bank_port;	// save old bank pointer

	// switch to correct bank
	bank_port = str >> 16;	// switch to correct bank

	// copy string from code bank to ram
	for ( i=0 ; ptr[i] ; i++ )
	{
		lclstr[i] = ptr[i] ;
	}
	lclstr[i] = 0 ;

	bank_port = bankvar;		// restore bank pointer

	x_send_mail ( AT_IO_DATA, IO_TASK, lclstr , i+1 ) ;
#endif
}
#endif	// !defined(CS_MODEM)

#if defined( ROM_FLASH ) && !defined(HOMOL)
/****************************************************************
	Function : z80_sector1 -
*****************************************************************/
non_banked void z80_sector1 ( void )
{
	word data ;
	byte ch ;
	extern word getCheckSum ( void ) ;
	extern word getLastPara ( void ) ;
	extern byte getFirstBank ( void ) ;

	data = getCheckSum () ;
	ddputs_nnl("Chksum="); sendHexWord(data);
	cs_debug_liv(Z80_SECTOR1_CHKSUM);
	cs_debug_liv(data | 0x2000);
	sendDumbChar(0x0A); sendDumbChar(0x0D);

	data = getLastPara () ;
	ddputs_nnl("Lst Para="); sendHexWord(data);
	cs_debug_liv(Z80_SECTOR1_LST_PARA);
	cs_debug_liv(data | 0x2000);
	sendDumbChar(0x0A); sendDumbChar(0x0D);

	ch = getFirstBank () ;
	ddputs_nnl("First Bank="); sendHexByte(ch);
	cs_debug_liv(FIRST_BANK);
	cs_debug_liv((word)ch | 0x2000);
	sendDumbChar(0x0A); sendDumbChar(0x0D);
}
#endif

extern void init_z80_hardware(void);
extern void mimic_control_registers(void);
extern void z80_init_dtr ( void );

#if defined( PCMCIA_MODEM ) && defined( DIA_MODE )

BOOL RMPFlag ;

non_banked
void rmpCapture ( void )
{
	byte reg ;

	ddputs_nnl( "Switching MIMIC port to RMP\n\r" ) ;

	//--------------------------------------------
	// read the MIMIC Base Address register
	// and write it to the RMP BAR.
	//--------------------------------------------
	reg = CAMILZ_REGREAD( 0xc3 ) ;
	CAMILZ_REGWRITE( 0xc5, reg ) ;
	reg = CAMILZ_REGREAD( 0xc4 ) ;
	CAMILZ_REGWRITE( 0xc6, reg ) ;

	//--------------------------------------------
	// read the MIMIC FCRs
	// and write to RMP FCRs
	//--------------------------------------------
	reg = CAMILZ_REGREAD( 0x40 ) ;
	CAMILZ_REGWRITE( 0x43, reg ) ;
	reg = CAMILZ_REGREAD( 0x41 ) ;
	CAMILZ_REGWRITE( 0x44, reg ) ;
	reg = CAMILZ_REGREAD( 0x42 ) ;
	CAMILZ_REGWRITE( 0x45, reg ) ;

	//--------------------------------------------
	// clear the MIMIC FCRs
	//--------------------------------------------
	CAMILZ_REGWRITE( 0x40, 0 ) ;
	CAMILZ_REGWRITE( 0x41, 0 ) ;
	CAMILZ_REGWRITE( 0x42, 0 ) ;

	//--------------------------------------------
	// Now clear the MIMIC Base Address register
	//--------------------------------------------
	CAMILZ_REGWRITE( 0xc3, 0 ) ;
	CAMILZ_REGWRITE( 0xc4, 0 ) ;
}
#endif

/****************************************************************
	Function : Main
*****************************************************************/
non_banked void main ( void )
{
	word i;

#if defined(PCMCIA_MODEM)
	// init FCR register vars
	last_mimic_cor = 0 ;
	last_mimic_fcsr = 0 ;
	last_mimic_prr = 0 ;
	last_mimic_baselo = 0 ;
	last_mimic_basehi = 0 ;
#endif
	// init variables
#if defined(CS_MODEM)
	uart_tx_count = 30 ; 		// mimic - dte transmit data count=30 for CSM
//	mcr_image = 0;                  // -c
	mcr_image = input(MIMIC_MCR);   // +c: Initialize with actual contents
#else
	uart_tx_count = 1 ; 		// mimic - dte transmit data count
#endif
	uart_rx_count = 0 ;    		// mimic - dte receive data count
	uart_fcr_reg = 0 ;  		// init uart mimic registers
	uart_baud_reg = 0 ; 
	uart_mcr_reg = 0 ;
	uart_lcr_reg = 0 ;
	uart_flow_control = FC_OFF ;

	enableDumbPort();

#if defined(PCMCIA_MODEM)
	ddputs_nnl( "CIS init\n\r" ) ;
	z80_cis_load() ;
	LoadCOR();
#endif

	// This is here as a result of the CNTL-ALT-DEL
	// problem with certain BIOS's that caused us to
	// reset in Plug and Play mode
	//venus_wake_from_sleep() to be inserted here (if necessary)

	ddputs_nnl( "HW init\n\r" ) ;
	cs_debug_liv(HW_INIT);
	init_z80_hardware () ;		      // init Z80 peripheral's

#if !defined( ROM_FLASH ) && defined( ROM )
	if ( z80_checksum ( FALSE ) == FALSE )	// rom checksum test
	{
		ddputs_nnl( "ROM Failure\n\r" ) ;
		cs_debug_liv(ROM_FAILURE);
 #if defined(CS_MODEM)
    *(byte*)0x00020 = 0xCC;          // +c-6/22: Indicate checksum failure to polling host
  	fatal_error ( "Rom Failure" ) ;  // +c-6/22: Add back in
 #endif
	}
#endif

#if defined(CS_MODEM)
#if	defined(CS_ENABLE_DEBUG_LOGGING)
	// reset dbg cmd buffer and setup it's ptr.
	cs_reset_dp_cmd_buffer ();		
#endif	//CS_ENABLE_DEBUG_LOGGING
#endif

#ifdef CS_STARTUP_DELAY
			x_sleep(STARTUP_DELAY);		
#endif
	ddputs_nnl( "UART_init\n\r" ) ;
	if ( UART_init () == FAILED )           // init modem task - variables
	{
		ddputs("DataPump Failure\n");
  #ifdef CS_MODEM                    // +c-6/22
	 *(byte*)0x00020 = 0xDD;          // +c-6/22: Indicate DSP failure to polling host
  #endif                             // +c-6/22
		fatal_error ( "Data Pump Failure" ) ;
	}

#if defined(CS_MODEM)
	cs_init();	
#endif

#if defined(K56FLEX)
	dp_dsp_int_regwrite(8, 0x0042);		// VPCM/K56
	dp_dsp_int_regwrite(1, 0x6800);		// IOC register
#endif //K56FLEX

#if !defined(CS_MODEM)
	z80_init_dtr();
#endif

#ifdef IPGATEWAY						//ky+ 091498
  tto_state = 0;     // +c-6/19
#endif									//ky+ 091498

	while ( 1 )           		      // forever loop
	{
		// call the modem background tasks
		// {send mail to} execute periodic routines
		// (for all but VENUS_FLASH, disable/enable
		//  int0 are NULL macros)
		z80_disable_int0();
			dp_task ( MC_PERIODIC, NULL, 0 ) ;
		z80_enable_int0();

		z80_disable_int0();
			io_task ( MC_PERIODIC, NULL, 0 ) ;
		z80_enable_int0();

// +c-6/15: Begin addition

#ifdef IPGATEWAY
// ********************************************************
// Background processing for "Hayes" CS I/F, TxFIFO Timeout
// ********************************************************

	 if (ip.host_status & 0x01)   // Using the "Hayes" CS interface?
    {
		if (uart_flow_control != FC_OFF)  // Flow control ON?
        tto_state = 2;                  // Set state machine to wait for FC_OFF

      switch (tto_state)
      {
        case 0:  // Check if TxFIFO is NOT empty
          if (!(input8 (MIMIC_LSR) & 0x20))// TxFIFO not empty?
          {
            tto_state++;                   // Set state to check timeout timer
            tto_flag = 1;                  // Indicate timer is active
            tto_timer = x_current_time (); // Start timer
          }

          break;

        case 1:  // Check if S/W TxFIFO timeout timer expired
          if (tto_flag)                    // Timer still active (cleared in mimic_lcr_int ())
          {
            if (x_elapsed_time (tto_timer) > 10)  // Not empty for 10 ms?
            {
              disable_interrupt ();                          // MIMIC BUG WORKAROUND!
              output8 (MIMIC_IE, input8 (MIMIC_IE) & 0x9B);  // Disable all THR interrupts
              enable_interrupt ();                           // MIMIC BUG WORKAROUND!
              unload_thr ();                                 // Empty partial TxFIFO
              tto_state = 0;                                 // Reset background task
              // MIMIC interrupts are set below
            }
          }

          else  // TxFIFO serviced by TxFIFO Full or LCR ISR
            tto_state = 0;                 // Reset background task

          break;

        case 2:  // Wait for flow control to go off
          if (uart_flow_control == FC_OFF) // Flow control off?
            tto_state = 0;                 // Reset background task

          break;

        default:
			 tto_state = 0;   // Reset background task
      }
	 }

#endif

// +c-6/19: End addition

		//---------------------------------------------------
		// START UART MIMIC PROCESSING
		//---------------------------------------------------

		//---------------------------------------------------
		// set software flow control - used in cstartup.asm
		// see mimic thr interrupt
		//---------------------------------------------------
#if !defined(CS_MODEM)
		if ( (S.ModemOptions.FlowControl == SW_FLOWCTRL) &&
		 	 (x_modem_mode == MODEM_DATA) &&
			 (x_modem_state == MS_ON_DIAL) &&
			 (io_at_esc_detect == FALSE) )
		{
#if defined( Z80_DEBUG_PRINT )
			if ( !z80_sw_flow_on )
			{
				sendDumbChar(0x0A); sendDumbChar(0x0D);
				ddputs_nnl("Entering SW FC");
				sendDumbChar(0x0A); sendDumbChar(0x0D);
			}
#endif
			z80_sw_flow_on = TRUE ;
		}
		else
		{
#if defined( Z80_DEBUG_PRINT )
			if ( z80_sw_flow_on )
			{
				sendDumbChar(0x0A); sendDumbChar(0x0D);
				ddputs_nnl("Exiting SW FC");
				sendDumbChar(0x0A); sendDumbChar(0x0D);
			}
#endif
			z80_sw_flow_on = FALSE ;
			xof_from_dte_rcvd = FALSE ;
		}
#endif

		z80_dte_rx_count() ;
		if ( uart_flow_control == FC_OFF )
		{
			// set mimic interrupt enable register
			uart_ie_reg = MIMIC_THR_ENABLE | MIMIC_MCR_ENABLE;

//+c-6/19: Begin addition
#ifdef IPGATEWAY

      if (ip.host_status & 0x01)  // Using Hayes CS interface?
      {
        uart_ie_reg = uart_ie_reg & ~0x20;  // Don't enable THO
        uart_ie_reg = uart_ie_reg |  0x04;  // +c-6/15: Enable LCR interrupts
      }

#endif
//+c-6/19: End addition

		}

		else
		{

#if !defined(CS_MODEM)
			uart_ie_reg = 0 ;

			if ( uart_flow_control == FC_OFF_TO_ON )
			{
				// Too many chars rcvd from host - apply back pressure
				// in the form of an XOFF (we are in software flow control).
				io_put_dte_tx_char ( XOFF ) ; 	// XOFF to host - 0x13
				uart_flow_control = FC_ON ;
			}
			// Assertion => uart_flow_control = FC_ON
			else if ( uart_rx_count <= IO_DTE_RX_BUFF_EMPTY )
#else
				uart_ie_reg = 0x88 ;	//CSM keep MCR enabled
	#ifndef IPGATEWAY
			if ( uart_rx_count <= IO_DTE_RX_BUFF_EMPTY )
	#else
			if ( uart_rx_count <= isr_rx_empty_count)
	#endif
#endif
			{
				// IF the DTE IS currently being back pressured AND
				// we now have room in our input buffer THEN undo it!!!
				z80_flow_off();
				uart_ie_reg = MIMIC_THR_ENABLE ;

#ifdef IPGATEWAY
			  if (ip.host_status & 0x01)  // Using Hayes CS interface?
			  {
				 uart_ie_reg = uart_ie_reg & ~0x20;  // Don't enable THO
				 uart_ie_reg = uart_ie_reg |  0x04;  // +c-6/15: Enable LCR interrupts
			  }
#endif
			}
		}

		// if there is data to transmit to the dte (pc)
		// - enable RBR transmit interrupt
#ifndef IPGATEWAY
		if ( UART_CommReadCount () )
		{
			// enable RBR interrupt
			uart_ie_reg |= MIMIC_RBR_ENABLE ;
		}
#else
	if (!(input8(MIMIC_IE) & 0x10))  // Only when RBR is masked
	{
		if (!ip_mode)    // Character mode?
		{
			word cnt = UART_CommReadCount ();				// Get number of bytes for host

			if (!(ip.host_status & 0x01))             // Not Using Hayes CS interface?
			{
				if (cnt)                               // ANY data for host?
					uart_ie_reg |= MIMIC_RBR_ENABLE ;   // Enable MIMIC RxEmpty interrupts
			}

			else
			{
				switch (rx_isr_state)
				{
					case 0:  // Idle state
						if (cnt)                             // Any data received?
						{
							rx_isr_tmr = x_current_time ();   // Start time-out timer
							rx_isr_state++;
						}

						break;

					case 1:  // Wait for 30 bytes or timeout
						if ( (cnt >= 30) ||				                   // 30 bytes received?
								  (x_elapsed_time (rx_isr_tmr) >= 30) )    // 30 ms since 1st byte?
						{
							ip.status = ip.status | RX_EOF;				  // Have ISR send a EOF code byte
							rx_isr_state--; 										 // Go back to Idle state
							uart_ie_reg |= MIMIC_RBR_ENABLE ;				 // Enable interrupts
						}

						break;

					default:
						rx_isr_state = 0;
				}
			} 
		}

		else if ( !(ip.status & (MCR_EN_RBR+EOF_ACK_WAIT)) )               // PPP/SLIP MODE: Host ACKed EOF?
		{
			if ( (ip_tx_bytes () >= 30) || (dpq.eof & (1 << dpq.isr_idx)) ) // 30 bytes rcvd or End of frame?
				uart_ie_reg |= MIMIC_RBR_ENABLE;
		}
	}
#endif

		// The disable/enable interrupts around this are
		// a workaround for VENUS.  When this write to
		// the MIMIC IE on VENUS is interrupted there's
		// a problem.
		disable_interrupt();
		// write to mimic interrupt enable register
		output8 ( MIMIC_IE, uart_ie_reg ) ;
		enable_interrupt();

		// keep clearing mimic highest interrupt source - work around
		output8 ( MIMIC_IUS, 0x80 ) ;	// clear interrupt source

		// check if any uart mimic control registers changed
#if !defined(CS_MODEM)
		mimic_control_registers () ;
#else
#if !defined(CS_V110)
		cs_bg_routines();	//MSI and Alive-Indicator routines

		// enable data bank interrupts - NCWTB1 & NCRTB1 - data tx & rx
		dp_regwrite ( 0xb6, 0xee ) ;	// enable interrupt bit 0 & 4
#endif	//!defined(CS_V110)
#endif

		// END UART MIMIC PROCESSING

#if defined(PCMCIA_MODEM)
		// process any host attribute memory writes
		Attribute_memory_write( ) ;

#if defined( DIA_MODE )
		// commandeer the MIMC port for RMP
		if ( (RMPFlag == TRUE) && (input8( 0xf7 ) == 0x55) )
		{
			RMPFlag = FALSE ;
			rmpCapture () ;
			disable_interrupt() ;
			while ( TRUE )
			{
#if defined( WATCHDOG_TIMER )
				// strobe sanity timer
				output8( 0xda, 0x1f ) ;
				output8( 0xdb, 0xe5 ) ;
#endif
			}
		}
#endif
#endif
	}
}
