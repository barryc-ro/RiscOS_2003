/*name and version number:@(#)z80util.c	1.119*/
/*date of get: 		  01/12/01 11:49:15*/
/*date of delta:	  01/11/01 14:09:49*/
/****************************************************************
File :	z80util.c
Description :
	Contains z80 utilities for external modem

Procedures Contained :
	read_eeprom
	read_eeprom_pg
	write_eeprom
	write_eeprom_pg
	venus_reg_rd
	venus_reg_wrt
For internal modems:
	mimic_reg_set
	mimic_reg_display

Revision History :
	RWF			11/07/95	initial
	RWF			11/10/95	moved eeprom driver to here
	RWF			11/15/95	added z80_PnP_chksum()
	RWF			17/17/96	added page mode serial eeprom routines.
*****************************************************************/
//#define Z80_DEBUG_THIS_FILE

#include	"llglob_d.h"
#include	"iouart_d.h"
#include	"ioglob_d.h"
#include	"atglob.h"
#include	"dpglob.h"
#include	"z80glob.h"

#if defined( CS_MODEM )
const byte str_convert[] = "0123456789ABCDEF";
#else
extern const byte str_convert[];
#endif

#ifdef CS_DEBUG
 #include "z80util.h"
#endif
#include	"allglobs.h"

#if defined( EEPROM_X24C04 )	// {
/*************************************************************************
	The following routines used read/write data from the X24C0X (EEPROM). 
	First, a start condition needs to be met, then read/write operation 
	and finally stop condition.
*************************************************************************/
extern BOOL write_byte(byte);
extern byte read_byte(BOOL rd_ack, BOOL *ok);

/*************************************************************************
	eeprom_start : generates the eeprom start sequence	
*************************************************************************/
void eeprom_start ()
{
	// start condition
	x_output ( IO_EEPROM_DATA_OUTPUT ) ;	// as output pins for start

	// the data need to be in high state 
	x_output ( IO_EEPROM_DATA_HIGH ) ;

	// the CLK need to be in high state
	x_output ( IO_EEPROM_CLOCK_HIGH ) ;

	// then data goes to low state while CLK=H
	x_output ( IO_EEPROM_DATA_LOW ) ;
	x_output ( IO_EEPROM_CLOCK_LOW ) ;
}

/*************************************************************************
	eeprom_stop : generates the eeprom stop sequence	
*************************************************************************/
void eeprom_stop ()
{
	// stop condition
	x_output ( IO_EEPROM_DATA_OUTPUT ) ;	// as output pins for start

	// the data need to be in low state 
	x_output ( IO_EEPROM_DATA_LOW ) ;

	// the CLK need to be in high state
	x_output ( IO_EEPROM_CLOCK_HIGH ) ;

	// then data goes to high state while CLK=H
	x_output ( IO_EEPROM_DATA_HIGH ) ;
		
	x_output ( IO_EEPROM_CLOCK_LOW ) ;
	x_output ( IO_EEPROM_DATA_INPUT ) ;	// as input pin
}

/*************************************************************************
	eeprom_ack : waits for current write to complete
*************************************************************************/
void eeprom_ack ( byte page )
{
	word current_time ;
	byte ack ;

	current_time = x_current_time () ;
	while ( x_elapsed_time ( current_time ) < 30 )
	{
		eeprom_start();
		write_byte( page ) ;
		x_output ( IO_EEPROM_DATA_HIGH ) ;
		x_output ( IO_EEPROM_DATA_INPUT ) ;
		x_output ( IO_EEPROM_CLOCK_HIGH ) ;
		ack =  x_input( IO_EEPROM_DATA ) ;
		x_output ( IO_EEPROM_CLOCK_LOW ) ;
		eeprom_stop() ;
		if ( ack == 0 )
		{
			// we're done
			break ;
		}
	}
}

#if defined( INT_MODEM )	// {
//---------------------------------------
// See if fugu is using the EPROM by
// looking at the SCR register.
//---------------------------------------
#define FuguUsingEEPROM  (input8(SCR) & 4)

//---------------------------------------
// Wait for the EEPROM to be ready.
// In VENUS PnP the EEPROM is grabbed
// by FUGU Jr. whenever it wants it so
// the controller has to be aware of this
// and wait its turn.
//---------------------------------------
void waitForEEPROM()
{
	word ee_timer;

	if (!FuguUsingEEPROM)
		return;

	x_debug_msg(" FUGU contention with EEPROM... waiting.. ");

	x_sleep(SECOND8);	// Wait to avoid contention

	ee_timer = x_current_time();

	// If there's a contention with FUGU
	// wait 'til there's been at least 10
	// seconds of no FUGU use.
	while ( x_elapsed_time(ee_timer) < SECOND8 )
	{
		if (FuguUsingEEPROM)
		{
			x_sleep(SECOND1);
			ee_timer = x_current_time();
		}
	}

	x_debug_msg(" FUGU is done");
}
#else	// } {
  #define waitForEEPROM() TRUE
  #define FuguUsingEEPROM FALSE
#endif	// } INT_MODEM

/*************************************************************************
	read_byte : reads a byte from eeprom
*************************************************************************/
byte read_byte ( BOOL rd_ack, BOOL *ok )
{
	byte bit_counter = 0 ;
	byte byte_value = 0 ;

	*ok = TRUE;

	if (FuguUsingEEPROM)
	{
		*ok = FALSE;
		return 0;
	}

	// in the next 8 clock cycles data will be read in
	x_output ( IO_EEPROM_DATA_INPUT ) ;	// as input pin
	while ( bit_counter <= 7 )
	{
		byte_value <<= 1 ;
		x_output ( IO_EEPROM_CLOCK_HIGH ) ;
		byte_value |= x_input (IO_EEPROM_DATA) ;
		x_output ( IO_EEPROM_CLOCK_LOW ) ;
		bit_counter++ ;

		if (FuguUsingEEPROM)
		{
			*ok = FALSE;
			return 0;
		}
	}

	if ( rd_ack )
	{
		// read acknowledgement
		x_output ( IO_EEPROM_DATA_LOW ) ;
		x_output ( IO_EEPROM_DATA_OUTPUT ) ;
		x_output ( IO_EEPROM_CLOCK_HIGH ) ;
		x_output ( IO_EEPROM_CLOCK_LOW ) ;
		x_output ( IO_EEPROM_DATA_HIGH ) ;
	}

	if (FuguUsingEEPROM)
		*ok = FALSE;

	return ( byte_value ) ;
}

/*************************************************************************
	write_byte : writes a byte to eeprom 
*************************************************************************/
BOOL write_byte ( byte byte_value )
{
	byte bit_counter = 0 ;

	if (FuguUsingEEPROM)
		return FALSE;

	x_output ( IO_EEPROM_DATA_OUTPUT ) ;	// as output pins for start
	while ( bit_counter < 8 ) 	
	{
		if ( byte_value & (0x01 << (7-bit_counter))) 
			x_output ( IO_EEPROM_DATA_HIGH ) ;
		else
			x_output ( IO_EEPROM_DATA_LOW ) ;
		x_output ( IO_EEPROM_CLOCK_HIGH ) ;
		x_output ( IO_EEPROM_CLOCK_LOW ) ;
		bit_counter++ ;

		if (FuguUsingEEPROM)
			return FALSE;
	}
	x_output ( IO_EEPROM_DATA_HIGH ) ;
	x_output ( IO_EEPROM_DATA_INPUT ) ;	// as input pin to read ack
#ifndef EEPROM_X24C00
	// for EEPROM_X24C02 and EEPROM_X24C04
	// read acknowledgement
	x_output ( IO_EEPROM_CLOCK_HIGH ) ;
	bit_counter = 0 ;
	while ( ( x_input (IO_EEPROM_DATA) == 1) && (bit_counter < 50) )
		bit_counter++ ;
	x_output ( IO_EEPROM_CLOCK_LOW ) ;
#endif
	return !FuguUsingEEPROM;
}


/*************************************************************************
	read_eeprom: reads returns a data byte from eeprom address 
	specified in "loc"
*************************************************************************/
byte read_eeprom ( word loc )
{
	byte byte_value ;
	byte page ;
	BOOL ok;

readByte:
	waitForEEPROM();

	x_output ( IO_EEPROM_CLOCK_OUTPUT ) ;	// as output pin

	// device addressing for write
	if ( loc > 0xff ) 
		page = 0xa2;
	else
		page = 0xa0;

	// dummy write to set address
	eeprom_start();

	if (!write_byte( page ) || !write_byte( loc ))
		goto readByte;

	// device addressing for read
	page |= 1 ;

	// read byte at address "loc"
	eeprom_start();
	if (!write_byte( page ))
		goto readByte;

	byte_value = read_byte( FALSE, &ok ) ;

	if (!ok)
		goto readByte;

	eeprom_stop() ; 		// stop condition

	x_output ( IO_EEPROM_CLOCK_INPUT ) ;	// as input pin

	return ( byte_value ) ;
}

/*************************************************************************
	write_eeprom : writes a data byte specified in "data_byte"
	at eeprom address specified in "loc"
*************************************************************************/
void write_eeprom ( word loc, byte data_value )
{
	byte page ;

	waitForEEPROM();

	if ( loc > MAX_LOC )	
		return ;

	x_output ( IO_EEPROM_CLOCK_OUTPUT ) ;	// as output pin

	// set page & write opcode
	if ( loc > 0xff ) 
		page = 0xa2;
	else
		page = 0xa0;

	// device addressing for write
	eeprom_start();
	write_byte( page ) ;
	write_byte( loc ) ;
	write_byte( data_value ) ;
	eeprom_stop() ;

	// wait for acknowledge
	eeprom_ack( page ) ;

	x_output ( IO_EEPROM_CLOCK_INPUT ) ;	// as input pin
}

/*************************************************************************
	read_eeprom_pg : reads up to the end of the current page (256 bytes)
	(passed in "cnt") from "loc" into buffer pointed to by "data_bytep".
	Note: caller must be aware of page boundary (see llutil1.c).
*************************************************************************/
void read_eeprom_pg ( word loc, byte *data_valuep , byte cnt )
{
	BOOL ok;
	byte page, *init_dvp = data_valuep;
	byte init_cnt = cnt;

	if ( loc+cnt > MAX_LOC )	if ( loc+cnt > MAX_LOC )
		return ;

readPage:
	cnt = init_cnt;
	data_valuep = init_dvp;
	waitForEEPROM();

	x_output ( IO_EEPROM_CLOCK_OUTPUT ) ;	// as output pin

	// device addressing for write
	if ( loc > 0xff ) 
		page = 0xa2;
	else
		page = 0xa0;

	// dummy write to set address
	eeprom_start();
	if (!write_byte(page) || !write_byte(loc))
		goto readPage;

	// device addressing for read
	page |= 1 ;

	// read the next "cnt" bytes of data
	eeprom_start();
	if (!write_byte( page ))
		goto readPage;

	while ( cnt-- > 1 )
	{
		*data_valuep = read_byte( TRUE, &ok ) ;
		if (!ok)
			goto readPage;
		data_valuep++ ;
	}
	*data_valuep = read_byte( FALSE, &ok ) ;
	if (!ok)
		goto readPage;
	eeprom_stop() ;

	x_output( IO_EEPROM_CLOCK_INPUT ) ;
	return ;
}

/*************************************************************************
	write_eeprom_pg : writes up to 16 data bytes (cnt) pointed to by
	"data_bytep" starting at eeprom address specified in "loc"
	Note: caller is responsible for avoiding "page wrap".
*************************************************************************/
void write_eeprom_pg ( word loc, byte *data_valuep , byte cnt )
{
	byte page ;

	// check for device wrap
	waitForEEPROM();

	if ( loc+cnt > MAX_LOC )
		return ;

	x_output ( IO_EEPROM_CLOCK_OUTPUT ) ;	// as output pin

	// set page & write opcode
	if ( loc > 0xff ) 
		page = 0xa2;
	else
		page = 0xa0;

	// write the data
	eeprom_start() ;
	write_byte (page) ;
	write_byte (loc) ;
	while ( cnt-- )
		write_byte (*data_valuep++) ;
	eeprom_stop() ;

	// wait for acknowledge
	eeprom_ack( page ) ;

	x_output ( IO_EEPROM_CLOCK_INPUT ) ;	// as input pin
}
#endif	// } EEPROM_X24C04

#if defined(THREE_WIRE_EEPROM)
/*************************************************************************
	The following routines read/write data from the XL93LC66 (EEPROM).
	Unlike the 2 wire device above, no start or stop conditions are
	involved.  Instead there is a third lead, the chip select, that
	synchronizes reads and writes to the device.  There is an 11 bit
	command (1 start bit + 2 bit opcode + 8 bits addr) followed by
	the data in or data out phase.  Also this device is word oriented
	(256x16) instead of byte oriented.
*************************************************************************/

/*************************************************************************
	eeprom_cmd_out : outputs the 11 bit (1 start bit + 2 bit opcode
	+ 8 bits addr) eeprom command sequence. Chip select and data
	direction have already been set up prior to calling this function.
*************************************************************************/
void eeprom_cmd_out ( byte cmd, byte loc )
{
	byte i ;

	// initialize clock to start the sequence
	x_output ( IO_EEPROM_CLOCK_HIGH ) ;
	x_output ( IO_EEPROM_CLOCK_LOW ) ;

	// first write the start bit...
	x_output ( IO_EEPROM_DATA_HIGH ) ;
	x_output ( IO_EEPROM_CLOCK_HIGH ) ;
	x_output ( IO_EEPROM_CLOCK_LOW ) ;

	// then send the 2 bit command...
	x_output ( cmd & 2 ? IO_EEPROM_DATA_HIGH : IO_EEPROM_DATA_LOW ) ;
	x_output ( IO_EEPROM_CLOCK_HIGH ) ;
	x_output ( IO_EEPROM_CLOCK_LOW ) ;
	x_output ( cmd & 1 ? IO_EEPROM_DATA_HIGH : IO_EEPROM_DATA_LOW ) ;
	x_output ( IO_EEPROM_CLOCK_HIGH ) ;
	x_output ( IO_EEPROM_CLOCK_LOW ) ;

#ifdef E2_X_ADR_LENGTH
	if( (cmd == EE_WR_DATA_CMD)
		||(cmd == EE_RD_DATA_CMD)
	)
	{
		//need to add upper n bits of base address for address longer
		//than 8 bits
		for( i = 0; i < EE_EXTRA_BITS; i++)
		{
			x_output ( EE_BASE_ADR & 1<<(7-i) ? IO_EEPROM_DATA_HIGH : IO_EEPROM_DATA_LOW ) ;
			x_output ( IO_EEPROM_CLOCK_HIGH ) ;
			x_output ( IO_EEPROM_CLOCK_LOW ) ;
		}
	}
#endif

	// finally send the 8 bit addr
	for ( i = 0; i < 8; i++, loc <<= 1 )
	{
		x_output ( loc & 0x80 ? IO_EEPROM_DATA_HIGH : IO_EEPROM_DATA_LOW ) ;
		x_output ( IO_EEPROM_CLOCK_HIGH ) ;
		x_output ( IO_EEPROM_CLOCK_LOW ) ;
	}

#ifdef E2_X_ADR_LENGTH
	if( (cmd == EE_WR_ENABLE_CMD)
		|| (cmd == EE_WR_DISABLE_CMD)
	)
	{
		//need to add n don't care bits for address longer than 8 bits
		for( i = 0; i < 2; i++)
		{
			x_output ( EE_EXTRA_CMD_BITS & 1<<(7-i) ?
					   IO_EEPROM_DATA_HIGH : IO_EEPROM_DATA_LOW ) ;
			x_output ( IO_EEPROM_CLOCK_HIGH ) ;
			x_output ( IO_EEPROM_CLOCK_LOW ) ;
		}
	}
#endif
}

/*************************************************************************
	read_eeprom_wd: reads returns a data word from eeprom address
	specified in "loc"
*************************************************************************/
word read_eeprom_wd ( byte loc )
{
	word data ;
	byte i ;

	// set I/O lead for output
	x_output ( IO_EEPROM_DATA_OUTPUT ) ;
	x_output ( IO_EEPROM_DATA_LOW ) ;
	x_output ( IO_EEPROM_CLOCK_LOW ) ;

	// enable chip select lead
	x_output ( IO_EEPROM_CS_HIGH ) ;

	// send read data command
	eeprom_cmd_out ( EE_RD_DATA_CMD, loc ) ;

	// set I/O lead for input
	x_output ( IO_EEPROM_DATA_HIGH ) ;
	x_output ( IO_EEPROM_DATA_INPUT ) ;

	for ( i=0; i<50; i++ ) ;

	// now read the data in; Note: the first bit in is a zero
	for ( i=0, data=0; i<16; i++, data<<=1 )
	{
		data |= x_input ( IO_EEPROM_DATA ) ? 1 : 0 ;
		x_output ( IO_EEPROM_CLOCK_HIGH ) ;
		x_output ( IO_EEPROM_CLOCK_LOW ) ;
	}
	data |= x_input ( IO_EEPROM_DATA ) ? 1 : 0 ;

	// disable chip select lead
	x_output ( IO_EEPROM_CS_LOW ) ;

	return ( data ) ;
}

/*************************************************************************
	write_eeprom_wd : writes a data word specified in "wdata"
	at eeprom address specified in "loc"
*************************************************************************/
void write_eeprom_wd ( byte loc, word wdata )
{
	byte i ;
	word cnt ;

	// set I/O lead for output
	x_output ( IO_EEPROM_DATA_OUTPUT ) ;
	x_output ( IO_EEPROM_DATA_LOW ) ;
	x_output ( IO_EEPROM_CLOCK_LOW ) ;

	// enable chip select lead
	x_output ( IO_EEPROM_CS_HIGH ) ;

	// send write enable command
	eeprom_cmd_out ( EE_WR_ENABLE_CMD, EE_WR_ENABLE_ADR ) ;

	// disable chip select lead
	x_output ( IO_EEPROM_CS_LOW ) ;

	for ( i=0; i<50; i++ ) ;

	// enable chip select lead
	x_output ( IO_EEPROM_DATA_LOW ) ;
	x_output ( IO_EEPROM_CS_HIGH ) ;

	// send write data command
	// followed by the data
	eeprom_cmd_out ( EE_WR_DATA_CMD, loc ) ;

	for ( i = 0; i < 16; i++, wdata <<= 1 )
	{
		x_output ( wdata & 0x8000 ? IO_EEPROM_DATA_HIGH
								 : IO_EEPROM_DATA_LOW ) ;
		x_output ( IO_EEPROM_CLOCK_HIGH ) ;
		x_output ( IO_EEPROM_CLOCK_LOW ) ;
	}

	// disable chip select lead
	x_output ( IO_EEPROM_CS_LOW ) ;

	for ( i=0; i<50; i++ ) ;

	// Now wait for write to complete (up to 10ms)
	// turn data lead around to read status and
	// enable chip select lead
	x_output ( IO_EEPROM_DATA_INPUT ) ;
	x_output ( IO_EEPROM_CS_HIGH ) ;
	for ( cnt=0; cnt<1000; cnt++ )
	{
		if ( x_input ( IO_EEPROM_DATA ) )
		{
			break ;
		}
		x_output ( IO_EEPROM_CLOCK_HIGH ) ;
		x_output ( IO_EEPROM_CLOCK_LOW ) ;
	} 

	// disable chip select lead
	x_output ( IO_EEPROM_CS_LOW ) ;

	for ( i=0; i<50; i++ ) ;

	// set I/O lead for output
	// and enable chip select lead
	x_output ( IO_EEPROM_DATA_OUTPUT ) ;
	x_output ( IO_EEPROM_DATA_LOW ) ;
	x_output ( IO_EEPROM_CS_HIGH ) ;

	// send write disable command
	eeprom_cmd_out ( EE_WR_DISABLE_CMD, EE_WR_DISABLE_ADR ) ;

	// disable chip select lead
	x_output ( IO_EEPROM_CS_LOW ) ;

	// set I/O lead for input
	x_output ( IO_EEPROM_DATA_HIGH ) ;
	x_output ( IO_EEPROM_DATA_INPUT ) ;
}

static word cache_data ;
static word cache_loc ;
static byte cache_flag ;
/*************************************************************************
	read_eeprom: for compatibility, this function reads a byte from the
	eeprom. The XL93LC66 is a 256x16 device.  This function will treat
	the device like it was 512x8.
	reads & returns a data byte from eeprom address specified in "loc"
*************************************************************************/
byte read_eeprom ( word loc )
{
	word wdata ;

	if ( cache_flag == 0x55 && cache_loc == loc )
	{
		wdata = cache_data ;
	}
	else
	{
		wdata = read_eeprom_wd ( loc >> 1 ) ;
		cache_data = wdata ;
		cache_loc  = loc ;
		cache_flag = 0x55 ;
	}
	return ( (byte)((loc & 1) ? (wdata & 0xff) : (wdata >> 8)) ) ;
}

/*************************************************************************
	write_eeprom : for compatibility, this function writes a data byte
	specified in "data_byte" at eeprom address specified in "loc"
*************************************************************************/
void write_eeprom ( word loc, byte data_byte )
{
	word wdata ;

	if ( cache_flag == 0x55 && cache_loc == loc )
	{
		wdata = cache_data ;
	}
	else
	{
		wdata = read_eeprom_wd ( loc >> 1 ) ;
	}
	if ( loc & 1 )
	{
		wdata &= 0xff00 ;
		wdata |= (0xff & (word)data_byte) ;
	}
	else
	{
		wdata &= 0x00ff ;
		wdata |= (word)(data_byte << 8) ;
	}

	write_eeprom_wd ( loc >> 1, wdata ) ;
	cache_data = wdata ;
	cache_loc  = loc ;
	cache_flag = 0x55 ;
}
#endif		// THREE_WIRE

#if defined( CS_MODEM )
// dummy functions for EEPROM
byte read_eeprom ( word loc )
{
	return 0;
}

void write_eeprom ( word loc, byte data_value )
{
}
#endif

#if defined(Z80_DEBUG_PRINT)
/****************************************************************
Routine : sendCrLf - send carriage return line feed to dumb port
*****************************************************************/
void sendCrLf(void)
{
	sendDumbChar(0x0A);
	sendDumbChar(0x0D);
}
#endif // Z80_DEBUG_PRINT

#if !defined( CS_MODEM )	// {
/****************************************************************
	Function : z80_display_mem
	support routine for z80_memory
*****************************************************************/
void z80_display_mem ( byte test, byte max, byte *loc )
{
	byte i, cnt, *bp, data, str[120];

	for ( i=0, bp=str, cnt=0; i<max; i++, cnt++ )
	{
		if ( !(cnt % 16) )
		{
			*bp++ = S.ModemOptions.CRChar;
			*bp++ = S.ModemOptions.LFChar;
#if defined( Z80_DEBUG_PRINT )
			if ( test == 3 )
			{
				*bp++ = 0 ;
				ddputs_nnl( str ) ;
			}
			else
#endif
			{
				x_send_mail ( AT_IO_DATA, IO_TASK, str, bp - str ) ;
			}
			cnt = 0 ;
			str[0]  = str_convert[  (byte)(((word)loc & 0xF000)>>12) ] ;
			str[1]  = str_convert[  (byte)(((word)loc & 0xF00)>>8) ] ;
			str[2]  = str_convert[  (byte)(((word)loc & 0xF0)>>4) ] ;
			str[3]  = str_convert[  (byte)((word)loc & 0xF) ] ;
			str[4]  = ':' ;
			str[5]  = ' ' ;
			bp = &str[6] ;
		}
		data =  ( test != 2 ) ? *loc++ : read_eeprom ( (word)(loc++) ) ;
		*bp++ = str_convert[ ((data>>4) & 0xf) ];
		*bp++ = str_convert[ (data & 0xf) ];
		*bp++ = ' ' ;
	}

	*bp++ = S.ModemOptions.CRChar;
	*bp++ = S.ModemOptions.LFChar;
#if defined( Z80_DEBUG_PRINT )
	if ( test == 3 )
	{
		*bp++ = 0 ;
		ddputs_nnl( str ) ;
	}
	else
#endif
	{
		x_send_mail ( AT_IO_DATA, IO_TASK, str, bp - str ) ;
	}
}

/****************************************************************
	Function : z80_memory
	Used only for NON Emulator debug
*****************************************************************/
word z80_memory ( byte test, dsp_ram *test_data )
{
	byte max;
	word adr, resp = 0;
	static word lst_adr;

	switch ( test )
	{
	case 6:				// hex dump of NEXT 0x80 bytes of memory
		adr = lst_adr ? lst_adr : 0x8000 ;
		lst_adr = adr+0x80;
		z80_display_mem ( 1, 0x80, (byte *)adr ) ;
		break;
	case 1:				// hex dump of 0x80 bytes of memory
		adr = test_data->loc | 0x8000 ;
		lst_adr = adr+0x80;
		z80_display_mem ( 1, 0x80, (byte *)adr ) ;
		break;
	case 2:				// hex dump of up to 80 bytes of serial eeprom
		adr = test_data->loc & (MAX_LOC-1) ;
		max = ( (adr+0x80) <= MAX_LOC ) ? 0x80 : MAX_LOC - adr ;
		z80_display_mem ( 2, max, (byte *)adr ) ;
		break;
#if defined(SERIAL_EEPROM_TEST)
	case 3:				// fill eeprom with zeroes
		for ( adr=0; adr<=MAX_LOC; adr++ )
		{
			write_eeprom ( adr, (byte)0 );
		}
		break;
	case 4:				// fill eeprom with ones
		for ( adr=0; adr<=MAX_LOC; adr++ )
		{
			write_eeprom ( adr, (byte)0xff );
		}
		break;
	case 5:				// Run 2 WS ROM
			// Wait State Generator: ROM=2; RAM=Disabled
		output8 ( WSG, 0x09 ) ;
		break;
#elif defined( Z80_DEBUG_PRINT )
	case 3:				// dump RAM to debug terminal
		adr = test_data->loc | 0x8000 ;
		z80_display_mem ( 3, 0x80, (byte *)adr ) ;
		break;
#endif
	}

	return resp ;
}
#endif	// } !CS_MODEM


#ifdef CS_DEBUG

void cs_write_debug_buf(word debug_str)
{
	extern word cs_debug_liv_indx;		// gita - defined in csmain.c
	extern word *cs_debug_liv_ptr;		// gita - defined in csmain.c
	extern word cs_debug_liv_buf[32];	// gita - defined in csmain.c 

	if((cs_debug_liv_buf[cs_debug_liv_indx] & 0x8000) ==  0x8000)
		cs_debug_liv_buf[cs_debug_liv_indx] |= 0x4000;
	else
	{
		// setting the data_ready bit
		debug_str |=0x8000;

		cs_debug_liv_buf[cs_debug_liv_indx] = debug_str;

		cs_debug_liv_indx++;

		cs_debug_liv_indx &=0x1F;

	}
}
#endif // CS_DEBUG

#if defined( TEST_COMMANDS )	// {
/****************************************************************
	Function : byte_display
*****************************************************************/
void byte_display ( byte xx )
{
#if defined(Z80_DEBUG_PRINT)
	extern byte dumbPortPresent;
	if ( dumbPortPresent )
	{
		sendHexByte( xx ) ;
	}
	else
#endif
	{
		byte i;
		byte str[6] ;
		extern word at_itoa( word, byte *, byte ) ;

		i = (byte)at_itoa( (word)xx, str, 16 ) ;
		x_send_mail ( AT_IO_DATA, IO_TASK, str, i ) ;
	}
}

/****************************************************************
	Function : venus_reg_rd -
*****************************************************************/
void venus_reg_rd ( byte loc )
{
	byte val ;
	extern void byte_display ( byte xx ) ;

	val = input( loc ) ;

	str_display( "Venus Reg=" ) ; byte_display( loc ) ;
	str_display( " is =" ) ; byte_display( val ) ;
	str_display( " " ) ;
}

/****************************************************************
	Function : venus_reg_wrt -
*****************************************************************/
void venus_reg_wrt ( byte loc, byte val )
{
	extern void byte_display ( byte xx ) ;

	str_display( "Setting Venus Reg=" ) ; byte_display( loc ) ;
	str_display( " to =" ) ; byte_display( val ) ;
	str_display( " " ) ;

	output( loc, val ) ;
}

#if !defined(EXT_MODEM) && !defined(USB_MODEM) && !defined(THUNDER)	// {
/****************************************************************
	Function : mimic_reg_set -
*****************************************************************/
void mimic_reg_set ( byte loc, byte val )
{
	str_display( "Setting Mimic Reg=" ) ; byte_display( loc ) ;
	str_display( " to =" ) ; byte_display( val ) ;
	str_display( " " ) ;

	output( loc, val ) ;
}

/****************************************************************
	Function : mimic_reg_display -
*****************************************************************/
void mimic_reg_display ( void )
{
	str_display( " " ) ;
	str_display( "  FCR  =" ) ;
	byte_display( input8( MIMIC_FCR ) ) ;
	str_display( "  FSCR =" ) ;
	byte_display( input8( MIMIC_FSCR ) ) ;
	str_display( "; LCR  =" ) ;
	byte_display( input8( MIMIC_LCR ) ) ;
	str_display( "; MCR  =" ) ;
	byte_display( input8( MIMIC_MCR ) ) ;
	str_display( "; MMC  =" ) ;
	byte_display( input8( MIMIC_MMC ) ) ;
	str_display( " " ) ;

	str_display( "  DLM  =" ) ;
	byte_display( input8( MIMIC_DLM ) ) ;
	str_display( "; DLL  =" ) ;
	byte_display( input8( MIMIC_DLL ) ) ;
	str_display( "; IER  =" ) ;
	byte_display( input8( MIMIC_IER ) ) ;
	str_display( "; LSR  =" ) ;
	byte_display( input8( MIMIC_LSR ) ) ;
	str_display( "; MSR  =" ) ;
	byte_display( input8( MIMIC_MSR ) ) ;
	str_display( " " ) ;

	str_display( "  RTTC =" ) ;
	byte_display( input8( MIMIC_RTTC ) ) ;
	str_display( "; RTCR =" ) ;
	byte_display( input8( MIMIC_RTCR ) ) ;
	str_display( "; TTTC =" ) ;
	byte_display( input8( MIMIC_TTTC ) ) ;
	str_display( "; TTCR =" ) ;
	byte_display( input8( MIMIC_TTCR ) ) ;
	str_display( " " ) ;

	str_display( "  BRGX =" ) ;
	byte_display( input8( BRGX ) ) ;
	str_display( "; BRGH =" ) ;
	byte_display( input8( BRGH ) ) ;
	str_display( "; BRGL =" ) ;
	byte_display( input8( BRGL ) ) ;
	str_display( "; ENHR =" ) ;
	byte_display( input8( ENHR ) ) ;
	str_display( " " ) ;

	str_display( "  ROMBR =" ) ;
	byte_display( input8( ROMBR ) ) ;
	str_display( "; RAMLBR =" ) ;
	byte_display( input8( RAMLBR ) ) ;
	str_display( "; RAMUBR =" ) ;
	byte_display( input8( RAMUBR ) ) ;
	str_display( "; CBAR =" ) ;
	byte_display( input8( CBAR ) ) ;
	str_display( "; CBR =" ) ;
	byte_display( input8( CBR ) ) ;
	str_display( "; MAR1B =" ) ;
	byte_display( input8( MAR1B ) ) ;
	str_display( " " ) ;
}
#endif	// } !EXT_MODEM && !USB_MODEM && !THUNDER
#endif	// } TEST_COMMANDS

#if defined( Z80_DEBUG_PRINT )	// {
/*************************************************************************
	The following routines read/write data from the VENUS development
	board Dumb Serial Port. 
*************************************************************************/


/****************************************************************
	Function : enableDumbPort(void)
	Sets up the Dumb Serial port
*****************************************************************/
void
enableDumbPort(void)
{
	output8(DUMB_LCR, 0x83);
	output8(DUMB_BRDH, 0);
#if defined( PEGASIS ) || defined(PCI_MODEM) || defined(ATHENA_LEDS)
	// mosquito-like crystal
	output8(DUMB_BRDL, 12); // baud rate 115.2
//	output8(DUMB_BRDL, 24); // baud rate  57.6
//	output8(DUMB_BRDL, 36); // baud rate  38.4
#else
	output8(DUMB_BRDL, 1);  // baud rate 115.2
//	output8(DUMB_BRDL, 2);  // baud rate  57.6
//	output8(DUMB_BRDL, 3);  // baud rate  38.4
#endif
	output8(DUMB_IIR, BIT0);
	output8(DUMB_IIR, BIT3|BIT0); // 16550 fifo mode

	output8(DUMB_LCR, 0x03);
	output8(DUMB_IER, 0x00);
	output8(DUMB_MCR, 0x0f);
	output8(DUMB_SCR, 0x55);
	dumbPortPresent = (input8(DUMB_SCR) == 0x55) ? 1 : 0;
}

/****************************************************************
	Function : sendDumbChar(byte ch)
	Sends a char on the Dumb Serial port
*****************************************************************/
void
sendDumbChar(byte ch)
{
#ifdef KORTEX
	byte tst_ch;
	
	// if desired, send dumb characters to terminal
	if (G(venusDebugToDTE) & 1)
	{
		tst_ch = 0x00;
		while (!(tst_ch&0x02))
		{
			tst_ch = input( ASCI_STAT0_REG ) ;
		}
		output8( ASCI_TX0_REG , ch ) ;
		return;
	}
#else
	// if desired, send dumb characters to terminal
	if (G(venusDebugToDTE) & 1)
	{
		char buf[1];

		#if defined(TCP_IP)
		// go straight to Host ring buffer
		if ( in_tcp_ip_mode )
		{
			byte *wptr ;
			wptr = (byte *) IO_DTE_TX_WPTR;
			*wptr++ = ch ;
			if ( wptr >= IO_DTE_TX_EPTR )
				wptr = (byte *) IO_DTE_TX_SPTR;
			IO_DTE_TX_WPTR = wptr ;
			return;
		}
		#endif // TCP_IP

		buf[0] = ch;
		x_send_mail(AT_IO_DATA, IO_TASK, buf, 1);
		return;
	}
#endif
	if (!dumbPortPresent)
		return;

	while (!(input8(DUMB_LSR) & 0x20))
		;
	output8(DUMB_DATA, ch);
}

/****************************************************************
	Function : sendHexDigit(byte digit)
	Converts the digit to ASCII and prints it on the debug port
*****************************************************************/
void
sendHexDigit(byte digit)
{
	sendDumbChar((digit > 0x0f) ? 'X' : str_convert[digit]);
}

/****************************************************************
	Function : ddputs_nnl(char *str)
	prints a string on the debug port
*****************************************************************/
void
ddputs_nnl(char *str)
{
	while (*str)
	{
		sendDumbChar(*str++);
	}
}

/****************************************************************
	Function : ddputs(char *str)
	prints a time stamped string on the debug port with CRLF
*****************************************************************/
void
ddputs(char *str)
{
	ddputs_nnl(str);
	sendCrLf();
}

/****************************************************************
	Function : sendDecByte(byte ch)
	prints a decimal byte
*****************************************************************/
void
sendDecByte(byte ch)
{
	byte x = 0;
	byte y = 0;

	/* hundreds */
	while (ch > 99)
	{
		y++;
		x++;
		ch -= 100;
	}
	if (x)
	{
		sendDumbChar(x + '0');
		x = 0;
	}

	/* tens */
	while (ch > 9)
	{
		x++;
		ch -= 10;
	}
	if (x || y)
	{
		sendDumbChar(x + '0');
		x = 0;
	}

	sendDumbChar(ch + '0');
}

/****************************************************************
	Function : sendHexByte(byte ch)
	prints a hex byte
*****************************************************************/
void
sendHexByte(byte ch)
{
	sendHexDigit( (ch >> 4) & 0x0f );
	sendHexDigit( ch & 0x0f );
}

/****************************************************************
	Function : sendHexWord(word wd)
	prints a hex word
*****************************************************************/
void
sendHexWord(word wd)
{
	byte i;

	for (i=0; i<4; i++)
	{
		sendHexDigit((wd & 0xf000) >> 12);
		wd <<= 4;
	}
}

/****************************************************************
	Function : fatal_error(char *str)
	replaces routine in cstartup.r01; uses ddputs_nnl()
*****************************************************************/
void
fatal_error(char *str)
{
	sendHexWord( x_current_time() ) ;
	x_debug_msg(": fatal error: ");
	//ddputs_nnl(str);
	//sendDumbChar(0x0A); sendDumbChar(0x0D);
	ddputs_nnl(str); sendCrLf();

	//------------------------------------
	// If there is a debug terminal
	// then just spin wait
	//------------------------------------
	#if defined(Z80_DEBUG_PRINT)
	if ( !dumbPortPresent )
	#endif
	{
		// No debug port is present, try to reset and continue
		output8( 0xda, 0x1f ) ;
		output8( 0xdb, 0xe5 ) ;
		disable_interrupt () ; // let sanity timer hit
	}

	while(1)
		;
}
#endif	//  } Z80_DEBUG_PRINT

#if defined PCI_MODEM
const byte VenusPCIdata[] =
{
0xFF, 0x40, 0xFE, 0x04, 0xFD, 0x04, 0xFC, 0x43, 0xFB, 0x05, 
0xFA, 0x01, 0xF9, 0x15, 0xF8, 0x02, 0xF7, 0x14, 0xF6, 0xF9
};

extern byte pita_regread(byte reg);
extern void pita_regwrite(byte reg, byte value);

/****************************************************************
Routine : pita_regread - read byte from PITA register 'reg'
*****************************************************************/
byte pita_regread ( byte reg )
{
	byte value;
	output8( PitaBaseAddress, reg ) ;
	value= input ( PitaBaseAddressData ) ;
	output8( PitaBaseAddress, 0x00 ) ;	// needed for chip bug
	return value;
}

/****************************************************************
Routine : pita_regwrite - write byte 'value' to PITA register 'reg'
*****************************************************************/
void pita_regwrite ( byte reg, byte value )
{
	output8( PitaBaseAddress, reg ) ;
	output8( PitaBaseAddressData, value ) ;
	output8( PitaBaseAddress, 0x00 ) ; // needed for chip bug
}

/****************************************************************
	Function : pciInit
		Initialize Pita things for the PCI case
*****************************************************************/
void pciInit(void)
{
	byte PitaData;
	byte PCIcount;
	byte PCIcountLoop;
	byte temp;

	pita_regwrite(0x03,0x00) ;//CFGCTL register, bit2=ELD=1, bit1=IDWPTR=1
	PCIcountLoop=0;	
	while(!(pita_regread(0x04) & 0x08))//PCI reset complete?
	{
		PCIcountLoop++;
		if(PCIcountLoop >500)
		{
			ddputs_nnl( "PRstFail\n\r" ) ;
			break;
		}
	}
	//INTSRC register
	pita_regwrite(0x04,0xFF);//Clear all INTSRC bit
	PCIcountLoop=0;	
	while((pita_regread(0x04)!=0x00))		//INTSRC reset complete?
	{
		PCIcountLoop++;
		if(PCIcountLoop >100)
		{
			ddputs_nnl( "IntsrcFail\n\r" ) ;
			break;
		}
	}

	pita_regwrite(0x03,0x10) ; ;//Clear RSTHLD bit
	PCIcount=0;	
	PCIcountLoop=0;
	while (PCIcount< sizeof VenusPCIdata)
	{
		while((pita_regread(0x04) & 0x01)!= 0x01)
		{
			PCIcountLoop++;
			if(PCIcountLoop >5)
			{
				ddputs_nnl( "Intsrc==0\n\r" ) ;
				PCIcountLoop=0;
				break;
			}			
		}
		PitaData=pita_regread(0x07);//CFGADD
		temp=VenusPCIdata[PCIcount];
#if defined DEBUG		
		ddputs_nnl("Pd=");
		sendHexByte(PitaData);
		ddputs_nnl(", t= ");
		sendHexByte(temp);
		sendCrLf();
#endif 
		//Please do not remove any line of code here.
		//The sequence of talking to PITA is critical.
		pita_regwrite(0x04,0x01);//Clear INTSRC bit0
		if (PitaData==temp)
		{
			PCIcount++;
			PitaData=VenusPCIdata[PCIcount];
			pita_regwrite(0x09,PitaData);//send data out to CFRDAT
		}
		else 
		{
			ddputs_nnl( "CfgAddrErr\n\r" ) ;
			break;
		};
		PCIcount++;
#if defined(DEBUG)
		ddputs_nnl("count=");
		sendHexByte(PCIcount);
		sendCrLf();
#endif
		if(PCIcount >sizeof VenusPCIdata)
		{
			ddputs_nnl( "CfgSizeErr\n\r" ) ;
			break;
		}
	}//end of while(PCIcount<= sizeof VenusPCIdata)

	pita_regwrite(0x0E,0x02); // MIMIC interrupt enable
}

byte z80_pitaPower;		// pita power management state
/****************************************************************
	Function : z80_poll_pita

	Poll pita for any power management stuff that
	needs to happen.
*****************************************************************/
void z80_poll_pita(void)
{
	// if we're running along and discover that
	// we've been put into a power management state,
	// we don't want to give any more characters to the
	// MIMIC so PITA doesn't get an interrupt.
	byte power = pita_regread(0x12) & 3;

	if (z80_pitaPower != power)
	{
		z80_pitaPower = power;
		switch (z80_pitaPower)
		{
		case 3:
		case 2:
		case 1:
			// In power management mode, disable MIMIC IRQ
			// to the PITA so the host doesn't get any interrupts.
			str_display("power down - disable MIMIC IRQ");
			dp_regwrite(0xcc, 0x0E);	// Assign MIMIC Irq C - (nothing)
			dp_regwrite(0xd6, 0x0F);	// disable IRQ's

			pita_regwrite(0x0E, 0x00); // MIMIC interrupt disable

			// hang up any call 
			if ( G(x_modem_state) != MS_IDLE )
			{
				x_send_mail(AT_IO_DISCONNECT, IO_TASK, NULL, 0);

				// don't want any "OK" message.  Tell DP to
				// hang up immediately.  This takes it out
				// of the DP_DISCONNECT state.
				x_send_mail(MC_ONHOOK, DP_TASK, NULL, 0);
			}

			// clean up anything hanging around in the DTE buffers
			UART_Flush(0);		// init dte receive  fifo
			UART_Flush(1);		// init dte transmit fifo

			// Let's try to go to sleep right away
			x_send_mail(IO_SLEEP_CMD, IO_TASK, NULL, 0);
			break;
		case 0:
			// Out of power management mode, enable MIMIC IRQ
			str_display("power up - enable MIMIC IRQ");

			// clean up anything hanging around in the DTE buffers
			UART_Flush(0);		// init dte receive  fifo
			UART_Flush(1);		// init dte transmit fifo

#if defined (TQFP128)
			dp_regwrite(0xcc, 0x0D);	// Assign MIMIC Irq B=3
			dp_regwrite(0xd6, 0x2D);	// IRQ B Driven always
#else
			dp_regwrite(0xcc, 0x0C);	// Assign MIMIC Irq A=4
			dp_regwrite(0xd6, 0x1E);	// IRQ A Driven always
#endif
			pita_regwrite(0x0E, 0x02); // MIMIC interrupt enable
			break;
		}
	}
}
#endif  // PCI_MODEM

#if defined(MODEM_Z80)

extern void z80_read_v92_capabilities(void);

//-----------------------------------------------------------
// M and N coefficients for different RAM / ROM combinations
//-----------------------------------------------------------
# define M_N_COEFF_12	 0x21			// 1.2*xtal = ~40MHz
# define M_N_COEFF_15	 0x54			// 1.125*xtal = ~35Mhz


/*************************************************************************
	z80_init_venus2:

	Initialize the venus2 specific functions.

	Update the z80_v92cap flag to indicate v.92 capabilities
	as indicated by the EEPROM.

*************************************************************************/
void z80_init_venus2(void)
{
	// read the revision (non- zero for venus 2)
	z80_venus2 = input8(REVR);
#if !defined(CS_MODEM)
	z80_read_v92_capabilities();
#endif
	#if defined(Z80_DEBUG_THIS_FILE)
	x_debug_msg("z80_v92cap=");
	sendHexByte(z80_v92cap);sendCrLf();
	#endif

#if defined(Z80_USE_DPLL)
	//-------------------------------------------------
	// Are we venus2 - revision register will be
	// 0x10 or 0x11 for V2; 0x00 for earlier chips
	//-------------------------------------------------
	if ( z80_venus2 )
	{
		// pick MN coefficient based on RAM/ROM speed as
		// dictated in EEPROM.
		byte mnCoeff = z80_v92cap & 2 ? M_N_COEFF_12 : M_N_COEFF_15;

		//-------------------------------------------------
		// Set the frequency and start the digital PLL.
		// z80_start_dpll() below will perform a seamless
		// switch to the DPLL later, after it is locked
		// onto the selected frequency.
		//-------------------------------------------------
		output8( 0x1d, 0 );					// disable DPLL
		output8( 0x1c, mnCoeff );			// set M and N
		output8( 0x1d, 1 );					// enable DPLL
		z80_use_dpll = TRUE;
	}
	else
	{
		z80_use_dpll = FALSE;
	}
#endif // Z80_USE_DPLL
}

/*************************************************************************
	z80_start_dpll: switch to the DPLL on venus2
*************************************************************************/
void z80_start_dpll ( void )
{
#if defined(Z80_USE_DPLL)
	byte dpll_statreg;

	if ( z80_use_dpll )
	{
		dpll_statreg = input8( 0x1d );

		// if DPLL is enabled and locked in
		if ( !(dpll_statreg & BIT2) &&
			 ((dpll_statreg & (BIT1|BIT0)) == (BIT1|BIT0)) )
		{
			x_debug_msg( "Switching to DPLL");

			// enable DPLL as Zinger clock
			output8( CKSRC, input8( CKSRC ) | BIT6 );
		}
	}
#endif // Z80_USE_DPLL
}

/*************************************************************************
	z80_stop_dpll: switch back to the crystal oscillator on venus2
*************************************************************************/
void z80_stop_dpll ( void )
{
#if defined(Z80_USE_DPLL)
	if ( z80_use_dpll )
	{
		// switch to xtal osc. for Zinger clock
		x_debug_msg( "Switching to XTAL");
		output8( CKSRC, input8( CKSRC ) & ~BIT6 );
	}
#endif // Z80_USE_DPLL
}
#endif // MODEM_Z80

#if defined(MODEM_Z80) && defined(VENUS2) && defined(TEST_V2_DPLL)
/*************************************************************************
	z80_set_dpll: set the dpll on venus2
*************************************************************************/
void z80_set_dpll(byte dpllmn)
{
	output8(CKSRC, input8(CKSRC) & ~BIT6);		// switch to crystal
	output8(0x1d, 0);							// disable DPLL
	output8(0x1c, dpllmn);						// set M and N
	output8(0x1d, 1);							// enable DPLL

	while(!input8(0x1d) & 3)
		;

	if (input8(0x1d) & BIT2)
	{
		return;
	}

	output8(CKSRC, input8(CKSRC) | BIT6);		// enable DPLL as Zinger clock
}
#endif // MODEM_Z80

#if defined( ZMODEM_TEST )
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// This include file contains a file test utility that
// can be used to track bit error problems even with
// zmodem.  To activate test, define the symbol
// ZMODEM_TEST in z80glob.h and place appropriate
// calls to the testing fcns within.
//---------------------------------------------------------------------
//---------------------------------------------------------------------
#include	"zmdmtest.h"
#endif	// ZMODEM_TEST
