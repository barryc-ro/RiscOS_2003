/*name and version number:@(#)atcmd.c	1.397*/
/*date of get: 		  12/15/00 10:10:15*/
/*date of delta:	  12/05/00 11:40:09*/
/****************************************************************
File : atcmd.c
Description :
	This file contains all the at command codes

Procedures Contained :
	at_a,   at_d
	at_e,   at_h
	at_i,   at_l
	at_m,   at_o
	at_p,   at_q
	at_t,   at_v
	at_w,   at_x
	at_y,   at_z

	at_and
	at_and_c        at_and_d
	at_and_f        at_and_z

	at_percent
	at_percent_c
    at_percent_e

	at_backslash
	at_backslash_j
	at_backslash_n

	at_data_compression
	at_dash

*****************************************************************/

#include "llglob_d.h"
#include "atglob.h"
#include "iouart_d.h"	// extern for UART_dtr_blocked()
//msm// #include "z80glob.h"
#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
	#include "fax_c2.h"
#endif

#include "allglobs.h"

extern void at_output_hex(word w);
extern void at_percent_f(void);
extern void at_diagnostics(void);		// ATI11

const char at_idstring[] = IDSTRING;	// defined in llglob_d.h

/****************************************************************
Routine : at_display_id
Description : Display the product-specific ID string.
	Called by the at_i() function below.
*****************************************************************/
void at_display_id(void)
{
	byte ptr[160];
#if defined(VPCM_SERVER) && !defined(CS_4)
	x_strcpy(ptr,"120899/1.68/257");
#ifdef CS_LAPM_DEBUG
	x_strcat(ptr,"/LAPM Dbg");
#endif
#ifdef CS_ETC
	x_strcat(ptr,"/ETC");
#endif
#ifdef CS_V110
	x_strcat(ptr,"/V110");
#endif
#else	// CLIENT
	x_strcpy(ptr, (byte *) at_idstring);
#if defined(VOICE)
	x_strcat(ptr, (byte *) " Voice");
#endif // VOICE
#if defined(MODEM_Z80)
	// append chip version info
	if (z80_venus2)
	{
		x_strcat(ptr, (byte *) " V2");
	}
	if (z80_v92cap & 1)
	{
		x_strcat(ptr, (byte *) " V92cap");
	}

	if (z80_v92cap & 2)
	{
		x_strcat(ptr, (byte *) " 12ns RAM");
	}
#endif // MODEM_Z80

	// For debug purposes you may overwrite ptr[] here.
	//x_strcpy(ptr, "test version id string");
#endif
    at_output_msg2(ptr);

}

#if defined(CS_V110)
#define V110_RATE_38400		3
#define V110_RATE_19200		6
#define V110_RATE_9600		9
#define V110_RATE_4800		11
#define V110_RATE_2400		13

/****************************************************************
Routine : config_v110
Description :
	Configure the modem for receiving v.110 call
*****************************************************************/
void config_v110( void )
{
	byte correct_speed;
	
	correct_speed = TRUE;

	switch (G(S).ModemOptions.V110Speed)
	{
		case 58:
			G(v110_uChannelRate) = V110_RATE_2400;
			break;
		case 59:
			G(v110_uChannelRate) = V110_RATE_4800;
			break;
		case 61:
		 	G(v110_uChannelRate) = V110_RATE_9600;
			break;
		case 64:
		 	G(v110_uChannelRate) = V110_RATE_19200;
			break;
		case 67:
		 	G(v110_uChannelRate) = V110_RATE_38400;
			break;
		default:	// wrong speed
			correct_speed = FALSE;
			break;
	}

	if (correct_speed == TRUE)		// no error, so start v.110
	{
		G(cs_v110_on) = 1;		// receiving v.110 call but not yet connected
		x_send_mail_dp1(MC_V110_ANSWER);
	}
}
#endif // CS_V110

/****************************************************************
Routine : at_cmd_err_ret
Description :
	Gives an error message.  Usually "ERROR"
	(but could be numeric message depending on ATX)
*****************************************************************/
void at_cmd_err_ret(void)
{
	G(at_result_code) = ERROR;
	at_output_msg(NULL, 0);
}

// ATE4BN - at_error_for_bad() parameter number result
// We're using this global for convenience sake on Z80
// where this is more space efficient than more parameter
// passing.
#define ATE4BN	(G(x_scratch)[0])

/****************************************************************
Routine : at_error_for_bad
Description :

	Check to see the the next byte(s) of at_cmd_ptr is
	a number whose value is less than firstBad.

	If the next byte is not a decimal digit than we
	treat it as if it were the digit zero.

	If the number is correct, at_cmd_ptr is updated to
	point to the character after the number.

	Value for the number is saved in x_scratch[0].

	ATE4BN - AT Error for Bad Number

	Return TRUE if good, FALSE if bad.
*****************************************************************/
byte at_error_for_bad(byte firstBad)
{
	word valword;
	
	byte len = (byte) at_atoi(G(at_cmd_ptr), &valword, DECIMAL);

	if (valword < firstBad)
	{
		G(at_cmd_ptr) += len;
		ATE4BN = (byte) valword;
		return TRUE;
	}

	at_cmd_err_ret();
	return FALSE;
}

/***********************************************************************
Routine : at_dummy
Description :
	Skip any decimal digit and do nothing.
************************************************************************/
void at_dummy(void)
{
	if ((*G(at_cmd_ptr) > 0x2f) && (*G(at_cmd_ptr) < 0x3a))
		G(at_cmd_ptr)++ ;
}

/***********************************************************************
Routine : at_f
Description :
	Online Data Character Echo Command

	(Command not supported but we'll accept ATF1)
************************************************************************/
void at_f(void)
{
	if ( *G(at_cmd_ptr)++ != '1' )
	{
		at_cmd_err_ret () ;
		return ;
	}
	atparse_cmd();
}
/***********************************************************************
Routine : at_and_j
Description :
	Returns OK if parameter is 0
	ERROR otherwise

	(Documentation shows AT&J as Auxiliary Relay Option).
************************************************************************/
void at_and_j(void)
{
	if ( *G(at_cmd_ptr)++ != '0' )
	{
		at_cmd_err_ret () ;
		return ;
	}
}

/****************************************************************
Routine : at_y
Description :
	aty command - ATY1 means long space disconnect, ATY0 means
		no long space disconnect.

		The long space disconnect command disconnects the modem
		from a call upon receiving a long space (1.6 sec break)
		signal from the distant end.  If Y1 is selected, the modem
		sends a 4-second break (space) before going on-hook when
		it initiates the call tear-down.

		This only has effect in 1200 and 2400 bps modes.

		In the firmware this is stored in the 'AdjustBPS'
		option, bit 1.
*****************************************************************/
void at_y(void)
{
	if (!at_error_for_bad(2))
		return;

	if (0 == ATE4BN)
	{
		G(S).ModemOptions.AdjustBPS &= ~2;
	}
	else
	{
		G(S).ModemOptions.AdjustBPS |= 2;
	}

	atparse_cmd();
}

/****************************************************************
Routine : at_and_k
Description :
	Local Flow Control Selection
*****************************************************************/
void at_and_k( void )
{
	if (!at_error_for_bad(5))
		return;

	switch (ATE4BN)
	{
		case 0:
			// disable flow control
			G(S).ModemOptions.FlowControl = NO_FLOWCTRL ;
			break ;
		case 1:
		case 2:
			at_cmd_err_ret() ;
			return ;
		case 3:
			// enable RTS/CTS (hardware) flow control (default)
			G(S).ModemOptions.FlowControl = HW_FLOWCTRL ;
			break;
		case 4:
			// enable XON/XOFF (software) flow control
			G(S).ModemOptions.FlowControl = SW_FLOWCTRL ;
			break;
	}
}

/****************************************************************
Routine : at_backslash_j
Description :
	Bits/s Rate Adjusted - This command determines whether or
	not the negotiated connect speed of the modem forces
	the adjustment of the speed of the DTE to the modem's
	speed.
*****************************************************************/
void at_backslash_j ( void )
{
	if (!at_error_for_bad(2))
		return;

	if (0 == ATE4BN)
	{
		G(S).ModemOptions.AdjustBPS &= ~1 ;	
	}
	else
	{
		G(S).ModemOptions.AdjustBPS |= 1 ;
	}
}
/****************************************************************
Routine : at_backslash_b
Description :
	Transmit Break to remote.

	\B1 - B9 - Break length in 100 ms units.
*****************************************************************/
void at_backslash_b ( void )
{
	if (!at_error_for_bad(10))
		return;

	if ( (G(x_modem_mode) != MODEM_DATA) || (G(x_modem_state) != MS_ON_DIAL) )
	{
		// return NO CARRIER if not connected or in FAX mode.
		G(at_result_code) = NO_CARRIER ;
		at_output_msg(NULL, 0);
		return ;
	}
	G(S).ModemOptions.BreakLength = ATE4BN;
	x_send_mail(AT_IO_BREAK, IO_TASK, NULL, 0);
}

/****************************************************************
Routine : at_backslash_k
Description :
	Break Control.

	Controls the response of the modem to a break received from
	the DTE or the remote modem or the \B command.
*****************************************************************/
void at_backslash_k ( void )
{
	if (!at_error_for_bad(6))
		return;

	G(S).ModemOptions.BreakControl = ATE4BN;
}

/****************************************************************
Routine : at_backslash_q
Description :
	Local flow control selection.  Same functionality as &KX.
*****************************************************************/
void at_backslash_q ( void )
{
	if (!at_error_for_bad(4))
		return;

	switch (ATE4BN)
	{
		case 0:
			// No flow control.
			G(S).ModemOptions.FlowControl = NO_FLOWCTRL ;
			break ;
		case 1:
			// Software flow control
			G(S).ModemOptions.FlowControl = SW_FLOWCTRL ;
			break;
		case 2:
			at_cmd_err_ret();
			return ;
		case 3:
			// Hardware flow control
			G(S).ModemOptions.FlowControl = HW_FLOWCTRL ;
			break;
	}
}
/****************************************************************
Routine : at_a
Description :
	This function process the ATA command
*****************************************************************/
void at_a(void)
{
	if ( (G(x_modem_state) != MS_IDLE) &&
		 (G(x_modem_state) != MS_RING_INDICATE)	&&
		 (G(x_modem_state) != MS_OFFHOOK) )
	{
		at_cmd_err_ret();
		return;
	}
#if defined(CS_V110)
	if (G(S).ModemOptions.V110Speed)	// V.110 receive mode
	{
		config_v110();
		return;
	}			
#endif
	if (G(x_modem_mode) == MODEM_FAX)
	{
		G(x_fax_state) = FAX_TX_HDLC;
		G(x_fax_rate) = MR_300;    // FTH=3 implied
		G(x_fax_v17) = NON_V17 ;
	}

	// If auto disconnect then do not answer unless DTR is ON
	if (UART_dtr_blocked())
	{
		at_cmd_err_ret();
		return;
	}

	x_send_mail_dp1(MC_ANSWER);
}

/***************************************************************
Routine : at_b
Description :
	ATB - Communication Standard Setting
*****************************************************************/
void at_b(void)
{
	if (!at_error_for_bad(17))
		return;

	switch(ATE4BN)
	{
	case 1:		// Select Bell 212A @ 1200 bps
	case 16:	// Select Bell 103J @ 300 bps
		if (G(S).ModemOptions.BellModePermited)
			G(S).ModemOptions.CommStdSetting = 1;
		G(S).ModemOptions.V23Reverse = 1;
		break;
	case 0:		// Select CCITT V.22 @ 1200 bps
	case 15:	// Select CCITT V.21 @ 300 bps
		G(S).ModemOptions.CommStdSetting = 0;	// V.21 or V.22
		G(S).ModemOptions.V23Reverse = 1;
		break ;
	case 2:
	case 3:
		// Unselect V.23 reverse channel
		G(S).ModemOptions.V23Reverse = 0;
		break ;
	default :
		at_cmd_err_ret();
		return;
	}
	atparse_cmd();         // not end yet, continue parsing
}
/****************************************************************
Routine : at_d
  Dial.
  Begin the dialing sequence.
*****************************************************************/
void at_d(void)
{
	if ((G(x_modem_state) != MS_OFFHOOK) &&
		(G(x_modem_state) != MS_IDLE))
	{
		// Can't dial if we're already off hook
		// except for the special case of dialing ';'
		// during RING.
		if (G(x_modem_state) == MS_RING_INDICATE )
		{
			if ( *G(at_cmd_ptr) != ';' )
			{
				at_cmd_err_ret() ;
				return ;
			}
		}
		else
		{
			at_cmd_err_ret() ;
			return ;
		}
	}

	// In fax mode the local phone must be on-hook before dialing
	if ( G(x_modem_mode) == MODEM_FAX )
	{
		if (x_input(IO_LOCAL_PHONE_OFFHOOK))	// off-hook
		{
			// This condition happens on new designs often when the
			// platform doesn't have a local phone connection.  As a
			// temporary fix you can set S95=2048 to make this go
			// away.
			x_debug_msg("AT - local phone off hook, dial error");
			at_cmd_err_ret();
			return;
		}
		G(x_fax_state) = FAX_RX_HDLC ;
		G(x_fax_rate) = MR_300 ;   // FRH=3
		G(x_fax_v17) = NON_V17 ;
	}

	// if auto disconnect (at&d==2) then do not dial unless DTR is ON
	if (UART_dtr_blocked())
	{
		at_cmd_err_ret();
		return;
	}

	// DP uses a NULL termination to figure out when the dial string
	// ends so we'll just pass everything along.
	x_send_mail(MC_DIAL, DP_TASK, G(at_cmd_ptr), 0);

	// skip past the number so any additional commands
	// will work correctly
	while (*G(at_cmd_ptr) && *G(at_cmd_ptr) != ';')
		G(at_cmd_ptr)++;

	if (*G(at_cmd_ptr) == ';')
		G(at_cmd_ptr)++;
}

/****************************************************************
Routine : at_e
Description :
	ATE - Enable/Disable Echo to DTE
*****************************************************************/
void at_e(void)
{
	if (!at_error_for_bad(2))
		return;

	G(S).ModemOptions.EchoToDTE = ATE4BN;
	atparse_cmd();
}

/****************************************************************
Routine : at_hangup
Description :
	Disconnect any call in progress, hang up.

	Return:  TRUE means we'll give an OK message
		as part of the hangup.
		     FALSE means no OK message is given.
*****************************************************************/
byte at_hangup(void)
{
	if ((G(x_modem_mode) != MODEM_VOICE) &&
		(G(x_modem_mode) != MODEM_SPEAKER_PHONE) &&
		(G(x_modem_state) != MS_IDLE))
	{
		// This is the normal path for hanging up a data call in
		// progress.  It instructs the LAPM (or whatever) protocol to
		// shut down gracefully.
		x_send_mail(AT_IO_DISCONNECT, IO_TASK, 0, 0);
		return TRUE;
	}
	else
	{
		x_send_mail_dp1(MC_ONHOOK);
	}
	G(io_at_esc_detect) = FALSE ;
	return FALSE;
}

/****************************************************************
Routine : at_h
Description :
	ATH - Hook Control.
*****************************************************************/
void at_h(void)
{
	if (!at_error_for_bad(2))
		return;

	if (0 == ATE4BN)
	{
		// ATH - hangup - go onhook
		if (at_hangup() && *G(at_cmd_ptr) == 0)
			return;		// don't give two OK's.
	}
	else
	{
		// ATH1 - go offhook
		if ( ( G(S).ModemOptions.OffHookRestrict < 2 ) &&
			 ( ( G(x_modem_state) == MS_IDLE ) ||
			   ( G(x_modem_state) == MS_RING_INDICATE ) ) )
		{
			x_send_mail_dp1(MC_OFFHOOK);
		}
		else
		{
			// can't go offhook in this situation
			at_cmd_err_ret();
			return;
		}
	}

	atparse_cmd();
}

/****************************************************************
Routine : at_i
Description :
	ATI - Request ID Information
*****************************************************************/
void at_i(void)
{
    byte ver[25], len;
    word version;

	if (!at_error_for_bad(12))
		return;

	if (10 == ATE4BN)
	{
		// ATI10 is also an error.
		at_cmd_err_ret();
		return ;
    }

    switch (ATE4BN)
	{
    case 1: /* calculate ROM checksum and display it on DTE */
		at_output_hex(z80_checksum(TRUE));
		break ;
	
    case 2: /* verify checksum */
		x_send_mail(DSP_VERSION, DP_TASK, (byte *)&version, 2);
		if (version == 0)
		{
			at_cmd_err_ret();
			return;
		}
		break;

    case 0:
    case 3: /* Display product ID */
		at_display_id();
		break;
	    
    case 4: /* return data pump firmware version */
		x_send_mail (DSP_VERSION, DP_TASK, (byte *)&version, 2);
		len = (byte)at_itoa((word)version, ver, DECIMAL);
		at_output_msg (ver, (word)len);
		break;
	    
    case 5: // firmware ID, hardware version, country code
		x_send_at_io_crlf();
		x_send_at_io_data((byte *) VERSION_STR ",0,");
		at_itoa((word)G(S).ModemOptions.CountryId, ver, HEX);
		x_send_at_io_data((byte *) ver);
		x_send_at_io_crlf();
		break;
	
#ifdef DC0
    case 6: /* Cellular modem */
		if (G(S).ModemOptions.CountryId == NA
			|| G(S).ModemOptions.CountryId == CANADA)
		{
			byte *ptr;
			if (prnC == 2)
				ptr = "MOTOROLA Cell Phone Selected";
			else if (prnC == 3)
				ptr = "NEC Cell Phone Selected";
			else
				ptr = "No Cell Phone Selected";
			at_output_msg2(ptr);
		}
		break;
#endif
	
    case 9: /* Country ID and PnP code */
		at_output_msg2(G(S).ModemOptions.CountryIdStr);
#if defined(PNPSTRING)
		PnP_identify(TRUE);
#endif
		break;

    case 11: /* Diagnostics */
		G(at_view_more) = 10;
		at_diagnostics();
		return;
    }
    atparse_cmd();
}

/****************************************************************
Routine : at_l
Description :
	Speaker Volume
*****************************************************************/
void at_l(void)
{
	if (!at_error_for_bad(4))
		return;

	G(S).ModemOptions.SpeakerVolume = ATE4BN;

	// Speaker volume commands passed along and decision is made in
	// x_output() based on S.ModemOptions.SpeakerVolume.
	x_send_mail_dp1(MC_SPEAKER_LOW);
	atparse_cmd();
}

/****************************************************************
Routine : at_m
Description :
	Monitor Speaker Mode
*****************************************************************/
void at_m(void)
{
	if (!at_error_for_bad(4))
		return;

	G(S).ModemOptions.SpeakerControl = ATE4BN;

	switch (ATE4BN)
	{
	case 2:               // Speaker always on
		if ( (( G(x_modem_state) == MS_ON_DIAL ) ||
			  ( G(x_modem_state) == MS_OFFHOOK ))
			 && ( G(x_modem_mode) != MODEM_SPEAKER_PHONE )
			)
			x_send_mail_dp1(MC_SPEAKER_ON);
		break;
	case 0:               // Speaker always off
		if ( G(x_modem_mode) != MODEM_SPEAKER_PHONE )
			x_send_mail_dp1(MC_SPEAKER_OFF);
		break;
	}
	atparse_cmd();
}

/****************************************************************
Routine : at_n
Description :
	ATN command - Modulation Handshake
*****************************************************************/
void at_n(void)
{
	if (!at_error_for_bad(2))
		return;

	G(S).ModemOptions.AutoMode = G(S).ModemOptions.AutoRate = ATE4BN;
	atparse_cmd();
}

/****************************************************************
Routine : at_o
Description :
	ATO - Return Online to Data Mode.
*****************************************************************/
void at_o(void)
{
	if ( (G(x_modem_state) == MS_ON_DIAL) ||
		 (G(x_modem_state) == MS_LOCAL_TEST) ||
		 (G(x_modem_state) == MS_REM_TEST) )
	{
		switch(*G(at_cmd_ptr))
		{
		case '1':
			x_send_mail_dp1(DSP_RETRAIN);		// Retrain
			break ;
		case 0:
		case '0':
			// exit command mode and go to data mode.
			x_send_mail(AT_IO_ON_LINE, IO_TASK, NULL, 0);
			break ;
		case '3':
			x_send_mail_dp1(DSP_FAST_RETRAIN);	// Rate Renegotiation
			break ;
		default  :
			at_cmd_err_ret();
			return ;
		}
	}
	else
	{
		// Can't go on line unless we're connected to something.
		at_cmd_err_ret();
		return;
	}
}

/**************************************************************
Routine : at_p
Description:
	Select Pulse Dialing (if allowed)
****************************************************************/
void at_p (void)
{
	if ( G(S).ModemOptions.PulseDialPermited == 0 )    // allowed 
		G(S).ModemOptions.DialMode = 0 ;
	atparse_cmd();
}

/****************************************************************
Routine : at_q
Description :
	ATQ - Result Code Control
*****************************************************************/
void at_q(void)
{
	if (!at_error_for_bad(2))
		return;

	G(S).ModemOptions.ResultCode = ATE4BN;
	atparse_cmd();
}

/****************************************************************
Routine : at_t
Description :
	ATT - Select Tone Dialing
*****************************************************************/
void at_t(void)
{
	G(S).ModemOptions.DialMode = 1;
	atparse_cmd();
}

/****************************************************************
Routine : at_v
Description :
	ATV - DCE Response Format
*****************************************************************/
void at_v(void)
{
	if (!at_error_for_bad(2))
		return;

	G(S).ModemOptions.ResultCodeFormat = ATE4BN;	// numeric response
	atparse_cmd();
}

/****************************************************************
Routine : at_w
Description :
	ATW - Result Code Option
*****************************************************************/
void at_w(void)
{
	if (!at_error_for_bad(3))
		return;

	// (ATW1) set common things first, then overwrite below
	G(S).ModemOptions.ConnectDteRate = 1;
	G(S).ModemOptions.ExtResultCode = 1;

	switch (ATE4BN)
	{
	case 0:	// report DTE speed, disable protocol result code
		G(S).ModemOptions.ExtResultCode = 2 ;
		break;
	case 2:	// report DCE speed, enable protocol result code
		G(S).ModemOptions.ConnectDteRate = 0 ;
		break ;
	}
	atparse_cmd();
}

/****************************************************************
Routine : at_x
Description :
	ATX - Result Code Selection
*****************************************************************/
void at_x(void)
{
	if (!at_error_for_bad(8))
		return;

	// Start with everything enabled, then disable
	// as appropriate.
	G(S).ModemOptions.ExtResultCode = 1;
	G(S).ModemOptions.DialToneDetect = 1;
	G(S).ModemOptions.BusyToneDetect = 1;
	
	if (ATE4BN < 3)
	{
		// Busy Tone detection disabled if permitted
		if (G(S).ModemOptions.BusyDetectDisable)
			G(S).ModemOptions.BusyToneDetect = 0;
	}

	switch (ATE4BN)
	{
	case 0:
		G(S).ModemOptions.ExtResultCode = 0 ;
		// no break - fall through
	case 1:
	case 3:
		// dial tone detect disabled if permitted
		if (G(S).ModemOptions.BlindDialPermited)
			G(S).ModemOptions.DialToneDetect = 0 ;
		break;
	case 7:       //compatibility w/dataport
		G(S).ModemOptions.ExtResultCode = 0 ;
		break;

	}
	atparse_cmd();
}

#if defined (DC0) || defined (CS_ETC)
/****************************************************************/
//
//	init_ETC_defaults()
//
//	Description:  Common routine for at&f5 command
//
//
/****************************************************************/
void init_ETC_defaults ( void )
{
	G(ETC_mode) = ETC_MODE_CELL_MASK_BIT ;
	G(S).ModemOptions.ETC = 2 ; // #ETC MODE
	if ( G(S).ModemOptions.NoAnsTimeOut <= 90 )
		G(S).ModemOptions.NoAnsTimeOut = 90 ; // 9 seconds
	if ( G(S).ModemOptions.NoCarrierDisc <= 100 )
		G(S).ModemOptions.NoCarrierDisc = 100 ;
	if ( G(S).ModemOptions.wV34RxSymbol == V34_RX_SYMBOL_RATE )
		G(S).ModemOptions.wV34RxSymbol = 0x0013 ; // 2800 symbol rate and less.
	G(S).ModemOptions.DataCallingTone = 1 ; // enable
	if ( G(S).ModemOptions.V42 == V42_LAPM_BUFFER )
		G(S).ModemOptions.V42 = V42_LAPM_ONLY;
	G(S).ModemOptions.wV34MSEScale = 0x2200 ;
	G(S).ModemOptions.BusyPassCount = 2 ;
	// enable v.34 id detection for cell, and skip 6db power check option
	// V.34 ID detection for cellular is enabled
	G(S).ModemOptions.wV34Option = 0x021b ; 
}

/****************************************************************/
//
//	init_landline_ETC
//
//	Description:  Common routine for at&f5 command
//
//
/****************************************************************/
void init_landline_ETC ( void )
{
	if ( ( G(S).ModemOptions.DialLineRate == 0 ) ||
		 ( G(S).ModemOptions.DialLineRate > 15 ) ) 
		G(S).ModemOptions.DialLineRate = 15 ; // max. 24000 baud rate.
	G(S).ModemOptions.TxLevel = 15 ;	// -18 db
	G(S).ModemOptions.TransmitLevel = 15 ;	// -18 db
	init_ETC_defaults ();
}

#endif // DC0

/****************************************************************
Routine : at_z
Description :
	ATZ - recall stored profile from EEPROM

	ATZ, ATZ0, or ATZ1 all recall the same profile
*****************************************************************/
void at_z(void)
{
	if (!at_error_for_bad(2))
		return;

	x_init_modem_options();		// load factory options

	// load options from EEPROM if present
	ll_load_modem_options();

	at_hangup();

	G(x_modem_mode) = MODEM_DATA;		// set up the default modem mode
	x_send_mail_dp1(DP_RESUME);			// initialize data pump
	x_send_mail(MC_OPTION_CHANGE, IO_TASK, NULL, 0);	// update the leads

	// Ignore any characters following ATZ command - (no atparse_cmd())
	G(at_result_code) = OK;
	at_output_msg(NULL, 0);
}

/****************************************************************
Routine : at_and_c
Description :
	AT&C - Data Carrier Detect (DCD) Control
*****************************************************************/
void at_and_c(void)
{
	if (!at_error_for_bad(2))
		return;

	G(S).ModemOptions.CDControl = ATE4BN;
	x_send_mail(MC_OPTION_CHANGE, IO_TASK, NULL, 0);
}

/****************************************************************
Routine : at_and_d
Description :
	AT&D - DTR Control
*****************************************************************/
void at_and_d(void)
{
	if (!at_error_for_bad(4))
		return;

	G(S).ModemOptions.DTRControl = ATE4BN;
}

/****************************************************************
Routine : at_init_defaults
Description :
	Common routine for and_and_f command
****************************************************************/
void at_init_defaults(void)
{
	x_init_modem_options();
#if defined(CLASS2_FAX) || defined(CLASS20_FAX)
	io_fax_c2_init ();	  // Initialize class2 FAX function
#endif

	at_hangup();		// hang up - go onhook

	// set up the default modem mode
	G(x_modem_mode) = MODEM_DATA ;
}

/****************************************************************
Routine : at_and_f
Description :
	AT&F - Load Factory Settings
*****************************************************************/
void at_and_f(void)
{
#if defined(DC0) || defined(CS_ETC)
	if (!at_error_for_bad(6))
		return;

	if (5 == ATE4BN)
	{
		at_init_defaults();
		init_landline_ETC();
		return;
	}

	if (ATE4BN > 0)
	{
		at_cmd_err_ret();
		return;
	}
#else
	if (!at_error_for_bad(1))
		return;
#endif

	at_init_defaults();
	x_send_mail(MC_OPTION_CHANGE, IO_TASK, NULL, 0); // update the leads
}

/****************************************************************
Routine : at_and_g
Description :
	V.22bis Guard Tone Control.
*****************************************************************/
void at_and_g(void)
{
	if (!at_error_for_bad(3))
		return;

	if (G(S).ModemOptions.GuardToneType == 0)
		G(S).ModemOptions.GuardTone = ATE4BN;
}

/****************************************************************
Routine : at_and_m
Description :
	Asynchronous Communications Mode.
*****************************************************************/
void at_and_m(void)
{
	if (!at_error_for_bad(1))
		return;

	// Asynchronous mode (default)
	G(S).ModemOptions.V42 = V42_BUFFER_MODE;  // Buffer mode
}

/****************************************************************
Routine : at_and_p
Description :
	Pulse Dial Make-to-Break Ratio Selection

	This command is effective only for Japan
*****************************************************************/
void at_and_p(void)
{
	if (!at_error_for_bad(3))
		return;

#if defined(HOMOL)
	if ( G(S).ModemOptions.CountryId == JAPAN )
	{
		switch(ATE4BN)
		{
		case 0:
			// 39/61 make/break ratio, 10PPS
		case 1:
			// 33/67 make/break ratio, 10PPS (default)
			G(S).ModemOptions.PulseDial20pps &= 0xBF ;    // set bit 6 to 0
			break;
		case 2:
			// 33/67 make/break ratio, 20PPS
			G(S).ModemOptions.PulseDial20pps |= 0x40 ;  // set bit 6 to 1
			break;
		}
	}
#endif // HOMOL
}

#ifdef SYNCH_MODE
	extern void dp_synch_patch_download(void);
	extern byte syncBaudRate;
	extern byte syncTimingMode;
	extern BOOL q2Dial;
	extern BOOL q3Dial;
	extern void dial_q2(void);
	extern void dial_q3(void);
	extern void	q2_dial_loop(void);
	extern void valv_setup(void);
	extern non_banked void dp_write_dsp_ram ( word loc, word value ) ;
#endif

/****************************************************************
Routine : at_and_q
Description :
	Asynchronous Communications Mode
*****************************************************************/
void at_and_q(void)
{
	if (!at_error_for_bad(10))
		return;

	switch(ATE4BN)
	{
#ifdef SYNCH_MODE
	case 1:
		G(at_cmd_ptr)++;
		dp_synch_patch_download();
		dp_write_dsp_ram ( 0xf21,0xe000 ) ; /* enable synch mode patch */
		G(S).ModemOptions.V42 = V42_SYNCH_MODE ; // Synchronous Mode
		syncBaudRate = 0;	// set auto select as default
		if ((syncTimingMode != '2')&&(syncTimingMode != '3'))
			syncTimingMode = '1'; // set free-running mode as default
		q2Dial = FALSE;
		q3Dial = FALSE;
		break;
	case 2:
		G(at_cmd_ptr)++;
		dp_synch_patch_download();
		dp_write_dsp_ram ( 0xf21,0xe000 ) ; /* enable synch mode patch */
		G(S).ModemOptions.V42 = V42_SYNCH_MODE ; // Synchronous Mode
		syncBaudRate = 0;	// set auto select as default
		if ((syncTimingMode != '2')&&(syncTimingMode != '3'))
			syncTimingMode = '1'; // set free-running mode as default
		q2Dial = TRUE;
		break;
	case 3:
		G(at_cmd_ptr)++;
		dp_synch_patch_download();
		dp_write_dsp_ram ( 0xf21,0xe000 ) ; /* enable synch mode patch */
		G(S).ModemOptions.V42 = V42_SYNCH_MODE ; // Synchronous Mode
		syncBaudRate = 0;	// set auto select as default
		if ((syncTimingMode != '2')&&(syncTimingMode != '3'))
			syncTimingMode = '1'; // set free-running mode as default
		q3Dial = TRUE;
		break;
#endif
	case 8:
		// MNP error control mode
		if (0 == (G(S).ModemOptions.NegotiationFallback & 1))
			G(S).ModemOptions.V42 = V42_MNP_DISC ;
		else
			G(S).ModemOptions.V42 = V42_MNP_BUFFER ;
		break ;
	case 9:
		// V.42 or MNP error control mode
		if (0 == (G(S).ModemOptions.NegotiationFallback & 1))
			G(S).ModemOptions.V42 = V42_LAPM_MNP_DISC ;
		else
			G(S).ModemOptions.V42 = V42_LAPM_MNP_BUFFER ;
		break ;
	case 5:
		// Error control mode, same as \N3 (default)
		G(S).ModemOptions.V42 = V42_LAPM_MNP_BUFFER ;  // LAPM, MNP or buffer
		break ;
	case 6:
	case 0:
		G(S).ModemOptions.V42 = V42_BUFFER_MODE ;  // Buffer mode
		break;
	default:
		at_cmd_err_ret();
		return;
	}
}

/****************************************************************
Routine : at_and_s
Description :
	Data Set Ready (DSR) Option
*****************************************************************/
void at_and_s(void)
{
	if (!at_error_for_bad(2))
		return;

	G(S).ModemOptions.DSRControl = ATE4BN;
	x_send_mail(MC_OPTION_CHANGE, IO_TASK, NULL, 0);
}

/****************************************************************
Routine : at_and_w
Description :
	Store current configuration in EEPROM.
*****************************************************************/
void at_and_w(void)
{
#ifdef DC0 // do not allow user to save parameters during cell call.
	if ( (G(cell_active) == TRUE) &&  ( G(x_modem_state) == MS_ON_DIAL ) )
	{
		at_cmd_err_ret();
		return;
	}
#endif
	if (!at_error_for_bad(1))
		return;

	// if eeprom present - save options - else return error
	if (ll_save_modem_options())
	{
		G(at_result_code) = OK;
	}
	else
	{
		at_cmd_err_ret();
		return;
	}
}

/****************************************************************
Routine : at_and_z
Description :
	This function process the AT&Zn=x command: store number
*****************************************************************/
void at_and_z(void)
{
	byte i;

	if (!at_error_for_bad(MAX_PHONE_NUMBERS))
		return;

	i = ATE4BN;

	/* now we should see an '=' */
	if (*G(at_cmd_ptr) != '=')
	{
		at_cmd_err_ret ();
		return;
	}
	G(at_cmd_ptr)++ ;

	// make sure the number's not too long to fit in its spot
	if (x_strlen(G(at_cmd_ptr)) > MAX_PHONE_LENGTH)
	{
		at_cmd_err_ret();
		return;
	}

	// try to save the number
	if (store_number(i, G(at_cmd_ptr)) == FALSE)
	{
		at_cmd_err_ret();
		return;
	}

	G(at_result_code) = OK;
	at_output_msg(NULL, 0);
}

/***************************************************************
Routine : at_and
Description :
	Parse the "at&" commands.

	This assumes that we need to keep on parsing
	after the current command unless we've hit
	an error.

	Thus, the functions called here that
	break to the end of this function should NOT
	call atparse_cmd() on their own.
*****************************************************************/
void at_and(void)
{
	switch (*G(at_cmd_ptr)++)
	{
	case 'C':
		at_and_c(); break;
	case 'D':
		at_and_d(); break;
	case 'F':
		at_and_f(); break;
	case 'G':
		at_and_g(); break;
	case 'M':
		at_and_m(); break;
	case 'P':
		at_and_p(); break;
	case 'Q':
		at_and_q(); break;
	case 'S':
		at_and_s(); break;
	case 'T':
		at_and_t(); return;
	case 'V':
		at_and_v(); return;
	case 'W':
		at_and_w(); break;
	case '&':
		at_and_and(); return;
	case 'B':
		// AT&B - Disabling V.32 auto retrain isn't supported but
		// we'll accept enabling it AT&B1.  This is the same as the
		// behavior for ATF where we accept ATF1 but don't do anything
		// with it.
		at_f(); return;
	case 'J':
		at_and_j(); break;
	case 'K':
		at_and_k(); break;
	case 'R':
		at_dummy(); break;
	case 'Y':
		// AT&Y - Select Stored Profile for Hard Reset.
		// We'll accept AT&Y0 but do nothing with the
		// info.  This is the same as the behavior
		// of the AT&J command.
		at_and_j(); break;
	case 'Z':
		at_and_z(); return;
	default:
		at_cmd_err_ret();
		break;
	}

	if (ERROR != G(at_result_code))
	{
		atparse_cmd();
	}
}

/****************************************************************
Routine : at_backslash_a
Description :
	Select Maximum MNP Block Size
*****************************************************************/
void at_backslash_a(void)       //change maximum MNP packet size
{
	if (!at_error_for_bad(4))
		return;

	switch(ATE4BN)
	{
	case 0:
		G(S).ModemOptions.MNPMaxOctets = 64 ;
		break;
	case 1:
		G(S).ModemOptions.MNPMaxOctets = 128 ;
		break ;
	case 2:
		G(S).ModemOptions.MNPMaxOctets = 192 ;
		break ;
	case 3:
		G(S).ModemOptions.MNPMaxOctets = 250 ;  // should be 256
		break ;
	}
}

/****************************************************************
Routine : at_backslash_n
Description :
	Error Control Mode Selection
*****************************************************************/
void at_backslash_n(void)
{
	switch( *G(at_cmd_ptr)++ )
	{
	case '0':
	case '1':
		G(S).ModemOptions.V42 = V42_BUFFER_MODE ;  // Buffer mode
		break ;
	case '2':
		G(S).ModemOptions.V42 = V42_MNP_DISC ; // MNP or disconnect
		break ;
	case '5':       //Accucom compatability
	case '3':
	case '7':       //Dataport compatability
		G(S).ModemOptions.V42 = V42_LAPM_MNP_BUFFER ;  // LAPM, MNP or buffer
		break ;
	case '4':
		G(S).ModemOptions.V42 = V42_LAPM_ONLY ;
		break ;

	case '6':
	case '8':
	case '9':
		at_cmd_err_ret();
		return;

	default:
		G(S).ModemOptions.V42 = V42_BUFFER_MODE;
		G(at_cmd_ptr)--;
		break;
	}
}

/****************************************************************
Routine : at_backslash_v
Description :
	Protocol Result Code
*****************************************************************/
void at_backslash_v(void)
{
	if (!at_error_for_bad(3))
		return;

    switch (ATE4BN)
	{
	case 0:
		// Disable protocol result appended to DCE speed.
		G(S).ModemOptions.ExtResultCode = 2 ;
		break;
	case 1:
	case 2:
		// Enable protocol result appended to DCE speed (default).
		G(S).ModemOptions.ExtResultCode = 1 ;
		break ;
	}
}

/****************************************************************
Routine : at_backslash_t
Description :
	Inactivity Timer.

	Length of time (in minutes) to wait before disconnecting
	when no data is sent or received.  A setting of zero disables
	the timer.  Alternatively, this timer may be set in register
	S30.
*****************************************************************/
void at_backslash_t(void)
{
	word tmp_timer;
	byte len;

	len = (byte) at_atoi( G(at_cmd_ptr), &tmp_timer,DECIMAL);
	if ( tmp_timer <= 255 )
	{
		G(at_cmd_ptr) += len ;
		G(S).ModemOptions.InactivityTimer = (byte)tmp_timer ;
	}
	else
	{
		at_cmd_err_ret();
		return;
	}
}

/****************************************************************
Routine : at_backslash_x
Description :
	XON/XOFF Pass Through

	(Command is here but the code doesn't do anything
	with this option currently - 07/19/2000.)
*****************************************************************/
void at_backslash_x ( void )
{
	if (!at_error_for_bad(2))
		return;
}

/****************************************************************
Routine : at_backslash
Description :
	This routine parses the "at\" commands.
*****************************************************************/
void at_backslash(void)
{
	switch(*G(at_cmd_ptr)++)
	{
	case 'A':
		at_backslash_a(); break;
	case 'B':
		at_backslash_b(); break;
	case 'N':
		at_backslash_n(); break;
	case 'V':
		at_backslash_v(); break;
	case 'T':
		at_backslash_t(); break;
	case 'G':
	case 'X':
		at_backslash_x(); break;
	case 'J':
		at_backslash_j(); break;
	case 'K':
		at_backslash_k();
		break;
	case 'Q':
		at_backslash_q(); break;
	case 'R': 
		at_and_j(); 	break;
	case 'D':
	case 'O':
	case 'U':
	case 'Y':
	case 'Z':
		at_dummy(); break;
	default:
		at_cmd_err_ret();
		break;
	}

	if (ERROR != G(at_result_code))
	{
		atparse_cmd();
	}
}


#ifdef HOMOL

#if defined(VENUS_WORLD_DAA) && defined(DC0)
/****************************************************************
Routine : at_percent_g	=>	AT%G
Description :
	All commands to turn on/off GSM PSTN interface 
	
*****************************************************************/
void at_percent_g ( void )
{
	if (!at_error_for_bad(3))
		return;

	switch (ATE4BN)
	{
	case 0:
		at_cmd_err_ret(); //send error msg 
		break ;
	case 1 : 
		x_output(IO_PSTN_ON);
		break ;
	case 2 :
		x_output(IO_PSTN_OFF);
		break ;
	}
	atparse_cmd();
}
#endif // VENUS_WORLD_DAA && DC0

/****************************************************************
Routine : at_percent_b
Description :
	AT%B - View Numbers in Blacklist
*****************************************************************/
void at_percent_b(void)
{
	if (G(S).ModemOptions.BlackListFlag)
	{
		x_send_mail_dp1(DP_SHOW_BLACKLIST);
		atparse_cmd();
	}
	else
		at_cmd_err_ret();
}
#endif  // HOMOL

/****************************************************************
Routine : at_percent_c
Description :
	Data Compression Control
*****************************************************************/
void at_percent_c(void)
{
	if (!at_error_for_bad(2))
		return;

	if (0 == ATE4BN)
	{
		// Disable Compression
		G(S).ModemOptions.Compression = 0;
	}
	else
	{
		// Enable Compression
		G(S).ModemOptions.Compression = MNP_COMP | V42BIS_COMP;

#if defined(V44)
#if defined(MODEM_Z80)
		// don't allow V.44 unless V92 capable
		if (1 & z80_v92cap)
#endif // MODEM_Z80
			G(S).ModemOptions.Compression |= V44_COMP;
#endif // V44
	}

	atparse_cmd();
}

/****************************************************************
Routine : at_percent_e
Description :
	Enable/Disable Auto-Retrain and Fallback/Fallforward
*****************************************************************/
void at_percent_e(void)
{
	if (!at_error_for_bad(3))
		return;

	// set common things first, then overwrite below
	// Enable fallback, disable fallforward
	G(S).ModemOptions.DisableFallForward = 1;
	G(S).ModemOptions.AutoRate = 1;

    switch (ATE4BN)
	{
	case 0:
		// Disable both
		G(S).ModemOptions.AutoRate = 0;
		break;
	case 2:
		// Enable both (default)
		G(S).ModemOptions.DisableFallForward = 0 ;
		break;
	}
	atparse_cmd();
}

/****************************************************************
Routine : at_dash - (processes only the AT-Cn command)

	Data Calling Tone
*****************************************************************/
void at_dash(void)
{
	if (!at_error_for_bad(2))
		return;

	if ( G(S).ModemOptions.CallingToneFlag == 1 )
		G(S).ModemOptions.DataCallingTone = ATE4BN;

	atparse_cmd();
}

/****************************************************************
Routine : at_percent
Description :
	This routine parses the "at%" commands.
*****************************************************************/
void at_percent(void)
{
	switch(*G(at_cmd_ptr)++)
	{
	case 'C':
		at_percent_c(); break;
#ifdef HOMOL
	case 'B':
		at_percent_b(); break;
#endif
#if (defined( PNPSTRING ) && !defined( ROM )) || defined( PCMCIA_MODEM )
	case 'P':
		at_percent_p(); break;
#endif
	case 'T':
		at_percent_t(); break;
	case 'E':
		at_percent_e(); break;
#if defined(HAYES_MODEMZ80)
	case 'F':
		// obsolete Z80 upgrade stuff
		at_percent_f(); break;
#endif // HAYES_MODEMZ80
#if defined(VENUS_WORLD_DAA) && defined(DC0)
	case 'G':
		at_percent_g(); break;
#endif
	default:
		at_cmd_err_ret();
		break;
	}
}

/****************************************************************
Routine : at_data_compression
Description :
	This routine process the ( at"Hn ) commands. Same as AT%Cn
*****************************************************************/
void at_data_compression(void)
{
	switch(*G(at_cmd_ptr)++)
	{
	case 'H':
		at_percent_c(); break;
	default:
		at_cmd_err_ret();
		break;
	}
}
