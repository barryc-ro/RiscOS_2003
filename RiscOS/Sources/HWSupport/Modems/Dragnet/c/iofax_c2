/*name and version number:@(#)iofax_c2.c	1.80*/
/*date of get: 		  12/15/00 10:10:36*/
/*date of delta:	  11/30/00 22:20:15*/
/****************************************************************
File :  iofax_c2.c
Description :
	Contains state machine for Class II FAX.

Procedures Contained :

Revision History :
	Initials        Date            Change
	S.J. Busak     08/19/96         Initial Version
	S.J. Busak     02/03/98         Added Central Site capability
	S.J. Busak		 09/02/98			    Added Class 2.0 sub-set for Wireless FAX
	S.J. Busak     10/19/98         Allow Class 2 and Class 2.0 in same build plus more IWF enhancments
	S.J. Busak     11/18/98         Added Non-standard facilities and polling; Use ANSI form for functions
	S.J. Busak     01/20/99         Ported Central Site features to Client
	JMG		         07/01/99	        Modified to accept V34 Fax Functions
	S.J. Busak		 09/13/99					Add changes to use V.34 modulation
	S.J. Busak     11/05/99         Add changes for CS-4
	S.J. Busak     12/01/99         Add changes to use 64K ECM buffer for CS-4 builds
	S.J. Busak     03/21/00					Add support for all VR, WD and DF values
  S.J. Busak     05/26/00	        Add support for color FAX JP values

*****************************************************************/

#include "llglob_d.h"

#if defined (CLASS2_FAX) || defined (CLASS20_FAX)
	#include "ioglob_d.h"
	#include "v42bis.h"
	#include "dpglob.h"
	#include "z80glob.h"
	//	#define FAX_DEBUG           // Uncomment for FAX debug messages
	#include "fax_c2.h"

	#ifdef FAX_ECM
		#include "fax_ecm.h"   
	#endif

	#ifdef CS_MODEM
		#include "csglob.h"		 // Command/Response definitions for CS
		#define OK       0
		#define CONNECT  1
	#else
		#include "atglob.h"
	#endif

	#ifdef V34_FAX
		#include "faxv34.h"
	#endif                 

	#include "allglobs.h"    // MUST BE LAST IN #include LIST!

// ------------------------------------------------------- //
// Static T.30 Responses and Commands (Reversed Bit Order) //
// ------------------------------------------------------- // 

#define RSP_DIS     0x80    // Initial Identification...
#define RSP_CSI     0x40
#define RSP_NSF     0x20

#define RSP_DTC     0x81    // Command to Send...
#define RSP_CIG     0x41
#define RSP_NSC     0x21
#define RSP_PPWD    0xC1    // (Password for polling)
#define RSP_SEP     0xA1   

// --------------------------------------------------------------------------------------- //
// T.30 Responses and Commands with Dynamic Bits (Reversed Bit Order, dynamic bit cleared) //
// --------------------------------------------------------------------------------------- // 
//   Format: b7 b6 b5 b4 b3 b2 b1 X
//     X is set to '1' for the Originating modems
//     X is set to '0' for the Answer modems                           

#define RSP_DCS     0x82   // Command to Receive...
#define RSP_TSI     0x42
#define RSP_NSS     0x22
#define RSP_SUB     0xC2
#define RSP_TPWD    0xA2   // (Password for transmission)

#define RSP_CFR     0x84   // Pre-message Response Signals...         
#define RSP_FTT     0x44

#define PPM_EOM     0x8E   // Post-Message Commands...                 
#define PPM_MPS     0x4E
#define PPM_EOP     0x2E
#define PPM_PRI_EOM 0x9E
#define PPM_PRI_MPS 0x5E
#define PPM_PRI_EOP 0x3E

#define RSP_MCF     0x8C   // Post-Message Responses...
#define RSP_RTP     0xCC
#define RSP_RTN     0x4C
#define RSP_PIP     0xAC
#define RSP_PIN     0x2C

#define RSP_DCN     0xFA   // Other line control signals...
#define RSP_CRP     0x1A

#define DYNAMIC_BIT ((G(c2rf.flag) & T30_BIT) ? 1 : 0)   

// --------------------------------- //  
// DTE <-> DCE Single Byte Commands: //
// --------------------------------- //

#define DC2         0x12
#define CAN         0x18

/* ------------------- */
/* Function Prototypes */
/* ------------------- */

static void org_init          (void);
static void look_4_dis        (void);
static void decode_cfr_ftt    (void);
static void wait_4_fifo_empty (void);
static void chk_fax_c2_timer  (void);

static void chk_dte_abort     (void);
static void start_page_tx     (void);
static void send_page_data    (void);
static void send_rtc          (void);
static void setup_rx_ppr      (void);
static void decode_ppr        (void);
static void turn_off_pump     (void);
static void send_ppm          (void);
static void send_disconnect   (void);

static void start_tcf         (void);
static void end_tcf           (void);
static void send_csi_dis      (void);
static void send_dte_dcs      (void);
static void send_hdlc_cmd     (byte);

static void answer_init            (void);
static void send_modem_id          (byte);
static void look_4_dcs             (void);
static void rx_tcf                 (void);
static void wait_till_carrier_gone (void);
static void t30_delay              (void);
static void send_cfr_ftt           (void);
static void wait_4_1st_eol         (void);

static void rx_page_data        (void);
static void decode_ppm          (void);
static void wait_4_dte_cmd      (void);
static void set_state_after_mcf (void);
static void check_dcn           (void);
static void end_of_call         (void);
static void check_no_cfr_ftt    (void);
static void check_no_ppr        (void);
static void send_tsi_dcs        (void);   
static void send_mcf            (void);

static void process_fet         (void);
static void cl2_at_bg           (void);
static void process_phcto       (void);
static void next_state          (void);
static void init_rx_page        (void);
static void send_tsi            (byte, word*);
static void t2_delay            (void);
static void t3_delay            (void);
static void mslt_fill           (void);

static void send_opt_cmds       (void);
static void display_opt_rsp     (byte);
static void send_add_poll       (byte);
static void send_fnss           (byte);
static byte load_dte_rsp        (byte, byte *);
static void load_rsp_str        (byte, word*);
static void load_rsp_nsf        (byte, word*);
static void load_rsp_cmpd       (byte, byte*);
static void load_rsp_ind        (byte);
static void cs_fax_response     (byte);
static byte com_ppr             (void);

static void ignore_dis          (byte);
static void start_org_state     (void);
static void wait_4_cmd          (void);
static void wait_4_rsp          (void);
static byte get_t30_cmd         (void);
static byte get_t30_rsp         (void);
static void send_fcon           (void);
static byte chk_t30_tmrs        (void);

// ------------------- //
// Tables of constants //
// ------------------- //

static const byte non_v17 [] = {0x00, 0x08, 0x0C, 0x04, 0x18, 0x10};	 // Encode bit rate for DCS, non V.17 modulations
static const byte v17 [] =     {0x00, 0x08, 0x2C, 0x24, 0x28, 0x20};	 // Encode bit rate for DCS, V.17 modulations
static const byte rate [] =    {MR_2400, MR_4800, MR_7200, MR_9600, MR_12000, MR_14400}; // Convert DIS bit rate to pump bit rate

static const byte dcs_rate [] =   // Convert T.30 DCS BR to Class 2/2.0 BR value
{
	0, 3, 1, 2,    5, 0xFF,    4, 0xFF,  // V.27-2400; V.29-9600; V.27-4800; V.29-7200; V.33-14400; Invalid; V.33-12000; Invalid
	5, 3, 4, 2, 0xFF, 0xFF, 0xFF, 0xFF   // V.17-14400; V.17-9600; V.17-12000; V.17-7200; Invalid; Invalid; Invalid; Invalid
};

// Indexes into response pointer table:
#define FCSI  0
#define FCON  1
#define FDCS  2
#define FET   3
#define FHNG  4
#define FDIS  5
#define FNSC  6
#define FNSF  7
#define FNSS  8
#define FCIG  9
#define FPOLL 10
#define FPTS  11
#define FDTC  12
#define FTSI  13
#define FCFR  14

#define FPA   15
#define FPW   16
#define FSA   17

#define FHR   18
#define FHT   19
#define FVO   20
#define FDM   21
#define FFD   22

#ifdef CS_MODEM
	struct CS_RSP
	{
		byte pid;
		byte len;
	};

	static const struct CS_RSP rsp_tbl_cs[] =
	{
		{CS_FCSI, 20},    
		{CS_FCON, 0},
		{CS_FDCS, 8},
		{CS_FET,  1},
		{CS_FHNG, 1},
		{CS_FDIS, 8},
		{CS_FNSC, 100},
		{CS_FNSF, 100},
		{CS_FNSS, 100},
		{CS_FCIG, 20},
		{CS_FPOLL, 0},
		{CS_FPTS, 1},
		{CS_FDTC, 8},
		{CS_FTSI, 20},
		{CS_FCFR, 0},
		{CS_FPA, 20},
		{CS_FPW, 20},
		{CS_FSA, 20}
	};

#else  // CLIENT
// NOTE: Defining the responses outside of rsp_tbl2[] puts the strings in
//       the CONST segment instead of the CSTR segment.  This prevents
//       CSTR segment overflow problems.  If the strings were declared
//       as part of the rsp_tabl2[] declaration, the compiler puts
//       the strings in CSTR segment and causes a segment overflow.

//       The same thing applies for rsp_tlb20[].

	static const byte fcsi_rsp[] = "+FCSI:";
	static const byte fcon_rsp[] = "+FCON";
	static const byte fdcs_rsp[] = "+FDCS:";
	static const byte fet_rsp[]  = "+FET:" ;
	static const byte fhng_rsp[] = "+FHNG:";
	static const byte fdis_rsp[] = "+FDIS:";
	static const byte fnsc_rsp[] = "+FNSC:";
	static const byte fnsf_rsp[] = "+FNSF:";
	static const byte fnss_rsp[] = "+FNSS:";
	static const byte fcig_rsp[] = "+FCIG:";
	static const byte fpoll_rsp[]= "+FPOLL";
	static const byte fpts_rsp[] = "+FPTS:";
	static const byte fdtc_rsp[] = "+FDTC:";
	static const byte ftsi_rsp[] = "+FTSI:";
	static const byte fcfr_rsp[] = "+FCFR";

	static const byte* const rsp_tbl2[] =    // NOTE: Declaration puts table in CONST segment
	{
		fcsi_rsp,
		fcon_rsp,
		fdcs_rsp,
		fet_rsp,
		fhng_rsp,
		fdis_rsp,
		fnsc_rsp,
		fnsf_rsp,
		fnss_rsp,
		fcig_rsp,
		fpoll_rsp,
		fpts_rsp,
		fdtc_rsp,
		ftsi_rsp,
		fcfr_rsp
	};

	#ifdef CLASS20_FAX
		static const byte fci_rsp[] = "+FCI:";
		static const byte fco_rsp[] = "+FCO";
		static const byte fcs_rsp[] = "+FCS:";
		static const byte fhs_rsp[] = "+FHS:";
		static const byte fis_rsp[] = "+FIS:";
		static const byte fnc_rsp[] = "+FNC:";
		static const byte fnf_rsp[] = "+FNF:";
		static const byte fns_rsp[] = "+FNS:";
		static const byte fpi_rsp[] = "+FPI:";
		static const byte fpo_rsp[] = "+FPO" ;
		static const byte fps_rsp[] = "+FPS:";
		static const byte ftc_rsp[] = "+FTC:";
		static const byte fti_rsp[] = "+FTI:";
		static const byte fcf_rsp[] = ""     ;    // CFR not used for Class 2.0
		static const byte fpa_rsp[] = "+FPA:";
		static const byte fpw_rsp[] = "+FPW:";
		static const byte fsa_rsp[] = "+FSA:";

		static const byte* const rsp_tbl20[] =    // NOTE: Declaration puts table in CONST segment
		{
			fci_rsp,
			fco_rsp,
			fcs_rsp,
			fet_rsp,
			fhs_rsp,
			fis_rsp,
			fnc_rsp,
			fnf_rsp,
			fns_rsp,
			fpi_rsp,
			fpo_rsp,
			fps_rsp,
			ftc_rsp,
			fti_rsp,
			fcf_rsp,
			fpa_rsp,
			fpw_rsp,
			fsa_rsp
		};
	#endif
#endif

// --------------------- //
// State Sequence Tables //
// --------------------- //

static const PFV org_sequence [] =	 // NOTE: Declaration locates array in EPROM for Z80 code
{
	org_init,					 //         0: Initialize originate mode
	wait_4_cmd,				 // ORG11:  1: Wait for NSF, CSI or DIS
	look_4_dis,				 // ORG0:   2: Decode NSF, CSI or DIS
	wait_4_dte_cmd,			 //	      3: Wait for DTE to send +FDT
	wait_till_carrier_gone, //	      4: Wait for remote fax to turn off carrier
	setup_hdlc_tx,			 // ORG1:   5: Setup modem to Tx HDLC @ 300 bps
	send_tsi_dcs,				 //         6: Send TSI & DCS to remote modem
	wait_4_fifo_empty,		 //         7: Wait for messge to clear buffer
	t30_delay,					 //         8: Delay before sync Tx
	start_tcf,					 //		   9: Start sending 0's for 1.5 seconds
	end_tcf,					 //	     10: Stop training sequence
	wait_4_rsp,				 //		  11: Wait for CFR or FTT response
	decode_cfr_ftt,			 //		  12: Evaluate response
	wait_till_carrier_gone, //		  13: Wait for remote fax to turn off carrier
	t30_delay,					 // ORG10: 14: Delay before page Tx
	start_page_tx,			 //		  15: Start page Tx
	send_page_data,			 // ORG15: 16: Send page data
	wait_4_dte_cmd,			 //		  17: Wait for DTE to send +FET=n
	send_rtc,					 // ORG7:  18: Append RTC to page data
	wait_4_fifo_empty,		 //		  19: Wait for RTC to clear pump
	t30_delay,					 //		  20: Delay between sync & HDLC
	setup_hdlc_tx,			 // ORG2:  21: Setup modem to Tx HDLC @ 300 bps
	send_ppm,					 //        22: Send post-page message
	wait_4_fifo_empty,		 //		  23: Wait for the current message to clear the modem
	setup_rx_ppr,				 //		  24: Setup to receive post-page response
	wait_4_rsp,				 //		  25: Wait for post-page response
	wait_till_carrier_gone, //		  26: Wait for remote fax to turn off carrier
	decode_ppr,				 //		  27: Decode post-page response
	wait_4_dte_cmd,			 //	ORG16 28: Wait for new command from DTE
	process_fet,				 //		  29: Process +FET:n command from AT task
	setup_hdlc_tx,			 // ORGX:  30: Setup modem to Tx HDLC @ 300 bps
	send_disconnect,			 //        31: Send DCN to remote modem
	wait_4_fifo_empty,		 //		  32: Wait until message clear the modem
	end_of_call,				 // ORG6:  33: Send +FHNG to DTE
	turn_off_pump,			 // ORG9:  34: Disconnect link

	t3_delay,					 // ORG13: 35: Delay for procedure interrupt
#ifndef FAX_ECM
	mslt_fill					 // ORG14: 36: Add fill characters to dce_tx_buffer to meet MSLT
#else
	mslt_fill,					 // ORG14: 36: Add fill characters to dce_tx_buffer to meet MSLT
	ecm_mode            // ORG_ECM: 37: Transmit page data using ECM
#endif

};

// Labels for originate sequence above

#define ORG0 2
#define ORG1 5
#define ORG2 21
#define ORGX 30
#define ORG6 33
#define ORG7 18
#define ORG9 34
#define ORG10 14
#define ORG11 1
#define ORG12 23
#define ORG13 35  
#define ORG14 36
#define ORG15 16
#define ORG16 28
#define ORG_ECM 37

// ANSWER SEQUENCE

static const PFV ans_sequence [] =	 // NOTE: Declaration locates array in EPROM for Z80 code
{
	answer_init,				 //		   0: Initialize state machine for answer
	setup_hdlc_tx,			 // ANS0:   1: Setup modem to Tx HDLC @ 300 bps
	send_csi_dis,				 //         2: Send CSI & DIS to remote modem
	wait_4_fifo_empty,		 // ANS1:   3: Wait until the DCE Tx fifo is empty
	setup_hdlc_rx,			 // ANS7:   4: Setup modem to Rx HDLC @ 300 bps
	wait_4_rsp,				 // ANS2:   5: Wait for a messge from remote modem
	look_4_dcs,				 //         6: Process NSS, TSI and/or DCS
	setup_sync_rx, 			 //         7: Configure modem to Rx synchronous data
	rx_tcf,						 //         8: Receive the TCF sequence
	wait_till_carrier_gone, //         9: Wait for carrier to turn off
	t30_delay,					 //        10: Delay 75 ms
	setup_hdlc_tx,			 //        11: Configure modem for Tx HDLC @ 300 bps
	send_cfr_ftt,				 //        12: Send CFR/FTT response
	wait_4_fifo_empty,		 //		  13: Wait for CFR/FTT to clear buffer
	setup_sync_rx,			 // ANS3:  14: Configure modem to Rx synchronous data
	wait_4_1st_eol,			 //        15: Wait until 1st EOL detected
	rx_page_data,				 // 	     16: Receive FAX page data
	wait_till_carrier_gone, //		  17: Wait until the carrier goes away
	setup_hdlc_rx,			 //        18: Setup modem to TX post page response
	wait_4_cmd, 				 //		  19: Wait for post-page message
	decode_ppm,   			 //		  20: Decode the post-page message
	wait_till_carrier_gone, //		  21: Wait until remote fax turns off carrier
	wait_4_dte_cmd,			 //		  22: Wait for a command from the DTE
	setup_hdlc_tx,			 // ANS6:  23: Setup modem to Tx HDCL @ 300bps
	send_mcf,					 //		  24: Send MCF/RTN/RTP to remote modem
	wait_4_fifo_empty,		 //		  25: Wait for message to clear modem
	set_state_after_mcf,	 //		  26: Set proper state after MCF/FTT sent
	setup_hdlc_rx,			 //		  27: Setup modem to Rx HDLC @ 300bps
	wait_4_cmd,				 //		  28: Wait for DCN
	check_dcn,					 //		  29: Check if DCN
	end_of_call,				 // ANSX:  30: Send +FHNG to DTE
	turn_off_pump,			 //		  31: Disconnect link

#ifndef FAX_ECM
	t2_delay					   // ANS5:  32: Wait for timer T2 to expire
#else
	t2_delay,					 // ANS5:  32: Wait for timer T2 to expire
	ecm_mode            // ANS_ECM: 33: Receive page data using ECM
#endif
};

// Lables for answer sequence above

#define ANS0 1
#define ANS1 3
#define ANS2 5
#define ANS3 14
#define ANS5 32
#define ANSX 30
#define ANS6 23
#define ANS7 4
#define ANS8 27
#define ANS_ECM 33  

// ************************************ //
// Main, periodic task for Class II FAX //
// ************************************ //

byte io_fax_c2_background (void)
{
	chk_fax_c2_timer ();					// Check for state time-out
	chk_dte_abort ();						// Check for DTE abort request
	cl2_at_bg ();							// Process AT-Commands, if enabled
	CALL(G(c2_sequence)[G(c2_sequence_ptr)]);  	// Vector to currently active state
	return (G(c2s.flag) & FAX_ACTIVE);	// Return FAX status
}

// *********************************************************** //
//                      ORIGINATE MODE						   //
// *********************************************************** //

// --------------------------------------------------------- //
// Initialize task to look for DIS, NSF and/or CSI responses //
// --------------------------------------------------------- //

void org_init (void)
{
	byte i;

	if ( (G(x_fax_state) == FAX_RX_HDLC)			 // V.17, V.33, V.29 or V.27 Originate mode?
#ifdef V34_FAX
				|| (G(x_fax_v34mode) == V34_SOURCE)      // V.34 Originate mode?
#endif
			)
	{
		for (i=0; i<8; i++)
			G(c2p.fdcs.pa[i]) = 0;			     // Initialize +FDCS with all '0'

#ifdef CLASS20_FAX
		G(c2p.fdcs.ps.jp) = 0;             // Disable color features
#endif

		G(c2p.faxerr) = 11;					 // No answer (T.30 T1 time-out)
		io_fax_init ( G(x_fax_state) );	     // Initialize DCE RX buffer controls
#ifdef FAX_ECM
		ecm_tx_init (1);             // Clear ECM page count
#endif                          
		G(c2_dce_buf_ptr) = (word*) IO_FAX_BUF_START;         // Initialize pointer for class 2, DCE messages
#ifdef CS_MODEM
		G(c2_dte_msg_buf) = C2_DTE_BUF_START;
		G(rsp_len) = 0;														// Reset response length
		G(num_rsp) = 0;														// Reset number of responses
#endif
		G(c2s.flag) = FAX_ACTIVE | SEND_FCON;	 // Send +FCON and indicate FAX is active
		G(c2s.t30) = 55;              // Value used to meet T.30 delays of 75ms +/- 20ms for all modulation
		G(c2s.dte_cmd) = 0;					 // Initialize DTE command buffer
		G(c2s.tcf_cnt) = 3;				    // Initialize DIS response counter
		G(c2rf.flag) = G(c2rf.flag) & T30_BIT;   // Clear all flags but T.30 dynamic bit
		G(c2s.state) = 0;  // Initialize T.30 command/response state machine
		G(c2_var1) = x_current_time ();  // Start T1 timer
		next_state ();
	}

	else
	{
		G(c2_sequence) = ans_sequence;	// Use ANSWER sequence
		answer_init ();						                  // Initialize for answer mode
	}
}

// ------------------------------------ //
// Decode the DIS, NSF or CSI responses //
// ------------------------------------ //

void look_4_dis (void)
{
	if (G(c2rf.flag) & ORG_POLL)            // Originate polling?
	{
		ignore_dis ((byte)G(c2_dce_buf_ptr[1]));  // Ignore NSF/CSI/DIS
		return;                             // Skip normal operation
	}

	switch ((byte)G(c2_dce_buf_ptr[2]))    	            // HDLC FIF
	{
		case RSP_CIG:
		case RSP_CSI:
#if defined(IWF_FAX) || defined(CLASS20_FAX)    
			if ( (G(c2p.fnr) & FNR_IDR) ||            // Report the FIS response for class 2.0?
					 (G(c2p.fclass) == 2) )                    // Always display for class 2?
#endif
				load_rsp_str ((byte)G(c2_dce_buf_ptr[2]) == RSP_CSI ? FCSI : FCIG, (word*)&G(c2_dce_buf_ptr[3]) );

			G(c2p.faxerr) = 22;						              // Command receive error
			break;

		case RSP_NSC:
		case RSP_NSF:				                           // Non-Standard Facilities
			display_opt_rsp ((byte)G(c2_dce_buf_ptr[2]));      // Send +FNSF (+FNS) to DTE
			G(c2p.faxerr) = 22;						                 // Command receive error
			break;

		case RSP_DTC:
		case RSP_DIS:
			if (!(G(c2_dce_buf_ptr[4]) & 0x03))                       // No T.4 Receiver and no document to poll?
			{
				G(c2p.faxerr) = 21;                                 // Remote cannot receive or send
				exit_state ();                                         
				return;
			}

			else
			{
				G(c2rf.flag) = (G(c2rf.flag) & ~0x01) +
							((G(c2_dce_buf_ptr[4]) & 0x3c) == 0x2C);            // Save V.17 modulation bit

				save_remote_vr ();                                             // VR: Save remote FAX modem's VR capabilities
				G(c2rf.dis.ps.br) = cnvt_bit_rate (G(c2_dce_buf_ptr[4]));      // BR: Bit rate
				G(c2rf.dis.ps.wd) = G(c2_dce_buf_ptr[5]) & 0x03;               // WD: Width
				G(c2rf.dis.ps.ln) = ((G(c2_dce_buf_ptr[5]) & 0x0C) >> 2) & 3;  // LN: Length

				if ( (G(c2rf.dis.ps.br) == 0xFF) ||  // Invalid bit rate?
						 (G(c2rf.dis.ps.wd) == 0x03) ||  // Invalid page width?
						 (G(c2rf.dis.ps.ln) == 0x03) )   // Invalid page length?
				{
					G(c2p.faxerr) = 22;                // COMREC error
					exit_state ();
					return;                            // Skip rest of function
				}

				save_remote_df ();                                             // DF: Save remote FAX modem's DF capabilities

				if (G(io_hdlc_byte_count) > 6)  // Byte with ECM info included?
				{
					if (!(G(c2_dce_buf_ptr[6]) & 4))                          // ECM not supported?
						G(c2rf.dis.ps.ec) = 0;	    						                // EC: Error Correction
					else
						G(c2rf.dis.ps.ec) = (G(c2_dce_buf_ptr[3]) & 0x40) ? 1 : 2;   // EC: Set 64/256 byte frame size
				}

				else
					G(c2rf.dis.ps.ec) = 0;

				G(c2rf.dis.ps.bf) = 0;			    					                // BF: Binary file xfer
				G(c2rf.dis.ps.st) = cnvt_scan_time (G(c2_dce_buf_ptr[5]));     // ST: Scan time
				G(c2rf.flag) = G(c2rf.flag) + ((G(c2_dce_buf_ptr[4]) & 1) << 2);    // Save poll bit

				if (G(io_hdlc_byte_count) >= 10)                       // Received PWD/SUB/SEP capabilities?
				{
					G(c2rf.flag) = G(c2rf.flag) + ((G(c2_dce_buf_ptr[9]) & 2) << 5);  // Save password capabilities

					if ((byte)G(c2_dce_buf_ptr[2]) == RSP_DIS)              // Normal transmit, Not poll?
						G(c2rf.flag) = G(c2rf.flag) + ((G(c2_dce_buf_ptr[9]) & 1) << 7);// Save sub-addressing capabilities

					else                                              // Polling (DTC)
						G(c2rf.flag) = G(c2rf.flag) + ((G(c2_dce_buf_ptr[8]) & 0x40) << 1);  // Save selective polling capabilities
				}

#ifdef CLASS20_FAX
				if (G(io_hdlc_byte_count) >= 12)  // Color info included?
				{
					G(c2rf.dis.ps.jp) = (G(c2_dce_buf_ptr[11]) & 0x78) >> 3;  // Save color info.
					G(c2rf.dis.ps.jp) = G(c2rf.dis.ps.jp) | ((G(c2_dce_buf_ptr[12]) & 0x7) << 4);
				}
#endif

#if defined(IWF_FAX) || defined(CLASS20_FAX)
				if ( (G(c2p.fnr) & FNR_RPR) ||                      // Report the FIS response for class 2.0?
						 (G(c2p.fclass) == 2) )                                // Always display for class 2?
#endif
				{
					byte save_ec = G(c2rf.dis.ps.ec); // Save remote's preferred ECM frame size

					if ( (G(c2p.fclass) == 0x20) &&  // Class 2.0/2.1 interface?
							 (G(c2rf.dis.ps.ec) == 2) )  // 256-byte frames?
						G(c2rf.dis.ps.ec) = 1;         // Indicate T.30, Annex A ECM

					if ((byte)G(c2_dce_buf_ptr[2]) == RSP_DTC)              // DTC command?
						load_rsp_cmpd (FDTC, (byte*)&G(c2rf.dis.pa[0]));     // Generate FDTC response for DTE

					else                                              // DIS command
						load_rsp_cmpd (FDIS, (byte*)&G(c2rf.dis.pa[0]));     // Generate FDIS response for DTE

					G(c2rf.dis.ps.ec) = save_ec;                       // Restore ECM frame size
				}

				if ( (G(c2rf.flag) & REMOTE_POLL) &&                     // Remote FAX has a document to poll?
						(G(c2p.sbf) & FSPL) &&                             // Polling is enabled by DTE?
						(G(c2p.sbf) & FCR) )                               // Receiver is enabled by DTE?
					load_rsp_ind (FPOLL);                             // Send "poll" indication to DTE

				cs_fax_response ((G(c2s.flag) & FDT_DIS) ? 1 : 0);        // Load CS_FAX_RESPONSE into M->H buffer, final frame is "OK" sent
				G(c2s.rsp_cnt) = 3;                    // Repeat TSI/DCS/TCF up to 3 times, if necessary
				G(c2p.faxerr) = 20;					          // Unspecified Phase B error (pump or DTE timed out)
				G(c2_var4) = DTE_FDT;						          // Look for +FDT from AT task

#ifdef V34_FAX
				if (G(x_fax_v34mode) != NON_V34)    // Using V.34 modulation?
				{
					G(c2_sequence_ptr) = G(c2_sequence_ptr) + 4;  // Skip non-V.34 states
					G(c2s.timer) = x_current_time ();    // Reset time-out timer

					if (!(G(c2s.flag) & FDT_DIS))        // Need a +FDT before continuing?
					{
						send_mdm_stat (OK);                // Send "READY/OK" to DTE
						G(c2s.flag) = G(c2s.flag) | AT_ENABLE;  // Enable AT-command parser
					}

					return;
				}

				else
#endif
				{
					// Situation: NSF/CSI/DIS received after TCF sent.  If DIS is final frame, don't look for +FDT again.
					// Add 1 to c2_sequence_ptr to skip that state. (c2_sequence_ptr will also be incremented below)
					// Otherwise, continue to look for NSF/CSI/DIS frames with final frame bit set.

					if (G(c2s.flag) & FDT_DIS)			        // Did the remote fax respond NSF/CSI/DIS to TCF?
						G(c2_sequence_ptr) = G(c2_sequence_ptr) + (G(c2_dce_buf_ptr[1]) == 0x13 ? 1 : 0);  // Skip +FDT or get final frame (Ignore command if not final frame)

					else
						G(c2s.flag) = G(c2s.flag) | AT_ENABLE;  // Enable AT-Command processing
				}
			}

			break;

		case RSP_DCN:
		case RSP_DCN+1:
			G(c2p.faxerr) = 0;   // Normal & proper termination
			G(c2_sequence_ptr) = ORG6;        // Send +FHNG/+FHS
			return;

		default:
			if (G(c2_dce_buf_ptr[1]) == 0x13)   // Final frame?
			{
				G(c2p.faxerr) = 23;					      // Invalid command received
				G(c2_sequence_ptr) = ORG6;        // Send +FHNG/+FHS
				return;  // Ignore rest of function
			}

	}

	if (G(c2_dce_buf_ptr[1]) == 0x13)   // Final frame?
	{
		if (!(G(c2s.flag) & FDT_DIS) )    // "Ready"/"OK" has not been sent yet?
			send_mdm_stat (OK);             // Send "READY/OK" to DTE

		next_state ();
	}

	else
		G(c2_sequence_ptr)--;		                        // Wait for NSF/CSI/DIS again with final frame bit set
}

// ---------------------------------------- //
// Ignore NSF/CSI/DIS for Originate Polling //
// ---------------------------------------- //

void ignore_dis (byte cmd)
{
	if (cmd == 0x13)       // Final Frame?
	{
#ifdef V34_FAX
		if (G(x_fax_v34mode) != NON_V34)    // Using V.34 modulation?
		{
			G(c2_sequence) = ans_sequence;        // Switch to answer state machine
			G(c2_sequence_ptr) = ANS0+1;          // Send CSI/DIS; skip non-V.34 state
			G(c2s.timer) = x_current_time ();  // Reset time-out timer
		}

		else if (!(dp_regread (DP_EIA_REGISTER) & 0x04))  // V.21 carrier gone?
#endif
		{
			G(x_fax_state) = FAX_TX_HDLC;      // Fool initialization function
			answer_init ();                 // Initialize for receive

			G(c2_sequence) = ans_sequence; // Switch to answer state machine
			G(c2_sequence_ptr) = ANS0;                  // Start HDLC Tx; send CIG/DTC
			G(c2s.timer) = x_current_time ();           // Reset time-out timer
		}
	}

	else  // NSF/CSI
	{
		G(c2p.faxerr) = 22;						              // Command receive error
		G(c2_sequence_ptr)--;		                        // Wait for CSI/DIS again
	}
}

#ifdef KORTEX
// ----------------------------------------------------------- //
// Return the Remote Faxes VR capabilities to Fax Forward Task //
// ----------------------------------------------------------- //

byte get_rf_vr (void)
{
	return (G(c2rf.dis.ps.vr));  // Return vertical resolution capabilities of remote fax
}

// -------------------------------------------------------------------- //
// Return the active status of this background task to Fax Forward Task //
// -------------------------------------------------------------------- //

byte cl2_active (void)
{
	return ( (G(c2s.flag) & FAX_ACTIVE) &&	// Class 2 background task is active?
					 (G(io_state) == IO_FAX) );    // I/O task is fax?
}
#endif

// ---------------------------------------- //
// Transmit TSI and DCS to remote FAX modem //
// ---------------------------------------- //

void send_tsi_dcs (void)
{
	byte i;

#ifdef V34_FAX
	if (G(x_fax_v34mode) != NON_V34)         // Using V.34 modulation?
	{
		if (G(c2s.flag) & AT_ENABLE)              // Waiting for AT-command?
		{
			if (G(c2s.dte_cmd))                     //  AT-command received?
			{
				if ( (G(c2s.dte_cmd) == DTE_FDR) ||
						 (G(c2s.dte_cmd) == DTE_FK) )

				{
					wait_4_dte_cmd ();               // Process it
					return;                          // Go to new state
				}

				G(c2s.dte_cmd) = 0;                   // Clear command
				G(c2s.flag) = G(c2s.flag) & ~AT_ENABLE;  // Disable AT-Command processing
			}

			else                                 // Wait if no AT-command
				return;
		}
	}

	else
#endif
	if (~G(c2s.flag) & CARRIER_DET)  // Wait until after 850ms of preamble
		return;

	if (G(c2p.fnss_idx) && (G(c2p.sbf) & FND) && (G(c2p.fclass) == 0x20))  // Using non-standard facilities?
	{
		send_modem_id (RSP_TSI);      // Send TSI if programmed
		send_fnss (RSP_NSS);          // Send non-standard setup frame
	}

	else
	{
		send_opt_cmds ();             // Send optional commands with DCS
		if (G(c2rf.flag) & ORG_POLL)       // Originate polling?
			send_modem_id (RSP_CIG);    // Send CIG if programmed
		else
			send_modem_id (RSP_TSI);      // Send TSI if programmed
#ifdef V34_FAX
		if (G(x_fax_v34mode) == NON_V34)         // Not using V.34 modulation?
		{
			if (G(c2p.fdis.ps.br) > 5)                // Data rate left over from V.34 modulation?
				G(c2p.fdis.ps.br) = 5;                  // Limit to 14,400 (	Restored at end of call)
		}

		else                                     // Using V.34 modulation
		{
			G(c2p.fdis.ps.ec) = 1;                    // Must use ECM for V.34 modulation (Restored at end of call)
			G(c2p.fdis.ps.br) = 0;                    // Cause data-signalling-rate bits in DCS to be all zeros (Restored at end of call)
		}
#endif

		G(c2_dce_buf_ptr[0]) = 0xFF;	      // Address
		G(c2_dce_buf_ptr[1]) = 0x13;        // Final frame

		if (G(c2rf.flag) & ORG_POLL)       // Originate polling?
			G(c2_dce_buf_ptr[2]) = RSP_DTC;  // DTC command
		else
			G(c2_dce_buf_ptr[2]) = RSP_DCS + DYNAMIC_BIT;  // DCS command

		G(c2_dce_buf_ptr[3]) = 0;           // T.2 & T.3 parameters disabled

		i = smaller (G(c2rf.dis.ps.br), G(c2p.fdis.ps.br));     // Select smaller bit rate

		if (G(c2rf.flag) & 0x01)                             // V.17 modulation available?
			G(c2_dce_buf_ptr[4]) = v17[i];
		else
			G(c2_dce_buf_ptr[4]) = non_v17[i];

		G(c2_dce_buf_ptr[4]) = G(c2_dce_buf_ptr[4]) + 0x02;  	  // Rx -- T.4 operation
		G(c2_dce_buf_ptr[5]) = dcs_scan () + 0x80;            // Load larger, minimum scan time + extend

		i = smaller (G(c2rf.dis.ps.wd), G(c2p.fdis.ps.wd));		// Select smaller width
		G(c2_dce_buf_ptr[5]) = G(c2_dce_buf_ptr[5]) + i;            // Load selected width

		i = smaller (G(c2rf.dis.ps.ln), G(c2p.fdis.ps.ln));     // Select smaller length
		G(c2_dce_buf_ptr[5]) = G(c2_dce_buf_ptr[5]) + (i << 2);     // Load selected length

#ifdef FAX_ECM                                
		if (!G(c2rf.dis.ps.ec) || !G(c2p.fdis.ps.ec) || (!(G(c2p.dbf) & FECM) && (G(c2p.fclass) == 2)) ) // Is ECM is not available at remote or disabled locally?
			G(c2_dce_buf_ptr[6]) = 0x80;					 	      // Features all disabled; Extend field

		else                                      // Using ECM
		{
			G(c2_dce_buf_ptr[5]) = G(c2_dce_buf_ptr[5]) | 0x70; // Force MSLT to be 0ms (T.30, Table 2, Note #11 {#10 on newer versions})

	#ifdef CS_4 
			if (use_64k_bufr ())                  // 64K of RAM available from the heap?
				G(c2_dce_buf_ptr[6]) = 0x84;        // Indicate 256 byte frame size used; extend field
			else                                  // 64K of RAM not available from heap
	#elif defined (ECM_64K_BUFF)
			G(ecm_stat) = 0;  // Clear ECM status

			if ( ( (G(c2p.fclass) == 2) &&                                   // Class 2 interface?
						 (G(c2p.fdis.ps.ec) == 2) && (G(c2rf.dis.ps.ec) == 2) ) || // Both requested 256-byte frames?
					 ( (G(c2p.fclass) == 0x20) &&                                // Class 2.x interface?
						 (G(c2rf.dis.ps.ec) == 2) )                                // Remote prefers 256-byte frames?
				 )
			{
				G(c2_dce_buf_ptr[6]) = 0x84;     // Indicate 256 byte frame size used; extend field
				use_64k_bufr ();                 // Indicate 64K buffer used
			}

			else
	#endif
				G(c2_dce_buf_ptr[6]) = 0x8C;                  // Set 64 byte frame sizes; extend field
		}
#else
			G(c2_dce_buf_ptr[6]) = 0x80;						      // Features all disabled; extend field
#endif
		negotiate_df ();             // Determine appropriate DF value
		G(c2_dce_buf_ptr[7]) = 0x80; // Extend field
		negotiate_vr ();             // Determine appropriate VR value

#ifdef CLASS20_FAX
		G(c2p.fdcs.ps.jp) = 0;       // Initialize to disabled for now

		if ( (G(c2p.fclass) == 0x20) &&      // Using Class 2.0/2.1 interface?
				 (G(c2_dce_buf_ptr[6]) & 0x04))  // ECM was negotiated?
		{
			G(c2_dce_buf_ptr[8]) = G(c2_dce_buf_ptr[8]) | 0x80;   // Extend field for Class 2.0/2.1
			G(c2_dce_buf_ptr[9]) = 0x80;                          // Extend field; disable everything for now

			if (G(c2_dce_buf_ptr[2]) == RSP_DTC)  // DTC command?
			{
				if (chk_poll (FAP_SEP, G(c2p.fpa)))
					G(c2_dce_buf_ptr[8]) = G(c2_dce_buf_ptr[8]) | 0x40;  // Indicate selective-polling capabilities
			}

			else  // DCS command
			{
				if (chk_poll (FAP_SUB, G(c2p.fsa)))
					G(c2_dce_buf_ptr[9]) = G(c2_dce_buf_ptr[9]) | 0x01;  // Indicate sub-addressing transmission
			}

			if (chk_poll (FAP_PWD, G(c2p.fpw)))
				G(c2_dce_buf_ptr[9]) = G(c2_dce_buf_ptr[9]) | 0x02;  // Indicate password transmission

			G(c2_dce_buf_ptr[10]) = 0x80;   // Extend field; everything disabled
			G(c2p.fdcs.ps.jp) = G(c2p.fdis.ps.jp) & G(c2rf.dis.ps.jp);  // Common capabilities
			G(c2p.fdcs.ps.jp) = G(c2p.fdcs.ps.jp) | (G(c2p.fdis.ps.jp) & 0x20);  // Use local Preferred-Huffman-Table bit
			G(c2_dce_buf_ptr[11]) = 0x80 | ((G(c2p.fdcs.ps.jp) & 0x0F) << 3);
			G(c2_dce_buf_ptr[12]) = (G(c2p.fdcs.ps.jp) & 0x70) >> 4;
			G(io_hdlc_byte_count) = 13;							           // 13 bytes in message
		}

		else
#endif
			G(io_hdlc_byte_count) = 9;							           // 9 bytes in message

		io_fax_hdlc_buf_to_dce( G(io_fax_buf), &G(io_hdlc_byte_count));

		for (i=0; i<8; i++)
			G(c2p.fdcs.pa[i]) = smaller (G(c2p.fdis.pa[i]), G(c2rf.dis.pa[i]));  // Update +FDCS with current parameters

		G(c2p.fdcs.ps.vr) = G(c2p.fdis.ps.vr) & G(c2rf.dis.ps.vr);  // Adjust negotiated VR to single bit (Hopefully, +FDIS was a single bit)
#ifdef FAX_ECM
		if (!(G(c2p.fdcs.ps.ec) && ((G(c2p.dbf) & FECM) || (G(c2p.fclass) == 0x20))) ) // ECM was not negotiated?
			G(c2p.fdcs.ps.ec) = 0;                      // Indicate ECM not used

		if (G(c2p.fdcs.ps.ec))                         // Using ECM?
			G(c2p.fdcs.ps.st) = 0;                       // Force MSLT to 0ms

		else
#endif
		if (G(c2p.fdcs.ps.st) == G(c2p.fdis.ps.st))
			G(c2p.fdcs.ps.st) = G(c2rf.dis.ps.st);		        // Save larger, minimum scan time.

		else
			G(c2p.fdcs.ps.st) = G(c2p.fdis.ps.st);            // Remote has largest MSLT

		G(c2rf.dis.ps.br) = G(c2p.fdcs.ps.br);              // Set rate used for fallback
	}

	if (G(c2rf.flag) & ORG_POLL)       // Originate polling?
	{
		G(c2_sequence) = ans_sequence; // Switch to answer state machine
		G(c2_sequence_ptr) = ANS1;                  // Wait for TSI/DCS after buffer clears
		G(c2s.timer) = x_current_time ();           // Reset time-out timer
	}

	else   // Not polling, normal transmit
	{
	#ifdef V34_FAX
		if (G(x_fax_v34mode) != NON_V34)         // Using V.34 modulation?
		{
			G(c2_sequence_ptr) = G(c2_sequence_ptr) + 5;       // Skip over non-V34 states
			G(c2s.timer) = x_current_time ();         // Reset the time-out timer
		}

		else
	#endif
		{
			G(c2p.faxerr) = 24;								           // Response receive error if time-out
			next_state ();
		}
	}
}

// ------------------------------ //
// Send the training sequence TCF //
// ------------------------------ //

void start_tcf (void)
{
	static const word tcf_dly [] = {2675,2442,1762,1762,3120,3120};  // 1.5 seconds - pump delays per bit rate

#ifdef FAX_ECM
	G(ecm_fax_hdlc) = 0;                   // Transparent synchronous mode for TCF
#endif
	set_train (V17_LONG_TRAIN);

	if ( (G(c2rf.flag) & 0x01) && (G(c2p.fdcs.ps.br) >= 2) ) // V.17 modulation selected?
		G(c2_var1) = 3120;							     // 1.5 seconds plus startup time

	else
		G(c2_var1) = tcf_dly [G(c2p.fdcs.ps.br)];		   // Select delay based on speed/modulation

	G(c2s.flag) = G(c2s.flag) | FDT_DIS;            // Indicate +FDT received from DTE
	setup_sync_tx ();							   // Set pump for sychronous Tx
	next_state ();
}

// ------------------------------- //
//  Turn off TCF after 1.5 seconds //
// ------------------------------- //

void end_tcf (void)
{
	if (x_elapsed_time (G(c2s.timer)) > G(c2_var1))			   // End of delay?
	{
		x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0); // Turn off carrier
		setup_hdlc_rx ();				     // Setup to receive HDLC @ 300 (Increments G(c2_sequence_ptr))
	}
}

// ------------------------------- //
// Process the FTT or CFR messages //
// ------------------------------- //

void decode_cfr_ftt (void)
{
	switch ((byte)G(c2_dce_buf_ptr[2]))     // HDLC FIF
	{
		case RSP_CFR+1:    // CFR for polling
		case RSP_CFR:      // CFR for transmit
#ifdef V34_FAX
		if (G(x_fax_v34mode) != NON_V34)           // Using V.34 modulation?
	#ifdef TEST_V34_FAX_WITH_WINFAX80
			G(c2p.fdcs.ps.br) = getActualPRate () - 6;  // Shift down to 2,400 through 14,400 range
	#else
			G(c2p.fdcs.ps.br) = getActualPRate ();      // Display actual V.34 primary channel rate
	#endif
#endif
#if defined(IWF_FAX) || defined(CLASS20_FAX)
			if ( (G(c2p.fnr) & FNR_TPR) || // Display the FCS response?
					(G(c2p.fclass) == 2) )          // Always display for class 2?
#endif
			{
				byte save_ec = G(c2p.fdcs.ps.ec); // Save negotiated ECM frame size

				if ( (G(c2p.fclass) == 0x20) &&  // Class 2.0/2.1 interface?
						 (G(c2p.fdcs.ps.ec) == 2) )  // 256-byte frames?
					G(c2p.fdcs.ps.ec) = 1;         // Indicate T.30, Annex A ECM

				load_rsp_cmpd (FDCS, (byte*)&G(c2p.fdcs.pa[0]));  // Display negotiated parameters
				G(c2p.fdcs.ps.ec) = save_ec;
			} 

			G(c2s.tcf_cnt) = 3;								                  // Initialize DIS response counter
			G(c2s.flag) = G(c2s.flag) & ~(FDT_DIS | FTT_2400);  //  Clear flags indicating +FDT was received for +FDIS; good train at 2400 or +FMINSP
#ifdef V34_FAX
			if (G(x_fax_v34mode) != NON_V34)
			{
				G(c2_sequence_ptr) = G(c2_sequence_ptr) + 3;       // Skip non-V.34 states
				G(c2s.timer) = x_current_time ();         // Reset the time-out timer
			}

			else
#endif
				next_state ();
			break;

		case RSP_FTT+1:    // FTT for polling
		case RSP_FTT:      // FTT for transmit
//			if (G(c2rf.dis.ps.br) <= G(c2p.fminsp)) // Lowest speed allowed?
			if (G(c2s.flag) & FTT_2400)  // 2nd attempt at 2400 or +FMINSP (+FMS)?
			{
				G(c2p.faxerr) = 27;			// Failure to train @ 2400 or +FMINSP
				exit_state ();
			}

			else   // NOTE: The datapump task will handle conversion to non-V.17 modulation at lower rates
			{
				if (G(c2rf.dis.ps.br) > G(c2p.fminsp) )  // Can a lower rate be used?
					--G(c2rf.dis.ps.br);             // Select next lower rate.

				else  
					G(c2s.flag) = G(c2s.flag) | FTT_2400;  // Indicate FTT at lowest, allowed rate

				G(c2s.rsp_cnt) = 3;              // Reset the No-Response counter (used by get_rsp ())
				G(c2s.timer) = x_current_time ();
				G(c2_sequence_ptr) = ORG1;        // Send TSI/DCS again
			}
			break;

		case RSP_NSC:
		case RSP_CIG:
		case RSP_DTC:
		case RSP_NSF:	 // Remote modem didn't recognize DCS/TSI & training
		case RSP_CSI:
		case RSP_DIS:
			if (--G(c2s.tcf_cnt))              // Third DIS response to training?
			{
				G(c2s.timer) = x_current_time ();
				G(c2_sequence_ptr) = ORG0;        // Evaluate NSF/CSI/DIS
			}

			else
			{
				G(c2p.faxerr) = 26;            // DCS not recognized
				exit_state ();				// Disconnect link
			}

			break;

		case RSP_DCN:
		case RSP_DCN+1:
			G(c2p.faxerr) = 0;         // Normal & proper termination
			G(c2_sequence_ptr) = ORG6; // Hang up
			return;

		default:
			G(c2p.faxerr) = 28;			    // Invalid response received
			exit_state ();
	}
}

// ------------------------ //
// Setup to transmit a page //
// ------------------------ //

void start_page_tx (void)
{
	static const byte sh_tbl[]  = {7,3,2,2,1,1,0,0};  // Shift values for VR = 0
	static const byte sh_tbl1[] = {7,3,3,2,2,1,1,0};  // Shift values for VR = 1
	static const byte sh_tbl2[] = {7,3,3,3,2,2,1,1};  // Shift values for VR = 400x400 or R#x15.4 l/mm
	const byte *ptr;

#ifdef V34_FAX
	if ( (G(x_fax_v34mode) != NON_V34) &&      // Using V.34 modulation?
			 (I(io_dte_tx_wptr) != I(io_dte_tx_rptr)) )  // +FDCS: response still in buffer?
		return;                                  // Wait until it's transfered to MIMIC RBR
#endif

#ifdef FAX_ECM                     
	if (!G(c2p.fdcs.ps.ec))              // Not using ECM? (Start pump now if not using ECM)
#endif
	{                                
#ifdef FAX_ECM
		G(ecm_fax_hdlc) = 0;                   // Sets idle char to 0x00
#endif
		set_train (V17_SHORT_TRAIN);
		setup_sync_tx ();			          // Set pump for synchronous Tx
	}                                

	I(io_dte_rx_rptr) = I(io_dte_rx_sptr);  // Flush DTE Rx buffer
	I(io_dte_rx_wptr) = I(io_dte_rx_sptr);
	G(c2_ps_rptr) = (byte*)I(io_dte_rx_sptr); // Initialize pre-scan pointer
	G(c2rf.flag) = G(c2rf.flag) & (REMOTE_V17+T30_BIT+REMOTE_POLL); // Clear all flags except V.17, T.30 dynamic bit & remote fax poll status
	G(c2_tcf_zeros_needed) = 0;             // Used to pre-scan for EOLs and DLE-ETX
	G(c2_tcf_error_cnt) = 0;                // Previous byte in pre-scan
	G(c2_ps_eol) = 0;

	G(c2_mslt_last) = 0;                    // Last byte for MSLT filtering
	G(c2_var2) = 0;								          // Consecutive zero bits in chk_mslt ()
	G(c2_var4) = 3;								          // Allow initial EOL pattern
	io_init_dce_tx_fifo ();			      // Init DCE Tx buffer

	if (G(c2p.fdcs.ps.vr) & ~0x08)     // Higher vertical resolution chosen (i.e.: VR not R8x3.85 or 200x100)?
	{
		if (G(c2rf.flag) & MSLT_15_4)    // T15.4 = 1/2T7.7?
			ptr = sh_tbl2;                 // Shift values for T15.4 = 1/2T7.7
		else
			ptr = sh_tbl1;						     // Point to shift values for VR>0
	}

	else
		ptr = sh_tbl;						         // Point to shift values for VR=0

	G(c2_var1) = 12 + (G(c2p.fdcs.ps.br) * 12);	      // Number of bytes @ 40ms MSLT for current bit rate
	G(c2_var1) = G(c2_var1) >> ptr[G(c2p.fdcs.ps.st)];       // Adjust bytes @ 40ms MSLT to chosen MSLT
	G(c2_var1) = G(c2_var1) + (ptr[G(c2p.fdcs.ps.st)] == 3); // Round up if 5ms MSLT
	G(c2_var1)++;									         // Add one (Genoa gets picky)

	G(io_dte_rx_last_ch) = 0xFF;         // Initialize variable used in DTE-to-DCE Xfers
	G(c2s.flag) = G(c2s.flag) & ~PAGE_ON; 	 // Clear send-page-active flag
	G(c2p.faxerr) = 40;						 // Unspecified Phase C error
	reset_phcto ();

#ifdef FAX_ECM
	if (G(c2p.fdcs.ps.ec))   // Using ECM?
	{
		ecm_tx_init (0);         // Initialize ECM for Tx
		G(c2_sequence_ptr) = ORG_ECM;  // Transmit page data in ECM mode
	}

	else    // Non-ECM mode
#endif
	{
		send_mdm_stat (CONNECT);         // Send "CONNECT" to the DTE

#if defined(IWF_FAX) || defined(CLASS20_FAX)
		if (G(c2p.fclass) == 2)                  // Class 2 selected?
#endif
			io_put_dte_tx_char (XON);      // Signal DTE to send page data

		next_state ();                   // Transmit page data in non-ECM mode
	}
}

// -------------------------------------- //
// Send page data from the DTE to the DCE //
// -------------------------------------- //
// NOTE: Flow control to the DTE is handled automatically
//       by the interrupt service routine.

void send_page_data (void)
{
	if (~G(c2s.flag) & CARRIER_DET)        // Is pump still not ready?
		return;

	pre_scan_tx_data ();                        // Pre-scan DTE data for EOLs and DLE-ETX (DLE-<ppm>)

	if ( (G(c2_ps_eol) > 1) || (G(c2rf.flag) & END_OF_PAGE) ||  // More than 1 EOL in buffer or end of page?
			 (io_get_dte_rx_bytes () >= IO_DTE_RX_BUFF_EMPTY) )     // DTE won't send any more data?
	{
		if (!(G(c2s.flag) & PAGE_ON))			       // Not sending page data yet?
		{
			byte j = 10;

			G(c2s.flag) = G(c2s.flag) | PAGE_ON;   // Set send-page-active flag

			while (j--)                            // Send leading zeros before data
				write_dce_fifo (0x00);
		}

		reset_phcto ();                          // Reset Phase C time-out timer
		G(c2rf.flag) = G(c2rf.flag) & ~EOL_SENT;           // Clear used to send EOL every 5 seconds

		if (io_fax_sync_dte_to_dce ())            // Send page data; End of page?
		{
			if (G(c2p.fclass) == 2)         // Class 2 FAX Service?
			{
				send_mdm_stat (OK);   // Send "READY/OK" to DTE
				G(c2_var4) = DTE_FET;			          // Expected command is +FET:n
				G(c2s.flag) = G(c2s.flag) | AT_ENABLE;  // Enable AT-Command processing
				next_state ();
			}
		#if defined(IWF_FAX) || defined(CLASS20_FAX)  
			else                                 // Class 2.0
			{
				G(c2s.timer) = x_current_time ();    // Reset the time-out timer
				G(c2s.rsp_cnt) = 3;			          // Three attempts for PPR
				G(c2_sequence_ptr) = ORG7+1;            // Wait for DSP fifo to empty, then send post-page message
			}
		#endif
			I(io_dte_rx_rptr) = I(io_dte_rx_sptr);     // Flush DTE Rx buffer
			I(io_dte_rx_wptr) = I(io_dte_rx_sptr);
		}
	}

	else    // Not end of page and EOLs in DTE buffer are less than or equal to one
	{
		// Note: Older revision of specification T.4 specify that the transmission (and reception) of any coded line
		//       must not exceed 5 seconds.  In other words, an EOL must be sent within 5 seconds or the receiving
		//       device may hang up.  Therefore, the following code will ensure that an EOL is sent within the 5
		//       second time frame.  This will be in the form of a "white" line of 1728 white pels.  A time of
		//       4.7 seconds was chosen to allow for propagation through both systems and delay over the network.
		//       Newer version of T.4 allow 13 seconds, but 5 will be used for compatibility with older systems.
		//       Refer to section 3.2 in both T.4 (06/96) and T.4 (1988).

		if ( ((x_elapsed_time (G(c2s.timer)) % 4700) >= 4600)// Has at least 4.7 seconds expired since last EOL sent? (100ms window)
#if defined(IWF_FAX) || defined(CLASS20_FAX)
				&& !(G(c2p.sbf) & FND)                         // Not sending non-standard data?
#endif
			)
		{                                                 // First interval is 4.6 seconds; subsequent intervals will be 4.7 seconds
			if (!(G(c2rf.flag) & EOL_SENT) )                // Has an EOL been sent for this 5 second interval?
			{
				G(c2rf.flag) = G(c2rf.flag) | EOL_SENT;       // Indicate EOL was sent
				send_white_line ();                           // Send a "white" line so remote FAX doesn't hang up.
			}
		}

		else if (check_phcto ())       // +FCT seconds of no DTE data?
		{
			G(c2s.flag) = G(c2s.flag) | PHASE_C_TIMEOUT;    // Indicate time-out occured
			G(c2p.fet) = 2;									   // Simulate receiving end of procedure
			G(c2s.timer) = x_current_time ();			   // Reset time-out timer
			G(c2_sequence_ptr) = ORG7;                      // Send RTC to remote modem
			I(io_dte_rx_rptr) = I(io_dte_rx_sptr);          // Flush DTE Rx buffer
			I(io_dte_rx_wptr) = I(io_dte_rx_sptr);
		}

		else                                               // Not in 4.900 to 4.999 second window
			G(c2rf.flag) = G(c2rf.flag) & ~EOL_SENT;                  // Clear flag indicating EOL sent every 5 seconds
	}
}

// ------------------------------------------------- //
// Called by ECM Tx to Return to Phase B Negotiation //
// ------------------------------------------------- //

void goto_phase_b (void)
{
	if (G(c2_sequence) == org_sequence)    // Sending a fax?
	{
		G(c2_var4) = DTE_FDT;						       // Expect a +FDT command from the AT task
		G(c2s.flag) = G(c2s.flag) | AT_ENABLE; // Enable AT-Command processor
		G(c2p.faxerr) = 50;					       // Unspecified Phase D error (DTE didn't respond)
		G(c2_sequence_ptr) = ORG16;            // Wait for +FDT from DTE
		G(c2rf.ppr) = 0;                      // Make sure this isn't PIP or PIN
	}

	else  // Answer State Machine
	{
		if (G(x_modem_originate) == FALSE)
		{
			G(c2p.faxerr) = 74;	    // T.30 T1 timeout after EOM received

	#ifdef V34_FAX
			if (G(x_fax_v34mode) == NON_V34)
	#endif
				setup_hdlc_rx ();     // Set modem to Rx HDLC

			G(c2_sequence_ptr) = ANS5;  // Timer T2 delay
		}

		else
			start_org_state ();
	}

	G(c2s.timer) = x_current_time ();   // Reset timer
	G(io_fax_buf) = (word *) IO_FAX_BUF_START;           // Restore pointer
}

#ifdef FAX_ECM
// ------------------------------------ //
// Transmit/Receive Page Data using ECM //
// ------------------------------------ //

void ecm_mode (void)
{
	if (G(c2_sequence) == org_sequence) // Sending a fax?
	{
		if (fax_ecm_tx ())             // Is ECM Tx still active?
			G(c2_sequence_ptr) = ORG_ECM;   // Calls to functions in iofax_c2.c can change G(c2_sequence_ptr); restore proper value
	}

	else                             // Receiving a fax
	{                                // Receiving a fax
		if (fax_ecm_rx ())             // Is ECM Rx still active?
			G(c2_sequence_ptr) = ANS_ECM;   // Calls to functions in iofax_c2.c can change G(c2_sequence_ptr); restore proper value
	}
}

// --------------------------------------------------------- //
// Called by ECM Tx/Rx to Check for AT-Commands from the DTE //
// --------------------------------------------------------- //

void chk_at_cmd (void)
{
	G(c2s.flag) = G(c2s.flag) | AT_ENABLE;    // Enable AT-Command background task
	cl2_at_bg ();                             // Process any AT-Commands from DTE
	G(c2s.flag) = G(c2s.flag) & ~AT_ENABLE;   // Disable AT-Command background task
}

// ------------------------------------ //
// Called byte ECM to Send +FPTS to DTE //
// ------------------------------------ //

void send_fpts (void)
{
	load_rsp_stat (FPTS, G(c2p.fpts));
}

// ---------------------------------------------------------------------------- //
// Return the Time Needed to Send Flags for ECM based on Data Rate & Modulation //
// ---------------------------------------------------------------------------- //
// Synchronization Sequence for ECM is 200ms to 300ms; Settings are for 225ms typically

word ecm_flag_time (void)
{
	static const word flag_time [] = {1383, 1158, 478, 478, 1836, 1836};  // Flag time vs BR for Non-V.17

#ifdef V34_FAX
	if (G(x_fax_v34mode) != NON_V34)   // Using V.34 modulation?
		return (200);

	else
#endif
	if ( (G(c2rf.flag) & REMOTE_V17) && (G(c2p.fdcs.ps.br) >= 2) )  // Using V.17 Modulation?
	{
		if (G(x_fax_v17) == V17_SHORT_TRAIN) // Short train used?
			return (585);                   // Delay for V.17 modulation, short train

		else
			return (1836);                  // Delay for V.17 modulation, long train
	}

	else                                // Delay for V.33, V.29, V.27 or V.27ter modulation
		return (flag_time [G(c2p.fdcs.ps.br)]);
}

// ---------------------------------------- //
// Set State Machine to Disconnect the Link //
// ---------------------------------------- //

void ecm_hang_up (void)
{
	if (G(c2_sequence) == org_sequence)
		G(c2_sequence_ptr) = ORG6;

	else
		G(c2_sequence_ptr) = ANSX;
}

// ------------------------------------------------- //
// Set State Machine to Wait for DCN from Remote FAX //
// ------------------------------------------------- //

void set_rx_dcn (void)
{
	G(c2_sequence_ptr) = ANS8;

#ifdef V34_FAX
	if (G(x_fax_v34mode) != NON_V34)  // Using V.34 modulation?
		G(c2_sequence_ptr)++;              // No need to setup to receive; use existing control channel
#endif
}

// ------------------------------------------------- //
// Get Signalling Rate for DCS issued with CTC (ECM) //
// ------------------------------------------------- //

byte get_ctc_rate (void)
{
	if (G(c2rf.flag) & 0x01)                   // V.17 modulation available?
		return (v17[G(c2p.fdcs.ps.br)]);

	else                                  // Non-V.17 modulation used
		return (non_v17[G(c2p.fdcs.ps.br)]);
}

// ------------------------------------------------ //
// Set Signalling Rate based on CTC FIF Value (ECM) //
// ------------------------------------------------ //

void set_ctc_rate (byte fif)
{
	byte idx = (fif >> 2) & 0x0F;      // Compiler doesn't handle index arithmatic well

	G(c2p.fdcs.ps.br) = dcs_rate [idx];  // BR: Bit rate
}

// ---------------------------------------------------- //
// Set Class 2/2.0 state machine to receive the TSI/DCS //
// ---------------------------------------------------- //

void set_rx_dcs (void)
{
	G(c2_sequence_ptr) = ANS2;
	G(c2s.timer) = x_current_time ();   // Reset timer
}
#endif       // FAX_ECM

// -------------------------------- //
// Add fill characters to meet MSLT //
// -------------------------------- //
/*
	G(c2_var3) contains the number of fill characters required.
	Sets G(c2_sequence_ptr) to ORG15 (send_page_data) when done.
*/

void mslt_fill (void)
{
	if (io_get_dce_tx_count () > G(c2_var3))   // Room in buffer for fill characters?
	{
		while (G(c2_var3)--)
			write_dce_fifo (0);		     // Load fill characters

		G(c2_sequence_ptr) = ORG15;			 // Return to state: send_page_data ()
	}
}

// --------------------------------------------- //
// Process a time-out waiting for +FET=n Command //
// --------------------------------------------- //

void process_phcto (void)
{
	G(c2s.flag) = G(c2s.flag) | PHASE_C_TIMEOUT;  // Indicate time-out occured
	G(c2p.fet) = 2;									// Simulate receiving end of procedure
	G(c2s.timer) = x_current_time ();			// Reset time-out timer
	G(c2_sequence_ptr) = ORG7;                   // Force end of call
}

// ------------------------------------------------------- //
// Send the RTC (Return to Control) Signal to Remote Modem //
// ------------------------------------------------------- //
// Send 000000000001 six times (12 bits)
// Byte Sequence: 00000000, 00001000, 10000000  ; repeat 3 times
//
// If 2-D, MR encoding is used, the RTC includes a "tag" bit set to '1' after each EOL.
// Byte Sequence: 00000000 00000011  ; repeated 6 times

void send_rtc (void)
{
	byte v1;
	word v2 = 0;		                 // Initialize RTC pattern

	if (io_get_dce_tx_count () > 42)	  // 9/12 bytes for RTC + 30 nulls
	{
		if (G(c2p.fdcs.ps.df))   // Sending 2-D, MR data?
			for (v1=0; v1<6; v1++) // Send EOL+T 6 times
			{
				write_dce_fifo (0x00);
				write_dce_fifo (0xC0);  // Bit reversed
			}

		else
			for (v1=0; v1<9; v1++)
			{
				write_dce_fifo ((byte)v2);	  // Put RTC byte in fifo

				if (v2)						     // Pattern = to 0008 or 0080?
					v2 = (v2 << 4) & 0x00FF;  // Set to 0080 or 0000
				else
					v2 = 0x0008;			     // Initialize pattern to 0008
			}

		for (v1=0; v1<30; v1++)         // Allow delay through modem
			write_dce_fifo (0);		     // Send 30 nulls after RTC

		G(c2s.rsp_cnt) = 3;			        // Three attempts for PPR
		G(c2p.faxerr) = 51;				     // Phase D Response error if time-out

		next_state ();
	}
}

// -------------------------------------- //
// Send post-page message to remote modem //
// -------------------------------------- //

void send_ppm (void) 
{
	static const byte ppm[] = {PPM_MPS, PPM_EOM, PPM_EOP};

	if (~G(c2s.flag) & CARRIER_DET)	// Wait until 850ms of preamble sent
		return;

	send_hdlc_cmd (ppm[G(c2p.fet)]);	// Send post-page message based on AT+FET command from DTE
	next_state ();
}

// --------------------------------------------- //
// Setup modem to receive the post-page response //
// --------------------------------------------- //

void setup_rx_ppr (void) 
{
	static const ppr_err[3] = {52, 56, 54};

	G(c2p.faxerr) = ppr_err[G(c2p.fet)];    // No response to MPS, EOM or EOP
	setup_hdlc_rx ();				  // Set pump for HDLC @ 300 (Increments G(c2_sequence_ptr))
	G(c2s.timer) = x_current_time ();
}

// --------------------------------------------- //
// Decode the Post-Page Response from remote DCE //
// --------------------------------------------- //
/*
	Response sent to DTE when post-page response received (ORIGINATE):

	Class 2:
		+FPTS:n
		"OK"     // Only if NOT last page

	Class 2.0:
		"OK"    // Only if NOT last page
	or
		"ERROR" // If post-page response is PIN or RTN
*/

void decode_ppr (void)
{
	static const byte ppr_err[3] = {53, 57, 55};
	byte i;
	byte fpts;        

 	i = 1;
#ifdef CS_4     // Make compiler happy:-)
	fpts = 1;
#endif

	if (G(c2s.flag) & PHASE_C_TIMEOUT) // Time-out in phase C?
		G(c2rf.ppr) = RSP_MCF;            // Force response to be an MCF

	else
		G(c2rf.ppr) = (byte) G(c2_dce_buf_ptr[2]);  // Save the post-page response

	G(c2rf.ppr) = G(c2rf.ppr) & 0xFE;        // Mask dynamic bit

	switch (G(c2rf.ppr))					 // Determine n for message
	{
		case RSP_MCF:
			fpts = 1;                           // FPTS:1 -- MCF
			i = com_ppr ();                     // Clear RE_TX_2400 flag; return TRUE if not EOP
			break;

		case RSP_PIP:
		case RSP_RTP:
			fpts = 3;                             // FPTS:3 -- Indicate RTP
			i = com_ppr ();                       // Clear RE_TX_2400 flag; return TRUE if not EOP
			break;

		case RSP_PIN:
		case RSP_RTN:
			fpts = 2;                               // Initially set +FPTS:2 -- Retrain negative

			if (G(c2rf.dis.ps.br) <= G(c2p.fminsp))         // Was attempt at lowest speed tried?
			{
				if (!(G(c2s.flag) & RE_TX_2400))         // Not re-transmission at lowest speed?
					G(c2s.flag) = G(c2s.flag) | RE_TX_2400;   // Indicate re-transmission at lowest speed

				else                                  // Retransmission at lowest speed
				{
					fpts = 1;                         // Cause DTE not to re-transmit this page again (1=MCF)
					i = com_ppr ();                     // Clear RE_TX_2400 flag; return TRUE if not EOP
				}
			}

			else                                     // Still lower speeds to try
			{
				// When falling back, the first page to reach 2400 by RTN must be
				// sent only once because some apps. give up if another RTN is
				// issued.  After that, each page is re-transmitted once 2400.

				--G(c2rf.dis.ps.br);                       // Select next lower rate.

				if (G(c2rf.dis.ps.br) <= G(c2p.fminsp))       // At lowest speed now?
					G(c2s.flag) = G(c2s.flag) | RE_TX_2400;   // First page must not re-transmit
			}

			break;

		case RSP_DCN:
		case RSP_DCN+1:
			G(c2p.faxerr) = 0;         // Normal & proper termination
			G(c2_sequence_ptr) = ORG6; // Hang up
			return;

		default: 					             // Invalid response
			G(c2p.faxerr) = ppr_err [G(c2p.fet)];	 // Invalid response to MPS, EOM, or EOP
			exit_state ();
			return;                           // Invalid response, terminate call
	}

	G(c2p.fpts) = fpts;                     // Update DTE variable

	if (G(c2p.fclass) == 2)                      // Send +FPTS:n response for class 2?
	{
		load_rsp_stat (FPTS, fpts);
		cs_fax_response (i == 0);
	}

	if (!i)								             // Disconnect link?
	{
		if (G(c2s.flag) & PHASE_C_TIMEOUT)  // Phase C time-out?
			G(c2p.faxerr) = 43;               // Underflow error

		else
			G(c2p.faxerr) = 0;                // Normal and proper end of connection

		exit_state ();
	}

	else                               // More pages to follow
	{
#if defined(IWF_FAX) || defined(CLASS20_FAX)  
		if (G(c2p.fclass) == 0x20)               // Class 2.0 FAX service?
		{
			if ( ((G(c2rf.ppr) == RSP_RTN) || (G(c2rf.ppr) == RSP_PIN)) && // Remote rejected page?
					((G(c2s.flag) & RE_TX_2400) ||                      // First re-transmission?
					(G(c2rf.dis.ps.br) > G(c2p.fminsp))) )                   // Not at lowest speed allowed?
				send_mdm_stat (ERROR);                             // Send ERROR/"ERROR" to DTE

			else                                                 // Remote accepted page (or 2nd attempt at lowest speed allowed)
				send_mdm_stat (OK);                                // Send READY/"OK" to DTE
		}

		else                                                   // Class 2 FAX service
#endif
			send_mdm_stat (OK);                                  // Send READY/"OK" to DTE

		G(c2_var4) = DTE_FDT;						       // Expect a +FDT command from the AT task
		G(c2s.flag) = G(c2s.flag) | AT_ENABLE; // Enable AT-Command processor
		G(c2p.faxerr) = 50;					       // Unspecified Phase D error (DTE didn't respond)
		next_state ();
	}
}

// -------------------------------------- //
// Common code for decode_ppr () function //
// -------------------------------------- //

byte com_ppr (void)
{
	G(c2s.flag) = G(c2s.flag) & ~RE_TX_2400;	// Clear re-Tx flag
	return (G(c2p.fet) != 2);
}

// ------------------------------------------- //
// Process the +FET:n command from the AT task //
// ------------------------------------------- //

void process_fet (void)
{
	if ( (G(c2rf.ppr) == RSP_PIP) || (G(c2rf.ppr) == RSP_PIN) )
	{
		G(c2_var1) = 0; 					     // Used for T3 delay
		G(c2_sequence_ptr) = ORG13;   // Wait for T3 delay
	}

	else
		switch (G(c2p.fet))      // What page punctuation was sent?
		{
			case 0:  // Multi-page segment?
				if (G(c2rf.ppr) == RSP_MCF)		// Multi-page segment AND Message comfirmation?
					G(c2_sequence_ptr) = ORG10;   // Send next page

				else  // RTN or RTP
					G(c2_sequence_ptr) = ORG1;	   // Re-transmit TSI/DCS/TCF
				break;

			case 1:  // End of message?
				{
#ifdef V34_FAX
					if (G(x_fax_v34mode) == NON_V34)  // Not using V.34 modulation?
#endif
						setup_hdlc_rx ();       // Configure modem to receive 300bps HDLC

					G(c2p.faxerr) = 22;		   // Command receive error in Phase B
					G(c2_sequence_ptr) = ORG11;   // Receive CSI/DIS again
					G(c2_var1) = x_current_time ();  // Start T1 timer
					G(c2s.flag) = G(c2s.flag) | FDT_DIS;  // Don't send "OK" nor wait for +FDT
				}

				break;

			case 2:  // End of Procedure and RTN?
				G(c2_sequence_ptr) = ORG1;       // Re-transmit TSI/DCS/TCF
				break;

			default: // Un-implemented or unknown punctuation
				G(c2p.faxerr) = 40;	         // Unspecified phase C error
				exit_state ();
				return;
		}

	G(c2s.timer) = x_current_time ();
}

// ---------------------------------------- //
// Delay T3 time after procedure interrupts //
// ---------------------------------------- //

void t3_delay (void)
{
	if (x_elapsed_time (G(c2s.timer)) > 3333)   // 3-1/3 seconds expired?
	{
		if (++G(c2_var1) >= 3)			         // Ten seconds expired?
			G(c2_sequence_ptr) = ORG1;             // Send TSI/DCS again

		G(c2s.timer) = x_current_time ();       // Reset the time-out timer
	}
}

// ----------------------------------------- //
// Send Disconnect (DCN) to remote FAX modem //
// ----------------------------------------- //

void send_disconnect (void) 
{
	if (~G(c2s.flag) & CARRIER_DET)    // Wait until 850ms of preamble are sent
		return;

	send_hdlc_cmd (RSP_DCN);
	next_state ();
}

// -------------------------------------- //
// Turn off pump after final message sent //
// -------------------------------------- //

void turn_off_pump (void)
{
	byte v1;

	x_send_mail (AT_IO_DISCONNECT, IO_TASK, NULL, 0); // Turn off pump
	G(c2s.flag) = 0;			                          // Clear all flags (Disable this task)
	G(c2rf.flag) = 0;                                // Clear flags for next call

	for (v1=0; v1<8; v1++)
		G(c2p.fdis.pa[v1]) = G(c2p.fdcc.pa[v1]);          // Initialize +FDIS with +FDCC

	G(c2_sequence_ptr) = 0;								        // Reset sequence pointer
	G(c2p.sbf) = G(c2p.sbf) & ~(FLPL + FSPL + FND);      // Clear polling and non-standard flags
}

// --------------------------------------------- //
// Check number of times when no response to TCF //
// --------------------------------------------- //

void check_no_cfr_ftt (void)
{
	if (--G(c2s.rsp_cnt))              // Not third attempt?
		G(c2_sequence_ptr) = ORG1;	    // Send TSI/DCS again

	else
	{
		G(c2p.faxerr) = 25; 			  // DCS sent 3 times without a response
		exit_state ();
	}
}

// ------------------------------------------------------------------------ //
// Check the number of times no response was received for post-page message //
// ------------------------------------------------------------------------ //

void check_no_ppr (void) 
{
	if (--G(c2s.rsp_cnt))           // Not third attempt?
		G(c2_sequence_ptr) = ORG2;     // Send post-page message again

	else
		exit_state ();

	G(c2s.timer) = x_current_time ();
}

// ---------------------------------- //
// Insert a word into the DCE TX FIFO //
// ---------------------------------- //

byte write_dce_fifo (byte val) 
{
	if (io_get_dce_tx_count ())				   // Any room in the buffer?
	{
		*G(io_dce_tx_wptr) = (word) val;		   // Save byte as a word
		dp_start_transmit ();				           // Trigger Tx interrupt routine

		if ( (G(io_dce_tx_wptr) + 1) >= G(io_dce_tx_eptr))  // End of buffer? (Prevent ISR from seeing invalid pointer)
			G(io_dce_tx_wptr) = G(io_dce_tx_sptr);            // Wrap to beginning

		else                                                // Not end of buffer
			G(io_dce_tx_wptr)++;                              // Point to next location

		return (1);							   // Indicate that the byte was written
	}

	return (0);                                // Indicates that the byte wasn't written
}

// -------------------------------- //
// Read a word from the DCE TX FIFO //
// -------------------------------- //

word read_dce_fifo (void) 
{
	word c;

	if (G(io_dce_rx_rptr) == G(io_dce_rx_wptr))  // Any data in buffer?
		return (0x8000);                   // Indicate no data to read

	c = *G(io_dce_rx_rptr);				                      // Read word

	if ( (G(io_dce_rx_rptr) + 1) >= G(io_dce_rx_eptr))  // End of buffer? (Prevent ISR from seeing invalid pointer)
		G(io_dce_rx_rptr) = G(io_dce_rx_sptr);            // Wrap to beginning

	else                                                // Not end of buffer
		G(io_dce_rx_rptr)++;                              // Point to next location

	return (c);							   // Return data
}

// ------------------------------- //
// Write a byte to the DTE TX FIFO //
// ------------------------------- //
// Note: By using the temp variable *ptr, this prevents io_dte_tx_wptr from
//       being equal to io_dte_tx_eptr in ISR comparisons which is not a good thing.

void write_dte_fifo (byte val)
{
	byte *ptr = (byte*) I(io_dte_tx_wptr);

	*ptr++ = val;

	if ( ptr >= I(io_dte_tx_eptr) )
		ptr = (byte *) I(io_dte_tx_sptr);

	I(io_dte_tx_wptr) = ptr;
}

// -------------------------------- //
// Read a byte from the DTE RX FIFO //
// -------------------------------- //

byte read_dte_fifo (void)
{
	byte i;

	i = *I(io_dte_rx_rptr);				                      // Read byte

	if ( (I(io_dte_rx_rptr) + 1) >= I(io_dte_rx_eptr))  // End of buffer? (Prevent ISR from seeing invalid pointer)
		I(io_dte_rx_rptr) = I(io_dte_rx_sptr);            // Wrap to beginning

	else                                                // Not end of buffer
		I(io_dte_rx_rptr)++;                              // Point to next location

	return (i);    // Return byte
}

// --------------------------------------- //
// Set the state machine to the next state //
// --------------------------------------- //

void next_state (void)  
{
	G(c2s.timer) = x_current_time ();  // Reset time-out timer
	G(c2_sequence_ptr)++;   				       // Point to next state
}

// ------------------------------------------------------- //
// Set the state machine to shut-down in an orderly manner //
// ------------------------------------------------------- //

void exit_state (void)
{
	G(c2s.timer) = x_current_time ();	// Reset the time-out timer

	if (G(c2_sequence) == org_sequence)
	{
		G(c2_sequence_ptr) = ORGX;			// Set sequence pointer to send DCN to remote FAX
#ifdef V34_FAX
		if (G(x_fax_v34mode) != NON_V34)  // Using V.34 modulation?
			G(c2_sequence_ptr)++;              // Control channel already setup
#endif
	}

	else
		G(c2_sequence_ptr) = ANSX;
}

// --------------------------------------------- //
// Load a Class 2/Class 2.0 Response into Buffer //
// --------------------------------------------- //

byte load_dte_rsp (byte rsp_id, byte *dest)
{
#ifdef CS_MODEM
	dest[G(rsp_len)++] = rsp_tbl_cs[rsp_id].pid;
	dest[G(rsp_len)++] = rsp_tbl_cs[rsp_id].len;
	return (rsp_tbl_cs[rsp_id].len);

#else // CLIENT
	byte slen = 0;
	byte *sptr;

	#ifdef CLASS20_FAX
	if (G(c2p.fclass) == 0x20)                      // Using Class 2.0?
		sptr = (byte*)rsp_tbl20[rsp_id];      // Index into the Class 2.0 response table

	else                                    // Class 2
	#endif
		sptr = (byte*)rsp_tbl2[rsp_id];       // Index into the Class 2 response table

	while (sptr[slen])                      // Until the end of the string...
		*dest++ = sptr[slen++];               // Copy the response to the destination buffer

	return (slen);                          // Return the number of bytes transfered
#endif
}

// ----------------------------------------------------------- //
// Send/Load a Class 2/Class 2.0 String Response to DTE/Buffer //
// ----------------------------------------------------------- //
/*
	 Used for the following response strings:

	 Class 2				Class 2.0
	 -------				---------
	 +FCSI:					+FCI:
	 +FCIG:					+FPI:
	 +FTSI:					+FTI:
		 --						+FPA:
		 --						+FPW:
		 --						+FSA:
*/
void load_rsp_str (byte rsp_id, word *src)
{
	byte i;
#ifdef CS_MODEM
	load_dte_rsp (rsp_id, G(c2_dte_msg_buf));     // Load response parameter ID & length

	for (i=0; i<20; i++)
		G(c2_dte_msg_buf[G(rsp_len)++]) = (byte)src[19-i]; // Reverse order response string

	G(num_rsp)++;											        // Increment the number of responses

#else    // CLIENT
	byte slen;
	byte buf[40];

	slen = load_dte_rsp (rsp_id, buf);      // Load the response into the buffer
	buf[slen++] = '"';                      // Beginning quote

	for (i=0; i<20; i++)					          // Save remote FAX's CSI
		buf[slen++] = (byte)src[19-i];        // Reverse order response string

	buf [slen++] = '"';                     // Ending quote
	at_output_msg (buf, slen);              // Send response to DTE
#endif
}

// ----------------------------------------------------------------- //
// Send/Load a Class 2/Class 2.0 Non-Standard Response to DTE/Buffer //
// ----------------------------------------------------------------- //
/*
	 Used for the following Non-Standard responses:

	 Class 2				Class 2.0
	 -------				---------
	 +FNSC					+FNC
	 +FNSF					+FNF
	 +FNSS					+FNS
*/
void load_rsp_nsf (byte rsp_id, word *src)
{
	byte i;

#ifdef CS_MODEM
	byte len;

	load_dte_rsp (rsp_id, G(c2_dte_msg_buf));          // Save parameter ID
	len = G(rsp_len) - 1;                           // Save location of length
	G(num_rsp)++;                                  

	for (i = 0; i < 100; i++)                    // Limit string to 100 bytes
	{
		if (src[i] & HDLC_END_OF_FRAME)            // Last byte in frame?
		{
			G(c2_dte_msg_buf[G(rsp_len)++]) = (byte)src[i];   // Copy last byte to DTE buffer
			G(c2_dte_msg_buf[len]) = i + 1;                // Save actual length
			break;
		}

		else
			G(c2_dte_msg_buf[G(rsp_len)++]) = (byte)src[i];   // Copy string to DTE buffer
	}

	if (i == 100)                                // Hit upper limit?
		G(c2_dte_msg_buf[len]) = 100;                    // Set length to limit

#else
	byte slen;
	byte format = DECIMAL;
	byte buf[80];
	byte max = 255;
	word fif;
	byte end;               

	#ifdef CLASS20_FAX
	if (G(c2p.fclass) == 0x20)
		format = HEX;
	#endif

	slen = load_dte_rsp (rsp_id, buf);                      // Load the response type into the buffer
	i = 0;

	do
	{
		fif = src[i++];                       // Temp storage for FIF byte
		end = (fif & HDLC_END_OF_FRAME) != 0; // End of frame indicator
		slen = slen + at_itoa ((byte)fif, &buf[slen], format); // Load value into buffer

		if (!end)                            // Not last byte?
			buf[slen++] = ',';                 // Add separator

		if ( (slen >= 70) || end || !max)    // Buffer full or end of HDLC frame or max length?
		{                                    // NOTE: slen >= 70 prevents a buffer overflow in at_output_msg ()
			at_output_msg (buf, slen);         // Send data to DTE
			slen = 0;                          // Reset length

			if (end)                           // End of HDLC frame?
				break;                           // Exit while loop
		}
	}	while (max--);

#endif
}

// ----------------------------------------------------------------------- //
// Send/Load a Class 2/Class 2.0 Compound Parameter Response to DTE/Buffer //
// ----------------------------------------------------------------------- //
/*
	 Used for the following compound parameters responses:

	 Class 2				Class 2.0
	 -------				---------
		+FDCS					+FCC
		+FDIS					+FIS
		+FDTC					+FTC
*/
void load_rsp_cmpd (byte rsp_id, byte *src)
{
	byte i;
#ifdef CS_MODEM
	load_dte_rsp (rsp_id, G(c2_dte_msg_buf));      // Load parameter ID & length

	for (i=0; i<8; i++)
		G(c2_dte_msg_buf[G(rsp_len)++]) = src[i];       // Copy parameters to buffer

	G(num_rsp)++;                               // Increment number of responses in buffer

#else  // CLIENT
	byte slen;
	byte buf[40];
	byte format = DECIMAL;
	byte n = 7;

	#ifdef CLASS20_FAX
	if (G(c2p.fclass) == 0x20)
	{
		format = HEX;
		n = 8;
	}        
	#endif

	slen = load_dte_rsp (rsp_id, buf);       // Load the response into the buffer

	for (i = 0; i < n; i++)                      // For first seven/eight parameters...
	{
		slen = slen + at_itoa (*src++, &buf[slen], format); // Load value into buffer
		buf[slen++] = ',';                     // Separate by comma
	}

	slen = slen + at_itoa (*src, &buf[slen], format); // Load last component into buffer
	at_output_msg (buf, slen);               // Send to DTE
#endif
}

// -------------------------------------------------------------- //
// Send/Load a Class 2/Class 2.0 Indicator Response to DTE/Buffer //
// -------------------------------------------------------------- //
/*
	 Used for the following Indicator responses:

	 Class 2				Class 2.0
	 -------				---------
	 +FCON					+FCO
	 +FPOLL					+FPO
*/
void load_rsp_ind (byte rsp_id)
{
#ifdef CS_MODEM
	load_dte_rsp (rsp_id, G(c2_dte_msg_buf));
	G(num_rsp)++;

#else
	byte slen;
	byte buf[10];

	slen = load_dte_rsp (rsp_id, buf);   // Load the response into the buffer
	at_output_msg (buf, slen);	       	 // Send indicator to DTE
#endif
}

// ----------------------------------------------------------- //
// Send/Load a Class 2/Class 2.0 Status Response to DTE/Buffer //
// ----------------------------------------------------------- //
/*
	 Used for the following Indicator responses:

	 Class 2				Class 2.0
	 -------				---------
	 +FET:n					+FET:n
	 +FHNG:n				+FHS:n
	 +FPTS:n				+FPS:n   (Class 2 Tx only)
*/
void load_rsp_stat (byte rsp_id, byte val)
{
#ifdef CS_MODEM
	load_dte_rsp (rsp_id, G(c2_dte_msg_buf));
	G(c2_dte_msg_buf[G(rsp_len)++]) = val;
	G(num_rsp)++;

#else
	byte slen;
	byte buf[10];
	byte format = DECIMAL;

	#ifdef CLASS20_FAX
	if (G(c2p.fclass) == 0x20)
		format = HEX;
	#endif

	slen = load_dte_rsp (rsp_id, buf);               // Load the response type into the buffer
	slen = slen + at_itoa (val, &buf[slen], format); // Load value into buffer
	at_output_msg (buf, slen);	       	 // Send indicator to DTE
#endif
}

// ---------------------------------------------------- //
// Send/Load a +FPTS/+FPS Status Response to DTE/Buffer //
// ---------------------------------------------------- //
/*
		The pointer points to the follow items:

		0: +FPTS value
		1: Number of lines
		2: Number of bad lines
		3: Number of consecutive bad lines
		4: Number of bytes lost due to overrun (Class 2.0 only)
*/

void load_rsp_fpts (word *buf)
{
	byte i;
	byte max = 4;   
#ifdef CS_MODEM
	byte *ptr;

	#ifdef IWF_FAX
	if (G(c2p.fclass) == 0x20)
		max = 5;         
	#endif

	G(c2_dte_msg_buf[G(rsp_len)++]) = CS_FPTS;
	ptr = &G(c2_dte_msg_buf[G(rsp_len)++]);     // Get location of length
	*ptr = 1;                          // Initial length is 1
	G(c2_dte_msg_buf[G(rsp_len)++]) = (byte)buf[0];  // Load page status

	for (i = 1; i < max; i++)
	{
		*ptr = *ptr + 2;                               // Add 2 to the length
		G(c2_dte_msg_buf[G(rsp_len)++]) = (byte)(buf[i] >> 8);  // Save number of lines, high byte first
		G(c2_dte_msg_buf[G(rsp_len)++]) = (byte)buf[i];
	}

	G(num_rsp)++;

#else                    // CLIENT
	byte slen;
	byte mbuf[40];
	byte format = DECIMAL;

	#ifdef CLASS20_FAX
	if (G(c2p.fclass) == 0x20)
	{
		format = HEX;
		max = 5;         
	}
	#endif

	slen = load_dte_rsp (FPTS, mbuf);     // Load "+FPTS:"/"+FPS:" into buffer
	slen = slen + at_itoa (buf[0], &mbuf[slen], format); // Load page status

	for (i = 1; i < max; i++)
	{
		mbuf[slen++] = ',';
		slen = slen + at_itoa (buf[i], &mbuf[slen], format); // Load number of lines
	}

	at_output_msg (mbuf, slen);	       	 // Send indicator to DTE
#endif
}

// ------------------------ //
// Send Modem Status to DTE //
// ------------------------ //
/*
	 Used for the following Modem Status:

	 Client 				Central Site
	 -------				---------
	 "OK"   				MODEM_READY
	 "CONNECT"			CONNECT
	 "ERROR" 				ERROR
*/
void send_mdm_stat (byte mdm_stat)
{
#ifdef CS_MODEM
	byte stat = MODEM_READY;

	switch (mdm_stat)
	{
		case ERROR:
			stat = ERROR;
		case OK:
			cs_compose_cmd (stat, 1, 0, 0);     // Send modem status to host
			break;

		case CONNECT:
			G(c2_dte_msg_buf[G(rsp_len)++]) = CS_FAX_CONNECT;  // Sending high speed carrier
			G(c2_dte_msg_buf[G(rsp_len)++]) = 0;               // Number of sub-parameters
			G(num_rsp)++;
			cs_compose_cmd (FAX_RESPONSE, 1, G(num_rsp), G(rsp_len));  // Load in modem->host buffer, signal host
			G(rsp_len) = 0;
			G(num_rsp) = 0;

		default:
			return;
	}

#else
	G(at_result_code) = mdm_stat;
	at_output_msg (NULL, 0);
#endif
}

// ---------------------------------------------------------- //
// Load a Central Site Response into the Modem-to-Host Buffer //
// ---------------------------------------------------------- //

void cs_fax_response (byte final_frm)
{
#ifdef CS_MODEM
	if (G(num_rsp))                                                  // Any messages generated?
		cs_compose_cmd (FAX_RESPONSE, final_frm, G(num_rsp), G(rsp_len)); // Load in modem->host buffer, signal host

	G(num_rsp) = 0;														                      // Reset response count & length
	G(rsp_len) = 0;

#else                 // CLIENT
	final_frm++;        // Prevents compiler error, does nothing
#endif
}

// *********************************************************** //
//                      ANSWER MODE			                       //
// *********************************************************** //

// ---------------------------------------- //
// Initialize state machine for answer mode //
// ---------------------------------------- //

void answer_init (void)
{
	byte v1;

	if ( (G(x_fax_state) == FAX_TX_HDLC)			  // V.17, V.33, V.29 or V.27 Originate mode?
#ifdef V34_FAX
				|| (G(x_fax_v34mode) == V34_RECEIVE) // V.34 Answer mode?
#endif
		 )
	{
		for (v1=0; v1<8; v1++)
			G(c2p.fdcs.pa[v1]) = 0;			        // Initialize +FDCS

#ifdef CLASS20_FAX
		G(c2p.fdcs.ps.jp) = 0;   // Disable color FAX
#endif

		for (v1=0; v1<20; v1++)			        // Initialize TSI to NULL
			G(c2rf.tsi[v1]) = ' ';

		G(c2p.fet) = 0;						            // Make sure inter-page status in not EOM.

		if (!(G(c2rf.flag) & ORG_POLL))          // Not Originate polling?
		{
			G(c2rf.flag) = G(c2rf.flag) & T30_BIT;          // Clear all flags but T.30 dynamic bit
			G(c2_var1) = x_current_time ();          // Start T.30 T1 timer
			G(c2s.state) = 0;                        // Initialize state for T.30 command/responses
			G(c2s.flag) = FAX_ACTIVE | SEND_FCON | CARRIER_DET;  // Send +FCON, force Tx CSI/DIS
		}

		io_fax_init ( G(x_fax_state) );
		G(c2_dce_buf_ptr) = (word*) IO_FAX_BUF_START;         // Initialize pointer for class 2, DCE messages
#ifdef CS_MODEM
		G(c2_dte_msg_buf) = C2_DTE_BUF_START;
		G(rsp_len) = 0;								        // Reset response length
		G(num_rsp) = 0;								        // Reset number of responses
#endif
		G(c2s.t30) = 60;
		G(c2s.dte_cmd) = 0;                    // Clear received DTE command
		G(c2s.timer) = x_current_time ();		  // Reset time-out timer
		G(c2_sequence_ptr) = ANS0+1;				      // Skip next state which enables HDLC Tx
	}

	else
	{
		G(c2_sequence) = org_sequence; // Execute ORIGINATE sequence
		org_init ();						                    // Initialize ORIGINATE state machine
	}
}

// ----------------------------------------- //
// Transmit the CSI/DIS to calling FAX modem //
// ----------------------------------------- //

void send_csi_dis (void)
{
	static const byte min_scan [] = {7,1,6,2,3,0,5,4};	 // Converts scan time to T.30 value

	if (~G(c2s.flag) & CARRIER_DET)	// Wait until preamble is sent
		return;

	send_opt_cmds ();                         // Send optional commands with DIS/DTC

	if (G(c2rf.flag) & ORG_POLL)                   // Start of orginate polling?
	{
		send_modem_id (RSP_CIG);                // Send as CIG, if programmed
		G(c2_dce_buf_ptr[2]) = RSP_DTC;               // Send as DTC commmand
	}

	else
	{
		send_modem_id (RSP_CSI);                // Send CSI to remote modem, if programmed
		G(c2_dce_buf_ptr[2]) = RSP_DIS;               // DIS command
	}

	G(c2_dce_buf_ptr[0]) = 0xFF;	                  // Address
	G(c2_dce_buf_ptr[1]) = 0x13;                    // Final frame
#if defined(CS_4) || defined(ECM_64K_BUFF)
	if ( (G(c2p.fclass) == 2) && (G(c2p.fdis.ps.ec) == 1) )  // Class 2, 64-byte frames requested?
		G(c2_dce_buf_ptr[3]) = 0x40;                           // T.2 & T.3 parameters disabled; 64-byte frames preferred
	else                                                    
		G(c2_dce_buf_ptr[3]) = 0;                                                  // T.2 & T.3 parameters disabled; 256-byte frames preferred
#else
	G(c2_dce_buf_ptr[3]) = 0x40;                                               // T.2 & T.3 parameters disabled; 64-byte frames preferred
#endif
	G(c2_dce_buf_ptr[4]) = (G(c2p.sbf) & FCR) >> 3;                               // T.4 receive capabilities
	G(c2_dce_buf_ptr[4]) = G(c2_dce_buf_ptr[4]) | (G(c2p.fdis.ps.vr) & 0x11 ? 0x40 : 0);  // R8 x 7.7 or 200 x 200 capabilities

	if (G(c2p.fdis.ps.df) >= 1)                            // 2D capabilities?
		G(c2_dce_buf_ptr[4]) = G(c2_dce_buf_ptr[4]) | 0x80;  // Indicate 2D capabilities

#ifdef V34_FAX
	if (G(x_fax_v34mode) != NON_V34)   // Using V.34 modulation?
	{
		;	 //	Leave all bits for bit rate cleared
		G(c2_dce_buf_ptr[3]) = G(c2_dce_buf_ptr[3]) | 0x20;  // Indicate V.8 capabilities
	}


	else
#endif
	if (G(c2p.fdis.ps.br) <= 1)		                                        // Bit rate limit <= 4,800?
		G(c2_dce_buf_ptr[4]) = G(c2_dce_buf_ptr[4]) + ((G(c2p.fdis.ps.br) & 0x01) << 3); // Indicate 2,400 or 4,800 max rate

	else if (G(c2p.fdis.ps.br) <= 3)                                       // Bit rate limit <= 9,600?
		G(c2_dce_buf_ptr[4]) = G(c2_dce_buf_ptr[4]) + 0x0C;                           // Indicate V.27 and V.29 only

	else
		G(c2_dce_buf_ptr[4]) = G(c2_dce_buf_ptr[4]) + 0x2C;                           // All data rates

	if (G(c2p.sbf) & FLPL)                                                  // DTE has a document to poll?
		G(c2_dce_buf_ptr[4]) = G(c2_dce_buf_ptr[4]) + 1;                              // Set bit 9 -- Poll flag

	G(c2_dce_buf_ptr[5]) = G(c2p.fdis.ps.wd) + (G(c2p.fdis.ps.ln) << 2) + 0x80 	   // Width, length, Extend
							+ (min_scan[G(c2p.fdis.ps.st)] << 4);				      // Min. scan time

#if defined(IWF_FAX) || defined(CLASS20_FAX)
	if (G(c2p.fdis.ps.df) >= 2)                       // 2D, uncompressed mode supported?
		G(c2_dce_buf_ptr[6]) = 0x82;                    // Extend field; Indicate 2D, uncompressed mode

	else                                             
		G(c2_dce_buf_ptr[6]) = 0x80;                                     // Extend field, everything disabled
	#ifdef FAX_ECM
		if (G(c2p.fdis.ps.ec) && ((G(c2p.dbf) & FECM) || (G(c2p.fclass) == 0x20)) ) // ECM enabled?
		{
			G(c2_dce_buf_ptr[6]) = G(c2_dce_buf_ptr[6]) | 0x04;                     // Indicate ECM is available

			if (G(c2p.fdis.ps.df) == 3)                            // Host supports MMR encoding?
				G(c2_dce_buf_ptr[6]) = G(c2_dce_buf_ptr[6]) | 0x40;  // Indicate MMR (T.6) encoding supported
		}
	#endif

	G(c2_dce_buf_ptr[7]) = 0x80;                                     // Extend field, everything disabled

	if (G(c2p.fclass) == 0x20)
	{
		byte dis;

		dis = G(c2p.fdis.ps.vr) & 0x02 ? 0x81 : 0x80;         // Send R8 x 15.4 capabilities; extend field
		dis = dis | (G(c2p.fdis.ps.vr) & 0x24 ? 0x04 : 0x00); // R16 x 15.4 and/or 400 x 400 capabilities
		dis = dis | (G(c2p.fdis.ps.vr) & 0x40 ? 0x02 : 0x00); // 300 x 300 capabilities
		dis = dis | (G(c2p.fdis.ps.vr) & 0x78 ? 0x18 : 0x10); // Preference for inches (metric always preferred)
		G(c2_dce_buf_ptr[8]) = dis;                           // Send higher VR capabilities
	}

	else
		G(c2_dce_buf_ptr[8]) = 0x90;  // Extend field; metric preferred

	G(c2_dce_buf_ptr[8]) = G(c2_dce_buf_ptr[8]) | ((G(c2p.fap) & FAP_SEP) << 5); // selective polling capabilities
	G(c2_dce_buf_ptr[9]) = (G(c2p.fap) & FAP_SUB) + ((G(c2p.fap) & FAP_PWD) >> 1); // Final field, sub-addressing & password

	#ifndef IWF_FAX
	if ( (G(c2_dce_buf_ptr[6]) & 0x04) &&   // ECM available? (Must be for color)
			 (G(c2p.fdis.ps.jp) & 0x01) &&      // JPEG is enabled?
			 (G(c2p.fclass) == 0x20) )           // Class 2.0/2.1 used
	{
		G(c2_dce_buf_ptr[9]) = G(c2_dce_buf_ptr[9]) | 0x80;  // Extend field
		G(c2_dce_buf_ptr[10]) = 0x80;                        // Extend field; everything disabled
		G(c2_dce_buf_ptr[11]) = 0x80 + ((G(c2p.fdis.ps.jp) & 0x0B) << 3);  // Extend field; JPEG; full color; 12 bits/pel component
		G(c2_dce_buf_ptr[12]) = (G(c2p.fdis.ps.jp) & 0x70) >> 4;  // Final frame; sub-sampling; custom illuminant & gamut range
		G(io_hdlc_byte_count) = 13;					                    // 13 bytes in message
	}

	else
	#endif
		G(io_hdlc_byte_count) = 10;					                    // Ten bytes in message

#else  // Class 2
	if (G(c2p.fdis.ps.df) >= 2)          // 2D, uncompressed mode supported?
		G(c2_dce_buf_ptr[6]) = 0x02;       // Indicate 2D, uncompressed mode; last byte

	else
		G(c2_dce_buf_ptr[6]) = 0;					// Features are all disabled
	#ifdef FAX_ECM                              
		if (G(c2p.fdis.ps.ec) && (G(c2p.dbf) & FECM))   // ECM enabled?
		{
			G(c2_dce_buf_ptr[6]) = G(c2_dce_buf_ptr[6]) | 0x04; // Indicate ECM is available

			if (G(c2p.fdis.ps.df) == 3)                           // Host supports MMR encoding?
				G(c2_dce_buf_ptr[6]) = G(c2_dce_buf_ptr[6]) | 0x40; // Indicate MMR encoding supported
		}
	#endif
	G(io_hdlc_byte_count) = 7;					      // Seven bytes in message
#endif
#if defined(CS_4) || defined(ECM_64K_BUFF)
	if (G(c2_dce_buf_ptr[6]) & 4)      // Is ECM available?
	{
		if (!use_64k_bufr () )                                 // Is 64K bytes not available from heap?
			G(c2_dce_buf_ptr[3]) = G(c2_dce_buf_ptr[3]) | 0x40;  // Request 64-byte frames
	}
#endif
	io_fax_hdlc_buf_to_dce( G(io_fax_buf), &G(io_hdlc_byte_count));
#ifdef V34_FAX
	if (G(x_fax_v34mode) != NON_V34)       // Using V.34 modulation?
		G(c2_sequence_ptr) = G(c2_sequence_ptr) + 3;  // Skip non-V.34 states; Look for TSI/DCS
	else
#endif
		next_state ();
}

// --------------------------------------- //
// Decode the TSI and/or DCS/NSS responses //
// --------------------------------------- //

void look_4_dcs (void)
{
	static const byte dcs_scan_time [] = {5,1,3,0,7,0,0,0};
	byte i;

	switch ((byte)G(c2_dce_buf_ptr[2]))	    // HDLC FCF
	{
		case RSP_CIG:
#if defined(IWF_FAX) || defined(CLASS20_FAX)   
			if ( (G(c2p.fnr) & FNR_IDR) ||              // Display the +FCIG (+FPI) response in Class 2.0?
					(G(c2p.fclass) == 2) )                         // Always display for Class 2?
#endif
				load_rsp_str (FCIG, (word*)&G(c2_dce_buf_ptr[3])); // Send +FCIG (+FPI) response

			break;

		case RSP_TSI+1:  // TSI for polling
		case RSP_TSI:    // TSI for receive
			if ( (G(c2p.fet) != 1) &&                      // Inter-page status not equal to EOM?
				 (~G(c2s.flag) & FTT_SENT) )	              // FTT not sent?
			{
				for (i=0; i<20; i++)					        // Save remote TSI
					G(c2rf.tsi[i]) = (byte)G(c2_dce_buf_ptr[22-i]);  // Reverse TSI order

				send_tsi (FTSI, &G(c2_dce_buf_ptr[3]));	            //  Send ID string to DTE
			}

			break;

		case RSP_TPWD:
		case RSP_TPWD+1:
		case RSP_PPWD:
		case RSP_SUB:
		case RSP_SUB+1:
		case RSP_SEP:
		case RSP_NSS:			                         // Non-Standard Setup command
		case RSP_NSS+1:                            // Non-standard setup for polling
			display_opt_rsp ((byte)G(c2_dce_buf_ptr[2]));  // Display response of optional T.30 signal
			break;

		case RSP_NSF:                             // Remote device wants to poll now
		case RSP_CSI:
		case RSP_DIS:
			G(c2rf.flag) = G(c2rf.flag) | T30_BIT;      // Update dynamic bit
		case RSP_DTC:
			G(c2_sequence) = org_sequence; // Switch to ORIGINATE sequence
			G(c2_sequence_ptr) = ORG0;                  // Decode DIS/DTC state
			look_4_dis ();                              // Decode DIS/DTC now; updates G(c2_sequence_ptr) properly
			return;

		case RSP_DCS+1:                            // DCS for polling
		case RSP_DCS:
			G(c2rf.flag) = (G(c2rf.flag) & ~0x01) +
						((G(c2_dce_buf_ptr[4]) & 0x30) == 0x20);                   // Save V.17 modulation bit

			dcs2vr ();                // Convert DCS bits to VR value
#ifdef V34_FAX
			if (G(x_fax_v34mode) != NON_V34)           // Using V.34 modulation?
	#ifdef TEST_V34_FAX_WITH_WINFAX80
				G(c2rf.dcs.ps.br) = getActualPRate () - 6; // Shift down to 2,400 through 14,000 range
	#else
				G(c2rf.dcs.ps.br) = getActualPRate ();     // Display negotiated, primary-channel rate
	#endif
			else
#endif
				G(c2rf.dcs.ps.br) = dcs_rate [(G(c2_dce_buf_ptr[4]) >> 2) & 0x0F];      // BR: Bit rate

			G(c2rf.dcs.ps.wd) = G(c2_dce_buf_ptr[5]) & 0x03;             // WD: Width
			G(c2rf.dcs.ps.ln) = (G(c2_dce_buf_ptr[5]) & 0x0C) >> 2;      // LN: Length

			if ( (G(c2rf.dcs.ps.br) == 0xFF) ||  // Invalid DCS rate? (See Telegra OVER-402)
					 (G(c2rf.dcs.ps.wd) >= 3) ||     // Invalid DCS width? (See Telegra OVER-410)
           (G(c2rf.dcs.ps.ln) >= 3) )      // Invalid DCS length? (See Telegra OVER-410)
			{
				G(c2p.faxerr) = 71;	  // RSPREC error
				exit_state ();
				return;               // Exit this function now
			}

			dcs2df ();                                                   // DF: Convert DCS bits to DF value
			G(c2rf.dcs.ps.ec) = 0;		    						                   // EC: Error Correction	(none)
#ifdef FAX_ECM                                                     
			if ( (G(c2_dce_buf_ptr[6]) & 0x04) &&                        // Error correction mode negotiated?
					 (G(c2_dce_buf_ptr[5]) & 0x80) )                         // Last frame was a Non-final frame
			{
				if (G(c2p.fclass) == 2)  // Class 2 interface?
					G(c2rf.dcs.ps.ec) = G(c2_dce_buf_ptr[6]) & 0x08 ? 1 : 2;   // Indicate frame size -- 1: 64 bytes; 2: 256 bytes

				else  // Class 2.0/2.1 interface
					G(c2rf.dcs.ps.ec) = 1;  // Indicate T.30 Annex A, ECM

				G(c2_var4) = (G(c2_dce_buf_ptr[6]) & 0x08) != 0;  // Save negotiated frame size: 1=64; 0=256 byte frames
			}

	#if defined(CS_4) || defined(ECM_64K_BUFF)
			if ( G(c2rf.dcs.ps.ec) && (G(c2_dce_buf_ptr[6]) & 0x08) )  // Using 64-byte frames?
				dont_use_64k ();           // Free 64K of RAM, if allocated
	#endif
#endif                                                             
			G(c2rf.dcs.ps.bf) = 0;			    					                   // BF: Binary file xfer (not allowed)
			G(c2rf.dcs.ps.st) = dcs_scan_time [(G(c2_dce_buf_ptr[5]) >> 4) & 0x07]; // ST: Scan time

#ifdef CLASS20_FAX
			if (G(io_hdlc_byte_count) >= 12) // Color parameters included in DCS?
			{
				G(c2rf.dcs.ps.jp) = (G(c2_dce_buf_ptr[11]) & 0x78) >> 3;
				G(c2rf.dcs.ps.jp) = G(c2rf.dcs.ps.jp) | ((G(c2_dce_buf_ptr[12]) & 0x7) << 4);
			}

			else
				G(c2rf.dcs.ps.jp) = 0;  // Color is not enabled

			G(c2p.fdcs.ps.jp) = G(c2rf.dcs.ps.jp); // Copy to +FDCS (+FCS)
#endif

			for (i=0; i<8; i++)
				G(c2p.fdcs.pa[i]) = G(c2rf.dcs.pa[i]);			                   // Copy to local parameters

			if ( (G(c2p.fet) != 1) &&				                            // Inter-page status not EOM?  AND
				 (~G(c2s.flag) & FTT_SENT) )		                            // FTT not sent?
			{
				send_dte_dcs ();		                                     // Send +FDCS to DTE

				if (!(G(c2rf.flag) & ORG_POLL))       // Not doing Originate polling?
					G(c2s.flag) = G(c2s.flag) | AT_ENABLE;        // Enable AT-command task, get +FDR from DTE
			}

			G(c2p.faxerr) = 72;				                                  // COMREC error if call terminated
			G(c2s.flag) = G(c2s.flag) & ~TRAIN_GOOD;                           // Initialize training results
			G(c2s.flag) = G(c2s.flag) | (SPT111 | DCS_RECEIVE);        // Indicate DCS received since last post-page message; for DIS
			G(c2s.dte_cmd) = 0;                                       // Clear expected command from AT-command task
			G(c2_tcf_zeros_needed) = 0;			                               // Initialize parameters for training
			G(c2_tcf_error_cnt) = 0;
			G(c2rf.flag) = G(c2rf.flag) & ~CARRIER_GAP;  // Assume no carrier gaps in TCF

			if (G(c2rf.dcs.ps.br) <= 1)   // V.27 rate?
				G(c2s.t30) = 26;            // Value needed for V.27 so T.30 delay is 75ms +/- 20ms
			else
				G(c2s.t30) = 43;            // Value needed for other modulations so T.30 delay is 75ms +/- 20ms

#ifdef FAX_ECM
			G(ecm_fax_hdlc) = 0;                                            // Idle character = 0x00
#endif
			set_train (V17_LONG_TRAIN);                                  // Do long train for TCF
#ifdef V34_FAX
			if (G(x_fax_v34mode) != NON_V34)       // Using V.34 modulation?
			{
				if (G(c2s.flag) & AT_ENABLE)         // Need an AT-command?
					send_mdm_stat (OK);                // Send READY/"OK" to DTE

				G(c2s.timer) = x_current_time ();	  // Reset time-out timer
				G(c2_sequence_ptr) = G(c2_sequence_ptr) + 6;  // Skip non-V.34 states; Send CFR
				return;
			}
#endif
			break;

		case RSP_DCN+1:   // DCN for polling
		case RSP_DCN:
			G(c2p.faxerr) = 0;
			exit_state ();
			return;

		case PPM_MPS:				 // Post-page message again, so
		case PPM_MPS+1:         
		case PPM_EOM:				 // calling modem didn't receive the response.
		case PPM_EOM+1:
		case PPM_EOP:
		case PPM_EOP+1:	     
		case PPM_PRI_EOM:
		case PPM_PRI_EOM+1:
		case PPM_PRI_EOP:
		case PPM_PRI_EOP+1:     
		case PPM_PRI_MPS:
		case PPM_PRI_MPS+1:     
			G(c2p.fet) = ((G(c2_dce_buf_ptr[2]) & 0x0020) >> 4) +   // Convert to +FET: value
						 ((G(c2_dce_buf_ptr[2]) & 0x0080) != 0);	   //  from T.30 value
			G(c2_sequence_ptr) = ANS6;	                       // Send response to post-page message
			return;

		default:  // Invalid mandatory command; terminate call.  Otherwise, ignore invalid optional commands
			if (G(c2_dce_buf_ptr[1]) == 0x13)  // Final Frame?
			{
				G(c2p.faxerr) = 71;	  // RSPREC error
				exit_state ();
				return;                           // Exit this function now
			}
	}

	if (G(c2_dce_buf_ptr[1]) == 0x13)  // Final frame?
	{
		if (G(c2s.flag) & AT_ENABLE)              // Need to get an AT-command?
		{
			cs_fax_response (0);                    // Load CS fax response to M-H buffer
			send_mdm_stat (OK);                     // Send READY/"OK" to DTE
		}

		G(c2_sequence_ptr)++;
	}

	else
		G(c2_sequence_ptr)--;					                 // Continue to look for DCS/DTC command

	G(c2s.timer) = x_current_time ();	// Reset time-out timer
}

// -------------------------------- //
// Send the TSI response to the DTE //
// -------------------------------- //

void send_tsi (byte rsp_id, word *src)
{
#if defined(IWF_FAX) || defined(CLASS20_FAX)
	if ( (G(c2p.fnr) & FNR_IDR) ||     // Display the FTI response?
			(G(c2p.fclass) == 2) )              // Always display for class 2?
#endif
		load_rsp_str (rsp_id, src);
}

// -------------------------------------- //
// Receive the TCF from the calling modem //
// -------------------------------------- //

void rx_tcf (void)
{
	word cnt, v3;
	static const word zero_tbl [] = {300, 600, 900, 1200, 1500, 1800};

	if (x_elapsed_time (G(c2s.timer)) > 3500)  // Greater than 3.5 seconds?
	{
		next_state ();
		return;
	}

	if (~G(c2s.flag) & CARRIER_DET)    // Wait until carrier is detected
		return;

	if (!(dp_regread (DP_EIA_REGISTER) & 0x04) &&   // Carrier gone?
			 (x_elapsed_time (G(c2s.timer)) < 1350) )   // Less than minimum TCF duration? (1.5 seconds - 10%)
		G(c2rf.flag) = G(c2rf.flag) | CARRIER_GAP;  // Indicate carrier gap

	cnt = io_get_dce_rx_count ();   // Number of bytes in buffer

	while (cnt--)
	{
		v3 = read_dce_fifo ();		     // Read byte from DCE buffer

		if (!G(c2_tcf_zeros_needed))	 // Looking for 1st NULL of a 1-second block?
		{
			if (v3 == 0)				         // Is this a NULL character?
				G(c2_tcf_zeros_needed)++;	          // Disable this branch; look for 1 second of zeros
		}

		else  // Look for 1 second of continuous zeros
		{
			if (v3 != 0)				           // NULL not received?
				G(c2_tcf_zeros_needed) = 0;	 // Restart window on next NULL byte

			else                           // NULL received
			{
				G(c2_tcf_zeros_needed)++;    // Count zeros

				if ( G(c2_tcf_zeros_needed) >= zero_tbl [G(c2p.fdcs.ps.br)] )	  // Enough zeros? (Telegra's definition of a good TCF. See OVER-20x)
				{
					G(c2s.flag) = G(c2s.flag) | TRAIN_GOOD;		 // Indicate training was acceptable
					next_state ();                             // Wait for carrier to go away
					break;                                     // Exit while loop
				}
			}
		}
	}

	if (x_elapsed_time (G(c2s.timer)) > 1350)  // Time greater than minimum TCF duration? (1.5 sec - 10%)
	{
		if ( (G(c2rf.flag) & CARRIER_GAP) ||           // Carrier gap detected?
				 !(dp_regread (DP_EIA_REGISTER) & 0x04) )  // Carrier gone?
			next_state ();                               // Send FTT when carrier is gone
	}
}

// ------------------------------------------------- //
// Send the CFR or FTT response to the calling modem //
// ------------------------------------------------- //

void send_cfr_ftt (void)  
{
	byte i;

	if (~G(c2s.flag) & CARRIER_DET)	  // Wait until preamble is sent
		return;

#ifdef V34_FAX
	if (G(x_fax_v34mode) != NON_V34)  // Using V.34 modulation?
	{
		if ( (G(c2s.dte_cmd) == DTE_FDR) ||     // Received +FDR yet?
				 (G(c2p.fet) == 1) ||	             // Inter-page status equal to EOM?
				 (G(c2rf.flag) & ORG_POLL) )          // Polling operation?
		{
			dp_write_dsp_ram (0x1FFF, 0);	  	 // Clear detect 1s flag
			G(c2s.flag) = G(c2s.flag) | TRAIN_GOOD;  // Always good for V.34
		}

		else                                 // Haven't received +FDR
			return;                            // Wait until it's sent from DTE
	}
	else
#endif
	if (G(c2rf.dcs.ps.br) > G(c2p.fdis.ps.br))    // Above bit rate limit?
		G(c2s.flag) = G(c2s.flag) & ~TRAIN_GOOD;	// Ignore train & force fallback to lower rate

	if (G(c2s.flag) & TRAIN_GOOD)
	{
		if ( (G(c2s.dte_cmd) == DTE_FDR) ||	  // Received +FDR from the DTE?
				 (G(c2p.fet) == 1) ||				      // Inter-page status equal to EOM?
				 (G(c2s.flag) & FTT_SENT) ||		    // FTT sent for prior training?
				 (G(c2rf.flag) & ORG_POLL) )         // Polling operation?
		{
#if defined(IWF_FAX) || defined(CLASS20_FAX)  
			if (G(c2p.fclass) == 2)                      // Class 2 FAX selected?
#endif
				load_rsp_ind (FCFR);              // Send +FCFR to host

			if ( (G(c2s.flag) & FTT_SENT) ||	  // Bit rate renegotiated?  OR
				 (G(c2p.fet) == 1) )			        // Inter-page status equal to EOM?
			{
				if (G(c2p.fet) == 1)			  // Inter-page status equal to EOM?
				{
						for (i=0; i<20; i++)
							G(c2_dce_buf_ptr[i]) = (word)G(c2rf.tsi[19-i]);     // Copy TSI to DCE buffer reverse order

					send_tsi (FTSI, G(c2_dce_buf_ptr));			       // Send TSI to DTE
				}

				send_dte_dcs ();	        // Send updated DCS to DTE
				G(c2s.flag) = G(c2s.flag) & ~FTT_SENT;  // Clear flag
			}

			send_hdlc_cmd (RSP_CFR);          // Send CFR to calling modem
			init_rx_page ();				  // Initialization before receiving page data
			next_state ();
			return;
		}

		else	   // DTE did not respond in time
			exit_state ();
	}

	else
	{
		send_hdlc_cmd (RSP_FTT);		 // Send failure-to-train command to remote modem
		G(c2_sequence_ptr) = ANS1;			 // Receive new DCS from remote modem
		G(c2s.flag) = G(c2s.flag) | FTT_SENT;	 // Indicate DCS will be different than that sent to DTE
	}

	G(c2s.timer) = x_current_time ();	 // Reset time-out timer
}

// ----------------------------------------- //
// Initialization before receiving page data //
// ----------------------------------------- //

void init_rx_page (void)  
{
	io_init_dce_rx_fifo ();           // Initialize DCE Rx queue
	set_train (V17_SHORT_TRAIN);	    // V.17 short train; others, long train

#ifdef FAX_ECM                     
	if (G(c2p.fdcs.ps.ec))           // ECM negotiated?
	{
		G(ecm_fax_hdlc) = 1;           // HDLC mode for ECM; idle char = 0x7E
		ecm_rx_init ( G(c2_var4) );    // Initialize ECM Rx; pass negotiated frame size
	}
#endif                             

	G(c2_var4) = 0;			                // Initialize the number of zeros detected
	G(c2p.faxerr) = 73;		             // T.30 T2 timeout, expected page not received
	G(c2s.flag) = G(c2s.flag) | C2FC_ON;      // Turn on flow control
	G(c2s.flag) = G(c2s.flag) & ~RX_PAGE;   // Clear flag to look for 1st EOL
	G(c2rf.flag) = G(c2rf.flag) & ~CARRIER_GAP;  // Assume no carrier gaps
	init_qc ();                       // Initialize quality checking
	G(c2_tcf_error_cnt) = 0;                // Count lines received here
	G(c2s.t200ms) = x_current_time ();  // Reset carrier drop-out timer

#if defined(IWF_FAX) || defined(CLASS20_FAX) 
	G(c2_ovr_cnt) = 0;            // Clear bytes lost due to overrun
	G(c2rf.flag) = G(c2rf.flag) & ~2; // Clear Rx overrun flag
#endif
}

// ------------------------------------ //
// Wait until the first EOL is received //
// ------------------------------------ //

void wait_4_1st_eol (void)
{
	word cnt;
	byte i;

	if (x_elapsed_time (G(c2s.timer)) >= 9000)   // T.30, Timer T2, plus Telegra OVER-140 margin, expired?
	{
		G(c2_sequence_ptr) = ANSX;
		G(c2s.timer) = x_current_time ();
		return;
	}

#ifdef V34_FAX
	if (G(x_fax_v34mode) == NON_V34)   // Not using V.34 modulation?
#endif
	{
		if (dp_read_dsp_ram (0x3B) & 0x0800) // V.21 detected?
		{
			G(c2s.flag) = G(c2s.flag) | FTT_SENT; // Treat this the same as a FTT
			setup_hdlc_rx ();			    // Configure modem to receive HDLC @ 300
			G(c2p.faxerr) = 72;			    // COMREC error
			G(c2_sequence_ptr) = ANS2;            // Receive DCS again.  Remote modem didn't receive CFR.
			G(c2s.timer) = x_current_time ();  // Reset the time-out timer
			return;
		}

		if (~G(c2s.flag) & CARRIER_DET)	    // Carrier detected yet?
			return;
	}

#ifdef FAX_ECM  
	if (G(c2p.fdcs.ps.ec))   // ECM negotiated?
	{
		ecm_mode ();   // Run ECM Rx state machine; set G(c2_sequence_ptr) to ANS_ECM
		return;        // Skip the rest of this function
	}
#endif            

	if (~G(c2s.flag) & RX_PAGE)		    // "CONNECT" sent to DTE yet?
	{
		send_mdm_stat (CONNECT);      
		G(c2s.flag) = G(c2s.flag) | RX_PAGE;  // Indicate message sent
	}

	if (!(dp_regread (DP_EIA_REGISTER) & 0x04))  // Carrier gone?
	{
		if (x_elapsed_time (G(c2s.t200ms)) > 200)  // for 200ms?
			exit_state ();
	}

	else
		G(c2s.t200ms) = x_current_time ();  // Reset carrier drop-out timer

	cnt = io_get_dce_rx_count ();	  // Get the number of bytes in the DCE queue

	while (cnt--)
	{
		G(c2_var1) = (byte) read_dce_fifo ();	 // Add in current byte received

		for (i=1; i; i = i<<1)			 // Check each bit in the byte
		{
			if (G(c2_var1) & i)				 // Is the bit a '1'?
			{
				if (G(c2_var4) >= 11)	                   // Has at least eleven prior '0' been Rx? (EOL = 11 zeros and 1 one)
				{
					if ( (G(c2p.dbf) & FCQ)	&&        // Quality checking enabled
						  (G(c2p.fbadmul) || G(c2p.fbadlin)) )
					{
						chk_rx_qual (0);		   // Note: EOL sometimes found in garbage!
						chk_rx_qual (0);       // Prime the Rx quality checking function with an EOL
						chk_rx_qual ( (byte)G(c2_var1) );
					}

					G(c2_var2) = 0;                      // Count bytes per line
					G(c2_var4) = 0;					   // Initialize number of zero bits detected
					G(c2_rtc) = 0;					   // Initialize number of EOL detected in RTC
					G(c2p.faxerr) = 90; 	           // Unspecified Receive Phase C error
					G(c2rf.flag) = G(c2rf.flag) & ~ORG_POLL;  // Clear polling flag, normal receive from this point forward
					next_state ();
					return;
				}

				else
					G(c2_var4) = 0;	 // Reset zero-bit counter
			}

			else
				G(c2_var4)++;			 // Count zero bits
		}
	}
}

// ------------------------- //
// Receive the FAX page data //
// ------------------------- //

void rx_page_data (void)  
{
	word cnt, v1;
	byte i;
	byte q;
	byte df = G(c2p.fdcs.ps.df);            // Results of negotiated 2D encoding

	cnt = io_get_dce_rx_count ();   // Number of bytes in DCE buffer

	if (dp_read_dsp_ram (0x3B) & 0x0800) // V.21 detected?
	{
		if ((x_elapsed_time (G(c2s.t200ms)) > 50) && !cnt)  // 50 ms of V.21 and no more data to process?
		{
			page_end ();     // Do end of page processing
			next_state ();   // Get PPS
			return;          // Skip the rest of this function
		}
	}

	else
		G(c2s.t200ms) = x_current_time ();  // Reset V.21 carrier detect timer

	if (!(dp_regread (DP_EIA_REGISTER) & 0x04) )  // Carrier gone?
		G(c2rf.flag) = G(c2rf.flag) | CARRIER_GAP;  // Indicate gap in high-speed carrier

	cnt = io_get_dte_rx_bytes ();	  // Get number of bytes in DTE Rx queue

	while (cnt--)
		switch (read_dte_fifo ())				// Get a byte from the DTE
		{
			case XOFF:
				G(c2s.flag) = G(c2s.flag) | C2FC_ON;    // Turn on flow control
				break;

			case 0x12:	                       // <DC2>
					write_dte_fifo (0);            // Send 1st EOL to DTE
					write_dte_fifo (0);
			#ifdef IWF_FAX
					if (G(c2p.dbf) & 0x1000)		     // +FBOR: Reverse bit order for phase C? (According to spec)
			#else
					if (~G(c2p.dbf) & 0x1000)		     // +FBOR: Reverse bit order for phase C? (Industry implementation)
			#endif
						G(c2_var1) = (word)rev_bits ((byte)G(c2_var1));  // Reverse the bit order

					write_dte_fifo ((byte)G(c2_var1));
					// Fall through
			case XON:
				G(c2s.flag) = G(c2s.flag) & ~C2FC_ON;   // Turn off flow control
				break;

			case CAN:
			case 'g':     // Winfax 4.0 cancel character (From TAS code)
				write_dte_fifo (DLE);
				write_dte_fifo (ETX);
				G(c2p.faxerr) = 2;                           // Call aborted from +FK (Cancel)
				G(c2_sequence) = org_sequence;	 // Send DCN (use end of originate sequence)
				G(c2_sequence_ptr) = ORGX;
				return;
		}

	if (G(c2s.flag) & C2FC_ON)  // Flow control on?
	{
#if defined(IWF_FAX) || defined(CLASS20_FAX)  
		chk_rx_overrun ();  // Check if DCE is filling up
#endif
		return;			     // Exit if so
	}

	cnt = io_get_dte_tx_count() ;       // Number of locations available in DTE Tx buffer

#if defined(IWF_FAX) || defined(CLASS20_FAX) 
	if (cnt > 4)
		G(c2rf.flag) = G(c2rf.flag) & ~2;          // Clear the overrun flag
#endif

	if (G(c2_tcf_error_cnt) >= 3)               // First 3 lines ignored for 5 second check
		G(c2_var1) = 1500 + 1500 * G(c2rf.dcs.ps.br);  // Max number of bytes/line/bit-rate for 5 seconds
	else
		G(c2_var1) = 0xFFF0;                      // Very large number for 1st three lines

	q = (G(c2p.dbf) & FCQ) &&                 // Check Rx quality if: Quality check enabled,
		 !(G(c2p.sbf) & FND) &&                // Not using non-standard data
		 (G(c2p.fbadmul) || G(c2p.fbadlin));      // One or both "bad page" threshold levels is set

	while (cnt-- > 4)			            // At least 4 locations left (DLE + inserted DLE + <DLE> + <ETX>)
	{
		v1 = read_dce_fifo ();	         // Get a received byte

		if (v1 & 0xFF00)			         // Was anything read?
			return;					         // Exit if not

		if (++G(c2_var2) > G(c2_var1))               // Line longer than 5 seconds?
		{
			write_dte_fifo (DLE);         // Signal end of page to DTE
			write_dte_fifo (ETX);
			G(c2s.timer) = x_current_time ();// Reset the time-out timer
			G(c2p.faxerr) = 91;	            // Missing EOL after 5 seconds
			G(c2_sequence_ptr) = ANSX;          // Send +FHNG:91 & terminate connection
			break;					         // Exit loop
		}

		G(c2_var3) = v1;					         // Save as received

		if (q)                             // Quality checking enabled?
			chk_rx_qual ((byte)G(c2_var3));  // Monitor line quality

		if ( (G(c2_var4) < 11) || v1)          // Not waiting for EOL or non-zero data? (i.e. don't remove zero padding?)
		{
	#ifdef IWF_FAX
			if (G(c2p.dbf) & 0x1000)		     // +FBOR: Reverse bit order for phase C? (According to spec)
	#else
			if (~G(c2p.dbf) & 0x1000)		   // +FBOR: Reverse bit order for phase C? (Industry implementation)
	#endif
				v1 = (word)rev_bits ((byte)v1);  // Reverse the bit order

			if (v1 == DLE)			         // DLE bit pattern?
				write_dte_fifo (DLE);	   // Insert a DLE in the sequence

			write_dte_fifo ((byte) v1);   // Send byte to DTE

			for (i=1; i; i = i<<1)		   // Check each bit in the byte
			{
				if (G(c2_var3) & i)			      // Is the bit a '1' as received?
				{
					if (G(c2_var4) >= 11)	      // Has at least eleven prior '0' been Rx? (EOL = 11 zeros and 1 one)
					{
						G(c2_rtc)++;				   // Increment number of consecutive EOLs
						G(c2_var2) = 0;            // Reset the byte counter
						G(c2_tcf_error_cnt)++;     // Increment the number of lines received
						G(c2s.timer) = x_current_time ();  // Reset the time-out timer
					}
					else
						G(c2_rtc) = df && !G(c2_var4) ? G(c2_rtc) : 0;  // Don't reset after EOL+1 if using 2D encoding

					G(c2_var4) = 0;	            // Reset zero-bit counter
				}

				else
					G(c2_var4)++;			         // Count zero bits
			}
		}

		if (G(c2_rtc) > 2)      // RTC detected? (3 out of the 6 EOLs sent)
		{
			page_end ();
			next_state (); 
			return;
		}
	}

	chk_rx_overrun ();  // Check for Receive overrun
}

// --------------------------------------------------- //
// Decode the post-page message from calling FAX modem //
// --------------------------------------------------- //

void decode_ppm (void)
{
	switch ((byte)G(c2_dce_buf_ptr[2]) & 0xFE) // What post-page message was sent?
	{
		case PPM_PRI_MPS:  // Accept, but ignore procedure interrups
		case PPM_MPS:	   // Multi-page segment
			G(c2p.fet) = 0;
			break;

		case PPM_PRI_EOM:  // Accept, but ignore procedure interrupts
		case PPM_EOM:	   // End of message
			G(c2p.fet) = 1;
			break;

		case PPM_PRI_EOP:  // Accept, but ignore procedure interrupts
		case PPM_EOP:	   // End of procedure
			G(c2p.fet) = 2;
			break;

		case RSP_DCN:
		case RSP_DCN+1:
			G(c2p.faxerr) = 0;   // Normal & proper termination
			exit_state ();
			return;

		default:		   // Invalid command
			G(c2p.faxerr) = 102;	   // COMREC invalid response received
			exit_state ();
			return;
	}

	load_rsp_stat (FET, G(c2p.fet));
	cs_fax_response (0);
	send_mdm_stat (OK);            
	G(c2s.dte_cmd) = 0;					 // Clear DTE command
	G(c2s.flag) = G(c2s.flag) | AT_ENABLE;     // Enable AT-command task
	G(c2_var4) = DTE_FDR;						 // Expect another +FDR
	next_state ();
}

// -------------------------------- //
// Wait for AT command from the DTE //
// -------------------------------- //

void wait_4_dte_cmd (void)
{
	if (G(c2s.dte_cmd) == DTE_FK)          // Terminate command (+FK)?
	{
		G(c2s.timer) = x_current_time ();   // Reset time-out timer
		G(c2p.faxerr) = 2;                  // Call aborted from +FK
		G(c2_sequence) = org_sequence; // Send DCN (use end of originate sequence)
		G(c2_sequence_ptr) = ORGX;
		return;
	}

	if (G(c2s.dte_cmd) == G(c2_var4))		      // Was expected command received?
	{
		G(c2s.dte_cmd) = 0;                 // Clear command
		next_state ();
	}

	if ( (G(c2_sequence) == org_sequence) &&    // In originate sequence?
			 (G(c2s.dte_cmd) == DTE_FDR) )       // +FDR received?
	{
		if ( (G(c2rf.flag) & REMOTE_POLL) &&       // Remote device has a document to poll?
				 (G(c2p.sbf) & FSPL) &&              // DTE wants to poll?
				 (G(c2p.sbf) & FCR) )                // Receive is enabled?
		{
			if (G(c2_sequence_ptr) == 3)             // In Phase B?
			{
			#ifdef V34_FAX
				if (G(x_fax_v34mode) != NON_V34)      // Using V.34 modulation?
					G(x_fax_v34mode) = V34_RECEIVE;    // Switch to Rx mode
				else
			#endif
					setup_hdlc_tx ();                  // Setup to Tx HDLC

				G(c2_sequence) = ans_sequence; // Use answer sequence
				G(c2_sequence_ptr) = ANS0-1;                // Rx Initialization
				G(c2rf.flag) = G(c2rf.flag) | ORG_POLL;     // Indicate Originate polling
				G(c2s.timer) = x_current_time ();           // Reset the timer
				G(c2s.dte_cmd) = 0;                         // Clear command
			}

			else    // Phase D
			{
			#ifdef V34_FAX
				if (G(x_fax_v34mode) == NON_V34)   // Not using V.34 modulation?
			#endif
				// Note: Download FAX to DSP here because there won't be enough time
				//       to do it between DCS & TCF if necessary (See Telegra AVER-126 & -127)
				{
					dp_download_fax ();           // Download FAX code to DSP
					G(dp_fax_downloaded) = TRUE;  // Don't download in dp_fax_startup ()
					G(last_fax_v17) = NON_V17;
					setup_hdlc_rx ();             // Setup to receive CSI/DIS
				}

				G(c2rf.flag) = G(c2rf.flag) | ORG_POLL;      // Indicate Originate polling
				G(c2s.timer) = x_current_time ();     // Reset the timer
				G(c2s.dte_cmd) = 0;                   // Clear command
				G(c2_sequence_ptr) = ORG11;              // Receive, but ignore NSF/CSI/DIS
				G(c2_var1) = x_current_time ();  // Start T1 timer
			}
		}

		else if (G(c2p.fet) == 1)                 // +FDR at end of message?
		{
			G(c2s.flag) = G(c2s.flag) | SPT111;         // Wait 6 seconds
			G(c2_sequence) = ans_sequence; // Switch to answer state machine
			goto_phase_b ();                            // Initialize for T2 delay state
		}

		else                                   // Don't know what to do with this +FDR
			exit_state ();                       // Terminate call
	}
}

// ----------------------------- //
// Send MCF to calling FAX modem //
// ----------------------------- //

void send_mcf (void)
{
	static const byte rsp[4] = {RSP_MCF, RSP_MCF, RSP_RTN, RSP_RTP};

	if (~G(c2s.flag) & CARRIER_DET)	// Wait until preamble is sent
		return;

	send_hdlc_cmd (rsp[G(c2p.fpts)]);  // Send status of page received
	next_state ();
}

// --------------------------------------------------------- //
// Set the proper state after sending MCF based on FET value //
// --------------------------------------------------------- //

void set_state_after_mcf (void)
{
	if ( (G(c2p.fpts) == 2) || (G(c2p.fpts) == 3) )  // RTN? or RTP?
	{
		init_rx_page ();            // Initialize to receive next page
		G(c2_sequence_ptr) = ANS3;  // Turn on high-speed receiver
	}

	else
		switch (G(c2p.fet))
		{
			case 0:	// MPS -- Multi-page segment
				init_rx_page ();	  // Initialization before receiving page data
				G(c2_sequence_ptr) = ANS3;  // Receive another page of data
				break;

			case 1:	// EOM -- End of message
				goto_phase_b ();   
				break;

			case 2:	// EOP -- End of procedure
				G(c2_sequence_ptr)++;		  // Wait for DCN from remote FAX modem
				break;

			default:
				G(c2_sequence_ptr)++;		  // Wait for DCN
		}

	G(c2s.timer) = x_current_time ();	  // Reset the time-out timer
}

// ----------------------------------------------------- //
// Switch to Originate State Machine with Initialization //
// ----------------------------------------------------- //

void start_org_state (void)
{
	setup_hdlc_rx ();        // Set modem to Rx HDLC
	org_init ();             // Initialization for Tx
	G(c2s.flag) = G(c2s.flag) & ~SEND_FCON;  // Don't display +FCON/+FCO
	G(c2_sequence) = org_sequence; // Switch to Originate state machine
	G(c2_sequence_ptr) = ORG11;    // Wait for NSF/CSI/DIS
}

// ------------------------------------------------ //
// Check if the received command is DCN (Disconnect //
// ------------------------------------------------ //

void check_dcn (void)
{
	if ( ((byte)G(c2_dce_buf_ptr[2]) & 0xFE) == RSP_DCN)  // Disconnect from remote modem?
		G(c2p.faxerr) = 0;    // Normal and proper termination

	else if ( ((byte)G(c2_dce_buf_ptr[2]) & 0xFE) == PPM_EOP)
	{
		G(c2_sequence_ptr) = 23;
		G(c2s.timer) = x_current_time ();
		return;
	}

	else
		G(c2p.faxerr) = 102;  // COMREC invalid response received

	next_state ();
}

// ---------------------- //
// End of call processing //
// ---------------------- //

void end_of_call (void)
{
	send_fhng ();		// Send +FHNG:n to the DTE
	next_state ();
}

// ------------------------------------ //
// Send the +FHNG:n response to the DTE //
// ------------------------------------ //

void send_fhng (void)
{
	byte val = G(c2p.faxerr);

#if defined(IWF_FAX) || defined(CLASS20_FAX)
	if (G(c2p.fclass) == 0x20)
		val = ((G(c2p.faxerr) / 10) << 4) + G(c2p.faxerr) % 10;  // Convert decimal to hex (e.g. 34 (0x22) to 0x34)
#endif
	load_rsp_stat (FHNG, val);
	cs_fax_response (0);

#ifdef CS_MODEM
	send_mdm_stat (OK);
#endif
}

// -------------------------------------------- //
// Send ID string to remote modem (TSI/CSI/CIG) //
// -------------------------------------------- //

void send_modem_id (byte cmd)
{
	byte i=0;
	byte *ptr;

	if (cmd == RSP_CIG)          // Orginate polling?
		ptr = G(c2p.fcig);

	else
		ptr = G(c2p.flid);           // CSI or TSI

	while (i < 20)					  // Check if string is programmed
		if (ptr[i++] != ' ')
			break;

	if (i != 20)
	{
		if (cmd == RSP_TSI)
			cmd = cmd + DYNAMIC_BIT;   // Dynamic bit used for TSI
																																	
		G(c2_dce_buf_ptr[0]) = 0xFF;		   // Address
		G(c2_dce_buf_ptr[1]) = 0x03;        // Not final frame
		G(c2_dce_buf_ptr[2]) = (word)cmd;   // CSI/TSI command

		for (i=0; i<20; i++)
			G(c2_dce_buf_ptr[i+3]) = (word) ptr[19-i];  // Reverse the byte order

		G(io_hdlc_byte_count) = 23;	   // 23 bytes in message
		io_fax_hdlc_buf_to_dce( G(io_fax_buf), &G(io_hdlc_byte_count));
	}
}

// -------------------------- //
// Send +FDCS response to DTE //
// -------------------------- //

void send_dte_dcs (void)
{
#if defined(IWF_FAX) || defined(CLASS20_FAX)
	if ( (G(c2p.fnr) & FNR_TPR) ||                             // +FCS allowed for Class 2.0?
			 (G(c2p.fclass) == 2) )
#endif
		load_rsp_cmpd (FDCS, (byte*)&G(c2rf.dcs.pa[0]));           // Send new +FDCS (+FCS) to host
}

// ----------------------------------------------- //
// Wait until the remote modem's carrier goes away //
// ----------------------------------------------- //

void wait_till_carrier_gone (void)
{
	if (!(dp_regread (DP_EIA_REGISTER) & 0x04))
		next_state ();
}

// ------------------------------------------------------------ //
// Send a single byte HDLC command/response to remote FAX modem //
// ------------------------------------------------------------ //

void send_hdlc_cmd (byte cmd)
{
	G(c2_dce_buf_ptr[0]) = 0xFF;
	G(c2_dce_buf_ptr[1]) = 0x13;		// Final frame
	G(c2_dce_buf_ptr[2]) = cmd + DYNAMIC_BIT;  // All commands that call this function use the dynamic bit

	G(io_hdlc_byte_count) = 3;
	io_fax_hdlc_buf_to_dce( G(io_fax_buf), &G(io_hdlc_byte_count));
}

// *********************************************************** //
//                      GENERAL PURPOSE FUNCTIONS 			   //
// *********************************************************** //

// ----------------------------------------------- //
// Wait for a decision on receiving a T.30 Command //
// ----------------------------------------------- //

void wait_4_cmd (void)
{
	switch (get_t30_cmd ())
	{
		case 1:  // "No"
			if (G(c2_sequence) == ans_sequence)  // Executing answer sequence
			{
				if (x_elapsed_time (G(c2s.timer)) >= 6050)  // Timer T2 expired (6 seconds)?
					exit_state ();
			}

			else  // Originate sequence
			{
				if (x_elapsed_time (G(c2_var1)) > 35050)       // Timer T1 expired (35 seconds)?
					G(c2_sequence_ptr) = ORG6;                   // Hang up
			}

			break;

		case 2:  // "Yes"
			next_state ();  // Execute next state in sequence
			break;
	}
}

// ------------------------------------------ //
// Look for a T.30 Command (Figure 5.2T/T.30) //
// ------------------------------------------ //
/*
	Return Values:
	 0: No decision yet
	 1: Decision is "No"
	 2: Decision is "Yes"
*/

byte get_t30_cmd (void)
{
	byte decision = 0;

	switch (G(c2s.state))
	{
		case 0:  // Look for flags (carrier)
			if (dp_regread (DP_EIA_REGISTER) & 0x04)        // Carrier (flags) detected?
			{
				G(c2s.t3sec) = x_current_time ();             // Reset 3 second timer
				G(c2s.t200ms) = G(c2s.t3sec);                 // Reset 200ms timer
				G(c2s.timer) = G(c2s.t3sec);                  // Reset 6 seconds T2 timer
				G(c2s.state) = 1;                             // Wait for an HDLC frame
			}

			else  // No flags (carrier)
				decision = 1;  // Return NO, Check T2

			break;

		case 1:  // Wait for an HDLC frame
			switch (io_fax_hdlc_dce_to_buf( G(io_fax_buf), &G(io_hdlc_byte_count)))
			{
				case TRUE:  // Complete frame, no CRC error
					send_fcon ();
					filter_rx_hdlc ();

					if (G(io_hdlc_byte_count) < 113)       // Frame less than 3 seconds? (See Telegra AVER-113)
					{
						decision = 2;  // Indicate "Yes"
						G(c2s.state) = 0;  // Look for flags again next time
					}

//				else  // Frame longer than 3 seconds
//					;   // Ignore it

					break;

				case TRUE+1:                // Complete frame, CRC error
					filter_rx_hdlc ();           // Remove DLE-DLE expansions

					if (G(io_hdlc_byte_count) >= 3)  // Enough bytes to be a valid frame? (addr, ctrl, cmd)
					{                               
						dp_fax_modem_idle_cmd();	// Put datapump in idle mode
						prog_bp_filter ();        // Program IIR, BP filter
						G(c2s.t200ms) = x_current_time ();  // Reset 200ms timer
						G(c2s.state) = 2;         // Wait for signal to go away
					}

//				else    // Less than 3 bytes in bad frame; can't be a valid frame.
//					;	    // Ignore it. (Note: Refer to Telegra Test AVER-103)

					break;

				default:
					if ((dp_regread (DP_EIA_REGISTER) & 0x04))        // Signal present?
					{
						if (x_elapsed_time (G(c2s.t3sec)) >= 3000)   // 3 second delay?
						{
							G(c2s.t3sec) = x_current_time ();          // Reset 3 second timer
							decision = 1;                              // Decision is NO, check T2
						}

						G(c2s.t200ms) = x_current_time ();  // Reset 200ms timer
					}

					else if (x_elapsed_time (G(c2s.t200ms)) >= 200)  // Signal gone for 200ms?
					{
						G(c2s.state) = 0;           // Wait for flags (carrier) again
						decision = 1;               // Decision is NO, Check T2
					}
			}

			break;

		case 2:  // FCS Error; Wait for 200 ms after signal goes away
			if (dp_read_dsp_ram (0x3A) & 0x1000)  // Signal present?
			{
				if (x_elapsed_time (G(c2s.t3sec)) >= 6000)   // 6 second delay? (See Telegra AVER-119)
				{
					G(c2_sequence) = ans_sequence;     // Switch to answer sequence
					G(c2_sequence_ptr) = ANSX;         // Send +FHNG:n and hangup
				}

				G(c2s.t200ms) = x_current_time ();  // Reset 200ms timer
			}

			else if (x_elapsed_time (G(c2s.t200ms)) >= 200)  // Signal gone for 200ms?
			{
				if (G(c2_dce_buf_ptr[1]) == 0x13)  // Final frame had FCS error?
				{
					G(c2_sequence_ptr)--;  // setup_hdlc_tx () will increments c2_sequence_ptr;
					setup_hdlc_tx ();      // Turn on transmitter to send CRP
					G(c2s.t3sec) = x_current_time ();  // Use for preamble time-out
					G(c2s.state) = 3;
				}

				else  // Non-final frame had FCS error
				{
					G(c2_sequence_ptr)--;  // setup_hdlc_rx () will increments c2_sequence_ptr;
					setup_hdlc_rx ();      // Turn on receiver to get repeated command
					G(c2s.state) = 0;
				}
			}

			break;

		case 3:  // Wait for HDLC preamble to be sent
			if (G(c2s.flag) & CARRIER_DET)	// Preamble sent?
			{
				send_hdlc_cmd (RSP_CRP);
				G(c2s.state) = 4;
			}

			else if (x_elapsed_time (G(c2s.t3sec)) >= 1500)  // No CARRIER DETECT after 1.5 seconds?
				G(c2s.state) = 4;                              // Set DSP to receive HDLC

			break;

		case 4:  // Wait for CRP to clear Tx buffer
			if ( (io_dce_tx_fifo_empty ())  ||            // Tx FIFO empty?
					 (x_elapsed_time (G(c2s.t3sec)) >= 2000))  //  Enough time allowed to Tx a command?
			{
				G(c2_sequence_ptr)--;  // setup_hdlc_rx () will increments c2_sequence_ptr;
				setup_hdlc_rx ();      // Turn on receiver to get repeated command
				G(c2s.state) = 0;      // Look for flags (carrier)
			}

			break;
	}

	if (decision)
		G(c2s.state) = 0;   

	return (decision);
}

// ------------------------------------------------ //
// Wait for a decision on receiving a T.30 Response //
// ------------------------------------------------ //

void wait_4_rsp (void)
{
	if ( (G(c2_sequence) == ans_sequence) &&  // Executing Answer sequence?
			 (G(c2s.flag) & DCS_RECEIVE) )             // Valid DCS has already been received?
		wait_4_cmd ();                          // Wait for a command instead of a response

	else
	{
		switch (get_t30_rsp ())
		{
			case 1:  // "No"
				if (G(c2_sequence) == ans_sequence) // Waiting for response to NSF/CSI/DIS?
				{
					if (x_elapsed_time (G(c2_var1)) > 35000)       // Timer T1 expired (35 seconds)
					{
						G(c2p.faxerr) = 11;		  // No answer, T.30 T1 time-out
						G(c2_sequence) = org_sequence;  // Send DCN (end of the originate sequence)
						G(c2_sequence_ptr) = ORGX;
					}

					else
					{
						if (G(io_hdlc_byte_count) != 0) // Received part of a frame? (See Telegra OVER-110)
						{
							G(io_hdlc_byte_count) = 0; // Make sure that next "NO" decision doesn't come here!
							dp_fax_modem_idle_cmd();	// Put datapump in idle mode
							prog_bp_filter ();        // Program IIR, BP filter
							G(c2s.t200ms) = x_current_time ();  // Reset 200ms timer
							G(c2s.state) = 2;         // Wait for signal to go away
						}

						else
							G(c2_sequence_ptr) = ANS0;    // Send CSI/DIS again
					}

					G(c2s.timer) = x_current_time ();  // Reset the time-out timer
				}

				else  // Executing Originate sequence
				{
					if (G(c2_sequence_ptr) == 11)
						check_no_cfr_ftt ();        // Send TSI/DCS/TCF again if not 3rd time

					else
						check_no_ppr ();            // Resend PPS if not third time
				}

				break;

			case 2:  // "Yes"
				next_state ();  // Process T.30 Response
				break;
		}
	}
}

// ------------------------------------------- //
// Wait for a T.30 Response (Figure 5.2S/T.30) //
// ------------------------------------------- //
/*
	Return Values:
	 0: No decision yet
	 1: Decision is "No"
	 2: Decision is "Yes"
*/

byte get_t30_rsp (void)
{
	byte decision = 0;  // No decision yet

	switch (G(c2s.state))
	{
		case 0:  // Wait for flags (carrier)
			if (dp_regread (DP_EIA_REGISTER) & 0x04)        // Carrier (flags) detected?
			{
				send_fcon ();                                 // Send +FCON(+FCO) to DTE once
				G(c2s.t3sec) = x_current_time ();             // Reset 3 second timer
				G(c2s.t200ms) = G(c2s.t3sec);                 // Reset 200ms timer
				G(c2s.state) = 1;                             // Wait for an HDLC frame
			}

			else if (x_elapsed_time (G(c2s.t3sec)) >= 3000) // T4 timer expired?
				decision = 1;                                 // Return NO

			break;

		case 1:  // Wait for an HDLC frame
			switch (io_fax_hdlc_dce_to_buf( G(io_fax_buf), &G(io_hdlc_byte_count)))
			{
				case TRUE:  // Complete frame, no CRC error
					filter_rx_hdlc ();

					if (G(io_hdlc_byte_count) < 113)       // Frame less than 3 seconds? (See Telegra AVER-113)
					{
						if ((byte)(G(c2_dce_buf_ptr[2] & 0xFE)) == RSP_CRP)  // Received a Command Repeat?
							G(c2s.state) = 3;               // Wait for carrier to go away

						else
							decision = 2;  // Indicate "Yes"
					}

//				else  // Frame longer than 3 seconds
//					;   // Ignore it

					break;

				case TRUE+1:  // Complete frame, CRC error
					filter_rx_hdlc ();           // Remove DLE-DLE expansions

					if (G(io_hdlc_byte_count) >= 3)  // Enough bytes to be a valid frame? (addr, ctrl, cmd)
					{                               
						dp_fax_modem_idle_cmd();	// Put datapump in idle mode
						prog_bp_filter ();        // Program IIR, BP filter
						G(c2s.t200ms) = x_current_time ();  // Reset 200ms timer
						G(c2s.state) = 2;   // Wait for signal to go away
					}

//				else    // Less than 3 bytes in bad frame; can't be a valid frame.
//					;	    // Ignore it. (Note: Refer to Telegra Test AVER-103)

					break;

				default:
					decision = chk_t30_tmrs ();
			}

			break;

		case 2:  // FCS Error; Wait for signal to go away
			if (dp_read_dsp_ram (0x3A) & 0x1000)  // Signal present?
			{
				if (x_elapsed_time (G(c2s.t3sec)) >= 3000)   // 3 second delay?
				{
					if ( (G(c2_sequence) != ans_sequence) ||     // Not Answering?
							 (x_elapsed_time (G(c2s.t3sec)) >= 6000) ) // Allow more time for TCF after DCS
						G(c2s.state) = 4;                            // Wait for other end to shut up
				}

				G(c2s.t200ms) = x_current_time ();  // Reset 200ms timer
			}

			else if (x_elapsed_time (G(c2s.t200ms)) >= 200)  // Signal gone for 200ms?
				decision = 1;  // No

			break;

		case 3:  // Received CRP; Wait for signal to go away
			decision = chk_t30_tmrs ();
			break;

		case 4:  // Send a DCN when the other end shuts up!
			if ( (x_elapsed_time (G(c2s.t3sec)) >= 10000) ||  // Didn't shut up after a ridiculous 10 second delay?
					!(dp_read_dsp_ram (0x3A) & 0x1000) )          // Other end finally shutup?
			{
				G(c2_sequence) = org_sequence;  // Send DCN (end of the originate sequence)
				G(c2_sequence_ptr) = ORGX;
			}

			break;

		default:  // Something went wrong
			G(c2s.state) = 0;  // Try to get back in sync
	}

	if (decision)
		G(c2s.state) = 0;

	return (decision);
}

// ------------------------------------------------ //
// Send +FCON (+FCO) to the DTE if not already sent //
// ------------------------------------------------ //

void send_fcon (void)
{
	if (G(c2s.flag) & SEND_FCON)				      // Send +FCON when message received?
	{
		load_rsp_ind (FCON);                    // Send +FCON/+FCO to DTE
		G(c2s.flag) = G(c2s.flag) & ~SEND_FCON; // Clear flag
	}
}

// --------------------------------------------------------------- //
// Check if signal is gone for 200ms or present for over 3 seconds //
// --------------------------------------------------------------- //

byte chk_t30_tmrs (void)
{
	byte decision = 0;

	if ((dp_regread (DP_EIA_REGISTER) & 0x04))        // Signal present?
	{
		if (x_elapsed_time (G(c2s.t3sec)) >= 5000)   // t > 3 second delay + 15% + BIG margin? (See Telegra AVER-102 & AVER-115)
		{
			G(c2_sequence) = org_sequence;     // Switch to originate sequence
			G(c2_sequence_ptr) = ORGX;         // Send DCN and hangup
		}

		G(c2s.t200ms) = x_current_time ();  // Reset 200ms timer
	}

	else if ( (x_elapsed_time (G(c2s.t3sec)) > 850) &&  // Ignore preamble drop-outs (See Telegra AVER-137)
						(x_elapsed_time (G(c2s.t200ms)) >= 200) ) // Signal gone for 200ms?
		decision = 1;               // Decision is NO

	return (decision);
}

// ----------------------------------------------------- //
// Configure the modem to receive Commands and Responses //
// ----------------------------------------------------- //

void setup_hdlc_rx (void)
{
#ifdef V34_FAX
	if ( G(x_fax_v34mode) != NON_V34 )        // Using V.34 modulation?
	{
		G(x_fax_v34channel) = PRIMARY_CHANNEL;  // Switch FROM primary to control channel
		x_send_mail (FAXV34_DETECT1S, DP_TASK, NULL, 0);  // Configure datapump for control channel
	}

	else    // Using V.17, V.33, V.29 or V.27
#endif
	{
		G(x_fax_state) = FAX_RX_HDLC;
		G(x_fax_rate) = MR_300;
		x_send_mail (FAX_STARTUP_RECEIVE, DP_TASK, NULL, 0);
	}

	G(c2s.flag) = G(c2s.flag) & ~CARRIER_DET;    // Clear carrier-detected flag
	next_state ();
	G(c2s.t3sec) = x_current_time (); 
}

// ------------------------------------------------------ //
// Configure the modem to transmit Commands and Responses //
// ------------------------------------------------------ //

void setup_hdlc_tx (void)
{
#ifdef V34_FAX
	if ( G(x_fax_v34mode) != NON_V34 )        // Using V.34 modulation?
	{
		G(x_fax_v34channel) = PRIMARY_CHANNEL;  // Switch FROM primary to control channel
		x_send_mail (FAXV34_SEND1S, DP_TASK, NULL, 0);  // Configure datapump
	}

	else    // Using V.17, V.33, V.29 or V.27
#endif
	{
		G(x_fax_state) = FAX_TX_HDLC;
		G(x_fax_rate) = MR_300;
		x_send_mail (FAX_STARTUP_TRANSMIT, DP_TASK, NULL, 0);
	}

	G(c2s.flag) = G(c2s.flag) & ~CARRIER_DET;    // Clear carrier-detected flag
	next_state ();
}

// ---------------------------------------- //
// Setup modem to receive synchronous data  //
// ---------------------------------------- //

void setup_sync_rx (void)
{
#ifdef V34_FAX
	if ( G(x_fax_v34mode) != NON_V34 )        // Using V.34 modulation?
	{
		if (!dp_read_dsp_ram (0x1FFF))          // Did not detect 1s?
			return;                               // Wait for 1s

		G(x_fax_v34channel) = CONTROL_CHANNEL;  // Switch FROM control channel to primary channel
		x_send_mail (FAXV34_DETECT1S, DP_TASK, NULL, 0);  // Configure datapump for primary channel
		dp_write_dsp_ram (0x1FFF, 0);		     // Clear detect 1s flag
	}

	else    // Using V.17, V.33, V.29 or V.27
#endif
//	Note:  A timing problem occurs if synchronous receive is started after an FTT
//         is sent and the TCF is 4,800 or 2,400 bps.  Apparently, V.21 interfers with
//         startup for these modulations and the TCF is received with many errors.
//         So, waiting for V.21 to go away prevents this from happening.
//
	if (dp_regread (DP_EIA_REGISTER) & 0x04)         // Signal present?
		return;

	else
	{
		G(x_fax_rate) = rate [G(c2p.fdcs.ps.br)];
		G(x_fax_state) = FAX_RX;
		x_send_mail (FAX_STARTUP_RECEIVE, DP_TASK, NULL, 0);
	}

	G(c2s.flag) = G(c2s.flag) & ~CARRIER_DET;   // Clear CARRIER DETECT flag
	G(c2_sequence_ptr)++;
}

// ----------------------------------------- //
// Setup modem to transmit synchronous data  //
// ----------------------------------------- //

void setup_sync_tx (void)
{
#ifdef V34_FAX
	if ( G(x_fax_v34mode) != NON_V34 )        // Using V.34 modulation?
	{
		G(x_fax_v34channel) = CONTROL_CHANNEL;  // Switch FROM control channel to primary channel
		x_send_mail (FAXV34_SEND1S, DP_TASK, NULL, 0);  // Configure datapump
	}

	else    // Using V.17, V.33, V.29 or V.27
#endif
	{
		G(x_fax_rate) = rate [G(c2p.fdcs.ps.br)];
		G(x_fax_state) = FAX_TX;
		x_send_mail (FAX_STARTUP_TRANSMIT, DP_TASK, NULL, 0);
	}

	G(c2s.flag) = G(c2s.flag) & ~CARRIER_DET;   // Clear CARRIER DETECT flag
}

// ------------------------------- //
// Reverse the bit order of a byte //
// ------------------------------- //

byte rev_bits (byte in)
{
	byte out = 0;
	word i;

	for (i=1; i<0x0100; i=i<<1)			// i is a bit mask which is shifted left
		out = (out << 1) + !(in & i);	// shift in complement of masked bit

	return ~out;						// return normal byte
}

/* --------------------------------- */
/* Wait for the DCE Tx FIFO to empty */
/* --------------------------------- */

void wait_4_fifo_empty (void)
{
	if (G(x_fax_state) == FAX_TX)	                  // Sync Tx mode?
	{
		if (!(G(c2s.flag) & TX_EMPTY))               // Does RAM buffer contain data?
		{
			if (io_dce_tx_fifo_empty ())		  // Is buffer empty yet?
			{
				G(c2s.flag) = G(c2s.flag) | TX_EMPTY;	  // Indicate empty
				G(c2s.timer) = x_current_time ();	  // Reset timer
			}
		}

		else
		{
			if (x_elapsed_time (G(c2s.timer)) > 175) // 175 ms delay after RAM buffer empty?
			{
				G(c2s.flag) = G(c2s.flag) & ~TX_EMPTY;  // Reset flag
				x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0);	 // Turn off carrier
				next_state ();					  // Go to next state
			}
		}
	}

	else if (io_dce_tx_fifo_empty ())
	{
	#ifdef V34_FAX
		if (G(x_fax_v34mode) == NON_V34)  // Not using V.34 modulation?
	#endif
			x_send_mail (FAX_DROP_CARRIER, DP_TASK, NULL, 0);

		next_state ();
	}
}

// ----------------------------------------------------------- //
// Delay time required by T.30 -- Silence time between TX & RX //
// ----------------------------------------------------------- //

void t30_delay (void)
{
	if (x_elapsed_time (G(c2s.timer)) >= G(c2s.t30))
		next_state ();
}

// ----------------------- //
// Setup pump for training //
// ----------------------- //

void set_train (V17_FAX_MODE duration)
{
	if ((G(c2rf.flag) & 0x01) && (G(c2p.fdcs.ps.br) >= 2))  // V.17 modulation selected?
		G(x_fax_v17) = duration;          // Use requested duration

	else if (G(c2p.fdcs.ps.br) >= 4)	  // V.33 modulation?
		G(x_fax_v17) = V17_LONG_TRAIN;	  // Always use long train

	else
		G(x_fax_v17) = NON_V17;   	      // Indicate non-V.17 modulation

	check_rate_change ();             // Check if change from V.17 to Non-V.17
}

// --------------------- //
// Timer T2 delay (T.30) //
// --------------------- //

void t2_delay (void)
{
	if (!(G(c2s.flag) & SPT111))				    // PPM before page data received?
	{
		G(c2p.fet) = 0;							// Causes OK to be sent to DTE after DCS
		G(c2_sequence_ptr) = ANS0;					// Enable HDLC Tx, send DIS again
		G(c2s.timer) = x_current_time ();
	}

	else
	{
		G(c2_var1) = x_current_time ();    // Reset T1 timer
		G(c2s.t3sec) = x_current_time ();  // Reset 3 second timer (T4)
	} 

	if ( (dp_regread (DP_EIA_REGISTER) & 0x04)    // Carrier detected?
#ifdef V34_FAX
				&& (G(x_fax_v34mode) == NON_V34)           // Not using V.34 modulation?
#endif
		 )
		G(c2_sequence_ptr) = ANS2;					// Receive the message

	if (x_elapsed_time (G(c2s.timer)) > 6000)      // 6 seconds expired?
	{
		G(c2_sequence_ptr) = ANS0;				// Setup to Tx CSI/DIS
		G(c2s.timer) = x_current_time ();		    // Reset timer
		G(c2s.flag) = G(c2s.flag) & ~DCS_RECEIVE;  // Indicate DCS has not been received yet
	}
#ifdef V34_FAX
	if ( (G(x_fax_v34mode) != NON_V34) &&    // Using V.34 modulation?
			 (G(c2_sequence_ptr) == ANS0) )	        // Leaving this state?
		G(c2_sequence_ptr)++;                     // Skip non-V.34 state
#endif
}

// ----------------------------------------------------- //
// Send Optional T.30 Commands with Required DIS/DTC/DCS //
// ----------------------------------------------------- //
/*
	DIS: NSF (Class 2/2.0)
	DCS: PWD, SUB (Class 2.0)
	DTC: NSC (Class 2/2.0), PWD, SEP (Class 2.0)
*/

void send_opt_cmds (void)
{
	if (G(c2_sequence) == ans_sequence)     // Sending DTC or DIS?
	{
		if (G(c2rf.flag) & ORG_POLL)        // Sending DTC?
		{                              // Send NSC, PWD, and/or SEP if +FNSS (+FNS), +FPW and/or FPA not NULL
			if (G(c2p.fnss_idx))           // Is +FNSS (+FNS) string programmed?
				send_fnss (RSP_NSC);     // Send T.30 NSC command

	#if defined(IWF_FAX) || defined(CLASS20_FAX)  
			if (G(c2p.fclass) == 0x20)          // Class 2.0 FAX service selected?
			{
				send_add_poll (RSP_PPWD);// Send password, if programmed/enabled
				send_add_poll (RSP_SEP); // Send selective polling address, if programmed/enabled
			}
 #endif
		}

		else                           // Sending DIS, send NSF if +FNSS (+FNS) not NULL
		{
			if (G(c2p.fnss_idx))           // Is +FNSS (+FSN) string programmed?
				send_fnss (RSP_NSF);     // Send T.30 NSF
		}
	}

	#if defined(IWF_FAX) || defined(CLASS20_FAX)  
	else                              // Sending DCS, send PWD and/or SUB if +FPW and/or +FSA not NULL
	{
		if (G(c2p.fclass) == 0x20)                // Class 2.0 FAX service selected?
		{
			if (G(c2rf.flag) & REMOTE_PWD)      // Remote supports passwords?
				send_add_poll (RSP_TPWD);   // Send password, if programmed/enabled

			if (G(c2rf.flag) & REMOTE_SUB_SEP)  // Remote supports sub-addressing?
				send_add_poll (RSP_SUB);    // Send Sub-Address, if programmed/enabled
		}
	}
 #endif
}

// ----------------------------- //
// Send T.30 NSF/NSC/NSS Command //
// ----------------------------- //

void send_fnss (byte cmd)
{
#if defined(IWF_FAX) || defined(CLASS20_FAX)  
	byte i;

	G(c2_dce_buf_ptr[0]) = 0xFF;		               // Address

	if (cmd == RSP_NSS)                       // Command is NSS?
	{
		cmd = cmd + DYNAMIC_BIT;               // NSS used dynamic bit
		G(c2_dce_buf_ptr[1]) = 0x13;                 // Final frame
	}

	else
		G(c2_dce_buf_ptr[1]) = 0x03;                 // Not final frame

	G(c2_dce_buf_ptr[2]) = (word)cmd;               // NSF/NSC/NSS command

	for (i=0; i < G(c2p.fnss_idx); i++)
		G(c2_dce_buf_ptr[i+3]) = (word) G(c2p.fnss[i]); // Send in order entered

	G(io_hdlc_byte_count) = G(c2p.fnss_idx) + 3;	   // Number of bytes in message
	io_fax_hdlc_buf_to_dce( G(io_fax_buf), &G(io_hdlc_byte_count));
#else
	cmd++;                                    // Prevents compile warning
#endif
}

#if defined(IWF_FAX) || defined(CLASS20_FAX)  
// -------------------------------------- //
// Send T.30 Address and Polling Commands //
// -------------------------------------- //

void send_add_poll (byte cmd)
{
	byte *ptr = 0;            // NULL pointer

	switch (cmd)
	{
		case RSP_TPWD:
			cmd = cmd + DYNAMIC_BIT;  // Use dynamic bit for xmit password
		case RSP_PPWD:
			if (G(c2p.fap) & FAP_PWD)  // Passwords enabled?
				ptr = G(c2p.fpw);   // Point to password string

			break;

		case RSP_SUB:
			if (G(c2p.fap) & FAP_SUB)  // Sub-addressing enabled?
			{
				cmd = cmd + DYNAMIC_BIT;  // Use dynamic bit for sub-addressing
				ptr = G(c2p.fsa);   // Point to sub-address string
			}

			break;

		case RSP_SEP:
			if (G(c2p.fap) & FAP_SEP)  // Selective polling enabled?
				ptr = G(c2p.fpa);    // Point to selective polling string

			break;
	}

	if (ptr)                            // Is the requested command enabled?
	{
		byte i = 0;

		do
		{
			if (ptr[i] != ' ')            // Non-space character?
				break;                     // Stop check for NULL string
		} while (++i < 20);

		if (i != 20)                     // String programmed?
		{
			byte k = 19;                  // Offset to last character
			byte j = 3;                   // Offset into c2_dce_buf_ptr

			G(c2_dce_buf_ptr[0]) = 0xFF;		   // Address
			G(c2_dce_buf_ptr[1]) = 0x03;        // Not final frame
			G(c2_dce_buf_ptr[2]) = (word)cmd;   // PWD/SUB/SEP command

			// Send LSB of least significant byte (ptr[19]) first
			// and right justify string.  Append spaces at the end.
			// (refer to T.30, section 5.3.6.2.8 - .10)
			// The string is stored right justifed with spaces appended.

			do
			{
				G(c2_dce_buf_ptr[j++]) = (word) ptr[k]; // Copy string to DCE buffer
			} while (k--);                       // Load all 20 characters

			G(io_hdlc_byte_count) = 23;	          // 23 bytes in message
			io_fax_hdlc_buf_to_dce( G(io_fax_buf), &G(io_hdlc_byte_count));
		}
	}
}
#endif

// --------------------------------------- //
// Send Optional T.30 Responses to the DTE //
// --------------------------------------- //

void display_opt_rsp (byte cmd)
{
	byte i = 1;         // Set variable to TRUE for non-standard responses
	byte rsp;
	byte nsf = 0;       

	switch (cmd)
	{
#if defined(IWF_FAX) || defined(CLASS20_FAX)  
		case RSP_TPWD:   // Password for transmission
		case RSP_TPWD+1:
		case RSP_PPWD:   // Password for polling
			i = G(c2p.fap) & FAP_PWD;                // Store enable/disable in i
			rsp = FPW;
			break;

		case RSP_SEP:    // Selective polling address
			i = G(c2p.fap) & FAP_SEP;                // Store enable/disable in i
			rsp = FPA;
			break;

		case RSP_SUB:    // Sub-address
		case RSP_SUB+1:
			i = G(c2p.fap) & FAP_SUB;                // Store enable/disable in i
			rsp = FSA;
			break;
#endif
		case RSP_NSS:  // Non-standard setup frame
		case RSP_NSS+1:
			rsp = FNSS;
			nsf++;                              
			break;

		case RSP_NSF:  // Non-standard facilities frame
			rsp = FNSF;
			nsf++;                               
			break;

		case RSP_NSC:  // Non-standard command frame
			rsp = FNSC;
			nsf++;                              
			break;

		default:
			return;
	}

	if (i)                                              // Response enabled?
	{
		if (nsf)                                          // Non-standard response?
			load_rsp_nsf (rsp, (word*)&G(c2_dce_buf_ptr[3]));

	#if defined(IWF_FAX) || defined(CLASS20_FAX)
		else                                              // PWD, SEP or SUB
			load_rsp_str (rsp, (word*)&G(c2_dce_buf_ptr[3]));
	#endif
	}
}

/* ------------------------------------- */
/* Initialization for Class II Operation */
/* ------------------------------------- */

void io_fax_c2_init (void)
{
	G(c2_sequence_ptr) = 0;         // Initialize sequence pointer to first state
	G(c2_sequence) = ans_sequence;  // Point to answer sequence
	G(c2s.flag) = 0;			       // Clear all flags
	G(c2rf.flag) = 0;              // Clear all flags
	G(c2_dte_msg_buf) = C2_DTE_BUF_START;  // Initialize pointer for DTE messages
	initialize_c2p ();           // Initialize c2p structure with default values
}

/* -------------------------------------- */
/* Check if a state experienced a timeout */
/* -------------------------------------- */

void chk_fax_c2_timer (void)
{
	static const byte org_to [] =  // 0 - 38 Originate States...
	{
		0x98,   //  7:Y  6:N  5:N  4:Y    3:Y  2:N  1:N  0:N
		0x20,   // 15:N 14:N 13:Y 12:N   11:N 10:N  9:N  8:N
		0x8E,   // 23:Y 22:N 21:N 20:N   19:Y 18:Y 17:Y 16:N
		0x14,   // 31:N 30:N 29:N 28:Y   27:N 26:Y 25:N 24:N
		0x01,   // 39:  38:N 37:N 36:N   35:N 34:N 33:N 32:Y
	};

	static const byte ans_to [] =  // 0 - 33 Answer States...
	{
		0x08,   //  7:N  6:N  5:N  4:N    3:Y  2:N  1:N  0:N
		0x23,   // 15:N 14:N 13:Y 12:N   11:N 10:N  9:Y  8:Y
		0x62,   // 23:N 22:Y 21:Y 20:N   19:N 18:N 17:Y 16:N
		0x02,   // 31:N 30:N 29:N 28:N   27:N 26:N 25:Y 24:N
		0x00    // 39:  38:  37:  36:    35:  34:  33:N 32:N
	};

	byte idx, mask;
	const byte *ptr;

	idx = G(c2_sequence_ptr) / 8;
	mask = 0x01 << (G(c2_sequence_ptr) % 8);

	if (G(c2_sequence) == org_sequence)  // Originate mode?
		ptr = org_to;

	else
		ptr = ans_to;

	if (ptr[idx] & mask)  // Check for a time-out?
	{
		if (x_elapsed_time (G(c2s.timer)) > 10000)  // Time-out?
		{
			if ( (G(c2_sequence) == org_sequence) && (G(c2_sequence_ptr) == 17) )  // Waiting for +FET=n from DTE?
				process_phcto ();

			else
			{
				G(c2p.faxerr) = 140;                         // Mfr Code: Internal time-out
				G(c2_sequence) = ans_sequence;  // Switch to answer sequence
				G(c2_sequence_ptr) = ANSX;                   // Send +FHNG:n and hangup
			}
		}
	}
}

/* ---------------------------------------------------------- */
/* Check if the DTE requests an abort of the previous command */
/* ---------------------------------------------------------- */

void chk_dte_abort (void)
{
	static const byte org_ab [] =  // 0 - 38 Originate States...
	{
		0x82,   //  7:Y  6:N  5:N  4:N    3:N  2:N  1:Y  0:N
		0xA8,   // 15:Y 14:N 13:Y 12:N   11:Y 10:N  9:N  8:N
		0x8C,   // 23:Y 22:N 21:N 20:N   19:Y 18:Y 17:N 16:N
		0x06,   // 31:N 30:N 29:N 28:N   27:N 26:Y 25:Y 24:N
		0x01,   // 39:  38:N 37:N 36:N   35:N 34:N 33:N 32:Y
	};

	static const byte ans_ab [] =  // 0 - 33 Answer States...
	{
		0x28,   //  7:N  6:N  5:Y  4:N    3:Y  2:N  1:N  0:N
		0x00,   // 15:N 14:N 13:N 12:N   11:N 10:N  9:N  8:N
		0x0A,   // 23:N 22:N 21:N 20:N   19:Y 18:N 17:Y 16:N
		0x12,   // 31:N 30:N 29:N 28:Y   27:N 26:N 25:Y 24:N
		0x00    // 39:  38:  37:  36:    35:  34:  33:N 32:N
	};

	byte idx, mask;
	const byte *ptr;

	idx = G(c2_sequence_ptr) / 8;
	mask = 0x01 << (G(c2_sequence_ptr) % 8);

	if (G(c2_sequence) == org_sequence)  // Originate mode?
		ptr = org_ab;

	else
		ptr = ans_ab;

	if (ptr[idx] & mask)  // Check for abort?
	{
		if (io_get_dte_rx_bytes () )		  // ANY character received from the DTE?
		{
			G(c2p.faxerr) = 2;					                // Call aborted
			G(c2_sequence) = org_sequence;	// Select originate sequence, if not already selected
			G(c2_sequence_ptr) = ORG6;			            // Send +FHNG:n to the DTE
		}
	}
}

#ifdef FAX_ECM
// ---------------------------------------------------------- //
// Get the Current State of the Dynamic Bit for T.30 Commands //
// ---------------------------------------------------------- //

byte get_t30_bit (void)
{
	return (DYNAMIC_BIT);
}
#endif

// ------------------------------------------ //
// Secondary, Background AT-Command Processor //
// ------------------------------------------ //
/* NOTE: Both this function, "io_fax_c2_background()", and "at_task()" are called by
	"io_periodic_task()".  However, the way the code is structured, only one can be
	active at a time based on the value of variable "G(io_state)".  So, whenever this
	task is active, AT-Commands can't be processed.  Therefore, whenever this function
	is waiting for an AT-Command, the function below will be called to process AT-commands.
	It should be cleaner and allow time-out timers to be used to avoid lockups.
	As much of the existing code as possible will be used.
*/

void cl2_at_bg (void)
{
#ifndef CS_MODEM
	word i;

	if (G(c2s.flag) & AT_ENABLE)
	{
		i = io_get_dte_rx_bytes ();   // Read number of bytes in DTE Rx buffer

		while (i--)
			atparse_state (read_dte_fifo ());  // Pass byte to state machine
	}
#endif
}
#endif    // CLASS2_FAX || CLASS20_FAX

