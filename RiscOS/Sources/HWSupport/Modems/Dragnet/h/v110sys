/*name and version number:@(#)v110sys.h	1.2*/
/*date of get: 		  09/06/00 16:59:37*/
/*date of delta:	  10/21/99 18:53:19*/
/****************************************************************/
/*
(C) Copyright 1989-1998 Link Technology, Inc.  All Rights Reserved Worldwide.

THIS SOFTWARE CONTAINS TRADE SECRETS OF LINK TECHNOLOGY INC.  NO DISCLOSURE,
COPYING OR USE OF WHOLE OR ANY PART THEREOF MAY BE MADE WITHOUT WRITTEN
PERMISSION.

Licensed Material - Program Property of Link Technology, Inc.

THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Link Technology, Inc.
The copyright notice above does not evidence any actual or intended
publication of such source code.
*/
/*
	$Header$

	History:
	$Log$
   
      Rev 1.4   28 Aug 1996 12:10:42   si
   Multiport changes; changes for Miniport version and support for
   other C compilers such as Borland; simplified some definitions
   
      Rev 1.3   06 Feb 1996 15:21:20   si
   Changed copyright date.
   
      Rev 1.2   06 Jun 1994 10:37:50   si
   Added ASI driver states ASI_STATE_CLOSED and ASI_STATE_OPENED.
   
   Added pragmas for compile configuration types.
   
   Added T312 timer id.
   
   Deleted T3_RST timer definitions (no longer used).
   
   Added T4 timer.
   
   Added T3xx timer id.
   
   Added NET3 T3 timer definitions.
   
      Rev 1.1   21 Aug 1990 17:13:44   jar
   Iniital controlled version
*/
/*************************************************************************
**									**
** name		: v110sys.h						**
** purpose	: System definitions					**
**									**
*************************************************************************/

#ifndef __V110_SYS_H__
#define __V110_SYS_H__

#if defined ( BC )
#pragma message("Borland C++")
void ltprintf( const char *format, ... );
#endif

#ifdef MSC60
#define _FP_SEG(fp) (*((unsigned __far *)&(fp)+1))
#define _FP_OFF(fp) (*((unsigned __far *)&(fp)))

#pragma message("Microsoft C++")
#endif

#ifndef MAX_ADAPTERS
#define MAX_ADAPTERS	1
#endif
#ifndef NUM_LINKS
#define NUM_LINKS	1
#endif
#ifndef M68K
#if MAX_ADAPTERS == 1
#pragma message( "1 Adapter" )
#elif MAX_ADAPTERS == 2
#pragma message( "2 Adapter" )
#elif MAX_ADAPTERS == 3
#pragma message( "3 Adapter" )
#else
#pragma message( ">3 Adapter" )
#endif
#endif

#if defined ( PORTABLE )
#pragma message("Portable")
void ltprintf( const char *format, ... );
#endif

#if defined (WIN40 )
#include <vtoolsc.h>
#if !defined( WANTLSPY )
#define ltprintf	dprintf
#else
void ltprintf( const char *format, ... );
#endif
#endif

#if defined ( NDIS_MINIPORT_DRIVER )
#pragma message("Miniport")

#include "isdntest.h"

#pragma pack(1)                 // x86, MS compiler; MIPS, MIPS compiler
#pragma message( "Pack 1 Byte" )

#ifndef VOID
#define VOID void
#endif
void ltprintf( const char *format, ... );

#endif /*#if defined ( NDIS_MINIPORT_DRIVER )*/

#if defined( PLUS )
#pragma message("IAB-4 PLUS")
#endif

#ifdef _WINDLL
#include <windows.h>
#pragma message("Windows DLL")
#endif

#define BYTE unsigned char
#ifdef M68K
#define WORD unsigned int
#define MMAP	1	/* always memory mapped I/O with 68K */
#define ltprintf	printf
#define strlen		__strlen
#define strcpy		__strcpy
#define memset		__memset
#define memcpy		__memcpy
#else

#if defined (WIN40 ) || defined( NDIS_MINIPORT_DRIVER ) || defined( USE_32 )
#pragma message( "WORD unsigned short" )
#define WORD unsigned short
#else
#define WORD unsigned int
#endif /* #if defined (WIN40 ) ... */

#endif /* #ifdef M68K */

#define LWORD unsigned long
#define TRUE	1
#define FALSE	0

#if defined (_WINDLL)
#include <stdio.h> 
#include <string.h> 
#include <stdarg.h> 
extern void ltprintf( LPCSTR, ... );

#define LOCAL static
#ifndef BOOLEAN
#define BOOLEAN	BYTE
#endif

extern DWORD setint( WORD, void (interrupt far *)() );
extern void INTei( BYTE adapter );
extern void INTdi( BYTE adapter );
extern WORD ints_off( void );
extern BOOLEAN C_timer_isr( void );

#elif defined( _DOS)
#pragma message( "DOS" )
#include <stddef.h>
#include <stdio.h> 
#include <string.h> 
#include <stdarg.h> 
#include <io.h>
#include <dos.h>
#include <bios.h>

/* min and max macros */
#if !defined( max )
#pragma message( "defining max" )
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#endif
#if !defined( min )
#pragma message( "defining min" )
#define min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

void ltprintf( const char *format, ... );

#define LOCAL
#ifndef BOOLEAN
#define BOOLEAN	BYTE
#endif

extern BOOLEAN C_timer_isr( void );

#else

//jc interfere with csmain's LOCAL; #define LOCAL

#endif /*#ifdef _WINDLL*/

#ifndef I8051
#ifndef BOOLEAN
#define BOOLEAN	BYTE
#endif

#ifndef FAR
#define FAR
/* #define FAR	far */
#endif

/* variable function parameter stuff */
#if !defined( _DOS)
#ifndef va_start
typedef char *va_list;
#define va_start(ap,v) ap = (va_list)&v + sizeof(v)
#define va_arg(ap,t) ((t *)(ap += sizeof(t)))[-1]
#define va_end(ap) ap = NULL
#endif
#endif /*#if !defined( _DOS)*/

#else

#define FAR
#ifndef I8051_STDIO_H
#define I8051_STDIO_H
#include <stdio.h>
#endif

#ifndef I8051_IO51_H
#define I8051_IO51_H
#include <io51.h>
#endif

#endif /*#ifndef I8051*/

#ifndef NULL
#define NULL	((void *)0)
#endif

#ifndef MSB_LSB
#ifdef M68K
#define MSB_LSB(wd)	( wd )
#else
#define MSB_LSB(wd)	( ( (WORD)(wd) >> 8 ) + ( (WORD)(wd) << 8 ) )
#endif
#endif

#define EVEN_COUNT_CHECK(val)	(( ( (val)/2 ) * 2 ) == (val))
#define MAKE_EVEN_COUNT(val)	( ( (val)/2 ) * 2 )

#if (defined( WIN40 ) || defined( NDIS_MINIPORT_DRIVER )) && !defined( max )
/* max macro */
#pragma message( "defining max" )
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#endif

#if (defined( WIN40 ) || defined( NDIS_MINIPORT_DRIVER )) && !defined( min )
/* min macro */
#pragma message( "defining min" )
#define min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

/*buffer header*/
struct bfr_hdr_s {
	struct bfr_hdr_s *pnext;	/*next buffer in queue*/
	struct bfr_hdr_s *pprev;	/*previous buffer in queue*/
	struct bfr_hdr_s *pnext_X25;	/*next buffer in X.25 I queue*/
	struct bfr_hdr_s *pprev_X25;	/*previous buffer in X.25 I queue*/
	struct bfr_hdr_s *pnext_L1;	/*next buffer in L1 queue*/
	struct bfr_hdr_s *pprev_L1;	/*previous buffer in L1 queue*/
	BYTE *pdata_area;		/*address of data*/
	WORD data_sz;			/*size of data*/
	BYTE *px25_data_area;		/*X.25 data area pointer*/
	WORD x25_data_sz;		/*size of X.25 data*/
	WORD offset;			/*offset of next byte to xmt/rcv*/
	BYTE pri;			/*transmission priority*/
	BYTE pid;			/*process id of buffer owner*/
	BYTE L1_do_not_free:1,		/*L1 do not free buffer flag - used
					  by L1 to ensure that bfr is not
					  freed that is in a transmit queue*/
		L2_do_not_free:1,	/*L2 do not free buffer flag - used
					  by L2 to ensure that bfr is not
					  freed that in an I frame queue*/
		X25_do_not_free:1;	/*X25 do not free buffer flag - used
					  by X25 to ensure that bfr is not
					  freed that in an I frame queue*/
	BYTE fill0;			/*fill to even align next fields*/
	LWORD misc1;			/*miscellaneous long word*/
	LWORD misc2;			/*miscellaneous long word*/
};

#define BFR_SIZE_CHANGE( pb, sz )	\
	pb->pdata_area -= sz;		\
	pb->data_sz += sz;

#define MAX_CEPT_CHANNELS	30	/* maximum # CEPT bearer channels */
#define MAX_DS1_CHANNELS	24	/* maximum # DS1 bearer channels */
#define MAX_PRI_CHANNELS	MAX_DS1_CHANNELS
#define MAX_BRI_CHANNELS	2

#define N200_DEFAULT	3		/*N200 maximum # frame rexmts count
					  default*/
/* NOTE: for some 68K processors, N201 *must* be a even number so the
	buffer allocations for word values are on an even boundary! */
#define N201_DEFAULT	260		/*N201 maximum frame octet count
					  default*/
#define N202_DEFAULT	3		/*N202 maximum # rexmts of TEI ID
					  requests default*/
#define N203_DEFAULT	3		/*N202 maximum # rexmts of TEI ID
					  check default*/
#define K_DEFAULT	1		/*maximum # outstanding I frames
					  default*/
#define PRI_K_DEFAULT	7		/* PRI maximum # outstanding I frames
					  default */
#define X25_LAPD_K_DEFAULT	3	/*maximum # outstanding X.25 I frames*/
#define X25_PKT_K_DEFAULT	2	/*maximum # outstanding X.25 pkts*/
#define MAX_X25_PVCS		2	/*maximum # PVCs*/
#define MAX_SVCS		2	/*maximum # SVCs*/
#define MAX_X25_LCNS	((MAX_X25_PVCS)+(MAX_SVCS))	/*maximum number of X.25 LCNs*/

#define DASS_VIRTUAL_DLC_START	32	 /* DASS virtual DLC start */
#define DASS_L2_LINKS	62		 /* DASS Layer 2 links per line */
#define MAX_DASS_L2_LINKS	((MAX_ADAPTERS)*(DASS_L2_LINKS)) /*maximum DASS Layer 2 links */

#ifdef PRI
/*#pragma message( "PRI Version" )*/
#define MAX_CALLS	((MAX_PRI_CHANNELS)*(MAX_ADAPTERS)) /*max # Calls*/
#define MAX_L2_LINKS	((MAX_ADAPTERS)*((NUM_LINKS)+2)) /*maximum Layer 2 links -
					1 per link for broadcast link +
					1 per link for signaling */

#else
/*#pragma message( "BRI Version" )*/
#define MAX_CALLS	((MAX_BRI_CHANNELS)*(MAX_ADAPTERS)) /*max # Calls*/
#define MAX_L2_LINKS	((MAX_ADAPTERS)*(((NUM_LINKS)*2)+2)) /*maximum Layer 2 links -
					1 per link for broadcast link +
					1 per link for signaling +
					2 for SAPI 0 and SAPI 16 D channel*/

#endif

/* add 10 extra bytes to account for an I frame control field of 4 bytes +
extra bytes possibly sent during conformance testing */
#define BFR_DATA_SIZE	((N201_DEFAULT)+10) /*maximum buffer data size*/
					/*size of each system
					 buffer including the bfr header*/
#define BFR_SIZE	((BFR_DATA_SIZE)+sizeof(struct bfr_hdr_s))
#define NUM_L1_D_BFRS	6		/*number of D Channel buffers*/
#define NUM_L1_B1_BFRS	6		/*number of B1 Channel buffers*/

#ifdef PRI
#define NUM_L1_B2_BFRS	0		/*number of B2 Channel buffers*/
#define NUM_X25_BFRS	0

#else
#define NUM_L1_B2_BFRS	6		/*number of B2 Channel buffers*/
#define NUM_X25_BFRS	((X25_PKT_K_DEFAULT)*(MAX_X25_LCNS))

#endif

#define NUM_L2_BFRS	((MAX_L2_LINKS)*PRI_K_DEFAULT)
/* #define NUM_L2_BFRS	(((MAX_L2_LINKS)-(NUM_LINKS))*8) */
					/*number of L2 buffers - enough for
					a full max window of 7 for each L2
					link, plus one extra to use for RNR;
					exclude broadcast links*/
					/*now define total # systems bfrs*/
#define NUM_L3_BFRS	(MAX_CALLS)	/*number of L3 buffers*/

#ifdef PRI
#define NUM_BFRS	((MAX_ADAPTERS)*64)	/*enlarge if buffers run low*/
#else
#define NUM_BFRS	((MAX_ADAPTERS)*64)
#endif

/* #define NUM_BFRS	((NUM_L1_D_BFRS)+(NUM_L1_B1_BFRS)+(NUM_L1_B2_BFRS)+(NUM_L2_BFRS)+(NUM_L3_BFRS)+(NUM_X25_BFRS)) */

#define BFRS_LOW_THRESHHOLD	((MAX_L2_LINKS)+(NUM_L1_D_BFRS))
#define BFRS_HI_THRESHHOLD	((BFRS_LOW_THRESHHOLD)+(NUM_L1_D_BFRS))

#define BROADCAST_TEI		127	/* Broadcast TEI */

#ifdef PRI
#define MAX_NUM_Q931_TTYS	1 /*per adapter*/
#else
#define MAX_NUM_Q931_TTYS	2 /*per adapter*/
#endif

/*maximum number of logical terminals - 
	first terminal is for broadcast terminal i.e. TEI 127;
	+1 is for spare */
#define MAX_NUM_TTYS	(((MAX_NUM_Q931_TTYS+1)*MAX_ADAPTERS)+1)

#define BRI_Q931_TTY	1	/* Basic Rate Q.931 TTY number */
/* Leave one spot for a second BRI TTY in case of NTI or similar rqmts */
#define MAX_BRI_Q931_TTY 2	/* Range for BRI TTYs */
#define PRI_Q931_TTY	1	/* Primary Rate Q.931 TTY number */
#define MAX_PRI_Q931_TTY 1	/* Range for PRI TTYs */
#define X25_TTY		2	/* Basic Rate X.25 TTY number */

#define FIRST_DYNAMIC_TEI	64

/*timer defines*/
#if defined( _DOS )
#define TICKS_PER_SEC	18	/*# ticks per second, 18.5 per sec*/
#define GET_REAL_TICKS(x)	((x)/2 + (x)*18)

#elif defined( I8051 )
#define PERIOD_HI		0xB4	/*50ms interrupt period @11.0592 Mhz*/
#define PERIOD_LOW		0x00
#define TICKS_PER_SEC	20	/*# ticks per second, 50ms tick*/
#define GET_REAL_TICKS(x)	((x)*(TICKS_PER_SEC))

#else
#define TICKS_PER_SEC		20	/*# ticks per second, 50ms per tick */
#define MILLSECS_PER_TICK	50
#define GET_REAL_TICKS(x)	((x)*(TICKS_PER_SEC))

#endif /*#if defined( _DOS )*/

#define NT1_DEFAULT	GET_REAL_TICKS(1)	/*NT1 timer default*/
#define NT2_DEFAULT	((TICKS_PER_SEC)/2)	/*NT2 timer default*/
#define NL_DEFAULT	10			/*NL count default*/
#define T200_DEFAULT	GET_REAL_TICKS(1)	/*T200 frame rexmt timer second
						count default*/
#define T201_DEFAULT	(T200_DEFAULT)		/*T201 TEI identity check
						timer second count default;
						NT SIDE*/
#define T202_DEFAULT	GET_REAL_TICKS(2)	/*T202 time between TEI ID
						request rexmts second count
						default*/
#ifdef PRI
#define T203_DEFAULT	GET_REAL_TICKS(10)	/*T203 max idle time between
						frame xmts second count
						default*/
#else
#define T203_DEFAULT	GET_REAL_TICKS(30)	/*T203 max idle time between
						frame xmts second count
						default*/
#endif
#define T205_DEFAULT	(T203_DEFAULT)		/*T205 max idle time between
						TEI id check second count
						default; NT SIDE*/
#define T20_DEFAULT	GET_REAL_TICKS(180)	/*T20 restart request*/
#define T21_DEFAULT	GET_REAL_TICKS(200)	/*T21 call request*/
#define T22_DEFAULT	GET_REAL_TICKS(180)	/*T22 reset request*/
#define T23_DEFAULT	GET_REAL_TICKS(180)	/*T23 clear request*/
#define T28_DEFAULT	GET_REAL_TICKS(300)	/*T28 registration request*/
#define L1_T3_DEFAULT	GET_REAL_TICKS(6)	/*T3 activation*/
#define L1_T4_DEFAULT	GET_REAL_TICKS(1)	/*T4 spurious hit*/
#define L1_POLL_DEFAULT	((TICKS_PER_SEC)/2)	/*L1 poll*/
#define L1_T1_DEFAULT	((TICKS_PER_SEC)/10)	/*T1 timer default*/
#define L1_T2_DEFAULT	((TICKS_PER_SEC)/10)	/*T2 timer default*/
#define V110_T1_DEFAULT	GET_REAL_TICKS(10)	/*V.110 T1 timer default*/
#define V110_RESYNC_DEFAULT GET_REAL_TICKS(3)	/*V.110 Resync timer default*/

/*timer ids*/
#define L2_TIMER_ID_START	1	/*start of Layer 2 timer ids*/
#define L2_T200_TIMER		1	/*T200 id*/
#define L2_T201_TIMER		2	/*T201 id*/
#define L2_T202_TIMER		3	/*T202 id*/
#define L2_T203_TIMER		4	/*T203 id*/
#define L2_T205_TIMER		5	/*T205 id - new timer; time between
					  TEI ID check requests*/
#define X25_T20_TIMER		6	/*X.25 T20 timer*/
#define X25_T21_TIMER		7	/*X.25 T21 timer*/
#define X25_T22_TIMER		8	/*X.25 T22 timer*/
#define X25_T23_TIMER		9	/*X.25 T23 timer*/
#define X25_T28_TIMER		10	/*X.25 T28 timer*/
#define L4_TIMER		10	/*L4 general timer - same as prior*/
#define T301_TIMER		11	/* Q.931 T301 timer */
#define T303_TIMER		12	/* Q.931 T303 timer */
#define T304_TIMER		13	/* Q.931 T304 timer */
#define T305_TIMER		14	/* Q.931 T305 timer */
#define T308_TIMER		15	/* Q.931 T308 timer */
#define T309_TIMER		16	/* Q.931 T309 timer */
#define T310_TIMER		17	/* Q.931 T310 timer */
#define T312_TIMER		18	/* Q.931 T312 timer */
#define T313_TIMER      	19	/* Q.931 T313 timer */
#define T316_TIMER		20	/* Q.931 T316 timer */
#define T317_TIMER		21	/* Q.931 T317 timer */
#define T321_TIMER		22	/* Q.931 T321 timer */
#define T322_TIMER     		23	/* Q.931 T322 timer */
#define T3M1_TIMER		24	/* Q.931 T3M1 Maintenance timer */
#define TSPID_TIMER		25	/* Q.931 SPID request timer */
#define L1_T3_TIMER		26	/* L1 activation T3 timer */
#define L1_T4_TIMER		27	/* L1 activation T4 timer */
#define L1_POLL_TIMER		28	/* L1 activation poll timer */
#define T3xx_TIMER		29	/* Q.931 T3xx timer */
#define L2_DASS_NT1_TIMER	30	/* DASS DLC NT1 timer */
#define L2_DASS_NT2_TIMER	31	/* DASS DLC NT2 timer */
#define L3_DPNSS_CRM_TIMER	32	/* DPNSS CRM timer */
#define T302_TIMER		33	/* Q.931 T302 timer */
#define L1_T1_TIMER		34	/* L1 deactivation T1 timer */
#define L1_T2_TIMER		35	/* L1 activation T2 timer */
#define V110_T1_TIMER		36	/* V.110 T1 timer */
#define V110_RESYNC_TIMER	37	/* V.110 Resync timer */
#define TIMER_ID_END	(V110_RESYNC_TIMER)	/*end of timer ids*/
					/*maximum number of system timers -
					  the maximum number of 'timer_id_s'
					  which are pre-allocated*/
#define IGNORE_TIMER	255		/*ignore timer id - used to filter
					  timers which have already timed out,
					  are in the event queue, but the
					  present thread is stopping the timer*/

#ifdef PRI
#if defined( DPNSS ) || defined( DASS )
/* need DASS_L2_LINKS of NTx timer + DASS_L2_LINKS of L3 timer */
#define MAX_TIMERS	((DASS_L2_LINKS)*2)
#else
#define MAX_TIMERS	((MAX_L2_LINKS)+(MAX_CALLS)+(MAX_PRI_CHANNELS))
#endif
#else

#ifdef X25
#define MAX_TIMERS	((MAX_L2_LINKS)+(MAX_NUM_TTYS)-1+4+(NUM_LINKS)+((MAX_X25_LCNS)*2)+(MAX_CALLS))

#else
#define MAX_TIMERS	((MAX_L2_LINKS)+(MAX_NUM_TTYS)-1+4+(NUM_LINKS))
							/*allow for T202
							timers for max TTYs
							less the 127 link*/
#endif /*#ifdef X25*/

#endif /*#ifdef PRI*/


#ifdef MSC60

#ifdef AUTO
#pragma message("AUTO ACTIVATION/DEACTIVATION")
#endif
#ifdef NET_3
#pragma message("NET_3 Version")
#ifdef VN4
#pragma message("VN4 Delta")
#endif
#endif
#ifdef AUST
#pragma message("Australia Version")
#endif

#endif /* #ifdef MSC60 */

/*maximum number of LTOS events*/
#if defined( DPNSS ) || defined( DASS )
#define MAX_EVENTS	300
#else
#define MAX_EVENTS	150
#endif
/* #define MAX_EVENTS	((((K_DEFAULT)*(MAX_L2_LINKS))+(NUM_L3_BFRS)+(MAX_TIMERS))+100) */

/*channel definitions*/
#define D_CHAN		1	/*D channel*/
#define B1_CHAN		2	/*B1 channel*/
				/*other B channels sequencial from B1_CHAN*/
#define PRI_D_CHAN	1	/*PRImary rate D channel is the first B channel, or
					the BRI B1 channel*/
#define B2_CHAN		3	/*B2 channel*/

#if defined( MSC60 ) || defined( WIN40 ) || defined( NDIS_MINIPORT_DRIVER )

#pragma message("MSC60 or WIN40 or Miniport")

extern WORD ints_off( void );

#define _DISABLE	_asm	\
	_asm	cli
#define _ENABLE		_asm	\
	_asm	sti
#define INTERRUPTS_OFF		\
	ints_were_on = (BYTE)ints_off();		\

#define INTERRUPTS_ON		\
	if (ints_were_on) {	\
		_asm	sti	\
	}

/*I/O functions*/
#if defined( BRD_NEUT )

/* Define board neutral I/O procedures */
#if defined (WIN40 )
extern void _IOInit( void );
extern BYTE  _InReg( WORD );
extern void _OutReg( WORD, BYTE );
#else
/* assume DLL */
extern void CALLBACK _export _IOInit( void );
extern int CALLBACK _export _InReg( WORD );
extern void CALLBACK _export _OutReg( WORD, BYTE );
#endif /*#if defined (WIN40 )*/

#define INREG( r )	_InReg( r )
#define OUTREG( r, b )	_OutReg( r, b )
#define INREGW( r )	_InRegW( r )
#define OUTREGW( r, b )	_OutRegW( r, b )

#elif defined( PLUS )
extern BYTE _InReg( WORD );
extern void _OutReg( WORD, WORD );
extern WORD _InRegW( WORD );
extern void _OutRegW( WORD, WORD );
#define INREG( r )	_InReg( (WORD)(r) )
#define OUTREG( r, b )	_OutReg( (WORD)(r), (BYTE)(b) )
#define INREGW( r )	_InRegW( (WORD)(r) )
#define OUTREGW( r, w )	_OutRegW( (WORD)(r), (WORD)(w) )

#elif defined( _DOS )
#if defined( MMAP )
#pragma message( "memory mapped I/O" )
#define INREG( r )	((BYTE)(*((BYTE *)(r))))
#define OUTREG( r, b )	*((BYTE *)(r)) = ((BYTE)(b))

#elif defined( INDIO )		/* indirect I/O */
#pragma message( "Indirect I/O" )
extern BYTE _InReg( BYTE, WORD );
extern void _OutReg( BYTE, WORD, BYTE );
extern WORD _InRegW( BYTE, WORD );
extern void _OutRegW( BYTE, WORD, WORD );
#define INREG( a, r )	_InReg( (BYTE)(a), (WORD)(r) )
#define OUTREG( a, r, b )	_OutReg( (BYTE)(a), (WORD)(r), (BYTE)(b) )
#define INREGW( a, r )	_InRegW( (BYTE)(a), (WORD)(r) )
#define OUTREGW( a, r, w )	_OutRegW( (BYTE)(a), (WORD)(r), (WORD)(w) )

#else
#pragma message( "Direct I/O" )
#define INREG( r )	inp( r )
#define OUTREG( r, b )	outp( r, b )
#define INREGW( r )	inpw( r )
#define OUTREGW( r, b )	outpw( r, b )
#endif
extern void ltprintf( const char *format, ... );

#elif defined( NDIS_MINIPORT_DRIVER )
#pragma message( "Miniport I/O" )
extern BYTE _InReg( WORD );
extern void _OutReg( WORD, BYTE );
extern WORD _InRegW( WORD );
extern void _OutRegW( WORD, WORD );
#define INREG( r )	_InReg( (WORD)(r) )
#define OUTREG( r, b )	_OutReg( (WORD)(r), (BYTE)(b) )
#define INREGW( r )	_InRegW( (WORD)(r) )
#define OUTREGW( r, w )	_OutRegW( (WORD)(r), (WORD)(w) )

#elif defined( MMAP )
#pragma message( "memory mapped I/O" )
#define INREG( r )	((BYTE)(*((BYTE *)(r))))
#define OUTREG( r, b )	*((BYTE *)(r)) = ((BYTE)(b))

#elif defined( INDIO )		/* indirect I/O */
#pragma message( "Indirect I/O" )
extern BYTE _InReg( BYTE, WORD );
extern void _OutReg( BYTE, WORD, BYTE );
extern WORD _InRegW( BYTE, WORD );
extern void _OutRegW( BYTE, WORD, WORD );
#define INREG( a, r )	_InReg( (BYTE)(a), (WORD)(r) )
#define OUTREG( a, r, b )	_OutReg( (BYTE)(a), (WORD)(r), (BYTE)(b) )
#define INREGW( a, r )	_InRegW( (BYTE)(a), (WORD)(r) )
#define OUTREGW( a, r, w )	_OutRegW( (BYTE)(a), (WORD)(r), (WORD)(w) )

#else
#define INREG( r )	inp( r )
#define OUTREG( r, b )	outp( r, b )
#define INREGW( r )	inpw( r )
#define OUTREGW( r, b )	outpw( r, b )

#endif /* #if defined( BRD_NEUT ) */

#endif /*#if defined( MSC60 ) || defined( WIN40 ) ...*/

#if defined( BC )

#define INREG( r )	inp( r )
#define OUTREG( r, b )	outp( r, b )
#define INREGW( r )	inpw( r )
#define OUTREGW( r, b )	outpw( r, b )

extern WORD ints_off( void );

#define _DISABLE	_asm	\
	_asm	cli
#define _ENABLE		_asm	\
	_asm	sti
#define INTERRUPTS_OFF		\
	ints_were_on = (BYTE)ints_off();		\

#define INTERRUPTS_ON		\
	if (ints_were_on)	\
		_enable();

/* min and max macros */
#if !defined( max )
#pragma message( "defining max" )
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#endif
#if !defined( min )
#pragma message( "defining min" )
#define min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#endif /*#if defined( BC )*/

#ifdef ASSERT
#undef ASSERT
#endif
#define ASSERT(C)	if (!(C)) ltprintf("ASSERT(%s) FAILED!\n%s #%d\n", #C, __FILE__, __LINE__);

#ifdef M68K

/* min and max macros */
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))

/* define MMAP for memory mapped I/O */
#define _DISABLE	_SPL(7);
#define _ENABLE		_SPL(0);
#define INTERRUPTS_OFF			\
	ints_were_on = _GPL();		\
	_DISABLE
#define INTERRUPTS_ON			\
	_SPL( ints_were_on );
#define INREG( r )	((BYTE)(*((BYTE *)(r))))
#define OUTREG( r, b )	*((BYTE *)(r)) = ((BYTE)(b))

#endif

#ifdef I8051

#define BOOLEAN	BYTE
#define XDATA_PTR	((BYTE *) 0x010000)	/* 3-byte pointer format */
#define CODE_PTR	((BYTE *) 0x020000)	/* 3-byte pointer format */

/* min and max macros */
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))

#define outp(preg, val)		*(preg) = (val)
#define inp(preg)		((BYTE)(*(preg)))

void memset(BYTE *, BYTE, WORD);
void memcpy(BYTE *, BYTE *, WORD);

/*general macros*/
extern BOOLEAN ints_were_on;		/*interrupts on flag*/
extern BYTE int_nesting_cnt;		/*interrupt nesting count*/
#define INTERRUPTS_OFF		\
	++int_nesting_cnt;	\
	if (EA) {	\
		ints_were_on = 1;\
		EA = 0;	\
	}

#define INTERRUPTS_ON		\
	if (--int_nesting_cnt==0 && ints_were_on) {	\
		EA = 1;	\
	}

#define _DISABLE	\
	EA = 0;

#define _ENABLE		\
	EA = 1;

#endif

#if defined ( PORTABLE )
void memcpy( BYTE *pdest, BYTE *psrc, WORD len );
void memset( BYTE *pdest, BYTE val, WORD len );
WORD strlen( char *pstr );
void strcpy( char *pdest, char *psrc );
void outp( WORD Addrs, BYTE Val );
void outpw( WORD Addrs, WORD Val );
#endif

/*general queue structure*/
struct queue_s {
	struct bfr_hdr_s *pfirst;	/*first buffer header in queue*/
	struct bfr_hdr_s *plast;	/*last buffer header in queue*/
	WORD q_cnt;			/*number of buffers in queue*/
};

/* Layer 1 priority defines */
#define	L1_PRI_HI		0		/*high priority*/
#define	L1_PRI_LO		1		/*low priority*/

/*Layer 1 driver trace log defines*/
#define LOG_SIZE		64	/*trace log buffer size*/
#define LOG_XMT_START		0x01	/*starting xmt*/
#define LOG_XMT_INT		0x02	/*xmt interrupt*/
#define LOG_XMT_DONE		0x03	/*xmt complete interrupt*/
#define LOG_RCV_INT		0x04	/*rcv interrupt*/
#define LOG_RCV_DONE		0x05	/*rcv done*/
#define LOG_INT			0x06	/*D interrupt*/
#define LOG_TIM_INT		0x07	/*D timer interrupt*/
#define LOG_EOF			0x08	/*end of rcv frame*/
#define LOG_RERROR		0x09	/*rcv error*/
#define LOG_ISR_REPEAT		0x0a	/*repeat main ISR processing*/
#define LOG_ILL			0x0b	/*D may be ill*/
#define LOG_ABORT		0x0c	/*abort transmission*/
#define LOG_MARKING_EOF		0x0d	/*marking end of frame*/
#define LOG_SEND_TOKEN		0x0e	/*send him the token*/
#define LOG_BXMT_START		0x0f	/*starting B xmt*/
#define LOG_BINT		0x10	/*B interrupt*/
#define LOG_BRERROR		0x11	/*B rcv error*/
#define LOG_BRCV_DONE		0x12	/*B rcv done*/
#define LOG_BXMT_DONE		0x13	/*B xmt complete interrupt*/
#define LOG_BXERROR		0x14	/*B xmt error*/
#define LOG_INTCLR		0x15	/*D interrupt clear*/
#define LOG_BRESET		0x16	/*D interrupt clear*/
#define LOG_DXMT_URUN		0x17	/*D xmt underrun*/
#define LOG_BXMT_URUN		0x18	/*B xmt underrun*/

/*Layer 1 driver trace log macro*/
#ifdef L1_LOG_DEBUG
#define L1_LOG(val) {\
	WORD ints_were_on;\
	INTERRUPTS_OFF;	\
	log_bfr[log_in] = val;\
	log_in = (log_in+1)%(LOG_SIZE);\
	INTERRUPTS_ON;	\
}
#else
#define L1_LOG(val) ;
#endif
#ifdef L1_ERROR_LOG
#define L1_ERROR_LOG(chan, val) {\
	l1err_log_bfr[l1err_log_in++] = ((chan)<<8)|(val);\
	if ( l1err_log_in == LOG_SIZE ) l1err_log_in=0;\
}
#else
#define L1_ERROR_LOG(chan, val) ;
#endif

#define SWAP_BYTES( wrd )	( ( (wrd) >> 8 ) | ( (wrd) << 8 ) )

/*Layer 1 state defines*/
#define STATE_DEACTIVATED	1
#define STATE_IDENTIFYING_INPUT	2
#define STATE_SYNCHRONIZED	3
#define STATE_ACTIVATED		4
#define STATE_LOST_FRAMING	5

#endif	// __V110_SYS_H__
