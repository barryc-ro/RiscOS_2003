/*name and version number:@(#)zmdmtest.h	1.1*/
/*date of get: 		  09/06/00 16:59:20*/
/*date of delta:	  05/18/98 10:42:32*/

#if defined( ZMODEM_TEST )

#define ISADIGIT( x ) ( ((x) >= '0') && ((x) <= '9') )

// this is global just to make it accessable
BOOL startIt ;
BOOL doIt ;

char counter ;
char c1, c2, c3, c4 ,c5 ;
char hc1, hc2, hc3, hc4, hc5 ;

void initIt ( void )
{
	counter = 0 ;
	doIt = startIt = FALSE ;
}

//--------------------------------------------------------------
// This is the routine that is called when an error is detected. 
// It just wiggles a dig-out to trigger the scope.
// (platform is 68k variant, so all addrs are mem-mapped.
//--------------------------------------------------------------
void triggerCATC ( char ch )
{
	// trigger CATC trace here
	GREEN_ON() ;
	sendDumbChar( 0x0a ) ;	sendDumbChar( 0x0d ) ;
	sendDumbChar( hc5 ) ;	sendDumbChar( hc4 ) ;
	sendDumbChar( hc3 ) ;	sendDumbChar( hc2 ) ;
	sendDumbChar( ':' ) ;	sendDumbChar( ' ' ) ;
	sendDumbChar( 'w' ) ;	sendDumbChar( 'a' ) ;
	sendDumbChar( 'n' ) ;	sendDumbChar( 't' ) ;
	sendDumbChar( ' ' ) ; 
	sendHexByte( counter ); sendDumbChar( ' ' ) ; 
	sendDumbChar( 'i' ) ;	sendDumbChar( 's' ) ;
	sendDumbChar( ' ' ) ; 
	sendHexByte( ch ) ;		sendDumbChar( ' ' ) ;
	doIt = FALSE ; counter = 0 ;

	disable_interrupt() ;
	while ( TRUE )
	{
#if defined( WATCHDOG_TIMER )
		// strobe sanity timer
		output8( 0xda, 0x1f ) ;
		output8( 0xdb, 0xe5 ) ;
#endif

		if ( input8( DUMB_LSR ) & 1 )
		{
			break ;
		}
	}
}

//---------------------------------------------------------------
// This is the routine that is called to check the next char
//---------------------------------------------------------------
// 0000: 0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefg
// 0001: 0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefg
//	o
//	o
//	o
// 8191: 0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefg
//---------------------------------------------------------------
void chrchk ( char ch )
{
	extern void triggerCATC ( char ch ) ;
	switch ( ch )
	{
		case ' ':
			//--------------------------------------------------
			// space char, enable monitor and seed counter
			// next char expected is a '0', so seed with
			// '0' - 1
			//--------------------------------------------------
			if ( doIt )
			{
				triggerCATC ( ch ) ;
			}
			else if ( (c1 == ':') && ISADIGIT( c2 ) && ISADIGIT( c3 ) &&
					 ISADIGIT( c4 ) && ISADIGIT( c5 ) )
			{
				counter = '0' - 1 ;
				doIt = TRUE ;
				hc2 = c2 ; hc3 = c3 ; hc4 = c4 ; hc5 = c5 ;
				GREEN_OFF() ;
				RED_ON() ;
			}
			break ;

		case '\n':
			//--------------------------------------------------
			// LF, check that last was CR and disable counter
			// until the next space char is seen.
			//--------------------------------------------------
			if ( doIt && counter && (counter != '\r') )
			{
				triggerCATC ( ch ) ;
			}
			counter = 0 ;
			doIt = FALSE ;
			RED_OFF() ;
			break ;

		case '\r':
			//--------------------------------------------------
			// CR, first discontiguous char in pattern so it
			// requires a special case compare ('g' is last
			// char on line in test file).
			//--------------------------------------------------
			if ( doIt && (counter != 'g') )
			{
				triggerCATC ( ch ) ;
			}
			else
			{
				counter = '\r' ;
			}
			break ;

		default:
			//--------------------------------------------------
			// Contiguous incrementing pattern. This char should
			// be "last char + 1"
			//--------------------------------------------------
			if ( doIt )
			{
				if ( (++counter) != ch )
				{
					triggerCATC ( ch ) ;
				}
			}
			break ;
	}
	c5 = c4; c4 = c3 ; c3 = c2 ; c2 = c1 ; c1 = ch ;
}
#endif // defined( ZMODEM_TEST )
