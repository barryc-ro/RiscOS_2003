/*name and version number:@(#)ocm.h	1.1*/
/*date of get: 		  01/12/01 11:49:20*/
/*date of delta:	  01/12/01 11:25:03*/
#ifndef __OCM__
#define __OCM__

#if defined(TRIDENT)
/***************************************************************************
    AWM4807 C header file Peripheral Definitions 
    Version 1.0 TJM  8/24/99

    Starting memory address for each peripherial (pointer to structure)
*****************************************************************************/

#define RPCM_BASE   0xE0000000
#define PIC_BASE    0xE0001000
#define DMAC_BASE   0xE0002000
#define EMI_BASE    0xE0003000
#define SSI_BASE    0xE0004000
#define PWM_BASE    0xE0005000
#define PPI1_BASE   0xE0006000
#define KEYBD_BASE  0xE0007000
#define ASCC0_BASE  0xE0008000
#define ASCC1_BASE  0xE0009000
#define ASCC2_BASE  0xE000A000
#define SIM0_BASE   0xE000B000
#define RTC_BASE    0xE000C000
#define ADC_BASE    0xE000D000
#define PPI2_BASE   0xE000E000
#define SIM1_BASE   0xE000F000
#define ASIC_BASE   0xE0010000
#define IRDA_BASE   ASCC0_BASE
#define ICPM_BASE   0xFFFF0000
#define ICP_BASE    0xFFFFFF00

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*  Reset, Power and Clock Management Registers Definitions                 */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    RPCM_PAUSE ;               // Pause register 
    volatile unsigned long    RPCM_CLOCK_MANG ;          //  register 
    volatile unsigned long    RPCM_PWR_MANG_SET ;        //  register 
    volatile unsigned long    RPCM_PWR_MANG_CLEAR ;      //  register 
    volatile unsigned long    RPCM_ID ;                  //  register 
    volatile unsigned long    RPCM_CLOCK_STATUS ;        //  register 
    volatile unsigned long    RPCM_CLOCK_CONTROL ;       //  register 
    volatile unsigned long    RPCM_RESERVED0 ;           //  register 
    volatile unsigned long    RPCM_RESERVED1 ;           //  register 
    volatile unsigned long    RPCM_PLL_CONTROL ;         //  register 
    volatile unsigned long    RPCM_RESERVED2 ;           //  register 
    volatile unsigned long    RPCM_RESERVED3 ;           //  register 
    volatile unsigned long    RPCM_RESET_STATUS ;        //  register 
    volatile unsigned long    RPCM_STATUS_CLEAR ;        //  register 
} StructRPCM ;

#define RPCM_PAUSE_WFI  (0001<<0)               // if set the system is in WFI mode

#define RPCM_CLOCK_MANG_CMEC    (1<<00)         // Switch to external clock
#define RPCM_CLOCK_MANG_PLCC    (1<<01)         // Switch to PLL clock
#define RPCM_CLOCK_MANG_CMRT    (1<<02)         // Switch to Real Time clock
#define RPCM_CLOCK_MANG_CMRO    (1<<03)         // Switch to Ring Oscillator clock

#define RPCM_PWR_MANG_PMIT      (1<<00)         // 0  clock interval timer unit is on. 1  clock interval timer unit is off
#define RPCM_PWR_MANG_PMWT      (1<<01)         // 0  clock to watchdog timer is on. 1  clock to watchdog timer is off
#define RPCM_PWR_MANG_PWM1      (1<<02)         // 0  clock to PWM1 is on. 1  clock to PWM1 is off
#define RPCM_PWR_MANG_PWM2      (1<<03)         // 0  clock to PWM2 is on. 1  clock to PWM2 is off
#define RPCM_PWR_MANG_PMP       (1<<04)         // 0  clock to Prescaler and Control Register is on. 1  clock to Prescaler and Control Register is off
#define RPCM_PWR_MANG_DMA       (1<<05)         // 0  clock to DMA is on. 1  clock to DMA is off
#define RPCM_PWR_MANG_SIM       (1<<06)         // 0  clock to SIM Interface is on. 1  clock to SIM Interface is off
#define RPCM_PWR_MANG_ASC0      (1<<07)         // 0  clock to Async Serial Comm Channel 0 is on. 1  clock to Async Serial Comm Channel 0 is off
#define RPCM_PWR_MANG_ASC1      (1<<08)         // 0  clock to Async Serial Comm Channel 1 is on. 1  clock to Async Serial Comm Channel 1 is off
#define RPCM_PWR_MANG_ASC2      (1<<09)         // 0  clock to Async Serial Comm Channel 2 is on. 1  clock to Async Serial Comm Channel 2 is off
#define RPCM_PWR_MANG_ASC3      (1<<10)         // 0  clock to Async Serial Comm Channel 3 is on. 1  clock to Async Serial Comm Channel 3 is off
#define RPCM_PWR_MANG_ADC       (1<<11)         // 0  clock to Analog to Digital Converter is on. 1  clock to Analog to Digital Converter is off
#define RPCM_PWR_MANG_EMI       (1<<12)         // 0  clock to External Memory Interface is on. 1  clock to External Memory Interface is off
#define RPCM_PWR_MANG_RTCI      (1<<13)         // 0  clock to Real Time Clock Interface is on. 1  clock to Real Time Clock Interface is off
#define RPCM_PWR_MANG_SSI       (1<<14)         // 0  clock to Synchronous Serial Interface is on. 1  clock to Synchronous Clock Interface is off
#define RPCM_PWR_MANG_PPI       (1<<15)         // 0  clock to Programmable Peripheral Interface is on. 1  clock to Programmable Peripheral Interface is off

#define RPCM_ID_IDS             (1<<0)          // 0  no further ID information is available. 1  further bits are required for more detailed info

#define RPCM_CLOCK_STATUS_PCS_EXT   (0x00<<0)   // 00 External Clock is system clock
#define RPCM_CLOCK_STATUS_PCS_PLL   (0x01<<0)   // 01 Phase Lock Loop is system clock
#define RPCM_CLOCK_STATUS_PCS_RTC   (0x02<<0)   // 10 Real Time Clock is system clock
#define RPCM_CLOCK_STATUS_PCS_ROC   (0x03<<0)   // 11 Ring Oscilator is system clock

#define RPCM_CLOCK_STATUS_PFSC_EXT  (0x00<<2)   // 00 External Clock is previous fast clock
#define RPCM_CLOCK_STATUS_PFSC_PLL  (0x01<<2)   // 01 Phase Lock Loop is previous fast clock
#define RPCM_CLOCK_STATUS_PFSC_RTC  (0x02<<2)   // 10 Real Time Clock is previous fast clock
#define RPCM_CLOCK_STATUS_PFSC_ROC  (0x03<<2)   // 11 Ring Oscilator is previous fast clock

#define RPCM_CLOCK_CONTROL_OFF      (1<<0)      // 0 CLKOFF mode is not active. 1 CLKOFF mode is active
#define RPCM_CLOCK_CONTROL_CKIOV    (1<<1)      // 0 CKI turns off when not needed. 1 CKI never turns off
#define RPCM_CLOCK_CONTROL_PLLE     (1<<2)      // 0 PLL is disabled in manual mode. 1 PLL is enabled in manual mode
#define RPCM_CLOCK_CONTROL_ROE      (1<<3)      // Enables the rign oscillator, when in manual mode 0 Ring Osc is powered off and RTC is slow clock. 1 Ring Osc is powered on and selected as slow clock
#define RPCM_CLOCK_CONTROL_MS       (1<<4)      // Enables manual mode 0 clock switching is completed automatically. 1 clock switching is completed by software
#define RPCM_CLOCK_CONTROL_CKOEN    (1<<10)     // 0 CKO is disabled and DRQ is free to use the bit. 1 CKO is enabled and DRQ can not use this bit

#define RPCM_RESET_STATUS_ER        (1<<0)      // Identifies that the last reset was an external reset. 0 last reset was not an external reset or bit has been cleared. 1 last reset was an external reset
#define RPCM_RESET_STATUS_WR        (1<<1)      // Identifies that the last reset was a warm reset(caused by watchdog timer) 0 last reset was not an warm reset or bit has been cleared. 1 last reset was an warm reset

#define RPCM_PLL_CONTROL_M_2    (0<<0)      // Encodes M
#define RPCM_PLL_CONTROL_M_3    (1<<0)      // Encodes M
#define RPCM_PLL_CONTROL_M_4    (2<<0)      // Encodes M
#define RPCM_PLL_CONTROL_M_5    (3<<0)      // Encodes M
#define RPCM_PLL_CONTROL_M_6    (4<<0)      // Encodes M
#define RPCM_PLL_CONTROL_M_7    (5<<0)      // Encodes M
#define RPCM_PLL_CONTROL_M_8    (6<<0)      // Encodes M
#define RPCM_PLL_CONTROL_M_9    (7<<0)      // Encodes M
#define RPCM_PLL_CONTROL_M_10   (8<<0)      // Encodes M
#define RPCM_PLL_CONTROL_M_11   (9<<0)      // Encodes M
#define RPCM_PLL_CONTROL_M_12   (10<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_13   (11<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_14   (12<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_15   (13<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_16   (14<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_17   (15<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_18   (16<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_19   (17<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_20   (18<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_21   (19<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_22   (20<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_23   (21<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_24   (22<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_25   (23<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_26   (24<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_27   (25<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_28   (26<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_29   (27<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_30   (28<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_31   (29<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_32   (30<<0)     // Encodes M
#define RPCM_PLL_CONTROL_M_33   (31<<0)     // Encodes M
#define RPCM_PLL_CONTROL_N_2    (0<<8)      // Encodes N
#define RPCM_PLL_CONTROL_N_3    (1<<8)      // Encodes N
#define RPCM_PLL_CONTROL_N_4    (2<<8)      // Encodes N
#define RPCM_PLL_CONTROL_N_5    (3<<8)      // Encodes N
#define RPCM_PLL_CONTROL_N_6    (4<<8)      // Encodes N
#define RPCM_PLL_CONTROL_N_7    (5<<8)      // Encodes N
#define RPCM_PLL_CONTROL_N_8    (6<<8)      // Encodes N
#define RPCM_PLL_CONTROL_N_1    (7<<8)      // Encodes N
#define RPCM_PLL_CONTROL_LF_0   (0<<12)     // Encodes LF
#define RPCM_PLL_CONTROL_LF_1   (1<<12)     // Encodes LF
#define RPCM_PLL_CONTROL_LF_2   (2<<12)     // Encodes LF
#define RPCM_PLL_CONTROL_LF_3   (3<<12)     // Encodes LF
#define RPCM_PLL_CONTROL_LF_4   (4<<12)     // Encodes LF
#define RPCM_PLL_CONTROL_LF_5   (5<<12)     // Encodes LF
#define RPCM_PLL_CONTROL_LF_6   (6<<12)     // Encodes LF
#define RPCM_PLL_CONTROL_LF_7   (7<<12)     // Encodes LF
#define RPCM_PLL_CONTROL_LF_8   (8<<12)     // Encodes LF
#define RPCM_PLL_CONTROL_LF_9   (9<<12)     // Encodes LF
#define RPCM_PLL_CONTROL_LF_10  (10<<12)    // Encodes LF
#define RPCM_PLL_CONTROL_LF_11  (11<<12)    // Encodes LF
#define RPCM_PLL_CONTROL_LF_12  (12<<12)    // Encodes LF
#define RPCM_PLL_CONTROL_LF_13  (13<<12)    // Encodes LF
#define RPCM_PLL_CONTROL_LF_14  (14<<12)    // Encodes LF
#define RPCM_PLL_CONTROL_LF_15  (15<<12)    // Encodes 
#define RPCM_PLL_CONTROL_FR_0   (0<<23)     // Encodes FR
#define RPCM_PLL_CONTROL_FR_1   (1<<23)     // Encodes FR
#define RPCM_PLL_CONTROL_FR_2   (2<<23)     // Encodes FR
#define RPCM_PLL_CONTROL_FR_3   (3<<23)     // Encodes FR

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*  Programmable Peripheral Interface Registers                             */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    PPI_DIR ;                  // Port Data Direction Register 
    volatile unsigned long    PPI_RESERVED1 ;            // Port Data Register 
    volatile unsigned long    PPI_INTENAB ;              //  
    volatile unsigned long    PPI_SENSE ;                // Sense Register 
    volatile unsigned long    PPI_POLARITY ;             // Polarity Register 
    volatile unsigned long    PPI_PULLUP ;               // Port Data Direction Register 
    volatile unsigned long    PPI_RESERVED2 ;            // Port Data Register 
    volatile unsigned long    PPI_CLEAR ;                //  
    volatile unsigned long    PPI_SET ;                  // Sense Register 
} StructPPI ;

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*  KeyBoard Interface Registers                             */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    KEYBD_DIR ;                  // Port Data Direction Register 
    volatile unsigned long    KEYBD_RESERVED1 ;            // Port Data Register 
    volatile unsigned long    KEYBD_INTENAB ;              //  
    volatile unsigned long    KEYBD_SENSE ;                // Sense Register 
    volatile unsigned long    KEYBD_POLARITY ;             // Polarity Register 
    volatile unsigned long    KEYBD_PULLUP ;               // Port Data Direction Register 
    volatile unsigned long    KEYBD_CONTROL ;            // Port Data Register 
    volatile unsigned long    KEYBD_CLEAR ;                //  
    volatile unsigned long    KEYBD_SET ;                  // Sense Register 
} StructKEYBD ;

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*  Programmable Timer Control Registers                                    */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    PWM_MAX_COUNT_A1 ;         // Maximum Count Register 
    volatile unsigned long    PWM_MAX_COUNT_B1 ;         // Maximum Count Register 
    volatile unsigned long    PWM_COUNT_1 ;              // Count Register 
    volatile unsigned long    PWM_MAX_COUNT_A2 ;         // Maximum Count Register 
    volatile unsigned long    PWM_MAX_COUNT_B2 ;         // Maximum Count Register 
    volatile unsigned long    PWM_COUNT_2 ;              // Count Register 
    volatile unsigned long    PWM_COUNT_RATE ;           // Count Rate Register 
    volatile unsigned long    PWM_WT_COUNT ;             // Watchdog Timer Count Register 
    volatile unsigned long    PWM_RESERVED1 ;            // Interval Timer Count Register 
    volatile unsigned long    PWM_STATUS ;               // Status Register 
    volatile unsigned long    PWM_MASK ;                 // Mask Register 
    volatile unsigned long    PWM_CONTROL ;              // Count Register 
    volatile unsigned long    PWM_ITMAX_COUNT_0 ;        // Count Register 
    volatile unsigned long    PWM_ITCOUNT_0 ;            // Count Register 
    volatile unsigned long    PWM_ITMAX_COUNT_1 ;        // Count Register 
    volatile unsigned long    PWM_ITCOUNT_1 ;            // Count Register 
    volatile unsigned long    PWM_ITMAX_COUNT_2 ;        // Count Register 
    volatile unsigned long    PWM_ITCOUNT_2 ;            // Count Register 
    volatile unsigned long    PWM_ITMAX_COUNT_3 ;        // Count Register 
    volatile unsigned long    PWM_ITCOUNT_3 ;            // Count Register 
    volatile unsigned long    PWM_ITPRESCALER ;            // Prescaler Register 
    volatile unsigned long    PWM_WTPRESCALER ;            // Prescaler Register 
    volatile unsigned long    PWM_PWMPRESCALER ;        //  Register 
    volatile unsigned long    PWM_MAX_COUNT_A3 ;         // Maximum Count Register 
    volatile unsigned long    PWM_MAX_COUNT_B3 ;         // Maximum Count Register 
    volatile unsigned long    PWM_COUNT_3 ;              // Count Register 
} StructPWM ;

#define PWM_COUNT_RATE_PWM_2        (0x00<<0)   // divide by 2
#define PWM_COUNT_RATE_PWM_4        (0x01<<0)   // divide by 4
#define PWM_COUNT_RATE_PWM_8        (0x02<<0)   // divide by 8
#define PWM_COUNT_RATE_PWM_16       (0x03<<0)   // divide by 16
#define PWM_COUNT_RATE_PWM_32       (0x04<<0)   // divide by 32
#define PWM_COUNT_RATE_PWM_64       (0x05<<0)   // divide by 64
#define PWM_COUNT_RATE_PWM_128      (0x06<<0)   // divide by 128
#define PWM_COUNT_RATE_PWM_256      (0x07<<0)   // divide by 256
#define PWM_COUNT_RATE_PWM_512      (0x08<<0)   // divide by 512
#define PWM_COUNT_RATE_PWM_1024     (0x09<<0)   // divide by 1024
#define PWM_COUNT_RATE_PWM_2048     (0x0A<<0)   // divide by 2048
#define PWM_COUNT_RATE_PWM_4096     (0x0B<<0)   // divide by 4096

#define PWM_COUNT_RATE_WT_2        (0x00<<4)   // divide by 2
#define PWM_COUNT_RATE_WT_4        (0001<<4)   // divide by 4
#define PWM_COUNT_RATE_WT_8        (0x02<<4)   // divide by 8
#define PWM_COUNT_RATE_WT_16       (0x03<<4)   // divide by 16
#define PWM_COUNT_RATE_WT_32       (0x04<<4)   // divide by 32
#define PWM_COUNT_RATE_WT_64       (0x05<<4)   // divide by 64
#define PWM_COUNT_RATE_WT_128      (0x06<<4)   // divide by 128
#define PWM_COUNT_RATE_WT_256      (0x07<<4)   // divide by 256
#define PWM_COUNT_RATE_WT_512      (0x08<<4)   // divide by 512
#define PWM_COUNT_RATE_WT_1024     (0x09<<4)   // divide by 1024
#define PWM_COUNT_RATE_WT_2048     (0x0A<<4)   // divide by 2048
#define PWM_COUNT_RATE_WT_4096     (0x0B<<4)   // divide by 4096

#define PWM_COUNT_RATE_IT_2        (0x00<<8)   // divide by 2
#define PWM_COUNT_RATE_IT_4        (0x01<<8)   // divide by 4
#define PWM_COUNT_RATE_IT_8        (0x02<<8)   // divide by 8
#define PWM_COUNT_RATE_IT_16       (0x03<<8)   // divide by 16
#define PWM_COUNT_RATE_IT_32       (0x04<<8)   // divide by 32
#define PWM_COUNT_RATE_IT_64       (0x05<<8)   // divide by 64
#define PWM_COUNT_RATE_IT_128      (0x06<<8)   // divide by 128
#define PWM_COUNT_RATE_IT_256      (0x07<<8)   // divide by 256
#define PWM_COUNT_RATE_IT_512      (0x08<<8)   // divide by 512
#define PWM_COUNT_RATE_IT_1024     (0x09<<8)   // divide by 1024
#define PWM_COUNT_RATE_IT_2048     (0x0A<<8)   // divide by 2048
#define PWM_COUNT_RATE_IT_4096     (0x0B<<8)   // divide by 4096

#define PWM_STATUS_I0S              (1<<0)      // 1 channel 0 IT comp reg matches IT count reg
#define PWM_STATUS_I1S              (1<<1)      // 1 channel 1 IT comp reg matches IT count reg
#define PWM_STATUS_I2S              (1<<2)      // 1 channel 2 IT comp reg matches IT count reg
#define PWM_STATUS_I3S              (1<<3)      // 1 channel 3 IT comp reg matches IT count reg
#define PWM_STATUS_ROSC             (1<<4)      // 1 measurement of ring oscillator is complete
#define PWM_STATUS_P1S              (1<<8)      // 1 a new PWM cycle has begun on channel 1
#define PWM_STATUS_P2S              (1<<9)      // 1 a new PWM cycle has begun on channel 2
#define PWM_STATUS_P3S              (1<<10)     // 1 a new PWM cycle has begun on channel 3
#define PWM_STATUS_WTS              (1<<11)     // 1 watchdog timer

#define PWM_MASK_I0E                (1<<0)      // 1 Timer IRQ will occur when IT Channel 0 is 1
#define PWM_MASK_I1E                (1<<1)      // 1 Timer IRQ will occur when IT Channel 1 is 1
#define PWM_MASK_I2E                (1<<2)      // 1 Timer IRQ will occur when IT Channel 2 is 1
#define PWM_MASK_I3E                (1<<3)      // 1 Timer IRQ will occur when IT Channel 3 is 1
#define PWM_MASK_ROSC               (1<<4)      // 1 Timer IRQ will occur when IT Channel 4 is 1
#define PWM_MASK_P1E                (1<<8)      // 1 Timer IRQ will occur when PWM Channel 1 starts a new cycle
#define PWM_MASK_P2E                (1<<9)      // 1 Timer IRQ will occur when PWM Channel 2 starts a new cycle
#define PWM_MASK_P3E                (1<<10)     // 1 Timer IRQ will occur when PWM Channel 3 starts a new cycle
#define PWM_MASK_WTE                (1<<11)     // 1 Timer IRQ will occur when watchdog timer

#define PWM_CONTROL_P1E             (1<<0)      // 1 PWM Channel 1 is enabled to count. 0 PWM Channel 1 is disabled
#define PWM_CONTROL_P2E             (1<<1)      // 1 PWM Channel 2 is enabled to count. 0 PWM Channel 2 is disabled
#define PWM_CONTROL_RENB            (1<<2)      // 1 ring oscillator mwasurement enable
#define PWM_CONTROL_WRE             (1<<3)      // 1 Watchdog Timer Counter is enabled.
#define PWM_CONTROL_WTR             (1<<4)      // 1 Watchdog Timer Counter is reset is enabled. 0 Watchdog timer reset is disabled.
#define PWM_CONTROL_WIC             (1<<5)      // 1 Watchdog Timer Counter clock is 32KHZ. 0 Watchdog timer clock is pripheral clock.
#define PWM_CONTROL_PWM2            (1<<7)      // 1 PWM2. 0 PA23
#define PWM_CONTROL_P23             (0<<7)      // 1 PWM2. 0 PA23
#define PWM_CONTROL_WTI             (1<<8)      // 1 watchdog timer interrupt mode. 0 PA23
#define PWM_CONTROL_P3E             (1<<9)      // 1 PWM Channel 3 is enabled to count. 0 PWM Channel 3 is disabled
#define PWM_CONTROL_PWM3            (1<<10)     // 1 PWM2. 0 PA24
#define PWM_CONTROL_P24             (0<<10)     // 1 PWM2. 0 PA24
#define PWM_CONTROL_IT0E            (1<<11)     // 1 interval timer 0 is enabled to count.
#define PWM_CONTROL_IT1E            (1<<12)     // 1 interval timer 1 is enabled to count.
#define PWM_CONTROL_IT2E            (1<<13)     // 1 interval timer 2 is enabled to count.
#define PWM_CONTROL_IT3E            (1<<14)     // 1 interval timer 3 is enabled to count.

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*  Asynchronous Serial Communication Controller Registers                  */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    ASCC_BAUD_RATE ;           // Baud Rate Register 
    volatile unsigned long    ASCC_BAUD_COUNTER ;        // Baud Rate Counter Register 
    volatile unsigned long    ASCC_FIFO_STATUS ;         // Fifo Status Register 
    volatile unsigned long    ASCC_STATUS ;              // ACC Status Register 
    volatile unsigned long    ASCC_RX_CONTROL ;          // Receiver Control Register 
    volatile unsigned long    ASCC_TX_CONTROL ;          // Transmitter Control Register 
    volatile unsigned long    ASCC_MODE_CONTROL ;        // Mode Control Register 
    volatile unsigned long    ASCC_TXRX_FIFO ;           // Tx/Rx FIFO Register 
    volatile unsigned long    ASCC_FEATURES ;            // Feature Register 
} StructASCC ;

#define ASCC_FIFO_STATUS_RFE        (1<<0)      // 1 receiver FIFO is empty. 0 receiver FIFO is NOT empty
#define ASCC_FIFO_STATUS_RFHF       (1<<1)      // 1 receiver FIFO is at least half full. 0 receiver FIFO is NOT at least half full
#define ASCC_FIFO_STATUS_RFF        (1<<2)      // 1 receiver FIFO is full. 0 receiver FIFO is NOT full
#define ASCC_FIFO_STATUS_TFE        (1<<3)      // 1 transmitter FIFO is empty. 0 transmitter FIFO is NOT empty
#define ASCC_FIFO_STATUS_TFHF       (1<<4)      // 1 transmitter FIFO is at least half full. 0 transmitter FIFO is NOT at least half full
#define ASCC_FIFO_STATUS_TFF        (1<<5)      // 1 transmitter FIFO is full. 0 transmitter FIFO is NOT full
#define ASCC_FIFO_STATUS_TSE        (1<<6)      // 1 transmitter Shift Register is empty.0 transmitter Shift Register is NOT empty
#define ASCC_FIFO_STATUS_RID        (1<<7)      // 1 the receiver is idle. 0 the receiver is NOT idle

#define ASCC_STATUS_RFT             (1<<0)      // 1 receiver FIFO threshold condition is met. 0 the FIFO condition is not met
#define ASCC_STATUS_RPE             (1<<1)      // 1 a parity error has occurred in a received character. 0 a parity error did not occur
#define ASCC_STATUS_ROE             (1<<2)      // 1 a character is received and the receive FIFO was full. 0 NO overrun
#define ASCC_STATUS_RFE             (1<<3)      // 1 a framing error occurred, rxed char did not have a stop bit. 0 NO framing error
#define ASCC_STATUS_TFT             (1<<4)      // 1 the transmitter FIFO threshold condition is met.0 the transmitter FIFO condition is NOT met

#define ASCC_RX_CONTROL_RSTRX        (1<<0)     // 1 reset the receiver FIFO. 0 make receiver FIFO receive new data
#define ASCC_RX_CONTROL_FINT_DISABLED     (0x00<<1)   // 00 RX FIFO threshold interrupt disabled
#define ASCC_RX_CONTROL_FINT_NOT_EMPTY    (0x01<<1)   // 01 generate interrupt when RX FIFO is not empty
#define ASCC_RX_CONTROL_FINT_HALF_FULL    (0x02<<1)   // 10 generate interrupt when RX FIFO is at least half full
#define ASCC_RX_CONTROL_FINT_FULL         (0x03<<1)   // 11 generate interrupt when RX FIFO is full
#define ASCC_RX_CONTROL_PC_NONE   (0x00<<3)     // 00 No parity
#define ASCC_RX_CONTROL_PC_MARK   (0x01<<3)     // Mark Parity
#define ASCC_RX_CONTROL_PC_EVEN   (0x02<<3)     // Even Parity
#define ASCC_RX_CONTROL_PC_ODD    (0x03<<3)     // Odd Parity
#define ASCC_RX_CONTROL_REIE      (1<<5)        // 0 Receiver error interrupts are disabled.1 Receiver error interrupts are enabled
#define ASCC_RX_CONTROL_RXNI      (1<<6)        // 1 enable RX not idle interrupt
#define ASCC_RX_CONTROL_RID       (1<<7)        // 1 disables the receiver

#define ASCC_TX_CONTROL_RSTTX        (1<<0)     // 1 Reset Transmitter FIFO, data is discarded marked as emtpy. 0 FIFO can accept new data 
#define ASCC_TX_CONTROL_FINT_DISABLED     (0x00<<1)   // 00 TX FIFO threshold interrupt disabled
#define ASCC_TX_CONTROL_FINT_NOT_FULL     (0x01<<1)   // 01 generate interrupt when TX FIFO is not full
#define ASCC_TX_CONTROL_FINT_HALF_FULL    (0x02<<1)   // 10 generate interrupt when TX FIFO is at least half full
#define ASCC_TX_CONTROL_FINT_EMPTY        (0x03<<1)   // 11 generate interrupt when TX FIFO is empty
#define ASCC_TX_CONTROL_PC_NONE   (0x00<<3)     // 00 No parity
#define ASCC_TX_CONTROL_PC_MARK   (0x01<<3)     // Mark Parity
#define ASCC_TX_CONTROL_PC_EVEN   (0x02<<3)     // Even Parity
#define ASCC_TX_CONTROL_PC_ODD    (0x03<<3)     // Odd Parity
#define ASCC_TX_CONTROL_TOD       (1<<5)        // 1 Open Drain. 0 Normal
#define ASCC_TX_CONTROL_TXSI      (1<<6)        // 1 irq will occur when Tx shift reg is empty. 0 no irq will occur when Tx shift reg is empty

#define ASCC_MODE_CONTROL_9BM       (1<<0)      // 1 9 bit mode.
#define ASCC_MODE_CONTROL_8BM       (0<<0)      // 0 8 bit mode
#define ASCC_MODE_CONTROL_P15_P16   (0<<1)      // use P15/P16 as mux pins
#define ASCC_MODE_CONTROL_RX0_TX0   (1<<1)      // use RX1/TX1 as mux pins
#define ASCC_MODE_CONTROL_ECE       (1<<2)      // 1 Extended characters are available in 9 bit mode. 0 Extended characters are not available
#define ASCC_MODE_CONTROL_ALCO      (1<<3)      // 1 LSB of sample count toggles for each new bit transferred. 0 sample count remains constant
#define ASCC_MODE_CONTROL_SM_16     (0x00<<4)   // Selects the input sample clock to 16
#define ASCC_MODE_CONTROL_SM_17     (0x01<<4)   // Selects the input sample clock to 17
#define ASCC_MODE_CONTROL_SM_18     (0x02<<4)   // Selects the input sample clock to 18
#define ASCC_MODE_CONTROL_SM_19     (0x03<<4)   // Selects the input sample clock to 19
#define ASCC_MODE_CONTROL_SM_20     (0x04<<4)   // Selects the input sample clock to 20
#define ASCC_MODE_CONTROL_SM_21     (0x04<<4)   // Selects the input sample clock to 21
#define ASCC_MODE_CONTROL_SM_22     (0x06<<4)   // Selects the input sample clock to 22
#define ASCC_MODE_CONTROL_SM_23     (0x07<<4)   // Selects the input sample clock to 23
#define ASCC_MODE_CONTROL_SM_24     (0x08<<4)   // Selects the input sample clock to 24
#define ASCC_MODE_CONTROL_SM_25     (0x09<<4)   // Selects the input sample clock to 25
#define ASCC_MODE_CONTROL_SM_26     (0x0A<<4)   // Selects the input sample clock to 26
#define ASCC_MODE_CONTROL_SM_27     (0x0B<<4)   // Selects the input sample clock to 27
#define ASCC_MODE_CONTROL_SM_28     (0x0C<<4)   // Selects the input sample clock to 28
#define ASCC_MODE_CONTROL_SM_29     (0x0D<<4)   // Selects the input sample clock to 29
#define ASCC_MODE_CONTROL_SM_30     (0C0E<<4)   // Selects the input sample clock to 30
#define ASCC_MODE_CONTROL_SM_31     (0x0F<<4)   // Selects the input sample clock to 31

#define ASCC_TXRX_FIFO_DB9          (1<<8)      // 9TH data bit in 9 bit mode
#define ASCC_TXRX_FIFO_EXFI         (1<<9)      // 1 character is extended character in 9 bit mode. 0 character is normal character

#define ASCC_FEATURES_PWC           (0<<0)      // Pulse Width Count Value
#define ASCC_FEATURES_IRDA          (1<<8)      // 1 IrDA is enabled.on mux pins
#define ASCC_FEATURES_SEL_UART      (1<<9)      // 1 UART functions for P15/TX0 and P16/RX0 are selected

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*  Synchronous Serial Interface Registers                                  */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    SSI_DATA ;                 // SSI Data Register 
    volatile unsigned long    SSI_CONTROL_1 ;            // SSI Control 1 Register 
    volatile unsigned long    SSI_CONTROL_2 ;            // SSI Control 2 Register 
} StructSSI ;

#define SSI_CONTROL_1_SCLK2             (0<<0)  // divide system clock by 2
#define SSI_CONTROL_1_SCLK4             (1<<0)  // divide system clock by 4
#define SSI_CONTROL_1_SCLK8             (2<<0)  // divide system clock by 8
#define SSI_CONTROL_1_SCLK16            (3<<0)  // divide system clock by 16
#define SSI_CONTROL_1_SCLK32            (4<<0)  // divide system clock by 32
#define SSI_CONTROL_1_SCLK64            (5<<0)  // divide system clock by 64
#define SSI_CONTROL_1_SCLK128           (6<<0)  // divide system clock by 128
#define SSI_CONTROL_1_IE_RD_ORUN        (1<<3)  // 1 interrupt enable for read overrun
#define SSI_CONTROL_1_RD_ORUN           (1<<4)  // 1 read overrun
#define SSI_CONTROL_1_MDOF              (1<<5)  // 1 mode fault error flag
#define SSI_CONTROL_1_WCOLL             (1<<6)  // 1 a write collision occurred
#define SSI_CONTROL_1_SDONE             (1<<7)  // 1 serial transfer was complete
#define SSI_CONTROL_1_SSN               (1<<8)  // 1 pin is used for SSN
#define SSI_CONTROL_1_P22               (0<<8)  // 0 pin is used for P22
#define SSI_CONTROL_1_MDOEN             (1<<9)  // 1 output from MDOSDI pin is enabled if master. 0 pin is is disabled
#define SSI_CONTROL_1_SSNEN             (1<<10) // 1 SSN pin is enabled if master.0 pin is is disabled
#define SSI_CONTROL_1_SDOEN             (1<<11) // 1 output from MDISDO pin is enabled if slave. 0 pin is is disabled
#define SSI_CONTROL_1_SPHA_LEAD         (1<<12) // 1 data changes on leading transition of SCK. 0 data changes on the mid point transition of SCK
#define SSI_CONTROL_1_SPHA_MID          (0<<12) // 1 data changes on leading transition of SCK. 0 data changes on the mid point transition of SCK
#define SSI_CONTROL_1_SPOL_IDLE_1       (1<<13) // 1 idle state of SCK is logic 1. 0 idle state of SCK is logic 0
#define SSI_CONTROL_1_SPOL_IDLE_0       (0<<13) // 1 idle state of SCK is logic 1. 0 idle state of SCK is logic 0
#define SSI_CONTROL_1_MSTR              (1<<14) // 1 SSI is in master mode. 0 SSI is in slave mode
#define SSI_CONTROL_1_SLAVE             (0<<14) // 1 SSI is in master mode. 0 SSI is in slave mode
#define SSI_CONTROL_1_ENABLE            (1<<15) // 1 SSI is enabled. 0 SSI is disabled
#define SSI_CONTROL_1_DISABLE           (0<<15) // 1 SSI is enabled. 0 SSI is disabled

#define SSI_CONTROL_2_SSN               (1<<0)  // value of SSN
#define SSI_CONTROL_2_FCLR              (1<<1)  // fast clear
#define SSI_CONTROL_2_MDOD_DD           (0<<3)  // master data direct drive
#define SSI_CONTROL_2_MDOD_OD           (1<<3)  // master data open drain
#define SSI_CONTROL_2_SCK_DD            (0<<4)  // sck data open drain
#define SSI_CONTROL_2_SCK_OD            (1<<4)  // sck data direct drive
#define SSI_CONTROL_2_MDOSDI            (1<<5)  // master data out
#define SSI_CONTROL_2_P19               (0<<5)  // slave data in
#define SSI_CONTROL_2_MDISDO            (1<<6)  // master data in
#define SSI_CONTROL_2_P20               (0<<6)  // slave data out
#define SSI_CONTROL_2_SCK               (1<<7)  // master data in
#define SSI_CONTROL_2_P21               (0<<7)  // slave data out

/****************************************************************************/
/*  Subscriber Identity Module Interface Registers							*/
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    SIM_BAUD_RATE ;            // Baud Rate Register 
    volatile unsigned long    SIM_BAUD_COUNTER ;         // Baud Rate Counter Register 
    volatile unsigned long    SIM_FIFO_STATUS ;          // Fifo Status Register 
    volatile unsigned long    SIM_STATUS ;               // ACC Status Register 
    volatile unsigned long    SIM_RXER_CONTROL ;         // Receiver Control Register 
    volatile unsigned long    SIM_TXER_CONTROL ;         // Transmitter Control Register 
    volatile unsigned long    SIM_MODE_CONTROL ;         // Mode Control Register 
    volatile unsigned long    SIM_TXRX_FIFO ;            // Tx/Rx FIFO Register 
} StructSIM ;

#define SIM_FIFO_STATUS_RFE         (1<<0)      // 1 receiver FIFO is empty. 0 receiver FIFO is NOT empty
#define SIM_FIFO_STATUS_RFHF        (1<<1)      // 1 receiver FIFO is at least half full. 0 receiver FIFO is NOT at least half full
#define SIM_FIFO_STATUS_RFF         (1<<2)      // 1 receiver FIFO is full. 0 receiver FIFO is NOT full
#define SIM_FIFO_STATUS_TFE         (1<<3)      // 1 transmitter FIFO is empty. 0 transmitter FIFO is NOT empty
#define SIM_FIFO_STATUS_TFHF        (1<<4)      // 1 transmitter FIFO is at least half full. 0 transmitter FIFO is NOT at least half full
#define SIM_FIFO_STATUS_TFF         (1<<5)      // 1 transmitter FIFO is full. 0 transmitter FIFO is NOT full

#define SIM_STATUS_RFT              (1<<0)      // 1 receiver FIFO threshold condition is met. 0 the FIFO condition is not met
#define SIM_STATUS_RPE              (1<<1)      // 1 a parity error has occurred in a received character. 0 a parity error did not occur
#define SIM_STATUS_ROE              (1<<2)      // 1 a character is received and the receive FIFO was full. 0 NO overrun
#define SIM_STATUS_RFE              (1<<3)      // 1 a framing error occurred, rxed char did not have a stop bit. 0 NO framing error
#define SIM_STATUS_TFT              (1<<4)      // 1 the transmitter FIFO threshold condition is met.0 the transmitter FIFO condition is NOT met
#define SIM_STATUS_TPE              (1<<5)      // 1 Tx parity error occurred. 0 reset when register is read
#define	SIM_STATUS_SPE              (1<<6)      // 1 Rx parity error occurred. 0 reset when register is read
#define	SIM_STATUS_RP               (1<<7)      // 1 a retransmit has been completed.0 reset when register is read

#define SIM_RXER_CONTROL_RR         (1<<0)      // 1 reset the receiver FIFO. 0 make receiver FIFO receive new data
#define SIM_RXER_CONTROL_FICE_DISABLED     (0x00<<1)   // 00 RX FIFO threshold interrupt disabled
#define SIM_RXER_CONTROL_FICE_NOT_EMPTY    (0x01<<1)   // 01 generate interrupt when RX FIFO is not empty
#define SIM_RXER_CONTROL_FICE_HALF_FULL    (0x02<<1)   // 10 generate interrupt when RX FIFO is at least half full
#define SIM_RXER_CONTROL_FICE_FULL         (0x03<<1)   // 11 generate interrupt when RX FIFO is full
#define SIM_RXER_CONTROL_PC_NONE    (0x00<<3)   // 00 No parity
#define SIM_RXER_CONTROL_PC_MARK    (0x01<<3)   // Mark Parity
#define SIM_RXER_CONTROL_PC_EVEN    (0x02<<3)   // Even Parity
#define SIM_RXER_CONTROL_PC_ODD     (0x03<<3)   // Odd Parity
#define SIM_RXER_CONTROL_REIE       (1<<5)      // 0 Receiver error interrupts are disabled.1 Receiver error interrupts are enabled

#define SIM_TXER_CONTROL_RT         (1<<0)      // 1 Reset Transmitter FIFO, data is discarded marked as emtpy. 0 FIFO can accept new data 
#define SIM_TXER_CONTROL_FICE_DISABLED     (0x00<<1)   // 00 TX FIFO threshold interrupt disabled
#define SIM_TXER_CONTROL_FICE_NOT_FULL     (0x01<<1)   // 01 generate interrupt when TX FIFO is not full
#define SIM_TXER_CONTROL_FICE_HALF_FULL    (0x02<<1)   // 10 generate interrupt when TX FIFO is at least half full
#define SIM_TXER_CONTROL_FICE_EMPTY        (0x03<<1)   // 11 generate interrupt when TX FIFO is empty
#define SIM_TXER_CONTROL_PC_NONE    (0x00<<3)   // 00 No parity
#define SIM_TXER_CONTROL_PC_MARK    (0x01<<3)   // Mark Parity
#define SIM_TXER_CONTROL_PC_EVEN    (0x02<<3)   // Even Parity
#define SIM_TXER_CONTROL_PC_ODD     (0x03<<3)   // Odd Parity
#define SIM_TXER_CONTROL_TEIE       (1<<5)      // 1 Open Drain. 0 Normal
#define SIM_TXER_CONTROL_FRZ        (1<<6)      // 1 irq will occur when Tx shift reg is empty. 0 no irq will occur when Tx shift reg is empty

#define SIM_MODE_CONTROL_SM_SIM     (1<<0)      // 0 SIM Mode. 1 ASCC Mode
#define SIM_MODE_CONTROL_SEN        (1<<1)      // 1 SIMCLK is active. 0 SIMCLK is inactive
#define SIM_MODE_CONTROL_SSH        (1<<2)      // 1 SIMCLK is held high if inactive/disabled. 0 SIMCLK is held low if inactive/disabled
#define SIM_MODE_CONTROL_LMF        (1<<3)      // 1 MSB is rxed/txed first and LSB last, data bits inverted. 0 LSB is rxed/txed first and MSB last, data bits NOT inverted
#define SIM_MODE_CONTROL_SCS        (1<<4)      // 1 divide by 16 sample clock is selected. 0 if bit 0 is 0 then sample clock is specified by bits 7-6
#define SIM_MODE_CONTROL_CKS        (1<<5)      // 1 CKO output is enabled. 0 SIMCLK output is selected
#define SIM_MODE_CONTROL_ESC_372    (0x00<<6)   // divide by 372
#define SIM_MODE_CONTROL_ESC_32     (0x01<<6)   // divide by 32
#define SIM_MODE_CONTROL_ESC_64     (0x02<<6)   // divide by 64
#define SIM_MODE_CONTROL_ESC_96     (0x03<<6)   // divide by 96

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*  Analog to Digital Converter Registers                                   */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    ADC_CONTROL ;              // Control Register 
    volatile unsigned long    ADC_DATA ;                 // Data Register 
} StructADC ;

#define ADC_CONTROL_START           (1<<0)          // 1 start an A to D cycle. 0 set when a process completes
#define ADC_CONTROL_SCAG0           (0x00<<1)       // select channel 0
#define ADC_CONTROL_SCAG1           (0x01<<1)       // select channel 1
#define ADC_CONTROL_SCAG2           (0x02<<1)       // select channel 2
#define ADC_CONTROL_SCAG3           (0x03<<1)       // select channel 3
#define ADC_CONTROL_SCAG4           (0x04<<1)       // select channel 4
#define ADC_CONTROL_SCAG5           (0x05<<1)       // select channel 5
#define ADC_CONTROL_SF2             (0x00<<4)       // 10.6 MHz < CLK < 16.25
#define ADC_CONTROL_SF3             (0x01<<4)       // 15.99 MHz < CLK < 24.375
#define ADC_CONTROL_SF4             (0x02<<4)       // 21.32 MHz < CLK < 32.5
#define ADC_CONTROL_VREF            (0<<6)          // 0 input range is between VSS to VREF. 1 input range is between VREF and 2 VREFF
#define ADC_CONTROL_2VREF           (1<<6)          // 0 input range is between VSS to VREF. 1 input range is between VREF and 2 VREFF
#define ADC_CONTROL_STN             (1<<7)          // 1 ADC is in test mode. 0 ADC is in normal mode

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*  DMA Control Registers                                                   */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    DMAC_0_SAR ;                   // Source Address Register 
    volatile unsigned long    DMAC_0_DAR ;                   // Destination Address Register 
    volatile unsigned long    DMAC_0_TCR ;                   // Transfer Counter Register 
    volatile unsigned long    DMAC_0_CR ;                    // Control Register 
    volatile unsigned long    DMAC_1_SAR ;                   // Source Address Register 
    volatile unsigned long    DMAC_1_DAR ;                   // Destination Address Register 
    volatile unsigned long    DMAC_1_TCR ;                   // Transfer Counter Register 
    volatile unsigned long    DMAC_1_CR ;                    // Control Register 
    volatile unsigned long    DMAC_2_SAR ;                   // Source Address Register 
    volatile unsigned long    DMAC_2_DAR ;                   // Destination Address Register 
    volatile unsigned long    DMAC_2_TCR ;                   // Transfer Counter Register 
    volatile unsigned long    DMAC_2_CR ;                    // Control Register 
    volatile unsigned long    DMAC_3_SAR ;                   // Source Address Register 
    volatile unsigned long    DMAC_3_DAR ;                   // Destination Address Register 
    volatile unsigned long    DMAC_3_TCR ;                   // Transfer Counter Register 
    volatile unsigned long    DMAC_3_CR ;                    // Control Register 
    volatile unsigned long    DMAC_STATUS ;                  // DMA Status Register 
} StructDMAC ;

/****************************************************************************/
/*  DMA Test Registers                                                      */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    DMAC_ABIST_CR ;                // DMA Assisted BIST Control Register 
    volatile unsigned long    DMAC_PCRCSR ;                  // Parallel CRC Signature Register 
    volatile unsigned long    DMAC_TPR ;                     // Test Pattern Register 
    volatile unsigned long    DMAC_RESERVED0 ;               // Register 
} StructDMAC_Test ;

#define DMAC_CR_CIS         (1<<0)                  // 0 source address does not increment. 1 source address increments after each transfer
#define DMAC_CR_CID         (1<<1)                  // 0 destination address does not increment.1 destination address increments after each transfer
#define DMAC_CR_CS          (1<<2)                  // 0 DMA channel is inactive. 1 DMA channel is active

#define DMAC_CR_BYTE        (0x00<<3)               // 00 byte size transfers
#define DMAC_CR_HALFWORD    (0x01<<3)               // 01 Halfword size transfers
#define DMAC_CR_WORD        (0x02<<3)               // 10 word size transfers
#define DMAC_CR_RESERVED    (0x03<<3)               // 11 Reserved

#define DMAC_CR_MODE0       (0x00<<5)               // Memory to Memory with default of zero hold states
#define DMAC_CR_MODE1       (0x01<<5)               // ASCC to Memory with default of zero hold states
#define DMAC_CR_MODE2       (0x02<<5)               // Memory to ASCC with default of zero hold states
#define DMAC_CR_MODE3       (0x03<<5)               // Memory to SSI with minimum of 1 hold state
#define DMAC_CR_MODE4       (0x04<<5)               // Memory to Memory using EXT DRQ with default of zero hold states
#define DMAC_CR_MODE5       (0x05<<5)               // ACC/wSIM to Memory with default of zero hold states
#define DMAC_CR_MODE6       (0x06<<5)               // Memory to ACC/wSIM with default of zero hold states
#define DMAC_CR_MODE7       (0x07<<5)               // Reserved

#define DMAC_CR_CRF         (1<<8)                  // 1 a read fault occurred during a DMA transfer
#define DMAC_CR_CWF         (1<<9)                  // 1 a write fault occurred during a DMA transfer

#define DMAC_CR_CHS0_000    (0x00<<10)              // If bit 6 = 0, use 0 hold states
#define DMAC_CR_CHS0_001    (0x01<<10)              // If bit 6 = 0, use 1 hold states
#define DMAC_CR_CHS0_010    (0x02<<10)              // If bit 6 = 0, use 2 hold states
#define DMAC_CR_CHS0_011    (0x03<<10)              // If bit 6 = 0, use 3 hold states
#define DMAC_CR_CHS0_100    (0x04<<10)              // If bit 6 = 0, use 4 hold states
#define DMAC_CR_CHS0_101    (0x05<<10)              // If bit 6 = 0, use 5 hold states
#define DMAC_CR_CHS0_110    (0x06<<10)              // If bit 6 = 0, use 6 hold states
#define DMAC_CR_CHS0_111    (0x07<<10)              // If bit 6 = 0, use 7 hold states
#define DMAC_CR_CHS1_000    (0x00<<10)              // If bit 6 = 1, use 1 hold states
#define DMAC_CR_CHS1_001    (0x01<<10)              // If bit 6 = 1, use 1 hold states
#define DMAC_CR_CHS1_010    (0x02<<10)              // If bit 6 = 1, use 2 hold states
#define DMAC_CR_CHS1_011    (0x03<<10)              // If bit 6 = 1, use 3 hold states
#define DMAC_CR_CHS1_100    (0x04<<10)              // If bit 6 = 1, use 4 hold states
#define DMAC_CR_CHS1_101    (0x05<<10)              // If bit 6 = 1, use 5 hold states
#define DMAC_CR_CHS1_110    (0x06<<10)              // If bit 6 = 1, use 6 hold states
#define DMAC_CR_CHS1_111    (0x07<<10)              // If bit 6 = 1, use 7 hold states

#define DMAC_CR_CACCS_1     (0x00<<13)              // ACC1
#define DMAC_CR_CACCS_2     (0x01<<13)              // ACC2
#define DMAC_CR_CACCS_3     (0x02<<13)              // ACC3
#define DMAC_CR_CACCS_RES   (0x03<<13)              // Reserved
#define DMAC_CR_CHANNEL_MASK    (0x03<<13)          // Reserved

#define DMAC_CR_CDPC_LL_SENSE   (0x00<<15)          // low level sense
#define DMAC_CR_CDPC_HTL_EDGE   (0x01<<15)          // high to low edge detection
#define DMAC_CR_CDPC_HL_SENSE   (0x02<<15)          // high level sense
#define DMAC_CR_CDPC_LTH_EDGE   (0x03<<15)          // low to high edge detection

#define DMAC_SR_IRQ_0       (1<<0)                  // Interrupt generated by channel 0
#define DMAC_SR_IRQ_1       (1<<1)                  // Interrupt generated by channel 1
#define DMAC_SR_IRQ_2       (1<<2)                  // Interrupt generated by channel 2
#define DMAC_SR_IRQ_3       (1<<3)                  // Interrupt generated by channel 3

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*  Programmable Interrupt Control Registers                                */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    PIC_INT_STATUS ;               // Interrupt Request Status Register 
    volatile unsigned long    PIC_RESERVED0 ;                // Unused Register 
    volatile unsigned long    PIC_INT_REQ_ENAB_SET ;         // Interrupt Request Enable Set Register 
    volatile unsigned long    PIC_INT_REQ_ENAB_CLEAR ;       // Interrupt Request Enable Clear Register 
    volatile unsigned long    PIC_INT_REQ_SOFT ;             // Interrupt Request Soft Register 
    volatile unsigned long    PIC_RESERVED1 ;                // IPCR 0 Interrupt priority control Register 
    volatile unsigned long    PIC_IPCR_1 ;                   // IPCR 1 Register 
    volatile unsigned long    PIC_IPCR_2 ;                   // IPCR 2 Register 
    volatile unsigned long    PIC_IPCR_3 ;                   // IPCR 3 Register 
    volatile unsigned long    PIC_IPCR_4 ;                   // IPCR 4 Register 
    volatile unsigned long    PIC_IPCR_5 ;                   // IPCR 5 Register 
    volatile unsigned long    PIC_IPCR_6 ;                   // IPCR 6 Register 
    volatile unsigned long    PIC_IPCR_7 ;                   // IPCR 7 Register 
    volatile unsigned long    PIC_IPCR_8 ;                   // IPCR 8 Register 
    volatile unsigned long    PIC_IPCR_9 ;                   // IPCR 9 Register 
    volatile unsigned long    PIC_IPCR_10 ;                  // IPCR 10 Register 
    volatile unsigned long    PIC_IPCR_11 ;                  // IPCR 11 Register 
    volatile unsigned long    PIC_IPCR_12 ;                  // IPCR 12 Register 
    volatile unsigned long    PIC_IPCR_13 ;                  // IPCR 13 Register 
    volatile unsigned long    PIC_IPCR_14 ;                  // IPCR 14 Register 
    volatile unsigned long    PIC_IPCR_15 ;                  // IPCR 15 Register 
    volatile unsigned long    PIC_IPCR_16 ;                   // IPCR 1 Register 
    volatile unsigned long    PIC_IPCR_17 ;                   // IPCR 2 Register 
    volatile unsigned long    PIC_IPCR_18 ;                   // IPCR 3 Register 
    volatile unsigned long    PIC_IPCR_19;                   // IPCR 4 Register 
    volatile unsigned long    PIC_IPCR_20;                   // IPCR 5 Register 
    volatile unsigned long    PIC_IPCR_21 ;                   // IPCR 6 Register 
    volatile unsigned long    PIC_IPCR_22 ;                   // IPCR 7 Register 
    volatile unsigned long    PIC_IPCR_23 ;                   // IPCR 8 Register 
    volatile unsigned long    PIC_IPCR_24;                   // IPCR 9 Register 
    volatile unsigned long    PIC_IPCR_25 ;                  // IPCR 10 Register 
    volatile unsigned long    PIC_IPCR_26 ;                  // IPCR 11 Register 
    volatile unsigned long    PIC_IPCR_27 ;                  // IPCR 12 Register 
    volatile unsigned long    PIC_IPCR_28 ;                  // IPCR 13 Register 
    volatile unsigned long    PIC_IPCR_29 ;                  // IPCR 14 Register 
    volatile unsigned long    PIC_IPCR_30 ;                  // IPCR 15 Register 
    volatile unsigned long    PIC_IPCR_31 ;                  // IPCR 15 Register 
    volatile unsigned long    PIC_ISIRQ ;                    // In Service IRQ Register 
    volatile unsigned long    PIC_ISFIQ ;                    // In Service FIQ Register 
    volatile unsigned long    PIC_INT_REQ_SRC_CLEAR ;        // Interrupt Request Source Clear Register 
    volatile unsigned long    PIC_IPE_SET ;                  // Interrupt Priority Enable Set Register 
    volatile unsigned long    PIC_IPE_CLEAR ;                // Interrupt Priority Enable Clear Register 
    volatile unsigned long    PIC_EXT_INT_1CR ;              // External Interrupt 1 Control Register 
    volatile unsigned long    PIC_EXT_INT_2CR ;              // External Interrupt 2 Control Register 
    volatile unsigned long    PIC_EXT_INT_3CR ;              // External Interrupt 3 Control Register 
    volatile unsigned long    PIC_EXT_INT_4CR ;              // External Interrupt 4 Control Register 
    volatile unsigned long    PIC_EXT_INT_5CR ;              // External Interrupt 5 Control Register 
    volatile unsigned long    PIC_EXT_INT_6CR ;              // External Interrupt 4 Control Register 
    volatile unsigned long    PIC_EXT_INT_7CR ;              // External Interrupt 5 Control Register 
    volatile unsigned long    PIC_RESERVED2 ;                  // ACC Interrupt Status Register 
} StructPIC ;

// Encoded Value of Interrupt Source 
#define PIC_ISR_IIS_NOIRQ   (0x00<<0)               // NO IRQ
#define PIC_ISR_IIS_IRQ1    (0x04<<0)               // IRQ 1
#define PIC_ISR_IIS_IRQ2    (0x08<<0)               // IRQ 2
#define PIC_ISR_IIS_IRQ3    (0x0c<<0)               // IRQ 3
#define PIC_ISR_IIS_IRQ4    (0x10<<0)               // IRQ 4
#define PIC_ISR_IIS_IRQ5    (0x14<<0)               // IRQ 5
#define PIC_ISR_IIS_IRQ6    (0x18<<0)               // IRQ 6
#define PIC_ISR_IIS_IRQ7    (0x1c<<0)               // IRQ 7
#define PIC_ISR_IIS_IRQ8    (0x20<<0)               // IRQ 8
#define PIC_ISR_IIS_IRQ9    (0x24<<0)               // IRQ 9
#define PIC_ISR_IIS_IRQ10   (0x28<<0)               // IRQ 10
#define PIC_ISR_IIS_IRQ11   (0x2c<<0)               // IRQ 11
#define PIC_ISR_IIS_IRQ12   (0x30<<0)               // IRQ 12
#define PIC_ISR_IIS_IRQ13   (0x34<<0)               // IRQ 13
#define PIC_ISR_IIS_IRQ14   (0x38<<0)               // IRQ 14
#define PIC_ISR_IIS_IRQ15   (0x3c<<0)               // IRQ 15
#define PIC_ISR_IIS_IRQ16   (0x40<<0)               // IRQ 1
#define PIC_ISR_IIS_IRQ17   (0x44<<0)               // IRQ 2
#define PIC_ISR_IIS_IRQ18   (0x48<<0)               // IRQ 3
#define PIC_ISR_IIS_IRQ19   (0x4c<<0)               // IRQ 4
#define PIC_ISR_IIS_IRQ20   (0x50<<0)               // IRQ 5
#define PIC_ISR_IIS_IRQ21   (0x54<<0)               // IRQ 6
#define PIC_ISR_IIS_IRQ22   (0x58<<0)               // IRQ 7
#define PIC_ISR_IIS_IRQ23   (0x5c<<0)               // IRQ 8
#define PIC_ISR_IIS_IRQ24   (0x60<<0)               // IRQ 9
#define PIC_ISR_IIS_IRQ25   (0x64<<0)               // IRQ 10
#define PIC_ISR_IIS_IRQ26   (0x68<<0)               // IRQ 11
#define PIC_ISR_IIS_IRQ27   (0x6c<<0)               // IRQ 12
#define PIC_ISR_IIS_IRQ28   (0x70<<0)               // IRQ 13
#define PIC_ISR_IIS_IRQ29   (0x74<<0)               // IRQ 14
#define PIC_ISR_IIS_IRQ30   (0x78<<0)               // IRQ 15
#define PIC_ISR_IIS_IRQ31   (0x7c<<0)               // NO IRQ

// Priority definition for IRQs
#define PIC_IPCR_NOIRQ      (0x00<<0)               // IRQ 0
#define PIC_IPCR_IRQ1       (0x01<<0)               // IRQ 1
#define PIC_IPCR_IRQ2       (0x02<<0)               // IRQ 2
#define PIC_IPCR_IRQ3       (0x03<<0)               // IRQ 3
#define PIC_IPCR_IRQ4       (0x04<<0)               // IRQ 4
#define PIC_IPCR_IRQ5       (0x05<<0)               // IRQ 5
#define PIC_IPCR_IRQ6       (0x06<<0)               // IRQ 6
#define PIC_IPCR_IRQ7       (0x07<<0)               // IRQ 7
#define PIC_IPCR_IRQ8       (0x08<<0)               // IRQ 8
#define PIC_IPCR_IRQ9       (0x09<<0)               // IRQ 9
#define PIC_IPCR_IRQ10      (0x0A<<0)               // IRQ 10
#define PIC_IPCR_IRQ11      (0x0B<<0)               // IRQ 11
#define PIC_IPCR_IRQ12      (0x0C<<0)               // IRQ 12
#define PIC_IPCR_IRQ13      (0x0D<<0)               // IRQ 13
#define PIC_IPCR_IRQ14      (0x0E<<0)               // IRQ 14
#define PIC_IPCR_IRQ15      (0x0F<<0)               // IRQ 15
#define PIC_IPCR_IRQ16      (0x10<<0)               // IRQ 1
#define PIC_IPCR_IRQ17      (0x11<<0)               // IRQ 2
#define PIC_IPCR_IRQ18      (0x12<<0)               // IRQ 3
#define PIC_IPCR_IRQ19      (0x13<<0)               // IRQ 4
#define PIC_IPCR_IRQ20      (0x14<<0)               // IRQ 5
#define PIC_IPCR_IRQ21      (0x15<<0)               // IRQ 6
#define PIC_IPCR_IRQ22      (0x16<<0)               // IRQ 7
#define PIC_IPCR_IRQ23      (0x17<<0)               // IRQ 8
#define PIC_IPCR_IRQ24      (0x18<<0)               // IRQ 9
#define PIC_IPCR_IRQ25      (0x19<<0)               // IRQ 10
#define PIC_IPCR_IRQ26      (0x1a<<0)               // IRQ 11
#define PIC_IPCR_IRQ27      (0x1b<<0)               // IRQ 12
#define PIC_IPCR_IRQ28      (0x1c<<0)               // IRQ 13
#define PIC_IPCR_IRQ29      (0x1d<<0)               // IRQ 14
#define PIC_IPCR_IRQ30      (0x1e<<0)               // IRQ 15
#define PIC_IPCR_IRQ31      (0x1f<<0)               // IRQ 15

#define PIC_IPCR_TYP_IRQ    (0<<5)                  // 0 this IRQ is mapped to IRQ
#define PIC_IPCR_TYP_FIQ    (1<<5)                  // 1 this IRQ is mapped to FIQ

// Interrupt Request Status Register, bit is set if that IRQ has occurred
#define PIC_INT_REQ_STATUS_RES  (1<<0)                  // IRQ 0
#define PIC_INT_REQ_STATUS_I1   (1<<1)                  // IRQ 1
#define PIC_INT_REQ_STATUS_I2   (1<<2)                  // IRQ 2
#define PIC_INT_REQ_STATUS_I3   (1<<3)                  // IRQ 3
#define PIC_INT_REQ_STATUS_I4   (1<<4)                  // IRQ 4
#define PIC_INT_REQ_STATUS_I5   (1<<5)                  // IRQ 5
#define PIC_INT_REQ_STATUS_I6   (1<<6)                  // IRQ 6
#define PIC_INT_REQ_STATUS_I7   (1<<7)                  // IRQ 7
#define PIC_INT_REQ_STATUS_I8   (1<<8)                  // IRQ 8
#define PIC_INT_REQ_STATUS_I9   (1<<9)                  // IRQ 9
#define PIC_INT_REQ_STATUS_I10  (1<<10)                 // IRQ 10
#define PIC_INT_REQ_STATUS_I11  (1<<11)                 // IRQ 11
#define PIC_INT_REQ_STATUS_I12  (1<<12)                 // IRQ 12
#define PIC_INT_REQ_STATUS_I13  (1<<13)                 // IRQ 13
#define PIC_INT_REQ_STATUS_I14  (1<<14)                 // IRQ 14
#define PIC_INT_REQ_STATUS_I15  (1<<15)                 // IRQ 15
#define PIC_INT_REQ_STATUS_I16  (1<<16)                  // IRQ 1
#define PIC_INT_REQ_STATUS_I17  (1<<17)                  // IRQ 2
#define PIC_INT_REQ_STATUS_I18  (1<<18)                  // IRQ 3
#define PIC_INT_REQ_STATUS_I19  (1<<19)                  // IRQ 4
#define PIC_INT_REQ_STATUS_I20  (1<<20)                  // IRQ 5
#define PIC_INT_REQ_STATUS_I21  (1<<21)                  // IRQ 6
#define PIC_INT_REQ_STATUS_I22  (1<<22)                  // IRQ 7
#define PIC_INT_REQ_STATUS_I23  (1<<23)                  // IRQ 8
#define PIC_INT_REQ_STATUS_I24  (1<<24)                  // IRQ 9
#define PIC_INT_REQ_STATUS_I25  (1<<25)                 // IRQ 10
#define PIC_INT_REQ_STATUS_I26  (1<<26)                 // IRQ 11
#define PIC_INT_REQ_STATUS_I27  (1<<27)                 // IRQ 12
#define PIC_INT_REQ_STATUS_I28  (1<<28)                 // IRQ 13
#define PIC_INT_REQ_STATUS_I29  (1<<29)                 // IRQ 14
#define PIC_INT_REQ_STATUS_I30  (1<<30)                 // IRQ 15
#define PIC_INT_REQ_STATUS_I31  (1<<31)                 // IRQ 15

// Interrupt Request Enable Register, bit is set if that IRQ is Enabled
#define PIC_INT_REQ_ENAB_RES    (1<<0)              // IRQ 0, Bit has no effect if bit 0 in Ext Irq 1 CR = 0
#define PIC_INT_REQ_ENAB_E1     (1<<1)              // IRQ 1, Bit has no effect if bit 1 in Ext Irq 1 CR = 0
#define PIC_INT_REQ_ENAB_E2     (1<<2)              // IRQ 2, Bit has no effect if bit 2 in Ext Irq 1 CR = 0
#define PIC_INT_REQ_ENAB_E3     (1<<3)              // IRQ 3, Bit has no effect if bit 3 in Ext Irq 1 CR = 0
#define PIC_INT_REQ_ENAB_E4     (1<<4)              // IRQ 4, Bit has no effect if bit 4 in Ext Irq 1 CR = 0
#define PIC_INT_REQ_ENAB_E5     (1<<5)              // IRQ 5, Bit has no effect if bit 5 in Ext Irq 1 CR = 0
#define PIC_INT_REQ_ENAB_E6     (1<<6)              // IRQ 6
#define PIC_INT_REQ_ENAB_E7     (1<<7)              // IRQ 7
#define PIC_INT_REQ_ENAB_E8     (1<<8)              // IRQ 8
#define PIC_INT_REQ_ENAB_E9     (1<<9)              // IRQ 9
#define PIC_INT_REQ_ENAB_E10    (1<<10)             // IRQ 10
#define PIC_INT_REQ_ENAB_E11    (1<<11)             // IRQ 11
#define PIC_INT_REQ_ENAB_E12    (1<<12)             // IRQ 12
#define PIC_INT_REQ_ENAB_E13    (1<<13)             // IRQ 13
#define PIC_INT_REQ_ENAB_E14    (1<<14)             // IRQ 14
#define PIC_INT_REQ_ENAB_E15    (1<<15)             // IRQ 15
#define PIC_INT_REQ_ENAB_E16    (1<<16)              // IRQ 1, Bit has no effect if bit 1 in Ext Irq 1 CR = 0
#define PIC_INT_REQ_ENAB_E17    (1<<17)              // IRQ 2, Bit has no effect if bit 2 in Ext Irq 1 CR = 0
#define PIC_INT_REQ_ENAB_E18    (1<<18)              // IRQ 3, Bit has no effect if bit 3 in Ext Irq 1 CR = 0
#define PIC_INT_REQ_ENAB_E19    (1<<19)              // IRQ 4, Bit has no effect if bit 4 in Ext Irq 1 CR = 0
#define PIC_INT_REQ_ENAB_E20    (1<<20)              // IRQ 5, Bit has no effect if bit 5 in Ext Irq 1 CR = 0
#define PIC_INT_REQ_ENAB_E21    (1<<21)              // IRQ 6
#define PIC_INT_REQ_ENAB_E22    (1<<22)              // IRQ 7
#define PIC_INT_REQ_ENAB_E23    (1<<23)              // IRQ 8
#define PIC_INT_REQ_ENAB_E24    (1<<24)              // IRQ 9
#define PIC_INT_REQ_ENAB_E25    (1<<25)             // IRQ 10
#define PIC_INT_REQ_ENAB_E26    (1<<26)             // IRQ 11
#define PIC_INT_REQ_ENAB_E27    (1<<27)             // IRQ 12
#define PIC_INT_REQ_ENAB_E28    (1<<28)             // IRQ 13
#define PIC_INT_REQ_ENAB_E29    (1<<29)             // IRQ 14
#define PIC_INT_REQ_ENAB_E30    (1<<30)             // IRQ 15
#define PIC_INT_REQ_ENAB_E31    (1<<31)             // IRQ 15
#define PIC_INT_REQ_ENAB_ALL_EXT_IRQS (PIC_INT_REQ_ENAB_E1 | PIC_INT_REQ_ENAB_E2 | PIC_INT_REQ_ENAB_E3 | PIC_INT_REQ_ENAB_E4 |PIC_INT_REQ_ENAB_E5)

// Interrupt Priority Enable Register, bit is set if that IRQ is Enabled
#define PIC_IPE_E0              (1<<0)              // IRQ 0
#define PIC_IPE_E1              (1<<1)              // IRQ 1
#define PIC_IPE_E2              (1<<2)              // IRQ 2
#define PIC_IPE_E3              (1<<3)              // IRQ 3
#define PIC_IPE_E4              (1<<4)              // IRQ 4
#define PIC_IPE_E5              (1<<5)              // IRQ 5
#define PIC_IPE_E6              (1<<6)              // IRQ 6
#define PIC_IPE_E7              (1<<7)              // IRQ 7
#define PIC_IPE_E8              (1<<8)              // IRQ 8
#define PIC_IPE_E9              (1<<9)              // IRQ 9
#define PIC_IPE_E10             (1<<10)             // IRQ 10
#define PIC_IPE_E11             (1<<11)             // IRQ 11
#define PIC_IPE_E12             (1<<12)             // IRQ 12
#define PIC_IPE_E13             (1<<13)             // IRQ 13
#define PIC_IPE_E14             (1<<14)             // IRQ 14
#define PIC_IPE_E15             (1<<15)             // IRQ 15
#define PIC_IPE_E16             (1<<16)              // IRQ 0
#define PIC_IPE_E17             (1<<17)              // IRQ 1
#define PIC_IPE_E18             (1<<18)              // IRQ 2
#define PIC_IPE_E19             (1<<19)              // IRQ 3
#define PIC_IPE_E20             (1<<20)              // IRQ 4
#define PIC_IPE_E21             (1<<21)              // IRQ 5
#define PIC_IPE_E22             (1<<22)              // IRQ 6
#define PIC_IPE_E23             (1<<23              // IRQ 7
#define PIC_IPE_E24             (1<<24)              // IRQ 8
#define PIC_IPE_E25             (1<<25)              // IRQ 9
#define PIC_IPE_E26             (1<<26)             // IRQ 10
#define PIC_IPE_E27             (1<<27)             // IRQ 11
#define PIC_IPE_E28             (1<<28)             // IRQ 12
#define PIC_IPE_E29             (1<<29)             // IRQ 13
#define PIC_IPE_E30             (1<<30)             // IRQ 14
#define PIC_IPE_E31             (1<<31)             // IRQ 15

// Interrupt Request Source Clear Register, setting bit clears that IRQ 
#define PIC_INT_REQ_SRC_CLEAR_RES             (1<<0)              // IRQ 0
#define PIC_INT_REQ_SRC_CLEAR_C1              (1<<1)              // IRQ 1
#define PIC_INT_REQ_SRC_CLEAR_C2              (1<<2)              // IRQ 2
#define PIC_INT_REQ_SRC_CLEAR_C3              (1<<3)              // IRQ 3
#define PIC_INT_REQ_SRC_CLEAR_C4              (1<<4)              // IRQ 4
#define PIC_INT_REQ_SRC_CLEAR_C5              (1<<5)              // IRQ 5
#define PIC_INT_REQ_SRC_CLEAR_C6              (1<<6)              // IRQ 6
#define PIC_INT_REQ_SRC_CLEAR_C7              (1<<7)              // IRQ 7
#define PIC_INT_REQ_SRC_CLEAR_C8              (1<<8)              // IRQ 8
#define PIC_INT_REQ_SRC_CLEAR_C9              (1<<9)              // IRQ 9
#define PIC_INT_REQ_SRC_CLEAR_C10             (1<<10)             // IRQ 10
#define PIC_INT_REQ_SRC_CLEAR_C11             (1<<11)             // IRQ 11
#define PIC_INT_REQ_SRC_CLEAR_C12             (1<<12)             // IRQ 12
#define PIC_INT_REQ_SRC_CLEAR_C13             (1<<13)             // IRQ 13
#define PIC_INT_REQ_SRC_CLEAR_C14             (1<<14)             // IRQ 14
#define PIC_INT_REQ_SRC_CLEAR_C15             (1<<15)             // IRQ 15
#define PIC_INT_REQ_SRC_CLEAR_C16             (1<<16)              // IRQ 0
#define PIC_INT_REQ_SRC_CLEAR_C17             (1<<17)              // IRQ 1
#define PIC_INT_REQ_SRC_CLEAR_C18             (1<<18)              // IRQ 2
#define PIC_INT_REQ_SRC_CLEAR_C19             (1<<19)              // IRQ 3
#define PIC_INT_REQ_SRC_CLEAR_C20             (1<<20)              // IRQ 4
#define PIC_INT_REQ_SRC_CLEAR_C21             (1<<21)              // IRQ 5
#define PIC_INT_REQ_SRC_CLEAR_C22             (1<<22)              // IRQ 6
#define PIC_INT_REQ_SRC_CLEAR_C23             (1<<23              // IRQ 7
#define PIC_INT_REQ_SRC_CLEAR_C24             (1<<24)              // IRQ 8
#define PIC_INT_REQ_SRC_CLEAR_C25             (1<<25)              // IRQ 9
#define PIC_INT_REQ_SRC_CLEAR_C26             (1<<26)             // IRQ 10
#define PIC_INT_REQ_SRC_CLEAR_C27             (1<<27)             // IRQ 11
#define PIC_INT_REQ_SRC_CLEAR_C28             (1<<28)             // IRQ 12
#define PIC_INT_REQ_SRC_CLEAR_C29             (1<<29)             // IRQ 13
#define PIC_INT_REQ_SRC_CLEAR_C30             (1<<30)             // IRQ 14
#define PIC_INT_REQ_SRC_CLEAR_C31             (1<<31)             // IRQ 15

// External Interrupt Control Registers
#define PIC_EXT_INT_ENA_OFF     (0<<0)              // 0 this external interrupt is disabled
#define PIC_EXT_INT_ENA_ON      (1<<0)              // 1 this external interrupt is enabled
#define PIC_EXT_INT_SEN_LEVEL   (0<<1)              // 0 this interrupt is level sensitive
#define PIC_EXT_INT_SEN_EDGE    (1<<1)              // 1 this interrupt is edge sensitive
#define PIC_EXT_INT_POL_LOW     (0<<2)              // 0 detects a high to low transition or low level
#define PIC_EXT_INT_POL_HIGH    (1<<2)              // 1 detects a low to high transition or high level
#define PIC_EXT_INT_ASY_SYNC    (0<<3)              // 0 this external interrupt is synchronous
#define PIC_EXT_INT_ASY_ASYNC   (1<<3)              // 1 this external interrupt is Asynchronous
#define PIC_EXT_INT_DAT         (1<<4)              // A read only copy of hte data on this IRQ pin delayed by three clock cycles

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*  Real Time Clock Control Registers                                       */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    RTC_CONTROL ;                  // Real Time Clock Control Register 
    volatile unsigned long    RTC_SECONDS_ALARM ;            // Alarm match value Register 
    volatile unsigned long    RTC_SECONDS_COUNTER ;          // Secounds counter used for match 
    volatile unsigned long    RTC_DIVIDER ;                  // Divider valueRegister 
} StructRTC ;

#define RTC_CONTROL_X1RTC   (1<<0)          // 1 clock is from crystal osc or X1RTC pin. 0 input clock is system clock
#define RTC_CONTROL_SYS     (0<<0)          // 1 clock is from crystal osc or X1RTC pin. 0 input clock is system clock
#define RTC_CONTROL_IE      (1<<1)          // 1 divider register will increment.0 divider register will decrement
#define RTC_CONTROL_AI      (1<<2)          // 1 an interrupt occurred due to seconds alarm.0 seconds alarm did not occur.
#define RTC_CONTROL_IWI     (1<<3)          // 1 a write operation on seconds counter or divider register. occurred during an update cycle when the divider reg was enabled.0 an illegal write did not occur
#define RTC_CONTROL_BYPASS  (1<<4)          // 1 crystal oscillator is disabled and X1RTC is used as clock.0 crystal oscillator is enabled
#define RTC_CONTROL_OCS32_TRI  (0x00<<5)       // OSC32 Output is Tri State
#define RTC_CONTROL_OCS32_RTC  (0x01<<5)       // OSC32 Output is RTC Clock
#define RTC_CONTROL_OCS32_TRI1  (0x02<<5)      // if BSW = 0, OSC32 Output is Tri State
#define RTC_CONTROL_OCS32_RTC2  (0x03<<5)      // if BSW = 1, OSC32 Output is RTC Clock
#define RTC_CONTROL_ENA     (1<<7)          // 1 analog part of crystal osc is active and using current.0 analog part of cyrstal osc is inactive and using NO current

#define RTC_SECONDS_ALARM_STABLE    (1<<31) // 1 an update cycle was in progress when read access occurred.0 returned value was stable

#define RTC_SECONDS_COUNTER_STABLE  (1<<31) // 1 an update cycle was in progress when read access occurred.0 returned value was stable

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*  EMI External Memroy Interface Register Definitions                      */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    EMI_CSROME_CONFIG ;    // External ROM CS Config Register 
    volatile unsigned long    EMI_CSRAME_CONFIG ;    // External RAM CS Config Register 
    volatile unsigned long    EMI_CS0_CONFIG ;       // External CS0 Config Register 
    volatile unsigned long    EMI_CS1_CONFIG ;       // External CS1 Config Register 
    volatile unsigned long    EMI_CS2_CONFIG ;       // External CS2 Config Register 
    volatile unsigned long    EMI_CS3_CONFIG ;       // External CS3 Config Register 
    volatile unsigned long    EMI_CS4_CONFIG ;       // External CS4 Config Register 
    volatile unsigned long    EMI_CS5_CONFIG ;       // External CS5 Config Register 
    volatile unsigned long    EMI_OPTIONS_STATUS;    // External CS0 Config Register 
    volatile unsigned long    EMI_CSROME_BASE ;      // External ROM Base Register 
    volatile unsigned long    EMI_CSRAME_BASE ;      // External RAM Base Register 
    volatile unsigned long    EMI_CS0_BASE ;         // External Base CS0 Register 
    volatile unsigned long    EMI_CS1_BASE ;         // External Base CS1 Register 
    volatile unsigned long    EMI_CS2_BASE ;         // External Base CS2 Register 
    volatile unsigned long    EMI_CS3_BASE ;         // External Base CS3 Register 
    volatile unsigned long    EMI_CS4_BASE ;         // External Base CS4 Register 
    volatile unsigned long    EMI_CS5_BASE ;         // External Base CS5 Register 
    volatile unsigned long    EMI_CSRAMI_BASE ;      // Internal RAM Base Register 
    volatile unsigned long    EMI_CSROMI_BASE ;      // Internal ROM Base Register 
} StructEMI ;

// Wait State Enable 
#define EMI_CS_CONFIG_WS_0      (0x00<<0)   // 0 wait states
#define EMI_CS_CONFIG_WS_1      (0x01<<0)   // 1 wait states
#define EMI_CS_CONFIG_WS_2      (0x02<<0)   // 2 wait states
#define EMI_CS_CONFIG_WS_3      (0x03<<0)   // 3 wait states
#define EMI_CS_CONFIG_WS_4      (0x04<<0)   // 4 wait states
#define EMI_CS_CONFIG_WS_5      (0x05<<0)   // 5 wait states
#define EMI_CS_CONFIG_WS_6      (0x06<<0)   // 6 wait states
#define EMI_CS_CONFIG_WS_7      (0x07<<0)   // 7 wait states
#define EMI_CS_CONFIG_WS_8      (0x08<<0)   // 8 wait states
#define EMI_CS_CONFIG_WS_9      (0x09<<0)   // 9 wait states
#define EMI_CS_CONFIG_WS_10     (0x0A<<0)   // 10 wait states
#define EMI_CS_CONFIG_WS_11     (0x0B<<0)   // 11 wait states
#define EMI_CS_CONFIG_WS_12     (0x0C<<0)   // 12 wait states
#define EMI_CS_CONFIG_WS_13     (0x0D<<0)   // 13 wait states
#define EMI_CS_CONFIG_WS_14     (0x0E<<0)   // 14 wait states
#define EMI_CS_CONFIG_WS_15     (0x0F<<0)   // 15 wait states

// hold State Enable 
#define EMI_CS_CONFIG_HS_0      (0x00<<4)   // 0 hold states
#define EMI_CS_CONFIG_HS_1      (0x01<<4)   // 1 hold states
#define EMI_CS_CONFIG_HS_2      (0x02<<4)   // 2 hold states
#define EMI_CS_CONFIG_HS_3      (0x03<<4)   // 3 hold states

// Bus Size 
#define EMI_CS_CONFIG_BS_16     (1<<6)      // device supports 16 bit transfer
#define EMI_CS_CONFIG_BS_8      (0<<6)      // device supports 8 bit transfer

// Setup Cycle 
#define EMI_CS_CONFIG_SET_ON    (1<<7)      // extra cycle added to setup time
#define EMI_CS_CONFIG_SET_OFF   (0<<7)      // NO extra cycle added to setup time

// Use Wait pin 
#define EMI_CS_CONFIG_WT_ON     (1<<8)      // allows WAITN pin to extend wait time
#define EMI_CS_CONFIG_WT_OFF    (0<<8)      // WAITN pin is not used

// Burst Mode 
#define EMI_CS_CONFIG_BM_ON     (1<<9)      // intermediate setup cycles suppreseed between accesses
#define EMI_CS_CONFIG_BM_OFF    (0<<9)      // not supressed

// Hold disable - disables the hold states between access in multicycle read transactions 
#define EMI_CS_CONFIG_HD_ON     (1<<10)     // hold states suppressed
#define EMI_CS_CONFIG_HD_OFF    (0<<10)     // not supressed

// Polarity - Sets the polarity for CS2, CS3, CS4 and CS5. Set this before CS is enabled 
#define EMI_CS_CONFIG_POL_HI    (1<<11)     // chip select is active high
#define EMI_CS_CONFIG_POL_LO    (0<<11)     // chip select is active low

// Enable - Enables CS2, CS3, CS4 and CS5. Others are enabled by having base register set 
#define EMI_CS_CONFIG_ENABLE    (1<<12)     // enable this chip select, PPI can not use this bit
#define EMI_CS_CONFIG_DISABLE   (0<<12)     // disable this chip select, let PPI use this bit

// Use Byte Enables - used for devices which are 16 bits and use byte enables. Must be set	
// if a device wants byte writes
#define EMI_CS_CONFIG_UBE_ON    (1<<13)     // allow byte enables for device selected by this CS
#define EMI_CS_CONFIG_UBE_OFF   (0<<13)     // disallow byte enables for device selected by this CS

// Block Wait State Enable 
#define EMI_CS_CONFIG_BWT_0      (0x00<<14) // 0 Block Wait states
#define EMI_CS_CONFIG_BWT_1      (0x01<<14) // 1 Block Wait states
#define EMI_CS_CONFIG_BWT_2      (0x02<<14) // 2 Block Wait states
#define EMI_CS_CONFIG_BWT_3      (0x03<<14) // 3 Block Wait states

// shadow mode select 
#define EMI_OPTIONS_STATUS_SHADON  (1<<0)   // shadow on
#define EMI_OPTIONS_STATUS_SHADOFF (0<<0)   // shadow off

// A22 select 
#define EMI_OPTIONS_STATUS_A22ENAB (1<<1)   // USE A22

// A23 select 
#define EMI_OPTIONS_STATUS_A23ENAB (1<<2)   // USE A23

// A24 select 
#define EMI_OPTIONS_STATUS_A24ENAB (1<<3)   // USE A24

// A25 select 
#define EMI_OPTIONS_STATUS_A25ENAB (1<<4)   // USE A25

// P34/OEN select 
#define EMI_OPTIONS_STATUS_OEN  (1<<5)      // USE P4/OEN as OEN
#define EMI_OPTIONS_STATUS_P4  (0<<5)       // USE P4/OEN as P4

// P35/WAITN select 
#define EMI_OPTIONS_STATUS_WAITN (1<<6)     // USE P5/WAITN as WAITN
#define EMI_OPTIONS_STATUS_P5   (0<<6)      // USE P5/WAITN as P5

// P36/BE1 select 
#define EMI_OPTIONS_STATUS_BE1   (1<<7)      // USE P6/BE1 as BE1
#define EMI_OPTIONS_STATUS_P6   (0<<7)       // USE P6/BE1 as P6

/*  Byte Enable Conflict - Indicates that a byte write was made to a16 bit	
    device that did not have byte enable. This bit is cleared by writing to this register
*/
#define EMI_OPTIONS_STATUS_BWE  (1<<11)     // if set an error occurred

/*  Peripheral Sub-Word Byte: Indicates that a write access lf less then a
    word was made to a peripheral. This bit is cleared by writing to this register.
*/
#define EMI_OPTIONS_STATUS_PWE  (1<<12)     // if set an error occurred

// Alignment error: indicates that a request has been made to an address that does not match the request size.
#define EMI_OPTIONS_STATUS_AE   (1<<13)     // if set an error occurred

/* Map Error: Indicates that an error is made programming the chip select	*/
/* base registers that caused either no chip select activation for a memory	*/
/* reuest or more than 1 chip select activation.							*/
#define EMI_OPTIONS_STATUS_ME   (1<<14)     // if set an error occurred

// trace mode
#define EMI_OPTIONS_STATUS_TM_ON  (1<<15)   // decoder adds extra cycle to every mem request
#define EMI_OPTIONS_STATUS_TM_OFF (0<<15)   // normal memory request processing

// WAITN Polarity 
#define EMI_OPTIONS_STATUS_WP_1 (1<<16)     // when WAITN pin is HIGH wait states are inserted 
#define EMI_OPTIONS_STATUS_WP_0 (0<<16)     // when WAITN pin is LOW wait states are inserted

// Base register block size 
#define EMI_BASE_SIZE_0         (0x00<<0)   // DISABLED block size,
#define EMI_BASE_SIZE_4K        (0x01<<0)   // 2K   bytes, Match A31:A12
#define EMI_BASE_SIZE_8K        (0x02<<0)   // 4K   bytes, Match A31:A13
#define EMI_BASE_SIZE_16K       (0x03<<0)   // 8K   bytes, Match A31:A14
#define EMI_BASE_SIZE_32K       (0x04<<0)   // 16K  bytes, Match A31:A15
#define EMI_BASE_SIZE_64K       (0x05<<0)   // 32K  bytes, Match A31:A16
#define EMI_BASE_SIZE_128K      (0x06<<0)   // 64K  bytes, Match A31:A17
#define EMI_BASE_SIZE_256K      (0x07<<0)   // 128K bytes, Match A31:A18
#define EMI_BASE_SIZE_512K      (0x08<<0)   // 256K bytes, Match A31:A19
#define EMI_BASE_SIZE_1M        (0x09<<0)   // 512K bytes, Match A31:A20
#define EMI_BASE_SIZE_2M        (0x0A<<0)   // 1M   bytes, Match A31:A21
#define EMI_BASE_SIZE_4M        (0x0B<<0)   // 2M   bytes, Match A31:A22
#define EMI_BASE_SIZE_8M        (0x0C<<0)   // 4M   bytes, Match A31:A23
#define EMI_BASE_SIZE_16M       (0x0D<<0)   // 8M   bytes, Match A31:A24
#define EMI_BASE_SIZE_32M       (0x0E<<0)   // 16M  bytes, Match A31:A25
#define EMI_BASE_SIZE_64M       (0x0F<<0)   // 16M  bytes, Match A31:A26


// these are bit shifted values to create base address
#define EMI_BASE_0M_S2M         (0x00000000 >> 8)
#define EMI_BASE_2M_S2M         (0x00200000 >> 8)  // start at 2M with 2M size
#define EMI_BASE_4M_S2M         (0x00400000 >> 8)  // start at 4M with 2M size
#define EMI_BASE_6M_S2M         (0x00600000 >> 8)  // start at 6M with 2M size
#define EMI_BASE_7M_S2M         (0x00700000 >> 8)  // start at 7M with 2M size


/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*  ICP (Interprocessor Communications Port) Interface Registers                             */
/****************************************************************************/
typedef struct 
{
    volatile unsigned long    ICP_DCCON ;            // ARM controlled control register 
    volatile unsigned long    ICP_DCSTAT ;           // ARM controlled status register 
} StructICP ;
#define ICP_DCCON_DIRQ0 (0x01<<0)           // IRQ req to DSP,
#define ICP_DCCON_DIRQ1 (0x01<<1)           // IRQ req to DSP,,
#define ICP_DCCON_DIRQ2 (0x01<<2)           // IRQ req to DSP,,
#define ICP_DCCON_DIRQ3 (0x01<<3)           // IRQ req to DSP,,
#define ICP_DCCON_DIRQ4 (0x01<<4)           // IRQ req to DSP,,
#define ICP_DCCON_DIRQ5 (0x01<<5)           // IRQ req to DSP,,
#define ICP_DCCON_DIRQ6 (0x01<<6)           // IRQ req to DSP,,
#define ICP_DCCON_DIRQ7 (0x01<<7)           // IRQ req to DSP,,
#define ICP_DCCON_DIRQ_ALL (0xFF<<0)        // IRQ req to DSP,,

#define ICP_DCCON_DRESETN (0x01<<8)         // 0 = hold reset to DSP,,

#define ICP_DCCON_DBOOTSHARED (0x01<<9)     // 1 = DSP will boot from shared memory
#define ICP_DCCON_DBOOTROM (0x00<<9)        // 0 = DSP will boot from internal ROM

#define ICP_DCCON_ACSIG0 (0x01<<10)         // handshake signal from ARM to DSP
#define ICP_DCCON_ACSIG1 (0x01<<11)         // handshake signal from ARM to DSP
#define ICP_DCCON_ACSIG2 (0x01<<12)         // handshake signal from ARM to DSP
#define ICP_DCCON_ACSIG3 (0x01<<13)         // handshake signal from ARM to DSP
#define ICP_DCCON_ACSIG4 (0x01<<14)         // handshake signal from ARM to DSP
#define ICP_DCCON_ACSIG5 (0x01<<15)         // handshake signal from ARM to DSP

#define ICP_DCSTAT_AIRQ0 (0x01<<0)           // IRQ req to DSP,
#define ICP_DCSTAT_AIRQ1 (0x01<<1)           // IRQ req to DSP,,
#define ICP_DCSTAT_AIRQ2 (0x01<<2)           // IRQ req to DSP,,
#define ICP_DCSTAT_AIRQ3 (0x01<<3)           // IRQ req to DSP,,
#define ICP_DCSTAT_AIRQ4 (0x01<<4)           // IRQ req to DSP,,
#define ICP_DCSTAT_AIRQ5 (0x01<<5)           // IRQ req to DSP,,
#define ICP_DCSTAT_AIRQ6 (0x01<<6)           // IRQ req to DSP,,
#define ICP_DCSTAT_AIRQ7 (0x01<<7)           // IRQ req to DSP,,

  
/******************************************************************************
 * Description: Parallel Peripheral Interface,
 *              see section 5.3 of the Trident data sheet
 * The following PA lines are used in this application
 * Note: We are not using the multiplex features of the chip.
 */
 
#define PPI_PA25	0x02000000		/* led 1 */
#define PPI_PA26	0x04000000		/* led 2 */
#define PPI_PA27	0x08000000		/* led 3 */

#define PPI_PA29	0x20000000		/* remote push-button */
#define PPI_PA30	0x40000000		/* jumper jp2 */


/*
 * Note: The LED defines follow the label on the pcb
 */
#define LED_USR1	PPI_PA25
#define LED_USR2	PPI_PA26
#define LED_USR3	PPI_PA27


#define	PPI_ALL_LEDS	(LED_USR1 | LED_USR2 | LED_USR3)


#define REMOTE_PUSH_BUTTON	PPI_PA29
#define JUMPER_JP2          PPI_PA30


#if defined(YS)
// Maui specific stuff / yellow sub

//==========================================================================
//					MOSQUITO Serial Port Defines (16550 compatible)
//==========================================================================
typedef struct _16550 {
	union {
		volatile unsigned char rbr;	// read-only RBR, when DLAB = 0
		volatile unsigned char thr;	// write-only THR, when DLAB = 0
		volatile unsigned char dll;	// r/w baud div latch least sig byte when DLAB=1
	} a0;
	union {
		volatile unsigned char ier;	// r/w IER when DLAB = 0
		volatile unsigned char dlm;	// r/w baud div latch most sig byte when DLAB=1
	} a1;
	union {
		volatile unsigned char iir;	// read-only IIR
		volatile unsigned char fcr;	// write-only FCR
	} a2;
	volatile unsigned char lcr;
	volatile unsigned char mcr;
	volatile unsigned char lsr;
	volatile unsigned char msr;
	volatile unsigned char scr;
} Struct16550;

#define	MOS_BASE  (APO_BASE + (4*1024))	// Mosquito registers

#endif // YS

#elif defined(OCM)

// Move the EASCI and other OCM-specific defs from arm_glob.h to here

#endif

#endif // __OCM__
