/*name and version number:@(#)llglob_d.h	1.580*/
/*date of get: 		  01/10/01 16:57:54*/
/*date of delta:	  01/09/01 09:49:23*/
/****************************************************************
File :	llglob_d.h
Description :
	Contains #defines, functions, variables global to the system.
*****************************************************************/
#ifndef __LL_GLOB_H__
#define __LL_GLOB_H__

#ifdef MODEM_Z80 		// makes zgo.exe happy

//#define CS_MODEM  
//#define COPERNICUS
//#define INT_MODEM
#define EXT_MODEM
//#define PCMCIA_MODEM
//#define USB_MODEM

#define VENUS				// DSP processor type

#define ROM					// select Mode:
//#define EMULATION

#if defined( ROM ) && !defined( CS_MODEM )

//#define ROM_FLASH	16		// AMD29F002B (ROM Flash Loader in 16K sector)
//#define ROM_2MEG			// 2 Meg Rom (zgo puts 2M on command line)
//#define ROM_FLASH	64		// AMD29F040 (ROM Flash Loader in 64K sector)
//#define ROM_4MEG			// 4 Meg Rom (opt: zgo puts 4M on command line)
//#define FAST_ROM			// for 55 nsec (2 wait state) ROM
#if defined(ROM_FLASH)
#if (ROM_FLASH == 16)
//#define ATMEL			// Atmel 49Fxxx Flash ROM (requires 16K ROM FLASH)
//#define ATMEL_NOBOOT	// Atmel AT49F020 w/o boot block
// note: ATMEL_NOBOOT can only be defined if ATMEL is defined.
#endif	// ROM_FLASH == 16
#endif	// ROM_FLASH
#endif	// ROM && !CS_MODEM
#endif	// MODEM_Z80

//#define VENUS_AT_CS

#if !defined(MODEM_Z80)		// generic defines for non-Z80


#define WINMODEM			//pwwlkl
typedef unsigned long uint_32;
typedef unsigned char byte;

//------------------------------------------
// Uncomment to use packed struct instead of arrays
// for V.42bis dictionary nodes
//------------------------------------------
# define V42BIS_PACKED_STRUCT


// Uncomment to get >2048 code words
//#define V42BIS_LARGE_CODEWORD

# define VENUS
# define VERSION_STR		__DATE__
# define non_banked
# define address_24_of(a) a
# define HDLC_FRAMES_BY_REFERENCE
# if defined(HDLC_FRAMES_BY_REFERENCE)
//#  define MNP_OFRAMES_BY_REFERENCE
# endif
# define Z80_DEBUG_PRINT
# define TEST_COMMANDS
  typedef unsigned char byte ;
  typedef unsigned short word ;
  typedef unsigned long dword ;
  typedef unsigned char BOOL ;
  extern void x_debug_msg ( char *message ) ;
  extern void ddputs( char* ) ;
  extern void sendDumbChar( byte ) ;
  extern void sendHexDigit( byte ) ;
  extern void sendHexByte( byte ) ;
  extern void sendDecByte( byte ) ;
  extern void sendHexWord( word ) ;
  extern void sendCrLf( void ) ;
  extern void enableDumbPort( void ) ;
  extern void fatal_error( char * ) ;
# define ddputs_24_nnl(lp) ddputs_nnl((char *)lp)
# define DP_PUTS(x)		ddputs_nnl(x)
# define dp_puts(x)		ddputs_nnl(x)
# if !defined(MODEM_ARM)
#  define COMPRESS_TABLES		// Use compressed DSP code for downloads
#  define DRAGNET				// Apollo device with Venus ROM code
#  define DRAGNET2				// has 16k DPRAM - no external RAM  pwwlkl
#  define HOMOL
#  define VOICE
#  define CALLER_ID
//#  define V80
#  define V25TER				// V.25ter commands
#  define V253					// V.253 commands
#  define VCE_FAX_STR		"win "
#  define LINE_PROBING_RESULTS
#  define LINE_PROBING_SAMPLES 49
   extern byte ddputs_nnl( char * );
# endif // !MODEM_ARM
#endif // !MODEM_Z80

#if defined(CS_4)
# include "sa_cnfig.h"
#elif defined(MODEM_ARM)
# include "arm_cnfg.h"
#else
# define PM_PRINTING_ON(x)
# define PM_PRINTING_OFF()
# if defined(MODEM_Z80)
#  define _INT_DISABLE() disable_interrupt()
#  define _INT_ENABLE()	enable_interrupt()
# else
#  define _INT_DISABLE()
#  define _INT_ENABLE()
# endif
#endif	// !CS_4

/****************************************************************
	DSP, hardware, feature, etc. dependent defines
 Environment defines:
	MODEM_Z80 - Z80, including VENUS
 DSP version defines:
 	VENUS - venus specific code
 Modem features:
	VOICE - TAD and Speaker Phone
	NO_MNP5 - MNP5 not included
	FLASH_LOADER - Flash loader for z80 build
	V80 - Includes V.80 (V.ib) sync commands, V.25 Annex A, V.8'
	CLASS2_FAX - Class 2 FAX
	TCP_IP - TCP/IP stack for Internet
 Homologation:
	HOMOL: Homologation & blacklisting
	EEPROM_X24C02: X24C02 serial eprom used DAA (for country code) 
	TEST_COMMANDS: All AT%T commands supported, else only AT%T19 and
				 AT%T20 supported.
    COUNTRY_BLOCKING: supports ability to block specific country ids
 Hardware:
	FULLWAVERING : Fullwave ring detection
	ROM_2MEG   	: 2 Meg Rom for Z80
	WAIT_STATE_TWO : Wait states for Z80 rom & ram
*****************************************************************/

//#define V34ONLY
#define DATAFAXONLY 0
#define DATA_FAX_TAM 1			// 1 - no speakerphone

// Removal of COPERNICUS was causing build failures.  Please do NOT remove.
#if defined(VENUS_AT_CS) || defined(CS_MODEM) || defined(COPERNICUS)
  #define VPCM_SERVER
  #define CS_CALLBACK   
  #define K56FLEX
  //#define CS_V110			// V110 rate adaption
  //#define CS_ETC
#else
  #define CS_CALLBACK   
  #if !defined(V34ONLY)
	# define VPCM_CLIENT				// V.90 client
//	# define V92						//pwwlkl
  #endif
#endif	

#if !defined(V34ONLY)
# define V8BIS
# if !defined( CS_4 ) && defined(V92)
#  define V92_MODEM_ON_HOLD			// v.92 modem on hold on call waiting
# endif	// !CS_4
#endif // !V34ONLY

#if !defined(DRAGNET) && !defined(DRAGNET2)	// ????
# define VENUS_1675		// Include workarounds for 1675/1673v7
# define VENUS2			// VENUS2 aka 1673v8
# if defined(VENUS2)
//#  define Z80_USE_DPLL	// Use digital PLL for clock - freq is set by
						// "M_N_COEFF" in z80util.c for various RAM/ROM speeds
# endif // VENUS2
#endif // !DRAGNET

//------------------------------------------
// Uncomment to enable V44 code + data
//------------------------------------------
//# define V44				//pwwlkl

// Handle compiler-specific extension to ANSI C
// for inline function declaration
#if defined(__MET__)	
# define _Inline _Inline	// Metaware
#elif defined(WIN32)
# define _Inline __inline	// MS Visual C/C++
#else
# define _Inline
#endif

#if defined(MODEM_Z80) // {

# define VERSION_DATE_STR		"011201a"

# define HDLC_FRAMES_BY_REFERENCE	// Leave LAPM and MNP HDLC TX frames
									// in Buffer Pool, that is, send by
									// reference from the DCE Ring Buffer.
# if defined(HDLC_FRAMES_BY_REFERENCE)
//#  define MNP_OFRAMES_BY_REFERENCE	// Leave MNP Octet TX frames
# endif								// in Buffer Pool, that is, send by
									// reference from the DCE Ring Buffer.
# if !defined(CS_MODEM)
#  if defined(K56FLEX) || defined(VPCM_CLIENT)
#   define COMPRESS_TABLES			// Use compressed DSP code for downloads
#  endif
# endif // !CS_MODEM

# if defined(EXT_MODEM)			// SERIAL MODEM - RS232
#  define VCE_FAX_STR			"Serial "
#  define VERSION_STR			"s" VERSION_DATE_STR
#  define PNPSTRING				"01.00"
#  define PNPDEFAULT			"\r\n(\x01\x24HSM0100\\\\MODEM" \
								"\\TIA0602,TIA0578\\Venus Serial Modem"
#  define Z80_EASCI_TX_DMA			// For DMA to DTE via EASCI TX
#  define Z80_EASCI_RX_DMA			// For DMA from DTE via EASCI RX
#  define WATCHDOG_TIMER
#  define DUMB_IOCS2				// dumb debug on IOCS2
//#  define ATHENA_LEDS		// Enable 3-LED code for Athena serial design
# elif defined(PCMCIA_MODEM)				// PC CARD MODEM
//#  define COMPACT_FLASH			// uncomment for CompactFlash card
#  if defined(COMPACT_FLASH)
#   define VCE_FAX_STR			"CF+ "
#  else
#   define VCE_FAX_STR			"PCMCIA "
#  endif
#  define VERSION_STR			"p" VERSION_DATE_STR
#  define MIMIC_RAM_CODE		// uncomment for MIMIC TX in RAM
#  define DC0					// Celular direct connect
//#  define MULTI_FUNCTION
//#  define WATCHDOG_TIMER
//#  define DIA_MODE			// Allow host to capture MIMIC port for DIA
//#  define Z80_MIMIC_DMA		// uncomment for MIMIC RX DMA
# elif defined(USB_MODEM)						// USB
#  define VCE_FAX_STR			"USB "
#  define VERSION_STR			"U" VERSION_DATE_STR
#  define PEGASIS				// Uncomment for reference design
#  define DUMB_IOCS2			// dumb debug port on IOCS2
#  define HOMOL
#  define WATCHDOG_TIMER
#  define USB_POLLED_MODE
#  define TQFP128				// 128 pin package (not MQFP160)
//#define USB_SHORT_POR			// Pegasis w/ 10ms/20ms POR time
# else				// INT_MODEM - ISA and other MIMIC modems
//#  define KASHMIR				// Kashmir board
//#  define Z80_MIMIC_DMA		// MIMIC RX DMA
//#  define COMM_DECODE			// disable FUGU
//#  define VENUS_AT_CS			// Venus Central Site - (AT commands)
//#  define PCI_MODEM
#  if defined(PCI_MODEM)
#   define COMM_DECODE			// disable FUGU
#   define DUMB_IOCS2			// dumb debug port on IOCS2
#   define TQFP128				// 128 pin package (not MQFP160)
#  endif
#  if !defined(CS_MODEM)
#   define MIMIC_RAM_CODE		// MIMIC TX in RAM
#   if defined(COMM_DECODE)
//#   define WATCHDOG_TIMER
#   endif
#   if defined(COPERNICUS)
#    define VCE_FAX_STR		"Copernicus "
#    define VERSION_STR		"C" VERSION_DATE_STR
#    define CLASS2_FAX		// Class 2 FAX
#    define CS_DIGITAL		// digital mode - ISDN/T1 line, no analog CODEC
#    define VENUS_AT_CS		// Venus Central Site - (AT commands)
#    define DUMB_IOCS2		// dumb debug port on IOCS2
#   elif defined(KASHMIR)
#    define VCE_FAX_STR		"Kashmir "
#    define VERSION_STR		"I" VERSION_DATE_STR
#    define DUMB_IOCS2		// dumb debug port on IOCS2
#   elif defined(PCI_MODEM)
#    define VCE_FAX_STR		"PCI "
#    define VERSION_STR		"I" VERSION_DATE_STR
#   else
#    define VCE_FAX_STR		"ISA "
#    define VERSION_STR		"I" VERSION_DATE_STR
#   endif
#  endif	// !CS_MODEM
# endif  // isa

# if !defined(CS_MODEM) // {
#  define FULLWAVERING				// (crouton not FULLWAVERING)
#  define TEST_COMMANDS
#  define FLASH_LOADER
#  if !defined(MODEM_ARM)
#   define V42BIS_RAM_CODE			// uncomment for v42bis RAM code
#  endif
#  define EEPROM_X24C04
//#  define RAW_FLASHER
//#  define V80
#  define V25TER					// V.25ter commands
#  define V253						// V.253 commands
#  if defined(ROM_FLASH)
#   if (ROM_FLASH == 64)
#    define Z80_DEBUG_PRINT			// uncomment for debug printing...
#    define UART_DEBUG_PRINT		//		serial debug
#   endif // 64
#  endif // ROM_FLASH

#  if !defined(COPERNICUS)
//#	define CLASS2_FAX     // Class 2 FAX as defined in EIA/TIA-592
//#	define CLASS20_FAX	// Class 2.0/2.1 FAX as defined in CCITT T.32
//#	define FAX_ECM	    // FAX Class 2/2.0/2.1 ECM (Error Correction Mode)
//# define V34_FAX				// V34 Fax
//# define SDR_RING_DETECT		// "special" distinctive ring
//# define CLASS1_DC_SUBS		// sub XON/XOFF chars in low-speed fax
#	if defined(FAX_ECM) && defined(VENUS2)
//#		define ECM_64K_BUFF   // Venus 2 using 64K ECM buffer
#	endif
//#   define CALL_WAITING			//pwwlkl
#   if !defined( USB_MODEM )
#    define HOMOL
#    if defined(HOMOL)
//#		define COUNTRY_BLOCKING
//#		define VENUS_WORLD_DAA
//#		define UKCID
//#		define SHUNT
#    endif // HOMOL
#    define VOICE
#    define CALLER_ID
#    if defined(VPCM_CLIENT)
//#     define CIDCW					// CID on call waiting  pwwlkl out already
#    endif // VPCM_CLIENT
#   endif // !USB_MODEM
#  endif // !COPERNICUS
//#	define VENUS_WORLD_DAA
//#   define OCP					// Over-current protection

# else // } { CS_MODEM

	// --- All of the switches below are enabled by default for CS_MODEM
#  define ROM_2MEG            // Specify 2-Meg part
#  define V80
#  define CS_DIGITAL
#  define VERSION_STR  "12089a"
#  if !defined(CLASS2_FAX) && !defined(CS_V110)
#    define CS_ENABLE_DEBUG_LOGGING // Central site debug buffer logging
#  endif
#  define CS_STARTUP_DELAY		// Central site modem startup delay enabled
#  define IPGATEWAY				// Uncomment for remote access server gateway
#  define CS_V23_MODULATION		// Central site modem V.23 modulation enabled
#  define CS_DTMF_DETECTION		// Central site modem DTMF detection enabled
#  define CS_MF_TONES			// Central site modem MF R1/R2 detect/gen
	// CS line probing enable. Overwrites DPSK buffer w/ line probing results.
#  define CS_LINE_PROBING
#  define CS_DTMF_DIALOUT		// Central site modem DTMF dial out enabled
#  define CS_MODEM_DEBUG
		// --- All of the switches above are enabled by default
//#  define CLASS2_FAX        // Uncomment to enable Class 2 FAX for CS modem
//#  define IWF_FAX			  // Network System's Wireless FAX (TDMA) product (Class 2.0)
//#  define FAX_ECM           // Class 2/2.0 ECM
//#  define IWF_DATA		  // IWF
//#  define CS_BANKING			// banking for debug buffers enabled
//#  define CS_CID_ENABLE		// Bell 202 caller id detection enabled
//#  define CS_RMP_DEBUG        // modem debugging enabled
#  if defined(CS_STARTUP_DELAY)
#   define STARTUP_DELAY		20
#  endif
#  if defined(CS_LAPM_DEBUG)
#   undef CS_LAPM_DEBUG
#  endif
#  if defined(CS_RMP_DEBUG)
#   define Z80_DEBUG_PRINT
#   define UART_DEBUG_PRINT
#   if defined(RMP_DEBUG_PRINT)
#    undef RMP_DEBUG_PRINT
#   endif
#  endif // CS_RMP_DEBUG

# endif // } !CS_MODEM

#endif // } MODEM_Z80


#if defined(TCP_IP)
// undefine all features not wanted in embedded TCP/IP applications
# include "mn_tcpip.h"
#endif

#define cs_debug_liv(x)
#define CLOCK_29MHZ
//#define WAIT_STATE_TWO

#if defined(K56FLEX) || defined(VPCM_CLIENT) || defined(VPCM_SERVER)
  #if defined(VENUS_AT_CS) || defined(CS_MODEM)
    #define IDSTRING "Lucent CS "  VCE_FAX_STR  VERSION_STR
  #else
    #define IDSTRING "Venus V.92 "  VCE_FAX_STR  VERSION_STR
  #endif
#else
  #define IDSTRING "Venus "  VCE_FAX_STR  VERSION_STR
#endif

#if defined(CS_4)
# define DSPCHECKSUM		0x3f39		// CS4
# define DSPVERSION			18  		// CS4
#elif defined(DRAGNET)
# define DSPCHECKSUM		0x25A2		// DRAGNET
# define DSPVERSION			57  		// DRAGNET
#else
# define DSPCHECKSUM		0x1222		// VENUS V1.17
# define DSPVERSION			17  		// VENUS V1.17
//# define DSPCHECKSUM		0x861b		// VENUS 'DG' ROM
//# define DSPVERSION		60			// VENUS 'DG' ROM
#endif

#define ENABLED		        1
#define DISABLED	        0
#if !defined(FALSE)
	#define FALSE		    0
#endif
#if !defined(TRUE)
	#define TRUE		    1
#endif
#define DONTKNOW	        2
#if !defined(NULL)
	#define NULL	        ((void *)0)
#endif
#define ON			1
#define OFF			0
#define YES			1
#define NO			0
#define ACK			0
#define NAK			1
#define DECIMAL		10
#define HEX         16
#define FAILED      0
#define XOFF		0x13
#define XON 		0x11
#define DLE     	0x10

#ifndef Z80_ASM
#if !defined( CS_4 )
  typedef unsigned char byte ;
  typedef unsigned short word ;
  typedef unsigned long dword ;
  typedef unsigned char BOOL ;
#endif
typedef void (*PFV)(void); // pointer to a func returning void, no params

/* system timer defines */
#define	MS10		10		// 10 ms
#define MS20		20		// 20 ms
#define	MS30		30		// 30 ms
#define MS50		50
#define MS55		55
#define	MS60		60		// 60 ms
#define	MS75		75
#define	MS1500		1500	// 1500 ms
#define MS100		100
#define MS150		150
#define MS170		170
#define MS200		200
#define MS300		300
#define MS400		400
#define MS500		500
#define MS600		600
#define MS750   	750
#define MS800   	800
#define MS850   	850
#define SECOND1		1000
#define SECOND1_5	1500		
#define SECOND1_8	1800
#define SECOND2		2000
#define SECOND2_2	2200
#define SECOND2_5	2500
#define SECOND2_6	2600
#define SECOND3		3000
#define SECOND3_5	3500
#define SECOND4		4000
#define SECOND5		5000
#define SECOND5_5	5500
#define SECOND6		6000
#define SECOND7		7000
#define SECOND8		8000
#define SECOND9		9000
#define SECOND10	10000
#define SECOND12	12000
#define SECOND15	15000
#define SECOND20	20000
#define SECOND30	30000
#define SECOND40	40000
#define SECOND50	50000
#define MINUTE1		60000


/* all task's present in the modem controller */
typedef enum {
	LL_TASK,
	DP_TASK,
	AT_TASK,
	IO_TASK
}	MBOX ;

/* all the modem commands */
typedef enum {

	MC_INIT,
	MC_RESET,
	MC_PERIODIC,
	MC_OPTION_CHANGE,
	MC_DIAL,
	MC_ANSWER,
	MC_OFFHOOK,
	MC_ONHOOK,
	MC_IDLE,
	MC_DISCONNECT,
	MC_ABORT_TEST,
	MC_ANALOG_LOOPBACK,
	MC_LOC_DIGITAL_LOOPBACK,
	MC_REM_DATA_LOOPBACK,
	MC_REM_DIGITAL_LOOPBACK,
	MC_SPEAKER_ON,
	MC_SPEAKER_OFF,
	MC_SPEAKER_HIGH,
	MC_SPEAKER_MEDIUM,
	MC_SPEAKER_LOW,
	DP_RING,
	DP_RING_CADENCE,
	DP_AT_DIALDONE,
	DP_IO_CONNECT,
	DP_IO_DISCONNECT,
	AT_IO_DISCONNECT,
	V42_LOCAL_DISC,
	V42_REMOTE_DISC,
	IO_AT_CONNECT,
	IO_AT_DISCONNECT,
	IO_AT_DATA,
	IO_IDLE_STATE,
	AT_IO_FAX_STATE,
	AT_IO_DATA,
	AT_OK,
	AT_IO_BREAK,
	AT_ERROR,
	AT_IO_ON_LINE,
	AT_IO_CD_ON,
	IO_INACTIVITY_STATE,
	IO_DP_RETRAIN,
	IO_DP_V90_CS_RETRAIN,
	FAX_END_OF_DATA,
	FAX_ERROR,
	FAX_STARTUP_TRANSMIT,
	FAX_STARTUP_RECEIVE,
	FAX_DROP_CARRIER,
	FAX_WAIT_SILENCE,
	DP_IO_FAX_CARRIER_LOSS,

	FAXV34_SEND1S,				// V34 Fax Send 1s to far end
	FAXV34_DETECT1S,			// V34 Fax detected 1s
	FAXV34_NO_ANSAM_START,		// V34 Fax start-up without ANSam

	DP_IO_V54_ORIGINATE,
	DP_IO_V54_TERMINATE,

	MC_V110_ANSWER,				// V110
	CSM_DETECT_TONES,		 	// CS_MODEM
	CSM_GENERATE_TONES,	 	 	// CS_MODEM
	CSM_STOP_DETECT_TONES,		// CS_MODEM
	DP_IO_V110,					// V110

	CSM_DETECT_BONG_TONE, 		// IWF Bong tone
	CSM_DETECT_2ND_DIALTONE,	// IWF 2nd Dial tone
	CSM_DETECT_QUIET_ANSWER,	// IWF Quiet Answer

	VOICE_START,				// voice commands
	VOICE_END,
	VOICE_WAVE_END,
	VOICE_LINE_LOOPBACK,
	VOICE_NEAR_LOOPBACK,
	VOICE_NEAR_RECORD,
	VOICE_NEAR_PLAYBACK,
	VOICE_NEAR_CHANGE_PLAYBACK,
	VOICE_LINE_RECORD,
	VOICE_LINE_PLAYBACK,
	VOICE_SCREEN_OUT,
	VOICE_SCREEN_IN,
	VOICE_NEAR_FULL_DUPLEX,
	VOICE_LINE_FULL_DUPLEX,
	VOICE_LOCAL_PHONE_PLAYBACK,
	VOICE_LOCAL_PHONE_RECORD,
	VOICE_LOCAL_PHONE_CONNECT,
	VOICE_TX,
	VOICE_RX,
	VOICE_DUALPLEX_TX_RX,
	VOICE_IDLE,
	VOICE_GENERATE_TONES,
	VOICE_SPEAKER_PHONE,
	VOICE_SPEAKER_PHONE_TRAIN,
	VOICE_SPEAKER_PHONE_SAVE_MUTE,
	VOICE_MUTE_SPKR_PHONE,
	VOICE_UNMUTE_SPKR_PHONE,
	VOICE_SPKR_PHONE_RECORD_START,
	VOICE_SPKR_PHONE_RECORD_STOP,
	VOICE_STOP_SPKR_PHONE,
	VOICE_GAIN_CONTROL,
	VOICE_MIC_GAIN_CONTROL,
	VOICE_AGC_CONTROL,
	CALLER_ID_END,
	RADISH_DP_TASK,
	RADISH_IO_TASK,
	IO_LOOPBACK_ABORT,
	IO_WAKEUP_CMD,
	IO_SLEEP_CMD,
	DP_TEST_CMD,
	DP_SLEEP,
	DP_WAKEUP,
	DP_READ_REG,
	DP_WRITE_REG,
	DSP_READ_RAM,
	DSP_READ_CONSTELLATION,
	DSP_WRITE_RAM,
	DSP_VERSION,
	DSP_CHECKSUM,
	DSP_RETRAIN,
	UPDATE_MODEM_RATE,
	DSP_FAST_RETRAIN,
	DP_SHOW_BLACKLIST,
	DP_START_TRANSMIT,
	DP_START_RECEIVE,
	DP_ASYNC_8BIT_MODE,
	DP_ASYNC_USER_MODE,
	DP_ASYNC_WORKAROUND,
	DP_SYNC_MODE,
	DP_HDLC_MODE,
	DP_HDLC_MODE_NO_CRC,
	SYNC_DISABLE_FORWARD,
	SYNC_ENABLE_FORWARD,
	DP_SYNC_MODE_MARK,
	DP_SEND_A8T_CMD,
	DP_V8BIS_DETECTION,
	DP_A8T_CMD,
	DP_IO_RETRAIN_START,
	DP_IO_RETRAIN_OVER,
	DP_TX_FIFO_EMPTY,
	DP_BLACKLIST_STATUS,
	DP_IO_DIAL_OR_ANSWER,
	IO_DUMP_DSP_MEM,			// IO should display DSP memory to DTE
	DP_SUSPEND,
	DP_RESUME,
	DP_DPORT_TX,
	DP_DPORT_RX,
	DP_DPORT_DUALPLEX_TX_RX,
	A_LAW_SELECTED ,
	MU_LAW_SELECTED ,

	CSM_DETECT_CID,			 //CS_MODEM bell202
 	CSM_CALLER_ID_END,		 //CS_MODEM bell202

	AM_KEYBOARD,
	AM_UPDATE

}	MODEM_COMMAND ;

/* modem state */
typedef enum {
	MS_INITIALIZING,	/* Initializing all the other Tasks */
	MS_IDLE,			/* Dial Modem, on-hook */
 	MS_RING_INDICATE,	/* Ring Signal present on local DAA. */
	MS_ANSWERING,		/* Off-hook, silence or sending answer-tone */
	MS_OFFHOOK,			/* Offhook, waiting for Dial Tone detection */
	MS_DIALING,			/* Dialing mode */
 	MS_ON_DIAL,			/* On Dial Lines */
	MS_LOCAL_TEST,		/* Test Mode - Analog Loopback */
	MS_DCE_LOOPBACK,	/* Test Mode - Digital Loopback in data mode */
	MS_DTE_LOOPBACK,	/* Test Mode - Local Digital Loopback */
	MS_REM_TEST,		/* Test Mode - Remote Digital Loopback */
	MS_TAD_NEAR,		/* In TAD local mode */
	MS_TAD_FAR,			/* In TAD far mode */
	MS_TAD_LOOPBACK		/* In TAD loopback mode */
}	MODEM_STATE ;

/* modem mode, corresponding to the at+fclass command */
typedef enum {
	MODEM_DATA,
	MODEM_FAX,
	MODEM_VOICE,
	MODEM_SPEAKER_PHONE,
	MODEM_RADISH
} MODEM_MODE;

// CS_RR_RET is a structure of variables. These variables
// keep count of local/remote retrains/rate renegotiations
typedef struct {
	byte remote_rr_req;
	byte remote_rr_granted;
	byte local_rr_granted;
	byte remote_rtn_req;
	byte remote_rtn_granted;
	byte local_rtn_granted;
	byte forward_back;
	byte remote_or_local;
} CS_RR_RTN;

// Modem Line Rate.  io_line_rate (in iomain.c) maps
// between this enum and word integers representing the
// line rate.  various functions make use of this array
// to print and otherwise manipulate the line speed
typedef enum {
	MR_TRAINING,
	MR_75,
	MR_300,
	MR_600,
	MR_1200,
	MR_2400,
	MR_4800,
	MR_7200,
	MR_9600,
	MR_12000,
	MR_14400,
	MR_16800,
	MR_19200,
	MR_21600,
	MR_24000,
	MR_26400,
	MR_28800,
	MR_31200,
	MR_33600,

	MR_32000,	// first K56FLEX rate
	MR_34000,
	MR_36000,
	MR_38000,
	MR_40000,
	MR_42000,
	MR_44000,
	MR_46000,
	MR_48000,
	MR_50000,
	MR_52000,
	MR_54000,
	MR_56000,
	MR_58000,
	MR_60000,

	MRV_28000,	// first V.90/V.92 rate
	MRV_29333,
	MRV_30666,
	MRV_32000,
	MRV_33333,
	MRV_34666,
	MRV_36000,
	MRV_37333,
	MRV_38666,
	MRV_40000,
	MRV_41333,
	MRV_42666,
	MRV_44000,
	MRV_45333,
	MRV_46666,
	MRV_48000,
	MRV_49333,
	MRV_50666,
	MRV_52000,
	MRV_53333,
	MRV_54666,
	MRV_56000
}	MODEM_LINE_RATE ;

typedef enum {
	MR_OK,
	MR_NO_DIAL_DTR,
	MR_NO_DIAL_TONE,
	MR_BUSY_SIGNAL,
	MR_TRUNK_BUSY,
	MR_NO_ANSWER_TONE,
	MR_NO_QUIET_DETECTED,
	MR_REMOTE_DISCONNECT,
	MR_DTR_DISCONNECT,
	MR_CD_DISCONNECT,
	MR_EC_DISCONNECT,
	MR_LONG_SPACE_DISC,
	MR_NO_DATA_DISC,
	MR_DELAYED,
	MR_BLACKLISTED,
	MR_BLACKLIST_FULL
}	MODEM_DIAL_RESIDUAL ;

typedef enum {
	EC_NO,
	EC_V42,
	EC_V42B,
	EC_V42V44,
	EC_MNP2,
	EC_MNP3,
	EC_MNP4,
	EC_MNP5
}	MODEM_EC ;

typedef struct {
	word minutes ;
	word mseconds ;
} TIME_MIN_SEC ;

/****************************************************************
Description :
	Contains externals for library routines in llutilxx.c
*****************************************************************/
#if defined (CS_MODEM)
  extern byte cs_atohex ( byte *value );
  extern void cs_msi_update ( void );
  extern void cs_parse_cmd( void );
  #if defined(CS_ENABLE_DEBUG_LOGGING)
	extern void cs_insert_error_tag ( word error_code, word counter );
    extern void cs_log_state_pointers ( void );
  #else
    #define cs_insert_error_tag(x,y)
    #define cs_log_state_pointers()
  #endif
#else
  #define cs_msi_update()
  #define cs_parse_cmd()
  #define cs_log_state_pointers()
  #ifdef MTS_DEBUG
	extern void cs_insert_error_tag ( word error_code, word counter );
  #else			 
    #define cs_insert_error_tag(x,y)
  #endif
#endif	// CS_MODEM

extern byte read_eeprom ( word ) ;
extern void write_eeprom ( word, byte ) ;
extern void UpdateEEPROM ( void ) ;

extern non_banked void x_send_mail_dp1(MODEM_COMMAND cmd);
extern non_banked void x_send_mail ( MODEM_COMMAND cmd, MBOX send_to,
							byte *text_ptr, word text_len ) ;
#if defined(WIN32)
extern word x_current_time(void);
extern word x_elapsed_time(word timer);
#endif

#if defined(MODEM_Z80)
# define x_current_time()	(x_timer)
extern non_banked word x_elapsed_time(word timer);
#endif	// MODEM_Z80

#if !defined(MODEM_ARM)
extern non_banked dword x_elapsed_time_long(dword x_minute_timer_long);
extern non_banked dword x_current_time_long(void);
#endif // !MODEM_ARM

extern non_banked byte x_parity ( byte tx_char ) ;
extern non_banked byte x_sleep_mode ( void ) ;
extern non_banked void x_send_at_io_data(byte *text_ptr);
extern non_banked void x_send_at_io_crlf(void);

/* function to set modem options to factory defaults */
extern void x_init_modem_options ( void ) ;
extern void x_set_current_time ( TIME_MIN_SEC *current_time ) ;
extern word x_elapsed_minutes ( TIME_MIN_SEC reference_time ) ;
extern word x_elapsed_long_time ( TIME_MIN_SEC reference_time ) ;
extern void x_sleep ( word timer ) ;

extern non_banked word x_strlen ( const byte *src ) ;
extern non_banked void x_strcpy ( byte *dest, const byte *src ) ;
extern non_banked void x_memcpy ( byte *, const byte *, word ) ;
extern non_banked void x_strcat ( byte *src, const byte *catstr ) ;

extern void cs_write_debug_buf(word dbg_msg);

#if defined(MODEM_Z80)
  #if defined(Z80_DEBUG_THIS_FILE) && defined(Z80_DEBUG_PRINT)
    // Define Z80_DEBUG_THIS_FILE in each file where we want debug messages.
    // This replaces the older way where x_debug_msg was defined as below
    // in each file. (The #define must be before the #include "llglob_d.h")
    #define x_debug_msg(x) (ddputs_24l(x))
  #endif

  #if !defined(x_debug_msg)
    #define x_debug_msg(message)
  #endif

  #if defined(Z80_DEBUG_PRINT)		// for debug printing
    #define ddputs_24l(x)	(ddputs_24(address_24_of(x)))
    extern non_banked void ddputs_24(long);
    extern non_banked byte ddputs_24_nnl(long);
    extern void ddputs_nnl ( char * ) ;
    extern void ddputs ( char* ) ;
    extern void sendDumbChar ( char ) ;
    extern void sendHexDigit( byte ) ;
    extern void sendHexByte(byte) ;
    extern void sendDecByte(byte);
    extern void sendHexWord(word) ;
    extern void sendCrLf( void ) ;
    extern void enableDumbPort( void ) ;
	extern void dp_puts(long);
	#define DP_PUTS(x)		dp_puts(address_24_of(x))
    #define str_display(x) 	(ddputs_24(address_24_of(x)))
  #else
    #define ddputs_24l(x)
    #define ddputs_nnl(s)
    #define ddputs_24_nnl(x)
    #define x_debug_msg(x)
    #define ddputs_nnl(ch)
    #define ddputs(ch)
    #define sendDumbChar(ch)
    #define sendHexDigit(ch)
    #define sendHexByte(ch)
    #define sendHexWord(wd)
    #define sendDecByte(ch)
    #define sendCrLf()
    #define enableDumbPort()
    #define str_display(x)
  #endif
  #define str_copy(d,s) 	(strcpy_24(d,address_24_of(s)))
  extern non_banked void strcpy_24(byte *, long);
#endif

#if defined( Z80_DEBUG_PRINT )
  extern void dp_puts_hex(word n);
  extern void dp_puts_dec(word n);
  extern void dp_puts_sdec(word n);
#else
  #define DP_PUTS(x)
  #define dp_puts(x)
  #define dp_puts_hex(x)
  #define dp_puts_dec(x)
  #define dp_puts_sdec(x)
#endif
/****************************************************************
Description :
	Contains the modem fax options that are global to the system.
*****************************************************************/

typedef enum {
	FAX_IDLE,
	FAX_TX_HDLC,
	FAX_RX_HDLC,
	FAX_TX,
	FAX_RX,
	FAX_RX_START,
	V34FAX_CCSTART,
	V34FAX_PRISTART,
	V34FAX_EOT
}	FAX_STATE ;


/* v.17 fax mode */
typedef enum {
	NON_V17,
	V17_LONG_TRAIN,
	V17_SHORT_TRAIN
} V17_FAX_MODE ;

/****************************************************************
Description :
	Contains all the S Registers and the modem options that are
	global to the system.
*****************************************************************/

#if defined(__MET__)
#pragma Pack(1)
#endif
typedef struct {	 // !!! WARNING !!! do not change order or delete
byte AutoAnswer ;		//S0
byte RingCount ;		//S1
byte EscapeChar ;		//S2
byte CRChar;			//s3
byte LFChar;			//s4
byte BSChar;			//s5
byte BlindDialPause;	//s6
byte NoAnsTimeOut;		//s7
byte DialPauseTime;		//s8
byte Dummy9;
byte NoCarrierDisc; 	//s10
byte DtmfDialSpeed;     //s11
byte EscapeGuardTime;	//s12
byte DataBits;			//s13 - WARNING!!! DO NOT MOVE (see z80v42b.asm)
byte PulseDial20pps;    //s14 Flag for enabling 20 pps dialing in Japan
byte StopBits;			//s15
byte DteRate;           //s16
#if defined(CS_V110)
byte V110Speed;			//s17 Used by V.110 for config speeds: =0 if no v.110
						//	= 58 for 2400, 59 for 4800, 61 for 9600
#else
#ifdef VPCM_CLIENT
byte Aggressive_Connection_Enable;	//s17
#else
byte Dummy17;
#endif	//VPCM_CLIENT
#endif  // CS_V110
byte Dummy18;			//s18
byte Parity;			//s19 - WARNING!!! DO NOT MOVE (see z80v42b.asm)
byte Dummy20;			//Used By KORTEX
byte Dummy21;			//Used By KORTEX
byte Dummy22;			//s22
byte Dummy23;
byte Dummy24;           //duplicate for S89 (Sleep Inactivity Timer)
byte Dummy25;
byte Dummy26;			//s26 (this is available)
byte V23mode;			// used for v23 mode checking, internal
byte bV34Enable;		//s28. 1 = V34 enabled. 0 = V34 disable.
byte Dummy29;			//s29
byte InactivityTimer;	//s30 in minutes
byte SpeakerPhoneMode;  //s31
byte SynRingVolume;		//s32
byte SynRingFreq;		//s33
byte MimicFIFOrate ;	//s34
byte DataCallingTone;   //AT-C setting: data calling tone
byte NegotiationFallback;	//S36
byte DialLineRate;		// s37
byte Rate56K;           // s38
byte CellConnectMsg;	// s39
byte ETC;				//s40  #ETC
byte OldLineRate;		//s41
byte AutoRate;			//s42
byte AutoMode;			//s43

// Other Modem Options, not part of S registers
byte ExtResultCode ;	// for ATX, 44
byte DialToneDetect ;	// for ATX, 45
byte BusyToneDetect ;	// for ATX, 46
byte DialMode ;			// 47
byte FeatureNegotiation;	// 48
byte ResultCode ;		// for ATQ, reuslt code enable, 49
byte ResultCodeFormat ;	// for ATV, result code format, 50
byte CDControl ;		// 51
byte DTRControl ;		// 52
byte GuardTone;			// 53
byte SpeakerVolume ;	// 54
byte SpeakerControl ;	// 55
byte V42 ;				// 56
byte Compression ;		// 57 see defines below for MNP, V.42bis, V.44
byte CommStdSetting;	// ATB setting: CCITT v. Bell, 58
byte V23Reverse; 		// ATB setting: v.23 reverse mode, 59
word SpeakerphoneMicGain ;	// 60, 61	
word SpeakerphoneMicMute ;	// 62, 63	

// options for direct connect phone
byte CellPhoneType;			// #DC0. cell phone type., 64

// options for voice
byte CallerId ;				// 65
byte VoiceVolumeControl ;	// 66
byte VoiceMicGainControl ;	// 67
byte VoiceLineSelection ;	// 68
byte RingbackGoAway ;		// 69
byte RingbackNeverCame ;	// 70
byte SilenceSensitivity ;	// 71
byte SilenceDetectTimer ;	// 72
byte VoiceCompression ;		// 73
byte VoiceSamplingRate ;	// 74
word BeepToneTimer ;		// 75, 76
byte DistinctiveRing ;		// 77
byte RingReportInterval ;	// 78
word VoiceEventMask ;		// 79, 80
byte DSRControl ;		// 81
byte Dummy82;			// 82
byte V8_Answer ;  		// 83
byte V8_CI_Octet ; 		// 84
byte V8_Orig ;  		// 85
byte Dummy86;			// 86
byte EchoToDTE ;		// for ATE, enable echo to the DTE,87
byte FlowControl;		// S88 Warning: see cstartup.asm - do not move
byte SleepModeTimer ;	// S89
byte LocalHandset;		// status of local handset, 0=onhook, 1=offhook
byte TransmitLevel ;	// S91
byte CellTransmitLevel;	// s92
word wV34Option;		// DSP location 821 s93/s94
word wHayes95;			// reserved for Hayes S95 option
word wV34MSEScale;		// DSP location 825 s97/98
byte Dummy99;			// 99
word wV34RxSymbol;		// DSP location 823 s100/101
byte EchoRam;			// S102 - RAM to vconstel
byte RamEchoAddrLow;	// S103 - address low to vconstel
byte RamEchoAddrHigh;	// S104 - address low to vconstel
byte NewCoperRing;		// S105 - Copernicus uses bioa6 for ring
byte V8bis;				// V8bis Negotiation enable / disable s106
byte Enabled56K;		// V8bis Negotiation value for 56K s107
byte DigitalLoss56K;	// Digital loss download register - s108
byte VpcmOption;		// S109 - V.90/V.92 options
byte EchoConstel;		// S110 vconstel thru comport
byte AdjustBPS;			// S111 - for AT\J command
						//   bit 0 - 1 means line rate <= DTE rate
						//   bit 1 - 1 means long space disconnect
byte ConnectDteRate;	// S112 - CONNECT msg use DTE Rate
byte DteInactivityTimer;// S113 - voice option
byte HangupControl;		// S114 - voice option
byte Dummy115;			// s115
byte DsvdVoiceCallFirst;// s116 -DSVD voice call first flag
byte BoardId;			// S117 - board id
byte Dummy118;			// S118
word Dummy119;			// S119 & S120 was Board number
byte MNPMaxOctets;      // S121 - Max MNP block size
byte Dummy122;			// S122
byte BreakControl;		// S123 - Break handling options.
byte BreakLength;		// S124 - Break length.
byte DisableFallForward;// S125 - disable fall forward in auto rate function
byte Dummy126;			// S126
byte CallerIdType ;		// S127 - 0=NA, 1=Japan, 3=UK(SIN242)
byte AdaptiveAnswer ;	// S128 - fax/data adaptive answer enable flag.
byte MHOptions;			// S129 - Modem on Hold Options for V.92


// Homologation parameters table begining.
// all parameters required for international support
// WARNING: Do not alter the order of parameters, add new parametrs at the end
byte CountryId ;			// Country identification code

byte PulseTimeMake ;		// pulse dial make time in msec
byte PulseTimeBreak ;		// pulse dial break time in msec
byte PulseDigitPattern ; 	// 0=normal, 2=Sweden, 3=Norway
byte DtmfLevel ; 			// DTMF high tone level in db
byte MinDtmfDialSpeed ;		// min s11 in msec
byte MaxDtmfDialSpeed ;		// max s11 in msec
byte CallProgressThreshold ;// Call progress tones detection threshold in db
byte DialToneDelay ;		// Waiting time before start detecting dialtone
byte DialToneHole ;			// Max Dialtone hole time or off cadance in msec
byte RingCountNullDelay ;	// in multiples of 100 msec
byte MinAutoAnsRingCount ;	// Auto Answer ring count lower limit
byte MaxAutoAnsRingCount ;	// Auto Answer ring count upper limit
byte MinRingPeriod ;		// Ring detction lower limit for the ring period
byte MaxRingPeriod ;		// Ring detction upper limit for the ring period
byte RingCadenceOn ;		// Ring cadence on period in multiples of 10 ms
byte RingCadenceOff ;		// Ring cadence off period in multiples of 100 ms
byte MinBusyCadenceOn ;		// Min Busy cadence on period in multiples of 10 ms
byte MaxBusyCadenceOn ;		// Max Busy cadence on period in multiples of 10 ms
byte BusyPassCount ; 		// # of busy cycle to conclude busy state
byte MinBusyCadenceOff ;	// Min Busy cadence off period in multiples of 10 ms
byte MaxBusyCadenceOff ;	// Max Busy cadence off period in multiples of 10 ms
byte ContinuousBusyDetect ; //  0=disabled, 1=enabled
byte AnsToneValidTime ; 	// Answer tone validation time in multiples of 10 ms
byte BlackListFlag ; 		//  Blacklisting/delayed, 0=disabled, 1=enabled
byte MaxCallAttempts ; 		// # of failed attempts for blacklisting a #
byte TroubleCallDelay ; 	// Delay for troubled call attempt in min
byte IneffectiveCallDelay ;	// Delay for ineffective call attempt in min
byte ErroneousCallDelay ;	// Delay for erroneous call attempt in min
byte BlackListPeriod ; 		// Blacklisting duration in multiples of 10 min 
byte LoopSenseWaitTime ;	// line current sense waiting time in multiples
							// of 100 msec, 0 = loop sensing not required
byte CallingToneFlag ;   	// 0 = not required, 1 = required & disable permited
							// 2 = required & disable not perimited
byte BlindDialPermited ; // 0=not permited, 1=permited, 2=permited with spk on
byte BusyDetectDisable ; // Disabling with ATX; 0 = not permited, 1 = permited
byte GuardToneType ; 		// 0=not present & adjustable, 1=550 Hz, 2=1800 Hz
byte BellModePermited ; 	// 0=not permited, 1=permited
byte OffHookRestrict ; 		// 0=no restrictions, 1=permited with time limit,
							// 2=not permited
byte OffhookShuntTime ;		// Duration in multiples of 10 ms for which the 
							// shunt relay turned on when modem goes offhook. 
byte HookFlashTime ;		// in multiples of 10 ms; 0 = hookflash disabled
byte MinBlindDialPause ;	// in sec
byte MaxBlindDialPause ;	// in sec
byte MinNoAnsTimeOut ;		// in sec
byte MaxNoAnsTimeOut ;		// in sec
byte MinDialPauseTime ;		// in sec
byte MaxDialPauseTime ;		// in sec
byte MinNoCarrierDisc ;		// in sec
byte MaxNoCarrierDisc ;		// in sec
byte TxLevel ;				// transmit level in dB
byte RestrictDial ;		// 0=If invalid dial modifiers are found dial the 
						// string ignoring the invalid modifiers. 
						// 1=If invalid modifier found do dial any digits 
						// treat the entire string as NULL 
byte TadRxGain ;			// tad RX gain
byte RingDetectType ;		// 1 = Full wave, 0 = Half wave 
byte DelayAttempts ;		// # of attempts after which delay is effective 
byte MaxAttempts ; 			// total # of all failed attempts before blocking 
							// any further call attempts,
							// if = 255 means this parameter not applicable
byte ErrorCallWeight ;		// # attempts incrementing factor for erroneous call
byte DialToneValidTime ;	// Dial tone validation time in multiples of 100 ms 
byte DialBusyDetect ;		// Busy detection during dial tone detection, 
							// 0=disabled 
byte DtmfToneDiff ;			// DTMF high & low tone level difference 
byte LocalPhoneDetect ;		// local phone detection in Speakerpone, 0=on, 1=off
byte PulseDialPermited ;	// Flag indicating pulse dialing allowed or not , 
							// 0=allowed, 1=not allowed
byte FilterIndex ;			// 0=340-560, 1=310-485, 2=363-502, 3=276-504,
							// 4=415-460.
byte DialToneThreshold ;	// dial tone detection threshold in db
byte DissableABCD ;			// Flag to dissable A,B,C, & D digit dialing 
							// 0=ABCD dialing allowed, 1=ABCD dialing dissabled
byte MaxCommaPauseTime ;	// in sec, restricts total comma pause duration 
							// if there are too many commas 
byte TadTxLevel ;		// TAD transmit level in dB
byte RxLevel ;			// receive threshold in dB (there is 6 db offsetin DSP)
byte WaitDialTimeOut ;	// W dial modifier no dialtone timeout in sec 
byte ToneThreshold ;	// Answer tone detection threshold
byte DialToneLevel ;	// Dialtone min energy level in multiples of 10 
byte FaxRxLevel ;		// Fax receive threshold in dB. 
byte PulseTonePermited ;// Flag indicating mixing of pulse and tone dialing
						// in same dial string allowed or not, 0=allowed 
byte RingImpedanceRly ;	// Ringer impedance relay flag, 0=Off, 1=On
byte LoopViRly ;		// DC loop V/I characteristics relay flag, 0=Off, 1=On
byte LoopLimitRly ;		// DC loop limiting relay flag , 0=Off, 1=On
byte ComplexImpedance ; // 0 = Mercury internal components 
						// 1 = real impedance (external components)
						// 2 = complex impedance (external components)
byte LineGainAMSB;		// Mercury Gain - CIOCA MSB
byte LineGainALSB;		// Mercury Gain - CIOCA LSB
byte LineGainBMSB;		// Mercury Gain - CIOCB MSB
byte LineGainBLSB;		// Mercury Gain - CIOCB LSB
byte TadLineGainBMSB;	// Mercury CIOCB MSB - Tx gain in Tad mode
byte FdspLineGainBMSB;	// Mercury CIOCB MSB - Tx gain in Fdsp mode
byte CTR21Enable ;		// True = enable CTR21, FALSE = disable CTR21
word DCOffset1;			// Perseus homologation dc offset
word ILimitOffset;		// Perseus homologation current limit offset
// Parameters table end. NOTE: Add new homologation parameters above this line

byte CountryIdStr[15] ; 	// country name & version string

byte Sanity ;			// this has to be the last byte in options
} MODEM_OPTIONS ;

typedef union {
	byte Reg[250] ;
	MODEM_OPTIONS ModemOptions;
} S_REGISTERS;
#if defined(__MET__)
#pragma Pack()
#endif

#define prnC	S.ModemOptions.CellPhoneType // #DC0

// defines for Error Control Mode - S.ModemOptions.V42
//  Different bits of this byte have meaning
//		0 - buffered mode allowed
//		1 - MNP allowed
//		2 - LAPM allowed
//		3 - synchronous mode allowed
//		4 - GMUX
// bit masks for error control mode.  Use these bit
// masks to make code simpler when testing for
// different kinds of error control.
#define V42_BUFFER_BIT	1
#define V42_MNP_BIT		2
#define V42_LAPM_BIT	4

#define V42_BUFFER_MODE		1
#define V42_MNP_DISC		2
#define V42_MNP_BUFFER		3
#define V42_LAPM_ONLY		4
#define V42_LAPM_BUFFER		5
#define V42_LAPM_MNP_DISC	6
#define V42_LAPM_MNP_BUFFER	7
#define V42_SYNCH_MODE		8
#define V42_SYNC_BUFFERED	9
#define V42_GMUX			16
// end of error control mode definitions

// Defines for ModemOptions.Compression
#define MNP_COMP	0x01
#define V42BIS_COMP	0x02
#if defined(V44)
# define V44_COMP	0x04		// this is set for normal and smart mode
# define V44S_COMP	0x08		// 'smart' mode V.44 - only V.92 server
#endif // V44

// flow control options
#define	NO_FLOWCTRL	0
#define SW_FLOWCTRL	1
#define HW_FLOWCTRL	2

// dte rate defines
#define DTE_110   	1
#define DTE_300  	2
#define DTE_600  	3
#define DTE_1200	4
#define DTE_2400	5
#define DTE_4800	6
#define DTE_9600	7
#define DTE_14400	8
#define DTE_19200	9
#define DTE_38400	10
#define DTE_57600	11
#define DTE_115200	12
#define DTE_230400	13

//structures for passing camil-registers and dsp-ram structures between tasks
typedef struct {
	byte loc ;
	byte val ;
} dp_reg ;

typedef struct {
	word loc ;
	word val ;
} dsp_ram ;

// direct connect equates
#define	CELL_DISABLE		0
#define CELL_ATNT_3730		1
#define	CELL_MOTOROLA		2
#define CELL_NEC      		3
#define	CELL_FUJITSU		4

#define FUJITSU_ENABLE		1
#define MOTOROLA_ENABLE		1
// #define ATNT_3730_ENABLE    1
// #define NEC_P100_ENABLE     1

// defines for Voice Compression Method and Voice Sampling Rate
#define VCM_LINEAR8			128
#define VCM_1ST_VAL			VCM_LINEAR8	/* used for checking */
#define VCM_LINEAR16		129
#define VCM_ALAW8			130
#define VCM_ULAW8			131
#define VCM_IMA_ADPCM		132
#define VCM_G729			133
#define VCM_LAST_VAL		VCM_G729

#define VSM_7KHZ			0
#define VSM_8KHZ			1
#define VSM_11KHZ			2

// define all the event bit positions in the VoiceEventMask word
#define EVENT_CALLER_ID			0x8000
#define EVENT_DISTINCTIVE_RING	0x4000
#define EVENT_RING				0x2000
#define EVENT_DTMF				0x1000
#define EVENT_FAX_CALLING_TONE	0x0800
#define EVENT_DATA_CALLING_TONE	0x0400
#define EVENT_LOCAL_PHONE_HOOK	0x0200
#define EVENT_SILENCE			0x0100
#define EVENT_BUSY_TONE			0x0080
#define EVENT_DIAL_TONE			0x0040
#define EVENT_CAS				0x0020

// defines for TAD Voice transfer rates for IS101
#ifdef KORTEX			
#define VOICE_RECORD_DSP_XFR_CNT		256	// ( AM_FH_PAGE_SIZE -> 272 )
#define VOICE_PLAY_DSP_XFR_CNT			512
#else
#define VOICE_RECORD_DSP_XFR_CNT		240
#define VOICE_PLAY_DSP_XFR_CNT			240
#endif			

#define VOICE_G729_DSP_XFR_CNT			176	// (for G.729A)


/****************************************************************
Description :
	This section contains functions that are used for input
	and output control of hardware pins (relays etc.)
*****************************************************************/

typedef enum {
	// all output commands
	IO_OUTPUT_INIT,
	IO_OFF_HOOK,
	IO_ON_HOOK,
	IO_SPEAKER_OFF,
	IO_SPEAKER_ON,
	IO_SPEAKER_LOW,
	IO_SPEAKER_MEDIUM,
	IO_SPEAKER_HIGH,
	IO_SPEAKER_CELL_HIGH,
	IO_CALLER_ID_ON,
	IO_CALLER_ID_OFF,
	IO_SHUNT_ON,
	IO_SHUNT_OFF,
	IO_AC_OH_RLY_ON,
	IO_AC_OH_RLY_OFF,
	IO_PSTN_ON,
	IO_PSTN_OFF,
	IO_DV_RLY_ON,
	IO_DV_RLY_OFF,
	IO_AUDIO_CODEC_ON,
	IO_AUDIO_CODEC_OFF,
	IO_LOCAL_PHONE_OFF,
	IO_LOCAL_PHONE_ON,
	IO_EEPROM_DATA_OUTPUT,
	IO_EEPROM_DATA_INPUT,
	IO_EEPROM_DATA_HIGH,
	IO_EEPROM_DATA_LOW,
	IO_EEPROM_CLOCK_OUTPUT,
	IO_EEPROM_CLOCK_INPUT,
	IO_EEPROM_CLOCK_HIGH,
	IO_EEPROM_CLOCK_LOW,
	IO_EEPROM_CS_HIGH,
	IO_EEPROM_CS_LOW,
	IO_CARRIER_DETECT_ON,
	IO_CARRIER_DETECT_OFF,
	IO_RING_INDICATE_ON,
	IO_RING_INDICATE_OFF,
	IO_DSR_ON,
	IO_DSR_OFF,
	IO_EXT_SPEAKER_OFF,
	IO_EXT_SPEAKER_ON,
	IO_OFF_HOOK_LED_OFF,
	IO_OFF_HOOK_LED_ON,
	IO_DATA_LED_OFF,
	IO_DATA_LED_TOGGLE,

	// all input commands
	IO_LOCAL_PHONE_STATE,
	IO_LOCAL_PHONE_OFFHOOK,
	IO_LOCAL_PHONE_ONHOOK,
	IO_EEPROM_DATA,
	IO_HARDWARE_ID,
	IO_YELLOW_LED_ON,
	IO_YELLOW_LED_OFF,
	IO_GREEN_LED_ON,
	IO_GREEN_LED_OFF,
	IO_OVERCURRENT_DET,
	IO_POLARITY_REV,
	IO_GOTO_SLEEP_ON,
	IO_GOTO_SLEEP_OFF,
	IO_OLD_DAA,
	HAUTE_IMPEDANCE_ON,
	HAUTE_IMPEDANCE_OFF,
	NDAA_PULSE_DIAL_BREAK,
	NDAA_PULSE_DIAL_MAKE,
	PULSE_DIAL_BREAK,
	PULSE_DIAL_MAKE,
	IO_HICID_ON,
	IO_HICID_OFF

}	IO_COMMAND ;

extern void x_output ( IO_COMMAND cmd ) ;
extern byte x_input  ( IO_COMMAND cmd ) ;

/****************************************************************
	Country codes
*****************************************************************/
#define AUSTRALIA		0x01
#define BELGIUM			0x02
#define DENMARK			0x03
#define FINLAND			0x04
#define FRANCE			0x05
#define GERMANY			0X06
#define	NETHERLANDS		0X07
#define	ITALY			0X08
#define	NEWZEALAND		0X09
#define	NORWAY			0X0A
#define	SPAIN			0X0B
#define	SWEDEN			0X0C
#define	SWITZERLAND		0X0D
#define	UK        		0X0E	// United Kingdom
#define	AUSTRIA			0X0F
#define	JAPAN			0X10
#define	PRC      		0X11	// Peoples Republic of China
#define	KOREA			0X12
#define	MALAYSIA		0X13
#define	SINGAPORE		0X14
#define	TAIWAN			0X15
#define	THAILAND		0X16
#define	INDONESIA		0X17
#define	PORTUGAL		0X18
#define	NA      		0x19	// North America (USA)
#define	IRELAND    		0x1a	
#define	HONGKONG		0x1b	
#define	CANADA			0x1c	
#define	MEXICO			0x1d	
#define	INDIA			0x1e
#define	VIETNAM			0x1f
#define	PHILIPPINES		0x20
#define	GREECE			0x21
#define	HUNGARY			0x22
#define	TURKEY			0x23
#define	SOUTHAFRICA		0x24
#define	POLAND			0x25
#define	SLOVENIA		0x26
#define	SLOVAKIA		0x27
#define	CZECHREP		0x28
#define	LUXEMBOURG		0x29
#define	EUROPE  		0x2a	// for TBR21 countries
#define	BRAZIL  		0x2b
#define	BULGARIA		0x2c
#define	CYPRUS 			0x2d
#define	ICELAND 		0x2e
#define	RUSSIA			0x2f

#ifdef COUNTRY_BLOCKING

#define START_COUNTRY_BLOCK     0xea
#define END_COUNTRY_BLOCK       0xef
#define CHKSUM_C_BLOCK_LOC      0xf0
#define CHKSUM_COUNTRY_BLOCK    0xa5
#define ONE_WORD                0x08
#define LAST_COUNTRY            RUSSIA

#endif
// -------------------   EEPROM declarations  -------------------------------
extern BOOL ll_load_modem_options ( void ) ;
extern BOOL ll_save_modem_options ( void ) ;
extern byte load_number ( word index, byte *buffer ) ;
extern byte store_number ( word index, byte *number ) ;
extern byte read_eeprom ( word ) ;
extern void write_eeprom ( word, byte ) ;

// --------------------------------------------------------------------------
//		07/17/96 - rwf
// For Dolphin & Barracuda (the x24c04 serial eeprom), a page write mechanism
// is employed for improved performance.  Each page must start on a 16 byte
// boundary and the total amount written must be divisable by 16.
// Also a page read is implemented.  Up to 256 bytes of data can be read at
// one time as long as the reads stay on the current page.
// Note: There are three bytes of overhead before the beginning of the paged
// area.
// --------------------------------------------------------------------------

#if defined (EEPROM_X24C04)
// --------------------------------------------------
// Activate the following symbol For Testing only!!!!
//#define SERIAL_EEPROM_TEST
// --------------------------------------------------
extern void read_eeprom_pg ( word, byte *, byte ) ;
extern void write_eeprom_pg ( word, byte *, byte ) ;
#endif

#define MAX_OPTION_LENGTH	112		// round up to a mult. of 16 for pg mode

#if defined (EEPROM_X24C04) || defined (THREE_WIRE_EEPROM)
#  define MAX_LOC				(512)
#  if defined( INT_MODEM ) || defined( PCMCIA_MODEM )
#    define COUNTRY_ID		(256-3)	// Internal modem required for PnP
#  else
#    define COUNTRY_ID		(144-3)	// USER_DATA must start on a 16 byte
#  endif
#else
#  define COUNTRY_ID			(0)
#  ifdef EEPROM_X24C02
#    define MAX_LOC				255
#  else
#    define MAX_LOC				750 	// max locations for eeprom - for w95
#  endif
#endif

// starting location for homologation parameter storage
#define HOMOL_START_LOC 300

#if defined( PNPSTRING )
#define PNP_EISA_BIT		(1<<0)
#define PNP_PROD_BIT		(1<<1)
#define PNP_SERNO_BIT		(1<<2)
#define PNP_DEVID_BIT		(1<<3)
#define PNP_USER_BIT		(1<<4)

#define PNP_START_LOC		(0)
#define PNP_BITMAP			(PNP_START_LOC)
#define PNP_EISA_ID			(PNP_BITMAP+1)
#define PNP_PROD_ID			(PNP_EISA_ID+3)
#define PNP_SERIAL_NO		(PNP_PROD_ID+2)
#define PNP_DEVICE_ID		(PNP_SERIAL_NO+4)
#define PNP_USER_NAME		(PNP_DEVICE_ID+40)
#define PNP_CHKSUM			(PNP_USER_NAME+40)
#define PNP_END_LOC			(PNP_CHKSUM+1)
#endif


#define CELL_PHONE_TYPE		(COUNTRY_ID+1)
#define USER_ACTIVE			(CELL_PHONE_TYPE+1)
#if defined  (EXT_MODEM)
 #define USER_DATA			256
#else
 #define USER_DATA			(USER_ACTIVE+1)
#endif
#define USER_CHKSUM			(USER_DATA+MAX_OPTION_LENGTH)
#define PHONE_ONE			(USER_CHKSUM+1)

#define MAX_PHONE_LENGTH	40
#define MAX_PHONE_NUMBERS	3

#define ETC_MODE_CELL_MASK_BIT	0x01
#define ETC_MODE_PSTN_MASK_BIT	0x02
#define ETC_MODE_MASK		0x03	//PSTN or CELL modes
#define ETC_MODE_STARTUP_MASK	0xc0
#define ETC_MODE_INIT_STARTUP_MASK_BIT	0x80
#define ETC_MODE_FB_STARTUP_MASK_BIT	0x40
#define V34_DEFAULT_OPTION	0x9650
#define V34_RX_SYMBOL_RATE	0x03ff
#define V34_MSE_SCALE		0x3800

#ifdef THREE_WIRE_EEPROM
// defines for THREE WIRE EXTERNAL MODEM XL93LC66 EEPROM
#define EE_WR_DATA_CMD				(1)
#define EE_RD_DATA_CMD				(2)
#define EE_ERASE_DATA_CMD			(3)

#define EE_WR_DISABLE_CMD			(0)
#define EE_WR_DISABLE_ADR			(0x00)
#define EE_WR_ALL_CMD				(0)
#define EE_WR_ALL_ADR				(0x40)
#define EE_ERASE_ALL_CMD			(0)
#define EE_ERASE_ALL_ADR			(0x80)
#define EE_WR_ENABLE_CMD			(0)
#define EE_WR_ENABLE_ADR			(0xc0)

#ifdef E2_X_ADR_LENGTH

#ifdef E2_2_EXTRA_BITS
# define EE_EXTRA_BITS				2
# define EE_BASE_ADR				0x40	//note-start from msb
# define EE_EXTRA_CMD_BITS			0X00
#endif

#endif	//E2_X_ADR_LENGTH

#endif	//THREE_WIRE_EEPROM

// defination for AT#UD termination cause
#define UD_TC_CAUSE_UNIDENTIIED	0
#define UD_TC_NO_CALL			0x1
#define	UD_TC_ON_PROGRESS		0x2
#define	UD_TC_DELAYED			0x4
#define UD_TC_INACT_TIME_OUT	0x19 
#define UD_TC_BLACKLISTED		0x29 
#define UD_TC_BLACKLIST_FULL	0x2A 
#define UD_TC_CALL_SETUP_TIME_OUT	0x2C 
#define UD_TC_INCOMING_CALL		0x2D
#define UD_TC_NO_DIAL_TONE		0x2F 
#define UD_TC_LONG_SPACE_DISC 	0x34
#define UD_TC_NO_CARRIER		0x3C 
#define UD_TC_TRAINING_FAIL		0x3D 
#define UD_TC_RETRAIN_FAIL		0x3F 
#define UD_TC_ANY_KEY_ABORT		0x50
#define UD_TC_DTE_HANDUP		0x51 
#define UD_TC_E_CONTROL_FAIL	0x5B 
#define	UD_TC_N400_TIME_OUT		0x5D
#define	UD_TC_RX_DISC_FRAME		0x5F

#define UD_CS_CNG_TONE			0xa
#define UD_CS_ANSWER_TONE		0x7

#define ASYNC_MODE				0x0
#define SYNC_V80_FRAME_MODE		0x1
#define SYNC_V80_TRANS_MODE		0x2

#define SYNC_TST_CMD			0x00
#define SYNC_Z80_CMD			0x01

// diagnostics - ati11 command
typedef struct {
	byte	Connection;
	word	IniTransmitRate;
	word	IniReceiveRate;
	word	FinalTransmitRate;
	word	FinalReceiveRate;
	word	NoiseLevel;
	word	ReceiveLevel;
	word	TransmitLevel;
	word	RoundTripDelay;
	word	NearEchoLevel;
	word	FarEchoLevel;
	word	TxFrameCount;
	word	TxErrorCount;
	word	RxFrameCount;
	word	RxErrorCount;
	word	LocalRetrain;
	word	RemoteRetrain;
	word	LocalRR;
	word	RemoteRR;
	byte	TerminationCause;
	word	RobbedBitPattern;
	word	lastPCMSptr;		// last valid PCM S PTR
	byte	DigitalLoss;
	byte	ud_TerminationCause;
	byte 	ud_CallResult;
	byte	ud_RetransmitCount;
} STATUS ;

#if defined(MTS_DEBUG)
	#define	LOCAL_RR_INCREMENT		(cs_insert_error_tag(0xeeee, ++G(x_status).LocalRR ) )
	#define	REMOTE_RR_INCREMENT		(cs_insert_error_tag(0xffff, ++G(x_status).RemoteRR ) )
	#define	LOCAL_RET_INCREMENT		(cs_insert_error_tag(0xbbbb, ++G(x_status).LocalRetrain ) )
	#define	REMOTE_RET_INCREMENT	(cs_insert_error_tag(0xaaaa, ++G(x_status).RemoteRetrain ) )
#else
	#define LOCAL_RR_INCREMENT		(++G(x_status).LocalRR)
	#define REMOTE_RR_INCREMENT		(++G(x_status).RemoteRR)
	#define LOCAL_RET_INCREMENT		(++G(x_status).LocalRetrain)
	#define REMOTE_RET_INCREMENT	(++G(x_status).RemoteRetrain)
#endif

#if defined(CS_MODEM)
  #define RX_LAPM_ERRORS	cs_rx_lapm_errors
  #define RX_LAPM_FRAMES	cs_rx_lapm_frames
  extern word cs_rx_lapm_errors;
  extern word cs_rx_lapm_frames;
  #define TX_LAPM_ERRORS	cs_tx_lapm_errors
  #define TX_LAPM_FRAMES	cs_tx_lapm_frames
  extern word cs_tx_lapm_errors;
  extern word cs_tx_lapm_frames;
#else
  #define RX_LAPM_ERRORS	G(x_status).RxErrorCount
  #define RX_LAPM_FRAMES	G(x_status).RxFrameCount
  #define TX_LAPM_ERRORS	G(x_status).TxErrorCount
  #define TX_LAPM_FRAMES	G(x_status).TxFrameCount
#endif

extern void at_init_diagnostics ( void ) ;
extern void dp_update_diagnostics ( void ) ;

#endif /* !Z80_ASM */

#endif	/*  __LL_GLOB_H__ */
