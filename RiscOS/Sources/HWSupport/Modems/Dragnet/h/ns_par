/*name and version number:@(#)ns_par.h	1.1*/
/*date of get: 		  09/08/00 16:22:21*/
/*date of delta:	  09/08/00 15:19:01*/
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ns_par.h
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *      - Implements the options and parameters header module of the
 *        NETWORK SIGNALLING layer of the ISDN-BRICKS product.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1999 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#ifndef NS_PAR_H
#define NS_PAR_H

								/* CARRIERS */

				/*-=-=- NETWORK OPERATORS IDS SELECTION -=-=-=-*/

/*------------------------------------------------------------------------*/

		/*
		 * Selected network flags are set to ON.
		 * Non selected network flags are set to OFF.
		 */

#define F_A11							OFF				/* ARINC CTU to  Bearer system BS */
#define F_A17							OFF				/* ARINC CTU to zone units in the CDS */
#define F_AT4							OFF				/* AT&T 4ESS (AT&T TR41459, August 1995) */
#define F_AT5							ON				/* AT&T 5ESS5 CUSTOM Flag */
#define F_AT9							ON				/* AT&T 5ESS9 NATIONAL Flag */
#define F_AU1							OFF				/* Australian Telecom 1 Flag */
#define F_BIP							OFF				/* Bellcore ISDN Primary rate, TR-NWT-001268 */
#define F_BT2							OFF				/* British Telecom ISDN2 Flag */
#define F_BV1							OFF				/* Belgian V1 Flag */
#define F_DMS							ON				/* Northern Telecom DMS100 Flag */
#define F_ETS							OFF				/* European ETSI Technical Comittee Flag */
#define F_E10							ON				/* ATT 5ESS10 CUSTOM for BRI, CUSTOM/NATIONAL for PRI (Switch 2000) */
#define F_FR4							OFF				/* Frame Relay Forum FRF.4 */
#define F_HKT							OFF				/* European Hong Kong Telephone Flag */
#define F_KDD							OFF				/* Kokusai Denshin Denwa (Japan) Flag */
#define F_KOR							OFF				/* Korean operator Flag */
#define F_NI1							ON				/* US National ISDN 1 Flag */
#define F_NI2							OFF				/* US National ISDN 2 Flag */
#define F_NTT							OFF				/* Nippon Telegraph Telephone (Japan) Flag */
#define F_QSI							OFF				/* ECMA QSIG Flag */
#define F_Q33							OFF				/* ITU Q.933 */
#define F_RTA							OFF				/* RITA */
#define F_SWD							OFF				/* Sweedish Televerket Flag */
#define F_TR6							OFF				/* Deutsche Telekom 1TR6 Flag */
#define F_VN2							OFF				/* France Telecom VN2 Flag */
#define F_VN3							OFF				/* France Telecom VN3 Flag */
#define F_VN6							OFF				/* France Telecom VN6 Flag */

#if F_ETS == ON
		/* 2 ETSI recommendations describe the Layer 3 signalling :
		 *	- ETS 300 102 : the first one
		 *	- ETS 300 403 : the new one, based on the first one but
		 *		with added AND also DELETED features/values
		 *
		 *	=> !!! ETS 300 403 is not 100 % compatible with ETS 300 102 !!!
		 *
		 *	ETS network variant inside NS is based on ETS 300 102 with
		 *	new features/values in ETS 300 403 implemented
		 *
		 *	if compile-time option FULL_ETS_300_403 is ON, the variant will be the one
		 *	described in ETS 300 403, so not fully compatible with previous one.
		 */

#	define FULL_ETS_300_403				OFF				/* ETS variant is the one described in ETS 300 403 or is fully compatible with ETS 300 102 */

#endif

#if F_QSI == ON
		/* 2 recommendations describe the Private Integrated Services Network (PISN) Layer 3 signalling :
		 * - ECMA - 143 (3rd edition - June 1997) : the first one
		 * - ETS 300 172 : the new one, based on ISO/IEC 11572 (First Edition - 1994/08/01) but
		 *		with added AND also DELETED features/values
		 *
		 * => !!! ETS 300 172 is not 100 % compatible with ISO/IEC 11572 (First Edition - 1994/08/01)
		 *
		 * QSIG network variant inside NS is based on ECMA - 143 with
		 * a few changes in ETS 300 172 implemented
		 *
		 * if compile_time option QSIG_ETS_300_172 is ON, the variant will be the one
		 * described in ETS 300 172, so not fully compatible with previous one.
		 */
#	define QSIG_ETS_300_172				OFF				/* QSIG variant is the one described in ETS 300 172 or is fully compatible with ECMA - 143 */

		/* The ATS QSIG recommendation describe the Air Traffic Services (ATS) voice communication.
		 *
		 * this variant is based on the ETS 300 172 recommendation.
		 *
		 * This ATS QSIG network variant inside NS is based on ATS QSIG - Revision 3.D.
		 *
		 */
#	define NS_QSIG_ATS					OFF				/* ATS QSIG variant */

#endif

#if (F_Q33 == ON) || (F_FR4 == ON)
		/* The Q.933 recommendation specifies the procedures for the establishing, maintaining, and clearing
		 * of Frame Mode (Frame relaying or Frame Switching) connections at the User-network interface.
		 * These procedures are defined in terms of messages and procedures at the S/T reference point for
		 * B-channel, and D-channel frame mode connection to a Frame Handler (FH) and Remote Frame Handler
		 * (FRH). These messages and procedures are applicable to both basic-rate and primary-rate 
		 * interfaces. They are generally aligned with those defined in Recommendation Q.931.
		 *
		 * The scope of this Recommendation covers the following procedures at the S/T reference point :
		 *
		 * Q933_CASE_A : circuit-switched access to a RFH by establishing B or H channel associated frame
		 * mode connections.
		 *
		 * Q933_CASE_B : establishment of a frame mode connection by using both bearer and D-channels.
		 *
		 * Q933_ANNEX_A : PVC management.
		 */

#	define Q933_CASE_A					0x01
		 /* case A : circuit-switched access to a remote frame handler by establishing
			bearer channel (B or H) associated frame mode connections. In this case,
			the frame mode network handler is provided using in-channel signalling. */

#	define Q933_CASE_B					0x02
			/* case B : access to the frame mode virtual circuit service on the local ISDN
				by establishing a frame mode connection. This connection may be initiated by
				user or the ISDN. Both bearer and D channels may be used in this case. Will be
				implemented in a near future. */

#	define Q933_ANNEX_A 				0x04
				/* annex A : this annex describes the means for notification of outage of a 
				Permanent Virtual Connection, and recovery from such a condition */

#	define FRAME_RELAY_MODE 			(Q933_CASE_A)
				/* Frame Relay selected mode */

#endif

#define NETWORK_NB						5				/* maximum implemented simultaneously running network number */

#define	NS_OPERATOR						ATT_5E10			/* was ATT_5E9 default NETWORK OPERATOR and release */
#define	NS_COUNTRY						USA			/* default country where the software is running */

/*------------------------------------------------------------------------*/

						/* NS OPTIONS */

#define MESSAGE_HEADER_IE				OFF				/* provide Message-header pseudo-IEs to CC (ON) or not (OFF) */
#define NS_NATIONAL_ESCAPE_MESSAGE		OFF				/* force the possibility to use National Escape message */
#define NS_EVENT_REPORT					OFF				/* Report events to MNS */
#define NS_T309						ON					/* Timer NS T309 option */
#define NS_SPID							OFF				/* Service Profile Identifier */
#define NS_T3DL						ON					/* Timer NS T3DL */

#define NS_SPF_CONFIG					OFF				/* Specific configuration (Needed if NS_AUTO_SWITCH/SPID is selected) */
#define NS_RESET_CONFIG				ON					/* NS reset configuration (Needed if NS_AUTO_SWITCH/SPID is selected) */
#define NS_NI_VSS						OFF				/* National ISDN Voice supplementary services (may be required for NI2 and DMS) */

#if (F_NI2 == ON) && (NS_SPID == ON)
#	define	NS_AUTO_SWITCH				OFF				/* Automatic switch detection (NI2 only) */
#	define	NS_AUTO_SPID				OFF				/* Automatic SPID detection (NI2 only) */
#endif

#if NS_AUTO_SPID == ON
#	define	NS_MX_SPID_FORMAT			40				/* Maximum nunber of SPID format description */
#	define	NS_MX_SPID_FORMAT_SZ		9				/* Size of the string describing the SPID format */
#endif

#if NS_AUTO_SWITCH == ON
#	define	NS_MX_SWITCH_COMBO			4				/* Maximum number of switch candiate for detection */
#endif

#define NS_MX_SPID						5				/* Maximum number of SPIDs used in a SPID guessing process performed by NS upon the receipt of several SPIDs from the switch */

#define NS_IE_TSP_OUT					OFF				/* OUTgoing IE are given with a Q931 format at NS interface */
#define NS_IE_TSP_IN					OFF				/* INcoming IE are also pass with Q931 format at NS interface in a second buffer */
#define NS_TYPE_BRI					ON					/* BRI access supported */
#define NS_TYPE_PRI					ON					/* PRI access supported */
#define NS_MAINTENANCE_CAPABILITY		OFF				/* maintenance messages option (with NS_TYPE_PRI only) */
#define NS_D_BACKUP						OFF				/* D channel backup (requires NS_MAINTENANCE_CAPABILITY and NS_TYPE_PRI) */
#define NS_SUPP_SERVICES				OFF				/* supplementary services supported */
#define NS_HOLD_RETRIEVE				OFF				/* Hold/Retrieve procedures supported */
#define NS_SPF_FACILITY					ON				/* network specific facility option */
#define NS_SPF_REGISTER					OFF				/* network specific use of REGISTER message (F_ETS only) */

#define NS_IE_RELAY						OFF				/* NS used as a relay for IEs : IEs may be sent and received transparently including unknown/unexpected IEs */
#define NS_IGNORE_USER_RQ_AF_CLEAR_IN	OFF				/* Requests from the user entity are ignored by NS (no error message sent - RQ can be due to
															message collision) after a NS_CLEAR_IN primitive has been sent (in call states U12 or N11) */

	/*
	 * These options are for compilation optimization purpose.
	 * If these flags are set to ON, you have the opportunity to
	 * allow or not the process of what they do by setting the
	 * parameters of the structure net_proc_param in file net_spdu.xxx
	 *	=> They are network dependent.
	 */

#define NS_SEGMENTATION					ON				/* Segmentation (may be not defined in some specifications) */
#define NS_DL_FAILURE_INT_CALL_CLEAR	ON				/* Clear internal call when data link failure */
#define NS_RESTART_PROCEDURE			ON				/* Restart procedure (may be not defined in some specifications)*/
#define NS_CONN_ACK						ON				/* Use of Connect Ack message ( only for Q-SIG ) */

#if F_QSI == ON
#define NS_FG_CONN_ORIENTED				ON				/* Bearer Independant Connection Oriented Generic Functional Generic Protocol */
#endif

	/*
	 * NS_SLICED_PROCESS (ON/OFF).
	 * When NS deals with a repetitive process (like clearing all calls
	 * present on a given Na), NS won't stop until a congestion is reached.
	 * Some applications might want NS to stop after a given number of calls,
	 * and retrieve the process after a given period of time.
	 * The first behavior is the default behavior (NS_SLICED_PROCESS == OFF).
	 * The second behavior needs NS_SLICED_PROCESS set to ON.
	 * In this case, the maximum number of actions in a row and the period of
	 * time after which the process is retrieved, are set in the dynamic
	 * configuration structure (ns_int.h)
	 */

#define NS_SLICED_PROCESS				OFF				/* Sliced process (ON/OFF) */

#if NS_SLICED_PROCESS == ON
#	define	NS_MX_ACTION_NBR			100 			/* Default number of actions to be taken in a row */
#	define	TI_RECOVER_VAL				(1 * SECOND)	/* Recover timer value */
#endif

/*------------------------------------------------------------------------*/

			/*	SUPPLEMENTARY SERVICES SUPPORTED
			 *	-> meaningful only if NS_SUPP_SERVICES is ON :
			 *	IF IT IS SET TO ON, AT LEAST 1 OF THE PARAMETERS BELOW MUST BE SET TO ON !
			 */

#define NS_COLP_COLR						OFF			/* Connected Line Identification Presentation (COLP) and Restriction (COLR) :
															These Supp services do not require 'NS_SUPP_SERVICES' parameter to be set to ON */

#if F_QSI == ON /* Q-SIG specific */
#	define NS_FAC_PROTOCOL_PROFILE			ON			/* Protocol Profile (octet 3) and Network Protocol Profile (octet 3.2) provided inside Facility IE (added in new ECMA standard) */
#	define NS_QSI_FAC_OBJECT_ID_TAG			OFF			/* Use OBJECT IDENTIFIER ASN.1 type in operator coding
															(compliant to old ECMA standards and compatible with NS version before v6.86) */
#endif

#if NS_SUPP_SERVICES == ON
#	if (F_ETS == ON) || (F_KOR == ON)	/* ETS specific supplementary services and additional network features */
#		define NS_SS_AOC_S					ON			/* 'Advice Of Charge (AOC) at call set-up time (S)' */
#		define NS_SS_AOC_D					ON			/* 'Advice Of Charge (AOC) during the call (D)' */
#		define NS_SS_AOC_E					ON			/* 'Advice Of Charge (AOC) at the end of the call (E)' */
#		define NS_SS_CUG					ON			/* 'Closed User Group' Supp Service */
#		define NS_SS_EXPL_CHAN_RESERVATION	ON			/* Explicit Channel Reservation function */
#		define NS_SS_3_PARTY				ON			/* Three-Party (3PTY) : three-way conversation */
#		define NS_SS_CONFERENCE				ON			/* Conference call, add-on (CONF) */
#		define NS_SS_USER_USER_EXP			ON			/* explicit requests for User-to-User Signalling Services(s) */
#		define NS_SS_ECT					ON			/* Explicit Call Transfer (ECT) */
#		define NS_SS_FREEPHONE				ON			/* Freephone (FPH) */
#		define NS_SS_MALICIOUS_CALL_ID		ON			/* Malicious Call Identification (MCID) */
#		define NS_SS_STATUS_REQUEST			ON			/* Status Request generic procedure */

#		define NS_SS_MAX_AOC_CHARGING_RQ	3			/* maximum number of AOCChargingRequest operations in Invoke component */
#		define NS_SS_MAX_CUG				2			/* maximum number of CUGCall operations in Invoke component */
#		define NS_SS_MAX_UUS_RQ				3			/* maximum number of User-to-User Service Request operations in Invoke component */
#	endif

#	if (F_ETS == ON) || (F_KOR == ON) || (F_QSI == ON)	/* ETS or Q-SIG specific supplementary services and additional network features */
#		define NS_SS_DIVERSION				ON			/* Diversion Supp Services (Deflection and Forward) */
#		define NS_SS_CCBS					ON			/* Completion of Calls to Busy Subscriber (CCBS) and Completion of Calls on No Reply (CCNR) */

#		define NS_SS_INTERACTIONS			ON			/* Supplementary service interactions : meaningless if only 1 Supp service is implemented */

#		define NS_MX_FAC_COMPONENTS 		4			/* maximum number of Facility components in a SPDU : it shall at least equal MX_FACILITY */
#	endif

#	if F_QSI == ON	/* Q-SIG specific supplementary services and additional network features */
#		define NS_SS_NAME_IDENT				ON			/* Name Identification (CNIP and CONP) : used in Q-SIG only */
#		define NS_SS_CALL_TRANSFER			ON			/* Call transfer (CT) : used in Q-SIG only */
#		define NS_SS_PATH_REPLACEMENT		ON			/* Path Replacement (ANF-PR) : used in Q-SIG only */
#		define NS_SS_CALL_OFFER				ON			/* Call offer (CO) : used in Q-SIG only */
#		define NS_SS_DO_NOT_DISTURB 		ON			/* Do Not Disturb (DND) and Do Not Disturb Override (DNDO) : used in Q-SIG only */
#		define NS_SS_CALL_INTRUSION 		ON			/* Call intrusion (CI) : used in Q-SIG only */
#		define NS_SS_MSG_WAITING_IND		ON			/* Message Waiting Indication (MWI) : used in Q-SIG only */
#		define NS_SS_CALL_PRIO_INT			ON			/* Call Priority Interruption : used in Q-SIG only */
#	endif
#endif

/*------------------------------------------------------------------------*/

#if SIMULATION == ON

#	define NS_RELEASE_DL				ON				/* release of the Data Link by the user */

						/* SIMULATION AND AUDIT */

#	if SIM_BUILDER == ON
#		define NS_SIM_BUILDER			ON				/* message building  : ON or OFF */
#	else
#		define NS_SIM_BUILDER			OFF				/* message building  : ON or OFF */
#	endif

#	if SIM_ANALYSER == ON
#		define NS_SIM_ANALYSER			ON				/* message analysing : ON or OFF */
#	else
#		define NS_SIM_ANALYSER			OFF				/* message analysing : ON or OFF */
#	endif

#	define DYNAMIC_MSG_BUILDER			OFF				/* Omnitel dynamic builder extension */

#else

#	if (EQUIPMENT == TE) || (EQUIPMENT == NT1_PLUS)
#		define NS_RELEASE_DL			OFF				/* release of the Data Link by the user if no more call */
#	else
#		define NS_RELEASE_DL			OFF				/* NT ---> release of the DL */
#	endif

						/* SIMULATION AND AUDIT */

#	if SIM_BUILDER == ON
#		define NS_SIM_BUILDER			ON				/* message building  : ON or OFF */
#	else
#		define NS_SIM_BUILDER			OFF				/* message building  : ON or OFF */
#	endif

#	if SIM_ANALYSER == ON
#		define NS_SIM_ANALYSER			ON				/* message analysing : ON or OFF */
#	else
#		define NS_SIM_ANALYSER			OFF				/* message analysing : ON or OFF */
#	endif

#	define DYNAMIC_MSG_BUILDER			OFF				/* Omnitel dynamic builder extension */

#endif

#define NS_AUDIT						ON				/* NS audit ON or OFF */

/*------------------------------------------------------------------------*/

				/* NETWORK SIGNALLING SIZING CONSTANTS */

#if NS_AUDIT == ON
#	define NS_MX_AUDIT					100 			/* size of the NS audit array */
#endif

#if (EQUIPMENT == NT2) || (EQUIPMENT == LE)
#	define MX_INT_PROC					12				/* Maximum number of internal processes allowed */
														/* On incoming call, a process is open for each terminal. */
#endif

#define NS_MX_IE_PRIM					36				/* maximum number of IE/primitive */
#define NS_MX_ERROR						20				/* maximum number of simultaneous errors in SPDU or SSDU */

/*------------------------------------------------------------------------*/

					/* NS CONFIGURATION STRUCTURE SIZING CONSTANTS */

#define NS_MX_NA						2				/* maximum number of logical network access supported */
														/* globally if NS_AUTO_SWITCH or NS_AUTO_SPID is ON, */
														/* otherwise, per configuration structure */

#if NS_HOLD_RETRIEVE == ON
#	define	NS_NB_HOLD_TIMER			1				/* Nb of simultaneous timers used for Hold/Retrieve procedures */
#else
#	define	NS_NB_HOLD_TIMER			0				/* Nb of simultaneous timers used for Hold/Retrieve procedures */
#endif

#	define	NB_CALL_TIMER				(4 + NS_NB_HOLD_TIMER)				/* Nb of simultaneous NS call timers */

#if NS_MAINTENANCE_CAPABILITY == ON
#	define	NS_MX_NFAS_NAI				20				/* Max number of Nais managed by a single D channel */
#	define	NS_MX_NFAS_GROUPS			3				/* Number of NFAS groups */
#endif

#if NS_SPID == ON
#	define NS_MX_SZ_SPID				20				/* maximum size (all networks included) for SPID */
#else
#	define NS_MX_SZ_SPID				0				/* null SPID size while no network specific recommendation */
#endif

/*------------------------------------------------------------------------*/

					/* NETWORK DEPENDENT OPTIONS */

#if F_AT4 == ON
#	include "at4.net_par"
#endif

#if F_AT5 == ON
#	include "at5.net_par"
#endif

#if F_AT9 == ON
#	include "at9.net_par"
#endif

#if F_BIP == ON
#	include "bip.net_par"
#endif

#if F_AU1 == ON
#	include "au1.net_par"
#endif

#if F_BV1 == ON
#	include "bv1.net_par"
#endif

#if F_BT2 == ON
#	include "bt2.net_par"
#endif

#if F_TR6 == ON
#	include "tr6.net_par"
#endif

#if F_ETS == ON
#	include "ets.net_par"
#endif

#if F_A17 == ON
#	include "a17.net_par"
#endif

#if F_A11 == ON
#	include "a11.net_par"
#endif

#if F_E10 == ON
#	include "e10.net_par"
#endif

#if F_VN2 == ON
#	include "vn2.net_par"
#endif

#if F_VN3 == ON
#	include "vn3.net_par"
#endif

#if F_VN6 == ON
#	include "vn6.net_par"
#endif

#if F_KDD == ON
#	include "kdd.net_par"
#endif

#if F_NI1 == ON
#	include "ni1.net_par"
#endif

#if F_NI2 == ON
#	include "ni2.net_par"
#endif

#if F_DMS == ON
#	include "dms.net_par"
#endif

#if F_NTT == ON
#	include "ntt.net_par"
#endif

#if F_SWD == ON
#	include "swd.net_par"
#endif

#if F_QSI == ON
#	include "qsi.net_par"
#endif

#if F_HKT == ON
#	include "hkt.net_par"
#endif

#if F_KOR == ON
#	include "kor.net_par"
#endif

#if F_Q33 == ON
#	include "q33.net_par"
#endif

#if F_FR4 == ON
#	include "fr4.net_par"
#endif

#if F_RTA == ON
#	include "rta.net_par"
#endif

/*------------------------------------------------------------------------*/

	/* Greatest <IE> repetition value (all networks included) */

#define MX_ADD_ATTRIB					1
#define MX_ADJUNCT_CON					1
#define MX_ADVICE_CHARGE				1
#define MX_AIRCRAFT_INFO				1
#define MX_ASSOC_TYPE					1

#if (F_NI2 == ON) && (NS_AUTO_SPID == ON)
#	define	MX_BC						3
#else
#	define	MX_BC						1
#endif

#define MX_CALL_APPEAR					1
#define MX_CALL_ID						1
#define MX_CALL_STATE					2
#define MX_CALLED_NB					1
#define MX_CALLED_SUB_ADD				1
#define MX_CALLING_NB					2
#define MX_CALLING_SUB_ADD				1
#define MX_CAUSE						4
#define MX_CHAN_ID						5
#define MX_CHARGING_INFO				1
#define MX_CONGEST_LEVEL				1
#define MX_CONN_NB						1
#define MX_CONN_SUB_ADD					1
#define MX_CREDIT_CARD_NUMBER			1
#define MX_CREDIT_CARD_STATUS			1
#define MX_DATE							1
#define MX_DATE_TIME					1
#define MX_DEST_CALL_APPEAR 			1
#define MX_DISPLAY						1
#define MX_DISPLAY_CON					1
#define MX_DISPLAY_FLD					9
#define MX_DLCI							1
#define MX_DTMF_2_DIALING				1
#define MX_E_T_E_TRANSIT_DLY			1
#define MX_ENDPOINT_ID					2
#define MX_ESCAPE						1
#define MX_EXTENDED_FAC					2
#define MX_FACILITY 					4
#define MX_FAC_SELECT					1
#define MX_FAC_STAT						1
#define MX_FEATURE_ACT					1
#define MX_FEATURE_IND					2

#if (F_ETS == ON) && (FULL_ETS_300_403 == ON)
#	define	MX_HLC						2		/* Changed in ETS 300 403 */
#else
#	define	MX_HLC						1
#endif

#define MX_INFORMATION_RQ				1
#define MX_KEYPAD						1
#define MX_KEYPAD_CON					1
#define MX_LINK_INTEG_VERIF				1
#define MX_LINK_LCP						1
#define MX_LINK_LPP						1
#define MX_LLC							2
#define MX_MANAGMNT						9

#if F_QSI == ON
#	define	MX_NOTIF_IND				4
#else
#	define	MX_NOTIF_IND				2
#endif

#define MX_O_CALLED_NB					1
#define MX_ORI_CALL_APPEAR				1
#define MX_OS_ACCSS						1
#define MX_OTHER_CALL_REF				1
#define MX_PACKET_LBP					1
#define MX_PARTY_CATEGORY				1
#define MX_PCS_USER						1
#define MX_PRECEDENCE_LEVEL				1
#define MX_PR4G_NUMBER					1
#define MX_PROGRESS_IND					3
#define MX_PROT_VER_CTRL				1
#define MX_PVC_STATUS					50
#define MX_QUEUE_INFO					1
#define MX_QUEUE_REQUEST				3
#define MX_REDIR_NB						2
#define MX_REDIR_SUB_ADD				1
#define MX_REDIR_SUB_ADD_NET_SPF		1
#define MX_REDIRECTION_NB				1
#define MX_REDIRECTION_NB_NET_SPF		1
#define MX_REPEAT_IND					1
#define MX_REPORT_TYPE					1
#define MX_RESTART_IND					1
#define MX_SEL_CALL_APPEAR				1
#define MX_SERVICE_ID					1
#define MX_SERVICE_IND					1
#define MX_SIGNAL						1
#define MX_SPF_FAC						4
#define MX_SPID							1
#define MX_SWITCHHOOK					1
#define MX_TE_CAP						1
#define MX_TRANSIT_COUNTER				1
#define MX_TRANSIT_NET_SEL				4
#define MX_TRAVELING_CLASS_MARK			1
#define MX_ROUTE_SELECT					1
#define MX_USER_ENTERED_CODE			1
#define MX_USER_FAC						1
#define MX_USER_MODE					1
#define MX_USER_PCS						1
#define MX_UUI							1
#define MX_X213_PRIORITY				1

/*------------------------------------------------------------------------*/

						/* DL INACTIVITY TIMER */

#define TI_DL_VAL						(90 * SECOND)	/* DL inactivity timer */
#define TI_DL_EST_VAL					(300 * SECOND)	/* DL re-establishment timer */

#define PCENT_RANDOM_TIMER				1				/* percentage used to calculate random values for timer TI_DL_EST_VAL) */

/*------------------------------------------------------------------------*/
						/* DL ENTITY */

#define NS_DL_ENTITY_ID					ENT_DL_D		/* definition of DL D entity */
#define NS_DL_F_ENTITY_ID				ENT_DL_F		/* definition of DL F entity */
#define NS_MX_DL_ENT					2				/* maximum DL entity number on a nai */
#define NS_N201							260 			/* maximum length of DL frames */

/*------------------------------------------------------------------------*/

						/* ADDRESSING RANGE */

						/*
							CONN_ID MANAGEMENT

							CAUTION : this value shall be chosen greater
							than the number of outgoing and mixed calls,
							and less than MX_CONN_ID minus the number of
							incoming calls.

		(MX_CONN_ID - Incoming) > CONN_ID_MANAGEMENT > (Outgoing + Mixed)

						*/

#define CONN_ID_MANAGEMENT				127

/*------------------------------------------------------------------------*/

						/* NS INTERFACE TYPEDEF */

typedef ushort							ns_offset_t;	/* NS interface offset type */

/*------------------------------------------------------------------------*/
						/* NS RELAY IEs */

#define NS_IE_IGNORE_SO					G_8 (1,1,1,1,1,1,1,1)	/* Ignore Single Octet IE */
#define NS_IE_IGNORE_VL					G_8 (0,0,0,0,0,0,0,1)	/* Ignore Variable Lengh IE */

/*------------------------------------------------------------------------*/

/*============================================================*

	Hooks used to restore active calls after system failure.
	--------------------------------------------------------

	1-Definition:
	  ----------

	Ns_save_active_call()	

	2-Description:
	  ------------

	This macro (function) is user dependent.

	Ns_save_active_call() is called when a call enters active state,
	so that an external process records this call.

	3-Input parameters:
	  -----------------

	nai_t		nai;			Network Access Identifier
	sapi_t		upper_sapi; 	SAPI with upper layer
	add_t		conn_id;		Conection identifier
	call_ref_t	call_ref;		Call reference value
	uchar		call_ref_lgth;	Call reference length

	4-Output parameters:
	  -----------------

	None.

	5-Return value:
	  -------------

	None.

	6-Function prototype:
	  -------------------
	void my_save_active_call (nai_t nai, sapi_t upper_sapi, add_t conn_id, call_ref_t call_ref, uchar call_ref_lgth);

	7-Example:
	  --------

	#define Ns_save_active_call(nai, upper_sapi, conn_id, call_ref, call_ref_lgth)	my_save_active_call (nai, upper_sapi, conn_id, call_ref, call_ref_lgth)

 *============================================================*

	1-Definition:
	  ----------

	Ns_clear_active_call()

	2-Description:
	  ------------

	This macro (function) is user dependent.

	Ns_clear_active_call() is called when a call leaves active state,
	so that an external process removes this call from its record.

	3-Input parameters:
	  -----------------

	nai_t		nai;			Network Access Identifier
	sapi_t		upper_sapi;		SAPI with upper layer
	add_t		conn_id;		Conection identifier

	4-Output parameters:
	  -----------------

	None.

	5-Return value:
	  -------------

	None.

	6-Function prototype:
	  -------------------
	void my_clear_active_call (nai_t nai, sapi_t upper_sapi, add_t conn_id);

	7-Example:
	  --------

	#define Ns_clear_active_call(nai, upper_sapi, conn_id)	my_clear_active_call (nai, upper_sapi, conn_id)

 *============================================================*

	1-Definition:
	  ----------

	Ns_get_saved_active_call()	

	2-Description:
	  ------------

	This macro (function) is user dependent.

	Ns_get_saved_active_call() is called when a NA is configured,
	so that an external process gives information on active calls to restore.
	Active calls are returned one by one.

	3-Input parameters:
	  -----------------

	nai_t		nai;			Network Access Identifier
	sapi_t		upper_sapi;		SAPI with upper layer

	4-Output parameters:
	  -----------------

	add_t		conn_id;		Conection identifier
	call_ref_t	call_ref;		Call reference value
	uchar		call_ref_lgth;	Call reference length

	5-Return value:
	  -------------

	CONTINUE	: an active call to restore.
	STOP		: no more active call to restore on this (nai, upper_sapi)

	6-Function prototype:
	  -------------------
	uchar my_get_saved_active_call (nai_t nai, sapi_t upper_sapi, add_t FAR * conn_id, call_ref_t FAR * call_ref, uchar FAR * call_ref_lgth);

	7-Example:
	  --------

	#define Ns_get_saved_active_call(nai, upper_sapi, p_conn_id, p_call_ref, p_call_ref_lgth)	my_get_saved_active_call (nai, upper_sapi, p_conn_id, p_call_ref, p_call_ref_lgth)

 *============================================================*

	1-Definition:
	  ----------

	Ns_save_nfas_ctx()	

	2-Description:
	  ------------

	This macro (function) is user dependent and used only in NS_D_BACKUP is ON.

	Ns_save_nfas_ctx() is called when the active D channel changes in a NFAS group,
	so that an external process records this information on active D channel in the NFAS group.

	3-Input parameter:
	  -----------------

	uchar		nfas_idx;		NFAS group index
	nai_t		nai;			Network Access Identifier bearing the active D channel

	4-Output parameter:
	  -----------------

	None.

	5-Return value:
	  -------------

	None.

	6-Function prototype:
	  -------------------
	void my_save_nfas_ctx (uchar nfas_idx, nai_t nai);

	7-Example:
	  --------

	#define Ns_save_nfas_ctx(nfas_idx, nai) my_save_nfas_ctx (nfas_idx, nai)

 *============================================================*

	1-Definition:
	  ----------

	Ns_get_saved_nfas_ctx() 

	2-Description:
	  ------------

	This macro (function) is user dependent and used only in NS_D_BACKUP is ON.

	Ns_get_saved_nfas_ctx() is called when a NA is configured,
	so that an external process gives information on active D channel in configured NFAS groups.
	NFAS group active D channels are returned one by one.

	3-Input parameter:
	  -----------------

	uchar		nfas_idx;		NFAS group index

	4-Output parameter:
	  -----------------

	nai_t		nai;			Network Access Identifier bearing the active D channel

	5-Return value:
	  -------------

	CONTINUE	: NFAS group information to restore.
	STOP		: no NFAS group information to restore.

	6-Function prototype:
	  -------------------
	uchar my_get_saved_nfas_ctx (uchar nfas_idx, nai_t FAR * p_nai);

	7-Example:
	  --------

	#define Ns_get_saved_nfas_ctx(nfas_idx, p_nai)	my_get_saved_nfas_ctx (nfas_idx, p_nai)

 *============================================================*

	1-Definition:
	  ----------

	Ns_save_chan_mode_int() 

	2-Description:
	  ------------

	This macro (function) is user dependent and used only in NS_MAINTENANCE_CAPABILITY is ON.

	Ns_save_chan_mode_int() is called when a B channel changes of maintenance state,
	so that an external process records this information on B channels maintenance state.

	3-Input parameter:
	  -----------------

	nai_t		nai;			Network Access Identifier bearing the B channel
	uchar		b_chan; 		B channel number
	uchar		state;			new B channel maintenance state

	4-Output parameter:
	  -----------------

	None.

	5-Return value:
	  -------------

	None.

	6-Function prototype:
	  -------------------
	void my_save_chan_mode_int (nai_t nai, uchar b_chan, uchar state);

	7-Example:
	  --------

	#define Ns_save_chan_mode_int(nai, b_chan, state)	my_save_chan_mode_int (nai, b_chan, state)

 *============================================================*

	1-Definition:
	  ----------

	Ns_get_saved_chan_mode_int()	

	2-Description:
	  ------------

	This macro (function) is user dependent and used only in NS_MAINTENANCE_CAPABILITY is ON.

	Ns_get_saved_chan_mode_int() is called when a NA is configured,
	so that an external process gives information on B channels maintenance state.
	B channels maintenance states are returned one by one.

	3-Input parameter:
	  -----------------

	nai_t		nai;			Network Access Identifier bearing the B channel

	4-Output parameter:
	  -----------------

	uchar		b_chan; 		B channel number
	uchar		state;			new B channel maintenance state

	5-Return value:
	  -------------

	CONTINUE	: B channel maintenance state to restore.
	STOP		: no B channel maintenance state to restore.

	6-Function prototype:
	  -------------------
	uchar my_get_saved_chan_mode_int (nai_t nai, uchar FAR * p_b_chan, uchar FAR * p_state);

	7-Example:
	  --------

	#define Ns_get_saved_chan_mode_int(nai, p_b_chan, p_state)	my_get_saved_chan_mode_int (nai, p_b_chan, p_state)

 *============================================================*/

#if 0 /* SIMULATION == ON { */

#	define	Ns_save_active_call(nai, upper_sapi, conn_id, call_ref, call_ref_lgth)				my_save_active_call (nai, upper_sapi, conn_id, call_ref, call_ref_lgth)
#	define	Ns_clear_active_call(nai, upper_sapi, conn_id)										my_clear_active_call (nai, upper_sapi, conn_id)
#	define	Ns_get_saved_active_call(nai, upper_sapi, p_conn_id, p_call_ref, p_call_ref_lgth)	my_get_saved_active_call (nai, upper_sapi, p_conn_id, p_call_ref, p_call_ref_lgth)
#	if NS_D_BACKUP == ON
#		define Ns_save_nfas_ctx(nfas_idx, nai)													my_save_nfas_ctx (nfas_idx, nai)
#		define Ns_get_saved_nfas_ctx(nfas_idx, p_nai)											my_get_saved_nfas_ctx (nfas_idx, p_nai)
#	endif
#	if NS_MAINTENANCE_CAPABILITY == ON
#		define Ns_save_chan_mode_int(nai, b_chan, state)										my_save_chan_mode_int (nai, b_chan, state)
#		define Ns_get_saved_chan_mode_int(nai, p_b_chan, p_state)								my_get_saved_chan_mode_int (nai, p_b_chan, p_state)
#	endif

#endif	/* } */

/*------------------------------------------------------------------------*/

#endif

/*EOF*/
