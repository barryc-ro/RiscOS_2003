/*name and version number:@(#)arm_glob.h	1.1*/
/*date of get: 		  12/15/00 10:10:56*/
/*date of delta:	  11/30/00 21:20:20*/
/****************************************************************
File :	arm_glob.h
Description :
	Contains #defines and variables that are global to ARM

Revision History :
	Initials	Date		Change
	JA  		11/06/00	Initial
*****************************************************************/
#ifndef __ARM_GLOB_H__
#define __ARM_GLOB_H__

#if defined(MODEM_ARM)
//# include "sa_cdefs.h"					// U32 definition

//-------------------------------------------
//				BITS
//-------------------------------------------
# define BIT0				(1<<0)
# define BIT1				(1<<1)
# define BIT2				(1<<2)
# define BIT3				(1<<3)
# define BIT4				(1<<4)
# define BIT5				(1<<5)
# define BIT6				(1<<6)
# define BIT7				(1<<7)
# define BIT8				(1<<8)
# define BIT9				(1<<9)
# define BIT10				(1<<10)
# define BIT11				(1<<11)
# define BIT12				(1<<12)
# define BIT13				(1<<13)
# define BIT14				(1<<14)
# define BIT15				(1<<15)

//----------------------------------------------------------
// EASCI/ESCC defs for the Internal BaudRate Generator (BRG)
//----------------------------------------------------------
#ifdef CLOCK_29MHZ
#define	CLOCK_FREQ		(29491200)
#endif

//----------------------------------------------------------
// EASCI clock is not divided by two
// For VENUS, the CLK_MODE is 1.
//----------------------------------------------------------
#define	CLOCK_DIVIDE	(1)
#define	CLOCK_MODE		(1)

#define	BMC_CLOCK		(CLOCK_FREQ/CLOCK_DIVIDE)

#define	BR75_2			(0)									//     75 bps
#define	BR150_2			(0)									//    150 bps
#define	BR300_2			(BMC_CLOCK/(2*CLOCK_MODE*300)-2)	//    300 bps
#define	BR600_2			(BMC_CLOCK/(2*CLOCK_MODE*600)-2)	//    600 bps
#define	BR1200_2		(BMC_CLOCK/(2*CLOCK_MODE*1200)-2)	//   1200 bps
#define	BR2400_2		(BMC_CLOCK/(2*CLOCK_MODE*2400)-2)	//   2400 bps
#define	BR4800_2		(BMC_CLOCK/(2*CLOCK_MODE*4800)-2)	//   4800 bps
#define	BR7200_2		(BMC_CLOCK/(2*CLOCK_MODE*7200)-2)	//   7200 bps
#define	BR9600_2		(BMC_CLOCK/(2*CLOCK_MODE*9600)-2)	//   9600 bps
#define	BR14400_2		(BMC_CLOCK/(2*CLOCK_MODE*14400)-2)	//  14400 bps
#define	BR19200_2		(BMC_CLOCK/(2*CLOCK_MODE*19200)-2)	//  19200 bps
#define	BR38400_2		(BMC_CLOCK/(2*CLOCK_MODE*38400)-2)	//  38400 bps
#define	BR57600_2		(BMC_CLOCK/(2*CLOCK_MODE*57600)-2)	//  57600 bps
#define	BR115200_2		(BMC_CLOCK/(2*CLOCK_MODE*115200)-2) // 115200 bps
#define	BR230400_2		(BMC_CLOCK/(2*CLOCK_MODE*230400)-2) // 230400 bps
//==========================================================================
//			END of Definitions for the BRG
//==========================================================================

#if defined( EXT_MODEM )	// {

//==========================================================================
//			Control registers for the SERIAL Channel
//==========================================================================
//---------------------------------------------
// EASCI Internal Registers for Channel 0
//---------------------------------------------
#define		ASCI_CTLA0_REG			0x00	// EASCI Cntrl Register A
#define		ASCI_CTLB0_REG			0x02	// EASCI Cntrl Register B
#define		ASCI_STAT0_REG			0x04	// EASCI Status register
#define		ASCI_TX0_REG			0x06	// EASCI Transmit Data register
#define		ASCI_RX0_REG			0x08	// EASCI Receive Data register
#define		ASCI_XCR0_REG			0x12	// EASCI Extension Cntrl register
#define		ASCI_TCLO_REG			0x1A	// EASCI Time Constant (low byte)
#define		ASCI_TCHI_REG			0x1B	// EASCI Time Constant (high byte)
#define		A0INTIN					0xD1	// EASCI Int Enable register
#define		A0NEWCTL				0xD0	// EASCI Int Status & AB register

//--------------------------------------------------------
// EASCI Control Bits for the various read/write registers
//--------------------------------------------------------
// ASCI Cntrl Register A (ASCI_CTLA0_REG)
#define		MOD_0					(1<<0)	// Mode selection
#define		MOD_1					(1<<1)	// Mode selection
#define		MOD_2					(1<<2)	// Mode selection
#define		ERROR_RESET				(1<<3)	// Error flag reset
#define		ASCI_RTS				(1<<4)	// CTS output to DTE
#define		TX_ENABLE				(1<<5)
#define		RX_ENABLE				(1<<6)

// ASCI Cntrl Register B (ASCI_CTLB0_REG)
#define		ASCI_DR					(1<<3)	// Clk mode select (0=16/1=64)
#define		ASCI_CTS				(1<<5)	// RTS input from DTE
#define		ASCI_ALL_SENT			(1<<6)	// Lst char shifted out to DTE

// ASCI Status Register (ASCI_STAT0_REG)
#define		TX_INT_ENABLE			(1<<0)
#define		TX_REG_EMPTY			(1<<1)
#define		DCD0					(1<<2)
#define		RX_INT_ENABLE			(1<<3)

// ASCI Extension Control Register (ASCI_XCR0_REG)
#define		SEND_BRK				(1<<0)
#define		BRK_DETECT				(1<<1)
#define		BRK_ENABLE				(1<<2)
#define		BRG0_MODE				(1<<3)
#define		X1_BIT_CLK				(1<<4)
#define		CTS0_DISABLE			(1<<5)
#define		DCD0_DISABLE			(1<<6)

// ASCI Interrupt Enable Register (A0INTIN)
#define		RDRF_INT_ENABLE			(1<<6)
#define		BAUD_INT_ENABLE			(1<<5)
#define		ERROR_INT_ENABLE		(1<<4)
#define		DCD_HL_INT_ENABLE		(1<<3)
#define		DCD_LH_INT_ENABLE		(1<<2)
#define		CTS_HL_INT_ENABLE		(1<<1)
#define		CTS_LH_INT_ENABLE		(1<<0)
#define		A0INTIN_VAL				RDRF_INT_ENABLE | ERROR_INT_ENABLE  \
								| DCD_HL_INT_ENABLE | DCD_LH_INT_ENABLE \
								| CTS_HL_INT_ENABLE | CTS_LH_INT_ENABLE

// ASCI Interrupt Status Register (A0NEWCTL)
#define		DCD_HL_INT_RCVD			(1<<7)
#define		DCD_LH_INT_RCVD			(1<<6)
#define		CTS_HL_INT_RCVD			(1<<5)
#define		CTS_LH_INT_RCVD			(1<<4)
#define		BAUD_DETECT				(1<<1)
#define		AUTOBAUD_EN				(1<<0)
//==========================================================================
//					END of EASCI Definitions
//==========================================================================

#else	// } { ISA || PCMCIA
#endif // }

//==========================================================================
//					Z80 Dumb Serial Port Defines
//==========================================================================
#if defined(DUMB_IOCS2) || defined(CS_RMP_DEBUG)
#define DUMB_DATA	0xc8
#else
#define DUMB_DATA	0x80
#endif
#define	DUMB_BRDL	(DUMB_DATA)
#define	DUMB_IER	(DUMB_DATA+1)
#define	DUMB_BRDH	(DUMB_DATA+1)
#define	DUMB_IIR	(DUMB_DATA+2)
#define	DUMB_LCR	(DUMB_DATA+3)
#define	DUMB_MCR	(DUMB_DATA+4)
#define	DUMB_LSR	(DUMB_DATA+5)
#define	DUMB_MSR	(DUMB_DATA+6)
#define	DUMB_SCR	(DUMB_DATA+7)

//-----------------------------------------------------
//	DIA Access Registers
//-----------------------------------------------------
# define DIAAL		(0x8)
# define DIAD		(0x9)
# define DIAAH		(0xa)

/****************************************************************************
*					Structures
****************************************************************************/
typedef enum
{
	FC_OFF,
	FC_ON
} FLOW_CONTROL;

typedef enum
{
	RUNNING,
	SOFT_RESET,
	WAITING_FOR_HARD_RESET,
	HARD_RESET
} END_SIGNAL ;

typedef enum
{
	PRINTING_ON,
	PRINTING_OFF,
	POSTMORTUM_PRINTING,
	IN_POSTMORTUM_DUMP
} PRINT_STATE;

typedef enum
{
	ROM_MODE,
	V34_MODE,
	V90_MODE,
	K56_MODE
} QMP_RX_DRIVER_MODE;

//-------------------------------------------
//		Following structures for debug
//-------------------------------------------
#if defined(SA_SEQUENCE_TEST)
typedef enum
{
	WAITING_FOR_0,
	WAITING_FOR_SEQNUM,
	PRINT_ERROR_SEQ,
	WAITING_FOR_NEXT
} SEQUENCE_CHECK;
#endif	// SA_SEQUENCE_TEST

#if defined(SA_LOOPBACK_TEST)
typedef enum
{
	LOOPBACK_TEST_OFF,
	LOOPBACK_MODE,
	GENPAT_INIT_MODE,
	GENPAT_MODE
} LOOPBACKMODE;
#endif	// SA_SEQUENCE_TEST

#if defined(SA_LAPM_DEBUG)
typedef enum
{
	SA_LAPM_DEBUG_OFF,
	SA_LAPM_DEBUG_ON,
	SA_LAPM_DEBUG_QMP_ON
} SA_LAPM_DEBUG_STATE;
#endif	// SA_LAPM_DEBUG

/****************************************************************************
*					MACROS
****************************************************************************/
#if defined( DSP_POLLED_MODE )
#define DP_INT_REGREAD(reg) dp_regread(reg)
#define DP_INT_REGREAD2(reg) dp_regread(reg)
#define DP_INT_REGWRITE(reg, value)	dp_regwrite(reg, value)

#else
#define DP_INT_REGREAD( reg )			\
  (output8( BaseAddress, (reg) ),		\
	input8(  BaseAddressData ) )

#define DP_INT_REGREAD2( reg )			\
  (output8( BaseAddress2, (reg) ),		\
	input8(  BaseAddressData ) )

//------------------------------------------------------
//		Write CAMILZ register MACRO
//------------------------------------------------------
#define DP_INT_REGWRITE( reg, value )	\
do										\
{										\
  output8( BaseAddress, (reg) ) ;		\
  output8( BaseAddressData, (value) ) ;	\
} while ( 0 )
#endif

//-------------------------------------------------------
// Macros for Hardware Timer Measurement (usecs)
//-------------------------------------------------------
#if defined(SA_TIMER_DEBUG)

#  define TIMER_A_LOAD		TIMER_3_LOAD
#  define TIMER_A_CONTROL	TIMER_3_CONTROL
#  define TIMER_A_VALUE		TIMER_3_VALUE

// ---------------------------------------- //
//			Timer A	(timer 1 or 3)			//
// ---------------------------------------- //
#  define INIT_TIMERA()						\
do {										\
	G(sa_timeA) = 0 ;						\
	saTimeA		= 0 ;						\
} while(0)

#  define START_TIMERA()					\
do {										\
	if ( AllTimerModem ||					\
		 (GET_MODEM() == OurTimerModem) )	\
	{										\
		PUT32( TIMER_A_LOAD, 0xFFFFFF ) ;	\
		PUT32( TIMER_A_CONTROL, 0x80 ) ;	\
	}										\
} while(0)

#  define SNAP_TIMERA(x)					\
do {										\
	if ( AllTimerModem ||					\
		 (GET_MODEM() == OurTimerModem) )	\
	{										\
		dword t = GET32( TIMER_A_VALUE ) ;	\
		t = (0xFFFFFF-t) / 50 ;				\
		if ( AllTimerModem )				\
		{									\
			if ( x ) saTimeA += t ;			\
			else     saTimeA  = t ;			\
		}									\
		else								\
		{									\
			if ( x ) G(sa_timeA) += t ;		\
			else     G(sa_timeA)  = t ;		\
		}									\
	}										\
} while(0)

#  define CALC_TIMERA()						\
do {										\
	if ( AllTimerModem )					\
	{										\
		if( saTimeA > saMaxTimeA )			\
			saMaxTimeA = saTimeA;			\
		saSumA += saTimeA;					\
		saCountsA++;						\
		saBinA[ saTimeA < SA_NUM_BINS ? saTimeA : SA_NUM_BINS - 1 ]++; \
	}										\
	else if ( GET_MODEM() == OurTimerModem )\
	{										\
		if( G(sa_timeA) > G(sa_max_timeA) )	\
			G(sa_max_timeA) = G(sa_timeA);	\
		G(sa_sumA) += G(sa_timeA);			\
		G(sa_countsA)++;					\
	}										\
} while(0)

# define CLEAR_TIMERA()						\
do {										\
	if ( AllTimerModem )					\
	{										\
		saMaxTimeA  = 0;					\
		saCountsA 	= 0;					\
		saSumA		= 0;					\
		for (int i = 0; i < SA_NUM_BINS; i++) \
		{									\
			saBinA[i] = 0;					\
		}									\
	}										\
	else if( GET_MODEM() == OurTimerModem )	\
	{										\
		G(sa_max_timeA) = 0;				\
		G(sa_countsA) 	= 0;				\
		G(sa_sumA)		= 0;				\
	}										\
} while(0)

// ---------------------------------------- //
//				Timer B	(timer 2)			//
// ---------------------------------------- //
#  define INIT_TIMERB()						\
do {										\
	G(sa_timeB) = 0 ;						\
	saTimeB		= 0 ;						\
} while(0)

# define START_TIMERB()						\
do {										\
	if ( AllTimerModem ||					\
		 (GET_MODEM() == OurTimerModem) )	\
	{										\
		PUT32( TIMER_2_LOAD, 0xFFFFFF ) ;	\
		PUT32( TIMER_2_CONTROL, 0x80 ) ;	\
	}										\
} while(0)

# define SNAP_TIMERB(x)						\
do {										\
	if ( AllTimerModem ||					\
		 (GET_MODEM() == OurTimerModem) )	\
	{										\
		dword t = GET32( TIMER_2_VALUE ) ;	\
		t = (0xFFFFFF-t) / 50 ;				\
		if ( AllTimerModem )				\
		{									\
			if ( x ) saTimeB += t ;			\
			else     saTimeB  = t ;			\
		}									\
		else								\
		{									\
			if ( x ) G(sa_timeB) += t ;		\
			else     G(sa_timeB)  = t ;		\
		}									\
	}										\
} while(0)

# define CALC_TIMERB()						\
do {										\
	if ( AllTimerModem )					\
	{										\
		if( saTimeB > saMaxTimeB )			\
			saMaxTimeB = saTimeB;			\
		saSumB += saTimeB;					\
		saCountsB++;						\
	}										\
	else if ( GET_MODEM() == OurTimerModem )\
	{										\
		if( G(sa_timeB) > G(sa_max_timeB) )	\
			G(sa_max_timeB) = G(sa_timeB);	\
		G(sa_sumB) += G(sa_timeB);			\
		G(sa_countsB)++;					\
	}										\
} while(0)

# define CLEAR_TIMERB()						\
do {										\
	if ( AllTimerModem )					\
	{										\
		saMaxTimeB  = 0;					\
		saCountsB 	= 0;					\
		saSumB		= 0;					\
	}										\
	else if( GET_MODEM() == OurTimerModem )	\
	{										\
		G(sa_max_timeB) = 0;				\
		G(sa_countsB) 	= 0;				\
		G(sa_sumB)		= 0;				\
	}										\
} while(0)

// ---------------------------------------- //
//				Timer C	(timer 4)			//
// ---------------------------------------- //
#  define INIT_TIMERC()						\
do {										\
	G(sa_timeC) = 0 ;						\
	saTimeC = 0 ;							\
} while(0)


# define START_TIMERC()						\
do {										\
	if ( AllTimerModem ||					\
		 (GET_MODEM() == OurTimerModem) )	\
	{										\
		PUT32( TIMER_4_LOAD, 0xFFFFFF ) ;	\
		PUT32( TIMER_4_CONTROL, 0x80 ) ;	\
	}										\
} while(0)

# define SNAP_TIMERC(x)						\
do {										\
	if ( AllTimerModem ||					\
		 (GET_MODEM() == OurTimerModem) )	\
	{										\
		dword t = GET32( TIMER_4_VALUE ) ;	\
		t = (0xFFFFFF-t) / 50 ;				\
		if ( AllTimerModem )				\
		{									\
			if ( x ) saTimeC += t ;			\
			else     saTimeC  = t ;			\
		}									\
		else								\
		{									\
			if ( x ) G(sa_timeC) += t ;		\
			else     G(sa_timeC)  = t ;		\
		}									\
	}										\
} while(0)

# define CALC_TIMERC()						\
do {										\
	if ( AllTimerModem )					\
	{										\
		if( saTimeC > saMaxTimeC )			\
			saMaxTimeC = saTimeC;			\
		saSumC += saTimeC;					\
		saCountsC++;						\
	}										\
	else if ( GET_MODEM() == OurTimerModem )\
	{										\
		if( G(sa_timeC) > G(sa_max_timeC) )	\
			G(sa_max_timeC) = G(sa_timeC);	\
		G(sa_sumC) += G(sa_timeC);			\
		G(sa_countsC)++;					\
	}										\
} while(0)

# define CLEAR_TIMERC()						\
do {										\
	if ( AllTimerModem )					\
	{										\
		saMaxTimeC  = 0;					\
		saCountsC 	= 0;					\
		saSumC		= 0;					\
	}										\
	else if( GET_MODEM() == OurTimerModem )	\
	{										\
		G(sa_max_timeC) = 0;				\
		G(sa_countsC) 	= 0;				\
		G(sa_sumC)		= 0;				\
	}										\
} while(0)

//
// ---------------------------------------- //

#else

# define INIT_TIMERA()
# define START_TIMERA()
# define SNAP_TIMERA(x)
# define CALC_TIMERA()
# define CLEAR_TIMERA()
# define INIT_TIMERB()
# define START_TIMERB()
# define SNAP_TIMERB(x)
# define CALC_TIMERB()
# define CLEAR_TIMERB()
# define INIT_TIMERC()
# define START_TIMERC()
# define SNAP_TIMERC(x)
# define CALC_TIMERC()
# define CLEAR_TIMERC()

#endif	// SA_TIMER_DEBUG

//					END MACROS
//==========================================================================

/****************************************************************************
*					GLOBAL VARS
****************************************************************************/
extern BOOL	AUTOBAUDING ;
extern BOOL	brk_to_dte_flg ;
extern word	brk_timer ;
extern word BaseAddressIndex;
extern byte BaseValue;
extern byte *datap ;
extern word firstWord;

/****************************************************************************
*					GLOBAL FCNS
****************************************************************************/
extern void _int_disable ( void ) ;
extern void _int_enable ( void ) ;

// routines in sa_prntf.c
extern void eduUartInit ( void ) ;
extern void eduPutChar ( byte ) ;
extern byte eduGetChar( void ) ;
extern BOOL eduCharAvail( void ) ;
extern void inputEDUchar ( void ) ;
extern void outputEDUchar ( void ) ;
extern void outputEDUbuff ( void ) ;

// routines in arm_util.c
extern word z80_checksum ( byte ) ;
extern void init_DSP ( void ) ;
extern byte read_eeprom ( word ) ;
extern void write_eeprom ( word, byte ) ;

// routines in arm_main.c
extern void z80_uart_cd_off ( void ) ;
extern void z80_uart_cd_on ( void ) ;
extern void z80_uart_ri_off ( void ) ;
extern void z80_uart_ri_on ( void ) ;
extern void z80_uart_dsr_off ( void ) ;
extern void z80_uart_dsr_on ( void ) ;
extern void z80_uart_break_on ( void ) ;
extern void z80_uart_break_off ( void ) ;

// routines in sa_test.c
extern word sa_test_cmd ( word , dsp_ram * ) ;
extern void sa_tstSequence( byte ) ;
extern void sa_toggleLoopBack ( void ) ;
extern void sa_loopbackDTE( void ) ;
extern void sa_procommTest( void ) ;
extern void sa_debug_init( void );
extern void sa_debug_parse( char *cmdBuf );
extern void sa_debug_port_reader( void ) ;
extern void sa_debug_port_rx_isr( void * );
extern void sa_switchDebugTerminal( dword ) ;
extern void lapm_LTF_LRQ_audit ( void ) ;	// debug

// routines in DP task
extern void venus_init ( void ) ;
extern void dsp_version_info ( void ) ;

// routines in dpisro.c
extern void sa_modemData_rx ( byte, byte, byte * ) ;
#if defined(QMP_BY_REFERENCE)
 extern byte sa_modemData_tx ( byte **, byte * ) ;
#else
 extern byte sa_modemData_tx ( byte *, byte * ) ;
#endif
extern void qmp_write ( word *, dword, byte ) ;
extern void qmp_TXwait ( void ) ;
extern byte qmp_read ( dword, word * ) ;
extern void qmp_fixed_read ( dword, word *, word ) ;
extern void dp_enab_fst_dsp ( word *, word ) ;
extern void dp_disa_fst_dsp ( void ) ;
extern void dp_blkwrt_dsp ( word * ) ;
extern void sa_downLoadK56Patch ( void ) ;
extern void sa_downLoadV34Patch ( void ) ;
extern void sa_downLoadV90Patch ( void ) ;

// routines in sa_test.c
extern void set_debugLeds( dword, byte );
extern byte get_debugLeds( dword );

// routines in allglobs.c
extern void init_SA_struct( void ) ;
extern void sa_switchModem( dword modemNum ) ;

#endif	// MODEM_ARM
#endif	// __ARM_GLOB_H__
