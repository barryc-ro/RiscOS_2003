/*name and version number:@(#)xsm_par.h	1.1*/
/*date of get: 		  09/08/00 16:24:11*/
/*date of delta:	  09/08/00 15:28:37*/

/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - sm_par.h
 *
 * $Revision$
 *
 * $Date$
 *
 * 			  Contains the SM entity paramaters
 *			  for the ISDN-BRICKS simulation servers.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|														|*/
/*|	ISDN-BRICKS  										|*/
/*|														|*/
/*|														|*/
/*|	Copyright (c) 1932 by OMNITEL SA					|*/
/*|	All Rights Reserved.								|*/
/*|														|*/
/*[]---------------------------------------------------[]*/

#define SM_PAR_LARGE_CONFIG_BUFFER			ON		/* use of the "large configuration buffer" */

#if SM_PAR_LARGE_CONFIG_BUFFER == ON
#	define SM_PAR_LARGE_CONFIG_BUFFER_SIZE	2000	/* size of the "large configuration buffer" */
#endif

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
			/*                                 */
			/*       Entities' interfaces      */
			/*                                 */
			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

#include "ns_int.h"
#include "dl_int.h"

#if DL_MLP == ON
#	include "mlp_int.h"
#endif

#include "ph_int.h"

/*-------------------------------------------------------------------------*/
/*																		   */
/*							STANDARD UPDATE ID							   */
/*																		   */
/*-------------------------------------------------------------------------*/

#define UPDATE_START_CONFIG_ID			0			/* start of configuration procedure (SM)*/
#define UPDATE_STOP_CONFIG_ID			1			/* stop of configuration procedure (SM)*/

#define UPDATE_SELECT_PROFILE_ID		2			/* Select the profile to use at reset time (DTE_INT)*/
#define UPDATE_STORE_PROFILE_ID			3			/* store profile number (DTE_INT) */

#define UPDATE_TEI_ID					200			/* TEI update ID (PAD) */
#define UPDATE_PACKET_SIZE_ID  			300			/* packet size update ID (PAD) */

/*-------------------------------------------------------------------------*/
/*																		   */
/*							USER UPDATE ID   							   */
/*																		   */
/*-------------------------------------------------------------------------*/

#define UPDATE_DEVICE_NUMBER_ID			400
#define UPDATE_DEVICE_SUB_ADDRESS_ID	401

/*-------------------------------------------------------------------------*/

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
			/*                                 */
			/*     Configuration structures    */
			/*                                 */
			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

#include "config.h"

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
			/*                                 */
			/*    Configuration update IDs     */
			/*                                 */
			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

#define UPDATE_TEI_ID		200			/* DL TEI update ID */

#define UPDATE_NA_COUNTRY	300			/* NS+CC Network access country */
#define UPDATE_NA_OPERATOR	301			/* NS+CC Network access operator */

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
			/*                                 */
			/*    Configuration update lists   */
			/*                                 */
			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/*---------------------------*/
	/* DL update parameters list */
	/*---------------------------*/

struct cfg_update CONST_ARRAY t_dl_cfg_update [] = {

	/* Update ID		update location in the dl_config_data */

	{UPDATE_TEI_ID,		(uchar FAR *)&dl_config_data.object[0].na.tei[2],
						sizeof (dl_config_data.object[0].na.tei[2])},

	{UPDATE_TEI_ID,		(uchar FAR *)&dl_config_data.object[1].na.tei[2],
						sizeof (dl_config_data.object[1].na.tei[2])},

	{UPDATE_ID_NIL},
};

	/*---------------------------*/
	/* NS update parameters list */
	/*---------------------------*/

struct cfg_update CONST_ARRAY t_ns_cfg_update [] = {

	/* Update ID		update location in the ns_config_data */

	{UPDATE_NA_COUNTRY, (uchar FAR *)&ns_config_data.i_country,
						sizeof (ns_config_data.i_country)},

	{UPDATE_NA_OPERATOR,(uchar FAR *)&ns_config_data.i_operator_type,
						sizeof (ns_config_data.i_operator_type)},

	{UPDATE_ID_NIL},
};

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
			/*                                 */
			/*       Configuration table       */
			/*                                 */
			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

struct config_descriptor CONST_ARRAY t_config [] = {

		/* CC Terminal side configuration */

	{
		ENT_CC,								/* entity id */
			(uchar FAR *)&cc_config_data_TE,/* address of configuration structure */
			sizeof (cc_config_data_TE),		/* size of configuration structure */
			P_NIL,							/* address of configuration update list */
			OFF,							/* wait flag */
	},

		/* CC Network side configuration */

	{
		ENT_CC,								/* entity id */
			(uchar FAR *)&cc_config_data_NET,/* address of configuration structure */
			sizeof (cc_config_data_NET),	/* size of configuration structure */
			P_NIL,							/* address of configuration update list */
			OFF,							/* wait flag */
	},

		/* NS Terminal side configuration */

	{
		ENT_MNS,							/* entity id */
			(uchar FAR *)&ns_config_data_TE,/* address of configuration structure */
			sizeof (ns_config_data_TE),		/* size of configuration structure */
			(struct cfg_update FAR *)&t_ns_cfg_update,
											/* address of configuration update list */
			OFF,							/* wait flag */
	},

		/* NS Network side configuration */

	{
		ENT_MNS,							/* entity id */
			(uchar FAR *)&ns_config_data_NET,/* address of configuration structure */
			sizeof (ns_config_data_NET),	/* size of configuration structure */
			(struct cfg_update FAR *)&t_ns_cfg_update,
											/* address of configuration update list */
			OFF,							/* wait flag */
	},

#ifdef NS_CONFIG_DATA_TE_2	/* defined in conf_ns.h using US variants */

		/* if NS & CC are using the SPIDs ((US variants only),
		 * then they require 2 Terminal side NAIs.
		 * See demo/ni2/conf_ns.h and demo/ni2/conf_cc.h
		 */

	{
		ENT_CC,								/* entity id */
			(uchar FAR *)&cc_config_data_TE_2,/* address of configuration structure */
			sizeof (cc_config_data_TE_2),	/* size of configuration structure */
			P_NIL,							/* address of configuration update list */
			OFF,							/* wait flag */
	},

	{
		ENT_MNS,							/* entity id */
			(uchar FAR *)&ns_config_data_TE_2,/* address of configuration structure */
			sizeof (ns_config_data_TE_2),	/* size of configuration structure */
			(struct cfg_update FAR *)&t_ns_cfg_update,
											/* address of configuration update list */
			OFF,							/* wait flag */
	},

#endif

#ifdef NS_CONFIG_DATA_AUTO_DETECT /* defined in conf_ns.h using US variants */

		/* NS SWITCH/SPID auto-detection configuration (US variants only) */

	{
		ENT_MNS,							/* entity id */
			(uchar FAR *)&ns_config_data_auto_detect,/* address of configuration structure */
			sizeof (ns_config_data_auto_detect),	/* size of configuration structure */
			(struct cfg_update FAR *)&t_ns_cfg_update,
											/* address of configuration update list */
			OFF,							/* wait flag */
	},

#endif
		/* DL Terminal side configuration */

	{
		ENT_MDL,							/* entity id */
			(uchar FAR *)&dl_config_data_TE,/* address of configuration structure */
			sizeof (dl_config_data_TE),		/* size of configuration structure */
			(struct cfg_update FAR *)&t_dl_cfg_update,
											/* address of configuration update list */
			OFF,							/* wait flag */
	},

		/* DL Network side configuration */

	{
		ENT_MDL,							/* entity id */
			(uchar FAR *)&dl_config_data_NET,/* address of configuration structure */
			sizeof (dl_config_data_NET),	/* size of configuration structure */
			(struct cfg_update FAR *)&t_dl_cfg_update,
											/* address of configuration update list */
			OFF,							/* wait flag */
	},

		/* PH layer configuration: empty in this demo because there is no
		 * real physical layer, but PH needs to receive an SM_SET_CONFIG_RQ
		 */

	{
		ENT_MPH,							/* entity id */
			P_NIL,							/* address of configuration structure */
			0,								/* size of configuration structure */
			P_NIL,							/* address of configuration update list */
			OFF,							/* wait flag */
	},

		/* APPLI layer configuration: empty in this demo because there is no
		 * real particular data to be passed to it, but PH needs to receive
		 * an SM_SET_CONFIG_RQ to start.
		 */

#if 1
	{
		ENT_APPLI,							/* entity id */
			P_NIL,							/* address of configuration structure */
			0,								/* size of configuration structure */
			P_NIL,							/* address of configuration update list */
			OFF,							/* wait flag */
	},
#endif

	/*-----------*/

	{ENT_NIL}, 				/* end of table */
};

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
			/*                                    */
			/* Configuration Table access macros  */
			/*                                    */
			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

	/*

		Sm_load_first_p_config_descriptor (p_p_descriptor, p_i)
		-------------------------------------------------------
		Sm_load_next_p_config_descriptor  (p_p_descriptor, p_i)
		-------------------------------------------------------

		These macros are used to access to one element of the configuration
		table (t_config[]).

			struct config_descriptor FAR * FAR *p_p_descriptor :
				current configuration descriptor address (passed by address)

			p_i : current index in the configuration table (passed by address)

	*/

#define Sm_load_first_p_config_descriptor(p_p_descriptor, p_i)	*p_p_descriptor = (struct config_descriptor FAR *)&t_config [0]
#define Sm_load_next_p_config_descriptor(p_p_descriptor, p_i)  	++*p_p_descriptor

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
			/*                                 */
			/*   Updates storage description   */
			/*                                 */
			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/*
		The 'p_mem_param[]' table lists all the existing update ids, giving
		for each of them the maximum size of the related update value,
		including the sizeof a mandatory field used internally by the SM
		configuration update process (PARAM_LENGTH_SIZE).
	*/

struct mem_param_descriptor CONST_ARRAY p_mem_param [] = {

	/* 	Update ID		total parameter maximum size (length + value) */

/*----------------------------------*/
/* DL update parameters description	*/
/*----------------------------------*/
	{UPDATE_TEI_ID,		1 + PARAM_LENGTH_SIZE},

	{UPDATE_ID_NIL},	/* end of list */
};

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
			/*                                 */
			/* Configuration update functions  */
			/*                                 */
			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

		/*

			Cfg_move_config_par (update_id, a_update_value, update_value_mx_sz) :
			---------------------------------------------------------------------
			Cfg_move_update_par (update_id, a_update_value, update_value_mx_sz) :
			---------------------------------------------------------------------

			These functions are user dependent and are used by the SM entity
			to transfer an initial value (for Cfg_move_config_par) or an
			updated value (for Cfg_move_update_par) of the configuration
			constant data into the buffer to be sent to the destination entity.

				uint       update_id          : ID of the update value,
				uchar FAR *a_update_value     : address where to store the
												update value,
				ushort     update_value_mx_sz : size of the update value.

		*/

#if CONFIG_UPDATE_MANAGEMENT == ON

#	define	Cfg_move_update_par(update_id, a_update_value, update_value_size) \
			sm_move_update_par (update_id, a_update_value, update_value_size)

#	define	Cfg_move_config_par(update_id, a_update_value, update_value_size) \
			sm_move_config_par (update_id, a_update_value, update_value_size)

#endif

		/*

			Cfg_set_update_par (update_id, a_update_value) :
			------------------------------------------------

			This function is user dependent and is used by an entity
			to save an update value in the safe memory area
			(this area is pointed to by 'p_sm_ram_mem' if SM_RAM.C or
			SM_STS.C is used).

				uint       update_id      : ID of the update value,
				uchar FAR *a_update_value : address of the update value to be
											copied in the safe memory area.

		*/

#if CONFIG_UPDATE_MANAGEMENT == ON

#	define	Cfg_set_update_par(update_id, a_update_value) \
			sm_set_update_par (update_id, a_update_value)

#endif

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
			/*                              */
			/* SM messages processing hooks */
			/*                              */
			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

		/*
		 *	The following macros can be defined to introduce processing
		 *	hooks into the SM entity:
		 *
		 *	- Sm_hook_before_config (p_msg):
		 *		called by SM when it receives its first message, just before
		 *		starting the configuration cycle.
		 *
		 *	- Sm_hook_after_config (p_msg):
		 *		called by SM when it receives the last configuration
		 *		confirmation message.
		 *
		 *	- Sm_hook_any_msg (p_msg):
		 *		called by SM for each received message after the
		 *		configuration cycle.
		 *
		 *	- Sm_hook_sm_report_in (p_msg):
		 *		called by SM when it receives an SM_REPORT_IN message.
		 *
		 *	- Sm_process_user_msg (p_msg):
		 *		called by SM when it does not recognize a received message.
		 *
		 *	- Sm_hook_sm_set_config_co_nok (p_msg):
		 *		called by SM when it receives an SM_SET_CONFIG_CO with
		 *		Confirm_ret_code == NOK.
		 *
		 *	If any macro is undefined, then the related hook is not
		 *	performed.
		 *
		 *	See the detailed descriptions below.
		 */

				/*--------------------------------*/
				/* SM "before configuration" hook */
				/*--------------------------------*/

		/*
		 *
		 *	Sm_hook_before_config (p_msg) :
		 *	-------------------------------
		 *
		 *
		 *	Called by SM when it receives its first message, just
		 *	before starting the configuration cycle.
		 *
		 *	Parameter:
		 *		struct message FAR *p_msg: pointer to the first message
		 *		received by SM.
		 *
		 *	Return code: OK: continue normal processing
		 *				 other: Trap.
		 *
		 *	Example :
		 *
		 *	#define Sm_hook_before_config(p_msg) sm_hook_before_config (p_msg)
		 *
		 */

#if SIMULATION == ON		/* example */

#include "simul.h"

#if NEW_FCT_STYLE == ON
	uchar sm_hook_before_config (struct message FAR *p_msg);
#else
	uchar sm_hook_before_config ();
#endif


uchar sm_hook_before_config (p_msg)
	struct message FAR *p_msg;
{
	fprintf (f_out, "\n-------------SM HOOK: Before Config-------------\n");
	return (OK);
}

#define Sm_hook_before_config(p_msg) sm_hook_before_config (p_msg)

#endif

				/*-------------------------------*/
				/* SM "after configuration" hook */
				/*-------------------------------*/

		/*
		 *
		 *	Sm_hook_after_config (p_msg) :
		 *	------------------------------
		 *
		 *	Called by SM when it receives the last configuration
		 *		confirmation message.
		 *
		 *	Parameter:
		 *		struct message FAR *p_msg: pointer to the last configuration
		 *		confirmation message received by SM.
		 *
		 *	Return code: OK: continue normal processing
		 *				 other: Trap.
		 *
		 *	Example :
		 *
		 *	#define Sm_hook_after_config(p_msg) sm_hook_after_config (p_msg)
		 *
		 */

#if SIMULATION == ON		/* example */

#if NEW_FCT_STYLE == ON
	uchar sm_hook_after_config (struct message FAR *p_msg);
#else
	uchar sm_hook_after_config ();
#endif

uchar sm_hook_after_config (p_msg)
	struct message FAR *p_msg;
{
	fprintf (f_out, "\n-------------SM HOOK: After Config-------------\n");
	return (OK);
}

#define Sm_hook_after_config(p_msg)	sm_hook_after_config (p_msg)

#endif

				/*-----------------------*/
				/* SM "any message" hook */
				/*-----------------------*/

		/*
		 *
		 *	Sm_hook_any_msg (p_msg) :
		 *	-------------------------
		 *
		 *	It is called by SM for each received message after the
		 *		configuration cycle.
		 *
		 *	Parameter:
		 *		struct message FAR *p_msg: pointer to the received message.
		 *
		 *	Return code: STOP or CONTINUE.
		 *		if it returns STOP, then SM does not perform the default
		 *		processing for this message, and exits.
		 *		The message is freed by SM before exiting.
		 *
		 *	Example :
		 *
		 *	#define Sm_hook_any_msg(p_msg)  sm_hook_any_msg (p_msg)
		 *
		 */

#if SIMULATION == ON		/* example */

#if NEW_FCT_STYLE == ON
	uchar sm_hook_any_msg (struct message FAR *p_msg);
#else
	uchar sm_hook_any_msg ();
#endif

uchar sm_hook_any_msg (p_msg)
	struct message FAR *p_msg;
{
	fprintf (f_out, "\n-------------SM HOOK: Any msg-------------\n");
	return (CONTINUE);
}

#define Sm_hook_any_msg(p_msg)	sm_hook_any_msg (p_msg)

#endif

				/*--------------------------------*/
				/* SM "unrecognised message" hook */
				/*--------------------------------*/

		/*
		 *
		 *	Sm_process_user_msg (p_msg) :
		 *	-----------------------------
		 *
		 *	Called by SM when it does not recognize a received message.
		 *
		 *	Parameter:
		 *		struct message FAR *p_msg : pointer to the received message.
		 *
		 *	Return code: void
		 *
		 *	WARNING:
		 *	--------
		 *
		 *	The message MUST be consumed by the macro, i.e. it must be
		 *	freed before exiting (by using the 'Free_msg()' macro).
		 *
		 *	Example :
		 *
		 *	#define Sm_process_user_msg(p_msg)  sm_process_user_msg (p_msg)
		 *
		 */

#if SIMULATION == ON		/* example */

#define Sm_process_user_msg(p_msg)  fprintf (f_out, "\n-------------SM HOOK: Unknown message-------------\n")

#endif

				/*-------------------*/
				/* SM_REPORT_IN hook */
				/*-------------------*/

		/*
		 *
		 *	Sm_hook_sm_report_in (p_msg) :
		 *	------------------------------
		 *
		 *	Called by SM when it receives an SM_REPORT_IN message.
		 *
		 *	Parameter:
		 *		struct message FAR *p_msg : pointer to the received message.
		 *
		 *	Return code: void
		 *
		 *	This hook is called in addition to the "any message" hook
		 *	(Sm_hook_any_msg()).
		 *
		 *	Example :
		 *
		 *	#define Sm_hook_sm_report_in(p_msg) sm_hook_sm_report_in (p_msg)
		 *
		 */

#if SIMULATION == ON		/* example */

#define Sm_hook_sm_report_in(p_msg) fprintf (f_out, "\n-------------SM HOOK: SM_REPORT_IN-------------\n")

#endif

				/*-----------------------*/
				/* SM_SET_CONFIG_CO hook */
				/*-----------------------*/

		/*
		 *
		 *	Sm_hook_sm_set_config_co_nok (p_msg) :
		 *	--------------------------------------
		 *
		 *	Called by SM when it receives an SM_SET_CONFIG_CO with
		 *	Confirm_ret_code == NOK.
		 *
		 *	Parameter:
		 *		struct message FAR *p_msg : pointer to the received message.
		 *
		 *	Return code: void
		 *
		 *	This hook is called in addition to the "any message" hook
		 *	(Sm_hook_any_msg()).
		 *
		 *	Example :
		 *
		 *	#define Sm_hook_sm_set_config_co_nok(p_msg) sm_hook_sm_set_config_co_nok(p_msg)
		 *
		 */

#if SIMULATION == ON		/* example */

#if NEW_FCT_STYLE == ON
	void sm_hook_sm_set_config_co_nok (struct message FAR *p_msg);
#else
	void sm_hook_sm_set_config_co_nok ();
#endif

void sm_hook_sm_set_config_co_nok (p_msg)
	struct message FAR *p_msg;
{
	struct buffer FAR *p_buffer;
	uchar FAR *p_data;

	p_data = L_a_data;

	fprintf (f_out, "\n-------------SM HOOK: SM_SET_CONFIG_CO[NOK] from %c, value=%d\n", Confirm_diagnostic, Confirm_cause);
}

#define Sm_hook_sm_set_config_co_nok(p_msg) sm_hook_sm_set_config_co_nok(p_msg)

#endif

/*--------------------------------------------------------------------------
 *	SM_MAX_NB_TRIGGERS : maximum number of triggers (activated and
 *						 deactivated by SM_SET_REPORT_IN) which can be
 *						 simultaneously active.
 *--------------------------------------------------------------------------*/

#define	SM_MAX_NB_TRIGGERS	1

/*EOF*/
