; >riscos.start
;
; Copyright (c) 1993 Acorn Computers Ltd., Cambridge, England.
;
; Assembler source for FPA support code and emulator
; ==================================================
; RISCOS veneer code assembled before the core routines
;

;
; character constants
;
NULL            *       &00
TAB             *       &09
LF              *       &0a
CR              *       &0d

;
; base of module SWI chunk
;
FPESWIBase      *       &40480

;
; **********************************************************************
;
; Module Header
;
        AREA    |!!!Module$Header|, CODE, READONLY

        ENTRY

Module_BaseAddr

        ASSERT  (. - Module_BaseAddr) = 0

        DCD     0                               ; Start code (there isn't any)
        DCD     FPEInit - Module_BaseAddr       ; Initialisation code
        [ {CONFIG}=32
        DCD     FPEFinal - Module_BaseAddr      ; Finalisation code
        |
        DCD     core_shutdown - Module_BaseAddr ; Finalisation code
        ]
        DCD     FPEServ - Module_BaseAddr       ; Service Call handler
        DCD     FPETitle - Module_BaseAddr      ; Title string
        DCD     FPEHelp - Module_BaseAddr       ; Help string
        DCD     0                               ; *commands (there aren't any)
        DCD     FPESWIBase                      ; SWI chunk base number
        DCD     FPESWI - Module_BaseAddr        ; SWI handler code
        DCD     FPESTable - Module_BaseAddr     ; SWI decoding table

;
; Header is complete, dump miscellaneous strings and tables
;

;
; Title string is shared with start of SWI decoding table
;
FPETitle
FPESTable
        DCB     "FPEmulator", 0
        DCB     "Version", 0
        DCB     "DeactivateContext", 0
        DCB     "ActivateContext", 0
        [ MultipleContexts
        DCB     "ChangeContext", 0
        DCB     "ContextLength", 0
        DCB     "InitContext", 0
        ]
        DCB     0
        ALIGN

BadSWIToken
        DCD     &1E6
        DCB     "BadSWI", 0
        ALIGN

;
; Despite what the current issue of the PRMs claims, ALL versions of
; the FPEmulator, whether hardware only, hardware/software, or
; software only, must have a version number greater than 4.00.  This
; allows software to easily test whether the additions to the floating
; point instruction set introduced with the FPA are available on a
; particular machine (by using RMEnsure FPEmulator 4.00).
;
        ASSERT  Module_Version >= 400

;
; **********************************************************************
;
; FPESWI - R10 to R12 may be corrupted
;
; The core routines called here will expect to be called in SVC32 mode
; if we're using the 32-bit core (ie if {CONFIG} = 32)
;
FPESWI          ROUT
        CMP     r11, #(EndOfSWIJumpTable - SWIJumpTable) / 4
        ADDLO   pc, pc, r11, LSL #2
        B       UnknownSWIError
SWIJumpTable
        B       FPESWI_Version
        [ {CONFIG} = 32
        B       FPESWI_DeactivateContext
        |
        B       core_deactivatecontext
        ]
        B       FPESWI_ActivateContext
        [ MultipleContexts
        B       FPESWI_ChangeContext
        B       FPESWI_ContextLength
        B       FPESWI_InitContext
        ]
EndOfSWIJumpTable

UnknownSWIError
        STMFD   sp!,{r0-r2,r4,lr}
        ADR     r0, BadSWIToken
        MOV     r1, #0
        MOV     r2, #0
        ADR     r4, FPETitle
        SWI     XMessageTrans_ErrorLookup
        LDMFD   sp!,{r0-r2,r4,pc}

FPESWI_Version
        LDR     r0, =Module_Version
        MOV     r11, #0
        MRS     r11, CPSR
        TST     r11, #2_11100
        MOVEQS  pc, lr                  ; 26-bit return
        MOV     pc, lr                  ; 32-bit return

        [ {CONFIG} = 32
FPESWI_DeactivateContext
        MOV     r12, lr
        MRS     r11, CPSR
        ORR     lr, r11, #&10
        MSR     CPSR_c, lr              ; Switch up to SVC32 mode
        BL      core_deactivatecontext
        MSR     CPSR_cf, r11            ; clear V
        TST     r11, #2_11100
        MOVEQS  pc, r12                 ; 26-bit return
        MOV     pc, r12                 ; 32-bit return
        ]

        ASSERT  Rwp = r10

FPESWI_ActivateContext
        CMP     r0, #-1
      [ MultipleContexts
        LDREQ   Rwp, [r12]
        ADREQ   r0, DefaultContext
      |
        LDREQ   r0, [r12]
      ]

        MOV     r12, lr
        MOV     r11, #0
        MRS     r11, CPSR
        [ {CONFIG} = 32
        ORR     lr, r11, #&10
        MSR     CPSR_c, lr              ; Switch to SVC32 mode
        ]
        MOV     r10, r0
        BL      core_activatecontext
        [ {CONFIG} =32
        MSR     CPSR_cf, r11            ; clear V
        ]
        TST     r11, #2_11100
        MOVEQS  pc, r12                 ; 26-bit return
        MOV     pc, r12                 ; 32-bit return

    [ MultipleContexts
FPESWI_ChangeContext
        CMP     r0, #-1
      [ MultipleContexts
        LDREQ   Rwp, [r12]
        ADREQ   r0, DefaultContext
      |
        LDREQ   r0, [r12]
      ]

        MOV     r12, lr
        MOV     r11, #0
        MRS     r11, CPSR
        [ {CONFIG} = 32
        ORR     lr, r11, #&10
        MSR     CPSR_c, lr              ; Switch to SVC32 mode
        ]
        MOV     r10, r0
        BL      core_deactivatecontext
        BL      core_activatecontext
        [ {CONFIG} =32
        MSR     CPSR_cf, r11            ; clear V
        ]
        TST     r11, #2_11100
        MOVEQS  pc, r12                 ; 26-bit return
        MOV     pc, r12                 ; 32-bit return

FPESWI_ContextLength
        MOV     r0, #ContextLength
        MOV     r11, #0
        MRS     r11, CPSR
        TST     r11, #2_11100
        MOVEQS  pc, lr                  ; 26-bit return
        MOV     pc, lr                  ; 32-bit return

FPESWI_InitContext
        CMP     r0, #-1
      [ MultipleContexts
        LDREQ   Rwp, [r12]
        ADREQ   r0, DefaultContext
      |
        LDREQ   r0, [r12]
      ]

        MOV     r12, lr
        MOV     r11, #0
        MRS     r11, CPSR
        [ {CONFIG} = 32
        ORR     lr, r11, #&10
        MSR     CPSR_c, lr              ; Switch to SVC32 mode
        ]
        MOV     r10, r0
        BL      core_initcontext
        [ {CONFIG} = 32
        MSR     CPSR_cf, r11            ; clear V
        ]
        TST     r11, #2_11100
        MOVEQS  pc, r12                 ; 26-bit return
        MOV     pc, r12                 ; 32-bit return

    ]


;
; **********************************************************************
;
; FPEInit - Initialisation Code
;
FPEInit         ROUT
        STMFD   sp!, {r10, lr}

;
; check whether workspace already allocated
;
        LDR     r2, [r12]
        TEQ     r2, #0
        BNE     %F5

;
; no workspace allocated - claim some
;
        MOV     r0, #ModHandReason_Claim
        LDR     r3, =WorkspaceLength
        SWI     XOS_Module

;
; return error if SWI failed
;
        LDMVSFD sp!, {r10, pc}

;
; workspace claim succeeded: zero it and save it in private word
;
        STR     r2, [r12]
5       MOV     r10, r2         ; r2 must be preserved from here on, so r10 can be reset later

;
; workspace pointer claimed if necessary, save it away in our
; private piece of page 0, ready for retrieval during traps.
;
        MOV     r0, #0
        STR     r10, [r0, #FPEAnchor]

        STRB    r0, OnVector

    [ Arm600
;
; on an Arm600 based system, control must not be passed straight along
; to the next handler, but must pass through some veneer code that is
; entered in svc26 mode and passes the call along in undef32 mode as
; if this module did not exist
;
; here we pass to the core the address of a location pointing
; to the passalong veneer (which won't actually be used until we
; get to veneer_newhandlers)

      [ {CONFIG}=32
        ADR     r1, UIVector
      |
        ADR     r1, UnwantedAddr
        ADRL    r0, PassAlong_veneer
        STR     r0, [r1]
      ]
    |
;
; load the current undefined instruction vector, and ascertain
; what flavour it is (i.e. B    <addr> or LDR pc, <addr>)
;
        MOV     r0, #Undef_vector
        LDR     r0, [r0]

        MOV     r1, r0, LSR #24
        CMP     r1, #&ea                ; 0xea?????? -> B <addr>
        BEQ     %F10

;
; vector is not B <addr>, assume it must be LDR pc, <addr> - get
; offset from bottom 12 bits of instruction
;
        MOV     r1, r0, LSL #20
        MOV     r1, r1, LSR #20

;
; now adjust for a PC relative load from vector address
;
        ADD     r1, r1, #12
      [ debug > 1
        DREG    r1, "Current vector is LDR pc, "
      ]

      [ debug > 9
        ;
        ; set r0 for debugs down below
        ;
        MOV     r0, #0
      ]
        B       %F15

;
; undefined instruction vector is of the form B <addr> - get offset
; from bottom 24 bits of instruction
;
10      AND     r0, r0, #&ff000000

;
; convert from word to byte offset, then adjust for vector address
; and instruction pipelining
;
        MOV     r0, r0, LSL #2
        ADD     r0, r0, #12

;
; save this branch target in module workspace
;
        STR     r0, UIBranchDest

     [  debug > 1
        DREG    r0, "Current vector is B "
     ]
    ]

;
; at this point r1 contains the address to be loaded into NextHandler,
; which is exactly what core_initws is expecting - load other registers
; and make the call
;
15
    [   debug > 5
        DREG    r1, "Calling core_initws with r1 = ", cc
        DREG    r10, ", r10 = "
    ]

    [   {CONFIG}=32
;
; Up into SVC32 mode to call all the core routines
;
        MRS     r3, CPSR
        ORR     r0, r3, #&10
        MSR     CPSR_c, r0
    ]

        BL      core_initws

    [ Flavour = "HardOnly"
     [  debug > 1
        DREG    r0, "SysId from core_initws = 0x"
     ]

;
; if the module only supports FPA based systems, then the absence
; of an FPA is a handicap that is best not to try to overcome
;
        CMP     r0, #SysID_FPA
        BEQ     %F20

     [ {CONFIG} = 32
        MSR     CPSR_c, r3      ; back to SVC26 mode to exit
     ]

;
; load message token. NOTE:  this is a new message, that does not
; appear in the default resources file in the RISC OS 3 ROMs, so
; it needs a default message to supply to MsgTrans.
;
        ADR     r0, NoHWMesg
        MOV     r1, #0                          ; no %0 substitution
        BL      copy_error_one

;
; return *without* restoring PSR (need to return V set)
;
        LDMFD   sp!, {r10, pc}

NoHWMesg
        DCD     ErrorBase_FloatingPoint + 6
        DCB     "NoHW:Initialisation failed: FPA not present", 0
        ALIGN
    ]

20
;
; if using multiple-context version of core, initialise our default
; context
;
    [   MultipleContexts
        ADR     r10, DefaultContext
        BL      core_initcontext
    ]

;
; Workspace is initialised, now activate the context.  Whether multiple
; contexts or not, address is already in r10.
;
        BL      core_changecontext

    [   {CONFIG} = 32
; back down to SVC26 mode
        MSR     CPSR_c, r3
    ]

;
; that's all folks
;
        CMP     r0, r0                  ; clear V
        LDMFD   sp!, {r10, pc}

     [  {CONFIG}=32
;
; **********************************************************************
;
; FPEFinal - Finalisation code
;
; all we need to do is call core_shutdown
;
; mjs 18-Feb-98 fix for Ursula (now uses FPE in 32-bit flavour)
; must not corrupt r0,r3 in service call handler (used to just push lr)
;
FPEFinal        ROUT
        STMFD   sp!,{r0,r3,lr}
        MRS     r3, CPSR
        ORR     r0, r3, #&10
        MSR     CPSR_c, r0              ; Into SVC32 mode
        BL      core_shutdown
        MSR     CPSR_cf, r3             ; clears V too
        LDMFD   sp!,{r0,r3,pc}
     ]

;
; **********************************************************************
;
; FPEServ - Service Call Handler
;
; this routine needs to check for Service_PreReset, and Service_Reset.
; on a Service_PreReset it should mimic the finalisation code (i.e.
; branch to core_shutdown); on a ServiceReset it should re-initialise the
; system if a soft-reset has just occured.
;

;mjs Updated to support Ursula format, with service table
;

        ASSERT Service_Reset < Service_PreReset
FPEServTab
        DCD     0                            ;flags word
        DCD     FPEServUrs - Module_BaseAddr ;offset to handler (skipping pre-rejection code)
        DCD     Service_Reset                ;service 1
        DCD     Service_PreReset             ;service 2
        DCD     0                            ;terminator
        DCD     FPEServTab - Module_BaseAddr ;anchor for table (precedes magic instruction)
FPEServ         ROUT
        MOV     r0, r0                       ;magic instruction to identify Ursula format
        TEQ     r1, #Service_PreReset
        TEQNE   r1, #Service_Reset
        MOVNE   pc, lr
FPEServUrs
        TEQ     r1, #Service_PreReset
    [   {CONFIG}=32
        BEQ     FPEFinal
    |
        BEQ     core_shutdown
    ]

;
; Service_Reset: read last reset type, ignore if not soft-reset
;
        STMFD   sp!, {r0-r3, lr}
        MOV     r0, #253
        MOV     r1, #0
        MOV     r2, #255

        SWI     XOS_Byte

        CMP     r1, #0
        LDMNEFD sp!, {r0-r3, pc}

;
; there has just been a soft-reset, get workspace pointer in r12
; and call initialisation routine
;
        BL      FPEInit

;
; finished
;
        LDMFD   sp!, {r0-r3, pc}

;
; **********************************************************************
;

        END

;
; EOF riscos.start
;
