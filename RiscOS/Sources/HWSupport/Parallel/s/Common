; > Common

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: common_open
;
; in:   r0  = device interrupt number to claim
;       r1  = address of device interrupt handler
;       r2  = external handle (used for calling DeviceFS)
;       r3  = flags for opening the file
;       r6 -> special field that has been decoded
;
; out:  r1  = internal handle (used in communication from DeviceFS)
;
; This call is made to allow the parallel device driver to initialise itself, ie.
; claiming any vectors it may need.
;



common_open
                ENTRY   "r2-r4"

                Debug   open,"common_open",r2

                LDRB    r4, Flags
                TST     r4, #f_OpenForRead :OR: f_OpenForWrite
                ADRNEL   r0, ErrorBlock_Parallel_InUse
                PullEnv NE

              [ international
                BNE     MakeErrorWithDeviceName
              |
                ORRNES  pc, lr, #V_bit
              ]

                STR     r2, StreamHandle                        ; stash the stream handle

                TST     r4, #f_VectorOwned                      ; do I own the vectors?
                BNE     %FT00

                MOV     r2, wp                                  ; -> code and workspace
                SWI     XOS_ClaimDeviceVector
                EXIT    VS                                      ; return any error from ClaimDeviceVector

                ORR     r4, r4, #f_VectorOwned
00
                TST     r3, #&01
                ORREQ   r4, r4, #f_OpenForRead
                ORRNE   r4, r4, #f_OpenForWrite
                STRB    r4, Flags                               ; update to indicate that the vectors are owned

                EXITS



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: common_close
;
; in:   r0  = device interrupt number to release
;       r1  = address of device interrupt handler
;       r2  = address of busy check callback handler (or 0)
;
; out:  -
;
; This call is made to allow the device to close down the routines associated
; with printing characters.
;

common_close
                ENTRY   "r2,r3"

                Debug   close,"common_close"

                ORR     lr, lr, #I_bit
                TEQP    lr, #0                                  ; disable IRQs

                TEQ     r2, #0
                LDRNEB  r3, IRQFlags
                TSTNE   r3, #if_PendingCallAfter
                BEQ     %05

                Push    "r0, r1"
                MOV     r0, r2
                MOV     r1, wp
                SWI     XOS_RemoveTickerEvent
                Pull    "r0, r1"

                BIC     r3, r3, #if_PendingCallAfter
                STRB    r3, IRQFlags

05
                LDRB    r3, Flags
                TST     r3, #f_VectorOwned                      ; is the vector owned at the moment
                BEQ     %10

                Debug   close," removing IRQ routine..."

                MOV     r2, wp                                  ; -> routines
                SWI     XOS_ReleaseDeviceVector
                PullEnv VS                                      ; return any error from ReleaseDeviceVector
                ORRVSS  pc, lr, #V_bit                          ; but ensure we set the I bit back

                BIC     r3, r3, #f_VectorOwned                  ; mark as vector no longer owned

                Debug   close," removed"
10
                BIC     r3, r3, #f_OpenForRead :OR: f_OpenForWrite
                STRB    r3, Flags

                MOV     r3, #0
                STR     r3, StreamHandle                        ; clear the output handle
                STR     r3, BufferHandle                        ; and buffer handle

                Debug   close,"finished closing stream"

                EXITS                                           ; exit restoring all flags (including I)



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: common_createTX
;
; in:   r0 = reason code (6)
;       r2 = internal stream handle
;       r3 = flags for buffer
;       r4 = size for buffer
;       r5 = buffer handle (usually -1)
;       r6 = threshold for buffer
;
; out:  above registers modified
;
; This routine is called just before the output stream is created.
;

common_createTX
                Debug   open,"common_createTX"

                CMP     r5, #-1
                MOVEQ   r5, #3          ; set the buffer handle
                MOV     pc, lr



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; call: common_createRX
;
; in:   r0 = reason code (7)
;       r2 = internal stream handle
;       r3 = flags for buffer
;       r4 = size for buffer
;       r5 = buffer handle (usually -1)
;       r6 = threshold for buffer
;
; out:  above registers modified
;
; This entry point is called just before the input stream buffer is going to
; be created.  The flags are modified so that the Halt and Resume entry points
; are called and the threshold is set.
;

common_createRX ENTRY   "r0-r2"

                Debug   open,"common_createRX"

                MOV     r0, #3                  ; change flags for parallel buffer (DeviceFS won't do this)
                ORR     r1, r3, #BufferFlags_SendThresholdUpCalls
                MOV     r2, #0
                SWI     XBuffer_ModifyFlags

                CMP     r5, #-1
                MOVEQ   r5, #3                  ; use parallel buffer
                MOV     r6, #Parallel_Threshold

                EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; call: common_get_loop_factor
;
; in:   -
;
; out:  r0 = looping factor
;
; This call is made to find a looping factor. This is a measurement of how
; fast the processor is. e.g. a 200MHz StrongArm returns r0=#268
;
; The first time it is called, calibration is performed for a while, which will
; mean that it will take longer that time. Thereafter it should be immediate.

ncpuloops * 2048	; loop this many times

common_get_loop_factor ENTRY

                Debug   open,"common_get_loop_factor"

		LDR	r0, LoopFactor
		TEQ	r0, #0			; Delay factor calibrated yet?
		BEQ	%FT20                   ; if not, calibrate
		EXITS				; else return with value in r0
20
		Push	"R1-R3"			; Okay, calibrate

		; We load Timer0 with &7FFE, and set it going. Then we go into
		; a tight loop for ncpuloops times. Then we reread the timer
		; and see how much it has gone down
		;
		; We then return 16384 (&4000) divided by this number so that we
		; return numbers which are higher when the processor is faster

		LDR	R1, =&7FFE		; 32K @@ 2MHz = ~16ms limit
		MOV	R3, #IOC		; Address of the IO controller

	        MOV     r0, r1, LSR #8
        	STRB    r1, [r3, #Timer1LL]
	        STRB    r0, [r3, #Timer1LH]
        	LDR     r0, =ncpuloops
	        STRB    r0, [r3, #Timer1GO]     ; start the timer NOW
	        B       %FT25                   ; Looks superfluous, but is required
        	                                ; to get ncpuloops pipeline breaks

25
	        SUBS    r0, r0, #1              ; 1S
        	BNE     %BT25                   ; 1N + 2S

	        STRB    r0, [r3, #Timer1LR]     ; latch count NOW
        	LDRB    r2, [r3, #Timer1CL]
	        LDRB    r0, [r3, #Timer1CH]
        	ADD     r2, r2, r0, LSL #8      ; count after looping is ...

	        SUB     r2, r1, r2              ; decrements !

		MOV	R1, #&4000		; = 16384
		DivRem	R0, R1, R2, R3		; R0 := 16384 DIV R2 (R3 is temp)

		STR	r0, LoopFactor		; save for next time

		Pull	"R1-R3"
                EXITS


		END

