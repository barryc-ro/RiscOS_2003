; > Parallel

; *******************
; *** Change List ***
; *******************

; 20-Jan-91 0.10 DDV Parallel device created, new style.
; 22-Jan-91      DDV Tidied the handling of finalise.
; 23-Jan-91      DDV Now traps Service_DeviceFSStarting/Dying.
; 23-Jan-91 0.11 DDV Calls to register to cope with new scheme.
; 25-Jan-91 0.12 DDV Fixed twee problem that stopped it printing.
; 29-Jan-91      DDV Setup so that validation strings generate an error.
; 15-Feb-91      DDV Checks made for hardware configuration.
; 17-Feb-91      DDV Device init functions added to allow devices to reset hardware.
; 17-Feb-91 0.13 DDV Semi-working 82C710 output routine added.
; 19-Feb-91      DDV IRQ routine for 82C710 improved.
; 20-Feb-91 0.14 DDV Finished changes to IRQ routine.
; 27-Feb-91      DDV Tweeked 827C10 interrupt routine changed, now uses Busy as IRQ source.
; 27-Feb-91      DDV Now sets up PrinterType$1 to use parallel:Output
; 27-Feb-91      DDV Added 'buffer,n' to validation string so kernel can specify which buffer to use.
; 27-Feb-91      DDV Removed IEOB input conditions.
; 28-Feb-91      DDV Validation string changed + default system var.
; 06-Mar-91      DDV Added configure/status command for buffer size.
; 06-Mar-91      DDV Reads CMOS bits for buffer size on module init.
; 06-Mar-91 0.15 DDV Handles value from special field correctly.
; 07-Mar-91      DDV Bug fix; CMOS read no longer corrupts all registers.
; 07-Mar-91      DDV Bug fix; DeviceFS table for IOEB now has miscop entry correctly placed.
; 07-Mar-91      DDV Contents of PrinterType$1 changed to include buffer handle.
; 07-Mar-91 0.16 DDV Bug fix; Decode of special field now gets buffer handle correctly.
; 07-Mar-91      DDV Bug fix; IOC IRQ busy routine checked the IRQ mask not IRQ status.
; 08-Mar-91      DDV Removed configure command for buffers.
; 11-Mar-91      DDV Added calls to Buffer_Unlink device to ensure buffer free'd.
; 11-Mar-91 0.17 DDV When DeviceFS starting service is recieved it will use SWIs, not call addresses.
; 12-Apr-91      DDV Internationalised.
; 12-Apr-91      DDV Added machine type checking.
; 12-Apr-91      DDV Added Parallel_HardwareAddress SWI.
; 12-Apr-91      DDV Clearing edge triggered interrupt on 710 added.
; 12-Apr-91      DDV Split again into some more useful files.
; 12-Apr-91      DDV Intergration with new DeviceFS
; 13-Apr-91 0.18 DDV Added new parameter to return IOEB update address.
; 17-Apr-91      DDV Tightened up coding for internationalisation.
; 18-Apr-91 0.19 DDV Bug fix; fixed stack inbalance.
; 21-Apr-91      DDV Changed to use IOEB binding for PINTR
; 21-Apr-91      DDV Now traps Service_DeviceDead.
; 21-Apr-91 0.20 DDV Changed system variable being used.
; 01-May-91 0.21 DDV Changed to cope with Jon's changes in special fields.
; 03-May-91 0.22 DDV Moved clear of the PINTR latch to end of IRQ routine.
; 16-Jul-91 0.23 TMD Made unknown SWI use global message.
;                    Recoded IRQ routines.
; 22-Jul-91 0.24 TMD Moved clearing of printer acknowledge to inside strobe
;                    routine (ie its now also called from dormant state).
;                    This is to clear any fake acknowledge signals caused by
;                    printer power-on.
; 30-Jul-91 0.25 TMD Put in CallAfters to poll busy when dormant.
;                    Improved strobe timing (doesn't use timers any more -
;                    they took too long)
; 31-Jul-91 0.26 TMD Changed device record to add reserved field
;                    Service_Reset code only executed on soft reset
; 08-Aug-91 0.27 TMD Fixed bug in SWI despatch
;                    Fixed bug in busy callafter code (was removing callafter without saving lr_svc)
; 22-Aug-91 0.28 TMD Base of errors changed
;                    Put in code that recognises 82C711
; 20-Nov-91 0.29 TMD Changed code that recognises 710/711 to check parallel sub-unit type
; 05-Dec-91 0.30 SMC Added parallel input stream
;                    Added SWI Parallel_Op
; 13-Dec-91 0.31 SMC Now only uses one local error message, the rest are global.
; 03-Feb-92 0.32 JSR Adjust service call entry for changed Service_MessageFileClosed.
; 02-Mar-92 0.33 TMD Added option to check busy after acknowledge pulse.
;                    Tidied up a few atomicity failures.
; 17-Mar-92 0.34 TMD Made it poll busy 20 times before rescheduling, for printers where
;                    busy always goes low after ack goes high.
; 21-Jun-93 0.35 SMC Now uses BufferManager service routines, not INSV/REMV.
;                    On read signal busy with nSlctIn and nAutoFd (for ECP cables).
;                    Created file Common to isolate files IOC, IOEB.
;                    Added file FastCent with driver for fastparallel: device (parallel FIFO).
; 29-Jun-93 0.36 SMC On IOMD based platforms clear PINTR in IRQCLRA, not using PINTR_Latch.
; 14-Jul-93 0.37 SMC OS_ReadSysInfo interface changed.
; 31-Aug-93 0.38 SMC Set ECR before CTRL as they are the same register in standard mode.
; 13-Dec-93 0.39 SMC Time out when waiting for PACK high after interrupt (prevent hang on printer off).
; 21-Jan-94 0.40 SMC Create for TX/RX should only have set the buffer id to 3 if it was -1.
; 20-Jul-94 0.41 RCM Added power saving code (active ONLY for portables) see StorkPower flag.
; 26-Jul-94 0.42 RCM Added conditional assembly flags OldHardware & NewHardware.
;                    Set OldHardware to false to save ROM space for RO Black.
; 13-Aug-94 0.43 ??? ??????????
; 18-Mar-97 0.44 JIFL Added timing loop function common_get_loop_factor to
;		     ensure processor speed independence
; 29 Apr 97 0.45 JRC Calculate loop factor in init code; added Paper, OnLine, Printer message tokens;
;                    make appropriate upcalls in ioeb_monitorTX when paper out etc; use
;                    ParallelDeviceDriver$Path for resources; added 'j' debug flag.

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                GET     Hdr:ListOpts
                GET     Hdr:Macros
                GET     Hdr:System
                GET     Hdr:ModHand
                GET     Hdr:FSNumbers
                GET     Hdr:NewErrors
                GET     Hdr:Services
                GET     Hdr:Symbols
                GET     Hdr:NDRDebug
		GET	Hdr:HostFS
                GET     Hdr:Proc
                GET     Hdr:DevNos
                GET     Hdr:PublicWS
                GET     Hdr:DDVMacros
                GET     Hdr:Buffer
                GET     Hdr:DeviceFS
;                GET     Hdr:IOEB
;                GET     Hdr:IOMD
                GET     Hdr:IO.IOC-A1
                GET     Hdr:IO.IOEB
                GET     Hdr:CMOS
                GET     Hdr:MsgTrans
                GET     Hdr:ResourceFS
                GET     Hdr:Portable
                GET     Hdr:UpCall

                GBLL    debug
                GBLL    hostvdu
                GBLL    international

                GBLL    CheckBusyAfterAck       ; whether to check busy after acknowledge pulse

CheckBusyAfterAck SETL  {TRUE}

                GBLL    FastBufferMan
FastBufferMan   SETL    {TRUE}

                GBLL    FastCentronics
FastCentronics  SETL    {TRUE}

                GBLL    StorkPower
StorkPower      SETL    {TRUE}                  ; try powering down the hardware when not in use

                GBLL    OldHardware             ; assemble code for old serial hardware?
OldHardware     SETL    {FALSE} ;{TRUE}         ; switched off to save space for RO Black

                GBLL    NewHardware             ; assemble code for new serial hardware (ie PC combo chips)
NewHardware     SETL    {TRUE}

; The following are defined because the new buffer manager interface uses r2 to
; insert and remove bytes whereas the old interface uses r0.
 [ FastBufferMan
tmp     RN      0
byte    RN      2
 |
byte    RN      0
tmp     RN      2
 ]

		[	:LNOT: :DEF: standalonemessages
                GBLL    standalonemessages
standalonemessages SETL {FALSE}
		]

debug           SETL    false
hostvdu         SETL    false
international   SETL    true
debug_file	SETS	"Custom:Debug.parallel"

inter           SETD    true
open            SETD    true
close           SETD    true
out             SETD    true
in              SETD    true
irq             SETD    true
j		SETD	true

                GET     Version
                GET     s.Errors

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Macros
;

 [ FastBufferMan
; Calls buffer manager service routine (corrupts lr).
                MACRO
$label          CallBuffMan     $cc

$label          Push    "r12"                                   ; save our workspace ptr
                ADR$cc   r12, BuffManWkSpace                    ; place of buffman wkspace and entry
                MOV$cc   lr, pc                                 ; return address
                ASSERT  BuffManService = BuffManWkSpace+4
                LDM$cc.IA r12, {r12, pc}                        ; load buffman wkspace and entry
                Pull    "r12"                                   ; restore our workspace ptr

                MEND
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Device workspace.
;

                        ^ 0, wp
Flags                   # 1             ; global flags used by module, updated only in foreground
IRQFlags                # 1             ; flags updated from IRQs, or from foregd with IRQs off
                        # 2             ; align
BufferHandle            # 4             ; handle for read/write buffer
StreamHandle            # 4             ; handle for output data
DeviceHandle            # 4             ; handle for device (from DeviceFS)
HardwareType            # 4             ; hardware type
HardwareBase            # 4             ; hardware base address return by calls
ByteBuffer              # 4             ; place to hold byte which couldn't be buffered
 [ FastCentronics
FastHandle              # 4             ; handle for fast device
 ]
 [ FastBufferMan
BufferId                # 4             ; buffer managers iternal buffer id
BuffManWkSpace          # 4             ; buffer managers workspace pointer
BuffManService          # 4             ; address of buffer manager service routine
 ]
 [ StorkPower
portable_present        # 4             ;  = 0 if we don't think the Portable module is present
                                        ;  = 1 if we do
power_state             # 4             ;
 ]
                      [ international
MessagesWorkspace       # 16            ; block of workspace for opening message files
localerrorblock		# 256		; do not use MessageTrans error block, as it gets trashed too easily
                      ]

LoopFactor		# 4		; factor for tight loops giving a delay
					; of 1us

wsrequired              * :INDEX: @


; constants about workspace

; Bits in Flags

f_VectorOwned           * 1:SHL:0       ; bit 0 set => IRQ vector owned
f_WeHaveMessages        * 1:SHL:1       ; bit 1 set => messages file loaded
f_OpenForRead           * 1:SHL:2       ; bit 2 set => open for read
f_OpenForWrite          * 1:SHL:3       ; bit 3 set => open for write
 [ FastCentronics
f_UseFIFO               * 1:SHL:4       ; bit 4 set => register fastparallel: device
 ]

; Bits in IRQFlags

if_PendingCallAfter     * 1:SHL:0       ; bit 0 set => pending CallAfter exists
if_ReadHalted           * 1:SHL:1       ; bit 1 set => input stream halted

; default flags for DeviceFS_Register
 [ NewHardware
dfsr_flags		* ParentFlag_MonitorTransfers ; Monitor TX/RX functions available
 |
dfsr_flags		* 0
 ]

hardware_IOC            * 0             ; which hardware type being used
hardware_IOEB           * 1
hardware_IOMD           * 2             ; similar to IOEB but has Pintr clear, not external latch

BusyCheckInterval       * 50            ; time between busy checks (centiseconds)

Parallel_Threshold      * 1016

ParallelPowerBits       * PortableControl_ParallelEnable

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Now we have the module header, this defines all the entry points required
; for the module.
;

                LEADR   Module_LoadAddr

Module_BaseAddr & 0
                & init -Module_BaseAddr                 ; init code
                & final -Module_BaseAddr                ; final code
                & service -Module_BaseAddr              ; service code

                & title -Module_BaseAddr                ; title string for module
                & help -Module_BaseAddr                 ; help string pointer
                & 0

                & ParallelSWI_Base
                & swicode -Module_BaseAddr
                & switable -Module_BaseAddr
                & 0

title           = "ParallelDeviceDriver",0
help            = "Parallel Device",9,"$VString ($Date)"
              [ debug
                = " Development version"
              ]
                = 0
                ALIGN

switable        = "Parallel", 0
                = "HardwareAddress", 0
                = "Op", 0
                = 0

 		[	international
		!	0, "Internationalised version"
resource_file   =	"ParallelDeviceDriver:Messages", 0
		]
                ALIGN

                MakeErrorBlock Parallel_BadCall
                MakeErrorBlock Parallel_BadHardware
                MakeErrorBlock Parallel_InUse
		MakeErrorBlock Parallel_PaperOut
		MakeErrorBlock Parallel_Offline
		MakeErrorBlock Parallel_OtherError

                ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Now data passed to the device register call.
;

setsysvar       = "Set PrinterType$1 devices#buffer3:$."
devicename      = "Parallel", 0
 [ FastCentronics
fastname        = "FastParallel",0
 ]
                ALIGN

block
                & devicename -.         ; offset to device name
                & DeviceFlag_BufferedDevice+ DeviceFlag_DefinePathVariable ; flags
                & 0                     ; default RX buffer flags
                & 1024                  ; default RX buffer size
                & 0                     ; default TX buffer flags
                & 1024                  ; default TX buffer size
                & 0                     ; reserved field (must be zero)

                & 0                     ; end of list marker

 [ FastCentronics
fastblock
                & fastname -.           ; offset to device name
                & DeviceFlag_BufferedDevice+ DeviceFlag_DefinePathVariable ; flags
                & 0                     ; default RX buffer flags
                & 0                     ; default RX buffer size
                & 0                     ; default TX buffer flags
                & 1024                  ; default TX buffer size
                & 0                     ; reserved field (must be zero)

                & 0                     ; end of list marker
 ]

                ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setvar	=	"If ""<ParallelDeviceDriver$Path>"" = """" then "
	=	"Set ParallelDeviceDriver$Path Resources:$.Resources.Parallel."
	=	0 ;so lazy!

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Now we must handle the module init calls.
;

init            ENTRY   "r7"

                LDR     r2, [wp]
                TEQ     r2, #0                                  ; any workspace?
                BNE     %FT10                                   ; yes, so handle as warm start

                MOV     r0, #ModHandReason_Claim
                LDR     r3, =wsrequired
                SWI     XOS_Module                              ; claim it
                EXIT    VS                                      ; return if it errored

                STR     r2, [wp]
10
                MOV     wp, r2                                  ; wp -> workspace

		[	debug
		Debug_Open debug_file
		]

		Debug	j, "initialised"

        [ standalonemessages
                ADR     r0, resourcefsfiles
                SWI     XResourceFS_RegisterFiles   ; ignore errors (starts on Service_ResourceFSStarting)
        ]

		ADR	r0, setvar
		SWI	XOS_CLI
		EXIT	VS

                MOV     r0, #0                                  ; zap workspace
                STRB    r0, Flags
                STRB    r0, IRQFlags
                STR     r0, StreamHandle
                STR     r0, DeviceHandle
                STR     r0, BufferHandle
                STR     r0, HardwareBase
		BL	common_get_loop_factor
        [ FastCentronics
                STR     r0, FastHandle
        ]
        [ FastBufferMan
                STR     r0, BufferId
                STR     r0, BuffManService
                STR     r0, BuffManWkSpace
        ]

                MOV     r0, #2                                  ; read machine information
                SWI     XOS_ReadSysInfo
                EXIT    VS                                      ; return any errors generated

                BIC     r0, r0, #&FF :SHL: 24                   ; not interested in video controller
                BIC     r0, r0, #&FF :SHL: 16                   ; or memory controller
                AND     r1, r1, #&FF                            ; only interested in I/O chip type

 [ OldHardware
                TEQ     r0, #&0000                              ; is it an A1 series machine?
                MOVEQ   r0, #hardware_IOC
                BEQ     %20
 ]
 [ NewHardware
                TEQ     r0, #&0001                              ; has it got IOEB
                TEQNE   r0, #&0100                              ; or IOMD
                TEQEQ   r1, #&01                                ; and an 82C710/711 (or similar)
                BNE     %15                                     ; no, so report error

                TEQ     r0, #&0001
                MOVEQ   r7, #hardware_IOEB
                MOVNE   r7, #hardware_IOMD

                MOV     r0, #3                                  ; read version fields for each sub-unit
                SWI     XOS_ReadSysInfo
                EXIT    VS
                AND     r0, r0, #(15 :SHL: 8)                   ; extract parallel sub-unit version
                TEQ     r0, #(1 :SHL: 8)                        ; if not type 1 then
                BNE     %15                                     ;   report error

        [ FastCentronics
                AND     r1, r1, #(15 :SHL: 8)                   ; extract extra features
                TEQ     r1, #(1 :SHL: 8)                        ; if we can use fast centronics then
                LDREQB  r0, Flags                               ;   set flag
                ORREQ   r0, r0, #f_UseFIFO
                STREQB  r0, Flags
        ]
                MOV     r0, r7                                  ; hardware OK
                B       %20
 ]
15
                ADRL    r0, ErrorBlock_Parallel_BadHardware
                PullEnv
                DoError                                         ; generate error about invalid hardware platform
20
                STR     r0, HardwareType                        ; store in workspace

                BL      registerdevice                          ; register the device
                ADRVC   r0, setsysvar
                SWIVC   XOS_CLI                                 ; setup system variable
 [ StorkPower
                EXIT    VS                                      ; return any errors generated

                MOV     r0, #1                                  ; pretend portable module present
                STR     r0, portable_present                    ; at least until we know better
                LDR     r0, =ParallelPowerBits
                STR     r0, power_state                         ; show power_state as ON, to
                BL      SetPower_Off                            ; force SetPower_Off to call XPortable_Control
 ]
                EXITS

                LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle the module close down.
;

final           ENTRY

                LDR     wp, [wp]                                ; setup workspace pointer

                LDR     r0, StreamHandle
                TEQ     r0, #0                                  ; are any of the outputs being used
                PullEnv NE
                ADRNE   r0, ErrorBlock_Parallel_InUse

        [ international
                BNE     MakeErrorWithDeviceName
                BL      CloseMessages                           ; just incase, ok so I am paraniod
        |
                ORRNES  pc, lr, #VFlag
        ]

        [ standalonemessages
                ADR     R0, resourcefsfiles
                SWI     XResourceFS_DeregisterFiles
        ]

                LDR     r0, DeviceHandle
                TEQ     r0, #0                                  ; is device registered?
                SWINE   XDeviceFS_Deregister                    ; remove device from being active

        [ FastCentronics
                LDR     r0, FastHandle
                TEQ     r0, #0
                SWINE   XDeviceFS_Deregister
        ]

		Debug	j, "terminated"

		[	debug
		Debug_Close
		]

                EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle service calls.
;

service         ROUT
                TEQ     r1, #Service_Reset
                TEQNE   r1, #Service_DeviceFSStarting
                TEQNE   r1, #Service_DeviceFSDying
                TEQNE   r1, #Service_DeviceDead
 [ StorkPower
                TEQNE   r1, #Service_Portable
 ]
 [ standalonemessages
                TEQNE   r1, #Service_ResourceFSStarting
 ]
                MOVNES  pc, lr

                LDR     wp, [wp]                                ; wp -> workspace

                TEQ     r1, #Service_Reset
                BEQ     svc_reset                               ; machine reset pending

                TEQ     r1, #Service_DeviceFSStarting
                BEQ     svc_starting                            ; handle the fs starting again

                TEQ     r1, #Service_DeviceFSDying
                BEQ     svc_devfsdead                           ; DeviceFS reseting...

        [ standalonemessages
                TEQ     r1, #Service_ResourceFSStarting
                BNE     %FT10
                Push    "r0-r3,lr"
                ADR     r0, resourcefsfiles
                MOV     lr, pc
                MOV     pc, r2
                Pull    "r0-r3,pc",,^
10
        ]

        [ StorkPower
                TEQ     r1, #Service_Portable
                BNE     %FT40
                TEQ     r2, #ServicePortable_PowerDown
                BNE     %FT35

                Push    "r0,r2,lr"
                MOV     lr, #1
                STR     lr, portable_present            ; indicate portable module present
                LDR     lr, =ParallelPowerBits
                TST     r3, lr                          ; are they trying to power down parallel port
                Pull    "r0,r2,pc",EQ,^                 ; no then just pass on the service

                LDRB    r0, Flags                       ; if open for reading or writing
                TST     r0, #f_OpenForRead :OR: f_OpenForWrite  ; then complain
                BEQ     %FT32                           ; [both closed, so OK]
                BICS    r3, r3, lr                      ; by clearing the parallel bits
                MOVEQ   r1, #0                          ; and if there are no more bits being turned off
                Pull    "r0,r2,pc",,^                   ; then claim service to save time
32
                LDR     r0, power_state                 ; update our record of which bits are on
                BIC     r0, r0, r3
                STR     r0, power_state
                Pull    "r0,r2,pc",,^

35
                TEQ     r2, #ServicePortable_PowerUp    ; bits being powered up
                MOVNES  pc, lr
                Push    "r0,r3,lr"
                MOV     lr, #1
                STR     lr, portable_present            ; indicate portable module present
                LDR     lr, =ParallelPowerBits
                AND     r3, r3, lr                      ; just get parallel bits which are being powered up
                LDR     r0, power_state
                ORR     r0, r0, r3                      ; and or them into our current state
                STR     r0, power_state
                Pull    "r0,r3,pc",,^

40
        ]

; must be device dead, we've checked for all the rest, so drop thru to ...

svc_devicedead
                Push    "lr"

                LDR     lr, DeviceHandle
                TEQ     lr, r2                                  ; is it my device being killed, don't bother checking r3.
                STREQ   r0, DeviceHandle                        ; yep, so write the value.

        [ FastCentronics
                LDR     lr, FastHandle
                TEQ     lr, r2
                STREQ   r0, FastHandle
        ]

                Pull    "pc",,^

svc_reset
                Push    "r0-r2, lr"

                MOV     r0, #&FD                                ; read last reset type
                MOV     r1, #0
                MOV     r2, #&FF
                SWI     XOS_Byte
                TEQ     r1, #0

                Pull    "r0-r2, pc",NE,^                        ; if hard reset, do nothing

                BL      svc_devfsdead                           ; reset the variables etc...

                LDR     r0, HardwareType
                TEQ     r0, #hardware_IOC                       ; reset the relevant hardware
;                BLEQ    IOCreset                               ; (doesn't need to do anything on old hardware)
                BLNE    IOEBreset

                Pull    "r0-r2, pc",,^

svc_devfsdead
                Push    "lr"

                MOV     lr, #0                                  ; zap buffer handles
                STR     lr, DeviceHandle
                STR     lr, StreamHandle
                STR     lr, BufferHandle
        [ FastCentronics
                STR     lr, FastHandle
        ]
        [ FastBufferMan
                STR     lr, BufferId
                STR     lr, BuffManService
                STR     lr, BuffManWkSpace
        ]
                STRB    lr, IRQFlags

        [ FastCentronics
                LDRB    lr, Flags
                AND     lr, lr, #f_UseFIFO                      ; keep use FIFO bit
                STRB    lr, Flags
        |
                STRB    lr, Flags
        ]

                Pull    "pc",,^


svc_starting
                Push    "r0, lr"

                BL      registerdevice
                ADRVCL	r0, setsysvar
                SWIVC   XOS_CLI                                 ; setup system variable

                Pull    "r0, pc",,^

                LTORG

                GBLS    conditionalgetbodge
 [ standalonemessages
                GBLS    ApplicationName
ApplicationName SETS    "Parallel"
conditionalgetbodge SETS "GET s.ResFiles"
resourcefsfiles
 |
conditionalgetbodge SETS ""
 ]
                $conditionalgetbodge
 [ standalonemessages
                DCD     0
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; SWI despatching within the module.
;

swicode         ROUT

                LDR     wp, [wp]

                CMP     r11, #(%10-%00):SHR:2                   ; is the SWI within a valid range?
                ADDCC   pc, pc, r11, LSL #2
                B       %10
00
                B       HardwareAddr
                B       ParallelOp
10
                ADR     r0, ErrorBlock_Parallel_BadSWI
 [ international
                B       MakeErrorWithModuleName
 |
                ORRS    pc, lr, #V_bit
 ]

                MakeErrorBlock Parallel_BadSWI

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Parallel_HardwareAddress
;
; in:   -
;
; out:  r0 -> base address of 82C710 within IOEB / =0 on non-ioeb machines.
;               if r0 >0 then
;                       r1 -> routine to update IOEB ctrl register
;
; This call is provided to read the base address of the 82C710 parallel port
; within IOEB workspace.  The device can then be driven directly by applications,
; although this is not really advised.
;
; People wishing to do such a ghastly deed should first lock the device by
; opening a stream onto it.
;

HardwareAddr    LDR     r0, HardwareBase                        ; return base address
                TEQ     r0, #0
                ADRNEL  r1, UpdateIOEBCtrl                      ; if it is an IOEB then -> update ctrl function

                MOVS    pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: ParallelOp
;
; in:   r0 = reason code
;       other registers as determined by reason code
;
; out:  r0 preserved
;       other registers as determined by reason code
;
 [ StorkPower
; We don't call SetPower_On/Off around this call.
; The user is recommended (in the PRM 2-481) to claim exclusive use
; of the port by doing 'lock%=OPENOUT("parallel:")', this will ensure
; that the port is powered. The user should release the port by doing
; 'CLOSE#lock%', which will power it down.
 ]
;

ParallelOp      ROUT
                Push    "r3"
                LDR     r3, HardwareBase                        ; Make sure the correct hardware is there
                TEQ     r3, #0
                ADREQL  r0, ErrorBlock_Parallel_BadHardware
                Pull    "r3"
        [ international
                BEQ     MakeError
        |
                ORRS    pc, lr, #V_bit
        ]
                CMP     r0, #(%10-%00):SHR:2
                ADDCC   pc, pc, r0, LSL #2
                B       %10
00
                B       IOEB_ReadDataStatus
                B       IOEB_WriteData
                B       IOEB_ReadWriteCtrl
10
                ADR     r0, ErrorBlock_Parallel_BadParm
        [ international
                B       MakeError
        |
                ORRS    pc, lr, #V_bit
        ]

                MakeErrorBlock Parallel_BadParm

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; call: registerdevice
;
; in:   -
;
; out:  -
;
; This routine registers the specified device, the routine assumes that the
; hardware type has been obtained and then it will attempt to register a
; device within DeviceFS.
;

registerdevice  ENTRY   "r0-r7"

                LDR     r0, HardwareType
                TEQ     r0, #hardware_IOC                       ; which type of hardware?
;                BLEQ    IOCreset                               ; (doesn't do anything on IOC)
                BLNE    IOEBreset                               ; reset it...
 [ OldHardware
                ADREQL  r2, IOCdevice                           ; -> device routine
 ]
 [ NewHardware
                ADRNEL  r2, IOEBdevice
 ]
                MOV     r0, #dfsr_flags                         ; flags for registering device
                ADRL    r1, block                               ; device description block
                MOV     r3, #0
                MOV     r4, wp
                MOV     r5, #0                                  ; validation string with no decoding message
                MOVEQ   r6, #0                                  ; no receive buffer for IOC
                MOVNE   r6, #1                                  ; single receive buffer for IOEB
                MOV     r7, #1                                  ; single transmit buffer
                SWI     XDeviceFS_Register
                EXIT    VS

                STR     r0, DeviceHandle                        ; store device handle away
                Debug   open,"device handle =",r0

 [ FastCentronics
                LDRB    r0, Flags
                TST     r0, #f_UseFIFO
                EXIT    EQ

                MOV     r0, #dfsr_flags
                ADRL    r1, fastblock
                ADRL    r2, FastDevice
                MOV     r6, #0
                SWI     XDeviceFS_Register
                STRVC   r0, FastHandle
                Debug   open,"fast handle =",r0
 ]

                EXIT

 [ StorkPower
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       Power management routines
;

SetPower_On     ENTRY   "r0,r1"
                LDR     r0, =ParallelPowerBits
                B       SetPower                        ; turn on power


SetPower_Off    ALTENTRY
                MOV     r0, #0                          ; turn power off

; and drop thru to...

SetPower        ROUT
                LDR     lr, portable_present            ; if no portable module present
                TEQ     lr, #0
                EXITS   EQ                              ; then do nothing

                LDR     lr, power_state                 ; if current state = new state, do nothing
                TEQ     r0, lr
                EXITS   EQ

                LDR     r1, =:NOT: ParallelPowerBits
                SWI     XPortable_Control               ; new = (old AND r1) EOR r0
                STRVC   r1, power_state
                EXITS   VC

                MOV     r0, #0                          ; if we got an error
                STR     r0, portable_present            ; then set portable_present = FALSE
                LDR     r0, =ParallelPowerBits
                STR     r0, power_state                 ; and set power_state = ON
                EXITS

                LTORG
 ]
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generalised internationalisation routines, these ensure that messages files
; are correctly opened and then return the relevant data.
;
              [ international


; Attempt to open the messages file.

OpenMessages    ROUT

                Push    "r0-r3, lr"

                LDRB    r3, Flags
                TST     r3, #f_WeHaveMessages                   ; do we have an open messages block?
                Pull    "r0-r3, pc", NE, ^                      ; yes, so don't bother again

                ADR     r0, MessagesWorkspace
                ADRL    r1, resource_file                       ; -> path to be opened
                MOV     r2, #0                                  ; allocate some wacky space in RMA
                SWI     XMessageTrans_OpenFile
                LDRVCB  r3, Flags
                ORRVC   r3, r3, #f_WeHaveMessages
                STRVCB  r3, Flags                               ; assuming it worked mark as having messages

                Pull    "r0-r3, pc",,^                          ; returning VC, VS from XSWI!


; Attempt to close the messages file.

CloseMessages   ROUT

                Push    "r0, lr"

                LDRB    r0, Flags
                TST     r0, #f_WeHaveMessages                   ; do we have any messages?
                Pull    "r0, pc", EQ, ^                         ; and return if not!

                ADR     r0, MessagesWorkspace
                SWI     XMessageTrans_CloseFile                 ; yes, so close the file
                LDRVCB  r0, Flags
                BICVC   r0, r0, #f_WeHaveMessages
                STRVCB  r0, Flags                               ; mark as we don't have them

                Pull    "r0, pc",,^


; Generate an error based on the error token given.  Does not assume that
; the messages file is open.  Will attempt to open it, then look it up.

MakeErrorWithModuleName ENTRY "r1-r7"
                ADRL    r4, title
                B       MakeErrorEntry

MakeErrorWithDeviceName ALTENTRY
                ADRL    r4, devicename
                B       MakeErrorEntry

MakeError       ALTENTRY
		[	debug
		ADD	r0, r0, #4
		DebugS	j, "MakeError", r0, 252
		SUB	r0, r0, #4
		]
                MOV     r4, #0
MakeErrorEntry
                LDRB    r1, Flags
                TST     r1, #f_WeHaveMessages                   ; has the messages file been closed?
		DebugIf	EQ, j, "opening messages file"
                BLEQ    OpenMessages

                LDRB    r1, Flags
                TST     r1, #f_WeHaveMessages
                PullEnv EQ
                ORREQS  pc, lr, #VFlag                          ; if still not open then return with V set

                ADR     r1, MessagesWorkspace                   ; -> message control block
		ADR	r2, localerrorblock			; was 'MOV r2, #0', but for some reason
								; MsgTrans trashes the block. JRC 21-Apr-1997
                MOV     r3, #?localerrorblock
                MOV     r5, #0
                MOV     r6, #0
                MOV     r7, #0                                  ; no substitution + use internal buffers
		[	debug
		ADD	r0, r0, #4
		DebugS	j, "looking up", r0, 252
		SUB	r0, r0, #4
		]
                SWI     XMessageTrans_ErrorLookup
		[	debug
		ADD	r0, r0, #4
		DebugS	j, "answer was", r0, 252
		SUB	r0, r0, #4
		Debug	j, "buffer", r0
		]

		Debug	j, "closing messages file"
                BL      CloseMessages                           ; attempt to close the doofer

		[	debug
		PullEnv
		Push	r0
		MOV	r0, sp
		Debug	j, "exit sp", r0
		Debug	j, "exit flags", pc
		Pull	r0
		Debug	j, "returning to", lr
		MOV	pc, lr
		|
                EXIT                                            ; return, r0 -> block, V set
		]
		ALIGN
              ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ debug
                InsertNDRDebugRoutines
 ]

                GET     s.Common

                GBLS    getaroundaasm
 [ OldHardware
getaroundaasm   SETS    "GET s.IOC"
 |
getaroundaasm   SETS    ""
 ]
                $getaroundaasm

 [ NewHardware
getaroundaasm   SETS    "GET s.IOEB"
 |
getaroundaasm   SETS    ""
 ]
                $getaroundaasm

                GBLS    GETFastCent
 [ FastCentronics
GETFastCent     SETS    "GET s.FastCent"
 |
GETFastCent     SETS    ""
 ]
                $GETFastCent

                END
