;******************************************************************************
;
; HotKey control of LCD contrast
;

LCD_ContrastDown
        ENTRY   "R1"
        LDRB    R1, ContrastCopy
        SUBS    R1, R1, #1
        BLGE    SetContrast
        EXIT


LCD_ContrastUp
        ENTRY   "R1"
        LDRB    R1, ContrastCopy
        ADDS    R1, R1, #1
        CMP     R1, #255
        BLLE    SetContrast
        EXIT


;******************************************************************************
;
; HotKey control of LCD brightness
;

LCD_BrightnessDown
        ENTRY   "R1,R2"
        LDRB    R1, BrightnessCopy1
        SUBS    R1, R1, #1                      ;decrement brightness
        BLGE    SetBrightness_WithLock          ;limit value to 0..7
        EXIT


LCD_BrightnessUp
        ENTRY   "R1,R2"
        LDRB    R1, BrightnessCopy1
        ADDS    R1, R1, #1                      ;increment brightness
        CMP     R1, #7
        BLLE    SetBrightness_WithLock          ;limit value to 0..7
        EXIT


LCD_DimBrightness
        ENTRY   "R1,R2"
        LDRB    R2, BrightnessCopy1             ;NB Swap values
        LDRB    R1, BrightnessCopy2             ; (final store of R1 into BrightnessCopy1
        STRB    R2, BrightnessCopy2             ;  performed by subroutine)
        BL      SetBrightness_WithLock          ;In R1=brightness value
        EXIT


;******************************************************************************
;
; Compare BrightnessCopy1 with BrightnessCopy2, if lower set BrightnessLock
;
; Entry
;   R1  = brightness (0..7)
;
SetBrightness_WithLock
        Push    "R2, R3"
        LDRB    R2, BrightnessCopy2
        CMP     R1, R2                          ;If the user has dimmed the display,
        MOVLT   R3, #1                          ; set a lock (=1) to inhibit the screen blanker
        MOVGE   R3, #0                          ; choosing the brighter setting on unblanking
        STRB    R3, BrightnessHold              ; or undimming.
        Pull    "R2, R3"
                                        ;drop into...
;
; Write BrightnessCopy1 and BrightnessCopy2 to CMOS RAM.
; Set LCD to BrightnessCopy1 value.
;
; Entry
;   R1  = brightness (0..7)
;
SetBrightness
        ENTRY   "R0, R1, R2"
        AND     R1, R1, #2_00000111             ;Should already be in range, but make sure
        STRB    R1, BrightnessCopy1             ;Keep a copy

        MOV     R0, #ReadCMOS
        MOV     R1, #BrightnessCMOS
        SWI     XOS_Byte                        ;result in R2.b

        BICVC   R2, R2, #2_00111111             ;clear both brightness values
        LDRVCB  R1, BrightnessCopy2
        ORRVC   R2, R2, R1, LSL #3              ;Pack 'other' into 3..5
        LDRVCB  R1, BrightnessCopy1
        ORRVC   R2, R2, R1                      ; and 'current' into 0..2

        MOVVC   R0, #WriteCMOS
        MOVVC   R1, #BrightnessCMOS
        SWIVC   XOS_Byte

        LDRB    R1, BrightnessCopy1             ;Restore corrupted register
        BL      SendBrightness                  ;In R1=brightness

        EXIT

;
; Write new contrast value to CMOS RAM,
; send value to contrast control pot.
;
; Entry
;   R1  = contrast value (0..255)
;
; Exit
;   All registers preserved
;
SetContrast
        ENTRY   "R0-R2"
        STRB    R1, ContrastCopy                ;Keep a copy
        MOV     R2, R1
        MOV     R0, #WriteCMOS
        MOV     R1, #BrightnessCMOS
        SWI     XOS_Byte                        ;Write to CMOS RAM, ignore errors
        LDRB    R1, ContrastCopy                ;Reload corrupted register
        BL      SendContrast                    ;Shout down some wet string at the pot.
        EXIT


;******************************************************************************
;



;******************************************************************************
;
; SendBrightness
;
; Entry
;   R1  = value (0..7) to write
;
; Exit
;   R0, R1 corrupt
;
SendBrightness
        ENTRY
 [ SwitchPower
        AND     R1, R1, #2_00000111             ;SHOULD be in range, but lets make sure!
        LDRB    R0, SCLatchMC                   ;PortSoftCopies[MORRIS_P]
        BIC     R0, R0, #2_00011100             ;Kill current brightness bits
        ORR     R0, R0, R1, LSL #2
        STRB    R0, SCLatchMC                   ;Write modified value to soft copy
        MOV     R1, #HWLatchMC                  ;
        STRB    R0, [R1]                        ; and then the actual port
 ]
        EXIT


;******************************************************************************
;
; SendContrast
;
; Entry
;   R1  = value (0..255) to write to digital potentiometer chip
;
; Exit
;   All registers preserved.
;
; nRST, DQ and CLK lines driving potentiometer chip left high to
; prevent power usage in their pull-up resistors.
;

rLines   RN 0
rOne     RN 1
rCount   RN 2
rData    RN 3
rAddress RN 4
rTmp     RN 5

SendContrast
        ENTRY   "rLines, rOne, rCount, rData, rAddress, rTmp"
        MOV     rData, R1

        MOV     rLines, #(line_nRST :OR: line_CLK :OR: line_DQ)
        BL      writedata                       ;all three lines should have been high already
        BL      writedata                       ; some more hold time

;
; Pull nRST low then high just to provide a nice trigger for the logic analyser
;
        BIC     rLines, rLines, #line_nRST      ;take nRST low
        BL      writedata
        BL      writedata                       ; some more hold time

        ORR     rLines, rLines, #line_nRST      ;take nRST high
        BL      writedata
        BL      writedata                       ; some more hold time

;
; The chip can take 17 bits of data, but since we only use potentiometer 0,
; we can get away with only transmitting 8 bits.
;
        MOV     rOne, #1
        MOV     rCount, #7              ;highest bit number

20
        TST     rData, rOne, LSL rCount
        BICEQ   rLines, rLines, #line_DQ        ;setup data
        ORRNE   rLines, rLines, #line_DQ        ;
        BIC     rLines, rLines, #line_CLK       ; and take CLK low
        BL      writedata

        ORR     rLines, rLines, #line_CLK       ;hold data and latch it by raising CLK
        BL      writedata

        SUBS    rCount, rCount, #1
        BGE     %BT20                           ;GE: more bits to transfer

        BL      writedata                       ;some more hold time

        ORR     rLines, rLines, #line_DQ        ;take DQ high (CLK already high)
        BIC     rLines, rLines, #line_nRST      ; and nRST low to transfer data to pot
        BL      writedata                       ;
        BL      writedata                       ; some more hold time


        ORR     rLines, rLines, #line_nRST      ;take nRST high
        BL      writedata                       ;
        BL      writedata                       ;some more hold time

        EXIT

;
; We update the soft copy BEFORE writing to the hardware
; incase an interrupt that uses this hardware occurs.
;
writedata
        ENTRY
 [ SwitchPower
        LDRB    rTmp, SCLatchMC                 ;Set lines to required state
        BIC     rTmp, rTmp, #linemask           ;
        ORR     rTmp, rTmp, rLines              ;
        STRB    rTmp, SCLatchMC                 ; first in soft copy
        MOV     rAddress, #HWLatchMC            ;
        STRB    rLines, [rAddress]              ; and then the actual port
        STRB    rLines, [rAddress]              ; (done a few times to slow
        STRB    rLines, [rAddress]              ;  the transfer time a bit)
 ]
        EXIT

        END
