;
;
; PowerCtrl
; ---------
;
; Physical switching of supply rails to 'power hungry' hardware and
; the control of configurable devices such as the I/O combo chip.
;
; Split from StPortable 8/2/95
;


 [ SwitchPower
;******************************************************************************
;
; InitLatchSoftCopies
;
; We assume the Kernel has turned most of the hardware on, so that the
; machine is usable if we (the Portable module) are unplugged, or fail
; to start up.
;
; We initialise the PortSoftCopies to that state and to ensure consistancy
; write that to the Hardware latches. Providing we and the Kernel see
; eye-to-eye on this, nothing power-wise will have changed.
;
InitLatchSoftCopies
        ENTRY   "R0-R2"
        ADR     R14, PowerTab
05
        LDMIA   R14!, {R0, R1, R2}              ;Soft copy offset in ws, latch address, initial value
        TEQ     R0, #0
        STRNEB  R2, [R12, R0]                   ;Write soft copy
        STRNEB  R2, [R1]                        ;Write to latch
        BNE     %BT05
        EXITS

;
; Must be consistent with PowerTab in Kernel (s.PMF.osinit)
;
PowerTab
        DCD     :INDEX:SCLatchPA, HWLatchPA, InitLatchPA
        DCD     :INDEX:SCLatchPB, HWLatchPB, InitLatchPB
        DCD     :INDEX:SCLatchMC, HWLatchMC, InitLatchMC
        DCD     :INDEX:SCLatchMA, HWLatchMA, InitLatchMA
        DCD     0
        ASSERT :INDEX:PortSoftCopies <> 0       ;cos we use 0 to terminate the table
 ]


;******************************************************************************
;
; Initialise the variables used by Portable_Control and ensure the hardware
; is in a consistant state.
;
InitSWIPortableControl ENTRY "r0-r2"
        LDR     R1, =InitialPowerState          ;We expect the Kernel to have switched
        MVN     R0, R1                          ; everything on at start up. But to be on the
        STR     R1, ConfigExtraBitsCopy         ; safe side, force the hardware to that state
        BL      SetPwrState                     ; anyway. NB no power-up messages sent.

        MOV     r0, #0                          ;Now try turning as much off as possible,
        LDR     r1, =:NOT: PowerSaveBits        ; serial, parallel and FDC etc
        BL      SWIControl                      ; NB this call does send power-down messages.
        EXITS


;******************************************************************************
;
; PortableControl - Read/write various power/LCD control settings
;
; Entry
;   R0  = EOR mask
;   R1  = AND mask
;
;   New value = (Old value AND R1) EOR R0
;
; Exit
;   R0  = old value
;   R1  = new value
;
;
; where the bits in control are as follows:-
;
; '+' indicates a bit new for Stork, '-' indicates an 'A4' bit ignored by Stork
;
;       Bit     Meaning
;
;  -    0       Set => power to Econet enabled
;       1       Set => power to LCD display enabled
;       2       Set => power to external video display enabled
;       3       Set => power to serial buffer and oscillator enabled
;  -    4       Set => dual panel mode enabled
;  -    6,5     Video clock control
;                 0,0 => External clock input
;                 0,1 => Crystal oscillator, divided by 2
;                 1,0 => Crystal oscillator
;                 1,1 => reserved, do not use
;  -    7       Set => invert video clock
;       8       Set => back-light enabled
;  -    9       Clear => 1 extra line on display, Set => 2 extra lines
;  -    10      Clear => 1 DRAM used for dual panel, Set => 2 DRAMs
;  +    11      Set => power to sound filters and amplifiers enabled
;  +    12      Set => PCMCIA hardware enabled
;  +    13      Set => power to Parallel port enabled
;       14      Set => power to FDC oscillator in 82C710/82C711 enabled
;  +    15      Set => power to IDC hard disc enabled
;       16      Set => LCD palette set up for inverse video
;       17..31  Reserved: these bits must not be modified, nor assumed to
;                read any particular value.
;
;
;            Bit       16..12...8...4...0         
ControlValidBits    * 2_11110100100001110
                     ;2_10100011111111111

ControlServiceBits  * 2_01110100000001000         ; bits that require service call when changing
                     ;2_00100000000001001

ControlPWRGDBits    * 2_01110000000001000       ;Bits that require PWRGD pin of '665 held high
ControlConfigBits   * 2_01110000000001000         ; bits that require us to enter config mode in 710/711
ControlOscilBits    * 2_00100000000001000         ; bits that control the oscillator
ControlExtraBits    * 2_11110100100001110

InitialPowerState   * 2_01111100100001010       ;Everything-on state
PowerSaveBits       * 2_01111100000001000       ;The bits we attempt to powerdown 

;                        IFPPS  B    S L
;                        DDaCo  a    e C
;                        ECrMu  c    r D
;                          aCn  k    i
;                          lId  l    a
;                          lA   i    l
;                          e    g
;                          l    h
;                               t
;
SWIControl      ENTRY "r2,r3"
        TEQP    pc, #SVC_mode + I_bit
 [ Debug
        NOP
        DREG    R0, "In 'Real' Portable_Control: EOR &", cc, LongWord
        DREG    R1, ", AND &",, LongWord
 ]

        MOV     r3, r0                          ;preserve EOR mask for later
        LDR     R0, ConfigExtraBitsCopy         ;get old state

        AND     r1, r0, r1
        EOR     r1, r1, r3
        LDR     r3, =ControlValidBits
        AND     r1, r1, r3                      ; r1 is now new state

        EOR     r3, r1, r0                      ; r3 = bits that have changed
        LDR     lr, =ControlServiceBits
        AND     r3, r3, lr                      ; r3 = bits that have changed that require service
        ANDS    r3, r3, r0                      ; r3 = bits that are going from 1 to 0 (ie power -> off)
        BEQ     %FT10                           ; [no power bits going off]

        Push    "r1-r3"                         ;R0 preserved by XOS_ServiceCall
        MOV     r1, #Service_Portable
        MOV     r2, #ServicePortable_PowerDown  ; indicate power about to go off
        SWI     XOS_ServiceCall                 ; r3 = mask of bits going off
        Pull    "r1,r2,lr"                      ; on exit r3 = mask of bits that are allowed to go off
        EOR     r3, r3, lr                      ; bits which were forbidden to go off
        ORR     r1, r1, r3                      ; so we'd better put them back on!
10
        LDR     lr, =ControlExtraBits
        AND     lr, lr, r1
        STR     lr, ConfigExtraBitsCopy         ; store soft copy bits

        BL      SetPwrState                     ;R0 = current state, R1 = required state

; now issue post service for those power bits that have just been turned on
        EOR     r3, r1, r0                      ; r3 = bits that have changed
        LDR     lr, =ControlServiceBits
        AND     r3, r3, lr                      ; r3 = bits that have changed that require service
        ANDS    r3, r3, r1                      ; r3 = bits that are going from 0 to 1 (ie power -> on)
        BEQ     %FT30                           ; [no power bits going on]

        Push    "r1,r2"                         ;R0 preserved by XOS_ServiceCall
        MOV     r1, #Service_Portable
        MOV     r2, #ServicePortable_PowerUp    ; indicate power has just gone on
        SWI     XOS_ServiceCall                 ; r3 = mask of bits going on
        Pull    "r1,r2"                         ; restore registers
30
 [ Debug
       ;DREG    R0, "'Real' Portable_Control: was &", cc, LongWord
       ;DREG    R1, ", now &",, LongWord
 ]
        EXITS


;******************************************************************************
;
; SetPwrState
;
; Entry
;   R0  = current state
;   R1  = required state
;
; If current state is unknown (eg at module initialisation),
; set to inverse of required state to overide optimisations.
;
; Exit
;   R0, R1 preserved
;   R2, R3 corrupt
;
; Use R2 for bits that are changing
;
SetPwrState ENTRY
 [ Debug
;
; report devices powering down
;
        EOR     R3, R0, R1                      ; r3 = bits that have changed
        AND     r3, r3, r0                      ; r3 = bits that are going from 1 to 0 (ie power -> off)

        TST     R3, #PortableControl_SoundEnable
        BEQ     %FT232
        DLINE   "switching audio amps OFF"
232

        TST     R3, #PortableControl_FDCEnable
        BEQ     %FT232
        DLINE   "switching Floppy power OFF"
232

        TST     R3, #PortableControl_IDEEnable
        BEQ     %FT232
        DLINE   "switching Winnie power OFF"
232

        TST     R3, #PortableControl_ParallelEnable
        BEQ     %FT232
        DLINE   "switching Parallel power OFF"
232

        TST     R3, #PortableControl_SerialEnable
        BEQ     %FT232
        DLINE   "switching Serial power OFF"
232

;
; report devices powering up
;
        EOR     R3, R0, R1                      ; r3 = bits that have changed
        AND     r3, r3, r1                      ; r3 = bits that are going from 0 to 1 (ie power -> on)

        TST     R3, #PortableControl_SoundEnable
        BEQ     %FT232
        DLINE   "switching audio amps ON"
232

        TST     R3, #PortableControl_FDCEnable
        BEQ     %FT232
        DLINE   "switching Floppy power ON"
232

        TST     R3, #PortableControl_IDEEnable
        BEQ     %FT232
        DLINE   "switching Winnie power ON"
232

        TST     R3, #PortableControl_ParallelEnable
        BEQ     %FT232
        DLINE   "switching Parallel power ON"
232

        TST     R3, #PortableControl_SerialEnable
        BEQ     %FT232
        DLINE   "switching Serial power ON"
232
 ]

        EOR     R2, R0, R1                      ; R3 = bits that are changing



 [ SwitchPower
  [ DisableHDC
        ADR     R2, SwitchControl_IDE
        BL      SwitchOff
  ]

  [ DisableFDC
        ADR     R2, SwitchControl_FDC
        BL      SwitchOff
  ]

  [ ConfigSerial
        ADR     R2, SwitchControl_Serial
        BL      SwitchOff
  ]

  [ DisableSound
        ADR     R2, SwitchControl_Sound
        BL      SwitchOff
  ]
 ]

 [ SwitchPower
; The PWRGD line into the 665 must be high whenever units inside it are in use.
; We must also ensure it is high whenever we try to configure it!.
;
        LDR     LR, =ControlPWRGDBits
        TST     R0, LR
        TSTEQ   R1, LR
        BEQ     %FT20                        ;EQ, none of the units in the '665 need power

        ADR     R2, SwitchControl_PWRGD
        BL      ForceSwitchOn
 ]
        EOR     r3, r1, r0              ; r3 = bits that are really changing
        LDR     lr, =ControlConfigBits  ; bits that require us to go into config mode to change
        TST     r3, lr                  ; bits that are changing in config
        BEQ     %FT20


        Push    "r4"
        BL      EnterConfigMode

 [ DisableFDC
 [ 1 = 1
;
; Standard Microsystems Corporation Application note 4-13 states that we should
; disable DMA and IRQ before placing the FDC into low power mode by ensuring
; that the last write to 3F2H register is 04H.
;
        EOR     r3, r1, r0              ; r3 = bits that are changing
        TST     r3, #PortableControl_FDCEnable
        TSTNE   r0, #PortableControl_FDCEnable

        LDRNE   LR, =FDCDOR             ; if floppy power is changing from 1 to 0
        LDRNEB  R3, [LR]                ;
        STRNE   R3, SaveFDCDOR          ;
        MOVNE   R3, #&04                ; write &04 to Digital Output register
        STRNEB  R3, [LR]                ; to disable DMA and IRQ
 ]
 ]

 [ DisableFDC
        ADR     R2, UnitControl_FDC
        BL      ConfigureUnit
 ]

 [ DisableHDC
        ADR     R2, UnitControl_IDE
        BL      ConfigureUnit
 ]

 [ ConfigSerial
        ADR     R2, UnitControl_Serial
        BL      ConfigureUnit
 ]

 [ ConfigParallel
        ADR     R2, UnitControl_Parallel
        BL      ConfigureUnit
 ]

 [ TurnOffOscillator
        ADR     R2, UnitControl_Oscil
        BL      ConfigureUnit
 ]

        BL      ExitConfigMode
        Pull    "r4"

20
 [ SwitchPower
;>>>may be able to lower PWRGD????

        ADR     R2, SwitchControl_PWRGD
        BL      SwitchOff
 ]


; [ BMU
;        LDRB    lr, BMU_Flags
;        TST     lr, #PortableBMUF_LidOpen
;        MOV     r3, #&0F
;        AND     lr, r3, r1              ; bits 0..3
;        BICEQ   lr, lr, #2              ; knock out LCD enable bit if lid shut
;        STRB    lr, [r2, #LC_LICR_lo]
;        AND     lr, r3, r1, LSR #4      ; bits 4..7
;        STRB    lr, [r2, #LC_LICR_mid]
;        AND     lr, r3, r1, LSR #8      ; bits 8..11
;        BICEQ   lr, lr, #1              ; knock out backlight bit if lid shut
;        STRB    lr, [r2, #LC_LICR_hi]
; |
;        MOV     r3, #&0F
;        AND     lr, r3, r1              ; bits 0..3
;        STRB    lr, [r2, #LC_LICR_lo]
;        AND     lr, r3, r1, LSR #4      ; bits 4..7
;        STRB    lr, [r2, #LC_LICR_mid]
;        AND     lr, r3, r1, LSR #8      ; bits 8..11
;        STRB    lr, [r2, #LC_LICR_hi]
; ]
;
;        AND     lr, r3, r1, LSR #16
;        STRB    lr, PalState
;
;        EOR     lr, r0, r1
;        TST     lr, #1:SHL:16
;        BLNE    UpdateLCDPalette



 [ SwitchPower
  [ DisableHDC
        ADR     R2, SwitchControl_IDE
        BL      SwitchOn
  ]

  [ DisableFDC
        ADR     R2, SwitchControl_FDC
        BL      SwitchOn
  ]

  [ ConfigSerial
        ADR     R2, SwitchControl_Serial
        BL      SwitchOn
  ]

  [ DisableSound
        ADR     R2, SwitchControl_Sound
        BL      SwitchOn
  ]
 ]

        EXITS


;
; Enter 'Configure' mode of the '665.
;
; All registers preserved
;
EnterConfigMode ENTRY "r0,r1"
       ;DLINE   "EnterConfigMode"
        ADR     lr, ConfigPre665
ProcessConfigTable
10
        LDMIA   lr!, {r0,r1}
        TEQ     r0, #0
        STRNEB  r1, [r0]
        BNE     %BT10
        EXITS


;
; Exit 'Configure' mode of the '665.
;
; All registers preserved
;
ExitConfigMode ENTRY "r0,r1"
       ;DLINE   "ExitConfigMode"
        ADR     lr, ConfigPost665
        B       ProcessConfigTable


;
; Enable/disable a subunit of the '665
;
; Entry
;   R0  current power state mask
;   R1  required power state mask
;   R2  ->unit control record (eg UnitControl_FDC, UnitControl_Serial etc)
;
; Exit
;   R0, R1 preserved
;   R2  corrupt
;
ConfigureUnit
        ENTRY   "R3-R5"
        LDMIA   R2!, {r5}
        LDMIA   R2!, {r3,r4}            ; load addr1, data1
        STRB    r4, [r3]                ; set up CRI
        LDMIA   R2, {r3,r4}             ; load addr2, data2
        LDRB    R2, [r3]
        TST     r1, r5
        BICEQ   R2, R2, r4              ; disable
        ORRNE   R2, R2, r4              ; or enable
        EOR     R2, R2, r4, LSR #8      ; allow for +ve/-ve logic
        STRB    R2, [r3]
        EXITS




ConfigPre665
        &       CSR665, &55
        &       CSR665, &55
        &       0, 0

ConfigPost665
        &       CSR665, &AA
        &       0, 0

;
ConfigParallelFDC665
;       &       CSR665, &04     ;register &04
;       &       CRD665, &080C   ;PPFD1 mode

        &       CSR665, &04     ;register &04
        &       CRD665, &040C   ;PPFD2 mode


;
; Unit control records
; ====================

UnitControl_FDC
        &       PortableControl_FDCEnable
        &       CSR665, &00     ;register &00
        &       CRD665, &0018   ;bit 3 is FDC POWER,  hi supplies power
                                ;bit 4 is FDC ENABLE, hi enables FDC

UnitControl_IDE
        &       PortableControl_IDEEnable
        &       CSR665, &00     ;register &00
        &       CRD665, &0001   ;bit 1 is IDE ENABLE, hi enables IDE

UnitControl_Serial
        &       PortableControl_SerialEnable
        &       CSR665, &02     ;register &02
        &       CRD665, &00C0   ;bit 2 is UART1 Enable, hi enables port
                                ;bit 3 is UART1 Power down, hi supplies power

;
; used both as a normal parallel port and a floppy port!
;
UnitControl_Parallel
        &       PortableControl_ParallelEnable + PortableControl_FDCEnable
        &       CSR665, &01     ;register &01
        &       CRD665, &0007   ;bits 1 & 0 are 0 0 disabled
                                ;               1 1 enabled at address &278 (default)
                                ;bit 2 is Parallel Port Power, hi supplies power

;
; We choose to explicitly enable the Osc and Baud rate generator (BRG) when
; required, rather than configure them to enable when the PWRGD input is high. 
UnitControl_Oscil
        &       PortableControl_SerialEnable + PortableControl_FDCEnable
        &       CSR665, &00     ;register &00
        &       CRD665, &6060   ;bits 6 & 5 are OSC 0 0 Osc ON, BRG enabled
                                ;                   1 1 Osc OFF, BRG disabled




 [ SwitchPower
;
; R2  -> power control record (eg SwitchControl_FDC, SwitchControl_Serial etc)
;
ForceSwitchOn
        ENTRY   "R3-R7"
        LDMIA   R2!, {R3, R4, R5}       ;Control mask, PortID

        ADR     R6, PortSoftCopies      ;array of bytes
        LDRB    R7, [R6, R4]            ;load PortSoftCopy[PortID]
        ORR     R7, R7, R5
        EOR     R7, R7, R5, LSR #8
        STRB    R7, [R6, R4]            ;save PortSoftCopy[PortID]

        ADR     R6, PortList            ;array of words
        LDR     R6, [R6, R4,LSL # 2]    ;PortList[PortID]
        STRB    R7, [R6]

        EXITS

;
; Apply power
;
; R0  current power state mask
; R1  required power state mask
; R2  -> power control record (eg SwitchControl_FDC, SwitchControl_Serial etc)
;
SwitchOn
        ENTRY   "R3-R7"
        LDMIA   R2!, {R3, R4, R5}       ;Control mask, PortID

        TST     R1, R3
        EXITS   EQ                      ;EQ, powered down, so nothing to do

        ADR     R6, PortSoftCopies      ;array of bytes
        LDRB    R7, [R6, R4]            ;load PortSoftCopy[PortID]
        ORR     R7, R7, R5
        EOR     R7, R7, R5, LSR #8
        STRB    R7, [R6, R4]            ;save PortSoftCopy[PortID]

        ADR     R6, PortList            ;array of words
        LDR     R6, [R6, R4,LSL # 2]    ;PortList[PortID]
        STRB    R7, [R6]

        TST     R0, R3
        EXITS   NE                      ;NE, was already powered so no surge worries
    ;>>>delay

        EXITS

;
; Remove power
;
; R0  current power state mask
; R1  required power state mask
; R2  -> power control record (eg SwitchControl_FDC, SwitchControl_Serial etc)
;
SwitchOff
        ENTRY   "R3-R7"
        LDMIA   R2!, {R3, R4, R5}       ;Control mask, PortID

        TST     R1, R3
        EXITS   NE                      ;NE, powered up, so nothing to do

        ADR     R6, PortSoftCopies      ;array of bytes
        LDRB    R7, [R6, R4]            ;load PortSoftCopy[PortID]
        BIC     R7, R7, R5
        EOR     R7, R7, R5, LSR #8
        STRB    R7, [R6, R4]            ;save PortSoftCopy[PortID]

        ADR     R6, PortList            ;array of words
        LDR     R6, [R6, R4,LSL # 2]    ;PortList[PortID]
        STRB    R7, [R6]

        EXITS


PCMCIA_A        * 0
PCMCIA_B        * 1
MORRIS_P        * 2
MORRIS_AtoD     * 3




PortList
        &       HWLatchPA
        &       HWLatchPB
        &       HWLatchMC
        &       HWLatchMA


;
; Power control records
; =====================

;
; Most signal lines are active low, but the inverters in the Berlin ASIC
; means we treat them as active high.
;

SwitchControl_PWRGD                             ;Io_power
        &       ControlPWRGDBits                ;
        &       PCMCIA_A, &0001                 ;bit0 active low

SwitchControl_FDC                               ;Fdd_power
        &       PortableControl_FDCEnable       ;
        &       PCMCIA_A, &0010                 ;bit4 active low

SwitchControl_IDE                               ;Hdd_power
        &       PortableControl_IDEEnable       ;
        &       PCMCIA_A, &0004                 ;bit2 active low

SwitchControl_Serial                            ;Ser_power
        &       PortableControl_SerialEnable    ;
        &       PCMCIA_A, &0002                 ;bit1 active low

SwitchControl_Sound
        &       PortableControl_SoundEnable
        &       MORRIS_AtoD, &0101              ;bit0 active low
 ]

;******************************************************************************

        END
