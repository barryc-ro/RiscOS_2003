        TTL     Source.Portable

;
; Module header and misc. functions
;


;******************************************************************************
;
; Module header
;
Module_BaseAddr
        DCD     0
        DCD     Init     - Module_BaseAddr
        DCD     Die      - Module_BaseAddr
        DCD     Service  - Module_BaseAddr
        DCD     Title    - Module_BaseAddr
        DCD     Help     - Module_BaseAddr
        DCD     Command  - Module_BaseAddr
        DCD     Module_SWISystemBase + PortableSWI * Module_SWIChunkSize
        DCD     SWIEntry - Module_BaseAddr
        DCD     SWINameTable - Module_BaseAddr
        DCD     0

;******************************************************************************

Title   DCB     "Portable",0
Help    DCB     "Portable",9,"$VString ($Date)",0
        ALIGN


Command DCB     "SleepTime", 0
        ALIGN
        DCD     SleepTime - Module_BaseAddr
        DCD     &00010000:OR:International_Help
        DCD     SleepTimeSyn - Module_BaseAddr
        DCD     SleepTimeHlp - Module_BaseAddr
        DCD     0                  ; No more cmd's

 [ International_Help=0
SleepTimeHlp    DCB     "*SleepTime sets the delay (seconds) before an idle machine shuts down.", 13
                DCB     "If used with no parameters, it displays the current status.", 13
                DCB     "To turn off use *SleepTime 0", 13
SleepTimeSyn    DCB     "Syntax: *SleepTime [Time]", 0
 |
SleepTimeHlp
        DCB     "HSCBBLT", 0
SleepTimeSyn
        DCB     "SSCBBLT", 0
 ]
        ALIGN


;******************************************************************************
;
; Resources
;
Path            DCB     "Portable$Path",0
DefPath         DCB     "Resources:$.Resources.Portable.",0

MessageFile     DCB     "Portable:Messages",0
        ALIGN


;******************************************************************************

        MakeErrorBlock  BadVarNam
        ALIGN

;******************************************************************************
;
; Errors
;
        ^               ErrorBase_Portable
        AddError        BadBMUVariable,"BadBMUVar"
        AddError        BadBMUCommand,"BadBMUCmd"
        AddError        BMUBusy,"BMUBusy"
        AddError        BadBMUVersion,"BadBMUVer"
        AddError        BMUFault,"BMUFault"
        AddError        BMUVecClaim,"BMUVecClaim"
        ASSERT          @ <= (ErrorBase_Portable + ?ErrorBase_Portable)



;******************************************************************************


;******************************************************************************
;
; Init - Module initialisation code
;
; Exit
;   R7-R11, R13 preserved
;
Init    ENTRY   "R7"
;
; Check machine type
;
        MOV     r0, #2                          ;Check main hardware details
        SWI     XOS_ReadSysInfo
        EXIT    VS
                                                ;R0 bits 8..15 give I/O control chip type
        AND     r0, r0, #&0000FF00              ;  0=IOC, 1=IOMD
        TEQ     r0,     #&00000100              ;  must have IOMD
                                                ;R1 bits 0..8 give I/O combo chip type
        ANDEQ   r1, r1, #&000000FF              ;  0=absent, 1=82C710/711 or SMC'665 or similar
        TEQEQ   r1,     #&00000001              ;  must have a combo chip (exact type checked below)
 [ 1 = 1
                                                ;R2 bits 0..7 give LCD controller type
        ANDEQ   r2, r2, #&000000FF              ;  0=absent, 1=A4, 2=Stork
        TEQEQ   r2,     #&00000002              ;  must be Stork
 ]
        BNE     %FT99

        MOV     r0, #3                          ;Now check I/O combo chip details
        SWI     XOS_ReadSysInfo
        EXIT    VS
                                                ;R0 bits 20..23 give configuration type
        AND     r0, r0, #&00F00000              ;  1=82C710, 2=82C711, 3=37C665
        TEQ     r0,     #&00300000              ;  must be type 3 (for 37C665)
        BNE     %FT99
;
; Hardware OK
;
        LDR     R2, [R12]
        TEQS    R2, #0                          ;already got work space if entered
        BNE     %FT10                           ;as part of RMTidy

;private word is zero, so claim some workspace
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #MemNeeded
        SWI     XOS_Module
        EXIT    VS                              ;quit if error

        STR     R2, [R12]                       ;got workspace ok, so store in private word
10
        MOV     R12, R2

 [ Debug
        InsertTMLInitialisation 0               ;my EasiStork uses podule slot 0
       ;DLINE   "Portable module initialisation"
 ]

 [ UseMicroController
 |
; initialise variables

        MOV     R1,#PortableBMU_Num_Variables   ;number to do
        ADR     R2,Defaults
        wsaddr  R3,variables
20
        LDR     R0,[R2],#4
        STR     R0,[R3],#4
        SUBS    R1,R1,#1
        BNE     %BT20
 ]
 [ SwitchPower
        BL      InitLatchSoftCopies             ;Initialise variables and ensure hardware consistency
 ]
        BL      InitSWIPortableControl          ;Initialise variables and ensure hardware consistency

        MOV     R0, #0
        LDR     R1, =1000
        STR     R1, SleepTimerDelay

        STRB    r0, PaletteVFlag                ;not yet on PaletteV
        STRB    R0, EventVFlag                  ;not yet on event vector (for hot-key detection)
        STRB    R0, KeyVFlag
        STRB    R0, SleepTimerFlag
 [ UseMicroController
        BL      InitMicroController             ;also clears BMUDevFlag
 ]
 [ UseSRAM
;
;The code controlling the DRAM CAS and RAS lines obviously can't be executed from DRAM.
;Final code will run from ROM, but for testing, we copy the code into SRAM.
;
        Push    "R0 - R3"
        LDR     R0, = sram                      ;destination address (SRAM)
        ADRL    R1, thecode_start               ;source address (from module)
        ADRL    R2, thecode_end
30
        LDR     R3, [R1],#4
        STR     R3, [R0],#4
        CMP     R1, R2
        BLO     %BT30

        LDR     R0, =&09800FF2
        LDR     R1, =&02C08000
        STR     R0, [R1]
        Pull    "R0 - R3"
 ]
        BL      CheckForCMOSReset               ;may need to reconfigure a few things
        BL      ClaimEventV                     ;capture 'hot-keys' events
        BL      ClaimPaletteV           ;>>>a kludge A4 code does this on mode change iff LCD mode
        BL      ClaimKeyV
 [ UseMicroController
;>>>claim battery manager events
        BL      ClaimMicroControllerEvent       ;Claims event, but DOES NOT enable interrupts
                                                ; from device. This is done by PS2Driver calling
                                                ; us via a KeyV upcall with reason code
                                                ; KEYV_PseudoIntMask. See DoKeyV_PseudoIntMask.
 ]

;>>>read CMOS for brightness & contrast settings
;
;
        MOV     R0, #ReadCMOS
        MOV     R1, #BrightnessCMOS
        SWI     XOS_Byte                        ;result in R2.b
        ANDVC   R1, R2, #7                      ;extract bits 0..2 as one brightness value
        MOVVC   R2, R2, LSR #3                  ;
        ANDVC   R2, R2, #7                      ;extract bits 3..5 as another brightness value
        MOVVS   R1, #default_LCDBrightness1
        MOVVS   R2, #default_LCDBrightness2

        CMP     R1, R2                          ;sort values, use highest ie start in undimmed state
        EORLT   R1, R1, R2                      ; R1:=a EOR b
        EORLT   R2, R1, R2                      ; R2:=a EOR b EOR b ie R2:=a
        EORLT   R1, R1, R2                      ; R1:=a EOR b EOR a ie R1:=b
        STRB    R2, BrightnessCopy2             ;store lowest value as 'other' value
        BL      SetBrightness_WithLock          ;In R1=value to set (highest value)

        MOV     R0, #ReadCMOS
        MOV     R1, #ContrastCMOS
        SWI     XOS_Byte                        ;result in R2.b
        MOVVC   R1, R2
        MOVVS   R1, #default_LCDContrast
        STRB    R1, ContrastCopy
        BL      SendContrast
        EXITS
;
;Wrong hardware for Portable module
;
99
        ADR     r0, ErrorBlock_BadHard
        MOV     r1, #0                          ;only use global message file
        MOV     r2, #0                          ;use MessageTrans buffer
        MOV     r3, #0                          ;buffer size (irrelevant)
        MOV     r4, #0                          ;don't substitute anything
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

        LTORG
        MakeErrorBlock  BadHard


 [ UseMicroController
 |
;
Defaults
        DCD     0
        DCD     100
        DCD     100
        DCD     0
        DCD     100
        DCD     100
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     &60
        DCD     0
;
; Stork variables
;
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     60
        DCD     &60
        DCD     0
        DCD     100

        ASSERT  (. - Defaults) = (PortableBMU_Num_Variables * 4)
 ]

;******************************************************************************
;
; Finalisation code - Called before killing the module
;
; Entry
;   R10 = fatality indication: 0 is non-fatal, 1 is fatal
;   R11 = instantiation number
;   R12 = pointer to private word
;
; Exit
;   R7-R11, R13 preserved
;
Die     ENTRY
        LDR     R12, [R12]                      ;get workspace pointer

        BL      CancelSleepTimer
 ;SWI XPortable_ReadFeatures
;>>>Kill sleep timer???

;
; Ensure all hardware is powered up, ie leave machine in usable state.
;
        LDR     R0, = InitialPowerState         ;Put the machine back as we found it
        MVN     R1, R0                          ; ie with everything powered up
        BL      SWIControl                      ; (sends Power-Up message around)

        BL      ReleaseEventV
        BL      ReleasePaletteV
        BL      ReleaseKeyV
 [ UseMicroController
;>>>DO we need to inhibit MicroController key/battery reports
;>>>DO we need to mask of its IRQ's???
        BL      ReleaseMicroControllerEvent
 ]
        CLRV
;
; Brightness and Contrast is left 'as is'.
;
        EXIT


;******************************************************************************
;
; Service call handler
;
; Entry
;   R1  = service number
;   R12 = pointer to private word
;
; Exit
;    R1 = 0 => service claimed
;    All other registers preserved unless returning values
;
Service ROUT
        TEQ     r1, #Service_Reset
    ;>>>TEQNE   r1, #Service_PreReset
    ;>>>TEQNE   r1, #Service_ModeChanging
    ;>>>TEQNE   r1, #Service_ModeExtension
    ;>>>TEQNE   r1, #Service_ModeTranslation
    ;>>>TEQNE   r1, #Service_ModeChange
    ;>>>TEQNE   r1, #Service_MonitorLeadTranslation
; no need to handle Service_MessageFileClosed
    ;>>>[       standalonemessages
    ;>>>TEQNE   R1,#Service_ResourceFSStarting
    ;>>>]
        MOVNES  PC, LR

        LDR     wp, [r12]

    ;>>>TEQ     r1, #Service_PreReset
    ;>>>BEQ     Svc_PreReset

;drop into...

Svc_Reset ENTRY "R0-R2"
        MOV     r0, #&FD                ; read last reset type
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
        TEQ     r1, #0                  ; if not a soft reset, ignore
        EXITS   NE

        BL      CancelSleepTimer
        STRB    r1, PaletteVFlag
        STRB    r1, EventVFlag          ; indicate not on EventV (r1 = 0)
        STRB    r1, KeyVFlag
        STRB    r1, SleepTimerFlag

        BL      ClaimEventV
        BL      ClaimPaletteV           ;>>>a kludge A4 code does this on mode change iff LCD mode
        BL      ClaimKeyV
 [ UseMicroController
        BL      InitMicroController             ;also clears BMUDevFlag
        BL      ClaimMicroControllerEvent
 ]

        MOV     r0, #0                          ;Now try turning as much off as possible,
        LDR     r1, =:NOT: PowerSaveBits        ; serial, parallel and FDC etc
        BL      SWIControl                      ; NB this call does send power-down messages.
        EXITS

Svc_PreReset ENTRY "r0-r2"
;>>>wait for VSync before disabling LCD panel???
        EXITS

;******************************************************************************

SleepTime       ENTRY
        LDR     R12, [R12]                      ;get workspace pointer

        TEQ     R1, #0
        BEQ     SleepTimeNoParams

SleepTimeLoop
        LDRB    R1, [R0]                        ;check for end
        CMP     R1, #32                         ;and chop off leading spaces.
        ADDEQ   R0, R0, #1
        BEQ     SleepTimeLoop
        EXITS   LT                              ;exit if control-char.
        BL      DecodeParam 
        BVC     SleepTimeLoop
        EXIT                                    ;return V set

SleepTimeNoParams
        EXIT

DecodeParam ENTRY "R6"
        MOV     R1, R0                          ;move strpointer to R1
        MOV     R0, #(1<<29)                    ;check  0<=R2<=2^18 (ca. 3 days)
        MOV     R2, #(1<<18)                    ;restrict to moderate positive int
        SWI     XOS_ReadUnsigned
        BVS     DecodeErr                       ;print error and exit.
        MOV     R6, R1                  ; save the updated strpointer
        MOV     R3, #100
        MUL     R1,R2,R3
   ;>>>     BL      Subr_SetTimeout         ; Corrupts some registers
        MOV     R0,R6
        EXITS

DecodeErr
        Pull    "R6,LR"
        ORRS    PC, LR, #V_bit

;******************************************************************************

SWIEntry        ROUT
        LDR     R12,[R12]
        CMPS    R11,#(EndSWIJmpTable - SWIJmpTable) /4
        ADDCC   PC,PC,R11,LSL #2
        B       SWIUnknown

SWIJmpTable
        B       SWISpeed
        B       SWIControl
        B       SWI_ReadBMUVariable
        B       SWI_WriteBMUVariable
        B       SWI_CommandBMU
        B       SWIReadFeatures
        B       SWIIdle
        B       SWIStop
       ;B       SWISleepTime
 [ TestHardware
        B       SWIConfig
        B       SWIFloppy
        B       SWIPrinter
 ]
EndSWIJmpTable


;******************************************************************************

SWINameTable
        =       "Portable",0
        =       "Speed",0
        =       "Control",0
        =       "ReadBMUVariable",0
        =       "WriteBMUVariable",0
        =       "CommandBMU",0
        =       "ReadFeatures",0
        =       "Idle",0
        =       "Stop",0
 [ TestHardware
        =       "Config",0
        =       "Floppy",0
        =       "Printer",0
 ]
        =       0
        ALIGN

;******************************************************************************

        MakeErrorBlock  OutOfRange
SWIUnknown      ROUT
SWISpeed
        addr    R0,ErrorBlock_OutOfRange
        ORRS    PC,LR,#V_bit

;******************************************************************************



;******************************************************************************
;
; SWI Portable_ReadFeatures
;
; Exit
;   R0  = bit 4 set to indicate SWI Portable_Idle is impletemted
;         bit 5 set to indicate SWI Portable_Stop is impletemted
;
; All other bits in R0 zeroed, all other registers preserved.
;
SWIReadFeatures ROUT
        MOV     R1,#(PortableFeature_Idle :OR: PortableFeature_Stop)
        BICS    PC,LR,#V_bit


;******************************************************************************
;
; SWI Portable_Idle - Places the system into idle mode.
;
; The CPU clock is stopped, but all other clocks run normally. This means the
; Video display and all the IO channels are active, the DRAM is refreshed, but
; the system consumes less power as the CPU is inactive. The CPU remains in
; this state until it receives a FIQ or IRQ interrupt (eg from the keyboard,
; floppy, centi-second timer etc).
;
SWIIdle ENTRY   "R0, R1"
       ; DLINE   "SWIIdle"
  
 [ OnMorris
        MOV     R0, #0                          ;0 will stop Fclk, Clk2, Clk8, Ref8 and Clk16
        MOV     R1, #IOMD_Base                  ;1 will stop Fclk (the CPU core clock) only
        STRB    R0, [R1, #IOMD_IDLEMODE]        ;INicholas 6/10/94 recommended stopping them all
        EXITS
 ]
        
 [ OnEasiStork
       ;TEQP    PC, #SVC_mode + I_bit
        MOV     R0, #0
        LDR     R1, =stop_fclk
        STRB    R0, [R1]
        STRB    R0, [R1]
        STRB    R0, [R1]
       ;STRB    R0, [R1]
       ;STRB    R0, [R1]
       ;STRB    R0, [R1]
 ]
        EXITS


;******************************************************************************
;
; SWI Portable_Stop - Stop (or freeze) the System.
;
; Sets the DRAM to self-refresh, then places the system into stop mode (all
; clocks are stopped). Execution continues only on receipt of an external
; wakeup event from the keyboard or real-time-clock. Normal FIQ or IRQ or
; centi-second timer events cannot happen because the IO system is not clocked.
; 
SWIStop ENTRY   "R0-R6,R7,R8"        
 [ T
       ;DLINE   "SWIStop called but ignored"
        EXITS           ;cos HardWare curled its toes up over Easter
 ]
       ;DLINE   "SWIStop entry"

        MOV     R7, #0                          ;Failure indication, set to OK

       ;TEQP    PC, #SVC_mode + I_bit + F_bit
;
; call ADFS_PowerControl to 'spindown' the winnies
;
       ;DLINE   "SWIStop - trying to shutdown the winnies"
        MOV     R0, #2                          ; manual control of drive spin
                                                ; without affecting autospindown
        MOV     r2, #0                          ; spin down immediately
        BL      ADFSPowerOp                     ; apply to all IDE drives
        MOVVS   R7, #1                          ;VS, failure to spin-down winnies
        BVS     fail_1



;
; call Portable_Control to powerdown floppies/econet/serial etc
;
; Bxx yyy ;Something refused to shutdown

       ;DLINE   "SWIStop - trying to shutdown the sound system"
        MOV     R0, #1
        SWI     XSound_Enable                   ;turn sound system off
        MOV     R5, R0                          ;preserve old state for later
        MOVVS   R7, #2                          ;VS, failure to kill sound system
        BVS     fail_2

       ;DLINE   "SWIStop - blanking the screen (probably was already)"
        MOV     R0, #ScreenBlankerReason_Blank
        SWI     XScreenBlanker_Control          ;blank screen
        MOVVS   R7, #3                          ;VS, failure to blank screen
        BVS     fail_3
;
; Send 'Suspend' command to microcontroller
;
 [ UseMicroController
        LDRB    R1, CommandState
        TEQ     R1, #0
        MOVNE   R7, #4                          ;NE, battery manager busy (interupted SendPowerCommand)
        BNE     fail_4
        LDR     R0, =uC_StatusReg               ;Get Tx buffer status bit
        LDRB    R1, [R0]                        ;
        TST     R1, #uC_Status_OBF              ;
        MOVNE   R7, #4                          ;NE, battery manager busy (processing an earlier Power or Keyboard command)
        BNE     fail_4

        MOV     R2, #PwrCmd_Suspend
        LDR     R0, =uC_PwrDataTxReg
        STRB    R2, [R0]                        ;Write byte to Power manager
 ]

;
; remove power from LCD display, LCD backlight and external VDU
;
        TEQP    PC, #SVC_mode + I_bit + F_bit

        MOV     R8, #IOMD_Base
        LDRB    R6, [R8, #IOMD_VREFCR]
        AND     R1, R6, #&E0                    ;preserve VRAM(Sz2..0) bits, but turn refresh off
        STRB    R1, [R8, #IOMD_VREFCR]          ;old value kept in R6 for later restoration


       ;DLINE   "SWIStop - setting DRAM to self refresh, stopping the processor"


 [ OnMorris
;
; Put DRAM into self-refresh mode by lowering the CAS lines then the RAS lines
;
        MOV     R1, #&F0
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS lines low
        MOV     R1, #&FF
        STRB    R1, [R8, #IOMD_SELFREF]         ;force CAS and RAS lines low
;
; Stop the processor
;
        MOV     R1, #&FFFFFFFF
        STR     R1, [R8, #IOMD_STOPMODE]
;
; *** The system is now asleep, pending a wake-up interrupt ***
;
        MOV     R1, #0
        STRB    R1, [R8, #IOMD_SELFREF]         ;return CAS and RAS lines to normal use


 ]

 [ OnEasiStork
        LDR     R1, =stop_both
        LDR     R2, =rascas_latch
        LDR     R3, =tlb_dummy
  [ UseSRAM
        BL      callcodeinSRAM
        B       thecode_end

thecode_start
  ]
        LDRB    R0, [R3]
        LDRB    R0, [R2]
        LDRB    R0, [R3]                        ;dummy reads to stop later TLB ram fetches
                                                ;Put DRAM into self-refresh mode
        MOV     R0, #&F0                        ;force CAS low
        STRB    R0, [R2]

        MOV     R0, #&FF                        ;force CAS and RAS low
        STRB    R0, [R2]

        MOV     R0, #0                          ;stop processor
        STRB    R0, [R1]
;
; *** The system is now asleep, pending a wake-up interrupt ***
;
        MOV     R0, #0                          ;CAS and RAS high
        STRB    R0, [R2]

  [ UseSRAM
        MOVS    PC, LR
thecode_end
  ]
 ]

        MOV     R8, #IOMD_Base
 [ T
        STRB    R6, [R8, #IOMD_VREFCR]          ;Restore VRAM size and refresh rate
 |
        LDRB    R1, [R8, #IOMD_VREFCR]
        AND     R1, R1, #&E0                    ;Preserve VRAM(Sz2..0) bits
        ORR     R1, R1, #IOMD_VREFCR_REF_16     ;set 16µs refresh >>>should really restore old value
        STRB    R1, [R8, #IOMD_VREFCR]
 ]

       ;DLINE   "SWIStop - restarting"

;
;>>>call Portable_Control to power LCD or VDU
;>>>I suppose we could have changed from VDU to LCD or vice-versa whilst asleep!
;
fail_4  ;Problem talking to microcontroller
        MOV     R0, #ScreenBlankerReason_Unblank
        SWI     XScreenBlanker_Control          ; un-blank screen

fail_3  ;Problem with screen blanking
        MOV     R0, R5                          ;restore state of sound system
        SWI     XSound_Enable

fail_2  ;Problem with sound system

fail_1  ;Problem with winnies
        SWI     XOS_WriteI + 7
       ;DLINE   "SWIStop exit"
        EXITS

 [ UseSRAM
callcodeinSRAM
        MOV     R0, #&02000000
        MOV     PC, R0
 ]

;******************************************************************************

SWISleepTime    ENTRY
        STR     R0, SleepTimerDelay     ;>>>should we restart any existing
        EXITS                           ;>>>screen blank/sleep timer???

 [ TestHardware
;******************************************************************************
SWIConfig ENTRY   "r1-r4"
        TEQP    pc, #SVC_mode + I_bit
        NOP
        BL      EnterConfigMode
        ADR     lr, ConfigParallelFDC665
        LDMIA   lr!, {r3,r4}            ; load addr1, data1
        STRB    r4, [r3]                ; set up CRI
        LDMIA   lr, {r3,r4}             ; load addr2, data2
        LDRB    R0, [r3]
        BL      ExitConfigMode
        EXITS

SWIFloppy ENTRY "r0-r4"
        TEQP    pc, #SVC_mode + I_bit
        NOP
        BL      EnterConfigMode

        ADR     lr, ConfigParallelFDC665
        LDMIA   lr!, {r3,r4}            ; load addr1, data1
        STRB    r4, [r3]                ; set up CRI
        LDMIA   lr, {r3,r4}             ; load addr2, data2
        LDRB    lr, [r3]
        ORR     lr, lr, r4              ; enable
        EOR     lr, lr, r4, LSR #8      ; allow for +ve/-ve logic
        STRB    lr, [r3]

        BL      ExitConfigMode

        EXITS


SWIPrinter ENTRY "r0-r4"
        TEQP    pc, #SVC_mode + I_bit
        NOP
        BL      EnterConfigMode

        ADR     lr, ConfigParallelFDC665
        LDMIA   lr!, {r3,r4}            ; load addr1, data1
        STRB    r4, [r3]                ; set up CRI
        LDMIA   lr, {r3,r4}             ; load addr2, data2
        LDRB    lr, [r3]
        BIC     lr, lr, r4              ; disable
       ;EOR     lr, lr, r4, LSR #8      ; allow for +ve/-ve logic
        STRB    lr, [r3]

        BL      ExitConfigMode

        EXITS
 ]

;******************************************************************************
;
; ClaimEventV - Claim EventV so we can notice hot keys
;
; Always preserves flags
;
ClaimEventV ENTRY "r0-r3"
        LDRB    r3, EventVFlag
        TEQ     r3, #0                  ; if already on vector
        EXITS   NE                      ; then exit

        MOV     r0, #EventV
        ADRL    r1, EventVHandler
        MOV     r2, wp
        SWI     XOS_Claim
        EXITS   VS

        MOV     r0, #14                 ; enable event
        MOV     r1, #Event_Keyboard
        SWI     XOS_Byte

        MOV     r3, #1                  ; indicate we're on vector
        STRB    r3, EventVFlag
        EXITS

;******************************************************************************
;
; ReleaseEventV - Release EventV
;
; Always preserves flags
;
ReleaseEventV ENTRY "r0-r3"
        LDRB    r3, EventVFlag
        TEQ     r3, #0                  ; if not on vector
        EXITS   EQ                      ; then don't bother releasing

        MOV     r0, #13                 ; disable event
        MOV     r1, #Event_Keyboard
        SWI     XOS_Byte

        MOV     r0, #EventV
        ADRL    r1, EventVHandler
        MOV     r2, wp
        SWI     XOS_Release

        MOV     r3, #0                  ; indicate not on vector
        STRB    r3, EventVFlag
        EXITS

; ******************************************************************************************************
;
;       ClaimKeyV - Claim KeyV
;       Always preserves flags
;

ClaimKeyV ENTRY "r0-r3"
        MOV     r0, #KEYV               ; always claim KeyV (MOS ensures we're only on once) -
        ADRL    r1, KeyVHandler
        MOV     r2, wp
        SWI     XOS_Claim
        EXITS   VS

        MOV     r3, #1                  ; indicate we're on vector
        STRB    r3, KeyVFlag
        EXITS 

; ******************************************************************************************************
;
;       ReleaseKeyV - Release KeyV
;       Always preserves flags
;

ReleaseKeyV ENTRY "r0-r3"
        LDRB    r3, KeyVFlag
        TEQ     r3, #0                  ; if not on vector
        EXITS   EQ                      ; then don't bother releasing

        MOV     r0, #KEYV
        ADRL    r1, KeyVHandler
        MOV     r2, wp
        SWI     XOS_Release

        MOV     r3, #0                  ; indicate not on vector
        STRB    r3, KeyVFlag
        EXITS

; ******************************************************************************************************
;
;       ClaimPaletteV - Claim PaletteV
;       Always preserves flags
;

ClaimPaletteV ENTRY "r0-r3"
        MOV     r0, #PaletteV           ; always claim PaletteV (MOS ensures we're only on once) -
        ADR     r1, PaletteVHandler     ; PaletteVFlag may be wrong immediately after a soft reset.
        MOV     r2, wp
        SWI     XOS_Claim
        EXITS   VS

        MOV     r3, #1                  ; indicate we're on vector, but colours not inited
        STRB    r3, PaletteVFlag
        EXITS

; ******************************************************************************************************
;
;       ReleasePaletteV - Release PaletteV
;       Always preserves flags
;

ReleasePaletteV ENTRY "r0-r3"
        LDRB    r3, PaletteVFlag
        TEQ     r3, #0                  ; if not on vector
        EXITS   EQ                      ; then don't bother releasing

        MOV     r0, #PaletteV
        ADR     r1, PaletteVHandler
        MOV     r2, wp
        SWI     XOS_Release

        MOV     r3, #0                  ; indicate not on vector
        STRB    r3, PaletteVFlag
        EXITS

;*******************************************************************************************************
;
;       PaletteVHandler
;
; in:   r4 = reason code
;
; out:  depends on r4
;

        ASSERT  paletteV_Complete = 0
        ASSERT  paletteV_Read = 1
        ASSERT  paletteV_Set = 2
        ASSERT  paletteV_1stFlashState = 3
        ASSERT  paletteV_2ndFlashState = 4
        ASSERT  paletteV_SetDefaultPalette = 5
        ASSERT  paletteV_BlankScreen = 6

PaletteVHandler ENTRY "r0-r3"
        CMP     r4, #1
        EXITS   CC
        BEQ     PV_ReadPalette
        CMP     r4, #3
        BCC     PV_SetPalette
        BEQ     PV_1stFlashState
        CMP     r4, #5
        BCC     PV_2ndFlashState
        BEQ     PV_SetDefaultPalette
        CMP     r4, #7
        BCC     PV_BlankUnblank
        EXITS

ClaimExit
        MOV     r4, #0
        PullEnv
        Pull    pc

PV_1stFlashState
PV_SetFlashState
PV_2ndFlashState
PV_ReadPalette
PV_SetPalette
PV_SetDefaultPalette
        EXITS

;******************************************************************************
;
;       PV_BlankUnblank - Blank/unblank screen
;
; in:   r0 = -1 (read blank state)
;          or 0 (unblank screen)
;          or 1 (blank screen)
;       r0-r3, lr already pushed
;
; out:  r0 = old state (0=unblanked, 1=blanked)
;       r4 = 0 => operation complete
;

PV_BlankUnblank ROUT
       ;DREG    R0, "PV_BlankUnblank, R0 is ",,Integer
        TEQ     R0, #0
        BLEQ    CancelSleepTimer
        TEQ     R0, #1
        BLEQ    StartSleepTimer
        EXITS


;******************************************************************************
;
;       ADFSPowerOp - Issue an ADFS_PowerControl SWI to all IDE drives
;
; in:   r0, r2 are the parameters we wish to pass to the SWI
;
; out:  -
;

ADFSPowerOp ENTRY "r0-r4"
        MOV     r4, r0                          ; save r0 value
        MOV     r1, #4                          ; for drive = 4 to 7
10
        MOV     r0, r1                          ; read type of drive
        SWI     XADFS_ControllerType
        BVS     %FT20                           ; if error then skip
        TEQ     r0, #4                          ; if IDE drive
        MOVEQ   r0, r4                          ; then perform operation
        SWIEQ   XADFS_PowerControl
 [ F
        BVC     %FT20
        ADD     R0, R0, #4      ;skip error number
       ;DLINE   R0, "XADFS_PowerControl reported: ",,String
 ]
20
        ADD     r1, r1, #1
        TEQ     r1, #8
        BNE     %BT10
        EXITS

;******************************************************************************
;
; CheckForCMOSReset - Check CMOS reset bit in CMOS RAM, and reconfigure
;                     certain values if so
;
; Entry:
;
; Exit:
;   R0-R7 may be corrupted
;
CheckForCMOSReset ENTRY
        MOV     r0, #ReadCMOS
        MOV     r1, #SystemSpeedCMOS            ;CMOS reset indicator location
        SWI     XOS_Byte
        EXITS   VS                              ;if couldn't read it then finish

        TST     r2, #CMOSResetBit               ;or if bit clear then finish
        EXITS   EQ

; Set configured Delay to 25 and Repeat to 6 and reflect in current states

        ADR     r0, ConfigureDelayCommand
        SWI     XOS_CLI
        ADR     r0, ConfigureRepeatCommand
        SWI     XOS_CLI
        MOV     r0, #12
        MOV     r1, #0
        SWI     XOS_Byte                        ;set current delay and repeat to configured

; Set configured screen-blanking time to 5 minutes and reflect in current state

        MOV     r0, #ReadCMOS
        MOV     r1, #Misc1CMOS
        SWI     XOS_Byte
        BICVC   r2, r2, #7 :SHL: 3
        ORRVC   r2, r2, #4 :SHL: 3              ; 0=>none, 1=>30s, 2=>1min, 3=>2min,
        MOVVC   r0, #WriteCMOS                  ; 4=>5min, 5=>10min, 6=>15min, 7=>30min
        SWIVC   XOS_Byte
        ADR     r0, BlankTimeCommand
        SWI     XOS_CLI

; Set configured SoundDefault to 1 6 2 and reflect in current states

        MOV     r0, #WriteCMOS
        MOV     r1, #SoundCMOS
        MOV     r2, #(1 :SHL: 7) :OR: (6 :SHL: 4) :OR: ((2-1) :SHL: 0)
        SWI     XOS_Byte

        MOV     r0, #6*18+1                     ; set volume to 6
        SWI     XSound_Volume                   ; (speaker should already be set to 1)

        MOV     r0, #1                          ; set channel 1
        MOV     r1, #2                          ; to use voice generator 2 (StringLib-Soft)
        SWI     XSound_AttachVoice

; Set configured beep to Loud and reflect in current state

        MOV     r0, #ReadCMOS
        MOV     r1, #DBTBCMOS
        SWI     XOS_Byte
        ORRVC   r2, r2, #2                      ; set beep to LOUD
        MOVVC   r0, #WriteCMOS
        SWIVC   XOS_Byte

        MOV     r0, #212                        ; OS_Byte number to set bell volume/envelope
        MOV     r1, #&90
        MOV     r2, #0
        SWI     XOS_Byte

; Set configured IDE disc spin to 2 mins and reflect in current state

        MOV     r0, #WriteCMOS
        MOV     r1, #ADFSSpinDownCMOS           ; set configured autospindown
        MOV     r2, #120/5                      ; to 2 minutes = 120 seconds
        SWI     XOS_Byte
        MOV     r0, #1                          ; set drive autospindown
        MOV     r2, #120/5                      ; to same
        BL      ADFSPowerOp

; Make !BatMgr appear on icon bar by default

        MOV     r0, #ReadCMOS
        MOV     r1, #Deskboot2CMOS
        SWI     XOS_Byte
        ORRVC   r2, r2, #1                      ; bit 0 set => appear on icon bar, clear => don't
        MOVVC   r0, #WriteCMOS
        SWIVC   XOS_Byte

;
;>>>must also configure sound system for 16 digital
;>>>
        EXITS

ConfigureDelayCommand
        =       "Configure Delay 25", 0
ConfigureRepeatCommand
        =       "Configure Repeat 6", 0
BlankTimeCommand
        =       "BlankTime 300", 0              ; 300 seconds = 5 minutes
        ALIGN

;******************************************************************************

ErrorLookupNoParms      ENTRY   "R1-R7"
;
; Entry:
;    R0 -> error block with tokenised message
;
; Exit:
;    R0 -> error block with real message
;    V set

        MOV     R4,#0                           ; no parameter 0
        B       ErrorLookupContinue

ErrorLookup1Parm        ALTENTRY
;
; Entry:
;    R0 -> error block with tokenised message
;    R4 -> parameter to substitute into error
;
; Exit:
;    R0 -> error block with real message
;    V set

ErrorLookupContinue

        wsaddr  R1,MsgTransBlk
        MOV     R2,#0                           ; use internal buffer
        MOV     R5,#0                           ; no parameter 0
        MOV     R6,#0                           ; no parameter 0
        MOV     R7,#0                           ; no parameter 0
        SWI     XMessageTrans_ErrorLookup
        EXIT

;******************************************************************************
;
; StartSleepTimer
;
; No params, all registers preserved
;
StartSleepTimer ENTRY "R0-R2"
        LDRB    R0, SleepTimerFlag
        TEQ     R0, #0
        EXITS   NE
;DLINE "StartSleepTimer"
        LDR     R0, SleepTimerDelay             ;sleep time delay
RestartSleepTimer
        ADR     R1, SleepTimerCallAfter         ;routine to call after timer expires
        MOV     R2, R12                         ;R12 value to call it with
        SWI     XOS_CallAfter                   ;if this fails, the 'go to sleep' event never happens...
        MOVVC   R0, #1                          ;eventually we receive a battery low interrupt
        STRVCB  R0, SleepTimerFlag
        EXITS

;******************************************************************************
;
; CancelSleepTimer
;
; No params, all registers preserved
;
CancelSleepTimer ENTRY "R0-R2"
        LDRB    R0, SleepTimerFlag
        TEQ     R0, #0
        EXITS   EQ
        ADR     R0, SleepTimerCallAfter         ;address and workspace originally
        MOV     R1, R12                         ;passed to OS_CallAfter
        SWI     XOS_RemoveTickerEvent

        MOV     R0, #0
        STRB    R0, SleepTimerFlag
        EXITS

;******************************************************************************

SleepTimerCallAfter ENTRY "R0-R2"
        MOV     R0, #0                          ;timer cleared once it fires
        STRB    R0, SleepTimerFlag
;DLINE "SleepTimerCallAfter"
        SWI     XPortable_Stop                  ;try putting the machine to sleep
        EXITS   VC                              ;VC machine stopped then restarted
                                                ;VS something objected
        MOV     R0, #RetryDelay       
        B       RestartSleepTimer

; Aside: XPortable_Stop calls Screen blanker to blank the screen (it happens to be blanked)
;        This causes us to be entered via PaletteV and another sleep timer is set up.
;        The machine then sleeps.
;        As soon as the machine restarts, the Screen blanker is called to unblank the screen,
;        it calls us via PaletteV which cancels the sleep timer.

;******************************************************************************

 [ Debug
        InsertDebugRoutines
 ]

;******************************************************************************

        END
