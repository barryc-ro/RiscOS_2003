;
; Hot Keys
; --------
;
; Handles 'hot keys', eg for LCD Brightness/Contrast.
;
; RCManby 6/10/94
;


;******************************************************************************
;
; HotKeyEventHandler
;
; Entry
;   r0 = event number (must be Event_Keyboard)
;   r1 = 0 for key up, 1 for key down
;   r2 = key number
;   r3 = keyboard driver ID
;
;   May be in IRQ mode or SVC mode
;

;;;HotKey_ToolBox          * &02   ;F2             ;Open Apps directory
HotKey_ContrastDown     * &03   ;F3
HotKey_ContrastUp       * &04   ;F4
HotKey_BrightnessDown   * &05   ;F5
HotKey_BrightnessUp     * &06   ;F6
;;;HotKey_Heart            * &07   ;F7             ;Run favourite application
HotKey_Freeze           * &08   ;F8
HotKey_MonLCD           * &09   ;F9             ;Toggle between LCD and external monitor
HotKey_InvertVideo      * &0A   ;F10
HotKey_AccessLock       * &39   ;keypad 9       ;
HotKey_DimBrightness    * &0B   ;F11
;;;HotKey_Battery          * &0C   ;F12


;HotKey_InvertVideo     *    &7D                     ; inverts LCD palette
;HotKey_ScreenBlank     *    &7E                     ; blanks screen and spins down hard disc


 [ SimulateBMU
HotKey_BMU0             * &65
HotKey_BMU1             * &5A
HotKey_BMU2             * &5B
HotKey_BMU3             * &5C
HotKey_BMU4             * &48
HotKey_BMU5             * &49
 ]

HotKeyEventHandler
EventVHandler ROUT
        TEQ     r0, #Event_Keyboard             ; only interested in keyboard event
;>>>    TEQEQ   r1, #1                          ; and only if it's key down
      TEQEQ   r1, #0    ;use key-up for now, for stork testing (else key up restarts stork) 
;>>>    TEQEQ   r3, #2                          ; and only if it's on a Perth keyboard
        MOVNES  pc, lr                          ; if not then exit by passing on vector

       ;DREG    R2, "Key number: &",, LongWord
       ;DREG    R3, "Keyboard driver ID: &",, LongWord


;>>>We may get lucky with the 'real' keyboard and find all these are
;>>>sequential, in which case a simple low..high range check will do
        TEQ     r2, #HotKey_ContrastDown
        TEQNE   r2, #HotKey_ContrastUp
        TEQNE   r2, #HotKey_BrightnessDown
        TEQNE   r2, #HotKey_BrightnessUp
        TEQNE   r2, #HotKey_Freeze
        TEQNE   r2, #HotKey_MonLCD
        TEQNE   r2, #HotKey_InvertVideo
        TEQNE   r2, #HotKey_AccessLock
        TEQNE   r2, #HotKey_DimBrightness
        ;;;TEQNE   r2, #HotKey_ToolBox
        ;;;TEQNE   r2, #HotKey_Heart
        ;;;TEQNE   r2, #HotKey_Battery

 [ SimulateBMU
        TEQNE   r2, #HotKey_BMU0
        TEQNE   r2, #HotKey_BMU1
        TEQNE   r2, #HotKey_BMU2
        TEQNE   r2, #HotKey_BMU3
        TEQNE   r2, #HotKey_BMU4
        TEQNE   r2, #HotKey_BMU5
 ]
        MOVNES  pc, lr                          ;NE, not a key we want, so pass along vector
;
; Switch to SVC mode (from IRQ or SVC mode) as all our hot-keys
; require us to issue SWI calls.
;
        Push    "r0-r2,lr"
        MOV     r0, pc
        ORR     r1, r0, #SVC_mode               ; switch to SVC mode
        TEQP    r1, #0
        NOP
        Push    "r0,lr"
;
; NB branch to ExitHandler to exit
;

;>>>We may get lucky with the 'real' keyboard and find all these are
;>>>sequential, in which case a simple low..high range check will do

        ;;;TEQ     r2, #HotKey_ToolBox
        ;;;BEQ     Key_ToolBox
        ;;;TEQ     r2, #HotKey_Heart
        ;;;BEQ     Key_Heart

        TEQ     r2, #HotKey_Freeze
        BEQ     %FT20
 [ SimulateBMU
        TEQ     r2, #HotKey_BMU0
        BEQ     %FT40
        TEQ     r2, #HotKey_BMU1
        BEQ     %FT41
        TEQ     r2, #HotKey_BMU2
        BEQ     %FT42
        TEQ     r2, #HotKey_BMU3
        BEQ     %FT43
        TEQ     r2, #HotKey_BMU4
        BEQ     %FT44
        TEQ     r2, #HotKey_BMU5
        BEQ     %FT45
 ]
ExitHandler
        Pull    "r0,lr"
        TEQP    r0, #0                          ; restore old processor mode
        NOP
        Pull    "r0-r2,pc",,^


 [ F
;>>>may need
; invert LCD palette - NB no need to go into SVC mode - we're not issuing any SWIs

        Push    "lr"
        LDRB    lr, PaletteVFlag
        TEQ     lr, #2                          ; only invert if LCD is up and running
        LDREQB  lr, PalState
        EOREQ   lr, lr, #1
        STREQB  lr, PalState
        BLEQ    UpdateLCDPalette
 ]
        Pull    "pc",,^                         ; pass on vector

;
; blank screen and spin down all IDE hard discs
;
10
        MOV     r0, #ScreenBlankerReason_Blank
        SWI     XScreenBlanker_Control          ; blank screen

        MOV     r0, #2                          ; manual control of drive spin
                                                ; without affecting autospindown
        MOV     r2, #0                          ; spin down immediately
        BL      ADFSPowerOp                     ; apply to all IDE drives
        B       ExitHandler

;
; put machine into sleep mode
;
20
        SWI     XPortable_Stop                  ;stop the world - I want to get off
        B       ExitHandler


;;;Key_ToolBox
;;;        MOV     r0, #User_Message_Recorded
;;;        ADR     r1, resourcefsmessage
;;; [ 1 = 0
;;;        LDR     r2, FilerHandle
;;; |
;;;        MOV     r2, #0
;;; ]
;;;        SWI     XWimp_SendMessage
;;;        B       ExitHandler
;;;
;;;resourcefsmessage
;;;        DCD     messageend-resourcefsmessage
;;;        DCD     0                       ; filled in by Wimp
;;;        DCD     0                       ; filled in by Wimp
;;;        DCD     0
;;;        DCD     Message_FilerOpenDir
;;;        DCD     fsnumber_resourcefs     ; filing system number
;;;        DCD     0                       ; bitset
;;;        DCB     "Resources:$.Apps", 0   ; pathname
;;;        DCB     "Apps", 0               ; directory title
;;;        ALIGN
;;;messageend
;;;
;;;Key_Heart
;;;        ADR     R0, CB_Heart
;;;        MOV     R1, R12
;;;        SWI     XOS_AddCallBack
;;;        B       ExitHandler
;;;
;;;
;;;CB_Heart
;;;        ENTRY   "R0-R9"
;;;        ADR     R0, HeartCommand
;;;        SWI     XOS_CLI
;;;        EXIT
;;;
;;;HeartCommand
;;;        ;DCB     "<Fav$App>", 0
;;;        DCB     "Filer_Run <Fav$App>", 0
;;;        ALIGN

Key_ContrastDown
        BL      LCD_ContrastDown
        B       ExitHandler


Key_ContrastUp
        BL      LCD_ContrastUp
        B       ExitHandler


Key_BrightnessDown
        BL      LCD_BrightnessDown
        B       ExitHandler


Key_BrightnessUp
        BL      LCD_BrightnessUp
        B       ExitHandler


Key_DimBrightness
        BL      LCD_DimBrightness
        B       ExitHandler

;
; Send a service call round to indicate that the 'AccessLock' key has been
; pressed, this should provide enough of a hook security module (3rd party)
; to be written. 
;
Key_AccessLock
        MOV     R1, #Service_AccessLockKey
        SWI     XOS_ServiceCall
        B       ExitHandler




 [ SimulateBMU
BMUBits * (PortableBMUF_ChargerPresent :OR: PortableBMUF_BatteryPresent  :OR: PortableBMUF_LidOpen)

;
; Normal battery state
;
40
        MOV     R0, #Event_PortableBMU
        MOV     R1, #BMUBits :OR: PortableBMUF_ChargeKnown
        SWI     XOS_GenerateEvent
        B       ExitHandler
;
; Battery low
;
41
        MOV     R0, #Event_PortableBMU
        MOV     R1, #BMUBits :OR: PortableBMUF_ChargeKnown :OR: PortableBMUF_Threshold_1
        SWI     XOS_GenerateEvent
        B       ExitHandler
;
; Battery empty
;
42
        MOV     R0, #Event_PortableBMU
        MOV     R1, #BMUBits :OR: PortableBMUF_ChargeKnown :OR: PortableBMUF_Threshold_2
        SWI     XOS_GenerateEvent
        B       ExitHandler
;
; Charger fault
;
43
        MOV     R0, #Event_PortableBMU
        MOV     R1, #BMUBits :OR: PortableBMUF_ChargeFault
        SWI     XOS_GenerateEvent
        B       ExitHandler
;
; Charge unknown ie estimate
;
44
        MOV     R0, #Event_PortableBMU
        MOV     R1, #BMUBits
        SWI     XOS_GenerateEvent
        B       ExitHandler
;
; Full charge
;
45
        MOV     R0, #Event_PortableBMU
        MOV     R1, #BMUBits :OR: PortableBMUF_ChargeKnown :OR: PortableBMUF_Threshold_3
        SWI     XOS_GenerateEvent
        B       ExitHandler
 ]




        END
