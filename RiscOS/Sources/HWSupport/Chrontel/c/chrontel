/* > chrontel.c								*/
/**/
/*		Provide support for Chrontel hardware.			*/
/**/

#include <stddef.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"

#include "chrontel.h"
#include "iomd.h"
#include "nvram.h"


static int CurrentX = 0, CurrentY = 0;

static dirmapping Directions[5] = {
	{ "up",		0,	1 },
	{ "down",	0,	-1 },
	{ "left",	-1,	0 },
	{ "right",	1,	0 },
	{ NULL,		0,	0 }
};


/* Modify IOLINES register. */
/**/
static void
ModifyIOLINES( int bits, int xor )
{
	int iolines, irqs_on = !_kernel_irqs_disabled();

	if ( irqs_on ) _kernel_irqs_off();
	iolines = *(char *)IOMD_IOLINES;
	*(char *)IOMD_IOLINES = ((iolines & ~bits) ^ xor) | IOMD_IOLINES_INPUTS;
	if ( irqs_on ) _kernel_irqs_on();
}


/* Read current video clock rate from NV-RAM. */
/**/
static int
ReadVClock( void )
{
        int vclock, err;

        if ( _swix(NVRAM_Read, _INR(0,2)|_OUT(0), NVRAM_VIDEOCLOCKRATE, &vclock, 0, &err) == NULL )
                if ( err > 0 ) return vclock;

        return 0;
}


/* Move the display according to parameter 'directions' which is a bit	*/
/* field which can be written to the direction control bits in our	*/
/* 'magic' location.							*/
/**/
static void
MoveDisplay( int directions )
{
	int irqs_on = !_kernel_irqs_disabled();
	int vclock = ReadVClock();

	/* Invert 'directions' as we need to go high->low to drive Chrontel	*/
	/* and or in the current video clock value.				*/
	directions = (~directions & CHRONTEL_CONTROL_DIRMASK) | vclock;

	if ( irqs_on ) _kernel_irqs_off();

	/* Write to 'magic' location. */
	*(char *)CHRONTEL_CONTROL = (char)directions;

	/* Reset 'magic' location to default all lines high + current video clock value. */
	*(char *)CHRONTEL_CONTROL = CHRONTEL_CONTROL_DEFAULT | vclock;

	if ( irqs_on ) _kernel_irqs_on();
}


/* Get current X, Y values. */
/**/
static void
GetCurrent( int *x, int *y )
{
        int ret;

        if ( _swix(NVRAM_Read, _INR(0,2)|_OUT(0), NVRAM_DISPLAYXPOSITION, x, 0, &ret) == NULL )
                if ( (ret > 0) && (_swix(NVRAM_Read, _INR(0,2)|_OUT(0), NVRAM_DISPLAYYPOSITION, y, 0, &ret) == NULL) )
                        if ( ret > 0 ) return;
        *x = *y = 0;
}


/* Set current X, Y values. */
/**/
static void
SetCurrent( int x, int y )
{
	CurrentX = x;
	CurrentY = y;

        _swix( NVRAM_Write, _INR(0,2), NVRAM_DISPLAYXPOSITION, &CurrentX, 0 );
        _swix( NVRAM_Write, _INR(0,2), NVRAM_DISPLAYYPOSITION, &CurrentY, 0 );
}


/* Set the display position to X, Y */
/**/
static void
SetDisplay( int x, int y )
{
	int nx, ny, dirx, diry;

	/* Limit X position. */
	if ( x > CHRONTEL_MAXX ) x = CHRONTEL_MAXX;
	else if ( x < -CHRONTEL_MAXX ) x = -CHRONTEL_MAXX;

	/* Limit Y position. */
	if ( y > CHRONTEL_MAXY ) y = CHRONTEL_MAXY;
	else if ( y < -CHRONTEL_MAXY ) y = -CHRONTEL_MAXY;

	/* Determine absolute X movement and direction. */
	nx = x - CurrentX;
	if ( nx < 0 )
	{
		nx = -nx;
		dirx = CHRONTEL_CONTROL_DOWN;
	} else
		dirx = CHRONTEL_CONTROL_UP;

	/* Determine absolute Y movement and direction. */
	ny = y - CurrentY;
	if ( ny < 0 )
	{
		ny = -ny;
		diry = CHRONTEL_CONTROL_LEFT;
	} else
		diry = CHRONTEL_CONTROL_RIGHT;

	/* Move in X and Y at the same time and stop when no more movement required. */
	while ( (nx > 0) | (ny > 0) )
	{
		int dirs = 0;
		if ( nx-- > 0 ) dirs |= dirx;
		if ( ny-- > 0 ) dirs |= diry;
                MoveDisplay( dirs );
	}

	/* Set current values in NV-RAM. */
	SetCurrent( x, y );
}


/* Perform case insensitive string comparison - returns true if the same */
/**/
static int
StrNoCaseCmp( char *str1, char *str2 )
{
	/* Only need to check for one string terminator as the second condition	*/
	/* catches the other string terminating when the first does not.	*/
	while ( (*str1 != '\0') && (tolower(*str1) == tolower(*str2)) )
	{
		str1++; str2++;
	}

	/* Return true if the strings are the same. */
	return (*str1 == '\0') && (*str2 == '\0');
}


/* Scan the Directions table to try to find a match. Return the deltas	*/
/* and non-zero if a match is found otherwise return 0.			*/
/**/
static int
FindDeltas( char *direction, int *dx, int *dy )
{
	int i;

	for ( i = 0; Directions[i].name != NULL; i++ )
		if ( StrNoCaseCmp(Directions[i].name, direction) )
		{
			*dx = Directions[i].dx;
			*dy = Directions[i].dy;
			return -1;
		}

	return 0;
}
		

/* Move the display based on one of the strings in the Directions table.	*/
/* These are case insensitive.							*/
/**/
void
chrontel_move( char *direction )
{
	if ( StrNoCaseCmp(direction, "reset") )
		SetDisplay( 0, 0 );
	else
	{
		/* Get movement deltas. */
		int dx, dy;

		if ( FindDeltas(direction, &dx, &dy) )
			/* Add the deltas from the table to the current position to set the new position. */
			SetDisplay( CurrentX + dx, CurrentY + dy );
	}
}


/* Power up/down the Chrontel device. Powering up means resetting the	*/
/* configured display position.						*/
void
chrontel_power( int reason )
{
	ModifyIOLINES( IOMD_IOLINES_VIDEOPOWERUP, (reason == CHRONTEL_POWERUP) ? IOMD_IOLINES_VIDEOPOWERUP : 0 );
}


_kernel_oserror *
chrontel_initialise( void )
{
	/* Set system variable to allow positioning from HTML pages. */
	_swix( OS_SetVarVal, _INR(0,4), CHRONTEL_VAR, CHRONTEL_VARVAL, CHRONTEL_VARVALLEN, 0, 0 );

	/* Read configured x and y movements from NV-RAM. */
	GetCurrent( &CurrentX, &CurrentY );

	/* Power up Chrontel device. */
	chrontel_power( CHRONTEL_POWERUP );

        SetDisplay( CurrentX, CurrentY );

	return NULL;
}


void
chrontel_finalise( void )
{
	/* Maybe shouldn't do this but... */
	chrontel_power( CHRONTEL_POWERDOWN );
}
