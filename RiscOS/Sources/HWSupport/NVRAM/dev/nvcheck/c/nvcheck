/* NVRAM resource file checker. */

/* This utility can be used to ensure the validity of the resource file	*/
/* used by the NVRAM module which specifies the location of individual	*/
/* items allocated in NV-RAM. The resource file is read by the NVRAM	*/
/* module using MessageTrans to perform tag lookups. This utility reads	*/
/* the file passed on the command line directly. The syntax of the	*/
/* utility is as follows:						*/
/*									*/
/*	nvcheck [-v] <file>						*/
/*									*/
/* The resource file should contain lines of the following format:	*/
/*									*/
/* <tag>:<location>,<start bit>,<length>,<default>,<flags>		*/
/*									*/
/* Where <tag> and <location> must be provided but all other fields are	*/
/* optional and have the following defaults:				*/
/*									*/
/*	<start bit>	0						*/
/*	<length>	8 (bits)					*/
/*	<default>	0						*/
/*	<flags>		None						*/
/*									*/
/* <flags> may be one or both of P (protected) and L (locked) where	*/
/* protected means not changed on NV-RAM reset and locked means cannot	*/
/* be changed by the caller. Optional fields may be left empty or may	*/
/* not be present at all, thus the following are all valid lines:	*/
/*									*/
/* ExampleLocation0:&80							*/
/* Example2:123,,,&FF							*/
/* Example3:&34,2,2,&03,P						*/

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>


#define FALSE			0
#define TRUE			(!FALSE)

#define LINELEN			128

#define DEFAULT_START_BIT	0
#define DEFAULT_LENGTH		8
#define DEFAULT_VALUE		0
#define DEFAULT_FLAGS		0

#define SEPARATOR		','

#define FLAGS_LOCKED		(1<<0)
#define FLAGS_PROTECTED		(1<<1)

/* NV-RAM size in bits. */
#define NVRAM_BYTE_SIZE		2048
#define NVRAM_SIZE		(NVRAM_BYTE_SIZE*8)

typedef struct _location {
	int location, start_bit, length, value, flags;
} location;

typedef struct _bit {
	char *tag;
} bit;


int verbose = FALSE;
int cline;
char *ctag;
bit *bits;

char *
skip_spaces(char *cp)
{
	while (isspace(*cp)) cp++;
	return cp;
}

char *
skip_past(char *cp, char c)
{
	/* Skip past char c but stop at '\0'. */
	while ((*cp != '\0') && (*cp != c)) cp++;
	return (*cp == '\0') ? cp : cp + 1;
}

int
get_value(char **ppd, int default_value)
{
	int base = 10, value = default_value;
	char *pd = skip_spaces(*ppd);

	if (*pd == '&')
	{
		base = 16;
		pd++;
	}
	if ((*pd != '\0') && (*pd != SEPARATOR))
	{
		value = 0;
		do
		{
			int digit = *pd - '0';
			if (base == 16)
			{
				/* Adjust for 'A' to 'F'. */
				if (digit > 9) digit -= 'A'-'9'-1;
				/* Adjust for 'a' to 'f'. */
				if (digit > 15) digit -= 'a'-'A';
			}
			if ((digit < 0) || (digit >= base)) break;
			value = value * base + digit;
			pd++;
		}
		while ((*pd != '\0') && (*pd != SEPARATOR));

		pd = skip_spaces(pd);
		if ((*pd != '\0') && (*pd != SEPARATOR))
		{
			/* Print error here. This would not normally be done if	*/
			/* we were not specifically looking for errors and the	*/
			/* field would just take its default value.		*/
			printf("Error in field for tag '%s' at line %d\n", ctag, cline);

			value = default_value;
		}
	}
	*ppd = skip_past(pd, SEPARATOR);
	return value;
}

int
get_flags(char *pd, int default_flags)
{
	int flags = 0;
	pd = skip_spaces(pd);

	/* Assume that flags is the last field ie. is terminated with '\0'. */
	while (TRUE)
	{
		switch (*pd)
		{
		case 'L':
		case 'l':
			flags |= FLAGS_LOCKED;
			break;

		case 'P':
		case 'p':
			flags |= FLAGS_PROTECTED;
			break;

		default:
			if (isspace(*pd)) break;

			if (*pd != '\0')
			{
				/* Print error here. This would not normally be done if	*/
				/* we were not specifically looking for errors and the	*/
				/* field would just take its default value.		*/
				printf("Error in flags for tag '%s' at line %d\n", ctag, cline);

				return default_flags;
			}
			return flags;
		}
		pd++;
	}
	/* Compiler will whinge but don't worry. */
}

void
parse_description(char *pd, location *ploc)
{
	/* Get values for all fields, providing defaults for missing or	*/
	/* broken fields.						*/
	ploc->location = get_value(&pd, -1);
	ploc->start_bit = get_value(&pd, DEFAULT_START_BIT);
	ploc->length = get_value(&pd, DEFAULT_LENGTH);
	ploc->value = get_value(&pd, DEFAULT_VALUE);
	ploc->flags = get_flags(pd, DEFAULT_FLAGS);
}

void
check_bits(location *ploc)
{
	char *tag = NULL, *last_clash_tag = NULL;
	int start_bit = ploc->location * 8 + ploc->start_bit;
	int end_bit = start_bit + ploc->length;
	int i;

	for (i = start_bit; i < end_bit; i++)
	{
		/* Check for a clash. */
		if (bits[i].tag != NULL)
		{
			/* But only report each tag clash once, not for each bit. */
			if (bits[i].tag != last_clash_tag)
			{
				printf("Tag '%s' clashes with tag '%s'\n", ctag, bits[i].tag);
				last_clash_tag = bits[i].tag;
			}
		} else {
			/* No clash so copy tag if not already done and store in bits. */
			if (tag == NULL)
			{
				tag = (char *)malloc(strlen(ctag) + 1);
				if (tag != NULL)
					strcpy(tag, ctag);
				else
					printf("Couldn't allocate memory for tag\n");
			}
			bits[i].tag = tag;
		}
	}
}

void
check_location(location *ploc)
{
	if (ploc->location != -1)
	{
		if (ploc->location < NVRAM_BYTE_SIZE)
		{
			int max_value = (1 << ploc->length) - 1;

			if (verbose)
				printf("%s: location=%d, start_bit=%d, length=%d, value=%d, flags=%d\n",
					ctag, ploc->location, ploc->start_bit, ploc->length, ploc->value, ploc->flags);
			if ((max_value >= 0) && (ploc->value > max_value))
				printf("Default value out of range for tag '%s' at line %d\n", ctag, cline);
			check_bits(ploc);
		} else
			printf("Location out of range for tag '%s' at line %d\n", ctag, cline);
	} else
		printf("Missing location for tag '%s' at line %d\n", ctag, cline);
}

void
check_description(char *desc)
{
	location loc;

	/* Parse the description into a location structure and	*/
	/* check for collisions.				*/
	parse_description(desc, &loc);
	check_location(&loc);
}

void
check_tag(char *tag)
{
	/* Tag must exist and must be all alphanumeric or '_'. */
	if (*tag != '\0')
	{
		do {
			if (!isalnum(*tag) && (*tag != '_'))
				printf("Illegal '%c' in tag '%s' at line %d\n", *tag, ctag, cline);
		} while (*++tag != '\0');
	} else
		printf("Missing tag at line %d\n", cline);
}

void
process_line(char *line)
{
	if ((*line != '\0') && (*line != '#'))
	{
		/* Find the tag separator. */
		char *separator = strchr(line, ':');
		
		if (separator != NULL)
		{
			/* Split into tag and description and check both. */
			*separator = '\0';
			ctag = line;
			check_tag(ctag);
			check_description(separator+1);
		} else
			printf("Missing ':' at line %d\n", cline);
	}
}

void
process_file(FILE *fp)
{
	char *line = (char *)malloc(LINELEN);

	cline = 0;

	if (line != NULL)
	{
		while (fgets(line, LINELEN, fp) != NULL)
		{
			char *cp = strchr(line, '\n');
			++cline;
			if (cp != NULL) *cp = '\0';
			process_line(line);
		}
		free(line);
	} else
		printf("Failed to allocate line buffer\n");
}

void
report_free(int start_bit, int end_bit)
{
	int start_loc = start_bit / 8;
	int end_loc = end_bit / 8;

	printf("Bits free (%d) ", end_bit - start_bit + 1);

	start_bit -= start_loc * 8;
	end_bit -= end_loc * 8;
	
	printf("between location &%03x bit %d and location &%03X bit %d\n",
		start_loc, start_bit, end_loc, end_bit);
}

void
free_bits( void )
{
	int i, last_free = -1;
	char *last_tag = NULL;

	for (i = 0; i < NVRAM_SIZE; i++)
	{
		if (bits[i].tag == NULL)
		{
			/* Check for start of a free range of bits. */
			if (last_free < 0) last_free = i;
		}
		else
		{
			/* Check for end of a free range of bits. */
			if (last_free >= 0)
			{
				report_free(last_free, i-1);

				/* Get ready for next range of free bits. */
				last_free = -1;
			}
			/* Free copies of tags we made (but only once). */
			if (bits[i].tag != last_tag)
			{
				if (last_tag != NULL) free(last_tag);
				last_tag = bits[i].tag;
			}
		}
	}
	/* Report any free space to the end of NV-RAM. */
	if (last_free >= 0) report_free(last_free, NVRAM_SIZE-1);

	/* Free bits array. */
	free(bits);
}

void
syntax( void )
{
	printf("Syntax: nvcheck [-v] <file>\n");
	exit(1);
}

int
main(int argc, char **argv)
{
	char *file = NULL;
	FILE *fp;

	while (--argc)
	{
		if (*(*++argv) == '-')
		{
			switch (*(*argv+1))
			{
			case 'v':
				verbose = TRUE;
				break;

			default:
				syntax();
			}
		}
		else
		{
			if (file != NULL) syntax();
			file = *argv;
		}
	}

	if (file == NULL) syntax();

	if ((fp = fopen(file, "r")) != NULL)
	{
		int bufsz = sizeof(bit) * NVRAM_SIZE;

		if ((bits = (bit *)malloc(bufsz)) != NULL)
		{
			memset(bits, 0, bufsz);
			process_file(fp);
			free_bits();
		} else
			printf("Could not allocate memory for bit array\n");

		fclose(fp);
	} else
		printf("Could not open file '%s'\n", file);
}

