/* > nvram.c */

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "nvram.h"
#include "msgfile.h"
#include "parse.h"
#include "error.h"

#include "trace.h"


ERROR_STRUCT( NOMEM, "NoMem" );

static char *pCache = NULL;
static char *pTagBuf, *pDescBuf;


static void
RawRead( char *pbuf, int byte, int count )
{
	/* Read and buffer 'count' bytes from NV-RAM starting at location 'byte'. */
	while ( count-- > 0 )
	{
		int value;
		
		_swix( OS_Byte, _INR(0,1)|_OUT(2), OSBYTE_READCMOS, byte++, &value );
		*pbuf++ = (char)value;
	}
}


static void
RawWrite( char *pbuf, int byte, int count )
{
	/* Write 'count' bytes from buffer into NV-RAM starting at location 'byte'. */
	char *ptmp = pbuf + byte;

	while ( count-- > 0 )
		_swix( OS_Byte, _INR(0,2), OSBYTE_WRITECMOS, byte++, *ptmp++ );

	/* Update checksum in 'pbuf' by reading back from Kernel. */
	RawRead( pbuf, NVRAM_CHECKSUM_BYTE, 1 );
}


static void
RawConsistent( char *pold, char *pnew, int byte, int count )
{
	/* Current NV-RAM contents are in 'pold' buffer, new contents are in	*/
	/* 'pnew' buffer. Go through 'count' bytes starting at location 'byte'	*/
	/* and set any bytes from 'pnew' that are different from those in	*/
	/* 'pold' ie. bring NV-RAM up to date with as few writes as possible.	*/
	while ( count-- > 0 )
	{
		/* Check for differences but don't update checksum byte!! */
		if ( (byte != NVRAM_CHECKSUM_BYTE) && (pnew[byte] != pold[byte]) )
			_swix( OS_Byte, _INR(0,2), OSBYTE_WRITECMOS, byte, pnew[byte] );
		byte++;
	}

	/* Update checksum in 'pnew' by reading back from Kernel. */
	RawRead( pnew, NVRAM_CHECKSUM_BYTE, 1 );
}


static int
ReadValue( char *pbuf, unsigned int location, unsigned int start_bit, unsigned int length )
{
	/* Ensure that 'start_bit' and 'length' are reasonable values. */
	start_bit &= 7; length = ((length - 1) & 31) + 1;

	/* Check start and end bytes are in range. */
	if ( (location < NVRAM_SIZE) && (location + (start_bit + length - 1) / 8 < NVRAM_SIZE) )
	{
		int value, totlen;
	
		/* Read a 'length'-bit value from 'pbuf' starting at bit 'start_bit' of	*/
		/* byte 'location'.							*/
		pbuf += location;
		value = *pbuf >> start_bit;
		totlen = 8 - start_bit;
		while ( totlen < length )
		{
			value |= *++pbuf << totlen;
			totlen += 8;
		}
		return value & ((1 << length) - 1);
	}
	return 0;
}


static void
WriteValue( char *pbuf, int value, unsigned int location, unsigned int start_bit, unsigned int length, unsigned int flags )
{
	int byte_length;
	
	/* Ensure that 'start_bit' and 'length' are reasonable values. */
	start_bit &= 7; length = ((length - 1) & 31) + 1;
	byte_length = (start_bit + length + 7) / 8;
	
	/* Check start and end bytes are in range. */
	if ( (location < NVRAM_SIZE) && (location + byte_length - 1 < NVRAM_SIZE) )
	{
		unsigned int mask = (1 << length) - 1;
		char *ptmp = pbuf + location;
		
		/* Write a 'length'-bit value into 'pbuf' starting at bit 'start_bit'	*/
		/* of byte 'location'.							*/
		value &= mask;
		*ptmp = (*ptmp & ~(mask << start_bit)) | (value << start_bit);
		value >>= 8 - start_bit;
		mask >>= 8 - start_bit;
		while ( mask != 0 )
		{
			ptmp++;
			*ptmp = (*ptmp & ~mask) | value;
			value >>= 8;
			mask >>= 8;
		}

		/* If writing through to NV-RAM then do the raw write. */
		if ( flags & NVRAM_FLAGS_WRITETHROUGH )
			RawWrite( pbuf, location, byte_length );
	}
}


/* Note that contrary to other calls, length must be an int here. */
static void
CopyBuffer( char *psource, char *pdest, unsigned int location, unsigned int start_bit, int length, unsigned int flags )
{
	int byte_length;
	
	/* Ensure that 'start_bit' and 'length' are reasonable values. */
	start_bit &= 7; length = ((length - 1) & 31) + 1;
	byte_length = (start_bit + length + 7) / 8;

	/* Check start and end bytes are in range. */
	if ( (location < NVRAM_SIZE) && (location + byte_length - 1 < NVRAM_SIZE) )
	{
		unsigned int mask = (1 << length) - 1;	/* Will be -1 for length >= 32. */
		char *ptmp = pdest + location;
		psource += location;
		*ptmp = (*ptmp & ~(mask << start_bit)) | (*psource & (mask << start_bit));
		length -= 8 - start_bit;
		while ( length > 7 )
		{
			*++ptmp = *++psource;
			length -= 8;
		}
		if ( length > 0 )
		{
			++ptmp;
			mask = (1 << length) - 1;
			*ptmp = (*ptmp & ~mask) | (*++psource & mask);
		}

		/* If writing through to NV-RAM then do the raw write. */
		if ( flags & NVRAM_FLAGS_WRITETHROUGH )
			RawWrite( pdest, location, byte_length );
	}
}


static void
FullReset( char *pold, char *pnew, location *ploc )
{
	/* Check for location being protected. */
	if ( ploc->flags & LOCATION_FLAGS_PROTECTED )
	{
		TRACE( "Copying old contents into cache for location &%03X\n" _ ploc->location );

		/* Protected so copy old contents into new contents. */
		CopyBuffer( pold, pnew, ploc->location, ploc->start_bit, ploc->length, NVRAM_FLAGS_WRITECACHE );
	} else {
		/* Otherwise set default value (only possible for locations with length <= 32). */
		if ( ploc->length <= 32 )
		{
			TRACE( "Setting default value for location &%03X\n" _ ploc->location );

			WriteValue( pnew, ploc->value, ploc->location, ploc->start_bit, ploc->length, NVRAM_FLAGS_WRITECACHE );
		}
	}
}


static void
LockedReset( char *pold, char *pnew, location *ploc )
{
	if ( ploc->flags & LOCATION_FLAGS_LOCKED )
	{
		/* Set default value (only possible for locations with length <= 32). */
		if ( ploc->length <= 32 )
		{
			TRACE( "Setting locked value for location &%03X\n" _ ploc->location );

			WriteValue( pnew, ploc->value, ploc->location, ploc->start_bit, ploc->length, NVRAM_FLAGS_WRITECACHE );
		}
	}

	NOT_USED( pold );
}


static int
GetLocation( char *ptag, location *ploc )
{
	char *pdesc;

	TRACE( "Looking up tag '%s'\n" _ ptag );

	/* Lookup tag and parse description into location 'ploc'. */
	pdesc = msgfile_lookup( ptag, pDescBuf, TMPBUF_SIZE, NULL );
	return ( pdesc != NULL ) ? parse_description( pdesc, ploc ) : 0;
}


static _kernel_oserror *
IterateTags( char *pold, char *pnew, void (*function)(char *, char *, location *) )
{
	_kernel_oserror *err;
	int index = 0;

	TRACE( "Iterating through Tags file\n" );

	/* Iterate through Tags file and call 'function' for each tag. */
	while (1)
	{
		location loc;

		err = msgfile_enumerate( "*", pTagBuf, TMPBUF_SIZE, &index );
		if ( (err != NULL) || (index == 0) ) break;
		if ( GetLocation(pTagBuf, &loc) )
			(*function)( pold, pnew, &loc );
	}
	return err;
}


_kernel_oserror *
nvram_initialise( void )
{
	_kernel_oserror *err = NULL;

	/* Allocate space for the cache + space for tag buffer + space for description buffer. */
	if ( (pCache = (char *)malloc(NVRAM_SIZE + TMPBUF_SIZE*2)) != NULL )
	{
		/* Allocate space for temporary cache copy. */
		char *pbuf = (char *)malloc(NVRAM_SIZE);

		TRACE( "Allocated cache at &%08X\n" _ pCache );

		if ( pbuf != NULL )
		{
			/* Set up scratch buffers to avoid malloc/free every time we	*/
			/* look up a tag.						*/
			pTagBuf = pCache + NVRAM_SIZE;
			pDescBuf = pTagBuf + TMPBUF_SIZE;

			/* Read and cache all NV-RAM contents in temporary buffer. */
			TRACE( "Reading NV-RAM\n" );
			RawRead( pbuf, 0, NVRAM_SIZE );
	
			if ( ReadValue(pbuf, NVRAM_LASTRESET_BYTE, NVRAM_LASTRESET_BIT, 1) != 0 )
			{
				TRACE( "Performing full NV-RAM reset\n" );
	
				/* Need to reset NV-RAM so start from all 0. */
				memset( pCache, 0, NVRAM_SIZE );
	
				/* Iterate through tags and perform a full reset. */
				err = IterateTags( pbuf, pCache, FullReset );
			} else {
				TRACE( "Performing reset of locked NV-RAM only\n" );
				
				/* Only ensuring locked locations so start from cache. */
				memcpy( pCache, pbuf, NVRAM_SIZE );
	
				/* Iterate through tags and only reset locked values. */
				err = IterateTags( pbuf, pCache, LockedReset );
			}
	
			/* Compare buffer with cache and make NV-RAM consistent with cache. */
			if ( err == NULL )
			{
				TRACE( "Making NV-RAM consistent with cache\n" );
				RawConsistent( pbuf, pCache, 0, NVRAM_SIZE );
			}

			/* Free temporary cache copy. */
			free( pbuf );
		} else
			err = ERROR(NOMEM);
	} else
		err = ERROR(NOMEM);

	/* Note that if we return an error then nvram_finalise is called and pCache is freed. */
	return err;
}


void
nvram_finalise( void )
{
	/* Free the cache. */
	if ( pCache != NULL )
	{
		free( pCache );
		pCache = NULL;
	}
	msgfile_close();
}


_kernel_oserror *
nvram_read( _kernel_swi_regs *r )
{
	location loc;
	
	if ( GetLocation((char *)r->r[0], &loc) )
	{
		int req_bufsz = (loc.length + loc.start_bit + 7) / 8;

		if ( r->r[1] == 0 )
		{
			/* Buffer pointer is 0 so just return required buffer size. */
			r->r[0] = req_bufsz;
		}
		else
		{
			if ( r->r[2] == 0 )
			{
				/* We have a buffer but want to read a value so check this location	*/
				/* fits in a word and assume r->r[1] points to an int.			*/
				if ( loc.length <= 32 )
				{
					*(int *)(r->r[1]) = ReadValue( pCache, loc.location, loc.start_bit, loc.length );
					r->r[0] = 4;
				}
				else
					r->r[0] = NVRAM_READ_BUFERR;
			}
			else
			{
				/* We have a buffer and want to read directly into it so check the	*/
				/* buffer size, zero the buffer and do the copy.			*/
				if ( r->r[2] >= req_bufsz )
				{
					memset( (char *)r->r[1], 0, r->r[2] );
					/* Destination pointer gets loc.location added so subtract	*/
					/* before calling and we definitely don't want to update the	*/
					/* cache!							*/
					CopyBuffer( pCache, (char *)(r->r[1] - loc.location), loc.location, loc.start_bit, loc.length, NVRAM_FLAGS_WRITECACHE );
					r->r[0] = req_bufsz;
				}
				else
					r->r[0] = NVRAM_READ_BUFERR;
			}
		}
	}
	else
		r->r[0] = NVRAM_READ_TAGERR;
					
	return NULL;
}


_kernel_oserror *
nvram_write( _kernel_swi_regs *r )
{
	location loc;
	
	if ( GetLocation((char *)r->r[0], &loc) )
	{
		if ( loc.flags & LOCATION_FLAGS_LOCKED )
		{
			/* Location is locked so can't be updated. */
			r->r[0] = NVRAM_WRITE_LOCKERR;
		}
		else
		{
			if ( r->r[2] == 0 )
			{
				/* Want to write a value so assume r->r[1] points to an int. */
				WriteValue( pCache, *(int *)(r->r[1]), loc.location, loc.start_bit, loc.length, NVRAM_FLAGS_WRITETHROUGH );
			}
			else
			{
				/* Have a buffer so copy bits into cache and update NV-RAM but	*/
				/* make sure we don't go past the end of the caller's buffer.	*/
				int caller_length = r->r[2] * 8 - loc.start_bit;
				
	                        CopyBuffer( (char *)(r->r[1] - loc.location), pCache, loc.location, loc.start_bit,
	                        		(caller_length < loc.length) ? caller_length : loc.length, NVRAM_FLAGS_WRITETHROUGH );
	                }
	                r->r[0] = 0;	/* Return no error. */
                }
	} else
		r->r[0] = NVRAM_WRITE_TAGERR;

	return NULL;
}
