/* > parse.c */

#include <ctype.h>

#include "nvram.h"

#include "trace.h"


static int
IsSpace(char c)
{
	return (c == ' ') || (c == 9);
}

static char *
SkipSpaces(char *cp)
{
	while ( (*cp == ' ') || (*cp == 9) ) cp++;
	return cp;
}

static char *
SkipPast(char *cp, char c)
{
	/* Skip past char c but stop at '\0'. */
	while ((*cp != '\0') && (*cp != c)) cp++;
	return (*cp == '\0') ? cp : cp + 1;
}


static unsigned int
GetValue(char **ppd, int default_value)
{
	int base = 10, value = default_value;
	char *pd = SkipSpaces(*ppd);

	TRACE( "GetValue: parsing '%s'\n" _ pd );

	if (*pd == '&')
	{
		base = 16;
		pd++;
	}
	if ((*pd != '\0') && (*pd != SEPARATOR))
	{
		value = 0;
		do
		{
			int digit = *pd - '0';
			if (base == 16)
			{
				/* Adjust for 'A' to 'F'. */
				if (digit > 9) digit -= 'A'-'9'-1;
				/* Adjust for 'a' to 'f'. */
				if (digit > 15) digit -= 'a'-'A';
			}

			TRACE( "GetValue: digit = %X\n" _ digit );

			if ((digit < 0) || (digit >= base)) break;
			value = value * base + digit;
			pd++;
		}
		while ((*pd != '\0') && (*pd != SEPARATOR));

		pd = SkipSpaces(pd);
		if ((*pd != '\0') && (*pd != SEPARATOR))
			value = default_value;
	}
	*ppd = SkipPast(pd, SEPARATOR);

	TRACE( "GetValue: now pointing to '%s'\n" _ *ppd );

	return value;
}

/******************************************************************
 Function:     GetDefaultValue
 Description:  When we read a default value, we may need to look at
               another tag if it contains an indirect reference
 Parameters:   ppd-> the pointer to the string (update this when you're
                     done)
               default_value = the value to assign when nothing is given
                               as a default value
               value_size = the size of the value we're writing into
 Returns:      value read
 NOTE:         JRF: I know this isn't a particularly wonderful way
                    of doing things, but I don't want to have to
                    re-structure all the file to cache the locations
                    and redirections just to implement this particular
                    thing. You can just have a small speed hit when
                    you look up indirected tags.
 Future:       What could be done in the future would be to allow fields
               to take arbitrary parameters so that any binary field
               sequence could be included, as could strings and any
               other data sequences. Simialrly it would allow larger
               than 4 byte fields to be defaulted by a tag.
 ******************************************************************/
static unsigned int
GetDefaultValue(char **ppd, int default_value, int value_size)
{
	unsigned int result=default_value;
	char *pd = SkipSpaces(*ppd);
	TRACE( "GetDefaultValue: parsing '%s'\n" _ pd );
	if (*pd == INDIRECT_START)
	{
		/* it's an indirected tag */
		char *name=++pd;
		while (*pd>=' ' && *pd!=INDIRECT_END)
			pd++;
		if (*pd==INDIRECT_END)
		{
			int length;
			/* valid NVRAM tag indirection */
			*pd++='\0'; /* terminate there */
			if (nvram_read(name,&result,sizeof result,&length) ||
			    length<=0)
			{
				result=default_value;
				TRACE( "GetDefaultValue: bad NVRAM value, using default, err= %i\n" _ err );
			}
			else
			{
				if (length*8 < value_size)
				{
					result=default_value;
					TRACE( "GetDefaultValue: default indirection size is > value size, ignoring\n" );
				}
			}
			*pd++=INDIRECT_END; /* put it back - icky */
			
			pd = SkipSpaces(pd);
			if ((*pd != '\0') && (*pd != SEPARATOR))
				result = default_value;
			*ppd = SkipPast(pd, SEPARATOR);
		}
	}
	else
		result=GetValue(ppd,default_value);
	
	TRACE( "GetDefaultValue: now pointing to '%s' got %i\n" _ *ppd _ result);
	return result;
}

static int
GetFlags(char *pd, int default_flags)
{
	int flags = 0;
	pd = SkipSpaces(pd);

	TRACE( "GetFlags: parsing '%s'\n" _ pd );

	/* Assume that flags is the last field ie. is terminated with '\0'. */
	while (1)
	{
		switch (*pd)
		{
		case 'L':
		case 'l':
			flags |= LOCATION_FLAGS_LOCKED;
			break;

		case 'P':
		case 'p':
			flags |= LOCATION_FLAGS_PROTECTED;
			break;

		default:
			if (IsSpace(*pd)) break;

			return (*pd != '\0') ? default_flags : flags;
		}
		pd++;
	}
	/* Compiler might whinge but don't worry. */
}

int
parse_description(char *pd, location *ploc, int nvram_limit)
{
	TRACE( "parse_description: parsing '%s'\n" _ pd );

	/* Get values for all fields, providing defaults for missing or	*/
	/* broken fields.						*/
	ploc->location = GetValue(&pd, -1);
	ploc->start_bit = GetValue(&pd, DEFAULT_START_BIT);
	ploc->length = GetValue(&pd, DEFAULT_LENGTH);
	ploc->value = GetDefaultValue(&pd, DEFAULT_VALUE, ploc->length);
	ploc->flags = GetFlags(pd, DEFAULT_FLAGS);

	TRACE( "location = &%03X, start_bit = %d, length = %d, value = %d, flags = %d\n" _ \
		ploc->location _ ploc->start_bit _ ploc->length _ ploc->value _ ploc->flags );

        /* If the field is outside the NVRAM, act as if the field doesn't exist */
	if (ploc->location >= nvram_limit)
	        return 0;

        /* Crop the field to the NVRAM available */
	if (ploc->location * 8 + ploc->start_bit + ploc->length > nvram_limit * 8)
	{
	        ploc->length = nvram_limit * 8 - (ploc->location * 8 + ploc->start_bit);
	}

	return (ploc->location != -1);
}
