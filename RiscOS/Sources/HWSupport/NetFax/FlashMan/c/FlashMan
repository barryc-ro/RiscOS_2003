#include <stdlib.h>
#include <stdio.h>
#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "time.h"
#include "netfax/flashlib/flashlib.h"
#include "misc.h"
#include "debuglib/debuglib.h"
#include "flashman.h"
#include "error.h"

#define Flash_NumberOfDataPages   2000
#define Flash_AddressOffset         48

/* Local static data structures */
static char freemap[Flash_NumberOfDataPages];
static int *result_list = NULL;

int *flash_used_records = NULL;
int *flash_used_forms = NULL;

/*
 * Functions
 */


/*
 * Module initialisation
 */
_kernel_oserror *flashman_initialise (void *pw, int podule_base)
{
  unsigned int seed;
  int page_num;
  flash_page *page;
  int ret;

  /* Seed the random number generator */
  seed = time (NULL);
  srand (seed);

  /* Need to find all the free pages in flash, and build up the
     free map
  */

  for (page_num = Flash_AddressOffset; page_num < (Flash_AddressOffset +
       Flash_NumberOfDataPages) ; page_num++)
  {
    ret = flashlib_read_page (page_num, &page);
    if (ret != Flash_ErrorCode_NoError)
    {
      switch (ret)
      {
        case Flash_ErrorCode_CRCFail:
          printf ("Fatal Error: Serial Flash checksum failed on read.\n");
          break;
        case Flash_ErrorCode_Timeout:
          printf ("Fatal Error: Timed-out waiting for serial flash.\n");
          break;
        case Flash_ErrorCode_SerFlashError:
          printf ("Fatal Error: Error calling SerialFlash SWIs\n");
          break;
      }
      return NULL;
    }

    if (page->data.structured.header.datatype == DataType_FreePage)
      freemap[page_num - Flash_AddressOffset] = 1;
    else
    {
      freemap[page_num - Flash_AddressOffset] = 0;

      switch (page->data.structured.header.datatype)
      {
        case DataType_FirstAddressPage:
          /* an address book entry */
          misc_integerlist_addto (&flash_used_records, page_num);
          break;

        case DataType_FirstFormPage:
          /* a form template */
          misc_integerlist_addto (&flash_used_forms, page_num);
          break;
      }
    }

    free (page);
  }

  return NULL;
}


/*
 * Module finalisation
 */
void flashman_finalise (void *pw)
{
  NOT_USED (pw);

  if (flash_used_records)
  {
    free (flash_used_records);
    flash_used_records = NULL;
  }

  if (flash_used_forms)
  {
    free (flash_used_forms);
    flash_used_records = NULL;
  }
}


/*
 * SWI DayFlashMan_Allocate
 *
 */
_kernel_oserror *flashman_allocate (_kernel_swi_regs *r)
{
  int page_num;
  int number_of_pages = r->r[0];
  int freepages_found = 0;
  int start, i;

  start = rand() % Flash_NumberOfDataPages;

  if (result_list)
  {
    free (result_list);
  }
  result_list = (int*) calloc (number_of_pages, sizeof(int));

  page_num = start;
  do
  {
    if (freemap[page_num])
      result_list[freepages_found++] = page_num + Flash_AddressOffset;

    page_num++;

    if (page_num == Flash_NumberOfDataPages)
      page_num = 0;

    /* We've been all the way through the list */
    if (page_num == start)
      break;
  }
  while (freepages_found < number_of_pages);

  if (freepages_found < number_of_pages)
  {
    r->r[0] = 0;
    r->r[1] = NULL;
  }
  else
  {
    for (i=0; i < number_of_pages; i++)
      freemap[result_list[i] - Flash_AddressOffset] = 0;

    r->r[0] = number_of_pages;
    r->r[1] = (int) result_list;
  }

  return NULL;
}


/*
 * SWI DayFlashMan_Deallocate
 *
 */
_kernel_oserror *flashman_deallocate (_kernel_swi_regs *r)
{
  int i;
  int *list = (int *) r->r[1];

  for (i=0; i < r->r[0]; i++)
    freemap[list[i] - Flash_AddressOffset] = 1;

  return NULL;
}


/*
 * SWI DayFlashMan_ShowAllocation
 *
 */
_kernel_oserror *flashman_showusage (_kernel_swi_regs *r)
{
  int i, j = 0, k = 0;

  NOT_USED (r);

  if (r->r[0] & 1)
  {
    for (i=0; i < Flash_NumberOfDataPages; i++)
    {
      if (freemap [i])
      {
        j++;
        dprintf (("", "%d Free\n", i + Flash_AddressOffset));
      }
      else
      {
        dprintf (("", "%d Used\n", i + Flash_AddressOffset));
        k++;
      }
    }

    dprintf (("", "%d free, %d used\n", j, k));
  }

  dprintf (("", "Address book records (%d):\n",
          misc_integerlist_findlength(flash_used_records)));
  misc_integerlist_print (flash_used_records);
  dprintf (("", "Forms records (%d):\n",
          misc_integerlist_findlength(flash_used_forms)));
  misc_integerlist_print (flash_used_forms);

  return NULL;
}

/*
 * SWI DayFlashMan_GetUsedList
 *
 */
_kernel_oserror *flashman_getusedlist (_kernel_swi_regs *r)
{
  if (r->r[0] == 0)
    r->r[0] = (int) flash_used_records;
  else
    r->r[0] = (int) flash_used_forms;

  return NULL;
}

/*
 * SWI DayFlashMan_ModifyUsedList
 *
 */
_kernel_oserror *flashman_modifyusedlist (_kernel_swi_regs *r)
{
  int **list_p;

  if (r->r[0] == 0)
    list_p = &flash_used_records;
  else
    list_p = &flash_used_forms;

  if (r->r[1] == 0)
    misc_integerlist_addto (list_p, r->r[2]);
  else
    misc_integerlist_removefrom (list_p, r->r[2]);

  return NULL;
}
