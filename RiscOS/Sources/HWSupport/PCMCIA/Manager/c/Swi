/*****************************************************************************************/
/***                                                                                   ***/
/***  Swi.c                                                                            ***/
/***                                                                                   ***/
/***  Application:   PCMCIA Manager                                                    ***/
/***  Version:       0.2                                                               ***/
/***                                                                                   ***/
/***  By:            W.Turner, Acorn Computers Ltd.                                    ***/
/***  Date:          30th July 1994                                                    ***/
/***                                                                                   ***/
/***  Purpose:       Contains the code which parses the SWI calls.                     ***/
/***                                                                                   ***/
/***  History:       0.01 30th July 1993 - Original version                            ***/
/***                 0.2  30th July 1994 - Vast changes due to spec review             ***/
/***                                                                                   ***/
/*****************************************************************************************/

/*****************************************************************************************/
/***                                                                                   ***/
/***  Routines:-                                                                       ***/
/***    PCMCIAManager_SwiHandler()                                                     ***/
/***    PCMCIA_Version()                                                               ***/
/***    PCMCIA_Drivers()                                                               ***/
/***    PCMCIA_Cis()                                                                   ***/
/***    PCMCIA_Read()                                                                  ***/
/***    PCMCIA_Write()                                                                 ***/
/***    PCMCIA_FSOp()                                                                  ***/
/***                                                                                   ***/
/***    PCMCIA_TestDriverFunction()                                                    ***/
/***    PCMCIA_SetAccessWidth()                                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"

#include "Defs.h"
#include "Structs.h"
#include "Variables.h"
#include "Driver.h"
#include "Read.h"
#include "Write.h"
#include "Error.h"
#include "Cis.h"
#include "FSOp.h"
#include "PowerOp.h"
#include "Interrupts.h"
#include "misc.h"
#include "Swi.h"

#include "Debug.h"



#if Debug == TRUE
PCMCIAManager_ErrorCode PCMCIA_TestDriverFunction(_kernel_swi_regs *);
PCMCIAManager_ErrorCode PCMCIA_SetAccessWidth(_kernel_swi_regs *);
#endif


/*****************************************************************************************/
/***                                                                                   ***/
/***  PCMCIAManager_SwiHandler(SWI_number, regs, pw)                                   ***/
/***                                                                                   ***/
/***  This function will parse the swi passed, and call the necessary routines to      ***/
/***  perform the requested action. Note that this function will not perform any       ***/
/***  actions unless the resouceses are loaded for this module.                        ***/
/***                                                                                   ***/
/***  SWIs:                                                                            ***/
/***     0      - PCMCIA_Version                                                       ***/
/***     1      - PCMCIA_Drivers                                                       ***/
/***                                                                                   ***/
/***  Return:                                                                          ***/
/***    NULL pointer, if SWI was succesfully.                                          ***/
/***    ErrorBlock, if an error occured.                                               ***/
/***                                                                                   ***/
/*****************************************************************************************/

_kernel_oserror *PCMCIAManager_SwiHandler(int SWI_number, _kernel_swi_regs *regs, void *pw)
    {
    PCMCIAManager_ErrorCode error = NO_ERROR;

    #if Debug == TRUE
        DebugMessage("mK","SWI number is %08X\n",SWI_number);
        DebugMessage("mK","reg 0 %08X reg 1 %08X\n",regs->r[0],regs->r[1]);
    #endif

    if (SWI_number == SWI__PCMCIA_VERSION) error = PCMCIA_Version(regs);
                                           /* Always works regardless of resource status */
    else
        {
        /*********************************************************************************/
        /***        Decode each SWI supportted and pass to relevant routine.           ***/
        /*********************************************************************************/
        if (Resources_Loaded)
            {
            switch(SWI_number)
                {
                case SWI__PCMCIA_VERSION:
                    break;

                case SWI__PCMCIA_DRIVER:
                    error = PCMCIA_Drivers(regs);
                    break;

                case SWI__PCMCIA_CIS:
                    error = PCMCIA_Cis(regs);
                    break;

                case SWI__PCMCIA_READ:
                    error = PCMCIA_Read(regs);
                    break;

                case SWI__PCMCIA_WRITE:
                    error = PCMCIA_Write(regs);
                    break;

                case SWI__PCMCIA_POWER_OP:
                    error = PCMCIA_PowerOp(regs);
                    break;

                case SWI__PCMCIA_FS_OP:
                    error = PCMCIA_FSOp(regs);
                    break;

#if Debug == TRUE
                case 0x3d:
                    error = PCMCIA_SetAccessWidth(regs);
                    break;

                case 0x3e:                              /***   Only used to test Driver Functions   ***/
                    error = PCMCIA_TestDriverFunction(regs);
                    break;
#endif
                default:
                    error = ERROR__SWI_UNKNOWN;
                    break;
                }
            }
        else error = ERROR__NOT_READY;
        }


    if (error == NO_ERROR) return(NULL);
        else return(SetError(error));
    }







/*****************************************************************************************/
/***                                                                                   ***/
/***  PCMCIA_Version(regs)                                                             ***/
/***                                                                                   ***/
/***  Returns the PCMCIA's Support Code version number and supported features.         ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       None.                                                                       ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       R0 = Software Version Number                                                ***/
/***       R1 = Software Features (bit flags)                                          ***/
/***                  0 Supports background Read/Write                                 ***/
/***                  1 Supports background Erase                                      ***/
/***                                                                                   ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfully.                                                      ***/
/***    PCMCIA Error Code, if an error occured.                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIAManager_ErrorCode PCMCIA_Version(_kernel_swi_regs *reg)
    {

    #if Debug == TRUE
        DebugMessage("mK","\n\n********         SWI PCMCIA_Version (&47500)  Entry       ********\n");
        DebugMessage("mK","    SWI &47500, Entry:\n");
    #endif



    reg ->r[0] = (int) PCMCIA_SUPPORT_VERSION;
    #if Debug == TRUE
        DebugMessage("mK","reg ->r[0] set up.\n");
    #endif
    reg ->r[1] = 0xFFFF0000
    #if PCMCIA_BackgroundRW__Implemented == TRUE
           | PCMCIA_BackgroundRW__Bits
    #endif

    #if PCMCIA_BackgroundE__Implemented == TRUE
           | PCMCIA_BackgroundE__Bits
    #endif
           ;

    #if Debug == TRUE
        DebugMessage("mK","reg ->r[1] setup.\n");
    #endif


    #if Debug == TRUE
        DebugMessage("mK","\n    SWI &47500, Exit:\n");
        DebugMessage("mK","        R0 = &%8X    (PCMCIA Support Code version number)\n", reg ->r[0]);
        DebugMessage("mK","        R1 = &%8X    (software features)\n", reg->r[1]);
        #if PCMCIA_BackgroundRW__Implemented == TRUE
            DebugMessage("mK", "                        background Read/Write implemented\n");
        #endif
        #if PCMCIA_BackgroundE__Implemented == TRUE
            DebugMessage("mK", "                        background Erase implemented\n");
        #endif
        DebugMessage("mK","\n******************************************************************\n");
    #endif

    return((PCMCIAManager_ErrorCode) NO_ERROR);
}





/*****************************************************************************************/
/***                                                                                   ***/
/***  PCMCIA_Drivers(regs)                                                             ***/
/***                                                                                   ***/
/***  This SWI is called whenever any driver is either registered or deregistered      ***/
/***  with the support code. However this function simply parses the reason code, then ***/
/***  calls the appropriate routine to handle the actual request.                      ***/
/***                                                                                   ***/
/***  Reason Codes:                                                                    ***/
/***    0 - RegisterHardwareDriver                                                     ***/
/***    1 - DeRegisterHardwareDriver                                                   ***/
/***    2 - RegisterDeviceDriver                                                       ***/
/***    3 - DeRegisterDeviceDriver                                                     ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R0 = reason code                                                            ***/
/***       R1 - R7 = varies.                                                           ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       (see specific calls)                                                        ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***       (see specific calls)                                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIAManager_ErrorCode PCMCIA_Drivers(_kernel_swi_regs *reg)
    {
    /*************************************************************************************/
    /***    Check reason code, then call appropiate function.                          ***/
    /*************************************************************************************/
    switch(reg ->r[0]) {
        case __DRIVER__REGISTER_HARDWARE_DRIVER:
            return(Drivers_RegisterHardwareDriver(reg));
            break;

        case __DRIVER__DEREGISTER_HARDWARE_DRIVER:
            return(Drivers_DeRegisterHardwareDriver(reg));
            break;

        case __DRIVER__REGISTER_DEVICE_DRIVER:
            return(Drivers_RegisterPCCardDriver(reg));
            break;

        case __DRIVER__DEREGISTER_DEVICE_DRIVER:
            return(Drivers_DeRegisterPCCardDriver(reg));
            break;

        default:
            return(ERROR__REASON_UNKNOWN);
            break;
    }
}




/*****************************************************************************************/
/***                                                                                   ***/
/***  PCMCIA_Cis(regs)                                                                 ***/
/***                                                                                   ***/
/***  Implements the reading and writing to/from PC cards of CISs and also of          ***/
/***  individual tuples. It makes use of the standard read/write routines.             ***/
/***  All the code is in Cis.c                                                         ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R0 = Reason Code                                                            ***/
/***             0 = Get CIS Length                                                    ***/
/***             1 = Read CIS                                                          ***/
/***             2 = Write CIS                                                         ***/
/***             3 = Read Tuple                                                        ***/
/***             4 = Write Tuple                                                       ***/
/***             5 = Find Tuple                                                        ***/
/***             6 = Delete Tuple                                                      ***/
/***       R1 = Slot handle                                                            ***/
/***       R2 = CIS Buffer address (0 for direct to card)                              ***/
/***       R3 to R7 varies depending on reason code                                    ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       Varies, depending on reason code.                                           ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if successful.                                                       ***/
/***    PCMCIA Error Code, if an error occured.                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIAManager_ErrorCode PCMCIA_Cis(_kernel_swi_regs *reg)
    {
    PCMCIAManager_ErrorCode         error = NO_ERROR;

#if Debug == TRUE
    DebugMessage("mK","\n\n********          SWI PCMCIA_Cis (&47502)  Entry         ********\n");
    DebugMessage("mK","    SWI &47502, Entry:\n");
    DebugMessage("mK","        R0 = &%8X    (Reason Code)\n", reg ->r[0]);
    DebugMessage("mK","        R1 = &%8X    (Card Drive)\n", reg ->r[1]);
    DebugMessage("mK","        R2 = &%8X\n", reg ->r[2]);
    DebugMessage("mK","        R3 = &%8X\n", reg ->r[3]);
    DebugMessage("mK","        R4 = &%8X\n", reg ->r[4]);
    DebugMessage("mK","        R5 = &%8X\n", reg ->r[5]);
    DebugMessage("mK","        R6 = &%8X\n", reg ->r[6]);
    DebugMessage("mK","        R7 = &%8X\n", reg ->r[7]);
    switch(reg ->r[0])
        {
        case 0: DebugMessage("mK","                             - Get CIS length\n"); break;
        case 1: DebugMessage("mK","                             - Read CIS\n"); break;
        case 2: DebugMessage("mK","                             - Write CIS\n"); break;
        case 3: DebugMessage("mK","                             - Read Tuple\n"); break;
        case 4: DebugMessage("mK","                             - Insert Tuple\n"); break;
        case 5: DebugMessage("mK","                             - Find Tuple\n"); break;
        case 6: DebugMessage("mK","                             - Delete Tuple\n"); break;
        default:DebugMessage("mK","                             - Unsupported Reason code\n"); break;
        }
#endif

    if(!HardwarePresent) return(ERROR__NO_HARDWARE_REGISTERED);

    switch(reg ->r[0])
        {
        case __CIS__GET_LENGTH:
            error = Cis_Length(reg);
            break;

        case __CIS__READ:
            error = Cis_ReadCis(reg);
            break;

        case __CIS__WRITE:
            error = Cis_WriteCis(reg);
            break;

        case __CIS__READ_TUPLE:
            error = Cis_ReadTuple(reg);
            break;

        case __CIS__INSERT_TUPLE:
            error = Cis_InsertTuple(reg);
            break;

        case __CIS__FIND_TUPLE:
            error = Cis_FindTuple(reg);
            break;

        case __CIS__DELETE_TUPLE:
            error = Cis_DeleteTuple(reg);
            break;

        default:
            error = ERROR__REASON_UNKNOWN;
        }

        return (error);
}









/*****************************************************************************************/
/***                                                                                   ***/
/***  PCMCIA_Read(regs)                                                                ***/
/***                                                                                   ***/
/***  Implements the reading of data from memory cards. This is a generic function for ***/
/***  all memory cards, as this routine works out which PCCard drivers should be used. ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R0 = Data Access Flags                                                      ***/
/***            bits                                                                   ***/
/***             0 -  3  Data Access Mode                                              ***/
/***                       0 = Physical Data                                           ***/
/***                       1 = Raw Data                                                ***/
/***                  4  Scatter List Flag                                             ***/
/***                       0 = Not a Scatter list pointer                              ***/
/***                       1 = Scatter List pointer                                    ***/
/***                  5  Memory Address Space                                          ***/
/***                       0 = Common Memory                                           ***/
/***                       1 = Attribute Memory                                        ***/
/***       R1 = Card drive                                                             ***/
/***       R2 = Source address                                                         ***/
/***       R3 = Destination address                                                    ***/
/***       R4 = Number of bytes to read                                                ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       R3 = Amount Transfered (or pointer to current scatter list entry)           ***/
/***       R4 = Amount Untransferred                                                   ***/
/***                                                                                   ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfully.                                                      ***/
/***    PCMCIA Error Code, if an error occured.                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIAManager_ErrorCode PCMCIA_Read(_kernel_swi_regs *reg)
    {
    PCMCIAManager_ErrorCode             error = NO_ERROR;
    DRIVER_REGISTERS                    DriverCall_Registers;


#if Debug == TRUE
    DebugMessage("mK","\n\n********          SWI PCMCIA_Read (&47503)  Entry         ********\n");
    DebugMessage("mK","    SWI &47503, Entry:\n");
    DebugMessage("mK","        R0 = &%8X    (Data Access Flags)\n", reg ->r[0]);
    DebugMessage("mK","        R1 = &%8X    (Card drive)\n", reg ->r[1]);
    DebugMessage("mK","        R2 = &%8X    (Byte Address)\n", reg->r[2]);
    if ((reg ->r[0] & SCATTER_LIST__BIT) == 0) DebugMessage("mK","        R3 = &%8X    (Address to Read to)\n", reg->r[3]);
    else DebugMessage("mK","        R3 = &%8X    (Pointer to Scatter List)\n", reg->r[3]);
    DebugMessage("mK","        R4 = &%8X    (No. of Bytes)\n", reg->r[4]);
#endif

    /** Check we have a valid datamode & that we have some hardware to use...quit if not **/
    if((reg ->r[0] & 0x0f) > 1) return(ERROR__BAD_DATA_MODE);
    if(!HardwarePresent) return(ERROR__NO_HARDWARE_REGISTERED);

    /** Better check that there is a card in the slot too.... (could be a Good Idea) **/
    SetUpHWDriver_CallRegs(CardDrive[reg ->r[1]].HardwareDriver, &DriverCall_Registers);
    DriverCall_Registers.r[7] = CardDrive[reg ->r[1]].SlotHandle;
    #if Debug == TRUE
        DebugMessage("mK","Checking to see if there is a card present\n");
    #endif
    HardwareFunction(HARDWARE_FUNCTION__GET_CARD_STATUS, &DriverCall_Registers, &DRV_Error);
    if((DriverCall_Registers.r[0] & 3) != 3) return(ERROR__SLOT_EMPTY);


    /*************************************************************************************/
    /***    Set the address space                                                      ***/
    /*************************************************************************************/
    DriverCall_Registers.r[1] = (reg ->r[0] & ATTRIBUTE_MEMORY__BIT) >> 5;
    #if Debug == TRUE
        DebugMessage("mK","Setting address space to %d",DriverCall_Registers.r[1]);
    #endif
    HardwareFunction(HARDWARE_FUNCTION__SELECT_MEMORY_SPACE, &DriverCall_Registers, &DRV_Error);


    /*************************************************************************************/
    /*** Add the partition base if raw read                                            ***/
    /*************************************************************************************/
    if((reg ->r[0] & 0x0f)==1) {
        reg ->r[2] = reg ->r[2] + CardDrive[reg ->r[1]].PartitionStart;
        #if Debug == TRUE
            DebugMessage("mK","\n            > Added &%08X to the read address (partition offset)\n\n", CardDrive[reg ->r[1]].PartitionStart);
        #endif
    }

    error = MedLevel_Read(reg);

    #if Debug == TRUE
        DebugMessage("mK","\n    SWI &47503, Exit:\n");
        if ((reg ->r[0] & SCATTER_LIST__BIT) == 0) DebugMessage("mK","        R3 = &%8X    (Number of Bytes transfered)\n", reg ->r[3]);
        else DebugMessage("mK","        R3 = &%8X    (Pointer to current Scatter List entry)\n", reg ->r[3]);
        DebugMessage("mK","        R4 = &%8X    (Number of Bytes untransfered)\n", reg->r[4]);
        DebugMessage("mK","\n******************************************************************\n");
    #endif

    return(error);
}













/*****************************************************************************************/
/***                                                                                   ***/
/***  PCMCIA_Write(regs)                                                               ***/
/***                                                                                   ***/
/***  Implements the writing of data from memory cards. This is a generic function for ***/
/***  for all memory cards, as this routine works out which device drivers should be   ***/
/***  used.                                                                            ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R0 = Data Access Flags                                                      ***/
/***            bits                                                                   ***/
/***             0 -  3  Data Access Mode                                              ***/
/***                       0 = Physical Data                                           ***/
/***                       1 = Raw Data                                                ***/
/***                  4  Scatter List Flag                                             ***/
/***                       0 = Not a Scatter list pointer                              ***/
/***                       1 = Scatter List pointer                                    ***/
/***                  5  Memory Address Space                                          ***/
/***                       0 = Common Memory                                           ***/
/***                       1 = Attribute Memory                                        ***/
/***       R1 = Card Drive                                                             ***/
/***       R2 = destination address                                                    ***/
/***       R3 = source address                                                         ***/
/***       R4 = number of bytes to xfer                                                ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       R3 = Amount Transfered (or pointer to current scatter list entry)           ***/
/***       R4 = Amount Unstransfered                                                   ***/
/***                                                                                   ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfully.                                                      ***/
/***    PCMCIA Error Code, if an error occured.                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIAManager_ErrorCode PCMCIA_Write(_kernel_swi_regs *reg)
    {
    PCMCIAManager_ErrorCode            error = NO_ERROR;
    DRIVER_REGISTERS                   DriverCall_Registers;


#if Debug == TRUE
    DebugMessage("mK","\n\n********          SWI PCMCIA_Write (&47504)  Entry        ********\n");
    DebugMessage("mK","    SWI &47504, Entry:\n");
    DebugMessage("mK","        R0 = &%8X    (Data Access Flags)\n", reg ->r[0]);
    DebugMessage("mK","        R1 = &%8X    (Card Drive)\n", reg ->r[1]);
    DebugMessage("mK","        R2 = &%8X    (Byte Address on Card)\n", reg->r[2]);
    if ((reg ->r[0] & SCATTER_LIST__BIT) == 0) DebugMessage("mK","        R3 = &%8X    (Address to Read from)\n", reg->r[3]);
    else DebugMessage("mK","        R3 = &%8X    (Pointer to Scatter List)\n", reg->r[3]);
    DebugMessage("mK","        R4 = &%8X    (No. of Bytes)\n", reg->r[4]);
#endif

    /** Check we have a valid datamode & some hardware to actually access...quit if not **/
    if((reg ->r[0] & 0x0f) > 1) return(ERROR__BAD_DATA_MODE);
    if(!HardwarePresent) return(ERROR__NO_HARDWARE_REGISTERED);

    /** Better check that there is a card in the slot too.... (could be a Good Idea) **/
    SetUpHWDriver_CallRegs(CardDrive[reg ->r[1]].HardwareDriver, &DriverCall_Registers);
    DriverCall_Registers.r[7] = CardDrive[reg ->r[1]].SlotHandle;
    #if Debug == TRUE
        DebugMessage("mK","Checking to see if there is a card present\n");
    #endif
    HardwareFunction(HARDWARE_FUNCTION__GET_CARD_STATUS, &DriverCall_Registers, &DRV_Error);
    if((DriverCall_Registers.r[0] & 3) != 3) return(ERROR__SLOT_EMPTY);

    /* best check whether the card is write protected or not..... */
    if((DriverCall_Registers.r[0] & 8) != 0) return(ERROR__WRITE_PROTECTED);

    /*************************************************************************************/
    /***        Set the address space                                                  ***/
    /*************************************************************************************/
    DriverCall_Registers.r[1] = (reg ->r[0] & ATTRIBUTE_MEMORY__BIT) >> 5;
    #if Debug == TRUE
        DebugMessage("mK","Setting address space to %d",DriverCall_Registers.r[1]);
    #endif
    HardwareFunction(HARDWARE_FUNCTION__SELECT_MEMORY_SPACE, &DriverCall_Registers, &DRV_Error);


    /*************************************************************************************/
    /*** Add the partition base if raw write                                           ***/
    /*************************************************************************************/
    if((reg ->r[0] & 0x0f)==1) {
        reg ->r[2] = reg ->r[2] + CardDrive[reg ->r[1]].PartitionStart;
        #if Debug == TRUE
            DebugMessage("mK","\n            > Added &%08X to the write address (partition offset)\n\n", CardDrive[reg ->r[1]].PartitionStart);
        #endif
    }

    error = MedLevel_Write(reg);

#if Debug == TRUE
    DebugMessage("mK","\n    SWI &47503, Exit:\n");
    if ((reg ->r[0] & SCATTER_LIST__BIT) == 0) DebugMessage("mK","        R3 = &%8X    (Number of Bytes transfered)\n", reg ->r[3]);
    else DebugMessage("mK","        R3 = &%8X    (Pointer to current Scatter List entry)\n", reg ->r[3]);
    DebugMessage("mK","        R4 = &%8X    (Number of Bytes untransfered)\n", reg->r[4]);
    DebugMessage("mK","\n******************************************************************\n");
#endif
    return(error);
}







/*****************************************************************************************/
/***                                                                                   ***/
/***  PCMCIA_FSOp(regs)                                                                ***/
/***                                                                                   ***/
/***  This function simply decodes the reason code for PCMCIA_FSop, and then calls the ***/
/***  appropriate routine, which is in FSOp.c                                          ***/
/***                                                                                   ***/
/***  Return:                                                                          ***/
/***    NULL pointer, if SWI was succesfully.                                          ***/
/***    ErrorBlock, if an error occured.                                               ***/
/***                                                                                   ***/
/*****************************************************************************************/

PCMCIAManager_ErrorCode PCMCIA_FSOp(_kernel_swi_regs *reg)
    {
    PCMCIAManager_ErrorCode error = NO_ERROR;

    if(!HardwarePresent) return(ERROR__NO_HARDWARE_REGISTERED);

    switch(reg ->r[0]) {
        case __FSOP__PART_INFO:
            error = FSOp_PartitionInfo(reg);
            break;

        case __FSOP__NUMCARDS_PRESENT:
            error = FSOp_GetNumberOfCardDrives(reg);
            break;

        case __FSOP__SIZE_CARD:
            error = FSOp_SizeCard(reg);
            break;

        case __FSOP__UPDATE_PART_INFO:
            error = FSOp_UpdatePartitionInfo(reg);
            break;

        default:
            error = ERROR__REASON_UNKNOWN;
            break;
    }

    #if Debug == TRUE
        DebugMessage("gK","\nFSOp returns \n");
    #endif

    return(error);
}






#if Debug == TRUE


/*****************************************************************************************/
/***                                                                                   ***/
/***  PCMCIA_TestDriverFunction(regs)                                                  ***/
/***                                                                                   ***/
/***  A special test vector to perform various driver functions. Is only compiled      ***/
/***  when Debugging is switched on. It allows any driver function to be called, but   ***/
/***  no checking on the parameters are performed.                                     ***/
/***                                                                                   ***/
/***  A valid driver must have been registered before this call can be made. A valid   ***/
/***  slot address must be present in the passed CCB.                                  ***/
/***                                                                                   ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R0 - R7, as Driver Specification                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       R0 - R7, as Driver Specification                                            ***/
/***                                                                                   ***/
/***                                                                                   ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfully.                                                      ***/
/***    PCMCIA Error Code, if an error occured.                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/

PCMCIAManager_ErrorCode PCMCIA_TestDriverFunction(_kernel_swi_regs *reg)
    {
    PCMCIAManager_ErrorCode error = NO_ERROR;
    DRIVER_REGISTERS            Driver_Call_Registers;


    DebugMessage("mK","\n\n********        SWI PCMCIA_TestDriver (&4753F)  Entry     ********\n");
    DebugMessage("mK","    SWI &4753F, Entry:\n");
    DebugMessage("mK","        R0  = &%8X\n", reg ->r[0]);
    DebugMessage("mK","        R1  = &%8X\n", reg ->r[1]);
    DebugMessage("mK","        R2  = &%8X\n", reg ->r[2]);
    DebugMessage("mK","        R3  = &%8X\n", reg ->r[3]);
    DebugMessage("mK","        R4  = &%8X\n", reg ->r[4]);
    DebugMessage("mK","        R5  = &%8X\n", reg ->r[5]);
    DebugMessage("mK","Slot Handle = %d\n", reg ->r[7]);

    if(!HardwarePresent) return(ERROR__NO_HARDWARE_REGISTERED);

    /*********************************************************************************/
    /***    Calculate the Driver Registration Block address.                       ***/
    /*********************************************************************************/

        SetUpHWDriver_CallRegs(0, &Driver_Call_Registers);

        Driver_Call_Registers.r[1] = reg ->r[1];
        Driver_Call_Registers.r[2] = reg ->r[2];
        Driver_Call_Registers.r[3] = reg ->r[3];
        Driver_Call_Registers.r[4] = reg ->r[4];
        Driver_Call_Registers.r[5] = reg ->r[5];
        Driver_Call_Registers.r[7] = reg ->r[7];
        if (HardwareFunction(reg ->r[0], &Driver_Call_Registers, &DRV_Error) != NULL) error = ERROR__DRIVER_ERROR;
        reg ->r[6] = Driver_Call_Registers.r[6];
        reg ->r[5] = Driver_Call_Registers.r[5];
        reg ->r[4] = Driver_Call_Registers.r[4];
        reg ->r[3] = Driver_Call_Registers.r[3];
        reg ->r[2] = Driver_Call_Registers.r[2];
        reg ->r[1] = Driver_Call_Registers.r[1];
        reg ->r[0] = Driver_Call_Registers.r[0];

    DebugMessage("mK","\n    SWI &4753F, Exit:\n");
    DebugMessage("mK","        R0  = &%8X\n", reg ->r[0]);
    DebugMessage("mK","        R1  = &%8X\n", reg ->r[1]);
    DebugMessage("mK","        R2  = &%8X\n", reg ->r[2]);
    DebugMessage("mK","        R3  = &%8X\n", reg ->r[3]);
    DebugMessage("mK","        R4  = &%8X\n", reg ->r[4]);
    DebugMessage("mK","        R5  = &%8X\n", reg ->r[5]);
    DebugMessage("mK","        R6  = &%8X\n", reg ->r[6]);
    DebugMessage("mK","        R7  = &%8X\n", reg ->r[7]);
    DebugMessage("mK","\n******************************************************************\n");

    return(error);
}





/*****************************************************************************************/
/***                                                                                   ***/
/***  PCMCIA_SetAccessWidth(regs)                                                      ***/
/***                                                                                   ***/
/***  A special test SWI to allow the apparent capabilities of the card to be altered. ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R0 = driver number to affect                                                ***/
/***       R1 = new mask: 0=8bit, 7=16bit, 15=32-bit                                   ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       None.                                                                       ***/
/***                                                                                   ***/
/***   NOTE: This SWI may crash the machine if given unexpected parameters!            ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR.                                                                      ***/
/***                                                                                   ***/
/*****************************************************************************************/

PCMCIAManager_ErrorCode PCMCIA_SetAccessWidth(_kernel_swi_regs *regs)
    {
    if(!HardwarePresent) return(ERROR__NO_HARDWARE_REGISTERED);

    HardwareDriver[regs ->r[0]].DataModesSupported = (regs ->r[1]);

    return(NO_ERROR);
}

#endif







