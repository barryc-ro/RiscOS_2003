; => &.Arthur.Podule.Module
        TTL     The Podule manager for Arthur.

        SUBT    Module header => &.Arthur.Podule.Module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Name  Description
; ----       ----  -----------
; 12-Jan-00  PMS   Added fake podule header for EtherI interface.
; 28-Apr-00  KJB   Made 32-bit compatible.
; 17-Aug-00  RJC   Added a new ProdType_ to include code that auto detects modem or ethernet version of Funai8
;
;
; Fake Podule Headers
; -------------------
; To keep production costs down the podule ROM is sometimes omitted from the final product,
; where an interface is built-in to the main motherboard (and hence always present).
; In such cases the podule manager can be made to provide a fake podule header, and this
; is used for STB MPEG hardware and also for the EtherI interface on a Funai Ethernet NC.
;
; There are two ways to include the fake ROM header:
; 1. Set FakePodule0 in the machine header file
; 2. Set FakePodule in the components file (passed in via the MakeFile)
;
; If FakePodule is passed in from the MakeFile it overrides FakePodule0 in the machine file.
;
; The first approach is normally used, but the second approach is used for the Funai 5 Ethernet NC
; where we use the same machine type as the Funai 4 modem NC.
; (The Funai 5 Ethernet NC is very closely based on the Funai 4 modem NC.
; We don't want to introduce a new machine type as that would lead to other complications
; and make it more difficult to develop the Ethernet and Modem versions in tandem.)

 [ :LNOT: :DEF: FakePodule
	GBLA	FakePodule
FakePodule SETA FakePodule0	; Use FakePodule0 from the machine header file if not defined by Components/makefile
 ]
	; We only know how to fake up STB2 MPEG1, MPEG2 (and MPEG0) podules and EtherI Podule
        ASSERT (FakePodule = 0) :LOR: (FakePodule = ProdType_STB2_MPEG1) :LOR: (FakePodule = ProdType_STB2_MPEG2) :LOR: (FakePodule = ProdType_EtherI) :LOR: (FakePodule = ProdType_AutoDetectFunai8)
 [ FakePodule <> 0
   [ FakePodule = ProdType_EtherI
        !       0, "Assembling Podule Manager with Fake EtherI Podule header, (type $FakePodule)"
   |
      [ FakePodule = ProdType_AutoDetectFunai8
           !       0, "Assembling Podule Manager with capability to auto-detect type of a Funai8 board - Hard modem or EtherI"
      |
           !       0, "Assembling Podule Manager with Fake Podule header, type $FakePodule"
      ]
   ]
 ]

MySWIChunkBase * Module_SWISystemBase + PoduleSWI * Module_SWIChunkSize
        ASSERT  MySWIChunkBase = Podule_ReadID

Origin
        DCD     0
        DCD     InitModule - Origin                     ; Initialisation
        DCD     KillModule - Origin                     ; Finalisation
        DCD     ServiceEntry - Origin
        DCD     ModuleTitle - Origin
        DCD     HelpString - Origin
        DCD     CommandTable - Origin
        DCD     MySWIChunkBase
        DCD     SVCEntry - Origin
        DCD     SWINameTable - Origin
        DCD     0
 [ International_Help <> 0
        DCD     message_filename - Origin
 |
        DCD     0
 ]
        DCD     Flags - Origin

        GBLL    DebugModule
DebugModule     SETL    ( :LNOT: ReleaseVersion ) :LAND: False

        GBLL    DebugInterface
DebugInterface  SETL    ( :LNOT: ReleaseVersion ) :LAND: False

        GBLL    DebugCommands
DebugCommands   SETL    ( :LNOT: ReleaseVersion ) :LAND: False

        GBLL    DebugLoader
DebugLoader     SETL    ( :LNOT: ReleaseVersion ) :LAND: False

        GBLL    TML_Debugging
TML_Debugging   SETL    False

        GBLL    FixLoaderBug
FixLoaderBug    SETL    True

        ;   The following assembly-time variables control the final
        ; form of the podule manager, and should be changed with care.

 [ :LNOT: :DEF: NumberOfPodules
                GBLA    NumberOfPodules                 ; Excluding the network podule
NumberOfPodules SETA    8
 ]

                GBLL    NetworkPodule
NetworkPodule   SETL    NetPodSupport			; System build option

        ; The reassigned interrupts nick the NIC interrupt for podule 0
        ASSERT  :LNOT: (ReassignedIOMDInterrupts :LAND: NetPodSupport)

                GBLL    EASISpace
EASISpace       SETL    True

                GBLL    ExtensionROMs
ExtensionROMs   SETL    ExtROMSupport			; System build option


        [       :LNOT: ReleaseVersion
        !       0, "This version supports " :CC: ((:STR:NumberOfPodules) :RIGHT: 1) :CC: " podules"
        [       NetworkPodule
        !       0, "Including support code for the NetworkPodule"
        |
        !       0, "No support for the NetworkPodule"
        ]
        [       ExtensionROMs
        !       0, "Including support code for Extension ROMs"
        |
        !       0, "No support for Extension ROMs"
        ]
        ]

        ;       These constants represent the physical implemention

PoduleBase0             *       &033C0000
PoduleBase1             *       &033C4000
PoduleBase2             *       &033C8000
PoduleBase3             *       &033CC000
PoduleBase4             *       &033F0000
PoduleBase5             *       &033F4000
PoduleBase6             *       &033F8000
PoduleBase7             *       &033FC000
NetworkBaseROM          *       &0302B000
NetworkBaseChip         *       &0302B800

PoduleCMOS0             *       PoduleCMOS
PoduleCMOS1             *       PoduleCMOS + 4
PoduleCMOS2             *       PoduleCMOS + 8
PoduleCMOS3             *       PoduleCMOS + 12
PoduleCMOS4             *       PoduleExtraCMOS + 16
PoduleCMOS5             *       PoduleExtraCMOS + 12
PoduleCMOS6             *       PoduleExtraCMOS + 8
PoduleCMOS7             *       PoduleExtraCMOS + 4
PoduleCMOS8             *       PoduleExtraCMOS

ModuleBase0             *       &03000000

ModuleBase4             *       &03030000

EASIAddress0            *       &88000000
EASIAddress1            *       &89000000
EASIAddress2            *       &8A000000
EASIAddress3            *       &8B000000
EASIAddress4            *       &8C000000
EASIAddress5            *       &8D000000
EASIAddress6            *       &8E000000
EASIAddress7            *       &8F000000

DMAChannel0             *       &000
DMAChannel1             *       &010
DMAChannel2             *       -1
DMAChannel3             *       -1
DMAChannel4             *       -1
DMAChannel5             *       -1
DMAChannel6             *       -1
DMAChannel7             *       -1
NetworkDMAChannel       *       &105

PoduleIntStatus         *       &03200020               ; IRQB
PoduleIntRequest        *       &03200024
PoduleIntMask           *       &03200028
PoduleIntValue          *       &20
PoduleIntDeviceVector   *       &0D

PoduleFIQasIntStatus    *       &03200020               ; IRQB
PoduleFIQasIntRequest   *       &03200024
PoduleFIQasIntMask      *       &03200028
PoduleFIQasIntValue     *       &01
PoduleFIQasIntDeviceVector *    &08

PoduleFIQStatus         *       &03200030               ; FIQ
PoduleFIQRequest        *       &03200034
PoduleFIQMask           *       &03200038
PoduleFIQValue          *       &40

NetworkIntStatus        *       &03200020               ; IRQB
NetworkIntRequest       *       &03200024
NetworkIntMask          *       &03200028
NetworkIntValue         *       &08
NetworkIntDeviceVector  *       &0B

NetworkFIQasIntStatus   *       &03200020               ; IRQB
NetworkFIQasIntRequest  *       &03200024
NetworkFIQasIntMask     *       &03200028
NetworkFIQasIntValue    *       &08
NetworkFIQasIntDeviceVector *   &0B

NetworkFIQStatus        *       &03200030               ; FIQ
NetworkFIQRequest       *       &03200034
NetworkFIQMask          *       &03200038
NetworkFIQValue         *       &02

 [ NetworkPodule
MaximumPodule           *       NumberOfPodules + 1
NumberOfNetworkPodule   *       MaximumPodule - 1
IOTCR                   *       &032000C4
 |
MaximumPodule           *       NumberOfPodules
 ]

 [ ExtensionROMs
   [ {TRUE}
StartOfROM      *       &03800000
EndOfROM        *       &04000000
   |
StartOfROM      *       &03400000
EndOfROM        *       &04000000
   ]
 ]

 [ FakePodule = ProdType_STB2_MPEG1 :LOR: FakePodule = ProdType_STB2_MPEG2
MachineConfig   *       (IOMD_Base + IOMD_CLINES)
MPEGfittedbit   *       IOMD_C_MPEGfitted
MPEGIDByte      *       0
 ]
 [ FakePodule	= 	ProdType_EtherI
EtherIIDByte	*	0
 ]
 [ FakePodule   =       ProdType_AutoDetectFunai8
EtherIIDByte    *       0
HModemIDByte    *       0
 ]

maxint          *       &7FFFFFFF

; Podule descriptor format

        ^       0

PoduleNode_Link                 #       4               ; Offset from start of workspace to next podule (zero if last)
                                                        ; joined up in order 0 > 1 > 2 > 3 > -2 > -3 > ...
                                                        ; links for 0 to 3 probably not used
PoduleNode_LoaderOffset         #       4               ; Offset from start of workspace to loader
PoduleNode_BaseAddress          #       4               ; Hardware base of podule, or address of fake header in Podule manager code
                                                        ; in the case of extension ROMs
PoduleNode_PoduleLimit          #       4               ; Highest numbered chunk in podule space, or maxint (&7FFFFFFF) if not yet known
PoduleNode_EnumerationLimit     #       4               ; Highest numbered chunk we've seen in podule space, -1 if not seen any
PoduleNode_ROMAddress           #       4               ; Address of start of image in ROM (for extension ROMs)
PoduleNode_WordOffset           #       4               ; Offset from one word to next
PoduleNode_ByteOffsets          #       16              ; Offset from start of word to byte 0,1,2,3
PoduleNode_DescriptionOffset    #       4               ; Zero or offset from start of workspace to description
PoduleNode_Type                 #       2               ; Type (actually a half-word)
PoduleNode_Flags                #       1               ; Bit zero => ROM is Podule, Bit one => ROM is EASI
PoduleNode_SpareByte            #       1
PoduleNode_IDByte               #       1               ; ID byte (byte 0) for each podule
PoduleNode_IntValue             #       1
PoduleNode_FIQasIntValue        #       1
PoduleNode_FIQValue             #       1
PoduleNode_CMOS                 #       4               ; CMOS base address
PoduleNode_CombinedAddress      #       4
PoduleNode_DMA                  #       4
PoduleNode_IntStatus            #       4
PoduleNode_IntRequest           #       4
PoduleNode_IntMask              #       4
PoduleNode_IntDeviceVector      #       4
PoduleNode_FIQasIntStatus       #       4
PoduleNode_FIQasIntRequest      #       4
PoduleNode_FIQasIntMask         #       4
PoduleNode_FIQasIntDeviceVector #       4
PoduleNode_FIQStatus            #       4
PoduleNode_FIQRequest           #       4
PoduleNode_FIQMask              #       4
        [       EASISpace
PoduleNode_EASIAddress          #       4
        ]

PoduleNode_Size                 *       :INDEX: @       ; size of node for normal podules
        [       :LNOT: ReleaseVersion
        !       0, "A node record is &" :CC: ((:STR: PoduleNode_Size) :RIGHT: 2) :CC: " bytes long"
        ]
PoduleNode_Checksum             #       4               ; ROM checksum (used to identify unique ROMs)

ROMNode_Size                    *       :INDEX: @       ; size of node for extension ROMs

        MACRO
$label  PoduleNode      $link, $baseaddress, $romaddress, $cmos, $type, $easi, $dma
        Byte    $label, PoduleNode_Size                 ; allocate space in workspace
        DCD     $link                                   ; offset in workspace of next node
        [       "$type" = "Network"
        DCD     :INDEX: NetworkLoader                   ; loader offset, initialised to point to the included loader
        |
        DCD     NIL                                     ; loader offset, initialised to no loader
        ]
        ASSERT  (.-Origin :AND: 3) = 0
        DCD     $baseaddress                            ; hardware base address
        DCD     maxint                                  ; podule limit
        DCD     -1                                      ; enumeration limit
        DCD     $romaddress                             ; same as baseaddress for normal podules
        DCD     16                                      ; word offset
        DCD     0, 4, 8, 12                             ; byte offsets
        DCD     0                                       ; Description pointer
        DCW     0                                       ; Type (16 bits)
        DCB     0                                       ; Flags, all zero
        DCB     0                                       ; Spare
        ASSERT  (.-Origin :AND: 3) = 0
        DCB     255                                     ; ID byte
        LCLS    inttype
        [       ReassignedIOMDInterrupts :LAND: PoduleInstance = 0
inttype SETS    "Network"                               ; Podule 0 uses the Network interrupt
        |
inttype SETS    "$type"
        ]
        DCB     $inttype.IntValue
        DCB     $inttype.FIQasIntValue
        DCB     $inttype.FIQValue
        ASSERT  (.-Origin  :AND: 3) = 0
        DCD     $cmos                                   ; CMOS base address
        DCD     $romaddress + $cmos
        DCD     $dma
        DCD     $inttype.IntStatus
        DCD     $inttype.IntRequest
        DCD     $inttype.IntMask
        DCD     $inttype.IntDeviceVector
        DCD     $inttype.FIQasIntStatus
        DCD     $inttype.FIQasIntRequest
        DCD     $inttype.FIQasIntMask
        DCD     $inttype.FIQasIntDeviceVector
        DCD     $inttype.FIQStatus
        DCD     $inttype.FIQRequest
        DCD     $inttype.FIQMask
        [       EASISpace
        DCD     $easi                                   ; EASI Space Logical address
        ]
        MEND

        ^       0,      wp                              ; Store
InitialisationData

        Byte    SegmentHeader, 16
        DCD     -1
        DCD     -1
        DCD     -1
        DCD     -1

        Word    message_file_block, 4                   ; File handle for MessageTrans
        DCD     -1
        DCD     -1
        DCD     -1
        DCD     -1
        Word    message_file_open                       ; Opened message file flag
        DCD     0                                       ; Flag that the message file is closed

        Word    number_of_extension_roms                ; How many extension roms there are
        DCD     0                                       ; There are no extension ROMs currently

        Word    AddressOfMyPrivateWord
        DCD     NIL

        Word    OffsetOfNextLoader
        DCD     TotalRAMRequired

                GBLA    PoduleInstance
PoduleInstance  SETA    0
                GBLS    PoduleString
        [       NetworkPodule
        WHILE   PoduleInstance < NumberOfPodules
PoduleString    SETS    "Podule" :CC: ((:STR: PoduleInstance) :RIGHT: 1) :CC: " PoduleNode "
PoduleString    SETS    "$PoduleString" :CC: ":INDEX: Podule" :CC: ((:STR: (PoduleInstance + 1)) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleCMOS" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", Podule, EASIAddress" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", DMAChannel" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
$PoduleString
PoduleInstance  SETA PoduleInstance + 1
        WEND
PoduleString    SETS    "Podule" :CC: ((:STR: PoduleInstance) :RIGHT: 1) :CC: " PoduleNode "
PoduleString    SETS    "$PoduleString" :CC: "0"
PoduleString    SETS    "$PoduleString" :CC: ", NetworkBaseChip"
PoduleString    SETS    "$PoduleString" :CC: ", NetworkBaseROM"
PoduleString    SETS    "$PoduleString" :CC: ", PoduleCMOS" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", Network, 0, NetworkDMAChannel"
$PoduleString
        |
        WHILE   PoduleInstance < NumberOfPodules - 1
PoduleString    SETS    "Podule" :CC: ((:STR: PoduleInstance) :RIGHT: 1) :CC: " PoduleNode "
PoduleString    SETS    "$PoduleString" :CC: ":INDEX: Podule" :CC: ((:STR: (PoduleInstance + 1)) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleCMOS" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", Podule, EASIAddress" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", DMAChannel" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
$PoduleString
PoduleInstance  SETA PoduleInstance + 1
        WEND
PoduleString    SETS    "Podule" :CC: ((:STR: PoduleInstance) :RIGHT: 1) :CC: " PoduleNode "
PoduleString    SETS    "$PoduleString" :CC: "0"
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleBase" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", PoduleCMOS" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", Podule, EASIAddress" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
PoduleString    SETS    "$PoduleString" :CC: ", DMAChannel" :CC: ((:STR: PoduleInstance) :RIGHT: 1)
$PoduleString
        ]
PoduleString    SETS    "ROMNodeChainHead * Podule" :CC: ((:STR: PoduleInstance) :RIGHT: 1) :CC: " + PoduleNode_Link"
$PoduleString

;	Podule chunk directories in the header are 8 bytes (see PRM4-128):

		MACRO
		CHUNK $type,$contents,$description,$end
		DCD	$type				; Type: High nybble will be &F for NC
$len		*	($end  - $desc)/4		; Length of field
$offset		*	($desc - $contents)/4		; Offset of field from start
		DCD 	 $len :AND: &FF			; Size in bytes
		DCD	($len :SHR:     8) :AND &FF
		DCD	($len :SHR:    16) :AND &FF
		DCD 	 $offset :AND: &FF		; Offset to chunk string
		DCD	($offset :SHR:  8) :AND &FF
		DCD	($offset :SHR: 16) :AND &FF
		DCD	($offset :SHR: 24) :AND &FF
		MEND



 [       FakePodule = ProdType_STB2_MPEG1 :LOR: FakePodule = ProdType_STB2_MPEG2
MPEG0descoff	*       (MPEG0desc - MPEG0contents)/4		; offset of description from start
MPEG0desclen	*       (MPEG0end  - MPEG0desc)/4		; length of description
MPEG0contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG0 :AND: &FF), (ProdType_STB2_MPEG0 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG0desclen, &00, &00, MPEG0descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG0desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'v', 'i', 'd', 'e', 'o', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
MPEG0end
                ALIGN
  [	FakePodule = ProdType_STB2_MPEG1

MPEG1descoff	*       (MPEG1desc - MPEG1contents)/4		; offset of description from start
MPEG1desclen	*       (MPEG1end  - MPEG1desc)/4		; length of description
MPEG1contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG1 :AND: &FF), (ProdType_STB2_MPEG1 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG1desclen, &00, &00, MPEG1descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG1desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'M', 'P', 'E', 'G', '1', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
MPEG1end
                ALIGN
  |
; it's the STB2/2
MPEG1descoff	*       (MPEG1desc - MPEG1contents)/4		; offset of description from start
MPEG1desclen	*       (MPEG1end  - MPEG1desc)/4		; length of description
MPEG1contents	DCD     &00, &02, &00, (ProdType_STB2_MPEG2 :AND: &FF), (ProdType_STB2_MPEG2 :SHR: 8)
		DCD	(Manf_OnlineMedia :AND: &FF), (Manf_OnlineMedia :SHR: 8), &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
                DCD     &f5, MPEG1desclen, &00, &00, MPEG1descoff, &00, &00, &00
                DCD     0, 0, 0, 0, 0, 0, 0, 0
MPEG1desc	DCD     'I', 'n', 't', 'e', 'r', 'n', 'a', 'l'
                DCD     ' ', 'M', 'P', 'E', 'G', '2', ' ', 'h'
                DCD     'a', 'r', 'd', 'w', 'a', 'r', 'e',  0
MPEG1end
                ALIGN
  ]
 ]

;  Fake Podule header for Funai 5 Ethernet NC.
;  This Ethernet NC has on-board Ethernet and although it has a podule ROM socket
;  this ROM is not fitted to reduce cost. We therefore provide a fake podule header here.
;  See PRM 4-122. Paul Skirrow 12 Jan 2000.
;
;	Podule chunk directories in the header are 8 bytes (see PRM4-128):


		MACRO
		PODCHUNK $type,$contents,$desc,$end
		LCLA len
		LCLA offset
		DCD	$type				; Type: High nybble will be &F for NC
; len		SETA	($end  - $desc)/4		; Length of field
; offset	SETA	($desc - $contents)/4		; Offset of field from start
		DCD 	 (($end  - $desc)/4) :AND: &FF			; Size in bytes
		DCD	((($end  - $desc)/4) :SHR:  8) :AND: &FF
		DCD	((($end  - $desc)/4) :SHR: 16) :AND: &FF
		DCD 	 (($desc - $contents)/4) :AND: &FF		; Offset to chunk string
		DCD	((($desc - $contents)/4) :SHR:  8) :AND: &FF
		DCD	((($desc - $contents)/4) :SHR: 16) :AND: &FF
		DCD	((($desc - $contents)/4) :SHR: 24) :AND: &FF
		MEND

 [      FakePodule = ProdType_EtherI :LOR: FakePodule = ProdType_AutoDetectFunai8
EtherIcontents	DCD     &00				; Interrupts, IRQ and FIQ are relocated
		DCD	&03				; Interrupt Status Pointers and Chunk dir follow ECId
		DCD 	&00				; Reserved
		DCD 	(ProdType_EtherI :AND: &FF) 	; Product type low byte
		DCD	(ProdType_EtherI :SHR: 8)	; Product type hight byte
		DCD	(Manf_AcornUK :AND: &FF)	; Manufacturer code, low byte
		DCD	(Manf_AcornUK :SHR: 8)		; Manufacturer code, high byte
		DCD	0				; Country code (0=UK)
                DCD     0, 0, 0, 0, 0, 0, 0, 0		; Interrupt status pointers
		; Chunks follow:
                PODCHUNK &f5, EtherIcontents, EtherIdesc, EtherIdescend 	; Description: "10baseT Ethernet..."
                PODCHUNK &f3, EtherIcontents, EtherImod, EtherImodend	; Modifications status byte: 4

                DCD     0, 0, 0, 0, 0, 0, 0, 0		; End of chunk directory
EtherIdesc	DCD     '1', '0', 'B', 'a', 's', 'e', 'T', ' '
                DCD     'E', 't', 'h', 'e', 'r', 'n', 'e', 't'
                DCD     ' ', '6', '4', 'k', ' ', 'b', 'u', 'f'
                DCD     'f', 'e', 'r', ' ', '(', 'A', ' ', 'c'
                DCD     'y', 'c', 'l', 'e', 's', ')', 0
EtherIdescend
EtherImod	DCD	'4', 0		; Modification byte
EtherImodend
 ]
 [      FakePodule = ProdType_AutoDetectFunai8
HModemcontents DCD     &00                             ; Interrupts, IRQ and FIQ are relocated
                DCD     &03                             ; Interrupt Status Pointers and Chunk dir follow ECId
                DCD     &00                             ; Reserved
                DCD     (ProdType_ModemCard :AND: &FF)  ; Product type low byte
                DCD     (ProdType_ModemCard :SHR: 8)    ; Product type hight byte
                DCD     (Manf_AcornUK :AND: &FF)        ; Manufacturer code, low byte
                DCD     (Manf_AcornUK :SHR: 8)          ; Manufacturer code, high byte
                DCD     0                               ; Country code (0=UK)
                DCD     0, 0, 0, 0, 0, 0, 0, 0          ; Interrupt status pointers
                ; Chunks follow:
                PODCHUNK &f5, HModemcontents, HModemdesc, HModemdescend ; Description: "10baseT Ethernet..."
                PODCHUNK &f3, HModemcontents, HModemmod, HModemmodend   ; Modifications status byte: 0

                DCD     0, 0, 0, 0, 0, 0, 0, 0          ; End of chunk directory
HModemdesc      DCD     'T', 'e', 'm', 'p', 'o', 'r', 'a', 'r'
                DCD     'y', ' ', 'm', 'o', 'd', 'e', 'm', ' '
                DCD     'e', 'x', 'p', 'a', 'n', 's', 'i', 'o'
                DCD     'n', ' ', 'c', 'a', 'r', 'd', ' ', '-'
                DCD     ' ', 'b', 'y', ' ', 'B', 'o', 'b', 0
HModemdescend
HModemmod       DCD     '0', 0          ; Modification byte
HModemmodend
 ]

; *****************************************************************************************************************
;
;       ExtensionROMLoader - Loader for reading extension ROM
;
        [       ExtensionROMs

ExtensionROMLoader
        B       ROMLoaderReadByte                       ; read a byte
        B       ROMLoaderError                          ; write a byte
        MOV     pc, lr                                  ; reset
        MOV     pc, lr                                  ; SWI Podule_CallLoader
        =       "32OK"

; ROMLoaderReadByte - Read a byte from extension ROM
;
; in:   R1 = address within ROM
;       R3 -> podule descriptor node *** NOTE actual address not offset from wp ***
;       R11 = "combined hardware address", ie ROM address in the case of extension ROMs
;       V clear
;
; out:  R0 = byte read
;       R1, R4-R9, R11,R12 preserved
;       R2,R3,R10 corrupted
;

ROMLoaderReadByte ROUT
        AND     r10, r1, #3                             ; get byte number
        ADD     r10, r3, r10, LSL #2
        LDR     r10, [r10, #PoduleNode_ByteOffsets]     ; r10 = offset from start of that word
        MOV     r2, r1, LSR #2                          ; r2 = word number
        LDR     r0, [r3, #PoduleNode_WordOffset]
        MLA     r10, r0, r2, r10                        ; r10 = byte offset in actual ROM
        LDRB    r0, [r11, r10]                          ; r0 = byte read
        MOV     pc, lr

ROMLoaderError
        MRS     CPSR_f, #V_bit
        MOV     r0, #0
        MOV     pc, lr


ExtensionROMLoaderEnd

        Byte    ROMLoader, ExtensionROMLoaderEnd - ExtensionROMLoader
        ]

; *****************************************************************************************************************
;
;       NetworkROMLoader - Loader for reading the ROM on the network card
;
        [       NetworkPodule
NetworkPoduleLoader
        B       NetworkLoaderReadByte                   ; Read a byte
        B       NetworkLoaderError                      ; Write a byte
        B       NetworkLoaderReset                      ; Reset
        MOV     pc, lr                                  ; SWI Podule_CallLoader
        =       "32OK"

;       The network ROM lives at address 'NetworkROMAddress' (R11)
;       Writes to that address reset a 12 bit counter attached to the
;       low order 12 bits of the ROMs address lines.  The address lines
;       above that are attached to LA2, LA3, LA4, etc.  So to read
;       consecutive bytes one reads location NetworkROMAddress 4096
;       times then NetworkROMAddress + 4 4096 times etc.

; NetworkLoaderReadByte - Read a byte from the Network Podule ROM
;
; in:   R1 = address within ROM
;       R3 -> podule descriptor node *** NOTE actual address not offset from wp ***
;       R11 = ROM base address
;
; out:  R0 = byte read
;       R2, R10, R11 corrupted
;       R1, R3-R9, R12 preserved

NetworkLoaderReadByte ROUT
        LDR     r2, BaseAddressANDMask
        AND     r11, r11, r2                            ; Reduce a combined address to the ROM address
        MOV     r2, r1, LSL #32-12
        MOV     r2, r2, LSR #32-12                      ; Now just the page offset
        MOV     r10, r1, LSR #12                        ; Page number
        CMP     r10, #&00000100                         ; Is this a viable address?
        BHS     NetworkLoaderTooBig
        ADD     r11, r11, r10, LSL #2                   ; Address to use to read the byte
        LDR     r10, NetworkPageCounter                 ; Soft copy of the value in the counter H/W
NetworkCounterLoop
        CMP     r2, r10                                 ; Is this the byte we want?
        LDRB    r0, [ r11, #0 ]                         ; Read it and increment the counter
        INC     r10                                     ; Increment the soft copy
   ;     BICEQ   r10, r10, #&000FF000                    ; Make sure the counter doesn't overflow
        STREQ   r10, NetworkPageCounter                 ; Update the soft copy
        MOVEQ   pc, lr                                  ; Return to the caller (V will be clear if EQ)
        BGT     NetworkCounterLoop                      ; And try again
        MOV     r10, #0
        STR     r10, NetworkPageCounter                 ; Reset the soft copy
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
        [       FixLoaderBug
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
        ]
        [       DebugLoader
        LDRB    r6, [ r11, #0 ]
        LDRB    r5, [ r11, #0 ]
        ORR     r6, r6, r5, LSL #8
        LDRB    r5, [ r11, #0 ]
        ORR     r6, r6, r5, LSL #16
        LDRB    r5, [ r11, #0 ]
        ORR     r6, r6, r5, LSL #24
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
        LDRB    r7, [ r11, #0 ]
        LDRB    r5, [ r11, #0 ]
        ORR     r7, r7, r5, LSL #8
        LDRB    r5, [ r11, #0 ]
        ORR     r7, r7, r5, LSL #16
        LDRB    r5, [ r11, #0 ]
        ORR     r7, r7, r5, LSL #24
    ;    STRB    r10, [ r11, #0 ]                        ; Reset the counter
    ;    STRB    r10, [ r11, #0 ]                        ; Reset the counter
        STRB    r10, [ r11, #0 ]                        ; Reset the counter
        MOV     r5, pc                                  ; Set flag to say reset occured
        ]
        B       NetworkCounterLoop                      ; And try again

NetworkLoaderError
        MSR     CPSR_f, #V_bit
        MOV     r0, #0
        MOV     pc, lr

NetworkLoaderTooBig
        MSR     CPSR_f, #V_bit
        ADR     r0, ErrorNetworkLoaderTooBig
        MOV     pc, lr

ErrorNetworkLoaderTooBig
        DCD     ErrorNumber_AddressRange
        [       FixLoaderBug
        DCB     "Bad"
        |
        DCB     "BadAddr"
        ]
        DCB     0
        ALIGN

NetworkPageCounter                                      ; This is the soft copy
        DCD     0                                       ; This is OK because this is in RAM

BaseAddressANDMask
        DCD     Podule_BaseAddressANDMask

; NetworkLoaderReset
;
; in:   R11 = ROM base address
;       V clear
;
; out:  R2, R11 corrupted

NetworkLoaderReset ROUT
        LDR     r2, BaseAddressANDMask
        AND     r11, r11, r2
        MOV     r2, #0
        STRB    r2, [ r11, #0 ]                         ; Reset the counter
        STR     r2, NetworkPageCounter
        MOV     pc, lr

NetworkLoaderEnd

        Byte    NetworkLoader, NetworkLoaderEnd - NetworkPoduleLoader
        ]

; *****************************************************************************************************************
;
;       Not32bitLoader - Dummy loader substituted for non 32-bit compatible ones
;

Not32bitDummyLoader
        B       Not32bitLoaderError                     ; read a byte
        B       Not32bitLoaderError                     ; write a byte
        MOV     pc, lr                                  ; reset (nothing to reset...)
        B       Not32bitLoaderError                     ; SWI Podule_CallLoader
        =       "32OK"

; in:   We know r12 is the Podule Manager global workspace. Use it to look up
;       the error

Not32bitLoaderError
        MSR     CPSR_f, #V_bit
        ADR     r0, Loader26bitError
        MOV     pc, lr

Not32bitLoaderEnd

        Byte    Not32bitLoader, Not32bitLoaderEnd - Not32bitDummyLoader

        AlignSpace      16

        Word    EndOfInitialisationData, 0
        [       :LNOT: ReleaseVersion
        !       0, "The end of initialisation data is at &" :CC:((:STR:(:INDEX:EndOfInitialisationData)):RIGHT:4)
        ]

        ;       The area after here is initialised to -1s

InfoBufLength * &40                                     ; buffer length for title and help strings

        Byte    RMName, InfoBufLength
        Byte    RMHelp, InfoBufLength
        Byte    Loader26bitError, InfoBufLength

        Word    EndOfInitialisationArea, 0


TotalRAMRequired *      :INDEX: @
        [       :LNOT: ReleaseVersion
        !       0, "Total RAM required is &" :CC: ((:STR: TotalRAMRequired) :RIGHT: 4) :CC: " bytes"
        ]

        SUBT    Module entry stuff
        OPT     OptPage

HelpString
        DCB     "Podule Manager", 9, "$Module_MajorVersion ($Module_Date)"
        [       Module_MinorVersion <> ""
        =       " $Module_MinorVersion"
        ]
        !       0, "Assembling Podule Manager $Module_MajorVersion $Module_MinorVersion"

        [       :LNOT: ReleaseVersion
        =       " [", (:STR: NumberOfPodules) :RIGHT: 1
        [       NetworkPodule
        =       "/N"
        ]
        [       ExtensionROMs
        =       "/E"
        ]
        =       "]"
        =       " assembled as a development version."
        ]
        =       0
        ALIGN

Flags
  [ No32bitCode
        DCD     0
  |
        DCD     ModuleFlag_32bit
  ]

        SUBT    Initialisation code
        OPT     OptPage

InitModule ROUT
        Push    "lr"
  [ ( DebugModule :LOR: DebugInterface :LOR: DebugCommands ) :LAND: TML_Debugging
        InsertTMLInitialisation 0
        BVS     ExitInitModule
  ]
        LDR     r2, [ r12 ]
        TEQ     r2, #0
 [ DebugModule
        BEQ     HardInit
        DLINE   "Podule - ReInit"
 ]
        MOVNE   r1, #0                                  ; If we already have workspace, then
        STRNE   r1, [r2, #:INDEX:message_file_open]     ; flag that the message file is closed
        BNE     ReInitialisation
 [ DebugModule
HardInit
        DLINE   "Podule - Init"
 ]
        MOV     r0, #ModHandReason_Claim
        LDR     r3, =TotalRAMRequired
        SWI     XOS_Module
        BVS     ExitInitModule
 [ DebugModule
        DREG    r2, "Workspace is at &"
        DREG    r12,"Private word is at &"
 ]
        ASSERT  ( ( :INDEX: EndOfInitialisationData ) :AND: 3 ) = 0
        MOV     r3, #0
        ADRL    r5, InitialisationData
InitialisationLoop
        CMP     r3, # :INDEX: EndOfInitialisationData
        LDRLT   r0, [ r5, r3 ]
        MOVGE   r0, #-1
        STR     r0, [ r2, r3 ]                          ; Note that the initialised data is
        INC     r3, 4                                   ; at the start of workspace
        CMP     r3, # :INDEX: EndOfInitialisationArea
        BLT     InitialisationLoop

        MOV     r0, #1                                  ; We've just copied code (the ROM and
        MOV     r1, r2                                  ; network loaders) into our workspace
        ADD     r2, r2, r3
        SWI     XOS_SynchroniseCodeAreas

        MOV     r2, r1                                  ; Restore workspace pointer

        Push    r12
        MOV     r12, r2
        BL      LookupLoader26bitError
        Pull    r12

 [ ExtensionROMs
        BL      FindExtensionROMs
 ]

;	Fake Podule ROM Headers
;
;	Some systems (such as STB and FUnai 5 Ethernet NC) have hardware fitted to the main board which
;	would traditionally have been implemented on an expansion card. Although there is normally
;	space for an expansion card ROM, it is not normally fitted and we fake the ROM header.
;	The hardware appears as expansion card 0 (podule 0) and the other expansion cards work normally
;	(if available).
;
;	If this is a Set-Top Box, then we know we've got MPEG hardware fitted as Podule0 but without the (EP)ROM
;	We'll make if look like its a real podule

 [       FakePodule = ProdType_STB2_MPEG1 :LOR: FakePodule = ProdType_STB2_MPEG2
        ADRL    r0, NormalPoduleNodeOffsets		; work out address of podule0 node
        LDR     r0, [r0]
        ADD     r0, r0, r2				; make it an absolute address

        MOV     r1, #MPEGIDByte				; ID byte for fake MPEG podule
        STRB    r1, [ r0, #PoduleNode_IDByte ]		; set ID byte to make ConvertR3ToPoduleNode happy

        MOV     r1, #BitZero
        STRB    r1, [ r0, #PoduleNode_Flags ]		; This is a (fake) Podule

	MOV	r1, #PoduleCMOS
	STR	r1, [ r0,  #PoduleNode_CMOS ]		; We don't have no CMOS

	MOV	r1, #-1
	STR	r1, [ r0,  #PoduleNode_DMA ]		; We don't do DMA

;	See if MPEG is fitted and point the podule ROM address to the appropriate fake header
;	The description string will be extracted from this block in the normal way when chunks get enumerated
        LDR     r3, =MachineConfig
        LDRB    r1, [r3]
        TST     r1, #MPEGfittedbit
        ADREQ	r1, MPEG0contents
        ADRNE	r1, MPEG1contents
        STR     r1, [ r0, #PoduleNode_ROMAddress ]	; Location to read header from
 ]

;	Fake EtherI podule ROM:

 [       FakePodule = ProdType_EtherI
        ;fake an EtherI
        ADRL    r0, NormalPoduleNodeOffsets		; work out address of podule0 node
        LDR     r0, [r0]
        ADD     r0, r0, r2				; make it an absolute address

        MOV     r1, #EtherIIDByte			; ID byte for fake EtherI podule
        STRB    r1, [ r0, #PoduleNode_IDByte ]		; set ID byte to make ConvertR3ToPoduleNode happy

        MOV     r1, #BitZero
        STRB    r1, [ r0, #PoduleNode_Flags ]		; This is a (fake) Podule

	MOV	r1, #PoduleCMOS
	STR	r1, [ r0,  #PoduleNode_CMOS ]		; We don't have no CMOS

	MOV	r1, #-1
	STR	r1, [ r0,  #PoduleNode_DMA ]		; We don't do DMA

;	We are faking an EtherI podule ROM, so point the podule ROM address to the appropriate fake header
;	The description string will be extracted from this block in the normal way when chunks get enumerated
        ADR	r1, EtherIcontents
        STR     r1, [ r0, #PoduleNode_ROMAddress ]	; Location to read header from
 ]

;       Fake either an EtherI or a Modem (for Funai8 boards)

 [       FakePodule = ProdType_AutoDetectFunai8

        ;to decide between modem and ethernet
        ;
        ;read line control register (low byte of &8800000C)
        ;invert bit 2
        ;store it back in line control register
        ;read it back out from &88000002C
        ;check it's still inverted
        ;if so modem
        ;else ethernet
        ;put original value back
 [ 1=2
        MOV     r0, #&88000000                          ;EASI space for podule 0
        LDRB    r1, [r0, #&0c]                          ;read reg3 (4x3=&c)
        EOR     r1, r1, #2_100                          ;invert bit 2
        STRB    r1, [r0, #&0c]                          ;store it back
        ; the modem will hold this value and the ethernet, however
        ; the bus isn't loaded in the ethernet version so it will float and also hold the value
        ; so drive the databus to clear this value
        ADD     r0,r0,#&400000
        LDRB    r0, [r0]                                ;load a value from the ethernet driver or from the modem depending on whats fitted - this will drive the bus
        MOV     r0, #&88000000
        LDRB    r0, [r0, #&2c]                          ;load the modem register back
        CMP     r0, r1                                  ;EQ => modem (the ethernet chip is only wired in at &88400000 so it isn't affected by this at all)
        EOR     r1, r1, #2_100                          ;put bit 2 back again
        MOV     r0, #&88000000
        STREQB  r1, [r0, #&0c]                          ;restore line control register - no need to bother if it's an ethernet
 |
        Push    "r2"
        MOV     r0, #&88000000                          ;EASI space for podule 0
        LDRB    r1, [r0, #&0c]                          ;read reg3 (4x3=&c)
        MOV     r2,r1
        BIC     r1, r1, #2_10                           ;clear bit 1
        STRB    r1, [r0, #&0c]                          ;store it back
        LDRB    r1, [r0, #&0c]                          ;load it back
        TST     r1, #2_10                               ;is bit 1 set (if not i.e EQ then it's a modem)
        STREQB  r2, [r0, #&0c]
        Pull    "r2"
 ]
        ADRL    r0, NormalPoduleNodeOffsets             ; work out address of podule0 node
        LDR     r0, [r0]
        ADD     r0, r0, r2                              ; make it an absolute address

        MOVNE   r1, #EtherIIDByte                       ; ID byte for fake EtherI podule
        MOVEQ   r1, #HModemIDByte                       ; ID byte for fake hard-Modem
        STRB    r1, [ r0, #PoduleNode_IDByte ]          ; set ID byte to make ConvertR3ToPoduleNode happy

        MOV     r1, #BitZero
        STRB    r1, [ r0, #PoduleNode_Flags ]           ; This is a (fake) Podule

        MOV     r1, #PoduleCMOS
        STR     r1, [ r0,  #PoduleNode_CMOS ]           ; We don't have no CMOS

        MOV     r1, #-1
        STR     r1, [ r0,  #PoduleNode_DMA ]            ; We don't do DMA

;       Point the podule ROM address to the appropriate fake header
;       The description string will be extracted from this block in the normal way when chunks get enumerated
        ADRNE   r1, EtherIcontents
        ADREQ   r1, HModemcontents                      ; Hard-Modem (i.e not soft-modem)
        STR     r1, [ r0, #PoduleNode_ROMAddress ]      ; Location to read header from
 ]

        BL      LoadAllLoaders                          ; ensure all loaders are loaded

ReInitialisation ; Address of workspace in R2, Address of Private word in R12
 [ DebugModule
        DREG    r2, "Workspace is at &"
        DREG    r12,"Private word is at &"
 ]
        STR     r2, [ r12 ]
        STR     r12, [ r2, #:INDEX:AddressOfMyPrivateWord ]

        CLRV
ExitInitModule
        Pull    "pc"


; OSS Note that due to the module die entry and the service reset code being the same,
; the Messages file gets closed on Service reset. This is not a problem.

KillModule ROUT
ResetAllLoaders
        LDR     wp, [ r12 ]
        MOV     r6, lr
        MOV     r3, #:INDEX: Podule0
10
        BL      ResetLoader
        MOVVS   pc, r6
  [  DebugModule
        DLINE   " OK"
  ]
        ASSERT  PoduleNode_Link = 0
        LDR     r3, [ wp, r3 ]                          ; get next node offset
        TEQ     r3, #0
        BNE     %10

        BL      close_message_file                      ; close messages file if it is open, marking it closed
        CLRV
        MOV     pc, r6

        ASSERT  Service_Reset < Service_PreReset
        ASSERT  Service_PreReset < Service_TerritoryStarted
ServiceTable
        DCD     0                        ;flags
        DCD     UServiceEntry - Origin
        DCD     Service_Reset
        DCD     Service_PreReset
        DCD     Service_TerritoryStarted
        DCD     0                        ;terminator
        DCD     ServiceTable - Origin    ;table anchor
ServiceEntry ROUT
        MOV     r0, r0                   ;magic instruction
        TEQ     r1, #Service_PreReset
        TEQNE   r1, #Service_Reset
        TEQNE   r1, #Service_TerritoryStarted
        MOVNE   pc, lr
UServiceEntry
        TEQ     r1, #Service_TerritoryStarted
        BEQ     RedoMessages

        Push    "r0-r6, lr"
        BL      ResetAllLoaders
        Pull    "r0-r6, pc"

RedoMessages
        LDR     wp, [r12]
        B       LookupLoader26bitError

; ****************************************************************************
;
;       LoadAllLoaders - Internal routine to load all loaders on initialisation
;
; in:   R12 -> private word
;       R2 -> workspace
;
; out:  R0,R1,R3-R5 corrupted
;       R2 -> workspace (not necessarily where it used to be)
;       All others must be preserved
;
LoadAllLoaders  ROUT
        Push    "r8-r12, lr"
        SUB     sp, sp, #16                             ; Make a frame to work in
  [  DebugModule
        DLINE   "Load All Loaders called"
  ]
        STR     r12, [ r2, #:INDEX:AddressOfMyPrivateWord ]
        STR     r2, [ r12 ]
        MOV     wp, r2
        [       NetworkPodule                           ; Reset the hardware
        LDR     r8, AddressOfNetworkBaseROM
        STRB    r8, [ r8, #0 ]                          ; A write resets the counter
        ]
        MOV     r8, #0                                  ; start with podule 0
LoadLoadersLoop
  [  DebugModule
        BREG    r8, "Doing podule &"
  ]
        MOV     r3, r8
        BL      ConvertR3ToPoduleNode
  [  DebugModule
        BVC     %14
        ADD     r14, r0, #4
        DSTRING r14, "Error from ConvertR3ToPoduleNode: "
        B       %15
14
        ADD     r14, wp, r3
        LDR     r14, [ r14, #PoduleNode_LoaderOffset ]
        DREG    r14, "Loader offset is &"
15
  ]
        BVS     TryNextPodule
        MOV     r2, sp                                  ; Base of 16 byte stack frame
  [  DebugModule
        LDR     r3, =&BCBCBCBC
        STR     r3, [ sp, #0 ]
        STR     r3, [ sp, #4 ]
        STR     r3, [ sp, #8 ]
        STR     r3, [ sp, #12 ]
  ]
        MOV     r3, r8                                  ; Podule number
        BL      ReadHeader                              ; Do this to get the type byte
  [  DebugModule
        BVC     %16
        ADD     r14, r0, #4
        DSTRING r14, "Error from ReadHeader: "
        B       %17
16
        LDR     r14, [ sp, #0 ]
        DREG    r14, "Header is &", cc
        LDR     r14, [ sp, #4 ]
        DREG    r14, ", &", cc
        LDR     r14, [ sp, #8 ]
        DREG    r14, ", &", cc
        LDR     r14, [ sp, #12 ]
        DREG    r14, ", &"
17
  ]
        BVS     TryNextPodule
        MOV     r0, #0                                  ; Start with chunk zero
NextChunk
        BL      EnumerateChunks                         ; Loads the loader and the description
        BVS     TryNextPodule                           ; if get error, goto next podule
        TEQ     r0, #0                                  ; Is this the last chunk?
        BNE     NextChunk                               ; No, so get another one
TryNextPodule
        ADD     r8, r8, #1                              ; Go to the next podule
        CMP     r8, #MaximumPodule
        BCC     LoadLoadersLoop
  [  ExtensionROMs
        LDR     r9, number_of_extension_roms		; jharris: was r10, but r10 gets trashed by EnumerateChunks
   [  DebugModule
        BREG    r9, "There are &", cc
        DLINE   " extension ROMs"
   ]
        TEQ     r9, #0
        BEQ     ExitLoadLoaders				; jharris: was BEQ to (non-existent) 99
        MOV     r8, #-2
LoadExtensionROMLoop
   [  DebugModule
        BREG    r8, "Doing extension ROM &"
   ]
        MOV     r3, r8
        BL      ConvertR3ToPoduleNode
   [  DebugModule
        BVC     %74
        ADD     r14, r0, #4
        DSTRING r14, "Error from ConvertR3ToPoduleNode: "
74
   ]
        BVS     NextExtensionROM
        MOV     r0, #0                                  ; Start with chunk zero
ExtensionChunkLoop
        MOV     r3, r8
        BL      EnumerateChunks                         ; Loads the description
        BVS     NextExtensionROM                        ; If get error, goto next ROM
        TEQ     r0, #0                                  ; Is this the last chunk?
        BNE     ExtensionChunkLoop                      ; No, so get another one
NextExtensionROM
        DEC     r8
        DECS    r9					; jharris
        BNE     LoadExtensionROMLoop
  ]
ExitLoadLoaders
        ADD     sp, sp, #16                             ; Remove frame
        Pull    "r8-r12, lr"
        LDR     r2, [ r12 ]                             ; reload workspace ptr from priv word
        MOV     pc, lr

  [  NetworkPodule
AddressOfNetworkBaseROM
        DCD     NetworkBaseROM
  ]

EasyLookup ROUT
        ;       In:  R1 Pointer to token
        ;       In:  R4 Single parameter to substitute
        ;       Out: R2 Pointer to looked up message in an error buffer
        ;       Out: R3 Length including terminator

        Push    "r0, r1, r3, r5, r6, r7, lr"
        BL      open_message_file
  [  DebugModule
        BVC     %71
        ADD     r14, r0, #4
        DSTRING r14, "Error from open_message_file: "
71
  ]
        ADRVC   r0, message_file_block                  ; Message file handle
        MOV     r2, #0                                  ; No buffer, expand in place
        MOV     r3, #0
        MOV     r5, #0                                  ; No %1
        MOV     r6, #0                                  ; No %2
        MOV     r7, #0                                  ; No %3
  [ DebugModule :LOR:  DebugCommands
        BVS     ExitEasyLookup
        DREG    r0, "R0 = &", cc
        Push    r14
        LDR     r14, [ r0, #0 ]
        DREG    r14, ", &", cc
        LDR     r14, [ r0, #4 ]
        DREG    r14, ", &", cc
        LDR     r14, [ r0, #8 ]
        DREG    r14, ", &", cc
        LDR     r14, [ r0, #12 ]
        DREG    r14, ", &"
        Pull    r14
        DREG    r1, "R1 = &", cc
        DSTRING r1, " token is: "
        DREG    r2, "R2 = &"
        DREG    r3, "R3 = &"
        DREG    r4, "R4 = &", cc
        DSTRING r4, " %0 is: "
        DREG    r5, "R5 = &", cc
        DSTRING r5, " %1 is: "
        DREG    r6, "R6 = &", cc
        DSTRING r6, " %2 is: "
        DREG    r7, "R7 = &", cc
        DSTRING r7, " %3 is: "
        DREG    r8, "R8 = &"
        DREG    r9, "R9 = &"
        DREG    r10, "R10 = &"
        DREG    r11, "R11 = &"
        DREG    r12, "R12 = &"
        DREG    r13, "R13 = &"
        DREG    r14, "R14 = &"
        DREG    r15, "R15 = &"
  ]
        SWIVC   XMessageTrans_Lookup
  [  DebugModule
        BVC     %76
        ADD     r14, r0, #4
        DSTRING r14, "Error from XMessageTrans_Lookup: "
76
  ]
        BVS     ExitEasyLookup
        ADD     r3, r3, #1                              ; Allow for the terminator
        STR     r3, [ sp, #8 ]                          ; Poke into the return frame
        LDR     r0, [ sp, #4 ]                          ; Get the token pointer
        DEC     r0, 4                                   ; Pretend it is an error pointer
        ADR     r1, message_file_block                  ; Message file handle
        MOV     r2, #0                                  ; No buffer, expand into a buffer
        MOV     r3, #0
  [ False ; DebugModule
        DREG    r0, "R0 = &"
        DREG    r1, "R1 = &"
        DREG    r2, "R2 = &"
        DREG    r3, "R3 = &"
        DREG    r4, "R4 = &"
        DREG    r5, "R5 = &"
        DREG    r6, "R6 = &"
        DREG    r7, "R7 = &"
        DREG    wp, "WP = &"
        DREG    sp, "SP = &"
  ]
        SWI     XMessageTrans_ErrorLookup
  [  DebugModule
        ADD     r14, r0, #4
        DSTRING r14, "Error from XMessageTrans_ErrorLookup: "
  ]
        CLRV
        ADD     r2, r0, #4                              ; Skip over the error number
ExitEasyLookup
  [ DebugModule :LOR:  DebugCommands
        Push    "r0, r1"
        ADR     r0, message_file_block                  ; Message file handle
        DREG    r0, "R0 = &", cc
        LDR     r1, [ r0, #0 ]
        DREG    r1, ", &", cc
        LDR     r1, [ r0, #4 ]
        DREG    r1, ", &", cc
        LDR     r1, [ r0, #8 ]
        DREG    r1, ", &", cc
        LDR     r1, [ r0, #12 ]
        DREG    r1, ", &"
        Pull    "r0, r1"
  ]
        STRVS   r0, [ sp, #0 ]
        Pull    "r0, r1, r3, r5, r6, r7, pc"

        ROUT

        LTORG

        [ :LNOT: ReleaseVersion
        InsertDebugRoutines
        ]

        END
