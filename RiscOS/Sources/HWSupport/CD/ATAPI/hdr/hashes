;******************************************************************************
;
; hdr.hashes
;
; Author: Mark Watson (EESOX)
;
; Description
; ===========
; Hash defines
;
; Change record
; =============
; 09-Mar-95  18:45  cpartington (Cambridge Systems Design)
; * Added a few more standard register definitions and CPU mode definitions.
; * Added flags sony_50_id_bodge, mode_select_dont_use_page_d and cdebug.
;
; 14-Mar-95  10:05  cpartington (Cambridge Systems Design)
; * Added flag check_transfer_before_drq.
;
; 18-Mar-95  12:13  cpartington (Cambridge Systems Design)
; * Added flags reset_on_drive_error and use_readcd_for_mode_1.
; * Removed flag check_transfer_before_drq (code permanently enabled).
;
; 21-Mar-95  13:55  cpartington (Cambridge Systems Design)
; * Removed flag use_readcd_for_mode_1 (code permanently enabled).
;
; 24-Mar-95  09:57  cpartington (Cambridge Systems Design)
; * Added flag mode_select_ignore_page_d_error.
;
; 30-Mar-95  16:56  cpartington (Cambridge Systems Design)
; * Added flags fix_cr571b10e_maybe, fix_slow_when_no_drives,
;   check_mode_sense_length, extra_delay_after_irq.
;
;*end of change record*


; sony_50_id_bodge enables code in IDENTIFY to check for the version
; of the SONY CDU50E with incorrect IDENTIFY data and cope with it.
;
        GBLL    sony_50_id_bodge
sony_50_id_bodge        SETL    {TRUE}
 [ sony_50_id_bodge
        !       0,"Sony CDU50E 0.3n bodge included"
 |
        !       0,"Sony CDU50E 0.3n bodge NOT included"
 ]


; mode_select_dont_use_page_d disables the code to send page D when doing
; a mode select - SONY CDU50E 0.3n aborts this command
;
        GBLL    mode_select_dont_use_page_d
mode_select_dont_use_page_d     SETL    {FALSE}
 [ mode_select_dont_use_page_d
        !       0,"MODE SELECT will NOT send page D"
 |
        !       0,"MODE SELECT will send page D"
 ]


; mode_select_ignore_page_d_error causes any error returned from sending
; page D during MODE SELECT to be ignored.
        GBLL    mode_select_ignore_page_d_error
mode_select_ignore_page_d_error SETL    {TRUE}
 [ :LNOT: mode_select_dont_use_page_d
  [ mode_select_ignore_page_d_error
        !       0,"Errors from MODE SELECT page D will be ignored"
  |
        !       0,"Errors from MODE SELECT page D will NOT be ignored"
  ]
 ]
 

; reset_on_drive_error causes the driver to issue an ATAPI reset to a drive
; if it misbehaves. This is part of the spec but, more pragmatically, it
; cures a problem with the Panasonic CR571B where it occasionally fails to
; deassert BSY if the draw is opened during certain operations.
;
        GBLL    reset_on_drive_error
reset_on_drive_error    SETL    {TRUE}
 [ reset_on_drive_error
        !       0,"Drive will be reset on error"
 |
        !       0,"Drive will NOT be reset on error"
 ]


; fix_cr571b10e_maybe inserts extra read of alt_status register after
; reading byte count registers to try to work around Panasonic CR571B 1.0e
; cache problem.
; 1.22 => FALSE
;
        GBLL    fix_cr571b10e_maybe
fix_cr571b10e_maybe     SETL    {TRUE}
 [ fix_cr571b10e_maybe
        !       0,"Fix for CR571B 1.0e cache enabled"
 |
        !       0,"Fix for CR571B 1.0e cache disabled"
 ]


; fix_slow_when_no_drives stops retries when no drives seem to be connected
; 1.22 => FALSE
;
        GBLL    fix_slow_when_no_drives
fix_slow_when_no_drives         SETL    {TRUE}
 [ fix_slow_when_no_drives
        !       0,"Fix for when no drives enabled"
 |
        !       0,"Fix for when no drives disabled"
 ]


; check_mode_sense_length enables MEW's code that requires returned
; mode sense data to be a particular size.
; 1.22 => TRUE
;
        GBLL    check_mode_sense_length
check_mode_sense_length         SETL    {FALSE}
 [ check_mode_sense_length
        !       0,"MODE SENSE data must be specific size"
 |
        !       0,"MODE SENSE data can be any size"
 ]


; extra_delay_after_irq adds a delay after BSY is cleared after IRQ
; 1.22 => FALSE
;
        GBLL    extra_delay_after_irq
extra_delay_after_irq   SETL    {TRUE}
 [ extra_delay_after_irq
        !       0,"Extra delay after IRQ added"
 |
        !       0,"No extra delay after IRQ"
 ]


; CSD debug flags
        GBLL    cdebug
cdebug  SETL    {TRUE}
cdebug  SETL    {FALSE}
        GBLL    cdebug2
cdebug2 SETL    cdebug :LAND: {FALSE}
        GBLL    cdebug_debugging_all_ops
cdebug_debugging_all_ops        SETL    {FALSE}
 [ cdebug
        !       0,"*** This is a debug version ***"
 ]

;***************************************************************************
; Define registers etc.for general use
;***************************************************************************

r14 RN 14
r13 RN 13
sp  RN 13
SP  RN 13
r12 RN 12                   ; This register is linked to the variables in w/s
r11 RN 11  ; NEVER CHANGE R11 in the driver
SWIN RN 11
r10 RN 10
r9  RN  9
r8  RN  8
r7  RN  7
r6  RN  6
r5  RN  5
r4  RN  4
r3  RN  3
r2  RN  2
r1  RN  1
r0  RN  0


SVC_mode        *       3

;***************************************************************************
; Debugging options
;***************************************************************************

OUTPUT_ON        * 0       ; =0 then no output, =1 then VDUcatcher or screen
OUTPUT_TO_SCREEN * 0       ; =0 then VDUcatcher, =1 then screen
MINCS            * 0       ; =1 then only use the ReadData command


X_bit                  *             1:SHL:17

;*************** ATAPI SWI numbers *******************

ATAPI_BaseNumber       *        &4A740
XATAPI_BaseNumber      *        ATAPI_BaseNumber:OR:X_bit

                       ^        XATAPI_BaseNumber
XATAPI_GetDrives       #        1

XOS_Word   * 7:OR:X_bit

;*************** CD driver SWI numbers *******************

XCD_BaseNumber         *        (&41240:OR:X_bit)
                       ^ XCD_BaseNumber
XCD_Version            #        1                      ;  0
XCD_ReadData           #        1                      ;  1
XCD_SeekTo             #        1                      ;  2
XCD_DriveStatus        #        1                      ;  3
XCD_DriveReady         #        1                      ;  4
XCD_GetParameters      #        1                      ;  5
XCD_SetParameters      #        1                      ;  6
XCD_OpenDrawer         #        1                      ;  7
XCD_EjectButton        #        1                      ;  8
XCD_EnquireAddress     #        1                      ;  9
XCD_EnquireDataMode    #        1                      ; 10
XCD_PlayAudio          #        1                      ; 11
XCD_PlayTrack          #        1                      ; 12
XCD_AudioPause         #        1                      ; 13
XCD_EnquireTrack       #        1                      ; 14
XCD_ReadSubChannel     #        1                      ; 15
XCD_CheckDrive         #        1                      ; 16
XCD_DiscChanged        #        1                      ; 17
XCD_StopDisc           #        1                      ; 18
XCD_DiscUsed           #        1                      ; 19
XCD_AudioStatus        #        1                      ; 20
XCD_Inquiry            #        1                      ; 21
XCD_DiscHasChanged     #        1                      ; 22
XCD_Control            #        1                      ; 23
XCD_Supported          #        1                      ; 24
XCD_Prefetch           #        1                      ; 25
XCD_Reset              #        1                      ; 26
XCD_CloseDrawer        #        1                      ; 27
XCD_IsDrawerLocked     #        1                      ; 28
XCD_AudioControl       #        1                      ; 29
XCD_LastError          #        1                      ; 30
XCD_AudioLevel         #        1                      ; 31
XCD_Register           #        1                      ; 32
XCD_Unregister         #        1                      ; 33
XCD_ByteCopy           #        1                      ; 34
XCD_Identify           #        1                      ; 35
XCD_ConvertToLBA       #        1                      ; 36
XCD_ConvertToMSF       #        1                      ; 37
XCD_ReadAudio          #        1                      ; 38
XCD_ReadUserData       #        1                      ; 39
XCD_SeekUserData       #        1                      ; 40
XCD_GetAudioParms      #        1                      ; 41
XCD_SetAudioParms      #        1                      ; 42


;***************************************************************************
; Define registers for RCM's block copy routine
;***************************************************************************

mbsrc1     RN 0
mbsrcptr   RN 1
mbdstptr   RN 2
mbcnt      RN 3
mbsrc2     RN 14
mbsrc3     RN 4
mbsrc4     RN 5
mbsrc5     RN 6
mbsrc6     RN 7
mbsrc7     RN 8
mbsrc8     RN 9
mbsrc9     RN 10
mbshftL    RN 11
mbshftR    RN 12
lr         RN 14
pc         RN 15

;***************************************************************************

OAK                   *       1
ACORN                 *       0

ON * 1
OFF * 0

TRUE * 1
FALSE * 0

debug        * OFF              ; prints debugging information
commanddebug * OFF              ; Keeps a list of SWI's called

;------------------------------------------------------------------
; Structure of r7 -> control block
;------------------------------------------------------------------
                      ^ 0
SdeviceIDoffset       #       4
LScardnumberoffset    #       4
LUNoffset             #       4
drivetypeoffset       #       4
control_block_size    #       0

;------------------------------------------------------------------

RESERVED              *       0
CONTROLBYTE           *       0


LBAFormat             *       0
MSFFormat             *       1
PBFormat              *       2

;*********************************************************************************************

SmallestMode          *       1
LargestMode           *       2

mode1datasize         *       2048
;mode2datasize         *       2336
mode2datasize         *       2340
mode1datasizeHBLB     *       &00080000 ; high/byte low/byte of above
mode2datasizeHBLB     *       &24090000 ;

SYNC_SIZE                 *         12


MODE2__HEADER_M           *          0
MODE2__HEADER_S           *          1
MODE2__HEADER_F           *          2
MODE2__HEADER_MODE        *          3
MODE2__HEADER_SIZE        *          4

MODE2__SUB_HEADER_FILE    *          0    ; These fields are repeated at 4,5,6,7
MODE2__SUB_HEADER_CHANNEL *          1    ;
MODE2__SUB_HEADER_SUBMODE *          2    ;
MODE2__SUB_HEADER_CODING  *          3    ;
MODE2__SUB_HEADER_SIZE    *          8

MODE2__TOTALHEADERSIZE    *      MODE2__HEADER_SIZE + MODE2__SUB_HEADER_SIZE

SUBMODE__FORM             *       (1:SHL:5)

USERDATA__MODE2FORM1      *       2048
USERDATA__MODE2FORM2      *       2324


;*********************************************************************************************

bit17                 *   2_100000000000000000

MaxNumberOfSeconds    *      59
MinNumberOfSeconds    *       2
MaxNumberOfBlocks     *      74

MaxSCSIcardnumber     *       3
MaxLUN                *       3
MaxSCSIdeviceID       *       6

PhysicalBlockDifference *   2 * ( MaxNumberOfBlocks + 1 ) ; 2 seconds

SWIBaseNumber         *   &41240

ErrorBlock            *   &00803400

;******************* Used for macro to allow nice error blocks ***********

 GBLA CDFSDriverErrorNumber
CDFSDriverErrorNumber SETA ErrorBlock


;******************* SCSI error numbers  ***************************

SCSIErrorNumber       *   &00020100

                      ^   SCSIErrorNumber

NoRoom                # 1     ; 0
UnknownSCSISWI        # 1     ; 1
UnknownReason         # 1     ; 2
FailedBusReset        # 1     ; 3
InvalidHostId         # 1     ; 4
InvalidDeviceId       # 1     ; 5
gap                   # 3     ; 6 - 8
DeviceNotIdle         # 1     ; 9
TimeoutSelection      # 1     ; 10
TimeoutOther          # 1     ; 11
CommandQueueError     # 1     ; 12
CommandQueFull        # 1     ; 13
ReservationError      # 1     ; 14
InvalidParameters     # 1     ; 15
ParameterError        # 1     ; 16
NotFromIRQ            # 1     ; 17
OperationAborted      # 1     ; 18
UnexpectedDisconnect  # 1     ; 19

;***************** SCSI sense numbers ( TargetError )**********************

SCSISenseNumber       *     &201C0
                      ^     SCSISenseNumber

NoSense               # 1   ; 0
RecoveredError        # 1   ; 1
NotReady              # 1   ; 2
MediumError           # 1   ; 3
HardwareError         # 1   ; 4
IllegalRequest        # 1   ; 5
UnitAttention         # 1   ; 6
DataProtect           # 1   ; 7
BlankCheck            # 1   ; 8
VendorUnique          # 1   ; 9
CopyAborted           # 1   ; 10
AbortedCommand        # 1   ; 11
Equal                 # 1   ; 12
VolumeOverflow        # 1   ; 13
Miscompare            # 1   ; 14
ReservedSenseKey      # 1   ; 15


;***************** SCSI status byte numbers *******************************

SCSIStatusNumber      *     &20180
                      ^     SCSIStatusNumber

CheckCondition        # 1
Busy                  # 1
Unknown               # 1


;******************* Retry count for all operations *********************

DefaultInternalRetryCount *  1600



;***************************** SWI Numbers ******************************

XSCSI_Command         *       &403C0:OR:bit17          ; For OAK SCSI
XSCSI_Op              *       &403C3:OR:bit17
XSCSI_Control         *       &403C2:OR:bit17
XSCSI_Initialise      *       &403C1:OR:bit17
XPodule_ReadHeader    *       &40281:OR:bit17
ADFS_LockIDE          *       &40251
XADFS_LockIDE         *       ADFS_LockIDE:OR:bit17          ; ADFS 2.97 onwards
XOS_ConvertCardinal2  *       &D6
XOS_ConvertCardinal3  *       &D7
XOS_ConvertCardinal4  *       &D8
XOS_ReadSysInfo       *       &58:OR:bit17
XOS_AddCallBack       *       &54:OR:bit17
XOS_PrettyPrint       *       &44:OR:bit17
XOS_ReadMonotonicTime *       &42:OR:bit17
XOS_SWINumberFromString *     &39:OR:bit17
OS_GenerateError      *       &2b             ; don't use X version 'cause it doesn't do anything
XOS_Release           *       &20:OR:bit17
XOS_Claim             *       &1f:OR:bit17
XOS_Module            *       &1E:OR:bit17
XOS_NewLine           *       &3:OR:bit17
XOS_Write0            *       &2:OR:bit17
XOS_WriteS            *       &1:OR:bit17
XOS_WriteC            *       &0:OR:bit17
XMessageTrans_OpenFile *      &41501:OR:bit17
XMessageTrans_ErrorLookup *   &41506:OR:bit17
XMessageTrans_CloseFile *     &41504:OR:bit17

;***************************** Values for SCSI_Op ************************

I_bit                       *   1:ROL:27
FIRQ_Flag                   *   1:ROL:26
IRQ_Flag                    *   1:ROL:27
Overflow_Flag               *   1:ROL:28
Carry_Flag                  *   1:ROL:29
Zero_Flag                   *   1:ROL:30

OK                    *  1
BUSY                  *  2
NOTREADY              *  4
UNAVAILABLE           *  8

ParameterBlockOffset  *  6

NODATA                *  0
READDATA              *  1
WRITEDATA             *  2

;----------------------------------------------------------------------------------------------
; CD_Supported values
;
; Meaning of number returned by CD_Supported
;  Bits    Description: ( if set )
;  ----    -----------------------
;  0 - 2   Level to which CD_AudioControl is supported ( 0 to 7 )
;          0 = no support at all
;          1 = supported to level 0
;          7 = supported to level 6
;    3     CD_Prefetch supported
;    4     CD_CloseDrawer supported
;    5     CD_AudioLevel supported
;  6 - 13  Number of different speeds supported by the drive - 1.
;          ie/ Standard drives support 1 speed, so will return 0.
;          The Sony 561 supports 2 speeds, so will return 1.
;   14     CD_ReadAudio supported
;   15     CD_Get/SetAudioParms supported
;  16 - 31  RESERVED ( 0 )
;----------------------------------------------------------------------------------------------

NOAUDIOCONTROLSUPPORT     *  0
AUDIOCONTROLSUPPORT1      *  2_1
AUDIOCONTROLSUPPORT2      *  2_10
AUDIOCONTROLSUPPORT3      *  2_11
AUDIOCONTROLSUPPORT4      *  2_100
AUDIOCONTROLSUPPORT5      *  2_101
AUDIOCONTROLSUPPORT6      *  2_110
AUDIOCONTROLSUPPORT7      *  2_111

SUPPORT__PREFETCH         *  2_1000

SUPPORT__CLOSE_DRAWER     *  2_10000

SUPPORT__AUDIO_LEVEL      *  2_100000

SUPPORT__SPEED_MULTIPLIER *  2_1000000

SUPPORT__READ_AUDIO       *  1:SHL:14

SUPPORT__AUDIO_PARMS      *  1:SHL:15

 [ Version >= 105

ATAPI_VERSIONBITS * (SUPPORT__SPEED_MULTIPLIER * 4) + SUPPORT__READ_AUDIO + SUPPORT__CLOSE_DRAWER + SUPPORT__AUDIO_PARMS

 |
ATAPI_VERSIONBITS * (SUPPORT__SPEED_MULTIPLIER * 4) + SUPPORT__READ_AUDIO + SUPPORT__CLOSE_DRAWER

 ]

;****************
; Audio status returns
;****************

PLAYINGAUDIO  * 0
PAUSED        * 1
MUTED         * 2
PLAYCOMPLETED * 3
PLAYERROR     * 4
NOPLAY        * 5

;****************
; AudioControl hashes ( level 0 )
;****************

STEREO        * 3
MUTEDSTEREO   * 0
LEFTALL       * 2
RIGHTALL      * 1

STEREOLISTLENGTH * 14

;****************

;----------------------------------------------------------------------------------------------
; Layout of the register block
;----------------------------------------------------------------------------------------------
             ^ 0
REG_INFO_WORD       #  4
REG_COUNT           #  4
REG_TYPES           #  4
REGISTER_BLOCK_SIZE #  0

;----------------------------------------------------------------------------------------------
; The information word when registering
;----------------------------------------------------------------------------------------------
CD_COMMANDS                 * 32
USE_SCSI_READ               * 1<<6
USE_SCSI_SEEK               * 1<<7
USE_SCSI_INQUIRY            * 1<<8
USE_SCSI_CAPACITY           * 1<<9
USE_SCSI_READY              * 1<<10
USE_SCSI_STOPOPEN           * 1<<11
USE_SCSI_CHECK              * 1<<12
USE_SCSI_STATUS             * 1<<13
USE_SCSI_CONTROL            * 1<<14
USE_SCSI_PREFETCH           * 1<<15
USE_SCSI_RESET              * 1<<16
USE_PROPRIETARY_RUD         * 1<<17   ; = 1 if support own method of reading data
USE_COMPLEX_RUD             * 1<<18   ; = 1 if want SCSI scatter list method of reading data
USE_PROPRIETARY_SUD         * 1<<19   ; = 1 if support own method of seeking to data
USE_COMPLEX_SUD             * 1<<20   ; = 1 if want SCSI scatter list method of seeking to data


INFORMATION_WORD    * CD_COMMANDS + USE_PROPRIETARY_RUD


DRIVE_TYPES         * 1
;----------------------------------------------------------------------------------------------



BUFFER_SIZE            *            2352 + 20      ; see EnquireDataMode


;----------------------------------------------------------------------------------------------
; Get and Set AudioParms reason codes
;----------------------------------------------------------------------------------------------

GAP__VOLUME_LEVELS          *         0

SAP__VOLUME_LEVELS          *         0

;----------------------------------------------------------------------------------------------


 END
