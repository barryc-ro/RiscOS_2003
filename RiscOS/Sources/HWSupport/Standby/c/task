/* File:    task.c
   Purpose: Wimp task section of module.
   Author:  Ben Laughton

   Copyright 1998 Acorn Computers Ltd

   This material is the confidential trade secret and proprietary information
   of Acorn Computers. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Acorn Computers.
   All rights reserved.

   History:

   1998-10-20 BAL
   Created.
 */




/* =============================================================================
 * Include header files
 */

/* CLib */
#include "kernel.h"
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include "swis.h"

/* Wimp */
#include "tboxlibs/wimp.h"
#include "tboxlibs/wimplib.h"

/* Standby */
#include "header.h"
#include "module.h"
#include "standby.h"
#include "task.h"




/* =============================================================================
 * Constants definitions
 */

#define TASK                0x4b534154
#define TASK_DESCRIPTION    "Standby"
#define WIMP_VERSION        310
#define KEY_CTRL_SHIFT_F12  0x1fc




/* =============================================================================
 * Global variable declarations
 */

int           task_handle = 0;
int           task_stack = 0;
volatile int  poll_word = 0;




/* =============================================================================
 * Function prototype declarations
 */

static _kernel_oserror *  handle_key_pressed (
                              WimpKeyPressedEvent *const  key_pressed);

static _kernel_oserror *  handle_poll_word_non_zero (
     WimpPollWordNonZeroEvent *const  poll_word_non_zero);

static _kernel_oserror *  handle_user_message_acknowledge (
    WimpUserMessageAcknowledgeEvent *const  user_message_acknowledge);

static _kernel_oserror *  send_pre_quit (void);




/* =============================================================================
 * Function definitions
 */

/* -----------------------------------------------------------------------------
   main

   Start the Wimp task section of the module and enter the main Wimp poll loop.

   Returns
   failure: EXIT_FAILURE
   otherwise doesn't return
 */

int  main (int     argc,
           char *  argv[])
{
    _kernel_oserror *  e = NULL;
    int  message_list[] =
    {
        Wimp_MPreQuit
    };

    NOT_USED (argc);
    NOT_USED (argv);

    e = wimp_initialise (WIMP_VERSION,
                         Module_Title,
                         message_list,

                         NULL,
                         &task_handle);
    if (!e)
    {
        int            mask = 0x00401831;
        int            event_code;
        WimpPollBlock  poll;

        for (;;)
        {
            e = wimp_poll (mask,
                           &poll,
                           (int *) &poll_word,
                           &event_code);
            if (!e)
            {
                switch (event_code)
                {
                    case Wimp_EKeyPressed:
                        e = handle_key_pressed (&poll.key_pressed);
                        break;

                    case Wimp_EPollWordNonZero:
                        e = handle_poll_word_non_zero (
                                &poll.poll_word_non_zero);
                        break;

                    case Wimp_EUserMessageAcknowledge:
                        e = handle_user_message_acknowledge (
                                &poll.user_message_acknowledge);
                        break;

                    default:
                        break;
                }
            }

            if (e)
            {
                wimp_report_error (e, 0, 0, 0, 0, 0);
            }
        }
    }

    fprintf (stderr, "%s\n", e->errmess);

    return EXIT_FAILURE;
}




/* -----------------------------------------------------------------------------
   task_closedown

   Closedown the Wimp task section of the module.

   Returns
   success: NULL
   failure: pointer to RISC OS error block
 */

_kernel_oserror *  task_closedown (void)
{
    _kernel_oserror *  e = NULL;

    /* Only closedown if task is currently active */
    if (task_handle > 0)
    {
        /* Can't sensibly deal with any error */
        e = wimp_close_down (task_handle);

        /* Mark task as inactive */
        task_handle = 0;
    }

    if (task_stack)
    {
        _swix (OS_Module,
               _IN (0) | _IN (2),

               OS_Module_Free,
               task_stack);

        task_stack = 0;
    }

    return e;
}




/* -----------------------------------------------------------------------------
   handle_key_pressed

   Handle key pressed events from the Wimp.

   Inputs
   WimpKeyPressedEvent *const  key_pressed: key pressed event data

   Returns
   success: NULL
   failure: pointer to RISC OS error block
 */

static _kernel_oserror *  handle_key_pressed (
                              WimpKeyPressedEvent *const  key_pressed)
{
    _kernel_oserror *  e = NULL;

    if (key_pressed->key_code == KEY_CTRL_SHIFT_F12)
    {
        e = send_pre_quit ();
    }
    else
    {
        /* Give other tasks a chance to process the key */
        e = wimp_process_key (key_pressed->key_code);
    }

    return e;
}




/* -----------------------------------------------------------------------------
   handle_poll_word_non_zero

   Handle poll-word non-zero events from the Wimp.

   Inputs
   WimpPollWordNonZeroEvent *const  poll_word_non_zero: poll-word non-zero event
                                                        data

   Returns
   success: NULL
   failure: pointer to RISC OS error block
 */

static _kernel_oserror *  handle_poll_word_non_zero (
     WimpPollWordNonZeroEvent *const  poll_word_non_zero)
{
    /* Only meaning of pollword is when module part wants the PreQuit
     * message to be broadcast.
     */
    *(int *) (poll_word_non_zero->poll_word) = 0;
    return send_pre_quit ();
}




/* -----------------------------------------------------------------------------
   handle_user_message_acknowledge

   Handle User Message Acknowledge events from the Wimp.

   Inputs
   WimpUserMessageAcknowledgeEvent *const  user_message_acknowledge :
       user message ackowledge event data

   Returns
   success: NULL
   failure: pointer to RISC OS error block
 */

static _kernel_oserror *  handle_user_message_acknowledge (
    WimpUserMessageAcknowledgeEvent *const  user_message_acknowledge)
{
    _kernel_oserror *  e = NULL;

    if (user_message_acknowledge->hdr.action_code == Wimp_MPreQuit)
    {
        /* Continue with Standby */
        e = _swix (Standby_Standby,
                   _IN (0),

                   STANDBY_STANDBY_SKIP_PREQUIT);
    }

    return e;
}




/* -----------------------------------------------------------------------------
   send_pre_quit

   Broadcast the PreQuit message to all tasks.

   Returns
   success: NULL
   failure: pointer to RISC OS error block
 */

static _kernel_oserror *  send_pre_quit (void)
{
    WimpMessage  message;

    message.hdr.size = sizeof (message.hdr) + sizeof (message.data.shutdown);
    message.hdr.your_ref = 0;
    message.hdr.action_code = Wimp_MPreQuit;

    message.data.shutdown.flags = 0;

    return wimp_send_message (Wimp_EUserMessageRecorded,
                              &message,
                              0,
                              0,
                              NULL);
}
