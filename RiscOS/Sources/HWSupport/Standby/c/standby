/* > standby.c
 *
 *	  Standby code.
 */

#include <stdlib.h>
#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "standby.h"
#include "led.h"
#include "veneer.h"


static int Flags = 0;
static int PointerType;


static void
SetLED( int flag )
{
	_swix( LED_Control, _INR(0,2), STANDBY_LED_NUMBER, ~LED_ON_FLAG, flag );
}


/*
 * Called (indirectly from wimp-message-handler) by EnterStandby after no
 * Wimp task has objected to the standby.
 */
static _kernel_oserror *
EnterStandby2( int flags, void *pw )
{
	_kernel_oserror *err = NULL;
	int temp;

	/* Disable handling of standby SWIs while we try to go into standby. */
	temp = veneer_irqs_off();
	Flags |= STANDBY_BUSY_FLAG;
	veneer_irqs_on( temp );

	if ( (Flags & STANDBY_SHUTDOWN_FLAG) == 0 )
	{
		temp = -1;

		/* If force is set then err == NULL and temp == -1 from above. */
		if ( !(flags & STANDBY_STANDBY_FORCE_FLAG) )
			err = _swix( OS_UpCall, _IN(0)|_OUT(0), UpCall_Standby, &temp );

		/* Only enter standby if no-one objects. */
		if ( (err == NULL) && (temp != 0) )
		{
			/* If force is set then err == NULL and temp == -1 from above. */
			if ( !(flags & STANDBY_STANDBY_FORCE_FLAG) )
				err = _swix( OS_ServiceCall, _IN(1)|_OUT(1), Service_ShutDown, &temp );

			/* Only enter standby if no-one objects. */
			if ( (err == NULL) && (temp != 0) )
			{
				/* Disable keyboard buffering. */
				err = _swix( OS_Byte, _IN(0)|_IN(1)|_IN(2)|_OUT(1), 201, 0xFF, 0, &temp );
				if ( (err == NULL) && (temp == 0) ) Flags |= STANDBY_ENABLE_KEYBOARD;

				/* Disable the mouse. */
				(void)_swix( OS_Pointer, _IN(0)|_OUT(0), 0, &temp );
				if ( temp != 255 )
				{
					PointerType = temp;
					(void)_swix( OS_Pointer, _IN(0)|_IN(1), 1, 255 );
					Flags |= STANDBY_ENABLE_POINTER;
				}

				/* Tell the world we're going into standby. */
				(void)_swix( OS_ServiceCall, _IN(1), Service_ShutDownComplete );

				/* Blank the screen and turn off the LED. */
				(void)_swix( ScreenBlanker_Control, _IN(0), ScreenBlankerReason_StrictBlank );
				SetLED( 0 );

				Flags |= STANDBY_SHUTDOWN_FLAG;

				/* Tell the world we're now standby. */
				(void)_swix( OS_ServiceCall, _INR(0,1), Flags & STANDBY_SHUTDOWN_FLAG, Service_Standby );

				/* Allow standby SWIs to work again after a suitable timeout. */
				if ( _swix(OS_CallAfter, _INR(0,2), STANDBY_ENABLE_DELAY, veneer_standby_enable, pw) != NULL )
					standby_enable( NULL, NULL );

				return NULL;
			}
		}
	}

	/* Didn't go into standby so enable SWIs now. */
	standby_enable( NULL, NULL );
	return err;
}



static void
ExitStandby( void *pw )
{
	/* Disable handling of standby SWIs while we come out of standby. */
	int temp = veneer_irqs_off();
	Flags |= STANDBY_BUSY_FLAG;
	veneer_irqs_on( temp );

	/* If we managed to enter standby then come out now. */
	if ( Flags & STANDBY_SHUTDOWN_FLAG )
	{
		int desktop_state;
		_kernel_oserror *err;

		/* Tell the world we're coming out. */
		_swix( OS_UpCall, _IN(0), UpCall_Online );

		/* Re-enable the mouse. */
		if ( Flags & STANDBY_ENABLE_POINTER )
		{
			(void)_swix( OS_Pointer, _IN(0)|_IN(1), 1, PointerType );
			Flags &= ~STANDBY_ENABLE_POINTER;
		}

		/* Re-enable keyboard buffering if required. */
		if ( Flags & STANDBY_ENABLE_KEYBOARD )
		{
			_swix( OS_Byte, _IN(0)|_IN(1)|_IN(2), 201, 0, 0 );
			Flags &= ~STANDBY_ENABLE_KEYBOARD;
		}

		/* Unblank the screen and turn on the LED. */
		(void)_swix( ScreenBlanker_Control, _IN(0), ScreenBlankerReason_StrictUnblank );
		SetLED( LED_ON_FLAG );

		/* Make a noise (but only if we are in the desktop). */
		err = _swix( Wimp_ReadSysInfo, _IN(0)|_OUT(0), 3, &desktop_state );
		if ( (err == NULL) && (desktop_state != 0) ) _swix( SoundFX_Play, _INR(0,1), 0, STANDBY_ONLINE_EVENT );

		Flags &= ~STANDBY_SHUTDOWN_FLAG;

		/* Tell the world we're out. */
		(void)_swix( OS_ServiceCall, _INR(0,1), Flags & STANDBY_SHUTDOWN_FLAG, Service_Standby );

		/* Allow standby IRQ to work again after a suitable timeout. */
		if ( _swix(OS_CallAfter, _INR(0,2), STANDBY_ENABLE_DELAY, veneer_standby_enable, pw) == NULL )
			return;
	}

	standby_enable( NULL, NULL );
}


/* Handler called to enable the standby SWIs after a timeout. */
void
standby_enable( _kernel_swi_regs *r, void *pw )
{
	int temp = veneer_irqs_off();
	Flags &= ~STANDBY_BUSY_FLAG;
	veneer_irqs_on( temp );

	NOT_USED( r );
	NOT_USED( pw );
}


/*
 * Handler for replies to our message_PREQUIT. Called via assembler
 * 'veneer_standby_wimpreplyhandler'.
 */
void standby_wimpreplyhandler( _kernel_swi_regs* r, void* pw)
{
	/* Check event type. */
	if ( r->r[0] == 19)
	{
		/* Message_PREQUIT has bounced, so we can proceed with shutdown. */
		if ( EnterStandby2(0, pw) != NULL ) ExitStandby( pw );
	}
}


static _kernel_oserror *
EnterStandby( int flags, void* pw )
{
	int desktop_state;
	_kernel_oserror *err = _swix( Wimp_ReadSysInfo, _IN(0)|_OUT(0), 3, &desktop_state );
	
	if ( (flags & STANDBY_STANDBY_FORCE_FLAG) || ((err == NULL) && (desktop_state == 0)) )
	{
		return EnterStandby2( flags, pw );
	}
	else
	{
		message_prequit	message;
		message.header.size		= sizeof( message_prequit);
		message.header.yourref		= 0;
		message.header.action		= 8;	/* Message_PreQuit	*/
		message.prequit.data.singletask	= 0;
		/*
		 * If 1, task could terminate itself after its files have been saved. Doing things like this
		 * means that a task could try to send TaskModule a Ctrl-Shift-F12 to try to restart the
		 * shutdown, but this will be ignored.
		 */
		return _swix( TaskModule_SendMessage, _INR(0,5), 0, &message, 0, 0, veneer_standby_wimpreplyhandler, pw);
	}
}


_kernel_oserror *
standby_initialise( void *pw )
{
	return EnterStandby( STANDBY_STANDBY_FORCE_FLAG, pw );
}


void
standby_finalise( void *pw )
{
}


_kernel_oserror *
standby_state( _kernel_swi_regs *r )
{
	r->r[0] = Flags & STANDBY_SHUTDOWN_FLAG;
	return NULL;
}


_kernel_oserror *
standby_standby( _kernel_swi_regs *r, void* pw )
{
	if ( (Flags & STANDBY_BUSY_FLAG) == 0 )
	{
		int old_r0 = r->r[0];
		r->r[0] = Flags & STANDBY_SHUTDOWN_FLAG;
		return EnterStandby( old_r0, pw );
	}
	return NULL;
}


_kernel_oserror *
standby_online( _kernel_swi_regs *r, void *pw )
{
	if ( (Flags & STANDBY_BUSY_FLAG) == 0 )
	{
		r->r[0] = Flags & STANDBY_SHUTDOWN_FLAG;
		ExitStandby( pw );
	}
	return NULL;
}
