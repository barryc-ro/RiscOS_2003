; > handler.s
; interrupt handlers

	GET     hdr:ListOpts
	GET     hdr:Macros
	GET     hdr:System



	EXPORT fiq_handler_code
	EXPORT fiq_installer

	AREA	|fiqhandler$$code|,CODE,READONLY

	;; fiq_installer copys the fiq_handler_code to zero page
	; void fiq_installer(unsigned int buffer address)
fiq_installer
	; need to disable interrupts
	mrs r3, CPSR
	orr r1, r3, #F32_bit+I32_bit
	msr CPSR_c, r1
	bic r1, r1, #M32_bits
	orr r1, r1, #FIQ32_mode
	msr CPSR_c, r1

	mov r2,#&1c

	; now copy data to fiq vector
	str r0,[r2, #data_adr - fiq_handler_code]
	mov r8,r0		; currently in FIQ mode so preset r8 to be data block

	adr r0,fiq_handler_code ;
	adr r1,fiq_handler_init_end

fiq_inst_loop
	ldr r14,[r0],#4		; get instruction from handler code
	str r14,[r2],#4		; store at fiq offset
	cmp r0,r1
	blo fiq_inst_loop

	; set up FIQ registers (for example)

					; // r8=data block, initialised above
;	mov r11,#0			; // r11=flag,  initialise to zero

	mov r12,#0			; // initialise flag
	mov r13,#&f9000000
	add r13,r13,#&009f0000
	add r13,r13,#&00008000



	; restore interrupt flags and mode to previous state
	msr CPSR_c, r3

	; note, this r12 isn't the above r12
	mov r12, r14


	mov r0, #1
	mov r1, #&1c
	; r2 is set up from above
	swi XOS_SynchroniseCodeAreas	; corrupts r14, remember


      [ {CONFIG}=26
	movs pc,r12
      |
        mov pc,r12
      ]


fiq_handler_code

; Set r13 to be APB_BASe
	add  r8,r13,#&00005000      ; gpio_base


; toggle rising/falling edge detection
	ldr r12,flag
	eor r12,r12,#&1
	str r12,flag
	str r12,[r8,#&70]   ; pdesnr

; clear current interrupt request
	mov r9,#1
	str r9,[r8,#&74]    ; pdeclr

	add r8,r13,#&3000   ; timer_base

	ldr r9,[r8,#&24]  ; timer2value

;calculate how much time taken since last interrupt
	rsb r9,r9,#&2000

	orr r9,r9,r12,lsl #16 ; add state change flag to time word
; reset timer to 4000
	mov r10,#&2000
	str r10,[r8,#&20]   ; timer2load
	mov r10,#&c0        ; periodic/enabled/noprescale
	str r10,[r8,#&28]   ; timer2control
; reenable interrupts
	add r8,r13,#&1000
	mov r10,#&20
	str r10,[r8,#&a0]

; store timer value
;	r8 is still set to data block base
	ldr r8,data_adr
	ldmia r8,{r10-r12}         ; r10 = data _start, r11 = data_ptr, r12 = data_max
;
	str r9,[r8,r11]            ; store timer value at data_adr+data_ptr value
;
	add r11,r11,#4              ; increment data_ptr

	cmp r11,r12                 ; test if data_ptr=data_end
	moveq r11,#20               ; reset back to start if true (offset 20 is start)

	cmp r11,r10                 ; test if data_ptr=data_start
	addeq r10,r10,#4            ; increment data_start to reflect new start position

	cmp r10,r12                ; test if data_start=data_end
	moveq r10,#20               ; reset back to start if true


;
;

	stmia r8,{r10-r11}         ; store data_start, data_ptr, data_max to data structure

;finished
	subs pc,r14,#4

flag
	DCD 0
fiq_handler_init_end

data_adr
	DCD 0

fiq_handler_end


	END

