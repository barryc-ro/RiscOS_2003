; > handler.s
; interrupt handlers

	GET     hdr:ListOpts
	GET     hdr:Macros
	GET     hdr:System



	EXPORT fiq_handler_code
	EXPORT fiq_installer

	AREA	|fiqhandler$$code|,CODE,READONLY

	;; fiq_installer copys the fiq_handler_code to zero page
	; void fiq_installer(unsigned int buffer address)
fiq_installer
	; need to disable interrupts
	mrs r3, CPSR
	orr r1, r3, #F32_bit+I32_bit
	msr CPSR_c, r1
	bic r1, r1, #M32_bits
	orr r1, r1, #FIQ32_mode
	msr CPSR_c, r1

	mov r2,#&1c

	; now copy data to fiq vector
	str r0,[r2, #data_adr - fiq_handler_code]
	mov r8,r0		; currently in FIQ mode so preset r8 to be data block

	adr r0,fiq_handler_code ;
	adr r1,fiq_handler_init_end

fiq_inst_loop
	ldr r14,[r0],#4		; get instruction from handler code
	str r14,[r2],#4		; store at fiq offset
	cmp r0,r1
	blo fiq_inst_loop

	; set up FIQ registers (for example)

					; // r8=data block, initialised above
;	mov r11,#0			; // r11=flag,  initialise to zero

	mov r12,#0			; // initialise flag
	mov r13,#&03200000           ; IOMD base


	; restore interrupt flags and mode to previous state
	msr CPSR_c, r3

	; note, this r12 isn't the above r12
	mov r12, r14


	mov r0, #1
	mov r1, #&1c
	; r2 is set up from above
	swi XOS_SynchroniseCodeAreas	; corrupts r14, remember


      [ {CONFIG}=26
	movs pc,r12
      |
        mov pc,r12
      ]


fiq_handler_code
; r13 is preset to IOMD base
; r12 is preset to flag
; r8  is preset to data word

; check it was our interrupt
;	ldr r9,[r8,#&30]            ; FIQST
;	tst r9,#&40                 ; has nINT8 been activated?
;	subeqs pc,r14,#4            ; nope so get out

; toggle edge and led by reading our internal flag, xor bits 4/5
	mov r9,#&89000000           ; podule base

;	r12 is still set to flag

	mov r10,r12,lsr #6	    ; reduce flag down to 1 bit on or off
	eor r12,r12,#&60            ; r12 = flag, toggle bits 4 and 5 for LED and XOR gate
	str r12,[r9]

	str r13,[r13,#&5C]            ; latch timer1, r13 is still IOMD base
	ldrb r9,[r13,#&50]           ; get low bit
	ldrb r11,[r13,#&54]          ; get high bit
	add r9,r9,r11,lsl #8        ; combine low and high bits

;	cmp r9,#&2000
	rsb r9,r9,#&2000            ; calculate how much time taken since last interrupt
;	movgt r9,#&3F00

	orr r9,r9,r10,lsl #16       ; add state change flag to time word

; reset timer to 2000, r13 is still IOMD base
	mov r10,#&00
	str r10,[r13,#&50]           ; low
	mov r10,#&20
	str r10,[r13,#&54]           ; high
	str r10,[r13,#&58]           ; go

; enable irq for timer 1, r13 is still IOMD base
	ldrb r10,[r13,#&18]
	orr r10,r10,#1<<6
	strb r10,[r13,#&18]

; store timer value
;	r8 is still set to data block base
	ldmia r8,{r10-r11}         ; r10 = data _start, r11 = data_ptr, r12 = data_max
;
	str r9,[r8,r11]            ; store timer value at data_adr+data_ptr value
;
	add r11,r11,#4              ; increment data_ptr
	cmp r11,#4096                 ; test if data_ptr=data_end
	moveq r11,#20               ; reset back to start if true (offset 20 is start)
;
	cmp r11,r10                 ; test if data_ptr=data_start
	addeq r10,r10,#4            ; increment data_start to reflect new start position
;
	cmp r10,#4096                 ; test if data_start=data_end
	moveq r10,#20               ; reset back to start if true

	stmia r8,{r10-r11}         ; store data_start, data_ptr, data_max to data structure

;finished
	subs pc,r14,#4

flag
	DCD 0
fiq_handler_init_end

data_adr
	DCD 0

fiq_handler_end


	END

