/*
 * IntHandler.c
 */

/************************************************************************/
/*              Copyright 2001 Pace Micro Technology PLC                */
/************************************************************************/

/*
 * This section deals with the interrupt handlers
 */

#include "targetsys.h"

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "debuglib/debuglib.h"

#include "kernel.h"
#include "swis.h"
#include "module.h"

#include "global/services.h"

#include "header.h"
#include "handler.h"
#include "DevFSIntFc.h"
#include "MsgHandler.h"
#include "IntHandler.h"


int irq_claimed=0,fiq_claimed=0;
int ir_status=SoftIR_Enable;             // Allow interrupts to be started

// hardware dependant section

void fiq_on()
{
  unsigned int *data_ptr, data_word;
  #if SoftIR_System==1
          data_ptr=(unsigned int*)0x03200038;    // fiqmsk
          data_word=*data_ptr & 0xff;
          data_word|=1<<6;                       // toggle nint 8
          *data_ptr=data_word;
  #endif
}

void fiq_off()
{
  unsigned int *data_ptr, data_word;
  #if SoftIR_System==1
          data_ptr=(unsigned int*)0x03200038;    // fiqmsk
          data_word=*data_ptr & 0xff;
          data_word&=~(1<<6);                    // toggle nint 8
          *data_ptr=data_word;
  #endif
}

void irq_on()
{
  unsigned int *data_ptr, data_word;
  #if SoftIR_System==1
          data_ptr=(unsigned int*)0x03200018; // irqmska
          data_word=(*data_ptr) & 0xff;
          data_word|=1<<6; // toggle timer 1 irq line
          *data_ptr=data_word;
  #endif
}

void irq_off()
{
  unsigned int *data_ptr, data_word;
  #if SoftIR_System==1
          data_ptr=(unsigned int*)0x03200018; // irqmska
          data_word=(*data_ptr) & 0xff;       // only get byte not word
          data_word&=~(1<<6);                 // toggle timer 1 irq line
          *data_ptr=data_word;
  #endif
}

_kernel_oserror *irq_timer_disable()
{
  _kernel_oserror *error=NULL;

  #if SoftIR_System==1
    error=_swix(OS_ReleaseDeviceVector,_INR(0,2),6, irq_entry,mod_wsp);
  #endif
  return(error);
}

_kernel_oserror *irq_timer_enable()
{
  _kernel_oserror *error=NULL;

//  #if SoftIR_System==1
    error=_swix(OS_ClaimDeviceVector,_INR(0,2),6, irq_entry,mod_wsp);
//  #endif
  return(error);
}

int test_irq_status()
{
  unsigned int *irq_status;
  int result=0;

  #if SoftIR_System==1
    irq_status = (unsigned int*) 0x03200010;
    result=(*irq_status) & (1<<6);
  #endif

  return(result);
}

int clear_irq_status()
{
  unsigned int *irq_clear;
  int result=0;

  #if SoftIR_System==1
    irq_clear  = (unsigned int*) 0x03200014;  // IRQRQA
    *irq_clear=1<<6;                          // clear bit 6 (timer1)
  #endif

  return(result);
}

// end hardware dependant section

/* Set_Status function
 * This function toggles the ir_status flag.
 * It must be called with either  SoftIR_Enable or SoftIR_Disable
 * If disabled, then all interrupt enabling calls will be ignored.
 */

void IntHandler_Set_Status(int status)
{
  ir_status=status;
}


/* fiq_control function
 * This function either installs or un-installs the fiq handler and
 * enables/disables respectively the timer 1 irq handler.
 *
 * Control parameter   =>  0 installs handler, 1 removes handler
 * service_call param  =>  0 calls service call, 1 bypasses service call
 */

_kernel_oserror * IntHandler_FIQ_Control(int control, int service_call)
{
  _kernel_oserror *error=NULL;
  unsigned int status=0;
  dprintf(("","IntHandler_FIQ_Control %d %d\n",control,service_call));

  // only do something if SoftIR_Enable has been set

  if (ir_status==SoftIR_Enable)
  {

    switch (control)
    {
    case SoftIR_FIQ_Install : //enable
      if (fiq_claimed==0)
      {
        if (service_call==SoftIR_ServiceCall)
          error=_swix(OS_ServiceCall,_IN(1) | _OUT(1), Service_ClaimFIQ, &status);

        if (error==NULL && status==0)
        {
          fiq_claimed=1;
          dprintf(("","Claiming fiq with address %x\n",(unsigned int)cyclic_buffer));
          fiq_installer(cyclic_buffer);
          dprintf(("","fiq installed..."));
          fiq_on();
          dprintf(("","fiq Enabled\n"));

        } // if (error==NULL && status==0)
        else
        {
          dprintf(("","Service_ClaimFIQ failed [%d]\n",status));
        } // if (error==NULL && status==0) else

        // attempt to claim timer1 interrupt
        if (error==NULL)
          error=irq_timer_enable();

        if (error==NULL)
        {
          irq_claimed=1;
          dprintf(("","Claiming irq..."));
          irq_on();
          dprintf(("","irq claimed\n"));
        } // if (error==NULL) for ClaimDeviceVector (irq)
        else
          dprintf(("","Failed to claim IRQ\n"));
      } // if (fiq_claimed==0)
      else
      {
        // fiq already claimed.  Unknown what to do.
      } // if (fiq_claimed==0) else
      break;
    case SoftIR_FIQ_UnInstall : // disable
      if (fiq_claimed==1)
      {
        dprintf(("","Releasing fiq\n"));

        if (service_call==SoftIR_ServiceCall)
          error=_swix(OS_ServiceCall,_IN(1), Service_ReleaseFIQ);

        if (error==NULL)
        {
          dprintf(("","Releasing fiq..."));
          fiq_off();
          dprintf(("","fiq released\n"));

          dprintf(("","Releasing irq..."));
          irq_off();
          dprintf(("","irq released\n"));
        } // if (error==NULL)
        else
          dprintf(("","Service_ReleaseFIQ failed\n"));

        // attempt to release timer1 interrupt
        if (error==NULL)
          error=irq_timer_disable();

        if (error==NULL)
        {
          irq_claimed=0;
          dprintf(("","IRQ Released\n"));
        }
        else
          dprintf(("","Failed to release IRQ\n"));

      } // if (fiq_claimed==1)
      else
      {
        // **** fiq not claimed, what do we do now?

      } // if (fiq_claimed==1) else

      break;

    } // case (control)

  }  // if (ir_status==SoftIR_Enable)



  return (error);
}

/*
 * IntHandler_Get_Status
 *
 * This function returns whether or not SoftIR has claimed IRQ/FIQ
 *
 */

int IntHandler_Get_Status(int test)
{
  int result=0;
  if ((test & SoftIR_FIQ_Test) && fiq_claimed)
    result |= SoftIR_FIQ_Claimed;
  if ((test & SoftIR_IRQ_Test) && irq_claimed)
    result |= SoftIR_IRQ_Claimed;
  return(result);
}

/*
 * Remove_IRQ
 * This function will disable timer1 interrupts and remove our irq handling code from the device vector
 */

_kernel_oserror * IntHandler_Remove_IRQ(void)
{
  _kernel_oserror *error=NULL;
  unsigned int *data_ptr, data_word;

  data_ptr=(unsigned int*)0x0320001;
  data_word=(*data_ptr) & 0xff;
  data_word=data_word & (~(1<<6)); // toggle timer 1 irq line
  *data_ptr=data_word;

  error=_swix(OS_ReleaseDeviceVector,_INR(0,2),6, irq_entry,mod_wsp);
  if (error==NULL)
    irq_claimed=0;
  else
    dprintf(("","Couldn't remove irq.  oh oh!\n"));

  return(error);
}

/* IRQ Handler
 * This is installed for Timer1 interrupts
 * This routine is called when Timer1 wraps around, as we reset timer1 whenever we receive a pulse
 * We should only get an interrupt when we've timed out receiving a message
 */


_kernel_oserror * IntHandler_IRQ_Handler(_kernel_swi_regs *reg, void *pw)
{
  static int lock=0;

  int interrupt_status;

  // ensure that we don't reenter ourselves, Should never happen
  if (lock==0)
  {
    lock=1;

    interrupt_status = _kernel_irqs_disabled();  // Preserve interrupt status
    _kernel_irqs_off();                          // Disable interrupts
    // was it a timer1 interrupt?
    if (test_irq_status())
    {

      clear_irq_status();        // timer 1 interrupt so reset it
      irq_off();                 // Disable timer 1 interrupt

      /* if we have an open rcmm data stream and have a buffer in existance
       * then check the buffer
       */

      if (DevFSIntFc_Get_Status()==SoftIR_DevFS_Claimed && cyclic_buffer!=NULL)
        MsgHandler_Check_Buffer();

    } // if ((*irq_status) & (1<<6))

    if (!interrupt_status) _kernel_irqs_on();    // Enable interrupts if necessary
    lock=0;
  } // if (state==0)
  return NULL;

}
