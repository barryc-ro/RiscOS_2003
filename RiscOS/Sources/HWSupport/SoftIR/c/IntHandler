/*
 * IntHandler.c
 */

/************************************************************************/
/*              Copyright 2001 Pace Micro Technology PLC                */
/************************************************************************/

/*
 * This section deals with the interrupt handlers
 */

#include "targetsys.h"

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "debuglib/debuglib.h"

#include "kernel.h"
#include "swis.h"
#include "module.h"

#include "global/services.h"

#include "header.h"
#include "handler.h"
#include "DevFSIntFc.h"
#include "MsgHandler.h"
#include "IntHandler.h"


int irq_claimed=0,fiq_claimed=0;
int ir_status=SoftIR_Enable;             // Allow interrupts to be started

// hardware dependant section

void fiq_on()
{
  volatile unsigned int *data_ptr, data_word;
  #if SoftIR_System==SoftIR_RPC
          FIQMSK |= (1<<6);
  #endif
  #if SoftIR_System==SoftIR_TViLINK
          // initialise GPIO lines
          data_ptr=(volatile unsigned int*)0xf99fd06c;   // pdeenr
          *data_ptr=1;                           // configure edge triggered events
          data_ptr=(volatile unsigned int*)0xf99fd070;   // pdesnr
          *data_ptr=1;                           // wait for initial falling edge
          data_ptr=(volatile unsigned int*)0xf99fd078;  // pdimr
          *data_ptr=1;                           // enable interrupts for bit 0

          data_ptr=(unsigned int*)0xf99f91a0;    // FIQLEnable
          data_word=1<<21;                       // enable gpioirq
          *data_ptr=data_word;

  #endif
}

void fiq_off()
{
  unsigned int *data_ptr, data_word;
  #if SoftIR_System==SoftIR_RPC
          FIQMSK &=~ (1<<6);
  #endif
  #if SoftIR_System==SoftIR_TViLINK
          data_ptr=(unsigned int*)0xf99f91b0;    // FIQLEnableClear
          data_word=1<<21;                       // disable gpioirq
          *data_ptr=data_word;
  #endif
}

void irq_on()
{
  volatile unsigned int *data_ptr;
  #if SoftIR_System==SoftIR_RPC
          IRQMSKA |= (1<<6);
  #endif
  #if SoftIR_System==SoftIR_TViLINK
          data_ptr=(volatile unsigned int*)0xf99f90a0;    // IRQLEnable
          *data_ptr=1<<5;                                 // set GCTC2IRQ timer 2
  #endif
}

void irq_off()
{
  volatile unsigned int *data_ptr;
  #if SoftIR_System==SoftIR_RPC
          IRQMSKA &=~ (1<<6);
  #endif
  #if SoftIR_System==SoftIR_TViLINK
          data_ptr=(volatile unsigned int*)0xf99f90b0;   // IRQLEnableclear
          *data_ptr=1<<5;                                // clear GCTC2IRQ timer 2
  #endif
}

_kernel_oserror *irq_timer_disable()
{
  _kernel_oserror *error=NULL;

  #if SoftIR_System==SoftIR_RPC
    error=_swix(OS_ReleaseDeviceVector,_INR(0,2),6, irq_entry,mod_wsp);
  #endif
  #if SoftIR_System==SoftIR_TViLINK
    error=_swix(OS_ReleaseDeviceVector,_INR(0,2),5, irq_entry,mod_wsp);
  #endif
  return(error);
}

_kernel_oserror *irq_timer_enable()
{
  _kernel_oserror *error=NULL;

  #if SoftIR_System==SoftIR_RPC
    error=_swix(OS_ClaimDeviceVector,_INR(0,2),6, irq_entry,mod_wsp);
  #endif
  #if SoftIR_System==SoftIR_TViLINK
    error=_swix(OS_ClaimDeviceVector,_INR(0,2),5, irq_entry,mod_wsp);
  #endif
  return(error);
}

/*
 * This function tests if it is our timer interrupt
 * It returns 0 if it is otherwise it returns a positive number
 */
int test_irq_status()
{
  unsigned int *irq_status;
  int result=0;

  #if SoftIR_System==SoftIR_RPC
    irq_status = (unsigned int*) 0x03200010;
    result=(*irq_status) & (1<<6);
  #endif
  #if SoftIR_System==SoftIR_TViLINK
    irq_status = (unsigned int*) 0xf99f9080;  // IRQLStatus
    result=(*irq_status) & (1<<5);            // test for TIMER2
  #endif

  return(result);
}
/*
 * This function clears the timer interrupt flag
 */

void clear_irq_status()
{
  volatile unsigned int *irq_clear;

  #if SoftIR_System==SoftIR_RPC
    irq_clear  = (volatile unsigned int*) 0x03200014;  // IRQRQA
    *irq_clear=1<<6;                                   // clear bit 6 (timer1)
  #endif
  #if SoftIR_System==SoftIR_TViLINK
    irq_clear = (volatile unsigned int*) 0xf99fb02c;   // Timer2Clear
    *irq_clear=0xff;                                   // reset timer2 interrupt
  #endif

}

// end hardware dependant section

/* Set_Status function
 * This function toggles the ir_status flag.
 * It must be called with either  SoftIR_Enable or SoftIR_Disable
 * If disabled, then all interrupt enabling calls will be ignored.
 */

void IntHandler_Set_Status(int status)
{
  ir_status=status;
}


/* fiq_control function
 * This function either installs or un-installs the fiq handler and
 * enables/disables respectively the timer 1 irq handler.
 *
 * Control parameter   =>  0 installs handler, 1 removes handler
 * service_call param  =>  0 calls service call, 1 bypasses service call
 */

_kernel_oserror * IntHandler_FIQ_Control(int control, int service_call)
{
  _kernel_oserror *error=NULL;
  unsigned int status=0;
  dprintf(("","IntHandler_FIQ_Control %d %d\n",control,service_call));

  // only do something if SoftIR_Enable has been set

  if (ir_status==SoftIR_Enable)
  {

    switch (control)
    {
    case SoftIR_FIQ_Install : //enable
      if (fiq_claimed==0)
      {
        if (service_call==SoftIR_ServiceCall)
          error=_swix(OS_ServiceCall,_IN(1) | _OUT(1), Service_ClaimFIQ, &status);

        if (error==NULL && status==0)
        {
          fiq_claimed=1;
          dprintf(("","Claiming fiq with address %x\n",(unsigned int)cyclic_buffer));
          fiq_installer(cyclic_buffer);
          dprintf(("","fiq installed..."));
          fiq_on();
          dprintf(("","fiq Enabled\n"));

        } // if (error==NULL && status==0)
        else
        {
          dprintf(("","Service_ClaimFIQ failed [%d]\n",status));
        } // if (error==NULL && status==0) else

        // attempt to claim timer1 interrupt
        if (error==NULL)
          error=irq_timer_enable();

        if (error==NULL)
        {
          irq_claimed=1;
          dprintf(("","Claiming irq..."));
          irq_on();
          dprintf(("","irq claimed\n"));
        } // if (error==NULL) for ClaimDeviceVector (irq)
        else
          dprintf(("","Failed to claim IRQ\n"));
      } // if (fiq_claimed==0)
      else
      {
        // fiq already claimed.  Unknown what to do.
      } // if (fiq_claimed==0) else
      break;
    case SoftIR_FIQ_UnInstall : // disable
      if (fiq_claimed==1)
      {
        dprintf(("","Releasing fiq..."));
        fiq_off();
        dprintf(("","fiq released\n"));
        fiq_claimed=0;

        dprintf(("","Releasing irq..."));
        irq_off();
        dprintf(("","irq released\n"));

        if (service_call==SoftIR_ServiceCall)
          error=_swix(OS_ServiceCall,_IN(1), Service_ReleaseFIQ);

        // attempt to release timer1 interrupt
        if (error==NULL)
          error=irq_timer_disable();

        if (error==NULL)
        {
          irq_claimed=0;
          dprintf(("","IRQ Released\n"));
        }
        else
          dprintf(("","Failed to release IRQ\n"));

      } // if (fiq_claimed==1)
      else
      {
        // **** fiq not claimed, what do we do now?

      } // if (fiq_claimed==1) else

      break;

    } // case (control)

  }  // if (ir_status==SoftIR_Enable)



  return (error);
}

/*
 * IntHandler_Get_Status
 *
 * This function returns whether or not SoftIR has claimed IRQ/FIQ
 *
 */

int IntHandler_Get_Status(int test)
{
  int result=0;
  if ((test & SoftIR_FIQ_Test) && fiq_claimed)
    result |= SoftIR_FIQ_Claimed;
  if ((test & SoftIR_IRQ_Test) && irq_claimed)
    result |= SoftIR_IRQ_Claimed;
  return(result);
}

/*
 * Remove_IRQ
 * This function will disable timer1 interrupts and remove our irq handling code from the device vector
 */

_kernel_oserror * IntHandler_Remove_IRQ(void)
{
  _kernel_oserror *error=NULL;
  unsigned int *data_ptr, data_word;

  data_ptr=(unsigned int*)0x0320001;
  data_word=(*data_ptr) & 0xff;
  data_word=data_word & (~(1<<6)); // toggle timer 1 irq line
  *data_ptr=data_word;

  error=_swix(OS_ReleaseDeviceVector,_INR(0,2),6, irq_entry,mod_wsp);
  if (error==NULL)
    irq_claimed=0;
  else
    dprintf(("","Couldn't remove irq.  oh oh!\n"));

  return(error);
}

/* IRQ Handler
 * This is installed for Timer1 interrupts
 * This routine is called when Timer1 wraps around, as we reset timer1 whenever we receive a pulse
 * We should only get an interrupt when we've timed out receiving a message
 */


_kernel_oserror * IntHandler_IRQ_Handler(_kernel_swi_regs *reg, void *pw)
{
  static int lock=0;

  int interrupt_status;
//  int data_word;

  // ensure that we don't reenter ourselves, Should never happen
  if (lock==0)
  {
    lock=1;

    interrupt_status = _kernel_irqs_disabled();  // Preserve interrupt status
    _kernel_irqs_off();                          // Disable interrupts
    // was it a timer1 interrupt?
//    if (test_irq_status())
//    {

      irq_off();                 // Disable timer 1 interrupt
      clear_irq_status();        // timer 1 interrupt so reset it

      /* if we have an open rcmm data stream and have a buffer in existance
       * then check the buffer
       */


      if (DevFSIntFc_Get_Status()==SoftIR_DevFS_Claimed && cyclic_buffer!=NULL)
        _swix(OS_AddCallBack,_INR(0,1),message_entry,pw);


//    } // if ((*irq_status) & (1<<6))

    if (!interrupt_status) _kernel_irqs_on();    // Enable interrupts if necessary
    lock=0;
  } // if (state==0)

  return NULL;

}

_kernel_oserror * message_handler(_kernel_swi_regs *reg, void *pw)
{
  MsgHandler_Check_Buffer();
  return NULL;
}
