;
; 		Copyright 1996 Acorn Network Computing
;
;  This material is the confidential trade secret and proprietary
;  information of Acorn Network Computing. It may not be reproduced,
;  used, sold, or transferred to any third party without the prior
;  written consent of Acorn Network Computing. All rights reserved.
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Description of the implemementation.
;
;   This code has been based on Serial driver 0.15 as included in the NCOS build
;

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; module workspace
                        ^ 0, wp
Flags			# 4
BuffManWkSpace          # 4	; buffer manager workspace
BuffManService          # 4     ; address of buffer manager routine
MessagesWorkspace       # 16    ; needed for messages routines
DeviceFSBlock		# 4	; address of devicefs registration block
DeviceHandle		# 4	; handle returned from DeviceFS_Register
InputStream		# 4	; devicefs stream handle
OutputStream		# 4	; devicefs stream handle
InputFSHandle		# 4     ; file switch handle of input stream
OutputFSHandle		# 4     ; file switch handle of output stream
 [ debug
InputBuffer		# 4	; buffer manager handle
OutputBuffer		# 4	; buffer manager handle
 ]
InputBufferPrivId      	# 4	; buffer managers private buffer id
OutputBufferPrivId	# 4	; buffer managers private buffer id
InputBufferSize		# 4	; buffer size in bytes
OutputBufferSize	# 4	;
InputBufferThreshold	# 4	; buffer threshold point in bytes
OutputBufferThreshold	# 4	;
BaseAddress		# 4	; base address of register set
InterruptAddress	# 4	; interrupt address
BaudRate		# 4	; ports programmed baud rate
DataFormat		# 4	; ports programmed data format
FifoControlRegister	# 1	; soft copy of fifo control register
Dummy			# 3
ControlLines		# 1
TxByteCount		# 1
FifoTrigger		# 1
Podule			# 1
 [ counting
ByteCount		# 4
ErrorCount		# 4
OverrunCount		# 4
ParityCount		# 4
FramingCount		# 4
InterruptCount		# 4
BufferOverrun		# 4
 ]
workspace               * :INDEX: @

;
; bit definitions for Flags
;
flag_OwnIRQ             * 1:SHL:0  	; irq owned for device
flag_HaveMessages	* 1:SHL:1  	; opened messages file
flag_FifosPresent	* 1:SHL:2	; we have fifos
flag_UseRTS		* 1:SHL:3	; rts/cts handshaking
flag_UseXon		* 1:SHL:4	; xon/off handshaking
flag_UseDTR		* 1:SHL:5	; dtr/dsr handshaking
flag_TxDormant		* 1:SHL:6	; no more characters tx
flag_RxThresholded	* 1:SHL:7	; rx buffer thresholded
flag_TxXon		* 1:SHL:8	; need to send xon char
flag_TxXoff		* 1:SHL:9	; need to send xoff char
flag_TxXoffed		* 1:SHL:10	; we have been xoffed
flag_Registered		* 1:SHL:11	; registered with devicefs
flag_HugeFifos		* 1:SHL:12	; 16C750 huge fifos present
flag_SlowMode		* 1:SHL:13	; run in 16C550 mode
;
; bit definitions for ControlLines
;
ctrl_line_dtr			* 1:SHL:0
ctrl_line_rts			* 1:SHL:1
ctrl_line_cts			* 1:SHL:2
ctrl_line_dsr			* 1:SHL:3
ctrl_line_ri			* 1:SHL:4
ctrl_line_dcd			* 1:SHL:5

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; standard module declarations

module          & 0
                & init    -module               ; => initalise routine
                & final   -module               ; => finalise routine
                & service -module               ; => service trap

                & title -module                 ; => title string
                & help  -module                 ; => help string
                & command_table-module		; => command table

                & 0

title           = "Modem", 0

 [ debug
help            = "Modem", 9, "$VString ($Date) (Debug on)", 0
 |
help            = "Modem", 9, "$VString ($Date)", 0
 ]

command_table   = "ModemInfo", 0
		ALIGN
		DCD	serial_command -module
		DCD	0
		DCD	serial_syntax -module
		DCD	serial_help   -module
		&	0

serial_help    = "*ModemInfo displays internal statistics", 13
serial_syntax  = "Syntax: *ModemlInfo", 0
		ALIGN

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; debug options
 [ debug
Host_Debug  	SETL 	False
HostDebugViaTML	SETL 	False
Debug_Module	SETL	False
;Debug_File      SETS	"$.Debug"
 ]
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; DeviceFS declarations
device_name3     = "modem", 0
                ALIGN

device_block3    & device_name3 - device_block3
                & DeviceFlag_BufferedDevice + DeviceFlag_DefinePathVariable
                & 8                             ; default RX buffer flags
                & 1024                          ; default RX buffer size
                & 8                             ; default TX buffer flags
                & 512                           ; default TX buffer size
                & 0                             ; reserved field (must be zero)

                & 0                             ; end of table

                ALIGN

device_validation = "baud/ndata/nstop/nnoparity,even,odd/snohandshake,rts,xon,dtr/ssize/nthres/n",0
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Globals
serial_expansion_slot   = "  Expansion slot : ",0
serial_baud_rate	= "  Baud (bps)     : ",0
serial_data_format	= "  Data format    : ",0
serial_handshake	= "  Handshake      : ",0
serial_handshake_rts	= "rts/cts",0
serial_handshake_dtr    = "rtr/dsr",0
serial_handshake_xon    = "xon/xoff",0
serial_handshake_none   = "none",0
 [ debug
serial_flags		= "  Flags           : 0x",0
serial_control_line	= "  Control lines   : 0x",0
serial_base_address	= "  Base address    : 0x",0
serial_workspace	= "  Workspace       : 0x",0
serial_input_buffer	= "  IP buffer       : ",0
serial_ip_buffer_size   = "  IP buffer size  : ",0
serial_ip_buffer_thres  = "  IP buffer thres : ",0
serial_output_buffer	= "  OP buffer       : ",0
serial_op_buffer_size   = "  OP buffer size  : ",0
serial_op_buffer_thres  = "  OP buffer thres : ",0
serial_fifo_present     = "  Fifos present",0
serial_huge_fifo	= "  Huge fifos present",0
serial_fifo_not_present = "  Fifos not present",0
 [ counting
serial_byte_count	= "  Byte count      : ",0
serial_error_count      = "  Error count     : ",0
serial_overrrun_count	= "  Overrun count   : ",0
serial_framing_count    = "  Framing count   : ",0
serial_interrupt_count  = "  Interrupt count : ",0
serial_buffer_overrun   = "  Buffer Overrun  : ",0
serial_parity_count	= "  Parity count    : ",0
 ]
 ]
resource_file = "Resources:$.Resources.Modem.Messages", 0

default_baud		* 9600
default_data   		* 8
default_stop   		* 1
default_parity 		* 0
default_threshold 	* 32
default_fifo_trigger	* 4

podule_interrupt_mask	* 1:SHL:0

easi_space_base		* &88000000

xonchar  * &11
xoffchar * &13

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Error declarations
	MakeErrorBlock Serial_InvalidCard
	MakeErrorBlock Serial_NotPresent

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

cmd_line_slow = "-slow",0
cmd_line_card = "-card",0

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This code handles the startup of the module, the routine must claim the
; required workspace and then initialise the driver.
;
init            ENTRY	"r0-r11"

                LDR     r2, [r12]		; r2 = &wp
                TEQ     r2, #0                  ; any workspace / warm start?
                BNE     %10

                MOV     r0, #ModHandReason_Claim
                LDR     r3, =workspace          ; r3  = amount of workspace

                SWI     XOS_Module
                EXIT    VS                      ; return if didn't work

                STR     r2, [wp]		; wp = r2
10
                MOV     wp, r2                  ; wp -> workspace

 [ standalonemessages
                ADRL    r0, resource_file_block
                SWI     XResourceFS_RegisterFiles
 ]

; clear workspace
                MOV     r0, #0
                STR     r0, Flags
                STR     r0, BuffManService
                STR     r0, BuffManWkSpace
		STR	r0, DeviceHandle
		STR	r0, InputStream
		STR	r0, OutputStream
		STR	r0, InputFSHandle
		STR	r0, OutputFSHandle
		STR	r0, DeviceFSBlock
 [ debug
		STR	r0, InputBuffer
		STR	r0, OutputBuffer
 [ counting
		STR	r0, ByteCount
		STR	r0, ErrorCount
		STR	r0, OverrunCount
		STR	r0, ParityCount
		STR	r0, FramingCount
		STR	r0, InterruptCount
		STR	r0, BufferOverrun
 ]
 ]
		STR	r0, BaudRate
		STR	r0, DataFormat
		STR	r0, InputBufferSize
		STR	r0, OutputBufferSize
		STR	r0, OutputBufferThreshold
		STRB	r0, ControlLines
		STRB	r0, TxByteCount
		STRB	r0, FifoTrigger
		STRB	r0, Podule

; invalidate buffer handles
		MOV	r0, #-1
		STR	r0, InputBufferPrivId
		STR	r0, OutputBufferPrivId

		MOV	r0, #default_threshold
		STR	r0, InputBufferThreshold

 [ debug
		SetColour off
 ]

; now handle command line arguments
		ADR	r9, cmd_line_card		; -card <number>
		BL	find_number
		CMP	r0, #-1
		MOVEQ	r0, #Modem_DefaultPodule
		STRB	r0, Podule

		ADR	r9, cmd_line_slow		; -slow
		BL	find_switch
		LDR	r1, Flags
		CMP	r0, #0
		ORRNE	r1, r1, #flag_SlowMode
		STRNE	r1, Flags

; check against maximum podule number
		SWI	XPodule_ReturnNumber
		LDRB	r3, Podule
		CMP	r3, r0
		BLE	%20

; generate an error
		ADR	r0, ErrorBlock_Serial_InvalidCard
		BL	make_error
                STR     r0, [sp]
		B	%40
20

; calculate uart and interrupt base addresses from podule number
		LDR	r0, =easi_space_base
		ADD	r0, r0, r3, LSL #24
		LDR	r1, =Modem_RegisterSetOffset
		ADD	r1, r0, r1
		STR	r1, BaseAddress
		LDR	r1, =Modem_InterruptStatusOffset
		ADD	r1, r0, r1
		STR	r1, InterruptAddress

; check to see if the devices are present
		LDR	r10, BaseAddress
		BL	hardware_probe
		CMP	r10, #0
		BNE	%30

; generate an error
		ADR	r0, ErrorBlock_Serial_NotPresent
		BL	make_error
                STR     r0, [sp]
		B	%40

30
; now set device up
		ADRL	r9, device_block3
		STR	r9, DeviceFSBlock
		BL	register_device
                STRVS   r0, [sp]
		BVS	%40

		BL	hardware_initialise
                STRVS   r0, [sp]
		BVS	%40

; claim the device vector
		BL 	hardware_claim
35

                EXIT

; free workspace up before exit
40
 [ standalonemessages
                ADRL    r0, resource_file_block
                SWI     XResourceFS_DeregisterFiles
 ]
                PullEnv
                ORRS  	pc, lr, #VFlag

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		LTORG
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle module close down.
;
	MakeErrorBlock Serial_StreamInUse

final           ENTRY	"r0-r1,r11"

                LDR     wp, [r12]               ; wp -> workspace
; see if any streams are in use
		LDR	r0, InputStream
		CMP	r0, #0
		LDREQ	r0, OutputStream
		CMPEQ	r0, #0

		BEQ	%10
; generate an error
		PullEnv
		ADR	r0, ErrorBlock_Serial_StreamInUse
		B	make_error
10
		BL	hardware_release

; sort the hardware out
		BL	hardware_remove		; release any owned IRQs
		BL	unregister_device

 [ standalonemessages
                ADRL    R0, resource_file_block
                SWI     XResourceFS_DeregisterFiles
 ]
                EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Handle service calls received by the module.
;
; Quickly test to see if they are of interest to use and pass on.

service         ROUT
                TEQ     r1, #Service_DeviceFSStarting
                TEQNE   r1, #Service_DeviceFSDying
 [ standalonemessages
                TEQNE   r1, #Service_ResourceFSStarting
 ]
                MOVNES  pc, lr

                LDR     wp, [r12]

; handle devicefs starting up
                TEQ     r1, #Service_DeviceFSStarting
		BNE	%10

		Push	"r1,r11,lr"
                BLNE	register_device
		Pull	"r1,r11,pc",,^
10
; handle devicefs going down
                TEQ     r1, #Service_DeviceFSDying
		BNE	%20

		Push	"r1,r11"
                STRNE   r0, DeviceHandle
		Pull	"r1,r11"
		MOVS	pc, lr
20
 [ standalonemessages
                TEQ     r1, #Service_ResourceFSStarting
                BNE     %FT30					; no so continue
                Push    "r0-r3,lr"
                ADRL    r0, resource_file_block
                MOV     lr, pc
                MOV     pc, r2
                Pull    "r0-r3,pc",,^				; and exit
30
 ]
                MOVS  	pc, lr

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; find_number
;
; returns number following tag if any, or 0 for nothing
;
; in:  r10 	-> string, ctrl terminated
;      r9	-> tag to search for
; out: r0	number associated with tag, -1 for not present
;
find_number	ENTRY "r1-r2,r10"

		MOV	r1, #0			; start of tag
10
		LDRB	r2, [r9, r1]		; load tag char
		CMP	r2, #32			; are we at the end of tag ?
		BLT	%30

		LDRB	r0, [r10]		; load cmd line char
		CMP	r0, #32			; are we at the end ?
		BLT	%20

		CMP	r0, r2			; compare chars
		ADDEQ	r1, r1, #1		; next tag char
		ADD	r10, r10, #1		; next char
		B	%10

20
; tag not found
		MOV	r0, #0
		EXITS
30
		MOV	r0, #10
		ORR	r0, r0, #1:SHL:30
		MOV	r1, r10
		SWI	XOS_ReadUnsigned
		MOVVS	r0, #0
		MOVVC	r0, r2

		EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; find_switch
;
; return 1 for present, 0 for not present
;
; in:  r10 	-> string, ctrl terminated
;      r9	-> tag to search for
; out: r0	number associated with tag, -1 for not present
;
find_switch	ENTRY "r1-r2,r10"

		MOV	r1, #0			; start of tag
10
		LDRB	r2, [r9, r1]		; load tag char
		CMP	r2, #32			; are we at the end of tag ?
		BLT	%30

		LDRB	r0, [r10]		; load cmd line char
		CMP	r0, #32			; are we at the end ?
		BLT	%20

		CMP	r0, r2			; compare chars
		ADDEQ	r1, r1, #1		; next tag char
		ADD	r10, r10, #1		; next char
		B	%10

20
; tag not found
		MOV	r0, #0
		EXITS
30
; tag found
		MOV	r0, #1
		EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; register device
;
register_device ENTRY "r0-r7"

; have we already been registered
		LDR	r0, Flags
		TST	r0, #flag_Registered
		EXITS	NE

                MOV     r0, #ParentFlag_FullDuplex :OR: ParentFlag_DeviceUpcalls
		LDR	r1, DeviceFSBlock
                ADDR    r2, handle_device_call    	; -> handler
                MOV     r3, #0				; passed in as r8
                MOV     r4, wp                         	; -> workspace
                ADDR    r5, device_validation           ; vaidation
                MOV     r6, #1				; max RX stream
                MOV     r7, #1                          ; max TX stream
                SWI     XDeviceFS_Register
                STRVS   r0, [sp]
                EXIT    VS
		STR	r0, DeviceHandle

; show we are registered
		LDR	r0, Flags
		ORR	r0, r0, #flag_Registered
		STR	r0, Flags

		EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; unregister device
;
unregister_device ENTRY "r0"

; have we been registered
		LDR	r0, Flags
		TST	r0, #flag_Registered
		EXITS	EQ

                LDR     r0, DeviceHandle
                CMP     r0, #0
                EXITS	EQ
                SWI     XDeviceFS_Deregister
                MOV     r0, #0
                STR     r0, DeviceHandle

; show we are unregistered
		LDR	r0, Flags
		BIC	r0, r0, #flag_Registered
		STR	r0, Flags

		EXITS
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; handle the command *SerialInfo
;
serial_command ENTRY "r0-r3"

                LDR     wp, [r12]   		; wp -> workspace

; write the port name
		ADRL	r0, device_name3
		SWI	XOS_Write0
		SWI	XOS_NewLine
; podule number
		ADRL	r0, serial_expansion_slot
		SWI	XOS_Write0
		LDRB	r0, Podule
		BL	show_integer
		SWI	XOS_NewLine
; baud rate
		ADRL	r0, serial_baud_rate
		SWI	XOS_Write0
		LDR	r0, BaudRate
		BL	show_integer
		SWI	XOS_NewLine
; data format
		ADRL	r0, serial_data_format
		SWI	XOS_Write0
;   data length
		LDR	r1, DataFormat
		AND	r0, r1, #&ff
		BL	show_integer
		MOV	r0, #"."
		SWI	XOS_WriteC
;   start bits
		MOV	r0, r1, LSR #8
		AND	r0, r0, #&ff
		BL	show_integer
		MOV	r0, #"."
		SWI	XOS_WriteC
;   parity
		MOV	r1, r1, LSR #16
		AND	r1, r1, #&ff
		CMP	r1, #0
		MOVEQ	r0, #"n"
		CMP	r1, #1
		MOVEQ	r0, #"e"
		CMP	r1, #2
		MOVEQ	r0, #"o"
		SWI	XOS_WriteC
		SWI	XOS_NewLine

; handshaking
		ADRL	r0, serial_handshake
		SWI	XOS_Write0
		LDR	r1, Flags
		ADRL	r0, serial_handshake_none	; default
		TST	r1, #flag_UseRTS
		ADRNEL	r0, serial_handshake_rts
		TST	r1, #flag_UseXon
		ADRNEL	r0, serial_handshake_xon
		TST	r1, #flag_UseDTR
		ADRNEL	r0, serial_handshake_dtr
		SWI	XOS_Write0
		SWI	XOS_NewLine
 [ debug
; base address
		ADRL	r0, serial_base_address
		SWI	XOS_Write0
		LDR	r0, BaseAddress
		BL	show_hex8
		SWI	XOS_NewLine
; flags
		ADRL	r0, serial_flags
		SWI	XOS_Write0
		LDR	r0, Flags
		BL	show_hex4
		SWI	XOS_NewLine
; control line
		BL	hardware_ctrl_lines
		ADRL	r0, serial_control_line
		SWI	XOS_Write0
		LDRB	r0, ControlLines
		BL	show_hex4
		SWI	XOS_NewLine
; input buffer
		ADRL	r0, serial_input_buffer
		SWI	XOS_Write0
		LDR	r0, InputBuffer
		BL	show_integer
		SWI	XOS_NewLine
; buffer size
		ADRL	r0, serial_ip_buffer_size
		SWI	XOS_Write0
		LDR	r0, InputBufferSize
		BL	show_integer
		SWI	XOS_NewLine
; buffer threshold
		ADRL	r0, serial_ip_buffer_thres
		SWI	XOS_Write0
		LDR	r0, InputBufferThreshold
		BL	show_integer
		SWI	XOS_NewLine
; output buffer
		ADRL	r0, serial_output_buffer
		SWI	XOS_Write0
		LDR	r0, OutputBuffer
		BL	show_integer
		SWI	XOS_NewLine
; buffer size
		ADRL	r0, serial_op_buffer_size
		SWI	XOS_Write0
		LDR	r0, OutputBufferSize
		BL	show_integer
		SWI	XOS_NewLine
; buffer threshold
		ADRL	r0, serial_op_buffer_thres
		SWI	XOS_Write0
		LDR	r0, OutputBufferThreshold
		BL	show_integer
		SWI	XOS_NewLine
; FIFOs present
		LDR	r0, Flags
		TST	r0, #flag_HugeFifos
		ADRNEL	r0, serial_huge_fifo
		BNE	%10
		TST	r0, #flag_FifosPresent
		ADRNEL	r0, serial_fifo_present
		ADREQL	r0, serial_fifo_not_present
10
		SWI	XOS_Write0
		SWI	XOS_NewLine
 [ counting
; error count
		ADRL	r0, serial_error_count
		SWI	XOS_Write0
		LDR	r0, ErrorCount
		BL	show_integer
		SWI	XOS_NewLine
 ; byte count
		ADRL	r0, serial_byte_count
		SWI	XOS_Write0
		LDR	r0, ByteCount
		BL	show_integer
		SWI	XOS_NewLine
; overrun count
		ADRL	r0, serial_overrrun_count
		SWI	XOS_Write0
		LDR	r0, OverrunCount
		BL	show_integer
		SWI	XOS_NewLine
; framing count
		ADRL	r0, serial_framing_count
		SWI	XOS_Write0
		LDR	r0, FramingCount
		BL	show_integer
		SWI	XOS_NewLine
; parity count
		ADRL	r0, serial_parity_count
		SWI	XOS_Write0
		LDR	r0, ParityCount
		BL	show_integer
		SWI	XOS_NewLine
; interrupt count
		ADRL	r0, serial_interrupt_count
		SWI	XOS_Write0
		LDR	r0, InterruptCount
		BL	show_integer
		SWI	XOS_NewLine
; buffer overrun
		ADRL	r0, serial_buffer_overrun
		SWI	XOS_Write0
		LDR	r0, BufferOverrun
		BL	show_integer
		SWI	XOS_NewLine
 ]
 ]
		EXITS

;
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Writes an integer to the screen.
;
; in:
;    r0 - value to be displayed

show_integer	ENTRY "r1-r2"
        	SUB     r13, r13, #16
        	MOV     r1, r13
        	MOV     r2, #16
        	SWI     XOS_ConvertInteger4
        	SWIVC	OS_Write0
        	ADD     r13, r13, #16
        	EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Routine to write a hex number to the screen
; in:
;    r0 - value to be displayed
 [ debug
show_hex8
        	Push    "r1-r2, lr"
        	SUB     r13, r13, #16
        	MOV     r1, r13
        	MOV     r2, #16
        	SWI     XOS_ConvertHex8
        	SWIVC	OS_Write0
        	ADD     r13, r13, #16
        	Pull    "r1-r2, pc",,^
show_hex4
        	Push    "r1-r2, lr"
        	SUB     r13, r13, #16
        	MOV     r1, r13
        	MOV     r2, #16
        	SWI     XOS_ConvertHex4
        	SWIVC	OS_Write0
        	ADD     r13, r13, #16
        	Pull    "r1-r2, pc",,^
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generalised internationalisation routines, these ensure that messages files
; are correctly opened and then return the relevant data.
;
; Attempt to open the messages file.

open_messages   ENTRY   "r0-r3"
                LDRB    r3, Flags
                TST     r3, #flag_HaveMessages
                EXITS   NE

                ADR     r0, MessagesWorkspace
                ADRL    r1, resource_file     ; -> path to be opened
                MOV     r2, #0                ; allocate some wacky space in RMA
                SWI     XMessageTrans_OpenFile
                LDRVCB  r3, Flags
                ORRVC   r3, r3, #flag_HaveMessages
                STRVCB  r3, Flags
                EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Attempt to close the messages file.

close_messages  ENTRY   "r0"
                LDRB    r0, Flags
                TST     r0, #flag_HaveMessages
                EXITS   EQ

                ADR     r0, MessagesWorkspace
                SWI     XMessageTrans_CloseFile
                LDRVCB  r0, Flags
                BICVC   r0, r0, #flag_HaveMessages
                STRVCB  r0, Flags
                EXITS

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generate an error based on the error token given.  Does not assume that
; the messages file is open.  Will attempt to open it, then look it up.
; if make_error_with_name is called, the module name is substituted in r4

make_error_with_name ENTRY "r1-r7"
		ADRL	r4, title
		B	make_error_entry

make_error      ENTRY "r1-r7"
                MOV     r4, #0
make_error_entry
                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                BLEQ    open_messages

                LDRB    r1, Flags
                TST     r1, #flag_HaveMessages
                PullEnv EQ
                ORREQS  pc, lr, #VFlag

                ADR     r1, MessagesWorkspace
                MOV     r2, #0
                MOV     r3, #0
                MOV     r5, #0
                MOV     r6, #0
                MOV     r7, #0
                SWI     XMessageTrans_ErrorLookup
                BL      close_messages

                EXIT                           ; return, r0 -> block, V set

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; This bit of appartently harmless code will bind a messages file into the code
; in the case of a standalone module. The macro ResourceFile will create the
; stuff and the label resource_file is used to point to the block required by
; ResourceFS

 [ standalonemessages
resource_file_block
	ResourceFile Resources.<Locale>.Messages, Resources.Modem.Messages
	DCD     0
 ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		END
