/*************************************************************************
Copyright [2000] Pace Micro Technology PLC. All rights reserved.

The copyright in this material is owned by Pace Micro Technology PLC
("Pace"). This material is regarded as highly confidential trade secret
of Pace. It may not be reproduced, used, sold or in any other way exploited
or transferred to any third party without the prior written permission of
Pace.
*************************************************************************/


#include <stdbool.h>

#include "swis.h"
#include "display.h"
#include "touchscr.h"


display::display()
{
     display_dimensions();  // ask RISC OS for the display size

     // because calibration application is not yet up and running...

     TOUCH_SCREEN_POSITION p;

#ifdef TEST

     p.x = 512, p.y = 512;
     set_centre(p);

     p.x = 512, p.y = 0;
     set_bottom_centre(p);

     p.x = 512, p.y = 1024;
     set_top_centre(p);

     p.x = 0, p.y = 512;
     set_left_centre(p);

     p.x = 1024, p.y = 512;
     set_right_centre(p);

#else
     /* Yum - matches my screen, anyway */
     p.x = 0x76600000; p.y = 0x79600000;
     set_centre(p);

     p.x = 0x77600000; p.y = 0xD6300000;
     set_bottom_centre(p);

     p.x = 0x77A00000; p.y = 0x1BC00000;
     set_top_centre(p);

     p.x = 0xD8200000; p.y = 0x79200000;
     set_left_centre(p);

     p.x = 0x18400000; p.y = 0x78600000;
     set_right_centre(p);
#endif


};


void display::set_centre(TOUCH_SCREEN_POSITION centre)
{
     centre_pos = centre;
}


void display::set_bottom_centre(TOUCH_SCREEN_POSITION bottom_centre)
{
     bottom_centre_pos = bottom_centre;
}


void display::set_top_centre(TOUCH_SCREEN_POSITION top_centre)
{
     top_centre_pos = top_centre;
}


void display::set_left_centre(TOUCH_SCREEN_POSITION left_centre)
{
     left_centre_pos = left_centre;
}


void display::set_right_centre(TOUCH_SCREEN_POSITION right_centre)
{
     right_centre_pos = right_centre;
}


void display::display_dimensions(void)
{
  struct sizereq { int xsize, ysize, xeig, yeig, terminator; };
  static const sizereq in = { 11,12,4,5,-1 };
  sizereq out;

  _swix(OS_ReadVduVariables, _INR(0,1), &in, &out);

  display_size_x = (out.xsize+1) << out.xeig;
  display_size_y = (out.ysize+1) << out.yeig;
}



// all corrections touch screen mis-alignments will be made here
DISPLAY_POSITION display::translate_position(TOUCH_SCREEN_POSITION in)
{
       DISPLAY_POSITION translated;
       int x_range, y_range;

       x_range = (right_centre_pos.x >> 16) - (left_centre_pos.x >> 16);
       y_range = (top_centre_pos.y >> 16) - (bottom_centre_pos.y >> 16);

       // we can get away with this because a) the RISC OS VDU
       // driver system only supports 16-bit co-ordinates, so the
       // display must be < 65536 wide, and b) the HAL is required
       // to scale its ADC sample to the full 32 bits.

       translated.x = (in.x >> 16) - (left_centre_pos.x >> 16);
       translated.y = (in.y >> 16) - (bottom_centre_pos.y >> 16);

       translated.x = translated.x * display_size_x / x_range;
       translated.y = translated.y * display_size_y / y_range;

       return translated;
}





