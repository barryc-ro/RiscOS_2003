/*************************************************************************
Copyright [2000] Pace Micro Technology PLC. All rights reserved.

The copyright in this material is owned by Pace Micro Technology PLC
("Pace"). This material is regarded as highly confidential trade secret
of Pace. It may not be reproduced, used, sold or in any other way exploited
or transferred to any third party without the prior written permission of
Pace.
*************************************************************************/

#include <stdbool.h>
#include "sensor.h"
#include "Global/HALEntries.h"
#include "swis.h"



// ideally this array would be private to the pressure sensor class.
// made global to avoid initialisation problems.
// all mulpliers here have been multiplied by 1000 to avoid the use
// of floating point variables.
static unsigned int calibration_multipliers[10][10] =
{
         { 1000,1000,1000,1000,1000,1000,1000,1000,1000,1000 },
         { 1000,1000,1000,1000,1000,1000,1000,1000,1000,1000 },
         { 1000,1000,700, 700, 700, 700, 700, 700, 1000,1000 },
         { 1000,1000,700, 600, 600, 600, 600, 700, 1000,1000 },
         { 1000,1000,700, 600, 500, 500, 600, 700, 1000,1000 },
         { 1000,1000,700, 600, 500, 500, 600, 700, 1000,1000 },
         { 1000,1000,700, 600, 600, 600, 600, 700, 1000,1000 },
         { 1000,1000,700, 700, 700, 700, 700, 700, 1000,1000 },
         { 1000,1000,1000,1000,1000,1000,1000,1000,1000,1000 },
         { 1000,1000,1000,1000,1000,1000,1000,1000,1000,1000 }
};




/***********************************************************************/
/*    SENSOR MEMBER FUNCTIONS. SENSOR IS AN ABSTRACT CLASS            */
/**********************************************************************/

// read the output of the adc and record the data
void sensor::measurement(void)
{
     PRESSURE_LEVEL touch = LIGHT;

#ifdef TEST
     unsigned int mouse_x_pos, mouse_y_pos;
     unsigned int mouse_buttons;

     // for test purposes, the mouse and pointer have been
     // dis-associated. here we will need to determine first
     // what we are supposed to be measuring and then read the actual
     // mouse position and return the appropriate position

     _swix(OS_Mouse, _OUTR(0, 2), &mouse_x_pos, &mouse_y_pos,
                                    &mouse_buttons);

     switch(type)
     {

            case CONFIGURED_FOR_X_MEASUREMENT:
                 measurement_data = mouse_x_pos;
                 break;

            case CONFIGURED_FOR_Y_MEASUREMENT:
                 measurement_data = mouse_y_pos;
                 break;

            case CONFIGURED_FOR_X_RESISTANCE_MEASUREMENT:
                 measurement_data = 1000;
                 break;

            case CONFIGURED_FOR_Y_RESISTANCE_MEASUREMENT:
                 measurement_data = 1000;
                 break;

            case CONFIGURED_FOR_PRESSURE_MEASUREMENT:
                 measurement_data = touch;
                 break;

            default:
                 ; // this is an error condition,
                  // might be good idea to attempt recovery

     }
#else

     _swix(OS_Hardware, _IN(0)|_INR(8,9)|_OUT(0),
                        type, 0, EntryNo_HAL_TouchscreenRead,
                        &measurement_data);

#endif

}






/***********************************************************************/
/*    X_SENSOR MEMBER FUNCTIONS                                        */
/***********************************************************************/

x_sensor::x_sensor()
{
     type = CONFIGURED_FOR_X_MEASUREMENT;
}

unsigned int x_sensor::get_x_position(void)
{
     measurement();
     return measurement_data;
}




/***********************************************************************/
/*    Y_SENSOR MEMBER FUNCTIONS                                        */
/***********************************************************************/

y_sensor::y_sensor()
{
     type = CONFIGURED_FOR_Y_MEASUREMENT;
}

unsigned int y_sensor::get_y_position(void)
{
     measurement();
     return measurement_data;
}



/***********************************************************************/
/*    PRESSURE SENSOR MEMBER FUNCTIONS                                 */
/***********************************************************************/

pressure_sensor::pressure_sensor()
{
     type = CONFIGURED_FOR_PRESSURE_MEASUREMENT;

     // some default values
     vlight_pressure_threshold = 0x10000000;
     light_pressure_threshold  = 0x48000000;
     firm_pressure_threshold   = 0x54000000;

}



// read the pressure level and set it to one of three levels
PRESSURE_LEVEL pressure_sensor::get_pressure_level(void)
{

     PRESSURE_LEVEL  pressure = ZERO;

     measurement();

     if(measurement_data >= vlight_pressure_threshold)
     {
         if(measurement_data < light_pressure_threshold)
         {
            pressure = VLIGHT;
         }

         else if(measurement_data < firm_pressure_threshold)
         {
            pressure = LIGHT;
         }

         else
         {
            pressure = FIRM;
         }

         return pressure;
     }

     else
     {
         return ZERO;
     }

}



/* an added complexity of a resistive touch screen is that the same
   pressure level will give different readings depending on what part
   of the touch screen the pressure was applied to. this function attempts
   to calibrate pressure. because the pressure sensor knows nothing about
   the touch screen, the position of the touched part of the screen has
   to be passed in as parameters. the bottom left corner of the ts is 0,0.
   the top right corner of the ts is 100, 100.
*/
PRESSURE_LEVEL pressure_sensor::get_pressure_level(unsigned int x_display_percentage,
                                                   unsigned int y_display_percentage)
{

     PRESSURE_LEVEL  pressure = ZERO;
     unsigned int calibration_multiplier;

     measurement();

     // now calibrate measurement
     // first will need to round display percentages to nearest 10%
     x_display_percentage = (((x_display_percentage + 5) / 10) * 10);
     y_display_percentage = (((y_display_percentage + 5) / 10) * 10);

     calibration_multiplier = calibration_multipliers[x_display_percentage]
                                                     [y_display_percentage];


     measurement_data = (measurement_data * calibration_multiplier) / 1000;

     // now the pressure has been calibrated

     if(measurement_data >= vlight_pressure_threshold)
     {
         if(measurement_data < light_pressure_threshold)
         {
            pressure = VLIGHT;
         }

         else if(measurement_data < firm_pressure_threshold)
         {
            pressure = LIGHT;
         }

         else
         {
            pressure = FIRM;
         }

         return pressure;
     }

     else
     {
         return ZERO;
     }

}





/***********************************************************************/
/*    RESISTANCE MEMBER FUNCTIONS                                      */
/***********************************************************************/

x_resistance_sensor::x_resistance_sensor()
{
     type = CONFIGURED_FOR_X_RESISTANCE_MEASUREMENT;
}


unsigned int x_resistance_sensor::get_x_resistance(void)
{
     measurement();
     return measurement_data;
}

y_resistance_sensor::y_resistance_sensor()
{
     type = CONFIGURED_FOR_Y_RESISTANCE_MEASUREMENT;
}


unsigned int y_resistance_sensor::get_y_resistance(void)
{
     measurement();
     return measurement_data;
}



