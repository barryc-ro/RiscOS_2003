/*************************************************************************
Copyright [2000] Pace Micro Technology PLC. All rights reserved.

The copyright in this material is owned by Pace Micro Technology PLC
("Pace"). This material is regarded as highly confidential trade secret
of Pace. It may not be reproduced, used, sold or in any other way exploited
or transferred to any third party without the prior written permission of
Pace.
*************************************************************************/

#include <stdbool.h>
#include "touchscr.h"

#include "module.h"
#include "Global/RISCOS.h"
#include "Global/IOCtl.h"

#include "swis.h"

extern "C" {
#include "header.h"
}


// global variables
static unsigned int x_calibration;
static unsigned int y_calibration;
static unsigned int pressure_calibration;

// local function prototypes
static PRESSURE_STATUS pressure_gradient(unsigned int current_pressure,
                                         unsigned int last_pressure);

static SCREEN_MEASUREMENT calibrate(SCREEN_MEASUREMENT p);


// local macros
#define LEFT_MOUSE_BUTTON(states)       (states && 0x00000100)
#define MIDDLE_MOUSE_BUTTON(states)     (states && 0x00000010)
#define RIGHT_MOUSE_BUTTON(states)      (states && 0x00000001)


#define LEFT_MOUSE_BUTTON_KEYCODE    9
#define MIDDLE_MOUSE_BUTTON_KEYCODE  10

/*************************************************************************************
   Driver currently runs off TickerV. Its operation is quite straight forward,
   simply determine if the screen is being touched with sufficient tscreen.pressure, if it is,
   then report to the OS where the screen is being touched.
**************************************************************************************/
int Driver(_kernel_swi_regs *r, void *pw)
{
     static touchscreen tscreen;       // create a touchscreen object


     SCREEN_MEASUREMENT    touched_position;
     SCREEN_MEASUREMENT    calibrated_position;
     static PRESSURE_LEVEL last_pressure = ZERO;
     PRESSURE_LEVEL        current_pressure;
     PRESSURE_STATUS       status;
     int button, button_states;

     (void)r;
     (void)pw;

     current_pressure = tscreen.pressure_measure.get_pressure_level();
     status = pressure_gradient(current_pressure, last_pressure);
     last_pressure = current_pressure;

     if(current_pressure != ZERO)
     {
        // look to see where screen is being touched and calibrate
        touched_position.x  = tscreen.x_position_measure.get_x_position();
        touched_position.y  = tscreen.y_position_measure.get_y_position();
        calibrated_position = calibrate(touched_position);


        // here need to convert position into pixels

        // inform the os where the screen was pressed
        tscreen.inform_kernel(calibrated_position.x, calibrated_position.y);

        if(status == INCREASING)
        {
           if(current_pressure == LIGHT)
           {
              // left mouse button down
              _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyDown, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
           }


           else if(current_pressure == FIRM)
           {
                // need to read to see if left mouse button is down,
                _swix(OS_Mouse, _OUT(2), button_states);
                if(LEFT_MOUSE_BUTTON(button_states))        // if it is then lift it
                {
                   _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
                }

                _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyDown, MIDDLE_MOUSE_BUTTON_KEYCODE, KeyV);
           }
        }

             // if the applied tscreen.pressure has decreased
        else if(status == DECREASING)
        {
             if(current_pressure == LIGHT)
             {
                // middle mouse button up
                _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, MIDDLE_MOUSE_BUTTON_KEYCODE, KeyV);
             }

             else
             {
                 // here will need to check if the middle mouse button is down,
                 _swix(OS_Mouse, _OUT(2), button_states);
                 if(MIDDLE_MOUSE_BUTTON(button_states))      // if it is then lift it
                 {
                    _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, MIDDLE_MOUSE_BUTTON_KEYCODE, KeyV);
                 }

                 // left mouse button up
                 _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
             }


          }

     }

     else  // this code executes when screen is not being touched at all
     {
           // report all mouse buttons to be in the up state
           _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);


     }

     return 0;
}


// function to detect if the screen is being pressed harder or softer
PRESSURE_STATUS pressure_gradient(unsigned int current_pressure,
                                  unsigned int last_pressure)
{
         PRESSURE_STATUS status = STATIC;

         if(current_pressure != last_pressure)
         {
            status = INCREASING;

            switch(current_pressure)
            {
                   case ZERO:
                     status = DECREASING;
                     break;

                   case VLIGHT:
                     if(last_pressure != ZERO)
                     {
                        status = DECREASING;
                     }
                     break;

                   case LIGHT:
                     if(last_pressure == FIRM)
                     {
                        status = DECREASING;
                     }
                     break;

                   case FIRM:
                     status = INCREASING;
                     break;

            }
         }
         return status;

}


// function to take the pressed point and calibrate the co-ordinates
SCREEN_MEASUREMENT calibrate(SCREEN_MEASUREMENT p)
{
       SCREEN_MEASUREMENT calibrated_value;
       return calibrated_value;
}



/*************************************************************************************
   module_initialise claims the vector TickerV
**************************************************************************************/
_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base, void *pw)
{
  (void)cmd_tail;
  (void)podule_base;

  return _swix(OS_Claim, _INR(0, 2), TickerV, tickerv_entry, pw);
}


/*************************************************************************************
   module_initialise releases the vector TickerV
**************************************************************************************/
_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{
  (void)fatal;
  (void)podule;
  (void)pw;

  return _swix(OS_Release, _INR(0, 2), TickerV, tickerv_entry, pw);

}


/*************************************************************************************
   swi handler
*************************************************************************************/
_kernel_oserror *swi_handler(int swi_no, _kernel_swi_regs *r, void *pw)
{
  (void)pw;
  (void)r;


  switch(swi_no)
  {
         case PaceTouchScreen_TSCalibratePosition - PaceTouchScreen_00:
              x_calibration = r->r[1];
              y_calibration = r->r[2];
              break;

         case PaceTouchScreen_TSCalibratePressure - PaceTouchScreen_00:
              pressure_calibration = r->r[1];
              break;

         default:
              return error_BAD_SWI;
  }

  return 0;
}

/*************************************************************************************
   command_handler
**************************************************************************************/
_kernel_oserror *command_handler(const char *arg_string, int argc, int cmd_no, void *pw)
{

  (void)arg_string;
  (void)argc;
  (void)pw;

  switch(cmd_no)
  {
         case CMD_Touchscreen_calibrate:
           break;

  }

  return 0;
}



