/*************************************************************************
Copyright [2000] Pace Micro Technology PLC. All rights reserved.

The copyright in this material is owned by Pace Micro Technology PLC
("Pace"). This material is regarded as highly confidential trade secret
of Pace. It may not be reproduced, used, sold or in any other way exploited
or transferred to any third party without the prior written permission of
Pace.
*************************************************************************/

#include <stdbool.h>
#include "touchscr.h"
#include "display.h"

#include "driver.h"
#include "module.h"
#include "Global/RISCOS.h"
#include "Global/IOCtl.h"
#include "Global/HALEntries.h"
#include "swis.h"

extern "C" {
#include "header.h"
}

extern "C" void ______main();

int Driver(_kernel_swi_regs *r, void *pw);

// local function prototypes
static PRESSURE_STATUS pressure_gradient(unsigned int current_pressure,
                                         unsigned int last_pressure);

static void inform_kernel(unsigned int x, unsigned int y);


// local macros
#define LEFT_MOUSE_BUTTON(states)       (states & 4)
#define MIDDLE_MOUSE_BUTTON(states)     (states & 2)
#define RIGHT_MOUSE_BUTTON(states)      (states & 1)

#define BYTE_1(x)     ((x) & 0x000000ff)
#define BYTE_2(x)    (((x) & 0x0000ff00) >> 8)


// these are defined here, but mouse button values may be already be defined in a .h file.
#define LEFT_MOUSE_BUTTON_KEYCODE    0x70
#define MIDDLE_MOUSE_BUTTON_KEYCODE  0x71



display     display_device;      // create a display object
touchscreen tscreen;             // create a touchscreen object

int pointerv_handler(_kernel_swi_regs *r, void *pw)
{
#ifdef TEST
     return Driver(r, pw);
#else

     switch (r->r[0])
     {
        case 0:
          if (r->r[1] != POINTER_TYPE)
            return 1;
          return Driver(r, pw);
        case 1:
        {
          pointer_record *record_ptr = NULL;
          int record_size = sizeof(pointer_record) + strlen(POINTER_NAME);
          _swix(OS_Module, _IN(0)|_IN(3)|_OUT(2), 6, record_size, &record_ptr);
          if (record_ptr)
          {
              record_ptr->next = (pointer_record *) r->r[1];
              record_ptr->device_flags = 0;
              record_ptr->device_type = POINTER_TYPE;
              strcpy(&record_ptr->device_name, POINTER_NAME);
              r->r[1] = (int) record_ptr;
              return 1;
          }
        }
        case 2:
          /* Should activate and deactivate here. Kernel bug - doesn't call on boot? */
          break;

        default:
          ;
     }

     return 1;

#endif
}

/*************************************************************************************
   Driver currently runs off PointerV. Its operation is quite straight forward,
   simply determine if the screen is being touched with sufficient tscreen.pressure, if it is,
   then report to the OS where the screen is being touched.
**************************************************************************************/
int Driver(_kernel_swi_regs *r, void *pw)
{

     static TOUCH_SCREEN_POSITION    touched_position;         // will contain data returned by HAL
     static DISPLAY_POSITION         display_position;         // will contain HAL data translated to pixels
     static PRESSURE_LEVEL           last_pressure = ZERO;
     static PRESSURE_LEVEL           current_pressure;
     static PRESSURE_STATUS          status;
     static bool                     left_down = false, middle_down = false;

     (void)r;
     (void)pw;

     // just to see if screen is being touched at all
     current_pressure = tscreen.pressure_measure.get_pressure_level();


     if(current_pressure != ZERO)
     {
        // look to see where screen is being touched, note that to keep this development code as
        // simple as possible the touch screen is assumed to be fitted in such a way that we know
        // which register contains the x-axis data, and which register contains the y-axis data.
        touched_position.x  = tscreen.x_position_measure.get_x_position();
        touched_position.y  = tscreen.y_position_measure.get_y_position();

        // here we need to convert the measured x and y data to a screen position
        display_position = display_device.translate_position(touched_position);

        // now that we know what part of the screen is touched we can calibrate the pressure
        current_pressure = tscreen.pressure_measure.get_pressure_level
                           (((display_device.get_display_size_x() * display_position.x) / 100),
                            ((display_device.get_display_size_y() * display_position.y) / 100));

        status = pressure_gradient(current_pressure, last_pressure);
        last_pressure = current_pressure;



#ifdef TEST
        // inform the os where the screen was pressed
        inform_kernel(display_position.x, display_position.y);
#else
        r->r[2] = display_position.x;
        r->r[3] = display_position.y;
        r->r[4] = 0x6F736241; /* Magic word: "Abso" - indicates absolute coordinates */
#endif



        if(status == INCREASING)
        {
           if(current_pressure == LIGHT)
           {
              // left mouse button down
              _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyDown, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
              left_down = true;
           }


           else if(current_pressure == FIRM)
           {
                // need to lift  left mouse button if moving from LIGHT
                if(left_down)
                {
                   _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
                   left_down = false;
                }

                _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyDown, MIDDLE_MOUSE_BUTTON_KEYCODE, KeyV);
                middle_down = true;
           }
        }

             // if the applied tscreen.pressure has decreased
        else if(status == DECREASING)
        {
           if(middle_down)
           {
              _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, MIDDLE_MOUSE_BUTTON_KEYCODE, KeyV);
              middle_down = false;
           }

           if (left_down)
           {
               // left mouse button up
               _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
               left_down = false;
           }

        }

     }

     else  // this code executes when screen is not being touched at all
     {
           // report all mouse buttons to be in the up state
           if(middle_down)
           {
              _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, MIDDLE_MOUSE_BUTTON_KEYCODE, KeyV);
              middle_down = false;
           }

           if (left_down)
           {
              // left mouse button up
              _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
              left_down = false;
           }

     }

     return 1;
}


// function to detect if the screen is being pressed harder or softer that at last measurement
PRESSURE_STATUS pressure_gradient(unsigned int current_pressure,
                                  unsigned int last_pressure)
{
         if (current_pressure == last_pressure)
             return STATIC;
         else if (current_pressure < last_pressure)
             return DECREASING;
         else
             return INCREASING;
}





#ifdef TEST
// inform the os of the new mouse position
void inform_kernel(unsigned int x, unsigned int y)
{
     unsigned char parameter_block[5];

     parameter_block[0] = 5;
     parameter_block[1] = BYTE_1(x);
     parameter_block[2] = BYTE_2(x);
     parameter_block[3] = BYTE_1(y);
     parameter_block[4] = BYTE_2(y);

     _swix(OS_Word, _INR(0,1), 21, parameter_block);


}
#endif

static struct { int errno; char errmess[8]; } BadHardError = { 0x603, "BadHard" };

/*************************************************************************************
   module_initialise claims the vector PointerV
**************************************************************************************/
_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *e;
  unsigned int flags;

  (void)cmd_tail;
  (void)podule_base;
  (void)pw;

  ______main();


  e = _swix(OS_Hardware, _INR(8,9)|_OUT(0), 0, EntryNo_HAL_TouchscreenType, &flags);
  if (e || (flags & 0xFF) == 0)
    return _swix(MessageTrans_ErrorLookup, _INR(0,2), &BadHardError, 0, 0);


#ifdef TEST
  return _swix(OS_Claim, _INR(0, 2), TickerV, pointerv_entry, pw);
#else
  return _swix(OS_Claim, _INR(0, 2), PointerV, pointerv_entry, pw);
#endif
}


/*************************************************************************************
   module_initialise releases the vector TickerV
**************************************************************************************/
_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{
  (void)fatal;
  (void)podule;
  (void)pw;

#ifdef TEST
  return _swix(OS_Release, _INR(0, 2), TickerV, pointerv_entry, pw);
#else
  return _swix(OS_Release, _INR(0, 2), PointerV, pointerv_entry, pw);
#endif

}


/*************************************************************************************
   swi handler
*************************************************************************************/
_kernel_oserror *swi_handler(int swi_no, _kernel_swi_regs *r, void *pw)
{
  (void)pw;
  (void)r;

  TOUCH_SCREEN_POSITION pos;
  _kernel_oserror* error_code = 0;

  pos.x = tscreen.x_position_measure.get_x_position();
  pos.y = tscreen.y_position_measure.get_y_position();

  r->r[0] = 0; // r0 is used to pass info back to the calibration app.
               // always reset to 0 just to be safe.

  switch(swi_no)
  {
         case TSDriver_Calibrate:  // values are being passed in from the calibration application
              switch(r->r[1])
              {
                     case 0:       // the user is pressing the centre of the display
                       display_device.set_centre(pos);
                       r->r[0] = 1;
                       break;

                     case 1:       // the user is pressing the bottom centre of the display
                       display_device.set_bottom_centre(pos);
                       r->r[0] = 1;
                       break;

                     case 2:       // the user is pressing the top centre of the display
                       display_device.set_top_centre(pos);
                       r->r[0] = 1;
                       break;

                     case 3:       // the user is pressing the left centre of the diaplay
                       display_device.set_left_centre(pos);
                       r->r[0] = 1;
                       break;

                     case 4:       // the user is pressing the right centre of the display
                       display_device.set_right_centre(pos);
                       r->r[0] = 1;
                       break;

                     case 5:       // r2 contains the light pressure threshold
                       tscreen.pressure_measure.set_light_threshold(r->r[2]);
                       r->r[0] = 1;
                       break;

                     case 6:       // r2 contains the firm pressure threshold
                       tscreen.pressure_measure.set_firm_threshold(r->r[2]);
                       r->r[0] = 1;
                       break;

                     default:
                       error_code = error_BAD_SWI;
              }
              break;

         default:
              error_code = error_BAD_SWI;
  }
  return error_code;

}

/*************************************************************************************
   command_handler
**************************************************************************************/
_kernel_oserror *command_handler(const char *arg_string, int argc, int cmd_no, void *pw)
{

  (void)arg_string;
  (void)argc;
  (void)pw;

  (void)cmd_no;  // will need to delete this line before switching

//  switch(cmd_no)
//  {

//  }

  return 0;
}



