/*************************************************************************
Copyright [2000] Pace Micro Technology PLC. All rights reserved.

The copyright in this material is owned by Pace Micro Technology PLC
("Pace"). This material is regarded as highly confidential trade secret
of Pace. It may not be reproduced, used, sold or in any other way exploited
or transferred to any third party without the prior written permission of
Pace.
*************************************************************************/

#include <stdbool.h>
#include "touchscr.h"
#include "display.h"

#include "module.h"
#include "Global/RISCOS.h"
#include "Global/IOCtl.h"

#include "swis.h"

extern "C" {
#include "header.h"
}

extern "C" void ______main();

int main(void)
{
  ______main();
  return 0;
}


// local function prototypes
static PRESSURE_STATUS pressure_gradient(unsigned int current_pressure,
                                         unsigned int last_pressure);

static void inform_kernel(unsigned int x, unsigned int y);

// local macros
#define LEFT_MOUSE_BUTTON(states)       (states && 0x00000100)
#define MIDDLE_MOUSE_BUTTON(states)     (states && 0x00000010)
#define RIGHT_MOUSE_BUTTON(states)      (states && 0x00000001)

#define BYTE_1(x)     ((x) & 0x000000ff)
#define BYTE_2(x)    (((x) & 0x0000ff00) >> 8)


// these are defined here, but mouse button values may be already be defined in a .h file.
#define LEFT_MOUSE_BUTTON_KEYCODE    9
#define MIDDLE_MOUSE_BUTTON_KEYCODE  10



display     display_device;      // create a display object
touchscreen tscreen;             // create a touchscreen object

/*************************************************************************************
   Driver currently runs off PointerV. Its operation is quite straight forward,
   simply determine if the screen is being touched with sufficient tscreen.pressure, if it is,
   then report to the OS where the screen is being touched.
**************************************************************************************/
int Driver(_kernel_swi_regs *r, void *pw)
{

     static TOUCH_SCREEN_POSITION    touched_position;         // will contain data returned by HAL
     static DISPLAY_POSITION    display_position;         // will contain HAL data translated to pixels
     static PRESSURE_LEVEL     last_pressure = ZERO;
     static PRESSURE_LEVEL     current_pressure;
     static PRESSURE_STATUS    status;
     static unsigned int       button, button_states;

     (void)r;
     (void)pw;

     current_pressure = tscreen.pressure_measure.get_pressure_level();
     status = pressure_gradient(current_pressure, last_pressure);
     last_pressure = current_pressure;


     if(current_pressure != ZERO)
     {
        // look to see where screen is being touched, note that to keep this development code as
        // simple as possible the touch screen is assumed to be fitted in such a way that we know
        // which register contains the x-axis data, and which register contains the y-axis data.
        touched_position.x  = tscreen.x_position_measure.get_x_position();
        touched_position.y  = tscreen.y_position_measure.get_y_position();

        // here we need to convert the measured x and y data to a screen position
        display_position = display_device.translate_position(touched_position);

        // inform the os where the screen was pressed
        inform_kernel(display_position.x, display_position.y);



        if(status == INCREASING)
        {
           if(current_pressure == LIGHT)
           {
              // left mouse button down
              _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyDown, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
           }


           else if(current_pressure == FIRM)
           {
                // need to read to see if left mouse button is down,
                _swix(OS_Mouse, _OUT(2), button_states);
                if(LEFT_MOUSE_BUTTON(button_states))        // if it is then lift it
                {
                   _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
                }

                _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyDown, MIDDLE_MOUSE_BUTTON_KEYCODE, KeyV);
           }
        }

             // if the applied tscreen.pressure has decreased
        else if(status == DECREASING)
        {
             if(current_pressure == LIGHT)
             {
                // middle mouse button up
                _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, MIDDLE_MOUSE_BUTTON_KEYCODE, KeyV);
             }

             else
             {
                 // here will need to check if the middle mouse button is down,
                 _swix(OS_Mouse, _OUT(2), button_states);
                 if(MIDDLE_MOUSE_BUTTON(button_states))      // if it is then lift it
                 {
                    _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, MIDDLE_MOUSE_BUTTON_KEYCODE, KeyV);
                 }

                 // left mouse button up
                 _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
             }


          }

     }

     else  // this code executes when screen is not being touched at all
     {
           // report all mouse buttons to be in the up state
           _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);

     }

     return 0;
}


// function to detect if the screen is being pressed harder or softer that at last measurement
PRESSURE_STATUS pressure_gradient(unsigned int current_pressure,
                                  unsigned int last_pressure)
{
         PRESSURE_STATUS status = STATIC;

         if(current_pressure != last_pressure)
         {
            status = INCREASING;

            switch(current_pressure)
            {
                   case ZERO:
                     status = DECREASING;
                     break;

                   case VLIGHT:
                     if(last_pressure != ZERO)
                     {
                        status = DECREASING;
                     }
                     break;

                   case LIGHT:
                     if(last_pressure == FIRM)
                     {
                        status = DECREASING;
                     }
                     break;

                   case FIRM:
                     status = INCREASING;
                     break;

            }
         }
         return status;

}


// inform the os of the new mouse position
void inform_kernel(unsigned int x, unsigned int y)
{
     unsigned char parameter_block[5];

     parameter_block[0] = 5;
     parameter_block[1] = BYTE_1(x);
     parameter_block[2] = BYTE_2(x);
     parameter_block[3] = BYTE_1(y);
     parameter_block[4] = BYTE_2(y);

     _swix(OS_Word, _INR(0,1), 21, parameter_block);


}


/*************************************************************************************
   module_initialise claims the vector TickerV
**************************************************************************************/
_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base, void *pw)
{
  (void)cmd_tail;
  (void)podule_base;

  ______main();

  return _swix(OS_Claim, _INR(0, 2), TickerV, tickerv_entry, pw);
}


/*************************************************************************************
   module_initialise releases the vector TickerV
**************************************************************************************/
_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{
  (void)fatal;
  (void)podule;
  (void)pw;

  return _swix(OS_Release, _INR(0, 2), TickerV, tickerv_entry, pw);

}


/*************************************************************************************
   swi handler
*************************************************************************************/
_kernel_oserror *swi_handler(int swi_no, _kernel_swi_regs *r, void *pw)
{
  (void)pw;
  (void)r;

  _kernel_oserror* err_code = 0;

  TOUCH_SCREEN_POSITION pos;

  pos.x = tscreen.x_position_measure.get_x_position();
  pos.y = tscreen.y_position_measure.get_y_position();

  switch(swi_no)
  {
         case TSDriver_Calibrate:  // values are being passed in from the calibration application
              switch(r->r[0])
              {
                     case 0:       // the user is pressing the centre of the display
                       display_device.set_centre(pos);
                       break;

                     case 1:       // the user is pressing the bottom centre of the display
                       display_device.set_bottom_centre(pos);
                       break;

                     case 2:       // the user is pressing the top centre of the display
                       display_device.set_top_centre(pos);
                       break;

                     case 3:       // the user is pressing the left centre of the diaplay
                       display_device.set_left_centre(pos);
                       break;

                     case 4:       // the user is pressing the right centre of the display
                       display_device.set_right_centre(pos);
                       break;

                     case 5:       // r2 contains the light pressure threshold
                       ;
                       break;

                     case 6:       // r2 contains the firm pressure threshold
                       ;
                       break;

                     default:
                       err_code = error_BAD_SWI;
              }
              break;

         default:
              err_code = error_BAD_SWI;
  }

  return err_code;
}

/*************************************************************************************
   command_handler
**************************************************************************************/
_kernel_oserror *command_handler(const char *arg_string, int argc, int cmd_no, void *pw)
{

  (void)arg_string;
  (void)argc;
  (void)pw;

  (void)cmd_no;  // will need to delete this line before switching

//  switch(cmd_no)
//  {

//  }

  return 0;
}



