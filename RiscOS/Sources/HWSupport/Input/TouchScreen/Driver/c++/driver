/*************************************************************************
Copyright [2000] Pace Micro Technology PLC. All rights reserved.

The copyright in this material is owned by Pace Micro Technology PLC
("Pace"). This material is regarded as highly confidential trade secret
of Pace. It may not be reproduced, used, sold or in any other way exploited
or transferred to any third party without the prior written permission of
Pace.
*************************************************************************/

#include <stdbool.h>
#include "touchscr.h"
#include "display.h"

#include "driver.h"
#include "module.h"
#include "Global/RISCOS.h"
#include "Global/IOCtl.h"
#include "Global/HALEntries.h"
#include "swis.h"

extern "C" {
#include "header.h"
}

extern "C" void ______main();

int Driver(_kernel_swi_regs *r, void *pw);

// local function prototypes
static PRESSURE_STATUS pressure_gradient(PRESSURE_LEVEL &current_pressure,
                                         PRESSURE_LEVEL last_pressure);

static void inform_kernel(unsigned int x, unsigned int y);


// local macros
#define LEFT_MOUSE_BUTTON(states)       (states & 4)
#define MIDDLE_MOUSE_BUTTON(states)     (states & 2)
#define RIGHT_MOUSE_BUTTON(states)      (states & 1)

#define BYTE_1(x)     ((x) & 0x000000ff)
#define BYTE_2(x)    (((x) & 0x0000ff00) >> 8)


// these are defined here, but mouse button values may be already be defined in a .h file.
#define LEFT_MOUSE_BUTTON_KEYCODE    0x70
#define MIDDLE_MOUSE_BUTTON_KEYCODE  0x71
#define RIGHT_MOUSE_BUTTON_KEYCODE  0x72
#define PROG_KEYCODE 0x7e
#define FN_KEYCODE   0x7f



display     display_device;      // create a display object
touchscreen tscreen;             // create a touchscreen object

static bool prog_down, fn_down;

int keyevent_handler(_kernel_swi_regs *r, void *pw)
{
    int key = r->r[2];
    int down = r->r[1];

    (void)pw;

    if (key != FN_KEYCODE && key != PROG_KEYCODE)
        return 1;

    if (down != 0 && down != 1)
        return 1;

    if (key == PROG_KEYCODE)
        prog_down = down;
    else
        fn_down = down;

    return 1;
}

int pointerv_handler(_kernel_swi_regs *r, void *pw)
{
#ifdef TEST
     return Driver(r, pw);
#else

     switch (r->r[0])
     {
        case 0:
          if (r->r[1] != POINTER_TYPE)
            return 1;
          return Driver(r, pw);
        case 1:
        {
          pointer_record *record_ptr = NULL;
          int record_size = sizeof(pointer_record) + strlen(POINTER_NAME);
          _swix(OS_Module, _IN(0)|_IN(3)|_OUT(2), 6, record_size, &record_ptr);
          if (record_ptr)
          {
              record_ptr->next = (pointer_record *) r->r[1];
              record_ptr->device_flags = 0;
              record_ptr->device_type = POINTER_TYPE;
              strcpy(&record_ptr->device_name, POINTER_NAME);
              r->r[1] = (int) record_ptr;
              return 1;
          }
        }
        case 2:
          /* Should activate and deactivate here. Kernel bug - doesn't call on boot? */
          break;

        default:
          ;
     }

     return 1;

#endif
}

/*************************************************************************************
   Driver currently runs off PointerV. Its operation is quite straight forward,
   simply determine if the screen is being touched with sufficient tscreen.pressure, if it is,
   then report to the OS where the screen is being touched.
**************************************************************************************/
int Driver(_kernel_swi_regs *r, void *pw)
{

     static TOUCH_SCREEN_POSITION    touched_position;         // will contain data returned by HAL
     static DISPLAY_POSITION         display_position;         // will contain HAL data translated to pixels
     static PRESSURE_LEVEL           last_pressure = ZERO;
     static PRESSURE_LEVEL           current_pressure;
     static PRESSURE_STATUS          status;
     static bool                     left_down = false, middle_down = false, right_down = false;
     static bool                     active;
     static int                      irqs_off;

     if (!display_device.is_calibrated())
         return 1;

     irqs_off = _kernel_irqs_disabled();
     if (!irqs_off)
        _kernel_irqs_off();

     if (active)  // don't re-enter ourselves
     {
         if (!irqs_off) _kernel_irqs_on();
         return 1;
     }

     active = true;
     _kernel_irqs_on();  // enable interrupts - we may be some time

     (void)r;
     (void)pw;

     // just to see if screen is being touched at all
     current_pressure = tscreen.pressure_measure.get_pressure_level();


     if(current_pressure != ZERO)
     {
        // look to see where screen is being touched, note that to keep this development code as
        // simple as possible the touch screen is assumed to be fitted in such a way that we know
        // which register contains the x-axis data, and which register contains the y-axis data.
        touched_position.x  = tscreen.x_position_measure.get_x_position();
        touched_position.y  = tscreen.y_position_measure.get_y_position();

        // here we need to convert the measured x and y data to a screen position
        display_position = display_device.translate_position(touched_position);

        // now that we know what part of the screen is touched we can calibrate the pressure
        // (and double-check to make sure the buggers haven't let go, invalidating the position)
        current_pressure = tscreen.pressure_measure.get_pressure_level(
                              display_device.which_corner(touched_position), display_position);

        status = pressure_gradient(current_pressure, last_pressure);
     }

     last_pressure = current_pressure;

     if(current_pressure != ZERO)
     {

#ifdef TEST
        // inform the os where the screen was pressed
        inform_kernel(display_position.x, display_position.y);
#else
        r->r[2] = display_position.x;
        r->r[3] = display_position.y;
        r->r[4] = 0x6F736241; /* Magic word: "Abso" - indicates absolute coordinates */
#endif



        if(status == INCREASING && current_pressure >= LIGHT)
        {
           if(current_pressure == FIRM || fn_down)
           {
                if(left_down)
                {
                   _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
                   left_down = false;
                }

                if(right_down)
                {
                   _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, RIGHT_MOUSE_BUTTON_KEYCODE, KeyV);
                   right_down = false;
                }

                _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyDown, MIDDLE_MOUSE_BUTTON_KEYCODE, KeyV);
                middle_down = true;
           }
           else if (prog_down)
           {
                _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyDown, RIGHT_MOUSE_BUTTON_KEYCODE, KeyV);
                right_down = true;
           }
           else
           {
              // left mouse button down
              _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyDown, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
              left_down = true;
           }


        }

     }

     else  // this code executes when screen is not being touched at all
     {
           // report all mouse buttons to be in the up state
           if(right_down)
           {
              _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, RIGHT_MOUSE_BUTTON_KEYCODE, KeyV);
              right_down = false;
           }

           if(middle_down)
           {
              _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, MIDDLE_MOUSE_BUTTON_KEYCODE, KeyV);
              middle_down = false;
           }

           if (left_down)
           {
              // left mouse button up
              _swix(OS_CallAVector, _INR(0, 1) | _IN(9), KeyV_KeyUp, LEFT_MOUSE_BUTTON_KEYCODE, KeyV);
              left_down = false;
           }

     }

     active = false;

     if (!irqs_off)
         _kernel_irqs_on();  // restore interrupt status

     return 1;
}


// function to detect if the screen is being pressed harder or softer that at last measurement
PRESSURE_STATUS pressure_gradient(PRESSURE_LEVEL &current_pressure,
                                  PRESSURE_LEVEL last_pressure)
{
         if (current_pressure == last_pressure)
             return STATIC;
         else if (current_pressure < last_pressure)
         {
             if (current_pressure != ZERO)
             {
                 /* Stickyness - they're not allowed to let go partially */
                 current_pressure = last_pressure;
                 return STATIC;
             }
             else
                 return DECREASING;
         }
         else
             return INCREASING;
}





#ifdef TEST
// inform the os of the new mouse position
void inform_kernel(unsigned int x, unsigned int y)
{
     unsigned char parameter_block[5];

     parameter_block[0] = 5;
     parameter_block[1] = BYTE_1(x);
     parameter_block[2] = BYTE_2(x);
     parameter_block[3] = BYTE_1(y);
     parameter_block[4] = BYTE_2(y);

     _swix(OS_Word, _INR(0,1), 21, parameter_block);


}
#endif

void service_handler(int service_number, _kernel_swi_regs *r, void *pw)
{
    (void) service_number;
    (void) r;
    (void) pw;

    // only Service_ModeChange at the moment

    display_device.display_dimensions();
}

static struct { int errno; char errmess[8]; } BadHardError = { 0x603, "BadHard" };

/*************************************************************************************
   module_initialise claims the vector PointerV
**************************************************************************************/
_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *e;
  unsigned int flags;

  (void)cmd_tail;
  (void)podule_base;
  (void)pw;

  ______main();


  e = _swix(OS_Hardware, _INR(8,9)|_OUT(0), 0, EntryNo_HAL_TouchscreenType, &flags);
  if (e || (flags & 0xFF) == 0)
    return _swix(MessageTrans_ErrorLookup, _INR(0,2), &BadHardError, 0, 0);

  // yeah, yeah - error handling...

  e = _swix(OS_Claim, _INR(0,2), EventV, keyevent_entry, pw);
  if (e) return e;

  e = _swix(OS_Byte, _INR(0,1), 14, Event_Keyboard);
  if (e) return e;


#ifdef TEST
  return _swix(OS_Claim, _INR(0, 2), TickerV, pointerv_entry, pw);
#else
  return _swix(OS_Claim, _INR(0, 2), PointerV, pointerv_entry, pw);
#endif
}


/*************************************************************************************
   module_initialise releases the vector TickerV
**************************************************************************************/
_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{
  (void)fatal;
  (void)podule;

  _swix(OS_Byte, _INR(0,1), 13, Event_Keyboard);
  _swix(OS_Release, _INR(0,2), EventV, keyevent_entry, pw);

#ifdef TEST
  return _swix(OS_Release, _INR(0, 2), TickerV, pointerv_entry, pw);
#else
  return _swix(OS_Release, _INR(0, 2), PointerV, pointerv_entry, pw);
#endif

}


/*************************************************************************************
   swi handler
*************************************************************************************/
_kernel_oserror *swi_handler(int swi_no, _kernel_swi_regs *r, void *pw)
{
  (void)pw;
  (void)r;

  TOUCH_SCREEN_POSITION pos;
  DISPLAY_POSITION disp;
  unsigned int pres;
  PRESSURE_LEVEL pres_level;
  _kernel_oserror* error_code = 0;

  pos.x = tscreen.x_position_measure.get_x_position();
  pos.y = tscreen.y_position_measure.get_y_position();
  pres = tscreen.pressure_measure.get_raw_pressure();
  pres_level = tscreen.pressure_measure.get_pressure_level(pres);

  r->r[0] = 0; // r0 is used to pass info back to the calibration app.
               // always reset to 0 just to be safe.

  disp.x = r->r[2];
  disp.y = r->r[3];

  switch(swi_no)
  {
         case TSDriver_Calibrate - TSDriver_00:
              switch(r->r[1])
              {
                     case 0:       // the user is pressing nothing
                       r->r[0] = tscreen.pressure_measure.calibrate_release(pres);
                       break;

                     case 1:       // the user is pressing the centre of the display
                       r->r[0] = display_device.calibrate_centre(pos, disp, pres);
                       break;

                     case 2:       // the user is pressing a corner of the display
                     case 3:
                     case 4:
                     case 5:
                       r->r[0] = display_device.calibrate_corner(pos, disp, pres);
                       break;

                     case 6:       // r2 contains the light pressure threshold
                       tscreen.pressure_measure.set_light_threshold((unsigned int) r->r[2] >> 20);
                       r->r[0] = 1;
                       break;

                     case 7:       // r2 contains the firm pressure threshold
                       tscreen.pressure_measure.set_firm_threshold((unsigned int) r->r[2] >> 20);
                       r->r[0] = 1;
                       break;

                     default:
                       error_code = error_BAD_SWI;
              }
              break;

         default:
              error_code = error_BAD_SWI;
  }
  return error_code;

}

/*************************************************************************************
   command_handler
**************************************************************************************/
_kernel_oserror *command_handler(const char *arg_string, int argc, int cmd_no, void *pw)
{

  (void)arg_string;
  (void)argc;
  (void)pw;

  (void)cmd_no;  // will need to delete this line before switching

//  switch(cmd_no)
//  {

//  }

  printf("Transformation matrix: (%8d,%8d)\n", display_device.get_xx(), display_device.get_xy());
  printf("                       (%8d,%8d)\n", display_device.get_yx(), display_device.get_yy());
  printf("ADC centre:            (%8d,%8d)\n", display_device.get_centre_adc().x, display_device.get_centre_adc().y);
  printf("Screen centre:         (%8d,%8d)\n", display_device.get_centre_pos().x, display_device.get_centre_pos().y);
  printf("Zero pressure:         %5d\n", tscreen.pressure_measure.get_zero_pressure());
  printf("Release pressure:      %5d\n", tscreen.pressure_measure.get_release_pressure());
  printf("VLight pressure:       %5d\n", tscreen.pressure_measure.get_vlight_pressure());
  printf("Light pressure:        %5d\n", tscreen.pressure_measure.get_light_pressure());
  printf("Firm pressure:         %5d\n\n", tscreen.pressure_measure.get_firm_pressure());
  printf("Centre pressure:       %5d\n", tscreen.pressure_measure.get_centre_pressure());
#if 0
  printf("Pressure adjustments:  (%d,%d,%d,%d)\n", tscreen.pressure_measure.get_pressure_adjust(0),
                                                   tscreen.pressure_measure.get_pressure_adjust(1),
                                                   tscreen.pressure_measure.get_pressure_adjust(2),
                                                   tscreen.pressure_measure.get_pressure_adjust(3));
#endif
  printf("Corner pressures:      (%5d,%5d,%5d,%5d)\n", tscreen.pressure_measure.get_corner_pressure(0),
                                                       tscreen.pressure_measure.get_corner_pressure(1),
                                                       tscreen.pressure_measure.get_corner_pressure(2),
                                                       tscreen.pressure_measure.get_corner_pressure(3));



  return 0;
}

