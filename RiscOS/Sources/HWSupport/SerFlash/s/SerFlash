; > SerFlash
;
; Atmel Serial Dataflash Driver
;
; - Drives AT45D041 serial dataflash IC and compatible devices

; *************************
; ***	Changes List	***
; *************************
;
; 02-Apr-97 SBF 0.00 Created: outline module code produced
; 02-Apr-97 SBF      Defined error messages
; 02-Apr-97 SBF      Added SWI call handler
; 03-Apr-97 SBF      Internationalised error message handling added
; 03-Apr-97 SBF      Constants defined
; 03-Apr-97 SBF      Implemented SWI call error handling
; 03-Apr-97 SBF      Added code to handle SerialFlash_DeviceInfo SWI call
; 04-Apr-97 SBF      Added code to handle SerialFlash_ReadPage SWI call
; 04-Apr-97 SBF      Added code to handle SerialFlash_WritePage SWI call
; 04-Apr-97 SBF 0.01 Removed redundant code
; 07-Apr-97 SBF 0.02 Added code to enable/disable the /CS line
; 16-Apr-97 SBF      Implemented new SWI: SerialFlash_DeviceStatus
; 16-Apr-97 SBF 0.03 Added "podule" switch, to allow testing with the podule containing the device
; 17-Apr-97 SBF 0.04 Significant update: added support for multiple devices
; 18-Apr-97 SBF      Continued adding support for multiple devices: I/O register now recorded in device table
; 18-Apr-97 SBF 0.05 Full information now returned from SerialFlash_DeviceInfo
; 07-Aug-97 SBF 0.06 Timing delay added to allow for faster clocking in of last byte on Daytona H/W
;
; **********************************************************************************************************************************


	; Import global headers
		GET	Hdr:ListOpts
		GET	Hdr:Macros
		GET	Hdr:DDVMacros
		GET	Hdr:System
		GET	Hdr:ModHand
		GET	Hdr:FSNumbers
		GET	Hdr:NewErrors
		GET	Hdr:CMOS
		GET	Hdr:Symbols
		GET	Hdr:Services
		GET	Hdr:DeviceFS
		GET	Hdr:Serial
		GET	Hdr:RS423
		GET	Hdr:HostFS
		GET	Hdr:NdrDebug
		GET	Hdr:MsgTrans
		GET	Hdr:UpCall
		GET	Hdr:Proc

		GBLL	debug
		GBLL	hostvdu
		GBLL	international
		GBLL	podule

debug		SETL	false				; Global debug flag
hostvdu		SETL	false				; VDU flag
international	SETL	false				; Internationalisation
podule		SETL	false				; Test podule version?

	; Debugging switches: "debug" must be set to true before any of these will take effect...
showregs	SETD	false				; Allow display of all register values (when "display_regs" called)
module		SETD	false				; Module entry points
swicalls	SETD	false				; SWI call handler
memoryblock	SETD	false				; Page memory block contents
delayloop	SETD	false				; Setup and hold time delay loop

	; Import user (local) headers
		GET	Version
		GET	s.Macros
		GET	s.FlashErrs

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Define workspace and how it's to be used:
;

			^ 0, wp				; Start of workspace
	[ international
			AlignSpace
MessagesWorkspace	# 16				; 16 byte header for message trans
	]

Flags			# 4

WorkspaceEnd		* :INDEX: @			; Amount of workspace needed


; *** Defined constants ***
;
; Define the number of columns and the (word aligned) position
; of each entry in the device table (label = DeviceTable)

Table_Col		* 5

Flash_Reg		* 0
IO_Reg			* 4
CS_Bit			* 8
Pages_In_Flash		* 12
Bytes_Per_Page		* 16

; Flash memory instruction opcodes:
Inst_PageRead		* &52
Inst_PageWrite		* &82
Inst_Status		* &57

; Delay loop iterations (see note under "Timing delay loop" below):
Delay_Iterations	* 24

; Flags:
f_WeHaveMessages	* 2_00000001


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Module header (entry points into module code)
;
module_base	DCD	0				; => Start code [none]
		DCD	initialisation - module_base	; => Initialisation
		DCD	finalisation - module_base	; => Finalisation
		DCD	0				; => Service handler [none]

		DCD	title_str - module_base		; => Title string
		DCD	help_str - module_base		; => Help string
		DCD	0				; => Command/keyword table [none]

		DCD	&4F540				; =  SWI base chunk number [allocated]
		DCD	swi_handler - module_base	; => SWI call handler
		DCD	swi_table - module_base		; => SWI decoding table
		DCD	0				; => SWI decoding code [none]


title_str	= "SerialFlash", 0
help_str	= "Flash Driver",9,"$VString ($Date)"
	[ debug
		! 0, "Development version - debugging statements included"
		= " [Development version]"
	]
	[ podule
		! 0, "Development podule version"
		= " [Podule version]"
	]
		= 0


	[ international
		! 0, "Internationalised version"
resource_file	= "Resources:$.Resources.SerFlash.Messages", 0
	]
		ALIGN

		MakeErrorBlock	SerialFlash_DeviceUnavailable
		MakeErrorBlock	SerialFlash_InvalidPage
		MakeErrorBlock	SerialFlash_PageBlockTooSmall
		MakeErrorBlock	SerialFlash_BadSWI

swi_table						; SWI call table
		= "SerialFlash", 0			; Group prefix

		= "DeviceInfo", 0			; SWI names
		= "ReadPage", 0
		= "WritePage", 0
		= "DeviceStatus", 0

		DCD	0				; Zero byte terminator (end of table)

		ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Module initialisation; this involves allocating the necessary workspace followed
; by claiming the required vectors
;

initialisation	ENTRY

	[ debug
	[ podule
		Debug	module, "*** Podule version ***"
	]
		Debug	module, "Initialisation..."
	]
		LDR	r2, [wp]
		TEQ	r2, #0				; Warm start?
		BNE	%FT10				; Yes, so skip workspace claim


		MOV	r0, #ModHandReason_Claim	; Set Claim reason code
		LDR	r3, =WorkspaceEnd		; R3 = amount of workspace required
		SWI	XOS_Module

		EXIT	VS				; Return if it failed

	[ debug
		Debug	module, "Workspace claimed =", r3
	]

		STR	r2, [wp]
10
		MOV	wp, r2				; wp -> workspace allocation

		EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Module finalisation; attempt to release any vectors already claimed
;

finalisation	ENTRY	"r0-r2"

	[ debug
		Debug	module, "Finalisation..."
	]

		LDR	wp, [wp]			; wp -> workspace

	[ international
		BL	CloseMessages			; Attempt to close messages file
	]

		; Free any workspace claimed
		CMP	r12, #0				; Any workspace?
		EXITS	EQ				; Exit now if there is no workspace

	[ debug
		Debug	module, "Free workspace"
	]

		MOV	r0, #ModHandReason_Free		; Set Free reason code
		MOV	r2, r12				; Copy amount of workspace into R2
		SWI	XOS_Module			; Free the workspace

	[ debug
		Debug	module, "Remove from RMA"
	]
		EXITS


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Table of available serial dataflash devices (must be word aligned addresses):
;
; This table contains information on each flash device.  The following details are stored:
;
;	Number of entries in table (DeviceEntries)
;
;	a) The 8-bit register, which all read/write operations must use
;	b) The 8-bit I/O register (usually the processor I/O register)
;	c) The bit used for the Chip Select (CS) line in the I/O register
;	d) The maximum number of pages in the device
;	e) The number of bytes per page

DeviceEntries	DCD	6

DeviceTable	; 	Flash Reg	I/O Reg		CS bit		Pages	Bytes
		DCD	&03010D00,	&0320000C,	1:SHL:2,	2048,	264	; Daytona hardware
		DCD	&88000010,	&88000000,	1:SHL:0,	2048,	264	; RiscPC podule slot 0
		DCD	&89000010,	&89000000,	1:SHL:0,	2048,	264	; RiscPC podule slot 1
		DCD	&8A000010,	&8A000000,	1:SHL:0,	2048,	264	; RiscPC podule slot 2
		DCD	&8B000010,	&8B000000,	1:SHL:0,	2048,	264	; RiscPC podule slot 3
		DCD	&8FEDC100,	&8FEDCBA0,	1:SHL:12,	1024,	512	; Bogus, for testing!!!
DeviceTableEnd
		ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Call:	swi_handler
;

swi_handler
		ROUT

		LDR	wp, [wp]			; wp -> wp

		CMP	r11, #(%10-%00)/4		; Check for invalid SWI calls
		ADDLO	pc, pc, r11, LSL #2		; If valid then call appropriate code
		B	%FT10
00
		B	SWI_0
		B	SWI_1
		B	SWI_2
		B	SWI_3
10
		ADDR	r0, ErrorBlock_SerialFlash_BadSWI
		DoError


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Call:	SWI_0
;
; SWI:	SerialFlash_DeviceInfo
;
; In:	r0 =  device index number
;
; Out:	r0 preserved
;	r1 =  number of pages in flash device
;	r2 =  number of bytes per page
;

SWI_0		; SWI SerialFlash_DeviceInfo
		ENTRY	"r0"
	[ debug
		Debug	swicalls, "SWI call: DeviceInfo"
	]
		; Ascertain the device characteristics from the device table
		ADRL	r3, DeviceTable			; -> device table
		ADRL	r4, DeviceEntries		; -> number of device entries
		LDR	r5, [r4]			; Obtain number of devices

		CMP	r0, r5				; Is specified index within range?
		PullEnv	HS				; No?  Then restore stack
		BHS	error_deviceunavailable		; And execute error handling code

		MOV	r4, #Table_Col			; Obtain number of columns in tables
		MOV	r4, r4, LSL #2			; Transform into bytes
		MUL	r0, r4, r0			; Calculate offset into table
		ADD	r0, r0, r3			; Add offset to base of table to locate required row
		LDR	r1, [r0, #Pages_In_Flash]	; Obtain number of pages from table
		LDR	r2, [r0, #Bytes_Per_Page]	; Obtain bytes per page from table
		LDR	r3, [r0, #Flash_Reg]		; Obtain flash register address from table
		LDR	r4, [r0, #IO_Reg]		; Obtain I/O register address from table
		LDR	r5, [r0, #CS_Bit]		; Obtain CS bit location from table

	[ debug
		Debug	swicalls, "Pages, bytes/page, flash reg., IO reg., CS bit =", r1, r2, r3, r4, r5
		Debug	swicalls, "Device info. complete"
	]
		EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Call:	SWI_1
;
; SWI:	SerialFlash_ReadPage
;
; In:	r0 =  device index number
;	r1 =  page number to read
;	r2 -> block for returned data
;	r3 =  size of block
;
; Out:	r0 - r2 preserved
;	r3 =  actual size of block required, if too small; preserved otherwise
;

SWI_1		; SWI SerialFlash_ReadPage

		ENTRY	"r0-r2, r4-r6"
	[ debug
		Debug	swicalls, "SWI call: ReadPage"
	]
		; Ascertain the device characteristics from the device table
		ADRL	r4, DeviceTable			; -> device table
		ADRL	r5, DeviceEntries		; -> number of device entries
		LDR	r5, [r5]			; Obtain number of devices
		CMP	r0, r5				; Is specified index within range?
		PullEnv	HS				; No?  Then restore stack
		BHS	error_deviceunavailable		; And execute error handling code

		MOV	r5, #Table_Col			; Obtain number of columns in table
		MOV	r5, r5, LSL #2			; Transform into bytes
		MUL	r0, r5, r0			; Calculate offset into table
		ADD	r0, r0, r4			; Add offset to base of table to locate required row
		LDR	r7, [r0, #Pages_In_Flash]	; Obtain number of pages from table
		LDR	r8, [r0, #Bytes_Per_Page]	; Obtain bytes per page from table
	[ debug
		Debug	swicalls, "Pages, bytes/page =", r7, r8
	]

		CMP	r1, r7				; Is specified page number in range?
		PullEnv	HS				; No?  Then restore stack
		BHS	error_invalidpage		; And execute error handling code
	[ debug
		Debug	swicalls, "Page number OK =", r1
	]

		CMP	r3, r8				; Is page memory block the correct size?
		MOVLT	r3, r8				; No?  Then return actual block size required
		PullEnv	LT				; Restore stack
		BLT	error_pageblocktoosmall		; And execute error handling code
	[ debug
		Debug	swicalls, "Page memory size OK =", r3
	]

		; Validation checks passed, so now the main code
		LDR	r6, [r0, #IO_Reg]		; Obtain address of I/O register from table
		LDR	r7, [r0, #Flash_Reg]		; Obtain address of flash register from table
		LDR	r9, [r0, #CS_Bit]		; Obtain CS bit location from table

		; Construct two 32-bit command registers (2 words)
		MOV	r1, r1, LSL #9			; Shift page number to correct position in word
		MOV	r4, #(Inst_PageRead:SHL:24)	; Obtain read instruction opcode and shift into top byte of word
		ORR	r1, r1, r4			; Merge the two registers to produce the 32-bit command register
	[ debug
		Debug	swicalls, "Command register =", r1
	]

		; Place command bytes into the flash register until done
		; First enable the flash IC (/CS line)
		LDRB	r5, [r6]			; Load current bit values
		BIC	r5, r5, r9			; Set /CS line active (=0)
		STRB	r5, [r6]			; Write result back
	[ debug
		Debug	swicalls, "Flash register address, CS bit =", r7, r9
		Debug	swicalls, "I/O register address, data =", r6, r5
	]

		; 1st word (8-bit opcode, 4-bit don't care, 11-bit page address, 9-bit byte offset)
		MOV	r5, #32				; Shift counter
00
		SUBS	r5, r5, #8			; Adjust shift value
		MOV	r4, r1, LSR r5			; } Obtain appropriate byte
		AND	r4, r4, #&FF			; } by shifting and masking
		STRB	r4, [r7]			; Pass the byte to the flash register location
	[ debug
		Debug	swicalls, "Shift, byte value =", r5, r4
	]
		BGT	%BT00				; Repeat until all command bytes written

		; 2nd word (32-bits, all don't cares (so set to 0))
		MOV	r4, #0				; Zero register
		MOV	r5, #4				; Initialise loop counter
10
		SUBS	r5, r5, #1			; Decrement counter
		STRB	r4, [r7]			; Pass the byte (00) to the flash register
	[ debug
		Debug	swicalls, "Loop count (don't cares) =", r5
	]
		BGT	%BT10				; Repeat until all command bytes written

		; Flash device now in read mode, and will start to pass data from the requested page
		MOV	r4, #0				; Zero temporary data register
		MOV	r5, r8				; Initialise byte counter (to byes per page value)
	[ debug
		Debug	swicalls, "Reading page..."
	]
20
		SUBS	r5, r5, #1			; Decrement counter
		LDRB	r4, [r7]			; Obtain byte from flash register
		STRB	r4, [r2], #1			; Store in block supplied by user, and increment block pointer
	[ debug
		SUB	r2, r2, #1			; Adjust R2 to correct the debug output!
		Debug	memoryblock, "Count, address, byte value =", r5, r2, r4
		ADD	r2, r2, #1			; Restore R2
	]
		BGT	%BT20				; Repeat until all bytes have been read

		; Disable the flash IC (/CS line)
		LDRB	r5, [r6]			; Load current bit values
		ORR	r5, r5, r9			; Set /CS line inactive (=1)
		STRB	r5, [r6]			; Write result back
	[ debug
		Debug	swicalls, "I/O register address, data =", r6, r5
		Debug	swicalls, "Page read complete"
	]
		EXIT					; Job done, so exit


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Call:	SWI_2
;
; SWI:	SerialFlash_WritePage
;
; In:	r0 =  device index number
;	r1 =  page number to read
;	r2 -> block containing data
;	r3 =  size of block
;
; Out:	r0 - r2 preserved
;	r3 =  actual size of block required, if too small; preserved otherwise
;

SWI_2		; SWI SerialFlash_WritePage
		ENTRY	"r0-r2, r4-r6"
	[ debug
		Debug	swicalls, "SWI call: WritePage"
	]
		; Ascertain the device characteristics from the device table
		ADRL	r4, DeviceTable			; -> device table
		ADRL	r5, DeviceEntries		; -> number of device entries
		LDR	r5, [r5]			; Obtain number of devices
		CMP	r0, r5				; Is specified index within range?
		PullEnv	HS				; No?  Then restore stack
		BHS	error_deviceunavailable		; And execute error handling code

		MOV	r5, #Table_Col			; Obtain number of columns in table
		MOV	r5, r5, LSL #2			; Transform into bytes
		MUL	r0, r5, r0			; Calculate offset into table
		ADD	r0, r0, r4			; Add offset to base of table to locate required row
		LDR	r7, [r0, #Pages_In_Flash]	; Obtain number of pages from table
		LDR	r8, [r0, #Bytes_Per_Page]	; Obtain bytes per page from table
	[ debug
		Debug	swicalls, "Pages, bytes/page =", r7, r8
	]

		CMP	r1, r7				; Is specified page number in range?
		PullEnv	HS				; No?  Then restore stack
		BHS	error_invalidpage		; And execute error handling code
	[ debug
		Debug	swicalls, "Page number OK =", r1
	]

		CMP	r3, r8				; Is page memory block the correct size?
		MOVLT	r3, r8				; No?  Then return actual block size required
		PullEnv	LT				; Restore stack
		BLT	error_pageblocktoosmall		; And execute error handling code
	[ debug
		Debug	swicalls, "Page memory size OK =", r3
	]

		; Validation checks passed, so now the main code
		LDR	r6, [r0, #IO_Reg]		; Obtain address of I/O register from table
		LDR	r7, [r0, #Flash_Reg]		; Obtain address of flash register from table
		LDR	r9, [r0, #CS_Bit]		; Obtain CS bit location from table

		; Construct 32-bit command register (1 word)
		MOV	r1, r1, LSL #9			; Shift page number to correct position in word
		MOV	r4, #(Inst_PageWrite:SHL:24)	; Obtain write instruction opcode and shift into top byte of word
		ORR	r1, r1, r4			; Merge the two registers to produce the 32-bit command register
	[ debug
		Debug	swicalls, "Command register =", r1
	]

		; Place command bytes into the flash register until done
		; First enable the flash IC (/CS line)
		LDRB	r5, [r6]			; Load current bit values
		BIC	r5, r5, r9			; Set /CS line active (=0)
		STRB	r5, [r6]			; Write result back
	[ debug
		Debug	swicalls, "Flash register address, CS bit =", r7, r9
		Debug	swicalls, "I/O register address, data =", r6, r5
	]

		; Command word (8-bit opcode, 4-bit don't care, 11-bit page address, 9-bit byte offset)
		MOV	r5, #32				; Shift counter
00
		SUBS	r5, r5, #8			; Adjust shift value
		MOV	r4, r1, LSR r5			; } Obtain appropriate byte
		AND	r4, r4, #&FF			; } by shifting and masking
		STRB	r4, [r7]			; Pass the byte to the flash register location
	[ debug
		Debug	swicalls, "Shift, byte value =", r5, r4
	]
		BGT	%BT00				; Repeat until all command bytes written

		; Flash device now in write mode, so start to pass the page data into the flash register
		MOV	r4, #0				; Zero temporary data register
		MOV	r5, r8				; Initialise byte counter (to bytes per page value)
	[ debug
		Debug	swicalls, "Writing page..."
	]
10
		SUBS	r5, r5, #1			; Decrement counter
		LDRB	r4, [r2], #1			; Obtain byte from block supplied by user, and increment block pointer
		STRB	r4, [r7]			; Pass the byte to the flash register
	[ debug
		SUB	r2, r2, #1			; Adjust R2 to correct the debug output!
		Debug	memoryblock, "Count, address, byte value =", r5, r2, r4
		ADD	r2, r2, #1			; Restore R2
	]
		BGT	%BT10				; Repeat until all bytes have been written

		; Delay to enable flash device to clock in last byte
		BL	delay				; Call the delay routine

		; Disable the flash IC (/CS line)
		LDRB	r5, [r6]			; Load current bit values
		ORR	r5, r5, r9			; Set /CS line inactive (=1)
		STRB	r5, [r6]			; Write result back
	[ debug
		Debug	swicalls, "I/O register address, data =", r6, r5
		Debug	swicalls, "Page write complete"
	]
		EXIT					; Job done, so exit


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Call:	SWI_3
;
; SWI:	SerialFlash_DeviceStatus
;
; In:	r0 =  device index number
;
; Out:	r0 preserved
;	r1 =  status (bit 7: 0 = ready, 1 = busy)
;

SWI_3		; SWI SerialFlash_DeviceStatus
		ENTRY	"r0, r2-r6"
	[ debug
		Debug	swicalls, "SWI call: DeviceStatus"
	]
		; Ascertain the device characteristics from the device table
		ADRL	r1, DeviceTable			; -> device table
		ADRL	r2, DeviceEntries		; -> number of device entries
		LDR	r2, [r2]			; Obtain number of devices
		CMP	r0, r2				; Is specified index within range?
		PullEnv	HS				; No?  Then restore stack
		BHS	error_deviceunavailable		; And execute error handling code

		MOV	r2, #Table_Col			; Obtain number of columns in table
		MOV	r2, r2, LSL #2			; Transform into bytes
		MUL	r0, r2, r0			; Calculate offset into table
		ADD	r0, r0, r1			; Add offset to base of table
		LDR	r2, [r0, #Flash_Reg]		; Obtain address of flash register from table
		LDR	r3, [r0, #CS_Bit]		; Obtain CS bit location from table
		LDR	r6, [r0, #IO_Reg]		; Obtain address of I/O register from table


		; First enable the flash IC (/CS line)
		LDRB	r5, [r6]			; Load current bit values
		BIC	r5, r5, r3			; Set /CS line active (=0)
		STRB	r5, [r6]			; Write result back
	[ debug
		Debug	swicalls, "Flash register, CS bit =", r2, r3
		Debug	swicalls, "I/O register address, data =", r6, r5
	]

		; Construct 8-bit command register
		MOV	r4, #Inst_Status		; Obtain status instruction opcode

		; Place command bytes into the flash register until done
		; Command word (8-bit opcode)
		STRB	r4, [r2]			; Pass the byte to the flash register location

		; Flash device now in status mode, so read the results
		LDRB	r1, [r2]			; Read the status and make it available to the caller
	[ debug
		Debug	swicalls, "Status register =", r1
	]

		; Disable the flash IC (/CS line)
		LDRB	r5, [r6]			; Load current bit values
		ORR	r5, r5, r3			; Set /CS line inactive (=1)
		STRB	r5, [r6]			; Write result back
	[ debug
		Debug	swicalls, "Flash register, CS bit =", r2, r3
		Debug	swicalls, "I/O register address, data =", r6, r5
		Debug	swicalls, "Status info. complete"
	]
		EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Timing delay loop
;
; This loop is used to provide a delay before the /CS line is released.  The method
; is, admittedly, horrific, but since (at present) the device does not provide adequate information
; on it's internal status it is currently the only way to ensure that read/write operations
; function correctly: sometimes adding a few NOPs is the only viable solution!!!  Ideally, the
; processor clock speed should be deduced in software and the delay set accordingly, but this is
; currently very difficult to achieve.
;
; NOTE: The loop iteration value is optimised for a 48MHz processor clock speed; if a faster processor
;       is used then the number of iterations around the loop must be increased linearly (update the
;       "Delay_Iterations" value at the top of this file).
;

delay
		ENTRY	"r0-r2"
	[ debug
		Debug	delayloop, "Delay loop..."
	]
		MOV	r0, #Delay_Iterations		; Obtain number of iterations (loop counter)
00
		SUBS	r0, r0, #1			; Decrement counter
		MOV	r0, r0				; NOP (do nothing)
		BGT	%BT00				; Repeat until counter reaches zero

		EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generic error handling code
;

error_deviceunavailable
		; Error handling: device unavailable
		ADDR	r0, ErrorBlock_SerialFlash_DeviceUnavailable
		DoError

error_invalidpage
		; Error handling: invalid page
		ADDR	r0, ErrorBlock_SerialFlash_InvalidPage
		DoError

error_pageblocktoosmall
		; Error handling: insufficient memory
		ADDR	r0, ErrorBlock_SerialFlash_PageBlockTooSmall
		DoError

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Generalised internationalisation routines, these ensure that messages files
; are correctly opened and then return the relevant data.
;
	[ international


; Attempt to open the messages file.

OpenMessages	ROUT

		Push	"r0-r3, lr"

		LDR	r3, Flags
		TST	r3, #f_WeHaveMessages		; Do we have an open messages block?
		Pull	"r0-r3, pc", NE, ^		; Yes, so don't bother again

		ADR	r0, MessagesWorkspace
		ADRL	r1, resource_file		; -> Path to be opened
		MOV	r2, #0				; Allocate some space in RMA
		SWI	XMessageTrans_OpenFile
		LDRVC	r3, Flags
		ORRVC	r3, r3, #f_WeHaveMessages
		STRVC	r3, Flags			; Assuming it worked mark as having messages

		Pull	"r0-r3, pc",,^			; Returning VC, VS from XSWI!


; Attempt to close the messages file.

CloseMessages	ROUT

		Push	"r0, lr"

		LDR	r0, Flags
		TST	r0, #f_WeHaveMessages		; Do we have any messages?
		Pull	"r0, pc", EQ, ^			; And return if not!

		ADR	r0, MessagesWorkspace
		SWI	XMessageTrans_CloseFile		; Yes, so close the file
		LDRVC	r0, Flags
		BICVC	r0, r0, #f_WeHaveMessages
		STRVC	r0, Flags			; Mark as we don't have them

		Pull	"r0, pc",,^


; Generate an error based on the error token given.  Does not assume that
; the messages file is open.  Will attempt to open it, then look it up.

MakeError	ROUT

		Push	"r1-r7, lr"

		LDR	r1, Flags
		TST	r1, #f_WeHaveMessages		; Has the messages file been closed?
		BLEQ	OpenMessages

		LDR	r1, Flags
		TST	r1, #f_WeHaveMessages
		Pull	"r1-r7, lr", EQ
		ORREQS	pc, lr, #V_bit			; If still not open then return with V set

		ADR	r1, MessagesWorkspace		; -> Message control block
		MOV	r2, #0
		MOV	r3, #0
		MOV	r4, #0
		MOV	r5, #0
		MOV	r6, #0
		MOV	r7, #0				; No substitution + use internal buffers
		SWI	XMessageTrans_ErrorLookup

		BL	CloseMessages			; Attempt to close the message file

		Pull	"r1-r7, pc"			; Return, r0 -> block, V set

	]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; Debug routines:
; 1) Display integer on screen
;
; Call:	display_int
;
; In:	R0 = value to be displayed
;
; Out:	-
;

	[ debug
display_int
		ENTRY	"r1-r2"

		SUB	r13, r13, #16			; Allocate workspace below stack
		MOV	r1, r13				; Pointer to workspace
		MOV	r2, #16				; Size of workspace
		SWI	XOS_ConvertInteger4		; Call conversion SWI
		SWIVC	OS_Write0			; Write the result to the screen
		ADD	r13, r13, #16			; Restore stack pointer

		EXITS
	]

; 2) Display hexadecimal number on screen
;
; Call:	display_hex
;
; In:	R0 = value to be displayed
;
; Out:	-
;

	[ debug
display_hex
		Push	"r1-r2, lr"			; Store registers
		SUB	r13, r13, #16			; Allocate workspace below stack
		MOV	r1, r13				; Pointer to workspace
		MOV	r2, #16				; Size of workspace
		SWI	XOS_ConvertHex8			; Call conversion SWI
		SWIVC	OS_Write0			; Write the result to the screen
		ADD	r13, r13, #16			; Restore stack pointer
		Pull	"r1-r2, pc",,^			; Restore registers
	]

; 3) Display all register values
;
; Call:	display_regs
;
; In:	-
;
; Out:	-
;

	[ debug
display_regs
		ENTRY

		Debug	showregs, "R0  =", r0
		Debug	showregs, "R1  =", r1
		Debug	showregs, "R2  =", r2
		Debug	showregs, "R3  =", r3
		Debug	showregs, "R4  =", r4
		Debug	showregs, "R5  =", r5
		Debug	showregs, "R6  =", r6
		Debug	showregs, "R7  =", r7
		Debug	showregs, "R8  =", r8
		Debug	showregs, "R9  =", r9
		Debug	showregs, "R10 =", r10
		Debug	showregs, "R11 =", r11
		Debug	showregs, "R12 =", r12
		Debug	showregs, "R13 =", r13
		Debug	showregs, "R14 =", r14
		Debug	showregs, "R15 =", r15

		EXIT
	]
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	[ debug
		InsertNDRDebugRoutines
	]

		END
