/*
 * IRhandset.c
 *
 * Module to read stuff from an IR handset and poke values into
 * the keyboard and mouse buffer as appropriate.
 *
 * Option to make arrow keys, menu and select simulate the mouse
 * or poke value into kbd buffer.
 *
 * - Now registers itself with KeyV and sends key up/down events
 *   (means we don't need to worry about auto-repeat)
 *
 * - changed to read codes from the Meridien controller (i.e. invert
 *   the bits)
 *
 * Chris Marshall 30/3/94
 *
 * 1.18 JRH Cooperates with the STBState module to do Online/Standby
 * 2.00 JRH New extended RC5 codes replace STB1 Meridian codes
 * 2.01 JRH Fixed bug which resulted in not getting off KeyV on finalisaion.
 *          Pause and Rewind had incorrect RC5->handset mappings.
 * 2.02 JRH Swallows F10 in keyboard buffer on initialisation
 *          Calls SWI STBState_Standby on Standby press when in Init and Final
 *          states, as well as when in On state

 *      CP  Disabled standby call to get over bug in STB22
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <math.h>

#include "kernel.h"
#include "swis.h"

#undef DEBUG
#undef DEBUGFILE		/* Messages go to a file. Doesn't really work */

#undef MOUSE			/* Embryonic mouse support: no */

#define FALSE 0
#define TRUE (!FALSE)

#define EventV 0x10
#define KeyV 0x13

#define BUFFERCODE_F10 0xCA

#define MOUSE_BUTTON_SELECT 0x4
#define MOUSE_BUTTON_MENU   0x2
#define MOUSE_BUTTON_ADJUST 0x1

#define ONLINE_CODE 0x0c
#define STANDBY_CODE 0x8c
#define NULL_CODE 0x7d
#define TOGGLE_BIT 0x80

#define EXTENDED_EXPANSION_SPACE 0x80000000
#define MPEG_CARD_OFFSET         0x08000000
#define MPEG_IR_OFFSET           0x00c00000
#define PODULE_SLOT		 0

/* Macro for getting the IR RC5 code including the toggle bit */
#define IR_READ ((int)*(char *)(EXTENDED_EXPANSION_SPACE + MPEG_CARD_OFFSET + MPEG_IR_OFFSET + (PODULE_SLOT << 24)))

#define MPEGVideo_CardControl	0x49305
#define STBState_Standby	0x4b404
#define STBState_State		0x4b405
#define STATE_LOWPOWER	1
#define STATE_FATAL	2
#define STATE_INIT	4
#define STATE_ON	6

typedef enum _Command { MAPLIST, MAP, RESET, CLEAR } Command;

typedef enum _MappingType { UNDEFINED, KEY, MOUSE_BUTTON, MOUSE_MOVE } MappingType ;

typedef enum _MouseButton { ADJUST = 1, MENU = 2, SELECT = 4 } MouseButton ;

char *mouse_button_names[] = {
                               "",
                               "ADJUST",
                               "MENU",
                               "",
                               "SELECT"
                             } ;


typedef enum _MouseMove { UP, DOWN, LEFT, RIGHT } MouseMove ;

typedef enum _KeyDir { KEYUP = 1, KEYDOWN = 2 } KeyDir ;

typedef enum _Modifier { NONE = 0, SHIFT = 0x4c, CTRL = 0x3b, ALT = 0x5e } Modifier ;

char *mouse_move_names[] = {
                             "UP",
                             "DOWN",
                             "LEFT",
                             "RIGHT"
} ;

typedef union _Action {
  int         key ;
  MouseButton mouse_button ;
  MouseMove   mouse_move ;
} Action ;

typedef struct _Mapping {
  MappingType type ;
  Action      action ;
  Modifier    modifier ;
} Mapping ;

Mapping IRmappings[256] ; /* Remote can't have more that this yet! */

typedef struct _Default {
  int  rc5 ;
  int  handset ;
  Mapping mapping ;
} Default ;

const Default defaults[] = {
/* RC5 handset	 type action modifier	   RC5   key    */
     1,    1,	{ KEY, 0x11, NONE },	/*  1	- 1	*/
     2,    2,	{ KEY, 0x12, NONE },	/*  2	- 2	*/
     3,    3,	{ KEY, 0x13, NONE },	/*  3	- 3	*/
     4,    4,	{ KEY, 0x14, NONE },	/*  4	- 4	*/
     5,    5,	{ KEY, 0x15, NONE },	/*  5	- 5	*/
     6,    6,	{ KEY, 0x16, NONE },	/*  6	- 6	*/
     7,    7,	{ KEY, 0x17, NONE },	/*  7	- 7	*/
     8,    8,	{ KEY, 0x18, NONE },	/*  8	- 8	*/
     9,    9,	{ KEY, 0x19, NONE },	/*  9	- 9	*/
    75,   75,	{ KEY, 0x24, NONE },	/*  *	- *	*/
     0,    0,	{ KEY, 0x1a, NONE },	/*  0	- 0	*/
    76,   76,	{ KEY, 0x25, NONE },	/*  #	- #	*/
    66,   10,	{ KEY, 0x01, NONE },	/* Help	- F1	*/
    65,   43,	{ KEY, 0x02, NONE },	/* Stat.- F2	*/
    67,   21,	{ KEY, 0x03, NONE },	/* Home	- F3	*/
    64,   29,	{ KEY, 0x04, NONE },	/* Back	- F4	*/
    33,   40,	{ KEY, 0x05, NONE },	/* Prev.- F5	*/
    48,   32,	{ KEY, 0x06, NONE },	/* Pause- F6	*/
    32,   41,	{ KEY, 0x07, NONE },	/* Next	- F7	*/
    50,   38,	{ KEY, 0x08, NONE },	/* Rew	- F8	*/
    53,   31,	{ KEY, 0x09, NONE },	/* Play	- F9	*/
    52,   35,	{ KEY, 0x0a, NONE },	/* FFwd.- F10	*/
    54,   30,	{ KEY, 0x0b, NONE },	/* Stop	- F11	*/
    80,   12,	{ KEY, 0x59, NONE },	/* Up	- Up	*/
    81,   28,	{ KEY, 0x63, NONE },	/* Down	- Down	*/
    85,   14,	{ KEY, 0x62, NONE },	/* Left	- Left	*/
    86,   20,	{ KEY, 0x64, NONE },	/* Right- Right	*/
    87,   15,	{ KEY, 0x67, NONE },	/* Sel.	- Ret.	*/
   107,   33,	{ KEY, 0x01, SHIFT },	/* Red	- S F1	*/
   108,   34,	{ KEY, 0x02, SHIFT },	/* Green- S F2	*/
   109,   36,	{ KEY, 0x03, SHIFT },	/* Yell.- S F3	*/
   110,   37,	{ KEY, 0x04, SHIFT },	/* Blue	- S F4	*/
   114,  114,	{ KEY, 0x21, NONE },	/* UpRgt- PgUp	*/
   115,  115,	{ KEY, 0x35, NONE },	/* DnLft- End	*/
   116,  116,	{ KEY, 0x20, NONE },	/* UpLft- Home	*/
   117,  117,	{ KEY, 0x36, NONE }	/* DnRgt- PgDn	*/
} ;

#define NUM_DEFAULTS (sizeof defaults / sizeof (Default))

void *private_word_pointer ;

_kernel_swi_regs regs ;
_kernel_oserror *e ;
_kernel_oserror err ;
char osword_block[9] ;

int last_code = NULL_CODE ;
int last_fire = 0 ;
int last_time = -1 ;
int remote_count = 0 ;
int mouse_step = 4 ;
int emulate_mouse = 1 ;
int first = FALSE ;

#ifdef DEBUG
#  ifdef DEBUGFILE
#    define OUTFILE outfile
FILE *outfile;
#  else
#    define OUTFILE stdout
#  endif
#endif

int keyv_ok = 0 ;
int on_keyv = 0 ;

/*
 * Forward function decls
 */

extern int IR_callevery_entry (_kernel_swi_regs *r, void *pw) ;
extern int IR_callback_entry (_kernel_swi_regs *r, void *pw) ;
extern int IR_keyv_entry (_kernel_swi_regs *r, void *pw) ;
void IR_write_LEDs (void) ;
void default_mappings (void) ;
void write_mpeg_control (int ctrl0, int ctrl1) ;
void fake_mouse_move (MouseMove where) ;

#ifdef MOUSE
void fake_mouse_click (MouseButton buttons) ;
#endif

void fake_key (int thing_pressed, KeyDir dir) ;

/*
 * Standard module routines
 */

void IR_modfinal (void)
{
  regs.r[0] = (int) IR_callevery_entry ;
  regs.r[1] = (int) private_word_pointer ;
  _kernel_swi (OS_RemoveTickerEvent, &regs, &regs) ;

  if (on_keyv)
  {
    regs.r[0] = KeyV ;
    regs.r[1] = (int) IR_keyv_entry ;
    regs.r[2] = (int) private_word_pointer ;
    _kernel_swi (OS_Release, &regs, &regs) ;
  }
}

_kernel_oserror *IR_modinit (char *cmd_tail, int podule_base, void *pw)
{
  int carry;
  private_word_pointer = pw;

#ifdef DEBUG
#  ifdef DEBUGFILE
  outfile = fopen("IRout", "w");
#  endif
  fprintf(OUTFILE, "IR module\n");
#endif

  /*
   * Wait for IR micro to take the online/standby code away
   * This relies on STBState having told the IR micro that the Standby key has
   * been noticed, by enabling the watchdog timer.
   */
  while ( (IR_READ & ~TOGGLE_BIT) == (ONLINE_CODE & ~TOGGLE_BIT) );

  regs.r[0] = 5 ; /* Every 5 centiseconds */
  regs.r[1] = (int) IR_callevery_entry ;
  regs.r[2] = (int) private_word_pointer ;
  if ((e = _kernel_swi (OS_CallEvery, &regs, &regs)) != NULL)
    return (e) ;

  regs.r[0] = KeyV ;
  regs.r[1] = (int) IR_keyv_entry ;
  regs.r[2] = (int) private_word_pointer ;
  if ((e = _kernel_swi (OS_Claim, &regs, &regs)) != NULL)
    return (e);
  on_keyv = 1 ;

  regs.r[0] = 0 ; /* kbd present */
  regs.r[1] = 2 ; /* PC-AT keyboard */
  regs.r[9] = KeyV ;
  if ((e = _kernel_swi (OS_CallAVector, &regs, &regs)) != NULL)
    return (e) ;

  default_mappings ();

  /* Flush initial F10 in keyboard buffer */
  regs.r[0] = 152;	/* reason = examine buffer status */
  regs.r[1] = 0;	/* keyboard buffer */
  _kernel_swi_c(OS_Byte, &regs, &regs, &carry);
  if ((regs.r[2] == BUFFERCODE_F10) && !carry)
  {
    regs.r[0] = 145;	/* reason = get byte from buffer */
    regs.r[1] = 0;	/* keyboard buffer */
    _kernel_swi(OS_Byte, &regs, &regs);
  }

  return NULL ;
}

int IR_keyv_handler (_kernel_swi_regs *r, void *pw)
{
  if (r->r[0] == 4)	/* Enable / flush drivers */
  {
    keyv_ok = 1 ;
    last_code = NULL_CODE;
#if 0			/* Eh? We shouldn't be getting off KeyV here */
    if (on_keyv)
    {
      regs.r[0] = KeyV ;
      regs.r[1] = (int) IR_keyv_entry ;
      regs.r[2] = (int) private_word_pointer ;
      _kernel_swi (OS_Release, &regs, &regs) ;
      on_keyv = 0 ;
    }
#endif
  }
  return (1) ; /* Pass on */
}

void IR_service_handler (int service_number, _kernel_swi_regs *r, void *pw)
{
  /*
   * We registered with CMHG for Service_Sleeping only, so we don't need to
   * check the service number here 'cos it will always be Sleeping
   *
   * Don't do anything if state is On; we're just going off and it might have
   * been us that turned us off
   */
  int code;

  /* Read twice to ensure value has settled */
  while ( (code = IR_READ) != IR_READ );

  if ( (r->r[0] != STATE_ON) && (code == ONLINE_CODE) )
  {
#ifdef DEBUG
    fprintf(OUTFILE, "IR:Service_Sleep, state=%d\n", r->r[0]);
#endif
    regs.r[0] = (int) IR_callback_entry;
    regs.r[1] = (int) private_word_pointer;
    _kernel_swi(OS_AddCallBack, &regs, &regs);

    r->r[1] = 0;	/* Claim the service */
  }
#ifdef DEBUG
  else
    fprintf(OUTFILE, ".");
#endif
}


int IR_callback_handler (_kernel_swi_regs *r, void *pw)
{
#ifdef DEBUG
  fprintf(OUTFILE, "IR:STBState_Standby\n");
#endif
/*
  14/4/97:CP:disabled due to bug in STB22s
  _kernel_swi(STBState_Standby, &regs, &regs);
*/

  return (1);
}


int IR_callevery_handler (_kernel_swi_regs *r, void *pw)
{
  int code;
#ifdef MOUSE
  unsigned char hor, ver, fire ;
#endif

  /* Read twice to ensure value has settled */
  while ( (code = IR_READ) != IR_READ );

  _kernel_swi (OS_ReadMonotonicTime, &regs, &regs) ;

  if (code == STANDBY_CODE && last_code != STANDBY_CODE)
  {
    _kernel_swi(STBState_State, &regs, &regs);
    if ((regs.r[0] == STATE_ON) || (regs.r[0] == STATE_FATAL) || (regs.r[0] == STATE_INIT))
    {
      regs.r[0] = (int) IR_callback_entry;
      regs.r[1] = (int) private_word_pointer;
      _kernel_swi(OS_AddCallBack, &regs, &regs);

      last_code = STANDBY_CODE;
    }
  }

  /* Clear toggle bit */
  code &= ~TOGGLE_BIT;

  if (code != NULL_CODE)
  {
    switch (IRmappings[code].type)
    {
      case KEY:
        if (code != last_code)
        {
          fake_key (IRmappings[last_code].action.key, KEYUP) ;
          if (IRmappings[last_code].modifier)
            fake_key (IRmappings[last_code].modifier, KEYUP) ;

          if (IRmappings[code].modifier)
            fake_key (IRmappings[code].modifier, KEYDOWN) ;
          fake_key (IRmappings[code].action.key, KEYDOWN) ;

        }
        break ;

    } /* Switch */

    last_code = code ;
    last_time = regs.r[0] ;
  }
  else if (last_code != NULL_CODE)
  {
    fake_key (IRmappings[last_code].action.key, KEYUP) ;
    if (IRmappings[last_code].modifier)
      fake_key (IRmappings[last_code].modifier, KEYUP) ;

    last_code = NULL_CODE;
    last_time = -1 ;
  }

#ifdef MOUSE
  if ((e = _kernel_swi (Joystick_Read, &regs, &regs)) == NULL)
  {
    /*
     * Joystick module there, move mouse based upon result
     */

    ver  = regs.r[0] & 0xff ;
    hor  = (regs.r[0] >> 8)  & 0xff ;
    fire = (regs.r[0] >> 16) & 0xff ;

    /*
     * Deal with fire button
     */

    if (fire == 0 && last_fire != 0)
    {
      /*
       * Fire button has gone up, therefore issue a key up event on select
       */
    }
    else if (fire != 0 && last_fire == 0)
    {
      /*
       * Fire button just gone down, issue key down event
       */
    }

    if (ver == 64)
    {
      /*
       * Up
       */
      fake_mouse_move (UP) ;
    }
    else if (ver == 192)
    {
      /*
       * Down
       */
      fake_mouse_move (DOWN) ;
    }

    if (hor == 64)
    {
      /*
       * Right
       */
      fake_mouse_move (RIGHT) ;
    }
    else if (hor == 192)
    {
      /*
       * Left
       */
      fake_mouse_move (LEFT) ;
    }

    last_fire = fire ;
  }
#endif

  return 1 ;
}


_kernel_oserror *IR_cmd (char *arg_string, int argc, int cmd_no, void *pw)
{
  int rc5, i ;

  switch (cmd_no)
  {
  case MAPLIST:
    /*
     * Dump mappings
     */
    for (rc5 = 0; rc5 < 255; rc5++)
    {
      switch (IRmappings[rc5].type)
      {
        case KEY:
          for (i=0 ; i < NUM_DEFAULTS ; i++)
            if (defaults[i].rc5 == rc5)
            {
              printf ("Handset code %d maps to key 0x%x (0x%x)\n", defaults[i].handset, IRmappings[rc5].action.key, (int) IRmappings[rc5].modifier) ;
              break;
            }
          break ;
#ifdef MOUSE
        case MOUSE_BUTTON:
          for (i=0 ; i < NUM_DEFAULTS ; i++)
            if (defaults[i].rc5 == rc5)
            {
          printf ("Handset code %d maps to %s mouse button\n", defaults[i].handset, mouse_button_names[IRmappings[rc5].action.mouse_button]) ;
             break;
            }
          break ;

        case MOUSE_MOVE:
          for (i=0 ; i < NUM_DEFAULTS ; i++)
            if (defaults[i].rc5 == rc5)
            {
          printf ("Handset code %d maps to %sward mouse movement\n", defaults[i].handset, mouse_move_names[IRmappings[rc5].action.mouse_move]) ;
             break;
            }
          break ;
#endif
      }
    }
    break;

  case MAP:
    {
      char *first_arg = arg_string ;
      char *second_arg ;
      char *third_arg ;
      char *fourth_arg ;
      char tmp[80] ;
      char tmp1[80] ;

      second_arg = strchr (first_arg, ' ') + 1 ;
      if (second_arg)
        third_arg = strchr (second_arg, ' ') + 1 ;
      else
        return NULL ;		/* FIXME: must try harder! */

      if (third_arg)
        fourth_arg = strchr (third_arg, ' ') + 1 ;

      strncpy (tmp, first_arg, (int) second_arg - (int) first_arg - 1) ;
      tmp[(int) second_arg - (int) first_arg - 1] = '\0' ;

      /* Evaluate handset code */
      regs.r[0] = (int) tmp ;
      regs.r[1] = 0 ;
      _kernel_swi (OS_EvaluateExpression, &regs, &regs) ;
#ifdef DEBUG
      printf("Handset code: %d\n", regs.r[2]);
#endif

      /* Find the RC5 code corresponding to the handset code */
      for (i = 0 ; i < NUM_DEFAULTS ; i++)
        if (defaults[i].handset == regs.r[2])
        {
          rc5 = defaults[i].rc5;
          break;
        }

      /* Done if none found */
      if (i == NUM_DEFAULTS)
        return (NULL);
#ifdef DEBUG
      printf("RC5 code: %d\n", rc5);
#endif

      switch (argc)
      {
        case 3:
        strncpy (tmp, second_arg, (int) third_arg - (int) second_arg - 1) ;
        tmp[(int) third_arg - (int) second_arg - 1] = '\0' ;
          strcpy (tmp1, third_arg) ;
          break ;

        case 4:
          strncpy (tmp, second_arg, (int) third_arg - (int) second_arg - 1) ;
          tmp[(int) third_arg - (int) second_arg - 1] = '\0' ;
          strncpy (tmp1, third_arg, (int) fourth_arg - (int) third_arg - 1) ;
          tmp1[(int) fourth_arg - (int) third_arg - 1] = '\0' ;
          break ;

        case 2:
          strcpy (tmp, second_arg) ;
          strcpy (tmp1, second_arg) ;
          break ;

        default:
          return NULL ;
          break ;
      }

      if (strncmp (tmp, "key", 3) == 0 && (argc == 3 || argc == 4) )
      {
        /* Evaluate keycode */
        regs.r[0] = (int) tmp1 ;
        regs.r[1] = 0 ;
        _kernel_swi (OS_EvaluateExpression, &regs, &regs) ;

        IRmappings[rc5].type = KEY ;
        IRmappings[rc5].action.key = regs.r[2] ;
        if (argc == 4)
        {
          if (strncmp (fourth_arg, "shift", 5) == 0)
            IRmappings[rc5].modifier = SHIFT ;
          else if (strncmp (fourth_arg, "ctrl", 4) == 0)
            IRmappings[rc5].modifier = CTRL ;
          else if (strncmp (fourth_arg, "alt", 3) == 0)
            IRmappings[rc5].modifier = ALT ;
          else
            IRmappings[rc5].modifier = NONE ;
        }
        else
        {
          IRmappings[rc5].modifier = NONE ;
        }
#ifdef DEBUG
        printf("Keycode: 0x%x (0x%x)\n", regs.r[2], IRmappings[rc5].modifier);
#endif
      }
#ifdef MOUSE
      else if (strncmp (tmp, "mousemove", 9) == 0 && argc == 3)
      {
        IRmappings[rc5].type = MOUSE_MOVE ;

        if (strncmp (third_arg, "up", 2) == 0)
          IRmappings[rc5].action.mouse_move = UP ;
        else if (strncmp (third_arg, "down", 4) == 0)
          IRmappings[rc5].action.mouse_move = DOWN ;
        else if (strncmp (third_arg, "left", 4) == 0)
          IRmappings[rc5].action.mouse_move = LEFT ;
        else if (strncmp (third_arg, "right", 5) == 0)
          IRmappings[rc5].action.mouse_move = RIGHT ;
        else
        {
          err.errnum = 0 ;
          strcpy (err.errmess, "Syntax:\tIRmap <handset code> mousemove up|down|left|right") ;
          return (&err) ;
        }
      }
      else if (strncmp (tmp, "mousebutton", 11) == 0 && argc == 3)
      {
        IRmappings[rc5].type = KEY ;
        IRmappings[rc5].modifier = NONE ;

        if (strncmp (third_arg, "select", 6) == 0)
          IRmappings[rc5].action.key = 0x07 ;
        else if (strncmp (third_arg, "menu", 4) == 0)
          IRmappings[rc5].action.key = 0x17 ;
        else if (strncmp (third_arg, "adjust", 6) == 0)
          IRmappings[rc5].action.key = 0x27 ;
        else
        {
          err.errnum = 0 ;
          strcpy (err.errmess, "Syntax:\tIRmap <handset code> mousebutton select|menu|adjust") ;
          return (&err) ;
        }
      }
#endif
      else if (strncmp (tmp, "cancel", 6) == 0 && argc == 2)
      {
#ifdef DEBUG
        printf("Used to map to 0x%x (0x%x)\n", IRmappings[rc5].action.key, IRmappings[rc5].modifier);
#endif
        IRmappings[rc5].type = UNDEFINED ;
      }
      else
      {
        err.errnum = 0 ;
        strcpy (err.errmess, "Invalid mapping type") ;
        return (&err) ;
      }
    }
    break;

  case RESET:
    default_mappings () ;
    break;

  case CLEAR:
    for (i = 0; i < 255; i++)
      IRmappings[i].type = UNDEFINED ;
    break;
  }

  return (NULL) ;
}

/*
 * Application specific routines
 */

void default_mappings (void)
{
  int i;

  /* Cursor keys act like function keys */
  regs.r[0] = 4;
  regs.r[1] = 2;
  _kernel_swi (OS_Byte, &regs, &regs);

  /* F10-F12 generate NULL followed by code */
  regs.r[0] = 221;
  regs.r[1] = 2;
  regs.r[2] = 0;
  _kernel_swi (OS_Byte, &regs, &regs);

  /* F1-F9, cursors and End generate NULL followed by code */
  regs.r[0] = 225;
  regs.r[1] = 2;
  regs.r[2] = 0;
  _kernel_swi (OS_Byte, &regs, &regs);

  /* PgUp and PgDn generate NULL followed by code */
  regs.r[0] = 226;
  regs.r[1] = 2;
  regs.r[2] = 0;
  _kernel_swi (OS_Byte, &regs, &regs);

  for (i = 0; i < NUM_DEFAULTS; i++)
  {
    IRmappings[defaults[i].rc5].type = defaults[i].mapping.type ;
    IRmappings[defaults[i].rc5].modifier = defaults[i].mapping.modifier ;
    IRmappings[defaults[i].rc5].action = defaults[i].mapping.action ;
  }
}

#ifdef MOUSE
void fake_mouse_move (MouseMove where)
{
  int xp, yp ;


  regs.r[0] = 21 ;
  regs.r[1] = (int) &osword_block ;
  osword_block[0] = 6 ; /* Read pointer position */
  _kernel_swi (OS_Word, &regs, &regs) ;

  regs.r[0] = 21 ;
  regs.r[1] = (int) &osword_block ;

  xp = ((osword_block[2] << 8) | osword_block[1]) ;
  yp = ((osword_block[4] << 8) | osword_block[3]) ;

  switch (where)
  {
    case UP:
      yp += mouse_step ;
      break ;

    case DOWN:
      yp -= mouse_step ;
      break ;

    case RIGHT:
      xp += mouse_step ;
      break ;

    case LEFT:
      xp -= mouse_step ;
      break ;
  }

  osword_block[1] = xp ;
  osword_block[2] = xp >> 8 ;
  osword_block[3] = yp ;
  osword_block[4] = yp >> 8 ;
  osword_block[0] = 5 ; /* Set pointer position */
  _kernel_swi (OS_Word, &regs, &regs) ;

  regs.r[0] = 21 ;
  regs.r[1] = (int) &osword_block ;
  osword_block[0] = 3 ; /* Set mouse position */
  _kernel_swi (OS_Word, &regs, &regs) ;
}
#endif

void fake_key (int thing_pressed, KeyDir dir)
{
  if (keyv_ok)
  {
    regs.r[0] = (int) dir ;
    regs.r[1] = thing_pressed ;
    regs.r[9] = KeyV ;
    _kernel_swi (OS_CallAVector, &regs, &regs) ;
  }
}
