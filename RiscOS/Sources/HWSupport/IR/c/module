/*
 * IRhandset.c
 *
 * Module to read stuff from an IR handset and poke values into
 * the keyboard and mouse buffer as appropriate.
 *
 * Option to make arrow keys, menu and select simulate the mouse
 * or poke value into kbd buffer.
 *
 * - Now registers itself with KeyV and sends key up/down events
 *   (means we don't need to worry about auto-repeat)
 *
 * - changed to read codes from the Meridien controller (i.e. invert
 *   the bits)
 *
 * Chris Marshall 30/3/94
 *
 * 1.18 JRH Cooperates with the STBState module to do Online/Standby
 * 2.00 JRH New extended RC5 codes replace STB1 Meridian codes
 * 2.01 JRH Fixed bug which resulted in not getting off KeyV on finalisaion.
 *          Pause and Rewind had incorrect RC5->handset mappings.
 * 2.02 JRH Swallows F10 in keyboard buffer on initialisation
 *          Calls SWI STBState_Standby on Standby press when in Init and Final
 *          states, as well as when in On state
 * 2.03 TMD Modify to cope with variable address of IR hardware between MPEG 1
 * 	    and MPEG 2 variants

16/7/97   CP   protected callback_handler() calls from stacking up.  Relies
               on flag callback_activeG being TRUE if callback pending.

21/7/97   CP   remove pending callbacks when module exits.

               2.04 released.

30/7/97   CP   Moved where Callback_ActiveG is changed slightly to minimise
               chances of callback stacking.

6/8/97    CP   Changed callevery handler so that STBState_Standby is called
               for _every_ Standby press! (Previously, the module expected a
               total reset, so never bothered to scan for a second, "turn
               back on" Standby keypress.... :-(  ).  IR micro does strange
               things too...

06/04/98  SMC  2.06 Added support for IR on the parallel port.

 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <math.h>

#include "kernel.h"
#include "swis.h"

#undef DEBUG
#undef DEBUGFILE		/* Messages go to a file. Doesn't really work */

#undef MOUSE			/* Embryonic mouse support: no */

#define FALSE 0
#define TRUE (!FALSE)

#define EventV 0x10
#define KeyV 0x13

#define BUFFERCODE_F10 0xCA

#define MOUSE_BUTTON_SELECT 0x4
#define MOUSE_BUTTON_MENU   0x2
#define MOUSE_BUTTON_ADJUST 0x1

#define ONLINE_CODE 0x0c
#define STANDBY_CODE 0x8c
#define NULL_CODE 0x7d
#define TOGGLE_BIT 0x80

#define PRODUCT_TYPE_STB2_MPEG0  0x0111
#define PRODUCT_TYPE_STB2_MPEG1  0x010E
#define PRODUCT_TYPE_STB1_MPEG2  0x010F
#define PRODUCT_TYPE_STB2_MPEG2  0x0121

#define MPEG1_IR_OFFSET          0x00c00000
#define MPEG2_IR_OFFSET		 0x00600000
#define PODULE_NUMBER		 0
#define PODULE_READINFO_EASILOGICAL 0x200

/* Macro for getting the IR RC5 code including the toggle bit */
#define IR_READ ((int)*ir_address)

#define MPEGVideo_CardControl	0x49305
#define STBState_Standby	0x4b404
#define STBState_State		0x4b405
#define STATE_LOWPOWER	1
#define STATE_FATAL	2
#define STATE_INIT	4
#define STATE_ON	6

typedef enum _Command { MAPLIST, MAP, RESET, CLEAR } Command;

typedef enum _MappingType { UNDEFINED, KEY, MOUSE_BUTTON, MOUSE_MOVE } MappingType ;

typedef enum _MouseButton { ADJUST = 1, MENU = 2, SELECT = 4 } MouseButton ;

char *mouse_button_names[] = {
                               "",
                               "ADJUST",
                               "MENU",
                               "",
                               "SELECT"
                             } ;


typedef enum _MouseMove { UP, DOWN, LEFT, RIGHT } MouseMove ;

typedef enum _KeyDir { KEYUP = 1, KEYDOWN = 2 } KeyDir ;

typedef enum _Modifier { NONE = 0, SHIFT = 0x4c, CTRL = 0x3b, ALT = 0x5e } Modifier ;

char *mouse_move_names[] = {
                             "UP",
                             "DOWN",
                             "LEFT",
                             "RIGHT"
} ;

typedef union _Action {
  int         key ;
  MouseButton mouse_button ;
  MouseMove   mouse_move ;
} Action ;

typedef struct _Mapping {
  MappingType type ;
  Action      action ;
  Modifier    modifier ;
} Mapping ;

Mapping IRmappings[256] ; /* Remote can't have more that this yet! */

typedef struct _Default {
  int  rc5 ;
  int  handset ;
  Mapping mapping ;
} Default ;

const Default defaults[] = {
/* RC5 handset	 type action modifier	   RC5   key    */
     1,    1,	{ KEY, 0x11, NONE },	/*  1	- 1	*/
     2,    2,	{ KEY, 0x12, NONE },	/*  2	- 2	*/
     3,    3,	{ KEY, 0x13, NONE },	/*  3	- 3	*/
     4,    4,	{ KEY, 0x14, NONE },	/*  4	- 4	*/
     5,    5,	{ KEY, 0x15, NONE },	/*  5	- 5	*/
     6,    6,	{ KEY, 0x16, NONE },	/*  6	- 6	*/
     7,    7,	{ KEY, 0x17, NONE },	/*  7	- 7	*/
     8,    8,	{ KEY, 0x18, NONE },	/*  8	- 8	*/
     9,    9,	{ KEY, 0x19, NONE },	/*  9	- 9	*/
    75,   75,	{ KEY, 0x24, NONE },	/*  *	- *	*/
     0,    0,	{ KEY, 0x1a, NONE },	/*  0	- 0	*/
    76,   76,	{ KEY, 0x25, NONE },	/*  #	- #	*/
    66,   10,	{ KEY, 0x01, NONE },	/* Help	- F1	*/
    65,   43,	{ KEY, 0x02, NONE },	/* Stat.- F2	*/
    67,   21,	{ KEY, 0x03, NONE },	/* Home	- F3	*/
    64,   29,	{ KEY, 0x04, NONE },	/* Back	- F4	*/
    33,   40,	{ KEY, 0x05, NONE },	/* Prev.- F5	*/
    48,   32,	{ KEY, 0x06, NONE },	/* Pause- F6	*/
    32,   41,	{ KEY, 0x07, NONE },	/* Next	- F7	*/
    50,   38,	{ KEY, 0x08, NONE },	/* Rew	- F8	*/
    53,   31,	{ KEY, 0x09, NONE },	/* Play	- F9	*/
    52,   35,	{ KEY, 0x0a, NONE },	/* FFwd.- F10	*/
    54,   30,	{ KEY, 0x0b, NONE },	/* Stop	- F11	*/
    80,   12,	{ KEY, 0x59, NONE },	/* Up	- Up	*/
    81,   28,	{ KEY, 0x63, NONE },	/* Down	- Down	*/
    85,   14,	{ KEY, 0x62, NONE },	/* Left	- Left	*/
    86,   20,	{ KEY, 0x64, NONE },	/* Right- Right	*/
    87,   15,	{ KEY, 0x67, NONE },	/* Sel.	- Ret.	*/
   107,   33,	{ KEY, 0x01, SHIFT },	/* Red	- S F1	*/
   108,   34,	{ KEY, 0x02, SHIFT },	/* Green- S F2	*/
   109,   36,	{ KEY, 0x03, SHIFT },	/* Yell.- S F3	*/
   110,   37,	{ KEY, 0x04, SHIFT },	/* Blue	- S F4	*/
   114,  114,	{ KEY, 0x21, NONE },	/* UpRgt- PgUp	*/
   115,  115,	{ KEY, 0x35, NONE },	/* DnLft- End	*/
   116,  116,	{ KEY, 0x20, NONE },	/* UpLft- Home	*/
   117,  117,	{ KEY, 0x36, NONE }	/* DnRgt- PgDn	*/
} ;

#define NUM_DEFAULTS (sizeof defaults / sizeof (Default))

void *private_word_pointer ;

_kernel_swi_regs regs ;
_kernel_oserror *e ;
_kernel_oserror err ;
char osword_block[9] ;

int last_code = NULL_CODE ;
int last_fire = 0 ;
int last_time = -1 ;
int remote_count = 0 ;
int mouse_step = 4 ;
int emulate_mouse = 1 ;
int first = FALSE ;

#ifdef DEBUG
#  ifdef DEBUGFILE
#    define OUTFILE outfile
FILE *outfile;
#  else
#    define OUTFILE stdout
#  endif
#endif

int keyv_ok = 0 ;
int on_keyv = 0 ;

volatile char *ir_address;
_kernel_oserror err_UnknownIRHardware = { 0, "Unknown IR hardware" };


/* 16/7/97:CP:flag to indicate pending callback */
static int callback_activeG = FALSE;

#ifdef PARALLEL
static int phandle = 0;
#endif

/*
 * Forward function decls
 */

extern int IR_callevery_entry (_kernel_swi_regs *r, void *pw) ;
extern int IR_callback_entry (_kernel_swi_regs *r, void *pw) ;
extern int IR_keyv_entry (_kernel_swi_regs *r, void *pw) ;
void IR_write_LEDs (void) ;
void default_mappings (void) ;
void write_mpeg_control (int ctrl0, int ctrl1) ;
void fake_mouse_move (MouseMove where) ;

#ifdef MOUSE
void fake_mouse_click (MouseButton buttons) ;
#endif

void fake_key (int thing_pressed, KeyDir dir) ;

/*
 * Standard module routines
 */

void IR_modfinal (void)
{
  regs.r[0] = (int) IR_callevery_entry ;
  regs.r[1] = (int) private_word_pointer ;
  _kernel_swi (OS_RemoveTickerEvent, &regs, &regs) ;

  if (on_keyv)
  {
    regs.r[0] = KeyV ;
    regs.r[1] = (int) IR_keyv_entry ;
    regs.r[2] = (int) private_word_pointer ;
    _kernel_swi (OS_Release, &regs, &regs) ;
  }

/* 21/7/97:CP:remove pending callback */
  if( callback_activeG == TRUE )
  {
    regs.r[0] = (int) IR_callback_entry;
    regs.r[1] = (int) private_word_pointer;
    _kernel_swi(OS_RemoveCallBack, &regs, &regs);

    callback_activeG = FALSE;
  }

#ifdef PARALLEL
  if (phandle != 0)
  {
    regs.r[0] = 0;
    regs.r[1] = phandle;
    _kernel_swi (OS_Find, &regs, &regs);
  }
#endif
}

_kernel_oserror *IR_modinit (char *cmd_tail, int podule_base, void *pw)
{
  int carry;
  char podule_header_buffer[16];
  int product_type;
  int ir_offset;

  private_word_pointer = pw;

#ifndef PARALLEL
     _swix(OS_WriteC, _IN(0), 22);
     _swix(OS_WriteC, _IN(0), 12);
#endif

#ifdef DEBUG
#  ifdef DEBUGFILE
  outfile = fopen("IRout", "w");
#  endif
  fprintf(OUTFILE, "IR module\n");
#endif

#ifndef PARALLEL

  /* Before we access the IR micro, we first have to find its address,
   * since the IR hardware moved to a different address on MPEG 2 machines.
   */

  regs.r[2] = (int) podule_header_buffer;
  regs.r[3] = (int) PODULE_NUMBER;
  e = _kernel_swi (Podule_ReadHeader, &regs, &regs);
  if (e) return (e);
  product_type = ((int) podule_header_buffer[3]) | ( ((int) podule_header_buffer[4]) << 8);
  switch (product_type)
  {
      case PRODUCT_TYPE_STB2_MPEG0:		/* STB 2 with no MPEG */
      case PRODUCT_TYPE_STB2_MPEG1:		/* STB 2 with MPEG 1 */
      	   ir_offset = MPEG1_IR_OFFSET;
      	   break;

      case PRODUCT_TYPE_STB1_MPEG2:		/* STB 1 with MPEG 2 podule */
      case PRODUCT_TYPE_STB2_MPEG2:		/* STB 2 with MPEG 2        */
      	   ir_offset = MPEG2_IR_OFFSET;
      	   break;
      default:
           return (&err_UnknownIRHardware);
  }

  /* Now read address of base of EASI space for podule */
  regs.r[0] = PODULE_READINFO_EASILOGICAL;
  regs.r[1] = (int)&ir_address;			/* address to return value into */
  regs.r[2] = 4;
  regs.r[3] = PODULE_NUMBER;
  e = _kernel_swi (Podule_ReadInfo, &regs, &regs);
  if (e) return (e);
  ir_address += ir_offset;

#else

  if ((e = _kernel_swi (Parallel_HardwareAddress, &regs, &regs)) != NULL)
  {
    return e;
  }
  ir_address = (volatile char *)regs.r[0];
  regs.r[0] = 0x4F;
  regs.r[1] = (int)"parallel:";
  regs.r[2] = 0;
  if ((e = _kernel_swi (OS_Find, &regs, &regs)) != NULL)
  {
    return e;
  }
  phandle = regs.r[0];

#endif

  /*
   * Wait for IR micro to take the online/standby code away
   * This relies on STBState having told the IR micro that the Standby key has
   * been noticed, by enabling the watchdog timer.
   */
  while ( (IR_READ & ~TOGGLE_BIT) == (ONLINE_CODE & ~TOGGLE_BIT) );

  regs.r[0] = 5 ; /* Every 5 centiseconds */
  regs.r[1] = (int) IR_callevery_entry ;
  regs.r[2] = (int) private_word_pointer ;
  if ((e = _kernel_swi (OS_CallEvery, &regs, &regs)) != NULL)
  {
    return (e) ;
  }

  regs.r[0] = KeyV ;
  regs.r[1] = (int) IR_keyv_entry ;
  regs.r[2] = (int) private_word_pointer ;
  if ((e = _kernel_swi (OS_Claim, &regs, &regs)) != NULL)
  {
    return (e);
  }

  on_keyv = 1 ;

  regs.r[0] = 0 ; /* kbd present */
  regs.r[1] = 2 ; /* PC-AT keyboard */
  regs.r[9] = KeyV ;
  if ((e = _kernel_swi (OS_CallAVector, &regs, &regs)) != NULL)
    return (e) ;

  default_mappings ();

  /* Flush initial F10 in keyboard buffer */
  regs.r[0] = 152;	/* reason = examine buffer status */
  regs.r[1] = 0;	/* keyboard buffer */
  _kernel_swi_c(OS_Byte, &regs, &regs, &carry);
  if ((regs.r[2] == BUFFERCODE_F10) && !carry)
  {
    regs.r[0] = 145;	/* reason = get byte from buffer */
    regs.r[1] = 0;	/* keyboard buffer */
    _kernel_swi(OS_Byte, &regs, &regs);
  }

  return NULL ;
}

int IR_keyv_handler (_kernel_swi_regs *r, void *pw)
{
  if (r->r[0] == 4)	/* Enable / flush drivers */
  {
    keyv_ok = 1 ;
    last_code = NULL_CODE;
#if 0			/* Eh? We shouldn't be getting off KeyV here */
    if (on_keyv)
    {
      regs.r[0] = KeyV ;
      regs.r[1] = (int) IR_keyv_entry ;
      regs.r[2] = (int) private_word_pointer ;
      _kernel_swi (OS_Release, &regs, &regs) ;
      on_keyv = 0 ;
    }
#endif
  }
  return (1) ; /* Pass on */
}

void IR_service_handler (int service_number, _kernel_swi_regs *r, void *pw)
{
  /*
   * We registered with CMHG for Service_Sleeping only, so we don't need to
   * check the service number here 'cos it will always be Sleeping
   *
   * Don't do anything if state is On; we're just going off and it might have
   * been us that turned us off
   */
  int code;

  /* Read twice to ensure value has settled */
  while ( (code = IR_READ) != IR_READ );

  if ( (r->r[0] != STATE_ON) && (code == ONLINE_CODE) )
  {
#ifdef DEBUG
    fprintf(OUTFILE, "IR:Service_Sleep, state=%d\n", r->r[0]);
#endif

/* 16/7/97:CP:added callback goof-proofing */
    if(callback_activeG == FALSE)
    {
      /* no callback pending, so set one up */
       callback_activeG = TRUE;

       regs.r[0] = (int) IR_callback_entry;
       regs.r[1] = (int) private_word_pointer;
       _kernel_swi(OS_AddCallBack, &regs, &regs);
    }

    r->r[1] = 0;	/* Claim the service */
  }
#ifdef DEBUG
  else
    fprintf(OUTFILE, ".");
#endif
}


int IR_callback_handler (_kernel_swi_regs *r, void *pw)
{
#ifdef DEBUG
  fprintf(OUTFILE, "IR:STBState_Standby\n");
#endif

  if(callback_activeG == TRUE) /* paranoia never hurt anyone ;-) */
  {
     _kernel_swi(STBState_Standby, &regs, &regs);

     callback_activeG = FALSE;
  }

  return (1);
}


int IR_callevery_handler (_kernel_swi_regs *r, void *pw)
{
  int code;
#ifdef MOUSE
  unsigned char hor, ver, fire ;
#endif

  /* Read twice to ensure value has settled */
  while ( (code = IR_READ) != IR_READ );


  _kernel_swi (OS_ReadMonotonicTime, &regs, &regs);


/* 11/8/97:CP:Standby multiple keypress fix

IR micro does strange things with standby mode - it has its own state
machine.  When standby is first pressed, it will send 8C from then on, until
it is pressed again, when it will send a continuous stream of 0C until the
"awake" line is asserted (toggled?).

So watch for byte xC, and process that based on the following (think about
the key sequence xx xx xx 8C 8C 8C 8C 0C 0C 0C ):
                         ^           ^
                         |           |
                       stdby       stdby


if (code toggle bit set) and (last_code != Standby code (0C))
{
  standby just pressed; call STBState_Standby, set last_code to Standby code
}

if (code toggle bit set) and (last_code == Standby)
{
   standby still active; do nothing
}

if (code toggle bit clear) and (last_code == Standby)
{
  standby over - call STBState_Standby
}



*/
  if( (code & ~TOGGLE_BIT) == 0xc)
  {

#ifdef DEBUG
    char dummy;

    printf("Received standby button %x\n", code);
    gets(&dummy);
#endif

    if( (  (code & TOGGLE_BIT) && (last_code != STANDBY_CODE) ) ||
        ( !(code & TOGGLE_BIT) && (last_code == STANDBY_CODE) ) )
    {

#ifdef DEBUG
       printf("Standby SWI called\n");
       gets(&dummy);
#endif

   /* 16/7/97:CP:added goof-proofing around callback */
       if(callback_activeG == FALSE)
       {
         /* no callback pending, so set one up */
          callback_activeG = TRUE;

          regs.r[0] = (int) IR_callback_entry;
          regs.r[1] = (int) private_word_pointer;

          _kernel_swi(OS_AddCallBack, &regs, &regs);
       }

    }

    last_code = code;
  }



  else
  {
      /* Clear toggle bit */
      code &= ~TOGGLE_BIT;

      if (code != NULL_CODE)
      {
        switch (IRmappings[code].type)
        {
          case KEY:
            if (code != last_code)
            {

              fake_key (IRmappings[last_code].action.key, KEYUP) ;

              if (IRmappings[last_code].modifier)
              {
                fake_key (IRmappings[last_code].modifier, KEYUP) ;
              }

              if (IRmappings[code].modifier)
              {
                fake_key (IRmappings[code].modifier, KEYDOWN) ;
              }

              fake_key (IRmappings[code].action.key, KEYDOWN) ;

            }
            break ;

        } /* Switch */

        last_code = code ;
        last_time = regs.r[0] ;
      }

      else if (last_code != NULL_CODE)
      {
         fake_key (IRmappings[last_code].action.key, KEYUP) ;

         if (IRmappings[last_code].modifier)
         {
           fake_key (IRmappings[last_code].modifier, KEYUP) ;
         }

        last_code = NULL_CODE;
        last_time = -1 ;
      }
  }

#ifdef MOUSE
  if ((e = _kernel_swi (Joystick_Read, &regs, &regs)) == NULL)
  {
    /*
     * Joystick module there, move mouse based upon result
     */

    ver  = regs.r[0] & 0xff ;
    hor  = (regs.r[0] >> 8)  & 0xff ;
    fire = (regs.r[0] >> 16) & 0xff ;

    /*
     * Deal with fire button
     */

    if (fire == 0 && last_fire != 0)
    {
      /*
       * Fire button has gone up, therefore issue a key up event on select
       */
    }
    else if (fire != 0 && last_fire == 0)
    {
      /*
       * Fire button just gone down, issue key down event
       */
    }

    if (ver == 64)
    {
      /*
       * Up
       */
      fake_mouse_move (UP) ;
    }
    else if (ver == 192)
    {
      /*
       * Down
       */
      fake_mouse_move (DOWN) ;
    }

    if (hor == 64)
    {
      /*
       * Right
       */
      fake_mouse_move (RIGHT) ;
    }
    else if (hor == 192)
    {
      /*
       * Left
       */
      fake_mouse_move (LEFT) ;
    }

    last_fire = fire ;
  }
#endif

  return 1 ;
}


_kernel_oserror *IR_cmd (char *arg_string, int argc, int cmd_no, void *pw)
{
  int rc5, i ;

  switch (cmd_no)
  {
  case MAPLIST:
    /*
     * Dump mappings
     */
    for (rc5 = 0; rc5 < 255; rc5++)
    {
      switch (IRmappings[rc5].type)
      {
        case KEY:
          for (i=0 ; i < NUM_DEFAULTS ; i++)
            if (defaults[i].rc5 == rc5)
            {
              printf ("Handset code %d maps to key 0x%x (0x%x)\n", defaults[i].handset, IRmappings[rc5].action.key, (int) IRmappings[rc5].modifier) ;
              break;
            }
          break ;
#ifdef MOUSE
        case MOUSE_BUTTON:
          for (i=0 ; i < NUM_DEFAULTS ; i++)
            if (defaults[i].rc5 == rc5)
            {
          printf ("Handset code %d maps to %s mouse button\n", defaults[i].handset, mouse_button_names[IRmappings[rc5].action.mouse_button]) ;
             break;
            }
          break ;

        case MOUSE_MOVE:
          for (i=0 ; i < NUM_DEFAULTS ; i++)
            if (defaults[i].rc5 == rc5)
            {
          printf ("Handset code %d maps to %sward mouse movement\n", defaults[i].handset, mouse_move_names[IRmappings[rc5].action.mouse_move]) ;
             break;
            }
          break ;
#endif
      }
    }
    break;

  case MAP:
    {
      char *first_arg = arg_string ;
      char *second_arg ;
      char *third_arg ;
      char *fourth_arg ;
      char tmp[80] ;
      char tmp1[80] ;

      second_arg = strchr (first_arg, ' ') + 1 ;
      if (second_arg)
        third_arg = strchr (second_arg, ' ') + 1 ;
      else
        return NULL ;		/* FIXME: must try harder! */

      if (third_arg)
        fourth_arg = strchr (third_arg, ' ') + 1 ;

      strncpy (tmp, first_arg, (int) second_arg - (int) first_arg - 1) ;
      tmp[(int) second_arg - (int) first_arg - 1] = '\0' ;

      /* Evaluate handset code */
      regs.r[0] = (int) tmp ;
      regs.r[1] = 0 ;
      _kernel_swi (OS_EvaluateExpression, &regs, &regs) ;
#ifdef DEBUG
      printf("Handset code: %d\n", regs.r[2]);
#endif

      /* Find the RC5 code corresponding to the handset code */
      for (i = 0 ; i < NUM_DEFAULTS ; i++)
        if (defaults[i].handset == regs.r[2])
        {
          rc5 = defaults[i].rc5;
          break;
        }

      /* Done if none found */
      if (i == NUM_DEFAULTS)
        return (NULL);
#ifdef DEBUG
      printf("RC5 code: %d\n", rc5);
#endif

      switch (argc)
      {
        case 3:
        strncpy (tmp, second_arg, (int) third_arg - (int) second_arg - 1) ;
        tmp[(int) third_arg - (int) second_arg - 1] = '\0' ;
          strcpy (tmp1, third_arg) ;
          break ;

        case 4:
          strncpy (tmp, second_arg, (int) third_arg - (int) second_arg - 1) ;
          tmp[(int) third_arg - (int) second_arg - 1] = '\0' ;
          strncpy (tmp1, third_arg, (int) fourth_arg - (int) third_arg - 1) ;
          tmp1[(int) fourth_arg - (int) third_arg - 1] = '\0' ;
          break ;

        case 2:
          strcpy (tmp, second_arg) ;
          strcpy (tmp1, second_arg) ;
          break ;

        default:
          return NULL ;
          break ;
      }

      if (strncmp (tmp, "key", 3) == 0 && (argc == 3 || argc == 4) )
      {
        /* Evaluate keycode */
        regs.r[0] = (int) tmp1 ;
        regs.r[1] = 0 ;
        _kernel_swi (OS_EvaluateExpression, &regs, &regs) ;

        IRmappings[rc5].type = KEY ;
        IRmappings[rc5].action.key = regs.r[2] ;
        if (argc == 4)
        {
          if (strncmp (fourth_arg, "shift", 5) == 0)
            IRmappings[rc5].modifier = SHIFT ;
          else if (strncmp (fourth_arg, "ctrl", 4) == 0)
            IRmappings[rc5].modifier = CTRL ;
          else if (strncmp (fourth_arg, "alt", 3) == 0)
            IRmappings[rc5].modifier = ALT ;
          else
            IRmappings[rc5].modifier = NONE ;
        }
        else
        {
          IRmappings[rc5].modifier = NONE ;
        }
#ifdef DEBUG
        printf("Keycode: 0x%x (0x%x)\n", regs.r[2], IRmappings[rc5].modifier);
#endif
      }
#ifdef MOUSE
      else if (strncmp (tmp, "mousemove", 9) == 0 && argc == 3)
      {
        IRmappings[rc5].type = MOUSE_MOVE ;

        if (strncmp (third_arg, "up", 2) == 0)
          IRmappings[rc5].action.mouse_move = UP ;
        else if (strncmp (third_arg, "down", 4) == 0)
          IRmappings[rc5].action.mouse_move = DOWN ;
        else if (strncmp (third_arg, "left", 4) == 0)
          IRmappings[rc5].action.mouse_move = LEFT ;
        else if (strncmp (third_arg, "right", 5) == 0)
          IRmappings[rc5].action.mouse_move = RIGHT ;
        else
        {
          err.errnum = 0 ;
          strcpy (err.errmess, "Syntax:\tIRmap <handset code> mousemove up|down|left|right") ;
          return (&err) ;
        }
      }
      else if (strncmp (tmp, "mousebutton", 11) == 0 && argc == 3)
      {
        IRmappings[rc5].type = KEY ;
        IRmappings[rc5].modifier = NONE ;

        if (strncmp (third_arg, "select", 6) == 0)
          IRmappings[rc5].action.key = 0x07 ;
        else if (strncmp (third_arg, "menu", 4) == 0)
          IRmappings[rc5].action.key = 0x17 ;
        else if (strncmp (third_arg, "adjust", 6) == 0)
          IRmappings[rc5].action.key = 0x27 ;
        else
        {
          err.errnum = 0 ;
          strcpy (err.errmess, "Syntax:\tIRmap <handset code> mousebutton select|menu|adjust") ;
          return (&err) ;
        }
      }
#endif
      else if (strncmp (tmp, "cancel", 6) == 0 && argc == 2)
      {
#ifdef DEBUG
        printf("Used to map to 0x%x (0x%x)\n", IRmappings[rc5].action.key, IRmappings[rc5].modifier);
#endif
        IRmappings[rc5].type = UNDEFINED ;
      }
      else
      {
        err.errnum = 0 ;
        strcpy (err.errmess, "Invalid mapping type") ;
        return (&err) ;
      }
    }
    break;

  case RESET:
    default_mappings () ;
    break;

  case CLEAR:
    for (i = 0; i < 255; i++)
      IRmappings[i].type = UNDEFINED ;
    break;
  }

  return (NULL) ;
}

/*
 * Application specific routines
 */

void default_mappings (void)
{
  int i;

  /* Cursor keys act like function keys */
  regs.r[0] = 4;
  regs.r[1] = 2;
  _kernel_swi (OS_Byte, &regs, &regs);

  /* F10-F12 generate NULL followed by code */
  regs.r[0] = 221;
  regs.r[1] = 2;
  regs.r[2] = 0;
  _kernel_swi (OS_Byte, &regs, &regs);

  /* F1-F9, cursors and End generate NULL followed by code */
  regs.r[0] = 225;
  regs.r[1] = 2;
  regs.r[2] = 0;
  _kernel_swi (OS_Byte, &regs, &regs);

  /* PgUp and PgDn generate NULL followed by code */
  regs.r[0] = 226;
  regs.r[1] = 2;
  regs.r[2] = 0;
  _kernel_swi (OS_Byte, &regs, &regs);

  for (i = 0; i < NUM_DEFAULTS; i++)
  {
    IRmappings[defaults[i].rc5].type = defaults[i].mapping.type ;
    IRmappings[defaults[i].rc5].modifier = defaults[i].mapping.modifier ;
    IRmappings[defaults[i].rc5].action = defaults[i].mapping.action ;
  }
}

#ifdef MOUSE
void fake_mouse_move (MouseMove where)
{
  int xp, yp ;


  regs.r[0] = 21 ;
  regs.r[1] = (int) &osword_block ;
  osword_block[0] = 6 ; /* Read pointer position */
  _kernel_swi (OS_Word, &regs, &regs) ;

  regs.r[0] = 21 ;
  regs.r[1] = (int) &osword_block ;

  xp = ((osword_block[2] << 8) | osword_block[1]) ;
  yp = ((osword_block[4] << 8) | osword_block[3]) ;

  switch (where)
  {
    case UP:
      yp += mouse_step ;
      break ;

    case DOWN:
      yp -= mouse_step ;
      break ;

    case RIGHT:
      xp += mouse_step ;
      break ;

    case LEFT:
      xp -= mouse_step ;
      break ;
  }

  osword_block[1] = xp ;
  osword_block[2] = xp >> 8 ;
  osword_block[3] = yp ;
  osword_block[4] = yp >> 8 ;
  osword_block[0] = 5 ; /* Set pointer position */
  _kernel_swi (OS_Word, &regs, &regs) ;

  regs.r[0] = 21 ;
  regs.r[1] = (int) &osword_block ;
  osword_block[0] = 3 ; /* Set mouse position */
  _kernel_swi (OS_Word, &regs, &regs) ;
}
#endif

void fake_key (int thing_pressed, KeyDir dir)
{
  if (keyv_ok)
  {
    regs.r[0] = (int) dir ;
    regs.r[1] = thing_pressed ;
    regs.r[9] = KeyV ;
    _kernel_swi (OS_CallAVector, &regs, &regs) ;
  }
}
