        SUBT    Task code -> Source.Task

; Change record
; =============
;
; CDP - Christopher Partington, Cambridge Systems Design
;
;
; 29-Jan-92  12:50  CDP
; First version.
;
; 04-Feb-92  16:21  CDP
; UpdateIcon now saves output registers from OS_SpriteOp SWI switching output
; to sprite and uses those values to restore previous output state when
; finished with sprite.
;
; 13-Feb-92  12:12  CDP
; Changed CalcPercent to make use of battery life (as well as capacity) in
; calculations dependent on UseLifeToCalculatePercent assembly variable.
;
; 20-Feb-92  11:26  CDP
; Changed CMOS bit used to determine whether to show icon on startup from
; bit2 to bit0.
;
; 03-Mar-92  14:52  CDP
; MakeMenu changed to grey-out SetChargeState option if there is no battery
; or the charger is connected.
; WE_Null now only calls UpdateIcon if CalcPercent succeeded.
;
; 11-Mar-92  12:58  CDP
; Warn now saves token pointer *after* call to WarnText (which destroys it)
; and reloads original pointer since MessageTrans_Lookup corrupts R1, contrary
; to documentation.
;
; 02-Apr-92  10:40  CDP
; New specification: rewrite started.
; New menu structure, new sprite/text icon, new method of calculation of
; remaining charge etc..
;
; 13-May-92  14:21  CDP
; Rewrite continues.
; Added code to use/initialise estimate when appropriate.
; ADJUST keeps menu structure open.
; MENU acts like SELECT in menu structure.
; Presence of "Estimate" below icon sorted out.
; Code could do with tidying.
;
; 19-May-92  12:16  CDP
; Define new VersionStr here for Info box (format is meant to be different to
; module help string.
; Only reopen menu structure when ADJUST used if the icon is still present
; (i.e. Remove Icon was not selected).
;
; 20-May-92  12:08  CDP
; UpdateIcon no longer calls ColourTrans to invalidate cache (RISC OS 3
; ColourTrans does not need this, unlike RISC OS 2).
;
;
;*End of change record*

;******************************************************************************

TaskDescription DCB     "Battery Manager",0

 [ Test
VersionStr      DCB     "$version ($date) $time"
 |
VersionStr      DCB     "$version ($vdayno-$vmon-",vyear:RIGHT:2,")"
 ]
                DCB     0               ; terminator


SpriteValidation        DCB     "S"
SpriteName              DCB     "batmgr",0


; Window names in templates file

WinName_ProgInfo        DCB     "ProgInfo",0
WinName_Warning         DCB     "Warning",0


; Message tokens

MToken_BatLow           DCB     "BatLow",0
MToken_ChgFault         DCB     "ChgFault",0
MToken_Estimated        DCB     "EstChg",0
MToken_CycleZero        DCB     "CycN",0


; Menu structure for MessageTrans
; Note: the disc entry is removed by shuffling the other entries up
; when no IDE hard discs are present
;
; *** DO NOT REORDER ITEMS WITHOUT CHECKING CODE THAT SHUFFLES ***

                ALIGN
IconBarMenuDef
IconBarMenu     Menu    MT1
M1O_Info        Item    M1I1
M1O_Estimate    Item    M1I2
 [ CycleBattery
M1O_Cycle       Item    M1I7
 ]
M1O_Disc        Item    M1I3
 [ PowerDown_SerialParallel
M1O_Serial      Item    M1I4
M1O_Parallel    Item    M1I5
 ]
M1O_Remove      Item    M1I6
 [ PowerDown_SerialParallel
  [ CycleBattery
                ASSERT  IconBarMenuItems = 7
  |
                ASSERT  IconBarMenuItems = 6
  ]
 |
  [ CycleBattery
                ASSERT  IconBarMenuItems = 5
  |
                ASSERT  IconBarMenuItems = 4
  ]
 ]
                DCB     0               ; terminates menu list

                ALIGN
EstimateMenuDef
EstimateMenu    Menu    MT2
M2O_Full        Item    M2I1
M2O_3Quarters   Item    M2I2
M2O_Half        Item    M2I3
M2O_1Quarter    Item    M2I4
M2O_Empty       Item    M2I5
                ASSERT  EstimateMenuItems = 5
                DCB     0               ; terminates menu list

 [ CycleBattery
                ALIGN
CycleMenuDef
CycleMenu       Menu    MT3
M3O_1           Item    M3I1
M3O_2           Item    M3I2
M3O_3           Item    M3I3
M3O_4           Item    M3I4
M3O_Abort       Item    M3I5
                ASSERT  CycleMenuItems = 5
                DCB     0               ; terminates menu list
 ]

; Menu option numbers for Menu 1
;    IDE discs > 0

                ^       0
M1A_ON_Info     #       1
M1A_ON_Estimate #       1
 [ CycleBattery
M1A_ON_Cycle    #       1
 ]
M1A_ON_Disc     #       1
 [ PowerDown_SerialParallel
M1A_ON_Serial   #       1
M1A_ON_Parallel #       1
 ]
M1A_ON_Remove   #       1

;    IDE discs = 0

                ^       0
M1B_ON_Info     #       1
M1B_ON_Estimate #       1
 [ CycleBattery
M1B_ON_Cycle    #       1
 ]
 [ PowerDown_SerialParallel
M1B_ON_Serial   #       1
M1B_ON_Parallel #       1
 ]
M1B_ON_Remove   #       1


; Menu option numbers for Menu 2

                ^       0
M2_ON_Full      #       1
M2_ON_3Quarters #       1
M2_ON_Half      #       1
M2_ON_1Quarter  #       1
M2_ON_Empty     #       1


 [ CycleBattery
; Menu option numbers for Menu 3

                ^       0
M3_ON_1         #       1
M3_ON_2         #       1
M3_ON_3         #       1
M3_ON_4         #       1
M3_ON_Abort     #       1
 ]


; List of Wimp messages we can handle (Quit is assumed)

                ALIGN
MsgList         DCD     Message_PreQuit
 [ CycleBattery
                DCD     Service_Portable        ;So we can inhibit power saving whilst cycling (discharging) the battery
 ]
                DCD     0

;******************************************************************************

Shutdown        ROUT
;
; Shutdown the WIMP task
;
; Exit:
;    R0 preserved
;    R1 undefined

        Push    "R0,LR"
        LDR     R0,TaskHandle
        LDR     R1,TASK
        SWI     XWimp_CloseDown
        MOV     R0,#0
        STR     R0,TaskHandle
        Pull    "R0,PC",,^

;******************************************************************************

ErrorStarted
;
; Task already started: report error without using stack
;

        addr    R0,ErrorBlock_NoStart
        wsaddr  R1,MsgTransBlk
        MOV     R2,#0                           ; use internal buffer
        MOV     R4,#0                           ; no parameter 0
        MOV     R5,#0                           ; no parameter 0
        MOV     R6,#0                           ; no parameter 0
        MOV     R7,#0                           ; no parameter 0
        SWI     XMessageTrans_ErrorLookup
        SWI     OS_GenerateError

;******************************************************************************

ErrorOldWimp    ROUT
;
; Old WIMP version
;

        SWI     XWimp_CloseDown
        SWI     XOS_WriteI+4            ; just in case (old Wimp!)
        addr    R0,ErrorBlock_OldWimp
        BL      ErrorLookup
        B       AbortTask

;******************************************************************************

ErrCloseTemplate        ROUT
;
; Error: close template file and abort
;
; Entry:
;    R0 -> error block
;
; Exit:
;    Does not return

        Push    "R0"
        SWI     XWimp_CloseTemplate
        Pull    "R0"

AbortTask

; R0 -> error block

        BL      Shutdown

AbortTaskNoTask

        MOV     R1,R0                           ; save error

; free task workspace and zero pointer

        MOV     R0,#ModHandReason_Free
        MOV     R2,TWP
        SWI     XOS_Module
        MOV     R0,#0
        STR     R0,TaskWorkspacePtr

; WARNING: stack no longer valid
; generate error

        MOV     R0,R1                           ; restore error
        SWI     OS_GenerateError

;******************************************************************************

Start   ROUT
;
; Entry:
;    R12 -> private word
;    MODE: USR
;    NO STACK

        LDR     MWP,[R12]                       ; must be valid to get this far

; check not already started: must check without using stack since stack
; may belong to existing incarnation of task

        LDR     LR,TaskHandle
        CMPS    LR,#0
 [ Test
        BGT     ErrorStarted
 |
        BGE     ErrorStarted
 ]

; not already started

        LDR     R2,TaskWorkspacePtr             ; get task workspace pointer
        TEQS    R2,#0                           ; valid?
        MOVEQ   R0,#ModHandReason_Claim         ; no, claim space
        LDIMM   R3,TaskWorkspace,EQ
        SWIEQ   OS_Module                       ; aborts if this fails
        STR     R2,TaskWorkspacePtr
        MOV     TWP,R2

; have got workspace
; set up stack

        wsaddr  SP,StackBase

; stack now valid

        MOV     R0,#300                         ; Wimp version
        LDR     R1,TASK
        addr    R2,TaskDescription
        addr    R3,MsgList                      ; Wimp 300 knows about this
        SWI     XWimp_Initialise
        BVS     AbortTaskNoTask

; check Wimp version

        LDIMM   R3,278                          ; need poll word
        CMPS    R0,R3
        BLO     ErrorOldWimp

        STR     R1,TaskHandle                   ; save handle

; load sprites

        MOV     R0,#SpriteReason_MergeSpriteFile
        addr    R2,SpriteFile
        SWI     XWimp_SpriteOp

; read sprite info

        MOVVC   R0,#SpriteReason_ReadSpriteSize ; read sprite info, user area
        addr    R2,SpriteName,VC
        SWIVC   XWimp_SpriteOp

; R3 = width
; R4 = height
; R5 = mask status
; R6 = mode
; read scale factors for sprite in mode in which it was created

        MOVVC   R0,R6                           ; mode
        MOVVC   R1,#VduExt_XEigFactor           ; read X shift
        SWIVC   XOS_ReadModeVariable
        MOVVC   R5,R2                           ; save X shift
        MOVVC   R1,#VduExt_YEigFactor           ; read Y shift
        SWIVC   XOS_ReadModeVariable
        BVS     AbortTask

; R5 = X shift
; R2 = Y shift
; R3 = sprite width
; R4 = sprite height
;
; Calculate X and Y positions for the create icon call

        MOV     R0,#0                           ; sprite left
        STR     R0,IconX_Text
        ADD     R0,R0,R3,LSL R5                 ; pixel size depends on mode
        STR     R0,IconX_Sprite

        MOV     R0,#20                          ; sprite baseline
        ADD     R0,R0,R4,LSL R2                 ; pixel size depends on mode
        STR     R0,IconY_Sprite
        MOV     R0,#-16                         ; text baseline
        STR     R0,IconY_Text 

; Calculate coordinates of corners of "sliding" bar within icon bar sprite
; Also calculate positions within bar to place '<', '>' and '?' characters
; (adjusting for size of one character)

        MOV     R0,#IconBorderL                 ; indent from left margin
        MOV     R0,R0,LSL R5                    ; adjust for mode
        STR     R0,MinX
        STR     R0,LeftX

        SUB     R1,R3,#IconBorderR + 8 + 1      ; allow for one character
        MOV     R1,R1,LSL R5
        STR     R1,RightX

        SUB     R1,R3,#IconBorderR + 1          ; indent from right margin
        MOV     R1,R1,LSL R5                    ; adjust for mode
        STR     R1,MaxX

; R0 = MinX
; R1 = MaxX
; R2 = Y shift
; R3 = sprite width
; R4 = sprite height
; R5 = X shift
; Calculate X coordinate of middle of sprite, allowing for one 8x8 character

        SUB     R1,R1,R0                        ; R1 = width of bar
        MOV     R1,R1,LSR #1                    ; R1 = 1/2 width of bar
        ADD     R1,R1,R0                        ; R1 += left margin
        MOV     R0,#4                           ; 1/2 character width...
        SUB     R1,R1,R0,LSL R5                 ; ...adjusted for mode
        STR     R1,MidX                         ; save as X coord

; Now do same for Y

        MOV     R0,#IconBorderB                 ; indent from bottom margin
        MOV     R0,R0,LSL R2                    ; adjust for mode
        STR     R0,MinY

        SUB     R1,R4,#IconBorderT + 1          ; indent from top margin
        MOV     R1,R1,LSL R2                    ; adjust for mode
        STR     R1,MaxY

; R0 = MinY
; R1 = MaxY
; Calculate Y coordinate of middle of sprite, allowing for one 8x8 character

        SUB     R1,R1,R0                        ; R1 = height of bar
        MOV     R1,R1,LSR #1                    ; R1 = 1/2 height of bar
        ADD     R1,R1,R0                        ; R1 += bottom margin
        MOV     R0,#4 + 3                       ; 1/2 character height...
        SUB     R1,R1,R0,LSL R2                 ; ...adjusted for mode
        STR     R1,MidY                         ; save as Y coord

; read "Estimate" string from messages file to determine length

        wsaddr  R0,MsgTransBlk
        addr    R1,MToken_Estimated             ; R1 -> token
        wsaddr  R2,SpriteText                   ; R2 -> buffer
        MOV     R3,#?SpriteText                 ; R2 = buf size
        MOV     R4,#0                           ; no parameter 0
        MOV     R5,#0                           ; no parameter 1
        MOV     R6,#0                           ; no parameter 2
        MOV     R7,#0                           ; no parameter 3
        SWI     XMessageTrans_Lookup            ; *corrupts* R1
        STRVCB  R3,SpriteTextLen

 [ CycleBattery
; copy "Estimate" string into EstimateText cos SpriteText is often overwritten by "Cycle 0"

        wsaddr  R0,EstimateText
        wsaddr  R1,SpriteText
        LDMIA   R1, {R2-R5}
        STMIA   R0, {R2-R5}

; read "Cycle 0" string from messages file into CycleZeroText
        wsaddr  R0,MsgTransBlk
        addr    R1,MToken_CycleZero             ; R1 -> token
        wsaddr  R2,CycleZeroText                ; R2 -> buffer
        MOV     R3,#?CycleZeroText              ; R2 = buf size
        MOV     R4,#0                           ; no parameter 0
        MOV     R5,#0                           ; no parameter 1
        MOV     R6,#0                           ; no parameter 2
        MOV     R7,#0                           ; no parameter 3
        SWIVC   XMessageTrans_Lookup            ; *corrupts* R1
        SUBVC   R3,R3,#1
        STRVCB  R3,CycleZeroLen                 ;position in string to poke the CycleCount digit
 ]

; open templates file

        addr    R1,TemplateFile,VC
        SWIVC   XWimp_OpenTemplate
        BVS     AbortTask

; read in templates and create windows

        wsaddr  R0,TemplateWorkspace
        STR     R0,TemplateWorkspace_Ptr

        addr    R5,WinName_ProgInfo
        BL      CreateWindow
        STRVC   R0,WinHand_ProgInfo
        addr    R5,WinName_Warning,VC
        BLVC    CreateWindow
        STRVC   R0,WinHand_Warning
        BVS     ErrCloseTemplate

; close templates file

        SWI     XWimp_CloseTemplate

; set info text

        LDR     R0,WinHand_ProgInfo
        MOV     R3,#4                           ; icon number
        addr    R2,VersionStr                   ; R2 -> version string
        BL      SetIconText

; initialise things

        MOV     R0,#0
        STRB    R0,Task_BMU_Flags               ; copy of BMU flags
        STRB    R0,Task_Flags                   ; local flags
        STR     R0,WarningTokenPtr              ; no warning displayed

; read CMOS to determine whether to display icon

        MOV     R0,#ReadCMOS
        MOV     R1,#Deskboot2CMOS
        SWI     XOS_Byte
        MOVVS   R2,#bit0                        ; if error, assume icon wanted

; fake a poll word change to handle current BMU flags, calc/display
; current percentage and create icon (if wanted)

        TSTS    R2,#bit0                        ; icon wanted?
        MOVNE   R0,#PollWordReason_AddIcon      ; if yes, setup reason
        MOVEQ   R0,#PollWordReason_BMUEvent     ; if no, give other reason
        STR     R0,PollWord
        BL      WE_PollWordChanged

; Wimp poll loop

Poll_Loop

; report any error

 [ T

        MOVVS   R2,#0                           ; clear warning pointer
        STRVS   R2,WarningTokenPtr
        ADDVS   R2,R0,#4                        ; step over error number
        BLVS    WarnText                        ; produce warning box

 |

; RMokady is supposed to be working on way to make this ok

        MOVVS   R1,#6                           ; Cancel box
        addr    R2,TaskDescription,VS
        SWIVS   XWimp_ReportError

 ]

; read time for next entry

        SWI     XOS_ReadMonotonicTime
        BVS     Poll_Loop
        LDIMM   R2,PollIdleTicks                ; centiseconds
        ADD     R2,R2,R0

; set event mask and poll

        LDIMM   R0,pollword_enable+(1<<Gain_Caret)+(1<<Lose_Caret)+pointerchange_bits
        wsaddr  R1,WorkBlock
        wsaddr  R3,PollWord
        SWI     XWimp_PollIdle
        BVS     Poll_Loop

; call relevant routine to handle event

        addr    LR,Poll_Loop                    ; set return address
        CMPS    R0,#(JmpTab_end-JmpTab)/4
        ADDCC   PC,PC,R0,ASL #2
        MOV     PC,LR
JmpTab
        B       WE_Null                 ;  0  null event
        MOV     PC,LR                   ;  1  redraw window
        B       WE_OpenWindow           ;  2  open window
        B       WE_CloseWindow          ;  3  close window
        MOV     PC,LR                   ;  4  pointer leaving window
        MOV     PC,LR                   ;  5  pointer entering window
        B       WE_MouseClick           ;  6  mouse click.
        MOV     PC,LR                   ;  7  drag box complete
        MOV     PC,LR                   ;  8
        B       WE_MenuSelection        ;  9  menu_select
        MOV     PC,LR                   ; 10
        MOV     PC,LR                   ; 11
        MOV     PC,LR                   ; 12
        B       WE_PollWordChanged      ; 13 poll word non-zero
        MOV     PC,LR                   ; 14
        MOV     PC,LR                   ; 15
        MOV     PC,LR                   ; 16
        B       WE_RxMessage            ; 17
        B       WE_RxMessageRecorded    ; 18
        MOV     PC,LR                   ; 19
JmpTab_end

;******************************************************************************

WE_PollWordChanged      ROUT
;
; R1 -> block returned by poll

        LDR     R0,PollWord                     ; get reason
        MOV     R1,#0                           ; zero pollword
        STR     R1,PollWord

        TEQS    R0,#PollWordReason_AddIcon      ; check reason
        BNE     WE_Null                         ; branch if not add icon

; pollword command is AddIcon

        Push    "LR"

        LDRB    R0,Task_Flags                   ; already present?
        TSTS    R0,#F_IconPresent
        BLEQ    CreateIcon                      ; if not, create icon

        Pull    "LR"
        MOVVS   PC,LR

; fall through to null event code

WE_Null ROUT
;
; Null event
;
; Exit:
;    VS => R0 -> error
;    VS => R0 undefined
;    R1-R2 undefined

        Push    "LR"

; update task copy of flags but keep old ones so we can compare

        LDRB    R2,Task_BMU_Flags               ; get flags we know about
        LDRB    R1,BMU_Flags                    ; get current flags
        STRB    R1,Task_BMU_Flags               ; update flags known about

; R1 = current BMU flags
; R2 = old flags

 [ debug
        DREG    R2,"T: flags change from ",cc
        DREG    R1," to ",cc
 ]
        EOR     R2,R1,R2

 [ debug
        DREG    R2,", changed = "
 ]
;
; look for changes of state
; R1 = current BMU flags
; R2 = flag bits that have changed state
;
 [ CycleBattery
        TSTS    R2,#PortableBMUF_ChargerPresent ; charger present flag changed?
        BLNE    Task_ChargerPresentChange       ; may alter R2, see comments in routine
 ]
        TSTS    R2,#PortableBMUF_Threshold_1    ; T1 changed?
        BLNE    Task_T1Change                   ; handle it if so

        TSTS    R2,#PortableBMUF_ChargeFault    ; charge fault changed?
        BLNE    Task_ChargeFaultChange          ; handle it if so

        TSTS    R2,#PortableBMUF_Threshold_2    ; threshold 2 changed?
        TSTNES  R1,#PortableBMUF_Threshold_2    ; has it become set
        BLNE    Task_SecondThreshold            ; act on it if so

; If "charge state known" or "battery present" changed, clear
; estimating flag (if charge state became unknown, estimate is now
; invalid, if charge state became known, we don't care about estimate,
; if battery removed OR inserted, estimate will be invalid)

 [ F
        TSTS    R2,#PortableBMUF_ChargeKnown :OR: PortableBMUF_BatteryPresent
        LDRNEB  R0,Task_Flags                   ; if changed, clear flag
        BICNE   R0,R0,#F_Estimating             ; so user will be forced to
        STRNEB  R0,Task_Flags                   ; enter new estimate
 ]

; update icon

        BL      CalcPercent
        BLVC    UpdateIcon

        Pull    "PC"

;******************************************************************************

WE_OpenWindow   ROUT
;
; R1 -> block returned by poll

        SWI     XWimp_OpenWindow
        MOV     PC,LR

;******************************************************************************

WE_CloseWindow  ROUT
;
; R1 -> block returned by poll

        SWI     XWimp_CloseWindow
        MOV     PC,LR

;******************************************************************************

WE_MouseClick   ROUT
;
; Mouse click
; Check where the click was and what type
; R1 -> block returned by poll

        LDMIA   R1,{R2-R6}                      ; get vars
        CMPS    R5,#-2                          ; icon bar?
        BEQ     %FT10
        LDR     R0,WinHand_Warning
        TEQS    R5,R0
        MOVNES  PC,LR

; Click in warning window

        TEQS    R4,#button_left                 ; SELECT?
        TEQNES  R4,#button_right                ; ADJUST?
        MOVNES  PC,LR

; SELECT/ADJUST: check icon

        TEQS    R6,#1                           ; icon 1
        MOVNES  PC,LR

        wsaddr  R1,WinHand_Warning              ; R1 -> close block
        SWI     XWimp_CloseWindow

        MOV     PC,LR

;~~~~~~~~~~~~~~~

10

; Click on icon
; R2-R6 = mouse info

        TEQS    R4,#button_middle               ; MENU?
        MOVNES  PC,LR

; MENU on icon

        Push    "LR"
        BL      CreateMenu
        Pull    "PC"

;******************************************************************************

WE_MenuSelection        ROUT
;
; Item selected from menu
;
; Entry:
;    R1 -> block returned by poll
;    MODE: USR

; Read mouse button state

        MOV     R2,R1                           ; save pointer to block
        wsaddr  R1,GetPointerBlk
        SWI     XWimp_GetPointerInfo
        MOVVS   PC,LR                           ; exit if error

        LDR     R0,[R1,#b_buttons]              ; get button state
        Push    "R0,LR"                         ; save buttons and link
        BL      %F00                            ; process selection
        Pull    "R0,PC",VS                      ; exit if error

; if icon still present and ADJUST was used, reopen menu

        LDR     R0,[SP]                         ; get buttons
        TSTS    R0,#2_001                       ; ADJUST?
        LDRNEB  R0,Task_Flags                   ; if so, check for icon
        TSTNES  R0,#F_IconPresent
        BLNE    CreateMenu                      ; if present, create menu
        Pull    "R0,PC"

;~~~~~~~~~~~~~~~

00
; Menu item has been selected
; R2 -> block returned from Wimp_Poll

; If no IDE drives present, increment menu option number if above the
; removed menu item to make comparison easier

        LDRB    R0,IDEdrives
        TEQS    R0,#0
        MOVEQ   R3,#1
        MOVNE   R3,#0

; R0 = what to add to menu option number

        LDR     R0,[R2]                         ; get item number
        CMPS    R0,#M1A_ON_Disc
        ADDHS   R0,R0,R3

; now can use M1A options exclusively

        TEQS    R0,#M1A_ON_Disc
        BEQ     %F10
 [ PowerDown_SerialParallel
        TEQS    R0,#M1A_ON_Serial
        BEQ     %F20
        TEQS    R0,#M1A_ON_Parallel
        BEQ     %F30
 ]
        TEQS    R0,#M1A_ON_Estimate
        BEQ     %F40
 [ CycleBattery
        TEQS    R0,#M1A_ON_Cycle
        BEQ     %FT50
 ]
        TEQS    R0,#M1A_ON_Remove
        MOVNES  PC,LR

; Option: remove icon from icon bar

        wsaddr  R1,WorkBlock
        MOV     R0,#-1
        LDR     R2,IconHandle
        STMIA   R1,{R0,R2}
        SWI     XWimp_DeleteIcon

; Clear flag: icon no longer present

        LDRVCB  R0,Task_Flags
        BICVC   R0,R0,#F_IconPresent
        STRVCB  R0,Task_Flags

        MOV     PC,LR

;~~~~~~~~~~~~~~~
10

; Option: stop hard discs
; for each hard disc
;  if disc is IDE
;   stop it

        MOV     R1,#4                           ; drive number
11
        MOV     R0,R1
        SWI     XADFS_ControllerType
        BVS     %FT12

; R0 = controller type

        TEQS    R0,#4                           ; IDE?
        MOVEQ   R0,#2                           ; spin control
        MOVEQ   R2,#0                           ; spin down
        SWIEQ   XADFS_PowerControl
12
        ADD     R1,R1,#1                        ; do next drive
        TEQS    R1,#8                           ; all done?
        BNE     %BT11

        MOVS    PC,LR

;~~~~~~~~~~~~~~~
 [ PowerDown_SerialParallel

20
; Option: power off serial (buffer and 82711)

        MOV     R0,#0                                   ; EOR mask
        MVN     R1,#PortableControl_SerialBufferEnable  ; buffer
        BIC     R1,R1,#PortableControl_SerialEnable     ; 82711
        SWI     XPortable_Control

        MOVS    PC,LR

;~~~~~~~~~~~~~~~

30
; Option: power off parallel

        MOV     R0,#0                                   ; EOR mask
        MVN     R1,#PortableControl_ParallelEnable      ; 82711
        SWI     XPortable_Control

        MOVS    PC,LR
 ]

;~~~~~~~~~~~~~~~

40
; Option: set estimate
; R2 -> block returned from poll

        LDR     R3,[R2,#4]                      ; get submenu selection
        CMPS    R3,#EstimateMenuItems
        MOVHS   PC,LR                           ; quit if out of range

; got submenu selection
; calculate usable * selection / (selections - 1)

        MOV     R0,#PortableBMUV_UsableCapacity ; read usable capacity
        SWI     XPortable_ReadBMUVariable
        MOVVS   PC,LR                           ; quit if error

        MUL     R3,R1,R3                        ; * usable
        DivRem  R1,R3,#EstimateMenuItems - 1,R0 ; / (selections - 1)
        ASSERT  EstimateMenuItems > 1

; write it to BMU

        MOV     R0,#PortableBMUV_ChargeEstimate
        SWI     XPortable_WriteBMUVariable
        MOVVS   PC,LR

 [ F
; set flag to say it's ok to use estimate

        LDRB    R0,Task_Flags
        ORR     R0,R0,#F_Estimating
        STRB    R0,Task_Flags
 ]

        Push    "LR"

        BL      CalcPercent
        BLVC    UpdateIcon

        Pull    "PC"

;~~~~~~~~~~~~~~~
 [ CycleBattery

50
; Option: cycle battery
; R2 -> block returned from poll

        LDR     R3,[R2,#4]                      ; get submenu selection
        CMPS    R3,#CycleMenuItems
        MOVHS   PC,LR                           ; quit if out of range

                                                ;Calculate number of discharge/charge cycles
        CMP     R3, #M3_ON_Abort
        MOVEQ   R3, #0                          ; zero means abort cycle
 [ T
        ASSERT  M3_ON_1 = 0
 |
       ;SUBNE   R3, R3, #M3_ON_1
 ]
        ADDNE   R3, R3, #1                      ; cycle count is 1..n

        Push    "LR"
        MOV     R0, R3                          ;Cycle count=0 abort cycling
        BL      StartCycling                    ; >0 means start discharging
        BL      UpdateIcon
        Pull    "PC"
 ]

;******************************************************************************

WE_RxMessageRecorded    ROUT
WE_RxMessage            ROUT
;
; R1 -> block returned by poll

        LDMIA   R1,{R2-R6}
        TEQS    R6,#Message_Quit
        BEQ     %FT10
        TEQS    R6,#Message_PreQuit
        MOVNES  PC,LR

; Message: PreQuit
; If it's quit me only, acnowledge message to stop quit
; If it's for everyone, must quit to avoid stopping shutdown

        CMPS    R2,#24                          ; if block too small
        MOVCCS  PC,LR                           ; act as if no flag word

; flag word present, bit 0 => quit me only

        LDR     R0,[R1,#ms_data]                ; get flag word
        TSTS    R0,#1                           ; bit 0 => just me
        MOVNE   R0,#User_Message_Acknowledge
        STRNE   R4,[R1,#ms_yourref]             ; reply
        MOVNE   R2,R3                           ; to sender
        SWINE   XWimp_SendMessage
        MOV     PC,LR

;~~~~~~~~~~~~~~~

10

; Message: Quit

        BL      Shutdown

; free task workspace and zero pointer

        MOV     R0,#ModHandReason_Free
        MOV     R2,TWP
        SWI     XOS_Module
        MOV     R0,#0
        STR     R0,TaskWorkspacePtr

; WARNING: stack no longer valid

        SWI     OS_Exit

;******************************************************************************

CreateIcon      ENTRY   "R1-R9"
;
; Creates the icon on the icon bar
;
; Entry:
;    MODE: USR
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined
;    IconHandle updated
;    Task_Flags updated

        MOV     R0,#-1                          ; right of icon bar

        ADR     R14,Icon_Coords
        LDMIA   R14,{R2-R5}
        ASSERT  IconX_Text = Icon_Coords
        ASSERT  IconY_Text = (IconX_Text + 4)
        ASSERT  IconX_Sprite = (IconY_Text + 4)
        ASSERT  IconY_Sprite = (IconX_Sprite + 4)

        LDIMM   R6,&1700310B                    ; icon flags
        wsaddr  R7,SpriteText
        addr    R8,SpriteValidation
        LDRB    R9,SpriteTextLen
        wsaddr  R1,WorkBlock
        STMIA   R1,{R0,R2-R9}
        SWI     XWimp_CreateIcon
        STRVC   R0,IconHandle
        LDRVCB  R0,Task_Flags                   ; flag icon now present
        ORRVC   R0,R0,#F_IconPresent
        STRVCB  R0,Task_Flags

        EXIT

;******************************************************************************

UpdateIcon      ENTRY   "R1-R7"
;
; Updates the icon bar icon to show the latest percentage
;
; Entry:
;    MODE: USR
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined
;    All other registers preserved

        LDRB    R0,Task_Flags                   ; check icon present
        TSTS    R0,#F_IconPresent
        EXIT    EQ

; icon is present
; switch output to sprite

        SWI     XWimp_BaseOfSprites             ; returns R1 -> RMA sprites
        LDIMM   R0,SpriteReason_SwitchOutputToSprite :OR: &100,VC
        addr    R2,SpriteName,VC                ; output to sprite
        MOVVC   R3,#0                           ; no save area
        SWIVC   XOS_SpriteOp
        EXIT    VS

; save previous state for when we switch output back

        Push    "R0-R3"

; move to bottom left (VDU 25,4,MinX;MinY;)

        MOV     R0,#4
        LDR     R1,MinX
        LDR     R2,MinY
        SWI     XOS_Plot

; set graphics colour white

        MOV     R0,#&FFFFFF00
        MOV     R3,#0
        MOV     R4,#0
        SWI     XColourTrans_SetGCOL

; move to top right, plotting filled rectangle (VDU 25,5+96,MaxX;MaxY;)

        MOV     R0,#5+96
        LDR     R1,MaxX
        LDR     R2,MaxY
        SWI     XOS_Plot

 [ CycleBattery
        LDRB    R0, CycleCount
        CMP     R0, #0
        wsaddr  R0, SpriteText
        wsaddr  R1, EstimateText, EQ
        wsaddr  R1, CycleZeroText, NE
        LDMIA   R1, {R2-R5}
        STMIA   R0, {R2-R5}
        LDRNEB  R1, CycleZeroLen
        LDRNEB  R2, CycleCount
        ADDNE   R2, R2, #'0'
        STRNEB  R2, [R0, R1]
 ]

; check if we know charge state to plot

        LDRB    R0,Task_BMU_Flags               ; get BMU flags
        TSTS    R0,#PortableBMUF_BatteryPresent ; battery present?
        BEQ     %F30                            ; branch if not
        TSTS    R0,#PortableBMUF_ChargeKnown    ; charge state known?
        LDREQB  R0,Task_Flags                   ; if not, check estimate
        TSTEQS  R0,#F_Estimating
        BEQ     %F30                            ; branch if not estimating

; charge state is known or is estimated
; if 0%, don't plot anything in colour as always get at least one pixel

        LDRB    R5,Percent
        TEQS    R5,#0
        BEQ     %FT20                           ; branch if 0%
        CMPS    R5,#100                         ; must be <= 100%
        MOVHI   R5,#100

; plot filled colour rectangle over top of white rectangle
; move to bottom left (VDU 25,4,MinX;MinY;)

        MOV     R0,#4
        LDR     R1,MinX
        LDR     R2,MinY
        SWI     XOS_Plot

; Choose colour based on critical levels and monitor type

        CMPS    R5,#ColourChange_Percent
        LDIMM   R0,&99999900,HI                 ; medium grey
        LDIMM   R0,&33333300,LS                 ; dark grey

; check we're using LCD as need different colours if not

        LDRB    R3,MonitorType
        TEQS    R3,#5                           ; LCD?
        BEQ     %FT10                           ; branch if so

; not LCD

        CMPS    R5,#ColourChange_Percent
        MOVHI   R0,#&00FF0000                   ; green
        MOVLS   R0,#&0000FF00                   ; red

10
        MOV     R3,#1 << 8                      ; use ECF
        MOV     R4,#0
        SWI     XColourTrans_SetGCOL

; move to top right, plotting filled rectangle (VDU 25,5+96,X;Y;)
; X coordinate = max rectangle width * percent / 100) + start X
; [should calculate (MaxX-MinX) once and for all really]

        LDR     R0,MaxX
        LDR     R1,MinX
        SUB     R0,R0,R1                        ; R0 = width of area
        MUL     R0,R5,R0                        ; R0 = width * percent
        DivRem  R2,R0,#100,R3                   ; R0 = width * percent / 100
        ADD     R1,R2,R1                        ; add in MinX
        LDR     R2,MaxY
        MOV     R0,#5+96
        SWI     XOS_Plot
20
; put in '>' or '<' to indicate charge/discharge as appropriate
; reset graphics foreground colour

        MOV     R0,#&00000000                   ; black
        MOV     R3,#0
        MOV     R4,#0
        SWI     XColourTrans_SetGCOL

; read charge rate from portable module

        MOV     R0,#PortableBMUV_ChargeRate     ; read charge rate
        SWI     XPortable_ReadBMUVariable
        BVS     %FT25                           ; branch if error

; look at charge rate bits

 [ debug
        DREG    R1,"T: Charge rate "
 ]
        ANDS    R0,R1,#&F0                      ; look at charge bits
        MOV     R1,#0                           ; assume no char to print
        MOVEQ   R1,#"<"                         ; if no charge bits, discharge
        LDREQ   R3,LeftX
        TSTNES  R0,#&60                         ; else, if fast or quick
        MOVNE   R1,#">"                         ; ...then charging  
        LDRNE   R3,RightX

; R1 = 0 or character to paint
; R3 = X position (if R1 != 0)

        TEQS    R1,#0
        MOVNE   R0,#SpriteReason_PaintCharScaled
        LDRNE   R4,MidY                         ; R4 = Y coord
        MOVNE   R6,#0                           ; no scale factors
        SWINE   XOS_SpriteOp
25
; switch output back to how it was before, using saved values

        Pull    "R0-R3"
        SWI     XOS_SpriteOp

; now make Wimp redraw icon with new sprite

        wsaddr  R1,WorkBlock
        MOV     R2,#-1                          ; icon bar icon
        LDR     R3,IconHandle                   ; icon handle

; If battery present and estimating, enable text below sprite,
; otherwise disable it by setting foreground colour = background colour

        LDRB    R0,Task_BMU_Flags
 [ CycleBattery
; If cycling the battery, enable text below sprite to show cycle number.
        LDRB    R4,CycleCount
        CMP     R4,#0
        BNE     %FT27
 ]
        TSTS    R0,#PortableBMUF_BatteryPresent ; battery present?
        EORNE   R0,R0,#PortableBMUF_ChargeKnown ; reverse sense of test
        TSTNES  R0,#PortableBMUF_ChargeKnown    ; charge not known?
        LDRNEB  R0,Task_Flags                   ; if not, estimating?
        TSTNES  R0,#F_Estimating
27      MOVNE   R4,#&07000000                   ; EOR word (foreground = 7)
        MOVEQ   R4,#&01000000                   ; EOR word (foreground = 1)
        MOV     R5,#&0F000000                   ; clear word
        STMIA   R1,{R2-R5}
        SWI     XWimp_SetIconState

        EXIT

;~~~~~~~~~~~~~~~

30
; charge state not known and not estimating
; put cursor in middle of sprite and draw a question mark

; set graphics foreground colour black

        MOV     R0,#&00000000
        MOV     R3,#0
        MOV     R4,#0
        SWI     XColourTrans_SetGCOL

; paint '?' in middle of sprite

        MOV     R0,#SpriteReason_PaintCharScaled
        MOV     R1,#'?'                         ; character
        LDR     R3,MidX                         ; R3 = X coord
        LDR     R4,MidY                         ; R4 = Y coord
        MOV     R6,#0                           ; no scale factors
        SWI     XOS_SpriteOp

        B       %BT20                           ; all done

;******************************************************************************

CreateWindow    ENTRY   "R1-R6"
;
; Loads a template from the template file and creates the window
;
; Entry:
;    MODE: USR
;    R5 -> template name
;    Template file is open
;
; Exit:
;    VS => R0 -> error
;    VC => R0 = window handle

        wsaddr  R1,WorkBlock
        LDR     R2,TemplateWorkspace_Ptr
        wsaddr  R3,TemplateWorkspace_End
        MOV     R4,#-1                          ; no fonts
        MOV     R6,#0                           ; search from beginning
        SWI     XWimp_LoadTemplate
        EXIT    VS

        TEQS    R6,#0                           ; found?
        addr    R0,ErrorBlock_NoTemplate,EQ     ; return error if not found
        BLEQ    ErrorLookup
        PullEnv EQ
        ORREQS  PC,LR,#V_bit

; have loaded the template, R1 => template

        STR     R2,TemplateWorkspace_Ptr        ; save updated pointer
        SWI     XWimp_CreateWindow
        EXIT

;******************************************************************************

MakeMenu        ENTRY   "R1-R4"
;
; Uses MessageTrans to make menu structures
;
; Entry:
;    MODE: USR or SVC
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined
;    All other registers preserved


; Make Estimate menu structure in RAM

        wsaddr  R0,MsgTransBlk
        addr    R1,EstimateMenuDef
        wsaddr  R2,EstimateMenu
        MOV     R3,#?EstimateMenu
        SWI     XMessageTrans_MakeMenus
        EXIT    VS

 [ CycleBattery
; Make Cycle menu structure in RAM

        wsaddr  R0,MsgTransBlk
        addr    R1,CycleMenuDef
        wsaddr  R2,CycleMenu
        MOV     R3,#?CycleMenu
        SWI     XMessageTrans_MakeMenus
        EXIT    VS
 ]

; Make Icon bar menu structure in RAM

        wsaddr  R0,MsgTransBlk
        addr    R1,IconBarMenuDef
        wsaddr  R2,IconBarMenu
        MOV     R3,#?IconBarMenu
        SWI     XMessageTrans_MakeMenus
        EXIT    VS

; Insert window handle for window opened off menu

        wsaddr  R2,IconBarMenu

        LDR     R0,WinHand_ProgInfo
        STR     R0,[R2,#m_headersize+mi_size*M1A_ON_Info+mi_submenu]
        ASSERT  M1A_ON_Info = M1B_ON_Info

; Insert pointer to submenu structure

        wsaddr  R0,EstimateMenu
        STR     R0,[R2,#m_headersize+mi_size*M1A_ON_Estimate+mi_submenu]
        ASSERT  M1A_ON_Estimate = M1B_ON_Estimate

; If no battery or charge state is known, grey out Estimate item

        LDRB    R0,Task_BMU_Flags               ; get flags
        AND     R0,R0,#PortableBMUF_BatteryPresent :OR: PortableBMUF_ChargeKnown
        TEQS    R0,#PortableBMUF_BatteryPresent
        LDRNE   R1,[R2,#m_headersize+mi_size*M1A_ON_Estimate+mi_iconflags]
        ORRNE   R1,R1,#is_shaded
        STRNE   R1,[R2,#m_headersize+mi_size*M1A_ON_Estimate+mi_iconflags]

 [ CycleBattery

; Insert pointer to submenu structure

        wsaddr  R0,CycleMenu
        STR     R0,[R2,#m_headersize+mi_size*M1A_ON_Cycle+mi_submenu]
        ASSERT  M1A_ON_Cycle = M1B_ON_Cycle
 ]

 [ PowerDown_SerialParallel

; Read power state of machine subunits

        MOV     R0,#&00000000                   ; EOR mask
        MOV     R1,#&FFFFFFFF                   ; AND mask
        SWI     XPortable_Control
        MOVVS   R0,#0                           ; if error, assume powered down

; If parallel already powered down, grey out item
; R0 = power state

        TSTS    R0,#PortableControl_ParallelEnable      ; parallel powered up?
        LDREQ   R1,[R2,#m_headersize+mi_size*M1A_ON_Parallel+mi_iconflags]
        ORREQ   R1,R1,#is_shaded
        STREQ   R1,[R2,#m_headersize+mi_size*M1A_ON_Parallel+mi_iconflags]

; If serial already powered down (both bits), grey out item

        TSTS    R0,#PortableControl_SerialBufferEnable  ; serial powered up?
        TSTEQS  R0,#PortableControl_SerialEnable        ; if not, 82711?
        LDREQ   R1,[R2,#m_headersize+mi_size*M1A_ON_Serial+mi_iconflags]
        ORREQ   R1,R1,#is_shaded
        STREQ   R1,[R2,#m_headersize+mi_size*M1A_ON_Serial+mi_iconflags]
 ]

; If no IDE drives, remove the stop disc option

        MOV     R1,#4                           ; drive number
        MOV     R3,#0                           ; IDE drives found
        MOV     R4,#0                           ; spinning IDE drives found
10
        MOV     R0,R1
        SWI     XADFS_ControllerType
        MOVVS   R0,#0                           ; if error, mark as not IDE

; R0 = controller type

        TEQS    R0,#4                           ; IDE?
        ADDEQ   R3,R3,#1                        ; if so, bump count
        MOV     R2,#0                           ; assume not spinning
        MOVEQ   R0,#0                           ; read drive spin status
        SWIEQ   XADFS_PowerControl
        TEQS    R2,#0                           ; spinning?
        ADDNE   R4,R4,#1                        ; if so, bump count
        ADD     R1,R1,#1                        ; do next drive
        TEQS    R1,#8                           ; all done?
        BNE     %BT10

; R3 = IDE drives found, if 0, shuffle up items to overwrite disc item
; R4 = spinning IDE drives, if 0 grey out item

        STRB    R3,IDEdrives

; if no spinning IDE drives, grey out menu item

        wsaddr  R2,IconBarMenu
        TEQS    R4,#0                           ; any spinning drives?
        LDREQ   R1,[R2,#m_headersize+mi_size*M1A_ON_Disc+mi_iconflags]
        ORREQ   R1,R1,#is_shaded
        STREQ   R1,[R2,#m_headersize+mi_size*M1A_ON_Disc+mi_iconflags]

        TEQS    R3,#0                           ; any IDE drives?
        EXIT    NE                              ; if yes, return

; no IDE drives: shuffle up items to remove menu option

        ADD     R2,R2,#m_headersize+mi_size*M1A_ON_Disc
        ADD     R3,R2,#mi_size
        MOV     R4,#(M1A_ON_Remove-M1A_ON_Disc)*mi_size+4       ; include 0 terminator

; following asserts check data source/dest are word aligned and length to be
; copied is whole number of words

        ASSERT  (m_headersize:AND:3)=0
        ASSERT  (mi_size:AND:3)=0

; copy the data

30
        LDR     R0,[R3],#4
        STR     R0,[R2],#4
        SUBS    R4,R4,#4
        BNE     %BT30

        EXIT

;******************************************************************************

CreateMenu      ENTRY   "R1-R3"
;
; Creates icon bar menu structure
;
; Entry:
;    R2 = mouse X position
;    R3 = mouse Y position
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined

; build menu structure in RAM

        BL      MakeMenu
        EXIT    VS

; create menu

        wsaddr  R1,IconBarMenu                  ; R1 -> structure
        SUB     R2,R2,#64                       ; X position

; Y position varies depending on whether stop disc option is present
; Determine this from the number of IDE drives

        LDRB    R3,IDEdrives
        TEQS    R3,#0
        MOVNE   R3,#96+IconBarMenuItems*44      ; Y position
        MOVEQ   R3,#96+(IconBarMenuItems-1)*44  ; Y position
        SWI     XWimp_CreateMenu
        EXIT

;******************************************************************************

SetIconText     ENTRY   "R1-R5"
;
; Changes the text for an icon
;
; Entry:
;    R0 = window handle
;    R2 -> new text
;    R3 = icon number
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined

        wsaddr  R1,WorkBlock
        STMIA   R1,{R0,R3}                      ; put handle & num in block
        SWI     XWimp_GetIconState
        EXIT    VS

; check icon is indirected

        LDR     R0,[R1,#gi_iconblock+i_flags]
        TSTS    R0,#if_indirected
        addr    R0,ErrorBlock_BadTemplate,EQ
        BLEQ    ErrorLookup                     ; returns VS
        EXIT    VS

; icon is indirected: get data pointer and length

        ADD     R1,R1,#gi_iconblock+i_data
        LDMIA   R1,{R3-R5}

; R2 -> source string
; R3 -> buffer
; R5 = buffer length
; copy string, terminating destination

10
        LDRB    R0,[R2],#1                      ; get byte from source
        STRB    R0,[R3]                         ; write to dest
        CMPS    R0,#32                          ; stop on ctrl char
        BLO     %FT20
        SUBS    R5,R5,#1
        ADDNE   R3,R3,#1                        ; step on dest ptr
        BNE     %BT10
        STRB    R5,[R3]                         ; terminate dest
20
        CLRV
        EXIT

;******************************************************************************

CloseWarningWindow      ENTRY   "R1"
;
; Closes the window used for warnings
;
; Entry:
;    MODE: USR
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined
;    All other registers preserved
;
; Uses:
;    WorkBlock

; check if warning window is already open

        wsaddr  R1,WorkBlock
        LDR     R0,WinHand_Warning
        STR     R0,[R1,#u_handle]
        SWI     XWimp_GetWindowState
        EXIT    VS                              ; quit if error

; if already open, close it

        LDR     R0,[R1,#u_wflags]               ; get flags
        TSTS    R0,#ws_open                     ; open?
        EXIT    EQ                              ; quit if not

; window is open, close it

        SWI     XWimp_CloseWindow               ; uses R1

; clear pointer to warning token

        MOVVC   LR,#0
        STRVC   LR,WarningTokenPtr

        EXIT

;******************************************************************************

Warn    ENTRY   "R1-R7"
;
; Produces a warning box from a message token
;
; Entry:
;    R1 -> message token
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined

; call MessageTrans to lookup message token

        wsaddr  R0,MsgTransBlk
        MOV     R2,#0                           ; use internal buffer
        MOV     R4,#0                           ; no parameter 0
        MOV     R5,#0                           ; no parameter 1
        MOV     R6,#0                           ; no parameter 2
        MOV     R7,#0                           ; no parameter 3
        SWI     XMessageTrans_Lookup            ; *corrupts* R1
        EXIT    VS

        BL      WarnText

        PullEnv
        STRVC   R1,WarningTokenPtr              ; save token pointer
        MOV     PC,LR

;******************************************************************************

WarnText        ENTRY   "R1-R4"
;
; Produces a warning box with a textual message
;
; Entry:
;    R2 -> message
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined

; change icon text

        LDR     R0,WinHand_Warning              ; window handle
        MOV     R3,#0                           ; icon number
        BL      SetIconText
        EXIT    VS

; close warning window if open

        BL      CloseWarningWindow
        EXIT    VS

; make box appear in middle of screen

        MOV     R0,#-1                          ; current mode
        MOV     R1,#11                          ; read X size
        SWI     XOS_ReadModeVariable
        MOV     R3,R2
        MOV     R1,#4                           ; read X shift
        SWI     XOS_ReadModeVariable
        MOV     R3,R3,LSL R2
        MOV     R3,R3,LSR #1                    ; divide by 2
        MOV     R1,#12                          ; read Y size
        SWI     XOS_ReadModeVariable
        MOV     R4,R2
        MOV     R1,#5                           ; read Y shift
        SWI     XOS_ReadModeVariable
        MOV     R4,R4,LSL R2
        MOV     R4,R4,LSR #1                    ; divide by 2

; R3, R4 = coordinates of middle of screen
; determine window size and set window position to middle
; of screen - half window size

        wsaddr  R1,WorkBlock,VC
        LDR     R0,[R1,#u_wax1]
        LDR     R2,[R1,#u_wax0]
        SUB     R0,R0,R2                        ; R0 = X size

        SUB     R3,R3,R0,LSR #1
        STR     R3,[R1,#u_wax0]
        ADD     R3,R3,R0
        STR     R3,[R1,#u_wax1]

        LDR     R0,[R1,#u_way1]
        LDR     R2,[R1,#u_way0]
        SUB     R0,R0,R2                        ; R0 = Y size

        SUB     R4,R4,R0,LSR #1
        STR     R4,[R1,#u_way0]
        ADD     R4,R4,R0
        STR     R4,[R1,#u_way1]

        MOV     R2,#-1                          ; open in front
        STR     R2,[R1,#u_bhandle]
        SWI     XWimp_OpenWindow

        EXIT

;******************************************************************************
 [ CycleBattery

Task_ChargerPresentChange ENTRY
;
; Called when task notices 'charger present' bit changing
;
; Entry:
;    R1 = current BMU flags
;    MODE: USR
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined

;
; Cycling the battery suppresses normal handling of 'battery low' and 'battery flat'
; events. If the charger has been disconnected whilst the battery is low or flat, we
; set the appropriate 'changed' bits in R2 so that the event receives attension.
;
; This also causes 'battery low' events to be repeated if the charger (connected in
; response to a battery low warning) is disconnected whilst the battery is still low.
;
        TSTS    R1,#PortableBMUF_ChargerPresent
        ANDEQ   R0, R1, #PortableBMUF_Threshold_1 :OR: PortableBMUF_Threshold_2
        ORREQ   R2, R2, R0
        EXITS
 ]
;******************************************************************************

Task_T1Change   ENTRY   "R1"
;
; Called when task notices T1 bit changing
;
; Entry:
;    R1 = current BMU flags
;    MODE: USR
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined

        TSTS    R1,#PortableBMUF_Threshold_1    ; T1 just arrived?
        BEQ     %FT10                           ; branch if it's just gone

; T1 has arrived
 [ CycleBattery
        LDRB    R0,CycleCount                   ;
        CMP     R0,#0                           ; are we cycling the battery?
        EXIT    NE                              ; yes, so suppress low battery warning
 ]

 [ F
        LDRB    R0,Task_Flags                   ; no longer estimating
        BIC     R0,R0,#F_Estimating
        STRB    R0,Task_Flags
 ]

; warn user

        addr    R1,MToken_BatLow
        BL      Warn
        EXIT

;~~~~~~~~~~~~~~~

10
; T1 has disappeared - remove warning if present

        LDR     R1,WarningTokenPtr              ; get current token pointer
        addr    LR,MToken_BatLow                ; T1 warning?
        TEQS    R1,LR
        BLEQ    CloseWarningWindow              ; close it if so
        EXIT

;******************************************************************************

Task_SecondThreshold    ENTRY   "R1"
;
; Called on second warning from Battery Management Unit that power is
; running low.
;
; Entry:
;    R1 = current BMU flags
;    MODE: USR
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined

        TSTS    R1,#PortableBMUF_Threshold_2    ; T2 just arrived?
        EXITS   EQ                              ; ignore if just gone

 [ CycleBattery
; Threshold 2 crossed
        LDRB    R0,CycleCount                   ;
        CMP     R0,#0                           ; are we cycling the battery?
        EXITS   NE                              ; yes, so ignore warning (BMUEvent will start recharging)
 ]

; T2 has arrived: check if shutdown already started

        LDRB    R0,WimpShutdown_Started         ; already started?
        TEQS    R0,#0
        EXITS   NE                              ; quit if so

; Shutdown desktop

        MOV     R0,#shutdownbit_NoRestartDialogue :OR: shutdownbit_NoPreQuit :OR: shutdownbit_ModifyStateCMOS :OR: shutdownbit_SendShutdownMessage :OR: shutdownbit_RejectMediaSearch
        SWI     XTaskManager_Shutdown
        MOVVC   R0,#1
        STRVCB  R0,WimpShutdown_Started

        EXIT

;******************************************************************************

Task_ChargeFaultChange  ENTRY   "R1"
;
; Called when task notices the charge fault bit changing
;
; Entry:
;    R1 = current BMU flags
;    MODE: USR
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined

        TSTS    R1,#PortableBMUF_ChargeFault    ; fault just arrived
        BEQ     %FT10                           ; branch if it's just gone

; charge fault has arrived

        addr    R1,MToken_ChgFault
        BL      Warn
        EXIT

;~~~~~~~~~~~~~~~

10
; charge fault has disappeared - remove warning if present

        LDR     R1,WarningTokenPtr              ; get current token pointer
        addr    LR,MToken_ChgFault              ; charge fault warning?
        TEQS    R1,LR
        BLEQ    CloseWarningWindow              ; close it if so

        EXIT

;******************************************************************************

CalcPercent     ENTRY   "R1-R4"
;
; Calculates the percentage of charge to display.
;
; Exit:
;    VS => R0 -> error
;    VC => R0 undefined
;    All other registers preserved
;    Percent updated

        LDRB    R0,Task_BMU_Flags
        TSTS    R0,#PortableBMUF_ChargeKnown    ; charge known?
        BEQ     %F50                            ; branch if not

; charge state is known (but there is a window here)
; calculate (MeasuredCapacity - UsedCapacity) / UsableCapacity

        MOV     R0,#PortableBMUV_UsedCapacity   ; read used capacity
        SWI     XPortable_ReadBMUVariable
10

; R1 = used or estimated capacity

        MOVVC   R3,R1                           ; save value
        MOVVC   R0,#PortableBMUV_MeasuredCapacity ; read measured capacity
        SWIVC   XPortable_ReadBMUVariable
        MOVVC   R2,R1                           ; save value
        MOVVC   R0,#PortableBMUV_UsableCapacity ; read usable capacity
        SWIVC   XPortable_ReadBMUVariable
        EXIT    VS

; R1 = usable capacity
; R2 = measured capacity
; R3 = used or esimated capacity

; set Percent = (R2 - R3) * 100 / R1

        SUBS    R3,R2,R3                        ; R3 = measured - used
        MOVLT   R3,#0                           ; R3 < 0 => R3 = 0
        MOV     R0,#100                         ; R3 *= 100
        MUL     R3,R0,R3
        TEQS    R1,#0                           ; must'nt divide by 0
        MOVEQ   R1,#1
        DivRem  R4,R3,R1,R0                     ; R4 = (meas - used)*100/usable
        CMPS    R4,#100
        MOVHI   R4,#100
        STRB    R4,Percent

        CLRV
        EXIT

;~~~~~~~~~~~~~~~
50
; charge state not known
; if estimating, calculate percent based on estimate

        MOV     R0,#PortableBMUV_ChargeEstimate ; read estimate
        SWI     XPortable_ReadBMUVariable
        EXIT    VS                              ; exit if error
        TEQS    R1,#&FF                         ; valid estimate?
        LDRB    R0,Task_Flags
        ORRNE   R0,R0,#F_Estimating             ; if so, set estimate flag
        BICEQ   R0,R0,#F_Estimating             ; if not, clear it
        STRB    R0,Task_Flags
        BNE     %B10                            ; branch if valid
        EXIT

;******************************************************************************

        LTORG

        END
