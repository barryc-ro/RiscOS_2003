        TTL     Sound System v3.0 -> <wini>arm.Sound0.Sound0

; *************************************************
; **                                             **
; **       ARTHUR Sound System Software          **
; **                                             **
; **    MODULE: SoundDMAHandler                  **
; **            Level0 Sound System Module       **
; **                                             **
; **    AUTHORS: David Flynn (alas, no more)     **
; **             Stuart Swales (ditto)           **
; **             Tim Dobson                      **
; **             Mark Taunton                    **
; **                                             **
; **    DESCRIPTION: all the privileged access   **
; **            to hardware/physical addresses   **
; **                                             **
; **    ENTRIES: IRQ  from Sound Buffer IRQ      **
; **             SWIs for system level interface **
; **             CLI  commands interface         **
; **                                             **
; *************************************************

; 1.05  EPROM release
; 1.06  Change help messages to add full stops
; 1.07  prevent ROM code linking to vector twice!
; 1.08  fix ROUT bug which corrupted Overrun fix
; 1.09  Service call reset IRQ problem...
; 1.10  Stereo help text fix
; 1.11  Tokenise help. SKS. Was looping freeing in death, not necessary
;       shorter exit sequences with {pc}^. Common error exits. Silly error
;       from irq claim failure. New irq scheme makes shorter + sexier
;       moved audio bug fix to proper place
;       Use spare registers in SWI handler
; 1.12  Fixed more places where IRQ could get in
; 1.13  Pass SoundLevel0Base around - a useful constant indeed!
;       Fixed RESET disabling sound problem. IRQ code neater, faster
; 1.14  Stereo can take optional '+' sign, does services
; 1.15  Had to take out overrun capability as it was much too dangerous
; ---- Released for Arthur 2.00 ----
; 1.16  Added code to cope with Fox VIDC clock speed adjustment
;       Modified header GETs so they work again
; 1.17  Internationalised
; 1.18  OSS  Added assemble time code for A500 which modifies the DMA
;            buffer for VIDC1 (rather than VIDC1a). Code courtesy of JRoach.
; 1.20  01 Mar 92  OSS  Changed to execute A500 buffer modify code in RAM to
;                       minimise the chance of overruns.
; 1.21  07-Aug-92  TMD  Re-added MEMC2 option
; 1.22  27-Aug-92  TMD  Put in VIDC20 option
; 1.23  16-Feb-93  TMD  Corrected for rotation of stereo image registers on VIDC20
; 1.24  25-May-93  MT   Added IOMD support; also conditionals (defined in xxHdr
;                       file) to handle loudspeaker on/off control (SpkControl)
;                       and sound clock frequency variation with video mode
;                       (VarSndClock). Older machines have both: Medusa has
;                       neither.
; 1.25  02-Jul-93  MT   Sound0Hack flag (defined in JordanHdr) now
;                       checked when assembling IOMD version, to avoid
;                       use of OS_Memory (not yet available), and
;                       OS_ClaimDeviceVector with IOMD DMA channels as
;                       devices (since that is also not yet ready).
;                       We use privileged knowledge about kernel's
;                       memory addressing variables to circumvent the
;                       first problem, and IrqV instead of the real
;                       IRQ vector, for the second.
; 1.26  09-Jul-93  TMD  Fix stack imbalance in unknown IRQ code.
; 1.27  15-Jul-93  JSR  Switch to new headers system.
; 1.28  06-Aug-93  MT   Fix bug in IOMD code where overrun (e.g. when
;                       interrupts were disabled for more than a
;                       buffer time) caused system lockup because of
;                       failure to program the correct buffer.
; 1.29  06-Aug-93  MT   No software change - merely getting version number
;                       right here.
; 1.30  11-Aug-93  MT   Fix handling of service call (bug MED-00362)
; 1.31  11-Aug-93  MT   Add the above line and this one, forgotten before (no
;                       code change).
; 1.32  26-Aug-93  OL   Libra mods: International_Help bit set for *audio,
;                       *speaker, *stereo. (These log lines added by MT.)
; 1.33  02-Sep-93  MT   Turned off Sound0Hack (no longer needed, but left in
;                       source for now); fixed stack imbalance bug in code for
;                       exit on XOS_Memory failure; added log entry for 1.32.
; 1.34  05-Oct-93  MT   Corrected flags to XOS_Memory, to fix bug MED-00621.
; 1.35  11-Nov-93  JSR  Fix MED-00820 - fix international help for *Stereo command.
;                       Install, but leave disabled, sound quenching code to quieten
;                       the quiet bits.
; 1.36  14-Feb-94  TMD  Fix MED-02859 - don't call InitResetCommon on Service_Reset
;                       unless it's a soft reset.
; 1.37  30-Jun-94  MT   Removed Sound0Hack, no longer needed, and JSR's sound quenching
;                       code - newer hardware fixes this `properly'.  Major surgery
;                       throughout, to support 16-bit output (set up by CMOS config).
; 1.38  12-Jul-94  MT   Fix problem with Sound_SampleRate setting new rate without VIDC
;                       programming offset of 2.  Also cure duff error on bad param.
; 1.40  18-Oct-94  RCM  Add power saving calls for Stork see 'StorkPower'.
; 1.41  21-Oct-94  SMC  Fixed bug in level0 fill where code could ask for more than would
;                       be played.
;                       Fixed MIN-00087 - Sound_Configure code allowed buffer size to be set
;                       too large for 16bit sound. Also WorkOutVIDCParams called process_oversample
;                       which used the OLD buffer size to determine whether to oversample rather than
;                       the new one given in the SWI call.
;                       Fixed MIN-00022 - Added *Configure SoundSystem for 8bit/16bit sound.
;
; ********************  See SrcFiler log file for changes since version 1.41.
;
; 1.53 14-Apr-97  MT    Merge in changes for StrongARM compatibility, mono output and
;                       oversampling performance improvement.  Change default sample rate
;                       to 22.05Khz, if hardware support is available for this (STB/NC).
; 1.54 22-Apr-97  MT    Fix to allow mono output to be controlled (Sound_Mode 3) - although
;                       the implementation was present, the code to recognise and act on
;                       the specific SWI function code had been omitted by accident in the
;                       code merge.
; 1.59 22-Feb-01  SBF   Obsolete STB flag removed; default frequency of 20.8333kHz used in all cases
;

              GBLL    StrongARM
StrongARM     SETL    {TRUE}
              GBLL    ARM810support
ARM810support SETL    {FALSE}

        GET     Hdr:ListOpts
        OPT     OptNoList
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        $GetVIDC
        $GetMEMM
        $GetIO
        GET     Hdr:CMOS
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:PublicWS
        GET     Hdr:Tokens
        GET     Hdr:DevNos
        GET     Hdr:Proc
        GET     Hdr:VduExt
        GET     Hdr:MsgTrans
        GET     Hdr:HostFS
        GET     Hdr:DDVMacros
        GET     Hdr:NDRDebug

        OPT     OptList
        OPT     OptPage

        GET     Hdr:Sound
        GET     Hdr:Portable

        GET     Version
        GET     VersionASM

        GET     hdr.L7200


; On IOMD-based systems, to support sound DMA "cheaply" in terms of
; software complexity, we must have physical sound buffers no bigger
; than the maximum DMA buffer IOMD supports (i.e. number of bytes
; transferred per DMA interrupt).  This is 4Kbytes: the size of a page
; on ARM{6,7}00 machines.  In addition, for each sound DMA buffer,
; either it must all lie within a single physical page, or else the
; pages which contain it must be physically contiguous.  We could
; survive any combination of values for SoundDMABufferSize and
; SoundDMABuffers which satisfied both these conditions. However it is
; simpler here (e.g. no need for physical contiguity check) just to
; use the tighter condition that the SoundDMABufferSize is *exactly*
; 4096 and that the base address of the sound buffers is on a 4096
; byte boundary. This was true for the original values as used on
; MEMC1 systems, and is unlikely to need to change. Therefore this
; tighter restriction is OK.

    [ SoundDMABufferSize /= 4096
        ! 1, "SoundDMABufferSize must be exactly 4096 for Sound0 on IOMD"
    ]
    [ SoundDMABuffers :MOD: 4096 /= 0
        ! 1, "SoundDMABuffers must be 4096-byte-aligned for Sound0 on IOMD"
    ]

; In addition, for yet more simplification, and minimum code change to
; support IOMD, we assume here that the two 4Kb sound buffer pages are
; physically contiguous (in the right order!), so that we can continue
; to use only one word [rLevel0Base,#Phys0] to hold the base address.
; This assumption cannot currently (21-May-93) be tested at assembly
; time.

        GBLL    debug
debug           SETL    False

        GBLL    hostvdu
hostvdu         SETL    True

swi     SETD    False

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Level0 data structure

; Sound0Segment:  Sound DMA Control Block
;
; Total of 16 words available.  First 9 must NOT be reordered without also
; fixing static copy (ProtoS0S) and init code, since an LDM/STM pair is used
; with specific registers known to match particular fields
          ^ 0
Semaphore # 4
Phys0     # 4   ; physical address of buffer 0
Buff0     # 4   ; logical page addresses...
Buff1     # 4
Config    # 0
BuffLenLo # 1   ; 16-bit Buffer Length
BuffLenHi # 1
Period    # 1   ; 8-bit SFG period
NChannels # 0   ; Log channels (3 bit) AND sundry flags
Flags     # 1   ; Name for flags byte
Level1Ptr # 4
Images    # 8   ; (8) byte image positions, full 8-bit resolution of user value (-127..127)
Level2Ptr # 4   ; scheduler

; End of order-critical section. From here on, items are initialised
; dynamically and one item at a time, hence order is not significant.

; To cope with hardware DMA buffer pipeline, need to keep parallel pipelines
; for SIB_ASD.
SRC_N     # 2   ; (new) value to stick into SRC to program audio sample rate divisor
SRC_H     # 2   ; value which IRQ code should ensure is in SRC on next irq
SRC_C     # 2   ; softcopy of value currently set in SRC

; Code to handle stereo 16-bit linear emulation of N-channel mu-law needs to
; keep track of how many channels are in use.
Log2nchan_C # 1 ; Log2(currently active channel count), as compiled into 16-bit conv code

Spare0    # 1

ImagesC_N # 4   ; compacted (new) version of Images, for prog'ing conv. routine
ImagesC_H # 4   ; value which IRQ code will load into conv. routine on next irq
ImagesC_C # 4   ; softcopy of value currently programmed into conv. routine
SoundRMA  # 4   ; pointer to remaining data/dynamic code items held in RMA
SoundGain # 1   ; value of additional gain (0..7) -> +0 .. 21dB in 3dB steps, for mu-law
SoundGain_C # 1 ; value of additional gain as currently compiled into conv code

; Currently 2 bytes free

        ASSERT  @ <= SoundLevel0Reserved

; Constants
; SC prefix for SoundConstant
SCPeriod     * 45                       ; default, i.e. 22.05 kHz

SCBufferLen  * 208                      ; 208 bytes/channel (&D0: multiple of 16)
SCLogChannel * 0                        ; default log2nchan = 0 -> 1 channel
SCSoundGain  * 0                        ; default soundgain is 0

; Flags bits in NChannels/Flags byte: bottom 2 bits are log2nchan, next 2 bits are
; Lin16 flags, 1 bit for auto-oversampling flag, 1 bit for "oversampling active" flag,
; 1 bit for mono-isation flag, top bit reserved (probably unnecessarily) for Level1Fill
; handler call "Level0 updated" flag.
DoMono          *       &40             ; mono-isation control bit
DoOversample    *       &20             ; oversampling active bit
OverMonoShift   *       5               ; shift to get to OS/Mono as 2-bit field
OversampleFlag  *       &10             ; AutoOversampling flag from CMOS
Lin16Bits       *       &0C             ; flags for 16-bit linear mode (VIDC20)
Lin16Shift      *       2

; Definition of cut-off point for oversampling
MinOSPeriod     *       42              ; do not oversample if period < 42 (f > 24kHz)

; Level0 constants

; Physical address of sound DMA buffers is not fixed on IOMD systems, but
; needs to be determined at initialisation time.


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module Header
        OPT     OptPage

        AREA    |Sound0$$Code|, CODE, READONLY, PIC

Module_Base
        DCD     0                    ; NOT AN APPLICATION
        DCD     Initialise_Module    - Module_Base
        DCD     Finalise_Module      - Module_Base
        DCD     Intercept_Services   - Module_Base
        DCD     Module_Name          - Module_Base
        DCD     Help_String          - Module_Base
        DCD     Module_Keywords      - Module_Base
        DCD     Module_SWISystemBase + Sound0SWI * Module_SWIChunkSize
        DCD     Sound_SWI_Code       - Module_Base
        DCD     Module_SWIDecodeBase - Module_Base
        DCD     0                    ; No decoding code.
 [ International_Help <> 0
        DCD     message_filename     - Module_Base
 |
        DCD     0
 ]
 [ :LNOT: No32bitCode
        DCD     Module_Flags         - Module_Base
 ]

Module_Name
        DCB     "SoundDMA", 0

Help_String
        DCB     "SoundDMA"
        DCB     9
        DCB     "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
        DCB     " $Module_MinorVersion"
 ]
 [ Development
        DCB     " Development"
        DCB     " IRQs disabled"
 ]
        DCB     " AC97 version"
        DCB     0

Module_SWIDecodeBase
        DCB     "Sound",0
        DCB     "Configure",0
        DCB     "Enable",0
        DCB     "Stereo",0
        DCB     "Speaker",0
        DCB     "Mode",0
        DCB     "LinearHandler",0
        DCB     "SampleRate",0
        DCB     0

Module_Keywords

        DCB     "Audio", 0
        ALIGN
        DCD     Audio_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)   ; all flags clear, and one parameter ONLY
        DCD     Audio_Syntax - Module_Base
        DCD     Audio_Help   - Module_Base

        DCB     "Speaker", 0
        ALIGN
        DCD     Speaker_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)   ; all flags clear, and one parameter ONLY
        DCD     Speaker_Syntax - Module_Base
        DCD     Speaker_Help   - Module_Base

        DCB     "Stereo", 0
        ALIGN
        DCD     Stereo_Code   - Module_Base
        DCB     2, 0, 2, 0:OR:(International_Help:SHR:24)   ; all flags clear, two parameters ONLY
        DCD     Stereo_Syntax - Module_Base
        DCD     Stereo_Help   - Module_Base

        DCB     "SoundGain", 0
        ALIGN
        DCD     SoundGain_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)
        DCD     SoundGain_Syntax - Module_Base
        DCD     SoundGain_Help   - Module_Base

        DCB     "SoundSystem", 0
        ALIGN
        DCD     SoundSystem_Code   - Module_Base
        DCB     1, 0, 2, 0:OR:(International_Help:SHR:24):OR:(Status_Keyword_Flag:SHR:24)
        DCD     SoundSystem_Syntax - Module_Base
        DCD     SoundSystem_Help   - Module_Base

        DCB     0            ; no more entries.

        GET     s.TokHelpSrc

        ALIGN

 [ :LNOT: No32bitCode
Module_Flags
        DCD     ModuleFlag_32bit
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;
; MT, May/June 1994.
;
; Code fragments used to convert from 1/2/4/8 channels of
; 8-bit mu-law sound in the "logical" buffer, to 2 channels of
; either 16-bit linear sound or 8-bit mu-law sound in the same
; buffer, now treated as a "physical" buffer to be output by DMA.
; Note the complexities caused because the logical buffer may
; be smaller than, the same size as, or bigger than the physical
; buffer, depending on the input and output sample-group sizes.
; There are always the same number of sample-groups in the physical
; buffer as in the logical buffer, and the sample rate is unaltered
; also.
;
; These fragments are compiled dynamically after any sound system
; reconfiguration or stereo position change, to cause the correct
; translation of data after the next sound DMA interrupt.  The compiled
; code lives in module workspace, whereas the conversion table stays
; here in module code space (though it might usefully be copied into
; RAM to maximise access speed if this code is running from ROM).
;
; On call to composite routine
;
;   r12 = start of logical/physical buffer
;   r11 = end of physical buffer (1,2 channels) or
;         start of physical buffer (4,8 channels)
;   r10 = end of logical buffer
;   r9  = base of 256-entry, 512-byte table converting mu-law bytes
;         (treated as 0..255, i.e. unsigned) to 16-bit signed
;         values in the range -3952..+3952.  See below
;         for more details on the format of entries.
;   r8  = 0xFF - mask for extraction of individual mu-law bytes
;   r5  = 0x7FFF - constant used for limit operation if soundgain > 0
;
; during call:
;   r7  = 32-bit accumulator for right channel linear data
;   r6  = 32-bit accumulator for left channel linear data
;   r0, r1, r3 - miscellaneous intermediate values
;   r2, r4, r5 - unused

; Conversion table (placed here to avoid addressing problems for the
; compiler).  Compute linear values from mu-law at assembly time.  For
; reference, the direct linear equivalents of mu-law values are:
;
; 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
; 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46
; 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108
; 112 120 128 136 144 152 160 168 176 184 192 200 208 216 224 232
; 240 256 272 288 304 320 336 352 368 384 400 416 432 448 464 480
; 496 528 560 592 624 656 688 720 752 784 816 848 880 912 944 976
; 1008 1072 1136 1200 1264 1328 1392 1456 1520 1584 1648 1712 1776 1840 1904 1968
; 2032 2160 2288 2416 2544 2672 2800 2928 3056 3184 3312 3440 3568 3696 3824 3952
;

convtable
        GBLA    chord
        GBLA    point
        GBLA    step
        GBLA    value
value   SETA    0
chord   SETA    0
        WHILE   chord < 8
step      SETA  1 :SHL: chord
point     SETA  0
          WHILE point < 16
            DCD         (((-value) :SHL: 2) :AND: &FFFF) :OR: ((value :SHL: 2) :SHL: 16)
value       SETA        value + step
point       SETA        point + 1
          WEND
chord     SETA  chord + 1
        WEND

; When size (logical buffer) >= size (physical buffer) we must proceed
; forward, loading via r12 which is stepped forwards until it equals
; r10.  Note that in this case r11 starts off = r12.  When the size of
; the logical buffer < size of physical buffer, must move backwards -
; r11 is initialised to end of physical buffer; hence r10 moves
; backwards and r12 stays constant as end-stop for logical buffer.
; End-condition is still r10 = r12.

; Instruction sequence (1): loop begin (same for all configurations)
loop_head
        CMP     R10, R12                ; check for having finished
        Pull    PC, EQ                  ; return if so

; Instruction sequence (2): load up a sample-time's worth of data (1..8 bytes), and
; check whether it is all zero. One instruction for each part, two instructions
; per sequence.  Indexed by log2nchan.
data_load_TAB
        LDRB    r1, [r10, #-1]!         ; instruction for loading 1 byte (backwards)
        MOVS    r1, r1, LSL #24         ; get 1 byte in top byte of r1, zero in rest

        LDR     r1, [r10, #-2]!         ; instruction for loading 2 bytes (backwards)
        MOVS    r1, r1, LSL #16         ; get 2 bytes in top half of r1, zero low bytes

        LDR     r1, [r12], #4           ; instruction for loading 4 bytes (forwards)
        MOVS    r1, r1                  ; check it for all 4 bytes being 0

        LDMIA   r12!, {r0,r1}           ; instruction for loading 8 bytes (forwards)
        ORRS    r3, r0, r1              ; result -> temp, to avoid corruption of r0/r1

; Instruction sequence (3): conditionally store a zero output value,
; for when input data is all 0.   Indexed by log2nchan>>1.
zero_store_TAB
; for log2nchan>>1 = 0 (i.e. 1, 2 channels)
        STREQ   r1, [r11, #-4]!         ; if 0, store out a zero and
; for log2nchan>>1 = 1 (i.e. 4, 8 channels)
        STREQ   r1, [r11], #4           ; if 0, store out a zero and

; Instruction sequence (4): conditionally branch back to
; start of loop if input data was all 0 for this sample.
zero_branch
        BEQ     .-(5*4)                 ; branch back to loop_head

; Instruction sequence (5): extract one byte out of 0 through 7 of the 1..8
; bytes picked up by instruction sequence (2), and put it into r3, testing
; for 0 as this is done.  One instruction word for each case.  Entries in
; this table are used starting from the (8-nchan)'th one, up to the required
; number of channels, hence the apparent oddity of the zero-data test
; instructions for 1,2 channels.  Note that the 1-channel case is slightly
; inefficient since we have already checked for all 1 byte being zero - if we
; hadn't done a LSL 24 in the process, we could dispense with this
; instruction, but that would be less regular so we just take the minor hit.
byte_ext_TAB
        ANDS    r3, r8, r0              ; byte 0
        ANDS    r3, r8, r0, LSR #8      ; byte 1
        ANDS    r3, r8, r0, LSR #16     ; byte 2
        ANDS    r3, r8, r0, LSR #24     ; byte 3 (could just be MOVS)
        ANDS    r3, r8, r1              ; byte 4
        ANDS    r3, r8, r1, LSR #8      ; byte 5
        ANDS    r3, r8, r1, LSR #16     ; byte 6
        ANDS    r3, r8, r1, LSR #24     ; byte 7 (could just be MOVS)

; Instruction sequence (6): load up linear value for mu-law byte, from
; table.  This always follows the extraction instruction (above) and is
; conditionalised on Z flag from ANDS, to allow faster execution on zero
; byte value (i.e. no load is actually done and r3 stays 0).  N.B.  As
; should be apparent from its definition, The table holds 16-bit values,
; arranged as +ve/-ve pairs, in words.  The access is indexed with LSL #1
; (i.e. 2-byte entries) but is performed as an LDR, so we get both -ve and
; +ve values, with the required one in the top half of r3, because of ARM's
; data rotation on non-word aligned LDRs.  The subsequent stereo position
; code extracts this value using ASR #n where n varies according to the
; required multiplicative factor for the particular stereo position.
; Within the table entries, each value is the basic 12-bit linear value,
; shifted left by 2, and sign-extended to 16-bits.  This leaves the bottom
; two bits 0, so that ASR #18, 17 or 16 then produces the original value
; times 1, 2 or 4 (respectively), sign extended to 32 bits.

conv_byte
        LDRNE   r3, [r9, r3, LSL #1]

; Instruction sequence (7): set or add linear value just loaded, in the
; correct proportions according to stereo position for channel, into stereo
; accumulators.  Some sequences are two instructions, others 3, so we store
; them here as 3 words each (for indexing during compilation) with the 3rd
; one 0 if not required.  The sequences come in pairs, the first of each
; pair being for the first channel, when the accumulators are initialised,
; and the second for subsequent channels, when the accumulators are added
; to.  This saves at least one instruction in the generated code, over
; pre-initialising both accumulators to 0, and more often than not, 2.

stereo_code
; 100% left
; code for first channel: r6 = (r3 >> 18) * 6 = (r3 >> 17) + (r3 >> 16)
        MOV     r6,     r3, ASR #17
        ADD     r6, r6, r3, ASR #16
        MOV     r7, #0                  ; init right acc to 0
; code for remaining channels
        ADD     r6, r6, r3, ASR #17
        ADD     r6, r6, r3, ASR #16
        DCD     0
; 83% left
; code for first channel: r6 = (r3 >> 18) * 5 = (r3 >> 16) + (r3 >> 18); r7 = r3 >> 18
        MOV     r6,     r3, ASR #16
        ADD     r6, r6, r3, ASR #18
        MOV     r7,     r3, ASR #18
; code for remaining channels
        ADD     r6, r6, r3, ASR #16
        ADD     r6, r6, r3, ASR #18
        ADD     r7, r7, r3, ASR #18
; 67% left
; code for first channel: r6 = (r3 >> 18) * 4 = r3 >> 16; r7 = (r3 >> 18) * 2 = r3 >> 17
        MOV     r6,     r3, ASR #16
        MOV     r7,     r3, ASR #17
        DCD     0
; code for remaining channels
        ADD     r6, r6, r3, ASR #16
        ADD     r7, r7, r3, ASR #17
        DCD     0

; Centre position.  Note that to avoid overflow problems we compute
; r3*1.5, then add r3 ASR #17 (== >> 18 then *2) to each accumulator.
; The multiplication by 1.5 is exact because we have 2 spare 0 bits at
; the bottom of the value.  Overflow from the multiplication in the
; lower half (when that is -ve, i.e. when the required value is +ve)
; does not interfere, since it may reach bit 16, but that gets shifted
; out.

; Code for first channel
        ADD     r3, r3, r3, ASR #1      ; * 1.5
        MOV     r6,     r3, ASR #17     ; == shifted right by 18, then * 2
        MOV     r7,     r3, ASR #17
; Code for remaining channels
        ADD     r3, r3, r3, ASR #1
        ADD     r6, r6, r3, ASR #17
        ADD     r7, r7, r3, ASR #17

; 67% right: the mirror of 67% left
; code for first channel
        MOV     r7,     r3, ASR #16
        MOV     r6,     r3, ASR #17
        DCD     0
; code for remaining channels
        ADD     r7, r7, r3, ASR #16
        ADD     r6, r6, r3, ASR #17
        DCD     0

; 83% right: mirror of 83% left
; code for first channel
        MOV     r7,     r3, ASR #16
        ADD     r7, r7, r3, ASR #18
        MOV     r6,     r3, ASR #18
; code for remaining channels
        ADD     r7, r7, r3, ASR #16
        ADD     r7, r7, r3, ASR #18
        ADD     r6, r6, r3, ASR #18

; 100% right: mirror of 100% left
; code for first channel
        MOV     r7,     r3, ASR #17
        ADD     r7, r7, r3, ASR #16
        MOV     r6, #0                  ; initialise left acc to 0
; code for remaining channels
        ADD     r7, r7, r3, ASR #17
        ADD     r7, r7, r3, ASR #16
        DCD     0

; Instruction sequence (8): scaling code, to convert accumulated values
; (32-bit) back into signed 16-bit numbers.  For 8 channels, the maximum
; absolute value in either accumulator is 6*3952*8 = 189696.  To convert
; this into the range 0..32767 requires multiplying by 32767/189696 =
; .1727342...  We approximate this by multiplying by 11/64 = .171875,
; achieved using ADDs/shifts for the *11 and ASR #6 for the /64.  Exactness
; is unimportant, since all the slightly low value introduces is a small
; gain reduction.  For 1, 2 or 4 channels, the maximum value reduces in
; proportion to the number of channels, so the code is the same except for
; the N in ASR #N which is 3,4,5,6 for 1,2,4,8 channels.

; Version 1.52 onwards: supports *soundgain giving 0 to +21dB additional
; gain, with 3dB increments, in mu-law to linear conversion.  This is
; achieved by using a multiplier of *11 and a divisor of 64 (ASR #6) to give
; 0dB for the 8-channel case, with reducing right shifts as channel count
; decreases or gain is increased in 6dB steps.  For the +3dB steps, don't do
; the mul by 11, but divide by 4 (ASR #2) for 8-channel case, to give
; effectively a +3dB increment, and again reduce the right shift constant or
; go to a left shift for reducing channel count or each extra +6dB gain.
;

; (8a): First the *11 code, the same for all configurations: this is inserted
; only when soundgain is even (i.e. 0dB, 6dB, 12dB, 18dB)
scale_mul_even
        ADD     r0, r6, r6, LSL #1      ; r6 * 3
        ADD     r6, r0, r6, LSL #3      ; + r6 * 8 = r6 * 11
        ADD     r0, r7, r7, LSL #1      ; r7 * 3
        ADD     r7, r0, r7, LSL #3      ; + r7 * 8 = r7 * 11

; (8b): gain scaling code, 2 instructions; table indexed by
;       7+log2nchan-soundgain DIV 2-(soundgain MOD 2 * 4).
scale_TAB                       ;       1ch     2ch     4ch     8ch
                                ;----------------------------------
        MOV     r6, r6, LSL #4  ;0      +21     -       -       -  GAIN (soundgain odd)
        MOV     r7, r7, LSL #4  ;       -       -       -       -  GAIN (soundgain even)

        MOV     r6, r6, LSL #3  ;1      +15     +21     -       -
        MOV     r7, r7, LSL #3  ;       -       -       -       -

        MOV     r6, r6, LSL #2  ;2      +9      +15     +21     -
        MOV     r7, r7, LSL #2  ;       -       -       -       -

        MOV     r6, r6, LSL #1  ;3      +3      +9      +15     +21
        MOV     r7, r7, LSL #1  ;       -       -       -       -

        DCD     0               ;4      -       +3      +9      +15
        DCD     0               ;       +18     -       -       -

        MOV     r6, r6, ASR #1  ;5      -       -       +3      +9
        MOV     r7, r7, ASR #1  ;       +12     +18     -       -

        MOV     r6, r6, ASR #2  ;6      -       -       -       +3
        MOV     r7, r7, ASR #2  ;       +6      +12     +18     -

        MOV     r6, r6, ASR #3  ;7      -       -       -       -
        MOV     r7, r7, ASR #3  ;       +0      +6      +12     +18

        MOV     r6, r6, ASR #4  ;8      -       -       -       -
        MOV     r7, r7, ASR #4  ;       -       +0      +6      +12

        MOV     r6, r6, ASR #5  ;9      -       -       -       -
        MOV     r7, r7, ASR #5  ;       -       -       +0      +6

        MOV     r6, r6, ASR #6  ;10      -       -       -       -
        MOV     r7, r7, ASR #6  ;       -       -       -       +0

; Instruction sequence (8c): do limiting (clipping) on output values:
; only used if soundgain > 0.
limit
        MOV     r0, r6, ASR #31         ; get r6 sign bit throughout r0
        CMP     r0, r6, ASR #15         ; check for overflow
        EORNE   r6, r0, r5              ; if so, get &00007FFF or &FFFF8000 in r6
        MOV     r0, r7, ASR #31         ; get r7 sign bit throughout r0
        CMP     r0, r7, ASR #15         ; check for overflow
        EORNE   r7, r0, r5              ; if so, get &00007FFF or &FFFF8000 in r7

; Instruction sequence (9): combine 2 x 16-bit values (sign-ext'd to
; 32-bits) from r6 and r7 into r6 ready for storing.  Same for all
; configurations.
combine
        MOV     r6, r6, LSL #16
        MOV     r7, r7, LSL #16
        ORR     r6, r6, r7, LSR #16

; Instruction sequence (10): store out the result: code for either
; direction (1 instruction each).  Index by log2nchan>>1.
store_sample
; for 1,2 channels
        STR     r6, [r11, #-4]!         ; backwards
; for 4,8 channels
        STR     r6, [r11], #4           ; forwards

; Instruction sequence (11): branch back to start of loop.  This
; instruction is adjusted in accordance with the total size of the loop
; code, which is dependent on both configuration (# channels) and also on
; individual stereo positions per channel.
loop_end
        B       .                       ; patched during compilation

; Defined maximum size of the conversion code.  This is:
;       size of sequence(1;2;3;4)         = 4 * (       (2 + 2 + 1 + 1)
; + 8 * size of sequence(5;6;7(max-size))        +  8 * (1 + 1 + 3)
; +     size of sequence(8a;8b;8c;9;10;11)       +      (4 + 2 + 6 + 3 + 1 + 1))

MAXLinConvCodeSize *  4 * ((2 + 2 + 1 + 1) + 8 * (1 + 1 + 3) + (4 + 2 + 6 + 3 + 1 + 1))


; Compile: generate a conversion routine appropriate to current configuration and
; stereo position settings.
; Entry conditions:
;   SVC or IRQ mode, IRQs disabled (essential for atomic rewrite of code!)
; Parameters:
;   r0 = log2nchan, i.e. 0 -> 1 channel, 1 -> 2 chans, 2 -> 4 chans, 3 -> 8 chans
;   r1 = pointer to space for compiled routine, in module workspace
;   r2 = compacted array of stereo position values, 8x3 bits each (1-based)
;        in bits 0..23, with soundgain (0..7) in top byte.

compile
        STMFD   sp!, {r1,r3-r9,lr}      ; save r3-r9,pc', and code start address (r1) for later

        ; (1): loop head code (fixed, 2 instructions)
        ADR     r3, loop_head
        LDMIA   r3,  {r4,r5}
        STMIA   r1!, {r4, r5}
        ; (2): data load and zero check: 2 instructions, indexed by log2nchan
        ADR     r3, data_load_TAB
        ADD     r3, r3, r0, LSL #3      ; 8 bytes each
        LDMIA   r3,  {r4, r5}           ; get 2 instructions
        STMIA   r1!, {r4, r5}           ; store them
        ; (3): conditional zero-store
        ADR     r3, zero_store_TAB
        MOV     r4, r0, LSR #1          ; index by log2nchan>>1
        LDR     r4, [r3, r4, LSL #2]    ; 4 bytes each, get 1 instr
        STMIA   r1!, {r4}               ; store it
        ; (4): conditional branch back
        LDR     r4, zero_branch         ; get the instruction
        STMIA   r1!, {r4}               ; store it out

        ; preserve soundgain value, for later (r2 gets shifted in next loop)
        MOV     r7, r2, LSR #24         ;

        ; Now the per-channel code.  Get r9 as nchans, and use r8
        ; as loop variable from 0 to nchans-1.
        MOV     r9, #1
        MOV     r9, r9, LSL r0          ; get nchans in r9
        MOV     r8, #0                  ; start at channel 0
10
        ; (5): byte-extraction code, per channel
        ADR     r3, byte_ext_TAB+8*4
        SUB     r3, r3, r9, LSL #2      ; start from (8-nchan)th entry
        LDR     r4, [r3, r8, LSL #2]    ; get the instruction for this channel
        STMIA   r1!, {r4}               ; store it out
        ; (6): byte-conversion (1 instruction, fixed)
        LDR     r4, conv_byte           ; get it
        STMIA   r1!, {r4}               ; store it
        ; (7): stereo positioning: index by channel position, and by
        ; whether this is the first channel (channel 0) or not.
        ADR     r3, stereo_code
        AND     r4, r2, #7              ; get this channel's value
        MOV     r2, r2, LSR #3          ; shift remaining channels down
        SUB     r4, r4, #1              ; convert to 0-based value
        ADD     r4, r4, r4, LSL #1      ; * 24 (3 w/seq * 2 seq/pos * 4b/w), first *3...
        ADD     r3, r3, r4, LSL #3      ; then *8, to index table of sequences
        CMP     r8, #0                  ; if not on channel 0...
        ADDNE   r3, r3, #3*4            ;  skip on to second 3-word seq of pair
        LDMIA   r3, {r4,r5,r6}          ; pick up three words
        CMP     r6, #0                  ; check for last being 0 (unused)
        STMEQIA r1!, {r4,r5}            ; if so, store out 2 only
        STMNEIA r1!, {r4,r5,r6}         ; else store out all 3

        ; OK, done one channel's code.  Step on.
        ADD     r8, r8, #1
        CMP     r8, r9
        BLT     %BT10                   ; branch back if more channels to do

        ; (8): scaling code, in three parts.
        ; (8a): if soundgain is even, multiply by 11 (same for all modes) - 4 insts
        ;       note: r7 holds soundgain value from above
        TST     r7, #1
        ADREQ   r2, scale_mul_even
        LDMEQIA r2!, {r3,r4,r5,r6}
        STMEQIA r1!, {r3,r4,r5,r6}

        ; (8b): next perform scaling (shifting) as required, using
        ;  scale_TAB[7+log2nchan-soundgain DIV 2-(soundgain MOD 2 * 4)]

        ADR     r2, scale_TAB+7*2*4     ; address scale_TAB[7]
        SUB     r6, r0, r7, LSR #1      ; compute (log2nchan - soundgain DIV 2)
        SUBNE   r6, r6, #4              ; if soundgain odd, subtract 4 (c/c still valid)
        ADD     r2, r2, r6, LSL #3      ; then scale for 2 instructions/entry
        LDMIA   r2, {r4,r5}             ; get the 2 instructions
        CMP     r4, #0                  ; if first instr is not 0 (for NOP)...
        STMNEIA r1!, {r4,r5}            ; ...store them

        ; (8c) perform limiting on sample values if required (i.e. soundgain > 0)
        ADR     r2, limit
        CMP     r7, #0
        LDMNEIA r2,  {r3,r4,r5,r6,r7,r8}  ; 6 instructions (3/channel)
        STMNEIA r1!, {r3,r4,r5,r6,r7,r8}  ; store them

        ; (9): combining two samples into 1 word - 3 fixed instructions
        ADR     r3, combine
        LDMIA   r3, {r4,r5,r6}          ; get them
        STMIA   r1!, {r4,r5,r6}         ; store them

        ; (10): store out the sample, 1 instruction - 2 cases.
        ADR     r3, store_sample
        MOV     r4, r0, LSR #1          ; get log2nchan>>1
        LDR     r4, [r3, r4, LSL #2]    ; index table of single word instrs
        STMIA   r1!, {r4}               ; store it out

        ; (11): branch back to loop start code.  Need to compute offset here
        LDR     r4, loop_end            ; get the B . instruction (note: bits 23..3 are 1)
        LDMFD   sp!, {r0}               ; pop original code start (loop top)
    [ StrongARM
        STMFD   sp!,{r0-r2}
        MRS     r3, CPSR
        MSR     CPSR_c, #I32_bit+SVC32_mode
        MOV     r5, lr_svc
        SUB     r2, r1, #4
        MOV     r1, r0
        MOV     r0, #1
        SWI     XOS_SynchroniseCodeAreas
        MOV     lr_svc, r5
        MSR     CPSR_c, r3
        LDMFD   sp!,{r0-r2}
    ]
        SUB     r0, r1, r0              ; work out offset from there to . now
        SUB     r4, r4, r0, LSR #2      ; subtract offset (in words) to get instr
        STMIA   r1!, {r4}               ; store it out and we're done!

        ; All done!
        LDMFD   sp!, {r3-r9,pc}         ; recover saved regs and go home


; Define RMA sound workspace now we know how big the A500 or mu-law-to-linear code is.

        ^       0

MessageFile_Block # 16
MessageFile_Open  #  4

; 16-bit linear support data
SavedSample       #  4                  ; Preserved stereo value from end of last buffer, for
                                        ; 2:1 linear interpolation (if configured).
Lin16GenR0        #  4                  ; Value to be passed in R0 to ...
Lin16Gen          #  4                  ; User-supplied 16-bit sound generator(/mixer) code
CurSRValue        #  4                  ; Current sample frequency in 1/1024 Hz units
CurSRIndex        #  4                  ; index into set of available frequencies
LinConvCode       #  MAXLinConvCodeSize ; Space for the dynamically-compiled mu-law to
                                        ; 16-bit-linear conversion code
DMACTRL_base      #  4
SIC_base          #  4
GPIO_base         #  4
INT_base          #  4

WorkSpaceSize     * @

        GBLA    nsr
nsr     SETA    0

        MACRO
        ACRate  $freq
        DCD     $freq*1024
        DCB     (1000000+($freq/2)) / $freq
        DCB     0,0,0
nsr     SETA    nsr+1
        MEND

ftab
        ACRate   8000
        ACRate  11025
        ACRate  16000
        ACRate  22050
        ACRate  32000
        ACRate  44100
        ACRate  48000


        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Audio_Code Entry

        BL      DecodeOnOrOff
        SWI     XSound_Enable
        EXIT

; .............................................................................

Speaker_Code ALTENTRY

        BL      DecodeOnOrOff
        SWI     XSound_Speaker
        EXIT

; .............................................................................
; Out   r0 = 1,2 (ON/OFF)
;       r12 = workspace pointer

DecodeOnOrOff ROUT

        LDR     r12, [r12]              ; Get workspace pointer for caller
        LDRB    r1, [r0], #1            ; Spaces skipped already
        CMP     r1, #"O"
        CMPNE   r1, #"o"
        BNE     Bad_Parameter_Error
        LDRB    r1, [r0], #1
        CMP     r1, #"N"
        CMPNE   r1, #"n"
        BNE     %FT50
        LDRB    r1, [r0], #1            ; Ensure no trailing crap
        CMP     r1, #" "
        BHI     Bad_Parameter_Error
        MOV     r0, #2                  ;  2 -> ON
        MOV     pc, lr                  ; flags irrelevant on *-command exit

50      CMP     r1, #"F"
        CMPNE   r1, #"f"
        BNE     Bad_Parameter_Error
        LDRB    r1, [r0], #1
        CMP     r1, #"F"
        CMPNE   r1, #"f"
        CMPNE   r1, #"."
        BNE     Bad_Parameter_Error

        LDRB    r1, [r0], #1            ; Ensure no trailing crap
        CMP     r1, #" "
        BHI     Bad_Parameter_Error
        MOV     r0, #1                  ;  1 -> OFF
        MOV     pc, lr                  ; flags irrelevant on *-command exit

Bad_Parameter_Error
        ADR     r0, ErrorBlock_BadSoundParameter

ReturnError ; For star commands

        BL      CopyError
        PullEnv
        RETURNVS

        MakeInternatErrorBlock BadSoundParameter,,M00

; .............................................................................

Stereo_Code ALTENTRY

        LDR     r12, [r12]              ; Get workspace pointer
        MOV     r1, r0
        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned
        BVS     Stereo_Channel_Error

        SUB     r14, r2, #1             ; Ensure in 1..SoundPhysChannels
        CMP     r14, #SoundPhysChannels
        BHS     Stereo_Channel_Error

        MOV     r4, r2                  ; preserve

10      LDRB    r3, [r1], #1            ; strip spaces
        CMP     r3, #" "
        BEQ     %BT10

        TEQ     r3, #"-"                ; signed?
        TEQNE   r3, #"+"
        SUBNE   r1, r1, #1              ; retrace our steps

        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned
        BVS     Stereo_Position_Error

        CMP     r2, #127
        BHI     Stereo_Position_Error

        TEQ     r3, #"-"                ; invert now if -ve
        RSBEQ   r2, r2, #0

        MOV     r0, r4                  ; channel no.
        MOV     r1, r2                  ; Position
        SWI     XSound_Stereo
        EXIT


Stereo_Channel_Error
        ADR     r0, ErrorBlock_BadSoundChannel
        B       ReturnError

        MakeInternatErrorBlock BadSoundChannel,,M01


Stereo_Position_Error
        ADR     r0, ErrorBlock_BadSoundStereo
        B       ReturnError

        MakeInternatErrorBlock BadSoundStereo,,M02

; .............................................................................

SoundSystem_Code
; In:   r0 = 0  => print syntax only
;       r0 = 1  => print current status
;       r0 > 1  => configure new value
;
        LDR     r12, [r12]

        Entry   "r1-r3"

        CMP     r0, #1
        BEQ     %FT10
        BCS     %FT20

        SWI     XOS_WriteS                      ; Print syntax only.
soundsystem_string
        DCB     "SoundSystem  ",0
        ALIGN
        SWI     XOS_WriteS
        DCB     "16bit [Oversampled] | <D>",0
        SWIVC   XOS_NewLine
        EXIT

10
        MOV     r0, #161                        ; Print status so read CMOS.
        MOV     r1, #PrintSoundCMOS
        SWI     XOS_Byte
        ADRVC   r0, soundsystem_string
        SWIVC   XOS_Write0
        EXIT    VS

        ADR     r0, parameter_16bit
        SWI     XOS_Write0
        EXIT    VS

        TST     r2, #&80
        BEQ     %FT15
        SWI     XOS_WriteI+" "
        ADRVC   r0, parameter_oversampled
        SWIVC   XOS_Write0
15
        SWIVC   XOS_NewLine
        EXIT

20
        MOV     r3, r0                          ; Save pointer to first parameter.

30
        MOV     r0, r3
        ADR     r1, parameter_16bit
        BL      strcmp_advance
        BNE     %FT40

        BL      skip_spaces                     ; "16bit" given so check for second parameter.
        MOVCC   r3, #1                          ; None, so no oversample.
        BCC     set_new_value

        ADR     r1, parameter_oversampled       ; Must be "oversampled".
        BL      strcmp_advance
        MOVEQ   r3, #5
        BEQ     set_new_value

        MOV     r0, #0                          ; Bad configure option.
exit_error
        SETV
        EXIT

40
        MOV     r0, #10:OR:(1:SHL:31):OR:(1:SHL:29)     ; Read unsigned, limit range, check terminator.
        MOV     r1, r3
        MOV     r2, #7
        SWI     XOS_ReadUnsigned
        EXIT    VS

        MOV     r0, r1                          ; Make sure number is not followed by another parameter.
        BL      skip_spaces
        MOVCS   r0, #3
        BCS     exit_error

        MOV     r3, r2
set_new_value
        MOV     r0, #161                        ; Read current value.
        MOV     r1, #PrintSoundCMOS
        SWI     XOS_Byte

        BICVC   r2, r2, #7:SHL:5                ; Set new value.
        ORRVC   r2, r2, r3, LSL #5
        MOVVC   r0, #162
        SWIVC   XOS_Byte
        EXIT


parameter_16bit
        DCB     "16bit",0
parameter_oversampled
        DCB     "Oversampled",0
        ALIGN

strcmp_advance
; In:   r0 -> string 1 (space or control char terminated)
;       r1 -> string 2 (space or control char terminated)
; Out:  EQ => strings match (no case)
;       r0 -> terminator of string 1
;       OR
;       NE => strings do not match
;
        Entry   "r2"
10
        LDRB    r2, [r0], #1
        LDRB    lr, [r1], #1
        CMP     r2, #" "                ; If found both terminators then strings are equal.
        CMPLE   lr, #" "
        BLE     %FT20

        BIC     r2, r2, #1:SHL:5
        BIC     lr, lr, #1:SHL:5
        TEQ     r2, lr
        BEQ     %BT10
        EXIT                            ; Not same so exit NE.
20
        SUB     r0, r0, #1              ; Point to terminator.
        CMP     r0, r0                  ; Same so exit EQ.
        EXIT

skip_spaces
; In:   r0 -> string
; Out:  r0 -> first non-space in string
;       CC => control char found
;       CS => printable char found
;
        Entry
10
        LDRB    lr, [r0], #1
        CMP     lr, #" "
        BEQ     %BT10
        SUB     r0, r0, #1
        EXIT


; .............................................................................

SoundGain_Code  ALTENTRY

        LDR     r12, [r12]              ; Get workspace pointer

        MOV     r1, r0
        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned        ; complain if not a number or bad term
        BVS     Bad_Parameter_Error
        CMP     r2, #7                  ; if >7, complain about range
        BHI     SoundGain_Error
        LDR     r1, =SoundLevel0Base
        STRB    r2, [r1, #SoundGain]   ; else store out for compilation on next irq
        EXIT

SoundGain_Error
        ADR     r0, ErrorBlock_BadSoundGain
        B       ReturnError

        MakeInternatErrorBlock BadSoundGain,,M03

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module Data Structure and Constants
        OPT     OptPage

; DMA physical address pointer

; Prototype of part of Sound0Segment from Buff 0 .. Scheduler

ProtoS0S
        DCD     SoundDMABuffers                         ; Buff 0
        DCD     SoundDMABuffers + SoundDMABufferSize    ; Buff 1
; Config word, comprised of buffer length (16 bits), period (8 bits),
; log2nchan (3 bits), spare (1 bit), 16-bit flags (2 bits), spare (2 bits)
        DCW     SCBufferLen
        DCB     SCPeriod
        DCB     SCLogChannel                            ; Note: 16-bit flags are 0

        DCD     SoundSystemNIL                          ; channel handler
        DCB     &80, &80, &80, &80, &80, &80, &80, &80  ; Images (2 words worth)
        DCD     SoundSystemNIL                          ; scheduler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module SWI Interface
        OPT     OptPage

Sound_SWI_Code ROUT
        MRS     R10, CPSR
        Push    "R10,R14"
        MSR     CPSR_c, #I32_bit :OR: SVC32_mode
        BL      Original_SWI_Code
        Pull    "R10,R14"
        MSR     CPSR_c, R10             ; restore interrupts
        MOV     PC,R14                  ; 32-bit exit: NZ corrupted, CV passed back

Original_SWI_Code
        LDR     r10, =SoundLevel0Base
        CMP     r11, #(EndOfJumpTable-JumpTable)/4
        ADDCC   pc, pc, r11, LSL #2
        MOV     pc, lr

JumpTable
        B       Sound0Config            ; configuration
        B       Sound0Enable            ; enable control
        B       Sound0Stereo            ; stereo positioning
        B       Sound0Speaker           ; loudspeaker control
        B       Sound0Mode              ; mode control/status (16-bit/mu-law etc)
        B       Sound0LinearHandler     ; 16-bit sound generator interface
        B       Sound0SampleRate        ; new sample rate control interface
EndOfJumpTable

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0  = no. of channels (rounded up to power of two)
;       r1  = samples per buffer
;       r2  = uS per sample
;       r3  = Level1 Handler   (normally 0!)
;       r4  = Level2 Scheduler (normally 0!)
;       r10 = SoundLevel0Base
;       0 -> don't change!
;       IRQs disabled
;
; Constraints:
;              1 <= r0             <= 8
;             16 <= r1 * NChannels <= SoundDMASize
;  3 * NChannels <= r2 * NChannels <= 255

; Out   Return old r0,r1,r2,r3,r4

Sound0Config Entry

        Debug   swi,"Sound0Config",r0,r1,r2,r3,r4

        CMP     r0, #0                  ; r0 processing
        LDREQB  r0, [r10, #NChannels]
        ANDEQ   r0, r0, #3
        BEQ     %FT10

        SUB     r0, r0, #1              ; 1=>0, 2=>1 FOR LOGS!
        CMP     r0, #3
        MOVEQ   r0, #2                  ; 2,3 => 2
        MOVGT   r0, #3                  ; 4,5,6,7 => 3

10 ; MUST UPDATE STEREO POSITIONS

        Push    "r0-r3"
        LDRB    r3, [r10, #NChannels]
        STRB    r0, [r10, #NChannels]
        MOV     r2, #1
        MOV     r2, r2, LSL r0          ; number of channels

; for r0 = 1 to NChannels
        MOV     r0, #1
15      MOV     r1, #-128               ; read stereo pos
        SWI     XSound_Stereo           ; get previous
        SWI     XSound_Stereo           ; force set to new channels
        ADD     r0, r0, #1
        CMP     r0, r2
        BLE     %BT15                   ; loop for N active channels

        STRB    r3, [r10, #NChannels]
        Pull    "r0-r3"

        CMP     r1, #0                  ; r1 processing
        LDREQ   r1, [r10, #Config]      ; bottom 16 bits
        BIC     r1, r1, #&FF000000
        BIC     r1, r1, #&00FF0000
        BEQ     %FT20

        MOV     r1, r1, LSL r0          ; scale for NChannels of 8bit data
        CMP     r1, #SoundDMABufferSize ; can't be > buffer size
        MOVGT   r1, #SoundDMABufferSize
        MOV     r1, r1, LSR r0          ; back to per channel

        LDRB    lr, [r10, #Flags]

        MOV     lr, #SoundDMABufferSize ; limit no. samples to
        CMP     r1, lr, LSR #2          ; 4096/4=1024
        MOVGT   r1, lr, LSR #2          ; (largest form always 16bit stereo)
19
        MOV     lr, #32                 ; ensure enough 8bit/16bit samples for >= 32bytes of raw data
        CMP     r1, lr, LSR #2
        MOVLT   r1, lr, LSR #2

        Debug   swi,"per channel bufsz =",r1

20      CMP     r2, #0                  ; r2 processing
        LDREQB  r2, [r10, #Period]       ; if 0 then substitute current

        BL      WorkOutVIDCParams       ; but still go through update procedure

30      CMP     r3, #0                  ; r3 processing
        LDREQ   r3, [r10, #Level1Ptr]    ; old if 0

        CMP     r4, #0                  ; r4 processing
        LDREQ   r4, [r10, #Level2Ptr]    ; old if 0

40 ; merge into reg

        ORR     r11,  r1, r2, LSL #16
        ORR     r11, r11, r0, LSL #24

        LDR     r0, [r10, #Config]      ; Get return params
        AND     r1, r0, #&FC000000      ; extract current flags from nchan/flags byte
        ORR     r11, r11, r1            ; combine into new config value to store
        BIC     r1, r0, #&FF000000      ; mask out flags etc, leaving per-chan buflen
        BIC     r1, r1, #&00FF0000

        MOV     r2, r0, LSR #16
        AND     r2, r2, #&FF            ; current period value in r2

        ; produce channel count in r0, starting from config word in r0.
        MOV     r0, r0, LSR #24
        AND     r0, r0, #3
        ORR     r0, r0, #&01000000
        MOV     r0, r0, LSL r0          ; relies on LSL reg using only bits 7:0 of reg!
        MOV     r0, r0, LSR #24

        STR     r11, [r10, #Config]     ; store new buflen, period, log2nchan, flags

        LDR     r11, [r10, #Level1Ptr]  ; SSCB base
        STR     r3,  [r10, #Level1Ptr]  ; Install new Level1 handler
        MOV     r3,  r11                ; Return old

        LDR     r11, [r10, #Level2Ptr]  ; SSCB base
        STR     r4,  [r10, #Level2Ptr]  ; Install new Level2 handler
        MOV     r4,  r11                ; Return old

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       WorkOutVIDCParams - Compute SIB ASD value from
;       present configuration: no. of channels, sample period.
;
; in:   r0 = log2(no of channels)
;       r1 = samples per buffer
;       r2 = desired sample period in microseconds, if < 256,
;       r10 = SoundLevel0Base
;
; out:  r2 = effective per-channel sample rate used (in microseconds)
;       SIB_ASD_N holds ASD value to program into SIB
;

WorkOutVIDCParams ROUT
        Push    "r0,r1,r3,lr"

        Debug   swi,"WorkOutVIDCParams",r0,r1,r2

20

; 16-bit output hardware in place: must use one of the subset of sample rates
; supported in this configuration.  This is effectively only rates which can
; be used in 4-channel mode, i.e. with period a multiple of 4usec, and in fact
; below 40usec (25kHz), just 8-channel-capable (N*8usec) rates, to allow for 2x
; oversampling.  Scan the appropriate subset of the tabulated frequencies,
; looking for a suitable match.

        Debug   swi,"16bit output"

        Push    "r4,r5,r6,r7,r8"
        MOV     r5, #nsr
        ADR     r4, ftab-8              ; address 0th entry of main freq info table
        MOV     lr, #1                  ; start with entry 1 in map
22      ADD     r1, r4, lr, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period

        SUBS    r7, r3, r2              ; place (entry - freq) in r7
        BEQ     %FT26                   ; if =, go do it
        BPL     %FT24                   ; else if freq > entry, then look at next entry

                                        ; here, freq < entry, so test for closest match ie

                                        ;      (last_entry > freq < this_entry)

        CMP     lr, #1                  ; accept if at start of table
        BEQ     %FT26
        SUB     lr, lr, #1              ; otherwise back up to previous entry
        ADD     r1, r4, lr, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period

        SUB     r8, r2, r3              ; place (freq - entry) in r8

        CMP     r7, r8                  ; if r7 < r8 (they're negative) then we have best
        BLT     %FT26                   ; match so accept the current entry

        ADD     lr, lr, #1              ; otherwise go back up to next entry
        ADD     r1, r4, lr, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period
        B       %FT26                   ; and accept it


24      CMP     lr, r5                  ; if at end of list, accept this one
        BEQ     %FT26
        ADD     lr, lr, #1
        B       %BT22

26      LDRB    r2, [r1, #4]            ; pick up period to report back to user
        LDR     r0, [r1, #0]            ; get frequency value
        MOV     r3, r0, LSR #10         ; value for SRC register
        Pull    "r4,r5,r6,r7,r8"
        ; and drop into final code

; Store computed values and exit:
; lr is sample rate index
; r3 is SIB ASD to program, unadjusted, assuming no oversampling
; r2 is user-visible per-channel period,
; r0 is sample frequency in Hz/1024
98
        Debug   swi,"computed values are",r0,r1,r2,r3

        LDR     r1, [r10, #SoundRMA]
        STR     r0, [r1, #CurSRValue]   ; and frequency
        STR     lr, [r1, #CurSRIndex]   ; and index of frequency
        LDRB    r0, [r10, #Flags]
        LDR     r1, [sp, #4]            ; get back current/new samples per buffer
        BL      process_oversample      ; go set up to do oversampling iff we can
        STRB    r0, [r10, #Flags]       ; store back possibly updated flags
        STRH    r3, [r10, #SRC_N]       ; store for prog'ing under IRQ
        Pull    "r0,r1,r3,pc"           ; pop log2nchan, old r1, old r3, return PC

; process_oversample
; in:  r0 = flags value
;      r1 = samples per buffer
;      r2 = user-visible period
;      r3 = unadjusted SRC value, for non-oversampling case
;      r10 = SoundLevel0Base
; out: r0 = new flags value reflecting oversampling state
;      r1 unchanged
;      r2 unchanged
;      r3 = unadjusted SRC for normal or oversampling as required
process_oversample Entry "r1,r2"
        Debug   swi,"process_oversample, default off"
        BIC     r0, r0, #DoOversample   ; clear out o/s active flag, assuming not possible
        TST     r0, #OversampleFlag     ;   && auto oversample flag is set)
        EXIT    EQ                      ; else return - can't oversample
        CMP     r2, #MinOSPeriod        ; check sample period value against oversample limit
        EXIT    LT                      ; if too small (f too high), can't oversample
        ; check buffer size: may be too big to handle double-length (4KB max)
        CMP     r1, #SoundDMABufferSize/4 ; check against size limit at Fs*2
        EXIT    HI                      ; don't oversample if gets too big
        ; OK, set up for oversampling....
        Debug   swi,"oversampling on"
        MOV     r3, r3, LSL #1          ; multiply final frequency by 2 to generate Fs*2.
        ORR     r0, r0, #DoOversample   ; and inform IRQ level through flags
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = 0 -> leave (and return previous)
;            1 -> OFF
;          >=2 -> ON
;       r10 = SoundLevel0Base
;       IRQs disabled

; Out   r0 = previous enable state

Sound0Enable Entry "r1"

        LDR     r11, [r10, #Semaphore]
        TST     r11, #&80000000
        MOVEQ   r11, #2                 ; return ON
        MOVNE   r11, #1                 ; or OFF

        CMP     r0, #1
        BLT     %FT20                   ; [just return value]
        BGT     %FT10

; Turn OFF

        LDR     r14, [r10, #SoundRMA]
        LDR     r0, [r14, #SIC_base]    ; Address SIC controller
        MOV     r1, #0
        STR     r1, [r0, #SICR2]        ; stop replay

        TEQ     r11, #1
        BEQ     %FT04

; if on, power it down gradually
        MOV     r1, #&26
        MOV     r0, #&0100
        BL      WriteAC97
        MOV     r1, #&26
        MOV     r0, #&0300
        BL      WriteAC97
        MOV     r1, #&26
        MOV     r0, #&0700
        BL      WriteAC97
        MOV     r1, #&26
        ORR     r1, r1, #1:SHL:20
        MOV     r0, #&1700
        BL      WriteAC97

04      LDR     r14, [r10, #SoundRMA]

        LDR     r0, [r14, #SIC_base]    ; Address SIC controller
        MOV     r1, #2_0110000
        STR     r1, [r0, #SICR0]        ; disable SIC

        LDR     r0, [r14, #GPIO_base]   ; Address GPIO controller
        LDR     r1, [r0, #PDDR]
        BIC     r1, r1, #1              ; pull reset low
        STR     r1, [r0, #PDDR]

        LDR     r0, [r14, #DMACTRL_base]; Address DMA controller
        MOV     r1, #&80
        STR     r1, [r0, #DMA_TERM]     ; Terminate DMA
        LDR     r1, [r0, #DMA_IER]      ; Also disable IRQ from sound0 DMA channel
        BIC     r1, r1, #&80
        STR     r1, [r0, #DMA_IER]
05

        MOV     r14, #&80000000         ; Set semaphore
        STR     r14, [r10, #Semaphore]
        B       %FT20


10 ; Turn ON - turning on when already damages sample rate!

        CMP     r11, #2                 ; Exit if turning on when already on
        BEQ     %FT20                   ; This is the proper place to fix
                                        ; the bug, not at the *Audio level!

15      MOV     r14, #0                 ; Clear semaphore. Common ep
        STR     r14, [r10, #Semaphore]

        LDR     r14, [r10, #SoundRMA]
        LDR     r12, [r14, #INT_base]
        MOV     r1, #IRQ_DMA
        STR     r1, [r12, #IRQLEnableClear] ; Disable IRQ from DMA controller

        ; *** THIS MAY TAKE A LONG TIME - TOO LONG FOR IRQs DISABLED.
        MSR     CPSR_c, #SVC32_mode
        LDR     r12, [r14, #SIC_base]
        LDR     r1, [r14, #GPIO_base]
;        MOV     r0, #2_0110000          ; Use SPI pins, reset
;        STR     r0, [r12, #SICR0]
        MOV     r0, #2_0100000          ; clear reset
        STR     r0, [r12, #SICR0]
        LDR     r0, [r1, #PDDDR]        ; bring AC97 codec out of reset
        ORR     r0, r0, #1              ; using GPIO lines
        STR     r0, [r1, #PDDDR]
        LDR     r0, [r1, #PDDR]
        ORR     r0, r0, #1
        STR     r0, [r1, #PDDR]
        MOV     r0, #2_0100001          ; enable interface
        STR     r0, [r12, #SICR0]
        MOV     r0, #1:SHL:8
        STR     r0, [r12, #SICR2]       ; warm reset
        ; HACK - software timing loop
        MOV     r0, #50
18      SUBS    r0, r0, #1              ; 50 x 4 cycles = 2.6us - plenty of room for a while
        BNE     %B18
        STR     r0, [r12, #SICR2]       ; end warm reset
19      LDR     r0, [r12, #SICR2]
        TST     r0, #1:SHL:8
        BNE     %B19
        MOV     r0, #2_00010            ; enable replay (rev AA workaround)
        STR     r0, [r12, #SICR2]
16      LDR     r0, [r12, #SIRSR]
        TST     r0, #1:SHL:20           ; wait for codec ready
        BEQ     %B16
;        MOV     r0, #2_00000            ; disable replay (rev AA workaround)
;        STR     r0, [r12, #SICR2]
17      MOV     r1, #&26
        BL      ReadAC97
        AND     r0, r0, #2_1111         ; wait for four green lights
        TEQ     r0, #2_1111             ; (just like Concorde, innit?)
        BNE     %B17
;        MOV     r1, #&00
;        MOV     r0, #0
;        BL      WriteAC97               ; reset registers
        MOV     r1, #&2A
        MOV     r0, #&0001
        BL      WriteAC97               ; enable variable rate
        ; Set SIB sample rate now, not later
        LDRH    r0, [r10, #SRC_N]       ; pick up computed value
        STRH    r0, [r10, #SRC_H]       ; store in next pipeline slot also
        STRH    r0, [r10, #SRC_C]       ; and record as current value
        MOV     r1, #&2C
        BL      WriteAC97               ; sample rate programmed
        MOV     r1, #&02
        MOV     r0, #&0000
        BL      WriteAC97               ; master volume = 0dB
        MOV     r1, #&04
        MOV     r0, #&0000
        BL      WriteAC97               ; headphone volume = 0dB
        MOV     r1, #&18
        MOV     r0, #&0800
        ORR     r0, r0, #&0008
        BL      WriteAC97               ; PCM out volume = 0dB

        MSR     CPSR_c, #I32_bit + SVC32_mode

        MOV     r0, #2_00010            ; enable replay
        STR     r0, [r12, #SICR2]

        LDR     r14, [r10, #SoundRMA]
        LDR     r12, [r14, #DMACTRL_base]
        LDR     r0, [r10, #Phys0]       ; set current pointer = buffer base
        STR     r0, [r12, #DMA_C7NBA]
        LDR     r0, [r12, #DMA_C7NTC]   ; pick up previous end mask value (already programmed)
        STR     r0, [r12, #DMA_C7NTC]   ; re-write, to start DMA

        LDR     r0, =SIC_BASE_PHYS + SIADR
        STR     r0, [r12, #DMA_C7PA]    ; set peripheral address

        LDR     r0, =2_011011           ; 32-bit from RAM, burst, auto-reload, don't stop
        ORR     r0, r0, #&300           ; 3 cycle idle gap
        STR     r0, [r12, #DMA_C7CTL]

        LDR     r0, [r12, #DMA_RCM2]
        BIC     r0, r0, #&FF000000
        ORR     r0, r0, #&18000000      ; map channel 7 to SIC audio transmit
        STR     r0, [r12, #DMA_RCM2]

        MOV     r0, #&80
        STR     r0, [r12, #DMA_UR]      ; clear underrun flag
        STR     r0, [r12, #DMA_ICR]     ; clear interrupts
        STR     r0, [r12, #DMA_EN]      ; enable channel 7
        LDR     r0, [r12, #DMA_IER]     ; enable interrupts from channel 7
        ORR     r0, r0, #&80
        STR     r0, [r12, #DMA_IER]

        LDR     r12, [r14, #INT_base]
        MOV     r1, #IRQ_DMA
        STR     r1, [r12, #IRQLEnableSet] ; Enable IRQ from DMA controller

20      MOV     r0, r11                 ; Return previous enable state
        EXIT                            ; Restores ints to caller state, maybe
                                        ; get IRQ'ed here too.

; .............................................................................
; Called at RESET time
; in: r10 = SoundLevel0Base

Sound0Reenable ALTENTRY

        LDR     r11, [r10, #Semaphore]
        TST     r11, #&80000000
        EXIT    NE                      ; was OFF, stays OFF

        B       %BT15                   ; Turn it on again

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = 0 -> leave (and return previous)
;            1 -> OFF
;          >=2 -> ON
;       r10 = SoundLevel0Base
;       IRQs disabled

; Out   r0 = previous speaker state

Sound0Speaker ROUT

        MOV     r0, #2                  ; if no speaker control hardware, report ON
        MOV     pc, lr                  ; no need to preserve flags (we have a wrapper)

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0  = channel number (1-8)
;       r1  = -127 for left, 0 centre, 127 right (-128 DON'T CHANGE)
;       r10 = SoundLevel0Base
;       IRQs disabled

; Attempts to be slightly clever...
; programs at interleave factor from r0 upwards...
; note pipeline delay on NChannels...!

; Out   r0 preserved
;       r1 is stereo position allocated (-128 for none/invalid)
;       -128 indicates invalid channel

Sound0Stereo Entry "r0, r2"

        SUB     r0, r0, #1              ; 1..8 -> 0..7
        CMP     r0, #SoundPhysChannels
        MOVHS   r1, #-128
        EXIT    HS

        ADD     r2, r1, #&80            ; add new offset
        LDRB    r14, [r10, #NChannels]
        AND     r14, r14, #3            ; get rid of extra flag bits
        MOV     r11, #1
        MOV     r14, r11, LSL r14       ; convert log

        ADD     r12, r10, #Images
        LDRB    r1, [r12, r0]           ; current pos
        SUB     r1, r1, #&80            ; map back to -127..+127

        CMP     r2, #0
        CMPNE   r2, #&100               ; force range
        EXIT    HS

        ADD     r11, r12, #8            ; end
        ADD     r12, r12, r0            ; base channel
05      STRB    r2, [r12], r14          ; store new pos
        CMP     r12, r11
        BLT     %BT05

        ADD     r0, r10, #Images        ; address full-size image set
        BL      ConvImages              ; produce compacted form...
        STR     r0, [r10, #ImagesC_N]   ; for programming on appropriate IRQ
        EXIT                            ; go back to caller


; Sound0Mode - implements Sound_Mode SWI
;
; In:
;
;   R0: function code
;     = 0: read current mode, returning information in r0/r1.  This code must
;          be used first, to determine the availability of other functions.
;     = 1: set/clear oversampling mode, returning previous state (0 or 1)
;          R1 = 0: disable linear 2x oversampling
;          R1 <> 0: enable linear 2x oversampling
;     = 2: (NOT YET IMPLEMENTED) set external sound clock handler
;          function (for format/status value 3)
;          R1 = external sound clock handler address, or 0 to cancel
;     = 3: set/clear mono flag, returning previous state (0 or 1)
;	   R1 = 0: stereo mode
;	   R1 <> 0: mono mode (convert stereo to mono for output)
;     other function code values not defined
;
;   R10 = SoundLevel0Base
;   IRQs disabled
;
; Out:
;  For function code 0:
;       R0      = 0: mu-law sound system only; SWIs Sound_LinearHandler and
;                    Sound_SampleRate, and all other functions of Sound_Mode, are
;                    not supported.  Contents of r1 are unchanged.
;       R0      = 1: 16-bit capable sound system: SWIs Sound_LinearHandler and
;                    Sound_SampleRate, and full Sound_Mode functionality are all
;                    available.
;
;       R1[3:0]: sound output format and clock control status (from CMOS RAM)
;               = 1: 16-bit linear output, 44k1, 22k05, 11k025 and selected original rates
;               = 2: 16-bit linear output, internal clock, selected original rates only
;               = 3: 16-bit linear output, external master clock source, custom rates only
;               = 4...15: reserved values
;       R1[4]: oversampling control
;               = 0: automatic linear 2x oversampling disabled
;               = 1: automatic linear 2x oversampling enabled
;       R1[5]   = 0: stereo output
;		= 1: mono conversion on output
;       R1[31:5]: reserved for expansion
;
; For all rates <= 25kHz, if auto-oversampling is on, the output data stream
; will be oversampled by 2x, by simple linear interpolation.
;
Sound0Mode      Entry   "r2"
        LDRB    r2, [r10, #Flags]

        CMP     r0, #0
        BNE     %FT10
; Function code 0: read mode information
        MOV     r0, #1                  ; new system, 16-bit
        MOV     r1, #2                  ; internal clock only
        TST     r2, #OversampleFlag     ; check for oversampling
        ORRNE   r1, r1, #1 :SHL: 4      ; set flag if so
        TST	r2, #DoMono		; check for mono mode
        ORRNE	r1, r1, #1 :SHL: 5	; set flag if enabled
        EXIT

10      CMP     r0, #1
        BNE     %FT20
; Function code 1: enable/disable automatic oversampling (allows overriding CMOS value)
        LDR     r0, [r10, #Config]
        MOV     r2, r0, LSR #24
        MOV     lr, r2                  ; preserve original value
        BIC     r2, r2, #OversampleFlag ; clear o/s bit, but NOT DoOversample for now
        CMP     r1, #0                  ; check requested state
        ORRNE   r2, r2, #OversampleFlag ; set bit if required
        ANDS    r1, lr, #OversampleFlag ; get old state of flag into r1 (wrong bit pos)
        MOVNE   r1, #1                  ; if not zero, set 1, else 0 already there...
        ; Need to fix up for oversampling if now enabled.
        Push    "r1,r3"
        MOV     r1, r0, LSL #16         ; r1 = samples per buffer
        MOV     r1, r1, LSR #16
        MOV     r0, r2                  ; r0 = new flags
        LDRB    r2, [r10, #Period]      ; and user-visible sample period into r2
        LDRB    r3, [r10, #SRC_N]       ; pick up current SRC into r3
        TST     lr, #DoOversample       ; check whether O/S was in use before
        MOVNE   r3, r3, LSR #1          ; halve the frequency if so, to give non-O/S period
        BL      process_oversample      ; determine whether to use o/s
        STRB    r0, [r10, #Flags]       ; store final flags
        STRH    r3, [r10, #SRC_N]       ; and store SRC
        Pull    "r1,r3"
        MOV     r0, #1
        EXIT

20      CMP     r0, #2
        BNE     %FT30
; FUNCTION CODE 2: NOT YET IMPLEMENTED!
	B	%FT99
30	CMP	r0, #3
	BNE	%FT40
; Function code 3: enable/disable mono-isation (allows overriding CMOS value)
        LDRB    r2, [r10, #Flags]       ; get flags byte
        MOV     lr, r2                  ; preserve original value
        CMP     r1, #0                  ; check requested state
        ORRNE   r2, r2, #DoMono         ; set bit if enabling mono conversion
        BICEQ   r2, r2, #DoMono         ; or clear bit if disabling it
        ANDS    r1, lr, #DoMono         ; get old state of flag into r1 (wrong bit pos)
        MOVNE   r1, #1                  ; if not zero, set 1, else 0 already there...
        STRB    r2, [r10, #Flags]       ; store out new flag value
        EXIT
40
99
        EXIT


; Sound0LinearHandler: implements Sound_LinearHandler SWI.
;
; In: (r0-r2 from user SWI)
;  r0 is function code:
;    r0 = 0: return current handler as {routine, param} pair in r1, r2
;         no side effects, all regs except r1, r2 preserved
;         a null handler is recorded as a routine address of 0, param of -1
;    r0 = 1: install new handler
;         r1 =  0: set null handler (initial, default state), r2 is ignored
;         r1 != 0: set r1 as routine to call, r2 as parameter value to pass
;                  to it in r0, with following call rules:
;               r0 = value specified on installation of routine (r2 here)
;               r1 = base of word-aligned buffer, to fill with 16-bit stereo
;                    data, stored as pairs of signed (2's complement) 16-bit
;                    values; each word has bits 31:16 left channel data, bits
;                    15:0 right channel data.
;               r2 = end of buffer (address of first word beyond buffer)
;               r3 = flag for initial buffer contents:
;                    0 => data in buffer is invalid and MUST be overwritten
;                    1 => data has been converted from N-channel mu-law sound
;                         system and may be either overwritten or (preferably)
;                         mixed with new data produced by routine.
;                    2 => data in buffer is all 0: if routine would generate
;                         silent output, it may simply return.
;               r4 = sample frequency at which data will be played, in Hz/1024
;                    (e.g. for 20kHz, r4 would be 20000*1024 = 20480000).
;    else (r0 = any other value): ignored (do nothing, not even error...)
;
;  r1 = as determined by value in r0
;  r2 = as determined by value in r0
;
;  r10 = SoundLevel0Base (set up locally)
;
;  IRQs are disabled
;
; Out:
;  r0 preserved
;  r1 = previous/current routine address
;  r2 = previous/current value to pass to routine
;
Sound0LinearHandler Entry "r3,r4,r5"
        LDR     r3, [r10, #SoundRMA]
        LDR     r4, [r3, #Lin16Gen]
        LDR     r5, [r3, #Lin16GenR0]
        CMP     r0, #1
        BHI     %FT10
        STREQ   r1, [r3, #Lin16Gen]     ; if r0 = 1, store new value for routine
        STREQ   r2, [r3, #Lin16GenR0]   ;            and new value for r0 param to routine
        MOVS    r1, r4                  ; set previous routine address in r1
        MOVNE   r2, r5                  ; if not null, put param to pass into r2
        MVNEQ   r2, #0                  ; else set -1 into r2
10
        EXIT                            ; and go home


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Sound0SampleRate: implements Sound_SampleRate SWI.  This SWI is only
; useable when SoundDevice is configured non-0, i.e. when there is 16-bit sound output
; hardware.  Otherwise it returns 0 in r1 and r2 for all calls.
;
; In: (r0,r1 from user SWI)
;   r0 is function code:
;      0: return in r1 the total number of available sample rates, NSR.
;         Available sample rates are indexed by numbers in the range 1..NSR,
;         and increase with increasing index number.  R2 is preserved.
;      1: return in r1 the index of the current sample rate, and in r2
;         the current sample rate, measured in units of 1/1024 Hz, e.g.
;         20kHz would be 20480000;
;      2: return in r2, as value measured in 1/1024ths of Hz, the sample
;         rate defined by index given in r1 (in range 1..NSR).
;      3: select new sample rate via index in r1, in range 1..NSR; return
;         index and value of previous rate in r1 and r2 respectively.
;
;   r1 = as determined by value in r0.
;   r2 = as determined by value in r0.
;
;  r10 = SoundLevel0Base (set up locally, not from SWI)
;
;  IRQs disabled
;
; Out:
;   r0 preserved
;   r1 = index of previous/current rate, or NSR;
;   r2 = previous/current/rate, measured in 1/1024ths of Hz, or preserved (r0 = 0)
;
Sound0SampleRate Entry "r3,r4"
        CMP     r0, #0                  ; check function code
        BNE     %FT10

; Function code 0: read NSR (as configured at module init or via clock handler)
        MOV     r1, #nsr
        EXIT

10      CMP     r0, #1
        BNE     %FT20
; Function code 1: read current sample rate index and sample rate
        LDR     r1, [r10, #SoundRMA]
        LDR     r2, [r1, #CurSRValue]
        LDR     r1, [r1, #CurSRIndex]
        EXIT

20      CMP     r0, #2
        BNE     %FT30
; Function code 2: return in r2 the sample rate for specified index in r1
        BL      SR_maptab               ; go get address of freq table entry
        CMP     r2, #0                  ; check for error
        BEQ     SR_badpar               ; handle error if any
        LDR     r2, [r2, #0]            ; pick up frequency (1st word in entry)
        EXIT                            ; all done!

30      CMP     r0, #3
        BNE     %FT40
; Function code 3: set sample rate as specified by index in r1
        BL      SR_maptab               ; get address of relevant main table entry
        MOVS    r4, r2                  ; move pointer, check for error (=0)
        BEQ     SR_badpar               ; handle error if any
        Push    "r1"                    ; save new index
        LDRB    r2, [r4, #4]            ; get nominal period from table entry
        STRB    r2, [r10, #Period]      ; store away for Sound_Configure calls
        LDRB    r3, [r4, #5]            ; get ASD w/o oversampling
        LDR     r1, [r10, #Config]
        MOV     r0, r1, LSR #24         ; r0 = current flags
        MOV     r1, r1, LSL #16
        MOV     r1, r1, LSR #16         ; r1 = samples per buffer
        BL      process_oversample      ; work out whether o/s needed, fix ASD if so
        STRB    r3, [r10, #SRC_N]       ; store SRC for later programming
        STRB    r0, [r10, #Flags]       ; and update flags
        Pull    "lr"                    ; recover new index, into lr this time
        LDR     r3, [r10, #SoundRMA]    ; address 16-bit system variables
        LDR     r1, [r3, #CurSRIndex]   ; get previous samplerate index for return to user
        LDR     r2, [r3, #CurSRValue]   ; get previous samplerate value for return to user
        STR     lr, [r3, #CurSRIndex]   ; save off new Sample Rate index
        LDR     lr, [r4, #0]            ; pick up frequency value from table entry
        STR     lr, [r3, #CurSRValue]   ; and save that too
        MOV     r0, #3
        EXIT                            ; all done

40                                      ; function code not 0..3: complain
SR_badpar
        ADR     r0, badparblock
        MOV     r1, #0
        MOV     r2, #0
        SWI     XMessageTrans_ErrorLookup
        PullEnv
        MOV     pc, lr                  ; SWI will always set V

badparblock
        DCD     &1F1                    ; ???
        DCB     "BadParm",0
        ALIGN

; SR_maptab: subroutine to convert r1 SR index to address of relevant
; entry in ftab, in r2.  Assumes r3 contains configured sound mode (1..3).
; Corrupts r3 and r4; r1 is always preserved; r2 is set to 0 on error.
SR_maptab
        SUB     r1, r1, #1              ; reduce index to 0-based range
        CMP     r1, #nsr                ; check against limit (unsigned)
        ADD     r1, r1, #1              ; put index back again always
        MOVHS   r2, #0                  ; if out of range, mark error
        MOVHS   pc, lr                  ; and return
        ADRL    r3, ftab-8              ; address main table 0th entry
        ADD     r2, r3, r1, LSL #3      ; index into main table (8 bytes each)
        MOV     pc, lr                  ; return



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Initialise_Module Entry "r7, r8, r10, r11"

        LDR     r2, [r12]
        TEQ     r2, #0
        BNE     %FT00

        MOV     r3, #WorkSpaceSize
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        EXIT    VS

        STR     r2, [r12]

00      LDR     r10, =SoundLevel0Base
        STR     r2, [r10, #SoundRMA]    ; keep separate record of RMA area base
        MOV     r0, #0
        STR     r0, [r2, #MessageFile_Open]
        STR     r0, [r2, #Lin16Gen]     ; No 16-bit handler
        STR     r0, [r2, #Lin16GenR0]
        STR     r0, [r2, #SavedSample]  ; 0 previous value for interpolation
        STR     r0, [r2, #CurSRIndex]   ;
        STR     r0, [r2, #CurSRValue]   ;
        MOV     r4, r2
        MOV     r0, #13
        LDR     r1, =DMACTRL_BASE_PHYS
        MOV     r2, #&1000
        SWI     XOS_Memory
        LDRVS   r3, =DMACTRL_BASE
        STR     r3, [r4, #DMACTRL_base]
        MOV     r0, #13
        LDR     r1, =SIC_BASE_PHYS
        MOV     r2, #&1000
        SWI     XOS_Memory
        LDRVS   r3, =SIC_BASE
        STR     r3, [r4, #SIC_base]
        MOV     r0, #13
        LDR     r1, =GPIO_BASE_PHYS
        MOV     r2, #&1000
        SWI     XOS_Memory
        LDRVS   r3, =GPIO_BASE
        STR     r3, [r4, #GPIO_base]
        MOV     r0, #13
        LDR     r1, =INT_BASE_PHYS
        MOV     r2, #&1000
        SWI     XOS_Memory
        LDRVS   r3, =INT_BASE
        STR     r3, [r4, #INT_base]
        BL      InitResetCommon
        EXIT    VS                      ; [going nowhere if this fails]

; Get physical address of sound buffer 0.  This is fixed at a single
; value on both MEMC1 and MEMC2 systems, but variable (obtained via new
; SWI) on IOMD systems.  The logical address is fixed (at &01F06000) on
; all systems.

        LDR     r2, =SoundDMABuffers    ; fixed logical address of 2 soundbuffers
        SUB     sp, sp, #12             ; get temp space for a single-entry Page Block
        STR     r2, [sp, #1*4]          ; write addr into l.a. slot of page block
        MOV     r1, sp                  ; point at Page Block as SWI arg
        MOV     r2, #1                  ; 1 entry to update
        MOV     r0, #&2200              ; convert log address to phys address
        SWI     XOS_Memory              ; go do the conversion
        LDR     r1, [sp, #2*4]          ; pick up physical address into R1
        ADD     sp, sp, #12             ; release temp space
        EXIT    VS                      ; ought never to fail!
        MOV     r0, #0                  ; Semaphore ON (so reenable wakens it)
        ADRL    r2, ProtoS0S            ; address sound0segment prototype
        LDMIA   r2, {r2,r3,r4,r5,r6,r7,r8} ; load it up (from Buff0 onwards)
        STMIA   r10, {r0-r8}            ; Set up Sound0Segment, first 9 words

        ADD     r0, r10, #Images        ; address user-level image positions
        BL      ConvImages              ; convert to compact version for prog'ing
        STR     r0, [r10, #ImagesC_N]   ; compacted form, into top of pipeline
        STR     r0, [r10, #ImagesC_H]   ; and for next buffer

        ; go fetch 16-bit sound control info from CMOS
        MOV     r0, #161                ; CMOS read OSBYTE
        MOV     r1, #PrintSoundCMOS     ; get extended (VIDC20) sound bits
        SWI     XOS_Byte                ; "won't" fail

; R2 is byte from CMOS
; bit 7 is quality bit (do interpolation to maximise quality)
; bit 6:5  form 16-bit sound control value. From Hdr:CMOS --
;
; Bit  5,6 = 16-Bit sound control, on VIDC20 machines including Risc PC.
;              0: no 16-bit sound output, use standard mu-law (default)
;              1: DAC clock is slave: 11.2896MHz ext clock: standard VIDC20 rates or
;                  44.1 KHz * 4/(4..45) can be used (as on ESP sound card).
;              2: DAC clock is slave: no ext clock: standard VIDC20 rates only
;              3: DAC clock is master: ext clock must be used for 16-bit sound
;                 (suitable sound clock driver must be installed)
        MOV     r2, r2, LSR #5-Lin16Shift ; shift right to bit position in Flags byte
        AND     r2, r2, #Lin16Bits+OversampleFlag ; extract the three applicable bits
        ORR     r4, r4, r2, LSL #24     ; set new flag bits in place
        STR     r4, [r10, #Config]      ; and store config, with them in

20      MOV     r0, r4, LSR #24         ; get log2nchan + flags byte
        AND     r0, r0, #3              ; get log2nchan alone into r0
        LDR     r1, [r10, #SoundRMA]
        ADD     r1, r1, #LinConvCode    ; get address to put code
        MOV     r2, #SCSoundGain        ; set up default soundgain value
        STRB    r2, [r10, #SoundGain]
        STRB    r2, [r10, #SoundGain_C]
        LDR     r2, [r10, #ImagesC_H]   ; address stereo position set
        STR     r2, [r10, #ImagesC_C]   ; mark as current set
        STRB    r0, [r10, #Log2nchan_C] ; do same for log2nchan
        ORR     r2, r2, #SCSoundGain :SHL: 24 ; combine default soundgain into r2
        BL      compile                 ; go call compiler to set it all up
        LDR     r1, [r10, #Phys0]       ; reload physical buffer address to r1
30
        MOV     r6, r4, LSL #16         ; build 16-bit Length (in sample times)
        MOV     r6, r6, LSR #16
        MOV     r7, r4, LSR #24         ; build LogChannel count in r7
        AND     r7, r7, #3
        MOV     r6, r6, LSL r7          ; build DAG End (i.e. length in bytes) in r6

        ; Initialise DMA pointers

        LDR     r0, [r10, #SoundRMA]
        LDR     r0, [r0, #DMACTRL_base]
        STR     r1, [r0, #DMA_C7NBA]
        STR     r6, [r0, #DMA_C7NTC]

        MOV     r0, r7                  ; r0:= log2(channels)
        MOV     r1, r4, LSL #16         ; r1 = samples per buffer
        MOV     r1, r1, LSR #16
        MOV     r2, r4, LSR #16         ; 8-bit period
        AND     r2, r2, #&FF
        BL      WorkOutVIDCParams

 [ {TRUE}
 |
        ; Set SIB sample rate now, not later
        LDRH    r4, [r10, #SRC_N]       ; pick up computed value
        STRH    r4, [r10, #SRC_H]       ; store in next pipeline slot also

        MOV     r1, #&2C
        MOV     r0, r4
        BL      WriteAC97               ; set rate in the codec

        STRH    r4, [r10, #SRC_C]       ; and record as current value
 ]

        MSR     CPSR_c, #I32_bit+SVC32_mode ; IRQ off please
        BL      Sound0Reenable          ; Turn on system
        MSR     CPSR_c, #SVC32_mode     ; Reenabled IRQs

        MOV     r0, #Service_SoundLevel0Alive
        MOV     r1, #Service_Sound
        SWI     XOS_ServiceCall
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;Ursula format
;
       ASSERT   Service_Reset      < Service_ModeChange
       ASSERT   Service_ModeChange < Service_Portable
;
UServTab
        DCD     0
        DCD     UService - Module_Base
        DCD     Service_Reset
        DCD     0
        DCD     UServTab - Module_Base
Intercept_Services ROUT
        MOV     r0,r0
        TEQ     r1,#Service_Reset
        MOVNE   PC,LR
UService
        CMP     r1, #Service_Reset
        MOVNE   pc, lr

        Entry   "r0-r4, r10, r11"

; Fix MED-02859 - only call InitResetCommon if it's a soft reset.
; Otherwise we'll try to put ourselves on twice, and there's a window
; during which Sound DMA is enabled and the kernel has temporarily removed
; all device handlers.

        MOV     r0, #&FD
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
        TEQ     r1, #0
        EXIT    NE

        LDR     r10, =SoundLevel0Base
        BL      InitResetCommon
        EXIT    VS                      ; Can't raise error from service

        MRS     r1, CPSR
        MSR     CPSR_c, #I32_bit :OR: SVC32_mode ; IRQ off please
        BL      Sound0Reenable          ; Turn on system/keep it off
        MSR     CPSR_c, r1              ; Restore caller's IRQ state
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r4 trashable <---- NB.
;       r10 = SoundLevel0Base

; Out   VC: ok
;       VS: r0 -> error block

InitResetCommon Entry

        LDR     r4, =SoundDMABuffers    ; Clear out entire DMA buffers
        ADD     r14, r4, #SoundDMABufferSize * 2
        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
50      STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        CMP     r4, r14
        BLT     %BT50

; Claim vector to field the interrupts on

        ADR     r1, Module_VectorCode
        MOV     r2, r10                 ; R12 value to be passed in

        MOV     r0, #L7200_DMA_DevNo
        SWI     XOS_ClaimDeviceVector
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable, r10 = fatality indication

Finalise_Module Entry "r10, r11"

        LDR     r12, [r12]              ; Get wp for messagefile info
        LDR     r0, [r12, #MessageFile_Open]
        CMP     r0, #0
        ADDNE   r0, r12, #MessageFile_Block
        SWINE   XMessageTrans_CloseFile

        LDR     r10, =SoundLevel0Base

        MOV     r0, #Service_SoundLevel0Dying
        MOV     r1, #Service_Sound
        SWI     XOS_ServiceCall         ; Can't stop me!

        PHPSEI  r14, r0
        Push    "r14"
        MOV     r0, #1                  ; Turn off system - can't SWI anymore
        BL      Sound0Enable
        Pull    "r14"
        PLP     r14                     ; Reenable IRQs

; release the irq handler

        ADR     r1, Module_VectorCode
        MOV     r2, r10

        MOV     r0, #L7200_DMA_DevNo
        SWI     XOS_ReleaseDeviceVector                 ; release device vector
        CLRV
        EXIT                            ; Don't refuse to die



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       Divide - r2 := r0 DIV r1  -
;
; This is needed when base sound clock rate varies (with video clock), and
; when computing period from frequency or vice versa.
;

Divide  Entry
        DivRem  r2, r0, r1, r14
        EXIT
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module Interrupt Service Routine
        OPT     OptPage

Module_VectorCode ROUT

        Push    "r11, lr"               ; Never entered except when SIRQ
                                        ; Below code expects stacked return pc

        MOV     r0, #&80
        STR     r0, [r2, #DMA_ICR]      ; clear the interrupt

; IFF semaphore is zero then r13 = system IRQ stack pointer
; ELSE re-entrant SIRQ indicating buffer filling STILL IN PROGRESS!
; r11     work register
; r12     SoundLevel0Base
; r13     IRQ stack (must be FD)
; r14     work register

        MOV     r14, wp                 ; =SoundLevel0Base
        LDR     r12, [r14, #Semaphore]  ; semaphore
        CMP     r12, #0
        BEQ     %FT40                   ; do Level0Swap

; Level0Overrun - can't break general IRQ thread; other handlers reenable IRQ.

        Push    "r0-r10"

; Program MEMC such that next buffer = this buffer

        LDMIB   r14, {r5-r11}           ; Sound0Segment params, skip semaphore
;;;        STR     r6, [r14, #Buff1]       ; DON'T Swap for next time
;;;        STR     r7, [r14, #Buff0]
        MOV     r12, r7                 ; r7 = old start
                                        ; r6 = new start
        SUBS    r0, r7, r6              ; buffer offset
        ADDPL   r5, r5, r0              ; if r7 > r6, then r5 += diff!
        MOV     r6, r8                  ; set r6 -ve for any updates

        MOV     r10, r6, LSL #16        ; 16-bit buffer length in r10
        MOV     r10, r10, LSR #16
        MOV     r11, r6, LSR #24        ; 3-bit log channel count in r11
        TST     r11, #DoOversample      ; 16-bit: check for oversampling
        MOVEQ   r11, #2                 ; 4 bytes/sample if no o/s
        MOVNE   r11, #3                 ; but 8 bytes/sample if o/s
01
        AND     r11, r11, #3
        MOV     r4, r10, LSL r11        ; compute physical buffer length in r4
        BIC     r4, r4, #&F             ; must be multiple of 16
        MOV     r10, r4, LSR r11        ; may need to adjust logical buffer length
        MOV     r0, r4                  ; compute DMA end

        LDR     r2, [r10, #SoundRMA]
        LDR     r2, [r2, #DMACTRL_base]

        STR     r5, [r2, #DMA_C7NBA]
        STR     r0, [r2, #DMA_C7NTC]

        LDR     r4, [r2, #DMA_UR]       ; check for still underrun
        TST     r4, #&80
        STRNE   r5, [r2, #DMA_C7NBA]
        STRNE   r0, [r2, #DMA_C7NTC]

10
        Pull    "r0-r10, r11, pc"


; Level0Swap

40      STR     sp_irq, [r14, #Semaphore] ; save IRQ stack^ in semaphore
        Push    "r0-r10"


; Level0 Go

 ASSERT Phys0     = 4  ; r5
 ASSERT Buff0     = 8  ; r6
 ASSERT Buff1     = 12 ; r7
 ASSERT Config    = 16 ; r8
 ASSERT Level1Ptr = 20 ; r9
 ASSERT Images    = 24 ; r10, r11 NB. Two words
50      LDMIB   r14, {r5-r9}            ; Sound0Segment params, skip semaphore
        STR     r6, [r14, #Buff1]       ; Swap for next time
        STR     r7, [r14, #Buff0]
        MOV     r12, r7                 ; r7 = old start
                                        ; r6 = new start
        SUBS    r0, r7, r6              ; buffer offset
        ADDPL   r5, r5, r0              ; if r7 > r6, then r5 += diff!
        MOV     r6, r8                  ; get config (incl. flags) in r6
        MOV     r0, r6, LSR #24         ; get configured log2nchan & flags
        AND     r0, r0, #3              ; mask out just current req'd log2nchan
        LDRB    r1, [r14, #Log2nchan_C] ; pick up current value in use
        CMP     r0, r1                  ; if different, mark update for Level1
        ORRNE   r6, r6, #1 :SHL: 31     ; by setting sign bit in r6
        STRNEB  r0, [r14, #Log2nchan_C] ; and also update log2nchan

        LDRB    r1, [r14, #SoundGain_C] ; get current value of mu-law->linear conv gain
        LDRB    r2, [r14, #SoundGain]   ; get last-set value
        CMP     r2, r1                  ; check if different, and if so mark fact...
        ORRNE   r6, r6, #1 :SHL: 31     ; ..by setting sign bit in r6
        STRNEB  r2, [r14, #SoundGain_C] ; and also update recorded value

        ; Handle 16-bit mode conversion routine re-compile if needed.  NB we
        ; change the compiled code directly on THIS interrupt, rather than
        ; with a one-buffer delay as is applied when updating the hardware.
        ; This is because the stereo positioning is already dealt with in the
        ; data put into the buffer, rather than when the buffer is read out
        ; (after next interrupt) by the hardware.
        ; Get currently required log2nchan value + flags

        ; Check whether any stereo position value has changed.
        ; Shuffle ImagesC FIFO first, since there is no buffer delay for
        ; software stereo
        LDR     r2, [r14, #ImagesC_N]   ; get wanted value of ImagesC
        STR     r2, [r14, #ImagesC_H]   ; (force skipping of 1-buffer delay)
        LDR     r1, [r14, #ImagesC_C]   ; check current value of ImagesC
        CMP     r2, r1                  ; check for being the same
        BNE     %FT55                   ; go recompile if different

        ; No change in stereo, but check whether number of active channels has
        ; changed, => recompile needed.  This was tested above, and marked in bit
        ; 31 of r6, so it's easy to re-check.  This bit may alternatively/also
        ; indicate change of soundgain value, with same consequence.
        TST     r6, #1 :SHL: 31
        BEQ     %FT65                   ; no re-compilation needed if bit 31 clear

55      ; Compile for updated configuration/stereo position/soundgain value.
        STR     r2, [r14, #ImagesC_C]   ; record req'd ImagesC value as current
        LDRB    r1, [r14, #SoundGain_C] ; pick up newest soundgain value
        ORR     r2, r2, r1, LSL #24     ; and combine into r2
        LDR     r1, [r14, #SoundRMA]    ; address code buffer in SoundRMA workspace
        ADD     r1, r1, #LinConvCode    ; ...
        BL      compile                 ; go compile it (R0 = log2nchan)
        LDR     r14, =SoundLevel0Base   ; (reset local vars pointer after BL)

65  ; Reprogram ASD, if required

        LDRH    r1, [r14, #SRC_C]       ; get currently active SRC value
        LDRH    r4, [r14, #SRC_H]       ; compare against value to apply from now on
        CMP     r4, r1                  ; are they the same?
        BEQ     %FT67

        MOV     r10, r14                ; remember r14
        MOV     r1, #&2C
        MOV     r0, r4
        BL      WriteAC97               ; set rate in the codec

        STRH    r4, [r10, #SRC_C]       ; and record as current value
        MOV     r14, r10                ; (reset local vars pointer after BL)

67      LDRH    r1, [r14, #SRC_N]       ; in any case, step FIFO...
        STRH    r1, [r14, #SRC_H]       ; to keep everything in sync.
        CMP     r4, r1                  ; if new value on NEXT irq, mark update for Level1 now
        ORRNE   r6, r6, #1 :SHL: 31

; level0 MEMC update

70      MOV     r10, r6, LSL #16        ; 16-bit buffer length in r10
        MOV     r10, r10, LSR #16
        MOV     r11, r6, LSR #24        ; 3-bit log channel count, + flags, in r11
        TST     r11, #DoOversample      ; 16-bit: check for oversampling
        MOVEQ   r11, #2                 ; 4 bytes/sample if no o/s
        MOVNE   r11, #3                 ; but 8 bytes/sample if o/s
71
        AND     r11, r11, #3
        MOV     r4, r10, LSL r11        ; compute physical buffer length in r4
        BIC     r4, r4, #&F             ; must be a multiple of 16
        MOV     r10, r4, LSR r11        ; may need to adjust logical buffer len
        MOV     r0, r4                  ; compute DMA end

        LDR     r2, [r14, #SoundRMA]
        LDR     r2, [r2, #DMACTRL_base]
        STR     r5, [r2, #DMA_C7NBA]
        STR     r0, [r2, #DMA_C7NTC]
        MOV     r4, #&80
        STR     r4, [r2, #DMA_ICR]      ; clear the interrupt
        LDR     r4, [r2, #DMA_UR]       ; check for still underrun
        TST     r4, #&80
        STRNE   r5, [r2, #DMA_C7NBA]
        STRNE   r0, [r2, #DMA_C7NTC]

80

; Level0Updated - any events to dispatch?

        Push    "r8-r12, r14"           ; r1-r7 preserved by scheduler
        LDR     r12, =SoundLevel0Base
        LDR     r12, [r12, #Level2Ptr]
        TST     r12, #SoundSystemNIL    ; test for installed scheduler
        LDREQ   r0, [r12]
        TSTEQ   r0, #SoundSystemNIL     ; Valid Level2?
        MOVEQ   lr, pc
        MOVEQ   pc, r0                  ; Call Level2
        Pull    "r8-r12, r14"

; Level0 ready to fill

        MOV     r11, r6, LSR #24        ; get log2nchan + flags
        TST     r11, #DoOversample      ; 16-bit: check for oversampling
        MOVEQ   r11, #2                 ; 4 bytes/sample if no o/s
        MOVNE   r11, #3                 ; but 8 bytes/sample if o/s
81
        AND     r11, r11, #3            ; get just log2nchan
        MOV     r10, r6, LSL #16        ; get logical buffer length/channel
        MOV     r10, r10, LSR #16       ; (16 bits worth)
        MOV     r4, r10, LSL r11        ; work out physical length into r4
        BIC     r4, r4, #&F             ; must be a multiple of 16
        MOV     r10, r4, LSR r11        ; may need to adjust logical buffer len
        MOV     r4, r10, LSL #2         ; work out physical length into r4 (Fs*1, 16-bit stereo)
        MOV     r11, r6, LSR #24        ; get back real log2nchan (asking for 8bit data)
        AND     r11, r11, #3
        ADD     r10, r12, r10, LSL r11  ; r10 = logical buffer end
        MOV     r0, #1                  ; convert log to buffer inc
        MOV     r11, r0, LSL r11        ; r11 = N channels

82      ; Convert mu-law N-channel data in logical buffer to 16-bit stereo physical data

        TST     r9, #SoundSystemNIL     ; Valid Level1? Loaded only once, above
        MOVNE   r3, #0                  ; if not, mark no valid data in physical buffer
        BNE     %FT86                   ;         and go do 16-bit handling

        STMFD   sp!, {r4,r6,r10,r12} ; save off physlen, config, logend, buffstart

        MSR     CPSR_c, #IRQ32_mode     ; enable IRQs

        ; Zap the logical buffer to 0 before calling level 1 code to fill it.
        ; This is necessary for compatibility, since the standard channel
        ; handler assumes that any channel which is silent will have 0 data in
        ; its entries in the logical buffer.  But since we overwrite the
        ; logical data with 16-bit physical data after filling it, this will
        ; not hold in general.  So fill the logical buffer with all 0 now.
        ;
        ; KJB - surely better to have separate logical and physical buffers?
        ; maybe not - more cache thrashing?

        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        MOV     r8, r12

        ; Zero 4*8 words = 128 bytes each loop.  Slightly overrunning the
        ; logical buffer end is not a problem, and since the physical
        ; buffers are a multiple of 128 bytes in length, we won't overrun
        ; those either.

84      STMIA   r8!, {r0-r7}
        STMIA   r8!, {r0-r7}
        STMIA   r8!, {r0-r7}
        STMIA   r8!, {r0-r7}
        CMP     r8, r10
        BLO     %BT84

        MSR     CPSR_c, #I32_bit + IRQ32_mode ; IRQs off again

        ; Call Level1: don't change mode, flags

        LDR     r6, [sp, #4]            ; reload config value, including update flag r6:31
        MOV     r8, r6, LSR #16         ; get current per-channel period in r8,
        AND     r8, r8, #&FF            ; for Level1 fill code

        MOV     lr, pc
        LDR     pc, [r9, #SoundLevel1FillPtr]

        LDMFD   sp, {r4,r6,r10,r12}    ; restore saved values. NB leave on stack: no `!'

        ; Convert mu-law to 16-bit linear data.
        ; have: physical length in r4,
        ;       logical buffer end in r10
        ;       logical buffer start in r12
        ; want: r10 and r12 as they are,
        ;       r11 = physical buffer start or end, according to logical buffer size
        ;       r9 = address of 256-entry mu-law to 16-bit conversion table
        ;       r8 = &FF for byte masking in conversion routine
        ;       r5 = &7FFF for overflow test

        TST     r6, #2 :SHL: 24         ; 4 or 8 channels in use?
        MOVNE   r11, r12                ; write 16-bit data forwards from start if so
        ADDEQ   r11, r12, r4            ; else write 16-bit data backwards from phys buff end
        ADRL    r9, convtable           ; address conversion table for routine to use
        MOV     r8, #&FF                ; set up byte mask used in routine
        ORR     r5, r8, #&7F00          ; and also mask for limit check
        LDR     r0, =SoundLevel0Base    ; address our local data
        LDR     r0, [r0, #SoundRMA]     ; go get RMA space address
        MOV     r7, #&70000003          ; put impossible 16-bit output value in r7
        MSR     CPSR_c, #IRQ32_mode     ; enable IRQs
        Push    pc                      ; set up return address
        ADD     pc, r0, #LinConvCode    ; call conversion code
        NOP

        MSR     CPSR_c, #I32_bit+IRQ32_mode ; IRQs off again

        LDMFD   sp!, {r4,r6,r10,r12}    ; again restore values, clearing stack this time

        CMP     r7, #&70000003          ; if impossible value still in r7, all data was 0
        MOVNE   r3, #1                  ; mark that there is valid (non-0) data in buffer
        MOVEQ   r3, #2                  ; else mark that 16-bit data in buffer is all 0

86      ; We're now dealing with a physical buffer containing 16-bit stereo
        ; data (it will still contain old data from last time, if no level 1
        ; handler is present).  Check whether there is a 16-bit sound
        ; generator/mixer, and if so, call it.  Note that r3 determines
        ; whether there is valid 16-bit data in the buffer already:
        ;
        ;     0 => old/invalid (*must* overwrite) - jumped here directly, no level 1 handler
        ;     1 => yes, valid, not all 0, but may overwrite to ignore
        ;     2 => yes, and known to be all 0, so can simply return if silent

        LDR     r0, =SoundLevel0Base
        LDR     r5, [r0, #SoundRMA]     ; address RMA workspace
        LDR     r11, [r5, #Lin16Gen]    ; pick up code address
        LDR     r0, [r5, #Lin16GenR0]   ; pick up paramter to pass it in r0
        MOV     r1, r12                 ; pass base of buffer in r1
        ADD     r2, r12, r4             ; and end of buffer in r2
        CMP     r11, #0                 ; check for valid entry, if so.....
        STMFD   sp!, {r1,r2}            ; save base/limit for oversampler below
        BEQ     %FT87
        LDR     r4, [r5, #CurSRValue]   ; load up current frequency value into r4

        MOV     lr, pc                  ; and go call
        MOV     pc, r11

87
        LDMFD   sp, {r0,r1}             ; reload (no pop) phys base & limit now

        MSR     CPSR_c, #IRQ32_mode     ; enable IRQs (watch out for r14)

        ; Finally, perform mono mix-down and/or oversampling, if required.

        LDR     r11, =SoundLevel0Base
        LDRB    r3, [r11, #Flags]
        MOV     r3, r3, LSR #OverMonoShift
        ANDS    r3, r3, #3              ; bit 0 -> oversamp. bit 1 -> mono
 [ StereoReverse
        BEQ     StereoOnly
 |
        BEQ     BufferDone              ; nowt to do if both bits clear (r3 = 0)
 ]

	; OK, doing some sort of filtering operation.  Set up some constants
	; used in all cases...

        ; Set up 0x80008000 in r12, to perform signed/unsigned swap overs
        MOV     r12, #1<<15
        ORR     r12, r12, #1<<31

        ; Create 0xFFFEFFFE in r11 for masking off LSBs, to isolate LH and RH
        ; parts during parallel additions.
        MVN     r11, r12, ROR #15       ; can derive from r12 in one go!

        CMP     r3, #2                  ; check which proc we need to call (1,2,3)
        BEQ     MonoOnly                ; if r3 = 2, do just mono conversion
                                        ; else doing oversampling...
        SUB     r2, r1, r0              ; determine phys length of buffer at Fs*1
        ADD     r2, r0, r2, LSL #1      ; and compute end of buffer at Fs*2
        STR     r2, [sp, #4]            ; store out for later use also
                                        ; switch to appropriate oversampling code
        BLT     OverOnly                ; if r3 < 2 (i.e. 1), only oversample
        B       MonoOver                ; if r3 > 2 (i.e. 3), do mono + oversample

BufferDone	; return here after any buffer processing
        MSR     CPSR_c, #I32_bit + IRQ32_mode ; redisable IRQs
	Pull	"r3,r4" 		; pop phys base+real limit (@Fs*2 if oversampling)
	LDR	r6, [r4, #-4]		; pick up last sample pair from this buffer
	LDR	r11, =SoundLevel0Base 	; address sound work area
	LDR	r7, [r11, #SoundRMA]	; address RMA area
	STR	r6, [r7, #SavedSample]	; save sample pair for possible oversampling next time

99      ; All done for this IRQ

        Pull    "r0-r10"
        LDR     wp, =SoundLevel0Base
        MOV     r11, #0
        STR     r11, [wp, #Semaphore]   ; clear semaphore
        Pull    "r11, pc"               ; Return from interrupt


; Buffer processing routines - 3 off, done as out-of-line code sequences which
; all return to "BufferDone" above....

; MonoOnly
;
;     Convert stereo into mono (in same buffer space)
;
;   r0 = base address of current buffer
;   r1 = limit address (last+1) of source (Fs*1)
;   r2-r9 free for general use
;   r10 = &FFFF0000
;   r11 = SoundLevel0Base
;   r12 free for general use
;   r14 = unavailable (IRQs enabled)
; On exit:
;   r0-r12,r14 corrupted

MonoOnly        ROUT
01      LDMDB   r1!, {r2,r3,r4,r5}
        ; convert from signed to unsigned format
        EOR     r2, r2, r12
        EOR     r3, r3, r12
        EOR     r4, r4, r12
        EOR     r5, r5, r12
        ; clear off LSB from each value (two in each reg)
        AND     r2, r2, r11
        AND     r3, r3, r11
        AND     r4, r4, r11
        AND     r5, r5, r11
        ; Add the left and right samples together, simultaneously in both upper and
        ; halves of each stereo pair. There will be no
        ; interference between carry out from the RHS MSB into bit 16 (LSB of
        ; LHS sample), and no carry from bit 16 into bit 17, since we cleared
        ; bit 16 in both sources (i.e. bit 16 and bit 0 of pre-rotated single source!)
        ; beforehand; therefore the subsequent right shift will correctly put the
        ; average of the two channel samples back into bits 15..0 (and also into
        ; bits 31..16, using RRX to recover carry out from bit 31).
        ; Get back to signed 16 bit result for each channel afterwards by EOR'ing
        ; with 0x80008000.
        ADDS    r2, r2, r2, ROR #16
        EOR     r2, r12, r2, RRX
        ADDS    r3, r3, r3, ROR #16
        EOR     r3, r12, r3, RRX
        ADDS    r4, r4, r4, ROR #16
        EOR     r4, r12, r4, RRX
        ADDS    r5, r5, r5, ROR #16
        EOR     r5, r12, r5, RRX
        STMIA   r1, {r2,r3,r4,r5}       ; store them all out
        CMP     r1, r0                  ; have we just done last loop?
        BNE     %B01                    ; round again if not
        B       BufferDone              ; we're all done


; OverOnly:
;     Oversample, expanding buffer by factor of 2 by performing linear interpolation
;     between each pair of samples.  For the very first case, this uses a saved copy
;     of the last stereo sample pair word (2x16-bit) from the end of the previous
;     buffer, to interpolate against.  Note that this process is done in reverse
;     order (working from end of buffer back to start) to avoid overwriting the
;     initial data as would happen if we went forwards..
OverOnly        ROUT
        MSR     CPSR_c, #SVC32_mode     ; want to use R14...
        Push    r14
        LDR     r14, [r1, #-4]!         ; get last sample in source buffer now
 [ StereoReverse
        EOR     r14, r12, r14, ROR #16  ; convert signed to unsigned and stereo reverse
 |
        EOR     r14, r14, r12           ; convert signed to unsigned
 ]
        AND     r14, r14, r11           ; mask LSB bits from this sample-pair
        ADD     r0, r0, #8*4            ; need to do last group separately, so move base

01      LDMDB   r1!, {r3,r5,r7,r9}      ; load 4 new samples

02      ; convert from signed to unsigned format (into separate regs apart from r3)
 [ StereoReverse
        EOR     r3, r12, r3, ROR #16
        MOV     r5, r5, ROR #16
        EOR     r6, r12, r5
        MOV     r7, r7, ROR #16
        EOR     r8, r12, r7
        MOV     r9, r9, ROR #16
        EOR     r10, r12, r9
 |
        EOR     r3, r3, r12
        EOR     r6, r5, r12
        EOR     r8, r7, r12
        EOR     r10, r9, r12
 ]
        ; clear off LSB from each value (two in each reg)
        AND     r3, r3, r11
        AND     r6, r6, r11
        AND     r8, r8, r11
        AND     r10, r10, r11
        ; oversampling: average pairs and turn back to signed format
        ADDS    r4, r3, r6
        EOR     r4, r12, r4, RRX
        ADDS    r6, r6, r8
        EOR     r6, r12, r6, RRX
        ADDS    r8, r8, r10
        EOR     r8, r12, r8, RRX
        ADDS    r10, r10, r14
        EOR     r10, r12, r10, RRX
        EOR     r14, r12, r14                   ; put r14 back to signed format also
        STMDB   r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results interleaved with originals
        MOV     r14, r3                 ; set lowest sample for end of next group
        CMP     r2, r0                  ; have we just done last normal loop?
        BHI     %B01                    ; round again if not
        Pull    r14, LO
        BLO     BufferDone              ; all done if done extra, special loop

        ; (r2==r0) for last special loop, pick up very first 3 samples from this buffer
        LDMDB   r1!, {r5,r7,r9}
        ; get last sample from previous buffer, to interpolate for first new sample of this
        LDR     r3, =SoundLevel0Base
        LDR     r3, [r3, #SoundRMA]
 [ StereoReverse
        LDR     r3, [r3, #SavedSample+2]
 |
        LDR     r3, [r3, #SavedSample]
 ]
        B       %B02                    ; use main loop code to do it

 [ StereoReverse
StereoOnly      ROUT
; Reverse stereo only
01      LDMDB   r1!, {r2,r3,r4,r5}      ; get four new samples
        MOV     r2, r2, ROR #16         ; reverse left-right stereo pairs
        MOV     r3, r3, ROR #16
        MOV     r4, r4, ROR #16
        MOV     r5, r5, ROR #16
        STMIA   r1, {r2,r3,r4,r5}       ; write back the four samples
        CMP     r1, r0                  ; have we finished?
        BNE     %B01
        B       BufferDone
 ]

; Convert to mono and oversample also
MonoOver        ROUT
        MSR     CPSR_c, #SVC32_mode     ; want to use R14...
        Push    r14
        ADD     r0, r0, #8*4            ; need to do last group separately, so move base

        LDR     r14, [r1, #-4]!         ; get last sample in source buffer now
        EOR     r14, r14, r12           ; convert signed to unsigned
        AND     r14, r14, r11           ; mask LSB bits from this sample-pair
        ADDS    r14, r14, r14, ROR #16  ; convert to mono
        AND     r14, r11, r14, RRX

01      LDMDB   r1!, {r3,r5,r7,r9}      ; get four new samples: signed, full 16-bit, stereo

02      ; convert from signed to unsigned format
        EOR     r3, r3, r12
        EOR     r5, r5, r12
        EOR     r7, r7, r12
        EOR     r9, r9, r12
        ; clear off LSB from each value (two in each reg)
        AND     r3, r3, r11
        AND     r5, r5, r11
        AND     r7, r7, r11
        AND     r9, r9, r11
        ; Monoise unsigned masked versions of input data; since we're also oversampling,
        ; leave in unsigned form and mask off LSBs again
        ADDS    r3, r3, r3, ROR #16
        AND     r3, r11, r3, RRX
        ADDS    r5, r5, r5, ROR #16
        AND     r5, r11, r5, RRX
        ADDS    r7, r7, r7, ROR #16
        AND     r7, r11, r7, RRX
        ADDS    r9, r9, r9, ROR #16
        AND     r9, r11, r9, RRX
        ; then oversample, generating new intermediate values in r4,r6,r8,r10, in signed format
        ADDS    r4, r3, r5
        EOR     r4, r12, r4, RRX
        ADDS    r6, r5, r7
        EOR     r6, r12, r6, RRX
        ADDS    r8, r7, r9
        EOR     r8, r12, r8, RRX
        ADDS    r10, r9, r14
        EOR     r10, r12, r10, RRX
        ; must convert monoised unsigned masked originals back to signed format also
        EOR     r5, r12, r5
        EOR     r7, r7, r12
        EOR     r9, r9, r12
        EOR     r14, r12, r14           ; put r14 back to signed format also for store-out
        STMDB   r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results, interleaved with originals
        MOV     r14, r3                 ; copy lo sample (mono,still unsigned & masked) for next group
        CMP     r2, r0                  ; have we just done last normalloop?
        BHI     %B01                    ; round again if not
        Pull    r14, LO
        BLO     BufferDone              ; return if just done extra, special loop

        ; r2==r0: finally, pick up very first 3 samples from this buffer
        LDMDB   r1!, {r5,r7,r9}
        ; and last sample from previous buffer, to interpolate for first new sample of this
        LDR     r3, =SoundLevel0Base
        LDR     r3, [r3, #SoundRMA]
        LDR     r3, [r3, #SavedSample]
        ; use main loop code to do final (earliest) 8 samples of output
        B       %B02

;
; ConvImages
;
; Passed in a pointer in r0 to 8 bytes (Images), returns in r0 a word
; having bits 31:24 zero and with 24:0 being compacted image data for
; programming (8 x 3 bits, chan 0 in bits 2:0, 1 = MAX L, 7 =
; MAX R).  r1-r13 preserved.
ConvImages Entry r1
        ADD     r1, r0, #7              ; start with channel 7
        MOV     r0, #0                  ; initialise output in r0
10      LDRB    lr, [r1], #-1           ; get one byte
        CMP     lr, #&E0                ; convert from linear pos to SIR value
        ADDLT   lr, lr, #&10
        MOVS    lr, lr, LSR #5
        MOVEQ   lr, #1                  ; correct for min
        MOV     r0, r0, LSL #3          ; shift previous values left one channel pos
        ORR     r0, r0, lr              ; merge in this channel into bottom
        TST     r0, #7 :SHL: (7*3)      ; shifted channel 7 value into place yet?
                                        ; (all output values are 1..7, i.e. not 0)
        BEQ     %BT10                   ; go round again if not
        EXIT                            ; all done, go home

; In: R0 = data
;     R1 = register number (bit 20 set => don't wait for response)
; Out: R0, R1 corrupted
WriteAC97    ROUT
        Push    "r2,r3,lr"
        LDR     r14, [r10, #SoundRMA]
        LDR     r3, [r14, #SIC_base]
        MRS     lr, CPSR
        MOV     r0, r0, LSL #4          ; Data
        MOVS    r1, r1, LSL #12         ; Register number  (C set => no wait)
        ORR     r2, lr, #I32_bit
        MSR     CPSR_c, r2
        STR     r1, [r3, #ACCAR]
        STR     r0, [r3, #ACCDR]
        BCS     %FT15
10      LDR     r1, [r3, #SIRSR]                ; Why poll for the result when we don't
        TST     r1, #1                          ; need it? Better would be to set a flag
        BEQ     %BT10                           ; and poll at the next access attempt.
15      MSR     CPSR_c, lr
        Pull    "r2,r3,pc"

; In: R1 = register number
; Out: R0 = data, R1 corrupted
ReadAC97    ROUT
        Push    "r3,lr"
        LDR     r14, [r10, #SoundRMA]
        LDR     r3, [r14, #SIC_base]
        MRS     lr, CPSR
        MOV     r1, r1, LSL #12         ; Register number
        ORR     r1, r1, #1:SHL:19
08      ORR     r0, lr, #I32_bit
        MSR     CPSR_c, r0
        STR     r1, [r3, #ACCAR]
10      LDR     r0, [r3, #SIRSR]
        TST     r0, #1:SHL:18
        BNE     ReadAC97_timeout
        TST     r0, #2
        BEQ     %BT10
        LDR     r0, [r3, #ACSDR]
        MOV     r0, r0, LSR #4
        MSR     CPSR_c, lr
        Pull    "r3,pc"

ReadAC97_timeout
        MOV     r0, #1:SHL:18
        STR     r0, [r3, #SIICR]
        MSR     CPSR_c, lr              ; re-enable IRQs (briefly)
        B       %BT08


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CopyError Entry r1-r7
        BL      open_messagefile
        EXIT    VS
        ADD     R1, R12, #MessageFile_Block
        MOV     R2, #0
        MOV     R4, #0
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.SoundDMA.Messages", 0
        ALIGN

open_messagefile Entry r0-r2
        LDR     r0, [r12, #MessageFile_Open]
        CMP     r0, #0
        EXIT    NE
        ADD     R0, r12, #MessageFile_Block
        ADR     R1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        EXIT    VS
        MOV     r0, #1
        STR     r0, [r12, #MessageFile_Open]
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ debug
        InsertNDRDebugRoutines
 ]

        END

