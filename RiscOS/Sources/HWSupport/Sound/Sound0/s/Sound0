        TTL     Sound System v3.0 -> <wini>arm.Sound0.Sound0

; *************************************************
; **                                             **
; **       ARTHUR Sound System Software          **
; **                                             **
; **    MODULE: SoundDMAHandler                  **
; **            Level0 Sound System Module       **
; **                                             **
; **    AUTHORS: David Flynn (alas, no more)     **
; **             Stuart Swales (ditto)           **
; **             Tim Dobson                      **
; **             Mark Taunton                    **
; **                                             **
; **    DESCRIPTION: all the privileged access   **
; **            to hardware/physical addresses   **
; **                                             **
; **    ENTRIES: IRQ  from Sound Buffer IRQ      **
; **             SWIs for system level interface **
; **             CLI  commands interface         **
; **                                             **
; *************************************************

; 1.05  EPROM release
; 1.06  Change help messages to add full stops
; 1.07  prevent ROM code linking to vector twice!
; 1.08  fix ROUT bug which corrupted Overrun fix
; 1.09  Service call reset IRQ problem...
; 1.10  Stereo help text fix
; 1.11  Tokenise help. SKS. Was looping freeing in death, not necessary
;       shorter exit sequences with {pc}^. Common error exits. Silly error
;       from irq claim failure. New irq scheme makes shorter + sexier
;       moved audio bug fix to proper place
;       Use spare registers in SWI handler
; 1.12  Fixed more places where IRQ could get in
; 1.13  Pass SoundLevel0Base around - a useful constant indeed!
;       Fixed RESET disabling sound problem. IRQ code neater, faster
; 1.14  Stereo can take optional '+' sign, does services
; 1.15  Had to take out overrun capability as it was much too dangerous
; ---- Released for Arthur 2.00 ----
; 1.16  Added code to cope with Fox VIDC clock speed adjustment
;       Modified header GETs so they work again
; 1.17  Internationalised
; 1.18  OSS  Added assemble time code for A500 which modifies the DMA
;            buffer for VIDC1 (rather than VIDC1a). Code courtesy of JRoach.
; 1.20  01 Mar 92  OSS  Changed to execute A500 buffer modify code in RAM to
;                       minimise the chance of overruns.
; 1.21  07-Aug-92  TMD  Re-added MEMC2 option
; 1.22  27-Aug-92  TMD  Put in VIDC20 option
; 1.23  16-Feb-93  TMD  Corrected for rotation of stereo image registers on VIDC20
; 1.24  25-May-93  MT   Added IOMD support; also conditionals (defined in xxHdr
;                       file) to handle loudspeaker on/off control (SpkControl)
;                       and sound clock frequency variation with video mode
;                       (VarSndClock). Older machines have both: Medusa has
;                       neither.
; 1.25  02-Jul-93  MT   Sound0Hack flag (defined in JordanHdr) now
;                       checked when assembling IOMD version, to avoid
;                       use of OS_Memory (not yet available), and
;                       OS_ClaimDeviceVector with IOMD DMA channels as
;                       devices (since that is also not yet ready).
;                       We use privileged knowledge about kernel's
;                       memory addressing variables to circumvent the
;                       first problem, and IrqV instead of the real
;                       IRQ vector, for the second.
; 1.26  09-Jul-93  TMD  Fix stack imbalance in unknown IRQ code.
; 1.27  15-Jul-93  JSR  Switch to new headers system.
; 1.28  06-Aug-93  MT   Fix bug in IOMD code where overrun (e.g. when
;                       interrupts were disabled for more than a
;                       buffer time) caused system lockup because of
;                       failure to program the correct buffer.
; 1.29  06-Aug-93  MT   No software change - merely getting version number
;                       right here.
; 1.30  11-Aug-93  MT   Fix handling of service call (bug MED-00362)
; 1.31  11-Aug-93  MT   Add the above line and this one, forgotten before (no
;                       code change).
; 1.32  26-Aug-93  OL   Libra mods: International_Help bit set for *audio,
;                       *speaker, *stereo. (These log lines added by MT.)
; 1.33  02-Sep-93  MT   Turned off Sound0Hack (no longer needed, but left in
;                       source for now); fixed stack imbalance bug in code for
;                       exit on XOS_Memory failure; added log entry for 1.32.
; 1.34  05-Oct-93  MT   Corrected flags to XOS_Memory, to fix bug MED-00621.
; 1.35  11-Nov-93  JSR  Fix MED-00820 - fix international help for *Stereo command.
;                       Install, but leave disabled, sound quenching code to quieten
;                       the quiet bits.
; 1.36  14-Feb-94  TMD  Fix MED-02859 - don't call InitResetCommon on Service_Reset
;                       unless it's a soft reset.
; 1.37  30-Jun-94  MT   Removed Sound0Hack, no longer needed, and JSR's sound quenching
;                       code - newer hardware fixes this `properly'.  Major surgery
;                       throughout, to support 16-bit output (set up by CMOS config).
; 1.38  12-Jul-94  MT   Fix problem with Sound_SampleRate setting new rate without VIDC
;                       programming offset of 2.  Also cure duff error on bad param.
; 1.40  18-Oct-94  RCM  Add power saving calls for Stork see 'StorkPower'.
; 1.41  21-Oct-94  SMC  Fixed bug in level0 fill where code could ask for more than would
;                       be played.
;                       Fixed MIN-00087 - Sound_Configure code allowed buffer size to be set
;                       too large for 16bit sound. Also WorkOutVIDCParams called process_oversample
;                       which used the OLD buffer size to determine whether to oversample rather than
;                       the new one given in the SWI call.
;                       Fixed MIN-00022 - Added *Configure SoundSystem for 8bit/16bit sound.
;
; ********************  See SrcFiler log file for changes since version 1.41.
;
; 1.53 14-Apr-97  MT    Merge in changes for StrongARM compatibility, mono output and
;                       oversampling performance improvement.  Change default sample rate
;                       to 22.05Khz, if hardware support is available for this (STB/NC).
; 1.54 22-Apr-97  MT    Fix to allow mono output to be controlled (Sound_Mode 3) - although
;                       the implementation was present, the code to recognise and act on
;                       the specific SWI function code had been omitted by accident in the
;                       code merge.
; 1.59 22-Feb-01  SBF   Obsolete STB flag removed; default frequency of 20.8333kHz used in all cases
;

              GBLL    StrongARM
StrongARM     SETL    {TRUE}
              GBLL    ARM810support
ARM810support SETL    {FALSE}

        GET     Hdr:ListOpts
        OPT     OptNoList
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        $GetVIDC
        $GetMEMM
        $GetIO
        GET     Hdr:CMOS
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:PublicWS
        GET     Hdr:Tokens
        GET     Hdr:DevNos
        GET     Hdr:Proc
        GET     Hdr:VduExt
        GET     Hdr:MsgTrans
        GET     Hdr:HostFS
        GET     Hdr:DDVMacros
        GET     Hdr:NDRDebug

        OPT     OptList
        OPT     OptPage

        GET     Hdr:Sound
        GET     Hdr:Portable

        GET     Version
        GET     VersionASM


;
; Define the VIDC specific things
;
; Note that we only handle VIDC1, VIDC1a and VIDC20
;
        GBLL    VarSndClock
 [ VIDC_Type = "VIDC1a"
VarSndClock     SETL    {TRUE}
 ]
 [ VIDC_Type = "VIDC20"
VarSndClock     SETL    {FALSE}
 ]

;
; Define IO specific things
;
        GBLL    SpkrControl
SpkrControl     SETL    IO_Type = "IOC-A1" :LOR: IO_Type = "IOC-A500" :LOR: IO_Type = "IOEB"

 [ MEMC_Type = "IOMD"

; On IOMD-based systems, to support sound DMA "cheaply" in terms of
; software complexity, we must have physical sound buffers no bigger
; than the maximum DMA buffer IOMD supports (i.e. number of bytes
; transferred per DMA interrupt).  This is 4Kbytes: the size of a page
; on ARM{6,7}00 machines.  In addition, for each sound DMA buffer,
; either it must all lie within a single physical page, or else the
; pages which contain it must be physically contiguous.  We could
; survive any combination of values for SoundDMABufferSize and
; SoundDMABuffers which satisfied both these conditions. However it is
; simpler here (e.g. no need for physical contiguity check) just to
; use the tighter condition that the SoundDMABufferSize is *exactly*
; 4096 and that the base address of the sound buffers is on a 4096
; byte boundary. This was true for the original values as used on
; MEMC1 systems, and is unlikely to need to change. Therefore this
; tighter restriction is OK.

    [ SoundDMABufferSize /= 4096
        ! 1, "SoundDMABufferSize must be exactly 4096 for Sound0 on IOMD"
    ]
    [ SoundDMABuffers :MOD: 4096 /= 0
        ! 1, "SoundDMABuffers must be 4096-byte-aligned for Sound0 on IOMD"
    ]

; In addition, for yet more simplification, and minimum code change to
; support IOMD, we assume here that the two 4Kb sound buffer pages are
; physically contiguous (in the right order!), so that we can continue
; to use only one word [rLevel0Base,#Phys0] to hold the base address.
; This assumption cannot currently (21-May-93) be tested at assembly
; time.

 ]

        GBLL    StorkPower
StorkPower      SETL    True

 [ StorkPower
        GBLL    AdvancedPower   ;True - power on only whilst buffers hold 'non-quiet' data
AdvancedPower   SETL    False   ;Switched off cos amps have nasty switch-on click
 ]

        GBLL    EnableIRQsIn16bit
EnableIRQsIn16bit       SETL    False

 [ EnableIRQsIn16bit
        GBLL    DisableFlybackIRQ
DisableFlybackIRQ       SETL    True

        GBLL    DisableHardDiscIRQ
DisableHardDiscIRQ      SETL    True
 ]

        GBLL    debug
debug           SETL    False

        GBLL    hostvdu
hostvdu         SETL    True

swi     SETD    False

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Level0 data structure

; Sound0Segment:  Sound DMA Control Block
;
; Total of 16 words available.  First 9 must NOT be reordered without also
; fixing static copy (ProtoS0S) and init code, since an LDM/STM pair is used
; with specific registers known to match particular fields
          ^ 0
Semaphore # 4
Phys0     # 4   ; physical address of buffer 0
Buff0     # 4   ; logical page addresses...
Buff1     # 4
Config    # 0
BuffLenLo # 1   ; 16-bit Buffer Length
BuffLenHi # 1
Period    # 1   ; 8-bit SFG period
NChannels # 0   ; Log channels (3 bit) AND sundry flags
Flags     # 1   ; Name for flags byte
Level1Ptr # 4
Images    # 8   ; (8) byte image positions, full 8-bit resolution of user value (-127..127)
Level2Ptr # 4   ; scheduler

; End of order-critical section. From here on, items are initialised
; dynamically and one item at a time, hence order is not significant.

; To cope with hardware DMA buffer pipeline, need to keep parallel pipelines
; for VIDCSFR and VIDCSCR values; also VIDC SIR values (if not in 16-bit mode
; when stereo is handled in software).
VIDCSFR_N # 1   ; (new) value to stick into VIDC to program sound frequency register
VIDCSFR_H # 1   ; value which IRQ code should ensure is in SFR on next irq
VIDCSFR_C # 1   ; softcopy of value currently set in VIDC
; same for VIDCSCR
VIDCSCR_N # 1   ; (new) value to program into VIDC20's Sound Control Register
VIDCSCR_H # 1   ; value which IRQ code should ensure is in SCR on next irq
VIDCSCR_C # 1   ; softcopy of value currently set in VIDC

; Code to handle stereo 16-bit linear emulation of N-channel mu-law needs to
; keep track of how many channels are in use.
Log2nchan_C # 1 ; Log2(currently active channel count), as compiled into 16-bit conv code

 [ VarSndClock
VIDCMultiplier # 1 ; VIDC clock speed in units of 4MHz
 |
Spare0    # 1
 ]

ImagesC_N # 4   ; compacted (new) version of Images, for prog'ing SIR or conv. routine
ImagesC_H # 4   ; value which IRQ code will load into VIDC SIRs on next irq
ImagesC_C # 4   ; softcopy of value currently programmed into VIDC
SoundRMA  # 4   ; pointer to remaining data/dynamic code items held in RMA
SoundGain # 1   ; value of additional gain (0..7) -> +0 .. 21dB in 3dB steps, for mu-law
SoundGain_C # 1 ; value of additional gain as currently compiled into conv code

; CURRENTLY 3(2?) BYTES SPARE (FOR VIDC20).

        ASSERT  @ <= SoundLevel0Reserved

; Constants
; SC prefix for SoundConstant
SCPeriod     * 48                       ; default, i.e. 20.8333 kHz (48us)

SCBufferLen  * 208                      ; 208 bytes/channel (&D0: multiple of 16)
SCLogChannel * 0                        ; default log2nchan = 0 -> 1 channel
SCSoundGain  * 0                        ; default soundgain is 0

; Flags bits in NChannels/Flags byte: bottom 2 bits are log2nchan, next 2 bits are
; Lin16 flags, 1 bit for auto-oversampling flag, 1 bit for "oversampling active" flag,
; 1 bit for mono-isation flag, top bit reserved (probably unnecessarily) for Level1Fill
; handler call "Level0 updated" flag.
DoMono          *       &40             ; mono-isation control bit
DoOversample    *       &20             ; oversampling active bit
OverMonoShift   *       5               ; shift to get to OS/Mono as 2-bit field
OversampleFlag  *       &10             ; AutoOversampling flag from CMOS
Lin16Bits       *       &0C             ; flags for 16-bit linear mode (VIDC20)
Lin16Shift      *       2               ; low bit of field is bit 2
L16_mulaw       *       &00             ; no, normal mu-law output
L16_slave44k    *       &04             ; DAC slave with 44k1*256 ext sound clock
L16_slaveInt    *       &08             ; DAC slave, no ext sound clock, internal only
L16_master      *       &0C             ; DAC clock is master (MUST use ext sound clock)

; Definition of cut-off point for oversampling
MinOSPeriod     *       40              ; do not oversample if period < 40 (f > 25kHz)

; Level0 constants

 [ MEMC_Type = "IOMD"
; Physical address of sound DMA buffers is not fixed on IOMD systems, but
; needs to be determined at initialisation time.
 |
SoundPhysBuffers * TopOfDMAPhysRAM - (TopOfDMAWorkSpace-SoundDMABuffers)
 ]

 [ VIDC_Type = "VIDC20"
SIR0    *       &A1000000               ; Stereo Image Register addr for chan 0
SIR1    *       &A2000000               ; etc...
SIR2    *       &A3000000
SIR3    *       &A4000000
SIR4    *       &A5000000
SIR5    *       &A6000000
SIR6    *       &A7000000
SIR7    *       &A0000000               ; NB chan 7 address is out of order
SIRSTEP *       &01000000               ; offset from one SIR to next
SFR     *       &B0000000               ; Sound Frequency Register
SCR     *       &B1000000               ; VIDC20 also has Sound Control Reg
 |
SIR0    *       &64000000
SIR1    *       &68000000
SIR2    *       &6C000000
SIR3    *       &70000000
SIR4    *       &74000000
SIR5    *       &78000000
SIR6    *       &7C000000
SIR7    *       &60000000               ; chan out of order
SIRSTEP *       &04000000               ; offset from one SIR to next
SFR     *       &C0000000
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module Header
        OPT     OptPage

        AREA    |Sound0$$Code|, CODE, READONLY, PIC

Module_Base
        DCD     0                    ; NOT AN APPLICATION
        DCD     Initialise_Module    - Module_Base
        DCD     Finalise_Module      - Module_Base
        DCD     Intercept_Services   - Module_Base
        DCD     Module_Name          - Module_Base
        DCD     Help_String          - Module_Base
        DCD     Module_Keywords      - Module_Base
        DCD     Module_SWISystemBase + Sound0SWI * Module_SWIChunkSize
        DCD     Sound_SWI_Code       - Module_Base
        DCD     Module_SWIDecodeBase - Module_Base
        DCD     0                    ; No decoding code.
 [ International_Help <> 0
        DCD     message_filename     - Module_Base
 |
        DCD     0
 ]
 [ :LNOT: No32bitCode
        DCD     Module_Flags         - Module_Base
 ]

Module_Name
        DCB     "SoundDMA", 0

Help_String
        DCB     "SoundDMA"
        DCB     9
        DCB     "$Module_HelpVersion"
 [ Development
        DCB     " Development"
  [ EnableIRQsIn16bit
        DCB     " IRQs enabled"
  |
        DCB     " IRQs disabled"
  ]
 ]
 [ VIDC_Type = "VIDC20"
  [ MEMC_Type = "IOMD"
        DCB     " Generic"
  |
        DCB     " VIDC20/MEMC1 version"
  ]
 ]
 [ MEMC_Type = "MEMC2" ; assume => VIDC10
        DCB     " MEMC2 version"
 ]
        DCB     0

Module_SWIDecodeBase
        DCB     "Sound",0
        DCB     "Configure",0
        DCB     "Enable",0
        DCB     "Stereo",0
        DCB     "Speaker",0
        DCB     "Mode",0
        DCB     "LinearHandler",0
        DCB     "SampleRate",0
        DCB     0

Module_Keywords

        DCB     "Audio", 0
        ALIGN
        DCD     Audio_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)   ; all flags clear, and one parameter ONLY
        DCD     Audio_Syntax - Module_Base
        DCD     Audio_Help   - Module_Base

        DCB     "Speaker", 0
        ALIGN
        DCD     Speaker_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)   ; all flags clear, and one parameter ONLY
        DCD     Speaker_Syntax - Module_Base
        DCD     Speaker_Help   - Module_Base

        DCB     "Stereo", 0
        ALIGN
        DCD     Stereo_Code   - Module_Base
        DCB     2, 0, 2, 0:OR:(International_Help:SHR:24)   ; all flags clear, two parameters ONLY
        DCD     Stereo_Syntax - Module_Base
        DCD     Stereo_Help   - Module_Base

        DCB     "SoundGain", 0
        ALIGN
        DCD     SoundGain_Code   - Module_Base
        DCB     1, 0, 1, 0:OR:(International_Help:SHR:24)
        DCD     SoundGain_Syntax - Module_Base
        DCD     SoundGain_Help   - Module_Base

        DCB     "SoundSystem", 0
        ALIGN
        DCD     SoundSystem_Code   - Module_Base
        DCB     1, 0, 2, 0:OR:(International_Help:SHR:24):OR:(Status_Keyword_Flag:SHR:24)
        DCD     SoundSystem_Syntax - Module_Base
        DCD     SoundSystem_Help   - Module_Base

        DCB     0            ; no more entries.

        GET     s.TokHelpSrc

        ALIGN

 [ :LNOT: No32bitCode
Module_Flags
        DCD     ModuleFlag_32bit
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ VIDC_Type = "VIDC20"                 ; only on VIDC20 machines for now
;
; MT, May/June 1994.
;
; Code fragments used to convert from 1/2/4/8 channels of
; 8-bit mu-law sound in the "logical" buffer, to 2 channels of
; either 16-bit linear sound or 8-bit mu-law sound in the same
; buffer, now treated as a "physical" buffer to be output by DMA.
; Note the complexities caused because the logical buffer may
; be smaller than, the same size as, or bigger than the physical
; buffer, depending on the input and output sample-group sizes.
; There are always the same number of sample-groups in the physical
; buffer as in the logical buffer, and the sample rate is unaltered
; also.
;
; These fragments are compiled dynamically after any sound system
; reconfiguration or stereo position change, to cause the correct
; translation of data after the next sound DMA interrupt.  The compiled
; code lives in module workspace, whereas the conversion table stays
; here in module code space (though it might usefully be copied into
; RAM to maximise access speed if this code is running from ROM).
;
; On call to composite routine
;
;   r12 = start of logical/physical buffer
;   r11 = end of physical buffer (1,2 channels) or
;         start of physical buffer (4,8 channels)
;   r10 = end of logical buffer
;   r9  = base of 256-entry, 512-byte table converting mu-law bytes
;         (treated as 0..255, i.e. unsigned) to 16-bit signed
;         values in the range -3952..+3952.  See below
;         for more details on the format of entries.
;   r8  = 0xFF - mask for extraction of individual mu-law bytes
;   r5  = 0x7FFF - constant used for limit operation if soundgain > 0
;
; during call:
;   r7  = 32-bit accumulator for right channel linear data
;   r6  = 32-bit accumulator for left channel linear data
;   r0, r1, r3 - miscellaneous intermediate values
;   r2, r4, r5 - unused

; Conversion table (placed here to avoid addressing problems for the
; compiler).  Compute linear values from mu-law at assembly time.  For
; reference, the direct linear equivalents of mu-law values are:
;
; 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
; 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46
; 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108
; 112 120 128 136 144 152 160 168 176 184 192 200 208 216 224 232
; 240 256 272 288 304 320 336 352 368 384 400 416 432 448 464 480
; 496 528 560 592 624 656 688 720 752 784 816 848 880 912 944 976
; 1008 1072 1136 1200 1264 1328 1392 1456 1520 1584 1648 1712 1776 1840 1904 1968
; 2032 2160 2288 2416 2544 2672 2800 2928 3056 3184 3312 3440 3568 3696 3824 3952
;

convtable
        GBLA    chord
        GBLA    point
        GBLA    step
        GBLA    value
value   SETA    0
chord   SETA    0
        WHILE   chord < 8
step      SETA  1 :SHL: chord
point     SETA  0
          WHILE point < 16
            DCD         (((-value) :SHL: 2) :AND: &FFFF) :OR: ((value :SHL: 2) :SHL: 16)
value       SETA        value + step
point       SETA        point + 1
          WEND
chord     SETA  chord + 1
        WEND

; When size (logical buffer) >= size (physical buffer) we must proceed
; forward, loading via r12 which is stepped forwards until it equals
; r10.  Note that in this case r11 starts off = r12.  When the size of
; the logical buffer < size of physical buffer, must move backwards -
; r11 is initialised to end of physical buffer; hence r10 moves
; backwards and r12 stays constant as end-stop for logical buffer.
; End-condition is still r10 = r12.

; Instruction sequence (1): loop begin (same for all configurations)
loop_head
        CMP     R10, R12                ; check for having finished
        MOVEQ   PC, R14                 ; return if so

; Instruction sequence (2): load up a sample-time's worth of data (1..8 bytes), and
; check whether it is all zero. One instruction for each part, two instructions
; per sequence.  Indexed by log2nchan.
data_load_TAB
        LDRB    r1, [r10, #-1]!         ; instruction for loading 1 byte (backwards)
        MOVS    r1, r1, LSL #24         ; get 1 byte in top byte of r1, zero in rest

        LDR     r1, [r10, #-2]!         ; instruction for loading 2 bytes (backwards)
        MOVS    r1, r1, LSL #16         ; get 2 bytes in top half of r1, zero low bytes

        LDR     r1, [r12], #4           ; instruction for loading 4 bytes (forwards)
        MOVS    r1, r1                  ; check it for all 4 bytes being 0

        LDMIA   r12!, {r0,r1}           ; instruction for loading 8 bytes (forwards)
        ORRS    r3, r0, r1              ; result -> temp, to avoid corruption of r0/r1

; Instruction sequence (3): conditionally store a zero output value,
; for when input data is all 0.   Indexed by log2nchan>>1.
zero_store_TAB
; for log2nchan>>1 = 0 (i.e. 1, 2 channels)
        STREQ   r1, [r11, #-4]!         ; if 0, store out a zero and
; for log2nchan>>1 = 1 (i.e. 4, 8 channels)
        STREQ   r1, [r11], #4           ; if 0, store out a zero and

; Instruction sequence (4): conditionally branch back to
; start of loop if input data was all 0 for this sample.
zero_branch
        BEQ     .-(5*4)                 ; branch back to loop_head

; Instruction sequence (5): extract one byte out of 0 through 7 of the 1..8
; bytes picked up by instruction sequence (2), and put it into r3, testing
; for 0 as this is done.  One instruction word for each case.  Entries in
; this table are used starting from the (8-nchan)'th one, up to the required
; number of channels, hence the apparent oddity of the zero-data test
; instructions for 1,2 channels.  Note that the 1-channel case is slightly
; inefficient since we have already checked for all 1 byte being zero - if we
; hadn't done a LSL 24 in the process, we could dispense with this
; instruction, but that would be less regular so we just take the minor hit.
byte_ext_TAB
        ANDS    r3, r8, r0              ; byte 0
        ANDS    r3, r8, r0, LSR #8      ; byte 1
        ANDS    r3, r8, r0, LSR #16     ; byte 2
        ANDS    r3, r8, r0, LSR #24     ; byte 3 (could just be MOVS)
        ANDS    r3, r8, r1              ; byte 4
        ANDS    r3, r8, r1, LSR #8      ; byte 5
        ANDS    r3, r8, r1, LSR #16     ; byte 6
        ANDS    r3, r8, r1, LSR #24     ; byte 7 (could just be MOVS)

; Instruction sequence (6): load up linear value for mu-law byte, from
; table.  This always follows the extraction instruction (above) and is
; conditionalised on Z flag from ANDS, to allow faster execution on zero
; byte value (i.e. no load is actually done and r3 stays 0).  N.B.  As
; should be apparent from its definition, The table holds 16-bit values,
; arranged as +ve/-ve pairs, in words.  The access is indexed with LSL #1
; (i.e. 2-byte entries) but is performed as an LDR, so we get both -ve and
; +ve values, with the required one in the top half of r3, because of ARM's
; data rotation on non-word aligned LDRs.  The subsequent stereo position
; code extracts this value using ASR #n where n varies according to the
; required multiplicative factor for the particular stereo position.
; Within the table entries, each value is the basic 12-bit linear value,
; shifted left by 2, and sign-extended to 16-bits.  This leaves the bottom
; two bits 0, so that ASR #18, 17 or 16 then produces the original value
; times 1, 2 or 4 (respectively), sign extended to 32 bits.

conv_byte
        LDRNE   r3, [r9, r3, LSL #1]

; Instruction sequence (7): set or add linear value just loaded, in the
; correct proportions according to stereo position for channel, into stereo
; accumulators.  Some sequences are two instructions, others 3, so we store
; them here as 3 words each (for indexing during compilation) with the 3rd
; one 0 if not required.  The sequences come in pairs, the first of each
; pair being for the first channel, when the accumulators are initialised,
; and the second for subsequent channels, when the accumulators are added
; to.  This saves at least one instruction in the generated code, over
; pre-initialising both accumulators to 0, and more often than not, 2.

stereo_code
; 100% left
; code for first channel: r6 = (r3 >> 18) * 6 = (r3 >> 17) + (r3 >> 16)
        MOV     r6,     r3, ASR #17
        ADD     r6, r6, r3, ASR #16
        MOV     r7, #0                  ; init right acc to 0
; code for remaining channels
        ADD     r6, r6, r3, ASR #17
        ADD     r6, r6, r3, ASR #16
        DCD     0
; 83% left
; code for first channel: r6 = (r3 >> 18) * 5 = (r3 >> 16) + (r3 >> 18); r7 = r3 >> 18
        MOV     r6,     r3, ASR #16
        ADD     r6, r6, r3, ASR #18
        MOV     r7,     r3, ASR #18
; code for remaining channels
        ADD     r6, r6, r3, ASR #16
        ADD     r6, r6, r3, ASR #18
        ADD     r7, r7, r3, ASR #18
; 67% left
; code for first channel: r6 = (r3 >> 18) * 4 = r3 >> 16; r7 = (r3 >> 18) * 2 = r3 >> 17
        MOV     r6,     r3, ASR #16
        MOV     r7,     r3, ASR #17
        DCD     0
; code for remaining channels
        ADD     r6, r6, r3, ASR #16
        ADD     r7, r7, r3, ASR #17
        DCD     0

; Centre position.  Note that to avoid overflow problems we compute
; r3*1.5, then add r3 ASR #17 (== >> 18 then *2) to each accumulator.
; The multiplication by 1.5 is exact because we have 2 spare 0 bits at
; the bottom of the value.  Overflow from the multiplication in the
; lower half (when that is -ve, i.e. when the required value is +ve)
; does not interfere, since it may reach bit 16, but that gets shifted
; out.

; Code for first channel
        ADD     r3, r3, r3, ASR #1      ; * 1.5
        MOV     r6,     r3, ASR #17     ; == shifted right by 18, then * 2
        MOV     r7,     r3, ASR #17
; Code for remaining channels
        ADD     r3, r3, r3, ASR #1
        ADD     r6, r6, r3, ASR #17
        ADD     r7, r7, r3, ASR #17

; 67% right: the mirror of 67% left
; code for first channel
        MOV     r7,     r3, ASR #16
        MOV     r6,     r3, ASR #17
        DCD     0
; code for remaining channels
        ADD     r7, r7, r3, ASR #16
        ADD     r6, r6, r3, ASR #17
        DCD     0

; 83% right: mirror of 83% left
; code for first channel
        MOV     r7,     r3, ASR #16
        ADD     r7, r7, r3, ASR #18
        MOV     r6,     r3, ASR #18
; code for remaining channels
        ADD     r7, r7, r3, ASR #16
        ADD     r7, r7, r3, ASR #18
        ADD     r6, r6, r3, ASR #18

; 100% right: mirror of 100% left
; code for first channel
        MOV     r7,     r3, ASR #17
        ADD     r7, r7, r3, ASR #16
        MOV     r6, #0                  ; initialise left acc to 0
; code for remaining channels
        ADD     r7, r7, r3, ASR #17
        ADD     r7, r7, r3, ASR #16
        DCD     0

; Instruction sequence (8): scaling code, to convert accumulated values
; (32-bit) back into signed 16-bit numbers.  For 8 channels, the maximum
; absolute value in either accumulator is 6*3952*8 = 189696.  To convert
; this into the range 0..32767 requires multiplying by 32767/189696 =
; .1727342...  We approximate this by multiplying by 11/64 = .171875,
; achieved using ADDs/shifts for the *11 and ASR #6 for the /64.  Exactness
; is unimportant, since all the slightly low value introduces is a small
; gain reduction.  For 1, 2 or 4 channels, the maximum value reduces in
; proportion to the number of channels, so the code is the same except for
; the N in ASR #N which is 3,4,5,6 for 1,2,4,8 channels.

; Version 1.52 onwards: supports *soundgain giving 0 to +21dB additional
; gain, with 3dB increments, in mu-law to linear conversion.  This is
; achieved by using a multiplier of *11 and a divisor of 64 (ASR #6) to give
; 0dB for the 8-channel case, with reducing right shifts as channel count
; decreases or gain is increased in 6dB steps.  For the +3dB steps, don't do
; the mul by 11, but divide by 4 (ASR #2) for 8-channel case, to give
; effectively a +3dB increment, and again reduce the right shift constant or
; go to a left shift for reducing channel count or each extra +6dB gain.
;

; (8a): First the *11 code, the same for all configurations: this is inserted
; only when soundgain is even (i.e. 0dB, 6dB, 12dB, 18dB)
scale_mul_even
        ADD     r0, r6, r6, LSL #1      ; r6 * 3
        ADD     r6, r0, r6, LSL #3      ; + r6 * 8 = r6 * 11
        ADD     r0, r7, r7, LSL #1      ; r7 * 3
        ADD     r7, r0, r7, LSL #3      ; + r7 * 8 = r7 * 11

; (8b): gain scaling code, 2 instructions; table indexed by
;       7+log2nchan-soundgain DIV 2-(soundgain MOD 2 * 4).
scale_TAB                       ;       1ch     2ch     4ch     8ch
                                ;----------------------------------
        MOV     r6, r6, LSL #4  ;0      +21     -       -       -  GAIN (soundgain odd)
        MOV     r7, r7, LSL #4  ;       -       -       -       -  GAIN (soundgain even)

        MOV     r6, r6, LSL #3  ;1      +15     +21     -       -
        MOV     r7, r7, LSL #3  ;       -       -       -       -

        MOV     r6, r6, LSL #2  ;2      +9      +15     +21     -
        MOV     r7, r7, LSL #2  ;       -       -       -       -

        MOV     r6, r6, LSL #1  ;3      +3      +9      +15     +21
        MOV     r7, r7, LSL #1  ;       -       -       -       -

        DCD     0               ;4      -       +3      +9      +15
        DCD     0               ;       +18     -       -       -

        MOV     r6, r6, ASR #1  ;5      -       -       +3      +9
        MOV     r7, r7, ASR #1  ;       +12     +18     -       -

        MOV     r6, r6, ASR #2  ;6      -       -       -       +3
        MOV     r7, r7, ASR #2  ;       +6      +12     +18     -

        MOV     r6, r6, ASR #3  ;7      -       -       -       -
        MOV     r7, r7, ASR #3  ;       +0      +6      +12     +18

        MOV     r6, r6, ASR #4  ;8      -       -       -       -
        MOV     r7, r7, ASR #4  ;       -       +0      +6      +12

        MOV     r6, r6, ASR #5  ;9      -       -       -       -
        MOV     r7, r7, ASR #5  ;       -       -       +0      +6

        MOV     r6, r6, ASR #6  ;10      -       -       -       -
        MOV     r7, r7, ASR #6  ;       -       -       -       +0

; Instruction sequence (8c): do limiting (clipping) on output values:
; only used if soundgain > 0.
limit
        MOV     r0, r6, ASR #31         ; get r6 sign bit throughout r0
        CMP     r0, r6, ASR #15         ; check for overflow
        EORNE   r6, r0, r5              ; if so, get &00007FFF or &FFFF8000 in r6
        MOV     r0, r7, ASR #31         ; get r7 sign bit throughout r0
        CMP     r0, r7, ASR #15         ; check for overflow
        EORNE   r7, r0, r5              ; if so, get &00007FFF or &FFFF8000 in r7

; Instruction sequence (9): combine 2 x 16-bit values (sign-ext'd to
; 32-bits) from r6 and r7 into r6 ready for storing.  Same for all
; configurations.
combine
        MOV     r6, r6, LSL #16
        MOV     r7, r7, LSL #16
        ORR     r6, r6, r7, LSR #16

; Instruction sequence (10): store out the result: code for either
; direction (1 instruction each).  Index by log2nchan>>1.
store_sample
; for 1,2 channels
        STR     r6, [r11, #-4]!         ; backwards
; for 4,8 channels
        STR     r6, [r11], #4           ; forwards

; Instruction sequence (11): branch back to start of loop.  This
; instruction is adjusted in accordance with the total size of the loop
; code, which is dependent on both configuration (# channels) and also on
; individual stereo positions per channel.
loop_end
        B       .                       ; patched during compilation

; Defined maximum size of the conversion code.  This is:
;       size of sequence(1;2;3;4)         = 4 * (       (2 + 2 + 1 + 1)
; + 8 * size of sequence(5;6;7(max-size))        +  8 * (1 + 1 + 3)
; +     size of sequence(8a;8b;8c;9;10;11)       +      (4 + 2 + 6 + 3 + 1 + 1))

MAXLinConvCodeSize *  4 * ((2 + 2 + 1 + 1) + 8 * (1 + 1 + 3) + (4 + 2 + 6 + 3 + 1 + 1))


; Compile: generate a conversion routine appropriate to current configuration and
; stereo position settings.
; Entry conditions:
;   SVC mode, IRQs disabled (essential for atomic rewrite of code!)
; Parameters:
;   r0 = log2nchan, i.e. 0 -> 1 channel, 1 -> 2 chans, 2 -> 4 chans, 3 -> 8 chans
;   r1 = pointer to space for compiled routine, in module workspace
;   r2 = compacted array of stereo position values, 8x3 bits each (1-based)
;        in bits 0..23, with soundgain (0..7) in top byte.

compile
        STMFD   sp!, {r1,r3-r9,lr}      ; save r3-r9,pc', and code start address (r1) for later

        ; (1): loop head code (fixed, 2 instructions)
        ADR     r3, loop_head
        LDMIA   r3,  {r4,r5}
        STMIA   r1!, {r4, r5}
        ; (2): data load and zero check: 2 instructions, indexed by log2nchan
        ADR     r3, data_load_TAB
        ADD     r3, r3, r0, LSL #3      ; 8 bytes each
        LDMIA   r3,  {r4, r5}           ; get 2 instructions
        STMIA   r1!, {r4, r5}           ; store them
        ; (3): conditional zero-store
        ADR     r3, zero_store_TAB
        MOV     r4, r0, LSR #1          ; index by log2nchan>>1
        LDR     r4, [r3, r4, LSL #2]    ; 4 bytes each, get 1 instr
        STMIA   r1!, {r4}               ; store it
        ; (4): conditional branch back
        LDR     r4, zero_branch         ; get the instruction
        STMIA   r1!, {r4}               ; store it out

        ; preserve soundgain value, for later (r2 gets shifted in next loop)
        MOV     r7, r2, LSR #24         ;

        ; Now the per-channel code.  Get r9 as nchans, and use r8
        ; as loop variable from 0 to nchans-1.
        MOV     r9, #1
        MOV     r9, r9, LSL r0          ; get nchans in r9
        MOV     r8, #0                  ; start at channel 0
10
        ; (5): byte-extraction code, per channel
        ADR     r3, byte_ext_TAB+8*4
        SUB     r3, r3, r9, LSL #2      ; start from (8-nchan)th entry
        LDR     r4, [r3, r8, LSL #2]    ; get the instruction for this channel
        STMIA   r1!, {r4}               ; store it out
        ; (6): byte-conversion (1 instruction, fixed)
        LDR     r4, conv_byte           ; get it
        STMIA   r1!, {r4}               ; store it
        ; (7): stereo positioning: index by channel position, and by
        ; whether this is the first channel (channel 0) or not.
        ADR     r3, stereo_code
        AND     r4, r2, #7              ; get this channel's value
        MOV     r2, r2, LSR #3          ; shift remaining channels down
        SUB     r4, r4, #1              ; convert to 0-based value
        ADD     r4, r4, r4, LSL #1      ; * 24 (3 w/seq * 2 seq/pos * 4b/w), first *3...
        ADD     r3, r3, r4, LSL #3      ; then *8, to index table of sequences
        CMP     r8, #0                  ; if not on channel 0...
        ADDNE   r3, r3, #3*4            ;  skip on to second 3-word seq of pair
        LDMIA   r3, {r4,r5,r6}          ; pick up three words
        CMP     r6, #0                  ; check for last being 0 (unused)
        STMEQIA r1!, {r4,r5}            ; if so, store out 2 only
        STMNEIA r1!, {r4,r5,r6}         ; else store out all 3

        ; OK, done one channel's code.  Step on.
        ADD     r8, r8, #1
        CMP     r8, r9
        BLT     %BT10                   ; branch back if more channels to do

        ; (8): scaling code, in three parts.
        ; (8a): if soundgain is even, multiply by 11 (same for all modes) - 4 insts
        ;       note: r7 holds soundgain value from above
        TST     r7, #1
        ADREQ   r2, scale_mul_even
        LDMEQIA r2!, {r3,r4,r5,r6}
        STMEQIA r1!, {r3,r4,r5,r6}

        ; (8b): next perform scaling (shifting) as required, using
        ;  scale_TAB[7+log2nchan-soundgain DIV 2-(soundgain MOD 2 * 4)]

        ADR     r2, scale_TAB+7*2*4     ; address scale_TAB[7]
        SUB     r6, r0, r7, LSR #1      ; compute (log2nchan - soundgain DIV 2)
        SUBNE   r6, r6, #4              ; if soundgain odd, subtract 4 (c/c still valid)
        ADD     r2, r2, r6, LSL #3      ; then scale for 2 instructions/entry
        LDMIA   r2, {r4,r5}             ; get the 2 instructions
        CMP     r4, #0                  ; if first instr is not 0 (for NOP)...
        STMNEIA r1!, {r4,r5}            ; ...store them

        ; (8c) perform limiting on sample values if required (i.e. soundgain > 0)
        ADR     r2, limit
        CMP     r7, #0
        LDMNEIA r2,  {r3,r4,r5,r6,r7,r8}  ; 6 instructions (3/channel)
        STMNEIA r1!, {r3,r4,r5,r6,r7,r8}  ; store them

        ; (9): combining two samples into 1 word - 3 fixed instructions
        ADR     r3, combine
        LDMIA   r3, {r4,r5,r6}          ; get them
        STMIA   r1!, {r4,r5,r6}         ; store them

        ; (10): store out the sample, 1 instruction - 2 cases.
        ADR     r3, store_sample
        MOV     r4, r0, LSR #1          ; get log2nchan>>1
        LDR     r4, [r3, r4, LSL #2]    ; index table of single word instrs
        STMIA   r1!, {r4}               ; store it out

        ; (11): branch back to loop start code.  Need to compute offset here
        LDR     r4, loop_end            ; get the B . instruction (note: bits 23..3 are 1)
        LDMFD   sp!, {r0}               ; pop original code start (loop top)
  [ StrongARM
        STMFD   sp!,{r0-r2,lr}
        BL      Sound0synccode          ;SynchroniseCodeAreas, r0=start addr, r1 = end addr (inclusive)
        LDMFD   sp!,{r0-r2,lr}
  ]
        SUB     r0, r1, r0              ; work out offset from there to . now
        SUB     r4, r4, r0, LSR #2      ; subtract offset (in words) to get instr
        STMIA   r1!, {r4}               ; store it out and we're done!

        ; All done!
        LDMFD   sp!, {r3-r9,pc}         ; recover saved regs and go home
 ]


; Define RMA sound workspace now we know how big the A500 or mu-law-to-linear code is.

        ^       0

MessageFile_Block # 16
MessageFile_Open  #  4

 [ VIDC_Type = "VIDC20"
; 16-bit linear support data
SavedSample       #  4                  ; Preserved stereo value from end of last buffer, for
                                        ; 2:1 linear interpolation (if configured).
Lin16GenR0        #  4                  ; Value to be passed in R0 to ...
Lin16Gen          #  4                  ; User-supplied 16-bit sound generator(/mixer) code
NSR               #  4                  ; Total number of available sample frequencies
CurSRValue        #  4                  ; Current sample frequency in 1/1024 Hz units
CurSRIndex        #  4                  ; index into set of available frequencies
LinConvCode       #  MAXLinConvCodeSize ; Space for the dynamically-compiled mu-law to
                                        ; 16-bit-linear conversion code
 ]

 [ StorkPower
portable_present  # 4                   ;  = 0 if we don't think the Portable module is present
                                        ;  = 1 if we do
power_state       # 4                   ;
  [ AdvancedPower
PowerControl      # 4                   ;0..PowerContThres2 number of consecutive quiet buffers
PowerContThres1   * 2                   ;When PowerControl is >=2, both current & next buffers
                                        ; are quiet so allow amplifier to be powered down
                                        ; ie don't reject ServicePortable_PowerDown.
PowerContThres2   * 100                 ;Threshold at which the interrupt routine powers down
                                        ; the amplifier
  ]
SoundPowerBits  * PortableControl_SoundEnable
 ]

WorkSpaceSize     * @

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Audio_Code Entry

        BL      DecodeOnOrOff
        SWI     XSound_Enable
        EXIT

; .............................................................................

Speaker_Code ALTENTRY

        BL      DecodeOnOrOff
        SWI     XSound_Speaker
        EXIT

; .............................................................................
; Out   r0 = 1,2 (ON/OFF)
;       r12 = workspace pointer

DecodeOnOrOff ROUT

        LDR     r12, [r12]              ; Get workspace pointer for caller
        LDRB    r1, [r0], #1            ; Spaces skipped already
        CMP     r1, #"O"
        CMPNE   r1, #"o"
        BNE     Bad_Parameter_Error
        LDRB    r1, [r0], #1
        CMP     r1, #"N"
        CMPNE   r1, #"n"
        BNE     %FT50
        LDRB    r1, [r0], #1            ; Ensure no trailing crap
        CMP     r1, #" "
        BHI     Bad_Parameter_Error
        MOV     r0, #2                  ;  2 -> ON
        MOV     pc, lr                  ; flags irrelevant on *-command exit

50      CMP     r1, #"F"
        CMPNE   r1, #"f"
        BNE     Bad_Parameter_Error
        LDRB    r1, [r0], #1
        CMP     r1, #"F"
        CMPNE   r1, #"f"
        CMPNE   r1, #"."
        BNE     Bad_Parameter_Error

        LDRB    r1, [r0], #1            ; Ensure no trailing crap
        CMP     r1, #" "
        BHI     Bad_Parameter_Error
        MOV     r0, #1                  ;  1 -> OFF
        MOV     pc, lr                  ; flags irrelevant on *-command exit

Bad_Parameter_Error
        ADR     r0, ErrorBlock_BadSoundParameter

ReturnError ; For star commands

        BL      CopyError
        PullEnv
        RETURNVS

        MakeInternatErrorBlock BadSoundParameter,,M00

; .............................................................................

Stereo_Code ALTENTRY

        LDR     r12, [r12]              ; Get workspace pointer
        MOV     r1, r0
        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned
        BVS     Stereo_Channel_Error

        SUB     r14, r2, #1             ; Ensure in 1..SoundPhysChannels
        CMP     r14, #SoundPhysChannels
        BHS     Stereo_Channel_Error

        MOV     r4, r2                  ; preserve

10      LDRB    r3, [r1], #1            ; strip spaces
        CMP     r3, #" "
        BEQ     %BT10

        TEQ     r3, #"-"                ; signed?
        TEQNE   r3, #"+"
        SUBNE   r1, r1, #1              ; retrace our steps

        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned
        BVS     Stereo_Position_Error

        CMP     r2, #127
        BHI     Stereo_Position_Error

        TEQ     r3, #"-"                ; invert now if -ve
        RSBEQ   r2, r2, #0

        MOV     r0, r4                  ; channel no.
        MOV     r1, r2                  ; Position
        SWI     XSound_Stereo
        EXIT


Stereo_Channel_Error
        ADR     r0, ErrorBlock_BadSoundChannel
        B       ReturnError

        MakeInternatErrorBlock BadSoundChannel,,M01


Stereo_Position_Error
        ADR     r0, ErrorBlock_BadSoundStereo
        B       ReturnError

        MakeInternatErrorBlock BadSoundStereo,,M02

; .............................................................................

SoundSystem_Code
; In:   r0 = 0  => print syntax only
;       r0 = 1  => print current status
;       r0 > 1  => configure new value
;
        LDR     r12, [r12]

        Entry   "r1-r3"

        CMP     r0, #1
        BEQ     %FT10
        BCS     %FT20

        SWI     XOS_WriteS                      ; Print syntax only.
soundsystem_string
        DCB     "SoundSystem  ",0
        ALIGN
        SWI     XOS_WriteS
        DCB     "8bit | 16bit [Oversampled] | <D>",0
        SWIVC   XOS_NewLine
        EXIT

10
        MOV     r0, #161                        ; Print status so read CMOS.
        MOV     r1, #PrintSoundCMOS
        SWI     XOS_Byte
        ADRVC   r0, soundsystem_string
        SWIVC   XOS_Write0
        EXIT    VS

        TST     r2, #&60
        ADREQ   r0, parameter_8bit
        ADRNE   r0, parameter_16bit
        SWI     XOS_Write0
        EXIT    VS

        TST     r2, #&80
        BEQ     %FT15
        SWI     XOS_WriteI+" "
        ADRVC   r0, parameter_oversampled
        SWIVC   XOS_Write0
15
        SWIVC   XOS_NewLine
        EXIT

20
        MOV     r3, r0                          ; Save pointer to first parameter.

        ADR     r1, parameter_8bit
        BL      strcmp_advance
        BNE     %FT30

        BL      skip_spaces                     ; "8bit" given so can be no more parameters.
        MOVCC   r3, #0
        BCC     set_new_value

        MOV     r0, #3                          ; Too many parameters
        B       exit_error

30
        MOV     r0, r3
        ADR     r1, parameter_16bit
        BL      strcmp_advance
        BNE     %FT40

        BL      skip_spaces                     ; "16bit" given so check for second parameter.
        MOVCC   r3, #1                          ; None, so no oversample.
        BCC     set_new_value

        ADR     r1, parameter_oversampled       ; Must be "oversampled".
        BL      strcmp_advance
        MOVEQ   r3, #5
        BEQ     set_new_value

        MOV     r0, #0                          ; Bad configure option.
exit_error
        SETV
        EXIT

40
        MOV     r0, #10:OR:(1:SHL:31):OR:(1:SHL:29)     ; Read unsigned, limit range, check terminator.
        MOV     r1, r3
        MOV     r2, #7
        SWI     XOS_ReadUnsigned
        EXIT    VS

        MOV     r0, r1                          ; Make sure number is not followed by another parameter.
        BL      skip_spaces
        MOVCS   r0, #3
        BCS     exit_error

        MOV     r3, r2
set_new_value
        MOV     r0, #161                        ; Read current value.
        MOV     r1, #PrintSoundCMOS
        SWI     XOS_Byte

        BICVC   r2, r2, #7:SHL:5                ; Set new value.
        ORRVC   r2, r2, r3, LSL #5
        MOVVC   r0, #162
        SWIVC   XOS_Byte
        EXIT


parameter_8bit
        DCB     "8bit",0
parameter_16bit
        DCB     "16bit",0
parameter_oversampled
        DCB     "Oversampled",0
        ALIGN

strcmp_advance
; In:   r0 -> string 1 (space or control char terminated)
;       r1 -> string 2 (space or control char terminated)
; Out:  EQ => strings match (no case)
;       r0 -> terminator of string 1
;       OR
;       NE => strings do not match
;
        Entry   "r2"
10
        LDRB    r2, [r0], #1
        LDRB    lr, [r1], #1
        CMP     r2, #" "                ; If found both terminators then strings are equal.
        CMPLE   lr, #" "
        BLE     %FT20

        BIC     r2, r2, #1:SHL:5
        BIC     lr, lr, #1:SHL:5
        TEQ     r2, lr
        BEQ     %BT10
        EXIT                            ; Not same so exit NE.
20
        SUB     r0, r0, #1              ; Point to terminator.
        CMP     r0, r0                  ; Same so exit EQ.
        EXIT

skip_spaces
; In:   r0 -> string
; Out:  r0 -> first non-space in string
;       CC => control char found
;       CS => printable char found
;
        Entry
10
        LDRB    lr, [r0], #1
        CMP     lr, #" "
        BEQ     %BT10
        SUB     r0, r0, #1
        EXIT


; .............................................................................

SoundGain_Code  ALTENTRY

        LDR     r12, [r12]              ; Get workspace pointer

        MOV     r1, r0
        MOV     r0, #10 + (2_100 :SHL: 29) ; Fault bad terminators
        SWI     XOS_ReadUnsigned        ; complain if not a number or bad term
        BVS     Bad_Parameter_Error
        CMP     r2, #7                  ; if >7, complain about range
        BHI     SoundGain_Error
        LDR     r1, =SoundLevel0Base
        STRB    r2, [r1, #SoundGain]   ; else store out for compilation on next irq
        EXIT

SoundGain_Error
        ADR     r0, ErrorBlock_BadSoundGain
        B       ReturnError

        MakeInternatErrorBlock BadSoundGain,,M03

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module Data Structure and Constants
        OPT     OptPage

; DMA physical address pointer

; Prototype of part of Sound0Segment from Buff 0 .. Scheduler

ProtoS0S
        DCD     SoundDMABuffers                         ; Buff 0
        DCD     SoundDMABuffers + SoundDMABufferSize    ; Buff 1
; Config word, comprised of buffer length (16 bits), period (8 bits),
; log2nchan (3 bits), spare (1 bit), 16-bit flags (2 bits), spare (2 bits)
        DCW     SCBufferLen
        DCB     SCPeriod
        DCB     SCLogChannel                            ; Note: 16-bit flags are 0

        DCD     SoundSystemNIL                          ; channel handler
        DCB     &80, &80, &80, &80, &80, &80, &80, &80  ; Images (2 words worth)
        DCD     SoundSystemNIL                          ; scheduler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module SWI Interface
        OPT     OptPage

Sound_SWI_Code ROUT
        Push    R14
        WritePSRc I_bit :OR: SVC_mode, r14
        BL      Original_SWI_Code
        Pull    R14
        MOV     R10,#0
        MRS     R10,CPSR                ; NOP on pre-ARM6
        TST     R10,#2_11100            ; EQ if in 26-bit mode - C,V unaltered
        MOVNE   PC,R14                  ; 32-bit exit: NZ corrupted, CV passed back
        MOVVCS  PC,R14                  ; 26-bit exit: NZC preserved, V clear
        ORRVSS  PC,R14,#V_bit           ; 26-bit exit: NZC preserved, V set

Original_SWI_Code
        LDR     r10, =SoundLevel0Base
        CMP     r11, #(EndOfJumpTable-JumpTable)/4
        ADDCC   pc, pc, r11, LSL #2
        MOV     pc, lr

JumpTable
        B       Sound0Config            ; configuration
        B       Sound0Enable            ; enable control
        B       Sound0Stereo            ; stereo positioning
        B       Sound0Speaker           ; loudspeaker control
        B       Sound0Mode              ; mode control/status (16-bit/mu-law etc)
        B       Sound0LinearHandler     ; 16-bit sound generator interface
        B       Sound0SampleRate        ; new sample rate control interface
EndOfJumpTable

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0  = no. of channels (rounded up to power of two)
;       r1  = samples per buffer
;       r2  = uS per sample
;       r3  = Level1 Handler   (normally 0!)
;       r4  = Level2 Scheduler (normally 0!)
;       r10 = SoundLevel0Base
;       0 -> don't change!
;       IRQs disabled
;
; Constraints:
;              1 <= r0             <= 8
;             16 <= r1 * NChannels <= SoundDMASize
;  3 * NChannels <= r2 * NChannels <= 255

; Out   Return old r0,r1,r2,r3,r4

Sound0Config Entry

        Debug   swi,"Sound0Config",r0,r1,r2,r3,r4

        CMP     r0, #0                  ; r0 processing
        LDREQB  r0, [r10, #NChannels]
        ANDEQ   r0, r0, #3
        BEQ     %FT10

        SUB     r0, r0, #1              ; 1=>0, 2=>1 FOR LOGS!
        CMP     r0, #3
        MOVEQ   r0, #2                  ; 2,3 => 2
        MOVGT   r0, #3                  ; 4,5,6,7 => 3

10 ; MUST UPDATE STEREO POSITIONS

        Push    "r0-r3"
        LDRB    r3, [r10, #NChannels]
        STRB    r0, [r10, #NChannels]
        MOV     r2, #1
        MOV     r2, r2, LSL r0          ; number of channels

; for r0 = 1 to NChannels
        MOV     r0, #1
15      MOV     r1, #-128               ; read stereo pos
        SWI     XSound_Stereo           ; get previous
        SWI     XSound_Stereo           ; force set to new channels
        ADD     r0, r0, #1
        CMP     r0, r2
        BLE     %BT15                   ; loop for N active channels

        STRB    r3, [r10, #NChannels]
        Pull    "r0-r3"

        CMP     r1, #0                  ; r1 processing
        LDREQ   r1, [r10, #Config]      ; bottom 16 bits
        BIC     r1, r1, #&FF000000
        BIC     r1, r1, #&00FF0000
        BEQ     %FT20

        MOV     r1, r1, LSL r0          ; scale for NChannels of 8bit data
        CMP     r1, #SoundDMABufferSize ; can't be > buffer size
        MOVGT   r1, #SoundDMABufferSize
        MOV     r1, r1, LSR r0          ; back to per channel

 [ VIDC_Type = "VIDC20"
        LDRB    lr, [r10, #Flags]
        TST     lr, #Lin16Bits          ; doing 16bit sound?
        MOVEQ   r11, r0                 ; no, so check enough for 16bits of raw 8bit data
        BEQ     %FT19

        TST     lr, #OversampleFlag     ; yes, so limit no. samples to
        MOVEQ   r11, #2                 ; 4096/4=1024 if no o/s
        MOVNE   r11, #3                 ; 4096/8=512 if o/s
        MOV     lr, #SoundDMABufferSize
        CMP     r1, lr, LSR r11
        MOVGT   r1, lr, LSR r11
19
        MOV     lr, #32                 ; ensure enough 8bit/16bit samples for >= 32bytes of raw data
        CMP     r1, lr, LSR r11
        MOVLT   r1, lr, LSR r11
 ]
        Debug   swi,"per channel bufsz =",r1

20      CMP     r2, #0                  ; r2 processing
        LDREQB  r2, [r10, #Period]       ; if 0 then substitute current

        BL      WorkOutVIDCParams       ; but still go through update procedure

30      CMP     r3, #0                  ; r3 processing
        LDREQ   r3, [r10, #Level1Ptr]    ; old if 0

        CMP     r4, #0                  ; r4 processing
        LDREQ   r4, [r10, #Level2Ptr]    ; old if 0

40 ; merge into reg

        ORR     r11,  r1, r2, LSL #16
        ORR     r11, r11, r0, LSL #24

        LDR     r0, [r10, #Config]      ; Get return params
        AND     r1, r0, #&FC000000      ; extract current flags from nchan/flags byte
        ORR     r11, r11, r1            ; combine into new config value to store
        BIC     r1, r0, #&FF000000      ; mask out flags etc, leaving per-chan buflen
        BIC     r1, r1, #&00FF0000

        MOV     r2, r0, LSR #16
        AND     r2, r2, #&FF            ; current period value in r2

        ; produce channel count in r0, starting from config word in r0.
        MOV     r0, r0, LSR #24
        AND     r0, r0, #3
        ORR     r0, r0, #&01000000
        MOV     r0, r0, LSL r0          ; relies on LSL reg using only bits 7:0 of reg!
        MOV     r0, r0, LSR #24

        STR     r11, [r10, #Config]     ; store new buflen, period, log2nchan, flags

        LDR     r11, [r10, #Level1Ptr]  ; SSCB base
        STR     r3,  [r10, #Level1Ptr]  ; Install new Level1 handler
        MOV     r3,  r11                ; Return old

        LDR     r11, [r10, #Level2Ptr]  ; SSCB base
        STR     r4,  [r10, #Level2Ptr]  ; Install new Level2 handler
        MOV     r4,  r11                ; Return old

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       WorkOutVIDCParams - Compute VIDC SFR (and for VIDC20, SCR) value from
;       present configuration: no. of channels, sample period [and, with variable
;       sound clock, VIDCMultiplier].
;
; in:   r0 = log2(no of channels)
;       r1 = samples per buffer
;       r2 = desired sample period in microseconds, if < 256,
;  [    VIDCMultiplier holds VIDC clock rate DIV 4MHz ]
;       r10 = SoundLevel0Base
;
; out:  r2 = effective per-channel sample rate used (in microseconds)
;       VIDCSFR_N holds SFR value to program into VIDC
;       [ VIDCSCR_N holds value to program into VIDC20 SCR ]
;

WorkOutVIDCParams ROUT
 [ VIDC_Type = "VIDC20"                 ; new code for Risc PC etc
        Push    "r0,r1,r3,lr"

        Debug   swi,"WorkOutVIDCParams",r0,r1,r2

        LDRB    r0, [r10, #Flags]       ; check for what rates we can handle
        AND     r0, r0, #Lin16Bits      ; by reference to new CMOS sound bits, read on init
        CMP     r0, #L16_mulaw  ; check for old sound system
        BNE     %FT20

; L16_mulaw: no special sound clock support, and mu-law sound only: can only
; handle standard VIDC rates; work out VIDC programming parameters, taking
; number of channels into account.

        Debug   swi,"L16_mulaw"

        BICS    r0, r2, #&FF            ; see if number out of range 0..255
        MOVNE   r2, #&FF                ; if >=255 (or -ve) then use 255
        MOVMI   r2, #&03                ; if -ve then use 3
        LDR     r0, [sp, #0*4]          ; get log2(NChannels) back
        MOV     r3, r2, LSR r0          ; scale for NChannels
        CMP     r3, #&03                ; if < 3
        MOVLO   r3, #&03                ; then use 3
        MOV     r2, r3, LSL r0          ; compute inter-sample period for one channel
        MOV     r1, #&05                ; program SCR for internal clock, mu-law DAC sound
        ; work out sample frequency from per-channel usec period in r2
        STMFD   sp!, {r1,r2}            ; save regs corrupted by Divide
        LDR     r1, =1024*1000*1000     ; calculate 1,024,000,000/usec
        MOV     r0, r2                  ; to get Hz/1024
        BL      Divide
        MOV     r0, r2                  ; put result into r0
        LDMFD   sp!, {r1,r2}            ; recover other values
        MOV     lr, #0                  ; non-sensible SampleRate index (irrelevant anyway!)
        B       %FT98                   ; go set up

20

; 16-bit output hardware in place: must use one of the subset of sample rates
; supported in this configuration.  This is effectively only rates which can
; be used in 4-channel mode, i.e. with period a multiple of 4usec, and in fact
; below 40usec (25kHz), just 8-channel-capable (N*8usec) rates, to allow for 2x
; oversampling.  Scan the appropriate subset of the tabulated frequencies,
; looking for a suitable match.

        Debug   swi,"16bit output"

        Push    "r4,r5,r6,r7,r8"
        MOV     r0, r0, LSR #Lin16Shift ; reduce mode to 1..3 range (0 accounted for above)
        ADRL    r1, mtab-1              ; address map table (0th entry)
        LDRB    r0, [r1, r0]            ; pick up map offset for mode
        ADD     r0, r1, r0              ; convert to address of relevant map, -1
        LDRB    r5, [r0, #1]!           ; get index range (entry 0 in map)
        ADR     r4, ftab-8              ; address 0th entry of main freq info table
        MOV     lr, #1                  ; start with entry 1 in map
22      LDRB    r6, [r0, lr]            ; get index into main freq table
        ADD     r1, r4, r6, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period

        SUBS    r7, r3, r2              ; place (entry - freq) in r7
        BEQ     %FT26                   ; if =, go do it
        BPL     %FT24                   ; else if freq > entry, then look at next entry

                                        ; here, freq < entry, so test for closest match ie

                                        ;      (last_entry > freq < this_entry)

        CMP     lr, #1                  ; accept if at start of table
        BEQ     %FT26
        SUB     lr, lr, #1              ; otherwise back up to previous entry
        LDRB    r6, [r0, lr]            ; get index into main freq table
        ADD     r1, r4, r6, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period

        SUB     r8, r2, r3              ; place (freq - entry) in r8

        CMP     r7, r8                  ; if r7 < r8 (they're negative) then we have best
        BLT     %FT26                   ; match so accept the current entry

        ADD     lr, lr, #1              ; otherwise go back up to next entry
        LDRB    r6, [r0, lr]            ; get index into main freq table
        ADD     r1, r4, r6, LSL #3      ; address entry in table
        LDRB    r3, [r1, #4]            ; pick up nominal period
        B       %FT26                   ; and accept it


24      CMP     lr, r5                  ; if at end of list, accept this one
        BEQ     %FT26
        ADD     lr, lr, #1
        B       %BT22

26      LDRB    r2, [r1, #4]            ; pick up period to report back to user
        LDRB    r3, [r1, #5]            ; pick up unadjusted SFR value
        LDR     r0, [r1, #0]            ; get frequency value
        LDRB    r1, [r1, #6]            ; and SCR value
        Pull    "r4,r5,r6,r7,r8"
        ; and drop into final code

; Store computed values and exit:
; lr is sample rate index
; r3 is VIDC SFR to program, unadjusted, assuming no oversampling
; r2 is user-visible per-channel period,
; r1 is value for scr
; r0 is sample frequency in Hz/1024
98
        Debug   swi,"computed values are",r0,r1,r2,r3

        STRB    r1, [r10, #VIDCSCR_N]   ; store new SCR value
        LDR     r1, [r10, #SoundRMA]
        STR     r0, [r1, #CurSRValue]   ; and frequency
        STR     lr, [r1, #CurSRIndex]   ; and index of frequency
        LDRB    r0, [r10, #Flags]
        LDR     r1, [sp, #4]            ; get back current/new samples per buffer
        BL      process_oversample      ; go set up to do oversampling iff we can
        STRB    r0, [r10, #Flags]       ; store back possibly updated flags
        STRB    r3, [r10, #VIDCSFR_N]   ; store for prog'ing under IRQ
        Pull    "r0,r1,r3,pc"           ; pop log2nchan, old r1, old r3, return PC

; process_oversample
; in:  r0 = flags value
;      r1 = samples per buffer
;      r2 = user-visible period
;      r3 = unadjusted SFR value, for non-oversampling case
;      r10 = SoundLevel0Base
; out: r0 = new flags value reflecting oversampling state
;      r1 unchanged
;      r2 unchanged
;      r3 = unadjusted SFR for normal or oversampling as required
process_oversample Entry "r1,r2"
        Debug   swi,"process_oversample, default off"
        BIC     r0, r0, #DoOversample   ; clear out o/s active flag, assuming not possible
        AND     lr, r0, #Lin16Bits      ; check that...
        CMP     lr, #L16_mulaw          ;  (not in mu-law mode
        CMPNE   lr, #L16_master         ;   && not in master mode
        TSTNE   r0, #OversampleFlag     ;   && auto oversample flag is set)
        EXIT    EQ                      ; else return - can't oversample
        CMP     r2, #MinOSPeriod        ; check sample period value against oversample limit
        EXIT    LT                      ; if too small (f too high), can't oversample
        TST     r3, #1                  ; is final period odd?
        EXIT    NE                      ; can't oversample if so
        ; check buffer size: may be too big to handle double-length (4KB max)
        CMP     r1, #SoundDMABufferSize/8 ; check against size limit at Fs*2
        EXIT    HI                      ; don't oversample if gets too big
        ; OK, set up for oversampling....
        Debug   swi,"oversampling on"
        MOV     r3, r3, LSR #1          ; divide final period by 2 to generate Fs*2.
        ORR     r0, r0, #DoOversample   ; and inform IRQ level through flags
        EXIT

 | ; Non-VIDC20 machine

        Push    "r0-r1,lr"

        BICS    r0, r2, #&FF            ; see if number out of range 0..255
        MOVNE   r2, #&FF                ; if >=255 (or -ve) then use 255
        MOVMI   r2, #&03                ; if -ve then use 3

 [ VarSndClock
        LDRB    r0, [r10, #VIDCMultiplier]
        MUL     r0, r2, r0              ; scale for VIDC clock rate
        MOV     r1, #6                  ; divide by nominal value (24MHz)
        BL      Divide
 ]
        LDR     r0, [sp, #0*4]          ; get log2(NChannels) back
        MOV     r2, r2, LSR r0          ; scale for NChannels
        CMP     r2, #&FF                ; if > 255
        MOVHI   r2, #&FF                ; then use 255
        CMP     r2, #&03                ; if < 3
        MOVLO   r2, #&03                ; then use 3

; now update the required VIDCSFR to be this value

        STRB    r1, [r10, #VIDCSFR_N]   ; record the value for prog'ing
        MOV     r2, r2, LSL r0          ; compute inter-sample period for one channel

 [ VarSndClock
; now need to reverse engineer the real period, depending on sound clock
        MOV     r0, #6                  ; work out (n*6)/vm
        MUL     r0, r2, r0
        LDRB    r1, [r10, #VIDCMultiplier]
        TEQ     r1, #0                  ; watch out for divide by zero
        MOVEQ   r1, #6
        BL      Divide
 ]

        Pull    "r0-r1,pc"
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = 0 -> leave (and return previous)
;            1 -> OFF
;          >=2 -> ON
;       r10 = SoundLevel0Base
;       IRQs disabled

; Out   r0 = previous enable state

Sound0Enable Entry "r1"

        LDR     r11, [r10, #Semaphore]
        TST     r11, #&80000000
        MOVEQ   r11, #2                 ; return ON
        MOVNE   r11, #1                 ; or OFF

        CMP     r0, #1
        BLT     %FT20                   ; [just return value]
        BGT     %FT10

; Turn OFF

 [ MEMC_Type = "IOMD"
        MOV     r0, #IOMD_Base          ; Address IOMD

        LDRB    r1, [r0, #IOMD_SD0CR]   ; Get Sound 0 Control reg
        BIC     r1, r1, #IOMD_DMA_E_Bit ; Clear the Enable bit (i.e. disable it)
        STRB    r1, [r0, #IOMD_SD0CR]
        LDRB    r1, [r0, #IOMD_DMAMSK]  ; Also disable IRQ from sound0 DMA channel
        BIC     r1, r1, #IOMD_DMA_SD0
        STRB    r1, [r0, #IOMD_DMAMSK]
05
 |
  [ MEMC_Type = "MEMC2"
        LDR     r0, =MEMC2Address+MEMC2_SATT
        MOV     r1, #(0*SATT_sdis + 0*SATT_senb + 1*SATT_srnw + 1*SATT_smsks + 0*SATT_smskf)
        STR     r1, [r0]                ; Disable Sound DMA
  |
    ASSERT MEMC_Type = "MEMC1" :LOR: MEMC_Type = "MEMC1a"
        MOV     r0, #&00000000          ; Disable Sound DMA
        MOV     r1, #&00000800
        SWI     XOS_UpdateMEMC
  ]
  ; IOC assumed if MEMC_Type != "IOMD"
        MOV     r12, #IOC
        LDRB    r14, [r12, #IOCIRQMSKB] ; Disable Sound IRQ
  [ IO_Type = "IOEB"
        BIC     r14, r14, #IOEB_sound_IRQ_bit
  |
        BIC     r14, r14, #sound_IRQ_bit
  ]
        STRB    r14, [r12, #IOCIRQMSKB]
 ]

        MOV     r14, #&80000000         ; Set semaphore
        STR     r14, [r10, #Semaphore]
 [ StorkPower
        BL      SetPower_Off            ; save power, ensure amplifiers are off (corrupts R0)
 ]
        B       %FT20


10 ; Turn ON - turning on when already damages sample rate!

        CMP     r11, #2                 ; Exit if turning on when already on
        BEQ     %FT20                   ; This is the proper place to fix
                                        ; the bug, not at the *Audio level!

15      MOV     r14, #0                 ; Clear semaphore. Common ep
        STR     r14, [r10, #Semaphore]

 [ StorkPower
  [ AdvancedPower
        LDR     r0, [r10, #SoundRMA]
        LDR     r0, [r0, #PowerControl]
        CMP     r0, #PowerContThres1    ; if both buffers are silent, no need to power up the amplifiers
        BLLT    SetPower_On             ; but if not... power up now (corrupts R0)
  |
        BL      SetPower_On             ; Power up now (corrupts R0)
  ]
 ]

 [ MEMC_Type = "IOMD"
        MOV     r12, #IOMD_Base
        ; reset the channel and enable it (starts DMA on buffer A once prog'ed)
        MOV     r0, #1*IOMD_DMA_E_Bit :OR: 1*IOMD_DMA_C_Bit :OR: 0*IOMD_DMA_D_Bit :OR: 16
        STR     r0, [r12, #IOMD_SD0CR]
        LDR     r0, [r10, #Phys0]       ; set current pointer = buffer base
        STR     r0, [r12, #IOMD_SD0CURA]
        LDR     r0, [r12, #IOMD_SD0ENDA] ; pick up previous end mask value (already programmed)
        STR     r0, [r12, #IOMD_SD0ENDA] ; re-write, to start DMA
 |
  [ MEMC_Type = "MEMC2"
        LDR     r0, [r10, #Phys0]
        MOV     r1, r0, LSR #16         ; get lo 16 bits
        EOR     r0, r0, r1, LSL #16     ; get hi 16 bits

        LDR     lr, =MEMC2Address+MEMC2_SSTRT
        STMIA   lr, {r0, r1}           ; write SSTRT
        ADD     lr, lr, #MEMC2_SCUR-MEMC2_SSTRT
        STMIA   lr, {r0, r1}           ; write SCUR

        MOV     r0, #(0*SATT_sdis + 1*SATT_senb + 1*SATT_srnw + 1*SATT_smsks + 0*SATT_smskf)
        STR     r0, [lr, #MEMC2_SATT-MEMC2_SCUR]  ; Enable Sound DMA
  |
    ASSERT MEMC_Type = "MEMC1" :LOR: MEMC_Type = "MEMC1a"
        LDR     r0, [r10, #Phys0]
        MOV     r0, r0, LSR #2
        ORR     r0, r0, #&03680000
        ORR     r1, r0, #&000C0000
        STR     r0, [r0]                ; Write DAG start
        STR     r1, [r1]                ; Write DAG ptr

        MOV     r0, #&00000800          ; Enable Sound DMA
        MOV     r1, #&00000800
        SWI     XOS_UpdateMEMC
  ]
 ]

 [ MEMC_Type = "IOMD"
        ; r12 already contains IOMD_Base
        LDRB    r1, [r12, #IOMD_DMAMSK] ; Enable IRQ from sound0 DMA channel
        ORR     r1, r1, #IOMD_DMA_SD0
        STRB    r1, [r12, #IOMD_DMAMSK]
 |
        MOV     r12, #IOC
        LDRB    r14, [r12, #IOCIRQMSKB] ; Enable Sound IRQ
  [ IO_Type="IOEB"
        ORR     r14, r14, #IOEB_sound_IRQ_bit
  |
        ORR     r14, r14, #sound_IRQ_bit
  ]
        STRB    r14, [r12, #IOCIRQMSKB]
 ]

20      MOV     r0, r11                 ; Return previous enable state
        EXIT                            ; Restores ints to caller state, maybe
                                        ; get IRQ'ed here too.

; .............................................................................
; Called at RESET time
; in: r10 = SoundLevel0Base

Sound0Reenable ALTENTRY

        LDR     r11, [r10, #Semaphore]
        TST     r11, #&80000000
        EXIT    NE                      ; was OFF, stays OFF

        B       %BT15                   ; Turn it on again

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = 0 -> leave (and return previous)
;            1 -> OFF
;          >=2 -> ON
;       r10 = SoundLevel0Base
;       IRQs disabled

; Out   r0 = previous speaker state

Sound0Speaker ROUT

 [ SpkrControl
        MOV     r12, #0
        LDRB    r10, [r12, #IOCControlSoftCopy]
        TST     r10, #2_00100000        ; check output bit
        MOVEQ   r11, #2                 ; return ON
        MOVNE   r11, #1                 ;     or OFF
        BIC     r10, r10, #2_00100000
        CMP     r0, #1
        ORREQ   r10, r10, #2_00100000
        STRHSB  r10, [r12, #IOCControlSoftCopy]
        MOVHS   r12, #IOC
        STRHSB  r10, [r12, #IOCControl]

        MOV     r0, r11                 ; Return previous speaker state
 |
        MOV     r0, #2                  ; if no speaker control hardware, report ON
 ]
        MOV     pc, lr                  ; no need to preserve flags (we have a wrapper)

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0  = channel number (1-8)
;       r1  = -127 for left, 0 centre, 127 right (-128 DON'T CHANGE)
;       r10 = SoundLevel0Base
;       IRQs disabled

; Attempts to be slightly clever...
; programs at interleave factor from r0 upwards...
; note pipeline delay on NChannels...!

; Out   r0 preserved
;       r1 is stereo position allocated (-128 for none/invalid)
;       -128 indicates invalid channel

Sound0Stereo Entry "r0, r2"

        SUB     r0, r0, #1              ; 1..8 -> 0..7
        CMP     r0, #SoundPhysChannels
        MOVHS   r1, #-128
        EXIT    HS

        ADD     r2, r1, #&80            ; add new offset
        LDRB    r14, [r10, #NChannels]
        AND     r14, r14, #3            ; get rid of extra flag bits
        MOV     r11, #1
        MOV     r14, r11, LSL r14       ; convert log

        ADD     r12, r10, #Images
        LDRB    r1, [r12, r0]           ; current pos
        SUB     r1, r1, #&80            ; map back to -127..+127

        CMP     r2, #0
        CMPNE   r2, #&100               ; force range
        EXIT    HS

        ADD     r11, r12, #8            ; end
        ADD     r12, r12, r0            ; base channel
05      STRB    r2, [r12], r14          ; store new pos
        CMP     r12, r11
        BLT     %BT05

        ADD     r0, r10, #Images        ; address full-size image set
        BL      ConvImages              ; produce compacted form...
        STR     r0, [r10, #ImagesC_N]   ; for programming on appropriate IRQ
        EXIT                            ; go back to caller

 [ VIDC_Type = "VIDC20"

; Sound0Mode - implements Sound_Mode SWI
;
; In:
;
;   R0: function code
;     = 0: read current mode, returning information in r0/r1.  This code must
;          be used first, to determine the availability of other functions.
;     = 1: set/clear oversampling mode, returning previous state (0 or 1)
;          R1 = 0: disable linear 2x oversampling
;          R1 <> 0: enable linear 2x oversampling
;     = 2: (NOT YET IMPLEMENTED) set external sound clock handler
;          function (for format/status value 3)
;          R1 = external sound clock handler address, or 0 to cancel
;     = 3: set/clear mono flag, returning previous state (0 or 1)
;	   R1 = 0: stereo mode
;	   R1 <> 0: mono mode (convert stereo to mono for output)
;     other function code values not defined
;
;   R10 = SoundLevel0Base
;   IRQs disabled
;
; Out:
;  For function code 0:
;       R0      = 0: mu-law sound system only; SWIs Sound_LinearHandler and
;                    Sound_SampleRate, and all other functions of Sound_Mode, are
;                    not supported.  Contents of r1 are unchanged.
;       R0      = 1: 16-bit capable sound system: SWIs Sound_LinearHandler and
;                    Sound_SampleRate, and full Sound_Mode functionality are all
;                    available.
;
;       R1[3:0]: sound output format and clock control status (from CMOS RAM)
;               = 1: 16-bit linear output, 44k1, 22k05, 11k025 and selected original rates
;               = 2: 16-bit linear output, internal clock, selected original rates only
;               = 3: 16-bit linear output, external master clock source, custom rates only
;               = 4...15: reserved values
;       R1[4]: oversampling control
;               = 0: automatic linear 2x oversampling disabled
;               = 1: automatic linear 2x oversampling enabled
;       R1[5]   = 0: stereo output
;		= 1: mono conversion on output
;       R1[31:5]: reserved for expansion
;
; For all rates <= 25kHz, if auto-oversampling is on, the output data stream
; will be oversampled by 2x, by simple linear interpolation.
;
Sound0Mode      Entry   "r2"
        LDRB    r2, [r10, #Flags]
        AND     lr, r2, #Lin16Bits      ; if configured for mu-law, return 0 in r0 and r1
        CMP     lr, #L16_mulaw
        MOVEQ   r0, #0
        MOVEQ   r1, #0
        EXIT    EQ

        CMP     r0, #0
        BNE     %FT10
; Function code 0: read mode information
        MOV     r0, #1                  ; new system, 16-bit
        MOV     r1, lr, LSR #Lin16Shift ; get mode (1..3) in right place
        TST     r2, #OversampleFlag     ; check for oversampling
        ORRNE   r1, r1, #1 :SHL: 4      ; set flag if so
        TST	r2, #DoMono		; check for mono mode
        ORRNE	r1, r1, #1 :SHL: 5	; set flag if enabled
        EXIT

10      CMP     r0, #1
        BNE     %FT20
; Function code 1: enable/disable automatic oversampling (allows overriding CMOS value)
        LDR     r0, [r10, #Config]
        MOV     r2, r0, LSR #24
        MOV     lr, r2                  ; preserve original value
        BIC     r2, r2, #OversampleFlag ; clear o/s bit, but NOT DoOversample for now
        CMP     r1, #0                  ; check requested state
        ORRNE   r2, r2, #OversampleFlag ; set bit if required
        ANDS    r1, lr, #OversampleFlag ; get old state of flag into r1 (wrong bit pos)
        MOVNE   r1, #1                  ; if not zero, set 1, else 0 already there...
        ; Need to fix up for oversampling if now enabled.
        Push    "r1,r3"
        MOV     r1, r0, LSL #16         ; r1 = samples per buffer
        MOV     r1, r1, LSR #16
        MOV     r0, r2                  ; r0 = new flags
        LDRB    r2, [r10, #Period]      ; and user-visible sample period into r2
        LDRB    r3, [r10, #VIDCSFR_N]   ; pick up current SFR into r3
        TST     lr, #DoOversample       ; check whether O/S was in use before
        MOVNE   r3, r3, LSL #1          ; double the period if so, to give non-O/S period
        BL      process_oversample      ; determine whether to use o/s
        STRB    r0, [r10, #Flags]       ; store final flags
        STRB    r3, [r10, #VIDCSFR_N]   ; and store SFR
        Pull    "r1,r3"
        MOV     r0, #1
        EXIT

20      CMP     r0, #2
        BNE     %FT30
; FUNCTION CODE 2: NOT YET IMPLEMENTED!
	B	%FT99
30	CMP	r0, #3
	BNE	%FT40
; Function code 3: enable/disable mono-isation (allows overriding CMOS value)
        LDRB    r2, [r10, #Flags]	; get flags byte
        MOV     lr, r2                  ; preserve original value
        CMP     r1, #0                  ; check requested state
        ORRNE   r2, r2, #DoMono         ; set bit if enabling mono conversion
        BICEQ   r2, r2, #DoMono         ; or clear bit if disabling it
        ANDS    r1, lr, #DoMono         ; get old state of flag into r1 (wrong bit pos)
        MOVNE   r1, #1                  ; if not zero, set 1, else 0 already there...
        STRB    r2, [r10, #Flags]       ; store out new flag value
        EXIT
40
99
        EXIT


; Sound0LinearHandler: implements Sound_LinearHandler SWI.
;
; In: (r0-r2 from user SWI)
;  r0 is function code:
;    r0 = 0: return current handler as {routine, param} pair in r1, r2
;         no side effects, all regs except r1, r2 preserved
;         a null handler is recorded as a routine address of 0, param of -1
;    r0 = 1: install new handler
;         r1 =  0: set null handler (initial, default state), r2 is ignored
;         r1 != 0: set r1 as routine to call, r2 as parameter value to pass
;                  to it in r0, with following call rules:
;               r0 = value specified on installation of routine (r2 here)
;               r1 = base of word-aligned buffer, to fill with 16-bit stereo
;                    data, stored as pairs of signed (2's complement) 16-bit
;                    values; each word has bits 31:16 left channel data, bits
;                    15:0 right channel data.
;               r2 = end of buffer (address of first word beyond buffer)
;               r3 = flag for initial buffer contents:
;                    0 => data in buffer is invalid and MUST be overwritten
;                    1 => data has been converted from N-channel mu-law sound
;                         system and may be either overwritten or (preferably)
;                         mixed with new data produced by routine.
;                    2 => data in buffer is all 0: if routine would generate
;                         silent output, it may simply return.
;               r4 = sample frequency at which data will be played, in Hz/1024
;                    (e.g. for 20kHz, r4 would be 20000*1024 = 20480000).
;    else (r0 = any other value): ignored (do nothing, not even error...)
;
;  r1 = as determined by value in r0
;  r2 = as determined by value in r0
;
;  r10 = SoundLevel0Base (set up locally)
;
;  IRQs are disabled
;
; Out:
;  r0 preserved
;  r1 = previous/current routine address
;  r2 = previous/current value to pass to routine
;
Sound0LinearHandler Entry "r3,r4,r5"
        LDRB    r3, [r10, #Flags]
        TST     r3, #Lin16Bits
        MOVEQ   r1, #0
        MOVEQ   r2, #0
        EXIT    EQ

        LDR     r3, [r10, #SoundRMA]
        LDR     r4, [r3, #Lin16Gen]
        LDR     r5, [r3, #Lin16GenR0]
        CMP     r0, #1
        BHI     %FT10
        STREQ   r1, [r3, #Lin16Gen]     ; if r0 = 1, store new value for routine
        STREQ   r2, [r3, #Lin16GenR0]   ;            and new value for r0 param to routine
        MOVS    r1, r4                  ; set previous routine address in r1
        MOVNE   r2, r5                  ; if not null, put param to pass into r2
        MVNEQ   r2, #0                  ; else set -1 into r2
10
        EXIT                            ; and go home


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Sound0SampleRate: implements Sound_SampleRate SWI.  This SWI is only
; useable when SoundDevice is configured non-0, i.e. when there is 16-bit sound output
; hardware.  Otherwise it returns 0 in r1 and r2 for all calls.
;
; In: (r0,r1 from user SWI)
;   r0 is function code:
;      0: return in r1 the total number of available sample rates, NSR.
;         Available sample rates are indexed by numbers in the range 1..NSR,
;         and increase with increasing index number.  R2 is preserved.
;      1: return in r1 the index of the current sample rate, and in r2
;         the current sample rate, measured in units of 1/1024 Hz, e.g.
;         20kHz would be 20480000;
;      2: return in r2, as value measured in 1/1024ths of Hz, the sample
;         rate defined by index given in r1 (in range 1..NSR).
;      3: select new sample rate via index in r1, in range 1..NSR; return
;         index and value of previous rate in r1 and r2 respectively.
;
;   r1 = as determined by value in r0.
;   r2 = as determined by value in r0.
;
;  r10 = SoundLevel0Base (set up locally, not from SWI)
;
;  IRQs disabled
;
; Out:
;   r0 preserved
;   r1 = index of previous/current rate, or NSR;
;   r2 = previous/current/rate, measured in 1/1024ths of Hz, or preserved (r0 = 0)
;
;
; Combined set of "selected original rates" and CD-derived rates is:
;
;  1  1   5kHz     (200usec)
;  2  2   6.25kHz  (160usec)
;  3  3   6.944kHz (144usec)
;  4  4   7.812kHz (128usec)
;  5  5   8.928kHz (112usec)
;  6  6  10.417kHz (96usec)
;     7  11.025kHz (~91 usec)  CD/4
;  7  8  11.364kHz (88usec)
;  8  9  12.5kHz   (80usec)
;  9 10  13.889kHz (72usec)
; 10 11  15.625kHz (64usec)
; 11 12  17.857kHz (56usec)
; 12 13  20.833kHz (48usec)
;    14  22.05kHz  (~45 usec)  CD/2
; 13 15  25kHz     (40usec)
; 14 16  27.778kHz (36usec)
; 15 17  31.25kHz  (32usec)
; 16 18  35.714kHz (28usec)
; 17 19  41.667kHz (24usec)
;    20  44.1kHz   (~23 usec)  CD/1
; 18 21  50kHz     (20usec)

        MACRO
$lab    vidcf   $per                    ; Original VIDC sample rate, defined by usec period
$lab    DCD     1000000*1024/$per       ; frequency derived from period
        DCB     $per                    ; period for use in Sound_Configure
        DCB     $per/4                  ; unadjusted value for SFR (no oversampling)
        DCB     3                       ; value for SCR: serial sound, int clk
        DCB     0                       ; padding so total is 8 bytes
        MEND

        MACRO
$lab    cdf     $freq, $per             ; CD-derived rate ($freq in Hz, since all integral)
$lab    DCD     $freq*1024              ; frequency value as reported by Sound_SampleRate
        DCB     $per                    ; period as reported via Sound_Configure
        DCB     4*44100/$freq           ; unadjusted value for SFR (no oversampling)
        DCB     2                       ; value for VIDC20 SCR: serial sound, ext sclk
        DCB     0                       ; padding so total is 8 bytes
        MEND

ftab    vidcf   200                     ; 1   5kHz     (200 usec)
        vidcf   160                     ; 2   6.25kHz  (160usec)
        vidcf   144                     ; 3   6.944kHz (144usec)
        vidcf   128                     ; 4   7.812kHz (128usec)
        vidcf   112                     ; 5   8.928kHz (112usec)
        vidcf   96                      ; 6  10.417kHz (96usec)
        cdf     11025, 91               ; 7  11.025kHz (~91 usec) CD/4
        vidcf   88                      ; 8  11.364kHz (88usec)
        vidcf   80                      ; 9  12.5kHz   (80usec)
        vidcf   72                      ;10  13.889kHz (72usec)
        vidcf   64                      ;11  15.625kHz (64usec)
        vidcf   56                      ;12  17.857kHz (56usec)
        vidcf   48                      ;13  20.833kHz (48usec)
        cdf     22050, 45               ;14  22.05kHz  (~45 usec) CD/2
        vidcf   40                      ;15  25kHz     (40usec)
        vidcf   36                      ;16  27.778kHz (36usec)
        vidcf   32                      ;17  31.25kHz  (32usec)
        vidcf   28                      ;18  35.714kHz (28usec)
        vidcf   24                      ;19  41.667kHz (24usec)
        cdf     44100, 23               ;20  44.1kHz   (~23 usec) CD/1
        vidcf   20                      ;21  50kHz     (20usec)

; NSR values for different sound modes.
nnsr    DCB     21, 18, 1

; map sound mode numbers onto tables of valid frequencies out of full ftab set
; mtab must be close to, but at a lower address than, the maps...
mtab    DCB     mapboth-mtab            ; L16_slave44k
        DCB     mapvidc-mtab            ; L16_slaveInt
        DCB     mapcd  -mtab            ; L16_master

mapboth DCB     21
        DCB     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21
mapvidc DCB     18
        DCB     1, 2, 3, 4, 5, 6,    8, 9, 10, 11, 12, 13,     15, 16, 17, 18, 19,     21
mapcd   DCB     1
        DCB                                                                        20

        ALIGN

Sound0SampleRate Entry "r3,r4"
        LDRB    r3, [r10, #Flags]
        AND     r3, r3, #Lin16Bits
        CMP     r3, #L16_mulaw          ; if in old sound world (not 16-bit), return 0s always
        MOVEQ   r1, #0
        MOVEQ   r2, #0
        EXIT    EQ

        MOV     r3, r3, LSR #Lin16Shift ; get sound mode bits at bottom of r3, so 1..3
        CMP     r0, #0                  ; check function code
        BNE     %FT10

; Function code 0: read NSR (as configured at module init or via clock handler)
        LDR     r1, [r10, #SoundRMA]
        LDR     r1, [r1, #NSR]
        EXIT

10      CMP     r0, #1
        BNE     %FT20
; Function code 1: read current sample rate index and sample rate
        LDR     r1, [r10, #SoundRMA]
        LDR     r2, [r1, #CurSRValue]
        LDR     r1, [r1, #CurSRIndex]
        EXIT

20      CMP     r0, #2
        BNE     %FT30
; Function code 2: return in r2 the sample rate for specified index in r1
        BL      SR_maptab               ; go get address of freq table entry
        CMP     r2, #0                  ; check for error
        BEQ     SR_badpar               ; handle error if any
        LDR     r2, [r2, #0]            ; pick up frequency (1st word in entry)
        EXIT                           ; all done!

30      CMP     r0, #3
        BNE     %FT40
; Function code 3: set sample rate as specified by index in r1
        BL      SR_maptab               ; get address of relevant main table entry
        MOVS    r4, r2                  ; move pointer, check for error (=0)
        BEQ     SR_badpar               ; handle error if any
        Push    "r1"                    ; save new index
        LDRB    r2, [r4, #4]            ; get nominal period from table entry
        STRB    r2, [r10, #Period]      ; store away for Sound_Configure calls
        LDRB    r3, [r4, #5]            ; get SFR w/o oversampling
        LDR     r1, [r10, #Config]
        MOV     r0, r1, LSR #24         ; r0 = current flags
        MOV     r1, r1, LSL #16
        MOV     r1, r1, LSR #16         ; r1 = samples per buffer
        BL      process_oversample      ; work out whether o/s needed, fix SFR if so
        STRB    r3, [r10, #VIDCSFR_N]   ; store SFR for later programming
        STRB    r0, [r10, #Flags]       ; and update flags
        LDRB    r3, [r4, #6]            ; get SCR value from table entry
        STRB    r3, [r10, #VIDCSCR_N]   ; store for prog'ing under IRQ
        Pull    "lr"                    ; recover new index, into lr this time
        LDR     r3, [r10, #SoundRMA]    ; address 16-bit system variables
        LDR     r1, [r3, #CurSRIndex]   ; get previous samplerate index for return to user
        LDR     r2, [r3, #CurSRValue]   ; get previous samplerate value for return to user
        STR     lr, [r3, #CurSRIndex]   ; save off new Sample Rate index
        LDR     lr, [r4, #0]            ; pick up frequency value from table entry
        STR     lr, [r3, #CurSRValue]   ; and save that too
        MOV     r0, #3
        EXIT                            ; all done

40                                      ; function code not 0..3: complain
SR_badpar
        ADR     r0, badparblock
        MOV     r1, #0
        MOV     r2, #0
        SWI     XMessageTrans_ErrorLookup
        PullEnv
        MOV     pc, lr                  ; SWI will always set V

badparblock
        DCD     &1F1                    ; ???
        DCB     "BadParm",0
        ALIGN

; SR_maptab: subroutine to convert r1 SR index to address of relevant
; entry in ftab, in r2.  Assumes r3 contains configured sound mode (1..3).
; Corrupts r3 and r4; r1 is always preserved; r2 is set to 0 on error.
SR_maptab
        ADRL    r4, mtab-1              ; address map table (0-equiv entry)
        LDRB    r3, [r4, r3]            ; pick up table offset
        ADD     r3, r4, r3              ; convert to address of relevant map, -1
        LDRB    r4, [r3, #1]!           ; get index range (entry 0 in map)
        SUB     r1, r1, #1              ; reduce index to 0-based range
        CMP     r1, r4                  ; check against limit (unsigned)
        ADD     r1, r1, #1              ; put index back again always
        MOVHS   r2, #0                  ; if out of range, mark error
        MOVHS   pc, lr                  ; and return
        LDRB    r2, [r3, r1]            ; get index into main freq table
        ADR     r3, ftab-8              ; address main table 0th entry
        ADD     r2, r3, r2, LSL #3      ; index into main table (8 bytes each)
        MOV     pc, lr                  ; return


  ]


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Initialise_Module Entry "r7, r8, r10, r11"

        LDR     r2, [r12]
        TEQ     r2, #0
        BNE     %FT00

        MOV     r3, #WorkSpaceSize
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        EXIT    VS

        STR     r2, [r12]

00      LDR     r10, =SoundLevel0Base
        STR     r2, [r10, #SoundRMA]    ; keep separate record of RMA area base
        MOV     r0, #0
        STR     r0, [r2, #MessageFile_Open]
 [ VIDC_Type = "VIDC20"
        STR     r0, [r2, #Lin16Gen]     ; No 16-bit handler
        STR     r0, [r2, #Lin16GenR0]
        STR     r0, [r2, #SavedSample]  ; 0 previous value for interpolation
        STR     r0, [r2, #CurSRIndex]   ;
        STR     r0, [r2, #CurSRValue]   ;
 ]
 [ StorkPower
  [ AdvancedPower
        MOV     r0, #0                          ; indicate amplifier power should be on
        STR     r0, [r2, #PowerControl]
        BL      GetPower                        ;
  |
        BL      GetPower                        ;
        BL      SetPower_On                     ; SetPower_On to call XPortable_Control (corrupts R0)
  ]
 ]
        BL      InitResetCommon
        EXIT    VS                      ; [going nowhere if this fails]

; Get physical address of sound buffer 0.  This is fixed at a single
; value on both MEMC1 and MEMC2 systems, but variable (obtained via new
; SWI) on IOMD systems.  The logical address is fixed (at &01F06000) on
; all systems.

 [ MEMC_Type = "IOMD"
        LDR     r2, =SoundDMABuffers    ; fixed logical address of 2 soundbuffers
        SUB     sp, sp, #12             ; get temp space for a single-entry Page Block
        STR     r2, [sp, #1*4]          ; write addr into l.a. slot of page block
        MOV     r1, sp                  ; point at Page Block as SWI arg
        MOV     r2, #1                  ; 1 entry to update
        MOV     r0, #&2200              ; convert log address to phys address
        SWI     XOS_Memory              ; go do the conversion
        LDR     r1, [sp, #2*4]          ; pick up physical address into R1
        ADD     sp, sp, #12             ; release temp space
        EXIT    VS                      ; ought never to fail!
 |
        LDR     r1, =SoundPhysBuffers   ; get fixed physical address in R1
 ]
        MOV     r0, #0                  ; Semaphore ON (so reenable wakens it)
        ADRL    r2, ProtoS0S            ; address sound0segment prototype
        LDMIA   r2, {r2,r3,r4,r5,r6,r7,r8} ; load it up (from Buff0 onwards)
        STMIA   r10, {r0-r8}            ; Set up Sound0Segment, first 9 words

        ADD     r0, r10, #Images        ; address user-level image positions
        BL      ConvImages              ; convert to compact version for prog'ing
        STR     r0, [r10, #ImagesC_N]   ; compacted form, into top of pipeline
        STR     r0, [r10, #ImagesC_H]   ; and for next buffer

 [ VIDC_Type <> "VIDC20"
        LDR     r0, [r10, #ImagesC_H]   ; program default SIR setting into hardware
        STR     r0, [r10, #ImagesC_C]   ; mark as current set
        BL      ProgramImages           ; program them now not later
 |
        ; go fetch 16-bit sound control info from CMOS
        MOV     r0, #161                ; CMOS read OSBYTE
        MOV     r1, #PrintSoundCMOS     ; get extended (VIDC20) sound bits
        SWI     XOS_Byte                ; "won't" fail

; R2 is byte from CMOS
; bit 7 is quality bit (do interpolation to maximise quality)
; bit 6:5  form 16-bit sound control value. From Hdr:CMOS --
;
; Bit  5,6 = 16-Bit sound control, on VIDC20 machines including Risc PC.
;              0: no 16-bit sound output, use standard mu-law (default)
;              1: DAC clock is slave: 11.2896MHz ext clock: standard VIDC20 rates or
;                  44.1 KHz * 4/(4..45) can be used (as on ESP sound card).
;              2: DAC clock is slave: no ext clock: standard VIDC20 rates only
;              3: DAC clock is master: ext clock must be used for 16-bit sound
;                 (suitable sound clock driver must be installed)
        MOV     r2, r2, LSR #5-Lin16Shift ; shift right to bit position in Flags byte
        AND     r2, r2, #Lin16Bits+OversampleFlag ; extract the three applicable bits
        ORR     r4, r4, r2, LSL #24     ; set new flag bits in place
        STR     r4, [r10, #Config]      ; and store config, with them in
        TST     r2, #Lin16Bits          ; check for 16-bit mode bits being 0
        BNE     %FT20                   ; if not, go handle software conv code compilation
                                        ; else nowt special to do except...
        LDR     r0, [r10, #ImagesC_H]   ; program default SIR setting into hardware
        STR     r0, [r10, #ImagesC_C]   ; mark as current set
        BL      ProgramImages           ; program them now not later

        B       %FT30

20      MOV     r0, r4, LSR #24         ; get log2nchan + flags byte
        AND     r0, r0, #3              ; get log2nchan alone into r0
        LDR     r1, [r10, #SoundRMA]
        ADD     r1, r1, #LinConvCode    ; get address to put code
        MOV     r2, #SCSoundGain        ; set up default soundgain value
        STRB    r2, [r10, #SoundGain]
        STRB    r2, [r10, #SoundGain_C]
        LDR     r2, [r10, #ImagesC_H]   ; address stereo position set
        STR     r2, [r10, #ImagesC_C]   ; mark as current set
        STRB    r0, [r10, #Log2nchan_C] ; do same for log2nchan
        ORR     r2, r2, #SCSoundGain :SHL: 24 ; combine default soundgain into r2
        BL      compile                 ; go call compiler to set it all up
        LDR     r1, [r10, #Phys0]       ; reload physical buffer address to r1
        ; set up NSR
        LDR     r7, [r10, #SoundRMA]
        MOV     r0, r4, LSR #24 + Lin16Shift
        AND     r0, r0, #Lin16Bits :SHR: Lin16Shift
        ADRL    r6, nnsr-1
        LDRB    r6, [r6, r0]
        STR     r6, [r7, #NSR]
30
 ]
        MOV     r6, r4, LSL #16         ; build 16-bit Length (in sample times)
        MOV     r6, r6, LSR #16
        MOV     r7, r4, LSR #24         ; build LogChannel count in r7
        AND     r7, r7, #3
        MOV     r6, r6, LSL r7          ; build DAG End (i.e. length in bytes) in r6
        SUB     r6, r6, #16             ; adjust for DMA end check (hardware)

 [ MEMC_Type = "IOMD"
        ; Initialise DMA pointers
        MOV     r0, #IOMD_Base
        STR     r1, [r0, #IOMD_SD0CURA]
        STR     r6, [r0, #IOMD_SD0ENDA] ; initialise buffer A
        STR     r1, [r0, #IOMD_SD0CURB]
        STR     r6, [r0, #IOMD_SD0ENDB] ; and buffer B, to same range!
 |
  [ MEMC_Type = "MEMC2"
        ADD     r0, r1, r6              ; r1 = start, r0 = end
        MOV     r3, r1, LSR #16         ; r3 = start hi
        EOR     r1, r1, r3, LSL #16     ; r1 = start lo
        MOV     r2, r0, LSR #16         ; r2 = end hi
        EOR     r0, r0, r2, LSL #16     ; r0 = end lo

        LDR     r5, =MEMC2Address+MEMC2_SSTRT
        ADD     r6, r5, #MEMC2_SENDN-MEMC2_SSTRT
        ADD     r14, r5, #MEMC2_SCUR-MEMC2_SSTRT

        STMIA   r6, {r0, r2}            ; write SENDN
        STMIA   r5, {r1, r3}            ; write SSTRT
        STMIA   r14, {r1, r3}           ; write SCUR
        STMIA   r6, {r0, r2}            ; write SENDN
        STMIA   r5, {r1, r3}            ; write SSTRT
  |
    ASSERT MEMC_Type = "MEMC1" :LOR: MEMC_Type = "MEMC1a"
        LDR     r2, =SoundPhysBuffers :SHR: 2 ; Set DMA constants
        ORR     r2, r2, #&03680000      ; r2 will be DAG start
        ORR     r1, r2, #&00020000      ; r1 will be DAG end
        ORR     r0, r2, #&00040000      ; r0 will be DAG ptr

        ADD     r1, r1, r6, LSR #2

        STR     r1, [r1]                ; write DAG end
        STR     r2, [r2]                ; write DAG start
        STR     r0, [r0]                ; and DAG ptr -> SWAP: now ...
        STR     r1, [r1]                ; write DAG end
        STR     r2, [r2]                ; write DAG start
        STR     r0, [r0]                ; and DAG ptr
  ]
 ]

        MOV     r0, r7                  ; r0:= log2(channels)
        MOV     r1, r4, LSL #16         ; r1 = samples per buffer
        MOV     r1, r1, LSR #16
        MOV     r2, r4, LSR #16         ; 8-bit period
        AND     r2, r2, #&FF
        BL      WorkOutVIDCParams

        ; Set VIDC sample rate now, not later
        LDRB    r0, [r10, #VIDCSFR_N]   ; pick up computed value
        STRB    r0, [r10, #VIDCSFR_H]   ; store in next pipeline slot also
        SUB     r2, r0, #2              ; adjust for programming (want N, write N-2)
        ORR     r2, r2, #SFR            ; merge in register address
 [ VIDC_Type <> "VIDC20"
        ORR     r2, r2, #&100           ; ensure NTest bit set -> not Test
 ]
        MOV     r1, #VIDC
        STR     r2, [r1]                ; and program into VIDC
        STRB    r0, [r10, #VIDCSFR_C]   ; store as current hardware value

 [ VIDC_Type = "VIDC20"
        ; Set up VIDC20's Sound Control Register in the same way
        LDRB    r0, [r10, #VIDCSCR_N]
        STRB    r0, [r10, #VIDCSCR_H]   ; copy into pipeline now
        ORR     r2, r0, #SCR            ; construct reg + value combination
        STR     r2, [r1]                ; and program it
        STRB    r0, [r10, #VIDCSCR_C]   ; and record as current value
 ]

        WritePSRc I_bit :OR: SVC_mode,lr; IRQ off please
        BL      Sound0Reenable          ; Turn on system
        WritePSRc SVC_mode, lr          ; Reenabled IRQs

        MOV     r0, #Service_SoundLevel0Alive
        MOV     r1, #Service_Sound
        SWI     XOS_ServiceCall
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;Ursula format
;
       ASSERT   Service_Reset      < Service_ModeChange
       ASSERT   Service_ModeChange < Service_Portable
;
UServTab
        DCD     0
        DCD     UService - Module_Base
        DCD     Service_Reset
  [ VarSndClock
        DCD     Service_ModeChange
  ]
  [ StorkPower
        DCD     Service_Portable
  ]
        DCD     0
        DCD     UServTab - Module_Base
Intercept_Services ROUT
        MOV     r0,r0
        TEQ     r1,#Service_Reset
  [ StorkPower
        TEQNE   r1,#Service_Portable
  ]
  [ VarSndClock
        TEQNE   r1,#Service_ModeChange
  ]
        MOVNE   PC,LR
UService
 [ StorkPower
        CMP     r1, #Service_Portable
        BEQ     %FT30
 ]
 [ VarSndClock
        CMP     r1, #Service_ModeChange         ; EQ, CS if this
        TEQNE   r1, #(Service_Reset :SHL: 2), 2 ; EQ, CC if that
        MOVNE   pc, lr
        BCS     ModeChangeCode
 |
        CMP     r1, #Service_Reset
        MOVNE   pc, lr
 ]

        Entry   "r0-r4, r10, r11"

; Fix MED-02859 - only call InitResetCommon if it's a soft reset.
; Otherwise we'll try to put ourselves on twice, and there's a window
; during which Sound DMA is enabled and the kernel has temporarily removed
; all device handlers.

        MOV     r0, #&FD
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
        TEQ     r1, #0
        EXIT    NE

        LDR     r10, =SoundLevel0Base
        BL      InitResetCommon
        EXIT    VS                      ; Can't raise error from service

        SavePSR r14
        Push    r14
        WritePSRc I_bit :OR: SVC_mode, r11 ; IRQ off please
        BL      Sound0Reenable          ; Turn on system/keep it off
 [ VarSndClock
        BL      ModeChangeCode          ; recache VIDCMultiplier + VIDCSFR
 ]
        WritePSRc I_bit :OR: SVC_mode, r11 ; restore SVC mode/IRQ off in case
        Pull    r14
        RestPSR r14
        EXIT                            ; Restore caller's IRQ state

 [ VarSndClock
ModeChangeCode
        Entry   "r0-r4, r10"
        LDR     r10, =SoundLevel0Base
        BL      SetupVIDCMultiplier
        MOV     r0, #0                  ; issue a Sound_Configure SWI
        MOV     r1, #0                  ; without altering any parameters
        MOV     r2, #0                  ; this will cause VIDCSFR to be
        MOV     r3, #0                  ; recalculated, and an update requested
        MOV     r4, #0                  ; from the low level code
        SWI     XSound_Configure
        CLRV
        EXIT
 ]

 [ StorkPower
30
        TEQ     r2, #ServicePortable_PowerDown
        BNE     %FT35

        Push    "r0,r10,r11,lr"
        LDR     r10, =SoundLevel0Base
        LDR     r11, [r10, #SoundRMA]

        MOV     lr, #1
        STR     lr, [r11, #portable_present]    ; indicate portable module present
        TST     r3, #SoundPowerBits             ; are they trying to power down the sound system
        Pull    "r0,r10,r11,pc",EQ              ; no then just pass on the service

        LDR     r0, [r10, #Semaphore]           ;Its OK to power down if sound IRQ's are off or
        TST     r0, #&80000000                  ; sound is quiet
        BNE     %FT32                           ;NE, sound system off
  [ AdvancedPower
        LDR     r0, [r11, #PowerControl]
        CMP     r0, #PowerContThres1
        BGE     %FT32                           ;GE, playing, but quietly
;
; Sound system on AND making a noise, so prevent powerdown
;
  |
;
; Sound system on, so prevent powerdown
;
  ]
        BICS    r3, r3, #SoundPowerBits         ; by clearing the sound bits
        MOVEQ   r1, #0                          ; and if there are no more bits being turned off
        Pull    "r0,r10,r11,pc"                 ; then claim service to save time
32
        LDR     r0, [r11, #power_state]         ; update our record of which bits are on
        BIC     r0, r0, r3
        STR     r0, [r11, #power_state]
        Pull    "r0,r10,r11,pc"

35
        TEQ     r2, #ServicePortable_PowerUp    ; bits being powered up
        MOVNE   pc, lr

        Push    "r0,r10,r11,lr"
        LDR     r10, =SoundLevel0Base
        LDR     r11, [r10, #SoundRMA]
        MOV     lr, #1
        STR     lr, [r11, #portable_present]    ; indicate portable module present
        AND     lr, r3, #SoundPowerBits         ; just get sound bits which are being powered up
        LDR     r0, [r11, #power_state]
        ORR     r0, r0, lr                      ; and or them into our current state
        STR     r0, [r11, #power_state]
        Pull    "r0,r10,r11,pc"
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r4 trashable <---- NB.
;       r10 = SoundLevel0Base

; Out   VC: ok
;       VS: r0 -> error block

InitResetCommon Entry

        LDR     r4, =SoundDMABuffers    ; Clear out entire DMA buffers
        ADD     r14, r4, #SoundDMABufferSize * 2
        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
50      STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        STMIA   r4!, {r0-r3}
        CMP     r4, r14
        BLT     %BT50

 [ VarSndClock
        BL      SetupVIDCMultiplier
 ]

; Claim vector to field the interrupts on

        ADR     r1, Module_VectorCode
        MOV     r2, r10                 ; R12 value to be passed in

 [ MEMC_Type = "IOMD"
        MOV     r0, #IOMD_DMASound0_DevNo
        SWI     XOS_ClaimDeviceVector
 |
        MOV     r0, #Sound_DevNo
        SWI     XOS_ClaimDeviceVector
 ]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable, r10 = fatality indication

Finalise_Module Entry "r10, r11"

        LDR     r12, [r12]              ; Get wp for messagefile info
        LDR     r0, [r12, #MessageFile_Open]
        CMP     r0, #0
        ADDNE   r0, r12, #MessageFile_Block
        SWINE   XMessageTrans_CloseFile

        LDR     r10, =SoundLevel0Base

        MOV     r0, #Service_SoundLevel0Dying
        MOV     r1, #Service_Sound
        SWI     XOS_ServiceCall         ; Can't stop me!

        PHPSEI  r14, r0
        Push    "r14"
        MOV     r0, #1                  ; Turn off system - can't SWI anymore
        BL      Sound0Enable
        Pull    "r14"
        PLP     r14                     ; Reenable IRQs

; release the irq handler

        ADR     r1, Module_VectorCode
        MOV     r2, r10

 [ MEMC_Type = "IOMD"
        MOV     r0, #IOMD_DMASound0_DevNo
        SWI     XOS_ReleaseDeviceVector                 ; release device vector
 |
        MOV     r0, #Sound_DevNo
        SWI     XOS_ReleaseDeviceVector                 ; release device vector
 ]
        CLRV
        EXIT                            ; Don't refuse to die


 [ VarSndClock
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       SetupVIDCMultiplier - Set up VIDC multiplier - for use
;       on systems where sound clock frequency is affected by
;       changes in video clock frequency (incl. any with VIDC1/1a).
;
; in:   wp -> Sound0 workspace
;       r10 = SoundLevel0Base
; out:  r0-r2 corrupted
;

SetupVIDCMultiplier Entry
        ADR     r0, RVVTab              ; point at table
        LDR     r2, =24000              ; default rate
        Push    r2                      ; push on stack
        MOV     r1, r13                 ; r1 -> object block
        SWI     XOS_ReadVduVariables    ; if SWI not known, will leave default
        Pull    r0
        TEQ     r0, #0                  ; 0 => variable not known
        MOVEQ   r0, r2                  ; so use default

        LDR     r1, =4000               ; now divide by 4000 to get VIDC clock
        BL      Divide                  ; in units of 4MHz
        STRB    r2, [r10, #VIDCMultiplier] ; and save it away
        EXIT

RVVTab
        &       VduExt_VIDCClockSpeed
        &       -1

 ]


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       Divide - r2 := r0 DIV r1  -
;
; This is needed when base sound clock rate varies (with video clock), and
; when computing period from frequency or vice versa.
;

Divide  Entry
        DivRem  r2, r0, r1, r14
        EXIT
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        SUBT    Sound DMA Module Interrupt Service Routine
        OPT     OptPage

Module_VectorCode ROUT

        Push    "r11, lr"               ; Never entered except when SIRQ
                                        ; Below code expects stacked return pc


; IFF semaphore is zero then r13 = system IRQ stack pointer
; ELSE re-entrant SIRQ indicating buffer filling STILL IN PROGRESS!
; r11     work register
; r12     SoundLevel0Base
; r13     IRQ stack (must be FD)
; r14     work register

        MOV     r14, wp                 ; =SoundLevel0Base
        LDR     r12, [r14, #Semaphore]  ; semaphore
        CMP     r12, #0
        BEQ     %FT40                   ; do Level0Swap

; Level0Overrun - can't break general IRQ thread; other handlers reenable IRQ.

        Push    "r0-r10"

; Program MEMC such that next buffer = this buffer

        LDMIB   r14, {r5-r11}           ; Sound0Segment params, skip semaphore
;;;        STR     r6, [r14, #Buff1]       ; DON'T Swap for next time
;;;        STR     r7, [r14, #Buff0]
        MOV     r12, r7                 ; r7 = old start
                                        ; r6 = new start
        SUBS    r0, r7, r6              ; buffer offset
        ADDPL   r5, r5, r0              ; if r7 > r6, then r5 += diff!
        MOV     r6, r8                  ; set r6 -ve for any updates

        MOV     r10, r6, LSL #16        ; 16-bit buffer length in r10
        MOV     r10, r10, LSR #16
        MOV     r11, r6, LSR #24        ; 3-bit log channel count in r11
 [ VIDC_Type = "VIDC20"
        TST     r11, #Lin16Bits         ; in 16-bit mode?
        BEQ     %FT01                   ; just use masked value if not
        TST     r11, #DoOversample      ; 16-bit: check for oversampling
        MOVEQ   r11, #2                 ; 4 bytes/sample if no o/s
        MOVNE   r11, #3                 ; but 8 bytes/sample if o/s
01
 ]
        AND     r11, r11, #3
        MOV     r4, r10, LSL r11        ; compute physical buffer length in r4
        BIC     r4, r4, #&F             ; must be multiple of 16
        MOV     r10, r4, LSR r11        ; may need to adjust logical buffer length
        SUB     r0, r4, #16             ; compute DMA end

 [ MEMC_Type = "IOMD"

        ; Can set end field to (length of buffer - 16), already
        ; computed in r0, since we know - or at least, we assume! -
        ; that buffers always start on a page boundary, and hence the
        ; end has the same page-relative alignment as the length.
        ; Note: we never need to set the S bit, since we assume
        ; continuous operation and never pre-program sound DMA to stop
        ; at some future point; if we are told to stop we do so
        ; immediately by clearing the enable bit.  Nor do we ever set
        ; the L bit, since we assume sane buffer lengths, i.e. much
        ; more than 16 bytes/buffer.

        ; Now work out which buffer set to program, by checking status
        ; of DMA channel hardware.  If hardware status shows A, update
        ; B and vice versa, unless overrun has occured in which case
        ; we update the same one hardware is now on (since it has now
        ; stopped on that buffer waiting to know what to do, and must
        ; have that same buffer programmed next).  When the A/B bit is
        ; zero, the hardware is on A, when one it is on B.

        MOV     r2, #IOMD_Base
        LDRB    r1, [r2, #IOMD_SD0ST]   ; get status of channel

        TST     r1, #IOMD_DMA_O_Bit     ; invert sense of A/B bit if O bit is set
        EORNE   r1, r1, #IOMD_DMA_B_Bit ; ....

        TST     r1, #IOMD_DMA_B_Bit     ; work out whether to write to A or B

        STRNE   r5, [r2, #IOMD_SD0CURA] ; if Z clear, update CURA reg
        STRNE   r0, [r2, #IOMD_SD0ENDA] ;   and also end reg, to make it valid
        STREQ   r5, [r2, #IOMD_SD0CURB] ; else update CURB reg
        STREQ   r0, [r2, #IOMD_SD0ENDB] ;   and also end reg, to make it valid

        ; Now check that it worked - if overrun happens between
        ; reading the status and writing the end register, the
        ; interrupt will still be there and O will be set, and we need
        ; to re-write the other register pair with the *same* values
        ; (cannot allow to just exit from interrupt service and catch
        ; on next IRQ since wrong buffers would then be used,
        ; resulting in an audible glitch if sound were playing at the
        ; time).

        ; BIG ASSUMPTION (but a very reasonable one): only a small
        ; amount of real time - certainly less than a buffer period -
        ; can have passed between the STR to the relevant end register
        ; above, and re-loading the status register now.  Since only
        ; FIQs can have got in (IRQs are disabled), we expect that
        ; this requirement will hold.  The only problem would be if
        ; FIQs started occuring after the STR and continued without
        ; pause for a whole buffer time: that seems highly unlikely.

        LDRB    r3, [r2, #IOMD_SD0ST]
        TST     r3, #IOMD_DMA_O_Bit     ; now in overrun?
        BEQ     %FT10                   ; branch if OK

        ; Here, use other buffer in channel, so if we programmed A
        ; above do B now, and vice versa
        TST     r1, #IOMD_DMA_B_Bit     ; same test as above, but
                                        ; reverse execution conditions below
        STREQ   r5, [r2, #IOMD_SD0CURA] ; if Z set, update CURA reg
        STREQ   r0, [r2, #IOMD_SD0ENDA] ;   and also end reg, to make it valid
        STRNE   r5, [r2, #IOMD_SD0CURB] ; else update CURB reg
        STRNE   r0, [r2, #IOMD_SD0ENDB] ;   and also end reg, to make it valid
        ; OK, should be all clear now...
10
 |
        ; Both MEMC1 and MEMC2 need actual end (last used) address rather
        ; than just end offset value as in IOMD: compute it now
        ADD     r0, r0, r5              ; OLD END! r12
  [ MEMC_Type = "MEMC2"
        MOV     r1, r0, LSR #16         ; r1 = end hi
        EOR     r0, r0, r1, LSL #16     ; r0 = end lo
        LDR     r2, =MEMC2Address+MEMC2_SENDN
        STMIA   r2, {r0, r1}            ; write DAG end

        MOV     r1, r5, LSR #16         ; r1 = start hi
        EOR     r0, r5, r1, LSL #16     ; r0 = start lo
        ADD     r2, r2, #MEMC2_SSTRT-MEMC2_SENDN
        STMIA   r2, {r0, r1}            ; write DAG start. Clears current SIRQ
  |
    ASSERT MEMC_Type = "MEMC1" :LOR: MEMC_Type = "MEMC1a"
        MOV     r0, r0, LSR #2
        ORR     r0, r0, #&03600000
        ORR     r0, r0, #&000A0000
        STR     r0, [r0]                ; write DAG end

        MOV     r0, r5, LSR #2          ; OLD compute NEW start
        ORR     r0, r0, #&03680000
        STR     r0, [r0]                ; write DAG start. Clears current SIRQ
  ]
 ]
        Pull    "r0-r10, r11, pc"


; Level0Swap

40      STR     sp_irq, [r14, #Semaphore] ; save IRQ stack^ in semaphore
        Push    "r0-r10"


; Level0 Go

 ASSERT Phys0     = 4  ; r5
 ASSERT Buff0     = 8  ; r6
 ASSERT Buff1     = 12 ; r7
 ASSERT Config    = 16 ; r8
 ASSERT Level1Ptr = 20 ; r9
 ASSERT Images    = 24 ; r10, r11 NB. Two words
50      LDMIB   r14, {r5-r9}            ; Sound0Segment params, skip semaphore
        STR     r6, [r14, #Buff1]       ; Swap for next time
        STR     r7, [r14, #Buff0]
        MOV     r12, r7                 ; r7 = old start
                                        ; r6 = new start
        SUBS    r0, r7, r6              ; buffer offset
        ADDPL   r5, r5, r0              ; if r7 > r6, then r5 += diff!
        MOV     r6, r8                  ; get config (incl. flags) in r6
        MOV     r0, r6, LSR #24         ; get configured log2nchan & flags
        AND     r0, r0, #3              ; mask out just current req'd log2nchan
        LDRB    r1, [r14, #Log2nchan_C] ; pick up current value in use
        CMP     r0, r1                  ; if different, mark update for Level1
        ORRNE   r6, r6, #1 :SHL: 31     ; by setting sign bit in r6
        STRNEB  r0, [r14, #Log2nchan_C] ; and also update log2nchan

 [ VIDC_Type = "VIDC20"
        LDRB    r1, [r14, #SoundGain_C] ; get current value of mu-law->linear conv gain
        LDRB    r2, [r14, #SoundGain]   ; get last-set value
        CMP     r2, r1                  ; check if different, and if so mark fact...
        ORRNE   r6, r6, #1 :SHL: 31     ; ..by setting sign bit in r6
        STRNEB  r2, [r14, #SoundGain_C] ; and also update recorded value

        ; Handle 16-bit mode conversion routine re-compile if needed.  NB we
        ; change the compiled code directly on THIS interrupt, rather than
        ; with a one-buffer delay as is applied when updating the hardware.
        ; This is because the stereo positioning is already dealt with in the
        ; data put into the buffer, rather than when the buffer is read out
        ; (after next interrupt) by the hardware.
        ; Get currently required log2nchan value + flags
        TST     r6, #Lin16Bits :SHL: 24 ; check whether in 16-bit mode
        BEQ     %FT60                   ; go do h/ware SIR update if not

        ; Check whether any stereo position value has changed.
        ; Shuffle ImagesC FIFO first, since there is no buffer delay for
        ; software stereo
        LDR     r2, [r14, #ImagesC_N]   ; get wanted value of ImagesC
        STR     r2, [r14, #ImagesC_H]   ; (force skipping of 1-buffer delay)
        LDR     r1, [r14, #ImagesC_C]   ; check current value of ImagesC
        CMP     r2, r1                  ; check for being the same
        BNE     %FT55                   ; go recompile if different

        ; No change in stereo, but check whether number of active channels has
        ; changed, => recompile needed.  This was tested above, and marked in bit
        ; 31 of r6, so it's easy to re-check.  This bit may alternatively/also
        ; indicate change of soundgain value, with same consequence.
        TST     r6, #1 :SHL: 31
        BEQ     %FT65                   ; no re-compilation needed if bit 31 clear

55      ; Compile for updated configuration/stereo position/soundgain value.
        STR     r2, [r14, #ImagesC_C]   ; record req'd ImagesC value as current
        LDRB    r1, [r14, #SoundGain_C] ; pick up newest soundgain value
        ORR     r2, r2, r1, LSL #24     ; and combine into r2
        LDR     r1, [r14, #SoundRMA]    ; address code buffer in SoundRMA workspace
        ADD     r1, r1, #LinConvCode    ; ...
        BL      compile                 ; go compile it (R0 = log2nchan)
        LDR     r14, =SoundLevel0Base   ; (reset local vars pointer after BL)
        B       %FT65                   ; skip hardware SIR programming
 ]

60 ; mu-law output. Level0 VIDC SIR reprogram if required

        LDR     r1, [r14, #ImagesC_C]   ; get currently loaded SIR set
        LDR     r0, [r14, #ImagesC_H]   ; get SIR set for this buffer-time
        CMP     r0, r1                  ; are they the same?
        BLNE    ProgramImages           ; if not, program new set
        LDR     r14, =SoundLevel0Base   ; (reset local vars pointer after possible BL)
        STR     r0, [r14, #ImagesC_C]   ; in any case, step FIFO on (r0 preserved)
        LDR     r0, [r14, #ImagesC_N]   ; ...
        STR     r0, [r14, #ImagesC_H]   ; by one, to keep everything in step

65  ; Reprogram SFR (and on VIDC20, SCR), if required

        MOV     r2, #VIDC
        LDRB    r1, [r14, #VIDCSFR_C]   ; get currently active SFR value
        LDRB    r0, [r14, #VIDCSFR_H]   ; compare against value to apply from now on
        CMP     r0, r1                  ; are they the same?
        SUBNE   r1, r0, #2              ; if not: adjust,
        ORRNE   r1, r1, #SFR            ;        set up with reg addr
 [ VIDC_Type <> "VIDC20"
        ORRNE   r1, r1, #&100           ;        ensure NTest bit set -> not Test
 ]
        STRNE   r1, [r2]                ;        program new value
        STRNEB  r0, [r14, #VIDCSFR_C]   ;        and mark as current
        LDRB    r1, [r14, #VIDCSFR_N]   ; in any case, step FIFO...
        STRB    r1, [r14, #VIDCSFR_H]   ; to keep everything in sync.
        CMP     r0, r1                  ; if new value on NEXT irq, mark update for Level1 now
        ORRNE   r6, r6, #1 :SHL: 31

 [ VIDC_Type = "VIDC20"
        ; on VIDC20, do the same for the SCR
        LDRB    r1, [r14, #VIDCSCR_C]   ; get currently active SCR value
        LDRB    r0, [r14, #VIDCSCR_H]   ; compare against value to apply from now on
        CMP     r0, r1                  ; are they the same?
        ORRNE   r1, r0, #SCR            ; if not, set up and
        STRNE   r1, [r2]                ; program new value
        STRNEB  r0, [r14, #VIDCSCR_C]   ; and mark as current
        LDRB    r0, [r14, #VIDCSCR_N]   ; in any case, step FIFO...
        STRB    r0, [r14, #VIDCSCR_H]   ; to keep everything in sync.
 ]

; level0 MEMC update

70      MOV     r10, r6, LSL #16        ; 16-bit buffer length in r10
        MOV     r10, r10, LSR #16
        MOV     r11, r6, LSR #24        ; 3-bit log channel count, + flags, in r11
 [ VIDC_Type = "VIDC20"
        TST     r11, #Lin16Bits         ; in 16-bit mode?
        BEQ     %FT71                   ; just use masked value if not
        TST     r11, #DoOversample      ; 16-bit: check for oversampling
        MOVEQ   r11, #2                 ; 4 bytes/sample if no o/s
        MOVNE   r11, #3                 ; but 8 bytes/sample if o/s
71
 ]
        AND     r11, r11, #3
        MOV     r4, r10, LSL r11        ; compute physical buffer length in r4
        BIC     r4, r4, #&F             ; must be a multiple of 16
        MOV     r10, r4, LSR r11        ; may need to adjust logical buffer len
        SUB     r0, r4, #16             ; compute DMA end

 [ MEMC_Type = "IOMD"
        Push    "r1,r2,r3"

        ; Now work out which buffer set to program, by checking status
        ; of DMA channel hardware.  If hardware status shows A, update
        ; B and vice versa, unless overrun has occured in which case
        ; we update the same one hardware is now on (since it has now
        ; stopped on that buffer waiting to know what to do, and must
        ; have that same buffer programmed next).  When the A/B bit is
        ; zero, the hardware is on A, when one it is on B.

        MOV     r2, #IOMD_Base
        LDRB    r1, [r2, #IOMD_SD0ST]   ; get status of channel

        TST     r1, #IOMD_DMA_O_Bit     ; invert sense of A/B bit if O bit is set
        EORNE   r1, r1, #IOMD_DMA_B_Bit ; ....

        TST     r1, #IOMD_DMA_B_Bit     ; work out whether to write to A or B

        STRNE   r5, [r2, #IOMD_SD0CURA] ; if Z clear, update CURA
        STRNE   r0, [r2, #IOMD_SD0ENDA] ;   and ENDA: clears IRQ, lets DMA go on to A next
        STREQ   r5, [r2, #IOMD_SD0CURB] ; else update CURB
        STREQ   r0, [r2, #IOMD_SD0ENDB] ;   and ENDB: clears IRQ, lets DMA go on to B next

        ; Now check that it worked - if overrun happens between
        ; reading the status and writing the end register, the
        ; interrupt will still be there and O will be set, and we need
        ; to re-write the other register pair with the *same* values
        ; (cannot allow to just exit from interrupt service and catch
        ; on next IRQ since wrong buffers would then be used,
        ; resulting in an audible glitch if sound were playing at the
        ; time).

        ; BIG ASSUMPTION (but a very reasonable one): only a small
        ; amount of real time - certainly less than a buffer period -
        ; can have passed between the STR to the relevant end register
        ; above, and re-loading the status register now.  Since only
        ; FIQs can have got in (IRQs are disabled), we expect that
        ; this requirement will hold.  The only problem would be if
        ; FIQs started occuring after the STR and continued without
        ; pause for a whole buffer time: that seems highly unlikely.

        LDRB    r3, [r2, #IOMD_SD0ST]
        TST     r3, #IOMD_DMA_O_Bit     ; now in overrun?
        BEQ     %FT80                   ; branch if OK

        ; Here, use other buffer in channel, so if we programmed A
        ; above do B now, and vice versa
        TST     r1, #IOMD_DMA_B_Bit     ; same test as above, but
                                        ; reverse execution conditions below
        STREQ   r5, [r2, #IOMD_SD0CURA] ; if Z set, update CURA reg
        STREQ   r0, [r2, #IOMD_SD0ENDA] ;   and also end reg, to make it valid
        STRNE   r5, [r2, #IOMD_SD0CURB] ; else update CURB reg
        STRNE   r0, [r2, #IOMD_SD0ENDB] ;   and also end reg, to make it valid
        ; OK, should be all clear now...
80
        Pull    "r1,r2,r3"
 |
        ADD     r0, r0, r5              ; OLD END! r12
  [ MEMC_Type = "MEMC2"
        Push    "r1,r2"
        MOV     r1, r0, LSR #16         ; r1 = end hi
        EOR     r0, r0, r1, LSL #16     ; r0 = end lo
        LDR     r2, =MEMC2Address+MEMC2_SENDN
        STMIA   r2, {r0, r1}            ; write DAG end

        MOV     r1, r5, LSR #16         ; r1 = start hi
        EOR     r0, r5, r1, LSL #16     ; r0 = start lo
        ADD     r2, r2, #MEMC2_SSTRT-MEMC2_SENDN
        STMIA   r2, {r0, r1}            ; write DAG start. Clears current SIRQ
        Pull    "r1,r2"
  |
   ASSERT MEMC_Type = "MEMC1" :LOR: MEMC_Type = "MEMC1a"
        MOV     r0, r0, LSR #2
        ORR     r0, r0, #&03600000
        ORR     r0, r0, #&000A0000
        STR     r0, [r0]                ; write DAG end

; program START, hence enable reentrant SIRQs! (not here, but up in Level1 etc)

        MOV     r0, r5, LSR #2          ; OLD compute NEW start
        ORR     r0, r0, #&03680000
        STR     r0, [r0]                ; write DAG start. Clears current SIRQ
  ]
 ]

; Level0Updated - any events to dispatch?

        Push    "r8-r12, r14"           ; r1-r7 preserved by scheduler
        LDR     r12, =SoundLevel0Base
        LDR     r12, [r12, #Level2Ptr]
        TST     r12, #SoundSystemNIL    ; test for installed scheduler
        LDREQ   r0, [r12]
        TSTEQ   r0, #SoundSystemNIL     ; Valid Level2?
        MOVEQ   lr, pc
        MOVEQ   pc, r0                  ; Call Level2
        Pull    "r8-r12, r14"

; Level0 ready to fill

        MOV     r11, r6, LSR #24        ; get log2nchan + flags
  [ VIDC_Type = "VIDC20"
        TST     r11, #Lin16Bits         ; in 16-bit mode?
        BEQ     %FT81                   ; just use masked value if not
        TST     r11, #DoOversample      ; 16-bit: check for oversampling
        MOVEQ   r11, #2                 ; 4 bytes/sample if no o/s
        MOVNE   r11, #3                 ; but 8 bytes/sample if o/s
81
  ]
        AND     r11, r11, #3            ; get just log2nchan
        MOV     r10, r6, LSL #16        ; get logical buffer length/channel
        MOV     r10, r10, LSR #16       ; (16 bits worth)
        MOV     r4, r10, LSL r11        ; work out physical length into r4
        BIC     r4, r4, #&F             ; must be a multiple of 16
        MOV     r10, r4, LSR r11        ; may need to adjust logical buffer len
  [ VIDC_Type = "VIDC20"
        MOV     r4, r10, LSL #2         ; work out physical length into r4 (Fs*1, 16-bit)
        MOV     r11, r6, LSR #24        ; get back real log2nchan (asking for 8bit data)
        AND     r11, r11, #3
  ]
        ADD     r10, r12, r10, LSL r11  ; r10 = logical buffer end
        MOV     r0, #1                  ; convert log to buffer inc
        MOV     r11, r0, LSL r11        ; r11 = N channels

 [ VIDC_Type <> "VIDC20"

        MOV     r8, r7, LSR #16         ; get current per-channel period in r8
        AND     r8, r8, #&FF            ; for Level1 fill code
        TST     r9, #SoundSystemNIL     ; Valid Level1? Loaded only once ^^^
        MOVEQ   lr, pc                  ; Call Level1: don't change mode, flags
        LDREQ   pc, [r9, #SoundLevel1FillPtr] ; but only call if valid

 |
        ; Check whether running in 16-bit mode
        TST     r6, #Lin16Bits :SHL: 24
        BNE     %FT82                   ; branch to handle if so

        ; Old mu-law mode: call Level1 (if valid) and be done.
        MOV     r8, r7, LSR #16         ; get current per-channel period in r8
        AND     r8, r8, #&FF            ; for Level1 fill code
        TST     r9, #SoundSystemNIL     ; Valid Level1? Loaded only once ^^^
        MOVEQ   lr, pc                  ; Call Level1: don't change mode, flags
        LDREQ   pc, [r9, #SoundLevel1FillPtr]
 [ StorkPower
  [ AdvancedPower
        LDR     r9, =SoundLevel0Base    ; Workspace pointer
        LDR     r9, [r9, #SoundRMA]     ; Address fixup code via RMA pointer
        LDR     r0, [r9, #portable_present]
        CMP     r0, #0
        BLNE    StorkCode
  ]
 ]
        B       %FT99                   ; all finished with this buffer

82      ; Convert mu-law N-channel data in logical buffer to 16-bit stereo physical data

 [ EnableIRQsIn16bit
        ; SMC: Try enabling IRQs during conversion to reduce latency (must disable
        ;      sound IRQ first).
        MOV     r0, #IOMD_Base
        LDRB    lr, [r0, #IOMD_DMAMSK]
        BIC     lr, lr, #IOMD_DMA_SD0
        STRB    lr, [r0, #IOMD_DMAMSK]

  [ DisableFlybackIRQ
        ; Hack to disable flyback IRQ so that Replay still works. Timer0 is also disabled
        ; because the Hourglass module waits for a VSync from a handler sitting on TickerV
        ; (== stiff machine if Timer0 IRQ goes off while VSync IRQ is disabled).
        ;
        LDRB    lr, [r0, #IOCIRQMSKA]           ; Assume IOC base = IOMD base.
        Push    lr
        BIC     lr, lr, #vsync_bit + timer0_bit
        STRB    lr, [r0, #IOCIRQMSKA]
  ]

  [ DisableHardDiscIRQ
        ; Disable IDE interrupt too. Replay doesn't like this being enabled either.
        ;
        LDRB    lr, [r0, #IOCIRQMSKB]
        Push    lr
        BIC     lr, lr, #IOMD_HardDisc_IRQ_bit
        STRB    lr, [r0, #IOCIRQMSKB]
  ]

        WritePSRc SVC_mode, r0          ; R0 corruptable.  Into SVC mode, enable IRQs
        NOP
        Push    lr                      ; Save SVC_lr.
 ]

        TST     r9, #SoundSystemNIL     ; Valid Level1? Loaded only once, above
        MOVNE   r3, #0                  ; if not, mark no valid data in physical buffer
        BNE     %FT86                   ;         and go do 16-bit handling

        STMFD   sp!, {r4,r6,r10,r12} ; save off physlen, config, logend, buffstart

        WritePSRc IRQ_mode, r0          ; enable IRQs

        ; Zap the logical buffer to 0 before calling level 1 code to fill it.
        ; This is necessary for compatibility, since the standard channel
        ; handler assumes that any channel which is silent will have 0 data in
        ; its entries in the logical buffer.  But since we overwrite the
        ; logical data with 16-bit physical data after filling it, this will
        ; not hold in general.  So fill the logical buffer with all 0 now.

        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        MOV     r8, r12

        ; Zero 4*8 words = 128 bytes each loop.  Slightly overrunning the
        ; logical buffer end is not a problem, and since the physical
        ; buffers are a multiple of 128 bytes in length, we won't overrun
        ; those either.

84      STMIA   r8!, {r0-r7}
        STMIA   r8!, {r0-r7}
        STMIA   r8!, {r0-r7}
        STMIA   r8!, {r0-r7}
        CMP     r8, r10
        BLO     %BT84

        WritePSRc I_bit + IRQ_mode, r0  ; IRQs off again

        ; Call Level1: don't change mode, flags

        LDR     r6, [sp, #4]            ; reload config value, including update flag r6:31
        MOV     r8, r6, LSR #16         ; get current per-channel period in r8,
        AND     r8, r8, #&FF            ; for Level1 fill code

 [ EnableIRQsIn16bit
        ; SMC: Back to IRQ mode with IRQs disabled for Level 1 fill.
        WritePSRc I_bit :OR: IRQ_mode, lr
        NOP
 ]

        MOV     lr, pc
        LDR     pc, [r9, #SoundLevel1FillPtr]

 [ EnableIRQsIn16bit
        ; SMC: Then back to SVC mode with IRQs enabled.
        WritePSRc SVC_mode, lr
        NOP
 ]

 [ StorkPower
  [ AdvancedPower
        LDR     r9, =SoundLevel0Base    ; Workspace pointer
        LDR     r9, [r9, #SoundRMA]     ; Address fixup code via RMA pointer
        LDR     r0, [r9, #portable_present]
        CMP     r0, #0
        BLNE    StorkCode
  ]
 ]
        LDMFD   sp, {r4,r6,r10,r12}    ; restore saved values. NB leave on stack: no `!'

        ; Convert mu-law to 16-bit linear data.
        ; have: physical length in r4,
        ;       logical buffer end in r10
        ;       logical buffer start in r12
        ; want: r10 and r12 as they are,
        ;       r11 = physical buffer start or end, according to logical buffer size
        ;       r9 = address of 256-entry mu-law to 16-bit conversion table
        ;       r8 = &FF for byte masking in conversion routine
        ;       r5 = &7FFF for overflow test

        TST     r6, #2 :SHL: 24         ; 4 or 8 channels in use?
        MOVNE   r11, r12                ; write 16-bit data forwards from start if so
        ADDEQ   r11, r12, r4            ; else write 16-bit data backwards from phys buff end
        ADRL    r9, convtable           ; address conversion table for routine to use
        MOV     r8, #&FF                ; set up byte mask used in routine
        ORR     r5, r8, #&7F00          ; and also mask for limit check
        LDR     r0, =SoundLevel0Base    ; address our local data
        LDR     r0, [r0, #SoundRMA]     ; go get RMA space address
        MOV     r7, #&70000003          ; put impossible 16-bit output value in r7
        MOV     lr, pc                  ; set up return address
        ADD     pc, r0, #LinConvCode    ; call conversion code

        LDMFD   sp!, {r4,r6,r10,r12}    ; again restore values, clearing stack this time

        CMP     r7, #&70000003          ; if impossible value still in r7, all data was 0
        MOVNE   r3, #1                  ; mark that there is valid (non-0) data in buffer
        MOVEQ   r3, #2                  ; else mark that 16-bit data in buffer is all 0

86      ; We're now dealing with a physical buffer containing 16-bit stereo
        ; data (it will still contain old data from last time, if no level 1
        ; handler is present).  Check whether there is a 16-bit sound
        ; generator/mixer, and if so, call it.  Note that r3 determines
        ; whether there is valid 16-bit data in the buffer already:
        ;
        ;     0 => old/invalid (*must* overwrite) - jumped here directly, no level 1 handler
        ;     1 => yes, valid, not all 0, but may overwrite to ignore
        ;     2 => yes, and known to be all 0, so can simply return if silent

        LDR     r0, =SoundLevel0Base
        LDR     r5, [r0, #SoundRMA]     ; address RMA workspace
        LDR     r11, [r5, #Lin16Gen]    ; pick up code address
        LDR     r0, [r5, #Lin16GenR0]   ; pick up paramter to pass it in r0
        MOV     r1, r12                 ; pass base of buffer in r1
        ADD     r2, r12, r4             ; and end of buffer in r2
        CMP     r11, #0                 ; check for valid entry, if so.....
        STMFD   sp!, {r1,r2}            ; save base/limit for oversampler below
        BEQ     %FT87
        LDR     r4, [r5, #CurSRValue]   ; load up current frequency value into r4

 [ EnableIRQsIn16bit
        ; SMC: Back to IRQ mode with IRQs disabled.
        WritePSRc I_bit :OR: IRQ_mode, lr
        NOP
 ]

        MOV     lr, pc                  ; and go call
        MOV     pc, r11

 [ EnableIRQsIn16bit
        ; SMC: Then back to SVC mode with IRQs enabled.
        WritePSRc SVC_mode, lr
        NOP
 ]

87
        LDMFD   sp, {r0,r1}            ; reload (no pop) phys base & limit now

        ; Finally, perform mono mix-down and/or oversampling, if required.

        LDR     r11, =SoundLevel0Base
        LDRB    r3, [r11, #Flags]       ; now check for oversamping/mono
	MOV	r3, r3, LSR #OverMonoShift
	ANDS	r3, r3, #3		; bit 0 -> oversamp. bit 1 -> mono
	BEQ	BufferDone		; nowt to do if both bits clear (r3 = 0)

	; OK, doing some sort of filtering operation.  Set up some constants
	; used in all cases...

	; Set up 0x80008000 in r12, to perform signed/unsigned swap overs
 	MOV	r12, #1<<15
 	ORR	r12, r12, #1<<31

	; Create 0xFFFEFFFE in r11 for masking off LSBs, to isolate LH and RH
	; parts during parallel additions.
 	MVN	r11, r12, ROR #15	; can derive from r12 in one go!

	CMP	r3, #2			; check which proc we need to call (1,2,3)
	BEQ	MonoOnly		; if r3 = 2, do just mono conversion
					; else doing oversampling...
        SUB     r2, r1, r0              ; determine phys length of buffer at Fs*1
        ADD     r2, r0, r2, LSL #1      ; and compute end of buffer at Fs*2
	STR	r2, [sp, #4]		; store out for later use also
					; switch to appropriate oversampling code
	BLT	OverOnly		; if r3 < 2 (i.e. 1), only oversample
	B	MonoOver		; if r3 > 2 (i.e. 3), do mono + oversample

BufferDone	; return here after any buffer processing
	Pull	"r3,r4" 		; pop phys base+real limit (@Fs*2 if oversampling)
	LDR	r6, [r4, #-4]		; pick up last sample pair from this buffer
	LDR	r11, =SoundLevel0Base 	; address sound work area
	LDR	r7, [r11, #SoundRMA]	; address RMA area
	STR	r6, [r7, #SavedSample]	; save sample pair for possible oversampling next time


  [ EnableIRQsIn16bit
        Pull    lr                      ; Restore SVC_lr.
        WritePSRc I_bit :OR: IRQ_mode, r0
        MOV     r0, #IOMD_Base
        LDRB    lr, [r0, #IOMD_DMAMSK]
        ORR     lr, lr, #IOMD_DMA_SD0
        STRB    lr, [r0, #IOMD_DMAMSK]
   [ DisableHardDiscIRQ
        Pull    lr
        TST     lr, #IOMD_HardDisc_IRQ_bit
        LDRNEB  lr, [r0, #IOCIRQMSKB]
        ORRNE   lr, lr, #IOMD_HardDisc_IRQ_bit
        STRNEB  lr, [r0, #IOCIRQMSKB]
   ]
   [ DisableFlybackIRQ
        Pull    lr
        ANDS    lr, lr, #vsync_bit + timer0_bit
        LDRNEB  r1, [r0, #IOCIRQMSKA]
        BICNE   r1, r1, #vsync_bit + timer0_bit
        ORRNE   r1, r1, lr
        STRNEB  r1, [r0, #IOCIRQMSKA]
   ]
  ]
 ]

99      ; All done for this IRQ

        Pull    "r0-r10"
        LDR     wp, =SoundLevel0Base
        MOV     r11, #0
        STR     r11, [wp, #Semaphore]   ; clear semaphore
        Pull    "r11, pc"               ; Return from interrupt


; Buffer processing routines - 3 off, done as out-of-line code sequences which
; all return to "BufferDone" above....

; MonoOnly
;
;     Convert stereo into mono (in same buffer space) for use with mono sound devices
;     (e.g. TV with only mono sound input, attached to NC).
;     NB: output data is still 2x16bit/sample.
;
;   r0 = base address of current buffer
;   r1 = limit address (last+1) of source (Fs*1)
;   r2-r10 free for general use
;   r11 = 0xFFFEFFFE
;   r12 = 0x80008000
;   r14 = free for use
; On exit:
;   r0-r10,r14 corrupted

MonoOnly	ROUT
01	LDMDB	r1!, {r2,r3,r4,r5}
	; convert from signed to unsigned format
	EOR	r2, r2, r12
	EOR	r3, r3, r12
	EOR	r4, r4, r12
	EOR	r5, r5, r12
	; clear off LSB from each value (two in each reg)
	AND	r2, r2, r11
	AND	r3, r3, r11
	AND	r4, r4, r11
	AND	r5, r5, r11
	; Add the left and right samples together, simultaneously in both upper and
	; halves of each stereo pair. There will be no
	; interference between carry out from the RHS MSB into bit 16 (LSB of
	; LHS sample), and no carry from bit 16 into bit 17, since we cleared
	; bit 16 in both sources (i.e. bit 16 and bit 0 of pre-rotated single source!)
	; beforehand; therefore the subsequent right shift will correctly put the
	; average of the two channel samples back into bits 15..0 (and also into
	; bits 31..16, using RRX to recover carry out from bit 31).
	; Get back to signed 16 bit result for each channel afterwards by EOR'ing
	; with 0x80008000.
	ADDS	r2, r2, r2, ROR #16
	EOR	r2, r12, r2, RRX
	ADDS	r3, r3, r3, ROR #16
	EOR	r3, r12, r3, RRX
	ADDS	r4, r4, r4, ROR #16
	EOR	r4, r12, r4, RRX
	ADDS	r5, r5, r5, ROR #16
	EOR	r5, r12, r5, RRX
	STMIA	r1, {r2,r3,r4,r5}	; store them all out
	CMP	r1, r0                  ; have we just done last loop?
        BNE     %B01                    ; round again if not
	B	BufferDone		; we're all done



; OverOnly:
;     Oversample, expanding buffer by factor of 2 by performing linear interpolation
;     between each pair of samples.  For the very first case, this uses a saved copy
;     of the last stereo sample pair word (2x16-bit) from the end of the previous
;     buffer, to interpolate against.  Note that this process is done in reverse
;     order (working from end of buffer back to start) to avoid overwriting the
;     initial data as would happen if we went forwards..
OverOnly 	ROUT
	LDR	r14, [r1, #-4]!		; get last sample in source buffer now
	EOR	r14, r14, r12		; convert signed to unsigned
	AND	r14, r14, r11		; mask LSB bits from this sample-pair
	ADD	r0, r0, #8*4		; need to do last group separately, so move base

01	LDMDB	r1!, {r3,r5,r7,r9}	; load 4 new samples

02	; convert from signed to unsigned format (into separate regs apart from r3)
	EOR	r3, r3, r12
	EOR	r6, r5, r12
	EOR	r8, r7, r12
	EOR	r10, r9, r12
	; clear off LSB from each value (two in each reg)
	AND	r3, r3, r11
	AND	r6, r6, r11
	AND	r8, r8, r11
	AND	r10, r10, r11
	; oversampling: average pairs and turn back to signed format
	ADDS	r4, r3, r6
	EOR     r4, r12, r4, RRX
	ADDS	r6, r6, r8
	EOR	r6, r12, r6, RRX
	ADDS	r8, r8, r10
	EOR	r8, r12, r8, RRX
  	ADDS	r10, r10, r14
	EOR     r10, r12, r10, RRX
	EOR	r14, r12, r14			; put r14 back to signed format also
	STMDB	r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results interleaved with originals
	MOV	r14, r3			; set lowest sample for end of next group
	CMP	r2, r0                  ; have we just done last normal loop?
        BHI     %B01                    ; round again if not
	BLO	BufferDone		; all done if done extra, special loop

 	; (r2==r0) for last special loop, pick up very first 3 samples from this buffer
 	LDMDB	r1!, {r5,r7,r9}
 	; get last sample from previous buffer, to interpolate for first new sample of this
 	LDR	r3, =SoundLevel0Base
 	LDR	r3, [r3, #SoundRMA]
 	LDR	r3, [r3, #SavedSample]
	B	%B02			; use main loop code to do it


; Convert to mono and oversample also
MonoOver	ROUT
	ADD	r0, r0, #8*4		; need to do last group separately, so move base

	LDR	r14, [r1, #-4]!		; get last sample in source buffer now
	EOR	r14, r14, r12		; convert signed to unsigned
	AND	r14, r14, r11		; mask LSB bits from this sample-pair
    	ADDS	r14, r14, r14, ROR #16	; convert to mono
    	AND	r14, r11, r14, RRX

01	LDMDB	r1!, {r3,r5,r7,r9}	; get four new samples: signed, full 16-bit, stereo

02	; convert from signed to unsigned format
	EOR	r3, r3, r12
	EOR	r5, r5, r12
	EOR	r7, r7, r12
	EOR	r9, r9, r12
	; clear off LSB from each value (two in each reg)
	AND	r3, r3, r11
	AND	r5, r5, r11
	AND	r7, r7, r11
	AND	r9, r9, r11
	; Monoise unsigned masked versions of input data; since we're also oversampling,
	; leave in unsigned form and mask off LSBs again
	ADDS	r3, r3, r3, ROR #16
	AND	r3, r11, r3, RRX
	ADDS	r5, r5, r5, ROR #16
	AND	r5, r11, r5, RRX
	ADDS	r7, r7, r7, ROR #16
	AND	r7, r11, r7, RRX
	ADDS	r9, r9, r9, ROR #16
	AND	r9, r11, r9, RRX
	; then oversample, generating new intermediate values in r4,r6,r8,r10, in signed format
	ADDS	r4, r3, r5
	EOR     r4, r12, r4, RRX
	ADDS	r6, r5, r7
	EOR	r6, r12, r6, RRX
	ADDS	r8, r7, r9
	EOR	r8, r12, r8, RRX
  	ADDS	r10, r9, r14
	EOR     r10, r12, r10, RRX
	; must convert monoised unsigned masked originals back to signed format also
	EOR	r5, r12, r5
	EOR	r7, r7, r12
	EOR	r9, r9, r12
	EOR	r14, r12, r14		; put r14 back to signed format also for store-out
	STMDB	r2!, {r4,r5,r6,r7,r8,r9,r10,r14} ; store final results, interleaved with originals
	MOV	r14, r3			; copy lo sample (mono,still unsigned & masked) for next group
	CMP	r2, r0                  ; have we just done last normalloop?
        BHI     %B01                    ; round again if not
	BLO	BufferDone		; return if just done extra, special loop

 	; r2==r0: finally, pick up very first 3 samples from this buffer
 	LDMDB	r1!, {r5,r7,r9}
 	; and last sample from previous buffer, to interpolate for first new sample of this
 	LDR	r3, =SoundLevel0Base
 	LDR	r3, [r3, #SoundRMA]
 	LDR	r3, [r3, #SavedSample]
 	; use main loop code to do final (earliest) 8 samples of output
 	B	%B02


;
; ConvImages
;
; Passed in a pointer in r0 to 8 bytes (Images), returns in r0 a word
; having bits 31:24 zero and with 24:0 being compacted image data for
; programming (8 x 3 bits, chan 0 in bits 2:0, 1 = MAX L, 7 =
; MAX R).  r1-r13 preserved.
ConvImages Entry r1
        ADD     r1, r0, #7              ; start with channel 7
        MOV     r0, #0                  ; initialise output in r0
10      LDRB    lr, [r1], #-1           ; get one byte
        CMP     lr, #&E0                ; convert from linear pos to SIR value
        ADDLT   lr, lr, #&10
        MOVS    lr, lr, LSR #5
        MOVEQ   lr, #1                  ; correct for min
        MOV     r0, r0, LSL #3          ; shift previous values left one channel pos
        ORR     r0, r0, lr              ; merge in this channel into bottom
        TST     r0, #7 :SHL: (7*3)      ; shifted channel 7 value into place yet?
                                        ; (all output values are 1..7, i.e. not 0)
        BEQ     %BT10                   ; go round again if not
        EXIT                            ; all done, go home

;
; ProgramImages
;
; Given a compact stereo image position set in r0, program VIDC
; with the values.  r0-r13 preserved.

ProgramImages Entry "r0-r3"
        MOV     r2, #SIR0               ; address channel 0 register
        MOV     r1, #VIDC
10      AND     r3, r0, #&7             ; get this channel
        CMP     r2, #SIR6+SIRSTEP       ; are we on channel 7? then fix regaddr
        MOVEQ   r2, #SIR7               ; to cope with out-of-order prog'ing
        ORR     r3, r3, r2              ; combine value and vidc reg addr
        STR     r3, [r1]                ; and program it
        ADD     r2, r2, #SIRSTEP        ; step on to next channel SIR address
        MOV     r0, r0, LSR #3          ; and shift down to next channel pos
        BNE     %BT10                   ; drop out if channel 7 done

        EXIT                            ; and go home

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CopyError Entry r1-r7
        BL      open_messagefile
        EXIT    VS
        ADD     R1, R12, #MessageFile_Block
        MOV     R2, #0
        MOV     R4, #0
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.SoundDMA.Messages", 0
        ALIGN

open_messagefile Entry r0-r2
        LDR     r0, [r12, #MessageFile_Open]
        CMP     r0, #0
        EXIT    NE
        ADD     R0, r12, #MessageFile_Block
        ADR     R1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        EXIT    VS
        MOV     r0, #1
        STR     r0, [r12, #MessageFile_Open]
        EXIT

 [ StorkPower
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       Power management routines
;

GetPower Entry "r1,r10,r11"
        LDR     r10, =SoundLevel0Base
        LDR     r11, [r10, #SoundRMA]

        MOV     R0, #0                          ; set masks for read
        MOV     R1, #&FFFFFFFF
        SWI     XPortable_Control               ; new = (old AND r1) EOR r0
        ANDVC   r1, r1, #SoundPowerBits         ; call ok, so extract sound bits
        MOVVS   r1, #SoundPowerBits             ; error, assume power is on
        STR     r1, [r11, #power_state]
        MOVVC   r1, #1                          ; call ok, mark module present
        MOVVS   r1, #0                          ; error
        STR     r1, [r11, #portable_present]
        EXIT

SetPower_On
        MOV     r0, #SoundPowerBits
        B       SetPower                        ; turn on power

SetPower_Off
        MOV     r0, #0                          ; turn power off

; and drop thru to...

SetPower Entry "r1,r10,r11"
        LDR     r10, =SoundLevel0Base
        LDR     r11, [r10, #SoundRMA]

        LDR     lr, [r11, #portable_present]    ; if no portable module present
        TEQ     lr, #0
        EXIT    EQ                              ; then do nothing

        LDR     lr, [r11, #power_state]         ; if current state = new state, do nothing
        TEQ     r0, lr
        EXIT    EQ

        MOV     r1, #:NOT:SoundPowerBits
        SWI     XPortable_Control               ; new = (old AND r1) EOR r0
        ANDVC   r1, r1, #SoundPowerBits
        STRVC   r1, [r11, #power_state]
        EXIT    VC

        MOV     r0, #0                          ; if we got an error
        STR     r0, [r11, #portable_present]    ; then set portable_present = FALSE
        MOV     r0, #SoundPowerBits
        STR     r0, [r11, #power_state]         ; and set power_state = ON
        EXIT

        LTORG
 ]

 [ StorkPower
  [ AdvancedPower
        ; Check the buffer for being all 0.
;
; Scan the buffer just filled, to see if it is silent (all zeroes) or noisy (non-zero).
; If the buffer is noisy, we must ensure that the sound hardware (filters & amplifier etc)
; is switched on. If the buffer is quiet, we increment PowerControl and compare it against
; a threshold (PowerContThres2). If the threshold is reached, we switch the sound hardware
; off. The threshold value is of course a compromise; a short value to minimise power
; consumption verses a long one to minimise annoying clicks from the speaker.
;
StorkCode
StorkCodeStart ROUT
        MOV     r0, #0
StorkCodeLoop1
        LDMIA   r12!, {r1-r4}
        ORR     r0, r0, r1
        ORR     r0, r0, r2
        ORR     r0, r0, r3
        ORR     r0, r0, r4
        CMP     r12, r10
        BLO     StorkCodeLoop1
        TEQ     r0, #0                          ;if r0 is 0, the sound system is quiet

        MOVNE   r0, #0                          ;NE, making a noise, so
        STRNE   r0, [r9, #PowerControl]         ;NE, zero counter
        MOVNE   r0, #SoundPowerBits             ;NE, and ensure sound system is powered up
        BNE     SetPower_

        LDR     r0, [r9, #PowerControl]         ;'next' buffer is quiet, so inc counter
        ADD     r0, r0, #1                      ;
        CMP     r0, #PowerContThres2            ; (limit count at threshold)
        MOVGE   r0, #PowerContThres2            ;
        STR     r0, [r9, #PowerControl]         ;

        MOVLT   pc, lr                          ;LT, not hit threshold, so leave power 'as-is'

        MOVGE   r0, #0                          ;hit switch off threshold, so power down

SetPower_
        Push    "LR"                            ;IRQ_LR

        LDR     lr, [r9, #power_state]
        TEQ     r0, r9
        Pull    "PC",EQ

       ;SVCMode r3
        SavePSR r3
        WritePSRc I_bit :OR: SVC_mode, r4
        NOP

        Push    "LR"                            ;save SVC_LR
        BL      SetPower
        Pull    "LR"                            ;restore SVC_LR

        RestPSR r3
        NOP

        Pull    "PC"
StorkCodeEnd
StorkCodeSize * StorkCodeEnd - StorkCodeStart
  ]
 ]

    GET Sound0_SA.s

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ debug
        InsertNDRDebugRoutines
 ]

        END

