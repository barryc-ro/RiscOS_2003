        TTL     => MoreComms

Error_Code ROUT
        ; Use MessageTrans to construct an error block by substituting the error text into
        ; an error

        Push    "r7,r8,lr"

        ASSERT  ?Error_CodeTag <= 8
        ADR     lr, Error_CodeTag
        LDMIA   lr, {r1,r2}
        Push    "r1,r2"

        MOV     r1, r0          ; pointer
        MOV     r0, #0          ; base
        SWI     XOS_ReadUnsigned
        Push    "r2"

        MOV     r0, sp          ; Error block
        BL      TranslateError_VClear

        ; If error number's changed don't substitute
        LDR     r3, [r0]
        TEQ     r3, r2
        BNE     %FT90

        ; GSTrans the text into the error buffer
        MOV     r3, r0
        MOV     r0, r1
        ADD     r1, r3, #4
        MOV     r2, #252
        SWI     XOS_GSTrans

        ; Ensure 0-terminated
        MOV     r0, #0
        CMP     r2, #252
        MOVHI   r2, #252
        STRB    r0, [r1, r2]

        MOV     r0, r3
90
        ADD     sp, sp, #12
        Pull    "r7,r8,lr"
        ORRS    pc, lr, #V_bit

Error_CodeTag DCB "ErrSub", 0

        LTORG

Eval_Code ROUT
             Push  "lr"
             LDR    R1, =GeneralMOSBuffer
  [ LongCommandLines
             MOV    R2, #LongCLISize
  |
             MOV    R2, #256
  ]
             SWI    XOS_EvaluateExpression
             Pull  "PC", VS
             Push   "r4"
             CMP    R1, #0
             ADREQ  R0, %FT01
             ADRNE  R0, %FT02
             BL     FindToken
             MOV    R4,R0
             BL     WriteS_Translated_UseR4
             =      "Result:Result is %0, value :",0
             ALIGN
             Pull   "r4"
 
             LDREQ  R1, =GeneralMOSBuffer
             MOVEQ  R0, R2
             MOVEQ  R2, #256
             SWIEQ  XOS_BinaryToDecimal
             MOV    R5, #-1
03           ADD    R5, R5, #1
             CMP    R5, R2
             BEQ    %FT04
             LDRB   R0, [R1, R5]
             CMP    R0, #&7F
             MOVEQ  R0, #"?"-"@"   ; preversion!!
             CMP    R0, #31
             ADDLE  R0, R0, #"@"
             SWILE  XOS_WriteI+"|"
             Pull  "PC", VS
             CMP    R0, #"|"
             CMPNE  R0, #""""
             CMPNE  R0, #"<"
             SWIEQ  XOS_WriteI+"|"
             SWIVC  XOS_WriteC
             BVC    %BT03

04           SWIVC  XOS_NewLine
             Pull  "PC"

01
    =    "Integer:an integer",0
02
    =    "String:a string",0

    ALIGN

;****************************************************************************
; Coupla utility commands

Time_Code    ROUT
     Push   "lr"
     LDR     R1, =GeneralMOSBuffer
 [ LongCommandLines
     ;take opportunity to fix occasional infelicity - re-use of GeneralMOSBuffer sometimes
     ;scrambles a time message the first time it happens in a Taskwindow
     ASSERT  LongCLISize >= 512
     ADD     R1, R1, #256
 ]
     MOV     R0, #0
     STRB    R0, [R1]
     MOV     R0, #14
     SWI     XOS_Word
     MOVVC   R0, R1
     MOVVC   R1, #24
     SWIVC   XOS_WriteN
     SWIVC   XOS_NewLine
     Pull   "PC"


Ignore_Code  ROUT
     Push   "lr"
     MOVS    R4, R1
     MOV     R1, R0
     MOV     R0, #10+ (1:SHL:30)
     SWINE   XOS_ReadUnsigned
     Pull   "PC", VS
     MOV     R6, R2        ; maybe number
     BL      CheckEOL
     BNE     %FT01

     CMP     R4, #0
     MOV     R0, #&B6
     MOVEQ   R1, #255
     MOVNE   R1, #0
     MOV     R2, #0
     SWI     XOS_Byte
     MOV     R0, #6
     MOV     R1, R6
     SWINE   XOS_Byte
     Pull   "PC"

01   ADRL    R0, ErrorBlock_BadNumb
     BL      TranslateError
     Pull   "PC"

;*****************************************************************************

ROMModules_Code ENTRY
        BL      GSWriteS_Translated
        =       "ROMMTitle:No. Position|IModule Name|I|IVersion|IStatus|M|J",0
        EXIT    VS
        MOV     r1, #0
        MOV     r2, #-1
01
        SWI     XOS_ReadEscapeState
        PullEnv CS
        BCS     AckEscape
        MOV     r0, #ModHandReason_EnumerateROM_ModulesWithInfo
        SWI     XOS_Module
        EXITS   VS                                      ; exit V clear

; R1 = module number +1
; R2 = podule number
; R3 -> name
; R4 = status (-1 unplugged, 0 dormant, 1 active, 2 running)
; R5 = chunk number
; R6 = version number

; Copy info into buffer and prettyprint

        MOV     r5, r1                                  ; save r1 and r2 for next call to OS_Module
        MOV     r10, r2
        MOV     r0, r1
        LDR     r1, =GeneralMOSBuffer
        MOV     r2, #256
        SWI     XOS_ConvertCardinal2
        SUB     r12, r1, r0                             ; characters in buffer
02
        CMP     r12, #3                                 ; tab out to 3 characters
        SWICC   XOS_WriteI+" "
        EXIT    VS
        ADDCC   r12, r12, #1
        BCC     %BT02
        MOV     r0, #" "
        BL      %FT20                                   ; add space
        CMP     r10, #-1
        ADREQL  r0, rommpossysrom
        ADRLTL  r0, rommposextrom
        ADRGTL  r0, rommpospodule
        BL      FindToken
        BL      %FT21                                   ; add string
        MOVGT   r0, r10                                 ; if normal podule then use plain number (flags still set from CMP)
        MVNLT   r0, r10                                 ; if extension ROM then NOT it (-2 => 1, -3 => 2 etc)
        SWINE   XOS_ConvertCardinal1
        MOV     r0, #TAB
        BL      %FT20                                   ; tab to col. 16
        MOV     r0, r3
        BL      %FT21                                   ; copy name in
        MOV     r3, r0                                  ; string length
        MOV     r0, #TAB
03
        CMP     r3, #24
        ADDCC   r3, r3, #8
        BLCC    %FT20
        BCC     %BT03

        MOV     r11, #"0"
        TST     r6, #&F0000000                          ; 1st digit of integer part
        ORRNE   r0, r11, r6, LSR #28
        BLNE    %FT20
        MOV     r6, r6, LSL #4
        TSTEQ   r6, #&F0000000                          ; 2nd digit of integer part
        ORRNE   r0, r11, r6, LSR #28
        BLNE    %FT20
        MOV     r6, r6, LSL #4
        TSTEQ   r6, #&F0000000                          ; 3rd digit of integer part
        ORRNE   r0, r11, r6, LSR #28
        BLNE    %FT20
        MOV     r6, r6, LSL #4
        ORR     r0, r11, r6, LSR #28                    ; 4th digit of integer part
        BL      %FT20
        MOV     r0, #"."
        BL      %FT20
        MOV     r6, r6, LSL #4
        ORR     r0, r11, r6, LSR #28                    ; 1st digit of decimal part
        BL      %FT20
        MOV     r6, r6, LSL #4
        ORR     r0, r11, r6, LSR #28                    ; 2nd digit of decimal part
        BL      %FT20
        MOVS    r6, r6, LSL #4                          ; only print 3rd and 4th digits of decimal part if non-zero
        ORRNE   r0, r11, r6, LSR #28
        BLNE    %FT20
        MOVS    r6, r6, LSL #4
        ORRNE   r0, r11, r6, LSR #28
        BLNE    %FT20
        MOV     r0, #TAB
        BL      %FT20

        CMP     r4, #0
        ADRMIL  r0, rommstatu
        ADREQL  r0, rommstatd
        ADRGTL  r0, rommstata
        BL      FindToken
        CMP     r4, #2
        ADREQL  r0, rommstatr
        BLEQ    FindToken
        BL      %FT21
        MOV     r0, #13
        BL      %FT20
        MOV     r0, #0
        BL      %FT20
        LDR     r0, =GeneralMOSBuffer
        MOV     r1, #0
        SWI     XOS_PrettyPrint
        EXIT    VS
        MOV     r1, r5
        MOV     r2, r10
        B       %BT01

; R1 buffer ptr, R2 bufflen left

20
        SUBS    r2, r2, #1
        STRPLB  r0, [r1], #1
        MOVS    pc, lr
21
        Push    "r0, lr"
        MOV     r12, r0
22
        LDRB    r0, [r12], #1
        CMP     r0, #TokenEscapeChar
        BEQ     %FT23
        CMP     r0, #0 
        CMPNE   r0, #10
        BLNE    %BT20
        BNE     %BT22
        Pull    "r0, lr"
        SUB     r0, r12, r0       ; length of string
        SUB     r0, r0, #1
        MOVS    pc, lr

23
        BL      %BT20
        LDRB    r0, [r12], #1
        BL      %BT20
        B       %BT22

rommpossysrom
     =   "SYSROM:System ROM", 0
rommposextrom
     =   "EXTROM:Extn ROM", 0
rommpospodule
     =   "PODROM:Podule", 0

rommstata
     =   "Active:Active", 0

rommstatd
     =   "Dormant:Dormant", 0

rommstatu
     =   "Unplugged:Unplugged", 0

rommstatr
     =   "Running:Running",0

     ALIGN

;*****************************************************************************

RMEnsure_Code ENTRY "r0, r1"
        MOV     r1, r0                          ; name pointer
        MOV     r0, #ModHandReason_LookupName
        SWI     XOS_Module
        MOVVS   r10, r0                         ; module handler will build a nice error
        BVS     RMEDoCommand                    ; module not found
        LDR     r0, [stack]                     ; now find version number
01
        LDRB    r6, [r0], #1
        CMP     r6, #" "
        BNE     %BT01
        BL      RMEGetVerNo
        MOV     r6, r1
        LDR     r0, [r3, #Module_HelpStr]
        TEQ     r0, #0
        BEQ     RMEDoCommand                    ; no help string, so do command
        ADD     r0, r0, r3
        BL      GetVerNoFromHelpString
        CMP     r1, r6
        EXIT    GE
        MOV     r10, #0
RMEDoCommand
        Pull    "r0, r1"
        CMP     r1, #2
        BEQ     BuildRMEnsureError
04
        LDRB    r1, [r0], #1
        CMP     r1, #" "
        BNE     %BT04
05
        LDRB    r1, [r0], #1
        CMP     r1, #" "
        BEQ     %BT05
06
        LDRB    r1, [r0], #1
        CMP     r1, #" "
        BNE     %BT06
        SUB     r0, r0, #1
03
        SWI     XOS_CLI
        Pull    PC

BuildRMEnsureError
        MOVS    r0, r10
        Pull    lr, NE
        ORRNES  pc, lr, #V_bit
        ADR     r0, ErrorBlock_ModuleTooOld
        LDR     r4,[r3, #Module_Title]
        ADD     r4,r4,r3
        BL      TranslateError_UseR4
        Pull    "LR"
        ORRS    PC,LR,#V_bit

rmecopystr
        LDRB    r2, [r0], #1
        CMP     r2, #32
        STRGEB  r2, [r5], #1
        BGE     rmecopystr
        MOV     pc, lr

        MakeErrorBlock ModuleTooOld

; *************************************************************************
;
;       RMEGetVerNo - Read version number from a string
;
; in:   R0 -> string
;
; out:  R0, R4, R5, R12 corrupted
;       R1 = version number in BCD with the decimal point between bits 15 and 16
;            eg "2.34" => &00023400, "5.6789" => &00056789, "17" => &00170000
;            only the last 4 digits of the integer part, and the first 4 decimal places are stored
;

RMEGetVerNo ENTRY
        MOV     r1, #0
10
        LDRB    r12, [r0], #1
        CMP     r12, #" "
        BEQ     %BT10
11
        SUB     r12, r12, #"0"
        CMP     r12, #9
        ORRLS   r1, r12, r1, LSL #4             ; just keep nibbles - we only need the
        LDRLSB  r12, [r0], #1                   ; result to be ordered, not continous
        BLS     %BT11
        MOV     r5, #0
        CMP     r12, #"."-"0"
        BNE     %FT13
        MOV     r4, #16
12
        SUBS    r4, r4, #4
        BMI     %FT13
        LDRB    r12, [r0], #1
        SUB     r12, r12, #"0"
        CMP     r12, #9
        ORRLS   r5, r5, r12, LSL r4
        BLS     %BT12
13
        ORR     r1, r5, r1, LSL #16
        EXIT

; *************************************************************************
;
;       GetVerNoFromHelpString - Read version number from a module help string
;
; in:   R0 -> module help string
;
; out:  R1 = version number in BCD with the decimal point between bits 15 and 16
;            eg "2.34" => &00023400, "5.6789" => &00056789, "17" => &00170000
;            only the last 4 digits of the integer part, and the first 4 decimal places are stored
;       All other registers preserved
;

GetVerNoFromHelpString ENTRY "r0, r4, r5, r12" 
        MOV     r5, #0                          ; char count
10
        LDRB    r1, [r0], #1
        CMP     r1, #0                          ; check character
        EXIT    EQ                              ; if end of string then no version number so return zero
        ADD     r5, r5, #1
        CMP     r1, #TAB
        ADDEQ   r5, r5, #7
        BICEQ   r5, r5, #7
        CMP     r5, #16                         ; hit verno col yet?
        BLT     %BT10
20
        LDRB    r1, [r0], #1
        CMP     r1, #TAB
        CMPNE   r1, #31                         ; if a control character (except TAB)
        MOVLT   r1, #0                          ; then no version number so return zero
        EXIT    LT
        SUB     r1, r1, #"0"
        CMP     r1, #9                          ; if not a digit
        BHI     %BT20                           ; then try next character
        SUB     r0, r0, #1                      ; was a digit so go back to it
        BL      RMEGetVerNo                     ; read version number from here
        EXIT

        END
