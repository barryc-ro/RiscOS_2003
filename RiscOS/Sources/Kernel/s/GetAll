; > GetAll

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetCPU
        $GetIO
        $GetMEMC
        $GetMEMM
        $GetVIDC

;whether compiling to run on (Risc PC) emulator
                GBLL    RunningOnEmul
RunningOnEmul   SETL    {FALSE}

;
; we can only build for medusa-ish h/w
;
        ASSERT Keyboard_Type = "PC"
        ASSERT CPU_Type      = "ARM600"
        ASSERT IO_Type       = "IOMD"
        ASSERT VIDC_Type     = "VIDC20"
        ASSERT MEMC_Type     = "IOMD"
        ASSERT MEMM_Type     = "ARM600"

; mjs:
; We cannot build for STB. If STB code is ever 're-merged', it is suggested
; that it is done in a more structured way than a basic CVS munge with
; fix-ups. For example, look at separating files for affected, hardware
; dependent areas of kernel. This is a lot of work, but is better than
; the obfuscation caused by pretend hardware abstraction.
;
        ASSERT :LNOT: STB
;
; We choose to distinguish IOMD variants by differing IOMD_ID0 bytes only
;
; Note that decision points based on IOMD variant now do exhaustive checks,
; and deliberately hang up in a loop for unrecognised IOMD. The panic
; hang-up loops continually read IOMD_ID0, so that examining the hang up
; with a logic analyser will give a clue. Doing exhaustive checks like
; this may seem a bit verbose, but is much less ad hoc than previous
; hacks, and may make it easier to see how to add support for other
; variants.
;
        ASSERT (IOMD_7500FE   :AND: &FF) < (IOMD_7500     :AND: &FF)
        ASSERT (IOMD_7500     :AND: &FF) < (IOMD_Original :AND: &FF)
        ASSERT (IOMD_Original :AND: &FF) < (IOMD_IOMD2    :AND: &FF)


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; essential global variables
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                GET   Version
                GBLS  VersionNo
VersionNo       SETS  "$VString ($Date)"

                GBLS  SystemName
SystemName      SETS  "RISC OS" ; ", p.k.a. Arthur a.k.a. Richard III"

                GBLS  MosTitle
MosTitle        SETS  "$SystemName $VersionNo"

                GBLL  AddTubeBashers
AddTubeBashers  SETL  {FALSE}

Tube_Normal     *       1
Tube_Simulator  *       2

                GBLA    TubeType
TubeType        SETA    Tube_Simulator

UserMemStart    * &8000


AssemblingArthur SETL  {TRUE}
      ASSERT AssemblingArthur   ;must be defined TRUE (some conditional code removed)
; defined in hdr.system to allow conditionals in macros

                GBLL    DoingVdu
DoingVdu        SETL    {FALSE}         ; so can get KeyWS!
                GBLL    Module
Module          SETL    {FALSE}

                GBLL    IncludeTestSrc  ; whether test code is included
IncludeTestSrc  SETL    {FALSE}


 [ RunningOnEmul
IncludeTestSrc  SETL    {FALSE}
 ]


;these are large-scale options, not necessarily controlling all code, but enough to allow
;some code size reduction, and to restrict ROM capability if desired
;
                  GBLL    ARM67Support        ;whether to support ARM6 and ARM7 cpu (610,710,cpu in 7500)
                  GBLL    ARMSASupport        ;whether to support StrongARM cpu (SA110,SA120)
                  GBLL    ARMSASupport_RevS   ;whether we can assume Revision S SA110 (rev 3 in ID register) or better
                  GBLL    ARMSASupport_Only   ;whether we can assume StrongARM cpu (SA110,SA120)
                  GBLL    IOMD1Support        ;whether to support IOMD 1 platforms (Risc PC,A7000)
                  GBLL    IOMD2Support        ;whether to support IOMD 2 platforms (Phoebe)
ARM67Support      SETL    {FALSE}
ARMSASupport      SETL    {TRUE}
ARMSASupport_RevS SETL    {TRUE}
ARMSASupport_Only SETL    ARMSASupport :LAND: (:LNOT: ARM67Support)
IOMD1Support      SETL    {FALSE}
IOMD2Support      SETL    {TRUE}
;
                  ASSERT  ARM67Support :LOR: ARMSASupport
                  ASSERT  IOMD1Support :LOR: IOMD2Support
;
    ! 0, "--"
  [ ARM67Support
    ! 0, "-- Compiling support for ARM 6,7 cpu's"
  ]
  [ ARMSASupport
    [ ARMSASupport_RevS
      ! 0, "-- Compiling support for StrongARM cpu's (SA-110 rev S or better)"
    |
      ! 0, "-- Compiling support for StrongARM cpu's"
    ]
  ]
  [ IOMD1Support
    ! 0, "-- Compiling support for IOMD1 platforms"
  ]
  [ IOMD2Support
    ! 0, "-- Compiling support for IOMD2 platforms"
  ]
    ! 0, "--"

;StrongARM support options
                       GBLL    SAcleanflushbroken      ;whether StrongARM single MCR for DC clean+flush broken (is always for SA110)
                       GBLL    SASTMhatbroken          ;whether ROM must support SA110's with broken STM^ (those before rev S)
                       GBLL    SALDMIBbroken           ;whether LDMIB Rn,{Reg list including Rn} cannot be reliably restarted after abort
                                                       ;on some StrongARMs (those before rev T)
                       GBLL    StrongARM_POST          ;whether to run POST for StrongARM (and possibly ARM8)
SA120minimumrev        * 9                             ;ARM id revision at which SA-120 introduced (kernel uses mini data cache for screen)
SAcleanflushbroken     SETL {TRUE}
SASTMhatbroken         SETL :LNOT: ARMSASupport_RevS   ;is broken before rev S - this flag now derived from ARMSASupport_RevS
SALDMIBbroken          SETL {TRUE}                     ;is broken before rev T
  [ SALDMIBbroken
SALDMIBfixedrev        * 4                             ;fixed in revision T SA110 (ARM id revision field = 4)
  ]
StrongARM_POST         SETL {TRUE}


;;;TEMPORARY - all PhoebeBodge code should ultimately be removed completely (not just switched out)

                     GBLL    PhoebeBodge
                     GBLL    PhoebeBodge_OldVCO   ;1st (FPGA) board has old style VCO, 2nd (FPGA/ASIC) board has new VCO
                     GBLL    PhoebeBodge_Bernard  ;temp kludge to avoid programming CURSINIT, for ASIC debug
                     GBLL    PhoebeBodge_Bernard2 ;temp kludge for external abort retry debug
                     GBLL    PhoebeBodge_Slow     ;assume ? MHz clock for 100Hz ticker, rather than 64 MHz
PhoebeBodge          SETL    {FALSE}
PhoebeBodge_OldVCO   SETL    {FALSE}
PhoebeBodge_Bernard  SETL    {FALSE}
PhoebeBodge_Bernard2 SETL    {FALSE}
PhoebeBodge_Slow     SETL    {FALSE}

                GBLL    IOMD2_VIDMRDbroken
IOMD2_VIDMRDbroken SETL {TRUE}              ;looks like this won't be fixed in ASIC

Phoebe_VRAMsize *       &400000             ;must be 4M currently (see ASSERTion for code that depends on this)

                GBLL    Phoebe_SoftROM
Phoebe_SoftROM  SETL    {TRUE}              ;whether to automagically soft load ROM on Phoebe, for speed
                       
                GBLL    KeepCachesOff       ;for logic analyser debug
KeepCachesOff   SETL    {FALSE}


;RISC OS 3.71 onwards assumed bus timings - ROM speeds atc are assumed according to IOMD ID regs. as follows:
;     if IOMD (Risc PC)     ROM ticks 5-3 (assumed bus 32 MHz)
;     if 7500 (A7000)       ROM ticks 5-3 (assumed bus 32 MHz), all clocks divide-by-1
;     if 7500FE (A7000+)    ROM ticks 5-3, half speed (asssumed bus 64 MHz), EDO memory, divide-by-2 I/O, divide-by-1 CPU and memory
;     if IOMD2 (Phoebe)     ROM ticks 10-6 (assumed bus 64 MHz)
;

                   GBLL  Select16BitSound
                   GBLL  Japanese16BitSound
Select16BitSound   SETL  {TRUE}
Japanese16BitSound SETL  {TRUE}


                GBLL   SqueezeMods             ; whether squeezed modules are allowed
SqueezeMods     SETL   {TRUE}


;mjs WARNING:
;  Setting this {TRUE} slows the whole OS down significantly (eg. when booting directories),
;  and is suspected to sometimes cause phantom unexpected errors because of flooding the
;  global MessageTrans buffers.
;  The English errors will rarely if ever be seen by the user. If a project really thinks the
;  world will stop spinning on seeing an English error, a scheme where the errors are
;  internationalised _once_ into (say) a SysHeap block should probably be used (this was not
;  considered worthwhile for Ursula).
;
                GBLL    InternationaliseCommonSilentErrors
InternationaliseCommonSilentErrors SETL {FALSE}

                GBLL    LCDInvert
LCDInvert       SETL    {TRUE}

                GBLL    MakeModeSelectorsForModeNumbers
MakeModeSelectorsForModeNumbers SETL   {FALSE}    ; not actually needed after all

                GBLL    IgnoreVRAM              ; if true, don't add VRAM to the RAM list (+ don't use for screen)
IgnoreVRAM      SETL    {FALSE}

                GBLL    ShrinkableDAs           ; if true, support Shrinkable Dynamic Areas (eg. CacheFS)
ShrinkableDAs   SETL    {TRUE}

                GBLL    Interruptible32bitModes
Interruptible32bitModes SETL {TRUE}             ;if true, limited 32-bit mode code support (interrupt handler does not assume
                                                ; 26-bit foreground), also allows faster, 32-bit APCS version of FPEmulator

                 GBLL   LongCommandLines        ;introduced for Ursula
LongCommandLines SETL   {TRUE}
  [ LongCommandLines
LongCLISize          * 1024                     ;buffer size for long commands
  ]

                  GBLL  KernelOwnsRAMFSDA           ; may be set false later for Ursula (if RAMFS takes on ownership)
                  GBLL  EarlierReentrancyInDAShrink ; fix for RAMFS and new FileCore (causes reentrant DA shrink/remove)
KernelOwnsRAMFSDA SETL  {TRUE}
EarlierReentrancyInDAShrink SETL {TRUE}

                GBLL    NewRAMFS                    ; if this is TRUE then we're running a new FileCore variant of
NewRAMFS        SETL    {TRUE}                      ; RAMFS.  different handling of the RAMFS pregrow etc results

                GET     hdr:FileCore
                GET     hdr:RAMFS

                GBLL    RescueVRAM              ;whether to run process that rescues VRAM pages that are not in use for the screen
                                                ;and sorts them into the bottom of the free pool - implements use of VRAM as a last resort
                                                ;(maybe useful on Risc PC, important on Phoebe where VRAM is slower than SDRAM)

                ;mjs
                ;concept of sparsely mapped dynamic areas introduced for Ursula
                GBLL    DA_Batman               ;Holy dynamic areas Batman!

                ;mjs
                ;Chocolate flavours implemented for Ursula, but they are generally useful performance enhancements
                ;(not all Ursula performance improvements are flagged with Chocolate - eg. simple changes such as slicker SWI
                ;despatch and wider SWI hashing)
                ;
                ;disabled at run time if not StrongARM
                GBLL    ChocolateScreen         ;whether to implement crazy chocolate flavour screen (section mapped and cacheable) on SA
                GBLL    ChocolateAMB            ;whether to implement crazy chocolate flavour AMBControl (lazy task swapping) on SA
                                                ;if LDMIBbroken is TRUE, ChocolateAMB is not forced FALSE, but the kernel does suspend
                                                ;chocolate task swapping at run time (allows use with fixed SA, or use with apps
                                                ;cleaned of LDMIBs or whatever)

                ;any ARM
                GBLL    ChocolateSysHeap        ;whether to save cost of SysHeap block claim/release for common cases (eg. callback blocks)
                                                ;also reduces SysHeap stress by using fewer blocks in total
                GBLL    ChocolateOSMod          ;whether to reduce SysHeap stress in module handling
                GBLL    ChocolateSysVars        ;whether to do performance improvements in system variable handling
                GBLL    ChocolateOscli          ;whether to do performance improvements in Oscli command stuff
                GBLL    ChocolateService        ;whether to implement fast module service call distribution (uses table introduced
                                                ;into module format by Ursula API

RescueVRAM             SETL {TRUE}

DA_Batman              SETL {TRUE}

ChocolateScreen        SETL {TRUE}
ChocolateAMB           SETL {TRUE} :LAND: ARMSASupport
;
ChocolateSysHeap       SETL {TRUE}
ChocolateOSMod         SETL {TRUE}
ChocolateSysVars       SETL {TRUE}
ChocolateOscli         SETL {TRUE}
ChocolateService       SETL {TRUE}
  [ ChocolateSysHeap
                       GBLA  MaxChocolateCBBlocks  ;max quick CallBack blocks available at any one time (else ordinary heap nodes used)
                       GBLA  MaxChocolateSVBlocks  ;max quick Software Vector blocks available at any one time (else ordinary heap nodes used)
                       GBLA  MaxChocolateTKBlocks  ;max quick Ticker blocks available at any one time (else ordinary heap nodes used)
                       GBLA  MaxChocolateMRBlocks  ;max module ROM blocks before ordinary heap nodes are used (reduces total no. nodes in SysHeap)
                       GBLA  MaxChocolateMABlocks  ;max module Active blocks before ordinary heap nodes are used
                       GBLA  MaxChocolateMSBlocks  ;max module SWI Hash blocks before ordinary heap nodes are used
MaxChocolateCBBlocks   SETA   32
MaxChocolateSVBlocks   SETA  128
MaxChocolateTKBlocks   SETA   32
MaxChocolateMRBlocks   SETA  150
MaxChocolateMABlocks   SETA  150
MaxChocolateMSBlocks   SETA  150
  ]


                GBLL    VCOstartfix              ;code in early kernel to fix VCO start problem on A7000 (esp. 7500FE)
VCOstartfix     SETL    {TRUE}


                     GBLL    mjsServiceTrace          ;for statistics gathering on service calls only
mjsServiceTrace      SETL    {FALSE}
                     GBLL    mjsSysHeapNodesTrace     ;for statistics gathering on some SysHeap nodes only
mjsSysHeapNodesTrace SETL    {FALSE}


                GBLL    RMTidyDoesNowt          ; if true, RMTidy does nothing
RMTidyDoesNowt  SETL    {TRUE}                  ; should really be "machine has FSLock in ROM"

                GBLL    DebugROMInit
DebugROMInit    SETL    {FALSE}

                GBLL    DebugROMErrors
DebugROMErrors  SETL    {FALSE}

                GBLL    DebugHeaps              ; initialise claimed and freed blocks
DebugHeaps      SETL    {FALSE}                 ; (may slow things down unacceptably)

; ChangeDynamicArea and related options

        GBLL    DebugCDA
DebugCDA SETL {FALSE}

        GBLL    DebugCDA2
DebugCDA2 SETL {FALSE}


                GBLL    StorkPowerSave  ;True => power saving for Stork AND A4
StorkPowerSave  SETL    {TRUE}          ;False=> older A4 code only

                GBLL    LCDSupport      ;Whether LCD Support is assembled in or not
LCDSupport      SETL    {TRUE}
                                        ;(First intro'd for Stork)

                GBLL    FixR9CorruptionInExtensionSWI   ; whether R9 corruption by ExtensionSWI handler is fixed
FixR9CorruptionInExtensionSWI   SETL    {FALSE}         ; currently FALSE as CC's !SpellMod (possibly others) rely on it being broken


                GBLL    ValidateCMOS            ; reset CMOS if checksum wrong on start-up
ValidateCMOS    SETL    {TRUE}

              [ DebugHeaps
                ! 0, "*** WARNING *** Heap debugging assembled in"
              ]

                GBLS    GetMessages
GetMessages     SETS    "GET s.MsgCode"

                GBLL    DebugForcedReset        ; debug forced hard resets
DebugForcedReset SETL   {FALSE}

                GBLA    ConfiguredLang
ConfiguredLang  SETA    10                      ; default configured language

                GBLA    FirstUnpluggableModule
FirstUnpluggableModule SETA 8                   ; Podule, FileSwitch, ResourceFS, Messages, MessageTrans,
                                                ; TerritoryManager, UKTerritory

 [ DebugForcedReset
Reset_CannotResetFlag           * 1
Reset_SysHeapCorrupt            * 2
Reset_WrongCamMapAddress        * 3
Reset_WrongNumberOfPages        * 4
Reset_CamMapCorrupt             * 5
Reset_VectorChainCorrupt        * 6
Reset_TickNodesCorrupt          * 7
Reset_DeviceVectorCorrupt       * 8
Reset_PoduleOrCallBackCorrupt   * 9
 ]

; Flags for RISC OS Blue changes
;
                        GBLL    AssembleA1KeyHandler
AssembleA1KeyHandler    SETL    {FALSE}
                        GBLL    AssembleKEYV
AssembleKEYV            SETL    {TRUE}          ; Use KEYV.
                        GBLL    AssemblePointerV
AssemblePointerV        SETL    {TRUE}          ; Use PointerV.
                        GBLL    PollMouse
PollMouse               SETL    {FALSE}         ; Poll mouse.

                    GBLS  GetUnsqueeze
 [ SqueezeMods
GetUnsqueeze        SETS  "GET s.Unsqueeze"
 |
GetUnsqueeze        SETS  ""
 ]
                    GBLS  GetPublicWS
                    GBLS  GetWorkspace
                    GBLS  GetKernelMEMC
                    GBLS  GetPalette
                    GBLS  GetMemInfo

GetPublicWS         SETS  "GET Hdr:PublicWS"
GetWorkspace        SETS  "GET Hdr:KernelWS"
GetKernelMEMC       SETS  "GET s.ARM600"
GetMemInfo          SETS  "GET s.MemInfo"

GetPalette          SETS  "GET s.Vdu.VduPal20"

                    GBLS    GetRS423
GetRS423            SETS  ""

                    GBLS  GetKbdDrA1
GetKbdDrA1          SETS  ""

                    GBLS  GetKbdRes
GetKbdRes           SETS  "GET s.KbdResPC"

                    GBLS  GetKey2
 [ AssembleA1KeyHandler
GetKey2             SETS  "GET s.PMF.Key2"
 |
GetKey2             SETS  ""
 ]

;flood fill routine params
smallest_rma_size   * (48*1024)                  ; define the low threshold for rma use
largest_rma_size    * (128*1024)                 ; and the ceiling for rma use


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; now get the headers
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        GET     Hdr:CMOS
        GET     Hdr:Heap
        $GetPublicWS
        $GetWorkspace
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:HighFSI
        GET     Hdr:NewErrors
        GET     Hdr:Proc
        GET     Hdr:Sprite
        GET     Hdr:KeyWS
        GET     Hdr:RS423
        GET     Hdr:ModHand
        GET     Hdr:Variables
        GET     Hdr:EnvNumbers
        GET     Hdr:UpCall
        GET     Hdr:Sound
        GET     Hdr:Pointer
        GET     Hdr:Podule
        GET     Hdr:VduExt
;        GET     Hdr:Fox
        GET     Hdr:Buffer
        GET     Hdr:Font
        GET     Hdr:DevNos
;        GET     Hdr:IOEB
        GET     Hdr:Territory
        GET     Hdr:Portable
        GET     Hdr:MsgTrans
        GET     Hdr:PaletteV
        GET     Hdr:Wimp
        GET     Hdr:ColourTran
        GET     Hdr:Debug
        GET     s.PMF.DEF          ; Common with 6502 code in the keyboard
        Protocol

; now the main parts of the MOS

        GET     s.Copro15ops ; some macros

        GET     s.Kernel
        GET     s.NewIRQs
        GET     s.Oscli
        GET     s.SysComms
        GET     s.HeapMan
        GET     s.ModHand
        $GetUnsqueeze
        GET     s.ArthurSWIs
        GET     s.ChangeDyn
        GET     s.Arthur2
        GET     s.Utility
        GET     s.MoreComms
        GET     s.Convrsions
        GET     s.MoreSWIs
        GET     s.ExtraSWIs
        GET     s.HeapSort
        GET     s.Arthur3
        GET     s.SWINaming
        GET     s.TickEvents
        $GetKbdRes
        GET     s.NewReset
        $GetMessages
        GET     s.Middle
        GET     s.Super1
        $GetKernelMEMC
        $GetMemInfo
        ! 0, "Main kernel size = &" :CC: :STR: (.-ROM)
StartOfVduDriver
        GET     s.vdu.VduDriver
        GET     s.vdu.VduSWIs
        GET     s.vdu.VduPalette
        $GetPalette
        GET     s.vdu.VduPlot
        GET     s.vdu.VduGrafA
        GET     s.vdu.VduGrafB
        GET     s.vdu.VduGrafC
        GET     s.vdu.VduGrafD
        GET     s.vdu.VduGrafE
        GET     s.vdu.VduGrafF
        GET     s.vdu.VduGrafG
        GET     s.vdu.VduGrafH
        GET     s.vdu.VduGrafI
        GET     s.vdu.VduGrafJ
        GET     s.vdu.VduGrafK
        GET     s.vdu.VduGrafL
        GET     s.vdu.VduWrch
        GET     s.vdu.Vdu23
        GET     s.vdu.VduPointer
        GET     s.vdu.Vdu5
        GET     s.vdu.VduCurSoft
        GET     s.vdu.VduTTX

        GBLS    GiveMeBfontAnyDay
        [ BleedinDaveBell
GiveMeBfontAnyDay SETS "GET s.vdu.VduFontL1"
        |
GiveMeBfontAnyDay SETS "GET s.vdu.VduFont"
        ]

        $GiveMeBfontAnyDay

        ! 0, "Vdu drivers size = &" :CC: :STR: (.-StartOfVduDriver)

StartOfPMF
        GET     s.PMF.osinit
        GET     s.PMF.oseven
        GET     s.PMF.osbyte
        GET     s.PMF.osword
        GET     s.PMF.realtime
        GET     s.PMF.convdate
        $GetRS423
        GET     s.PMF.i2cutils
        GET     s.PMF.oswrch
        GET     s.PMF.buffer
        $GetKbdDrA1
        GET     s.PMF.key
        $GetKey2
        GET     s.PMF.mouse
        ALIGN

;;;StartOfAMB_beforealign
;;;        ALIGN   4096                    ;align to 4k page boundary, for easy ROMpatch
;;;StartOfAMB
        GET     s.AMBControl.AMB
;;;        DCB     "GROT"                  ;spare words marker
;;;        ALIGN   4096                    ;align to 4k page boundary, for easy ROMpatch

EndOfKernel
        &       0                       ; for patching by BigSplit et al

;;;        ! 0, "PMF section size = &" :CC: :STR: (StartOfAMB_beforealign - StartOfPMF)

;;;        ! 0, "AMB section (4k aligned) starts at ":CC::STR:(StartOfAMB)
;;;        ! 0, "AMB section size (4k aligned) = &" :CC: :STR: (EndOfKernel - StartOfAMB)


        END
