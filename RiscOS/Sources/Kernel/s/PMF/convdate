; > $.Source.PMF.ConvDate

        MACRO
        CDATT   $mnemonic, $stackoffset, $digits
        ASSERT  (:LEN: "$mnemonic") = 2
        ASSERT  ((CDAT$mnemonic-(CDATBranch+8)) :AND: &FFFFFC03) = 0
        ASSERT  ($stackoffset >=0) :LAND: ($stackoffset < 64)
        LCLA    digits
        [       "$digits"=""
digits  SETA    2
        |
digits  SETA    $digits
        ]
        ASSERT  (digits >= 1) :LAND: (digits <= 3)

        DCB     digits :OR: ($stackoffset :SHL: 2)
        DCB     (CDAT$mnemonic-(CDATBranch+8)) :SHR: 2
        =       "$mnemonic"
        MEND

; *****************************************************************************
;
;       ConvertStandardDateAndTime - Convert from 5-byte cs representation to
;                                    format specified in <SYS$DateFormat>
;
; in:   R0 -> time block
;       [R0, #0..4] = 5-byte centisecond representation
;       R1 -> buffer to accept conversion
;       R2 = size of buffer
;
; out:  V=0 => successful conversion
;       R0 = input value of R1
;       R1 = updated pointer to buffer
;       R2 = updated size of buffer
;
;       V=1 => failed conversion
;       R0 -> error block
;       R1 = input value of R1
;       R2 = input value of R2
;


ConvertStandardDateAndTime ROUT
        BIC     R10, R13, #&00FF
        BIC     R10, R10, #&7F00        ; R10 -> assumed start of stack
        SUB     R10, R13, R10           ; R10 := free space on stack
        CMP     R10, #&200              ; to be on the safe side
        BCS     %FT10

; not enough stack for operation

        ADR     R0, ErrorBlock_CDATStackOverflow
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
        SWI     XOS_GenerateError
        ORR     R14, R14, #V_bit
        ExitSWIHandler

        MakeErrorBlock CDATStackOverflow

10
        SUB     R13, R13, #&100         ; room for reading <SYS$DateFormat>
        Push    "R0-R4, R14"
        ADR     R0, DateFormatVarName   ; R0 -> "SYS$DateFormat"
        ADD     R1, R13, #6*4           ; R1 -> buffer for string
        MOV     R2, #255                ; R2 = maximum length of string
        MOV     R3, #0                  ; not wild carding
        MOV     R4, #VarType_Expanded   ; convert to string
        SWI     XOS_ReadVarVal
        BVS     %FT30
        MOV     R0, #0
        STRB    R0, [R1, R2]            ; terminate string with zero
        MOV     R3, R1                  ; R3 -> format string
        Pull    "R0-R2"
        SWI     XOS_ConvertDateAndTime
        Pull    "R3,R4, R14"
20
        ADD     R13, R13, #&100
        ORRVS   R14, R14, #V_bit
        ExitSWIHandler

; format specifier not found

30
        ADD     R13, R13, #4            ; throw away stacked R0
        Pull    "R1-R4, R14"
        B       %BT20

DateFormatVarName
        =       "SYS$DateFormat",0
        ALIGN

; *****************************************************************************
;
;       ConvertDateAndTime - Convert from 5-byte cs representation to
;                            format specified by user
;
; in:   R0 -> time block
;       [R0, #0..4] = 5-byte centisecond representation
;       R1 -> buffer to accept conversion
;       R2 = size of buffer
;       R3 -> format string
;
; out:  V=0 => successful conversion
;       R0 = input value of R1
;       R1 = updated pointer to buffer
;       R2 = updated size of buffer
;
;       V=1 => failed conversion
;       R0 -> error block
;       R1 = input value of R1
;       R2 = input value of R2
;

ConvertDateAndTime ROUT
          
; International vesion just calls territory manager.

        Push    "R4,R14"


        MOV     R4,R3                   ; Territory SWI wants things one register up.
        MOV     R3,R2
        MOV     R2,R1
        MOV     R1,R0
        MOV     R0,#-1                  ; Use configured territory.
        SWI     XTerritory_ConvertDateAndTime      
        Pull    "R4,R14"
        ORRVS   R14, R14, #V_bit        ; set V in R14 for exit
        ExitSWIHandler

        LTORG

        END
