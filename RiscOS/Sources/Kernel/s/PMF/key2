; > $.Source.PMF.Key2

; ARTHUR keyboard code (Keyboard table handler)

; Author        Tim Dobson
; Started       15-Apr-87

; ************************************************************
; ***    C h a n g e   L i s t  (better late than never!)  ***
; ************************************************************

; Date       Description
; ----       -----------
; 19-Feb-88  Modified InkeyTran2 so that INKEY(-95) returns state of new key
;             next to left shift key on international keyboards
; 11-Aug-88  Modified A500 keyboard as follows:-
;             LOOKS = ALT; MENU = F0; F10 = F10; keypad # = F11;
;             keypad % = F12; keypad / = F13

        MACRO
        IKT     $A, $B, $C, $D, $E, $F, $G, $H
        IKT2    $A
        IKT2    $B
        IKT2    $C
        IKT2    $D
        IKT2    $E
        IKT2    $F
        IKT2    $G
        IKT2    $H
        MEND

        MACRO
        IKT2    $TE
        LCLA    T
T       SETA    $TE
        [ (T :AND: &FF00) = 0
T       SETA    T :OR: &FF00
        ]
        [ (T :AND: &FF0000) = 0
T       SETA    T :OR: &FF0000
        ]
        [ (T :AND: &FF000000) = 0
T       SETA    T :OR: &FF000000
        ]
        &       T
        MEND


; Special keys

K0ShiftKey      * &0A
K0LooksKey      * &0B
K0ControlKey    * &0C
K0RightMouse    * &0D
K0CentreMouse   * &0E
K0LeftMouse     * &0F
K0TabKey        * &30
K0CapsKey       * &40
K0BreakKey      * &05 ; key marked ESCAPE is BREAK
K0NumPadHash    * &04
K0NumPadPercent * &17
K0NumPadSlash   * &07
K0NumPadStar    * &06
K0NumPad7       * &14
K0NumPad8       * &77
K0NumPad9       * &27
K0NumPadMinus   * &16
K0NumPad4       * &24
K0NumPad5       * &97
K0NumPad6       * &67
K0NumPadPlus    * &87
K0NumPad1       * &64
K0NumPad2       * &37
K0NumPad3       * &57
K0NumPadEnter   * &47
K0NumPad0       * &94
K0NumPadDot     * &44

K1ShiftLeft     * &4C
K1ShiftRight    * &58
K1CtrlLeft      * &3B
K1CtrlRight     * &61
K1AltLeft       * &5E
K1AltRight      * &60
K1RightMouse    * &72
K1CentreMouse   * &71
K1LeftMouse     * &70
K1TabKey        * &26
K1CapsKey       * &5D
K1NumKey        * &22
K1ScrollKey     * &0E
K1BreakKey      * &0F
K1BackTickKey   * &10
K1PoundKey      * &1D
K1NumPadSlash   * &23
K1NumPadStar    * &24
K1NumPadHash    * &25
K1NumPad7       * &37
K1NumPad8       * &38
K1NumPad9       * &39
K1NumPadMinus   * &3A
K1NumPad4       * &48
K1NumPad5       * &49
K1NumPad6       * &4A
K1NumPadPlus    * &4B
K1NumPad1       * &5A
K1NumPad2       * &5B
K1NumPad3       * &5C
K1NumPadEnter   * &67
K1NumPad0       * &65
K1NumPadDot     * &66

; UserKeyWorkSpace allocation

        ^ 0, R12
ShiftCount      # 1
CtrlCount       # 1
MyMouseButtons  # 1
KeyReturn       # 2     ; length byte (1), value byte
KeyNULReturn    # 3     ; length byte (2), NUL, value byte

        ASSERT (:INDEX: @) <= UserKeyWorkSpaceSize

; *****************************************************************************

OldKeyStruct
        &       KeyTran-OldKeyStruct
        &       (KeyTranEnd-KeyTran) :SHR: 2
        &       InkeyTran-OldKeyStruct
        &       ShiftingKeyList-OldKeyStruct
        &       SpecialList-OldKeyStruct
        &       SpecialCodeTable-OldKeyStruct
        &       KeyStructInit-OldKeyStruct
        &       PendingAltCode-OldKeyStruct

ShiftingKeyList
        =       ShiftingKeyListEnd-ShiftingKeyList-1
        =       K0ShiftKey, K0ControlKey, K0LooksKey
        =       K0RightMouse, K0CentreMouse, K0LeftMouse
        =       K0BreakKey
ShiftingKeyListEnd
        ALIGN

SpecialList
SpecialListEnd
        ALIGN

SpecialCodeTable

; *****************************************************************************

NewKeyStruct
        &       KeyTran2-NewKeyStruct
        &       (KeyTran2End-KeyTran2) :SHR: 2
        &       InkeyTran2-NewKeyStruct
        &       NewShiftingKeyList-NewKeyStruct
        &       NewSpecialList-NewKeyStruct
        &       NewSpecialCodeTable-NewKeyStruct
        &       KeyStructInit-NewKeyStruct
        &       PendingAltCode-NewKeyStruct

NewShiftingKeyList
        =       NewShiftingKeyListEnd-NewShiftingKeyList-1
        =       K1ShiftLeft, K1ShiftRight, K1CtrlLeft, K1CtrlRight
        =       K1RightMouse, K1CentreMouse, K1LeftMouse, K1BreakKey
NewShiftingKeyListEnd
        ALIGN

NewSpecialList
NewSpecialListEnd
        ALIGN

NewSpecialCodeTable

; Now the code to handle it

; Initialise keyboard table handler
;
; in:   R12 -> my workspace
;       R5 = KeyBdStatus
;       R7 = PendingAltType
;
; out:  R5 = new KeyBdStatus
;       R7 = new PendingAltType

KeyStructInit ROUT
        MOV     R0, #0                  ; no shift or ctrl keys down
        STRB    R0, ShiftCount
        STRB    R0, CtrlCount
        STRB    R0, MyMouseButtons
        STRB    R0, KeyNULReturn+1      ; NUL for NUL char return
        MOV     R0, #1                  ; string length for single key return
        STRB    R0, KeyReturn+0
        MOV     R0, #2                  ; length for NUL char return
        STRB    R0, KeyNULReturn+0

        BIC     R5, R5, #(KBStat_ShiftEngaged :OR: KBStat_CtrlEngaged :OR: KBStat_PendingAlt)
        MOV     PC, R14

ProcessKShift ROUT
        ADR     R0, ShiftCount
        MOV     R2, #KBStat_ShiftEngaged
ProcessShiftOrCtrl
        TEQ     R1, #0                  ; R1=1 => down, R1=0 => up
        LDRB    R3, [R0]
        ADDNE   R3, R3, #1              ; if down then increment
        SUBEQ   R3, R3, #1              ; if up then decrement
        STRB    R3, [R0]
        TEQ     R3, #0
        ORRNE   R5, R5, R2              ; one or more shift/ctrl keys down
        BICEQ   R5, R5, R2              ; zero shift/ctrl keys down
        MOV     PC, R14

ProcessKCtrl ROUT
        ADR     R0, CtrlCount
        MOV     R2, #KBStat_CtrlEngaged
        B       ProcessShiftOrCtrl

ProcessKRight ROUT
        MOV     R2, #1
ProcessMouseButton
        TEQ     R1, #0
        LDRB    R0, MyMouseButtons
        ORRNE   R0, R0, R2              ; button going down
        BICEQ   R0, R0, R2              ; button going up
        STRB    R0, MyMouseButtons
        MOV     PC, R3                  ; call his routine and exit

ProcessKCentre ROUT
        MOV     R2, #2
        B       ProcessMouseButton

ProcessKAlt ROUT
        TST     R5, #KBStat_ShiftEngaged
        MOVEQ   R7, #1                          ; Alt
        MOVNE   R7, #2                          ; Shift-Alt
        TST     R5, #KBStat_CtrlEngaged
        ADDNE   R7, R7, #2                      ; Ctrl-Alt, Ctrl-Shift-Alt
        ORR     R5, R5, #KBStat_PendingAlt      ; indicate a pending alt
        MOV     PC, R14

ProcessKLeft ROUT
        MOV     R2, #4
        B       ProcessMouseButton

ProcessKCaps ROUT
        TEQ     R1, #2                          ; is it first press ?
        MOVNE   PC, R14                         ; don't auto-repeat

        TST     R5, #KBStat_ShiftEngaged        ; if shift down
        BICNE   R5, R5, #KBStat_NoCapsLock      ; then force CAPS on
        ORRNE   R5, R5, #KBStat_ShiftEnable     ; and SHIFT CAPS state
        EOREQ   R5, R5, #KBStat_NoCapsLock      ; else toggle caps lock state
        BICEQ   R5, R5, #KBStat_ShiftEnable     ; and cancel shift enable

        MOV     PC, R14

ProcessKTab ROUT
        LDROSB  R0, TABch                       ; TAB key code
        TST     R0, #&80                        ; top bit set ?
        BEQ     ReturnOneChar                   ; no, don't shift or ctrl it
        TST     R5, #KBStat_ShiftEngaged
        EORNE   R0, R0, #&10                    ; modify for shift
        TST     R5, #KBStat_CtrlEngaged
        EORNE   R0, R0, #&20                    ; modify for ctrl
ReturnOneChar
        ADR     R6, KeyReturn                   ; pass pointer back to MOS
        STRB    R0, [R6, #1]                    ; having poked byte in
        MOV     PC, R14

ProcessKNum ROUT
        TEQ     R1, #2                          ; is it first press ?
        EOREQ   R5, R5, #KBStat_NoNumLock       ; yes, then toggle num lock
        MOV     PC, R14                         ; (don't auto-repeat)

ProcessKScroll ROUT
        TEQ     R1, #2                          ; is it first press ?
        EOREQ   R5, R5, #KBStat_ScrollLock      ; yes, then toggle scroll lock
        MOV     PC, R14                         ; (don't auto-repeat)

ProcessKBreak ROUT
        ADD     PC, R3, #4                      ; offset for break routine

ProcessPad
        TST     R5, #KBStat_NoNumLock           ; test num lock
        MOVNE   R0, R2                          ; numlock off -> use R2
        LDRB    R0, [R0, R4]                    ; get table entry
        TEQ     R0, #&FF                        ; dummy key ?
        MOVEQ   PC, R14                         ; then exit

        LDROSB  R2, KeyBase                     ; add on numeric key base
        SUB     R0, R0, #"0"
        ADD     R0, R0, R2

        LDROSB  R2, KeyOpt                      ; zero => ctrl/shift modifies
        TEQ     R2, #0
        BNE     %FT10                           ; [don't modify]

        TST     R0, #&80                        ; top bit set ?
        BEQ     %FT10                           ; no, then don't modify

        TST     R5, #KBStat_ShiftEngaged
        EORNE   R0, R0, #&10                    ; modify for shift
        TST     R5, #KBStat_CtrlEngaged
        EORNE   R0, R0, #&20                    ; modify for ctrl
10
        B       ReturnOneChar

        ALIGN

; *****************************************************************************
;
;       PendingAltCode - Process ALT+char
;
; in:   R0 -> key structure
;       R2 = internal key number for char
;       R3 = character
;       R5 = keyboard status
;       R7 = pending alt type
;
; out:  R6 -> returned key list
;

PendingAltCode ROUT
        BIC     R5, R5, #KBStat_PendingAlt ; cancel pending alt
        TEQ     R7, #4                  ; is it CTRL-SHIFT-ALT char ?
        MOVNE   R0, R3
        BNE     ReturnOneChar
        ORR     R0, R3, #&80            ; set top bit
ReturnNULChar
        ADR     R6, KeyNULReturn
        STRB    R0, [R6, #2]
        MOV     PC, R14

; *****************************************************************************

KeyTran ROUT

KeyTranEnd


; *****************************************************************************

; Keyboard table for new keyboard

KeyTran2 ROUT

KeyTran2End


; *****************************************************************************
;
;       Reverse table lookup for INKEY(-ve)
;

InkeyTran

InkeyTran2


        END
