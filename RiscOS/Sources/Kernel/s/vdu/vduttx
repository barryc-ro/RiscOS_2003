; > $.Source.VduTTX

;       Teletext (MODE 7) emulation
;       ---------------------------

;       Author          Tim Dobson
;       Started         24-Feb-87

; *****************************************************************************

; Teletext control codes

TTX_AlphaRed     *      &01
TTX_AlphaGreen   *      &02
TTX_AlphaYellow  *      &03
TTX_AlphaBlue    *      &04
TTX_AlphaMagenta *      &05
TTX_AlphaCyan    *      &06
TTX_AlphaWhite   *      &07
TTX_Flash        *      &08
TTX_Steady       *      &09
TTX_EndBox       *      &0A
TTX_StartBox     *      &0B
TTX_NormalHeight *      &0C
TTX_DoubleHeight *      &0D

TTX_GraphRed     *      &11
TTX_GraphGreen   *      &12
TTX_GraphYellow  *      &13
TTX_GraphBlue    *      &14
TTX_GraphMagenta *      &15
TTX_GraphCyan    *      &16
TTX_GraphWhite   *      &17
TTX_Conceal      *      &18
TTX_Contiguous   *      &19
TTX_Separated    *      &1A
TTX_BlackBackgd  *      &1C
TTX_NewBackgd    *      &1D
TTX_HoldGraph    *      &1E
TTX_RelGraph     *      &1F

TTXGraphContFontA * TTXSoftFonts +0    ; Contiguous graphics font (&20-&3F)
TTXGraphSepaFontA * TTXSoftFonts +&140 ; Separated graphics font  (&20-&3F)
TTXGraphContFontB * TTXSoftFonts +&280 ; Contiguous graphics font (&60-&7F)
TTXGraphSepaFontB * TTXSoftFonts +&3C0 ; Separated graphics font  (&60-&7F)

; Bits in the map

;       Bits 0-7        8 bit character
;       Bit  8          0 => Alpha, 1 => Graphics
;       Bit  9          0 => Contiguous, 1 => Separated
;       Bit  10         0 => Steady, 1 => Flash
;       Bit  11         0 => Release, 1 => Hold
;       Bit  12         0 => Reveal, 1 => Conceal
;       Bits 13-14      Bit 13  Bit 14
;                       0       0       Single Height
;                       1       0       Undefined
;                       0       1       Double Height Top
;                       1       1       Double Height Bottom
;       Bit  15         1 => Pending Start Box
;       Bit  16         1 => Pending End Box
;       Bits 17-19      Foreground colour
;       Bit  20         0 => Unboxed, 1 => Boxed
;       Bits 21-23      Background colour
;       Bit  24         0 => Unboxed, 1 => Boxed
;       Bits 25-29,31   Held graphic 
;       Bit  30         0 => Held graphic contiguous, 1 => separated

MapBit_Char     *       1 :SHL: 0
MapBit_Graph    *       1 :SHL: 8
MapBit_Separated *      1 :SHL: 9
MapBit_Flash    *       1 :SHL: 10
MapBit_Hold     *       1 :SHL: 11
MapBit_Conceal  *       1 :SHL: 12
MapBit_Bottom   *       1 :SHL: 13
MapBit_Double   *       1 :SHL: 14
MapBit_PendingStart *   1 :SHL: 15

MapBit_PendingEnd *     1 :SHL: 16
MapBit_ForeMask *       7 :SHL: 17
MapBit_BackMask *       7 :SHL: 21
MapBits_Boxed   *       (1 :SHL: 20) :OR: (1 :SHL: 24)
MapBit_HeldMask *       &7F :SHL: 25
MapBit_HeldSeparated *  1 :SHL: 30

MapForeShift    *       17
MapBackShift    *       21
MapHeldShift    *       25

MapBit_Default  *       (7 :SHL: MapForeShift)+32 ; default at start of line

; *****************************************************************************
;
;       TeletextInit - Initialise teletext workspace
;       Called when MODE 7 (or 135) is selected
;

TeletextInit ROUT
        MOV     R0, #1                          ; set to flash immediately
        STR     R0, [WsPtr, #TeletextCount]

; compute the graphics fonts

        ADD     R0, WsPtr, #TTXSoftFonts ; R0 -> contiguous font
        MOV     R2, #&20                ; R2 = character number
        MOV     R3, #0                  ; R3 = byte to store
10
        ADD     R1, R0, #&140           ; R1 -> separated font
20
        TST     R2, #1                  ; top left
        ORRNE   R3, R3, #&F0
        TST     R2, #2                  ; top right
        ORRNE   R3, R3, #&0F
        STRB    R3, [R0], #1            ; 3 pixel rows for top
        STRB    R3, [R0], #1
        STRB    R3, [R0], #1
        AND     R3, R3, #&77            ; do separated
        STRB    R3, [R1], #1
        STRB    R3, [R1], #1
        MOV     R3, #0
        STRB    R3, [R1], #1

        TST     R2, #4                  ; middle left
        ORRNE   R3, R3, #&F0
        TST     R2, #8                  ; middle right
        ORRNE   R3, R3, #&0F
        STRB    R3, [R0], #1            ; 4 pixel rows for middle
        STRB    R3, [R0], #1
        STRB    R3, [R0], #1
        STRB    R3, [R0], #1
        AND     R3, R3, #&77            ; do separated
        STRB    R3, [R1], #1
        STRB    R3, [R1], #1
        STRB    R3, [R1], #1
        MOV     R3, #0
        STRB    R3, [R1], #1

        TST     R2, #&10                ; bottom left
        ORRNE   R3, R3, #&F0
        TST     R2, #&40                ; bottom right
        ORRNE   R3, R3, #&0F
        STRB    R3, [R0], #1            ; 3 pixel rows for bottom
        STRB    R3, [R0], #1
        STRB    R3, [R0], #1
        AND     R3, R3, #&77            ; do separated
        STRB    R3, [R1], #1
        STRB    R3, [R1], #1
        MOV     R3, #0
        STRB    R3, [R1], #1

        ADD     R2, R2, #1
        TEQ     R2, #&40                ; if at end of 1st part
        MOVEQ   R2, #&60                ; then start 2nd
        ADDEQ   R0, R0, #&140           ; skipping separated already done
        BEQ     %BT10                   ; and resetting R1 too

        TEQ     R2, #&80                ; finished
        BNE     %BT20

        MOV     PC, R14

; *****************************************************************************
;
;       TTXFastCLS - Called when clearing whole screen
;       Clears the teletext map to default
;

TTXFastCLS ROUT
        ADD     R0, WsPtr, #TTXMap      ; R0 -> map
        ADD     R1, R0, #TTXMapSize-4   ; R1 -> last word of map
        LDR     R2, =MapBit_Default     ; R2 = default status at start of line
10
        STR     R2, [R0], #4
        CMP     R0, R1
        BLS     %BT10

        ADD     R0, WsPtr, #TTXDoubleCounts   ; zero double counts on each line
        ADD     R1, R0, #25
        MOV     R2, #0
20
        STRB    R2, [R0], #1
        TEQ     R0, R1
        BNE     %BT20

        MOV     PC, R14

; *****************************************************************************
;
;       TTXUpdateColours - Update colour table for new colours
;
; in:   R5 = new foregd colour
;       R6 = new backgd colour
;
; out:  R0, R2 preserved
;

TTXUpdateColours ROUT
        Push    "R0,R2,R14"
        ADD     R14, WsPtr, #TForeCol
        STMIA   R14, {R5,R6}
        MOV     fore, R5
        MOV     back, R6
        LDR     bpp, [WsPtr, #BitsPerPix]
        BL      SetColours
        Pull    "R0,R2,PC"

; *****************************************************************************
;
;       PrintDoubleHeight - Process font for double height
;
; in:   R0 = char + attributes
;       tophalf    contains bytes 0123
;       bottomhalf contains bytes 4567
;       R10        contains bytes xx89
;       We know that at least one of MapBit_Bottom or MapBit_Double is set
;

PrintDoubleHeight ROUT
        TST     R0, #MapBit_Double              ; if not double height,
        MOVEQ   tophalf, #0                     ; then must be single height
        MOVEQ   bottomhalf, #0                  ; part on line below double,
        MOVEQ   R10, #0                         ; so make it invisible
        MOVEQ   PC, R14

        TST     R0, #MapBit_Bottom
        BNE     %FT10                           ; [bottom half of double]

        [ 1=1 ;                 0 1              2 3         4
; do top half, we want tophalf=0112, bottomhalf=2334, R10=xx45
        MOV     R10, bottomhalf, LSL #16        ; R10 := o o 4 5
        ORR     R10, R10, R10, LSL #8           ; R10 := o o 4 4/5
        AND     R3, tophalf, #&FF000000         ; R3 := o o o 3
        ORR     bottomhalf, R3, bottomhalf, LSL #24 ; bot := o o o 3/4
        MOV     R3, tophalf, LSR #16            ; R3 := 2 3 o o
        ORR     R3, R3, R3, LSL #8              ; R3 := 2 2/3 3 o
        ORR     bottomhalf, bottomhalf, R3      ; bot := 2 2/3 3 3/4
        MOV     tophalf, tophalf, LSL #16       ; top := o o 0 1
        ORR     tophalf, tophalf, tophalf, LSR #8 ; top := o 0 0/1 1
        MOV     tophalf, tophalf, LSR #8        ; top := 0 0/1 1 o
        ORR     tophalf, tophalf, bottomhalf, LSL #24 ; top := 0 0/1 1 2
        AND     R3, tophalf, #&00FF0000         ; R3 := o o 1 o
        ORR     tophalf, tophalf, R3, LSL #8    ; top := 0 0/1 1 1/2
        MOV     PC, R14

10 ;                               5 6              7 8         9
; do bottom half, we want tophalf=5667, bottomhalf=7889, R10=xx9o
        AND     tophalf, bottomhalf, #&FF000000 ; top := o o o 7
        MOV     R3, bottomhalf, LSL #8          ; R3 := o 4 5 6
        MOV     R3, R3, LSR #16                 ; R3 := 5 6 o o
        ORR     tophalf, tophalf, R3            ; top := 5 6 o 7
        ORR     tophalf, tophalf, R3, LSL #8    ; top := 5 5/6 6 7
        AND     R3, R3, #&0000FF00              ; R3 := o 6 o o
        ORR     tophalf, tophalf, R3, LSL #16   ; top := 5 5/6 6 6/7
        MOV     bottomhalf, bottomhalf, LSR #24 ; bot := 7 o o o
        AND     R3, R10, #&00FF0000             ; R3 := o o 8 o
        ORR     bottomhalf, bottomhalf, R3, LSR #8 ; bot := 7 8 o o
        ORR     bottomhalf, bottomhalf, bottomhalf, LSL #8 ; bot := 7 7/8 8 o
        ORR     R3, R10, R10, LSL #8            ; R3 := x x x 8/9
        AND     R3, R3, #&FF000000              ; R3 := o o o 8/9
        ORR     bottomhalf, bottomhalf, R3      ; bot := 7 7/8 8 8/9
        MOV     R10, R10, LSR #24               ; R10 := 9 o o o
        ORR     R10, R10, R10, LSL #8           ; R10 := 9 9 o o
        MOV     R10, R10, LSL #16               ; R10 := o o 9 9
        MOV     PC, R14
        |
; do top half, we want tophalf=0011, bottomhalf=2233, R10=xx44

        MOV     R10, bottomhalf, LSL #24        ; R10 := ooo4
        ORR     R10, R10, R10, LSR #8           ; R10 := oo44
        AND     bottomhalf, tophalf, #&00FF0000 ; bottom := oo2o
        ORR     bottomhalf, bottomhalf, tophalf, LSR #24 ; bottom := 3o2o
        ORR     bottomhalf, bottomhalf, bottomhalf, LSL #8 ; bottom := 3322
        MOV     bottomhalf, bottomhalf, ROR #16 ; bottom := 2233
        AND     R3, tophalf, #&0000FF00         ; R3 := o1oo
        AND     tophalf, tophalf, #&FF          ; top := 0ooo
        ORR     tophalf, tophalf, R3, LSL #8    ; top := 0o1o
        ORR     tophalf, tophalf, tophalf, LSL #8 ; top := 0011
        MOV     PC, R14

; do bottom half, we want tophalf=5566, bottomhalf=7788, R10=xx99

10
        AND     tophalf, bottomhalf, #&0000FF00         ; top := o5oo
        MOV     bottomhalf, bottomhalf, LSR #16         ; bot := 67oo
        ORR     tophalf, tophalf, bottomhalf, LSL #24   ; top := o5o6
        ORR     tophalf, tophalf, tophalf, LSR #8       ; top := 5566
        MOV     bottomhalf, bottomhalf, LSR #8          ; bot := 7ooo
        MOV     R10, R10, LSR #16                       ; R10 := 89oo
        ORR     bottomhalf, bottomhalf, R10, LSL #16    ; bot := 7o89
        BIC     bottomhalf, bottomhalf, #&FF000000      ; bot := 7o8o
        ORR     bottomhalf, bottomhalf, bottomhalf, LSL #8 ; bot := 7788
        BIC     R10, R10, #&FF                          ; R10 := o9oo
        ORR     R10, R10, R10, LSR #8                   ; R10 := 99oo
        MOV     R10, R10, LSL #16                       ; R10 := oo99
        MOV     PC, R14
        ]

; *****************************************************************************
;
;       TTXWrch - Print a character in the range &20-&FF
;
; in:   R0 = character
; out:  cursor has been moved on if appropriate
;

TTXWrch ROUT
        Push    R14
        BL      TTXDoChar
        Pull    R14
        B       PostCharMove

; *****************************************************************************
;
;       TTXDoChar - Print a character (don't move cursor)
;
; in:   R0 = character
;

TTXDoChar ROUT
        Push    R14

        MOV     R3, R0
        TEQ     R3, #"#"                        ; swap around the three
        MOVEQ   R0, #"_"                        ; old favourites
        TEQ     R3, #"_"
        MOVEQ   R0, #"`"
        TEQ     R3, #"`"
        MOVEQ   R0, #"#"

        LDR     R11, [WsPtr, #CursorY]          ; R11 = current Y position
        LDR     R3, [WsPtr, #CursorX]           ; R3=start X posn on this line
        LDR     R2, [WsPtr, #CursorAddr]        ; screen address
TTXScanFromHere
        MOV     R4, #0                          ; Xmin and
        MOV     R5, #0                          ; Xmax are irrelevant
        MOV     R10, #0                         ; Ymax always <= Y so no zap
TTXScanZap
        ADRL    R1, TTXLineStarts               ; R1 -> table of line starts
        LDR     R8, [R1, R11, LSL #2]           ; R8 -> map entry at st.of line
        ADD     R7, R8, #40*4                   ; R7 -> end of this line
        LDR     R1, [R8, R3, LSL #2]!           ; R1 = prev. char+attr
08
        ADD     R3, WsPtr, #TTXDoubleCounts
        LDRB    R9, [R3, R11]                   ; R9 = no. of dbls on this line
10
        BIC     R1, R1, #&FF                    ; clear char bits
        ORR     R0, R1, R0                      ; store new char
        AND     R1, R0, #&7F                    ; just look at char bits

        Push    R14
        CMP     R1, #&20                        ; is it a control char
        BLCC    DoPreControl                    ; [do pre-control things]

        Push    "R1,R4-R11"
        BL      TTXPaintChar
        Pull    "R1,R4-R11"

        BIC     R0, R0, #(MapBit_PendingStart :OR: MapBit_PendingEnd)

        CMP     R1, #&20
        BLCC    DoPostControl                   ; [do post-control things]
        Pull    R14                             ; restore zap flag

        LDR     R1, [R8, #4]!                   ; get old character
        STR     R0, [R8]                        ; store character away

        AND     R3, R1, #&7F                    ; if overwriting double height
        TEQ     R3, #TTX_DoubleHeight
        SUBEQ   R9, R9, #1                      ; then one less

        EOR     R1, R0, R1                      ; get difference
        BIC     R3, R1, #&FF                    ; difference in attributes
        MOV     R1, R0                          ; R1 = prev char + new attr

        CMP     R11, R10                        ; if Y >= Ymax
        BCS     %FT20                           ; then load from map
        CMPCC   R8, R5                          ; else if X <= Xmax
        MOVLS   R3, #1                          ; then pretend attr different
        CMPCC   R4, R8                          ; if Xmin < X < Xmax
        CMPCC   R14, #1                         ; and we're zapping (not scan)
        MOVCC   R0, #32                         ; then zap to space
20
        LDRCSB  R0, [R8, #4]                    ; else load from map

        TEQ     R3, #0                          ; if attributes different
        TEQNE   R8, R7                          ; and not at end of line
        ADDNE   R2, R2, #4                      ; then move to next char
        BNE     %BT10                           ; and loop

        ADD     R3, WsPtr, #TTXDoubleCounts
        STRB    R9, [R3, R11]                   ; update no. of doubles

        ADD     R11, R11, #1                    ; go to next line
        TEQ     R11, #25                        ; if off bottom of screen
        Pull    PC, EQ                          ; then finished

        MOVS    R3, R9                          ; if no doubles
                                                ; then next line is top line
        EORNE   R3, R1, #MapBit_Bottom          ; else next line is opposite
                                                ; to this line

        LDR     R1, [R7, #4]                    ; get dummy word on next line
        EOR     R3, R1, R3                      ; difference
        ANDS    R3, R3, #MapBit_Bottom          ; difference in 'bottom' bit
        EORNE   R1, R1, #MapBit_Bottom          ; if different then toggle bit
        STR     R1, [R7, #4]!                   ; always store back
        BNE     %FT30                           ; and do another row

        CMP     R11, R10                        ; else if finished zap
        Pull    PC, CS                          ; then exit
30

; now compute new R2

        SUB     R3, R7, R8                      ; no. of chars before eol
        RSB     R3, R3, #160                    ; current char number
        SUB     R2, R2, R3                      ; back to start of old line
        LDR     R3, [WsPtr, #RowLength]
        ADD     R2, R2, R3                      ; move down a row

        MOV     R8, R7                          ; R8 -> dummy char on new line
        ADD     R7, R7, #40*4                   ; R7 -> last char on new line

        ADD     R4, R4, #41*4                   ; move Xmin to next line
        ADD     R5, R5, #41*4                   ; move Xmax to next line

        CMP     R11, R10                        ; if Y < Ymax
        CMPCC   R8, R5                          ; and X < Xmax
        CMPCC   R4, R8                          ; if also Xmin < X
        CMPCC   R14, #1                         ; & we're zapping not scanning
        MOVCC   R0, #32                         ; then zap to space
        LDRCSB  R0, [R8, #4]                    ; else load from map
        B       %BT08

; *****************************************************************************
;
;       TTXClearBox - Fill a rectangle with spaces, and update screen
;
; in:   R0 = left column
;       R1 = bottom row
;       R2 = right column
;       R3 = top row
;       Return address already stacked
;

TTXClearBox
        ADD     R10, R1, #1                     ; R10 := bottom +1
        MOV     R11, R3                         ; R11 := top
        ADD     R5, R2, #1                      ; R5 := right + 1

        MOV     R1, R3
        BL      AddressR0R1                     ; R2 := address(topleft)
                                                ; R1, R3, R4 corrupted
        MOV     R3, R0                          ; R3 := left

        ADRL    R4, TTXLineStarts
        LDR     R0, [R4, R11, LSL #2]           ; R0 -> dummy(top)
        ADD     R5, R0, R5, LSL #2              ; R5 := map(topright)
        ADD     R4, R0, R3, LSL #2              ; R4 := map(topleft)-4
        SUB     R4, R4, #4                      ; R4 := map(topleft)-8
        MOV     R0, #32                         ; start with a space
        MOV     R14, #0                         ; indicate zapping
        B       TTXScanZap                      ; go and do it

; *****************************************************************************
;
;       TTXHardScrollUp - Scroll teletext screen upwards
;

TTXHardScrollUp ROUT

; first scroll map up

        LDR     R0, [WsPtr, #RowLength]         ; save real RowLength
        Push    "R0, R6, R14"                   ; and save CursorFlags
        
        MOV     R0, #1                          ; pretend rowmult = 1
        LDR     R2, TTXLineStarts               ; R2 -> TTXMap
        MOV     R5, #41*4                       ; R5 = no. of bytes horiz
        STR     R5, [WsPtr, #RowLength]         ; pretend rowlength
        MOV     R6, #25                         ; no. of 'pixel' rows
        MOV     R7, R5                          ; linelength
        BL      SoftScrollUp2

        Pull    "R0, R6"
        STR     R0, [WsPtr, #RowLength]         ; restore RowLength

; now 'scroll' DoubleCounts

        ADD     R0, WsPtr, #TTXDoubleCounts
        ADD     R1, R0, #24
10
        LDRB    R2, [R0, #1]
        STRB    R2, [R0], #1
        TEQ     R0, R1
        BNE     %BT10

; now see if top line was a 'bottom' row
; if so, we need to rescan from the top

        LDR     R8, TTXLineStarts               ; R8 -> top left map
        LDR     R1, [R8]                        ; R1 = dummy word
        TST     R1, #MapBit_Bottom              ; if not bottom
        BEQ     %FT20                           ; then OK
        
        BIC     R1, R1, #MapBit_Bottom          ; make into a 'top' line
        STR     R1, [R8]                        ; store back
        LDRB    R0, [R8, #4]                    ; R0 = first char
        MOV     R3, #0                          ; X = 0
        MOV     R11, #0                         ; Y = 0
        LDR     R2, [WsPtr, #ScreenStart]       ; screen address for top-left

        ADR     R14, %FT20
        Push    R14
        B       TTXScanFromHere

20

; now see if new bottom line should be a 'bottom' or a 'top' line

        ADRL    R0, TTXLineStarts
        LDR     R0, [R0, #23*4]                 ; R0 -> dummy word on line 23
        LDRB    R1, [WsPtr, #TTXDoubleCounts+23] ; no. of dbls on line 23
        TEQ     R1, #0                          ; if R1=0 then line 24 is 'top'
        LDRNE   R1, [R0]                        ; else line 24 is opposite
        EORNE   R1, R1, #MapBit_Bottom          ; of line 23
        ANDNE   R1, R1, #MapBit_Bottom
        LDR     R2, [R0, #41*4]                 ; R2 = dummy word on line 24
        BIC     R2, R2, #MapBit_Bottom          ; clear that bit
        ORR     R2, R2, R1                      ; OR in new bit
        STR     R2, [R0, #41*4]                 ; and store back

        Pull    PC

; *****************************************************************************
;
;       TTXSoftScrollUp - Scroll screen up by software in teletext mode
;

TTXSoftScrollUp ROUT

; first scroll map up

        LDR     R0, [WsPtr, #RowLength]         ; save real RowLength
        LDR     R1, [WsPtr, #TWTRow]            ; top row
        LDR     R3, [WsPtr, #TWBRow]            ; bottom row

        ADRL    R2, TTXLineStarts
        LDR     R2, [R2, R1, LSL #2]            ; R2 -> dummy char top row
        ADD     R2, R2, #4                      ; R2 -> 0th char top row
        LDR     R4, [WsPtr, #TWLCol]
        LDR     R5, [WsPtr, #TWRCol]

        Push    "R0-R6,R14"                     ; and save CursorFlags
        
        ADD     R2, R2, R4, LSL #2              ; R2 -> top left char

        SUB     R5, R5, R4
        ADD     R5, R5, #1                      ; R5 = no. of chars wide
        MOV     R5, R5, LSL #2                  ; R5 = no. of bytes / line

        SUB     R6, R3, R1
        ADD     R6, R6, #1                      ; R6 = no. of 'pixel' rows

        MOV     R7, #41*4                       ; R7 = line length
        STR     R7, [WsPtr, #RowLength]         ; pretend row length
        MOV     R0, #1                          ; pretend rowmult =1

        BL      SoftScrollUp2

        Pull    "R0-R6"
        STR     R0, [WsPtr, #RowLength]         ; restore RowLength

; now R1=top row, R2 -> char 0 on row R1, R3=bottom row, R4=left, R5=right

; now clear bottom row

        ADR     R7, TTXLineStarts
        LDR     R7, [R7, R3, LSL #2]            ; R7 -> dummy word(bottom)
        ADD     R8, R7, R5, LSL #2              ; R8 -> char before bottom rt
        ADD     R7, R7, R4, LSL #2              ; R7 -> char before bottom left
        MOV     R0, #32
30
        STRB    R0, [R7, #4]!                   ; zap to space
        CMP     R7, R8                          ; if <= char before bottom rt
        BLS     %BT30                           ; then loop

        MOV     R9, R2
CountAndRescan
        BL      CountDoubles

; now rescan from top of window

        ADD     R10, R3, #1                     ; R10 = bottom + 1
        MOV     R11, R1                         ; R11 = top
        ADD     R7, R2, R4, LSL #2              ; R7 = map(left,top)
        ADD     R5, R2, R5, LSL #2              ; R5 = map(right,top)
        MOV     R0, R4                          ; R0 = left
TTXScanZap2
        BL      AddressR0R1                     ; R2 = screen(left,top)
                                                ; (R1,R3,R4 corrupted)
        SUB     R4, R7, #8                      ; R4 = map(left,top)-8
        MOV     R3, R0                          ; R3 = left
        LDRB    R0, [R4, #8]                    ; R0 = first char
        MOV     R14, #1                         ; scan not zap
        B       TTXScanZap

; *****************************************************************************
;
;       CountDoubles - Count double height characters in a range of rows
;
; in:   R1 = top row to count
;       R3 = bottom row to count
;       R9 -> map(0,top)
;
; out:  R1-R6 preserved
;

CountDoubles ROUT
        ADD     R7, WsPtr, #TTXDoubleCounts
        ADD     R7, R7, R1                      ; R7 -> current double count
        MOV     R11, R1
10
        ADD     R8, R9, #40*4                   ; R8 -> dummy char next row
        MOV     R10, #0                         ; count so far
20
        LDR     R0, [R9], #4                    ; load char word
        AND     R0, R0, #&7F                    ; only look at bottom 7 bits
        TEQ     R0, #TTX_DoubleHeight           ; if double height
        ADDEQ   R10, R10, #1                    ; then increment count
        TEQ     R9, R8                          ; if not at end of row
        BNE     %BT20                           ; then loop

        STRB    R10, [R7], #1                   ; store double count
        ADD     R9, R9, #4                      ; skip dummy char
        ADD     R11, R11, #1                    ; goto next row
        CMP     R11, R3                         ; if <= bottom
        BLS     %BT10                           ; then loop

        MOV     PC, R14

; *****************************************************************************
;
;       TTXHardScrollDown - Scroll teletext screen downwards
;

TTXHardScrollDown ROUT

; first scroll map down

        LDR     R0, [WsPtr, #RowLength]         ; save real RowLength
        Push    "R0, R6, R14"                   ; and save CursorFlags
        
        MOV     R0, #1                          ; pretend rowmult = 1
        LDR     R2, TTXLineStarts+24*4          ; R2 -> dummy char on bottom
        MOV     R5, #41*4                       ; R5 = no. of bytes horiz
        STR     R5, [WsPtr, #RowLength]         ; pretend rowlength
        MOV     R6, #25                         ; no. of 'pixel' rows
        MOV     R7, R5                          ; linelength
        BL      SoftScrollDown2

        Pull    "R0, R6"
        STR     R0, [WsPtr, #RowLength]         ; restore RowLength

; now 'scroll' DoubleCounts

        ADD     R0, WsPtr, #TTXDoubleCounts
        ADD     R1, R0, #24
10
        LDRB    R2, [R1, #-1]
        STRB    R2, [R1], #-1
        TEQ     R1, R0
        BNE     %BT10

; now make top row a 'top' row

        LDR     R0, TTXLineStarts               ; R0 -> top line dummy word
        LDR     R1, [R0]                        ; R1 = dummy word
        BIC     R1, R1, #MapBit_Bottom          ; clear 'bottom' bit
        STR     R1, [R0]                        ; and store back

        Pull    PC

; *****************************************************************************
;
;       TTXSoftScrollDown - Scroll screen down by software in teletext mode
;

TTXSoftScrollDown ROUT

; first scroll map down

        LDR     R0, [WsPtr, #RowLength]         ; save real RowLength
        LDR     R1, [WsPtr, #TWTRow]            ; top row
        LDR     R3, [WsPtr, #TWBRow]            ; bottom row

        ADR     R2, TTXLineStarts
        LDR     R2, [R2, R3, LSL #2]            ; R2 -> dummy char bottom row
        ADD     R2, R2, #4                      ; R2 -> 0th char bottom row
        LDR     R4, [WsPtr, #TWLCol]
        LDR     R5, [WsPtr, #TWRCol]

        Push    "R0-R6,R14"                     ; and save CursorFlags
        
        ADD     R2, R2, R4, LSL #2              ; R2 -> bottom left char

        SUB     R5, R5, R4
        ADD     R5, R5, #1                      ; R5 = no. of chars wide
        MOV     R5, R5, LSL #2                  ; R5 = no. of bytes / line

        SUB     R6, R3, R1
        ADD     R6, R6, #1                      ; R6 = no. of 'pixel' rows

        MOV     R7, #41*4                       ; R7 = line length
        STR     R7, [WsPtr, #RowLength]         ; pretend row length
        MOV     R0, #1                          ; pretend rowmult =1

        BL      SoftScrollDown2

        Pull    "R0-R6"
        STR     R0, [WsPtr, #RowLength]         ; restore RowLength

; now R1=top row, R2 -> char 0 on row R3, R3=bottom row, R4=left, R5=right

; now clear top row

        ADR     R7, TTXLineStarts
        LDR     R7, [R7, R1, LSL #2]            ; R7 -> dummy word(top)
        ADD     R8, R7, R5, LSL #2              ; R8 -> char before top rt
        ADD     R7, R7, R4, LSL #2              ; R7 -> char before top left
        MOV     R0, #32
30
        STRB    R0, [R7, #4]!                   ; zap to space
        CMP     R7, R8                          ; if <= char before bottom rt
        BLS     %BT30                           ; then loop

        SUB     R9, R8, R5, LSL #2              ; R9 -> dummy word(top)
        ADD     R9, R9, #4                      ; R9 -> map(0,top)
        MOV     R2, R9
        B       CountAndRescan                  ; count doubles and rescan
                                                ; from top of window

; *****************************************************************************
;
;       TTXScrollLeft - Scroll left (by software) in Teletext mode
;
; in:   R0 bit0=0 => scroll window
;               1 => scroll screen
;

TTXScrollLeft ROUT
        Push    R14
        BL      TTXSideScroll1
        MOV     R5, R0                          ; R5 = left = column to check
                                                ; for double height chars
        BL      TTXSideScroll2                  ; do second part
        BL      ScrollLeft2

; now store spaces in right hand column

        Pull    "R0-R3, R6, R9"
        ADD     R4, R9, R2, LSL #2              ; R4 -> map(right,top)
TTXSideScroll3
        MOV     R7, R3                          ; R7 = current row
        MOV     R8, #32                         ; poke spaces
20
        STRB    R8, [R4], #41*4                 ; store space and move down
        ADD     R7, R7, #1                      ; next row
        CMP     R7, R1                          ; if row <= bottom
        BLS     %BT20                           ; then loop

; now rescan from top of window/screen

        ADD     R10, R1, #1                     ; R10 = bottom+1
        MOV     R11, R3                         ; R11 = top
        ADD     R7, R9, R0, LSL #2              ; R7 -> map(left,top)
        ADD     R5, R9, R2, LSL #2              ; R5 -> map(right,top)
        MOV     R1, R3                          ; R1 = top
        B       TTXScanZap2

; *****************************************************************************
;
;       TTXScrollRight - Scroll right (by software) in Teletext mode
;
; in:   R0 bit0=0 => scroll window
;               1 => scroll screen
;

TTXScrollRight ROUT
        Push    R14
        BL      TTXSideScroll1
        MOV     R5, R2                          ; R5 = right = column to check
                                                ; for double height chars
        BL      TTXSideScroll2
        BL      ScrollRight2

; now store spaces in left hand column

        Pull    "R0-R3, R6, R9"
        ADD     R4, R9, R0, LSL #2              ; R4 -> map(left,top)
        B       TTXSideScroll3

; *****************************************************************************
;
;       TTXSideScroll1 - Do first part of sideways scroll
;

TTXSideScroll1 ROUT
        MOVS    R0, R0, LSR #1

; C=0 => scroll window

        ADDCC   R0, WsPtr, #TWLCol              ; R0 = left, R1 = bottom
        LDMCCIA R0, {R0-R3}                     ; R2 = right, R3 = top

; C=1 => scroll screen

        MOVCS   R0, #0                          ; left
        LDRCS   R1, [WsPtr, #ScrBRow]           ; bottom
        LDRCS   R2, [WsPtr, #ScrRCol]           ; right
        MOVCS   R3, #0                          ; top

        MOV     PC, R14

; *****************************************************************************
;
;       TTXSideScroll2 - Do second part of sideways scroll
;
; in:   R5 = left or right hand column for left or right scroll respectively
;

TTXSideScroll2 ROUT

; first check char R5 on each line and decrement double count if a double

        ADR     R4, TTXLineStarts
        LDR     R4, [R4, R3, LSL #2]            ; R4 -> map(dummy,top)
        ADD     R9, R4, #4                      ; R9 -> map(0,top)
        ADD     R4, R9, R5, LSL #2              ; R4 -> map(left or right,top)

        ADD     R5, WsPtr, #TTXDoubleCounts
        MOV     R7, R3                          ; R7 = current row
10
        LDR     R8, [R4], #41*4                 ; get char+attr
        AND     R8, R8, #&7F
        TEQ     R8, #TTX_DoubleHeight           ; test if double height char

        LDREQB  R8, [R5, R7]                    ; if so then load double count
        SUBEQ   R8, R8, #1                      ; decrement it
        STREQB  R8, [R5, R7]                    ; and store back

        ADD     R7, R7, #1                      ; next row
        CMP     R7, R1                          ; if row <= bottom
        BLS     %BT10                           ; then loop

; now scroll map

        Push    "R0-R3, R6, R9"
        SUB     R5, R2, R0                      ; R5 = right-left
        ADD     R5, R5, #1                      ; R5 = right-left+1
        MOV     R5, R5, LSL #2                  ; R5 = (right-left+1)*4
        ADD     R2, R9, R0, LSL #2              ; R2 -> map(left,top)
        SUB     R6, R1, R3                      ; R6 = bottom-top
        ADD     R6, R6, #1                      ; R6 = bottom-top+1
        MOV     R7, #41*4                       ; linelength
        MOV     R9, #4                          ; no. of bytes to scroll by

        MOV     PC, R14

; *****************************************************************************
;
;       TTXPaintChar - Paint char according to attributes
;
; in:   R0 = character + attributes word
;       R2 -> screen (for the time being)
;
; out:  R2 preserved
;       R0 largely preserved, but held graphic bits may have been changed
;

TTXPaintChar ROUT
        Push    R14
        VDWS    WsPtr                           ; for now

; first set up the colours

        ADD     R1, WsPtr, #TForeCol
        LDMIA   R1, {R1, R3}                    ; R1 = TForeCol; R3 = TBackCol
        MOV     R4, #&0F
        AND     R5, R4, R0, LSR #MapForeShift   ; R5 = new foregd colour
        AND     R6, R4, R0, LSR #MapBackShift   ; R6 = new backgd colour

        TEQ     R1, R5                          ; if foregd different
        TEQEQ   R3, R6                          ; or backgd different
        BLNE    TTXUpdateColours                ; then update colour table

        ADR     R1, TTXHardFont-32*10           ; R1 -> base for font
        MOVS    R3, R0, LSL #26                 ; C := bit6, N := bit5
        AND     R3, R0, #&7F                    ; R3 = char
        BMI     %FT10                           ; [&20-&3F or &60-&7F]
        BCS     %FT20                           ; [&40-&5F (definitely Alpha)]

; control code, so display as space or held graphic

        TST     R0, #MapBit_Hold                ; zero if not holding
        MOVEQ   R3, #&20                        ; pretend to be space
        BICEQ   R0, R0, #MapBit_HeldMask        ; and cancel held graphic
        BEQ     %FT20                           ; [display as space]

; next instruction assumes no valid bits above held graphic bits

        MOV     R3, R0, LSR #MapHeldShift       ; R3 = char to display
        B       %FT30                           ; [display as held graphic]

; char in range &20-&3F or &60-&7F, so check for alpha/graphics

10
        TST     R0, #MapBit_Graph               ; in graphics mode
        BEQ     %FT20                           ; [no, so definitely Alpha]
        TST     R0, #MapBit_Separated           ; separated graphics ?
        BICEQ   R3, R3, #&20                    ; no, then make &00-&1F,&40-&5F
        BIC     R0, R0, #MapBit_HeldMask        ; cancel current held graphic
        ORR     R0, R0, R3, LSL #MapHeldShift   ; and put new one in
30
        ADD     R1, WsPtr, #TTXSoftFonts
20
        ADD     R1, R1, R3, LSL #3              ; add 8*char
        ADD     R1, R1, R3, LSL #1              ; add 2*char

        TST     R0, #MapBit_Conceal             ; concealing ?
        ADRNE   R1, TTXHardFont                 ; yes, then display as space

; now load font bytes
; 0..3 into tophalf
; 4..7 into bottomhalf
; 8..9 into R10 (top 2 bytes)

        TST     R1, #2                          ; starting on a word bdy ?

        SUBNE   R1, R1, #2                      ; if not, move back
        LDMIA   R1, {tophalf, bottomhalf, R10}  ; yes, so load all 3 up
        MOVEQ   R10, R10, LSL #16
        MOVNE   tophalf, tophalf, LSR #16
        ORRNE   tophalf, tophalf, bottomhalf, LSL #16
        MOVNE   bottomhalf, bottomhalf, LSR #16
        ORRNE   bottomhalf, bottomhalf, R10, LSL #16

        TST     R0, #(MapBit_Bottom :OR: MapBit_Double)
        BLNE    PrintDoubleHeight

        LDR     bigfont, [WsPtr, #TextExpandArea]
        MOV     mask, #&FF000000
        LDR     linelen, [WsPtr, #LineLength]
        Push    "R0, screen"
        MOV     R0, #0                          ; indicate 10 rows
        BL      Wrch4bitTTX                     ; do 1st bank

        LDMFD   R13, {R0, screen}               ; restore char + scr. addr
        ADD     screen, screen, #40*1024
        TST     R0, #MapBit_Flash
        MOVNE   mask, #0                        ; flash => 2nd bank is space
        MOV     R0, #0
        BL      Wrch4bitTTX
        Pull    "R0, screen, PC"

; *****************************************************************************

TTXLineStarts
        GBLA    lineno
lineno  SETA    0
        WHILE   lineno < 25
        &       VduDriverWorkSpace+TTXMap+4*41*lineno
lineno  SETA    lineno +1
        WEND

        LTORG

; *****************************************************************************
;
;       DoPreControl  - Process 'at'    action of control char
;       DoPostControl - Process 'after' action of control char
;
; in:   R0 = new char + attributes of current previous char
;       R1 = new char AND &7F
;       (0 <= R1 <= 31)
;

DoPreControl ROUT
        ADD     PC, PC, R1, LSL #3
DoPostControl ROUT
        ADD     PC, PC, R1, LSL #3
        MOV     PC, R14                 ; &00 Pre
        MOV     PC, R14                 ; &00 Post
        MOV     PC, R14                 ; &01 Pre
        B       DoAlphaColour           ; &01 Post
        MOV     PC, R14                 ; &02 Pre
        B       DoAlphaColour           ; &02 Post
        MOV     PC, R14                 ; &03 Pre
        B       DoAlphaColour           ; &03 Post
        MOV     PC, R14                 ; &04 Pre
        B       DoAlphaColour           ; &04 Post
        MOV     PC, R14                 ; &05 Pre
        B       DoAlphaColour           ; &05 Post
        MOV     PC, R14                 ; &06 Pre
        B       DoAlphaColour           ; &06 Post
        MOV     PC, R14                 ; &07 Pre
        B       DoAlphaColour           ; &07 Post
        MOV     PC, R14                 ; &08 Pre
        B       DoFlash                 ; &08 Post
        BIC     R0, R0, #MapBit_Flash   ; &09 Pre       ; clear flash mode
        MOV     PC, R14                 ; &09 Post
        B       DoPreEndBox             ; &0A Pre
        B       DoPostEndBox            ; &0A Post
        B       DoPreStartBox           ; &0B Pre
        B       DoPostStartBox          ; &0B Post
        B       DoSingleHeight          ; &0C Pre
        MOV     PC, R14                 ; &0C Post
        B       DoDoubleHeight          ; &0D Pre
        MOV     PC, R14                 ; &0D Post
        MOV     PC, R14                 ; &0E Pre
        MOV     PC, R14                 ; &0E Post
        MOV     PC, R14                 ; &0F Pre
        MOV     PC, R14                 ; &0F Post
        MOV     PC, R14                 ; &10 Pre
        MOV     PC, R14                 ; &10 Post
        MOV     PC, R14                 ; &11 Pre
        B       DoGraphColour           ; &11 Post
        MOV     PC, R14                 ; &12 Pre
        B       DoGraphColour           ; &12 Post
        MOV     PC, R14                 ; &13 Pre
        B       DoGraphColour           ; &13 Post
        MOV     PC, R14                 ; &14 Pre
        B       DoGraphColour           ; &14 Post
        MOV     PC, R14                 ; &15 Pre
        B       DoGraphColour           ; &15 Post
        MOV     PC, R14                 ; &16 Pre
        B       DoGraphColour           ; &16 Post
        MOV     PC, R14                 ; &17 Pre
        B       DoGraphColour           ; &17 Post
        ORR     R0, R0, #MapBit_Conceal ; &18 Pre       ; set conceal mode
        MOV     PC, R14                 ; &18 Post
        MOV     PC, R14                 ; &19 Pre
        BIC     R0, R0, #MapBit_Separated ; &19 Post    ; clear separated
        MOV     PC, R14                 ; &1A Pre
        ORR     R0, R0, #MapBit_Separated ; &1A Post    ; set separated
        MOV     PC, R14                 ; &1B Pre
        MOV     PC, R14                 ; &1B Post
        BIC     R0, R0, #MapBit_BackMask ; &1C Pre      ; clear backgd colour
        MOV     PC, R14                 ; &1C Post
        B       DoNewBackgd             ; &1D Pre
        MOV     PC, R14                 ; &1D Post
        ORR     R0, R0, #MapBit_Hold    ; &1E Pre       ; set hold graph mode
        MOV     PC, R14                 ; &1E Post
        MOV     PC, R14                 ; &1F Pre
        BIC     R0, R0, #MapBit_Hold    ; &1F Post      ; clear hold graph mode
        MOV     PC, R14

; *****************************************************************************

DoAlphaColour
        BIC     R0, R0, #MapBit_HeldMask        ; clear held graphic
        BIC     R0, R0, #(MapBit_ForeMask :OR: MapBit_Conceal)
                                                ; clear colour + conceal
        ORR     R0, R0, R1, LSL #MapForeShift   ; put in new colour
        BIC     R0, R0, #MapBit_Graph           ; set alpha mode
        MOV     PC, R14

DoGraphColour
        BIC     R0, R0, #(MapBit_ForeMask :OR: MapBit_Conceal)
                                                ; clear colour + conceal
        AND     R3, R1, #&07                    ; ensure only colour bits
        ORR     R0, R0, R3, LSL #MapForeShift   ; put in new colour
        ORR     R0, R0, #MapBit_Graph           ; set graph mode
        MOV     PC, R14

DoFlash
        ORR     R0, R0, #MapBit_Flash           ; set flash mode
        MOV     PC, R14

DoNewBackgd
        AND     R3, R0, #MapBit_ForeMask        ; R5 = fore colour
        BIC     R0, R0, #MapBit_BackMask        ; clear old backgd
        ORR     R0, R0, R3, LSL #(MapBackShift-MapForeShift) ; new backgd
        MOV     PC, R14

DoDoubleHeight
        TST     R0, #MapBit_Double              ; if currently single height
        BICEQ   R0, R0, #MapBit_HeldMask        ; then cancel held graphic
        ORR     R0, R0, #MapBit_Double          ; set double height mode
        ADD     R9, R9, #1                      ; one more double char
        MOV     PC, R14

DoSingleHeight
        TST     R0, #MapBit_Double              ; if currently double height
        BICNE   R0, R0, #MapBit_HeldMask        ; then cancel held graphic
        BIC     R0, R0, #MapBit_Double          ; set single height mode
        MOV     PC, R14

DoPreStartBox
        TST     R0, #MapBit_PendingStart        ; if prev char was start box
        ORRNE   R0, R0, #MapBits_Boxed          ; then start boxed area
        MOV     PC, R14

DoPostStartBox
        ORR     R0, R0, #MapBit_PendingStart    ; "Previous char is Start Box"
        MOV     PC, R14

DoPreEndBox
        TST     R0, #MapBit_PendingEnd          ; if prev char was end box
        BICNE   R0, R0, #MapBits_Boxed          ; then end boxed area
        MOV     PC, R14

DoPostEndBox
        ORR     R0, R0, #MapBit_PendingEnd      ; "Previous char is End Box"
        MOV     PC, R14

; *****************************************************************************

TTXHardFont
        =       &00,&00,&00,&00,&00,&00,&00,&00,&00,&00 ; space
        =       &00,&08,&08,&08,&08,&08,&00,&08,&00,&00 ; !
        =       &00,&14,&14,&14,&00,&00,&00,&00,&00,&00 ; "
        =       &00,&0C,&12,&10,&38,&10,&10,&3E,&00,&00 ; `
        =       &00,&1C,&2A,&28,&1C,&0A,&2A,&1C,&00,&00 ; $
        =       &00,&30,&32,&04,&08,&10,&26,&06,&00,&00 ; %
        =       &00,&10,&28,&28,&10,&2A,&24,&1A,&00,&00 ; &
        =       &00,&08,&08,&08,&00,&00,&00,&00,&00,&00 ; '
        =       &00,&04,&08,&10,&10,&10,&08,&04,&00,&00 ; (
        =       &00,&10,&08,&04,&04,&04,&08,&10,&00,&00 ; )
        =       &00,&08,&2A,&1C,&08,&1C,&2A,&08,&00,&00 ; *
        =       &00,&00,&08,&08,&3E,&08,&08,&00,&00,&00 ; +
        =       &00,&00,&00,&00,&00,&00,&08,&08,&10,&00 ; ,
        =       &00,&00,&00,&00,&1C,&00,&00,&00,&00,&00 ; -
        =       &00,&00,&00,&00,&00,&00,&00,&08,&00,&00 ; .
        =       &00,&00,&02,&04,&08,&10,&20,&00,&00,&00 ; /
        =       &00,&08,&14,&22,&22,&22,&14,&08,&00,&00 ; 0
        =       &00,&08,&18,&08,&08,&08,&08,&1C,&00,&00 ; 1
        =       &00,&1C,&22,&02,&0C,&10,&20,&3E,&00,&00 ; 2
        =       &00,&3E,&02,&04,&0C,&02,&22,&1C,&00,&00 ; 3
        =       &00,&04,&0C,&14,&24,&3E,&04,&04,&00,&00 ; 4
        =       &00,&3E,&20,&3C,&02,&02,&22,&1C,&00,&00 ; 5
        =       &00,&0C,&10,&20,&3C,&22,&22,&1C,&00,&00 ; 6
        =       &00,&3E,&02,&04,&08,&10,&10,&10,&00,&00 ; 7
        =       &00,&1C,&22,&22,&1C,&22,&22,&1C,&00,&00 ; 8
        =       &00,&1C,&22,&22,&1E,&02,&04,&18,&00,&00 ; 9
        =       &00,&00,&00,&08,&00,&00,&08,&00,&00,&00 ; :
        =       &00,&00,&00,&08,&00,&00,&08,&08,&10,&00 ; ;
        =       &00,&04,&08,&10,&20,&10,&08,&04,&00,&00 ; <
        =       &00,&00,&00,&3E,&00,&3E,&00,&00,&00,&00 ; =
        =       &00,&10,&08,&04,&02,&04,&08,&10,&00,&00 ; >
        =       &00,&1C,&22,&04,&08,&08,&00,&08,&00,&00 ; ?
        =       &00,&1C,&22,&2E,&2A,&2E,&20,&1C,&00,&00 ; @
        =       &00,&08,&14,&22,&22,&3E,&22,&22,&00,&00 ; A
        =       &00,&3C,&22,&22,&3C,&22,&22,&3C,&00,&00 ; B
        =       &00,&1C,&22,&20,&20,&20,&22,&1C,&00,&00 ; C
        =       &00,&3C,&22,&22,&22,&22,&22,&3C,&00,&00 ; D
        =       &00,&3E,&20,&20,&3C,&20,&20,&3E,&00,&00 ; E
        =       &00,&3E,&20,&20,&3C,&20,&20,&20,&00,&00 ; F
        =       &00,&1C,&22,&20,&20,&26,&22,&1E,&00,&00 ; G
        =       &00,&22,&22,&22,&3E,&22,&22,&22,&00,&00 ; H
        =       &00,&1C,&08,&08,&08,&08,&08,&1C,&00,&00 ; I
        =       &00,&02,&02,&02,&02,&02,&22,&1C,&00,&00 ; J
        =       &00,&22,&24,&28,&30,&28,&24,&22,&00,&00 ; K
        =       &00,&20,&20,&20,&20,&20,&20,&3E,&00,&00 ; L
        =       &00,&22,&36,&2A,&22,&22,&22,&22,&00,&00 ; M
        =       &00,&22,&22,&32,&2A,&26,&22,&22,&00,&00 ; N
        =       &00,&1C,&22,&22,&22,&22,&22,&1C,&00,&00 ; O
        =       &00,&3C,&22,&22,&3C,&20,&20,&20,&00,&00 ; P
        =       &00,&1C,&22,&22,&22,&2A,&24,&1A,&00,&00 ; Q
        =       &00,&3C,&22,&22,&3C,&28,&24,&22,&00,&00 ; R
        =       &00,&1C,&22,&20,&1C,&02,&22,&1C,&00,&00 ; S
        =       &00,&3E,&08,&08,&08,&08,&08,&08,&00,&00 ; T
        =       &00,&22,&22,&22,&22,&22,&22,&1C,&00,&00 ; U
        =       &00,&22,&22,&22,&14,&14,&08,&08,&00,&00 ; V
        =       &00,&22,&22,&22,&2A,&2A,&2A,&14,&00,&00 ; W
        =       &00,&22,&22,&14,&08,&14,&22,&22,&00,&00 ; X
        =       &00,&22,&22,&14,&08,&08,&08,&08,&00,&00 ; Y
        =       &00,&3E,&02,&04,&08,&10,&20,&3E,&00,&00 ; Z
        =       &00,&00,&08,&10,&3E,&10,&08,&00,&00,&00 ; [
        =       &00,&20,&20,&20,&20,&2C,&02,&04,&08,&0E ; \
        =       &00,&00,&08,&04,&3E,&04,&08,&00,&00,&00 ; ]
        =       &00,&00,&08,&1C,&2A,&08,&08,&00,&00,&00 ; ^
        =       &00,&14,&14,&3E,&14,&3E,&14,&14,&00,&00 ; #
        =       &00,&00,&00,&00,&3E,&00,&00,&00,&00,&00 ; _
        =       &00,&00,&00,&1C,&02,&1E,&22,&1E,&00,&00 ; a
        =       &00,&20,&20,&3C,&22,&22,&22,&3C,&00,&00 ; b
        =       &00,&00,&00,&1E,&20,&20,&20,&1E,&00,&00 ; c
        =       &00,&02,&02,&1E,&22,&22,&22,&1E,&00,&00 ; d
        =       &00,&00,&00,&1C,&22,&3E,&20,&1C,&00,&00 ; e
        =       &00,&04,&08,&08,&1C,&08,&08,&08,&00,&00 ; f
        =       &00,&00,&00,&1E,&22,&22,&22,&1E,&02,&1C ; g
        =       &00,&20,&20,&3C,&22,&22,&22,&22,&00,&00 ; h
        =       &00,&08,&00,&18,&08,&08,&08,&1C,&00,&00 ; i
        =       &00,&08,&00,&08,&08,&08,&08,&08,&08,&10 ; j
        =       &00,&10,&10,&12,&14,&18,&14,&12,&00,&00 ; k
        =       &00,&18,&08,&08,&08,&08,&08,&1C,&00,&00 ; l
        =       &00,&00,&00,&34,&2A,&2A,&2A,&2A,&00,&00 ; m
        =       &00,&00,&00,&3C,&22,&22,&22,&22,&00,&00 ; n
        =       &00,&00,&00,&1C,&22,&22,&22,&1C,&00,&00 ; o
        =       &00,&00,&00,&3C,&22,&22,&22,&3C,&20,&20 ; p
        =       &00,&00,&00,&1E,&22,&22,&22,&1E,&02,&02 ; q
        =       &00,&00,&00,&16,&18,&10,&10,&10,&00,&00 ; r
        =       &00,&00,&00,&1E,&20,&1C,&02,&3C,&00,&00 ; s
        =       &00,&08,&08,&1C,&08,&08,&08,&04,&00,&00 ; t
        =       &00,&00,&00,&22,&22,&22,&22,&1E,&00,&00 ; u
        =       &00,&00,&00,&22,&22,&14,&14,&08,&00,&00 ; v
        =       &00,&00,&00,&22,&22,&2A,&2A,&14,&00,&00 ; w
        =       &00,&00,&00,&22,&14,&08,&14,&22,&00,&00 ; x
        =       &00,&00,&00,&22,&22,&22,&22,&1E,&02,&1C ; y
        =       &00,&00,&00,&3E,&04,&08,&10,&3E,&00,&00 ; z
        =       &00,&10,&10,&10,&10,&12,&06,&0A,&0E,&02 ; {
        =       &00,&14,&14,&14,&14,&14,&14,&14,&00,&00 ; |
        =       &00,&30,&08,&30,&08,&32,&06,&0A,&0E,&02 ; }
        =       &00,&00,&08,&00,&3E,&00,&08,&00,&00,&00 ; ~
        =       &00,&3E,&3E,&3E,&3E,&3E,&3E,&3E,&00,&00 ; &FF

        END
