        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS
        GET     hdr.Hardware

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  HAL_Timers
        EXPORT  HAL_TimerDevice
        EXPORT  HAL_TimerGranularity
        EXPORT  HAL_TimerMaxPeriod
        EXPORT  HAL_TimerSetPeriod
        EXPORT  HAL_TimerPeriod
        EXPORT  HAL_TimerReadCountdown

        EXPORT  HAL_CounterRate
        EXPORT  HAL_CounterPeriod
        EXPORT  HAL_CounterRead
        EXPORT  HAL_CounterDelay

HAL_Timers
        MOV     a1, #2                  ; 2 timers
        MOV     pc, lr

HAL_TimerDevice
        ADD     a1, a1, #4              ; devices 4 and 5
        MOV     pc, lr

HAL_CounterRate
HAL_TimerGranularity
        LDR     a1, =3686400            ; 3.6864MHz
        MOV     pc, lr

HAL_TimerMaxPeriod
        MOV     a1, #&10000             ; 16-bit counter
        MOV     pc, lr

HAL_TimerSetPeriod
        LDR     a4, TIMER_BASE_Address

        ADR     a3, TimerPeriods
        STR     a2, [a3, a1, LSL #2]

        SUBS    a2, a2, #1
        ASSERT  TIMER2LOAD - TIMER1LOAD = 32
        ADD     a4, a4, a1, LSL #5
        BMI     %FT50

        STR     a2, [a4, #TIMER1LOAD]
        LDR     a1, [a4, #TIMER1CONTROL]
        ORR     a1, a1, #&2C0           ; BZ manual, Enable, periodic
        BIC     a1, a1, #&00C           ; /1
        STR     a1, [a4, #TIMER1CONTROL]
        MOV     pc, lr

50      LDR     a1, [a4, #TIMER1CONTROL]
        BIC     a1, a1, #&80            ; Disable
        STR     a1, [a4, #TIMER1CONTROL]
        MOV     pc, lr

HAL_TimerPeriod
        ADR     a4, TimerPeriods
        LDR     a1, [a4, a1, LSL #2]
        MOV     pc, lr

HAL_CounterRead
        MOV     a1, #0
        ; Fall through

HAL_TimerReadCountdown
        LDR     a4, TIMER_BASE_Address

        ASSERT  TIMER2LOAD - TIMER1LOAD = 32
        ADD     a4, a4, a1, LSL #5

        LDRH    a1, [a4, #TIMER1VALUE]

        MOV     pc, lr

HAL_CounterPeriod
        LDR     a1, TimerPeriods + 0
        MOV     pc, lr

MicrosecToTicks * &EBEDFA44             ; 3.6864 * (2^30)

; If they want n ticks, wait until we've seen n+1 transitions of the clock.
HAL_CounterDelay
        LDR     a2, =MicrosecToTicks

        LDR     a4, TIMER_BASE_Address

        UMULL   ip, a1, a2, a1          ; (a1,ip) = ticks << 30

        ADDS    ip, ip, ip              ; shift up 1
        ADC     a1, a1, a1
        ADDS    ip, ip, ip              ; shift up 1
        ADC     a1, a1, a1
        ADDNE   a1, a1, #1              ; a1 = ticks (rounded up)

        LDRH    a2, [a4, #TIMER1VALUE]

10      LDRH    a3, [a4, #TIMER1VALUE]
        SUBS    ip, a2, a3              ; ip = difference in ticks
        ADDLO   ip, a2, #1              ; if wrapped, must have had at least old latch+1 ticks
        SUBS    a1, a1, ip
        MOVLO   pc, lr
        LDRH    a2, [a4, #TIMER1VALUE]
        SUBS    ip, a3, a2              ; ip = difference in ticks
        ADDLO   ip, a3, #1              ; if wrapped, must have had at least old latch+1 ticks
        SUBS    a1, a1, ip
        BHS     %BT10
        MOV     pc, lr

        END
