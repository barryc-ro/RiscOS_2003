;
;       These HAL entries fit the LinkUp UART.
;       This is subtely different from the ARM UART MacroCell
;

        EXPORT  HAL_UARTPorts
        EXPORT  HAL_UARTStartUp
        EXPORT  HAL_UARTShutdown
        EXPORT  HAL_UARTFeatures
        EXPORT  HAL_UARTReceiveByte
        EXPORT  HAL_UARTTransmitByte
        EXPORT  HAL_UARTLineStatus
        EXPORT  HAL_UARTInterruptEnable
        EXPORT  HAL_UARTRate
        EXPORT  HAL_UARTFormat
        EXPORT  HAL_UARTFIFOSize
        EXPORT  HAL_UARTFIFOClear
        EXPORT  HAL_UARTFIFOEnable
        EXPORT  HAL_UARTFIFOThreshold
        EXPORT  HAL_UARTInterruptID
        EXPORT  HAL_UARTBreak
        EXPORT  HAL_UARTModemControl
        EXPORT  HAL_UARTModemStatus
        EXPORT  HAL_UARTDevice

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>

        GET     Hdr:Proc
        GET     Hdr:OSEntries

        GET     hdr.StaticWS
        GET     hdr.Hardware

; Put base address into the a1, given port number in a1
        MACRO
$label  BaseAddr
        TEQ         a1, #0
        LDREQ       a1, UART1_Address
        LDRNE       a1, UART2_Address
        MEND

        AREA    |Asm$$Code|, CODE, READONLY, PIC

; The UART must be disabled before any of the control registers are reprogrammed
; Disable the UART (assumes base address set up)
        MACRO
$label  Disable $temp
        LDRB    $temp, [a1, #UARTCON]
        BIC     $temp, $temp, #UARTEN
        STRB    $temp, [a1, #UARTCON]
        MEND

; Enable the UART (assumes base address set up)
        MACRO
$label  Enable $temp
        LDRB    $temp, [a1, #UARTCON]
        ORR     $temp, $temp, #UARTEN
        STRB    $temp, [a1, #UARTCON]
        MEND

; Swap the bottom two bits of a word
        MACRO               ;  31 30 29 28 ... 3  2  1  0   C
$label  TwoBitSwap  $rn     ;
                            ;  x  x  x  x      x  x  1  0
        MOVS $rn,$rn,ROR#1  ;  0  x  x  x      x  x  x  1   0
        MOVS $rn,$rn,RRX    ;  0  0  x  x      x  x  x  x   1
        MOV $rn,$rn,ROR#31  ;  0  x  x  x      x  x  x  0   1
        ADC $rn,$rn,$rn     ;  x  x  x  x      x  x  0  1   1
        MEND

; int Ports(void)
;
;   Return array of UART port physical addresses.
;
HAL_UARTPorts
        MOV     a1, #2
        MOV     pc, lr

; void StartUp(int port)
;
HAL_UARTStartUp
        BaseAddr

        ; Enable the UART, and enable interrupt when error at top of FIFO
        MOV     a2, #UARTEN :OR: DMAONERR
        STRB    a2, [a1, #UARTCON]

        ; Disable the UART disabled interrupt
        ; - we're not interested.
        MOV     a2, #UDINT
        STRB    a2, [a1, #UARTINTMASK]
        MOV     pc, lr

; void Shutdown(int port)
;
HAL_UARTShutdown
        BaseAddr
        MOV     a2, #0
        STRB    a2, [a1,#UARTCON]
        MOV     pc, lr

; int Features(int port)
;
;      Bit 0:  FIFOs available
;      Bit 1:  DMA available
;      Bit 2:  Modem lines available
;
HAL_UARTFeatures
        TEQ     a1, #0
        MOVEQ   a1, #7
        MOVNE   a1, #3
        MOV     pc, lr

; int ReceiveByte(int port, int *status)
;
;   Returns the next byte from the FIFO (if enabled) or the holding register.
;   If status is non-NULL, the line status associated with the byte is
;   read (see LineStatus). The return value is only meaningful if a
;   received byte is available (bit 0 of *status will be set).
;
HAL_UARTReceiveByte
        Entry   "v1,v2"
        BaseAddr
        MOVS    v2, a2
        LDRNEB  a3, [a1, #UARTINTSTAT]      ; Read int state if retrning status
        LDRB    v1, [a1, #UARTDR]
        BLNE    HAL_UARTLineStatus_internal
        TEQ     v2, #0
        STRNE   a1, [v2]
        MOV     a1, v1
        EXIT

; void TransmitByte(int port, int byte)
;
HAL_UARTTransmitByte
        BaseAddr
        STRB    a2, [a1, #UARTDR]
        PHPSEI  a3, a4
        LDRB    a2, [a1, #UARTINTMASK]      ; Fudgetastic
        ORR     a2, a2, #TXINT
        STRB    a2, [a1, #UARTINTMASK]
        PLP     a3
        MOV     pc, lr

; int LineStatus(int port)
;
;      Bit 0: Receiver Data Ready
;      Bit 1: Overrun Error
;      Bit 2: Parity Error
;      Bit 3: Framing Error
;      Bit 4: Break Error
;      Bit 5: Transmitter Holding Register Empty
;      Bit 6: Transmitter Empty (including FIFO)
;      Bit 7: FIFO contains a Parity, Framing or Break error
;
;   Parity, Framing and Break errors are associated with each byte received.
;   Whether the values reported here are associated with the last byte
;   read using ReceiveByte or with the next byte to be read is undefined.
;   You should request the status using ReceiveByte to ensure accurate
;   identification of bytes with errors.
;
;   Error bits are cleared whenever status is read, using either LineStatus
;   or ReceiveByte with status non-NULL.
;
HAL_UARTLineStatus
        BaseAddr

        ; Read status information
        LDRB    a3, [a1, #UARTINTSTAT]

HAL_UARTLineStatus_internal
        LDRB    a2, [a1, #RXSTAT]

        ; Construct API data
        TST     a3, #RXINT
        MOVEQ   a1, #0 :SHL: 0
        MOVNE   a1, #1 :SHL: 0
        TST     a2, #OVERRUN
        ORRNE   a1, a1, #1 :SHL: 1
        TST     a2, #PARITY
        ORRNE   a1, a1, #1 :SHL: 2
        TST     a2, #FRAME

        ; This chip doesn't recognise break conditions...

        ORRNE   a1, a1, #1 :SHL: 3
        TST     a3, #TXINT
        ORRNE   a1, a1, #1 :SHL: 5
        TST     a3, #UTXEINT
        ORRNE   a1, a1, #1 :SHL: 6

        ; ... nor can it detect errors in the FIFO.

        MOV     pc, lr

; int InterruptEnable(int port, int eor, int mask)
;
;   Enables interrupts. Bits are:
;
;      Bit 0: Received Data Available (and Character Timeout)
;      Bit 1: Transmitter Holding Register Empty
;      Bit 2: Received Line Status
;      Bit 3: Modem Status
;
;   Returns previous state.
;
HAL_UARTInterruptEnable
        BaseAddr
        PHPSEI  ip, a4
        LDRB    a4, [a1, #UARTINTMASK]

        ; Swap bottom two bits
        TwoBitSwap  a4

        AND     a3, a4, a3
        EOR     a3, a2, a3

        ; Swap bottom two bits
        TwoBitSwap  a3

        STRB    a3, [a1, #UARTINTMASK]
        PLP     ip
        MOV     a1, a4
        MOV     pc, lr

; int Rate(int port, int baud16)
;
;   Sets the rate, in units of 1/16 of a baud. Returns the previous rate.
;   Use -1 to read.
;
HAL_UARTRate
        Entry   "v1"
        BaseAddr
        LDRB    a3, [a1, #L_UBRLCR]    ; Read the current baud rate
        LDRB    a4, [a1, #M_UBRLCR]
        LDR     v1, =UARTCLK
        ADD     a3, a3, a4
        ADD     a3, a3, #1
        MOV     a3, a3, LSL #4
        MUL     a3, v1, a3              ; a3 now contains baud rate * 16
        CMN     a2, #1                 ; Don't write if we're reading!
        BEQ     %FT10

; We need to program 3.6864MHz / (16 * baud rate) - 1

        DivRem  a4, v1, a2, lr
        CMP     v1, a2, LSR#1           ; If the remainder is greater than 1/2
        SUBLT   a4, a4, #1              ; the divisor, don't subtract the 1
        Disable a2                      ; to make it round up
        STRB    a4, [a1, #L_UBRLCR]
        MOV     a4, a4, LSR#8
        STRB    a4, [a1, #M_UBRLCR]
        PHPSEI  , a4
        LDRB    a4, [a1, #H_UBRLCR]
        STRB    a4, [a1, #H_UBRLCR]     ; Kick this register to relatch M+L
        PLP
        Enable  a2

10      MOV     a3, a1                  ; Return previous state
        EXIT

; int Format(int port, int format)
;
;   Bits 0-1: Bits per word  0=>5, 1=>6, 2=>7, 3=>8
;   Bit 2:    Stop length 0=>1, 1=>2 (1.5 if 5 bits)
;   Bit 3:    Parity enabled
;   Bits 4-5: Parity:  0 => Odd (or disabled)
;                      1 => Even
;                      2 => Mark (parity bit = 1)
;                      3 => Space (parity bit = 0)
;
;   Returns previous format. -1 to read.
;

; Layout of line control register in 7205 is:
; 0 Break
; 1 Enable parity
; 2 Even parity
; 3 Extra stop bit
; 4 Enable FIFO
; 5&6 0=8 bits, 1=7 bits, 2=6 bits, 3=5 bits
HAL_UARTFormatMask    *  WORDLEN0:OR:WORDLEN1:OR:XSTOP:OR:PRTEN:OR:EVENPRT

HAL_UARTFormat
        BaseAddr
        LDRB    a3, [a1, #H_UBRLCR]              ; Record old state
        CMN     a2, #1
        BEQ     %FT10
        BIC     a4, a3, #HAL_UARTFormatMask

        ; Convert into bit format for Link Up
        TST     a2,     #2_00000001
        ORREQ   a4, a4, #WORDLEN1      ; NOT low bit of API
        TST     a2,     #2_00000010
        ORREQ   a4, a4, #WORDLEN0      ; NOT high bit of API
        TST     a2,     #2_00000100
        ORRNE   a4, a4, #XSTOP
        TST     a2,     #2_00001000
        ORRNE   a4, a4, #PRTEN
        TST     a2,     #2_00010000
        ORRNE   a4, a4, #EVENPRT
        Disable a2
        STRB    a4, [a1, #H_UBRLCR]
        Enable  a2

        ; Convert old state into API format
10      MOV     a1, #0
        TST     a3,     #WORDLEN1
        ORREQ   a1, a1, #2_00000001             ; NOT high bit of LinkUp
        TST     a3,     #WORDLEN0
        ORREQ   a1, a1, #2_00000010             ; NOT low bit of LinkUp
        TST     a3,     #XSTOP
        ORRNE   a1, a1, #2_00000100
        TST     a3,     #PRTEN
        ORRNE   a1, a1, #2_00001000
        TST     a3,     #EVENPRT
        ORRNE   a1, a1, #2_00010000

        MOV     pc, lr

; void FIFOSize(int port, int *rx, int *tx)
;
;   Returns the size of the RX and TX FIFOs. Either parameter may be NULL.
;   Note that the size of the TX FIFO is the total amount of data that can
;   be sent immediately when the Transmitter Holding Register Empty
;   status holds. (So an unusual UART that had a transmit threshold
;   should return total FIFO size minus threshold).
;
HAL_UARTFIFOSize
        BaseAddr
        MOV     a1, #8                  ; Threshold is 8 bytes free/used
        TEQ     a2, #0
        STRNE   a1, [a2]
        TEQ     a3, #0
        STRNE   a1, [a3]
        MOV     pc, lr

; void FIFOClear(int port, int flags)
;
;   Clears the input FIFO (if bit 0 set) and the output FIFO (if bit 1 set).
;
HAL_UARTFIFOClear
        BaseAddr
        ; The chip does not allow this function
        MOV     pc, lr

; int FIFOEnable(int port, int enable)
;
;   Enables or disables the RX and TX FIFOs: 0 => disable, 1 => enable
;   -1 => read status. Returns previous status.
;
HAL_UARTFIFOEnable
        BaseAddr
        LDRB    a3, [a1, #H_UBRLCR]
        CMP     a2, #0
        BLT     %FT10
        BICEQ   a3, a3, #FIFOEN
        ORRNE   a3, a3, #FIFOEN
        Disable a4
        STRB    a3, [a1, #H_UBRLCR]
        Enable  a4

10      TST     a3, #FIFOEN
        MOVEQ   a1, #0
        MOVNE   a1, #1
        MOV     pc, lr

; int FIFOThreshold(int port, int threshold)
;
;   Sets the receive threshold level for the FIFO RX interrupt. Normally
;   available values are 1,4,8 and 14 bytes. Returns previous value.
;   -1 to read.
;
HAL_UARTFIFOThreshold
        ; Chip does not support this
        MOV     a1, #8
        MOV     pc, lr

; int InterruptID(int port)
;
;   Returns the highest priority interrupt currently asserted. In order
;   of priority:
;
;   3 => Receiver Line Status (Cleared by ReceiveByte)
;   2 => Received Data Available (Cleared by reading enough data)
;   6 => Character Timeout (received data waiting)
;   1 => Transmitter Holding Register Empty (Cleared by this call)
;   0 => Modem Status (Cleared by ModemStatus)
;   -1 => No Interrupt
;
;   The Modem Status interrupt occurs when the CTS, DSR or DCD inputs
;   change, or when RI goes from high to low (ie bits 0 to 3 of ModemStatus
;   are set).
;
HAL_UARTInterruptID
        BaseAddr
        LDRB    a4, [a1, #UARTINTSTAT]
        LDRB    a3, [a1, #UARTINTMASK]
        AND     a4, a4, a3

        TST     a4, #RXERRINT
        MOVNE   a1, #3
        MOVNE   pc, lr

        TST     a4, #RXINT
        BEQ     %FT10
        TST     a4, #URXTINT
        MOVEQ   a1, #2
        MOVNE   a1, #6
        MOV     pc, lr

10      TST     a4, #TXINT
        BEQ     %FT20

        PHPSEI  a3, a4
        LDRB    a2, [a1, #UARTINTMASK]          ; this call must clear the interrupt
        BIC     a2, a2, #TXINT                  ; so we must mask it out temporarily
        STRB    a2, [a1, #UARTINTMASK]
        PLP     a3

        MOV     a1, #1
        MOV     pc, lr

20      TST     a4, #MSINT
        MOVNE   a1, #0
        MOVNE   pc, lr

        MOV     a1, #-1
        MOV     pc, lr

; int Break(int port, int enable)
;
;   Activates (1) or deactivates (0) a break condition. -1 to read,
;   returns previous state.
;
HAL_UARTBreak
        BaseAddr
        LDRB    a3, [a1, #H_UBRLCR]
        CMP     a2, #0
        BLT     %FT10
        BICEQ   a2, a3, #BREAK
        ORRNE   a2, a3, #BREAK
        Disable a4
        STRB    a2, [a1, #H_UBRLCR]
        Enable  a4

10      TST     a3, #BREAK
        MOVEQ   a1, #0
        MOVNE   a1, #1
        MOV     pc, lr

; int ModemControl(int port, int eor, int mask)
;
;   Modifies the modem control outputs.
;
;   Bit 0: DTR
;   Bit 1: RTS
;
;   Note that these are logical outputs, although the physical pins may be
;   inverted.  So 1 indicates a request to send.  Returns previous state.
;   Needs to clear the modem interrupt status.
;
TVILink_RTS             *   1 :SHL: 5
TVILink_DTR             *   1 :SHL: 6
SDB_RTS                 *   1 :SHL: 2
SDB_DTR                 *   1 :SHL: 3

HAL_UARTModemControl
        Entry   "v1"
        BaseAddr

        ; The modem interrupt can take a while to clear.
        MOV     a4, #MSINT
        STRB    a4, [a1, #UARTINTCLR]
        MOV     a4, #&10000                     ; Timeout
10      LDRB    lr, [a1, #UARTINTSTAT]
        SUBS    a4, a4, #1
        TSTNE   lr, #MSINT
        BNE     %BT10

 [ SDB
        LDR     ip, AUX_REG_Address
        PHPSEI  v1, a4
        LDRB    a4, AUX_REG_SoftCopy

        ; Convert into API format
        TST     a4, #SDB_DTR
        MOVEQ   lr, #0
        MOVNE   lr, #1
        TST     a4, #SDB_RTS
        ORRNE   lr, lr, #2
 |
        ; Read GPIO register containing modem bits
        LDR     ip, GPIO_BASE_Address
        LDRB    a4, [ip, #PEDR]

        ; Convert into API format
   [ {TRUE}
        TST     a4, #TVILink_DTR
        MOVNE   lr, #0
        MOVEQ   lr, #1
        TST     a4, #TVILink_RTS
        ORREQ   lr, lr, #2
   |
        TST     a4, #TVILink_DTR
        MOVEQ   lr, #0
        MOVNE   lr, #1
        TST     a4, #TVILink_RTS
        ORRNE   lr, lr, #2
   ]
 ]

        ; Apply the bit switching
        AND     a3, a3, lr
        EOR     a3, a3, a2

 [ SDB
        ; Convert back into SDB format and write it back
        BIC     a4, a4, #SDB_RTS:OR:SDB_DTR
        TST     a3, #1
        ORRNE   a4, a4, #SDB_DTR
        TST     a3, #2
        ORRNE   a4, a4, #SDB_RTS
        STRB    a4, [ip]
        STRB    a4, AUX_REG_SoftCopy
        PLP     v1
 |
        ; Convert back into TViLink format and write it back
   [ {TRUE}
        ORR     a4, a4, #TVILink_RTS:OR:TVILink_DTR
        TST     a3, #1
        BICNE   a4, a4, #TVILink_DTR
        TST     a3, #2
        BICNE   a4, a4, #TVILink_RTS
        STRB    a4, [ip, #PEDR]
   |
        BIC     a4, a4, #TVILink_RTS:OR:TVILink_DTR
        TST     a3, #1
        ORRNE   a4, a4, #TVILink_DTR
        TST     a3, #2
        ORRNE   a4, a4, #TVILink_RTS
        STRB    a4, [ip, #PEDR]
   ]
 ]

        ; Return original value
        MOV     a1, lr

        EXIT

; int ModemStatus(int port)
;
;   Reads the modem status inputs.
;
;   Bit 0: CTS changed since last call
;   Bit 1: DSR changed since last call
;   Bit 2: RI changed from high to low since last call
;   Bit 3: DCD changed since last call
;   Bit 4: CTS
;   Bit 5: DSR
;   Bit 6: RI
;   Bit 7: DCD
;
;   Note that these are logical inputs, although the physical pins may be
;   inverted.  So 1 indicates a Clear To Send condition.  This must also clear
;   the modem interrupt status.
;
HAL_UARTModemStatus
        BaseAddr

        ; The modem interrupt can take a while to clear, so we do it now.
        MOV     a2, #MSINT
        STRB    a2, [a1, #UARTINTCLR]
        LDRB    a3, [a1, #UARTFLG]

        BIC     a3, a3, #UBUSY :OR: URXFE :OR: UTXFF
        TST     a3, #nDCD
        BIC     a3, a3, #nDCD
        ORRNE   a3, a3, #2_1000
        LDR     a2, UART1_ModemFlags
        STR     a3, UART1_ModemFlags
        ORR     a3, a3, a3, LSL#4
        EOR     a3, a3, a2
        MOV     a4, #&10000                     ; Timeout
10      LDRB    a2, [a1, #UARTINTSTAT]
        SUBS    a4, a4, #1
        TSTNE   a2, #MSINT
        BNE     %BT10
        MOV     a1, a3

        MOV     pc, lr

; int Device(int port)
;
;   Return the device number allocated to the UART port
;
HAL_UARTDevice
        ADD     a1, a1, #16
        MOV     pc, lr

        END
