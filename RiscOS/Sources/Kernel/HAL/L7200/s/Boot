        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>

        GET     Hdr:Proc
        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS
        GET     hdr.Hardware



; This version assumes a RISC OS image starting 64K after us.

        AREA    |!!!ROMStart|, CODE, READONLY, PIC

        ENTRY

HAL_Base

vectors B       start           ; Reset
        B       .               ; Undefined instruction
        B       .               ; SWI
        B       .               ; Prefetch abort
        B       .               ; Data abort
        B       .               ; (Address exception)
        B       .               ; IRQ
        B       .               ; FIQ

        DCD     64*1024         ; offset to RISC OS image

        ASSERT  . - HAL_Base < 0x60
        %       0x60 - (. - HAL_Base)
ROMsize
        DCD     0                       ; patched in by build system

HALdescriptor   DATA
        DCD     0
        DCD     HAL_Base - HALdescriptor
        DCD     64*1024
        DCD     HAL_EntryTable - HALdescriptor
        DCD     HAL_Entries
        DCD     HAL_WsSize

        MACRO
        HALEntry $name
        ASSERT  (. - HAL_EntryTable) / 4 = EntryNo_$name
        DCD     $name - HAL_EntryTable
        MEND

        MACRO
        NullEntry
        DCD     0
;        DCD     HAL_Null - HAL_EntryTable
        MEND

        IMPORT   Video_init
        IMPORT   Matrix_Init
 [ SDB
        IMPORT   SIB_Init
 |
        IMPORT   USB_Init
        IMPORT   NVMemory_Init
 ]

        IMPORT   HAL_IRQEnable
        IMPORT   HAL_IRQDisable
        IMPORT   HAL_IRQClear
        IMPORT   HAL_IRQSource
        IMPORT   HAL_FIQDisableCode

        IMPORT   HAL_Timers
        IMPORT   HAL_TimerDevice
        IMPORT   HAL_TimerGranularity
        IMPORT   HAL_TimerMaxPeriod
        IMPORT   HAL_TimerSetPeriod
        IMPORT   HAL_TimerPeriod
        IMPORT   HAL_TimerReadCountdown

        IMPORT   HAL_CounterRate
        IMPORT   HAL_CounterPeriod
        IMPORT   HAL_CounterRead
        IMPORT   HAL_CounterDelay

        IMPORT   HAL_IICBuses
 [ :LNOT:SDB
        IMPORT   HAL_IICType
        IMPORT   HAL_IICSetLines
        IMPORT   HAL_IICReadLines
 ]

        IMPORT   HAL_NVMemoryType
 [ :LNOT:SDB
        IMPORT   HAL_NVMemorySize
        IMPORT   HAL_NVMemoryProtectedSize
        IMPORT   HAL_NVMemoryProtection
        IMPORT   HAL_NVMemoryRead
        IMPORT   HAL_NVMemoryWrite
 ]

        IMPORT   HAL_VideoFlybackDevice
        IMPORT   HAL_Video_SetMode
        IMPORT   HAL_Video_WritePaletteEntry
        IMPORT   HAL_Video_WritePaletteEntries
        IMPORT   HAL_Video_ReadPaletteEntry
        IMPORT   HAL_Video_SetInterlace
        IMPORT   HAL_Video_SetBlank
        IMPORT   HAL_Video_SetPowerSave
        IMPORT   HAL_Video_UpdatePointer
        IMPORT   HAL_Video_SetDAG
        IMPORT   HAL_Video_VetMode
        IMPORT   HAL_Video_PixelFormats
        IMPORT   HAL_Video_Features
        IMPORT   HAL_Video_BufferAlignment
        IMPORT   HAL_Video_OutputFormat

        IMPORT   HAL_MatrixColumns
        IMPORT   HAL_MatrixScan

 [ SDB
        IMPORT   HAL_TouchscreenType
        IMPORT   HAL_TouchscreenRead
        IMPORT   HAL_TouchscreenMode
        IMPORT   HAL_TouchscreenMeasure
 ]

        IMPORT   HAL_MachineID

        IMPORT   HAL_UARTPorts
        IMPORT   HAL_UARTStartUp
        IMPORT   HAL_UARTShutdown
        IMPORT   HAL_UARTFeatures
        IMPORT   HAL_UARTReceiveByte
        IMPORT   HAL_UARTTransmitByte
        IMPORT   HAL_UARTLineStatus
        IMPORT   HAL_UARTInterruptEnable
        IMPORT   HAL_UARTRate
        IMPORT   HAL_UARTFormat
        IMPORT   HAL_UARTFIFOSize
        IMPORT   HAL_UARTFIFOClear
        IMPORT   HAL_UARTFIFOEnable
        IMPORT   HAL_UARTFIFOThreshold
        IMPORT   HAL_UARTInterruptID
        IMPORT   HAL_UARTBreak
        IMPORT   HAL_UARTModemControl
        IMPORT   HAL_UARTModemStatus
        IMPORT   HAL_UARTDevice

HAL_EntryTable  DATA
        HALEntry HAL_Init

        HALEntry HAL_IRQEnable
        HALEntry HAL_IRQDisable
        HALEntry HAL_IRQClear
        HALEntry HAL_IRQSource
        HALEntry HAL_FIQDisableCode

        HALEntry HAL_Timers
        HALEntry HAL_TimerDevice
        HALEntry HAL_TimerGranularity
        HALEntry HAL_TimerMaxPeriod
        HALEntry HAL_TimerSetPeriod
        HALEntry HAL_TimerPeriod
        HALEntry HAL_TimerReadCountdown

        HALEntry HAL_CounterRate
        HALEntry HAL_CounterPeriod
        HALEntry HAL_CounterRead
        HALEntry HAL_CounterDelay

        HALEntry HAL_NVMemoryType
 [ SDB
        NullEntry
        NullEntry
        NullEntry
        NullEntry
        NullEntry
        NullEntry
 |
        HALEntry HAL_NVMemorySize
        HALEntry HAL_NVMemoryProtectedSize
        HALEntry HAL_NVMemoryProtection
        NullEntry
        HALEntry HAL_NVMemoryRead
        HALEntry HAL_NVMemoryWrite
 ]

        HALEntry HAL_IICBuses
 [ SDB
        NullEntry
        NullEntry
        NullEntry
 |
        HALEntry HAL_IICType
        HALEntry HAL_IICSetLines
        HALEntry HAL_IICReadLines
 ]

        HALEntry HAL_VideoFlybackDevice
        HALEntry HAL_Video_SetMode
        HALEntry HAL_Video_WritePaletteEntry
        HALEntry HAL_Video_WritePaletteEntries
        HALEntry HAL_Video_ReadPaletteEntry
        HALEntry HAL_Video_SetInterlace
        HALEntry HAL_Video_SetBlank
        HALEntry HAL_Video_SetPowerSave
        HALEntry HAL_Video_UpdatePointer
        HALEntry HAL_Video_SetDAG
        HALEntry HAL_Video_VetMode
        HALEntry HAL_Video_PixelFormats
        HALEntry HAL_Video_Features
        HALEntry HAL_Video_BufferAlignment
        HALEntry HAL_Video_OutputFormat

        HALEntry HAL_MatrixColumns
        HALEntry HAL_MatrixScan

 [ SDB
        HALEntry HAL_TouchscreenType
        HALEntry HAL_TouchscreenRead
        HALEntry HAL_TouchscreenMode
        HALEntry HAL_TouchscreenMeasure
 |
        NullEntry
        NullEntry
        NullEntry
        NullEntry
 ]

        HALEntry HAL_MachineID

        HALEntry HAL_ControllerAddress
        HALEntry HAL_HardwareInfo
        HALEntry HAL_SuperIOInfo

        HALEntry HAL_UARTPorts
        HALEntry HAL_UARTStartUp
        HALEntry HAL_UARTShutdown
        HALEntry HAL_UARTFeatures
        HALEntry HAL_UARTReceiveByte
        HALEntry HAL_UARTTransmitByte
        HALEntry HAL_UARTLineStatus
        HALEntry HAL_UARTInterruptEnable
        HALEntry HAL_UARTRate
        HALEntry HAL_UARTFormat
        HALEntry HAL_UARTFIFOSize
        HALEntry HAL_UARTFIFOClear
        HALEntry HAL_UARTFIFOEnable
        HALEntry HAL_UARTFIFOThreshold
        HALEntry HAL_UARTInterruptID
        HALEntry HAL_UARTBreak
        HALEntry HAL_UARTModemControl
        HALEntry HAL_UARTModemStatus
        HALEntry HAL_UARTDevice

HAL_Entries     * (.-HAL_EntryTable)/4

; v8 is used as pointer to RISC OS entry table throughout pre-MMU stage.
        MACRO
        CallOSM $entry, $reg
        LDR     ip, [v8, #$entry*4]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND

        MACRO
        CallOS  $entry
        ASSERT  $entry <= HighestOSEntry
        MOV     lr, pc
        LDR     pc, OSentries + 4*$entry
        MEND


start
        DIAG    off

        ADRL    v1, HAL_Base + 64*1024          ; v1 -> RISC OS image

        LDR     v8, [v1, #OSHdr_Entries]
        ADD     v8, v8, v1                      ; v8 -> RISC OS entry table

        MOV     a1, #0
        CallOSM OS_InitARM

        LDR     sp, =SRAM_BASE+SRAM_SIZE

        LDR     a4, =SYSTEM_BASE
        LDR     a1, [a4, #SYS_CONFIG_SDRAM]
        BIC     a1, a1, #PICEN
        STR     a1, [a4, #SYS_CONFIG_SDRAM]     ; power down Piccolo

        BL      sort_out_the_blasted_clocks

        BUZ     off

        BL      initialise_rom

        CMP     pc, #SDRAM_BASE                 ; don't init RAM if we're in it!
        BLLO    initialise_ram

        BL      initialise_timers

        MOV     v6, #SDRAM_BASE

        BL      initialise_uart

;        BL      initialise_mlcd

        LDR     a3, =SYSTEM_BASE

        LDR     a1, [a3, #SYS_STATUS]
        TST     a1, #1 :SHL: 10
        MOVNE   v3, #OSStartFlag_POR
        MOVEQ   v3, #0
        STR     a1, [a3, #SYS_STAT_CLR]

 [ MSI
SDRAM_SIZE 	* 16*1024*1024
 |
SDRAM_SIZE	* 32*1024*1024
 ]

        MOV     a1, #4:SHL:8
        LDR     a2, =SDRAM_BASE2 - (SDRAM_SIZE/2)
        ADR     a3, HAL_Base                    ; a3 = bottom of HAL, may be top of RAM
        CMP     a3, a2
	ADDLOS	a3, a2, #SDRAM_SIZE
        LDR     a4, =&FFFFFFFF
        MOV     ip, #0
        STR     ip, [sp, #-4]!
        CallOSM OS_AddRAM
        STR     a1, [sp]
        ADD     sp, sp, #4

        MOV     a4, a1
        MOV     a1, v3
        MOV     a2, v1
        ADR     a3, HALdescriptor
        CallOSM OS_Start


power_on_reset
        =       "Power-on reset", 10, 0
normal_reset
        =       "Normal reset", 10, 0
hello_string
        =       "Hello world!", 10, 0
syscon_string
        =       "SYS_CONFIG_CURRENT = ", 0
sdramcon_string
        =       10, "SYS_CONFIG_SDRAM = ", 0
        ALIGN



sort_out_the_blasted_clocks
        STMFD   sp!, {lr}

        BL      peripheral_clocks_off

        LDR     a4, =SYSTEM_BASE
        LDR     a1, =2_10:SHL:25                ; state change, no stall
        ORR     a1, a1, #&7F:SHL:18             ; pase a nice long time
        STR     a1, [a4, #SYS_CONFIG_NEXT]

                    ;  OSCEN   PLLEN
                    ;  |OSCMUX |PLLMUX
                    ;  ||PLLMUL||  BCLK_DIV
      [ PLL = 129
        LDR     a1, =2_10100011100010111        ; 3M6 osc, PLL on (129M), BCLK=PLL/4, SDRAM=CPU, not Fastbus
      |
        LDR     a1, =2_10101000100010111        ; 3M6 osc, PLL on (147M), BCLK=PLL/4, SDRAM=CPU, not Fastbus
      ]
                   ;   65432109876543210
        STR     a1, [a4, #SYS_CONFIG_RUN]
        STR     a1, [a4, #SYS_CONFIG_COMM]      ; initiate change
        LDR     a1, [a4, #SYS_CONFIG_COMM]

        LDR     a1, [a4, #SYS_CLOCK_SELECT]
      [ PLL = 129
        ORR     a1, a1, #3                      ; (SIBCLK = MIRCLK/2), MIRCLK = SYNCLK18M, CLK18M=BCLK/2
      |
        ORR     a1, a1, #1                      ; (SIBCLK = MIRCLK/2), MIRCLK = CLK18M, CLK18M=BCLK/2
      ]
        ORR     a1, a1, #3:SHL:24               ; FIRCLK = AUXPLLCLK, SICSYSCLK from AUXPLLCLK
      [ :LNOT:SDB
        ORR     a1, a1, #1:SHL:14               ; CLCLK = STCLK
      ]
        STR     a1, [a4, #SYS_CLOCK_SELECT]

        MOV     a1, #(13:SHL:2)+2_00            ; AUXPLLCLK = 13 * 3M6
        STR     a1, [a4, #SYS_CLOCK_AUX]

        LDR     a1, [a4, #SYS_CLOCK_ENABLE]
        BIC     a1, a1, #ALTD_EN
        ORR     a1, a1, #AUXPLL_EN
        STR     a1, [a4, #SYS_CLOCK_ENABLE]

      [ PLL = 129
        MOV     a1, #SYN_EN
      |
        MOV     a1, #B18M_EN
      ]
        BL      enable_clocks
;        MOV     a1, #CLCLK_EN
;        BL      enable_clocks
      [ :LNOT: SDB
        LDR     a4, =SYSTEM_BASE
        LDR     a3, [a4, #SYS_CLOCK_ENABLE]
        ORR     a3, a3, #STCLK_EN
        STR     a3, [a4, #SYS_CLOCK_ENABLE]
     ;   MOV     a1, #STCLK_EN
     ;   BL      enable_clocks
      ]
        MOV     a1, #BUART_EN
        BL      enable_clocks
        MOV     a1, #C3M6_EN
        BL      enable_clocks
        MOV     a1, #UARTM_EN
        BL      enable_clocks
        MOV     a1, #AUXCLK_EN
        BL      enable_clocks
        MOV     a1, #SICSYN_EN
        BL      enable_clocks
 [ {FALSE}
        MOV     a1, #USBHOST_EN
        BL      enable_clocks
 |
        LDR     a4, =SYSTEM_BASE
        LDR     a1, [a4, #SYS_CLOCK_ENABLE]
        ORR     a1, a1, #USBHOST_EN
        STR     a1, [a4, #SYS_CLOCK_ENABLE]
 ]
        LDMFD   sp!, {pc}


; Turn off clocks at the bottom of the tree first
peripheral_clocks_off
        STMFD   sp!, {lr}
        LDR     a1, =SIBADC_EN + UARTM_EN + MIRM_EN + USBHOST_EN; + STCLK_EN; + SICSYN_EN
        BL      disable_clocks
        MOV     a1, #C18MU_EN
        BL      disable_clocks
        LDR     a1, =BUART_EN + B18M_EN + C3M6_EN + FIR_EN + AUXCLK_EN
        BL      disable_clocks
        LDR     a4, =SYSTEM_BASE
        LDR     a3, [a4, #SYS_CLOCK_ENABLE]
        BIC     a3, a3, #AUXPLL_EN + STCLK_EN
        STR     a3, [a4, #SYS_CLOCK_ENABLE]
        LDMFD   sp!, {pc}

; void enable_clocks(int bits)
enable_clocks
        MOV     a2, a1
        B       modify_clocks

; void disable_clocks(int bits)
disable_clocks
        MOV     a2, #0
        B       modify_clocks

; void modify_clocks(int bits, int values)
modify_clocks
        LDR     a4, =SYSTEM_BASE
        LDR     a3, [a4, #SYS_CLOCK_ENABLE]
        BIC     a3, a3, a1
        ORR     a3, a3, a2
        STR     a3, [a4, #SYS_CLOCK_ENABLE]
01      LDR     a3, [a4, #SYS_CLOCK_ESYNC]
        AND     a3, a3, a1
        TEQ     a3, a2
        BNE     %BT01
        MOV     pc, lr




initialise_mlcd
        LDR     a4, =GPIO_BASE
        MOV     a1, #2_00011110
        STRB    a1, [a4, #PEDDR]                ; set up outputs on port E

        LDR     a4, =SMIREG_BASE                ; configure static memory for L1121 chip
        LDR     a1, [a4, #IOCFG2]
        LDR     a2, =2_00100000000001           ; 32-bit, slow, blah blah, blah
        MOV     a1, a1, LSR #16
        ORR     a1, a2, a1, LSL #16
        STR     a1, [a4, #IOCFG2]

        MOV     a4, #L1121_BASE                 ; set L1121 DAC
        MOV     a1, #0
        STR     a1, [a4, #DACCR]
        MOV     a1, #MLCD_Contrast
        STR     a1, [a4, #DACDR]

        LDR     a4, =DC_BASE                    ; enable DC-DC converter
        MOV     a1, #&0EE
        STR     a1, [a4, #PMPCON]

        LDR     a4, =MLCD_BASE
        MOV     a1, #ScreenBase :AND: &01FFFFFF
        STR     a1, [a4, #MLCDBASE]
        MOV     a1, #&F0                        ; Black on white (?)
        STR     a1, [a4, #MPALLSW]

        MOV     a1, #1
        STR     a1, [a4, #MLCDTIMING0]
        LDR     a1, =(0:SHL:24)+(0:SHL:16)+(MLCD_Width/4-1)
        STR     a1, [a4, #MLCDTIMING1]

        LDR     a3, =(1:SHL:25)+(PIXPRE:SHL:19)+((MLCD_Width/16-1):SHL:13)+((MLCD_Height-1):SHL:4)+MLCD_SRAM + 1
        STR     a3, [a4, #MLCDCON]

        LDR     a4, =GPIO_BASE
        MOV     a1, #2_00001000
        STRB    a1, [a4, #PEDR]                 ; turn on LCD
        MOV     pc, lr

; The timers are clocked by UARTCLK (3.6864MHz)
; We initially require a 100Hz timer, which means we program 36863 as the start value.
initialise_timers
        LDR     a4, =TIMER_BASE
        LDR     a1, [a4, #TIMER1CONTROL]
        BIC     a1, a1, #2_11000000000          ; use UARTCLK/1, STBUZ driven manually
        BIC     a1, a1, #2_00000001100
        ORR     a1, a1, #2_00011000000          ; periodic-timer mode, enabled
        STR     a1, [a4, #TIMER1CONTROL]
        LDR     a1, =36864-1
        STR     a1, [a4, #TIMER1LOAD]
        STR     a1, [a4, #TIMER1CLEAR]          ; clear any pending interrupt

        LDR     a1, [a4, #TIMER2CONTROL]        ; disable timer 2
        BIC     a1, a1, #2_10000000
        STR     a1, [a4, #TIMER2CONTROL]
        STR     a1, [a4, #TIMER2CLEAR]          ; clear any pending interrupt
        MOV     pc, lr



initialise_ram
        STMFD   sp!, {v1,lr}
        MOV     a1, #100
        BL      wait

        LDR     a4, =SDRAMREG_BASE
        ; Normal power, no auto-refresh, no auto-precharge, DMA and main write
        ; buffers disabled, both slots enabled, 4 banks, no tristate, clocks always on
        ; (performs the precharge)
        LDR     v1, =2_0000000000000000011001110 :OR: (CAS :SHL: 20)
        STR     v1, [a4, #SDRAMCFG]

        MOV     a1, #6
        STR     a1, [a4, #SDRAMRFSH]    ; fast refresh period

        ORR     v1, v1, #1:SHL:23       ; enable auto-refresh
        STR     v1, [a4, #SDRAMCFG]

        MOV     a1, #1
        BL      wait                    ; wait for 2 refreshes

        ; Program both SDRAMs for CAS, sequential burst of 8
        LDR     a4, =SDRAMMODE_BASE + (((CAS:SHL:4)+3):SHL:11)
        LDR     a1, [a4]

        ADD     a4, a4, #1:SHL:24
        LDR     a1, [a4]

        BUZ     off

        ASSERT  PLL = 129 :LOR: PLL = 147
        LDR     a4, =SDRAMREG_BASE
      [ PLL = 129
        MOV     a1, #504
      |
        MOV     a1, #576
      ]
        STR     a1, [a4, #SDRAMRFSH]    ; 15.625us refresh period

        MOV     a1, #&77
        STR     a1, [a4, #SDRAMWBFT]    ; 128 cycle write-buffer timeouts

        ;Enable DMA and main write buffers
        ORR     v1, v1, #2_11:SHL:16
        STR     v1, [a4, #SDRAMCFG]

        LDMFD   sp!, {v1,pc}

 [ SDB
; Timings for AMD AM29LV160DB-90EC flash (90ns access from CS, 35ns from IOE)
; Contention limit: 30ns
; cycle time = 27.13ns
;   non-burst/Flash device
;   2 cycles from CS to OE (54.3+7=61.3ns)
;   2 cycles OE hold (54.3ns)
;   device outputs 90ns after CS, 35ns after OE; ie 25.6ns into OE, giving 28.7ns hold (L7205 needs 10ns)
;   1.5 cycle recovery (40.7-7=33.7ns) - Flash spec says 30ns
IOCS0 * 2_00010100100111
 ]
 [ TViLink
; Timings for Intel 28F128J3A flash (150ns access from CS, 25ns burst access)
; Contention limit: 15ns
; cycle time = 27.13ns
;   4-word burst device
;   0 cycles from CS to OE (0+7=7ns)
;   6 cycles OE hold (162.8ns)
;   2 cycle burst (54.3ns)
;   device outputs 150ns after CS; ie 143ns into OE, giving 19.8ns hold (L7205 needs 10ns)
;   for burst, device outputs 25ns after address change, giving 29.3ns hold (not clear how much required - assume 10ns)
;   1.5 cycle recovery (40.7-7=33.7ns) - Flash spec says 15ns
IOCS0 * 2_01010111010111
 ]
 [ MSI
; Timings for Intel TE28F320CTA100 flash (100ns access from CS, 30ns from OE)
; Contention limit: 20ns
; cycle time = 27.13ns
;   non-burst/Flash device
;   3 cycles from CS to OE (81.39+7=88.39ns)
;   2 cycles OE hold (54.3ns)
;   device outputs 100ns after CS, 30ns after OE, giving 24.3ns hold (L7205 needs 10ns)
;  (acutally, just do 5 cycles CS+OE)
;   1.5 cycle recovery (40.7-7=33.7ns) - Flash spec says 20ns
IOCS0 * 2_00010011011111
 ]

initialise_rom
        LDR     R3, =SMIREG_BASE                ; set up cycle times for ROM bank 0
        LDR     R0, [R3, #IOCFG1]
        MOV     R0, R0, LSR #16
        LDR     R1, =IOCS0
        ORR     R0, R1, R0, LSL #16
        STR     R0, [R3, #IOCFG1]

        LDR     R3, =SYSTEM_BASE
        STR     R0, [R3, #SYS_RESET_REMAP]      ; get rid of the boot ROM
        MOV     PC, LR


; wait n microseconds (yuck)
wait
        MOV     R1, #19
        MUL     R0, R1, R0
01      SUBS    R0, R0, #1              ; 4 cycles min per loop, max 75MHz, so at least 53ns
        BNE     %BT01                   ; so 19 loops for one microsecond
        MOV     pc, lr

initialise_uart
        LDR     R3, =UART1_BASE
        MOV     R0, #&17        ; 9600 baud
        STRB    R0, [R3, #L_UBRLCR]
        MOV     R0, #0
        STRB    R0, [R3, #M_UBRLCR]
        MOV     R0, #2_0010000
        STRB    R0, [R3, #H_UBRLCR]
        MOV     R0, #2_00000001
        STRB    R0, [R3, #UARTCON]
  [ :LNOT: SDB
        LDR     R3, =GPIO_BASE
        LDRB    R0, [R3, #PEDDR]
        ORR     R0, R0, #&60
        STRB    R0, [R3, #PEDDR]
  ]
        MOV     PC, LR


;--------------------------------------------------------------------------------------


HAL_Init
        Entry

        BL      SetUpOSEntries

        MOV     a1, #0
        MOV     a2, #PERIPHERAL_BASE
        MOV     a3, #PERIPHERAL_SIZE
        CallOS  OS_MapInIO
        ADD     ip, a1, #CLCD_BASE - PERIPHERAL_BASE
        STR     ip, CLCD_Address
        ADD     ip, a1, #SIB_BASE - PERIPHERAL_BASE
        STR     ip, SIB_Address
        ADD     ip, a1, #UART1_BASE - PERIPHERAL_BASE
        STR     ip, UART1_Address
        ADD     ip, a1, #UART2_BASE - PERIPHERAL_BASE
        STR     ip, UART2_Address

        MOV     a1, #0
        MOV     a2, #APB_BASE
        MOV     a3, #APB_SIZE
        CallOS  OS_MapInIO

        ADD     ip, a1, #TIMER_BASE - APB_BASE
        STR     ip, TIMER_BASE_Address
        ADD     ip, a1, #INT_BASE - APB_BASE
        STR     ip, INT_BASE_Address

        ADD     ip, a1, #KEYBOARD_BASE - APB_BASE
        STR     ip, KEYBOARD_BASE_Address
        ADD     ip, a1, #GPIO_BASE - APB_BASE
        STR     ip, GPIO_BASE_Address

        MOV     a1, #0
        MOV     a2, #AUX_REG_BASE
        MOV     a3, #1
        CallOS  OS_MapInIO
 [ SDB
        STR     a1, AUX_REG_Address
        MOV     lr, #0
        STRB    lr, [a1]
        STRB    lr, AUX_REG_SoftCopy
 ]

        MOV     a1, #0
        MOV     a2, #USB_BASE
        MOV     a3, #USB_SIZE
        CallOS  OS_MapInIO
        STR     a1, USB_BASE_Address

        MOV     a1, #0
        LDR     a2, =FLASHNVMEM_BASE
        MOV     a3, #FLASHNVMEM_SIZE
        CallOS  OS_MapInIO
        STR     a1, FLASHNVMEM_Address

 [ SDB
        BL      Matrix_Init
 |
        LDR     a4, KEYBOARD_BASE_Address
        MOV     a1, #0
        STR     a1, [a4, #KBDR]
        LDR     a1, =2_1111111011111    ; GPIO mode, all pins inputs (except 5)
        STR     a1, [a4, #KBDMR]        ; (AC'97 nReset output)
        BL      USB_Init
        BL      NVMemory_Init
 ]

        BL      Video_init

 [ SDB
        BL      SIB_Init
 ]

        EXIT

; Initialise and relocate the entry table.
SetUpOSEntries  ROUT
        STR     a1, OSheader
        LDR     a2, [a1, #OSHdr_NumEntries]
        CMP     a2, #HighestOSEntry+1
        MOVHI   a2, #HighestOSEntry+1

        ADR     a3, OSentries
        LDR     a4, [a1, #OSHdr_Entries]
        ADD     a4, a4, a1

05      SUBS    a2, a2, #1
        LDR     ip, [a4, a2, LSL #2]
        ADD     ip, ip, a4
        STR     ip, [a3, a2, LSL #2]
        BNE     %BT05

        MOV     pc, lr


HAL_Null
        MOV     pc, lr

HAL_ControllerAddress
        MOV     a1, #0
        MOV     pc, lr

HAL_HardwareInfo
        LDR     ip, =&FFFFFF00
        STR     ip, [a1]
        MOV     ip, #0
        STR     ip, [a2]
        LDR     ip, =&00FFFF00
        STR     ip, [a3]
        MOV     pc, lr

HAL_SuperIOInfo
        MOV     ip, #0
        STR     ip, [a1]
        STR     ip, [a2]
        MOV     pc, lr

        LTORG

        END
