        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>

        GET     Hdr:Proc
        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS
        GET     hdr.Hardware



; This version assumes a RISC OS image starting 64K after us.

        AREA    |!!!ROMStart|, CODE, READONLY, PIC

        ENTRY

HAL_Base

vectors B       start           ; Reset
        B       .               ; Undefined instruction
        B       .               ; SWI
        B       .               ; Prefetch abort
        B       .               ; Data abort
        B       .               ; (Address exception)
        B       .               ; IRQ
        B       .               ; FIQ

        DCD     64*1024         ; offset to RISC OS image

        ASSERT  . - HAL_Base < 0x60
        %       0x60 - (. - HAL_Base)
ROMsize
        DCD     0                       ; patched in by build system

HALdescriptor   DATA
        DCD     0
        DCD     HAL_Base - HALdescriptor
        DCD     64*1024
        DCD     HAL_EntryTable - HALdescriptor
        DCD     HAL_Entries
        DCD     HAL_WsSize

        MACRO
        HALEntry $name
        ASSERT  (. - HAL_EntryTable) / 4 = EntryNo_$name
        DCD     $name - HAL_EntryTable
        MEND

        MACRO
        NullEntry
        DCD     HAL_Null - HAL_EntryTable
        MEND

        ;IMPORT   Video_init
        IMPORT   Matrix_Init

        IMPORT   HAL_IRQEnable
        IMPORT   HAL_IRQDisable
        IMPORT   HAL_IRQClear
        IMPORT   HAL_IRQSource

        IMPORT   HAL_Timers
        IMPORT   HAL_TimerDevice
        IMPORT   HAL_TimerGranularity
        IMPORT   HAL_TimerMaxPeriod
        IMPORT   HAL_TimerSetPeriod
        IMPORT   HAL_TimerPeriod
        IMPORT   HAL_TimerReadCountdown

        IMPORT   HAL_CounterRate
        IMPORT   HAL_CounterPeriod
        IMPORT   HAL_CounterRead
        IMPORT   HAL_CounterDelay

        IMPORT   HAL_IICBuses

        IMPORT   HAL_NVMemoryType

        ;IMPORT   HAL_VideoFlybackDevice
        ;IMPORT   HAL_Video_SetMode
        ;IMPORT   HAL_Video_WritePaletteEntry
        ;IMPORT   HAL_Video_WritePaletteEntries
        ;IMPORT   HAL_Video_ReadPaletteEntry
        ;IMPORT   HAL_Video_SetInterlace
        ;IMPORT   HAL_Video_SetBlank
        ;IMPORT   HAL_Video_SetPowerSave
        ;IMPORT   HAL_Video_UpdatePointer
        ;IMPORT   HAL_Video_SetDAG
        ;IMPORT   HAL_Video_VetMode

        IMPORT   HAL_MatrixColumns
        IMPORT   HAL_MatrixScan

        IMPORT   HAL_MachineID

HAL_EntryTable  DATA
        HALEntry HAL_Init

        HALEntry HAL_IRQEnable
        HALEntry HAL_IRQDisable
        HALEntry HAL_IRQClear
        HALEntry HAL_IRQSource

        HALEntry HAL_Timers
        HALEntry HAL_TimerDevice
        HALEntry HAL_TimerGranularity
        HALEntry HAL_TimerMaxPeriod
        HALEntry HAL_TimerSetPeriod
        HALEntry HAL_TimerPeriod
        HALEntry HAL_TimerReadCountdown

        HALEntry HAL_CounterRate
        HALEntry HAL_CounterPeriod
        HALEntry HAL_CounterRead
        HALEntry HAL_CounterDelay

        HALEntry HAL_NVMemoryType
        NullEntry
        NullEntry
        NullEntry
        NullEntry
        NullEntry
        NullEntry

        HALEntry HAL_IICBuses
        NullEntry
        NullEntry
        NullEntry

        NullEntry ;HALEntry HAL_VideoFlybackDevice
        NullEntry ;HALEntry HAL_Video_SetMode
        NullEntry ;HALEntry HAL_Video_WritePaletteEntry
        NullEntry ;HALEntry HAL_Video_WritePaletteEntries
        NullEntry ;HALEntry HAL_Video_ReadPaletteEntry
        NullEntry ;HALEntry HAL_Video_SetInterlace
        NullEntry ;HALEntry HAL_Video_SetBlank
        NullEntry ;HALEntry HAL_Video_SetPowerSave
        NullEntry ;HALEntry HAL_Video_UpdatePointer
        NullEntry ;HALEntry HAL_Video_SetDAG
        NullEntry ;HALEntry HAL_Video_VetMode

        HALEntry HAL_MatrixColumns
        HALEntry HAL_MatrixScan

        HALEntry HAL_MachineID

        HALEntry HAL_ControllerAddress
        HALEntry HAL_HardwareInfo
        HALEntry HAL_SuperIOInfo


HAL_Entries     * (.-HAL_EntryTable)/4

; v8 is used as pointer to RISC OS entry table throughout pre-MMU stage.
        MACRO
        CallOSM $entry, $reg
        LDR     ip, [v8, #$entry*4]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND

        MACRO
        CallOS  $entry
        ASSERT  $entry <= HighestOSEntry
        MOV     lr, pc
        LDR     pc, OSentries + 4*$entry
        MEND


start
        DIAG    off

        ADRL    v1, HAL_Base + 64*1024          ; v1 -> RISC OS image

        LDR     v8, [v1, #OSHdr_Entries]
        ADD     v8, v8, v1                      ; v8 -> RISC OS entry table

        MOV     a1, #0
        CallOSM OS_InitARM

        LDR     sp, =SRAM_BASE+SRAM_SIZE

        LDR     a4, =SYSTEM_BASE
        LDR     a1, [a4, #SYS_CONFIG_SDRAM]
        BIC     a1, a1, #PICEN
        STR     a1, [a4, #SYS_CONFIG_SDRAM]     ; power down Piccolo

        BL      sort_out_the_blasted_clocks

        BUZ     off

        BL      initialise_rom

        CMP     pc, #SDRAM_BASE                 ; don't init RAM if we're in it!
        BLLO    initialise_ram

        BL      initialise_timers

        MOV     v6, #SDRAM_BASE

        BL      initialise_serial

        BL      initialise_mlcd

        LDR     a3, =SYSTEM_BASE

        LDR     a1, [a3, #SYS_STATUS]
        TST     a1, #1 :SHL: 10
        MOVNE   v3, #OSStartFlag_POR
        MOVEQ   v3, #0
        STR     a1, [a3, #SYS_STAT_CLR]

        MOV     a1, #4:SHL:8
        LDR     a2, =SDRAM_BASE
        ADD     a3, a2, #28*1024*1024           ; 32 M fitted, OS in top 4 (hack hack hack)
        LDR     a4, =&FFFFFFFF
        MOV     ip, #0
        STR     ip, [sp, #-4]!
        CallOSM OS_AddRAM
        STR     a1, [sp]
        ADD     sp, sp, #4

        MOV     a4, a1
        MOV     a1, v3
        MOV     a2, v1
        ADR     a3, HALdescriptor
        CallOSM OS_Start


power_on_reset
        =       "Power-on reset", 10, 0
normal_reset
        =       "Normal reset", 10, 0
hello_string
        =       "Hello world!", 10, 0
syscon_string
        =       "SYS_CONFIG_CURRENT = ", 0
sdramcon_string
        =       10, "SYS_CONFIG_SDRAM = ", 0
        ALIGN



sort_out_the_blasted_clocks
        STMFD   sp!, {lr}

        BL      peripheral_clocks_off

        LDR     a4, =SYSTEM_BASE
        LDR     a1, =2_10:SHL:25                ; state change, no stall
        STR     a1, [a4, #SYS_CONFIG_NEXT]

                    ;  OSCEN   PLLEN
                    ;  |OSCMUX |PLLMUX
                    ;  ||PLLMUL||  BCLK_DIV
      [ PLL = 129
        LDR     a1, =2_10100011100010111        ; 3M6 osc, PLL on (129M), BCLK=PLL/4, SDRAM=CPU, not Fastbus
      |
        LDR     a1, =2_10101000100010111        ; 3M6 osc, PLL on (147M), BCLK=PLL/4, SDRAM=CPU, not Fastbus
      ]
                   ;   65432109876543210
        STR     a1, [a4, #SYS_CONFIG_RUN]
        STR     a1, [a4, #SYS_CONFIG_COMM]      ; initiate change

        LDR     a1, [a4, #SYS_CLOCK_SELECT]
      [ PLL = 129
        ORR     a1, a1, #3                      ; MIRCLK = SYNCLK18M, CLK18M=BLCK/2
      |
        ORR     a1, a1, #1                      ; CLK18M=BLCK/2
      ]
        STR     a1, [a4, #SYS_CLOCK_SELECT]

        LDR     a1, [a4, #SYS_CLOCK_ENABLE]
        BIC     a1, a1, #ALTD_EN
        STR     a1, [a4, #SYS_CLOCK_ENABLE]

      [ PLL = 129
        MOV     a1, #SYN_EN
      |
        MOV     a1, #B18M_EN
      ]
        BL      enable_clocks
        MOV     a1, #BUART_EN
        BL      enable_clocks
        MOV     a1, #C3M6_EN
        BL      enable_clocks
        MOV     a1, #UARTM_EN
        BL      enable_clocks
        MOV     a1, #SIBADC_EN
        BL      enable_clocks
        LDMFD   sp!, {pc}


; Turn off clocks at the bottom of the tree first
peripheral_clocks_off
        STMFD   sp!, {v1, lr}
        MOV     v1, #SIBADC_EN + UARTM_EN + MIRM_EN
        BL      disable_clocks
        MOV     v1, #C18MU_EN
        BL      disable_clocks
        LDR     v1, =BUART_EN + B18M_EN + C3M6_EN + FIR_EN + CLCLK_EN
        BL      disable_clocks
        LDMFD   sp!, {v1, pc}

; void enable_clocks(int bits)
enable_clocks
        MOV     a2, a1
        B       modify_clocks

; void disable_clocks(int bits)
disable_clocks
        MOV     a2, #0
        B       modify_clocks

; void modify_clocks(int bits, int values)
modify_clocks
        LDR     a4, =SYSTEM_BASE
        LDR     a3, [a4, #SYS_CLOCK_ENABLE]
        BIC     a3, a3, a1
        ORR     a3, a3, a2
        STR     a3, [a4, #SYS_CLOCK_ENABLE]
01      LDR     a3, [a4, #SYS_CLOCK_ESYNC]
        AND     a3, a3, a1
        TEQ     a3, a2
        BNE     %BT01
        MOV     pc, lr




initialise_mlcd
        LDR     a4, =GPIO_BASE
        MOV     a1, #2_00011110
        STRB    a1, [a4, #PEDDR]                ; set up outputs on port E

        LDR     a4, =SMIREG_BASE                ; configure static memory for L1121 chip
        LDR     a1, [a4, #IOCFG2]
        LDR     a2, =2_00100000000001           ; 32-bit, slow, blah blah, blah
        MOV     a1, a1, LSR #16
        ORR     a1, a2, a1, LSL #16
        STR     a1, [a4, #IOCFG2]

        MOV     a4, #L1121_BASE                 ; set L1121 DAC
        MOV     a1, #0
        STR     a1, [a4, #DACCR]
        MOV     a1, #MLCD_Contrast
        STR     a1, [a4, #DACDR]

        LDR     a4, =DC_BASE                    ; enable DC-DC converter
        MOV     a1, #&0EE
        STR     a1, [a4, #PMPCON]

        LDR     a4, =MLCD_BASE
        MOV     a1, #ScreenBase :AND: &01FFFFFF
        STR     a1, [a4, #MLCDBASE]
        MOV     a1, #&F0                        ; Black on white (?)
        STR     a1, [a4, #MPALLSW]

        MOV     a1, #1
        STR     a1, [a4, #MLCDTIMING0]
        LDR     a1, =(0:SHL:24)+(0:SHL:16)+(MLCD_Width/4-1)
        STR     a1, [a4, #MLCDTIMING1]

        LDR     a3, =(1:SHL:25)+(PIXPRE:SHL:19)+((MLCD_Width/16-1):SHL:13)+((MLCD_Height-1):SHL:4)+MLCD_SRAM + 1
        STR     a3, [a4, #MLCDCON]

        LDR     a4, =GPIO_BASE
        MOV     a1, #2_00001000
        STRB    a1, [a4, #PEDR]                 ; turn on LCD
        MOV     pc, lr

; The timers are clocked by UARTCLK (3.6864MHz)
; We initially require a 100Hz timer, which means we program 36863 as the start value.
initialise_timers
        LDR     a4, =TIMER_BASE
        LDR     a1, [a4, #TIMER1CONTROL]
        BIC     a1, a1, #2_11000000000          ; use UARTCLK/1, STBUZ driven manually
        BIC     a1, a1, #2_00000001100
        ORR     a1, a1, #2_00011000000          ; periodic-timer mode, enabled
        STR     a1, [a4, #TIMER1CONTROL]
        LDR     a1, =36864-1
        STR     a1, [a4, #TIMER1LOAD]
        STR     a1, [a4, #TIMER1CLEAR]          ; clear any pending interrupt

        LDR     a1, [a4, #TIMER2CONTROL]        ; disable timer 2
        BIC     a1, a1, #2_10000000
        STR     a1, [a4, #TIMER2CONTROL]
        STR     a1, [a4, #TIMER2CLEAR]          ; clear any pending interrupt
        MOV     pc, lr



initialise_ram
        STMFD   sp!, {v1,lr}
        MOV     a1, #100
        BL      wait

        LDR     a4, =SDRAMREG_BASE
        ; Normal power, no auto-refresh, no auto-precharge, DMA and main write
        ; buffers disabled, both slots enabled, 4 banks, no tristate, clocks always on
        ; (performs the precharge)
        LDR     v1, =2_0000000000000000011001110 :OR: (CAS :SHL: 20)
        STR     v1, [a4, #SDRAMCFG]

        MOV     a1, #6
        STR     a1, [a4, #SDRAMRFSH]    ; fast refresh period

        ORR     v1, v1, #1:SHL:23       ; enable auto-refresh
        STR     v1, [a4, #SDRAMCFG]

        MOV     a1, #1
        BL      wait                    ; wait for 2 refreshes

        ; Program both SDRAMs for CAS, sequential burst of 8
        LDR     a4, =SDRAMMODE_BASE + (((CAS:SHL:4)+3):SHL:11)
        LDR     a1, [a4]

        ADD     a4, a4, #1:SHL:24
        LDR     a1, [a4]

        BUZ     off

        ASSERT  PLL = 129 :LOR: PLL = 147
        LDR     a4, =SDRAMREG_BASE
      [ PLL = 129
        MOV     a1, #504
      |
        MOV     a1, #576
      ]
        STR     a1, [a4, #SDRAMRFSH]    ; 15.625us refresh period

        MOV     a1, #&77
        STR     a1, [a4, #SDRAMWBFT]    ; 128 cycle write-buffer timeouts

        ; Enable DMA and main write buffers
        ORR     v1, v1, #2_11:SHL:16
        STR     v1, [a4, #SDRAMCFG]

        LDMFD   sp!, {v1,pc}

; Timings for AMD AM29LV160DB-90EC flash (90ns access from CS, 35ns from IOE)
; Contention limit: 30ns
 [ PLL = 129
; cycle time = 31.00ns - 3 cycles from CS (93ns), 2 cycles from IOE (62-7=55ns), 1.5 cycle recovery
IOCS0 * 2_00010110110101
 |
; cycle time = 27.26ns - 4 cycles from CS (109ns), 2 cycles from IOE (54.5-7=47.5ns), 1.5 cycle recovery
;IOCS0 * 2_00010110110011
IOCS0 * 2_00010100100111
 ]

initialise_rom
        LDR     R3, =SMIREG_BASE                ; set up cycle times for ROM bank 0
        LDR     R0, [R3, #IOCFG1]
        MOV     R0, R0, LSR #16
        LDR     R1, =IOCS0
        ORR     R0, R1, R0, LSL #16
        STR     R0, [R3, #IOCFG1]

        LDR     R3, =SYSTEM_BASE
        STR     R0, [R3, #SYS_RESET_REMAP]      ; get rid of the boot ROM
        MOV     PC, LR


; wait n microseconds (yuck)
wait
        MOV     R1, #19
        MUL     R0, R1, R0
01      SUBS    R0, R0, #1              ; 4 cycles min per loop, max 75MHz, so at least 53ns
        BNE     %BT01                   ; so 19 loops for one microsecond
        MOV     pc, lr

initialise_serial
        LDR     R3, =UART1_BASE
        MOV     R0, #&17        ; 9600 baud
        STRB    R0, [R3, #L_UBRLCR]
        MOV     R0, #0
        STRB    R0, [R3, #M_UBRLCR]
        MOV     R0, #2_0010000
        STRB    R0, [R3, #H_UBRLCR]
        MOV     R0, #2_00000001
        STRB    R0, [R3, #UARTCON]
        MOV     PC, LR


;--------------------------------------------------------------------------------------


HAL_Init
        Entry

        BL      SetUpOSEntries

        MOV     a1, #0
        MOV     a2, #PERIPHERAL_BASE
        MOV     a3, #PERIPHERAL_SIZE
        CallOS  OS_MapInIO

        MOV     a1, #0
        MOV     a2, #APB_BASE
        MOV     a3, #APB_SIZE
        CallOS  OS_MapInIO

        ADD     ip, a1, #TIMER_BASE - APB_BASE
        STR     ip, TIMER_BASE_Address
        ADD     ip, a1, #INT_BASE - APB_BASE
        STR     ip, INT_BASE_Address
        ADD     ip, a1, #KEYBOARD_BASE - APB_BASE
        STR     ip, KEYBOARD_BASE_Address
        ADD     ip, a1, #GPIO_BASE - APB_BASE
        STR     ip, GPIO_BASE_Address

        BL      Matrix_Init

        EXIT

; Initialise and relocate the entry table.
SetUpOSEntries  ROUT
        STR     a1, OSheader
        LDR     a2, [a1, #OSHdr_NumEntries]
        CMP     a2, #HighestOSEntry+1
        MOVHI   a2, #HighestOSEntry+1

        ADR     a3, OSentries
        LDR     a4, [a1, #OSHdr_Entries]
        ADD     a4, a4, a1

05      SUBS    a2, a2, #1
        LDR     ip, [a4, a2, LSL #2]
        ADD     ip, ip, a4
        STR     ip, [a3, a2, LSL #2]
        BNE     %BT05

        MOV     pc, lr


HAL_Null
        MOV     pc, lr

HAL_ControllerAddress
        MOV     a1, #0
        MOV     pc, lr

HAL_HardwareInfo
        MOV     ip, #0
        STR     ip, [a1]
        STR     ip, [a2]
        STR     ip, [a3]
        MOV     pc, lr

HAL_SuperIOInfo
        MOV     ip, #0
        STR     ip, [a1]
        STR     ip, [a2]
        MOV     pc, lr

        LTORG

        END
