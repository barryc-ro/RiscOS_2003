        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>

        GET     Hdr:Proc
        GET     Hdr:HALEntries
        GET     Hdr:OSEntries

        GET     hdr.StaticWS
        GET     hdr.Hardware

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  HAL_NVMemoryType

 [ SDB
HAL_NVMemoryType
        MOV     a1, #0
        MOV     pc, lr
 |
        EXPORT  NVMemory_Init

NVMemory_Init
        LDR     a4, FLASHNVMEM_Address
        ADR     a3, NVMemSoftCopy
        MOV     a2, #4096
10      LDR     a1, [a4], #4
        STR     a1, [a3], #4
        SUBS    a2, a2, #4
        BNE     %BT10

        ADR     a4, ReprogramFlash
        ADR     a3, ReprogramFlashEnd
        ADR     a2, ProgramRoutine
10      LDR     a1, [a4], #4
        STR     a1, [a2], #4
        TEQ     a4, a3
        BNE     %BT10

        MOV     pc, lr

HAL_NVMemoryType
        MOV     a1, #NVMemoryFlag_HAL
        ORR     a1, a1, #NVMemoryFlag_ProtectAtEnd+NVMemoryFlag_Deprotectable+NVMemoryFlag_LowRead+NVMemoryFlag_LowWrite
        MOV     pc, lr

        EXPORT  HAL_NVMemorySize
        EXPORT  HAL_NVMemoryProtectedSize
        EXPORT  HAL_NVMemoryProtection
        EXPORT  HAL_NVMemoryRead
        EXPORT  HAL_NVMemoryWrite

HAL_NVMemorySize
        MOV     a1, #4096
        MOV     pc, lr

HAL_NVMemoryProtectedSize
        MOV     a1, #1024
        MOV     pc, lr

HAL_NVMemoryProtection
        MOV     pc, lr

HAL_NVMemoryRead
        ADR     a4, NVMemSoftCopy
        ADD     a4, a4, a1
        MOV     a1, a3
10      SUBS    a3, a3, #1
        LDRCSB  ip, [a4], #1
        STRCSB  ip, [a2], #1
        BCS     %BT10
        MOV     pc, lr

HAL_NVMemoryWrite
        Push    "v1,lr"
        ADR     a4, NVMemSoftCopy
        ADD     a4, a4, a1
        MOV     v1, a3
10      SUBS    a3, a3, #1
        LDRCSB  ip, [a2], #1
        STRCSB  ip, [a4], #1
        BCS     %BT10
        ; RISC OS hacky hacky. Only write if including checksum byte.
        SUBS    lr, a1, #&3F            ; LS if start-&3F <= 0, ie start <= &3F
        ADDLS   a2, a1, v1              ; a2 = end (exclusive). want end >= &40 ie &40<= end
        RSBLSS  a2, a2, #&40            ; LS if &40-end <= 0, ie end >= &40.
        MOVHI   a1, v1
        Pull    "v1,pc",HI
        MOV     lr, pc
        ADR     pc, ProgramRoutine
        TEQ     a1, #0
        MOVEQ   a1, v1
        MOVNE   a1, #0
        Pull    "v1,pc"

ReprogramFlash
        Push    "v1-v3,lr"
        MRS     v1, CPSR
        ORR     ip, v1, #&C0                    ; IRQs and FIQs off (wahey!)
        MSR     CPSR_c, ip
        LDR     v2, FLASHNVMEM_Address
        MOV     a4, v2
        ADR     a3, NVMemSoftCopy
        ADD     v3, a3, #4096

        MOV     a1, #&60
        ORR     a1, a1, a1, LSL #16             ; Block Unlock
        STR     a1, [v2]
        MOV     a1, #&D0
        ORR     a1, a1, a1, LSL #16             ; Confirm
        STR     a1, [v2]
05      LDR     a2, [v2]
        TST     a2, #&80
        TSTNE   a2, #&80 :SHL: 16
        BEQ     %BT05


        MOV     a1, #&20
        ORR     a1, a1, a1, LSL #16             ; Block Erase
        STR     a1, [v2]
        MOV     a1, #&D0
        ORR     a1, a1, a1, LSL #16             ; Confirm
        STR     a1, [v2]
10      LDR     a2, [v2]
        TST     a2, #&80
        TSTNE   a2, #&80 :SHL: 16
        BEQ     %BT10

        TST     a2, #&20
        TSTEQ   a2, #&20 :SHL: 16
        MOVNE   a1, #-1
        BNE     %FT90                           ; error

 [ MSI                                          ; No buffer so have to write single words
15      MOV     a1, #&40                        ; Program
        ORR     a1, a1, a1, LSL #16
        STR     a1, [v2]

        LDR     a1, [a3], #4
        STR     a1, [a4], #4                    ; write data word

 |

15      MOV     a1, #&E8                        ; Write to Buffer
        ORR     a1, a1, a1, LSL #16
20      STR     a1, [v2]
        LDR     a2, [v2]                        ; Check XSR.7 set (it'd better be)
        TST     a2, #&80
        TSTNE   a2, #&80 :SHL: 16
        BNE     %FT25
        ; failed
        MOV     a1, #&70
        ORR     a1, a1, a1, LSL #16             ; Read Status Register
        STR     a1, [v2]
        MOV     a1, #-1                         ; error indication
        MOV     a3, v3
        B       %FT40

25      MOV     ip, #15                         ; Number of words (-1)
        ORR     a1, ip, ip, LSL #16
        STR     a1, [v2]
30      LDR     a1, [a3], #4
        STR     a1, [a4], #4
        SUBS    ip, ip, #1
        BCS     %BT30

        MOV     a1, #&D0
        ORR     a1, a1, a1, LSL #16             ; Confirm
        STR     a1, [v2]
 ] ; MSI

40      LDR     a2, [v2]                        ; wait until finished
        TST     a2, #&80
        TSTNE   a2, #&80 :SHL: 16
        BEQ     %BT40

        TST     a2, #&1A                        ; check for errors
        TSTEQ   a2, #&1A :SHL: 16
        MOVNE   a1, #-1
        BNE     %FT90

        TEQ     a3, v3
        BNE     %BT15

        MOV     a1, #0                          ; successful

90
        MOV     a2, #&50
        ORR     a2, a2, a2, LSL #16
        STR     a2, [v2]                        ; Clear Status Register
        MOV     a2, #&FF
        ORR     a2, a2, a2, LSL #16
        STR     a2, [v2]                        ; Read Array
        MSR     CPSR_c, v1
        Pull    "v1-v3, pc"


ReprogramFlashEnd
 ]
        END
