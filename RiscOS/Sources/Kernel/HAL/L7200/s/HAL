TIMER_BASE      * &90003000

TIMER1LOAD      * &000 ; R/W
TIMER1VALUE     * &004 ; R
TIMER1CONTROL   * &008 ; R/W
TIMER1CLEAR     * &00C ;   W
TIMER2LOAD      * &020 ; R/W
TIMER2VALUE     * &024 ; R
TIMER2CONTROL   * &028 ; R/W
TIMER2CLEAR     * &02C ;   W

DC_BASE         * &90006000
PMPCON          * &000

MLCD_BASE       * &80048000

MLCDCON         * &000
MPALLSW         * &004
MPALMSW         * &008
MLCDBASE        * &00C
MLCDCAR         * &010
MLCDID          * &014
MLCDTIMING0     * &018
MLCDTIMING1     * &01C

GPIO_BASE       * &90005000
PEDR            * &080
PEDDR           * &084
PESBSR          * &088
PEEENR          * &08C
PEESNR          * &090
PEECLR          * &094
PEIMR           * &098
PEINT           * &09C

SMIREG_BASE     * &90007000
IOCFG1          * &000
IOCFG2          * &004
IOCFG3          * &008
IOCFG4          * &00C
IOCFG5          * &010
IOSR            * &014

UART1_BASE      * &80044000
UARTDR          * &000
RXSTAT          * &004
H_UBRLCR        * &008
M_UBRLCR        * &00C
L_UBRLCR        * &010
UARTCON         * &014
UARTFLG         * &018
UARTINTSTAT     * &01C
UARTINTMASK     * &020

SYSTEM_BASE     * &80050000

SYS_CONFIG_CURRENT * &000
SYS_CONFIG_NEXT  * &004
SYS_CONFIG_RUN   * &00C
SYS_CONFIG_COMM  * &010
SYS_CONFIG_SDRAM * &014
PICEN   * &10
SYS_CLOCK_ENABLE * &030
SYS_CLOCK_ESYNC  * &034
SYS_CLOCK_SELECT * &038
SYS_STATUS       * &040
SYS_STAT_CLR     * &044
SYS_RESET_REMAP  * &048

SYN_EN          * 1
B18M_EN         * 2
C3M6_EN         * 4
BUART_EN        * 8
C18MU_EN        * 16
FIR_EN          * 32
MIRM_EN         * 64
UARTM_EN        * 128
SIBADC_EN       * 256
ALTD_EN         * 512
CLCLK_EN        * 1024

SDRAMREG_BASE   * &D0000000
SDRAMCFG        * &000
SDRAMRFSH       * &004
SDRAMWBFT       * &008

SDRAMMODE_BASE  * &E0000000

L1121_BASE      * &14000000
DACCR           * &040
DACDR           * &044

MLCD_Width   * 320
MLCD_Height  * 240
MLCD_Refresh * 75
MLCD_Contrast * &70

VFP          * 240-MLCD_Height

SRAM_BASE       * &60000000
SRAM_SIZE       * 5120
SDRAM_BASE      * &F0000000
SDRAM2_BASE     * &F1000000

ScreenBase * SDRAM2_BASE

 [ ScreenBase >= SRAM_BASE :LAND: ScreenBase < SRAM_BASE +16384
MLCD_SRAM * 2
 |
MLCD_SRAM * 0
 ]

PLL     * 147
CAS     * 2

 [ PLL = 129
BCLK    * 32256000
 |
BCLK    * 36864000
 ]

PIXPRE  * (BCLK*4)/(MLCD_Refresh*((MLCD_Width*MLCD_Height)+MLCD_Height/2)) - 1

        MACRO
        BUZ     $on
        LDR     R3, =TIMER_BASE
        LDR     R0, [R3, #TIMER1CONTROL]
       [ "$on" = "toggle"
        EOR     R0, R0, #&100
       |
        [ "$on" = "on"
        BIC     R0, R0, #&100
        |
        ORR     R0, R0, #&100
        ]
       ]
        STR     R0, [R3, #TIMER1CONTROL]
        MEND

        MACRO
        DIAG    $on
        MOV     R3, #&1A000000
        [ "$on" = "on"
        MOV     R0, #0
        |
        MOV     R0, #2
        ]
        STRB    R0, [R3]
        MEND

RISCOS_InitARM  * 0
RISCOS_AddRAM   * 4
RISCOS_Start    * 8

                ^       0,sb
IntBase         #       4
StaticWorkspaceSize *   :INDEX:@


        ^       0, R9
curx    #       4
cury    #       4
count   #       4

 [ PLL = 129
; PLL = 129.024MHz
; BCLK = 32.256MHz
; CPU = 64.512MHz
; SDRAM FCLK = 64.512MHz
; SDRAM BCLK = 32.256MHz
; SYNCLK18M = 18.432MHz (PLL/7)
 |
; PLL = 147.456MHz
; BCLK = 36.684MHz
; CPU = 73.728MHz
; SDRAM FCLK = 73.728MHz
; SDRAM BCLK = 36.684MHz
 ]

; This version assumes a RISC OS image starting 64K after us.

        AREA    Fred, CODE, READONLY, PIC

HAL_Base

vectors B       start           ; Reset
        B       .               ; Undefined instruction
        B       .               ; SWI
        B       .               ; Prefetch abort
        B       .               ; Data abort
        B       .               ; (Address exception)
        B       .               ; IRQ
        B       .               ; FIQ

        DCD     64*1024         ; offset to RISC OS image

HALdescriptor
        DCD     0
        DCD     HAL_Base - HALdescriptor
        DCD     64*1024
        DCD     HAL_EntryTable - HALdescriptor
        DCD     HAL_Entries
        DCD     StaticWorkspaceSize

HAL_EntryTable
        DCD     HAL_WriteC - HAL_EntryTable
HAL_Entries     * (.-HAL_EntryTable)/4

; R11 is used as pointer to RISC OS entry table throughout
        MACRO
        CallOS  $entry
        LDR     ip, [v8, #$entry]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND

start
        DIAG    off

        ADR     R4, HAL_Base                    ; R4 -> HAL base
        LDR     R0, [R4, #&20]
        ADD     R5, R4, R0                      ; R5 -> RISC OS image

        LDR     R11, [R5, #16]
        ADD     R11, R11, R5                    ; R11 -> RISC OS entry table

        MOV     R0, #0
        CallOS  RISCOS_InitARM

        LDR     R13, =SRAM_BASE+SRAM_SIZE

        LDR     R3, =SYSTEM_BASE
        LDR     R0, [R3, #SYS_CONFIG_SDRAM]
        BIC     R0, R0, #PICEN
        STR     R0, [R3, #SYS_CONFIG_SDRAM]     ; power down Piccolo

        BL      sort_out_the_blasted_clocks

        BUZ     off

        BL      initialise_rom

        BL      initialise_ram

        BL      initialise_timers

        MOV     R9, #SDRAM_BASE

        BL      initialise_serial

        BL      initialise_mlcd

        MOV     R0, #4:SHL:8
        LDR     R1, =SDRAM_BASE
        ADD     R2, R1, #16*1024*1024
        LDR     R3, =&FFFFFFFF
        MOV     R12, #0
        STR     R12, [R13, #-4]!
        CallOS  RISCOS_AddRAM
        STR     R0, [R13]
        MOV     R0, #4:SHL:8
        LDR     R1, =SDRAM2_BASE
        ADD     R2, R1, #16*1024*1024
        LDR     R3, =&FFFFFFFF
        CallOS  RISCOS_AddRAM
        ADD     R13, R13, #4
        MOV     R3, R0
        MOV     R0, #0
        MOV     R1, R5
        ADR     R2, HALdescriptor
        CallOS  RISCOS_Start


power_on_reset
        =       "Power-on reset", 10, 0
normal_reset
        =       "Normal reset", 10, 0
hello_string
        =       "Hello world!", 10, 0
syscon_string
        =       "SYS_CONFIG_CURRENT = ", 0
sdramcon_string
        =       10, "SYS_CONFIG_SDRAM = ", 0
        ALIGN



sort_out_the_blasted_clocks
        STMFD   R13!, {LR}

        BL      peripheral_clocks_off

        LDR     R3, =SYSTEM_BASE
        LDR     R0, =2_10:SHL:25                ; state change, no stall
        STR     R0, [R3, #SYS_CONFIG_NEXT]

                    ;  OSCEN   PLLEN
                    ;  |OSCMUX |PLLMUX
                    ;  ||PLLMUL||  BCLK_DIV
      [ PLL = 129
        LDR     R0, =2_10100011100010111        ; 3M6 osc, PLL on (129M), BCLK=PLL/4, SDRAM=CPU, not Fastbus
      |
        LDR     R0, =2_10101000100010111        ; 3M6 osc, PLL on (147M), BCLK=PLL/4, SDRAM=CPU, not Fastbus
      ]
                   ;   65432109876543210
        STR     R0, [R3, #SYS_CONFIG_RUN]
        STR     R0, [R3, #SYS_CONFIG_COMM]      ; initiate change

        LDR     R0, [R3, #SYS_CLOCK_SELECT]
      [ PLL = 129
        ORR     R0, R0, #3                      ; MIRCLK = SYNCLK18M, CLK18M=BLCK/2
      |
        ORR     R0, R0, #1                      ; CLK18M=BLCK/2
      ]
        STR     R0, [R3, #SYS_CLOCK_SELECT]

        LDR     R0, [R3, #SYS_CLOCK_ENABLE]
        BIC     R0, R0, #ALTD_EN
        STR     R0, [R3, #SYS_CLOCK_ENABLE]

      [ PLL = 129
        MOV     R0, #SYN_EN
      |
        MOV     R0, #B18M_EN
      ]
        BL      enable_clocks
        MOV     R0, #BUART_EN
        BL      enable_clocks
        MOV     R0, #C3M6_EN
        BL      enable_clocks
        MOV     R0, #UARTM_EN
        BL      enable_clocks
        MOV     R0, #SIBADC_EN
        BL      enable_clocks
        LDMFD   R13!, {PC}


; Turn off clocks at the bottom of the tree first
peripheral_clocks_off
        STMFD   R13!, {R4, LR}
        MOV     R4, #SIBADC_EN + UARTM_EN + MIRM_EN
        BL      disable_clocks
        MOV     R4, #C18MU_EN
        BL      disable_clocks
        LDR     R4, =BUART_EN + B18M_EN + C3M6_EN + FIR_EN + CLCLK_EN
        BL      disable_clocks
        LDMFD   R13!, {R4, PC}

; void enable_clocks(int bits)
enable_clocks
        MOV     R1, R0
        B       modify_clocks

; void disable_clocks(int bits)
disable_clocks
        MOV     R1, #0
        B       modify_clocks

; void modify_clocks(int bits, int values)
modify_clocks
        LDR     R3, =SYSTEM_BASE
        LDR     R2, [R3, #SYS_CLOCK_ENABLE]
        BIC     R2, R2, R0
        ORR     R2, R2, R1
        STR     R2, [R3, #SYS_CLOCK_ENABLE]
01      LDR     R2, [R3, #SYS_CLOCK_ESYNC]
        AND     R2, R2, R0
        TEQ     R2, R1
        BNE     %BT01
        MOV     PC, LR




initialise_mlcd
        LDR     R3, =GPIO_BASE
        MOV     R0, #2_00011110
        STRB    R0, [R3, #PEDDR]                ; set up outputs on port E

        LDR     R3, =SMIREG_BASE                ; configure static memory for L1121 chip
        LDR     R0, [R3, #IOCFG2]
        LDR     R1, =2_00100000000001           ; 32-bit, slow, blah blah, blah
        MOV     R0, R0, LSR #16
        ORR     R0, R1, R0, LSL #16
        STR     R0, [R3, #IOCFG2]

        MOV     R3, #L1121_BASE                 ; set L1121 DAC
        MOV     R0, #0
        STR     R0, [R3, #DACCR]
        MOV     R0, #MLCD_Contrast
        STR     R0, [R3, #DACDR]

        LDR     R3, =DC_BASE                    ; enable DC-DC converter
        MOV     R0, #&0EE
        STR     R0, [R3, #PMPCON]

        LDR     R3, =MLCD_BASE
        MOV     R0, #ScreenBase :AND: &01FFFFFF
        STR     R0, [R3, #MLCDBASE]
        MOV     R0, #&F0                        ; Black on white (?)
        STR     R0, [R3, #MPALLSW]

        MOV     R0, #1
        STR     R0, [R3, #MLCDTIMING0]
        LDR     R0, =(0:SHL:24)+(0:SHL:16)+(MLCD_Width/4-1)
        STR     R0, [R3, #MLCDTIMING1]

        LDR     R2, =(1:SHL:25)+(PIXPRE:SHL:19)+((MLCD_Width/16-1):SHL:13)+((MLCD_Height-1):SHL:4)+MLCD_SRAM + 1
        STR     R2, [R3, #MLCDCON]

        LDR     R3, =GPIO_BASE
        MOV     R0, #2_00001000
        STRB    R0, [R3, #PEDR]                 ; turn on LCD
        MOV     PC, LR

; The timers are clocked by UARTCLK (3.6864MHz)
; We initially require a 100Hz timer, which means we program 36863 as the start value.
initialise_timers
        LDR     R3, =TIMER_BASE
        LDR     R0, [R3, #TIMER1CONTROL]
        BIC     R0, R0, #2_11000000000          ; use UARTCLK/1, STBUZ driven manually
        BIC     R0, R0, #2_00000001100
        ORR     R0, R0, #2_00011000000          ; periodic-timer mode, enabled
        STR     R0, [R3, #TIMER1CONTROL]
        LDR     R0, =36864-1
        STR     R0, [R3, #TIMER1LOAD]
        STR     R0, [R3, #TIMER1CLEAR]          ; clear any pending interrupt

        LDR     R0, [R3, #TIMER2CONTROL]        ; disable timer 2
        BIC     R0, R0, #2_10000000
        STR     R0, [R3, #TIMER2CONTROL]
        STR     R0, [R3, #TIMER2CLEAR]          ; clear any pending interrupt
        MOV     PC, LR



initialise_ram
        STMFD   R13!, {R4,LR}
        MOV     R0, #100
        BL      wait

        LDR     R3, =SDRAMREG_BASE
        ; Normal power, no auto-refresh, no auto-precharge, DMA and main write
        ; buffers disabled, both slots enabled, 4 banks, no tristate, clocks always on
        ; (performs the precharge)
        LDR     R4, =2_0000000000000000011001110 :OR: (CAS :SHL: 20)
        STR     R4, [R3, #SDRAMCFG]

        MOV     R0, #6
        STR     R0, [R3, #SDRAMRFSH]    ; fast refresh period

        ORR     R4, R4, #1:SHL:23       ; enable auto-refresh
        STR     R4, [R3, #SDRAMCFG]

        MOV     R0, #1
        BL      wait                    ; wait for 2 refreshes

        ; Program both SDRAMs for CAS, sequential burst of 8
        LDR     R3, =SDRAMMODE_BASE + (((CAS:SHL:4)+3):SHL:11)
        LDR     R0, [R3]

        ADD     R3, R3, #1:SHL:24
        LDR     R0, [R3]

        BUZ     off

        ASSERT  PLL = 129 :LOR: PLL = 147
        LDR     R3, =SDRAMREG_BASE
      [ PLL = 129
        MOV     R0, #504
      |
        MOV     R0, #576
      ]
        STR     R0, [R3, #SDRAMRFSH]    ; 15.625us refresh period

        MOV     R0, #&77
        STR     R0, [R3, #SDRAMWBFT]    ; 128 cycle write-buffer timeouts

        ; Enable DMA and main write buffers
        ORR     R4, R4, #2_11:SHL:16
        STR     R4, [R3, #SDRAMCFG]

        LDMFD   R13!, {R4,PC}



; Timings for AMD AM29LV160DB-90EC flash (90ns access from CS, 35ns from IOE)
; Contention limit: 30ns
 [ PLL = 129
; cycle time = 31.00ns - 3 cycles from CS (93ns), 2 cycles from IOE (62-7=55ns), 1.5 cycle recovery
IOCS0 * 2_00010110110101
 |
; cycle time = 27.26ns - 4 cycles from CS (109ns), 2 cycles from IOE (54.5-7=47.5ns), 1.5 cycle recovery
;IOCS0 * 2_00010110110011
IOCS0 * 2_00010100100111
 ]
initialise_rom
        LDR     R3, =SMIREG_BASE                ; set up cycle times for ROM bank 0
        LDR     R0, [R3, #IOCFG1]
        MOV     R0, R0, LSR #16
        LDR     R1, =IOCS0
        ORR     R0, R1, R0, LSL #16
        STR     R0, [R3, #IOCFG1]

        LDR     R3, =SYSTEM_BASE
        STR     R0, [R3, #SYS_RESET_REMAP]      ; get rid of the boot ROM
        MOV     PC, LR



; wait n microseconds (yuck)
wait
        MOV     R1, #19
        MUL     R0, R1, R0
01      SUBS    R0, R0, #1              ; 4 cycles min per loop, max 75MHz, so at least 53ns
        BNE     %BT01                   ; so 19 loops for one microsecond
        MOV     pc, lr


maxcurx *       MLCD_Width/8
maxcury *       MLCD_Height/8

cls
        STMFD   R13!, {LR}
        LDR     R0, =ScreenBase
        MOV     R1, #0
        LDR     R2, = MLCD_Width/8 * MLCD_Height
        BL      memset
        MOV     R0, #0
        MOV     R1, #0
        BL      set_cursor
        LDMFD   R13!, {PC}

; memset
memset
        SUBS    R2, R2, #1
        MOVCC   PC, R14
        STRB    R1, [R0], #1
        B       memset


; set_cursor(int x, y)
set_cursor
        STR     R0, curx
        STR     R1, cury
        MOV     PC, R14

; print_hex(unsigned n)
print_hex
        STMFD   R13!, {R4,R5,LR}
        MOV     R5, #8
        MOV     R4, R0
01      MOV     R0, R4, LSR #28
        MOV     R4, R4, LSL #4
        CMP     R0, #9
        ADDLS   R0, R0, #'0'
        ADDHI   R0, R0, #'A'-10
        BL      plot_char
        SUBS    R5, R5, #1
        BNE     %BT01
        LDMFD   R13!, {R4,R5,PC}

; print(const char *s)
print
        STMFD   R13!, {R4,LR}
        MOV     R4, R0
01      LDRB    R0, [R4], #1
        TEQ     R0, #0
        LDMEQFD R13!, {R4,PC}
        BL      plot_char
        B       %BT01

; plot_char(char c)
HAL_WriteC
plot_char
        STMFD   R13!, {R4,R5,LR}
        LDR     R1, curx
        LDR     R2, cury
        CMP     R0, #32
        BLO     control_code
        CMP     R0, #127
        BHS     control_code
        ADR     R3, font_table - 8*32
        ADD     R0, R3, R0, LSL #3

        LDR     R3, =ScreenBase
        LDR     R4, =maxcurx*8
        MLA     R3, R4, R2, R3
        ADD     R3, R3, R1
        MOV     R5, #8
01      LDRB    R14, [R0], #1
        STRB    R14, [R3], R4, LSR #3
        SUBS    R5, R5, #1
        BNE     %BT01
        ADD     R1, R1, #1
        B       boundxy

control_code
        TEQ     R0, #10
        MOVEQ   R1, #0
        ADDEQ   R2, R2, #1
        TEQ     R0, #13
        MOVEQ   R1, #0
boundxy
        CMP     R1, #maxcurx
        MOVHS   R1, #0
        ADDHS   R2, R2, #1
        CMP     R2, #maxcury
        MOVHS   R2, #0
        STR     R1, curx
        STR     R2, cury
        LDMFD   R13!, {R4,R5,PC}

initialise_serial
        LDR     R3, =UART1_BASE
        MOV     R0, #&17        ; 9600 baud
        STRB    R0, [R3, #L_UBRLCR]
        MOV     R0, #0
        STRB    R0, [R3, #M_UBRLCR]
        MOV     R0, #2_0010000
        STRB    R0, [R3, #H_UBRLCR]
        MOV     R0, #2_00000001
        STRB    R0, [R3, #UARTCON]
        MOV     PC, LR

serial_send_byte
        LDR     R3, =UART1_BASE
01      LDRB    R1, [R3, #UARTFLG]
        TST     R1, #&20                ; wait for CTS and FIFO not full
        BNE     %BT01
        STRB    R0, [R3, #UARTDR]
        MOV     PC, LR

        LTORG

font_table
U_0020 = &00,&00,&00,&00,&00,&00,&00,&00 ;ISO  "space"
U_0021 = &18,&18,&18,&18,&18,&00,&18,&00 ;ISO  "exclamation mark"
U_0022 = &6C,&6C,&6C,&00,&00,&00,&00,&00 ;ISO  "quotation mark"
U_0023 = &36,&36,&7F,&36,&7F,&36,&36,&00 ;ISO  "number sign"
U_0024 = &0C,&3F,&68,&3E,&0B,&7E,&18,&00 ;ISO  "dollar sign"
U_0025 = &60,&66,&0C,&18,&30,&66,&06,&00 ;ISO  "percent sign"
U_0026 = &38,&6C,&6C,&38,&6D,&66,&3B,&00 ;ISO  "ampersand"
U_0027 = &18,&18,&18,&00,&00,&00,&00,&00 ;ISO  "apostrophe" (vertical)
U_0028 = &0C,&18,&30,&30,&30,&18,&0C,&00 ;ISO  "left parenthesis"
U_0029 = &30,&18,&0C,&0C,&0C,&18,&30,&00 ;ISO  "right parenthesis"
U_002A = &00,&18,&7E,&3C,&7E,&18,&00,&00 ;ISO  "asterisk"
U_002B = &00,&18,&18,&7E,&18,&18,&00,&00 ;ISO  "plus sign"
U_002C = &00,&00,&00,&00,&00,&18,&18,&30 ;ISO  "comma"
U_002D = &00,&00,&00,&7E,&00,&00,&00,&00 ;ISO  "hyphen-minus"
U_002E = &00,&00,&00,&00,&00,&18,&18,&00 ;ISO  "full stop"
U_002F = &00,&06,&0C,&18,&30,&60,&00,&00 ;ISO  "solidus"
U_0030 = &3C,&66,&6E,&7E,&76,&66,&3C,&00 ;ISO  "digit zero"
U_0031 = &18,&38,&18,&18,&18,&18,&7E,&00 ;ISO  "digit one"
U_0032 = &3C,&66,&06,&0C,&18,&30,&7E,&00 ;ISO  "digit two"
U_0033 = &3C,&66,&06,&1C,&06,&66,&3C,&00 ;ISO  "digit three"
U_0034 = &0C,&1C,&3C,&6C,&7E,&0C,&0C,&00 ;ISO  "digit four"
U_0035 = &7E,&60,&7C,&06,&06,&66,&3C,&00 ;ISO  "digit five"
U_0036 = &1C,&30,&60,&7C,&66,&66,&3C,&00 ;ISO  "digit six"
U_0037 = &7E,&06,&0C,&18,&30,&30,&30,&00 ;ISO  "digit seven"
U_0038 = &3C,&66,&66,&3C,&66,&66,&3C,&00 ;ISO  "digit eight"
U_0039 = &3C,&66,&66,&3E,&06,&0C,&38,&00 ;ISO  "digit nine"
U_003A = &00,&00,&18,&18,&00,&18,&18,&00 ;ISO  "colon"
U_003B = &00,&00,&18,&18,&00,&18,&18,&30 ;ISO  "semicolon"
U_003C = &0C,&18,&30,&60,&30,&18,&0C,&00 ;ISO  "less-than sign"
U_003D = &00,&00,&7E,&00,&7E,&00,&00,&00 ;ISO  "equals sign"
U_003E = &30,&18,&0C,&06,&0C,&18,&30,&00 ;ISO  "greater-than sign"
U_003F = &3C,&66,&0C,&18,&18,&00,&18,&00 ;ISO  "question mark"
U_0040 = &3C,&66,&6E,&6A,&6E,&60,&3C,&00 ;ISO  "commercial at"
U_0041 = &3C,&66,&66,&7E,&66,&66,&66,&00 ;ISO  "Latin capital letter A"
U_0042 = &7C,&66,&66,&7C,&66,&66,&7C,&00 ;ISO  "Latin capital letter B"
U_0043 = &3C,&66,&60,&60,&60,&66,&3C,&00 ;ISO  "Latin capital letter C"
U_0044 = &78,&6C,&66,&66,&66,&6C,&78,&00 ;ISO  "Latin capital letter D"
U_0045 = &7E,&60,&60,&7C,&60,&60,&7E,&00 ;ISO  "Latin capital letter E"
U_0046 = &7E,&60,&60,&7C,&60,&60,&60,&00 ;ISO  "Latin capital letter F"
U_0047 = &3C,&66,&60,&6E,&66,&66,&3C,&00 ;ISO  "Latin capital letter G"
U_0048 = &66,&66,&66,&7E,&66,&66,&66,&00 ;ISO  "Latin capital letter H"
U_0049 = &7E,&18,&18,&18,&18,&18,&7E,&00 ;ISO  "Latin capital letter I"
U_004A = &3E,&0C,&0C,&0C,&0C,&6C,&38,&00 ;ISO  "Latin capital letter J"
U_004B = &66,&6C,&78,&70,&78,&6C,&66,&00 ;ISO  "Latin capital letter K"
U_004C = &60,&60,&60,&60,&60,&60,&7E,&00 ;ISO  "Latin capital letter L"
U_004D = &63,&77,&7F,&6B,&6B,&63,&63,&00 ;ISO  "Latin capital letter M"
U_004E = &66,&66,&76,&7E,&6E,&66,&66,&00 ;ISO  "Latin capital letter N"
U_004F = &3C,&66,&66,&66,&66,&66,&3C,&00 ;ISO  "Latin capital letter O"
U_0050 = &7C,&66,&66,&7C,&60,&60,&60,&00 ;ISO  "Latin capital letter P"
U_0051 = &3C,&66,&66,&66,&6A,&6C,&36,&00 ;ISO  "Latin capital letter Q"
U_0052 = &7C,&66,&66,&7C,&6C,&66,&66,&00 ;ISO  "Latin capital letter R"
U_0053 = &3C,&66,&60,&3C,&06,&66,&3C,&00 ;ISO  "Latin capital letter S"
U_0054 = &7E,&18,&18,&18,&18,&18,&18,&00 ;ISO  "Latin capital letter T"
U_0055 = &66,&66,&66,&66,&66,&66,&3C,&00 ;ISO  "Latin capital letter U"
U_0056 = &66,&66,&66,&66,&66,&3C,&18,&00 ;ISO  "Latin capital letter V"
U_0057 = &63,&63,&6B,&6B,&7F,&77,&63,&00 ;ISO  "Latin capital letter W"
U_0058 = &66,&66,&3C,&18,&3C,&66,&66,&00 ;ISO  "Latin capital letter X"
U_0059 = &66,&66,&66,&3C,&18,&18,&18,&00 ;ISO  "Latin capital letter Y"
U_005A = &7E,&06,&0C,&18,&30,&60,&7E,&00 ;ISO  "Latin capital letter Z"
U_005B = &7C,&60,&60,&60,&60,&60,&7C,&00 ;ISO  "left square bracket"
U_005C = &00,&60,&30,&18,&0C,&06,&00,&00 ;ISO  "reverse solidus"
U_005D = &3E,&06,&06,&06,&06,&06,&3E,&00 ;ISO  "right square bracket"
U_005E = &3C,&66,&00,&00,&00,&00,&00,&00 ;ISO  "circumflex accent"
U_005F = &00,&00,&00,&00,&00,&00,&00,&FF ;ISO  "low line"
U_0060 = &30,&18,&00,&00,&00,&00,&00,&00 ;ISO  "grave accent"
U_0061 = &00,&00,&3C,&06,&3E,&66,&3E,&00 ;ISO  "Latin small letter a"
U_0062 = &60,&60,&7C,&66,&66,&66,&7C,&00 ;ISO  "Latin small letter b"
U_0063 = &00,&00,&3C,&66,&60,&66,&3C,&00 ;ISO  "Latin small letter c"
U_0064 = &06,&06,&3E,&66,&66,&66,&3E,&00 ;ISO  "Latin small letter d"
U_0065 = &00,&00,&3C,&66,&7E,&60,&3C,&00 ;ISO  "Latin small letter e"
U_0066 = &1C,&30,&30,&7C,&30,&30,&30,&00 ;ISO  "Latin small letter f"
U_0067 = &00,&00,&3E,&66,&66,&3E,&06,&3C ;ISO  "Latin small letter g"
U_0068 = &60,&60,&7C,&66,&66,&66,&66,&00 ;ISO  "Latin small letter h"
U_0069 = &18,&00,&38,&18,&18,&18,&3C,&00 ;ISO  "Latin small letter i"
U_006A = &18,&00,&38,&18,&18,&18,&18,&70 ;ISO  "Latin small letter j"
U_006B = &60,&60,&66,&6C,&78,&6C,&66,&00 ;ISO  "Latin small letter k"
U_006C = &38,&18,&18,&18,&18,&18,&3C,&00 ;ISO  "Latin small letter l"
U_006D = &00,&00,&36,&7F,&6B,&6B,&63,&00 ;ISO  "Latin small letter m"
U_006E = &00,&00,&7C,&66,&66,&66,&66,&00 ;ISO  "Latin small letter n"
U_006F = &00,&00,&3C,&66,&66,&66,&3C,&00 ;ISO  "Latin small letter o"
U_0070 = &00,&00,&7C,&66,&66,&7C,&60,&60 ;ISO  "Latin small letter p"
U_0071 = &00,&00,&3E,&66,&66,&3E,&06,&07 ;ISO  "Latin small letter q"
U_0072 = &00,&00,&6C,&76,&60,&60,&60,&00 ;ISO  "Latin small letter r"
U_0073 = &00,&00,&3E,&60,&3C,&06,&7C,&00 ;ISO  "Latin small letter s"
U_0074 = &30,&30,&7C,&30,&30,&30,&1C,&00 ;ISO  "Latin small letter t"
U_0075 = &00,&00,&66,&66,&66,&66,&3E,&00 ;ISO  "Latin small letter u"
U_0076 = &00,&00,&66,&66,&66,&3C,&18,&00 ;ISO  "Latin small letter v"
U_0077 = &00,&00,&63,&6B,&6B,&7F,&36,&00 ;ISO  "Latin small letter w"
U_0078 = &00,&00,&66,&3C,&18,&3C,&66,&00 ;ISO  "Latin small letter x"
U_0079 = &00,&00,&66,&66,&66,&3E,&06,&3C ;ISO  "Latin small letter y"
U_007A = &00,&00,&7E,&0C,&18,&30,&7E,&00 ;ISO  "Latin small letter z"
U_007B = &0C,&18,&18,&70,&18,&18,&0C,&00 ;ISO  "left curly bracket"
U_007C = &18,&18,&18,&18,&18,&18,&18,&00 ;ISO  "vertical line"
U_007D = &30,&18,&18,&0E,&18,&18,&30,&00 ;ISO  "right curly bracket"
U_007E = &31,&6B,&46,&00,&00,&00,&00,&00 ;ISO  "tilde"

INT_BASE        * &90001000
IRQLStatus      * &080  ; also &000
IRQHStatus      * &084
IRQLRawStatus   * &090  ; also &004
IRQHRawStatus   * &094
IRQLEnable      * &0A0  ; also &008
IRQHEnable      * &0A4
IRQLEnableSet   * &0A0  ; also &008
IRQHEnableSet   * &0A4
IRQLEnableClear * &0B0  ; also &00C
IRQHEnableClear * &0B4

HAL_IRQEnable
        LDR     a3, IntBase
        MOV     ip, #1
        CMP     a1, #32
        SUBHS   a1, a1, #32
        MOV     a1, ip, LSL a1
        STRLO   a1, [a3, #IRQLEnableSet]
        STRHS   a1, [a3, #IRQHEnableSet]
        MOV     pc, lr

HAL_IRQEnabled
        LDR     a3, IntBase
        MOV     ip, #1
        CMP     a1, #32
        LDRLO   a2, [a3, #IRQLEnable]
        LDRHS   a2, [a3, #IRQHEnable]
        SUBHS   a1, a1, #32
        ANDS    a1, a2, ip, LSL a1
        MOV     pc, lr

HAL_IRQDisable
        LDR     a3, IntBase
        MOV     ip, #1
        CMP     a1, #32
        SUBHS   a1, a1, #32
        MOV     a1, ip, LSL a1
        STRLO   a1, [a3, #IRQLEnableClear]
        STRHS   a1, [a3, #IRQHEnableClear]
        MOV     pc, lr

HAL_IRQClear
        MOV     pc, lr

HAL_IRQStatus
        LDR     a3, IntBase
        MOV     ip, #1
        CMP     a1, #32
        LDRLO   a2, [a3, #IRQLStatus]
        LDRHS   a2, [a3, #IRQHStatus]
        SUBHS   a1, a1, #32
        ANDS    a1, a2, ip, LSL a1
        MOV     pc, lr

HAL_IRQRawStatus
        LDR     a3, IntBase
        MOV     ip, #1
        CMP     a1, #32
        LDRLO   a2, [a3, #IRQLRawStatus]
        LDRHS   a2, [a3, #IRQHRawStatus]
        SUBHS   a1, a1, #32
        ANDS    a1, a2, ip, LSL a1
        MOV     pc, lr

; Slow, and no sensible priority, but it'll do for a first pass.
HAL_GetHighestIRQ
        LDR     a3, IntBase
        MOV     a1, #0
        LDR     ip, [a3, #IRQLStatus]
05      MOVS    ip, ip, LSR #1
        MOVCS   pc, lr
        BEQ     %FT30
        ADD     a1, a1, #1
        B       %BT05
30      MOV     a1, #32
        LDR     ip, [a3, #IRQHStatus]
10      MOVS    ip, ip, LSR #1
        MOVCS   pc, lr
        ADD     a1, a1, #1
        BNE     %BT10
        MOV     a1, #64
        MOV     pc, lr


; Pad to 64K
        %       65536-(.-HAL_Base)

        END
