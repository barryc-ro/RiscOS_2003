        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System

        GET     Hdr:OSEntries

        GET     hdr.StaticWS
        GET     hdr.Hardware

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        IMPORT  HAL_CounterDelay

; MCCR fields
ASD_SHIFT       * 0
ASD_MASK        * 2_1111111
TSD_SHIFT       * 8
TSD_MASK        * 2_1111111 :SHL: 8
MCE             * 1:SHL:16
ECS             * 1:SHL:17
ADM             * 1:SHL:18
TTM             * 1:SHL:19
TRM             * 1:SHL:20
ATM             * 1:SHL:21
ARM             * 1:SHL:22
LBM             * 1:SHL:23
ECP_SHIFT       * 24
ECP_PDCLK       * 0:SHL:ECP_SHIFT
ECP_PDCLK2      * 1:SHL:ECP_SHIFT
ECP_PDCLK3      * 2:SHL:ECP_SHIFT
ECP_PDCLK4      * 3:SHL:ECP_SHIFT
PMC             * 1:SHL:26
ERI             * 1:SHL:27
EWI             * 1:SHL:28

; MCSR fields
ATS             * 1:SHL:0
ARS             * 1:SHL:1
TTS             * 1:SHL:2
TRS             * 1:SHL:3
ATU             * 1:SHL:4
ARO             * 1:SHL:5
TTU             * 1:SHL:6
TRO             * 1:SHL:7
ANF             * 1:SHL:8
ANE             * 1:SHL:9
TNF             * 1:SHL:10
TNE             * 1:SHL:11
CWC             * 1:SHL:12
CRC             * 1:SHL:13
ACE             * 1:SHL:14
TCE             * 1:SHL:15

; MCDR2 fields - bottom 16 bits are data
MCDR2_nRW       * 1:SHL:16
MCDR2_REG_SHIFT * 17

ClkDiv * 14     ; 9216000/(32*14) = 20571Hz

; UCB 1200 registers
UCB_IOData     * 0
UCB_IODir      * 1
UCB_IntRise    * 2
UCB_IntFall    * 3
UCB_IntStatus  * 4
UCB_IntClear   * 4
UCB_TelecomA   * 5
UCB_TelecomB   * 6
UCB_AudioA     * 7
UCB_AudioB     * 8
UCB_Touch      * 9
UCB_ADCControl * 10
UCB_ADCData    * 11
UCB_ID         * 12
UCB_Mode       * 13
UCB_Null       * 15

; UCB 1200 Falling edge interrupt enable register
IO_FAL_INT0     * 1:SHL:0
IO_FAL_INT1     * 1:SHL:1
IO_FAL_INT2     * 1:SHL:2
IO_FAL_INT3     * 1:SHL:3
IO_FAL_INT4     * 1:SHL:4
IO_FAL_INT5     * 1:SHL:5
IO_FAL_INT6     * 1:SHL:6
IO_FAL_INT7     * 1:SHL:7
IO_FAL_INT8     * 1:SHL:8
IO_FAL_INT9     * 1:SHL:9
ADC_FAL_INT     * 1:SHL:11
TSPX_FAL_INT    * 1:SHL:12
TSMX_FAL_INT    * 1:SHL:13
TCLIP_FAL_INT   * 1:SHL:14
ACLIP_FAL_INT   * 1:SHL:15

; UCB 1200 Interrupt clear register
IO_INT_CLR0     * 1:SHL:0
IO_INT_CLR1     * 1:SHL:1
IO_INT_CLR2     * 1:SHL:2
IO_INT_CLR3     * 1:SHL:3
IO_INT_CLR4     * 1:SHL:4
IO_INT_CLR5     * 1:SHL:5
IO_INT_CLR6     * 1:SHL:6
IO_INT_CLR7     * 1:SHL:7
IO_INT_CLR8     * 1:SHL:8
IO_INT_CLR9     * 1:SHL:9
ADC_INT_CLR     * 1:SHL:11
TSPX_INT_CLR    * 1:SHL:12
TSMX_INT_CLR    * 1:SHL:13
TCLIP_INT_CLR   * 1:SHL:14
ACLIP_INT_CLR   * 1:SHL:15

; UCB 1200 Touchscreen control register
TSMX_POW        * 1:SHL:0
TSPX_POW        * 1:SHL:1
TSMY_POW        * 1:SHL:2
TSPY_POW        * 1:SHL:3
TSMX_GND        * 1:SHL:4
TSPX_GND        * 1:SHL:5
TSMY_GND        * 1:SHL:6
TSPY_GND        * 1:SHL:7
TSC_MODE_INT    * 0:SHL:8
TSC_MODE_PRES   * 1:SHL:8
TSC_MODE_POS    * 2:SHL:8
TSC_BIAS_ENA    * 1:SHL:11
TSPX_LOW        * 1:SHL:12
TSPY_LOW        * 1:SHL:13

; UCB 1200 ADC control register
ADC_SYNC_ENA    * 1:SHL:0
VREFBYP_CON     * 1:SHL:1
ADC_INPUT_TSPX  * 0:SHL:2
ADC_INPUT_TSMX  * 1:SHL:2
ADC_INPUT_TSPY  * 2:SHL:2
ADC_INPUT_TSMY  * 3:SHL:2
ADC_INPUT_AD0   * 4:SHL:2
ADC_INPUT_AD1   * 5:SHL:2
ADC_INPUT_AD2   * 6:SHL:2
ADC_INPUT_AD3   * 7:SHL:2
EXT_REF_ENA     * 1:SHL:5
ADC_START       * 1:SHL:7
ADC_ENA         * 1:SHL:15

; UCB 1200 ADC data register
ADC_DAT_VAL     * 1:SHL:15

; UCB 1200 Mode register
DYN_VFLAG_ENA   * 1:SHL:12

; void WriteUCB1200(int reg, int value)
WriteUCB1200
        MRS     a3, CPSR
        MOV     a2, a2, LSL #16
        MOV     a2, a2, LSR #16
        ORR     a2, a2, #MCDR2_nRW
        ORR     a2, a2, a1, LSL #MCDR2_REG_SHIFT
        ORR     ip, a3, #I32_bit
        MSR     CPSR_c, ip
        STR     a2, [v1, #MCDR2]
10      LDR     a2, [v1, #MCSR]                 ; Why poll for the result when we don't
        TST     a2, #CWC                        ; need it? Better would be to set a flag
        BEQ     %BT10                           ; and poll at the next access attempt.
        MSR     CPSR_c, a3
        MOV     pc, lr

; int ReadUCB1200(int reg)
ReadUCB1200
        MRS     a3, CPSR
        MOV     a1, a1, LSL #MCDR2_REG_SHIFT
        ORR     ip, a3, #I32_bit
        MSR     CPSR_c, ip
        STR     a1, [v1, #MCDR2]
10      LDR     a2, [v1, #MCSR]                 ; Polling for the result - shouldn't
        TST     a2, #CRC                        ; take long, we hope (I reckon 21µs max).
        BEQ     %BT10
        LDRH    a1, [v1, #MCDR2]
        MSR     CPSR_c, a3
        MOV     pc, lr

ReadADC
        Push    "v2,v3,lr"
        MRS     v3, CPSR
        ORR     ip, v3, #I32_bit
        MSR     CPSR_c, ip

        ORR     v2, a1, #ADC_ENA
       ; ORR     v2, v2, #ADC_SYNC_ENA                  ; Don't use sync - it isn't actually connected

        MOV     a1, #UCB_ADCControl                     ; Start up the ADC circuit
        MOV     a2, v2
        BL      WriteUCB1200

    ;    MOV     a1, #400 ;us
    ;    BL      HAL_CounterDelay

        MOV     a1, #UCB_ADCControl                     ; Start the conversion
        ORR     a2, v2, #ADC_START
        BL      WriteUCB1200

10      MOV     a1, #UCB_ADCData                        ; Wait for response
        BL      ReadUCB1200
        TST     a1, #ADC_DAT_VAL
        BEQ     %BT10

        MOV     a2, v2
   ;     BIC     a2, v2, #ADC_ENA                        ; Stop the ADC (v2 register conflict)
        MOV     v2, a1, LSR #5                          ; Push result down to bottom 10 bits
        MOV     a1, #UCB_ADCControl
        BL      WriteUCB1200

        MSR     CPSR_c, v3

        MOV     a1, v2, LSL #22                         ; Expand result to 32 bits
        ORR     a1, a1, a1, LSR #10
        ORR     a1, a1, a1, LSR #20

        Pull    "v2,v3,pc"

        EXPORT  SIB_Init
        EXPORT  HAL_TouchscreenRead
        EXPORT  HAL_TouchscreenType

SIB_Init
        Push    "v1,lr"
        LDR     v1, SIB_Address
        MVN     a1, #0
;        MOV     a1, #ATU+ARO+TTU+TRO
        STR     a1, [v1, #MCSR]         ; clear pending interrupts
        LDR     a1, =(ClkDiv:SHL:ASD_SHIFT) + (ClkDiv:SHL:TSD_SHIFT) + MCE + PMC
        STR     a1, [v1, #MCCR]
        MOV     a1, #UCB_AudioA
        MOV     a2, #ClkDiv
        BL      WriteUCB1200
        MOV     a1, #UCB_TelecomA
        MOV     a2, #ClkDiv
        BL      WriteUCB1200
        MOV     a1, #UCB_Mode
        MOV     a2, #DYN_VFLAG_ENA
        BL      WriteUCB1200
        MOV     a1, #UCB_IntClear
        MOV     a2, #TSPX_INT_CLR
        BL      WriteUCB1200
        MOV     a1, #UCB_IntClear
        MOV     a2, #0
        BL      WriteUCB1200
        MOV     a1, #UCB_IntFall
        MOV     a2, #TSPX_FAL_INT
        BL      WriteUCB1200
        MOV     a1, #5
        STRB    a1, TSMode
        Pull    "v1,pc"

HAL_TouchscreenType
        MOV     a1, #1 ; resistive
        ORR     a1, a1, #10 :SHL: 16 ; bits of precision
        MOV     pc, lr

HAL_TouchscreenRead
        Push    "v1-v4,lr"
        LDR     v1, SIB_Address
        ADR     ip, TSdriveTable
        ADD     ip, ip, a1, LSL #3
        LDMIA   ip, {v2, v3}

        MRS     v4, CPSR
        ORR     ip, v4, #I32_bit
        MSR     CPSR_c, ip

        MOV     a1, #UCB_Touch
        MOV     a2, v2
        BL      WriteUCB1200                    ; Set up the touchscreen pins

        MOV     a1, #150 ;us
        BL      HAL_CounterDelay

        MOV     a1, v3                          ; Do an ADC read on the appropriate pin
        BL      ReadADC
       ; MOV     v2, a1

       ; MOV     a1, #UCB_Touch                  ; Back to interrupt mode (low power)
       ; LDR     a2, =TSPX_POW + TSMX_POW + TSPY_GND + TSMY_GND + TSC_MODE_INT
       ; BL      WriteUCB1200

        MSR     CPSR_c, v4

       ; MOV     a1, v2
        Pull    "v1-v4,pc"

        EXPORT  HAL_TouchscreenMeasure
HAL_TouchscreenMeasure
        Push    "v1,lr"
        LDR     v1, SIB_Address
        ADR     ip, TSdriveTable+4
        LDR     a1, [ip, a1, LSL #3]
        BL      ReadADC
        Pull    "v1,pc"

        EXPORT  HAL_TouchscreenMode
HAL_TouchscreenMode
        Push    "v1,v2,lr"
        MOV     v2, a1
        LDR     v1, SIB_Address
        ADR     ip, TSdriveTable
        LDR     a2, [ip, v2, LSL #3]
        MOV     a1, #UCB_Touch
        BL      WriteUCB1200
        LDRB    a1, TSMode
        TEQ     v2, #5
        BEQ     HAL_TSModeInt

        TEQ     a1, #5                          ; turn off interrupts
        MOVEQ   a2, #0
        MOVEQ   a1, #UCB_IntFall
        BLEQ    WriteUCB1200

10      STRB    v2, TSMode
        Pull    "v1,v2,pc"


HAL_TSModeInt
        STRB    v2, TSMode
        MOV     v2, a1

        MOV     a2, #TSPX_INT_CLR               ; clear interrupts
        MOV     a1, #UCB_IntClear
        BL      WriteUCB1200
        MOV     a2, #0
        MOV     a1, #UCB_IntClear
        BL      WriteUCB1200

        TEQ     v2, #5
        MOVNE   a2, #TSPX_FAL_INT               ; turn on interrupts
        MOVNE   a1, #UCB_IntFall
        BLNE    WriteUCB1200

        Pull    "v1,v2,pc"



TSdriveTable
        DCD     TSPX_POW + TSMX_GND                       + TSC_MODE_POS  + TSC_BIAS_ENA, ADC_INPUT_TSMY
        DCD                           TSPY_POW + TSMY_GND + TSC_MODE_POS  + TSC_BIAS_ENA, ADC_INPUT_TSMX
        DCD     TSPX_POW + TSMX_POW + TSPY_GND + TSMY_GND + TSC_MODE_PRES + TSC_BIAS_ENA, ADC_INPUT_TSMX
        DCD     TSPX_POW + TSMX_GND                       + TSC_MODE_PRES + TSC_BIAS_ENA, ADC_INPUT_TSMX
        DCD                           TSPY_POW + TSMY_GND + TSC_MODE_PRES + TSC_BIAS_ENA, ADC_INPUT_TSMY
        DCD     TSPX_POW + TSMX_POW + TSPY_GND + TSMY_GND + TSC_MODE_INT                , ADC_INPUT_TSMX

        END
