
;
; Colour LCD controller driving K6488L DSTN display
;

; mjs Oct 2000

; ------------------------------------------------------------------------

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO
        GET     Hdr:Proc

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS
        GET     hdr.Video
        GET     hdr.Hardware

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        EXPORT  Video_init
        EXPORT  HAL_VideoFlybackDevice
        EXPORT  HAL_Video_SetMode
        EXPORT  HAL_Video_WritePaletteEntry
        EXPORT  HAL_Video_WritePaletteEntries
        EXPORT  HAL_Video_ReadPaletteEntry
        EXPORT  HAL_Video_SetInterlace
        EXPORT  HAL_Video_SetBlank
        EXPORT  HAL_Video_SetPowerSave
        EXPORT  HAL_Video_UpdatePointer
        EXPORT  HAL_Video_SetDAG
        EXPORT  HAL_Video_VetMode
        EXPORT  HAL_Video_PixelFormats
        EXPORT  HAL_Video_Features
        EXPORT  HAL_Video_BufferAlignment

        EXPORT  HAL_IRQClear_Video

        IMPORT  HAL_TimerSetPeriod
        IMPORT  HAL_CounterDelay

; ------------------------------------------------------------------------

Video_init ROUT
    Push     "a1-a4, ip, lr"

    LDR      a1, GPIO_BASE_Address
    MOV      a2, #2_00011110
    STRB     a2, [a1, #PEDDR]        ; set up outputs on port E
    MOV      a2, #2_00000100
    STRB     a2, [a1, #PEDR]

    MOV      a2, #0                  ; ensure disabled, off
    STR      a2, [a1, #CLCD_Control]

    ADR      a1, CLCD_boot_display
    BL       HAL_Video_SetMode

    MOV      a1, #0
    ADR      a2, CLCD_boot_palette
    MOV      a3, #0
    MOV      a4, #16
    BL       HAL_Video_WritePaletteEntries

    MOV      a1, #0
    LDR      a2, =&F1C00000         ; assumed screen address for start-up
    BL       HAL_Video_SetDAG

    LDR      ip, CLCD_Address
    LDR      a1, [ip, #CLCD_Control]
    ORR      a1, a1, #CLCDCB_LCDEN
    STR      a1, [ip, #CLCD_Control]
    MOV      a1, #0
    MOV      a2, #36864              ; nominal period
    BL       HAL_TimerSetPeriod
    MOV      a1, #&4F00              ; approx 20000 usec or 20 msec
    BL       HAL_CounterDelay
    LDR      ip, CLCD_Address
    LDR      a1, [ip, #CLCD_Control]
    ORR      a1, a1, #CLCDCB_LCDPWR
    STR      a1, [ip, #CLCD_Control]

    Pull     "a1-a4, ip, pc"

; ------------------------------------------------------------------------

; in:  a3 = pixel rate (kHz)
; out: a2 = PCD value (0..31 for /2 .. /33), a3 corrupted

; should probably do decent division

Video_ComputePCD

    ! 0, "naff implementation of Video_ComputePCD"

    Push     "lr"

    CMP      a3, #4096
    MOVLO    a3, #4096        ; 4MHz minimum, just to avoid silliness in naff division
    LDR      lr, =CLCD_CLK


    MOV      a2, #0
10                            ; impressively naff division algorithm
    SUBS     lr, lr, a3
    ADDPL    a2, a2, #1
    BPL      %BT10

    ADD      lr, lr, a3
    CMP      lr, a3, LSR #1
    ADDHI    a2, a2, #1       ; rounding

    CMP      a2, #2
    MOVLO    a2, #2
    CMP      a2, #33
    MOVHI    a2, #33

    SUB      a2, a2, #2

    Pull     "pc"

; ------------------------------------------------------------------------

;
;  uint HAL_VideoFlybackDevice(void)
;

HAL_VideoFlybackDevice

        MOV     a1, #CLCD_IRQ
        MOV     pc, lr

HAL_IRQClear_Video
        LDR     a4, CLCD_Address
        MOV     a1, #CLCDSB_VCOMP
        STR     a1, [a4, #CLCD_Status]
        MOV     pc, lr

; -------------------------------------------------------------------------

;
;  void HAL_Video_SetMode(const void *VIDCList3)
;

  ! 0, "Video_SetMode does very little validation of VIDC3List"

HAL_Video_SetMode ROUT

        Push    "lr"

        LDR     ip, CLCD_Address
;
; control reg
        LDR     a2, [ip, #CLCD_Control]
        LDR     a3, =(CLCDCB_LCDEN | CLCDCB_LCDPWR) ; preserve these
        AND     a2, a2, a3
        ORR     a2, a2, #CLCDCB_LCDDUAL
        ORR     a2, a2, #(CLCDCB_LCDVCOMP | CLCDCB_LCDMUX)
        LDR     a3, [a1, #VIDCList3_PixelDepth]  ; assume its either 4,8 or 16 bpp
        STR     a3, CLCD_bpp                     ; remember it
        CMP     a3, #3
        ORRLO   a2, a2, #CLCDCB_4BPP
        ORREQ   a2, a2, #CLCDCB_8BPP
        ORRHI   a2, a2, #CLCDCB_16BPP
        STR     a2, [ip, #CLCD_Control]
;
; mask reg
        MOV     a2, #CLCDSB_VCOMP
        STR     a2, [ip, #CLCD_Mask]
;
; timing0
        LDR     a3, [a1, #VIDCList3_HorizDisplaySize]
        MOV     a3, a3, LSR #4
        SUB     a3, a3, #1                            ; program PPL with size/16 -1
        MOV     a2, a3, LSL #2                        ; PPL field
        LDR     a3, [a1, #VIDCList3_HorizSyncWidth]
        SUBS    a3, a3, #1
        MOVMI   a3, #0
        ORR     a2, a2, a3, LSL #8                    ; HSW field
        LDR     a3, [a1, #VIDCList3_HorizBackPorch]
        LDR     a4, [a1, #VIDCList3_HorizLeftBorder]
        ADD     a3, a3, a4
        SUBS    a3, a3, #1
        MOVMI   a3, #0
        ORR     a2, a2, a3, LSL #24                   ; HBP field
        LDR     a3, [a1, #VIDCList3_HorizRightBorder]
        LDR     a4, [a1, #VIDCList3_HorizFrontPorch]
        ADD     a3, a3, a4
        SUBS    a3, a3, #1
        MOVMI   a3, #0
        ORR     a2, a2, a3, LSL #16                   ; HFP field
        STR     a2, [ip, #CLCD_Timing0]
;
; timing 1
        LDR     a3, [a1, #VIDCList3_VertiDisplaySize]
        MOV     a3, a3, LSR #1                        ; /2 (lines per panel)
        SUB     a2, a3, #1                            ; LPS field
        LDR     a3, [a1, #VIDCList3_VertiSyncWidth]
        SUBS    a3, a3, #1
        MOVMI   a3, #0
        ORR     a2, a2, a3, LSL #10                   ; VSW field
        LDR     a3, [a1, #VIDCList3_VertiBottomBorder]
        LDR     a4, [a1, #VIDCList3_VertiFrontPorch]
        ADD     a3, a3, a4
        ORR     a2, a2, a3, LSL #16                   ; VFP field
        LDR     a3, [a1, #VIDCList3_VertiBackPorch]
        LDR     a4, [a1, #VIDCList3_VertiTopBorder]
        ADD     a3, a3, a4
        ORR     a2, a2, a3, LSL #24                   ; VBP field
        STR     a2, [ip, #CLCD_Timing1]
;
; timing 2
        LDR     a3, [a1, #VIDCList3_PixelRate]
        ADD     a3, a3, a3, LSL #1
        MOV     a3, a3, LSR #4                       ; *3/16 (*3/8 then /2 for dual panel)
        BL      Video_ComputePCD                     ; returns PCD in a2
        LDR     a3, [a1, #VIDCList3_HorizDisplaySize]
        ADD     a3, a3, a3, LSL #1
        MOV     a3, a3, LSR #3                       ; *3/8
        SUB     a3, a3, #1
        ORR     a2, a2, a3, LSL #16                  ; CPL field
        ORR     a2, a2, #(12<<6)                     ; ACB = 12
        STR     a2, [ip, #CLCD_Timing2]
;
; timing 3
        MOV     a2, #15                              ; LED = 15
        ORR     a2, a2, #(1<<16)                     ; LEE active
        STR     a2, [ip, #CLCD_Timing3]

        Pull    "pc"

; -------------------------------------------------------------------------

;
; void HAL_Video_WritePaletteEntry(uint type, uint pcolour, uint index)
;

HAL_Video_WritePaletteEntry ROUT

        TEQ     a1, #0                ; ignore border, pointer (types 1,2)
        MOVNE   pc, lr

        MOV     a2, a2, LSR #8        ; 00BBGGRR
        BIC     a2, a2, #&0000000F    ; 00BBGGR0
        BIC     a2, a2, #&00000F00    ; 00BBG0R0
        BIC     a2, a2, #&000F0000    ; 00B0G0R0

        LDR     ip, CLCD_Address
        ADD     ip, ip, #CLCD_Palette

        STR     a2, [ip, a3, LSL #2]  ; hit palette entry

        MOV     pc, lr

; -------------------------------------------------------------------------

;
; void HAL_Video_WritePaletteEntries(uint type, const uint *pcolours,
;                                    uint index, uint Nentries)
;

HAL_Video_WritePaletteEntries ROUT

        TEQ     a1, #0                ; ignore border, pointer (types 1,2)
        MOVNE   pc, lr

        LDR     ip, CLCD_Address
        ADD     ip, ip, #CLCD_Palette
        ADD     ip, ip, a3, LSL #2    ; first palette entry

        ; First write appears to fail sometimes after vsync - flashing colour
        ; zero doesn't work. Reason as yet unknown...

10      LDR     a1, [a2], #4
        SUBS    a4, a4, #1
        MOV     a1, a1, LSR #8        ; 00BBGGRR
        BIC     a1, a1, #&0000000F    ; 00BBGGR0
        BIC     a1, a1, #&00000F00    ; 00BBG0R0
        BIC     a1, a1, #&000F0000    ; 00B0G0R0
        STR     a1, [ip], #4
        BNE     %BT10

        MOV     pc, lr

; -------------------------------------------------------------------------

;
; uint HAL_Video_ReadPaletteEntry(uint type, uint pcolour, uint index)
;

; we'll pretend we have border, pointer entries of same form as normal entries

HAL_Video_ReadPaletteEntry ROUT

        BIC     a1, a2, #&000000FF    ; BBGGRR00
        BIC     a1, a1, #&00000F00    ; BBGGR000
        BIC     a1, a1, #&000F0000    ; BBG0R000
        BIC     a1, a1, #&0F000000    ; B0G0R000

        MOV     pc, lr

; -------------------------------------------------------------------------

;
; void HAL_Video_SetInterlace(uint interlace)
;

HAL_Video_SetInterlace ROUT

        MOV     pc, lr       ; not implemented

; -------------------------------------------------------------------------

;
; void HAL_Video_SetBlank(uint blank, uint DPMS)
;

        ! 0, "HAL_Video_SetBlank not implemented"

HAL_Video_SetBlank

        MOV     pc, lr       ; not implemented, at least for now

; -------------------------------------------------------------------------

;
; void HAL_Video_SetPowerSave(uint powersave)
;

HAL_Video_SetPowerSave ROUT

        ! 0, "HAL_Video_SetPowerSave not implemented"

        MOV     pc, lr       ; not implemented

; -------------------------------------------------------------------------

;
; void HAL_Video_UpdatePointer(uint flags, int x, int y, const shape_t *shape)
;

HAL_Video_UpdatePointer ROUT

        MOV     pc, lr       ; not implemented, we have no h/w pointer

; -------------------------------------------------------------------------

;
; void HAL_Video_SetDAG(uint DAG, uint paddr)
;

HAL_Video_SetDAG ROUT

        TEQ     a1, #0                ; ignore calls except DAG=0 (start of display)
        MOVNE   pc, lr

        LDR     ip, CLCD_Address

        BIC     a2, a2, #&1F          ; 32-byte aligned
        BIC     a2, a2, #&FE000000
        STR     a2, [ip, #CLCD_DBAR0]

        LDR     a3, =CLCD_DUALOFFSET  ; offset in pixels
        LDR     a4, CLCD_bpp          ; 2,3 or 4 for 4,8,16 bpp
        CMP     a4, #3
        MOVLO   a3, a3, LSR #1
        MOVHI   a3, a3, LSL #1        ; offset in bytes
        ADD     a3, a3, a2
        STR     a3, [ip, #CLCD_DBAR1]

        MOV     pc, lr

; -------------------------------------------------------------------------

;
; int HAL_Video_VetMode(const void *VIDClist, const void *workspace)
;

HAL_Video_VetMode ROUT

        MOV   r0, #0    ; do nothing for now
        MOV   pc, lr

; -------------------------------------------------------------------------

;
; uint HAL_Video_Features(void)
;
; returns a flags word:
;    bit 0     h/w scroll is supported
;    bit 1     h/w pointer is supported
;    bit 2     interlace is supported with progressive framestore
;    other bits reserved (returned as 0)

HAL_Video_Features ROUT
        MOV   a1, #0     ; no h/w scroll, pointer or interlace
        MOV   pc, lr

; -------------------------------------------------------------------------

;
; uint HAL_Video_PixelFormats(void)
;
;
; returns flags word:
;    bit 0     1 bpp is supported
;    bit 1     2 bpp is supported
;    bit 2     4 bpp is supported
;    bit 3     8 bpp is supported
;    bit 4    16 bpp is supported
;    bit 5    32 bpp is supported
;    other bits reserved (returned as 0)
;    bits 0-5 refer to support with standard RO pixel layout (little endian
;    packing for 1,2,4 bpp, 5-5-5 RGB for 16 bpp, etc.)
;    other formats may be introduced when/if RO supports them

HAL_Video_PixelFormats ROUT
        MOV   a1, #2_011100   ; 4,8,16 bpp
        MOV   pc, lr

; -------------------------------------------------------------------------

;
; uint HAL_Video_BufferAlignment(void)
;
; returns the required alignment for the framestore buffer, in bytes
; (expected to be a power of 2)

HAL_Video_BufferAlignment ROUT
        MOV   a1, #32          ; align to 32 bytes
        MOV   pc, lr

; -------------------------------------------------------------------------

;
; a minimal display for start-up display, specified as a VIDCList3
;
CLCD_boot_display
        &     3         ; format 3
        &     2         ; 4 bpp
; horizontal
        &     8         ; sync width
        &     32        ; back porch
        &     0         ; left border
        &     640       ; display size
        &     0         ; right border
        &     16        ; front porch
; vertical
        &     1         ; sync width
        &     0         ; back porch
        &     0         ; top border
        &     480       ; display size
        &     0         ; bottom border
        &     0         ; front porch
;
        &     30000     ; pixel rate (kHz)
        &     0         ; sync polarity
        &     -1        ; terminator

;
; a 16 colour palette for start-up display (4 bpp)
;
CLCD_boot_palette
        &     &00000000 ; black  (BBGGRRSS)
        &     &0000FF00 ; red
        &     &00FF0000 ; green
        &     &00FFFF00 ; yellow
        &     &FF000000 ; blue
        &     &FF00FF00 ; magenta
        &     &FFFF0000 ; cyan
        &     &FFFFFF00 ; white
        &     &00000000 ; black
        &     &00007F00 ; half red
        &     &007F0000 ; half green
        &     &007F7F00 ; half yellow
        &     &7F000000 ; half blue
        &     &7F007F00 ; half magenta
        &     &7F7F0000 ; half cyan
        &     &7F7F7F00 ; half white

; -------------------------------------------------------------------------

        END
