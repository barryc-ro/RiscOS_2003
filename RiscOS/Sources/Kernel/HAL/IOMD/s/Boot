        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetCPU
        $GetIO
        $GetMEMC
        $GetMEMM
        $GetVIDC

                GBLL    CheckProtectionLink     ; if true, disallow CMOS RAM changes if link in protected position
CheckProtectionLink SETL (IO_Type = "IOMD") :LAND: {TRUE}       ; NB affects Delete/Copy/R/T and 0-9/.

        GET     Hdr:Proc
        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS



                GBLL    VCOstartfix
VCOstartfix     SETL    {TRUE}


; This version assumes a RISC OS image starting 64K after us.

        AREA    |!!!ROMStart|, CODE, READONLY, PIC

        ENTRY

HAL_Base

vectors
        LDR     pc, ResetInd            ; Reset
        LDR     pc, HaltInd             ; Undefined instruction
        LDR     pc, HaltInd             ; SWI
        LDR     pc, HaltInd             ; Prefetch abort
        LDR     pc, HaltInd             ; Data abort
        LDR     pc, HaltInd             ; (Address exception)
        LDR     pc, HaltInd             ; IRQ
        LDR     pc, HaltInd             ; FIQ

; The above 8 instructions will operate as expected in 32-bit ROM mode,
; or in 16-bit ROM mode with a 16-bit ROM used.  In 16-bit ROM mode, and
; with 32-bit wide ROMs in use, they will instead be intepreted as 4
; NV-condition instructions (exact meaning not determined and should be
; irrelevant) which should do nothing and so allow control to drop
; through to this point, still in 16-bit mode.  Force IOMD into 32-bit
; ROM mode for bank 0.  The following instruction sequence has been
; produced in 16-in-32 form by extracting hex values from a listing...

        DCD     &0000B632, &0000E3A0    ; 20: MOV R11, #IO+IOMDREGS - point at IOMD
        DCD     &00000000, &0000E3A0    ; 28: MOV R0, #&0 - ROMCR:32b,slow,218.75us,no burst
        DCD     &00000080, &0000E5CB    ; 30: STRB R0,[R11,#ROMCR0] - switch mode
        DCD     &0000F000, &0000E3A0    ; 38: MOV PC, #0 - jump to 0 (this instr pre-fetched)

ResetInd
        DCD     start - HAL_Base
HaltInd
        DCD     halt - HAL_Base

halt    B       halt

        ASSERT  . - HAL_Base < 0x60
        %       0x60 - (. - HAL_Base)
ROMsize
        DCD     0                       ; patched in by build system

HALdescriptor   DATA
        DCD     0
        DCD     HAL_Base - HALdescriptor
        DCD     64*1024
        DCD     HAL_EntryTable - HALdescriptor
        DCD     HAL_Entries
        DCD     HAL_WsSize

        MACRO
        HALEntry $name
        ASSERT  (. - HAL_EntryTable) / 4 = EntryNo_$name
        DCD     $name - HAL_EntryTable
        MEND

        MACRO
        NullEntry
        DCD     HAL_Null - HAL_EntryTable
        MEND

        IMPORT   Video_init

        IMPORT   HAL_IRQEnable
        IMPORT   HAL_IRQDisable
        IMPORT   HAL_IRQClear
        IMPORT   HAL_IRQSource

        IMPORT   HAL_Timers
        IMPORT   HAL_TimerDevice
        IMPORT   HAL_TimerGranularity
        IMPORT   HAL_TimerMaxPeriod
        IMPORT   HAL_TimerSetPeriod
        IMPORT   HAL_TimerPeriod
        IMPORT   HAL_TimerReadCountdown

        IMPORT   HAL_CounterRate
        IMPORT   HAL_CounterPeriod
        IMPORT   HAL_CounterRead
        IMPORT   HAL_CounterDelay

        IMPORT   HAL_IICBuses
        IMPORT   HAL_IICType
        IMPORT   HAL_IICSetLines
        IMPORT   HAL_IICReadLines

    	IMPORT	 HAL_NVMemoryType
    	IMPORT	 HAL_NVMemorySize
    	IMPORT	 HAL_NVMemoryProtectedSize
    	IMPORT	 HAL_NVMemoryProtection
    	IMPORT	 HAL_NVMemoryIICAddress
    	IMPORT	 HAL_NVMemoryRead
    	IMPORT	 HAL_NVMemoryWrite

        IMPORT   HAL_VideoFlybackDevice
        IMPORT   HAL_Video_SetMode
        IMPORT   HAL_Video_WritePaletteEntry
        IMPORT   HAL_Video_WritePaletteEntries
        IMPORT   HAL_Video_ReadPaletteEntry
        IMPORT   HAL_Video_SetInterlace
        IMPORT   HAL_Video_SetBlank
        IMPORT   HAL_Video_SetPowerSave
        IMPORT   HAL_Video_UpdatePointer
        IMPORT   HAL_Video_SetDAG
        IMPORT   HAL_Video_VetMode

        IMPORT   HAL_MachineID

HAL_EntryTable  DATA
        HALEntry HAL_Init

        HALEntry HAL_IRQEnable
        HALEntry HAL_IRQDisable
        HALEntry HAL_IRQClear
        HALEntry HAL_IRQSource

        HALEntry HAL_Timers
        HALEntry HAL_TimerDevice
        HALEntry HAL_TimerGranularity
        HALEntry HAL_TimerMaxPeriod
        HALEntry HAL_TimerSetPeriod
        HALEntry HAL_TimerPeriod
        HALEntry HAL_TimerReadCountdown

        HALEntry HAL_CounterRate
        HALEntry HAL_CounterPeriod
        HALEntry HAL_CounterRead
        HALEntry HAL_CounterDelay

    	HALEntry HAL_NVMemoryType
    	HALEntry HAL_NVMemorySize
    	HALEntry HAL_NVMemoryProtectedSize
    	HALEntry HAL_NVMemoryProtection
    	HALEntry HAL_NVMemoryIICAddress
    	HALEntry HAL_NVMemoryRead
    	HALEntry HAL_NVMemoryWrite

        HALEntry HAL_IICBuses
        HALEntry HAL_IICType
        HALEntry HAL_IICSetLines
        HALEntry HAL_IICReadLines

        HALEntry HAL_VideoFlybackDevice
        HALEntry HAL_Video_SetMode
        HALEntry HAL_Video_WritePaletteEntry
        HALEntry HAL_Video_WritePaletteEntries
        HALEntry HAL_Video_ReadPaletteEntry
        HALEntry HAL_Video_SetInterlace
        HALEntry HAL_Video_SetBlank
        HALEntry HAL_Video_SetPowerSave
        HALEntry HAL_Video_UpdatePointer
        HALEntry HAL_Video_SetDAG
        HALEntry HAL_Video_VetMode

        HALEntry HAL_MachineID

        HALEntry HAL_ControllerAddress
        HALEntry HAL_HardwareInfo
        HALEntry HAL_SuperIOInfo


HAL_Entries     * (.-HAL_EntryTable)/4

; R11 is used as pointer to RISC OS entry table throughout pre-MMU stage.
        MACRO
        CallOSM $entry, $reg
        LDR     ip, [v8, #$entry*4]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND

        MACRO
        CallOS  $entry
        ASSERT  $entry <= HighestOSEntry
        MOV     lr, pc
        LDR     pc, OSentries + 4*$entry
        MEND


start
        ADRL    R5, HAL_Base + 64*1024          ; R5 -> RISC OS image

        LDR     R11, [R5, #OSHdr_Entries]
        ADD     R11, R11, R5                    ; R11 -> RISC OS entry table

        MOV     R0, #0
        CallOSM OS_InitARM

        LDR     R13, =&10001000

        MOV     r12, #IOMD_Base

; Perform a dummy write to IOMD (some harmless register) to get it out of ROM force mode.
; Reads from IOMD will return garbage before this has happened. If we're actually running out
; of 32-bit wide ROMs on MORRIS, a write will already have happened, to get ROMCR0 from
; 16 to 32-bit wide mode, but we can't yet determine for sure (by reading it back), so do it
; anyway.

        STRB    r12, [r12, #IOMD_DMAREQ]              ; writes to DMAREQ are ignored

        LDRB    r2,[r12,#IOMD_ID1]	; load r2 with IOMD ID high byte
        LDRB    r0,[r12,#IOMD_ID0]	; load r0 with IOMD ID low byte
        ORR     r0,r0,r2, LSL #8	; Or r0 and r2 - shifted left 8, put in r0
        LDR     r2,=IOMD_7500		; get Ref IOMD ID code for IOMD in a 7500
        CMPS    r0,r2                   ; check for IOMD ID Code for IOMD in a 7500
	BEQ	init7500cpu		; If equal, got to init7500cpu

        LDRNE   r2,=IOMD_7500FE		; If not, get ID code for IOMD in a 7500FE
        CMPNES  r0,r2			; If not, check for IOMD ID Code for IOMD in a 7500FE
        BNE     MedusaInit              ; NOT MORRIS assume Medusa hardware


init7500FEcpu
; Here bceause its an ARM7500 'FE' variant
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-

;	CPUCLK divide by 1
;	MEMCLK divide by 2
;	IOCLK  divide by 2
;
        MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkHalf + IOMD_CLKCTL_IOclkHalf
        STRB    r0, [r12, #IOMD_CLKCTL] ; initialise all the prescalers.
;
; Set ROM speed, take care to preserve 16-bit mode bit, or all hell breaks loose...
;
        LDRB    r0, [r12, #IOMD_ROMCR0]         ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_3
        STRB    r0, [r12, #IOMD_ROMCR0]         ; Prog. the reg.s

; Program the 2nd ROM bank

        STRB	r0, [r12, #IOMD_ROMCR1]		; 2nd bank unused: program it the same anyway


; Now program ASTCR to add wait states, since MEMCLK is fast relative to IOCLK

	MOV	r0, #IOMD_ASTCR_WaitStates
	STRB	r0, [r12, #IOMD_ASTCR]

	B	init7500cpu_common		; branch to common init code.
;

init7500cpu
; Here because its an ARM7500 variant - NON 'FE' device.
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-
;	CPUCLK divide by 1
;	MEMCLK divide by 1
;	IOCLK  divide by 1
;
        MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkNormal + IOMD_CLKCTL_IOclkNormal
        STRB    r0, [r12, #IOMD_CLKCTL] ; initialise all prescalers to div1
;
; Set ROM speed, take care to preserve 16-bit mode bit, or all hell breaks loose...

        LDRB    r0, [r12, #IOMD_ROMCR0]          ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_3
        STRB    r0, [r12, #IOMD_ROMCR0]          ; Prog. the reg.s

; Program the 2nd ROM bank

        STRB	r0, [r12, #IOMD_ROMCR1]		; Program the 2nd bank the same as the 1st


; Now program ASTCR to *NOT* add wait states, since MEMCLK is slow relative to IOCLK

	MOV	r0, #IOMD_ASTCR_Minimal
	STRB	r0, [r12, #IOMD_ASTCR]

;
;
init7500cpu_common
; Common setup requirments for BOTH 7500 and 7500FE.
;
; MORRIS doesn't support VRAM. Kryten has same DRAM speed as Medusa
;
        MOV     r0, #IOMD_VREFCR_REF_16                         ; select 16µs refresh
        STRB    r0, [r12, #IOMD_VREFCR]

        MOV     r0, #IOMD_IOTCR_Network_TypeA :OR: IOMD_IOTCR_Combo_TypeB :OR: IOMD_IOTCR_Sound_TypeB :OR: IOMD_IOTCR_Sound_Word
        STRB    r0, [r12, #IOMD_IOTCR]

        MOV     r0, #0                          ; Podule manager wants TypeA setting by default for all podules
        STRB    r0, [r12, #IOMD_ECTCR]

        B       CommonInit

        LTORG

MedusaInit


        MOV     r0, #&12    ; 5-3 cycle ROM access

        STRB    r0, [r12, #IOMD_ROMCR0]
        STRB    r0, [r12, #IOMD_ROMCR1]         ; and do the same for extension ROMs (just in case)
        MOV     r0, #IOMD_VREFCR_VRAM_256Kx64 :OR: IOMD_VREFCR_REF_16   ; select 16µs refresh, assume 2 banks of VRAM
        STRB    r0, [r12, #IOMD_VREFCR]

        MOV     r0, #IOMD_IOTCR_Network_TypeA :OR: IOMD_IOTCR_Combo_TypeB :OR: IOMD_IOTCR_Sound_TypeB :OR: IOMD_IOTCR_Sound_Word
        STRB    r0, [r12, #IOMD_IOTCR]

        MOV     r0, #0                          ; Podule manager wants TypeA setting by default for all podules
        STRB    r0, [r12, #IOMD_ECTCR]

CommonInit

 [ {FALSE}
; Turn off VIDC (set power down bit in control register)

        MOV     R1, #VIDCPhys   ; Must ALWAYS initialise VIDC on reset or else
        MOV     R0, #1:SHL:14   ; we may get vsync interrupts that stiff us
        ORR     R0, R0, #&E0000000
        STR     R0, [R1]
 |
; VInit etc set on ze mode change: no DMA going yet so don't set owt.

        MOV     R1, #VIDCPhys   ; Must ALWAYS initialise VIDC on reset or else
        ADR     R2, VIDCTAB     ; we may get vsync interrupts that stiff us
10      LDR     R0, [R2], #4    ; permanently as VIDC is in an undefined state
        CMP     R0, #-1         ; so have mode 0 with all black palette
        STRNE   R0, [R1]
        BNE     %BT10

 ]

; Now bang IOC (disable all but keyboard interrupts)

        MOV     R1, #IOC
        MOV     R0, #&FF                ; all inputs
        STRB    R0, [R1, #IOCControl]   ; in case called by Tim

        MOV     R0, #0
        STRB    R0, [R1, #IOCIRQMSKA]   ; kein interrupts
        STRB    R0, [R1, #IOCFIQMSK]    ; knob off, FIQ
        STRB    R0, [R1, #IOMD_DMAMSK]  ; disable DMA interrupts, too
        STRB    R0, [R1, #IOMD_IRQMSKC] ; and the rest...
        STRB    R0, [R1, #IOMD_IRQMSKD]

  [ Keyboard_Type = "PC"
        MOV     R0, #serial_Rx_bit      ; used for Archi keyboard or IOMD PC keyboard
  ]
        STRB    R0, [R1, #IOCIRQMSKB]   ; allow communication with kbd, when I_bit gets cleared

; now bits to allow CMOS read/write : need timer

        LDR     R0, =20000-1    ; R0 = Timer delay (units of 0.5 microsecond)
                                ; 20000*0.5E-6 = 0.01 Seconds (100Hz ticker)
                                ; TMD 21-May-93: "-1" correction applied

        STRB    R0, [R1, #Timer0LL]     ; Set up the delay
        MOV     R0, R0, LSR #8
        STRB    R0, [R1, #Timer0LH]
        STRB    R0, [R1, #Timer0GO]     ; and start the ticks

        MOV     R0, #timer0_bit
        STRB    R0, [R1, #IOCIRQCLRA]   ; Clear pending t0 interrupt j.i.c.

  [ VCOstartfix
        ;2nd part of fix for VCO failing to start on A7000 (esp. 7500FE) - forcing PCOMP high for about 3 ms
        LDRB    R0, [R1,#IOMD_ID0]
        CMP     R0, #&E7
        LDREQB  R0, [R1,#IOMD_ID1]
        CMPEQ   R0, #&D4
        BEQ     vcofix_notMorris      ; risky to force PCOMP on Risc PC
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000342        ; VIDC20 FSYNREG, as in VIDCTAB but with force PCOMP high
        STR     R2, [R0]
        MOV     R0, #3072*2           ; time delay of about 3 ms (0.5 us units)
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R2, [R1, #Timer0CL]   ; R2 := low output latch
vcofix_waitloop
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R3, [R1, #Timer0CL]   ; R3 := low output latch
        TEQ     R3, R2                ; unchanged ?
        BEQ     vcofix_waitloop       ; then loop
        MOV     R2, R3                ; copy anyway
        SUBS    R0, R0, #1            ; decrement count
        BNE     vcofix_waitloop       ; loop if not finished
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000302        ; VIDC20 FSYNREG, as in VIDCTAB (PCOMP low again)
        STR     R2, [R0]
vcofix_notMorris
  ]

        MOV     R0, #0
        STRB    R0, [R1, #IOMD_ATODICR] ; power down the A to D convertor

; On breaks (ie software resets) we have to turn the MMU off.
; This is slightly tricky if we've been soft-loaded!


 [ {FALSE}
  ; Config for Dave's medusa
        MOV     R0, #4:SHL:8
        LDR     R1, =&10000000
        ADD     R2, R1, #&00400000
        LDR     R3, =&FFFFFFFF
        MOV     R12, #0
        STR     R12, [R13, #-4]!
        CallOSM OS_AddRAM
        STR     R0, [R13]

        MOV     R0, #4:SHL:8
        LDR     R1, =&14000000
        ADD     R2, R1, #&00400000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        STR     R0, [R13]

        MOV     R0, #4:SHL:8
        LDR     R1, =&1C000000
        ADD     R2, R1, #&00400000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        STR     R0, [R13]
  |
  ; The Risc PC (RAM from 10000000 - 11000000, ROM image at 10B00000-10F00000)
        MOV     R0, #4:SHL:8
        LDR     R1, =&10000000
        ADD     R2, R1, #&00B00000
        LDR     R3, =&FFFFFFFF
        MOV     R12, #0
        STR     R12, [R13, #-4]!
        CallOSM OS_AddRAM
        STR     R0, [R13]

        MOV     R0, #4:SHL:8
        LDR     R1, =&10F00000
        ADD     R2, R1, #&00100000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        STR     R0, [R13]

  ]

        LDR     R0, =4:SHL:8 + 1
        LDR     R1, =&02000000
        ADD     R2, R1, #&00200000
        LDR     R3, =&FFFFFFFF
        CallOSM OS_AddRAM
        ADD     R13, R13, #4

        MOV     R3, R0                  ; parameter for OS_Start

; Check the various reset flags

        MOV     R12, #IOC
        LDRB    R1, [R12, #IOCIRQSTAA]
        ANDS    R1, R1, #por_bit
        STRNEB  R1, [R12, #IOCIRQCLRA]  ; clear POR if set
        ORRNE   R0, R0, #OSStartFlag_POR

 [ CheckProtectionLink
        LDR     R2, =IOMD_MonitorType

; on Issue A's the protection bit is only weakly pulled up,
; so force it high, then read it back

        LDRB    R1, [R2]
        ORR     R1, R1, #IOMD_ProtectionLinkBit
        STRB    R1, [R2]
        LDRB    R1, [R2]
        TST     R1, #IOMD_ProtectionLinkBit
        ORRNE   R0, R0, #OSStartFlag_NoCMOSReset
 ]

 [ STB :LAND: IOMD_C_FrontPanelButton <> 0
  [ FrontPanelButtClearsCMOS
        LDRB    R1, [R12, #IOMD_CLINES] ; if front panel button pressed then CMOS reset
        TST     R1, #IOMD_C_FrontPanelButton
        ORRNE   R0, R0, #OSStartFlag_CMOSReset
  ]
 ]

        MOV     R1, R5
        ADR     R2, HALdescriptor
        CallOSM OS_Start

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data tables: VIDC := mode 0, all palette black

VIDCTAB DATA
; Program Control Register first, to clear power-down bit
; Now depending upon the VIDCClockSource flag, re-program the clock source.
   [ VIDCClockSource = "VCO"
     [ VCOstartfix
        & &E0000404     ; CR: FIFO load 16 words, 1 bpp, ck/2, vclk (allow for doubled VCO freq)
     |
        & &E0000400     ; CR: FIFO load 16 words, 1 bpp, ck/1, vclk
     ]
   ]
   [ VIDCClockSource = "HCLK"
        & &E0000401     ; CR: FIFO load 16 words, 1 bpp, ck/1, hclk
   ]
   [ VIDCClockSource = "RCLK"
        & &E0000406     ; CR: FIFO load 16 words, 1 bpp, ck/2, rclk
   ]

; Don't bother programming all 256 palette entries, we'll be here all night
; Since we're setting up a 1 bit-per-pixel mode, just do colours 0 and 1

        & &10000000     ; Palette address register = 0
        & &00000000     ; Colour 0 = black
        & &00000000     ; Colour 1 = black
        & &40000000     ; Border colour = black
        & &50000000     ; Pointer colour 1 = black
        & &60000000     ; Pointer colour 2 = black
        & &70000000     ; Pointer colour 3 = black

; Get a stable display up so we get stable signals

        & &800003F8     ; HCR  = 76 + 88 + 96 + 640 + 96 + 28
        & &81000044     ; HSWR = 76
        & &82000098     ; HBSR = 76 + 88
        & &830000F2     ; HDSR = 76 + 88 + 96
        & &84000372     ; HDER = 76 + 88 + 96 + 640
        & &850003D8     ; HBER = 76 + 88 + 96 + 640 + 96
        & &860000F3     ; HCSR = HDSR

        & &90000137     ; VCR  = 3 + 19 + 16 + 256 + 16 + 2
        & &91000002     ; VSWR = 3
        & &92000015     ; VBSR = 3 + 19
        & &93000025     ; VDSR = 3 + 19 + 16
 [ MEMC_Type = "IOMD"
        & &94000125     ; VDER = 3 + 19 + 16 + 256
 | ;MEMC_Type <> "IOMD"
        & &94000125     ; VDER = 3 + 19 + 16 + 256
 ] ;MEMC_Tupe = "IOMD"
        & &95000135     ; VBER = 3 + 19 + 16 + 256 + 16
        & &96000025     ; VCSR = VDSR
        & &97000025     ; VCER = VDSR

        & &B1000001     ; SCR: sound disabled (+use 24MHz clock)

        & &C00F1003     ; EREG = comp sync, DACs on, ereg output ext lut
   [ VCOstartfix
        & &D0000302     ; FSYNREG, clk = (3+1)/(2+1) * 24MHz = 32MHz  (higher frequency as part of fix)
   |
        & &D0000305     ; FSYNREG, clk = (3+1)/(5+1) * 24MHz = 16MHz
   ]
        & &F0013000     ; DCR: bus D[31:0], Hdisc       ;RCM 29/9/94: changed from &F0012000 at PSwindells request
        & &FFFFFFFF     ; That's the lot

IOPhys          *       &03000000
IOSize          *       &00800000

EASIPhys        *       &08000000
EASISlotSize    *       &01000000
EASISlotSizeShift *     24
EASISlots       *       8
EASISize        *       EASISlotSize * EASISlots

IOMDPhys        *       &03200000
VIDCPhys        *       &03400000       ; used to address VIDC when MMU is off

;--------------------------------------------------------------------------------------


HAL_Init
        Entry

        BL      SetUpOSEntries
        MOV     a1, #0
        MOV     a2, #IOPhys
        MOV     a3, #IOSize
        CallOS  OS_MapInIO
        STR     a1, IO_Address
        ADD     a2, a1, #IOMDPhys - IOPhys
        STR     a2, IOMD_Address
        ADD     a3, a1, #VIDCPhys - IOPhys
        STR     a3, VIDC_Address

        LDRB    a1, [a2, #IOMD_ID0]
        LDRB    a4, [a2, #IOMD_ID1]
        ORR     a1, a1, a4, LSL #8
        LDR     a4, =IOMD_Original
        TEQ     a1, a4
        MOVEQ   ip, #0                    ; assume Medusa
        MOVNE   ip, #IOST_7500            ; else assume Morris
        STRB    ip, IOSystemType

        MOV     a1, #0
        MOV     a2, #EASIPhys
        MOV     a3, #EASISize
        CallOS  OS_MapInIO
        STR     a1, EASI_Address

        BL      Video_init
        EXIT

; Initialise and relocate the entry table.
SetUpOSEntries  ROUT
        STR     a1, OSheader
        LDR     a2, [a1, #OSHdr_NumEntries]
        CMP     a2, #HighestOSEntry+1
        MOVHI   a2, #HighestOSEntry+1

        ADR     a3, OSentries
        LDR     a4, [a1, #OSHdr_Entries]
        ADD     a4, a4, a1

05      SUBS    a2, a2, #1
        LDR     ip, [a4, a2, LSL #2]
        ADD     ip, ip, a4
        STR     ip, [a3, a2, LSL #2]
        BNE     %BT05

        MOV     pc, lr


HAL_Null
        MOV     pc, lr

HAL_ControllerAddress
        MOV     a1, #0                  ; Default to "not fitted"
        AND     a3, a2, #&FF            ; Get sequence number.
        MOV     a2, a2, LSR #8          ; Get controller type.
        CMP     a2, #4
        ADDLS   pc, pc, a2, LSL #2
        MOV     pc, lr
        B       ca_EASIspeed
        B       ca_EASIspace
        MOV     pc, lr
        B       ca_VIDC20
        B       ca_IOMD

ca_EASIspeed
        LDR     ip, IOMD_Address
        CMP     a3, #EASISlots
        ADDLO   a1, ip, #IOMD_ECTCR
        MOV     pc, lr

ca_EASIspace
        LDR     ip, EASI_Address
        CMP     a3, #EASISlots
        ADDLO   a1, ip, a3, LSL #EASISlotSizeShift
        MOV     pc, lr

ca_VIDC20
        TEQ     a3, #0
        LDREQ   a1, VIDC_Address
        MOV     pc, lr

ca_IOMD
        TEQ     a3, #0
        LDREQ   a1, IOMD_Address
        MOV     pc, lr

HAL_HardwareInfo
        LDR     ip, =&01010101
        STR     ip, [a1]
        MOV     ip, #1
        STR     ip, [a2]
        MOV     ip, #0
        STR     ip, [a3]
        MOV     pc, lr

HAL_SuperIOInfo
        LDR     ip, =&00311111
        STR     ip, [a1]
        LDR     ip, =&00011100
        STR     ip, [a2]
        MOV     pc, lr


        LTORG

        END
