        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO
        GET     Hdr:DevNos

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET     hdr.StaticWS

        AREA    |Asm$$Code|, CODE, READONLY, PIC

NoInterrupt     * 38

        EXPORT  HAL_IRQSource
        EXPORT  HAL_IRQEnable
        EXPORT  HAL_IRQDisable
        EXPORT  HAL_IRQClear

HAL_IRQSource
        LDR     r3, IOMDa
        LDRB    r0, [r3, #IOMD_DMAREQ]
        TEQ     r0, #0
        ADRNE   r1, IrqDMADevnos
        LDREQB  r0, [r3, #IOCIRQREQB]   ; if not DMA then assume IRQB until we know otherwise
        ADREQ   r1, IrqReqBDevnos

        ADREQ   r12, DeviceTables       ; can't reach these tables with ADR

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOMD_IRQRQD]
        ADDEQ   r1, r12, #IrqReqDDevnos-DeviceTables

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOMD_IRQRQC]
        ADDEQ   r1, r12, #IrqReqCDevnos-DeviceTables

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOCIRQREQA]   ; not DMA and not IRQB so assume IRQA
        ADREQ   r1, IrqReqADevnos

        LDRB    r0, [r1, r0]            ; pick up offset in device despatcher
        MOV     pc, lr


; Following tables encode the priority of the devices within each register
;
DeviceTables


; Prioritised IOMD DMA device numbers

IrqDMAPrio0     * 1:SHL:5
IrqDMADev0      * IOMD_DMASound1_DevNo

IrqDMAPrio1     * 1:SHL:4
IrqDMADev1      * IOMD_DMASound0_DevNo

IrqDMAPrio2     * 1:SHL:3
IrqDMADev2      * IOMD_DMAChannel3_DevNo

IrqDMAPrio3     * 1:SHL:2
IrqDMADev3      * IOMD_DMAChannel2_DevNo

IrqDMAPrio4     * 1:SHL:1
IrqDMADev4      * IOMD_DMAChannel1_DevNo

IrqDMAPrio5     * 1:SHL:0
IrqDMADev5      * IOMD_DMAChannel0_DevNo


       GBLA  DTabC
DTabC  SETA 1

IrqDMADevnos
  = NoInterrupt*3

; Top 2 bits are always 0 so table need only be 64 bytes
  WHILE DTabC <64
  [ (DTabC:AND:IrqDMAPrio5)<>0
  = IrqDMADev5*3
  |
  [ (DTabC:AND:IrqDMAPrio4)<>0
  = IrqDMADev4*3
  |
  [ (DTabC:AND:IrqDMAPrio3)<>0
  = IrqDMADev3*3
  |
  [ (DTabC:AND:IrqDMAPrio2)<>0
  = IrqDMADev2*3
  |
  [ (DTabC:AND:IrqDMAPrio1)<>0
  = IrqDMADev1*3
  |
  [ (DTabC:AND:IrqDMAPrio0)<>0
  = IrqDMADev0*3
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND



; generic IRQA bits
IrqReqAPrio0 * por_bit
IrqReqADev0  * PowerOn_DevNo

IrqReqAPrio4 * timer1_bit
IrqReqADev4 * Timer1_DevNo

IrqReqAPrio5 * vsync_bit
IrqReqADev5 * VSync_DevNo

IrqReqAPrio6 * timer0_bit
IrqReqADev6 * Timer0_DevNo

IrqReqAPrio7 * force_bit
IrqReqADev7 * FIQDowngrade_DevNo

; Machine specific IRQB bits (devices 0-2)

IrqReqAPrio1 * 1:SHL:1          ; not used
IrqReqADev1 * 1

 [ ReassignedIOMDInterrupts
 ASSERT IOMDr_PrinterIRQ_DevNo = 2

IrqReqAPrio2 * IOMDr_printer_IRQ_bit
IrqReqADev2 * IOMDr_PrinterIRQ_DevNo

IrqReqAPrio3 * 1:SHL:0          ; not used
IrqReqADev3 * 0
 |
 ASSERT IOMD_PrinterIRQ_DevNo = 0
 ASSERT IOMD_FloppyIndex_DevNo = 2

IrqReqAPrio2 * IOMD_printer_IRQ_bit
IrqReqADev2 * IOMD_PrinterIRQ_DevNo

IrqReqAPrio3 * IOMD_floppy_index_bit
IrqReqADev3 * IOMD_FloppyIndex_DevNo
 ]


DTabC  SETA 1

IrqReqADevnos
  =  NoInterrupt*3
  WHILE DTabC <256
  [ (DTabC:AND:IrqReqAPrio7)<>0
  = IrqReqADev7*3
  |
  [ (DTabC:AND:IrqReqAPrio6)<>0
  = IrqReqADev6*3
  |
  [ (DTabC:AND:IrqReqAPrio5)<>0
  = IrqReqADev5*3
  |
  [ (DTabC:AND:IrqReqAPrio4)<>0
  = IrqReqADev4*3
  |
  [ (DTabC:AND:IrqReqAPrio3)<>0
  = IrqReqADev3*3
  |
  [ (DTabC:AND:IrqReqAPrio2)<>0
  = IrqReqADev2*3
  |
  [ (DTabC:AND:IrqReqAPrio1)<>0
  = IrqReqADev1*3
  |
  [ (DTabC:AND:IrqReqAPrio0)<>0
  = IrqReqADev0*3
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND


; generic IRQB bits
IrqReqBPrio2 * podule_FIQ_as_IRQ_bit
IrqReqBDev2  * PFIQasIRQ_DevNo

IrqReqBPrio3 * serial_Tx_bit
IrqReqBDev3 * SerialTx_DevNo

IrqReqBPrio4 * serial_Rx_bit
IrqReqBDev4 * SerialRx_DevNo

IrqReqBPrio5 * podule_IRQ_bit
IrqReqBDev5 * Podule_DevNo

; Machine specific IRQB bits

 [ ReassignedIOMDInterrupts
IrqReqBPrio0 * IOMDr_MPEGAudio_IRQ_bit
IrqReqBDev0 * IOMDr_MPEGAudio_DevNo

IrqReqBPrio1 * IOMDr_MPEGVideo_IRQ_bit
IrqReqBDev1 * IOMDr_MPEGVideo_DevNo

IrqReqBPrio6 * IOMDr_Network_IRQ_bit
IrqReqBDev6 * IOMDr_Network_DevNo

IrqReqBPrio7 * IOMDr_serial_IRQ_bit
IrqReqBDev7 * IOMDr_Serial_DevNo
 |
IrqReqBPrio0 * IOMD_floppy_IRQ_bit
IrqReqBDev0 * DiscChanged_DevNo

IrqReqBPrio1 * IOMD_HardDisc_IRQ_bit
IrqReqBDev1 * Sound_DevNo

IrqReqBPrio6 * IOMD_Network_IRQ_bit
IrqReqBDev6 * WinnieIRQ_DevNo

IrqReqBPrio7 * IOMD_serial_IRQ_bit
IrqReqBDev7 * IOMD_Serial_DevNo
 ]


DTabC  SETA 1

IrqReqBDevnos
  =  NoInterrupt*3

  WHILE DTabC <256
  [ (DTabC:AND:IrqReqBPrio7)<>0
  = IrqReqBDev7*3
  |
  [ (DTabC:AND:IrqReqBPrio6)<>0
  = IrqReqBDev6*3
  |
  [ (DTabC:AND:IrqReqBPrio5)<>0
  = IrqReqBDev5*3
  |
  [ (DTabC:AND:IrqReqBPrio4)<>0
  = IrqReqBDev4*3
  |
  [ (DTabC:AND:IrqReqBPrio3)<>0
  = IrqReqBDev3*3
  |
  [ (DTabC:AND:IrqReqBPrio2)<>0
  = IrqReqBDev2*3
  |
  [ (DTabC:AND:IrqReqBPrio1)<>0
  = IrqReqBDev1*3
  |
  [ (DTabC:AND:IrqReqBPrio0)<>0
  = IrqReqBDev0*3
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND


; Prioritised IRQD device numbers

IrqReqDPrio0     * 1:SHL:4
IrqReqDDev0      * IOMD_Event2_DevNo

IrqReqDPrio1     * 1:SHL:3
IrqReqDDev1      * IOMD_Event1_DevNo

IrqReqDPrio2     * 1:SHL:2
IrqReqDDev2      * IOMD_AtoD_DevNo

IrqReqDPrio3     * 1:SHL:1
IrqReqDDev3      * IOMD_MouseTxEmpty_DevNo

IrqReqDPrio4     * 1:SHL:0
IrqReqDDev4      * IOMD_MouseRxFull_DevNo


DTabC  SETA 1

IrqReqDDevnos
  =  NoInterrupt*3

; Top 3 bits are always 0 so table need only be 32 bytes (this will
; need to change if bits 5 to 7 are ever used).
  WHILE DTabC <32
  [ (DTabC:AND:IrqReqDPrio4)<>0
  = IrqReqDDev4*3
  |
  [ (DTabC:AND:IrqReqDPrio3)<>0
  = IrqReqDDev3*3
  |
  [ (DTabC:AND:IrqReqDPrio2)<>0
  = IrqReqDDev2*3
  |
  [ (DTabC:AND:IrqReqDPrio1)<>0
  = IrqReqDDev1*3
  |
  [ (DTabC:AND:IrqReqDPrio0)<>0
  = IrqReqDDev0*3
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND

; Prioritised IRQC device numbers. We have to handle ALL interrupts
; using specific device numbers as we don't know what the IO pins
; are connected to and the NOIRQ code has to know what bit to clear
; when an unknown interrupt is triggered.

IrqReqCPrio0    * 1:SHL:0
IrqReqCDev0     * IOMD_C_Bit0_DevNo

IrqReqCPrio1    * 1:SHL:1
IrqReqCDev1     * IOMD_C_Bit1_DevNo

IrqReqCPrio2    * 1:SHL:2
IrqReqCDev2     * IOMD_C_Bit2_DevNo

IrqReqCPrio3    * 1:SHL:3
IrqReqCDev3     * IOMD_C_Bit3_DevNo

IrqReqCPrio4    * 1:SHL:4
IrqReqCDev4     * IOMD_C_Bit4_DevNo

IrqReqCPrio5    * 1:SHL:5
IrqReqCDev5     * IOMD_C_Bit5_DevNo

IrqReqCPrio6    * 1:SHL:6
IrqReqCDev6     * IOMD_C_Bit6_DevNo

IrqReqCPrio7    * 1:SHL:7
IrqReqCDev7     * IOMD_C_Bit7_DevNo


DTabC   SETA 1

IrqReqCDevnos
  =  NoInterrupt*3

  WHILE DTabC <256
  [ (DTabC:AND:IrqReqCPrio7)<>0
  = IrqReqCDev7*3
  |
  [ (DTabC:AND:IrqReqCPrio6)<>0
  = IrqReqCDev6*3
  |
  [ (DTabC:AND:IrqReqCPrio5)<>0
  = IrqReqCDev5*3
  |
  [ (DTabC:AND:IrqReqCPrio4)<>0
  = IrqReqCDev4*3
  |
  [ (DTabC:AND:IrqReqCPrio3)<>0
  = IrqReqCDev3*3
  |
  [ (DTabC:AND:IrqReqCPrio2)<>0
  = IrqReqCDev2*3
  |
  [ (DTabC:AND:IrqReqCPrio1)<>0
  = IrqReqCDev1*3
  |
  [ (DTabC:AND:IrqReqCPrio0)<>0
  = IrqReqCDev0*3
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND

; In: a1 = device no.
; Out: a1 = bit number within register, ip = register offset
        MACRO
        DevNoToRegAndBit $type
        MOV     ip, #IOMD_IRQSTC + (IOCIRQ$type.A - IOCIRQSTAA)
        SUBS    a1, a1, #30
        MOVMI   ip, #IOMD_IRQSTD + (IOCIRQ$type.A - IOCIRQSTAA)
        ADDMIS  a1, a1, #8
        MOVMI   ip, #IOMD_DMASTA + (IOCIRQ$type.A - IOCIRQSTAA)
        ADDMIS  a1, a1, #6
        MOVMI   ip, #IOCIRQSTAB + (IOCIRQ$type.A - IOCIRQSTAA)
        ADDMIS  a1, a1, #8
        MOVMI   ip, #IOCIRQSTAA + (IOCIRQ$type.A - IOCIRQSTAA)
        ADDMI   a1, a1, #8
        MEND

; In: a1 = bit number within register, ip = register offset
; Out: a1-a4 corrupt
        MACRO
        ModifyBit $op
        MRS     a4, CPSR
        MOV     a2, #1
        ADD     ip, a3, ip
        MOV     a1, a2, LSL a1
        ORR     a3, a4, #F32_bit+I32_bit
        MSR     CPSR_c, a3
        LDRB    a2, [ip]
        $op     a2, a2, a1
        STRB    a2, [ip]
        MSR     CPSR_c, a4
        MEND

HAL_IRQEnable
        LDR     a3, IOMDa
        DevNoToRegAndBit MSK
        ModifyBit ORR
        MOV     pc, lr

HAL_IRQDisable
        LDR     a3, IOMDa
        DevNoToRegAndBit MSK
        ModifyBit BIC
        MOV     pc, lr

HAL_IRQClear
        LDR     a3, IOMDa
        MOV     a2, #1
        DevNoToRegAndBit CLR
        MOV     a2, a2, LSL a1
        STRB    a2, [a3, ip]
        MOV     pc, lr

HAL_IRQStatus
        LDR     a3, IOMDa
        DevNoToRegAndBit STA
        LDRB    a2, [a3, ip]
        MOV     a2, a2, LSR a1
        AND     a2, a2, #1
        MOV     pc, lr

        END
