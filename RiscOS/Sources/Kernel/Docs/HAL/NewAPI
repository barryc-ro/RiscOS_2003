Overview
========

The HAL introduces the new concept of a "device". A device is a logical
representation of a component of hardware. Each active devices is uniquely
identified by a constant pointer to a device descriptor. The descriptor is
a structure which contains information about the device and a series of entry
points to perform usually simple operations on the device. Devices can be
provided by the Bootloader, or by RISC OS modules.

Devices provided outside the Bootloader are, in principle, hot swappable,
although it is up to device drivers using it whether they can support this.

Throughout this document, device descriptors are described in terms of C,
although the scheme maps naturally to assembler or C++. All device calls use
the base ATPCS calling standard (R0-R3 arguments/return values, R4-R11
preserved, R12 corrupted), to permit straightforward use from C or assembler.

From C:
        XXXDevice->Activate(XXXDevice);

A simple call to a activate a device from assembler might look like:

        LDR    R0, XXXDevice
        MOV    LR, PC
        LDR    PC, [R0, #DevEntry_Activate]      ; R0-R3,R12 corrupted

If an assembler device driver module is using a lot of device calls, it
might be preferable to move the workspace pointer from the traditional R12
to R11.
       

The device descriptor
=====================

The device descriptor starts with a fixed format header, as described
below. Following this header are more function pointers providing device-specific
calls.

struct device
{
    uint16_t type;
    uint16_t id;
    uint32_t location;
    uint32_t version;
    const char *description;
    void *address;
    uint32_t reserved[3];
    int (*Activate)(struct peripheral *);
    void (*Deactivate)(struct peripheral *)
    void (*Reset)(struct peripheral *);
    int (*Sleep)(struct peripheral *, state);
    int (*Claim)(struct peripheral *, int intno, myfunc, handle);
    void (*Release)(struct peripheral *, int intno, myfunc, handle);
    uint32_t reserved[2];

};


struct serial
{
    struct device dev;
    int (*ReadByte)(struct serial *);
    void (*WriteByte)(struct serial *, int c);

    // private data
}

Hence, the first device specific function pointer is offset 32 bytes from the
device pointer.

Type
----
The type word describes what the device is. It is grouped into sub-words as follows:

   Bits 31-24: Top level type (eg video, sound, system peripheral, comms port)
   Bits 23-16: Second level type (eg VDU display, 16-bit PCM sound output,
               interrupt controller, UART).
   Bits 15-0:  Product code - a unique identifier for this particular device.

A device driver will normally search for devices with a specific value in bits 31-16,
and not care about bits 15-0. Bits 31-16, together with the version number, indicate
which device specific calls are available.

Location
--------
The location describes the location of the device in terms of the bus architecture
of the computer. Again, it is grouped by bytes.

   Bits 31-24: Bus type
                     0 => processor (0 = core, 1 = coprocessor)
                     1 => main system bus (0 = AHB, 1 = ASB)
                     2 => peripheral bus (0 = APB)
                     3 => expansion bus (0 = Acorn Expansion Card, 1 = ISA, 2 = PCI)
   Bits 23-16: Bus
   Bits 15-8:  Card number (PCI, expansion card etc) / chip select number
   Bits 7-0:   Unit number

Version
-------
The version describes the version of the device API implemented. It consists of a
major version number (bits 31-16) and a minor version number (bits 15-0). A change in
major version number indicates an incompatible change of API. An increase in the
minor version number indicates backwards-compatible extensions to the API (eg
extra functions).

Description
-----------
A textual description of the device. This should be English, human-readable and
Basic Latin (characters &20-&7E). Descriptors along the lines of those output by
*Podules are expected. For example:

           National Semiconductor 16C550 UART
           Cirrus Logic CL92xx interrupt controller
           Acorn IOMD21 PS/2 keyboard
           Acorn VIDC20
           Intel SA-1110 DMA controller

Address
-------
This field may either be 0, or may be a pointer to the base address of the
memory-mapped registers of the device in question. Drivers should not
normally use this field to directly poke the device. If they do, they must be
absolutely certain that there is no other way to achieve the effect, and that
the device type word is known to them. What exactly the address points to
depends on the exact device in question.

Activate
--------
A device driver must call the Activate entry point before using a device. A
success/failure indication is returned: 0 indicates successful activation, -1 indicates
unsuccessful. Devices may ignore activate/deactivate calls, count them, or
may alternatively provide full locking to allow only one activation. Typically this
would be called by in a driver's module initialisation routine. Alternatively, it might
be called just before a DeviceFS device is opened for access.

Deactivate
----------
A device driver must call the Deactivate entry point when it has finished
using a device.

Reset
-----
The Kernel will call the Reset entry point of every device on the system
before performing a software reset (eg OS_Reset or Ctrl-Break), after it has
issued Service_PreReset. All devices must enter a quiescent state.

Claim
-----
Claim is a front-end to OS_ClaimDeviceVector. The device should set up interrupt
parameters appropriately for the interrupt in question, and call OS_ClaimDeviceVector.




Creation and removal of devices
===============================

Devices are declared by calling the HAL->OS call OS_AddDevice or SWI OS_Hardware 2.

SWI OS_Hardware 2 (SWI &7A)
---------------------------
On entry: R0 -> device descriptor
          R8 = 2
On exit:  All registers preserved

void OS_AddDevice(device *d);

Declare a new device to the system.

Devices are removed by calling OS_Hardware 3. There is no HAL->OS equivalent.

SWI OS_Hardware 3 (SWI &7A)
---------------------------
On entry: R0 -> device descriptor
          R8 = 3
On exit:  All registers preserved

The Kernel tracks all present devices, issuing service calls as devices come and go, and
providing a call to enumerate devices of a particular type.

SWI OS_Hardware 4 (SWI &7A)
---------------------------
On entry: R0 = type
          R8 = 4
On exit:


