Initialisation
==============

HAL_Init(unsigned int *riscos_header)

   Will be called after the MMU is turned on, before any other entries points.
   The HAL workspace will be filled with zeroes.


Interrupts
==========

The HAL must provide the ability to identify, prioritise and mask IRQs, and the ability
to mask FIQs. RISC OS supplies the ARM's processor vectors, and on an IRQ calls the HAL
to request the identity of the highest priority interrupt.

IRQ and FIQ device numbers are arbitrary, varying from system to system. They should be
arranged to allow quick mappings to and from hardware registers, and should ideally
be packed, starting at 0.

HAL_IRQEnable
HAL_IRQDisable
HAL_IRQClear
HAL_IRQSource (get highest priority asserted IRQ)

HAL_FIQEnable
HAL_FIQDisable
HAL_FIQClear



Timers
======

The HAL must supply at least one timer capable of generating periodic
interrupts. Each timer should generate a separate logical interrupt, and the
interrupt must be latched. The timers must either be variable rate (period is
a multiple of a basic granularity), or be fixed rate (period = 1*granularity).
Optionally, the timer should be capable of reporting the time until the
next interrupt, in units of the granularity.

int HAL_Timers(void)

  Returns number of timers. Timers are numbered from 0 upwards. Timer 0
  must exist.

int HAL_TimerDevice(int timer)

  Returns device number of timer n

unsigned int HAL_TimerGranularity(int timer)

  Returns basic granularity of timer n in ticks per second.

unsigned int HAL_TimerMaxPeriod(int timer)

  Returns maximum period of the timer, in units of Granularity. Will be 1
  for a fixed rate timer.

void HAL_TimerSetPeriod(int timer, unsigned int period)

  Sets period of timer n. If period > 0, the timer will generate interrupts every
  (period / granularity) seconds. If period = 0, the timer may be stopped.
  This may not be possible on some hardware, so the corresponding interrupt
  should be masked in addition to calling this function with period 0.
  If period > maxperiod, behaviour is undefined.

unsigned int HAL_TimerPeriod(int timer)

  Reads period of timer n. This should be the actual period in use by the
  hardware, so if for example period 0 was requested and impossible, the
  actual current period should be reported.

unsigned int HAL_TimerReadCountdown(int timer)

  Returns the time until the next interrupt in units of granularity, rounded down.
  If not available, 0 is returned.

Counter
=======

The HAL must supply a counter that varies rapidly, appropriate for use for
sub-millisecond timing. On many systems, this counter will form part of
timer 0 - as such it is not required to operate when timer 0 is not running.
On other systems, the periodic timers may have no readable latch, and a
separate unit will be required.

The counter should count down from (period-1) to 0 continuously.

unsigned int HAL_CounterRate(void)

  Returns the rate of the counter in ticks per second. Typically will
  equal HAL_TimerGranularity(0).

unsigned int HAL_CounterPeriod(void)

  Returns the period of the counter, in ticks. Typically will equal
  HAL_TimerPeriod(0).

unsigned int HAL_CounterRead(void)

  Reads the current counter value. Typically will equal
  HAL_TimerReadCountdown(0).

unsigned void HAL_CounterDelay(unsigned int microseconds)

  Delay for at least the specified number of microseconds.


Non-volatile memory
===================

The HAL should provide at least 240 bytes of non-volatile memory. If no
non-volatile memory is available, the HAL may provide fake NVRAM contents
suitable for RISC OS - however, it is preferable that the HAL just state that
NVRAM is not available, and RISC OS will act as though a CMOS reset has been
performed every reset.

NVRAM is typically implemented as an IIC device, so the calls are permitted
to be slow, and to enable interrupts. The HAL is not expected to cache
contents.

If the HAL has no particular knowledge of NVMemory, then it may
just say that "NVMemory is on IIC", and the OS will probe for CMOS/EEPROM
devices on the IIC bus.

unsigned int HAL_NVMemoryType(void)

  Returns a flags word describing the NVMemory
        bits 0-7: 0 => no NVMemory available
                  1 => NVMemory may be available on the IIC bus
                  2 => NVMemory is available on the IIC bus, and the
                       device characteristics are known
                  3 => the HAL provides NVMemory access calls.
        bit 8:    NVMemory has a protected region at the end
        bit 9:    Protected region is software deprotectable
        bit 10:   Memory locations 0-15 are readable
        bit 11:   Memory locations 0-15 are writeable

  If bits 0-7 are 0 or 1 no other NVMemory calls need be available,
  and bits 8-31 should be zero.

  If bits 0-7 are 2, Size, ProtectedSize, Protection and IICAddress calls must
  be available.

  If bits 0-7 are 3, all calls except IICAddress must be available.

unsigned int HAL_NVMemorySize(void)

  Returns the number of bytes of non-volatile memory available. Bytes 0-15
  should be included in the count, so for example a Philips PCF8583
  CMOS/RTC device (as used in the Archimedes and Risc PC) would be described
  as a 256-byte device, with locations 0-15 not readable. More complex
  arrangements would have to be abstracted out by the HAL providing its own
  NVMemory access calls.

  This is to suit the current RISC OS Kernel, which does not use bytes 0-15.

unsigned int HAL_NVMemoryProtectedSize(void)

  Returns the number of bytes of NVMemory that are protected. These should
  be at the top of the address space. The OS will not attempt to write
  to those locations without first requesting deprotection (if available).
  Returns 0 if bit 8 of the flags is clear.

void HAL_NVMemoryProtection(bool)

  Enables (if true) or disables if (false) the protection of the software
  protectable region. Does nothing if bits 8 and 9 not both set.

unsigned int HAL_NVMemoryIICAddress(void)

  Returns a word describing the addressing scheme of the NVRAM.
        bits 0-7: IIC address

int HAL_NVMemoryRead(unsigned int addr, void *buffer, unsigned int n)

  Reads n bytes of memory from address addr onwards into the buffer supplied.
  Returns the number of bytes successfully read. Under all normal circumstances
  the return value will be n - if it is not, a hardware failure is implied.
  Behaviour is undefined if the address range specified is outside the NVMemory,
  or inside bytes 0-15, if declared unavailable.

int HAL_NVMemoryWrite(unsigned int addr, void *buffer, unsigned int n)

  Write n bytes of memory into address addr onwards from the buffer supplied.
  Returns the number of bytes successfully written. Under all normal circumstances
  the return value will be n - if it is not, a hardware failure is implied.
  Behaviour is undefined if the address range specified is outside the NVMemory.
  Writes inside the a protected region should be ignored.

I²C bus
=======

Many hardware designs have an I²C bus. Often, it is used only to place non-
volatile memory on, but in other systems TV tuners, TV modulators,
microcontrollers, and arbitrary expansion cards may be fitted.

Low-level and high level APIs are defined. An arbitrary number of buses are
supported, and each can be controlled by either the low or high level API.
The OS should normally only use one fixed API on each bus - mixing APIs may
not have good results.

The low-level API requires the OS to control the two lines of the bus
directly. The high-level API currently covers version 2.1 of the I²C
protocol, and allows high-level transactions to be performed.

It is expected that a HAL will always provide the low-level API on each
bus, where possible in hardware. Using this, the OS can provide Fast mode
single or multi-master operation. The HAL may wish to provide the high-level API
where a dedicated I²C port with hardware assistance is available; this will
further permit High-speed and slave operation.

As it is possible that some HAL APIs (eg NVMemory), although abstracted at
this API layer, are still actually an I²C device, a matching set of high-level
I²C calls are provided in the OS. These give the HAL access to the OS I²C engine,
which will make low-level HAL calls. This saves the HAL from implementing the
full I²C protocol. To illustrate this diagramatically:

    +----------+ NVMem_Read +------------+  NVMemoryRead  +------------+
    |          | ---------> |            | ------------>  |            |
    |   App    |            |     OS     |  IICTransmit   |    HAL     |
    |          |            |            | <------------  |            |
    |          |            |            |  IICSetLines   |            |
    |          |            |            | ------------>  |            |
    +----------+            +------------+                +------------+

int HAL_IICBuses(void)

  Returns the number of IIC buses on the system.

unsigned int HAL_IICType(int bus)

  Returns a flag word describing the specified IIC bus.
        bit 0: Bus supplies the low-level API
        bit 1: Bus supplies the high-level API
        bit 2: High-level API supports multi-master operation
        bit 3: High-level API supports slave operation
       bit 16: Bus supports Fast (400kbps) operation
       bit 17: Bus supports High-speed (3.4Mbps) operation
   bits 20-31: Version number of I²C supported by high-level API, * 100.

Low level API
-------------

The low-level calls should be instantaneous. Interrupt status may not be altered.

The following structure is used:

   typedef struct { int SDA, SCL } IICLines;

Note the "__value_in_regs" keyword, which signifies that the binary ABI expects
SDA and SCL to be returned in registers a1 and a2.

__value_in_regs IICLines HAL_IICSetLines(int bus, IICLines lines)

  Sets the SDA and SCL lines on the specified bus. A 0 value represents
  logic LOW, 1 logic HIGH. The function then reads back and returns
  the values present on the bus, to permit arbitration.

__value_in_regs IICLines HAL_IICReadLines(int bus);

  Reads the state of the IIC lines on the specified bus, without changing
  their state.

High level API
--------------

To be defined.

Machine ID
==========

unsigned int64 HAL_MachineID(void)

  Returns a 64-bit unique machine identifier. What does it mean?
