; > Module
; Source for SoakTest module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 10-Mar-95  TMD  0.01		Started
; 14-Mar-95  TMD  0.02		Added audio stuff
; 17-Mar-95  TMD  0.03		Added checks for joystick hardware
; 27-Mar-95  TMD  0.04		Added parallel bootstrap
; 27-Mar-95  TMD  0.05		Dummy version to maintain consistency with SrcFiler
; 28-Mar-95  TMD  0.06		Turn on SCART signals using MPEGVideo_CardControl for now (until State module appears)
; 20-Apr-95  TMD  0.07		(Conditionally) use STBState module to disable watchdog timer reset and turn on SCART
; 05-Jun-95  TMD  0.08		Do variant for Roadster - ie no MPEG hardware
; 06-Jul-95  JRH  0.09          Combined MPEG and non-MPEG versions. Does MPEG soaktest iff pod 0 is of type STB2_MPEG1
; 10-Jun-95  JRH  0.10          Got rid of redundant Audio control structure. Uses PAL or NTSC screen mode depending
;                               on link bit. Does non-MPEG soaktest also in interlaced (PAL or NTSC) mode.
; 17-Jun-95  JRH  0.11          Oops, omitted the NTSC flag in VideoStructureNTSC. NTSC MPEG variant works properly now.
; 24-Jun-95  JRH  0.12          (Conditionally) use STBState module to flash LEDs. Now beeps every 2 secs on non-MPEG.
;                               (Conditionally) no longer poke IOMD_CLINES since STBState module does this
; 30-May-96  BAR  0.13		Update for NC. Add conditional (IOMD_C_FrontPanelLED = (1<<7)) calls to toggle the LED
;				status. Conditionally (IOMD_C_JoystickDetectBits <> 0) check for SoakTest dongle.
;				Change BoxType to conditionally (IOMD_C_PALNTSCType = (1<<4)) check the H/W for the
;				NTSC/PAl flag. HDR:GetAll, updated : IOMD_C_PALNTSCType = (1<<4) used to condionally
;				set up a string to get the toggle led file.
; 25-Jun-96  BAR  0.14		Add code to respond to smart card chatter, so it can check for the reqd. smart card
;				and act as reqd.
; 05-Aug-96  BAR		Tidy up & complete.
; 15-Aug-96  BAR  0.15          Improve mode selection code, now select NTSC and PAL by mode specifiers rather than
;                               by mode number. Moan if mode cannot be selected.
; 22-Aug-96  BAR		Finalise changes for the above, add new colour translation table, ensure green led
;				on at end, ensure screen cursor turned off. Ensure can plot sprite.
; 27-Aug-96  BAR  0.16		Update to ensure old mode operation still works. Ensure MPEG will still work.
;				Make object code as small as possible, by switching in only reqd. code. Hdr.getall
;				updated to use {MACHINE} variable to specify how to build the module and create
;				seperate executables.
; 28-Aug-96			Improve methods of defining the screen modes in use.
;				Smart Card and Joystic support are compiler switchable options.
; 30-Aug-96 BAR   0.17		Further code reduction process.
; 05-Sep-96 BAR   0.18		Remove debugging code left in MPEG stuff.
; 06-Sep-96 BAR	  0.19		Correct bug in module init code, rtn duff info, thus crashing serive handler
; 17-Sep-96 BAR   0.20		Make smart card code work ! Not enough 'entry' points, size of data is always
;				4 bytes ! Didn't check plip if smart card inserted, 'cos soak code exited !
;				Add calls to check for smart card to mosule init code. Needed 'cos ethernet
;				nc's will not exit looking for a server, thus soaktest module won't kick in.
; 20-Sep-96 			Sorted out the entry..exits to match.

        LEADR   Module_LoadAddr


NCRegistry_Enquiry	EQU	&4d382				; DEFINE SWI names ! REMOVE REMOVE
XNCRegistry_Enquiry	EQU	&6D382				; DEFINE SWI names ! REMOVE REMOVE

TAB     *       9
LF      *       10
FF      *       12
CR      *       13

; Values to write to ARM7500 IOLINES register to control LEDs

LEDs_RedNotGreen	*	2_11111011	; bit 1 high, bit 2 low, other bits 1 so inputs
LEDs_GreenNotRed	*	2_11111101	; bit 1 low, bit 2 high, other bits 1 so inputs

; Timeouts for parallel port bootstrap

Timeout_BGET		*	300		; go back to start of protocol if BGET takes longer than this

; Header string from parallel port

			GBLS	PTHeader
PTHeader		SETS	"ProdTest"

; Module workspace

                        ^       0, wp
EASISpaceAddress	#	4

 [ IncludeMPEGCode
VideoPacketInUse	#	4
VideoStreamHandle	#	4
VideoPacketDescriptor	#	PacketDescriptorSize	; video packet descriptor
AudioPacketInUse	#	4
AudioStreamHandle	#	4
AudioPacketDescriptor	#	PacketDescriptorSize	; audio packet descriptor
 ]

StackPtr		#	4			; flat stack ptr inside bootstrap

PoduleBuffer      	#       16      		; podule header

 [ international
MessageFile_Block #     16
MessageFile_Open  #     4
 ]



Module_WorkspaceSize * :INDEX: @

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
        &       0				; SWI base
        &       0				; SWI handler
        &       0				; SWI table
        &       0                               ; no swi name decode entry

Mod_Title
        =       "SoakTest", 0

Mod_HelpStr
        =       "SoakTest", TAB, "0.20 (20-Sep-96)", 0
        ALIGN

Mod_HC_Table
        Command SoakTest, 0, 0
	Command Bootstrap, 0, 0
        =       0

SoakTest_Help
	=	"*SoakTest performs a soak test", CR

SoakTest_Syntax
        =       "Syntax: *SoakTest", 0

Bootstrap_Help
	=	"*Bootstrap performs a parallel port bootstrap", CR
Bootstrap_Syntax
	=	"Syntax: *Bootstrap", 0
        ALIGN

; **************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry
        LDR     r2, [r12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die

 [ SmartCardSupported
	; Ethernet NC's won't pass looking for a server, thus won't see the smart card !
	; So check for the smart card on init.
	BL	CheckForSmartCard		; On an NC we use the smart card.
;	DREG	r0,"exit check for smart card at init, r0 = ",cc
;	DLINE	"garbige"
	CMP	r0, #2				; is r0 = 2 ? : BootStrap Smart Card
	BLEQ    BootstrapWPEntry
	CMP	r0, #1				; is r0 = 1 ? : SoakTest Smart Card
	BLEQ	SoakTestWPEntry
 ]


05
        MOV     r12, r2

; nothing else to do here now

;	DLINE	"Exiting #3 "
;	DREG	r13,"R13 = ",cc
;	DREG	r14,"R14 = ",cc
;	DREG	r15,"R15 = ",cc

        CLRV
        EXIT

; **************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die * Module_BaseAddr	; nothing to do yet

; **************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

 [ SmartCardSupported
Service_SmartCardRegistryCalled *	&BA		; Could be changed if assigned a global name.
 ]

Mod_Service ROUT
	TEQ	r1, #Service_PostInit			; Was it a post init service call ?
 [ SmartCardSupported
	TEQNE	r1, #Service_SmartCardRegistryCalled	; Was it a smart card registry call ?
 ]
	MOVNE	pc, lr					; Not a service call we want - exit

; Ok, we want the service call ... handle it
	LDR     wp, [r12]
	Entry   "r0-r6"
; Check which service call and jump as reqd.
 [ SmartCardSupported
	TEQ	r1, #Service_SmartCardRegistryCalled	; Was it a smart card registry call ?
;	DLINE 	"Smart card - checking smc type ...."
	BLEQ	CheckForSmartCard			; Yes : Jump to smart card code.
 ]
 [ JoysticksSupported
	TEQNE	r1, #Service_PostInit			; Was it a post init service call ?
	BLEQ	CheckForSoakConnector			; Yes : Jump to Joystick code.
 ]
	CMP	r0, #2					; is r0 = 2 ? : BootStrap Smart Card
	BEQ	dobootstrap
	CMP	r0, #1					; is r0 = 1 ? : SoakTest Smart Card
	BEQ	dosoaktest

;	DLINE	"Exiting #1 "
;	DREG	r13,"R13 = ",cc
;	DREG	r14,"R14 = ",cc
;	DREG	r15,"R15 = ",cc
	EXIT

;	DLINE	"Exiting module (aaa) "
;	MOVNE	pc, lr					; Not a service call we want - exit

; do soak test

dosoaktest
	BL	SoakTestWPEntry
	EXIT

; do parallel port bootstrap

dobootstrap
        BL      BootstrapWPEntry
;	DLINE	"Exiting module ??? "
;	DREG	r13,"R13 = ",cc
;	DREG	r14,"R14 = ",cc
;	DREG	r15,"R15 = ",cc
	EXIT

;
; Here 'cos it was a post init service call.
;
 [ JoysticksSupported
; We have joystick hardware, check for a dongle
; **************************************************************************
;
;	CheckForSoakConnector
;
; in:	-
; out:	r0 = 0 => no soak test connector
;	r0 = 1 => digital joystick ID, bits 1..3, 8..11 low, bit 0 low => perform soak test
;	r0 = 2 => digital joystick ID, bits 1..3, 8..11 low, bit 0 high => perform bootstrap from parallel interface
;

CheckForSoakConnector Entry "r1-r3"
	LDR	lr, =IOMD_Base
 [ PokeCLINES
	MOV	r0, #&79
	STRB	r0, [lr, #IOMD_CLINES]				; OS does not yet set up ID pins as inputs, so we do it
 ]
	LDRB	r0, [lr, #IOMD_CLINES]
	AND	r0, r0, #2_01100000				; extract bits 5 and 6
	TEQ	r0, #0						; for digital joystick, bits 5 and 6 are both zero
	MOVNE	r0, #0						; if not, then return zero, ie nothing special
	EXIT	NE

	MOV	r0, #Podule_ReadInfo_EASILogical
	ADR	r1, EASISpaceAddress				; workspace to dump value
	MOV	r2, #4						; length of workspace
	MOV	r3, #0						; podule 0
	SWI	XPodule_ReadInfo

	MOVVS	r0, #0						; if VS then can't find joystick hardware, so return zero
	EXIT	VS

	LDR	r0, EASISpaceAddress
	ADD	r0, r0, #&00C00000				; point at IR + joystick stuff
	LDR	r1, [r0, #4]					; read it once to latch it
	LDR	r1, [r0, #4]					; and again to get the latched value
	TST	r1, #&0F00					; bits 11..8 must be low (all directions down, stick 2)
	TSTEQ	r1, #&000E					; and bits 3..1 must be low (R, L, D down, stick 1)
	MOVNE	r0, #0
	EXIT	NE

	AND	r0, r1, #1					; extract bit 0 (low => return 1, high => return 2)
	ADD	r0, r0, #1
	EXIT
 ] ; end if joystick hardware suppot

 [ SmartCardSupported
; Smart Card hardware fitted, check them for special smart cards.
;
CheckForSmartCard	Entry
; **************************************************************************
;
;	CheckForSmartCard
;
; in:	-
; out:	r0 = 0 => no smart card, data not vlaid or an error occured => dont do anything.
;	r0 = 1 => soak smart card detected => perform soak test.
;	r0 = 2 => plip smart card detected => perform bootstrap from parallel interface.
;

smcrd_source		*	2		; constant indicateing that the
						; smart card was the source for the
						; data.
scrd_enqbuf_size	*	16		; Size (bytes) of buffer
scrd_enqbuf		% scrd_enqbuf_size	; reserve the memory - zeroed.

1
	=	"SOAK_ENABLE",0
2
	=	"PLIP_ENABLE",0

; Note : Because we are asking for specific flags the registrary modeule
; shifts the bits down to the LSB, therefore we are always looking at bit 0.
; Not the bit specefied in the relevent documentation.

smcrd_checksoak
	ADR	r0,%BT1			; Address of tag to get data on
	ADR	r1,scrd_enqbuf		; Address of buffer
	MOV	r2,#scrd_enqbuf_size	; Size of the buffer
	SWI	XNCRegistry_Enquiry	; Make the SWi call
					; V bit set (VS) if error
	BVS	smcrd_end		; error -exit.

	CMP	r0,#4			; Is length of data 4 bytes ?
	CMPEQ	r1,#smcrd_source	; Does the data cone from the smart card ?
	BLNE	smcrd_checkplip		; Not right size, not from smart card check for plip

	ADR	r1,scrd_enqbuf		; Address of buffer
	LDR	r0,[r1]			; get contents of buffer
	AND	r0,r0,#1		; mask off all but bit 0
	CMP	r0,#1			; is bit 0 = 1 ?
	BLNE	smcrd_checkplip		; if <> 1, then check for plip
	MOVEQ	r0,#1			; if == 1, then r0= 1 - soak flag
	EXIT

smcrd_checkplip
	ADR	r0,%BT2			; Address of tag to get data on
	ADR	r1,scrd_enqbuf		; Address of buffer
	MOV	r2,#scrd_enqbuf_size	; Size of the buffer
	SWI	XNCRegistry_Enquiry	; Make the SWi call
					; V bit set (VS) if error
	BVS	smcrd_end		; error -exit.

	CMP	r0,#4			; Is length of data 4 bytes ?
	CMPEQ	r1,#smcrd_source	; Does the data cone from the smart card ?
	BLNE	smcrd_end		; Not right size, not from smart card - exit

	ADR	r1,scrd_enqbuf		; Address of buffer
	LDR	r0,[r1]			; get contents of buffer
	AND	r0,r0,#1		; mask off all but bit 0
	CMP	r0,#1			; is bit 0 = 1 ?
	MOVNE	r0,#0                   ; if <> then r0 = 0 - don't do anything
	MOVEQ	r0,#2			; if ==, then r0= 2 - plip flag
	EXIT

smcrd_end
	MOV	r0,#0			; don't do anything
	EXIT				; exit from here
 ] ; end if smart card hardware support

 [ IncludeMPEGCode
; **************************************************************************
;
;	Routines for MPEG soak test

VideoPacketFreeRoutine Entry "r12"
	LDR	r12, [r0, #PacketDescriptor_FreeWorkspace]
	MOV	lr, #0
	STR	lr, VideoPacketInUse
	EXIT

AudioPacketFreeRoutine Entry "r12"
	LDR	r12, [r0, #PacketDescriptor_FreeWorkspace]
	MOV	lr, #0
	STR	lr, AudioPacketInUse
	EXIT
 ]

; **************************************************************************
;
;	SoakTest_Code - Decide on MPEG or non-MPEG soaktest and do it

SoakTest_Code
	LDR	wp, [r12]

SoakTestWPEntry Entry "r7-r11"

SoakTestInternalEntry

 [ MPEGandNonMPEG
	MOV	r3, #0						; Get podule header for podule 0
        ADR     r2, PoduleBuffer
	SWI	XPodule_ReadHeader
	BVS	SoakTestNonMPEG					; nothing in podule 0; do non-MPEG soaktest
        LDRB    r0, [r2, #3]
        LDRB    r1, [r2, #4]
        ORR     r0, r0, r1, LSL #8				; r0 holds podule product type
	LDR	r1, =ProdType_STB2_MPEG1
	CMP	r0, r1
	BNE	SoakTestNonMPEG					; not a STB2 w/ MPEG1; do non-MPEG soaktest
;	Fall through to MPEG soaktest
 ]

 [ MPEGOnly
	B	SoakTestMPEG
 ]

 [ NonMPEGOnly
	B	SoakTestNonMPEG
 ]

; **************************************************************************
;
; Define the screen modes
; Depending upon 'UseModeDescriptors' the mode will be either :-
;    a Mode number - the old way.
;    a pointer to a descriptor block - the new way.
;
 [ UseModeDescriptors
;		Format, X Size, Y Size, Pixel Depth, Frame Rate, Terminator
VGAMode
		&	1,800,600,3,60,-1
;		Format, X Size, Y Size, Pixel Depth, Frame Rate, Terminator
NTSCMode
		&	1,768,480,3,30,-1
;		Format, X Size, Y Size, Pixel Depth, Frame Rate, Terminator
PALMode
		&	1,768,576,3,25,-1
 |
; 		Select mode 50 - 768 x 576 (16bpp)
VGAMode		*	50
; 		Select mode 55 - 768 x 480 (16bpp)
NTSCMode	*	55
; 		Select mode 50 - 768 x 576 (16bpp)
PALMode		*	50
 ]

 [ IncludeMPEGCode
; **************************************************************************
;
;	SoakTestMPEG - Routine to perform soak test (MPEG version)

SoakTestMPEG
	ADR	r0, ReInitVideoString
	SWI	XOS_CLI
	ADRVC	r0, ReInitAudioString
	SWIVC	XOS_CLI
	EXIT	VS

 [ UseSCARTSwitching
	BL	TurnSCARTOn
 ]
 [ UseSTBStateModule
	MOV	r0, #0						; prevent watchdog timer from resetting computer
	SWI	XSTBState_Control
 ]

	ADR	r1, VideoPacketDescriptor
	MOV	r0, #0
	STR	r0, [r1, #PacketDescriptor_Link]		; only one packet
	STR	r0, [r1, #PacketDescriptor_BufferDescriptor]	; not using MPEGControl, so irrelevant
	STR	r0, VideoPacketInUse

	ADR	r2, VideoPacketFreeRoutine
	STR	r2, [r1, #PacketDescriptor_FreeRoutine]
	STR	wp, [r1, #PacketDescriptor_FreeWorkspace]

	MOV	r0, #StreamFlags_VideoPresent
	MOV	r1, #0						; control stream handle

; Find out what type of video display system we have connected.
	MOV	r10,#4						; prime r10 with invalid data
	BL	BoxType						; find out what type of system we have
								; on exit : r10 = 0 = VGA
								; on exit : r10 = 1 = NTSC
								; on exit : r10 = 2 = PAL
; Select the required video structure data.
	CMP	r10,#0						; r10 = 0 = 'VGA' ?
	ADREQ	r2, VideoStructureVGA				; r2 has the addr. of the VideoStructure
	BEQ	%FT5

	CMP	r10,#1						; r10 = 1 = 'NTSC' ?
	ADREQ	r2, VideoStructureNTSC				; r2 has the addr. of the VideoStructure
	BEQ	%FT5

	CMP	r10,#2						; r10 = 2 = 'PAL' ?
	ADREQ	r2, VideoStructurePAL				; r2 has the addr. of the VideoStructure
	BNE	InvalidBoxType					; None of the above, jump to moan code.
5
; Setup the MPEG Video Stream
	SWI	XMPEGVideo_OpenStream
	BVS	%FT99

	STR	r0, VideoStreamHandle

	ADR	r1, AudioPacketDescriptor
	MOV	r0, #0
	STR	r0, [r1, #PacketDescriptor_Link]		; only one packet
	STR	r0, [r1, #PacketDescriptor_BufferDescriptor]	; not using MPEGControl, so irrelevant
	STR	r0, AudioPacketInUse

	ADR	r2, AudioPacketFreeRoutine
	STR	r2, [r1, #PacketDescriptor_FreeRoutine]
	STR	wp, [r1, #PacketDescriptor_FreeWorkspace]

	MOV	r0, #StreamFlags_AudioPresent :OR: StreamFlags_NoLipSync
	MOV	r1, #0						; control stream handle
	MOV	r2, #0						; pointer to audio structure (NULL)
	SWI	XMPEGAudio_OpenStream
	BVS	%FT97

	STR	r0, AudioStreamHandle

 	MOV	r0, #0
	LDR	r1, VideoStreamHandle
	SWI	XMPEGVideo_Play					; this is so the video module doesn't call MPEGControl_Play

	MOV	r0, #0
	LDR	r1, AudioStreamHandle
	SWI	XMPEGAudio_Play					; this is so the audio module doesn't call MPEGControl_Play

 [ UseNCFrontPanelLEDs
	SWI	XOS_ReadMonotonicTime				; Get the TIME
	MOV	r9, r0						; Temporary copy in r9
 ]

; now enter main loop

10
	SWI	XOS_ReadEscapeState				; check for ESCAPE
	BCS	%FT95						; and bomb out if we get it

	TEQP	pc, #0
	MOV	r0, r0
	SWI	XOS_EnterOS

	SWI	XOS_ReadMonotonicTime
	MOV	r2, #100					; divide by 100 to get it in seconds
	DivRem	r1, r0, r2, r3					; r1 = time in seconds
	TST	r1, #1
	ADREQ	r6, MPEGSoakEvenStruct
	ADRNE	r6, MPEGSoakOddStruct

 [ UseNCFrontPanelLEDs
	; See if 0.5 seconds are up, if so toggle the LED's
	SWI	XOS_ReadMonotonicTime
	CMP	r0, r9						; is r0 >= r9+50 (0.5 Secs)
	ADDPL	r9, r0, #50					; r0 >= r9+50 then add on 0.5 seconds
	BLPL	tl_Toggle_LEDs					; r0 >= r9+50 then toggle LEDs
 |
 	[ UseSTBStateModule
	AND	r0, r1, #1					; r0 = 0 or 1
	ADD	r0, r0, #1					; r0 = 1 or 2
	SWI	XSTBState_Control				; update LED status
 	|
	LDR	r0, [r6], #4
	MOV	r1, #IOMD_Base
	STRB	r0, [r1, #IOMD_CLINES]				; update LED status
	]
 ]

	LDR	r2, VideoPacketInUse
	TEQ	r2, #0
	BNE	%FT20						; [packet in use, so skip]

	ADR	r2, VideoPacketDescriptor
	LDMIA	r6, {r3, r4}
	ADD	r3, r3, r6
	STR	r3, [r2, #PacketDescriptor_Start]
	STR	r4, [r2, #PacketDescriptor_Length]
	STR	r4, [r2, #PacketDescriptor_FullLength]
	MOV	r0, #PacketDescriptorFlags_MPEGStart		; pretend is start of MPEG packet
	STR	r0, [r2, #PacketDescriptor_Flags]
	MOV	r3, #1
	STR	r3, VideoPacketInUse

	MOV	r0, #0
	LDR	r1, VideoStreamHandle
	SWI	XMPEGVideo_FullPackets
20
	LDR	r2, AudioPacketInUse
	TEQ	r2, #0
	BNE	%BT10

	ADD	r6, r6, #8
	ADR	r2, AudioPacketDescriptor
	LDMIA	r6, {r3, r4}
	ADD	r3, r3, r6
	STR	r3, [r2, #PacketDescriptor_Start]
	STR	r4, [r2, #PacketDescriptor_Length]
	STR	r4, [r2, #PacketDescriptor_FullLength]
	MOV	r0, #PacketDescriptorFlags_MPEGStart		; pretend is start of MPEG packet
	STR	r0, [r2, #PacketDescriptor_Flags]

	MOV	r3, #1
	STR	r3, AudioPacketInUse

	MOV	r0, #0
	LDR	r1, AudioStreamHandle
	SWI	XMPEGAudio_FullPackets

	B	%BT10

	LTORG

95
	MOV	r0, #&7E
	SWI	XOS_Byte					; acknowledge Escape

	MOV	r0, #0
	LDR	r1, AudioStreamHandle
	SWI	XMPEGAudio_CloseStream
97
	MOV	r0, #0
	LDR	r1, VideoStreamHandle
	SWI	XMPEGVideo_CloseStream

	CLRV
99
 [ UseSTBStateModule
	MOV	r0, #0						; LEDs off
	SWI	XSTBState_Control
 ]
	EXIT

ReInitVideoString
	=	"RMReInit MPEGVideo", 0
	ALIGN
ReInitAudioString
	=	"RMReInit MPEGAudio", 0
	ALIGN


MPEGSoakEvenStruct ROUT
 [ :LNOT: UseNCFrontPanelLEDs
 	[ :LNOT: UseSTBStateModule
	&	LEDs_RedNotGreen
	]
 ]
10
	&	MPEGSoakData - %BT10
	&	MPEGSoakDataEnd - MPEGSoakData
20
	&	MPEGAudioLoData - %BT20
	&	MPEGAudioLoDataEnd - MPEGAudioLoData

MPEGSoakOddStruct ROUT
 [ :LNOT: UseNCFrontPanelLEDs
 	[ :LNOT: UseSTBStateModule
	&	LEDs_GreenNotRed
	]
 ]
10
	&	MPEGTestData - %BT10
	&	MPEGTestDataEnd - MPEGTestData
20
	&	MPEGAudioHiData - %BT20
	&	MPEGAudioHiDataEnd - MPEGAudioHiData

; Define the required screen modes, depending upon 'UseModeDescriptors' this will be either :-
;   a Mode number
;   a pointer to a description block
;
VideoStructureVGA
	&	0						; format type
	&	0						; flags
 [ UseModeDescriptors
	&	VGAMode	- VideoStructureVGA			; VGA mode descriptor
 |
	&	50						; VGA mode  number
 ]
	&	0						; DisplayedLines - no longer used
	&	96						; BorderLeft - guesstimate
	&	0						; BorderTop - no longer used

VideoStructurePAL
	&	0						; format type
	&	0						; flags
 [ UseModeDescriptors
	&	PALMode	- VideoStructurePAL			; PAL mode descriptor
 |
	&	50						; PAL mode  number
 ]
	&	0						; DisplayedLines - no longer used
	&	96						; BorderLeft - guesstimate
	&	0						; BorderTop - no longer used

VideoStructureNTSC
	&	0		   				; format type
	&	VideoStructureFlags_NTSC			; flags
 [ UseModeDescriptors
	&	NTSCMode - VideoStructureNTSC			; NTSC mode descriptor
 |
	&	55						; NTSC mode  number
 ]
	&	0						; DisplayedLines - no longer used
	&	96						; BorderLeft - guesstimate
	&	0						; BorderTop - no longer used


MPEGSoakData
	BIN	"MPEG.Soak"
MPEGSoakDataEnd

MPEGTestData
	BIN	"MPEG.Test"
MPEGTestDataEnd

MPEGAudioLoData
	BIN	"MPEG.AudioLo"
MPEGAudioLoDataEnd

MPEGAudioHiData
	BIN	"MPEG.AudioHi"
MPEGAudioHiDataEnd
	ALIGN
 ]  ; End of if IncludeMPEGCode



 [ IncludeNonMPEGCode
; **************************************************************************
;
;	SoakTestNonMPEG - Routine to perform soak test (non-MPEG version)

SoakTestNonMPEG	ROUT
 [ UseSCARTSwitching
	BL	TurnSCARTOn
 ]
 [ UseSTBStateModule
	MOV	r0, #0						; prevent watchdog timer from resetting computer
	SWI	XSTBState_Control
 ]
; Find out what type of video display system we have connected.
	MOV	r10,#4						; prime r10 with invalid data
	BL	BoxType						; find out what type of system we have
								; on exit : r10 = 0 = VGA
								; on exit : r10 = 1 = NTSC
								; on exit : r10 = 2 = PAL
; Select the required screen definition data.
	CMP	r10,#0						; r10 = 0 = 'VGA' ?
 [ UseModeDescriptors
	ADREQ	r1, VGAMode				        ; r1 has addr of the VGA mode specifier
 |
	MOVEQ	r1, #VGAMode					; r1 = VGA Mode number.
 ]
	BEQ	%FT5

	CMP	r10,#1						; r10 = 1 = 'NTSC' ?
 [ UseModeDescriptors
	ADREQ	r1, NTSCMode				        ; r1 has addr of the NTSC mode specifier.
 |
	MOVEQ	r1, #NTSCMode					; r1 = NTSC Mode number.
 ]
	BEQ	%FT5

	CMP	r10,#2						; r10 = 2 = 'PAL' ?
 [ UseModeDescriptors
	ADREQ	r1, PALMode				        ; r1 has addr of the PAL mode specifier.
 |
	MOVEQ	r1, #PALMode					; r1 = PAL Mode number.
 ]
	BNE	InvalidBoxType					; None of the above, jump to moan code.
5
; Switch to the required screen mode.
	MOV	r0,#0					        ; r0 = resion code = 0 = select mode.
        SWI     XOS_ScreenMode				        ; Make the SWI call.
	BVS	ScreenModeErrorTrap				; If error, then jump to error report code.

; Turn the screen cursor off.
	ADR	r0, ScreenCursorOff				; r0 = addr of data to turn the cursor off
	MOV	r1, #ScreenCursorOffEnd - ScreenCursorOff	; r1 = length of the data
	SWI	XOS_WriteN					; execue the data !

; Make a note of the start time
	SWI	XOS_ReadMonotonicTime				; Get the TIME
	MOV	r8, r0						; Temporary copy in r8
 [ UseNCFrontPanelLEDs
	MOV	r9, r0						; Temporary copy in r9
 ]

; Now enter the main loop, escape is the only way out.

10
	SWI	XOS_ReadEscapeState				; check for ESCAPE
	BCS	%FT95						; and bomb out if we get it

	TEQP	pc, #0
	MOV	r0, r0
	SWI	XOS_EnterOS

	SWI	XOS_ReadMonotonicTime				; Get the TIME

	; See if 2 seconds are up, if so can start beeping and beep every 2 secs
	CMP	r0, r8						; is r0 >= r8+200 (2 Secs)
	ADDPL	r8, r0, #200					; r0 >= r8+200 then add on 2 seconds
	SWIPL	XOS_WriteI+7					; r0 >= r8+200 then beep

	; Determin if this an odd or even second, call screen display as reqd.
	MOV	r2, #100					; divide by 100 to get it in seconds
	DivRem	r1, r0, r2, r3					; r1 = time in seconds
	TST	r1, #1						; r1 = 1 ?
	ADREQ	r6, SoakEvenStruct				; Even screen display
	ADRNE	r6, SoakOddStruct				; Odd screen display

 [ UseNCFrontPanelLEDs
	; See if 0.5 seconds are up, if so toggle the LED's
	SWI	XOS_ReadMonotonicTime				; Get the TIME
	CMP	r0, r9						; is r0 >= r9+50 (0.5 Secs)
	ADDPL	r9, r0, #50					; r0 >= r9+50 then add on 0.5 seconds
	BLPL	tl_Toggle_LEDs					; r0 >= r9+50 then toggle LEDs
 |
	[ UseSTBStateModule
	AND	r0, r1, #1					; r0 = 0 or 1
	ADD	r0, r0, #1					; r0 = 1 or 2
	SWI	XSTBState_Control				; update LED status
	|
 	LDR	r0, [r6], #4
	MOV	r1, #IOMD_Base
	STRB	r0, [r1, #IOMD_CLINES]				; update LED status
 	]
 ]
; Plot the sprite on the screen
	MOV	r0, #SpriteReason_PutSpriteScaled :OR: &200
	LDR	r1, [r6]					; r1 -> sprite area
	ADD	r1, r1, r6
	ADD	r2, r1, #16					; r2 -> sprite
	MOV	r3, #32						; r3 = xcoord
; r10 has a copy of the Box type found at the start
; r0 = 0 = VGA, r0 = 1 = NTSC, r0 = 2 = PAL
	CMP	r10,#0						; is r10 = 0 = VGA ?
	MOVEQ	r4, #0						; yes : r4 = ycoord (VGA)
	BEQ	%FT20						; Skip to remainder of code.

	CMP	r10,#1						; is r10 = 1 = NTSC ?
	MOVEQ	r4, #-48					; yes : r4 = ycoord (NTSC)
	BEQ	%FT20						; Skip to remainder of code.

	CMP	r10,#2						; is r10 = 2 = PAL ?
	MOVEQ	r4, #0						; r4 = ycoord (PAL)

20
	MOV	r5, #0						; plot action = overwrite
	ADR	r6, SpriteScaleFactors				; r6 = addr of scale factors
	ADR	r7, SpriteTranslationTable			; r7 = addr of colour trans table
	SWI	OS_SpriteOp					; plot the sprite
	B	%BT10						; loop back ....

	LTORG

;****************************************************************************************************
; Code to moan if OS_ScreenMode SWI call failed.
ScreenModeErrorTrap
; Report that the OS_ScreenModes SWI call failed, thus failed to select reqd. screen mode.
	SWI	OS_WriteS
	=	"SWI OS_ScreenModes failed ....",10,13,0
	ADD	r0,r0,#4				; add 4 to r0, so r0 -> text msg.
	SWI	OS_Write0				; print report text.
	B	%FT99					; skip ack esc.

;****************************************************************************************************
; Code to moan if BoxType function does not return a number 0, 1 or 2.
; Used by both old and new mode selection code.

InvalidBoxTypeMessage
	=	"Box Type was NOT PAL, NTSC or Monitor.",13,10,0
InvalidBoxType
; print out error message if BoxType func rtn value not known.
	ADRNE	r0,InvalidBoxTypeMessage		; r0 -> message
	SWI	XOS_Write0				; print message
	B	%FT99

;****************************************************************************************************
; Code to acknowledge the escape key if it has been pressed.

95
	MOV	r0, #&7E
	SWI	XOS_Byte					; acknowledge Escape
	CLRV

99
; That's it finish off !
 [ UseNCFrontPanelLEDs
	; on an nc, ensure Green LED is on.
        LDR     r0,=IOMD_Base				; r1 = IOMD Base addr
	MOV	r1,#0					; clear out r1
        LDRB    r1, [r0, #IOMD_CLINES]			; r0 = contents of r0+&0C
	MOV	r2,#&FF-IOMD_STANDBY_LED_BIT		; create a mask
	AND	r1,r2,r1				; Clear the stand-by LED bit.
	ORR	r1,r1,#IOMD_IOLINES_INPUTS		; OR with the default I/O settings
	STRB	r1,[r0, #IOMD_CLINES]			; store a byte of r1 in to loc pointed to by r0
 |
	[ UseSTBStateModule
	MOV	r0, #0					; LEDs off
	SWI	XSTBState_Control
	]
 ]
	EXIT

SoakEvenStruct ROUT
 [ :LNOT: UseNCFrontPanelLEDs
 	[ :LNOT: UseSTBStateModule
	&	LEDs_RedNotGreen
	]
 ]
10
	&	SoakSpriteArea - %BT10

SoakOddStruct ROUT
 [ :LNOT: UseNCFrontPanelLEDs
 	[ :LNOT: UseSTBStateModule
	&	LEDs_GreenNotRed
	]
 ]
10
	&	TestSpriteArea - %BT10

; Define the required screen modes, depending upon 'UseModeDescriptors' this will be either :-
;   a Mode number
;   a pointer to a description block
;
;	ALIGN
;ScreenInitStringPAL
;	=	PALMode						; PAL mode descriptor or number
;
;ScreenInitStringNTSC
;	=	NTSCMode					; PAL mode descriptor or number
;
;ScreenInitStringVGA
;	=	VGAMode						; PAL mode descriptor or number

	ALIGN
ScreenCursorOff
	=	23, 1, 0, 0, 0, 0, 0, 0, 0, 0                   ; turn cursor off
ScreenCursorOffEnd

	ALIGN
SpriteScaleFactors
	&	32, 32, 1, 1


 [ UseColourTransTable256to16
; Colour translation table for 256 -> 16 colours
	ALIGN
SpriteTranslationTable
	=	&ff, &fd, &d3, &d1, &2f, &2d, &03, &00
	=	&A0, &76, &60, &14, &f6, &44, &57, &ca
 ]

 [ UseColourTransTable32Kto16
; Colour translation table for 32K -> 16 colours
	ALIGN
SpriteTranslationTable
	=	&ff, &fd, &ab, &a9, &57, &55, &03, &00
	=	&90, &3e, &30, &0c, &be, &24, &2f, &e3
 ]

SoakSpriteArea
	&	SoakSpriteAreaEnd - SoakSpriteArea
	BIN	"Sprites.Soak.4bpp"
	ALIGN
SoakSpriteAreaEnd

TestSpriteArea
	&	TestSpriteAreaEnd - TestSpriteArea
	BIN	"Sprites.Test.4bpp"
	ALIGN
TestSpriteAreaEnd
 ]  ; End of if IncludeNonMPEGCode

; **************************************************************************
;
;	Bootstrap_Code - Routine to perform parallel port bootstrap

Bootstrap_Code Entry "r7-r11"
	LDR	wp, [r12]
BootstrapInternalEntry
 [ UseSCARTSwitching
	BL	TurnSCARTOn
 ]
	SWI	XOS_WriteI+22
	SWIVC	XOS_WriteI+0
	EXIT	VS

	MOV	r1, #0				; parallel stream not open at the moment

RestartBootstrap
	SWI	XOS_ReadEscapeState
	BCS	%FT98						; and bomb out if we get it

	SWI	XOS_WriteS
	=	"Parallel bootstrap starting...", 10, 13, 0
	ALIGN

	TEQ	r1, #0				; is stream already open?
	BNE	%FT05				; if so then skip this

	DLINE	"Opening Parallel stream"

;	ADRL	r0, CloseDevices
;	SWI	XOS_CLI

	MOV	r0, #OSFind_ReadFile
	ADRL	r1, ParallelFilename
	SWI	XOS_Find
	EXIT	VS
;	DREG	r0,"Opened Parallel: its handle = ",cc
	MOV	r1, r0
05
	ADR	r10, PTHeaderString

	STR	r13, StackPtr

	SWI	XOS_ReadMonotonicTime
	ADD	r11, r0, #Timeout_BGET
	MOVS	r8, #0				; no RMA block claimed yet, and set EQ
	MOV	r7, #0				; offset in PTHeaderString to compare
10
	BL	GetByte				; get byte from string
12
	LDRB	r9, [r10, r7]
	TEQ	r0, r9
	BEQ	%FT20				; [character matches]

; no match, so reset to beginning

	TEQ	r7, #0				; were we checking first char?
	BEQ	%BT10				; if so, then get another byte and wait for first char
	MOV	r7, #0				; if not, then recheck against first char
	B	%BT12				; without getting another char from port

; there is a match

20
	ADD	r7, r7, #1			; advance position in string
	TEQ	r7, #PTHeaderStringEnd - PTHeaderString ; have we got to end?
	BNE	%BT10				; no, then carry on

	SWI	XOS_WriteS
	=	"Read ",13,10,0
PTHeaderString
        =	PTHeader
PTHeaderStringEnd
	=	" string...", 10, 13, 0
	ALIGN

	BL	GetWord
	MOV	r6, r0
	DREG	r6, "Module length = &"

	MOV	r0, #ModHandReason_Claim
	MOV	r3, r6
	SWI	XOS_Module
	BVS	%FT90

	DLINE	"Reading module data", cc

	MOV	r8, r2				; r8 -> module block
	MOV	r7, #0				; current offset in module block
	MOV	r5, #0				; checksum
	MOV	r4, #0				; ROR position in checksum
30
	TST	r7, #&FF
	SWIEQ	XOS_WriteI+"."			; print a dot every 256 bytes

	BL	GetByte
	STRB	r0, [r8, r7]
	ADD	r5, r5, r0, ROR r4
	SUBS	r4, r4, #8			; in sequence ROR by 0, 24, 16, 8
	MOVMI	r4, #24

	ADD	r7, r7, #1
	CMP	r7, r6
	BCC	%BT30

; we've received all the data, now read the checksum

	SWI	XOS_NewLine
	DLINE	"Received all data, reading checksum"

	BL	GetWord
	TEQ	r0, r5
	BNE	%FT50				; [checksum incorrect]

	DLINE	"Checksum correct, closing parallel stream"
;	DREG	r1,"Closing handle ",cc

	MOV	r0, #0				; r0 = 0 = close file
						; r1 = handle to close
	SWI	XOS_Find			; close parallel stream

	DLINE	"Initialising module"

	MOV	r0, #ModHandReason_AddArea
	MOV	r1, r8
	SWI	XOS_Module
	MOV	r1, #0				; indicate stream not open
	BVS	%FT40				; [module failed to initialise]

	DLINE	"Module initialised OK, looking for another one"
	MOV	r8, #0				; indicate no block claimed from RMA
	B	RestartBootstrap

; module returned error in init

40
	DLINE	"Module returned error '", cc
	ADD	r0, r0, #4
	SWI	XOS_Write0
	DLINE	"' from initialisation, restarting"
	B	RestartAfterError

; checksum was incorrect

50
	DLINE	"Checksum incorrect"
RestartAfterError
	LDR	r13, StackPtr
	TEQ	r8, #0				; if we have a block claimed from RMA
	BNE	%FT52
	MOV	r0, #ModHandReason_Free
	MOV	r2, r8
	SWI	XOS_Module
	MOV	r8, #0
52
	B	RestartBootstrap

90
	DLINE	"Failed to allocate RMA block for module"
	B	RestartAfterError
98
	; An escape has been detected
	DLINE	"Escape detected ......"
	TEQ	r1,#0				; is stream already open?
	BEQ	%FT99				; not open, don't close
						; parallel open, close it
	DLINE	"Parallel: was open, closing it"
;	DREG	r1,"Closing handle ",cc
	MOV	r0, #0				; r0 = 0 = close file
						; r1 = handle to close
	SWI	XOS_Find			; close parallel stream
99
	; exit stage right with CS
;	DLINE	"Exit stage right with CS set"
	EXIT


BootstrapWPEntry ALTENTRY
	B	BootstrapInternalEntry

GetWord Entry "r2"
	BL	GetByte
	MOV	r2, r0
	BL	GetByte
	ORR	r2, r2, r0, LSL #8
	BL	GetByte
	ORR	r2, r2, r0, LSL #16
	BL	GetByte
	ORR	r0, r2, r0, LSL #24
	EXIT

GetByte Entry "r2"
10
	MOV	r0, #OSArgs_EOFCheck
	SWI	XOS_Args
	BVS	%FT90				; EOF check returned error
	TEQ	r2, #0
	BEQ	%FT20

; EOF, so no characters waiting, check timeout

	SWI	XOS_ReadMonotonicTime
	CMP	r0, r11				; have we timed out?
	BMI	%BT10				; [no, so loop]

	DLINE	"BGET timeout, restarting"
	B	RestartAfterError

20
	SWI	XOS_ReadMonotonicTime		; reset timeout value
	ADD	r11, r0, #Timeout_BGET

	SWI	XOS_BGet
	EXIT	VC

	DLINE	"OS_BGet returned error, restarting"
	B	RestartAfterError

90
	DLINE	"OS_Args EOF check returned error, restarting"
	B	RestartAfterError



ParallelFilename
	=	"Parallel:", 0
CloseDevices
	=	"Devices:Close", 0
	ALIGN



; **************************************************************************
;
;	TurnSCARTOn - Enable SCART signals so we can see something
;

TurnSCARTOn Entry "r0-r2"
 [ UseSTBStateModule
	SWI	XSTBState_On		; try to use STB State module if present
	EXIT	VC
 ]
 [ IncludeMPEGCode
	MOV	r0, #CardControlReason_UpdateControlRegister
	MOV	r1, #MPEGPoduleControl_CTRL0 :OR: MPEGPoduleControl_CTRL1 ; EOR mask
	MVN	r2, r1 ; AND mask = NOT EOR mask
	SWI	XMPEGVideo_CardControl
	CLRV	; ignore errors for now
 ]
	EXIT

; **************************************************************************
;
;	BoxType - Find out box type from configured mode.
;
;       out: 	registers r0-r3 preserved.
;		r10 0 = Monitor
;		    1 = NTSC
;		    2 = PAL
;

BoxType	ROUT
	Entry	"r0-r3"
 [ IOMD_C_PALNTSCType = (1<<4)
	; NC - Check the IO flag.
        LDR     r0,=IOMD_Base				; r0 = IOMD Base addr
	MOV	r1,#0					; clear out r1
        LDRB    r1, [r0, #IOMD_CLINES]			; r1 = contents of r0+&0C
	TST	r1, #IOMD_C_TVMode			; mask off bit 2
	MOVEQ	r10, #0					; bit 4 CLR : Monitor
	EXIT	EQ					; bit 4 CLR : Exit
	TST	r1, #IOMD_C_PALNTSCType			; mask off bit 4
	MOVNE	r10,#1					; Bit 4 SET : NTSC
	MOVEQ	r10,#2					; Bit 4 CLR : PAL
 |
	; Non NC - read the MCOS RAM.
	MOV	r0, #ReadCMOS				; r0 = Read CMOS OS_Byte No. 161
	MOV	r1, #WimpModeCMOS			; r1 = Location to read
	SWI	XOS_Byte				; Make te SWI call
	CMP	r2, #55					; is r2 = 55 (NTSC) ?
	MOVEQ	r10,#1					; Yes : r10 = 1 : NTSC
	EXIT	EQ					; Yes : Exit
	CMP	r2, #50					; is r2 = 50 (PAL) ?
	MOVEQ	r10,#2					; Yes : r10 = 2 : PAL
	MOV	r10,#0					; No  : r10 = 0 : Monitor
 ]
	EXIT

; **************************************************************************
;
;       Message stuff


 [ international
CopyError ENTRY "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.SoakTest.Messages", 0
        ALIGN

open_messagefile ENTRY "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message ENTRY "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 ]

	InsertDebugRoutines

        END
