/* >c.System

TEST SOFTWARE (c) Element 14 Ltd. 1997-1999

************************* CHANGE LIST *************************************

Vers    Date            Name    Comment
------  ---------       ---     -------------------------------------------
1.00    20 Mar 97       BAR     Initial writing
1.01    02 May 97       BAR     Change so theat when id test failes uses
                                display_sub_test_status.
1.02    06 May 97       BAR     Print out CPU type in HEX.
                                Print out IOCtrl ID in HEX caps and 4.2
                                digits, with leading 0 if needed.
                                Use err->errmess to get os version number.
1.03    11 Nov 97       BAR     Add code to read the serial number on a
                                Daytona unit.
1.04	28 Nov 97	RLT	Modified #ifdef statement around the serial
				number read and changed the SWI to read the
				number.
1.05    01 Mar 99       SBF     Added a new (updated) "find_cputype" call
                                which correctly identifies the CPU from both
                                the CPU and IOMD IDs.

Perform the system check.
*/

#include <stdio.h>
#include "kernel.h"
#include "swis.h"
#include "signal.h"

#include "support.h"
#include "system.h"
#include "display.h"
#include "msgs.h"
#include "CPUType.h"
#include "IOControl.h"
#include "daytonahw.h"


void system_test()
{
        int overall = FAILED;

        display_status(SYSTEM,RUNNING);
        get_cpu_type();
        get_io_controller();
        overall=get_id_number();
        display_sub_test(OSVSN,get_os_version());
        get_memory_size();
        if (overall==PASSED){
                display_status(SYSTEM,COMPLETED);
                log_status(SYSTEM,PASSED);
        }else{
                display_status(SYSTEM,FAILED);
                log_status(SYSTEM,FAILED);
        }
}

char *get_os_version()
/* Get the OS version
 */
{
        _kernel_swi_regs reg;
        _kernel_oserror *err;

        reg.r[0] = 0;
        reg.r[1] = 0;
        err = _kernel_swi(OS_Byte, &reg, &reg);
        return (err->errmess);
}

void get_cpu_type()
/* Get the CPU type and display it
 */
{
        int cpu_type;
        char str[80];

        cpu_type=find_cputype();
        sprintf(str,"ARM%X",cpu_type);
        display_sub_test(ARMCPU,str);
}

void get_memory_size()
/* Get the memory size and display it
 */
{
        int size;
        char str[80];

        size=find_memory_size(DRAM_AREA);
        sprintf(str,"%d%s",size,general_msg[1]);
        display_sub_test(DRAMSIZE,str);
}

void get_io_controller()
/* Get the IO Controller details and display
 */
{
        int ioctrlid=0;
        int ioctrlvsn=0;
        char str[80];

        ioctrlid=find_ioctrl_id();
        ioctrlvsn=find_ioctrl_vsn();
        if (ioctrlvsn<=9){
                sprintf(str,"IOMD (%4X-0%1X)",ioctrlid,ioctrlvsn);
        }else{
                sprintf(str,"IOMD (%4X-%2X)",ioctrlid,ioctrlvsn);
        }
        display_sub_test(IOCONTROL,str);
}

#ifndef MACHDaytona

int get_id_number(void)
/* Get the ID Number and then display it
 */
{
        char str[80];
        int len, cnt, status=FAILED;
        _kernel_swi_regs reg;
        uniqueid_data id_data;

        /* ask the UniqueID module how long the serial number is */
        reg.r[0] = 0;
        reg.r[1] = 0;
        _kernel_swi(UniqueID_Read, &reg, &reg);
        len=reg.r[2];

        if (len<=max_id_size){
                /* Ok, the system has given a sensible length */
                /* now get the serial number */
                reg.r[0] = 0;
                reg.r[1] = (int)&id_data;
                reg.r[2] = sizeof(id_data);
                _kernel_swi(UniqueID_Read, &reg, &reg);
                /* id_data has all the relevent information stored there in ! */
                /* now all we need to do is display it !!!!!! */
                /* displayed as a long line of numbers split with '.' E.G. .... */
                /* sv.st.mimi.mnmn.bvbvbvbv.ovovovov */
                sprintf(str,"%x.",id_data.serial_version);
                sprintf(str,"%s%x.",str,id_data.serial_type);
                sprintf(str,"%s%x%x.",str,id_data.manuf_id_hi,id_data.manuf_id_low);
                sprintf(str,"%s%x%x.",str,id_data.model_no_hi,id_data.model_no_hi);
                sprintf(str,"%s%x%x%x%x.",str,id_data.bios_vsn_b4,id_data.bios_vsn_b3,id_data.bios_vsn_b2,id_data.bios_vsn_b1);
                sprintf(str,"%s%x%x%x%x.",str,id_data.ncos_vsn_b4,id_data.ncos_vsn_b3,id_data.ncos_vsn_b2,id_data.ncos_vsn_b1);
                display_sub_test(IDNUMBER,str);

                /* Now display the serial number, whose length is in id_data.serial_numb_len */
                /* We're not displaying the serial numbers length. */
                /* Diaplsy as one long 1-> 255 bytes number E.G. ... */
                /* AA01559768534D1C5A6B583DC4EFA626AB8C4EFDB8625D542C96A84526ACDFF8844AABB45CED56.....  */
                /* Really need to put in some form of line split code to handle the really long numbers. */
                /* Currently we can handle a serial number up to 20 bytes long. */
                sprintf(str,"");
                for (cnt=0; cnt<id_data.serial_numb_len; cnt++){
                        sprintf(str,"%s%x",str,id_data.serial_number[cnt]);
                }
                display_sub_test(SUBTESTCONT,str);
                status=PASSED;
        }else{
                /* well, the system thinks the length is more thatn the spec. */
                display_sub_test_status(IDNUMBER,FAILED);
                status=FAILED;
        }
        return status;
}

#else

int get_id_number(void)
/* Get the ID Number and then display it
 */
{
        char str[80];
        int ser_no=-1;
        int status=FAILED;
        _kernel_swi_regs reg;
        _kernel_oserror *e;

        reg.r[0] = 2;
        e = _kernel_swi(DaytonaHW_ReadOTP, &reg, &reg);
        if (e)
        {
            switch (e->errnum)					/* get error number */
            {
                case ID_CHECKSUM_ERRORNUM:
                    status = ID_ERROR_INVALIDCHECKSUM;
                    break;
                case ID_NOACKFROMICC_ERRORNUM:
                    status = ID_ERROR_NOICCDEVICE;
                    break;
            }
            display_sub_test_status(IDNUMBER, status);
        }
        else
        {
            ser_no=reg.r[0];
            sprintf(str,"&%08X",ser_no);
            status = PASSED;
            display_sub_test(IDNUMBER,str);
        }
        return status;
}

#endif


int find_cputype(void)
{
  static int cpu_id = 0;

  if (cpu_id != 0)
    return cpu_id;

  cpu_id = ARM_identification();

  cpu_id = (cpu_id >> 4) & 0xfff; // extract part number field

  if ((cpu_id & 0xf00) == 0)
  {
    /* An old-style ID (ARM 3 or prototype ARM 600) - shift it into the new form */
    cpu_id <<= 4;
  }

  if (cpu_id == 0x300)
  {
    cpu_id = 3;
  }
  else if (cpu_id == 0x710)
  {
    /*
     * The ARM 7500 returns an ARM 710 ID - need to look at its
     * integral IOMD unit to spot the difference
     */
    int iomd_id = IOMD_identification();
    iomd_id &= 0xff00; /* Just require most significant byte */

    if (iomd_id == 0x5b00)
      cpu_id = 0x7500; /* It's a standard 7500 */
    else if (iomd_id == 0xaa00)
      cpu_id = 0x7500FE; /* It's the FE flavour of 7500 */
  }
  return cpu_id;
}

/* End of c.System */
