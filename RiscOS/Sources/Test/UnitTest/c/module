/* > module.c

ACORN TEST SOFTWARE (c) Acorn Computers Ltd. 1997

************************* CHANGE LIST *************************************

Vers    Date            Name    Comment
------  ---------       ---     -------------------------------------------
1.00    18 Sep 97       BAR     Add this header.
1.01    02 Oct 97       BAR     ensure duration variables are of correct type.
1.02    07 Oct 97       BAR     Don't include RCA only headers.
1.03    05 Nov 97       BAR     Update to make the module run in User Mode
                                not supervisor mode.
1.04    11 Nov 97       BAR     Add trap for when there are no arguments
                                given.

RISC OS module related code.
 */

/* From CLib */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "Support.h"
#include "module.h"
#ifdef RCA
#include "storedinfo.h"
#else
#include "UnitTest.h"
#endif
#include "UserDiag.h"


/*------------------------------------------------------------------------------
 * module_finalise
 *
 *      Module exit handler.
 */
_kernel_oserror *
module_finalise( int fatal, int podule, void *pw )
{
        unittest_finalise( pw );

        return NULL;

        NOT_USED( fatal );
        NOT_USED( podule );
        NOT_USED( pw );
}


/*------------------------------------------------------------------------------
 * module_initialise
 *
 *      Module initialisation entry point.
 */
_kernel_oserror *
module_initialise( char *cmd_tail, int podule_base, void *pw )
{
        return unittest_initialise( pw );

        NOT_USED( cmd_tail );
        NOT_USED( podule_base );
        NOT_USED( pw );
}


/*------------------------------------------------------------------------------
 * module_command
 *
 *        Module command handler.
 */
_kernel_oserror *
module_command( char *arg_string, int argc, int cmd_no, void *pw )
{
        _kernel_swi_regs reg;

        reg.r[0]=2;
        reg.r[1]=(int) MODULE_NAME;
        reg.r[2]=(int) arg_string;
        _kernel_swi(OS_Module, &reg, &reg);

        return NULL;

/*         NOT_USED( arg_string ); */
/*         NOT_USED( argc ); */
        NOT_USED( pw );
}

/*------------------------------------------------------------------------------
 * module_service
 *
 *      Module service call entry point.
 */
void
module_service( int service_no, _kernel_swi_regs *r, void *pw )
{
#ifdef RCA
        switch ( service_no )
        {
                case Service_Standby:
                        storedinfo_standby( r, pw );
                        break;

                case Service_ErrorStarting:
                        storedinfo_errorstarting( r, pw );
                        break;
        }
#endif
}


int main(int argc, char *argv[])
/*
 * Entered in user-mode with argc and argv
 * Check the command line arguments and react as reqd.
 *
 * Commands are ......
 *          UnitTest Single test_pattern
 *          UnitTest Cont   test_pattern stop_on_failure cycle_count duration
 * argv === 0        1      2            3               4           5
 * argc === 1        2      3            4               5           6
 */
{
        int args_ok=TRUE;
        int test_pattern=0;
        int stop_failure=0;
        int target_cycle=0;
        float target_duration=0;
        int test_mode;

        /* Check that argc is >=2, other wise we haven't been given any arguments */

        if (argc>=2){
                /* argv[0] is the module name so bin it. */
                /* argv[1] is the test mode ... switch on it */

                /* make the test mode argument is all lower case */
                strlwr(argv[1]);
                /* now validate it, if ok rtn test mode number, else rtn -1 */
                test_mode = validate_mode(argv[1]);
        
                switch ( test_mode )
                {
                        case MODE_USER:
                                /* we've been asked to do USER_MODE testing */
                                /* Check that we have 1 ARGUMENT (3 inc cmd and test mode) */
                                if (argc!=3){
                                        /* incorrect number of args */
                                        /* return an error ..... HOW !!!!!!! */
                                        printf("Incorrect number of arguments .....\n");
                                }else{
                                        /* Correct number of args ... check it */
                                        /* Its the test pattern int 0->2^32 - thus can't really check it*/
                                        test_pattern=atoi(argv[2]);
                                        user_diag_test( MODE_USER, test_pattern, 0, 1, 0 );
                                }
                                break;
        
                        case MODE_LIFE:
        
                                if (argc !=6){
                                /* we've been asked to do LIFE_CYCLE testing */
                                /* Check that we have 4 ARGUMENTS (6 inc cmd and test mode) */
                                        /* incorrect number of args */
                                        /* return an error ..... HOW !!!!!!! */
                                        printf("Incorrect number of arguments .....\n");
                                }else{
                                        /* Correct number of args ... check them */
                                        /* Test pattern 0-2^32 - thus can't really check it*/
                                        /* Stop on failure 0 or 1 */
                                        /* cycle count 0-999999 */
                                        /* duration 0-9999.99 */
                                        test_pattern=atoi(argv[2]);
                                        stop_failure=atoi(argv[3]);
                                        target_cycle=atoi(argv[4]);
                                        target_duration=atof(argv[5]);
                                        if (stop_failure==0){
                                                stop_failure=FALSE;
                                        }else{
                                                stop_failure=TRUE;
                                        }
                                        if ((target_cycle) <0 && (target_cycle>999999)){
                                                /* target_cycle NOT in range */
                                                /* Report the error ... HOW */
                                                args_ok=FALSE;
                                        }else{
                                                /* target_cycle in range */
                                        }
                                        if ((target_duration<0) && (target_duration>9999.99)){
                                                /* target_cycle NOT in range */
                                                /* Report the error ... HOW */
                                                args_ok=FALSE;
                                        }else{
                                                /* target_duration in range */
                                        }
                                        if (args_ok!=FALSE){
                                                user_diag_test( MODE_LIFE, test_pattern, stop_failure, target_cycle, target_duration);
                                        }
                                }
                                break;
                        case -1:
                                /* well the test mode given wasn't correct .... moan */
                                printf("'%s' is an invalid Test Mode name\n",argv[1]);
                                break;
                }
        }else{
                /* Infufficent arguments */
                printf("Syntax : UnitTest Single <Test Pattern>\n");
                printf("Syntax : UnitTest Cont <Test pattern> <Stop On Failure> <Cycle Count> <Duration>\n");
        }
        return 1;

}
