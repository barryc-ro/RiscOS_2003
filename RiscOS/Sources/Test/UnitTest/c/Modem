/* >c.Modem

ACORN TEST SOFTWARE (c) Acorn Computers Ltd. 1997

************************* CHANGE LIST *************************************

Vers    Date            Name    Comment
------  ---------       ---     -------------------------------------------
1.00    21 Apr 97       BAR     Initial writing
1.01    08 May 97       BAR     Now logs its status
1.02    04 Jun 97       BAR     Fixed code...not UART0_ just UART_, changed
                                line check to dial with wait '###' - check
                                response for no dialtone.
1.03    05 Jun 97       BAR     Remove read & reset timer .. now in support
1.04    16 Sep 97       RLT     Added Daytona specific code to test the 2
                                internal modems.
1.05    16 Oct 97       RLT     Added Daytona version of Modem_Test.
1.07    11 Nov 97       RLT     Added DaytonaHW_WimpMessages to stop Wimp
                                messages from being issued.
1.08    18 Nov 97       RLT     Modified Modem_Test to actually calculate the
                                overall test status correctly.
1.09    19 Nov 97       RLT     Removed numerous modem_wait function calls.
1.10	20 Jan 98	RLT	Modified loopback and line check sub tests
				to only appear as one test.
1.11	21 Jan 98	RLT	Modified Modem_Test () to only run line_check ()
				in single cycle mode.


Will perform a modem test
*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "support.h"
#include "module.h"
#include "Modem.h"
#include "display.h"
#include "Msgs.h"
#include "Dialler.h"

#ifdef MACHDaytona
# include "Serial.h"                                   /* Daytona serial port routines */
# include "types.h"				       /* Type definitions used for the buffer manager (bufman.s) */
# include "bufman.h"				       /* Buffer manager C interface header file */
# include "daytonahw.h"
# include "diallerb.h"
#endif

 /*
 send an ATZ                     (reset)
 wait for OK

 do rom checksum, use ATI2 ... does and compares checksum :  OK or ERROR

 send ATDPW###                   (Dial Tone with Wait)
 wait for ok or no-dialtone
 send ATH0                       (Off Line / On Hook)
 wait for ok
 */


/*
 * buffer handles
 */
#ifdef MACHDaytona
static int iInputBuffer0, iOutputBuffer0;             /* Buffer handles in form which can be used by bufman */
static int iInputBuffer2, iOutputBuffer2;
static int iFileInput, iFileOutput;
#endif
static int iInputBuffer1, iOutputBuffer1;
#ifndef MACHDaytona
static int  iSpeed = 38400;
static int  iStatus = 258;
#endif
static int  iCarrierSpeed = 28800;
#ifndef MACHDaytona
static char strFormat[] = "n.1.8";
#endif
static int  swi_error = 0;

static char *psd[] = {"n.1.8","n.1.7","n.1.6","n.1.5","n.2.8","n.2.7",
       	    	         "n.2.6","n.1.5.5","o.1.8","o.1.7","o.1.6","o.1.5",
       	    	         "o.1.8","o.2.7","o.2.6","o.2.5","n.1.8","n.1.7",
       	    	         "n.1.6","n.1.5","n.2.8","n.2.7","n.2.6","n.1.5.5",
       	    	         "e.1.8","e.1.7","e.1.6","e.1.5","e.1.8","e.2.7",
       	    	         "e.2.6","e.2.5","n.1.8","n.1.7","n.1.6","n.1.5",
       	    	         "n.2.8","n.2.7","n.2.6","n.1.5.5","1.1.8","1.1.7",
                         "1.1.6","1.1.5","1.1.8","1.2.7","1.2.6","1.2.5",
                         "n.1.8","n.1.7","n.1.6","n.1.5","n.2.8","n.2.7",
                         "n.2.6","n.2.5","0.1.8","0.1.7","0.1.6","0.1.5",
                         "0.1.8","0.2.7","0.2.6","0.2.5"};

static int baud_rate[] = {9600,75,150,300,1200,2400,4800,9600,19200,50,110,134,
       	   		   600,1800,3600,7200,38400,57600,115200};

/* Local function prototypes */
t_modem_resp receive_command(int iBuffer);
int loop_back_test(int InputBufferHandle0, int OutputBufferHandle0, int InputBufferHandle1, int OutputBufferHandle1);


int calculate_status (int test1,
                      int test2,
                      int error_base)
{
    int overall = FALSE;

    overall = ((test1 == TRUE) && (test2 == TRUE)) ? TRUE :
              ((test1 != TRUE) && (test2 != TRUE)) ? (test1 + test2) + error_base :
              (test1 != TRUE) ? test1 + error_base : test2 + error_base;

    return overall;
}


#ifdef MACHDaytona
void Modem_Test (int test_mode)
{
      int flagOK1 = FALSE,
          flagOK2 = FALSE,
          flagOK3 = FALSE,
          flagOK4 = FALSE,
          status;
      _kernel_swi_regs reg;

      display_status (MODEM, RUNNING);

      reg.r[0] = 1;
      _kernel_swi (DaytonaHW_WimpMessages, &reg, &reg);

      if (initialise_serial ())
      {
            flagOK1 = modem_checksum ();
            modem_wait (100);

            display_sub_test_status(MODEMLOOPBACK, RUNNING);
            flagOK3 = loop_back_test (iInputBuffer0, iOutputBuffer0, iInputBuffer1, iOutputBuffer1);
            if (flagOK3 != ERROR_LOOPBACK_MALLOC_FAILED)
            {
                modem_wait (100);
                flagOK4 = loop_back_test (iInputBuffer1, iOutputBuffer1, iInputBuffer0, iOutputBuffer0);
                if (flagOK4 != TRUE)
                {
                    flagOK4 = 1 << flagOK4;
                    flagOK4 = flagOK4 * 1024;
                }
                if (flagOK3 != TRUE)
                {
                    flagOK3 = 1 << flagOK3;
                }
                flagOK3 = calculate_status (flagOK3, flagOK4, 0x00100000);
                display_sub_test_status(MODEMLOOPBACK, flagOK3);
            }
            else
            {
                display_sub_test_status(MODEMLOOPBACK, flagOK3);
            }

            if (test_mode == MODE_USER)
            {
                modem_wait (100);
                flagOK2 = line_ok ();
            }
            else
            {
                /* bodge fix here...  as there is a problem with the fake exchange swi, we can't use line_ok () in life mode
                   as the machine falls over dead, so fix it here to automatically pass if it's life mode */
                flagOK2 = TRUE;
            }
      }
      if (test_mode == MODE_USER)
      {
          /* same story as above.  dialler doesn't need to be used if fake exchange isn't and to cut down on possible problems,
             take it out unless it's running single cycle */
          do
          {
              _swix (DiallerB_Status, _IN (0) | _OUT (0), 0, &status);
          } while ((status & Dialler_ConnectedFlagsMask) != Dialler_Disconnected);
      }

      Serial_Close_Ports ();
      if ((flagOK1 == TRUE) && (flagOK2 == TRUE) && (flagOK3 == TRUE))
          status = PASSED;
      else
          status = FAILED;
      display_status (MODEM, status);
      log_status (MODEM, status);
}


#else

void Modem_Test(int test_mode)
{
        int status=FALSE;

/* debugging flag */
/* flagDebugging=TRUE; */

        display_status(MODEM,RUNNING);

        status=initialise_serial();
        if (status==TRUE){
                /* initilised the serial comms to modem  */
                status=modem_checksum();
                if ((status==TRUE) && (test_mode==MODE_USER)){
                        /* do the connection subtest */
                        status=line_ok();
                }
        }
        display_status(MODEM,status);
        log_status(MODEM,status);
}
#endif

int modem_checksum()
/* Check the modem Checksum is ok.
 */
{
       int flagTestOK = TRUE;        /* Assume passed */
       int rtn  = FALSE,
           rtn2 = FALSE;

        display_sub_test_status(MODEMROMCHECK,RUNNING);
        flush_buffer(iInputBuffer1);
        transmit(iOutputBuffer1,"ATZ",CR);
        flagTestOK = wait_for_ok(TIMEOUT,flagTestOK,iInputBuffer1);
        if (flagTestOK==TRUE){
                /* reset ok ... ask to check its checksum */
                flush_buffer(iInputBuffer1);
                /* Ask modem to cal. checksum and rtn OK or ERROR */
                transmit(iOutputBuffer1,"ATI2",CR);
                flagTestOK = wait_for_ok(TIMEOUT,flagTestOK,iInputBuffer1);
                if (flagTestOK==TRUE)
                {
                        rtn = TRUE;
                }
                else
                {
                        /* failed rtn the reqd. fail code. */
                        rtn = 1 << ERROR_CHECKSUM_ATI2_FAILED;
                }
        }
        else
        {
                /* failed to reset ... fail it */
                /* rtn the reqd. fail code. */
                rtn = 1 << ERROR_CHECKSUM_ATZ_FAILED;
        }
/*         display_sub_test_status(MODEMROMCHECK, rtn); */
/*
 * The duplicate code below will only be linked if DAYTONA has been defined, as to
 * check the checksum of the second modem.
 */

#ifdef MACHDaytona
/*         display_sub_test_status(MODEMROM2CHECK,RUNNING); */
        flush_buffer(iInputBuffer0);
        transmit(iOutputBuffer0,"ATZ",CR);
        flagTestOK = wait_for_ok(TIMEOUT,flagTestOK,iInputBuffer0);
        if (flagTestOK==TRUE){
                /* reset ok ... ask to check its checksum */
                flush_buffer(iInputBuffer0);
                /* Ask modem to cal. checksum and rtn OK or ERROR */
                transmit(iOutputBuffer0,"ATI2",CR);
                flagTestOK = wait_for_ok(TIMEOUT,flagTestOK,iInputBuffer0);
                if (flagTestOK==TRUE)
                {
                        rtn2 = TRUE;
                }
                else
                {
                        /* failed rtn the reqd. fail code. */
                        rtn2 = 1 << (ERROR_CHECKSUM_ATI2_FAILED + 2);
                }
        }
        else
        {
                /* failed to reset ... fail it */
                /* rtn the reqd. fail code. */
                rtn2 = 1 << (ERROR_CHECKSUM_ATZ_FAILED + 2);
        }

        rtn = calculate_status (rtn, rtn2, 0x00100100);

        display_sub_test_status(MODEMROMCHECK,rtn);
#endif
        return rtn;
}


#ifdef MACHDaytona
int line_ok()
/* Check that we can hear the dial tone
 */
{
        int flagTestOK = TRUE;          /* Assume passed */
        int rtn=TRUE;
        _kernel_swi_regs reg;
        _kernel_oserror *e;

        display_sub_test_status(MODEMLINECHECK,RUNNING);
        flush_buffer(iInputBuffer0);
        transmit(iOutputBuffer0,"ATZ",CR);
        flagTestOK = wait_for_ok(TIMEOUT,flagTestOK,iInputBuffer0);
        if (flagTestOK==TRUE){
                /* reset ok ... ask to check the line */

                reg.r[0] = 0;
                reg.r[1] = iInputBuffer2;
                reg.r[2] = iOutputBuffer2;
                reg.r[3] = iFileInput;
                reg.r[4] = iFileOutput;
                reg.r[5] = 2000;
                reg.r[6] = 0;
                e = _kernel_swi(DaytonaHW_FakeExchange, &reg, &reg);
                if (e)
                {
                      printf ("%s\n", e->errmess);
                }

                flush_buffer(iInputBuffer0);
                transmit(iOutputBuffer0,"ATDTW###",CR);

                /* Wait for no_dialtone or Time Out */
                /* If no_dialtone ... fail */
                /* If time out ... pass */
                /* flagTestOK set as reqd. */
                flagTestOK=wait_for_nodialtone(TIMEOUT*3,flagTestOK,iInputBuffer0);
                if (flagTestOK==FALSE){
                        rtn=ERROR_LINETEST_NODIALTONE;
                        debug printf("error no dialtone\n");
                }

                reg.r[0] = 1;
                e = _kernel_swi(DaytonaHW_FakeExchange, &reg, &reg);
                if (e)
                {
                      printf ("%s\n", e->errmess);
                }

                /* OFF Line check */
                flush_buffer(iInputBuffer0);
                transmit(iOutputBuffer0,"ATH0",CR);
                flagTestOK = wait_for_ok_or_nocarrier(TIMEOUT,flagTestOK,iInputBuffer0);
                if (flagTestOK==FALSE){
                        if (rtn==TRUE){
                                /* rtn hasn't changed, add error_base to number */
                                rtn=ERROR_BASE+ERROR_LINETEST_ATH0_FAILED;
                        }else{
                                /* rtn has changed, don't add this error to current rtn value */
                                rtn=rtn + ERROR_LINETEST_ATH0_FAILED;
                        }
                }
        }else{
                /* failed to reset ... fail it */
                /* rtn the reqd. fail code. */
                rtn=ERROR_LINETEST_ATZ_FAILED;
                debug printf("error atz failed\n");
        }
        display_sub_test_status(MODEMLINECHECK,rtn);
        return rtn;
}
#else
int line_ok()
/* Check that we can hear the dial tone
 */
{
        int flagTestOK = TRUE;          /* Assume passed */
        int rtn=TRUE;

        display_sub_test_status(MODEMLINECHECK,RUNNING);
        flush_buffer(iInputBuffer1);
        transmit(iOutputBuffer1,"ATZ",CR);
        flagTestOK = wait_for_ok(TIMEOUT,flagTestOK,iInputBuffer1);
        if (flagTestOK==TRUE){
                /* reset ok ... ask to check the line */

                flush_buffer(iInputBuffer1);
                transmit(iOutputBuffer1,"ATDTW###",CR);

                /* Wait for no_dialtone or Time Out */
                /* If no_dialtone ... fail */
                /* If time out ... pass */
                /* flagTestOK set as reqd. */

                flagTestOK=wait_for_nodialtone(TIMEOUT*3,flagTestOK,iInputBuffer1);
                if (flagTestOK==FALSE){
                        rtn=ERROR_LINETEST_NODIALTONE;
                }

                /* OFF Line check */
                flush_buffer(iInputBuffer1);
                transmit(iOutputBuffer1,"ATH0",CR);
                flagTestOK = wait_for_ok_or_nocarrier(TIMEOUT,flagTestOK,iInputBuffer1);
                if (flagTestOK==FALSE){
                        if (rtn==TRUE){
                                /* rtn hasn't changed, add error_base to number */
                                rtn=ERROR_BASE+ERROR_LINETEST_ATH0_FAILED;
                        }else{
                                /* rtn has changed, don't add this error to current rtn value */
                                rtn=rtn + ERROR_LINETEST_ATH0_FAILED;
                        }
                }
        }else{
                /* failed to reset ... fail it */
                /* rtn the reqd. fail code. */
                rtn=ERROR_LINETEST_ATZ_FAILED;
        }
        display_sub_test_status(MODEMLINECHECK,rtn);
        return rtn;
}
#endif

#ifdef MACHDaytona
/*
 *           Funtion: loop_back_test
 * Parameters passed:  In: InputBufferHandle0  - Input buffer of dialing modem
 *                         OutputBufferHandle0 - Output buffer of dialing modem
 *                         InputBufferHandle1  - Input buffer of answering modem
 *                         OutputBufferHandle1 - Output buffer of answering modem
 *                    Out: Returns TRUE if passed, else error number
 */

int loop_back_test(int InputBufferHandle0,
                   int OutputBufferHandle0,
                   int InputBufferHandle1,
                   int OutputBufferHandle1)
{
  int rtn                   = TRUE;
  char *pointer_to_rom_base = (char *) 0x03810000;                  /* pointer to an address in ROM to read our test data from */
  char *read_buffer;                                                /* buffer to read data into */
  int loop;
  int flagTestOK            = TRUE;


  debug printf("Variables set up\nAllocating memory for buffer...\n");

  read_buffer = (char *) malloc(READ_BUFFER_SIZE);                  /* allocate memory for our read buffer */
  if (read_buffer)
  {
    debug printf("Flushing serial buffers\n");
    flush_buffer(InputBufferHandle0);
    flush_buffer(InputBufferHandle1);
    debug printf("Reseting modems\n");
    transmit(OutputBufferHandle0, "AT&F%C3W1S95=53", CR);           /* reset 1st modem and setup error correction */
    transmit(OutputBufferHandle1, "AT&F%C3W1S95=53", CR);           /* reset 2nd modem and setup error correction*/
    if (wait_for_ok(TIMEOUT, flagTestOK, InputBufferHandle0)
       && wait_for_ok(TIMEOUT, flagTestOK, InputBufferHandle1))     /* check if modems reset okay */
    {
      debug printf("Modems reset OK\n");
      flush_buffer(InputBufferHandle0);
      debug  printf("Disabling dial tone check on receiving modem\n");
      transmit(OutputBufferHandle0, "ATX0", CR);                    /* disable the dial tone check on receiving modem*/
      if (wait_for_ok(TIMEOUT, flagTestOK, InputBufferHandle0))
      {
        debug printf("OK\n");
        flush_buffer(InputBufferHandle1);
        debug printf("Disabling adaptive answering on receiving modem\n");
        transmit(OutputBufferHandle1, "AT+FAE=0", CR);              /* disable adaptive answering on receiving modem */
        if (wait_for_ok(TIMEOUT, flagTestOK, InputBufferHandle1))
        {
          debug printf("OK\n");
          flush_buffer(InputBufferHandle0);
          flush_buffer(InputBufferHandle1);
          debug printf("Dialing other modem\n");
          transmit(OutputBufferHandle0, "ATD", CR);                 /* make dialling modem dial */
          transmit(OutputBufferHandle1, "ATA", CR);                 /* set receiving modem to auto answer */
          if (wait_for_connect(6000, flagTestOK, InputBufferHandle0, InputBufferHandle1))
          {
            debug printf("\n\nConnected\n\n");
            flush_buffer(InputBufferHandle0);
            flush_buffer(InputBufferHandle1);
            loop = 0;
            while (rtn == TRUE && loop < READ_BUFFER_SIZE)
            {
              if (!put_char(OutputBufferHandle0, *(pointer_to_rom_base + loop)))  /* send test data byte, read from ROM */
              {
                debug printf("byte could not be sent\n");
                rtn = ERROR_LOOPBACK_SENDING_DATA;                  /* aborting if an error occured */
              }
              loop++;                                               /* loop until error or all data has been sent */
            }
            debug printf("%d bytes sent OK\nReading data from the remote modem\n", loop);
            if (rtn == TRUE)
            {
              loop = 0;
              while (loop < READ_BUFFER_SIZE)
              {
                debug printf("Reading bytes... (%d)\n", loop);
                if (examine_buffer(InputBufferHandle1) == 0)        /* if the receive buffer contains bytes */
                {
                  read_buffer[loop] = (char) get_char(InputBufferHandle1);  /* read them into the read_buffer array */
                  debug printf("%c\n", read_buffer[loop]);
                  loop++;                                           /* and increment our read bytes counter */
                }
              }
              debug printf("%d bytes read OK\nComparing two sets of data...\n", loop);
              pointer_to_rom_base = (char *) 0x03810000;            /* pointer in memory to where we started reading the data */
              loop = 0;
              while (rtn == TRUE && loop < READ_BUFFER_SIZE)
              {
                debug printf("Comparing... (%d)\n", loop);
                if (*pointer_to_rom_base++ != read_buffer[loop])    /* are the two sets the same? */
                {                                                   /* if not, abort with error */
                  debug printf("Error, not the same (%c : %c)\n", *pointer_to_rom_base, read_buffer[loop]);
                  rtn = ERROR_LOOPBACK_DATA_NOT_SAME;
                }
                loop++;                                             /* otherwise move onto the next byte */
              }
            }
            flush_buffer(InputBufferHandle0);
            debug printf("Putting remote modem back into command mode\n");
            transmit(OutputBufferHandle0, "+++", 0);                /* put the dialing modem back to command mode for AT cmds */
            if (wait_for_ok(TIMEOUT, flagTestOK, InputBufferHandle0))
            {
              flush_buffer(InputBufferHandle0);
              debug printf("Hanging up remote modem\n");            /* hang up the connection */
              transmit(OutputBufferHandle0, "ATH", CR);
              if (!wait_for_ok_or_nocarrier(TIMEOUT, flagTestOK, InputBufferHandle0))
              {
                debug printf("Can't hangup!\n");
                rtn = ERROR_LOOPBACK_ATH_2;
              }
            }
            else
            {
              debug printf("Failed to enter command mode...\n");
              rtn = ERROR_LOOPBACK_CMD_MODE_2;
            }
          }
          else
          {
            flush_buffer(InputBufferHandle0);
            debug printf("Timeout\n");
            transmit(OutputBufferHandle0, "+++", 0);
            if (wait_for_ok(TIMEOUT, flagTestOK, InputBufferHandle0))
            {
              flush_buffer(InputBufferHandle0);
              transmit(OutputBufferHandle0, "ATH", CR);
              if (!wait_for_ok_or_nocarrier(TIMEOUT, flagTestOK, InputBufferHandle0))
              {
                debug printf("Can't hangup! (after connect failed)\n");
                rtn = ERROR_LOOPBACK_ATH_1;
              }
            }
            else
            {
              debug printf("Can't enter command mode (after connect failed)\n");
              rtn = ERROR_LOOPBACK_CMD_MODE_1;
            }
          }
        }
        else
        {
          debug printf("Error disabling ataptive answering\n");
          rtn = ERROR_LOOPBACK_ATFAE_FAILED;
        }
      }
      else
      {
        debug printf("Error ATX failed\n");
        rtn = ERROR_LOOPBACK_ATX_FAILED;
      }
    }
    else
    {
      debug printf("Error resetting modems\n");
      rtn = ERROR_LOOPBACK_ATZ_FAILED;
    }
    free(read_buffer);
  }
  else
  {
    debug printf("Error malloc() failed\n");
    rtn = ERROR_LOOPBACK_MALLOC_FAILED;
  }
  return rtn;
}

/*
 * flush_test_buffer takes a pointer to a buffer in memory, and the size of the
 * buffer and will fill it with NULL terminators.
 */

void flush_test_buffer(char *buffer, int size)
{
  while (size != 0)                                     /* Are we at the end of the buffer? */
  {
    buffer[size--] = '\0';                              /* Set byte in the buffer to NULL terminator */
  }
}
#endif							/* End of Daytona loop back and ring test code */

/*
 * Wait for the modem to say OK or No Carrier
 * iTimeLimit    Time limit to wait for
 * iCmdBuf       Buffer to look for retned commands
 * flagTestOK    Indicates current status of test; passed in order to preserve, if needed.
 */

int
wait_for_ok_or_nocarrier(int iTimeLimit, int flagTestOK, int iCmdBuf)
{
        t_timer timer;      	  /* timeout timer */
        int flagTimedOut = FALSE;
        t_modem_resp rx_cmd = nothing;

        /* wait for OK OR no_carrier */
        timer_reset(&timer);
        while ((rx_cmd !=ok) && (rx_cmd!=no_carrier) && (flagTimedOut != TRUE)){
                rx_cmd=receive_command(iCmdBuf);
                if (timer_read(&timer)>iTimeLimit){
                        /* Timed out */
                        flagTestOK = FALSE;
                        flagTimedOut = TRUE;
                        debug display_info(modem_test_msg[00]);
                }
        }
        return flagTestOK;
}

/*
 * Wait for the modem to say no-dialtone
 * iTimeLimit    Time limit to wait for
 * iCmdBuf       Buffer to look for retned commands
 * flagTestOK    Indicates current status of test; passed in order to preserve, if needed.
 */
int
wait_for_nodialtone(int iTimeLimit, int flagTestOK, int iCmdBuf)
{
        t_timer timer;      	  /* timeout timer */
        int flagTimedOut = FALSE;
        int abort=FALSE;
        t_modem_resp rx_cmd = nothing;

        /* wait for OK or No Dail Tone Or to time out, latter to rtn false else rtn true. */
        timer_reset(&timer);
        while ((flagTimedOut != TRUE) && (abort==FALSE)){
                /* while we're waiting ... check in buffer */
                rx_cmd=receive_command(iCmdBuf);
                if (rx_cmd==no_dialtone){
                        /* we got a no dial tone response */
                        flagTestOK=FALSE;
                        abort=TRUE;
                        debug display_info(modem_test_msg[01]);
                }
               if (timer_read(&timer)>iTimeLimit){
                       /* Timed out */
                        flagTimedOut = TRUE;
                }
        }
        return flagTestOK;
}

/*
 * clear everything out of the given buffer
 */

#ifdef MACHDaytona

void flush_buffer(int iBuffer)
{
  buffermanager_purge(iBuffer);
  modem_wait(10);
}

#else

void
flush_buffer(int iBuffer)
{
  _kernel_swi_regs reg;

  while (examine_buffer(iBuffer)==0)
  {
    reg.r[0] = 21;                      /* flush buffer */
    reg.r[1] = iBuffer;
    _kernel_swi(OS_Byte, &reg, &reg);
    modem_wait(10);
  }
}

#endif

/*
 * insert characters in the serial output buffer followed by a newline
 * character.
 */
void
transmit(int iBuffer, char *strCommand, char chTerminate)
{
  if (strCommand!=NULL)
  {
    /*printf("tx:'%s'\n",strCommand);*/
    /*printf("in     transmit (hex): '%x'\n", *strCommand);*/
    while (*strCommand != NULL)
    {
      /*printf("send   transmit (hex): '%x'\n", *strCommand);*/
      if (!put_char(iBuffer,*strCommand++)) return;   /* exit if problem */
    }
    if (chTerminate != 0) put_char(iBuffer,chTerminate);
  }
}

/*
 * Wait for the modem to say OK
 * iTimeLimit    Time limit to wait for
 * iCmdBuf       Buffer to look for retned commands
 * flagTestOK    Indicates current status of test; passed in order to preserve, if needed.
 */

int
wait_for_ok(int iTimeLimit, int flagTestOK, int iCmdBuf)
{
        t_timer timer;      	  /* timeout timer */
        int flagTimedOut = FALSE;
        t_modem_resp rx_cmd = nothing;

        /* wait for OK */
        timer_reset(&timer);
        while ((rx_cmd !=ok) && (flagTimedOut != TRUE)){
                rx_cmd=receive_command(iCmdBuf);
                if (timer_read(&timer)>iTimeLimit){
                        /* Timed out */
                        flagTestOK = FALSE;
                        flagTimedOut = TRUE;
                        debug display_info(modem_test_msg[00]);
                }
        }
        return flagTestOK;
}

#ifdef MACHDaytona
int
wait_for_connect(int iTimeLimit, int flagTestOK, int iCmdBuf0, int iCmdBuf1)
{
        t_timer timer;      	  /* timeout timer */
        int flagTimedOut = FALSE;
        t_modem_resp rx_cmd0 = nothing;
        t_modem_resp rx_cmd1 = nothing;
        int flagConnect  = FALSE;
        int flagConnect0 = FALSE;
        int flagConnect1 = FALSE;

        /* wait for CONNECT */
        timer_reset(&timer);
        while ((flagConnect != TRUE) && (flagTimedOut != TRUE)){
                rx_cmd0=receive_command(iCmdBuf0);
                rx_cmd1=receive_command(iCmdBuf1);
                if (rx_cmd0 == connect)
                {
                  flagConnect0 = TRUE;
                }
                if (rx_cmd1 == connect)
                {
                  flagConnect1 = TRUE;
                }
                if ((flagConnect0 == TRUE) && (flagConnect1 == TRUE))
                  flagConnect = TRUE;
                if (timer_read(&timer)>iTimeLimit){
                        /* Timed out */
                        flagTestOK = FALSE;
                        flagTimedOut = TRUE;
                        debug display_info(modem_test_msg[00]);
                }
        }
        return flagTestOK;
}

#endif

/*
 * compare two strings caselessly
 */
int caseless_strcmp(char *a, char *b, int len)
{
        int d;
        while ( (*a || *b) && len)
        {
                d = toupper( *(a++) ) - toupper( *(b++) );
                if (d) return d;
                len--;
        }
        return 0;
}

/*
 * return state of c flag, 1 = buffer empty, 0 = bytes present.
 */
#ifdef MACHDaytona
int examine_buffer(int iBuffer)
{
  if (buffermanager_get_nused(iBuffer) > 0)
    return 0;
  else
  {
    return 1;
  }
}

#else

int
examine_buffer(int iBuffer)
{
  int iCarry;
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;

  reg.r[0] = 152;                     /* Examine buffer state */
  reg.r[1] = iBuffer;
  err = _kernel_swi_c(OS_Byte, &reg, &reg, &iCarry);
  if (err)
    return (1);

  return (iCarry);
}
#endif

/*
 * get a terminated string from an input buffer, returns 1 if string read,
 * 0 if timeout.
 */
int
get_modem_response(int iBuffer, char *strBuffer, int size)
{
  t_timer timer;      	  /* timeout timer */
  int i=0;
  int ch;

  timer_reset(&timer);
  do
  {
    ch = get_char(iBuffer);

    if (ch>-1)
      if (ch!=10 && ch !=13) strBuffer[i++] = (char)ch;

    strBuffer[i] = 0;
    if (timer_read(&timer) > TIMEOUT)
    {
      return (0);
    }

  } while (ch!=10 && ch!=13 && i<size);

  return (i?1:0);
}

/*
 * check for any data in the input buffer, if data present, extract it.
 */
t_modem_resp
receive_command(int iBuffer)
{
  char strBuffer[BUFFER_SIZE];
  int iThisCarrierSpeed;

  if (!examine_buffer(iBuffer))   /* Examine input buffer */
  {
    if (get_modem_response(iBuffer,strBuffer,sizeof(strBuffer)))
    {
      if (caseless_strcmp(strBuffer,"connect",7) ==0)
      {
        debug printf("RX Cmd '%s'\n",strBuffer);
        return (connect);
      }
      else if (caseless_strcmp(strBuffer,"protocol",8) == 0)
      {
        debug printf("RX Cmd '%s'\n",strBuffer);
        if (caseless_strcmp(strBuffer+strlen("protocol: "),"none",4) == 0)
          return (protocol_err);
        else if (caseless_strcmp(strBuffer+strlen("protocol: "),"lap-m",5) == 0)
          return (protocol_lapm);
        else if (caseless_strcmp(strBuffer+strlen("protocol: "),"alt",4) == 0)
          return (protocol_alt);
        else
          return (protocol_err);
      }
      else if (caseless_strcmp(strBuffer,"carrier",7) == 0)
      {
        debug printf("RX Cmd '%s'\n",strBuffer);
        iThisCarrierSpeed = atoi(strBuffer + strlen("carrier "));
        if (iThisCarrierSpeed < iCarrierSpeed)
          return (carrier_slow);
        else
          return (carrier_ok);
      }
      else if (caseless_strcmp(strBuffer,"no carrier",10) == 0)
        return (no_carrier);
      else if (caseless_strcmp(strBuffer,"no answer",9) == 0)
        return (no_answer);
      else if (caseless_strcmp(strBuffer,"no dialtone",10) == 0)
        return (no_dialtone);
      else if (caseless_strcmp(strBuffer,"busy",4) == 0)
        return (busy);
      else if (caseless_strcmp(strBuffer,"ring",4) == 0)
        return (ring);
      else if (caseless_strcmp(strBuffer,"ok",2) == 0)
        return (ok);
      else if (strcmp(strBuffer,TRANSFER0) == 0)
	return (transferred);
      else if (caseless_strcmp(strBuffer,"at",2) == 0) /* ignore echos */
      {
        debug printf("RX Cmd at:'%s'\n",strBuffer);
      }
      else
      {
        debug printf("RX Cmd rx:'%s'\n",strBuffer);
      }
    }
  }
  return (nothing);
}

#ifdef MACHDaytona
/*
 * Place a character in buffer iBuffer.
 * Returns TRUE if successful, FALSE otherwise.
 */
int put_char(int iBuffer, char ch)
{
//      printf ("putting: %c\n", ch);
  if (buffermanager_put_byte(iBuffer, ch) == 0)
    return TRUE;
  else
    return FALSE;
}

/*
 * Removes a character from iBuffer.
 * Returns character if one present, -1 otherwise.
 */
int get_char(int iBuffer)
{
//      char c;
//
//      c = buffermanager_get_byte(iBuffer);
//      printf ("got: %c\n", c);
//      return c;
  return (buffermanager_get_byte(iBuffer));
}

#else

/*
 * place given buffer in output buffer and perform timeout checks.
 * Return TRUE if success, FALSE otherwise.
 */
int
put_char(int iBuffer, char ch)
{
  _kernel_swi_regs reg;
  int     iCarry;                /* carry flag returned from SWI */
  t_timer out_timer;      	  /* timeout timer for output buffer */

  timer_reset(&out_timer);

  reg.r[0] = 138;                 /* Insert byte into buffer */
  reg.r[1] = iBuffer;
  reg.r[2] = (int)ch;
  do
  {
    _kernel_swi_c(OS_Byte, &reg, &reg, &iCarry);
    if (iCarry == 1 && timer_read(&out_timer) >= TIMEOUT)
      return (FALSE);
  } while (iCarry == 1);

  return (TRUE);
}

/*
 * remove character from input buffer, character if one present, -1 otherwise
 */
int
get_char(int iBuffer)
{
  _kernel_swi_regs reg;
  _kernel_oserror *err=NULL;
  int iCarry;

  reg.r[0] = 145;                      /* Get byte from buffer */
  reg.r[1] = iBuffer;
  err = _kernel_swi_c(OS_Byte, &reg, &reg, &iCarry);
  if (err != NULL)
  {
    error_generate(err);
    return (-1);
  }
  if (iCarry == 0)
    return (reg.r[2]);

  return (-1);
}

#endif

/*
 * waits for given number of centiseconds
 */
void modem_wait(long time)
{
        t_timer timer;

        if (time>0){
                timer_reset(&timer);
                while (timer_read(&timer) < time) ;
        }
}


/*
 * set up default baud rates, handshaking etc and initialise the internal
 * serial port, modem card 0 and modem card 1
 *
 * Two different initialise_serial() functions are needed as the UART_ SWIs are
 * not available in Daytona's ROM.
 */

#ifndef MACHDaytona                                         /* Non Daytona initialise_serial() function */
int
initialise_serial(void)
{

        _kernel_oserror *err = NULL;
        _kernel_swi_regs reg;
        int iInitSerialOK = TRUE;

        /* Setup the internal serial port */
        err = _kernel_swi(UART_GetBufferHandles, &reg, &reg);
        if (err !=0)
        {
                return ERROR_INIT_SERIAL_BUFFERS;
        }
        iInputBuffer1 = reg.r[0];
        iOutputBuffer1= reg.r[1];

        reg.r[0] = RxBaud;
        reg.r[1] = conv_baud_serialop(iSpeed);
        err = _kernel_swi(UART_SerialOp, &reg, &reg);
        if (err !=0)
        {
                return ERROR_INIT_SERIAL_RXSPEED;
        }

        reg.r[0] = TxBaud;
        reg.r[1] = conv_baud_serialop(iSpeed);
        err = _kernel_swi(UART_SerialOp, &reg, &reg);
        if (err !=0)
        {
                return ERROR_INIT_SERIAL_TXSPEED;
        }

        reg.r[0] = SerialStatus;
        reg.r[1] = iStatus;
        reg.r[2] = 0;
        err = _kernel_swi(UART_SerialOp, &reg, &reg);
        if (err !=0)
        {
                return ERROR_INIT_SERIAL_STATUS;
        }

        reg.r[0] = DataFormat;
        reg.r[1] = conv_psd_serialop(strFormat);
        err = _kernel_swi(UART_SerialOp, &reg, &reg);
        if (err !=0)
        {
                return ERROR_INIT_SERIAL_DATA;
        }
        return iInitSerialOK;
}
#else                                                   /* Daytona initialise_serial() function */
int initialise_serial(void)
{
  _kernel_oserror *err;
  int iInitSerialOK = TRUE;

  err = Serial_Open_Ports();                            /* Called from Serial.c */
  if (err)
  {
    return ERROR_INIT_SERIAL_PORTS;
  }
  iInputBuffer0  = buffermanager_get_internalID(Modem[REMMODEM].BufferIn); /* Phone modem; remote; external */
  iOutputBuffer0 = buffermanager_get_internalID(Modem[REMMODEM].BufferOut);
  iInputBuffer1  = buffermanager_get_internalID(Modem[LOCMODEM].BufferIn); /* Fax modem; local; internal */
  iOutputBuffer1 = buffermanager_get_internalID(Modem[LOCMODEM].BufferOut);
  iInputBuffer2  = Modem[LOCMODEM].BufferIn;
  iOutputBuffer2 = Modem[LOCMODEM].BufferOut;
  iFileInput     = Modem[LOCMODEM].FileIn;
  iFileOutput    = Modem[LOCMODEM].FileOut;
  return iInitSerialOK;
}
#endif                                                  /* End of Daytona initialise_serial() function */

/*
 * convert a numeric baud rate value to a OS_SerialOp index
 */
int
conv_baud_serialop(int baud)
{
  int i=0;

  while (i<MAX_BAUD)
  {
    if (baud_rate[i]==baud) return (i);
    i++;
  }

  return (0);
}


/*
 * convert the data format string expressed as <p.s.d> to the lowest
 * OS_SerialOp 1 representation. Return -1 if unsuccessful.
 */
int
conv_psd_serialop (char *formatstr)
{
  int i = 0;
  int serialopval = -1;           /* -1 is "illegal string" */

  do
  {
    if (strcmp(psd[i], formatstr) == 0 ) serialopval = i;
    i++;
  } while ( (i < 64) && (serialopval == -1) );

  return (serialopval);
}


/*
 * capture unknown error message
 */
void
error_generate(_kernel_oserror *err)
{
        /* if debug available then show error on screen */
        debug printf("ERROR %s (0x%x)\n",err->errmess,err->errnum);
        swi_error=ERROR_GET_CHAR_SWI_FAILED;
}

/*
 * test_connection
 * tests a connection between two modems by scanning the keyboard buffer
 * for key presses, sending the character across the modem link if there
 * a key is pressed, then printing the character got from the other modem
 * to the screen.
 */

void test_connection(int InputBuffer0, int OutputBuffer0, int InputBuffer1, int OutputBufer1)
{
  int carry_flag;
  _kernel_swi_regs reg;

  while (reg.r[2] != (char) '~')                         /* character to terminate the loop and exit function */
  {
    reg.r[0] = 145;                                      /* get character from buffer */
    reg.r[1] = 0;					 /* keyboard buffer */
    _kernel_swi_c(OS_Byte, &reg, &reg, &carry_flag);
    if (carry_flag == 0)	   	                 /* character present in buffer */
    {
      if (!put_char(OutputBuffer0, (char) reg.r[2]))
      {
        debug printf("Error sending byte.\n");                 /* could not send byte */
      }
    }
    if (examine_buffer(InputBuffer1) == 0)               /* has the byte appeared at the other modem yet? */
    {
      printf("%c", (char) get_char(InputBuffer1));       /* if so, print it! */
    }
  }
}

