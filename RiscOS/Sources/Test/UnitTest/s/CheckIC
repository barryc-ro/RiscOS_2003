; >CheckIC
;
; ACORN TEST SOFTWARE (c) Acorn Computers Ltd 1990-98.
;
; *********************** CHANGE LIST *************************************
;
; Vers  Date            Name    Comment
; ----- ----------      ---     -------------------------------------------
; 1.00	27 Jan 98	RLT	Created
;


	GET	h.SWINames

	AREA	|C$$Code|, CODE, READONLY

	EXPORT	CheckIC
CheckIC
	MOV	r2, lr				; Preserve original mode
	ORR	r1, r2, #1:SHL:27:OR:3		; Switch to SVC mode disabling interrupts
	SWI	OS_EnterOS			; Enter SVC mode
	TEQP	r1, #0				; Disable interrupts
	STMFD	sp!, {r2}
	STMFD	sp!, {r4-r9}			; Push registers to the stack

	LDR	r1, setup_value			; Load the address to poke
	MOV	r2, #&92			; Move the value to poke to r2
	STRB	r2, [r1]			; Set the chip to read mode

	MOV	r8, #0				; No errors have yet occurred
	LDR	r3, check_word			; Put the check word in r3

	LDR	r1, base_address		; Put the base address in r2
	LDR	r0, [r1]			; Load r1 with the address to check
	CMP	r0, r3				; Check the value against the check word
	BLNE	examine				; If they're not equal, branch to examine

	ADR	r2, address_words + 0

	LDR	r1, [r2], #4
	LDR	r0, [r1]
	CMP	r0, r3
	BLNE	examine

	LDR	r1, [r2], #4
	LDR	r0, [r1]
	CMP	r0, r3
	BLNE	examine

	LDR	r1, [r2]
	LDR	r0, [r1]
	CMP	r0, r3
	BLNE	examine

	LDR	r1, base_address		; Put the base address in r2
	MOV	r4, #1				; Set the loop counter to 1
	MOV	r5, #&20000			; Move &20000 to r5 - Offset
loop
	ADD	r1, r1, r5			; Add offset to base address
	LDR	r0, [r1]			; Load r0 with the address
	CMP	r0, r3				; Check the value against the check word
	BLNE	examine				; If they're not equal, branch to examine
	ADD	r4, r4, #1			; Increment the loop counter
	CMP	r4, #16				; Check the loop counter to see if it's 16
	BNE	loop				; If not, carry on looping

	MOV	r0, r8				; Set up r0 with return value

	LDMFD	sp!, {r4-r9}			; Pull registers from the stack
	LDMFD	sp!, {r2}
	MOVS	pc, r2				; Restore original mode/interrups and return

examine
						; r1 = the address to examine

	STMFD	sp!, {r2-r7}			; Preserve original values from caller

						; Set up IC chip to read the status flags
	ADR	r2, write_addresses + 0
	ADR	r3, write_values + 0
	LDR	r7, [r2], #4
	LDR	r6, [r3], #4
	STR	r6, [r7]

	LDR	r7, [r2], #4
	LDR	r6, [r3], #4
	STR	r6, [r7]

	LDR	r7, [r2]
	LDR	r6, [r3]
	STR	r6, [r7]

	; Now check the status bits are not set
	LDR	r3, [r1, #8]			; Load r3 with the status flag
	; Check low half word is clear.
	LDR	r4, mask1			; Load r4 with mask#1 (&0000FFFF)
	AND	r4, r3, r4			; AND the needed bits of the flag
	CMPS	r4, #0				; Check to see if any of the bits are set
	ORRNE	r8, r8, #1			; if not equal, OR 1 into r8

	; check high half word is clear.
	LDR	r4, mask2			; Load r4 with mask#2 (&FFFF0000)
	AND	r4, r3, r4			; AND the needed bits of the flag
	MOV	r4, r4, LSR #16			; Shift value of r4 to the right by 16 bits
	CMPS	r4, #0				; Check to see if any of the bits are set
	ORRNE	r8, r8, #2			; if not equal, OR 2 into r8

	LDR	r7, base_address
	LDR	r2, read_value
	STR	r2, [r7]

	LDMFD	sp!, {r2-r7}			; Restore original registers
	MOV	pc, lr				; Return to caller



check_word
	DCD	&ffffffff			; Word containing the 'erased' value

base_address
	DCD	&03c00000			; Base address of flash

address_words
	DCD	&03c08000			; Non standard addresses to check
	DCD	&03c0c000
	DCD	&03c10000

write_addresses
	DCD	&03c15554			; Addresses to set write mode
	DCD	&03c0aaa8
	DCD	&03c15554

write_values
	DCD	&00aa00aa			; Values to store to the write addresses
	DCD	&00550055
	DCD	&00900090

read_value
	DCD	&00f000f0			; Value to disable write mode

setup_value
	DCD	&03200080

mask1
	DCD	&0000ffff

mask2
	DCD	&ffff0000

	END
