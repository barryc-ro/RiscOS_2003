 REM    >PRINTER TEST- Based on 'ExtPorts'
 REM    ACORN TEST SOFTWARE.
 REM
 REM    ************************ CHANGE LIST *******************************
 REM
 REM    Vers    Date            Name    Comment
 REM    ------  ---------       ---     ------------------------------------
 REM                                    See mod_list for earlier changes.
 REM    2.22    19-Nov-93       DB      Change order do serial then parallel. Better order 
 REM                                    when failures from port tester. Config should aid 
 REM                                    the fault reporting aswell.
 REM    2.23    22-Feb-94       DB      Add if medusa do baud speed test at 38400.
 REM    2.24    09-Jun-94       DB      If tests fail update report file if enabled. Also if 
 REM                                    enabled append code related to failure to string.
 REM                                    Fix bug if gnd_failure during parallel port test 
 REM                                    then it should pause for space, it did not, now 
 REM                                    fixed.
 REM    2.25    20-Jun-94       DB      Add if Medusa Dealer (ie Granada) use new loopback 
 REM                                    plug hence change data patterns for serial test.
 REM    2.26    05-Aug-94       DB      Fix bug in writing to report file. When creating new 
 REM                                    report file program did not write to it.
 REM    2.27    16-Aug-94       DB      Make result% local in init and autofeed tests.
 REM    2.28    17-Aug-94       DB      Change order of data test so that the last test leaves
 REM                                    the bus in a driven state. Write &AA to data so that 
 REM                                    state of data can be easily read. Create new read data,
 REM                                    status functions and write data procedures that do not
 REM                                    alter dir bit, hence leave data bus driven. Increase
 REM                                    reporting to report file when failures occur during 
 REM                                    parallel port test. 
 REM    2.29    26-Aug-94       BAR     Fix two bugs, in serial code. The
 REM                                    general test rate was not
 REM                                    configurable. The Baud Rate test did
 REM                                    not stop when asked.
 REM  **** Printer test created by adapting ExtPorts  ***
 REM    0.01    09-Feb-99      NCE      Hacked out the old Serial stuff to create a stand alone
 REM					printer test. Removed 'Set_Test_Bits' - we don't want
 REM					to write to CMOS.  Also removed JP101 option.
 REM					Removed most of the serial test stuff. 

 REM This program will test the printer port.
 REM This program will be called from the C program UnitTest

 REM This test program will check the cmos ram to ensure that this porgram
 REM is required to be run. If required then the program will test the
 REM printer by outputting a series of horizontal lines to the attached
 REM printer the program checks the cmos ram for the type of printer being
 REM used. The program checks the RS423 serial port by the use of the
 REM appropiate loop back plug.
 REM Note: This program requires at least 2K of RMA to be free. Usually
 REM this is not a problem.


 REM Failure codes that will be written to the report file.

 REM Serial Port Test Failures

 REM 10              Cannot find Port Tester or Port Tester version invalid.
 REM 
 REM 21              Epson graphic failure.
 REM 22              JP101 graphic failure.
 REM 
 REM 31              Epson send text failure.
 REM 32              Epson send text failure.
 REM 
 REM 41-47           RS423 Test data lines bit test
 REM 49              RS423 Test data line pattern &55
 REM 4A              RS423 Test data line pattern &AA
 REM 
 REM 51-62           Baud Rate Test - test at each baud rate
 REM 68              Baud rate Speed Test
 REM 
 REM 71              Comm state test.
 REM 
 REM B1 - B5         RS423 Control line Test

                              
 REM Parallel port Test Failures.

 REM C1      Data Output Failure.
 REM         Also written to report file are result flags for each
 REM         bit set and clear. All should be true (-1)
 REM C2      Data Input Failure.
 REM         Also written to report file are result flags for each
 REM         bit set and clear. All should be true (-1)
 REM C3      Input Control line Failure.
 REM         further message will be written for each sub test.
 REM                 Ack low, high to low, low to high, low
 REM                 Busy high, high to low, low to high, low
 REM                 PE high, low to high, high to low, low
 REM                 Selectin low, low to high, high to low, high
 REM                 Error low, low to high, high to low, high
 REM 
 REM         Each test returns a true false flag dependent on the 
 REM         sub test result. True = -1, False =0.
 REM         All should be -1.
 REM 
 REM C4      Init Control Line.
 REM C5      Selectin Control Line.
 REM C6      Autofeed Control Line.
 REM C7      Ground Test. During above test the ground signals on 
 REM         the connector changed state.
 REM C8      Power / Ground Test. Cable not connected between UUT  
 REM         and Port Tester or Ground not seen by Port Tester.  
 REM         Could be serial or parallel cable.



 REM Main Program
 PROCload_librarys
 PROCinit
 PROCtitle(title$,prog_ver$)
 PROCprinter_test
 test_status% = FNdecide_test_status
 PROCdisplay_status(test_status%)
 PROCpress_space(test_status%)
 PROCviewport(0)
 END

 DEFPROCinit
   REM This procedure will prepare the program.
   VDU 6                  :  REM Turn the screen on
   MODE 7
   PROClibrary_init  
 REM   IF FNcheck_port_tester >= &10000 THEN
 REM     portstester% = TRUE
 REM   ELSE
      portstester% = FALSE
 REM   ENDIF
   ON ERROR PROCerror_trap
   REM Define global constants
     title$         = "EXTERNAL PORTS TEST"
     prog_ver$      = "1.00"
     date$          = "09.02.99"
   REM Define global variables
     printer_status% = FAIL
     serial_status%  = FAIL
     econet_status%  = FAIL
     do_printer%     = TRUE
     do_serial%      = FALSE
     do_econet%      = FALSE
     gnd_failure%    = FALSE
   REM Define a global constant
     RUNNING          = 2
   REM Define the text messages.
     not_doing_msg$        = "NOT DOING "
     running_msg$          = "RUNNING   "
     passed_msg$           = "PASSED    "
     failed_msg$           = "FAILED    "
     test_msg$             = "TEST."
     printer_msg$          = "PRINTER "
     serial_msg$           = "SERIAL "
     econet_msg$           = "ECONET "
     port_msg$             = "PORT "
     unknown_printer_msg1$ = "The printer type held in the CMOS"
     unknown_printer_msg2$ = "RAM is not known by this program."
     unknown_printer_msg3$ = "The CMOS RAM or the Test Disc has"
     unknown_printer_msg4$ = "been corrupted, refer to ACORN"
     unknown_printer_msg5$ = "Computers Ltd for advice."
     printer_online_msg1$  = "The printer is not responding."
     printer_online_msg2$  = "Check that the printer is ONLINE."
     DIM port_test_msg$(24)
     port_test_msg$(4)     = "PARALLEL, Printer Graphic Test."
     port_test_msg$(5)     = "PARALLEL, Printer Text Test."
     port_test_msg$(6)     = "SERIAL,   Control Line Test."
     port_test_msg$(7)     = "SERIAL,   Data Line Test."
     port_test_msg$(8)     = "SERIAL,   Baud Rate Test."
     port_test_msg$(9)     = "SERIAL,   Comms. State Test."
     port_test_msg$(10)    = "PARALLEL, PORT TESTER TEST."
     port_test_msg$(11)    = "PARALLEL, Data Test."
     port_test_msg$(12)    = "PARALLEL, IO Line Test."
     port_test_msg$(13)    = "PARALLEL, Power / Gnd Test."
     port_test_msg$(14)    = "PARALLEL, Ground Test"

     port_test_msg$(15)    = "PARALLEL, Acknowledge Test"
     port_test_msg$(16)    = "PARALLEL, Busy Test"
     port_test_msg$(17)    = "PARALLEL, Paper Error Test"
     port_test_msg$(18)    = "PARALLEL, Select Test"
     port_test_msg$(19)    = "PARALLEL, Error Test"
     port_test_msg$(20)    = "PARALLEL, Init Test"
     port_test_msg$(21)    = "PARALLEL, Selectin Test"
     port_test_msg$(22)    = "PARALLEL, Autofeed Test"
     port_test_msg$(23)    = "PARALLEL, Data Output Test"
     port_test_msg$(24)    = "PARALLEL, Data Input Test"

     DIM port_test_line%(10)
     port_test_line%(0)    = 0
     port_test_line%(1)    = 0
     port_test_line%(10)   = 0
     port_test_line%(2)    = 3
     port_test_line%(3)    = 3
     port_test_line%(4)    = 1
     port_test_line%(5)    = 2
     port_test_line%(6)    = 4
     port_test_line%(7)    = 5
     port_test_line%(8)    = 7
     port_test_line%(9)    = 6
     dis_line%=0
     Medusa%               = FNIs_a_Medusa
     Failure$              = ""
 ENDPROC

 DEFFNIs_a_Medusa
   LOCAL a%,b%,c%,d%,flag%,machine_type%

   PROCtest_info(a%,b%,c%,d%)
   machine_type%  = (a% AND &FF) >> 4
   IF machine_type% = 9 THEN
        flag% = TRUE
   ELSE
        flag% = FALSE
   ENDIF
  = flag%



 DEFPROCload_librarys
   REM This procedure will load the required library files for the
   REM crc checker routines, the procedure will check the version
   REM number to insure the latest is used.
   LOCAL ERROR
   ON ERROR LOCAL PROClibrary_error(0)
   LIBRARY "Test:GEN_LIB"
   library_version% = FNlibrary_version
   IF library_version% < 176 THEN
       PROClibrary_error(53)
     ENDIF
 ENDPROC

 DEFPROClibrary_error(special_error%)
   REM This procedure will provide error handling for the library
   REM loading procedure.
   LOCAL error_number%
   LOCAL error_line%
   error_number% = ERR
   error_line% = ERL
   IF special_error% >= 53 THEN
       error_number% = special_error%
       CASE error_number% OF
           WHEN 53
             PRINT "General library is out of date."
           WHEN 54
             PRINT "MOS library is out of date."
           WHEN 55
             PRINT "CRC library is out of date."
         ENDCASE
     ENDIF
   REPORT
   PRINT "ERROR NUMBER ";error_number%;" AT ";error_line%
   ON ERROR OFF
   OSCLI "BYE"
   OSCLI "SHUTDOWN"
   END
 ENDPROC


 DEFFNdecide_test_status
   REM This function will decide if this test has psssed or failed, by
   REM checking the sub test do flags and the sub test status flags. The
   REM function wil then return PASS or FAIL.
   LOCAL test_status%
   test_status% = PASS
   IF do_printer% = TRUE AND printer_status% = FAIL THEN
       test_status% = FAIL
     ENDIF
   IF do_serial%  = TRUE AND serial_status%  = FAIL THEN
       test_status% = FAIL
     ENDIF
   IF do_econet%  = TRUE AND econet_status%  = FAIL THEN
       test_status% = FAIL
     ENDIF
 = test_status%

 
 DEFPROCport_test_status(status%,port_test_numb%,failure%)
   REM This procedure will tell the user the status of the specified
   REM sub test. The procedure will show if the sub test has passed or failed
   REM or if the test is running.
   REM The message is first displayed as running then overwritten with the
   REM pass/ fail message. The line the text is displayed on is updated from where
   REM this procedure is called. If the failure message is displayed the report 
   REM file will also be written to if enabled. A code for the sub-test failure
   REM will also be sent to the file not to the screen. This should enable the 
   REM failure to be diagnosed down to the actual test that failed.
   REM status% = RUNNING ... show RUNNING
   REM status% = FAIL    ... show FAILED
   REM status% = PASS    ... show PASSED
   LOCAL ctrl$
   LOCAL message$
   CASE status% OF
       WHEN RUNNING
         ctrl$    = cyan$
         message$ = running_msg$+port_test_msg$(port_test_numb%)
       WHEN PASS
         ctrl$    = green$
         message$ = passed_msg$+port_test_msg$(port_test_numb%)
       WHEN FAIL
         ctrl$    = red$
         message$ = failed_msg$+port_test_msg$(port_test_numb%)
         PROCUpdate_report_file(message$+" "+STR$~(failure%))
   ENDCASE
   PROCclear_line(2,dis_line%)
   PROCprint_result(2,dis_line%,ctrl$,message$)
   IF (status% = PASS OR status%=FAIL) THEN
        dis_line%=dis_line%+1
   ENDIF
 ENDPROC



 DEFPROCUpdate_report_file(text$)
   REM This function will first check that writing to the report file is
   REM enabled. If it is it will either open or create the report file 
   REM and ensure that the pointer for the file is at the end. It will 
   REM then write to the file if it can be opened / created, then write
   REM the last entry marker, and close the file.

   LOCAL filename$
   LOCAL file_length%, file%, enable%

   REM force no test report
   REM enable% = FNread_syst_variable("TEST$REPORT_FILE")
   REM enable% = 0
   IF (enable% AND &01) = 1 THEN
        filename$ = "<TEST$REPORT_DIR>.<TEST$REPORT_NAME><TEST$MACHINE_NUMBER>"
        file% = OPENUP(filename$)
        IF file% = 0 THEN
                REM not found
                file% = OPENOUT(filename$)
                IF  file% = 0 THEN
                        REM Cannot open file
                        file% = 0
                ELSE
                        REM Created the file, set its type to text
                        OSCLI("SETTYPE "+filename$+" Text")
                        BPUT#file%,text$
                        BPUT#file%,Failure$
                        BPUT#file%,"¤";
                        CLOSE#file%
                ENDIF
        ELSE
                REM File found, set the pointer to the end, less 1.
                REM This removes the marker.
                file_length% = EXT#file%
                PTR#file% = file_length% - 1
                BPUT#file%,text$
                BPUT#file%,Failure$
                BPUT#file%,"¤";
                CLOSE#file%
        ENDIF
   ENDIF
 ENDPROC                    
           

 DEFPROCno_test(test_number%)
   REM This procedure will tell the user that a test was not selected.
   LOCAL ctrl$
   LOCAL message$
   ctrl$ = cyan$
   CASE test_number% OF
       WHEN 1
         PROCclear_line(2,0)
         PROCprint_result(2,0,ctrl$,not_doing_msg$+printer_msg$+port_msg$+test_msg$)
       WHEN 2
         PROCclear_line(2,3)
         PROCprint_result(2,3,ctrl$,not_doing_msg$+serial_msg$+port_msg$+test_msg$)
       WHEN 3
         PROCclear_line(2,8)
         PROCprint_result(2,8,ctrl$,not_doing_msg$+econet_msg$+port_msg$+test_msg$)
     ENDCASE
 ENDPROC

 DEFPROCprinter_test
   REM This procedure will test the operation of the printer port.
   LOCAL magic_number%
   LOCAL checksum%
   LOCAL printer_type%
   LOCAL test_type%
  REM This reads the CMOS RAM so throw it away
  REM PROCtest_info(magic_number%,checksum%,printer_type%,test_type%)
  REM set test_type to 1 for now, previously set by above function
   test_type%=1      
   PROCprinter_init(test_type%)
   PROCepson_init
   PROCepson_printer
 ENDPROC

 DEFPROCprinter_init(test_type%)
   REM This procedure will set up some variables etc for the printer tests
   REM Find out the size of the printer buffer
     SYS "OS_Byte",21,3
     printer_buffer_size% = ADVAL -4
   REM Define how long we wait for the printer to take the printed stuff.
     min_printer_time%    = 2
     max_printer_timeout% = 3
   REM Define the test text strings
     number_text_strings% = 2
     DIM printer_test_text$(number_text_strings%)
     printer_test_text$(0) = "the quick brown fox jumps over the lazy dog."
     printer_test_text$(1) = "THE QUICK DOG JUMPS OVER THE LAZY BROWN FOX."
     IF test_type% = 8 OR test_type% = 9 THEN
         REM DRAT & PRAT Test Only.
         printer_test_text$(2) = "`1234567890-=£[]\;',./~!@#$%^&*()_+¤{}|:<>?"+" "+TIME$
       ELSE
         REM The rest.
         printer_test_text$(2) = "`1234567890-=£[]\;',./~!@#$%^&*()_+¤{}|:<>?"
       ENDIF
 ENDPROC

 DEFPROCunknown_printer
   REM This procedure will tell the user that an unknown printer was
   REM found from the CMOS RAM.
   LOCAL ctrl$
   LOCAL message$
   ctrl$ = red$
   PROCprint_line(2,1,ctrl$,unknown_printer_msg1$)
   PROCprint_line(2,2,ctrl$,unknown_printer_msg2$)
   PROCprint_line(2,4,ctrl$,unknown_printer_msg3$)
   PROCprint_line(2,5,ctrl$,unknown_printer_msg4$)
   PROCprint_line(2,6,ctrl$,unknown_printer_msg5$)
   PROCpress_space(FALSE)
   PROCclear_viewport(2)
 ENDPROC


 DEFPROCepson_printer
   REM This procedure will test an Epson printer.
   LOCAL test1%
   LOCAL test2%
   LOCAL test1_2%
   LOCAL pnum%
   
   pnum% = 0
   PROCport_test_status(RUNNING,4,0)
   test1% =  FNepson_graphic
   PROCport_test_status(test1%,4,&21)
   PROCport_test_status(RUNNING,5,0)
   test2% = FNsend_text
   PROCport_test_status(test2%,5,&31)
   test1_2% = FNshow_test_status(test1%,test2%)
   IF portstester% THEN
       IF FNto_io_tester(":CENTRONICS:STOP;:") <> portsOK% THEN
           test1_2% = FAIL
         ENDIF
     ENDIF
 ENDPROC


 DEFPROCepson_init
   REM This procedure will initialise variables for the Epson test.
   REM Epson printer parameters
     Maxpattern = 2
     Maxbit = 7
     Maxdot = 22
     IF portstester% THEN
         Maxdot = 5
       ENDIF
     Maxline =2
     Pattern = Maxdot * Maxpattern * (Maxbit + 1)
     No_ofBitImage = Pattern
     LoByte = No_ofBitImage MOD 256
     HiByte = No_ofBitImage DIV 256
 ENDPROC

 DEFFNepson_graphic
   REM This function will print the graphic test for Epson printers.
   REM The function will then check that the printer buffer has emptied. If
   REM the buffer does not empty with in defined limits, then the sub test
   REM has failed, else the sub test has passed.
   LOCAL buffer_empty%
   LOCAL printer_sub_test%
   LOCAL ptok%,verfok%

   ptok% = TRUE
   verf% = TRUE
   IF portstester% THEN
       IF FNto_io_tester(":CENTRONICS:ACCEPT 1B400D0A") <> portsOK% THEN
           ptok% = FALSE
         ENDIF
     ENDIF
   VDU2
   REM Send 'Reset' to the printer only.
     VDU1,27,1,64
   REM Send 'CR' and 'LF' to the printer only.
     VDU1,13,1,10

   FOR line% = 1 TO Maxline
     IF portstester% THEN
         IF FNto_io_tester("START") <> portsOK% THEN
           ptok% = FALSE
         ENDIF
       ENDIF
     PROCepsontest
     REM Send 'CR' and 'LF' to the printer only.
       VDU1,13,1,10
     REM Now read & check printer output
     IF portstester% THEN
         IF NOT FNverify_graph(FNfrom_io_tester("READ")) THEN
             verf% = FALSE
           ENDIF
       ENDIF
   NEXT line%

   IF portstester% THEN
       IF FNto_io_tester("ACCEPT 0D0A1B40") <> portsOK% THEN
           ptok% = FALSE
         ENDIF
     ENDIF
   REM Send 'CR' and 'LF' to the printer only.
     VDU1,13,1,10
   REM Send 'Reset' to the printer only.
     VDU1,27,1,64

   REM Now that we have sent the information, we check to see if the printer
   REM buffer has been emptied.
   buffer_empty% = FNcheck_buffer
   IF buffer_empty% = FALSE THEN
       SYS "OS_Byte",21,3
       printer_sub_test% = FALSE
     ELSE
       printer_sub_test% = TRUE
     ENDIF
   VDU3
 = printer_sub_test% AND ptok% AND verf%


 DEFPROCepsontest
   VDU1,27,1,ASC"*",1,0,1,LoByte,1,HiByte
   FOR pattern=1 TO Maxpattern
     FOR bit=0 TO Maxbit
       code= 2^bit
       FOR dot=1 TO Maxdot
         VDU1,code
       NEXT
     NEXT
   NEXT
 ENDPROC

 DEFFNverify_graph(hex$)
   REM This function compares the calculated graphic print string with the hexified
   REM version returned by the port tester's printer emulator.
   REM Returns TRUE if they match, FALSE if not.
   REM The hex string is in the form "NN,aabbccddeeffgghh" etc. where NN is a byte count.
   LOCAL ll%
   LOCAL hix%
   LOCAL pattern%, bit%, code%, dot%

   REM check the received string is valid
   REM result should be "NN,1B2A00LLHH" + (2 * number of bytes) + "0D0A"
   IF LEN(hex$) <> (3+10+(Maxdot * (Maxbit+1) * Maxpattern * 2)+4) THEN
 = FALSE
   ENDIF

   REM Check the lead in (char count and escape sequence)
   ll% = EVAL("&"+LEFT$(hex$,2))
   IF ll% <> ((LEN(hex$)-3) / 2) THEN
 = FALSE
   ENDIF
   REM VDU1,27,1,ASC"*",1,0,1,LoByte,1,HiByte
   IF MID$(hex$,4,6) <> "1B2A00" THEN
 = FALSE
   ENDIF
   IF EVAL("&"+MID$(hex$,10,2)) <> LoByte OR EVAL("&"+MID$(hex$,12,2)) <> HiByte THEN
 = FALSE
   ENDIF

   REM recalculate the graphics loop, comparing with the received result
   hix% = 14
   FOR pattern%=1 TO Maxpattern
     FOR bit%=0 TO Maxbit
       code% = 2^bit%
       FOR dot%=1 TO Maxdot
         IF EVAL("&"+MID$(hex$,hix%,2)) <> code% THEN
 = FALSE
         ENDIF
         hix% += 2
       NEXT dot%
     NEXT bit%
   NEXT pattern%

   REM made it to the end .. so it must match
 = TRUE



 DEFPROCjp101_printer
   LOCAL test1%
   LOCAL test2%
   LOCAL test1_2%
   PROCport_test_status(RUNNING,4,0)
   test1% = FNjp101_graphic
   PROCport_test_status(test1%,4,&22)
   test2% =  FNsend_text
   PROCport_test_status(test2%,5,&32)
   test1_2% = FNshow_test_status(test1%,test2%)
 ENDPROC

 DEFPROCjp101_init
   REM This procedure will initialise some variables for the JP101 test.
   REM   Jet printer parameters
     Heightbytes = 8
     Pattern = 2
     Widthbytes=6
   REM "control$" is the code to define the Image for Jet
     control$= CHR$(27)+"G9;"+STR$(2*Widthbytes)+";"+STR$(Heightbytes)+";2"+CHR$(27)+"Z"
 ENDPROC

 DEFFNjp101_graphic
   REM This function will perform the JP101 graphic tests.
   REM The function will then check that the printer buffer has emptied. If
   REM the buffer does not empty with in defined limits, then the sub test
   REM has failed, else the sub test has passed.
   LOCAL buffer_empty%
   LOCAL printer_sub_test%
   VDU2
   REM Send 'Reset' to the printer only.
     VDU1,27,1,48
   REM Send 'CR' and 'LF' to the printer only.
     VDU1,13,1,10
   PROCjptest
   REM Send 'CR' and 'LF' to the printer only.
     VDU1,13,1,10
   REM Send 'Reset' to the printer only.
     VDU1,27,1,48
   REM Now that we have sent the information, we check to see if the printer
   REM buffer has been emptied.
   buffer_empty% = FNcheck_buffer
   IF buffer_empty% = FALSE THEN
       SYS "OS_Byte",21,3
       printer_sub_test% = FALSE
     ELSE
       printer_sub_test% = TRUE
     ENDIF
   VDU3
 = printer_sub_test%

 DEFPROCjptest
   FOR pattern = 1 TO Pattern
     REM Send CONTROL to printer
     FOR controlbyte=0 TO (LEN(control$)-1)
       VDU1,CONTROL?controlbyte
     NEXT
     FOR bit = 0 TO (Heightbytes-1)
       FOR line = 0 TO 7
         FOR no = 1 TO Widthbytes
           D = 1<<bit
           VDU1,D,1,0
         NEXT
       NEXT
     NEXT
   NEXT
 ENDPROC

 DEFPROCsetcontrol
   DIM CONTROL LEN(control$)
   $CONTROL = control$
 ENDPROC

 DEFFNsend_text
   REM This function will send some text to the printer (any).
   REM The function will then check that the printer buffer has emptied. If
   REM the buffer does not empty within defined limits, then the sub test
   REM has failed, else the sub test has passed.
   LOCAL length%
   LOCAL count%
   LOCAL chr$
   LOCAL chr%
   LOCAL buffer_empty%
   LOCAL printer_sub_test%
   LOCAL text_string%
   LOCAL test_text$
   LOCAL ptok%
   LOCAL verf%

   text_string% = -1
   ptok% = TRUE
   verf% = TRUE

   REM Turn on the printer
     VDU 2

   REPEAT

     REM Enable the ports tester pseudo printer
     IF portstester% THEN
         IF FNto_io_tester("START") <> portsOK% THEN
             ptok% = FALSE
           ENDIF
       ENDIF

     text_string% = text_string% + 1
     test_text$ = printer_test_text$(text_string%)
     length% = LEN(test_text$)
     FOR count% = 1 TO length%
       chr$ = MID$(test_text$,count%,1)
       chr% = ASC(chr$)
       VDU 1,chr%
     NEXT count%

     REM Read back what was printed
     IF portstester% THEN
         IF NOT FNverify_text(FNfrom_io_tester("READ"),test_text$) THEN
             verf% = FALSE
           ENDIF
       ENDIF

     REM Absorb the initial CRLF
     IF portstester% THEN
         IF FNto_io_tester(":CENTRONICS:ACCEPT 0D0A") <> portsOK% THEN
             ptok% = FALSE
           ENDIF
       ENDIF

     REM Send 'CR' and 'LF' to the printer only.
       VDU 1,13,1,10

   UNTIL text_string% >= number_text_strings%

  REM Send a CR/LF to the printer so that the last line IS printed from the PRINTERS buffer.
    REM Absorb the initial CRLF
REM      IF portstester% THEN
REM          IF FNto_io_tester(":CENTRONICS:ACCEPT 0D0A") <> portsOK% THEN
REM              ptok% = FALSE
REM            ENDIF
REM        ENDIF
    REM Send 'CR' and 'LF' to the printer only.
REM      VDU 1,13,1,10


   REM Now that we have sent the information, we check to see if the printer
   REM buffer has been emptied.
   buffer_empty% = FNcheck_buffer
   IF buffer_empty% = FALSE THEN
       SYS "OS_Byte",21,3
       printer_sub_test% = FALSE
     ELSE
       printer_sub_test% = TRUE
     ENDIF
   VDU 3

   REM and that the correct text was recieved

 = printer_sub_test% AND ptok% AND verf%



 DEFFNverify_text(hex$, ascii$)
   REM This function compares the transmitted (ascii) print string with the hexified
   REM version returned by the port tester's printer emulator.
   REM Returns TRUE if they match, FALSE if not.
   REM The hex string is in the form "NN,aabbccddeeffgghh" etc. where NN is a byte count.
   LOCAL ll%
   LOCAL ascix%
   LOCAL hix%

   REM hex string must be "NN," plus 2 chars for each char in the ascii string
   IF LEN(hex$) <> (LEN(ascii$) * 2) + 3 THEN
 = FALSE
   ENDIF
   ll% = EVAL("&"+LEFT$(hex$,2))
   IF ll% <> LEN(ascii$) THEN
 = FALSE
   ENDIF

   REM loop along the hex string, comparing with the ascii one
   hix% = 4 : REM point to the first pair in the hex string
   FOR ascix% = 1 TO ll%
     IF EVAL("&"+MID$(hex$,hix%,2)) <> ASC(MID$(ascii$,ascix%,1)) THEN
 = FALSE
     ENDIF
     hix% += 2
   NEXT ascix%

   REM made it to the end .. so it must match
 = TRUE




 DEFFNcheck_buffer
   REM This procedure will check that the printer buffer is empty.
   REM The function will return TRUE if the buffer is empty.
   REM False if the buffer is not empty.
   REM The function will wait for a specified time for the printer to do
   REM it's job, then check the printer buffer. If the buffer is not empty,
   REM then the function will wait again for the specified time and check
   REM once more this is repeated for a specified number of times.
   LOCAL
   LOCAL max_unchaned_buf%
   LOCAL max_print_attempt%
   LOCAL check_buf_delay%
   LOCAL now%
   LOCAL printer_buf_now%
   LOCAL printer_buf_pre%
   LOCAL count1%
   LOCAL count%
   LOCAL done_check_printer_online%
   LOCAL empty_buffer%
   REM Define local limits of operation
     check_buf_delay%   = 50
     max_unchaned_buf%  = 4
     max_print_attempt% = 3
   done_check_printer_online% = FALSE
   printer_buf_now% = 0
   printer_buf_pre% = 0
   count1%          = 0
   count%           = 0
   REPEAT
     REPEAT
       now% = TIME
       REPEAT
         printer_buf_now% = ADVAL -4
       UNTIL TIME >= now% + check_buf_delay%
       IF printer_buf_pre% = printer_buf_now% THEN
           REM buffer has not changed.
           count1% = count1% + 1
         ELSE
           count1% = 0
         ENDIF
       printer_buf_pre% = printer_buf_now%
     UNTIL count1% >= max_unchaned_buf% OR (printer_buf_now% = printer_buffer_size% AND printer_buf_pre% = printer_buffer_size%)
     count% = count% + 1
     IF count1% >= max_unchaned_buf% THEN
         REM After nn seconds the buffer had not changed.
         REM Time = max_unchaned_buf% X check_buf_delay%
         REM If it's not a real printer, give up straightaway
         IF portstester% THEN
             done_check_printer_online% = TRUE
             count% = max_print_attempt%
         ENDIF
         REM Ask user to check on-line.
         IF done_check_printer_online% = FALSE THEN
             done_check_printer_online% = TRUE
             PROCcheck_printer_online("on")
           ELSE
             PROCcheck_printer_online("off")
           ENDIF
       ENDIF
   UNTIL count% >= max_print_attempt% OR (printer_buf_now% = printer_buffer_size% AND printer_buf_pre% = printer_buffer_size%)
   IF count% < max_print_attempt% AND printer_buf_now% = printer_buffer_size% AND printer_buf_pre% = printer_buffer_size% THEN
       empty_buffer% = TRUE
     ELSE
       empty_buffer% = FALSE
     ENDIF
 = empty_buffer%

 DEFPROCcheck_printer_online(option$)
   REM This procedure will either prompt the user to check that the printer
   REM is ONLINE and prompt for the space bar to be ptessed or will clear
   REM the aforsaid message from the screen.
   LOCAL old_setting%
   option$ = FNto_lower(option$)
   REM Turn the 'copy text to printer' path off in the printer driver.
     SYS "OS_Byte",3,&04 TO ,old_setting%
   IF option$ = "on" THEN
       PROCprint_line(2,12,yellow$,printer_online_msg1$)
       PROCprint_line(2,13,yellow$,printer_online_msg2$)
       PROCpress_space(FALSE)
     ELSE
       PROCclear_line(2,12)
       PROCclear_line(2,13)
     ENDIF
   REM Restore the setting of the output streams.
     SYS "OS_Byte",3,old_setting%
 ENDPROC

 DEFFNshow_test_status(status1%,status2%)
   REM This procedure will show the user the status of the printer tests.
   REM The variable printer_status% is a GLOBAL variable.
   IF status1% = PASS AND status2% = PASS THEN
       printer_status% = PASS
     ELSE
       printer_status% = FAIL
     ENDIF
 = printer_status%

 DEFFNno_module_error
   REM This function will provide local error trapping for when we try to
   REM kill the RTC Adjust module.
   LOCAL return%
   IF ERR = 258 THEN
       REM No module
       return% = FALSE
     ELSE
       PROCerror_trap
     ENDIF
 = return%


DEFPROCUsePortTester
  LOCAL lock,dataout%,datain%,IOinput%
  LOCAL init%,selectin%,autofeed%,ground%

  ON ERROR PROCParallelerror(lock)
  lock = OPENOUT("Parallel:")
  ground% = FNCheckgnd
  IF ground% = TRUE THEN
        PROCport_test_status(PASS,13,0)
        PROCport_test_status(RUNNING,11,0)
        datain%  = FNTestDataIn
        dataout% = FNTestDataOut
        PROCWriteData(&AA) :REM Set data bus in driven state with known byte.     
        IF (dataout% AND datain%) THEN
                PROCport_test_status(PASS,11,0)
        ELSE
                IF (dataout% = FALSE) THEN
                        PROCport_test_status(FAIL,11,&C1)
                ELSE
                        PROCport_test_status(FAIL,11,&C2)
                ENDIF
        ENDIF
        IF (gnd_failure% = FALSE) THEN
                IOinput%  = FNTestInputControlLines
                IF (IOinput%=FALSE) THEN failcode%=&C3
                init% = FNTestInitLine
                IF (init%=FALSE) THEN 
                        failcode%=&C4
                        message$ = ""
                        message$ = failed_msg$+port_test_msg$(20)
                        PROCUpdate_report_file(message$+" "+STR$~(&C4))
                ENDIF
                IF (gnd_failure% = FALSE) THEN
                        selectin% = FNSelectin
                        IF (selectin% = FALSE) THEN 
                                failcode% = &C5
                                message$ = ""
                                message$ = failed_msg$+port_test_msg$(21)
                                PROCUpdate_report_file(message$+" "+STR$~(&C5))
                        ENDIF
                ENDIF
                IF (gnd_failure% = FALSE) THEN
                        autofeed% = FNTestAutofeed
                        IF (autofeed%=FALSE) THEN 
                                failcode% = &C6
                                message$ = ""
                                message$ = failed_msg$+port_test_msg$(22)
                                PROCUpdate_report_file(message$+" "+STR$~(&C6))
                        ENDIF
                ENDIF
                IF (gnd_failure% = TRUE) THEN
                        PROCport_test_status(FAIL,14,&C7)
                ELSE
                        IF (IOinput% AND init% AND selectin% AND autofeed%) THEN
                                PROCport_test_status(PASS,12,0)
                        ELSE
                                PROCport_test_status(FAIL,12,failcode%)
                        ENDIF
                ENDIF
        ELSE
                PROCport_test_status(FAIL,14,&C7)
        ENDIF
  ELSE
        PROCport_test_status(FAIL,13,&C8)
  ENDIF
  CLOSE#lock
  IF (dataout% AND datain% AND IOinput% AND init% AND selectin% AND autofeed% AND ground% AND gnd_failure%=FALSE) THEN
        printer_status% = PASS
  ELSE
        printer_status% = FAIL
  ENDIF
 ENDPROC




 DEFPROCParallelerror(ch%)
   IF ch%>0 THEN
        CLOSE#ch%
        ch%=0
   ENDIF
   PROCerror_trap
   END
 ENDPROC


 DEFFNCheckgnd
   LOCAL value%,Autofeed%,Init%,Selectin%,Gnd%

   PROCReadAllPortTesterLines(value%,Autofeed%,Init%,Selectin%,Gnd%)
   IF Gnd%=0 THEN
        flag% = TRUE
   ELSE
        flag% = FALSE
   ENDIF
 =flag%


 DEFFNTestDataOut
  REM Preset dataport all high. Clear line, check
  REM all lines from port tester. Repeat for all
  REM lines. Clear all lines, Set line, check all
  REM lines from port tester. testing output
  REM capability.

  LOCAL cbit0%,cbit1%,cbit2%,cbit3%,cbit4%
  LOCAL cbit5%,cbit6%,cbit7%,sbit0%,sbit1%
  LOCAL sbit2%,sbit3%,sbit4%,sbit5%,sbit6%
  LOCAL sbit7%
  LOCAL cbit_flag%, sbit_flag%, result%
  LOCAL message$

  cbit0% = FNTestWritedata(&FF,&FF - 1)
  cbit1% = FNTestWritedata(&FF,&FF - 2)
  cbit2% = FNTestWritedata(&FF,&FF - 4)
  cbit3% = FNTestWritedata(&FF,&FF - 8)
  cbit4% = FNTestWritedata(&FF,&FF - &10)
  cbit5% = FNTestWritedata(&FF,&FF - &20)
  cbit6% = FNTestWritedata(&FF,&FF - &40)
  cbit7% = FNTestWritedata(&FF,&FF - &80)
  sbit0% = FNTestWritedata(&00,1)
  sbit1% = FNTestWritedata(&00,2)
  sbit2% = FNTestWritedata(&00,4)
  sbit3% = FNTestWritedata(&00,8)
  sbit4% = FNTestWritedata(&00,&10)
  sbit5% = FNTestWritedata(&00,&20)
  sbit6% = FNTestWritedata(&00,&40)
  sbit7% = FNTestWritedata(&00,&80)
  IF cbit0% AND cbit1% AND cbit2% AND cbit3% AND cbit4% AND cbit5% AND cbit6% AND cbit7% THEN
        cbit_flag% = TRUE
  ELSE
        cbit_flag% = FALSE
        Failure$ = "Data Out Clear "+STR$(cbit0%)+":"+STR$(cbit1%)+":"+STR$(cbit2%)+":"+STR$(cbit3%)+":"+STR$(cbit4%)+":"+STR$(cbit5%)+":"+STR$(cbit6%)+":"+STR$(cbit7%)
        message$ = ""
        message$ = failed_msg$+port_test_msg$(23)
        PROCUpdate_report_file(message$+" "+STR$~(&C1))
  ENDIF
  IF sbit0% AND sbit1% AND sbit2% AND sbit3% AND sbit4% AND sbit5% AND sbit6% AND sbit7% THEN
        sbit_flag% = TRUE
  ELSE
        sbit_flag% = FALSE
        Failure$ = "Data Out Set "+STR$(sbit0%)+":"+STR$(sbit1%)+":"+STR$(sbit2%)+":"+STR$(sbit3%)+":"+STR$(sbit4%)+":"+STR$(sbit5%)+":"+STR$(sbit6%)+":"+STR$(sbit7%)
        message$ = ""
        message$ = failed_msg$+port_test_msg$(23)
        PROCUpdate_report_file(message$+" "+STR$~(&C1))
  ENDIF
  IF cbit_flag% AND sbit_flag% THEN
        result% = TRUE
  ELSE
        result% = FALSE
  ENDIF
=result%





 DEFFNTestWritedata(preset%,writedata%)
  REM Preset is the value yo set the signals before starting the
  REM test. Writedata is the value to write to the data bus.
  REM Write data to preset value, read all signal states from the
  REM port tester and log them. Change state of signal to be
  REM tested and compare state of all lines with states logged
  REM earlier. Return all signals to preset state.


  LOCAL flag%,Wflag%,resetflag%,result%
  LOCAL dvalue%,Autofeed%,Init%,Selectin%,Gnd%
  LOCAL datavalue%,WrAutofeed%,WrInit%,WrSelectin%,WrGnd%


  flag% = FNWriteDataRegister(preset%)
  PROCReadAllPortTesterLines(dvalue%,Autofeed%,Init%,Selectin%,Gnd%)
  Wflag% = FNWriteDataRegister(writedata%)
  PROCReadAllPortTesterLines(datavalue%,WrAutofeed%,WrInit%,WrSelectin%,WrGnd%)
  resetflag% = FNWriteDataRegister(preset%)

  IF ((WrAutofeed% = Autofeed%) AND (WrInit% =Init%) AND (WrSelectin% = Selectin%)) THEN
        IF ((WrGnd% = Gnd%) AND (flag% = TRUE) AND (dvalue% = preset%))THEN
                IF ((Wflag% = TRUE) AND (datavalue% = writedata%) AND (resetflag% = TRUE)) THEN
                        result% = TRUE
                ELSE
                        result%=FALSE
                ENDIF
        ELSE
                result%=FALSE
                IF (WrGnd% <>0 OR Gnd%<>0)THEN
                        gnd_failure% = TRUE
                ENDIF
        ENDIF
  ELSE
        result%=FALSE
  ENDIF
=result%





DEFFNTestDataIn
  REM Test the data bus input state.
  REM Set all signals high from the port tester.
  REM Change state of signal to be tested, check
  REM all other signals. Check initially high then
  REM low and reverse.

  LOCAL cbit0%,cbit1%,cbit2%,cbit3%,cbit4%
  LOCAL cbit5%,cbit6%,cbit7%,sbit0%,sbit1%
  LOCAL sbit2%,sbit3%,sbit4%,sbit5%,sbit6%
  LOCAL sbit7%
  LOCAL cbit_flag%, sbit_flag%, result%
  LOCAL message$

  cbit0% = FNReadDataPort(&FF,&FF-1)
  cbit1% = FNReadDataPort(&FF,&FF-2)
  cbit2% = FNReadDataPort(&FF,&FF-4)
  cbit3% = FNReadDataPort(&FF,&FF-8)
  cbit4% = FNReadDataPort(&FF,&FF-&10)
  cbit5% = FNReadDataPort(&FF,&FF-&20)
  cbit6% = FNReadDataPort(&FF,&FF-&40)
  cbit7% = FNReadDataPort(&FF,&FF-&80)
  sbit0% = FNReadDataPort(&00,1)
  sbit1% = FNReadDataPort(&00,2)
  sbit2% = FNReadDataPort(&00,4)
  sbit3% = FNReadDataPort(&00,8)
  sbit4% = FNReadDataPort(&00,&10)
  sbit5% = FNReadDataPort(&00,&20)
  sbit6% = FNReadDataPort(&00,&40)
  sbit7% = FNReadDataPort(&00,&80)
  IF cbit0% AND cbit1% AND cbit2% AND cbit3% AND cbit4% AND cbit5% AND cbit6% AND cbit7% THEN
        cbit_flag% = TRUE
  ELSE
        cbit_flag% = FALSE
        Failure$ = "Data In Clear "+STR$(cbit0%)+":"+STR$(cbit1%)+":"+STR$(cbit2%)+":"+STR$(cbit3%)+":"+STR$(cbit4%)+":"+STR$(cbit5%)+":"+STR$(cbit6%)+":"+STR$(cbit7%)
        message$ = ""
        message$ = failed_msg$+port_test_msg$(24)
        PROCUpdate_report_file(message$+" "+STR$~(&C2))        
  ENDIF
  IF sbit0% AND sbit1% AND sbit2% AND sbit3% AND sbit4% AND sbit5% AND sbit6% AND sbit7% THEN
        sbit_flag% = TRUE
  ELSE
        sbit_flag% = FALSE
        Failure$ = "Data In Set "+STR$(sbit0%)+":"+STR$(sbit1%)+":"+STR$(sbit2%)+":"+STR$(sbit3%)+":"+STR$(sbit4%)+":"+STR$(sbit5%)+":"+STR$(sbit6%)+":"+STR$(sbit7%)
        message$ = ""
        message$ = failed_msg$+port_test_msg$(24)
        PROCUpdate_report_file(message$+" "+STR$~(&C2))      
  ENDIF
  IF cbit_flag% AND sbit_flag% THEN
        result% = TRUE
  ELSE
        result% = FALSE
  ENDIF
=result%




DEFFNReadDataPort(preset%,data%)
  REM Set data bus from the port tester to preset% state.
  REM Check state from UUT. Set data bus from port tester
  REM to specific value to test one signal. Check state
  REM of all signals to check only one being tested has
  REM changed. Set data bus from port tester back to
  REM preset state. Check final state. Compare results
  REM to ensure correct actions.


  LOCAL presetflag%,pdrflag%,pstflag%,piodata%
  LOCAL pdata%,psdata%,flag%,wdrflag%,wstflag%
  LOCAL wiodata%,wdata%,wsdata%,result%
  LOCAL resetflag%,rstdflag%,rststflag,rstiodata%
  LOCAL rsdata%,rdata%

  presetflag% = FNSetPortTesterLine(0,preset%)

  pdrflag%    = FNReadDataRegister(pdata%)
  pstflag%    = FNReadStatusRegister(psdata%)
  piodata%    = FNReadAllIOControllines

  flag%    = FNSetPortTesterLine(0,data%)

  wdrflag% = FNReadDataRegister(wdata%)
  wstflag% = FNReadStatusRegister(wsdata%)
  wiodata% = FNReadAllIOControllines

  resetflag% = FNSetPortTesterLine(0,preset%)

  rstdflag%   = FNReadDataRegister(rdata%)
  rststflag%  = FNReadStatusRegister(rsdata%)
  rstiodata%  = FNReadAllIOControllines

  IF (presetflag% AND pdrflag% AND pstflag% AND wdrflag% AND wstflag%) THEN
        IF (resetflag% AND rstdflag% AND rststflag%) THEN
                IF ((piodata% = wiodata%) AND (piodata% = rstiodata%)) THEN
                        IF ((psdata% = wsdata%) AND (psdata%=rsdata%)) THEN
                                IF ((pdata%=preset%) AND (wdata% = data%) AND (rdata%=preset%)) THEN
                                        result% = TRUE
                                ELSE
                                        result% = FALSE
                                ENDIF
                        ELSE
                                result% = FALSE
                        ENDIF
                ELSE
                        result% = FALSE
                ENDIF
        ELSE
                result% = FALSE
        ENDIF
  ELSE
        result% = FALSE
  ENDIF
=result%




DEFFNTestInputControlLines

  LOCAL lack%,lhack%,hlack%,hack%
  LOCAL hbusy%,hlbusy%,lhbusy%,lbusy%
  LOCAL hpe%,hlpe%,lhpe%,lpe%
  LOCAL hslct%,hlslct%,lhslct%,lslct%
  LOCAL lerr%,lherr%,hlerr%,herr%
  LOCAL Acknowledge%,Busy%,PapErr%,Sclt%
  LOCAL Error%,result%
  LOCAL message$


  REM Ack low,high,low,high
  lack%   = FNSetInputSig(1,1,&0,&BF,&40)
  lhack%  = FNSetInputSig(1,0,&40,&BF,&40)
  hlack%  = FNSetInputSig(1,1,&0,&BF,&40)
  hack%   = FNSetInputSig(1,0,&40,&BF,&40)

  REM Busy High,Low,High,Low
  hbusy%  = FNSetInputSig(2,0,&0,&7F,&80)
  hlbusy% = FNSetInputSig(2,1,&80,&7F,&80)
  lhbusy% = FNSetInputSig(2,0,&0,&7F,&80)
  lbusy%  = FNSetInputSig(2,1,&80,&7F,&80)

  REM PE High,Low,High,Low
  hpe%    = FNSetInputSig(3,0,&20,&DF,&20)
  hlpe%   = FNSetInputSig(3,1,&0,&DF,&20)
  lhpe%   = FNSetInputSig(3,0,&20,&DF,&20)
  lpe%    = FNSetInputSig(3,1,&0,&DF,&20)

  REM SLCT high,low,high,low
  hslct%  = FNSetInputSig(5,0,&10,&EF,&10)
  hlslct% = FNSetInputSig(5,1,&0,&EF,&10)
  lhslct% = FNSetInputSig(5,0,&10,&EF,&10)
  lslct%  = FNSetInputSig(5,1,&0,&EF,&10)

  REM SLCT low,high,low,high
  lerr%   = FNSetInputSig(4,1,&0,&F7,&08)
  lherr%  = FNSetInputSig(4,0,&08,&F7,&08)
  hlerr%   = FNSetInputSig(4,1,&0,&F7,&08)
  herr%  = FNSetInputSig(4,0,&08,&F7,&08)


  Acknowledge% = hack%  AND hlack%  AND lhack%  AND lack%
  Busy%        = hbusy% AND hlbusy% AND lhbusy% AND lbusy%
  PapErr%      = hpe%   AND lhpe%   AND hlpe%   AND lpe%
  Sclt  %      = lslct% AND lhslct% AND hlslct% AND hslct%
  Error%       = lerr%  AND lherr%  AND hlerr%  AND herr%

  IF (Acknowledge% AND Busy% AND PapErr% AND Sclt% AND Error%) THEN
        result% = TRUE
  ELSE
        result% = FALSE
        IF (Acknowledge%=FALSE) THEN
                message$ = failed_msg$+port_test_msg$(15)
                Failure$ = "Ack : "+STR$(lack%)+":"+STR$(hlack%)+":"+STR$(lhack%)+":"+STR$(lack%)
                PROCUpdate_report_file(message$+" "+STR$~(&C3))
        ENDIF
        IF (Busy% = FALSE) THEN
                message$ = failed_msg$+port_test_msg$(16)
                Failure$ = "Busy : "+STR$(hbusy%)+":"+STR$(hlbusy%)+":"+STR$(lhbusy%)+":"+STR$(lbusy%)
                PROCUpdate_report_file(message$+" "+STR$~(&C3))
        ENDIF
        IF (PapErr%= FALSE) THEN
                message$ = failed_msg$+port_test_msg$(17)
                Failure$ = "PE : "+STR$(hpe%)+":"+STR$(lhpe%)+":"+STR$(hlpe%)+":"+STR$(lpe%)
                PROCUpdate_report_file(message$+" "+STR$~(&C3))
        ENDIF
        IF (Sclt%=FALSE) THEN
                message$ = failed_msg$+port_test_msg$(18)               
                Failure$ = "Sclt : "+STR$(lslct%)+":"+STR$(lhslct%)+":"+STR$(hlslct%)+":"+STR$(hslct%)
                PROCUpdate_report_file(message$+" "+STR$~(&C3))
        ENDIF
        IF (Error%=FALSE) THEN
                message$ = failed_msg$+port_test_msg$(19)
                Failure$ = "Err : "+STR$(lerr%)+":"+STR$(lherr%)+":"+STR$(hlerr%)+":"+STR$(herr%)
                PROCUpdate_report_file(message$+" "+STR$~(&C3))
        ENDIF
  ENDIF
=result%




DEFFNSetInputSig(getvalue%,level%,maskres%,notmask%,sigmask%)
  REM getvalue = The value that represents the signal
  REM            in the SET call. (0-5)
  REM level%   = Set signal high or low (0,1)
  REM maskres% = When the status reg. is AND with the
  REM            mask, maskres is the correct result.
  REM notmask% = The is the mask that needs to be used
  REM            to check that all other pins in the
  REM            status reg. apart from the one being
  REM            tested, have not changed.
  REM sigmask% = The mask that allows only the signal
  REM            being tested to be examined.

  REM Used to test input signals.
  REM Read all signal states from UUT. Set a signal (getvalue)
  REM to a level (level%) from the port tester. Read state of
  REM all signals. Compare current state with state at start of
  REM test, check only signal being tested has altered.
  REM Use functions that read data and status register without 
  REM altering dir bit, hence data bus is still being driven.


  LOCAL pdrflag%,pstflag%,pnotsig%,piodata%,pdata%
  LOCAL psdata%,flag%,drflag%,iodata%,stflag%,sig%
  LOCAL data%,stdata%,notsig%,sigresult%


  pdata%      = FNRdDataReg
  psdata%     = FNRdStatusReg
  pnotsig%    = psdata% AND notmask%
  piodata%    = FNReadAllIOControllines

  flag%       = FNSetPortTesterLine(getvalue%,level%)

  data%       = FNRdDataReg
  iodata%     = FNReadAllIOControllines
  stdata%     = FNRdStatusReg
  sig%        = stdata% AND sigmask%
  notsig%     = stdata% AND notmask%

  IF (flag%) THEN
        IF ((pdata%=data%) AND (pnotsig%=notsig%) AND (piodata%=iodata%)) THEN
                IF (sig% = maskres%) THEN
                        sigresult% = TRUE
                ELSE
                        sigresult% = FALSE
                ENDIF
        ELSE
                sigresult% = FALSE
        ENDIF
  ELSE
        sigresult% = FALSE
  ENDIF
=sigresult%



DEFFNTestInitLine
  REM NOTE the Init signal is inverted.
  REM Test the Init signal. Initial state Low.
  REM Clr the signal from UUT. Read state of all
  REM signals from the port tester. Set the init signal.
  REM Again read state of all signals. Clr the init
  REM signal again. Compare the state of all signals to
  REM check only the init signal changed. Return to original
  REM state.
  REM Init starts high goes Low,High,Low,High

  LOCAL pcrflg%,wcrflg%,scrflg%,retflg%
  LOCAL prdvalue%,prAutofeed%,prInit%,prSelectin%,prGnd%
  LOCAL wrdvalue%,wrAutofeed%,wrInit%,wrSelectin%,wrGnd%
  LOCAL sdvalue%,sAutofeed%,sInit%,sSelectin%,sGnd%
  LOCAL result%


  pcrflg% = FNClrIOControlline(2)
  PROCReadAllPortTesterLines(prdvalue%,prAutofeed%,prInit%,prSelectin%,prGnd%)

  wcrflg% = FNSetIOControlline(2)
  PROCReadAllPortTesterLines(wrdvalue%,wrAutofeed%,wrInit%,wrSelectin%,wrGnd%)

  scrflg% = FNClrIOControlline(2)
  PROCReadAllPortTesterLines(sdvalue%,sAutofeed%,sInit%,sSelectin%,sGnd%)
  retflg% = FNSetIOControlline(2)
  IF (pcrflg% AND wcrflg% AND scrflg% AND retflg%) THEN
        IF ((prdvalue%=wrdvalue%) AND (wrdvalue%=sdvalue%)) THEN
                IF ((prAutofeed%=wrAutofeed%) AND (wrAutofeed%=sAutofeed%)) THEN
                        IF ((prSelectin% =wrSelectin%) AND (wrSelectin%=sSelectin%)) THEN
                                IF ((prGnd%=wrGnd%) AND (wrGnd%=sGnd%)) THEN
                                        IF ((prInit%=0) AND (wrInit%=1) AND (sInit%=0)) THEN
                                                result%=TRUE
                                        ELSE
                                                result%=FALSE
                                        ENDIF
                                ELSE
                                        result%=FALSE
                                        IF (prGnd% <>0 OR wrGnd%<>0 OR sGnd%<>0)THEN
                                                gnd_failure% = TRUE
                                        ENDIF
                                ENDIF
                        ELSE
                                result%=FALSE
                        ENDIF
                ELSE
                        result%=FALSE
                ENDIF
        ELSE
                result%=FALSE
        ENDIF
  ELSE
        result%=FALSE
  ENDIF
  IF (result% = FALSE) THEN
        Failure$ = "Init Preset "+STR$~(prdvalue%)+":"+STR$~(prAutofeed%)+":"+STR$~(prInit%)+":"+STR$~(prSelectin%)+":"+STR$~(prGnd%)+";"
        Failure$ = Failure$+" Write "+STR$~(wrdvalue%)+":"+STR$~(wrAutofeed%)+":"+STR$~(wrInit%)+":"+STR$~(wrSelectin%)+":"+STR$~(wrGnd%)+";"
        Failure$ = Failure$+" Set "+STR$~(sdvalue%)+":"+STR$~(sAutofeed%)+":"+STR$~(sInit%)+":"+STR$~(sSelectin%)+":"+STR$~(sGnd%)+";"
        Failure$ = Failure$ + " Flags = "+STR$(pcrflg%)+":"+STR$(wcrflg%)+":"+STR$(scrflg%)+":"+STR$(retflg%)
  ENDIF
=result%




DEFFNSelectin
  REM As FNTestInitLine but for Selectin signal.
  REM Selectin signal is inverted when seen from UUT
  REM but not from Port Tester.

  LOCAL pcrflg%,wcrflg%,scrflg%,resflg%,result%
  LOCAL prdvalue%,prAutofeed%,prInit%,prSelectin%,prGnd%
  LOCAL wrdvalue%,wrAutofeed%,wrInit%,wrSelectin%,wrGnd%
  LOCAL sdvalue%,sAutofeed%,sInit%,sSelectin%,sGnd%

  pcrflg% = FNClrIOControlline(3)
  PROCReadAllPortTesterLines(prdvalue%,prAutofeed%,prInit%,prSelectin%,prGnd%)

  wcrflg% = FNSetIOControlline(3)
  PROCReadAllPortTesterLines(wrdvalue%,wrAutofeed%,wrInit%,wrSelectin%,wrGnd%)

  scrflg% = FNClrIOControlline(3)
  PROCReadAllPortTesterLines(sdvalue%,sAutofeed%,sInit%,sSelectin%,sGnd%)
  resflg% = FNSetIOControlline(3)
  IF (pcrflg% AND wcrflg% AND scrflg% AND resflg%) THEN
        IF ((prdvalue%=wrdvalue%) AND (wrdvalue%=sdvalue%)) THEN
                IF ((prInit%=wrInit%)AND (wrInit%=sInit%)) THEN
                        IF ((prAutofeed% = wrAutofeed%) AND (wrAutofeed%=sAutofeed%)) THEN
                                IF((prGnd%=wrGnd%)AND(wrGnd%=sGnd%)) THEN
                                        IF ((prSelectin%=1) AND (wrSelectin%=0) AND (sSelectin%=1)) THEN
                                                result% = TRUE
                                        ELSE
                                                result% = FALSE
                                        ENDIF
                                ELSE
                                        result% = FALSE
                                        IF (prGnd%<>0 OR wrGnd%<>0 OR sGnd%<>0)THEN
                                                gnd_failure% = TRUE
                                        ENDIF
                                ENDIF
                        ELSE
                                result% = FALSE
                        ENDIF
                ELSE
                        result% = FALSE
                ENDIF
        ELSE
                result% = FALSE
        ENDIF
  ELSE
        result% = FALSE
  ENDIF
  IF (result% = FALSE) THEN
        Failure$ = "Selectin : Preset "+STR$~(prdvalue%)+":"+STR$~(prAutofeed%)+":"+STR$~(prInit%)+":"+STR$~(prSelectin%)+":"+STR$(prGnd%)+":"
        Failure$=Failure$+" Write "+STR$~(wrdvalue%)+":"+STR$~(wrAutofeed%)+":"+STR$~(wrInit%)+":"+STR$~(wrSelectin%)+":"+STR$(wrGnd%)+":"
        Failure$=Failure$+" Set "+STR$~(sdvalue%)+":"+STR$~(sAutofeed%)+":"+STR$~(sInit%)+":"+STR$~(sSelectin%)+":"+STR$(sGnd%)+":"
        Failure$ = Failure$ + " Flags = "+STR$(pcrflg%)+":"+STR$(wcrflg%)+":"+STR$(scrflg%)+":"+STR$(resflg%)
  ENDIF
=result%



DEFFNTestAutofeed
  REM As FNTestInitLine but for Autofeed signal.
  REM Starts High goes low,high,low,high.
  REM Signal Inverted to UUT.

  LOCAL pcrflg%, wcrflg%, scrflg%, resflg%, result%
  LOCAL prdvalue%,prAutofeed%,prInit%,prSelectin%,prGnd%
  LOCAL wrdvalue%,wrAutofeed%,wrInit%,wrSelectin%,wrGnd%
  LOCAL sdvalue%,sAutofeed%,sInit%,sSelectin%,sGnd%


  pcrflg% = FNSetIOControlline(1)
  PROCReadAllPortTesterLines(prdvalue%,prAutofeed%,prInit%,prSelectin%,prGnd%)

  wcrflg% = FNClrIOControlline(1)
  PROCReadAllPortTesterLines(wrdvalue%,wrAutofeed%,wrInit%,wrSelectin%,wrGnd%)

  scrflg% = FNSetIOControlline(1)
  PROCReadAllPortTesterLines(sdvalue%,sAutofeed%,sInit%,sSelectin%,sGnd%)

  resflg% = FNClrIOControlline(1)
  IF (pcrflg% AND wcrflg% AND scrflg% AND resflg%) THEN
        IF ((prdvalue% = wrdvalue%) AND (wrdvalue%=sdvalue%)) THEN
                IF ((prInit%=wrInit%)AND(wrInit%=sInit%)) THEN
                        IF ((prSelectin%=wrSelectin%) AND (wrSelectin%=sSelectin%)) THEN
                                IF ((prGnd%=wrGnd%) AND (wrGnd%=sGnd%)) THEN
                                        IF ((prAutofeed%=0) AND (wrAutofeed%=1) AND (sAutofeed%=0)) THEN
                                                result% = TRUE
                                        ELSE
                                                result% = FALSE
                                        ENDIF
                                ELSE
                                        result% = FALSE
                                        IF (prGnd%<>0 OR wrGnd%<>0 OR sGnd%<>0)THEN
                                                gnd_failure% = TRUE
                                        ENDIF
                                ENDIF
                        ELSE
                                result% = FALSE
                        ENDIF
                ELSE
                        result% = FALSE
                ENDIF
        ELSE
                result% = FALSE
        ENDIF
  ELSE
        result% = FALSE
  ENDIF
  IF (result% = FALSE) THEN
        Failure$ = "Autofeed : Preset "+STR$~(prdvalue%)+":"+STR$~(prAutofeed%)+":"+STR$~(prInit%)+":"+STR$~(prSelectin%)+":"+STR$(prGnd%)+":"
        Failure$=Failure$+" Write "+STR$~(wrdvalue%)+":"+STR$~(wrAutofeed%)+":"+STR$~(wrInit%)+":"+STR$~(wrSelectin%)+":"+STR$(wrGnd%)+":"
        Failure$=Failure$+" Set "+STR$~(sdvalue%)+":"+STR$~(sAutofeed%)+":"+STR$~(sInit%)+":"+STR$~(sSelectin%)+":"+STR$(sGnd%)+":"
        Failure$ = Failure$ + " Flags = "+STR$(pcrflg%)+":"+STR$(wcrflg%)+":"+STR$(scrflg%)+":"+STR$(resflg%)
  ENDIF
=result%





DEFFNClearAllIOControllines
REM Clear all usable lines in i/o control register.
REM Bits 7,6 reserved.
REM If cleared correctly then return true.

LOCAL new%,flag%

SYS"Parallel_Op",2,0,0 TO ,,new%
IF (new% AND &3F) = 0 THEN
        flag% = TRUE
ELSE
        flag% = FALSE
ENDIF
=flag%



DEFFNSetAllIOControllines
REM Set all usable lines in i/o control register.
REM Bits 7,6 reserved.
REM If all set correctly then return true.

LOCAL new%,flag%

SYS"Parallel_Op",2,&3F,&C0 TO ,,new%
IF (new% AND &3F)= &3F THEN
        flag% = TRUE
ELSE
        flag% = FALSE
ENDIF
=flag%


DEFFNReadAllIOControllines
REM Read IO Control lines. Return read value.
LOCAL value%
SYS"Parallel_Op",2,&00,&FF TO ,,value%
=value%



DEFFNSetIOControlline(line_no%)
REM Set the IO Control line specified.
REM Set the bit and then check it did set it correctly.
REM Return true if correct.
REM line_no% = bit number.

LOCAL bit%,value%,new_val%,flag%

value% = &1<<line_no%
inv_val% = NOT value%
SYS"Parallel_Op",2,value%,inv_val% TO ,,new_val%
IF (value% AND new_val%) = value% THEN
        flag% = TRUE
ELSE
        flag% = FALSE
ENDIF
=flag%


DEFFNClrIOControlline(line_no%)
REM Clear the one bit specified.
REM Return true if bit cleared.
LOCAL value%,inv_val%,new_val%,flag%

value% = &1<<line_no%
inv_val% = NOT value%
SYS"Parallel_Op",2,&0,inv_val% TO ,,new_val%
IF (new_val% AND value%) =0 THEN
        flag% = TRUE
ELSE
        flag% = FALSE
ENDIF
=flag%



DEFFNReadDataRegister(RETURN data%)
REM Set direction to read and then read the
REM data register. If fail to set dir pin then flag
REM is FALSE. If call completes the flag is TRUE.
REM Data is returned in formal parameter.
LOCAL flag%,dir%

flag% = FALSE
dir% = 5
IF FNSetIOControlline(dir%) THEN
        SYS"Parallel_Op",0 TO ,data%
        flag% = TRUE
ENDIF
=flag%


DEFFNRdDataReg
REM Read data register without altering dir bit.
REM dir bit controls driven / not driven data bus.
LOCAL data%
SYS"Parallel_Op",0 TO ,data%
=data%


DEFFNWriteDataRegister(data%)
REM Set dir line to write and then if successful
REM write the data.
LOCAL flag%,dir%
flag% = FALSE
dir% = 5
IF FNClrIOControlline(dir%) THEN
        SYS"Parallel_Op",1,data%
        flag% = TRUE
ENDIF
=flag%


DEFPROCWriteData(data%)
REM Write data register without altering dir bit.
REM dir bit controls driven / not driven data bus.
LOCAL data%
SYS"Parallel_Op",0 TO ,data%
ENDPROC




DEFFNReadStatusRegister(RETURN data%)
REM Set DIR line then if successful read
REM the status register.
LOCAL flag%,dir%

flag% = FALSE
dir% = 5
IF FNSetIOControlline(dir%) THEN
        SYS"Parallel_Op",0 TO ,,data%
        flag% = TRUE
ENDIF
=flag%


DEFFNRdStatusReg
REM Read data register without altering dir bit.
REM dir bit controls driven / not driven data bus.
LOCAL data%
SYS"Parallel_Op",0 TO ,,data%
=data%



DEFFNSetPortTesterLine(line_no%,level%)
REM Send port tester command to set a line to a
REM know state.

LOCAL flag%
LOCAL sendstr$

flag% = TRUE
sendstr$ = ":CENTRONICS:SET "+STR$(line_no%)+","+STR$~(level%)
IF FNto_io_tester(sendstr$) <> portsOK% THEN
        flag% = FALSE
ENDIF
=flag%


DEFFNReadSinglePortLine(line_no%)
REM Read the state of a particular line from the
REM port tester. Return the value from this function
REM as an integer.

LOCAL string$

string$ = ":CENTRONICS:GET "+ STR$(line_no%)
= VAL(FNfrom_io_tester(string$))




DEFPROCReadAllPortTesterLines(RETURN da%,RETURN au%,RETURN in%,RETURN se%,RETURN gn%)
LOCAL pos%,Alen%,AAlen%,AIlen%,ASlen%,
LOCAL AA$,AI$,AS$

A$ = FNfrom_io_tester(":CENTRONICS:GET")
Alen%   = LEN(A$)
pos%    = INSTR(A$,",")
da%     = FNhex_strtoint(LEFT$(A$,pos%))

AA$     = RIGHT$(A$,(Alen%-pos%))
AAlen%  = LEN(AA$)
pos%    = INSTR(AA$,",")
au%     = VAL(LEFT$(AA$,pos%))
AI$     = RIGHT$(AA$,(AAlen%-pos%))

AIlen%  = LEN(AI$)
pos%    = INSTR(AI$,",")
in%     = VAL(LEFT$(AI$,pos%))
AS$     = RIGHT$(A$,(AIlen%-pos%))

ASlen%  = LEN(AS$)
pos%    = INSTR(AS$,",")
se%     = VAL(LEFT$(AS$,pos%))
gn%     = VAL(RIGHT$(AS$,(ASlen%-pos%)))

ENDPROC





DEFFNhex_strtoint(A$)
REM Convert a hex string into an integer. Returns integer result.
REM finds length of string. Reads chars from string from right.
REM If ASCII of char is between 47-59 ie 0-9 or 65-71 A-F then
REM its a valid number. First valid char read starts calculation,
REM continues until next non valid char, OR end of string.
REM Length of string dtermined by size of number BASIC can handle.

LOCAL start%,end%,len%,powers%,n%,ct%

total%=0
start%=FALSE:end%=FALSE
ct%=1

len% = LEN(A$)
powers% = 0

REPEAT
        n% = ASC(RIGHT$(A$,ct%))
        IF (n%>47 AND n%<58) THEN
                start% = TRUE
                IF powers% = 0 THEN
                        total% = n% - 48
                        powers% = powers%+1
                ELSE
                        total% = ((16^powers%) * (n%-48)) + total%
                        powers% = powers%+1
                ENDIF
        ELSE
                IF (n%>=65 AND n%<71) THEN
                        start% = TRUE
                        IF powers% = 0 THEN
                                total% = n% - 55
                                powers% = powers%+1
                        ELSE
                                total% = ((n%-55) * (16^powers%) ) + total%
                                powers% = powers%+1
                        ENDIF
                ELSE
                        IF start% THEN
                                end% = TRUE
                        ENDIF
                ENDIF
        ENDIF
        ct%=ct%+1
UNTIL ct%> len% OR end% = TRUE

=total%



 REM That's all folks.
