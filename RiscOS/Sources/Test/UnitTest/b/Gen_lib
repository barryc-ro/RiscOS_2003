 REM    >GEN_LIB - STD TEST PROC LIB.
 REM    ACORN TEST SOFTWARE.
 REM    © ACORN Computers Limited 1990.
 REM
 REM    ************************ CHANGE LIST *******************************
 REM
 REM    Vers    Date            Name    Comment
 REM    ------  ---------       ---     ------------------------------------
 REM    1.78    04-Mar-93       DB      mdify title banner to include cycle 
 REM                                    counters and run time. Also allow bkgrd
 REM                                    colour to change if failures have 
 REM                                    occured. 
 REM    1.79    27-May-93       DB      Add machine number 9 = medusa.
 REM    1.80    21-Jul-93       BAR     Add code to check the current
 REM                                    country code and set global varaible
 REM                                    current_country%. Add code to check
 REM                                    if current_country% and if it is 1
 REM                                    then print the error text REPORT$ on
 REM                                    the screen, else do not.
 REM    1.81    22-Jul-93       BAR     Correct bug in FNget_podule_id,
 REM                                    where it did not return -1 for no
 REM                                    installed podule.
 REM    1.82    23-Jul-93       GN/BAR  Fixed a possible bug with the
 REM                                    arguments to GBPB in FNfind_file. 
 REM                                    It used swi_buf_end% when it meant
 REM                                    swi_buf_size%
 REM    1.83    13-Sep-93       DB      Add backplane test tdb.
 REM    1.84    18-Oct-93       BAR     Improve error handling code, to
 REM                                    check that the error string is set
 REM                                    to the correct value.
 REM    1.85    29-Oct-93       BAR     Correct bug in PROCread_variable,
 REM                                    where if a variable is read and not
 REM                                    found, all subsequent calls to the
 REM                                    procedure will be told the variable
 REM                                    was not found, even if it is
 REM                                    present.
 REM    1.86    07-Dec-93       DB      Add td def'n for genlock and Network 
 REM                                    interface tests.
 REM    1.87    17-Feb-94       BAR     Add code to read trhe version number
 REM                                    for a given module.
 REM    1.88    23-Feb-94       DB      Add wiper and 2nd proc I/F tdb 
 REM                                    definitions.
 REM    1.89    01-Mar-94       DB      Bug fixed line / variable should not
 REM                                    start with number.
 REM    1.90    06-Apr-95       BAR     Reduce the header info.
 REM                                    See b.Oldheader.
 REM                                    Increase tda_size% to 70
 REM                                    Add pcmcia_if_tdb% (30)
 REM                                    Reassign second_keyboard_tdb% (24)
 REM                                    to be cdrom_test_tdb%.
 REM    1.91    12-Jun-95       DB      Add sound default. This is to allow 
 REM                                    different levels of bleep through 
 REM                                    headphones.
 REM    1.92    18-Jul-95       BAR     Change above, to use a system
 REM                                    variable to define the default
 REM                                    setting. Also add a code to allow
 REM                                    programs to change the bleep sound
 REM                                    level.
 REM    1.93    02-Aug-95       BAR     Correct mistake in above, called
 REM                                    non-existant function.
 REM    1.94    31-Aug-95       BAR     Correct comment / code difference in
 REM                                    FNread_syst_variable, where comment
 REM                                    said -1 rtned, code rtned 0. Update
 REM                                    PROCsetup_bleep_default to check for
 REM                                    '0' being returned. If 0 rtn then
 REM                                    used coded default.
 REM    1.95    12-Jun-96       BAR     Add function to read the cycle
 REM                                    counter on the CMOS RAM.
 REM            13-Jun-96       BAR     Fix bugs.
 REM    1.96    26 Nov 97       BAR     Don't moan if report_number not
 REM                                    specified.

 REM This is a general procedures library for use with test software.
 REM The library file is based on the general routines developed for
 REM COMP_TYPE, Universal test S/W, @8/2/90 not released.
 REM This library file must be called by the test software.

 REM This library file will provide the necessary procedures for the test
 REM software. This library file is test suite independent.

 REM **************************************************************
 REM Standard utility procedures and functions follow below.
 REM **************************************************************

 DEFPROClibrary_init
   REM This procedure will assign some global constants that are used
   REM throughout the program, library as well as the main program.
   REM Assign some logical flags
     ALIVE        = TRUE   :  REM -1
     DEAD         = FALSE  :  REM  0
     PASS         = TRUE   :  REM -1
     FAIL         = FALSE  :  REM  0
   REM Define some function keys
     OSCLI "KEY5 Y|M"
     OSCLI "KEY8 N|M"
   REM Define  constants
     max_ports%   = 4
     width%       = 39
     red$         = CHR$(129)
     green$       = CHR$(130)
     yellow$      = CHR$(131)
     blue$        = CHR$(132)
     magenta$     = CHR$(133)
     cyan$        = CHR$(134)
     white$       = CHR$(135)
     flash_on$    = CHR$(136)
     flash_off$   = CHR$(137)
     back$        = CHR$(157)
     double$      = CHR$(141)
     REM Find out the current country code.
     SYS "OS_Byte",70,127 TO ,current_country%
   REM Define global TDA constants.
     system_tdb%          =  1
     sound_tdb%           =  2
     video_tdb%           =  3
     ext_ports_tdb%       =  4
     floppy_tdb%          =  5
     st506_main_tdb%      =  6
     first_keyboard_tdb%  =  7
     reports_tdb%         =  8
     exp_rom_ram_tdb%     =  9
     cycles_tdb%          = 10
     exp_user_midi_tdb%   = 11
     exp_midi_tdb%        = 12
     exp_st506_tdb%       = 13
     exp_scsi_tdb%        = 14
     exp_eth1_tdb%        = 15
     exp_eth2_tdb%        = 16
     exp_upm_tdb%         = 17
     exp_memory_tdb%      = 18
     copy_apps_tdb%       = 19
     lcd_tdb%             = 20
     batt_tdb%            = 21
     joystick_tdb%        = 22
     uhf_modulator_tdb%   = 23
     REM second_keyboard_tdb% = 24
     cdrom_test_tdb%      = 24
     bkplane_tdb%         = 25
     genlock_if_tdb%      = 26
     network_if_tdb%      = 27
     wiper_tdb%           = 28
     second_proc_if_tdb%  = 29
     pcmcia_if_tdb%       = 30


   REM Define some fixed CMOS RAM locations and TDA parameters
     tda_start%         = 30
     tda_size%          = 70
     tda_end%           = tda_start% + tda_size% - 1
     tda_sib_size%      = 3
     tdb_area_start%    = tda_start% + tda_sib_size% - 1
     magic_num_loc%     = tda_start%
     checksum_loc%      = tda_start% + 1
     test_status_loc%   = tda_start% + 2
     printer_mask%      = &E0
     printer_shift%     = 5
   REM Define some ports tester values
     pifsendto%           = 50
     pifrecvto%           = 50
     pifquickto%          =  2
     portsOK%             = ASC("<")
     portsREPLY%          = ASC(">")
     portsEPARM%          = ASC("P")
     portsECMD%           = ASC("C")
     portsEVOLT%          = ASC("V")
     portsEEMPTY%         = ASC("E")
   REM Dimension some global arrays and memory storage areas.
     swi_buf_size%      = 1024
     DIM swi_buffer% swi_buf_size%
     swi_buf_end%       = swi_buffer% + swi_buf_size%
     temp_store_size%   = 79
     DIM temp_store$(temp_store_size%)
     DIM tda_buf% tda_size%
     DIM iic_buf% &10
   REM Set up some global variables
     net_dead%            = FALSE
     error_in_progress%   = FALSE
     show_syst_var_error% = TRUE
     sound_bleep_default% = -1
   REM Define the OS-Byte call values for reading and writing to and from
   REM the CMOS RAM.
     cmos_read%         = 161
     cmos_write%        = 162
   REM Define the values for cmos_valid% and cmos_invalid%
     cmos_valid%        = -1
     cmos_invalid%      = -2
   REM Define some values for variables used for reading and writing to
   REM and from the CMOS RAM, using IIC calls.
     iic_read%          = &01
     iic_write%         = &00
     cmos_addr%         = &A0
     cmos_ram_read%     = cmos_addr% OR iic_read%
     cmos_ram_write%    = cmos_addr% OR iic_write%
     cmos_size%         = &EF
     cmos_start%        = &40
   REM Define the exit codes for all in sundry to use.
     EXIT_SUCCESS        = 0
     EXIT_PASS           = EXIT_SUCCESS
     EXIT_NOUP_CONT      = 10
     EXIT_NOUP_STOP      = 11
     EXIT_STOP           = 12
     EXIT_FAIL_UP_CONT   = 20
     EXIT_FAIL_NOUP_CONT = 21
     EXIT_FAIL_NOUP_STOP = 22
     EXIT_FAIL_UP_STOP   = 23
     EXIT_FAILURE        = 1
     EXIT_FAIL           = EXIT_FAILURE
   REM Define some gen_lib text strings.
     REM Error messages for PROCread_variable_error
       gen_lib_msg1$    = "System variable "
       gen_lib_msg2$    = "was not found, check that the system"
       gen_lib_msg3$    = "variable has been set, else check code."
       gen_lib_msg4$    = "was found, but it's length was 0."
       gen_lib_msg5$    = "Check that it has been set correctly."
       gen_lib_msg6$    = "was found, but it was too long."
     REM Error messages for FNstring_to_number.
       non_numb_string_msg1$ = "The string "
       non_numb_string_msg2$ = "was expected to be a number. The variable"
       non_numb_string_msg3$ = "contains non numeric characters."
     REM Error messages for PROCerror_trap
       error_trap_msg1$ = "Message from general error handler."
       error_trap_msg2$ = "Page Mode is ON, <SHIFT> to scroll."
       error_trap_msg3$ = "Error No. "
       error_trap_msg4$ = " at line "
     REM Space bar message
       space_msg$="PRESS"+flash_on$+"<SPACE BAR>"+flash_off$+"TO CONTINUE"
     REM Sub Test messages
       pass_sub_test_msg$ = "THIS SUB TEST HAS PASSED."
       fail_sub_test_msg$ = "THIS SUB TEST HAS FAILED."
     REM Error messages for saving to a file.
      save_error_msg1$ = "ERROR HAS occurred - TEST SEQUENCE ABORTED."
      save_error_msg2$ = "The time is "
      save_error_msg3$ = "Test program title "
      save_error_msg4$ = "Test program version "
      save_error_msg5$ = "The error number  (ERR)     was "
      save_error_msg6$ = "The error line    (ERL)     was "
      save_error_msg7$ = "The error message (REPORT$) was "
      save_error_msg8$ = "CYCLE NUMBER "
      save_error_msg9$ = "I have completed saving the errors file."
     REM Ask if passed messages
      ask_pass_msg1$ = "Press F5 to PASS the "
      ask_pass_msg2$ = "Press F8 to FAIL the "
   REM Define some gen_lib text strings for 'ERROR' messages, for passing
   REM to the error trapper, for reporting.
     REM Message assigned to error number 100
       lib_100_error1$ = "The TDA checksum "
       lib_100_error2$ = " is incorrect."
     REM Message assigned to error number 101
       lib_101_error$ = "Exceeded bounds of TDA when searching for block "
 ENDPROC

 DEFFNlibrary_version
   REM This function will return the version number of this library file.
   LOCAL lib_version%
   lib_version% = 196
 = lib_version%

 DEFFNinput_text(view_port%,vert_tab%,control_code$,text$,default$)
   REM This function will prompt for a text input, the default
   REM response will be shown.
   REM The function will print out a line of text (text$)
   REM in the viewport specified by view_port%
   REM on the line specified by vert_tab%, note this is the
   REM relative line number for the specified viewport.
   REM Horizontally tabbed by 1 column.
   REM The control codes for the line of text are specified
   REM by control_code$.
   LOCAL end_line%
   LOCAL reply%
   LOCAL input$
   LOCAL return%
   return%=13
   text$=text$+" ?"
   PROCviewport(view_port%)
   PRINTTAB(0,vert_tab%)control_code$;
   PRINTTAB(1,vert_tab%)text$;
   end_line%=POS
   PRINTTAB(end_line%,vert_tab%)default$;
   PRINTTAB(end_line%,vert_tab%);
   *FX 15,1
   reply%=GET
   IF reply%=return% THEN
       input$=default$
     ELSE
       input$=CHR$(reply%)
       PRINTTAB(end_line%,vert_tab%);input$;
     ENDIF
 =input$

 DEFPROCtitle(program_title$,program_version$)
   REM Display the title of the test being done, name and version passed
   REM in program_title$ and program_version$. The procedure will also
   REM check the test type flag and add the appropriate extension to the
   REM title message.

   PROCdisplay_title(program_title$,program_version$,TRUE)
 ENDPROC

 DEFPROCtitle_nochk(program_title$,program_version$)
   REM Display the title of the test being done, name and version passed
   REM in program_title$ and program_version$. The procedure will also
   REM check the test type flag and add the appropriate extension to the
   REM title message. No check of the checksum is performed.

   PROCdisplay_title(program_title$,program_version$,FALSE)
 ENDPROC


 DEFPROCdisplay_title(program_title$,program_version$,check%)
   REM Will check if checksum is to be performed. If so uses appropriate
   REM call to find test type. Checks if any cycles have failed. 
   REM Sets the background colour depending on result. Displays
   REM 2nd line of title string.
 
   LOCAL ctrl$, title_msg$, test_type$
   LOCAL fstfail$,Secondtitle$
   LOCAL failcyc%

   IF check%=TRUE THEN
        test_type$ = FNtest_type_string
   ELSE
        test_type$ = FNtest_type_string_nochk
   ENDIF
   title_msg$=program_title$+" V "+program_version$+" "+test_type$
   show_syst_var_error% = FALSE
   fstfail$ = FNread_syst_string("Test_Firstfailure")
   IF fstfail$ <> "" THEN
        failcyc% = FNstring_to_number(fstfail$)
        ctrl$=red$+back$+blue$
   ELSE
        ctrl$=green$+back$+blue$ 
   ENDIF
   PROCprint_line(1,0,ctrl$,title_msg$)
   show_syst_var_error% = FALSE
   Secondtitle$  = FNread_syst_string("TEST_Titlestring")
   IF Secondtitle$ <> "" THEN
        PROCprint_line(1,1,ctrl$,Secondtitle$)
   ELSE
        PROCprint_line(1,1,ctrl$," ")
   ENDIF
 ENDPROC


 DEFPROCdef_std_viewports
   REM This procedure will define the standard display windows.
   LOCAL counter%
   FOR counter%=1 TO max_ports%
     PROCviewport(counter%)
   NEXT
 ENDPROC

 DEFPROCviewport(port_number%)
   REM This procedure will specify a screen viewport.
   LOCAL view_port%
   LOCAL vp_top%
   LOCAL vp_bottom%
   LOCAL left_edge%
   LOCAL right_edge%
   REM  vp,top,bottom,left,right
   RESTORE + 0
   DATA  0, 00,    23,   0,   39
   DATA  1, 00,    01,   0,   39
   DATA  2, 03,    16,   0,   39
   DATA  3, 18,    24,   0,   39
   DATA  4, 21,    24,   0,   39
   REPEAT
     READ view_port%,vp_top%,vp_bottom%,left_edge%,right_edge%
   UNTIL view_port%=port_number%
   VDU 28,left_edge%,vp_bottom%,right_edge%,vp_top%
 ENDPROC

 DEFPROCprint_line(view_port%,vert_tab%,control_code$,text$)
   REM This procedure will print out a line of text (text$),
   REM in the viewport specified by view_port%,
   REM on the line specified by vert_tab%, note this is the
   REM relative line number for the specified viewport.
   REM The control codes for the line of text are specified
   REM by control_code$.
   REM The text will be centered automatically.
   LOCAL length%
   LOCAL hori_tab%
   LOCAL ctrl_length%
   ctrl_length%=LEN(control_code$)
   length%=LEN(text$)
   hori_tab%=(width%-length%) DIV 2
   IF ctrl_length% > hori_tab% THEN
       hori_tab%=ctrl_length%
     ENDIF
   PROCviewport(view_port%)
   PRINTTAB(0,vert_tab%)control_code$;
   PRINTTAB(hori_tab%,vert_tab%)text$;
 ENDPROC

 DEFPROCprint_result(view_port%,vert_tab%,control_code$,text$)
   REM This procedure will print out a line of text (text$)
   REM in the viewport specified by view_port%
   REM on the line specified by vert_tab%, note this is the
   REM relative line number for the specified viewport.
   REM Horizontally tabbed to 1 column.
   REM The control codes for the line of text are specified
   REM by control_code$.
   PROCviewport(view_port%)
   PRINTTAB(0,vert_tab%)control_code$;
   PRINTTAB(1,vert_tab%)text$;
 ENDPROC

 DEFPROCpress_space(status%)
   REM If system variable is set to TRUE then space bar is always
   REM requested.
   REM Otherwise only request space bar if a failure occurs or if
   REM the user is requested to check something (ie sound)
   REM status% = pass/fail status
   LOCAL string$
   LOCAL forever
   LOCAL space_timeout
   string$ = "TEST$Space_bar_enable"
   forever = -1
   space_timeout =  1
   show_syst_var_error% = FALSE
   PROCtest_info_nochk(a%,b,c%,test_type%)
   IF (test_type% <> 1 AND test_type% <> 2 AND test_type% <> 4) OR status% = FALSE THEN
       var_name$ = FNread_syst_string(string$)
       IF var_name$ = "FALSE" OR var_name$ = "" THEN
           IF status% = FALSE THEN
               PROCget_space(forever)
             ELSE
               PROCget_space(space_timeout)
             ENDIF
         ELSE
           PROCget_space(forever)
         ENDIF
     ENDIF
 ENDPROC

 DEFPROCget_space(delay)
   REM If spec bar required - check test type then prompt the user to press
   REM the space bar.
   REM If delay is -1 then the user has to press space to continue (ie wait
   REM forever). A bleep will sound prior to the space being read if sys var set.
   REM If not -1 then waits for delay number of seconds, or until the space
   REM is pressed, whichever is the shorter, then continues.
   LOCAL input$, alert$
   space_bar_reqd% = FNneed_space
   IF space_bar_reqd% = TRUE THEN
       *FX15,1
       IF delay = -1 THEN
           alert$ = FNread_syst_string("TEST$ALERT")
           alert$ = FNto_lower(alert$)
           IF alert$ = "on" THEN
               PROCspace_sound
             ENDIF
           PROCprint_line(4,2,yellow$,space_msg$)
           REPEAT
             input$ = GET$
           UNTIL input$ = " "
         ELSE
           PROCprint_line(4,2,yellow$,space_msg$)
           REPEAT
             input$ = INKEY$(delay*100)
           UNTIL input$ = " " OR input$ = ""
         ENDIF
       PROCclear_line(4,2)
     ELSE
       PROCwait(2)
     ENDIF
 ENDPROC

 DEFFNregister_bleep_level(new_level%)
   REM This function will resister, new_level%, as the new default sound
   REM level. The function will return the old setting, so that the calling
   REM program can restore.
   REM Set the the Global vraiable sound_bleep_default%
   IF (sound_bleep_default% < 0) THEN
       REM Sound level default not setup.
       PROCsetup_bleep_default
       old_setting% = sound_bleep_default%
     ELSE
       old_setting% = sound_bleep_default%
     ENDIF
   sound_bleep_default% = new_level%
 = old_setting%

 DEFPROCsetup_bleep_default
   REM This procedure will read the system variable specifying the default
   REM sound level. If the system variable wasn't set, then the code will
   REM use the coded default of 127. Then set the Global Variable
   REM sound_bleep_default% to the required value.
   REM Don't use FNregister_bleep_level, cos you'd end up in an infinite
   REM loop.
   LOCAL bleep_default%
   show_syst_var_error% = FALSE
   bleep_default% = FNread_syst_variable("Test$Speaker_Default_Volume")
   IF (bleep_default% <= 0) THEN
       REM System variable not set or too low
       bleep_default% = 127
     ENDIF
   sound_bleep_default% = bleep_default%
 ENDPROC

 DEFPROCspace_sound
   REM This procedure will cause a bleep.
   REM If the variable sound_bleep_default% is set less than 0, then the
   REM default sound level hasn't been setup, so set it up.
   REM uses the global variable sound_bleep_default%
   IF (sound_bleep_default% <= 0) THEN
       REM Sound level default not setup.
       PROCsetup_bleep_default
     ENDIF
   SOUND ON
   VOICES 1
   OSCLI "*VOLUME "+STR$(sound_bleep_default%)
   OSCLI "*SPEAKER ON"
   OSCLI "*CHANNELVOICE 1 WaveSynth-Beep"
   STEREO 1,0
   SOUND 1,-15,90,15
   PROCwait(0.5)
   OSCLI "*SPEAKER OFF"
 ENDPROC

 DEFPROCclear_line(view_port%,vert_tab%)
   REM This procedure will clear a line of text
   REM in the viewport specified by view_port%
   REM on the line specified by vert_tab%, note this is the
   REM relative line number for the specified viewport.
   PROCviewport(view_port%)
   PRINTTAB(0,vert_tab%)SPC(width%);
 ENDPROC

 DEFPROCdisplay_status(status_flag%)
   REM This procedure will display if the test has PASSED or FAILED.
   LOCAL ctrl$
   LOCAL message$
   IF status_flag% = PASS THEN
       ctrl$ = green$+flash_on$
       message$ = pass_sub_test_msg$
     ELSE
       ctrl$ = red$+flash_on$
       message$ = fail_sub_test_msg$
     ENDIF
     PROCprint_line(4,0,ctrl$,message$)
 ENDPROC

 DEFPROCwait(secs)
   REM This procedure will wait for a specified time period.
   REM The variable secs need to be real to allow the timing of parts of
   REM a second.
   LOCAL now%
   now%=TIME
   REPEAT
     REM Do nothing !
   UNTIL TIME-now% >= (100*secs)
 ENDPROC

 DEFPROCerror_trap
   REM This procedure will provide global error handling, for the test
   REM programs. The procedure will try to save the error to an error file
   REM on the network. The procedure will check the system variable to see
   REM if the errors file needs to be saved. The procedure will also check
   REM the global variable net_dead%, set by the net error handler, this
   REM variable is used to indicate if a fatal net error has occurred.
   LOCAL message$
   LOCAL length%
   LOCAL error_text$
   LOCAL error_left$
   LOCAL error_right$
   LOCAL error_number%
   LOCAL error_file%
   LOCAL pos%
   LOCAL space_pos%
   LOCAL chr$
   ON ERROR PROCerror_trap2
   REM Turn the error in progress flag on.
     error_in_progress% = TRUE
   REM Turn the screen on
     VDU 6
   PROCviewport(3)
   REM Page mode on
     VDU 14
   error_text$ =""
   error_right$ =""
   error_left$ = ""
   length% = 0
   alert$ = FNread_syst_string("TEST$ALERT")
   alert$ = FNto_lower(alert$)
   IF alert$ = "on" THEN
       PROCsound_alert
     ENDIF
   error_number% = ERR
   error_line%   = ERL
   error_text$   = REPORT$
   PRINT error_trap_msg1$
   PRINT yellow$ + error_trap_msg2$
   PRINT error_trap_msg3$ + STR$(error_number%) + error_trap_msg4$ + STR$(error_line%)
   REM Check the global variable 'current_country%' if this is 1 then show
   REM error_text$, else do not.
   IF current_country% = 1 THEN
       REM See if error_text$ > width%, if so split into two.
         length% = LEN(error_text$)
         IF length% >= (width%-1) THEN
             pos% = width%
             REPEAT
               chr$ = MID$(error_text$,pos%,1)
               pos% = pos% - 1
             UNTIL chr$ = " "
             space_pos% = pos% + 1
             error_left$ = LEFT$(error_text$,space_pos%)
             error_right$ = RIGHT$(error_text$,(length%-space_pos%))
             PRINTerror_left$
             PRINTerror_right$
           ELSE
             PRINTerror_text$
           ENDIF
     ENDIF
   REM Check to see if we are saving to the net.
     error_file% = FNread_syst_variable("TEST$REPORT_FILE")
     IF (((error_file% AND %10)>>1) = 1) AND (net_dead% = FALSE) THEN
         REM Try and save the errors on to the net.
         PROCsave_errors_file(error_number%,error_line%,error_text$)
       ENDIF
   REM Set BASIC$ReturnCode to EXIT_FAILURE
   REM CMOS RAM will not be updated.
   REM Control will not continue.
   REM Control will show the exit codes on screen.
     OSCLI "SETEVAL BASIC$ReturnCode "+STR$(EXIT_FAILURE)
   REM Do some tidying up.
     OSCLI "CLOSE"
     OSCLI "DEFAULT_FILER"
     OSCLI "SHUTDOWN"
     REM Page mode off
       VDU 15
   END
 ENDPROC

 DEFPROCsound_alert
   REM This procedure will sound the alert.
     SOUND ON
     VOICES 1
     OSCLI "*VOLUME 127"
     OSCLI "*SPEAKER ON"
     OSCLI "*CHANNELVOICE 1 WaveSynth-Beep"
     SOUND 1,-15,80,10
     PROCwait(0.5)
     SOUND 1,-15,110,10
     PROCwait(0.5)
     OSCLI "*SPEAKER OFF"
 ENDPROC

 DEFPROCsave_errors_file(number%,line%,text$)
   REM This procedure will try to save the error to the net.
   LOCAL file_name$
   LOCAL file_handle%
   file_name$   = FNread_syst_string("TEST$ERROR_NAME")
   file_name$   = FNadd_path(file_name$)
   file_handle% = FNopen_file(file_name$)
   PROCpointer_to_end(file_handle%)
   PROCsave_text(file_handle%," ")
   PROCsave_text(file_handle%,save_error_msg1$)
   PROCsave_text(file_handle%,save_error_msg2$+TIME$)
   PROCsave_text(file_handle%,save_error_msg3$+title$)
   PROCsave_text(file_handle%,save_error_msg4$+prog_ver$)
   PROCsave_text(file_handle%,save_error_msg5$+STR$(number%))
   PROCsave_text(file_handle%,save_error_msg6$+STR$(line%))
   PROCsave_text(file_handle%,save_error_msg7$+text$)
   total_cycles% = FNread_syst_variable("TEST$TOTAL_CYCLES")
   cycle_number% = FNread_syst_variable("TEST$CYCLE_COUNTER")
   cycle_number% = total_cycles% - cycle_number% + 1
   PROCsave_text(file_handle%,save_error_msg8$+STR$(cycle_number%))
   PROCsave_text(file_handle%,save_error_msg9$)
   PROCclose_file(file_handle%,file_name$)
 ENDPROC

 DEFPROCerror_trap2
   REM This procedure will provide error trapping for the error handler.
   REM The procedure will simply report a problem in the error handler.
   ON ERROR OFF
   IF error_in_progress% <> TRUE THEN
       VDU 6
       PROCviewport(3)
       VDU 14
     ENDIF
   PRINT "Error within the error handler."
   PRINT "Program operation terminated."
   PRINT "Error Number ";ERR
   PRINT "Line Number  ";ERL
   PRINT REPORT$
   END
 ENDPROC

 DEFFNread_cmos_loc(location%)
   REM This function will read a location in the CMOS RAM.
   REM Location is specified by location%.
   LOCAL byte%
   SYS "OS_Byte",cmos_read%,location%,0 TO ,,byte%
 = byte%

 DEFPROCsave_cmos_loc(location%,data%)
   REM This procedure will save the data specified by data% into the
   REM CMOS RAM location, location%. The procedure will then regenerate
   REM the checksum.
   SYS "OS_Byte",cmos_write%,location%,data%
   PROCgenerate_checksum
 ENDPROC

 DEFPROCsave_cmos_loc_nogen(location%,data%)
   REM This procedure will save the data specified by data% into the
   REM CMOS RAM location, location%. The procedure will NOT regenerate
   REM the checksum.
   SYS "OS_Byte",cmos_write%,location%,data%
 ENDPROC

 DEFFNgenerate_checksum
   REM This function will calculate the value of the checksum for the area
   REM of the cmos ram that the test data is stored in, the TDA.
   REM The function will generate a simple additive check sum of all the
   REM locations between the global variables tda-start% and tda_end%.
   REM The function will not add in the the checksum location specified
   REM by the global variable checksum_loc%. The checksum is then calculated
   REM and put into the checksum location.
   REM The checksum is returned by the program although is not required.
   LOCAL sum%
   LOCAL count%
   LOCAL checksum%
   LOCAL checksum_byte%
   LOCAL tda_start_phy%
   REM Adjust the TDA start to be physical.
   tda_start_phy% = tda_start% + &40
   REM Read the TDA Area of the CMOS RAM with an IIC_Control SWI.
   REM Uses the global buffers iic_buf & tda_buf
     REM Tell the chip where to read from by writing the addr to the chip.
       iic_buf%?0 = tda_start_phy%
       SYS "IIC_Control",cmos_ram_write%,iic_buf%,1
       SYS "IIC_Control",cmos_ram_read%,tda_buf%,tda_size%
   REM Calculate the checksum byte in the buffer.
     checksum_byte% = checksum_loc% - tda_start%
   FOR count% = 0 TO tda_size% - 1
     IF count% <> checksum_byte% THEN
         sum% = sum% + tda_buf%?count%
       ENDIF
   NEXT count%
   sum% = sum% AND &FF
   checksum% = 0 - sum%
   SYS "OS_Byte",cmos_write%,checksum_loc%,checksum%
 = checksum%

 DEFPROCgenerate_checksum
   REM This procedure will calculate the value of the checksum for the area
   REM of the cmos ram that the test data is stored in, the TDA.
   REM The procedure will generate a simple additive check sum of all the
   REM locations between the global variables tda-start% and tda_end%.
   REM The procedure will not add in the the checksum location specified
   REM by the global variable checksum_loc%. The checksum is then calculated
   REM and put into the checksum location.
   LOCAL sum%
   LOCAL count%
   LOCAL checksum%
   LOCAL checksum_byte%
   LOCAL tda_start_phy%
   REM Adjust the TDA start to be physical.
   tda_start_phy% = tda_start% + &40
   REM Read the TDA Area of the CMOS RAM with an IIC_Control SWI.
   REM Uses the global buffers iic_buf & tda_buf
     REM Tell the chip where to read from by writing the addr to the chip.
       iic_buf%?0 = tda_start_phy%
       SYS "IIC_Control",cmos_ram_write%,iic_buf%,1
       SYS "IIC_Control",cmos_ram_read%,tda_buf%,tda_size%
   REM Calculate the checksum byte in the buffer.
     checksum_byte% = checksum_loc% - tda_start%
   FOR count% = 0 TO tda_size% - 1
     IF count% <> checksum_byte% THEN
         sum% = sum% + tda_buf%?count%
       ENDIF
   NEXT count%
   sum% = sum% AND &FF
   checksum% = 0 - sum%
   SYS "OS_Byte",cmos_write%,checksum_loc%,checksum%
 ENDPROC

 DEFFNvalidate_checksum
   REM This function will check that the CMOS RAM is valid. The function
   REM performs a simple additive check of the CMOS RAM, except for the
   REM checksum location. The contents of the checksum location is added to
   REM the total summation of the CMOS RAM. If the result is 0 then the CMOS
   REM RAM is valid, else the CMOS RAM is invalid.
   LOCAL check%
   LOCAL sum%
   LOCAL count%
   LOCAL checksum%
   LOCAL cmos_valid%
   LOCAL checksum_byte%
   LOCAL tda_start_phy%
   REM Adjust the TDA start to be physical.
   tda_start_phy% = tda_start% + &40
   REM Read the TDA Area of the CMOS RAM with an IIC_Control SWI.
   REM Uses the global buffers iic_buf & tda_buf
     REM Tell the chip where to read from by writing the addr to the chip.
       iic_buf%?0 = tda_start_phy%
       SYS "IIC_Control",cmos_ram_write%,iic_buf%,1
       SYS "IIC_Control",cmos_ram_read%,tda_buf%,tda_size%
   REM Calculate the checksum byte in the buffer.
     checksum_byte% = checksum_loc% - tda_start%
   FOR count% = 0 TO tda_size% - 1
     IF count% <> checksum_byte% THEN
         sum% = sum% + tda_buf%?count%
       ENDIF
   NEXT count%
   sum% = sum% AND &FF
   checksum% = tda_buf%?checksum_byte%
   check% = sum% + checksum%
   check% = check% AND &FF
   IF check% = 0 THEN
       cmos_valid% = TRUE
     ELSE
       cmos_valid% = FALSE
     ENDIF
 = cmos_valid%

 DEFPROCfind_block(reqd_block%,RETURN location%, RETURN number_of_bytes%)
   REM This procedure will check the CMOS RAM checksum is valid.
   REM If valid then the procedure will find the position in the CMOS RAM
   REM of a Test Data Block TDB. The TDB to be found is specified by
   REM reqd_block%. The location of the TDB is returned by location%.
   REM The number of bytes that the TDB occupies is specified by
   REM number_of_bytes%. If the TDB occupies more than one block then
   REM location% has the value of the last byte of the TDB.
   REM Otherwise the procedure will PANIC and call the general error
   REM trapper, passing error number 100.
   LOCAL checksum_ok%
   checksum_ok% = FNvalidate_checksum
   IF checksum_ok% = TRUE THEN
       PROCfind_the_block(reqd_block%,location%,number_of_bytes%)
     ELSE
       checksum% = FNread_cmos_loc(checksum_loc%)
       ERROR 100, lib_100_error1$+STR$~(checksum%)+lib_100_error2$
     ENDIF
 ENDPROC

 DEFPROCfind_the_block(block%,RETURN block_loc%, RETURN block_size%)
   REM This procedure will do the find block work, as described by it's
   REM parent call. The procedure will return the same parameters as it's
   REM parent. The procedure will check that when searching that the counter
   REM does not exceed the limits of the TDA, if exceeded then the procedure
   REM will PANIC and call the general error trapper, passing error number
   REM 101.
   LOCAL terminator%
   LOCAL byte%
   LOCAL test_data_block%
   test_data_block% = 0
   REM The value for location is set to 1 below the start of the TDB area,
   REM because we pre-increment the value.
   location% = tdb_area_start%
   REPEAT
     number_of_bytes% = 1
     REPEAT
       location% = location% + 1
       IF location% <= tda_end% THEN
           REM We are still within the bounds of the TDA.
           byte% = FNread_cmos_loc(location%)
           terminator% = byte% AND &01
           IF terminator% = 1 THEN
               test_data_block% = test_data_block% + 1
             ELSE
               number_of_bytes% = number_of_bytes% + 1
             ENDIF
         ELSE
           REM We have gone outside the bounds of the TDA, so panic,
           REM call the error handler with err number 101.
           ERROR 101, lib_101_error$ + STR$(block%)
         ENDIF
     UNTIL terminator% = 1
   UNTIL test_data_block% = block%
   block_loc%  = location%
   block_size% = number_of_bytes%
 ENDPROC

 DEFFNread_cmos_bit(location%,bit%)
   REM This function will read the specified location, location%, in the
   REM CMOS RAM, then extract the required bit, bit%, from the CMOS RAM.
   LOCAL byte%
   LOCAL mask%
   LOCAL return_bit%
   mask% = &01 << bit%
   byte% = FNread_cmos_loc(location%)
   return_bit% = (byte% AND mask%) >> bit%
 = return_bit%

 DEFPROCset_cmos_bit(location%,bit%,status%)
   REM This procedure will set the specified bit, bit%, to the specified
   REM status, status%, in the specified CMOS RAM location, location%.
   REM The procedure will then regenerate the checksum.
   LOCAL byte%
   LOCAL data%
   LOCAL mask%
   byte% = FNread_cmos_loc(location%)
   mask% = &01 << bit%
   mask% = NOT mask%
   byte% = byte% AND mask%
   byte% = byte% OR (status% << bit%)
   PROCsave_cmos_loc_nogen(location%,byte%)
   PROCgenerate_checksum
 ENDPROC

 DEFPROCtest_info_nochk(RETURN magic_number%, RETURN checksum%, RETURN printer_type%, RETURN test_type%)
   REM This procedure will find out the information from the SIB data area,
   REM within the TDA. This procedure will not check the CMOS RAM checksum
   REM before reading the CMOS RAM.
   LOCAL test_status%
   magic_number% = FNread_cmos_loc(magic_num_loc%)
   checksum% = FNread_cmos_loc(checksum_loc%)
   test_status% = FNread_cmos_loc(test_status_loc%)
   printer_type% = (test_status% AND printer_mask%) >> printer_shift%
   test_type% = test_status% AND &0F
 ENDPROC

 DEFPROCtest_info(RETURN magic_number%, RETURN checksum%, RETURN printer_type%, RETURN test_type%)
   REM This procedure will find out the information from the SIB data area,
   REM within the TDA. This procedure will check that the CMOS RAM checksum
   REM is valid. If the CMOS is valid then the procedure will read the test
   REM information bytes at the start of the test data area in CMOS RAM.
   REM Otherwise the procedure will PANIC and call the general error
   REM trapper, passing error number 100.
   LOCAL checksum_ok%
   checksum_ok% = FNvalidate_checksum
   IF checksum_ok% = TRUE THEN
       PROCtest_info_nochk(magic_number%,checksum%,printer_type%,test_type%)
     ELSE
       checksum% = FNread_cmos_loc(checksum_loc%)
       ERROR 100, lib_100_error1$+STR$~(checksum%)+lib_100_error2$
     ENDIF
 ENDPROC

 DEFPROCset_test_info(magic_number%,checksum%,printer_type%,test_type%)
   REM This procedure will check that the checksum for the CMOS RAM is valid.
   REM If the CMOS is valid then the procedure will set the test information
   REM bytes at the start of the test data area in CMOS RAM. Then
   REM regenerate the CMOS RAM checksum. Otherwise the procedure will PANIC
   REM and call the general error trapper, passing error number 100.
   LOCAL test_status%
   LOCAL checksum_ok%
   checksum_ok% = FNvalidate_checksum
   IF checksum_ok% = TRUE THEN
       PROCsave_cmos_loc_nogen(magic_num_loc%,magic_number%)
       PROCsave_cmos_loc_nogen(checksum_loc%,checksum%)
       status_data% = test_type% OR (printer_type% << printer_shift%)
       PROCsave_cmos_loc_nogen(test_status_loc%,status_data%)
       PROCgenerate_checksum
     ELSE
       checksum% = FNread_cmos_loc(checksum_loc%)
       ERROR 100, lib_100_error1$+STR$~(checksum%)+lib_100_error2$
     ENDIF
 ENDPROC

 DEFFNget_podule_id(podule_slot%)
   REM This function will get the podule id code for the given podule slot.
   REM If there is no podule in the slot then the error number &0502 will be
   REM returned by the system call, the function checks for this error and
   REM if present will make the function return the podule id of -1,
   REM otherwise the function will return the podule id code. If the podule
   REM id code is 0 then the podule has an extended id code, the function
   REM will use the read header system call.
   LOCAL value%
   LOCAL flag%
   LOCAL id_code%
   LOCAL swi_error%
   LOCAL podule_buff%
   LOCAL id_mask%
   DIM podule_buff% 16
   id_mask% = &78
   SYS "XPodule_ReadID",,,,podule_slot% TO value%; flag%
   IF (flag% AND &01) = &01 THEN
       REM There was an error
       IF value%!0=&0502 THEN
           REM Error was no installed podule.
           id_code% = -1
           swi_error% = TRUE
         ELSE
           REM Some other error
           PROCerror_trap
         ENDIF
     ELSE
       REM There was not an error = podule fitted.
       IF ((value% AND id_mask%) = 0) THEN
           REM Podule not a simple podule. Read extended header.
           SYS "Podule_ReadHeader",,,podule_buff%,podule_slot% TO value%
           id_code% = podule_buff%?3 OR (podule_buff%?4<<8)
         ELSE
           REM Podule was simple podule. RTN simple ID.
           id_code% = value% AND id_mask%
         ENDIF
     ENDIF
 = id_code%

 DEFFNfind_block_start(location%,number_of_bytes%)
   REM This function will find the start location of a TDB from the location
   REM given and the number of bytes in the block.
   LOCAL start%
   start% = location% - (number_of_bytes%-1)
 = start%

 DEFFNget_response(min_number%,max_number%,default$)
   REM This procedure will prompt and wait for a valid keyboard input.
   LOCAL ctrl$
   LOCAL message$
   LOCAL response$
   LOCAL input%
   *FX15,0
   REPEAT
     ctrl$ = yellow$
     message$ = "Please select the required option"
     response$ = FNinput_text(4,0,ctrl$,message$,default$)
     PROCclear_line(4,0)
     input% = ASC(response$)-48
   UNTIL input% >= min_number% AND input% <= max_number%
 = input%

 DEFPROCclear_viewport(port_to_clear%)
   REM This procedure will clear the specified viewport.
   LOCAL count%
   LOCAL length%
   LOCAL viewport
   REM data table specifying the lengths of the viewports.
   REM view port  0, 1, 2, 3, 4
   RESTORE + 0
   DATA          24, 1,13, 6, 3
   FOR count% = 0 TO port_to_clear%
     READ length%
   NEXT count%
   FOR count% = 0 TO length%
     PROCclear_line(port_to_clear%,count%)
   NEXT count%
 ENDPROC

 DEFFNinput_string(view_port%,vert_tab%,control_code$,text$)
   REM This function will prompt for a text input.
   REM The function will print out a line of text (text$)
   REM in the viewport specified by view_port%
   REM on the line specified by vert_tab%, note this is the
   REM relative line number for the specified viewport.
   REM Horizontally tabbed by 1 column.
   REM The control codes for the line of text are specified
   REM by control_code$.
   LOCAL end_line%
   LOCAL reply%
   LOCAL input$
   LOCAL chr$
   LOCAL return%
   LOCAL delete%
   LOCAL backspace%
   LOCAL count%
   LOCAL counter%
   delete%    = 127
   backspace% = 8
   return%    = 13
   text$=text$+" ?"
   PROCviewport(view_port%)
   PRINTTAB(0,vert_tab%)control_code$;
   PRINTTAB(1,vert_tab%)text$;
   end_line%=POS
   count% = 0
   REPEAT
     *FX 15,1
     reply%=GET
     IF reply% = backspace% THEN
         reply% = delete%
       ENDIF
     IF reply% <> delete% AND reply% <> return% THEN
         chr$ = CHR$(reply%)
         temp_store$(count%) = chr$
         PRINTTAB(end_line%+count%,vert_tab%);chr$;
         count% = count% + 1
       ENDIF
     IF reply% = delete% THEN
         PRINTTAB(end_line%+count%,vert_tab%);CHR$(reply%);
         count% = count% - 1
         IF count% = 0 THEN
                temp_store$(count%) = ""
         ENDIF
     ENDIF
   UNTIL reply% = return%
   input$ = ""
   FOR counter% = 0 TO count%-1
     input$ = input$ + temp_store$(counter%)
   NEXT counter%
   FOR counter% = 0 TO temp_store_size%
     temp_store$(counter%) = ""
   NEXT counter%
 = input$

 DEFFNneed_space
   REM This function will look at the test information blocks, some tests
   REM do not require any interaction from the user, these tests will be
   REM checked for. The function will set the require% flag to TRUE if user
   REM interaction is required, else it is set to FALSE.
   REM So far the only tests that do not require interaction from the
   REM user are the soak (3), DRAT (8), PRAT (9) and PRT (10).
   LOCAL magic_num%
   LOCAL checksum%
   LOCAL printer_type%
   LOCAL test_type%
   PROCtest_info(magic_num%,checksum%,printer_type%,test_type%)
   CASE test_type% OF
       WHEN 3
         required% = FALSE
       WHEN 8
         required% = FALSE
       WHEN 9
         required% = FALSE
       WHEN 10
         required% = FALSE
     OTHERWISE
         required% = TRUE
     ENDCASE
 = required%

 DEFPROCtest_type_unknown
   REM This procedure will inform the user that an unknown test type has
   REM been found in the cmos ram.
   LOCAL ctrl$
   LOCAL message$
   ctrl$ = red$+flash_on$
   message$ = "The test type code held in the CMOS"
   PROCprint_line(2,1,ctrl$,message$)
   message$ = "RAM is not known by this program."
   PROCprint_line(2,2,ctrl$,message$)
   message$ = "The CMOS RAM or the Test Disc has"
   PROCprint_line(2,4,ctrl$,message$)
   message$ = "been corrupted, refer to ACORN"
   PROCprint_line(2,5,ctrl$,message$)
   message$ = "Computers Ltd for advice."
   PROCprint_line(2,6,ctrl$,message$)
   PROCpress_space(FALSE)
 ENDPROC

 DEFFNread_syst_variable(syst_variable$)
   REM This function will read the value of a system variable, given by
   REM syst_variable$. The function will return the numeric value of the
   REM variable. If the variable DOES NOT exist or is not set, then the
   REM function will return 0 as the value.
   LOCAL variable$
   LOCAL variable%
   variable$ = ""
   variable% = -1
   PROCread_variable(syst_variable$,var_valid%,string$)
   IF var_valid% = -1 THEN
       variable% = 0
     ELSE
       variable% = FNstring_to_number(string$)
     ENDIF
 = variable%

 DEFFNread_syst_string(syst_variable$)
   REM This function will read the value of a system string variable, given
   REM by variable$. The function will return the string contents of the
   REM variable. If the variable DOES NOT exist or is not set, then the
   REM function will return "" (NULL) as the contents of the string.
   LOCAL variable$
   LOCAL var_valid%
   LOCAL string$
   variable$ = ""
   PROCread_variable(syst_variable$,var_valid%,string$)
   IF var_valid% = -1 THEN
       variable$ = ""
     ELSE
       variable$ = string$
     ENDIF
 = variable$

 DEFPROCread_variable(variable_to_read$, RETURN var_ok%, RETURN return_string$)
   REM This procedure will read the value of a system variable, given by
   REM variable_to_read$. The procedure will return the variable var_ok, and
   REM return_string$. The variable var_ok% is used to indicate the status
   REM of the variable to be found. -1 indicates that the variable was not
   REM found. If this condition is found then the procedure will call an
   REM error generator, the error generator will inform the user of the
   REM unknown variable. The procedure uses the buffer swi_buffer% and
   REM references the variable swi_buf_size%.
   LOCAL length%
   LOCAL check_var%
   LOCAL var_press%
   length%        = 0
   return_string$ = ""
   check_var%     = -1
   var_press%     = -1
   SYS "XOS_ReadVarVal",variable_to_read$,,check_var% TO ,,var_press%
   IF var_press% = 0 OR var_press% >= swi_buf_size% THEN
       IF var_press% = 0 THEN
           PROCread_variable_error(1,variable_to_read$)
         ELSE
           PROCread_variable_error(3,variable_to_read$)
         ENDIF
       var_ok% = -1
     ELSE
       PROCclear_swi_buffer
       SYS "XOS_ReadVarVal",variable_to_read$,swi_buffer%,swi_buf_size%,0,3 TO ,,length%
       IF length% = 0 THEN
           var_ok% = -1
           PROCread_variable_error(2,variable_to_read$)
         ELSE
           var_ok% = 0
           swi_buffer%?length% = 13
           return_string$ = $swi_buffer%
         ENDIF
     ENDIF
 ENDPROC

 DEFPROCread_variable_error(error_code%,variable_to_read$)
   REM This procedure will provide error handling for the read_variable
   REM function. The procedure will inform the user that a system variable
   REM has not been found or that it was not set properly (0 length).
   REM When the user has acknowledged the procedure will end.
   REM The procedure will check the global variable 'show_syst_var_error%'.
   REM If the variable is TRUE then the error message is shown, if not then
   REM the procedure does nothing, and then resets the variable back.
   IF show_syst_var_error% = TRUE THEN
       PROCshow_variable_error(error_code%,variable_to_read$)
     ELSE
       show_syst_var_error% = TRUE
     ENDIF
 ENDPROC

 DEFPROCshow_variable_error(error_code%,variable_to_read$)
   IF error_in_progress% <> TRUE THEN
       VDU 6
       PROCviewport(3)
       VDU 14
     ENDIF
   PRINT gen_lib_msg1$ + variable_to_read$
   CASE error_code% OF
       WHEN 1
         PRINT gen_lib_msg2$
         PRINT gen_lib_msg3$
       WHEN 2
         PRINT gen_lib_msg4$
         PRINT gen_lib_msg5$
       WHEN 3
         PRINT gen_lib_msg6$
         PRINT gen_lib_msg5$
     ENDCASE
   IF error_in_progress% <> TRUE THEN
       PROCwait(5)
       PROCclear_viewport(3)
       PRINT
     ENDIF
 ENDPROC

 DEFFNstring_to_number(variable_to_convert$)
   REM This function will convert a string in to a number, the function
   REM will only convert numeric chrs. If the string contains non-numeric
   REM chrs then the user is told, and zero is returned.
   LOCAL length%
   LOCAL count%
   LOCAL chr$
   LOCAL return_var%
   LOCAL numb_string$
   LOCAL non_numeric%
   non_numeric% = FALSE
   numb_string$ = "0123456789-"
   chr$         = ""
   length%      = 0
   return_var%  = 0
   length% = LEN(variable_to_convert$)
   FOR count% = 0 TO length%
     chr$     = MID$(variable_to_convert$,count%,1)
     chr_pos% = INSTR(numb_string$,chr$)
     IF chr_pos% = 0 THEN
         REM Non numeric chr
         non_numeric% = TRUE
       ENDIF
   NEXT count%
   IF non_numeric% = FALSE THEN
       return_var%  = VAL(variable_to_convert$)
     ELSE
       return_var%  = 0
       PROCprint_line(3,0,red$,non_numb_string_msg1$+variable_to_convert$)
       PROCprint_line(3,1,red$,non_numb_string_msg2$)
       PROCprint_line(3,2,red$,non_numb_string_msg3$)
       PROCwait(5)
       PROCclear_line(3,0)
       PROCclear_line(3,1)
       PROCclear_line(3,2)
     ENDIF
 = return_var%

 DEFPROCclear_swi_buffer
   REM This procedure will clear the swi_buffer to contain &00.
   LOCAL count%
   FOR count% = 0 TO swi_buf_size%
     swi_buffer%?count% = &00
   NEXT count%
 ENDPROC

 DEFFNdo_this_test(block_to_check%)
   REM This function will check the TDB specified by block_to_check% 3 to
   REM see if we are required to do the test that called this function.
   LOCAL location%
   LOCAL size%
   LOCAL start_loc%
   LOCAL do_test_bit%
   PROCfind_block(block_to_check%,location%,size%)
   start_loc% = FNfind_block_start(location%,size%)
   do_test_bit% = FNread_cmos_bit(start_loc%,1)
   IF do_test_bit% = &01 THEN
       do_test_bit% = TRUE
     ELSE
       do_test_bit% = FALSE
     ENDIF
 = do_test_bit%

 DEFFNinput_number(view_port%,vert_tab%,control_code$,text$,min%,max%)
   REM This function will prompt for a numeric input.
   REM The function will print out a line of text (text$)
   REM in the viewport specified by view_port%
   REM on the line specified by vert_tab%, note this is the
   REM relative line number for the specified viewport.
   REM Horizontally tabbed by 1 column.
   REM The control codes for the line of text are specified
   REM by control_code$.
   REM The function will use the function FNinput_string, to input
   REM the number, then convert it to a number, check it is in the
   REM required range.
   LOCAL input_string$
   LOCAL input_numb%
   LOCAL string_valid%
   LOCAL zero%
   LOCAL nine%
   zero% = 48
   nine% = 57
   input_string$ = ""
   input_numb% = -99
   REPEAT
     REPEAT
       input_string$ = FNinput_string(view_port%,vert_tab%,control_code$,text$)
       length% = LEN(input_string$)
       string_valid% = TRUE
       FOR count% = 0 TO length%
         chr$ = MID$(input_string$,count%,1)
         IF ASC(chr$) < zero% OR ASC(chr$) > nine% THEN
             string_valid% = FALSE
           ENDIF
       NEXT count%
     UNTIL string_valid% = TRUE
     input_numb% = VAL(input_string$)
   UNTIL input_numb% >= min% AND input_numb% <= max%
 = input_numb%

 DEFPROCnet_errors(tries%, RETURN net_working%, RETURN tries%)
   REM This function will provide net error handling facilities.
   REM The function will return a TRUE or FALSE flag.
   REM The function will check the BASIC error number ERR for a valid net
   REM error number. The function looks for net errors to do with :-
   REM BLM refers to Broadcast loader module, NET refers to NETFS.
   REM User not known             - from NET &105BC - stop.
   REM No Clock                   - from BLM &3A3   - stop.
   REM Line Jammed                - from BLM &3A0   - stop.
   REM Station XXXX not present   - from BLM &38A   - stop.
   REM Station XXXX not listening - from BLM &3A2   - wait  - return.
   REM No reply from station XXXX - from BLM &3A5   - wait  - return.
   REM Not logged on              - from NET &105BF - logon - return.
   REM File already open          - from NET &105C2 - wait  - return.
   LOCAL error_number%
   error_number% = ERR
   IF (error_number% < &300 AND error_number% > &3FF) OR (error_number% < &10500 AND error_number% > &105FF) THEN
       PROCerror_trap
     ELSE
       CASE error_number% OF
           WHEN &105BC
             REM User not known
             net_working% = FALSE
             tries% = 10
           WHEN &3A3
             REM No Clock
             net_working% = FALSE
             tries% = 10
           WHEN &3A0
             REM Line Jammed, this is returned by RISC OS 2.01, instead of
             REM No Clock !!! - A bug me thinks.
             net_working% = FALSE
             tries% = 10
           WHEN &38A
             REM Station XXXX not present
             net_working% = FALSE
             tries% = 10
           WHEN &3A5
             REM No reply from station XXXX
             ctrl$ = yellow$
             message$ = "No rely from FS, waiting to retry."
             PROCprint_line(4,0,ctrl$,message$)
             net_working% = TRUE
             tries% = tries% + 1
             PROCwait(15)
             PROCclear_line(4,0)
           WHEN &3A2
             REM Station XXXX not listening
             ctrl$ = yellow$
             message$ = "FS not listening, waiting to retry."
             PROCprint_line(4,0,ctrl$,message$)
             net_working% = TRUE
             tries% = tries% + 1
             PROCwait(15)
             PROCclear_line(4,0)
           WHEN &105BF
             REM Not logged on
             ctrl$ = yellow$
             message$ = "Not logged on, waiting to logon."
             PROCprint_line(4,0,ctrl$,message$)
             net_working% = TRUE
             tries% = tries% + 1
             PROCwait(10)
             PROCclear_line(4,0)
             message$ = "Trying to logon to the FS."
             PROCprint_line(4,0,ctrl$,message$)
             logon_name$ = FNread_syst_string("TEST$USER_NAME")
             OSCLI "*NET"
             OSCLI "*LOGON 0.254 "+logon_name$
             OSCLI "DEFAULT_FILER"
             PROCclear_line(4,0)
           WHEN &105C2
             REM File is already open, some body else is having a look,
             REM wait a while and retry. However if after 5 attempts file
             REM still open close it.
             IF tries% <= 5 THEN
                 net_working% = TRUE
                 PROCwait(15)
               ELSE
                 net_working% = TRUE
                 OSCLI "*NET"
                 OSCLI "*CLOSE"
                 OSCLI "DEFAULT_FILER"
               ENDIF
           OTHERWISE
             REM The error produced was a BLM or NET error, but was
             REM not one of the above, so send it to  the error handler.
             net_working% = FALSE
             tries% = 10
         ENDCASE
     ENDIF
 ENDPROC

 DEFFNopen_file(file_to_open$)
   REM This function will openup the file specified by file_to_open$,
   REM this variable refers to the full file information including the
   REM filer type. If the file does not exist then the function will
   REM openout the file (create the file). The function will return
   REM the file number. The function will handle net errors via the
   REM net_error handler.
   LOCAL file%
   LOCAL net_ok%
   LOCAL net_attempts%
   LOCAL max_attempts%
   LOCAL ERROR
   net_attempts% = 1
   max_attempts% = 10
   net_ok% = TRUE
   REM Open the file concerned.
     ON ERROR LOCAL PROCnet_errors(net_attempts%,net_ok%,net_attempts%)
     IF net_ok% = TRUE AND net_attempts% < max_attempts% THEN
         file% = OPENUP file_to_open$
       ELSE
         REM Terminal net error abort.
         net_dead% = TRUE
         PROCerror_trap
       ENDIF
     ON ERROR LOCAL OFF
   REM Check to see that the file opened actually exists, file% <>0.
     IF file% = 0 THEN
         REM The file did not exist so create it
         CLOSE#file%
         file% = OPENOUT file_to_open$
       ENDIF
 = file%

 DEFFNadd_path(name$)
   REM This function will add the path and machine id to the file name,
   REM specified by name$. The function will return the path and name
   REM of the file.
   REM Don't moan if TEST$MACHINE_NUMBER is not set. From Vsn 1.96
   LOCAL path$
   LOCAL path_name$
   LOCAL machine_id$
   show_syst_var_error% = FALSE
   machine_id$ = FNread_syst_string("TEST$MACHINE_NUMBER")
   name$       = name$ + machine_id$
   path$       = FNread_syst_string("TEST$REPORT_DIR")
   path_name$  = path$+"."+name$
 = path_name$

 DEFPROCpointer_to_end(file_number%)
   REM This procedure will find out how long the file is and then set the
   REM pointer for the next byte to the end.
   LOCAL file_length%
   REM Find out how long the file is.
     file_length% = EXT#file_number%
   REM Set the pointer for the next byte in the file to the end.
     PTR#file_number% = file_length%
 ENDPROC

 DEFPROCsave_text(file_number%,text$)
   REM This procedure will save the text in text$ to the file specified
   REM by file_number%.
   BPUT#file_number%,text$
 ENDPROC

 DEFPROCclose_file(file_number%,name_of_file$)
   REM This procedure will close the file specified by file_number% and
   REM set the file type of file name$ to text.
   CLOSE#file_number%
   OSCLI "SETTYPE "+name_of_file$+" TEXT"
 ENDPROC

 DEFFNfind_file(name$,directory$)
   REM This procedure will search a given directory for the file
   REM specified by "name$". The directory to search is given by
   REM "directory$", this is the full directory path required by
   REM RISC OS to find a file. The function will return a TRUE/FALSE flag
   REM to indicate if the file was FOUND.
   REM This function uses the buffer swi_buffer% and references the variable
   REM swi_buf_end%.
   LOCAL next_file%
   LOCAL read_name$
   LOCAL file$
   LOCAL count%
   LOCAL file_found%
   LOCAL c_flag%
   LOCAL v_flag%
   LOCAL z_flag%
   LOCAL flags%
   LOCAL r3
   LOCAL r4
   LOCAL gbpb_swi_error%
   PROCclear_swi_buffer
   next_file% = 0
   gbpb_swi_error% = FALSE
   REPEAT
     SYS "XOS_GBPB",9,directory$,swi_buffer%,1,next_file%,swi_buf_size%,0 TO ,,,r3,r4;flags%
     v_flag% = flags% AND &01
     IF v_flag% = 1 THEN
         REM There has been an error - rtn FALSE
         gbpb_swi_error% = TRUE
         read_name$ = ""
       ENDIF
     IF r3 = 0 THEN
         REM No files were read - rtn FALSE
         gbpb_swi_error% = TRUE
         read_name$ = ""
       ENDIF
     IF gbpb_swi_error% <> TRUE THEN
         next_file% = r4
         read_name$ = ""
         count% = 0
         WHILE swi_buffer%?count% <> &00
           read_name$ = read_name$ + CHR$(swi_buffer%?count%)
           count% = count% + 1
         ENDWHILE
       ENDIF
   UNTIL next_file% = -1 OR read_name$ = name$ OR gbpb_swi_error% = TRUE
   IF read_name$ = name$ THEN
       file_found% = TRUE
     ELSE
       file_found% = FALSE
     ENDIF
 = file_found%

 DEFPROCdisc_freespace(check_drive$, RETURN total_free%, RETURN largest_block%)
   REM This procedure will return the amount of free space and the largest
   REM block available on the disc that is currently in the drive
   REM specified by drive$.
   SYS "ADFS_FreeSpace",check_drive$ TO total_free%,largest_block%
 ENDPROC

 DEFFNfind_filer(sys_var$)
   REM This function will find out which filing system we are using
   REM for the test program source.
   LOCAL sys_string$
   LOCAL file_system$
   LOCAL filer$
   sys_string$  = FNread_syst_string(sys_var$)
   file_system$ = LEFT$(sys_string$,3)
   file_system$ = FNto_lower(file_system$)
   IF file_system$ = "net" THEN
       filer$ = "NETFS "
     ENDIF
   IF file_system$ = "adf" THEN
       filer$ = "ADFS  "
     ENDIF
   IF file_system$ = "scs" THEN
       filer$ = "SCSIFS"
     ENDIF
 = filer$

 DEFFNto_upper(string$)
   REM This function will convert the string specified by string$ from
   REM lower case letters to UPPER CASE LETTERS. Any upper case letters
   REM present in the string will be left as upper case.
   LOCAL length%
   LOCAL count%
   LOCAL chr$
   LOCAL chr%
   LOCAL return_string$
   length% = LEN(string$)
   FOR count% = 1 TO length%
     chr$ = MID$(string$,count%,1)
     chr% = ASC(chr$)
     IF chr% >= 97 AND chr% <= 122 THEN
         chr% = chr% - 32
         chr$ = CHR$(chr%)
       ENDIF
     return_string$ = return_string$ + chr$
   NEXT count%
 = return_string$

 DEFFNto_lower(string$)
   REM This function will convert the string specified by string$ from
   REM UPPER CASE LETTERS to lower case letters. Any lower case letters
   REM present in the string will be left as lower case.
   LOCAL length%
   LOCAL count%
   LOCAL chr$
   LOCAL chr%
   LOCAL return_string$
   length% = LEN(string$)
   FOR count% = 1 TO length%
     chr$ = MID$(string$,count%,1)
     chr% = ASC(chr$)
     IF chr% >= 65 AND chr% <= 90 THEN
         chr% = chr% + 32
         chr$ = CHR$(chr%)
       ENDIF
     return_string$ = return_string$ + chr$
   NEXT count%
 = return_string$

 DEFFNask_if_passed(test_name$)
   REM This function will ask the user if the subjective test just
   REM completed as passed or failed.
   LOCAL test_ok%, alert$

   test_ok% = FALSE
   alert$ = FNread_syst_string("TEST$ALERT")
   alert$ = FNto_lower(alert$)
   IF alert$ = "on" THEN
           PROCspace_sound
   ENDIF
   PROCprint_result(4,0,yellow$,ask_pass_msg1$+test_name$)
   PROCprint_result(4,1,yellow$,ask_pass_msg2$+test_name$)
   REPEAT
     reply$ = GET$
     reply$ = FNto_lower(reply$)
   UNTIL reply$ = "y" OR reply$ = "n"
   IF reply$ = "y" THEN
       test_ok% = TRUE
     ENDIF
 = test_ok%

 DEFFNtest_type_string
   REM This function will return a string which is the 6 chr test type
   REM name, used for the title display.
   LOCAL magic_num%
   LOCAL checksum%
   LOCAL printer_type%
   LOCAL test_type%
   LOCAL string$
   PROCtest_info(magic_num%,checksum%,printer_type%,test_type%)
   string$ = FNtest_string(test_type%)
 = string$

 DEFFNtest_type_string_nochk
   REM This function will return a string which is the 6 chr test type
   REM name, used for the title display. No CMS checksum performed.
   LOCAL magic_num%
   LOCAL checksum%
   LOCAL printer_type%
   LOCAL test_type%
   LOCAL string$
   PROCtest_info_nochk(magic_num%,checksum%,printer_type%,test_type%)
   string$ = FNtest_string(test_type%)
 = string$

 DEFFNtest_string(test_numb%)
   REM This function will return a string for the test number given.
   LOCAL rtn_string$
   CASE test_numb% OF
       WHEN 0
         rtn_string$ = "UN-DEF"
       WHEN 1
         rtn_string$ = "PROD-0"
       WHEN 2
         rtn_string$ = "PROD-1"
       WHEN 3
         rtn_string$ = "PROD-S"
       WHEN 4
         rtn_string$ = "PROD-2"
       WHEN 5
         rtn_string$ = "QA-AUD"
       WHEN 6
         rtn_string$ = "DEALER"
       WHEN 7
         rtn_string$ = "DIAG"
       WHEN 8
         rtn_string$ = "DRAT"
       WHEN 9
         rtn_string$ = "PRAT"
       WHEN 10
         rtn_string$ = "PRT"
       WHEN 11
         rtn_string$ = "!TEST"
       WHEN 12
         rtn_string$ = "SET_UP"
       WHEN 13
         rtn_string$ = "??????"
       WHEN 14
         rtn_string$ = "??????"
       WHEN 15
         rtn_string$ = "??????"
       OTHERWISE
         rtn_string$ = "ERROR"
     ENDCASE
 = rtn_string$

 DEFFNmch_type_string
   REM This function will return a string which is the name of the machine
   REM type being tested.
   LOCAL magic_num%
   LOCAL checksum%
   LOCAL printer_type%
   LOCAL test_type%
   LOCAL machine_type%
   PROCtest_info(magic_num%,checksum%,printer_type%,test_type%)
   machine_type% = (magic_num% AND &F0)>>4
   CASE machine_type% OF
       WHEN 0
         string$ = "??Machine??"
       WHEN 1
         string$ = "A300/A400  "
       WHEN 2
         string$ = "A400/1     "
       WHEN 3
         string$ = "A3000      "
       WHEN 4
         string$ = "R140       "
       WHEN 5
         string$ = "A500/R200  "
       WHEN 6
         string$ = "A5000      "
       WHEN 7
         string$ = "Portable   "
       WHEN 8
         string$ = "Heron      "
       WHEN 9
         string$ = "Medusa     "
       OTHERWISE
         string$ = "Undefned   "
     ENDCASE
 = string$

 DEFFNfind_sw_type(type%)
   REM This function will check the test type given by type% and assign
   REM the return string to the appropriate message.
   LOCAL string$
   CASE type% OF
       WHEN 0
         string$ = "Unknown"
       WHEN 1
         string$ = "Board Level"
       WHEN 2
         string$ = "1st Functional"
       WHEN 3
         string$ = "Production Soak"
       WHEN 4
         string$ = "2nd Functional"
       WHEN 5
         string$ = "QA Audit"
       WHEN 6
         string$ = "Dealer"
       WHEN 7
         string$ = "Diagnostics"
       WHEN 8
         string$ = "D.R.A.T."
       WHEN 9
         string$ = "P.R.A.T."
       WHEN 10
         string$ = "P.R.T."
       WHEN 11
         string$ = "!TEST App"
       WHEN 12
         string$ = "Set Up For Shiping"
       WHEN 13
         string$ = "Un Defined"
       WHEN 14
         string$ = "Un Defined"
       WHEN 15
         string$ = "Error Condition."
     ENDCASE
 = string$

 DEFFNconvert_log_phy(logical%)
   REM This function will convert a logical CMOS RAM address, logical%,
   REM into a physical CMOS RAM address, physical%.
   LOCAL physical%
   LOCAL offset1%
   LOCAL offset2%
   LOCAL offset3%
   offset1%   = &40
   offset2%   = &B0
   offset3%   = &F0
   IF logical% >= &00 AND logical% <= &BF THEN
       physical% = logical% + offset1%
     ENDIF
   IF logical% >= &C0 AND logical% <= &EF THEN
       physical% = logical% - offset2%
     ENDIF
   IF logical% >= &F0 AND logical% <= &FF THEN
       physical% = logical% - offset3%
     ENDIF
 = physical%

 DEFFNconvert_phy_log(physical%)
   REM This function will convert a physical CMOS RAM address, physical%,
   REM into a logical CMOS RAM address, logical%.
   LOCAL logical%
   LOCAL offset1%
   LOCAL offset2%
   LOCAL offset3%
   offset1%   = &40
   offset2%   = &B0
   offset3%   = &F0
   IF physical% >= &00 AND physical% <= &0F THEN
       logical% = physical% + offset3%
     ENDIF
   IF physical% >= &10 AND physical% <= &3F THEN
       logical% = physical% + offset2%
     ENDIF
   IF physical% >= &40 AND physical% <= &FF THEN
       logical% = physical% - offset1%
     ENDIF
 = logical%

 DEFPROCread_whole_cmos(buffer%)
   REM This procedure will read the whole CMOS RAM into the buffer specified
   REM by, buffer%. The procedure will start reading from location &C0,
   REM logical, &10, physical, specified by cmos_start%. The procedure will
   REM read a number of bytes, specified by the global variable cmos_size%.
   LOCAL temp_buffer1%
   LOCAL temp_buffer2%
   LOCAL temp_buffer3%
   LOCAL buffer1_size%
   LOCAL buffer2_size%
   LOCAL buffer3_size%
   LOCAL cmos_start1%
   LOCAL cmos_start2%
   buffer1_size% = &100 - &40
   buffer2_size% = &40 - &10
   buffer3_size% = &10
   cmos_start1% = &40
   cmos_start2% = &10
   DIM temp_buffer1% buffer1_size%
   DIM temp_buffer2% buffer2_size%
   DIM temp_buffer3% buffer3_size%
   REM Now read the CMOS RAM in two goes ..
     REM Tell the chip where to read from by writing the addr to the chip.
       temp_buffer3%?0 = cmos_start1%
       SYS "IIC_Control",cmos_ram_write%,temp_buffer3%,1
       SYS "IIC_Control",cmos_ram_read%,temp_buffer1%,buffer1_size%
     REM Tell the chip where to read from by writing the addr to the chip.
       temp_buffer3%?0 = cmos_start2%
       SYS "IIC_Control",cmos_ram_write%,temp_buffer3%,1
       SYS "IIC_Control",cmos_ram_read%,temp_buffer2%,buffer2_size%
   REM Now make up one output buffer, buffer%, which looks to be logical.
     FOR count% = 0 TO buffer1_size% - 1
       buffer%?count% = temp_buffer1%?count%
     NEXT count%
     FOR count% = 0 TO buffer2_size% - 1
       buffer%?(count% + buffer1_size%) = temp_buffer2%?count%
     NEXT count%
 ENDPROC

 DEFPROCwrite_whole_cmos(buffer%)
   REM This procedure will write the contents of the buffer specified by,
   REM buffer%, to the CMOS RAM. The procedure will start writing the
   REM contents of the buffer at location &C0, logical, &10, physical,
   REM specified by cmos_start%. The procedure will read a number of bytes,
   REM specified by the global variable cmos_size%.
   LOCAL temp_buffer1%
   LOCAL temp_buffer2%
   LOCAL buffer1_size%
   LOCAL buffer2_size%
   LOCAL cmos_start1%
   LOCAL cmos_start2%
   buffer1_size% = (&100 - &40) + 1
   buffer2_size% = (&40 - &10) + 1
   cmos_start1% = &40
   cmos_start2% = &10
   DIM temp_buffer1% buffer1_size%
   DIM temp_buffer2% buffer2_size%
   REM Now write to the CMOS RAM in two goes ..
     REM Put the start addr in to the first byte of the buffer.
       temp_buffer1%?0 = cmos_start1%
       FOR count% = 1 TO buffer1_size% - 1
         temp_buffer1%?count% = buffer%?(count% - 1)
       NEXT count%
       SYS "IIC_Control",cmos_ram_write%,temp_buffer1%,buffer1_size%
     REM Put the start addr in to the first byte of the buffer.
       temp_buffer2%?0 = cmos_start2%
       FOR count% = 1 TO buffer2_size% -1
         temp_buffer2%?count% = buffer%?((count% + buffer1_size%) - 2)
       NEXT count%
       SYS "IIC_Control",cmos_ram_write%,temp_buffer2%,buffer2_size%
 ENDPROC

 DEFFNFind_draw_number(Podule%)
   REM This function will return the D.O. Number of a ROM fitted to an
   REM expansion card. The function will read the Podule id, if the podule
   REM ID code is 0 then the ID is extended. Read the Podule header, and then
   REM read the chunk directories. The directory that returns &F6 contains
   REM the D.O. number. The function will return the D.O. number as a string.
   REM If the chunk directory cannot be found with an ID of &F6 then the
   REM function will return the string "Unknown". If the podule fails to find
   REM the end of chunk directories the function returns the string "Error".

   REM ******************************************************************
   REM *   CAUTION   THIS FUNCTION HAS MULTIPLE EXIT POINTS   CAUTION   *
   REM ******************************************************************

   LOCAL exec_id%
   LOCAL flags
   LOCAL do_number$
   LOCAL count%
   LOCAL id%
   LOCAL Chunkno%
   LOCAL size%
   LOCAL OSid%
   LOCAL ptr
   LOCAL Chknext%
   LOCAL buffer
   LOCAL size%
   LOCAL chr$
   LOCAL reply_msg1$
   LOCAL reply_msg1$
   reply_msg1$ = "Error"
   reply_msg2$ = "Unknown"
   DIM exec_id% 16
   SYS"XPodule_ReadID",,,,Podule% TO id%;flags
   IF (flags AND 1) = 1 THEN
       do_number$ = reply_msg1$
     ELSE
       IF id% = 0 THEN
           SYS"XPodule_ReadHeader",,,exec_id%,Podule% TO ;flags
           IF (flags AND 1) = 1 THEN
               do_number$ = reply_msg1$
               = do_number$
             ENDIF
         ENDIF
       Chunkno%=-1
       REPEAT
         Chunkno% = Chunkno% + 1
         SYS"XPodule_EnumerateChunks",Chunkno%,,,Podule% TO Chknext%,size%,OSid%,,ptr%;flags
         IF (flags AND 1) =1 THEN
             do_number$ = reply_msg1$
             = do_number$
           ENDIF
       UNTIL OSid%= &F6 OR Chknext%=0
       IF Chknext% = 0 THEN
           do_number$ = reply_msg2$
           = do_number$
         ELSE
           DIM buffer% size% + &20
           SYS"XPodule_ReadChunk",Chunkno%,,buffer%,Podule% TO ;flags
           IF (flags AND 1) = 1 THEN
               do_number$ = reply_msg1$
               = do_number$
             ELSE
               FOR count% = 0 TO size% - 1
                 chr$ = CHR$(buffer%?count%)
                 do_number$ = do_number$ + chr$
               NEXT count%
             ENDIF
         ENDIF
     ENDIF
  = do_number$

 DEFPROCto_io_tester(string$)
   REM This procedure will send the specified string, string$, to the io
   REM tester. All errors will be reported via the current error trapper,
   REM and any return string will placed in swi_buffer.
   LOCAL resp%
   LOCAL len%
   SYS "PortsIf_Send",,string$+CHR$(10)+CHR$(0),,pifsendto% TO resp%
   IF resp% = ASC(">") THEN
       SYS "PortsIf_Receive",,swi_buffer%,swi_buf_size%,pifrecvto% TO ,,len%
       IF swi_buffer%?(len%-1) = 10 THEN
           swi_buffer%?(len%-1) = 13
       ENDIF
   ELSE
       $swi_buffer% = ""
   ENDIF
 ENDPROC

 DEFFNto_io_tester(string$)
   REM This function will send the specified string, string$, to the io
   REM tester. The function is interested in any errors.
   REM Any errors reported will be passed back to the caller - SWI errors.
   LOCAL resp%
   LOCAL flags%
   SYS "XPortsIf_Send",,string$+CHR$(10)+CHR$(0),,pifsendto% TO resp%;flags%
   IF (flags% AND 1) = 1 THEN
       REM The SWI returned an error - probably a timeout.
       REM So find out the error number and return it.
       resp% = resp%!0
   ENDIF
 = resp%

 DEFFNto_io_testto(string$,time%)
   REM This function will send the specified string, string$, to the io
   REM tester, without waiting long for completion.
   REM Any errors reported will be passed back to the caller - SWI errors.
   LOCAL resp%
   LOCAL flags%
   SYS "XPortsIf_Send",,string$+CHR$(10)+CHR$(0),,time% TO resp%;flags%
   IF (flags% AND 1) = 1 THEN
       REM The SWI returned an error - probably a timeout.
       REM So find out the error number and return it.
       resp% = resp%!0
   ENDIF
 = resp%

 DEFFNfrom_io_tester(string$)
   REM This function will optionally send a command to the ports tester, obtain a
   REM response string and return it as the function's result.
   LOCAL len%
   LOCAL flags%

   IF LEN(string$) > 0 AND FNto_io_tester(string$) <> portsREPLY% THEN
     REM return early - prompt failed to elicit a full output buffer
     =""
   ENDIF
   SYS "XPortsIf_Receive",,swi_buffer%,swi_buf_size%,pifrecvto% TO ,,len%;flags%
   IF (flags% AND 1) = 1 THEN
       REM The SWI returned an error - probably a timeout, so return an empty buffer
       $swi_buffer%=""
   ELSE
       IF swi_buffer%?(len%-1) = 10 THEN
           swi_buffer%?(len%-1) = 13
       ENDIF
   ENDIF
 = $swi_buffer%

 DEFFNcheck_port_tester
   REM This function will check that the port tester is fitted and will
   REM return either FALSE (not fitted) or the port tester's version number.
   REM Use SWINumberFromString to find out of the module is loaded. If not
   REM then return false.
   LOCAL flags%
   LOCAL pifversion%
   LOCAL xportsif_open_swi%
   SYS "XOS_SWINumberFromString",,"XPortsIf_Open" TO xportsif_open_swi%;flags%
   IF (flags% AND 1) = 1 THEN
       REM There was an error, so it's either not fitted or is faulty.
       REM Either way we can't use it.
       pifversion% = FALSE
     ELSE
       SYS xportsif_open_swi% TO ,pifversion%;flags%
       IF (flags% AND 1) = 1 THEN
           REM There was an error, so it's either not fitted or is faulty.
           REM Either way we can't use it.
           pifversion% = FALSE
         ENDIF
     ENDIF
 = pifversion%

 DEFPROCset_return_codes(status%)
   REM This procedure will, depending upon status, set the system variable
   REM BASIC$ReturnCode to be either PASS or FAIL.
   IF status% = PASS THEN
       PROCset_basic_return_code(EXIT_PASS)
     ENDIF
   IF status% = FAIL THEN
       PROCset_basic_return_code(EXIT_FAIL_UP_CONT)
     ENDIF
 ENDPROC

 DEFPROCset_basic_return_code(value%)
   REM This procedure will set the system variable BASIC$ReturnCode to the
   REM value given.
   LOCAL value$
   value$ = STR$(value%)
   SYS "OS_SetVarVal","BASIC$ReturnCode",value$,,0,0
 ENDPROC

 DEFFNread_module_version(module_name$)
   REM This function will check to see if the module specified by
   REM module_name$ - (case insensitive) - is can be found. If it cannot be
   REM found the function returns the version as FALSE (0), otherwise it
   REM goes on to get the modules version number and returns that.
   LOCAL module_number%
   SYS "XOS_Module",18,module_name$ TO ,module_number%;flags%
   IF (flags% AND &01) = 1 THEN
       REM Module not found
       REM Return vsn% as FALSE
       vsn% = FALSE
     ELSE
       REM Module found !
       REM Check it out !
       vsn% = FNget_module_version(module_number%)
     ENDIF
 = vsn%

 DEFFNget_module_version(module_numb%)
   REM This function will get the version number of a module, whose name is
   REM specified by module_numb%. The function will return the version
   REM number as an interger. The version number will be multiplied by 100
   REM I.E. 2.67 is 267. uses the general swi buffer, swi_buffer%.
   REM The function will read the module information, get the base address
   REM for the module and then extract the address of the help string. From
   REM here its a quick dash thrught the string to find the '.' in the
   REM version number and convert this to an interger.
   REM If the module information cannot be read the function returns FALSE
   REM (0) as the version number.
   LOCAL module_address%
   LOCAL help_word_addr%
   LOCAL help_word_off%
   LOCAL help_str_start%
   LOCAL help_str$
   LOCAL count%
   LOCAL byte%
   LOCAL decimal_point%
   LOCAL major_vsn$
   LOCAL minor_vsn$
   SYS "XOS_Module",12,module_number% TO ,,,module_address%;flags%
   IF (flags% AND &01) = 1 THEN
       REM An error occured, probably not found.
       REM Return vsn_numb% as FALSE
       vsn_numb% = FALSE
     ELSE
       REM Got the info, ok.
       help_word_addr% = module_address%+&14
       help_word_off% = help_word_addr%!0
       help_str_start% = module_address%+help_word_off%
       help_str$ = ""
       PROCclear_swi_buffer
       count% = 0
       REPEAT
         byte% = help_str_start%?count%
         IF byte% <> 0 THEN
             swi_buffer%?count% = byte%
             count% += 1
           ENDIF
       UNTIL (byte% = 0) OR (count% >= 40)
       swi_buffer%?count% = 13
       help_str$ = $(swi_buffer%)
       decimal_point% = INSTR(help_str$,".")
       major_vsn$ = MID$(help_str$,(decimal_point%-1),1)
       minor_vsn$ = MID$(help_str$,(decimal_point%+1),2)
       vsn_numb% = (VAL(major_vsn$)*100)+VAL(minor_vsn$)
       PROCclear_swi_buffer
     ENDIF
 = vsn_numb%

 DEFFNread_cycle_ctr
   REM This function will read the cycle counter in CMOS RAM.
   LOCAL start_blk%
   LOCAL size%
   LOCAL loc%
   PROCfind_block(cycles_tdb%,loc%,size%)
   blk_start% = FNfind_block_start(loc%,size%)
   lsb% = FNread_cmos_loc(blk_start%)
   msb% = FNread_cmos_loc(blk_start%+1)
   lsb% = (lsb% AND &FC) >> 2
   msb% = (msb% AND &FC) >> 2
   cycle% = lsb% + (msb% << 6)
 = cycle%

 REM End of GEN_LIB, the general library.
