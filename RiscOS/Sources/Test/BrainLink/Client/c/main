/*************************************************************************
Copyright [2000] Pace Micro Technology PLC. All rights reserved.

The copyright in this material is owned by Pace Micro Technology PLC
("Pace"). This material is regarded as highly confidential trade secret
of Pace. It may not be reproduced, used, sold or in any other way exploited
or transferred to any third party without the prior written permission of
Pace.
--------------------------------------------------------------------------
* Purpose: This is the client application for the brainlink module.
*
*
--------------------------------------------------------------------------
* History:
*
*
**************************************************************************/

/**************************************************************************
* Include header files
**************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
#include <signal.h>
#include "tboxlibs/toolbox.h"
#include "tboxlibs/event.h"
#include "tboxlibs/wimplib.h"
#include "tboxlibs/saveas.h"
#include "tboxlibs/quit.h"
#include "kernel.h"
#include "swis.h"
#include "events.h"
#include "error.h"
#include "serial/serial.h"
#include "screen.h"
#include "buffer.h"
#include "brainlink.h"
#include "blclient.h"
#include "gui.h"
#include "handler.h"
#include "zmodem/zmodem.h"
#include "tboxevents.h"
#include "script.h"

/***************************************************************************
* Local #defines
***************************************************************************/
#define TaskModule_RegisterUpCall  (int)0x4D309
#define UPCALL_SERIAL              (int)0x4D301


/****************************************************************************
* local typedefs
*****************************************************************************/


/****************************************************************************
* Function prototypes
*****************************************************************************/
static void appInitialise (APP_DATA* const application_data);
static void installSignalHandlers (void);
static void atexitHandler (void);
static void catchErrors(int signum);
static int appFinalise (APP_DATA* const application_data);


/* wimp event handler prototypes */
static int getInput (int event_code, WimpPollBlock* event, IdBlock* id_block, void* handle);

/* message handler prototypes */
static int setReadyToReadInput (WimpMessage* message, void* handle);




/****************************************************************************
* Global data
*****************************************************************************/
static APP_DATA application_data;
static MessagesFD msg_block;         /* declare a message block for use with toolbox initialise */

static int current_wimp;

static _kernel_oserror erb;
jmp_buf env;

static unsigned int null_event_counter = 0;
bool ack = false;

/*************************************************************************
* function: main
*
* description:
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
**************************************************************************/
int main(int argc, char *argv[])
{
   int poll_word = 0;
   int event_code;
   WimpPollBlock poll_block;
   _kernel_oserror *e;

   installSignalHandlers ();
   atexit (atexitHandler); /* register the atexit handler. */

   appInitialise (&application_data);

   if (setjmp (env) == MAIN_FROM_CATCH_ERRORS)
   {
      unsigned int* regdump;
      unsigned int* os_regdump;

      /* sort out the register dump */
      _swix (OS_ChangeEnvironment,  _INR (0, 3) | _OUT (3), 7, 0, 0, 0, &regdump);
      _swix (OS_ChangeEnvironment, _INR (0, 3) | _OUT (1), 13, 0, 0, 0, &os_regdump);

      /* copy the C register dump into the OS space */
      if (regdump && os_regdump)
      {
         memcpy (os_regdump, regdump, 4 * 16);
      }

      installSignalHandlers ();
      error_showErrorContinue (&erb);
   }

   while (application_data.quit == false) /* poll the wimp for events while quit flag is false. */
   {
       e = event_poll (&event_code, &poll_block, &poll_word);  /* poll the wimp */
   }

   exit (EXIT_SUCCESS);

}


/*************************************************************************
* function: installSignalHandlers
*
* description:
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
*************************************************************************/
static void installSignalHandlers (void)
{
   signal (SIGOSERROR, catchErrors);   /* OS error */
   signal (SIGILL,     catchErrors);   /* Illegal instruction */
   signal (SIGSEGV,    catchErrors);   /* Segment violation */
   signal (SIGSTAK,    catchErrors);   /* Stack overflow */
   signal (SIGFPE,     catchErrors);   /* FPE error */
}



/*************************************************************************
* function: atexitHandler
*
* description: The handler for the atexit function.
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
*************************************************************************/
static void atexitHandler (void)
{
   appFinalise (&application_data);
}



/*************************************************************************
* function: appInitialise
*
* description: Initialises the application.
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
*************************************************************************/
static void appInitialise (APP_DATA* const application_data)
{

   error_showError (serial_openPort ());
   error_showError (serial_flushBuffers (true, true));   /* flush the serial ports buffers */
   error_showError (serial_setBlockingStatus (false));   /* all reads are to be non-blocking */


   /* initialise as a toolbox task */
   error_showError (toolbox_initialise (0, 310, wimp_messages, tb_events, "<BrainlinkClient$Dir>",
                                  &msg_block, &application_data->id_block,
                                  &current_wimp, &application_data->task_handle, 0));


   screen_readScreenModeVariables (&application_data->mode);
   screen_readVDUVariables (&application_data->vdu);

   /* initialise event lib */
   event_initialise (&application_data->id_block);

   event_set_mask (1); /* mask out null events. */

   /* register for upcall DeviceRxDataPresent */
   _swi (TaskModule_RegisterUpCall, _INR (0, 2), 0, 15, application_data->task_handle);

   /* register event handlers */
   event_register_wimp_handler (-1, Wimp_ENull, getInput, (void*)application_data);
   event_register_wimp_handler (-1, Wimp_ENull, script_process, 0);

   /* register message handlers */
   event_register_message_handler (UPCALL_SERIAL, setReadyToReadInput, 0);
   event_register_message_handler (Wimp_MDataLoad, handler_dataLoadMessage, 0);
   event_register_message_handler (Wimp_MDataOpen, handler_dataOpenMessage, 0);
   event_register_message_handler (Wimp_MQuit, handler_quit, NULL);

   /* register toolbox handlers */
   event_register_toolbox_handler (-1, Toolbox_ObjectAutoCreated, handler_tbObjectAutoCreated, (void*)application_data);

   event_register_toolbox_handler (-1, TASK_WINDOW_OPEN, handler_windowOpen, (void*)&application_data->main_window);
   event_register_toolbox_handler (-1, TASK_WINDOW_CLOSE, handler_windowClose, (void*)&application_data->main_window);
   event_register_toolbox_handler (-1, STATUS_WINDOW_OPEN, handler_windowOpen, (void*)&application_data->status_window);
   event_register_toolbox_handler (-1, STATUS_WINDOW_CLOSE, handler_windowClose, (void*)&application_data->status_window);
   event_register_toolbox_handler (-1, WRCHV_WINDOW_OPEN, handler_windowOpen, (void*)&application_data->wrchv_window);
   event_register_toolbox_handler (-1, WRCHV_WINDOW_CLOSE, handler_windowClose, (void*)&application_data->wrchv_window);
   event_register_toolbox_handler (-1, DEBUG_WINDOW_OPEN, handler_windowOpen, (void*)&application_data->debug_window);
   event_register_toolbox_handler (-1, DEBUG_WINDOW_CLOSE, handler_windowClose, (void*)&application_data->debug_window);

   event_register_toolbox_handler (-1, SET_BAUD_RATE_110, handler_setBaudRate, 0);
   event_register_toolbox_handler (-1, SET_BAUD_RATE_300, handler_setBaudRate, 0);
   event_register_toolbox_handler (-1, SET_BAUD_RATE_600, handler_setBaudRate, 0);
   event_register_toolbox_handler (-1, SET_BAUD_RATE_1200, handler_setBaudRate, 0);
   event_register_toolbox_handler (-1, SET_BAUD_RATE_2400, handler_setBaudRate, 0);
   event_register_toolbox_handler (-1, SET_BAUD_RATE_4800, handler_setBaudRate, 0);
   event_register_toolbox_handler (-1, SET_BAUD_RATE_9600, handler_setBaudRate, 0);
   event_register_toolbox_handler (-1, SET_BAUD_RATE_14400, handler_setBaudRate, 0);
   event_register_toolbox_handler (-1, SET_BAUD_RATE_19200, handler_setBaudRate, 0);
   event_register_toolbox_handler (-1, SET_BAUD_RATE_38400, handler_setBaudRate, 0);
   event_register_toolbox_handler (-1, SET_BAUD_RATE_57600, handler_setBaudRate, 0);
   event_register_toolbox_handler (-1, SET_BAUD_RATE_115200, handler_setBaudRate, 0);

   event_register_toolbox_handler (-1, HELP_BUTTON, handler_helpButton, 0);

   event_register_toolbox_handler (-1, CLEAR_BUFFER, handler_clearWindow, 0);
   event_register_toolbox_handler (-1, SET_BUFFER_SIZE_BUTTON, handler_increaseWindowBufferSize, 0);

   event_register_toolbox_handler (-1, SaveAs_AboutToBeShown, handler_saveAsWindow, 0);
   event_register_toolbox_handler (-1, SaveAs_SaveToFile, handler_saveAsWindow, 0);
   event_register_toolbox_handler (-1, SaveAs_SaveCompleted, handler_saveAsWindow, 0);
   event_register_toolbox_handler (-1, SaveAs_DialogueCompleted, handler_saveAsWindow, 0);

   event_register_toolbox_handler (-1, Quit_Quit, handler_tbquit, (void*)application_data);

   /* create the circular text buffers that will hold all of the text in each work area. */
   buffer_createBuffer (&application_data->main_window.text_buf,   200);
   buffer_createBuffer (&application_data->debug_window.text_buf,  200);
   buffer_createBuffer (&application_data->wrchv_window.text_buf,  200);
   buffer_createBuffer (&application_data->status_window.text_buf, 200);

   screen_pixelsToOSUnits (&application_data->vdu.gchar_size_x,
                           &application_data->vdu.gchar_size_y,
                           &application_data->mode);


   application_data->main_window.text_properties.character_width  = application_data->vdu.gchar_size_x;
   application_data->main_window.text_properties.character_height = application_data->vdu.gchar_size_y;
   application_data->main_window.window_open = false;

   application_data->debug_window.text_properties.character_width  = application_data->vdu.gchar_size_x;
   application_data->debug_window.text_properties.character_height = application_data->vdu.gchar_size_y;
   application_data->debug_window.window_open = false;

   application_data->wrchv_window.text_properties.character_width  = application_data->vdu.gchar_size_x;
   application_data->wrchv_window.text_properties.character_height = application_data->vdu.gchar_size_y;
   application_data->wrchv_window.window_open = false;

   application_data->status_window.text_properties.character_width  = application_data->vdu.gchar_size_x;
   application_data->status_window.text_properties.character_height = application_data->vdu.gchar_size_y;
   application_data->status_window.window_open = false;

   application_data->current_window = &application_data->main_window;
   application_data->hour_glass_on = false;
   application_data->quit = false;

}


/************************************************************************
* function: appFinalise
*
* description:
* Parameters:
* Assumptions:
*
*
*
* Returns: error code.
*          0, no error.
*
*
*
************************************************************************/
static int appFinalise (APP_DATA* const application_data)
{
   error_showError (serial_closePort ());     /* close the serial ports. */

   /* free any memory dynamically allocated here. */
   buffer_destroyBuffer (&application_data->main_window.text_buf);
   buffer_destroyBuffer (&application_data->debug_window.text_buf);
   buffer_destroyBuffer (&application_data->wrchv_window.text_buf);
   buffer_destroyBuffer (&application_data->status_window.text_buf);

   return 0;
}





/**************************************************************************
* function: setReadyToRead
*
* description:
*
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
**************************************************************************/
static int setReadyToReadInput (WimpMessage* message, void* handle)
{
   enableNullEvents ();

   return 1;
}

/**************************************************************************
* function: enableNullEvents
*
* description: when an upcall is recieved from the TaskModule,
*              this function is called. It enables null events.
*              The data is read from the serial port in the
*              null event handler.
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
**************************************************************************/
extern int enableNullEvents (void)
{
   unsigned int mask;

   if (null_event_counter == 0)
   {
      event_get_mask (&mask);
      event_set_mask (mask & 0xfffffffe);    /* enable null events. */
   }

   null_event_counter++;

   return 1;
}



/**************************************************************************
* function: disableNullEvents
*
* description:
*
*
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
**************************************************************************/
extern int disableNullEvents (void)
{
   unsigned int mask;

   if (null_event_counter > 0)
   {
      null_event_counter--;
      if (null_event_counter == 0)
      {
         event_get_mask (&mask);
         event_set_mask (mask | 1);  /* disable null events. */
      }
   }

   return 1;
}




/*******************************************************************************
* function: getInput
*
* description: Function is called when there is data
*              present on the serial port.
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
********************************************************************************/
static int getInput (int event_code, WimpPollBlock* event, IdBlock* id_block, void* handle)
{
   APP_DATA* application_data = (APP_DATA*)handle;
   bool data_read = false;
   static char escape_sequence[10];
   static bool processing_escape_sequence = false;
   static unsigned int escape_sequence_size = 0;
   int ps;
   int increase = 0;
   int lines_up = 0;

   application_data->main_window.lines_to_move_up   = 0;
   application_data->debug_window.lines_to_move_up  = 0;
   application_data->wrchv_window.lines_to_move_up  = 0;
   application_data->status_window.lines_to_move_up = 0;

   if (serial_getNumberOfBytesInBuffer () > 0)
   {
      char buffer[256];
      unsigned int bytes_read;
      char read;
      int i;

      data_read = true;
      bytes_read = serial_read (buffer, 256);


      for (i = 0; i < bytes_read; i++)
      {
         read = buffer[i];

         if (read == 0x1b) /* if an escape character is detected */
         {
            processing_escape_sequence = true;
         }
         else if (read == '>')
         {
            ack = true;
         }

         if (processing_escape_sequence)
         {
            escape_sequence[escape_sequence_size++] = read;

            if ((read == 'H') || (read == 'f') || (read == 'A') || (read == 'B') || (read == 'C') ||
                (read == 'D') || (read == 's') || (read == 'u') || (read == 'J') || (read == 'k') || (read == 'm'))
            {
               if (read == 'm')
               {
                  ps = ((escape_sequence[4] - '0') * 10) + (escape_sequence[5] - '0');

                  switch (ps)
                  {
                     case RED:
                        application_data->current_window = &application_data->debug_window;
                        break;
                     case GREEN:
                        application_data->current_window = &application_data->status_window;
                        break;
                     case YELLOW:
                        application_data->current_window = &application_data->wrchv_window;
                        break;
                     case WHITE:
                        application_data->current_window = &application_data->main_window;
                        break;
                     case BLACK:
                        directzmodemrx ("@.");
                     default:
                       application_data->current_window = &application_data->main_window;
                  }
               }
               processing_escape_sequence = false;
               escape_sequence_size = 0;

            }

         }

         else if ((read >= 0x20 && read <= 0x7f) || (read == 0x0D))
         {

            if (read == 0x0D)  /* if the CR character is detected */
            {
               gui_invalidateCharacterArea (application_data->current_window); /* to remove the cursor from the current last line */
               if (buffer_incrementLastLine (&application_data->current_window->text_buf))
               {
                  application_data->current_window->lines_to_move_up++;
               }
               gui_invalidateCharacterArea (application_data->current_window);

            }
            else if (read == 0x7f) /* if the delete character is detected */
            {
                gui_invalidateCharacterArea (application_data->current_window);  /* first, remove the cursor. */
                buffer_removeCharFromLastLine (&application_data->current_window->text_buf);
                gui_invalidateCharacterArea (application_data->current_window);
            }

            else
            {
               if (buffer_addCharToLastLine (&application_data->current_window->text_buf, read))
               {
                  gui_invalidateCharacterArea (application_data->current_window);  /* to add the character to the end of the line */
               }
               else
               {
                  gui_invalidateCharacterArea (application_data->current_window);  /* to remove the cursor from the end of the line */
                  if (buffer_incrementLastLine (&application_data->current_window->text_buf))
                  {
                     application_data->current_window->lines_to_move_up++;
                  }
               }
            }
         }
      }


      /* update each window */
      if (application_data->main_window.window_open)
      {
         increase = gui_updateWorkAreaSize (&application_data->main_window);
         gui_moveScrollBar (&application_data->main_window, -increase);

         if (application_data->main_window.lines_to_move_up > 0)
         {
            lines_up = application_data->main_window.lines_to_move_up;
            gui_blockAreaMove (&application_data->main_window);
            application_data->main_window.lines_to_move_up = 0;
         }
      }
      if (application_data->status_window.window_open)
      {
         increase = gui_updateWorkAreaSize (&application_data->status_window);
         gui_moveScrollBar (&application_data->status_window, -increase);

         if (application_data->status_window.lines_to_move_up > 0)
         {
            lines_up = application_data->status_window.lines_to_move_up;
            gui_blockAreaMove (&application_data->status_window);
            application_data->status_window.lines_to_move_up = 0;
         }
      }
      if (application_data->wrchv_window.window_open)
      {
         increase = gui_updateWorkAreaSize (&application_data->wrchv_window);
         gui_moveScrollBar (&application_data->wrchv_window, -increase);

         if (application_data->wrchv_window.lines_to_move_up > 0)
         {
            lines_up = application_data->wrchv_window.lines_to_move_up;
            gui_blockAreaMove (&application_data->wrchv_window);
            application_data->wrchv_window.lines_to_move_up = 0;
         }
      }
      if (application_data->debug_window.window_open)
      {
         increase = gui_updateWorkAreaSize (&application_data->debug_window);
         gui_moveScrollBar (&application_data->debug_window, -increase);

         if (application_data->debug_window.lines_to_move_up > 0)
         {
            lines_up = application_data->debug_window.lines_to_move_up;
            gui_blockAreaMove (&application_data->debug_window);
            application_data->debug_window.lines_to_move_up = 0;
         }
      }

   }
   else if (data_read == true)
   {
      disableNullEvents ();
   }

   return 0;

}






/*************************************************************************
* catchErrors()
*
* Catch OS errors and report them with the
* opportunity to continue or quit (done inside
* main itself).
*
* This is the last function in the file since
* it plays around with stack checking, and you
* can't read the previous state. If this was in
* the middle of the source and someone wrote a
* #pragma above it, endless confusion could
* otherwise arise as to why the instruction had
* no effect on some of the functions here...
*
* Parameters: The signal number (ignored).
*************************************************************************/

#pragma no_check_stack

extern void catchErrors(int signum)
{
  erb = *_kernel_last_oserror();

  /* Go back to main to report the error */
  longjmp(env, MAIN_FROM_CATCH_ERRORS);

  exit(EXIT_FAILURE);
}






