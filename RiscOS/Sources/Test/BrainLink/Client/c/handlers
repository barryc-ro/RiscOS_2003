/*************************************************************************
Copyright [2000] Pace Micro Technology PLC. All rights reserved.

The copyright in this material is owned by Pace Micro Technology PLC
("Pace"). This material is regarded as highly confidential trade secret
of Pace. It may not be reproduced, used, sold or in any other way exploited
or transferred to any third party without the prior written permission of
Pace.
--------------------------------------------------------------------------
* Purpose: This is the client application for the brainlink module.
*
*
--------------------------------------------------------------------------
* History:
*
*
**************************************************************************/

/**************************************************************************
* Include header files
**************************************************************************/

#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "brainlink.h"
#include "handlers.h"
#include "serialcomm/serialcomm.h"
#include "buffer.h"
#include "gui.h"
#include "tboxlibs/wimplib.h"
#include "tboxlibs/menu.h"
#include "tboxlibs/event.h"
#include "zmodem/zmodem.h"
#include "tboxevents.h"
#include "tboxcomps.h"



/**************************************************************************
* function: tbObjectAutoCreatedHandler
*
* description:
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
**************************************************************************/
extern int tbObjectAutoCreatedHandler (int event_code, ToolboxEvent* event,
                                       IdBlock* id_block, void* handle)
{
   char* objname;
   APP_DATA* application_data = (APP_DATA*)handle;


   objname = ((ToolboxObjectAutoCreatedEvent*)event)->template_name;

   if (strcmp (objname, "taskWin") == 0)
   {
      window_get_wimp_handle (0, id_block->self_id, &application_data->task_window.window_handle);
      toolbox_set_client_handle (0, id_block->self_id, (void*)&application_data->task_window);
      event_register_wimp_handler (id_block->self_id, Wimp_ERedrawWindow, redrawWindow, (void*)&application_data->task_window);
      event_register_wimp_handler (id_block->self_id, Wimp_EKeyPressed, keyHandler, (void*)application_data);
      event_register_wimp_handler (id_block->self_id, Wimp_EMouseClick, mouseClickHandler, (void*)&application_data->task_window);
      initWorkAreaSize (&application_data->task_window);
   }

   else if (strcmp (objname, "debugWin") == 0)
   {
      window_get_wimp_handle (0, id_block->self_id, &application_data->debug_window.window_handle);
      toolbox_set_client_handle (0, id_block->self_id, (void*)&application_data->debug_window);
      event_register_wimp_handler (id_block->self_id, Wimp_ERedrawWindow, redrawWindow, (void*)&application_data->debug_window);
      event_register_wimp_handler (id_block->self_id, Wimp_EMouseClick, mouseClickHandler, (void*)&application_data->task_window);
      initWorkAreaSize (&application_data->debug_window);
   }

   else if (strcmp (objname, "wrchvWin") == 0)
   {
      window_get_wimp_handle (0, id_block->self_id, &application_data->wrchv_window.window_handle);
      toolbox_set_client_handle (0, id_block->self_id, (void*)&application_data->wrchv_window);
      event_register_wimp_handler (id_block->self_id, Wimp_ERedrawWindow, redrawWindow, (void*)&application_data->wrchv_window);
      event_register_wimp_handler (id_block->self_id, Wimp_EMouseClick, mouseClickHandler, (void*)&application_data->task_window);
      initWorkAreaSize (&application_data->wrchv_window);
   }

   else if (strcmp (objname, "statusWin") == 0)
   {
      window_get_wimp_handle (0, id_block->self_id, &application_data->status_window.window_handle);
      toolbox_set_client_handle (0, id_block->self_id, (void*)&application_data->status_window);
      event_register_wimp_handler (id_block->self_id, Wimp_ERedrawWindow, redrawWindow, (void*)&application_data->status_window);
      event_register_wimp_handler (id_block->self_id, Wimp_EMouseClick, mouseClickHandler, (void*)&application_data->task_window);
      initWorkAreaSize (&application_data->status_window);
   }

   return 1;
}





/**************************************************************************
* function: windowOpenHandler
*
* description:
*
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
**************************************************************************/
extern int windowOpenHandler (int event_code, ToolboxEvent* event, IdBlock* id_block, void* handle)
{
   WINDOW_DATA* win_data = (WINDOW_DATA*)handle;

   win_data->window_open = true;

   return 1;
}

/**************************************************************************
* function: windowCloseHandler
*
* description:
*
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
**************************************************************************/
extern int windowCloseHandler (int event_code, ToolboxEvent* event, IdBlock* id_block, void* handle)
{
   WINDOW_DATA* win_data = (WINDOW_DATA*)handle;

   win_data->window_open = false;

   return 1;
}




/**************************************************************************
* function: clearWindow
*
* description:
*
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
**************************************************************************/
extern int clearWindow (int event_code, ToolboxEvent* event, IdBlock* id_block, void* handle)
{
   WINDOW_DATA* window_to_clear;

   toolbox_get_client_handle (0, id_block->ancestor_id, (void*)&window_to_clear);

   eraseTextBufferContents (&window_to_clear->text_buf);

   initWorkAreaSize (window_to_clear);
   invalidateWindow (window_to_clear);

   return 1;
}




/*********************************************************************************/
/* function: keyHandler                                                          */
/*                                                                               */
/* description:                                                                  */
/*                                                                               */
/*                                                                               */
/* Parameters:                                                                   */
/* Assumptions:                                                                  */
/*                                                                               */
/*                                                                               */
/*                                                                               */
/* Returns:                                                                      */
/*                                                                               */
/*                                                                               */
/*                                                                               */
/*                                                                               */
/*********************************************************************************/
extern int keyHandler (int event_code, WimpPollBlock* event, IdBlock* id_block, void* handle)
{
   int key_code;

   key_code = event->words[6];  /* extract the keycode */

   if (key_code < 0x80)
   {
      writeToSerialPort ((char*)&key_code, 1); /* and output it to the serial port. */
   }
   else
   {
      _swix (Wimp_ProcessKey, _IN (0), key_code);
   }

   return 1;
}





/*************************************************************************
* function: mouseClickHandler
*
* description: This is the event handler for a mouse click event.
*
*
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
*************************************************************************/
extern int mouseClickHandler (int event_code, WimpPollBlock* event, IdBlock* id_block, void* handle)
{
   int window_handle = event->mouse_click.window_handle;

   /* in this function, will need give the window input focus */
   _swix (Wimp_SetCaretPosition, _INR (0, 5), window_handle,
                                              -1,
                                              0,
                                              0,
                                              0x02000000,
                                              0);


   return 1;
}




/*************************************************************************
* function: saveAsWindowEventHandler
*
* description:
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
*************************************************************************/
extern int saveAsWindowEventHandler (int event_code, ToolboxEvent* event,
                                     IdBlock* id_block, void* handle)
{
   WINDOW_DATA* window_to_save;
   SaveAsSaveToFileEvent* save_info = (SaveAsSaveToFileEvent*)event;
   FILE* file_ptr = 0;
   TEXT_LINE* current_line;
   bool finished = false;
   int flags = 0;

      /* get the WINDOW_DATA information. */
   toolbox_get_client_handle (0, id_block->ancestor_id, (void*)&window_to_save);


   switch (event_code)
   {
      case SaveAs_AboutToBeShown:
         break;
      case SaveAs_SaveToFile:
         file_ptr = fopen (save_info->filename, "w");
         if (file_ptr) /* if the file was opened ok */
         {
            /* traverse the text buffer and copy each line to the file. */
            current_line = window_to_save->text_buf.start;
            do
            {
               if (current_line ==  window_to_save->text_buf.last_line)
               {
                  finished = true;
               }
               fprintf (file_ptr, current_line->text);
               fprintf (file_ptr, "\n");
               current_line = current_line->next_line;
            }
            while (finished == false);

            fclose (file_ptr);
            flags = 1;  /* need to set flag to 1 to say that save was successful. */
         }
         saveas_file_save_completed (flags, id_block->self_id, save_info->filename);
         break;
      case SaveAs_SaveCompleted:
         /* maybe mark the document as unmodified */
         break;
      case SaveAs_DialogueCompleted:
         /* do any tidying up
            maybe delete the SaveAs object if desired */
         break;
   }
   return 1;
}



/**************************************************************************
* function: increaseBufferSizeWindowEventHandler
*
* description:
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
**************************************************************************/
extern int increaseBufferSizeWindowEventHandler (int event_code, ToolboxEvent* event,
                                                 IdBlock* id_block, void* handle)
{
   WINDOW_DATA* window;
   int obj_id = id_block->self_id;
   int increase;

   /* get the WINDOW_DATA information. */
   toolbox_get_client_handle (0, id_block->ancestor_id, (void*)&window);

   switch (event_code)
   {
      /* when the user presses add, read what is set, and increase the buffer size by
         that amount. */
      case SET_BUFFER_SIZE_BUTTON:
        numberrange_get_value (0, obj_id, SET_BUFFER_SIZE_FIELD, &increase);  /* get the buffer size */
        extendTextBuffer (&window->text_buf, increase);
        updateWorkAreaSize (window);
        break;
      default:
        break;
   }

   return 1;
}



/**************************************************************************
* function: helpButtonEventHandler
*
* description: event handler for the help button.
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
**************************************************************************/
extern int helpButtonEventHandler (int event_code, ToolboxEvent* event,
                                   IdBlock* id_block, void* handle)
{
   char command[] = "<BrainlinkClient$Dir>.!help";
   _swix (Wimp_StartTask, _IN (0), command);
   return 1;
}



/**************************************************************************
* function: setBaudRateEventHandler
*
* description:
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
**************************************************************************/
extern int setBaudRateEventHandler (int event_code, ToolboxEvent* event,
                                    IdBlock* id_block, void* handle)
{

   static ComponentId last_selection = 9;

   if (id_block->self_component != last_selection)
   {
      switch (event_code)
      {
         case SET_BAUD_RATE_1200:
             menu_set_tick (0, id_block->self_id, last_selection, 0);
             menu_set_tick (0, id_block->self_id, id_block->self_component, 1);
             last_selection = BAUD_1200;
             setBaudRate ("1200");
            break;
         case SET_BAUD_RATE_2400:
            menu_set_tick (0, id_block->self_id, last_selection, 0);
            menu_set_tick (0, id_block->self_id, id_block->self_component, 1);
            last_selection = BAUD_2400;
            setBaudRate ("2400");
            break;
         case SET_BAUD_RATE_4800:
            menu_set_tick (0, id_block->self_id, last_selection, 0);
            menu_set_tick (0, id_block->self_id, id_block->self_component, 1);
            last_selection = BAUD_4800;
            setBaudRate ("4800");
            break;
         case SET_BAUD_RATE_9600:
            menu_set_tick (0, id_block->self_id, last_selection, 0);
            menu_set_tick (0, id_block->self_id, id_block->self_component, 1);
            last_selection = BAUD_9600;
            setBaudRate ("9600");
            break;
         case SET_BAUD_RATE_14400:
            menu_set_tick (0, id_block->self_id, last_selection, 0);
            menu_set_tick (0, id_block->self_id, id_block->self_component, 1);
            last_selection = BAUD_14400;
            setBaudRate ("14400");
            break;
         case SET_BAUD_RATE_19200:
            menu_set_tick (0, id_block->self_id, last_selection, 0);
            menu_set_tick (0, id_block->self_id, id_block->self_component, 1);
            last_selection = BAUD_19200;
            setBaudRate ("19200");
            break;
         case SET_BAUD_RATE_38400:
            menu_set_tick (0, id_block->self_id, last_selection, 0);
            menu_set_tick (0, id_block->self_id, id_block->self_component, 1);
            last_selection = BAUD_38400;
            setBaudRate ("38400");
            break;
         case SET_BAUD_RATE_57600:
            menu_set_tick (0, id_block->self_id, last_selection, 0);
            menu_set_tick (0, id_block->self_id, id_block->self_component, 1);
            last_selection = BAUD_57600;
            setBaudRate ("57600");
            break;
         case SET_BAUD_RATE_115200:
            menu_set_tick (0, id_block->self_id, last_selection, 0);
            menu_set_tick (0, id_block->self_id, id_block->self_component, 1);
            last_selection = BAUD_115200;
            setBaudRate ("115200");
            break;
         default:
            menu_set_tick (0, id_block->self_id, last_selection, 0);
            menu_set_tick (0, id_block->self_id, 9, 1);
            last_selection = BAUD_115200;
            setBaudRate ("115200");
      }
   }


   return 1;
}




/****************************************************************************
* function: dataloadMessageHandler
*
* description: When a file is dragged onto the window, this function
*              transmits the file using the Z-Modem protocol
*
* Parameters:
* Assumptions:
*
*
*
* Returns: 1
*
*
*
****************************************************************************/
extern int dataloadMessageHandler (WimpMessage* message, void* handle)
{
    WimpMessage msg = *message;

    msg.hdr.your_ref = msg.hdr.my_ref;
    directzmodemtx (msg.data.data_load_ack.leaf_name);

    if (message->hdr.action_code == Wimp_MDataLoad)
    {
       msg.hdr.action_code = Wimp_MDataLoadAck;
       wimp_send_message (Wimp_EUserMessage, &msg, msg.hdr.sender, 0, 0);
    }

    return 1;
}






/**************************************************************************
* function: tbquitHandler
*
* description:
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
**************************************************************************/
extern int tbquitHandler (int event_code, ToolboxEvent* event,
                          IdBlock* id_block, void* handle)
{
   APP_DATA* application_data = (APP_DATA*)handle;

   application_data->quit = true;
   return 1;
}



/*************************************************************************
* function: QuitHandler
*
* description:
* Parameters:
* Assumptions:
*
*
*
* Returns:
*
*
*
*
*************************************************************************/
extern int quitHandler (WimpMessage* message, void* handle)
{
   APP_DATA* application_data = (APP_DATA*)handle;

   application_data->quit = true;
   return 1;
}





