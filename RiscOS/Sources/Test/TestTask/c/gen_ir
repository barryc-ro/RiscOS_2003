//Generate RC5 IR codes
// NCE  08/03/2000

#include <unixlib.h>
#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>
#include "swis.h"
#include "PeeknPoke.h"
#include "support.h"
#include "debug.h"

//convert 16 bits to 32 bit Manchester code
int man_encode(int code)
{
  int l;
  int result=0;

  for(l=0;l<16;l++)
  {
    result=result<<2;

    if(code & 0x8000)
    {
      result=result | 0x01;
    }
    else
    {
      result=result | 0x02;
    }
    code=code<<1;
  }
  return result;
}


void gen_ir(char *data)
{
  int l;
  static toggle=0x800;
  _kernel_swi_regs reg;
  struct timeval start;
  struct timeval now;
  long int result[30];
  int command;
  int code;
  int manchester;   //manchester coded RC5 output

  toggle=toggle^0x800;

  command=atoi(data);

  code=command | 0x2000; //start bit
  code=code | 0x1000;     //field bit (codes 0-63)
  code=code | toggle;    //toggle bit
  code=code | 0x280;     //system address bits

  deprintf("RC5 code: 0X%X\n",code);

  manchester=man_encode(code);  //convert the code to manchester coding

  manchester=manchester<<4; //were not interested in the top 4 bits

   //make sure the standby LED if off
   poke_reg(0x0C,0x00);
   wait(2);

  _kernel_swi(OS_IntOff, &reg, &reg);

  for(l=0;l<28;l++)
  {
     if(manchester & 0x80000000)
    {
      poke_reg(0x0C,0x02); //standby LED
    }
    else
    {
      poke_reg(0x0C,0x00); //standby LED
    }
    manchester=manchester<<1;

    gettimeofday(&start,NULL);

    do
    {
      gettimeofday(&now,NULL);
    }
    while ((((now.tv_sec-start.tv_sec)*1000000)
          +(now.tv_usec - start.tv_usec))<800);

    result[l]=(((now.tv_sec-start.tv_sec)*1000000)
          +(now.tv_usec - start.tv_usec))-800;

  }

  _kernel_swi(OS_IntOn, &reg, &reg);

  //return the LED to off state
  poke_reg(0x0C,0x00);

 //list the timing deviations
 for(l=0;l<28;l+=2)
  {
    deprintf("%ld  %ld\n",result[l],result[l+1]);
  }
}

