
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "os.h"

#include "main.h"

#define RIGHT_CTRL 7
#define KEYPAD_1 107
#define KEYPAD_2 124
#define KEYPAD_3 108
#define KEYPAD_4 122
#define KEYPAD_5 123
#define KEYPAD_6 26
#define KEYPAD_7 27
#define KEYPAD_8 42
#define KEYPAD_9 43

#define UNUSED(x) x=x

static int host_ip_address[4]        = {192,168,1,0};
static int sub_net_mask              = 24;              /* which equates to 255.255.255.0 */
static int gateway_ip_address[4]     = {192,168,1,1};
static int boot_server_ip_address[4] = {192,168,1,2};
static int primary_dns_ip_address[4] = {192,168,1,2};
static char boot_mount_path[32]      = "/FuncTest";
static int static_ip_booting         = 1;              /* yes */
static int atm_pvc_address           = 88;

static int key_pressed(int code);
static int check_for_keys(void);
static void set_up_the_variables(void);

static int ip_address_value;

static void *module_workspace;

static void exithandler(void)
{
  
}

_kernel_oserror *MyInit ( char *cmd_tail, int podule_base, void *pw )
{
  UNUSED(cmd_tail);
  UNUSED(podule_base);

  module_workspace = pw;
  atexit(exithandler);

  if (key_pressed(RIGHT_CTRL))
  {
    ip_address_value = check_for_keys();

    if (ip_address_value)
    {
      /* Set the CMOS here */

      host_ip_address[3] = ip_address_value;

      set_up_the_variables();
    }
  }

  return(0);
}

extern _kernel_oserror *cmd_handler(char *arg_string, int argc, int cmd_no, void *pw)
{
  switch (cmd_no)
  {
    case 0:
      
    break;
  }

  return 0;
}

static int check_for_keys(void)
{
  if (key_pressed(KEYPAD_1))
    return(11);
  if (key_pressed(KEYPAD_2))
    return(12);
  if (key_pressed(KEYPAD_3))
    return(13);
  if (key_pressed(KEYPAD_4))
    return(14);
  if (key_pressed(KEYPAD_5))
    return(15);
  if (key_pressed(KEYPAD_6))
    return(16);
  if (key_pressed(KEYPAD_7))
    return(17);
  if (key_pressed(KEYPAD_8))
    return(18);
  if (key_pressed(KEYPAD_9))
    return(19);

  return(0);
}

static int key_pressed(int code)
{
  _kernel_swi_regs r;

  r.r[0] = 129;
  r.r[1] = code ^ 0xff;
  r.r[2] = 0xff;
  _kernel_swi(OS_Byte, &r, &r);
  if (r.r[1] == 0xff)
    return(1);

  return(0);
}

static void set_up_the_variables(void)
{
  int loop, out;
  _kernel_swi_regs r;

  /*** Host IP ***/

  _kernel_osbyte(162, 0x6c, host_ip_address[0]);
  _kernel_osbyte(162, 0x6d, host_ip_address[1]);
  _kernel_osbyte(162, 0x6e, host_ip_address[2]);
  _kernel_osbyte(162, 0x00, host_ip_address[3]);

  /*** Sub-net mask ***/

  r.r[0] = 161;
  r.r[1] = 0x6f;
  _kernel_swi(OS_Byte, &r, &r);
  out = r.r[2];

  out = out & 0x7;                  /* Clear bits 3-7 */
  out = out | (sub_net_mask << 3);  /* Set sub-net mask into bits 3-7) */

  _kernel_osbyte(162, 0x6f, out);

  /*** Gateway IP address ***/

  _kernel_osbyte(162, 0xe0, gateway_ip_address[0]);
  _kernel_osbyte(162, 0xe1, gateway_ip_address[1]);
  _kernel_osbyte(162, 0xe2, gateway_ip_address[2]);
  _kernel_osbyte(162, 0xe3, gateway_ip_address[3]);

  /*** Boot server IP address ***/

  _kernel_osbyte(162, 0x38, boot_server_ip_address[0]);
  _kernel_osbyte(162, 0x39, boot_server_ip_address[1]);
  _kernel_osbyte(162, 0x3a, boot_server_ip_address[2]);
  _kernel_osbyte(162, 0x3b, boot_server_ip_address[3]);

  /*** Primary DNS address ***/

  _kernel_osbyte(162, 0x95, primary_dns_ip_address[0]);
  _kernel_osbyte(162, 0x96, primary_dns_ip_address[1]);
  _kernel_osbyte(162, 0x97, primary_dns_ip_address[2]);
  _kernel_osbyte(162, 0x98, primary_dns_ip_address[3]);

  /*** Boot mount path ***/

  for (loop = 0x51; loop <= 0x6a; loop++)
  {
    _kernel_osbyte(162, loop, 0);
  }

  for (loop = 0; loop < strlen(boot_mount_path); loop++)
  {
    _kernel_osbyte(162, 0x51 + loop, boot_mount_path[loop]);
  }

  /*** Static IP booting ***/

  r.r[0] = 161;
  r.r[1] = 0x6f;
  _kernel_swi(OS_Byte, &r, &r);
  out = r.r[2];

  if (static_ip_booting)
    out = out | 0x2; /* Set bit 1 to on (i.e. OR the byte with %00000010) */
  else
    out = out & 0xfd; /* Set bit 1 to off (i.e. AND the byte with %11111101) */

  _kernel_osbyte(162, 0x6f, out);

  /*** ATM PVC address ***/

  _kernel_osbyte(162, 0x2e, atm_pvc_address & 0xff);
  _kernel_osbyte(162, 0x2f, atm_pvc_address >> 8);
}
