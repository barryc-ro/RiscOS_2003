/* >c.Support

ACORN TEST SOFTWARE (c) Acorn Computers Ltd. 1997

************************* CHANGE LIST *************************************
                                                                        
Vers    Date            Name    Comment                                 
------  ---------       ---     -------------------------------------------
1.00    20 Mar 97       BAR     Initial writing

Will provides support functions
*/
#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "support.h"
#include "led.h"
#include "display.h"
#include "Msgs.h"


static results_store res_store[ NUMB_TESTS ];

/* Declare the variables available */
int tests_status = 0;
int tests_done   = 0;
int flagDebugging   = FALSE;

int get_yn_responce_forever(void)
/* Check to see if either the OK or BAD keys have been pressed. */
/* wait forever if needed. */
/* returns true or false */
{
        int rtn=CONT;
        int key;

        flush_keyboard();
        do{
                key=get();
                if (key==GOOD_KEY){
                        rtn=TRUE;
                }else{
                        if (key==BAD_KEY){
                                rtn=FALSE;
                        }else{
                                rtn=CONT;
                        }
                }
        }while (rtn==CONT);
        return rtn;
}

int get_yn_responce_timed(int delay)
/* Check to see if either the OK or BAD keys have been pressed. */
/* delay specifies how long to wait before returning */
/*  if timed out, then return CONT */
/* returns true or false */
{
        int rtn=CONT;
        int key;

        flush_keyboard();
        key=inkey(delay);
        if (key==GOOD_KEY){
                rtn=TRUE;
        }else{
                if (key==BAD_KEY){
                        rtn=FALSE;
                }else{
                        rtn=CONT;
                }
        }
        return rtn;
}

int get_key_forever(int reqd_key)
/* wait for the key specified to be pressed. */
/* wait forever if needed */
{
        int key;
        int rtn=FALSE;

        flush_keyboard();
        do{
                key=get();
        }while(key!=reqd_key);
        return rtn;
}

int get_key_abortable(int reqd_key, int abort_key)
/* wait for the key specified to be pressed. */
/* wait forever if needed - unless abort key pressed*/
{
        int key;

        flush_keyboard();
        do{
                key=get();
        }while((key!=reqd_key) && (key!=abort_key));
        return (key==reqd_key) ? TRUE : FALSE;
}

int get_key_timed(int reqd_key, int delay)
/* wait for the key specified to be pressed. */
/* dealy specifies how long to wait for. */
{
        int key;
        int rtn=FALSE;

        flush_keyboard();
        key=inkey(delay);

        if (key==reqd_key){
                rtn=TRUE;
        }else{
                rtn=FALSE;
        }
        return rtn;
}

void WaitForSpaceBar(void)
/* Wait for the space bar to be pressed.
 */
{
        WaitForOKKey();
/*         int key;
        _kernel_swi_regs regs;

        do{
                _kernel_osbyte(21,0,0);
                _kernel_swi(OS_ReadC, &regs, &regs);
                key = regs.r[0];
        }while (key != SPACE_CHR); */
}

void WaitForOKKey(void)
/* Wait for the OK button to be pressed.
 */
{
       int key;

        flush_keyboard();
        do{
                key=get();
        }while (key != CONT_KEY);
}

int inkey(int delay)
/* perform an INKEY function
   return -1 if timed out.
 */
{
        _kernel_swi_regs regs;
        long tnow, tstart = 0, tstop=0;
        int rtn_key=-1;
        int iCarry;

        /* get the start time */
        _kernel_swi (OS_ReadMonotonicTime, &regs, &regs);
        tstart = (long) regs.r[0];
        /* multiply seconds by 100 to get CSec's */
        tstop = tstart+((long)delay*100);
        do{
                /* examin the keyboard buffer */
                regs.r[0] = 145;
                regs.r[1] = 0;
                _kernel_swi_c(OS_Byte, &regs, &regs, &iCarry);
                if (iCarry == 0){
                        /* we've got something ! */
                        rtn_key=regs.r[2];
                }
                /* get the time */
                _kernel_swi (OS_ReadMonotonicTime, &regs, &regs);
                tnow = (long) regs.r[0];
        }while ((rtn_key==-1) && (tnow<=tstop));
        /* we've either timed out in which case rtn_key still =-1 */
        /* A key was prerssed, in which case rtn_key no longer =-1 */
        return rtn_key;
}

int get(void)
/* Perform a GET function
 */
{
        int rtn_key=-1;
        _kernel_swi_regs regs;
        int iCarry;

        do{
                /* examin the keyboard buffer */
                regs.r[0] = 145;
                regs.r[1] = 0;
                _kernel_swi_c(OS_Byte, &regs, &regs, &iCarry);
                if (iCarry == 0){
                        /* we've got something ! */
                        rtn_key=regs.r[2];
                }
        }while (rtn_key==-1);
        /* A key was prerssed, in which case rtn_key no longer =-1 */
        return rtn_key;
}

void flush_keyboard(void)
/* Flush the keyboard buffer
 */
{
        _kernel_osbyte(21,0,0);
}

void log_status(int test,int status)
/* Log the status of a test
   Uses global variables tests_done and tests_status
   Both variables are a bit pattern
   The bit corresponding to the tests tag number will be set in the done
   variable if the test is done. If the test has passed then the
   corresponding bit in the status variable will also be set.
 */
{
        if (status!=RUNNING){
                /* We've been called sothing other than RUNNING */
                res_store[test].done=TRUE;
                if (status > LASTSTATUS){
                        /* We've been given an error code, change to FAILED */
                        status=FAILED;
                }
                if (status==COMPLETED){
                        /* We've been given COMPLETED, change to PASSED */
                        status=PASSED;
                }
                res_store[test].result=status;
        }
        /* Ignore if called with RUNNING */
}

int check_logged_status(int failed_count, int cycle)
/* Check the done and results flags for each of the tests.
   if done
       increment the run counter for that test.
       if not passed
           increment the failed counter
           if first is zero
               enter cycle count
 */
{
        int i;
        int cycle_failed=FALSE;

        for (i=0; i<= NUMB_TESTS; i++){
                /* for each test, check that it's done flag is set. */
                if (res_store[i].done==TRUE){
                        /* we did the test */
                        res_store[i].total_runs++;
                        if (res_store[i].result!=PASSED){
                                /* It failed !!! */
                                cycle_failed=TRUE;
                                res_store[i].total_fails++;
                                if (res_store[i].first==0){
                                        /* Set first failure value */
                                        res_store[i].first=cycle;
                                }
                        }
                }
        }
        /* check cycle_failed, if true inc. failed counter */
        if (cycle_failed==TRUE){
                failed_count++;
        }
        return failed_count;
}

void clear_res_store(int cycle)
/* Clear the cycle fields in the results store
   If cycle_count==0 then clear the lot
 */
{
        int i;

        for (i=0; i<= NUMB_TESTS; i++){
                res_store[i].done=FALSE;
                res_store[i].result=FAILED;
                if (cycle<=0){
                        /* First time through .. clear the lot */
                        res_store[i].total_runs=0;
                        res_store[i].total_fails=0;
                        res_store[i].first=0;
                }
        }
}

int find_memory_size(int area)
/* Get the memory size and retun it
   area is the area to ge information on
        1 = DRAM aka DRAM_AREA
        2 = VRAM aka VRAM_AREA
        3 = ROM  aka ROM_AREA
        4 = IO   aka IO_AREA
 */
{
        int size;
        int pages;
        int page_size;
        _kernel_swi_regs reg;

        reg.r[0] = 8 | (area << 8);
        _kernel_swi(OS_Memory, &reg, &reg);
        page_size=reg.r[2];
        pages=reg.r[1];
        size=(pages*page_size)/1024/0124;
        return size;
}

int make_error_no(int c_err, int t_base, int t_numb, int f_numb)
/* Make an error number from the paramiters given. */
/* c_err is the value of the current error numnber, this will be added too. */
/* t_base is the base number to shift the test number by */
/* t_numb is the test number to identify a sub test */
/* f_numb is the fault number or code */
{
	return (t_numb!=0) ? (c_err+(t_numb < t_base)+f_numb) : c_err;
}

void display_status_led(int test_mode, int status)
/* display the status of the test(s) by setting the led
if needed flash rate id determined by test_mode */
{
        int rate;

        if (test_mode==MODE_USER){
                rate=LED_FLASH_USER;
        }else{
                rate=LED_FLASH_LIFE;
        }
        switch(status){
                case FAILED:
                        change_led_state(LED_RED,LED_ON,0);
                        change_led_state(LED_GREEN,LED_FLASH,rate);
                        break;
                case PASSED:
                        change_led_state(LED_RED,LED_FLASH,rate);
                        change_led_state(LED_GREEN,LED_ON,0);
                        break;
                case RUNNING:
                        change_led_state(LED_RED,LED_FLASH,rate);
                        change_led_state(LED_GREEN,LED_FLASH,rate);
                        break;
        }
}

void change_led_state(int led, int state, int rate)
/* Set the requied LED to the required state, and if needed start it
flashing */
{
        int old_state;

        old_state=get_led_state(led);
        if (((old_state && LED_FLASH)==LED_FLASH) && (state!=LED_FLASH)){
                /* We were flashing but we don't want to now */
                led_flash_off(led);
        }
        set_led_state(led,state);
        set_led_flash_rate(led,rate);
}

int get_led_state(int led)
/* Get the status of the led speified. */
{
        _kernel_swi_regs regs;
        regs.r[0] = 0;
        regs.r[1] = 0xFFFFFFFF;
        regs.r[2] = 0;
        _kernel_swi(LED_Control, &regs, &regs);
        return regs.r[0];
}

void set_led_state(int led, int state)
/* Set the status of the led specified */
{
        _kernel_swi_regs regs;
        regs.r[0] = led;
        if (state==LED_FLASH){
                /* set bit 1 in the regs */
                regs.r[1] = 1;
        }else{
                /* set bit o in the regs */
                regs.r[1] = 0;
        }                
        regs.r[2] = state;
        _kernel_swi(LED_Control, &regs, &regs);
}

void led_steady_off(int led)
/* Turn the required led off */
{
        _kernel_swi_regs regs;
        regs.r[0] = led;
        regs.r[1] = 0;
        regs.r[2] = 0;
        _kernel_swi(LED_Control, &regs, &regs);
}

void led_steady_on(int led)
/* Turn the required led on */
{
        _kernel_swi_regs regs;
        regs.r[0] = led;
        regs.r[1] = 0;
        regs.r[2] = 1;
        _kernel_swi(LED_Control, &regs, &regs);
}

void led_flash_off(int led)
/* Stop the led specified from flashing */
{
        _kernel_swi_regs regs;
        regs.r[0] = led;
        regs.r[1] = 1;
        regs.r[2] = 0;
        _kernel_swi(LED_Control, &regs, &regs);
}

void led_flash_on(int led)
/* Start the led specified flashing */
{
        _kernel_swi_regs regs;
        regs.r[0] = led;
        regs.r[1] = 1;
        regs.r[2] = 1;
        _kernel_swi(LED_Control, &regs, &regs);
}

void set_led_flash_rate(int led, int rate)
/* Set the LED specified's flash rate */
{
        _kernel_swi_regs regs;
        regs.r[0] = led;
        regs.r[1] = rate;
        _kernel_swi(LED_FlashRate, &regs, &regs);
}

void wait_for_cont(void)
/* Prompt the user to make us continue.
   Wait (forever) for their response.
 */
{
        display_instruction(CONT_INST_LINE,general_msg[0]);
        WaitForSpaceBar();
        clear_line(CONT_INST_LINE);
}

void wait(int seconds)
/* Wait a specified number of seconds
 */
{
        _kernel_swi_regs regs;
        long tnow, tstart = 0, tstop=0;

        _kernel_swi (OS_ReadMonotonicTime, &regs, &regs);
        tstart = (long) regs.r[0];
        /* multiply seconds by 100 to get CSec's */
        tstop = tstart+((long)seconds*100);

        do{
                _kernel_swi (OS_ReadMonotonicTime, &regs, &regs);
                tnow = (long) regs.r[0];
        }while (tnow <= tstop);
}
