/* >c.Display

ACORN TEST SOFTWARE (c) Acorn Computers Ltd. 1997

************************* CHANGE LIST *************************************
                                                                        
Vers    Date            Name    Comment                                 
------  ---------       ---     -------------------------------------------
1.00    20 Mar 97       BAR     Initial writing
1.01    01 May 97       BAR     Corrrect problem when printing out sub test
                                results, subtest_ststus_line wsa not being
                                initilied to be current test line+1
1.02    02 May 97       BAR     Change sub_test_status to show non-std.
                                status messages as 8 digit hex.
1.03    07 May 97       BAR     Change func. display_mode to call tab()
                                func. with the x/y args correct waty around.
                                Func. clear_info() now reset info_line to 1.
                                Func. display_instruction90 calls tab90
                                corrrectly. Correct display_mode in
                                calculating the padwidth. in func.
                                display_status show error codes as 8 digit
                                hex numbers.
1.04    08 May 97       BAR     Add & and leading 0 to last hex print out
                                fix.
1.05    08 May 97       BAR     Use correct string when displaying cycle counter.
                                display_info now uses all of its lines.
                                Add two new functions, display_info_clear
                                and display_info_noclear. former was
                                display_info but now has flag to indicate if
                                auto clear of info is needed. Latter calls
                                display_info_clear but don't clear info area
                                if full. display_info now calls
                                display_info_clear and asks to clear the
                                info if full. Resolve the problem of over
                                printing passed on running - not same
                                length.

Will provides display functions
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "display.h"
#include "msgs.h"
#include "support.h"


/* Declare the variables available */
int test_status_line     = 1;
int subtest_status_line  = 0;
int info_line            = INFO_START;
int instruct_line        = 0;

void inc_test_line(void)
/* Increments the test line in use
   Updates a global variable test_status_line 
 */
{
        test_status_line++;
}

void display_status(int test, int state)
/* Displays the status of the current test.
   test is used to reference the correct test name.
   Uses a global variable test_status_line 
     to specify which line is in current use.
   Update the line pointer when status !RUNNING
     IF subtest !0 then add that in and reset to 0
   The test_names are already pre packed to the same length
 */
{
        char str[80];
        int mode_matched=FALSE;
        int prefix;
        int runs=0;
        int fails=0;
        int first=0;

        /* check output line counter, if less than start, set to start */
        if (test_status_line < OUTPUT_START){
                test_status_line = OUTPUT_START;
        }

        tab(0,test_status_line);

        if (state <= LASTSTATUS){
                /* know sensible state */
                sprintf(str,"%s%s%s",test_names[test],test_status[state],general_msg[4]);
        }else{
                /* unkown error state AKA its the fault code */
                sprintf(str,"%s%s  (&%08X)",test_names[test],test_status[FAILED],state);
        }
        mode_matched=check_test_mode(MODE_LIFE);
        if (mode_matched==TRUE){
                /* In life mode */
                prefix=check_prefix_type(test);
                runs=get_logged_data(test,LOG_RUNS);
                fails=get_logged_data(test,LOG_FAILS);
                first=get_logged_data(test,LOG_FIRST);

                switch (prefix){
                        case RUN_PASS:
                                sprintf(str,"%s [R:%08d-P:%08d]",str,runs,(runs-fails));
                                break;
                        case COMP_PASS:
                                /* don't do anything extra */
                                break;
                        case FAIL_FIRST:
                                sprintf(str,"%s [F:%08d-T:%08d]",str,first,fails);
                                break;
                }
        }
        printf(str);
        if (state!=RUNNING){
                /* update test_status_line value */
                if (subtest_status_line!=0){
                        /* sub test has been used */
                        test_status_line=test_status_line+subtest_status_line+1;
                        subtest_status_line=0;
                }else{
                        test_status_line++;
                }
        }
}

void display_sub_test(int sub_test, char *data)
/* Displays the result of a sub-test, usually useful info.
   subtest specifies the sub test within a test.
   Uses a global variable subtest_status_line 
     to specify which line is in current use.
     Added to the current value of test_status_line
   Updates the line pointer brefore use.
   Uses max_test_name_len to provide 'x' offset.
 */
{
        subtest_status_line++;
        /* Ensure sub test info printed on correct line by adding
           test_status_line to each tab call.
         */
        tab(MAX_TEST_NAME_LEN,(subtest_status_line+test_status_line));
        printf("%s%s",sub_test_names[sub_test],data);
}

void display_sub_test_status(int sub_test, int state)
/* Displays the status of the current sub_test.
   sub_test is used to reference the correct sub_test name.
   state is checked, if greater than LASTSTATUS then its an error code,
     change to string and pass to subtest display func., otherwise pick
     correct status name from list and pass on.
 */
{
        char str[80];

        if (state <= LASTSTATUS){
                /* know sensible state */
                display_sub_test(sub_test,test_status[state]);
        }else{
                /* unkown error state AKA its the fault code */
                sprintf(str,"&%08X",state);
                display_sub_test(sub_test,str);
        }
}

void dec_info_line(void)
/* Increments the test line in use
   Updates a global variable test_status_line 
 */
{
        info_line--;
}

void display_info(char *msg)
/* displays some information in the information area.
   calls display_info_clear with auto clear flag set to TRUE
 */
{
        display_info_clear(msg,TRUE);
}

void display_info_noclear(char *msg)
/* displays some information in the information area.
   calls display_info_clear with auto clear flag set to FALSE
 */
{
        display_info_clear(msg,FALSE);
}

void display_info_clear(char *msg, int auto_clear)
/* Displays some information in the information area.
   Uses a global variable info_line
     display message
     inc info_line
     If auto_clear true and info_line line exceeds INFO_STOP, then
        tell user to press space bar
        wait for space
        clear info area (inc. reset info_line to INFO_START)
 */
{
        tab(0,info_line);
        printf("%s",msg);
        info_line++;
        if ((auto_clear==TRUE) && (info_line>INFO_STOP)){
                display_instruction(CONT_INST_LINE,general_msg[0]);
                WaitForSpaceBar();
                clear_line(CONT_INST_LINE);
                clear_info();
        }
}

void clear_whole_screen(void)
/* clears the whole screen
 */
{
        _kernel_oswrch(12);
/*         int i;
        for (i=SCRN_START; i<=SCRN_STOP; i++){
                clear_line(i);
        } */
}

void clear_output(void)
/* clears the output area
 */
{
        int i;
        for (i=OUTPUT_START; i<=OUTPUT_STOP; i++){
                clear_line(i);
        }
}

void clear_info(void)
/* Clears the information area.
   Resets the global variable info_line.
 */
{
        int i;
        for (i=INFO_START; i<=INFO_STOP; i++){
                clear_line(i);
        }
        info_line=INFO_START;
}

void clear_line(int vtab)
/* Clear a line of text */
{
        tab(0,vtab);
        printf("%*s",SCRN_WIDTH,"");
}

void tab(int x, int y)
/* Tab to a particular line & column */
{ 
        _kernel_oswrch(31);
        _kernel_oswrch(x);
        _kernel_oswrch(y);
} 

void display_mode(int mode)
/* Displays the current mode of operation
   Always displayed on line 1.
   Displays the information in the middle of the screen
 */
{
        tab(cal_padding(test_modes[mode]),TEST_MODE_LINE);
        printf("%s",test_modes[mode]);
}

void display_cycle_count(int cycle, int fails)
/* Displays the current cycle count
   Always displayed on line 3.
 */
{
        tab(0,CYCLE_COUNT_LINE);
        printf("%s %d [%d]",test_modes[2],cycle,fails);
}

void display_instruction(int inst_line, char *msg)
/* Displays an instruction on the line specified.
   Centers the instruction.
 */
{
        tab(cal_padding(msg),inst_line);
        printf("%s",msg);
}

int cal_padding(char *msg)
/* Calculate the ammount of padding needed to center some text
 */
{
        int  padwidth;
        padwidth=(SCRN_WIDTH-strlen(msg))/2;
        return padwidth;
}
