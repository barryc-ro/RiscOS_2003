/* >c.Display

ACORN TEST SOFTWARE (c) Acorn Computers Ltd. 1997

************************* CHANGE LIST *************************************
                                                                        
Vers    Date            Name    Comment                                 
------  ---------       ---     -------------------------------------------
1.00    20 Mar 97       BAR     Initial writing

Will provides display functions
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

#include "display.h"
#include "msgs.h"
#include "support.h"


/* Declare the variables available */
int test_status_line     = 1;
int subtest_status_line  = 0;
int info_line            = 1;
int instruct_line        = 0;


void inc_test_line(void)
/* Increments the test line in use
   Updates a global variable test_status_line 
 */
{
        test_status_line++;
}

void display_status(int test, int state)
/* Displays the status of the current test.
   test is used to reference the correct test name.
   Uses a global variable test_status_line 
     to specify which line is in current use.
   Update the line pointer when status !RUNNING
     IF subtest !0 then add that in and reset to 0
   The test_names are already pre packed to the same length
 */
{
        /* check output line counter, if less than start, set to start */
        if (test_status_line < OUTPUT_START){
                test_status_line = OUTPUT_START;
        }
        
        tab(0,test_status_line);
        if (state <= LASTSTATUS){
                /* know sensible state */
                printf("%s%s",test_names[test],test_status[state]);
        }else{
                /* unkown error state AKA its the fault code */
                printf("%s%s (%x)",test_names[test],test_status[FAILED],state);
        }
        if (state!=RUNNING){
                /* update test_status_line value */
                if (subtest_status_line!=0){
                        /* sub test has been used */
                        test_status_line=test_status_line+subtest_status_line+1;
                        subtest_status_line=0;
                }else{
                        test_status_line++;
                }
        }
}

void display_sub_test(int sub_test, char *data)
/* Displays the result of a sub-test, usually useful info.
   subtest specifies the sub test within a test.
   Uses a global variable subtest_status_line 
     to specify which line is in current use.
     Added to the current value of test_status_line
   Updates the line pointer brefore use.
   Uses max_test_name_len to provide 'x' offset.
 */
{
        subtest_status_line++;
        tab(MAX_TEST_NAME_LEN,subtest_status_line);
        printf("%s%s",sub_test_names[sub_test],data);
}

void display_sub_test_status(int sub_test, int state)
/* Displays the status of the current sub_test.
   sub_test is used to reference the correct sub_test name.
   state is checked, if greater than LASTSTATUS then its an error code,
     change to string and pass to subtest display func., otherwise pick
     correct status name from list and pass on.
 */
{
        char str[80];

        if (state <= LASTSTATUS){
                /* know sensible state */
                display_sub_test(sub_test,test_status[state]);
        }else{
                /* unkown error state AKA its the fault code */
                sprintf(str,"%d",state);
                display_sub_test(sub_test,str);
        }
}

void dec_info_line(void)
/* Increments the test line in use
   Updates a global variable test_status_line 
 */
{
        info_line--;
}

void display_info(char *msg)
/* Displays some information in the information area.
   Uses a global variable info_line 
     to specify which line is in current use.
     Added to INFO_START.
     IF current line exceeds INFO_STOP, then
        tell user to press space bar
        wait for space
        clear info area
        reset info_line to 0.
 */
{
        int space_line;
        int padwidth;
        int current;

        current=INFO_START+info_line;
        tab(0,current);
        printf("%s",msg);
        info_line++;
        if (current>=INFO_STOP){
                padwidth=(SCRN_WIDTH-strlen(general_msg[0]))/2;
                space_line=current+1;
                tab(space_line,padwidth);
                printf("%s",general_msg[0]);
                WaitForSpaceBar();
                clear_line(space_line);
                clear_info();
                info_line=0;
        }
}

void clear_whole_screen(void)
/* clears the whole screen
 */
{
        _kernel_oswrch(12);
/*         int i;
        for (i=SCRN_START; i<=SCRN_STOP; i++){
                clear_line(i);
        } */
}

void clear_output(void)
/* clears the output area
 */
{
        int i;
        for (i=OUTPUT_START; i<=OUTPUT_STOP; i++){
                clear_line(i);
        }
}

void clear_info(void)
/* Clears the information area.
 */
{
        int i;
        for (i=INFO_START; i<=INFO_STOP; i++){
                clear_line(i);
        }
}

void clear_line(int vtab)
/* Clear a line of text */
{
        tab(0,vtab);
        printf("%*s",SCRN_WIDTH,"");
}

void tab(int x, int y)
/* Tab to a particular line & column */
{ 
        _kernel_oswrch(31);
        _kernel_oswrch(x);
        _kernel_oswrch(y);
} 

void display_mode(int mode)
/* Displays the current mode of operation
   Always displayed on line 1.
   Displays the information in the middle of the screen
 */
{
        int  padwidth;

        padwidth=SCRN_WIDTH-(strlen(test_modes[mode]))/2;
        tab(1,padwidth);
        printf("%s",test_modes[mode]);
}

void display_cycle_count(int cycle, int fails)
/* Displays the current cycle count
   Always displayed on line 3.
 */
{
        tab(0,3);
        printf("%s %d (%d)",test_modes[3],cycle,fails);
}

void display_instruction(int inst_line, char *msg)
/* Displays an instruction on the line specified.
   Centers the instruction.
 */
{
        int padwidth;
        padwidth=(SCRN_WIDTH-strlen(msg))/2;
        tab(inst_line,padwidth);
        printf("%s",msg);
}
