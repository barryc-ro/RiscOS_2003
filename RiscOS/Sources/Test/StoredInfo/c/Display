/* >c.Display

ACORN TEST SOFTWARE (c) Acorn Computers Ltd. 1997

************************* CHANGE LIST *************************************
                                                                        
Vers    Date            Name    Comment                                 
------  ---------       ---     -------------------------------------------
1.00    20 Mar 97       BAR     Initial writing
1.01    01 May 97       BAR     Corrrect problem when printing out sub test
                                results, subtest_ststus_line wsa not being
                                initilied to be current test line+1
1.02    02 May 97       BAR     Change sub_test_status to show non-std.
                                status messages as 8 digit hex.
1.03    07 May 97       BAR     Change func. display_mode to call tab()
                                func. with the x/y args correct waty around.
                                Func. clear_info() now reset info_line to 1.
                                Func. display_instruction90 calls tab90
                                corrrectly. Correct display_mode in
                                calculating the padwidth. in func.
                                display_status show error codes as 8 digit
                                hex numbers.

Will provides display functions
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

#include "display.h"
#include "msgs.h"
#include "support.h"


/* Declare the variables available */
int test_status_line     = 1;
int subtest_status_line  = 0;
int info_line            = 1;
int instruct_line        = 0;


void inc_test_line(void)
/* Increments the test line in use
   Updates a global variable test_status_line 
 */
{
        test_status_line++;
}

void display_status(int test, int state)
/* Displays the status of the current test.
   test is used to reference the correct test name.
   Uses a global variable test_status_line 
     to specify which line is in current use.
   Update the line pointer when status !RUNNING
     IF subtest !0 then add that in and reset to 0
   The test_names are already pre packed to the same length
 */
{
        /* check output line counter, if less than start, set to start */
        if (test_status_line < OUTPUT_START){
                test_status_line = OUTPUT_START;
        }
        
        tab(0,test_status_line);
        if (state <= LASTSTATUS){
                /* know sensible state */
                printf("%s%s",test_names[test],test_status[state]);
        }else{
                /* unkown error state AKA its the fault code */
                printf("%s%s (%8X)",test_names[test],test_status[FAILED],state);
        }
        if (state!=RUNNING){
                /* update test_status_line value */
                if (subtest_status_line!=0){
                        /* sub test has been used */
                        test_status_line=test_status_line+subtest_status_line+1;
                        subtest_status_line=0;
                }else{
                        test_status_line++;
                }
        }
}

void display_sub_test(int sub_test, char *data)
/* Displays the result of a sub-test, usually useful info.
   subtest specifies the sub test within a test.
   Uses a global variable subtest_status_line 
     to specify which line is in current use.
     Added to the current value of test_status_line
   Updates the line pointer brefore use.
   Uses max_test_name_len to provide 'x' offset.
 */
{
        subtest_status_line++;
        /* Ensure sub test info printed on correct line by adding
           test_status_line to each tab call.
         */
        tab(MAX_TEST_NAME_LEN,(subtest_status_line+test_status_line));
        printf("%s%s",sub_test_names[sub_test],data);
}

void display_sub_test_status(int sub_test, int state)
/* Displays the status of the current sub_test.
   sub_test is used to reference the correct sub_test name.
   state is checked, if greater than LASTSTATUS then its an error code,
     change to string and pass to subtest display func., otherwise pick
     correct status name from list and pass on.
 */
{
        char str[80];

        if (state <= LASTSTATUS){
                /* know sensible state */
                display_sub_test(sub_test,test_status[state]);
        }else{
                /* unkown error state AKA its the fault code */
                sprintf(str,"&%08X",state);
                display_sub_test(sub_test,str);
        }
}

void dec_info_line(void)
/* Increments the test line in use
   Updates a global variable test_status_line 
 */
{
        info_line--;
}

void display_info(char *msg)
/* Displays some information in the information area.
   Uses a global variable info_line 
     to specify which line is in current use.
     Added to INFO_START.
     IF current line exceeds INFO_STOP, then
        tell user to press space bar
        wait for space
        clear info area (inc. reset info_line to 1.)
 */
{
        int space_line;
        int padwidth;
        int current;

        current=INFO_START+info_line;
        tab(0,current);
        printf("%s",msg);
        info_line++;
        if (current>=INFO_STOP){
                padwidth=(SCRN_WIDTH-strlen(general_msg[0]))/2;
                space_line=current+1;
                tab(padwidth,space_line);
                printf("%s",general_msg[0]);
                WaitForSpaceBar();
                clear_line(space_line);
                clear_info();
        }
}

void clear_whole_screen(void)
/* clears the whole screen
 */
{
        _kernel_oswrch(12);
/*         int i;
        for (i=SCRN_START; i<=SCRN_STOP; i++){
                clear_line(i);
        } */
}

void clear_output(void)
/* clears the output area
 */
{
        int i;
        for (i=OUTPUT_START; i<=OUTPUT_STOP; i++){
                clear_line(i);
        }
}

void clear_info(void)
/* Clears the information area.
   Resets the global variable info_line.
 */
{
        int i;
        for (i=INFO_START; i<=INFO_STOP; i++){
                clear_line(i);
        }
        info_line=1;
}

void clear_line(int vtab)
/* Clear a line of text */
{
        tab(0,vtab);
        printf("%*s",SCRN_WIDTH,"");
}

void tab(int x, int y)
/* Tab to a particular line & column */
{ 
        _kernel_oswrch(31);
        _kernel_oswrch(x);
        _kernel_oswrch(y);
} 

void display_mode(int mode)
/* Displays the current mode of operation
   Always displayed on line 1.
   Displays the information in the middle of the screen
 */
{
        int  padwidth;

        padwidth=(SCRN_WIDTH-strlen(test_modes[mode]))/2;
        tab(padwidth,1);
        printf("%s",test_modes[mode]);
}

void display_cycle_count(int cycle, int fails)
/* Displays the current cycle count
   Always displayed on line 3.
 */
{
        tab(0,3);
        printf("%s %d (%d)",test_modes[3],cycle,fails);
}

void display_instruction(int inst_line, char *msg)
/* Displays an instruction on the line specified.
   Centers the instruction.
 */
{
        int padwidth;
        padwidth=(SCRN_WIDTH-strlen(msg))/2;
        tab(padwidth,inst_line);
        printf("%s",msg);
}
