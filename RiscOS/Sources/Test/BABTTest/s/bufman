	GET	h.CVars
	GET	h.SWINames


	ASSERT	r12 = ip	; Just in case APCS changes (code routinely corrupts r12)...


	AREA	|C$$code|, CODE, READONLY


; All the buffermanager_* routines can be called from any (non-FIQ) processor mode
; (including USR mode; the inefficiency when called from SVC or IRQ mode is small).
; All but buffermanager_get_internalID are re-entrant and do not enable interrupts
; (so can be called from interrupt routines).


	EXPORTVar	buffermanager_service_routine
	EXPORTVar	buffermanager_service_pw


; uint buffermanager_get_internalID (const uint b);
;
; Returns internal buffer ID for buffer whose handle is b.
;
; Also initialises buffermanager_service_routine and buffermanager_service_pw.
; Indeed, it can be called with any old b and this will still work (PRM5a-226).

	EXPORT	buffermanager_get_internalID
buffermanager_get_internalID

	STMFD	sp!, {lr}
	SWI	XBuffer_InternalInfo
	MOVVS	a1, #0					; Return zero for error
	StaticBaseFromSL	r3
	STRVar	r1, r3, buffermanager_service_routine, lr
	STRVar	r2, r3, buffermanager_service_pw, lr
	LDMFD	sp!, {pc}^


; int buffermanager_put_byte (const uint b, const byte c);
;
; Inserts byte c into internal buffer ID b.
;
; Returns 0 if inserted OK, 1 otherwise

	EXPORT  buffermanager_put_byte
buffermanager_put_byte

	MOV	ip, lr		; Preserve caller lr in ip
	MOVS	lr, pc, LSR#2	; Test whether SVC or IRQ mode
	SWICC	XOS_EnterOS	; Enter SVC mode if not (assuming not FIQ mode!)
	STMFD	sp!, {ip}	; Preserve caller lr (held in ip) on stack
	MOV	r2, a2		; Do this first so that a2 (r1) is not squashed
	MOV	r1, a1		; Then do this so that a1 (r0) is not squashed
	StaticBaseFromSL	r0
	LDRVar	r12, r0, buffermanager_service_pw
	LDRVar	r3, r0, buffermanager_service_routine
	MOV	r0, #0		; "Insert byte" reason code
	MOV	lr, pc		; Returns two instructions from here
	MOV	pc, r3		; Jump to service routine
	ADC	a1, r0, r0	; Sneaky, huh?  (r0 is 0)
	LDMFD	sp!, {pc}^	; Return using caller lr (restores PSR)


; int buffermanager_put_block (const uint b, const byte *const s, const int n);
;
; Inserts n bytes from string s into internal buffer ID b.
;
; Returns 0 if inserted OK, otherwise the number of bytes not inserted.

	EXPORT  buffermanager_put_block
buffermanager_put_block

	MOV	ip, lr		; Preserve caller lr in ip
	MOVS	lr, pc, LSR#2	; Test whether SVC or IRQ mode
	SWICC	XOS_EnterOS	; Enter SVC mode if not (assuming not FIQ mode!)
	STMFD	sp!, {v1, ip}	; Preserve v1 (r4) and caller lr (held in ip) on stack
	MOV	r3, a3		; Do this first so that a3 (r2) is not squashed
	MOV	r2, a2		; Then do this so that a2 (r1) is not squashed
	MOV	r1, a1		; Then do this so that a1 (r0) is not squashed
	StaticBaseFromSL	r0
	LDRVar	r12, r0, buffermanager_service_pw
	LDRVar	r4, r0, buffermanager_service_routine
	MOV	r0, #1		; "Insert block" reason code
	MOV	lr, pc		; Returns two instructions from here
	MOV	pc, r4		; Jump to service routine
	MOV	a1, r3		; Number of bytes not inserted
	LDMFD	sp!, {v1, pc}^	; Return using caller lr (restores PSR)


; int buffermanager_put_DLEdblock (const uint b, const byte *const s, const int n);
;
; Inserts n bytes from string s into internal buffer ID b, with <DLE> escaping, and
; then inserts a <DLE><ETX> terminator.  n can be 0 to just insert the terminator.
;
; Returns 0 if inserted OK, 1 otherwise.

	EXPORT  buffermanager_put_DLEdblock
buffermanager_put_DLEdblock

	MOV	ip, lr		; Preserve caller lr in ip
	MOVS	lr, pc, LSR#2	; Test whether SVC or IRQ mode
	SWICC	XOS_EnterOS	; Enter SVC mode if not (assuming not FIQ mode!)
	STMFD	sp!, {v1, v2, ip}	; Preserve v1 (r4), v2 (r5) and caller lr (held in ip) on stack
	MOV	r3, a3		; Do this first so that a3 (r2) is not squashed
	MOV	r5, a2		; Then do this so that a2 (r1) is not squashed
	MOV	r1, a1		; Then do this so that a1 (r0) is not squashed
	StaticBaseFromSL	r0
	LDRVar	r12, r0, buffermanager_service_pw
	LDRVar	r4, r0, buffermanager_service_routine
	MOV	r0, #0		; "Insert byte" reason code
				; Here r0-r1 for insert, r3 for n, r4 for service routine, r5 for string
	CMP	r3, #0		; Just put in string terminator if zero length
	BEQ	buffermanager_put_DLEdblock_terminate
buffermanager_put_DLEdblock_more
	LDRB	r2, [r5], #1
	MOV	lr, pc		; Returns two instructions from here
	MOV	pc, r4		; Jump to service routine
	BCS	buffermanager_put_DLEdblock_failed
	CMP	r2, #0x10	; If <DLE> then repeat
	CMPNE   r2, #0x100      ; Clear C flag and Z flag if not (r2 always < 0x100)
	MOVEQ	lr, pc		; Returns two instructions from here
	MOVEQ	pc, r4		; Jump to service routine
	BCS	buffermanager_put_DLEdblock_failed
	SUBS	r3, r3, #1
	BNE	buffermanager_put_DLEdblock_more
buffermanager_put_DLEdblock_terminate
	MOV	r2, #0x10	; Insert <DLE>
	MOV	lr, pc
	MOV	pc, r4
	BCS	buffermanager_put_DLEdblock_failed
	MOV	r2, #0x03	; Insert <ETX>
	MOV	lr, pc
	MOV	pc, r4
	BCS	buffermanager_put_DLEdblock_failed
	MOV	a1, #0		; OK
	LDMFD	sp!, {v1, v2, pc}^	; Return using caller lr (restores PSR)
buffermanager_put_DLEdblock_failed
	MOV	a1, #1		; Not OK
	LDMFD	sp!, {v1, v2, pc}^	; Return using caller lr (restores PSR)


; int buffermanager_get_byte (const uint b);
;
; Returns byte removed from internal buffer ID b, or -1 if none.

	EXPORT  buffermanager_get_byte
buffermanager_get_byte

	MOV     r3, lr		; Preserve caller lr in r3 across call
	MOVS	ip, pc, LSR#2	; Test whether SVC or IRQ mode
	SWICC	XOS_EnterOS	; Enter SVC mode if not (assuming not FIQ mode!)
	MOV	r1, a1		; Do this first so that a1 (r0) is not squashed
	StaticBaseFromSL	r0
	LDRVar	r12, r0, buffermanager_service_pw
	LDRVar	r2, r0, buffermanager_service_routine
	MOV	r0, #2		; "Remove byte" reason code
	MOV	lr, pc		; Returns two instructions from here
	MOV	pc, r2		; Jump to service routine
	MOV	a1, r2		; Byte removed
	MVNCS	a1, #0		; Return -1 if unable to remove byte
	MOVS	pc, r3		; Return using caller lr (restores PSR)


; int buffermanager_get_nused (const uint b);
;
; Returns number of bytes in internal buffer ID b.

	EXPORT  buffermanager_get_nused
buffermanager_get_nused

	MOV     r3, lr		; Preserve caller lr in r3 across call
	MOVS	ip, pc, LSR#2	; Test whether SVC or IRQ mode
	SWICC	XOS_EnterOS	; Enter SVC mode if not (assuming not FIQ mode!)
	MOV	r1, a1		; Do this first so that a1 (r0) is not squashed
	StaticBaseFromSL	r0
	LDRVar	r12, r0, buffermanager_service_pw
	LDRVar	r2, r0, buffermanager_service_routine
	MOV	r0, #6		; "Return used space" reason code
	MOV	lr, pc		; Returns two instructions from here
	MOV	pc, r2		; Jump to service routine
	MOV	a1, r2		; Used space
	MOVS	pc, r3		; Return using caller lr (restores PSR)


; int buffermanager_get_nfree (const uint b);
;
; Returns number of free bytes in internal buffer ID b.

	EXPORT  buffermanager_get_nfree
buffermanager_get_nfree

	MOV     r3, lr		; Preserve caller lr in r3 across call
	MOVS	ip, pc, LSR#2	; Test whether SVC or IRQ mode
	SWICC	XOS_EnterOS	; Enter SVC mode if not (assuming not FIQ mode!)
	MOV	r1, a1		; Do this first so that a1 (r0) is not squashed
	StaticBaseFromSL	r0
	LDRVar	r12, r0, buffermanager_service_pw
	LDRVar	r2, r0, buffermanager_service_routine
	MOV	r0, #7		; "Return free space" reason code
	MOV	lr, pc		; Returns two instructions from here
	MOV	pc, r2		; Jump to service routine
	MOV	a1, r2		; Free space
	MOVS	pc, r3		; Return using caller lr (restores PSR)


; void buffermanager_purge (const uint b);
;
; Purges internal buffer ID b.  Returns nothing.

	EXPORT  buffermanager_purge
buffermanager_purge

	MOV     r3, lr		; Preserve caller lr in r3 across call
	MOVS	ip, pc, LSR#2	; Test whether SVC or IRQ mode
	SWICC	XOS_EnterOS	; Enter SVC mode if not (assuming not FIQ mode!)
	MOV	r1, a1		; Do this first so that a1 (r0) is not squashed
	StaticBaseFromSL	r0
	LDRVar	r12, r0, buffermanager_service_pw
	LDRVar	r2, r0, buffermanager_service_routine
	MOV	r0, #8		; "Purge buffer" reason code
	MOV	lr, pc		; Returns two instructions from here
	MOV	pc, r2		; Jump to service routine
	MOVS	pc, r3		; Return using caller lr (restores PSR)


	AREA	|C$$data|, DATA

buffermanager_service_routine	DCD	0
buffermanager_service_pw	DCD	0


	END
