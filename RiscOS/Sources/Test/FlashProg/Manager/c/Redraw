/***************************************************/
/* File   : Redraw.c                               */
/*                                                 */
/* Purpose: Displaying information. The geometry   */
/*          of the display, scrolling of items and */
/*          so-on is all controlled here. Other    */
/*          source files deal with colours or what */
/*          entries are to be displayed; this      */
/*          controls where.                        */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 11-Jan-1999: Created.                  */
/***************************************************/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "kernel.h"
#include "swis.h"

#include "ASCIIdraw.h"
#include "Colours.h"
#include "FromROSLib.h"
#include "Global.h"
#include "Repository.h"
#include "State.h"
#include "svcprint.h"
#include "Utils.h"

#include "Redraw.h"

/* Local definitions. ItemsPerPage is derived from the  */
/* height of the repository drawable areas (these       */
/* describe a bounding box with *inclusive* coords, so  */
/* you've 'n' items of 3 chars high plus 1 character    */
/* gap between each; therefore, items per page is area  */
/* height plus one divided by four in practice).        */

#define Redraw_Left                            0
#define Redraw_Top                             0
#define Redraw_Right                           79
#define Redraw_Bottom                          59

#define Redraw_Title_RepositoryTopLeftX        1
#define Redraw_Title_RepositoryTopLeftY        1
#define Redraw_Title_RepositoryWidth           38
#define Redraw_Title_RepositoryHeight          5
#define Redraw_Title_ZipTopLeftX               41
#define Redraw_Title_ZipTopLeftY               1
#define Redraw_Title_ZipWidth                  38
#define Redraw_Title_ZipHeight                 5

#define Redraw_ItemHeight                      3
#define Redraw_TotalItemHeight                 4
#define Redraw_ItemsPerPage                    9

/* For the lists, we define both an inclusive rectangle */
/* for the outline box and an inclusive rectangle for   */
/* the actual drawable area, which means we can abut    */
/* this against the box or give a border should we wish */
/* just by altering these definitions.                  */

#define Redraw_OutlineArea_ZipTopLeftX         41
#define Redraw_OutlineArea_ZipTopLeftY         7
#define Redraw_OutlineArea_ZipWidth            38
#define Redraw_OutlineArea_ZipHeight           39
#define Redraw_OutlineArea_RepositoryTopLeftX  1
#define Redraw_OutlineArea_RepositoryTopLeftY  7
#define Redraw_OutlineArea_RepositoryWidth     38
#define Redraw_OutlineArea_RepositoryHeight    39

#define Redraw_DrawableArea_RepositoryTopLeftX 3
#define Redraw_DrawableArea_RepositoryTopLeftY 9
#define Redraw_DrawableArea_RepositoryWidth    34
#define Redraw_DrawableArea_RepositoryHeight   35
#define Redraw_DrawableArea_ZipTopLeftX        43
#define Redraw_DrawableArea_ZipTopLeftY        9
#define Redraw_DrawableArea_ZipWidth           34
#define Redraw_DrawableArea_ZipHeight          35

#define Redraw_ImageCount_RepositoryX          1
#define Redraw_ImageCount_RepositoryY          46
#define Redraw_ImageCount_RepositoryMaxLength  38
#define Redraw_ImageCount_ZipX                 41
#define Redraw_ImageCount_ZipY                 46
#define Redraw_ImageCount_ZipMaxLength         38

/* Unlike the lists, the command area is only specified */
/* by an outline box; the format of the interior is     */
/* fixed.                                               */

#define Redraw_CommandArea_TopLeftX            1
#define Redraw_CommandArea_TopLeftY            48
#define Redraw_CommandArea_Width               78
#define Redraw_CommandArea_Height              11

/* Static function prototypes */

static _kernel_oserror * redraw_draw_single_count (int maxlen, int c, int i);

/*************************************************/
/* redraw_move_up()                              */
/*                                               */
/* Because only the redraw engine knows the      */
/* real display geometry, only it is qualified   */
/* to move a selected item around.               */
/*                                               */
/* This function moves the highlight up one      */
/* item, flipping the display by a page if       */
/* required.                                     */
/*                                               */
/* Parameters: Pointer to a pointer to the       */
/*             currently selected item; contents */
/*             will be updated with the new      */
/*             item pointer.                     */
/*************************************************/

_kernel_oserror * redraw_move_up(repository_entry ** selected)
{
  if (!selected || !*selected) return NULL;

  if ((*selected)->next)
  {
    *selected = (*selected)->next;
    state_set_list_selected(*selected);

    return redraw_move_highlight((*selected)->prev, *selected);
  }

  return NULL;
}

/*************************************************/
/* redraw_move_down()                            */
/*                                               */
/* Because only the redraw engine knows the      */
/* real display geometry, only it is qualified   */
/* to move a selected item around.               */
/*                                               */
/* This function moves the highlight down one    */
/* item, flipping the display by a page if       */
/* required.                                     */
/*                                               */
/* Parameters: Pointer to a pointer to the       */
/*             currently selected item; contents */
/*             will be updated with the new      */
/*             item pointer.                     */
/*************************************************/

_kernel_oserror * redraw_move_down(repository_entry ** selected)
{
  if (!selected || !*selected) return NULL;

  if ((*selected)->prev)
  {
    *selected = (*selected)->prev;
    state_set_list_selected(*selected);

    return redraw_move_highlight((*selected)->next, *selected);
  }

  return NULL;
}

/*************************************************/
/* redraw_page_up()                              */
/*                                               */
/* Because only the redraw engine knows the      */
/* real display geometry, only it is qualified   */
/* to move a selected item around.               */
/*                                               */
/* This function moves the highlight up one      */
/* page.                                         */
/*                                               */
/* Parameters: Pointer to a pointer to the       */
/*             currently selected item; contents */
/*             will be updated with the new      */
/*             item pointer.                     */
/*************************************************/

_kernel_oserror * redraw_page_up(repository_entry ** selected)
{
  repository_entry * new;
  unsigned int       count;

  if (!selected || !*selected) return NULL;

  new = *selected;

  for (
        count = 0;
        count < Redraw_ItemsPerPage;
        count ++
      )
  {
    if (new->next) new = new->next;
    else break;
  }

  if (*selected != new)
  {
    _kernel_oserror * e = redraw_move_highlight(*selected, new);
    *selected = new;
    state_set_list_selected(new);

    if (e) return e;
  }

  return NULL;
}

/*************************************************/
/* redraw_page_down()                            */
/*                                               */
/* Because only the redraw engine knows the      */
/* real display geometry, only it is qualified   */
/* to move a selected item around.               */
/*                                               */
/* This function moves the highlight down one    */
/* page.                                         */
/*                                               */
/* Parameters: Pointer to a pointer to the       */
/*             currently selected item; contents */
/*             will be updated with the new      */
/*             item pointer.                     */
/*************************************************/

_kernel_oserror * redraw_page_down(repository_entry ** selected)
{
  repository_entry * new;
  unsigned int       count;

  if (!selected || !*selected) return NULL;

  new = *selected;

  for (
        count = 0;
        count < Redraw_ItemsPerPage;
        count ++
      )
  {
    if (new->prev) new = new->prev;
    else break;
  }

  if (*selected != new)
  {
    _kernel_oserror * e = redraw_move_highlight(*selected, new);
    *selected = new;
    state_set_list_selected(new);

    if (e) return e;
  }

  return NULL;
}

/*************************************************/
/* redraw_jump_to_home()                         */
/*                                               */
/* Because only the redraw engine knows the      */
/* real display geometry, only it is qualified   */
/* to move a selected item around.               */
/*                                               */
/* This function moves the highlight to the      */
/* first item the list.                          */
/*                                               */
/* Parameters: Pointer to a pointer to the       */
/*             currently selected item; contents */
/*             will be updated with the new      */
/*             item pointer.                     */
/*************************************************/

_kernel_oserror * redraw_jump_to_home(repository_entry ** selected)
{
  repository_entry * new;

  if (!selected || !*selected) return NULL;

  new = *selected;

  while (new->next) new = new->next;

  if (*selected != new)
  {
    _kernel_oserror * e = redraw_move_highlight(*selected, new);
    *selected = new;
    state_set_list_selected(new);

    if (e) return e;
  }

  return NULL;
}

/*************************************************/
/* redraw_jump_to_end()                          */
/*                                               */
/* Because only the redraw engine knows the      */
/* real display geometry, only it is qualified   */
/* to move a selected item around.               */
/*                                               */
/* This function moves the highlight to the      */
/* last item the list.                           */
/*                                               */
/* Parameters: Pointer to a pointer to the       */
/*             currently selected item; contents */
/*             will be updated with the new      */
/*             item pointer.                     */
/*************************************************/

_kernel_oserror * redraw_jump_to_end(repository_entry ** selected)
{
  repository_entry * new;

  if (!selected || !*selected) return NULL;

  new = *selected;

  while (new->prev) new = new->prev;

  if (*selected != new)
  {
    _kernel_oserror * e = redraw_move_highlight(*selected, new);
    *selected = new;
    state_set_list_selected(new);

    if (e) return e;
  }

  return NULL;
}

/*************************************************/
/* redraw_swap_list()                            */
/*                                               */
/* Because only the redraw engine knows the      */
/* real display geometry, only it is qualified   */
/* to move a selected item around.               */
/*                                               */
/* This function moves the highlight from one    */
/* list to another. The highlight will always    */
/* end up on the first item, with the other list */
/* scrolling back to the top.                    */
/*                                               */
/* Parameters: Pointer to a pointer to the       */
/*             currently selected item; contents */
/*             will be updated with the new      */
/*             item pointer.                     */
/*************************************************/

_kernel_oserror * redraw_swap_list(repository_entry ** selected)
{
  repository_entry * main;
  repository_entry * zip;
  repository_entry * scan;
  unsigned int       main_c;
  unsigned int       zip_c;
  unsigned int       found;

  state_get_list_details(&main, &main_c, &zip, &zip_c);

  if (!main || !zip || !selected || !*selected) return NULL;

  /* This is a bit painful; we have to work out what list */
  /* the selected item is in. We'll scan the Zip disc     */
  /* list as it is likely to be shorter, and assume that  */
  /* if the item isn't in that one, it must be in the     */
  /* repository.                                          */

  scan  = zip;
  found = 0;

  while (scan && !found)
  {
    if (scan == *selected) found = 1;
    else scan = scan->prev;
  }

  /* If found is set, we've moving from Zip disc list to main */
  /* repository list; or vice versa.                          */

  scan = *selected;

  if (found)
  {
    *selected = main;
    state_set_list_state(in_main_repository);
    state_set_list_selected(main);

    return redraw_move_highlight(scan, main);
  }
  else
  {
    *selected = zip;
    state_set_list_state(in_zip_list);
    state_set_list_selected(zip);

    return redraw_move_highlight(scan, zip);
  }
}

/*************************************************/
/* redraw_move_highlight()                       */
/*                                               */
/* Move the highlighted item. Tries to redraw as */
/* little as possible. Deals with highlight      */
/* appearing or disappearing, and moving between */
/* the repository or zip disc lists.             */
/*                                               */
/* Parameters: Pointer to the currently selected */
/*             item, or NULL to make it appear;  */
/*                                               */
/*             Pointer to the item that should   */
/*             become selected, or NULL to make  */
/*             it disappear.                     */
/*************************************************/

_kernel_oserror * redraw_move_highlight(repository_entry * old, repository_entry * new)
{
  repository_entry * scan;
  repository_entry * new_top, * old_top;
  repository_entry * main,   * zip;

  unsigned int       new_in = 0, old_in = 0;
  unsigned int       new_d,      old_d;
  unsigned int       new_p,      old_p;
  unsigned int       y,          count;
  unsigned int       main_c,     zip_c;

  state_get_list_details(&main, &main_c, &zip, &zip_c);

  if (!main && !zip) return NULL;
  if (!old && !new)  return NULL;
  if (old == new)    return NULL;

  /* First, find out which list the highlighted items are in; */
  /* hmm, this is all hideously inefficient...                */

  old_d = 0;
  new_d = 0;

  scan = main;

  while (scan)
  {
    if (scan == old) old_in = 1;
    if (scan == new) new_in = 1;

    if (new_in && old_in) break;

    if (!old_in) old_d++;
    if (!new_in) new_d++;

    scan = scan->prev;
  }

  if (!old_in || !new_in)
  {
    if (!old_in) old_d = 0;
    if (!new_in) new_d = 0;

    scan = zip;

    while (scan)
    {
      if (scan == old) old_in = 2;
      if (scan == new) new_in = 2;

      if (new_in && old_in) break;

      if (!old_in) old_d++;
      if (!new_in) new_d++;

      scan = scan->prev;
    }
  }

  if (!old_in && !new_in) return NULL;

  /* Now we need to work out what upper item display */

  old_p = old_d / Redraw_ItemsPerPage;
  new_p = new_d / Redraw_ItemsPerPage;

  if (old_in)
  {
    if (old_in == 1) old_top = main;
    else             old_top = zip;

    for (
          count = old_p * Redraw_ItemsPerPage;
          count > 0 && old_top->prev;
          count--
        )
        old_top = old_top->prev;
  }
  else old_top = NULL;

  if (new_in)
  {
    if (new_in == 1) new_top = main;
    else             new_top = zip;

    for (
          count = new_p * Redraw_ItemsPerPage;
          count > 0 && new_top->prev;
          count--
        )
        new_top = new_top->prev;
  }
  else new_top = NULL;

  if (!old_top && !new_top) return NULL;

  /* Do the redraws. */

  if (old_top == new_top)
  {
    /* We've stayed with the same item at the top of the list */

    if (old_in == 1)
    {
      y = Redraw_DrawableArea_RepositoryTopLeftY +
          (old_d - old_p * Redraw_ItemsPerPage)  *
          Redraw_TotalItemHeight;

      RetError(colours_set_text_foreground(&scheme.repository_text));
      RetError(colours_set_text_background(&scheme.repository_inner));

      RetError(redraw_draw_entry(old,
                                 Redraw_DrawableArea_RepositoryTopLeftX,
                                 y,
                                 Redraw_DrawableArea_RepositoryWidth,
                                 y + Redraw_ItemHeight));
    }
    else if (old_in == 2)
    {
      y = Redraw_DrawableArea_ZipTopLeftY        +
          (old_d - old_p * Redraw_ItemsPerPage)  *
          Redraw_TotalItemHeight;

      RetError(colours_set_text_foreground(&scheme.zip_text));
      RetError(colours_set_text_background(&scheme.zip_inner));

      RetError(redraw_draw_entry(old,
                                 Redraw_DrawableArea_ZipTopLeftX,
                                 y,
                                 Redraw_DrawableArea_ZipWidth,
                                 y + Redraw_ItemHeight));
    }

    RetError(colours_set_text_foreground(&scheme.highlighted_foreground));
    RetError(colours_set_text_background(&scheme.highlighted_background));

    if (new_in == 1)
    {
      y = Redraw_DrawableArea_RepositoryTopLeftY +
          (new_d - new_p * Redraw_ItemsPerPage)  *
          Redraw_TotalItemHeight;

      RetError(redraw_draw_entry(new,
                                 Redraw_DrawableArea_RepositoryTopLeftX,
                                 y,
                                 Redraw_DrawableArea_RepositoryWidth,
                                 y + Redraw_ItemHeight));
    }
    else if (old_in == 2)
    {
      y = Redraw_DrawableArea_ZipTopLeftY        +
          (new_d - new_p * Redraw_ItemsPerPage)  *
          Redraw_TotalItemHeight;

      RetError(redraw_draw_entry(new,
                                 Redraw_DrawableArea_ZipTopLeftX,
                                 y,
                                 Redraw_DrawableArea_ZipWidth,
                                 y + Redraw_ItemHeight));
    }
  }
  else
  {
    /* The item at the top of the list has changed. If we're in a completely */
    /* different list, need to redraw the old one with no highlight before   */
    /* redrawing the at the new position with highlight.                     */

    if (old_in != new_in)
    {
      if (old_in == 1)
      {
        RetError(redraw_draw_entries(&scheme.repository_text,        &scheme.repository_inner,
                                     &scheme.highlighted_foreground, &scheme.highlighted_background,

                                     Redraw_DrawableArea_RepositoryTopLeftX, Redraw_DrawableArea_RepositoryTopLeftY,
                                     Redraw_DrawableArea_RepositoryWidth,    Redraw_DrawableArea_RepositoryHeight,

                                     old_top,
                                     NULL));
      }
      else if (old_in == 2)
      {
        RetError(redraw_draw_entries(&scheme.zip_text,               &scheme.zip_inner,
                                     &scheme.highlighted_foreground, &scheme.highlighted_background,

                                     Redraw_DrawableArea_ZipTopLeftX, Redraw_DrawableArea_ZipTopLeftY,
                                     Redraw_DrawableArea_ZipWidth,    Redraw_DrawableArea_ZipHeight,

                                     old_top,
                                     NULL));
      }
    }

    /* Right, draw the whole list from the new position with new selected item */

    if (new_in == 1)
    {
      RetError(redraw_draw_entries(&scheme.repository_text,        &scheme.repository_inner,
                                   &scheme.highlighted_foreground, &scheme.highlighted_background,

                                   Redraw_DrawableArea_RepositoryTopLeftX, Redraw_DrawableArea_RepositoryTopLeftY,
                                   Redraw_DrawableArea_RepositoryWidth,    Redraw_DrawableArea_RepositoryHeight,

                                   new_top,
                                   new));
    }
    else if (new_in == 2)
    {
      RetError(redraw_draw_entries(&scheme.zip_text,               &scheme.zip_inner,
                                   &scheme.highlighted_foreground, &scheme.highlighted_background,

                                   Redraw_DrawableArea_ZipTopLeftX, Redraw_DrawableArea_ZipTopLeftY,
                                   Redraw_DrawableArea_ZipWidth,    Redraw_DrawableArea_ZipHeight,

                                   new_top,
                                   new));
    }
  }

  /* Update the "N items" / "Item N of M" count */

  if (new_in == 1)
  {
    RetError(redraw_draw_entry_count(main_c,    zip_c,
                                     new_d + 1, 0));
  }
  else
  {
    RetError(redraw_draw_entry_count(main_c, zip_c,
                                     0,      new_d + 1));
  }

  return redraw_draw_possible_commands(0);
}

/*************************************************/
/* redraw_draw_entry()                           */
/*                                               */
/* Draw an entry from a given repository_entry   */
/* structure, constrained to a given width,      */
/* starting top left at a given coordinate.      */
/*                                               */
/* You should already have set text foreground   */
/* and background colours.                       */
/*                                               */
/* Parameters: Pointer to the repository_entry   */
/*             struct to draw;                   */
/*                                               */
/*             Top left (x,y) coord, inclusive,  */
/*             in characters, (0,0) at screen    */
/*             top left.                         */
/*                                               */
/*             Width constraint in characters;   */
/*                                               */
/*             Maximum y coordinate plotting may */
/*             reach (i.e. you can clip off the  */
/*             bottom of the item if you wish);  */
/*                                               */
/* Returns:    Has some transient memory         */
/*             requirements, so apart from       */
/*             anything else, returns general    */
/*             memory error 7 if claims fail.    */
/*************************************************/

_kernel_oserror * redraw_draw_entry(repository_entry * entry,
                                    unsigned int x, unsigned int y,
                                    unsigned int w, unsigned int max_y)
{
  _kernel_oserror * e;
  char            * temp = NULL;
  int               len;
  int               curx, cury;

  if (!entry)                 return NULL;
  if (w < 1 || max_y - y < 1) return NULL;

  curx = x;
  cury = y;

  temp = malloc(w + 1);
  if (!temp) return make_no_memory_error(7);

  /* Show the image path; well, just the leafname if we can */
  /* determine it, otherwise the whole thing.               */

  if (cury < max_y)
  {
    if (entry->path)
    {
      char * p = strrchr(entry->path, '.');

      if (p) strncpy(temp, p + 1,       w);
      else   strncpy(temp, entry->path, w);
    }
    else strncpy(temp, lookup_token("NoPath:<No path>",0,0), w);

    temp[w] = '\0';
    len = strlen(temp);
    while (len < w) temp[len] = ' ', len ++;

    e = asciidraw_move(curx, cury);

    if (e)
    {
      free(temp);
      return e;
    }

    printf("%s", temp);
  }

  /* Show the image name */

  cury++;

  if (cury < max_y)
  {
    memset(temp, ' ', w);
    if (entry->name) strncpy(temp, entry->name, w);
    else             strncpy(temp, lookup_token("NoName:<No name>",0,0), w);

    temp[w] = '\0';
    len = strlen(temp);
    while (len < w) temp[len] = ' ', len ++;

    e = asciidraw_move(curx, cury);

    if (e)
    {
      free(temp);
      return e;
    }

    printf("%s", temp);
  }

  /* Show the image version, build date and build master */

  cury++;

  if (cury < max_y)
  {
    if (entry->version) strncpy(temp, entry->version, w);
    else                strncpy(temp, lookup_token("NoVersion:<No version>",0,0), w);

    temp[w] = '\0';

    if (entry->build_date)
    {
      utils_strncat(temp, " ", w);
      temp[w] = '\0';
      utils_strncat(temp, entry->build_date, w);
    }
    else utils_strncat(temp, lookup_token("NoBuildDate: <No build date>",0,0), w);
    temp[w] = '\0';

    if (entry->build_master)
    {
      utils_strncat(temp, " ", w);
      temp[w] = '\0';
      utils_strncat(temp, entry->build_master, w);
    }
    else utils_strncat(temp, lookup_token("NoBuildMaster: <No build master>",0,0), w);
    temp[w] = '\0';

    len = strlen(temp);
    while (len < w) temp[len] = ' ', len ++;

    e = asciidraw_move(curx, cury);

    if (e)
    {
      free(temp);
      return e;
    }

    printf("%s", temp);
  }

  free(temp);
  return NULL;
}

/*************************************************/
/* redraw_draw_entries()                         */
/*                                               */
/* Draw a list of repository entries that fit in */
/* a given rectangle, possibly highlighting one  */
/* item. The first item to be drawn is always    */
/* aligned at the top of the rectangle. The last */
/* item may fall off it. Items are clipped to    */
/* fit the given space.                          */
/*                                               */
/* Items are drawn from the given start entry    */
/* downwards, following *prev* and not next      */
/* pointers to get to successive entries.        */
/*                                               */
/* Parameters: Pointer to four colour structs    */
/*             describing the unhighlighted      */
/*             text foreground and background,   */
/*             and highlighted text foreground   */
/*             and background colours, in that   */
/*             order;                            */
/*                                               */
/*             Top left hand corner coordinate,  */
/*             inclusive, in characters with     */
/*             (0,0) as top left of screen, for  */
/*             the rectangle the list should be  */
/*             drawn in;                         */
/*                                               */
/*             Rectangle width in characters;    */
/*                                               */
/*             Rectangle height in characters;   */
/*                                               */
/*             Pointer to a repository_entry     */
/*             structure to start at;            */
/*                                               */
/*             Pointer to a repository_entry     */
/*             struct which if redrawn will be   */
/*             shown highlighted (or NULL).      */
/*************************************************/

_kernel_oserror * redraw_draw_entries(colour * un_fore, colour * un_back,
                                      colour * hi_fore, colour * hi_back,
                                      unsigned int x, unsigned int y,
                                      unsigned int w, unsigned int h,
                                      repository_entry * start,
                                      repository_entry * highlight)
{
  repository_entry * current = start;
  int                curx;
  int                cury;

  if (!un_fore || !un_back || !hi_fore || !hi_back) return NULL;
  if (w < 1 || h < 1)                               return NULL;

  curx = x;
  cury = y;

  while (current)
  {
    /* Set the correct colours */

    if (current != highlight)
    {
      RetError(colours_set_text_foreground(un_fore));
      RetError(colours_set_text_background(un_back));
    }
    else
    {
      RetError(colours_set_text_foreground(hi_fore));
      RetError(colours_set_text_background(hi_back));
    }

    RetError(redraw_draw_entry(current, curx, cury, w, y + h));

    cury += 4;
    current = current->prev;
  }

  if (cury < y + h)
  {
    RetError(colours_set_text_background(un_back));
    RetError(asciidraw_filled_rectangle(curx, cury, w, y + h - cury));
  }

  return NULL;
}

/*************************************************/
/* redraw_draw_single_count()                    */
/*                                               */
/* Basically a back-end to                       */
/* redraw_draw_entry_count to avoid code         */
/* duplication. Have the right text colours and  */
/* cursor position set up before calling.        */
/*                                               */
/* Parameters: Maximum string length to allow -  */
/*             the printed message will be       */
/*             padded with spaces to fill this;  */
/*                                               */
/*             Number of items in total present  */
/*             in the list you are referring to; */
/*                                               */
/*             Number of the item currently      */
/*             selected in that list, or 0 for   */
/*             nothing selected / don't want to  */
/*             report that something is.         */
/*************************************************/

static _kernel_oserror * redraw_draw_single_count(int maxlen, int c, int i)
{
  char * temp = malloc(maxlen + 1);
  char * looked;
  int    len;

  if (!temp)
  {
    /* If either claim fails, bomb out */

    return make_no_memory_error(6);
  }
  else
  {
    /* Otherwise, make full length strings of space characters */
    /* - we'll put the string terminators in the last byte     */
    /* later...                                                */

    memset(temp, ' ', maxlen);
  }

  /* Build the message string. If what we want to say is too */
  /* long, blank spaces will be printed instead...           */

  if (i)
  {
    looked = lookup_token("ImageNOf:Image %%d of %%d",0,0);
    len    = strlen(looked) +
             utils_number_length((int) i) +
             utils_number_length((int) c) -
             4; /* Account for two '%d's */

    if (len <= maxlen)
    {
      sprintf(temp,
              looked,
              i,
              c);

      /* Trample on the terminator, to ensure the message is padded */
      /* with spaces. We could be trampling on the very last char   */
      /* in the buffer of course, which is why a final terminator   */
      /* was not added above, and is instead added below. This way  */
      /* we don't have to keep checking before doing the below.     */

      temp[strlen(temp)] = ' ';
    }
  }
  else
  {
    if (c < 2)
    {
      if (!c) looked = lookup_token("NoImages:No images",0,0);
      else    looked = lookup_token("OneImage:1 image",0,0);

      len = strlen(looked);

      if (len <= maxlen)
      {
        sprintf(temp, looked);
        temp[strlen(temp)] = ' ';
      }
    }
    else
    {
      looked = lookup_token("ManyImages:%%d images",0,0);
      len    = strlen(looked) +
               utils_number_length((int) c) -
               2; /* Account for '%d' */

      if (len <= maxlen)
      {
        sprintf(temp,
                looked,
                c);

        temp[strlen(temp)] = ' ';
      }
    }
  }

  temp[maxlen] = '\0';
  printf("%s", temp);

  free (temp);

  return NULL;
}

/*************************************************/
/* redraw_draw_entry_count()                     */
/*                                               */
/* Show "Item n of m" or "n item(s)" counts      */
/* under the repository and Zip disc lists.      */
/*                                               */
/* Parameters: Number of items in the main       */
/*             repository;                       */
/*                                               */
/*             Similarly for the Zip disc list;  */
/*                                               */
/*             Number of current item in         */
/*             repository for "Item n of m" or   */
/*             zero for "n item(s)";             */
/*                                               */
/*             Similarly for the Zip disc list.  */
/*                                               */
/* Returns:    Apart from other errors, memory   */
/*             claim error 6 may be raised.      */
/*************************************************/

_kernel_oserror * redraw_draw_entry_count(unsigned int main_c, unsigned int zip_c,
                                          unsigned int main_i, unsigned int zip_i)
{
  /* First, the repository count */

  RetError(colours_set_text_foreground(&scheme.title_text));
  RetError(colours_set_text_background(&scheme.background));

  RetError(asciidraw_move(Redraw_ImageCount_RepositoryX,
                          Redraw_ImageCount_RepositoryY));

  RetError(redraw_draw_single_count(Redraw_ImageCount_RepositoryMaxLength,
                                    main_c,
                                    main_i));

  /* Now the Zip count */

  RetError(asciidraw_move(Redraw_ImageCount_ZipX,
                          Redraw_ImageCount_ZipY));

  RetError(redraw_draw_single_count(Redraw_ImageCount_ZipMaxLength,
                                    zip_c,
                                    zip_i));

  return NULL;
}

/*************************************************/
/* redraw_draw_possible_commands()               */
/*                                               */
/* Update the command area to show currently     */
/* available commands. Uses state_get_list_state */
/* to work out what is allowed.                  */
/*                                               */
/* Parameters: 1 if the command area should be   */
/*             completely blanked out before     */
/*             redrawing, else 0. Blanking is    */
/*             only necessary if something other */
/*             than any of the selections of     */
/*             commands shown by this function   */
/*             has been drawn in the command     */
/*             area first.                       */
/*************************************************/

_kernel_oserror * redraw_draw_possible_commands(unsigned int blank)
{
  unsigned int pos;
  unsigned int haw = (Redraw_CommandArea_Width >> 1) + 1;
  state_list   state;

  RetError(colours_set_text_background(&scheme.commands_inner));
  RetError(colours_set_text_foreground(&scheme.commands_text));

  if (blank)
  {
    bbc_vduq(BBC_DefTextWindow,
             Redraw_CommandArea_TopLeftX + 1,
             Redraw_CommandArea_TopLeftY + Redraw_CommandArea_Height - 2,
             Redraw_CommandArea_TopLeftX + Redraw_CommandArea_Width - 2,
             Redraw_CommandArea_TopLeftY + 1);

    bbc_vdu (BBC_ClearText);

    bbc_vdu (BBC_DefaultWindow);
  }

  state = state_get_list_state();

  switch (state)
  {
    default:
    case nothing_selected:
    {
      /* No items selected (or unrecognised item value) */

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                              Redraw_CommandArea_TopLeftY + 2));

      printf("%s%n", lookup_token("CommandQ:Q - Quit",0,0), &pos);

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                              Redraw_CommandArea_TopLeftY + 4));

      pos = 0;
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + haw,
                              Redraw_CommandArea_TopLeftY + 4));

      pos = 0;
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                              Redraw_CommandArea_TopLeftY + 5));

      pos = 0;
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + haw,
                              Redraw_CommandArea_TopLeftY + 5));

      pos = 0;
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                              Redraw_CommandArea_TopLeftY + 7));

      pos = 0;
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + haw,
                              Redraw_CommandArea_TopLeftY + 8));

      pos = 0;
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                              Redraw_CommandArea_TopLeftY + 8));

      pos = 0;
      while (++pos < haw - 3) printf(" ");
    }
    break;

    case in_main_repository:
    {
      /* Item in main repository list selected */

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                              Redraw_CommandArea_TopLeftY + 2));

      printf("%s%n", lookup_token("CommandQ:Q - Quit",0,0), &pos);
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                              Redraw_CommandArea_TopLeftY + 4));

      printf("%s%n", lookup_token("CommandC:C - Check CRC value",0,0), &pos);
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + haw,
                              Redraw_CommandArea_TopLeftY + 4));

      printf("%s%n", lookup_token("CommandD:D - Delete",0,0), &pos);
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                              Redraw_CommandArea_TopLeftY + 5));

      printf("%s%n", lookup_token("CommandE:E - Export",0,0), &pos);
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + haw,
                              Redraw_CommandArea_TopLeftY + 5));

      printf("%s%n", lookup_token("CommandB:B - Build production disc",0,0), &pos);
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                              Redraw_CommandArea_TopLeftY + 7));

      /* Navigation keys */

      {
        repository_entry * zip;
        repository_entry * selected;
        unsigned int       zip_c;

        state_get_list_details(NULL, NULL, &zip, &zip_c);
        selected = state_get_list_selected();

        RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                                Redraw_CommandArea_TopLeftY + 8));

        if (selected && selected->prev)
        {
          printf("%s%n", lookup_token("CommandDown:Down - Select next",0,0), &pos);
          while (++pos < haw - 3) printf(" ");
        }
        else
        {
          pos = 0;
          while (++pos < haw - 3) printf(" ");
        }

        RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                                Redraw_CommandArea_TopLeftY + 7));

        if (selected && selected->next)
        {
          printf("%s%n", lookup_token("CommandUp:Up   - Select previous",0,0), &pos);
          while (++pos < haw - 3) printf(" ");
        }
        else
        {
          pos = 0;
          while (++pos < haw - 3) printf(" ");
        }

        RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + haw,
                                Redraw_CommandArea_TopLeftY + 8));

        if (zip && zip_c)
        {
          printf("%s%n", lookup_token("CommandRight:Right - Jump to Zip list",0,0), &pos);
          while (++pos < haw - 3) printf(" ");
        }
        else
        {
          pos = 0;
          while (++pos < haw - 3) printf(" ");
        }
      }
    }
    break;

    case in_zip_list:
    {
      /* Item in zip disc list selected */

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                              Redraw_CommandArea_TopLeftY + 2));

      printf("%s%n", lookup_token("CommandQ:Q - Quit",0,0), &pos);
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                              Redraw_CommandArea_TopLeftY + 4));

      printf("%s%n", lookup_token("CommandC:C - Check CRC value",0,0), &pos);
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + haw,
                              Redraw_CommandArea_TopLeftY + 4));

      printf("%s%n", lookup_token("CommandD:D - Delete",0,0), &pos);
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                              Redraw_CommandArea_TopLeftY + 5));

      printf("%s%n", lookup_token("CommandI:I - Import",0,0), &pos);
      while (++pos < haw - 3) printf(" ");

      RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + haw,
                              Redraw_CommandArea_TopLeftY + 5));

      pos = 0;
      while (++pos < haw - 3) printf(" ");

      /* Navigation keys */

      {
        repository_entry * main;
        repository_entry * selected;
        unsigned int       main_c;

        state_get_list_details(&main, &main_c, NULL, NULL);
        selected = state_get_list_selected();

        RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                                Redraw_CommandArea_TopLeftY + 8));

        if (selected && selected->prev)
        {
          printf("%s%n", lookup_token("CommandDown:Down - Select next",0,0), &pos);
          while (++pos < haw - 3) printf(" ");
        }
        else
        {
          pos = 0;
          while (++pos < haw - 3) printf(" ");
        }

        RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + 2,
                                Redraw_CommandArea_TopLeftY + 7));

        if (selected && selected->next)
        {
          printf("%s%n", lookup_token("CommandUp:Up   - Select previous",0,0), &pos);
          while (++pos < haw - 3) printf(" ");
        }
        else
        {
          pos = 0;
          while (++pos < haw - 3) printf(" ");
        }

        RetError(asciidraw_move(Redraw_CommandArea_TopLeftX + haw,
                                Redraw_CommandArea_TopLeftY + 8));

        if (main && main_c)
        {
          printf("%s%n", lookup_token("CommandLeft:Left - Jump to repository list",0,0), &pos);
          while (++pos < haw - 3) printf(" ");
        }
        else
        {
          pos = 0;
          while (++pos < haw - 3) printf(" ");
        }
      }
    }
    break;
  }

  return NULL;
}

/*************************************************/
/* redraw_draw_main_framework()                  */
/*                                               */
/* Draw the main display framework. Assumes a    */
/* 640x480x256 display mode has been entered and */
/* the VDU system state is unchanged since this  */
/* mode was displayed.                           */
/*************************************************/

_kernel_oserror * redraw_draw_main_framework(void)
{
  /* Do the background */

  RetError(colours_set_text_background(&scheme.background));
  RetError(asciidraw_filled_rectangle(0, 0, 80, 60));

  /* Boxes for the Repository and Zip Disc list titles */

  RetError(asciidraw_filled_box(&scheme.title_outer,
                                &scheme.title_inner,

                                Redraw_Title_RepositoryTopLeftX, Redraw_Title_RepositoryTopLeftY,
                                Redraw_Title_RepositoryWidth,    Redraw_Title_RepositoryHeight));

  RetError(asciidraw_filled_box(&scheme.title_outer,
                                &scheme.title_inner,

                                Redraw_Title_ZipTopLeftX, Redraw_Title_ZipTopLeftY,
                                Redraw_Title_ZipWidth,    Redraw_Title_ZipHeight));

  /* Fill the boxes in with the relevant titles */

  RetError(colours_set_text_foreground(&scheme.title_text));
  RetError(colours_set_text_background(&scheme.title_inner));

  RetError(asciidraw_write_centred(Redraw_Title_RepositoryTopLeftX + 1,
                                   Redraw_Title_RepositoryTopLeftX + Redraw_Title_RepositoryWidth - 2,
                                   Redraw_Title_RepositoryTopLeftY + ((Redraw_Title_RepositoryHeight - 1) >> 1),
                                   lookup_token("RedrRepTitle:Repository",0,0)));

  RetError(asciidraw_write_centred(Redraw_Title_ZipTopLeftX + 1,
                                   Redraw_Title_ZipTopLeftX + Redraw_Title_ZipWidth - 2,
                                   Redraw_Title_ZipTopLeftY + ((Redraw_Title_ZipHeight - 1) >> 1),
                                   lookup_token("RedrZipTitle:Zip disc",0,0)));

  /* Now the boxes for the actual lists */

  RetError(asciidraw_filled_box(&scheme.repository_outer,
                                &scheme.repository_inner,

                                Redraw_OutlineArea_RepositoryTopLeftX, Redraw_OutlineArea_RepositoryTopLeftY,
                                Redraw_OutlineArea_RepositoryWidth,    Redraw_OutlineArea_RepositoryHeight));

  RetError(asciidraw_filled_box(&scheme.zip_outer,
                                &scheme.zip_inner,

                                Redraw_OutlineArea_ZipTopLeftX, Redraw_OutlineArea_ZipTopLeftY,
                                Redraw_OutlineArea_ZipWidth,    Redraw_OutlineArea_ZipHeight));

  /* Box for the command area */

  return asciidraw_filled_box(&scheme.commands_outer,
                              &scheme.commands_inner,

                              Redraw_CommandArea_TopLeftX, Redraw_CommandArea_TopLeftY,
                              Redraw_CommandArea_Width,    Redraw_CommandArea_Height);
}

/*************************************************/
/* redraw_draw_default_display()                 */
/*                                               */
/* Redraw the whole screen to a default starting */
/* display, with the repository and zip disc     */
/* contents scrolled to the top, and the         */
/* starting point commands displayed in the      */
/* command area.                                 */
/*                                               */
/* Will set the current list state with          */
/* state_set_list_state to select the first item */
/* in the main repository, or Zip disc list, or  */
/* neither, depending on which is available.     */
/*                                               */
/* Parameters: Pointer to a pointer to a         */
/*             repository_entry structure, which */
/*             if no error is returned will be   */
/*             updated to point to the currently */
/*             selected repository item.         */
/*                                               */
/* Assumes:    Any of the repository_entry       */
/*             structure pointers may be NULL.   */
/*************************************************/

_kernel_oserror * redraw_draw_default_display(repository_entry ** selected)
{
  repository_entry * main,   * zip;
  unsigned int       main_c,   zip_c;
  state_list         state;

  if (!selected) return NULL;
  state_get_list_details(&main, &main_c, &zip, &zip_c);

  RetError(redraw_draw_main_framework());

  if (main_c)     *selected = main, state = in_main_repository;
  else if (zip_c) *selected = zip,  state = in_zip_list;
  else            *selected = NULL, state = nothing_selected;

  state_set_list_state(state);
  state_set_list_selected(*selected);

  RetError(redraw_draw_entries(&scheme.repository_text,        &scheme.repository_inner,
                               &scheme.highlighted_foreground, &scheme.highlighted_background,

                               Redraw_DrawableArea_RepositoryTopLeftX, Redraw_DrawableArea_RepositoryTopLeftY,
                               Redraw_DrawableArea_RepositoryWidth,    Redraw_DrawableArea_RepositoryHeight,

                               main,
                               *selected));

  RetError(redraw_draw_entries(&scheme.zip_text,               &scheme.zip_inner,
                               &scheme.highlighted_foreground, &scheme.highlighted_background,

                               Redraw_DrawableArea_ZipTopLeftX, Redraw_DrawableArea_ZipTopLeftY,
                               Redraw_DrawableArea_ZipWidth,    Redraw_DrawableArea_ZipHeight,

                               zip,
                               *selected));

  if (main_c)
  {
    RetError(redraw_draw_entry_count(main_c, zip_c,
                                     1,      0));
  }
  else if (zip_c)
  {
    RetError(redraw_draw_entry_count(0, zip_c,
                                     0, 1));
  }
  else
  {
    RetError(redraw_draw_entry_count(0, 0,
                                     0, 0));
  }

  return redraw_draw_possible_commands(1);
}

/*************************************************/
/* redraw_set_up_scan_display()                  */
/*                                               */
/* Set up the display for repository scanning.   */
/*************************************************/

_kernel_oserror * redraw_set_up_scan_display(void)
{
  RetError(colours_set_text_foreground(&scheme.progress_text));
  RetError(colours_set_text_background(&scheme.progress_inner));

  bbc_vdu(BBC_DefaultWindow);
  bbc_vdu(BBC_ClearText);

  printf(lookup_token("RepScan:Scanning repository...",0,0));

  return NULL;
}

/*************************************************/
/* redraw_show_scan_progress()                   */
/*                                               */
/* Show the progress of a repository scan action */
/* - must not be called until after              */
/* redraw_set_up_scan_display has been run.      */
/*                                               */
/* Parameters: String to use for progress        */
/*             display.                          */
/*************************************************/

_kernel_oserror * redraw_show_scan_progress(const char * show)
{
  char         draw[Redraw_Right - Redraw_Left + 2]; /* One line of text with terminator */
  unsigned int len;

  if (!show) show = "";

  bbc_vduq(BBC_DefTextWindow,
           Redraw_Left,
           Redraw_Bottom,
           Redraw_Right,
           Redraw_Top + 2);

  memset(draw, ' ', sizeof(draw));

  len = strlen(show);

  if (len > sizeof(draw) - 1)
  {
    const char * start = show + len - (sizeof(draw) - 4);

    if (sizeof(draw) < 4) return NULL;

    strcpy(draw, "...");
    StrNCat0(draw, start);
  }
  else
  {
    strcpy(draw, show);
  }

  draw[strlen(draw)]     = ' ';
  draw[sizeof(draw) - 1] = '\0';

  printf("%s", draw);

  bbc_vdu(BBC_DefaultWindow);

  return NULL;
}

/*************************************************/
/* redraw_report_error()                         */
/*                                               */
/* Print an error message on-screen in colours   */
/* and at a position defined at the top of this  */
/* source file.                                  */
/*                                               */
/* Parameters: Pointer to the error block;       */
/*                                               */
/*             Pointer to a message token to     */
/*             give to lookup_token; this is to  */
/*             generate an instruction string    */
/*             after the reported error (e.g.    */
/*             'press A to accept, Q to quit').  */
/*************************************************/

void redraw_report_error(_kernel_oserror * e, const char * token)
{
  char number[11];

  if (!e || !e->errmess || !*e->errmess) return;

  colours_set_text_background(&scheme.error_background);
  colours_set_text_foreground(&scheme.error_foreground);

  /* Print the actual error */

  bbc_vduq(BBC_DefTextWindow,
           Redraw_CommandArea_TopLeftX + 2,
           Redraw_CommandArea_TopLeftY + Redraw_CommandArea_Height - 3,
           Redraw_CommandArea_TopLeftX + Redraw_CommandArea_Width - 3,
           Redraw_CommandArea_TopLeftY + 2);

  bbc_vdu (BBC_ClearText);

  bbc_vduq(BBC_DefTextWindow,
           Redraw_CommandArea_TopLeftX + 3,
           Redraw_CommandArea_TopLeftY + Redraw_CommandArea_Height - 5,
           Redraw_CommandArea_TopLeftX + Redraw_CommandArea_Width - 5,
           Redraw_CommandArea_TopLeftY + 3);

  asciidraw_move(0,0);

  sprintf(number, "%#08x", e->errnum);

  /* Show an error number, unless this is a message / query */

  if (e->errnum == Utils_Error_Custom_Message)
  {
    _swix(OS_PrettyPrint,
          _INR(0,2),

          lookup_token("Format3:Message:", 0, number),
          0,
          NULL);
  }
  else
  {
    _swix(OS_PrettyPrint,
          _INR(0,2),

          lookup_token("Format1:(%0)", 0, number),
          0,
          NULL);
  }

  /* Tag on the actual error */

  _swix(OS_PrettyPrint,
        _INR(0,2),

        lookup_token("Format2:\xa0%0", 0, e->errmess),
        0,
        NULL);

  /* Give instructions on how to proceed */

  bbc_vduq(BBC_DefTextWindow,
           Redraw_CommandArea_TopLeftX + 3,
           Redraw_CommandArea_TopLeftY + Redraw_CommandArea_Height - 4,
           Redraw_CommandArea_TopLeftX + Redraw_CommandArea_Width - 5,
           Redraw_CommandArea_TopLeftY + Redraw_CommandArea_Height - 4);

  bbc_vdu (BBC_ClearText);

  asciidraw_write_centred(0,
                          Redraw_CommandArea_Width - 6,
                          0,
                          lookup_token(token, 0, 0));

  /* Restore a default text window in case Escape is used, etc. */

  bbc_vdu (BBC_DefaultWindow);
}

/*************************************************/
/* redraw_report_message()                       */
/*                                               */
/* Print a message in the command area in a      */
/* given colour.                                 */
/*                                               */
/* Use redraw_draw_possible_commands(1) to       */
/* restore the command area display when you     */
/* need to clear the message.                    */
/*                                               */
/* If you asked for the text window and cursor   */
/* position to be left alone (see parameters     */
/* list), you must be sure to use                */
/* bbc_vdu(BBC_ClearText) - see FromROSLib.h -   */
/* to restore the default window before calling  */
/* any other Redraw.c functions.                 */
/*                                               */
/* Parameters: Pointer to the string to print;   */
/*                                               */
/*             Pointer to a colour structure     */
/*             describing the foreground colour; */
/*                                               */
/*             Pointer to a colour structure     */
/*             describing the background colour; */
/*                                               */
/*             1 to restore a default text       */
/*             window before exitting, else 0 to */
/*             leave the text window and text    */
/*             cursor position unchanged (can be */
/*             used to append extra text, e.g.   */
/*             dots to indicate progress).       */
/*************************************************/

_kernel_oserror * redraw_report_message(const char * message, colour * fg, colour * bg, unsigned int restore)
{
  if (!fg || !bg || !message || !*message) return NULL;

  RetError(colours_set_text_background(bg));
  RetError(colours_set_text_foreground(fg));

  bbc_vduq(BBC_DefTextWindow,
           Redraw_CommandArea_TopLeftX + 2,
           Redraw_CommandArea_TopLeftY + Redraw_CommandArea_Height - 3,
           Redraw_CommandArea_TopLeftX + Redraw_CommandArea_Width - 3,
           Redraw_CommandArea_TopLeftY + 2);

  bbc_vdu (BBC_ClearText);

  bbc_vduq(BBC_DefTextWindow,
           Redraw_CommandArea_TopLeftX + 3,
           Redraw_CommandArea_TopLeftY + Redraw_CommandArea_Height - 4,
           Redraw_CommandArea_TopLeftX + Redraw_CommandArea_Width - 5,
           Redraw_CommandArea_TopLeftY + 3);

  RetError(_swix(OS_PrettyPrint,
                 _INR(0,2),

                 message,
                 0,
                 NULL));

  if (restore) bbc_vdu (BBC_DefaultWindow);

  return NULL;
}
