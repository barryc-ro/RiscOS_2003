/*
 ----------------------------------------------------------------------------
  Copyright [1999] Pace Micro Technology PLC.  All rights reserved.
  
  The copyright in this material is owned by Pace Micro Technology PLC
  ("Pace").  This material is regarded as a highly confidential trade secret
  of Pace.  It may not be reproduced, used, sold or in any other way exploited
  or transferred to any third party without the prior written permission of
  Pace.
  ----------------------------------------------------------------------------
*/

/****************************************************************************/
//   	Filename:	parser.c++
//	Author:		Alistair Rodger
//	Spec:		DO 2501,833/FS
//
//	Description:
//	this class contains a set of methods appropriate to parsing a config file
//
// History:
//
// Date      Who	Description of change
// ===========================================
// 08/10/99  AR		File created
/****************************************************************************/

#include "menuhier.h"
#include "ctype.h"
#include "main.h"

// token strings used to define menus see table 4 of the spec
static char* menu_token    = "MENU";
static char* submenu_token = "SUBMENU";
static char* nvram_token   = "NVRAM";
static char* list_token    = "LIST";
static char* string_token  = "STRING";
static char* IPstring_token= "IPSTRING";
static char* range_token   = "RANGE";
static char* desc_token    = "DESC";
static char* mfunc_token   = "MFUNC";

/**********************************************************************************/
// this file takes a filename and reads it into an allocated array
// it also sets the menu tree to null etc.
Parser::Parser(char *file)
{
  	error = NULL;
  	menu_pool = NULL;
  	line_num = 1;		// updated at each eoln factor.
  	current = seek = 0;	// set the offsets
  	
  	int type = 0;		// file type
  	
  	if ((file == NULL)&&(error == NULL))
  		error = makeError(EM_ObjectError);
  	 	
  	if (error == NULL)
  		error = _swix(OS_File, _INR(0,1)|_OUT(0)|_OUT(4), 17, file, &type, &eof);
  	
 	if (type != 1) { 	// file found
  		if (error == NULL)  		  	
  			error = makeError(EM_NoFILE, file);
  	} else {
  	  	if (error == NULL) {
  	  		file_ptr = new char[eof];	// allocate memory for the file
  	  	
  	  		if (file_ptr != NULL) {
  	  		  
  	  		  	error = _swix(OS_File, _INR(0,3), 16, file, file_ptr, 0);

  	  		} else {
  	  		  
  	  			error = makeError(EM_Alloc);
  	  			
  	  		}
  	  	}
  	}
  	
  	eof -= 1; // point to the last element in the list.
  	
#ifdef DEBUGLIB
	debug("parser","open config file size = %i\n", eof);
#endif  	
}

Parser::~Parser()
{
  	if (menu_pool != NULL) delete menu_pool;
  	
  	if (file_ptr != NULL) {
  	  	delete file_ptr; file_ptr = NULL;
  	}
}

char*
Parser::line_num_to_string()
{
  	sprintf(line_str, "%i", line_num);
  	return line_str;
}

// this parses the config file ( allocated block ) on an element/menu level
// this is the visable function that will construct a menu heirarchy
menuObject*
Parser::getMenuPool()
{
    menuObject* temp_menu = NULL;	// the returnable, NULL on error.
    
     while ((current < eof)&&(error == NULL)){
             
            // this returns a boolean but we dont care
            while ((getComment() == true)&&(current < eof));
            
            if (current >= eof) break;
             
            // line parsing, at this level the token represents a menu, it new menu. or a
            // menu element to be added to the current menu, therefore one must exist.
            if (seekToken() == true) {
                    
                    // MENU
                    if (seekTokenCompare(menu_token) == true)
                    		getMenuDesc();
		    else
		    // ELEMENT (8* is checked by the menu object);  
                    if (menu_pool != NULL){
                          
                            // SUBMENU
                            if (seekTokenCompare(submenu_token) == true)
                              		getSubmenu();
                            else
                            
                            // NVRAM
                            if (seekTokenCompare(nvram_token) == true)
                              		getNVRAM();
                            else
                            
                            // DESC
                            if (seekTokenCompare(desc_token) == true)
                              		getDescFn();
                            else
                            
                            // MFUNC
                            if (seekTokenCompare(mfunc_token) == true)
                              		getManagementFn();
                              		
                            else {
                            	// default error
                            	if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
                            }
                            	
                    } else {
                      		// there is no current menu to add an element to
                          	if (error == NULL) error = makeError(EM_NoMENU);
                    }
                        
            	    // end of line
            	    if ((error == NULL)&&(getChar(';') == false)) {
            			if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
            	    } else {
            			line_num++;
                    }
            } else {
              
              	if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
              	
            }
            
     }
     
     if (error != NULL) {
       
#ifdef DEBUGLIB       
       	   debug("parser", "exit parser on error");
#endif       	  

     	   delete menu_pool;
     	   menu_pool = NULL;
     }
          
     temp_menu = menu_pool;
     menu_pool = NULL;
     
     current = seek = 0;	// in case we parse again.
     
     return temp_menu;
}
/**********************************************************************************/
//
// Private functions and nothing to do with pigs.
//
// all of the get and seek functions consume white space.
//
// these are defined by the syntactical factors as defined in the specification
// with the exception of getChar which does the job of all seperators, "," , eoln
// and list.
//
/**********************************************************************************/

// moves the current and seek to the end of a comment line if one exists
bool
Parser::getComment()
{
  	bool return_val = false;
  	
  	if ((return_val = getChar('#')) == true)
  		while ((current < eof)&&(isprint(file_ptr[current]))) current++;
  		
  	seek = current; // point to next non-printable, usually white space
  		
 	return return_val;
}

// moves the current and seek past the character specified by 'item'
bool
Parser::getChar(char item)
{
  	bool return_val = false;
 	
 	// get white space
 	while ((current < eof)&&(isspace(file_ptr[current]))) current++;
  	
  	// check item
  	if (file_ptr[current] == item){
  	  	current++;
  		return_val = true;
  	}
  		
  	seek = current;	// move both pointers to one char past item, or next non white space
  	
   	return return_val;
}

// moves the current to the first character of the string, and the seek one past the final.
// in all cases this must be the '"'.
bool
Parser::seekString()
{
  	bool return_val = false;
  	
  	if ((return_val = getChar('"')) == true){
  	    		
  	  	while ((seek < eof)&&(isprint(file_ptr[seek]))) {
  	  	  
  	  	  	if (file_ptr[seek] == '"'){
  	  	  	  
  	  	  	  	if( seek != current+1)// if not an empty string
  					return_val = true;
  				break;
  			}
  			
  	  	  	seek ++; // now look at the next character and loop
  		}// isprint
        }// starts as "
        
 	return return_val;
}

// moves the current to the first character of the token and moves the seek to one past the last
bool
Parser::seekToken()
{
  	bool return_val = false;
  	
 	while ((current < eof)&&(isspace(file_ptr[current]))) current++;
 	
	if (isalnum(file_ptr[current])) {
	  
	  	return_val = true;
	  	
	  	seek = current; // move seek to the head of the token
	  	
	  	while ( (seek < eof) && (isalnum(file_ptr[seek])) ) seek++;
	}
 	return return_val;
}

// similarly current points to the first digit seek one past the last.
bool
Parser::seekNumber()
{
 	bool return_val = false;
  	
 	while ( (current < eof) && (isspace(file_ptr[current])) ) current++;

	if (isdigit(file_ptr[current])) {
	  
	  	return_val = true;
	  	
	  	seek = current;
	  	
	  	while ( (seek < eof) && (isdigit(file_ptr[seek])) ) seek++;
	}
 	return return_val;
}

// compares comp_str with the space between the current and seek pointers upto seek -1;
bool 
Parser::seekTokenCompare(const char* comp_str)
{
  	bool return_val = false;
  	
  	if (seek > current) {
  	  	if (strncmp(comp_str, (file_ptr + current), seek-current) == 0)
  	  		return_val = true;
  	  	else
  	  		return_val = false;
  	} else {
  	  	// this should not happen if the code is consistent
  	  	if (error == NULL) error = makeError( EM_ObjectError );
  	}
  	
  	// if comp_str is longer
  	if ( (return_val != false) && (strlen(comp_str) > (seek - current)) )
  		return_val = false;
  	
 	return return_val;
}

// extract an integer from between the current and seek offsets
int	
Parser::getNewNumberFromSeek()
{
  	int value = 0, i = 0;
  	
  	if (seek > current) {
  	  
          	while (i < seek-current) {
          		value = (value*10) + ( file_ptr[current+i] - '0');
          		i++;
          	}
          	
  	} else {
  	  
  	  	if (error == NULL) error = makeError( EM_ObjectError );
  	}
  	
  	return value;
}

// extract and allocate a string from between current and seek offsets.
char*	
Parser::getNewStringFromSeek()
{
  	char *string = NULL;
  	
  	if (seek > current) {
  	  
          	string = new char[(seek-current)+1];
          	
          	if (string != NULL) {
          	  
          		strncpy(string, (file_ptr + current), seek-current);
          	
          		string[(seek-current)] = '\0';
          		
                } else {
                  
                  	if (error == NULL) error = makeError(EM_Alloc);
                }
        } else {
          
  	  	if (error == NULL) error = makeError( EM_ObjectError );
  	}
  	
  	return string;
}

//----------------------------------------------------------------------- MENU desc -------
// this gets the 'menu description' syntactic factor and constructs a new menu object
// it adds this new menu object to the head of the menu list (menu_pool).  This means
// that adding a new menu element will add it to this menu not the last.
//
void
Parser::getMenuDesc()
{
  	char *TAG = NULL, *desc_string = NULL;
  
  	current = seek;// these currently straddle the MENU token
  
        // TAG identifying this menu with submenu lookups
      	if ((getChar(',') == true)&&(seekToken() == true)) {
        	
          	TAG = getNewStringFromSeek();
	  	current = seek;
                
      	} else {
      	 
	      	if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());	
      	
      	}  
        
	// description string.      
      	if (error == NULL){
        	if ((getChar(',') == true)&&(seekString() == true)) {
        		  
        		desc_string = getNewStringFromSeek();
			current = seek +=1; // past '"'
              
          	} else {
    	
               		if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
               		delete TAG; TAG = NULL;
        	}
      	}
        
        // create new menu object
      	if (error == NULL) {
      	  	menuObject* menu = new menuObject(TAG, desc_string);
        	  	
       	  	if (menu == NULL) {
       	  	  
       	  		if (error == NULL) error = makeError(EM_Alloc);
       	  		
       	  	} else {
       	  	  
       	  	  	if ((error = menu->getError()) == NULL){
       	  	  		menu->chain = menu_pool;
      				menu_pool = menu;
      			} else {
      			  	delete menu;
      			  	menu = NULL;
      			}
      		}
        }
 }
 
//----------------------------------------------------------------------- SUBMENU -------
// this gets the TAG from that submenu and looks up the existing menu with that tag.  This
// method then creates a new submenu element that links the resolved menu.  It then adds this
// element to the current menu object
void
Parser::getSubmenu()
{
  	current = seek;	// presently straddling SUBMENU
  	
  	if ((getChar(',') == true)&&(seekToken() == true)) {
		
		menuObject* tmpObjectPtr = menu_pool;
	
		// go through the menu pool and find the menu with this tag.
		while (( tmpObjectPtr != NULL )&&( seekTokenCompare(tmpObjectPtr->tag) == false))
				tmpObjectPtr = tmpObjectPtr->chain;
		
		current = seek; // we have no further need of the token.
			
		if (tmpObjectPtr == NULL){
	  
			if (error == NULL) {
			  	
			  	char* tag = getNewStringFromSeek();
			  	
			  	if (error == NULL) {
			  		error = makeError(EM_UnknownTAG, tag);
			  		delete tag;
			  	}
			}
		
		} else {
		  
			menuElement* tmpElem = new SUBMENU(tmpObjectPtr);
		  	
			if (tmpElem == NULL) {
			  
			  	if (error == NULL) error = makeError(EM_Alloc);
			  	
			} else {
			  	// this will check for errors in the elements construction
				if (error == NULL) {
				  	error = menu_pool->addElement(tmpElem);
				  	
				  	if (error != NULL) {
				  		delete tmpElem;
				  		tmpElem = NULL;
				  	}
				}				
			}
		}
		
	} else {
	  
	  	if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
	}
}

//-----------------------------------------------------------------------  NVRAM  --------
void
Parser::getNVRAM()
{  	
  	char *desc = NULL;
  	
  	current = seek; // straddling NVRAM
  	
  	// description string
  	if ((getChar(',') == true)&&(seekString() == true)) {
  	  
  		desc = getNewStringFromSeek();
		current = seek +=1;
		
  	} else {
  	  
  		if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  		
  	}
  	
  	if ((error == NULL)&&(getChar(',') == true)&&(seekToken() == true)) {
  	  	
  	  	// LIST
  	  	if (seekTokenCompare(list_token) == true)
  	  		getNVRAMlist(desc);
  	  	else
  	  	
  	  	// STRING
  	  	if (seekTokenCompare(string_token) == true)
  	  		getNVRAMstring(desc);
  	  	else
  	  	
  	  	// IPSTRING
  	  	if (seekTokenCompare(IPstring_token) == true)
  	  		getNVRAMstring(desc, true);
  	  	else
  	  	
  	  	// RANGE
  	  	if (seekTokenCompare(range_token) == true) {
  	  		getNVRAMrange(desc);
  	  		
  	  	} else {
  	  		if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  	  		
  	  		if (desc != NULL) { delete desc; desc = NULL; }
  	  	}
  	  	
  	} else {
  	  
  	  	if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  	  		
  	  	if (desc != NULL) { delete desc; desc = NULL; }  	  	
  	}
}

void
Parser::getNVRAMlist(char* desc)
{
  	int nvram_value = 0;
  	
  	char *token = NULL;
  	char *nvram_string = NULL;

  	current = seek; // straddling LIST

  	// nvram token
  	if (error == NULL){
  	  	if ((getChar(',') == true)&&(seekToken() == true)) {
  			token = getNewStringFromSeek();
			current = seek;
  		} else {
  			error = makeError(EM_ParseError, line_num_to_string());
  		}
  	}

  	listNVRAM *tmpElement = new listNVRAM(desc, token);

 	if (tmpElement == NULL) {
 	  
  		if (error == NULL) error = makeError(EM_Alloc);
  		
  	} else {
  	  
  	        if (error == NULL) {
#ifdef DEBUGLIB
	debug("parser", "+adding nvram list\n");
#endif  	          
  	          	error = menu_pool->addElement(tmpElement);
#ifdef DEBUGLIB
	debug("parser", "-adding nvram list e = %8.8X\n", error);
#endif  	          
  	          	
  	          	if (error != NULL) {
  	          	
				delete tmpElement;
  	          		tmpElement = NULL;
#ifdef DEBUGLIB
				debug("parser", "-adding nvram list e = %8.8X\n", error);
#endif  	          
  	                } else {
  	        	
				menu_pool->notCentred();
  	        	}
  	        }
  	}
  	    
  	if (error == NULL) {
  	  
  	  	//while list elements
  	  	while ((getChar(',') == true)&&(seekString() == true)){
  	  	  
  	  	  	nvram_string = getNewStringFromSeek();
  	  	  	current = seek += 1;
  	  	  	
  	  	  	if ((getChar('=') == true)&&(seekNumber() == true)){
  	  	  	  	nvram_value = getNewNumberFromSeek();
  	  	  	  	current= seek;
  	  	  	  	
  	  	  	  	error = tmpElement->addList(nvram_string, nvram_value);
  	  	  	} else {
  	  			error = makeError(EM_ParseError, line_num_to_string());
  	  		}
  	  	}
  	  	
  	  	if (nvram_string == NULL) {
  	  	  	// this will be set to non null when a list is found if it is null no list
  	  	  	// entries have been found this is an error.
  	  	  	if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  	  	}
  	} // not error
}

void
Parser::getNVRAMstring(char* desc, boolean IPstring)
{
  	tag_list *tags = NULL, *tags2 = NULL, *tags_base = NULL;
   	menuElement* tmpElement = NULL;
   	
  	current = seek; // straddling STRING
   	
  	// nvram token
  	if (getChar(',') != true)
  		error = makeError(EM_ParseError, line_num_to_string());
  		
  	if (error == NULL) {
  	  	
  	  	do {
  	  	  	tags = new tag_list;
  	  	  	
  	  	  	if (tags == NULL) {
  	  	  	  	
  	  	  	  	error = makeError(EM_Alloc);
  	  	  	} else {
  	  	  		if (tags_base != NULL){
  	  	  			tags2->next = tags;
  	  	  		} else {
  	  	  		  	tags_base = tags;
  	  	  		}
  	  	  		
  	  	  		tags->length = 0;
  	  	  		tags->next = NULL;
  	  	  	
  	  	  		if (seekToken() == true) {
  	  	  			tags->tag = getNewStringFromSeek();
  	  	  			current = seek;
  	  	  		} else {
  	  	  	  
  	  	  	  		error = makeError(EM_ParseError, line_num_to_string());
  	  	  	  		break;
  	  	  	  	}
  	  	  	}
  	  	  	
  	  	  	tags2 = tags;
  	  	  	
  	  	} while (getChar(',') == true);
  	}
  	
  	if (IPstring == true){
  		tmpElement = new IPstringNVRAM(desc, tags_base);
  	} else {
  		tmpElement = new stringNVRAM(desc, tags_base);
  	}
  	  		
  	if (tmpElement == NULL) {
  	
		if (error == NULL) error = makeError(EM_Alloc);
  	} else {
  	  
  	       	if (error == NULL) {
  	       	  
  	       	  	error = menu_pool->addElement(tmpElement);
  	       	  	if (error != NULL) {
  	       	  	  	
  	       	  	  	delete tmpElement;
  	       	  	  	tmpElement = NULL;
  	       	  	} else {
  	        		
  	        		menu_pool->notCentred();
  	        	}
  	        }
  	}
}

void
Parser::getNVRAMrange(char* desc)
{
  	int min = 0, max = 0, granularity = 1;
  	char* token = NULL;
  	current = seek; //straddling RANGE
  	  	
  	// nvram token
  	if (error == NULL){
  	  	if ((getChar(',') == true)&&(seekToken() == true)) {
  			token = getNewStringFromSeek();
			current = seek;
  		} else {
  			error = makeError(EM_ParseError, line_num_to_string());
  		}
  	}

  	if (error == NULL){
  		if ((getChar(',') == true)&&(seekNumber() == true)) {
  		  
  			min = getNewNumberFromSeek();
			current = seek;
			
  		} else {
  		  
  			if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  		}
  	}
  	
  	if (error == NULL){
  	  
  		if (getChar('-') == false)
  			if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  	}
  	
  	if (error == NULL){
  		if (seekNumber() == true){
  		  
  			max = getNewNumberFromSeek();
			current = seek;
  		} else {
  		  
  			if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  		}
  	}
  	
  	if ((error == NULL)&&(getChar(',') == true)&&(seekNumber() == true)){
  	  
  		granularity = getNewNumberFromSeek();
		current = seek;
  	}
  	
  	if (min > max)
  		error = error = makeError(EM_ParseError, line_num_to_string());
   	
  	if (error == NULL) {
  	  	
 			
  	  	if (menu_pool != NULL) {
  	  	  
  			menuElement* tmpElement = new rangeNVRAM( desc, token, min, max, granularity);
  		
  			if (tmpElement == NULL) {
  			  
  				if (error == NULL) error = makeError(EM_Alloc);
  	        	} else {
  	        	  
  	        	  	if (error == NULL) {
  	        	  	  	error = menu_pool->addElement(tmpElement);
  	        	  	  	if (error != NULL) {
  	        	  	  	  
  	        	  	  		delete tmpElement;
  	        	  	  		tmpElement = NULL;
  	        	  	        } else {
  	        				menu_pool->notCentred();
  	        		        }
  	        		}
  	        	}
  		} else {
  		  	error = makeError(EM_NoMENU);
  		}
  		
  	} else {
  	  
  		delete desc; desc = NULL;
  		delete token; token = NULL;
  	}
}

//-----------------------------------------------------------------------  DESC  --------

void
Parser::getDescFn()
{
  	char *desc = NULL, *token = NULL;
  	
  	current = seek; // straddling DESC
  	
  	if ((getChar(',') == true)&&(seekString() == true)) {
  	  
  		desc = getNewStringFromSeek();
		current = seek +=1;
	} else {
	  
  		if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  	}
  	
  	if (error == NULL){
  	  
  	  	if ((getChar(',') == true)&&(seekToken() == true)) {
  	
			token = getNewStringFromSeek();
			current = seek;
		} else {
		  
  			if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  		}
  	}
  	
 	if (error == NULL) {
 	  
  		DESC* tmpElement = new DESC(desc, token);
  		
  		if (tmpElement == NULL) {
  	
			if (error == NULL) error = makeError(EM_Alloc);
  	        } else {
  	          
  	          	// while there are arguments
  			while (getChar(',') == true){
  	  
  	  			if (seekString() == false) {
  	  	
  	  				if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  	  		
  	        		} else {
  	        		  
  	          			if (error == NULL) error = tmpElement->addArgument(getNewStringFromSeek());
					current = seek += 1;
  	        		}		
  	                }
  	                
  	                if (error == NULL) {
  	          		error = menu_pool->addElement((menuElement*)tmpElement);
  	          		if (error != NULL) {
  	          			delete tmpElement;
  	          			tmpElement = NULL;
  	          		} else {
  	        			menu_pool->notCentred();
  	        		}
  	          	} else {
  	          		delete tmpElement;
  	          	}
    	        }
  	} else {
  	  	error = makeError(EM_NoMENU);
  	}
}

//-----------------------------------------------------------------------  MFUNC  --------

void
Parser::getManagementFn()
{
  	char *desc = NULL, *token = NULL, *message = NULL;
  	
  	current = seek; //straddling MFUNC
  	  	
  	if ((getChar(',') == true)&&(seekString() == true)) {
  	  
  		desc = getNewStringFromSeek();
		current = seek +=1;
  	} else {
  	  
  		if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  	}
  	
  	if (error == NULL) {
  	  
  	  	if ((getChar(',') == true)&&(seekToken() == true)) {
  	
			token = getNewStringFromSeek();
			current = seek;
  		} else {
  	
			if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  		}
  	}
  	
   	if (error == NULL){
   	  
  	  	if (getChar(',') == true) {
  	  	  
  	  		if (seekString() == true){
  	  		  
  				message = getNewStringFromSeek();
				current = seek +=1;
				
  			} else {
  				
  				if (error == NULL) error = makeError(EM_ParseError, line_num_to_string());
  			}
  		}
  	}
  	
  	if (error == NULL){
  	  	menuElement* tmpElement = new MFUNC(desc, token, message);
          		
          	if (tmpElement == NULL) {
          		  
          		error = makeError(EM_Alloc);
          		
                } else {
          	
                   	if (error == NULL) {
                   	  	error = menu_pool->addElement(tmpElement);
                   	  	if (error != NULL) {
                   	  	  	delete tmpElement;
                   	  	  	tmpElement = NULL;
                   	  	}
          	        }
                }
  	}
}
