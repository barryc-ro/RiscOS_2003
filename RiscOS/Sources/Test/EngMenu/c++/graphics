
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

extern "C" {
#include "kernel.h"
#include "swis.h"
#include "os.h"
#include "bbc.h"
}
#include "main.h"
#include "graphics.h"

// swi calls
#define NH_AntiTwitter		0x838C0
#define ModeFiles_SafeArea	0x4D481

#define RiscPC_Test 1

/***************************************************************************************************/
// this section defines the variables refered to in the drawing functions
#define font_size 16
// these are integer 24 bit colour values of the form
// BBGGRR00 where B,G & R mean blue, green and red.
typedef enum {
  col_background = 0x55000000,
  col_orange	 = 0x0044CC00,
  col_lightblue  = 0xCC000000,
  col_offwhite	 = 0xF8F8F800
} col_palette;

// these values depict the layout of the graphics in OS units
// to calculate these draw a picture.  These are relative to centre.
typedef enum {
  twocol_inside = 15, 	// measured from the center
  twocol_outside = 600,
  onecol_outside = 500,
  height_topstrip = 100,// height from the top area
  eleheight = 100,	// the height of the element, this is row occupation
  elembord = 10,	// the vertical distance between elements, visable element height = height - (elebord>1) 
  twitter_border = 3,	// the overscan to twitter.
  maxelem = 8,
  sprite_x = 10,        // sprite distance from bottom right
  sprite_y = 10,	// 
  sprite_width = 200,	// by definition this must match the sprite passed in or it will look bad.
  sprite_height = 120
} pos_menu;

// macros used to make code more readable
#define TOP_OF_TOP_ELEMENT	(safe_area.y1 - height_topstrip - eleheight*3/4)
#define COLUMN_C_LEFT		((( (safe_area.x1-safe_area.x0) >>1)+safe_area.x0)+1 - onecol_outside)
#define COLUMN_C_RIGHT		((( (safe_area.x1-safe_area.x0) >>1)+safe_area.x0)+1 + onecol_outside)
#define COLUMN_1_LEFT		((( (safe_area.x1-safe_area.x0) >>1)+safe_area.x0)+1 - twocol_outside)
#define COLUMN_1_RIGHT 		((( (safe_area.x1-safe_area.x0) >>1)+safe_area.x0)+1 - twocol_inside)
#define COLUMN_2_LEFT		((( (safe_area.x1-safe_area.x0) >>1)+safe_area.x0)+1 + twocol_inside)
#define COLUMN_2_RIGHT 		((( (safe_area.x1-safe_area.x0) >>1)+safe_area.x0)+1 + twocol_outside)

/***************************************************************************************************/

typedef struct
{
          int width;
          int height;
          int bpp;
          char name[24];
          int size;
          int mode;
} imageinfo_str;

// file scope
imageinfo_str image_info;

_kernel_oserror*
graphics::plot_sprite_translated(int x, int y)
{
  char pal[256];
  int scale[16];
  
  int logical_colour;
  
  _kernel_swi_regs r;
  _kernel_oserror *err = NULL;

  err = _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 3, &logical_colour);
  
  if ((err == NULL)&&(logical_colour > 15))
  {
    	r.r[0] = 0x100;
    	r.r[1] = (int) sprite_area;
    	r.r[2] = (int) image_info.name;
    	r.r[3] = r.r[4] = r.r[5] = 0;
    	r.r[6] = (int) scale;
    	r.r[7] = (int) pal;
    	err = _kernel_swi(Wimp_ReadPixTrans, &r, &r);
    
    	if (err == NULL) {
    		r.r[0] = (int) sprite_area;
    		r.r[1] = (int) image_info.name;
    		r.r[2] = r.r[3] = -1;
    		r.r[4] = (int) pal;
    		err = _kernel_swi(ColourTrans_SelectTable, &r, &r);
    	}
  } else {
    	r.r[0] = 0x100;
    	r.r[1] = (int) sprite_area;
    	r.r[2] = (int) image_info.name;
    	r.r[3] = r.r[4] = r.r[5] = 0;
    	r.r[6] = (int) scale;
    	r.r[7] = (int) pal;
    	err = _kernel_swi(Wimp_ReadPixTrans, &r, &r);
  }

  if (err == NULL){
  	r.r[0] = 256 + 52;
  	r.r[1] = (int) sprite_area;
  	r.r[2] = (int) image_info.name;
  	r.r[3] = x;
  	r.r[4] = y;
  	r.r[5] = 8;
  	r.r[6] = (int) scale;
  	r.r[7] = (int) pal;
  	err = _kernel_swi(OS_SpriteOp, &r, &r);
  }
  return err;
}

// load and plot a sprite at x and y co-ords os units.
_kernel_oserror*
graphics::load_sprite(const char *filename)
{
  _kernel_swi_regs r;
  _kernel_oserror *err;
  char name[25];

  sprite_area[0] = 12 * 1024;
  sprite_area[2] = 16;
  r.r[0] = 256 + 9;
  r.r[1] = (int) sprite_area;
  err = _kernel_swi(OS_SpriteOp, &r, &r);

  if (!err)
  {
      r.r[0] = 256 + 10;
      r.r[1] = (int) sprite_area;
      r.r[2] = (int) filename;
      err = _kernel_swi(OS_SpriteOp, &r, &r);

      r.r[0] = 256 + 13;
      r.r[1] = (int) sprite_area;
      r.r[2] = (int) name;
      r.r[3] = 24;
      r.r[4] = 1;
      _kernel_swi(OS_SpriteOp, &r, &r);
      name[r.r[3]] = 0;
      strcpy(image_info.name, name);

      r.r[0] = 256 + 40;
      r.r[1] = (int) sprite_area;
      r.r[2] = (int) image_info.name;
      _kernel_swi(OS_SpriteOp, &r, &r);
      image_info.width = r.r[3];
      image_info.height = r.r[4];
      image_info.mode = r.r[6];
  }
  return err;
}

// object functions
// 
/***************************************************************************************************/
// this function draws a rectangle then plots text over it text_alignment aligned.
// for font paint see 3-429
_kernel_oserror*
graphics::display_text(const char *text, text_alignment align, box border, int box_col, int font_col)
{
	_kernel_oserror *err = NULL;
	char* tmp_string;
	
	tmp_string = new char[strlen(text)+1];
	
	if (tmp_string == NULL){
	  	err = makeError(EM_Alloc);
	} else {
		int width, height, start_x, start_y;
		
		 /* includes a 5% margin */
		int margin = (border.x1-border.x0)/20;
		
		int co_ord[5], width_milli;
		char *ptr = NULL;
		
	  	strcpy(tmp_string, text);
	  	
	  	// determine the cut-off for strings that are too long.
	  	co_ord[0] = 0; // there is no need to specify where it is being displayed we are only interested
	  	co_ord[1] = 0; // in the width.
	  	co_ord[2] = 0;
	  	co_ord[3] = 0;
	  	co_ord[4] = -1;	// cut-off character if available.
	  	
	  	_swi(Font_Converttopoints, _IN(1)|_OUT(1), (border.x1-border.x0) - margin*2, &width_milli);
	  	
	  	err = _swix(Font_ScanString, _INR(0,5)|_OUT(1)|_OUT(3), fonthandle, tmp_string, 0x20, width_milli, 0x7fffffff, co_ord, &ptr, &width);
	  	
	  	(*ptr) = '\0';

		_swi(Font_ConverttoOS, _IN(1)|_OUT(1), width, &width);
  			  		  	
		// the height is defined by the font size.
  		height = font_size << y_eig; // graphic variables

 		if (err == NULL) err = draw_full_box(border.x0, border.y0, border.x1, border.y1, box_col);
	
    		// calculate the relative position
    		if (align == align_centre)
      			start_x = border.x0 + (((border.x1 - border.x0) / 2) - (width / 2));
		else 
		if (align == align_right)
      			start_x = border.x1 - margin - width;
      		else
      		if (align == align_left)
      			start_x = border.x0 + margin; 

 	   	start_y = (border.y0 + ((border.y1 - border.y0) / 2)) - (height / 2);
    	 	
    		if ((fonthandle != 0)&&(err == NULL))
   			_swix(ColourTrans_SetFontColours, _INR(0,3), 0, box_col, font_col, 14);
    	
    		if (err == NULL) err = _swix(Font_Paint, _INR(0,5), fonthandle, tmp_string, 0x0110, start_x, start_y, NULL);
    	
#ifndef RiscPC_Test    // anti twitter the box again
  		if (err == NULL) err = _swix(NH_AntiTwitter, _INR(0,3), border.x0, border.y0-twitter_border,
  						border.x1-border.x0, (border.y1-border.y0)+(twitter_border<<1));
#endif  						
  	}
    return err;
}

_kernel_oserror*
graphics::draw_full_box(int xbl, int ybl, int xtr, int ytr, int col)
{
  _kernel_oserror *err;
  int colnum;
  
  // determine the colour
  err =  _swix(ColourTrans_ReturnColourNumber, _IN(0)|_OUT(0), col, &colnum);
  if (err == NULL) err = _swix(OS_SetColour, _INR(0,1), 0, colnum);
  
  // paint the box
  if (err == NULL) err = _swix(OS_Plot, _INR(0,2), 4, xbl, ybl);

  if (err == NULL) err = _swix(OS_Plot, _INR(0,2), 4, xbl, ytr);

  if (err == NULL) err = _swix(OS_Plot, _INR(0,2), 85, xtr, ybl);

  if (err == NULL) err = _swix(OS_Plot, _INR(0,2), 85, xtr, ytr);
  
  return(err);
}

/*************************************************************************/
// public methods
// MENU draw functions
//
_kernel_oserror*
graphics::drawWindow(void)
{
  	_kernel_oserror* err = NULL;
  	
	// clear the screen
  	err = draw_full_box(0,0,window_width, window_height, col_background);

	// draw the sprite
  	if (err == NULL) err = plot_sprite_translated(safe_area.x1 - (sprite_x + sprite_width), safe_area.y0 + sprite_y);
  	
#ifndef RiscPC_Test  	// anti twitter the sprite
  	if (err == NULL) err = _swix(NH_AntiTwitter, _INR(0,3), window_width - sprite_x, sprite_y, sprite_width, sprite_height);
#endif  	
  	// draw the top strip
  	if (err == NULL) err = draw_full_box(0, window_height - height_topstrip, window_width, window_height, col_orange);

  	return err;
}

_kernel_oserror*
graphics::drawMenuElement(boolean selected, int row, char *text, char *text2)
{
	_kernel_oserror* err = NULL;

   	box panel;
   	
   	// calculate the row position, y1 & y0 of the menu element strip.
   	// this is the window height - strip height - half an element height spacing.
   	panel.y1 = TOP_OF_TOP_ELEMENT - (row * eleheight);
   	panel.y0 = TOP_OF_TOP_ELEMENT - ((row+1)*eleheight);
  	
  	// clear the box
  	if (text2 == NULL) {
  		if (err == NULL) err = draw_full_box( COLUMN_1_LEFT, panel.y0, COLUMN_1_RIGHT, panel.y1,  col_background);
  	} else {
  		if (err == NULL) err = draw_full_box( COLUMN_1_LEFT, panel.y0, COLUMN_2_RIGHT, panel.y1,  col_background);
  	}
 
 	// set shrink the box by the border.
  	panel.y1 -= elembord;
  	panel.y0 += elembord;
  	  	
    	if (row < maxelem) {
    	  	// set the box position to reflect the primary column
    	  	panel.x0 = COLUMN_1_LEFT + elembord;
  	  	panel.x1 = COLUMN_1_RIGHT - elembord;
  	  	
  	  	if (selected != true)
 	  		err = display_text(text, align_left, panel, col_lightblue, col_offwhite);
 	  	else
 	  		err = display_text(text, align_left, panel, col_offwhite, col_lightblue);
  		
  		
  		if ((err == NULL)&&(text2 != NULL)){
  		  	// reflect the secondary column only if there is text to display in it.
    	  		panel.x0 = COLUMN_2_LEFT + elembord;
  	  		panel.x1 = COLUMN_2_RIGHT - elembord;
  	  	
  	  		if (selected != true)
 	  			err = display_text(text2, align_centre, panel, col_orange, col_offwhite);
 	  		else
 	  			err = display_text(text2, align_centre, panel, col_offwhite, col_orange);
  	  	}	
  	} 
  	else {
    		err = makeError(EM_TooManyElem);
    	}
  	return err;
}

_kernel_oserror*
graphics::drawCentredMenuElement(boolean selected, int row, char *text)
{
	_kernel_oserror* err = NULL;

   	box panel;
   	
   	// calculate the row position, y1 & y0 of the menu element strip.
   	// this is the window height - strip height - half an element height spacing.
   	panel.y1 = TOP_OF_TOP_ELEMENT - (row * eleheight);
   	panel.y0 = TOP_OF_TOP_ELEMENT - ((row+1)*eleheight);
  	
  	// clear the box
  	if (err == NULL) err = draw_full_box( COLUMN_C_LEFT, panel.y0, COLUMN_C_RIGHT, panel.y1,  col_background);
 
 	// set shrink the box by the border.
  	panel.y1 -= elembord;
  	panel.y0 += elembord;
  	  	
    	if (row < maxelem) {
    	  	// set the box position to reflect the primary column
    	  	panel.x0 = COLUMN_C_LEFT + elembord;
  	  	panel.x1 = COLUMN_C_RIGHT - elembord;
  	  	
  	  	if (selected != true)
 	  		err = display_text(text, align_centre, panel, col_lightblue, col_offwhite);
 	  	else
 	  		err = display_text(text, align_centre, panel, col_offwhite, col_lightblue);
  	} 
  	else {
    		err = makeError(EM_TooManyElem);
    	}
  	return err;
}

 _kernel_oserror*
 graphics::drawDialogue(char* text)
 {
   	_kernel_oserror* err = NULL;
 	box panel;
   	
     	panel.y1 = TOP_OF_TOP_ELEMENT - ((maxelem>>1) * eleheight);
   	panel.y0 = TOP_OF_TOP_ELEMENT - ( ((maxelem>>1)+1)*eleheight );
   	panel.x1 = window_width;
   	panel.x0 = 0;
 
   	err = drawWindow();
   	
   	if (err == NULL) err = display_text(text, align_centre, panel, col_background, col_offwhite);
   	
   	return err;
 }
 
 _kernel_oserror*
 graphics::drawError(char* errormess)
 {
   	_kernel_oserror* err = NULL;
 	box panel;
   	
     	panel.y1 = TOP_OF_TOP_ELEMENT - ((maxelem>>1) * eleheight);
   	panel.y0 = TOP_OF_TOP_ELEMENT - ( ((maxelem>>1)+1)*eleheight );
   	panel.x1 = window_width;
   	panel.x0 = 0;
 
   	err = drawWindow();
   	
   	if (err == NULL) err = display_text(errormess, align_centre, panel, col_background, col_offwhite);
   	
   	// draw button;
   	
   	return err;
 }
 
// constructors
graphics::graphics(const char* sprite_file)
{
  	error = NULL;
  	int screen_depth;
  	
	error = _swix(ModeFiles_SafeArea, _OUTR(0,3), &safe_area.x0, &safe_area.y0, &safe_area.x1, &safe_area.y1);
  
	// in a square pixel mode there are 2 os units per pixel
	if (error == NULL) error = _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 12, &window_height);
	if (error == NULL) error = _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 11, &window_width);
	
	window_height *= 2;	// pixels to os units
	window_width *= 2;
	
	debug("graphics", "safe area is, x0=%i, y0=%i, x1=%i, y1=%i\n", safe_area.x0, safe_area.y0, safe_area.x1, safe_area.y1);
	debug("graphics", "screen size %ix%i (hxw)\n", window_height, window_width);
  	
	if (error == NULL) error = _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 4, &x_eig);
	if (error == NULL) error = _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 5, &y_eig);
	if (error == NULL) error = _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 9, &screen_depth);
	
	bpp = 1 << screen_depth;

 	// set up the font to be used for graphics
  	if (error == NULL) error = _swix(Font_FindFont, _INR(1,5)|_OUT(0), "Homerton.Bold", font_size*16,  font_size*16, 0, 0, &fonthandle);
  	
  	if (error == NULL) error = load_sprite(sprite_file); 
}

graphics::~graphics()
{
  	_swi(Font_LoseFont, _IN(0), fonthandle);	
}
