/****************************************************************************/
//   	Filename:	menuheirarchy.h
//	Author:		Alistair Rodger
//	Spec:		DO 2501,833/FS
//
// © Pace Micro Technology Ltd
//
//	Description:
//	This is the major container class.  It holds a list of all of the
//	menu elements.  It also ownes the viewer element.
//
// History:
//
// Date      Who	Description of change
// ===========================================
// 08/10/99  AR		File created
/****************************************************************************/

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#include "menuhier.h"

/****************************************************************************/
// class menuHierarchy : public ParentObject
// constructor this takes a filename and loads it it then parses it one line
// at a time to create a linked list of objects.


menuHierarchy::menuHierarchy(char *sprite_file)
{
  graphic = new graphics(sprite_file);
  
  current = NULL;
  
  menu_pool = NULL;
  
  if (graphic != NULL)
  	error = graphic->getError();
  else
  	error = makeError(EM_Alloc);
}

menuHierarchy::~menuHierarchy()
{
  error = NULL; 
  
  current = NULL;
  
  delete graphic; graphic = NULL;
 
  delete menu_pool; menu_pool = NULL; // this will chain
 }

_kernel_oserror*
menuHierarchy::handleKey(int key)
{ 
	if (current != NULL) {
	
		error = current->handleKey(key, graphic);
		
	} else {
	  
		error = makeError(EM_ObjectError);
		
	}
	return error;
}

_kernel_oserror*
menuHierarchy::change_menu(void *menu)
{
  	// we could put checking in here to ensure valid address but
  	// for speed reasons I have not done this.
  	// thought for debug reasons though it might be useful
#ifdef DEBUGLIB
	menuObject *tmp = menu_pool;
	
	while (tmp != NULL){
	  	if ((void*)tmp == menu)	break;
	  	tmp = tmp->chain;
	}
	
	if (tmp == NULL){
		debug("", "change menu passed a non menu");
		return makeError(EM_ObjectError);
	}
#endif  	
  	
  	menuObject* new_current = (menuObject*)menu;
  	// lay bread crumbs
  	new_current->setPrev(current);
  	
  	current = new_current;
  	// draw the new menu
  	return current->drawMenu(graphic);
}

_kernel_oserror*
menuHierarchy::back_menu()
{
#ifdef DEBUGLIB
	menuObject *tmp = menu_pool;
	
	while (tmp != NULL){
	  	if (tmp == current->getPreviousMenu())	break;
	  	tmp = tmp->chain;
	}
	
	if (tmp == NULL){
		debug("", "back menu found non menu in previous");
		return makeError(EM_ObjectError);
	}
#endif  	
 	menuObject* new_current = current->getPreviousMenu();
  	
  	if (new_current != NULL){
  		current = new_current;
  		return current->drawMenu(graphic);
  	}
  	return (error = makeError(EM_ObjectError));
}

_kernel_oserror*
menuHierarchy::draw(void)
{
  	 if (error == NULL) {	
  	 	if ((menu_pool == NULL)||(current == NULL)){
  	 	  	error = makeError(EM_ObjectError);
  	 	} else {
	  		current->drawMenu(graphic);
    		}
    	 }

	return error;
}

void
menuHierarchy::operator = (Parser& file_parser)
{
     menu_pool = file_parser.getMenuPool();
     
     error = file_parser.getError();
     
     if ((error == NULL)&&((current = menu_pool) == NULL)){
     	error = makeError(EM_ObjectError);
     }
     
}
