/*
 ----------------------------------------------------------------------------
  Copyright [1999] Pace Micro Technology PLC.  All rights reserved.
  
  The copyright in this material is owned by Pace Micro Technology PLC
  ("Pace").  This material is regarded as a highly confidential trade secret
  of Pace.  It may not be reproduced, used, sold or in any other way exploited
  or transferred to any third party without the prior written permission of
  Pace.
  ----------------------------------------------------------------------------
*/

#include "main.h"

// for getting interface information
#include "sys/dcistructs.h"

#include "menuhier.h"

menuHierarchy* menus_ptr = NULL;
boolean do_continue = false;
_kernel_oserror* error = NULL;

_kernel_oserror* getKey(int* key, boolean* success){
  
  	_kernel_oserror* err = NULL;
  	
  	int r2 = 0;
  	
  	err = _swix(OS_Byte, _INR(0,2)|_OUTR(1,2), 129, 0xFF, 0, key, &r2);
  	
  	(*key) = (*key) & 0xFF;
  	
  	(*success) = (r2 == 0) ? true : false ;
  	  	
  	return err;
}

_kernel_oserror* change_menu(void *menu)
{
  	if (menus_ptr != NULL){
  	  	menus_ptr->debug("functions", "fn change menu\n");
  		return menus_ptr->change_menu(menu);
  	} else {
  		return NULL;
  	}
}

// MFUNC functions
_kernel_oserror* back_menu(void) {
  	if (menus_ptr != NULL){
  	  	menus_ptr->debug("functions", "fn back\n");
  		return menus_ptr->back_menu();
  	} else {
  		return NULL;
  	}
}

_kernel_oserror* save(void)
{
  	if (menus_ptr != NULL){
  	  	menus_ptr->debug("functions", "fn save\n");
  	  	return menus_ptr->save();
  	} else {
  	    	return NULL;
  	}
}

_kernel_oserror* terminate(void)
{
  	if (menus_ptr != NULL)
  	  	menus_ptr->debug("functions", "fn terminate\n");
  	  	
  	do_continue = false;
  	return NULL;
}

_kernel_oserror* reset_nvram(void)
{
  	// this reads the checksum and writes ~checksum to that value.
  	// the location of the checksum is a byte at 0xEF in the NVRAM.
  	// this uses OS_Bytes so as not to alert the NVRAM module that
  	// it is corrupting its checksum.  We then reboot the NVRAM will
  	// reset its values to default because the checksum is incorrect.
  	
  	int checksum;
  	_kernel_oserror* err = NULL;
  	
  	err = _swix(OS_Byte, _INR(0,1)|_OUT(2), 161, 0xEF, &checksum);
  	
  	if (err == NULL) {
  	  	checksum = 0xFF & (~checksum);
  	  	
  	  	err = _swix(OS_Byte, _INR(0,2), 162, 0xEF, checksum);
  	  	
  	  	if (err == NULL){
  	  	  	err = terminate();
  	  	}
  	}
  	
  	return err;  	
}

// DESC functions
// MAX_MSG_LEN is defined in the messages file
static char fn_string[MAX_MSG_LEN];

char *moduleVersion(int margc, char* margv[])
{
  	if (margc == 1){
  	  	char* location = NULL;
  	  	char * help_string;
  	  	int offset;
  	  	
  	  	error = _swix(OS_Module, _INR(0,1)|_OUT(3), 18, margv[0], &location);
  	  	
  	  	if ((error == NULL)&&(location != NULL)){
  	  	  	offset = (*(location + 0x14)); 		// go to the help string;
  	  	  	help_string = (location + offset); 	// de-reference the pointer to the help string
  	  	  	
  	  	  	// the following algorithm is taken from the system so if a string fails here
  	  	  	// it will fail when comparing (i.e rmensure)
  	  	  	// this is with the exception of the early termination on the close bracket
  	  	  	
  	  	  	if (offset != 0){ // if there is a string
  	  	  	
    				int r0 = 0, r5 = 0;	// string offset and count, not the same
    				char r1;
    				boolean parse_error = false;
    
    				do
    				{
    				  	r1 = help_string[r0++];
      					if (r1 == '\0'){
      					  	parse_error = true;
      					  	break;
      					}
      					r5++;
      					if (r1 == 9) // if tab
          					r5 = (r5+7)&~7;          				
    				}
    				while (r5 < 16);
  	  	  		
  	  	  		help_string += r0;
  	  	  	  
  	  	  	  	if (parse_error == false) {
  	  	  	  	  
  	  	  	  	  	while (!isdigit(*help_string)){
  	  	  	  	  		//control characters
  	  	  	  	  	  	if ( (*help_string != 9)&&((int)(*help_string) < 31) )
  	  	  	  	  	  	{
      					  		parse_error = true;
      					  		break;
      						} else {
  	  	  					help_string++;
  	  	  				}
  	  	  			}
  	  	  			
  	  	  			if (parse_error == false){
  	  	  			  	menus_ptr->debug("functions", "version number (%s) isolated string (%s)\n", margv[0], help_string);
  	  	  			  	r0 = 0;
  	  	  			  	do 
  	  	  			  	{
  	  	  			  	  	fn_string[r0] = help_string[r0];
  	  	  			  	}
  	  	  			  	while (((r0+1) < MAX_MSG_LEN)&&(help_string[r0] != '\0')&&(help_string[r0] != ')')&&(++r0));
  	  	  			  	fn_string[++r0] = '\0';
  	  	  			}
  	  	  	  	}
  	  	  		
  	  	  		if (parse_error == true)
  	  	  			error = menus_ptr->lookupMessage(MSG_Unknown, fn_string, MAX_MSG_LEN);
  	  	  			
  	  	  	} else {
  	  	  	  	error = menus_ptr->lookupMessage(MSG_Unknown, fn_string, MAX_MSG_LEN);
  	  	  	}
  	  	} else {
  	  	  	if (error == NULL) error = menus_ptr->makeError(EM_ObjectError);
  	  	}
  	} else {
  	  	error = menus_ptr->makeError(EM_ObjectError);
  	}
  	
  	if (error != NULL)
  		terminate();
  		
  	return (fn_string);
}

char *dciInfo(int margc, char* margv[])
{
  	//return parameters;
	IGNORE(margc);
	IGNORE(margv);
	
	chaindib *list = NULL;
	boolean found = false;
	
	error = _swix(OS_ServiceCall, _INR(0,1)|_OUT(0), list, Service_EnumerateNetworkDrivers, &list);
	
	if (error == NULL){
		chaindib* next = NULL;
		
		while (list != NULL){
		  	// examine
		  	menus_ptr->debug("functions", "list->flags (%8.8X)\n", list->chd_dib->dib_inquire);
		  	if ((found == false)&&(list->chd_dib->dib_inquire & INQ_HWADDRVALID)){
		  	  	found = true;
		  	  	// mess with the dib address;
		  	  	sprintf(fn_string, "%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X", 
		  	  		list->chd_dib->dib_address[0], list->chd_dib->dib_address[1], list->chd_dib->dib_address[2],
		  	  		list->chd_dib->dib_address[3], list->chd_dib->dib_address[4], list->chd_dib->dib_address[5]);
		  	}
		  	
		  	// delete list element, we don't delete the dib block as it is static.
		  	next = list->chd_next;
		  	error = _swix(OS_Module, _IN(0)|_IN(2), 7, list);
		  	list = next;
		}
	}
	
	if (found == false)
  	  	  error = menus_ptr->lookupMessage(MSG_Unknown, fn_string, MAX_MSG_LEN);

  	if (error != NULL)
  		terminate();
   	  	  	
	return (fn_string);
}

//LIST FUNCTIONS
_kernel_oserror*
addListElement(list_choice** list, char* element, int value)
{
  	_kernel_oserror *error = NULL;
  
  	list_choice *tmp, *tmp2;
  	
	tmp = new list_choice;
  	
  	if (tmp != NULL){
  	  
  		tmp->choice = element;
  		tmp->value = value;
  		
  		if ((*list) == NULL){
  		  	// tmp is the only element in the loop
  		  	// and choices must point to it.
  		  	tmp->next = tmp->prev = (*list) = tmp;
  		} else {
  		  	// tmp2 may be equal to choices, we are going
  		  	// to insert tmp between tmp2 and choices.
  			tmp2 = (list_choice*)(*list)->next;
  			tmp2->prev = tmp; tmp->next = tmp2;
  			(*list)->next = tmp; tmp->prev = (*list);
  		}
  	} else {
  	  
  	  	if (error == NULL) error = menus_ptr->makeError(EM_Alloc);
  	}
  	
  	return error;
}

_kernel_oserror* list_tv_standards(list_choice** list)
{
  _kernel_oserror* err = NULL;
  
  TV_Standard_struct *standards;

  	// call the DENCdriver to get the list.
  	err = _swix(Macrovision_PlatformFeatures, _IN(0)|_OUT(1), &standards);
  	
  	if (err == NULL){
  	  	int i = 0;
  	  	
  	  	// while not NULL word terminated
  	  	while ((((int)standards[i].TVStandard) != NULL)&&(err == NULL)){
  	  	  	
  	  	  	char *tmp = new char[12];
  	  	  	
  	  	  	if (tmp == NULL) {
  	  	  		err = menus_ptr->makeError(EM_Alloc);
  	  	  	} else {
  	  	  	  	
  	  	  	  	strncpy(tmp, standards[i].TVStandard, 12);
  	  	  	
  	  	  		err = addListElement(list, tmp, standards[i].NVRAM_value);
  	  	  	}
  	  	}
  	}
  	
  	return err;
}

_kernel_oserror* list_tv_channels(list_choice** list)
{
   _kernel_oserror* err = NULL;
  
   const char* tvStandard_tag = "TVStandard";
  
   TV_Standard_struct   *standards;
   TV_Channel_Returnable *channels;
   
   int standard = 0, length = 0, channel_offset = -1;

	  	
	if (err == NULL) err = _swix(NVRAM_Read, _INR(0,2)|_OUT(0), tvStandard_tag, &standard, 0, &length);
	
	if ((err == NULL)&&(length < 0)) {
	  	err = menus_ptr->makeError(EM_NVRead, tvStandard_tag);
	}
	
	// get the TVChannels offset
	if (err == NULL) {

  		// call the DENCdriver to get the standards list.
  		err = _swix(Macrovision_PlatformFeatures, _IN(1)|_OUT(1), 0, &standards);
  	
  		if (err == NULL){
  	  		int i = 0;
  	  	
  	  		// while not NULL word terminated
  	  		while ((((int)standards[i].TVStandard) != NULL)&&(err == NULL)){
  	  	  		if (standards[i].NVRAM_value == standard){
  	  	  		  	channel_offset = standards[i].TVChannels_offset;
  	  	  		  	break;
  	  	  		}
  	  	  	}
  	  	}
  	  	
	  	// get the channels for the configured standard.
  	  	if ((channel_offset != -1)&&(error == NULL)){
  	  	  	  
  	  	  	err = _swix(Macrovision_PlatformFeatures, _INR(0,1)|_OUT(2), 1, channel_offset, &channels);
  	  	  	  	
  	  	  	if (err == NULL){
  				int i = 0;
  				// while not NULL word terminated
  	  			while ((i < channels->channel_count)&&(err == NULL)){
  	  	  	
  	  	  			char *tmp = new char[5];
  	  	  	
  	  	  			if (tmp == NULL) {
  	  	  				err = menus_ptr->makeError(EM_Alloc);
  	  	  			} else {
  	  	  			  	tmp[4] = '\0';
  	  	  	  			strncpy(tmp, channels->channels[i].TVChannel, 4);
  	  	  	
  	  	  				err = addListElement(list, tmp, channels->channels[i].NVRAM_value);
  	  	  			}
  	  	  		}
  	  	  	}
  	  	}
  	}
  	
  	return err;
}
//-------------------------------------------------------------------------------- tables of functions ------

// management functions
manage_fn_table management_functions[] = {
  "exit", terminate,
  "reset", reset_nvram,
  "back", back_menu,
  "save", save
};
static int no_of_management_functions = 4;

// functions that return strings
string_fn_table string_functions[] = {
  "moduleVersion", moduleVersion,
  "macAddress", dciInfo
};
static int no_of_string_functions = 2;

list_fn_table list_functions[] = {
  "getTVStandards", list_tv_standards,
  "getTVChannels", list_tv_channels
};
static int no_of_list_functions = 2;
//-------------------------------------------------------------------------------- Lookup functions ------


string_fn_ptr lookup_string_function(char *token, _kernel_oserror** err)
{
  	if ((*err) == NULL){
  	  	int function = no_of_string_functions -1;
  	  	while (function >= 0){
  	  	  if (strcmp(token, string_functions[function].token) == 0)
  			return string_functions[function].function;
  		  function--;
  		}
  	}
  	
  	(*err) = menus_ptr->makeError(EM_BadFnCall, token);
  	
  	return dciInfo;	// I am returning an arbitrary function here to protect against de-referencing
  			// I appreciate that it is not necessary but a nice safty net incase, I or somebody
  			// adding to the code does not check for errors and null functions before de-referencing.
}

manage_fn_ptr lookup_management_function(char *token, _kernel_oserror** err)
{
  	if ((*err) == NULL){
  	  	int function = no_of_management_functions -1;
  	  	while (function >= 0){
  	  	  if (strcmp(token, management_functions[function].token) == 0)
  			return management_functions[function].function;
  		  function--;
  		}
  	}
  	(*err) = menus_ptr->makeError(EM_BadFnCall, token);
  	
  	return terminate;
}

list_fn_ptr lookup_list_function(char *token, _kernel_oserror** err)
{
  	if ((*err) == NULL){
  	  	int function = no_of_list_functions -1;
  	  	while (function >= 0){
  	  	  if (strcmp(token, list_functions[function].token) == 0)
  			return list_functions[function].function;
  		  function--;
  		}
  	}
  	(*err) = menus_ptr->makeError(EM_BadFnCall, token);
  	
  	return list_tv_standards;
}



//-------------------------------------------------------------------------------- MAIN ------------------
#define task_name "EngMenu"

// command line is: !EngMenu Config Sprite Messages

int main(int argc, char* argv[])
{
  	int key;
  	
  	_swi(OS_Byte, _INR(0,1)|_OUT(1), 121, 0, &key);
  	
#ifndef DEBUGLIB
  	if (key == select_key_button_number) {
#else  	  
  	if (1) {
#endif  	  
  		if (argc == 4) {
  			int escape_cond = 0x01;
  		  	_swi(OS_Byte, _INR(0,2)|_OUT(1), 200, escape_cond, 0, &escape_cond);
  	  
                   	_kernel_oserror *err = NULL; 
                   	// initialise everything    
                   	MessageFile messagefile(task_name, &err, argv[3]);
               
                	if (err == NULL) {
                	  	do_continue = true;
                	  	
                	  	graphics window(argv[2]);
                	  	
                	  	if ((err = window.getError()) == NULL) {
                	  	  
                        	  	boolean got_key = false;
                	  	
                        	  	menuHierarchy menus(&window);
                        	  	
                        	  	if ((err == NULL)&&((err = menus.getError()) == NULL)){
                                        
                               			Parser file_parse(argv[1]);
                               	
                               			menus = file_parse; // assign the parsed file to the menu structure
                               			
                               			if ((err = file_parse.getError()) == NULL)
                               				err = menus.draw(); // this acts as get error also
#ifdef DEBUGLIB                               			
                               			if (err != NULL)
                               				menus.debug("functions", "error = %s\n", err->errmess);
                               			else
                               				menus.debug("functions", "error = NULL\n");
#endif                               				
                               		}
                        	  	
                        	  	if ((err == NULL)&&((err = menus.getError()) == NULL)){
                        	  	
                        	  		menus_ptr = &menus;
                        	  		  
						// wait for the select key to be released	
                        	  		while (key == select_key_button_number)
                        	  			_swi(OS_Byte, _INR(0,1)|_OUT(1), 121, 0, &key);
  	
                        	  		// flush the buffer
                        	  		while (got_key == true)
                        	  			err = getKey(&key, &got_key);
#ifdef DEBUGLIB
						menus_ptr->debug("", "entering big time\n");
#endif                        	  			
                        	  		// loop to go.
                               			while ((err == NULL)&&(do_continue == true)){
                               		     	
                                       			//key = bbc_get();
                                       			err = getKey(&key, &got_key);
                                       		                            
							if ( (err == NULL)&&(got_key == true) ) {
							  			
                            					err = menus.handleKey(key);
                            				}
                            			
                               			}// loop
                       		        } else {
                        	  		  
						// wait for the select key to be released	
                        	  		while (key == select_key_button_number)
                        	  			_swi(OS_Byte, _INR(0,1)|_OUT(1), 121, 0, &key);
                        	  			
                       		        	// flush the buffer
                        	  		while (got_key == true)
                        	  			err = getKey(&key, &got_key);
                        	  	}
                        	  	
                       		        // check the local error
                       			if (err != NULL) {
                       			  	// error creating
                       			  	window.drawError(err);
                       			  	
                       			  	key = 0;
                       			  	
                       			  	while (key != key_select) {
                        	  			getKey(&key, &got_key);
                        	  			if (got_key == false)
                        	  				key = 0;
                       			  	}
                       	      		}
                       	      		// check the global error
                       			if (error != NULL) {
                       			  	// error creating
                       			  	window.drawError(error);
                       			  	
                       			  	key = 0;
                       			  	
                       			  	while (key != key_select) {
                        	  			getKey(&key, &got_key);
                        	  			if (got_key == false)
                        	  				key = 0;
                       			  	}
                       	      		}
                       	        } else { // cannot allocate graphics
                       	          	printf("%s, %s", task_name, err->errmess);
                       	        }
                       	        
                	}
                    
                   	// this is nearly useless as it is not a wimp task but it is a useful practice.
                   	if (err != NULL)
                          _swi(Wimp_ReportError, _INR(0,2), err, 0x19, task_name);
                
  		  	_swi(OS_Byte, _INR(0,2)|_OUT(1), 200, escape_cond, 0xFF, &escape_cond);          
          	}
#ifndef DEBUGLIB
	// reset is the only way out.
	_swi(OS_Reset, _IN(0), 0);
#endif                   
        }// select key not held down
}
