#include "menu.h"
#include "main.h"
#include "string.h"

/****************************************************************************/
//class menuObject : public ParentObject

_kernel_oserror*
menuObject::saveOptions()
{
  	int i=0;
 	while ( (i < elements) && (error != NULL) ){
  		if (element[i] != NULL)
  			error = element[i++]->saveOption();
  	}

  	return error;
}

_kernel_oserror*
menuObject::handleKey(int key, graphics* graphic)
{
 	int old_selection = selected;
  	
 	// if key == key_up || key_down change selection
  	switch (key) {
  		case key_up:
  			if (selected == 0)
  	  			selected = elements-1;
  	  		else
  	  			selected--;
  	  		element[old_selection]->redraw(graphic, false, centred);
  	  		element[selected]->redraw(graphic, true, centred);
  	  		break;
  	  		
  	  	case key_down:
  			if (selected == elements-1)
  	  			selected = 0;
  	  		else
  	  			selected++;

  	  		element[old_selection]->redraw(graphic, false, centred);
  	  		element[selected]->redraw(graphic, true, centred);
  	  		break;
  	  		
  	  	default:
  	  		if (element[selected] != NULL)
  				error = element[selected]->handleKey(key, graphic);
        }
   	return error;
}
  	
_kernel_oserror*
menuObject::drawMenu(graphics* graphic)
{
  	error = graphic->drawWindow();
  	
  	// draw all of the elements in the menu
   	int i = 0;
 	while ((i < elements)&&(error == NULL)){
  		if (element[i] != NULL)
  			error = element[i]->redraw(graphic, ((i==selected)?true:false), centred);
  		i++;
  	}
  	return error;
}
 
_kernel_oserror*
menuObject::addElement(menuElement* ele)
{
  	if (elements == (MAX_elements-1))
  		error = makeError(EM_TooManyElem);
  	else {
  	  	ele->element = elements;
   		element[elements++] = ele;
  	}
  	
  	return error;
}

menuObject::menuObject(char* n_tag, char* desc)
{
 	error = NULL;
  	previous = NULL;
 	selected = 0;
   	tag = NULL;
  	desc_string = NULL;
 	centred = true;
 	elements = 0;
  	chain = NULL;
  	
  	for (int i = 0; i < MAX_elements; i++) element[i] = NULL;
   	
  	tag = new char[strlen(n_tag)+1];
 
  	if (tag==NULL)
  		error = makeError(EM_Alloc);
  	else{ 
  		desc_string = new char[strlen(desc)+1];
  		if (desc_string == NULL)
  			error = makeError(EM_Alloc);
  		else {
  		  	strcpy(tag, n_tag);
  		  	strcpy(desc_string, desc);
  		}
 	}
}

menuObject::~menuObject()
{
  	for (int i = 0; i < elements; i++){
  	  	if (element[i] != NULL) {
   	  		delete element[i];
  	  		element[i] = NULL;
  	  	}
  	}
  	
  	delete tag; tag = NULL;
  	delete desc_string; desc_string = NULL;
  	error = NULL;	// we don't allocate we don't delete
  	delete chain; chain = NULL;
}

/****************************************************************************/
//class SUBMENU : public menuElement

_kernel_oserror*
SUBMENU::handleKey(int key, graphics*)
{
  	if (key == key_select)
  		error = change_menu((void*) link);
  		
  	return error;
}
  	 
_kernel_oserror*
SUBMENU::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	if (centred == true)
  		return error = graphic->drawCentredMenuElement(selected, element, link->getDescString());
  	else
  		return error = graphic->drawMenuElement(selected, element, link->getDescString());
}
  	 
SUBMENU::SUBMENU(menuObject *n_link)
{
  	link = n_link;
  	debug("", "SUBMENU for %s\n", link->getDescString());
};

SUBMENU::~SUBMENU()
{
  	link = NULL; // this is freed in the menu hierarchy object
}

/****************************************************************************/
//class NVRAM : public menuElement
 
choiceContainer::choiceContainer(char* n_choice, int n_value)
{
  	choice = new char[strlen(n_choice)+1];
  	
  	if (choice != NULL){
  		strcpy(choice, n_choice);
  	}
  	
  	value = n_value;
  	next = NULL;
  	prev = NULL;
}	

choiceContainer::~choiceContainer()
{
  	next = NULL;
  	prev = NULL;
  	delete choice; choice = NULL;
}
 
NVRAM::NVRAM(char* n_desc, char* n_tag)
{
  
  	desc = n_desc;
  	tag = n_tag;
  	  	  	
  	debug("", "NVRAM %s tag %s\n", desc, tag);
}

NVRAM::~NVRAM()
{  	
  	delete desc;
  	delete tag;
}


listNVRAM::~listNVRAM()
{
  	choiceContainer *tmp1, *tmp2;
  	
  	tmp2 = choices->next;
  	
  	while (tmp2 != choices){
  	  	tmp1 = tmp2;
  	  	tmp2 = tmp2->next;
  	  	delete tmp1;
  	}
  	
  	delete choices; choices = NULL;
}

_kernel_oserror*
listNVRAM::addChoice(choiceContainer* n_choice)
{
  if (n_choice != NULL){
    	 // if first choice
    	if (choices == NULL){
    		choices = n_choice;
    		n_choice->next = n_choice;
    		n_choice->prev = n_choice;
    	} else {
    	  	choiceContainer* c_next = choices->next;
     		    	  
    	  	c_next->prev = n_choice;
    	  	n_choice->next = c_next;
 
    	  	choices->next = n_choice;
    	  	n_choice->prev = choices;
    	}
    	return NULL;
  } else 
  	return makeError(EM_Alloc);
}

_kernel_oserror*
listNVRAM::handleKey(int key, graphics* graphic)
{
  	if (choices != NULL) {
  		switch (key) {
  			case key_right:
  				choices = choices->next;
  				error = redraw(graphic, true, false);
  				break;
  			case key_left:
  				choices = choices->prev;
  				error = redraw(graphic, true, false);
  				break;
  		}
  	}
  	return error;
}

_kernel_oserror*
listNVRAM::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	IGNORE(centred);
  	
  	char* stg = ((choices == NULL) ? NULL: choices->choice);
  	
 	return error = graphic->drawMenuElement(selected, element, desc, stg);
}

_kernel_oserror*
listNVRAM::saveOption()
{
  	// call nvram with tag and value;
  	return error;
}

_kernel_oserror*
listNVRAM::addList(char* element, int value)
{
  	choiceContainer* tmp = new choiceContainer(element, value);
  	return addChoice( tmp );
}

/****************************************************************************/
//class  rangeNVRAM : public NVRAM
rangeNVRAM::rangeNVRAM(char* n_desc, char* n_tag, int min, int max, int gran):NVRAM(n_desc, n_tag)
{
  	minimum = min;
  	maximum = max;
  	current = min; // NVRAM get value
  	granularity = gran;
  	// range testing.
}

_kernel_oserror*
rangeNVRAM::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	IGNORE(centred);
  	
  	char string[24];	// the greatest unsigned integer length
  	
  	sprintf(string, "%i", current);
  	
  	return error = graphic->drawMenuElement(selected, element, desc, string);
}

_kernel_oserror*
rangeNVRAM::saveOption()
{
  	return NULL;
}

_kernel_oserror* 	
rangeNVRAM::handleKey(int key, graphics* graphic)
{
  	switch (key) {
  		case key_right:
  			current += granularity;
  			if (current > maximum)
  				current = maximum;
  			error = redraw(graphic, true, false);
  			break;
  		case key_left:
  			current -= granularity;
  			if (current < minimum)
  				current = minimum;
  			error = redraw(graphic, true, false);
  			break;
  	}
  	return error;
}

/****************************************************************************/
//class DESC : public menuElement
_kernel_oserror*
DESC::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	IGNORE(centred);
  	
	return error = graphic->drawMenuElement(selected, element, desc, (*string_fn)(parameters));
}
  	 
DESC::DESC(char* n_desc, char* token)
{
  desc = n_desc;
  parameters = NULL;
  string_fn = lookup_string_function(token, &error);
  
  delete token;
}

DESC::~DESC()
{
  	delete desc;
  	delete parameters;
  	string_fn = NULL;
}

 	
/****************************************************************************/
//class MFUNC : public menuElement
_kernel_oserror*
MFUNC::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	if (centred == true)
		return error = graphic->drawCentredMenuElement(selected, element, desc);
	else
		return error = graphic->drawMenuElement(selected, element, desc);
}

_kernel_oserror*
MFUNC::handleKey(int key, graphics*)
{
  	if (key == key_select)
  		error = (*manage_fn)();
		
  	return error;
}

MFUNC::MFUNC(char* n_desc, char* token, char* n_message)
{
  desc = n_desc;
  message = n_message;		// assign to none damaging function

  manage_fn = lookup_management_function(token, &error);
  
  delete token;
}

MFUNC::~MFUNC()
{
	delete desc;
	delete message;
	
}
