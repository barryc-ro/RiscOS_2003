#include "menu.h"
#include "main.h"
#include "string.h"
#include "ctype.h"

/****************************************************************************/
//class menuObject : public ParentObject

_kernel_oserror*
menuObject::saveOptions()
{
  	int i=0;

 	while ( (i < elements) && (error == NULL) ){
 	  
  		if (element[i] != NULL){
  			error = element[i]->saveOption();
  			error = element[i++]->getError();
  		}
  	}

  	return error;
}

_kernel_oserror*
menuObject::handleKey(int key, graphics* graphic)
{
 	int old_selection = selected;
 	boolean redraw = false;
  	
 	// if key == key_up || key_down change selection
  	switch (key) {
  		case key_up:
  			if (selected == 0)
  	  			selected = elements-1;
  	  		else
  	  			selected--;
  	  		element[old_selection]->redraw(graphic, false, centred);
  	  		element[selected]->redraw(graphic, true, centred);
  	  		break;
  	  		
  	  	case key_down:
  			if (selected == elements-1)
  	  			selected = 0;
  	  		else
  	  			selected++;

  	  		element[old_selection]->redraw(graphic, false, centred);
  	  		element[selected]->redraw(graphic, true, centred);
  	  		break;
  	  		
  	  	default:
  	  		if (element[selected] != NULL)
  				error = element[selected]->handleKey(key, graphic, &redraw);
        }
        
        if ((error == NULL)&&(redraw == true))
        	return (drawMenu(graphic));
        	
   	return error;
}
  	
_kernel_oserror*
menuObject::drawMenu(graphics* graphic)
{
  	error = graphic->reDrawWindow(elements);
  	
  	// draw all of the elements in the menu
   	int i = 0;
 	while ((i < elements)&&(error == NULL)){
  		if (element[i] != NULL)
  			error = element[i]->redraw(graphic, ((i==selected)?true:false), centred);
  		i++;
  	}
  	return error;
}
 
_kernel_oserror*
menuObject::addElement(menuElement* ele)
{
  	if (elements == MAX_elements)
  		error = makeError(EM_TooManyElem);
  	else {
  	  	ele->element = elements;
   		element[elements] = ele;
   		elements++;
  	}
  	
  	return error;
}

menuObject::menuObject(char* n_tag, char* desc)
{
 	error = NULL;
  	previous = NULL;
 	selected = 0;
   	tag = NULL;
  	desc_string = NULL;
 	centred = true;
 	elements = 0;
  	chain = NULL;
  	
  	tag = n_tag;
  	desc_string = desc;
  	
  	for (int i = 0; i < MAX_elements; i++) element[i] = NULL;
}

menuObject::~menuObject()
{
  	for (int i = 0; i < elements; i++){
  	  	if (element[i] != NULL) {
   	  		delete element[i];
  	  		element[i] = NULL;
  	  	}
  	}
  	
  	delete tag; tag = NULL;
  	delete desc_string; desc_string = NULL;
  	error = NULL;	// we don't allocate we don't delete
  	delete chain; chain = NULL;
}

/****************************************************************************/
//class SUBMENU : public menuElement

_kernel_oserror*
SUBMENU::handleKey(int key, graphics*, boolean*)
{
  	if (key == key_select)
  		error = change_menu((void*) link);
  		
  	return error;
}
  	 
_kernel_oserror*
SUBMENU::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	if (centred == true)
  		return error = graphic->drawCentredMenuElement(selected, element, link->getDescString());
  	else
  		return error = graphic->drawMenuElement(selected, element, link->getDescString());
}
  	 
SUBMENU::SUBMENU(menuObject *n_link)
{
  	link = n_link;
  	debug("", "SUBMENU for %s\n", link->getDescString());
};

SUBMENU::~SUBMENU()
{
  	link = NULL; // this is freed in the menu hierarchy object
}

/****************************************************************************/
//class NVRAM : public menuElement
 
choiceContainer::choiceContainer(char* n_choice, int n_value)
{
  	choice = new char[strlen(n_choice)+1];
  	
  	if (choice != NULL){
  		strcpy(choice, n_choice);
  	}
  	
  	value = n_value;
  	next = NULL;
  	prev = NULL;
}	

choiceContainer::~choiceContainer()
{
  	next = NULL;
  	prev = NULL;
  	delete choice; choice = NULL;
}
 
NVRAM::NVRAM(char* n_desc, char* n_tag)
{
  
  	desc = n_desc;
  	tag = n_tag;
  	
  	if ((tag==NULL)||(desc== NULL))
  		error = makeError(EM_ObjectError);
#ifdef DEBUGLIB  	  	  	
  	debug("", "NVRAM %s tag %s\n", desc, tag);
#endif  	
}

NVRAM::~NVRAM()
{  	
  	delete desc;
  	delete tag;
}

int
NVRAM::getLength()
{
  	int length = 0;
  	
  	error = _swix(NVRAM_Read, _INR(0,2), _OUT(0), tag, 0, 0, &length);
  
  	if (length < 0) {
  		error = makeError(EM_NVRead);
  		length = 0;
  	}
  	
  	return length;
}

boolean
NVRAM::getValue(char* buffer)
{
  	int length = 0;
  	
  	error = _swix(NVRAM_Read, _INR(0,2), _OUT(0), tag, buffer, 0, &length);
  	
  	debug("", "get value (%s) return value is %i\n", tag, length);
  		
  	if (length < 0) {
  		error = makeError(EM_NVRead);
  		length = 0;
  	}
  	
  	return (error == NULL)? true:false;
}

boolean
NVRAM::setValue(char* buffer)
{
  	int length = 0;
  	
  	error = _swix(NVRAM_Write, _INR(0,2), _OUT(0), tag, buffer, 0, &length);
  	
  	if (length < 0) {
  		error = makeError(EM_NVWrite);
  		length = 0;
  	}
  	
  	return (error == NULL)? true:false;
}
  	
listNVRAM::listNVRAM(char* n_desc, char* n_tag):NVRAM(n_desc, n_tag)
{ 
	choices = NULL;
	getValue((char*)&current_value);
}

listNVRAM::~listNVRAM()
{
  	choiceContainer *tmp1, *tmp2;
  	
  	tmp2 = choices->next;
  	
  	while (tmp2 != choices){
  	  	tmp1 = tmp2;
  	  	tmp2 = tmp2->next;
  	  	delete tmp1;
  	}
  	
  	delete choices; choices = NULL;
}

_kernel_oserror*
listNVRAM::addChoice(choiceContainer* n_choice)
{
  if (n_choice != NULL){
    	 // if first choice
    	if (choices == NULL){
    		choices = n_choice;
    		n_choice->next = n_choice;
    		n_choice->prev = n_choice;
    	} else {
    	  	choiceContainer* c_next = choices->next;
     		    	  
    	  	c_next->prev = n_choice;
    	  	n_choice->next = c_next;
 
    	  	choices->next = n_choice;
    	  	n_choice->prev = choices;
    	}
    	return NULL;
  } else 
  	return makeError(EM_Alloc);
}

_kernel_oserror*
listNVRAM::handleKey(int key, graphics* graphic, boolean*)
{
  	if (choices != NULL) {
  		switch (key) {
  			case key_right:
  				choices = choices->next;
  				error = graphic->redrawSecondaryString(element, choices->choice);
  				break;
  			case key_left:
  				choices = choices->prev;
  				error = graphic->redrawSecondaryString(element, choices->choice);
  				break;
  		}
  	}
  	return error;
}

_kernel_oserror*
listNVRAM::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	IGNORE(centred);
  	
  	char* stg = NULL;
  	char undef[MAX_MSG_LEN];
  	
  	if (choices != NULL){
  	  	choiceContainer *start = choices;
  	  	do {
  	  	  	if (start->value = current_value){
  	  	  		stg = start->choice;
  	  	  		choices = start;
  	  	  		break;
  	  	  	} else {
  	  	  	  	start = start->next;
  	  	  	}
  	  	} while (start != choices);
  	}
  	if (stg == NULL) {
  		error = lookupMessage(MSG_Unknown, undef, MAX_MSG_LEN);
  		stg = undef;
  	}
  	
 	return error = graphic->drawMenuElement(selected, element, desc, stg);
}

_kernel_oserror*
listNVRAM::saveOption()
{
  	if (choices != NULL) {
  	  	if (choices->value != current_value) {
  	  	  	if (setValue((char*)choices->value) == true)
  	  	  		current_value = choices->value;
  	  	}
  	}
  	
  	return error;
}

_kernel_oserror*
listNVRAM::addList(char* element, int value)
{
  	choiceContainer* tmp = new choiceContainer(element, value);
  	return addChoice( tmp );
}

stringNVRAM::stringNVRAM( char* n_desc, char* n_tag):NVRAM(n_desc, n_tag)
{
  	contents = NULL;
  	length = getLength();
  	
  	if ((error == NULL)&&(length > 0)) {
  	  
  	  	contents = new char[length + 1];
  	  	
  	  	if (contents != NULL){
  	  	  	getValue(contents);
  	  	  	contents[length] = '\0';
  	  	  	end = strlen(contents);
  	  	} else {
  	  	  	error = makeError(EM_Alloc);
  	  	}
  	}
}

stringNVRAM::~stringNVRAM()
{
  	length = 0;
  	end = 0;
  	if (contents != NULL) {
  		delete contents;
  		contents = NULL;
  	}
}

boolean
stringNVRAM::getValue(char* buffer)
{
  	int size = 0;
  	
  	error = _swix(NVRAM_Read, _INR(0,2), _OUT(0), tag, buffer, length, &size);
  	
  	if (size < 0) {
  		error = makeError(EM_NVRead);
  		length = 0;
  	}
  	
  	return (error == NULL)? true:false;
}

boolean
stringNVRAM::setValue(char* buffer)
{
  	int size = 0;
  	
  	error = _swix(NVRAM_Write, _INR(0,2), _OUT(0), tag, buffer, length, &size);
  	
  	if (size < 0) {
  		error = makeError(EM_NVWrite);
  		length = 0;
  	}
  	
  	return (error == NULL)? true:false;
}

_kernel_oserror*
stringNVRAM::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	IGNORE(centred);
  	
  	return error = graphic->drawMenuElement(selected, element, desc, contents);
}
	
_kernel_oserror*
stringNVRAM::saveOption()
{
  	if (contents != NULL) {
  	  	setValue(contents);
  	}
  	return error;
}

_kernel_oserror*
stringNVRAM::handleKey(int key, graphics* graphic, boolean*)
{
  	if ((isprint(key))&&(end != length +1)) {
  	  
  	  	contents[end] = key;
  	  	end++;
  	  	contents[end] = '\0';
  	  	
  	  	error = graphic->redrawSecondaryString(element, contents);
  	  	
  	} else {
  	  
  		if ((key == ASCII_delete)&&(end != 0)) {
  		  	end--;
  		  	contents[end] = '\0';
  		  	
  		  	error = graphic->redrawSecondaryString(element, contents);
  		}
  	}
   	return error;
}

/****************************************************************************/
//class  rangeNVRAM : public NVRAM
rangeNVRAM::rangeNVRAM(char* n_desc, char* n_tag, int min, int max, int gran):NVRAM(n_desc, n_tag)
{
  	minimum = min;
  	maximum = max;
  	getValue((char*)&current);
  	granularity = gran;
  	// range testing.
}

_kernel_oserror*
rangeNVRAM::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	IGNORE(centred);
  	
  	if ((current < minimum)||(current > maximum)) {
  		error = lookupMessage(MSG_Unknown, string, MAX_MSG_LEN);
  	} else {
  		getCurrentAsString();
  	}
  	
  	return error = graphic->drawMenuElement(selected, element, desc, string);
}

_kernel_oserror*
rangeNVRAM::saveOption()
{
  	if ((current >= minimum)&&(current <= maximum)) {
  	  	setValue((char*)current);
  	}
  	
  	return NULL;
}

_kernel_oserror* 	
rangeNVRAM::handleKey(int key, graphics* graphic, boolean*)
{
  	switch (key) {
  		case key_right:
  			current += granularity;
  			if (current > maximum)
  				current = maximum;
  			error = graphic->redrawSecondaryString(element, getCurrentAsString());
  			break;
  		case key_left:
  			current -= granularity;
  			if (current < minimum)
  				current = minimum;
  			error = graphic->redrawSecondaryString(element, getCurrentAsString());
  			break;
  	}
  	return error;
}

/****************************************************************************/
//class DESC : public menuElement
_kernel_oserror*
DESC::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	IGNORE(centred);
  	
	return error = graphic->drawMenuElement(selected, element, desc, (*string_fn)(margc,margv));
}

_kernel_oserror*
DESC::addArgument(char* arg)
{
  	// if there is not enough room in the vector
  	if (margc == (margv_size-1)) {
  	  	char **tmp = (char**) new int[margv_size + arg_size];
  	  	char **tmp2 = NULL;
  	  	
  	  	if (tmp != NULL) { // move to larger accomodation
  	  	  	for (int i = 0; i < margc; i++)
  	  	  		tmp[i] = margv[i];
  	  	  		
  	  	  	tmp2 = margv;
  	  	  	margv = tmp;
  	  	  	delete tmp2;
  	  	  	tmp2 = NULL;
  	  	  	tmp = NULL;
  	  	  	margv_size += arg_size;
  	  	  	
  	  	} else {
  	  	  
  	  	  	delete arg;
  	  	  	error = makeError(EM_Alloc);
  	  	  	
  	  	}
  	}
  	
	if (error == NULL){
	  	margv[margc] = arg;
	  	margc++;
	}
	return error;	
}
	 
DESC::DESC(char* n_desc, char* token)
{
  desc = n_desc;
  
  margc = 0;
  margv = (char**)new int[arg_size];
  if (margv != NULL) {
  	margv_size = arg_size;
  } else {
    	error = makeError(EM_Alloc);
  }
  
  string_fn = lookup_string_function(token, &error);
  
  delete token;
  
  debug("", "DESC (%s)\n", desc);
}

DESC::~DESC()
{
  	delete desc;
  	
  	for (int i = 0; i < margc; i++)
  		delete margv[i];
  	
	delete margv;
		
  	string_fn = NULL;
}

 	
/****************************************************************************/
//class MFUNC : public menuElement
_kernel_oserror*
MFUNC::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	if (centred == true)
		return error = graphic->drawCentredMenuElement(selected, element, desc);
	else
		return error = graphic->drawMenuElement(selected, element, desc);
}

_kernel_oserror*
MFUNC::handleKey(int key, graphics* graphic, boolean *redraw)
{
  	if (key == key_select){
  		unsigned int time1, time2;
  	
  		if (message != NULL){// if message != null display message
  	
  	  		_swi(OS_ReadMonotonicTime, _OUT(0), &time1);
  	  		graphic->drawDialogue(message);
  	  	
  		}
  		
  		error = (*manage_fn)();
  		
  		if (message != NULL){ // message was displayed
  	
  			while (time2 < ( time1 + DialogueDelay) ){
  		  		_swi(OS_ReadMonotonicTime, _OUT(0), &time2);	
  			}
  			(*redraw) = true;
  		
  		}
  	}	
  	return error;
}

MFUNC::MFUNC(char* n_desc, char* token, char* n_message)
{
  desc = n_desc;
  message = n_message;		// assign to none damaging function

  manage_fn = lookup_management_function(token, &error);
  
  if (message != NULL)
  	debug("", "MFUNC (%s) [msg (%s)]\n", desc, message);
  else
  	debug("", "MFUNC (%s) [no msg]\n", desc);
  
  delete token;
}

MFUNC::~MFUNC()
{
	delete desc;
	delete message;
	
}
