/*
 ----------------------------------------------------------------------------
  Copyright [1999] Pace Micro Technology PLC.  All rights reserved.
  
  The copyright in this material is owned by Pace Micro Technology PLC
  ("Pace").  This material is regarded as a highly confidential trade secret
  of Pace.  It may not be reproduced, used, sold or in any other way exploited
  or transferred to any third party without the prior written permission of
  Pace.
  ----------------------------------------------------------------------------
*/

#include "menu.h"
#include "main.h"
#include "string.h"
#include "ctype.h"

/**************************************************************************************************************** MENU OBJECT ****************/
//class menuObject : public ParentObject

_kernel_oserror*
menuObject::saveOptions(graphics* graphic)
{
  	int i=0;

 	while ( (i < elements) && (error == NULL) ){
 	  
  		if (element[i] != NULL){
  			if (error == NULL) error = element[i]->saveOption(graphic);
  			if (error == NULL) error = element[i++]->getError();
  		}
  	}

  	return error;
}

_kernel_oserror*
menuObject::handleKey(int key, graphics* graphic)
{
 	int old_selection = selected;
 	boolean redraw = false;
  	
 	// if key == key_up || key_down change selection
  	switch (key) {
  		case key_up:
  			if (selected == 0)
  	  			selected = elements-1;
  	  		else
  	  			selected--;
  	  		if (error == NULL) error = element[old_selection]->redraw(graphic, false, centred);
  	  		if (error == NULL) error = element[selected]->redraw(graphic, true, centred);
  	  		break;
  	  		
  	  	case key_down:
  			if (selected == elements-1)
  	  			selected = 0;
  	  		else
  	  			selected++;

  	  		if (error == NULL) error = element[old_selection]->redraw(graphic, false, centred);
  	  		if (error == NULL) error = element[selected]->redraw(graphic, true, centred);
  	  		break;
  	  		
  	  	default:
  	  		if (element[selected] != NULL)
  				if (error == NULL) error = element[selected]->handleKey(key, graphic, &redraw);
        }
        
        if ((error == NULL)&&(redraw == true))
        	drawMenu(graphic);
        	
   	return error;
}
  	
_kernel_oserror*
menuObject::drawMenu(graphics* graphic)
{
  	if (error == NULL) error = graphic->reDrawWindow(elements);
  	
  	// draw all of the elements in the menu
   	int i = 0;
 	while ((i < elements)&&(error == NULL)){
  		if (element[i] != NULL)
  			error = element[i]->draw(graphic, ((i==selected)?true:false), centred);
  		i++;
  	}
  	
  	return error;
}
 
_kernel_oserror*
menuObject::addElement(menuElement* ele)
{  
  	if (error == NULL){
  		
  		if (elements == MAX_elements) {
  			if (error == NULL) error = makeError(EM_TooManyElem);
  		} else {
  		  	if ((error = ele->getError()) == NULL) {
  		  		ele->element = elements;
   				element[elements] = ele;
   				elements++;
   			}
  		}
  	}
  	return error;
}

menuObject::menuObject(char* n_tag, char* desc)
{
 	error = NULL;
  	previous = NULL;
 	selected = 0;
   	tag = NULL;
  	desc_string = NULL;
 	centred = true;
 	elements = 0;
  	chain = NULL;
  	
  	tag = n_tag;
  	desc_string = desc;
  	
  	for (int i = 0; i < MAX_elements; i++) element[i] = NULL;
  	
#ifdef DEBUGLIB
  	debug("menus", "MENU %s\n", desc_string);
#endif  	  	
}

menuObject::~menuObject()
{
  	for (int i = 0; i < elements; i++){
  	  	if (element[i] != NULL) {
   	  		delete element[i];
  	  		element[i] = NULL;
  	  	}
  	}
  	
  	delete tag; tag = NULL;
  	delete desc_string; desc_string = NULL;
  	error = NULL;	// we don't allocate we don't delete
  	
  	// delete next menu
  	if (chain != NULL)
  		delete chain; chain = NULL;
}

/**************************************************************************************************************** MENU ELEMENTS ****************/

/********************************************************************** SUBMENU ******/
//class SUBMENU : public menuElement

// change menu is a global function that changes the state of the menus, ie current.
_kernel_oserror*
SUBMENU::handleKey(int key, graphics*, boolean*)
{
  	if (key == key_select)
  		if (error == NULL) error = change_menu((void*) link);
  		
  	return error;
}
  	 
_kernel_oserror*
SUBMENU::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	if (error == NULL) {
  	  
  		if (centred == true)
  			error = graphic->drawCentredMenuElement(selected, element, link->getDescString());
  		else
  			error = graphic->drawMenuElement(selected, element, link->getDescString());
  	}
  	return error;
}
  	 
SUBMENU::SUBMENU(menuObject *n_link)
{
  	link = n_link;
  	debug("menus", "SUBMENU for %s\n", link->getDescString());
};

SUBMENU::~SUBMENU()
{
  	link = NULL; // this is freed in the menu hierarchy object
}

/********************************************************************** NVRAM  ******/
int
NVRAM::getLength(char* tag)
{
  	int length = 0;
  	
  	if (error == NULL) error = _swix(NVRAM_Read, _INR(0,2)|_OUT(0), tag, 0, 0, &length);
  
  	if (length < 0) {
  		if (error == NULL) error = makeError(EM_NVRead);
  		length = 0;
  	}
  	
  	return length;
}

boolean
NVRAM::getValue(char* buffer)
{
  	int length = 0;
  	
  	if (error == NULL) error = _swix(NVRAM_Read, _INR(0,2)|_OUT(0), tag, buffer, 0, &length);
  	
   	debug("menus", "(%8.8X)get value (%s) return value is %i (%i)\n", error, tag, length, (*(int*)buffer));
  		
  	if (length < 0) {
  		if (error == NULL) error = makeError(EM_NVRead);
  		(*(int*)buffer) = 0;
  	} //else {
  	  //	(*(int*)buffer) = length;
  	//}

 	return (error == NULL)?true:false;
}

boolean
NVRAM::setValue(char* buffer)
{
  	int length = 0;
  	
   	debug("menus", "set value (%s) value is (%i)\n", tag, (*(int*)buffer));

  	if (error == NULL) error = _swix(NVRAM_Write, _INR(0,2)|_OUT(0), tag, buffer, 0, &length);
  	
   	debug("menus", "set value (%s) returns %i\n", tag, length);

  	if (length < 0) {
  		if (error == NULL) error = makeError(EM_NVWrite);
  		length = 0;
  	}
  	
  	return (error == NULL)? true:false;
}
  
NVRAM::NVRAM(char* n_desc, char* n_tag)
{
  
  	desc = n_desc;
  	tag = n_tag;
  	
  	if ((tag==NULL)||(desc== NULL))
  		error = makeError(EM_ObjectError);
#ifdef DEBUGLIB  	  	  	
  	debug("menus", "NVRAM %s tag %s\n", desc, tag);
#endif  	
}

NVRAM::NVRAM(char* n_desc)
{
  
  	desc = n_desc;
  	
  	if (desc== NULL)
  		error = makeError(EM_ObjectError);
#ifdef DEBUGLIB  	  	  	
  	debug("menus", "NVRAM %s\n", desc);
#endif  	
}

NVRAM::~NVRAM()
{  	
  	delete desc;
  	delete tag;
}

/********************************************************************** NVRAM list ******/

_kernel_oserror*
listNVRAM::handleKey(int key, graphics* graphic, boolean*)
{
  	if (choices != NULL) {
  		switch (key) {
  			case key_right:
  				choices = (list_choice*)choices->next;
  				if (error == NULL) error = graphic->redrawSecondaryString(element, choices->choice);
  				current_value = choices->value;
  				break;
  			case key_left:
  				choices = (list_choice*)choices->prev;
  				if (error == NULL) error = graphic->redrawSecondaryString(element, choices->choice);
  				current_value = choices->value;
  				break;
  		}
  	}
  	return error;
}

_kernel_oserror*
listNVRAM::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	IGNORE(centred);
  	boolean choice_found = false;
  	
#ifdef DEBUGLIB
	debug("menus", "started redraw list current = (%i) choices->value = (%i)\n", current_value, choices->value);
#endif  	
  	
  	if (choices != NULL){
  	  
  	  	list_choice *start = choices;
  	  	
  	  	do {
  	  	  	if (start->value == current_value){
  	  	  	 	if (error == NULL) error = graphic->drawMenuElement(selected, element, desc, start->choice);
  	  	  		choices = start;
  	  	  		choice_found = true;
  	  	  		break;
  	  	  	} else {
  	  	  	  	start = (list_choice*)start->next;
  	  	  	}
  	  	} while (start != choices);
  	}
  	
  	if (choice_found == false) {
  	  
  		char undef[MAX_MSG_LEN];
  		
  		if (error == NULL) error = lookupMessage(MSG_Unknown, undef, MAX_MSG_LEN);
  		
  		if (error == NULL) error = graphic->drawMenuElement(selected, element, desc, undef);
  	}
  	
  	if ((error == NULL)&&(selected == true))
  		graphic->drawSelectable(element);
   	
 	return error;
}

_kernel_oserror*
listNVRAM::draw(graphics* graphic, boolean selected, boolean centred)
{
  	// realign the current value with NVRAM value
	if (getValue((char*)&current_value) == true)
		
		redraw(graphic, selected, centred); // no need to assign to error as redraw will already have done that
		
	return error;
}

_kernel_oserror*
listNVRAM::saveOption(graphics*)
{
  	if (choices != NULL) {
  	  
  	  	// if this is not equal it must be displayed as unknown
  	  	if (choices->value == current_value) {
  	  	  	if (setValue((char*)(&(choices->value))) == true)
  	  	  		current_value = choices->value;
  	  	}
  	}
  	
  	return error;
}

_kernel_oserror*
listNVRAM::addList(char* element, int value)
{
#ifdef DEBUGLIB
	debug("menus", "listNVRAM Add element (%s)->(%i)\n", element, value);
#endif	
 
  	list_choice *tmp, *tmp2;
  	
	tmp = new list_choice;
  	
  	if (tmp != NULL){
  	  
  		tmp->choice = element;
  		tmp->value = value;
  		
  		if (choices == NULL){
  		  	// tmp is the only element in the loop
  		  	// and choices must point to it.
  		  	tmp->next = tmp->prev = choices = tmp;
  		} else {
  		  	// tmp2 may be equal to choices, we are going
  		  	// to insert tmp between tmp2 and choices.
  			tmp2 = (list_choice*)choices->next;
  			tmp2->prev = tmp; tmp->next = tmp2;
  			choices->next = tmp; tmp->prev = choices;
  		}
  	} else {
  	  
  	  	if (error == NULL) error = makeError(EM_Alloc);
  	}
  	
  	return error;
}
	
listNVRAM::listNVRAM(char* n_desc, char* n_tag):NVRAM(n_desc, n_tag)
{ 
	choices = NULL;
	getValue((char*)&current_value);
#ifdef DEBUGLIB
	debug("menus", "listNVRAM\n");
#endif	
}

listNVRAM::~listNVRAM()
{
  
  	if (choices != NULL){
  	  
  		list_choice *tmp1, *tmp2;
  	
  		tmp2 = (list_choice*)choices->next;
  	
  		while (tmp2 != choices){
  		  
  		  	// isolate tmp1 between tmp2 and choices
  		  	// tmp2 can equal choices at this point, but there must be at least
  		  	// two structures.
  		  	tmp1 = tmp2;
  		  	tmp2 = (list_choice*)tmp2->next;
  		  	
  		  	// delete tmp1 now it is isolated from the loop
  		  	delete tmp1->choice;	// delete string
  		  	delete tmp1;
  		}
  	
  		delete choices->choice;
  		delete choices; choices = NULL;
  	}
}

/********************************************************************** NVRAM string ******/

stringNVRAM::stringNVRAM( char* n_desc, tag_list* n_tag):NVRAM(n_desc)
{
  	contents = NULL;
  	length = 0;
  	tags = n_tag;
  	  	
  	while ((error == NULL)&&(n_tag != NULL)) {
  	  
  	  	n_tag->offset = length;
  		length += n_tag->length = getLength(n_tag->tag);
  		n_tag = (tag_list*)n_tag->next;
  	}
  	
#ifdef DEBUGLIB
	debug("", "string NVRAM length = %i\n", length);
#endif
  	if ((error == NULL)&&(length > 0)) {
  	  
  	  	contents = new char[length + 1];
  	  	
  	  	if (contents != NULL){
  	  	  	getValue(contents);
  	  	  	contents[length] = '\0';
  	  	  	end = strlen(contents);
  	  	} else {
  	  	  	if (error == NULL) error = makeError(EM_Alloc);
  	  	}
  	}
}

stringNVRAM::~stringNVRAM()
{
  	tag_list* n_tags = tags;
  	
  	while (tags != NULL) {
  	  	tags = (tag_list*)tags->next;
  	  	delete n_tags;
  	  	n_tags = tags;
  	}
  	
  	length = 0;
  	end = 0;
  	if (contents != NULL) {
  		delete contents;
  		contents = NULL;
  	}
  	
}

boolean
stringNVRAM::getValue(char* buffer)
{
  	tag_list* n_tags = tags;
   	int size = 0;
  	  	
  	while ((error == NULL)&&(n_tags != NULL)) {
  	  
  		error = _swix(NVRAM_Read, _INR(0,2)|_OUT(0), n_tags->tag, buffer+(n_tags->offset), n_tags->length, &size);
  		
  		if (size < 0) {
  			if (error == NULL) error = makeError(EM_NVRead);
  			break;
  		}
  		
   	  	n_tags = (tag_list*)n_tags->next;
  	}
  	return (error == NULL)? true:false;
}

boolean
stringNVRAM::setValue(char* buffer)
{
  	tag_list* n_tags = tags;
   	int size = 0;
  	  	
  	while ((error == NULL)&&(n_tags != NULL)) {
  	  
  		error = _swix(NVRAM_Write, _INR(0,2)|_OUT(0), n_tags->tag, buffer+(n_tags->offset), n_tags->length, &size);
  		
  		if (size < 0) {
  			if (error == NULL) error = makeError(EM_NVWrite);
  			break;
  		}
  		
   	  	n_tags = (tag_list*)n_tags->next;
  	}
 	
  	return (error == NULL)? true:false;
}

_kernel_oserror*
stringNVRAM::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	IGNORE(centred);
  	
  	end = strlen(contents);
  	
  	debug("", "redraw IP address (%s)@(%8.8X), l(%i) e(%i)\n", contents, contents, length, end);
  	
  	if (error == NULL) error = graphic->drawMenuElement(selected, element, desc, contents);
  	
  	if ((error == NULL)&&(selected == true))
  		graphic->drawSelectable(element);
 
  	return error;
}
	
_kernel_oserror*
stringNVRAM::draw(graphics* graphic, boolean selected, boolean centred)
{
  	if (error == NULL) {
  	
  	  	getValue(contents);
  	  	contents[length] = '\0';
  	}
  	
	return redraw(graphic, selected, centred);
}

_kernel_oserror*
stringNVRAM::saveOption(graphics*)
{
  	if (contents != NULL) {
  	  	setValue(contents);
  	}
  	return error;
}

_kernel_oserror*
stringNVRAM::handleKey(int key, graphics* graphic, boolean*)
{
  	if (((isprint(key))||(key == key_select))&&(end != length)) {
  	  
  	  	if (key == key_select)
  	  		contents[end] = '.';
  	  	else
  	  		contents[end] = key;
  	  		
  	  	end++;
  	  	contents[end] = '\0';
  	  	
  	  	if (error == NULL) error = graphic->redrawSecondaryString(element, contents);
  	  	
  	} else {
  	  
  		if (((key == key_left)||(key == ASCII_delete))&&(end != 0)) {
  		  	end--;
  		  	contents[end] = '\0';
  		  	
  		  	if (error == NULL) error = graphic->redrawSecondaryString(element, contents);
  		}
  	}
   	return error;
}

/****************************************************************************/
//class  IPStringNVRAM : public NVRAM
_kernel_oserror*
IPstringNVRAM::saveOption(graphics *graphic)
{
  	char IPaddress[4];
  	int i = 0;
 
	if (error == NULL) { 	
  		
  		IPaddress[0] = atoi(contents);
  		
  		while (isdigit(contents[i])) i++;
  		
  		if (contents[i] != '.') {
  			error = makeError(EM_IPStringErr);
  		} else {
  		  	i++;
  		
  			IPaddress[1] = atoi(contents+i);
  		
  			while (isdigit(contents[i])) i++;
  		
  			if (contents[i] != '.') {
  				error = makeError(EM_IPStringErr);
  		        } else {
  		          	i++;
  		          	
  		          	IPaddress[2] = atoi(contents+i);
  		          	
  				while (isdigit(contents[i])) i++;
  		
  				if (contents[i] != '.') {
  					error = makeError(EM_IPStringErr);
  				} else {
  		          		i++;
  				  
  					IPaddress[3] = atoi(contents+i);
  				}
  			}
  		}
  		if (error != NULL){
  		  	// error handling
                       	graphic->drawError(error, MSG_Cont);
                       			  	
                       	int key = 0;
                       	boolean got_key = false;
                       			  	
                       	while (key != key_select) {
                        	  getKey(&key, &got_key);
                        	  if (got_key == false)
                        	  	key = 0;
                       	}
                       	
  		  	debug("", "Error in reading ip address\n");
  		  	error = NULL;
  		} else {
  		  	setValue(IPaddress);
#ifdef DEBUGLIB
			debug("", "save %i.%i.%i.%i\n", IPaddress[0]&0xff, IPaddress[1]&0xff, IPaddress[2]&0xff, IPaddress[3]&0xff);
#endif  		
                }
  	}
  	return error;
}
	
_kernel_oserror*
IPstringNVRAM::draw(graphics* graphic, boolean selected, boolean centred)
{
  	if (error == NULL) {
  	  	char IPaddress[4];
  	
  	  	getValue(IPaddress);
  	  	
  	  	sprintf(contents, "%i.%i.%i.%i", IPaddress[0]&0xff, IPaddress[1]&0xff, IPaddress[2]&0xff, IPaddress[3]&0xff);
  	  	contents[length] = '\0';
  	}
  	
	return redraw(graphic, selected, centred);
}


IPstringNVRAM::IPstringNVRAM(char* n_desc, tag_list* n_tag):stringNVRAM(n_desc, n_tag)
{
  	if (error == NULL) {
  		// at this point current is  a four byte IP address, or error 
  		
  		if (length != 4) {
  		  	error = makeError(EM_IPLengthErr);
  		} else {
  		  	char *disp_string = new char[16];
  		  	
  		  	if (disp_string != NULL) {
          		  	sprintf(disp_string, "%i.%i.%i.%i", contents[0]&0xff, contents[1]&0xff, contents[2]&0xff, contents[3]&0xff);
          		  	
          		  	delete contents;
          		  	
          		  	contents = disp_string;
          		  	
        			length = 15;
        			contents[length] = '\0';
          		  	end = strlen(contents);
          		} else {
  		  	  	error = makeError(EM_Alloc);
  		  	}
  		}
  	}
}

/****************************************************************************/
//class  rangeNVRAM : public NVRAM
rangeNVRAM::rangeNVRAM(char* n_desc, char* n_tag, int min, int max, int gran):NVRAM(n_desc, n_tag)
{
  	minimum = min;
  	maximum = max;
  	getValue((char*)&current);
  	granularity = gran;
  	
  	if (min > max) error = makeError(EM_Value);
}

_kernel_oserror*
rangeNVRAM::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	IGNORE(centred);
  	
  	if ((current < minimum)||(current > maximum)) {
  		if (error == NULL) error = lookupMessage(MSG_Unknown, string, MAX_MSG_LEN);
  	} else {
  		getCurrentAsString();
  	}
  	
  	if (error == NULL)
  		if (error == NULL) error = graphic->drawMenuElement(selected, element, desc, string);
  	
  	if ((error == NULL)&&(selected == true))
  		graphic->drawSelectable(element);
  		
  	return error;
}

_kernel_oserror*
rangeNVRAM::draw(graphics* graphic, boolean selected, boolean centred)
{
	if (getValue((char*)&current) == true){
		error = redraw(graphic, selected, centred);
	}
	return error;
}

_kernel_oserror*
rangeNVRAM::saveOption(graphics*)
{
  	if ((current >= minimum)&&(current <= maximum)) {
  	  	setValue((char*)&current);
  	}
  	
  	return NULL;
}

_kernel_oserror* 	
rangeNVRAM::handleKey(int key, graphics* graphic, boolean*)
{
  	switch (key) {
  		case key_right:
  			current += granularity;
  			if (current > maximum)
  				current = maximum;
  			if (error == NULL) error = graphic->redrawSecondaryString(element, getCurrentAsString());
  			break;
  		case key_left:
  			current -= granularity;
  			if (current < minimum)
  				current = minimum;
  			if (error == NULL) error = graphic->redrawSecondaryString(element, getCurrentAsString());
  			break;
  	}
  	return error;
}

/****************************************************************************/
//class DESC : public menuElement
_kernel_oserror*
DESC::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	IGNORE(centred);
  		
  	if ((result != NULL)&&(error == NULL))
  		error = graphic->drawMenuElement(selected, element, desc, result);
  		
  	return error;
}

_kernel_oserror*
DESC::draw(graphics* graphic, boolean selected, boolean centred)
{
  	IGNORE(centred);
  	
  	const char* return_string = (*string_fn)(margc,margv);
  	int length = strlen(return_string);
  	
  	if (result != NULL)
  		delete result;
  		
  	result =  new char[length+1];
  	
  	if (result != NULL){
  	  	strncpy(result, return_string, length);
  	  	result[length] = '\0';
  	}
  	
  	return redraw(graphic, selected, centred);
}

_kernel_oserror*
DESC::addArgument(char* arg)
{
  	// if there is not enough room in the vector
  	if (margc == (margv_size-1)) {
  	  	char **tmp = (char**) new int[margv_size + arg_size];
  	  	char **tmp2 = NULL;
  	  	
  	  	if (tmp != NULL) { // move to larger accomodation
  	  	  	for (int i = 0; i < margc; i++)
  	  	  		tmp[i] = margv[i];
  	  	  		
  	  	  	tmp2 = margv;
  	  	  	margv = tmp;
  	  	  	delete tmp2;
  	  	  	tmp2 = NULL;
  	  	  	tmp = NULL;
  	  	  	margv_size += arg_size;
  	  	  	
  	  	} else {
  	  	  
  	  	  	delete arg;
  	  	  	if (error == NULL) error = makeError(EM_Alloc);
  	  	  	
  	  	}
  	}
  	
	if (error == NULL){
	  	margv[margc] = arg;
	  	margc++;
	}
	return error;	
}
	 
DESC::DESC(char* n_desc, char* token)
{
  desc = n_desc;
  result = NULL;
  
  margc = 0;
  margv = (char**)new int[arg_size];
  
  if (margv != NULL) {
  	margv_size = arg_size;
  } else {
    	if (error == NULL) error = makeError(EM_Alloc);
  }
  
  string_fn = lookup_string_function(token, &error);
  
  delete token;
  
  debug("menus", "DESC (%s)\n", desc);
}

DESC::~DESC()
{
  	delete desc;
  	
  	for (int i = 0; i < margc; i++)
  		delete margv[i];
  	
	delete margv;
	delete result;
		
  	string_fn = NULL;
}

 	
/****************************************************************************/
//class MFUNC : public menuElement
_kernel_oserror*
MFUNC::redraw(graphics* graphic, boolean selected, boolean centred)
{
  	if (centred == true)
		return error = graphic->drawCentredMenuElement(selected, element, desc);
	else
		return error = graphic->drawMenuElement(selected, element, desc);
}

_kernel_oserror*
MFUNC::handleKey(int key, graphics* graphic, boolean *redraw)
{
  	if (key == key_select){
  	  
  		unsigned int time1, time2;
  	
  		if (message != NULL){// if message != null display message
  	
  	  		_swi(OS_ReadMonotonicTime, _OUT(0), &time1);
  	  		graphic->drawDialogue(message);
  	  	
  		}
  		
  		error = (*manage_fn)();
  		
  		if (message != NULL){ // message was displayed
  		
  			do {
  		  		_swi(OS_ReadMonotonicTime, _OUT(0), &time2);
  			} while (time2 < ( time1 + DialogueDelay) );
  			
  			(*redraw) = true;
  		
  		}
  	}	
  	return error;
}

MFUNC::MFUNC(char* n_desc, char* token, char* n_message)
{
  desc = n_desc;
  message = n_message;		// assign to none damaging function

  manage_fn = lookup_management_function(token, &error);
  
  if (message != NULL)
  	debug("menus", "MFUNC (%s) [msg (%s)]\n", desc, message);
  else
  	debug("menus", "MFUNC (%s) [no msg]\n", desc);
  
  delete token;
}

MFUNC::~MFUNC()
{
	delete desc;
	delete message;
	
}
