/* ncma_bootb.c - deal with all aspects of bootblocks, enterprise blocks etc.
                  whether in RAM, NVRAM, or on the smartcard
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"
#define PROTOTYPES_INTERNAL
#include "ncma_bootb.h"
#define PROTOTYPES_INTERNAL
#include "ncma_tags.h"
#include "ncma_scard.h"
#include "ncma_cache.h"
#include "ncma_url.h"
#include "ncma_uid.h"
#include "ncma_utils.h"
#include "smcard.h"

#include "DBUG.h"

#define MUNGE2b(a,b) a###b
#define MUNGE3b(a,b,c) a###b##c
#define MUNGE2(a,b) MUNGE2b(a,b)
#define MUNGE3(a,b,c) MUNGE3b(a,b,c)


int fetch_sc_bootblock(void)
{
    _kernel_swi_regs r;

    r.r[0] = 1; /* tell bootblock that we want even insecure data */
    if(_kernel_swi(NCBootblock_Enquiry, &r, &r)!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "fetch_sc_bootblock: SWI failed\n");
        return(-1);
    }

    if(r.r[0]<0) {

      switch(r.r[0]) {


        case -1: /* no enterprise data available */
               DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: no enterprise info available\n");
               sc_block_ptr = NULL;
    	       sc_block_bytes = 0;
    	       sc_index_ptr = (unsigned char *)r.r[2];
    	       sc_index_bytes = r.r[3];
    	       sc_alt_ptr = (unsigned char *)r.r[4];
    	       sc_alt_bytes = r.r[5];
    	       break;

        case -2: /* authentication failed */
               DBUG_PRINTF(DBUG_LVL_ERROR, "fetch_sc_bootblock: authentication failed\n");
               return(-1);

        default:
               DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: bizarre error %d\n", r.r[0]);
               return(-1);
      }
      } else {

        /* success */
        DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: succeeded\n");

        if(r.r[6] & 1) {
            DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: NCBootblock doesn't trust this data\n");
            trusted_scard_data = 0;
        } else {
            DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: NCBootblock trusts this data\n");
            trusted_scard_data = 1;
        }

        sc_block_ptr = (unsigned char *)r.r[0];
    	sc_block_bytes = r.r[1];
    	sc_index_ptr = (unsigned char *)r.r[2];
    	sc_index_bytes = r.r[3];
    	sc_alt_ptr = (unsigned char *)r.r[4];
    	sc_alt_bytes = r.r[5];
    	sc_eb_ptr = find_tag_in_block(sc_block_ptr, sc_block_bytes, NCIBeginSignatureTag, &sc_eb_bytes, NULL);
    	sc_hash_ptr = find_tag_in_block(sc_block_ptr, sc_block_bytes, NCISignatureTag, &sc_hash_bytes, NULL);
      }


    return(0);

}

int select_scard_iap(void)
{
    unsigned char *group_ptr;
    unsigned int group_bytes;

    unsigned char *matrix_ptr;
    unsigned int matrix_bytes;

    unsigned char *id_ptr;
    unsigned int id_bytes;

    unsigned int tmp;

    if((matrix_ptr = find_tag_in_block(sc_eb_ptr, sc_eb_bytes, NCIIAPConnectMatrixTag, &matrix_bytes, NULL))==NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "select_scard_iap: no IAPConnectMatrix in s/card block\n");
        return(-1);
    }

    for(group_ptr = NULL;;) {
        if((group_ptr = find_tag_in_block(matrix_ptr, matrix_bytes, NCIGroupTag, &group_bytes, group_ptr))==NULL) {
            DBUG_PRINTF(DBUG_LVL_ERROR, "select_scard_iap: exhausted s/card IAP groups\n");
            return(-1);
        }
        if((id_ptr = find_tag_in_block(group_ptr, group_bytes, NCIIAPIDTag, &id_bytes, NULL))==NULL) {
            DBUG_PRINTF(DBUG_LVL_DIAG, "select_scard_iap: no IAP ID in this block\n");
            continue;
        }

        tmp = read_big_word((char *)id_ptr);
        iap_id = tmp;
        DBUG_PRINTF(DBUG_LVL_DIAG, "select_scard_iap: using IAP ID %d\n", iap_id);
        sc_iap_ptr = group_ptr;
        sc_iap_bytes = group_bytes;
        return(1);
    }
    return(0);
}

int virgin_smartcard(void)
{
    int i;
    _kernel_swi_regs r;

    r.r[0] = 1; /* gimme data whether it's authentic or not */
    if(_kernel_swi(NCBootblock_Enquiry, &r, &r)!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "virgin_smartcard: Bootblock enquiry SWI failed!\n");
        return(-1);
    }

    if(r.r[0] != -2) {
      i = *(unsigned int *)(r.r[2]);

      //DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard: purity rating: 0x%x\n", i);
      if((i == 0x00000000) || (i == 0xffffffff)) {
          DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard: VIRGIN CARD\n");
          return(1);
      }
    } else {
        DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard: SWI returned error %d\n", r.r[0]);
        return(-1);
    }
    DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard: SULLIED CARD\n");
    return(0);
}




