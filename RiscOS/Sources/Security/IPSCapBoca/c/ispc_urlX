#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"


#include "ispc_ispc.h"
#define PROTOTYPES_INTERNAL
#include "ispc_url.h"
#include "DBUG.h"


int ispc_url_init(void)
{
   if(write_os_var(ISPC_URL_ENV_NAME, ISPC_URL_ENV_VAL, strlen(ISPC_URL_ENV_VAL))<0) return(-1);
   if(write_os_var(ISPC_PATH_ENV_NAME, ISPC_PATH_ENV_VAL, strlen(ISPC_PATH_ENV_VAL))<0) return(-1);
   return(0);
}

int ispc_url_open(char *url)
{
    _kernel_swi_regs r;
    int n;

    n = strlen(url);

    DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_url_open: %s (%d)\n", url, n);

    n = n>236?236:n;

    memset(msg_block, 0, 256);

//    *(int *)msg_block = n + 20;
    *(int *)msg_block = 256;
    *(int *)(msg_block + 16) = 0x4af80; /* Message_URL */
    strncpy(msg_block + 20, url, n);

    r.r[0] = 0;
    r.r[1] = (int)msg_block;
    r.r[2] = 0;
    r.r[3] = 0;
    r.r[4] = 0;
    r.r[5] = 0;

    if(_kernel_swi(TaskModule_SendMessage, &r, &r) != NULL) return(-1);
    return(0);
}

int ispc_url_gsopen(char *url)
{
    _kernel_swi_regs r;
    int n;

    n = strlen(url);

    DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_url_open: %s (%d)\n", url, n);

    n = n>236?236:n;

    memset(msg_block, 0, 256);

//    *(int *)msg_block = n + 20;
    *(int *)msg_block = 256;
    *(int *)(msg_block + 16) = 0x4af80; /* Message_URL */

    r.r[0] = (int)url;
    r.r[1] = (int)msg_block + 20;
    r.r[2] = 236;

    if(_kernel_swi(OS_GSTrans, &r, &r)!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_url_GSopen: GSTrans failed\n");
        strncpy(msg_block + 20, url, n);
    }

    r.r[0] = 0;
    r.r[1] = (int)msg_block;
    r.r[2] = 0;
    r.r[3] = 0;
    r.r[4] = 0;
    r.r[5] = 0;

    if(_kernel_swi(TaskModule_SendMessage, &r, &r) != NULL) return(-1);
    return(0);
}



int ispc_dbox_open(char *url)
{
    _kernel_swi_regs r;
    urlopen_data payload;
    static char dbox_target[] = "__dbox";

    DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_dbox_open: %s\n", url);

    // payload.indirect.url.ptr = url;
    payload.url.offset = sizeof(urlopen_data)+8;
    payload.body_file.ptr = NULL;
    // payload.indirect.target.ptr = dbox_target;
    payload.target.offset = sizeof(urlopen_data);
    payload.tag = 0;
    payload.flags = 0;

    memset(msg_block, 0, 256);

    *(int *)msg_block = 256;
    *(int *)(msg_block + 16) = 0x4af80; /* Message_URL */
    memcpy(msg_block + 20, &payload, sizeof(payload));
    strcpy(msg_block + 20 + sizeof(urlopen_data), dbox_target);
    strcpy(msg_block + 28 + sizeof(urlopen_data), url);

    r.r[0] = 0;
    r.r[1] = (int)msg_block;
    r.r[2] = 0;
    r.r[3] = 0;
    r.r[4] = 0;
    r.r[5] = 0;

    if(_kernel_swi(TaskModule_SendMessage, &r, &r) != NULL) return(-1);
    return(0);
}


int ncma_dbox_close(void)
{
    ispc_url_open("ncint:loadurl?remove=__dbox");
    return(0);
}

int ispc_parse_url(char *s)
{
    int i = 0;
    char *p = s;
    int n = 0;

    while(*p++ != '?'); /* find arg separator */
    *(p-1) = 0x0; /* terminate it */
    urlv[i++] = s;
    s = p;

    for(i=1;i<MAX_URLV;i++) {
        urlv[i] = p;
        while(*p++ != '&') if(*(p-1) == 0) break; /* find arg separator */
        if(*(p-1)==0) break;
        else *(p-1) = 0;
    }

    urlc = i+(i>1);

    DBUG_PRINTF(DBUG_LVL_DIAG, "parse_url: got %d args.\n", urlc);
    DBUG_PRINTF(DBUG_LVL_DIAG, "parse_url: urlv[0]:\t\t%s\t\t0x%x\n", urlv[0], (int)urlv[0]);

    for(i=1; i<urlc; i++) {
        for(p=urlv[i];*p;p++) {
            if(*p == '+') *p = 0x20; /* unescape plus */
            if(*p == '%') {
                sscanf(p+1, "%2X", &n); /* unescape % codes */
                *p = (char)n;
                memmove(p+1, p+3, strlen(p+3)+1); /* shunt string up */
            }
        }
        DBUG_PRINTF(DBUG_LVL_DIAG, "parse_url: urlv[%d]:\t\t%s\t\t0x%x\n", i, urlv[i], (int)urlv[i]);
    }
    return(urlc);
}





