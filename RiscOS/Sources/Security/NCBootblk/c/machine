#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

#define PROTOTYPES_INTERNAL /* make prototypes and globals internal to this file */
#include "machine.h"
#include "module.h"
#include "reg_events.h"
#include "reg_status.h"
#include "scinter.h"
#include "reg_scbb.h"
#include "reg_auth.h"
#include "reg_files.h"
#include "reg_index.h"
#include "reg_utils.h"
#include "reg_sign.h"

#include "DBUG.h"
#ifdef BROKEN_ON_TELLIES
#include "kprintf.h"
#endif


#define ENUM_DIR_SUPPORT

char *trans_string(BOOTBLOCK_TRANS trans)
{
  static char *t_table[] = {
    "Trans_Idle",
    "Trans_CardOK",
    "Trans_CardBad",
    "Trans_CardRemoved",
    "Trans_ReadCard",
    "Trans_WriteCard",
    "Trans_CompleteOK",
    "Trans_CompleteBad",
    "Trans_Next",
    "Trans_Finished",
    "Trans_AuthFail",
    "Trans_AuthRetry",
    "Trans_ChangeCHV",
    "Trans_AuthCard",
    "Trans_UnblockCHV"
  };


  return(t_table[trans]);
}

char *state_string(BOOTBLOCK_STATE state)
{
    static char *s_table[] = {
    "State_NoCard",
    "State_CardInserted",
    "State_BadCard",
    "State_ReadIndex",
    "State_WriteBootBlock",
    "State_ReadBootBlock",
    "State_BootBlockWritten",
    "State_BootBlockRead",
    "State_Error",
    "State_AuthFail",
    "State_ChangeCHV",
    "State_CardAuthCheck",
    "State_StartBootBlockRead",
    "State_ReadSerial",
    "State_EnumFiles",
    "State_WroteIndex",
    "State_StartBootBlockWrite",
    "State_StartAlternateRead",
    "State_ReadAlternate"
  };

  return(s_table[state]);
}

/* this is the NCbootblock ASM */
BOOTBLOCK_STATE machine(BOOTBLOCK_TRANS trans)
{
  _kernel_swi_regs r;
  char filename[MAX_FILEPATH];
  static int l;

#ifdef BROKEN_ON_TELLIES
  kprintf("bootblock: trans. %s in state %s\n", trans_string(trans), state_string(bootblock_state));
#else
  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock_machine: got transition %s in state %s\n", trans_string(trans), state_string(bootblock_state));
#endif

/*********************************************************************************

    GLOBAL TRANSITIONS

 *********************************************************************************/

  switch(trans) { /* global transitions that apply to all states */

    case Trans_CardOK:
    	 if(bootblock_state != State_NoCard) {
    	   DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock machine: pointless smartcard event - ignoring...\n");
    	   return(bootblock_state);
    	 } else break;

    case Trans_CardBad:
         set_status_bits(SELECT_SC_STATUS, BB_STATUS_INSERTED);
         clr_status_bits(SELECT_SC_STATUS, BB_STATUS_SC_VALID);
         status_service_call();
         return(State_BadCard);

    case Trans_CardRemoved:
    	 chv1_bit_set = 0;
    	 chv1_tries_left = 0xff;
    	 bootblock_loaded = 0;
    	 bootblock_authentic = 0;
    	 total_smartcard_bytes = 0;
    	 total_bootblock_bytes = 0;
    	 total_index_bytes = 0;
    	 clr_authblock();
         reset_status_bits(SELECT_SC_STATUS);
         status_service_call();
         return(State_NoCard);

  }

  switch(bootblock_state) {

/*********************************************************************************

    STATE_NOCARD : there is no card inserted in the NC

 *********************************************************************************/

    case State_NoCard:

         switch(trans) {

           case Trans_CardOK:

		clr_authblock();
	        set_status_bits(SELECT_SC_STATUS, BB_STATUS_INSERTED | BB_STATUS_SC_VALID);
	        status_service_call();
	        memset(sc_bb_buffer, 0, sc_bb_bytes);
	        memset(sc_index, 0, sc_index_bytes);
	        memset(sc_rs_buffer, 0, sc_rs_bytes);
	        bootblock_trans = Trans_AuthCard; /* force a state transition */
	        cardauth_retries = MAX_CARDAUTH_RETRIES;
	        setcallback();
	        return(State_CardAuthCheck);


           default: goto state_machine_error;

         }

/*********************************************************************************

    STATE_CARDAUTHCHECK : determine whether the relevant files are CHV1 protected

 *********************************************************************************/


    case State_CardAuthCheck: /* bootblock remains in this state until we've verified whether CHV1 access codes
    	 		      	 are needed or not. This is a change to earlier behaviour of reading a file and
    	 		      	 complaining if it's CHV1 blocked - because the s.card keeps a count of CHV1
    	 		      	 failures and locks the card out after 16 of them. Bummer. */

         switch(trans) {

           case Trans_AuthCard:

                reauth_card:

                DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: checking card access permissions...\n");
		strncpy(filename, NC_DIRNAME, MAX_FILEPATH);
		r.r[0] = 3; /* validate s/c filenames, gimme struct */
           	r.r[1] = (int)filename;
           	r.r[2] = (int)&sc_stats;
           	//r.r[3] = FRESCO_FILE_SIZE;
           	_kernel_swi(SCInterface_FileInfo, &r, &r); /* SCInterface_FileInfo */
           	DBUG_PRINTF(DBUG_LVL_DIAG, "            return code: %d\n", r.r[0]);
           	if(r.r[0] == SC_SUCCESS) {  /* read started ok */

		  return(State_CardAuthCheck);
		}
		else {
		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard read error %d - aborting...\n", r.r[0]);
		  return(State_BadCard);
		}

	    case Trans_CompleteBad:
	        if(--cardauth_retries) { /* let's have another go at that... */
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard auth. failed...retrying\n");
	            goto reauth_card;
	        }
	        else { /* Nope, no good. Reject the card. */
                  set_status_bits(SELECT_SC_STATUS, BB_STATUS_INSERTED);
                  clr_status_bits(SELECT_SC_STATUS, BB_STATUS_SC_VALID);
                  status_service_call();
                  return(State_BadCard);
                }

            case Trans_CompleteOK:
                //chv1_tries_left = fresco_buffer[CARDAUTH_ATTEMPTS_BYTE] & CARDAUTH_ATTEMPTS_MASK;
                //ncdir_files = (int)fresco_buffer[NCDIR_FILES_BYTE];
                //ncdir_dirs = (int)fresco_buffer[NCDIR_DIRS_BYTE];
                DBUG_PRINTF(DBUG_LVL_DIAG, "NCBootblock: FileInfo: File: %s  CHV1: %s Unblock: %s\n",
                  sc_stats.file?"YES":"NO", sc_stats.chv1_enabled?"YES":"NO", sc_stats.unblock_chv1_enabled?"YES":"NO");
                DBUG_PRINTF(DBUG_LVL_DIAG, "NCBootblock: Size: %d CHV1attempts: %d Unblock_attempts: %d\n",
                  sc_stats.size, sc_stats.chv1_attempts, sc_stats.unblock_chv1_attempts);
                DBUG_PRINTF(DBUG_LVL_DIAG, "NCBootblovk: Num. files: %d Num. dirs: %d\n", sc_stats.num_files, sc_stats.num_dirs);

                chv1_tries_left = sc_stats.chv1_attempts;
                ncdir_files = sc_stats.num_files;
                ncdir_dirs = sc_stats.num_dirs;

                if(sc_stats.chv1_enabled == 0) { /* CHV1 not enabled */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: CHV1 not enabled\n");
                  clr_status_bits(SELECT_SC_STATUS, BB_STATUS_LOCKED);
                  chv1_required = 0;
                  chv1_bit_set = 0;
                } else { /* CHV1 _is_ enabled */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: CHV1 REQUIRED!\n");
                  set_status_bits(SELECT_SC_STATUS, BB_STATUS_LOCKED);
                  chv1_required = 1;
                  chv1_bit_set = 1;
                }


		  /* ok - now get the card serial number */
 	          strncpy(filename, SERIAL_FILENAME, MAX_FILEPATH);
  		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: reading serial file \"%s\"\n", filename);
  		  r.r[0] = 0;
  		  r.r[1] = (int)filename;
  		  r.r[2] = 0;
  		  r.r[3] = (int)fresco_buffer;
  		  r.r[4] = SERIAL_FILE_SIZE;
  		  r.r[5] = NULL; /* no authentication for serial number file */
  		  r.r[6] = 0;
          	  _kernel_swi(SCInterface_Read, &r, &r); /* SCInterface_Read */
           	  DBUG_PRINTF(DBUG_LVL_DIAG, "            return code: %d\n", r.r[0]);
           	  if(r.r[0] == SC_SUCCESS) {  /* read started ok */

		    return(State_ReadSerial);
		  }
		  else {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard read error %d - aborting...\n", r.r[0]);
		    set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
  		    status_service_call();

		    return(State_BadCard);
		  }


            default: goto state_machine_error;

         }

/*********************************************************************************

    STATE_READSERIAL : read the serial number file from the smartcard

 *********************************************************************************/


    case State_ReadSerial: /* return from trying to read the card serial number */

         switch(trans) {

           case Trans_AuthFail:
                DBUG_PRINTF(DBUG_LVL_PANIC, "NCbootblock: serial file locked against read access. Aborting...\n");
                set_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
                status_service_call();
                return(State_BadCard);

           case Trans_CompleteBad:
           	DBUG_PRINTF(DBUG_LVL_PANIC, "NCbootblock: failed reading serial file. Aborting...\n");
                clr_status_bits(SELECT_SC_STATUS, BB_STATUS_BB_VALID);
                set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
                status_service_call();
                return(State_BadCard);

           case Trans_CompleteOK:
           	btos((unsigned char *)fresco_buffer, 8, serial_buffer, SERIAL_BUFFER_SIZE);
           	DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: serial number is %s\n", serial_buffer);

           	l = 0;
           	reg_file_reset(); /* clear any pre-exisiting file information */

           	reg_filename(filename, l);
  		DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: statting file \"%s\"\n", filename);

		r.r[0] = 3; /* validate s/c filenames; gimme a struct */
           	r.r[1] = (int)filename;
           	r.r[2] = (int)&sc_stats;
           	//r.r[3] = FRESCO_FILE_SIZE;
           	_kernel_swi(SCInterface_FileInfo, &r, &r); /* SCInterface_FileInfo */
           	DBUG_PRINTF(DBUG_LVL_DIAG, "            return code: %d\n", r.r[0]);
           	if(r.r[0] == SC_SUCCESS) {  /* read started ok */

		  return(State_EnumFiles);
		}
		else {
		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard read error %d - aborting...\n", r.r[0]);
		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
  		  status_service_call();

		  return(State_BadCard);
		}


            default: goto state_machine_error;

         }

/*********************************************************************************

    STATE_ENUMFILES : read params of all files in the NC smartcard directory

 *********************************************************************************/


    case State_EnumFiles: /* enumerating files in the smartcard NC directory */

    	 switch(trans) {

    	     case Trans_CompleteOK:
    	     	  reg_file_record(l, &sc_stats);

	     next_enum_file:
    	     	  l++;
    	     	  if((l<ncdir_files) && (l<MAX_REG_FILES)) {
               	    reg_filename(filename, l);
      		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: statting file \"%s\"\n", filename);

    		    r.r[0] = 3; /* validate s/c filenames; gimme a struct */
               	    r.r[1] = (int)filename;
               	    r.r[2] = (int)&sc_stats;
               	    //r.r[3] = FRESCO_FILE_SIZE;
               	    _kernel_swi(SCInterface_FileInfo, &r, &r); /* SCInterface_FileInfo */
               	    DBUG_PRINTF(DBUG_LVL_DIAG, "            return code: %d\n", r.r[0]);
               	    if(r.r[0] == SC_SUCCESS) {  /* read started ok */

    		      return(State_EnumFiles);
    		    }
    		    else {
    		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard read error %d - aborting...\n", r.r[0]);
    		      set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
  		      status_service_call();

    		      return(State_BadCard);
    		    }
    		  } else {
    		      bootblock_trans = Trans_ReadCard;
    		      setcallback();
    		      return(State_CardInserted); /* fall thru to normal activity */
    		  }

    		  break;

             case Trans_CompleteBad:
              	  DBUG_PRINTF(DBUG_LVL_PANIC, "NCbootblock: smartcard enumdir failed on file \"%s\". Skipping...\n", filename);
              	  goto next_enum_file;

            default: goto state_machine_error;

         }

/*********************************************************************************

    STATE_CARDINSERTED : the idle state when a smartcard is present

 *********************************************************************************/



    case State_CardInserted:

         switch(trans) {

	   case Trans_AuthRetry:
	   	/* this is the default 'do nothing' return state after authorization failure and
	   	   subsequent setting of an authorization key. We do nothing, but are now in a
	   	   state of readiness for read and write requests
	   	*/
	   	return(State_CardInserted);

           case Trans_ReadCard:
           	/* perform SWI to read index file - sc_completion event will cause transition */

		if(reg_file[0].size > MAX_INDEX_FILE_SIZE) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: index file size too big - truncating\n");
		    sc_index_bytes = MAX_INDEX_FILE_SIZE;
		} else {
		    sc_index_bytes = reg_file[0].size;
		}

           	DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: reading index file (%d bytes)\n", sc_index_bytes);
           	memset(sc_index, 0, MAX_INDEX_FILE_SIZE);
           	sc_bbs = 0;

		strncpy(filename, INDEX_SC_FILENAME, MAX_FILEPATH);
		r.r[0] = 0; /* validate smartcard filenames */
           	r.r[1] = (int)filename;
           	r.r[2] = 0;
           	r.r[3] = (int)sc_index;
           	r.r[4] = sc_index_bytes;
           	r.r[5] = NULL; /* no authentication for index file */
           	r.r[6] = 0; /* no authentication for index file */
           	_kernel_swi(SCInterface_Read, &r, &r); /* SCInterface_Read */
           	DBUG_PRINTF(DBUG_LVL_DIAG, "            return code: %d\n", r.r[0]);
           	if(r.r[0] == SC_SUCCESS) {  /* read started ok */

		  return(State_ReadIndex);
		}
		else {
		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard read error %d - aborting...\n", r.r[0]);
		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
  		  status_service_call();

		  return(State_BadCard);
		}

           case Trans_WriteCard:
           	/* perform SWI to write index file - sc_completion event will cause transition */

		if(trans_index_bytes > MAX_INDEX_FILE_SIZE) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: index size too big for file - aborting\n");
	            clr_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEOK | BB_STATUS_AUTHFAIL);
	            set_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEFAIL);
                    status_service_call();
                    return(State_CardInserted);
		}

           	DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: writing index file (%d bytes)\n", trans_index_bytes);

		strncpy(filename, INDEX_SC_FILENAME, MAX_FILEPATH);
		r.r[0] = 0; /* validate smartcard filenames */
           	r.r[1] = (int)filename;
           	r.r[2] = 0;
           	r.r[3] = (int)trans_index;
           	r.r[4] = trans_index_bytes;
             	r.r[5] = (int)authblock.authblock_key;
             	r.r[6] = authblock.authblock_bytes;
           	_kernel_swi(SCInterface_Write, &r, &r); /* SCInterface_Read */
           	DBUG_PRINTF(DBUG_LVL_DIAG, "            return code: %d\n", r.r[0]);
           	if(r.r[0] == SC_SUCCESS) {  /* read started ok */

		  return(State_WroteIndex);
		}
		else {
		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard write error %d - aborting...\n", r.r[0]);
		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEFAIL);
		  status_service_call();
		  return(State_BadCard);
		}

           case Trans_ChangeCHV:

                /* perform SWI to change Cardholder Verification Value */
		clr_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);

                DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: changing CHV1...\n");
                strcpy(filename, "/4e43");
                r.r[0] = 0; /* validate smartcard filenames */
                r.r[1] = (int)filename;
                r.r[2] = 0x1; /* select CHV1 */
                r.r[3] = (int)authblock.authblock_key;
                r.r[4] = authblock.authblock_bytes;
                r.r[5] = (int)authblock_new.authblock_key;
                r.r[6] = authblock_new.authblock_bytes;
                _kernel_swi(SCInterface_ChangeCHV, &r, &r);
           	if(r.r[0] == SC_SUCCESS) {  /* write started ok */

		  return(State_ChangeCHV);
		}
		else {
		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard auth. change error %d - aborting...\n", r.r[0]);
		  return(State_CardInserted);
		}



           default: goto state_machine_error;

         }

/*********************************************************************************
 *********************************************************************************
 *******************STATES*INVOLVED*IN*READING*AN*ENTERPRISE*BLOCK****************
 *****************************(AND*CORRESPONDING*INDEX*FILE)**********************
 *********************************************************************************/

/*********************************************************************************

    STATE_READINDEX : completion of an attempt to read the smartcard index file

 *********************************************************************************/

    case State_ReadIndex:

         switch(trans) {

           case Trans_AuthFail:
                DBUG_PRINTF(DBUG_LVL_PANIC, "NCbootblock: index file locked against read access. Aborting...\n");
                set_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
                status_service_call();
                return(State_BadCard);

           case Trans_CompleteBad:
                clr_status_bits(SELECT_SC_STATUS, BB_STATUS_BB_VALID);
                set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
                status_service_call();
                return(State_BadCard);

           case Trans_CompleteOK:
                /* process index file to generate boot file list, select nic, etc */
                /* do SWI to read first boot block file */

		index_version = version_control(sc_index);

		if(index_version == 0) { /* new smartcard, although the criteria are a bit dodgy */
		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: unregistered smartcard\n");
		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_BB_VALID);
		  clr_status_bits(SELECT_SC_STATUS, BB_STATUS_BADVERSION);
		  /* tell the file sequencer to attempt to read a few bytes from a bit bucket,
		     so that we can make sure that the CHV is OK (normally a new card will do
		     no further reads because there's no file sequence on the card */

		  fresco_data_present = 0;

		  if(build_index_cmds(0x21, 0, 4)<0) {
		      DBUG_PRINTF(DBUG_LVL_ERROR, "NCbootblock: failed to build bootblock read sequence\n");
		      set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
		      status_service_call();
		      return(State_BadCard);
		  }

		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCBootblock: sequenced short read on virgin card\n");

		  status_service_call();
		  enterprise_block_start = 0x21;
		  enterprise_block_offset = 0;
		  enterprise_block_bytes = 4;
		  bootblock_trans = Trans_CompleteOK;
		  setcallback();
		  return(State_StartBootBlockRead);
		}

                if(index_version<0) {
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: bad index version ...\n");
                  clr_status_bits(SELECT_SC_STATUS, BB_STATUS_BB_VALID);
                  set_status_bits(SELECT_SC_STATUS, BB_STATUS_BADVERSION);
                  status_service_call();
                  return(State_BadCard);
                }

		 clr_status_bits(SELECT_SC_STATUS, BB_STATUS_BADVERSION);
		 index_enterprise_id(sc_index);

		 if(enterprise_id<0) { /* no enterprise ID present */
		   DBUG_PRINTF(DBUG_LVL_DIAG, "NCBootblock: no ENTERPRISE_ID listed on this card\n");
		 }

		 if(alternate_rs_present) { /* an alternative 1-800 number for the RS is present on the card */
		   DBUG_PRINTF(DBUG_LVL_DIAG, "NCBootblock: alternate RS block present\n");
		 }

       		 fresco_data_present = 0;

		 if(build_index_cmds( enterprise_block_start,
		 		      enterprise_block_offset,
		 		      enterprise_block_bytes)<0) {
		     DBUG_PRINTF(DBUG_LVL_ERROR, "NCbootblock: failed to build bootblock read sequence\n");
		     set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
		     status_service_call();
		     return(State_BadCard);
		 }

       		 bootblock_trans = Trans_CompleteOK;
       		 setcallback();
       		 return(State_StartBootBlockRead);

            default: goto state_machine_error;
         }



/*********************************************************************************

    STATE_STARTBOOTBLOCKREAD : begin bootblock read sequence

 *********************************************************************************/





    case State_StartBootBlockRead:

         switch(trans) {

             case Trans_CompleteBad:
             	  DBUG_PRINTF(DBUG_LVL_ERROR, "NCbootblock: couldn't start bootblock read sequence\n");
             	  set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
  		  status_service_call();

             	  return(State_BadCard);

             case Trans_CompleteOK:

             	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: stat'd enterprise block size: %d\n", enterprise_block_bytes);

             	  if(enterprise_block_bytes > BOOTBLOCK_BUFFER_SIZE) {
             	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: enterprise block too large\n");
             	      return(State_BadCard);
             	  }

             	  if(enterprise_block_bytes == 4) {
             	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: starting short read on virgin card\n");
             	  }

             	  if((l = pop_file_cmd())<0) { /* get the first file command */
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: no bootblock file instructions\n");
		    set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
		    status_service_call();
		    return(State_BadCard);
		  }

		  sc_bb_ptr = sc_bb_buffer;
		  sc_bb_bytes = 0;

              case Trans_AuthRetry: /* re-entry point after authorization failure */

              	/* push state in case of auth. failure */
              	set_authstate(State_StartBootBlockRead, Trans_AuthRetry);

	   	if(chv1_required) { /* haven't had a PIN yet - stop before we try to read any locked files */
	   	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: need a CHV1 code before proceeding\n");
	   	  set_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
	   	  status_service_call();
	   	  return(State_AuthFail);
	   	}

		l = pop_last_file_cmd(); /* don't need to check for -1, as it would have failed in Trans_CompleteOK */
             	DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: starting bootblock read sequence...\n");

  		r.r[0] = 0; /* do s/c filename validation */
             	r.r[1] = (int)bb_file_command[l].filename;
             	r.r[2] = bb_file_command[l].offset;
             	r.r[3] = (int)sc_bb_ptr;
             	r.r[4] = bb_file_command[l].bytes;
             	r.r[5] = (int)authblock.authblock_key;
             	r.r[6] = authblock.authblock_bytes;
             	_kernel_swi(SCInterface_Read, &r, &r); /* SCInterface_Read */
             	DBUG_PRINTF(DBUG_LVL_DIAG, "            return code: %d\n", r.r[0]);

             	if(r.r[0] == SC_SUCCESS) {  /* read started ok */

  		  return(State_ReadBootBlock);
  		}
  		else {
  		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard read error %d - aborting...\n", r.r[0]);
  		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
  		  status_service_call();

  		  return(State_BadCard);
  		}


             default: goto state_machine_error;

            }

/*********************************************************************************

    STATE_READBOOTBLOCK : completion of an attempt to read a bootblock chunk

 *********************************************************************************/

    case State_ReadBootBlock:

         switch(trans) {


           case Trans_AuthFail:
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: authorization failure reading bootblock data.\n");
		 set_status_bits(SELECT_SC_STATUS, BB_STATUS_LOCKED | BB_STATUS_AUTHFAIL);
  		 status_service_call();

                 status_service_call();

                 return(State_AuthFail);

           case Trans_CompleteBad:
           	DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: error reading bootblock chunk - aborting\n");
		set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
  		status_service_call();

           	return(State_BadCard);

           case Trans_CompleteOK:
           	/* determine whether there's more to read, and set trans accordingly */

           	clr_status_bits(SELECT_SC_STATUS, BB_STATUS_LOCKED | BB_STATUS_AUTHFAIL);
           	status_service_call();

		if((enterprise_block_start == 0x21) &&
		   (enterprise_block_offset == 0) &&
		   (enterprise_block_bytes == 4)) {
		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: short read on virgin card completed OK - idling\n");
		       bootblock_authentic = 0;
		       bootblock_loaded = 0;
		       alternate_rs_loaded = 0;
		       set_status_bits(SELECT_SC_STATUS, BB_STATUS_READOK);
		       status_service_call();
		       return(State_CardInserted);
		   }

		l = pop_last_file_cmd();
		sc_bb_ptr += bb_file_command[l].bytes;
		sc_bb_bytes += bb_file_command[l].bytes;

		if((l = pop_file_cmd())<0) { /* no more reading to do */
           	  bootblock_trans = Trans_Finished;
           	  setcallback(); /* force state transition */
           	  return(State_BootBlockRead);
           	} else {
           	  bootblock_trans = Trans_Next;
           	  setcallback(); /* force state transition */
           	  return(State_BootBlockRead);
           	}


           default: goto state_machine_error;

         }

/*********************************************************************************

    STATE_BOOTBLOCKREAD : decide whether there is more reading to do

 *********************************************************************************/

    case State_BootBlockRead:

         switch(trans) {

           case Trans_Next:
           	/* do SWI to fetch next file */
           	l = pop_last_file_cmd(); /* 'last' because we already popped once in previous state */
  		r.r[0] = 0; /* do s/c filename validation */
             	r.r[1] = (int)bb_file_command[l].filename;
             	r.r[2] = bb_file_command[l].offset;
             	r.r[3] = (int)sc_bb_ptr;
             	r.r[4] = bb_file_command[l].bytes;
             	r.r[5] = (int)authblock.authblock_key;
             	r.r[6] = authblock.authblock_bytes;
             	_kernel_swi(SCInterface_Read, &r, &r); /* SCInterface_Read */
             	DBUG_PRINTF(DBUG_LVL_DIAG, "            return code: %d\n", r.r[0]);

             	if(r.r[0] == SC_SUCCESS) {  /* read started ok */

  		  return(State_ReadBootBlock);
  		}
  		else {
  		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard read error %d - aborting...\n", r.r[0]);
  		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
  		  status_service_call();
  		  return(State_BadCard);
  		}




           	return(State_ReadBootBlock);

           case Trans_Finished:
                /* we're finished reading from the smartcard */

                /* do something secure to decide whether it's authentic or not */
                if(authenticate_bootblock(sc_bb_buffer, sc_bb_bytes, NULL, 0)>0) {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: enterprise block auth SUCCEEDED\n");
                    bootblock_authentic = 1;
                } else {
                    DBUG_PRINTF(DBUG_LVL_ERROR, "NCbootblock: enterprise block auth FAILED\n");
#ifdef AUTHENTICATE_SIGNATURES
                    bootblock_authentic = 0;
#else
		DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: overriding auth result\n");
		bootblock_authentic = 1;
#endif

                }

                bootblock_loaded = 1;

		if(alternate_rs_present) { /* now we've got to read the damn alternate 1-800 data from somewhere */
		  if(build_index_cmds(alternate_rs_start, alternate_rs_offset, alternate_rs_bytes)<0) {
		      DBUG_PRINTF(DBUG_LVL_ERROR, "NCBootblock; alternate data present, but couldn't build read sequence - ignoring\n");
		      alternate_rs_loaded = 0;
		      return(State_CardInserted);
		  }
		  bootblock_trans = Trans_CompleteOK;
		  setcallback();
		  return(State_StartAlternateRead);
		}

		alternate_rs_loaded = 0;
		set_status_bits(SELECT_SC_STATUS, BB_STATUS_READOK);
		status_service_call();
                return(State_CardInserted);

           default: goto state_machine_error;

         }

/*********************************************************************************
 *********************************************************************************
 *******************STATES*INVOLVED*IN*WRITING*AN*ENTERPRISE*BLOCK****************
 *****************************(AND*CORRESPONDING*INDEX*FILE)**********************
 *********************************************************************************/

/*********************************************************************************

    STATE_WROTEINDEX : completion of an attempt to write the smartcard index file

 *********************************************************************************/

    case State_WroteIndex:

         switch(trans) {

           case Trans_AuthFail:
                DBUG_PRINTF(DBUG_LVL_PANIC, "NCbootblock: index file locked against write access. Aborting...\n");
                set_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
                status_service_call();
                return(State_AuthFail);

           case Trans_CompleteBad:
	        clr_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEOK | BB_STATUS_AUTHFAIL);
	        set_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEFAIL);
	        status_service_call();

                return(State_CardInserted);

           case Trans_CompleteOK:

       		 bootblock_trans = Trans_CompleteOK;
       		 setcallback();
       		 return(State_StartBootBlockWrite);

            default: goto state_machine_error;
         }



/*********************************************************************************

    STATE_STARTBOOTBLOCKWRITE : begin bootblock write sequence

 *********************************************************************************/





    case State_StartBootBlockWrite:

         switch(trans) {

             case Trans_CompleteBad:
             	  DBUG_PRINTF(DBUG_LVL_ERROR, "NCbootblock: couldn't start bootblock write sequence\n");
             	  set_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEFAIL);
             	  status_service_call();
             	  return(State_BadCard);

             case Trans_CompleteOK:

             	  if((l = pop_file_cmd())<0) { /* get the first file command */
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: no bootblock file write instructions\n");
		    return(State_BadCard);
		  }

		  trans_bb_ptr = trans_bb_buffer;

              case Trans_AuthRetry: /* re-entry point after authorization failure */

              	/* push state in case of auth. failure */
              	set_authstate(State_StartBootBlockWrite, Trans_AuthRetry);

	   	if(chv1_required) { /* haven't had a PIN yet - stop before we try to write any locked files */
	   	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: need a CHV1 code before proceeding\n");
	   	  set_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
	   	  status_service_call();
	   	  return(State_AuthFail);
	   	}

		l = pop_last_file_cmd(); /* don't need to check for -1, as it would have failed in Trans_CompleteOK */
             	DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: starting bootblock write sequence...\n");

  		r.r[0] = 0; /* do s/c filename validation */
             	r.r[1] = (int)bb_file_command[l].filename;
             	r.r[2] = bb_file_command[l].offset;
             	r.r[3] = (int)trans_bb_ptr;
             	r.r[4] = bb_file_command[l].bytes;
             	r.r[5] = (int)authblock.authblock_key;
             	r.r[6] = authblock.authblock_bytes;
             	_kernel_swi(SCInterface_Write, &r, &r); /* SCInterface_Read */
             	DBUG_PRINTF(DBUG_LVL_DIAG, "            return code: %d\n", r.r[0]);

             	if(r.r[0] == SC_SUCCESS) {  /* read started ok */

  		  return(State_WriteBootBlock);
  		}
  		else {
  		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard read error %d - aborting...\n", r.r[0]);
  		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEFAIL);
             	  status_service_call();

  		  return(State_BadCard);
  		}


             default: goto state_machine_error;

            }


/*********************************************************************************

    STATE_WRITEBOOTBLOCK : completion of attempt to write a bootblock file

 *********************************************************************************/

    case State_WriteBootBlock:

         switch(trans) {

           case Trans_AuthFail:
           	/* decide whether there's more work to do, set trans accordingly */
	        set_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL | BB_STATUS_WRITEFAIL);
	        clr_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEOK);
	        status_service_call();
		return(State_AuthFail);

           case Trans_CompleteBad:
	        clr_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEOK | BB_STATUS_AUTHFAIL);
	        set_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEFAIL);
	        status_service_call();
	        bootblock_trans = Trans_Finished; /* force state transition */
	        setcallback();
	        return(State_BootBlockWritten);

           case Trans_CompleteOK:
           	/* decide whether there's more work to do, set trans accordingly */

		l = pop_last_file_cmd();
		trans_bb_ptr += bb_file_command[l].bytes;

		if((l = pop_file_cmd())<0) { /* no more writing to do */
		  bootblock_trans = Trans_Finished;
		  setcallback(); /* force state transition */
		  return(State_BootBlockWritten);
		} else {
		    bootblock_trans = Trans_Next;
		    setcallback(); /* force state transition */
		    return(State_BootBlockWritten);
		}

           default: goto state_machine_error;

         }



/*********************************************************************************

    STATE_BOOTBLOCKWRITTEN : decide whether there is more writing to do

 *********************************************************************************/

    case State_BootBlockWritten:

         switch(trans) {

           case Trans_Next:
           	/* do SWI to write next file */
           	l = pop_last_file_cmd(); /* 'last' because we already popped once in previous state */
  		r.r[0] = 0; /* do s/c filename validation */
             	r.r[1] = (int)bb_file_command[l].filename;
             	r.r[2] = bb_file_command[l].offset;
             	r.r[3] = (int)trans_bb_ptr;
             	r.r[4] = bb_file_command[l].bytes;
             	r.r[5] = (int)authblock.authblock_key;
             	r.r[6] = authblock.authblock_bytes;
             	_kernel_swi(SCInterface_Write, &r, &r); /* SCInterface_Read */
             	DBUG_PRINTF(DBUG_LVL_DIAG, "            return code: %d\n", r.r[0]);

             	if(r.r[0] == SC_SUCCESS) {  /* read started ok */

  		  return(State_WriteBootBlock);
  		}
  		else {
  		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard write error %d - aborting...\n", r.r[0]);
  		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEFAIL);
             	  status_service_call();

  		  return(State_BadCard);
  		}


           	return(State_WriteBootBlock);

           case Trans_Finished:
	        clr_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEFAIL | BB_STATUS_AUTHFAIL);
	        set_status_bits(SELECT_SC_STATUS, BB_STATUS_WRITEOK);
	        status_service_call();

	        memcpy(sc_index, trans_index, trans_index_bytes);
	        memcpy(sc_bb_buffer, trans_bb_buffer, trans_bb_bytes);

	        sc_index_bytes = trans_index_bytes;
	        sc_bb_bytes = trans_bb_bytes;
	        bootblock_loaded = 1;
	        bootblock_authentic = 1;

           	return(State_CardInserted);

           default: goto state_machine_error;

         }

/*********************************************************************************
 *********************************************************************************
 *******************STATES*INVOLVED*IN*READING*ALTERNATE*RS*DATA******************
 *********************************************************************************
 *********************************************************************************/


/*********************************************************************************

    STATE_STARTALTERNATEREAD : begin alternate 1-800 read sequence

 *********************************************************************************/





    case State_StartAlternateRead:

         switch(trans) {

             case Trans_CompleteBad:
             	  DBUG_PRINTF(DBUG_LVL_ERROR, "NCbootblock: couldn't start bootblock read sequence\n");
             	  set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
             	  status_service_call();

             	  return(State_BadCard);

             case Trans_CompleteOK:

             	  if(alternate_rs_bytes > BOOTBLOCK_BUFFER_SIZE) {
             	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: alternate_block file too large\n");
             	      set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
             	      status_service_call();

             	      return(State_BadCard);
             	  }

             	  if((l = pop_file_cmd())<0) { /* get the first file command */
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: no alternate_block file instructions\n");
		    set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
             	    status_service_call();

		    return(State_BadCard);
		  }

		  sc_rs_ptr = sc_rs_buffer;
		  sc_rs_bytes = 0;

              case Trans_AuthRetry: /* re-entry point after authorization failure */

              	/* push state in case of auth. failure */
              	set_authstate(State_StartAlternateRead, Trans_AuthRetry);

	   	if(chv1_required) { /* haven't had a PIN yet - stop before we try to read any locked files */
	   	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: need a CHV1 code before proceeding\n");
	   	  set_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
	   	  status_service_call();
	   	  return(State_AuthFail);
	   	}

		l = pop_last_file_cmd(); /* don't need to check for -1, as it would have failed in Trans_CompleteOK */
             	DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: starting alternate read sequence...\n");

  		r.r[0] = 0; /* do s/c filename validation */
             	r.r[1] = (int)bb_file_command[l].filename;
             	r.r[2] = bb_file_command[l].offset;
             	r.r[3] = (int)sc_rs_ptr;
             	r.r[4] = bb_file_command[l].bytes;
             	r.r[5] = (int)authblock.authblock_key;
             	r.r[6] = authblock.authblock_bytes;
             	_kernel_swi(SCInterface_Read, &r, &r); /* SCInterface_Read */
             	DBUG_PRINTF(DBUG_LVL_DIAG, "            return code: %d\n", r.r[0]);

             	if(r.r[0] == SC_SUCCESS) {  /* read started ok */

  		  return(State_ReadAlternate);
  		}
  		else {
  		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard read error %d - aborting...\n", r.r[0]);
  		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
             	  status_service_call();

  		  return(State_BadCard);
  		}


             default: goto state_machine_error;

            }

/*********************************************************************************

    STATE_READALTERNATE : completion of an attempt to read a bootblock chunk

 *********************************************************************************/

    case State_ReadAlternate:

         switch(trans) {


           case Trans_AuthFail:
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: authorization failure reading alternate block data.\n");
                 set_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
                 status_service_call();

                 return(State_AuthFail);

           case Trans_CompleteBad:
           	DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: error reading alternate chunk - aborting\n");
           	clr_status_bits(SELECT_SC_STATUS, BB_STATUS_BB_VALID | BB_STATUS_AUTHFAIL);
           	set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
           	status_service_call();
           	return(State_BadCard);

           case Trans_CompleteOK:
           	/* determine whether there's more to read, and set trans accordingly */

           	clr_status_bits(SELECT_SC_STATUS, BB_STATUS_LOCKED | BB_STATUS_AUTHFAIL);
           	status_service_call();

		l = pop_last_file_cmd();
		sc_rs_ptr += bb_file_command[l].bytes;
		sc_rs_bytes += bb_file_command[l].bytes;

		if((l = pop_file_cmd())<0) { /* no more reading to do */
           	  bootblock_trans = Trans_Finished;
           	  setcallback(); /* force state transition */
           	  return(State_AlternateRead);
           	} else {
           	  bootblock_trans = Trans_Next;
           	  setcallback(); /* force state transition */
           	  return(State_AlternateRead);
           	}


           default: goto state_machine_error;

         }

/*********************************************************************************

    STATE_ALTERNATEREAD : decide whether there is more reading to do

 *********************************************************************************/

    case State_AlternateRead:

         switch(trans) {

           case Trans_Next:
           	/* do SWI to fetch next file */
           	l = pop_last_file_cmd(); /* 'last' because we already popped once in previous state */
  		r.r[0] = 0; /* do s/c filename validation */
             	r.r[1] = (int)bb_file_command[l].filename;
             	r.r[2] = bb_file_command[l].offset;
             	r.r[3] = (int)sc_rs_ptr;
             	r.r[4] = bb_file_command[l].bytes;
             	r.r[5] = (int)authblock.authblock_key;
             	r.r[6] = authblock.authblock_bytes;
             	_kernel_swi(SCInterface_Read, &r, &r); /* SCInterface_Read */
             	DBUG_PRINTF(DBUG_LVL_DIAG, "            return code: %d\n", r.r[0]);

             	if(r.r[0] == SC_SUCCESS) {  /* read started ok */

  		  return(State_ReadAlternate);
  		}
  		else {
  		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard read error %d - aborting...\n", r.r[0]);
  		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_READFAIL);
             	  status_service_call();

  		  return(State_BadCard);
  		}




           	return(State_ReadAlternate);

           case Trans_Finished:
                /* we're finished reading from the smartcard */

                /* do something secure to decide whether it's authentic or not */
                if(authenticate_altblock(sc_rs_buffer, sc_rs_bytes)>0) {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: alternate block auth SUCCEEDED\n");
                    alternate_rs_loaded = 1;
                } else {
                    DBUG_PRINTF(DBUG_LVL_ERROR, "NCbootblock: alternate block auth FAILED\n");
#ifdef AUTHENTICATE_SIGNATURES
                    alternate_rs_loaded = 0;
#else
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: overriding auth result\n");
		    alternate_rs_loaded = 1;
#endif

                }
		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_READOK);
             	  status_service_call();

                  return(State_CardInserted);

           default: goto state_machine_error;

         }


/*********************************************************************************
 *********************************************************************************
 *******************AUTHENTICATION*RELATED*STUFF**********************************
 *********************************************************************************
 *********************************************************************************/


/*********************************************************************************

    STATE_AUTHFAIL : authentication failure - idle state until correct PIN is supplied

 *********************************************************************************/

    case State_AuthFail:
    	 switch(trans) {

    	   case Trans_AuthRetry: /* standard authentication retry handler */

    	        DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: initiating authentication retry...\n");

		clr_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);

		if((sc_status & (BB_STATUS_LOCKED |BB_STATUS_PIN)) != (BB_STATUS_LOCKED | BB_STATUS_PIN)) {
		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_PIN | BB_STATUS_LOCKED);
		}

    	        if(authfail_state != State_NoCard) {
    	          bootblock_trans = Trans_AuthRetry;
    	          bootblock_state = authfail_state;
    	          authfail_trans = Trans_Idle;
    	          authfail_state = State_NoCard;
    	          setcallback();
    	        } else {
    	          /* no action, so we become idle */
    	          bootblock_trans = Trans_Idle;
    	          bootblock_state = State_CardInserted;
    	        }
    	        return(bootblock_state);

	   case Trans_UnblockCHV: /* unblocking the card */

                /* perform SWI to unblock Cardholder Verification Value */
		clr_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);

	   	DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: unblocking CHV1 code\n");
	   	strcpy(filename, "/");
	   	r.r[0] = 0;
	   	r.r[1] = (int)filename;
	   	r.r[2] = 0x1;
	   	r.r[3] = (int)authblock_unblock.authblock_key;
	   	r.r[4] = authblock_unblock.authblock_bytes;
	   	r.r[5] = (int)authblock.authblock_key;
	   	r.r[6] = authblock.authblock_bytes;
	   	_kernel_swi(SCInterface_UnBlockCHV, &r, &r);

          	if(r.r[0] != SC_SUCCESS) {  /* write started badly */
		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard auth. unblock error %d - aborting...\n", r.r[0]);
		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
		  status_service_call();
		}

		return(State_AuthFail);
    	        break;

           case Trans_ChangeCHV: /* user can do an alter pin instead of straight pin entry */

                /* perform SWI to change Cardholder Verification Value */
		clr_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);

                DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: changing CHV1...\n");
                strcpy(filename, "/4e43");
                r.r[0] = 0; /* validate smartcard filenames */
                r.r[1] = (int)filename;
                r.r[2] = 0x1; /* select CHV1 */
                r.r[3] = (int)authblock.authblock_key;
                r.r[4] = authblock.authblock_bytes;
                r.r[5] = (int)authblock_new.authblock_key;
                r.r[6] = authblock_new.authblock_bytes;
                _kernel_swi(SCInterface_ChangeCHV, &r, &r);

           	if(r.r[0] != SC_SUCCESS) {  /* write started badly */
		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: smartcard auth. change error %d - aborting...\n", r.r[0]);
		  set_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
		  status_service_call();
		}

		return(State_AuthFail);
    	        break;


          case Trans_AuthFail: /* handle return codes from a CHV change within AuthFail state */
           case Trans_CompleteBad:

           	DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: authentication failure on CHV change request.\n");
           	set_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
           	status_service_call();
           	return(State_AuthFail);

           case Trans_CompleteOK:

                DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: CHV change completed OK.\n");
                update_authblock();
                if((sc_status & BB_STATUS_PIN)==0) set_status_bits(SELECT_SC_STATUS, BB_STATUS_PIN);
                clr_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
                status_service_call();

    	        if(authfail_state != State_NoCard) {
    	          bootblock_trans = Trans_AuthRetry;
    	          bootblock_state = authfail_state;
    	          authfail_trans = Trans_Idle;
    	          authfail_state = State_NoCard;
    	          setcallback();
    	        } else {
    	          /* no action, so we become idle */
    	          bootblock_trans = Trans_Idle;
    	          bootblock_state = State_CardInserted;
    	        }
    	        return(bootblock_state);



           default: goto state_machine_error;

    	 }


/*********************************************************************************

    STATE_CHANGECHV : the user has requested that the s/c CHV1 PIN be changed

 *********************************************************************************/

    case State_ChangeCHV:
         switch(trans) {

           case Trans_AuthFail:
           case Trans_CompleteBad:

           	DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: authentication failure on CHV change request.\n");
           	set_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
           	status_service_call();
           	return(State_CardInserted);

           case Trans_CompleteOK:

                DBUG_PRINTF(DBUG_LVL_DIAG, "NCbootblock: CHV change completed OK.\n");
                update_authblock();
                if((sc_status & BB_STATUS_PIN)==0) set_status_bits(SELECT_SC_STATUS, BB_STATUS_PIN);
                clr_status_bits(SELECT_SC_STATUS, BB_STATUS_AUTHFAIL);
                status_service_call();
                return(State_CardInserted);

           default: goto state_machine_error;
         }

/*********************************************************************************

    STATE_BADCARD : an invalid smartcard has been inserted

 *********************************************************************************/

    case State_BadCard:

         switch(trans) {

           case Trans_CardRemoved:
                clr_status_bits(SELECT_SC_STATUS, BB_STATUS_INSERTED);
                status_service_call();
                return(State_NoCard);

           default: goto state_machine_error;

         }

/*********************************************************************************

    STATE_ERROR : an unrecoverable error has occured - this state is FINAL

 *********************************************************************************/

    case State_Error:
    default:
         return(State_Error);

  }

state_machine_error:

  /* ignore i/o acks that we weren't expecting - these may have been generated by support modules
     or by a completely different app.
  */

  if((trans == Trans_CompleteOK) || (trans == Trans_CompleteBad) || (trans == Trans_AuthFail)) {
    DBUG_PRINTF(DBUG_LVL_DEBUG, "NCbootblock: spurious I/O ACK from smartcard driver...ignoring\n");
    return(bootblock_state);
  }

  /* otherwise . . . PANIC!! */

  DBUG_PRINTF(DBUG_LVL_PANIC, "NCbootblock: state machine panic - invalid transition event %s in state %s\n",
  		      trans_string(bootblock_trans), state_string(bootblock_state));
  DBUG_PRINTF(DBUG_LVL_PANIC, "            setting state to State_Error\n");
  return(State_Error);
}
