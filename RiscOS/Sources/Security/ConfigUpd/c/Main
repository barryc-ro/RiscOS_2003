/**************************************************************************
* $Id$
* $Name$
*
* Author(s):  David Cotton
* Project(s): Lazarus (300), Bethany (333)
*
* ----------------------------------------------------------------------------
* Copyright [2000] Pace Micro Technology PLC.  All rights reserved.
*
* The copyright in this material is owned by Pace Micro Technology PLC
* ("Pace").  This material is regarded as a highly confidential trade secret
* of Pace.  It may not be reproduced, used, sold or in any other way exploited
* or transferred to any third party without the prior written permission of
* Pace.
*
* ----------------------------------------------------------------------------
* Purpose:
*
*
* ----------------------------------------------------------------------------
* History: See source control system log
*
*****************************************************************************/


/*****************************************************************************
* Include header files
*****************************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#include "swis.h"
#include "Debuglib/Debuglib.h"
#include "NVRAM.h"
#include "kernel.h"

/* Include headers from ncmalib */
#include "ncma_tags.h"
#include "dynalloc.h"
#include "smcard.h"
#define PROTOTYPES_INTERNAL
#include "smtags.h"
#define PROTOTYPES_INTERNAL
#include "ncma_bootb.h"
#include "ncma_scard.h"
#include "ncma_utils.h"
#include "cu_nvram.h"
#include "cu_main.h"
#include "cu_utils.h"
#include "cu_exclusn.h"
#include "cu_errors.h"
#include "module.h"

/*****************************************************************************
* MACROS
*****************************************************************************/


/* Forward prototypes */
bool check_values(void);

static bool parse_line(char* line, sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb, const unsigned int line_number);
static int match_values(const char* const target, const char* const tag, const char* const value, sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb);
static int return_struct_position_from_ncitag_number(const int number, sc_bootblock_data_struct* bbdata);
static bool write_values(sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb, int flags);
static bool validate_values(sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb, int flags, const char* const filename);
bool read_exclusions_file(const char* const filename);

static char* exclusions_filename = "Resources:$.Resources.configupd.exclude";

/*****************************************************************************
* Internal flags
*****************************************************************************/
static struct
{
  bool incremental_update;
  char* return_url;
  int session_id;
} upgrade_file_flags;


field biglist[] =
{
  {"ISPTelephoneNumber",             TagType_String, 32,  0x33, true},
  {"UserName",                       TagType_String, 256, 0x31, true},
  {"Password",                       TagType_String, 256, 0x32, true},
  {"HomeURL",                        TagType_String, 256, 0x16, true},
  {"DomainName",                     TagType_String, 256, 0x20, true},
  {"DNSServer1",                     TagType_IP,     16,  0x24, true},
  {"DNSServer2",                     TagType_IP,     16,  0x25, false},
  {"DialScript",                     TagType_String, 512, 0x40, true},
  {"TimeServer",                     TagType_String, 256, 0x47, false},
  {"EmailURL",                       TagType_String, 256, 0x72, true},
  {"HTTPProxyServer",                TagType_String, 256, 0x22, false},
  {"FTPProxyServer",                 TagType_String, 256, 0x23, false},
  {"SearchURL",                      TagType_String, 256, 0x70, true},
  {"ISPName",                        TagType_String, 32,  0x02, false},
  {"ISPCAccessPassword",             TagType_String, 11,  0x501, true},
  {"NCMAHiddenPhoneNumber",          TagType_String, 15,  0x502, true},
  {"NCMAStartHiddenDialPassword",    TagType_String, 11,  0x503, true},
  {"DefaultTerritory",               TagType_String, 256, 0x504, true},
  {"DefaultCountry",                 TagType_String, 256, 0x505, true},
  {"DefaultTimeZone",                TagType_String, 256, 0x506, true},
  {"ModemCountry",                   TagType_String, 256, 0x507, true},
  {"CSFSTypeRO",                     TagType_String, 256, 0x10, false},
  {"CSFSServerRO",                   TagType_String, 256, 0x12, false},
  {"CSFSPathRO",                     TagType_String, 256, 0x14, false},
  {"CSFSUserRO",                     TagType_String, 256, 0x1C, false},
  {"CSFSPasswordRO",                 TagType_String, 256, 0x1D, false},
  {"CSFSTypeRW",                     TagType_String, 256, 0x11, false},
  {"CSFSServerRW",                   TagType_String, 256, 0x13, false},
  {"CSFSPathRW",                     TagType_String, 256, 0x15, false},
  {"CSFSUserRW",                     TagType_String, 256, 0x1A, false},
  {"CSFSPasswordRW",                 TagType_String, 256, 0x1B, false},
  {"BootblockWritten",               TagType_String, 256, 0x73, false},
  {"Registration_PSTN_Num",          TagType_String, 256, 0x74, true},
  {"NCMARegistrationServerPassword", TagType_String, 256, 0x508, true},
  {NULL, TagType_Nul, 0, 0x0, false}
};


/* This routine parses the filename passed in for the flags. It searches for the following flags (as defied in the FS):
   INCREMENTAL_UPDATE_BOOTBLOCK
   RETURN_URL
   SESSION_ID
   It returns false if the file is malformed or does not contain the RETURN_URL or SESSION_ID.
*/
static bool parse_file_for_flags(const char* const memory_pointer, const int memory_area_size)
{
  char* line = NULL;
  char* alt = NULL;
  unsigned int count = 0;
  char* memory = (char*)memory_pointer;

  dprintf (("", "parse_file_for_flags(): Parsing memory area at %p.\n", memory_pointer));

  /* Reset the upgrade_file_flags structure. */
  upgrade_file_flags.session_id = 0;
  if (upgrade_file_flags.return_url != NULL)
  {
    dprintf (("", "parse_file_for_flags(): Freeing upgrade file flags return_url\n"));
    rmfree ((unsigned char*)upgrade_file_flags.return_url);
  }
  upgrade_file_flags.return_url = NULL;
  upgrade_file_flags.incremental_update = false;

  /* Read the file line-by-line */
  do
  {
    line =  get_line_buffer(memory, memory_pointer+memory_area_size);
    if (line)
    {
      dprintf(("", "parse_file_for_flags(): line is %s (count %d memory_area_size %d)\n", line, count, memory_area_size));
      count+=strlen(line)+1;
      memory+=strlen(line)+1;

      alt = RipNTrim(line);
      if (strlen(alt) > 1)
      {
        convert_linefeeds(alt);
      }
      else
      {
        /* Line is blank; move onto the next line. */
        continue;
      }

      dprintf(("", "parse_file_for_flags(): line is %s\n", alt));

      /* Search the line for the magic keywords */
      if (strncmp(alt, "INCREMENTAL_UPDATE_BOOTBLOCK", 28) == 0)
      {
        upgrade_file_flags.incremental_update = true;
        dprintf(("", "parse_file_for_flags(): Incremental update set.\n"));
      }

      if (strncmp(alt, "RETURN_URL=", 11) == 0)
      {
        char* pos = NULL;
        dprintf(("", "parse_file_for_flags(): return_url spotted.\n"));
        /* Strip off the "return_url" string */
        pos = strstr(alt, "RETURN_URL=")+strlen("RETURN_URL=");
        upgrade_file_flags.return_url=(char*)rmalloc(strlen(pos)+1, "Return URL storage");
        strcpy(upgrade_file_flags.return_url, pos);
        dprintf(("", "parse_file_for_flags(): return URL set to %s.\n", upgrade_file_flags.return_url));
      }

      if (strncmp(alt, "SESSION_ID=", 11) == 0)
      {
        /* Strip off the session id number */
        char* pos = strstr(alt, "SESSION_ID=")+strlen("SESSION_ID=");
        upgrade_file_flags.session_id = atoi(pos);
        dprintf(("", "parse_file_for_flags(): Session ID set to %d.\n", upgrade_file_flags.session_id));
      }
    }
    else
    {
      /* Skip over blank lines. */
      memory++;
     count++;
    }
  }
  while ((count < memory_area_size));

  /* Ensure the correct values have been set. */
  if (!upgrade_file_flags.return_url)
  {
    /* Add the relevant error to the errors file. */
    char error_string[255];
    sprintf(error_string, "Mandatory flag RETURN_URL missing.");
    append_error(error_string, E_ERROR_MANDATORY_FLAG_ABSENT, 1);
    return (false);
  }
  if (upgrade_file_flags.session_id == 0)
  {
    /* Add the relevant error to the errors file. */
    char error_string[255];
    sprintf(error_string, "Mandatory flag SESSION_ID missing.");
    append_error(error_string, E_ERROR_MANDATORY_FLAG_ABSENT, 2);
    return (false);
  }

  return (true);
}




/*
  This routine opens the configuation file and reads in the lines.
  It returns true if the file was parse correctly, false otherwise.
*/
static bool parse_file(const char* const memory_pointer, const int memory_area_size, sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb)
{
  char* line = NULL;
  unsigned int byte_count = 0;
  unsigned int line_count = 0;
  char* memory = (char*) memory_pointer;

  dprintf(("", "parse_file(): Parsing file at %p (size %d)\n", memory, memory_area_size));

  /* Read the file line-by-line */
  do
  {
    line =  get_line_buffer(memory, memory_pointer+memory_area_size);
    line_count++;
    if (line)
    {
      dprintf(("", "parse_file(): line is %s (count %d memory_area_size %d)\n", line, byte_count, memory_area_size));
      byte_count+=strlen(line)+1;
      memory+=strlen(line)+1;
      if (!parse_line(line, main_bb, default_bb, line_count))
      {
        dprintf(("", "parse_file(): Error parsing line %d of CU file.\n", line_count));
        return (false);
      }
    }
    else
    {
      /* Skip over blank lines. */
      memory++;
      byte_count++;
    }
  }
  while ((byte_count < memory_area_size));

  return (true);
}







/*
  This routine takes a line from the configuration file and parses it. If the
   line contains a valid tag/value combination it returns true, otherwise it
   returns false.
*/
bool parse_line(char* line, sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb, const unsigned int line_number)
{
  char* ptr = NULL;
  char target_buffer[LINE_BUFFER_SIZE];
  char tag_buffer[LINE_BUFFER_SIZE];
  char* target = NULL;
  char* tag = NULL;
  char val[LINE_BUFFER_SIZE];
  int field_number = 0;

  dprintf(("", "parse_line(): Parsing line %s\n", line));

  /* Trim the line (eg. remove comments)... */
  line = RipNTrim(line);
  if (strlen(line) > 1)
  {
    convert_linefeeds(line);
    dprintf(("", "parse_line(): Line is %s\n", line));
  }
  else
  {
    /* Blank line */
    return (true);
  }

  /* Ignore the line if it is a flags line. */
  if (strncmp(line, "SESSION_ID=", 11) == 0)
  {
    return(true);
  }
  if (strncmp(line, "RETURN_URL=", 11) == 0)
  {
    return(true);
  }
  if (strncmp(line, "INCREMENTAL_UPDATE_BOOTBLOCK", 28) == 0)
  {
    return(true);
  }

  /* Now split the line into a <loc>:<tag>=<value> couplet. */
  ptr = strpbrk(line,":");
  while (*ptr==' ') ptr++; /* Skip whitespace. */
  if (!ptr)
  {
    /*  No : seperator, therefore line is malformed */
    char error_string[255];
    dprintf(("", "parse_line(): No : seperator, therefore line is malformed\n"));
    sprintf(error_string, "Line %d malformed (No : seperator)", line_number);
    append_error(error_string, E_ERROR_MALFORMED_UPDATE_FILE, line_number);
    return (false);
  }
  else
  {
    int target_length = ptr-line; /* Warning, horrible pointer maths - may not be necesarilly portable */
    strncpy(target_buffer, line, target_length);
    target_buffer[target_length]='\0'; /* Add a terminator */
    target=RipNTrim(target_buffer);
    dprintf(("", "parse_line(): Target is %s (length %d) \n", target, target_length));
    line=ptr+1; /* Move pointer to past the target */
  }

  /* Decode the tag name and value */
  ptr = strpbrk(line,"=");
  if (!ptr)
  {
    /*  No = seperator, therefore line is malformed */
    char error_string[255];
    sprintf(error_string, "Line %d malformed (No = seperator)", line_number);
    append_error(error_string, E_ERROR_MALFORMED_UPDATE_FILE, line_number);
    return (false);
  }
  else
  {
    int tag_length = ptr-line; /* Warning, horrible pointer maths - may not be necesarilly portable */
    strncpy(tag_buffer, line, tag_length);
    tag_buffer[tag_length]='\0'; /* Add a terminator */
    tag=RipNTrim(tag_buffer);
    strcpy(val, ptr+1);
    dprintf(("", "parse_line(): Tag is %s (length %d)  Val is %s\n", tag, tag_length, val));
    if ((field_number = match_values(target, tag, val, main_bb, default_bb)) < 0)
    {
      char error_string[255];
      dprintf(("", "parse_line(): Error: Tag %s not recognised in target %s.\n", tag, target));
      sprintf(error_string, "Tag not recognised in target at line %d", line_number);
      append_error(error_string, E_ERROR_UNRECOGNISED_TAG, line_number);
    }
  }

  return (true);
}





/* This routine is the main routine that is called when reading in a
    Configuration Update file. It is called from the ConfigurationUpdate_
    AcceptFile SWI. */
bool read_configuration_file(const char* const memory_area, const int memory_area_size, const int configs_to_update)
{
  sc_bootblock_data_struct* default_bootblock;
  sc_bootblock_data_struct* main_bootblock;

  dprintf(("", "read_configuration_file()\n"));
  debug_rmstat();

  /* Clear all errors ready for new operation. */
  clear_error_structure();

  /* Parse a configuration file. */
  default_bootblock = (sc_bootblock_data_struct*)rmalloc(sizeof(sc_bootblock_data_struct), "Default bootblock");
  main_bootblock = (sc_bootblock_data_struct*)rmalloc(sizeof(sc_bootblock_data_struct), "Main bootblock");

  if (!read_exclusions_file(exclusions_filename))
  {
    /* An error occured reading the exclusions file... */
    char error_string[255];
    sprintf(error_string, "Could not open exclusions file %s", exclusions_filename);
    append_error(error_string, E_ERROR_EXCLUSIONS_FILE_ABSENT, -1);
    dprintf(("", "validate_values(): Error: Error loading exclusions file %s.\n", exclusions_filename));
    return (false);
  }

  /* Obtain the flags from the file. */
  dprintf(("", "read_configuration_file(): Parsing file for flags.\n"));
  if (!parse_file_for_flags(memory_area, memory_area_size))
  {
    /* An error occured. */
    dprintf(("", "read_configuration_file(): Error: Error occured whilst parsing for flags. Aborting file load.\n"));
    return (false);
  }

  dprintf(("", "read_configuration_file(): Initialising structures.\n"));
  initialise_sc_bootblock_data_struct(default_bootblock);
  initialise_sc_bootblock_data_struct(main_bootblock);

  /* Only read the existing main and default bootblock values if we are
      doing an incremental update */
  if (upgrade_file_flags.incremental_update)
  {
    int error;
    dprintf(("", "read_configuration_file(): Performing an incremental update\n"));
    error = read_bootblock_from_nvram(default_bootblock, "BootBlockDefault");
    if (error <= 0)
    {
      dprintf(("", "read_configuration_file(): Error %d whilst reading default Bootblock\n", error));
    }
    error = read_bootblock_from_ncbootblock(main_bootblock);
    if (error <= 0)
    {
      dprintf(("", "read_configuration_file(): Error %d whilst reading main Bootblock\n", error));
    }
  }

  /* Parse the file and save the altered bootblock tags. */
  parse_file(memory_area, memory_area_size, main_bootblock, default_bootblock);

  /* Debug display contents of lists. */
  debug_display_exclusions_list();

  /* Now check that the values are valid. */
  if (!validate_values(main_bootblock, default_bootblock, configs_to_update, exclusions_filename))
  {
    dprintf(("", "read_configuration_file(): Error whilst validating alterations.\n"));
  }

  /* Now write all the values */
  write_values(main_bootblock, default_bootblock, configs_to_update);

  /* Free all allocated memory */
  if (is_exclusions_file_valid() == 1)
  {
    /* Deallocate all memory pertaining to the exclusions file handling. */
    clear_exclusions_file();
  }
  free_sc_bootblock_data_struct(default_bootblock);
  free_sc_bootblock_data_struct(main_bootblock);
  free_nvram_tags_list();
  rmfree((unsigned char*)default_bootblock);
  rmfree((unsigned char*)main_bootblock);

  /* Free any line buffer that may have been allocated... */
  free_line_buffer();

  {
    /* Display error(s) */
    unsigned int number = 0;
    char* retval = return_errors(&number);
    if (retval)
    {
      dprintf(("", "read_configuration_file(): %d errors (%s)\n", number, retval));
    }
    else
    {
      dprintf(("", "read_configuration_file(): %d errors\n", number));
    }

    /* Display all errors in a debug build. */
    debug_display_errors();
    /* Clear all memory used by the errors code during this operation. */
    clear_error_structure();
  }

  /* Check memory allocation (should not be anything allocated here). */
  debug_rmstat();

  return (true);
}






/* This routine returns an nci_tag number from the string passed in. If the
string does not match a tag, then -1 is returned. */
int return_nci_tag_number_from_tag_string(const char* const tag_string)
{
  int return_value = -1;
  int loop=0;
  dprintf(("", "return_nci_tag_number_from_tag_string(): string is %s\n", tag_string));

  for (loop=0; loop<SIZE_OF_BIGLIST; loop++)
  {
//    dprintf(("", "return_nci_tag_number_from_tag_string(): comparing %s and %s\n", biglist[loop].name, tag_string));
    if (strcmp(biglist[loop].name, tag_string) == 0) /* They match! */
    {
      return (biglist[loop].tag_number);
    }
  }

  return (return_value);
}




/*
  This routine returns the position in the bootblock structure of the element
in that structure which has an nci_tag number of 'number'. If the tag is not
found, -1 is returned.
*/

int return_struct_position_from_ncitag_number(const int number, sc_bootblock_data_struct* bbdata)
{
  int loop=0;
  for (loop=0; loop < MAX_TAG_CACHE; loop++)
  {
    if (bbdata->tag_cache->tag[loop].nci_tag == number)
    {
      return (loop);
    }
  }
  return (-1);
}






/* This routine searches for the tag passed in against the list of fields.
    It returns the number of the tag in the list, or -1 if it is not matched. */
int match_values(const char* const target, const char* const tag, const char* const value, sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb)
{
  int field_number = 0;
  TARGET_TYPE target_type = E_TARGET_TYPE_NO_TARGET;

  dprintf(("", "match_values(): Target %s Tag %s Value %s\n", target, tag, value));

  while (biglist[field_number].name) /* Scan through all the tags */
  {
    if (strcmp(biglist[field_number].name, tag) == 0) /* Tags match */
    {
      int tag_number = return_struct_position_from_ncitag_number(biglist[field_number].tag_number, main_bb);
      /* Store the value */
      dprintf(("", "match_values(): Tag type for %s is %d and tag number is %d (internal data structure position %d)\n", tag, biglist[field_number].type, biglist[field_number].tag_number, tag_number));
      if (biglist[field_number].tag_number > 500) /* It is an NVRAM tag */
      {
        char* altered_value = NULL;
        unsigned int size = convert_nvram_tag_to_internal_representation(field_number, value, &altered_value);

        /* Before writing the value, ensure that this tag is not excluded. */
        target_type = E_TARGET_TYPE_NVRAM;
        if (is_tag_excluded(biglist[field_number].tag_number, target_type))
        {
          char error_string[255];
          sprintf(error_string, "NVRAM tag %0x excluded from CU file.", biglist[field_number].tag_number);
          append_error(error_string, E_ERROR_EXCLUDED_TAG_INCLUDED, biglist[field_number].tag_number);
          dprintf(("","match_values(): Error: Tag %0x excluded.\n", biglist[field_number].tag_number));
        }

        dprintf(("", "match_values(): NVRAM Tag %s needs Value %s\n", tag, value));
        if (size == 0)
        {
          dprintf(("", "match_values(): Error converting tag %s to an internal value.\n", tag));
        }
        else
        {
          dprintf(("", "match_values(): Value is now %d\n", *altered_value));
          /* Fill the nvram_tags_list[] element with the new value. */
          fill_nvram_tags_list(altered_value, size, tag, field_number);
          dprintf(("", "match_values(): Freeing memory storing the altered_value.\n"));
          if (altered_value)
          {
            rmfree ((void*)altered_value);
          }
        }
        return (field_number);
      }
      else /* bootblock tag */
      {
        sc_bootblock_data_struct* target_bb = NULL;
        if (strcmp(target, "BBMAIN") == 0) /* A main bootblock tag */
        {
          target_bb = main_bb;
          target_type = E_TARGET_TYPE_MAIN_BB;
        }
        else
        {
          if (strcmp(target, "BBDEFAULT") == 0) /* A main bootblock tag */
          {
            target_bb = default_bb;
            target_type = E_TARGET_TYPE_DEFAULT_BB;
          }
          else
          {
            char error_string[255];
            sprintf(error_string, "Unrecognised target %s", target);
            append_error(error_string, E_ERROR_UNRECOGNISED_TARGET, -1);
            dprintf(("", "match_values(): Unrecognised target.\n"));
            return (-1);
          }
        }

        /* Search through the tag cache in the bootblock structure for this tag. */
        assert (tag_number < MAX_TAG_CACHE); /* Ensure number is within required range. */
        dprintf(("", "match_values(): Writing tag %s (value %s) to bootblock data...\n", tag, value));
        if (target_bb->tag_cache->tag[tag_number].val) /* Tag is not empty */
        {
          dprintf(("","match_values(): Freeing existing BB tag %s (%s)\n", tag, target_bb->tag_cache->tag[tag_number].val));
          rmfree((unsigned char*)target_bb->tag_cache->tag[tag_number].val);
        }

        /* Before writing the value, ensure that this tag is not excluded. */
        if (is_tag_excluded(target_bb->tag_cache->tag[tag_number].nci_tag, target_type))
        {
          char error_string[255];
          sprintf(error_string, "Bootblock tag %0x excluded from CU file.", target_bb->tag_cache->tag[tag_number].nci_tag);
          append_error(error_string, E_ERROR_EXCLUDED_TAG_INCLUDED, target_bb->tag_cache->tag[tag_number].nci_tag);
          dprintf(("","match_values(): Error: Tag %0x excluded.\n", target_bb->tag_cache->tag[tag_number].nci_tag));
        }

        /* Write the new values into the structure */
        dprintf(("","match_values(): Writing BB tag %s with value %s\n", tag, value));
        target_bb->tag_cache->tag[tag_number].val = (char*)rmalloc(strlen(value)+1, "Tag store.");
        if (!target_bb->tag_cache->tag[tag_number].val)
        {
          dprintf(("","match_values(): Error allcoating memory.\n"));
          return (-1);
        }
        strcpy (target_bb->tag_cache->tag[tag_number].val, value);
        target_bb->tag_cache->tag[tag_number].bytes = strlen (value);
        dprintf(("","match_values(): Tag %s now has value %s\n", tag, target_bb->tag_cache->tag[tag_number].val));
      }
      return (field_number);
    }
    field_number++;
  }

  dprintf(("","match_values(): routine finished.\n"));
  return (-1);
}







/* This routine writes all the correct values back to NVRAM and bootblocks. */
bool write_values(sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb, int flags_bitfield)
{
  dprintf(("", "write_values(): flags_bitfield is %d\n", flags_bitfield));
  /* Do main bootblock */
  if (flags_bitfield & (1L << 0))
  {
    char* bootblock = NULL;

    dprintf(("", "write_values(): Writing default bootblock values\n"));
    bootblock = create_bootblock(default_bb);
    if (!bootblock)
    {
      dprintf(("", "write_values(): Error creating default bootblock\n"));
    }
    else
    {
      display_bootblock_image(bootblock, SIZE_OF_BOOTBLOCK);
      /* Write the default bootblock to the NVRAM. */
      if (!write_nvram_value("BootBlockDefault", bootblock, SIZE_OF_BOOTBLOCK, true))
      {
        dprintf(("", "write_values(): Error attempting to write default bootblock to NVRAM\n"));
      }
      else
      {
        dprintf(("", "write_values(): Default bootblock successfully written to NVRAM.\n"));
      }
      /* Free the memory */
      rmfree((unsigned char*)bootblock);
    }
    service_configurationchanged((int)(flags_bitfield));
  }

  if (flags_bitfield & (1L << 1))
  {
    char* bootblock = NULL;
    _kernel_swi_regs regs;

    dprintf(("", "write_values(): Writing main bootblock values\n"));
    bootblock = create_bootblock(main_bb);
    if (!bootblock)
    {
      dprintf(("", "write_values(): Error creating main bootblock\n"));
    }
    else
    {
      display_bootblock_image(bootblock, SIZE_OF_BOOTBLOCK);

      /* Write the main bootblock to the NVRAM using a call to NCBootBlock. */
      regs.r[0] = (int)bootblock+8;
      regs.r[1] = SIZE_OF_BOOTBLOCK-8;

      if(_kernel_swi(NCBootblock_Write, &regs, &regs)!=NULL)
      {
        dprintf(("", "write_values(): NCBootblock Write SWI failed\n"));
        return(-1);
      }
      switch(regs.r[0])
      {
        case  0: dprintf(("", "write_values(): completed OK\n"));
                 break;
        case -1: dprintf(("", "write_values(): enterprise block not authentic\n"));
                 break;
        case -2: dprintf(("", "write_values(): enterprise block too big\n"));
                 return(-1);
                 break;
        case -3: dprintf(("", "write_values(): bootblock is readonly\n"));
                 break;
        case -4: dprintf(("", "write_values(): enterprise block is readonly\n"));
                 break;
        case -5: dprintf(("", "write_values(): file write error\n"));
                 return(-1);
                 break;
        case -6: dprintf(("", "write_values(): alternate block too big\n"));
                 break;
        case -7: dprintf(("", "write_values(): alternate block not authentic\n"));
                 break;
        default: dprintf(("", "write_values(): unrecognized return code from write SWI (&%x)\n",regs.r[0]));
                 break;
      }
      /* Free the memory */
      rmfree((unsigned char*)bootblock);
    }
    service_configurationchanged((int)(flags_bitfield));
  }

  if (flags_bitfield & (1L << 2))
  {
    dprintf(("", "write_values(): Writing NVRAM values\n"));
    display_nvram_tags_list();
    write_nvram_tags_list_to_nvram();
    service_configurationchanged((int)(flags_bitfield));
  }

  return (true);
}




/* This routine validates the values of the new data. This should only be called after all values have been read into the systam. It returns true if it thinks that the data is valid, false otherwise. */
bool validate_values(sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb, const int flags_bitfield, const char* const filename)
{
  dprintf(("", "validate_values(): Validating file %s\n", filename));
  if (flags_bitfield & (1L << 0))
  {
    dprintf(("", "validate_values(): Validating default bootblock values\n"));
    /* Go through all the default bootblock tags and ensure that the rules match. */
    validate_bootblock_data(default_bb);
  }

  if (flags_bitfield & (1L << 1))
  {
    dprintf(("", "validate_values(): Validating main bootblock values\n"));
  }

  if (flags_bitfield & (1L << 2))
  {
    dprintf(("", "validate_values(): Validating NVRAM values\n"));
  }

  return (true);
}



/****************************************************************************
* END OF FILE
****************************************************************************/

