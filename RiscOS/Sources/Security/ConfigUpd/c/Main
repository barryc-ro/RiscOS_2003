/*****************************************************************************
* $Id$
* $Name$
*
* Author(s):  David Cotton
* Project(s): Lazarus (300), Bethany (333)
*
* ----------------------------------------------------------------------------
* Copyright [2000] Pace Micro Technology PLC.  All rights reserved.
*
* The copyright in this material is owned by Pace Micro Technology PLC
* ("Pace").  This material is regarded as a highly confidential trade secret
* of Pace.  It may not be reproduced, used, sold or in any other way exploited
* or transferred to any third party without the prior written permission of
* Pace.
*
* ----------------------------------------------------------------------------
* Purpose:
*
*
* ----------------------------------------------------------------------------
* History: See source control system log
*
*****************************************************************************/


/*****************************************************************************
* Include header files
*****************************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#include "swis.h"
#include "Debuglib/Debuglib.h"
#include "NVRAM.h"
#include "kernel.h"

/* Include headers from ncmalib */
#include "ncma_tags.h"
#include "dynalloc.h"
#include "smcard.h"
#define PROTOTYPES_INTERNAL
#include "smtags.h"
#define PROTOTYPES_INTERNAL
#include "ncma_bootb.h"
#include "ncma_scard.h"
#include "ncma_utils.h"
#include "cu_nvram.h"
#include "cu_main.h"
#include "cu_utils.h"
#include "module.h"

/*****************************************************************************
* MACROS
*****************************************************************************/
/* This symbol defines the mazimum size any line in the file can be.
    It would be better to dynamically allocate the memory, but for this
    quick and simple program this will do */
#define LINE_BUFFER_SIZE 512


/* Forward prototypes */
bool check_values(void);
void display_bootblock_image(const char* const memory, const int size);

static int output_list_of_tags(const char* const filename, sc_bootblock_data_struct* bootblock, const char* const prefix);
static int return_external_number_from_bbtag_number(const int number);
static char* return_external_name_from_tag_number(const int number);
static bool parse_line(char* line, sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb);
static int match_values(const char* const target, const char* const tag, const char* const value, sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb);
static int return_struct_position_from_ncitag_number(const int number, sc_bootblock_data_struct* bbdata);
static bool write_values(sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb, int flags);
static bool validate_values(sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb, int flags);
bool read_exclusions_file(const char* const filename);
static char* create_bootblock(const sc_bootblock_data_struct* const main_bb);

static char* exclusions_filename[] = "Resources::$.!boot.exclude";

/*****************************************************************************
* Internal flags
*****************************************************************************/
static struct
{
  bool incremental_update;
  char* return_url;
  int session_id;
} upgrade_file_flags;


field biglist[] =
{
  {"ISPTelephoneNumber",             TagType_String, 32,  0x33, true},
  {"UserName",                       TagType_String, 256, 0x31, true},
  {"Password",                       TagType_String, 256, 0x32, true},
  {"HomeURL",                        TagType_String, 256, 0x16, true},
  {"DomainName",                     TagType_String, 256, 0x20, true},
  {"DNSServer1",                     TagType_IP,     16,  0x24, true},
  {"DNSServer2",                     TagType_IP,     16,  0x25, false},
  {"DialScript",                     TagType_String, 512, 0x40, true},
  {"TimeServer",                     TagType_String, 256, 0x47, false},
  {"EmailURL",                       TagType_String, 256, 0x72, true},
  {"HTTPProxyServer",                TagType_String, 256, 0x22, false},
  {"FTPProxyServer",                 TagType_String, 256, 0x23, false},
  {"SearchURL",                      TagType_String, 256, 0x70, true},
  {"ISPName",                        TagType_String, 32,  0x02, false},
  {"ISPCAccessPassword",             TagType_String, 11,  0x00, true},
  {"NCMAHiddenPhoneNumber",          TagType_String, 15,  0x00, true},
  {"NCMAStartHiddenDialPassword",    TagType_String, 11,  0x00, true},
  {"DefaultTerritory",               TagType_String, 256, 0x00, true},
  {"DefaultCountry",                 TagType_String, 256, 0x00, true},
  {"DefaultTimeZone",                TagType_String, 256, 0x00, true},
  {"ModemCountry",                   TagType_String, 256, 0x00, true},
  {"CSFSTypeRO",                     TagType_String, 256, 0x10, false},
  {"CSFSServerRO",                   TagType_String, 256, 0x12, false},
  {"CSFSPathRO",                     TagType_String, 256, 0x14, false},
  {"CSFSUserRO",                     TagType_String, 256, 0x1C, false},
  {"CSFSPasswordRO",                 TagType_String, 256, 0x1D, false},
  {"CSFSTypeRW",                     TagType_String, 256, 0x11, false},
  {"CSFSServerRW",                   TagType_String, 256, 0x13, false},
  {"CSFSPathRW",                     TagType_String, 256, 0x15, false},
  {"CSFSUserRW",                     TagType_String, 256, 0x1A, false},
  {"CSFSPasswordRW",                 TagType_String, 256, 0x1B, false},
  {"BootblockWritten",               TagType_String, 256, 0x73, false},
  {"Registration_PSTN_Num",          TagType_String, 256, 0x74, true},
  {"NCMARegistrationServerPassword", TagType_String, 256, 0x00, true},
  {NULL, TagType_Nul, 0, 0x0, false}
};


/* This routine parses the filename passed in for the flags. It searches for the following flags (as defied in the FS):
   INCREMENTAL_UPDATE_BOOTBLOCK
   RETURN_URL
   SESSION_ID
   It returns false if the file is malformed or does not contain the RETURN_URL or SESSION_ID.
*/
static bool parse_file_for_flags(const char* const filename)
{
  FILE* fp = NULL;
  char* line = NULL;
  char* alt = NULL;

  dprintf (("", "parse_file_for_flags(): file %s.\n", filename));

  line=(char*)rmalloc(LINE_BUFFER_SIZE, "Temporary line buffer");
  if (!line)
  {
    dprintf (("", "parse_file_for_flags(): Error allocating %d bytes for line.\n",LINE_BUFFER_SIZE));
    return (false);
  }

  /* Reset the upgrade_file_flags structure. */
  upgrade_file_flags.session_id = 0;
  if (upgrade_file_flags.return_url != NULL)
  {
    dprintf (("", "parse_file_for_flags(): Freeing upgrade file flags return_url\n"));
    rmfree ((unsigned char*)upgrade_file_flags.return_url);
  }
  upgrade_file_flags.return_url = NULL;
  upgrade_file_flags.incremental_update = false;

  /* Open the file */
  dprintf (("", "parse_file_for_flags(): Opening file %s.\n", filename));
  if ((fp = fopen(filename, "r")) == NULL)
  {
    dprintf (("", "parse_file_for_flags(): Error opening file %s.\n", filename));
    return (false);
  }

  /* Read the file line-by-line */
  while (fgets(line, LINE_BUFFER_SIZE, fp))
  {
    dprintf (("", "parse_file_for_flags():Line is %s.\n", line));
    alt = RipNTrim(line);
    if (strlen(alt) > 1)
    {
      convert_linefeeds(alt);
    }
    else
    {
      return (false);
    }

    /* Search for the magic keywords */
    dprintf(("", "parse_file_for_flags(): Line is %s\n", alt));
    if (strcmp(alt, "INCREMENTAL_UPDATE_BOOTBLOCK") == 0)
    {
      upgrade_file_flags.incremental_update = true;
      dprintf(("", "parse_file_for_flags(): Incremental update set.\n"));
    }

    if (strcmp(alt, "RETURN_URL=") == 0)
    {
      /* Strip off the "return_url" string */
      char* pos = strstr(alt, "RETURN_URL=")+strlen("RETURN_URL=");
      upgrade_file_flags.return_url=(char*)rmalloc(strlen(pos)+1, "Return URL storage");
      strcpy(upgrade_file_flags.return_url, pos);
      dprintf(("", "parse_file_for_flags(): return URL set to %s.\n", upgrade_file_flags.return_url));
    }

    if (strcmp(alt, "SESSION_ID=") == 0)
    {
      /* Strip off the session id number */
      char* pos = strstr(alt, "SESSION_ID=")+strlen("SESSION_ID=");
      upgrade_file_flags.session_id = atoi(pos);
      dprintf(("", "parse_file_for_flags(): Session ID set to %d.\n", upgrade_file_flags.session_id));
    }
  }

  /* Close the file */
  fclose(fp);

  rmfree((unsigned char*) line);

  /* Ensure the correct vales have been set. */
  if (!upgrade_file_flags.return_url || upgrade_file_flags.session_id == 0)
    return (false);

  return (true);
}




/*
  This routine opens the configuation file and reads in the lines.
  It returns true if the file was parse correctly, false otherwise.
*/
static bool parse_file(const char* const filename, sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb)
{
  FILE* fp = NULL;
  char line_buffer[LINE_BUFFER_SIZE];

  dprintf(("", "parse_file(): Parsing file %s\n", filename));

  /* Open the file */
  if ((fp = fopen(filename, "r")) == NULL)
  {
    dprintf (("", "parse_file(): Error opening file %s.\n", filename));
    return (false);
  }

  /* Read the file line-by-line */
  while (fgets(line_buffer, LINE_BUFFER_SIZE, fp))
  {
    parse_line(line_buffer, main_bb, default_bb);
  }

  /* Close the file */
  fclose(fp);

  return (true);
}







/*
  This routine takes a line from the configuration file and parses it. If the
   line contains a valid tag/value combination it returns true, otherwise it
   returns false.
*/
bool parse_line(char* line, sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb)
{
  char* ptr = NULL;
  char target[LINE_BUFFER_SIZE];
  char tag[LINE_BUFFER_SIZE];
  char val[LINE_BUFFER_SIZE];
  int field_number = 0;

  dprintf(("", "parse_line(): Parsing line %s", line));

  /* Trim the line (eg. remove comments)... */
  line = RipNTrim(line);
  if (strlen(line) > 1)
  {
    convert_linefeeds(line);
    dprintf(("", "parse_line(): Line is %s\n", line));
  }
  else
  {
    return (false);
  }

  /* Now split the line into a <loc>:<tag>=<value> couplet. */
  ptr = strpbrk(line,":");
  if (!ptr)
  {
    /*  No : seperator, therefore line is malformed */
    return (false);
  }
  else
  {
    int target_length = ptr-line; /* Warning, horrible pointer maths - may not be necesarilly portable */
    strncpy(target, line, target_length);
    target[target_length]='\0'; /* Add a terminator */
    dprintf(("", "parse_line(): Target is %s (length %d) \n", target, target_length));
    line=ptr+1; /* Move pointer to past the target */
  }

  /* Decode the tag name and value */
  ptr = strpbrk(line,"=");
  if (!ptr)
  {
    /*  No = seperator, therefore line is malformed */
    return (false);
  }
  else
  {
    int tag_length = ptr-line; /* Warning, horrible pointer maths - may not be necesarilly portable */
    strncpy(tag, line, tag_length);
    tag[tag_length]='\0'; /* Add a terminator */
    strcpy(val, ptr+1);
    dprintf(("", "parse_line(): Tag is %s (length %d)  Val is %s\n", tag, tag_length, val));
    if ((field_number = match_values(target, tag, val, main_bb, default_bb)) < 0)
    {
      dprintf(("", "parse_line(): Error: Tag %s not recognised in target %s.\n", tag, target));
    }
  }

  return (true);
}




/* This routine goes through the entered fields and checks to see if they have any values entered.
    If any fields must have a value and do not, then it returns false
*/
bool check_values(void)
{
  int field_number = 0;
  while (biglist[field_number].name) /* Scan through all the tags */
  {
    if (biglist[field_number].required && (strcmp(biglist[field_number].value,"")==0))
    {
      dprintf (("", "A value is expected for tag %s, and one has not been entered.\n", biglist[field_number].name));
      return (false);
    }

    /* Now ensure that if a value is present, it is shorter than the max length allowable for that field */
    if (strcmp(biglist[field_number].value,"")!=0) /* The field has a value */
    {
      if (strlen(biglist[field_number].value) > biglist[field_number].maxlen)
      {
        dprintf(("", "Tag %s is too long (is %d bytes, should be <%d)", biglist[field_number].name, strlen(biglist[field_number].value), biglist[field_number].maxlen));
        return (false);
      }
    }

    /* DefaultTerritory, DefaultCountry, and ModemCountry must specify countries
       that exist in the lookup table countries[]. */
    if ((field_number == e_tagname_defaultterritory) || (field_number == e_tagname_defaultcountry) || (field_number == e_tagname_modemcountry))
    {
      if (lookup_country(biglist[field_number].value) == 0)
      {
        dprintf(("", "Country '%s' specified in tag %s is not supported.\n", biglist[field_number].value, biglist[field_number].name));
        return (false);
      }
    }

    field_number++;
  }

  return (true);
}





/* This routine displays the nvram image in a format similar to that
    produced by the *dump RISC OS command (and hence to that shown in
    section 4 of the spec)
   As it displays the information in a series of 16 by 16 bytes blocks,
    the total size of the area being displayed should be a multiple of
    (16*16)=256 bytes. Behaviour for any other sized block is undefined.
*/
void display_bootblock_image(const char* const memory, const int size)
{
  unsigned int location = 0;
  unsigned int location2 = 0;

  dprintf(("", "display_bootblock_image(): Disaplying area of sizer %d starting at %p\n", size, memory));

  for (location=0; location < size; location+=(16*16))
  {
    dprintf(("", "\nAddress  : 00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F       ASCII data\n"));
    for (location2=location; location2 < location+(16*16); location2+=16)
    {
      unsigned int loop=0;
      dprintf(("", "%08X : ", location2));
      for (loop = 0; loop < 16; loop++)
      {
        dprintf(("", "%03X ", *(memory+location2+loop)));
      }
      dprintf(("", "  "));
      for (loop = 0; loop < 16; loop++)
      {
        /* Only display as characters if they are printable (i.e. in range 32 to 126). Otherwise print as a . */
        if (isprint(*(memory+location2+loop)))
        {
          dprintf(("", "%c", *(memory+location2+loop)));
        }
        else
        {
          dprintf(("", "."));
        }
      }
      dprintf(("", "\n"));
    }
  }
}


bool read_configuration_file(const char* const input_filename, int configs_to_update)
{
  {
    dprintf(("", "read_configuration_file()\n"));
    /* Parse a returned configuration file. */
    {
      sc_bootblock_data_struct* default_bootblock;
      sc_bootblock_data_struct* main_bootblock;
      default_bootblock = (sc_bootblock_data_struct*)rmalloc(sizeof(sc_bootblock_data_struct), "Default bootblock");
      main_bootblock = (sc_bootblock_data_struct*)rmalloc(sizeof(sc_bootblock_data_struct), "Main bootblock");

      /* Obtain the flags from the file. */
      dprintf(("", "read_configuration_file(): Parsing file for flags.\n"));
      parse_file_for_flags(input_filename);

      dprintf(("", "read_configuration_file(): Initialising structures.\n"));
      initialise_sc_bootblock_data_struct(default_bootblock);
      initialise_sc_bootblock_data_struct(main_bootblock);

      /* Only read the existing values if we are doing an incremental update */
      if (upgrade_file_flags.incremental_update)
      {
        int error;
        dprintf(("", "read_configuration_file(): Performing an incremental update\n"));
        error = read_bootblock_from_nvram(default_bootblock, "BootBlockDefault");
        if (error <= 0)
        {
          dprintf(("", "main(): Error %d whilst reading default Bootblock\n", error));
        }
        error = read_bootblock_from_ncbootblock(main_bootblock);
        if (error <= 0)
        {
          dprintf(("", "main(): Error %d whilst reading main Bootblock\n", error));
        }
      }

      /* Parse the file and save the altered bootblock tags. */
      parse_file(input_filename, main_bootblock, default_bootblock);

      /* Now check that the values are correct. */
      validate_values(main_bootblock, default_bootblock, configs_to_update);
      /* Now write all the values */
      write_values(main_bootblock, default_bootblock, configs_to_update);

      /* Free all allocated memory */
      free_sc_bootblock_data_struct(default_bootblock);
      free_sc_bootblock_data_struct(main_bootblock);
      free_nvram_tags_list();
      rmfree((unsigned char*)default_bootblock);
      rmfree((unsigned char*)main_bootblock);
    }
  }
  return (true);
}




/* This routine gets the current settings of the objects referred to in the
bitfield and createsa configuration file stating the current settings. */

void get_current_configuration(const unsigned int bitfield, const char* filename)
{
  /* Decode the bitfield (bit 1 = default bootblock, 2 = main bootblock, 3 = NVRAM tags */
  dprintf (("", "get_current_configuration(): value is %d\n", bitfield));
  if (bitfield & (1L << 0))
  {
    sc_bootblock_data_struct default_bootblock;
    int error = 0;
    dprintf(("", "get_current_configuration():   Bit 1 is set : default bootblock required\n"));
    initialise_sc_bootblock_data_struct(&default_bootblock);
    error = read_bootblock_from_nvram(&default_bootblock, "BootBlockDefault");
    error = output_list_of_tags(filename, &default_bootblock, "BBDEFAULT:");
    if (error <= 0)
    {
      dprintf(("", "get_current_configuration(): Error %d whilst building list of tags\n", error));
    }
    free_sc_bootblock_data_struct(&default_bootblock);
    rmstat();
  }

  if (bitfield & (1L << 1))
  {
    sc_bootblock_data_struct main_bootblock;
    int error = 0;
    dprintf(("", "get_current_configuration():   Bit 2 is set : main bootblock required.\n"));
    initialise_sc_bootblock_data_struct(&main_bootblock);
    error = read_bootblock_from_ncbootblock(&main_bootblock);
    error = output_list_of_tags(filename, &main_bootblock, "BBMAIN:");
    if (error <= 0)
    {
      dprintf(("", "get_current_configuration(): Error %d whilst building list of tags\n", error));
    }
    free_sc_bootblock_data_struct(&main_bootblock);
    rmstat();
  }

  if (bitfield & (1L << 2))
  {
    dprintf(("", "get_current_configuration():   Bit 3 is set : all known NVRAM tags required.\n"));
    output_nvram_tags(filename);
  }
}




/* This routine returns a pointer to the external name of the nci tag number passed in. The external name is that used in the CU file, whilst the tag number is the number of the bootblock/NVRAM tag as defind in smtags.h.
  The routine returns a pointer to the external name, or NULL if it was not found. The pointer returned by this routine *must not* be altered or free'd as it points to a static string in a structure. */

char* return_external_name_from_tag_number(const int tag)
{
  int number= return_external_number_from_bbtag_number(tag);
  dprintf(("", "return_external_name_from_tag_number(): External tag number of nci_tag %d is %d\n", tag, number));
  if (number < 0 || number > SIZE_OF_BIGLIST)
  {
    return (NULL); /* Not recognised. */
  }
  else
  {
    dprintf(("", "return_external_name_from_tag_number(): External tag name is %s\n", biglist[number].name));
    return (biglist[number].name);
  }
}




/* This routine outputs all known tags to the file passed in, in a format
specified in the FS. The 'prefix' string is added to the start of any line
output. */

int output_list_of_tags(const char* const filename, sc_bootblock_data_struct* bootblock, const char* const prefix)
{
  int l, m;
  FILE *f;

  dprintf(("", "output_list_of_tags(): List of tags present in the default bootblock:\n"));

  /* Open the output file for writing */
  if((f = fopen(filename, "a+"))==NULL)
  {
    dprintf(("", "output_list_of_tags(): couldn't open %s for writing\n", filename));
    return(0);
  }

  /* Go through all the tags one at a time. If they are present output them to the filename passed in. */
  for(l=0; l<MAX_TAG_CACHE; l++)
  {
    if(bootblock->tag_cache->tag[l].tag == NULL) break; /* no more tags */

    dprintf(("", "output_list_of_tags(): tag %d\n", l));
    if(bootblock->tag_cache->tag[l].bytes != 0) /* Tag has a value */
    {
       /* Map the tag number to an external CU file name */
       char* ext_name = return_external_name_from_tag_number(bootblock->tag_cache->tag[l].nci_tag);
       if (ext_name!=NULL)
       {
         fprintf(f, "%s%s=", prefix, ext_name);
       }
       else
       {
         dprintf(("", "output_list_of_tags(): Error, external name of tag %d not known", l));
       }

       switch(bootblock->tag_cache->tag[l].mapping)
       {
         case TAG_MAPPING_URL:
         case TAG_MAPPING_STRING:
         case TAG_MAPPING_HOST:
         case TAG_MAPPING_PROXY:
         {
           char* updated_string = convert_linefeeds_to_text(bootblock->tag_cache->tag[l].val);
           if (updated_string)
           {
             fprintf(f, "%s\n", updated_string);
             rmfree((void*)updated_string);
           }
           break;
         }

         case TAG_MAPPING_INT:
         case TAG_MAPPING_IP:
         {
           char val2[255];
           dprintf(("", "output_list_of_tags(): val is %s\n", (char *)(bootblock->tag_cache->tag[l].val)));
           ip_ntos(val2, (char *)(bootblock->tag_cache->tag[l].val));
           fprintf(f, "%s\n", val2);
           break;
         }

         case TAG_MAPPING_SOAK:
         case TAG_MAPPING_PLIP:
           m = read_little_word((char *)(bootblock->tag_cache->tag[l].val));
           fprintf(f, "%s\n", m?"ENABLED":"DISABLED");
           break;

         default:
           fprintf(f, "???\n");
           break;
       }
    }
  }

  /* And close the file */
  fclose(f);

  return (1);
}



/* This routine returns the tag number of the tag name passed in. It returns -1 if the tag cannot be found in the module's internal list. */
int return_external_number_from_bbtag_number(const int number)
{
  int loop = 0;

  for (loop=0; loop<SIZE_OF_BIGLIST; loop++)
  {
    if (biglist[loop].tag_number == number) /* They match! */
    {
      return (loop);
    }
  }

  return (-1); /* Error! tag not found. */
}



int return_struct_position_from_ncitag_number(const int number, sc_bootblock_data_struct* bbdata)
{
  int loop=0;
  for (loop=0; loop < MAX_TAG_CACHE; loop++)
  {
    if (bbdata->tag_cache->tag[loop].nci_tag == number)
    {
      return (loop);
    }
  }
  return (-1);
}






/* This routine searches for the tag passed in against the list of fields.
    It returns the number of the tag in the list, or -1 if it is not matched. */
int match_values(const char* const target, const char* const tag, const char* const value, sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb)
{
  int field_number = 0;

  dprintf(("", "match_values(): Target %s Tag %s Value %s\n", target, tag, value));

  while (biglist[field_number].name) /* Scan through all the tags */
  {
    if (strcmp(biglist[field_number].name, tag) == 0) /* Tags match */
    {
      int tag_number = return_struct_position_from_ncitag_number(biglist[field_number].tag_number, main_bb);
      /* Store the value */
      dprintf(("", "match_values(): Tag type for %s is %d and tag number is %d (internal data structure position %d)\n", tag, biglist[field_number].type, biglist[field_number].tag_number, tag_number));
      if (biglist[field_number].tag_number == 0) /* It is an NVRAM tag */
      {
        char* altered_value = NULL;
        unsigned int size = convert_nvram_tag_to_internal_representation(field_number, value, &altered_value);
        dprintf(("", "match_values(): NVRAM Tag %s needs Value %s\n", tag, value));
        if (size == 0)
        {
          dprintf(("", "match_values(): Error converting tag %s to an internal value.\n", tag));
        }
        else
        {
          dprintf(("", "match_values(): Value is now %d\n", *altered_value));
          /* Fill the nvram_tags_list[] element with the new value. */
          fill_nvram_tags_list(altered_value, size, tag, field_number);
          dprintf(("", "match_values(): Freeing memory storing the altered_value.\n"));
          if (altered_value)
          {
            rmfree ((void*)altered_value);
          }
        }
        return (field_number);
      }
      else /* bootblock tag */
      {
        sc_bootblock_data_struct* target_bb = NULL;
        if (strcmp(target, "BBMAIN") == 0) /* A main bootblock tag */
        {
          target_bb = main_bb;
        }
        else
        {
          if (strcmp(target, "BBDEFAULT") == 0) /* A main bootblock tag */
          {
            target_bb = default_bb;
          }
          else
          {
             dprintf(("", "match_values(): Silly value for target.\n"));
             return (-1);
          }
        }

        /* Search through the tag cache in the bootblock structure for this tag. */
        assert (tag_number < MAX_TAG_CACHE); /* Ensure number is within required range. */
        dprintf(("", "match_values(): Writing tag %s (value %s) to bootblock data...\n", tag, value));
        if (target_bb->tag_cache->tag[tag_number].val) /* Tag is not empty */
        {
          dprintf(("","match_values(): Freeing existing BB tag %s (%s)\n", tag, target_bb->tag_cache->tag[tag_number].val));
          rmfree((unsigned char*)target_bb->tag_cache->tag[tag_number].val);
        }
        /* Write the new values into the structure */
        dprintf(("","match_values(): Writing BB tag %s with value %s\n", tag, value));
        target_bb->tag_cache->tag[tag_number].val = (char*)rmalloc(strlen(value)+1, "Tag store.");
        if (!target_bb->tag_cache->tag[tag_number].val)
        {
          return (-1);
        }
        strcpy (target_bb->tag_cache->tag[tag_number].val, value);
        target_bb->tag_cache->tag[tag_number].bytes = strlen (value);
        dprintf(("","match_values(): Tag %s now has value %s\n", tag, target_bb->tag_cache->tag[tag_number].val));
      }
      return (field_number);
    }
    field_number++;
  }

  dprintf(("","match_values(): routine finished.\n"));
  return (-1);
}






/* This routine validates the values of the new data. This should only be called after all values have been read into the systam. */
bool validate_values(sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb, const int flags_bitfield)
{
  dprintf(("", "validate_values()\n"));

  read_exclusions_file((char*)exclusions_filename);

  if (flags_bitfield & (1L << 0))
  {
    dprintf(("", "validate_values(): Validating default bootblock values\n"));
  }

  if (flags_bitfield & (1L << 1))
  {
    dprintf(("", "validate_values(): Validating main bootblock values\n"));
  }

  if (flags_bitfield & (1L << 2))
  {
    dprintf(("", "validate_values(): Validating NVRAM values\n"));
  }

  return (false);
}






/*
  This routine creates the bootblock from the data held in the internal structures.
  Note that it creates the body data first, and then the header data, as the header
   has to contain information about the size of the body data.
  (This could e fixed by having a two-stage parser, but I cannot see the point of
   this for this simple version of the program).
  It returns a pointer to the resultant bootblock or NULL if the operation fails.
*/
char* create_bootblock(const sc_bootblock_data_struct* const bootblock)
{
  char header_data[36];  /* 28-byte header + 8 bit pre-bootblock header */
  char trailer_data[12]; /* A 12 byte bootblock trailer */
  unsigned int bootblock_body_count = 0; /* This stores where we are up to in the bootblock */
  unsigned int loop = 0;
  unsigned int loop2 = 0;
  unsigned int l = 0;

  char* body_data = (char*)rmalloc(SIZE_OF_BOOTBLOCK, "bootblock body area"); /* I *really* doubt a bootblock would ever be this big ;*) */
  char* bootblock_data = (char*)rmalloc(SIZE_OF_BOOTBLOCK, "bootblock area"); /* I *really* doubt a bootblock would ever be this big ;*) */

  if (!body_data)
  {
    dprintf(("", "create_bootblock(): Error allocating memory for bootblock.\n"));
    return (NULL);
  }

  if (!bootblock_data)
  {
    dprintf(("", "create_bootblock(): Error allocating memory for bootblock.\n"));
    return (NULL);
  }
  else
  {
    /* 0 initialise the data */
    for (loop=0; loop<SIZE_OF_BOOTBLOCK; loop++)
    {
      bootblock_data[loop]=0x00;
    }
  }

  for(l=0; l<MAX_TAG_CACHE; l++)
  {
    if(bootblock->tag_cache->tag[l].tag == NULL) break; /* no more tags */

    if(bootblock->tag_cache->tag[l].bytes != 0) /* Tag has a value */
    {
      dprintf(("", "create_bootblock(): tag %d (%0x %s) has a value\n", l, bootblock->tag_cache->tag[l].nci_tag, bootblock->tag_cache->tag[l].tag));
      switch (bootblock->tag_cache->tag[l].mapping)
      {
        case TagType_String: /* Tag is a string  */
        case TagType_Proxy:  /* Proxy is a string  */
        case TagType_Host:   /* Tag is a hostname / textual IP, just like a string  */
        {
          /* Write the tag number and tag value size */
          write_big_word(body_data+bootblock_body_count, bootblock->tag_cache->tag[l].nci_tag);
          bootblock_body_count+=4;
          write_big_short(body_data+bootblock_body_count, strlen(bootblock->tag_cache->tag[l].val));
          bootblock_body_count+=2;
          /* Now write the actual string value into the bootblock data */
          for (loop2=0; loop2 < strlen(bootblock->tag_cache->tag[l].val); loop2++)
          {
            body_data[bootblock_body_count+loop2] = bootblock->tag_cache->tag[l].val[loop2];
          }
          bootblock_body_count+=strlen(bootblock->tag_cache->tag[l].val);
          dprintf(("", "create_bootblock(): tag %d has string value %s\n", l, bootblock->tag_cache->tag[l].val));
        }
        break;

        case TagType_IP: /* Tag is an IP address */
        {
          /* The code below is horrible and hacky. Suggest you use inet_addr() or equivalent if you have a TCPIP library available. */
          int loop2 = 0;
          int nums[4];
          int num_count = 0;
          char num_store[4];
          int isp_part_count = 0;
          dprintf(("", "create_bootblock(): value for IP tag %s is %s\n", bootblock->tag_cache->tag[l].tag, bootblock->tag_cache->tag[l].val));
          /* Attempt to split the string into four numbers */
          do
          {
            if (bootblock->tag_cache->tag[l].val[loop2]=='.' || bootblock->tag_cache->tag[l].val[loop2]=='\0')
            {
              num_store[num_count]='\0'; /* Terminate the string. */
              nums[isp_part_count++] = atoi(num_store);
              dprintf(("", "create_bootblock(): Number isp_part_count is %s (%d)\n", num_store, nums[isp_part_count-1]));
              num_count=0;
            }
            else
            {
              num_store[num_count++]=bootblock->tag_cache->tag[l].val[loop2];
            }
            loop2++;
          }
          while (bootblock->tag_cache->tag[l].val[loop2-1] != '\0'); /* Scan until end of string */

          /* Ensure that there are four numbers, and if there are, write them */
          if (isp_part_count < 3)
          {
            dprintf(("", "create_bootblock(): Error: IP address does not have three constituent numbers.\n"));
          }
          else
          {
            /* Write the tag number and tag value size */
            write_big_word(body_data+bootblock_body_count, bootblock->tag_cache->tag[l].nci_tag);
            bootblock_body_count+=4;
            write_big_short(body_data+bootblock_body_count, 4);
            bootblock_body_count+=2;
            /* Now write the actual data */
            body_data[bootblock_body_count++]=nums[0];
            body_data[bootblock_body_count++]=nums[1];
            body_data[bootblock_body_count++]=nums[2];
            body_data[bootblock_body_count++]=nums[3];
          }
        }
        break;

        default:
          dprintf(("", "create_bootblock(): Error: Tag type %d for tag %s is currently unsupported.\n", bootblock->tag_cache->tag[l].mapping, bootblock->tag_cache->tag[l].tag));

      }
    }
  }

  dprintf(("", "create_bootblock(): Bootblock successfully created. Size of bootblock is %d bytes. Adding header and footer.\n", bootblock_body_count));

  /* Create the pre-bootblock header (spec 2.2.5) */
  header_data[0] = 0x01;
  header_data[1] = 0x00;
  header_data[2] = 0x00;
  header_data[3] = 0x00;
  /* The next word needs to be in litle-endian format (spec 2.2.5 table) */
  header_data[7] = ((bootblock_body_count+28) & 0xff000000)>>24;
  header_data[6] = ((bootblock_body_count+28) & 0x00ff0000)>>16;
  header_data[5] = ((bootblock_body_count+28) & 0x0000ff00)>>8;
  header_data[4] = ((bootblock_body_count+28) & 0x000000ff);

  /* Now create the bootblock header. (spec 3.1) */
  header_data[8]  = 0x80; /* (All these are defined in spec 3.1 table) */
  header_data[9]  = 0x00;
  header_data[10] = 0x00;
  header_data[11] = 0x04;
  write_big_short(header_data+12, (bootblock_body_count+22));
  header_data[14] = 0x80;
  header_data[15] = 0x00;
  header_data[16] = 0x00;
  header_data[17] = 0x01;
  write_big_short(header_data+18, (bootblock_body_count+16));
  header_data[20] = 0x80;
  header_data[21] = 0x00;
  header_data[22] = 0x00;
  header_data[23] = 0x03;
  write_big_short(header_data+24, (bootblock_body_count+10));
  header_data[26] = 0x00;
  header_data[27] = 0x00;
  header_data[28] = 0x00;
  header_data[29] = 0x30;
  header_data[30] = 0x00;
  header_data[31] = 0x04;
  header_data[32] = 0x2A;
  header_data[33] = 0x00;
  header_data[34] = 0x00;
  header_data[35] = 0x00;

  /* Generate the trailer (spec 3.3) */
  trailer_data[0] = 0x00;
  trailer_data[1] = 0x00;
  trailer_data[2] = 0x00;
  trailer_data[3] = 0x05;
  trailer_data[4] = 0x00;
  trailer_data[5] = 0x06;
  trailer_data[6] = 0x62;
  trailer_data[7] = 0x79;
  trailer_data[8] = 0x20;
  trailer_data[9] = 0x41;
  trailer_data[10] = 0x6E;
  trailer_data[11] = 0x74;

  /* Now create the bootblock data (header+data+trailer) */
  memcpy(bootblock_data, header_data, 36);
  memcpy(bootblock_data+36, body_data, bootblock_body_count);
  memcpy(bootblock_data+36+bootblock_body_count, trailer_data, 12);

  if (body_data)
  {
    rmfree((unsigned char*)body_data);
  }

  return (bootblock_data);
}



/* This routine writes all the correct values back to NVRAM and bootblocks. */
bool write_values(sc_bootblock_data_struct* main_bb, sc_bootblock_data_struct* default_bb, int flags_bitfield)
{
  dprintf(("", "write_values(): flags_bitfield is %d\n", flags_bitfield));
  /* Do main bootblock */
  if (flags_bitfield & (1L << 0))
  {
    char* bootblock = NULL;

    dprintf(("", "write_values(): Writing default bootblock values\n"));
    bootblock = create_bootblock(default_bb);
    if (!bootblock)
    {
      dprintf(("", "write_values(): Error creating default bootblock\n"));
    }
    else
    {
      display_bootblock_image(bootblock, SIZE_OF_BOOTBLOCK);
      /* Write the default bootblock to the NVRAM. */
      if (!write_nvram_value("BootBlockDefault", bootblock, SIZE_OF_BOOTBLOCK, true))
      {
        dprintf(("", "write_values(): Error attempting to write default bootblock to NVRAM\n"));
      }
      else
      {
        dprintf(("", "write_values(): Default bootblock successfully written to NVRAM.\n"));
      }
      /* Free the memory */
      rmfree((unsigned char*)bootblock);
    }
    service_configurationchanged((int)(flags_bitfield));
  }

  if (flags_bitfield & (1L << 1))
  {
    char* bootblock = NULL;
    _kernel_oserror* err = NULL;
    _kernel_swi_regs regs;

    dprintf(("", "write_values(): Writing main bootblock values\n"));
    bootblock = create_bootblock(main_bb);
    if (!bootblock)
    {
      dprintf(("", "write_values(): Error creating main bootblock\n"));
    }
    else
    {
      display_bootblock_image(bootblock, SIZE_OF_BOOTBLOCK);

      /* Write the main bootblock to the NVRAM using a call to NCBootBlock. */
      regs.r[0] = (int)bootblock+8;
      regs.r[1] = SIZE_OF_BOOTBLOCK-8;

      if(_kernel_swi(NCBootblock_Write, &regs, &regs)!=NULL)
      {
        dprintf(("", "write_values(): NCBootblock Write SWI failed\n"));
        return(-1);
      }
      switch(regs.r[0])
      {
        case  0: dprintf(("", "write_values(): completed OK\n"));
                 break;
        case -1: dprintf(("", "write_values(): enterprise block not authentic\n"));
                 break;
        case -2: dprintf(("", "write_values(): enterprise block too big\n"));
                 return(-1);
                 break;
        case -3: dprintf(("", "write_values(): bootblock is readonly\n"));
                 break;
        case -4: dprintf(("", "write_values(): enterprise block is readonly\n"));
                 break;
        case -5: dprintf(("", "write_values(): file write error\n"));
                 return(-1);
                 break;
        case -6: dprintf(("", "write_values(): alternate block too big\n"));
                 break;
        case -7: dprintf(("", "write_values(): alternate block not authentic\n"));
                 break;
        default: dprintf(("", "write_values(): unrecognized return code from write SWI (&%x)\n",regs.r[0]));
                 break;
      }
      /* Free the memory */
      rmfree((unsigned char*)bootblock);
    }
    service_configurationchanged((int)(flags_bitfield));
  }

  if (flags_bitfield & (1L << 2))
  {
    dprintf(("", "write_values(): Writing NVRAM values\n"));
    write_nvram_tags_list_to_nvram();
    service_configurationchanged((int)(flags_bitfield));
  }

  return (true);
}





/*****************************************************************************
* END OF FILE
*****************************************************************************/

