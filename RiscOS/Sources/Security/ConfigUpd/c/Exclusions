
/*****************************************************************************
* Include header files
*****************************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#include "swis.h"
#include "Debuglib/Debuglib.h"
#include "NVRAM.h"
#include "kernel.h"

#include "sys/queue.h"		/* get SLIST macros */

/* Include headers from ncmalib */
#include "dynalloc.h"
#include "ncma_utils.h"
#include "cu_nvram.h"
#include "cu_main.h"
#include "cu_utils.h"
#include "cu_exclusn.h"
#include "cu_errors.h"

static int exclusions_file_valid = -1; /* No attempt as been made to load file. */

static bool parse_exclusions_file_line(const char* const line);
static void debug_display_lists(void);


/* This file uses the queue functionality provided by TCPIPLibs inthe file sys.queue.h.
   The code scans an exclusions file and places any rules found into a singly-linked lists. This list cmprises of rules for tags that must be present (included) or not be present (excluded).
*/

static SLIST_HEAD(list2, list) *inclusions;

struct list
{
  SLIST_ENTRY(list) list_link; /* list macro glue */
  /*
   struct {
	struct list *sle_next;	// next element
  */
  int rule_type;         /* 1 = include, 2 = exclude */
  int nci_tag_number;    /* The nci_ tag number of the tag this rule represents. */
  char* rule_text;       /* An additional rule (e.g. a DNS range ) */
};



/* This routine reads the exclusions file into memory. */
bool read_exclusions_file(const char* const filename)
{
  bool file_valid = true;
  FILE* fp = NULL;
  char line[256];

  dprintf(("", "read_exclusions_file(): reading filename %s\n", filename));

  /* Open the file */
  dprintf (("", "read_exclusions_file(): Opening file %s.\n", filename));
  if ((fp = fopen(filename, "r")) == NULL)
  {
    dprintf (("", "read_exclusions_file(): Error opening file %s.\n", filename));
    return (false);
  }

  SLIST_INIT(inclusions);

  /* Read the file line-by-line */
  while (fgets(line, LINE_BUFFER_SIZE, fp))
  {
    dprintf (("", "read_exclusions_file(): Line is %s", line));

    /* Malformed lines *must* stop the module from doing anything more. */
    if (!parse_exclusions_file_line(line))
    {
      file_valid = false;
    }
  }

  if (!file_valid)
  {
    dprintf(("", "read_exclusions_file(): Error, exclusions file is invalid.\n"));
    /* Now do what we need to do... Remove the list so no rules are visible to the rest of the system. */
    clear_all_lists();
    exclusions_file_valid = 0;
  }
  else
  {
    dprintf(("", "read_exclusions_file(): exclusions file was valid. Rules are now available for use.\n"));
    exclusions_file_valid = 1;

    /* Debug display contents of lists. */
    debug_display_lists();
  }

  /* Close the file */
  fclose(fp);

  return (false);
}





/* This tourine scans a line for valid exclusion or inclusion rules, and if
they are present adds them to the relevant lists. It returns false if the line is malformed, otherwise it returns true. */
static bool parse_exclusions_file_line(const char* const line)
{
  struct list *p = NULL;
  char* line_ptr = NULL;
  char* ptr = NULL;
  char* equals_ptr = NULL;
  char fragment[3][256];
  int fragment_length[3]; /* Stores te length of each text fragment */
  unsigned int line_type = 0; /* 0 = comment, 1 = inclusion, 2 = exclusion, 3 = blank */
  int loop;

  dprintf(("", "parse_exclusions_file_line()\n"));

  /* Initialise temproary data structures */
  for (loop=0; loop<=2; loop++)
  {
    strcpy(fragment[loop],"");
    fragment_length[loop] = 0;
  }

  /* Trim the line (eg.   remove comments)... */
  line_ptr = (char*)line;
  line_ptr = RipNTrim(line_ptr);
  if (strlen(line_ptr) > 1)
  {
    convert_linefeeds(line_ptr);
    dprintf(("", "parse_exclusions_file_line(): Line is %s\n", line_ptr));
  }
  else
  {
    dprintf(("", "parse_exclusions_file_line(): Line is blank\n"));
    return (true);
  }

  /* Check for comments */
  if (line_ptr[0]=='#')
  {
    dprintf(("", "parse_exclusions_file_line(): Line is a comment\n"));
    return (true);
  }

  /* Now split the line into a <param>:<tag>=<value> triplet. */
  ptr = strpbrk(line_ptr,":");
  if (!ptr)
  {
    /* No : seperator, therefore line is malformed */
    dprintf(("", "parse_exclusions_file_line(): No : seperator, therefore line is malformed\n"));
    return (false);
  }
  else
  {
    fragment_length[0] = ptr-line_ptr;
    strncat(fragment[0], line_ptr, fragment_length[0]);
    dprintf(("", "parse_exclusions_file_line(): first part of line is %s\n", fragment[0]));
    dprintf(("", "parse_exclusions_file_line(): Next part of line is %s\n", ptr));
  }
  equals_ptr = strpbrk(ptr,"=");
  if (!equals_ptr)
  {
    /* No = seperator *is* allowed. */
    dprintf(("", "parse_exclusions_file_line(): No = seperator\n"));
  }
  else
  {
    dprintf(("", "parse_exclusions_file_line(): Third part of line is %s\n", equals_ptr+1));
  }

  /* Decode the second and third parts of the line. */
  if (equals_ptr)
  {
    fragment_length[1] = equals_ptr-ptr-1;
    fragment_length[2] = strlen(equals_ptr+1);
    strncat(fragment[1], ptr+1, fragment_length[1]);
    strncat(fragment[2], equals_ptr+1, fragment_length[2]);
    dprintf(("", "parse_exclusions_file_line(): 2nd line fragment is %s (length %d).\n", fragment[1], strlen(fragment[1])));
    dprintf(("", "parse_exclusions_file_line(): 3rd line fragment is %s (length %d).\n", fragment[2], strlen(fragment[2])));
  }
  else
  {
    fragment_length[1] = strlen(ptr+1);
    strncat(fragment[1], ptr+1, fragment_length[1]);
    dprintf(("", "parse_exclusions_file_line(): 2nd line fragment is %s (length %d).\n", fragment[1], strlen(fragment[1])));
  }

  /* Ensure that there is something after the = */
  if (fragment_length[1] == 0)
  {
    dprintf(("", "parse_exclusions_file_line(): Error: Non-existant second fragment.\n"));
    return (false);
  }

  dprintf(("", "Fragment lengths and contents:\n"));
  for (loop=0; loop<=2; loop++)
  {
    char* foo = NULL;
    char* foo2=NULL;
    foo=(char*)rmalloc(strlen(fragment[loop])+1, "foo!");
    foo2=RipNTrim(fragment[loop]);
    strcpy(foo,foo2);
    strcpy(fragment[loop], foo);
    fragment_length[loop] = strlen(fragment[loop]);
    dprintf(("", "%d: %d %s\n", loop, fragment_length[loop], fragment[loop]));
    if (foo)
    {
      rmfree((unsigned char*)foo);
    }
  }

  /* The line should begin with either include: or exclude:, be a comment or a blankline. Find out which it is, otherwise it is rubbish. */
  if (strncmp(fragment[0], "include", 7) == 0)
  {
    dprintf(("", "parse_exclusions_file_line(): Line is an inclusion.\n"));
    line_type = 1;
  }
  if (strncmp(fragment[0], "exclude", 7) == 0)
  {
    dprintf(("", "parse_exclusions_file_line(): Line is an exclusion.\n"));
    line_type = 2;
  }

  if (line_type > 2 || line_type < 1)
  {
    dprintf(("", "parse_exclusions_file_line(): Error, unrecognised line type.\n"));
    return (false);
  }

  /* Create a node and add to the list. Only do this if the line has been verified as being correct. */
  p = (struct list *)rmalloc(sizeof(struct list), "exclusions list node");
  if (!p)
  {
    dprintf(("", "parse_exclusions_file_line(): Error allocating memory for node.\n"));
  }
  else
  {
    /* Convert the rule_type fragment to an number. */
    p->rule_type = line_type;
    /* Convert the tag string to an nci_tag number. */
    p->nci_tag_number = return_nci_tag_number_from_tag_string(fragment[1]);
    if (p->nci_tag_number == -1)
    {
      dprintf(("", "parse_exclusions_file_line(): Unrecognised tag %s\n", fragment[1]));
      /* Tidy up memory allocated for this node. */
      rmfree((unsigned char*)p);
      p = NULL;
      return (false);
    }
    else
    {
      dprintf(("", "parse_exclusions_file_line(): nci_tag_number for %s is %d\n", fragment[1], p->nci_tag_number));
    }

    if (fragment_length[2] > 0) /* There is a value present */
    {
      p->rule_text = (char*)rmalloc(fragment_length[2], "exclusions list node contents");
      if (!p->rule_text)
      {
        dprintf(("", "parse_exclusions_file_line(): Error allocating memory for node contents.\n"));
      }
      else
      {
        strcpy (p->rule_text, fragment[2]);
      }
    }
    else
    {
      p->rule_text = NULL;
    }

    /* Insert an item into the list. */
    SLIST_INSERT_HEAD(inclusions, p, list_link);
  }

  return (true);
}


/* This routine should be called to clear up all memory allocated allocated for the exclusions file handling. */
bool clear_exclusions_file(void)
{
  /* Clear all memory */
  clear_all_lists();
  /* Reset state of flag so that file has not been read. */
  exclusions_file_valid = -1;

  return (true);
}



/* This routine displays a debug list of all the known rules. */
static void debug_display_lists(void)
{
  struct list *p;
  unsigned int count = 0;

  /* Display the inclusions list... */
  SLIST_FOREACH(p, inclusions, list_link)
  {
    count++;
    dprintf(("", "debug_display_lists(): Node %d is: %d %d \"", count, p->rule_type, p->nci_tag_number));
    if (p->rule_text)
    {
      dprintf(("", "%s", p->rule_text));
    }
    dprintf(("", "\"\n"));
  }

  dprintf(("", "debug_display_lists(): There were %d nodes.\n", count));
}




/* This routine clears the inclusion and exclusion lists, tidying up all memory as it goes. */
void clear_all_lists(void)
{
  struct list *p, *next;

  /* Initially free all data held within the nodes. */
  SLIST_FOREACH(p, inclusions, list_link)
  {
    if (p->rule_text)
    {
      rmfree((unsigned char*)p->rule_text);
      p->rule_text = NULL;
    }
  }

  /* Now free the memory of the nodes themsleves. */
  p = SLIST_FIRST(inclusions);
  while (p)
  {
    next = SLIST_NEXT(p, list_link);
    rmfree((unsigned char*) p);
    p = next;
  }
}




/* This routine can be used to detect whether the exclusions file is valid or not. It returns -1 if no attempt to read thr exclusions file was mode, 0 if an attempt has been made and it was invalid, and 1 if an attempt has been made and it was valid. */
int is_exclusions_file_valid(void)
{
  return (exclusions_file_valid);
}




/* This routine scans through the lists and returns true if the tag
 is mentioned in the exclusions file. If it is present then it returns a
pointer to the node in the list for this tag, otherwise it returns NULL. */

static struct list* search_exclusions_file_for_tag(const int nci_tag)
{
  struct list *p = NULL;

  dprintf(("", "search_exclusions_file_for_tag()\n"));

  /* Parse the inclusions list... */
  SLIST_FOREACH(p, inclusions, list_link)
  {
    if (p->nci_tag_number == nci_tag)
    {
      return (p);
    }
  }

  return (NULL);
}




#define EXCLUSION_RULE_TYPE_INCLUDED 1
#define EXCLUSION_RULE_TYPE_EXCLUDED 2

/* This routine ensures that all the tags in the target are valid against the rules held in the exclusions file, i.e. that any included tags are present and that excluded ones are not. Also any extended rules (e.g. DNS ranges) need to be checked.
   It returns 0 if all tags match, otherwise it returns non-zero. Any errors encoutnered should be added to the errors list. */

unsigned int validate_bootblock_data(sc_bootblock_data_struct* bootblock)
{
  unsigned int loop;

 /* Initially check that the same tag is not present as both an inclusion and an exclusion; this would obviously be an error.
    We then need to do 2 parses:
    1) Scan through all the tags in the CU file and ensure that they should all be present (i.e. none are excluded in the exclusions file);
    2) Scan through the exclusions file and ensure that all tags that are included are present in the CU file.
    As well as th above, we also need to ensure that any extended rule (for example DNS ranges) are validated.
 */

  /* Ensure that the same tag is not mentioned in both exclusion and inclusion rules. */
  struct list *p;
  SLIST_FOREACH(p, inclusions, list_link)
  {
    struct list *p_inner;
    SLIST_FOREACH(p_inner, inclusions, list_link)
    {
      dprintf(("", "validate_bootblock_data(): Node %p is: %d %d (%p %d %d)", p, p->rule_type, p->nci_tag_number, p_inner, p_inner->rule_type, p_inner->nci_tag_number));
      /* Ensure we are not comparing the same node. */
      if (p_inner == p)
      {
        continue;
      }

      if (p->nci_tag_number == p_inner->nci_tag_number)
      {
        char error_string[255];
        dprintf(("", "validate_bootblock_data(): Error: The same tag number has two rules.\n"));
        sprintf(error_string, "Tag %d has two exclusions rules.", p->nci_tag_number);
        append_error(error_string);
        return (-1);
      }
    }
  }

  /* Check CU file tags are not excluded. */
  for(loop=0; loop<MAX_TAG_CACHE; loop++)
  {
    if(bootblock->tag_cache->tag[loop].tag == NULL)
      break; /* no more tags */

    if(bootblock->tag_cache->tag[loop].bytes != 0) /* Tag has a value */
    {
      struct list *p = NULL;
      /* Is this tag excluded or excluded in the exclusions file? */
      p = search_exclusions_file_for_tag(bootblock->tag_cache->tag[loop].nci_tag);
      if (p)
      {
        dprintf(("", "validate_bootblock_data(): tag %d is a %d in the exclusions file.\n", loop, p->rule_type));
        if (p->rule_type == EXCLUSION_RULE_TYPE_EXCLUDED)
        {
          char error_string[255];
          dprintf(("", "validate_bootblock_data(): Error: Attempt to alter tag %s (it is excluded in the exclusions file).\n", bootblock->tag_cache->tag[loop].tag));
          sprintf(error_string, "Tag %s excluded in exclusions file.", bootblock->tag_cache->tag[loop].tag);
          append_error(error_string);
          return (loop);
        }
      }
    }
  }

  /* Ensure that all tags that need including are included. */

  return (0);
}
