/************************************************************************/
/* File:    module.c                                                    */
/* Purpose: Code to deal with module initialisation and finalisation.   */
/*           It also deals with service calls and SWI's.                */
/*                                                                      */
/* Author:  David Cotton <mailto:david.cotton@pace.co.uk>               */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"
#include "Debuglib/Debuglib.h"

#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif /* MemCheck_MEMCHECK */

#include "dynalloc.h"
#include "module.h"
#include "cu_output.h"
#include "cmhg_defs.h"






struct swient cu_ent[MAXSWI + 1] =
{
  cu_acceptfile,
  cu_currentconfiguration,
  cu_nullswi,
  cu_nullswi,
  0,
};

#ifdef DEBUGLIB
//debug_device DebugOutputDevice = PRINTF_OUTPUT;
debug_device DebugOutputDevice = PDEBUG_OUTPUT;
#endif /* DEBUGLIB */

/* code */
_kernel_oserror *module_init(char *cmd_tail, int pbase, void *pw)
{
  pw=pw; pbase=pbase; cmd_tail=cmd_tail;

#ifdef MemCheck_MEMCHECK
  MemCheck_RedirectToFilename("<obey$dir>.MemCheck");
  MemCheck_SetStoreMallocFunctions(1);
  MemCheck_SetStoreMiscFunctions( 1);    // So that diagnostics tell us which functions malloced each malloc block.
  MemCheck_InterceptSCLStringFunctions();
  atexit(MemCheck_OutputBlocksInfo);
  MemCheck_SetQuitting(1, 1);
  MemCheck_SetAccessQuitting(1, 1);
#endif // MemCheck_MEMCHECK

  debug_initialise ("ConfigUpd", "izipfs:$.log", "");
  debug_atexit ();
  debug_output_device (DebugOutputDevice); /* Output debug info via pdebug */

  /* Initialise memory subsystems */
  init_dma();
  init_rma();

  return ((_kernel_oserror *)0);
}



_kernel_oserror *module_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
  struct swient *callp;
  int error;

  pw=pw;

  callp = &cu_ent[swinum];
  error = (*(callp->swi_call))(r);
  return((_kernel_oserror *)NULL);
}




void module_sc_handler(int sn, _kernel_swi_regs *r, void *pw)
{
  pw=pw; sn=sn; r=r; /* Stop compiler warnings */

  dprintf(("", "module_sc_handler(): service call 0x%x reason code: 0x%x\n",sn,r->r[2]));

  switch(sn)
  {
    case Service_ConfigurationChanged:
      dprintf(("", "module_sc_handler(): service call : Service_ConfigurationChanged recieved.\n"));
      break;

    default:
      dprintf(("", "module_sc_handler(): service call : unrecognized service call\n"));
      break;
  }
}





_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
  pw=pw; podule=podule; fatal=fatal; /* Stop compiler warnings */

  dprintf(("", "module_final()\n"));
  return((_kernel_oserror *)NULL);
}



int cu_nullswi(_kernel_swi_regs *r)
{
  r=r; /* Stop compiler warnings */
  return(0);
}



int cu_acceptfile(_kernel_swi_regs *r)
{
  dprintf(("", "cu_acceptfile(): File requested.\n"));

  /* Validate parameters... */
  if (r->r[0] == NULL)
  {
    dprintf(("", "cu_acceptfile(): Error: memory pointer is NULL.\n"));
    return (0);
  }

  if ((r->r[1] <= 0)) /* Memory area size must be greater than 0 */
  {
    dprintf(("", "cu_acceptfile(): Error: Memory area size is less than zero.\n"));
    return (0);
  }

  dprintf(("", "cu_acceptfile(): Attempting to load from %X (size %d).\n", r->r[0], (int)r->r[1]));

  read_configuration_file((char*)r->r[0], (int)r->r[1], 7);

  return(0);
}



int cu_currentconfiguration(_kernel_swi_regs *r)
{
  /* Validate parameters... */
  if (r->r[0] == NULL)
  {
    dprintf(("", "cu_acceptfile(): Error: file pointer is NULL.\n"));
    return (0);
  }
  if ((r->r[2] < 0) || (r->r[2] > 7)) /* Flags must be between 0 and 7 */
  {
    dprintf(("", "cu_acceptfile(): Error: file pointer is NULL.\n"));
    return (0);
  }

  dprintf(("", "cu_currentconfiguration(): Current Config requested.\n"));

  r->r[1] = get_current_configuration((char*)r->r[0], (int)r->r[1], (int)r->r[2]);

  return(0);
}

