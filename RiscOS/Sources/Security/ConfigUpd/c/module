/************************************************************************/
/* File:    module.c                                                    */
/* Purpose: Code to deal with module initialisation and finalisation.   */
/*           It also deals with service calls and SWI's.                */
/*                                                                      */
/* Author:  David Cotton <mailto:david.cotton@pace.co.uk>               */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"
#include "Debuglib/Debuglib.h"

#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif /* MemCheck_MEMCHECK */

#include "dynalloc.h"
#include "module.h"
#include "cu_output.h"
#include "cu_exclusn.h"
#include "cmhg_defs.h"
#include "cu_errors.h"

static _kernel_oserror global_error_block={0,0};

struct cmdent cu_cmdent[MAXCMD + 1] =
{
  cmd_cu_change_exc_file,
  0
};




struct swient cu_ent[MAXSWI + 1] =
{
  cu_acceptfile,
  cu_currentconfiguration,
  cu_nullswi,
  cu_nullswi,
  0,
};


/* This is used thoughout this file. */
static ERROR_STRUCT(BAD_PARAMETER,"Bad Parameter");



#ifdef DEBUGLIB
debug_device DebugOutputDevice = PRINTF_OUTPUT;
//debug_device DebugOutputDevice = PDEBUG_OUTPUT;
#endif /* DEBUGLIB */

/* code */
_kernel_oserror *module_init(char *cmd_tail, int pbase, void *pw)
{
  pw=pw; pbase=pbase; cmd_tail=cmd_tail;

#ifdef MemCheck_MEMCHECK
  MemCheck_RedirectToFilename("<obey$dir>.MemCheck");
  MemCheck_SetStoreMallocFunctions(1);
  MemCheck_SetStoreMiscFunctions( 1);    // So that diagnostics tell us which functions malloced each malloc block.
  MemCheck_InterceptSCLStringFunctions();
  atexit(MemCheck_OutputBlocksInfo);
  MemCheck_SetQuitting(1, 1);
  MemCheck_SetAccessQuitting(1, 1);
#endif // MemCheck_MEMCHECK

  debug_initialise ("ConfigUpd", "izipfs:$.log", "");
  debug_atexit ();
  debug_output_device (DebugOutputDevice); /* Output debug info via pdebug */

  /* Initialise memory subsystems */
  init_dma();
  init_rma();

  /* Set the pointer to the exclusions file to have an initial value. */
  set_exclusions_file("Resources:$.Resources.configupd.exclude");

  return ((_kernel_oserror *)0);
}




_kernel_oserror *module_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
  struct swient *callp;
  _kernel_oserror* error;

  pw=pw;

  callp = &cu_ent[swinum];
  error = (*(callp->swi_call))(r);
  return(error);
}




void module_sc_handler(int sn, _kernel_swi_regs *r, void *pw)
{
  pw=pw; sn=sn; r=r; /* Stop compiler warnings */

  dprintf(("", "module_sc_handler(): service call 0x%x reason code: 0x%x\n",sn,r->r[2]));

  switch(sn)
  {
    case Service_ConfigurationChanged:
      dprintf(("", "module_sc_handler(): service call : Service_ConfigurationChanged recieved.\n"));
      break;

    default:
      dprintf(("", "module_sc_handler(): service call : unrecognized service call\n"));
      break;
  }
}





_kernel_oserror* module_final(int fatal, int podule, void *pw)
{
  pw=pw; podule=podule; fatal=fatal; /* Stop compiler warnings */
  dprintf(("", "module_final()\n"));

  /* Clear up the exclusion file. */
  free_exclusions_file();

  /* Finally see how much memory is left. */
  debug_rmstat();

  return((_kernel_oserror *)NULL);
}



_kernel_oserror* cu_nullswi(_kernel_swi_regs *r)
{
  r=r; /* Stop compiler warnings */
  return(NULL);
}



_kernel_oserror* cu_acceptfile(_kernel_swi_regs *r)
{
  unsigned int number_of_errors = 0;
  char* return_value = NULL;

  dprintf(("", "cu_acceptfile(): File requested.\n"));

  /* Validate parameters... */
  if (r->r[0] == NULL)
  {
    dprintf(("", "cu_acceptfile(): Error: memory pointer is NULL.\n"));
    return (ERROR(BAD_PARAMETER));
  }

  if ((r->r[1] <= 0)) /* Memory area size must be greater than 0 */
  {
    dprintf(("", "cu_acceptfile(): Error: Memory area size is less than zero.\n"));
    return (ERROR(BAD_PARAMETER));
  }

  dprintf(("", "cu_acceptfile(): Attempting to load from %X (size %d).\n", r->r[0], (int)r->r[1]));

  read_configuration_file((char*)r->r[0], (int)r->r[1], 7);

  /* Display all errors in a debug build. */
  debug_display_errors();

  /* Parse error(s) */
  return_value = return_errors(&number_of_errors);
  if (return_value)
  {
    dprintf(("", "cu_acceptfile(): %d errors (%s)\n", number_of_errors, return_value));
    strcpy(global_error_block.errmess, return_value);
    global_error_block.errnum=(int)E_SWIERR_SWI_ERROR;
  }
  else
  {
    dprintf(("", "cu_acceptfile(): %d errors\n", number_of_errors));
    strcpy(global_error_block.errmess, "");
    global_error_block.errnum=0;
  }

  /* Clear all memory used by the errors code during this operation. */
  clear_error_structure();

  /* Check memory allocation (should not be anything allocated here). */
  debug_rmstat();

  if (global_error_block.errnum != 0)
  {
    dprintf(("", "cu_currentconfiguration(): Returning error code %d\n", global_error_block.errnum));
    return(&global_error_block);
  }
  else
  {
    dprintf(("", "cu_currentconfiguration(): Returning error code as NULL\n"));
    return (NULL);
  }
}



_kernel_oserror* cu_currentconfiguration(_kernel_swi_regs *r)
{
  unsigned int number_of_errors = 0;
  char* return_value = NULL;

  dprintf(("", "cu_currentconfiguration()\n"));

  strcpy(global_error_block.errmess, "");
  global_error_block.errnum=0;

  /* Validate parameters... */
  if (r->r[0] == NULL)
  {
    dprintf(("", "cu_currentconfiguration(): Error: file pointer is NULL.\n"));
    return (ERROR(BAD_PARAMETER));
  }

  if ((r->r[2] < 0) || (r->r[2] > 7)) /* Flags must be between 0 and 7 */
  {
    dprintf(("", "cu_currentconfiguration(): Error: file pointer is NULL.\n"));
    return (ERROR(BAD_PARAMETER));
  }

  dprintf(("", "cu_currentconfiguration(): Current Config requested.\n"));

  /* Now get the current configuration. This should return the size of the data held in the memory area in r1. */
  r->r[1] = get_current_configuration((char*)r->r[0], (int)r->r[1], (int)r->r[2]);

  /* Display all errors in a debug build. */
  debug_display_errors();

  /* Parse error(s) */
  return_value = return_errors(&number_of_errors);
  if (return_value)
  {
    dprintf(("", "cu_currentconfiguration(): %d errors (%s)\n", number_of_errors, return_value));
    strcpy(global_error_block.errmess, return_value);
    global_error_block.errnum=(int)E_SWIERR_SWI_ERROR;
  }
  else
  {
    dprintf(("", "cu_currentconfiguration(): %d errors\n", number_of_errors));
    strcpy(global_error_block.errmess, "");
    global_error_block.errnum=0;
  }

  /* Clear all memory used by the errors code during this operation. */
  clear_error_structure();

  if (global_error_block.errnum != 0)
  {
    dprintf(("", "cu_currentconfiguration(): Returning error code %d\n", global_error_block.errnum));
    return(&global_error_block);
  }
  else
  {
    dprintf(("", "cu_currentconfiguration(): Returning error code as NULL\n"));
    return (NULL);
  }
}





_kernel_oserror *module_cmd_handler(char *arg_string, int argc, int cmd_no, void *pw)
{
  struct cmdent *callp;
  int error;
  pw=pw;

  callp = &cu_cmdent[cmd_no];
  error = (*(callp->cmd_call))(arg_string, argc);
  return((_kernel_oserror *)NULL);
}



int cmd_cu_change_exc_file(char *string, int n)
{
  unsigned int loop=0;
  dprintf(("", "cu_change_exc_file(): string %s n=%d\n", string, n));

  /* Check that there was at least one parameter. */
  if (n<1)
  {
    dprintf(("", "cu_change_exc_file(): No paraemter passed. Ingoring.\n"));
    return (0);
  }

  /* Replace the newline char with a EOS */
  while (*(string+loop) != 13 || loop > 254)
  {
    loop++;
  }
  string[loop] = '\0';
  if (strlen(string) > 0)
  {
    set_exclusions_file(string);
  }
  else
  {
    dprintf(("", "cu_change_exc_file(): No filename\n"));
  }

  return(0);
}

