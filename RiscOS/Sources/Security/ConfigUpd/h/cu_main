/* header file cu_nvram.h  */

#ifndef CU_MAIN_H
#define CU_MAIN_H


#include <stdbool.h>


/* Forward prototypes */

/* Structures */

/*****************************************************************************
* New enumerated types
*****************************************************************************/
typedef enum
{
  TagType_Nul = 0,
  TagType_String,
  TagType_Int,      /* Unsupported by this program atm */
  TagType_Host,
  TagType_IP,
  TagType_Proxy,
  TagType_Soak,     /* Unsupported by this program atm */
  TagType_PLIP,     /* Unsupported by this program atm */
  TagType_Phone,    /* Unsupported by this program atm */
  TagType_HTTPUrl,  /* Unsupported by this program atm */
  TagType_Url       /* Unsupported by this program atm */
} tag_type;





typedef struct
{
  char *name;      /* Tag Name */
  tag_type type;   /* The type of the tag */
  int maxlen;      /* Maximum allowable length in bytes */
  int tag_number;  /* A hex number */
  bool required;   /* Whether the tag *must* be present */
  char value[256]; /* naughty, naughty - should really dynamically allocate this whenever a value is added */
} field;

/* This is a large array storing information about the tags that this program
    has to know about. Be *very* careful in altering information held in
    here. The hexidecimal tag number should match the one in smcard.h
    (exported from the bootblock module). If the tag is *not* a tag contained
    in the bootblock but an NVRAM tag (e.g. the alternate dial number tag)
    then the hex number should be set to 0x00.
*/
extern field biglist[];

/* This value is the number of entries in the list below */
#define SIZE_OF_BIGLIST 34




/* This enumerated type needs to match the relevant locations in the array
    below. If it does not, then undefined behaviour *will* occur. */
typedef enum
{
  e_tagname_telephonenumber = 0,
  e_tagname_username,
  e_tagname_password,
  e_tagname_homeurl,
  e_tagname_domainname,
  e_tagname_dnsserver1,
  e_tagname_dnsserver2,
  e_tagname_dialscript,
  e_tagname_timeserver,
  e_tagname_emailurl,
  e_tagname_httpproxyserver,
  e_tagname_ftpproxyserver,
  e_tagname_searchurl,
  e_tagname_ispname,
  e_tagname_configurationaccesspassword,
  e_tagname_alternatedialnumber,
  e_tagname_alternatedialpassword,
  e_tagname_defaultterritory,
  e_tagname_defaultcountry,
  e_tagname_defaulttimezone,
  e_tagname_modemcountry,
  e_tagname_csfstypero,
  e_tagname_csfsserverro,
  e_tagname_csfspathro,
  e_tagname_csfsuserro,
  e_tagname_csfspasswordro,
  e_tagname_csfstyperw,
  e_tagname_csfsserverrw,
  e_tagname_csfspathrw,
  e_tagname_csfsuserrw,
  e_tagname_csfspasswordrw,
  e_tagname_bootblockwritten,
  e_tagname_registrationpstnnum,
  e_tagname_ncmaregistrationserverpassword
} e_tag_names;


/* This symbol holds the size of the bootblock area NVRAM tags. This should
    be the same for the Bootblock and the default bootblock, and in Alba 1.0
    was 768 bytes. */
#define SIZE_OF_BOOTBLOCK 768

/* This symbol defines the size in bytes of the NVRAM device. In Alba 1.0 /
    1.1 this was 4KBytes, on Alba 2.0 it will be 8KBytes. */
#define SIZE_OF_NVRAM 4096

bool read_configuration_file(const char* const input_filename, int configs_to_update);
void get_current_configuration(const unsigned int bitfield, const char* filename);

#endif /* CU_MAIN_H */
