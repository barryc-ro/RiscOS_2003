/* NCAccessManager smartcard handling routines */

#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#define PROTOTYPES_INTERNAL
#include "ncma_scard.h"
#include "ncma_url.h"
#include "ncma_utils.h"
#include "dynalloc.h"
#include "usermode.h"
#include "machine.h"
#include "vectors.h"
#include "DBUG.h"
#include "kprintf.h"

int smartcard_status(int *p)
{
    _kernel_swi_regs r;

    if(_kernel_swi(NCRegistry_Status, &r, &r)!=NULL) return(-1);
    DBUG_PRINTF(DBUG_LVL_DIAG, "smartcard_status: 0x%x 0x%x\n", r.r[0], r.r[2]);
    if(p) *p = r.r[2];
    return(r.r[0]);
}

int smartcard_present(void)
{
    if(smartcard_status(NULL) & BB_STATUS_INSERTED) return(1);
    return(0);
}

int smartcard_valid(void)
{
    if(smartcard_status(NULL) & BB_STATUS_SC_VALID & BB_STATUS_BB_VALID) return(1);
    return(0);
}

int smartcard_pin_protected(void)
{
  if(smartcard_status(NULL) & BB_STATUS_LOCKED) return(1);
  return(0);
}

/* return number of remaining attempts at PIN entry */
int smartcard_blocked(void)
{
    _kernel_swi_regs r;

#ifdef DO_SOME_STUFF_THAT_REALLY_SUCKS

    char filename[] = "/\0";
    char results[64];

    r.r[0] = 0;
    r.r[1] = (int)filename;
    r.r[2] = (int)results;
    r.r[3] = 64;
    _kernel_swi(SCInterface_FileInfo, &r, &r);
    if(r.r[0] != 0x0) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "smartcard_blocked: SCInterface FileInfo failed - error %d\n", r.r[0]);
        return(16);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG,"smartcard_blocked: polling...\n");

    for(;;) {
        _kernel_swi(SCInterface_Status, &r, &r);
        usermode_donothing(); /* do that ol' black magic voodoo */
        if(r.r[0] == 2) continue; /* busy */
        if(r.r[0] == 3) { /* error */
            DBUG_PRINTF(DBUG_LVL_ERROR, "smartcard_blocked: SCInterface error %d\n", r.r[1]);
            return(20);
        }
        break;
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "smartcard_blocked: done!\n");
    return((int)(results[18] & 0xf));
#else
    if(_kernel_swi(NCRegistry_PinInfo, &r, &r)!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "smartcard_blocked: PinInfo SWI failed\n");
        return(20);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "smartcard_blocked: CHV1 is %s set with %d attemts remaining\n",
    			       r.r[0]?"":"not", r.r[1]);
    return(r.r[1]);
#endif
}


int validate_pin(char *s)
{
    char *q;
    _kernel_swi_regs r;

    if((q = get_form_field(s, "pin"))==NULL) {
    	DBUG_PRINTF(DBUG_LVL_DIAG, "validate_pin: couldn't find PIN value in form response\n");
        return(-1);
    }

    chv_pin_size = strlen(q);
    if(chv_pin_size > 8) chv_pin_size = 8;
    strncpy(chv_pin, q, chv_pin_size);

    r.r[0] = (int)chv_pin;
    r.r[1] = chv_pin_size;

    DBUG_PRINTF(DBUG_LVL_DIAG, "validate_pin: authenticating with %d byte key \"%s\"\n", r.r[1], r.r[0]);

    if(_kernel_swi(NCRegistry_Authenticate, &r, &r)!=NULL) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "validate_pin: Registry authentication failed\n");
        return(-1);
    }

    return(1);
}

int registry_status_asserted(int p)
{
    if((registry_delta & registry_status) & p) {
        //registry_delta = 0;
        return(1);
    }
    return(0);
}

int registry_status_cleared(int p)
{
    if((registry_delta & !registry_status) & p) {
        //registry_delta = 0;
        return(1);
    }
    return(0);
}

int registry_status_set(int p)
{
    if(registry_status & p) return(1);
    return(0);
}

int registry_status_clear(int p)
{
    if(!registry_status & p) return(1);
    return(0);
}

void unlock_cache(void)
{
    DBUG_PRINTF(DBUG_LVL_DIAG, "unlock_cache: unlocking tag cache\n");
    tag_cache.card = 0;
    return;
}

int cache_smartcard(void)
{
    int l;
    _kernel_swi_regs r;
    char *ptr;
    int bytes;

    if(tag_cache.base == NULL) {
        if((tag_cache.base = (char *)rmalloc(TAG_CACHE_SIZE, "NCMA tag cache"))==NULL) return(-1);
    }

    if(tag_cache.card == 1) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "cache_smartcard: cache locked\n");
        return(0);
    }

    tag_cache.card = 1;

    ptr = tag_cache.base;
    bytes = TAG_CACHE_SIZE;

    /* bin any old contents... */
    for(l=0; l<MAX_TAG_CACHE; l++) {
        tag_cache.tag[l].val = NULL;
        tag_cache.tag[l].bytes = 0;
    }

    tag_cache.bytes = 0;
    tag_cache.tags = 0;
    memset(tag_cache.base, 0, TAG_CACHE_SIZE);

    /* and get some new stuff off the smartcard */

    for(l=0; (l<MAX_TAG_CACHE && bytes)>0;l++) {

        if(tag_cache.tag[l].tag == NULL) break;

        r.r[0] = (int)tag_cache.tag[l].tag;
        r.r[1] = (int)ptr;
        r.r[2] = bytes;

        DBUG_PRINTF(DBUG_LVL_DIAG, "cache_smartcard: bytes: %d next ptr: 0x%x\n", bytes, ptr);

        if(_kernel_swi(NCRegistry_Enquiry, &r, &r)==NULL) {
            if(r.r[0] >0) {
                DBUG_PRINTF(DBUG_LVL_DIAG, "cache_smartcard: %s ok\n", tag_cache.tag[l].tag);
                tag_cache.tag[l].val = ptr;
                tag_cache.tag[l].bytes = r.r[0];
                ptr += r.r[0];
                bytes -= r.r[0];
            } else {
                DBUG_PRINTF(DBUG_LVL_DIAG, "cache_smartcard: %s failed\n", tag_cache.tag[l].tag);
            }
        } else {
            DBUG_PRINTF(DBUG_LVL_DIAG, "cache_smartcard: %s SWI failed\n", tag_cache.tag[l].tag);
        }
    }

    tag_cache.tags = l;
    tag_cache.bytes = TAG_CACHE_SIZE - bytes;


    return(l);
}

int cache_info(void)
{
    int l;

    kprintf("Tag cache stats:\n\n");

    for(l=0; l<tag_cache.tags; l++)
        kprintf("%s (%d) %s\n",
        			   tag_cache.tag[l].tag,
        			   tag_cache.tag[l].bytes,
        			   tag_cache.tag[l].bytes==0?"MISS":"HIT");

    kprintf("\nTag cache base: 0x%x  Bytes used: %d/%d  Tags in cache: %d\n",
    			       tag_cache.base, tag_cache.bytes, tag_cache.max, tag_cache.tags);

    kprintf("Smartcard %s present\n\n", tag_cache.card?"":"not");

    return(0);
}

int cache_enquiry(char *tag, char *buff, int bytes)
{
    int l;

    for(l=0; l<tag_cache.tags; l++) {
        if(caseless_strcmp(tag, (char *)tag_cache.tag[l].tag)==0) {
            strncpy(buff, tag_cache.tag[l].val, tag_cache.tag[l].bytes>bytes?bytes:tag_cache.tag[l].bytes);
            return(tag_cache.tag[l].bytes);
        }
    }
    return(-1);
}


int set_unblock_pin(char *s)
{
    char *q;

    if((q = get_form_field(s, "pin"))==NULL) {
    	DBUG_PRINTF(DBUG_LVL_DIAG, "set_unblock_pin: couldn't find PIN value in form response\n");
        return(-1);
    }
    DBUG_PRINTF(DBUG_LVL_DIAG, "set_unblock_pin: got unblock PIN \"%s\"\n", q);

    unblock_pin_size = strlen(q);
    if(unblock_pin_size>8) unblock_pin_size = 0;
    strncpy(unblock_pin, q, unblock_pin_size);

    return(unblock_pin_size);
}

int change_pin(char *s)
{
    _kernel_swi_regs r;
    char filepath[] = "/\0";
    char *q, *p;

    if((q = get_form_field(s, "pin"))==NULL) {
    	DBUG_PRINTF(DBUG_LVL_DIAG, "change_pin: couldn't find new PIN in form response\n");
        return(-1);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "change_pin: first PIN: \"%s\" %d bytes\n", q, strlen(q));

    s = q + strlen(q) + 1;

    if((p = get_form_field(s, "pincopy"))==NULL) {
    	DBUG_PRINTF(DBUG_LVL_DIAG, "change_pin: couldn't find PIN duplicate in form response\n");
        return(-1);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "change_pin: second PIN: \"%s\" %d bytes\n", p, strlen(p));

    if(strncmp(q,p,8)!=0) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "change_pin: PINs entered don't match\n");
        ncma_trans = Trans_URLMismatch;
        setcallback();
        return(0);
    }




    chv_pin_size = strlen(q);
    if(chv_pin_size > 8) chv_pin_size = 8;
    strncpy(chv_pin, q, chv_pin_size);

    DBUG_PRINTF(DBUG_LVL_DIAG, "change_pin: got new PIN \"%s\" %d bytes\n", chv_pin, chv_pin_size);


    if(unblock_pin_size > 0) { /* It's an unblock PIN operation */
      DBUG_PRINTF(DBUG_LVL_DIAG, "change_pin: calling unblock PIN\n");
      r.r[0] = 0;
      r.r[1] = (int)filepath;
      r.r[2] = 0x1;
      r.r[3] = (int)unblock_pin;
      r.r[4] = unblock_pin_size;
      r.r[5] = (int)chv_pin;
      r.r[6] = chv_pin_size;

      if(_kernel_swi(SCInterface_UnBlockCHV, &r, &r)!=NULL) {
          DBUG_PRINTF(DBUG_LVL_ERROR, "change_pin: SCInterface PIN unblock failed\n");
          return(-1);
      }
    } else { /* It's a normal change PIN operation */
      DBUG_PRINTF(DBUG_LVL_DIAG, "change_pin: calling change CHV\n");
#if 0
      r.r[0] = 0;
      r.r[1] = (int)filepath;
      r.r[2] = 0x1;
      r.r[3] = (int)old_chv_pin;
      r.r[4] = old_chv_pin_size;
      r.r[5] = (int)chv_pin;
      r.r[6] = chv_pin_size;
       if(_kernel_swi(SCInterface_ChangeCHV, &r, &r)!=NULL) {
           DBUG_PRINTF(DBUG_LVL_ERROR, "change_pin: SCInterface PIN change failed\n");
           return(-1);
       }
#else
      r.r[0] = 1;
      r.r[1] = (int)chv_pin;
      r.r[2] = chv_pin_size;
      if(_kernel_swi(NCRegistry_ChangeSmartCardCHV, &r, &r)!=NULL) {
          DBUG_PRINTF(DBUG_LVL_ERROR, "change_pin: NCRegistry change PIN failed\n");
          return(-1);
      }
#endif
    }
    return(0);
}


