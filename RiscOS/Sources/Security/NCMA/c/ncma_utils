#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"

#define PROTOTYPES_INTERNAL
#include "ncma_utils.h"
#include "ncma_scard.h"
#include "ncma_ncma.h"

#include "DBUG.h"

void dump_block(unsigned char *src, int bytes)
{
  int lines, stub;
  char t[17];
  int l;

  lines = bytes / 16;
  stub = bytes % 16;
  t[16] = 0;

  while(lines--) {
    for(l=0; l<16; l++, src++) {
      printf("%.2x ", *src);
      if(iscntrl(*src)) t[l] = '.';
      else t[l] = *src;
    }
    printf("  %s\n", t);
  }

  for(l=0; l<16; l++, src++) {
    if(l<stub) {
      printf("%.2x ", *src);
      if(iscntrl(*src)) t[l] = '.';
      else t[l] = *src;
    } else {
      printf(".. ");
      t[l] = 0x20;
    }
  }
  printf("  %s\n", t);
}

int strterm(char *s)
{
    int b;

    for(b=0; isprint(*s); b++, s++);
    *s = 0;
    return(b);
}

void shutdown_nc(void)
{
    _kernel_swi_regs r;

    r.r[0] = 0;
    _kernel_swi(0x4c7c1, &r, &r);
    return;
}

int caseless_strcmp(char *a, char *b)
{
  int n;

  for(n=0; n<MAX_TAGNAME; n++, a++, b++) {
    if(toupper(*a) != toupper(*b)) return(1);
    if(iscntrl(*a) || iscntrl(*b)) break;
  }

  if(n>0) return(0);
  else return(1);
}

int ip_ntos(char *b, char *i)
{
    DBUG_PRINTF(DBUG_LVL_DIAG, "ip_ntos: word 0x%x\n", *(int *)i);
    sprintf(b, "%d.%d.%d.%d",
      (int)*(i), (int)*(i+1), (int)*(i+2), (int)*(i+3));
    return(0);
}

int ncma_network_init(void) /* set resolver config */
{
    char buff[128];
    int dns[2];
    char *p;
    int l;
    _kernel_swi_regs r;

    if(cache_enquiry("DNS_PRIMARY", (char *)&dns[0], 4)<0) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_network_init: cache enquiry failed for DNS_PRIMARY\n");
        return(-1);
    }

    if(cache_enquiry("DNS_BACKUP", (char *)&dns[1], 4)<0) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_network_init: cache enquiry failed for DNS_BACKUP\n");
        return(-1);
    }

    ip_ntos(buff, (char *)&dns[0]);
    p = buff;
    l = strlen(p);
    p += l;
    *p++ = 0x20;
    ip_ntos(p, (char *)&dns[1]);

    DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_network_init: setting resolvers to %s\n", buff);


    if(write_os_var(RESOLVER_ENV_VAR_NAME, buff, strlen(buff))<0) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_network_init: failed setting resolvers\n");
        return(-1);
    }

    memset(buff, 0, 128);
    if(cache_enquiry("ISP_DOMAIN", buff, 128)<0) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_network_init: cache enquiry failed for ISP_DOMAIN\n");
        return(-1);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_network_init: setting domain to \"%s\"\n", buff);

    if(write_os_var(DOMAIN_ENV_VAR_NAME, buff, strlen(buff))<0) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_network_init: failed setting domain\n");
        return(-1);
    }

    sprintf(buff, "ResolverConfig");
    r.r[0] = (int)buff;
    if(_kernel_swi(0x5, &r, &r)!=NULL) { /* OS_Cli */
      DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_network_init: resolver config failed\n");
      return(-1);
    }
    return(0);
}

int ui_present(void)
{
    _kernel_swi_regs r;
    char ui[] = UI_ENV_VAR;

    r.r[0] = (int)ui;
    r.r[1] = 0;
    r.r[2] = -1;
    r.r[3] = 0;
    r.r[4] = 0;

    _kernel_swi(OS_ReadVarVal, &r, &r);

    if(r.r[2] == 0) return(0);
    return(1);
}

