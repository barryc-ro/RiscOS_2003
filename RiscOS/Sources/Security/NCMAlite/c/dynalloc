/************************************************************************/
/* File:    dynalloc.c                                                  */
/* Purpose: Handle memory handling for NCMAlite. It can use either DMA  */
/*           or RMA to claim memory, and logs memory usage when using   */
/*           DMA areas.                                                 */
/*                                                                      */
/* Author:  David Cotton <mailto:david.cotton@pacemicro.com>            */
/*                                                                      */
/************************************************************************/

/* ANSI includes */
#include <stdio.h>

/* Library includes */
#include "kernel.h"
#include "swis.h"

/* Local includes */
#define PROTOTYPES_INTERNAL
#include "dynalloc.h"
#include "DBUG.h"
#include "kprintf.h"


/*********************************************************************************/
/* init_dma                                                                      */
/*                                                                               */
/* This routine initialises the DMA ready for use.                               */
/*                                                                               */
/* Parameters: None                                                              */
/*                                                                               */
/* Returns:    Nothing                                                           */
/*                                                                               */
/*********************************************************************************/
void init_dma(void)
{
  int loop;
  for(loop=0;loop<MAX_RMA_MALLOX;loop++)
  {
    rmalloc_data[loop].area_number = -1;
    rmalloc_data[loop].area_start = NULL;
  }

  num_mallox = 0;
  return;
}





/*********************************************************************************/
/* get_dma                                                                       */
/*                                                                               */
/* This routine claims an area of memory ready for use.                          */
/*                                                                               */
/* Parameters: int : The number of bytes to be claimed.                          */
/*             char* : A description of the usage of the area.                   */
/*                                                                               */
/* Returns:    unsigned char* : A pointer to the allocated memory, or NULL if    */
/*              the memory could not be claimed.                                 */
/*                                                                               */
/*********************************************************************************/
unsigned char *get_dma(int bytes, char *descrip)
{
  _kernel_swi_regs r;
  _kernel_oserror *e;
  int loop;

  DBUG_PRINTF(DBUG_LVL_ERROR, "get_dma() : Requesting %d bytes for '%s'\n", bytes, descrip);

  if (num_mallox >= MAX_RMA_MALLOX) goto no_free_dma;

  for (loop=0; loop<MAX_RMA_MALLOX; loop++)
  {
    if (rmalloc_data[loop].area_number == -1)
    {
      r.r[0] = 0;
      r.r[1] = -1;
      r.r[2] = bytes;
      r.r[3] = -1;
      r.r[4] = 128; /* not draggable */
      r.r[5] = bytes; /* 1 Meg */
      r.r[6] = 0;
      r.r[7] = 0;
      r.r[8] = (int) descrip;

      if ((e=_kernel_swi(XOS_Bit | OS_DynamicArea, &r, &r))!=NULL)
      {
        goto bad_dmalloc;
      }

      rmalloc_data[loop].area_number = r.r[1];
      rmalloc_data[loop].area_start = (unsigned char *) r.r[3];
      DBUG_PRINTF(DBUG_LVL_DIAG, "get_dma() : area number=%d, area_start=%p\n", rmalloc_data[loop].area_number, rmalloc_data[loop].area_start);
      num_mallox++;
      return (unsigned char *)(r.r[3]);
    }
   }

bad_dmalloc:
    DBUG_PRINTF(DBUG_LVL_ERROR, "get_dma: OS_DynamicArea claim failed: \n");
no_free_dma:
    DBUG_PRINTF(DBUG_LVL_ERROR, "get_dma: Cannot claim any more memory.\n");

    return ((void *)NULL);
}




/*********************************************************************************/
/* free_dma                                                                      */
/*                                                                               */
/* This routine frees a previously-claimed area of DMA memory.                   */
/*                                                                               */
/* Parameters: char* : The area of memory to be free'd.                          */
/*                                                                               */
/* Returns:    Nothing                                                           */
/*                                                                               */
/*********************************************************************************/
void free_dma(unsigned char *ptr)
{
  int loop;
  _kernel_swi_regs r;
  _kernel_oserror *e;

  DBUG_PRINTF(DBUG_LVL_DIAG, "free_dma:() : Request to free area at %p\n", ptr);

  for(loop=0;loop<MAX_RMA_MALLOX;loop++)
  {
    if ((rmalloc_data[loop].area_start == ptr) && (rmalloc_data[loop].area_number != -1))
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "free_dma:() : Freeing area %d at %p\n", rmalloc_data[loop].area_number, rmalloc_data[loop].area_start);
      r.r[0] = 1;
      r.r[1] = rmalloc_data[loop].area_number;

      if((e=_kernel_swi(XOS_Bit | OS_DynamicArea, &r, &r))!=NULL)
      {
        DBUG_PRINTF(DBUG_LVL_ERROR, "free_dma: dynamic area release failed.\n");
        return;
      }

      rmalloc_data[loop].area_number = -1;
      rmalloc_data[loop].area_start = NULL;
      num_mallox--;

      return;
    }
  }
  return;
}




/*********************************************************************************/
/* free_all_dma                                                                  */
/*                                                                               */
/* This routine free's all the DMA memory areas claimed.                         */
/*                                                                               */
/* Parameters: None                                                              */
/*                                                                               */
/* Returns:    Nothing.                                                          */
/*                                                                               */
/*********************************************************************************/
void free_all_dma(void)
{
  int loop;
  _kernel_swi_regs r;

  if(num_mallox==0) return;

  for(loop=0;loop<MAX_RMA_MALLOX;loop++) {
    r.r[0] = 1;
    if(rmalloc_data[loop].area_number != -1) {
      r.r[1] = rmalloc_data[loop].area_number;
      _kernel_swi(XOS_Bit | OS_DynamicArea, &r, &r);
      rmalloc_data[loop].area_number = -1;
      rmalloc_data[loop].area_start = NULL;
    }
  }
  num_mallox = 0;
  return;
}



/*********************************************************************************/
/* init_rma                                                                      */
/*                                                                               */
/* This routine initialises the RMA ready for use.                               */
/*                                                                               */
/* Parameters: None                                                              */
/*                                                                               */
/* Returns:    Nothing                                                           */
/*                                                                               */
/*********************************************************************************/
void init_rma(void)
{
  init_dma();
}




/*********************************************************************************/
/* get_rma                                                                       */
/*                                                                               */
/* This routine claims an area of memory ready for use.                          */
/*                                                                               */
/* Parameters: int : The number of bytes to be claimed.                          */
/*                                                                               */
/* Returns:    unsigned char* : A pointer to the allocated memory, or NULL if    */
/*              the memory could not be claimed.                                 */
/*                                                                               */
/*********************************************************************************/
unsigned char *get_rma(int size)
{
  _kernel_swi_regs r;
  _kernel_oserror *e;
  int loop;

  if (num_mallox >= MAX_RMA_MALLOX) goto no_free_rma;

  for(loop=0;loop<MAX_RMA_MALLOX;loop++)
    if(rmalloc_data[loop].area_number == -1) {

      r.r[0] = 6; /* claim */
      r.r[3] = size;
      if((e=_kernel_swi(XOS_Bit | OS_Module, &r, &r))!=NULL) goto bad_rmalloc;


      rmalloc_data[num_mallox].area_number = 1;
      rmalloc_data[num_mallox].area_start = (unsigned char *)(r.r[2]);
      num_mallox++;

      return((unsigned char *)(r.r[2])); /* return base address */
    }
bad_rmalloc:
    DBUG_PRINTF(DBUG_LVL_ERROR, "get_rma: OS_Module claim failed.\n");
no_free_rma:
    DBUG_PRINTF(DBUG_LVL_ERROR, "get_rma: Cannot claim any more memory.\n");

    return((unsigned char *)NULL);
}



/*********************************************************************************/
/* free_rma                                                                      */
/*                                                                               */
/* This routine frees a previously-claimed area of RMA memory.                   */
/*                                                                               */
/* Parameters: char* : The area of memory to be free'd.                          */
/*                                                                               */
/* Returns:    Nothing                                                           */
/*                                                                               */
/*********************************************************************************/
void free_rma(unsigned char *ptr)
{
  int loop;
  _kernel_swi_regs r;
  _kernel_oserror *e;

  for(loop=0;loop<MAX_RMA_MALLOX;loop++) {
    if ((rmalloc_data[loop].area_start == ptr) && (rmalloc_data[loop].area_number != -1)) {

      r.r[0] = 7; /* free RMA */
      r.r[2] = (int)ptr;
      if((e=_kernel_swi(OS_Module, &r, &r))!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "free_rma: RMA release failed.\n");
        return;
      }

       rmalloc_data[loop].area_number = -1;
       rmalloc_data[loop].area_start = NULL;
       num_mallox--;
    }
  }
  return;
}


/*********************************************************************************/
/* free_all_rma                                                                  */
/*                                                                               */
/* This routine free's all the RMA memory areas claimed.                         */
/*                                                                               */
/* Parameters: None                                                              */
/*                                                                               */
/* Returns:    Nothing.                                                          */
/*                                                                               */
/*********************************************************************************/
void free_all_rma(void)
{
  int loop;
  _kernel_swi_regs r;

  if(num_mallox==0) return;

  for(loop=0;loop<MAX_RMA_MALLOX;loop++) {
    if(rmalloc_data[loop].area_number != -1) {
      r.r[0] = 7;
      r.r[2] = (int)(rmalloc_data[loop].area_start);
      _kernel_swi(XOS_Bit | OS_Module, &r, &r);
      rmalloc_data[loop].area_number = -1;
      rmalloc_data[loop].area_start = NULL;
    }
  }
  num_mallox = 0;
  return;
}



/*********************************************************************************/
/* rminit                                                                        */
/*                                                                               */
/* This routine initialises the memory systems. It decides whether to use RMA    */
/*  or DMA as the store.                                                         */
/*                                                                               */
/* Parameters: None                                                              */
/*                                                                               */
/* Returns:    Nothing.                                                          */
/*                                                                               */
/*********************************************************************************/
void rminit(void)
{
  int variant;

  DBUG_PRINTF(DBUG_LVL_DIAG, "rminit()\n");

  variant = _kernel_osbyte(129, 0, 0xff) & 0xff;
  if(variant < 0xa5)
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "rminit() : Use RMA for memory accesses.\n");
    use_dynamic_areas = false;
  }
  else
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "rminit() : Use DMA for memory accesses.\n");
    use_dynamic_areas = true;
  }

  init_dma();
  return;
}



/*********************************************************************************/
/* rmalloc                                                                       */
/*                                                                               */
/* This routine is a generic interface to the memory routines, and acts as a     */
/*  wrapper for malloc()                                                         */
/*                                                                               */
/* Parameters: int   : The amount of memory to be claimed.                       */
/*             char* : A string describing the usage of the memory.              */
/*                                                                               */
/* Returns:    unsigned char* : A pointer to the memory area claimed, or NULL    */
/*              if the memory could not be claimed.                              */
/*                                                                               */
/*********************************************************************************/
unsigned char *rmalloc(int s, char *n)
{
  if(use_dynamic_areas) return(get_dma(s, n));
  return(get_rma(s));
}



/*********************************************************************************/
/* rmfree                                                                        */
/*                                                                               */
/* This routine is a generic interface to the memory routines, and acts as a     */
/*  wrapper for free()                                                           */
/*                                                                               */
/* Parameters: unsigned char* : A pointer to the memory area to be free'd.       */
/*                                                                               */
/* Returns:    Nothing.                                                          */
/*                                                                               */
/*********************************************************************************/
void rmfree(unsigned char *s)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "rmfree: freeing area at %p\n", s);
  if(use_dynamic_areas) free_dma(s);
  else free_rma(s);
  return;
}




/*********************************************************************************/
/* rmfree_all                                                                    */
/*                                                                               */
/* This routine is a generic interface to the memory routines, and free's all    */
/*  memory currently known in the system.                                        */
/*                                                                               */
/* Parameters: None.                                                             */
/*                                                                               */
/* Returns:    Nothing.                                                          */
/*                                                                               */
/*********************************************************************************/
void rmfree_all(void)
{
  if(use_dynamic_areas) free_all_dma();
  else free_all_rma();
  return;
}




/*********************************************************************************/
/* rmstat                                                                        */
/*                                                                               */
/* This routine displays a list of all known memory areas.                       */
/*                                                                               */
/* Parameters: None.                                                             */
/*                                                                               */
/* Returns:    Nothing.                                                          */
/*                                                                               */
/*********************************************************************************/
void rmstat(void)
{
    int loop;

    printf("Memory manager stats: %d areas present.\n", num_mallox);

    for(loop=0;loop<MAX_RMA_MALLOX;loop++)
    {
      if(rmalloc_data[loop].area_number != -1)
      {
        DBUG_PRINTF(DBUG_LVL_DIAG, " rmstat() : Area: %d  Start: %p\n", rmalloc_data[loop].area_number, rmalloc_data[loop].area_start);
        printf("Area: %d  Start: %p\n", rmalloc_data[loop].area_number, rmalloc_data[loop].area_start);
      }
    }

    printf("\n");
    return;
}


