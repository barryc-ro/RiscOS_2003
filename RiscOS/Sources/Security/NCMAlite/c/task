/* File:     task.c
   Purpose:  Wimp task section of module.
   Author:   Ben Laughton
   Modified: David Cotton

   Copyright 1998 Acorn Computers Ltd

   This material is the confidential trade secret and proprietary information
   of Acorn Computers. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Acorn Computers.
   All rights reserved.

   History:

   1998-10-20 BAL
   Created.
   1998-11-20 DSC
   Modified for NCMAlite use.
 */




/* =============================================================================
 * Include header files
 */

/* CLib */
#include "kernel.h"
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include "swis.h"

/* Wimp */
#include "tboxlibs/wimp.h"
#include "tboxlibs/wimplib.h"

/* Standby */
#include "cmhg_defs.h"
#include "module.h"
#include "task.h"
#include "machine.h"

#include "dbug.h"


/* =============================================================================
 * Constants definitions
 */

#define TASK                0x4b534154
#define TASK_DESCRIPTION    "NCMAlite"
#define WIMP_VERSION        310




/* =============================================================================
 * New type definitions
 */

#define Wimp_MPreLogOff                    0x4f000
#define Wimp_MRestartPreLogOff             0x4f001
#define Wimp_MLogOff                       0x4f002


/* =============================================================================
 * Global variable declarations
 */

int           task_handle = 0;
int           task_stack = 0;
volatile int  poll_word = 0;
/* This variable stores the reference for the prelogoff sequence. */
unsigned int  my_prelogoff_ref = 0;
/* This variable stores the reference for the logoff sequence. */
unsigned int  my_logoff_ref = 0;



/* =============================================================================
 * Function prototype declarations
 */
/*
static _kernel_oserror *  handle_key_pressed (
                              WimpKeyPressedEvent *const  key_pressed);
*/

static _kernel_oserror *  handle_user_message_restart_prelogoff (void);

static _kernel_oserror *  handle_poll_word_non_zero (
     WimpPollWordNonZeroEvent *const  poll_word_non_zero);

static _kernel_oserror *  handle_user_message_acknowledge (
    WimpUserMessageAcknowledgeEvent *const  user_message_acknowledge);

static _kernel_oserror *  handle_user_message_quit (void);

_kernel_oserror *  send_pre_logoff (void);

static _kernel_oserror *  handle_user_message_logoff (WimpUserMessageEvent event);

static _kernel_oserror *  handle_user_message_prelogoff (WimpUserMessageEvent event);

static _kernel_oserror *  send_logoff (void);



/* =============================================================================
 * Function definitions
 */

/* -----------------------------------------------------------------------------
   main

   Start the Wimp task section of the module and enter the main Wimp poll loop.

   Returns
   failure: EXIT_FAILURE
   otherwise doesn't return
 */

int  main (int     argc,
           char *  argv[])
{
    _kernel_oserror *  e = NULL;
    int  message_list[] =
    {
        Wimp_MPreQuit,
        Wimp_MPreLogOff,
        Wimp_MRestartPreLogOff,
        Wimp_MLogOff,
        0
    };

    DBUG_PRINTF(DBUG_LVL_DIAG, "main: Starting the task section of the module.\n");

    NOT_USED (argc);
    NOT_USED (argv);

    e = wimp_initialise (WIMP_VERSION,
                         Module_Title_String,
                         message_list,
                         NULL,
                         &task_handle);
    if (!e)
    {
        int            mask = 0x00401831;
        int            event_code;
        WimpPollBlock  poll;

        for (;;)
        {
            e = wimp_poll (mask,
                           &poll,
                           (int *) &poll_word,
                           &event_code);
            if (!e)
            {
                DBUG_PRINTF(DBUG_LVL_DIAG, "Event code %d\n", event_code);
                switch (event_code)
                {

                    case Wimp_EPollWordNonZero:
                        DBUG_PRINTF(DBUG_LVL_DIAG, "Wimp_EPollWordNonZero event\n");
                        e = handle_poll_word_non_zero (
                                &poll.poll_word_non_zero);
                        break;

                    case Wimp_EUserMessageAcknowledge:
                        DBUG_PRINTF(DBUG_LVL_DIAG, "Wimp_EUserMessageAcknowledge event\n");
                        e = handle_user_message_acknowledge (
                                &poll.user_message_acknowledge);
                        break;

                    case Wimp_EUserMessage:
                        DBUG_PRINTF(DBUG_LVL_DIAG, "Wimp_EUserMessage event\n");
                        if (poll.user_message.hdr.action_code == Wimp_MLogOff)
                        {
                          e = handle_user_message_logoff(poll.user_message);
                          break;
                        }
                        /* Deliberate fall-through */
                    case Wimp_EUserMessageRecorded:
                        DBUG_PRINTF(DBUG_LVL_DIAG, "Wimp_EUserMessageRecorded event\n");
                        if (poll.user_message.hdr.action_code == Wimp_MQuit)
                        {
                          e = handle_user_message_quit ();
                          break;
                        }
                        if (poll.user_message.hdr.action_code == Wimp_MRestartPreLogOff)
                        {
                          e = handle_user_message_restart_prelogoff();
                          break;
                        }
                        if (poll.user_message.hdr.action_code == Wimp_MPreLogOff)
                        {
                          DBUG_PRINTF(DBUG_LVL_DIAG, "Wimp_MPreLogOff recieved as Wimp_EUserMessageRecorded event\n");
                          e = handle_user_message_prelogoff((WimpUserMessageEvent)poll.user_message_recorded);
                          break;
                        }
                        if (poll.user_message.hdr.action_code == Wimp_MLogOff)
                        {
                          e = handle_user_message_logoff((WimpUserMessageEvent)poll.user_message_recorded);
                          break;
                        }

                    default:
                        break;
                }
            }

            if (e)
            {
                wimp_report_error (e, 0, 0, 0, 0, 0);
            }
        }
    }

    fprintf (stderr, "%s\n", e->errmess);

    return EXIT_FAILURE;
}




/* -----------------------------------------------------------------------------
   task_closedown

   Closedown the Wimp task section of the module.

   Returns
   success: NULL
   failure: pointer to RISC OS error block
 */

_kernel_oserror *  task_closedown (void)
{
    _kernel_oserror *  e = NULL;

    DBUG_PRINTF(DBUG_LVL_DIAG, "task_closedown()\n");

    /* Only closedown if task is currently active */
    if (task_handle > 0)
    {
        DBUG_PRINTF(DBUG_LVL_DIAG, "task_closedown() : Task is currently active so closing down.\n");
        /* Can't sensibly deal with any error */
        e = wimp_close_down (task_handle);

        /* Mark task as inactive */
        task_handle = 0;
    }
    else
    {
        DBUG_PRINTF(DBUG_LVL_DIAG, "task_closedown() : Task is not currently active so cannot close down.\n");
    }

    if (task_stack)
    {
        _swix (OS_Module,
               _IN (0) | _IN (2),

               OS_Module_Free,
               task_stack);

        task_stack = 0;
    }

    return e;
}




/* -----------------------------------------------------------------------------
   handle_poll_word_non_zero

   Handle poll-word non-zero events from the Wimp.

   Inputs
   WimpPollWordNonZeroEvent *const  poll_word_non_zero: poll-word non-zero event
                                                        data

   Returns
   success: NULL
   failure: pointer to RISC OS error block
 */

static _kernel_oserror *  handle_poll_word_non_zero (
     WimpPollWordNonZeroEvent *const  poll_word_non_zero)
{
    /* Only meaning of pollword is when module part wants the PreLogoff
     * message to be broadcast.
     */
    DBUG_PRINTF(DBUG_LVL_DIAG, "handle_poll_word_non_zero() recieved. Resetiing poll_word_non_zero->poll_word to 0 and calling send_pre_logoff()\n");
    *(int *) (poll_word_non_zero->poll_word) = 0;
    return send_pre_logoff ();
}




/* -----------------------------------------------------------------------------
   handle_user_message_acknowledge

   Handle User Message Acknowledge events from the Wimp.

   Inputs
   WimpUserMessageAcknowledgeEvent *const  user_message_acknowledge :
       user message ackowledge event data

   Returns
   success: NULL
   failure: pointer to RISC OS error block
 */

static _kernel_oserror *  handle_user_message_acknowledge (
    WimpUserMessageAcknowledgeEvent *const  user_message_acknowledge)
{
    _kernel_oserror *  e = NULL;

    DBUG_PRINTF(DBUG_LVL_DIAG, "handle_user_message_acknowledge()\n");

    if (user_message_acknowledge->hdr.action_code == Wimp_MQuit)
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "handle_user_message_acknowledge() : Wimp_MQuit recieved.\n");
      task_closedown ();
    }

    /* Handle prelogoff */
    if (user_message_acknowledge->hdr.action_code == Wimp_MPreLogOff)
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "handle_user_message_acknowledge() : WimpPreLogOffMessage recieved (%d, %d).\n", user_message_acknowledge->hdr.my_ref, my_prelogoff_ref);
      /* Check whether it was a bounce or not. */
      if (user_message_acknowledge->hdr.my_ref == my_prelogoff_ref)
      {
        /* Continue with the Logoff */
        DBUG_PRINTF(DBUG_LVL_DIAG, "handle_user_message_acknowledge() : Prelogoff message was bounced. Sending message logoff\n");
        e = send_logoff();
      }
    }

    /* Handle logoff */
    if (user_message_acknowledge->hdr.action_code == Wimp_MLogOff)
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "handle_user_message_acknowledge() : WimpLogOffMessage recieved (%d, %d).\n", user_message_acknowledge->hdr.my_ref, my_logoff_ref);
      /* Check whether it was a bounce or not. */
      if (user_message_acknowledge->hdr.my_ref == my_logoff_ref)
      {
        /* Logoff */
        NCMA_STATE state;
        DBUG_PRINTF(DBUG_LVL_DIAG, "handle_user_message_acknowledge() : logoff message was bounced. Perform logoff\n");
        state = logoff();
      }
    }

    return e;
}



/* -----------------------------------------------------------------------------
   handle_user_message_quit

   Handles a quit.

   Inputs
   None

   Returns
   success: NULL
   failure: pointer to RISC OS error block
*/
static _kernel_oserror *  handle_user_message_quit (void)
{
    _kernel_oserror *  e = NULL;
    DBUG_PRINTF(DBUG_LVL_DIAG, "handle_user_message_quit() : Wimp_MQuit called.\n");
    e = task_closedown ();
    return e;
}


/* -----------------------------------------------------------------------------
   handle_user_message_logoff

   Handles a logoff.

   Inputs
   None

   Returns
   success: NULL
   failure: pointer to RISC OS error block
*/
static _kernel_oserror *  handle_user_message_logoff (WimpUserMessageEvent event)
{
    _kernel_oserror *  e = NULL;
    DBUG_PRINTF(DBUG_LVL_DIAG, "handle_user_message_logoff()\n");
    if (event.hdr.my_ref != my_logoff_ref)
    {
      NCMA_STATE state;
      /* logoff message was sent by another task, so do actual logoff */
      DBUG_PRINTF(DBUG_LVL_DIAG, "handle_user_message_logoff(): logoff message was sent by another task, so do actual logoff\n");
      state = logoff();
    }
    return e;
}


/* -----------------------------------------------------------------------------
   handle_user_message_prelogoff

   Handles a prelogoff.

   Inputs
   None

   Returns
   success: NULL
   failure: pointer to RISC OS error block
*/
static _kernel_oserror *  handle_user_message_prelogoff (WimpUserMessageEvent event)
{
    _kernel_oserror *  e = NULL;
    DBUG_PRINTF(DBUG_LVL_DIAG, "handle_user_message_prelogoff()\n");
    if (event.hdr.my_ref != my_prelogoff_ref)
    {
      /* logoff message was sent by another task, so ??? */
      DBUG_PRINTF(DBUG_LVL_DIAG, "handle_user_message_prelogoff(): prelogoff message was sent by another task, so ???\n");
    }
    return e;
}




/* -----------------------------------------------------------------------------
   send_pre_logoff

   Broadcast the PreLogoff message to all tasks.

   Returns
   success: NULL
   failure: pointer to RISC OS error block
 */

_kernel_oserror *  send_pre_logoff (void)
{
    WimpMessage  message;
    _kernel_oserror *  e = NULL;

    DBUG_PRINTF(DBUG_LVL_DIAG, "send_pre_logoff()\n");

    message.hdr.size = sizeof (message.hdr) + sizeof (message.data.shutdown);
    message.hdr.your_ref = 0;
    message.hdr.action_code = Wimp_MPreLogOff;

    message.data.shutdown.flags = 0;

    e = wimp_send_message (Wimp_EUserMessageRecorded,
                              &message,
                              0,
                              0,
                              NULL);
    my_prelogoff_ref = message.hdr.my_ref;
    DBUG_PRINTF(DBUG_LVL_DIAG, "prelogoff message sent. my_ref = %d\n", my_prelogoff_ref);
    return (e);
}

/* -----------------------------------------------------------------------------
   send_logoff

   Broadcast the Logoff message to all tasks.

   Returns
   success: NULL
   failure: pointer to RISC OS error block
 */

static _kernel_oserror *  send_logoff (void)
{
    WimpMessage  message;
    _kernel_oserror *  e = NULL;

    DBUG_PRINTF(DBUG_LVL_DIAG, "send_logoff()\n");

    message.hdr.size = sizeof (message.hdr) + sizeof (message.data.shutdown);
    message.hdr.your_ref = 0;
    message.hdr.action_code = Wimp_MLogOff;

    message.data.shutdown.flags = 0;

    e = wimp_send_message (Wimp_EUserMessageRecorded,
                              &message,
                              0,
                              0,
                              NULL);
    my_logoff_ref = message.hdr.my_ref;
    DBUG_PRINTF(DBUG_LVL_DIAG, "logoff message sent. my_ref = %d\n", my_logoff_ref);
    return (e);
}



/* -----------------------------------------------------------------------------
   handle_user_message_restart_prelogoff

   Restarts the logoff process..

   Inputs
   None

   Returns
   success: NULL
   failure: pointer to RISC OS error block
*/
static _kernel_oserror * handle_user_message_restart_prelogoff (void)
{
    _kernel_oserror *  e = NULL;
    DBUG_PRINTF(DBUG_LVL_DIAG, "handle_user_message_restart_prelogoff() recieved. Resending prelogoff message.\n");
    e = send_pre_logoff();
    return e;
}

