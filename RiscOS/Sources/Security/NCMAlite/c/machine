#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"
#include "os.h"

#define PROTOTYPES_INTERNAL /* make prototypes and globals internal to this file */
#include "machine.h"
#include "module.h"
#include "ncma_ncma.h"
#include "ncma_scard.h"
#include "ncma_url.h"
#include "ncma_utils.h"
#include "ncma_dial.h"
#include "ncma_cache.h"
#include "ncma_bootb.h"
#include "ncma_net.h"
#include "ncma_fx.h"
#include "vectors.h"


#include "DBUG.h"


#ifdef SC_SWAPPING
/* Declare all global variables required for the cmartcard swapping version
    of the module.*/
unsigned int bNoScreenChanges = 0; /* Screen changes are allowed */
unsigned int bCardVerified = 0;    /* Card is intially unverified */
NCMA_STATE   uiPreviousState = State_NCMAInit;
unsigned int bRedialRequested = 0; /* No redial has been requested */

int bootblock_num_bytes = 0;  /* This variable is used to store the number of bytes held in the cache. */
char *bootblock_copy;  /* This holds a copy of the memory area. */
#endif /* SC_SWAPPING */



#ifdef SC_SWAPPING
  /* Routine to free memory used in checking whether the smartcard is the
      same one as the session started with. This routine should be called at
      the end of a session. */
void tidy_memory(void)
{
  if (bootblock_copy) /* memory has been allocated */
  {
    free(bootblock_copy);
    bootblock_copy = NULL;
  }
}
#endif // SC_SWAPPING



char *trans_string(NCMA_TRANS trans)
{
  static char *t_table[] = {
    "Trans_Idle",
    "Trans_Timeout",
    "Trans_CardOK",
    "Trans_CardBad",
    "Trans_CardRemoved",
    "Trans_CompleteOK",
    "Trans_CompleteBad",
    "Trans_AuthFail",
    "Trans_URLStart",
    "Trans_URLRetry",
    "Trans_Registry",
    "Trans_Shutdown",
    "Trans_ShutdownComplete",
    "Trans_URLShutdown",
    "Trans_URLShutdownCancel",
    "Trans_URLUnblock",
    "Trans_URLChangePIN",
    "Trans_URLLeavePIN",
    "Trans_PowerUp",
    "Trans_DialOK",
    "Trans_DialBad",
    "Trans_URLMismatch",
    "Trans_URLMismatchAck",
    "Trans_NCMASurf",
    "Trans_URLDownloadMin",
    "Trans_URLDownloadMax",
    "Trans_URLDownloadSched",
    "Trans_URLDownloadNak",
    "Trans_URLConnect",
    "Trans_URLConnectNak",
    "Trans_MIMEOk",
    "Trans_MIMEBad",
    "Trans_URLMovedAck",
    "Trans_URLMovedNak",
#ifdef TRAP_PPP_TIMEOUTS
    "Trans_PPPTimeout",
#endif
    "Trans_DisconnectAck",
#ifdef POINTLESS_BUTTONS
    "Trans_URLSmartcardAck",
    "Trans_URLBadCardAck",
#endif
     "Trans_URLDisconnectNak",
     "Trans_URLBadUnblockPINAck",
     "Trans_HUP",
     "Trans_BootedFull",
     "Trans_BootedFast",
     "Trans_BootedUpdate",
     "Trans_URLTransfer",
     "Trans_Cron",
     "Trans_URLPinNAK",
     "Trans_PreConnect",
#ifdef SC_SWAPPING
     "Trans_Logout",
     "Trans_LogoutAck",
     "Trans_LogoutNak",
     "Trans_NCMADialUI_Start",
     "Trans_WrongISPCard",
#endif /* SC_SWAPPING */
     "Trans_HangUp"
  };


  return(t_table[trans]);
}

char *state_string(NCMA_STATE state)
{
    static char *s_table[] = {
    "State_NCMAInit",
    "State_NCMAStart",
    "State_NCMAPanic",
    "State_NCMASleep",
    "State_NCMANoCard",
    "State_NCMABadCard",
    "State_NCMAPin",
#ifdef CHIMPANZEE_INTERFACE
    "State_NCMADefaultPIN",
    "State_NCMAApresPIN",
#endif
    "State_NCMADiallingISP",
    "State_NCMABadPin",
    "State_NCMAShutdown",
    "State_NCMAUnblock",
    "State_NCMAChangePIN",
    "State_NCMANewPIN",
    "State_NCMAMismatch",
    "State_NCMABooted",
    "State_NCMADownload",
    "State_NCMAConnect",
    "State_NCMADiallingRelServer",
    "State_NCMAMoved",
    "State_NCMADiallingRegServer",
    "State_NCMABadUnblockPIN",
#ifdef SC_SWAPPING
    "State_NCMALogout",
    "State_NCMAWrongISPCard",
#endif /* SC_SWAPPING */
    "State_Cron"
  };

  return(s_table[state]);
}



/* build tag cache without connecting, to allow ISPCapture to display current sc values */
NCMA_STATE PreConnect_in_NCMA_Connect()
{
  DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: PreConnect_in_NCMA_Connect() called\n");

#ifdef SC_SWAPPING
/* Check that sc_bootblock returns that the cards are the same. */
                   {
                     int temp_return_value = fetch_sc_bootblock(1);
		     if(temp_return_value == -1)
		     {
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read sc bootblock\n");
                         return(State_NCMAConnect);
		     }
		     if(temp_return_value == -2)
		     {
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard is not the same one as at start of session.\n");
                         ncma_dbox_open(URL_PATH(correct.html));
                         return(State_NCMAWrongISPCard);
		     }
                   }
#else
		     if(fetch_sc_bootblock(1)<0)
		     {
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read sc bootblock\n");
                         return(State_NCMAConnect);
		     }
#endif /* SC_SWAPPING */

  if(virgin_smartcard()) {
      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: preconnect, nothing on card\n");
      return(State_NCMAConnect);
  }

  if(build_ram_cache()<0) {
      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: preconnect, couldn't build RAM cache\n");
      return(State_NCMAConnect);
  }
  return(State_NCMAConnect);
}




/*
  Connect to ISP, reading smartcard values.
*/
NCMA_STATE URLConnect_in_NCMA_Connect(void)
{
  DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: URLConnect_in_NCMA_Connect() called\n");
#ifdef ETHERNET
       		     ncma_dbox_close();
#endif

#ifdef SC_SWAPPING
/* Check that sc_bootblock returns that the cards are the same. */
                   {
                     int temp_return_value = fetch_sc_bootblock(0);
		     if(temp_return_value == -1)
		     {
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read sc bootblock\n");
		     }
		     if(temp_return_value == -2)
		     {
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard is not the same one as at start of session.\n");
                         ncma_dbox_open(URL_PATH(correct.html));
                         return(State_NCMAWrongISPCard);
		     }
                   }
#else
		     if(fetch_sc_bootblock(0)<0)
		     {
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read sc bootblock\n");

#ifdef ISP_CAPTURE
       			 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: running ISP capture\n");
       			 ncma_isp_capture();
       			 return(State_NCMAConnect);
#else
		         ncma_dbox_open(URL_PATH(invalid.html)); // was dmaged.html
		         return(State_NCMABadCard);
#endif
		     }
#endif /* SC_SWAPPING */


		     if(virgin_smartcard()) { /* smartcard never been written to */
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read sc bootblock\n");
#ifdef ISP_CAPTURE
       			 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: running ISP capture\n");
       			 ncma_isp_capture();
       			 return(State_NCMAConnect);
#else
		         ncma_dbox_open(URL_PATH(invalid.html)); // was damaged.html
		         return(State_NCMABadCard);
#endif
		     }



      		     if(build_ram_cache()<0) { /* insufficient connect details, call RS */
      		             DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: insufficient connection details - calling RS\n");
#ifdef ISP_CAPTURE
       			 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: running ISP capture\n");
       			 ncma_isp_capture();
       			 return(State_NCMAConnect);
#else

		         ncma_dbox_open(URL_PATH(invalid.html)); // was damaged.html
		         return(State_NCMAConnect);
#endif

      		     }

      		       /* dial based on connection details in RAM/SC */
      		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: RAM/SC DIALLING...\n");
      		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Calling ncma_dial() automatically.\n");
      		       if(ncma_dial()<0)
                       {
      		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: ISP dial initiation failed\n");
      		         ncma_dbox_close();
      		         ncma_url_open(URL_PATH(connect.html));
      		         return(State_NCMAConnect);
      		       }
		     return(State_NCMADiallingISP);
}






/* this is the NCMA ASM */
NCMA_STATE machine(NCMA_TRANS trans)
{

#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got transition %s in state %s\n", trans_string(trans), state_string(ncma_state));
#else
  if(trans != Trans_CompleteOK)
    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got transition %s in state %s\n", trans_string(trans), state_string(ncma_state));
#endif

/*********************************************************************************

    GLOBAL TRANSITIONS

 *********************************************************************************/

  switch(trans) { /* global transitions that apply to all states (except maybe State_Sleep) */

    case Trans_Shutdown:
         if(ncma_state != State_NCMAShutdown) { /* if we're not already in shutdown state, save context */
    	   pre_shutdown_state = ncma_state;
    	   DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: shutdown imminent - pushed state \"%s\"\n", state_string(ncma_state));
    	   ncma_standby_dbox_open(URL_PATH(poweroff.html));
    	   return(State_NCMAShutdown);
    	 }
    	 break;

    case Trans_Registry: /* HACK - damn s/c layer doesn't always report Card_Removed */
         if(registry_status_cleared(BB_STATUS_INSERTED)) goto card_removed;
         break;

    case Trans_CardRemoved:
         card_removed:

#ifdef SC_SWAPPING
         /* We only want the line to be dropped globally if we are not in
             State_NCMABooted or State_NCMADiallingISP, as those states
             handle the situation themselves.
            Otherwise do as below. Also, it should not be dropped if the
             bNoScreenChanges flag is set. */
         if ((ncma_state != State_NCMABooted &&
              ncma_state != State_NCMADiallingISP) && !bNoScreenChanges)
         {
#endif /* SC_SWAPPING */

    	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard removed, hanging up, flushing cache\n");
#ifdef POINTLESS_BUTTONS
    	 run_from_powerup = 0;
    	 pointless_button_clicked = 0;
    	 ncma_hourglass_off(); /* might be on, if we're in chimp mode */
#endif
	 ncma_hangup();
	 ncma_dbox_close();
    	 reset_cache(); /* was unlock_cache() */

#ifdef POINTLESS_BUTTONS
         if(ncma_state == State_NCMABadCard) return(State_NCMABadCard); /* oh, how hatefully poor */
#endif

	if(ncma_started) {
                //ncma_dbox_open(URL_PATH(splash.html));
                //return(State_NCMANoCard);
#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif
	          return(State_NCMAInit);
        } else return(State_NCMAInit); /* sc layer kicks off with a card removed event */

#ifdef SC_SWAPPING
       }
#endif // SC_SWAPPING

        break;

    default:
         break;
  }

  switch(ncma_state) {

/*********************************************************************************

    STATE_NCMAINIT

 *********************************************************************************/
    case State_NCMAInit:  /* start-up, pre WIMP stage */

         switch(trans) {

	   case Trans_NCMASurf: /* we might wanna surf, but have removed the smartcard
	   			   thus we have to go through all the s/c and dial up crap,
	   			   and when it's finished remember that we want the Internet
	   			   home page, not the top level UI */
	   	//surf_again = 1;
	   	ncma_trans = Trans_URLStart;
	   	setcallback();
	   	return(State_NCMAInit);
	   	break;


           case Trans_HUP: /* HUP ack, we're displaying an error screen and waiting for retry */
                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got HUP, ignoring\n");
                return(State_NCMAInit);
                break;

           case Trans_CardOK: /* ignore it */
           	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ignoring card OK event\n");
           	return(State_NCMAInit);
           	break;

	   case Trans_PowerUp:  /* and so, I awake... */
	   	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: POWERUP\n");



	   	if(!smartcard_present()) { /* powered up but no card? Fetch the blurb */

#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif
		  run_from_powerup = 0;
	   	  return(State_NCMAInit);
	   	}

	   	/* otherwise, there's a card in, so fall through */
		run_from_powerup = 1;
	   	/* \/ \/ \/ \/ \/ DELIBERATE FALL THRU \/ \/ \/ \/ \/ */



           case Trans_URLStart: /* got a URL/CLI type call */

#ifdef POINTLESS_BUTTONS
       		pointless_ncma_manual_restart:
#endif

                ncma_started = 1;

	        /* read our status vars so smartcard checking works
	           (because we've no doubt missed a bunch of registry service calls */

	           registry_status = smartcard_status(NULL);
	           registry_delta = registry_status; /* assume everything set */

	   	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Managed access starting\n");
		if(!smartcard_present()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no smartcard - fetching splash screen\n");
		    ncma_dbox_open(URL_PATH(splash.html));
		    return(State_NCMANoCard);
		}

		if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard - bailing\n");
		    ncma_dbox_open(URL_PATH(invalid.html));
		    return(State_NCMABadCard);
		}


		if(smartcard_pin_protected()) {
		    card_attempts = smartcard_blocked();
		    if(card_attempts>0) {
#ifdef CHIMPANZEE_INTERFACE
       		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not blocked (%d), trying default PIN\n", card_attempts);
       		      default_pin();
       		      /* a virgin card doesn't generate any status calls on authentication, because NCBootblock has
       		         already given up reading at this point, since it cannot construct a file sequence from the
       		         empty index file. Virgin smartcards will always ship with PIN (0000), so we call default_pin
       		         to set it for future operations, and then skip the bit of this state machine which expects a reply */
       		      return(State_NCMADefaultPIN);
#else

		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
		      ncma_dbox_open(URL_PATH(pin.html));
		      return(State_NCMAPin);
#endif
		    } else {
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard is blocked\n");
		        ncma_dbox_open(URL_PATH(unblock.html));
		        return(State_NCMAUnblock);
		    }
		}

		proceed_after_pin:

                if(bootblock_read_succeeded()==0) { /* bootblock read ok, but not finished yet */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock (init)\n");
                  return(State_NCMANoCard);
                }

#ifdef POINTLESS_BUTTONS
       		/* clear the hourglass and click condition from 'insert s/c' OSD */
		DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard ready - hourglass off\n");
                ncma_hourglass_off();
                pointless_button_clicked = 0;

#endif
		ncma_dbox_close();
		ncma_url_open(URL_PATH(connect.html));
#ifdef SC_SWAPPING
		DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: setting flag bCardVerified to TRUE - the card has been verified.\n");
                 bCardVerified = 1; /* Card is known to be valid */
#endif /* SC_SWAPPING */
		return(State_NCMAConnect);


#ifdef SC_SWAPPING
             /* The transition below copes with the explicit disconnect
                 button on the toolbar of Funai NC 2's being pressed. It exhibits the same
                 behaviour as occured with the smartcard being removed on other NC's. */
             case Trans_Logout:
               ncma_dbox_open(URL_PATH(logout.html)); /* Open the logout window */
               uiPreviousState = ncma_state;
               return (State_NCMALogout);
#endif /* SC_SWAPPING */

	 } /* end state_ncmainit */
	 break;

/*********************************************************************************

    STATE_NCMABADCARD

 *********************************************************************************/
    case State_NCMABadCard: /* waiting for URL/CLI call */

    	 switch(trans) {
#ifdef POINTLESS_BUTTONS
       	     case Trans_Registry:
       	     case Trans_CardRemoved:
       	     	  return(State_NCMANoCard);

       	     case Trans_URLBadCardAck:
       	     	  goto pointless_ncma_manual_restart;
#else
    	     case Trans_CardRemoved: /* user has removed bad card */

    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard removed\n");
    	     	  ncma_dbox_open(URL_PATH(splash.html));
    	     	  return(State_NCMANoCard);
#endif
    	 } /* end state_ncmabadcard */

    	 break;

/*********************************************************************************

    +STATE_NCMANOCARD

 *********************************************************************************/
    case State_NCMANoCard: /* waiting for a smartcard to be inserted */

         switch(trans) {
	    case Trans_CardOK:
	         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card_ok event - clearing status delta register\n");
	         smartcard_status(NULL);
	    	 return(State_NCMANoCard);

	    case Trans_Timeout: /* user clicked 'Continue' with no card inserted */
	    	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Card check timer expired\n");
	    	 pointless_button_clicked = 0;
	    	 ncma_hourglass_off();
	    	 ncma_dbox_open(URL_PATH(splash.html));
	    	 return(State_NCMANoCard);

            case Trans_Registry: /* card activity */

#ifdef POINTLESS_BUTTONS
       		 if((run_from_powerup | pointless_button_clicked)==0) {
		     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: r_f_p: %d p_b_c: %d -- ignoring\n",
		     				run_from_powerup, pointless_button_clicked);
       		     return(State_NCMANoCard);
       		 }
       		 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: cancel card scan timer\n");
       		 canceltimeout();
       		 /* else deliberate fall through to next case */

            case Trans_URLSmartcardAck:
            case Trans_URLStart: /* repeat click on "continue" from cancel setup screen */

                 if(!pointless_button_clicked) { /* continue not already pressed */
                     pointless_button_clicked = 1;
                     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Got click\n");
                     ncma_hourglass_on();
                     if(!smartcard_present()) {
                         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no card ; starting timer\n");
                         settimeout(CARD_SCAN_TIMEOUT);
                         return(State_NCMANoCard);
                     }
                 }

                 if(!smartcard_present()) {
                     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: pointless button clicked with no scard inserted - ignoring\n");
                     return(State_NCMANoCard);
                 }

                 if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard - bailing\n");
		    ncma_dbox_open(URL_PATH(invalid.html));
                    ncma_hourglass_off();
                    pointless_button_clicked = 0;
		    return(State_NCMABadCard);
		}


		if(smartcard_pin_protected()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected\n");
                    ncma_hourglass_off();
                    //pointless_button_clicked = 0;
		    card_attempts = smartcard_blocked();
		    if(card_attempts>0) {
#ifdef CHIMPANZEE_INTERFACE
       		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not blocked (%d), trying default PIN\n", card_attempts);
       		      default_pin();
       		      //if(virgin_smartcard()) goto proceed_after_pin; /* see top for explanation of this */
       		      return(State_NCMADefaultPIN);
#else

		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
		      ncma_dbox_open(URL_PATH(pin.html));
		      return(State_NCMAPin);
#endif
		    } else {
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard is blocked\n");
		        ncma_dbox_open(URL_PATH(unblock.html));
		        return(State_NCMAUnblock);
		    }
		} else {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard is not PIN protected\n");
		}

#else
		/* NOT POINTLESS_BUTTONS */

		//if(!registry_status_changed(BB_STATUS_LOCKED)) {
		if(!smartcard_present()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading PIN status (no card)\n");
		    return(State_NCMANoCard);
		}

		//if(registry_status_asserted(BB_STATUS_BADVERSION)) {
		if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: invalid smartcard\n");
		    ncma_dbox_open(URL_PATH(invalid.html));
		    return(State_NCMABadCard);
		}

	    	//if(registry_status_asserted(BB_STATUS_LOCKED)) { /* PIN protected */
	    	if(smartcard_pin_protected()) {

	    	    card_attempts = smartcard_blocked();
	    	    if(card_attempts>0) {
#ifdef CHIMPANZEE_INTERFACE
       		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not blocked (%d), trying defalt PIN\n", card_attempts);
       		      default_pin();
       		      //if(virgin_smartcard()) goto proceed_after_pin; /* see top for explanation of this */
       		      return(State_NCMADefaultPIN);
#else
 		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
		      ncma_dbox_open(URL_PATH(pin.html));
		      return(State_NCMAPin);
#endif
		    } else {
		      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard is blocked\n");
		      ncma_dbox_open(URL_PATH(unblock.html));
		      return(State_NCMAUnblock);
		    }
		}


                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
                if(bootblock_read_failed()) {
                     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bootblock read failed\n");
                     ncma_dbox_open(URL_PATH(invalid.html)); // was damaged.html
                     return(State_NCMABadCard);
                }
#endif
		/* ENDIF POINTLESS_BUTTONS */


		goto proceed_after_pin;

		break;

            case Trans_CardBad: /* bad card */

            	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bad card re-inserted\n");
            	 ncma_dbox_open(URL_PATH(damaged.html));
#ifdef POINTLESS_BUTTONS
                 ncma_hourglass_off();
                 pointless_button_clicked = 0;
#endif
            	 return(State_NCMABadCard);
         } /* end state_ncmanocard */
         break;

#ifdef CHIMPANZEE_INTERFACE
/*********************************************************************************

    STATE_NCMADEFAULTPIN

 *********************************************************************************/
    case State_NCMADefaultPIN:

    	 switch(trans) {
	     case Trans_AuthFail: /* default PIN failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure for default PIN (auth)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	    ncma_dbox_open(URL_PATH(pin.html));
	     	    return(State_NCMAPin);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open(URL_PATH(unblock.html));
	     	    return(State_NCMAUnblock);
	     	  }
	     	  break;

    	     case Trans_Registry: /* test status of default PIN transaction */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: default PIN failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	        ncma_dbox_open(URL_PATH(pin.html));
	     	        return(State_NCMAPin);
	     	      } else {
	     	        ncma_dbox_open(URL_PATH(unblock.html));
	     	        return(State_NCMAUnblock);
	     	      }
	     	      break;


	     	  }
		  /* default PIN succeeded */
	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: default PIN succeeded\n");
                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

		      goto proceed_after_pin;
	     	      break;
	          }


    	 } /* end state_ncmadefaultpin */
    	 break;
#endif
/*********************************************************************************

    +STATE_NCMAPIN

 *********************************************************************************/
    case State_NCMAPin:

    	 switch(trans) {

	     case Trans_CardOK:
	     	  return(State_NCMAPin);
	     	  break;

	     case Trans_URLPinNAK:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: user cancelled PIN entry\n");
	     	  ncma_dbox_close();
#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif

		  return(State_NCMAInit);
	     	  //ncma_dbox_open(URL_PATH(splash.html));
	     	  //return(State_NCMANoCard);
	     	  break;

	     case Trans_AuthFail: /* the user entered a pin, but it failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure (authfail)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	    ncma_dbox_open(URL_PATH(badpin.html));
                    ncma_hourglass_off();
	     	    return(State_NCMABadPin);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open(URL_PATH(unblock.html));
                    ncma_hourglass_off();
	     	    return(State_NCMAUnblock);
	     	  }
	     	  break;

    	     case Trans_Registry: /* the user entered a pin, maybe it worked, maybe it didn't */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	        ncma_dbox_open(URL_PATH(badpin.html));
                        ncma_hourglass_off();
	     	        return(State_NCMABadPin);
	     	      } else {
	     	        ncma_dbox_open(URL_PATH(unblock.html));
                        ncma_hourglass_off();
	     	        return(State_NCMAUnblock);
	     	      }
	     	      break;
	     	  }

	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");
                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;
#ifdef SC_SWAPPING
	              DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: setting flag bCardVerified to TRUE - the card has been verified. #2\n");
                      bCardVerified = 1; // Card is known to be valid
#endif /* SC_SWAPPING */

#ifdef CHIMPANZEE_INTERFACE
       		      ncma_trans = Trans_Registry; /* cue on up */
       		      setcallback();

#ifdef SC_SWAPPING
	              DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: setting flag bCardVerified to TRUE - the card has been verified. #3\n");
                      bCardVerified = 1; // Card is known to be valid
#endif // SC_SWAPPING

       		      return(State_NCMAApresPIN);
#else

		      goto proceed_after_pin;
	     	      break;
#endif
	          }


    	 } /* end state_ncmapin */
    	 break;

#ifdef CHIMPANZEE_INTERFACE
/*********************************************************************************

    STATE_NCMAAPRESPIN wait for registry completion on bootblock read after user PIN entry

 *********************************************************************************/
    case State_NCMAApresPIN:

         switch(trans) {

             case Trans_Registry:
                if(bootblock_read_succeeded()==0) { /* bootblock read ok, but not finished yet */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock (after pin)\n");
                  return(State_NCMAApresPIN);
                }

		ncma_dbox_close();
                ncma_hourglass_off(); /* Pin checking finished */
#ifdef SC_SWAPPING
                if (!bNoScreenChanges) /* Screens can change */
                {
		  ncma_url_open(URL_PATH(connect.html));
                }
                else /* Screens cannot change */
                {
                  if (bCardVerified)
                  {
                    NCMA_STATE new_state;
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Screens cannot change, but card is now verified\n");
                    if (bRedialRequested)
                    {
                      new_state = URLConnect_in_NCMA_Connect(); // Rebuild all caches.
                    }
                    if (new_state == State_NCMAWrongISPCard)
                    {
                      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Setting state to %s\n", state_string(new_state));
                      return (new_state);
                    }
                    else
                    {
                      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Setting state to State_NCMADiallingISP\n");
                      return(State_NCMADiallingISP);
                    }
                  }
                  else
                  {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Screens cannot change, and card is unverified\n");
                  }
                }
#else
		ncma_url_open(URL_PATH(connect.html));
#endif /* SC_SWAPPING */
		return(State_NCMAConnect);


 	 }
	 break;
#endif


/*********************************************************************************

    STATE_NCMABADPIN

 *********************************************************************************/
    case State_NCMABadPin:

         switch(trans) {

	     case Trans_CardOK:
	     	  return(State_NCMABadPin);
	     	  break;

             case Trans_URLRetry:
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: getting ready for another go\n");
             	  //ncma_url_open("file:/ncma:pin.html");
             	  ncma_dbox_open(URL_PATH(pin.html));
             	  return(State_NCMAPin);
         } /* end state_ncmabadpin */
         break;

/*********************************************************************************

    +STATE_NCMACONNECT

 *********************************************************************************/
    case State_NCMAConnect:

    	 switch(trans) {

	     case Trans_URLChangePIN: /* the user clicked on 'change pin' */
	     	  ncma_dbox_open(URL_PATH(newpin.html));
	     	  return(State_NCMANewPIN);

             case Trans_PreConnect: /* byild tag cache without connecting, to allow ISPCapture to display current sc values */
                  return(PreConnect_in_NCMA_Connect());

	     case Trans_URLConnect:
                  return (URLConnect_in_NCMA_Connect());


#ifdef SC_SWAPPING
             /* The transition below copes with the explicit disconnect
                 button on the toolbar of Funai NC 2's being pressed. It exhibits the same
                 behaviour as occured with the smartcard being removed on other NC's. */
             case Trans_Logout:
                  ncma_dbox_open(URL_PATH(logout.html)); // Open the logout window
                  uiPreviousState = ncma_state;
                  return (State_NCMALogout);
#endif /* SC_SWAPPING */

             case Trans_URLConnectNak:
                  ncma_url_open(WELCOME_SCREEN_URL);
     	          run_from_powerup = 0;
             	  return(State_NCMAInit);
                  break;
         } /* end state_ncmaconnect */
         break;


/*********************************************************************************

    STATE_NCMADIALLINGISP

 *********************************************************************************/
    case State_NCMADiallingISP:

    	 switch(trans) {

    	     case Trans_DialBad: /* Don't know what to do here! Not in the CIS!! */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ISP dial failed - bummer\n");
    	     	  ncma_dbox_close();
    	     	  ncma_url_open(URL_PATH(connect.html));
    	     	  return(State_NCMAConnect);
    	     	  break;

    	     case Trans_DialOK: /* dial succeeded */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ISP dial succeeded\n");

#ifdef DEBUG_DISCONNECT
       		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: DEBUG_DISCONNECT setting line drop timeout\n");
       		  set_ppp_timeout();
#endif

#ifdef SC_SWAPPING
                  if (bRedialRequested)
                  {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: A redial was requested, so not calling ncma_network_init() and resetting bRedialRequested\n");
                    bRedialRequested = 0;
                  }
                  else
                  {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: No redial requested, so calling ncma_network_init()\n");
#endif /* SC_SWAPPING */
    	     	    ncma_network_init(NCMA_NET_RAM | NCMA_NET_POST_DIAL); /* set resolver variables */

                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Calling ncma_url_user\n");
                    if (ncma_url_user() != 0)
    		    {
          	        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Hanging up due to ncma_url_user() != 0, and returning State_NCMAConnect\n");
		        ncma_hangup();
			ncma_dbox_open( URL_PATH(badurldbox.html) );
			return(State_NCMAConnect);
		    }
#ifdef SC_SWAPPING
                  }

                  DBUG_PRINTF(DBUG_LVL_DIAG, "Resetting bNoScreenChanges to 0 and moving to State_NCMABooted.\n");
                  bNoScreenChanges = 0;
#endif /* SC_SWAPPING */

    	     	  return(State_NCMABooted);
 		  break;

#ifdef SC_SWAPPING
             case Trans_CardRemoved:  /* Ignoring this case. */
               DBUG_PRINTF(DBUG_LVL_DIAG, "Ignoring transition Trans_CardRemoved in State_NCMADIallingISP.\n");
               bCardVerified = 0;
               return(State_NCMADiallingISP);
#endif /* SC_SWAPPING */

 	 } /* end state_ncmadiallingisp */
 	 break;

/*********************************************************************************

    +STATE_NCMABOOTED

 *********************************************************************************/
    case State_NCMABooted:

    	 switch(trans) {
#ifdef SC_SWAPPING
             /* The transition below is called when the browser wants to
                 restart a dial. If the card is currently verified, then it calls
                 NCDialUI_Start, otherwise it notes that a redial has been requested and
                 prompts for a card to be inserted. */
               case Trans_NCMADialUI_Start:
	         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: DiallerUI_Start has been called in State_NCMABooted\n");
                 if (!bCardVerified) /* Card is unverified */
                 {
	           DBUG_PRINTF(DBUG_LVL_DIAG, "Card is unverified; setting bNoScreenChanges and bRedialRequested\n");
	           reset_cache(); /* was unlock_cache() */
	           bNoScreenChanges = 1;
	           bRedialRequested = 1;
	           /* Check the current status of the card (eg. invalid, inserted, bad) and go to the appropriate screen. */
  		   if(!smartcard_present())
  		   {
  		     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no smartcard - fetching splash screen\n");
                     ncma_dbox_open(URL_PATH(splash.html));
  		     return(State_NCMANoCard);
  		   }

  		   if(!smartcard_valid())
                   {
  		     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard - bailing\n");
  		     ncma_dbox_open(URL_PATH(invalid.html));
  		     return(State_NCMABadCard);
  		   }

  		   if(smartcard_pin_protected())
                   {
		     card_attempts = smartcard_blocked();
		     if(card_attempts>0)
		     {
#ifdef CHIMPANZEE_INTERFACE
       		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not blocked (%d), trying default PIN\n", card_attempts);
       		       default_pin();
       		       /* a virgin card doesn't generate any status calls on authentication, because NCBootblock has
       		          already given up reading at this point, since it cannot construct a file sequence from the
       		          empty index file. Virgin smartcards will always ship with PIN (0000), so we call default_pin
       		          to set it for future operations, and then skip the bit of this state machine which expects a reply */
       		       return(State_NCMADefaultPIN);
#else

		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
		       ncma_dbox_open(URL_PATH(pin.html));
		       return(State_NCMAPin);
#endif
		     }
		     else
		     {
		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard is blocked\n");
		       ncma_dbox_open(URL_PATH(unblock.html));
		       return(State_NCMAUnblock);
		     }
		   }
                   return (State_NCMANoCard);
                 }
                 else
                 {
                   /* Card is verified, send a NCDialUI_Start */
                   DBUG_PRINTF(DBUG_LVL_DIAG, "Card is verified; sending a NCDialUI_Start\n");
      	           ncma_dial();
                 }
                 return (State_NCMABooted);

               case Trans_DialOK:
                 // Ignoring this case as it is produced after a Trans_NCMADialUI_Start if the redial was successful.
	         DBUG_PRINTF(DBUG_LVL_DIAG, "Ignoring Trans_DialOK\n");
               return (State_NCMABooted);

#endif /* SC_SWAPPING */

    	     case Trans_NCMASurf:
 	         DBUG_PRINTF(DBUG_LVL_DIAG, "Trans_NCMASurf in State_NCMABooted : calling ncma_url_user() and returning State_NCMABooted\n");
		  ncma_url_user();	/* this can happen when the user presses home - just let it fail if it must */
    	     	  return(State_NCMABooted);

#ifdef TRAP_PPP_TIMEOUTS
	     case Trans_PPPTimeout:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PPP timeout event received\n");
	     	  ignore_ppp_timeout = 1; /* next time, don't claim svc call, just let it happen */
	     	  set_ppp_timeout(); /* set short timeout for drop, in case user has dozed off */+
	     	  ncma_sound_effect(NCMA_TIMEOUT_SOUND);
	     	  ncma_dbox_close();
	     	  ncma_dbox_open(URL_PATH(disconnect.html));
	     	  return(State_NCMABooted);
#endif

	     case Trans_URLDisconnectAck: /* user wants to disconnect now */
	     	  ignore_ppp_timeout = 0; /* tell svc handler to block next timeout & notify us */
	     	  ncma_dbox_close();
	     	  ncma_hangup();
	     	  return(State_NCMABooted);

	     case Trans_URLDisconnectNak: /* user wants to carry on */
	     	  ignore_ppp_timeout = 0; /* tell svc handler to block next timeout & notify us */
	     	  set_ppp_timeout_long(); /* do the long timeout */
	     	  ncma_dbox_close();
	     	  return(State_NCMABooted);

	     case Trans_HUP: /* we've lost our connection */

#ifdef SILENT_HUP
       		  /* no special action - rely on browser to bring the line back up
       		     note that this might be thru a ref. to NCFresco$Home, which is
       		     a macro which evaluates to ncma:userhome, which fires Trans_NCMASurf,
       		     which calls the browser (first trans above) which brings the line
       		     up. :) */
       		  return(State_NCMABooted);
#else
		  /* alternatively, bung the 'connect to isp' screen up and do all that pallaver */
       		  ncma_url_open(URL_PATH(connect.html));
	     	  return(State_NCMAConnect);
#endif

	     case Trans_URLConnect:
	     	  ncma_dbox_close();
		  ncma_url_open(URL_PATH(badurl.html));
	     	  return(State_NCMABooted);

	     case Trans_URLConnectNak:
		  ncma_hangup();
	     	  ncma_dbox_close();
		  ncma_url_open(WELCOME_SCREEN_URL);
     		  run_from_powerup = 0;
             	  return(State_NCMAInit);

	     case Trans_HangUp:
		  ncma_hangup();
	     	  ncma_dbox_close();
		  ncma_url_open(URL_PATH(connect.html));
		  return(State_NCMAConnect);

             case Trans_PreConnect: /* called by ISPCapture to ensure smartcard details are read */
		  ncma_hangup();
             	  return(State_NCMAConnect);

#ifdef SC_SWAPPING
             /* The transition below copes with the explicit disconnect
                 button on the toolbar of Funai NC 2's being pressed. It exhibits the same
                 behaviour as occured with the smartcard being removed on other NC's. */
             case Trans_Logout:
               uiPreviousState = ncma_state;
               ncma_dbox_open(URL_PATH(logout.html)); // Open the logout window
               return (State_NCMALogout);


             case Trans_CardRemoved:
               /* Card has been removed. From now on the card will be flagged as being unverified. */
               bCardVerified = 0;
               return (State_NCMABooted);
#endif /* SC_SWAPPING */


    	 } /* end state_ncmabooted */
    	 break;


 /*********************************************************************************

    +STATE_NCMASHUTDOWN

 *********************************************************************************/
    case State_NCMAShutdown:

         switch(trans) {

             case Trans_URLShutdown:
             case Trans_Shutdown:
                  prevent_shutdown = 0;
                  shutdown_nc();
                  ncma_standby_dbox_close(); /* close my dbox */
                  ncma_dbox_close(); /* close any other dbox. Yuck. */
                  ncma_url_open(BLANK_SCREEN_URL);
#ifdef SC_SWAPPING
                  tidy_memory();
#endif // SC_SWAPPING
                  return(State_NCMAShutdown);
                  break;

             case Trans_URLShutdownCancel:
                  ncma_standby_dbox_close();
             	  return(pre_shutdown_state);
             	  break;

             case Trans_ShutdownComplete:
             	  prevent_shutdown = 1;
             	  if(ui_present()) prod_browser_after_standby();
             	  return(State_NCMAInit);
             	  break;
         } /* end state_ncmashutdown */
         break;

/*********************************************************************************

    STATE_NCMAUNBLOCK

 *********************************************************************************/
    case State_NCMAUnblock:

         switch(trans) {

             case Trans_URLMismatch: /* user has entered unblock details */
             	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: unblock PIN mismatch\n");
             	  ncma_dbox_open(URL_PATH(mismatch.html));
             	  return(State_NCMAUnblock);

             case Trans_URLMismatchAck:
             	  ncma_dbox_open(URL_PATH(unblock.html));
             	  return(State_NCMAUnblock);

             case Trans_AuthFail:
             	  DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: PIN unblock failure\n");
             	  ncma_dbox_open(URL_PATH(badubp.html));
             	  return(State_NCMABadUnblockPIN);

             case Trans_CardOK: /* ignore these, they get spewed for an invalid unblock PIN */
             	  // DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: PIN unblock failure\n");
             	  // ncma_dbox_open(URL_PATH(unblock.html));
             	  return(State_NCMAUnblock);

    	     case Trans_Registry:
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failed failed\n");
	     	      ncma_dbox_open(URL_PATH(unblock.html));
	     	      return(State_NCMAUnblock);
	     	  }

	     	  if(registry_status_asserted(BB_STATUS_BB_VALID) || registry_status_cleared(BB_STATUS_LOCKED) ||
	     	  		registry_status_cleared(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");

                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;
                      ncma_dbox_close();

		      ncma_url_open(URL_PATH(connect.html));
        	      return(State_NCMAConnect);

	     	  }
    	 }
    	 break;


/*********************************************************************************

    STATE_NCMABADUNBLOCKPIN

 *********************************************************************************/
    case State_NCMABadUnblockPIN:

         switch(trans) {

             case Trans_URLBadUnblockPINAck:
             	  ncma_dbox_open(URL_PATH(unblock.html));
             	  return(State_NCMAUnblock);
         }
         break;



/*********************************************************************************

    STATE_NCMANEWPIN

 *********************************************************************************/
    case State_NCMANewPIN:

    	 switch(trans) {

	     case Trans_AuthFail: /* failed setting PIN */ /* this shouldn't happen */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failure\n");
	     	  ncma_dbox_open(URL_PATH(newpin.html));
	     	  return(State_NCMANewPIN);

	     	  break;

	     case Trans_URLMismatch: /* the two PINs the user entered didn't match */
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: fetching PIN mismatch page\n");
	     	  ncma_dbox_open(URL_PATH(mismatch.html));
	     	  return(State_NCMAMismatch);
	     	  break;

	     case Trans_URLLeavePIN: /* a cancel on the change pin OSD */
	     	  if(ui_present()) {
	     	     ncma_url_gsopen(TOPLEVEL_UI_URL);
	     	     return(State_NCMABooted);
	     	  } else {
	     	    ncma_dbox_close();
	     	    ncma_url_open(URL_PATH(connect.html));
	     	    return(State_NCMAConnect);
	     	  }
	     	  break;

    	     case Trans_Registry: /* PIN set status from registry */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failed failed\n"); /* this shouldn't happen */
	     	      ncma_dbox_open(URL_PATH(newpin.html));
	     	      return(State_NCMANewPIN);
	     	  }

	     	  if(registry_status_asserted(BB_STATUS_BB_VALID) || registry_status_cleared(BB_STATUS_LOCKED) ||
	     	  		registry_status_cleared(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");

                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;
		      ncma_dbox_close();
		      ncma_url_open(URL_PATH(connect.html));
        	      return(State_NCMAConnect);

	     	  }
    	 }
    	 break;


/*********************************************************************************

    STATE_NCMAMISMATCH

 *********************************************************************************/
    case State_NCMAMismatch:

    	 switch(trans) {

    	     case Trans_URLMismatchAck:
    	     	  ncma_dbox_open(URL_PATH(newpin.html));
    	     	  return(State_NCMANewPIN);
    	     	  break;
    	 }
    	 break;





#ifdef SC_SWAPPING
/*********************************************************************************

    STATE_NCMALOGOUT

 *********************************************************************************/
    case State_NCMALogout:

    	 switch(trans) {

    	     case Trans_Logout:
        	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Recieved a Trans_Logout in State_NCMALogout; treated as a logout confirmation.\n");
              /* Deliberate case statement fall-through */
    	     case Trans_LogoutAck:
        	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: explicit logout acknowledged, hanging up, flushing cache\n");
#ifdef POINTLESS_BUTTONS
        	 run_from_powerup = 0;
        	 pointless_button_clicked = 0;
        	 ncma_hourglass_off(); /* might be on, if we're in chimp mode */
#endif
          	 ncma_hangup();
        	 ncma_dbox_close();
        	 reset_cache(); /* was unlock_cache() */
#ifdef SC_SWAPPING
                 tidy_memory();
#endif // SC_SWAPPING

#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif
	          return(State_NCMAInit);

    	     case Trans_LogoutNak: /* User has cancelled action */
        	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: explicit logout not acknowledged, returning to previous state\n");
    	     	  ncma_dbox_close(); /* Close the pop-up window */
    	     	  return(uiPreviousState); /* Return previous state */

              default:
        	 DBUG_PRINTF(DBUG_LVL_DIAG, "Error : Transition %s (num=%d) not recognised in State_NCMALogout\n", trans_string(trans), trans);
                break;

    	 }
    	 break;


/*********************************************************************************

    STATE_NCMAWrongISPCard

 *********************************************************************************/
   case State_NCMAWrongISPCard:
    	switch(trans)
        {
	    case Trans_CardOK:
	         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card_ok event in State_NCMAWrongISPCard - clearing status delta register\n");
	         smartcard_status(NULL);
	    	 return(State_NCMANoCard);

	    case Trans_CardRemoved:
	         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: cCardRemoved event in State_NCMAWrongISPCard - Opening splash.html and going to State_NCMANoCard\n");
	    	 ncma_dbox_open(URL_PATH(splash.html));
	    	 return(State_NCMANoCard);

	    case Trans_Timeout: /* user clicked 'Continue' with no card inserted */
	    	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Card check timer expired\n");
	    	 pointless_button_clicked = 0;
	    	 ncma_hourglass_off();
	    	 ncma_dbox_open(URL_PATH(splash.html));
	    	 return(State_NCMANoCard);        }

        break;
#endif /* SC_SWAPPING */



/*********************************************************************************

    STATE_NCMAPANIC

 *********************************************************************************/
    case State_NCMAPanic:
    default:

	 DBUG_PRINTF(DBUG_LVL_PANIC, "NCMA_machine: PANIC!\n");
	 return(State_NCMAPanic);

  } /* end switch STATE */

  if(trans == Trans_Registry) {
#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: sweet nothings from the registry\n");
#endif
      return(ncma_state);
  }

  if((trans == Trans_CompleteOK) || (trans == Trans_CompleteBad) || (trans == Trans_AuthFail)) {
#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
    DBUG_PRINTF(DBUG_LVL_DEBUG, "NCMA: spurious I/O ACK from smartcard driver...ignoring\n");
#endif
    return(ncma_state);
  }

  /* otherwise . . . PANIC!! */

  DBUG_PRINTF(DBUG_LVL_PANIC, "NCMA: state machine panic - invalid transition event %s in state %s\n",
  		      trans_string(ncma_trans), state_string(ncma_state));

#ifdef ABORT_ON_PANIC
  DBUG_PRINTF(DBUG_LVL_PANIC, "            setting state to State_Panic\n");
  return(State_NCMAPanic);
#else
  return(ncma_state);
#endif
}



