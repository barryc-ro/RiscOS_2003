#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"
#include "os.h"

#define PROTOTYPES_INTERNAL /* make prototypes and globals internal to this file */
#include "machine.h"
#include "module.h"
#include "ncma_ncma.h"
#include "ncma_scard.h"
#include "ncma_url.h"
#include "ncma_utils.h"
#include "ncma_dial.h"
#include "smtags.h"
#include "ncma_bootb.h"
#include "ncma_net.h"
#include "ncma_fx.h"
#include "vectors.h"
#include "init.h"

#include "DBUG.h"
#include "task.h"




#ifdef SC_SWAPPING
  /* Routine to free memory used in checking whether the smartcard is the
      same one as the session started with. This routine should be called at
      the end of a session. */
void tidy_memory(void)
{
  if (bootblock_copy) /* memory has been allocated */
  {
    free(bootblock_copy);
    bootblock_copy = NULL;
  }
}

static NCMA_STATE after_pin(void); /* Declare this routine */

#endif /* SC_SWAPPING */


#ifdef ENABLE_DEBUGGING
  extern const int DebugOutputDevice;
#endif /* ENABLE_DEBUGGING */



char *trans_string(NCMA_TRANS trans)
{
  static char *t_table[] = {
    "Trans_Idle",
    "Trans_Timeout",
    "Trans_CardOK",
    "Trans_CardBad",
    "Trans_CardRemoved",
    "Trans_CompleteOK",
    "Trans_CompleteBad",
    "Trans_AuthFail",
    "Trans_URLStart",
    "Trans_URLRetry",
    "Trans_Registry",
    "Trans_Shutdown",
    "Trans_ShutdownComplete",
    "Trans_URLShutdown",
    "Trans_URLShutdownCancel",
    "Trans_URLUnblock",
    "Trans_URLChangePIN",
    "Trans_URLLeavePIN",
    "Trans_PowerUp",
    "Trans_DialOK",
    "Trans_DialBad",
    "Trans_URLMismatch",
    "Trans_URLMismatchAck",
    "Trans_NCMASurf",
    "Trans_URLDownloadMin",
    "Trans_URLDownloadMax",
    "Trans_URLDownloadSched",
    "Trans_URLDownloadNak",
    "Trans_URLConnect",
    "Trans_URLConnectNak",
    "Trans_MIMEOk",
    "Trans_MIMEBad",
    "Trans_URLMovedAck",
    "Trans_URLMovedNak",
#ifdef TRAP_PPP_TIMEOUTS
    "Trans_PPPTimeout",
#endif
    "Trans_DisconnectAck",
#ifdef POINTLESS_BUTTONS
    "Trans_URLSmartcardAck",
    "Trans_URLBadCardAck",
#endif
     "Trans_URLDisconnectNak",
     "Trans_URLBadUnblockPINAck",
     "Trans_HUP",
     "Trans_BootedFull",
     "Trans_BootedFast",
     "Trans_BootedUpdate",
     "Trans_URLTransfer",
     "Trans_Cron",
     "Trans_URLPinNAK",
     "Trans_PreConnect",
     "Trans_NCMADialUI_Start",
     "Trans_Logout",
     "Trans_LogoutAck",
     "Trans_LogoutNak",
#ifdef SC_SWAPPING
     "Trans_WrongISPCard",
#endif /* SC_SWAPPING */
#ifdef EMAIL_CLIENT
    "Trans_NCMAEnterEmailSelectUserOffline",
    "Trans_NCMAEnterEmailSelectUserOnline",
    "Trans_NCMAEmailSelectUserAck",
    "Trans_NCMAEmailSelectUserNak",
#endif /* EMAIL_CLIENT */
     "Trans_HangUp"
  };


  return(t_table[trans]);
}

char *state_string(NCMA_STATE state)
{
    static char *s_table[] = {
    "State_NCMAInit",
    "State_NCMAStart",
    "State_NCMAPanic",
    "State_NCMASleep",
    "State_NCMANoCard",
    "State_NCMABadCard",
    "State_NCMAPin",
#ifdef CHIMPANZEE_INTERFACE
    "State_NCMADefaultPIN",
    "State_NCMAApresPIN",
#endif
    "State_NCMADiallingISP",
    "State_NCMABadPin",
    "State_NCMAShutdown",
    "State_NCMAUnblock",
    "State_NCMAChangePIN",
    "State_NCMANewPIN",
    "State_NCMAMismatch",
    "State_NCMABooted",
    "State_NCMADownload",
    "State_NCMAConnect",
    "State_NCMADiallingRelServer",
    "State_NCMAMoved",
    "State_NCMADiallingRegServer",
    "State_NCMABadUnblockPIN",
    "State_NCMALogout",
#ifdef SC_SWAPPING
    "State_NCMAWrongISPCard",
#endif /* SC_SWAPPING */
#ifdef EMAIL_CLIENT
    "State_NCMAEmailSelectUser",
#endif /* EMAIL_CLIENT */
    "State_Cron"
  };

  return(s_table[state]);
}


#ifdef EMAIL_CLIENT
char *email_status_string(EMAIL_CLIENT_STATE state)
{
  static char *state_table[] =
  {
    "none",
    "offline",
    "online"
  };
  return(state_table[state]);
}
#endif /* EMAIL_CLIENT */


/* Foward prototypes: */
NCMA_STATE start_redial(void);



/* This routine selects whether to go to the 'connect' or the 'continue'
    screen depending on whether or not the smartcard is inserted or verified,
    etc
*/
NCMA_STATE select_screen_to_move_to(void)
{
    DBUG_PRINTF(DBUG_LVL_DIAG, "select_screen_to_move_to()\n");

#ifdef SC_SWAPPING
  /* This code should go to either State_NCMAConnect or State_NCMAInit
      according to whether the smartcard is inserted or not.  */
  if (smartcard_present())
  {
    /* Smartcard is inserted. */
    DBUG_PRINTF(DBUG_LVL_DIAG, "select_screen_to_move_to(): Smartcard is inserted.\n");

    if (bCardVerified)
    {
      /* Since card is verified, can go to the 'Connect' screen and state. Do not reset the smartcard cache. */
      DBUG_PRINTF(DBUG_LVL_DIAG, "select_screen_to_move_to(): Card is verified. Going to the 'Connect' screen and state\n");
      ncma_url_open(URL_PATH(connect.html));
      ncma_state = State_NCMAConnect;
      return (State_NCMAConnect);
    }
    else
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "select_screen_to_move_to(): Smartcard is unverified. Going to the 'Welcome' screen and state\n");
      /* Drop through to the case below. */
    }
  }
  else
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "select_screen_to_move_to(): Smartcard is not inserted. Go to the 'Welcome' screen and state\n");
  }

  /* Smartcard is not inserted. Go to the 'Welcome' screen and state */
  DBUG_PRINTF(DBUG_LVL_DIAG, "select_screen_to_move_to(): Resetting the smartcard cache.\n");
  reset_cache(); /* was unlock_cache() */
#ifdef LOCAL_URL_PATHS
  ncma_url_open(URL_PATH(welcome.html));
#else
  ncma_url_open(WELCOME_SCREEN_URL);
#endif
  ncma_state = State_NCMAInit;
#else
  /* Non SC_SWAPPING builds */
  DBUG_PRINTF(DBUG_LVL_DIAG, "select_screen_to_move_to(): Non SC_SWAPPING build. Going to the 'Connect' screen and state\n");
  ncma_url_open(URL_PATH(connect.html));
  ncma_state = State_NCMAConnect;
  return (State_NCMAConnect);

#endif /* SC_SWAPPING */
  return(State_NCMAInit);
}



/* This routine initialises all variables to do with smartcard swapping and
    the email client. It is used at the beginning of a session, i.e. at
    initialisation and after a standby/logoff sequence. */
void initialise_variables(void)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "initialise_variables().\n");
  /* Reinitialise all data */
  bNoScreenChanges = 0; /* Screen changes are allowed */
  bRedialRequested = 0; /* No redial has been requested */
#ifdef SC_SWAPPING
  bCardVerified = 0;    /* Card is intially unverified */
  uiPreviousState = State_NCMAInit;
  tidy_memory();
#ifdef EMAIL_CLIENT
  uiemail_client_state = email_state_none; /* Reset email client state */
#endif /* EMAIL_CLIENT */
#endif /* SC_SWAPPING */

  /* Ensure that the post_initialisation() routine has been run - it may not have been if the module was soft-loaded */
  if (!post_initialisation_run)
  {
    post_initialisation();
    post_initialisation_run = TRUE;
  }
}



/* This routine is called from the task part of the module when the
    logoff message has been recieved. */
NCMA_STATE logoff(void)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "logoff() called. Logging out.\n");
  DBUG_PRINTF(DBUG_LVL_DIAG, "logoff(): explicit logout acknowledged, hanging up, flushing cache\n");
#ifdef POINTLESS_BUTTONS
  run_from_powerup = 0;
  pointless_button_clicked = 0;
  ncma_hourglass_off(); /* might be on, if we're in chimp mode */
#endif
  ncma_hangup(); /* Hang up the line */

  /* Decide which screen needs to be moved to, and move to it. */
  return(select_screen_to_move_to());
}



/* build tag cache without connecting, to allow ISPCapture to display current sc values */
NCMA_STATE PreConnect_in_NCMA_Connect()
{
  DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: PreConnect_in_NCMA_Connect() called\n");

#ifdef SC_SWAPPING
  /* Check that sc_bootblock returns that the cards are the same. */
  {
    int temp_return_value = fetch_sc_bootblock(FETCH_BOOTBLOCK_FOR_ISPCAPTURE);
    if(temp_return_value == -1)
    {
      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read sc bootblock\n");
      return(State_NCMAConnect);
    }
    if(temp_return_value == -2)
    {
      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard is not the same one as at start of session.\n");
      ncma_dbox_open_to_target(URL_PATH(correct.html), INCORRECT_DIALOGUE_BOX);
      return(State_NCMAWrongISPCard);
    }
  }
#else
  if(fetch_sc_bootblock(FETCH_BOOTBLOCK_FOR_ISPCAPTURE)<0)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read sc bootblock\n");
    return(State_NCMAConnect);
  }
#endif /* SC_SWAPPING */

  if(virgin_smartcard()) {
      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: preconnect, nothing on card\n");
      return(State_NCMAConnect);
  }

  if(build_ram_cache()<0) {
      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: preconnect, couldn't build RAM cache\n");
      return(State_NCMAConnect);
  }
  return(State_NCMAConnect);
}




/*
  Connect to ISP, reading smartcard values.
*/
NCMA_STATE URLConnect_in_NCMA_Connect(void)
{
  DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: URLConnect_in_NCMA_Connect() called\n");
  if (interface_type == ETHERNET_INTERFACE)
  {
    ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
  }

#ifdef SC_SWAPPING
/* Check that sc_bootblock returns that the cards are the same. */
                   {
                     int temp_return_value = fetch_sc_bootblock(FETCH_BOOTBLOCK_FOR_CLIENT);
		     if(temp_return_value == -1)
		     {
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read sc bootblock\n");
		     }
		     if(temp_return_value == -2)
		     {
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard is not the same one as at start of session.\n");
                         ncma_dbox_open_to_target(URL_PATH(correct.html), INCORRECT_DIALOGUE_BOX);
                         return(State_NCMAWrongISPCard);
		     }
                   }
#else
		     if(fetch_sc_bootblock(FETCH_BOOTBLOCK_FOR_CLIENT)<0)
		     {
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read sc bootblock\n");

#ifdef ISP_CAPTURE
       			 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: running ISP capture\n");
       			 ncma_isp_capture();
       			 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Going to State_NCMAConnect\n");
       			 return(State_NCMAConnect);
#else
		         ncma_dbox_open_to_target(URL_PATH(invalid.html), COMMON_DIALOGUE_BOX); // was dmaged.html
		         return(State_NCMABadCard);
#endif
		     }
#endif /* SC_SWAPPING */


		     if(virgin_smartcard()) { /* smartcard never been written to */
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read sc bootblock\n");
#ifdef ISP_CAPTURE
       			 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: running ISP capture\n");
       			 ncma_isp_capture();
       			 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Going to State_NCMAConnect\n");
       			 return(State_NCMAConnect);
#else
		         ncma_dbox_open_to_target(URL_PATH(invalid.html), COMMON_DIALOGUE_BOX); // was damaged.html
		         return(State_NCMABadCard);
#endif
		     }



      		     if(build_ram_cache()<0) { /* insufficient connect details, call RS */
      		         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: insufficient connection details - calling RS\n");
#ifdef ISP_CAPTURE
       			 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: running ISP capture\n");
       			 ncma_isp_capture();
       			 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Going to State_NCMAConnect\n");
       			 return(State_NCMAConnect);
#else
		         ncma_dbox_open_to_target(URL_PATH(invalid.html), COMMON_DIALOGUE_BOX); // was damaged.html
		         return(State_NCMAConnect);
#endif

      		     }

      		       /* dial based on connection details in RAM/SC */
      		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: RAM/SC DIALLING...\n");
      		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Calling ncma_dial() automatically.\n");

                       /* This line moved from State_DiallingISP so it is initialised *before* dialling. */
                       ncma_network_init(NCMA_NET_RAM | NCMA_NET_POST_DIAL); /* set resolver variables */

                       ncma_hourglass_on();
      		       if(ncma_dial()<0)
                       {
      		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: IAP dial initiation failed\n");
      		         ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
      		         ncma_url_open(URL_PATH(connect.html));
      		         return(State_NCMAConnect);
      		       }

                       if (interface_type == MODEM_INTERFACE)
                       {
                         /* Dial was successful, open the please wait screen
                             if the bNoScreenChanges is unset and a redial
                             was not requested. */
                         if (!bNoScreenChanges && !bRedialRequested)
                         {
                           DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Opening the please wait screen.\n");
                           ncma_url_open(URL_PATH(pleasewait.html));
                         }
                         else
                         {
                           DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Not opening the please wait screen as the bNoScreenChanges and bRedialRequested flags are set.\n");
                         }
                       }

        	       ncma_hourglass_off();
                       return(State_NCMADiallingISP);
}






/* this is the NCMA ASM */
NCMA_STATE machine(NCMA_TRANS trans)
{

#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got transition %s in state %s\n", trans_string(trans), state_string(ncma_state));
#else
  if(trans != Trans_CompleteOK)
    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got transition %s in state %s\n", trans_string(trans), state_string(ncma_state));
#endif

/*********************************************************************************

    GLOBAL TRANSITIONS

 *********************************************************************************/

  switch(trans)
  { /* global transitions that apply to all states (except maybe State_Sleep) */

    case Trans_Shutdown:
         if(ncma_state != State_NCMAShutdown) { /* if we're not already in shutdown state, save context */
    	   pre_shutdown_state = ncma_state;
    	   DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: shutdown imminent - pushed state \"%s\"\n", state_string(ncma_state));
    	   ncma_dbox_open_to_target(URL_PATH(poweroff.html), STANDBY_DIALOGUE_BOX);
    	   return(State_NCMAShutdown);
    	 }
    	 break;

    case Trans_Registry: /* HACK - damn s/c layer doesn't always report Card_Removed */
         if(registry_status_cleared(BB_STATUS_INSERTED)) goto card_removed;
         break;

    case Trans_CardRemoved:
         card_removed:

#ifdef SC_SWAPPING
         /* We only want the line to be dropped globally if we are not in
             State_NCMABooted or State_NCMADiallingISP, as those states
             handle the situation themselves.
            Otherwise do as below. Also, it should not be dropped if the
             bNoScreenChanges flag is set. */
         if ((ncma_state != State_NCMABooted &&
#ifdef EMAIL_CLIENT
              ncma_state != State_NCMAEmailSelectUser &&
#endif /* EMAIL_CLIENT */
              ncma_state != State_NCMADiallingISP) && !bNoScreenChanges)
         {
#endif /* SC_SWAPPING */

    	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard removed, hanging up, flushing cache\n");
#ifdef POINTLESS_BUTTONS
    	 run_from_powerup = 0;
    	 pointless_button_clicked = 0;
    	 ncma_hourglass_off(); /* might be on, if we're in chimp mode */
#endif
	 ncma_hangup();
	 ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
    	 reset_cache(); /* was unlock_cache() */

#ifdef POINTLESS_BUTTONS
         if(ncma_state == State_NCMABadCard) return(State_NCMABadCard); /* oh, how hatefully poor */
#endif

	if(ncma_started) {
                //ncma_dbox_open_to_target(URL_PATH(splash.html), COMMON_DIALOGUE_BOX);
                //return(State_NCMANoCard);
#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif
	          return(State_NCMAInit);
        } else return(State_NCMAInit); /* sc layer kicks off with a card removed event */

#ifdef SC_SWAPPING
       }
#endif // SC_SWAPPING

        break;

    default:
         break;
  }

  switch(ncma_state) {

/*********************************************************************************

    STATE_NCMAINIT

 *********************************************************************************/
    case State_NCMAInit:  /* start-up, pre WIMP stage */

         switch(trans) {

           case Trans_ShutdownComplete:
               /* This transition is needed since the standby module now
                   sends a logoff before the shutdown_complete, meaning that
                   NCMA goes into either the Init or Connect state (according
                   to whether smartcard is inserted or not) */
                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_ShutdownComplete received in State_NCMAInit\n");
                prevent_shutdown = 1;
                if(ui_present()) prod_browser_after_standby();
                return(State_NCMAInit);
                break;

	   case Trans_NCMASurf: /* we might wanna surf, but have removed the smartcard
	   			   thus we have to go through all the s/c and dial up crap,
	   			   and when it's finished remember that we want the Internet
	   			   home page, not the top level UI */
	   	//surf_again = 1;
	   	ncma_trans = Trans_URLStart;
	   	setcallback();
	   	return(State_NCMAInit);
	   	break;


           case Trans_HUP: /* HUP ack, we're displaying an error screen and waiting for retry */
                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got HUP, ignoring\n");
                return(State_NCMAInit);
                break;

           case Trans_CardOK: /* ignore it */
           	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ignoring card OK event\n");
           	return(State_NCMAInit);
           	break;

	   case Trans_PowerUp:  /* and so, I awake... */
	   	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: POWERUP\n");

	   	if(!smartcard_present()) { /* powered up but no card? Fetch the blurb */

#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif
		  run_from_powerup = 0;
	   	  return(State_NCMAInit);
	   	}

	   	/* otherwise, there's a card in, so fall through */
		run_from_powerup = 1;
	   	/* \/ \/ \/ \/ \/ DELIBERATE FALL THRU \/ \/ \/ \/ \/ */



           case Trans_URLStart: /* got a URL/CLI type call */

#ifdef POINTLESS_BUTTONS
       		pointless_ncma_manual_restart:
#endif

                ncma_started = 1;
                initialise_variables();

/* Below is the code which can be used to allow buffered output to DebugLib.
    This is the place where the buffering is disabled and hence the data gets
    flushed to the output device. */
#ifdef ALLOW_BUFFERED_DEBUGLIB_OUTPUT
                debug_output_buffer_off (0, DebugOutputDevice);
#endif /* ALLOW_BUFFERED_DEBUGLIB_OUTPUT */

	        /* read our status vars so smartcard checking works
	           (because we've no doubt missed a bunch of registry service calls */

	        registry_status = smartcard_status(NULL);
	        registry_delta = registry_status; /* assume everything set */

	   	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Managed access starting\n");
		if(!smartcard_present()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no smartcard - fetching splash screen\n");
		    ncma_dbox_open_to_target(URL_PATH(splash.html), COMMON_DIALOGUE_BOX);
		    return(State_NCMANoCard);
		}

		if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard - bailing\n");
		    ncma_dbox_open_to_target(URL_PATH(invalid.html), COMMON_DIALOGUE_BOX);
		    return(State_NCMABadCard);
		}


		if(smartcard_pin_protected()) {
		    card_attempts = smartcard_blocked();
		    if(card_attempts>0) {
#ifdef CHIMPANZEE_INTERFACE
       		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not blocked (%d), trying default PIN\n", card_attempts);
       		      default_pin();
       		      /* a virgin card doesn't generate any status calls on authentication, because NCBootblock has
       		         already given up reading at this point, since it cannot construct a file sequence from the
       		         empty index file. Virgin smartcards will always ship with PIN (0000), so we call default_pin
       		         to set it for future operations, and then skip the bit of this state machine which expects a reply */
       		      return(State_NCMADefaultPIN);
#else

		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
		      ncma_dbox_open_to_target(URL_PATH(pin.html), COMMON_DIALOGUE_BOX);
		      return(State_NCMAPin);
#endif
		    } else {
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard is blocked\n");
		        ncma_dbox_open_to_target(URL_PATH(unblock.html), COMMON_DIALOGUE_BOX);
		        return(State_NCMAUnblock);
		    }
		}

		proceed_after_pin:

                if(bootblock_read_succeeded()==0) { /* bootblock read ok, but not finished yet */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock (init)\n");
                  return(State_NCMANoCard);
                }

#ifdef POINTLESS_BUTTONS
       		/* clear the hourglass and click condition from 'insert s/c' OSD */
		DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard ready - hourglass off\n");
                ncma_hourglass_off();
                pointless_button_clicked = 0;

#endif

#ifdef SC_SWAPPING
                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: setting flag bCardVerified to TRUE - the card has been verified.\n");
                bCardVerified = 1; /* Card is known to be valid */
                ncma_dbox_close_target(COMMON_DIALOGUE_BOX); /* Closing the 'enter pin' or 'insert smartcard' dialogues */
                return(after_pin());
#else
		ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
		ncma_url_open(URL_PATH(connect.html));
		return(State_NCMAConnect);
#endif /* SC_SWAPPING */


#ifdef SC_SWAPPING
             /* The transition below copes with the explicit disconnect (i.e. logout)
                 button on the toolbar of Funai NC 2's being pressed. It exhibits the same
                 behaviour as occured with the smartcard being removed on other NC's. */
             case Trans_Logout:
               ncma_dbox_open_to_target(URL_PATH(logout.html), COMMON_DIALOGUE_BOX); /* Open the logout window */
               uiPreviousState = ncma_state;
               return (State_NCMALogout);
#endif /* SC_SWAPPING */

	 } /* end state_ncmainit */
	 break;

/*********************************************************************************

    STATE_NCMABADCARD

 *********************************************************************************/
    case State_NCMABadCard: /* waiting for URL/CLI call */

    	 switch(trans) {
#ifdef POINTLESS_BUTTONS
       	     case Trans_Registry:
       	     case Trans_CardRemoved:
       	     	  return(State_NCMANoCard);

       	     case Trans_URLBadCardAck:
       	     	  goto pointless_ncma_manual_restart;
#else
    	     case Trans_CardRemoved: /* user has removed bad card */

    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard removed\n");
    	     	  ncma_dbox_open_to_target(URL_PATH(splash.html), COMMON_DIALOGUE_BOX);
    	     	  return(State_NCMANoCard);
#endif
    	 } /* end state_ncmabadcard */

    	 break;

/*********************************************************************************

    +STATE_NCMANOCARD

 *********************************************************************************/
    case State_NCMANoCard: /* waiting for a smartcard to be inserted */

         switch(trans) {
	    case Trans_CardOK:
	         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card_ok event - clearing status delta register\n");
	         smartcard_status(NULL);
	    	 return(State_NCMANoCard);

	    case Trans_Timeout: /* user clicked 'Continue' with no card inserted */
	    	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Card check timer expired\n");
	    	 pointless_button_clicked = 0;
	    	 ncma_hourglass_off();
	    	 ncma_dbox_open_to_target(URL_PATH(splash.html), COMMON_DIALOGUE_BOX);
	    	 return(State_NCMANoCard);

            case Trans_Registry: /* card activity */

#ifdef POINTLESS_BUTTONS
       		 if((run_from_powerup | pointless_button_clicked)==0) {
		     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: r_f_p: %d p_b_c: %d -- ignoring\n",
		     				run_from_powerup, pointless_button_clicked);
       		     return(State_NCMANoCard);
       		 }
       		 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: cancel card scan timer\n");
       		 canceltimeout();
       		 /* else deliberate fall through to next case */

            case Trans_URLSmartcardAck:
            case Trans_URLStart: /* repeat click on "continue" from cancel setup screen */

                 if(!pointless_button_clicked) { /* continue not already pressed */
                     pointless_button_clicked = 1;
                     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Got click\n");
                     ncma_hourglass_on();
                     if(!smartcard_present()) {
                         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no card ; starting timer\n");
                         settimeout(CARD_SCAN_TIMEOUT);
                         return(State_NCMANoCard);
                     }
                 }

                 if(!smartcard_present()) {
                     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: pointless button clicked with no scard inserted - ignoring\n");
                     return(State_NCMANoCard);
                 }

                 if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard - bailing\n");
		    ncma_dbox_open_to_target(URL_PATH(invalid.html), COMMON_DIALOGUE_BOX);
                    ncma_hourglass_off();
                    pointless_button_clicked = 0;
		    return(State_NCMABadCard);
		}


		if(smartcard_pin_protected()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected\n");
                    ncma_hourglass_off();
                    //pointless_button_clicked = 0;
		    card_attempts = smartcard_blocked();
		    if(card_attempts>0) {
#ifdef CHIMPANZEE_INTERFACE
       		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not blocked (%d), trying default PIN\n", card_attempts);
       		      default_pin();
       		      //if(virgin_smartcard()) goto proceed_after_pin; /* see top for explanation of this */
       		      return(State_NCMADefaultPIN);
#else

		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
		      ncma_dbox_open_to_target(URL_PATH(pin.html), COMMON_DIALOGUE_BOX);
		      return(State_NCMAPin);
#endif
		    } else {
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard is blocked\n");
		        ncma_dbox_open_to_target(URL_PATH(unblock.html), COMMON_DIALOGUE_BOX);
		        return(State_NCMAUnblock);
		    }
		} else {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard is not PIN protected\n");
		}

#else
		/* NOT POINTLESS_BUTTONS */

		//if(!registry_status_changed(BB_STATUS_LOCKED)) {
		if(!smartcard_present()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading PIN status (no card)\n");
		    return(State_NCMANoCard);
		}

		//if(registry_status_asserted(BB_STATUS_BADVERSION)) {
		if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: invalid smartcard\n");
		    ncma_dbox_open_to_target(URL_PATH(invalid.html), COMMON_DIALOGUE_BOX);
		    return(State_NCMABadCard);
		}

	    	//if(registry_status_asserted(BB_STATUS_LOCKED)) { /* PIN protected */
	    	if(smartcard_pin_protected()) {

	    	    card_attempts = smartcard_blocked();
	    	    if(card_attempts>0) {
#ifdef CHIMPANZEE_INTERFACE
       		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not blocked (%d), trying defalt PIN\n", card_attempts);
       		      default_pin();
       		      //if(virgin_smartcard()) goto proceed_after_pin; /* see top for explanation of this */
       		      return(State_NCMADefaultPIN);
#else
 		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
		      ncma_dbox_open_to_target(URL_PATH(pin.html), COMMON_DIALOGUE_BOX);
		      return(State_NCMAPin);
#endif
		    } else {
		      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard is blocked\n");
		      ncma_dbox_open_to_target(URL_PATH(unblock.html), COMMON_DIALOGUE_BOX);
		      return(State_NCMAUnblock);
		    }
		}


                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
                if(bootblock_read_failed()) {
                     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bootblock read failed\n");
                     ncma_dbox_open_to_target(URL_PATH(invalid.html), COMMON_DIALOGUE_BOX); // was damaged.html
                     return(State_NCMABadCard);
                }
#endif
		/* ENDIF POINTLESS_BUTTONS */


		goto proceed_after_pin;

		break;

            case Trans_CardBad: /* bad card */

            	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bad card re-inserted\n");
            	 ncma_dbox_open_to_target(URL_PATH(damaged.html), COMMON_DIALOGUE_BOX);
#ifdef POINTLESS_BUTTONS
                 ncma_hourglass_off();
                 pointless_button_clicked = 0;
#endif
            	 return(State_NCMABadCard);
         } /* end state_ncmanocard */
         break;

#ifdef CHIMPANZEE_INTERFACE
/*********************************************************************************

    STATE_NCMADEFAULTPIN

 *********************************************************************************/
    case State_NCMADefaultPIN:

    	 switch(trans) {
	     case Trans_AuthFail: /* default PIN failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure for default PIN (auth)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	    ncma_dbox_open_to_target(URL_PATH(pin.html), COMMON_DIALOGUE_BOX);
	     	    return(State_NCMAPin);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open_to_target(URL_PATH(unblock.html), COMMON_DIALOGUE_BOX);
	     	    return(State_NCMAUnblock);
	     	  }
	     	  break;

    	     case Trans_Registry: /* test status of default PIN transaction */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: default PIN failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	        ncma_dbox_open_to_target(URL_PATH(pin.html), COMMON_DIALOGUE_BOX);
	     	        return(State_NCMAPin);
	     	      } else {
	     	        ncma_dbox_open_to_target(URL_PATH(unblock.html), COMMON_DIALOGUE_BOX);
	     	        return(State_NCMAUnblock);
	     	      }
	     	      break;


	     	  }
		  /* default PIN succeeded */
	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: default PIN succeeded\n");
                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

		      goto proceed_after_pin;
	     	      break;
	          }


    	 } /* end state_ncmadefaultpin */
    	 break;
#endif
/*********************************************************************************

    +STATE_NCMAPIN

 *********************************************************************************/
    case State_NCMAPin:

    	 switch(trans) {

#ifdef SC_SWAPPING
             /* This transition must cope with the case where the card is
                 removed whilst waiting for the pin to be verified when
                 browsing. */
             case Trans_CardRemoved:
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_CardRemoved recieved in State_NCMAPin\n");
                  ncma_hourglass_off(); /* Always switch off the hourglass */
                  if (interface_type == MODEM_INTERFACE)
                  {
                    if (bRedialRequested) /* Since it is a redial, it must be browsing */
                    {
                      /* Open the 'please insert smartcard' screen. */
                      ncma_dbox_open_to_target(URL_PATH(splash.html), COMMON_DIALOGUE_BOX);
                      return(State_NCMANoCard);
                    }
                  }
                  break;
#endif /* SC_SWAPPING */

             case Trans_CardOK:
	     	  return(State_NCMAPin);
	     	  break;

	     case Trans_URLPinNAK:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: user cancelled PIN entry\n");
	     	  ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif

		  return(State_NCMAInit);
	     	  //ncma_dbox_open_to_target(URL_PATH(splash.html), COMMON_DIALOGUE_BOX);
	     	  //return(State_NCMANoCard);
	     	  break;

	     case Trans_AuthFail: /* the user entered a pin, but it failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure (authfail)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	    ncma_dbox_open_to_target(URL_PATH(badpin.html), COMMON_DIALOGUE_BOX);
                    ncma_hourglass_off();
	     	    return(State_NCMABadPin);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open_to_target(URL_PATH(unblock.html), COMMON_DIALOGUE_BOX);
                    ncma_hourglass_off();
	     	    return(State_NCMAUnblock);
	     	  }
	     	  break;

    	     case Trans_Registry: /* the user entered a pin, maybe it worked, maybe it didn't */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	        ncma_dbox_open_to_target(URL_PATH(badpin.html), COMMON_DIALOGUE_BOX);
                        ncma_hourglass_off();
	     	        return(State_NCMABadPin);
	     	      } else {
	     	        ncma_dbox_open_to_target(URL_PATH(unblock.html), COMMON_DIALOGUE_BOX);
                        ncma_hourglass_off();
	     	        return(State_NCMAUnblock);
	     	      }
	     	      break;
	     	  }

	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");
                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;
#ifdef SC_SWAPPING
	              DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: setting flag bCardVerified to TRUE - the card has been verified. #2\n");
                      bCardVerified = 1; // Card is known to be valid
#endif /* SC_SWAPPING */

#ifdef CHIMPANZEE_INTERFACE
       		      ncma_trans = Trans_Registry; /* cue on up */
       		      setcallback();

#ifdef SC_SWAPPING
	              DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: setting flag bCardVerified to TRUE - the card has been verified. #3\n");
                      bCardVerified = 1; // Card is known to be valid
#endif /* SC_SWAPPING */

       		      return(State_NCMAApresPIN);
#else

		      goto proceed_after_pin;
	     	      break;
#endif
	          }


    	 } /* end state_ncmapin */
    	 break;

#ifdef CHIMPANZEE_INTERFACE
/*********************************************************************************

    STATE_NCMAAPRESPIN wait for registry completion on bootblock read after user PIN entry

 *********************************************************************************/
    case State_NCMAApresPIN:

         switch(trans) {

             case Trans_Registry:
                if(bootblock_read_succeeded()==0) { /* bootblock read ok, but not finished yet */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock (after pin)\n");
                  return(State_NCMAApresPIN);
                }

                ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
                ncma_hourglass_off(); /* Pin checking finished */
#ifdef SC_SWAPPING
                return(after_pin());
#else
                ncma_url_open(URL_PATH(connect.html));
#endif /* SC_SWAPPING */
                return(State_NCMAConnect);


 	 }
	 break;
#endif


/*********************************************************************************

    STATE_NCMABADPIN

 *********************************************************************************/
    case State_NCMABadPin:

         switch(trans) {

	     case Trans_CardOK:
	     	  return(State_NCMABadPin);
	     	  break;

             case Trans_URLRetry:
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: getting ready for another go\n");
             	  //ncma_url_open("file:/ncma:pin.html");
             	  ncma_dbox_open_to_target(URL_PATH(pin.html), COMMON_DIALOGUE_BOX);
             	  return(State_NCMAPin);
         } /* end state_ncmabadpin */
         break;

/*********************************************************************************

    +STATE_NCMACONNECT

 *********************************************************************************/
    case State_NCMAConnect:

         switch(trans) {
             case Trans_Logout:
               /* This transition should never be recieved. However,
                   repeatedly connecting and disconnecting can cause the
                   state machine to get confused and not display the connect
                   screen. Hence opening up the 'connect' screen on a logout
                   will prevent the state machine and screen from getting out
                   of synch. */
              ncma_url_open(URL_PATH(connect.html));
              return(State_NCMAConnect);

             case Trans_ShutdownComplete:
               /* This transition is needed since the standby module now
                   sends a logoff before the shutdown_complete, meaning that
                   NCMA goes into either the Init or Connect state (according
                   to whether smartcard is inserted or not) */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_ShutdownComplete received in State_NCMAConnect\n");
                  prevent_shutdown = 1;
                  if(ui_present()) prod_browser_after_standby();
                  return(State_NCMAInit);
                  break;

	     case Trans_URLChangePIN: /* the user clicked on 'change pin' */
	     	  ncma_dbox_open_to_target(URL_PATH(newpin.html), COMMON_DIALOGUE_BOX);
	     	  return(State_NCMANewPIN);

             case Trans_PreConnect: /* build tag cache without connecting, to allow ISPCapture to display current sc values */
                  return(PreConnect_in_NCMA_Connect());
#ifndef EMAIL_CLIENT
	     case Trans_URLConnect:
                  return (URLConnect_in_NCMA_Connect());
#else
             /* In email client builds, there is no such transition as
                 Trans_URLConnect. It has been replaced with
                 Trans_NCMAEnterEmailSelectUserOffline (to enter the email
                 client offline) and Trans_NCMAEnterEmailSelectUserOnline (to
                 enter the email client online). */
             case Trans_NCMAEnterEmailSelectUserOffline:
             {
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Calling the email client user selection (connect mode).\n");
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: uiemail_client_state = email_state_offline\n");
                  uiemail_client_state = email_state_offline;
                  ncma_url_open("ncmail:/?page=UserSel&button=Start&mode=email");
                  return (State_NCMAEmailSelectUser);
             }

             case Trans_NCMAEnterEmailSelectUserOnline:
             {
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Calling the email client user selection (email mode).\n");
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: uiemail_client_state = email_state_online\n");
                  uiemail_client_state = email_state_online;
                  ncma_url_open("ncmail:/?page=UserSel&button=Start&mode=connect");
                  return (State_NCMAEmailSelectUser);
             }
#endif /* EMAIL_CLIENT */

#ifdef SC_SWAPPING
             /* The transition below copes with the explicit disconnect (logout)
                 button on the toolbar of Funai NC 2's being pressed. It exhibits the same
                 behaviour as occured with the smartcard being removed on other NC's. */
             case Trans_Logout:
                  ncma_dbox_open_to_target(URL_PATH(logout.html), COMMON_DIALOGUE_BOX); // Open the logout window
                  uiPreviousState = ncma_state;
                  return (State_NCMALogout);
#endif /* SC_SWAPPING */

             case Trans_URLConnectNak:
                  ncma_url_open(WELCOME_SCREEN_URL);
                  run_from_powerup = 0;
                  return(State_NCMAInit);
                  break;
         } /* end state_ncmaconnect */
         break;


/*********************************************************************************

    STATE_NCMADIALLINGISP

 *********************************************************************************/
    case State_NCMADiallingISP:

         switch(trans) {

             case Trans_DialBad: /* Don't know what to do here! Not in the CIS!! */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ISP dial failed - bummer\n");
#ifdef EMAIL_CLIENT
                  if (uiemail_client_state == email_state_offline)
                  {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Dial failed when in offline email client. Do not open the coonect screen.\n");
                  }
                  else
                  {
#endif /* EMAIL_CLIENT */
                    ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
                    ncma_url_open(URL_PATH(connect.html));
                    return(State_NCMAConnect);
#ifdef EMAIL_CLIENT
                  }
#endif /* EMAIL_CLIENT */
                  break;

    	     case Trans_DialOK: /* dial succeeded */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ISP dial succeeded\n");

#ifdef DEBUG_DISCONNECT
       		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: DEBUG_DISCONNECT setting line drop timeout\n");
       		  set_ppp_timeout();
#endif

                  if (bRedialRequested)
                  {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: A redial has been requested, so resetting bRedialRequested to 0\n");
                    bRedialRequested = 0;
                  }
                  else
                  {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: No redial requested.\n");

#ifdef EMAIL_CLIENT
                    DBUG_PRINTF(DBUG_LVL_DIAG, "Email client status is %s\n", email_status_string(uiemail_client_state));
                    if (uiemail_client_state != email_state_offline)
                    { /* If dialling was called by the email client offline, we do not want the URL screen to be opened. */
#endif /* EMAIL_CLIENT */
                      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Calling ncma_url_user\n");
                      if (ncma_url_user() != 0)
      		      {
          	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Hanging up due to ncma_url_user() != 0, and returning State_NCMAConnect\n");
		          ncma_hangup();
			  ncma_dbox_open_to_target( URL_PATH(badurldbox.html), COMMON_DIALOGUE_BOX);
			  return(State_NCMAConnect);
		      }
#ifdef EMAIL_CLIENT
                    }
                    else
                    {
                      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Not calling ncma_url_user as we are in offline email mode.\n");
                    }
#endif /* EMAIL_CLIENT */

                  }

                  DBUG_PRINTF(DBUG_LVL_DIAG, "Resetting bNoScreenChanges to 0 and moving to State_NCMABooted.\n");
                  bNoScreenChanges = 0;

    	     	  return(State_NCMABooted);
 		  break;

#ifdef SC_SWAPPING
             case Trans_CardRemoved:  /* Ignoring this case. */
               DBUG_PRINTF(DBUG_LVL_DIAG, "Ignoring transition Trans_CardRemoved in State_NCMADIallingISP.\n");
               bCardVerified = 0;
               return(State_NCMADiallingISP);
#endif /* SC_SWAPPING */

 	 } /* end state_ncmadiallingisp */
 	 break;

/*********************************************************************************

    +STATE_NCMABOOTED

 *********************************************************************************/
    case State_NCMABooted:

    	 switch(trans) {
             /* The transition below is called when the browser wants to
                 restart a dial. If the card is currently verified, then it calls
                 NCDialUI_Start, otherwise it notes that a redial has been requested and
                 prompts for a card to be inserted. */
               case Trans_NCMADialUI_Start:
                 DBUG_PRINTF(DBUG_LVL_DIAG, "Trans_NCMADialUI_Start in State_NCMABooted: calling start_redial()\n");
                 return (start_redial());

               case Trans_DialOK:
                 // Ignoring this case as it is produced after a Trans_NCMADialUI_Start if the redial was successful.
                 DBUG_PRINTF(DBUG_LVL_DIAG, "Ignoring Trans_DialOK\n");
               return (State_NCMABooted);

    	     case Trans_NCMASurf:
 	         DBUG_PRINTF(DBUG_LVL_DIAG, "Trans_NCMASurf in State_NCMABooted : calling ncma_url_user() and returning State_NCMABooted\n");
		  ncma_url_user();	/* this can happen when the user presses home - just let it fail if it must */
    	     	  return(State_NCMABooted);

#ifdef TRAP_PPP_TIMEOUTS
	     case Trans_PPPTimeout:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PPP timeout event received\n");
	     	  ignore_ppp_timeout = 1; /* next time, don't claim svc call, just let it happen */
	     	  set_ppp_timeout(); /* set short timeout for drop, in case user has dozed off */+
	     	  ncma_sound_effect(NCMA_TIMEOUT_SOUND);
	     	  ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
	     	  ncma_dbox_open_to_target(URL_PATH(disconnect.html), COMMON_DIALOGUE_BOX);
	     	  return(State_NCMABooted);
#endif

	     case Trans_URLDisconnectAck: /* user wants to disconnect now */
	     	  ignore_ppp_timeout = 0; /* tell svc handler to block next timeout & notify us */
	     	  ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
	     	  ncma_hangup();
	     	  return(State_NCMABooted);

	     case Trans_URLDisconnectNak: /* user wants to carry on */
	     	  ignore_ppp_timeout = 0; /* tell svc handler to block next timeout & notify us */
	     	  set_ppp_timeout_long(); /* do the long timeout */
	     	  ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
	     	  return(State_NCMABooted);

	     case Trans_HUP: /* we've lost our connection */
#ifdef SILENT_HUP
#ifdef EMAIL_CLIENT
                  /* If we get a HUP when in the email client, return to State_NCMAEmailSelectUser. */
                  if (uiemail_client_state != email_state_none) /* In the email client */
                  {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "Hanging up from the email client. Going back to State_NCMAEmailSelectUser\n");
                    DBUG_PRINTF(DBUG_LVL_DIAG, "Email client status is %s\n", email_status_string(uiemail_client_state));
                    return(State_NCMAEmailSelectUser);
                  }
#endif /* EMAIL_CLIENT */
       		  /* no special action - rely on browser to bring the line back up
       		     note that this might be thru a ref. to NCFresco$Home, which is
       		     a macro which evaluates to ncma:userhome, which fires Trans_NCMASurf,
       		     which calls the browser (first trans above) which brings the line
       		     up. :) */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "HUP recieved. Doing nothing as email_client_state is unset.\n");
       		  return(State_NCMABooted);
#else
		  /* alternatively, bung the 'connect to isp' screen up and do all that pallaver */
       		  ncma_url_open(URL_PATH(connect.html));
	     	  return(State_NCMAConnect);
#endif /* SILENT_HUP */

	     case Trans_URLConnect:
	     	  ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
		  ncma_url_open(URL_PATH(badurl.html));
	     	  return(State_NCMABooted);

	     case Trans_URLConnectNak:
		  ncma_hangup();
	     	  ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
		  ncma_url_open(WELCOME_SCREEN_URL);
     		  run_from_powerup = 0;
             	  return(State_NCMAInit);

	     case Trans_HangUp:
		  ncma_hangup();
	     	  ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
		  ncma_url_open(URL_PATH(connect.html));
		  return(State_NCMAConnect);

             case Trans_PreConnect: /* called by ISPCapture to ensure smartcard details are read */
		  ncma_hangup();
             	  return(State_NCMAConnect);

#ifdef SC_SWAPPING
             case Trans_CardRemoved:
               /* Card has been removed. From now on the card will be flagged as being unverified. */
               bCardVerified = 0;
               return (State_NCMABooted);
#endif /* SC_SWAPPING */

             /* The transition below copes with the explicit disconnect
                 button on the toolbar being pressed. It exhibits the same
                 behaviour as occured with the smartcard being removed on other NC's.
                On modem boxes it opens the logout window to verify the user really wishes to
                 log out, whilst on ethernet boxes it just drops down to the 'connect to services'
                 screen.
             */
             case Trans_Logout:
#ifdef DISALLOW_USER_CONFIRMATION_OF_LOGOUTS
                 /* Set poll_word to 1 to start send of prelogoff message */
                 poll_word = 1;
                 return (State_NCMABooted);
#else
#ifdef SC_SWAPPING
               uiPreviousState = ncma_state;
#endif /* SC_SWAPPING */
               ncma_dbox_open_to_target(URL_PATH(logout.html), COMMON_DIALOGUE_BOX); // Open the logout window
               return (State_NCMALogout);
#endif /* DISALLOW_USER_CONFIRMATION_OF_LOGOUTS */
    	 } /* end state_ncmabooted */
    	 break;


 /*********************************************************************************

    +STATE_NCMASHUTDOWN

 *********************************************************************************/
    case State_NCMAShutdown:

         switch(trans) {

             case Trans_URLShutdown:
             	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_URLShutdown received\n");
             case Trans_Shutdown:
             	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Shutdown received\n");
                  prevent_shutdown = 0;
                  shutdown_nc();
                  ncma_dbox_close_target(STANDBY_DIALOGUE_BOX); /* close my dbox */
                  ncma_dbox_close_target(COMMON_DIALOGUE_BOX);  /* close any other dbox. Yuck. */
                  ncma_url_open(BLANK_SCREEN_URL);
#ifdef SC_SWAPPING
                  tidy_memory();
#endif // SC_SWAPPING
                  return(State_NCMAShutdown);
                  break;

             case Trans_URLShutdownCancel:
             	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_ShutdownCancel received\n");
                  ncma_dbox_close_target(STANDBY_DIALOGUE_BOX);
                  return(pre_shutdown_state);
                  break;

             case Trans_ShutdownComplete:
             	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Complete received\n");
                  prevent_shutdown = 1;
                  if(ui_present()) prod_browser_after_standby();
                  return(State_NCMAInit);
                  break;
         } /* end state_ncmashutdown */
         break;

/*********************************************************************************

    STATE_NCMAUNBLOCK

 *********************************************************************************/
    case State_NCMAUnblock:

         switch(trans) {

             case Trans_URLMismatch: /* user has entered unblock details */
             	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: unblock PIN mismatch\n");
             	  ncma_dbox_open_to_target(URL_PATH(mismatch.html), COMMON_DIALOGUE_BOX);
             	  return(State_NCMAUnblock);

             case Trans_URLMismatchAck:
             	  ncma_dbox_open_to_target(URL_PATH(unblock.html), COMMON_DIALOGUE_BOX);
             	  return(State_NCMAUnblock);

             case Trans_AuthFail:
             	  DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: PIN unblock failure\n");
             	  ncma_dbox_open_to_target(URL_PATH(badubp.html), COMMON_DIALOGUE_BOX);
             	  return(State_NCMABadUnblockPIN);

             case Trans_CardOK: /* ignore these, they get spewed for an invalid unblock PIN */
             	  // DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: PIN unblock failure\n");
             	  // ncma_dbox_open_to_target(URL_PATH(unblock.html), COMMON_DIALOGUE_BOX);
             	  return(State_NCMAUnblock);

    	     case Trans_Registry:
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failed failed\n");
	     	      ncma_dbox_open_to_target(URL_PATH(unblock.html), COMMON_DIALOGUE_BOX);
	     	      return(State_NCMAUnblock);
	     	  }

	     	  if(registry_status_asserted(BB_STATUS_BB_VALID) || registry_status_cleared(BB_STATUS_LOCKED) ||
	     	  		registry_status_cleared(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");

                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;
                      ncma_dbox_close_target(COMMON_DIALOGUE_BOX);

		      ncma_url_open(URL_PATH(connect.html));
        	      return(State_NCMAConnect);

	     	  }
    	 }
    	 break;


/*********************************************************************************

    STATE_NCMABADUNBLOCKPIN

 *********************************************************************************/
    case State_NCMABadUnblockPIN:

         switch(trans) {

             case Trans_URLBadUnblockPINAck:
                  ncma_dbox_open_to_target(URL_PATH(unblock.html), COMMON_DIALOGUE_BOX);
                  return(State_NCMAUnblock);
         }
         break;



/*********************************************************************************

    STATE_NCMANEWPIN

 *********************************************************************************/
    case State_NCMANewPIN:

    	 switch(trans) {

	     case Trans_AuthFail: /* failed setting PIN */ /* this shouldn't happen */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failure\n");
	     	  ncma_dbox_open_to_target(URL_PATH(newpin.html), COMMON_DIALOGUE_BOX);
	     	  return(State_NCMANewPIN);

	     	  break;

	     case Trans_URLMismatch: /* the two PINs the user entered didn't match */
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: fetching PIN mismatch page\n");
	     	  ncma_dbox_open_to_target(URL_PATH(mismatch.html), COMMON_DIALOGUE_BOX);
	     	  return(State_NCMAMismatch);
	     	  break;

	     case Trans_URLLeavePIN: /* a cancel on the change pin OSD */
	     	  if(ui_present()) {
	     	     ncma_url_gsopen(TOPLEVEL_UI_URL);
	     	     return(State_NCMABooted);
	     	  } else {
	     	    ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
	     	    ncma_url_open(URL_PATH(connect.html));
	     	    return(State_NCMAConnect);
	     	  }
	     	  break;

    	     case Trans_Registry: /* PIN set status from registry */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failed failed\n"); /* this shouldn't happen */
	     	      ncma_dbox_open_to_target(URL_PATH(newpin.html), COMMON_DIALOGUE_BOX);
	     	      return(State_NCMANewPIN);
	     	  }

	     	  if(registry_status_asserted(BB_STATUS_BB_VALID) || registry_status_cleared(BB_STATUS_LOCKED) ||
	     	  		registry_status_cleared(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");

                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;
		      ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
		      ncma_url_open(URL_PATH(connect.html));
        	      return(State_NCMAConnect);

	     	  }
    	 }
    	 break;


/*********************************************************************************

    STATE_NCMAMISMATCH

 *********************************************************************************/
    case State_NCMAMismatch:

         switch(trans) {

             case Trans_URLMismatchAck:
                  ncma_dbox_open_to_target(URL_PATH(newpin.html), COMMON_DIALOGUE_BOX);
                  return(State_NCMANewPIN);
                  break;
         }
         break;





#ifdef EMAIL_CLIENT
/*********************************************************************************

    State_NCMAEmailSelectUser

 *********************************************************************************/
    case State_NCMAEmailSelectUser:

         switch(trans)
         {

           case Trans_NCMASurf:
           {
             NCMA_STATE state;
             DBUG_PRINTF(DBUG_LVL_DIAG, "Trans_NCMASurf in State_NCMAEmailSelectUser: redialling and calling ncma_url_user() and returning State_NCMABooted\n");
             bRedialRequested = 0; /* It is not an 'official' redial */
             state = start_redial();
             ncma_url_user();  /* this can happen when the user presses home - just let it fail if it must */
             return(state);
           }

#ifdef SC_SWAPPING
             /* The transition below copes with the explicit disconnect (i.e. logout)
                 button on the toolbar of Funai NC 2's being pressed. It exhibits the same
                 behaviour as occured with the smartcard being removed on other NC's. */
             case Trans_Logout:
               ncma_dbox_open_to_target(URL_PATH(logout.html), COMMON_DIALOGUE_BOX); /* Open the logout window */
               uiPreviousState = ncma_state;
               return (State_NCMALogout);
#endif /* SC_SWAPPING */

           case Trans_NCMADialUI_Start:
             DBUG_PRINTF(DBUG_LVL_DIAG, "Trans_NCMADialUI_Start recieved in State_NCMAEmailSelectUser\n");
             return(start_redial());

           case Trans_CardRemoved:
             DBUG_PRINTF(DBUG_LVL_DIAG, "Trans_CardRemoved recieved in State_NCMAEmailSelectUser\n");
             /* Card has been removed. From now on the card will be flagged as being unverified. */
             bCardVerified = 0;
             return (State_NCMAEmailSelectUser);

           case Trans_DialOK:
             /* Going to state Booted as dial was successful */
             DBUG_PRINTF(DBUG_LVL_DIAG, "Trans_DialOK recieved: Going to State_Booted\n");
             return (State_NCMABooted);

           case Trans_PreConnect:
             /* The email client has requested the smartcard tag cache to be built. */
             DBUG_PRINTF(DBUG_LVL_DIAG, "Trans_PreConnect recieved in State_NCMAEmailSelectUser\n");
             if(fetch_sc_bootblock(FETCH_BOOTBLOCK_FOR_CLIENT)<0)
             {
               DBUG_PRINTF(DBUG_LVL_ERROR, "couldn't read sc bootblock\n");
             }
             if(build_ram_cache()<0)
             {
               DBUG_PRINTF(DBUG_LVL_ERROR, "preconnect, couldn't build RAM cache\n");
             }
             return (State_NCMAEmailSelectUser);
             break;


           case Trans_NCMAEmailSelectUserAck:
             DBUG_PRINTF(DBUG_LVL_DIAG, "Trans_NCMAEmailSelectUserAck recieved\n");

             switch (uiemail_client_state)
             {
               case email_state_offline:
               {
                 /* The code below fetches the URL out of NCMA's cache and
                     appends it into NCMail's starting string. It assumes that
                     the cache has already been built and that the URL exists;
                     these are valid assumptions as the email client has to
                     have built the cache before getting this far. */
                 char* url_buff_ptr = NULL;        /* This stores the URL string to be returned (NULL if none found) */
                 char* ncmail_entry_string = NULL; /* This stores the whole NCMail entry string */
                 int   url_size = 0;               /* The size of the URL string in the cache. */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_NCMAEmailSelectUserAck (email client state is offline)\n");
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Get the size of the home URL using my own cache_enquiry() routine.\n");

                 /* This line moved from State_DiallingISP so it is initialised *before* dialling. */
                 ncma_network_init(NCMA_NET_RAM | NCMA_NET_POST_DIAL); /* set resolver variables */

                 url_size = cache_enquiry("URL_INIT", NULL, 0);
                 if (url_size < 0)
                 {
                   DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Error in cache_enquiry() #1\n");
                 }
                 /* Allocate the memory for the buffer */
                 url_buff_ptr = malloc(url_size+1);
                 if (!url_buff_ptr)
                 {
                   DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Error : Could not Allocate memory for URL string.\n");
                 }
                 /* Get the url string */
                 url_size = cache_enquiry("URL_INIT", url_buff_ptr, url_size+1);
                 if (url_size < 0)
                 {
                   DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Error in cache_enquiry() #2\n");
                 }
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: URL in cache is : %s\n", url_buff_ptr);
                 /* Concatentate home URL onto the string below from cache (exiton). */
                 ncmail_entry_string = malloc(150+strlen(url_buff_ptr)); /* 150 is a guesstimate - beware! */
                 if (!ncmail_entry_string)
                 {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Error : Could not Allocate memory for NCMail entry string.\n");
                 }
                 strcpy (ncmail_entry_string, "ncmail:/?page=Enter&button=Enter&exiton=");
                 strcat (ncmail_entry_string, url_buff_ptr);
                 strcat (ncmail_entry_string, "&exitoff=ncma:emailselectusernak");
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Open URL with string of %s\n", ncmail_entry_string);
                 ncma_url_open(ncmail_entry_string);
/*
  The URL should end up looking something like this :
                 ncma_url_open("ncmail:/?page=Enter&button=Enter&exiton=http://www.acorn.com/&exitoff=ncint:current");
*/
                 free (url_buff_ptr);
                 free (ncmail_entry_string);
                 return (State_NCMAEmailSelectUser);
                 break;
               }

               case email_state_online:
               {
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_NCMAEmailSelectUserAck (email client state is online)\n");
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Dialling (by calling URLConnect_in_NCMA_Connect()).\n");
                 URLConnect_in_NCMA_Connect();
                 return (State_NCMADiallingISP);
                 break;
               }

               default:
               {
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Blarghh!!!! Unrecognised email client state!\n");
                 return (State_NCMAEmailSelectUser);
                 break;
               }
             }
             return (State_NCMAEmailSelectUser);
             break;


           case Trans_NCMAEmailSelectUserNak:
             DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_NCMAEmailSelectUserNak recieved\n");

             switch (uiemail_client_state)
             {
               case email_state_offline:
               {
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_NCMAEmailSelectUserAck (email client state is offline)\n");
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: uiemail_client_state = email_state_none\n");
                 uiemail_client_state = email_state_none;
                 return(select_screen_to_move_to());
               }

               case email_state_online:
               {
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_NCMAEmailSelectUserAck (email client state is online)\n");
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: uiemail_client_state = email_state_none\n");
                 uiemail_client_state = email_state_none;
                 return(select_screen_to_move_to());
               }

               default:
               {
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Blarghh!!!! Unrecognised email client state!\n");
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: uiemail_client_state = email_state_none\n");
                 uiemail_client_state = email_state_none;
                 return(select_screen_to_move_to());
               }

               return (State_NCMAEmailSelectUser);
             }
             break;
         }
         break;
#endif /* EMAIL_CLIENT */

/*********************************************************************************

    STATE_NCMALOGOUT

 *********************************************************************************/
    case State_NCMALogout:

    	 switch(trans) {

    	     case Trans_Logout:
        	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Recieved a Trans_Logout in State_NCMALogout; reopening logout window.\n");
        	 ncma_dbox_open_to_target(URL_PATH(logout.html), COMMON_DIALOGUE_BOX); /* Open the logout window */
                 return (State_NCMALogout);

              /* Deliberate case statement fall-through */
    	     case Trans_LogoutAck:
        	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Setting poll_word to 1 to start send of prelogoff message\n");
  	    	 ncma_dbox_close_target(COMMON_DIALOGUE_BOX); /* Close the pop-up window */
                 /* Set poll_word to 1 to start send of prelogoff message */
                 poll_word = 1;
                 /* Note that nothing else happens here. The logoff is
                     actually performed by the logoff() routine which is set
                     in motion once a logoff message has been recieved by the
                     task part of the module. */
                 return (State_NCMALogout);

    	     case Trans_LogoutNak: /* User has cancelled action */
        	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: explicit logout not acknowledged, returning to previous state\n");
    	          ncma_dbox_close_target(COMMON_DIALOGUE_BOX); /* Close the pop-up window */
#ifdef SC_SWAPPING
                  return(uiPreviousState); /* Return previous state */
#endif /* SC_SWAPPING */

              default:
        	 DBUG_PRINTF(DBUG_LVL_DIAG, "Error : Transition %s (num=%d) not recognised in State_NCMALogout\n", trans_string(trans), trans);
                break;

    	 }
    	 break;


#ifdef SC_SWAPPING
/*********************************************************************************

    STATE_NCMAWrongISPCard

 *********************************************************************************/
   case State_NCMAWrongISPCard:
    	switch(trans)
        {
	    case Trans_CardOK:
	         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card_ok event in State_NCMAWrongISPCard - clearing status delta register\n");
	         smartcard_status(NULL);
	    	 return(State_NCMANoCard);

            case Trans_CardRemoved:
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: CardRemoved event in State_NCMAWrongISPCard - Closing the correct.html screen and opening splash.html and going to State_NCMANoCard\n");
                 ncma_dbox_close_target(INCORRECT_DIALOGUE_BOX);
                 ncma_dbox_open_to_target(URL_PATH(splash.html), COMMON_DIALOGUE_BOX);
                 return(State_NCMANoCard);

	    case Trans_Timeout: /* user clicked 'Continue' with no card inserted */
	    	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Card check timer expired\n");
	    	 pointless_button_clicked = 0;
	    	 ncma_hourglass_off();
	    	 ncma_dbox_open_to_target(URL_PATH(splash.html), COMMON_DIALOGUE_BOX);
	    	 return(State_NCMANoCard);        }

        break;
#endif /* SC_SWAPPING */



/*********************************************************************************

    STATE_NCMAPANIC

 *********************************************************************************/
    case State_NCMAPanic:
    default:

	 DBUG_PRINTF(DBUG_LVL_PANIC, "NCMA_machine: PANIC!\n");
	 return(State_NCMAPanic);

  } /* end switch STATE */

  if(trans == Trans_Registry) {
#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: sweet nothings from the registry\n");
#endif
      return(ncma_state);
  }

  if((trans == Trans_CompleteOK) || (trans == Trans_CompleteBad) || (trans == Trans_AuthFail)) {
#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
    DBUG_PRINTF(DBUG_LVL_DEBUG, "NCMA: spurious I/O ACK from smartcard driver...ignoring\n");
#endif
    return(ncma_state);
  }

  /* otherwise . . . PANIC!! */

  DBUG_PRINTF(DBUG_LVL_PANIC, "NCMA: state machine panic - invalid transition event %s in state %s\n",
  		      trans_string(ncma_trans), state_string(ncma_state));

#ifdef ABORT_ON_PANIC
  DBUG_PRINTF(DBUG_LVL_PANIC, "            setting state to State_Panic\n");
  return(State_NCMAPanic);
#else
  return(ncma_state);
#endif
}





/*
  This routine deals with the redialling process. If the card is currently
   unverified, it prompts the user to reinsert the card that (s)he started
   the session with. The dial cannot start until this is done. */
#ifdef SC_SWAPPING
NCMA_STATE start_redial(void)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial()\n");

  DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial(): Card is unverified; setting bRedialRequested.\n");
  bRedialRequested = 1;
  if (!bCardVerified) /* Card is unverified */
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial(): Card is unverified; resetting smartcard cache and setting bNoScreenChanges\n");
    reset_cache();
    bNoScreenChanges = 1;
    /* Check the current status of the card (eg. invalid, inserted, bad) and go to the appropriate screen. */
    if(!smartcard_present())
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial(): no smartcard - fetching splash screen\n");
      ncma_dbox_open_to_target(URL_PATH(splash.html), COMMON_DIALOGUE_BOX);
      return(State_NCMANoCard);
    }

    if(!smartcard_valid())
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial(): invalid smartcard - bailing\n");
      ncma_dbox_open_to_target(URL_PATH(invalid.html), COMMON_DIALOGUE_BOX);
      return(State_NCMABadCard);
    }

    if(smartcard_pin_protected())
    {
      card_attempts = smartcard_blocked();
      if(card_attempts>0)
      {
#ifdef CHIMPANZEE_INTERFACE
        DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial(): smartcard not blocked (%d), trying default PIN\n", card_attempts);
        default_pin();
        /* a virgin card doesn't generate any status calls on authentication, because NCBootblock has
           already given up reading at this point, since it cannot construct a file sequence from the
           empty index file. Virgin smartcards will always ship with PIN (0000), so we call default_pin
           to set it for future operations, and then skip the bit of this state machine which expects a reply */
        return(State_NCMADefaultPIN);
#else

        DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial(): smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
        ncma_dbox_open_to_target(URL_PATH(pin.html), COMMON_DIALOGUE_BOX);
        return(State_NCMAPin);
#endif
      }
      else
      {
        DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial(): smartcard is blocked\n");
        ncma_dbox_open_to_target(URL_PATH(unblock.html), COMMON_DIALOGUE_BOX);
        return(State_NCMAUnblock);
      }
    }
    return (State_NCMANoCard);
  }
  else
  {
    /* Card is verified, send a NCDialUI_Start */
    DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial(): DiallerUI_Start has been called.\n");
    DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial(): Card is verified; sending a NCDialUI_Start and returning State_NCMADiallingISP\n");
    ncma_hourglass_on();
    if(ncma_dial()<0)
    {
      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: IAP dial initiation failed\n");
      ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
      ncma_url_open(URL_PATH(connect.html));
      return(State_NCMAConnect);
    }
    ncma_hourglass_off();

#ifdef EMAIL_CLIENT
    DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial(): Email client status is %s\n", email_status_string(uiemail_client_state));
#endif /* EMAIL_CLIENT */
  }
  return (State_NCMADiallingISP);
}
#else
NCMA_STATE start_redial(void)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial()\n");
  DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial(): sending a NCDialUI_Start and returning State_NCMADiallingISP\n");
  ncma_hourglass_on();

  DBUG_PRINTF(DBUG_LVL_DIAG, "start_redial(): setting bRedialRequested and bNoScreenChanges.\n");
  bRedialRequested = 1;
  bNoScreenChanges = 1;
  if(ncma_dial()<0)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: IAP dial initiation failed\n");
    ncma_dbox_close_target(COMMON_DIALOGUE_BOX);
    ncma_url_open(URL_PATH(connect.html));
    return(State_NCMAConnect);
  }
  ncma_hourglass_off();
  return (State_NCMADiallingISP);
}
#endif /* SC_SWAPING */



#ifdef SC_SWAPPING
/* This routine does some stuff which needs to be done in several cases (in
    apres_pin and after a default pin entry) to do with smartcard swapping
   things. Moved into a routine to prevent having two copies of idetical
   code. */

static NCMA_STATE after_pin(void)
{
  if (!bNoScreenChanges) /* Screens can change */
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "after_pin(): Opening connect screen and going to State_Connect.\n");
    ncma_url_open(URL_PATH(connect.html));
    return(State_NCMAConnect);
  }
  else /* Screens cannot change, obviously already booted. */
  {
    if (bCardVerified)
    {
      NCMA_STATE new_state;
      DBUG_PRINTF(DBUG_LVL_DIAG, "after_pin(): Screens cannot change, but card is now verified\n");
      if (bRedialRequested)
      {
        new_state = URLConnect_in_NCMA_Connect(); // Rebuild all caches.
      }
      if (new_state == State_NCMAWrongISPCard)
      {
        DBUG_PRINTF(DBUG_LVL_DIAG, "after_pin(): Setting state to %s\n", state_string(new_state));
        return (new_state);
      }
      else
      {
        DBUG_PRINTF(DBUG_LVL_DIAG, "after_pin(): Setting state to State_NCMADiallingISP\n");
        return(State_NCMADiallingISP);
      }
    }
    else
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "after_pin(): Screens cannot change, and card is unverified\n");
    }
  }

  DBUG_PRINTF(DBUG_LVL_ERROR, "after_pin(): Going to State_Connect.\n");

  /* This default return should never be used. */
  return(State_NCMAConnect);
}
#endif /* SC_SWAPPING */

