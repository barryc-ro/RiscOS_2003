#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"

#define PROTOTYPES_INTERNAL
#include "ncma_cmds.h"
#include "ncma_ncma.h"
#include "ncma_utils.h"
#include "ncma_url.h"
#include "ncma_scard.h"
#include "ncma_cache.h"
#include "ncma_mime.h"
#include "machine.h"
#include "ncma_cron.h"
#include "vectors.h"
#include "kprintf.h"
#include "dynalloc.h"
#include "DBUG.h"

int cmd_ncma_nullcmd(char *s, int n)
{
  return(0);
}

int cmd_ncma_status(char *s, int n)
{
    kprintf("cmd_ncma_status: last state: %s   last trans: %s\n",
    			       	state_string(ncma_state), trans_string(ncma_trans));

    kprintf("cmd_ncma_status: registry state: 0x%x registry delta: 0x%x\n",
    			       	registry_status, registry_delta);

    kprintf("cmd_ncma_status: NCMA started: %s\n", ncma_started?"Yes":"No");

    kprintf("cmd_ncma_status: prevent shutdown: %s\n", prevent_shutdown?"Yes":"No");

    return(0);
}

int cmd_ncma_urc(char *q, int n)
{
    int bytes;
    _kernel_swi_regs r;
    char s[256];

    memset(s, 0, 256);
    memcpy(s, q, 255);
    bytes = strterm(s);

    DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ncma_urc: got %d args as %d bytes in \"%s\"\n", n, bytes, s);

    if(strstr(s, "start")) { /* it's a start URL */
      ncma_trans = Trans_URLStart;
      setcallback();
      return(0);
    }

    if(strstr(s, "pinack")) { /* It's a PIN request */
      validate_pin(s); /* state transition will be driven by AUTH status calls from the registry / sc layer */
      return(0);
    }

    if(strstr(s, "pinnak")) { /* It's a PIN cancel */
      ncma_trans = Trans_URLPinNAK;
      setcallback();
      return(0);
    }

    if(strstr(s, "alterpin")) { /* user wants to change their PIN */
      ncma_trans = Trans_URLChangePIN;
      setcallback();
      return(0);
    }

    if(strstr(s, "unblock")) { /* It's the system unblock PIN */
      do_unblock_pin(s); /* state transition will be driven by unblocking events from SCTransport */
      return(0);
    }

    if(strstr(s, "changeack")) { /* It's a PIN change request */
#ifndef SOMETHING_VERY_BADLY_BROKEN
      change_pin(s); /* state transition will by driven by AUTH status calls from the registry / sc layer */
#else
      strcpy(s, "hello");
#endif
      return(0);
    }

    if(strstr(s, "changenak")) { /* User doesn't want to change PIN */
      ncma_trans = Trans_URLLeavePIN;
      setcallback();
      return(0);
    }


    if(strstr(s, "retry")) { /* It's a CONFIRM off the bad PIN screen */
      ncma_trans = Trans_URLRetry;
      setcallback();
      return(0);
    }

    if(strstr(s, "mismatch")) { /* It's a confirm off the mismatched PINs screen */
      ncma_trans = Trans_URLMismatchAck;
      setcallback();
      return(0);
    }

    if(strstr(s, "downloadack")) { /* It's a radio button off the download screen */

      ncma_trans = Trans_URLDownloadMin; /* default to a minimum download */

#ifdef POINTLESS
      if(strstr(s, "MIN")) {
          ncma_trans = Trans_URLDownloadMin;
      }

      else if(strstr(s, "MAX")) {
#else
      if(strstr(s, "MAX")) {
#endif
          ncma_trans = Trans_URLDownloadMax;
      }

      else if(strstr(s, "SCHED")) {
          ncma_trans = Trans_URLDownloadSched;
      }

      setcallback();
      return(0);
    }

    if(strstr(s, "downloadnak")) { /* it's a disconnect off the download screen */
      ncma_trans = Trans_URLDownloadNak;
      setcallback();
      return(0);
    }

    if(strstr(s, "connectack")) { /* It's an OK off the connect screen */
      ncma_trans = Trans_URLConnect;
      setcallback();
      return(0);
    }

    if(strstr(s, "connectnak")) { /* It's a cancel off the connect screen */
      ncma_trans = Trans_URLConnectNak;
      setcallback();
      return(0);
    }

    if(strstr(s, "movedack")) { /* the box has moved */
      ncma_trans = Trans_URLMovedAck;
      setcallback();
      return(0);
    }

    if(strstr(s, "movednak")) { /* the box hasn't moved */
      ncma_trans = Trans_URLMovedNak;
      setcallback();
      return(0);
    }

    if(strstr(s, "disconnectack")) { /* It's an OK off the connect screen */
      ncma_trans = Trans_URLDisconnectAck;
      setcallback();
      return(0);
    }

    if(strstr(s, "disconnectnak")) { /* It's a cancel off the connect screen */
      ncma_trans = Trans_URLDisconnectNak;
      setcallback();
      return(0);
    }

    if(strstr(s, "standby")) { /* initiate a STANDBY sequence */
        prevent_shutdown = 1;
        ncma_trans = Trans_Shutdown;
        setcallback();
        return(0);
    }

    if(strstr(s, "booted")) { /* boot file completion notifications */
       if(strstr(s, "full")) {
          ncma_trans = Trans_BootedFull;
          setcallback();
          return(0);
       } else if(strstr(s, "fast")) {
           ncma_trans = Trans_BootedFast;
           setcallback();
           return(0);
       } else if(strstr(s, "update")) {
           ncma_trans = Trans_BootedUpdate;
           setcallback();
           return(0);
       }
    }

    if(strstr(s, "transfer")) { /* browser is telling us to start boot transfer */
        ncma_trans = Trans_URLTransfer;
        setcallback();
        return(0);
    }


#ifdef ENABLE_DEBUGGING
    if(strstr(s, "test")) { /* funky test URLs */

      if(strstr(s, "sleep")) { /* initiate a STANDBY sequence */
          ncma_url_open(BLANK_SCREEN_URL);
          shutdown_nc();
          return(0);
      }

      if(strstr(s, "powerup")) { /* initiate power up sequence */
        ncma_trans = Trans_PowerUp;
        setcallback();
        return(0);
      }

      if(strstr(s, "reset")) { /* initiate power up sequence */
        ncma_state = State_NCMAInit;
        ncma_trans = Trans_Idle;
        return(0);
      }

      if(strstr(s, "dialbad")) { /* initiate a dial-failed sequence */
        ncma_trans = Trans_DialBad;
        setcallback();
        return(0);
      }

      if(strstr(s, "dialok")) { /* initiate a dial succeeded sequence */
        ncma_trans = Trans_DialOK;
        setcallback();
        return(0);
      }


      if(strstr(s, "mimebad")) { /* initiate a dial-failed sequence */
        ncma_trans = Trans_MIMEBad;
        setcallback();
        return(0);
      }

      if(strstr(s, "mimeok")) { /* initiate a dial succeeded sequence */
        ncma_trans = Trans_MIMEOk;
        setcallback();
        return(0);
      }

      if(strstr(s, "hup")) { /* fake a line drop acknowledgement */
        ncma_trans = Trans_HUP;
        setcallback();
        return(0);
      }

      if(strstr(s, "log")) { /* close debug log */
        DBUG_FCLOSE();
        return(0);
      }

      if(strstr(s, "drop")) { /* fake Service_PPPTimingOut */
        r.r[1] = 0xc0;
        _kernel_swi(OS_ServiceCall, &r, &r);
        return(0);
      }

    }
#endif

    if(strstr(s, "shutdownack")) { /* URL notification from shutdown page */
       ncma_trans = Trans_URLShutdown;
       setcallback();
       return(0);
    }

    if(strstr(s, "shutdownnak")) { /* URL notification from shutdown page */
       ncma_trans = Trans_URLShutdownCancel;
       setcallback();
       return(0);
    }

    if(strstr(s, "surf") || strstr(s, "userhome")) { /* Let's surf! */
       ncma_trans = Trans_NCMASurf;
       setcallback();
       return(0);
    }

    if(strstr(s, "badubpack")) { /* ack. from the bad unblock pin screen */
       ncma_trans = Trans_URLBadUnblockPINAck;
       setcallback();
       return(0);
    }



#ifdef POINTLESS_BUTTONS
    if(strstr(s, "smartcardack")) { /* URL notification from shutdown page */
       ncma_trans = Trans_URLSmartcardAck;
       setcallback();
       return(0);
    }

    if(strstr(s, "badcardack")) { /* URL notification from shutdown page */
       ncma_trans = Trans_URLBadCardAck;
       setcallback();
       return(0);
    }
#endif


    return(0);
}

int cmd_ncma_cache(char *s, int n)
{
    cache_info();
    return(0);
}

int cmd_ncma_scload(char *s, int n)
{
    if(handle_mime_object(s)<0) {
        ncma_trans = Trans_MIMEBad;
    } else {
        ncma_trans = Trans_MIMEOk;
    }
    setcallback();
    return(0);
}

int cmd_ncma_update(char *s, int n) /* triggered by cron */
{
    cron_value = atoi(s);
    ncma_trans = Trans_Cron;
    setcallback();
    return(0);
}

int cmd_ncma_memory(char *s, int n)
{
    rmstat();
    return(0);
}
