#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

#define PROTOTYPES_INTERNAL /* make prototypes and globals internal to this file */
#include "machine.h"
#include "module.h"
#include "ncma_ncma.h"
#include "ncma_scard.h"
#include "ncma_url.h"
#include "ncma_utils.h"
#include "ncma_dial.h"
#include "ncma_cron.h"
#include "ncma_exec.h"
#include "ncma_smurf.h"
#include "ncma_atr.h"
#include "ncma_cache.h"
#include "ncma_bootb.h"
#include "ncma_mime.h"
#include "ncma_nvram.h"
#include "ncma_auth.h"
#include "ncma_net.h"
#include "ncma_fx.h"
#include "vectors.h"

#include "DBUG.h"



char *trans_string(NCMA_TRANS trans)
{
  static char *t_table[] = {
    "Trans_Idle",
    "Trans_Timeout",
    "Trans_CardOK",
    "Trans_CardBad",
    "Trans_CardRemoved",
    "Trans_CompleteOK",
    "Trans_CompleteBad",
    "Trans_AuthFail",
    "Trans_URLStart",
    "Trans_URLRetry",
    "Trans_Registry",
    "Trans_Shutdown",
    "Trans_ShutdownComplete",
    "Trans_URLShutdown",
    "Trans_URLShutdownCancel",
    "Trans_URLUnblock",
    "Trans_URLChangePIN",
    "Trans_URLLeavePIN",
    "Trans_PowerUp",
    "Trans_DialOK",
    "Trans_DialBad",
    "Trans_URLMismatch",
    "Trans_URLMismatchAck",
    "Trans_NCMASurf",
    "Trans_URLDownloadMin",
    "Trans_URLDownloadMax",
    "Trans_URLDownloadSched",
    "Trans_URLDownloadNak",
    "Trans_URLConnect",
    "Trans_URLConnectNak",
    "Trans_MIMEOk",
    "Trans_MIMEBad",
    "Trans_URLMovedAck",
    "Trans_URLMovedNak",
    "Trans_PPPTimeout",
    "Trans_DisconnectNak",
#ifdef POINTLESS_BUTTONS
    "Trans_URLSmartcardAck",
    "Trans_URLBadCardAck",
#endif
     "Trans_URLDisconnectAck",
     "Trans_URLBadUnblockPINAck",
     "Trans_HUP",
     "Trans_BootedFull",
     "Trans_BootedFast",
     "Trans_BootedUpdate",
     "Trans_URLTransfer",
     "Trans_Cron"
  };


  return(t_table[trans]);
}

char *state_string(NCMA_STATE state)
{
    static char *s_table[] = {
    "State_NCMAInit",
    "State_NCMAStart",
    "State_NCMAPanic",
    "State_NCMASleep",
    "State_NCMANoCard",
    "State_NCMABadCard",
    "State_NCMAPin",
#ifdef CHIMPANZEE_INTERFACE
    "State_NCMADefaultPIN",
    "State_NCMAApresPIN",
#endif
    "State_NCMADiallingISP",
    "State_NCMABadPin",
    "State_NCMAShutdown",
    "State_NCMAUnblock",
    "State_NCMAChangePIN",
    "State_NCMANewPIN",
    "State_NCMAMismatch",
    "State_NCMABooted",
    "State_NCMADownload",
    "State_NCMAConnect",
    "State_NCMADiallingRelServer",
    "State_NCMAMoved",
    "State_NCMADiallingRegServer",
    "State_NCMABadUnblockPIN",
    "State_Cron"
  };

  return(s_table[state]);
}

/* this is the NCMA ASM */
NCMA_STATE machine(NCMA_TRANS trans)
{

#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got transition %s in state %s\n", trans_string(trans), state_string(ncma_state));
#else
  if(trans != Trans_CompleteOK)
    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got transition %s in state %s\n", trans_string(trans), state_string(ncma_state));
#endif

/*********************************************************************************

    GLOBAL TRANSITIONS

 *********************************************************************************/

  switch(trans) { /* global transitions that apply to all states (except maybe State_Sleep) */

    case Trans_Shutdown:
         if(ncma_state != State_NCMAShutdown) { /* if we're not already in shutdown state, save context */
    	   pre_shutdown_state = ncma_state;
    	   DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: shutdown imminent - pushed state \"%s\"\n", state_string(ncma_state));
    	   ncma_dbox_open(URL_PATH(poweroff.html));
    	   return(State_NCMAShutdown);
    	 }

    case Trans_Registry: /* HACK - damn s/c layer doesn't always report Card_Removed */
#if 0
         if(registry_status_cleared(BB_STATUS_INSERTED)) goto card_removed;
#else
	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ignoring Trans_Registry in state Init\n");
         break;
#endif

    case Trans_CardRemoved:
         card_removed:
    	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard removed, hanging up, flushing cache\n");
#ifdef POINTLESS_BUTTONS
    	 run_from_powerup = 0;
    	 pointless_button_clicked = 0;
    	 ncma_hourglass_off(); /* might be on, if we're in chimp mode */
#endif
	 ncma_hangup();
    	 reset_cache(); /* was unlock_cache() */

#ifdef POINTLESS_BUTTONS
         if(ncma_state == State_NCMABadCard) return(State_NCMABadCard); /* oh, how hatefully poor */
#endif
#if 0
    	 if(ncma_started) {
    	     ncma_dbox_open(URL_PATH(splash.html));
    	     return(State_NCMANoCard);
    	 } else return(State_NCMAInit);
    	 break;
#endif
	if(ncma_started) {
            if(ui_present()) {
                ncma_url_gsopen(TOPLEVEL_UI_URL);
                return(State_NCMAInit);
            } else {
                ncma_dbox_open(URL_PATH(splash.html));
                return(State_NCMANoCard);
            }
        } else return(State_NCMAInit); /* sc layer kicks off with a card removed event */
        break;

    default:
         break;
  }

  switch(ncma_state) {

/*********************************************************************************

    STATE_NCMAINIT

 *********************************************************************************/
    case State_NCMAInit:  /* start-up, pre WIMP stage */

         switch(trans) {

           case Trans_HUP: /* HUP ack, we're displaying an error screen and waiting for retry */
                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got HUP, ignoring\n");
                return(State_NCMAInit);

           case Trans_CardOK: /* ignore it */
           	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ignoring card OK event\n");
           	return(State_NCMAInit);

	   case Trans_PowerUp:  /* and so, I awake... */

                init_certificate_path();

	        if(ui_present()) { /* we're coming out of standby, and we've got a UI downloaded */
	           return(State_NCMAInit); /* top level menu is already on screen, so do nothing */
	        }  			   /* next transition will be URLStart */

	   	if(!smartcard_present()) { /* powered up but no card? Fetch the blurb */

#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif
		  run_from_powerup = 0;
	   	  return(State_NCMAInit);
	   	}

	   	/* otherwise, there's a card in, so fall through */
		run_from_powerup = 1;
	   	/* \/ \/ \/ \/ \/ DELIBERATE FALL THRU \/ \/ \/ \/ \/ */


           case Trans_URLStart: /* got a URL/CLI type call */

#ifdef POINTLESS_BUTTONS
       		pointless_ncma_manual_restart:
#endif

                ncma_started = 1;

	        /* read our status vars so smartcard checking works
	           (because we've no doubt missed a bunch of registry service calls */

	           registry_status = smartcard_status(NULL);
	           registry_delta = registry_status; /* assume everything set */

	   	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Managed access starting\n");
		if(!smartcard_present()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no smartcard - fetching splash screen\n");
		    ncma_dbox_open(URL_PATH(splash.html));
		    return(State_NCMANoCard);
		}

		if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard - bailing\n");
		    ncma_dbox_open(URL_PATH(invalid.html));
		    return(State_NCMABadCard);
		}


		if(smartcard_pin_protected()) {
		    card_attempts = smartcard_blocked();
		    if(card_attempts>0) {
#ifdef CHIMPANZEE_INTERFACE
       		      default_pin();
       		      //if(virgin_smartcard()) goto proceed_after_pin;
       		      /* a virgin card doesn't generate any status calls on authentication, because NCBootblock has
       		         already given up reading at this point, since it cannot construct a file sequence from the
       		         empty index file. Virgin smartcards will always ship with PIN (0000), so we call default_pin
       		         to set it for future operations, and then skip the bit of this state machine which expects a reply */
       		      return(State_NCMADefaultPIN);
#else

		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
		      ncma_dbox_open(URL_PATH(pin.html));
		      return(State_NCMAPin);
		    } else {
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard is blocked\n");
		        ncma_dbox_open(URL_PATH(unblock.html));
		        return(State_NCMAUnblock);
#endif
		    }
		}

		proceed_after_pin:

                if(bootblock_read_succeeded()==0) { /* bootblock read ok, but not finished yet */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock\n");
                  return(State_NCMANoCard);
                }

#ifdef POINTLESS_BUTTONS
       		/* clear the hourglass and click condition from 'insert s/c' OSD */
		DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard ready - hourglass off\n");
                ncma_hourglass_off();
                pointless_button_clicked = 0;

#endif
		if(ram_empty() && !nvram_empty()) {
		    ncma_dbox_open(URL_PATH(moved.html));
		    return(State_NCMAMoved);
		} else {
		    ncma_dbox_open(URL_PATH(connect.html));
		    return(State_NCMAConnect);
		}


	 } /* end state_ncmainit */
	 break;

/*********************************************************************************

    STATE_NCMABADCARD

 *********************************************************************************/
    case State_NCMABadCard: /* waiting for URL/CLI call */

    	 switch(trans) {
#ifdef POINTLESS_BUTTONS
       	     case Trans_Registry:
       	     case Trans_CardRemoved:
       	     	  return(State_NCMANoCard);

       	     case Trans_URLBadCardAck:
       	     	  goto pointless_ncma_manual_restart;
#else
    	     case Trans_CardRemoved: /* user has removed bad card */

    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard removed\n");
    	     	  ncma_dbox_open(URL_PATH(splash.html));
    	     	  return(State_NCMANoCard);
#endif
    	 } /* end state_ncmabadcard */

    	 break;

/*********************************************************************************

    +STATE_NCMANOCARD

 *********************************************************************************/
    case State_NCMANoCard: /* waiting for a smartcard to be inserted */

         switch(trans) {
	    case Trans_CardOK:
	         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card_ok event - clearing status delta register\n");
	         smartcard_status(NULL);
	    	 return(State_NCMANoCard);

	    case Trans_Timeout: /* user clicked 'Continue' with no card inserted */
	    	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Card check timer expired\n");
	    	 pointless_button_clicked = 0;
	    	 ncma_hourglass_off();
	    	 return(State_NCMANoCard);

            case Trans_Registry: /* card activity */

#ifdef POINTLESS_BUTTONS
       		 if((run_from_powerup | pointless_button_clicked)==0) return(State_NCMANoCard);
       		 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: cancel card scan timer\n");
       		 canceltimeout();
       		 /* else deliberate fall through to next case */

            case Trans_URLSmartcardAck:
            case Trans_URLStart: /* repeat click on "continue" from cancel setup screen */

                 if(!pointless_button_clicked) { /* continue not already pressed */
                     pointless_button_clicked = 1;
                     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Got click\n");
                     ncma_hourglass_on();
                     if(!smartcard_present()) {
                         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no card ; starting timer\n");
                         settimeout(CARD_SCAN_TIMEOUT);
                         return(State_NCMANoCard);
                     }
                 }

                 if(!smartcard_present()) {
                     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: pointless button clicked with no scard inserted - ignoring\n");
                     return(State_NCMANoCard);
                 }

                 if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard - bailing\n");
		    ncma_dbox_open(URL_PATH(invalid.html));
                    ncma_hourglass_off();
                    pointless_button_clicked = 0;
		    return(State_NCMABadCard);
		}


		if(smartcard_pin_protected()) {
                    ncma_hourglass_off();
                    pointless_button_clicked = 0;
		    card_attempts = smartcard_blocked();
		    if(card_attempts>0) {
#ifdef CHIMPANZEE_INTERFACE
       		      default_pin();
       		      //if(virgin_smartcard()) goto proceed_after_pin; /* see top for explanation of this */
       		      return(State_NCMADefaultPIN);
#else

		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
		      ncma_dbox_open(URL_PATH(pin.html));
		      return(State_NCMAPin);
		    } else {
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard is blocked\n");
		        ncma_dbox_open(URL_PATH(unblock.html));
		        return(State_NCMAUnblock);
#endif
		    }
		}

#else
		/* NOT POINTLESS_BUTTONS */

		if(!registry_status_changed(BB_STATUS_LOCKED)) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading PIN status\n");
		    return(State_NCMANoCard);
		}

		if(registry_status_asserted(BB_STATUS_BADVERSION)) {
		    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: bad smartcard version\n");
		    ncma_dbox_open(URL_PATH(invalid.html));
		    return(State_NCMABadCard);
		}

	    	if(registry_status_asserted(BB_STATUS_LOCKED)) { /* PIN protected */

	    	    card_attempts = smartcard_blocked();
	    	    if(card_attempts>0) {
#ifdef CHIMPANZEE_INTERFACE
       		      default_pin();
       		      //if(virgin_smartcard()) goto proceed_after_pin; /* see top for explanation of this */
       		      return(State_NCMADefaultPIN);
#else
 		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
		      ncma_dbox_open(URL_PATH(pin.html));
		      return(State_NCMAPin);
		    } else {
		      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard is blocked\n");
		      ncma_dbox_open(URL_PATH(unblock.html));
		      return(State_NCMAUnblock);
#endif
		    }
		}


                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
                if(bootblock_read_failed()) {
                     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bootblock read failed\n");
                     ncma_dbox_open(URL_PATH(damaged.html));
                     return(State_NCMABadCard);
                }
#endif
		/* ENDIF POINTLESS_BUTTONS */


		goto proceed_after_pin;

		break;

            case Trans_CardBad: /* bad card */

            	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bad card re-inserted\n");
            	 ncma_dbox_open(URL_PATH(damaged.html));
#ifdef POINTLESS_BUTTONS
                 ncma_hourglass_off();
                 pointless_button_clicked = 0;
#endif
            	 return(State_NCMABadCard);
         } /* end state_ncmanocard */
         break;

#ifdef CHIMPANZEE_INTERFACE
/*********************************************************************************

    STATE_NCMADEFAULTPIN

 *********************************************************************************/
    case State_NCMADefaultPIN:

    	 switch(trans) {
	     case Trans_AuthFail: /* default PIN failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure for default PIN (auth)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	    ncma_dbox_open(URL_PATH(pin.html));
	     	    return(State_NCMAPin);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open(URL_PATH(unblock.html));
	     	    return(State_NCMAUnblock);
	     	  }
	     	  break;

    	     case Trans_Registry: /* test status of default PIN transaction */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: default PIN failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	        ncma_dbox_open(URL_PATH(pin.html));
	     	        return(State_NCMAPin);
	     	      } else {
	     	        ncma_dbox_open(URL_PATH(unblock.html));
	     	        return(State_NCMAUnblock);
	     	      }
	     	      break;


	     	  }
		  /* default PIN succeeded */
	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: default PIN succeeded\n");
                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

		      goto proceed_after_pin;
	     	      break;
	          }


    	 } /* end state_ncmadefaultpin */
    	 break;
#endif
/*********************************************************************************

    STATE_NCMAPIN

 *********************************************************************************/
    case State_NCMAPin:

    	 switch(trans) {

	     case Trans_AuthFail: /* the user entered a pin, but it failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure (authfail)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	    ncma_dbox_open(URL_PATH(badpin.html));
	     	    return(State_NCMABadPin);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open(URL_PATH(unblock.html));
	     	    return(State_NCMAUnblock);
	     	  }
	     	  break;

    	     case Trans_Registry: /* the user entered a pin, maybe it worked, maybe it didn't */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	        ncma_dbox_open(URL_PATH(badpin.html));
	     	        return(State_NCMABadPin);
	     	      } else {
	     	        ncma_dbox_open(URL_PATH(unblock.html));
	     	        return(State_NCMAUnblock);
	     	      }
	     	      break;


	     	  }

	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");
                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;
#ifdef CHIMPANZEE_INTERFACE
       		      ncma_trans = Trans_Registry; /* cue on up */
       		      setcallback();

       		      return(State_NCMAApresPIN);
#else
		      goto proceed_after_pin;
	     	      break;
#endif
	          }


    	 } /* end state_ncmapin */
    	 break;

#ifdef CHIMPANZEE_INTERFACE
/*********************************************************************************

    STATE_NCMAAPRESPIN wait for registry completion on bootblock read after user PIN entry

 *********************************************************************************/
    case State_NCMAApresPIN:

         switch(trans) {

             case Trans_Registry:
                if(bootblock_read_succeeded()==0) { /* bootblock read ok, but not finished yet */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock\n");
                  return(State_NCMAApresPIN);
                }

		if(ram_empty() && !nvram_empty()) {
		    ncma_dbox_open(URL_PATH(moved.html));
		    return(State_NCMAMoved);
		} else {
		    ncma_dbox_open(URL_PATH(connect.html));
		    return(State_NCMAConnect);
		}

 	 }
	 break;
#endif


/*********************************************************************************

    STATE_NCMABADPIN

 *********************************************************************************/
    case State_NCMABadPin:

         switch(trans) {

             case Trans_URLRetry:
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: getting ready for another go\n");
             	  //ncma_url_open("file:/ncma:pin.html");
             	  ncma_dbox_open(URL_PATH(pin.html));
             	  return(State_NCMAPin);
         } /* end state_ncmabadpin */
         break;

/*********************************************************************************

    STATE_NCMACONNECT

 *********************************************************************************/
    case State_NCMAConnect:

    	 switch(trans) {

	     case Trans_URLChangePIN: /* the user clicked on 'change pin' */
	     	  ncma_dbox_open(URL_PATH(newpin.html));
	     	  return(State_NCMANewPIN);


	 	case Trans_URLConnect:

		     if(fetch_sc_bootblock()<0) {
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read sc bootblock\n");
		         ncma_dbox_open(URL_PATH(damaged.html));
		         return(State_NCMABadCard);
		     }

		     managed_access_nightmare: /* also entry point after dialling relationship server */

		     if(virgin_smartcard()) { /* smartcard never been written to */

		     call_relationship_server:
		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: building ROM dial details\n");
		       build_rs_cache();

		       ncma_network_init(NCMA_NET_ROM | NCMA_NET_PRE_DIAL);
		       if(find_enterprise_id()<0) {
		           DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: couldn't read enterprise ID - downloading s/c content\n");
		       }

		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ROM DIALLING...\n");
		       if(ncma_dial()<0) {
		           DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: relationship server dial failed\n");
		           ncma_dbox_open(URL_PATH(connect.html));
		           return(State_NCMAConnect);
		       }
		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: relationship server dial succeeded ->%s\n", state_string(State_NCMADiallingRelServer));

		       return(State_NCMADiallingRelServer);
		     } /* endif virgin smartcard */

		     if(ram_empty()) { /* no connect matrix details in RAM */
		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: RAM matrix empty - trying NVRAM\n");
		       if(nvram_empty()) { /* or in NVRAM */
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: NVRAM empty - calling RelServer\n");
		        goto call_relationship_server;
		       } else { /* RAM empty, but NVRAM isn't */
		         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: NVRAM details available\n");
			 if(box_moved) {
			     goto call_relationship_server;
			 } else {
			     copy_nvram_to_ram();
			     goto connect_from_ram;
			 }
		         return(State_NCMAMoved);
		       }

		     } else { /* there are connect details in RAM */

		     connect_from_ram:
		       if(find_enterprise_id()<0) {
                          DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read enterprise id\n");
                          ncma_dbox_open(URL_PATH(damaged.html));
                          return(State_NCMABadCard);
                       }

      		       if(find_ram_enterprise_block()<0) { /* enterprise ID not found in RAM */
      		         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no ENTERPRISE_ID match in RAM - calling RS\n");
      		         goto call_relationship_server;
      		       }


		       if(skip_ram_cache_build) { /* rel. server dial up already built the cache */
		           DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: skipping ram cache build and network setup\n");
		           skip_ram_cache_build = 0;
		       } else {
      		           if(build_ram_cache()<0) { /* insufficient connect details, call RS */
      		             DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: insufficient connection details - calling RS\n");
      		             goto call_relationship_server;
      		           }
      		           if(ncma_network_init(NCMA_NET_RAM | NCMA_NET_PRE_DIAL)<0) {
        		     DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: network init failed\n");
    			   }

      		       }

      		       /* dial based on connection details in RAM/SC */
      		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: RAM/SC DIALLING...\n");
      		       if(ncma_dial()<0) {
      		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: IAP dial initiation failed\n");
      		         ncma_dbox_open(URL_PATH(connect.html));
      		         return(State_NCMAConnect);
      		       }

                     } /* endifelse RAM empty */


		     return(State_NCMADiallingISP);
                     break;

                case Trans_URLConnectNak:
		     ncma_url_open(WELCOME_SCREEN_URL);
     		     run_from_powerup = 0;
             	     return(State_NCMAInit);
                     break;
         } /* end state_ncmaconnect */
         break;


/*********************************************************************************

    STATE_NCMADIALLINGISP

 *********************************************************************************/
    case State_NCMADiallingISP:

    	 switch(trans) {

    	     case Trans_DialBad: /* Don't know what to do here! Not in the CIS!! */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ISP dial failed - bummer\n");
    	     	  ncma_dbox_open(URL_PATH(connect.html));
    	     	  return(State_NCMAConnect);
    	     	  break;

    	     case Trans_DialOK: /* dial succeeded */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ISP dial succeeded\n");
    	     	  build_nvram_info();


    	     	  ncma_cron_kick(0); /* setup scheduled update */
    	     	  ncma_network_init(NCMA_NET_RAM | NCMA_NET_POST_DIAL); /* set resolver variables */

     	     	  if(ui_present()) {
     	     	     if(ro_smurf_mounted) {
 	                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Boot structure mounted\n");
     	     	         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: top level UI detected - fullbooting\n");
      	     	         ncma_exec_fullboot();
      	     	     }
      	     	     ncma_url_open("file:/UI:index.html"); /* display top level menu */
      	     	     return(State_NCMABooted);
      	     	  } else {
      	     	      if(ro_smurf_mounted) { /* got a boot filing system, ie not registration server */
         	        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Boot structure mounted\n");
      	     	        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no top level UI - prompting for download\n");
      	     	        ncma_dbox_open(URL_PATH(download.html));
      	     	        return(State_NCMADownload);
      	     	      } else { /* no boot filing system, must be registration server */

      	     	      /* fetch URL if it isn't open already (auto-loaded in browser-limiting mode) */
      	     	      if(user_isp_registered()==1) ncma_url_user();
      	     	      }
      	     	  }



    	     	      return(State_NCMABooted);
 		      break;
 	 } /* end state_ncmadiallingisp */

/*********************************************************************************

    STATE_NCMABOOTED

 *********************************************************************************/
    case State_NCMABooted:

    	 switch(trans) {

    	     case Trans_MIMEOk:
                  if(ncma_network_init(NCMA_NET_RAM | NCMA_NET_POST_DIAL)<0) {
                    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: network init failed\n");
                  }

    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: MIME reload successful\n");
     	     	  if(ui_present()) {
     	     	     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: top level UI detected - fullbooting\n");
      	     	     if(ro_smurf_mounted) ncma_exec_fullboot();
      	     	     ncma_url_open("file:/UI:index.html"); /* display top level menu */
      	     	     return(State_NCMABooted);
      	     	  } else {
      	     	      if(ro_smurf_mounted) { /* got a boot filing system, ie not registration server */
      	     	        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no top level UI - prompting for download\n");
      	     	        ncma_dbox_open(URL_PATH(download.html));
      	     	        return(State_NCMADownload);
      	     	      } else { /* no boot filing system, must be registration server */
      	     	          ncma_url_user();
      	     	      }
      	     	  }
    	     	  return(State_NCMABooted);

    	     case Trans_MIMEBad:
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bad MIME reload - ignoring\n");
    	     	  ncma_dbox_open(URL_PATH(scprobs.html));
    	     	  return(State_NCMABooted);

    	     case Trans_NCMASurf:
    	     	  ncma_url_user();
    	     	  return(State_NCMABooted);

	     case Trans_PPPTimeout:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PPP timeout event received\n");
	     	  ignore_ppp_timeout = 1;
	     	  set_ppp_timeout();
	     	  ncma_sound_effect(NCMA_TIMEOUT_SOUND);
	     	  ncma_dbox_open(URL_PATH(disconnect.html));
	     	  return(State_NCMABooted);

	     case Trans_URLDisconnectAck:
	     	  ignore_ppp_timeout = 0;
	     	  ncma_hangup();
	     	  return(State_NCMABooted);

	     case Trans_URLDisconnectNak:
	     	  ignore_ppp_timeout = 0;
	     	  set_ppp_timeout();
	     	  return(State_NCMABooted);

	     case Trans_HUP:
	     	  return(State_NCMABooted);

	     case Trans_Cron:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got CRON event\n");
	     	  if(cron_upcall(cron_value)<0)
	     	    return(State_NCMABooted); /* failed */
	     	  else {
	     	      pre_cron_state = State_NCMABooted;
	     	      return(State_NCMACron);
	     	  }


	     case Trans_BootedFull:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: MIME reload Full Boot completed\n");
	     	  return(State_NCMABooted);
    	 } /* end state_ncmabooted */
    	 break;

/*********************************************************************************

    STATE_NCMADOWNLOAD

 *********************************************************************************/
    case State_NCMADownload:

         switch(trans) {

	          /* these ops split into 2 to give the browser a chance to display transfer.html before the
	             transfer starts :) */

             case Trans_URLDownloadMin:
             	  ncma_boottype = NCMA_BOOT_MIN;
             	  ncma_dbox_open(URL_PATH(transfer.html));
             	  return(State_NCMADownload);
             	  break;

             case Trans_URLDownloadMax:
             	  ncma_boottype = NCMA_BOOT_MAX;
             	  ncma_dbox_open(URL_PATH(transfer.html));
             	  return(State_NCMADownload);
             	  break;

             case Trans_URLDownloadNak:
             	  ncma_hangup();
             	  return(State_NCMADownload);

             case Trans_HUP:
             	  ncma_url_open(WELCOME_SCREEN_URL);
             	  run_from_powerup = 0;
             	  return(State_NCMAInit);

             case Trans_URLDownloadSched:

             	  prevent_shutdown = 0;
             	  shutdown_nc();
             	  return(State_NCMAShutdown);
		  break;

             case Trans_BootedFull:
             	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Full boot completed\n");
             	  ncma_dbox_close();
             	  if(ui_present()) ncma_url_gsopen(TOPLEVEL_UI_URL);
             	  else ncma_url_user();
             	  return(State_NCMABooted);
             	  break;

	     case Trans_BootedFast:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Fast boot completed\n");
	     	  ncma_dbox_close();
	     	  if(ui_present()) ncma_url_gsopen(TOPLEVEL_UI_URL);
	     	  else ncma_url_user();
	     	  return(State_NCMABooted);
	     	  break;

	     case Trans_URLTransfer:
             	  ncma_start_progress_ui();
	          if(ncma_boottype == NCMA_BOOT_MAX) ncma_exec_fullboot();
	     	  else ncma_exec_fastboot();
	     	  ncma_boottype = NCMA_BOOT_NONE;
	     	  return(State_NCMADownload);
	     	  break;

	 } /* end state_ncmadownload */
	 break;

 /*********************************************************************************

    STATE_NCMASHUTDOWN

 *********************************************************************************/
    case State_NCMAShutdown:

         switch(trans) {

             case Trans_URLShutdown:
             case Trans_Shutdown:
                  prevent_shutdown = 0;
                  shutdown_nc();
                  ncma_dbox_close();
                  if(ui_present()) ncma_url_gsopen(TOPLEVEL_UI_URL);
                  else ncma_url_open(BLANK_SCREEN_URL);
                  return(State_NCMAShutdown);
                  break;

             case Trans_URLShutdownCancel:
             	  return(pre_shutdown_state);
             	  break;

             case Trans_ShutdownComplete:
             	  prevent_shutdown = 1;
             	  if(ui_present()) prod_browser_after_standby();
             	  return(State_NCMAInit);
             	  break;
         } /* end state_ncmashutdown */
         break;

/*********************************************************************************

    STATE_NCMAUNBLOCK

 *********************************************************************************/
    case State_NCMAUnblock:

         switch(trans) {

             case Trans_URLMismatch: /* user has entered unblock details */
             	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: unblock PIN mismatch\n");
             	  ncma_dbox_open(URL_PATH(mismatch.html));
             	  return(State_NCMAUnblock);

             case Trans_URLMismatchAck:
             	  ncma_dbox_open(URL_PATH(unblock.html));
             	  return(State_NCMAUnblock);

             case Trans_AuthFail:
             	  DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: PIN unblock failure\n");
             	  ncma_dbox_open(URL_PATH(badubp.html));
             	  return(State_NCMABadUnblockPIN);

             case Trans_CardOK: /* ignore these, they get spewed for an invalid unblock PIN */
             	  // DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: PIN unblock failure\n");
             	  // ncma_dbox_open(URL_PATH(unblock.html));
             	  return(State_NCMAUnblock);

    	     case Trans_Registry:
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failed failed\n");
	     	      ncma_dbox_open(URL_PATH(unblock.html));
	     	      return(State_NCMAUnblock);
	     	  }

	     	  if(registry_status_asserted(BB_STATUS_BB_VALID) || registry_status_cleared(BB_STATUS_LOCKED) ||
	     	  		registry_status_cleared(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");

                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

		      ncma_dbox_open(URL_PATH(connect.html));
        	      return(State_NCMAConnect);

	     	  }
    	 }
    	 break;


/*********************************************************************************

    STATE_NCMABADUNBLOCKPIN

 *********************************************************************************/
    case State_NCMABadUnblockPIN:

         switch(trans) {

             case Trans_URLBadUnblockPINAck:
             	  ncma_dbox_open(URL_PATH(unblock.html));
             	  return(State_NCMAUnblock);
         }
         break;



/*********************************************************************************

    STATE_NCMANEWPIN

 *********************************************************************************/
    case State_NCMANewPIN:

    	 switch(trans) {

	     case Trans_AuthFail: /* failed setting PIN */ /* this shouldn't happen */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failure\n");
	     	  ncma_dbox_open(URL_PATH(newpin.html));
	     	  return(State_NCMANewPIN);

	     	  break;

	     case Trans_URLMismatch: /* the two PINs the user entered didn't match */
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: fetching PIN mismatch page\n");
	     	  ncma_dbox_open(URL_PATH(mismatch.html));
	     	  return(State_NCMAMismatch);
	     	  break;

	     case Trans_URLLeavePIN: /* a cancel on the change pin OSD */
	     	  if(ui_present()) {
	     	     ncma_url_gsopen(TOPLEVEL_UI_URL);
	     	     return(State_NCMABooted);
	     	  } else {
	     	    ncma_dbox_open(URL_PATH(connect.html));
	     	    return(State_NCMAConnect);
	     	  }
	     	  break;

    	     case Trans_Registry: /* PIN set status from registry */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failed failed\n"); /* this shouldn't happen */
	     	      ncma_dbox_open(URL_PATH(newpin.html));
	     	      return(State_NCMANewPIN);
	     	  }

	     	  if(registry_status_asserted(BB_STATUS_BB_VALID) || registry_status_cleared(BB_STATUS_LOCKED) ||
	     	  		registry_status_cleared(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");

                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

		      ncma_dbox_open(URL_PATH(connect.html));
        	      return(State_NCMAConnect);

	     	  }
    	 }
    	 break;

/*********************************************************************************

    STATE_NCMACHANGEPIN "do you want to change your pin?" now obsolete

 *********************************************************************************/
    case State_NCMAChangePIN:

    	 switch(trans) {

    	     case Trans_URLChangePIN:
    	     	  ncma_dbox_open(URL_PATH(newpin.html));
    	     	  return(State_NCMANewPIN);
    	     	  break;

    	     case Trans_URLLeavePIN:
        	  if(cache_smartcard()<0) {
        	     DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard content caching failed\n");
        	  }

		  ncma_dbox_open(URL_PATH(connect.html));
        	  return(State_NCMAConnect);

	 }
	 break;

/*********************************************************************************

    STATE_NCMAMISMATCH

 *********************************************************************************/
    case State_NCMAMismatch:

    	 switch(trans) {

    	     case Trans_URLMismatchAck:
    	     	  ncma_dbox_open(URL_PATH(newpin.html));
    	     	  return(State_NCMANewPIN);
    	     	  break;
    	 }
    	 break;


/*********************************************************************************

    STATE_NCMAMOVED

 *********************************************************************************/
    case State_NCMAMoved:

    	 switch(trans) {

    	     case Trans_URLMovedNak:
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: box not moved\n");
    	     	  box_moved = 0;
		  ncma_dbox_open(URL_PATH(connect.html));
		  return(State_NCMAConnect);
    	     	  break;

    	     case Trans_URLMovedAck:
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: box moved\n");
    	     	  box_moved = 1;
    	     	  ncma_dbox_open(URL_PATH(connect.html));
    	     	  return(State_NCMAConnect);
    	     	  break;
    	 }

/*********************************************************************************

    STATE_NCMADIALLINGRELSERVER

 *********************************************************************************/
    case State_NCMADiallingRelServer:

    	 switch(trans) {
	     case Trans_CompleteOK:
    	     case Trans_Registry: /* ignore registry transitions - they'll be bootblock write events triggered by
    	     	  		     the MIME object */

	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ignoring registry transition\n");
	          return(State_NCMADiallingRelServer);
	          break;

    	     case Trans_DialBad: /* Don't know what to do here! Not in the CIS!! */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: rel. server dial failed - bummer\n");
    	     	  ncma_dbox_open(URL_PATH(connect.html));
    	     	  return(State_NCMAConnect);
    	     	  break;

    	     case Trans_DialOK: /* dial succeeded */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: rel. server dial succeeded\n");

    	     	  fetch_relationship_url();
    	     	  return(State_NCMADiallingRelServer);
    	     	  break;

    	     case Trans_MIMEBad: /* oh dear - bad MIME */

		  ncma_hangup();

    	          if(last_mime_error == MIME_ERROR_NOT_MA) { /* not a valid NC! */
    	     	    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not a valid NC!\n");
    	     	    ncma_dbox_open(URL_PATH(notNC.html));

    	     	    return(State_NCMAInit);
    	     	    break;
    	     	  }

    	          if(last_mime_error == MIME_ERROR_NOT_NC) { /* oh dear - not a managed access box */
    	     	    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not a ManagedAccess NC!\n");
    	     	    ncma_dbox_open(URL_PATH(notMA.html));

    	     	    return(State_NCMAInit);
    	     	    break;
    	     	  }

		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad MIME - showing scprobs.html\n");
		  ncma_dbox_open(URL_PATH(SCprobs.html));
		  return(State_NCMAInit);
		  break;

		  /* this should never happen now */
  	     	  DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: Bad MIME object from relationship server - waiting for HUP\n");    	   	    	     	  return(State_NCMADiallingRelServer);

    	     case Trans_MIMEOk: /* wahey! It worked! */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: MIME object thoroughly grokked - doing netstuff\n");
                  if(ncma_network_init(NCMA_NET_ROM | NCMA_NET_POST_DIAL)<0) {
                    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: network init failed\n");
                  }

    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: HANGING UP\n");
    	     	  ncma_hangup();
    	     	  skip_ram_cache_build = 1; /* tell connect state not to bother building cache as we just did it */
    	     	  return(State_NCMADiallingRelServer);

    	     case Trans_HUP: /* got a HUP ack from dialler */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: line dropped - here we go again...\n");
    	     	  goto managed_access_nightmare;
    	     	  break;

   	 }

/*********************************************************************************

    STATE_NCMACRON

 *********************************************************************************/
    case State_NCMACron:

    	 switch(trans) {
    	     case Trans_DialBad:
    	     	  DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: CRON dial failed\n");
    	     case Trans_HUP:
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: CRON rescheduling\n");
    	     	  ncma_cron_kick(cron_value);
    	     	  return(pre_cron_state);
    	     	  break;

    	     case Trans_DialOK:
    	     	  if(ro_smurf_mounted == 0) {
        	    if(ncma_mount_ro_smurfs()<0) {
            	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: CRON: couldn't mount read-only SMURF\n");
            	        ncma_hangup();
            	        return(State_NCMACron); /* hangup, reschedule on HUP notification */
        	    }
    		  }

    		  /* mount succeeded */
    		  cron_value = -1; /* reschedule for tomorrow on hangup */
    		  ncma_exec_schedboot();
    		  return(State_NCMACron);
    		  break;

             case Trans_BootedUpdate: /* scheduled update completion */
             	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: CRON update completed\n");
             	  ncma_hangup();
             	  return(State_NCMACron);
             	  break;
         }


/*********************************************************************************

    STATE_NCMAPANIC

 *********************************************************************************/
    case State_NCMAPanic:
    default:

	 DBUG_PRINTF(DBUG_LVL_PANIC, "NCMA_machine: PANIC!\n");
	 return(State_NCMAPanic);

  } /* end switch STATE */

  if(trans == Trans_Registry) {
#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: sweet nothings from the registry\n");
#endif
      return(ncma_state);
  }

  if((trans == Trans_CompleteOK) || (trans == Trans_CompleteBad) || (trans == Trans_AuthFail)) {
#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
    DBUG_PRINTF(DBUG_LVL_DEBUG, "NCMA: spurious I/O ACK from smartcard driver...ignoring\n");
#endif
    return(ncma_state);
  }

  /* otherwise . . . PANIC!! */

  DBUG_PRINTF(DBUG_LVL_PANIC, "NCMA: state machine panic - invalid transition event %s in state %s\n",
  		      trans_string(ncma_trans), state_string(ncma_state));

#ifdef ABORT_ON_PANIC
  DBUG_PRINTF(DBUG_LVL_PANIC, "            setting state to State_Panic\n");
  return(State_NCMAPanic);
#else
  return(ncma_state);
#endif
}
