#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

#define PROTOTYPES_INTERNAL /* make prototypes and globals internal to this file */
#include "machine.h"
#include "module.h"
#include "ncma_ncma.h"
#include "ncma_scard.h"
#include "ncma_url.h"
#include "ncma_utils.h"
#include "ncma_dial.h"
#include "ncma_cron.h"
#include "ncma_exec.h"
#include "ncma_smurf.h"
#include "ncma_atr.h"
#include "ncma_cache.h"
#include "ncma_bootb.h"
#include "ncma_mime.h"
#include "ncma_nvram.h"
#include "ncma_net.h"
#include "vectors.h"

#include "DBUG.h"



char *trans_string(NCMA_TRANS trans)
{
  static char *t_table[] = {
    "Trans_Idle",
    "Trans_Timeout",
    "Trans_CardOK",
    "Trans_CardBad",
    "Trans_CardRemoved",
    "Trans_CompleteOK",
    "Trans_CompleteBad",
    "Trans_AuthFail",
    "Trans_URLStart",
    "Trans_URLRetry",
    "Trans_Registry",
    "Trans_Shutdown",
    "Trans_ShutdownComplete",
    "Trans_URLShutdown",
    "Trans_URLShutdownCancel",
    "Trans_URLUnblock",
    "Trans_URLChangePIN",
    "Trans_URLLeavePIN",
    "Trans_PowerUp",
    "Trans_DialOK",
    "Trans_DialBad",
    "Trans_URLMismatch",
    "Trans_URLMismatchAck",
    "Trans_NCMASurf",
    "Trans_URLDownloadMin",
    "Trans_URLDownloadMax",
    "Trans_URLDownloadSched",
    "Trans_URLDownloadNak",
    "Trans_URLConnect",
    "Trans_URLConnectNak",
    "Trans_MIMEOk",
    "Trans_MIMEBad",
    "Trans_URLMovedAck",
    "Trans_URLMovedNak",
    "Trans_PPPTimeout",
    "Trans_DisconnectNak",
#ifdef POINTLESS_BUTTONS
    "Trans_URLSmartcardAck",
    "Trans_URLBadCardAck",
#endif
"Trans_URLDisconnectAck"
  };


  return(t_table[trans]);
}

char *state_string(NCMA_STATE state)
{
    static char *s_table[] = {
    "State_NCMAInit",
    "State_NCMAStart",
    "State_NCMAPanic",
    "State_NCMASleep",
    "State_NCMANoCard",
    "State_NCMABadCard",
    "State_NCMAPin",
    "State_NCMADiallingISP",
    "State_NCMABadPin",
    "State_NCMAShutdown",
    "State_NCMAUnblock",
    "State_NCMAChangePIN",
    "State_NCMANewPIN",
    "State_NCMAMismatch",
    "State_NCMABooted",
    "State_NCMADownload",
    "State_NCMAConnect",
    "State_NCMADiallingRelServer",
    "State_NCMAMoved",
    "State_NCMADiallingRegServer"
  };

  return(s_table[state]);
}

/* this is the NCMA ASM */
NCMA_STATE machine(NCMA_TRANS trans)
{

#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got transition %s in state %s\n", trans_string(trans), state_string(ncma_state));
#else
  if(trans != Trans_CompleteOK)
    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got transition %s in state %s\n", trans_string(trans), state_string(ncma_state));
#endif

/*********************************************************************************

    GLOBAL TRANSITIONS

 *********************************************************************************/

  switch(trans) { /* global transitions that apply to all states (except maybe State_Sleep) */

    case Trans_Shutdown:
    	 pre_shutdown_state = ncma_state;
    	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: shutdown imminent - pushed state \"%s\"\n", state_string(ncma_state));
    	 ncma_dbox_open(URL_PATH(poweroff.html));
    	 return(State_NCMAShutdown);

    case Trans_Registry: /* HACK - damn s/c layer doesn't always report Card_Removed */
         if(registry_status_cleared(BB_STATUS_INSERTED)) goto card_removed;
         break;

    case Trans_CardRemoved:
         card_removed:
    	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard removed\n");
    	 unlock_cache();

#ifdef POINTLESS_BUTTONS
         if(ncma_state == State_NCMABadCard) return(State_NCMABadCard); /* oh, how hatefully poor */
#endif
    	 if(ncma_started) {
    	     ncma_dbox_open(URL_PATH(splash.html));
    	     return(State_NCMANoCard);
    	 } else return(State_NCMAInit);
    	 break;

    default:
         break;
  }

  switch(ncma_state) {

/*********************************************************************************

    STATE_NCMAINIT

 *********************************************************************************/
    case State_NCMAInit:  /* start-up, pre WIMP stage */

         switch(trans) {

	   case Trans_PowerUp:  /* and so, I awake... */

	        if(ui_present()) { /* we're coming out of standby, and we've got a UI downloaded */
	           return(State_NCMAInit); /* top level menu is already on screen, so do nothing */
	        }  			   /* next transition will be URLStart */

	   	if(!smartcard_present()) { /* powered up but no card? Fetch the blurb */

#ifdef ENABLE_DEBUGGING
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif
	   	  return(State_NCMAInit);
	   	}

	   	/* otherwise, there's a card in, so fall through */

	   	/* \/ \/ \/ \/ \/ DELIBERATE FALL THRU \/ \/ \/ \/ \/ */


           case Trans_URLStart: /* got a URL/CLI type call */

#ifdef POINTLESS_BUTTONS
       		pointless_ncma_manual_restart:
#endif

                ncma_started = 1;

	        /* read our status vars so smartcard checking works
	           (because we've no doubt missed a bunch of registry service calls */

	           registry_status = smartcard_status(NULL);
	           registry_delta = registry_status; /* assume everything set */

	   	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Managed access starting\n");
		if(!smartcard_present()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no smartcard - fetching splash screen\n");
		    ncma_dbox_open(URL_PATH(splash.html));
		    return(State_NCMANoCard);
		}

		if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard - bailing\n");
		    ncma_dbox_open(URL_PATH(invalid.html));
		    return(State_NCMABadCard);
		}


		if(smartcard_pin_protected()) {
		    card_attempts = smartcard_blocked();
		    if(card_attempts>0) {
		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
		      ncma_dbox_open(URL_PATH(pin.html));
		      return(State_NCMAPin);
		    } else {
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard is blocked\n");
		        ncma_dbox_open(URL_PATH(unblock.html));
		        return(State_NCMAUnblock);
		    }
		}

		proceed_after_pin:

                if(bootblock_read_succeeded()==0) { /* bootblock read ok, but not finished yet */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock\n");
                  return(State_NCMANoCard);
                }


		if(cache_smartcard()<0) {
		    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard content caching failed\n");
		}
		ncma_dbox_open(URL_PATH(connect.html));
		return(State_NCMAConnect);


	 } /* end state_ncmainit */
	 break;

/*********************************************************************************

    STATE_NCMABADCARD

 *********************************************************************************/
    case State_NCMABadCard: /* waiting for URL/CLI call */

    	 switch(trans) {
#ifdef POINTLESS_BUTTONS
       	     case Trans_Registry:
       	     case Trans_CardRemoved:
       	     	  return(State_NCMANoCard);

       	     case Trans_URLBadCardAck:
       	     	  goto pointless_ncma_manual_restart;
#else
    	     case Trans_CardRemoved: /* user has removed bad card */

    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard removed\n");
    	     	  ncma_dbox_open(URL_PATH(splash.html));
    	     	  return(State_NCMANoCard);
#endif
    	 } /* end state_ncmabadcard */

    	 break;

/*********************************************************************************

    STATE_NCMANOCARD

 *********************************************************************************/
    case State_NCMANoCard: /* waiting for a smartcard to be inserted */

         switch(trans) {
	    case Trans_CardOK:
	         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card_ok event - clearing status delta register\n");
	         smartcard_status(NULL);
	    	 return(State_NCMANoCard);

            case Trans_Registry: /* card activity */

#ifdef POINTLESS_BUTTONS
       		 return(State_NCMANoCard);

            case Trans_URLSmartcardAck:
#endif


		if(!registry_status_changed(BB_STATUS_LOCKED)) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading PIN status\n");
		    return(State_NCMANoCard);
		}

		if(registry_status_asserted(BB_STATUS_BADVERSION)) {
		    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: bad smartcard version\n");
		    ncma_dbox_open(URL_PATH(invalid.html));
		    return(State_NCMABadCard);
		}

	    	if(registry_status_asserted(BB_STATUS_LOCKED)) { /* PIN protected */
	    	    card_attempts = smartcard_blocked();
	    	    if(card_attempts>0) {
 		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard PIN protected (%d attempts) - fetching page\n", card_attempts);
		      ncma_dbox_open(URL_PATH(pin.html));
		      return(State_NCMAPin);
		    } else {
		      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard is blocked\n");
		      ncma_dbox_open(URL_PATH(unblock.html));
		      return(State_NCMAUnblock);
		    }
		}

                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
                if(bootblock_read_failed()) {
                     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bootblock read failed\n");
                     ncma_dbox_open(URL_PATH(damaged.html));
                     return(State_NCMABadCard);
                }


		goto proceed_after_pin;

		break;

            case Trans_CardBad: /* bad card */

            	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bad card re-inserted\n");
            	 ncma_dbox_open(URL_PATH(damaged.html));
            	 return(State_NCMABadCard);
         } /* end state_ncmanocard */
         break;

/*********************************************************************************

    STATE_NCMAPIN

 *********************************************************************************/
    case State_NCMAPin:

    	 switch(trans) {

	     case Trans_URLChangePIN: /* the user clicked on 'change pin' */
	     	  ncma_dbox_open(URL_PATH(newpin.html));
	     	  return(State_NCMANewPIN);

	     case Trans_AuthFail: /* the user entered a pin, but it failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure (authfail)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	    ncma_dbox_open(URL_PATH(badpin.html));
	     	    return(State_NCMABadPin);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open(URL_PATH(unblock.html));
	     	    return(State_NCMAUnblock);
	     	  }
	     	  break;

    	     case Trans_Registry: /* the user entered a pin, maybe it worked, maybe it didn't */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	        ncma_dbox_open(URL_PATH(badpin.html));
	     	        return(State_NCMABadPin);
	     	      } else {
	     	        ncma_dbox_open(URL_PATH(unblock.html));
	     	        return(State_NCMAUnblock);
	     	      }
	     	      break;


	     	  }

	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");
/*
        	      if(cache_smartcard()<0) {
        		 DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard content caching failed\n");
        	      }

        	      if(ncma_dial()<0) {
        		 DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: dial initiation failed\n");
        	      }
        	      return(State_NCMADiallingISP);

	     	  }
*/
                    strncpy(old_chv_pin, chv_pin, chv_pin_size);
                    old_chv_pin_size = chv_pin_size;

		    goto proceed_after_pin;
	     	    break;
	          }


    	 } /* end state_ncmapin */
    	 break;

/*********************************************************************************

    STATE_NCMABADPIN

 *********************************************************************************/
    case State_NCMABadPin:

         switch(trans) {

             case Trans_URLRetry:
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: getting ready for another go\n");
             	  //ncma_url_open("file:/ncma:pin.html");
             	  ncma_dbox_open(URL_PATH(pin.html));
             	  return(State_NCMAPin);
         } /* end state_ncmabadpin */
         break;

/*********************************************************************************

    STATE_NCMACONNECT

 *********************************************************************************/
    case State_NCMAConnect:

    	 switch(trans) {
	 	case Trans_URLConnect:

		     if(fetch_sc_bootblock()<0) {
		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: couldn't read sc bootblock\n");
		         ncma_dbox_open(URL_PATH(damaged.html));
		         return(State_NCMABadCard);
		     }

		     managed_access_nightmare: /* also entry point after dialling relationship server */

		     if(virgin_smartcard()) { /* smartcard never been written to */
		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: virgin smartcard\n");

		     call_relationship_server:
		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: building ROM dial details\n");
		       build_rs_cache();

		       ncma_network_init();

		       if(ncma_dial()<0) {
		           DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: relationship server dial failed\n");
		           ncma_dbox_open(URL_PATH(connect.html));
		           return(State_NCMAConnect);
		       }
		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: relationship server dial succeeded ->%s\n", state_string(State_NCMADiallingRelServer));

		       return(State_NCMADiallingRelServer);
		     } /* endif virgin smartcard */

		     if(ram_empty()) { /* no connect matrix details in RAM */
		       DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: RAM matrix empty - trying NVRAM\n");
		       if(nvram_empty()) { /* or in NVRAM */
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: NVRAM empty - calling RelServer\n");
		        goto call_relationship_server;
		       } else { /* RAM empty, but NVRAM isn't */
		         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: NVRAM details available\n");
		         ncma_dbox_open(URL_PATH(moved.html)); /* find out whether we've moved or not */
		       }

		       return(State_NCMAMoved);
		     } else { /* there are connect details in RAM */

		     connect_from_ram:
		       if(find_enterprise_id()<0) {
                          DBUG_PRINTF(DBUG_LVL_ERROR, "find_ram_enterprise_block: couldn't read enterprise id\n");
                          ncma_dbox_open(URL_PATH(damaged.html));
                          return(State_NCMABadCard);
                       }

      		       if(find_ram_enterprise_block()<0) { /* enterprise ID not found in RAM */
      		         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no ENTERPRISE_ID match in RAM - calling RS\n");
      		         goto call_relationship_server;
      		       }

		       if(skip_ram_cache_build) { /* rel. server dial up already built the cache */
		           DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: skipping ram cache build and network setup\n");
		           skip_ram_cache_build = 0;
		       } else {
      		           if(build_ram_cache()<0) { /* insufficient connect details, call RS */
      		             DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: insufficient connection details - calling RS\n");
      		             goto call_relationship_server;
      		           }
      		           if(ncma_network_init()<0) {
        		     DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: network init failed\n");
    			   }

      		       }

      		       /* dial based on connection details in RAM/SC */
      		       if(ncma_dial()<0) {
      		         DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: IAP dial initiation failed\n");
      		         ncma_dbox_open(URL_PATH(connect.html));
      		         return(State_NCMAConnect);
      		       }

                     } /* endifelse RAM empty */


		     return(State_NCMADiallingISP);
                     break;

                case Trans_URLConnectNak:
                     prevent_shutdown = 0;
                     ncma_url_open(BLANK_SCREEN_URL);
                     shutdown_nc();
                     return(State_NCMAShutdown);
                     break;
         } /* end state_ncmaconnect */
         break;


/*********************************************************************************

    STATE_NCMADIALLINGISP

 *********************************************************************************/
    case State_NCMADiallingISP:

    	 switch(trans) {

    	     case Trans_DialBad: /* Don't know what to do here! Not in the CIS!! */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ISP dial failed - bummer\n");
    	     	  ncma_dbox_open(URL_PATH(connect.html));
    	     	  return(State_NCMAConnect);
    	     	  break;

    	     case Trans_DialOK: /* dial succeeded */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ISP dial succeeded\n");
    	     	  build_nvram_info();


    	     	  ncma_cron_kick(0); /* setup scheduled update */
    	     	  ncma_network_init(); /* set resolver variables */

     	     	     if(ui_present()) {
     	     	        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: top level UI detected - fullbooting\n");
      	     	        ncma_exec_fullboot();
      	     	        ncma_url_open("file:/UI:index.html"); /* display top level menu */
      	     	        return(State_NCMABooted);
      	     	     } else {
      	     	        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no top level UI - prompting for download\n");
      	     	        ncma_dbox_open(URL_PATH(download.html));
      	     	        return(State_NCMADownload);
      	     	     }

    	     	      return(State_NCMABooted);
 		      break;
 	 } /* end state_ncmadiallingisp */

/*********************************************************************************

    STATE_NCMABOOTED

 *********************************************************************************/
    case State_NCMABooted:

    	 switch(trans) {

    	     case Trans_MIMEOk:
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: MIME reload successful\n");
    	     	  return(State_NCMABooted);

    	     case Trans_MIMEBad:
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bad MIME reload\n");
    	     	  return(State_NCMABooted);

    	     case Trans_NCMASurf:
    	     	  ncma_url_user();
    	     	  return(State_NCMABooted);

	     case Trans_PPPTimeout:
	     	  ignore_ppp_timeout = 1;
	     	  set_ppp_timeout();
	     	  ncma_dbox_open(URL_PATH(disconnect.html));
	     	  return(State_NCMABooted);

	     case Trans_URLDisconnectAck:
	     	  ignore_ppp_timeout = 0;
	     	  ncma_hangup();
	     	  return(State_NCMABooted);

	     case Trans_URLDisconnectNak:
	     	  ignore_ppp_timeout = 0;
	     	  set_ppp_timeout();
	     	  return(State_NCMABooted);
    	 } /* end state_ncmabooted */
    	 break;

/*********************************************************************************

    STATE_NCMADOWNLOAD

 *********************************************************************************/
    case State_NCMADownload:

         switch(trans) {

             case Trans_URLDownloadMin:
             	  ncma_dbox_open(URL_PATH(transfer.html));
             	  ncma_exec_fastboot();
             	  return(State_NCMABooted);
             	  break;

             case Trans_URLDownloadMax:
             	  ncma_dbox_open(URL_PATH(transfer.html));
             	  ncma_exec_fullboot();
             	  return(State_NCMABooted);
             	  break;

             case Trans_URLDownloadSched:
             case Trans_URLDownloadNak:
             	  prevent_shutdown = 0;
             	  shutdown_nc();
             	  return(State_NCMAShutdown);
		  break;
	 } /* end state_ncmadownload */
	 break;

 /*********************************************************************************

    STATE_NCMASHUTDOWN

 *********************************************************************************/
    case State_NCMAShutdown:

         switch(trans) {

             case Trans_URLShutdown:
                  prevent_shutdown = 0;
                  shutdown_nc();
                  if(ui_present()) ncma_url_open(TOPLEVEL_UI_URL);
                  else ncma_url_open(BLANK_SCREEN_URL);
                  return(State_NCMAShutdown);
                  break;

             case Trans_URLShutdownCancel:
             	  return(pre_shutdown_state);
             	  break;

             case Trans_ShutdownComplete:
             	  prevent_shutdown = 1;
             	  if(ui_present()) prod_browser_after_standby();
             	  return(State_NCMAInit);
             	  break;
         } /* end state_ncmashutdown */
         break;

/*********************************************************************************

    STATE_NCMAUNBLOCK

 *********************************************************************************/
    case State_NCMAUnblock:

         switch(trans) {

             case Trans_URLMismatch: /* user has entered unblock details */
             	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: unblock PIN mismatch\n");
             	  ncma_dbox_open(URL_PATH(mismatch.html));
             	  return(State_NCMAUnblock);

             case Trans_URLMismatchAck:
             	  ncma_dbox_open(URL_PATH(unblock.html));
             	  return(State_NCMAUnblock);

             case Trans_AuthFail:
             case Trans_CardOK: /* ignore these, they get spewed for an invalid unblock PIN */
             	  // DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: PIN unblock failure\n");
             	  // ncma_dbox_open(URL_PATH(unblock.html));
             	  return(State_NCMAUnblock);

    	     case Trans_Registry:
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failed failed\n");
	     	      ncma_dbox_open(URL_PATH(unblock.html));
	     	      return(State_NCMAUnblock);
	     	  }

	     	  if(registry_status_asserted(BB_STATUS_BB_VALID) || registry_status_cleared(BB_STATUS_LOCKED) ||
	     	  		registry_status_cleared(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");

                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

		      ncma_dbox_open(URL_PATH(connect.html));
        	      return(State_NCMAConnect);

	     	  }
    	 }
    	 break;


/*********************************************************************************

    STATE_NCMANEWPIN

 *********************************************************************************/
    case State_NCMANewPIN:

    	 switch(trans) {

	     case Trans_AuthFail:
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failure\n");
	     	  ncma_dbox_open(URL_PATH(newpin.html));
	     	  return(State_NCMANewPIN);

	     	  break;

	     case Trans_URLMismatch:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: fetching PIN mismatch page\n");
	     	  ncma_dbox_open(URL_PATH(mismatch.html));
	     	  return(State_NCMAMismatch);
	     	  break;

	     case Trans_URLLeavePIN:
	     	  ncma_dbox_open(URL_PATH(pin.html));
	     	  return(State_NCMAPin);
	     	  break;

    	     case Trans_Registry:
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failed failed\n");
	     	      ncma_dbox_open(URL_PATH(newpin.html));
	     	      return(State_NCMANewPIN);
	     	  }

	     	  if(registry_status_asserted(BB_STATUS_BB_VALID) || registry_status_cleared(BB_STATUS_LOCKED) ||
	     	  		registry_status_cleared(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");

                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

		      ncma_dbox_open(URL_PATH(connect.html));
        	      return(State_NCMAConnect);

	     	  }
    	 }
    	 break;

/*********************************************************************************

    STATE_NCMACHANGEPIN "do you want to change your pin?" now obsolete

 *********************************************************************************/
    case State_NCMAChangePIN:

    	 switch(trans) {

    	     case Trans_URLChangePIN:
    	     	  ncma_dbox_open(URL_PATH(newpin.html));
    	     	  return(State_NCMANewPIN);
    	     	  break;

    	     case Trans_URLLeavePIN:
        	  if(cache_smartcard()<0) {
        	     DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard content caching failed\n");
        	  }

		  ncma_dbox_open(URL_PATH(connect.html));
        	  return(State_NCMAConnect);

	 }
	 break;

/*********************************************************************************

    STATE_NCMAMISMATCH

 *********************************************************************************/
    case State_NCMAMismatch:

    	 switch(trans) {

    	     case Trans_URLMismatchAck:
    	     	  ncma_dbox_open(URL_PATH(newpin.html));
    	     	  return(State_NCMANewPIN);
    	     	  break;
    	 }
    	 break;


/*********************************************************************************

    STATE_NCMAMOVED

 *********************************************************************************/
    case State_NCMAMoved:

    	 switch(trans) {

    	     case Trans_URLMovedNak:
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: box not moved - connecting from NVRAM\n");
    	     	  copy_nvram_to_ram();
    	     	  goto connect_from_ram;
    	     	  break;

    	     case Trans_URLMovedAck:
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: box moved - calling RelServer\n");
    	     	  goto call_relationship_server;
    	     	  break;
    	 }

/*********************************************************************************

    STATE_NCMADIALLINGRELSERVER

 *********************************************************************************/
    case State_NCMADiallingRelServer:

    	 switch(trans) {
	     case Trans_CompleteOK:
    	     case Trans_Registry: /* ignore registry transitions - they'll be bootblock write events triggered by
    	     	  		     the MIME object */

	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ignoring registry transition\n");
	          return(State_NCMADiallingRelServer);
	          break;

    	     case Trans_DialBad: /* Don't know what to do here! Not in the CIS!! */
    	     	  line_up = 0;
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: rel. server dial failed - bummer\n");
    	     	  ncma_dbox_open(URL_PATH(connect.html));
    	     	  return(State_NCMAConnect);
    	     	  break;

    	     case Trans_DialOK: /* dial succeeded */
    	     	  line_up = 1;
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: rel. server dial succeeded\n");

    	     	  fetch_relationship_url();
    	     	  return(State_NCMADiallingRelServer);
    	     	  break;

    	     case Trans_MIMEBad: /* oh dear - bad MIME */

    	          if(last_mime_error == MIME_ERROR_NOT_MA) { /* not a valid NC! */
    	     	    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not a valid NC!\n");
    	     	    ncma_dbox_open(URL_PATH(notNC.html));

    	     	    return(State_NCMAInit);
    	     	    break;
    	     	  }

    	          if(last_mime_error == MIME_ERROR_NOT_NC) { /* oh dear - not a managed access box */
    	     	    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not a ManagedAccess NC!\n");
    	     	    ncma_dbox_open(URL_PATH(notMA.html));

    	     	    return(State_NCMAInit);
    	     	    break;
    	     	  }

    	     case Trans_MIMEOk: /* wahey! It worked! */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: MIME object thoroughly grokked\n");
    	     	  // ncma_hangup();
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: line dropped - here we go again...\n");
    	     	  skip_ram_cache_build = 1; /* tell connect state not to bother building cache as we just did it */
    	     	  goto managed_access_nightmare;
    	     	  break;

   	 }


/*********************************************************************************

    STATE_NCMAPANIC

 *********************************************************************************/
    case State_NCMAPanic:
    default:

	 DBUG_PRINTF(DBUG_LVL_PANIC, "NCMA_machine: PANIC!\n");
	 return(State_NCMAPanic);

  } /* end switch STATE */

  if(trans == Trans_Registry) {
#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: sweet nothings from the registry\n");
#endif
      return(ncma_state);
  }

  if((trans == Trans_CompleteOK) || (trans == Trans_CompleteBad) || (trans == Trans_AuthFail)) {
#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
    DBUG_PRINTF(DBUG_LVL_DEBUG, "NCMA: spurious I/O ACK from smartcard driver...ignoring\n");
#endif
    return(ncma_state);
  }

  /* otherwise . . . PANIC!! */

  DBUG_PRINTF(DBUG_LVL_PANIC, "NCMA: state machine panic - invalid transition event %s in state %s\n",
  		      trans_string(ncma_trans), state_string(ncma_state));

#ifdef ABORT_ON_PANIC
  DBUG_PRINTF(DBUG_LVL_PANIC, "            setting state to State_Panic\n");
  return(State_NCMAPanic);
#else
  return(ncma_state);
#endif
}
