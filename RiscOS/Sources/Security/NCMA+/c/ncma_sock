#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "ctype.h"

#include "module.h"

#pragma -d0 /* suppress whinges about non-ANSI includes */
#include "socklib.h"
#include "inetlib.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#include "netdb.h"
#pragma -d1

#define PROTOTYPES_INTERNAL
#include "ncma_sock.h"
#include "ncma_cache.h"
#include "DBUG.h"


int open_socket(void)
{
  struct sockaddr_in server;
  struct servent *service;
  int sock, on=1;
  unsigned int i;

  memset((char *)&server, 0, sizeof(server));

  if(cache_enquiry("DNS_PRIMARY", (char *)&i, sizeof(unsigned int))<0) {
      DBUG_PRINTF(DBUG_LVL_ERROR, "open_socket: couldn't read DNS_PRIMARY\n");
      return(-1);
  }

  server.sin_addr.s_addr = i;

  if((service = getservbyname("echo", "tcp")) == NULL) {
      DBUG_PRINTF(DBUG_LVL_ERROR, "open_socket: couldn't read echo/tcp service\n");
      return(-1);
  }

  if ((sock=socket(AF_INET, SOCK_STREAM, 0)) < 0) { /* get a socket descriptor */
    return(-2);
  }

  if (socketioctl(sock, FIOASYNC, &on) < 0) { /* mark socket as asynchronous  */
     close_socket(sock);
     return (-3);
  }

  server.sin_family = AF_INET;
  server.sin_port = service->s_port;

  if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0) {
    close_socket(sock);
    return(-4);
  }

  if (socketioctl(sock, FIONBIO, &on) < 0) { /* mark socket as non-blocking   */
     close_socket(sock);
     return (-5);
  }

  return(sock);
}

void close_socket(int s)
{
  shutdown(s,2);
  socketclose(s);
  return;
}

