#include <stdio.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"


#include "ncma_ncma.h"
#define PROTOTYPES_INTERNAL
#include "ncma_url.h"
#include "ncma_scard.h"
#include "ncma_cache.h"
#include "ncma_tags.h"
#include "ncma_bootb.h"
#include "ncma_ROM.h"
#include "ncma_uid.h"
#include "smcard.h"
#include "dynalloc.h"


#include "DBUG.h"


int ncma_url_init(void)
{
   if(write_os_var(NCMA_URL_ENV_NAME, NCMA_URL_ENV_VAL, strlen(NCMA_URL_ENV_VAL))<0) return(-1);
   if(write_os_var(NCMA_PATH_ENV_NAME, NCMA_PATH_ENV_VAL, strlen(NCMA_PATH_ENV_VAL))<0) return(-1);
   return(0);
}

int ncma_url_open(char *url)
{
    _kernel_swi_regs r;
    int n;

    DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_url_open: %s\n", url);
    n = strlen(url);

    n = n>236?236:n;

    memset(msg_block, 0, 256);

//    *(int *)msg_block = n + 20;
    *(int *)msg_block = 256;
    *(int *)(msg_block + 16) = 0x4af80; /* Message_URL */
    strncpy(msg_block + 20, url, n);

    r.r[0] = 0;
    r.r[1] = (int)msg_block;
    r.r[2] = 0;
    r.r[3] = 0;
    r.r[4] = 0;
    r.r[5] = 0;

    if(_kernel_swi(TaskModule_SendMessage, &r, &r) != NULL) return(-1);
    return(0);
}

char *get_form_field(char *s, char *field)
{
    char *p, *q;

    //if((q = strchr(s, '?'))==NULL) return(NULL);
    if((q = strstr(q, field))==NULL) return(NULL);

    for(;;q++) {
        switch(*q) {
            case '=':
            	 for(p=q; ((*p != '&') && (*p != 0)); p++);
            	 *p = 0;
                 return(++q);
                 break;

            case '&':
            case 0:
            	 return(NULL);
            	 break;

        }
    }
    return(NULL);
}


int ncma_dbox_open(char *url)
{
    _kernel_swi_regs r;
    urlopen_data payload;
    static char dbox_target[] = "__dbox";

    DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_dbox_open: %s\n", url);

    // payload.indirect.url.ptr = url;
    payload.url.offset = sizeof(urlopen_data)+8;
    payload.body_file.ptr = NULL;
    // payload.indirect.target.ptr = dbox_target;
    payload.target.offset = sizeof(urlopen_data);
    payload.tag = 0;
    payload.flags = 0;

    memset(msg_block, 0, 256);

    *(int *)msg_block = 256;
    *(int *)(msg_block + 16) = 0x4af80; /* Message_URL */
    memcpy(msg_block + 20, &payload, sizeof(payload));
    strcpy(msg_block + 20 + sizeof(urlopen_data), dbox_target);
    strcpy(msg_block + 28 + sizeof(urlopen_data), url);

    r.r[0] = 0;
    r.r[1] = (int)msg_block;
    r.r[2] = 0;
    r.r[3] = 0;
    r.r[4] = 0;
    r.r[5] = 0;

    if(_kernel_swi(TaskModule_SendMessage, &r, &r) != NULL) return(-1);
    return(0);
}


int reload_browser_files(void)
{
    _kernel_swi_regs r;

    memset(msg_block, 0, 256);

//    *(int *)msg_block = n + 20;
    *(int *)msg_block = 256;
    *(int *)(msg_block + 16) = 0x4af84; /* Message_NCFresco */
    *(int *)(msg_block + 20) = 0;
    *(int *)(msg_block + 24) = 0;

    r.r[0] = 0;
    r.r[1] = (int)msg_block;
    r.r[2] = 0;
    r.r[3] = 0;
    r.r[4] = 0;
    r.r[5] = 0;

    if(_kernel_swi(TaskModule_SendMessage, &r, &r) != NULL) return(-1);
    return(0);
}


int prod_browser_after_standby(void)
{
    write_os_var(CURRENT_USER_ENV_NAME, CURRENT_USER_ENV_VAL, strlen(CURRENT_USER_ENV_VAL));
    reload_browser_files();
    ncma_url_open(TOPLEVEL_UI_URL);
    return(0);
}


int ncma_url_user(void) /* "start 'Surfing'" URL, as NCI put it */
{
    char *buff;
    char *tag;
    char *serial;
    _kernel_swi_regs r;

    int tag_bytes;

    if(_kernel_swi(NCBootblock_PinInfo, &r, &r)!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_url_user: NCBootblock_PinInfo SWI failed\n");
        return(-1);
    }

    if((buff = (char *)rmalloc(1024, "URL buffer"))==NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_url_user: couldn't allocate memory for URL\n");
        return(-1);
    }

    serial = (char *)r.r[4]; /* get pointer to serial string */


    if((tag = cache_ptr("URL_INITBC", &tag_bytes))!=NULL) { /* append s/c id and m/f id */
      strncpy(buff, tag, tag_bytes);
      strcat(buff, "?");
      strcat(buff, REGISTRATION_URL_CGI1); /* smartcard serial number */
      strcat(buff, serial);
      strcat(buff, "&");
      strcat(buff, REGISTRATION_URL_CGI2); /* manufacturer ID */
      render_hex_id(buff+strlen(buff));
    } else if((tag = cache_ptr("URL_INITB", &tag_bytes))!=NULL) { /* append m/f id only */
      strncpy(buff, tag, tag_bytes);
      strcat(buff, "?");
      strcat(buff, REGISTRATION_URL_CGI2); /* manufacturer ID */
      render_hex_id(buff+strlen(buff));
    } else if((tag = cache_ptr("URL_INITC", &tag_bytes))!=NULL) { /* append s/c id only */
      strncpy(buff, tag, tag_bytes);
      strcat(buff, "?");
      strcat(buff, REGISTRATION_URL_CGI1); /* smartcard serial number */
      strcat(buff, serial);
    } else if((tag = cache_ptr("URL_INIT", &tag_bytes))!=NULL) { /* it's just a bog standard URL */
      strncpy(buff, tag, tag_bytes);
    } else {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_url_user: no URL tags defined\n");
        rmfree((unsigned char *)buff);
        return(-1);
    }

    ncma_url_open(buff);
    rmfree((unsigned char *)buff);
    return(0);
}


/* create a browser files.allow file and flag it for inclusion in next browser config msg */
int limit_browser_url(void)
{
    FILE *fp;
    unsigned char *tptr;
    unsigned int tbytes;
    unsigned char *iptr;

    if((fp=fopen(BROWSER_LIMIT_FILE, "w"))==NULL) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "limit_browser_url: couldn't create temp file\n");
        return(-1);
    }

    if((tptr=find_tag_in_block(sc_block_ptr, sc_block_bytes, NCIURLTag, &tbytes, NULL))==NULL) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "limit_browser_url: no URL to limit browser to!\n");
        fclose(fp);
        return(-1);
    }

    if((iptr = (unsigned char *)strstr((char *)tptr, "//"))==NULL) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "limit_browser_url: didn't understand URL\n");
        fclose(fp);
        return(-1);
    }

    if((iptr = (unsigned char *)strchr((char *)iptr, '/'))==NULL) { /* only slashes are initial '//' - URL is of the form method://host.site  */
      fwrite(tptr, sizeof(unsigned char), tbytes, fp);
      fputs("\n", fp);
      fclose(fp);
      return(0);
    }

    /* otherwise, URL is method://host.site/path/path/file[?args] - limit to method://host.site/path/path/ */
    fwrite(tptr, sizeof(unsigned char), (int)(iptr-tptr), fp);
    fputs("\n", fp);
    fclose(fp);

    limit_browser_access = 1;
    return(0);
}

/* unset the browser site-limiting flag */
int unlimit_browser_url(void)
{
    limit_browser_access = 0;
    return(0);
}

/* set the browser proxy, and limit URL access if applicable */
int browser_proxy(void)
{
    int http = 0, ftp = 0;
    char *hptr, *fptr;
    unsigned int hbytes, fbytes;
    FILE *fp;

    _kernel_swi_regs r;

    if((hptr=cache_ptr("HTTP_PROXY", (int *)&hbytes))!=NULL) http = 1;
    if((fptr=cache_ptr("FTP_PROXY", (int *)&fbytes))!=NULL) ftp = 1;

      if((fp=fopen(BROWSER_CONFIG_FILE, "w"))==NULL) {
          DBUG_PRINTF(DBUG_LVL_ERROR, "browser_proxy: couldn't open config file\n");
          return(-1);
      }

      fprintf(fp, "file.allow: %s\n", limit_browser_access?BROWSER_LIMIT_FILE:"");

      if(http) {
          fprintf(fp, "proxy.http.enable: Yes\n");
          fprintf(fp, "proxy.http: %s\n", hptr);
      }

      if(ftp) {
          fprintf(fp, "proxy.ftp.enable: Yes\n");
          fprintf(fp, "proxy.ftp: %s\n", fptr);
      }


      fclose(fp);

    memset(msg_block, 0, 256);

    *(int *)msg_block = 256;
    *(int *)(msg_block + 16) = 0x4af84; /* Message_NCFresco */
    *(int *)(msg_block + 20) = 2; /* load browser config */
    *(int *)(msg_block + 24) = 0;
    sprintf(msg_block+28, "%s", BROWSER_CONFIG_FILE);

    r.r[0] = 0;
    r.r[1] = (int)msg_block;
    r.r[2] = 0;
    r.r[3] = 0;
    r.r[4] = 0;
    r.r[5] = 0;

    if(_kernel_swi(TaskModule_SendMessage, &r, &r) != NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "browser_proxy: couldn't send message\n");
        return(-1);
    }
    return(0);

}
