/* ncma_uid.c - handle NC ID for managed access */
#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "smcard.h"
#include "ncma_ROM.h"
#define PROTOTYPES_INTERNAL
#include "ncma_uid.h"
#include "DBUG.h"

int init_unique_id(void)
{
    _kernel_swi_regs r;

    r.r[0] = 0;
    r.r[1] = (int)&unique_id;
    r.r[2] = sizeof(unique_id);

    if(_kernel_swi(UniqueID_Read, &r, &r)!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "init_unique_id: get UID SWI failed\n");
        return(0);
    }


    DBUG_PRINTF(DBUG_LVL_DIAG, "init_unique_id: got %d bytes of UID\n", r.r[2]);
#ifdef LIMIT_RUNAWAY_UIDS
   /* if your NVRAM OTP contains crap, you can get a really bogus UID- this code restores sanity */

   if(unique_id.serial_len > r.r[2]) {
       DBUG_PRINTF(DBUG_LVL_DIAG, "init_unique_id: possible runaway UID detected (%d bytes) limiting to %d bytes\n",
        			  unique_id.serial_len, r.r[2]);
       unique_id.serial_len = r.r[2];
   }

   if(unique_id.serial_len <8) {
       DBUG_PRINTF(DBUG_LVL_DIAG, "init_unique_id: serial len was %d - setting to 8\n", unique_id.serial_len);
       unique_id.serial_len = 8;
   }
#endif
    /* copy unique box serial number into serial number field of machine id */
    return(0);
}

int render_hex_id(char *b)
{
    int i;

    sprintf(b, "%02X.%02X.%08X.%08X.%08X.%08X.",
    	       unique_id.serial_version,
    	       unique_id.serial_type,
    	       unique_id.manufacture_ID,
    	       unique_id.model,
    	       unique_id.BIOS_version,
    	       unique_id.ncos_version);

    for(i=0;i<unique_id.serial_len;i++)
        sprintf(b+strlen(b), "%02X", unique_id.serial_info[i]);

    return(0);
}
