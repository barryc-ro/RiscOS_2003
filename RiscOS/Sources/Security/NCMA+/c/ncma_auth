/* ncma_auth - deal with MD5/RSA authentication for managed access */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"
#define PROTOTYPES_INTERNAL
#include "ncma_auth.h"
#include "ncma_ncma.h"
#include "ncma_bootb.h"

#include "DBUG.h"

/* verify either against root or via intermediate certificate, if present */
int ncma_auth(unsigned char *a, unsigned int b, unsigned char *c, unsigned int d, unsigned char *e, unsigned int f)
{
    if((e != NULL) && (f != 0)) { /* certificate details present */
      return(ncma_auth_cert(a,b,c,d,e,f));
    }

    /* else use root public key */
    return(ncma_auth_root(a,b,c,d));
}

/* verify a message against the root (manufacturer) certificate */
int ncma_auth_root(unsigned char *msg, unsigned int mbytes, unsigned char *digest, unsigned int dbytes)
{
    _kernel_swi_regs r;

    DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_auth_root: mbytes: %d dbytes: %d root cert: \"%s\"\n", mbytes, dbytes, ncma_auth_root_certificate_name);
    r.r[0] = AUTH_FLAGS_KEY_DER;
    r.r[1] = (int)msg;
    r.r[2] = mbytes;
    r.r[3] = (int)digest;
    r.r[4] = dbytes;
    r.r[5] = (int)ncma_auth_root_certificate_name;
    r.r[6] = 0;
    r.r[7] = 0;
    if((_kernel_swi(HTTP_VerifyMessageDigest, &r, &r))!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_auth_root: HTTP_VerifyMD SWI failed\n");
        return(-1);
    }

    if(r.r[0] != 0) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_auth_root: FAILED with reason code %d ", r.r[0]);
        switch(r.r[0]) {
            case AUTH_ERROR_BAD_INPUT:
            	 DBUG_PRINTF(DBUG_LVL_ERROR, "BAD INPUT\n");
            	 break;
            case AUTH_ERROR_BAD_CERT:
            	 DBUG_PRINTF(DBUG_LVL_ERROR, "BAD CERT\n");
            	 break;
            case AUTH_ERROR_FAILED:
            	 DBUG_PRINTF(DBUG_LVL_ERROR, "FAILED\n");
            	 break;
          default:
                 DBUG_PRINTF(DBUG_LVL_ERROR, "\n");
        }
        return(-1);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_auth_root: SUCCEEDED\n");
    return(1);
}

/* verify a message against the root (manufacturer) certificate via an intermediate certificate
   so, auth path is:

   authenticate intermediate certificate with root certificate
   authenticate message with intermediate certificate

 */
int ncma_auth_cert(unsigned char *msg, unsigned int mbytes, unsigned char *digest, unsigned int dbytes,
    	           unsigned char *cert, unsigned int cbytes)
{
    _kernel_swi_regs r;

    DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_auth_root: mbytes: %d dbytes: %d root cert: \"%s\"\n", mbytes, dbytes, ncma_auth_root_certificate_name);
    DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_auth_root: cert at 0x%x len: %d\n", cert, cbytes);

    r.r[0] = AUTH_FLAGS_KEY_DER | AUTH_FLAGS_CERT_DER | AUTH_FLAGS_CERT_INCORE;
    r.r[1] = (int)msg;
    r.r[2] = mbytes;
    r.r[3] = (int)digest;
    r.r[4] = dbytes;
    r.r[5] = (int)ncma_auth_root_certificate_name;
    r.r[6] = (int)cert;
    r.r[7] = cbytes;
    if((_kernel_swi(HTTP_VerifyMessageDigest, &r, &r))!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_auth_cert: HTTP_VerifyMD SWI failed\n");
        return(-1);
    }

    if(r.r[0] != 0) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_auth_cert: FAILED with reason code %d ", r.r[0]);
        switch(r.r[0]) {
            case AUTH_ERROR_BAD_INPUT:
            	 DBUG_PRINTF(DBUG_LVL_ERROR, "BAD INPUT\n");
            	 break;
            case AUTH_ERROR_BAD_CERT:
            	 DBUG_PRINTF(DBUG_LVL_ERROR, "BAD CERT\n");
            	 break;
            case AUTH_ERROR_FAILED:
            	 DBUG_PRINTF(DBUG_LVL_ERROR, "FAILED\n");
            	 break;
          default:
                 DBUG_PRINTF(DBUG_LVL_ERROR, "\n");
        }

        return(-1);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_auth_cert: SUCCEEDED\n");
    return(1);
}

/* this fn takes the RAM certificate and hands it off to the browser for use in SSL connectioms */
void export_ram_certificate(void)
{
    _kernel_swi_regs r;
    int ssl_path_bytes;
    char *ssl_path, *ssl_path2;
    char cert_path[256];

    ssl_path = getenv(SSL_PATH_ENV_VAR);
    ssl_path_bytes = ssl_path?strlen(ssl_path):0;

    if(ssl_path_bytes == 0) { /* SSL path doesn't exist! */
       DBUG_PRINTF(DBUG_LVL_DIAG, "export_ram_certificate: no SSL$Path !\n");
       write_os_var(SSL_PATH_ENV_VAR, NCMA_CERTIFICATE_DIR, strlen(NCMA_CERTIFICATE_DIR));

    } else {/* SSL path does exist */
        DBUG_PRINTF(DBUG_LVL_DIAG, "export_ram_certificate: read %d bytes of SSLPath\n", ssl_path_bytes);

        if(strstr(ssl_path, NCMA_CERTIFICATE_DIR)==NULL) { /* we're not on the path, so add ourselves */
          if((ssl_path2 = malloc(ssl_path_bytes + strlen(NCMA_CERTIFICATE_DIR)+4))==NULL) {
              DBUG_PRINTF(DBUG_LVL_ERROR, "export_ram_certificate: no workspace to build path\n");
              return;
          }
          strcpy(ssl_path2, ssl_path);
          strcat(ssl_path2, "," NCMA_CERTIFICATE_DIR);
          write_os_var(SSL_PATH_ENV_VAR, ssl_path2, strlen(ssl_path2));
          free(ssl_path2);
        }
    }

    strncpy(cert_path, NCMA_CERTIFICATE_DIR, 256);
    DBUG_PRINTF(DBUG_LVL_DIAG, "export_ram_certificate: cert added to path \"%s\"\n", ssl_path);
    DBUG_PRINTF(DBUG_LVL_DIAG, "export_ram_certificate: writing cert to \"%s\"\n", cert_path);


    r.r[0] = (int)ram_cert_ptr;
    r.r[1] = ram_cert_bytes;
    r.r[2] = (int)cert_path;
    if(_kernel_swi(HTTP_ConvertToPEM, &r, &r)!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "export_ram_certificate: PEM conversion SWI failed\n");
    }

    else if(r.r[0] != 0) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "export_ram_certificate: PEM conversion returned error %d\n", r.r[0]);
    }

    else {
        DBUG_PRINTF(DBUG_LVL_DIAG, "export_ram_certificate: PEM conversion succeeded\n");
    }
    return;
}

void init_certificate_path(void)
{
    int ssl_path_bytes;
    char *ssl_path, *ssl_path2;
    char cert_path[256];

    ssl_path = getenv(SSL_PATH_ENV_VAR);
    ssl_path_bytes = ssl_path?strlen(ssl_path):0;

    if(ssl_path_bytes == 0) { /* SSL path doesn't exist! */
       DBUG_PRINTF(DBUG_LVL_DIAG, "init_certificate_path: no SSL$Path !\n");
       write_os_var(SSL_PATH_ENV_VAR, NCMA_ROOT_CERTIFICATE_DIR, strlen(NCMA_ROOT_CERTIFICATE_DIR));

    } else {/* SSL path does exist */
        DBUG_PRINTF(DBUG_LVL_DIAG, "init_certificate_path: read %d bytes of SSLPath\n", ssl_path_bytes);

        if(strstr(ssl_path, NCMA_ROOT_CERTIFICATE_DIR)==NULL) { /* we're not on the path, so add ourselves */
          if((ssl_path2 = malloc(ssl_path_bytes + strlen(NCMA_ROOT_CERTIFICATE_DIR)+4))==NULL) {
              DBUG_PRINTF(DBUG_LVL_ERROR, "init_certificate_path: no workspace to build path\n");
              return;
          }
          strcpy(ssl_path2, ssl_path);
          strcat(ssl_path2, "," NCMA_ROOT_CERTIFICATE_DIR);
          write_os_var(SSL_PATH_ENV_VAR, ssl_path2, strlen(ssl_path2));
          free(ssl_path2);
        }
    }

    strncpy(cert_path, NCMA_ROOT_CERTIFICATE_DIR, 256);
    DBUG_PRINTF(DBUG_LVL_DIAG, "export_ram_certificate: cert added to path \"%s\"\n", ssl_path);
    DBUG_PRINTF(DBUG_LVL_DIAG, "export_ram_certificate: writing cert to \"%s\"\n", cert_path);

    return;
}

