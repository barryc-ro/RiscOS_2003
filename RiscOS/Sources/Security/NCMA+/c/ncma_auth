/* ncma_auth - deal with MD5/RSA authentication for managed access */
#include <stdio.h>
#include "kernel.h"
#include "swis.h"
#define PROTOTYPES_INTERNAL
#include "ncma_auth.h"

#include "DBUG.h"

/* verify either against root or via intermediate certificate, if present */
int ncma_auth(unsigned char *a, unsigned int b, unsigned char *c, unsigned int d, unsigned char *e, unsigned int f)
{
    if((e != NULL) && (f != 0)) { /* certificate details present */
      return(ncma_auth_cert(a,b,c,d,e,f));
    }

    /* else use root public key */
    return(ncma_auth_root(a,b,c,d));
}

/* verify a message against the root (manufacturer) certificate */
int ncma_auth_root(unsigned char *msg, unsigned int mbytes, unsigned char *digest, unsigned int dbytes)
{
    _kernel_swi_regs r;

    r.r[0] = AUTH_FLAGS_KEY_DER;
    r.r[1] = (int)msg;
    r.r[2] = mbytes;
    r.r[3] = (int)digest;
    r.r[4] = dbytes;
    r.r[5] = (int)ncma_auth_root_certificate_name;
    r.r[6] = 0;
    r.r[7] = 0;
    if((_kernel_swi(HTTP_VerifyMessageDigest, &r, &r))!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_auth_root: HTTP_VerifyMD SWI failed\n");
        return(-1);
    }

    if(r.r[0] != 0) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_auth_root: FAILED with reason code %d ", r.r[0]);
        switch(r.r[0]) {
            case AUTH_ERROR_BAD_INPUT:
            	 DBUG_PRINTF(DBUG_LVL_ERROR, "BAD INPUT\n");
            	 break;
            case AUTH_ERROR_BAD_CERT:
            	 DBUG_PRINTF(DBUG_LVL_ERROR, "BAD CERT\n");
            	 break;
            case AUTH_ERROR_FAILED:
            	 DBUG_PRINTF(DBUG_LVL_ERROR, "FAILED\n");
            	 break;
          default:
                 DBUG_PRINTF(DBUG_LVL_ERROR, "\n");
        }
        return(-1);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_auth_root: SUCCEEDED\n");
    return(1);
}

/* verify a message against the root (manufacturer) certificate via an intermediate certificate
   so, auth path is:

   authenticate intermediate certificate with root certificate
   authenticate message with intermediate certificate

 */
int ncma_auth_cert(unsigned char *msg, unsigned int mbytes, unsigned char *digest, unsigned int dbytes,
    	           unsigned char *cert, unsigned int cbytes)
{
    _kernel_swi_regs r;

    r.r[0] = AUTH_FLAGS_KEY_DER | AUTH_FLAGS_CERT_DER | AUTH_FLAGS_CERT_INCORE;
    r.r[1] = (int)msg;
    r.r[2] = mbytes;
    r.r[3] = (int)digest;
    r.r[4] = dbytes;
    r.r[5] = (int)ncma_auth_root_certificate_name;
    r.r[6] = (int)cert;
    r.r[7] = cbytes;
    if((_kernel_swi(HTTP_VerifyMessageDigest, &r, &r))!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_auth_cert: HTTP_VerifyMD SWI failed\n");
        return(-1);
    }

    if(r.r[0] != 0) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ncma_auth_cert: FAILED with reason code %d ", r.r[0]);
        switch(r.r[0]) {
            case AUTH_ERROR_BAD_INPUT:
            	 DBUG_PRINTF(DBUG_LVL_ERROR, "BAD INPUT\n");
            	 break;
            case AUTH_ERROR_BAD_CERT:
            	 DBUG_PRINTF(DBUG_LVL_ERROR, "BAD CERT\n");
            	 break;
            case AUTH_ERROR_FAILED:
            	 DBUG_PRINTF(DBUG_LVL_ERROR, "FAILED\n");
            	 break;
          default:
                 DBUG_PRINTF(DBUG_LVL_ERROR, "\n");
        }

        return(-1);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_auth_cert: SUCCEEDED\n");
    return(1);
}
