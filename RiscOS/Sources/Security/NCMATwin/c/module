#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

/* includes for other segments */

#define PROTOTYPES_INTERNAL
#include "module.h"
#include "DBUG.h"
#include "machine.h"
#include "vectors.h"
#include "ncma_cmds.h"
#include "ncma_swis.h"
#include "ncma_ncma.h"
#include "ncma_scard.h"
#include "ncma_dial.h"
#include "dynalloc.h"
#include "ncma_url.h"
#ifndef TRAP_PPP_TIMEOUTS
#include "ncma_fx.h"
#endif

#include "VersionNum"
#include "header.h"

#include "cmhg_defs.h"
#include "DBUG.h"

#ifdef USE_TINY
static _kernel_oserror *TinyError;
#endif

/* code */
#if (CMHG_VERSION >= 516)
_kernel_oserror *module_init(const char *cmd_tail, int pbase, void *pw)
#else
_kernel_oserror *module_init(char *cmd_tail, int pbase, void *pw)
#endif
{
    _kernel_oserror f = {0x00810800, "NCMATwin failed to initialize."}, *e = NULL;
    _kernel_swi_regs r;
    static char keyword[] = "verbose/s,file/k,debug/k/e";

    static int args[32];
    char *argp, *debug_file;
    int debug_lvl = 0;

    module_wsp = pw;

#ifdef USE_TINY
  /*
   * try to use TinyStubs if possible.
   */
    r.r[0] = (int)module_wsp;
    TinyError = _kernel_swi(TinySupport_Share, &r, &r);
#endif

   r.r[0] = (int)keyword;
   r.r[1] = (int)cmd_tail;
   r.r[2] = (int)args;
   r.r[3] = 128;
   memset((char *)args, 0, 32 * sizeof(int));
   _kernel_swi(OS_ReadArgs, &r, &r);


   if(args[0]) quiet = 0;

   QUIET printf("RISC OS NC Managed Access Twin Version " Module_MajorVersion " " Module_MinorVersion "\n");

   if(args[1] != 0) debug_file = (char *)args[1];
   else debug_file = NULL;

   if(args[2]) { /* debug value present */
     argp = (char *)args[2];
     if(*argp++ == 0) {
       debug_lvl = *((int *)argp);
       if(debug_lvl <0) debug_lvl = 0;
       if(debug_lvl >5) debug_lvl = 5;
       if(debug_file == NULL) DBUG_FOPEN("stdout");
       else DBUG_FOPEN(debug_file);
       DBUG_LEVEL(debug_lvl);
       QUIET {
         printf("ncma_init: debug level set to %d\n", debug_lvl);
         if(debug_file != NULL) printf("ncma_init: debug file: %s\n", debug_file);
       }
     }
   }

   QUIET printf("ncma_init: initialising memory subsystem...\n");
   rminit();

   QUIET printf("ncma_init: registering resources...\n");
   resource_init();

   if(use_dynamic_areas) {
     QUIET printf("ncma_init: dynamic area support detected...\n");
   } else {
     QUIET printf("ncma_init: no dynamic area support found...\n");
   }

#if 0
    // events now enabled in module_sc_handler
   QUIET printf("ncma_init: claiming event vector...\n");
   e = module_claimv();
   if(e) {
     e = &f;
     goto out;
   }

   QUIET printf("ncma_init: enabling event...\n");
   e = module_event_enable();
   if(e) {
     e = &f;
     goto out;
   }
#endif

   QUIET printf("ncma_init: initialising ncma subsystem...\n");

   if(ncma_ncma_init()<0) {
     QUIET printf("ncma_init: ncma init failed.\n");
     e = &f;
     goto out;
   };


   ncma_state = State_NCMAInit;


   return ((_kernel_oserror *)0);

out:
   QUIET printf("ncma_init: Bummer!\n");
   return (e);
}


#if (CMHG_VERSION >= 516)
_kernel_oserror *module_cmd_handler(const char *arg_string, int argc, int cmd_no, void *pw)
#else
_kernel_oserror *module_cmd_handler(char *arg_string, int argc, int cmd_no, void *pw)
#endif
{
    struct cmdent *callp;
    int error;

    callp = &ncma_cmdent[cmd_no];
    error = (*(callp->cmd_call))(arg_string, argc);
    return((_kernel_oserror *)NULL);

}


_kernel_oserror *module_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    struct swient *callp;
    int error;

    callp = &ncma_ent[swinum];
    error = (*(callp->swi_call))(r);
    return((_kernel_oserror *)NULL);

}

void module_sc_handler(int sn, _kernel_swi_regs *r, void *pw)
{

  static int lock = 0;

  DBUG_PRINTF(DBUG_LVL_DIAG, "ncma: service call 0x%x reason code: 0x%x\n",sn,r->r[2]);
  switch(sn) {

    // respond to SCTransportStarting once only - purpose is to ignore events and svc calls
    // until sctrans is ready. We want to ignore all events, and any registry service calls
    // registry service calls from the bootblock module won't happen until SCTransStarting,
    // because it has the same code.
    // Other service calls are allowed through, because they can't happen until much later,
    // apart from Service_Standby, which we might see early, but if we do, we need to handle it.

    case Service_SCTransportStarting:
    	if(lock == 0) {
    	    lock = 1;
    	    module_claimv();
    	    module_event_enable();
    	}
    	break;

    case Service_NCDialUIStatus:
    	 switch(r->r[2]) {

             case 0x4: /* IP layer started */
	     	  ncma_trans = Trans_DialOK;
	     	  line_up = 1;
	     	  setcallback();
	     	  break;
	     case 0x0: /* broken */
	     case 0x81: /* no dial tone */
	     case 0x82: /* line busy */
	     case 0x83: /* no carrier */
	     case 0x84: /* server not responding */
	     case 0x85: /* timeout in script operation */
	     case 0x86: /* unspecified error */
	     	  ncma_trans = Trans_DialBad;
	     	  line_up = 0;
	     	  setcallback();
	     	  break;

    	     default:
    	     	  //DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_svc_handler: unrecognized NCDialUI status code 0x%x\n", r->r[2]);
    	     	  break;
    	 }

    	 break;

    case Service_DiallerStatus: /* we need to listen to the dialler for HUP signals */
    	 switch(r->r[2]) {

    	     case 0x0: /* IP down, line down */
    	       if(line_up) {
    	         ncma_dbox_close();
    	         ignore_ppp_timeout = 0;
    	         ncma_trans = Trans_HUP;
    	         line_up = 0;
    	         setcallback();
    	       }
    	     break;
    	 }
    	 break;

    case REGISTRY_STATUS:
  	  registry_status = r->r[2];
     	  registry_delta = r->r[4];
     	  ncma_trans = Trans_Registry;
     	  setcallback();
       	  break;

    case Service_Shutdown:
    	 if(prevent_shutdown == 1) {
    	    r->r[1] = 0; /* whoah, there, shutdown! */
    	    ncma_trans = Trans_Shutdown;
    	    setcallback();
    	 }
    	 break;

    case Service_ShutdownComplete:
    	 ncma_trans = Trans_ShutdownComplete;
    	 setcallback();
    	 break;

    case Service_Standby:
    	 if((r->r[0] & 1) == 0) { /* box waking up */
    	     ncma_trans = Trans_PowerUp;
    	     setcallback();
    	 }
    	 break;


    case Service_PPPTimingOut:
#ifdef TRAP_PPP_TIMEOUTS
         if(ignore_ppp_timeout) { /* don't claim */
#else
	   ncma_sound_effect(NCMA_TIMEOUT_SOUND);
#endif
           ignore_ppp_timeout = 0; /* reset ignore flag */
           ncma_dbox_close();
#ifdef TRAP_PPP_TIMEOUTS
         } else { /* claim svc call to prevent shutdown */
           r->r[1] = 0; /* claim it */
    	   ncma_trans = Trans_PPPTimeout;
    	   setcallback();
    	 }
#endif
    	 break;


    default:
         //DBUG_PRINTF(DBUG_LVL_DIAG, "ncma_svc_handler: unrecognized service call.\n");
         break;
  }
}


_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
#ifdef USE_TINY
  _kernel_swi_regs r;
  if ( TinyError == NULL ) _kernel_swi( TinySupport_Die, &r, &r);
#endif


  QUIET printf("ncma_final: cancelling timeouts...\n");
  canceltimeout();

  QUIET printf("ncma_final: releasing events...\n");
  module_event_disable();
  module_releasev();

  QUIET printf("ncma_final: releasing memory resources...\n");
  rmfree_all();

  QUIET printf("ncma_final: freeing resources...\n");
  resource_final();

  QUIET printf("ncma_final: done.\n");
  DBUG_FCLOSE();

  return((_kernel_oserror *)NULL);
}





