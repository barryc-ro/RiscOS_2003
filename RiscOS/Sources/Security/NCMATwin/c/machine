#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

#define PROTOTYPES_INTERNAL /* make prototypes and globals internal to this file */
#include "machine.h"
#include "module.h"
#include "ncma_ncma.h"
#include "ncma_scard.h"
#include "ncma_url.h"
#include "ncma_utils.h"
#include "ncma_dial.h"
#include "ncma_cache.h"
#include "ncma_bootb.h"
#include "ncma_net.h"
#include "ncma_funai.h"
#include "ncma_fx.h"
#include "vectors.h"

#include "DBUG.h"



char *trans_string(NCMA_TRANS trans)
{
  static char *t_table[] = {
    "Trans_Idle",
    "Trans_Timeout",
    "Trans_CardOK",
    "Trans_CardBad",
    "Trans_CardRemoved",
    "Trans_CompleteOK",
    "Trans_CompleteBad",
    "Trans_AuthFail",
    "Trans_URLRetry",
    "Trans_Registry",
    "Trans_Shutdown",
    "Trans_ShutdownComplete",
    "Trans_URLShutdown",
    "Trans_URLShutdownCancel",
    "Trans_URLChangePIN",
    "Trans_URLLeavePIN",
    "Trans_PowerUp",
    "Trans_DialOK",
    "Trans_DialBad",
    "Trans_URLMismatch",
    "Trans_URLMismatchAck",
    "Trans_NCMASurf",
#ifdef TRAP_PPP_TIMEOUTS
    "Trans_PPPTimeout",
#endif
    "Trans_DisconnectAck",
     "Trans_URLDisconnectNak",
     "Trans_HUP",
     "Trans_URLPinNAK",
     "Trans_PreConnect",
     "Trans_HangUp",
     "Trans_URLCardInserted",
     "Trans_URLCardRemoved",
     "Trans_URLCardRetry",
     "Trans_URLConnect",
     "Trans_URLStart",
     "Trans_URLConnectNak"
  };


  return(t_table[trans]);
}

char *state_string(NCMA_STATE state)
{
    static char *s_table[] = {
    "State_NCMAInit",
    "State_NCMAStart",
    "State_NCMAPanic",
    "State_NCMASleep",
    "State_NCMANoCard",
    "State_NCMABadCard",
    "State_NCMAPin",
    "State_NCMADefaultPIN",
    "State_NCMAApresPIN",
    "State_NCMADiallingISP",
    "State_NCMABadPin",
    "State_NCMAShutdown",
    "State_NCMAChangePIN",
    "State_NCMANewPIN",
    "State_NCMAMismatch",
    "State_NCMABooted",
    "State_NCMAConnect",
    "State_NCMAUpdatePIN",
    "State_NCMANeedPIN"

  };

  return(s_table[state]);
}

/* this is the NCMA ASM */
NCMA_STATE machine(NCMA_TRANS trans)
{

#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got transition %s in state %s\n", trans_string(trans), state_string(ncma_state));
#else
  if(trans != Trans_CompleteOK)
    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got transition %s in state %s\n", trans_string(trans), state_string(ncma_state));
#endif

/*********************************************************************************

    GLOBAL TRANSITIONS

 *********************************************************************************/

  switch(trans) { /* global transitions that apply to all states (except maybe State_Sleep) */

    case Trans_Shutdown:
         if(ncma_state != State_NCMAShutdown) { /* if we're not already in shutdown state, save context */
    	   pre_shutdown_state = ncma_state;
    	   DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: shutdown imminent - pushed state \"%s\"\n", state_string(ncma_state));
    	   ncma_standby_dbox_open(URL_PATH(poweroff.html));
    	   return(State_NCMAShutdown);
    	 }
    	 break;
#if 0
    case Trans_Registry: /* HACK - damn s/c layer doesn't always report Card_Removed */

         if(registry_status_cleared(BB_STATUS_INSERTED)) goto card_removed;
         break;
#endif

    case Trans_CardRemoved:
         //card_removed: UNCOMMENT ME IF CHANGING ABOVE #IF 0
    	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard removed, hanging up, flushing cache\n");
	 ncma_hangup();
	 ncma_dbox_close();
    	 reset_cache(); /* was unlock_cache() */
    	 options_mode = 0; // clear options screen lock-out
    	 force_pin = 0;

	if(ncma_started) {
                //ncma_dbox_open(URL_PATH(splash.html));
                //return(State_NCMANoCard);
#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif
	          return(State_NCMAInit);
        } else return(State_NCMAInit); /* sc layer kicks off with a card removed event */
        break;

    case Trans_URLCardInserted: // these states are only of interest to State_NCMAConnect and State_NCMABooted
    case Trans_URLCardRemoved: // so if we're not in that state, ignore, otherwise fall-thru
    	if((ncma_state != State_NCMAConnect) && (ncma_state != State_NCMABooted)) return(ncma_state);
    	break;

    default:
         break;
  }

  switch(ncma_state) {

/*********************************************************************************

    STATE_NCMAINIT

 *********************************************************************************/
    case State_NCMAInit:  /* start-up, pre WIMP stage */

         switch(trans) {
#if 0
// a candidate for removal, but I can't remember what it's for

	   case Trans_NCMASurf: /* we might wanna surf, but have removed the smartcard
	   			   thus we have to go through all the s/c and dial up crap,
	   			   and when it's finished remember that we want the Internet
	   			   home page, not the top level UI */
	   	//surf_again = 1;
	   	ncma_trans = Trans_URLStart;
	   	setcallback();
	   	return(State_NCMAInit);
	   	break;
#endif

           case Trans_HUP: /* HUP ack, we're displaying an error screen and waiting for retry */
                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got HUP, ignoring\n");
                return(State_NCMAInit);
                break;

	   case Trans_PowerUp:  /* and so, I awake... */
	   	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: POWERUP\n");

	   	if(!smartcard_present()) { /* powered up but no card? Fetch the blurb */
	   	    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: powered up, no smartcard. Fetching Welcome screen\n");

#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif
		  run_from_powerup = 0; // card_in_at_power_up = 0
	   	  return(State_NCMAInit);
	   	}

	   	/* otherwise, there's a card in, so fall through */
		run_from_powerup = 1; // card_in_at_power_up = 1
	   	/* \/ \/ \/ \/ \/ DELIBERATE FALL THRU \/ \/ \/ \/ \/ */

    	   case Trans_URLStart: // re-connection attempts come thru here
           case Trans_CardOK: // card inserted event

            	if(options_mode != 0) {
            	    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ignoring, because options mode is currently ON\n");
            	    return(State_NCMAInit);
            	}

            	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card inserted in slot 1 \n");

                ncma_started = 1;

                num_slots = find_slots();

                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: this is a %d slot system\n", num_slots);

	        /* read our status vars so smartcard checking works
	           (because we've no doubt missed a bunch of registry service calls */

	           registry_status = smartcard_status(NULL);
	           registry_delta = registry_status; /* assume everything set */

	   	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Managed access starting\n");
		if(!smartcard_present()) {
		    //DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no smartcard - fetching splash screen\n");
		    //ncma_dbox_open(URL_PATH(splash.html));
		    //return(State_NCMANoCard);
		    return(State_NCMAInit);
		}

		if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard - bailing\n");
		    ncma_dbox_open(URL_PATH(invalid.html));
		    return(State_NCMABadCard);
		}

    case Trans_Timeout: // timeout re-try entry for determining number of PIN attempts remaining

		if(smartcard_pin_protected()) {
		    card_attempts = smartcard_blocked();
		    if(card_attempts>0) {
       		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not blocked (%d), trying default PIN\n", card_attempts);
       		      default_pin(); // try the default PIN "00000000"
       		      return(State_NCMADefaultPIN);
		    } else if(card_attempts == 0) { // card_attempts == 0
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard is blocked\n");
		        ncma_dbox_open(URL_PATH(unblock.html));
		        return(State_NCMABadCard); // no unblocking mechanism on this NC!
		    } else { // card_attempts = -1, not ready
		    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: NCBBTwin not ready to return blocking info, timing out...\n");
		    	settimeout(1);
		    	return(State_NCMAInit);
		    }
		}

		proceed_after_pin: // callback entry point from State_NCMANoCard

                if(bootblock_read_succeeded()==0) { /* bootblock read ok, but not finished yet */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock (init)\n");
                  return(State_NCMANoCard);
                }

    	    	proceed_after_apres_pin: // callback entry point from State_NCMAApresPIN


                // AJS changed: read the bootblock here, because we need to know whether to offer
                // the user the option of changing the PIN...
                if(fetch_sc_bootblock() < 0) { // bootblock read was crap
                    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: failed to read bootblock\n");
                    ncma_dbox_open(URL_PATH(invalid.html));
                    return(State_NCMABadCard);
                }

                if(build_ram_cache() < 0) {
             	      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: failed to build RAM cache\n");
             	      ncma_dbox_open(URL_PATH(invalid.html));
             	      return(State_NCMABadCard);
             	}

                if(validate_funai_id_card() < 0) { // check bootblock looks ok
                    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: bootblock isn't formatted as Funai ID card\n");
                    ncma_dbox_open(URL_PATH(invalid.html));
                    return(State_NCMABadCard);
                }

                if(force_pin == 1) {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: forcing user to set PIN\n");
                    ncma_dbox_open(URL_PATH(needpin.html));
                    return(State_NCMANeedPIN);
                }

                proceed_after_force_pin: // callback entry point from State_NCMANeedPIN

                if(num_slots == 2) { // twin slot system
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: twin slot system - connect page has no CONNECT button\n");

    	    	    init_service_card(); // see if SVC card is already inserted

    	    	    switch(url_card_inserted) {
    	    	        case -1: // there's an invalid card already inserted
    	    	            	 // open badsvc dialogue, and open connect[BNP] dialogue underneath, proceed as if no card inserted
    	    	    	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: invalid card already inserted\n");
    	    	    	    ncma_dbox_open(URL_PATH(badsvc.html));
    	    	    	    // fall-thru to complete 'card not inserted' stuff

    	    	    	case 0: // no card inserted
    	    	    	    if(url_card_inserted == 0) DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: there is no card in slot 2\n"); // yuk
    	    	    	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: nothing of interest in slot 2\n");

    	    	    	    switch(user_config) { // decide which connect screen needs to be displayed
    	    	    	    	case USER_CONFIG_PIN: // can change PIN only
    	    	    	    	    ncma_url_open(URL_PATH(connectP.html));
    	    	    	    	    break;

    	    	    	    	case USER_CONFIG_CARD: // can change PIN and CARD details
    	    	    	    	    ncma_url_open(URL_PATH(connectB.html));
    	    	    	    	    break;

    	    	    	    	case USER_CONFIG_NONE: // can't change anything
    	    	    	    	default:
    	    	    	    	    ncma_url_open(URL_PATH(connectN.html));
    	    	    	    	    break;
    	    	    	    }
    	    	    	    return(State_NCMAConnect); // change state to connect phase
    	    	    	    break;

    	    	    	case 1: // valid card inserted - continue in connect phase
    	    	    	    ncma_trans = Trans_URLConnect;
    	    	    	    setcallback();
    	    	    	    return(State_NCMAConnect);
    	    	    	    break;

    	    	    	default:
    	    	    	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: bad value %d returned from init_service_card()\n",
    	    	    	    	url_card_inserted);
    	    	    	    break;
    	    	    } // endswitch url_card_inserted
    	    	} else { // endif num_slots == 2
    	    	    // there's only 1 slot, therefore the connect pages have to have 'connect' buttons to give
    	    	    // the user the chance to edit PIN and/or ISP details if applicable
    	    	    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: single slot system - connect page has CONNECT button\n");

    	    	    switch(user_config) { // decide which connect screen (if any) needs to be displayed
    	    	    	case USER_CONFIG_PIN: // can change PIN
    	    	    	    ncma_url_open(URL_PATH(connectSP.html));
    	    	    	    return(State_NCMAConnect);
    	    	    	    break;

    	    	    	case USER_CONFIG_CARD: // can change PIN and ISP stuff
    	    	    	    ncma_url_open(URL_PATH(connectSB.html));
    	    	    	    return(State_NCMAConnect);
    	    	    	    break;

    	    	    	case USER_CONFIG_NONE: // no edit privileges
    	    	    	default:
    	    	    	    // no screen - proceed immediately with connect phase
    	    	    	    ncma_trans = Trans_URLConnect;
    	    	    	    setcallback();
    	    	    	    return(State_NCMAConnect);
    	    	    } // endswitch user-config
    	    	} // endelse num_slots == 1

    } /* end state_ncmainit */
    break;


/*********************************************************************************

    +STATE_NCMACONNECT

 *********************************************************************************/
    case State_NCMAConnect:

    	 switch(trans) {

	     case Trans_URLChangePIN: /* the user clicked on 'change pin' */
	     	  ncma_dbox_open(URL_PATH(newpin.html));
	     	  return(State_NCMANewPIN);

             case Trans_PreConnect: /* byild tag cache without connecting, to allow ISPCapture to display current sc values */
    	    	  // don't need do to anything, as ram cache is built during state_ncmainit now
		 // SJM: copied stuff here from ncmainit as ISPCapture could have changed the values and then needs to read them back
                if(fetch_sc_bootblock() < 0) { // bootblock read was crap
                    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: failed to read bootblock\n");
                    ncma_dbox_open(URL_PATH(invalid.html));
                    return(State_NCMABadCard);
                }

                if(build_ram_cache() < 0) {
             	      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: failed to build RAM cache\n");
             	      ncma_dbox_open(URL_PATH(invalid.html));
             	      return(State_NCMABadCard);
             	}

                if(validate_funai_id_card() < 0) { // check bootblock looks ok
                    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: bootblock isn't formatted as Funai ID card\n");
                    ncma_dbox_open(URL_PATH(invalid.html));
                    return(State_NCMABadCard);
                }
             	  return(State_NCMAConnect);


	     case Trans_URLConnect: /* generated internally for a twin-slot box when the SVC card is inserted
	     	    	    	       generated by user-click on a 'connect' button on a single slot box ONLY */

    	    	  if(fetch_sc_bootblock() < 0) { // fetch again, in case changed by ISPCapture
    	    	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: failed to re-read bootblock\n");
    	    	      ncma_dbox_open(URL_PATH(invalid.html));
    	    	      return(State_NCMABadCard);
    	    	  }

      		  if(build_ram_cache()<0) { // build again - may have been altered by ISPCapture
      		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: insufficient connection details\n");
		      ncma_dbox_open(URL_PATH(invalid.html)); // was damaged.html
		      return(State_NCMABadCard);
      		  }

		  // used to be in State_NCMADiallingISP/Trans_DialOK
    	     	  ncma_network_init(NCMA_NET_RAM | NCMA_NET_POST_DIAL); /* set resolver variables */

      		  // dial based on connection details in bootblock
      		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: dialling from SC info...\n");
      		  if(ncma_dial()<0) {
      		      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: IAP dial initiation failed\n");
      		      ncma_dbox_close();
      		      ncma_url_open(URL_PATH(connect.html));
      		      return(State_NCMAConnect);
      		  }
		  else
		  {
		      /* Dial was successful, open the please wait screen */
		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Opening the please wait screen.\n");
		      ncma_url_open(URL_PATH(pleasewait.html));
		  }
		  
		  return(State_NCMADiallingISP);
                  break;

    	    case Trans_URLCardInserted: // second card inserted into slot 2
    	    	ncma_dbox_close();
    	    	init_service_card() ; // sets url_card_inserted

    	    	switch(url_card_inserted) {
    	    	    case -1: // bad card
    	    	    	DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: bad card in slot 2\n");
    	    	    	ncma_dbox_open(URL_PATH(badsvc.html));
    	    	    	return(State_NCMAConnect);

    	    	    case 0: // no card present - this shouldn't be possible
    	    	    	DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: Eh? got slot2 in event, but no card present - ignoring\n");
    	    	    	return(State_NCMAConnect);

    	    	    case 1: // card present
    	    	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card detected in slot 2\n");
    	    	    	ncma_trans = Trans_URLCardRetry; // callback to this state - gives the card a chance to settle
    	    	    	setcallback();
    	    	    	return(State_NCMAConnect);
    	    	}
    	    	break;

     	    case Trans_URLCardRemoved: // card 2 out, reset retries
      	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card 2 removed, waiting for re-insertion\n");
      	    	ncma_dbox_close();
      	    	slot2_retries = MAX_SLOT2_RETRIES;
      	    	return(State_NCMAConnect);
      	    	break;

    	    case Trans_URLCardRetry: // called from card 2 inserted above
    	    case Trans_Timeout: // called after 'not ready' error from card

    	    	switch(read_service_card()) { // attempt to read the 2nd smartcard, sets URL card inserted
	    	    case -1: // error
		    	DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: read service card FAILED\n");
    	    	    	ncma_dbox_open(URL_PATH(badsvc.html));
    	    	    	return(State_NCMAConnect);

	    	    case -2: // not ready
	    	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading slot2 - timing out\n");
		    	settimeout(1);
		    	return(State_NCMAConnect);

	    	    default: // got the data
	    	    	ncma_trans = Trans_URLConnect; // re-enter state & connect
	    	    	setcallback();
		    	return(State_NCMAConnect);
	    	}
	    	break;

         } /* end state_ncmaconnect */
         break;


/*********************************************************************************

    STATE_NCMADIALLINGISP

 *********************************************************************************/
    case State_NCMADiallingISP:

    	 switch(trans) {

    	     case Trans_DialBad: /* Don't know what to do here! Not in the CIS!! */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ISP dial failed - bummer\n");
    	     	  ncma_dbox_close();
    	     	  ncma_url_open(URL_PATH(connect.html));
    	     	  return(State_NCMAConnect);
    	     	  break;

    	     case Trans_DialOK: /* dial succeeded */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ISP dial succeeded\n");

#ifdef DEBUG_DISCONNECT
       		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: DEBUG_DISCONNECT setting line drop timeout\n");
       		  set_ppp_timeout();
#endif

		  /* moved to just before ncma_dial() */
    	     	  /* ncma_network_init(NCMA_NET_RAM | NCMA_NET_POST_DIAL); set resolver variables */

      	     	  ncma_url_user();

    	     	  return(State_NCMABooted);
 		  break;
 	 } /* end state_ncmadiallingisp */
 	 break;

/*********************************************************************************

    +STATE_NCMABOOTED

 *********************************************************************************/
    case State_NCMABooted:

    	 switch(trans) {

    	     case Trans_NCMASurf:
		  ncma_url_user();	/* this can happen when the user presses home - just let it fail if it must */
    	     	  return(State_NCMABooted);

#ifdef TRAP_PPP_TIMEOUTS
	     case Trans_PPPTimeout:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PPP timeout event received\n");
	     	  ignore_ppp_timeout = 1; /* next time, don't claim svc call, just let it happen */
	     	  set_ppp_timeout(); /* set short timeout for drop, in case user has dozed off */
	     	  ncma_sound_effect(NCMA_TIMEOUT_SOUND);
	     	  ncma_dbox_close();
	     	  ncma_dbox_open(URL_PATH(disconnect.html));
	     	  return(State_NCMABooted);
#endif

	     case Trans_URLDisconnectAck: /* user wants to disconnect now */
	     	  ignore_ppp_timeout = 0; /* tell svc handler to block next timeout & notify us */
	     	  ncma_dbox_close();
	     	  ncma_hangup();
	     	  return(State_NCMABooted);

	     case Trans_URLDisconnectNak: /* user wants to carry on */
	     	  ignore_ppp_timeout = 0; /* tell svc handler to block next timeout & notify us */
	     	  set_ppp_timeout_long(); /* do the long timeout */
	     	  ncma_dbox_close();
	     	  return(State_NCMABooted);

	     case Trans_HUP: /* we've lost our connection */

#ifdef SILENT_HUP
       		  /* no special action - rely on browser to bring the line back up
       		     note that this might be thru a ref. to NCFresco$Home, which is
       		     a macro which evaluates to ncma:userhome, which fires Trans_NCMASurf,
       		     which calls the browser (first trans above) which brings the line
       		     up. :) */
       		  return(State_NCMABooted);
#else
		  /* alternatively, bung the 'connect to isp' screen up and do all that pallaver */
       		  ncma_url_open(URL_PATH(connect.html));
	     	  return(State_NCMAConnect);
#endif

	     case Trans_URLConnect: // Added by SJM - refer to Docs.BocaChanges
	     	  ncma_dbox_close();
		  ncma_url_open(BAD_URL_URL);
	     	  return(State_NCMABooted);

	     case Trans_URLConnectNak: // Added by SJM - refer to Docs.BocaChanges
		  ncma_hangup();
	     	  ncma_dbox_close();
		  ncma_url_open(WELCOME_SCREEN_URL);
     		  run_from_powerup = 0;
             	  return(State_NCMAInit);

	     case Trans_HangUp: // Added by SJM - refer to Docs.BocaChanges
		  ncma_hangup();
	     	  ncma_dbox_close();

    	    	  // modified by AJS - multiple connect.html options, depending on num_slots, editability,
    	    	  // whether the SERVICE card is already in or not &c &c

    	    	  goto proceed_after_force_pin;	// continue in init state

		  //ncma_url_open(URL_PATH(connect.html));
		  //return(State_NCMAConnect);

             case Trans_PreConnect: /* called by ISPCapture to ensure smartcard details are read */
		  ncma_hangup();
             	  return(State_NCMAConnect);

    	    // NEW STUFF to handle re-insertion of a SVC/URL card while in booted state
    	    // basically, ignore card-outs, but on a valid card-in, fetch the SVC/URL card's URL regardless

    	    case Trans_URLCardInserted: // second card inserted into slot 2
    	    	ncma_dbox_close();
    	    	init_service_card() ; // sets url_card_inserted

    	    	switch(url_card_inserted) {
    	    	    case -1: // bad card
    	    	    	DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: bad card in slot 2, ignoring it\n");
    	    	    	return(State_NCMABooted);

    	    	    case 0: // no card present - this shouldn't be possible
    	    	    	DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: Eh? got slot2 in event, but no card present - ignoring\n");
    	    	    	return(State_NCMABooted);

    	    	    case 1: // card present
    	    	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card detected in slot 2\n");
    	    	    	ncma_trans = Trans_URLCardRetry; // callback to this state - gives the card a chance to settle
    	    	    	setcallback();
    	    	    	return(State_NCMABooted);
    	    	}
    	    	break;

     	    case Trans_URLCardRemoved: // card 2 out, reset retries
      	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card 2 removed, but this state doesn't care\n");
      	    	ncma_dbox_close();
      	    	slot2_retries = MAX_SLOT2_RETRIES;
      	    	return(State_NCMABooted);
      	    	break;

    	    case Trans_URLCardRetry: // called from card 2 inserted above
    	    case Trans_Timeout: // called after 'not ready' error from card

    	    	switch(read_service_card()) { // attempt to read the 2nd smartcard, sets URL card inserted
	    	    case -1: // error
		    	DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: read service card FAILED, ignoring it\n");
    	    	    	return(State_NCMABooted);

	    	    case -2: // not ready
	    	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading slot2 - timing out\n");
		    	settimeout(1);
		    	return(State_NCMABooted);

	    	    default: // got the data
	    	    	ncma_trans = Trans_URLConnect; // re-enter state & connect
    	    	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: new SERVICE card info read...fetching\n");
    	    	    	ncma_url_user();
		    	return(State_NCMABooted);
	    	}
	    	break;

    	 } /* end state_ncmabooted */
    	 break;


 /*********************************************************************************

    +STATE_NCMASHUTDOWN

 *********************************************************************************/
    case State_NCMAShutdown:

         switch(trans) {

             case Trans_URLShutdown:
             case Trans_Shutdown:
                  prevent_shutdown = 0;
                  shutdown_nc();
                  ncma_standby_dbox_close(); /* close my dbox */
                  ncma_dbox_close(); /* close any other dbox. Yuck. */
                  ncma_url_open(BLANK_SCREEN_URL);
                  return(State_NCMAShutdown);
                  break;

             case Trans_URLShutdownCancel:
                  ncma_standby_dbox_close();
             	  return(pre_shutdown_state);
             	  break;

             case Trans_ShutdownComplete:
             	  prevent_shutdown = 1;
             	  if(ui_present()) prod_browser_after_standby();
             	  return(State_NCMAInit);
             	  break;
         } /* end state_ncmashutdown */
         break;


/*********************************************************************************

    STATE_NCMADEFAULTPIN : we've just attempted the default Funai PIN "00000000"

 *********************************************************************************/
    case State_NCMADefaultPIN:

    	 switch(trans) {
	     case Trans_AuthFail: /* default PIN failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure for default PIN (auth)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad DEFAULT PIN: %d attempts left\n", card_attempts);
	     	    update_pin();
	     	    return(State_NCMAUpdatePIN);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open(URL_PATH(unblock.html));
	     	    return(State_NCMABadCard);
	     	  }
	     	  break;

    	     case Trans_Registry: /* test status of default PIN transaction */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

#if 0
	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: DEFAULT PIN failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad DEFAULT PIN: %d attempts left\n", card_attempts);
	                update_pin();
	     	        return(State_NCMAUpdatePIN);
	     	      } else {
	     	        DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	        ncma_dbox_open(URL_PATH(unblock.html));
	     	        return(State_NCMABadCard);
	     	      }
	     	      break;


	     	  }
#endif
		  /* default PIN succeeded */
	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: DEFAULT PIN succeeded\n");
                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

       		      ncma_trans = Trans_Registry; /* cue one up */
       		      setcallback();

       		      return(State_NCMAApresPIN);

	          }


    	 } /* end state_ncmadefaultpin */
    	 break;


/*********************************************************************************

    STATE_NCMAUPDATEPIN : we've just attempted the update Funai PIN "99999999"

 *********************************************************************************/
    case State_NCMAUpdatePIN:

    	 switch(trans) {
	     case Trans_AuthFail: /* update PIN failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure for update PIN (auth)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad UPDATE PIN: %d attempts left\n", card_attempts);
	     	    ncma_dbox_open(URL_PATH(pin.html));
	     	    return(State_NCMAPin);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open(URL_PATH(unblock.html));
	     	    return(State_NCMABadCard);
	     	  }
	     	  break;

    	     case Trans_Registry: /* test status of update PIN transaction */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
#if 0
	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: UPDATE PIN failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad UPDATE PIN: %d attempts left\n", card_attempts);
	     	        ncma_dbox_open(URL_PATH(pin.html));
	     	        return(State_NCMAPin);
	     	      } else {
	     	        ncma_dbox_open(URL_PATH(unblock.html));
	     	        return(State_NCMABadCard);
	     	      }
	     	      break;


	     	  }
#endif
		  /* update PIN succeeded */
	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: UPDATE PIN succeeded, prompting for new PIN\n");
                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

    	    	      //ncma_dbox_open(URL_PATH(needpin.html));
    	    	      //return(State_NCMANewPIN);
      		      ncma_trans = Trans_Registry; /* cue one up */
       		      setcallback();
    	    	      force_pin = 1;
       		      return(State_NCMAApresPIN);

	          }


    	 } /* end state_ncmadefaultpin */
    	 break;



/*********************************************************************************

    +STATE_NCMAPIN

 *********************************************************************************/
    case State_NCMAPin:

    	 switch(trans) {

	     case Trans_CardOK:
	     	  return(State_NCMAPin);
	     	  break;

	     case Trans_URLPinNAK:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: user cancelled PIN entry\n");
	     	  ncma_dbox_close();
#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif

		  return(State_NCMAInit);
	     	  //ncma_dbox_open(URL_PATH(splash.html));
	     	  //return(State_NCMANoCard);
	     	  break;

	     case Trans_AuthFail: /* the user entered a pin, but it failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure (authfail)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	    ncma_dbox_open(URL_PATH(badpin.html));
	     	    return(State_NCMABadPin);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open(URL_PATH(unblock.html));
	     	    return(State_NCMABadCard);
	     	  }
	     	  break;

    	     case Trans_Registry: /* the user entered a pin, maybe it worked, maybe it didn't */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
#if 0
	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	        ncma_dbox_open(URL_PATH(badpin.html));
	     	        return(State_NCMABadPin);
	     	      } else {
	     	        ncma_dbox_open(URL_PATH(unblock.html));
	     	        return(State_NCMABadCard);
	     	      }
	     	      break;


	     	  }
#endif
	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");
                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

    	    	      ncma_dbox_close();
       		      ncma_trans = Trans_Registry; /* cue one up */
       		      setcallback();

       		      return(State_NCMAApresPIN);
	          }


    	 } /* end state_ncmapin */
    	 break;


/*********************************************************************************

    STATE_NCMAAPRESPIN wait for registry completion on bootblock read after user PIN entry

 *********************************************************************************/
    case State_NCMAApresPIN:

         switch(trans) {

             case Trans_Registry:
                if(bootblock_read_succeeded()==0) { /* bootblock read ok, but not finished yet */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock (after pin)\n");
                  return(State_NCMAApresPIN);
                } else {
                    goto proceed_after_apres_pin;
                }
                break;




 	 }
	 break;



/*********************************************************************************

    STATE_NCMABADPIN

 *********************************************************************************/
    case State_NCMABadPin:

         switch(trans) {

	     case Trans_CardOK:
	     	  return(State_NCMABadPin);
	     	  break;

             case Trans_URLRetry:
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: getting ready for another go\n");
             	  //ncma_url_open("file:/ncma:pin.html");
             	  ncma_dbox_open(URL_PATH(pin.html));
             	  return(State_NCMAPin);
         } /* end state_ncmabadpin */
         break;


/*********************************************************************************

    STATE_NCMANEWPIN

 *********************************************************************************/
    case State_NCMANewPIN:

    	 switch(trans) {

	     case Trans_AuthFail: /* failed setting PIN */ /* this shouldn't happen */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failure\n");
	     	  ncma_dbox_open(URL_PATH(newpin.html));
	     	  return(State_NCMANewPIN);

	     	  break;

	     case Trans_URLMismatch: /* the two PINs the user entered didn't match */
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: fetching PIN mismatch page\n");
	     	  ncma_dbox_open(URL_PATH(mismatch.html));
	     	  return(State_NCMAMismatch);
	     	  break;

	     case Trans_URLLeavePIN: /* a cancel on the change pin OSD */
	     	    ncma_dbox_close();
	     	    return(State_NCMAConnect);
    	    	    break;

    	     case Trans_Registry: /* PIN set status from registry */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
#if 0
	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failed\n"); /* this shouldn't happen */
	     	      ncma_dbox_open(URL_PATH(newpin.html));
	     	      return(State_NCMANewPIN);
	     	  }
#endif
	     	  if(registry_status_asserted(BB_STATUS_BB_VALID) || registry_status_cleared(BB_STATUS_LOCKED) ||
	     	  		registry_status_cleared(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");

                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;
		      ncma_dbox_close();

    	    	      return(State_NCMAConnect);

	     	  }
    	 }
    	 break;

/*********************************************************************************

    STATE_NCMANEEDPIN

 *********************************************************************************/
    case State_NCMANeedPIN:

    	 switch(trans) {

	     case Trans_AuthFail: /* failed setting PIN */ /* this shouldn't happen */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failure\n");
	     	  ncma_dbox_open(URL_PATH(needpin.html));
	     	  return(State_NCMANeedPIN);

	     	  break;

	     case Trans_URLMismatch: /* the two PINs the user entered didn't match */
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: fetching PIN mismatch page\n");
	     	  ncma_dbox_open(URL_PATH(mismatch.html));
	     	  return(State_NCMANeedPIN);
	     	  break;

	     case Trans_URLMismatchAck:
	     	  ncma_dbox_open(URL_PATH(needpin.html));
	     	  return(State_NCMANeedPIN);

    	     case Trans_Registry: /* PIN set status from registry */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
#if 0
	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failed\n"); /* this shouldn't happen */
	     	      ncma_dbox_open(URL_PATH(needpin.html));
	     	      return(State_NCMANeedPIN);
	     	  }
#endif
	     	  if(registry_status_asserted(BB_STATUS_BB_VALID) || registry_status_cleared(BB_STATUS_LOCKED) ||
	     	  		registry_status_cleared(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");

                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;
		      ncma_dbox_close();

    	    	      force_pin = 0;
    	    	      goto proceed_after_force_pin;

	     	  }
    	 }
    	 break;

/*********************************************************************************

    STATE_NCMAMISMATCH

 *********************************************************************************/
    case State_NCMAMismatch:

    	 switch(trans) {

    	     case Trans_URLMismatchAck:
    	     	  ncma_dbox_open(URL_PATH(newpin.html));
    	     	  return(State_NCMANewPIN);
    	     	  break;
    	 }
    	 break;

/*********************************************************************************

    STATE_NCMABADCARD

 *********************************************************************************/
    case State_NCMABadCard: /* waiting for URL/CLI call */

    	 switch(trans) {
    	     case Trans_CardRemoved: /* user has removed bad card */

    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard removed\n");
    	     	  ncma_dbox_open(URL_PATH(splash.html));
    	     	  return(State_NCMANoCard);

    	 } /* end state_ncmabadcard */

    	 break;

/*********************************************************************************

    +STATE_NCMANOCARD

 *********************************************************************************/
    case State_NCMANoCard: /* waiting for a smartcard to be inserted */

         switch(trans) {
	    case Trans_CardOK:
	         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card_ok event - clearing status delta register\n");
	         smartcard_status(NULL);
	    	 return(State_NCMANoCard);


            case Trans_Registry: /* card activity */

		if(!smartcard_present()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading PIN status (no card)\n");
		    return(State_NCMANoCard);
		}

		if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: invalid smartcard\n");
		    ncma_dbox_open(URL_PATH(invalid.html));
		    return(State_NCMABadCard);
		}

	    	if(smartcard_pin_protected()) {
	    	    card_attempts = smartcard_blocked();
	    	    if(card_attempts>0) {
       		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not blocked (%d), trying defalt PIN\n", card_attempts);
       		      default_pin(); // try the default PIN "00000000"
       		      return(State_NCMADefaultPIN);
		    } else if(card_attempts == 0) {
		      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard is blocked\n");
		      ncma_dbox_open(URL_PATH(unblock.html));
		      return(State_NCMABadCard); // no unblock mechanism on this NC
		    } else {
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock PIN info\n");
		        return(State_NCMANoCard);
		    }
		}


                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
                if(bootblock_read_failed()) {
                     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bootblock read failed\n");
                     ncma_dbox_open(URL_PATH(invalid.html)); // was damaged.html
                     return(State_NCMABadCard);
                }


		goto proceed_after_pin;

		break;

            case Trans_CardBad: /* bad card */

            	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bad card re-inserted\n");
            	 ncma_dbox_open(URL_PATH(invalid.html)); // was damaged.html
            	 return(State_NCMABadCard);
         } /* end state_ncmanocard */
         break;




/*********************************************************************************

    STATE_NCMAPANIC

 *********************************************************************************/
    case State_NCMAPanic:
    default:

	 DBUG_PRINTF(DBUG_LVL_PANIC, "NCMA_machine: PANIC!\n");
	 return(State_NCMAPanic);

  } /* end switch STATE */

  if(trans == Trans_Registry) {
#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: sweet nothings from the registry\n");
#endif
      return(ncma_state);
  }

  if((trans == Trans_CompleteOK) || (trans == Trans_CompleteBad) || (trans == Trans_AuthFail)) {
#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
    DBUG_PRINTF(DBUG_LVL_DEBUG, "NCMA: spurious I/O ACK from smartcard driver...ignoring\n");
#endif
    return(ncma_state);
  }

  /* otherwise . . . PANIC!! */

  DBUG_PRINTF(DBUG_LVL_PANIC, "NCMA: state machine panic - invalid transition event %s in state %s\n",
  		      trans_string(ncma_trans), state_string(ncma_state));

#ifdef ABORT_ON_PANIC
  DBUG_PRINTF(DBUG_LVL_PANIC, "            setting state to State_Panic\n");
  return(State_NCMAPanic);
#else
  return(ncma_state);
#endif
}
