#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

#define PROTOTYPES_INTERNAL /* make prototypes and globals internal to this file */
#include "machine.h"
#include "module.h"
#include "ncma_ncma.h"
#include "ncma_scard.h"
#include "ncma_url.h"
#include "ncma_utils.h"
#include "ncma_dial.h"
#include "smtagsCCIJ.h"
#include "ncma_bootb.h"
#include "ncma_net.h"
#include "ncma_funai.h"
#include "ncma_fx.h"
#include "vectors.h"
#include "init.h"

#include "DBUG.h"



char *trans_string(NCMA_TRANS trans)
{
  static char *t_table[] = {
    "Trans_Idle",
    "Trans_Timeout",
    "Trans_CardOK",
    "Trans_CardBad",
    "Trans_CardRemoved",
    "Trans_CompleteOK",
    "Trans_CompleteBad",
    "Trans_AuthFail",
    "Trans_URLStart",
    "Trans_URLRetry",
    "Trans_Registry",
    "Trans_Shutdown",
    "Trans_ShutdownComplete",
    "Trans_URLShutdown",
    "Trans_URLShutdownCancel",
    "Trans_URLUnblock",
    "Trans_URLChangePIN",
    "Trans_URLLeavePIN",
    "Trans_PowerUp",
    "Trans_DialOK",
    "Trans_DialBad",
    "Trans_URLMismatch",
    "Trans_URLMismatchAck",
    "Trans_NCMASurf",
    "Trans_URLDownloadMin",
    "Trans_URLDownloadMax",
    "Trans_URLDownloadSched",
    "Trans_URLDownloadNak",
    "Trans_URLConnect",
    "Trans_URLConnectNak",
    "Trans_MIMEOk",
    "Trans_MIMEBad",
    "Trans_URLDisconnectAck",
    "Trans_URLDisconnectNak",
    "Trans_HUP",
    "Trans_URLPinNAK",
    "Trans_PreConnect",
    "Trans_NCMADialUI_Start",
    "Trans_BadCardNak",
    "Trans_Logout",
    "Trans_LogoutAck",
    "Trans_LogoutNak",
    "Trans_HangUp",
    "Trans_NCDialUI_Cancel",
    "Trans_URLCardInserted", // Funai slot 2 smartcard inserted
    "Trans_URLCardRemoved", // Funai slot 2 smartcard removed
    "Trans_URLCardRetry", // retry a read on slot 2
    "Trans_CardBroken",
#ifdef TRAP_PPP_TIMEOUTS
    "Trans_PPPTimeout",
#endif
#ifdef SC_SWAPPING
    "Trans_WrongISPCard",
#endif /* SC_SWAPPING */
#ifdef EMAIL_CLIENT
    "Trans_NCMAEnterEmailSelectUserOffline",
    "Trans_NCMAEnterEmailSelectUserOnline",
    "Trans_NCMAEmailSelectUserAck",
    "Trans_NCMAEmailSelectUserNak",
#endif /* EMAIL_CLIENT */
    "Trans_URLCardBroken"
  };


  return(t_table[trans]);
}

char *state_string(NCMA_STATE state)
{
    static char *s_table[] = {
    "State_NCMAInit",
    "State_NCMAStart",
    "State_NCMASleep",
    "State_NCMANoCard",
    "State_NCMABadCard",
    "State_NCMAPin",
    "State_NCMADefaultPIN",
    "State_NCMAApresPIN",
    "State_NCMADiallingISP",
    "State_NCMABadPin",
    "State_NCMAShutdown",
    "State_NCMAChangePIN",
    "State_NCMANewPIN",
    "State_NCMAMismatch",
    "State_NCMABooted",
    "State_NCMAConnect",
    "State_NCMAUpdatePIN",
    "State_NCMANeedPIN",

    "State_NCMAPanic",
    "State_NCMAUnblock",
    "State_NCMADownload",
    "State_NCMABadUnblockPIN",
#ifdef SC_SWAPPING
    "State_NCMAWrongISPCard",
#endif /* SC_SWAPPING */
#ifdef EMAIL_CLIENT
    "State_NCMAEmailSelectUser",
#endif /* EMAIL_CLIENT */
    "State_NCMALogout"
  };
  return(s_table[state]);
}




/* This routine initialises all variables to do with smartcard swapping and
    the email client. It is used at the beginning of a session, i.e. at
    initialisation and after a standby/logoff sequence. */
void initialise_variables(void)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "initialise_variables().\n");
  /* Reinitialise all data */
  bNoScreenChanges = false; /* Screen changes are allowed */
  bRedialRequested = false; /* No redial has been requested */
#ifdef SC_SWAPPING
  bCardVerified = false;    /* Card is intially unverified */
  uiPreviousState = State_NCMAInit;
  tidy_memory();
#ifdef EMAIL_CLIENT
  uiemail_client_state = email_state_none; /* Reset email client state */
#endif /* EMAIL_CLIENT */
#endif /* SC_SWAPPING */

  /* Ensure that the post_initialisation() routine has been run - it may not have been if the module was soft-loaded */
  if (!post_initialisation_run)
  {
    post_initialisation();
    post_initialisation_run = true;
  }
}



/* this is the NCMA ASM */
NCMA_STATE machine(NCMA_TRANS trans)
{

#ifdef SHOW_BOOTBLOCK_TRANSACTIONS
  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got transition %s in state %s\n", trans_string(trans), state_string(ncma_state));
#else
  if(trans != Trans_CompleteOK)
    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got transition %s in state %s\n", trans_string(trans), state_string(ncma_state));
#endif

/*********************************************************************************

    GLOBAL TRANSITIONS

 *********************************************************************************/

  switch(trans) { /* global transitions that apply to all states (except maybe State_Sleep) */

    case Trans_Shutdown:
         if(ncma_state != State_NCMAShutdown) { /* if we're not already in shutdown state, save context */
    	   pre_shutdown_state = ncma_state;
    	   DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: shutdown imminent - pushed state \"%s\"\n", state_string(ncma_state));
    	   ncma_standby_dbox_open(URL_PATH(poweroff.html));
    	   return(State_NCMAShutdown);
    	 }
    	 break;
#if 0
    case Trans_Registry: /* HACK - damn s/c layer doesn't always report Card_Removed */

         if(registry_status_cleared(BB_STATUS_INSERTED)) goto card_removed;
         break;
#endif

    case Trans_CardRemoved:
	//card_removed: UNCOMMENT ME IF CHANGING ABOVE #IF 0

	/* 5Jan98 SJM This comes around whilst in stutdown process so
           we need to ignore some of it or it upsets the handling of
           ShutdownComplete */

	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard removed, flushing cache, maybe hanging up\n");

	reset_cache(); /* was unlock_cache() */
	options_mode = 0; // clear options screen lock-out
	force_pin = 0;

	if (ncma_state == State_NCMAShutdown)
	{
	    return State_NCMAShutdown;
	}
	else
	{
	    ncma_hangup();

	    /* close all the dboxes */
	    ncma_dialler_dbox_close();
	    ncma_dbox_close();
	    ncma_dbox2_close();

	    if (ncma_started)
	    {
		//ncma_dbox_open(URL_PATH(splash.html));
		//return(State_NCMANoCard);
#ifdef LOCAL_URL_PATHS
		ncma_url_open(URL_PATH(welcome.html));
#else
		ncma_url_open(WELCOME_SCREEN_URL);
#endif
		return(State_NCMAInit);
	    }
	    else
	    {
		return(State_NCMAInit); /* sc layer kicks off with a card removed event */
	    }
	}
	break;

	/* SJM 14Dec98: triggered from SCI_BADINSERTx event from
           SCTrans. Means a non-smartcard has been inserted in the
           slot (eg upside down) */
  case Trans_CardBroken:
      if (ncma_state != State_NCMAShutdown)
	  ncma_dbox_open(URL_PATH(SCprobs.html));
      return (ncma_state);

  case Trans_URLCardBroken:
      if (ncma_state != State_NCMAShutdown)
	  ncma_dbox2_open(URL_PATH(SCprobs.html));
      return (ncma_state);

      /* this globally removes any card dbox. It also, in certain
         states, drops though to the main state machine to perform
         suitable other functions. */
  case Trans_URLCardRemoved:
      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card 2 removed, clear any dbox2\n");
      ncma_dbox2_close();
      slot2_retries = MAX_SLOT2_RETRIES;
#ifdef MUST_HAVE_URL_CARD
      if (ncma_state != State_NCMADiallingISP && ncma_state != State_NCMABooted)
#endif
	  return ncma_state;
      break;

  default:
      break;
  }

  switch(ncma_state) {

/*********************************************************************************

    STATE_NCMAINIT

 *********************************************************************************/
    case State_NCMAInit:  /* start-up, pre WIMP stage */

         switch(trans) {
#if 0
// a candidate for removal, but I can't remember what it's for

	   case Trans_NCMASurf: /* we might wanna surf, but have removed the smartcard
	   			   thus we have to go through all the s/c and dial up crap,
	   			   and when it's finished remember that we want the Internet
	   			   home page, not the top level UI */
	   	//surf_again = 1;
	   	ncma_trans = Trans_URLStart;
	   	setcallback();
	   	return(State_NCMAInit);
	   	break;
#endif

           case Trans_HUP: /* HUP ack, we're displaying an error screen and waiting for retry */
                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: got HUP, ignoring\n");
                return(State_NCMAInit);
                break;

	   case Trans_PowerUp:  /* and so, I awake... */
	   	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: POWERUP\n");

	   	if(!smartcard_present()) { /* powered up but no card? Fetch the blurb */
	   	    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: powered up, no smartcard. Fetching Welcome screen\n");

#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif
		  run_from_powerup = 0; // card_in_at_power_up = 0
	   	  return(State_NCMAInit);
	   	}

	   	/* otherwise, there's a card in, so fall through */
		run_from_powerup = 1; // card_in_at_power_up = 1
	   	/* \/ \/ \/ \/ \/ DELIBERATE FALL THRU \/ \/ \/ \/ \/ */

    	   case Trans_URLStart: // re-connection attempts come thru here
           case Trans_CardOK: // card inserted event

            	if(options_mode != 0) {
            	    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ignoring, because options mode is currently ON\n");
            	    return(State_NCMAInit);
            	}

            	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card inserted in slot 1 \n");

                ncma_started = true;
                initialise_variables();

                num_slots = find_slots();

                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: this is a %d slot system\n", num_slots);

	        /* read our status vars so smartcard checking works
	           (because we've no doubt missed a bunch of registry service calls */

	           registry_status = smartcard_status(NULL);
	           registry_delta = registry_status; /* assume everything set */

	   	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Managed access starting\n");
		if(!smartcard_present()) {
		    //DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: no smartcard - fetching splash screen\n");
		    //ncma_dbox_open(URL_PATH(splash.html));
		    //return(State_NCMANoCard);
		    return(State_NCMAInit);
		}

		if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard - bailing\n");
		    ncma_dbox_open(URL_PATH(invalid.html));
		    return(State_NCMABadCard);
		}

    case Trans_Timeout: // timeout re-try entry for determining number of PIN attempts remaining

		if(smartcard_pin_protected()) {
		    card_attempts = smartcard_blocked();
		    if(card_attempts>0) {
       		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not blocked (%d), trying default PIN\n", card_attempts);
       		      default_pin(); // try the default PIN "00000000"
       		      return(State_NCMADefaultPIN);
		    } else if(card_attempts == 0) { // card_attempts == 0
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: smartcard is blocked\n");
		        ncma_dbox_open(URL_PATH(unblock.html));
		        return(State_NCMABadCard); // no unblocking mechanism on this NC!
		    } else { // card_attempts = -1, not ready
		    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: NCBBTwin not ready to return blocking info, timing out...\n");
		    	settimeout(1);
		    	return(State_NCMAInit);
		    }
		}

		proceed_after_pin: // callback entry point from State_NCMANoCard

                if(bootblock_read_succeeded()==0) { /* bootblock read ok, but not finished yet */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock (init)\n");
                  return(State_NCMANoCard);
                }

    	    	proceed_after_apres_pin: // callback entry point from State_NCMAApresPIN


                // AJS changed: read the bootblock here, because we need to know whether to offer
                // the user the option of changing the PIN...
                if(fetch_sc_bootblock() < 0) { // bootblock read was crap
                    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: failed to read bootblock\n");
                    ncma_dbox_open(URL_PATH(invalid.html));
                    return(State_NCMABadCard);
                }

                if(build_ram_cache() < 0) {
             	      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: failed to build RAM cache\n");
             	      ncma_dbox_open(URL_PATH(invalid.html));
             	      return(State_NCMABadCard);
             	}

                if(validate_funai_id_card() < 0) { // check bootblock looks ok
                    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: bootblock isn't formatted as Funai ID card\n");
                    ncma_dbox_open(URL_PATH(invalid.html));
                    return(State_NCMABadCard);
                }

                if(force_pin == 1) {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: forcing user to set PIN\n");
                    ncma_dbox_open(URL_PATH(needpin.html));
                    return(State_NCMANeedPIN);
                }

                proceed_after_force_pin: // callback entry point from State_NCMANeedPIN
                proceed_after_dial_failed: // callback from State_DiallingISP

                if(num_slots == 2) { // twin slot system
                    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: twin slot system - connect page has no CONNECT button\n");

    	    	    init_service_card(); // see if SVC card is already inserted

    	    	    switch(url_card_inserted) {
    	    	        case -1: // there's an invalid card already inserted
    	    	            	 // open badsvc dialogue, and open connect[BNP] dialogue underneath, proceed as if no card inserted
    	    	    	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: invalid card already inserted\n");
    	    	    	    ncma_dbox2_open(URL_PATH(badsvc.html));
    	    	    	    // fall-thru to complete 'card not inserted' stuff

    	    	    	case 0: // no card inserted
    	    	    	    if(url_card_inserted == 0) DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: there is no card in slot 2\n"); // yuk
    	    	    	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: nothing of interest in slot 2\n");

    	    	    	    switch(user_config) { // decide which connect screen needs to be displayed
    	    	    	    	case USER_CONFIG_PIN: // can change PIN only
    	    	    	    	    ncma_url_open(URL_PATH(connectP.html));
    	    	    	    	    break;

    	    	    	    	case USER_CONFIG_CARD: // can change PIN and CARD details
    	    	    	    	    ncma_url_open(URL_PATH(connectB.html));
    	    	    	    	    break;

    	    	    	    	case USER_CONFIG_NONE: // can't change anything
    	    	    	    	default:
    	    	    	    	    ncma_url_open(URL_PATH(connectN.html));
    	    	    	    	    break;
    	    	    	    }
    	    	    	    return(State_NCMAConnect); // change state to connect phase
    	    	    	    break;

    	    	    	case 1: // valid card inserted - continue in connect phase
    	    	    	    ncma_trans = Trans_URLCardRetry; // SJM: 8Dec98: Was Trans_URLConnect;
    	    	    	    setcallback();
    	    	    	    return(State_NCMAConnect);
    	    	    	    break;

    	    	    	default:
    	    	    	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: bad value %d returned from init_service_card()\n",
    	    	    	    	url_card_inserted);
    	    	    	    break;
    	    	    } // endswitch url_card_inserted
    	    	} else { // endif num_slots == 2
    	    	    // there's only 1 slot, therefore the connect pages have to have 'connect' buttons to give
    	    	    // the user the chance to edit PIN and/or ISP details if applicable
    	    	    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: single slot system - connect page has CONNECT button\n");

    	    	    switch(user_config) { // decide which connect screen (if any) needs to be displayed
    	    	    	case USER_CONFIG_PIN: // can change PIN
    	    	    	    ncma_url_open(URL_PATH(connectSP.html));
    	    	    	    return(State_NCMAConnect);
    	    	    	    break;

    	    	    	case USER_CONFIG_CARD: // can change PIN and ISP stuff
    	    	    	    ncma_url_open(URL_PATH(connectSB.html));
    	    	    	    return(State_NCMAConnect);
    	    	    	    break;

    	    	    	case USER_CONFIG_NONE: // no edit privileges
    	    	    	default:
    	    	    	    // no screen - proceed immediately with connect phase
    	    	    	    ncma_trans = Trans_URLConnect;
    	    	    	    setcallback();
    	    	    	    return(State_NCMAConnect);
    	    	    } // endswitch user-config
    	    	} // endelse num_slots == 1

    } /* end state_ncmainit */
    break;


/*********************************************************************************

    +STATE_NCMACONNECT

 *********************************************************************************/
    case State_NCMAConnect:

    	 switch(trans) {

	     case Trans_URLChangePIN: /* the user clicked on 'change pin' */
	     	  ncma_dbox_open(URL_PATH(newpin.html));
	     	  return(State_NCMANewPIN);

             case Trans_PreConnect: /* byild tag cache without connecting, to allow ISPCapture to display current sc values */
    	    	  // don't need do to anything, as ram cache is built during state_ncmainit now
		 // SJM: copied stuff here from ncmainit as ISPCapture could have changed the values and then needs to read them back
                if(fetch_sc_bootblock() < 0) { // bootblock read was crap
                    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: failed to read bootblock\n");
                    ncma_dbox_open(URL_PATH(invalid.html));
                    return(State_NCMABadCard);
                }

                if(build_ram_cache() < 0) {
             	      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: failed to build RAM cache\n");
             	      ncma_dbox_open(URL_PATH(invalid.html));
             	      return(State_NCMABadCard);
             	}

                if(validate_funai_id_card() < 0) { // check bootblock looks ok
                    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: bootblock isn't formatted as Funai ID card\n");
                    ncma_dbox_open(URL_PATH(invalid.html));
                    return(State_NCMABadCard);
                }
             	  return(State_NCMAConnect);


	     case Trans_URLConnect: /* generated internally for a twin-slot box when the SVC card is inserted
	     	    	    	       generated by user-click on a 'connect' button on a single slot box ONLY */

                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: TransURLConnect state  ** Paul **\n");
    	    	  if(fetch_sc_bootblock() < 0) { // fetch again, in case changed by ISPCapture
    	    	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: failed to re-read bootblock\n");
    	    	      ncma_dbox_open(URL_PATH(invalid.html));
    	    	      return(State_NCMABadCard);
    	    	  }

      		  if(build_ram_cache()<0) { // build again - may have been altered by ISPCapture
      		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: insufficient connection details\n");
		      ncma_dbox_open(URL_PATH(invalid.html)); // was damaged.html
		      return(State_NCMABadCard);
      		  }

		  // used to be in State_NCMADiallingISP/Trans_DialOK
    	     	  ncma_network_init(NCMA_NET_RAM | NCMA_NET_POST_DIAL); /* set resolver variables */

      		  // dial based on connection details in bootblock
      		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: dialling from SC info...\n");
      		  if(ncma_dial()<0) {
      		      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: IAP dial initiation failed\n");
      		      ncma_dbox_close();
      		      ncma_url_open(URL_PATH(connect.html));
      		      return(State_NCMAConnect);
      		  }
		  else
		  {
                    /* Dial was successful, open the please waitscreen if appropriate.
                       Note that we open please wait when using a modem, but not with Ethernet
                       where 'dialling' is effectively instant.
                       Beware of a nasty problem here: we used to open pleasewait here with
                       Ethernet intrerface, and the openurl message was sent to NCFresco
                       before the openurl message for our required url, BUT during the same
                       wimpoll. However, the TaskModule can deliver messages in a different
                       order to that in which they were sent (if sent in the same wimpoll cycle),
                       and NCFresco received a message to open the pleasewait screen AFTER it
                       received the URL that we really want.         Paul Skirrow, 21 Dec 1999 */

                    switch (interface_type)
                    {
                        case ETHERNET_INTERFACE:
                            break;
                        case MODEM_INTERFACE:
		            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Opening the please wait screen.\n");
		            ncma_url_open(URL_PATH(pleasewait.html));
		            break;
                        default:
		            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Opening pleasewait for unknown interface. BEWARE! ***\n");
		            ncma_url_open(URL_PATH(pleasewait.html));
                            break;
                    }
		  }

		  return(State_NCMADiallingISP);
                  break;

    	    case Trans_URLCardInserted: // second card inserted into slot 2
    	    	ncma_dbox_close();
    	    	init_service_card() ; // sets url_card_inserted

    	    	switch(url_card_inserted) {
    	    	    case -1: // bad card
    	    	    	DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: bad card in slot 2\n");
    	    	    	ncma_dbox2_open(URL_PATH(badsvc.html));
    	    	    	return(State_NCMAConnect);

    	    	    case 0: // no card present - this shouldn't be possible
    	    	    	DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: Eh? got slot2 in event, but no card present - ignoring\n");
    	    	    	return(State_NCMAConnect);

    	    	    case 1: // card present
    	    	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card detected in slot 2\n");
    	    	    	ncma_trans = Trans_URLCardRetry; // callback to this state - gives the card a chance to settle
    	    	    	setcallback();
    	    	    	return(State_NCMAConnect);
    	    	}
    	    	break;

    	    case Trans_URLCardRetry: // called from card 2 inserted above
    	    case Trans_Timeout: // called after 'not ready' error from card

    	    	switch(read_service_card()) { // attempt to read the 2nd smartcard, sets URL card inserted
	    	    case -1: // error
		    	DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: read service card FAILED\n");
    	    	    	ncma_dbox2_open(URL_PATH(badsvc.html));
    	    	    	return(State_NCMAConnect);

	    	    case -2: // not ready
	    	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading slot2 - timing out\n");
		    	settimeout(1);
		    	return(State_NCMAConnect);

	    	    default: // got the data
			ncma_dbox2_close(); /* 14Jan99 there can be an
			error box hanging around at this point from
			quick insert and remove */

	    	    	ncma_trans = Trans_URLConnect; // re-enter state & connect
	    	    	setcallback();
		    	return(State_NCMAConnect);
	    	}
	    	break;

         } /* end state_ncmaconnect */
         break;


/*********************************************************************************

    STATE_NCMADIALLINGISP

 *********************************************************************************/
    case State_NCMADiallingISP:

    	 switch(trans) {
#ifdef MUST_HAVE_URL_CARD
    	     case Trans_URLCardRemoved: // user removed the URL card while we were dialling
    	     	  // this bit's not in the spec - it's a late addition at the customer's behest
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: URL card removed while dialling\n");
    	     	  ncma_hangup();
    	     	  ncma_dialler_dbox_close();
    	     	  ncma_dbox_close();
    	     	  goto proceed_after_dial_failed;
    	     	  return(State_NCMAConnect);
    	     	  break;
#endif
    	     case Trans_DialBad: /* Don't know what to do here! Not in the CIS!! */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ISP dial failed - bummer\n");
    	     	  ncma_dialler_dbox_close();
    	     	  ncma_dbox_close();
    	     	  //ncma_url_open(URL_PATH(connect.html));
    	     	  goto proceed_after_dial_failed;
    	     	  return(State_NCMAConnect);
    	     	  break;

    	     case Trans_DialOK: /* dial succeeded */
    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: ISP dial succeeded\n");

#ifdef DEBUG_DISCONNECT
       		  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: DEBUG_DISCONNECT setting line drop timeout\n");
       		  set_ppp_timeout();
#endif

		  /* moved to just before ncma_dial() */
    	     	  /* ncma_network_init(NCMA_NET_RAM | NCMA_NET_POST_DIAL); set resolver variables */

      	     	  ncma_url_user();

    	     	  return(State_NCMABooted);
 		  break;

		  /* 5Jan99 SJM add this transition so that we can
                     redial from a dial failure via NCMA and get the
                     pleasewait screen up. */
	 case Trans_URLConnect:	/* request to redial after a dial failure */
	     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: redialling from SC info...\n");
	     if(ncma_dial()<0) {
		 DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: IAP dial initiation failed\n");
		 ncma_dbox_close();
		 ncma_url_open(URL_PATH(connect.html));
		 return(State_NCMAConnect);
	     }
	     else
	     {
		 /* Dial was successful, open the please wait screen */
		 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Opening the please wait screen.\n");
		 ncma_url_open(URL_PATH(pleasewait.html));
	     }
	     break;

	 } /* end state_ncmadiallingisp */
 	 break;

/*********************************************************************************

    +STATE_NCMABOOTED

 *********************************************************************************/
    case State_NCMABooted:

    	 switch(trans) {

    	     case Trans_NCMASurf:
		  ncma_url_user();	/* this can happen when the user presses home - just let it fail if it must */
    	     	  return(State_NCMABooted);

#ifdef TRAP_PPP_TIMEOUTS
	     case Trans_PPPTimeout:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PPP timeout event received\n");
	     	  ignore_ppp_timeout = 1; /* next time, don't claim svc call, just let it happen */
	     	  set_ppp_timeout(); /* set short timeout for drop, in case user has dozed off */
	     	  ncma_sound_effect(NCMA_TIMEOUT_SOUND);
	     	  ncma_dbox_close();
	     	  ncma_dbox_open(URL_PATH(disconnect.html));
	     	  return(State_NCMABooted);
#endif

	     case Trans_URLDisconnectAck: /* user wants to disconnect now */
	     	  ignore_ppp_timeout = 0; /* tell svc handler to block next timeout & notify us */
	     	  ncma_dbox_close();
	     	  ncma_hangup();
	     	  return(State_NCMABooted);

	     case Trans_URLDisconnectNak: /* user wants to carry on */
	     	  ignore_ppp_timeout = 0; /* tell svc handler to block next timeout & notify us */
	     	  set_ppp_timeout_long(); /* do the long timeout */
	     	  ncma_dbox_close();
	     	  return(State_NCMABooted);

	     case Trans_HUP: /* we've lost our connection */

#ifdef SILENT_HUP
       		  /* no special action - rely on browser to bring the line back up
       		     note that this might be thru a ref. to NCFresco$Home, which is
       		     a macro which evaluates to ncma:userhome, which fires Trans_NCMASurf,
       		     which calls the browser (first trans above) which brings the line
       		     up. :) */
       		  return(State_NCMABooted);
#else
		  /* alternatively, bung the 'connect to isp' screen up and do all that pallaver */
       		  ncma_url_open(URL_PATH(connect.html));
	     	  return(State_NCMAConnect);
#endif

	     case Trans_URLConnect:
		 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: redialling from SC info...\n");
#if 1
		 /* 14Jan99 it is possible to get a dial error whilst
                    in the booted state. If the user goes to options
                    at this point then they will come back out with
                    'connectack' */
		 if(ncma_dial()<0) {
		     DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: IAP dial initiation failed\n");
		     ncma_dbox_close();
		     ncma_url_open(URL_PATH(connect.html));
		     return(State_NCMAConnect);
		 }
		 else
		 {
		     /* Dial was successful, open the please wait screen */
		     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Opening the please wait screen.\n");
		     ncma_url_open(URL_PATH(pleasewait.html));
		     return(State_NCMADiallingISP);
		 }
		 break;
#else
		 /* this is the old code from NCMAlite - the Boca years */
		 ncma_dbox_close();
		 ncma_url_open(URL_PATH(badurl.html));
		 return(State_NCMABooted);
#endif

	     case Trans_URLConnectNak: // Added by SJM - refer to Docs.BocaChanges
		  ncma_hangup();
	     	  ncma_dbox_close();
		  ncma_url_open(WELCOME_SCREEN_URL);
     		  run_from_powerup = 0;
             	  return(State_NCMAInit);

	     case Trans_HangUp: // Added by SJM - refer to Docs.BocaChanges
		  ncma_hangup();
	     	  ncma_dbox_close();

    	    	  // modified by AJS - multiple connect.html options, depending on num_slots, editability,
    	    	  // whether the SERVICE card is already in or not &c &c

    	    	  goto proceed_after_force_pin;	// continue in init state

		  //ncma_url_open(URL_PATH(connect.html));
		  //return(State_NCMAConnect);

             case Trans_PreConnect: /* called by ISPCapture to ensure smartcard details are read */
		  ncma_hangup();
             	  return(State_NCMAConnect);

    	    // NEW STUFF to handle re-insertion of a SVC/URL card while in booted state
    	    // basically, ignore card-outs, but on a valid card-in, fetch the SVC/URL card's URL regardless

    	    case Trans_URLCardInserted: // second card inserted into slot 2
		if (disable_slot2_count == 0)
		{
		    init_service_card() ; // sets url_card_inserted

		    switch(url_card_inserted) {
    	    	    case -1: // bad card
    	    	    	DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: bad card in slot 2, ignoring it\n");
    	    	    	return(State_NCMABooted);

    	    	    case 0: // no card present - this shouldn't be possible
    	    	    	DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: Eh? got slot2 in event, but no card present - ignoring\n");
    	    	    	return(State_NCMABooted);

    	    	    case 1: // card present
    	    	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card detected in slot 2\n");
    	    	    	ncma_trans = Trans_URLCardRetry; // callback to this state - gives the card a chance to settle
    	    	    	setcallback();
    	    	    	return(State_NCMABooted);
		    }
		}
    	    	break;

#ifdef MUST_HAVE_URL_CARD
     	    case Trans_URLCardRemoved: // card 2 out, reset retries
     	    	// this isn't in the spec. either - it's a late addition at the customer's behest
      	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card 2 removed, but this state DOES now care\n");

      	    	// put a dialogue up until the user puts another URL card in
      	    	// don't need a separate state to handle this, as the browser won't let the user do anything
      	    	// while one of my dialogs is on screen. Now there's handy!
      	    	ncma_dbox2_open(URL_PATH(waiturl.html));
      	    	return(State_NCMABooted);
      	    	break;
#endif

    	    case Trans_URLCardRetry: // called from card 2 inserted above
    	    case Trans_Timeout: // called after 'not ready' error from card

    	    	switch(read_service_card()) { // attempt to read the 2nd smartcard, sets URL card inserted
	    	    case -1: // error
		    	DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: read service card FAILED, ignoring it\n");
    	    	    	return(State_NCMABooted);

	    	    case -2: // not ready
	    	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading slot2 - timing out\n");
		    	settimeout(1);
		    	return(State_NCMABooted);

	    	    default: // got the data
	    	    	ncma_dbox2_close(); // close the waiturl.html dialogue
	    	    	ncma_trans = Trans_URLConnect; // re-enter state & connect
    	    	    	DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: new SERVICE card info read...fetching\n");
    	    	    	ncma_url_user();
		    	return(State_NCMABooted);
	    	}
	    	break;

    	 } /* end state_ncmabooted */
    	 break;


 /*********************************************************************************

    +STATE_NCMASHUTDOWN

 *********************************************************************************/
    case State_NCMAShutdown:

         switch(trans) {

             case Trans_URLShutdown:
             case Trans_Shutdown:
                  prevent_shutdown = 0;
                  shutdown_nc();
                  ncma_standby_dbox_close(); /* close my dbox */
                  ncma_dbox_close(); /* close any other dbox. Yuck. */
                  ncma_dbox2_close(); /* close any other dbox. Yuck. */
                  ncma_url_open(BLANK_SCREEN_URL);
                  return(State_NCMAShutdown);
                  break;

             case Trans_URLShutdownCancel:
                  ncma_standby_dbox_close();
             	  return(pre_shutdown_state);
             	  break;

             case Trans_ShutdownComplete:
             	  prevent_shutdown = 1;
             	  if(ui_present()) prod_browser_after_standby();
             	  return(State_NCMAInit);
             	  break;
         } /* end state_ncmashutdown */
         break;


/*********************************************************************************

    STATE_NCMADEFAULTPIN : we've just attempted the default Funai PIN "00000000"

 *********************************************************************************/
    case State_NCMADefaultPIN:

    	 switch(trans) {
	     case Trans_AuthFail: /* default PIN failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure for default PIN (auth)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad DEFAULT PIN: %d attempts left\n", card_attempts);
	     	    update_pin();
	     	    return(State_NCMAUpdatePIN);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open(URL_PATH(unblock.html));
	     	    return(State_NCMABadCard);
	     	  }
	     	  break;

    	     case Trans_Registry: /* test status of default PIN transaction */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);

#if 0
	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: DEFAULT PIN failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad DEFAULT PIN: %d attempts left\n", card_attempts);
	                update_pin();
	     	        return(State_NCMAUpdatePIN);
	     	      } else {
	     	        DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	        ncma_dbox_open(URL_PATH(unblock.html));
	     	        return(State_NCMABadCard);
	     	      }
	     	      break;


	     	  }
#endif
		  /* default PIN succeeded */
	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: DEFAULT PIN succeeded\n");
                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

       		      ncma_trans = Trans_Registry; /* cue one up */
       		      setcallback();

       		      return(State_NCMAApresPIN);

	          }


    	 } /* end state_ncmadefaultpin */
    	 break;


/*********************************************************************************

    STATE_NCMAUPDATEPIN : we've just attempted the update Funai PIN "99999999"

 *********************************************************************************/
    case State_NCMAUpdatePIN:

    	 switch(trans) {
	     case Trans_AuthFail: /* update PIN failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure for update PIN (auth)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad UPDATE PIN: %d attempts left\n", card_attempts);
	     	    ncma_dbox_open(URL_PATH(pin.html));
	     	    return(State_NCMAPin);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open(URL_PATH(unblock.html));
	     	    return(State_NCMABadCard);
	     	  }
	     	  break;

    	     case Trans_Registry: /* test status of update PIN transaction */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
#if 0
	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: UPDATE PIN failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad UPDATE PIN: %d attempts left\n", card_attempts);
	     	        ncma_dbox_open(URL_PATH(pin.html));
	     	        return(State_NCMAPin);
	     	      } else {
	     	        ncma_dbox_open(URL_PATH(unblock.html));
	     	        return(State_NCMABadCard);
	     	      }
	     	      break;


	     	  }
#endif
		  /* update PIN succeeded */
	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: UPDATE PIN succeeded, prompting for new PIN\n");
                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

    	    	      //ncma_dbox_open(URL_PATH(needpin.html));
    	    	      //return(State_NCMANewPIN);
      		      ncma_trans = Trans_Registry; /* cue one up */
       		      setcallback();
    	    	      force_pin = 1;
       		      return(State_NCMAApresPIN);

	          }


    	 } /* end state_ncmadefaultpin */
    	 break;



/*********************************************************************************

    +STATE_NCMAPIN

 *********************************************************************************/
    case State_NCMAPin:

    	 switch(trans) {

	     case Trans_CardOK:
	     	  return(State_NCMAPin);
	     	  break;

	     case Trans_URLPinNAK:
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: user cancelled PIN entry\n");
	     	  ncma_dbox_close();
#ifdef LOCAL_URL_PATHS
  	   	  ncma_url_open(URL_PATH(welcome.html));
#else
		  ncma_url_open(WELCOME_SCREEN_URL);
#endif

		  return(State_NCMAInit);
	     	  //ncma_dbox_open(URL_PATH(splash.html));
	     	  //return(State_NCMANoCard);
	     	  break;

	     case Trans_AuthFail: /* the user entered a pin, but it failed */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failure (authfail)\n");
	          if(card_attempts-->0) {
	            DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	    ncma_dbox_open(URL_PATH(badpin.html));
	     	    return(State_NCMABadPin);
	     	  } else {
	     	    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: card has become blocked\n");
	     	    ncma_dbox_open(URL_PATH(unblock.html));
	     	    return(State_NCMABadCard);
	     	  }
	     	  break;

    	     case Trans_Registry: /* the user entered a pin, maybe it worked, maybe it didn't */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
#if 0
	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization failed (registry)\n");

	              if(card_attempts-->0) {
	                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Bad PIN! %d attempts left\n", card_attempts);
	     	        ncma_dbox_open(URL_PATH(badpin.html));
	     	        return(State_NCMABadPin);
	     	      } else {
	     	        ncma_dbox_open(URL_PATH(unblock.html));
	     	        return(State_NCMABadCard);
	     	      }
	     	      break;


	     	  }
#endif
	     	  if(registry_status_clear(BB_STATUS_LOCKED) && registry_status_clear(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");
                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;

    	    	      ncma_dbox_close();
       		      ncma_trans = Trans_Registry; /* cue one up */
       		      setcallback();

       		      return(State_NCMAApresPIN);
	          }
		  break;
    	 } /* end state_ncmapin */
    	 break;


/*********************************************************************************

    STATE_NCMAAPRESPIN wait for registry completion on bootblock read after user PIN entry

 *********************************************************************************/
    case State_NCMAApresPIN:

         switch(trans) {

             case Trans_Registry:
                if(bootblock_read_succeeded()==0) { /* bootblock read ok, but not finished yet */
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock (after pin)\n");
                  return(State_NCMAApresPIN);
                } else {
                    goto proceed_after_apres_pin;
                }
                break;




 	 }
	 break;



/*********************************************************************************

    STATE_NCMABADPIN

 *********************************************************************************/
    case State_NCMABadPin:

         switch(trans) {

	     case Trans_CardOK:
	     	  return(State_NCMABadPin);
	     	  break;

             case Trans_URLRetry:
                  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: getting ready for another go\n");
             	  //ncma_url_open("file:/ncma:pin.html");
             	  ncma_dbox_open(URL_PATH(pin.html));
             	  return(State_NCMAPin);
         } /* end state_ncmabadpin */
         break;


/*********************************************************************************

    STATE_NCMANEWPIN

 *********************************************************************************/
    case State_NCMANewPIN:

    	 switch(trans) {

	     case Trans_AuthFail: /* failed setting PIN */ /* this shouldn't happen */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failure\n");
	     	  ncma_dbox_open(URL_PATH(newpin.html));
	     	  return(State_NCMANewPIN);

	     	  break;

	     case Trans_URLMismatch: /* the two PINs the user entered didn't match */
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: fetching PIN mismatch page\n");
	     	  ncma_dbox_open(URL_PATH(mismatch.html));
	     	  return(State_NCMAMismatch);
	     	  break;

	     case Trans_URLLeavePIN: /* a cancel on the change pin OSD */
	     	    ncma_dbox_close();
	     	    return(State_NCMAConnect);
    	    	    break;

    	     case Trans_Registry: /* PIN set status from registry */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
#if 0
	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failed\n"); /* this shouldn't happen */
	     	      ncma_dbox_open(URL_PATH(newpin.html));
	     	      return(State_NCMANewPIN);
	     	  }
#endif
	     	  if(registry_status_asserted(BB_STATUS_BB_VALID) || registry_status_cleared(BB_STATUS_LOCKED) ||
	     	  		registry_status_cleared(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");

                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;
		      ncma_dbox_close();

    	    	      return(State_NCMAConnect);

	     	  }
		  break;
    	 }
    	 break;

/*********************************************************************************

    STATE_NCMANEEDPIN

 *********************************************************************************/
    case State_NCMANeedPIN:

    	 switch(trans) {

	     case Trans_AuthFail: /* failed setting PIN */ /* this shouldn't happen */
	          DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failure\n");
	     	  ncma_dbox_open(URL_PATH(needpin.html));
	     	  return(State_NCMANeedPIN);

	     	  break;

	     case Trans_URLMismatch: /* the two PINs the user entered didn't match */
	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: fetching PIN mismatch page\n");
	     	  ncma_dbox_open(URL_PATH(mismatch.html));
	     	  return(State_NCMANeedPIN);
	     	  break;

	     case Trans_URLMismatchAck:
	     	  ncma_dbox_open(URL_PATH(needpin.html));
	     	  return(State_NCMANeedPIN);

    	     case Trans_Registry: /* PIN set status from registry */
                 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
#if 0
	     	  if(registry_status_asserted(BB_STATUS_LOCKED) || registry_status_asserted(BB_STATUS_AUTHFAIL)) { /* PIN was wrong */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: PIN change failed\n"); /* this shouldn't happen */
	     	      ncma_dbox_open(URL_PATH(needpin.html));
	     	      return(State_NCMANeedPIN);
	     	  }
#endif
	     	  if(registry_status_asserted(BB_STATUS_BB_VALID) || registry_status_cleared(BB_STATUS_LOCKED) ||
	     	  		registry_status_cleared(BB_STATUS_AUTHFAIL)) { /* PIN was right */
	     	      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: authorization successful\n");

                      strncpy(old_chv_pin, chv_pin, chv_pin_size);
                      old_chv_pin_size = chv_pin_size;
		      ncma_dbox_close();

    	    	      force_pin = 0;
    	    	      goto proceed_after_force_pin;

	     	  }
    	 }
    	 break;

/*********************************************************************************

    STATE_NCMAMISMATCH

 *********************************************************************************/
    case State_NCMAMismatch:

    	 switch(trans) {

    	     case Trans_URLMismatchAck:
    	     	  ncma_dbox_open(URL_PATH(newpin.html));
    	     	  return(State_NCMANewPIN);
    	     	  break;
    	 }
    	 break;

/*********************************************************************************

    STATE_NCMABADCARD

 *********************************************************************************/
    case State_NCMABadCard: /* waiting for URL/CLI call */

    	 switch(trans) {
    	     case Trans_CardRemoved: /* user has removed bad card */

    	     	  DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: invalid smartcard removed\n");
    	     	  ncma_dbox_close();
    	     	  ncma_dbox_open(URL_PATH(splash.html));
    	     	  return(State_NCMANoCard);

    	 } /* end state_ncmabadcard */

    	 break;

/*********************************************************************************

    +STATE_NCMANOCARD

 *********************************************************************************/
    case State_NCMANoCard: /* waiting for a smartcard to be inserted */

         switch(trans) {
	    case Trans_CardOK:
	         DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: card_ok event - clearing status delta register\n");
	         smartcard_status(NULL);
	    	 return(State_NCMANoCard);


            case Trans_Registry: /* card activity */

		if(!smartcard_present()) {
		    DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading PIN status (no card)\n");
		    return(State_NCMANoCard);
		}

		if(!smartcard_valid()) {
		    DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: invalid smartcard\n");
		    ncma_dbox_open(URL_PATH(invalid.html));
		    return(State_NCMABadCard);
		}

	    	if(smartcard_pin_protected()) {
	    	    card_attempts = smartcard_blocked();
	    	    if(card_attempts>0) {
       		      DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not blocked (%d), trying defalt PIN\n", card_attempts);
       		      default_pin(); // try the default PIN "00000000"
       		      return(State_NCMADefaultPIN);
		    } else if(card_attempts == 0) {
		      DBUG_PRINTF(DBUG_LVL_ERROR, "NCMA_machine: smartcard is blocked\n");
		      ncma_dbox_open(URL_PATH(unblock.html));
		      return(State_NCMABadCard); // no unblock mechanism on this NC
		    } else {
		        DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: not ready reading bootblock PIN info\n");
		        return(State_NCMANoCard);
		    }
		}


                DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: Trans_Registry s=0x%x d=0x%x\n", registry_status, registry_delta);
                if(bootblock_read_failed()) {
                     DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bootblock read failed\n");
                     ncma_dbox_open(URL_PATH(invalid.html)); // was damaged.html
                     return(State_NCMABadCard);
                }


		goto proceed_after_pin;

		break;

            case Trans_CardBad: /* bad card */

            	 DBUG_PRINTF(DBUG_LVL_DIAG, "NCMA_machine: bad card re-inserted\n");
            	 ncma_dbox_open(URL_PATH(invalid.html)); // was damaged.html
            	 return(State_NCMABadCard);
         } /* end state_ncmanocard */
         break;

  } /* end switch STATE */


  /* otherwise . . . PANIC!! */

  DBUG_PRINTF(DBUG_LVL_PANIC, "NCMA: state machine panic - invalid transition event %s in state %s\n",
  		      trans_string(ncma_trans), state_string(ncma_state));

#ifdef ABORT_ON_PANIC
  DBUG_PRINTF(DBUG_LVL_PANIC, "            setting state to State_Panic\n");
  return(State_NCMAPanic);
#else
  return(ncma_state);
#endif
}
