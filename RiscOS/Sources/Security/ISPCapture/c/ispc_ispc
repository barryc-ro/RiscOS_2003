/* ispc_ispc.c - ported from UNIX utility */
/* smartcard.c - ant's prog. to generate smartcard content for the Boca platform (NCMAlite)
                            do smartcard -h for usage
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"

#include "socklib.h"
#include "inetlib.h"


#ifdef CCIJ10
 #include "smcardccij.h"
 #define PROTOTYPES_INTERNAL
 #include "smtagsCCIJ.h"
#else
 #include "smcard.h"
 #define PROTOTYPES_INTERNAL
 #include "smtags.h"
#endif /* CCIJ10 */

#pragma -d0
#include "netdb.h"
#pragma -d1


#define PROTOTYPES_INTERNAL
#include "ispc_ispc.h"
#include "ispc_url.h"
#include "ispc_utils.h"
#include "dynalloc.h"
#include "DBUG.h"


#include "callbacks.h"

static int finish_compile(char *start, char *end);
static char *collapse_quotes(char const *s);
static char *expand_ctrls(char const *s);

/* characters allowed by the SoftModem. Not including dash and space
   which are allowed but screw up DiallerB and are disallowed by the
   Funai specification */
static const char phone_allowable_chars[] = "0123456789ABCD,#!*;";



int ispc_compile(void)
{
    int bytes;
    int nextline;
    char *l;

    iptr = ibuff;
    optr = obuff;

    DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_compile()\n");

    while((iptr = getline(iptr, ibuff, ibytes))!=NULL) {
	nextline = strlen(iptr)+1;
	if((l = write_tags(iptr, optr))==NULL) {
	    DBUG_PRINTF(DBUG_LVL_DIAG, "\naborted\n");
	    return -1;
	}
	iptr += nextline;
	optr = l;
    }

    bytes = finish_compile(obuff, optr);

    DBUG_PRINTF(DBUG_LVL_DIAG, "ok.\n");
    return(bytes);
}


char *getline(char *p, char *s, int n)
{
    char *r, *e;

    DBUG_PRINTF(DBUG_LVL_DIAG, "getline()\n");

    e = s + n;
    for(; p<e; p++) {
	if(*p == 0) return NULL;
	if(*p == 0x0a) {
	    input_line++;
	    continue;
	}
	if(isprint(*p)) {
	    if(*p == '#') {
		input_line++;
		while(*p != 0x0a) p++;
		continue;
	    } else {
		for(r=p; (*r != 0x0a) && r<e; r++);
		*r = 0x0;
		input_line++;
		return(p);
	    }
	}
    }
    return NULL;
}

int caseless_strncmp(char const *a, char const *b, int n)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "caseless_strncmp()\n");

  while(n--) {
	if(*a == 0) return(0);
	if(toupper(*a++) != toupper(*b++)) return(1);
    }
    return(0);
}

#ifdef ENABLE_DEBUGGING
static void tag_dumpcontents(int bytes)
{
  static char nastybuf[256]="";
  char *buf=obuff;
  while (buf < obuff+bytes)
  {
    char *np=nastybuf;
    int type;
    int len;
#ifdef CCIJ10
    type=*buf++;
    len=*buf++;
#else
    type=read_big_word(buf); buf+=4;
    len=read_big_short(buf); buf+=2;
#endif
    if (buf+len > obuff+bytes)
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "  [Length puts it outside buffer]\n");
      break;
    }
    while (len>0)
    {
      char c=*buf;
      if (c>=' ' && c!=127)
        *np++=c;
      else
      {
        np+=sprintf(np,"[%i]",c);
      }
      *np='\0';
      buf++; len--;
    }
    DBUG_PRINTF(DBUG_LVL_DIAG, "  %5i : '%s'\n",type,nastybuf);
  }
}
#endif

/* erg. UNIXy bits commented out, because they don't work under RISC OS. ntohs is really broken */
/*******************************************************************
 Function:     tag
 Description:  Write a tag into the output buffer
 Parameters:   d-> output block
               t = tag value
               s-> source data to write
               n = length of source data
 Returns:      pointer to new output block (ie end of data written)
 ******************************************************************/
char *tag(char *d, unsigned int t, char const *s, int n)
{
    DBUG_PRINTF(DBUG_LVL_DIAG, "tag()\n");

#ifdef CCIJ10
    /* CCIJ1.0 tags are 1 byte label, 1 byte length, DATA */
    DBUG_PRINTF(DBUG_LVL_DIAG, "tag: writing 1+1+%d = %d byte tag\n", n, n+2);
    *d++ = t;
    //*d++ = n + 2; NO!! value of length byte does NOT include <tag> and <length> bytes
    *d++ = n;
#else
    //unsigned short m;

    DBUG_PRINTF(DBUG_LVL_DIAG, "tag: writing 4+2+%d = %d byte tag\n", n, n+6);
    write_big_word(d, t);
    // *(unsigned int *)d = (int)htonl(t);
    d += 4;
    write_big_short(d, n);
    // m = htons(n);
    // *(unsigned short *)d = m;
    d += 2;
#endif
    if(s != NULL) {
	memcpy(d, s, n);
	d += n;
    }
#ifdef ENABLE_DEBUGGING
    tag_dumpcontents(d-obuff);
#endif
    return d;
}

void set_base(char *buff, char const *param)
{
    DBUG_PRINTF(DBUG_LVL_DIAG, "set_base()\n");
    if(strstr(param, "0x")) strcpy(buff, "0x%x");
    else if(strstr(param, "0X")) strcpy(buff, "0X%X");
    else strcpy(buff, "%d");
    return;
}

/* Process 's' into buffer 'out' to get rid of any characters that aren't
 * in the 'allowed' string.
 * 'out' should be at least as long as 's'. */

static void strip_disallowed_chars(char const *s, char *out, const char *allowed)
{
    const char *in = s;
    char c;

    DBUG_PRINTF(DBUG_LVL_DIAG, "strip_disallowed_chars()\n");

    while ( (c = *in++) != 0 )
    {
	if ( strchr( allowed, c ) != 0 )
	    *out++ = c;
    }
    *out++ = 0;
}

char *write_tags(char const *iptr, char *optr)
{
  int l;
  char const *param;
  unsigned int i;
  char buff[8];

  DBUG_PRINTF(DBUG_LVL_DIAG, "write_tags()\n");

  for(l = 0; (tag_cache.tag[l].tag != NULL) && (l < MAX_TAG_CACHE); l++) {
      if(caseless_strncmp(tag_cache.tag[l].tag, iptr, strlen(tag_cache.tag[l].tag))==0) { /* match */
	  DBUG_PRINTF(DBUG_LVL_DIAG, "write_tags: matched tag %s: ", tag_cache.tag[l].tag);
	  param = iptr + strlen(tag_cache.tag[l].tag);
	  switch(tag_cache.tag[l].mapping) {

	  case TAG_MAPPING_PHONE:
	  {
	      char *stripped=(char *)rmalloc(strlen(param)+1, "Strip temporary buffer");
	      if (stripped == NULL)
	           return NULL; /* Failed to allocate out temporary buffer */
	      strip_disallowed_chars(param, stripped,phone_allowable_chars);
	      optr = tag(optr, tag_cache.tag[l].nci_tag, stripped, strlen(param));
	      rmfree ((unsigned char *)stripped);
	      
	      return optr;
	  }

	  case TAG_MAPPING_HTTP_URL:
	       while(isspace(*param)) param++;
	       if (caseless_strncmp(param, "http://", 7) == 0)
		   param += 7;
	       optr = tag(optr, tag_cache.tag[l].nci_tag, param, strlen(param));
	       return(optr);

#ifndef CCIJ10
	  case TAG_MAPPING_URL:
	  {
	       int no_proto;
	       char *str;

	       while(isspace(*param)) param++;
	       /* If there is no colon in the URL ... */
	       no_proto = (strchr (param, ':') == NULL);

	       /* If there is no colon in the URL ... */
	       if (no_proto)
	       {
	         /* ... we've got no protocol, so prefix http:// as an assumption */
	         str = (char *)rmalloc(strlen(param)+strlen("http://")+1, "URL buffer");
	         if (str == NULL)
	           return NULL;
	         sprintf (str, "http://%s", param);
	       }
	       else
	       {
	         /* ... else there is a colon, assume we have a valid URL with a protocol */
	         str = (char *)param; /* Icky cast ! Sorry -
	                                 str isn't written to anywhere
	                                 from here on anyhow */
	       }
	       optr = tag(optr, tag_cache.tag[l].nci_tag, str, strlen(str));
	       if (no_proto)
	       {
	         rmfree ((unsigned char *)str);
	       }
	       return(optr);
	  }
#endif

	  case TAG_MAPPING_STRING:
	       while(isspace(*param)) param++;
	       if((i = nquotes(param))>0) {
	           char *collapsed;
	           char *expanded;
		   if(i & 1) {
		       DBUG_PRINTF(DBUG_LVL_DIAG, "\nwrite_tags: Unbalanced quotes at line %d -->\"%s\"\n", input_line, param);
		       return(NULL);
		   }
		   DBUG_PRINTF(DBUG_LVL_DIAG, "found %d quotes in string\n", i);
		   collapsed=collapse_quotes(param);
		   if (collapsed==NULL) {
		       DBUG_PRINTF(DBUG_LVL_DIAG, "collapse_quotes failed, returning failure\n");
		       return(NULL);
		   }
		   expanded=expand_ctrls(collapsed);
		   free(collapsed);
		   if (expanded==NULL) {
		       DBUG_PRINTF(DBUG_LVL_DIAG, "expand_ctrls failed, returning failure\n");
		       return(NULL);
		   }
		   DBUG_PRINTF(DBUG_LVL_DIAG, "String after expansion: %s\n", param);
		   optr = tag(optr, tag_cache.tag[l].nci_tag, expanded, strlen(expanded));
		   free(expanded);
	       }
	       else
	       {
		       DBUG_PRINTF(DBUG_LVL_DIAG, "String: %s\n", param);
		       optr = tag(optr, tag_cache.tag[l].nci_tag, param, strlen(param));
	       }
	       return(optr);

	  case TAG_MAPPING_INT:
	      set_base(buff, param);
	      if(sscanf(param, buff, &i)!=1) {
		  DBUG_PRINTF(DBUG_LVL_DIAG, "\nwrite_tags: Bad integer at line: %d\n --> \"%s\"\n", input_line, param);
		  return(NULL);
	      }

	      i = (int)htonl(i);
	      DBUG_PRINTF(DBUG_LVL_DIAG, "Int: 0x%x\n", i);
	      optr = tag(optr, tag_cache.tag[l].nci_tag, (char *)&i, 4);
	      return(optr);


	  case TAG_MAPPING_HOST:
	       while(isspace(*param)) param++;
	       if(validate_host(param, NULL)<0) return(NULL);
	       DBUG_PRINTF(DBUG_LVL_DIAG, "Host: %s\n", param);
	       optr = tag(optr, tag_cache.tag[l].nci_tag, param, strlen(param));
	       return(optr);

	  case TAG_MAPPING_IP:
	      while(isspace(*param)) param++;
	      if(validate_host(param, &i)) { /* first, try a textual job */
		  DBUG_PRINTF(DBUG_LVL_DIAG, "IP: %s\n", param);
		  optr = tag(optr, tag_cache.tag[l].nci_tag, (char *)&i, 4);
		  return(optr);
	      } /* otherwise, must be a word */
	       set_base(buff, param);
	       if(sscanf(param, buff, &i)!=1) {
		   DBUG_PRINTF(DBUG_LVL_DIAG, "\nwrite_tags: Bad IP word at line: %d --> \"%s\"\n", input_line, param);
		   return(NULL);
		   i = (int)htonl(i);
		   DBUG_PRINTF(DBUG_LVL_DIAG, "IP: 0x%x\n", param);
		   optr = tag(optr, tag_cache.tag[l].nci_tag, (char *)&i, 4);
		   return(optr);
	       }

	  case TAG_MAPPING_PROXY:
	       while(isspace(*param)) param++;
	       if(validate_proxy(param, NULL)<0) {
		   DBUG_PRINTF(DBUG_LVL_DIAG, "\nwrite_tags: Bad Proxy at line: %d --> \"%s\"\n", input_line, param);
		   return(NULL);
	       }
	       DBUG_PRINTF(DBUG_LVL_DIAG, "Proxy: %s\n", param);
	       optr = tag(optr, tag_cache.tag[l].nci_tag, param, strlen(param));
	       return(optr);

	  default:
	      DBUG_PRINTF(DBUG_LVL_DIAG, "\nwrite_tags: Bad tag mapping (%d) for tag %s at line %d --> \"%s\"\n", tag_cache.tag[l].mapping,
		      tag_cache.tag[l].tag, input_line, iptr);
	      return(NULL);
	  } /* end switch */
      } /* end if */
  } /* end for */

  DBUG_PRINTF(DBUG_LVL_DIAG, "\nwrite_tags: Unrecognized tag name at line %d --> \"%s\"\n", input_line, iptr);
  return(NULL);
}

#ifndef CCIJ10
int tag_headers(char *obuff, char *optr)
{
    int bytes;
    int iap_id = 42;

    bytes = optr - obuff;

    DBUG_PRINTF(DBUG_LVL_DIAG, "tag_headers: adding 28 bytes of header info to %d bytes of data\n", bytes);

    memmove(obuff + 28, obuff, bytes);

    tag(obuff, NCIBeginSignatureTag, NULL, bytes+22);
    tag(obuff + 6, NCIIAPConnectMatrixTag, NULL, bytes + 16);
    tag(obuff + 12, NCIGroupTag, NULL, bytes + 10);
    tag(obuff + 18, NCIIAPIDTag, (char *)&iap_id, 4);
    return(bytes+28);
}

int hash(char *obuff, int n)
{
    char nohash[] = "by Ant";

    tag(obuff + n, NCISignatureTag, nohash, strlen(nohash));
    return(n + 6 + strlen(nohash));
}
#endif

static int finish_compile(char *start, char *end)
{
    int bytes;
    DBUG_PRINTF(DBUG_LVL_DIAG, "finish_compile()\n");
#ifdef CCIJ10
/*  *end++ = 0xFF */
    bytes = end - start;
#else
    bytes = hash(start, tag_headers(start, end));
#endif
    return bytes;
}

int validate_host(char const *host, unsigned int *ret)
{
    unsigned long l;

    DBUG_PRINTF(DBUG_LVL_DIAG, "validate_host()\n");

    if((l = inet_addr(host))!=-1) { /* first try a dot quad */
	if(ret != NULL) *ret = (unsigned int)l;
	return(1);
    }


    return(1);
}

int validate_proxy(char const *proxy, unsigned int *ret)
{
    char *q;

    DBUG_PRINTF(DBUG_LVL_DIAG, "validate_proxy()\n");

    if((q=strstr(proxy, ":"))==NULL) {
	DBUG_PRINTF(DBUG_LVL_DIAG, "validate_proxy: proxy address has no port at line %d --> \"%s\"\n", input_line, proxy);
	return(-1);
    }

    return(1);
}


int nquotes(char const *s)
{
    int n;

    DBUG_PRINTF(DBUG_LVL_DIAG, "nquotes()\n");

    for(n = 0; *s != 0; s++) if(*s == 0x22) n++;
    return(n);
}

int min(int a, int b)
{
    DBUG_PRINTF(DBUG_LVL_DIAG, "min()\n");
    return(a<b?a:b);
}

int read_os_var(char *varname, char *buff, int n)
{
  _kernel_swi_regs r;

  DBUG_PRINTF(DBUG_LVL_DIAG, "read_os_var\n");

  r.r[0] = (int)varname;
  r.r[1] = (int)buff;
  r.r[2] = (buff==NULL)?0x80000000:n;
  r.r[3] = 0;
  r.r[4] = 0;
  if(_kernel_swi(OS_ReadVarVal, &r, &r) != NULL) return(-1);
  if(buff) {
      *(buff + r.r[2]) = 0;
      return(r.r[2]);
  }
  return(-(r.r[2]));

}

int write_os_var(char *varname, char *buff, int n) /* set an OS string variable */
{
    _kernel_swi_regs r;

    DBUG_PRINTF(DBUG_LVL_DIAG, "write_os_var\n");

    r.r[0] = (int)varname;
    r.r[1] = (int)buff;
    r.r[2] = n;
    r.r[3] = 0;
    r.r[4] = 0; /* type string GSTrans once */
  if(_kernel_swi(OS_SetVarVal, &r, &r) != NULL) return(-1);
  return(0);
}


int ispc_ispc_init(void)
{

  DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_ispc_init: setting up URL interface\n");
  if(ispc_url_init()<0) {
      DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_ispc_init: URL init failed\n");
      return(-1);
  }
  return(0);
}

int putline(char *s) /* s is of the form "[tagname] [tag value]" */
{
    int l;
    char *p;
    int nextline;

    DBUG_PRINTF(DBUG_LVL_DIAG, "putline: entered with arg \"%s\" 0x%x\n", s, (int)s);

    if(strlen(s)+ibytes > MAX_BUFF) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "putline: input buffer exhausted\n");
        return(-1);
    }

    if(caseless_strncmp(s, "NEXT", 4)==0) { /* redirect to next ISPcapture page */
      if((p = strchr(s, ' '))==NULL) {
          DBUG_PRINTF(DBUG_LVL_DIAG, "putline: bad ISPcapture page redirect\n");
      } else {
          strncpy(redirect_url, p+1, strlen(p+1));
          DBUG_PRINTF(DBUG_LVL_DIAG, "putline: get redirect URL \"%s\"\n", redirect_url);
          return(0);
      }
    }

    for(l=0; (tag_cache.tag[l].tag != NULL) && (l < MAX_TAG_CACHE); l++) {
        //DBUG_PRINTF(DBUG_LVL_DIAG, "putline: cf. \"%s\" with \"%s\"\n", s, tag_cache.tag[l]);
        if(caseless_strncmp((char *)(tag_cache.tag[l].tag), s, strlen(tag_cache.tag[l].tag))==0) { /* match */
	  DBUG_PRINTF(DBUG_LVL_DIAG, "putline: matched tag %s: ", tag_cache.tag[l].tag);
	  l = -1;
	  break;
	}
    }

    if(l>=0) { /* loop terminated without match */
      DBUG_PRINTF(DBUG_LVL_ERROR, "putline: unrecognized tag %s - ignoring\n", s);
      return(0);
    }

    /* now check to see whether it already exists */

    if(ibytes) {
      p = ibuff;
      while((p = getline(p, ibuff, ibytes))!=NULL) {
          nextline = strlen(p)+1;
          //DBUG_PRINTF(DBUG_LVL_DIAG, "putline: comparing %s with previous script entry %s\n", s, p);
          if(caseless_strncmp(s, p, nextline)==0) { /* match */
            *p = '#'; /* comment that sucker out */
            DBUG_PRINTF(DBUG_LVL_DIAG, "putline: previous incarnation of tag discarded\n");
            break;
          }
          p += nextline;
      }
    }
    DBUG_PRINTF(DBUG_LVL_DIAG, "putline: added line \"%s\" to script\n",s);

    strncpy(iptr, s, strlen(s));
    *(iptr + strlen(s)) = '\n';
    ibytes += strlen(s)+1;
    iptr += strlen(s)+1;


    return(1);
}


/******************************************************************
 Function:     collapse_quotes
 Description:  Collapse the quotes and escaped characters in the
               passed string ("hello \"there"" becomes hello there)
 Parameters:   s-> the string to collapse
 Returns:      rmalloc'd string
 ******************************************************************/
static char *collapse_quotes(char const *s)
{
    char *q, *pq;
    char const *ps;
    int quote = 0;

    DBUG_PRINTF(DBUG_LVL_DIAG, "collapse_quotes()\n");

    /* Strictly this +1 isn't needed because we 'know' that the string
       passed has quotes around it and so we'll be stripping things, but
       to be safe we'll allocate too much space. */
    if((q = (char *)rmalloc(strlen(s)+1, "CQ buffer"))==NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "collapse_quotes: not enough memory\n");
        return NULL;
    }
    /* memcpy (q, s, strlen(s)); */

    pq = q;
    ps = s;

    while (*ps) {
	/* first check for quote status */
	if((*ps == '\\') && (*(ps+1) == '"')) { /* escaped quote */
	    memcpy(pq, ps, 2);
	    pq+=2;
	    ps+=2;
	    continue;
	}

	else if(*ps == '"') { /* bare quote */
	    quote++;
	    ps++;
	    continue;
	}

	else if(isspace(*ps)) { /* white space */
	    if(quote & 1) { /* if inside quotes */
		*pq++ = *ps++; /* copy it */
	    } /* else skip */
	    ps++;
	} else { /* copy it */
	    *pq++ = *ps++;
	}
    }
    *pq = 0;
    DBUG_PRINTF(DBUG_LVL_DIAG,  "collapse_quotes: from %s to %s\n", s, q);
    return q;
}

static char *expand_ctrls(char const *s)
{
    char *q;

    DBUG_PRINTF(DBUG_LVL_DIAG, "expand_ctrls()\n");

    if((q = (char *)rmalloc(strlen(s)+1, "EC buffer"))==NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "expand_ctrls: not enough memory\n");
        return NULL;
    }

    strccpy(q, s);
    //DBUG_PRINTF(DBUG_LVL_DIAG, "expand_ctrls: from %s to %s\n", s, q);
    return q;
}

/* emulation of POSIX strccpy() libgen.a */
#define MKCTRL(X,Y) case X: *dst++ = Y; \
		       	    src++; \
		       	    break;

char *strccpy(char *dst, char const *src)
{
    int n,m;
    char *q = dst;

    DBUG_PRINTF(DBUG_LVL_DIAG, "strccpy()\n");

    if(*src == 0) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "strccpy: empty string\n");
        *dst = 0;
        return(dst);
    }

    //DBUG_PRINTF(DBUG_LVL_DIAG, "strccpy: entered with \"%s\"\n", src);

    src++; /* skip first char - our focus is char _after_ a '\' */

    while(*src) {
        if(*(src-1) == '\\') {
            switch(*src) {
	        MKCTRL('a', '\a'); /* audible bell */
	        MKCTRL('b', '\b'); /* backspace */
	        MKCTRL('f', '\f'); /* formfeed */
	        MKCTRL('n', '\n'); /* newline */
	        MKCTRL('r', '\r'); /* carriage-return */
	        MKCTRL('t', '\t'); /* horizontal tab */
	        MKCTRL('v', '\v'); /* vertical tab */
	        MKCTRL('\\', '\\'); /* backslash */
	        MKCTRL('\?', '\?'); /* question mark */
	        MKCTRL('\'', '\''); /* single quote */
	        MKCTRL('\"', '\"'); /* double quote */


	        case 'x': /* uh-oh; hex escape */
	             	  if((sscanf(src, "%2x%n", &n, &m)==1)) {
	             	      //DBUG_PRINTF(DBUG_LVL_DIAG, "strccpy: hex escape, read %d chars\n", m);
	             	      *dst++ = (char)n;
	             	      src += m;
	             	      break;
	             	  }

                default: /* urg, might be an octal escape, or shite */
                	 if((sscanf(src, "%3o%n", &n, &m)==1)) {
                	     //DBUG_PRINTF(DBUG_LVL_DIAG, "strccpy: octal escape, read %d chars.\n", m);
                	     *dst++ = (char)n;
                	     src += m;
                	     break;
                	 }
            } /* endswitch */
	    continue;
        } /* endif backslash */

        if(*src == '\\') { /* skip an opening backslash */
            //DBUG_PRINTF(DBUG_LVL_DIAG, "strccpy: found initial backslash - skipping\n");
            src++;
            continue;
        }

        *dst++ = *src++; /* boring old normal character */
    }
    *dst = 0;
    return(q);
}

int ispc_write_smartcard(int bytes)
{
    _kernel_swi_regs r;

    DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_write_smartcard()\n");

#ifdef ENABLE_DEBUGGING
    tag_dumpcontents(bytes);
#endif

    r.r[0] = (int)obuff;
    r.r[1] = bytes;
    r.r[2] = NULL;
    r.r[3] = 0;
    r.r[4] = 42;
    r.r[5] = NULL;
    r.r[6] = 0;

    if(_kernel_swi(NCBootblock_Write, &r, &r)!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: NCBootblock Write SWI failed\n");
        return(-1);
    }
        switch(r.r[0]) {
            case  0: DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_write_smartcard: completed OK\n");
            	     break;
            case -1: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: enterprise block not authentic\n");
            	     break;

            case -2: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: enterprise block too big\n");
            	     return(-1);
            	     break;

            case -3: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: bootblock is readonly\n");
            	     break;

            case -4: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: enterprise block is readonly\n");
            	     break;

            case -5: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: file write error\n");
            	     return(-1);
            	     break;

            case -6: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: alternate block too big\n");
            	     break;

            case -7: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: alternate block not authentic\n");
            	     break;

            default: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: unrecognized return code from write SWI (&%x)\n",r.r[0]);
            	     break;
        }

     ispc_hourglass_off();
     do {
         usermode_donothing();
         r.r[0] = 0;
         _kernel_swi(NCBootblock_Status, &r, &r);
     } while((r.r[2] & 0x60)==0);

     ispc_hourglass_off();

     if(r.r[0] & 0x20) {
         DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_write_smartcard: write OK!\n");
         return(0);
     }

     if(r.r[0] & 0x40) {
         DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: write FAILED\n");
         return(-1);
     }

     DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: eh? bogus status: s->0x%x  d->0x%x\n", r.r[0], r.r[2]);
     return(-1);
}

int ispc_resetdefaults(void)
{
     int status = -1;
     _swix(NCBootblock_Reinitialise, _OUT(0), &status);
     return status;
}


/*
 * New function that combines kick_managed_access() and handle_abort().
 * Pick the right URL to go to.
 */

void ispc_completed(int reason)
{
    char *url;

    DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_completed: reason %d\n", reason);

#ifdef DIAL_ON_COMPLETION
    if (reason == ispc_COMPLETE_SUCCESS)
    {
	_kernel_swi_regs r;
	static char ncma_boot[] = "ncma_urc connectack";

	r.r[0] = (int)ncma_boot;
	if(_kernel_swi(OS_CLI, &r, &r)!=NULL) {
	    DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_completed: OS_CLI failed!\n");
	}
	return;
    }
#endif

    url = NULL;
    switch (reason)
    {
    case ispc_FINISH_SUCCESS:
	url = end_url;
	break;
    case ispc_FINISH_ERROR:
	url = error_url;
	break;
    case ispc_FINISH_ABORT:
	url = abort_url;
	break;
    }

    if (!url)
	url = EXIT_URL;

    DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_completed: using URL '%s'\n", url);

    ispc_url_open(url);
}
