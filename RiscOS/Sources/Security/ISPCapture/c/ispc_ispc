/* ispc_ispc.c - ported from UNIX utility */
/* smartcard.c - ant's prog. to generate smartcard content for the Boca platform (NCMAlite)
                            do smartcard -h for usage
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"

#include "socklib.h"
#include "inetlib.h"
#pragma -d0
#include "netdb.h"
#pragma -d1

#include "smcard.h"
#define PROTOTYPES_INTERNAL
#include "ispc_cache.h"
#define PROTOTYPES_INTERNAL
#include "ispc_ispc.h"
#include "ispc_url.h"
#include "ispc_utils.h"
#include "dynalloc.h"
#include "DBUG.h"


extern int usermode_donothing(void);


int ispc_compile(void)
{
    int bytes;
    int nextline;
    char *l;

    iptr = ibuff;
    optr = obuff;

    while((iptr = getline(iptr, ibuff, ibytes))!=NULL) {
	nextline = strlen(iptr)+1;
	if((l = write_tags(iptr, optr))==NULL) {
	    DBUG_PRINTF(DBUG_LVL_DIAG, "\naborted\n");
	    exit(1);
	}
	iptr += nextline;
	optr = l;
    }

    bytes = hash(obuff, tag_headers(obuff, optr));

    DBUG_PRINTF(DBUG_LVL_DIAG, "ok.\n");
    return(bytes);
}


char *getline(char *p, char *s, int n)
{
    char *r, *e;

    e = s + n;
    for(; p<e; p++) {
	if(*p == 0) return NULL;
	if(*p == 0x0a) {
	    input_line++;
	    continue;
	}
	if(isprint(*p)) {
	    if(*p == '#') {
		input_line++;
		while(*p != 0x0a) p++;
		continue;
	    } else {
		for(r=p; (*r != 0x0a) && r<e; r++);
		*r = 0x0;
		input_line++;
		return(p);
	    }
	}
    }
    return NULL;
}

int caseless_strncmp(char *a, char *b, int n)
{
    while(n--) {
	if(*a == 0) return(0);
	if(toupper(*a++) != toupper(*b++)) return(1);
    }
    return(0);
}

/* erg. UNIXy bits commented out, because they don't work under RISC OS. ntohs is really broken */
char *tag(char *d, unsigned int t, char *s, int n)
{
    //unsigned short m;

    DBUG_PRINTF(DBUG_LVL_DIAG, "tag: writing 4+2+%d = %d byte tag\n", n, n+6);
    write_big_word(d, t);
    // *(unsigned int *)d = (int)htonl(t);
    d += 4;
    write_big_short(d, n);
    // m = htons(n);
    // *(unsigned short *)d = m;
    d += 2;
    if(s != NULL) {
	memcpy(d, s, n);
	d += n;
    }
    return d;
}

void set_base(char *buff, char *param)
{
    if(strstr(param, "0x")) strcpy(buff, "0x%x");
    else if(strstr(param, "0X")) strcpy(buff, "0X%X");
    else strcpy(buff, "%d");
    return;
}

char *write_tags(char *iptr, char *optr)
{
  int l;
  char *param;
  unsigned int i;
  char buff[8];

  for(l = 0; (tag_cache.tag[l].tag != NULL) && (l < MAX_TAG_CACHE); l++) {
      if(caseless_strncmp((char *)(tag_cache.tag[l].tag), iptr, strlen(tag_cache.tag[l].tag))==0) { /* match */
	  DBUG_PRINTF(DBUG_LVL_DIAG, "write_tags: matched tag %s: ", tag_cache.tag[l].tag);
	  param = iptr + strlen(tag_cache.tag[l].tag);
	  switch(tag_cache.tag[l].mapping) {

	  case TAG_MAPPING_STRING:
	       while(isspace(*param)) param++;
	       if((i = nquotes(param))>0) {
		   if(i & 1) {
		       DBUG_PRINTF(DBUG_LVL_DIAG, "\nwrite_tags: Unbalanced quotes at line %d -->\"%s\"\n", input_line, param);
		       return(NULL);
		   }
		   DBUG_PRINTF(DBUG_LVL_DIAG, "found %d quotes in string\n", i);
		   collapse_quotes(param);
		   expand_ctrls(param);
	       }
	       DBUG_PRINTF(DBUG_LVL_DIAG, "String: %s\n", param);
	       optr = tag(optr, tag_cache.tag[l].nci_tag, param, strlen(param));
	       return(optr);

	  case TAG_MAPPING_INT:
	      set_base(buff, param);
	      if(sscanf(param, buff, &i)!=1) {
		  DBUG_PRINTF(DBUG_LVL_DIAG, "\nwrite_tags: Bad integer at line: %d\n --> \"%s\"\n", input_line, param);
		  return(NULL);
	      }

	      i = (int)htonl(i);
	      DBUG_PRINTF(DBUG_LVL_DIAG, "Int: 0x%x\n", i);
	      optr = tag(optr, tag_cache.tag[l].nci_tag, (char *)&i, 4);
	      return(optr);


	  case TAG_MAPPING_HOST:
	       while(isspace(*param)) param++;
	       if(validate_host(param, NULL)<0) return(NULL);
	       DBUG_PRINTF(DBUG_LVL_DIAG, "Host: %s\n", param);
	       optr = tag(optr, tag_cache.tag[l].nci_tag, param, strlen(param));
	       return(optr);

	  case TAG_MAPPING_IP:
	      while(isspace(*param)) param++;
	      if(validate_host(param, &i)) { /* first, try a textual job */
		  DBUG_PRINTF(DBUG_LVL_DIAG, "IP: %s\n", param);
		  optr = tag(optr, tag_cache.tag[l].nci_tag, (char *)&i, 4);
		  return(optr);
	      } /* otherwise, must be a word */
	       set_base(buff, param);
	       if(sscanf(param, buff, &i)!=1) {
		   DBUG_PRINTF(DBUG_LVL_DIAG, "\nwrite_tags: Bad IP word at line: %d --> \"%s\"\n", input_line, param);
		   return(NULL);
		   i = (int)htonl(i);
		   DBUG_PRINTF(DBUG_LVL_DIAG, "IP: 0x%x\n", param);
		   optr = tag(optr, tag_cache.tag[l].nci_tag, (char *)&i, 4);
		   return(optr);
	       }

	  case TAG_MAPPING_PROXY:
	       while(isspace(*param)) param++;
	       if(validate_proxy(param, NULL)<0) {
		   DBUG_PRINTF(DBUG_LVL_DIAG, "\nwrite_tags: Bad Proxy at line: %d --> \"%s\"\n", input_line, param);
		   return(NULL);
	       }
	       DBUG_PRINTF(DBUG_LVL_DIAG, "Proxy: %s\n", param);
	       optr = tag(optr, tag_cache.tag[l].nci_tag, param, strlen(param));
	       return(optr);

	  default:
	      DBUG_PRINTF(DBUG_LVL_DIAG, "\nwrite_tags: Bad tag mapping (%d) for tag %s at line %d --> \"%s\"\n", tag_cache.tag[l].mapping,
		      tag_cache.tag[l].tag, input_line, iptr);
	      return(NULL);
	  } /* end switch */
      } /* end if */
  } /* end for */

  DBUG_PRINTF(DBUG_LVL_DIAG, "\nwrite_tags: Unrecognized tag name at line %d --> \"%s\"\n", input_line, iptr);
  return(NULL);
}

int tag_headers(char *obuff, char *optr)
{
    int bytes;
    int iap_id = 42;

    bytes = optr - obuff;

    DBUG_PRINTF(DBUG_LVL_DIAG, "tag_headers: adding 28 bytes of header info to %d bytes of data\n", bytes);

    memmove(obuff + 28, obuff, bytes);

    tag(obuff, NCIBeginSignatureTag, NULL, bytes+22);
    tag(obuff + 6, NCIIAPConnectMatrixTag, NULL, bytes + 16);
    tag(obuff + 12, NCIGroupTag, NULL, bytes + 10);
    tag(obuff + 18, NCIIAPIDTag, (char *)&iap_id, 4);
    return(bytes+28);
}

int hash(char *obuff, int n)
{
    char nohash[] = "by Ant";

    tag(obuff + n, NCISignatureTag, nohash, strlen(nohash));
    return(n + 6 + strlen(nohash));
}


int validate_host(char *host, unsigned int *ret)
{
    unsigned long l;

    if((l = inet_addr(host))!=-1) { /* first try a dot quad */
	if(ret != NULL) *ret = (unsigned int)l;
	return(1);
    }


    return(1);
}

int validate_proxy(char *proxy, unsigned int *ret)
{
    char *q;

    if((q=strstr(proxy, ":"))==NULL) {
	DBUG_PRINTF(DBUG_LVL_DIAG, "validate_proxy: proxy address has no port at line %d --> \"%s\"\n", input_line, proxy);
	return(-1);
    }

    return(1);
}


int nquotes(char *s)
{
    int n;

    for(n = 0; *s != 0; s++) if(*s == 0x22) n++;
    return(n);
}

int min(int a, int b)
{
    return(a<b?a:b);
}

int read_os_var(char *varname, char *buff, int n)
{
  _kernel_swi_regs r;

  r.r[0] = (int)varname;
  r.r[1] = (int)buff;
  r.r[2] = (buff==NULL)?0x80000000:n;
  r.r[3] = 0;
  r.r[4] = 0;
  if(_kernel_swi(OS_ReadVarVal, &r, &r) != NULL) return(-1);
  if(buff) {
      *(buff + r.r[2]) = 0;
      return(r.r[2]);
  }
  return(-(r.r[2]));

}

int write_os_var(char *varname, char *buff, int n) /* set an OS string variable */
{
    _kernel_swi_regs r;

    r.r[0] = (int)varname;
    r.r[1] = (int)buff;
    r.r[2] = n;
    r.r[3] = 0;
    r.r[4] = 0; /* type string GSTrans once */
  if(_kernel_swi(OS_SetVarVal, &r, &r) != NULL) return(-1);
  return(0);
}


int ispc_ispc_init(void)
{

  DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_ispc_init: setting up URL interface\n");
  if(ispc_url_init()<0) {
      DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_ispc_init: URL init failed\n");
      return(-1);
  }
  return(0);
}

int putline(char *s) /* s is of the form "[tagname] [tag value]" */
{
    int l;
    char *p;
    int nextline;

    DBUG_PRINTF(DBUG_LVL_DIAG, "putline: entered with arg \"%s\" 0x%x\n", s, (int)s);

    if(strlen(s)+ibytes > MAX_BUFF) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "putline: input buffer exhausted\n");
        return(-1);
    }

    if(caseless_strncmp(s, "NEXT", 4)==0) { /* redirect to next ISPcapture page */
      if((p = strchr(s, ' '))==NULL) {
          DBUG_PRINTF(DBUG_LVL_DIAG, "putline: bad ISPcapture page redirect\n");
      } else {
          strncpy(redirect_url, p+1, strlen(p+1));
          DBUG_PRINTF(DBUG_LVL_DIAG, "putline: get redirect URL \"%s\"\n", redirect_url);
          return(0);
      }
    }

    for(l=0; (tag_cache.tag[l].tag != NULL) && (l < MAX_TAG_CACHE); l++) {
        //DBUG_PRINTF(DBUG_LVL_DIAG, "putline: cf. \"%s\" with \"%s\"\n", s, tag_cache.tag[l]);
        if(caseless_strncmp((char *)(tag_cache.tag[l].tag), s, strlen(tag_cache.tag[l].tag))==0) { /* match */
	  DBUG_PRINTF(DBUG_LVL_DIAG, "putline: matched tag %s: ", tag_cache.tag[l].tag);
	  l = -1;
	  break;
	}
    }

    if(l>=0) { /* loop terminated without match */
      DBUG_PRINTF(DBUG_LVL_ERROR, "putline: unrecognized tag - ignoring\n");
      return(0);
    }

    /* now check to see whether it already exists */

    if(ibytes) {
      p = ibuff;
      while((p = getline(p, ibuff, ibytes))!=NULL) {
          nextline = strlen(p)+1;
          //DBUG_PRINTF(DBUG_LVL_DIAG, "putline: comparing %s with previous script entry %s\n", s, p);
          if(caseless_strncmp(s, p, nextline)==0) { /* match */
            *p = '#'; /* comment that sucker out */
            DBUG_PRINTF(DBUG_LVL_DIAG, "putline: previous incarnation of tag discarded\n");
            break;
          }
          p += nextline;
      }
    }
    DBUG_PRINTF(DBUG_LVL_DIAG, "putline: added line \"%s\" to script\n",s);

    strncpy(iptr, s, strlen(s));
    *(iptr + strlen(s)) = '\n';
    ibytes += strlen(s)+1;
    iptr += strlen(s)+1;


    return(1);
}


void collapse_quotes(char *s)
{
    char *q, *pq, *ps;
    int quote = 0;

    if((q = (char *)rmalloc(strlen(s), "CQ buffer"))==NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "collapse_quotes: not enough memory\n");
        return;
    }
    memset(q, 0, strlen(s));
    memcpy(q, s, strlen(s));

    pq = q;
    ps = s;

    while(*ps != 0x0) {
	/* first check for quote status */
	if((*ps == 0x5c) && (*(ps+1) == 0x22)) { /* escaped quote */
	    memcpy(pq, ps, 2);
	    pq+=2;
	    ps+=2;
	    continue;
	}

	else if(*ps == 0x22) { /* bare quote */
	    quote++;
	    ps++;
	    continue;
	}

	else if(isspace(*ps)) { /* white space */
	    if(quote & 1) { /* if inside quotes */
		*pq++ = *ps++; /* copy it */
	    } /* else skip */
	    ps++;
	} else { /* copy it */
	    *pq++ = *ps++;
	}
    }
    *pq = 0;
    //DBUG_PRINTF(DBUG_LVL_DIAG,  "collapse_quotes: from %s to %s\n", s, q);
    strcpy(s, q);
    rmfree((unsigned char *)q);
    return;
}

void expand_ctrls(char *s)
{
    char *q;

    if((q = (char *)rmalloc(strlen(s), "CQ buffer"))==NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "expand_ctrls: not enough memory\n");
        return;
    }
    memset(q, 0, strlen(s));
    memcpy(q, s, strlen(s));

    strccpy(s, q);
    //DBUG_PRINTF(DBUG_LVL_DIAG, "expand_ctrls: from %s to %s\n", s, q);
    rmfree((unsigned char *)q);
    return;
}

/* emulation of POSIX strccpy() libgen.a */
#define MKCTRL(X,Y) case X: *dst++ = Y; \
		       	    src++; \
		       	    break;

char *strccpy(char *dst, char *src)
{
    int n,m;
    char *q = dst;

    if(*src == 0) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "strccpy: empty string\n");
        *dst = 0;
        return(dst);
    }

    //DBUG_PRINTF(DBUG_LVL_DIAG, "strccpy: entered with \"%s\"\n", src);

    src++; /* skip first char - our focus is char _after_ a '\' */

    while(*src != 0x0) {
        if(*(src-1) == '\\') {
            switch(*src) {
	        MKCTRL('a', '\a'); /* audible bell */
	        MKCTRL('b', '\b'); /* backspace */
	        MKCTRL('f', '\f'); /* formfeed */
	        MKCTRL('n', '\n'); /* newline */
	        MKCTRL('r', '\r'); /* carriage-return */
	        MKCTRL('t', '\t'); /* horizontal tab */
	        MKCTRL('v', '\v'); /* vertical tab */
	        MKCTRL('\\', '\\'); /* backslash */
	        MKCTRL('\?', '\?'); /* question mark */
	        MKCTRL('\'', '\''); /* single quote */
	        MKCTRL('\"', '\"'); /* double quote */


	        case 'x': /* uh-oh; hex escape */
	             	  if((sscanf(src, "%2x%n", &n, &m)==1)) {
	             	      //DBUG_PRINTF(DBUG_LVL_DIAG, "strccpy: hex escape, read %d chars\n", m);
	             	      *dst++ = (char)n;
	             	      src += m;
	             	      break;
	             	  }

                default: /* urg, might be an octal escape, or shite */
                	 if((sscanf(src, "%3o%n", &n, &m)==1)) {
                	     //DBUG_PRINTF(DBUG_LVL_DIAG, "strccpy: octal escape, read %d chars.\n", m);
                	     *dst++ = (char)n;
                	     src += m;
                	     break;
                	 }
            } /* endswitch */
	    continue;
        } /* endif backslash */

        if(*src == '\\') { /* skip an opening backslash */
            //DBUG_PRINTF(DBUG_LVL_DIAG, "strccpy: found initial backslash - skipping\n");
            src++;
            continue;
        }

        *dst++ = *src++; /* boring old normal character */
    }
    *dst = 0;
    return(q);
}


int ispc_write_smartcard(int bytes)
{
    _kernel_swi_regs r;

    r.r[0] = (int)obuff;
    r.r[1] = bytes;
    r.r[2] = NULL;
    r.r[3] = 0;
    r.r[4] = 42;
    r.r[5] = NULL;
    r.r[6] = 0;

    if(_kernel_swi(NCBootblock_Write, &r, &r)!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: NCBootblock Write SWI failed\n");
        return(-1);
    }
        switch(r.r[0]) {
            case  0: DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_write_smartcard: completed OK\n");
            	     break;
            case -1: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: enterprise block not authentic\n");
            	     break;

            case -2: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: enterprise block too big\n");
            	     return(-1);
            	     break;

            case -3: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: bootblock is readonly\n");
            	     break;

            case -4: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: enterprise block is readonly\n");
            	     break;

            case -5: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: file write error\n");
            	     return(-1);
            	     break;

            case -6: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: alternate block too big\n");
            	     break;

            case -7: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: alternate block not authentic\n");
            	     break;

            default: DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: unrecognized return code from write SWI\n");
            	     break;
        }

     ispc_hourglass_off();
     do {
         usermode_donothing();
         r.r[0] = 0;
         _kernel_swi(NCBootblock_Status, &r, &r);
     } while((r.r[2] & 0x60)==0);

     ispc_hourglass_off();

     if(r.r[0] & 0x20) {
         DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_write_smartcard: write OK!\n");
         return(0);
     }

     if(r.r[0] & 0x40) {
         DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: write FAILED\n");
         return(-1);
     }

     DBUG_PRINTF(DBUG_LVL_ERROR, "ispc_write_smartcard: eh? bogus status: s->0x%x  d->0x%x\n", r.r[0], r.r[2]);
     return(-1);
}


void ispc_handle_abort(void)
{
#if 0
    if(ui_present()) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_handle_abort: toplevel UI present - fetching\n");
        ispc_url_gsopen(TOPLEVEL_UI_URL);
    } else {
        DBUG_PRINTF(DBUG_LVL_DIAG, "ispc_handle_abort: no toplevel UI, fetching welcome screen\n");
        ispc_url_open(WELCOME_SCREEN_URL);
    }
#endif

    /* the above isn't really correct behaviour any more */
    ispc_url_open("file:/MAScr:connect.html");
    return;
}

void ispc_kick_managed_access(void)
{
    _kernel_swi_regs r;
    static char ncma_boot[] = "ncma_urc connectack";

    r.r[0] = (int)ncma_boot;
    if(_kernel_swi(OS_CLI, &r, &r)!=NULL) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "isp_kick_managed_access: OS_CLI failed!\n");
    }
    return;
}
