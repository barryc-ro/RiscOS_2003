#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"

#define PROTOTYPES_INTERNAL
#include "ispc_cmds.h"
#include "ispc_ispc.h"
#include "ispc_url.h"
#include "ispc_utils.h"
#include "kprintf.h"
#include "dynalloc.h"
#include "ispc_file.h"
#include "DBUG.h"

#define MUNGE2b(a,b) a###b
#define MUNGE3b(a,b,c) a###b##c
#define MUNGE2(a,b) MUNGE2b(a,b)
#define MUNGE3(a,b,c) MUNGE3b(a,b,c)



int cmd_ispc_nullcmd(char *s, int n)
{
  return(0);
}

int cmd_ispc_status(char *s, int n)
{
    kprintf("ISPCapture has no status to report.\n");
    return(0);
}



int cmd_ispc_urc(char *q, int n)
{
    int bytes;
    char *a = NULL;
    char *b = NULL;
    int l, i;
    int newsize = 0;
    char *page_name;
    int tmp;

    memset(cmdargs, 0, 512);
    memcpy(cmdargs, q, 256);
    bytes = strterm(cmdargs);

    DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: got %d args as %d bytes in \"%s\"\n", n, bytes, cmdargs);

    if(n==2) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: looks like a POST method. Trying for file\n");
        if(ispc_parse_file(cmdargs)<0) return(0);
    }

    ispc_parse_url(cmdargs);

    if(strstr(urlv[0], "begin")) { /* fire up our first page */
        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: begin sequence\n");

        memset(redirect_url, 0, MAX_URL);
        memset(end_url, 0, MAX_URL);
        memset(error_url, 0, MAX_URL);
        memset(abort_url, 0, MAX_URL);

        boot_managed_access(); /* build cache without connecting */

	if(ibuff == NULL) {
          if((ibuff = (char *)rmalloc(MAX_BUFF, "ISPC Ibuff"))==NULL) {
              DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: couldn't claim input buffer\n");
              return(0);
          }
        }

	if(obuff == NULL) {
          if((obuff = (char *)rmalloc(MAX_BUFF, "ISPC Obuff"))==NULL) {
              DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: couldn't claim output buffer\n");
              return(0);
          }
        }

	iptr = ibuff;
	optr = obuff;
	ibytes = obytes = 0;

	if(urlc>1) { /* ooh, there's args */
	    for(tmp = 1; tmp < urlc; tmp++) {

            	if(caseless_strncmp(urlv[tmp], "START", 5)==0) {
	      	    if((a = strchr(urlv[tmp], '=')) != NULL) a = a + 1; // find '=, and get param after it
	      	    DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: found START param \"%s\"\n", a);
	      	    continue;
	      	}

	      	if(caseless_strncmp(urlv[tmp], "ABORT", 3) == 0) {
	      	    if((b = strchr(urlv[tmp], '=')) != NULL) {
	      	        b++; // skip the equals
	      	        strncpy(abort_url, b, MAX_URL);
	      	        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: found ABORT param \"%s\"\n", end_url);
	      	    } else {
	      	        DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: found ABORT param with no value - ignoring\n");
	      	    }
	      	    continue;
	      	}

	      	if(caseless_strncmp(urlv[tmp], "END", 3) == 0) {
	      	    if((b = strchr(urlv[tmp], '=')) != NULL) {
	      	        b++; // skip the equals
	      	        strncpy(end_url, b, MAX_URL);
	      	        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: found END param \"%s\"\n", end_url);
	      	    } else {
	      	        DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: found END param with no value - ignoring\n");
	      	    }
	      	    continue;
	      	}

	      	if(caseless_strncmp(urlv[tmp], "ERROR", 5) == 0) {
	      	    if((b = strchr(urlv[tmp], '=')) != NULL) {
	      	        b++; // skip the equals
	      	        strncpy(error_url, b, MAX_URL);
	      	        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: found ERROR param \"%s\"\n", error_url);
	      	    } else {
	      	        DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: found ERROR param with no value - ignoring\n");
	      	    }
	      	    continue;
	      	}

    	    	DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: found unknown param \"%s\" - ignoring\n", urlv[tmp]);
    	    }
    	}

    	if(a != NULL) { // we have  a BEGIN url
	    DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: attempting to fetch URL \"%s\"\n", a);
	    ispc_url_open(a);
	    return(0);
	}

    	// if we get here, 'begin' was either invalid, or not specified

	if(read_os_var(ISPCAPTURE_VAR_NAME, redirect_url, 256)>0) {
	    DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: redirect from env. var. \"%s\"\n", redirect_url);
	    if((page_name = preprocess_file(url_to_file(redirect_url)))!=NULL) {
	    	DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: preprocessed to \"%s\"\n", page_name);
		ispc_url_open(page_name);
	    } else {
		DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: preprocessing failed...using as is\n");
	        ispc_url_open(redirect_url);
	    }
	    memset(redirect_url, 0, 256);
	} else {
	    if((page_name = preprocess_file(url_to_file(URL_PATH(ISPC1))))!=NULL) {
	    	DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: preprocessed \"%s\" to \"%s\"\n", URL_PATH(ISPC1), page_name);
	        ispc_url_open(page_name);
	    } else {
	    	DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: preprocess failed, fetching \"%s\"\n", URL_PATH(ISPC1));
	        ispc_url_open(URL_PATH(ispc1));
	    }
	}
        return(0);
    }

    if(strstr(urlv[0], "submit")) { /* add a page of args */
        if(ibuff == NULL) {
            DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: no workspace for input buffer - ignoring\n");
            return(-1);
        }
        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: args submitted\n");
        /* add args to 'script' */
        for(l = 1; l<urlc; l++) {
            DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_handler: calling PutLine with arg %d \"%s\" 0x%x\n", l, urlv[l], (int)urlv[l]);
#ifdef ENABLE_DEBUGGING
            cmd_ispc_showargs(NULL, 0);
#endif
	    if((a = strchr(urlv[l], '='))!=NULL) *a = 0x20; /* replace = with SPC */
	    else {
	        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_handler: tag has no arguments!\n");
	        continue;
	    }

	    for(i=0; *a!=0x0;a++) if((isgraph(*a)) && (*a!=0x22)) i++; /* any actual args? */

	    if(i==0) {
	        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_handler: tag has null args - ignoring\n");
	        continue;
	    }

            if(putline(urlv[l])<0) {
                DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_handler: barfed on PutLine return\n");
                return(0);
            }
        }

        if(*redirect_url != 0) { // set when putline encounters a 'next=...' tag
            DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: redirecting to %s\n", redirect_url);
            if((caseless_strncmp(redirect_url, "compile", 7)==0) ||
               (caseless_strncmp(redirect_url, "ispcapture:compile", 18)==0))  goto compile_block;
            if((page_name = preprocess_file(url_to_file(redirect_url)))!=NULL) {
                DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_irc: preprocessed to \"%s\"\n", page_name);
                ispc_url_open(page_name);
            } else {
                DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: preprocessing failed...using as is\n");
                ispc_url_open(redirect_url);
            }
            memset(redirect_url, 0, 256);
        }
        return(0);
    }

    if(strstr(urlv[0], "compile")) { /* compile args */
        compile_block:
    	DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: compile submitted args\n");
    	if((newsize = ispc_compile())<0) {
    	    DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: compilation aborted\n");
    	    return(0);
    	}

	DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: final blocksize %d bytes\n", newsize);
    	if(ispc_write_smartcard(newsize)<0) {
    	    DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: arse; smartcard write failed - aborting\n");
    	    ispc_completed(ispc_FINISH_ERROR);
    	} else {
    	    ispc_completed(ispc_FINISH_SUCCESS); /* start the dial up again */
    	}

    	if(ibuff != NULL) ibuff = (rmfree((unsigned char *)ibuff),(char *)NULL);
    	if(obuff != NULL) obuff = (rmfree((unsigned char *)obuff),(char *)NULL);
    	return(0);
    }

    if(strstr(urlv[0], "abort")) {/* user bottled it */
      DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: abort received\n");
      ispc_completed(ispc_FINISH_ABORT);
    }


    return(0);
}

int cmd_ispc_memory(char *s, int n)
{
    rmstat();
    return(0);
}

int cmd_ispc_showargs(char *s, int n)
{
    int l;

    kprintf("Last arg list:\n\n");
    for(l=0; l<urlc; l++)
        DBUG_PRINTF(DBUG_LVL_DIAG, "\t\targ %d: %s\t\t0x%x\n", l, urlv[l], (int)urlv[l]);
    kprintf("\n\n");
    return(0);
}

int cmd_ispc_showscript(char *s, int n)
{
    char *p;


    kprintf("Current internal script:\n\n");
    if(ibuff==NULL) {
        kprintf("No script.\n");
        return(0);
    }
    for(p=ibuff; (p=getline(p, ibuff, ibytes))!=NULL; p+=(strlen(p)+1)) kprintf("\t> %s\n", p);
    kprintf("\n\n");
    return(0);
}

int cmd_ispc_parsescript(char *s, int n)
{
    char *src, *dst;
    int sn, dn;
    FILE *f;

    if((src = (char *)rmalloc(4096, "ParseScript"))==NULL) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_parsescript: couldn't claim workspace\n");
     	return(0);
    }

    sn = dn = 2048;
    dst = src + sn;

    if((f = fopen(s, "r"))==NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "cms_ispc_parsescript: couldn't open file\n");
        return(0);
    }

    sn = fread(src, 1, 2048, f);
    fclose(f);

    dn = format_script(src, sn, dst, dn);

    DBUG_PRINTF(DBUG_LVL_DIAG, "%.*s\n", dn, dst);
    rmfree((unsigned char *)src);
    return(0);
}
