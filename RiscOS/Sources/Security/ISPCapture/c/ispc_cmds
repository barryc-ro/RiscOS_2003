#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"

#define PROTOTYPES_INTERNAL
#include "ispc_cmds.h"
#include "ispc_ispc.h"
#include "ispc_url.h"
#include "ispc_utils.h"
#include "kprintf.h"
#include "dynalloc.h"
#include "DBUG.h"

#define MUNGE2b(a,b) a###b
#define MUNGE3b(a,b,c) a###b##c
#define MUNGE2(a,b) MUNGE2b(a,b)
#define MUNGE3(a,b,c) MUNGE3b(a,b,c)



int cmd_ispc_nullcmd(char *s, int n)
{
  return(0);
}

int cmd_ispc_status(char *s, int n)
{
    kprintf("ISPCapture has no status to report.\n");
    return(0);
}



int cmd_ispc_urc(char *q, int n)
{
    int bytes;
    char *a;
    int l, i;
    int newsize = 0;

    memset(cmdargs, 0, 512);
    memcpy(cmdargs, q, 256);
    bytes = strterm(cmdargs);

    DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: got %d args as %d bytes in \"%s\"\n", n, bytes, cmdargs);

    if(n==2) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: looks like a POST method. Trying for file\n");
        if(ispc_parse_file(cmdargs)<0) return(0);
    }

    ispc_parse_url(cmdargs);

    if(strstr(urlv[0], "begin")) { /* fire up our first page */
        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: begin sequence\n");

        memset(redirect_url, 0, 256);

	if(ibuff == NULL) {
          if((ibuff = (char *)rmalloc(MAX_BUFF, "ISPC Ibuff"))==NULL) {
              DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: couldn't claim input buffer\n");
              return(0);
          }
        }

	if(obuff == NULL) {
          if((obuff = (char *)rmalloc(MAX_BUFF, "ISPC Obuff"))==NULL) {
              DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: couldn't claim output buffer\n");
              return(0);
          }
        }

	iptr = ibuff;
	optr = obuff;
	ibytes = obytes = 0;

	if(urlc>1) { /* ooh, there's an arg */
          if(caseless_strncmp(urlv[1], "START", 5)==0) {
	  /*if(strstr(urlv[1], "START")) {*/
	      a = strchr(urlv[1], '=') + 1;
	      DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: attempting to fetch URL \"%s\"\n", a);
	      ispc_url_open(a);
	  } else {
	      DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: bad parameter to ISPCature:begin\n");
	      return(0);
	  }
	} else {
	    if(read_os_var(ISPCAPTURE_VAR_NAME, redirect_url, 256)>0) {
	        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: redirect from env. var. \"%s\"\n", redirect_url);
	        ispc_url_open(redirect_url);
	        memset(redirect_url, 0, 256);
	    } else {
	        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: no redirects, fetching \"%s\"\n", URL_PATH(ISPC1.html));
	        ispc_url_open(URL_PATH(ispc1.html));
	    }
        }
        return(0);
    }

    if(strstr(urlv[0], "submit")) { /* add a page of args */
        if(ibuff == NULL) {
            DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: no workspace for input buffer - ignoring\n");
            return(-1);
        }
        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: args submitted\n");
        /* add args to 'script' */
        for(l = 1; l<urlc; l++) {
            DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_handler: calling PutLine with arg %d \"%s\" 0x%x\n", l, urlv[l], (int)urlv[l]);
#ifdef ENABLE_DEBUGGING
            cmd_ispc_showargs(NULL, 0);
#endif
	    if((a = strchr(urlv[l], '='))!=NULL) *a = 0x20; /* replace = with SPC */
	    else {
	        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_handler: tag has no arguments!\n");
	        continue;
	    }

	    for(i=0; *a!=0x0;a++) if((isgraph(*a)) && (*a!=0x22)) i++; /* any actual args? */

	    if(i==0) {
	        DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_handler: tag has null args - ignoring\n");
	        continue;
	    }

            if(putline(urlv[l])<0) {
                DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_handler: barfed on PutLine return\n");
                return(0);
            }
        }

        if(*redirect_url != 0) {
            DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: redirecting to %s\n", redirect_url);
            if(caseless_strncmp(redirect_url, "compile", 6)==0) goto compile_block;
            ispc_url_open(redirect_url);
            memset(redirect_url, 0, 256);
        }
        return(0);
    }

    if(strstr(urlv[0], "compile")) { /* compile args */
        compile_block:
    	DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: compile submitted args\n");
    	if((newsize = ispc_compile())<0) {
    	    DBUG_PRINTF(DBUG_LVL_ERROR, "cmd_ispc_urc: compilation aborted\n");
    	    return(0);
    	}

	DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: final blocksize %d bytes\n", newsize);
    	if(ispc_write_smartcard(newsize)<0) {
    	    DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: arse; smartcard write failed - aborting\n");
    	    ispc_handle_abort();
    	} else {
    	    ispc_kick_managed_access(); /* start the dial up again */
    	}

    	if(ibuff != NULL) ibuff = (rmfree((unsigned char *)ibuff),(char *)NULL);
    	if(obuff != NULL) obuff = (rmfree((unsigned char *)obuff),(char *)NULL);
    	return(0);
    }

    if(strstr(urlv[0], "abort")) {/* user bottled it */
      DBUG_PRINTF(DBUG_LVL_DIAG, "cmd_ispc_urc: abort received\n");
      ispc_handle_abort();
    }


    return(0);
}

int cmd_ispc_memory(char *s, int n)
{
    rmstat();
    return(0);
}

int cmd_ispc_showargs(char *s, int n)
{
    int l;

    kprintf("Last arg list:\n\n");
    for(l=0; l<urlc; l++)
        DBUG_PRINTF(DBUG_LVL_DIAG, "\t\targ %d: %s\t\t0x%x\n", l, urlv[l], (int)urlv[l]);
    kprintf("\n\n");
    return(0);
}

int cmd_ispc_showscript(char *s, int n)
{
    char *p;


    kprintf("Current internal script:\n\n");
    if(ibuff==NULL) {
        kprintf("No script.\n");
        return(0);
    }
    for(p=ibuff; (p=getline(p, ibuff, ibytes))!=NULL; p+=(strlen(p)+1)) kprintf("\t> %s\n", p);
    kprintf("\n\n");
    return(0);
}
