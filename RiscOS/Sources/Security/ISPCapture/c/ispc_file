/* ispc_file.c - preprocess html pages to insert current tag values. By Ant. */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"
#include "dynalloc.h"
#define PROTOTYPES_INTERNAL
#include "ispc_file.h"
#include "ispc_ispc.h"
#include "ispc_cache.h"
#include "ispc_utils.h"
#include "DBUG.h"

char *preprocess_file(char *fname_in)
{
    static char *buffer = NULL;

    char *fname = NULL;
    char *data = NULL;
    char *working = NULL;
    char *tag_buff = NULL;
    char *data_ptr = NULL;

    int bytes = 0, n = 0, tag_bytes = 0, m = 0;
    int substitution = 0;
    int active_html = 1; /* not within an html comment block */
    int end_of_html = 0;

    FILE *fin, *fout;

    TBUF tokens[5];

    /* once only memory grab */

    if(buffer == NULL) {
        if((buffer=(char *)rmalloc(8*WORK_BUF_SIZE, "ISPCapture"))==NULL) {
            DBUG_PRINTF(DBUG_LVL_ERROR, "preprocess_file: couldn't allocate workspace\n");
            return NULL;
        } else {
            DBUG_PRINTF(DBUG_LVL_DIAG, "preprocess_file: workspace allocated ok\n");
        }
    }

    /* build a temporary file for the output */
    /* strcpy(buffer, WIMP_SCRAPDIR ".");  hmm, tmpnam seems to sort out the scrapdir as well - naughty */
    /* strcat(buffer, tmpnam(NULL)); */
    strcpy(buffer, tmpnam(NULL));
    DBUG_PRINTF(DBUG_LVL_DIAG, "preprocess_file: temp. file \"%s\"\n", buffer);
    fname = buffer;
    working = fname + ((strlen(fname)+8) &~3);
    tag_buff = working + WORK_BUF_SIZE;
    data = tag_buff + WORK_BUF_SIZE;
    data_ptr = data;

    /* open the input */

    if((fin = fopen(fname_in, "r"))==NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "preprocess_file: couldn't open input \"%s\"\n", fname_in);
        return NULL;
    }

    while(!end_of_html && ((n = fgetline(fin, working, WORK_BUF_SIZE))>0)) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "preprocess_file: -->%s\n", working);

        if(caseless_strnstr(working, "</html>", n, 7)!=NULL) { /* no more html */
           DBUG_PRINTF(DBUG_LVL_DIAG, "preprocess_file: closing html tag encountered - truncating file\n");
           end_of_html = 1;
        }

        parsing_form(working, n, &substitution, &active_html); /* are we within <form>....</form> construct? */

        if(substitution & active_html) { /* yup */

            if(find_tokens(working, n, tokens)) { /* look for (<.*name=")(.*)(".*value=")(.*)(".*) */

                DBUG_PRINTF(DBUG_LVL_DIAG, "preprocess_file: tokens found\n");
                tag_bytes = find_tag(&tokens[1], tag_buff, WORK_BUF_SIZE); /* lookup tag, rewrite token if found */

                if(tag_bytes>0) {

                    m = rewrite_line(tokens, data_ptr, tag_buff, tag_bytes);

                    if(m) {
                      bytes += m;
                      data_ptr = data + bytes;
                      continue; /* next line */
                    } else {
                        DBUG_PRINTF(DBUG_LVL_DIAG, "preprocess_file: unrecognized tag, dumping line\n");
                        continue;
                    }

                } else { /* didn't recognize the tag within the name="" parameter */

                    if(caseless_strnstr(tokens[1].ptr, "next", 4, 4)!=NULL) {
                        DBUG_PRINTF(DBUG_LVL_DIAG, "preprocess_file: it's a NEXT tag - passing thru\n");
                        /* fall thru to bottom of outside if */
                    } else if(token_lookup(&tokens[1])>=0) { /* tag exists, but there's no corresponding data on the card */
                        DBUG_PRINTF(DBUG_LVL_DIAG, "preprocess_file: valid tag, but no info\n");
                    } else {
                        DBUG_PRINTF(DBUG_LVL_ERROR, "preprocess_file: unrecognized tag, passing thru\n");
                        /* continue; NOOO!!! Might not be our form, so fall thru */
                    }
                }

            } else {
                DBUG_PRINTF(DBUG_LVL_DIAG, "preprocess_file: line contains no tokens\n");
            }
        }
        /* all other cases, just copy the line */
        memcpy(data_ptr, working, n);
        data_ptr += n;
        bytes += n;

    } /* next line */

    fclose(fin);

    if((fout = fopen(fname, "w"))==NULL) { /* open output file */
       DBUG_PRINTF(DBUG_LVL_ERROR, "preprocess_files: couldn't open temp file for output \"%s\"\n", fname);
       return NULL;
    }

    if(fwrite(data, bytes, 1, fout)!=1) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "preprocess_files: error writing to \"%s\"\n", fname);
        fclose(fout);
        return NULL;
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "preprocess_files: wrote %d bytes to \"%s\" ok\n", bytes, fname);
    fclose(fout);
    return(file_to_url(fname)); /* grind the filename */
}

/* get a line from a file into our buffer, limited by the buffer size, don't terminate */
int fgetline(FILE *f, char *buf, int maxb)
{
    int bytes = 0;
    char c;

    memset(buf, 0, maxb);

    while(maxb && !feof(f)) {
        c = (char)getc(f);
        switch(c) {
            case '\n':
            case '\r':  *buf++ = c; return(bytes+1);
            default:    bytes++; maxb++; *buf++ = c;
        }
    }
    if(feof(f)) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "fgetline: end of file, returning %d bytes\n", bytes);
    } else {
        DBUG_PRINTF(DBUG_LVL_DIAG, "fgetline: buffer full, returned partial line (%d bytes)\n", bytes);
    }
    return(bytes);
}

/* determine whether we're within in <form>...</form> construct
   this doesn't handle nested forms, because they shouldn't crop up, nor does it handle smartass
   stuff like <form> within comments, strings, etc. which no doubt Neil will try  */
int parsing_form(char *buf, int bytes, int *flag, int *cflag)
{
    switch(*flag) {

        case 0x0: /* we're not currently within the construct */
             	  if(caseless_strnstr(buf, "<form", bytes, 5)!=NULL) { /* found it */
             	      DBUG_PRINTF(DBUG_LVL_DIAG, "parsing_form: substitution ON\n");
             	      *flag = 1;
             	  }
             	  break;

        case 0x1: /* we're already within the construct */
                  if(caseless_strnstr(buf, "</form>", bytes, 7)!=NULL) {  /* found it */
                      DBUG_PRINTF(DBUG_LVL_DIAG, "parsing_form: substitution OFF\n");
                      *flag = 0;
                  }
                  break;
    }

    switch(*cflag) {

        case 0x0: /* we're in a comment block */
             	  if(caseless_strnstr(buf, "<!--", bytes, 4)!=NULL) { /* found it */
             	      DBUG_PRINTF(DBUG_LVL_DIAG, "parsing_form: active html OFF\n");
             	      *cflag = 1;
             	  }
             	  break;

        case 0x1: /* we're in active code */
                  if(caseless_strnstr(buf, "-->", bytes, 3)!=NULL) {  /* found it */
                      DBUG_PRINTF(DBUG_LVL_DIAG, "parsing_form: active html ON\n");
                      *cflag = 0;
                  }
                  break;
    }



    return(*flag);
}

/* caseless, byte limited sub string match
   n is length of str buffer */
char *caseless_strnstr(char *str, char *substr, int n, int m)
{
    char *ss_ptr = substr;
    int s;

    s = m;
    while(n) {
        if(toupper(*str++) == toupper(*ss_ptr++)) { /* chars match */
          if(--n,--s) continue; /* chars left */
          return(str-m); /* substr exhausted - match */
        } else { /* mismatch */
          n--;
          if(ss_ptr != substr) { /* reset if we're part way thru a match */
              ss_ptr = substr;
              s = m;
          }
        }
    } /* string buffer exhausted, no match */
    return NULL;
}

/* tokenize a form line of the form name="..."   value="..."
   TBUFs are pointer/length structs, 'tokens' points to five of them,
   1st is start of line, up to opening quote of name="..."
   2nd is name parameter, not including closing quote
   3rd is closing quote of name="..." up to opening quote of value=".."
   4th is value paramter, not including closing quote
   5th is closing quote of value=".." to end of line */
int find_tokens(char *buf, int n, TBUF *tokens)
{
   char *t;

   tokens->ptr = buf;
   t = caseless_strnstr(buf, "name=", n, 5);
   if(t == NULL) return NULL;

   while(*t++ != '\"'); /* find opening quote of name="..." */
   tokens->len = t-buf;
   DBUG_PRINTF(DBUG_LVL_DIAG, "find_tokens: %.*s\n", tokens->len, tokens->ptr);

   (++tokens)->ptr = t;
   while(*t != '\"') t++; /* find char preceeding closing quote of name="..." */
   tokens->len = t-tokens->ptr;
   DBUG_PRINTF(DBUG_LVL_DIAG, "find_tokens: %.*s\n", tokens->len, tokens->ptr);


   (++tokens)->ptr = t; /* closing quote of name=".." */
   t = caseless_strnstr(t, "value=", n-(t-buf), 6);
   if(t == NULL) return NULL;
   while(*t++ != '\"'); /* find opening quote of value="..." */
   tokens->len = t-tokens->ptr;
   DBUG_PRINTF(DBUG_LVL_DIAG, "find_tokens: %.*s\n", tokens->len, tokens->ptr);


   (++tokens)->ptr = t; /* first char of value arg */
   while(*t != '\"') t++; /* find char preceeding closing quote of value="..." */
   tokens->len = t-tokens->ptr;
   DBUG_PRINTF(DBUG_LVL_DIAG, "find_tokens: %.*s\n", tokens->len, tokens->ptr);


   (++tokens)->ptr = t;  /* start of value parameter */
   while(!iscntrl(*t++)); /* skip to end of line */
   tokens->len = t-tokens->ptr;
   DBUG_PRINTF(DBUG_LVL_DIAG, "find_tokens: %.*s\n", tokens->len, tokens->ptr);


   return(1);
}

/* find_tag - do a managed access tag lookup */
int find_tag(TBUF *tag, char *buf, int n)
{
    _kernel_swi_regs r;
    char *s;

    /* copy byte-counted string and terminate it for managed access use */
    if((s = malloc(tag->len+4))==NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "find_tag: couldn't malloc\n");
        return(-1);
    }
    memset(s, 0, tag->len+4);
    memcpy(s, tag->ptr, tag->len);

    DBUG_PRINTF(DBUG_LVL_DIAG, "find_tag: looking for \"%s\" to %d bytes at 0x%x\n", s, n, buf);

    r.r[0] = (int)s;
    r.r[1] = (int)buf;
    r.r[2] = n;

    if(_kernel_swi(ManagedAccess_Enquiry, &r, &r)!=NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "find_tag: MA Enquiry failed\n");
        return(-1);
    }

    free(s);

    if(r.r[0]<0) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "find_tag: tag lookup failed with code %d\n", r.r[0]);
        return(-1);
    }

    return(r.r[0]);
}


/* rewrite_line - do value replacement for tokenized line */
int rewrite_line(TBUF *tokens, char *data_ptr, char *tag_buf, int tag_bytes)
{
    int mapping;
    int bytes = 0;
    unsigned int temp_word;
    int temp;
    int script = 0;

    if((mapping = token_lookup((tokens+1)))<0) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "rewrite_line: token lookup failed for token \"%.*s",
        			    (tokens+1)->len, (tokens+1)->ptr);
        return(-1);
    }

    if(caseless_strnstr((tokens+1)->ptr, "SEND_EXPECT", (tokens+1)->len, 11)) script = 1;

    memcpy(data_ptr, tokens->ptr, tokens->len);  /* do the preamble */
    bytes += tokens->len;
    tokens++;

    memcpy(data_ptr + bytes, tokens->ptr, tokens->len); /* do the tag name */
    bytes += tokens->len;
    tokens++;

    memcpy(data_ptr + bytes, tokens->ptr, tokens->len); /* do the stuff in the middle */
    bytes += tokens->len;
    tokens++;

    switch(mapping) { /* do the value replacement */

        case TAG_MAPPING_STRING:  /* it's a (non-termiated) string */
             if(script)  { /* great - it's the script */
               bytes += format_script(tag_buf, tag_bytes, data_ptr+bytes, WORK_BUF_SIZE - bytes);
               break;
             }

        case TAG_MAPPING_HOST: /* it's a hostname / textual IP - just like a string */
        case TAG_MAPPING_PROXY: /* a proxy, also looks like a string */
             memcpy(data_ptr+bytes, tag_buf, tag_bytes);
             bytes += tag_bytes;
             break;

        case TAG_MAPPING_INT:  /* it's an unsigned int, big endian */
             temp_word = read_big_word(tag_buf);
             temp = sprintf(tag_buf, "%d", temp_word); /* overwrite tag buf - it's at least WORK_BUF_SIZE big */
             memcpy(data_ptr + bytes, tag_buf, temp);
             bytes += temp;
             break;


        case TAG_MAPPING_IP: /* an IP address word, big endian */
             temp_word = *(unsigned int *)tag_buf;  /* overwrite tag_buf again */
             temp = sprintf(tag_buf, "%d.%d.%d.%d", temp_word & 0xff,
             	    		     		    (temp_word >> 8) & 0xff,
             	    		     		    (temp_word >> 16)  & 0xff,
             	    		     		    temp_word >> 24) & 0xff;
             memcpy(data_ptr + bytes, tag_buf, temp);
             bytes += temp;
             break;

        case TAG_MAPPING_SOAK:
        case TAG_MAPPING_PLIP: /* we're not allowing these, for the time being */
             DBUG_PRINTF(DBUG_LVL_ERROR, "rewrite_line: AARGHHH! Brian Rice tokens! Panic!\n");
             return(-1);
    }

    tokens++;
    memcpy(data_ptr + bytes, tokens->ptr, tokens->len);  /* do all the trailing stuff */
    bytes += tokens->len;
    return(bytes);
}

/* find mapping type for a given token */
int token_lookup(TBUF *token)
{
   int l = 0;

   DBUG_PRINTF(DBUG_LVL_DIAG, "token_lookup: looking up %.*s\n", token->len, token->ptr);

   for(l=0; l<MAX_TAG_CACHE;l++) {
       if(tag_cache.tag[l].tag == NULL) break;
       DBUG_PRINTF(DBUG_LVL_DIAG, "token_lookup: \"%.*s\" CF \"%s\"\n", token->len, token->ptr, tag_cache.tag[l].tag);
#if 0
       if(caseless_strnstr((char *)(tag_cache.tag[l].tag), token->ptr,
       				 strlen(tag_cache.tag[l].tag),token->len))
         return(tag_cache.tag[l].mapping);
#else
    { // new block
    	int tmp;

    	tmp = strlen(tag_cache.tag[l].tag) < token->len ? strlen(tag_cache.tag[l].tag) : token->len;
       if(caseless_strncmp((char *)(tag_cache.tag[l].tag), token->ptr, tmp) == 0)
            return(tag_cache.tag[l].mapping);
    }
#endif
   }

   return(-1);
}

/* grind a url into a risc os filename */
char *url_to_file(char *s)
{
    char *p, *q;

    if((p = caseless_strnstr(s, "file://", strlen(s),7))!=NULL) p+=7;
    else if((p = caseless_strnstr(s, "file:/", strlen(s),6))!=NULL) p+=6;
    else p = s;

    for(q=p;*q!=0;q++) { /* do separator mappings */
        if(*q == '/') *q = '.';
        else if(*q == '.') *q = '/';
    }
    return(p);
}

/* grind a risc os filename into a url  - filename buffer must have space for 6 more characters */
char *file_to_url(char *s)
{
    char *q;
    static char urc[] = "file:/";
    _kernel_swi_regs r;

    /* new file is untyped, so type it */
    r.r[0] = 18; /* write file type */
    r.r[1] = (int)s;
    r.r[2] = 0xfaf;
    _kernel_swi(OS_File, &r, &r);

    memmove(s+6,s,strlen(s)+1); /* shunt the filename up */
    memcpy(s, urc, 6); /* bung the urc on the front */

    for(q=s+6;*q!=0;q++) { /* undo separator mappings */
        if(*q == '/') *q = '.';
        else if(*q == '.') *q = '/';
    }

    return(s);

}


void boot_managed_access(void)
{
    _kernel_swi_regs r;

    r.r[0] = 0; /* NCMA_MISCOP_CONNECT */
    _kernel_swi(ManagedAccess_MiscOp, &r, &r);
    return;
}

/* turn an internally formatted script into something nicer */
int format_script(char *src, int sn, char *dest, int dn)
{
  int newlines = 0; /* number of newlines encountered so far */
  char *dp = dest;
  int bytes = 0;

  DBUG_PRINTF(DBUG_LVL_DIAG, "format_script: starting with \"%.*s\"\n", sn, src);
  DBUG_PRINTF(DBUG_LVL_DIAG, "format_script: sn=%d,dn=%d\n", sn, dn);

  sprintf(dest, "&quot;"); /* opening quote */
  dn-=6;
  dest+=6;
  while(dn-- && sn--) { /* src and target available */
    switch(*src) {

        case '&' : sprintf(dest, "&amp;"); dn += 4; dest+= 5; break;
        case '<' : sprintf(dest, "&lt;"); dn += 3; dest+= 4; break;
        case '>' : sprintf(dest, "&gt;"); dn += 3; dest+= 4; break;
        case '\"': sprintf(dest, "&quot;"); dn+= 5; dest+= 6;break;

        case '\a': *dest++ = '\\'; *dest++ = 'a'; dn++; break;
        case '\b': *dest++ = '\\'; *dest++ = 'b'; dn++; break;
        case '\f': *dest++ = '\\'; *dest++ = 'f'; dn++; break;
        case '\r': *dest++ = '\\'; *dest++ = 'r'; dn++; break;
        case '\t': *dest++ = '\\'; *dest++ = 't'; dn++; break;
        case '\v': *dest++ = '\\'; *dest++ = 'v'; dn++; break;
        case '\\': *dest++ = '\\'; *dest++ = '\\'; dn++; break;
        case '\?': *dest++ = '\\'; *dest++ = '\?'; dn++; break;
        case '\'': *dest++ = '\\'; *dest++ = '\''; dn++; break;
        case '\n': *dest++ = '\\'; *dest++ = 'n'; dn++;
	     	   newlines++;
	     	   if((newlines % 2)==0) { /* ooo, second of a pair of newlines detected */
		     sprintf(dest, "&quot; &quot;");
	     	     dn -= 12;
	     	     dest += 13;
	     	   }
	     	   break;

        default:
           if(iscntrl(*src)) { /* do hex escapes */
               sprintf(dest, "\\x%.2x", (int)(*src));
               dn -= 3;
               dest += 4;
           } else {
             *dest++ = *src;
           }
           break;
    }
    src++;
  }

  bytes = dest - dp;

  if(sn <= 0) { /* source exhausted */
    if((newlines %2) == 0) { /* did we just add a quote-spc-quote combo? */
      DBUG_PRINTF(DBUG_LVL_DIAG, "format_script: removing space-quote padding from end of script:\n");
      DBUG_PRINTF(DBUG_LVL_DIAG, "format_script:--> %.*s (%d)\n", bytes, dp, bytes);
      /* bytes -= 7; can't do this, because if the input is a NUL terminated string, the script unmunger will
                     have turned the NUL into the C escape \x00 - result: crap on the end of your script */
      while(*dest-- != '&') bytes--;
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "format_script: returning \"%.*s\" (%d)\n", bytes, dp, bytes);

    return(bytes);
  }

  if(dn <= 0) { /* destination exhausted */
    DBUG_PRINTF(DBUG_LVL_DIAG, "format_script: destination buffer exhausted\n");
    return(bytes);
  }

  DBUG_PRINTF(DBUG_LVL_ERROR, "format_script: shouldn't be here: sn=%d, dn=%d\n",sn,dn);
  return(0);
}











