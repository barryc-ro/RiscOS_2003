#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

/* includes for other segments */

#define PROTOTYPES_INTERNAL
#include "module.h"
#include "DBUG.h"
#include "dynalloc.h"
#include "ispc_ispc.h"
#include "ispc_cmds.h"


#ifdef USE_TINY
static _kernel_oserror *TinyError;
#endif

/* code */

_kernel_oserror *module_init(char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror f = {0x00810800, "ISPcapture failed to initialize."}, *e = NULL;
    _kernel_swi_regs r;
    static char keyword[] = "verbose/s,file/k,debug/k/e";

    static int args[32];
    char *argp, *debug_file;
    int debug_lvl = 0;

    module_wsp = pw;

#ifdef USE_TINY
  /*
   * try to use TinyStubs if possible.
   */
    r.r[0] = (int)module_wsp;
    TinyError = _kernel_swi(TinySupport_Share, &r, &r);
#endif

   r.r[0] = (int)keyword;
   r.r[1] = (int)cmd_tail;
   r.r[2] = (int)args;
   r.r[3] = 128;
   memset((char *)args, 0, 32 * sizeof(int));
   _kernel_swi(OS_ReadArgs, &r, &r);


   if(args[0]) quiet = 0;

   QUIET printf("RISC OS ISPcapture Version %s\n", ISPC_VERSION);

   if(args[1] != 0) debug_file = (char *)args[1];
   else debug_file = NULL;

   if(args[2]) { /* debug value present */
     argp = (char *)args[2];
     if(*argp++ == 0) {
       debug_lvl = *((int *)argp);
       if(debug_lvl <0) debug_lvl = 0;
       if(debug_lvl >5) debug_lvl = 5;
       if(debug_file == NULL) DBUG_FOPEN("stdout", "ISPcapture");
       else DBUG_FOPEN(debug_file, "ISPcapture");
       DBUG_LEVEL(debug_lvl);
       QUIET {
         printf("ispc_init: debug level set to %d\n", debug_lvl);
         if(debug_file != NULL) printf("ncma_init: debug file: %s\n", debug_file);
       }
     }
   }

   QUIET printf("ispc_init: initialising memory subsystem...\n");
   rminit();

   QUIET printf("ispc_init: registering resources...\n");
   resource_init();

   if(use_dynamic_areas) {
     QUIET printf("ispc_init: dynamic area support detected...\n");
   } else {
     QUIET printf("ispc_init: no dynamic area support found...\n");
   }

   QUIET printf("ispc_init: initialising ISPC subsystem...\n");

   if(ispc_ispc_init()<0) {
     QUIET printf("ispc_init: ncma init failed.\n");
     e = &f;
     goto out;
   };

   return ((_kernel_oserror *)0);

out:
   QUIET printf("ispc_init: Bummer!\n");
   return (e);
}



_kernel_oserror *module_cmd_handler(char *arg_string, int argc, int cmd_no, void *pw)
{
    struct cmdent *callp;
    int error;

    callp = &ispc_cmdent[cmd_no];
    error = (*(callp->cmd_call))(arg_string, argc);
    return((_kernel_oserror *)NULL);

}



_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
#ifdef USE_TINY
  _kernel_swi_regs r;
  if ( TinyError == NULL ) _kernel_swi( TinySupport_Die, &r, &r);
#endif


  QUIET printf("ispc_final: releasing memory resources...\n");
  rmfree_all();

  QUIET printf("ispc_final: freeing resources...\n");
  resource_final();

  QUIET printf("ispc_final: done.\n");
  DBUG_FCLOSE();

  return((_kernel_oserror *)NULL);
}





