/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

/*
 * The following routines for des encryption and decryption have been
 * derived from sources kindly supplies by InCard SPA.
 *
 * Modification History
 *---------------------
 *
 * 20-Jan-97 RWB First compiled.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <float.h>

#include "module.h"
#include "des.h"
#include "destbl.h"

/*
 * local prototypes
 */

void xor(uchar *a, uchar *b, int n);
void bitset(uchar *a, int n);
int  bittest(uchar *b, int n);
void permut(uchar *a, uchar *b, int *c);
void shift(uchar *a, int n);
void keygen(uchar *a);
void select(uchar *a, uchar *b, int c[][4][16]);
void fctf(uchar *a, uchar *b, uchar *c);

/*
 ******************** Tripple DES ENCRYPTION / DECRYPTION *****************
 */
void
des_triple_encrypt(uchar *rcpbuf, uchar *data, uchar *sx, uchar *dx)
{
  uchar tmp[8];

  des_encrypt(tmp,data,sx,0);        /* encrypt with first half of key */
  des_decrypt(rcpbuf,tmp,dx,0);      /* decrypt with second half of key */
  memcpy(tmp,rcpbuf,sizeof(tmp));
  des_encrypt(rcpbuf,tmp,sx,0);      /* encrypt with first half again */
}

void
des_triple_decrypt(uchar *rcpbuf, uchar *data, uchar *sx, uchar *dx)
{
  uchar tmp[8];

  des_decrypt(tmp,data,sx,0);        /* encrypt with first half of key */
  des_encrypt(rcpbuf,tmp,dx,0);      /* decrypt with second half of key */
  memcpy(tmp,rcpbuf,sizeof(tmp));
  des_decrypt(rcpbuf,tmp,sx,0);      /* encrypt with first half again */
}

/*
 ************************** ENCRYPTION / DECRYPTION ***********************
 */
void
des_encrypt(uchar *rcpbuf,uchar *buf,uchar *key,int key_flag)
{
  uchar base[8],nbase[8],*ln,*rn,*ln_1,*rn_1;
  int iter;

  if(!key_flag) keygen(key);	/* GENERATE 16 KEY VARIATIONS K1-K16 */

  memset(base,0x00,8);
  permut(base,buf,ip);	        /* INITIAL PERMUTATION 'IP'          */

  ln = nbase;
  rn = nbase+4;
  ln_1 = base;
  rn_1 = base+4;

  for (iter=0; iter<16 ; iter++)
  {
    memcpy(ln,rn_1,4);          /* Ln = Rn-1 */
    fctf(rn,rn_1,keyn[iter]);   /* F(Rn-1,Kn) */
    xor(rn,ln_1,4);		/* Rn = Ln-1 + F(Rn-1,Kn) */
    memcpy(base,nbase,8);
  }

  memcpy(base+4,nbase,4);	/* SWAP LEFT & RIGHT */
  memcpy(base,nbase+4,4);

  memset(rcpbuf,0x00,8);
  permut(rcpbuf,base,ip_1);	/* OUTPUT PERMUTATION 'IP-1' */

  return;
}

void
des_decrypt(uchar *rcpbuf,uchar *buf,uchar *key,int key_flag)
{
  uchar base[8],nbase[8],*ln,*rn,*ln_1,*rn_1;
  int iter;

  if(!key_flag) keygen(key);	/* GENERATE 16 KEY VARIATIONS K1-K16 */

  memset(base,0x00,8);
  permut(base,buf,ip);	        /* INVERSE PERMUTATION 'IP'        */

  memcpy(nbase,base,8);	        /* SWAP LEFT & RIGHT */
  memcpy(base+4,nbase,4);
  memcpy(base,nbase+4,4);

  ln = base;
  rn = base+4;
  ln_1 = nbase;
  rn_1 = nbase+4;

  for (iter=15; iter>=0 ; iter--)
  {
    memcpy(rn_1,ln,4);   	/* Rn-1 = Ln */
    fctf(ln_1,ln,keyn[iter]);   /* F(Ln,Kn) */
    xor(ln_1,rn,4);		/* Ln-1 = Rn + F(Ln,Kn) */
    memcpy(base,nbase,8);
  }

  memset(rcpbuf,0x00,8);
  permut(rcpbuf,base,ip_1);	/* PERMUTATION 'IP-1' */

  return;
}


/* FUNCTION 'F' AS DEFINED IN STANDARD */
void
fctf(uchar *out_array,uchar *in_array,uchar *key)
{
  uchar base[8],nbase[8];

  memset(base,0x00,6);
  permut(base,in_array,expand);	 /* EXPANSION OF 32 INTO 48 BITS */
  xor(base,key,6);		 /* XOR WITH Kn */
  select(nbase,base,sel);	 /* SELECT ONLY 32 BITS OUT OF 48 */
  memset(out_array,0x00,4);
  permut(out_array,nbase,perm);	 /* APPLY FINAL PERMUTATION 'PERM'*/

  return;
}


/* SELECTION FUNCTION */
void
select(uchar *out_array,uchar *in_array,int sel_array[][4][16])
{
  int b,bn,i,j,bs,exponent,val4;

  memset(out_array,0x00,4);

  for ( b = 0; b<8 ; b++)
  {
    bn = (b*6)+1;			 /* Bit offset = byte offset x 6  */
    i  = 0;
    if ( bittest(in_array,bn+5))
      i=1;			         /* GET Ith COLUMN */
    if ( bittest(in_array,bn))
      i+=2;
    j=0;
    exponent = 8;	                 /* GET Jth COLUMN */

    for ( bs = 1; bs<5; bs++)
    {
      if ( bittest(in_array,bn+bs) )
        j+=exponent;
      exponent >>= 1;
    }
    val4 = sel_array[b][i][j];

    if ( (b&1) == 0 ) val4 <<= 4;        /* PUT IN HIGH NIBBLE IF EVEN */
    out_array[b>>1] |= val4;		 /* LOAD NIBBLE AT OFFSET */
  }

  return;
}

/* GENERATION OF THE 16 KEY VARIATIONS */
void
keygen(uchar *key)
{
  uchar bkey[7];
  int  iter;

  memset(keyn,0x00,7*16);
  memset(bkey,0x00,7);
  permut(bkey,key,p1);	/* PERMUTATION NU 1 */

  for (iter=0 ; iter<16 ; iter++)
  {
    shift(bkey,iter);		/* SHIFT ACCORDING TO TABLE 'TSHIFT' */
    permut(keyn[iter],bkey,p2);	/* GENERATE KEY ORDER iter */
  }

  return;
}

/* SHIFT SCHEME OF 1 OR 2 BITS LEFT */
void
shift(uchar *array,int iteration)
{
  int i,j;
  union {
    uchar s[4];
    long int li;
  } us;
  uchar c[7],d[7];

  for (i=6,j=0; i>=0;j++,i--)           /* REVERSE ARRAY */
    c[j] = array[i];

  memcpy(us.s,c+3,4);
  us.s[0] = ( us.s[0]&0xf0 ) | ( us.s[3]>>4 );
  us.li <<= tshift[iteration];		/* SHIFT 'C' PART */

  memcpy(d+3,us.s,4);			/* STORE RESULT   */

  memcpy(us.s,c,4);
  us.s[3] &= 0x0f;
  us.li <<= tshift[iteration];		/* SHIFT 'D' PART */
  us.s[0] |=  us.s[3]>>4 ;

  memcpy(d,us.s,3);
  d[3] = (d[3]&0xf0) | (us.s[3]&0x0f);

  for (i=6,j=0; i>=0;j++,i--) 		/* REVERSE ARRAY BACK */
    array[j] = d[i];

  return;
}

/* GENERAL PERMUTATION ROUTINE                  */
void
permut(uchar *out_array,uchar *in_array,int   *sel_array)
{
  int i;

  for ( i=1; *sel_array; i++)
  {
    if ( bittest(in_array,*sel_array++) )
      bitset(out_array,i);
  }

  return;
}

/* TEST BIT IN 'ARRAY' AT BIT OFFSET 'BITNO'  */
int
bittest(uchar *array,int bitno)
{
  --bitno;
  return( ( *(array+(bitno>>3)) >> (7 -(bitno&7)) ) &1 );
}

/* SET BIT IN 'ARRAY' AT BIT OFFSET 'BITNO' */
void
bitset(uchar *array,int bitno)
{
  --bitno;
  *(array+(bitno>>3)) |= 0x80 >> (bitno&7);

  return;
}

/* XOR 'B' INTO 'A' ON LENGTH 'LG' */
void
xor(uchar *a,uchar *b,int lg)
{
  for (;lg--;)
    *a++ ^= *b++;

  return;
}

