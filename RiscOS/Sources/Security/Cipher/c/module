/************************************************************************/
/* 	        Copyright 1996 Acorn Network Computers		        */
/*									*/
/*  This material is the confidential trade secret and proprietary	*/
/*  information of Acorn Network Computers. It may not be reproduced,   */
/*  used sold, or transferred to any third party without the prior      */
/*  written consent of Acorn Network Computers. All rights reserved.	*/
/* 									*/
/************************************************************************/

#include <stdio.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"
#include "module.h"
#include "cipher.h"
#include "header.h"
#include "desfunc.h"
#include "md5.h"

#ifdef USE_TINY
static _kernel_oserror *TinyError;
#endif

int little_endian;

ERROR_STRUCT(BADPARAM,"Bad parameter");


_kernel_oserror *
module_initialise(char *cmd_tail, int podule_base, void *pw)
{
  unsigned int i = 0x01020304;

  /*
   * find endianess
   */
  little_endian = ((*(char*)&i)==1)?0:1;
  
#ifdef USE_TINY
  /*
   * try to use TinyStubs if possible.
   */
  TinyError = _swix(TinySupport_Share, _IN(0),pw);
#endif

  return (NULL);
}

_kernel_oserror *
module_finalise(int fatal, int podule, void *pw)
{
#ifdef USE_TINY
  if ( TinyError == NULL ) _swix( TinySupport_Die, 0 );
#endif
  return (NULL);
}

_kernel_oserror *
module_swi(int swi_no, _kernel_swi_regs *r, void *pw)
{
  struct MD5Context ctx;

  switch (swi_no+Cipher_00)
  {
    case Cipher_DESEncrypt :
      if (!(r->r[1]) || !(r->r[2]) || !(r->r[3]))
        return ERROR(BADPARAM);
        
      des_encrypt((uchar *)r->r[2],(uchar *)r->r[1],(uchar *)r->r[3],0);
      break;
    case Cipher_DESDecrypt :
      if (!(r->r[1]) || !(r->r[2]) || !(r->r[3]))
        return ERROR(BADPARAM);

      des_decrypt((uchar *)r->r[2],(uchar *)r->r[1],(uchar *)r->r[3],0);
      break;
    case Cipher_DESTripleEncrypt :
      if (!(r->r[1]) || !(r->r[2]) || !(r->r[3]) || !(r->r[4]))
        return ERROR(BADPARAM);
        
      des_triple_encrypt((uchar *)r->r[2],(uchar *)r->r[1],
      			 (uchar *)r->r[3],(uchar *)r->r[4]);
      break;
    case Cipher_DESTripleDecrypt :
      if (!(r->r[1]) || !(r->r[2]) || !(r->r[3]) || !(r->r[4]))
        return ERROR(BADPARAM);

      des_triple_decrypt((uchar *)r->r[2],(uchar *)r->r[1],
      			 (uchar *)r->r[3],(uchar *)r->r[4]);
      break;
    case Cipher_MD5 :
      if (!(r->r[1]) || (r->r[2]==0) || !(r->r[3]))
        return ERROR(BADPARAM);

      MD5Init(&ctx);
      MD5Update(&ctx,(md5byte*)r->r[1],r->r[2]);
      MD5Final((uchar *)r->r[3], &ctx);
      break;
    default :
      return (error_BAD_SWI);
  }
  return (NULL);
}
