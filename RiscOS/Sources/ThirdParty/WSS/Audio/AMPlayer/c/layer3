/*
 * Decoding layer 3
 */

#include "defs.h"
#include "string.h"

#include "common.h"
#include "huffman.h"
#include "sound.h"
#include "tabcalc.h"
#include "fpasm.h"
#include "miscasm.h"
#include "output.h"

#include "tables.h"
#include "tables3.h"
#include "dec_buf.h"

int reusable_buffer[2*SSLIMIT*SBLIMIT];

/*STATIC fpl COS6_1,COS6_2;*/
#if 0
STATIC fpl win[4][36];
STATIC fpl win1[4][36];
STATIC fpl ispow[8207];
STATIC fpl aa_ca[8],aa_cs[8];
#endif
#if SYNTH_ASM || FP
#else
STATIC fpl COS9[18];
STATIC fpl tfcos36[9];
#endif
#if 0
STATIC fpl tfcos12[3];
STATIC fpl gainpow2[256+118+4];
STATIC fpl tan1_1[16],tan2_1[16],tan1_2[16],tan2_2[16];
STATIC fpl pow1_1[2][16],pow2_1[2][16],pow1_2[2][16],pow2_2[2][16];
#endif

typedef struct
{
  int longIdx[23];
  int longDiff[22];
  int shortIdx[14];
  int shortDiff[13];
} BandInfo;

typedef struct
{
  word main_data_begin;
  word private_bits;
  struct {
    struct gr_info_s {
      int scfsi;
      word part2_3_length;
      word big_values;
      word scalefac_compress;
      word block_type;
      word mixed_block_flag;
      word table_select[3];
      word maxband[3];
      word maxbandl;
      word maxb;
      word region1start;
      word region2start;
      word preflag;
      word scalefac_scale;
      word count1table_select;
      fpl *full_gain[3];
      fpl *pow2gain;
    } gr[2];
  } ch[2];
} III_sideinfo;

#if 0
STATIC int longLimit[9][23];
STATIC int shortLimit[9][14];
#define longLimit(A,B) longLimit[A][B]
#define shortLimit(A,B) shortLimit[A][B]

BandInfo bandInfo[9] = {

/* MPEG 1.0 */
 { {0,4,8,12,16,20,24,30,36,44,52,62,74, 90,110,134,162,196,238,288,342,418,576},
   {4,4,4,4,4,4,6,6,8, 8,10,12,16,20,24,28,34,42,50,54, 76,158},
   {0,4*3,8*3,12*3,16*3,22*3,30*3,40*3,52*3,66*3, 84*3,106*3,136*3,192*3},
   {4,4,4,4,6,8,10,12,14,18,22,30,56} } ,

 { {0,4,8,12,16,20,24,30,36,42,50,60,72, 88,106,128,156,190,230,276,330,384,576},
   {4,4,4,4,4,4,6,6,6, 8,10,12,16,18,22,28,34,40,46,54, 54,192},
   {0,4*3,8*3,12*3,16*3,22*3,28*3,38*3,50*3,64*3, 80*3,100*3,126*3,192*3},
   {4,4,4,4,6,6,10,12,14,16,20,26,66} } ,

 { {0,4,8,12,16,20,24,30,36,44,54,66,82,102,126,156,194,240,296,364,448,550,576} ,
   {4,4,4,4,4,4,6,6,8,10,12,16,20,24,30,38,46,56,68,84,102, 26} ,
   {0,4*3,8*3,12*3,16*3,22*3,30*3,42*3,58*3,78*3,104*3,138*3,180*3,192*3} ,
   {4,4,4,4,6,8,12,16,20,26,34,42,12} }  ,

/* MPEG 2.0 */
 { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
   {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54 } ,
   {0,4*3,8*3,12*3,18*3,24*3,32*3,42*3,56*3,74*3,100*3,132*3,174*3,192*3} ,
   {4,4,4,6,6,8,10,14,18,26,32,42,18 } } ,

 { {0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,330,394,464,540,576},
   {6,6,6,6,6,6,8,10,12,14,16,18,22,26,32,38,46,52,64,70,76,36 } ,
   {0,4*3,8*3,12*3,18*3,26*3,36*3,48*3,62*3,80*3,104*3,136*3,180*3,192*3} ,
   {4,4,4,6,8,10,12,14,18,24,32,44,12 } } ,

 { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
   {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54 },
   {0,4*3,8*3,12*3,18*3,26*3,36*3,48*3,62*3,80*3,104*3,134*3,174*3,192*3},
   {4,4,4,6,8,10,12,14,18,24,30,40,18 } } ,

/* MPEG 2.5 */
 { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576} ,
   {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54},
   {0,12,24,36,54,78,108,144,186,240,312,402,522,576},
   {4,4,4,6,8,10,12,14,18,24,30,40,18} },
 { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576} ,
   {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54},
   {0,12,24,36,54,78,108,144,186,240,312,402,522,576},
   {4,4,4,6,8,10,12,14,18,24,30,40,18} },
 { {0,12,24,36,48,60,72,88,108,132,160,192,232,280,336,400,476,566,568,570,572,574,576},
   {12,12,12,12,12,12,16,20,24,28,32,40,48,56,64,76,90,2,2,2,2,2},
   {0, 24, 48, 72,108,156,216,288,372,480,486,492,498,576},
   {8,8,8,12,16,20,24,28,36,2,2,2,26} } ,
};

STATIC int mapbuf0[9][152];
STATIC int mapbuf1[9][156];
STATIC int mapbuf2[9][44];
STATIC int *map[10][3];
STATIC int *mapend[9][3];
#define map0(A) map[A][0]
#define map1(A) map[A][1]
#define map2(A) map[A][2]

STATIC unsigned short n_slen2[512]; /* MPEG 2.0 slen for 'normal' mode */
STATIC unsigned short i_slen2[256]; /* MPEG 2.0 slen for intensity stereo */

STATIC unsigned char pretab1[22] = {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,3,3,3,2,0};
STATIC unsigned char pretab2[22] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
#endif

fpl block[2][2][SBLIMIT*SSLIMIT]; /* 9K */
int blc[2];

/*
 * init tables for layer-3
 */
void init_layer3(void)
{
#if SYNTH_ASM || FP
#else
  int i;
#endif
#if 0
  int j,k,l;

  double tan, tans;

  for(i=-256;i<118+4;i++) {
    gainpow2[i+256] = make_gainpow(i);
    printf("%x\n", gainpow2[i+256]);
  }

  #define ispow(x) ispow[x]
  for(i=0;i<8207;i++)
    ispow[i] = make_ispow(i);

  for (i=0;i<8;i++)
  {
    double Ci[8]={-0.6,-0.535,-0.33,-0.185,-0.095,-0.041,-0.0142,-0.0037};

    aa_cs[i] = make_aa_cs(&Ci[i]);
    aa_ca[i] = make_aa_ca(&Ci[i]);
  }

  for(i=0;i<36;i++)
    win[0][i]=make_win(2*i+1,2*i+19);

  for(i=0;i<18;i++)
  {
    win[1][i]=win[0][i];
    win[3][i+18]=win[0][i+18];
  }
  for(i=0;i<6;i++)
  {
    win[1][i+18]=make_win(    36, 2*i+36+19);
    win[1][i+24]=make_win(6*i+39, 2*i+48+19);
    win[1][i+30]=0;
    win[3][i+ 0]=0;
    win[3][i+ 6]=make_win(6*i+ 3, 2*i+12+19);
    win[3][i+12]=make_win(    36, 2*i+24+19);
  }

  for(i=0;i<12;i++)
    win[2][i]=make_win(6*i+3,6*i+21);

  for(j=0;j<4;j++)
  {
    static int len[4] = { 36,36,12,36 };
    for(i=0;i<len[j];i+=2)
      win1[j][i] =  win[j][i];
    for(i=1;i<len[j];i+=2)
      win1[j][i] = -win[j][i];
  }
#endif

#if SYNTH_ASM || FP
#else
  for(i=1;i<18;i++)
    COS9[i]=make_cos9(i);

  for(i=0;i<9;i++)
    tfcos36[i]=make_cos36(i*2+1,cos36_SH);
#endif

#if 0
  for(i=0;i<3;i++) {
    tfcos12[i]=make_cos36(i*6+3,cos12_SH);
  }

  COS6_1 = 0x6ed9eba1; /* cos(pi/6) */
  COS6_2 = 0x40000000; /* cos(pi/3) */


  for(i=0;i<16;i++) {
    if (i!=7) {
      set_tan(i, &tan, &tans);
      tan1_1[i] = make_tan11(&tan, &tans);
      tan2_1[i] = make_tan21(&tan, &tans);
      tan1_2[i] = make_tan12(&tan, &tans);
      tan2_2[i] = make_tan22(&tan, &tans);
    }
  }

  for (i=0;i<16;i+=2)
  {
    pow1_1[0][i]   =
    pow1_1[1][i]   =
    pow2_1[0][i+1] =
    pow2_1[1][i+1] = 0x40000000>>(pow_SH-1);

    pow1_2[0][i]   =
    pow1_2[1][i]   =
    pow2_2[0][i+1] =
    pow2_2[1][i+1] = 0x5a82799a>>(pow_SH-1);

    pow2_1[0][i]   = make_pow(-i  ,8);
    pow2_1[1][i]   = make_pow(-i  ,4);
    pow1_1[0][i+1] = make_pow(-i-2,8);
    pow1_1[1][i+1] = make_pow(-i-2,4);

    pow2_2[0][i]   = make_pow(-i+4,8);
    pow2_2[1][i]   = make_pow(-i+2,4);
    pow1_2[0][i+1] = make_pow(-i+2,8);
    pow1_2[1][i+1] = make_pow(-i  ,4);
  }

  for(j=0;j<9;j++)
  {
   BandInfo *bi = &bandInfo[j];
   int *mp;
   int cb,lwin;
   int *bdf;

   mp = map[j][0] = mapbuf0[j];
   bdf = bi->longDiff;
   for(i=0,cb = 0; cb < 8 ; cb++,i+=*bdf++) {
     *mp++ = (*bdf) >> 1;
     *mp++ = i;
     *mp++ = 3;
     *mp++ = cb;
   }
   bdf = bi->shortDiff+3;
   for(cb=3;cb<13;cb++) {
     int l = (*bdf++) >> 1;
     for(lwin=0;lwin<3;lwin++) {
       *mp++ = l;
       *mp++ = i + lwin;
       *mp++ = lwin;
       *mp++ = cb;
     }
     i += 6*l;
   }
   mapend[j][0] = mp;

   mp = map[j][1] = mapbuf1[j];
   bdf = bi->shortDiff+0;
   for(i=0,cb=0;cb<13;cb++) {
     int l = (*bdf++) >> 1;
     for(lwin=0;lwin<3;lwin++) {
       *mp++ = l;
       *mp++ = i + lwin;
       *mp++ = lwin;
       *mp++ = cb;
     }
     i += 6*l;
   }
   mapend[j][1] = mp;

   mp = map[j][2] = mapbuf2[j];
   bdf = bi->longDiff;
   for(cb = 0; cb < 22 ; cb++) {
     *mp++ = (*bdf++) >> 1;
     *mp++ = cb;
   }
   mapend[j][2] = mp;
  }

  for(j=0;j<9;j++) {
    for(i=0;i<23;i++) {
      longLimit[j][i] = (bandInfo[j].longIdx[i] - 1 + 8) / 18 + 1;
      if(longLimit[j][i] > SBLIMIT )
        longLimit[j][i] = SBLIMIT;
    }
    for(i=0;i<14;i++) {
      shortLimit[j][i] = (bandInfo[j].shortIdx[i] - 1) / 18 + 1;
      if(shortLimit[j][i] > SBLIMIT )
        shortLimit[j][i] = SBLIMIT;
    }
  }

  for(i=0;i<5;i++) {
    for(j=0;j<6;j++) {
      for(k=0;k<6;k++) {
        int n = k + j * 6 + i * 36;
        i_slen2[n] = i|(j<<3)|(k<<6)|(3<<12);
      }
    }
  }
  for(i=0;i<4;i++) {
    for(j=0;j<4;j++) {
      for(k=0;k<4;k++) {
        int n = k + j * 4 + i * 16;
        i_slen2[n+180] = i|(j<<3)|(k<<6)|(4<<12);
      }
    }
  }
  for(i=0;i<4;i++) {
    for(j=0;j<3;j++) {
      int n = j + i * 3;
      i_slen2[n+244] = i|(j<<3) | (5<<12);
      n_slen2[n+500] = i|(j<<3) | (2<<12) | (1<<15);
    }
  }

  for(i=0;i<5;i++) {
    for(j=0;j<5;j++) {
      for(k=0;k<4;k++) {
        for(l=0;l<4;l++) {
          int n = l + k * 4 + j * 16 + i * 80;
          n_slen2[n] = i|(j<<3)|(k<<6)|(l<<9)|(0<<12);
        }
      }
    }
  }
  for(i=0;i<5;i++) {
    for(j=0;j<5;j++) {
      for(k=0;k<4;k++) {
        int n = k + j * 4 + i * 20;
        n_slen2[n+400] = i|(j<<3)|(k<<6)|(1<<12);
      }
    }
  }
  
  printf("CONST_n_slen2\n");
  for (i=0; i<512; i++) {
    printf(" DCW 0x%04x\n", n_slen2[i]);
  }
  printf("CONST_i_slen2\n");
  for (i=0; i<256; i++) {
    printf(" DCW 0x%04x\n", i_slen2[i]);
  }

  /* Init the huffman table pointers */
  ht[0].table=  tab0;
  ht[1].table=  tab1;
  ht[2].table=  tab2;
  ht[3].table=  tab3;
  ht[4].table=  tab0;
  ht[5].table=  tab5;
  ht[6].table=  tab6;
  ht[7].table=  tab7;
  ht[8].table=  tab8;
  ht[9].table=  tab9;
  ht[10].table= tab10;
  ht[11].table= tab11;
  ht[12].table= tab12;
  ht[13].table= tab13;
  ht[14].table= tab0;
  ht[15].table= tab15;
  ht[16].table=
  ht[17].table=
  ht[18].table=
  ht[19].table=
  ht[20].table=
  ht[21].table=
  ht[22].table=
  ht[23].table= tab16;
  ht[24].table=
  ht[25].table=
  ht[26].table=
  ht[27].table=
  ht[28].table=
  ht[29].table=
  ht[30].table=
  ht[31].table= tab24;

  htc[0].table= tab_c0;
  htc[1].table= tab_c1;
#endif
}

/*
 * read additional side information
 */
int III_get_side_info_1(III_sideinfo *si,int stereo,int ms_stereo,int sfreq)
{
  int ch, gr;
  int powdiff = 0;

  si->main_data_begin = getbits16(9);
  if (stereo == 1)
    si->private_bits = getbits16(5);
  else
    si->private_bits = getbits16(3);

  for (ch=0; ch<stereo; ch++)
  {
    si->ch[ch].gr[0].scfsi = -1;
    si->ch[ch].gr[1].scfsi = getbits16(4);
  }

  for (gr=0; gr<2; gr++)
  {
    for (ch=0; ch<stereo; ch++)
    {
      struct gr_info_s *gr_info = &(si->ch[ch].gr[gr]);

      gr_info->part2_3_length = getbits(12);
      gr_info->big_values = getbits16(9);
      if (gr_info->big_values > 288)
      {
        async_err("Big values too large!");
        gr_info->big_values = 288;
      }
      gr_info->pow2gain = gainpow2+256 - getbits16(8) + powdiff;
      if(ms_stereo)
        gr_info->pow2gain += 2;
      gr_info->scalefac_compress = getbits16(4);
      /* window-switching flag == 1 for block_Type != 0 ..
       * and block-type == 0 -> win-sw-flag = 0
       */
      if(get1bit())
      {
        int i;
        gr_info->block_type = getbits16(2);
        gr_info->mixed_block_flag = get1bit();
        gr_info->table_select[0] = getbits16(5);
        gr_info->table_select[1] = getbits16(5);
        /*
         * table_select[2] not needed, because there is no region2,
         * but to satisfy some verifications tools we set it either.
         */
        gr_info->table_select[2] = 0;
        for(i=0;i<3;i++)
          gr_info->full_gain[i] = gr_info->pow2gain + (getbits16(3)<<3);

        if(gr_info->block_type == 0)
        {
          async_err("BT=0, WS=1 illegal");
          return 1;
        }
        /* region_count/start parameters are implicit in this case. */
        gr_info->region1start = 36>>1;
        gr_info->region2start = 576>>1;
      }
      else
      {
        int i,r0c,r1c;
        for (i=0; i<3; i++)
          gr_info->table_select[i] = getbits16(5);
        r0c = getbits16(4);
        r1c = getbits16(3);
        gr_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
        gr_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
        gr_info->block_type = 0;
        gr_info->mixed_block_flag = 0;
      }
      gr_info->preflag = get1bit();
      gr_info->scalefac_scale = get1bit();
      gr_info->count1table_select = get1bit();
    }
  }
  return 0;
}

/*
 * Side Info for MPEG 2.0 / LSF
 */
int III_get_side_info_2(III_sideinfo *si,int stereo,int ms_stereo,int sfreq)
{
  int ch;
  int powdiff = 0;

  si->main_data_begin = getbits16(8);
  if (stereo == 1)
    si->private_bits = get1bit();
  else
    si->private_bits = getbits16(2);

  for (ch=0; ch<stereo; ch++)
  {
    struct gr_info_s *gr_info = &(si->ch[ch].gr[0]);

    gr_info->part2_3_length = getbits(12);
    gr_info->big_values = getbits16(9);
    if (gr_info->big_values > 288)
    {
      async_err("Big values too large!");
      gr_info->big_values = 288;
    }
    gr_info->pow2gain = gainpow2+256 - getbits16(8) + powdiff;
    if(ms_stereo)
      gr_info->pow2gain += 2;
    gr_info->scalefac_compress = getbits16(9);
    /* window-switching flag == 1 for block_Type != 0 ..
     * and block-type == 0 -> win-sw-flag = 0
     */
    if(get1bit())
    {
      int i;
      gr_info->block_type = getbits16(2);
      gr_info->mixed_block_flag = get1bit();
      gr_info->table_select[0] = getbits16(5);
      gr_info->table_select[1] = getbits16(5);
      /*
       * table_select[2] not needed, because there is no region2,
       * but to satisfy some verifications tools we set it anyway.
       */
      gr_info->table_select[2] = 0;
      for(i=0;i<3;i++)
        gr_info->full_gain[i] = gr_info->pow2gain + (getbits16(3)<<3);

      if(gr_info->block_type == 0)
      {
        async_err("BT=0 & WS=1 illegal");
        return 1;
      }
      /* region_count/start parameters are implicit in this case.
       */
      /* check this again! */
      if(gr_info->block_type == 2)
        gr_info->region1start = 36>>1;
      else if(sfreq == 8)
        /* check this for 2.5 and sfreq=8 */
        gr_info->region1start = 108>>1;
      else
        gr_info->region1start = 54>>1;
      gr_info->region2start = 576>>1;
    }
    else
    {
      int i,r0c,r1c;
      for (i=0; i<3; i++)
        gr_info->table_select[i] = getbits16(5);
      r0c = getbits16(4);
      r1c = getbits16(3);
      gr_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
      gr_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
      gr_info->block_type = 0;
      gr_info->mixed_block_flag = 0;
    }
    gr_info->scalefac_scale = get1bit();
    gr_info->count1table_select = get1bit();
  }
  return 0;
}

/*
 * read scalefactors
 */
int III_get_scale_factors_1(int *scf,struct gr_info_s *gr_info)
{
#if 0
  static byte slen[2][16] = {
     {0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4},
     {0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3}
   };
   #define slen(A,B) slen[A][B]
#endif
  int numbits;
  int num0 = slen(0,gr_info->scalefac_compress);
  int num1 = slen(1,gr_info->scalefac_compress);

  if (gr_info->block_type == 2)
  {
    int i=18;
    numbits = (num0 + num1) * 18;

    if (gr_info->mixed_block_flag) {
      for (i=8;i;i--)
        *scf++ = getbits16(num0);
      i = 9;
      numbits -= num0; /* num0 * 17 + num1 * 18 */
    }

    for (;i;i--)
      *scf++ = getbits16(num0);
    for (i = 18; i; i--)
      *scf++ = getbits16(num1);
    *scf++ = 0; *scf++ = 0; *scf++ = 0; /* short[13][0..2] = 0 */
  }
  else
  {
    int i;
    int scfsi = gr_info->scfsi;

    if(scfsi < 0) { /* scfsi < 0 => granule == 0 */
      for(i=11;i;i--)
        *scf++ = getbits16(num0);
      for(i=10;i;i--)
        *scf++ = getbits16(num1);
      numbits = (num0 + num1) * 10 + num0;
      *scf++ = 0;
    }
    else {
      numbits = 0;
      if(!(scfsi & 0x8)) {
        for (i=6;i;i--)
          *scf++ = getbits16(num0);
        numbits += num0 * 6;
      }
      else
        scf+=6;

      if(!(scfsi & 0x4)) {
        for (i=5;i;i--)
          *scf++ = getbits16(num0);
        numbits += num0 * 5;
      }
      else
        scf+=5;

      if(!(scfsi & 0x2)) {
        for(i=5;i;i--)
          *scf++ = getbits16(num1);
        numbits += num1 * 5;
      }
      else
        scf+=5;

      if(!(scfsi & 0x1)) {
        for (i=5;i;i--)
          *scf++ = getbits16(num1);
        numbits += num1 * 5;
      }
      else
        scf+=5;
    }

    *scf++ = 0;  /* no l[21] in original sources */
  }
  return numbits;
}

int III_get_scale_factors_2(int *scf,struct gr_info_s *gr_info,int i_stereo)
{
  byte *pnt;
  int i,j;
  word slen;
  int n = 0;
  int numbits = 0;

#if 0
  static byte stab[3][6][4] = {
   { { 6, 5, 5,5 } , { 6, 5, 7,3 } , { 11,10,0,0} ,
     { 7, 7, 7,0 } , { 6, 6, 6,3 } , {  8, 8,5,0} } ,
   { { 9, 9, 9,9 } , { 9, 9,12,6 } , { 18,18,0,0} ,
     {12,12,12,0 } , {12, 9, 9,6 } , { 15,12,9,0} } ,
   { { 6, 9, 9,9 } , { 6, 9,12,6 } , { 15,18,0,0} ,
     { 6,15,12,0 } , { 6,12, 9,6 } , {  6,18,9,0} } };
   #define stab(A,B) stab[A][B]
#endif

  if(i_stereo) /* i_stereo AND second channel -> do_layer3() checks this */
    slen = i_slen2[gr_info->scalefac_compress>>1];
  else
    slen = n_slen2[gr_info->scalefac_compress];

  gr_info->preflag = (slen>>15) & 0x1;

  n = 0;
  if( gr_info->block_type == 2 ) {
    n++;
    if(gr_info->mixed_block_flag)
      n++;
  }

  pnt = stab(n,(slen>>12)&0x7);

  for(i=0;i<4;i++) {
    int num = slen & 0x7;
    slen >>= 3;
    if(num) {
      for(j=0;j<pnt[i];j++)
        *scf++ = getbits16(num);
      numbits += pnt[i] * num;
    }
    else {
      for(j=0;j<pnt[i];j++)
        *scf++ = 0;
    }
  }

  n = (n << 1) + 1;
  for(i=0;i<n;i++)
    *scf++ = 0;

  return numbits;
}

/*
 * don't forget to apply the same changes to III_dequantize_sample_ms() !!!
 */
int III_dequantize_sample(fpl xr[SBLIMIT][SSLIMIT],int *scf, struct gr_info_s *gr_info,int sfreq,int part2bits)
{
  int shift = 1 + gr_info->scalefac_scale;
  fpl *xrpnt = xr[0];
  int l[3],l3;
  int part2remain = gr_info->part2_3_length - part2bits;
  unsigned short *me;

  {
    int bv       = gr_info->big_values;
    int region1  = gr_info->region1start;
    int region2  = gr_info->region2start;

    if ((l3=(288-bv)>>1)<0)
    {
      async_err("Belgium!");
      return 1;
    }
    /*
     * check this later again
     */
    if(bv <= region1)
    {
      l[0] = bv; l[1] = 0; l[2] = 0;
    }
    else
    {
      l[0] = region1;
      if(bv <= region2)
      {
        l[1] = bv - l[0];  l[2] = 0;
      }
      else
      {
        l[1] = region2 - l[0]; l[2] = bv - region2;
      }
    }
  }

  if(gr_info->block_type == 2)
  {
    /*
     * decoding with short or mixed mode BandIndex table
     */
    int i,max[4];
    int step=0,lwin=0,cb=0;
    fpl v = 0;
    unsigned short *m;
    int mc;

    if(gr_info->mixed_block_flag)
    {
      max[3] = -1;
      max[0] = max[1] = max[2] = 2;
      m = map0(sfreq);
      /*me = mapend[sfreq][0];*/
      me = m+152;
    }
    else
    {
      max[0] = max[1] = max[2] = max[3] = -1;
      /* max[3] not actually needed in this case */
      m = map1(sfreq);
      /*me = mapend[sfreq][1];*/
      me = m + 156;
    }

    mc = 0;
    for(i=0;i<2;i++)
    {
      int lp = l[i];
      NewHuff *h = ht+gr_info->table_select[i];
      for(;lp;lp--,mc--)
      {
        int x,y;
        if( (!mc) )
        {
          mc    = *m++;
          xrpnt = &xr[0][*m++];
          lwin  = *m++;
          cb    = *m++;
          if(lwin == 3)
          {
            v = gr_info->pow2gain[(*scf++)<<shift];
            step = 1;
          }
          else
          {
            v = gr_info->full_gain[lwin][(*scf++)<<shift];
            step = 3;
          }


        }
        {
          fptab *val = h->table;
          while((y=*val++)<0)
          {
            if (get1bit()) val -= y;
            part2remain--;
          }
          x = y >> 4;
          y &= 0xf;
        }
        if(x == 15)
        {
          max[lwin] = cb;
          part2remain -= h->linbits+1;
          x += getbits(h->linbits);
          *xrpnt = mulss_ispow_gain_SH(ispow(x),get1bit()? -v:v);
        }
        else if(x)
        {
          max[lwin] = cb;
          *xrpnt = mulss_ispow_gain_SH(ispow(x),get1bit()? -v:v);
          part2remain--;
        }
        else
          *xrpnt = 0;
        xrpnt += step;
        if(y == 15)
        {
          max[lwin] = cb;
          part2remain -= h->linbits+1;
          y += getbits(h->linbits);
          *xrpnt = mulss_ispow_gain_SH(ispow(y),get1bit()? -v:v);
        }
        else if(y)
        {
          max[lwin] = cb;
          *xrpnt = mulss_ispow_gain_SH(ispow(y),get1bit()? -v:v);
          part2remain--;
        }
        else
          *xrpnt = 0;
        xrpnt += step;
      }
    }
    for(;l3 && (part2remain > 0);l3--)
    {
      NewHuff *h = htc+gr_info->count1table_select;
      fptab *val = h->table,a;

      while((a=*val++)<0)
      {
        if (part2remain<1)
        {
          a = 0;
          break;
        }
        part2remain--;
        if (get1bit()) val -= a;
      }

      for(i=0;i<4;i++)
      {
        if(!(i & 1))
        {
          if(!mc)
          {
            mc   = *m++;
            xrpnt= &xr[0][*m++];
            lwin = *m++;
            cb   = *m++;
            if(lwin == 3)
            {
              v = gr_info->pow2gain[(*scf++)<<shift];
              step = 1;
            }
            else
            {
              v = gr_info->full_gain[lwin][(*scf++)<<shift];
              step = 3;
            }
          }
          mc--;
        }
        if( (a & (0x8>>i)) )
        {
          max[lwin] = cb;
          if (part2remain<1)
            break;
          part2remain--;
          *xrpnt = (get1bit()? -v:v)<<gain_SH;
        }
        else
          *xrpnt = 0;
        xrpnt += step;
      }
    }

    while( m < me )
    {
      if(!mc)
      {
        mc   = *m++;
        xrpnt= &xr[0][*m++];
        if( (*m++) == 3)
          step = 1;
        else
          step = 3;
        m++; /* cb */
      }
      mc--;
      *xrpnt = 0;
      xrpnt += step;
      *xrpnt = 0;
      xrpnt += step;
    }

    gr_info->maxband[0] = max[0]+1;
    gr_info->maxband[1] = max[1]+1;
    gr_info->maxband[2] = max[2]+1;
    gr_info->maxbandl = max[3]+1;

    {
      int rmax = max[0] > max[1] ? max[0] : max[1];
      rmax = (rmax > max[2] ? rmax : max[2]) + 1;
      gr_info->maxb = rmax ? shortLimit(sfreq,rmax) : longLimit(sfreq,max[3]+1);
    }

  }
  else
  {
    /*
     * decoding with 'long' BandIndex table (block_type != 2)
     */
    unsigned char *pretab = gr_info->preflag ? pretab1 : pretab2;
    int i,max = -1;
    int cb = 0;
    unsigned char *m = map2(sfreq);
    /*int *m = map2(sfreq);*/
    fpl v = 0;
    int mc = 0;

    for(i=0;i<3;i++)
    {
      int lp = l[i];
      NewHuff *h = ht+gr_info->table_select[i];

      for(;lp;lp--,mc--)
      {
        int x,y;

        if(!mc)
        {
          mc = *m++;
          v = gr_info->pow2gain[((*scf++) + (*pretab++))<<shift];
          cb = *m++;
        }
        {
          fptab *val = h->table;
          while((y=*val++)<0)
          {
            if (get1bit()) val -= y;
            part2remain--;
          }
          x = y >> 4;
          y &= 0xf;
        }
        if (x == 15)
        {
          max = cb;
          part2remain -= h->linbits+1;
          x += getbits(h->linbits);
          *xrpnt++ = mulss_ispow_gain_SH(ispow(x),get1bit()? -v:v);
        }
        else if(x)
        {
          max = cb;
          *xrpnt++ = mulss_ispow_gain_SH(ispow(x),get1bit()? -v:v);
          part2remain--;
        }
        else
          *xrpnt++ = 0;

        if (y == 15)
        {
          max = cb;
          part2remain -= h->linbits+1;
          y += getbits(h->linbits);
          *xrpnt++ = mulss_ispow_gain_SH(ispow(y),get1bit()? -v:v);
        }
        else if(y)
        {
          max = cb;
          *xrpnt++ = mulss_ispow_gain_SH(ispow(y),get1bit()? -v:v);
          part2remain--;
        }
        else
          *xrpnt++ = 0;
      }
    }

    for(;l3 && (part2remain > 0);l3--)
    {
      NewHuff *h = htc+gr_info->count1table_select;
      fptab *val = h->table,a;

      while((a=*val++)<0)
      {
        if (part2remain<1)
        {
          a = 0;
          break;
        }
        part2remain--;
        if (get1bit()) val -= a;
      }

      for(i=0;i<4;i++)
      {
        if(!(i & 1))
        {
          if(!mc)
          {
            mc = *m++;
            cb = *m++;
            v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
          }
          mc--;
        }
        if ( (a & (0x8>>i)) )
        {
          max = cb;
          if (part2remain<1)
            break;
          part2remain--;
          *xrpnt++ = (get1bit()? -v:v)<<gain_SH;

        }
        else
          *xrpnt++ = 0;
      }
    }
    for(i=&xr[SBLIMIT][0]-xrpnt;i;i--)
      *xrpnt++ = 0;

    gr_info->maxbandl = max+1;
    gr_info->maxb = longLimit(sfreq,gr_info->maxbandl);
  }

  if (part2remain>=0)
  {
    while (part2remain>=16)
    {
      getbits(16); /* Dismiss stuffing Bits */
      part2remain-=16;
    }
    getbits(part2remain);
  }
  else
  {
    async_err("Bitstream error (%i bits missing)",-part2remain);
    return 1; /* -> error */
  }
  return 0;
}

int III_dequantize_sample_ms(fpl xr[2][SBLIMIT][SSLIMIT],int *scf, struct gr_info_s *gr_info,int sfreq,int part2bits)
{
  int shift = 1 + gr_info->scalefac_scale;
  fpl *xr0pnt = xr[0][0];
  fpl *xrpnt  = xr[1][0];
  int l[3],l3;
  int part2remain = gr_info->part2_3_length - part2bits;

  {
    int bv       = gr_info->big_values;
    int region1  = gr_info->region1start;
    int region2  = gr_info->region2start;

    if ((l3=(288-bv)>>1)<0)
    {
      async_err("Belgium!");
      return 1;
    }
    /*
     * check this later again
     */
    if(bv <= region1)
    {
      l[0] = bv; l[1] = 0; l[2] = 0;
    }
    else
    {
      l[0] = region1;
      if(bv <= region2)
      {
        l[1] = bv - l[0];  l[2] = 0;
      }
      else
      {
        l[1] = region2 - l[0]; l[2] = bv - region2;
      }
    }
  }

  if(gr_info->block_type == 2)
  {
    int i,max[4];
    int step=0,lwin=0,cb=0;
    fpl v = 0;
    unsigned short *m;
    int mc = 0;
    unsigned short *me;

    if(gr_info->mixed_block_flag)
    {
      max[3] = -1;
      max[0] = max[1] = max[2] = 2;
      m = map0(sfreq);
      /*me = mapend[sfreq][0];*/
      me = m + 152;
    }
    else
    {
      max[0] = max[1] = max[2] = max[3] = -1;
      /* max[3] not actually needed in this case */
      m = map1(sfreq);
      /*me = mapend[sfreq][1];*/
      me = m+156;
    }

    for(i=0;i<2;i++)
    {
      int lp = l[i];
      NewHuff *h = ht+gr_info->table_select[i];
      for(;lp;lp--,mc--)
      {
        int x,y;

        if(!mc)
        {
          mc    = *m++;
          xr0pnt= &xr[0][0][*m];
          xrpnt = &xr[1][0][*m++];
          lwin  = *m++;
          cb    = *m++;
          if(lwin == 3)
          {
            v = gr_info->pow2gain[(*scf++) << shift];
            step = 1;
          }
          else
          {
            v = gr_info->full_gain[lwin][(*scf++) << shift];
            step = 3;
          }
        }
        {
          fptab *val = h->table;

          while((y=*val++)<0)
          {
            if (get1bit()) val -= y;
            part2remain--;
          }
          x = y >> 4;
          y &= 0xf;
        }
        if(x == 15)
        {
          fpl a;

          max[lwin] = cb;
          part2remain -= h->linbits+1;
          x += getbits(h->linbits);
          a = mulss_ispow_gain_SH(ispow(x),get1bit()? v:-v);
          *xrpnt = *xr0pnt + a;
          *xr0pnt -= a;
        }
        else if(x)
        {
          fpl a;

          max[lwin] = cb;
          a = mulss_ispow_gain_SH(ispow(x),get1bit()? v:-v);
          *xrpnt = *xr0pnt + a;
          *xr0pnt -= a;
          part2remain--;
        }
        else
          *xrpnt = *xr0pnt;
        xrpnt  += step;
        xr0pnt += step;

        if(y == 15)
        {
          fpl a;

          max[lwin] = cb;
          part2remain -= h->linbits+1;
          y += getbits(h->linbits);
          a = mulss_ispow_gain_SH(ispow(y),get1bit()? v:-v);
          *xrpnt = *xr0pnt + a;
          *xr0pnt -= a;
        }
        else if(y)
        {
          fpl a;

          max[lwin] = cb;
          a = mulss_ispow_gain_SH(ispow(y),get1bit()? v:-v);
          *xrpnt = *xr0pnt + a;
          *xr0pnt -= a;
          part2remain--;
        }
        else
          *xrpnt = *xr0pnt;
        xrpnt  += step;
        xr0pnt += step;
      }
    }

    for(;l3 && (part2remain > 0);l3--)
    {
      NewHuff *h = htc+gr_info->count1table_select;
      fptab *val = h->table,a;

      while((a=*val++)<0)
      {
        if (part2remain<1)
        {
          a = 0;
          break;
        }
        part2remain--;
        if (get1bit()) val -= a;
      }

      for(i=0;i<4;i++)
      {
        if(!(i & 1))
        {
          if(!mc)
          {
            mc    = *m++;
            xr0pnt= &xr[0][0][*m];
            xrpnt = &xr[1][0][*m++];
            lwin  = *m++;
            cb    = *m++;
            if(lwin == 3)
            {
              v = gr_info->pow2gain[(*scf++) << shift];
              step = 1;
            }
            else
            {
              v = gr_info->full_gain[lwin][(*scf++) << shift];
              step = 3;
            }
          }
          mc--;
        }
        if( (a & (0x8>>i)) )
        {
          max[lwin] = cb;
          if (part2remain<1)
            break;
          part2remain--;
          if(get1bit())
          {
            *xrpnt = *xr0pnt + (v<<gain_SH);
            *xr0pnt -= (v<<gain_SH);
          }
          else
          {
            *xrpnt = *xr0pnt - (v<<gain_SH);
            *xr0pnt += (v<<gain_SH);
          }
        }
        else
          *xrpnt = *xr0pnt;
        xrpnt += step;
        xr0pnt += step;
      }
    }

    while( m < me )
    {
      if(!mc)
      {
        mc    = *m++;
        xrpnt = &xr[1][0][*m];    /* changed from xr[0] to xr[1], seems right */
        xr0pnt= &xr[0][0][*m++];
        if(*m++ == 3)
          step = 1;
        else
          step = 3;
        m++; /* cb */
      }
      mc--;
      *xrpnt = *xr0pnt;
      xrpnt += step;
      xr0pnt += step;
      *xrpnt = *xr0pnt;
      xrpnt += step;
      xr0pnt += step;
    }

    gr_info->maxband[0] = max[0]+1;
    gr_info->maxband[1] = max[1]+1;
    gr_info->maxband[2] = max[2]+1;
    gr_info->maxbandl = max[3]+1;

    {
      int rmax = max[0] > max[1] ? max[0] : max[1];
      rmax = (rmax > max[2] ? rmax : max[2]) + 1;
      gr_info->maxb = rmax ? shortLimit(sfreq,rmax) : longLimit(sfreq,max[3]+1);
    }
  }
  else
  {
    unsigned char *pretab = gr_info->preflag ? pretab1 : pretab2;
    int i,max = -1;
    int cb = 0;
    int mc=0;
    /*int *m = map2(sfreq);*/
    unsigned char *m = map2(sfreq);
    fpl v = 0;

    for(i=0;i<3;i++)
    {
      int lp = l[i];
      NewHuff *h = ht+gr_info->table_select[i];

      for(;lp;lp--,mc--)
      {
        int x,y;

        if(!mc)
        {
          mc = *m++;
          cb = *m++;
          v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
        }
        {
          fptab *val = h->table;
          while((y=*val++)<0)
          {
            if (get1bit()) val -= y;
            part2remain--;
          }
          x = y >> 4;
          y &= 0xf;
        }
        if (x == 15)
        {
          fpl a;

          max = cb;
          part2remain -= h->linbits+1;
          x += getbits(h->linbits);
          a = mulss_ispow_gain_SH(ispow(x),get1bit()? v:-v);
          *xrpnt++ = *xr0pnt + a;
          *xr0pnt++ -= a;
        }
        else if(x)
        {
          fpl a;

          max = cb;
          a = mulss_ispow_gain_SH(ispow(x),get1bit()? v:-v);
          *xrpnt++ = *xr0pnt + a;
          *xr0pnt++ -= a;
          part2remain--;
        }
        else
          *xrpnt++ = *xr0pnt++;

        if (y == 15)
        {
          fpl a;

          max = cb;
          part2remain -= h->linbits+1;
          y += getbits(h->linbits);
          a = mulss_ispow_gain_SH(ispow(y),get1bit()? v:-v);
          *xrpnt++ = *xr0pnt + a;
          *xr0pnt++ -= a;
        }
        else if(y)
        {
          fpl a;

          max = cb;
          a = mulss_ispow_gain_SH(ispow(y),get1bit()? v:-v);
          *xrpnt++ = *xr0pnt + a;
          *xr0pnt++ -= a;
          part2remain--;
        }
        else
          *xrpnt++ = *xr0pnt++;
      }
    }

    for(;l3 && (part2remain > 0);l3--)
    {
      NewHuff *h = htc+gr_info->count1table_select;
      fptab *val = h->table,a;

      while((a=*val++)<0)
      {
        if (part2remain<1)
        {
          a = 0;
          break;
        }
        part2remain--;
        if (get1bit()) val -= a;
      }

      for(i=0;i<4;i++)
      {
        if(!(i & 1))
        {
          if(!mc)
          {
            mc = *m++;
            cb = *m++;
            v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
          }
          mc--;
        }
        if ( (a & (0x8>>i)) )
        {
          max = cb;
          if (part2remain<1)
            break;
          part2remain--;
          if(get1bit())
          {
            *xrpnt++ = *xr0pnt + (v<<gain_SH);
            *xr0pnt++ -= (v<<gain_SH);
          }
          else
          {
            *xrpnt++ = *xr0pnt - (v<<gain_SH);
            *xr0pnt++ += (v<<gain_SH);
          }
        }
        else
          *xrpnt++ = *xr0pnt++;
      }
    }
    for(i=&xr[1][SBLIMIT][0]-xrpnt;i;i--)
      *xrpnt++ = *xr0pnt++;

    gr_info->maxbandl = max+1;
    gr_info->maxb = longLimit(sfreq,gr_info->maxbandl);
  }

  if (part2remain>=0)
  {
    while (part2remain>=16)
    {
      getbits(16); /* Dismiss stuffing Bits */
      part2remain-=16;
    }
    getbits(part2remain);
  }
  else
  {
    async_err("Bitstream error (%i bits missing)",-part2remain);
    return 1; /* -> error */
  }
  return 0;
}

/*
 * III_stereo: calculate channel values for Joint-I-Stereo-mode
 */
void III_i_stereo(fpl xr_buf[2][SBLIMIT][SSLIMIT],int *scalefac,
   struct gr_info_s *gr_info,int sfreq,int ms_stereo,int lsf)
{
      fpl (*xr)[SBLIMIT*SSLIMIT] = (fpl (*)[SBLIMIT*SSLIMIT] ) xr_buf;
      BandInfo *bi = &bandInfo[sfreq];
      fpl *tab1,*tab2;

      if(lsf)
      {
        int p = gr_info->scalefac_compress & 0x1;
	if(ms_stereo)
	{
          tab1 = pow1_2(p);
          tab2 = pow2_2(p);
        }
        else
        {
          tab1 = pow1_1(p);
          tab2 = pow2_1(p);
        }
      }
      else
      {
        if(ms_stereo)
        {
          tab1 = tan1_2;
          tab2 = tan2_2;
        }
        else
        {
          tab1 = tan1_1;
          tab2 = tan2_1;
        }
      }

      if (gr_info->block_type == 2)
      {
         int lwin,do_l = 0;
         if( gr_info->mixed_block_flag )
           do_l = 1;

         for (lwin=0;lwin<3;lwin++) /* process each window */
         {
             /* get first band with zero values */
           int is_p,sb,idx,sfb = gr_info->maxband[lwin];  /* sfb is minimal 3 for mixed mode */
           if(sfb > 3)
             do_l = 0;

           for(;sfb<12;sfb++)
           {
             is_p = scalefac[sfb*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */
             if(is_p != 7)
             {
               fpl t1,t2;

               sb = bi->shortDiff[sfb];
               idx = bi->shortIdx[sfb] + lwin;
               t1 = tab1[is_p];
               t2 = tab2[is_p];
               for (; sb > 0; sb--,idx+=3)
               {
                 fpl v = xr[0][idx];
                 xr[0][idx] = mulss_pow_SH(v,t1);
                 xr[1][idx] = mulss_pow_SH(v,t2);
               }
             }
           }

           is_p = scalefac[11*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */
           sb = bi->shortDiff[12];
           idx = bi->shortIdx[12] + lwin;
           if(is_p != 7)
           {
             fpl t1,t2;

             t1 = tab1[is_p];
             t2 = tab2[is_p];
             for ( ; sb > 0; sb--,idx+=3 )
             {
               fpl v = xr[0][idx];
               xr[0][idx] = mulss_pow_SH(v,t1);
               xr[1][idx] = mulss_pow_SH(v,t2);
             }
           }
         } /* end for(lwin; .. ; . ) */

         if (do_l)
         {
           /* also check l-part, if ALL bands in the three windows are 'empty'
            * and mode = mixed_mode
            */
           int sfb = gr_info->maxbandl;
           int idx = bi->longIdx[sfb];

           for ( ; sfb<8; sfb++ )
           {
             int sb = bi->longDiff[sfb];
             int is_p = scalefac[sfb]; /* scale: 0-15 */
             if(is_p != 7)
             {
               fpl t1,t2;

               t1 = tab1[is_p];
               t2 = tab2[is_p];
               for ( ; sb > 0; sb--,idx++)
               {
                 fpl v = xr[0][idx];
                 xr[0][idx] = mulss_pow_SH(v,t1);
                 xr[1][idx] = mulss_pow_SH(v,t2);
               }
             }
             else
               idx += sb;
           }
         }
      }
      else /* ((gr_info->block_type != 2)) */
      {
        int sfb = gr_info->maxbandl;
        int is_p,idx = bi->longIdx[sfb];
        for ( ; sfb<21; sfb++)
        {
          int sb = bi->longDiff[sfb];
          is_p = scalefac[sfb]; /* scale: 0-15 */
          if(is_p != 7)
          {
            fpl t1,t2;

            t1 = tab1[is_p];
            t2 = tab2[is_p];
            for ( ; sb > 0; sb--,idx++)
            {
               fpl v = xr[0][idx];
               xr[0][idx] = mulss_pow_SH(v,t1);
               xr[1][idx] = mulss_pow_SH(v,t2);
            }
          }
          else
            idx += sb;
        }

        is_p = scalefac[20]; /* copy l-band 20 to l-band 21 */
        if(is_p != 7)
        {
          int sb;
          fpl t1,t2;

          t1 = tab1[is_p];
          t2 = tab2[is_p];
          for ( sb = bi->longDiff[21]; sb > 0; sb--,idx++ )
          {
            fpl v = xr[0][idx];
            xr[0][idx] = mulss_pow_SH(v,t1);
            xr[1][idx] = mulss_pow_SH(v,t2);
          }
        }
      } /* ... */
}

void III_antialias(fpl xr[SBLIMIT][SSLIMIT],struct gr_info_s *gr_info)
{
   int sblim;

   if(gr_info->block_type == 2)
   {
      if(!gr_info->mixed_block_flag)
        return;
      sblim = 1;
   }
   else
   {
     sblim = gr_info->maxb-1;
   }

   /* 31 alias-reduction operations between each pair of sub-bands */
   /* with 8 butterflies between each pair                         */

   {
     int sb;
     fpl *xr1=(fpl *) xr[1];

     for(sb=sblim;sb;sb--,xr1+=10)
     {
       int ss;
       fpl *cs=aa_cs;
       fpl *ca=aa_ca;
       fpl *xr2 = xr1;
       fpl bu,bd;

       for(ss=7;ss>=0;ss--)
       {       /* upper and lower butterfly inputs */
         bu = *--xr2;
         bd = *xr1;
         *xr2   = muls(bu,*cs)-muls(bd,*ca);
         *xr1++ = mlas(bd,*cs++,muls(bu,*ca++));
       }
     }
  }
}

/* Calculation of the inverse MDCT
 */

#if SYNTH_ASM || FP
extern void dct36(fpl *in,fpl *out1,fpl *out2,fpl *w,fpl *ts);
#else
void dct36(fpl *in,fpl *out1,fpl *out2,fpl *w,fpl *ts)
{
  int  i;
  fpl ta33,ta66,tb33,tb66;
  fpl tmp1a,tmp2a,tmp1b,tmp2b;
  fpl sum0,sum1,tmp;

  #define dct36_part0(v) \
  tmp=sum0+sum1; \
  out2[9+v] = muls(tmp,w[27+v]); \
  out2[8-v] = muls(tmp,w[26-v]); \
  sum0-=sum1; \
  ts[SBLIMIT*(9+v)] = muls(sum0,w[9+v])+out1[9+v]; \
  ts[SBLIMIT*(8-v)] = muls(sum0,w[8-v])+out1[8-v];

  #define dct36_part1(v) \
  sum0=tmp1a+tmp2a; \
  sum1=mulss_cos36_SH(tmp1b+tmp2b,tfcos36[v]); \
  dct36_part0(v);

  #define dct36_part2(v) \
  sum0=tmp2a-tmp1a; \
  sum1=mulss_cos36_SH(tmp2b-tmp1b,tfcos36[v]); \
  dct36_part0(v);

  #define ia(x) in[2*x]
  #define ib(x) in[2*x+1]

  for (i=17;i>0;i--)
    in[i]+=in[i-1];

  for (i=17;i>1;i-=2)
    in[i]+=in[i-2];

  ta33=muls(ia(3),COS9[15]);
  tb33=muls(ib(3),COS9[15]);
  ta66=muls(ia(6),COS9[6]);
  tb66=muls(ib(6),COS9[6]);

  tmp1a=mlas(ia(7),COS9[ 7],mlas(ia(5),COS9[ 5],muls(ia(1),COS9[ 1])))-ta33;
  tmp1b=mlas(ib(7),COS9[ 7],mlas(ib(5),COS9[ 5],muls(ib(1),COS9[ 1])))-tb33;
  tmp2a=mlas(ia(8),COS9[ 8],mlas(ia(4),COS9[ 4],mlas(ia(2),COS9[ 2],ia(0))))+ta66;
  tmp2b=mlas(ib(8),COS9[ 8],mlas(ib(4),COS9[ 4],mlas(ib(2),COS9[ 2],ib(0))))+tb66;
  dct36_part1(0);
  dct36_part2(8);

  tmp1a=muls(ia(1)-ia(5)-ia(7),COS9[3]);
  tmp1b=muls(ib(1)-ib(5)-ib(7),COS9[3]);
  tmp2a=mlas(ia(2)-ia(4)-ia(8),COS9[6],ia(0))-ia(6);
  tmp2b=mlas(ib(2)-ib(4)-ib(8),COS9[6],ib(0))-ib(6);
  dct36_part1(1);
  dct36_part2(7);


  tmp1a=mlas(ia(7),COS9[ 1],mlas(ia(5),COS9[11],mlas(ia(1),COS9[ 5],ta33)));
  tmp1b=mlas(ib(7),COS9[ 1],mlas(ib(5),COS9[11],mlas(ib(1),COS9[ 5],tb33)));
  tmp2a=mlas(ia(8),COS9[ 4],mlas(ia(4),COS9[16],mlas(ia(2),COS9[10],ia(0))))+ta66;
  tmp2b=mlas(ib(8),COS9[ 4],mlas(ib(4),COS9[16],mlas(ib(2),COS9[10],ib(0))))+tb66;
  dct36_part1(2);
  dct36_part2(6);

  tmp1a=mlas(ia(7),COS9[13],mlas(ia(5),COS9[1],mlas(ia(1),COS9[ 7],ta33)));
  tmp1b=mlas(ib(7),COS9[13],mlas(ib(5),COS9[1],mlas(ib(1),COS9[ 7],tb33)));
  tmp2a=mlas(ia(8),COS9[16],mlas(ia(4),COS9[8],mlas(ia(2),COS9[14],ia(0))))+ta66;
  tmp2b=mlas(ib(8),COS9[16],mlas(ib(4),COS9[8],mlas(ib(2),COS9[14],ib(0))))+tb66;
  dct36_part1(3);
  dct36_part2(5);

  sum0=ia(0)-ia(2)+ia(4)-ia(6)+ia(8);
  sum1=mulss_cos36_SH(ib(0)-ib(2)+ib(4)-ib(6)+ib(8),tfcos36[4]);
  dct36_part0(4);
}
#endif

/*
 * new DCT12
 */
void dct12(fpl *in,fpl *out1,fpl *out2,fpl *wi,fpl *ts)
{
  fpl in0,in1,in2,in3,in4,in5;
  fpl tmp0,tmp1,tmp2;

  #define DCT12_PART1(v) \
          in5 = in[5*3+v];  \
  in5 += (in4 = in[4*3+v]); \
  in4 += (in3 = in[3*3+v]); \
  in3 += (in2 = in[2*3+v]); \
  in2 += (in1 = in[1*3+v]); \
  in1 += (in0 = in[0*3+v]); \
                          \
  in5 += in3; in3 += in1; \
                          \
  in2 = muls(in2,0x6ed9eba1 /* COS6_1 */); \
  in3 = muls(in3,0x6ed9eba1 /* COS6_1 */);

  #define DCT12_PART2 \
  in0 += muls(in4,0x40000000 /* COS6_2 */); \
                       \
  in4 = in0 + in2;     \
  in0 -= in2;          \
                       \
  in1 += muls(in5,0x40000000 /* COS6_2 */); \
                       \
  in5 = mulss_cos12_SH(in1+in3,0x2120fb83 /*tfcos12[0]*/); \
  in1 = mulss_cos12_SH(in1-in3,0x7ba3751d /*tfcos12[2]*/); \
                      \
  in3 = in4 + in5;    \
  in4 -= in5;         \
                      \
  in2 = in0 + in1;    \
  in0 -= in1;

  ts[SBLIMIT*0] = out1[0];
  ts[SBLIMIT*1] = out1[1];
  ts[SBLIMIT*2] = out1[2];
  ts[SBLIMIT*3] = out1[3];
  ts[SBLIMIT*4] = out1[4];
  ts[SBLIMIT*5] = out1[5];

  DCT12_PART1(0)

  tmp1 = (in0 - in4);
  tmp2 = mulss_cos12_SH(in1-in5,0x2d413ccc/*tfcos12[1]*/);
  tmp0 = tmp1 + tmp2;
  tmp1 -= tmp2;

  ts[(17-1)*SBLIMIT] = out1[17-1] + muls(tmp0,wi[11-1]);
  ts[(12+1)*SBLIMIT] = out1[12+1] + muls(tmp0,wi[ 6+1]);
  ts[( 6+1)*SBLIMIT] = out1[ 6+1] + muls(tmp1,wi[   1]);
  ts[(11-1)*SBLIMIT] = out1[11-1] + muls(tmp1,wi[ 5-1]);

  DCT12_PART2

  ts[(17-0)*SBLIMIT] = out1[17-0] + muls( in2,wi[11-0]);
  ts[(12+0)*SBLIMIT] = out1[12+0] + muls( in2,wi[ 6+0]);
  ts[(12+2)*SBLIMIT] = out1[12+2] + muls( in3,wi[ 6+2]);
  ts[(17-2)*SBLIMIT] = out1[17-2] + muls( in3,wi[11-2]);

  ts[( 6+0)*SBLIMIT] = out1[ 6+0] + muls( in0,wi[   0]);
  ts[(11-0)*SBLIMIT] = out1[11-0] + muls( in0,wi[ 5-0]);
  ts[( 6+2)*SBLIMIT] = out1[ 6+2] + muls( in4,wi[   2]);
  ts[(11-2)*SBLIMIT] = out1[11-2] + muls( in4,wi[ 5-2]);

  DCT12_PART1(1)

  tmp1 = (in0 - in4);
  tmp2 = mulss_cos12_SH(in1-in5,0x2d413ccc/*tfcos12[1]*/);
  tmp0 = tmp1 + tmp2;
  tmp1 -= tmp2;

  out2[5-1] =           muls(tmp0,wi[11-1]);
  out2[0+1] =           muls(tmp0,wi[ 6+1]);
  ts[(12+1)*SBLIMIT] += muls(tmp1,wi[   1]);
  ts[(17-1)*SBLIMIT] += muls(tmp1,wi[ 5-1]);

  DCT12_PART2

  out2[5-0] = muls(in2,wi[11-0]);
  out2[0+0] = muls(in2,wi[ 6+0]);
  out2[0+2] = muls(in3,wi[ 6+2]);
  out2[5-2] = muls(in3,wi[11-2]);

  ts[(12+0)*SBLIMIT] += muls( in0,wi[   0]);
  ts[(17-0)*SBLIMIT] += muls( in0,wi[ 5-0]);
  ts[(12+2)*SBLIMIT] += muls( in4,wi[   2]);
  ts[(17-2)*SBLIMIT] += muls( in4,wi[ 5-2]);

  out2[12]=out2[13]=out2[14]=out2[15]=out2[16]=out2[17]=0;

  DCT12_PART1(2)

  tmp1 = (in0 - in4);
  tmp2 = mulss_cos12_SH(in1-in5,0x2d413ccc /*tfcos12[1]*/);
  tmp0 = tmp1 + tmp2;
  tmp1 -= tmp2;

  out2[11-1] =  muls(tmp0,wi[11-1]);
  out2[ 6+1] =  muls(tmp0,wi[ 6+1]);
  out2[ 0+1] += muls(tmp1,wi[   1]);
  out2[ 5-1] += muls(tmp1,wi[ 5-1]);

  DCT12_PART2

  out2[11-0] =  muls( in2,wi[11-0]);
  out2[ 6+0] =  muls( in2,wi[ 6+0]);
  out2[ 6+2] =  muls( in3,wi[ 6+2]);
  out2[11-2] =  muls( in3,wi[11-2]);

  out2[ 0+0] += muls( in0,wi[   0]);
  out2[ 5-0] += muls( in0,wi[ 5-0]);
  out2[ 0+2] += muls( in4,wi[   2]);
  out2[ 5-2] += muls( in4,wi[ 5-2]);
}

void III_init(void)
{
  int i;

  for (i=0;i<2*2*SBLIMIT*SSLIMIT;i++)
    block[0][0][i]=0;

  blc[0]=blc[1]=0;
}

/*
 * III_hybrid
 *
 * block[], rawout1, rawout2, tsOut all contain 1/128th of actual value to avoid overflow
 *
 */
void III_hybrid(fpl fsIn[SBLIMIT][SSLIMIT],fpl tsOut[SSLIMIT][SBLIMIT],int ch,struct gr_info_s *gr_info)
{
  fpl *tspnt = (fpl *) tsOut;
  fpl *rawout1,*rawout2;
  int bt,i;
  int sb = 0;

  {
    int b = blc[ch];
    rawout1=block[b][ch];
    b=1-b;
    rawout2=block[b][ch];
    blc[ch] = b;
  }

  if(gr_info->mixed_block_flag)
  {
    sb = 2;
    dct36(fsIn[0],rawout1,rawout2,win(0),tspnt);
    dct36(fsIn[1],rawout1+18,rawout2+18,win1(0),tspnt+1);
    rawout1 += 36; rawout2 += 36; tspnt += 2;
  }

  bt = gr_info->block_type;
  if(bt == 2)
  {
    for (; sb<gr_info->maxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36)
    {
      dct12(fsIn[sb],rawout1,rawout2,win(2),tspnt);
      dct12(fsIn[sb+1],rawout1+18,rawout2+18,win1(2),tspnt+1);
    }
  }
  else
  {
    for (; sb<gr_info->maxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36)
    {
      dct36(fsIn[sb],rawout1,rawout2,win(bt),tspnt);
      dct36(fsIn[sb+1],rawout1+18,rawout2+18,win1(bt),tspnt+1);
    }
  }

  for(;sb<SBLIMIT;sb++,tspnt++)
  {
    for(i=0;i<SSLIMIT;i++)
    {
      tspnt[i*SBLIMIT] = *rawout1++;
      *rawout2++ = 0;
    }
  }
}

void do_silence(int granules)
{
  int gr;

  for (gr=0;gr<granules;gr++)
  {
    memset(svar.audiobuf+svar.fillofs,0,SSLIMIT*128);
    svar.fillofs+=SSLIMIT*128;
  }
}

/*
 * main layer3 handler
 */
void do_layer3(Frame *fr)
{
  int  gr, ss;
  int  scalefacs[2][39]; /* max 39 for short[13][3] mode, mixed: 38, long: 22 */
  III_sideinfo sideinfo;
  int  stereo = fr->stereo;
  int  ms_stereo,i_stereo;
  int  sfreq = fr->sampling_frequency;
  int  granules;
  char *ptr=svar.audiobuf+svar.fillofs;
  /* The following is not defined in decbuf.h */
  /*static fpl hybridInf[2][SBLIMIT][SSLIMIT];*/
  static fpl hybridOut[2][SSLIMIT][SBLIMIT];

  fr->dctR=hybridOut[0][0];
  fr->dctL=hybridOut[1][0];

  if (fr->mode == MPG_MD_JOINT_STEREO)
  {
    ms_stereo = fr->mode_ext & 0x2;
    i_stereo  = fr->mode_ext & 0x1;
  }
  else
    ms_stereo = i_stereo = 0;

  if(fr->lsf)
  {
    if (III_get_side_info_2(&sideinfo,stereo,ms_stereo,sfreq))
    {
      do_silence(1);
      return;
    }
    granules=1;
  }
  else
  {
    if (III_get_side_info_1(&sideinfo,stereo,ms_stereo,sfreq))
    {
      do_silence(2);
      return;
    }
    granules=2;
  }

  set_pointer(sideinfo.main_data_begin);

  for (gr=0;gr<granules;gr++)
  {
    {
      struct gr_info_s *gr_info = &(sideinfo.ch[0].gr[gr]);
      int part2bits;

      if(fr->lsf)
        part2bits = III_get_scale_factors_2(scalefacs[0],gr_info,0);
      else
        part2bits = III_get_scale_factors_1(scalefacs[0],gr_info);

      if(III_dequantize_sample(hybridInf[0], scalefacs[0],gr_info,sfreq,part2bits))
      {
        do_silence(granules);
        return;
      }
    }
    if (stereo == 2)
    {
      struct gr_info_s *gr_info0 = &(sideinfo.ch[0].gr[gr]);
      struct gr_info_s *gr_info1 = &(sideinfo.ch[1].gr[gr]);
      int part2bits;

      if (fr->lsf)
        part2bits = III_get_scale_factors_2(scalefacs[1],gr_info1,i_stereo);
      else
        part2bits = III_get_scale_factors_1(scalefacs[1],gr_info1);

      if (ms_stereo)
      {
        if(III_dequantize_sample_ms(hybridInf,scalefacs[1],gr_info1,sfreq,part2bits))
        {
          do_silence(granules);
          return;
        }
      }
      else
      {
        if(III_dequantize_sample(hybridInf[1],scalefacs[1],gr_info1,sfreq,part2bits))
        {
          do_silence(granules);
          return;
        }
      }

      if (i_stereo)
        III_i_stereo(hybridInf,scalefacs[1],gr_info1,sfreq,ms_stereo,fr->lsf);


      if(ms_stereo || i_stereo)
      {
        if(gr_info1->maxb > sideinfo.ch[0].gr[gr].maxb)
          sideinfo.ch[0].gr[gr].maxb = gr_info1->maxb;
        else
          gr_info1->maxb = sideinfo.ch[0].gr[gr].maxb;
      }

      III_antialias(hybridInf[0],gr_info0);
      III_hybrid(hybridInf[0], hybridOut[0], 0,gr_info0);

      III_antialias(hybridInf[1],gr_info1);
      III_hybrid(hybridInf[1], hybridOut[1], 1,gr_info1);

      for(ss=0;ss<SSLIMIT;ss++)
      {
        synth(hybridOut[0][ss],hybridOut[1][ss],ptr);
        ptr+=128;
      }
    }
    else
    {
      struct gr_info_s *gr_info0 = &(sideinfo.ch[0].gr[gr]);

      III_antialias(hybridInf[0],gr_info0);
      III_hybrid(hybridInf[0], hybridOut[0], 0,gr_info0);

      for(ss=0;ss<SSLIMIT;ss++)
      {
        synth_mono(hybridOut[0][ss],ptr);
        ptr+=128;
      }
    }
  }
  svar.fillofs+=granules*SSLIMIT*128;
}
