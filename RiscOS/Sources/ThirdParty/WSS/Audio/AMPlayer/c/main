/*
 * Main module things, and API
 */

#include "defs.h"
#include "stdio.h"
#include "stdlib.h"
#include "stdarg.h"
#include "string.h"
#include "time.h"
#include "swis.h"

#include "amplayer.h"
#include "common.h"
#include "soundX.h"
#include "sound.h"
#include "main.h"
#include "miscasm.h"
#include "fpasm.h"
#include "plugin.h"

#include "amplayer.h"
#include "id3v1.h"
#include "id3v2.h"
#include "vbr.h"
#include "event.h"
#include "Fstream.h"
#include "metadata.h"

#include "tables.h"
/*#include "tabstate.h"*/

/* Define this if you want errors running to a log file */
/* #define LOG_ERR "<AMPlayer$Dir>.Log" */

/* Define this to display buffer sizes in aminfo */
/* #define DEBUG_AMINFO_SIZES */

	void get_fib(Frame *);
	void get_frib(Frame *);
	void print_info_wss(Frib *frib, Fib *fib);
extern	void init_layer3(void);
extern	void init_layer2(void);
/*extern	void make_dct64_table(void);*/
extern	void make_voltable(int vol);

/* Main static vars */

/* Keep these in sync with a.tabstate */
enum
{ ST_IDLE, ST_START, ST_LOC, ST_PLAY, ST_PAUSE, ST_STOP, ST_CHANGE, ST_CUE,
  ST_MAX
};

#if 1
#define st_active(A) CONST_st_active2[(A)]
#define st_playing(A) CONST_st_playing2[(A)]

int CONST_st_active2[ST_MAX]=
{ FALSE,   FALSE,    TRUE,   TRUE,    TRUE,     TRUE,    TRUE,      TRUE };

int CONST_st_playing2[ST_MAX]=
{ FALSE,   FALSE,    TRUE,   TRUE,    TRUE,     FALSE,   FALSE,     FALSE };

char *statename[ST_MAX]=
{ "Dormant","About to play","Locating frame in","Playing","Paused",
  "Stopping","Changing to","Cueing"
};
#endif

/* Overall settings */
int MainVol;
int state;
#ifdef APPLICATION
int frequency;
#endif

/* Things shared with sound handler */
Svar svar;

/* Information about current file playing */
int  areanum;
int  removing_area;

/* Details of the currently playing file */
char infile[256];
int infiletype;
stream_t infilestream;

/* Details of the file to be played next */
char nextfile[256];
int nextfiletype;
stream_t nextfilestream;

#ifdef APPLICATION
char errbuf[256];
#else
char errbuf[256];
#endif
FILE *filept;
STATIC int  targetframe;
STATIC int  allow_play;
STATIC int  nextframe;
STATIC long *framepos;
STATIC int  numfp;
STATIC int  numfp_max;
Tag  curtag; /* Also used in common */
STATIC Fib  curfib;
STATIC Frib curfrib;
STATIC char fiberr[256];

#ifdef LOG_ERR
FILE   *logfile;
#endif

/*#define dostate(s) { printf("state=%i\n",s); state=s; }*/

#define dostate(s) state=s

/* Generate error block */
_kernel_oserror *err(int num,const char *msg,...)
{
  static _kernel_oserror err;
  va_list ap;

  err.errnum=num+ERRBASE;
  va_start(ap,msg);
  vsprintf(err.errmess,msg,ap);
  va_end(ap);
  return &err;
}

/* Register error to be reported later in AMPlayer_Info call */
void async_err(const char *f,...)
{
  va_list ap;

  va_start(ap,f);
  vsprintf(errbuf,f,ap);
  va_end(ap);
  #ifdef LOG_ERR
    fprintf(logfile,"frame %i: %s",nextframe-1,errbuf);
    fflush(logfile);
  #endif
}

/* Convert Frame number to time in cs */
int frame_to_time(Frame *fr,int num)
{
  return num*(fr->lay==1? 384:1152)/(freqs[fr->sampling_frequency]*(fr->lsf+1)/100);
}

/* And the other way */
int time_to_frame(Frame *fr,int time)
{
  return time*(freqs[fr->sampling_frequency]/100)*(fr->lsf+1)/(fr->lay==1? 384:1152);
}

/* Number of frame cache entries to extend the cache by per time */
#define FRAMEPOS_INTERVAL (64)

/* Number of frames to jump per jump fetch (during locate) */
#define JUMP_FRAMES       (5)

/* Remember the file offset of every 4th frame */
#define reg_pos \
if (!(nextframe&3) && ((nextframe>>2)==numfp) && (framepos!=NULL)) \
{ \
  numfp++; \
  if (numfp_max <= numfp) \
  { \
    long *fp; \
    numfp_max += FRAMEPOS_INTERVAL; \
    fp = framepos; \
    if (fp) \
      fp = realloc(framepos,numfp_max*sizeof(long int)); \
    if (fp==NULL) \
    { \
      free(framepos); \
      framepos=NULL; \
      numfp=0; \
    } \
    else \
      framepos=fp; \
  } \
  if (framepos!=NULL) \
    framepos[numfp-1]=Ftell(filept); \
}

int buffer_full(void) {

  int freespace;

  freespace=svar.playofs-svar.fillofs;

  if (freespace <= 0)
    freespace+=svar.audiobufsize;

  return freespace <= MAX_OUTPUT_BYTES_PER_FRAME;
}

STATIC void dispatch_event(void) {

  void *data;

  /*_swix(0x100+'[', 0);*/
  /* Change the frequency now */
  switch (Event_Pop(&data)) {
    case Frequency:
      svar.freq_change_is_immediate = 0;
#ifdef APPLICATION
      frequency = (int)data;
#else
      SoundX_SetRate((int)data);
#endif
      break;
    case MetaDataChange:
      MetaData_MergeWithCurrent((meta_t)data);
      break;
    case MetaDataClear:
      MetaData_Clear();
      break;
  }
  /*_swix(0x100+']', 0);*/
}

/* Try to fill the output buffer. Give up after a time lapse */
int fill_buffer(int time)
{
  int freespace;
#ifndef APPLICATION
  clock_t timeout=clock()+time;
#endif
  FrameState ok;
  int gotdata=FALSE;
  meta_t m;

  while ((allow_play) && (Event_Due())) {
    dispatch_event();
  }

  if ((freespace=svar.playofs-svar.fillofs)<=0)
    freespace+=svar.audiobufsize;

  ok = frame_ok;

  /* While we are allowed to play, there is space in the buffer, we haven't timed out, and we haven't run out of data */
#ifdef APPLICATION
  while (allow_play && (freespace>MAX_OUTPUT_BYTES_PER_FRAME) && (ok >= frame_ok))
#else
  while (allow_play && (freespace>MAX_OUTPUT_BYTES_PER_FRAME) && (clock()<timeout) && (ok >= frame_ok))
#endif
    {
    ok = read_frame(&fr);
    if (ok == frame_ok)
    {
      fr.do_layer(&fr);
      if (svar.fillofs>=svar.audiobufsize)
      {
        svar.audiobufsize=svar.fillofs;
        svar.fillofs-=svar.audiobufsize;
      }
      if ((freespace=svar.playofs-svar.fillofs)<=0)
        freespace+=svar.audiobufsize;
      gotdata=TRUE;
      nextframe++;
      reg_pos
    }
    else
    {
      if (ok == frame_eof)
        allow_play=FALSE;
    }
    /*_swix(0x100+'/', 0);*/
    m = Freadmetadata();
    /*_swix(0x100+'\\', 0);*/
    if (m)
      Event_Push(svar.fillofs, MetaDataChange, m);
  }

  while ((allow_play) && (Event_Due())) {
    dispatch_event();
  }

  return allow_play;
}

/* Canonicalise a filename */
_kernel_oserror *canonstrcpy(char *dst,const char *src)
{
  return _swix(OS_FSControl,_INR(0,5),37,src,dst,0,0,256);
}

/* Find out what buffer size to use, given the pathname */
int get_buffersize(char *file)
{
  char var[256]="AMPlayer$Buffer$";
  char val[12]="";
  int i=0,len=strlen(file);
  int vlen;

  do
  {
    var[i+16]='*';
    var[i+17]=0;
    if(_swix(OS_ReadVarVal,_INR(0,4)|_OUT(2),var,val,12,0,3,&vlen))
      vlen=0;
    if (vlen) val[vlen]=0;
    var[i+16]=file[i];
    i++;
  } while (i<=len && vlen);

  return *val? atoi(val)*MAX_OUTPUT_BYTES_PER_FRAME : AUDIOBUFSIZE;
}

/* Find out what initial volume to use */
int get_volume_variable(void)
{
  char *vol;

  vol=getenv("AMPlayer$Volume");
  return vol? atoi(vol) : NOMINALVOL;
}

/* Set the volume; so that we can restore it when we're loaded */
void set_volume_variable(void)
{
  char vol[8];
  sprintf(vol,"%i",MainVol);
  _swix(OS_SetVarVal,_INR(0,4),"AMPlayer$Volume",vol,strlen(vol),0,0);
}

/* Called just after init, to make plugins register themselves */
extern void call_reg_plugins(void);

/* Called just after init, to kill the selector module */
extern void call_kill_selector(void);

_kernel_oserror *kill_selector(_kernel_swi_regs *r, void *pw) {

  _swix(OS_CLI, _IN(0), "RMKill AMPlayerSelector");
  return NULL;
}

/* Initialise all static data */
void init_static(void *pw)
{
#ifndef APPLICATION
  _swix(Hourglass_On,0);
#endif
  state=ST_IDLE;
  *infile=0;
  infiletype=0;
  infilestream=0;
  *nextfile=0;
  nextfiletype=0;
  areanum=0;
  svar.audiobufsize=AUDIOBUFSIZE;
  svar.nextaudiobufsize=AUDIOBUFSIZE;
  svar.playofs=svar.fillofs=0;
  svar.paused=FALSE;
  svar.freq_change_is_immediate = 1;
  filept=NULL;
  framepos=NULL;
  numfp=0;
  numfp_max=0;
  MainVol=get_volume_variable();
  fr.valid=FALSE;
  curtag.valid=FALSE;
#ifndef APPLICATION
  set_stack_size(0);
#endif
  init_layer2();
  init_layer3();
  /*make_dct64_table();*/
  make_voltable(MainVol);
#ifdef APPLICATION
  call_reg_plugins();
#else
  callback(call_reg_plugins,pw);
  callback(call_kill_selector,pw);
  _swix(Hourglass_Off,0);
#endif
}

/*******************************************************************
 Function:     change_limit
 Description:  Change dynamic area size, discarding data if necessary
 Parameters:   newsize = size of new buffer
 Returns:      none
 ******************************************************************/
void change_limit(int newsize)
{
  int newlimit=(newsize/MAX_OUTPUT_BYTES_PER_FRAME)*MAX_OUTPUT_BYTES_PER_FRAME-MAX_OUTPUT_BYTES_PER_FRAME;
  int oldlimit=svar.audiobufsize;
  int playofs=svar.playofs;
  int fillofs=svar.fillofs;

  if (newlimit==oldlimit)
    return;

  /* First we set the buffer into a valid 'dead' state so that if
     things go 'wrong' we don't abort in playback */
  svar.audiobufsize=svar.nextaudiobufsize=newlimit;
  svar.playofs=0, svar.fillofs=0; /* This will pause sound */

  /* If the dynamic area changes size for a stream, we must just jump */
  if (Fisastream(filept))
    return;

  {
    /* (1) Data at end of buffer :
         [****|fill-------|play**********|audiobufsize----]nextaudiobufsize
       (2) Data only at start of buffer :
         [----|play************|fill-----|audiobufsize----]nextaudiobufsize

       * = audio data    [ = start of area
       - = gap           ] = end of area
       | = marker

       The audio data runs up to audiobufsize.
       When playback wraps we will move it up to nextaudiobufsize and we'll
       be doing a full buffer fill then.

       This is the most common case - the player tends to keep the buffer
       full.
    */
    int change=newlimit-oldlimit; /* Number of samples lost */
    int lost;
    int frame;

    if (change<0)
    {
      /* The buffer size reduced */
      if (fillofs>=playofs)
      {
        /* Case (2) */
        if (playofs>=newlimit)
        {
          /* Case (2) - reduced past buffer start
             lost the entire buffer */
          lost=fillofs-playofs;
          playofs=0, fillofs=0;
        }
        else
        {
          if (fillofs>=newlimit)
          {
            /* Case (2) - reduced past fill offset,
               lost part of the end of the buffer */
            lost=fillofs-newlimit;
            fillofs=newlimit;
          }
          else
          {
            /* Case (2) - reduced into dead space
               we've lost no samples */
            lost=0;
          }
        }
      }
      else
      {
        /* Case (1) - must have lost /some/ data */
        if (playofs>=newlimit)
        {
          /* Reduced past the play,
             lost the entire buffer */
          lost=fillofs+(oldlimit-playofs);
          playofs=0, fillofs=0;
        }
        else
        {
          /* Reduced into part of the play,
             lost first chunk + part of end chunk */
          lost=fillofs+(oldlimit-newlimit);
          fillofs=newlimit;
        }
      }
    }
    else
    {
      /* The buffer size increased */
      if (fillofs>=playofs)
      {
        /* Case (2) - we haven't lost anything, just increase space */
        lost=0;
      }
      else
      {
        /* Case (1) - we've lost the first chunk */
        lost=fillofs;
        fillofs=oldlimit; /* Move fill point to old end */
      }
    }

    /* Change lost samples into lost time in cs*/
    /* async_err("Lost %i samples %i cs",lost,(25*lost/freqs(fr.sampling_frequency))); */
    lost=(25*lost/freqs[fr.sampling_frequency]);
    /* Now turn that into frames */
    lost=time_to_frame(&fr,lost);

    /* And simulate a move back that far */
    if (lost)
    {
      if (state==ST_LOC)
      {
        if (!svar.resetonlocate)
        { /* We're in a locate we set up, so we've lost /more/ data,
             add this on and seek */
          frame=targetframe-lost;
          if ((targetframe=frame)<0)
            targetframe=0;
          svar.resetonlocate=0;
        }
        else
        {
          /* We're in a user locate, so we're going to lose data anyhow -
             no point in resyncing to a lost position */
        }
      }
      else
      {
        frame=nextframe-lost;
        if ((targetframe=frame)<0)
          targetframe=0;
        svar.resetonlocate=0;
        dostate(ST_LOC);
      }
    }
  }
  svar.fillofs=fillofs, svar.playofs=playofs;
}

/* Called when the output buffer changes size (e.g. because someone's dragging the bar) */
extern void call_bufchange(void);

_kernel_oserror *bufchange(_kernel_swi_regs *r,void *pw)
{
  if (removing_area) return NULL;
  switch (r->r[0])
  {
    case 2: /* pre shrink */
    {
      int limit=MAX_OUTPUT_BYTES_PER_FRAME*2;
      int maxloss;

      limit=(limit/MAX_OUTPUT_BYTES_PER_FRAME)*MAX_OUTPUT_BYTES_PER_FRAME+MAX_OUTPUT_BYTES_PER_FRAME;
      maxloss=r->r[4]-limit;
      if (r->r[3]>maxloss) r->r[3]=maxloss;
      if (limit & ~(r->r[5]-1))
      {
        /* The size that we can reduce by is non-0 */
        change_limit(limit);
      }
      break;
    }

    case 0: /* pre grow */
      /* Do nothing until it has grown */
      break;

    case 1: /* post grow */
    case 3: /* post shrink */
      change_limit(r->r[4]);
      break;
  }
  return NULL;
}

void removearea(void)
{
  if (!areanum) return;

  removing_area=TRUE; /* allow area to disappear now */
  _swix(OS_DynamicArea,_INR(0,1),1,areanum);
  areanum=0;
}


/* Do what is necessary to begin calling fill_buffer() */
_kernel_oserror *do_start(void *pw)
{
  _kernel_oserror *e;

#ifdef APPLICATION
  e = NULL;
#else
  e = SoundX_Init(pw);
#endif
  if (e) return e;

  if (filept==NULL)
  {
    if (infiletype == 0) {
      if (!(filept=Fopen(infile,"rb")))
        return err(ERROR_BADFILE,"File '%s' wouldn't open",infile);
    } else {
      /* Its a stream */
      if (!(filept=Fopen_stream(infilestream)))
        return err(ERROR_BADFILE,"Stream '%s' wouldn't open", infile);
    }
    Fsetvbuf(filept);
    read_frame_init(&fr);
    id3v1_gettag(filept,&curtag);
    vbr_getinfo(filept,&curtag);
    nextframe=0;
    targetframe=0;
    allow_play=TRUE;
  }

  if (!Fisastream(filept)) {
    if (framepos==NULL)
    {
      if (framepos=malloc(FRAMEPOS_INTERVAL*sizeof(long int)))
      {
        framepos[0]=0;
        numfp=1;
        numfp_max=FRAMEPOS_INTERVAL;
      }
      else {
        return err(ERROR_NOMEMORY,"Can't get enough memory to play");
      }
    }
  } else {
    free(framepos);
    framepos = NULL;
  }

  if (!areanum)
  {
    if (infiletype == 0) {
      svar.audiobufsize=svar.nextaudiobufsize=get_buffersize(infile);
    } else {
      svar.audiobufsize=svar.nextaudiobufsize=get_buffersize("Stream");
    }
    removing_area=FALSE;
#ifdef APPLICATION
    /* JRF: Please note that this is quite awkward - should we just malloc
            a block ?
            Notice the difference is the lack of a handler and the
            non-dragable bar bit is set.
     */
    if (e=_swix(OS_DynamicArea,_INR(0,8)|_OUT(1)|_OUT(3),
          0,-1,svar.nextaudiobufsize+MAX_OUTPUT_BYTES_PER_FRAME,-1,0xA0,4*1024*1024,NULL,pw,"AMPlay antishock",&areanum,&svar.audiobuf))
    {
      areanum=0;
      return e;
    }
    call_bufchange();
#else
    if (e=_swix(OS_DynamicArea,_INR(0,8)|_OUT(1)|_OUT(3),
          0,-1,svar.nextaudiobufsize+MAX_OUTPUT_BYTES_PER_FRAME,-1,0x20,4*1024*1024,call_bufchange,pw,"AMPlay antishock",&areanum,&svar.audiobuf))
    {
      areanum=0;
      return e;
    }
#endif
  }
  svar.paused=FALSE;

#ifndef APPLICATION
  _swix(OS_ServiceCall,_INR(0,1),SC_START,SERVICECALL);
#endif

  return NULL;
}

/* Clean up after playing */
void do_stop(int fatal)
{
#ifndef APPLICATION
  _swix(OS_ServiceCall,_INR(0,1),SC_STOP,SERVICECALL);
#endif

  if (framepos)
  {
    free(framepos);
    framepos=NULL;
    numfp=0;
    numfp_max=0;
  }
  fr.valid=FALSE;
  curtag.valid=FALSE;

  SoundX_Final();

  if (filept)
  {
    Fclose(filept);
    filept=NULL;
  }

/* removearea(); - nope, for some reason this makes the wimp angry */

}

/* Change to a new file without actually stopping and starting */
_kernel_oserror *do_change(void)
{
  Event_Push(svar.fillofs, MetaDataClear, NULL);
  if (filept)
    Fclose(filept);
  if (infiletype == 0) {
    if (!(filept=Fopen(infile,"rb")))
      return err(ERROR_BADFILE,"File '%s' wouldn't open",infile);
  } else {
    if (!(filept=Fopen_stream(infilestream)))
      return err(ERROR_BADFILE,"Stream '%s' wouldn't open",infile);
  }
  Fsetvbuf(filept);
  read_frame_init(&fr);
  id3v1_gettag(filept,&curtag);
  vbr_getinfo(filept,&curtag);
  nextframe=0;
  targetframe=0;
  allow_play=TRUE;
  if (framepos)
  {
    long *fp;
    fp=realloc(framepos,FRAMEPOS_INTERVAL*sizeof(long int));
    if (fp)
    {
      framepos[0]=0;
      numfp=1;
      numfp_max=FRAMEPOS_INTERVAL;
    }
    else
    {
      free(framepos);
      framepos=0;
    }
  }
#ifndef APPLICATION
  _swix(OS_ServiceCall,_INR(0,1),SC_CHANGE,SERVICECALL);
#endif
  return 0;
}

/* Locate a frame. Returns one of these: */
enum
{
  JT_IMPOSSIBLE, /* If target frame can't be found */
  JT_INPROGRESS, /* If it will take more calls to get a result */
  JT_COMPLETED   /* If request satisfied */
};

/* FIXME: Check the logic of the framepos checks at some point */
int jump_to(int target)
{
  if (target==nextframe)
    return JT_COMPLETED;
  if (target<nextframe)
  {
    if (framepos==NULL)
    { /* If no frame buffer, we need to move to the start of the file
         and look for the right frame */
      if (Fseek(filept,0,SEEK_SET))
        return JT_IMPOSSIBLE;
      nextframe=0;
      return JT_INPROGRESS;
    }

    if (Fseek(filept,framepos[target>>2],SEEK_SET))
      return JT_IMPOSSIBLE;
    nextframe=target&~3;
    while (nextframe!=target)
    {
      if (read_frame(&fr) != frame_ok)
        return JT_IMPOSSIBLE;
      if (fr.lay == 3) set_pointer(512);
      nextframe++;
    }
    return JT_COMPLETED;
  }
  if ((target-nextframe)>3)
  {
    if (framepos==NULL)
    { /* If no frame buffer, we need to move to the start of the file
         and look for the right frame */
      if (Fseek(filept,0,SEEK_SET))
        return JT_IMPOSSIBLE;
      nextframe=0;
      return JT_INPROGRESS;
    }

    if ((target>>2)<numfp)
    {
      /* Target is in a position in the file that we have passed */
      if (Fseek(filept,framepos[target>>2],SEEK_SET))
        return JT_IMPOSSIBLE;
      nextframe=target&~3;
      while (nextframe!=target)
      {
        if (read_frame(&fr) != frame_ok)
          return JT_IMPOSSIBLE;
        if (fr.lay == 3) set_pointer(512);
        nextframe++;
      }
      return JT_COMPLETED;
    }
    else
    {
      /* Target is beyond the end of the cache, and we're before the
         end of the cache too */
      if (Fseek(filept,framepos[numfp-1],SEEK_SET))
        return JT_IMPOSSIBLE;
      nextframe=(numfp-1)<<2;
      {
        int i;

        for (i=0;i<4;i++)
        {
          if (nextframe==target)
            return JT_COMPLETED;
          if (read_frame(&fr) != frame_ok)
            return JT_IMPOSSIBLE;
          if (fr.lay == 3) set_pointer(512);
          nextframe++;
        }
        reg_pos
        return JT_INPROGRESS;
      }
    }
  }

  /* Target is after current position in unexplored territory, run through
     it */
  while (nextframe!=target)
  {
    if (read_frame(&fr) != frame_ok)
      return JT_IMPOSSIBLE;
    if (fr.lay == 3) set_pointer(512);
    nextframe++;
    reg_pos
  }
  return JT_COMPLETED;
}

/* On odd occasions the AMPlayer state machine seems to manage to unthread
 * itself. One such circumstance is starting in low memory situations,
 * failing to allocate the antishock buffer, and hence not starting the sound
 * system. Because the sound system isn't started, more callbacks aren't
 * generated, and the state machine stalls in the stopping state.
 *
 * This happens (very rarely) during normal play too, but despite our best
 * efforts we've never managed to pin it down.
 *
 * We therefore introduce this grotty 'safety net' that keeps the callbacks
 * turning over at least once a second.
 */
#ifndef APPLICATION
STATIC void safety_rethread(void *pw) {

  /* Rethread ourselves */
  _swix(OS_CallAfter, _INR(0,2), 100, call_safety_net, pw);
}

_kernel_oserror *safety_net(_kernel_swi_regs *r, void *pw) {

  if (svar.busy == FALSE) {
    /* Set ourselves as generating a frame, and call us back. Race Condition, but
     * the worst that can happen here is that we generate 2 successive callbacks.
     * That shouldn't matter.
     */
    svar.busy = TRUE;
    callback(call_do_state,pw);
  }
  safety_rethread(pw);
  return NULL;
}

STATIC void dismantle_safety_net(void *pw) {

  _swix(OS_RemoveTickerEvent, _INR(0,1), call_safety_net, pw);
}

#endif
	/*****************\
	*                 *
	*  State machine  *
	*                 *
	\*****************/

extern void call_do_state(void);

#if FP
_kernel_oserror *do_state2(_kernel_swi_regs *r,void *pw);
extern void fp_enable(int *);
extern void fp_disable(int *);

_kernel_oserror *do_state(_kernel_swi_regs *r,void *pw)
{
  _kernel_oserror *e;
  int fp_save[8*3+1];

  fp_enable(fp_save);
  e = do_state2(r, pw);
  fp_disable(fp_save);
  return e;
}

_kernel_oserror *do_state2(_kernel_swi_regs *r,void *pw)
{
#else
_kernel_oserror *do_state(_kernel_swi_regs *r,void *pw)
{
#endif

#ifndef APPLICATION
#if 0
  int lvl=check_stack(call_do_state,pw);

  if (lvl)
  {
    _kernel_oswrch(4);
    _kernel_oswrch(30);
    printf("re-reg, level=%i   ",lvl-26);
    return NULL;
  }
#else
  if (check_stack(call_do_state,pw))
    return NULL;
#endif
#endif

  switch (state)
  {
    case ST_IDLE:	/* Nothing to do: */
			/* Rarely called, if at all. Don't rely on it. */
      break;

    case ST_START:	/* Play new file: */
			/* Claim buffer. */
			/* Open file. */
			/* Claim sound IRQ. */
			/* State=ST_PLAY if ok */
#ifndef APPLICATION
      _swix(Hourglass_On,0);
#endif
      dostate(do_start(pw)? ST_STOP : ST_PLAY);
#ifndef APPLICATION
      _swix(Hourglass_Off,0);
#endif
      break;

    case ST_LOC:	/* Locate: */
			/* Skip to targetframe if necessary. */
			/* Stop if impossible. */
			/* State=ST_PLAY or ST_PAUSE */
      if (!allow_play) {
        dostate(ST_STOP);
      }
      else
      {
        int i;
        int jumpstate;
        for (i=0; i<JUMP_FRAMES; i++)
        {
          jumpstate=jump_to(targetframe);
          if (jumpstate!=JT_INPROGRESS)
            break;
        }
        switch (jumpstate)
        {
          case JT_IMPOSSIBLE:
            dostate(ST_STOP);
            break;
          case JT_COMPLETED:
            if (svar.resetonlocate)
            {
              /* drop buffer and fill from new point */
              svar.playofs=svar.fillofs=0;
            }
            else
            {
              /* Continue from the end of the buffer, ensuring a form of
                 continuity for dynamic area resizes */
            }
            dostate(svar.paused? ST_PAUSE : ST_PLAY);
            break;
        }
      }
      break;

    case ST_PLAY:	/* Fill buffer: */
			/* Call appropriate do_layer() routine. */
			/* When no more frames, State=ST_STOP */
      if (!(fill_buffer(10))) {
        dostate(ST_STOP);
      }
      break;

    case ST_PAUSE:	/* Stay put: */
			/* Keep buffer filled anyway, with short timeout */
      svar.paused=TRUE;
      if (!(fill_buffer(1))) {
        dostate(ST_STOP);
      }
      break;

    case ST_STOP:	/* Clean up: */
			/* If paused, don't wait for buffer. */
			/* Change to queued file if any. */
			/* Else wait for remaining buffer (if not paused) */
			/* Release sound IRQ. */
			/* Close file. */
			/* Release buffer. */
			/* State=ST_IDLE */
      if (svar.paused)
        svar.playofs=svar.fillofs;
      MetaData_Clear();
      if ((*nextfile) || (nextfilestream))
      {
        strcpy(infile,nextfile);
        infiletype = nextfiletype;
        infilestream = nextfilestream;
        nextfiletype=0;
        *nextfile=0;
        nextfilestream=0;
        dostate(ST_CHANGE);
      }
      else
      {
        svar.paused=FALSE;
        if (svar.playofs==svar.fillofs)
        {
          do_stop(FALSE);
          *infile=0;
          infiletype = 0;
          infilestream = 0;
          dostate(ST_IDLE);
          svar.freq_change_is_immediate = 1;
        }
      }
      break;

    case ST_CHANGE:	/* Change to new file: */
			/* Close current file */
			/* Open new file */
			/* State=ST_PLAY or ST_PAUSE */
#ifndef APPLICATION
      _swix(Hourglass_On,0);
#endif
      if (!do_change()) {
        dostate(svar.paused? ST_PAUSE : ST_PLAY);
      }
      else
      {
        dostate(ST_STOP);
      }
#ifndef APPLICATION
      _swix(Hourglass_Off,0);
#endif
      break;

    case ST_CUE:	/* Cue new file: */
			/* Claim buffer. */
			/* Open file. */
			/* Claim sound IRQ. */
			/* State=ST_PAUSE if ok */
#ifndef APPLICATION
      _swix(Hourglass_On,0);
#endif
      dostate(do_start(pw)? ST_STOP : ST_PAUSE);
#ifndef APPLICATION
      _swix(Hourglass_Off,0);
#endif
      break;

  }
  svar.busy=FALSE; /* Done: allow sound IRQ to register another callback */
  return NULL;
}

/* Start state machine in play mode, or just queue a file.
 * Sound routine is not active yet,
 * so register the first callback manually
 */
_kernel_oserror *playfile(void *pw, const char *name, int queue, int hold)
{
  if (queue && *name==0)
  {
    *nextfile=0;
    nextfiletype = 0; /* File */
    return 0;
  }
  if (queue && st_playing(state)) {
    canonstrcpy(nextfile,name);
    nextfiletype = 0; /* File */
    nextfilestream = 0;
  } else {
    canonstrcpy(infile,name);
    infiletype = 0; /* File */
    infilestream = 0;
    *nextfile = 0;
    nextfiletype = 0; /* File */
    nextfilestream = 0;
    if (st_active(state))
    {
      if (hold) svar.paused=TRUE;
      dostate(ST_CHANGE);
    }
    else
    {
#ifdef APPLICATION
      call_do_state();
#else
      _kernel_oserror *e;

      if (e=callback(call_do_state,pw))
        return e;
#endif
      dostate(hold? ST_CUE : ST_START);
      svar.busy=TRUE;
    }
  }
  return 0;
}

/* Start state machine in play mode, or just queue a file.
 * Sound routine is not active yet,
 * so register the first callback manually
 */
_kernel_oserror *playstream(void *pw, const char *name, int queue, int hold, int *stream)
{
  char tmp[1];

  *tmp = 0;
  if (name == NULL)
    name = tmp;
  if (queue && *name==0)
  {
    *nextfile=0;
    nextfiletype = 1; /* Stream */
    return 0;
  }
  if (queue && st_playing(state)) {
    nextfilestream = stream_open();
    *stream = (int)nextfilestream;
    if (nextfilestream == NULL)
      return err(ERROR_NOMEMORY, "Stream failed to open");
    strncpy(nextfile,name,255);
    nextfiletype = 1; /* Stream */
  } else {
    infilestream = stream_open();
    *stream = (int)infilestream;
    if (infilestream == NULL)
      return err(ERROR_NOMEMORY, "Stream failed to open");
    strncpy(infile,name,255);
    infiletype = 1; /* Stream */
    *nextfile=0;
    nextfiletype = 0; /* File */
    nextfilestream = 0;
    if (st_active(state))
    {
      if (hold) svar.paused=TRUE;
      dostate(ST_CHANGE);
    }
    else
    {
#ifdef APPLICATION
      call_do_state();
#else
      _kernel_oserror *e;

      if (e=callback(call_do_state,pw))
        return e;
#endif
      dostate(hold? ST_CUE : ST_START);
      svar.busy=TRUE;
    }
  }
  return 0;
}



	/****************\
	*                *
	* Module entries *
	*                *
	\****************/

_kernel_oserror *init_code(char const *cmd, int pod, void *pw)
{
  int need;
  _kernel_oserror *e;

  if (pod >= 0x03000000) {
    pod = 0;
  }

#if 1
  need = NeedARM7M();
  switch (need) {
    case 0:
      if (cputype()!=0)
        return err(ERROR_BADPROCESSOR,"This is the slow non-ARM7M version, use the ARM7M one instead");
      break;
    case 1:
      if (cputype()!=1)
        return err(ERROR_BADPROCESSOR,"This version of AMPlayer requires ARM7M, StrongARM, or similar");
      break;
    case 2:
      if (cputype()!=2)
        return err(ERROR_BADPROCESSOR,"This version of AMPlayer requires Hardware FP!");
      break;
    default:
      return err(ERROR_BADPROCESSOR,"Unknown CPU variant! Sorry.");
      break;
  }
#endif
  e = SoundX_PreInit(pod);
  if (e)
    return e;
  init_static(pw);
  pi_init();
#ifndef APPLICATION
  safety_rethread(pw);
#endif
  #ifdef LOG_ERR
   logfile=fopen(LOG_ERR,"w");
  #endif
  return NULL;
}

_kernel_oserror *final_code(int fatal, int pod, void *pw)
{
  if (state!=ST_IDLE)
    do_stop(TRUE);
#ifndef APPLICATION
  removecallback(call_do_state,pw);
  removecallback(call_reg_plugins,pw);
  removecallback(call_kill_selector,pw);
#endif
  set_volume_variable();
  removearea();
  pi_die();
#ifndef APPLICATION
  dismantle_safety_net(pw);
#endif
#ifdef LOG_ERR
  fclose(logfile);
#endif
  return NULL;
}

void service_code(int num, _kernel_swi_regs *r, void *pw)
{
  switch (num)
  {
    case 0x54: /* Service_Sound - parts of the sound system changing state */
      SoundX_Service(r->r[0],pw);
      break;
    case 0x92: /* Area renumbered */
      if (areanum && (areanum==r->r[2]))
        areanum=r->r[3]; /* Dynamic area renumber  */
      break;
    case 0x80: /* Shutdown complete */
      _swix(AMPlayer_Stop,_IN(0),0);
      break;
  }
}

_kernel_oserror *module_cmd(char const *args, int argc, int cmd, void *pw)
{
  _kernel_oserror *e;

  switch (cmd)
  {
    case CMD_AMPlay: /* AMPlay <filename> [-Queue|-Cue] */
    {
      struct
      {
        char *infile;
        int   queue;
        int   hold;
        char  space[256];
      } argbuf;

      if (e=_swix(OS_ReadArgs,_INR(0,3),"in/A,Queue=Q/S,Cue=C/S",args,&argbuf,sizeof(argbuf)))
        return e;
      return playfile(pw, argbuf.infile, argbuf.queue, argbuf.hold);
    }

    case CMD_AMPause: /* AMPause [-Off] */
    {
      struct
      {
        int   off;
        char  space[16];
      } argbuf;

      if (e=_swix(OS_ReadArgs,_INR(0,3),"Off/S",args,&argbuf,sizeof(argbuf)))
        return e;
      return _swix(AMPlayer_Pause,_IN(0),argbuf.off);
    }

    case CMD_AMStop: /* AMStop */
      return _swix(AMPlayer_Stop,_IN(0),0);

    case CMD_AMInfo: /* AMInfo [-Plugins] [<file>] */
    {
      static struct
      {
        int   pi;
        char  *filename;
        char  space[1280];
      } argbuf;

      if (e=_swix(OS_ReadArgs,_INR(0,3),"Plugins=P/S,File=F",args,&argbuf,sizeof(argbuf)))
        return e;
      if (argbuf.pi)
        pi_list();
      else
      {
        Fib fib;
        Frib frib;
        Fib *fibp;
        Frib *fribp;
        int state;
        int time;
        if (argbuf.filename)
        {
          e=_swix(AMPlayer_FileInfo,_INR(0,3),FIB_TAG | FIB_TTIME,
                                              argbuf.filename,
                                              &fib,&frib);
          if (e && (e->errnum != ERRBASE+ERROR_NOID3))
            return e;
          if (e)
          {
            e=_swix(AMPlayer_FileInfo,_INR(0,3),FIB_TTIME,argbuf.filename,
                                                &fib,&frib);
            if (e)
              return e;
          }
          fibp=&fib;
          fribp=&frib;
          state=ST_PLAY;
          printf("File: %s\n",argbuf.filename);
        }
        else
        {
          e=_swix(AMPlayer_Info,_INR(0,4)|_OUTR(0,4),0,NULL,NULL,NULL,-1,
                                &state,&argbuf.filename,&fibp,&fribp,&time);
          if (e)
            return e;

          printf("AMPlayer status: %s %s\n",statename[state],
                                   argbuf.filename ? argbuf.filename : "");
        }
        if (st_active(state))
          print_info_wss(fribp,fibp);

#ifdef DEBUG_AMINFO_SIZES
        printf("Buffer size = %ik (%i), currently using %ik (%i)\n",
                svar.audiobufsize/1024, svar.audiobufsize);
                svar.nextaudiobufsize/1024, svar.nextaudiobufsize,
                /* Note: The previous two entries were reversed incorrectly */
        printf("Fill offset = %ik (%i), Play offset %ik (%i)\n",
                svar.fillofs/1024, svar.fillofs,
                svar.playofs/1024, svar.playofs);
        printf("File offset = %li\n",Ftell(filept));
#endif
      }
      break;
    }

    case CMD_AMVolume: /* AMVolume <number> */
    {
      int v;

      if (sscanf(args,"%u",&v)!=1)
        return err(ERROR_BADPARAMETER,"Number not recognised");

      return _swix(AMPlayer_Control,_INR(0,1),0,v);
    }

    case CMD_AMLocate: /* AMLocate <time> */
    {
      int hh=0,mm=0,ss=0;

      if (sscanf(args,"%u:%u",&mm,&ss)!=2 &&
          sscanf(args,"%u:%u:%u",&hh,&mm,&ss)!=3)
        return err(ERROR_BADPARAMETER,"Time not recognised");

      return _swix(AMPlayer_Locate,_INR(0,1),0,((hh*60+mm)*60+ss)*100);
    }

  }
  return NULL;
}

_kernel_oserror *swi_code(int swi_no, _kernel_swi_regs *r,void *pw)
{
  switch (swi_no)
  {
    case AMPlayer_Play - AMPlayer_00: /* AMPlayer_Play */
      return playfile(pw, (char*) r->r[1], r->r[0]&1, r->r[0]&2);

    case AMPlayer_Stop - AMPlayer_00: /* AMPlayer_Stop */
      allow_play=FALSE;
      if (!(r->r[0]&1))
      {
        *nextfile=0;
        svar.playofs=svar.fillofs;
      }
      break;

    case AMPlayer_Pause - AMPlayer_00: /* AMPlayer_Pause */
      if (st_playing(state))
      {
        if (r->r[0]&1)
        {
          if (state==ST_PAUSE)
          {
            svar.paused=FALSE;
            dostate(ST_PLAY);
          }
        }
        else
          dostate(ST_PAUSE);
      }
      break;

    case AMPlayer_Locate - AMPlayer_00: /* AMPlayer_Locate */
      if (st_playing(state))
      {
        if (Fisastream(filept))
          return err(ERROR_STREAMLOCATE,"Cannot locate on a stream");
        else
        {
          if ((targetframe=time_to_frame(&fr,r->r[1]))<0)
            targetframe=0;
          svar.resetonlocate=1;
          dostate(ST_LOC);
        }
      }
      break;

    case AMPlayer_Info - AMPlayer_00: /* AMPlayer_Info */
      r->r[0]=state;
      r->r[1]=(int)infile;
      get_fib(&fr);
      r->r[2]=(int)&curfib;
      if (st_playing(state) && fr.valid)
      {
        get_frib(&fr);
        r->r[3]=(int)&curfrib;
      }
      if (state==ST_LOC)
        r->r[4]=frame_to_time(&fr,targetframe);
      break;

    case AMPlayer_Control - AMPlayer_00: /* AMPlayer_Control */
      switch (r->r[0])
      {
        case CONTROL_VOLUME: /* r/w volume */
          {
            int v=MainVol;

            if (r->r[1]!=-1)
            {
              if ((r->r[1]>=0) && (r->r[1]<=127))
              {
                MainVol=r->r[1];
                make_voltable(MainVol);
              }
              else
                return err(ERROR_BADVOLUME,"Volume out of range");
            }
            r->r[1]=v;
            return NULL;
          }

        case CONTROL_BUFFERSIZE: /* r/w output buffer size */
          {
            int oldsize=0; /* Don't know the size */
            _kernel_oserror *e=NULL;

            if (r->r[1]!=-1)
            {
              if (areanum)
              {
                e=_swix(OS_ReadDynamicArea,_IN(0)|_OUT(1),areanum,&oldsize);
                if (!e)
                  e=_swix(OS_ChangeDynamicArea,_INR(0,1),areanum,
                                                         r->r[1]-oldsize);
              }
              else
                svar.audiobufsize=svar.nextaudiobufsize=r->r[1];
            }
            r->r[1]=oldsize;
            return e;
          }

        case CONTROL_STACKLEVEL: /* set stack check level */
          {
            set_stack_size(r->r[1]);
            return NULL;
          }

        case CONTROL_ID3v2: /* Change ID3v2 parameters */
          return id3v2_control(r->r[1],r);

      }
      return err(ERROR_BADCONTROL,"Bad reason for AMPlayer_Control");
      break;

    case AMPlayer_Plugin - AMPlayer_00: /* AMPlayer_Plugin */
    {
      union dickon {
        _kernel_swi_regs r;
        plugin_code      *f[10];
      } *hood;

      hood = (union dickon *) r;

      switch (r->r[0])
      {
        case PLUGIN_ADD: /* Add
        	   r1->pw
        	   r2->pre_dct code
        	   r3->post_dct code
        	   r4->info block
        	 */
          return pi_add((void*)r->r[1],
                        hood->f[2],
                        hood->f[3],
                        (plugin_info*)r->r[4]);
        case PLUGIN_REMOVE: /* Remove
        	   r1->pw
        	   r2->pre_dct code
        	   r3->post_dct code
        	 */
          return pi_remove((void*)r->r[1],
                           hood->f[2],
                           hood->f[3]);
        case PLUGIN_ENUMERATE: /* Enumerate
                   r1=0 or preserved from last call
                 */
          r->r[1]=(int)pi_enum((Plugin*)r->r[1]);
          break;

      }
      break;
    }

    case AMPlayer_FileInfo - AMPlayer_00: /* AMPlayer_FileInfo */
      if (r->r[0])
        return read_fileinfo(r->r[0], (char*)r->r[1], (Fib*)r->r[2], (Frib*)r->r[3]);
      else
      {
        r->r[2] = sizeof(Fib);
        r->r[3] = sizeof(Frib);
      }
      break;

    case AMPlayer_StreamOpen - AMPlayer_00:
      return playstream(pw, (char*) r->r[1], r->r[0]&1, r->r[0]&2, &r->r[0]);
      break;

    case AMPlayer_StreamClose - AMPlayer_00:
      return stream_close((stream_t)r->r[0]);
      break;

    case AMPlayer_StreamGiveData - AMPlayer_00:
      return stream_givedata((stream_t)r->r[0], (stream_block_t)r->r[1]);
      break;

    case AMPlayer_StreamInfo - AMPlayer_00: /* AMPlayer_Info */
      switch (stream_is_active((stream_t)r->r[0])) {
        case -1:
          return err(ERROR_BADSTREAM,"No Such Stream!");
          break;
        case 0:
          r->r[0] = 0;
          break;
        case 1:
          r->r[0] = 1;
           if (buffer_full())
            r->r[0] |= 2;
          if (state == ST_PAUSE)
            r->r[0] |= 4;
          break;
      }
      break;

    case AMPlayer_MetaDataPollChange - AMPlayer_00: /* AMPlayer_MetaDataPollChange */
      r->r[0] = MetaData_PollChange();
      break;

    case AMPlayer_MetaDataLookup - AMPlayer_00: /* AMPlayer_MetaDataPollChange */
      {
        char *p;
        int l;
        p = MetaData_Lookup((const char *)r->r[0], &l);
        if (p) {
          memcpy((char *)r->r[1], p, ((r->r[2] < l) ? r->r[2] : l));
          r->r[2] = l;
        } else {
          r->r[2] = 0;
        }
      }
      break;

    case AMPlayer_SoundSystem - AMPlayer_00: /* AMPlayer_SoundSystem */
    {
      _kernel_oserror *err;

      err = SoundX_SelectSystem((sound_system)r->r[1]);
      if (err)
        return err;
      r->r[0] = SoundX_AvailableSystems();
      break;
    }

    case AMPlayer_StreamReadData - AMPlayer_00: /* AMPlayer_StreamReadData */
    {
      return SoundUser_StreamReadData(r->r[1], &r->r[2], &r->r[3], &r->r[4], &svar);
    }

    default:
      return error_BAD_SWI;
  }
  return NULL;
}

void get_fib(Frame *fr)
{
  int flags=0;

  {
    int used;

    if ((used=svar.fillofs-svar.playofs)<0) used+=svar.audiobufsize;
    curfib.ratio=100*used/svar.audiobufsize;
    if (fr->valid)
    {
      if ((curfib.etime=frame_to_time(fr,nextframe)-(25*used/freqs[fr->sampling_frequency]))>=0)
        flags|=FIB_ETIME;
    }
  }
  if (fr->valid && ((curtag.filesize && !fr->bitrate_variable) ||
                    (curtag.framesize && fr->bitrate_variable)))
  {
    int framesize=curtag.framesize;
    if (framesize)
    {
      curfib.ttime=frame_to_time(fr,framesize);
    }
    else
    {
      int bps = tabsel_123(fr->lsf,fr->lay-1,fr->bitrate_index);

      curfib.ttime=curtag.filesize*4/(bps*5);
    }
    flags|=FIB_TTIME;
  }
  if (curtag.valid)
  {
    curfib.title=  curtag.title;
    curfib.artist= curtag.artist;
    curfib.album=  curtag.album;
    curfib.year=   curtag.year;
    curfib.comment=curtag.comment;
    curfib.genre=  curtag.genre;
    curfib.track=  curtag.track;
    if (curfib.track!=0)
      flags|=FIB_TRACK;
    flags|=FIB_TAG;
  }
  if (!get_vu(&curfib.vu_l,&curfib.vu_r,&svar)) flags|=FIB_VU;
  curfib.volume=MainVol;
  if (*errbuf!=0)
  {
    strcpy(fiberr,errbuf);
    curfib.error=fiberr;
    *errbuf=0;
    flags|=FIB_ERROR;
  }
  if (*nextfile!=0)
  {
    curfib.nextfile=nextfile;
    flags|=FIB_NEXT;
  }
  if (fr->bitrate_variable)
  {
    flags|=FIB_VBR;
    curfib.bitrate_low=tabsel_123(fr->lsf,fr->lay-1,fr->bitrate_low);
    curfib.bitrate_high=tabsel_123(fr->lsf,fr->lay-1,fr->bitrate_high);
  }
  if (filept && Fisastream(filept))
    flags|=FIB_STREAM;

  curfib.flags=flags;
}

void get_frib(Frame *fr)
{
  strcpy(curfrib.mpegver,fr->mpeg25?"2.5":(fr->lsf?"2.0":"1.0"));
  curfrib.layer=fr->lay;
  curfrib.freq=freqs[fr->sampling_frequency];
  curfrib.bitrate=tabsel_123(fr->lsf,fr->lay-1,fr->bitrate_index);
  curfrib.mode=fr->mode;
  curfrib.chan=fr->stereo;
  curfrib.flags=(fr->copyright?FRIB_COPYRIGHT:0) |
                (fr->original?FRIB_ORIGINAL:0) |
                (fr->crc?FRIB_CRC:0);
  curfrib.dctL=fr->dctL;
  curfrib.dctR=fr->dctR;
}

void print_time(unsigned int time)
{
  if (time>(60*60*100))
  {
    printf("%i:",time/(60*60*100));
    time=time%(60*60*100);
  }

  printf("%02i:",time/(60*100));
  time=time%(60*100);
  printf("%02i.",time/100);
  time=time%100;
  printf("%02i",time);
}

void print_info_wss(Frib *frib,Fib *fib)
{
  char *modes[4] = { "Stereo", "Joint-Stereo", "Dual-Channel", "Single-Channel" };
  char *layers[4] = { "Unknown" , "I", "II", "III" };

  if (frib)
  {
    printf("MPEG %s, Layer %s, %i Hz, %s, ",
            &frib->mpegver, layers[frib->layer], frib->freq,
            modes[frib->mode]);
    if (fib && (fib->flags & FIB_VBR))
        printf("%i-%i kbits/s\n",
               fib->bitrate_low, fib->bitrate_high);
    else
        printf("%i kbit/s\n",frib->bitrate);
    printf("Channels: %i, %sopyright, %s, %s\n",
            frib->chan,
            (frib->flags&1)?"C":"No c",
            (frib->flags&2)?"Original":"Copy",
            (frib->flags&4)?"CRC":"No CRC");
  }
  if (fib)
  {
    unsigned int flags;
    flags=fib->flags;
    if (flags & FIB_TTIME)
    {
      printf("Total time: ");
      print_time(fib->ttime);
      printf("\n");
    }
    if (flags & FIB_ETIME)
    {
      printf("Elapsed time: ");
      print_time(fib->etime);
      printf("\n");
    }
    if (flags & FIB_TAG)
    {
      printf("ID3 tag information:\n");
      if (*fib->title)   printf("Title:   %s\n",fib->title);
      if (*fib->artist)  printf("Artist:  %s\n",fib->artist);
      if (*fib->album)   printf("Album:   %s\n",fib->album);
      if (*fib->year)    printf("Year:    %s\n",fib->year);
      if (*fib->comment) printf("Comment: %s\n",fib->comment);
      if ((flags & FIB_TRACK) && fib->track)
        printf("Track:   %i\n",fib->track);
    }
  }
}
