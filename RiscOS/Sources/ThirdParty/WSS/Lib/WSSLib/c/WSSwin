/******************************************************/
/*                                                    */
/* Name: WSSwin.c                                     */
/* Author: Paul Gardiner.                             */
/* Function: Provides a library of functions for      */
/*           manipulating windows.                    */
/*                                                    */
/******************************************************/

#include "kernel.h"
#include "swis.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "WSSerr.h"
#include "WSSgr.h"
#include "WSSptr.h"
#include "WSSfs.h"
#include "WSSicn.h"
#include "WSSicnH.h"
#include "WSSdevH.h"
#include "WSSmnu.h"
#include "WSSmnuH.h"
#include "WSSspr.h"
#include "WSSsprH.h"
#include "WSSwin.h"
#include "WSSwinH.h"
#include "WSSmem.h"

#define MAX_TPLT_SIZE (1024*4)
#define MAX_TITLE_SIZE (80)


static _kernel_swi_regs regs;
static int task;
static struct win_window_s icon_bar = {-2};
static win_window window_list = &icon_bar;
static void *win_data = NULL;
static int double_clicked = 0;
static win_window rubber_band_window = NULL;
static win_new_mode mode_change_handler = NULL;
static win_data_open data_open_handler = NULL;
static char task_name[21];
struct redraw_area_s xyzREDRAW_AREAxyz;

void (*xyzREDRAW_SLIDERxyz)(win_window, int *) = NULL;
void (*xyzDRAG_SLIDERxyz)(int *) = NULL;
void (*xyzPOLL_SLIDERxyz)(void) = NULL;
void (*xyzKILL_SLIDERxyz)(win_window) = NULL;
void (*xyzTASK_DYINGxyz)(int *) = NULL;
void (*xyzPLUGIN_MESSAGExyz)(int *) = NULL;

static void *scratch = NULL;
static int scratch_size = 0;

static char font_ref[256] = {0};

struct callback_list {
  win_callback		 cb;
  void 			*data;
  struct callback_list	*next;
};

static struct callback_list *pending_callbacks;

static void lose_fonts(void)
{
    int i;

    for(i = 1; i < 256; i++)
    {
        regs.r[0] = i;
        while(font_ref[i] > 0)
        {
            _kernel_swi(Font_LoseFont, &regs, &regs);
            font_ref[i]--;
        }
    }
}

static void skip(void) {}

static win_window add(int handle, char *title, int n_icon, void *indir)
{
    win_window win;

    win = (win_window) Malloc0(sizeof(struct win_window_s));
    if(win == NULL)
    {
        ErrorFatal("Insufficient memory to create window");
        return NULL;
    }
    win->handle    = handle;
    win->indir     = indir;
    win->title     = title;
    win->draw      = NULL;
    win->click_s   = NULL;
    win->click_m   = NULL;
    win->click_a   = NULL;
    win->click_c   = NULL;
    win->key       = NULL;
    win->caret     = NULL;
    win->select    = NULL;
    win->load      = NULL;
    win->data      = NULL;
    win->n_icon    = n_icon;
    win->icon_data = NULL;
    win->icon_arr  = NULL;
    win->icon_recs = NULL;
    win->next      = window_list;
    win->children  = NULL;
    win->parent    = NULL;
    win->sliders   = NULL;
    win->watchsize = NULL;
    win->rawopen = NULL;
    window_list = win;
    return win;
}

static void remv(int handle)
{
    win_window *ptr;

    ptr = &window_list;
    while(*ptr != NULL && (*ptr)->handle != handle)
        ptr = &(*ptr)->next;
    if(*ptr != NULL)
    {
        win_window del;
        win_child *list, lFree;
        win_child child, next;

        del = *ptr;
	/* Unlink the window list */
        *ptr = (*ptr)->next;
	/* If this window has a parent, then unlink it from the parents child list */
	if (del->parent) {
	  list = &del->parent->children;
	  while (*list) {
	    if ((*list)->child == del) {
	      lFree = *list;
	      *list = (*list)->next;
	      Free(lFree);
	    } else {
	      list = &(*list)->next;
	    }
	  }
	}
	/* If this window has children then destroy the list, and unlink them */
	child = del->children;
	while (child) {
	  next = child->next;
	  child->child->parent = NULL;
	  Free(child);
	  child = next;
	}
	/* If this window has sliders, then destroy them */
	if (del->sliders)
	  xyzKILL_SLIDERxyz(del);
	/* Free the various icon data blocks */
	Free(del->title);
        Free(del->indir);
        Free(del->icon_data);
        Free(del->icon_recs);
        Free(del->icon_arr);
        /* And Free the window */
        Free(del);
    }
}

win_window xyzWINFINDxyz(int handle)
{
    win_window win;

    win = window_list;
    while(win != NULL && win->handle != handle)
        win = win->next;
    if(win != NULL)
        win_data = win->data;
    return win;
}


void WinInit(char *name)
{
    static int messages[] = {1,2,3,4,5,11,12,0x400C1,0x400c3,0x4D540,0x4D541,
      				0x4D542,0x4D543,0x4D544,0x4D545,0x4D546,0x4D547,
				0x4D548,0x4D549,0x4D54A,0x4D54B,0x4D54C,0x4D54D,
				0x4D54E,0x4D54F,0x4D550,0x4D551,0x4D552, 0};
    strncpy(task_name, name, 21);
    task_name[20] = '\0';
    regs.r[0] = 310;
    regs.r[1] = 0x4B534154;
    regs.r[2] = (int) task_name;
    regs.r[3] = (int) messages;
    _kernel_swi(Wimp_Initialise, &regs, &regs);
    task = regs.r[1];
    atexit(lose_fonts);
}

void WinFin(void)
{
    regs.r[0] = task;
    regs.r[1] = 0x4B534154;
    _kernel_swi(Wimp_CloseDown, &regs, &regs);
    exit(0);
}

char *WinTaskName(void)
{
    return task_name;
}

static void do_rubber_band(win_window win, int x, int y)
{
    int drag_buf[10], win_buf[9];

    rubber_band_window = win;
    win_buf[0] = win->handle;
    regs.r[1] = (int) win_buf;
    _kernel_swi(Wimp_GetWindowState, &regs, &regs);
    drag_buf[1] = 7;
    drag_buf[2] = x;
    drag_buf[3] = y;
    drag_buf[4] = x;
    drag_buf[5] = y;
    drag_buf[6] = win_buf[1];
    drag_buf[7] = win_buf[2];
    drag_buf[8] = win_buf[3];
    drag_buf[9] = win_buf[4];
    regs.r[1] = (int) drag_buf;
    _kernel_swi(Wimp_DragBox, &regs, &regs);
}

static void window_click(int *poll)
{
    win_window win;

    win = xyzWINFINDxyz(poll[3]);
    if(win != NULL)
    {
        if((poll[2] & 0x40 || poll[2] & 0x10) && win->select != NULL)
        {
            do_rubber_band(win, poll[0], poll[1]);
        }
        else
        {
            int blk[9];

            blk[0] = poll[3];
            regs.r[1] = (int) blk;
            _kernel_swi(Wimp_GetWindowState, &regs, &regs);
            double_clicked = ((poll[2] & 0x7) != 0);
            if(poll[2] & 0x101 && win->click_a != NULL)
                win->click_a(poll[0] + blk[5] - blk[1], poll[1] + blk[6] - blk[4]);
            if(poll[2] & 0x202 && win->click_m != NULL)
                win->click_m(poll[0] + blk[5] - blk[1], poll[1] + blk[6] - blk[4]);
            if(poll[2] & 0x404 && win->click_s != NULL)
                win->click_s(poll[0] + blk[5] - blk[1], poll[1] + blk[6] - blk[4]);
        }
    }
}

static void respond_to_drag(int *poll)
{
    int blk[9];

    blk[0] = rubber_band_window->handle;
    regs.r[1] = (int) blk;
    _kernel_swi(Wimp_GetWindowState, &regs, &regs);
    rubber_band_window->select(poll[0] + blk[5] - blk[1],
                                    poll[3] + blk[6] - blk[4],
                                    poll[2] + blk[5] - blk[1],
                                    poll[1] + blk[6] - blk[4]);
    rubber_band_window = NULL;
}

static void message(int reason, int *poll)
{
    win_window win;

    switch(poll[4])
    {
        case  0: WinFin();
                 break;
        case  1:
            win = xyzWINFINDxyz(poll[5]);
            if(win != NULL && win->load != NULL)
            {
                poll[0] = 60;
                poll[3] = poll[2];
                poll[4] = 2;
                poll[9] = -1;
                strcpy((char *)(poll + 11), "<Wimp$Scrap>");
                regs.r[0] = 17;
                regs.r[1] = (int) poll;
                regs.r[2] = poll[1];
                _kernel_swi(Wimp_SendMessage, &regs, &regs);
            }
            break;
        case  2: xyzICNxyz(reason, poll);
            break;
        case  3:
            win = xyzWINFINDxyz(poll[5]);
            if(win != NULL && win->load != NULL)
            {
                win->load((char *) (poll + 11));
                if(poll[3] != 0)
                {
                    FsDelete((char *)(poll + 11));
                }
                poll[3] = poll[2];
                poll[4] = 4;
                regs.r[0] = 17;
                regs.r[1] = (int) poll;
                regs.r[2] = poll[1];
                _kernel_swi(Wimp_SendMessage, &regs, &regs);
            }
            break;
        case  4: xyzICNxyz(reason, poll);
            break;
        case  5:
            if(data_open_handler)
                if(data_open_handler(poll[10], (char *) (poll + 11)))
                {
                    poll[3] = poll[2];
                    poll[4] = 4;
                    regs.r[0] = 17;
                    regs.r[1] = (int) poll;
                    regs.r[2] = poll[1];
                    _kernel_swi(Wimp_SendMessage, &regs, &regs);
                 }
            break;
        case 11:
        case 12:
            xyzDEVxyz(reason, poll);
            break;
        case 0x400c1:
            if(mode_change_handler != NULL)
                mode_change_handler();
            break;
        case 0x400c3:
            if(xyzTASK_DYINGxyz != NULL)
                xyzTASK_DYINGxyz(poll);
            if(xyzPLUGIN_MESSAGExyz != NULL)
              xyzPLUGIN_MESSAGExyz(poll);
            break;
        case 0x4D540:
        case 0x4D541:
        case 0x4D542:
        case 0x4D543:
        case 0x4D544:
        case 0x4D545:
        case 0x4D546:
        case 0x4D547:
        case 0x4D548:
        case 0x4D549:
        case 0x4D54A:
        case 0x4D54B:
        case 0x4D54C:
        case 0x4D54D:
        case 0x4D54E:
        case 0x4D54F:
        case 0x4D550:
        case 0x4D551:
        case 0x4D552:
            if(xyzPLUGIN_MESSAGExyz != NULL)
              xyzPLUGIN_MESSAGExyz(poll);
            break;
    }
}

static int Time(void)
{
    _kernel_swi_regs regs;

    _kernel_swi(OS_ReadMonotonicTime, &regs, &regs);
    return regs.r[0];
}

static void open_panes(win_window win) {

    int blk[9];
    win_child child;
    int x0,y0,x1,y1;
    int tx0,ty0,tx1,ty1;
    int offx, offy;
    int xeig, yeig;
    int under;

    child = win->children;
    _swix(OS_ReadModeVariable, _IN(0) | _IN(1) | _OUT(2), -1, 4, &xeig);
    _swix(OS_ReadModeVariable, _IN(0) | _IN(1) | _OUT(2), -1, 5, &yeig);
    xeig = (1<<xeig)-1;
    yeig = (1<<yeig)-1;
    blk[0] = win->handle;
    regs.r[1] = (int) blk;
    _kernel_swi(Wimp_GetWindowState, &regs, &regs);
    under = blk[7];
    _kernel_swi(Wimp_GetWindowOutline, &regs, &regs);
    x0 = blk[1];
    y0 = blk[2];
    x1 = blk[3]-xeig;
    y1 = blk[4]-yeig;
    while (child) {
        blk[0] = child->child->handle;
        regs.r[1] = (int) blk;
        _kernel_swi(Wimp_GetWindowOutline, &regs, &regs);
	tx0 = blk[1];
	ty0 = blk[2];
	tx1 = blk[3]-xeig;
	ty1 = blk[4]-yeig;
        switch (child->attach) {
#if 0
          case IN_LEFT:
            offx = x0-tx1;
            offy = y1-ty1;
            break;
          case IN_RIGHT:
            offx = x1-tx0;
            offy = y1-ty1;
            break;
          case IN_TOP:
            offx = x0-tx0;
            offy = y1-ty1;
            break;
          case IN_BOTTOM:
            offx = x0-tx1;
            offy = y0-ty0;
            break;
#endif
          case OUT_LEFT:
            offx = x0-tx0;
            offy = y1-ty1;
            break;
          case OUT_RIGHT:
            offx = x1-tx1;
            offy = y1-ty1;
            break;
          case OUT_TOP:
            offx = x0-tx0;
            offy = y1-ty0;
            break;
          case OUT_BOTTOM:
            offx = x0-tx0;
            offy = y0-ty1+xeig+1;
            break;
        }
        _kernel_swi(Wimp_GetWindowState, &regs, &regs);
	blk[1] += offx;
	blk[2] += offy;
	blk[3] += offx;
	blk[4] += offy;
	blk[7]  = under;
	_kernel_swi(Wimp_OpenWindow, &regs, &regs);
        under = (int)child->child->handle;
        child = child->next;
    }
}

static void pane_open(win_window win, int poll[64]) {

  int blk[9];
  int x, y, sx, sy;

  /* Called when a pane window is opened */
  blk[0] = win->handle;
  regs.r[1] = (int)blk;
  _kernel_swi(Wimp_GetWindowState, &regs, &regs);
  x = blk[1] - poll[1];
  y = blk[4] - poll[4];
  sx = (blk[3] - blk[1]) - (poll[3] - poll[1]);
  sy = (blk[4] - blk[2]) - (poll[4] - poll[2]);
  /* Now open the parent first, and let the panes shuffle accordingly */
  blk[0] = win->parent->handle;
  regs.r[1] = (int)blk;
  _kernel_swi(Wimp_GetWindowState, &regs, &regs);
  blk[1] -= x;
  blk[2] -= y;
  blk[3] -= x;
  blk[4] -= y;
  _kernel_swi(Wimp_OpenWindow, &regs, &regs);
  open_panes(win->parent);
}

static void parent_open(win_window win, int poll[64]) {

  int blk[9];
  int x, y, sx, sy;
  win_child child;
  int xpix, ypix, xeig, yeig;

  /* Called when a pane window is opened */
  blk[0] = win->handle;
  regs.r[1] = (int)blk;
  _kernel_swi(Wimp_GetWindowState, &regs, &regs);
  x = poll[3] - poll[1];
  y = poll[4] - poll[2];
  sx = (blk[3] - blk[1]) - (poll[3] - poll[1]);
  sy = (blk[4] - blk[2]) - (poll[4] - poll[2]);
  if (sx || sy) {
    /* Resize - check for too big */
    child = win->children;
    while (child) {
      blk[0] = child->child->handle;
      regs.r[1] = (int)blk;
      _kernel_swi(Wimp_GetWindowOutline, &regs, &regs);
      switch (child->attach) {
        case OUT_TOP:
        case OUT_BOTTOM:
	  y += blk[4]-blk[2];
          break;
        case OUT_LEFT:
        case OUT_RIGHT:
	  x += blk[3]-blk[1];
          break;
      }
      child = child->next;
    }
    _swix(OS_ReadModeVariable, _IN(0) | _IN(1) | _OUT(2), -1, 4, &xeig);
    _swix(OS_ReadModeVariable, _IN(0) | _IN(1) | _OUT(2), -1, 5, &yeig);
    _swix(OS_ReadModeVariable, _IN(0) | _IN(1) | _OUT(2), -1, 11, &xpix);
    _swix(OS_ReadModeVariable, _IN(0) | _IN(1) | _OUT(2), -1, 12, &ypix);
    xpix = (xpix+1)<<xeig;
    ypix = (ypix+1)<<yeig;
    if ((x > xpix) || (y > ypix))
      return;
  }
  regs.r[1] = (int)poll;
  _kernel_swi(Wimp_OpenWindow, &regs, &regs);
  open_panes(win);
}

static void close_children(win_window win) {

  int blk[1];
  win_child child;

  child = win->children;
  while (child) {
    blk[0] = (int)child->child->handle;
    regs.r[1] = (int)blk;
    _kernel_swi(Wimp_CloseWindow, &regs, &regs);
    child = child->next;
  }
}

static int check_win_size(win_window win, int *poll) {

  int blk[9];
  int x, y, sx, sy;

  blk[0] = win->handle;
  regs.r[1] = (int)blk;
  _kernel_swi(Wimp_GetWindowState, &regs, &regs);
  x = poll[3] - poll[1];
  y = poll[4] - poll[2];
  sx = (blk[3] - blk[1]) - (poll[3] - poll[1]);
  sy = (blk[4] - blk[2]) - (poll[4] - poll[2]);
  if (sx || sy) {
    win->watchsize(poll[1], poll[2], poll[3], poll[4]);
    return 0;
  }
  return 1;
}

static int raw_win_open(win_window win, int *poll) {

  int blk[9];
  _kernel_swi_regs regs;

  win->rawopen(poll);
  blk[0] = win->handle;
  regs.r[1] = (int)blk;
  _kernel_swi(Wimp_GetWindowState, &regs, &regs);
  if ((blk[8] & 0x10000) == 0) {
    /* Closed! */
    return 0;
  }
  /* Update the poll block with where it *was* opened to */
  poll[1]=blk[1];
  poll[2]=blk[2];
  poll[3]=blk[3];
  poll[4]=blk[4];
  poll[5]=blk[5];
  poll[6]=blk[6];
  poll[7]=blk[7];
  return 1;
}

static void win_coop(int time)
{
    int poll[64];
    int reason = -1;
    static int entered = 0;
    static int entered_cb = 0;
    struct callback_list *callback, *callback2;
    int swi_num;

    if(entered)
        return;
    else
        entered = 1;
    while(reason != 0)
    {
	/* Changes here from RJW:                                                                  */
	/* 1) If we have pending callbacks, then we mustn't do either a pollidle or a poll         */
	/* with null events disabled, as callbacks want to be processed asap.                      */
	/* 2) If we do a pollidle for 'time', and then get our sleep interrupted by an event       */
	/* we want to go back to sleep only for the remaining time, not for the full 'time' again. */
        /* 3) If we have xyzPOLL_SLIDERxyz, then we need null polls to monitor the slider state.   */
        regs.r[0] = ((time < 0) && (pending_callbacks == NULL) && (xyzPOLL_SLIDERxyz == NULL)) ? 1 : 0;
        regs.r[1] = (int) poll;
        swi_num = (((time > 0) && (pending_callbacks == NULL) && (xyzPOLL_SLIDERxyz == NULL)) ? Wimp_PollIdle : Wimp_Poll);
        /* time = Desired Finish Time */
        time += Time();
        regs.r[2] = time;
        _kernel_swi(swi_num, &regs, &regs);
        reason = regs.r[0];
        switch(reason)
        {
            case 0:
              	    if (xyzPOLL_SLIDERxyz)
                        xyzPOLL_SLIDERxyz();
              	    break;
            case 1: _kernel_swi(Wimp_RedrawWindow, &regs, &regs);
                    if(regs.r[0] != 0)
                    {
                        win_window win;
                        win_draw draw;
                        int xorig, yorig;

                        win = xyzWINFINDxyz(poll[0]);
                        if(win != NULL && win->draw != NULL)
                            draw = win->draw;
                        else
                            draw = skip;
                        do
                        {
                            xorig = poll[1] - poll[5];
                            yorig = poll[4] - poll[6];
                            GrOrigin(xorig, yorig);
                            xyzREDRAW_AREAxyz.xmin = poll[7] - xorig;
                            xyzREDRAW_AREAxyz.ymin = poll[8] - yorig;
                            xyzREDRAW_AREAxyz.xmax = poll[9] - xorig;
                            xyzREDRAW_AREAxyz.ymax = poll[10] - yorig;
                            xyzREDRAW_AREAxyz.xorig = xorig;
                            xyzREDRAW_AREAxyz.yorig = yorig;
                            if (xyzREDRAW_SLIDERxyz)
                              xyzREDRAW_SLIDERxyz(win, poll);
                            GrMove(0, 0);
                            draw();
                            GrOrigin(0, 0);
                        }
                        while(_kernel_swi(Wimp_GetRectangle, &regs, &regs), regs.r[0] != 0);
                    }
                    break;
            case 2: {
                        win_window win;
                        int ok;

                        win = xyzWINFINDxyz(poll[0]);
                        ok = 1;
		        if (win->watchsize)
		          ok = check_win_size(win, poll);
		        if (ok) {
		          if (win->rawopen)
		            ok = raw_win_open(win, poll);
		        }
		        if (ok) {
			  if (win->parent) {
		            pane_open(win, poll);
			  } else if (win->children) {
			    parent_open(win, poll);
			  } else {
		            _kernel_swi(Wimp_OpenWindow, &regs, &regs);
		          }
		        }
                    }
                    break;
            case 3: {
                        win_window win;

                        win = xyzWINFINDxyz(poll[0]);
                        if (win == NULL) {
                            _kernel_swi(Wimp_CloseWindow, &regs, &regs);
                        } else {
                            if (win->parent) {
                                win = win->parent;
                                poll[0] = win->handle;
                            }
                            if (win->click_c == NULL) {
                                _kernel_swi(Wimp_CloseWindow, &regs, &regs);
                                if (win->children)
                                  close_children(win);
                            } else
                                win->click_c();
                        }
                    }
                    break;
            case 6: if(poll[3] != -1 && poll[3] != -2 && poll[4] == -1)
                        window_click(poll);
                    else
                        xyzICNxyz(reason, poll);
                    break;
            case 7: if (xyzDRAG_SLIDERxyz)
              		xyzDRAG_SLIDERxyz(poll);
                    else if(rubber_band_window != NULL)
                        respond_to_drag(poll);
                    else
                        xyzICNxyz(reason, poll);
                    break;
            case 8: {
                        win_window win;

                        win = xyzWINFINDxyz(poll[0]);
                        if(win == NULL || win->key == NULL || !win->key(poll[6]))
                        {
                            regs.r[0] = poll[6];
                            _kernel_swi(Wimp_ProcessKey, &regs, &regs);
                        }
                    }
                    break;
            case 9: xyzMNUxyz(poll);
                    break;
           case 11:
           case 12: {
                        win_window win;

                        win = xyzWINFINDxyz(poll[0]);
                        if(win != NULL && win->caret != NULL)
                            win->caret(reason == 12);
                    }
                    break;
           case 17:
           case 18:
           case 19: message(reason, poll);
                    break;
        }
        /* How much longer do we have to sleep for? */
        time -= Time();
        if (time < 0)
          time = 0;
    }
    entered = 0;
    if (entered_cb == 0) {
      entered_cb = 1;
      /* Now we process any callbacks that may be outstanding */
      callback = pending_callbacks;
      pending_callbacks = NULL;
      while (callback != NULL) {
        callback->cb(callback->data);
        callback2 = callback->next;
        Free(callback);
        callback = callback2;
      }
      entered_cb = 0;
    }
}

void WinCoOp(void)
{
    win_coop(0);
}

void WinSleep(int t)
{
    win_coop(t);
}

win_template WinStdTplt(void)
{
    static struct win_template_s tplt;
    static int data[] =
    {
        0x0000014A, 0x000001E4, 0x00000582, 0x00000448, 0x0000006C,
        0x00000334, 0xFFFFFFFF, 0xFF000002, 0xFF070207, 0x000C0103,
        0x00000000, 0x00000000, 0x00000500, 0x00000400, 0x0000003D,
        0x00006000, 0x00000001, 0x00000001, 0x6C0D700D, 0x65572021,
        0x0D216C6C, 0x00000000
    };

    tplt.handle        = (int) data;
    tplt.icn_data      = NULL;
    tplt.icn_data_size = 0;
    return &tplt;
}

typedef struct {
  int minx;
  int miny;
  int maxx;
  int maxy;
  int flags;
  int data[3];
} riscos_icon_defs;

typedef struct {
  int              vaminx;
  int              vaminy;
  int              vamaxx;
  int              vamaxy;
  int              scrollx;
  int              scrolly;
  int              under;
  int              win_flags;
  char             cols[7];
  char             res1;
  int              waminx;
  int              waminy;
  int              wamaxx;
  int              wamaxy;
  int              tbflags;
  int              waflags;
  int              sprites;
  short            minx;
  short            miny;
  char             title[12];
  int              num_icons;
  riscos_icon_defs icon[1];
} riscos_windef;

void offset_indirected_data(riscos_windef *win, int offset)
{
  int i;
  riscos_icon_defs *icon;
  int fred[150];

  for (i = 0; i < win->num_icons; i++) {
    fred[i] = 0;
    icon = &win->icon[i];
    if (icon->flags & 0x100) {
      /* Indirected icon! */
      switch (icon->flags & 3) {
        case 0:
          /* No sprite, no text, no point */
          break;
        case 1:
          /* Text only */
          icon->data[0] += offset;
          icon->data[1] += offset;
          break;
        case 2:
          /* Sprite only */
          icon->data[0] += offset;
          break;
        case 3:
          /* Text + Sprite */
          icon->data[0] += offset;
          icon->data[1] += offset;
          break;
      }
    }
  }
}

void WinDlTplt(win_template tplt)
{
  Free((void *)tplt->handle);
  Free(tplt->icn_data);
  Free(tplt);
}

win_template WinLdTplt(char *file_name, char *tplt_name)
{
    win_template tplt;
    int ind_buf, win_buf;
    int ind_size, win_size;
    char cbuf[12];

    regs.r[1] = (int) file_name;
    _kernel_swi(Wimp_OpenTemplate, &regs, &regs);

    strncpy(cbuf, tplt_name, 12);
    cbuf[11] = '\0';
    regs.r[1] = 0;
    regs.r[2] = 0;
    regs.r[3] = 0;
    regs.r[4] = -1;
    regs.r[5] = (int) cbuf;
    regs.r[6] = 0;
    _kernel_swi(Wimp_LoadTemplate, &regs, &regs);
    win_size = regs.r[1];
    ind_size = regs.r[2];
    if (win_size == NULL)
      return NULL;

    win_buf = (int) Malloc0(win_size);
    ind_buf = (int) Malloc0(ind_size);
    tplt = (win_template) Malloc0(sizeof(struct win_template_s));
    if(tplt == NULL || ((win_buf == 0) && (win_size != 0)) || ((ind_buf == 0) && (ind_size != 0)))
    {

        if(win_buf) Free((void *) win_buf);
        if(ind_buf) Free((void *) ind_buf);
        if(tplt) Free((void *) tplt);
        ErrorFatal("Insufficient memory to load template");
        return NULL;
    }

    strncpy(cbuf, tplt_name, 12);
    cbuf[11] = '\0';
    regs.r[1] = win_buf;
    regs.r[2] = ind_buf;
    regs.r[3] = ind_buf + ind_size;
    regs.r[4] = (int) font_ref;
    regs.r[5] = (int) cbuf;
    regs.r[6] = 0;
    _kernel_swi(Wimp_LoadTemplate, &regs, &regs);

    tplt->handle        = win_buf;
    tplt->icn_data      = (void *)ind_buf;
    tplt->icn_data_size = ind_size;

    _kernel_swi(Wimp_CloseTemplate, &regs, &regs);

    win_size += 4;
    if(win_size > scratch_size)
    {
        scratch_size = win_size;
        if(scratch) Free(scratch);
        scratch = Malloc0(scratch_size);
        if(scratch == NULL)
        {
            ErrorFatal("Insufficient memory for scratch buffer");
            return NULL;
        }
    }
    return tplt;
}

void WinSprites(win_template tplt, spr_sprite *sp)
{
    ((int *) tplt->handle)[16] = (*sp)->area;
}

win_window WinIconBar(void)
{
    return &icon_bar;
}

win_window WinCreate(win_template tplt)
{
    char *title = NULL;
    int *blk;
    char *indir;
    int old_blk[7];

    if(tplt == NULL)
        return NULL;

    if (tplt->icn_data_size > 0) {
      indir = Malloc0(tplt->icn_data_size);
      if (indir == NULL)
      {
        ErrorFatal("Insufficient memory to create window");
        return NULL;
      }
      memcpy(indir, tplt->icn_data, tplt->icn_data_size);
      offset_indirected_data((riscos_windef *)tplt->handle, (int)(indir) - (int)(tplt->icn_data));
    } else {
      indir = NULL;
    }
    blk = (int *) tplt->handle;
    memcpy(old_blk, &blk[14], 7 * sizeof(int));
    if((blk[7] & 0x4000000) && (blk[14] & 0x3) == 1)
    {
        title = (char *) Malloc0(MAX_TITLE_SIZE);
        if(title == NULL)
        {
            ErrorFatal("Insufficient memory to create window");
            return NULL;
        }
        if(blk[14] & 0x100)
        {
            strncpy(title, (char *) blk[18], MAX_TITLE_SIZE);
        }
        else
        {
            strncpy(title, (char *) (blk + 18), 12);
            title[12] = '\0';
        }
        blk[14] |= 0x100;
        blk[18] = (int) title;
        blk[19] = -1;
        blk[20] = MAX_TITLE_SIZE;
    }
    regs.r[1] = (int) blk;
    _kernel_swi(Wimp_CreateWindow, &regs, &regs);
    memcpy(&blk[14], old_blk, 7 * sizeof(int));
    offset_indirected_data((riscos_windef *)tplt->handle, (int)(tplt->icn_data) - (int)(indir));
    return add(regs.r[0], title, blk[21], indir);
}

void WinTitle(win_window win, char *title)
{
    int win_st[9], win_ol[5];

    if(win->title != NULL)
    {
        strncpy(win->title, title, MAX_TITLE_SIZE);
        win_st[0] = win->handle;
        regs.r[1] = (int) win_st;
        _kernel_swi(Wimp_GetWindowState, &regs, &regs);
        if(win_st[8] & 0x10000)
        {
            win_ol[0] = win->handle;
            regs.r[1] = (int) win_ol;
            _kernel_swi(Wimp_GetWindowOutline, &regs, &regs);
            regs.r[0] = -1;
            regs.r[1] = win_st[1];
            regs.r[2] = win_st[4];
            regs.r[3] = win_st[3];
            regs.r[4] = win_ol[4];
            _kernel_swi(Wimp_ForceRedraw, &regs, &regs);
        }
    }
}

void WinKill(win_window win)
{
    int block[1];

    if(win == NULL)
        return;
    block[0] = win->handle;
    regs.r[1] = (int) block;
    _kernel_swi(Wimp_DeleteWindow, &regs, &regs);
    remv(win->handle);
}

void WinOpen(win_window win)
{
    int blk[9];

    if(win == NULL)
        return;
    blk[0] = win->handle;
    regs.r[1] = (int) blk;
    _kernel_swi(Wimp_GetWindowState, &regs, &regs);
    _kernel_swi(Wimp_OpenWindow, &regs, &regs);
    if (win->children)
      open_panes(win);
}

void WinOpenHidden(win_window win)
{
    int blk[9];

    if(win == NULL)
        return;
    blk[0] = win->handle;
    regs.r[1] = (int) blk;
    _kernel_swi(Wimp_GetWindowState, &regs, &regs);
    blk[7] = -3;
    _kernel_swi(Wimp_OpenWindow, &regs, &regs);
    if (win->children)
      open_panes(win);
}

void WinOpenCentre(win_window win)
{
    int blk[9];
    int cx, cy, w, h;

    if(win == NULL)
        return;
    regs.r[0] = (int)&blk[0];
    regs.r[1] = (int)&blk[5];
    blk[0] = 4;   /* XEig -> blk[5] */
    blk[1] = 5;   /* YEig -> blk[6] */
    blk[2] = 11;  /* XWid -> blk[7] */
    blk[3] = 12;  /* YWid -> blk[8] */
    blk[4] = -1;
    _kernel_swi(OS_ReadVduVariables, &regs, &regs);
    cx = ((blk[7]+1)<<blk[5])>>1;
    cy = ((blk[8]+1)<<blk[6])>>1;

    blk[0] = win->handle;
    regs.r[1] = (int) blk;
    _kernel_swi(Wimp_GetWindowState, &regs, &regs);
    w = (blk[3]-blk[1])>>1;
    h = (blk[4]-blk[2])>>1;
    cx -= w;
    cy -= h;
    cx -= blk[1];
    cy -= blk[2];
    blk[1] += cx;
    blk[2] += cy;
    blk[3] += cx;
    blk[4] += cy;
    _kernel_swi(Wimp_OpenWindow, &regs, &regs);
    if (win->children)
      open_panes(win);
}

void WinClose(win_window win)
{
    int blk[1];

    if(win != NULL)
    {
        if (win->parent)
            win = win->parent;
        blk[0] = win->handle;
        regs.r[1] = (int) blk;
        _kernel_swi(Wimp_CloseWindow, &regs, &regs);
        if (win->children)
            close_children(win);
    }
}

void WinExtent(win_window win, int *xmin, int *ymin, int *xmax, int *ymax)
{
    int *buf;

    if(win == NULL)
        return;
    buf = scratch;
    buf[0] = win->handle;
    regs.r[1] = (int) buf;
    _kernel_swi(Wimp_GetWindowInfo, &regs, &regs);
    *xmin = buf[11];
    *ymin = buf[12];
    *xmax = buf[13];
    *ymax = buf[14];
}

void WinVisible(win_window win, int *xmin, int *ymin, int *xmax, int *ymax)
{
    int *buf;

    if(win == NULL)
        return;
    buf = scratch;
    buf[0] = win->handle;
    regs.r[1] = (int) buf;
    _kernel_swi(Wimp_GetWindowState, &regs, &regs);
    *xmin = buf[1];
    *ymin = buf[2];
    *xmax = buf[3];
    *ymax = buf[4];
}

void WinSetExtent(win_window win, int xmin, int ymin, int xmax, int ymax)
{
    int buf[9];

    //if(win->title != NULL)
    if(win != NULL)
    {
        buf[0] = xmin;
        buf[1] = ymin;
        buf[2] = xmax;
        buf[3] = ymax;
        regs.r[0] = win->handle;
        regs.r[1] = (int) buf;
        _kernel_swi(Wimp_SetExtent, &regs, &regs);
        buf[0] = win->handle;
        regs.r[1] = (int) buf;
        _kernel_swi(Wimp_GetWindowState, &regs, &regs);
        if(buf[8] & 0x10000)
        {
            _kernel_swi(Wimp_OpenWindow, &regs, &regs);
            if (win->children)
              open_panes(win);
        }
    }
}

void WinGetPlace(win_window win, int *x, int *y)
{
    int *buf;

    if(win == NULL)
        return;
    buf = scratch;
    buf[0] = win->handle;
    regs.r[1] = (int) buf;
    _kernel_swi(Wimp_GetWindowInfo, &regs, &regs);
    *x = buf[1];
    *y = buf[4];
}

#if 0
void WinGetOutPlace(win_window win, int *x, int *y)
{
    int *buf;

    if(win == NULL)
        return;
    buf = scratch;
    buf[0] = win->handle;
    regs.r[1] = (int) buf;
    _kernel_swi(Wimp_GetWindowOutline, &regs, &regs);
    *x = buf[1];
    *y = buf[4];
}
#endif

void WinGetSize(win_window win, int *w, int *h)
{
    int *buf;

    if(win == NULL)
        return;
    buf = scratch;
    buf[0] = win->handle;
    regs.r[1] = (int) buf;
    _kernel_swi(Wimp_GetWindowOutline, &regs, &regs);
    *w = buf[3]-buf[1];
    *h = buf[4]-buf[2];
}

void WinPlace(win_window win, int x, int y)
{
    int *buf;

    if(win == NULL)
        return;
    buf = scratch;
    buf[0] = win->handle;
    regs.r[1] = (int) buf;
    _kernel_swi(Wimp_GetWindowInfo, &regs, &regs);
    buf[2] += (y - buf[4]);
    buf[3] += (x - buf[1]);
    buf[4] = y;
    buf[1] = x;
    _kernel_swi(Wimp_OpenWindow, &regs, &regs);
    if(!(buf[8] & 0x10000))
    {
        _kernel_swi(Wimp_CloseWindow, &regs, &regs);
    }
}

#if 0
void WinOutPlace(win_window win, int x, int y)
{
    int *buf;

    if(win == NULL)
        return;
    buf = scratch;
    buf[0] = win->handle;
    regs.r[1] = (int) buf;
    _kernel_swi(Wimp_GetWindowOutline, &regs, &regs);
    x = x - buf[1];
    y = y - buf[4];
    buf[0] = win->handle;
    regs.r[1] = (int) buf;
    _kernel_swi(Wimp_GetWindowInfo, &regs, &regs);
    buf[2] += y;
    buf[3] += x;
    buf[4] += y;
    buf[1] += x;
    _kernel_swi(Wimp_OpenWindow, &regs, &regs);
    if(!(buf[8] & 0x10000))
    {
        _kernel_swi(Wimp_CloseWindow, &regs, &regs);
    }
}
#endif

void WinNudge(win_window win, int x, int y)
{
    int *buf;

    if(win == NULL)
        return;
    buf = scratch;
    buf[0] = win->handle;
    regs.r[1] = (int) buf;
    _kernel_swi(Wimp_GetWindowInfo, &regs, &regs);
    buf[2] += y;
    buf[3] += x;
    buf[4] += y;
    buf[1] += x;
    _kernel_swi(Wimp_OpenWindow, &regs, &regs);
    if(!(buf[8] & 0x10000))
    {
        _kernel_swi(Wimp_CloseWindow, &regs, &regs);
    }
}

void WinFullSize(win_window win)
{
    int *buf;

    if(win == NULL)
        return;
    buf = scratch;
    buf[0] = win->handle;
    regs.r[1] = (int) buf;
    _kernel_swi(Wimp_GetWindowInfo, &regs, &regs);
    buf[2] = buf[4] - (buf[14] - buf[12]);
    buf[3] = buf[1] + (buf[13] - buf[11]);
    buf[5] = buf[6] = 0;
    _kernel_swi(Wimp_OpenWindow, &regs, &regs);
    if(!(buf[8] & 0x10000))
    {
        _kernel_swi(Wimp_CloseWindow, &regs, &regs);
    }
}

void WinShowBottom(win_window win)
{
    int *buf;

    if(win == NULL)
        return;
    buf = scratch;
    buf[0] = win->handle;
    regs.r[1] = (int) buf;
    _kernel_swi(Wimp_GetWindowInfo, &regs, &regs);
    buf[6] = buf[12] + (buf[4] - buf[2]);
    _kernel_swi(Wimp_OpenWindow, &regs, &regs);
}

void WinNewMode(win_new_mode mch)
{
    mode_change_handler = mch;
}

void WinContent(win_window win, win_draw draw)
{
    if(win != NULL)
        win->draw = draw;
}

void WinRedrawArea(int *xmin, int *ymin, int *xmax, int *ymax)
{
    *xmin = xyzREDRAW_AREAxyz.xmin;
    *ymin = xyzREDRAW_AREAxyz.ymin;
    *xmax = xyzREDRAW_AREAxyz.xmax;
    *ymax = xyzREDRAW_AREAxyz.ymax;
}

void WinPatch(win_window win, int minx, int miny, int maxx, int maxy)
{
    if(win != NULL)
    {
        int buf[11];

        buf[0] = win->handle;
        buf[1] = minx;
        buf[2] = miny;
        buf[3] = maxx;
        buf[4] = maxy;
        regs.r[1] = (int) buf;
        _kernel_swi(Wimp_UpdateWindow, &regs, &regs);
        if(regs.r[0] != 0)
        {
            win_draw draw;
            int xorig, yorig;

            if(win->draw != NULL)
                draw = win->draw;
            else
                draw = skip;
            win_data = win->data;
            do
            {
                xorig = buf[1] - buf[5];
                yorig = buf[4] - buf[6];
                GrOrigin(xorig, yorig);
                xyzREDRAW_AREAxyz.xmin = buf[7] - xorig;
                xyzREDRAW_AREAxyz.ymin = buf[8] - yorig;
                xyzREDRAW_AREAxyz.xmax = buf[9] - xorig;
                xyzREDRAW_AREAxyz.ymax = buf[10] - yorig;
                GrMove(0, 0);
                draw();
                GrOrigin(0, 0);
            }
            while(_kernel_swi(Wimp_GetRectangle, &regs, &regs), regs.r[0] != 0);
        }
    }
}

void WinClickS(win_window win, win_action click)
{
    if(win != NULL)
        win->click_s = click;
}

void WinClickM(win_window win, win_action click)
{
    if(win != NULL)
        win->click_m = click;
}

void WinClickA(win_window win, win_action click)
{
    if(win != NULL)
        win->click_a = click;
}

void WinClickC(win_window win, win_closing click)
{
    if(win != NULL)
        win->click_c = click;
}

int WinDoubled(void)
{
    return double_clicked;
}

void WinPress(win_window win, win_use_char key)
{
    if(win != NULL)
    {
        win->key = key;
        if(key != NULL)
        {
            regs.r[0] = win->handle;
        }
        else
        {
            regs.r[0] = -1;
        }
        regs.r[1] = -1;
        regs.r[2] = 0;
        regs.r[3] = 0;
        regs.r[4] = 0x2000000;
        regs.r[5] = 0;
        _kernel_swi(Wimp_SetCaretPosition, &regs, &regs);
    }
}

void WinFocus(win_window win, win_caret caret)
{
    if(win != NULL)
        win->caret = caret;
}

void WinDrag(win_window win, win_select select)
{
    if(win != NULL)
        win->select = select;
}

void WinDataOpen(win_data_open doh)
{
    data_open_handler = doh;
}

void WinLoad(win_window win, win_load load)
{
    if(win != NULL)
        win->load = load;
}

void WinSetData(win_window win, void *data)
{
    if(win != NULL)
        win->data = data;
}

void *WinGetData(win_window win)
{
    return win ? win->data : NULL;
}

void *WinData(void)
{
    return win_data;
}

typedef struct {int ft;
                icn_icon drag;
                icn_icon writeable;
                icn_icon ok;
                win_save save;} *save_data;

static void ssave(void)
{
    save_data data;

    data = (save_data) WinData();
    data->save(IcnText(data->writeable));
    FsSetType(IcnText(data->writeable), data->ft);
    MnuOpen(NULL);
}

static void asave(void)
{
    save_data data;

    data = (save_data) WinData();
    data->save(IcnText(data->writeable));
    FsSetType(IcnText(data->writeable), data->ft);
}

static char *dsave_seed(void)
{
    save_data data;

    data = (save_data) WinData();
    return IcnText(data->writeable);
}

static void dsave_save(char *path)
{
    save_data data;

    data = (save_data) WinData();

    data->save(path);
    FsSetType(path, data->ft);
    if(IcnSafe())
        IcnSetText(data->writeable, path);
    MnuOpen(NULL);
}

win_window WinSaveAs(char *tplt, win_save save)
{
    win_window win;
    icn_icon *button;
    save_data data;
    char *spr_name;
    icn_drag dsave;

    win = WinCreate(WinLdTplt(tplt, "saveas"));
    button = IcnButtons(win);
    data = (save_data) Malloc0(sizeof(*data));
    if(data == NULL)
    {
        ErrorFatal("Insufficient memory to create window");
        return NULL;
    }
    data->drag = button[0];
    data->writeable = button[1];
    data->ok = button[2];
    data->save = save;
    WinSetData(win, (void *) data);
    spr_name = IcnSprName(data->drag);
    if(spr_name == NULL || sscanf(spr_name, "file_%3x", &data->ft) != 1)
        data->ft = 0xfff;
    dsave.file_type = data->ft;
    dsave.seed = dsave_seed;
    dsave.save = dsave_save;
    IcnDrag(data->drag, dsave);
    IcnClickS(data->ok, ssave);
    IcnClickA(data->ok, asave);
    return win;
}

void WinHourGlass(int onoff)
{
    if(onoff)
        _kernel_swi(Hourglass_On, &regs, &regs);
    else
        _kernel_swi(Hourglass_Off, &regs, &regs);
}

void WinHourGlassPercentage(int percent)
{
  regs.r[0] = percent;
  _kernel_swi(Hourglass_Percentage, &regs, &regs);
}

void WinRedraw(int xmin, int ymin, int xmax, int ymax)
{
    regs.r[0] = -1;
    regs.r[1] = xmin;
    regs.r[2] = ymin;
    regs.r[3] = xmax;
    regs.r[4] = ymax;
    _kernel_swi(Wimp_ForceRedraw, &regs, &regs);
}

void WinRedrawWin(win_window win, int xmin, int ymin, int xmax, int ymax)
{
    regs.r[0] = win->handle;
    regs.r[1] = xmin;
    regs.r[2] = ymin;
    regs.r[3] = xmax;
    regs.r[4] = ymax;
    _kernel_swi(Wimp_ForceRedraw, &regs, &regs);
}

void WinError(_kernel_oserror *err)
{
    PtrOn();
    PtrAnimate(NULL, 0, 0, 0, 0);
    regs.r[0] = (int) err;
    regs.r[1] = 1;
    regs.r[2] = (int) WinTaskName();
    _kernel_swi(Wimp_ReportError, &regs, &regs);
}

void WinMessage(_kernel_oserror *err)
{
    PtrOn();
    PtrAnimate(NULL, 0, 0, 0, 0);
    regs.r[0] = (int) err;
    regs.r[1] = 1+(1<<4);
    regs.r[2] = (int) WinTaskName();
    _kernel_swi(Wimp_ReportError, &regs, &regs);
}

int WinCallBack(win_callback cb, void *data)
{
  struct callback_list *entry;

  entry = (struct callback_list *)Malloc0(sizeof(struct callback_list));
  if (entry == NULL)
    return 1;
  entry->cb         = cb;
  entry->data       = data;
  entry->next       = pending_callbacks;
  pending_callbacks = entry;

  return 0;
}

void WinChild(win_window parent, win_window child, win_child_type type) {

  win_child c;

  c = Malloc0(sizeof(*c));
  if(c == NULL) {
    ErrorFatal("Insufficient memory to attach pane window");
    return;
  }
  c->attach = type;
  c->child  = child;
  c->next   = parent->children;
  parent->children = c;
  if(child->parent != NULL) {
    ErrorFatal("Single parent families only!");
    return;
  }
  child->parent = parent;
}

void WinWatchSize(win_window win, win_size size) {

  win->watchsize = size;
}

void WinRawOpen(win_window win, win_rawopen size) {

  win->rawopen = size;
}

void WinOrigin(win_window win, int *x, int *y) {

  int blk[9];

  blk[0] = win->handle;
  regs.r[1] = (int)blk;
  _kernel_swi(Wimp_GetWindowState, &regs, &regs);
  *x = blk[1] - blk[5];
  *y = blk[4] - blk[6];
}

void WinTpltBorder(win_template t, int b) {

  if (t) {
    ((char *)t->handle)[32] = (b ? 7 : 0xFF);
  }
}

int WinToggled(win_window win) {

  int win_buf[9];

  win_buf[0] = win->handle;
  regs.r[1] = (int) win_buf;
  _kernel_swi(Wimp_GetWindowState, &regs, &regs);
  return (win_buf[8] & (1<<19)) != 0;
}
