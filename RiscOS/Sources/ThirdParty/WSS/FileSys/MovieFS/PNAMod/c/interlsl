/*
 * New interleave scheme designed for RA05_6
 *
 * 11/27/96		ver 1.0		Ken
 *
 * $Log$
 * Revision 1.1.2.1.10.2  1997/09/09 17:22:50  aurika
 * merged new bitcopy routine from rvencoder1 branch
 * removed ifdefed prototype for RASL_DeInterleave
 *
 * Revision 1.1.2.1.10.1  1997/09/09 00:04:29  aurika
 * added 16 Kbps sipro codec
 *
 * Revision 1.1.2.1  1997/01/09 17:48:42  mwebb
 * Irix port
 *
 */

#include <string.h>
#include "interlsl.h"

/*
 * The interleave table was created with the following properties:
 * -equal contributions from each block
 * -symmetric (if table[i] = j, then table[j] = i), allows in-place interleave
 * -random spacing between lost frames, except
 * -no double losses
 * Solution was generated by a random-walk optimization loop.
 *
 */
/* Loss patterns for a five-block solution:
...X..X....X.X.....X.X.X........X..........X...X.X....X........X..X..X..X.......
.X..X....X........X...X..X.....X.X........X...X....X...X..X......X....X.......X.
..X..X.X.........X..........X.X...X...X..X...X.......X.....X.X.....X......X.X...
..........X.X..X....X......X.X......X...X...X...X.X.....X.....X.X......X.X......
X.......X.....X.X.......X.X........X.X.X............X....X..X.......X......X.X.X
*/
/*
static int RASL_InterleaveTable[RASL_NFRAMES * RASL_NBLOCKS] = {
	66, 21, 43, 3, 23, 47, 6, 32, 72, 19, 49, 11, 54, 13, 69, 63,
	65, 42, 18, 9, 58, 1, 22, 4, 78, 25, 70, 51, 33, 55, 46, 31,
	7, 28, 34, 74, 61, 76, 38, 67, 59, 41, 17, 2, 53, 45, 30, 5,
	48, 10, 50, 27, 71, 44, 12, 29, 56, 73, 20, 40, 64, 36, 62, 15,
	60, 16, 0, 39, 68, 14, 26, 52, 8, 57, 35, 75, 37, 77, 24, 79
};
*/

/* Loss pattern for a six-block solution
....X.X....X..........X........X....X..X....X........X....X....X....X....X.......X....X...X.....
.X.....X..........X....X...X..X...X...........X...X...X..X...........X.X...X............X.....X.
..X.......X..X......X...X............X...X.....X........X..X.....X....X...X..........X.X....X...
X........X.....X.X........X..X..........X....X......X.......X.X.............X..X.........X...X.X
............X.X.X....X......X...X..X.......X....X............X..X.X.....X.....X.X..X............
...X.X..X..........X.....X.......X....X...X......X.X...X...........X.........X....X.X......X....
*/
static int RASL_InterleaveTable[RASL_NFRAMES * RASL_NBLOCKS] = {
	63, 22, 44, 90, 4, 81, 6, 31, 86, 58, 36, 11, 68, 39, 73, 53,
	69, 57, 18, 88, 34, 71, 1, 23, 46, 94, 54, 27, 75, 50, 30, 7,
	70, 92, 20, 74, 10, 37, 85, 13, 56, 41, 87, 65, 2, 59, 24, 47,
	79, 93, 29, 89, 52, 15, 26, 95, 40, 17, 9, 45, 60, 76, 62, 0,
	64, 43, 66, 83, 12, 16, 32, 21, 72, 14, 35, 28, 61, 80, 78, 48,
	77, 5, 82, 67, 84, 38, 8, 42, 19, 51, 3, 91, 33, 49, 25, 55
};

static void bitcopy (unsigned char *toPtr, unsigned char *fromPtr,
              int bitOffsetTo, int bitOffsetFrom, int numBits)
{
    int bofMod8, botMod8, nbMod8, eightMinusBotMod8, eightMinusBofMod8, i, iMax;
    unsigned char rightInword, leftInword, *byteOffsetFrom, *byteOffsetTo,
                  alignWord, endWord;
    unsigned char lmask[9] = {0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff};
    unsigned char rmask[9] = {0, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};

    int nibbleAlignFrom, nibbleAlignTo, alignCase=30; // special case variables
    unsigned char mask[2] = {0x0f, 0xf0};

    bofMod8 = bitOffsetFrom & 0x07;  // same as %8
    botMod8 = bitOffsetTo & 0x07;
    nbMod8 = numBits & 0x07;
    eightMinusBofMod8 = 8 - bofMod8; // don't want these evaluated every loop
    eightMinusBotMod8 = 8 - botMod8;
    byteOffsetFrom = fromPtr + (bitOffsetFrom >> 3);
    byteOffsetTo = toPtr + (bitOffsetTo >> 3);
    iMax = (numBits>>3) - 1; // last output byte not handled inside a loop

    if (numBits>>3 == 0)
    // quick and easy if we have fewer than 8 bits to align

    {
       	leftInword = *(byteOffsetFrom++);
        rightInword = *(byteOffsetFrom);
        alignWord = (leftInword >> bofMod8) + (rightInword << (eightMinusBofMod8));
        alignWord &= rmask[nbMod8];

    	if (nbMod8 >= eightMinusBotMod8)  // have more extra input bits than
                                          // free space in current output byte
            {
            *(byteOffsetTo) &= rmask[botMod8];
            *(byteOffsetTo++) += (alignWord << botMod8);
            *(byteOffsetTo) = ((*byteOffsetTo) & lmask[8-(nbMod8-eightMinusBotMod8)])
                + (alignWord >> eightMinusBotMod8);
            }

       	else    // have fewer input bits than free space in current output byte
                // be careful not to overwrite extra bits already in output byte
            {
            endWord = *(byteOffsetTo) & lmask[8-(nbMod8+botMod8)];
            *(byteOffsetTo) &= rmask[botMod8];
            *(byteOffsetTo) += ((alignWord << botMod8) + endWord);
            }
        return; // finished, return to calling function
  	}

    if (bitOffsetFrom%4 == 0 && bitOffsetTo%4 == 0)
     	// byte-packing done here is optimized for the common case of nibble-alignment

    {
        nibbleAlignFrom = (bitOffsetFrom & 0x04)>>2;  // 0 implies whole-byte alignment
        nibbleAlignTo = (bitOffsetTo & 0x04)>>2;      // 1 implies half-byte alignment


        if (nibbleAlignFrom == nibbleAlignTo) {// either src and dest both byte-aligned
                                              // or both half byte-aligned
            if (nibbleAlignFrom == 0) {
                alignCase = 0;
            } else {
                alignCase = 3;
            }
        }


        if (nibbleAlignFrom != nibbleAlignTo) {
            if (nibbleAlignFrom == 0) {
                alignCase = 1;          // src aligned, dest half aligned
            } else {
                alignCase = 2;          // src half aligned, dest aligned
            }
        }

        switch (alignCase)
        {
        case 0:
            for (i=0; i<iMax; i++)
                *byteOffsetTo++ = *byteOffsetFrom++; // copy byte-by-byte directly
                break;

        case 1:
            for (i=0; i<iMax; i++)  // move two nibbles from src to dest each loop
            {                       // shift bits as necessary
                *byteOffsetTo = (*byteOffsetTo & mask[0]) +
                    ((*byteOffsetFrom & mask[0])<<4);
                *++byteOffsetTo = ((*byteOffsetFrom++ & mask[1])>>4);
            }
                break;

        case 2:
            for (i=0; i<iMax; i++)  // same as case 1, but shift other direction
            {
                *byteOffsetTo = ((*byteOffsetFrom & mask[1])>>4);
                *byteOffsetTo++ += ((*++byteOffsetFrom & mask[0])<<4);
            }
                break;

        case 3:
            {
            *byteOffsetTo &= mask[0];  // align first nibble, thereafter this is
            *byteOffsetTo += (*byteOffsetFrom & mask[1]);  // just like case 0
            for (i=0; i<iMax; i++)
                *++byteOffsetTo = *++byteOffsetFrom; // copy byte-by-byte directly
            }
                break;
        }
    }

    else
    	// this code can handle all source and destination buffer offsets

    {
    	// take the first 8 desired bits from the input buffer, store them
    	// in alignWord, then break up alignWord into two pieces to
    	// fit in the free space in two consecutive output buffer bytes

        for (i=0; i<iMax; i++)
        {
            leftInword = *(byteOffsetFrom++);
            rightInword = *(byteOffsetFrom);
            alignWord = (leftInword >> bofMod8) + (rightInword << (eightMinusBofMod8));
            *(byteOffsetTo) = (*(byteOffsetTo) & rmask[botMod8]) +
                (alignWord << (botMod8));
            *(++byteOffsetTo) = alignWord >> (eightMinusBotMod8);
        }
    }
        // special section to set last byte in fromBuf correctly

        // even if byte packing was done with the code optimized for nibble-alignment,
       	// the tricky job of setting the last output byte is still done here

            leftInword = *(byteOffsetFrom++);
            rightInword = *(byteOffsetFrom);
            alignWord = (leftInword >> bofMod8) + (rightInword << (eightMinusBofMod8));
            *(byteOffsetTo) = (*(byteOffsetTo) & rmask[botMod8]) +
                (alignWord << (botMod8));

            if (nbMod8 >= eightMinusBotMod8)
            {
            *(++byteOffsetTo) = alignWord >> (eightMinusBotMod8);

            leftInword = *(byteOffsetFrom++);
            rightInword = *(byteOffsetFrom);
            alignWord = (leftInword >> bofMod8) + (rightInword << (eightMinusBofMod8));
            alignWord &= rmask[nbMod8];
            *(byteOffsetTo++) += (alignWord << botMod8);
            *(byteOffsetTo) = ((*byteOffsetTo) & lmask[8-(nbMod8-eightMinusBotMod8)])
                + (alignWord >> eightMinusBotMod8);
            }

            else
            {
            endWord = *(++byteOffsetTo) & lmask[8-(nbMod8+botMod8)];
            *(byteOffsetTo) = alignWord >> (eightMinusBotMod8);
            leftInword = *(byteOffsetFrom++);
            rightInword = *(byteOffsetFrom);
            alignWord = (leftInword >> bofMod8) + (rightInword << (eightMinusBofMod8));
            alignWord &= rmask[nbMod8];
            *(byteOffsetTo) += ((alignWord << botMod8) + endWord);
            }


}

#if 0
/*
 * Interleave operates in-place!
 *
 * Entry:
 * buf points to NCODEBYTES * NFRAMES * NBLOCKS bytes of data.
 *
 * Exit:
 * data in buf is interleaved.
 */
void
RASL_Interleave(char *buf, int type)
{
        char temp[RASL_MAXCODEBYTES];     /* space for swapping */
        int fi, fo;                           /* frame in/out */
        int nCodeBits;
        int nCodeBytes;
        int bitOffsetTo, bitOffsetFrom;       /* for bit maniputlations */
        char *toPtr, *fromPtr;                /* for bit maniputlations */

        if(type == 0)
        {
            nCodeBits=RA65_NCODEBITS;
        }
        if(type == 1)
        {
            nCodeBits=RA85_NCODEBITS;
        }
        if(type == 2)
        {
            nCodeBits=RA50_NCODEBITS;
        }
        if(type == 3)
        {
            nCodeBits=RA160_NCODEBITS;
        }

        if(nCodeBits%8 == 0)
        {
            nCodeBytes=nCodeBits>>3;
            /* Loop sequentially thru input frames */
            for (fi = 0; fi < RASL_NFRAMES * RASL_NBLOCKS; fi++)
            {

                fo = RASL_InterleaveTable[fi];  /* frame to swap with */
		/*
		 * Note that if (fo == fi), the frame doesn't move,
		 * and if (fo < fi), we have swapped it already.
		 */
                if (fo > fi)
                {
                    /* do the swap if needed */
                    memcpy(temp, buf + fo * nCodeBytes, nCodeBytes);
                    memcpy(buf + fo * nCodeBytes, buf + fi * nCodeBytes, nCodeBytes);
                    memcpy(buf + fi * nCodeBytes, temp, nCodeBytes);
                }
            }
	}
        else
        {
            for (fi = 0; fi < RASL_NFRAMES * RASL_NBLOCKS; fi++)
            {

                fo = RASL_InterleaveTable[fi];  /* frame to swap with */
		/*
		 * Note that if (fo == fi), the frame doesn't move,
		 * and if (fo < fi), we have swapped it already.
		 */
                if (fo > fi)
                {
                    /* do the swap if needed */
                    toPtr=temp;
                    fromPtr=buf;
                    bitOffsetTo=0;
                    bitOffsetFrom=fo*nCodeBits;
                    bitcopy((unsigned char *)toPtr,(unsigned char *)fromPtr,bitOffsetTo,bitOffsetFrom,nCodeBits);

                    toPtr=buf;
                    fromPtr=buf;
                    bitOffsetTo=fo*nCodeBits;
                    bitOffsetFrom=fi*nCodeBits;
                    bitcopy((unsigned char *)toPtr,(unsigned char *)fromPtr,bitOffsetTo,bitOffsetFrom,nCodeBits);

                    toPtr=buf;
                    fromPtr=temp;
                    bitOffsetTo=fi*nCodeBits;
                    bitOffsetFrom=0;
                    bitcopy((unsigned char *)toPtr,(unsigned char *)fromPtr,bitOffsetTo,bitOffsetFrom,nCodeBits);
                }
            }
        }
}
#endif

/*
 * DeInterleave operates in-place!.
 *
 * Entry:
 * buf points to NCODEBYTES * NFRAMES * NBLOCKS bytes of interleaved data.
 * If an input block is bad, flag[block] should be set.
 *
 * Exit:
 * data in buf is deinterleaved.
 * flags[block] stores a bit array for each output block,
 * where (flags[block] & (1 << F)) is set if Fth frame is bad.
 */
void
RASL_DeInterleave(char *buf, int type, unsigned int * pFlags)
{
        char temp[RASL_MAXCODEBYTES];     /* space for swapping */
        long inFlags[RASL_NBLOCKS];           /* save input flags */
        int nCodeBytes,nCodeBits;
        int fi, fo;                           /* frame in/out */
	    int blk;
        int bitOffsetTo, bitOffsetFrom;       /* for bit maniputlations */
        char *toPtr, *fromPtr;                /* for bit maniputlations */

        if(type == 0)
        {
            nCodeBits=RA65_NCODEBITS;
        }
        if(type == 1)
        {
            nCodeBits=RA85_NCODEBITS;
        }
        if(type == 2)
        {
            nCodeBits=RA50_NCODEBITS;
        }
        if(type == 3)
        {
            nCodeBits=RA160_NCODEBITS;
        }

	/* Save input flags, and initialize output flags */
	if(pFlags)
        for (blk = 0; blk < RASL_NBLOCKS; blk++) {
		inFlags[blk] = pFlags[blk];	    /* save input */
		pFlags[blk] = 0;				/* init output to no error */
	}


        if(nCodeBits%8 == 0)
        {
            nCodeBytes=nCodeBits>>3;
            for (fi = 0; fi < RASL_NFRAMES * RASL_NBLOCKS; fi++)
            {

                fo = RASL_InterleaveTable[fi];  /* frame to swap with */
		/*
		 * Note that when (fo == fi), the frame doesn't move,
		 * and if (fo < fi), we have swapped it already.
		 */
                if (fo > fi)             /* do the swap if needed */
                {
                    memcpy(temp, buf + fo * nCodeBytes, nCodeBytes);
                    memcpy(buf + fo * nCodeBytes, buf + fi * nCodeBytes, nCodeBytes);
                    memcpy(buf + fi * nCodeBytes, temp, nCodeBytes);
		        }

		/*
		 * If frame came from bad block, set bit corresponding to new position.
		 * Only check one of the swapped pair, since other will be done when
		 * fi gets there.
		 */
                if (pFlags && inFlags[RASL_BLOCK_NUM(fi)])
                        pFlags[RASL_BLOCK_NUM(fo)] |= (1 << RASL_BLOCK_OFF(fo));
            }
        }
        else
        {
            for (fi = 0; fi < RASL_NFRAMES * RASL_NBLOCKS; fi++)
            {

                fo = RASL_InterleaveTable[fi];  /* frame to swap with */
		/*
		 * Note that when (fo == fi), the frame doesn't move,
		 * and if (fo < fi), we have swapped it already.
		 */
                if (fo > fi)             /* do the swap if needed */
                {
                    toPtr=temp;
                    fromPtr=buf;
                    bitOffsetTo=0;
                    bitOffsetFrom=fo*nCodeBits;
                    bitcopy((unsigned char *)toPtr,(unsigned char *)fromPtr,bitOffsetTo,bitOffsetFrom,nCodeBits);

                    toPtr=buf;
                    fromPtr=buf;
                    bitOffsetTo=fo*nCodeBits;
                    bitOffsetFrom=fi*nCodeBits;
                    bitcopy((unsigned char *)toPtr,(unsigned char *)fromPtr,bitOffsetTo,bitOffsetFrom,nCodeBits);

                    toPtr=buf;
                    fromPtr=temp;
                    bitOffsetTo=fi*nCodeBits;
                    bitOffsetFrom=0;
                    bitcopy((unsigned char *)toPtr,(unsigned char *)fromPtr,bitOffsetTo,bitOffsetFrom,nCodeBits);
		       }

		/*
		 * If frame came from bad block, set bit corresponding to new position.
		 * Only check one of the swapped pair, since other will be done when
		 * fi gets there.
		 */
                if (pFlags && inFlags[RASL_BLOCK_NUM(fi)])
                        pFlags[RASL_BLOCK_NUM(fo)] |= (1 << RASL_BLOCK_OFF(fo));
	    }
    }
}
