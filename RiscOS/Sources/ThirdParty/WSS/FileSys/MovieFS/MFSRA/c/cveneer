/*
    (c) Copyright Warm Silence Software Ltd, 1996
    All rights reserved.
    
    PHBG: Initial version
*/

#include <string.h>
#include "error.h"
#include "cveneer.h"

#define VENEER_SIZE (20)

typedef struct {int code[VENEER_SIZE];} veneer_t;

static veneer_t veneer[MAXVENEER] =
{
    {
        0xE59DC000,0xE92D4C30,0xE92D1000,0xE1A0AA2D,
        0xE1A0AA0A,0xE89A0030,0xE59FC028,0xE59CC000,
        0xE99C1800,0xE88A1800,0xE28AAF87,0xE3A0B000,
        0xE1A0E00F,0xE59FF010,0xE24AAF87,0xE88A0030,
        0xE28DD004,0xE8FD8C30,0x00000000,0x00000000
 /* Equivalent to:
        LDR     R12,[R13,#0]
        STMDB   R13!,{R4,R5,R10,R11,R14}
        STMDB   R13!,{R12}
        MOV     R10,R13,LSR #20
        MOV     R10,R10,LSL #20
        LDMIA   R10,{R4,R5}
        LDR     R12,PrivateWord
        LDR     R12,[R12,#0]
        LDMIB   R12,{R11,R12}
        STMIA   R10,{R11,R12}
        ADD     R10,R10,#540
        MOV     R11,#0
        MOV     R14,PC
        LDR     PC,Routine
        SUB     R10,R10,#540
        STMIA   R10,{R4,R5}
        ADD     R13,R13,#4
        LDMIA   R13!,{R4,R5,R10,R11,PC}^
    PrivateWord
        DCD     0
    Routine
        DCD     0
  */
    }
};

static int index = 0;

int CVeneer(int func, void *pw)
{
    if(index >= MAXVENEER)
        Error("Too many veneers");
    if(index > 0)
        veneer[index] = veneer[0];
    veneer[index].code[VENEER_SIZE - 1] = func;
    veneer[index].code[VENEER_SIZE - 2] = (int) pw;
    return (int) (veneer + index++);
}
