/* scbb.c - smartcard boot block internals */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "s_card.h"
#include "reg_object.h"
#define PROTOTYPES_INTERNAL
#include "reg_scbb.h"
#include "reg_status.h"
#include "reg_versn.h"
#include "enum_ddi.h"
#include "dynalloc.h"
#include "DBUG.h"

int init_scbb(void)
{
    if((sc_bb_buffer = (unsigned char *)rmalloc(3 * BOOTBLOCK_BUFFER_SIZE, "Bootblocks"))==NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "init_scbb: couldn't claim bootblock buffers\n");
        return(-1);
    }

    net_bb_buffer = sc_bb_buffer + BOOTBLOCK_BUFFER_SIZE;
    trans_bb_buffer = net_bb_buffer + BOOTBLOCK_BUFFER_SIZE;
    DBUG_PRINTF(DBUG_LVL_DIAG, "init_scbb: sc-0x%x net-0x%x trans-0x%x\n", sc_bb_buffer, net_bb_buffer, trans_bb_buffer);

    if((sc_bb_wspace = (unsigned char *)rmalloc(3 * WSPACE_BUFFER_SIZE, "BB Wspace"))==NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "init_scbb: couldn't claim workspace buffers\n");
        return(-1);
    }

    net_bb_wspace = sc_bb_wspace + WSPACE_BUFFER_SIZE;
    trans_bb_wspace = net_bb_wspace + WSPACE_BUFFER_SIZE;

    return(0);
}

int load_scbb(int sel, char *fp)
{
  FILE *fin;
  int bytes;

  if((fin=fopen(fp, "r"))==NULL) return(-1); /* couldn't see file */

  switch(sel) {
    case SELECT_NET_BB:
    	 /* keep old contents in case of disaster */
    	 memcpy((void *)&trans_bb, (void *)&net_bb, sizeof(REG_BOOTBLOCK));
    	 memcpy(trans_bb_buffer, net_bb_buffer, BOOTBLOCK_BUFFER_SIZE);
    	 memcpy(trans_bb_wspace, net_bb_wspace, WSPACE_BUFFER_SIZE);
    	 trans_bb.container.start = trans_bb_buffer;

	 if((bytes = fread(net_bb_buffer, 1, BOOTBLOCK_BUFFER_SIZE, fin))<0) {
	     DBUG_PRINTF(DBUG_LVL_ERROR, "load_scbb: failed to read file\n");
	     return(-2); /* bad file - original bb remains */
	 }

	   /* now check bootblock - will corrupt block and regss data if wrong */
	   if(version_control(net_bb_buffer, bytes, &net_bb, SELECT_NET_BB, net_bb_wspace, WSPACE_BUFFER_SIZE)<0) {
	     DBUG_PRINTF(DBUG_LVL_ERROR, "load_scbb: softloaded bootblock failed version control\n");
    	     memcpy((void *)&net_bb, (void *)&trans_bb, sizeof(REG_BOOTBLOCK));
    	     memcpy(net_bb_buffer, trans_bb_buffer, BOOTBLOCK_BUFFER_SIZE);
    	     memcpy(net_bb_wspace, trans_bb_wspace, WSPACE_BUFFER_SIZE);
    	     net_bb.container.start = net_bb_buffer;
    	     net_bb.container.type = REG_CONTAINER_TYPE_NET;

    	     /* re init original bootblock to rebuild script database & check integrity */
    	     version_control(net_bb_buffer, net_bb.container.size, &net_bb, SELECT_NET_BB, net_bb_wspace, WSPACE_BUFFER_SIZE);
    	     return(-2); /* bad file */
    	   } else {
    	     set_status_bits(SELECT_NET_STATUS, BB_STATUS_INSERTED | BB_STATUS_BB_VALID);
    	   }
	 break;

    case SELECT_SC_BB:
#ifdef INSECURE_SMARTCARD_OPS
    	 /* keep old contents in case of disaster */
    	 memcpy((void *)&trans_bb, (void *)&sc_bb, sizeof(REG_BOOTBLOCK));
    	 memcpy(trans_bb_buffer, sc_bb_buffer, BOOTBLOCK_BUFFER_SIZE);
    	 memcpy(trans_bb_wspace, sc_bb_wspace, WSPACE_BUFFER_SIZE);
    	 trans_bb.container.start = trans_bb_buffer;
    	 trans_bb.container.wspace = trans_bb_wspace;
    	 trans_bb.container.wbytes = WSPACE_BUFFER_SIZE;

	 if((bytes = fread(sc_bb_buffer, 1, BOOTBLOCK_BUFFER_SIZE, fin))<0) return(-2); /* bad file - original bb remains */

	   /* now check bootblock - will corrupt block and regss data if wrong */
	   if(version_control(sc_bb_buffer, bytes, &sc_bb, SELECT_SC_BB, sc_bb_wspace, WSPACE_BUFFER_SIZE)<0) {
    	     memcpy((void *)&sc_bb, (void *)&trans_bb, sizeof(REG_BOOTBLOCK));
    	     memcpy(sc_bb_buffer, trans_bb_buffer, BOOTBLOCK_BUFFER_SIZE);
    	     memcpy(sc_bb_wspace, trans_bb_wspace, WSPACE_BUFFER_SIZE);
    	     sc_bb.container.start = sc_bb_buffer;
    	     sc_bb.container.type = REG_CONTAINER_TYPE_SC;

    	     /* re init original bootblock to rebuild script database & check integrity */
    	     version_control(sc_bb_buffer, sc_bb.container.size, &sc_bb, SELECT_SC_BB, sc_bb_wspace, WSPACE_BUFFER_SIZE);
    	     return(-2); /* bad file */
    	   } else {
    	     set_status_bits(SELECT_SC_STATUS, BB_STATUS_INSERTED | BB_STATUS_BB_VALID);
    	   }


#endif
         break;

  }
  if(fin) fclose(fin);
  status_service_call();
  return(0);
}




int consolidate_nics(INDEX *iptr)
{
  // INDEX new[8];
  INDEX *iptr2;
  unsigned char *buff;
  int n;
  mydci4_diblist *diblist_ptr;

  // char test_buff[20];
  diblist_ptr = diblist_copy;

  buff = (unsigned char *)iptr;

  /* structure read from card has no flags field, so massage data

     bit it does now, so we don't need to bother with this

  sc_bbs = 0;
  while(*buff != 0) {
    memcpy(new[sc_bbs].interface, buff, 4);
    memcpy(new[sc_bbs].path, buff+4, 4);
    new[sc_bbs].flags = 0;
    expand_index_filename(test_buff, new[sc_bbs].path);
    DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: moved bb i/f:%s path:%s\n", new[sc_bbs].interface, test_buff);
    buff += 8;
    sc_bbs++;
  }

  memcpy(iptr, &new, sizeof(new));  write back mangled index

  */

  /* invalidate blocks if no corresponding interface present */
  for(n=0, sc_bbs = 0, iptr2 = iptr; n<MAX_INDEX_SIZE; n++, iptr2++, sc_bbs++) {
    if(iptr2->interface[0] == 0) break; /* end of defined blocks */
    if(find_ddi(iptr2->interface)==NULL) {
      DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: ingoring bootblock %d\n", n);
      iptr2->flags |= INDEX_IGNORE;
    }
    else {
      DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: bootblock %d valid.\n", n);
      iptr2->flags &= ~INDEX_IGNORE;
    }
  }

  /* invalidate interfaces if no s/c block available */

  while(diblist_ptr != NULL) {
    if(find_scbb(diblist_ptr->dib_ptr->dib_name)==NULL) {
      DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: ignoring i/f %s\n", diblist_ptr->dib_ptr->dib_name);
      diblist_ptr->flags |= DIB_FLAG_IGNORE;
      diblist_ptr->flags &= ~DIB_FLAG_SCOK;
    } else {
      DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: valid i/f %s\n", diblist_ptr->dib_ptr->dib_name);
      diblist_ptr->flags |= DIB_FLAG_SCOK;
      diblist_ptr->flags &= ~DIB_FLAG_IGNORE;
    }
    diblist_ptr = diblist_ptr->next;
  }

  for(n=0, iptr2 = iptr; n<sc_bbs; n++, iptr2++) {
    if((iptr2->flags & INDEX_IGNORE) != INDEX_IGNORE) {
      sc_file = iptr2->path;
      DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: selected primary block %d i/f: %s\n", n, iptr2->interface);
      diblist_ptr = find_ddi(iptr2->interface);
      if(diblist_ptr != NULL) {
        diblist_ptr->flags |= DIB_FLAG_PRIMARY;
        if(iptr2->flags & INDEX_CLIENT_UPDATE) {
          DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: setting client update status bit.\n");
          set_status_bits(SELECT_SC_STATUS, BB_STATUS_CLIENT);
        }
        else {
          DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: clearing client update status bit.\n");
          clr_status_bits(SELECT_SC_STATUS, BB_STATUS_CLIENT);
        }
        if(iptr2->flags & INDEX_LOCKED) {
          DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: bootblock file is locked in index.\n");
          set_status_bits(SELECT_SC_STATUS, BB_STATUS_PIN | BB_STATUS_LOCKED);
        } else {
          DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: bootblock file is not locked in index.\n");
          clr_status_bits(SELECT_SC_STATUS, BB_STATUS_PIN | BB_STATUS_LOCKED);
        }
        DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: PRIMARY i/f flag set.\n");
      } else {
        DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: couldn't set PRIMARY flag on i/f!\n");
      }
      return(1);
    }
  }
  DBUG_PRINTF(DBUG_LVL_DEBUG, "consolidate_nics: no primary i/f found - bailing...\n");
  return(-1);
}




INDEX *find_scbb(char *s)
{
  int n;

  for(n=0;n<sc_bbs;n++)
    if(strncmp(sc_index[n].interface, s, 4)==0) return(&sc_index[n]);

  return((INDEX *)NULL);
}

#if 0
int check_sc_version(unsigned int sc_version)
{
    if((sc_version < REGISTRY_MIN_VERSION) || (sc_version > REGISTRY_MAX_VERSION)) return(-1);
    return(0);
}
#endif


int expand_index_filename(char *dst, unsigned char *src)
{
  int n, leaf = 1;
  char m;
  char *tomata = dst;
  unsigned char *banana = src;
  static char conv[] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};

  *dst++ = '/'; /* start filename */

  for(n=0; n<4; n++) {
    m = *src++;
    if(m == 0) break; /* end of src filename */

    *dst++ = conv[(m / 0x10)];
    *dst++ = conv[(m % 0x10)];
    if(leaf && (*(src+1)==0)) {
      *dst++ = '/'; /* penultimate src byte? Add slash before doing leafname */
      leaf = 0;
    }
  }

  *dst = 0;

  DBUG_PRINTF(DBUG_LVL_DIAG, "expand: converted \"%s\" to \"%s\"\n", banana, tomata);

  return(strlen(dst));
}

