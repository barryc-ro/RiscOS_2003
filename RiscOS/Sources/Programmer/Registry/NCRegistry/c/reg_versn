/* registry version control */
#include <stdio.h>
#include "reg_object.h"
#define PROTOTYPES_INTERNAL
#include "reg_versn.h"
#include "s_card.h"
#include "reg_bbv0.h"
#include "reg_bbv1.h"
#include "reg_object.h"
#include "reg_scbb.h"
#include "reg_status.h"
#include "DBUG.h"

#define RELEVANT_STATUS (selector==SELECT_SC_BB?SELECT_SC_STATUS:SELECT_NET_STATUS)
/* selector can be SELECT_SC_BB, SELECT_NET_BB, or 0 if we don't want to bother (eg for parsing a
   softloaded block to determine its suitability prior to it becoming active
*/

int version_control(unsigned char *buff, unsigned int bytes, REG_BOOTBLOCK *bbptr, unsigned int selector, unsigned char *wspace, unsigned int wbytes)
{
    unsigned int major_version;
    unsigned int minor_version;

    DBUG_PRINTF(DBUG_LVL_DIAG, "version_control: entered\n");
    if(selector) DBUG_PRINTF(DBUG_LVL_DIAG, "version_control: checking %s block\n",
                 selector==SELECT_SC_BB?"smartcard":"network");

    major_version = *(int *)buff;
    minor_version = major_version & 0xffff;
    major_version >>= 16;

    DBUG_PRINTF(DBUG_LVL_DIAG, "version_control: bootblock version %d/%d\n", major_version, minor_version);

    /* cast to (int) below to avoid 'odd unsigned comparison with zero' warning.
       Is that odd as in peculiar, or odd as in not even? */

    if((int)major_version < REGISTRY_MAJOR_COMPAT_VERSION) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "version_control: bootblock major version too old\n");
        if(selector) {
            clr_status_bits(RELEVANT_STATUS, BB_STATUS_BB_VALID);
            set_status_bits(RELEVANT_STATUS, BB_STATUS_TOO_OLD);
            status_service_call();
        }
        return(-1);
    }

    if(major_version > REGISTRY_MAJOR_VERSION) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "version_control: bootblock major version too new\n");
        if(selector) {
            clr_status_bits(RELEVANT_STATUS, BB_STATUS_BB_VALID);
            set_status_bits(RELEVANT_STATUS, BB_STATUS_TOO_NEW);
            status_service_call();
        }

        return(-1);
    }

    if(selector) {
        if(selector == SELECT_SC_BB) bbptr->container.type = REG_CONTAINER_TYPE_SC;
        else bbptr->container.type = REG_CONTAINER_TYPE_NET;
    }

    switch(major_version) {
        case REGISTRY_BOOTBLOCK_VERSION_0:
             init_reg_bbv0(bbptr, buff, bytes, wspace, wbytes);
             if(sc_bb.container.post_read((void *)bbptr)<0) {
                 DBUG_PRINTF(DBUG_LVL_ERROR, "version_control: bootblock_0 init failed\n");
		 if(selector) {
		     clr_status_bits(RELEVANT_STATUS, BB_STATUS_BB_VALID);
        	     status_service_call();
        	 }

                 return(-1);
             }
             break;

        case REGISTRY_BOOTBLOCK_VERSION_1:
             init_reg_bbv1(bbptr, buff, bytes, wspace, wbytes);
             if(sc_bb.container.post_read((void *)bbptr)<0) {
                 DBUG_PRINTF(DBUG_LVL_ERROR, "version_control: bootblock_1 init failed\n");
		 if(selector) {
		     clr_status_bits(RELEVANT_STATUS, BB_STATUS_BB_VALID);
        	     status_service_call();
        	 }

                 return(-1);
             }
             break;


        default:
             DBUG_PRINTF(DBUG_LVL_ERROR, "version_control: unrecognized bootblock version\n");
             if(selector) {
                 clr_status_bits(RELEVANT_STATUS, BB_STATUS_BB_VALID);
             	 status_service_call();
             }

             return(-1);
             break;
    }

    if(selector) {
        set_status_bits(RELEVANT_STATUS, BB_STATUS_BB_VALID);
        status_service_call();
    }

    return(1);
}
