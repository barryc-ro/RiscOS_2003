/* c code for Registry SWI calls */

#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "kernel.h"


#include "module.h"
#define PROTOTYPES_INTERNAL   /* declare our header file as local */
#include "reg_swis.h"
#include "reg_tags.h"
#include "reg_object.h"
#include "reg_scbb.h"
#include "reg_status.h"
#include "enum_ddi.h"
#include "machine.h"
#include "reg_spprt.h"
#include "reg_auth.h"
#include "DBUG.H"

#include "scinter.h"


int registry_nullswi(_kernel_swi_regs *r)  /* the "does nothing" swi */
{
    return (0);
}


int registry_enumerate_network_drivers(_kernel_swi_regs *r)
{
  if(enum_dci4_dibs()<0)  r->r[0] = -1;
  else r->r[0] = (int)diblist_copy;
  return(0);
}

int registry_enumerate_smartcard_blocks(_kernel_swi_regs *r)
{
  return(0);
}

/* registry_enquiry():
   Lookup a tag reference in the registry.
   On entry:
      r0 = ptr to tag string (case unimportant)
      r1 = ptr to buffer for returned result
      r2 = size of buffer (or 0 to return size of tag value)
      r3 = SCBB selector  TEST TEST TEST - INSECURE SMARTCARD OPERATION!
   On exit:
      r0 = size of returned data, or error
      r1 = source for data tag (selector)
      r2 = preserved

The requested tag is returned to the buffer if there is sufficient room for it
*/

int registry_enquiry(_kernel_swi_regs *r)
{
   int sc_tag_flags, net_tag_flags;
   int tmp;

   tmp = BB_STATUS_INSERTED | BB_STATUS_SC_VALID | BB_STATUS_BB_VALID;
   if((sc_status & tmp) != tmp) {
       DBUG_PRINTF(DBUG_LVL_ERROR, "registry_enquiry: no smartcard present\n");
       r->r[0] = -5; /* invalid or absent smartcard */
       return(0);
   }

   DBUG_PRINTF(DBUG_LVL_DIAG, "registry_enquiry: checking smartcard bootblock...\n");
   sc_tag_flags = sc_bb.tags.tag_info((void *)&sc_bb, (unsigned char *)r->r[0]);

   if(net_status & BB_STATUS_BB_VALID) {
     DBUG_PRINTF(DBUG_LVL_DIAG, "registry_enquiry: checking network bootblock...\n");
     net_tag_flags = net_bb.tags.tag_info((void *)&net_bb, (unsigned char *)r->r[0]);
   } else {
       net_tag_flags = REG_TAG_INFO_NOSUCH_TAG;
   }

   if((sc_tag_flags & REG_TAG_INFO_TAGTYPE_MASK) == REG_TAG_INFO_NOSUCH_TAG) {
       r->r[0] = -1; /* no such tag */
       return(0);
   }

   /* if tag is 1) marked overrideable in the smartcard bootblock, and
      	     	2) present in the net boot block and
      	     	3) a net bootblock is actually loaded
      then get it from the net bootblock */

   if((net_status & BB_STATUS_BB_VALID) &&
      (sc_tag_flags & REG_TAG_INFO_OVERRIDEABLE) &&
      (net_tag_flags & REG_TAG_INFO_TAGTYPE_MASK)) {

	  DBUG_PRINTF(DBUG_LVL_DIAG, "registry_enquiry: smartcard tag over-ridden by network equivalent\n");

          tmp = net_tag_flags & REG_TAG_INFO_TAGTYPE_MASK;

          switch(tmp) {
              case REG_TAG_INFO_HARD_TAG:
              	   r->r[0] = net_bb.tags.hard.t_read((void *)&net_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1], r->r[2]);
              	   r->r[1] = SELECT_NET_BB;
              	   r->r[3] = net_tag_flags;
              	   return(0);
              	   break;

	      case REG_TAG_INFO_SOFT_TAG:
	      	   r->r[0] = net_bb.tags.soft.t_read((void *)&net_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1], r->r[2]);
              	   r->r[1] = SELECT_NET_BB;
              	   r->r[3] = net_tag_flags;
              	   return(0);
	      	   break;

	      case REG_TAG_INFO_SPECIAL_TAG:
	      	   r->r[0] = net_bb.tags.special.t_read((void *)&net_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1], r->r[2]);
              	   r->r[1] = SELECT_NET_BB;
              	   r->r[3] = net_tag_flags;
              	   return(0);
	      	   break;

	      default:
	      	   /* something untoward has happened - fall back to getting info from the smartcard */
	           break;
	  }
      } /* endif net stuff */

      DBUG_PRINTF(DBUG_LVL_DIAG, "registry_enquiry: fetching tag from smartcard\n");

      tmp  = sc_tag_flags & REG_TAG_INFO_TAGTYPE_MASK;

      switch(tmp) {
              case REG_TAG_INFO_HARD_TAG:
              	   r->r[0] = sc_bb.tags.hard.t_read((void *)&sc_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1], r->r[2]);
              	   r->r[1] = SELECT_SC_BB;
              	   r->r[3] = sc_tag_flags;
              	   return(0);
              	   break;

	      case REG_TAG_INFO_SOFT_TAG:
	      	   r->r[0] = sc_bb.tags.soft.t_read((void *)&sc_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1], r->r[2]);
              	   r->r[1] = SELECT_SC_BB;
              	   r->r[3] = sc_tag_flags;
              	   return(0);
	      	   break;

	      case REG_TAG_INFO_SPECIAL_TAG:
	      	   r->r[0] = sc_bb.tags.special.t_read((void *)&sc_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1], r->r[2]);
              	   r->r[1] = SELECT_SC_BB;
              	   r->r[3] = sc_tag_flags;
              	   return(0);
	      	   break;

	      default:
	      	   r->r[0] = -3; /* no tag info available */
	      	   return(0);
	           break;
	  }

   return(0);

}

/* registry_load_scbb():
   Load a smartcard boot block into the registry - intended for network
   boot block area only, but sc area allowed for testing - INSECURE SMARTCARD OPERATION!
   On entry:
      r0 = fully qualified filename of SCBB
      r1 = boot block selector

   On exit:
      r0 = 0 for success, or -N for error
*/

int registry_load_scbb(_kernel_swi_regs *r)
{

  switch(r->r[1]) {

  case SELECT_NET_BB:
    r->r[0] = load_scbb(r->r[1], (char *)r->r[0]);
    break;

  case SELECT_SC_BB:
    r->r[0] = load_scbb(r->r[1], (char *)r->r[0]);
    break;

  default:
    r->r[0] = -1;
    return(0);
  }

   return(0);
}

/* registry_status(): read registry status

   On entry:
   r0 = non zero to clear the status delta registers

   On exit:
   r0 = smartcard status
   r1 = network status
   r2 = smartcard delta
   r3 = smartcard delta
*/
int registry_status(_kernel_swi_regs *r)
{

  r->r[0] = sc_status;
  r->r[1] = net_status;
  r->r[2] = sc_delta_swi;
  r->r[3] = net_delta_swi;

  sc_delta_swi = net_delta_swi = 0;
  status_swi_count++;

  return(0);
}

/* registry_write():
   Write a tag reference in the registry, write thru to smartcard
   On entry:
      r0 = ptr to tag string (case unimportant)
      r1 = ptr to buffer containing new value
      r2 = size of new value
      r3 = tag flags

   On exit:
      r0 = 0 for success, or error
      r1 = source for data tag (selector)
      r2 = preserved

The requested tag is returned to the buffer if there is sufficient room for it
*/

int registry_write(_kernel_swi_regs *r)
{
  int tmp, tmp2;
  int sc_tag_flags;

  unsigned char writeable_tag[] = "WRITE_ENABLE";

  tmp = BB_STATUS_INSERTED | BB_STATUS_SC_VALID | BB_STATUS_BB_VALID;

  if((sc_status & tmp) != tmp) {
    r->r[0] = -5; /* invalid smartcard */
    return(0);
  }

  /*-------------------------WRITE-THRU------------------------------*/

  if((r->r[0] == 0) && (r->r[1] == 0) && (r->r[2] == 0)) { /* WRITE THRU TO SMARTCARD */

    if(!scbb_changed) {
      r->r[0] = -6; /* nothing has changed */
      return(0);
    }

    if(registry_state != State_CardInserted) {
      r->r[0] = -7; /* registry busy */
      return(0);
    }

    registry_trans = Trans_WriteCard; /* fake a transition */
    setcallback(); /* fire up the state machine */
    r->r[0] = 0; /* success */
    return(0);
  }

  /*---------------------END-WRITE-THRU------------------------------*/

  if((r->r[1] == NULL) || (r->r[2] == 0)) return(-12); /* bad tag value */

  (sc_bb.tags.hard.t_read((void *)&sc_bb, writeable_tag, (unsigned char *)&tmp2, 4));
  if(tmp2 ==0) {
    DBUG_PRINTF(DBUG_LVL_DIAG, "registry_write: bootblock marked as not writeable\n");
    r->r[0] = -4; /* bootblock not writeable */
    return(0);
  }


  sc_tag_flags = sc_bb.tags.tag_info((void *)&sc_bb, (unsigned char *)r->r[0]);

  if((sc_tag_flags & REG_TAG_INFO_TAGTYPE_MASK) == REG_TAG_INFO_NOSUCH_TAG) {
      r->r[0] = -1; /* no such tag */
      return(0);
  }

  if((sc_tag_flags & REG_TAG_INFO_UPDATEABLE)==0) {
      r->r[0] = -2; /* tag not updateable */
      return(0);
  }

  tmp  = sc_tag_flags & REG_TAG_INFO_TAGTYPE_MASK;

  switch(tmp) {
          case REG_TAG_INFO_HARD_TAG:
          	   r->r[0] = sc_bb.tags.hard.t_write((void *)&sc_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1], r->r[2]);
          	   r->r[1] = SELECT_SC_BB;
          	   r->r[3] = sc_tag_flags;
          	   scbb_changed = 1;
          	   return(0);
          	   break;

   case REG_TAG_INFO_SOFT_TAG:
   	   r->r[0] = sc_bb.tags.soft.t_write((void *)&sc_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1], r->r[2]);
          	   r->r[1] = SELECT_SC_BB;
          	   r->r[3] = sc_tag_flags;
          	   scbb_changed = 1;
          	   return(0);
   	   break;

   case REG_TAG_INFO_SPECIAL_TAG:
   	   r->r[0] = sc_bb.tags.special.t_write((void *)&sc_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1], r->r[2]);
          	   r->r[1] = SELECT_SC_BB;
          	   r->r[3] = sc_tag_flags;
          	   scbb_changed = 1;
          	   return(0);
   	   break;

   default:
   	   r->r[0] = -1; /* no such tag  */
   	   return(0);
        break;
  }



  return(0);

}

/* registry_authenticate() - pass PIN to smartcard subsystem

   On entry:

    r0 -> max. 8 byte authorization key
    r1 = no. bytes in key up to MAX_AUTHBLOCK_KEY (8 currently)

  On exit:

    r0 = no. bytes written to authentication key

*/
int registry_authenticate(_kernel_swi_regs *r)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "NCRegistry: Authentication block received.\n");
  if(chv1_required) chv1_required = 0; /* clear first-time PIN requirement */
  r->r[0] = set_authblock((char *)(r->r[0]), r->r[1]);
  if(registry_state == State_AuthFail) {
    registry_trans = Trans_AuthRetry;
    setcallback();
  }
  return(0);
}

/* registry_supportinit() - allow a registry support module to register itself

   On entry:

      r0 = registry support ID
      r1 = registry support module swi base
      r2 = ptr. to registry support title (static)

   On exit:

      r0 = registry support handle, or -1 for failure

*/
int registry_supportinit(_kernel_swi_regs *r)
{
  return(add_support((unsigned int)r->r[0],
   	            (unsigned int)r->r[1],
   	            (char *)r->r[2]));
}

/* registry_supportexit() - allow a registry support module to deregister itself

   On entry:

      r0 = registry support ID
      r1 = registry support module swi base

   On exit:

      r0 = registry support handle, or -1 for failure

*/
int registry_supportexit(_kernel_swi_regs *r)
{
  return(remove_support((unsigned int)r->r[0],
   	            (unsigned int)r->r[1]));

}

/* registry_changechv() - change the Card Holder Verification key on the smartcard

   On entry:

     r0 = CHV selector, 1 for CHV1, 2 for CHV2 (only CHV1 ops. supported atm)
     r1 -> buffer containing new CHV1
     r2 = num. bytes in new CHV1

   On exit:

     r0 = 0 - success
         -1 - registry busy
*/
int registry_changechv(_kernel_swi_regs *r)
{
  if(registry_state != State_CardInserted) {
    r->r[0] = -1;   /* Registry busy */
    return(0);
  }

  set_authblockNU((char *)(r->r[1]), r->r[2]);
  registry_trans = Trans_ChangeCHV;
  setcallback();
  r->r[0] = 0;
  return(0);
}

/* registry_proxy - allows an external client to read smartcard files
   without knowing the CHV1

   On Entry:

      r0 = as SCInterface_Read
      r1 = as SCInterface_Read
      r2 = as SCInterface_Read
      r3 = as SCInterface_Read
      r4 = as SCInterface_Read
      r5 = NULL
      r6 = 0

   On exit:

      as SCInterface_Read
*/
int registry_proxy(_kernel_swi_regs *r)
{
  r->r[5] = (int)&authblock.authblock_key;
  r->r[6] = (int)authblock.authblock_bytes;
  _kernel_swi(XOS_Bit | SCInterface_Read, r, r);
  return(0);
}


/* registry_delete():
   Delete a tag reference in the registry, write thru to smartcard
   On entry:
      r0 = ptr to tag string (case unimportant)

   On exit:
      r0 = 0 for success, or error
      r1 = source for data tag (selector)
      r2 = preserved

The requested tag is deleted if it exists and is deletable
*/

int registry_delete(_kernel_swi_regs *r)
{
  int tmp, tmp2;
  int sc_tag_flags;

  unsigned char writeable_tag[] = "WRITE_ENABLE";

  tmp = BB_STATUS_INSERTED | BB_STATUS_SC_VALID | BB_STATUS_BB_VALID;

  if((sc_status & tmp) != tmp) {
    r->r[0] = -5; /* invalid smartcard */
    return(0);
  }

  /*-------------------------WRITE-THRU------------------------------*/

  if((r->r[0] == 0) && (r->r[1] == 0) && (r->r[2] == 0)) { /* WRITE THRU TO SMARTCARD */

    if(!scbb_changed) {
      r->r[0] = -6; /* nothing has changed */
      return(0);
    }

    if(registry_state != State_CardInserted) {
      r->r[0] = -7; /* registry busy */
      return(0);
    }

    registry_trans = Trans_WriteCard; /* fake a transition */
    setcallback(); /* fire up the state machine */
    r->r[0] = 0; /* success */
    return(0);
  }

  /*---------------------END-WRITE-THRU------------------------------*/

  (sc_bb.tags.hard.t_read((void *)&sc_bb, writeable_tag, (unsigned char *)&tmp2, 4));
  if(tmp2 ==0) {
    DBUG_PRINTF(DBUG_LVL_DIAG, "registry_write: bootblock marked as not writeable\n");
    r->r[0] = -4; /* bootblock not writeable */
    return(0);
  }


  sc_tag_flags = sc_bb.tags.tag_info((void *)&sc_bb, (unsigned char *)r->r[0]);

  if((sc_tag_flags & REG_TAG_INFO_TAGTYPE_MASK) == REG_TAG_INFO_NOSUCH_TAG) {
      r->r[0] = -1; /* no such tag */
      return(0);
  }

  if((sc_tag_flags & REG_TAG_INFO_UPDATEABLE)==0) {
      r->r[0] = -2; /* tag not updateable */
      return(0);
  }

  tmp  = sc_tag_flags & REG_TAG_INFO_TAGTYPE_MASK;

  switch(tmp) {
          case REG_TAG_INFO_HARD_TAG:
          	   r->r[0] = sc_bb.tags.hard.t_delete((void *)&sc_bb, (unsigned char *)r->r[0]);
          	   r->r[1] = SELECT_SC_BB;
          	   r->r[3] = sc_tag_flags;
          	   scbb_changed = 1;
          	   return(0);
          	   break;

   case REG_TAG_INFO_SOFT_TAG:
   	   r->r[0] = sc_bb.tags.soft.t_delete((void *)&sc_bb, (unsigned char *)r->r[0]);
          	   r->r[1] = SELECT_SC_BB;
          	   r->r[3] = sc_tag_flags;
          	   scbb_changed = 1;
          	   return(0);
   	   break;

   case REG_TAG_INFO_SPECIAL_TAG:
   	   r->r[0] = sc_bb.tags.special.t_delete((void *)&sc_bb, (unsigned char *)r->r[0]);
          	   r->r[1] = SELECT_SC_BB;
          	   r->r[3] = sc_tag_flags;
          	   scbb_changed = 1;
          	   return(0);
   	   break;

   default:
   	   r->r[0] = -1; /* no such tag  */
   	   return(0);
        break;
  }



  return(0);

}


/* registry_rename():
   Rename a tag reference in the registry, write thru to smartcard
   On entry:
      r0 = ptr to current tag string (case unimportant)
      r1 = ptr to new tag string (case unimportant)

   On exit:
      r0 = 0 for success, or error
      r1 = source for data tag (selector)
      r2 = preserved

The requested tag is renamed if it exists and is updateable
*/

int registry_rename(_kernel_swi_regs *r)
{
  int tmp, tmp2;
  int sc_tag_flags;

  unsigned char writeable_tag[] = "WRITE_ENABLE";

  if(r->r[1] == NULL) return(-12); /* bad tag value */

  tmp = BB_STATUS_INSERTED | BB_STATUS_SC_VALID | BB_STATUS_BB_VALID;

  if((sc_status & tmp) != tmp) {
    r->r[0] = -5; /* invalid smartcard */
    return(0);
  }

  /*-------------------------WRITE-THRU------------------------------*/

  if((r->r[0] == 0) && (r->r[1] == 0) && (r->r[2] == 0)) { /* WRITE THRU TO SMARTCARD */

    if(!scbb_changed) {
      r->r[0] = -6; /* nothing has changed */
      return(0);
    }

    if(registry_state != State_CardInserted) {
      r->r[0] = -7; /* registry busy */
      return(0);
    }

    registry_trans = Trans_WriteCard; /* fake a transition */
    setcallback(); /* fire up the state machine */
    r->r[0] = 0; /* success */
    return(0);
  }

  /*---------------------END-WRITE-THRU------------------------------*/

  (sc_bb.tags.hard.t_read((void *)&sc_bb, writeable_tag, (unsigned char *)&tmp2, 4));
  if(tmp2 ==0) {
    DBUG_PRINTF(DBUG_LVL_DIAG, "registry_write: bootblock marked as not writeable\n");
    r->r[0] = -4; /* bootblock not writeable */
    return(0);
  }


  sc_tag_flags = sc_bb.tags.tag_info((void *)&sc_bb, (unsigned char *)r->r[0]);

  if((sc_tag_flags & REG_TAG_INFO_TAGTYPE_MASK) == REG_TAG_INFO_NOSUCH_TAG) {
      r->r[0] = -1; /* no such tag */
      return(0);
  }

  if((sc_tag_flags & REG_TAG_INFO_UPDATEABLE)==0) {
      r->r[0] = -2; /* tag not updateable */
      return(0);
  }

  tmp  = sc_tag_flags & REG_TAG_INFO_TAGTYPE_MASK;

  switch(tmp) {
          case REG_TAG_INFO_HARD_TAG:
          	   r->r[0] = sc_bb.tags.hard.t_rename((void *)&sc_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1]);
          	   r->r[1] = SELECT_SC_BB;
          	   r->r[3] = sc_tag_flags;
          	   scbb_changed = 1;
          	   return(0);
          	   break;

   case REG_TAG_INFO_SOFT_TAG:
   	   r->r[0] = sc_bb.tags.soft.t_rename((void *)&sc_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1]);
          	   r->r[1] = SELECT_SC_BB;
          	   r->r[3] = sc_tag_flags;
          	   scbb_changed = 1;
          	   return(0);
   	   break;

   case REG_TAG_INFO_SPECIAL_TAG:
   	   r->r[0] = sc_bb.tags.special.t_rename((void *)&sc_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1]);
          	   r->r[1] = SELECT_SC_BB;
          	   r->r[3] = sc_tag_flags;
          	   scbb_changed = 1;
          	   return(0);
   	   break;

   default:
   	   r->r[0] = -1; /* no such tag  */
   	   return(0);
        break;
  }



  return(0);

}


/* registry_create():
   Create a soft tag reference in the registry, write thru to smartcard
   If the entry already exists, it will be updated

   On entry:
      r0 = ptr to tag string
      r1 = ptr to new tag value
      r2 = size of tag value

   On exit:
      r0 = 0 for success, or error
      r1 = source for data tag (selector)
      r2 = preserved

The requested tag is created or updated
*/

int registry_create(_kernel_swi_regs *r)
{
  int tmp, tmp2;
  int sc_tag_flags;

  unsigned char writeable_tag[] = "WRITE_ENABLE";

  tmp = BB_STATUS_INSERTED | BB_STATUS_SC_VALID | BB_STATUS_BB_VALID;

  if((sc_status & tmp) != tmp) {
    r->r[0] = -5; /* invalid smartcard */
    return(0);
  }

  if((r->r[0] == NULL) || (r->r[1] == NULL) || (r->r[2] == 0)) return(-12); /* bad tag value */
  /*-------------------------WRITE-THRU------------------------------*/

  if((r->r[0] == 0) && (r->r[1] == 0) && (r->r[2] == 0)) { /* WRITE THRU TO SMARTCARD */

    if(!scbb_changed) {
      r->r[0] = -6; /* nothing has changed */
      return(0);
    }

    if(registry_state != State_CardInserted) {
      r->r[0] = -7; /* registry busy */
      return(0);
    }

    registry_trans = Trans_WriteCard; /* fake a transition */
    setcallback(); /* fire up the state machine */
    r->r[0] = 0; /* success */
    return(0);
  }

  /*---------------------END-WRITE-THRU------------------------------*/

  (sc_bb.tags.hard.t_read((void *)&sc_bb, writeable_tag, (unsigned char *)&tmp2, 4));
  if(tmp2 ==0) {
    DBUG_PRINTF(DBUG_LVL_DIAG, "registry_write: bootblock marked as not writeable\n");
    r->r[0] = -4; /* bootblock not writeable */
    return(0);
  }


  sc_tag_flags = sc_bb.tags.tag_info((void *)&sc_bb, (unsigned char *)r->r[0]);

  r->r[0] = sc_bb.tags.soft.t_write((void *)&sc_bb, (unsigned char *)r->r[0], (unsigned char *)r->r[1], r->r[2]);
  r->r[1] = SELECT_SC_BB;
  r->r[3] = sc_tag_flags;
  scbb_changed = 1;

  return(0);

}

int registry_pin_info(_kernel_swi_regs *r)
{
    r->r[0] = chv1_bit_set;
    r->r[1] = chv1_tries_left;
    return(0);
}




