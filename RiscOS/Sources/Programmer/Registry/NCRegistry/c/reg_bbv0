/* reg_bbv0.h

   registry bootblock major version 0

*/

#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "s_card.h"
#include "reg_object.h"
#include "reg_scbb.h"
#include "module.h"
#include "reg_status.h"
#include "reg_spprt.h"
#define PROTOTYPES_INTERNAL
#include "reg_bbv0.h"
#include "reg_tags.h"
#include "machine.h"
#include "reg_auth.h"
#include "DBUG.h"
#include "kprintf.h"

/* ******************************************************************************** */
/* initialise a bootblock structure to bootblock major version 0 */
int init_reg_bbv0(REG_BOOTBLOCK *bootblock, unsigned char *buff, unsigned int bytes, unsigned char *wspace, unsigned int wbytes)
{
    reg_bbv0 = bootblock;

    reg_bbv0->version.major = (*(int *)buff)>>16;
    reg_bbv0->version.minor = (*(int *)buff) & 0xffff;

    reg_bbv0->container.start = buff;
    reg_bbv0->container.size = bytes;
    reg_bbv0->container.max_size = 440;
    reg_bbv0->container.cksum = 0;
    reg_bbv0->container.wspace = wspace;
    reg_bbv0->container.wbytes = wbytes;

    reg_bbv0->container.post_read = reg_bbv0_post_read;
    reg_bbv0->container.pre_write = reg_bbv0_pre_write;

    reg_bbv0->tags.tag_info      = reg_bbv0_tag_info;
    reg_bbv0->tags.hard.t_enum   = reg_bbv0_enum_htags;
    reg_bbv0->tags.hard.t_read   = reg_bbv0_read_htags;
    reg_bbv0->tags.hard.t_write  = reg_bbv0_write_htags;
    reg_bbv0->tags.hard.t_rename = reg_bbv0_rename_htags;
    reg_bbv0->tags.hard.t_delete = reg_bbv0_delete_htags;

    reg_bbv0->tags.soft.t_enum   = reg_bbv0_enum_sftags;
    reg_bbv0->tags.soft.t_read   = reg_bbv0_read_sftags;
    reg_bbv0->tags.soft.t_write  = reg_bbv0_write_sftags;
    reg_bbv0->tags.soft.t_rename = reg_bbv0_rename_sftags;
    reg_bbv0->tags.soft.t_delete = reg_bbv0_delete_sftags;

    reg_bbv0->tags.special.t_enum   = reg_bbv0_enum_stags;
    reg_bbv0->tags.special.t_read   = reg_bbv0_read_stags;
    reg_bbv0->tags.special.t_write  = reg_bbv0_write_stags;
    reg_bbv0->tags.special.t_rename = reg_bbv0_rename_stags;
    reg_bbv0->tags.special.t_delete = reg_bbv0_delete_stags;
    return(0);
}

/* ******************************************************************************** */
/* routines to tidy up after loading and before saving */
int reg_bbv0_post_read(void *bb_base)
{
    _kernel_swi_regs r;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_post_read: entered\n");
    /* we're only interested in smartcard bootblocks, not network ones */
    if(((REG_BOOTBLOCK *)bb_base)->container.type == REG_CONTAINER_TYPE_SC) {
      r.r[0] = (int)(((REG_BOOTBLOCK *)bb_base)->container.start);
      r.r[1] = SELECT_SC_BB;
      r.r[2] = fresco_data_present ? (int)fresco_buffer : NULL;
      r.r[3] = fresco_data_present ? fresco_stat_size : 0;
      support_notify(&r, &r);
      /* _kernel_swi(XOS_Bit | 0x4d3c0, &r, &r);  Registry support init */
      if(r.r[0] > 0) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "succeeded.\n");
        set_status_bits(SELECT_SC_STATUS, BB_STATUS_BB_VALID);
        status_service_call();
        return(0);
      } else {
        DBUG_PRINTF(DBUG_LVL_DIAG, "failed.\n");
        clr_status_bits(SELECT_SC_STATUS, BB_STATUS_BB_VALID);
        status_service_call();
        return(-1);
      }
    }

    return(0);
}

int reg_bbv0_pre_write(void *bb_base)
{
    return(0);
}
/* ******************************************************************************** */
/* routine to provide info on tags within this block */
int reg_bbv0_tag_info(void *bb_base, unsigned char *tag)
{
    REG_TAGS *rt;
    int tmp;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_tag_info: entered -> checking %s\n", tag);

    if((rt = locate_tag((char *)tag))==NULL) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_tag_info: requested tag not found\n");
        return(REG_TAG_INFO_NOSUCH_TAG);
    }

    /* version 0 bootblocks don't have soft tags */
    if(rt->flags & REG_TAGS_SPECIAL) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_tag_info: found as special tag\n");
        tmp = REG_TAG_INFO_SPECIAL_TAG;
    }
    else {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_tag_info: found as hard tag\n");
        tmp = REG_TAG_INFO_HARD_TAG;
    }

    if(rt->flags & REG_TAGS_OVERRIDE) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_tag_info: tag overrideable\n");
        tmp |= REG_TAG_INFO_OVERRIDEABLE;
    }

    if(rt->flags & REG_TAGS_UPDATE) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_tag_info: tag updateable\n");
        tmp |= REG_TAG_INFO_UPDATEABLE;
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_tag_info: exiting\n");
    return(tmp);
}



/* ******************************************************************************** */
/* routines to deal with hard tags */

int reg_bbv0_enum_htags(void *bb_base)
{
  show_htags(bb_base);
  return(0);
}

int reg_bbv0_read_htags(void *bb_base, unsigned char *tag, unsigned char *buffer, unsigned int bytes)
{
    REG_TAGS *rt;
    int tmp;
    unsigned char *src;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_read_htags: entered -> fetching %s\n", tag);

    if((rt = locate_tag((char *)tag))==NULL) return(-1); /* no such tag */

    if((buffer == NULL) || (bytes == 0)) { /* return size info only */
      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_read_htags: returning size only\n");
      return(rt->length);
    }
    /* otherwise, write the data to the buffer too */

    if(rt->length > bytes) return(-4); /* insufficient buffer space */

    if((rt->length == 4) && ((rt->mask != 0) || (rt->shift != 0))) { /* varibits */
      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_read_htags: decoding varibits field mask: 0x%x shift: 0x%x\n", rt->mask, rt->shift);
      tmp = reduce_tag((SC_BOOT_BLOCK *)(((REG_BOOTBLOCK *)bb_base)->container.start), rt);
      *(int *)buffer = tmp;
    } else {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_read_htags: copied %d bytes from bootblock offset: %d\n", rt->length, rt->offset);
        src = (unsigned char *)(((REG_BOOTBLOCK *)bb_base)->container.start) + rt->offset;
        memcpy((void *)buffer, (void *)src, rt->length);
    }
    return(rt->length);
}

int reg_bbv0_write_htags(void *bb_base, unsigned char *tag, unsigned char *buffer, unsigned int bytes)
{
    REG_TAGS *rt;
    int tmp, tmp2;
    char *src;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_write_htags: entered\n");

    if((rt = locate_tag((char *)tag))==NULL) return(-1); /* no such tag */
    if(bytes > rt->length) return(-3); /* tag value too big */

    src = (char *)(((REG_BOOTBLOCK *)bb_base)->container.start) + rt->offset;

    if(rt->mask || rt->shift) { /* varibits */
      tmp = *(int *)buffer;
      tmp <<= rt->shift;
      tmp &= rt->mask;

      tmp2 = *src;

      if(tmp) tmp2 |= tmp; /* set bit */
      else tmp2 &= ~tmp; /* clr bit */

      memcpy((void *)src, (void *)&tmp2, 4);
    } else {
        memcpy((void *)src, (void *)buffer, bytes);
    }
    return(0);
}

int reg_bbv0_rename_htags(void *bb_base, unsigned char *tag, unsigned char *new_tag)
{
    /* can't delete hard tags in version 0 */
    return(-11);
}


int reg_bbv0_delete_htags(void *bb_base, unsigned char *tag)
{
    /* can't delete hard tags in version 0 */
    return(-11);
}

/* ******************************************************************************** */
/* routines to deal with special tags */

int reg_bbv0_enum_stags(void *bb_base)
{
    show_stags(bb_base);
    return(0);
}

int reg_bbv0_read_stags(void *bb_base, unsigned char *tag, unsigned char *buffer, unsigned int bytes)
{
    REG_TAGS *rt;
    int s_swi;
    _kernel_swi_regs tr;
    int target;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_read_stags: entered -> reading %s\n", tag);

    if((rt = locate_tag((char *)tag)) == NULL) return(-1); /* no such tag */
    if(!(rt->flags & REG_TAGS_SPECIAL)) return(-3); /* no tag info available */
    s_swi = find_support_swibase(rt->shift);
    if(s_swi < 0) return(-2); /* no support module for requested tag */

    s_swi += REGISTRY_SUPPORT_READSWI;
    s_swi |= XOS_Bit;

    tr.r[0] = rt->mask;
    tr.r[1] = (int)buffer;
    tr.r[2] = (int)bytes;

    target = ((REG_BOOTBLOCK *)bb_base)->container.type;
    if( target == REG_CONTAINER_TYPE_SC) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_read_stags: calling support SWI on smartcard bootblock (%d)\n", target);
        tr.r[3] = SELECT_SC_BB;
        tr.r[4] = sc_status;
        tr.r[5] = (int)sc_bb_buffer;
    } else {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_read_stags: calling support SWI on network bootblock (%d)\n", target);
        tr.r[3] = SELECT_NET_BB;
        tr.r[4] = net_status;
        tr.r[5] = (int)net_bb_buffer;
    }

    _kernel_swi(s_swi, &tr, &tr);
    return(tr.r[0]);
}

int reg_bbv0_write_stags(void *bb_base, unsigned char *tag, unsigned char *buffer, unsigned int bytes)
{
    REG_TAGS *rt;
    int s_swi;
    _kernel_swi_regs tr;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv0_write_stags: entered\n");

    if((rt = locate_tag((char *)tag)) == NULL) return(-1); /* no such tag */
    if(!(rt->flags & REG_TAGS_SPECIAL)) return(-9); /* no tag info available */
    if(!(rt->flags & REG_TAGS_UPDATE)) return(-2); /* tag not updateable */

    s_swi = find_support_swibase(rt->shift);
    if(s_swi < 0) return(-8); /* no support module for requested tag */

    s_swi += REGISTRY_SUPPORT_WRITESWI;
    s_swi |= XOS_Bit;

    tr.r[0] = rt->mask;
    tr.r[1] = (int)buffer;
    tr.r[2] = (int)bytes;
    tr.r[3] = sc_status;
    tr.r[4] = (int)sc_bb_buffer;
    tr.r[5] = (int)authblock.authblock_key;
    tr.r[6] = authblock.authblock_bytes;

    _kernel_swi(s_swi, &tr, &tr);
    return(tr.r[0]);
}

int reg_bbv0_delete_stags(void *bb_base, unsigned char *tag)
{
    /* can't delete version 0 special tags */
    return(-11);
}

int reg_bbv0_rename_stags(void *bb_base, unsigned char *tag, unsigned char *new_tag)
{
    /* can't delete version 0 special tags */
    return(-11);
}


/* ******************************************************************************** */
/* routines to deal with soft tags */

/* BOOTBLOCK FORMAT 0 DOESN'T SUPPORT SOFT TAGS */
int reg_bbv0_enum_sftags(void *bb_base)
{
    /* can't delete version 0 special tags */
    return(-11);
}

int reg_bbv0_read_sftags(void *bb_base, unsigned char *a, unsigned char *b, unsigned int c)
{
    /* can't delete version 0 special tags */
    return(-11); /* not supported */
}
int reg_bbv0_write_sftags(void *bb_base, unsigned char *a, unsigned char *b, unsigned int c)
{
    /* can't delete version 0 special tags */
    return(-11);
}

int reg_bbv0_rename_sftags(void *bb_base, unsigned char *tag, unsigned char *new_tag)
{
    /* can't delete version 0 special tags */
    return(-11);
}

int reg_bbv0_delete_sftags(void *bb_base, unsigned char *tag)
{
    /* can't delete version 0 special tags */
    return(-11);
}

