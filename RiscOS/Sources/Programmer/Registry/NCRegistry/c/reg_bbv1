/* reg_bbv1.c

   registry bootblock major version 1 support code

*/

#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "s_card.h"
#include "reg_object.h"
#include "reg_scbb.h"
#include "module.h"
#include "reg_status.h"
#include "reg_spprt.h"
#define PROTOTYPES_INTERNAL
#include "reg_bbv1.h"
#include "reg_tags.h"
#include "machine.h"
#include "reg_auth.h"
#include "dynalloc.h"
#include "DBUG.h"
#include "kprintf.h"

/* ******************************************************************************** */
/* initialise a bootblock structure to bootblock major version 1 */
int init_reg_bbv1(REG_BOOTBLOCK *bootblock, unsigned char *buff, unsigned int bytes, unsigned char *wspace, unsigned int wbytes)
{
    SOFTTAG_LIST *stl;
    reg_bbv1 = bootblock;

    reg_bbv1->version.major = (*(int *)buff)>>16;
    reg_bbv1->version.minor = (*(int *)buff) & 0xffff;

    reg_bbv1->container.start = buff;
    reg_bbv1->container.size = 0;
    reg_bbv1->container.max_size = bytes;
    reg_bbv1->container.cksum = 0;
    reg_bbv1->container.wspace = wspace;
    reg_bbv1->container.wbytes = wbytes;

    /* set up workspace for recording softtag stuff */
    memset(wspace, 0, wbytes);
    stl = (SOFTTAG_LIST *)wspace;
    stl->head = (unsigned char **)(wspace + sizeof(SOFTTAG_LIST));
    stl->next = stl->head;
    stl->tail = (unsigned char **)(wspace + wbytes - sizeof(SOFTTAG_LIST));

    DBUG_PRINTF(DBUG_LVL_DIAG, "init_reg_bbv1: wspace: 0x%x stl->head: 0x%x next: 0x%x tail: 0x%x\n",
    			       wspace, stl->head, stl->next, stl->tail);

    reg_bbv1->container.post_read = reg_bbv1_post_read;
    reg_bbv1->container.pre_write = reg_bbv1_pre_write;

    reg_bbv1->tags.tag_info      = reg_bbv1_tag_info;

    reg_bbv1->tags.hard.t_enum   = reg_bbv1_enum_htags;
    reg_bbv1->tags.hard.t_read   = reg_bbv1_read_htags;
    reg_bbv1->tags.hard.t_write  = reg_bbv1_write_htags;
    reg_bbv1->tags.hard.t_rename = NULL;
    reg_bbv1->tags.hard.t_delete = reg_bbv1_delete_htags;

    reg_bbv1->tags.soft.t_enum   = reg_bbv1_enum_stags;
    reg_bbv1->tags.soft.t_read   = reg_bbv1_read_stags;
    reg_bbv1->tags.soft.t_write  = reg_bbv1_write_stags;
    reg_bbv1->tags.soft.t_rename = reg_bbv1_rename_stags;
    reg_bbv1->tags.soft.t_delete = reg_bbv1_delete_stags;

    reg_bbv1->tags.special.t_enum   = reg_bbv1_enum_sptags;
    reg_bbv1->tags.special.t_read   = reg_bbv1_read_sptags;
    reg_bbv1->tags.special.t_write  = reg_bbv1_write_sptags;
    reg_bbv1->tags.special.t_rename = NULL;
    reg_bbv1->tags.special.t_delete = reg_bbv1_delete_sptags;
    return(0);
}

/* ******************************************************************************** */
/* routines to tidy up after loading and before saving */
int reg_bbv1_post_read(void *bb_base)
{
    unsigned char *bb_ptr;
    unsigned int bb_tag_id, bb_tag_len_lo, bb_tag_len_hi;
    unsigned int cksum;
    int bytes;
    unsigned int bb_cksum;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_post_read: entered\n");


    cksum = 0;
    bb_ptr = (unsigned char *)(((REG_BOOTBLOCK *)bb_base)->container.start);

    cksum =  (unsigned int)*bb_ptr++; /* add SCF_ID version field contents into checksum */
    cksum += (unsigned int)*bb_ptr++;
    cksum += (unsigned int)*bb_ptr++;
    cksum += (unsigned int)*bb_ptr++;

    bytes = 4;

    while(bytes < BOOTBLOCK_BUFFER_SIZE) {
        bb_tag_id = (unsigned int)*bb_ptr++;
        bb_tag_len_lo = (unsigned int)*bb_ptr++;
        bb_tag_len_hi = (unsigned int)*bb_ptr++;


        cksum += (bb_tag_id + bb_tag_len_lo + bb_tag_len_hi);

        bb_tag_len_lo |= (bb_tag_len_hi<<8);

        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_post_read: read tag id: %d length: %d\n", bb_tag_id, bb_tag_len_lo);

        if(!is_bbv1_htag(bb_tag_id)) {
            DBUG_PRINTF(DBUG_LVL_ERROR, "reg_bbv1_post_read: bad tag id %d\n", bb_tag_id);
            goto v1_post_read_error;
        }

        if(bb_tag_id == 0xfe) { /* soft tag */
           add_soft_mapping(bb_ptr-3, (SOFTTAG_LIST *)(((REG_BOOTBLOCK *)bb_base)->container.wspace)); /* soft tag ptrs. point to tag id */
        }

        if(bb_tag_id == 0xff) { /* checksum */
           bb_cksum = read_unaligned_int(bb_ptr);

           if(bb_cksum != cksum) {
               DBUG_PRINTF(DBUG_LVL_ERROR, "reg_bbv1_post_read: checksum error (%d (calc)<> %d(stored))\n", cksum, bb_cksum);
               goto v1_post_read_error;
           } else {
               DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_post_read: bootblock checksum OK\n");
               bytes += 7;
               ((REG_BOOTBLOCK *)bb_base)->container.cksum = cksum;
               ((REG_BOOTBLOCK *)bb_base)->container.size = bytes;
               break;
           }
        }

        bytes += (bb_tag_len_lo + 3); /* account for bytes used */


        while(bb_tag_len_lo--) {
            cksum += (unsigned int)*bb_ptr++;
        }


    } /* endwhile */

    if(bytes > ((REG_BOOTBLOCK *)bb_base)->container.max_size) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "reg_bbv1_post_read: bootblock exceeds maximum buffer size\n");
        goto v1_post_read_error;
    }

    /* Success! */
    if(((REG_BOOTBLOCK *)bb_base)->container.type == REG_CONTAINER_TYPE_SC) {
        set_status_bits(SELECT_SC_STATUS, BB_STATUS_BB_VALID);
        status_service_call();
    }
    else if(((REG_BOOTBLOCK *)bb_base)->container.type == REG_CONTAINER_TYPE_NET) {
        set_status_bits(SELECT_NET_STATUS, BB_STATUS_BB_VALID);
        status_service_call();
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_post_read: read %d/%d bytes, checksum: %d, type: %d\n",
      ((REG_BOOTBLOCK *)bb_base)->container.size,
      ((REG_BOOTBLOCK *)bb_base)->container.max_size,
      ((REG_BOOTBLOCK *)bb_base)->container.cksum,
      ((REG_BOOTBLOCK *)bb_base)->container.type);

    return(0);

v1_post_read_error:
    if(((REG_BOOTBLOCK *)bb_base)->container.type == REG_CONTAINER_TYPE_SC) {
        clr_status_bits(SELECT_SC_STATUS, BB_STATUS_BB_VALID);
        status_service_call();
    }
    else if(((REG_BOOTBLOCK *)bb_base)->container.type == REG_CONTAINER_TYPE_NET) {
        clr_status_bits(SELECT_NET_STATUS, BB_STATUS_BB_VALID);
        status_service_call();
    }
  return(-1);

}

int reg_bbv1_pre_write(void *bb_base)
{
    unsigned char *bb_ptr;
    unsigned int bb_tag_id, bb_tag_len;
    unsigned int cksum;
    int bytes;


    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_pre_write: entered\n");

    bytes = 0;
    cksum = 0;
    bb_ptr = (unsigned char *)(((REG_BOOTBLOCK *)bb_base)->container.start);

    cksum =  (unsigned int)*bb_ptr++; /* add SCF_ID field to checksum */
    cksum += (unsigned int)*bb_ptr++;
    cksum += (unsigned int)*bb_ptr++;
    cksum += (unsigned int)*bb_ptr++;

    bytes = 4;

    while(bytes < BOOTBLOCK_BUFFER_SIZE) {
        bb_tag_id = (unsigned int)*bb_ptr++;
        bb_tag_len = (unsigned int)*bb_ptr++;

        cksum += (bb_tag_id + bb_tag_len + (unsigned int)*bb_ptr);

        bb_tag_len |= ((unsigned int)*bb_ptr++)<<8;

        if(bb_tag_id == 0xff) { /* checksum */
           /* *(unsigned int *)bb_ptr = cksum; */
           write_unaligned_int(bb_ptr, cksum);
           ((REG_BOOTBLOCK *)bb_base)->container.cksum = cksum;
           DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_pre_write: wrote new checksum: %d at offset: 0x%x\n", cksum, bb_ptr);
           bytes += 7;
           break;
        }
        bytes += (bb_tag_len + 3); /* account for bytes used */
        while(bb_tag_len--) cksum += (unsigned int)*bb_ptr++;
    }

    if(bytes > ((REG_BOOTBLOCK *)bb_base)->container.max_size) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "reg_bbv1_pre_write: bootblock (%d) exceeds maximum buffer size (%d)\n",
        	bytes, ((REG_BOOTBLOCK *)bb_base)->container.max_size);
        return(-1);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_pre_write: write block at 0x%x size %d\n",
    	((REG_BOOTBLOCK *)bb_base)->container.start,
    	((REG_BOOTBLOCK *)bb_base)->container.size);

    return(0);
}
/* ******************************************************************************** */
/* routine to provide info on tags within this block */
int reg_bbv1_tag_info(void *bb_base, unsigned char *tag)
{
    REG_V1_TAGS *rt;
    SOFT_TAG st;
    int tmp;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_tag_info: entered -> checking %s\n", tag);

    if((rt = v1_locate_tag(tag)) != NULL) { /* exists as hard or special tag */
      if(rt->flags & REG_V1_TAG_SPECIAL) {
          DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_tag_info: special tag\n");
          tmp = REG_TAG_INFO_SPECIAL_TAG;
      } else {
          DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_tag_info: hard tag\n");
          tmp = REG_TAG_INFO_HARD_TAG;
      }

      if(rt->flags & REG_V1_TAG_UPDATEABLE) tmp |= REG_TAG_INFO_UPDATEABLE;
      if(rt->flags & REG_V1_TAG_OVERRIDEABLE) tmp |= REG_TAG_INFO_OVERRIDEABLE;
    } else if(locate_softtag(tag, &st, (SOFTTAG_LIST *)(((REG_BOOTBLOCK *)bb_base)->container.wspace)) > 0) { /* exists as a soft tag */
      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_tag_info: soft tag\n");
      tmp = REG_TAG_INFO_SOFT_TAG;
      if(st.flags & REG_V1_TAG_UPDATEABLE) tmp |= REG_TAG_INFO_UPDATEABLE;
      if(st.flags & REG_V1_TAG_OVERRIDEABLE) tmp |= REG_TAG_INFO_OVERRIDEABLE;
    } else {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_tag_info: no such tag \"%s\"\n", tag);
        return(REG_TAG_INFO_NOSUCH_TAG);
    }
    return(tmp);
}



/* ******************************************************************************** */
/* routines to deal with hard tags */

int reg_bbv1_enum_htags(void *bb_base)
{
   unsigned char *bb_ptr;
   REG_V1_TAGS *tag;
   unsigned int bb_tag_id, bb_tag_len_lo, bb_tag_len_hi;

    bb_ptr = (unsigned char *)(((REG_BOOTBLOCK *)bb_base)->container.start);

    bb_ptr += 4; /* skip SCF_ID field */

    kprintf("\n\nVersion 1 Hard tags:\n--------------------\n\n");

    while(*bb_ptr != 0xff) { /* loop until checksum flag */
        bb_tag_id = (unsigned int)*bb_ptr++;
        bb_tag_len_lo = (unsigned int)*bb_ptr++;
        bb_tag_len_hi = (unsigned int)*bb_ptr++;

        bb_tag_len_lo |= (bb_tag_len_hi<<8);

        if(bb_tag_id == 0xfe) { /* soft tag - ignore it */
            bb_ptr += bb_tag_len_lo;
            continue;
        }
	if((tag=get_htag_by_id(bb_tag_id))==NULL) {
	    kprintf("Unknown tag id: 0x%x length: %d\n", bb_tag_id, bb_tag_len_lo);
	    bb_ptr += bb_tag_len_lo;
	    continue;
	}

	if((tag->flags & (REG_V1_TAG_INVISIBLE | REG_V1_TAG_SPECIAL))==0)
	    kprintf("Tag: %s\v28Id: 0x%x\v44Length: %d\v56%s %s %s\n", tag->tagname, bb_tag_id, bb_tag_len_lo,
	            tag->flags&REG_V1_TAG_UPDATEABLE?"UPD":"",
	            tag->flags&REG_V1_TAG_OVERRIDEABLE?"OVR":"",
	            tag->flags&REG_V1_TAG_PACKED?"PKD":"");

	bb_ptr += bb_tag_len_lo;
    }
    return(0);
}

int reg_bbv1_read_htags(void *bb_base, unsigned char *tag, unsigned char *buffer, unsigned int bytes)
{
    REG_V1_TAGS *rt;
    unsigned int tmp, len;
    unsigned char *src;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_htags: entered -> fetching %s\n", tag);

    if((rt = v1_locate_tag(tag)) == NULL) return(-1); /* no such tag (or invisible) */

    /* search bootblock for tag, or for parent tag if a sub tag */
    if(rt->flags & REG_V1_TAG_PACKED) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_htags: sub tag, parent tag id: %d\n", rt->src_tag);
        tmp = rt->src_tag;
    }
    else {
        tmp = rt->id;
    }

    if((src = find_tag_in_block(tmp, ((REG_BOOTBLOCK *)bb_base)->container.start, ((REG_BOOTBLOCK *)bb_base)->container.size)) == NULL) return(-3); /* no tag info available */

    len = (*(src + 2)<<8) | (*(src + 1));
    src += 3; /* src now points to tag data */
    if(buffer == NULL || bytes == 0) { /* return size only */
      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_htags: returning size only\n");
      return(len);
    }

    if(rt->flags & REG_V1_TAG_PACKED) { /* varibits */
      if(rt->src_offset > len) { /* offset of data in tag is greater than tag's actual size */
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_htags: varibit tag offset exceeds tag data size\n");
        return(-3); /* no tag info available */
      }
      tmp = read_unaligned_int(src + rt->src_offset); /* fetch relevant word within field */
      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_htags: read word from 0x%x + offset %d (=0x%x)\n", src, rt->src_offset, tmp);
      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_htags: mask with 0x%x, shift down by %d bits\n", rt->mask, rt->shift);
      tmp &= rt->mask;
      tmp >>= rt->shift;
      *(unsigned int *)buffer = tmp;
    } else { /* not a varibit field */
      if(len > bytes) return(-4); /* insufficient buffer space */
      memset(buffer, 0, bytes);
      memcpy(buffer, src, len);
    }
    return(len);
}

int reg_bbv1_write_htags(void *bb_base, unsigned char *tag, unsigned char *buffer, unsigned int bytes)
{
    REG_V1_TAGS *rt;
    unsigned char *src;
    unsigned int tmp, tmp2, tmp3;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_htags: entered\n");

    if((rt = v1_locate_tag(tag)) == NULL) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_htags: couldn't find tag\n");
        return(-1); /* no such tag (or invisible) */
    }

    if(!(rt->flags & REG_V1_TAG_UPDATEABLE)) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_htags: tag not updateable\n");
        return(-2); /* tag not updateable */
    }

    if(rt->flags & REG_V1_TAG_PACKED) { /* varibit - update in place */
      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_htags: varibit tag, parent tag is: %d\n", rt->src_tag);
      tmp = rt->src_tag;
      if((src = find_tag_in_block(tmp, ((REG_BOOTBLOCK *)bb_base)->container.start, ((REG_BOOTBLOCK *)bb_base)->container.size)) == NULL) {
          DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_htags: couldn't find tag %d in bootblock\n", rt->src_tag);
          return(-10); /* parent tag doesn't exist */
      }
      tmp2 = *((unsigned int *)buffer);
      tmp2 <<= rt->shift;
      tmp2 &= rt->mask;

      src += 3; /* src points to tag data */
      tmp3 = *(unsigned int *)(src + rt->src_offset); /* fetch relevant word within field */
      if(tmp2) tmp3 |= tmp2; /* set bit */
      else tmp3 &= ~tmp2; /* clr bit */
      *(unsigned int *)(src + rt->src_offset) = tmp3; /* write back */
      return(4);
    }

    /* not varibit - proceed as normal */

    if((src = find_tag_in_block(rt->id, ((REG_BOOTBLOCK *)bb_base)->container.start, ((REG_BOOTBLOCK *)bb_base)->container.size)) != NULL) { /* tag exists - delete and replace */
      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_htags: tag entry found\n");
      tmp = ((REG_BOOTBLOCK *)bb_base)->container.size; /* current block size */
      tmp2 = ((REG_BOOTBLOCK *)bb_base)->container.max_size; /* max. block size */
      tmp3 = (*(src + 2)<<8) | (*(src + 1)); /* size of existing tag */

      tmp -= tmp3;  /* don't need '+3' as tag_id + len is already stored -       */
      tmp += bytes; /* only the data field is changing in size	  	 	 */

      if(tmp > tmp2) {
      	 DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_htags: tag value too big\n");
         return(-3); /* tag value too big */
      }

      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_htags: removing old tag entry\n");
      remove_tag_in_block(bb_base, src);
      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_htags: appending new tag entry\n");
      append_tag_to_block(bb_base, rt->id, bytes, buffer);
    } else { /* tag not in block - append as new tag */
      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_htags: new tag - appending to bootblock\n");
      tmp = ((REG_BOOTBLOCK *)bb_base)->container.size; /* current block size */
      tmp2 = ((REG_BOOTBLOCK *)bb_base)->container.max_size; /* max. block size */

      if((tmp + bytes + 3) > tmp2) {
          DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_htags: tag value too big\n");
          return(-3); /* tag value too big */
      }

      append_tag_to_block(bb_base, rt->id, bytes, buffer);
    }

    return(bytes);
}

int reg_bbv1_delete_htags(void *bb_base, unsigned char *tag)
{
    REG_V1_TAGS *rt;
    unsigned char *src;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_delete_htags: entered\n");

    if((rt = v1_locate_tag(tag)) == NULL) return(-1); /* no such tag (or invisible) */

    if(!(rt->flags & REG_V1_TAG_UPDATEABLE)) return(-2); /* tag not updateable */
    if(rt->flags & REG_V1_TAG_PACKED) return(-2); /* can't delete a varibit tag */
    if((src = find_tag_in_block(rt->id, ((REG_BOOTBLOCK *)bb_base)->container.start, ((REG_BOOTBLOCK *)bb_base)->container.size)) == NULL) return(-1); /* tag not in block */

    remove_tag_in_block(bb_base, src);

    return(0);
}

int reg_bbv1_rename_htags(void *bb_base, unsigned char *tag, unsigned char *new_tag)
{
    /* erm, haven't written this yet */
    return(-11);
}
/* ******************************************************************************** */
/* routines to deal with soft tags */
int reg_bbv1_enum_stags(void *bb_base)
{
    unsigned char **ptr;
    unsigned char *st_ptr;
    SOFTTAG_LIST *slptr;
    unsigned int st_len, st_flags;

    kprintf("\n\nVersion 1 Soft tags:\n--------------------\n\n");

    slptr = (SOFTTAG_LIST *)((REG_BOOTBLOCK *)bb_base)->container.wspace;

    for(ptr = slptr->head; ptr != slptr->next; ptr++) {
       st_ptr = *ptr;
       if(*st_ptr++ != 0xfe) {
           kprintf("Unrecognized softtag - softtag mapping table corrupt - skipping\n");
           continue;
       }
        st_len = *st_ptr++;
        st_len |= (*st_ptr++) << 8;

        st_flags = (unsigned int)*st_ptr++;
        kprintf("Tag: %s \v44Length: %d \v56%s %s %s\n", st_ptr, st_len,
	            st_flags&REG_V1_TAG_UPDATEABLE?"UPD":"",
	            st_flags&REG_V1_TAG_OVERRIDEABLE?"OVR":"",
	            st_flags&REG_V1_TAG_PACKED?"PKD":"");
    }
    return(0);

}

int reg_bbv1_read_stags(void *bb_base, unsigned char *tag, unsigned char *buffer, unsigned int bytes)
{
    SOFT_TAG st;
    unsigned int data_len;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_stags: entered -> reading %s\n", tag);

    if(!locate_softtag(tag, &st, (SOFTTAG_LIST *)((REG_BOOTBLOCK *)bb_base)->container.wspace)) return(-1); /* no such tag */
    if(st.len > bytes) return(-3); /* tag value too big */

    if((buffer == NULL) || (bytes == 0)) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_stags: returning size only (%d)\n", st.len);
    } else {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_stags: returning data\n");
        memset(buffer, 0, bytes);

        data_len = st.len - (strlen((char *)st.name) + 2); /* 1 for terminating zero, 1 for flag byte */
        memcpy(buffer, st.data, data_len);
    }
    return(data_len);
}

int reg_bbv1_write_stags(void *bb_base, unsigned char *tag, unsigned char *buffer, unsigned int bytes)
{
    SOFT_TAG st;
    unsigned char *tag_src;
    unsigned char *new_tag_src;
    unsigned int new_len;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_stags: entered\n");

    if(locate_softtag(tag, &st, (SOFTTAG_LIST *)((REG_BOOTBLOCK *)bb_base)->container.wspace)) { /* tag exists */
      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_stags: soft tag already exists\n");
      tag_src = st.name - 4; /* rewind ptr to point to tag_id */

      new_len = ((REG_BOOTBLOCK *)bb_base)->container.size;
      new_len -= st.len;
      new_len += (bytes + strlen((char *)(st.name)) + 2); /* +1 for terminating 0, +1 for flags byte */

      if(new_len > ((REG_BOOTBLOCK *)bb_base)->container.max_size) return(-3); /* tag info too big */

      remove_tag_in_block(bb_base, tag_src); /* delete it */
      new_tag_src = append_softtag_to_block(bb_base, tag, buffer, bytes, st.flags);
      remap_softtag(tag_src, new_tag_src, (SOFTTAG_LIST *)((REG_BOOTBLOCK *)bb_base)->container.wspace);
    } else { /* it's a new soft tag */
      DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_stags: creating new soft tag record\n");
      st.flags = REG_V1_TAG_UPDATEABLE | REG_V1_TAG_OVERRIDEABLE;
      new_len = ((REG_BOOTBLOCK *)bb_base)->container.size;
      new_len += (bytes + strlen((char *)tag) + 5); /* +2 as above, +3 for tag id, lsb, msb */

       if(new_len > ((REG_BOOTBLOCK *)bb_base)->container.max_size) return(-3); /* tag info too big */

       new_tag_src = append_softtag_to_block(bb_base, tag, buffer, bytes, st.flags);
       add_soft_mapping(new_tag_src, (SOFTTAG_LIST *)((REG_BOOTBLOCK *)bb_base)->container.wspace);
    }
    return(bytes);
}

int reg_bbv1_delete_stags(void *bb_base, unsigned char *tag)
{
    SOFT_TAG st;
    unsigned char *tag_src;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_delete_stags: entered\n");
    if(!locate_softtag(tag, &st, (SOFTTAG_LIST *)((REG_BOOTBLOCK *)bb_base)->container.wspace)) return(-1); /* no such tag */
    tag_src = st.name - 4; /* rewind ptr to point to tag_id */
    remove_tag_in_block(bb_base, tag_src); /* delete it */
    remove_softtag_mapping((SOFTTAG_LIST *)((REG_BOOTBLOCK *)bb_base)->container.wspace, tag_src);


    return(0);
}

int reg_bbv1_rename_stags(void *bb_base, unsigned char *tag, unsigned char *new_tag)
{
    /* can't rename soft tags yet */
    return(-11);
}

/* ******************************************************************************** */
/* routines to deal with special tags */
int reg_bbv1_enum_sptags(void *bb_base)
{
   unsigned char *bb_ptr;
   REG_V1_TAGS *tag;
   unsigned int bb_tag_id, bb_tag_len_lo, bb_tag_len_hi;

    bb_ptr = (unsigned char *)(((REG_BOOTBLOCK *)bb_base)->container.start);

    bb_ptr += 4; /* skip SCF_ID field */

    kprintf("\n\nVersion 1 Special tags:\n-----------------------\n\n");

    while(*bb_ptr != 0xff) { /* loop until checksum flag */
        bb_tag_id = (unsigned int)*bb_ptr++;
        bb_tag_len_lo = (unsigned int)*bb_ptr++;
        bb_tag_len_hi = (unsigned int)*bb_ptr++;

        bb_tag_len_lo |= (bb_tag_len_hi<<8);

        if(bb_tag_id == 0xfe) { /* soft tag - ignore it */
            bb_ptr += bb_tag_len_lo;
            continue;
        }
	if((tag=get_htag_by_id(bb_tag_id))==NULL) {
	    kprintf("Unknown tag id: 0x%x length: %d\n", bb_tag_id, bb_tag_len_lo);
	    bb_ptr += bb_tag_len_lo;
	    continue;
	}

	if(((tag->flags & REG_V1_TAG_INVISIBLE)==0) && (tag->flags & REG_V1_TAG_SPECIAL))
	    kprintf("Tag: %s\v28Id: 0x%x\v44Length: %d\v56%s %s %s\n", tag->tagname, bb_tag_id, bb_tag_len_lo,
	            tag->flags&REG_V1_TAG_UPDATEABLE?"UPD":"",
	            tag->flags&REG_V1_TAG_OVERRIDEABLE?"OVR":"",
	            tag->flags&REG_V1_TAG_PACKED?"PKD":"");

	bb_ptr += bb_tag_len_lo;
    }
    return(0);
}


int reg_bbv1_read_sptags(void *bb_base, unsigned char *tag, unsigned char *buffer, unsigned int bytes)
{
    unsigned char *pbuff;
    int id_bytes, secret_bytes;
    unsigned char *scptr;

    unsigned char tag_id[] = "LOGIN_ID";
    unsigned char tag_secret[] = "LOGIN_SECRET";
    unsigned char tag_system[] = "SYSTEM_FLAGS1";

    _kernel_swi_regs r;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: entered -> reading %s\n", tag);
    if(caseless_strcmp((char *)tag, "SEND_EXPECT") != 0) return(-3); /* we only support the send_expect special tag */

    if((scptr = find_tag_in_block(0x25, ((REG_BOOTBLOCK *)bb_base)->container.start,
    	      ((REG_BOOTBLOCK *)bb_base)->container.size)) == NULL) {
    	          DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: failed to find SEND_EXPECT data in bootblock\n");
    	          return(-9); /* oh dear */
    	      }

    scptr += 3; /* skip tag id and length */

    if((pbuff = (unsigned char *)rmalloc(1024, "Temp")) == NULL) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: couldn't claim temporary buffer\n");
        return(-6); /* couln't claim workspace */
    }
    memset(pbuff, 0, 1020);

    if(reg_bbv1_read_htags(bb_base, tag_system, pbuff, 1020)<0) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: couldn't read SYSTEM_FLAGS1\n");
        rmfree((char *)pbuff);
        return(-7); /* couldn't read ancillary tag */
    }
    if((id_bytes = reg_bbv1_read_htags(bb_base, tag_id, pbuff+4, 1016))<0) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: couldn't read LOGIN_ID\n");
        rmfree((char *)pbuff);
        return(-7); /* couldn't read ancillary tag */
    }
    if((secret_bytes = reg_bbv1_read_htags(bb_base, tag_secret, pbuff+id_bytes+5, 1016-(id_bytes+1)))<0) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: couldn't read LOGIN_SECRET\n");
        rmfree((char *)pbuff);
        return(-7); /* couldn't read ancillary tag */
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: calling support SWIs with:\n");
    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: id: %s, secret: %s, flags: 0x%x\n", (pbuff+4), (pbuff + 5 + id_bytes),
    			       *(unsigned int *)pbuff);
    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: id_len: %d secret_len: %d\n", id_bytes, secret_bytes);

    r.r[0] = NULL;
    r.r[1] = SELECT_SC_BB;
    r.r[2] = NULL;
    r.r[3] = 0;
    r.r[4] = 0xbeefcafe;
    r.r[5] = *(unsigned int *)pbuff;
    r.r[6] = (unsigned int)scptr;

    _kernel_swi(0x4d3c0, &r, &r);

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: support init returned\n");

    r.r[0] = 0x4; /* SEND_EXPECT special tag number */
    r.r[1] = (unsigned int)buffer;
    if((buffer == NULL) || (bytes == 0)) {
    	DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: returning size only\n");
        r.r[2] = 0;
    } else {
        r.r[2] = bytes;
    }
    r.r[3] = SELECT_SC_BB;
    r.r[4] = sc_status;
    r.r[5] = ((id_bytes << 16) | secret_bytes);
    r.r[6] = 0xbeefcafe;
    r.r[7] = (unsigned int)(pbuff + 4);
    r.r[8] = (unsigned int)(pbuff + 5 + id_bytes);
    r.r[9] = ((id_bytes << 16) | secret_bytes);

    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: munged length field: 0x%x\n", r.r[9]);

    _kernel_swi(0x4d3c1, &r, &r);
    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_read_sptags: support read SWI returned %d bytes\n", r.r[0]);
    rmfree((char *)pbuff);
    return(r.r[0]);
}

int reg_bbv1_write_sptags(void *bb_base, unsigned char *tag, unsigned char *buffer, unsigned int bytes)
{
    DBUG_PRINTF(DBUG_LVL_DIAG, "reg_bbv1_write_stags: entered\n");
    /* can't write version 1 special tags */
    return(-11);
}

int reg_bbv1_delete_sptags(void *bb_base, unsigned char *tag)
{
    /* can't delete version 1 special tags */
    return(-11);
}

int reg_bbv1_rename_sptags(void *bb_base, unsigned char *tag, unsigned char *new_tag)
{
    /* can't rename version 1 special tags */
    return(-11);
}


/* ******************************************************************************** */

/* support routines */

/* check given hard tag id is valid */
int is_bbv1_htag(unsigned int tag_id)
{
  REG_V1_TAGS *rt;

  for(rt = reg_v1_tags; *(rt->tagname) != NULL; rt++) {
    if(rt->id == tag_id) return(1);
  }

  return(0);
}

/* return name for given hard tag id */
REG_V1_TAGS *get_htag_by_id(unsigned int tag_id)
{
    REG_V1_TAGS *rt;

  for(rt = reg_v1_tags; *(rt->tagname) != NULL; rt++) {
    if(rt->id == tag_id) return(rt);
  }

  return(NULL);
}


/* add a soft tag to the soft tag mapping table */
int add_soft_mapping(void *tag_ptr, SOFTTAG_LIST *slptr)
{
    if(slptr->next == slptr->tail) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "add_soft_mapping: no room in soft tag table\n");
        return(-1);
    }

    /* why the hell did I define tag_ptr as void * ? */
    if((unsigned int)*(unsigned char *)tag_ptr != 0xfe) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "add_soft_mapping: requested bootblock address is not a soft tag\n");
        return(-1);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "add_soft_mapping: soft tag added to list\n");
    *(slptr->next) = (unsigned char *)tag_ptr;
    slptr->next++;
    return(0);
}

/* update soft tag mappings after the bootblock contents have changed */
void update_softtag_mappings(unsigned char *deleted, unsigned char *moved, SOFTTAG_LIST *slptr)
{
    unsigned char **ptr;
    unsigned char *st_ptr;
    int offset;

    DBUG_PRINTF(DBUG_LVL_DIAG, "update_softtag_mappings: entered\n");

    offset = moved - deleted;
    for(ptr = slptr->head; ptr != slptr->next; ptr++) {
        st_ptr = *ptr;
	DBUG_PRINTF(DBUG_LVL_DIAG, "update_softtag_mappings: cf. 0x%x with 0x%x\n", st_ptr, deleted);
	if(st_ptr == deleted) { /* found the target tag */
	  /* we ignore the target tag because it will be deleted or remapped as appropriate */
	  DBUG_PRINTF(DBUG_LVL_DIAG, "update_softtag_mappings: target tag found - ignoring\n");
	} else if(st_ptr < deleted) { /* tag intact */
	  DBUG_PRINTF(DBUG_LVL_DIAG, "update_softtag_mappings: tag unaffected\n");
	} else { /* tag ptr invalid - remap it */
	  DBUG_PRINTF(DBUG_LVL_DIAG, "update_softtag_mappings: remap needed, shifting up by %d bytes\n", offset);
	  *ptr = (st_ptr - offset);
	}
    }
    return;
}

/* remove an entry from the softtag mappings and tidy the mapping table as appropriate */
int remove_softtag_mapping(SOFTTAG_LIST *slptr, unsigned char *tag_src)
{
    unsigned char **ptr;
    unsigned char *st_ptr;
    unsigned int overwrite;

    DBUG_PRINTF(DBUG_LVL_DIAG, "remove_softtag_mapping: entered\n");

    for(overwrite = 0, ptr = slptr->head; ptr != slptr->next; ptr++) {
        st_ptr = *ptr;

        if(!overwrite) {
            if(st_ptr == tag_src) { /* found it */
              slptr->next--;
              overwrite = 1;
              if(ptr == slptr->next) { /* we're at the end of the list, so bail */
                DBUG_PRINTF(DBUG_LVL_DIAG, "remove_softtag_mapping: target found at end of list\n");
                break;
              } else {
                DBUG_PRINTF(DBUG_LVL_DIAG, "remove_softtag_mapping: moving FIRST list entry up\n");
                *ptr = *(ptr + 1);
              }
            }
        } else { /* in update-tags mode */
           DBUG_PRINTF(DBUG_LVL_DIAG, "remove_softtag_mapping: moving subsequent list entry up\n");
           *ptr = *(ptr + 1);
        }
    }

    if(overwrite) return(1);
    DBUG_PRINTF(DBUG_LVL_DIAG, "remove_softtag_mapping: target tag not found\n");
    return(0);
}



/* locate named hard tag in master tag index */
REG_V1_TAGS *v1_locate_tag(unsigned char *tagname)
{
    REG_V1_TAGS *rt;

  for(rt = reg_v1_tags; *(rt->tagname) != NULL; rt++) {
    // DBUG_PRINTF(DBUG_LVL_LOOP, "Comparing: %s with %s\n", rt->tagname, tagname);
    if(caseless_strcmp((char *)tagname, (char *)rt->tagname) == 0) {
        if(rt->flags & REG_V1_TAG_INVISIBLE) {
            DBUG_PRINTF(DBUG_LVL_DIAG, "v1_locate_tag: hard tag exists, but is invisible\n");
            break;
        } else {
            DBUG_PRINTF(DBUG_LVL_DIAG, "v1_locate_tag hard tag %s found\n", tagname);
            return(rt);
        }
    }
  }
  DBUG_PRINTF(DBUG_LVL_DIAG, "v1_locate_tag: hard tag %s not found\n", tagname);
  return((REG_V1_TAGS *)NULL);
}

/* locate named soft tag in soft tag mapping table */
int locate_softtag(unsigned char *tag, SOFT_TAG *st, SOFTTAG_LIST *slptr)
{
    unsigned char **ptr;
    unsigned char *st_ptr;
    unsigned int st_len;
    unsigned int st_flags;

    for(ptr = slptr->head; ptr != slptr->next; ptr++) {
        DBUG_PRINTF(DBUG_LVL_DIAG, "locate_softtag: ptr 0x%x\n", ptr);
        st_ptr = *ptr;
        if(*st_ptr++ != 0xfe) { /* eek! */
          DBUG_PRINTF(DBUG_LVL_DIAG, "locate_softtag: softtag table entry corupted - skipping\n");
          continue;
        }

        st_len = *st_ptr++;
        st_len |= (*st_ptr++) << 8;

        st_flags = (unsigned int)*st_ptr++;
	DBUG_PRINTF(DBUG_LVL_DIAG, "locate_softtag: cf. request \"%s\" with softtag \"%s\"\n", tag, st_ptr);
        if(caseless_strcmp((char *)st_ptr, (char *)tag) == 0) { /* it's a hit */
          st->name = st_ptr;
          st->len = st_len;
          st->flags = st_flags;
          while(*st_ptr++ != 0);
          st->data = st_ptr;
          return(1);
        }
    }
    return(0);
}

/* search for location of given tag_id in a boot block */
unsigned char *find_tag_in_block(unsigned int tag_id, unsigned char *src, unsigned int bytes)
{
    unsigned int len;
    int nbytes;

    nbytes = (int)bytes;

    src += 4; /* skip SCF_ID field */

    DBUG_PRINTF(DBUG_LVL_DIAG, "find_tag_in_block: searching for tag id %d in %d bytes\n", tag_id, bytes);

    while(nbytes>0) {
        DBUG_PRINTF(DBUG_LVL_LOOP, "find_tag_in_block: tag id: %d\n", (int)*src);
        if((unsigned int)*src == tag_id) {
            DBUG_PRINTF(DBUG_LVL_DIAG, "find_tag_in_block: found\n");
            return(src);
        }
        if(*src == 0xff) {
            DBUG_PRINTF(DBUG_LVL_DIAG, "find_tag_in_block: hit checksum tag without finding target\n");
            return(NULL); /* hit checksum tag without finding target */
        }
        len = (*(src + 2)<<8) | (*(src + 1));
        src += (len + 3);
        nbytes -= (len + 3);
    }
    DBUG_PRINTF(DBUG_LVL_DIAG, "find_tag_in_block: exhausted bootblock without finding target\n");
    return(NULL);
}

/* remove a tag from bootblock, update records */
int remove_tag_in_block(void *bb_base, unsigned char *src)
{
    unsigned int len;
    unsigned int new_len;
    unsigned char *new_src;
    unsigned char *csum_src;

    DBUG_PRINTF(DBUG_LVL_DIAG, "remove_tag_in_block: entered\n");

    /* get length of tag to be deleted */
    len = (*(src + 2)<<8) | (*(src + 1));
    len += 3;

    /* calc. ptr to tag after deletion target */
    new_src = src + len;

    /* find ptr. to checksum tag */
    if((csum_src = find_tag_in_block(0xff, ((REG_BOOTBLOCK *)bb_base)->container.start, ((REG_BOOTBLOCK *)bb_base)->container.size))==NULL)
    return(-1);

    /* calculate number of bytes in bootblock after deletion target */
    new_len = (int)csum_src - (int)new_src;
    new_len += 7; /* add on actual size of csum */

    DBUG_PRINTF(DBUG_LVL_DIAG, "remove_tag_in_block: removed %d bytes from 0x%x \n", len, src);
    DBUG_PRINTF(DBUG_LVL_DIAG, "remove_tag_in_block: moved %d bytes from 0x%x to 0x%x\n", new_len, new_src, src);

    /* move following block up, overwriting deletion target */
    memmove(src, new_src, new_len);
    update_softtag_mappings(src, new_src, (SOFTTAG_LIST *)((REG_BOOTBLOCK *)bb_base)->container.wspace);

    /* update bootblock records */
    new_len = ((REG_BOOTBLOCK *)bb_base)->container.size;
    new_len -= len;
    ((REG_BOOTBLOCK *)bb_base)->container.size = new_len;

    return(1);
}

/* append a new tag to the end of the bootblock - rewrite checksum tag */
int append_tag_to_block(void *bb_base, unsigned int tag_id, unsigned int bytes, unsigned char *buffer)
{
    unsigned char *csum_src;

    /* find start of checksum tag */
    if((csum_src = find_tag_in_block(0xff, ((REG_BOOTBLOCK *)bb_base)->container.start, ((REG_BOOTBLOCK *)bb_base)->container.size))==NULL)
    return(-1);

    /* overwrite it with new tag info */
    *csum_src++ = (unsigned char)tag_id;
    *csum_src++ = (unsigned char)(bytes & 0xff);
    *csum_src++ = (unsigned char)((bytes >> 8) & 0xff);
    memcpy(csum_src, buffer, bytes);

    csum_src += bytes;

    *csum_src++ = 0xff;
    *csum_src++ = 4;
    *csum_src++ = 0;

    ((REG_BOOTBLOCK *)bb_base)->container.size += (bytes+3); /* +1 each for tag id, lsb, msb */
    return(1);
}

/* append a soft tag to the block - return ptr to start of tag defn */
unsigned char *append_softtag_to_block(void *bb_base, unsigned char *tag, unsigned char *buffer, unsigned int bytes, unsigned int flags)
{
    unsigned char *csum_src;
    unsigned char *new_tag_ptr;
    unsigned int st_len;
    unsigned int tag_name_len;

    DBUG_PRINTF(DBUG_LVL_DIAG, "append_softtag_to_block: entered\n");
    tag_name_len = strlen((char *)tag);
    /* find start of checksum tag */
    if((csum_src = find_tag_in_block(0xff, ((REG_BOOTBLOCK *)bb_base)->container.start, ((REG_BOOTBLOCK *)bb_base)->container.size))==NULL) {
        DBUG_PRINTF(DBUG_LVL_ERROR, "append_softtag_to_block: couldn't find checksum field.\n");
    	return(NULL);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "append_softtag_to_block: checksum tag found - overwriting\n");

    new_tag_ptr = csum_src;
    st_len = bytes + tag_name_len + 2; /* 1 for terminating zero & 1 for flags byte */

    /* overwrite it with new tag info */
    *csum_src++ = (unsigned char)0xfe; /* soft tag id */
    *csum_src++ = (unsigned char)(st_len & 0xff);
    *csum_src++ = (unsigned char)((st_len >> 8) & 0xff);

    *csum_src++ = (unsigned char)flags;
    memcpy(csum_src, tag, tag_name_len);
    csum_src += tag_name_len;
    *csum_src++ = 0;
    memcpy(csum_src, buffer, bytes);

    /* write new (blank) checksum tag */
    csum_src += bytes;

    *csum_src++ = 0xff; /* checksum source */
    *csum_src++ = 4;
    *csum_src++ = 0;

    ((REG_BOOTBLOCK *)bb_base)->container.size += (bytes+ tag_name_len + 5); /* +2 as above +3 for tag, lsb, msb */

    return(new_tag_ptr);
}

/* remap an old softtag mapping to point to its new location */
int remap_softtag(unsigned char *tag_src, unsigned char *new_tag_src, SOFTTAG_LIST *slptr)
{
    unsigned char **ptr;
    unsigned char *st_ptr;

    DBUG_PRINTF(DBUG_LVL_DIAG, "remap_softtag: entered\n");

    for(ptr = slptr->head; ptr != slptr->next; ptr++) {
        st_ptr = *ptr;
	DBUG_PRINTF(DBUG_LVL_DIAG, "remap_softtag: cf. 0x%x with 0x%x\n", st_ptr, tag_src);
	if(st_ptr == tag_src) { /* found it */
	  DBUG_PRINTF(DBUG_LVL_DIAG, "remap_softtag: remapped tag from 0x%x to 0x%x\n", tag_src, new_tag_src);
	  *ptr = new_tag_src; /* remap */
	  return(1);
	}
    }
    DBUG_PRINTF(DBUG_LVL_ERROR, "remap_softtag: soft tag entry not found - remap failed\n");
    return(0);
}

/* read integer from non-word aligned memory */
unsigned int read_unaligned_int(unsigned char *ptr)
{
    unsigned int i;

    i = (unsigned int)*ptr++;
    i |= ((unsigned int)*ptr++)<<8;
    i |= ((unsigned int)*ptr++)<<16;
    i |= ((unsigned int)*ptr++)<<24;
    return(i);
}

/* write integer to non-word aligned memory */
void write_unaligned_int(unsigned char *ptr, unsigned int i)
{
    *ptr++ = i & 0xff;
    *ptr++ = (i >> 8) & 0xff;
    *ptr++ = (i >> 16) & 0xff;
    *ptr++ = (i >> 24) & 0xff;
    return;
}


