; >s.Module

CR				* 13
XDebugTools_ClaimOSSWI		*  7 + 0x000554C0 :OR: 0x20000
XDebugTools_ReleaseOSSWI	*  9 + 0x000554C0 :OR: 0x20000
Max_ModHandReason		* 21 * 4
Max_BlockSize			* 12 * 4
WSP_size			* Max_ModHandReason + Max_BlockSize


	AREA	|Asm$$Code|, CODE, READONLY


; ****************************************************
; *
; * Module header block
; *
Module_BaseAddr
	&	Mod_Start-Module_BaseAddr	; Module start entry point offset
	&	Mod_Init-Module_BaseAddr	; Module intialisation entry point offset
	&	Mod_Die-Module_BaseAddr		; Module finalisation entry point offset
	&	Mod_Service-Module_BaseAddr	; Module service call entry point offset
	&	Mod_Title-Module_BaseAddr	; Module title string offset
	&	Mod_HelpStr-Module_BaseAddr	; Module version info string offset
	&	Mod_HC_Table-Module_BaseAddr	; Help and command keyword table offset
	&	0				; SWI chunk
	&	Mod_SWIHandler-Module_BaseAddr	; Module SWI handler entry point offset
	&	Mod_SWITable-Module_BaseAddr	; Module SWI table offset
	&	0				; No SWI name decode entry
	&	0				; No messages file
	&	Mod_Flags-Module_BaseAddr	; Module flags word offset


; ****************************************************
; *
; * Module version, date (and copyright) string
; *
Mod_HelpStr
	DCB	"Debug Test", 9
	DCB	"$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
	DCB	" $Module_MinorVersion"
 ]
	DCB	0
	ALIGN


; ****************************************************
; *
; * Module flags word
; *
Mod_Flags
 [ No32bitCode
	&	0
 |
	&	ModuleFlag_32bit
 ]


; ****************************************************
; *
; * Module help and command keyword table
; *
Mod_HC_Table
	Command OSModule, 0, 0
	Command OSModule_Read, 0, 0
	DCB	0
OSModule_Help
	DCB	"Output count of OS_Module calls since last call to this *command.", CR
OSModule_Syntax
	DCB	"Syntax: *OSModule", 0
OSModule_Read_Help
	DCB	"Output count of OS_Module calls without resetting the counts to zero.", CR
OSModule_Read_Syntax
	DCB	"Syntax: *OSModule_Read", 0


; ****************************************************
; *
; * Module title string and module SWI table
; *
Mod_Title
	DCB	"DebugTest", 0


; ****************************************************
; *
; * Unused stuff
; *
Mod_Start * Module_BaseAddr
Mod_SWIHandler * Module_BaseAddr
Mod_SWITable * Module_BaseAddr
Mod_Service * Module_BaseAddr

; ****************************************************
; *
; * Module initialisation entry point
; *
; * In...
; *   R10	= pointer to environment string
; *   R11	= I/O base or instantiation number
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0-R6	= can be corrupted
; *   R7-R11	= must be preserved
; *   R12	= can be corrupted
; *   R13	= must be preserved
; *   R14	= can be corrupted
; *   V flag	= set if R0 is a pointer to an error block
; *
Mod_Init Entry
	WriteLn	"InitTest..."
	MOV	R0, #ModHandReason_Claim
	MOV	R3, #WSP_size
	SWI	XOS_Module
	BVS	InitErr
	WriteLn	"  Zero-init;"
	MOV	R0, #0
	MOV	R1, R2
00	STR	R0, [R1], #4
	SUBS	R3, R3, #4
	BNE	%BT00
	STR	R2, [R12]
	WriteLn	"  Claim;"
	MOV	R0, #OS_Module
	ADR	R1, OSModule_Handler
	SWI	XDebugTools_ClaimOSSWI
	WriteLn	"  Done."
InitErr	EXIT


; ****************************************************
; *
; * Module finalisation entry point
; *
; * In...
; *   R10	= fatality indication: 0 is non-fatal, 1 is fatal
; *   R11	= instantiation number
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0-R6	= can be corrupted
; *   R7-R11	= must be preserved
; *   R12	= can be corrupted
; *   R13	= must be preserved
; *   R14	= can be corrupted
; *   V flag	= set if R0 is a pointer to an error block
; *
Mod_Die Entry
	WriteLn	"DieTest..."
	LDR	R2, [R12]
	WriteLn	"  Release;"
	MOV	R0, #OS_Module
	ADR	R1, OSModule_Handler
	SWI	XDebugTools_ReleaseOSSWI
	WriteLn	"  Free;"
	;
	MOV	R0, #ModHandReason_Free
	SWI	XOS_Module
	MOV	R0, #0
	STR	R0, [R12]
	CLRV
	WriteLn	"  Done."
DieErr	EXIT


OSModule_Handler
	; Exit early for out-of-range reason codes...
	CMP	R0, #(Max_ModHandReason-4) :SHR: 2
	MOVHI	PC, LR
	; Push some scratch registers...
	Entry	"R0-R1"
	; Disable interrupts...
	SCPSR	I_bit, 0, R1,, R14
	NOP
	; Increment our counter...
	LDR	R1, [R12, R0, LSL #2]
	ADD	R1, R1, #1
	STR	R1, [R12, R0, LSL #2]
	; Restore interrupts...
	RestPSR	R14
	; Go to next section if it's a claim...
	TEQ	R0, #ModHandReason_Claim
	BEQ	%FT00
	; Exit (allow claim to continue)...
	EXIT
00	; How big (power of 2) is the block to claim?
	MOV	R0, #Max_ModHandReason
	MOV	R14, R3, LSR #2		; Start at 4 byte blocks
01	MOVS	R14, R14, LSR #1
	ADDNE	R0, R0, #4
	BNE	%BT01
	; Blocks bigger than our limit are treated as the biggest...
	CMP	R0, #WSP_size-4
	MOVHI	R0, #WSP_size-4
	; Disable interrupts again...
	SCPSR	I_bit, 0, R1,, R14
	NOP
	; Incrememt hit count for the specified block size...
	LDR	R1, [R12, R0]
	ADD	R1, R1, #1
	STR	R1, [R12, R0]
	; Restore interrupts again...
	RestPSR	R14
	NOP
	; Exit (allow claim to continue)...
	EXIT


OSModule_Read_Code ROUT
	MOV	R6, #0
	B	Common_Code
OSModule_Code ROUT
	MOV	R6, #1
	B	Common_Code
Common_Code Entry "R7-R11"
	LDR	R12, [R12]
	; Claim a block to copy our statistics into...
	MOV	R0, #ModHandReason_Claim
	MOV	R3, #WSP_size
	SWI	XOS_Module
	EXIT	VS
	SCPSR	I_bit, 0, R0,, R14	; IRQs off
	MOV	R0, #0
	; Copy the values and reset them to zero...
00	LDR	R1, [R12], #4
	TEQ	R6, #1
	STREQ	R0, [R12, #-4]
	SUBS	R3, R3, #4
	STR	R1, [R2], #4
	BNE	%BT00
	RestPSR	R14			; IRQs on
	NOP
	SUB	R12, R2, #WSP_size
	; Output a title line...
	SWI	XOS_WriteS
	DCB	"OS_Module calls:", 10, 13, 0
	ALIGN
	; Loop through all OS_Module reason codes...
	MOV	R4, #0
	MOV	R5, #Max_ModHandReason :SHR: 2
	; Claim a small stack frame for workspace...
	SUB	SP, SP, #16
01	SWI	XOS_WriteS
	DCB	"  R0=", 0
	ALIGN
	MOV	R0, R4
	MOV	R1, SP
	MOV	R2, #16
	; Output reason number...
	SWI	XOS_ConvertCardinal4
	SWI	XOS_Write0
	SWI	XOS_WriteI+" "
	LDR	R0, [R12, R4, LSL #2]
	MOV	R3, R0
	MOV	R1, SP
	MOV	R2, #16
	; Output counter...
	SWI	XOS_ConvertCardinal4
	SWI	XOS_Write0
	SWI	XOS_NewLine
	; Is this claims? If so, output stats on ave. block sizes...
	TEQ	R4, #ModHandReason_Claim
	BNE	%FT03
	; Loop through counters for various block claim sizes...
	ADD	R7, R12, #Max_ModHandReason
	ADD	R8, R7,  #Max_BlockSize
	MOV	R9, #4
02	SWI	XOS_WriteS
	DCB	"    R3=", 0
	ALIGN
	MOV	R0, R9
	MOV	R1, SP
	MOV	R2, #16
	SWI	XOS_ConvertCardinal4
	SWI	XOS_Write0
	SWI	XOS_WriteI+" "
	LDR	R0, [R7], #4
	MOV	R1, SP
	MOV	R2, #16
	SWI	XOS_ConvertCardinal4
	SWI	XOS_Write0
	SWI	XOS_NewLine
	MOV	R9, R9, LSL #1
	CMP	R7, R8
	BLO	%BT02
03	; Move on to the next reason code (if any)...
	ADD	R4, R4, #1
	CMP	R4, R5
	BLO	%BT01
	; Release our stack frame...
	ADD	SP, SP, #16
	; Free our RMA copy...
	MOV	R0, #ModHandReason_Free
	MOV	R2, R12
	SWI	XOS_Module
	EXIT


	END
