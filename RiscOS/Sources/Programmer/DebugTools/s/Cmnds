; s.Cmnds


; ****************************************************
; *
; * *Where [<address>]
; *
; * Output information about the specified address (or that of the last
; * abort).
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= preserved (or pointer to error block)
; *   R1-R2	= corrupted
; *   R3-R9	= preserved
; *   R10-R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
Where_Code Entry
	LDR	R12, [R12]
	CMP	R1, #1
	BHI	where_param_err
	BLO	%FT00
	MOV	R1, R0
	MOV	R0, #0x80000010
	SWI	XOS_ReadUnsigned
	BVS	where_param_err
	MOV	R0, #0
	MOV	R1, R2
	BL	SWI_Where
	EXIT
00	; Read the source address from the last exception's address...
	MOV	R0, #1
	BL	SWI_Where
	EXIT


; ****************************************************
; *
; * *Vectors
; *
; * List the contents of the software vectors.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted
; *   R1-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
Vectors_Code ROUT
	LDR	R12, [R12]
	CMP	R1, #1
	BHI	vector_param_err
	Entry
	BLO	%FT00
	MOV	R1, R0
	MOV	R4, R0	; Preserve string pointer in case of error
	MOV	R0, #0x80000010
	SWI	XOS_ReadUnsigned
	BVS	%FT01
	; The parameter was a vector number. Enumerate just this vector...
	MOV	R0, #1
	MOV	R1, R2
	BL	SWI_Vectors
	EXIT
00	; If no parameters were specified, enumerate all vectors...
	MOV	R0, #0
	BL	SWI_Vectors
	EXIT
01	; The parameter was a vector name. Look-up its number...
	MOV	R1, R4
	BL	Str_to_vector
	MOVVC	R0, #1
	BLVC	SWI_Vectors
	EXIT


; ****************************************************
; *
; * *Tickers
; *
; * List the contents of the Kernel's CallAfter and CallEvery list.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted
; *   R1-R9	= preserved
; *   R10-R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
Tickers_Code ROUT
	LDR	R12, [R12]
	B	SWI_Tickers


; ****************************************************
; *
; * *Devices
; *
; * List the contents of the Kernel device vectors.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted
; *   R1-R9	= preserved
; *   R10-R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
Devices_Code ROUT
	LDR	R12, [R12]
	B	SWI_Devices


; ****************************************************
; *
; * *X <CLI command>
; *
; * Execute the specified *command and place any error into the X$Error system
; * variable (if it is currently unset). Do not return the error.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R4	= corrupted
; *   R5-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
X_Code Entry
	; Execute the CLI command...
	SWI	XOS_CLI
	EXIT	VC
	; Read the X$Error system variable...
	ADD	R12, R0, #4
	ADR	R0, X_sys_var
	MOV	R1, R12
	MVN	R2, #0
	MOV	R3, #0
	MOV	R4, #0
	SWI	XOS_ReadVarVal
	; Exit if it is set to something...
	TEQ	R2, #0
	CMNNE	R2, #1
	EXIT	NE
	; Find the end of the error string...
	MOV	R0, R12
	MOV	R1, R0
00	LDRB	R2, [R0], #1
	TEQ	R2, #0
	BNE	%BT00
	; Set the X$Error variable to the error message...
	SUB	R2, R0, R1
	ADR	R0, X_sys_var
	MOV	R3, #0
	MOV	R4, #0
	SWI	XOS_SetVarVal
	EXIT
X_sys_var
	DCB	"X$Error", 0
	ALIGN


; ****************************************************
; *
; * *Canonical <sys var> <file spec>
; *
; * Canonicalise the specified filename and place the result in a system variable.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R5	= corrupted
; *   R6-R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
Canonical_Code Entry
	MOV	R4, R0		; Preserve R0 (CLI str) in R4
	; Claim RMA block for the resultant string...
	MOV	R0, #ModHandReason_Claim
	MOV	R3, #4096
	SWI	XOS_Module
	EXIT	VS
	MOV	R12, R2		; Preserve R2 (RMA) in R12
	; Parse the parameters to this utility
	ADR	R0, canonical_synstr
	MOV	R1, R4		; Restore R0 into R1
	SWI	XOS_ReadArgs
	BVS	canonical_param_err
	LDMIA	R12, {R0, R1}
	TEQ	R0, #0
	TEQNE	R1, #0
	BEQ	canonical_param_err
	; Canonicalise the path
	MOV	R0, #FSControl_CanonicalisePath
	MOV	R2, R1
	MOV	R3, #0
	MOV	R4, #0
	MOV	R5, #2048
	SWI	XOS_FSControl
	BVS	canonical_err_exit
	; R5 - bytes free (in 2048 byte buffer)
	;
	; Place the result into a system variable
	LDR	R0, [R12]
	RSB	R2, R5, #2048	; Calculate length of string
	MOV	R3, #0
	MOV	R4, #0
	SWI	XOS_SetVarVal
	BVS	canonical_err_exit
	; Free our RMA block (return possible error)
	MOV	R0, #ModHandReason_Free
	MOV	R2, R12
	SWI	XOS_Module
	EXIT
canonical_err_exit
	MOV	R3, R0
	MOV	R0, #ModHandReason_Free
	MOV	R2, R12
	SWI	XOS_Module
	MOV	R0, R3
	SETV
	EXIT
canonical_synstr
	DCB	"var,file", 0
	ALIGN


; ****************************************************
; *
; * *IRQInfo [<IRQ device number>]
; *
; * Output information on how many times each device was called in the last
; * second and what percentage of the CPU time the device driver consumed.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R5	= corrupted
; *   R6-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
IRQInfo_Code Entry "R10"
	; Dereference our private word pointer...
	LDR	R12, [R12]

	; Output a title banner...
	SWI	XOS_WriteS
	DCB	"Device: Calls:      CPU Use:", 10, 13, 0
	ALIGN

	; Enumerate all of the IRQs 0-15...
	ADD	R3, R12, #WSP_IRQinfo
	MOV	R0, #0
	MOV	R10, #OS_ConvertCardinal4
	ORR	R10, R10, #0x20000
00	LDMIA	R3 !, {R4-R5}
	Push	"R0"
	; Output the IRQ number with padding...
	MOV	R2, #8
	BL	NumPad
	SWI	XOS_Write0
	; Output the number of calls with padding...
	MOV	R0, R5
	MOV	R2, #12
	BL	NumPad
	SWI	XOS_Write0
	; Output the cycles as a percentage of CPU usage...
	BL	CPUPcnt
	SWI	XOS_NewLine
	; Move on to the next IRQ...
	Pull	"R0"
	ADD	R0, R0, #1
	CMP	R0, #32
	BLO	%BT00

	; Output the info for the other IRQs...
	LDMIA	R3, {R4-R5}
	SWI	XOS_WriteS
	DCB	"32+     ", 0
	ALIGN
	MOV	R0, R5
	BL	NumPad
	SWI	XOS_Write0
	BL	CPUPcnt
	SWI	XOS_NewLine
	EXIT


; ****************************************************
; *
; * *UnknownIRQs
; *
; * Output a dump of our count of how many times we have seen each device
; * pass along IrqV since the last call to this *command. Reset all counters
; * to zero after reading them.
; *
; * In...
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R4	= corrupted
; *   R5-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
UnknownIRQs_Code Entry "R10"
	LDR	R12, [R12]
	; Ensure that we managed to claim IrqV...
	LDR	R0, [R12, #WSP_IRQtable]
	CMP	R0, #0
	BEQ	UnkExit
	; Initialise some registers...
	MOV	R10, #OS_ConvertCardinal4
	ORR	R10, R10, #0x20000
	MOV	R3, #0
	ADD	R4, R12, #WSP_UnkIRQCount
	; R3  = device number
	; R4  = pointer to base of table
	; R10 = conversion SWI number

	; Output a heading...
	SWI	XOS_WriteS
	DCB	"Device: IRQs:", 10, 13, 0
	ALIGN
	; Output info on each of the device numbers...
00	MOV	R0, R3
	MOV	R2, #8
	BL	NumPad
	SWI	XOS_Write0
	LDR	R0, [R4]
	ADD	R1, R12, #WSP_ScratchBuffer
	MOV	R2, #16
	SWI	XOS_ConvertCardinal4
	SWI	XOS_Write0
	SWI	XOS_NewLine
	MOV	R0, #0
	STR	R0, [R4], #4
	ADD	R3, R3, #1
	CMP	R3, #(?WSP_UnkIRQCount)/4
	BLO	%BT00
UnkExit	EXIT



; ****************************************************
; *
; * *RMDie <module title>
; *
; * Write zero into the specified module's header for the finalisation
; * code offset. Then, we can kill the module no matter what it was
; * going to do on finalisation.
; *
; * This is fairly risky as various resources (i.e. callbacks, RMA,
; * event handlers, etc) could still be claimed by the module, but the
; * space it occupies in RMA has now been freed.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R6	= corrupted
; *   R7-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
RMDie_Code Entry
	LDR	R12, [R12]
	SWI	XOS_WriteS
	DCB	"Forcing death of '", 0
	ALIGN
	; Check that the module isn't in ROM...
	BL	RM_Common
	BVS	%FT00
	; Blat the finalisation offset header word...
	MOV	R6, #0
	STR	R6, [R3, #8]
	; Kill the module...
	MOV	R1, R0
	MOV	R0, #ModHandReason_Delete
	SWI	XOS_Module
	SWI	XOS_WriteS
	DCB	"Module killed", 10, 13, 0
	ALIGN
00	; Exit...
	EXIT


; ****************************************************
; *
; * *RMRemove <module title>
; *
; * Replace all the module header words in the specified module with
; * zero, except the module title and help strings. These are made to
; * reference a small RMA block with a temporary module name in it
; * (so that you can RMKill the module later).
; *
; * Killing the module will cause an RMA leak of at least 16 bytes
; * (the small module title block), plus any system resources that
; * the module claimed and would have released on module finalisation.
; *
; * This is slightly less dangerous than using *RMDie.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R6	= corrupted
; *   R7-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
RMRemove_Code Entry
	LDR	R12, [R12]
	SWI	XOS_WriteS
	DCB	"Removing '", 0
	ALIGN
	; Check that the module isn't in ROM...
	BL	RM_Common
	BVS	%FT01
	; Blat the module header words...
	MOV	R6, #0
	ADD	R4, R3, #0x30
00	STR	R6, [R3], #4
	CMP	R3, R4
	BLO	%BT00
	; Claim a block of RMA...
	SUB	R1, R3, #0x30
	MOV	R0, #ModHandReason_Claim
	MOV	R3, #16
	SWI	XOS_Module
	BVS	%FT01
	; Store offsets into block in module header words...
	SUB	R0, R2, R1
	STR	R0, [R1, #0x10]
	STR	R0, [R1, #0x14]
	; Store 'Dead' at the start of the new title and help strings...
	LDR	R0, =0x64616544
	STR	R0, [R2]
	; Load and increment our dead module counter...
	LDR	R0, [R12, #WSP_DeadMods]
	ADD	R0, R0, #1
	STR	R0, [R12, #WSP_DeadMods]
	; Module title = 'Dead<number>'...
	ADD	R1, R2, #4
	MOV	R2, R12
	SWI	XOS_ConvertHex8
	; Output a success message...
	SWI	XOS_WriteS
	DCB	"Module removed", 10, 13, 0
	ALIGN
01	; Exit...
	EXIT

; ****************************************************
; *
; * Get some information about the specified module and generate an
; * error if that module is in the ROM.
; *
; * In...
; *   R0	= pointer to module title string
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= preserved
; *   R1	= module number
; *   R2	= instantiation number
; *   R3	= module code base address
; *   R4	= private word *value*
; *   R5	= postfix string
; *   R6-R12	= preserved
; *   R13	= preserved (or modified on error)
; *
RM_Common Entry "R0"
	SUB	R1, R0, #1
	; Output the module title...
00	LDRB	R14, [R1, #1]!
	CMP	R14, #" "
	BHI	%BT00
	SUB	R1, R1, R0
	SWI	XOS_WriteN
	SWI	XOS_WriteI+"'"
	; Look-up module info for this module title string...
	MOV	R1, R0
	MOV	R0, #ModHandReason_LookupName
	SWI	XOS_Module
	BVS	%FT01
	; Is it in the ROM...
	LDR	R0, [R12, #WSP_ROMBase]
	LDR	R5, [R12, #WSP_ROMTop]
	CMP	R3, R0
	SUBHSS	R0, R5, R3
	ADDHS	SP, SP, #8
	BHS	rommod_err
	; Output the module number...
	SWI	XOS_WriteS
	DCB	" (module ", 0
	ALIGN
	Push	"R1-R2"
	SUB	SP, SP, #12
	MOV	R0, R1
	MOV	R1, SP
	MOV	R2, #12
	SWI	XOS_ConvertCardinal4
	SWI	XOS_Write0
	ADD	SP, SP, #12
	Pull	"R1-R2"
	SWI	XOS_WriteS
	DCB	")", 10, 13, 0
	ALIGN
	EXIT
01	ADD	SP, SP, #4
	Pull	"PC"


	END
