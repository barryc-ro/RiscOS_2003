; s.Cmnds


; ****************************************************
; *
; * *Where [<address>]
; *
; * Output information about the specified address (or that of the last
; * abort).
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= preserved (or pointer to error block)
; *   R1-R2	= corrupted
; *   R3-R9	= preserved
; *   R10-R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
Where_Code Entry
	LDR	R12, [R12]
	CMP	R1, #1
	BHI	where_param_err
	BLO	%FT00
	MOV	R1, R0
	MOV	R0, #0x80000010
	SWI	XOS_ReadUnsigned
	BVS	where_param_err
	MOV	R0, #0
	MOV	R1, R2
	BL	SWI_Where
	EXIT
00	; Read the source address from the last exception's address...
	MOV	R0, #1
	BL	SWI_Where
	EXIT


; ****************************************************
; *
; * *Vectors
; *
; * List the contents of the software vectors.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted
; *   R1-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
Vectors_Code ROUT
	LDR	R12, [R12]
	CMP	R1, #1
	BHI	vector_param_err
	Entry
	BLO	%FT00
	MOV	R1, R0
	MOV	R4, R0	; Preserve string pointer in case of error
	MOV	R0, #0x80000010
	SWI	XOS_ReadUnsigned
	BVS	%FT01
	; The parameter was a vector number. Enumerate just this vector...
	MOV	R0, #1
	MOV	R1, R2
	BL	SWI_Vectors
	EXIT
00	; If no parameters were specified, enumerate all vectors...
	MOV	R0, #0
	BL	SWI_Vectors
	EXIT
01	; The parameter was a vector name. Look-up its number...
	MOV	R1, R4
	BL	Str_to_vector
	MOVVC	R0, #1
	BLVC	SWI_Vectors
	EXIT


; ****************************************************
; *
; * *Tickers
; *
; * List the contents of the Kernel's CallAfter and CallEvery list.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted
; *   R1-R9	= preserved
; *   R10-R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
Tickers_Code ROUT
	LDR	R12, [R12]
	B	SWI_Tickers


; ****************************************************
; *
; * *Devices
; *
; * List the contents of the Kernel device vectors.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted
; *   R1-R9	= preserved
; *   R10-R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
Devices_Code ROUT
	LDR	R12, [R12]
	B	SWI_Devices


; ****************************************************
; *
; * *X <CLI command>
; *
; * Execute the specified *command and place any error into the X$Error system
; * variable (if it is currently unset). Do not return the error.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R4	= corrupted
; *   R5-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
X_Code Entry
	; Execute the CLI command...
	SWI	XOS_CLI
	EXIT	VC
	; Read the X$Error system variable...
	ADD	R12, R0, #4
	ADR	R0, X_sys_var
	MOV	R1, R12
	MVN	R2, #0
	MOV	R3, #0
	MOV	R4, #0
	SWI	XOS_ReadVarVal
	; Exit if it is set to something...
	TEQ	R2, #0
	CMNNE	R2, #1
	EXIT	NE
	; Find the end of the error string...
	MOV	R0, R12
	MOV	R1, R0
00	LDRB	R2, [R0], #1
	TEQ	R2, #0
	BNE	%BT00
	; Set the X$Error variable to the error message...
	SUB	R2, R0, R1
	ADR	R0, X_sys_var
	MOV	R3, #0
	MOV	R4, #0
	SWI	XOS_SetVarVal
	EXIT
X_sys_var
	DCB	"X$Error", 0
	ALIGN


; ****************************************************
; *
; * *Canonical <sys var> <file spec>
; *
; * Canonicalise the specified filename and place the result in a system variable.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R5	= corrupted
; *   R6-R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
Canonical_Code Entry
	MOV	R4, R0		; Preserve R0 (CLI str) in R4
	; Claim RMA block for the resultant string...
	MOV	R0, #ModHandReason_Claim
	MOV	R3, #4096
	SWI	XOS_Module
	EXIT	VS
	MOV	R12, R2		; Preserve R2 (RMA) in R12
	; Parse the parameters to this utility
	ADR	R0, canonical_synstr
	MOV	R1, R4		; Restore R0 into R1
	SWI	XOS_ReadArgs
	BVS	canonical_param_err
	LDMIA	R12, {R0, R1}
	TEQ	R0, #0
	TEQNE	R1, #0
	BEQ	canonical_param_err
	; Canonicalise the path
	MOV	R0, #FSControl_CanonicalisePath
	MOV	R2, R1
	MOV	R3, #0
	MOV	R4, #0
	MOV	R5, #2048
	SWI	XOS_FSControl
	BVS	canonical_err_exit
	; R5 - bytes free (in 2048 byte buffer)
	;
	; Place the result into a system variable
	LDR	R0, [R12]
	RSB	R2, R5, #2048	; Calculate length of string
	MOV	R3, #0
	MOV	R4, #0
	SWI	XOS_SetVarVal
	BVS	canonical_err_exit
	; Free our RMA block (return possible error)
	MOV	R0, #ModHandReason_Free
	MOV	R2, R12
	SWI	XOS_Module
	EXIT
canonical_err_exit
	MOV	R3, R0
	MOV	R0, #ModHandReason_Free
	MOV	R2, R12
	SWI	XOS_Module
	MOV	R0, R3
	SETV
	EXIT
canonical_synstr
	DCB	"var,file", 0
	ALIGN


; ****************************************************
; *
; * *IRQInfo [<IRQ device number>]
; *
; * Output information on how many times each device was called in the last
; * second and what percentage of the CPU time the device driver consumed.
; *
; * In...
; *   R0	= pointer to parameter string
; *   R1	= number of parameters
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R5	= corrupted
; *   R6-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
IRQInfo_Code Entry "R10"
	; Dereference our private word pointer...
	LDR	R12, [R12]

	; Output a title banner...
	SWI	XOS_WriteS
	DCB	"Device: Calls:      CPU Use:", 10, 13, 0
	ALIGN

	; Enumerate all of the IRQs 0-15...
	ADD	R3, R12, #WSP_IRQinfo
	MOV	R0, #0
	MOV	R10, #OS_ConvertCardinal4
	ORR	R10, R10, #0x20000
00	LDMIA	R3 !, {R4-R5}
	Push	"R0"
	; Output the IRQ number with padding...
	MOV	R2, #8
	BL	NumPad
	SWI	XOS_Write0
	; Output the number of calls with padding...
	MOV	R0, R5
	MOV	R2, #12
	BL	NumPad
	SWI	XOS_Write0
	; Output the cycles as a percentage of CPU usage...
	BL	CPUPcnt
	SWI	XOS_NewLine
	; Move on to the next IRQ...
	Pull	"R0"
	ADD	R0, R0, #1
	CMP	R0, #32
	BLO	%BT00

	; Output the info for the other IRQs...
	LDMIA	R3, {R4-R5}
	SWI	XOS_WriteS
	DCB	"32+     ", 0
	ALIGN
	MOV	R0, R5
	BL	NumPad
	SWI	XOS_Write0
	BL	CPUPcnt
	SWI	XOS_NewLine
	EXIT


; ****************************************************
; *
; * *UnknownIRQs
; *
; * Output a dump of our count of how many times we have seen each device
; * pass along IrqV since the last call to this *command. Reset all counters
; * to zero after reading them.
; *
; * In...
; *   R12	= private word pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R4	= corrupted
; *   R5-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   V flag	= set if R0 is a pointer to an error block
; *
UnknownIRQs_Code Entry "R10"
	LDR	R12, [R12]
	; Ensure that we managed to claim IrqV...
	LDR	R0, [R12, #WSP_IRQtable]
	CMP	R0, #0
	BEQ	UnkExit
	; Initialise some registers...
	MOV	R10, #OS_ConvertCardinal4
	ORR	R10, R10, #0x20000
	MOV	R3, #0
	ADD	R4, R12, #WSP_UnkIRQCount
	; R3  = device number
	; R4  = pointer to base of table
	; R10 = conversion SWI number

	; Output a heading...
	SWI	XOS_WriteS
	DCB	"Device: IRQs:", 10, 13, 0
	ALIGN
	; Output info on each of the device numbers...
00	MOV	R0, R3
	MOV	R2, #8
	BL	NumPad
	SWI	XOS_Write0
	LDR	R0, [R4]
	ADD	R1, R12, #WSP_ScratchBuffer
	MOV	R2, #16
	SWI	XOS_ConvertCardinal4
	SWI	XOS_Write0
	SWI	XOS_NewLine
	MOV	R0, #0
	STR	R0, [R4], #4
	ADD	R3, R3, #1
	CMP	R3, #(?WSP_UnkIRQCount)/4
	BLO	%BT00
UnkExit	EXIT


	END
