        TTL     > <wini>arm.Debugger.Debugger - ARM/Arthur debugger (principally for machine code)

; Authors:      Roger Wilson (Brazil version)
;               Andrew F. Powis (Arthur version)
;               Stuart K. Swales (Arthur fixes/enhancements)
;               Tim Dobson (Adjusting headers, ARM600 variant)
;               Alan Glover (fixes/enhancements, ARM6/ARM7 instructions)
;		William Turner (StrongARM compatibility)
;		Kevin Bracey (Architecture 4 instructions)

; 1.18  SKS     Fixed disassembly of #xx,yy operands
; 1.19  SKS     Fixed disassembly of LSR #32, ASR #32
;               Comment where LDR pc relative comes from
; 1.20  SKS     Fixed fp/coproc disassembly, memoryi/memorya parameters
; 1.21  SKS     Fixed *debug response wrt ESCape
; 1.22  SKS     Fixed memory wrt wrapping at 64M

; ---- Released for Arthur 2.00 ----

; 1.22  TMD 22-Nov-89    Fixed source to assemble again with new headers,
;                        and with new AAsm which objects to DCD rel.sym.
;                        (shouldn't affect object file)
;
; 1.23  AMG 30-Oct-90    Various fixes/enhancements
;                        1. ADR made from ADD/SUB Rn,R15,#nn
;                        2. SWP/SWPB now recognised, with >ARM2 warning
;                        3. LDR/STR and LDF/STF now decode PC relative addressing
;                           in the instruction, not the comment field
;                        4. MRC/MCR to CP15 (ie ARM3 control) are commented
;                        5. Comment position moved in for longer comments
;                        6. Silly code detection and indication added...
;                           a) NV condition code
;                           b) SWI following a CDP
;                           c) MUL Rx,Rx or MUL R15,Rx
;                           d) LDM/STM with ^ and !
;                           e) LDM with ^ - bank switches
;                           f) Use of R8-R14 after a xxxP instruction
; 1.24  ENevill ??-Mar-91
;                        Text extraction, untested I think - AMG
;
; 1.25  AMG 11-Mar-91    Fixed disassembly of ADD rd,R15,rm as an ADR
;                        Change OS_Confirm usage to use EQ flag, not ASCII Y
;
; **** Version 1.24 and 1.25 have not been tested, though the bug fix
;      in 1.25 has been checked using 1.23's source.
;
; 1.26  AMG 12-Mar-91    Altered wacky shift coding to give
;                        ADD R0,R0,#0,ROR #24 instead of
;                        ADD R0,R0,#0,24 which confuses people
;
; **** This version is also untested, but changes made have been checked
;      with 1.23's source again
;
; 1.27  ECN 15-Mar-91    Internationalised
; 1.27  ECN 08-Apr-91    Fixed logic of MCR/MRC disassembly.
;                        Bit 20 = 0 => MCR, = 1 => MRC
;                        Internal ARM datasheet is wrong wrt MCR/MRC
;                        VLSI datasheet and assemblers are correct
; 1.27  ECN 19-Apr-91    Fixed "Enter new value" message in MemoryA

; 1.28  AMG 25-Apr-91    Corrected 'use ! and ^' message in messages file.
;                        Added BadSWI error for unused SWIs and associated
;                          message
;
; 1.29  AMG 10-May-91    Used mask &FC000000 instead of &FC000003 to force
;                        LDR/STR into addressing range since it was
;                          messing up LDRB R0,[PC,#1] disassembly
;
; 1.30  AMG 23-May-91    Use global Bad SWI message.
;                        Sort out Message Token not found for bad syntax
;                          to MEMORYI & MEMORY
;
; 1.31  amg 31-May-91    Change invalid instruction used by InitStore to
;                          &E6000010 - which is still invalid - the old
;                          one, &E1000090, is now a SWP instruction!
;                        Added new FPA  URD and NRM instructions
;
; 1.32  amg 05-Jun-91    Added new FPA  LFM/SFM instructions. While in that
;                          area also fixed a bug where coproc offsets were
;                          treated as a 12 bit number, not an 8 bit one.
;
; 1.33  amg 21-Jun-91    Bugfix: Use Global copy of 'Escape' error message
;
; 1.34  amg 18-Jul-91    Tidy up internationalisation to save some space.
;
; 1.36  ECN 07-Aug-91    Inserted NOP after LDM forcing user bank followed
;                        by access to banked register.
;
; 1.37  amg 26-Nov-91    RP-0512 (hang accessing &3000000 - empty IO slot)
;                        Add address validation as below
;                        &0000000-&1ffffff - Use OS_ValidateAddress
;                        &2000000-&2ffffff - No checks (always present)
;                        &3000000-&33fffff - No access (I/O areas)
;                        &3400000-&3ffffff - Read access only (ROMs)
;                                              (writes=VIDC or MEMC)
;                        MEMORYA will trap interactive mode going into
;                        a read-only/no access area too.
;
; 1.38  amg 24-Jan-92    Repaired non-interactive MEMORYA (RP-0970)
;
; 1.39  amg 13-Apr-92    Revert fix of Rp-0512 to a switchable flag,
;                        off by default

; ---- Released for RISC OS 3.10 ----

; 1.40  TMD 27-Jul-92    Added variant for ARM600 which doesn't wrap
;                        addresses at 64M
;
; 1.41  ECN 10-Aug-93    Internationalised help/syntax messages
;
; 1.42  TMD 27-Oct-93    Fixed bug MED-00167 - coprocessor data transfers to
;                        PC-relative address were disassembled wrong.
; 1.43  TMD 01-Dec-93    Fixed bug MED-01490 - couldn't set breakpoints
;                         above 32MB (eg in RMA!).
; 1.44  amg 23-Jan-94    Catch up on new ARM6/7 opcodes: MRS, MSR, MULL, MLAL and
;                         check conformance with FPA10 spec. Tighten up tests
;                         for MUL/MULL/SWP - now insist b7:b4=2_1001
;                        Add national switch to override internationalised help/syntax
; 1.46  WT  07-Feb-96    Made StrongARM compatible (breakpoint code breaks IDcache)
; 1.48  KJB 04-Jun-96    Added ARMv4 instructions (BX, LDR[H|SH|SB], STRH)
;                        SWP wasn't being disassembled
;			 CP15 comments amended to ARMv4
;			 ARM3 warning removed from SWP (after all, MRS,
;			 MULL etc don't have warnings!)
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:EnvNumbers
        GET     Hdr:Proc
        GET     Hdr:VduExt
        GET     Hdr:Tokens
        GET     Hdr:MsgTrans

        GET     Hdr:Debugger

        GET     Version

        GET     Hdr:Debug

        GBLL    debug
debug   SETL    False
;debug   SETL    True

        GBLL    rp0512
rp0512  SETL    False ;False = do not implement RP0512 bug fix coding

        GBLL    Addr26
Addr26  SETL    CPU_Type <> "ARM600" ; true for 26 bit wrap on addresses

        GBLL    national
national SETL   False

	GBLL	StrongARM
StrongARM SETL  True

; Continue not up to much

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Debug global workspace

                ^       0, wp

; Breakpoint code section - keep layout same as RelocatedCode section

nbreakpoints    *       16

BreakCodeStart  #       nbreakpoints*8  ; Breakpoint entry code segments
                #       4*5             ; Save other registers before JMP
BreakCodeEnd    #       0               ; End of copied area

; Areas accessed pc relative by relocated breakpoint code

TrapStore       #       4               ; Store for breakpoint id
Registers       #       4*16            ; Register dump area
pc_register     *       Registers + 4*15 ; dumped pc
r12Store        #       4               ; r12 for breakpoint code
JumpStore       #       4               ; address of breakpoint code in ROM

Breaklist       #       nbreakpoints*8  ; List of addresses, old data

OldExceptionDumpArea #  4               ; Old exception register dump area

WindowWidth     #       4
BytesPerLine    #       4

Mistake         #       4               ;potential error number

OldAddress      #       4               ;address of last instruction

MessageFile_Block #     16              ; File handle for MessageTrans
MessageFile_Open  #     4               ; Opened message file flag

StringBuffer    #       88              ; Temp string buffer. Big enough to
                                        ; hold a disassembled instruction
                                        ; and a full register set + two instrs
TotalSpace      *       :INDEX: @


; Overlaid workspace

 [ StrongARM
ExeBufLen	*	4+4+4*16
 ]

                ^       :INDEX: StringBuffer, wp
CoreBuffer      #       16              ; Enough for a line of bytes
 ASSERT ?StringBuffer >= ?CoreBuffer

                ^       :INDEX: StringBuffer, wp
 [ StrongARM
ExecuteBuffer   #       ExeBufLen
 |
ExecuteBuffer   #       4+4+4*16
 ]
 ASSERT ?StringBuffer >= ?ExecuteBuffer

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Useful constants

TAB     *       9
LF      *       10
CR      *       13
space   *       " "
quote   *       """"
colon   *       ":"
delete  *       &7F

ARM_Addr_Mask * &FC000000 ; local mask to avoid knocking off byte offsets

        LEADR   Module_LoadAddr

Module_BaseAddr

        DCD     0
        DCD     Debug_Init - Module_BaseAddr
        DCD     Debug_Die - Module_BaseAddr
        DCD     Debug_Service - Module_BaseAddr
        DCD     Debug_Title - Module_BaseAddr
        DCD     Debug_HelpStr - Module_BaseAddr
        DCD     Debug_HC_Table - Module_BaseAddr
        DCD     Module_SWISystemBase + DebuggerSWI * Module_SWIChunkSize
        DCD     Debug_SWI_Code - Module_BaseAddr
        DCD     Debug_SWI_Name - Module_BaseAddr
        DCD     0
 [ International_Help <> 0
        DCD     message_filename - Module_BaseAddr
 |
        DCD     0
 ]

Debug_Title ; share with
Debug_SWI_Name
        DCB     "Debugger", 0           ; SWI class
        DCB     "Disassemble", 0        ; +0
        DCB     0

Debug_HelpStr
        DCB     "Debugger", TAB, "$Version ($CurrentDate)", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Debug_Init ENTRY

        LDR     r2, [r12]               ; Hard or soft init ?
        TEQ     r2, #0
        BNE     %FT00

; Hard init

        LDR     r3, =TotalSpace         ; Claim module workspace
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        EXIT    VS                      ; 'No room' good enough error

        STR     r2, [r12]

00      MOV     wp, r2


        ADRL    r0, RelocatedCodeStart  ; fwd ref
        MOV     r3, #BreakCodeEnd - BreakCodeStart
01      SUBS    r3, r3, #4              ; Move breakpoint code to RAM
        LDRPL   r1, [r0, r3]
        STRPL   r1, [r2, r3]
        BPL     %BT01

 [ StrongARM
	MOV	r0, #1
	MOV	r1, r2
	ADD	r2, r1, #(nbreakpoints*8)
	SWI	XOS_SynchroniseCodeAreas
 ]

        ADRL    r14, BreakTrap          ; Address of breakpoint code in ROM
        STR     r14, JumpStore          ; fwd ref
        STR     wp, r12Store            ; A good idea to initialise it

        ADR     r1, Breaklist           ; Clear breakpoint list
        MOV     r3, #nbreakpoints
        MOV     r14, #-1
10      STR     r14, [r1], #8           ; Only need to zap address field
        SUBS    r3, r3, #1
        BNE     %BT10

        ADR     r1, Registers           ; Clear register dump area
        MOV     r3, #16
        MOV     r14, #0
        STR     r14, MessageFile_Open
20      STR     r14, [r1], #4
        SUBS    r3, r3, #1
        BNE     %BT20

        MOV     r0, #ExceptionDumpArea  ; Change exception register dump area
        ADR     r1, Registers
        SWI     XOS_ChangeEnvironment
        STRVC   r1, OldExceptionDumpArea

        MOV     r3, #0
        STR     R3, Mistake
        STR     R3, OldAddress          ;Init vars for dodgy code detection
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    no registers trashable

        ALIGN

Debug_Service ROUT

        TEQ     r1, #Service_Reset
        MOVNE   pc, lr

        ENTRY   "r0, r1"
        LDR     wp, [r12]
        MOV     r0, #ExceptionDumpArea          ; Set exception dump area
        ADR     r1, Registers
        SWI     XOS_ChangeEnvironment
        STRVC   r1, OldExceptionDumpArea
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Debug_Die ENTRY

        LDR     wp, [r12]

        BL      SwapAllBreakpoints      ; Be nice

        MOV     r0, #ExceptionDumpArea  ; Restore old exception dump area
        MOV     r1, #0                  ; if current one is us
        SWI     XOS_ChangeEnvironment
        ADR     r14, Registers
        CMP     r14, r1
        MOVEQ   r0, #ExceptionDumpArea
        LDREQ   r1, OldExceptionDumpArea
        SWIEQ   XOS_ChangeEnvironment
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        ADRNE   r0, MessageFile_Block
        SWINE   XMessageTrans_CloseFile

        EXITS                           ; Don't refuse to die

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;                        (No. of Parameters)

Debug_HC_Table ; Name       Max  Min

        [ national
        Command BreakClr,    1,   0,
        Command BreakList,   0,   0,
        Command BreakSet,    1,   1,
        Command Continue,    0,   0,
        Command Debug,       0,   0,
        Command InitStore,   1,   0,
        Command Memory,      4,   1,; B R + R
        Command MemoryA,     3,   1,; B R V
        Command MemoryI,     5,   1,; A +/- B + C
        Command ShowRegs,    0,   0,
        |
        Command BreakClr,    1,   0, International_Help
        Command BreakList,   0,   0, International_Help
        Command BreakSet,    1,   1, International_Help
        Command Continue,    0,   0, International_Help
        Command Debug,       0,   0, International_Help
        Command InitStore,   1,   0, International_Help
        Command Memory,      4,   1, International_Help     ; B R + R
        Command MemoryA,     3,   1, International_Help     ; B R V
        Command MemoryI,     5,   1, International_Help     ; A +/- B + C
        Command ShowRegs,    0,   0, International_Help
        ]

        DCB     0                       ; end of table

        GET     TokHelpSrc
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = instruction to disassemble
;       r1 = address to disassemble relative to (bug in 1.00 debug did relative
;                                                to module base only !)

; Out   r1 -> core containing string
;       r2 = length of string including 0

Debug_SWI_Code ENTRY "r9"

        LDR     wp, [r12]
        TEQ     R11,#0 ;only one SWI
        BEQ     swi00

        ADR     R0,ErrorBlock_ModuleBadSWI
        BL      CopyErrorP1

        EXIT

        MakeInternatErrorBlock ModuleBadSWI,,BadSWI

swi00
        LDR     R14,Mistake

        CMP     R14,#-3            ;potential error if a banked access occurs (after LDM)
        MOVEQ   R14,#-2
        CMP     R14,#-4            ;potential error if a SWI occurs (after coproc)
        MOVEQ   R14,#-1

        STR     R14,Mistake

        MOV     R9, R1
        BL      Instruction

        LDR     R14,Mistake

        CMP     R14,#-2
        CMPNE   R14,#-1
        MOVEQ   R14,#0

        STREQ   R14,Mistake

        EXIT                           ; Preserve flags

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkreg
        STMFD   R13!,{R14}
        LDR     R14,Mistake
        CMP     R14,#-2
        MOVEQ   R14,#3
        STR     R14,Mistake
        LDMFD   R13!,{R15}


; In    r0 = instruction to disassemble
;       r9 = where it is

; Out   r1 -> core containing string
;       r2 = length of string including 0
;       r10,r11 corrupt

Instruction ENTRY "r0, r3-r9"

        SUB     R4, R9, #4
        LDR     R5, OldAddress
        CMP     R4, R5
        MOV     R4, #0
        STRNE   R4, Mistake         ;not going in sequence, so forget context
        STR     R9, OldAddress      ;save for next time

        MOV     r4, r0

        ADR     r0, StringBuffer        ; Always build into temp buffer

 [ debug :LAND: True
        MOV     r14, #0                 ; zap buffer
        MOV     r3, #?StringBuffer-4
00      STR     r14, [r0, r3]
        SUBS    r3, r3, #4
        BPL     %BT00
 ]

        MOV     r3, r4, LSR #24         ; r3 := primary instruction nibble
        AND     r3, r3, #2_00001111     ; remove condition codes
        CMP     r3, #&0F
        BEQ     Swi                     ; [software interrupt = 0F]

        CMP     r3, #&0C
        BHS     Coprocessor             ; [coproc 0C..0E]

        CMP     r3, #&0A
        BEQ     Branch
        BHI     BranchLink

        CMP     r3, #&08
        BHS     LdmStm                  ; [load/store multiple = 08,09]

        CMP     r3, #&04
        BHS     LdrStr                  ; [load/store register = 04..07]

        B       DataProcessing          ; [data processing = 00.03]

; .............................................................................

Undefined
        ADR     r10, Unknown
        BL      lookup_r10

; .............................................................................
; In    r0 -> buffer to be terminated. registers stacked as for entry
;       r10 -> string to be appended first

SaveStringEnd

        BL      SaveString

; .............................................................................
; In    r0 -> buffer to be terminated. registers stacked as for entry

; Out   r1 -> completed buffer
;       r2 = length of buffer

InstructionEnd

        BL      TestMistakes

        MOV     r14, #0
        STRB    r14, [r0]

        ADR     r1, StringBuffer
        SUBS    r2, r0, r1              ; VClear
        EXIT


Unknown DCB     "M00", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Software interrupt

Swi     LDR     R10, Mistake
        CMP     R10, #-1
        MOVEQ   R10, #4
        STREQ   R10, Mistake

        BL      checkreg

        ADR     r10, Swi_Instruction
        BL      SaveStringConditions

        BL      Tab

        MOV     r1, r0
        ADR     r2, StringBuffer+?StringBuffer
        SUB     r2, r2, r1
        BIC     r0, r4, #&FF000000      ; Mask out SWI<cc>
        SWI     XOS_SWINumberToString   ; This may give error (eg. Buffer over)

        SUBVC   R2,R2,#1                ;adjust to avoid taking the zero byte
        ADDVC   r0, r1, r2
        B       InstructionEnd


Swi_Instruction
        DCB     "SWI", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Branch, Branch and Link

Branch ROUT

        MOV     r2, #"B"
        B       %FT50

BranchLink

        BL      checkreg
        MOV     r2, #"B"
        STRB    r2, [r0], #1
        MOV     r2, #"L"

50      STRB    r2, [r0], #1

        BL      Conditions

        BL      Tab

 [ Addr26
        ADD     r8, r9, r4, LSL #2      ; Form offset from required address
 |
        MOV     r8, r4, LSL #8          ; shift offset up to top
        ADD     r8, r9, r8, ASR #6      ; convert to signed offset and add
 ]

BranchLdrStrCommon
        ADD     r8, r8, #8              ; pc advanced by 8
 [ Addr26
        BIC     r8, r8, #ARM_Addr_Mask    ; Wrap in 64MByte space
 ]
        MOV     r2, #32-4                 ; (keeping byte offsets)
        BL      StoreHex

        B       InstructionEnd

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Load and store multiple

Ldm     DCB     "LDM", 0
Stm     DCB     "STM", 0
W_Back  DCB     "!,{", 0
        ALIGN


LdmStm ROUT

        ANDS    R5, R4, #&7F00
        BLNE    checkreg        ;error if R8-R14 in list

        ;test for silly conditions - ldm/stm ! and ^ with R15 not in list is bad,
        ;and LDM ^ with R15 not in the list is a deferred bank error

        TST     R4, #1 :SHL: 15
        BNE     notbad ;R15 in list

        TST     R4, #1 :SHL: 22
        BEQ     notbad ;not forcing user

        ;case 1 - ! too
        TST     R4, #1 :SHL: 21
        MOVNE   R10, #2
        STRNE   R10, Mistake
        BNE     notbad ;don"t bother with next test

        ;case 2 - LDM
        TST     R4, #1 :SHL: 20
        MOVNE   R10,#-3
        STRNE   R10,Mistake

notbad
        TST     r4, #1 :SHL: 20         ; Load/~Store bit
        ADRNE   r10, Ldm
        ADREQ   r10, Stm
        BL      SaveStringConditions

        TST     r4, #1 :SHL: 23         ; Up/~Down bit
        MOVEQ   r10, #"D"
        MOVNE   r10, #"I"
        STRB    r10, [r0], #1

        TST     r4, #1 :SHL: 24         ; Pre/~Post bit
        MOVEQ   r10, #"A"
        MOVNE   r10, #"B"
        STRB    r10, [r0], #1

        MOV     r5, r4, LSR #16         ; Rn
        CMP     R5, #15
        CMPNE   R5, #8
        BLHI    checkreg                ;error if R8-R14
        BL      Tab_Dis_Register

        TST     r4, #1 :SHL: 21         ; Writeback bit
        ADR     r10, W_Back
        ADDEQ   r10, r10, #1            ; just do ',{'
        BL      SaveString

; Register list

        MOV     r5, #0
        MOV     r8, #0

RegList ADD     r2, r5, #1
        TST     r2, r4, LSR r2
        BCC     Next

        TEQ     r8, #0
        BLNE    AddComma

        BL      Dis_Register
        ADD     r5, r5, #1
        CMP     r5, #16
        BEQ     Xxm_End

        ADD     r2, r5, #1
        TST     r2, r4, LSR r2
        MOV     r8, #1
        BCC     Next                    ; If next reg not done, loop

Count   ADD     r8, r8, #1
        ADD     r5, r5, #1              ; Count registers
        CMP     r5, #16
        BEQ     Group

        ADD     r2, r5, #1
        TST     r2, r4, LSR r2
        BCS     Count

; Group or single register

Group   MOV     r6, #","
        CMP     r8, #3
        MOVCS   r6, #"-"
        STRB    r6, [r0], #1

        SUB     r5, r5, #1
        BL      Dis_Register

Next    ADD     r5, r5, #1
        CMP     r5, #16
        BNE     RegList


Xxm_End MOV     r10, #"}"               ; end register list
        STRB    r10, [r0], #1

        TST     r4, #1 :SHL:  22        ; '^' bit
        MOVNE   r10, #"^"
        STRNEB  r10, [r0], #1

        B       InstructionEnd

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Load or store register


LdrStr ROUT

        TST     r4, #1 :SHL: 25         ; If Rm and shift and trying Rs
        TSTNE   r4, #1 :SHL: 4          ; then that was xxR Rd,[Rn,Rm,SHF Rs]
        BNE     Undefined               ; but ARM2 doesn't do that anymore

        TST     r4, #1 :SHL: 20         ; Load/~Store bit
        ADRNE   r10, Ldr
        ADREQ   r10, Str
        BL      SaveStringConditions

        TST     r4, #1 :SHL: 22         ; Byte/~Word bit
        MOVNE   r10, #"B"
        STRNEB  r10, [r0], #1

        AND     r10, r4, #2_1001 :SHL: 21
        CMP     r10,     #2_0001 :SHL: 21 ; postincrement with writeback ?
        MOVEQ   r10, #"T"               ; -> T(ranslate)
        STREQB  r10, [r0], #1

        MOV     r5, r4, LSR #12         ; Rd
        BL      Tab_Dis_Register


DataTransfer_Common ; for CPDT - address part similar to LDR/STR (no reg index)

        ;from 1.23, show resultant LDR/STR Rx,[R15,#nnn] address directly

        MOV     R5,R4,LSR #16
        AND     R5,R5,#15
        CMP     R5,#15

        TSTEQ   R4,#1 :SHL: 25

        MOVEQ   R5,#","
        STREQB  R5,[R0],#1
        MOVEQ   R8,R4,LSL #32-12
        MOVEQ   R8,R8,LSR #32-12
        BNE     not_rel

 [ {TRUE} ; TMD 27-Oct-93 - fix MED-00167

; offset in LDC/STC instructions is a word offset

        TST     r4, #1 :SHL: 27         ; if a coproc data transfer
        MOVNE   r8, r8, LSL #2          ; then multiply offset by 4
 ]

        TST     r4, #1 :SHL: 23         ; Up/~Down bit
        SUBEQ   r8, r9, r8              ; Form offset from required address
        ADDNE   r8, r9, r8

        B       BranchLdrStrCommon

not_rel
        ADR     r10, Open_B             ; ',['
        BL      SaveString

        MOV     r5, r4, LSR #16         ; Rn
        BL      Dis_Register

        TST     r4, #1 :SHL: 24         ; Pre/~Post bit
        ADR     r10, Close_B
        ADDNE   r10, r10, #1            ; just ',' else '],'
        BL      SaveString

        TST     r4, #1 :SHL: 25         ; Shift/~Immediate bit
        BNE     %FT90

; Immediate offset

        MOV     r6, #"#"
        STRB    r6, [r0], #1

        TST     r4, #1 :SHL: 23         ; Up/~Down bit
        MOVEQ   r6, #"-"
        STREQB  r6, [r0], #1            ; -ve index

        MOV     r8, r4, LSL #32-12
        MOV     r8, r8, LSR #32-12      ; r4 & 0x0FFF
        AND     r6, r4, #&0C000000
        CMP     r6,     #&0C000000
        ANDEQ   r8, r8, #&FF            ; smaller offset if coproc (1.32)
        MOVEQ   r8, r8, LSL #2          ; Word offset if coprocessor
        BL      StoreDecimal

        AND     r5, r5, #&0F
        CMP     r5, #&0F                ; If [pc, #xxx] then comment it
        MOVNE   r8, #-1
        BNE     %FT80

        TST     r4, #1 :SHL: 24         ; Pre/~Post bit
        MOVEQ   r8, #-1
        BEQ     %FT80                   ; [postincrement, so wacky]

        TST     r4, #1 :SHL: 23         ; Up/~Down bit
        SUBEQ   r8, r9, r8              ; Form offset from required address
        ADDNE   r8, r9, r8


80      TST     r4, #1 :SHL: 24         ; Pre/~Post bit
        MOVNE   r10, #"]"
        STRNEB  r10, [r0], #1           ; [preincrement, so close]

        AND     r10, r4, #2_1001 :SHL: 21
        CMP     r10,     #2_1001 :SHL: 21 ; preincrement with writeback ?
        MOVEQ   r10, #"!"
        STREQB  r10, [r0], #1

        CMP     r8, #-1
        BEQ     InstructionEnd

        BL      Tab                     ; Will also insert '; '

        B       BranchLdrStrCommon



; Register offset

90      TST     r4, #1 :SHL: 23         ; Up/~Down bit
        MOVEQ   r10, #"-"
        STREQB  r10, [r0], #1           ; -ve index

        MOV     r5, r4                  ; Rm
        BL      Dis_Register

        BL      ShiftField

        MOV     r8, #-1
        B       %BT80

Ldr     DCB     "LDR", 0
Str     DCB     "STR", 0
Open_B  DCB     ",[", 0
Close_B DCB     "],", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Multiply + Multiply-with-Accumulate

Mul     DCB     "MUL", 0
Mla     DCB     "MLA", 0
        ALIGN

UndefinedDataProcessing ROUT

        AND     R10,R4,#&F0             ; forcible check for &xxxxxx9x
        CMP     R10,#&90
        BNE	LdrStrH

        MOV     R5,R4,LSR #23
        AND     R5,R5,#&1F
                                        ; vvv - tested
        TST     r4, #&38 :SHL: 22       ; 0000 00AS dddd nnnn ssss 1001 mmmm ?
        BNE     Undefined               ; test was &3F - changed to allow SWP,MULL,MLAL through

        CMP     R5,#2_00001
        BEQ     mul_long

        CMP     R5,#2_00010
        BEQ     swp

; MUL/MLA

        TST     r4, #1 :SHL: 21         ; Accumulate bit
        ADREQ   r10, Mul
        ADRNE   r10, Mla
        BL      SaveStringConditions

        TST     r4, #1 :SHL: 20         ; Update flags bit
        MOVNE   r10, #"S"
        STRNEB  r10, [r0], #1

        MOV     r5, r4, LSR #16         ; Rd
        BL      Tab_Dis_Register

        MOV     r5, r4                  ; Rm
        AND     R5,R5,#15
        MOV     R10, R4, LSR #16
        AND     R10,R10,#15
        CMP     R10,R5
        CMPNE   R10,#15
        MOVEQ   R14,#5
        STREQ   R14,Mistake

        BL      Comma_Dis_Register

        MOV     r5, r4, LSR #8          ; Rs
        BL      Comma_Dis_Register

        TST     r4, #1 :SHL: 21         ; MLA has extra operand
        MOVNE   r5, r4, LSR #12         ; Rn
        BLNE    Comma_Dis_Register

        B       InstructionEnd

mul_long
        ;deal with signed/unsigned
        TST     R4, #1 :SHL: 22
        MOVNE   R10, #"S"
        MOVEQ   R10, #"U"
        STRB    R10, [R0], #1

        TST     r4, #1 :SHL: 21         ; Accumulate bit

        ;note: the accumulate works differently here to MUL/MLA
        ;on an accumulating multiply you get Rd+=Rm * Rs, otherwise
        ;you get Rd==Rm * Rs, so wheras MLA uses one more register
        ;than MUL both MULL/MLAL use four registers.

        ADREQ   r10, Mull
        ADRNE   r10, Mlal
        BL      SaveStringConditions

        TST     r4, #1 :SHL: 20         ; Update flags bit
        MOVNE   r10, #"S"
        STRNEB  r10, [r0], #1

        MOV     r5, r4, LSR #12         ; RdLo
        BL      Tab_Dis_Register

        MOV     r5, r4, LSR #16         ; RdHi
        BL      Comma_Dis_Register

        MOV     r5, r4                  ; Rm
        BL      Comma_Dis_Register

        MOV     r5, r4, LSR #8          ; Rs
        BL      Comma_Dis_Register

        B       InstructionEnd

aswp    DCB     "SWP",0
Mull    DCB     "MULL",0
Mlal    DCB     "MLAL",0
        ALIGN

swp     AND     R5,R4,#&F90
        CMP     R5,#&90
        BNE     Undefined               ;it is SWP, ie cond00010b00nnnndddd00001001mmmm

        ADR     R10,aswp
        BL      SaveStringConditions
        ANDS    R5,R4,#1 :SHL: 22
        MOVNE   R10,#"B"
        STRNEB  R10,[R0],#1
        MOV     R5,R4,LSR #12
        BL      Tab_Dis_Register
        MOV     R5,R4
        BL      Comma_Dis_Register
        ADR     R10,Open_B
        BL      SaveString
        MOV     R5,R4,LSR #16
        BL      Dis_Register
        MOV     R10,#"]"
        STRB    R10,[R0],#1
	[ {FALSE}
        BL      Tab
        ADR     R10,arm3only
        BL      lookup_r10
        BL      SaveString
	]
        B       InstructionEnd

LdrStrH	; Load and Store Halfword or Load Signed Byte
	; arrive here with cccc 000x xxxx xxxx xxxx xxxx 1nn1 xxxx
	; (nn != 00)
	; format is        cccc 000p uiwl nnnn dddd aaaa 1sh1 bbbb
	;
	; {LDRH|LDRSH|LDRSB|STRH} Rd,[Rn,{#offset|Rm}]
	;                         Rd,[Rn,{#offset|Rm}]!
	;                         Rd,[Rn],{#offset|Rm}
	; where cccc = condition
	;	   p = Pre-indexed/~Post-indexed
	;	   u = Up/~Down
	;	   i = Immediate/~Register offset
	;	   w = Writeback
	;          l = Load/~Store
	;       nnnn = Rn
	;       dddd = Rd
	;       aaaa = immediate offset high nibble (if i==1), else 0
	;          s = Signed/~Unsigned halfword
	;	   h = Halfword/~Signed byte
	;	bbbb = immediate offset low nibble (if i==1), else Rm

	; cccc 000x x0xx xxxx xxxx nnnn 1xx1 xxx is undefined if any of
	; nnnn are 1.
	TSTS	r4, #1:SHL:22		; Immediate/~Register offset
	BNE	%F5
	TSTS	r4, #&00000F00
	BNE	Undefined
	; Can only have STRH, not STRSH or STRSB
5	TSTS	r4, #1:SHL:20		; Load/~Store
	BNE	%F20
	AND	r5, r4, #&000000F0
	TEQS	r5, #&000000B0
	BNE	Undefined

20	TSTS	r4, #1:SHL:20
	ADRNE	r10, Ldr
	ADREQ	r10, Str
	BL	SaveStringConditions
	TSTS	r4, #1:SHL:6
	MOVNE	r10, #"S"
	STRNEB	r10, [r0], #1
	TSTS	r4, #1:SHL:5
	MOVNE	r10, #"H"
	MOVEQ	r10, #"B"
	STRB	r10, [r0], #1

	MOV	r5, r4, LSR #12
	BL	Tab_Dis_Register

	MOV	r5, r4, LSR #16
	AND	r5, r5, #&F
	TEQS	r5, #15
	ANDEQ	r10, r4, #1:SHL:22      ; Immediate/~Register offset
	TEQEQS	r10, #1:SHL:22
	BNE	not_ldrh_rel

	; show resultant [LD|ST]R[H|SH|SB] Rd,[PC,#nn] address directly

	MOV	r5, #","
	STRB	r5, [r0], #1
	AND	r8,  r4, #&0000000F
	AND	r10, r4, #&00000F00
	ORR	r8, r8, r10, LSR #4
	TSTS	r4, #1:SHL:23		; Up/~Down bit
	SUBEQ	r8, r9, r8
	ADDNE	r8, r9, r8
	B	BranchLdrStrCommon


not_ldrh_rel
	ADR	r10, Open_B		; ",["
	BL	SaveString

	BL	Dis_Register

	TSTS	r4, #1:SHL:24           ; Pre/~Post bit
	ADRL	r10, Close_B
	ADDNE	r10, r10, #1            ; just ',' else '],'
	BL	SaveString
	TSTS	r4, #1:SHL:22		; Immediate/~Register bit
	BEQ	ldrstrh_reg

	MOV	r6, #"#"
	STRB	r6, [r0], #1
	TSTS	r4, #1 :SHL: 23		; Up/~Down bit
	MOVEQ	r6, #"-"
	STREQB	r6, [r0], #1

	AND	r8,  r4, #&0000000F
	AND	r10, r4, #&00000F00
	ORR	r8, r8, r10, LSR #4
	BL	StoreDecimal
	B	%F50

ldrstrh_reg
	TSTS	r4, #1:SHL:23		; Up/~Down bit
	MOVEQ	r6, #"-"
	STREQB	r6, [r0], #1
	AND	r5, r4, #&F
	BL	Dis_Register


50	TSTS	r4, #1:SHL:24           ; Pre/~Post bit
	BEQ	InstructionEnd

	MOV	r6, #"]"
	STRB	r6, [r0], #1

	TSTS	r4, #1:SHL:21           ; Writeback bit
	MOVNE	r6, #"!"
	STRNEB	r6, [r0], #1
	B	InstructionEnd

	[ {FALSE}
arm3only = "M01",0
        ALIGN
	]


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data processing opcodes

DataProcessing ROUT

        LDR     r3, =&0E000090          ; Data processing op with bit 4 set
        AND     r3, r4, r3              ; -> shift by Rs, but bit 7 set, so
        LDR     r2, =&00000090          ; is not defined
        CMP     r3, r2
        BEQ     UndefinedDataProcessing ; MUL/MLA in here too (and SWP from 1.23)
                                        ; (and MULL/MLAL from 1.44)

        MOV     r6, r4, LSR #21         ; r6 := dp opcode
        AND     r6, r6, #2_1111
;Version 1.25 bug fix - only apply ADR to immediate operands
        ;If ADD or SUB, and Rn=15 then call it ADR instead
        CMP     R6,#2
        CMPNE   R6,#4
        BNE     notADR ;not ADD/SUB

        MOV     R5,R4,LSR #16
        AND     R5,R5,#15
        CMP     R5,#15
        BNE     notADR ;Rn not R15

        ANDS    R5,R4,#&02000000
        BNE     isADR
notADR
        ;if opc is 0xx0 we need to check whether it's going to a MRS/MSR
        ANDS    R5,R6,#8
        BEQ     notMRSorMSR
        ;r4 still holds the opcode, we want the following cases
        ;31   27   23   19   15
        ;cccc 0001 0x00 1111 xxxx MRS
        ;cccc 0001 0x10 1001 1111 MSR (register to PSR)
        ;cccc 00x1 0x10 1000 1111 MSR (flag bits only)
        ;previous test ensures that b24 is set

        AND     R5,R4,#&00BF0000
        CMP     R5,#&000F0000
        BEQ     is_MRS

        AND     R10,R4,#&0000F000
        CMP     R10,#&F000
        BNE     notMRSorMSR
        BIC     R5,R5,#&00010000
        CMP     R5,#&00280000
        BEQ     is_MSR

        ; and fall through to...

notMRSorMSR
	BIC	r5, r4, #&F000000F
	LDR	r10, =&012FFF10
	TEQS	r5, r10
	BEQ	is_BX

        ADR     r10, OpcTAB
        ADD     r10, r10, r6, LSL #2

        BL      SaveStringConditions

        MOV     r5, r4, LSR #12         ; Rn
        CMP     r6, #&08                ; TEQ,TST,CMP,CMN
        RSBCSS  r14, r6, #&0B
        BCC     %FT10

        AND     r5, r5, #2_1111         ; If Rn = pc then xxxP
        TEQ     r5, #15
        MOVEQ   r10, #"P"
        STREQB  r10, [r0], #1
        MOVEQ   R10, #-3
        STREQ   R10, Mistake            ;potential bank access error

        BL      Tab
        B       %FT20


10      TST     r4, #1 :SHL: 20         ; Update flags bit
        MOVNE   r10, #"S"
        STRNEB  r10, [r0], #1

        BL      Tab_Dis_Register

        BL      AddComma

        TEQ     r6, #13                 ; MOV
        TEQNE   r6, #15                 ; MVN
        BEQ     Operand_2


20      MOV     r5, r4, LSR #16         ; Rd
        BL      Dis_Register
        BL      AddComma

Operand_2
        TST     r4, #1 :SHL: 25         ; Immediate bit
        BNE     Immediate

        MOV     r5, r4                  ; Rm
        BL      Dis_Register

        BL      ShiftField
        B       InstructionEnd


Immediate
        MOV     r10, #"#"
        STRB    r10, [r0], #1

        MOV     r2, r4, LSR #7
        AND     r2, r2, #30             ; Yes, I really do mean 30, see the bok
        AND     r8, r4, #&FF
        MOV     r8, r8, ROR r2

        MOVS    r14, r8, LSR #8         ; Does value fit in LSB
        BNE     %FT10
        TEQ     r2, #0                  ; but have a non-zero shift ?
        BNE     WackyShift
10

;Testing for weird shifts, ie representable numbers as <data><no shift> but are in fact <data><shift>
;removed

        CMP     r8, #10
        BCC     Rem_Number              ; If really simple, just display number
                                        ; ie. 0..9 unambiguous

        MOV     r2, #8-4                ; default is byte
        CMP     r8, #&100
        MOVCS   r2, #16-4               ; then halfword
        CMP     r8, #&10000
        MOVCS   r2, #32-4               ; then fullword
        BL      StoreHex

        CMP     r8, #8192               ; If really big, don't comment on it
        BHS     InstructionEnd          ; May have VSet from CMP!

        BL      Tab                     ; Will also insert '; '

        MOV     r10, #"="
        STRB    r10, [r0], #1


Rem_Character
        CMP     r8, #delete
        CMPNE   r8, #space-1
        BLS     Rem_Number

        CMP     r8, #&100
        BHS     Rem_Number

        MOV     r10, #quote
        STRB    r10, [r0], #1
        STRB    r8,  [r0], #1
        STRB    r10, [r0], #1
        B       InstructionEnd


Rem_Number
        BL      StoreDecimal
        B       InstructionEnd

;ADR pseudo-op - display address being created instead of the ADD/SUB

isADR   ADR     R10, AdrTAB
        BL      SaveStringConditions
        BL      Tab
        MOV     R5, R4, LSR #12
        BL      Dis_Register
        BL      AddComma
        MOV     R2, R4, LSR #7
        AND     R2, R2, #&1E
        AND     R8, R4, #&FF
        MOV     r8, r8, ROR r2
        CMP     R6, #2
        SUBEQ   R8, R9, R8
        ADDNE   R8, R8, R9
        ADD     R8, R8, #8
        MOV     R2, #32-4
        BL      StoreHex
        B       InstructionEnd

CPSR_or_SPSR
        ANDS    R5,R4,#&00400000
        ADREQ   R10,cpsr_tab
        ADRNE   R10,spsr_tab
        B       SaveString

CPSR_or_SPSRflag
        ANDS    R5,R4,#&00400000
        ADREQ   R10,cpsr_flag_tab
        ADRNE   R10,spsr_flag_tab
        B       SaveString

is_MRS  ;check for illegal instruction first
        MOVS    R5, R4, LSL #20            ;bottom 12 bits should be zero
        BNE     Undefined

        ADR     R10, MrsTAB
        BL      SaveStringConditions
        BL      Tab
        MOV     R5,R4,LSR #12              ;get Rd
        BL      Dis_Register
        BL      AddComma
        ;either CPSR or SPSR - b22 clear for CPSR
        BL      CPSR_or_SPSR
        B       InstructionEnd

cpsr_tab DCB    "CPSR_all",0
spsr_tab DCB    "SPSR_all",0
cpsr_flag_tab DCB    "CPSR_flg",0
spsr_flag_tab DCB    "SPSR_flg",0
        ALIGN

is_MSR  ;two legal cases here
        ;cccc 0001 0x10 1001 1111 xxxx xxxx xxxx
        ;cccc 00x1 0x10 1000 1111 xxxx xxxx xxxx
        ;so if b25 set and b16 set we revert to a data op
        ANDS    R5,R4,#&02000000
        ANDNES  R5,R4,#&00010000
        BNE     notMRSorMSR

        ;if bit is 16 it is MSR to whole PSR, otherwise it is to flags only

        TST     R4,#&10000
        BNE     msr_whole

        ;flags only, may be register or immediate value
        ADR     R10,MsrTAB
        BL      SaveStringConditions
        BL      Tab
        BL      CPSR_or_SPSRflag
        BL      AddComma
        B       Operand_2

msr_whole

        ;but undefined if shift is non zero

        ANDS    R5,R4,#&FF0
        BNE     Undefined

        ADR     R10,MsrTAB
        BL      SaveStringConditions
        BL      Tab
        BL      CPSR_or_SPSR
        BL      AddComma
        B       Operand_2

is_BX	; one legal case
	; cccc 0001 0010 1111 1111 1111 0001 mmmm
	;
	; BX Rm
	;
	; where mmmm = Rm
	;
	ADR	R10,BxTAB
	BL	SaveStringConditions
	AND	R5,R4,#&FF
	BL	Tab_Dis_Register

	B	InstructionEnd

AdrTAB  DCB     "ADR",0
MrsTAB  DCB     "MRS",0
MsrTAB  DCB     "MSR",0
BxTAB   DCB     "BX", 0, 0

OpcTAB  DCB     "AND",0
        DCB     "EOR",0
        DCB     "SUB",0
        DCB     "RSB",0
        DCB     "ADD",0
        DCB     "ADC",0
        DCB     "SBC",0
        DCB     "RSC",0
        DCB     "TST",0
        DCB     "TEQ",0
        DCB     "CMP",0
        DCB     "CMN",0
        DCB     "ORR",0
        DCB     "MOV",0
        DCB     "BIC",0
        DCB     "MVN",0


WackyShift
        AND     r8, r4, #&FF            ; Get unrotated byte back
        CMP     r8, #0                  ; 0,n prettified
        MOVEQ   r10, #"0"
        STREQB  r10, [r0], #1

        MOVNE   r2, #8-4                ; Display unrotated byte,decimal rotate
        BLNE    StoreHex

;1.26 - Change layout to #0, ROR #nn
        ADRL    R10,ShiftROR
        BL      SaveString

        MOV     r10, #"#"
        STRB    r10, [r0], #1

        MOV     r8, r4, LSR #7          ; Extract shift part again
        AND     r8, r8, #30
        B       Rem_Number

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Coprocessor

        MOV     r2, r4, LSR #8          ; r2 := CP#
        AND     r2, r2, #2_1111

        TEQ     r2, #2_0001
        BEQ     Floating_Point          ; [Floating Point coprocessor]

;1.32 add coproc 2 for FPA LFM/SFM instructions
        TEQ     r2, #2_0010
        BEQ     New_FPA                 ;new FPA

; Currently unknown coprocessor

        CMP     r3, #&0E
        BEQ     Co_Operations

; Coprocessor Data Transfer (CPDT)

        TST     r4, #1 :SHL: 20         ; Load/~Store bit
        ADRNE   r10, Ldc
        ADREQ   r10, Stc
        BL      SaveStringConditions

        TST     r4, #1 :SHL: 22         ; Precision bit
        MOVNE   r10, #"L"
        STRNEB  r10, [r0], #1

        BL      Tab_CPN                 ; CP#

        MOV     r5, r4, LSR #12         ; CRd
        BL      Dis_C_Register


CPDT_Common                             ; FP entry point from below

        BIC     r3, r3, #2_1000         ; Make like a normal data transfer
                                        ; 0C,0D -> 04,05
        BIC     r4, r4, #&00000F00      ; Clear CP# field
        B       DataTransfer_Common

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Ldc     DCB     "LDC", 0
Stc     DCB     "STC", 0

Cdp     DCB     "CDP", 0

Mcr     DCB     "MCR", 0
Mrc     DCB     "MRC", 0

Cp      DCB     "CP", 0

        ALIGN


Co_Operations

        TST     r4, #1 :SHL: 4          ; Transfer/~Operation bit
        BNE     Co_Transfers

; Coprocessor Data Operation (CPDO)

        MOV     R10, #-4 ;deferred warning in case SWI next
        STR     R10, Mistake

        ADR     r10, Cdp
        BL      SaveStringConditions

        BL      Tab_CPN                 ; CP#

        MOV     r8, r4, LSR #20         ; CPOpc
        AND     r8, r8, #2_1111         ; All of nibble for CPDO
        BL      StoreDecimal_Comma

        MOV     r5, r4, LSR #12         ; CRd
        BL      Dis_C_Register_Comma

CPRT_CPDO_Common

        MOV     r5, r4, LSR #16         ; CRn
        BL      Dis_C_Register_Comma

        MOV     r5, r4                  ; CRm
        BL      Dis_C_Register

        MOV     r8, r4, LSR #5          ; CP
        ANDS    r8, r8, #2_111          ; non-zero ?
        BLNE    AddComma
        BLNE    StoreDecimal

        ;if MRC/MCR check for system control coprocessor and comment accordingly

        TST     r4, #1 :SHL: 4          ; Transfer/~Operation bit
        BEQ     InstructionEnd

        AND     R5,R4,#&F00
        CMP     R5,#&F00
        BNE     InstructionEnd          ; Not CP15

        MOV     R5,R4,LSR #16
        AND     R5,R5,#&0F
	TEQS	R5,#4
	BEQ	InstructionEnd
	CMPS	R5,#8
	BHI	InstructionEnd

        BL      Tab

        ADR     R10,msgtable
        ADD     R10,R10,R5,LSL #2
        BL      lookup_r10
        BL      SaveString
        B       InstructionEnd

msgtable
msg0    = "M02",0
msg1    = "M03",0
msg2    = "M04",0
msg3    = "M05",0
msg4    = "M08",0
msg5    = "M06",0
msg6    = "M07",0
msg7    = "M51",0
msg8	= "M52",0

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Coprocessor Register Transfer (CPRT)

Co_Transfers

        TST     r4, #1 :SHL: 20         ; Load/~Store bit
        ADRNE   r10, Mrc
        ADREQ   r10, Mcr
        BL      SaveStringConditions

        BL      Tab_CPN                 ; CP#

        MOV     r8, r4, LSR #20         ; CPOpc
        AND     r8, r8, #2_1110         ; Only three bits for CPRT
        BL      StoreDecimal_Comma

        MOV     r5, r4, LSR #12         ; Rd (ARM register)
        BL      Dis_Register
        BL      AddComma

        B       CPRT_CPDO_Common

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Tab_CPN ENTRY

        BL      Tab

        ADR     r10, Cp
        BL      SaveString

        MOV     r8, r4, LSR #8
        AND     r8, r8, #2_1111
        BL      StoreDecimal_Comma      ; CP#
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Lfm     DCB     "LFM",0
Sfm     DCB     "SFM",0
        ALIGN

New_FPA
        CMP     r3,#&0C
        CMPNE   r3,#&0D
        BNE     Undefined       ;only coproc 2 codes so far are LFM/SFM

        TST     r4, #1 :SHL: 20
        ADRNE   r10,Lfm
        ADREQ   r10,Sfm
        BL      SaveStringConditions
        BL      Tab

        MOV     r5, r4, LSR #12         ; Fd
        BIC     r5, r5, #2_1000         ; Only 8 FP registers
        BL      Dis_F_Register

        MOV     r5,#","
        STRB    r5, [r0], #1

        MOV     r5, r4, LSR #15
        AND     r5, r5, #1
        MOV     r14, r4, LSR #21
        AND     r14, r14, #2
        ORR     r5, r5, r14
        TEQ     r5, #0
        MOVEQ   r5, #4
        ORR     r5, r5, #&30
        STRB    r5, [r0], #1

        B       not_rel ;drop into ordinary CPDT processing

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Ldf     DCB     "LDF", 0
Stf     DCB     "STF", 0

        ALIGN

Floating_Point

        CMP     r3, #&0E
        BEQ     Floating_processing

; Floating Point Data Transfer (CPDT)

        TST     r4, #1 :SHL: 20         ; Load/~Store bit
        ADRNE   r10, Ldf
        ADREQ   r10, Stf
        BL      SaveStringConditions

        AND     r14, r4, #1 :SHL: 15    ; FPDT precision bits (Y,X)
        MOV     r14, r14, LSR #15
        AND     r10, r4, #1 :SHL: 22
        ORR     r14, r14, r10, LSR #22-1
        ADR     r10, fpdt_prec
        LDRB    r10, [r10, r14]
        STRB    r10, [r0], #1

        BL      Tab

        MOV     r5, r4, LSR #12         ; Fd
        BIC     r5, r5, #2_1000         ; Only 8 FP registers
        BL      Dis_F_Register

        B       CPDT_Common


fpdt_prec
        DCB     "SDEP"
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Floating_processing

        TST     r4, #1 :SHL: 4          ; Transfer/~Operation bit
        BNE     Floating_Register_Transfer

; Floating Point Data Operation (CPDO)

        MOV     R6, #-4
        STR     R6, Mistake

        MOV     r6, r4, LSR #20         ; FPOpc
        AND     r6, r6, #2_01111
        TST     r4, #1 :SHL: 15
        ORRNE   r6, r6, #2_10000        ; jabcde

        ADR     r1, Floating_Operations
        BL      FPRT_FPDO_Common

        MOV     r5, r4, LSR #12         ; Fd
        BIC     r5, r5, #2_1000         ; Only 8 FP registers
        BL      Dis_F_Register

        TST     r4, #1 :SHL: 15
        BNE     Dis_FmOrConstant        ; [unary op]

        BL      AddComma
        B       Dis_Fn_FmOrConstant

        LTORG


Floating_Operations

        DCB     "ADF"           ; 0  ... binary ops
        DCB     "MUF"           ; 1
        DCB     "SUF"           ; 2
        DCB     "RSF"           ; 3
        DCB     "DVF"           ; 4
        DCB     "RDF"           ; 5
        DCB     "POW"           ; 6
        DCB     "RPW"           ; 7

        DCB     "RMF"           ; 8
        DCB     "FML"           ; 9
        DCB     "FDV"           ; 10
        DCB     "FRD"           ; 11
        DCB     "POL"           ; 12
        DCB     "F0D"           ; 13 ... undefined binary ops
        DCB     "F0E"           ; 14
        DCB     "F0F"           ; 15

        DCB     "MVF"           ; 16 ... unary ops
        DCB     "MNF"           ; 17
        DCB     "ABS"           ; 18
        DCB     "RND"           ; 19
        DCB     "SQT"           ; 20
        DCB     "LOG"           ; 21
        DCB     "LGN"           ; 22
        DCB     "EXP"           ; 23

        DCB     "SIN"           ; 24
        DCB     "COS"           ; 25
        DCB     "TAN"           ; 26
        DCB     "ASN"           ; 27
        DCB     "ACS"           ; 28
        DCB     "ATN"           ; 29
        DCB     "URD"           ; 30
        DCB     "NRM"           ; 31

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

FPRT_FPDO_Common ENTRY

        ADD     r6, r6, r6, LSL #1      ; *3
        ADD     r1, r1, r6
        LDRB    r10, [r1], #1
        STRB    r10, [r0], #1
        LDRB    r10, [r1], #1
        STRB    r10, [r0], #1
        LDRB    r10, [r1], #1
        STRB    r10, [r0], #1

        BL      Conditions

        AND     r14, r4, #1 :SHL: 7     ; FPDO/FPRT precision bits (e,f)
        MOV     r14, r14, LSR #7
        AND     r10, r4, #1 :SHL: 19
        ORR     r14, r14, r10, LSR #19-1
        ADR     r10, fpdo_fprt_prec
        LDRB    r10, [r10, r14]
        STRB    r10, [r0], #1

        MOV     r10, #"Z"               ; Rounding mode
        TST     r4, #2_01 :SHL: 5
        MOVEQ   r10, #"M"
        TST     r4, #2_10 :SHL: 5
        MOVEQ   r10, #"P"
        TST     r4, #2_11 :SHL: 5
        STRNEB  r10, [r0], #1

        BL      Tab
        EXIT


fpdo_fprt_prec
        DCB     "SDE?"
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Floating Point Register Transfer (CPRT)

Floating_Register_Transfer

        LDR     r2,  =&0E98FF10
        LDR     r10, =&0E90F110
        AND     r2, r4, r2
        CMP     r2, r10
        BEQ     Floating_Status_Transfer

        MOV     r6, r4, LSR #20         ; FPOpc
        AND     r6, r6, #2_1111

        ADR     r1, Floating_Transfers
        BL      FPRT_FPDO_Common

        MOV     r5, r4, LSR #12         ; Rd (ARM register)
        BL      Dis_Register

        MOV     r6, r4, LSR #20         ; FPOpc
        AND     r6, r6, #2_1111
        CMP     r6, #2_0010             ; FLT/FIX have another operand
        BLCC    Dis_FmOrConstant
        B       InstructionEnd


        LTORG

Floating_Transfers

        DCB     "FLT"           ; 0
        DCB     "FIX"           ; 1
        DCB     "WFS"           ; 2
        DCB     "RFS"           ; 3
        DCB     "WFC"           ; 4
        DCB     "RFC"           ; 5
        DCB     "FT6"           ; 6 ... undefined floating_transfers
        DCB     "FT7"           ; 7

        DCB     "FT8"           ; 8
        DCB     "FT9"           ; 9
        DCB     "FTA"           ; 10
        DCB     "FTB"           ; 11
        DCB     "FTC"           ; 12
        DCB     "FTD"           ; 13
        DCB     "FTE"           ; 14
        DCB     "FTF"           ; 15

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Floating Point Status Transfer

Cmf     DCB     "CMF", 0
Cnf     DCB     "CNF", 0
        ALIGN

Floating_Status_Transfer

        TST     r4, #1 :SHL: 21         ; Negated compare/~Compare bit
        ADREQ   r10, Cmf
        ADRNE   r10, Cnf
        BL      SaveString

        TST     r4, #1 :SHL: 22         ; Exception bit
        MOVNE   r10, #"E"
        STRNEB  r10, [r0], #1

        BL      Conditions

        BL      Tab

; .............................................................................

Dis_Fn_FmOrConstant

        MOV     r5, r4, LSR #16         ; Fn
        BIC     r5, r5, #2_1000         ; Only 8 FP registers
        BL      Dis_F_Register

; .............................................................................

Dis_FmOrConstant ROUT

        BL      AddComma

        TST     r4, #2_1000             ; Immediate operand ?
        BNE     %FT50

        AND     r5, r4, #2_0111         ; Fm
        BL      Dis_F_Register
        B       InstructionEnd


50      MOV     r10, #"#"
        STRB    r10, [r0], #1

        AND     r8, r4, #2_0111         ; 3 bits instead of Fm
        TEQ     r8, #6                  ; 0..7 -> 0,1,2,3,4,5,0.5,10
        ADREQ   r10, Pt5                ; 0.5
        BEQ     SaveStringEnd

        TEQ     r8, #7
        MOVEQ   r8, #10
        BL      StoreDecimal

        ADR     r10, Point0
        B       SaveStringEnd


Pt5     DCB     "0.5", 0
Point0  DCB     ".0", 0

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ShiftField ROUT

        MOV     r2, r4, LSR #4
        ANDS    r2, r2, #&FF            ; LSL #0 -> no shift at all
        MOVEQ   pc, lr

        ENTRY

        TEQ     r2, #2_00000110         ; ROR #0 -> RRX
        BEQ     %FT80

        AND     r1, r2, #2_00000110     ; Each is 6 chars long
        ADR     r10, ShiftTypes
        ADD     r10, r10, r1, LSL #1
        ADD     r10, r10, r1
        BL      SaveString

        TST     r2, #2_00000001
        BNE     %FT50                   ; [, SHF Rs]

; Shift number

        MOV     r10, #"#"
        STRB    r10, [r0], #1

        MOVS    r8, r2, LSR #3          ; LSR #0 -> LSR #32
        MOVEQ   r8, #32                 ; ASR #0 -> ASR #32
        BL      StoreDecimal
        EXIT

50 ; Shift register

        MOV     r5, r2, LSR #4          ; Rs
        BL      Dis_Register
        EXIT


80      ADR     r10, %FT90              ; RRX
        BL      SaveString
        EXIT


90
        DCB     ",RRX", 0

ShiftTypes
        DCB     ",LSL ", 0              ; 00x
        DCB     ",LSR ", 0              ; 01x
        DCB     ",ASR ", 0              ; 02x
ShiftROR ;used for wacky zero shifts
        DCB     ",ROR ", 0              ; 03x

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r5 = fp register

Dis_F_Register ENTRY "r2"

        MOV     r10, #"F"

        AND     r5, r5, #2_1111
        CMP     r5, #2_1000             ; Only 8 FP registers
        BCC     %FT50

        STRB    r10, [r0], #1

        CMP     r5, #2_1111             ; Of other 8, only #15 (FSW) valid
        MOVEQ   r10, #"S"
        MOVNE   r10, #"?"
        STRB    r10, [r0], #1

        MOVEQ   r10, #"W"
        MOVNE   r10, #"?"
        STRB    r10, [r0], #1
        EXIT

; .............................................................................

Dis_C_Register ALTENTRY

        MOV     r10, #"C"
        B       %FT50

; .............................................................................

Dis_Register ALTENTRY

20      AND     r5, r5, #2_1111
        TEQ     r5, #15
        BEQ     Dis_pc

        MOV     r10, #"R"

; .............................................................................
; In    r5 = register number
;       r10 = first character

50      STRB    r10, [r0], #1

        CMP     R5,#15
        CMPNE   R5,#7
        BLHI    checkreg

        AND     r5, r5, #2_1111
        ADD     r2, r5, #"0"
        CMP     r5, #10
        MOVCS   r10, #"1"
        STRCSB  r10, [r0], #1
        SUBCS   r2, r2, #10
        STRB    r2, [r0], #1
        EXIT

; .............................................................................

Dis_pc  ADR     r10, pc_Reg
        BL      SaveString
        EXIT


pc_Reg  DCB     "PC", 0
        ALIGN

; .............................................................................

Comma_Dis_Register ALTENTRY

        BL      AddComma
        B       %BT20

; .............................................................................

Tab_Dis_Register ALTENTRY

        BL      Tab
        B       %BT20

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r10 -> string, 0 to copy into buffer
;       r0 -> current buffer position

; Out   r0 ++, r10++

SaveString ENTRY

10      LDRB    r14, [r10], #1
        CMP     r14, #32
        STRCSB  r14, [r0], #1
        BCS     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r4 = instruction

; Out   r0++ with condition codes appended

Conditions ENTRY "r1, r10"

10      MOV     r1, r4, LSR #28
        CMP     R1, #15
        MOVEQ   R10,#1
        STREQ   R10,Mistake
        ADR     R10, CondSym
        ADD     r1, r10, r1, LSL #1
        LDRB    r10, [r1], #1
        CMP     r10, #0
        STRNEB  r10, [r0], #1
        LDRNEB  r10, [r1], #1
        STRNEB  r10, [r0], #1
        EXIT


CondSym DCB     "EQ"                    ; 0
        DCB     "NE"                    ; 1
        DCB     "CS"                    ; 2
        DCB     "CC"                    ; 3
        DCB     "MI"                    ; 4
        DCB     "PL"                    ; 5
        DCB     "VS"                    ; 6
        DCB     "VC"                    ; 7

        DCB     "HI"                    ; 8
        DCB     "LS"                    ; 9
        DCB     "GE"                    ; 10
        DCB     "LT"                    ; 11
        DCB     "GT"                    ; 12
        DCB     "LE"                    ; 13
        DCB     0,0                     ; 14 : AL cc
        DCB     "NV"                    ; 15

        ALIGN

; .............................................................................

SaveStringConditions ALTENTRY

        BL      SaveString
        B       %BT10

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Pad with spaces to operand field or comment field

Tab ENTRY

10      ADR     r1, StringBuffer
        SUB     r1, r0, r1
        MOV     r14, #space
        STRB    r14, [r0], #1
        CMP     r1, #7
        EXIT    EQ
        CMP     r1, #25 ;new exit position for longer comments
        BCC     %BT10

        ADR     r10, Rem
        BL      SaveString
        EXIT

Rem     DCB     " ; ", 0
        ALIGN

TestMistakes
        ENTRY   "r5"
        LDR     R5,Mistake
        CMP     R5,#1
        BLT     exitM

        BL      Tab
        MOV     R10,#0
        STR     R10,Mistake
        ADR     R10,Silly
        SUB     R5,R5,#1
        ADD     R10,R10,R5,LSL #2
;        LDR     R5,[R5]
;        ADD     R10,R10,R5
        BL      lookup_r10
        BL      SaveString
exitM
        EXIT

Silly
sil01   =       "M09",0
sil02   =       "M10",0
sil03   =       "M11",0
sil04   =       "M12",0
sil05   =       "M13",0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> buffer
;       r2 = bit position to start at
;       r8 = value to store in hex

; Out   r0 ++

StoreHex ENTRY "r2"

        MOV     r14, #"&"
        STRB    r14, [r0], #1

10      MOV     r14, r8, LSR r2
        AND     r14, r14, #15
        CMP     r14, #9
        ORRLS   r14, r14, #"0"
        ADDHI   r14, r14, #"A"-10
        STRB    r14, [r0], #1
        SUBS    r2, r2, #4
        BPL     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> current buffer position
;       r8 = value to store in decimal

; Out   r0++

StoreDecimal ENTRY "r1-r2, r4"

        SUB     sp, sp, #16
        MOV     r4, r0

        MOV     r0, r8
        MOV     r1, sp
        MOV     r2, #16                 ; Can't get an error with this much
        SWI     XOS_BinaryToDecimal     ; r2 := length of number

        MOV     r0, r4
10      SUBS    r2, r2, #1
        LDRPLB  r14, [r1], #1
        STRPLB  r14, [r0], #1
        BNE     %BT10

        ADD     sp, sp, #16
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

StoreDecimal_Comma ENTRY

        BL      StoreDecimal
        B       %FT50

;..............................................................................
; In    r0 -> output buffer

; Out   comma appended, r0++, flags preserved

AddComma ALTENTRY

50      MOV     r14, #","
        STRB    r14, [r0], #1
        EXITS

; .............................................................................

Dis_C_Register_Comma ALTENTRY

        BL      Dis_C_Register
        B       %BT50

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MemoryI_Error
        DCD     ErrorNumber_Syntax
        DCB     "M14", 0
        ALIGN


MemoryI_Code ENTRY "r6-r11"

        LDR     wp, [r12]

        ADR     r2, MemoryI_Error
        BL      GetCommandParms_R0
        BLVS    CopyErrorR2
        EXIT    VS

        TST     r8, #secondparm
        ADDEQ   r7, r9, #4*24

 [ Addr26
        BIC     r9, r9, #ARM_CC_Mask    ; Ensure in 64M space
        BIC     r7, r7, #ARM_CC_Mask
 |
        BIC     r9, r9, #3              ; ensure word aligned
        BIC     r7, r7, #3
 ]

        CMP     r9, r7                  ; If same, ensure we do one word
        ADDEQ   r7, r7, #4
 [ Addr26
        BICEQ   r7, r7, #ARM_CC_Mask    ; Ensure still in 64M space
 ]

        [       rp0512
        BL      memorytest
        ]

        BL      SwapAllBreakpoints

10 ; Loop doing disassembly until ESCape or ended

        SWI     XOS_ReadEscapeState
        BCS     %FT95

        BL      DisplayHexWord_R9       ; Display address

        BLVC    MarkPC

        MOVVC   r2, #4                  ; Display characters at address
        BLVC    DisplayCharacters
        EXIT    VS

        SWI     XOS_WriteS
        DCB     " : ", 0
        ALIGN

        LDRVC   r10, [r9]               ; Display word at address
        BLVC    DisplayHexWord

        BLVC    MarkBreakpoints

        LDRVC   r0, [r9]                ; Display instruction at address
        MOVVC   r1, r9
        SWIVC   XDebugger_Disassemble
        MOVVC   r0, r1

        SWIVC   XOS_Write0
        SWIVC   XOS_NewLine
        EXIT    VS

        ADD     r9, r9, #4
 [ Addr26
        BIC     r9, r9, #ARM_CC_Mask            ; Wrap within 64M
 ]

        CMP     r9, r7
        BNE     %BT10


90      BL      SwapAllBreakpoints
        EXIT

95      BL      AckEscape
        B       %BT90

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

InitStore_Error
        DCD     ErrorNumber_Syntax
        DCB     "M15", 0
        ALIGN


UserMemStart  * &8000

InitStore_Code ENTRY "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        ADR     r0, InitStore_Error
        BL      ReadOneParm             ; r7 := parm, r8 state
        BLVS    CopyError
        EXIT    VS

        TST     r8, #hasparm
        LDREQ   r7, =&E6000010          ; A nice invalid instruction
        SWI     XOS_GetEnv              ; r1 -> end of user memory

        MOV     r14, #UserMemStart
10      TEQ     r14, r1                 ; Might have zero apl space
        STRNE   r7, [r14], #4
        BNE     %BT10

        BL      message_writes
        DCB     "M16", 0
        ALIGN

        MOVVC   r10, r7
        BLVC    DisplayHexWord
        SWIVC   XOS_NewLine
        EXIT

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ShowRegs_Code

        LDR     wp, [r12]

; .............................................................................

ShowRegs_Code_Common ENTRY "r6-r11"

        BL      message_writes        ; Display address of register dump
        DCB     "M17", 0
        ALIGN

        ADRVC   r10, Registers
        BLVC    DisplayHexWord
        EXIT    VS

        BL      message_writes
        DCB     "M18", 0
        ALIGN
        EXIT    VS

        MOV     r4, #0
        ADR     r11, Registers

10 ; Display dumped registers

        TST     r4, #3
        SWIEQ   XOS_NewLine
        EXIT    VS

        SWINE   XOS_WriteI+space

        SWIVC   XOS_WriteI+"R"

        MOVVC   r8, r4
        BLVC    DisplayDecimalNumber
        EXIT    VS

        CMP     r4, #10
        SWICC   XOS_WriteI+space
        EXIT    VS

        SWI     XOS_WriteS
        DCB     " = ", 0
        ALIGN

        LDRVC   r10, [r11, r4, LSL #2]
        BLVC    DisplayHexWord
        EXIT    VS

        ADD     r4, r4, #1
        CMP     r4, #16
        BNE     %BT10


; Display processor mode (r10 = dumped pc at end of loop)

        SWI     XOS_NewLine
        EXIT    VS
        BL      message_writes
        DCB     "M19", 0
        ALIGN

        ANDVC   r2, r10, #2_11          ; Mask with M[1:0] bits
        ADRVC   r0, ARM_Modes
        ADDVC   r0, r0, r2, LSL #2
        SWIVC   XOS_Write0
        EXIT    VS

        BL      message_writes
        DCB     "M20", 0
        ALIGN

        MOVVC   r0, #"N"
        MOVVC   r1, #N_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"Z"
        MOVVC   r1, #Z_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"C"
        MOVVC   r1, #C_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"V"
        MOVVC   r1, #V_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"I"
        MOVVC   r1, #I_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"F"
        MOVVC   r1, #F_bit
        BLVC    DoFlagBit

        SWIVC   XOS_NewLine
        EXIT


ARM_Modes
        DCB     "USR", 0
        DCB     "FIQ", 0
        DCB     "IRQ", 0
        DCB     "SVC", 0

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 = flag bit to test
;       r10 = psr
;       r0 = uppercase char to print if set

; Out   char printed uppercase or lowercase, r0 corrupt

DoFlagBit ENTRY

        TST     r1, r10
        ORREQ   r0, r0, #&20            ; Cheap lowercase, known values input
        SWI     XOS_WriteC
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Memory_Error
        DCD     ErrorNumber_Syntax
        DCB     "M21", 0
        ALIGN


Memory_Code ENTRY "r6-r11"

        BL      MemoryCommon

        ADR     r2, Memory_Error
        BL      GetCommandParms
        BLVS    CopyErrorR2
        EXIT    VS

        TST     r8, #secondparm
        ADDEQ   r7, r9, #256            ; [no second parameter]

 [ Addr26
        BIC     r9, r9, #&FC000000      ; Ensure in 64M space
        BIC     r7, r7, #&FC000000
 ]

        CMP     r6, #4                  ; Round down if words
        BICEQ   r9, r9, #3
        BICEQ   r7, r7, #3

        CMP     r7, r9                  ; If same, ensure we do one byte/word
        ADDEQ   r7, r7, r6
 [ Addr26
        BICEQ   r7, r7, #&FC000000      ; Ensure still in 64M space
 ]

        [       rp0512
        BL      memorytest
        ]

        BL      SwapAllBreakpoints

        MOV     r0, #VduExt_WindowWidth
        MOV     r1, #-1
        Push    "r0, r1"
        MOV     r0, sp
        MOV     r1, sp
        SWI     XOS_ReadVduVariables
        Pull    "r0, r1"
        STR     r0, WindowWidth

        CMP     r0, #8+2+3*32+3+1*32
        MOVHS   r14, #32
        MOVLO   r14, #16
        STR     r14, BytesPerLine

        MOV     r11, #0                 ; Force header on first row

05 ; Loop displaying memory

        SWI     XOS_ReadEscapeState
        BCS     %FT95

        TST     r11, #15
        BLEQ    MemoryHeader

        BLVC    DisplayHexWord_R9       ; address

        SWIVC   XOS_WriteI+space
        SWIVC   XOS_WriteI+colon
        BVS     %FT90

        LDR     r8, BytesPerLine
        CMP     r6, #4
        MOVEQ   r8, r8, LSR #2          ; words per line

        MOV     r0, r9

10
 [ Addr26
        BIC     r0, r0, #&FC000000      ; Wrap to keep in 64M each loop
 ]
        CMP     r6, #4                  ; Need to size reset each loop
        MOVEQ   r2, #32-4               ; word
        BEQ     %FT20

        MOV     r2, #8-4                ; byte

        SWI     XOS_WriteI+space        ; Display byte

        TEQ     r0, r7
        BEQ     %FT50                   ; [ended, so blank. DO NOT READ BYTE]

        LDRVCB  r10, [r0], #1           ; <<<get from buffer
        B       %FA30


20      SWI     XOS_WriteS              ; Display word
        DCB     "    ", 0
        ALIGN

        TEQ     r0, r7
        BEQ     %FT50                   ; [ended, so blank. DO NOT READ WORD]

        LDRVC   r10, [r0], #4           ; <<<get from buffer


30      BLVC    DisplayHex
        B       %FA60


50      BLVC    Blank                   ; Output r2 spaces

60      BVS     %FT90

        SUBS    r8, r8, #1              ; Loop if not done whole line
        BNE     %BT10                   ; Even if ended in middle, were padding

        BL      SpaceColonSpace
        BVS     %FT90

        SUB     r2, r7, r9              ; nchars to print this row

        LDR     r14, BytesPerLine
        CMP     r2, r14
        MOVHS   r2, r14

        CMP     r2, #0                  ; VClear
        BLNE    DisplayCharacters
        SWIVC   XOS_NewLine
        BVS     %FT90

        ADD     r11, r11, #1            ; Another line gone by

        LDR     r14, BytesPerLine
        ADD     r9, r9, r14             ; More bytes per line done

        CMP     r9, r7
        BLO     %BT05


90      BL      SwapAllBreakpoints
        EXIT

95      BL      AckEscape
        B       %BT90

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SpaceColonSpace ENTRY

        SWI     XOS_WriteI+space
        SWIVC   XOS_WriteI+colon
        SWIVC   XOS_WriteI+space
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MemoryHeader ENTRY

        SWI     XOS_NewLine
        EXIT    VS
        BL      message_writes
        DCB     "M22", 0
        ALIGN
        EXIT    VS

        TEQ     r6, #4
        ADREQ   r0, Words
        ADRNE   r0, Bytes
        MOV     lr, pc
        MOV     pc, r0

        BL      SpaceColonSpace
        EXIT    VS

        LDR     r14, BytesPerLine       ; Doing in 32 ?
        CMP     r14, #32
        ADREQ   r0, %FT85
        SWIEQ   XOS_Write0

        ADRVC   r0, %FT80
        BLVC    message_write0
        MOVVC   r11, #0
        SWIVC   XOS_NewLine
        EXIT

80
        DCB     "M23"

85
        DCB     "        ", 0           ; Otherwise centre in field of 32
;                01234567

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9 (0,4,8,C)

Words ENTRY "r9, r10, r11"

        LDR     r11, BytesPerLine

        ADR     r10, Words_Header

10      SWI     XOS_WriteS
        DCB     "     ", 0
        ALIGN
        ANDVC   r9, r9, #&F
        ADDVC   r0, r10, r9, LSL #1
        SWIVC   XOS_Write0
        EXIT    VS

        ADD     r9, r9, #4

        SUBS    r11, r11, #4
        BNE     %BT10
        EXIT

Words_Header
        DCB     "3 2 1 0", 0
        DCB     "7 6 5 4", 0
        DCB     "B A 9 8", 0
        DCB     "F E D C", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Count from r9 to r9+15 modulo 16 along the top

Bytes ENTRY "r9, r10, r11"

        LDR     r11, BytesPerLine

10      SWI     XOS_WriteI+space
        MOVVC   r2, #8-4
        ANDVC   r10, r9, #&F
        BLVC    DisplayHex
        EXIT    VS

        ADD     r9, r9, #1

        SUBS    r11, r11, #1
        BNE     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Fill remaining space with 1 + r2/4 blanks

; In    r2 = number of blanks to go (multiple of 4)

Blank ENTRY

10      SWI     XOS_WriteI+space
        EXIT    VS

        SUBS    r2, r2, #4
        BPL     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; in    r12 to be indirected
;       r0 -> string

; Out   r1 -> string
;       r6 = 1 or 4 depending on whether 'B' present (+ skipped)
;       r0 corrupt

MemoryCommon ENTRY

        LDR     wp, [r12]

        MOV     r1, r0                  ; Check for 'B',space
        BL      SkipSpaces
        TEQ     r0, #"b"
        TEQNE   r0, #"B"
        LDREQB  r0, [r1, #1]
        TEQEQ   r0, #space
        ADDEQ   r1, r1, #2              ; skip 'B',space
        MOVEQ   r6, #1                  ; bytes
        MOVNE   r6, #4                  ; words
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MemoryA_Code ENTRY "r6-r11"

        BL      MemoryCommon

        ADR     r2, MemoryA_Error
        BL      GetCommandParms
        EXIT    VS

        TST     r8, #&FF00              ; had operator ?
        BNE     %FT99                   ; [not permitted here]

 [ Addr26
        BIC     r9, r9, #&FC000000      ; Ensure in 64M space
 ]
        CMP     r6, #4                  ; round down if words
        BICEQ   r9, r9, #3

        [       rp0512
        MOV     r2, r7                 ; avoid walking over the value to write
        MOV     r7,r9

        BL      memorytest2
        ]

        BL      SwapAllBreakpoints

        [       rp0512
        MOV     r7, r2                  ; and back where it should be
        ]
        TST     r8, #secondparm
        BEQ     Interactive             ; [no second parameter]

; Simple command, not interactive

        TEQ     r6, #4
        MOVEQ   r2, #32-4
        LDREQ   r4, [r9]
        STREQ   r7, [r9]
        LDREQ   r5, [r9]
        ADREQ   r0, %FT40

        MOVNE   r2, #8-4
        LDRNEB  r4, [r9]
        STRNEB  r7, [r9]
        LDRNE   r5, [r9]
        ADRNE   r0, %FT41
        BL      message_write0

        BLVC    DisplayHexWord_R9

        ADRVC   r0, %FT44
        BLVC    message_write0

        MOVVC   r10, r4
        BLVC    DisplayHex

        ADRVC   r0, %FT45
        BLVC    message_write0

        MOVVC   r10, r5
        BLVC    DisplayHex

        SWIVC   XOS_NewLine

        BL      SwapAllBreakpoints
        EXIT

40
        DCB     "M24", 0
41
        DCB     "M25", 0
44
        DCB     "M26", 0
45
        DCB     "M27", 0
        ALIGN

99      ADR     r0, MemoryA_Error
        BL      CopyError
        EXIT


MemoryA_Error
        DCD     ErrorNumber_Syntax
        DCB     "M28", 0
        ALIGN

; .............................................................................

Interactive ROUT

        SUB     sp, sp, #256            ; Use buffer on stack
        MOV     r8, r6                  ; 1 or 4, initial step +ve

10
 [ Addr26
        BIC     r9, r9, #&FC000000      ; Wrap in 64M space
 ]
        CMP     r8, #0
        MOVGE   r0, #"+"
        MOVLT   r0, #"-"
        SWI     XOS_WriteC
        SWIVC   XOS_WriteI+space

        BLVC    DisplayHexWord_R9

        BLVC    MarkPC

        TEQ     r6, #4
        LDREQ   r10, [r9]
        LDRNEB  r10, [r9]
        MOVVC   r2, r6
        BLVC    DisplayCharacters

        BLVC    MarkBreakpoints

        TEQ     r6, #4
        MOVEQ   r2, #32-4
        MOVNE   r2, #8-4
        BLVC    DisplayHex

        SWIVC   XOS_WriteI+space
        SWIVC   XOS_WriteI+colon
        SWIVC   XOS_WriteI+space

        TEQ     r6, #4                  ; Only disassemble when doing words
        BNE     %FT50

        LDRVC   r0, [r9]
        MOVVC   r1, r9
        SWIVC   XDebugger_Disassemble
        MOVVC   r0, r1
        SWIVC   XOS_Write0

50      SWIVC   XOS_NewLine
        ADRVC   r0, %FT96
        BLVC    message_write0

        MOVVC   r0, sp
        MOVVC   r1, #255
        MOVVC   r2, #space
        MOVVC   r3, #&FF
        SWIVC   XOS_ReadLine
        BVS     %FT90
        BCS     %FT95

        MOV     r1, sp
        BL      SkipSpaces
        ADDCC   r9, r9, r8              ; No parm, just advance in current dirn
        MOVCC   r7,r9
        [       rp0512
        ADDCC   sp,sp,#256
        BLCC    memorytest2             ;ensure not walking into prohibited space
        SUBCC   sp,sp,#256
        ]

        BCC     %BT10

        TEQ     r0, #"+"
        MOVEQ   r8, r6                  ; Change to +ve step
        BEQ     %BT10

        TEQ     r0, #"-"
        RSBEQ   r8, r6, #0              ; Change to -ve step
        BEQ     %BT10

        CMP     r0, #"."                ; End interactive
        BEQ     %FT90                   ; VClear

        ADR     r0, ErrorBlock_Debug_InvalidValue
        BL      CopyError
        Push    r8
        BL      ReadOneParm             ; r7 := parm, r8 state
        Pull    r8
        BVS     %FT90

        TEQ     r6, #4
        STREQ   r7, [r9]
        LDREQ   r10, [r9]
        MOVEQ   r2, #32-4

        STRNEB  r7, [r9]
        LDRNEB  r10, [r9]
        MOVNE   r2, #8-4

        SWI     XOS_WriteS
        DCB     "                  . ", 0
        ALIGN

        BLVC    DisplayHex
        SWIVC   XOS_NewLine
        BVC     %BT10


90      ADD     sp, sp, #256
        BL      SwapAllBreakpoints
        EXIT

95      BL      AckEscape
        B       %BT90


        MakeInternatErrorBlock Debug_InvalidValue, NOALIGN, M46

96
        DCB     "M29", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BreakSet_Code ENTRY "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        BL      ReadFirstParm           ; r7 := parm
        EXIT    VS

        TST     r8, #parmfollowed
        BNE     BreakSetError0

 [ Addr26
        BIC     r7, r7, #ARM_CC_Mask    ; Can only set at word address in 64M

        CMP     r7, #&02000000          ; Can only set in LogRam
        BHS     BreakSetError1
 |
        BIC     r7, r7, #3              ; Can only set at word address
        CMP     r7, #&04000000          ; Can only set in bottom 64M (has to
                                        ; construct a branch)
        BHS     BreakSetError1
 ]

        [       rp0512
        MOV     r9,r7
        BL      memorytest
        ]

        ADR     r4, Breaklist           ; Check for breakpoint already in list
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        TEQ     r1, r7
        BEQ     %FT40                   ; [already allocated, but ensure there]
        SUBS    r3, r3, #8              ; each breakpoint entry is 8 bytes
        BPL     %BT10

        MOV     r3, #(nbreakpoints-1)*8 ; Allocate breakpoint
20      LDR     r1, [r4, r3]
        CMP     r1, #-1
        BEQ     %FT30                   ; [free slot found]
        SUBS    r3, r3, #8
        BPL     %BT20

        ADR     r0, ErrorBlock_Debug_NoRoom
        BL      CopyError
        B       %FA90


30 ; Store breakpoint address and old contents, r3 = breakpoint number*8

        MOV     r1, r7
        STR     r1, [r4, r3]            ; breakpoint address
        LDR     r0, [r1]
        ADD     r14, r4, #4
        STR     r0, [r14, r3]           ; old data

40 ; Place branch at breakpoint address, r3 = breakpoint number*8, r1 valid

        ADR     r0, BreakCodeStart
        ADD     r0, r0, r3              ; each code entry is 8 bytes too
        BL      MakeBranch
        STR     r2, [r1]
 [ StrongARM
	;Do the IMB thingy here, for the replaced instruction
	MOV	r0, #1		;Ranged IMB
	MOV	r2, r1
	SWI	XOS_SynchroniseCodeAreas
 ]
        EXIT


BreakSetError0
        ADR     r0, BreakSet_Error
        BL      CopyError

90      EXIT


BreakSetError1
        ADR     r0, ErrorBlock_Debug_BadBreakpoint
        BL      CopyError
        B       %BA90


BreakSet_Error
        DCD     ErrorNumber_Syntax
        DCB     "M30", 0
        ALIGN

        MakeInternatErrorBlock Debug_NoRoom,,M48
        MakeInternatErrorBlock Debug_BadBreakpoint,,M50

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BreakList_Code ENTRY "r6-r11"

        LDR     wp, [r12]

        ADR     r4, Breaklist           ; Any breakpoints to display ?
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        CMP     r1, #-1
        BNE     %FT20                   ; [yes, starting at r3]
        SUBS    r3, r3, #8
        BPL     %BT10

        BL      message_writes
        DCB     "M31", 0
        SWIVC   XOS_NewLine
        ALIGN
        EXIT


20 ; Display list

        BL      message_writes
        DCB     "M32", 0
        ALIGN
        SWIVC   XOS_NewLine
        EXIT    VS

30      CMP     r1, #-1
        BEQ     %FT60                   ; [no breakpoint entry here]

        MOV     r10, r1
        BL      DisplayHexWord          ; r10 = breakpoint address
        EXIT    VS

        SWI     XOS_WriteS
        DCB     "    ", 0
        ALIGN

        ADDVC   r14, r4, #4
        LDRVC   r10, [r14, r3]
        BLVC    DisplayHexWord          ; r10 = old data
        EXIT    VS

        ADR     r0, BreakCodeStart      ; Check still B debugger
        ADD     r0, r0, r3              ; each code entry is 8 bytes too
        BL      MakeBranch              ; r1 from up there
        LDR     r14, [r1]
        CMP     r14, r2
        BEQ     %FT50                   ; [breakpoint present and correct]

        MOV     r14, #-1                ; Clear faulty breakpoint entry
        STR     r14, [r4, r3]           ; Only need to zap address field

        BL      message_writes
        DCB     "M33", 0 ; No newline
        ALIGN

50      SWIVC   XOS_NewLine
        EXIT    VS

60      SUBS    r3, r3, #8
        LDRPL   r1, [r4, r3]
        BPL     %BT30

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BreakClr_Error
        DCD     ErrorNumber_Syntax
        DCB     "M34", 0
        ALIGN


BreakClr_Code ENTRY "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        ADR     r0, BreakClr_Error
        BL      ReadOneParm             ; r7 := parm, r8 state
        BLVS    CopyError
        EXIT    VS

        BIC     r7, r7, #ARM_CC_Mask    ; Can only set at word address in 64M

        ADR     r4, Breaklist
        MOV     r3, #(nbreakpoints-1)*8

        TST     r8, #hasparm
        BEQ     %FT50                   ; [no parm, so prompt]

; Clear particular breakpoint

10      LDR     r1, [r4, r3]
        CMP     r1, r7
        BEQ     %FT20                   ; [found]
        SUBS    r3, r3, #8
        BPL     %BT10

        ADR     r0, ErrorBlock_Debug_BreakNotFound
        BL      CopyError
        EXIT


20      BL      ClearBreakpoint         ; uses r1,r3,r4
        EXIT


50 ; Clear all breakpoints

        BL      message_writes
        DCB     "M35", 0
        ALIGN

        SWIVC   XOS_Confirm             ; So sexy, huh ? Returns lowercase char
        EXIT    VS
        BLCS    AckEscape
        SWIVC   XOS_NewLine
        EXIT    VS

        ;TEQ     r0, #"y"
        EXIT    NE                      ; [anything else -> go home]


60      LDR     r1, [r4, r3]
        CMP     r1, #-1
        BLNE    ClearBreakpoint         ; uses r1,r3,r4

        SUBS    r3, r3, #8
        BPL     %BT60

        BL      message_writes
        DCB     "M36", 0
        ALIGN
        SWIVC   XOS_NewLine
        EXIT


        MakeInternatErrorBlock Debug_BreakNotFound,,M45

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 = breakpoint address
;       r3 = breakpoint number*8
;       r4 -> Breaklist

ClearBreakpoint ENTRY "r0-r2, r10"

        MOV     r14, #-1                ; Always clear breakpoint entry
        STR     r14, [r4, r3]           ; Only need to zap address field

        ADR     r0, BreakCodeStart      ; Check that breakpoint was valid
        ADD     r0, r0, r3              ; Each code entry is 8 bytes too
        BL      MakeBranch
        LDR     r14, [r1]
        CMP     r14, r2
        ADDEQ   r14, r4, #4             ; breakpoint was good, so put data back
        LDREQ   r14, [r14, r3]
        STREQ   r14, [r1]
 [ StrongARM
	;Do the IMB thingy here
	MOV	r0, #1			;Ranged IMB
	MOV	r2, r1
	SWI	XOS_SynchroniseCodeAreas
 ]
        EXIT    EQ

        BL      message_writes
        DCB     "M37", 0
        ALIGN
        MOVVC   r10, r1
        BICVC   R10,R10,#ARM_CC_Mask
        BLVC    DisplayHexWord
        EXIT    VS
        BL      message_writes
        DCB     "M38", 0
        ALIGN
        SWIVC   XOS_NewLine
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Continue_Code ENTRY "r6-r11"

        LDR     wp, [r12]

        LDR     r14, pc_register        ; Get pc from exception dump
        BIC     r14, r14, #ARM_CC_Mask

        ADR     r4, Breaklist           ; Check breakpoint list for pc
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        CMP     r1, r14
        MOVEQ   r5, #0                  ; [found]
        BEQ     %FT20
        SUBS    r3, r3, #8
        BPL     %BT10

 [ debug
 DLINE "Not continuing from any of current breakpoints"
 ]
        ADR     r0, Registers
        B       %FT90                   ; Continue with this state



20 ; Check branch at breakpoint

        ADR     r0, BreakCodeStart
        ADD     r0, r0, r3
        BL      MakeBranch
        LDR     r14, [r1]
        TEQ     r14, r2
        BNE     ContinueError1          ; [not kosher]

        BL      message_writes
        DCB     "M39", 0
        ALIGN

        MOVVC   r10, r1
        BICVC   R10,R10,#ARM_CC_Mask
        BLVC    DisplayHexWord
        EXIT    VS

        SWI     XOS_NewLine
        EXIT    VS
        BL      message_writes
        DCB     "M40", 0
        ALIGN

        SWIVC   XOS_Confirm             ; So sexy, huh ? Returns lowercase char
        EXIT    VS                      ; (which for Internationalisation's sake
        BLCS    AckEscape               ; we now ignore, and use the Carry flag
        SWIVC   XOS_NewLine             ; return instead!)
        EXIT    VS

        ;TEQ     r0, #"y"
        EXIT    NE

; Execute instruction out-of-line

        Push    "r1, r3, r4"
        ADR     r8, ExecuteBuffer+8
        ADR     r9, Registers
        LDMIA   r9!, {r0-r7}            ; Get + Store first 8 registers
        STMIA   r8!, {r0-r7}
        LDMIA   r9!, {r0-r6}            ; Get next 7 registers
        LDR     r14, pc_register
        AND     r14, r14, #ARM_CC_Mask
        ADR     r7, ExecuteBuffer
        ORR     r7, r7, r14             ; dumped pc -> ExecBuffer +mode +flags
        STMIA   r8!, {r0-r7}
        Pull    "r1, r3, r4"

; See if we can do any better for pc relatives in this version

        ADR     r8, ExecuteBuffer
        ADD     r14, r4, #4
        LDR     r14, [r14, r3]          ; Copy instruction(old data)into buffer
 [ debug
 DREG r14,"Instruction to execute out of line is "
 ]
        AND     r0, r14, #&0F000000     ; If it's a Bxx, correct for new loc'n
        TEQ     r0,      #&0A000000
        MOVEQ   r0, r14, LSL #8
        ADDEQ   r0, r0, r1, LSL #6      ; r0 = destination of branch-8
 [ debug
 BNE %FT00
 MOV r0, r0, LSR #6
 DREG r0,"continuing a branch, destination-8 = "
 MOV r0, r0, LSL #6
00
 ]
        SUBEQ   r0, r0, r8, LSL #6
        ANDEQ   r2, r14, #&FF000000     ; Copy condition codes + instruction
        ORREQ   r14, r2, r0, LSR #8     ; Munge back together
 [ debug
 BNE %FT00
 DREG r14,"replacing instruction with "
00
 ]
        STR     r14, ExecuteBuffer


        ADD     r0, r1, #4              ; Make a BAL to the next instruction
        ADR     r1, ExecuteBuffer+4     ; that it wants to execute after this
        BL      MakeBranch              ; one, ie. back in real program @ r1+4
        STR     r2, [r1]
 [ StrongARM
	;Best IMB the ExecuteBuffer here
	MOV	r0, #1			; Guess what? It's a ranged sync
	ADR	r1, ExecuteBuffer
	ADD	r2, r1, #ExeBufLen
	SWI	XOS_SynchroniseCodeAreas
 ]
        ADR     r0, ExecuteBuffer+8     ; and drop into ...


90 ; Nice simple continuation. r0 -> register state to continue with

        LDR     r14_svc, [r0, #15*4]
        ANDS    r14_svc, r14_svc, #SVC_mode
        BEQ     %FT95                   ; [user mode harder]

        TEQP    r14_svc, #F_bit + I_bit ; Enter correct mode, ints off
        NOP
        LDMIA   r0, {r0-pc}^            ; Restore int state, r0 never banked


95      MOV     r14_svc, r0
        LDMIA   r14_svc, {r0-r12, r13_usr, r14_usr}^
; ECN: Inserted NOP to avoid registers being trashed.
        NOP
        LDR     r14_svc, [r14_svc, #15*4]
        MOVS    pc, r14_svc             ; Jump to instruction in right mode


ContinueError1
        MOV     r14, #-1
        STR     r14, [r4, r3]           ; Only need to zap address field
        BL      message_writes
        DCB     "M41", 0
        ALIGN
        MOVVC   r10, r1
        BICVC   R10,R10,#ARM_CC_Mask
        BLVC    DisplayHexWord
        EXIT    VS
        BL      message_writes
        DCB     "M42", 0
        ALIGN
        SWIVC   XOS_NewLine
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Debug_Code

        LDR     wp, [r12]

; .............................................................................

Debug_Code_Common ENTRY "r6-r11"

10
        BL      message_writes
        DCB     "M43", 0
        ALIGN

        ADRVC   r0, StringBuffer
        MOVVC   r1, #?StringBuffer-1
        MOVVC   r2, #space
        MOVVC   r3, #255
        SWIVC   XOS_ReadLine
        EXIT    VS
        BCS     %FT50

        SWIVC   XOS_CLI

40      BLVS    PrintError
        B       %BT10

50      BL      AckEscape

        TEQ     r1, #0                  ; Any chars read ?
        EXIT    EQ                      ; VSet, return error

        SWI     XOS_NewLine             ; Need to print a NewLine as we
        SETV                            ; didn't terminate the Iine with CR/LF
        B       %BT40

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

AckEscape ENTRY "r1, r2"

        MOV     r0, #&7E
        SWI     XOS_Byte

        ADRVC   r0, ErrorBlock_Escape
        BLVC    CopyError
        EXIT

        MakeInternatErrorBlock Escape,,Escape

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PrintError ENTRY

        ADD     r0, r0, #4
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r10 = number to be displayed
;       r2 = starting bit position

; Out   r0 corrupt if error

DisplayHex ENTRY "r0, r2"

10      MOV     r0, r10, LSR r2
        AND     r0, r0, #15
        CMP     r0, #9
        ORRLS   r0, r0, #"0"
        ADDHI   r0, r0, #"A"-10
        SWI     XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS

        SUBS    r2, r2, #4
        BPL     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Out   r10 corrupt

DisplayHexWord_R9

        MOV     r10, r9

; .............................................................................

DisplayHexWord ENTRY "r2"

        MOV     r2, #32-4
        BL      DisplayHex
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r9 -> core
;       r2 = number of chars to print

; Out   VS: r0 -> error
;       VC: all preserved

DisplayCharacters ENTRY "r0, r2, r9"

10
 [ Addr26
        BIC     r9, r9, #&FC000000      ; Wrap within 64M each loop
 ]
        LDRB    r0, [r9], #1
        CMP     r0, #delete
        CMPNE   r0, #space-1
        MOVLS   r0, #"."
        SWI     XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS

        SUBS    r2, r2, #1
        BNE     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r8 = number to display

DisplayDecimalNumber ENTRY "r0-r2"

        SUB     sp, sp, #16
        MOV     r0, r8
        MOV     r1, sp
        MOV     r2, #16
        SWI     XOS_BinaryToDecimal

        ADD     r2, r2, r1
10      LDRB    r0, [r1], #1
        SWI     XOS_WriteC
        BVS     %FT90
        CMP     r1, r2
        BLT     %BT10

90      ADD     sp, sp, #16
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r9 = address to consider

MarkBreakpoints ENTRY "r2, r3"

        ADR     r2, Breaklist
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r14, [r2, r3]
        CMP     r14, r9
        MOVEQ   r0, #"*"                ; [found]
        BEQ     %FT50
        SUBS    r3, r3, #8
        BPL     %BT10
        MOV     r0, #":"                ; [not found]

50      SWI     XOS_WriteI+space
        SWIVC   XOS_WriteC
        SWIVC   XOS_WriteI+space
        EXIT

; .............................................................................

MarkPC ALTENTRY

        LDR     r14, pc_register
        BIC     r14, r14, #ARM_CC_Mask
        CMP     r14, r9
        MOVEQ   r0, #"<"                ; [found]
        MOVNE   r0, #":"                ; [not found]

        B       %BT50                   ; Share some code

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Swap old data back into core, remembering our branches

SwapAllBreakpoints ENTRY "r1-r5"

        ADR     r4, Breaklist
        ADD     r5, r4, #4              ; r5 -> old data list to index on
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        CMP     r1, #-1
        LDRNE   r2,  [r1]               ; Get our branch
        LDRNE   r14, [r5, r3]           ; Get old data
        STRNE   r2,  [r5, r3]
        STRNE   r14, [r1]
        SUBS    r3, r3, #8
        BPL     %BT10
        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Code to be relocated into RAM at initialise time

RelocatedCodeStart ROUT

        GBLA    count
count   SETA    0
        WHILE   count < nbreakpoints
        STR     r14, Registers_ROM+14*4 ; Dump current r14 directly
        BL      ClaimBreak              ; pc relative, into RAM code really
count   SETA    count + 1
        WEND

ClaimBreak
        STR     r14, TrapStore_ROM      ; Save id of breakpoint
        ADR     r14, Registers_ROM
        STMIA   r14, {r0-r13}           ; Save registers 0 to 13 in dump area
        LDR     wp, r12Store_ROM
        LDR     pc, JumpStore_ROM       ; Jump to debugger with correct wp

RelocatedCodeEnd ; End of relocated code - next instruction is a patched branch
                 ; to the debugger

 ASSERT RelocatedCodeEnd-RelocatedCodeStart = BreakCodeEnd-BreakCodeStart

TrapStore_ROM   *       (TrapStore - BreakCodeStart) + RelocatedCodeStart
Registers_ROM   *       (Registers - BreakCodeStart) + RelocatedCodeStart
r12Store_ROM    *       (r12Store  - BreakCodeStart) + RelocatedCodeStart
JumpStore_ROM   *       (JumpStore - BreakCodeStart) + RelocatedCodeStart

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; A breakpoint has been hit

BreakTrap ROUT

        SWI     XOS_EnterOS             ; And why not too!

        LDR     r1, TrapStore
        AND     r3, r1, #ARM_CC_Mask    ; Save mode and flags
        BIC     r1, r1, #ARM_CC_Mask
        ADR     r0, BreakCodeStart      ; Calculate Breakpoint number we hit
        SUB     r0, r1, r0
        SUB     r0, r0, #8
        ADR     r1, Breaklist
        LDR     r10, [r1, r0]
        ORR     r10, r10, r3
        STR     r10, pc_register        ; Save pc+psr from breakpoint

        BL      message_writes
        DCB     "M44", 0
        ALIGN

        BIC     R10,R10,#ARM_CC_Mask
        BLVC    DisplayHexWord          ; Tee hee, nowhere to go if VS! <<<
        SWIVC   XOS_NewLine

        BLVC    ShowRegs_Code_Common
        BLVC    Debug_Code_Common

        SWI     XOS_NewLine
        SWI     XOS_Exit

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> string
;       r2 -> error to generate if naff syntax (ie. no p1, trailing op or crap)

GetCommandParms_R0

        MOV     r1, r0

; .............................................................................
; In    r1 -> string
;       r2 -> error to generate if naff syntax (ie. no p1, trailing op or crap)

; Decodes string of form <addr|reg> [[+|-] <addr|reg>]

; Out   r9 = parm1
;       r8 = parm state
;       r7 = parm2

hasparm         *       2_001
parmfollowed    *       2_010
secondparm      *       2_100

; a         -> a, X
; a b       -> a, b
; a + b     -> a, a+b
; a - b     -> a-b, a
; a + b + c -> a+b, a+b+c
; a - b + c -> a-b, a-b+c

GetCommandParms ENTRY "r2"

 [ debug
 DSTRING r1, "Command tail "
        BL      %FT00
 DREG r9, "p1 ",cc
 DREG r7, " p2 ",cc
 DREG r8, " state ",,Byte
        EXIT

00
        ENTRY
 ]

        BL      ReadFirstParm           ; r7 := parm
        EXIT    VS

        TST     r8, #hasparm
        BEQ     %FT99                   ; [no parm1, so it's bad news]

        MOV     r9, r7                  ; r9 := parm1

        TST     r8, #parmfollowed
        EXIT    EQ                      ; [no parm2]

        ORR     r8, r8, #secondparm

        TEQ     r0, #"+"
        TEQNE   r0, #"-"
        BNE     %FT50

        ORR     r8, r8, r0, LSL #8      ; has '+' or '-', so skip it
        ADD     r1, r1, #1

50      BL      ReadParm                ; r7 := parm2
        EXIT    VS

        TST     r8, #hasparm            ; [no second parm when there should be]
        BEQ     %FT99                   ; [ie. after operator]

        MOVS    r14, r8, LSR #8
        BEQ     %FT80                   ; [no operator]

        TEQ     r14, #"+"               ; addition ?
        ADDEQ   r7, r9, r7              ; -> a, a+b
        SUBNE   r14, r9, r7             ; subtraction then
        MOVNE   r7, r9
        MOVNE   r9, r14                 ; -> a-b, a

        TST     r8, #parmfollowed
        EXIT    EQ                      ; [no second operator]

        TEQ     r0, #"+"                ; so we can *mi base -offset1 +offset2
        BNE     %FT99                   ;        or *mi base +offset1 +offset2

        Push    "r7, r14"               ; save r7, first operator
        ADD     r1, r1, #1              ; skip '+'
        BL      ReadParm                ; r7 := parm3
        Pull    "r1, r14"
        EXIT    VS

        TEQ     r14, #"+"               ; it does work, honest ...
        MOVEQ   r9, r1                  ; a, a+b -> a+b, a+b+c
        ADD     r7, r9, r7              ; a-b, a -> a-b, a-b+c

                                        ; and fall into ...

80      TST     r8, #parmfollowed
        EXIT    EQ                      ; [no trailing non-blank muck]


99      LDR     r0, [sp]
        SETV
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string

; Out   r7 = value of parm
;       r8 = parm state
;       r0 = next ~space char

ReadFirstParm ROUT

        MOV     r8, #0                  ; nowt so far

; .............................................................................

ReadParm ENTRY "r2"

 [ debug
 DSTRING r1, "ReadParm "
        BL      %FT00
 DREG r7, "parm ",cc
 DREG r8, ", state "
        EXIT

00
        ENTRY
 ]
        BIC     r8, r8, #hasparm + parmfollowed ; in all cases

        BL      SkipSpaces
        EXIT    CC

        ORR     r0, r0, #&20            ; Cheap and nasty lowercase

        TEQ     r0, #"r"
        BEQ     %FT50                   ; register

        TEQ     r0, #"p"
        MOVEQ   r0, #"c"                ; Expect 'c'
        LDREQ   r7, pc_register
 [ :LNOT: Addr26
        BICEQ   r7, r7, #ARM_CC_Mask    ; knock off psr bits for "pc" but not for "r15"
 ]
        BEQ     %FT60

        TEQ     r0, #"l"
        MOVEQ   r0, #"r"                ; Expect 'r'
        LDREQ   r7, Registers + 14*4
 [ :LNOT: Addr26
        BICEQ   r7, r7, #ARM_CC_Mask    ; knock off psr bits for "lr" but not for "r14"
 ]
        BEQ     %FT60

        TEQ     r0, #"s"
        MOVEQ   r0, #"p"                ; Expect 'p'
        LDREQ   r7, Registers + 13*4
        BEQ     %FT60

        TEQ     r0, #"w"
        MOVEQ   r0, #"p"                ; Expect 'p'
        LDREQ   r7, Registers + 12*4
        BEQ     %FT60


40      MOV     r0, #16                 ; allow any term, read hex
        SWI     XOS_ReadUnsigned
        MOVVC   r7, r2

45      EXIT    VS

        BL      SkipSpaces
        ORR     r8, r8, #hasparm
        ORRCS   r8, r8, #parmfollowed
        EXIT


50      ADD     r1, r1, #1
        MOV     r0, #(2_001 :SHL: 29) + 10 ; allow any term, read decimal, rest
        MOV     r2, #15
        SWI     XOS_ReadUnsigned

        ADRVC   r14, Registers
        LDRVC   r7, [r14, r2, LSL #2]   ; load register n from dump
        B       %BA45


60      LDRB    r14, [r1, #1]
        ORR     r14, r14, #&20          ; Cheap and nasty lowercase
        TEQ     r14, r0                 ; Expected ?
        BNE     %BT40                   ; give error from ReadUnsniged

        ADD     r1, r1, #2              ; skip 'pc'
        B       %BA45                   ; and skip spaces

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string
;       r0 -> error to generate if parmfollowed

; Out   r7, r8 from ReadFirstParm

ReadOneParm ENTRY "r0"

        BL      ReadFirstParm           ; r7 := parm
        EXIT    VS

        TST     r8, #parmfollowed
        LDRNE   r0, [sp]
        SETV    NE
        STRVS   r0, [sp]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string

; Out   r0 = first non-space char
;       flags from CMP r0, #space for eol detection. (CC -> r0 = CtrlChar)

SkipSpaces ROUT

10      LDRB    r0, [r1], #1
        CMP     r0, #space
        BEQ     %BT10
        SUB     r1, r1, #1      ; Leave r1 -> ~space
        MOV     pc, lr          ; r0 = first ~space

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = branch destination
;       r1 = branch location (ie. where it is executed)

; Out   r2 = branch instruction

MakeBranch ROUT

        SUB     r2, r0, r1
        SUB     r2, r2, #8
        MOV     r2, r2, ASR #2
        BIC     r2, r2, #&FF000000
        ORR     r2, r2, #&EA000000      ; BAL instruction
 [ debug
 DREG r0,"Branch instruction to get to ",cc
 DREG r1," from ",cc
 DREG r2," is "
 ]
        MOVS    pc, lr

lookup_r10 ENTRY r0-r7
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r10
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r10, r2
        EXIT

message_writes
        ENTRY   r0-r7
        BIC     r0, lr, #&fc000003
        MOV     r2, r0
10      LDRB    r1, [r2], #1
        CMP     r1, #0
        BNE     %B10
        SUB     r2, r2, r0
        ADD     r2, r2, #3
        BIC     r2, r2, #3
        ADD     lr, lr, r2
        STR     lr, [sp, #8 * 4]
        B       message_write0_tail

message_write0 ENTRY r0-r7
message_write0_tail
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #32
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        EXIT

CopyErrorP1 ENTRY r1-r7
        BL      open_messagefile
        EXIT    VS
        ADRL    R4,Debug_Title
        B       CopyError0

CopyErrorR2
        MOV     R0,R2

CopyError ENTRY r1-r7
        BL      open_messagefile
        EXIT    VS
        MOV     R4, #0
CopyError0
        ADR     R1, MessageFile_Block
        MOV     R2, #0
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.Debugger.Messages", 0

        ALIGN

open_messagefile ENTRY r0-r2
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     R0, MessageFile_Block
        ADR     R1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ rp0512

memorytest2
;for memorya - only allow values <&3000000
  STMFD R13!,{R7-R9,R14}
  CMP R7,#&3000000
  CMPLT R9,#&3000000
  BHS bad_write_addr
  B memtest

memorytest
  STMFD R13!,{R7-R9,R14}
memtest
  ;address range=R9 to R7

  ;under <&2000000 call OS_ValidateAddress
  ;no if within &3000000-&33FFFFF
  ;yes if &3400000-&3FFFFFF

  ;is high address above validated area ?
  CMP r7,#&2000000
  BHS above_logical

  ;feed both through OS_ValidateAddress
  MOV r0,r9
  MOV r1,r7
  SWI XOS_ValidateAddress
  BCS bad_addr
values_ok
  LDMFD R13!,{R7-R9,R15}


above_logical
  ;is low address below this range
  CMP r9,#&2000000
  BHS not_logical

  ;validate from low address to end of logical ram
  MOV r0,r9
  MOV r1,#&2000000
  SUB r1,r1,#1
  SWI XOS_ValidateAddress
  BCS bad_addr

not_logical
  ;now bounce if either involve, or pass &3000000-&33FFFFF
  ;logic - if low addr<&33FFFFF and hi>&3000000 bounce it - crosses the range
  ;then bounce if either is within the range &3000000-&33FFFFF

  MOV r8,#&3400000
  SUB r8,r8,#1

  CMP r9,r8
  BHS values_ok ;lower is >end of area, so higher must be

  CMP r7,#&3000000
  BLT values_ok ; higher is before area, so lower must be

bad_addr
  ADR R0,badaddr
bad_common
  LDMFD R13!,{R7-R9,R14} ;recover regs and return for BL
  LDMFD R13!,{R6-R11,R14}
  B CopyError

bad_write_addr
  ADR R0,badwrite
  B bad_common

badaddr
  DCD ErrorNumber_CoreNotReadable
  = "BadRead",0
  ALIGN

badwrite
  DCD ErrorNumber_CoreNotWriteable
  = "BadWrt",0
  ALIGN

 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


        LTORG

 [ debug
        InsertDebugRoutines
 ]

        END
