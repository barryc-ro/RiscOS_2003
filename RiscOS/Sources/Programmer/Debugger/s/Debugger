        TTL     > Debugger.s.Debugger - ARM/RISC OS debugger (principally for machine code)

; Authors:      Roger Wilson (Brazil version)
;               Andrew F. Powis (Arthur version)
;               Stuart K. Swales (Arthur fixes/enhancements)
;               Tim Dobson (Adjusting headers, ARM600 variant)
;               Alan Glover (fixes/enhancements, ARM6/ARM7 instructions)
;		William Turner (StrongARM compatibility)
;		Kevin Bracey (Architecture 4 instructions, fixes)

; 1.18  SKS     Fixed disassembly of #xx,yy operands
; 1.19  SKS     Fixed disassembly of LSR #32, ASR #32
;               Comment where LDR pc relative comes from
; 1.20  SKS     Fixed fp/coproc disassembly, memoryi/memorya parameters
; 1.21  SKS     Fixed *debug response wrt ESCape
; 1.22  SKS     Fixed memory wrt wrapping at 64M

; ---- Released for Arthur 2.00 ----

; 1.22  TMD 22-Nov-89    Fixed source to assemble again with new headers,
;                        and with new AAsm which objects to DCD rel.sym.
;                        (shouldn't affect object file)
;
; 1.23  AMG 30-Oct-90    Various fixes/enhancements
;                        1. ADR made from ADD/SUB Rn,R15,#nn
;                        2. SWP/SWPB now recognised, with >ARM2 warning
;                        3. LDR/STR and LDF/STF now decode PC relative addressing
;                           in the instruction, not the comment field
;                        4. MRC/MCR to CP15 (ie ARM3 control) are commented
;                        5. Comment position moved in for longer comments
;                        6. Silly code detection and indication added...
;                           a) NV condition code
;                           b) SWI following a CDP
;                           c) MUL Rx,Rx or MUL R15,Rx
;                           d) LDM/STM with ^ and !
;                           e) LDM with ^ - bank switches
;                           f) Use of R8-R14 after a xxxP instruction
; 1.24  ENevill ??-Mar-91
;                        Text extraction, untested I think - AMG
;
; 1.25  AMG 11-Mar-91    Fixed disassembly of ADD rd,R15,rm as an ADR
;                        Change OS_Confirm usage to use EQ flag, not ASCII Y
;
; **** Version 1.24 and 1.25 have not been tested, though the bug fix
;      in 1.25 has been checked using 1.23's source.
;
; 1.26  AMG 12-Mar-91    Altered wacky shift coding to give
;                        ADD R0,R0,#0,ROR #24 instead of
;                        ADD R0,R0,#0,24 which confuses people
;
; **** This version is also untested, but changes made have been checked
;      with 1.23's source again
;
; 1.27  ECN 15-Mar-91    Internationalised
; 1.27  ECN 08-Apr-91    Fixed logic of MCR/MRC disassembly.
;                        Bit 20 = 0 => MCR, = 1 => MRC
;                        Internal ARM datasheet is wrong wrt MCR/MRC
;                        VLSI datasheet and assemblers are correct
; 1.27  ECN 19-Apr-91    Fixed "Enter new value" message in MemoryA

; 1.28  AMG 25-Apr-91    Corrected 'use ! and ^' message in messages file.
;                        Added BadSWI error for unused SWIs and associated
;                          message
;
; 1.29  AMG 10-May-91    Used mask &FC000000 instead of &FC000003 to force
;                        LDR/STR into addressing range since it was
;                          messing up LDRB R0,[PC,#1] disassembly
;
; 1.30  AMG 23-May-91    Use global Bad SWI message.
;                        Sort out Message Token not found for bad syntax
;                          to MEMORYI & MEMORY
;
; 1.31  amg 31-May-91    Change invalid instruction used by InitStore to
;                          &E6000010 - which is still invalid - the old
;                          one, &E1000090, is now a SWP instruction!
;                        Added new FPA  URD and NRM instructions
;
; 1.32  amg 05-Jun-91    Added new FPA  LFM/SFM instructions. While in that
;                          area also fixed a bug where coproc offsets were
;                          treated as a 12 bit number, not an 8 bit one.
;
; 1.33  amg 21-Jun-91    Bugfix: Use Global copy of 'Escape' error message
;
; 1.34  amg 18-Jul-91    Tidy up internationalisation to save some space.
;
; 1.36  ECN 07-Aug-91    Inserted NOP after LDM forcing user bank followed
;                        by access to banked register.
;
; 1.37  amg 26-Nov-91    RP-0512 (hang accessing &3000000 - empty IO slot)
;                        Add address validation as below
;                        &0000000-&1ffffff - Use OS_ValidateAddress
;                        &2000000-&2ffffff - No checks (always present)
;                        &3000000-&33fffff - No access (I/O areas)
;                        &3400000-&3ffffff - Read access only (ROMs)
;                                              (writes=VIDC or MEMC)
;                        MEMORYA will trap interactive mode going into
;                        a read-only/no access area too.
;
; 1.38  amg 24-Jan-92    Repaired non-interactive MEMORYA (RP-0970)
;
; 1.39  amg 13-Apr-92    Revert fix of Rp-0512 to a switchable flag,
;                        off by default

; ---- Released for RISC OS 3.10 ----

; 1.40  TMD 27-Jul-92    Added variant for ARM600 which doesn't wrap
;                        addresses at 64M
;
; 1.41  ECN 10-Aug-93    Internationalised help/syntax messages
;
; 1.42  TMD 27-Oct-93    Fixed bug MED-00167 - coprocessor data transfers to
;                        PC-relative address were disassembled wrong.
; 1.43  TMD 01-Dec-93    Fixed bug MED-01490 - couldn't set breakpoints
;                         above 32MB (eg in RMA!).
; 1.44  amg 23-Jan-94    Catch up on new ARM6/7 opcodes: MRS, MSR, MULL, MLAL and
;                         check conformance with FPA10 spec. Tighten up tests
;                         for MUL/MULL/SWP - now insist b7:b4=2_1001
;                        Add national switch to override internationalised help/syntax

; ---- Released for RISC OS 3.60 ----

; 1.46  WT  07-Feb-96    Made StrongARM compatible (breakpoint code breaks IDcache)
; 1.48  KJB 04-Jun-96    Added ARMv4 instructions (BX, LDR[H|SH|SB], STRH)
;                        SWP wasn't being disassembled
;			 CP15 comments amended to ARMv4
;			 ARM3 warning removed from SWP (after all, MRS,
;			   MULL etc don't have warnings!)

; ---- Released for RISC OS 3.70 ----

; 1.49  KJB 07-Oct-96    Operation code of MRC, MCR was shown times 2.
;			 FLT was showing wrong dest reg, with registers
;			   shown in wrong order.
;			 WFC etc were showing precision.
;			 Unknown FP opcodes now shown as normal coprocessor
;			   operations.
;			 LDC/STC (and FP derivatives) didn't detect
;			   post-indexing with no writeback. Now reported as
;			   undefined instructions.
;			 UMULLEQS no longer pushes registers into the
;			   comment field.
;			 MSR/MRS now specified as described in ARM
;			   Architecture Reference 4.
; 1.50  KJB 10-Oct-96    Lots of warnings added.
;			 More FP opcodes tightened up.
;			 PC-relative load/store with writeback no longer
;                         shown as simple ADR.
;                        Thumb disassembly added.
; 1.51  KJB 29-Oct-96    Bugs introduced by 1.49 and 1.50 fixed.
;                        Warnings added to the LDRH family to match LDC and LDR.
;                        Warning about StrongARM STM^ bug added.
;                        Source code tidied up and simplified with macros.
; 1.52  KJB 06-Nov-96    More bug fixes.
;                        StrongARM warning revised following Digital guidelines.
; 1.53  KJB 11-Nov-96    SWI called checkreg for no apparent reason.
;                        Stopped Addr26 screwing up Thumb disassembly.
;                        Set Addr26 to True.
; 1.54  KJB 27-Mar-98    Test for post-indexed LDRH etc with W set didn't work.
;                        Service call table added.
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:EnvNumbers
        GET     Hdr:Proc
        GET     Hdr:VduExt
        GET     Hdr:Tokens
        GET     Hdr:MsgTrans

        GET     Hdr:Debugger

        GET     Version

        GET     Hdr:Debug

        GBLL    debug
debug   SETL    False
;debug   SETL    True

        GBLL    rp0512
rp0512  SETL    False ;False = do not implement RP0512 bug fix coding

        GBLL    Addr26
Addr26  SETL    True ; true for 26 bit wrap on addresses

        GBLL    national
national SETL   False

	GBLL	StrongARM
StrongARM SETL  True

	GBLL	WarnSArev2
WarnSArev2	SETL False	; Warn about hitting the SA revision 2 STM^ bug

	GBLL	Thumb
Thumb	SETL	True


; Continue not up to much

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Debug global workspace

                ^       0, wp

; Breakpoint code section - keep layout same as RelocatedCode section

nbreakpoints    *       16

BreakCodeStart  #       nbreakpoints*8  ; Breakpoint entry code segments
                #       4*5             ; Save other registers before JMP
BreakCodeEnd    #       0               ; End of copied area

; Areas accessed pc relative by relocated breakpoint code

TrapStore       #       4               ; Store for breakpoint id
Registers       #       4*16            ; Register dump area
pc_register     *       Registers + 4*15 ; dumped pc
r12Store        #       4               ; r12 for breakpoint code
JumpStore       #       4               ; address of breakpoint code in ROM

Breaklist       #       nbreakpoints*8  ; List of addresses, old data

OldExceptionDumpArea #  4               ; Old exception register dump area

WindowWidth     #       4
BytesPerLine    #       4

Mistake         #       4               ;potential error number

OldAddress      #       4               ;address of last instruction
 [ Thumb
OldThumbAddress #       4               ;address of last Thumb instruction
OldThumbInst	#	4		; last Thumb instruction disassembled
 ]

MessageFile_Block #     16              ; File handle for MessageTrans
MessageFile_Open  #     4               ; Opened message file flag

StringBuffer    #       160             ; Temp string buffer. Big enough to
                                        ; hold a disassembled instruction
                                        ; and a full register set + two instrs
TotalSpace      *       :INDEX: @

; List of mistakes

		^	1
Mistake_NV	#	1
Mistake_PlingHat #	1
Mistake_Banked	#	1
Mistake_SWICDP	#	1
Mistake_MUL	#	1
Mistake_R15shift #	1
Mistake_R15	#	1
Mistake_PCwriteback #	1
Mistake_BytePC	#	1
Mistake_StorePC	#	1
Mistake_Unpred	#	1
Mistake_RdRn    #       1
Mistake_RmRn	#	1
Mistake_RdLoRdHi #	1
Mistake_RdLoRm	#	1
Mistake_RdHiRm	#	1
Mistake_Rninlist #	1
Mistake_RdRm	#	1
Mistake_STMHat	#	1

		^	-1
Potential_SWICDP #	-1
Potential_Banked #	-1
Potential_Banked_Next # -1
Potential_SWICDP_Next #	-1

; Overlaid workspace

 [ StrongARM
ExeBufLen	*	4+4+4*16
 ]

                ^       :INDEX: StringBuffer, wp
CoreBuffer      #       16              ; Enough for a line of bytes
 ASSERT ?StringBuffer >= ?CoreBuffer

                ^       :INDEX: StringBuffer, wp
 [ StrongARM
ExecuteBuffer   #       ExeBufLen
 |
ExecuteBuffer   #       4+4+4*16
 ]
 ASSERT ?StringBuffer >= ?ExecuteBuffer

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Useful constants

TAB     *       9
LF      *       10
CR      *       13
space   *       " "
quote   *       """"
colon   *       ":"
delete  *       &7F

; Useful macros

; AddChar - Add a character (possibly conditionally) to the disassembly
;           eg  AddChar "B",NE
	MACRO
	AddChar	  $c,$cond
	MOV$cond  R10,#"$c"
	STR$cond.B R10,[R0],#1
	MEND

; AddStr - Add a string (possibly conditionally) to the disassembly,
;          optionally adding the ARM condition field - eg
;              AddStr BX_string,,conds
	MACRO
	AddStr	$c,$cond,$conds
	ADR$cond R10,$c
	[ "$conds" <> ""
	  BL$cond  SaveStringConditions
	|
	  BL$cond  SaveString
	]
	MEND

; TestBit - check to see if a bit is set, and add one of two characters
;           depending on that bit. Needn't add a character in both
;           or indeed either case; exits with Z bit set appropriately.
;              eg    TestBit 24,"L"
	MACRO
	TestBit	$bit,$set,$unset
	TSTS	R4,#1:SHL:$bit
	[ "$set" <> "" :LAND: "$unset" <> ""
	MOVEQ	R10,#"$unset"
	MOVNE	R10,#"$set"
	STRB	R10,[R0],#1
	|
	  [ "$set" <> ""
	  AddChar "$set",NE
	  ]
	  [ "$unset" <> ""
	  AddChar "$unset",EQ
	  ]
	]
	MEND

; TestStr - check to see if a bit is set, and add one of two strings
;           depending on that bit. Needn't add a string in both
;           cases. Optionally add the ARM condition field. eg
;                  TestStr 20,Ldr,Str,conds
	MACRO
	TestStr	$bit,$set,$unset,$conds
	TSTS	R4,#1:SHL:$bit
	[ "$set" <> "" :LAND: "$unset" <> ""
	ADREQ	R10,$unset
	ADRNE	R10,$set
	  [ "$conds" <> ""
	  BL	SaveStringConditions
	  |
	  BL	SaveString
	  ]
	|
	  [ "$set" <> ""
	  AddStr   $set,NE,$conds
	  ]
	  [ "$unset" <> ""
	  AddStr   $unset,EQ,$conds
	  ]
	]
	MEND

ARM_Addr_Mask * &FC000000 ; local mask to avoid knocking off byte offsets

        LEADR   Module_LoadAddr

Module_BaseAddr

        DCD     0
        DCD     Debug_Init - Module_BaseAddr
        DCD     Debug_Die - Module_BaseAddr
        DCD     Debug_Service - Module_BaseAddr
        DCD     Debug_Title - Module_BaseAddr
        DCD     Debug_HelpStr - Module_BaseAddr
        DCD     Debug_HC_Table - Module_BaseAddr
        DCD     Module_SWISystemBase + DebuggerSWI * Module_SWIChunkSize
        DCD     Debug_SWI_Code - Module_BaseAddr
        DCD     Debug_SWI_Name - Module_BaseAddr
        DCD     0
 [ International_Help <> 0
        DCD     message_filename - Module_BaseAddr
 |
        DCD     0
 ]

Debug_Title ; share with
Debug_SWI_Name
        DCB     "Debugger", 0           ; SWI class
        DCB     "Disassemble", 0        ; +0
 [ Thumb
	DCB	"DisassembleThumb", 0	; +1
 ]
        DCB     0

Debug_HelpStr
        DCB     "Debugger", TAB, "$Version ($CurrentDate)", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Debug_Init ENTRY

        LDR     r2, [r12]               ; Hard or soft init ?
        TEQ     r2, #0
        BNE     %FT00

; Hard init

        LDR     r3, =TotalSpace         ; Claim module workspace
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        EXIT    VS                      ; 'No room' good enough error

        STR     r2, [r12]

00      MOV     wp, r2


        ADRL    r0, RelocatedCodeStart  ; fwd ref
        MOV     r3, #BreakCodeEnd - BreakCodeStart
01      SUBS    r3, r3, #4              ; Move breakpoint code to RAM
        LDRPL   r1, [r0, r3]
        STRPL   r1, [r2, r3]
        BPL     %BT01

 [ StrongARM
	MOV	r0, #1
	MOV	r1, r2
	ADD	r2, r1, #(nbreakpoints*8)
	SWI	XOS_SynchroniseCodeAreas
 ]

        ADRL    r14, BreakTrap          ; Address of breakpoint code in ROM
        STR     r14, JumpStore          ; fwd ref
        STR     wp, r12Store            ; A good idea to initialise it

        ADR     r1, Breaklist           ; Clear breakpoint list
        MOV     r3, #nbreakpoints
        MOV     r14, #-1
10      STR     r14, [r1], #8           ; Only need to zap address field
        SUBS    r3, r3, #1
        BNE     %BT10

        ADR     r1, Registers           ; Clear register dump area
        MOV     r3, #16
        MOV     r14, #0
        STR     r14, MessageFile_Open
20      STR     r14, [r1], #4
        SUBS    r3, r3, #1
        BNE     %BT20

        MOV     r0, #ExceptionDumpArea  ; Change exception register dump area
        ADR     r1, Registers
        SWI     XOS_ChangeEnvironment
        STRVC   r1, OldExceptionDumpArea

        MOV     r3, #0
        STR     R3, Mistake
        STR     R3, OldAddress          ;Init vars for dodgy code detection
	[ Thumb
	STR	R3, OldThumbAddress
	STR	R3, OldThumbInst
	]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    no registers trashable

        ALIGN
Debug_ServiceTable
	DCD	0
	DCD	Debug_ServiceBody - Module_BaseAddr
	DCD	Service_Reset
	DCD	0

	DCD	Debug_ServiceTable - Module_BaseAddr
Debug_Service ROUT
	MOV	r0, r0
        TEQ     r1, #Service_Reset
        MOVNE   pc, lr

Debug_ServiceBody
        ENTRY   "r0, r1"
        LDR     wp, [r12]
        MOV     r0, #ExceptionDumpArea          ; Set exception dump area
        ADR     r1, Registers
        SWI     XOS_ChangeEnvironment
        STRVC   r1, OldExceptionDumpArea
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Debug_Die ENTRY

        LDR     wp, [r12]

        BL      SwapAllBreakpoints      ; Be nice

        MOV     r0, #ExceptionDumpArea  ; Restore old exception dump area
        MOV     r1, #0                  ; if current one is us
        SWI     XOS_ChangeEnvironment
        ADR     r14, Registers
        TEQS    r14, r1
        MOVEQ   r0, #ExceptionDumpArea
        LDREQ   r1, OldExceptionDumpArea
        SWIEQ   XOS_ChangeEnvironment
        LDR     r0, MessageFile_Open
        TEQS    r0, #0
        ADRNE   r0, MessageFile_Block
        SWINE   XMessageTrans_CloseFile
	MOV	r0, #0
	STR	r0, MessageFile_Open

        EXITS                           ; Don't refuse to die

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;                        (No. of Parameters)

Debug_HC_Table ; Name       Max  Min

        [ national
        Command BreakClr,    1,   0,
        Command BreakList,   0,   0,
        Command BreakSet,    1,   1,
        Command Continue,    0,   0,
        Command Debug,       0,   0,
        Command InitStore,   1,   0,
        Command Memory,      4,   1,; B R + R
        Command MemoryA,     3,   1,; B R V
 [ Thumb
        Command MemoryI,     6,   1,; T A +/- B + C
 |
        Command MemoryI,     5,   1,; A +/- B + C
 ]
        Command ShowRegs,    0,   0,
        |
        Command BreakClr,    1,   0, International_Help
        Command BreakList,   0,   0, International_Help
        Command BreakSet,    1,   1, International_Help
        Command Continue,    0,   0, International_Help
        Command Debug,       0,   0, International_Help
        Command InitStore,   1,   0, International_Help
        Command Memory,      4,   1, International_Help     ; B R + R
        Command MemoryA,     3,   1, International_Help     ; B R V
 [ Thumb
        Command MemoryI,     6,   1, International_Help     ; T A +/- B + C
 |
        Command MemoryI,     5,   1, International_Help     ; A +/- B + C
 ]
        Command ShowRegs,    0,   0, International_Help
        ]

        DCB     0                       ; end of table

        GET     TokHelpSrc
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = instruction to disassemble
;       r1 = address to disassemble relative to (bug in 1.00 debug did relative
;                                                to module base only !)

; Out   r1 -> core containing string
;       r2 = length of string excluding 0 terminator

Debug_SWI_Code ENTRY "r9"

        LDR     wp, [r12]
        TEQ     R11,#0 ;only one SWI
        BEQ     swi00
 [ Thumb
	TEQ	R11,#1
	BEQ	swi01
 ]

        ADR     R0,ErrorBlock_ModuleBadSWI
        BL      CopyErrorP1

        EXIT

        MakeInternatErrorBlock ModuleBadSWI,,BadSWI

swi00
        LDR     R14,Mistake

        CMPS    R14,#Potential_Banked_Next  ;potential error if a banked access occurs (after LDM)
        MOVEQ   R14,#Potential_Banked
        CMPS    R14,#Potential_SWICDP_Next  ;potential error if a SWI occurs (after coproc)
        MOVEQ   R14,#Potential_SWICDP

        STR     R14,Mistake

        MOV     R9, R1
        BL      Instruction

        LDR     R14,Mistake

        CMPS    R14,#Potential_Banked
        CMPNES  R14,#Potential_SWICDP
        MOVEQ   R14,#0

        STREQ   R14,Mistake

        EXIT                           ; Preserve flags

 [ Thumb
swi01
	MOV	R9,R1
	BL	ThumbInstruction

	EXIT
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkreg
        STMFD   R13!,{R14}
        LDR     R14,Mistake
        CMPS    R14,#Potential_Banked
        MOVEQ   R14,#Mistake_Banked
        STR     R14,Mistake
        LDMFD   R13!,{R15}


; In    r0 = instruction to disassemble
;       r9 = where it is

; Out   r1 -> core containing string
;       r2 = length of string including 0
;       r10,r11 corrupt

Instruction ENTRY "r0, r3-r9"

        SUB     R4, R9, #4
        LDR     R5, OldAddress
        TEQS    R4, R5
        MOV     R4, #0
        STRNE   R4, Mistake         ;not going in sequence, so forget context
        STR     R9, OldAddress      ;save for next time

        MOV     r4, r0

        ADR     r0, StringBuffer        ; Always build into temp buffer

 [ debug :LAND: True
        MOV     r14, #0                 ; zap buffer
        MOV     r3, #?StringBuffer-4
00      STR     r14, [r0, r3]
        SUBS    r3, r3, #4
        BPL     %BT00
 ]

        MOV     r3, r4, LSR #24         ; r3 := primary instruction nibble
        AND     r3, r3, #2_00001111     ; remove condition codes
        TEQS    r3, #&0F
        BEQ     Swi                     ; [software interrupt = 0F]

        CMP     r3, #&0C
        BHS     Coprocessor             ; [coproc 0C..0E]

        CMP     r3, #&0A
        BHS     Branch                  ; [branch = 0A..0B]

        CMP     r3, #&08
        BHS     LdmStm                  ; [load/store multiple = 08,09]

        CMP     r3, #&04
        BHS     LdrStr                  ; [load/store register = 04..07]

        B       DataProcessing          ; [data processing = 00.03]

; .............................................................................

Undefined
	ADR	r0, StringBuffer	; Reset pointer
        ADR     r10, Unknown
        BL      lookup_r10

; .............................................................................
; In    r0 -> buffer to be terminated. registers stacked as for entry
;       r10 -> string to be appended first

SaveStringEnd

        BL      SaveString

; .............................................................................
; In    r0 -> buffer to be terminated. registers stacked as for entry

; Out   r1 -> completed buffer
;       r2 = length of buffer

InstructionEnd

        BL      TestMistakes

        MOV     r14, #0
        STRB    r14, [r0]

        ADR     r1, StringBuffer
	SUBS	r2, r0, r1		; Clears V flag

	EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Software interrupt

	; arrive here with cccc 1111 xxxx xxxx xxxx xxxx xxxx xxxx
	; format is        cccc 1111 nnnn nnnn nnnn nnnn nnnn nnnn
	;
	; SWI{cond} <number|name>
	;
	; where cccc = condition
	;       nnnn = number

Swi     LDR     R10, Mistake
        CMP     R10, #Potential_SWICDP
        MOVEQ   R10, #Mistake_SWICDP
        STREQ   R10, Mistake

	AddStr	Swi_Instruction,,conds

        BL      Tab

        MOV     r1, r0
        ADR     r2, StringBuffer+?StringBuffer
        SUB     r2, r2, r1
        BIC     r0, r4, #&FF000000      ; Mask out SWI<cc>
        SWI     XOS_SWINumberToString   ; This may give error (eg. Buffer over)

        SUBVC   R2,R2,#1                ;adjust to avoid taking the zero byte
        ADDVC   r0, r1, r2
        B       InstructionEnd


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Branch, Branch and Link

	; arrive here with cccc 101x xxxx xxxx xxxx xxxx xxxx xxxx
	; format is        cccc 101l oooo oooo oooo oooo oooo oooo
	;
	; B{L}{cond} address
	;
	; where cccc = condition
	;          l = Link
	;          o = 24-bit signed offset (in words)

Branch ROUT

	AddChar	"B"
	TestBit	24,"L"

        BL      Conditions

        BL      Tab

 [ Addr26
        ADD     r8, r9, r4, LSL #2      ; Form offset from required address
 |
        MOV     r8, r4, ASL #8          ; shift offset up to top
        ADD     r8, r9, r8, ASR #6      ; convert to signed offset and add
 ]

BranchLdrStrCommon
        ADD     r8, r8, #8              ; pc advanced by 8
 [ Addr26
        BIC     r8, r8, #ARM_Addr_Mask    ; Wrap in 64MByte space
 ]
        MOV     r2, #32-4                 ; (keeping byte offsets)
        BL      StoreHex

        B       InstructionEnd

Unknown DCB     "M00", 0		; "Undefined instruction"
Swi_Instruction
        DCB     "SWI", 0
Ldm     DCB     "LDM", 0
Stm     DCB     "STM", 0
W_Back  DCB     "!,{", 0
        ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Load and store multiple

	; arrive here with cccc 100x xxxx xxxx xxxx xxxx xxxx xxxx
	; format is        cccc 100p uswl nnnn rrrr rrrr rrrr rrrr
	;
	; <LDM|STM>{cond}<I|D><A|B> Rn{!},register list{^}
	;
	; where cccc = condition
	;          p = Pre-indexing/~Post-indexing
	;          u = Up/~Down
	;          s = the ^ bit (transfer user registers, or restore PSR)
	;          w = Writeback
	;          l = Load/~Store
	;       nnnn = Rn
	;       rrrr = register list
LdmStm ROUT

        ANDS    R5, R4, #&7F00
        BLNE    checkreg        ;error if R8-R14 in list

        ;test for silly conditions - ldm/stm ! and ^ with R15 not in list is bad,
        ;and LDM ^ with R15 not in the list is a deferred bank error

        TestBit	15
        BNE     notbad ;R15 in list

        TestBit	22
        BEQ     notbad ;not forcing user

        ;case 1 - ! too
        TestBit	21
        MOVNE   r10, #Mistake_PlingHat
        STRNE   r10, Mistake
        BNE     notbad2 ;don't bother with next test

        ;case 2 - LDM
        TestBit	20
        MOVNE   r10,#Potential_Banked_Next
        STRNE   r10,Mistake
	BNE	notbad2 ; don't bother with next test

notbad
	;case 3 - Rn in list with writeback
	TestBit	21
	BEQ	notbad3
	MOV	r10, r4, LSR #16
	AND	r10, r10, #2_1111
	MOV	r14, #1
	TSTS	r4, r14, LSL r10
	MOVNE	r10,#Mistake_Rninlist
	STRNE	r10,Mistake
	BNE	notbad2

notbad3
	;case 4 - storing PC
	AND	r14, r4, #1 :SHL: 20 :OR: 1 :SHL: 15
	TEQ	r14, #1 :SHL: 15
	BNE	notbad2
	; okay, we're storing PC, but complaining about APCS would be boring.
	; Therefore don't bother whinging about STMFD R13!,{[any R0-R9],R11,R12,R14,PC}
	AND	r14, r4, #2_1111 :SHL: 21
	TEQ	r14, #2_1001 :SHL: 21		; Check FD, !, and no ^
	ANDEQ	r14, r4, #2_1111 :SHL: 16
	TEQEQ	r14, #13 :SHL: 16		; Check R13
	ANDEQ	r14, r4, #2_1111110000000000
	TEQEQ	r14,     #2_1101100000000000
	MOVNE	r10,#Mistake_StorePC
	STRNE	r10,Mistake

notbad2
	TestStr	20,Ldm,Stm,conds        ; Load/~Store bit

	TestBit	23,"I","D"              ; Up/~Down bit

	TestBit	24,"B","A"              ; Pre/~Post bit

        MOV     r5, r4, LSR #16         ; Rn
	AND	r5, r5, #2_1111
	TEQS	r5, #15
	MOVEQ	r14, #Mistake_R15
	STREQ	r14, Mistake
        BL      Tab_Dis_Register

        TST     r4, #1 :SHL: 21         ; Writeback bit
        ADR     r10, W_Back
        ADDEQ   r10, r10, #1            ; just do ',{'
        BL      SaveString

; Register list

        MOV     r5, #0		; Current register
 [ WarnSArev2
	MOV	r7, #0		; Total registers
 ]
        MOV     r8, #0		; Registers in current group

RegList ADD     r2, r5, #1
        TST     r2, r4, LSR r2
        BCC     Next

        TEQ     r8, #0
        BLNE    AddComma

        BL      Dis_Register
        ADD     r5, r5, #1
 [ WarnSArev2
	ADD	r7, r7, #1
 ]
        TEQS    r5, #16
        BEQ     Xxm_End

        ADD     r2, r5, #1
        TSTS    r2, r4, LSR r2
        MOV     r8, #1
        BCC     Next                    ; If next reg not done, loop

Count   ADD     r8, r8, #1
        ADD     r5, r5, #1              ; Count registers
        TEQS    r5, #16
        BEQ     Group

        ADD     r2, r5, #1
        TSTS    r2, r4, LSR r2
        BCS     Count

; Group or single register

Group   MOV     r6, #","
        CMPS    r8, #3
        MOVHS   r6, #"-"
        STRB    r6, [r0], #1

        SUB     r5, r5, #1
        BL      Dis_Register
 [ WarnSArev2
	ADD	r7, r7, r8
	SUB	r7, r7, #1
 ]

Next    ADD     r5, r5, #1
        TEQS    r5, #16
        BNE     RegList

Xxm_End
        AddChar	"}"                     ; end register list

	TestBit	22,"^"                  ; '^' bit

	[ WarnSArev2
	BEQ	InstructionEnd		; It's not ^
	TestBit	20
	BNE	InstructionEnd		; It's not a store

	; If we have more than 1 register in a STM user bank,
	; then it may fail on early StrongARMs
	CMPS	r7, #1
	MOVHI	r10, #Mistake_STMHat
	STRHI	r10, Mistake
	]

        B       InstructionEnd

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Load or store register

LdrStr	ROUT
	; Load and Store Word or Byte
	; arrive here with cccc 01xx xxxx xxxx xxxx xxxx xxxx xxxx
	; (nn != 00)
	; format is        cccc 010p ubwl nnnn dddd rrrr rtt0 mmmm
	;        or        cccc 011p ubwl nnnn dddd iiii iiii iiii
	;
	; <LDR|STR>{cond}{B}    Rd,[Rn,#offset]{!}
	; 	                Rd,[Rn,{+|-}Rm{,shift}]{!}
	; <LDR|STR>{cond}{B}{T} Rd,[Rn],#offset
	;                       Rd,[Rn],{+|-}Rm{,shift}
	; where cccc = condition
	;          i = Immediate/~Register offset
	;	   p = Pre-indexed/~Post-indexed
	;	   u = Up/~Down
	;	   b = Byte/~Word
	;	   w = Writeback (or T bit if post-indexed)
	;          l = Load/~Store
	;       nnnn = Rn
	;       dddd = Rd
	;      rrrrr = shift amount
	;         tt = shift type (LSL, LSR, ASR or ROR)
	;       mmmm = Rm
	;       iiii = 12-bit unsigned immediate offset

        TST     r4, #1 :SHL: 25         ; If Rm and shift and trying Rs
        TSTNE   r4, #1 :SHL: 4          ; then that was xxR Rd,[Rn,Rm,SHF Rs]
        BNE     Undefined               ; but ARM2 doesn't do that anymore

	TestStr	20,Ldr,Str,conds        ; Load/~Store bit

        MOV     r5, r4, LSR #12         ; Rd
	AND	r5, r5, #2_1111

        TST     r4, #1 :SHL: 22         ; Byte/~Word bit
	BEQ	%FT01

	AddChar	"B"
	TEQS	r5, #15
	MOVEQ	r10, #Mistake_BytePC
	STREQ	r10, Mistake
	BEQ	%FT03

1	TEQS	r5, #15
	TSTEQS	r4, #1 :SHL: 20
	MOVEQ	r10, #Mistake_StorePC
	STREQ	r10, Mistake

3       AND     r10, r4, #2_1001 :SHL: 21
        TEQS    r10,     #2_0001 :SHL: 21 ; postincrement with writeback ?
	AddChar	"T",EQ                    ; -> T(ranslate)

        BL      Tab_Dis_Register	; uses r5 from above

	; Check for writeback LDR/STR with Rd=Rn
        AND     r10, r4, #2_1001 :SHL: 21
	TEQS	r10, #2_1000 :SHL: 21
	BEQ	%FT10			; if not writeback, okay

	TestBit	25
	BNE	%FT05
	MOVS	r14, r4, LSL #32-12
	BEQ	%FT10			; zero offset, so okay

5	AND	r14, r4, #2_1111 :SHL: 12
	AND	r10, r4, #2_1111 :SHL: 16
	TEQS	r10, r14, LSL #4
	MOVEQ	r10, #Mistake_RdRn
	STREQ	r10, Mistake

	; Check for post-indexed LDR/STR with Rm=Rn
10	AND	r14, r4, #2_11000 :SHL: 21
	TEQS	r14, #2_10000 :SHL: 21
	BNE	%FT20
	AND	r14, r4, #2_1111 :SHL: 16
	AND	r10, r4, #2_1111
	TEQS	r10, r14, LSR #16
	MOVEQ	r10, #Mistake_RmRn
	STREQ	r10, Mistake

20
DataTransfer_Common ; for CPDT - address part similar to LDR/STR (no reg index)

        ;from 1.23, show resultant LDR/STR Rx,[R15,#nnn] address directly

        MOV     R5,R4,LSR #16
        AND     R5,R5,#15
	TEQ	R5,#15
	BNE	not_rel

	TestBit 21
	MOVNE	r10, #Mistake_PCwriteback
	STRNE	r10, Mistake
	TestBit	24
	MOVEQ	r10, #Mistake_PCwriteback
	STREQ	r10, Mistake

	AND	r14,R4,#2_11001 :SHL: 21
	TEQS	r14,#2_01000 :SHL: 21
	BNE	not_rel

	AddChar	","
        MOV     R8,R4,LSL #32-12
        MOV     R8,R8,LSR #32-12

; offset in LDC/STC instructions is a word offset

        TestBit	27		        ; if a coproc data transfer
        MOVNE   r8, r8, LSL #2          ; then multiply offset by 4

        TestBit	23		        ; Up/~Down bit
        SUBEQ   r8, r9, r8              ; Form offset from required address
        ADDNE   r8, r9, r8

        B       BranchLdrStrCommon

not_rel
	AddStr	Open_B                  ; ',['

        MOV     r5, r4, LSR #16         ; Rn
        BL      Dis_Register

	TestStr	24,Close_B+1,Close_B    ; Pre/~Post bit - just ',' else '],'

	TestBit	25        		; Shift/~Immediate bit
        BNE     %FT90

; Immediate offset

	AddChar	"#"

	TestBit	23,,"-"                 ; Up/~Down bit

        MOV     r8, r4, LSL #32-12
        MOV     r8, r8, LSR #32-12      ; r4 & 0x0FFF
	TestBit	27
        MOVNE   r8, r8, LSL #2          ; Word offset if coprocessor
        BL      StoreDecimal

        AND     r5, r5, #&0F
        TEQS    r5, #&0F                ; If [pc, #xxx] then comment it
        MOVNE   r8, #-1
        BNE     %FT80

        TestBit	24		        ; Pre/~Post bit
        MOVEQ   r8, #-1
        BEQ     %FT80                   ; [postincrement, so wacky]

        TestBit 23		        ; Up/~Down bit
        SUBEQ   r8, r9, r8              ; Form offset from required address
        ADDNE   r8, r9, r8

80
	TestBit	24,"]"                 ; Pre/~Post bit
                                       ; [preincrement, so close]

        AND     r10, r4, #2_1001 :SHL: 21
        TEQS    r10,     #2_1001 :SHL: 21 ; preincrement with writeback ?
	AddChar	"!",EQ

        CMP     r8, #-1
        BEQ     InstructionEnd

        BL      Tab                     ; Will also insert '; '

        B       BranchLdrStrCommon



; Register offset
90
	TestBit	23,,"-"                 ; Up/~Down bit

        MOV     r5, r4                  ; Rm
        BL      Dis_Register

        BL      ShiftField

        MOV     r8, #-1
        B       %BT80

Ldr     DCB     "LDR", 0
Str     DCB     "STR", 0
Open_B  DCB     ",[", 0
Close_B DCB     "],", 0

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Mul     DCB     "MUL", 0
Mla     DCB     "MLA", 0
Mull    DCB     "MULL",0
Mlal    DCB     "MLAL",0
aswp    DCB     "SWP",0
        ALIGN

UndefinedDataProcessing ROUT
	; Arrive here with cccc 00xx xxxx xxxx xxxx xxxx 1xx1 xxxx

        AND     R10,R4,#&F0             ; forcible check for &xxxxxx9x
        TEQS    R10,#&90
        BNE	LdrStrH

        MOV     R5,R4,LSR #23
        AND     R5,R5,#&1F
                                        ; vvv - tested
        TST     r4, #&38 :SHL: 22       ; 0000 00AS dddd nnnn ssss 1001 mmmm ?
        BNE     Undefined               ; test was &3F - changed to allow SWP,MULL,MLAL through

        TEQS    R5,#2_00001
        BEQ     mul_long

        CMPS    R5,#2_00010
        BEQ     swp
	BHS	Undefined

	TestBit	22
	BNE	Undefined

	; Multiply + Multiply-with-Accumulate
	; Arrive here with cccc 0000 00xx xxxx xxxx xxxx 1001 xxxx
	; Format is        cccc 0000 00as dddd nnnn ssss 1001 mmmm
	;
	; MUL{cond}{S} Rd,Rm,Rs
	; MLA{cond}{S} Rd,Rm,Rs,Rn
	;
	; where cccc = condition
	;          a = Accumulate
	;          s = Set flags
	;       dddd = Rd
	;       nnnn = Rn
	;       ssss = Rs
	;       mmmm = Rm

	TestStr	21,Mla,Mul,conds        ; Accumulate bit

	TestBit	20,"S"                  ; Update flags bit

        MOV     r5, r4, LSR #16         ; Rd
        BL      Tab_Dis_Register

        AND     R5,R4,#15               ; Rm
        MOV     R10, R4, LSR #16
        AND     R10,R10,#15
        TEQS    R10,R5
        TEQNES  R10,#15
        MOVEQ   R14,#Mistake_MUL
        STREQ   R14,Mistake

        BL      Comma_Dis_Register

        MOV     r5, r4, LSR #8          ; Rs
        BL      Comma_Dis_Register

        TestBit	21		        ; MLA has extra operand
        MOVNE   r5, r4, LSR #12         ; Rn
	BLNE	Comma_Dis_Register
	BNE	InstructionEnd

	TST	r4, #2_1111:SHL:12	; Check Rn=R0 for MUL
	BNE	Undefined

        B       InstructionEnd

mul_long
	; Multiply long + Multiply-with-Accumulate long
	; Arrive here with cccc 0000 1xxx xxxx xxxx xxxx 1001 xxxx
	; Format is        cccc 0000 1uas hhhh llll ssss 1001 mmmm
	;
	; <U|S><MULL|MLAL>{cond}{S} RdLo,RdHi,Rm,Rs
	;
	; where cccc = condition
	;          u = Signed/~Unsigned
	;          a = Accumulate
	;          s = Set flags
	;       hhhh = RdHi
	;       llll = RdLo
	;       ssss = Rs
	;       mmmm = Rm

        ;deal with signed/unsigned
	TestBit 22,"S","U"

        ;note: the accumulate works differently here to MUL/MLA
        ;on an accumulating multiply you get Rd+=Rm * Rs, otherwise
        ;you get Rd==Rm * Rs, so wheras MLA uses one more register
        ;than MUL both MULL/MLAL use four registers.

	TestStr	21,Mlal,Mull,conds      ; Accumulate bit

	TestBit	20,"S"                  ; Update flags bit

	; This stupid opcode can be too long. Will hardly ever happen
	; so don't increase the tab width (might break some programs).
	; Instead, just push the registers over one space.
	ADR	r1, StringBuffer
	SUB	r1, r0, r1
	TEQS	r1, #8
	AddChar	" ",EQ
	BLNE	Tab

        MOV     r5, r4, LSR #12         ; RdLo
	AND	r6, r5, #2_1111
        BL      Dis_Register

        MOV     r5, r4, LSR #16         ; RdHi
	AND	r7, r5, #2_1111
        BL      Comma_Dis_Register

        MOV     r5, r4                  ; Rm
	AND	r8, r5, #2_1111
        BL      Comma_Dis_Register

        MOV     r5, r4, LSR #8          ; Rs
	AND	r9, r5, #2_1111
        BL      Comma_Dis_Register

	; Can't use R15 as any register, unpredictable
	; if RdLo=RdHi or RdLo=Rm or RdHi=Rm
	LDR	r14, Mistake
	TEQS	r7, r8
	MOVEQ	r14, #Mistake_RdHiRm
	TEQS	r6, r8
	MOVEQ	r14, #Mistake_RdLoRm
	TEQS	r6, r7
	MOVEQ	r14, #Mistake_RdLoRdHi
	TEQS	r6, #15
	TEQNES	r7, #15
	TEQNES	r8, #15
	TEQNES	r9, #15
	MOVEQ	r14, #Mistake_R15
	STR	r14, Mistake

        B       InstructionEnd

swp
	; Swap register/memory
	; arrive here with cccc 0001 0xxx xxxx xxxx xxxx 1001 xxxx
	; format is        cccc 0001 0b00 nnnn dddd 0000 1001 mmmm
	;
	; SWP{cond}{B} Rd,Rm,[Rn]
	;
	; where cccc = condition
	;          b = Byte/~Word
	;       nnnn = Rn
	;       dddd = Rd
	;       mmmm = Rm

	TSTS	R4,#2_1111 :SHL: 8
        BNE     Undefined

	TST	R4,#2_11 :SHL: 20
	BNE	Undefined

	AddStr	aswp,,conds
	TestBit	22,"B"

        MOV     R5,R4,LSR #12
	AND	r9,r5,#2_1111		; Rd
	; Rd=R15 -> unpredictable
	TEQS	r9,#15
	MOVEQ	r14,#Mistake_R15
	STREQ	r14,Mistake
        BL      Tab_Dis_Register

        AND     R5,R4,#2_1111		; Rm
	; Rm=R15 -> unpredictable
	TEQS	r5,#15
	MOVEQ	r14,#Mistake_R15
	STREQ	r14,Mistake
	; Rd=Rm -> unpredictable
	TEQS	r5,r9
	MOVEQ	r14,#Mistake_RdRm
	STREQ	r14,Mistake
        BL      Comma_Dis_Register
	AddStr	Open_B

        MOV     R5,R4,LSR #16
	AND	r5,r5,#2_1111		; Rn
	; Rn=R15 -> unpredictable
	TEQS	r5,#15
	MOVEQ	r14,#Mistake_R15
	STREQ	r14,Mistake
	; Rd=Rn -> unpredictable
	TEQS	r5,r9
	MOVEQ	r14,#Mistake_RdRn
	STREQ	r14,Mistake
        BL      Dis_Register
	AddChar	"]"
	[ {FALSE}
        BL      Tab
        ADR     R10,arm3only
        BL      lookup_r10
        BL      SaveString
	]
        B       InstructionEnd

LdrStrH	; Load and Store Halfword or Load Signed Byte
	; arrive here with cccc 000x xxxx xxxx xxxx xxxx 1nn1 xxxx
	; (nn != 00)
	; format is        cccc 000p uiwl nnnn dddd aaaa 1sh1 bbbb
	;
	; LDR{cond}<H|SH|SB> Rd,[Rn,<#offset|Rm>]{!}
	;                    Rd,[Rn],<#offset|Rm>
	; STR{cond}H         Rd,[Rn,<#offset|Rm>]{!}
	;                    Rd,[Rn],<#offset|Rm>
	; where cccc = condition
	;	   p = Pre-indexed/~Post-indexed
	;	   u = Up/~Down
	;	   i = Immediate/~Register offset
	;	   w = Writeback (must be zero if post-indexed)
	;          l = Load/~Store
	;       nnnn = Rn
	;       dddd = Rd
	;       aaaa = immediate offset high nibble (if i==1), else 0
	;          s = Signed/~Unsigned halfword
	;	   h = Halfword/~Signed byte
	;	bbbb = immediate offset low nibble (if i==1), else Rm

	; cccc 000x x0xx xxxx xxxx nnnn 1xx1 xxx is undefined if any of
	; nnnn are 1.
	TSTS	r4, #1:SHL:22		; Immediate/~Register offset
	BNE	%F5
	TSTS	r4, #&00000F00
	BNE	Undefined
	; Can only have STRH, not STRSH or STRSB
5	TSTS	r4, #1:SHL:20		; Load/~Store
	BNE	%F20
	AND	r5, r4, #&000000F0
	TEQS	r5, #&000000B0
	BNE	Undefined
20	AND	r5, r4, #1:SHL:24 :OR: 1:SHL:21
	TEQS	r5, #1:SHL:21		; Check for post-indexed with W set (illegal)
	BEQ	Undefined

	TestStr	20,Ldr,Str,conds
	TestBit	6,"S"
	TestBit	5,"H","B"

	MOV	r5, r4, LSR #12
	BL	Tab_Dis_Register

	; Check we're not storing/loading PC
	TEQS	r5, #15
	MOVEQ	r10, #Mistake_R15
	STREQ	r10, Mistake
	BEQ	%FT30

	;
	; Check for Rd=Rn with writeback
	;
	AND	r10, r4, #2_10010:SHL:20	; If pre-indexed and no writeback, then OK
	TEQS	r10, #2_10000:SHL:20
	BEQ	%FT30
	AND	r10, r4, #&F:SHL:16		; If Rd <> Rn then OK
	TEQS	r5, r10, LSR #16
	BNE	%FT30
	TSTS	r4, #1:SHL:22			; If a register offset, then fail
	BEQ	%FT25
	TSTS	r4, #&F
	TSTEQS	r4, #&F00
	BEQ	%FT30				; If an immediate offset of 0, then OK

25	MOV	r10, #Mistake_RdRn
	STR	r10, Mistake

30	MOV	r5, r4, LSR #16
	AND	r5, r5, #&F
	TEQS	r5, #15
	BNE	not_ldrh_rel

	;
	; Check for PC-writeback
	;
	AND	r10, r4, #2_10010:SHL:20
	TEQS	r10, #2_10000:SHL:20
	MOVNE	r10, #Mistake_PCwriteback
	STRNE	r10, Mistake

	ANDEQ	r10, r4, #2_10110:SHL:20     	; Check P,I and W bits
	TEQEQS	r10, #2_10100:SHL:20		; Must be pre-indexed,immediate,no writeback
	BNE	not_ldrh_rel

	; show resultant [LD|ST]R[H|SH|SB] Rd,[PC,#nn] address directly

	AddChar	","
	AND	r8,  r4, #&0000000F
	AND	r10, r4, #&00000F00
	ORR	r8, r8, r10, LSR #4
	TSTS	r4, #1:SHL:23		; Up/~Down bit
	SUBEQ	r8, r9, r8
	ADDNE	r8, r9, r8
	B	BranchLdrStrCommon


not_ldrh_rel

	AddStr	Open_B	        	; ",["

	BL	Dis_Register

	TSTS	r4, #1:SHL:24           ; Pre/~Post bit
	ADRL	r10, Close_B
	ADDNE	r10, r10, #1            ; just ',' else '],'
	BL	SaveString
	TSTS	r4, #1:SHL:22		; Immediate/~Register bit
	BEQ	ldrstrh_reg

	AddChar	"#"
	TestBit	23,,"-"	        	; Up/~Down bit

	AND	r8,  r4, #&0000000F
	AND	r10, r4, #&00000F00
	ORR	r8, r8, r10, LSR #4
	BL	StoreDecimal
	B	%F50

ldrstrh_reg
	TestBit	23,,"-"	        	; Up/~Down bit
	AND	r5, r4, #&F
	BL	Dis_Register

	; Check for Rm=Rn in register post-indexed case
	AND	r6, r4, #&F :SHL: 16
	TEQS	r5, r6, LSR #16
	TSTEQS	r4, #1:SHL:24
	MOVEQ	r6, #Mistake_RmRn
	STREQ	r6, Mistake

50	TSTS	r4, #1:SHL:24           ; Pre/~Post bit
	BEQ	InstructionEnd

	AddChar	"]"

	TestBit	21,"!"                  ; Writeback bit
	B	InstructionEnd

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data processing opcodes

	; Arrive here with cccc 00xx xxxx xxxx xxxx xxxx xxxx xxxx
	; Format is        cccc 000o ooos nnnn dddd rrrr rtt0 mmmm
        ;                  cccc 000o ooos nnnn dddd ssss 0tt1 mmmm
	;                  cccc 001o ooos nnnn dddd rrrr iiii iiii
	;
	; <data op>{cond}{S} Rd,Rn,op2    (0-7,12,14: AND,EOR,SUB,RSB,ADD,ADC,SBC,RSC,ORR,BIC)
	; <data op>{cond}{S} Rd,op2       (13,15: MOV,MVN)
	; <compare>{cond}{P} Rn,op2       (8-11: TST,TEQ,CMP,CMN)
	;
	;        op2 = #imm
	;              Rm{,<LSL|LSR|ASR|ROR> <#imm|Rs>}
	;	       Rm,RRX
	;
	; where cccc = condition
	;       oooo = operation
	;          s = Set flags (required for comparisons)
	;       nnnn = Rn (0 if not used, 15 signals P flag on compares)
	;       dddd = Rd (0 if not used)
	;      rrrrr = rotate/shift amount
	;         tt = shift type (LSL,LSR,ASR,ROR) (RRX encoded by ROR #0)
	;   iiiiiiii = immediate
	;       mmmm = Rm
DataProcessing ROUT

        LDR     r3, =&02000090          ; Data processing op with bit 4 set
        AND     r3, r4, r3              ; -> shift by Rs, but bit 7 set, so
        TEQS    r3, #&90                ; is not defined
        BEQ     UndefinedDataProcessing ; MUL/MLA in here too (and SWP from 1.23)
                                        ; (and MULL/MLAL from 1.44)
					; (and LDRH etc from 1.48)

        MOV     r6, r4, LSR #21         ; r6 := dp opcode
        AND     r6, r6, #2_1111
;Version 1.25 bug fix - only apply ADR to immediate operands
        ;If ADD or SUB, and Rn=15 then call it ADR instead
        TEQS    R6,#2
        TEQNES  R6,#4
        BNE     notADR ;not ADD/SUB

        MOV     R5,R4,LSR #16
        AND     R5,R5,#15
        TEQS    R5,#15
        BNE     notADR ;Rn not R15

        TestBit	25			; I bit
        BNE     isADR
notADR
	AND	r5, r4, #2_11001 :SHL: 20
	TEQS	r5, #2_10000 :SHL: 20		; Check for opcodes 8-11 with S clear
	BEQ	is_MRSorMSR

        ADR     r10, OpcTAB
        ADD     r10, r10, r6, LSL #2

        BL      SaveStringConditions

        MOV     r5, r4, LSR #12         ; Rd
        CMP     r6, #&08                ; TEQ,TST,CMP,CMN
        RSBHSS  r14, r6, #&0B
        BLO     %FT10

        ANDS    r5, r5, #2_1111         ; If Rd = pc then xxxP
	BEQ	%FT05
        TEQ     r5, #15
	BNE	Undefined		; Otherwise check Rd=R0
	AddChar	"P"
        MOV     R10, #Potential_Banked_Next
        STR     R10, Mistake            ; potential bank access error

5       BL      Tab
        B       %FT20

10
	TestBit	20,"S"       		; Update flags bit

        BL      Tab_Dis_Register

        BL      AddComma

        TEQ     r6, #13                 ; MOV
        TEQNE   r6, #15                 ; MVN
	BNE	%FT20
	TSTS	r4, #2_1111 :SHL: 16	; Check that Rn=R0
	BNE	Undefined
	B	Operand_2

20      MOV     r5, r4, LSR #16         ; Rn
        BL      Dis_Register
        BL      AddComma

Operand_2
	TestBit	25         		; Immediate bit
        BNE     Immediate

        MOV     r5, r4                  ; Rm
        BL      Dis_Register

        BL      ShiftField
        B       InstructionEnd


Immediate
	AddChar	"#"

        MOV     r2, r4, LSR #7
        AND     r2, r2, #2_11110        ; Yes, I really do mean 30, see the book
        AND     r8, r4, #2_11111111
        MOV     r8, r8, ROR r2

        MOVS    r14, r8, LSR #8         ; Does value fit in LSB
        BNE     %FT10
        TEQ     r2, #0                  ; but have a non-zero shift ?
        BNE     WackyShift
10

;Testing for weird shifts, ie representable numbers as <data><no shift> but are in fact <data><shift>
;removed

        CMPS    r8, #10
        BLO     Rem_Number              ; If really simple, just display number
                                        ; ie. 0..9 unambiguous

        MOV     r2, #8-4                ; default is byte
        CMPS    r8, #&100
        MOVHS   r2, #16-4               ; then halfword
        CMPS    r8, #&10000
        MOVHS   r2, #32-4               ; then fullword
        BL      StoreHex

        CMPS    r8, #8192               ; If really big, don't comment on it
        BHS     InstructionEnd          ; May have VSet from CMP!

        BL      Tab                     ; Will also insert '; '

	AddChar	"="


Rem_Character
        CMPS    r8, #delete
        CMPNES  r8, #space-1
        BLS     Rem_Number

        CMPS    r8, #&100
        BHS     Rem_Number

        MOV     r10, #quote
        STRB    r10, [r0], #1
        STRB    r8,  [r0], #1
        STRB    r10, [r0], #1
        B       InstructionEnd


Rem_Number
        BL      StoreDecimal
        B       InstructionEnd

;ADR pseudo-op - display address being created instead of the ADD/SUB

isADR
	AddStr	AdrTAB,,conds
        MOV     R5, R4, LSR #12
        BL      Tab_Dis_Register
        BL      AddComma
        MOV     R2, R4, LSR #7
        AND     R2, R2, #2_11110
        AND     R8, R4, #2_11111111
        MOV     r8, r8, ROR r2
        TEQS    R6, #2
        SUBEQ   R8, R9, R8
        ADDNE   R8, R8, R9
        ADD     R8, R8, #8
        MOV     R2, #32-4
        BL      StoreHex
        B       InstructionEnd

CPSR_or_SPSR
	TestBit	22
        ADREQ   R10,cpsr_tab
        ADRNE   R10,spsr_tab
        B       SaveString

is_MRSorMSR
	; arrive here with cccc 00x1 0xx0 xxxx xxxx xxxx xxxx xxxx
	TestBit	21
	BNE	is_MSR

is_MRS	; arrive here with cccc 00x1 0x00 xxxx xxxx xxxx xxxx xxxx
	;
	; format is        cccc 0001 0r00 1111 dddd 0000 0000 0000
	;
	; MRS{cond} Rd, <CPSR|SPSR>
	; where cccc = condition
	;	   r = 1 for SPSR, 0 for CPSR
	MOVS	r5, r4, LSL #20		   ; bottom 12 bits should be 0
	BNE	Undefined
	AND	r14, r4, #2_1111 :SHL: 16  ; bits 16-19 should be 1
	TEQS	r14, #2_1111 :SHL: 16
	BNE	Undefined
	TestBit	25
	BNE	Undefined

	AddStr	MrsTAB,,conds
	MOV	r5, r4, LSR #12
	BL	Tab_Dis_Register	   ; Rd
	BL	AddComma
	BL	CPSR_or_SPSR
	B	InstructionEnd

cpsr_tab DCB    "CPSR",0
spsr_tab DCB    "SPSR",0

        ALIGN

is_MSR	; arrive here with cccc 00x1 0x10 xxxx xxxx xxxx xxxx xxxx
	;
	; format is        cccc 0001 0r10 fsxc 1111 0000 0000 mmmm
	;        or        cccc 0011 0r10 fsxc 1111 rrrr iiii iiii
	; MSR{cond} <CPSR|SPSR>_<fields>, Rm
	; MSR{cond} <CPSR|SPSR>_<fields>, #imm
	;
	; where cccc = condition
	;	   r = 1 for SPSR, 0 for CPSR
	;       fsxc = field mask bits
	;       rrrr = rotate amount (/2)
	;       iiii = immediate
	;	mmmm = Rm
	TestBit	25       	      ; if register, bits 4-11 must be 0
	BNE	%FT01

	; Check it's not a BX (encoded as MSR CPSR_cxsf, Rm, LSL PC)
	BIC	r5, r4, #&F000000F
	LDR	r10, =&012FFF10
	TEQS	r5, r10
	BEQ	is_BX

	TST	r4, #2_11111111 :SHL: 4
	BNE	Undefined

01	AND	r10, r4, #2_1111 :SHL: 12
	TEQ	r10, #2_1111 :SHL: 12
	BNE	Undefined

	; Can't use cxs bits in an immediate MSR
	TestBit	25
	BEQ	%FT05
	TST	r4, #2_0111 :SHL: 16
	MOVNE	r10, #Mistake_Unpred
	STRNE	r10, Mistake

05	ADR	r10, MsrTAB
	BL	SaveStringConditions
	BL	Tab
	BL	CPSR_or_SPSR
	AddChar	"_"
	TestBit	16,"c"
	TestBit	17,"x"
	TestBit	18,"s"
	TestBit	19,"f"
	BL	AddComma
	B	Operand_2

is_BX	; arrive here with cccc 0001 0010 1111 1111 1111 0001 xxxx
	;
	; format is        cccc 0001 0010 1111 1111 1111 0001 nnnn
	;
	; BX{cond} Rn
	;
	; where cccc = condition
	;	nnnn = Rn
	AddStr	BxTAB,,conds
	AND	R5,R4,#2_1111
	BL	Tab_Dis_Register

	B	InstructionEnd

AdrTAB  DCB     "ADR",0
MrsTAB  DCB     "MRS",0
MsrTAB  DCB     "MSR",0
BxTAB   DCB     "BX", 0
	ALIGN
OpcTAB  DCB     "AND",0
        DCB     "EOR",0
        DCB     "SUB",0
        DCB     "RSB",0
        DCB     "ADD",0
        DCB     "ADC",0
        DCB     "SBC",0
        DCB     "RSC",0
        DCB     "TST",0
        DCB     "TEQ",0
        DCB     "CMP",0
        DCB     "CMN",0
        DCB     "ORR",0
        DCB     "MOV",0
        DCB     "BIC",0
        DCB     "MVN",0

Ldc     DCB     "LDC", 0
Stc     DCB     "STC", 0
Cdp     DCB     "CDP", 0
Mcr     DCB     "MCR", 0
Mrc     DCB     "MRC", 0
Cp      DCB     "CP", 0

	ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Coprocessor
	; Coprocessor operations
	; arrive here with cccc 11nn xxxx xxxx xxxx xxxx xxxx xxxx
	; with nn <> 11

        AND     r2, r4, #2_1111 :SHL: 8 ; r2 := CP# << 8

        TEQS    r2, #2_0001 :SHL: 8
        BEQ     Floating_Point          ; [Floating Point coprocessor]

        TEQS    r2, #2_0010 :SHL: 8
        BEQ     New_FPA                 ;new FPA

Coprocessor_NotFP

; Currently unknown coprocessor

        TEQS    r3, #&0E
        BEQ     Co_Operations

	; arrive here with cccc 110x xxxx xxxx xxxx xxxx xxxx xxxx
	; format is        cccc 110p unwl nnnn dddd #### iiii iiii
	;
	; <LDC|STC>{cond}{L} CP#,Cd,[Rn,#imm]{!}
	;		     CP#,Cd,[Rn],#imm
	;
	; where cccc = condition
	;	   p = Pre-indexed/~Post-indexed
	;	   u = Up/~Down
	;	   n = Transfer length
	;	   w = Writeback (must be 1 if post-indexed)
	;	   l = Load/~Store
	;	nnnn = Rn
	;	dddd = Cd
	;	#### = CP#
	;	iiii = immediate offset (in words)

; Coprocessor Data Transfer (CPDT)

	TST	r4, #1:SHL:24 :OR: 1:SHL:21
	BEQ	Undefined		; Post-indexed, but no writeback!

	TestStr	20,Ldc,Stc,conds        ; Load/~Store bit

	TestBit	22,"L"                  ; Length bit

        BL      Tab_CPN                 ; CP#

        MOV     r5, r4, LSR #12         ; CRd
        BL      Dis_C_Register


CPDT_Common                             ; FP entry point from below

        BIC     r3, r3, #2_1000         ; Make like a normal data transfer
                                        ; 0C,0D -> 04,05 (STC,LDC -> STR,LDR)
        BIC     r4, r4, #&00000F00      ; Clear CP# field
        B       DataTransfer_Common

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Co_Operations

	; arrive here with cccc 1110 xxxx xxxx xxxx xxxx xxxx xxxx

        TestBit 4		; Transfer/~Operation bit
        BNE     Co_Transfers

; Coprocessor Data Operation (CPDO)
	; arrive here with cccc 1110 xxxx xxxx xxxx xxxx xxx0 xxxx
	; format is        cccc 1110 oooo nnnn dddd #### iii0 mmmm
	;
	; CDP{cond} CP#,op,Cd,Cn,Cm{,info}
	;
	; where cccc = cond
	;	oooo = operation
	;       nnnn = Cn
	;       dddd = Cd
	;       #### = CP#
	;        iii = info
	;       mmmm = Cm

        MOV     R10, #Potential_SWICDP_Next ;deferred warning in case SWI next
        STR     R10, Mistake

	AddStr	Cdp,,conds

        BL      Tab_CPN                 ; CP#

        MOV     r8, r4, LSR #20         ; CPOpc
        AND     r8, r8, #2_1111         ; All of nibble for CPDO
        BL      StoreDecimal_Comma

        MOV     r5, r4, LSR #12         ; CRd
        BL      Dis_C_Register_Comma

CPRT_CPDO_Common

        MOV     r5, r4, LSR #16         ; CRn
        BL      Dis_C_Register_Comma

        MOV     r5, r4                  ; CRm
        BL      Dis_C_Register

        MOV     r8, r4, LSR #5          ; CP
        ANDS    r8, r8, #2_111          ; non-zero ?
        BLNE    AddComma
        BLNE    StoreDecimal

        ;if MRC/MCR check for system control coprocessor and comment accordingly

        TestBit	4                       ; Transfer/~Operation bit
        BEQ     InstructionEnd

        AND     R5,R4,#&F00
        TEQS    R5,#&F00
        BNE     InstructionEnd          ; Not CP15

        AND     R5,R4,#&F0000
	TEQS	R5,#&40000
	BEQ	InstructionEnd
	CMPS	R5,#&80000
	BHI	InstructionEnd

        BL      Tab

        ADR     R10,msgtable
        ADD     R10,R10,R5,LSR #14
        BL      lookup_r10
        BL      SaveString
        B       InstructionEnd


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Coprocessor Register Transfer (CPRT)

Co_Transfers
	; arrive here with cccc 1110 xxxx xxxx xxxx xxxx xxx1 xxxx
	; format is        cccc 1110 oool nnnn dddd #### iii1 mmmm
	;
	; <MCR|MRC>{cond} CP#,op,Rd,Cn,Cm{,info}
	;
	; where cccc = cond
	;	 ooo = operation
	;          l = Load/~Store (ie load from coprocessor)
	;       nnnn = Cn
	;       dddd = Rd
	;       #### = CP#
	;        iii = info
	;       mmmm = Cm

	TestStr	20,Mrc,Mcr,conds        ; Load/~Store bit

        BL      Tab_CPN                 ; CP#

        MOV     r8, r4, LSR #21         ; CPOpc
        AND     r8, r8, #2_111          ; Only three bits for CPRT
        BL      StoreDecimal_Comma

        MOV     r5, r4, LSR #12         ; Rd (ARM register)
        BL      Dis_Register
        BL      AddComma

        B       CPRT_CPDO_Common

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Tab_CPN ENTRY

        BL      Tab

	AddStr	Cp

        MOV     r8, r4, LSR #8
        AND     r8, r8, #2_1111
        BL      StoreDecimal_Comma      ; CP#
        EXIT

        LTORG

msgtable
msg0    = "M02",0    	; CP15,C0 : ARMv4 ID
msg1    = "M03",0    	; CP15,C1 : ARMv4 Control
msg2    = "M04",0 	; CP15,C2 : ARMv4 Translation Table
msg3    = "M05",0	; CP15,C3 : ARMv4 Domain Access Control
msg4    = "M08",0	; CP15,C4 : ARMv4 - Bad register
msg5    = "M06",0	; CP15,C5 : ARMv4 Fault Status
msg6    = "M07",0	; CP15,C6 : ARMv4 Fault Address
msg7    = "M51",0	; CP15,C7 : ARMv4 Cache Operations
msg8	= "M52",0	; CP15,C8 : ARMv4 TLB Operations


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

WackyShift
        AND     r8, r4, #&FF            ; Get unrotated byte back
        TEQS    r8, #0                  ; 0,n prettified
	AddChar	"0",EQ

        MOVNE   r2, #8-4                ; Display unrotated byte,decimal rotate
        BLNE    StoreHex

;1.26 - Change layout to #0, ROR #nn
	AddStr	ShiftROR

	AddChar	"#"

        MOV     r8, r4, LSR #7          ; Extract shift part again
        AND     r8, r8, #30
        B       Rem_Number

ShiftField ROUT

        MOV     r2, r4, LSR #4
        ANDS    r2, r2, #&FF            ; LSL #0 -> no shift at all
        MOVEQ   pc, lr

        ENTRY

        TEQ     r2, #2_00000110         ; ROR #0 -> RRX
        BEQ     %FT80

        AND     r1, r2, #2_00000110     ; Each is 6 chars long
        ADR     r10, ShiftTypes
        ADD     r10, r10, r1, LSL #1
        ADD     r10, r10, r1
        BL      SaveString

        TST     r2, #2_00000001
        BNE     %FT50                   ; [, SHF Rs]

; Shift number

	AddChar	"#"

        MOVS    r8, r2, LSR #3          ; LSR #0 -> LSR #32
        MOVEQ   r8, #32                 ; ASR #0 -> ASR #32
        BL      StoreDecimal
        EXIT

50 ; Shift register

        MOV     r5, r2, LSR #4          ; Rs

	AND	r5, r5, #2_1111
	TEQS	r5, #15
	MOVEQ	r14, #Mistake_R15shift
	STREQ	r14, Mistake

        BL      Dis_Register
        EXIT


80      ADR     r10, %FT90              ; RRX
        BL      SaveString
        EXIT

90
        DCB     ",RRX", 0

ShiftTypes
        DCB     ",LSL ", 0              ; 00x
        DCB     ",LSR ", 0              ; 01x
        DCB     ",ASR ", 0              ; 02x
ShiftROR ;used for wacky zero shifts
        DCB     ",ROR ", 0              ; 03x

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r5 = fp register

Dis_F_Register ENTRY "r2"

	AND	r5, r5, #2_111		; Only 8 FP registers

	MOV	r10, #"F"
	B	%FT50

; .............................................................................

Dis_C_Register ALTENTRY

        MOV     r10, #"C"
        B       %FT50

; .............................................................................

; In	r5 = register number (in bottom 4 bits, rest can be garbage)
; Out   r5 = register number (correctly masked)
;       r2, r10 corrupted

Dis_Register ALTENTRY

20      AND     r5, r5, #2_1111
        TEQ     r5, #15
        BEQ     Dis_pc

	CMPS	R5,#8
	BLHS	checkreg

        MOV     r10, #"R"

; .............................................................................
; In    r5 = register number
;       r10 = first character

50      STRB    r10, [r0], #1

        AND     r5, r5, #2_1111
        ADD     r2, r5, #"0"
        CMPS    r5, #10
	AddChar "1",HS
        SUBHS   r2, r2, #10
        STRB    r2, [r0], #1
        EXIT

; .............................................................................

Dis_pc
	AddStr	pc_Reg
        EXIT


pc_Reg  DCB     "PC", 0
        ALIGN

; .............................................................................

Comma_Dis_Register ALTENTRY

        BL      AddComma
        B       %BT20

; .............................................................................

Tab_Dis_Register ALTENTRY

        BL      Tab
        B       %BT20

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r10 -> string, 0 to copy into buffer
;       r0 -> current buffer position

; Out   r0 ++, r10++

SaveString ENTRY

10      LDRB    r14, [r10], #1
        CMPS    r14, #32
        STRHSB  r14, [r0], #1
        BHS     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r4 = instruction

; Out   r0++ with condition codes appended

Conditions ENTRY "r1, r10"

10      MOV     r1, r4, LSR #28
        TEQS    R1, #15
        MOVEQ   R10,#Mistake_NV
        STREQ   R10,Mistake
        ADR     R10, CondSym
        ADD     r1, r10, r1, LSL #1
        LDRB    r10, [r1], #1
        TEQS    r10, #0
        STRNEB  r10, [r0], #1
        LDRNEB  r10, [r1], #1
        STRNEB  r10, [r0], #1
        EXIT


CondSym DCB     "EQ"                    ; 0
        DCB     "NE"                    ; 1
        DCB     "CS"                    ; 2
        DCB     "CC"                    ; 3
        DCB     "MI"                    ; 4
        DCB     "PL"                    ; 5
        DCB     "VS"                    ; 6
        DCB     "VC"                    ; 7

        DCB     "HI"                    ; 8
        DCB     "LS"                    ; 9
        DCB     "GE"                    ; 10
        DCB     "LT"                    ; 11
        DCB     "GT"                    ; 12
        DCB     "LE"                    ; 13
        DCB     0,0                     ; 14 : AL cc
        DCB     "NV"                    ; 15

        ALIGN

; .............................................................................

SaveStringConditions ALTENTRY

        BL      SaveString
        B       %BT10

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Pad with spaces to operand field or comment field

Tab ENTRY

10      ADR     r1, StringBuffer
        SUB     r1, r0, r1
        MOV     r14, #space
        STRB    r14, [r0], #1
        TEQS    r1, #7
        EXIT    EQ
        CMPS    r1, #25 ;new exit position for longer comments
        BLO     %BT10

        ADR     r10, Rem
        BL      SaveString
        EXIT

Rem     DCB     " ; ", 0
        ALIGN

TestMistakes
        ENTRY   "r5"
        LDR     R5,Mistake
        CMPS    R5,#1
        BLT     exitM

        BL      Tab
        MOV     R10,#0
        STR     R10,Mistake
        ADR     R10,Silly
        SUB     R5,R5,#1
        ADD     R10,R10,R5,LSL #2
;        LDR     R5,[R5]
;        ADD     R10,R10,R5
        BL      lookup_r10
        BL      SaveString
exitM
        EXIT

Silly
        =       "M09",0		; Use of NV
        =       "M10",0		; ! and ^
        =       "M11",0		; Not R8-R14
        =       "M12",0		; SWI after CDP
        =       "M13",0		; Rd=Rm or Rd=R15
     	=	"M53",0		; Shift by R15
     	=	"M54",0		; Not R15
     	=	"M55",0		; PC writeback
     	=	"M56",0		; Byte load/store of PC
     	=	"M57",0		; May store PC+8 or PC+12
     	=	"M58",0		; Unpredictable
     	=	"M59",0		; Rd=Rn
     	=	"M60",0		; Rm=Rn
     	=	"M61",0		; RdLo=RdHi
     	=	"M62",0		; RdLo=Rm
     	=	"M63",0		; RdHi=Rm
     	=	"M64",0		; Rn in list
	=	"M66",0		; Rd=Rm
	=	"M67",0		; Only 1 reg on SA-110 rev 2

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> buffer
;       r2 = bit position to start at
;       r8 = value to store in hex

; Out   r0 ++

StoreHex ENTRY "r2"

	AddChar "&"

10      MOV     r14, r8, LSR r2
        AND     r14, r14, #15
        CMPS    r14, #9
        ORRLS   r14, r14, #"0"
        ADDHI   r14, r14, #"A"-10
        STRB    r14, [r0], #1
        SUBS    r2, r2, #4
        BPL     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> current buffer position
;       r8 = value to store in decimal

; Out   r0++

StoreDecimal ENTRY "r1-r2, r4"

        SUB     sp, sp, #16
        MOV     r4, r0

        MOV     r0, r8
        MOV     r1, sp
        MOV     r2, #16                 ; Can't get an error with this much
        SWI     XOS_BinaryToDecimal     ; r2 := length of number

        MOV     r0, r4
10      SUBS    r2, r2, #1
        LDRPLB  r14, [r1], #1
        STRPLB  r14, [r0], #1
        BNE     %BT10

        ADD     sp, sp, #16
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

StoreDecimal_Comma ENTRY

        BL      StoreDecimal
        B       %FT50

;..............................................................................
; In    r0 -> output buffer

; Out   comma appended, r0++, flags preserved

AddComma ALTENTRY

50
	AddChar ","
        EXITS

; .............................................................................

Dis_C_Register_Comma ALTENTRY

        BL      Dis_C_Register
        B       %BT50

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MemoryI_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGMMI", 0
        ALIGN


MemoryI_Code ENTRY "r6-r11"

 [ Thumb
	MOV	R6,#"T"
	BL	MemoryCommon
	TEQS	R6,#1
	MOVEQ	R6,#2
 |
        LDR     wp, [r12]
 ]

        ADR     r2, MemoryI_Error
 [ Thumb
        BL      GetCommandParms
 |
        BL      GetCommandParms_R0
 ]
        BLVS    CopyErrorR2
        EXIT    VS

        TST     r8, #secondparm
        ADDEQ   r7, r9, #4*24

 [ Thumb
	TEQ	r6, #4

 [ Addr26
        BICEQ   r9, r9, #ARM_CC_Mask    ; Ensure in 64M space
        BICEQ   r7, r7, #ARM_CC_Mask
        BICNE   r9, r9, #1              ; ensure halfword aligned
        BICNE   r7, r7, #1
 |
        BICEQ   r9, r9, #3              ; ensure word aligned
        BICEQ   r7, r7, #3
        BICNE   r9, r9, #1              ; ensure halfword aligned
        BICNE   r7, r7, #1
 ]
 |
 [ Addr26
        BIC     r9, r9, #ARM_CC_Mask    ; Ensure in 64M space
        BIC     r7, r7, #ARM_CC_Mask
 |
        BIC     r9, r9, #3              ; ensure word aligned
        BIC     r7, r7, #3
 ]
 ]

        TEQS    r9, r7                  ; If same, ensure we do one word
	BNE	%FT05

	ADD	r7, r7, r6
 [ Addr26
	TEQ	r6, #4
        BICEQ   r7, r7, #ARM_CC_Mask    ; Ensure still in 64M space
 ]

05
        [       rp0512
        BL      memorytest
        ]

        BL      SwapAllBreakpoints

10 ; Loop doing disassembly until ESCape or ended

        SWI     XOS_ReadEscapeState
        BCS     %FT95

        BL      DisplayHexWord_R9       ; Display address

        BLVC    MarkPC

 [ Thumb
        MOVVC   r2, r6                  ; Display characters at address
 |
        MOVVC   r2, #4                  ; Display characters at address
 ]
        BLVC    DisplayCharacters
        EXIT    VS

        SWI     XOS_WriteS
        DCB     " : ", 0
        ALIGN

	EXIT	VS

        LDR     r10, [r9]               ; Display word at address
 [ Thumb
	TEQS	r6, #4
	BNE	%F40
 ]
        BL      DisplayHexWord
 [ Thumb
	B	%F45
40	BL	DisplayHexHalfword
 ]

45      BLVC    MarkBreakpoints

	EXIT	VS

        LDR     r0, [r9]                ; Display instruction at address
        MOV     r1, r9
 [ Thumb
	TEQS	r6, #4
	BNE	%F50
 ]
        SWI     XDebugger_Disassemble
 [ Thumb
	B	%F55
50	SWI	XDebugger_DisassembleThumb
 ]
55      MOVVC   r0, r1

        SWIVC   XOS_Write0
        SWIVC   XOS_NewLine
        EXIT    VS

 [ Thumb
        ADD     r9, r9, r6
 |
        ADD     r9, r9, #4
 ]
 [ Addr26
        BIC     r9, r9, #&FC000000            ; Wrap within 64M
 ]

        TEQS    r9, r7
        BNE     %BT10


90      BL      SwapAllBreakpoints
        EXIT

95      BL      AckEscape
        B       %BT90

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

InitStore_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGINS", 0
        ALIGN


UserMemStart  * &8000

InitStore_Code ENTRY "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        ADR     r0, InitStore_Error
        BL      ReadOneParm             ; r7 := parm, r8 state
        BLVS    CopyError
        EXIT    VS

        TST     r8, #hasparm
        LDREQ   r7, =&E6000010          ; A nice invalid instruction
        SWI     XOS_GetEnv              ; r1 -> end of user memory

        MOV     r14, #UserMemStart
10      TEQ     r14, r1                 ; Might have zero apl space
        STRNE   r7, [r14], #4
        BNE     %BT10

        BL      message_writes
        DCB     "M16", 0		; "Store inititalised to &"
        ALIGN

        MOVVC   r10, r7
        BLVC    DisplayHexWord
        SWIVC   XOS_NewLine
        EXIT

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ShowRegs_Code

        LDR     wp, [r12]

; .............................................................................

ShowRegs_Code_Common ENTRY "r6-r11"

        BL      message_writes        ; Display address of register dump
        DCB     "M17", 0	      ; "Register dump (stored at &)
        ALIGN

        ADRVC   r10, Registers
        BLVC    DisplayHexWord
        EXIT    VS

        BL      message_writes
        DCB     "M18", 0	      ; ") is:"
        ALIGN
        EXIT    VS

        MOV     r4, #0
        ADR     r11, Registers

10 ; Display dumped registers

        TST     r4, #3
        SWIEQ   XOS_NewLine
        EXIT    VS

        SWINE   XOS_WriteI+space

        SWIVC   XOS_WriteI+"R"

        MOVVC   r8, r4
        BLVC    DisplayDecimalNumber
        EXIT    VS

        CMPS    r4, #10
        SWILO   XOS_WriteI+space
        EXIT    VS

        SWI     XOS_WriteS
        DCB     " = ", 0
        ALIGN

        LDRVC   r10, [r11, r4, LSL #2]
        BLVC    DisplayHexWord
        EXIT    VS

        ADD     r4, r4, #1
        TEQS    r4, #16
        BNE     %BT10


; Display processor mode (r10 = dumped pc at end of loop)

        SWI     XOS_NewLine
        EXIT    VS
        BL      message_writes
        DCB     "M19", 0	        ; "Mode "
        ALIGN

        ANDVC   r2, r10, #2_11          ; Mask with M[1:0] bits
        ADRVC   r0, ARM_Modes
        ADDVC   r0, r0, r2, LSL #2
        SWIVC   XOS_Write0
        EXIT    VS

        BL      message_writes
        DCB     "M20", 0	   	; " flags set: "
        ALIGN

        MOVVC   r0, #"N"
        MOVVC   r1, #N_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"Z"
        MOVVC   r1, #Z_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"C"
        MOVVC   r1, #C_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"V"
        MOVVC   r1, #V_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"I"
        MOVVC   r1, #I_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"F"
        MOVVC   r1, #F_bit
        BLVC    DoFlagBit

        SWIVC   XOS_NewLine
        EXIT


ARM_Modes
        DCB     "USR", 0
        DCB     "FIQ", 0
        DCB     "IRQ", 0
        DCB     "SVC", 0

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 = flag bit to test
;       r10 = psr
;       r0 = uppercase char to print if set

; Out   char printed uppercase or lowercase, r0 corrupt

DoFlagBit ENTRY

        TST     r1, r10
        ORREQ   r0, r0, #&20            ; Cheap lowercase, known values input
        SWI     XOS_WriteC
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Memory_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGMEM", 0
        ALIGN


Memory_Code ENTRY "r6-r11"

 [ Thumb
	MOV	R6,#"B"
 ]
        BL      MemoryCommon

        ADR     r2, Memory_Error
        BL      GetCommandParms
        BLVS    CopyErrorR2
        EXIT    VS

        TST     r8, #secondparm
        ADDEQ   r7, r9, #256            ; [no second parameter]

 [ Addr26
        BIC     r9, r9, #&FC000000      ; Ensure in 64M space
        BIC     r7, r7, #&FC000000
 ]

        TEQS    r6, #4                  ; Round down if words
        BICEQ   r9, r9, #3
        BICEQ   r7, r7, #3

        TEQS    r7, r9                  ; If same, ensure we do one byte/word
        ADDEQ   r7, r7, r6
 [ Addr26
        BICEQ   r7, r7, #&FC000000      ; Ensure still in 64M space
 ]

        [       rp0512
        BL      memorytest
        ]

        BL      SwapAllBreakpoints

        MOV     r0, #VduExt_WindowWidth
        MOV     r1, #-1
        Push    "r0, r1"
        MOV     r0, sp
        MOV     r1, sp
        SWI     XOS_ReadVduVariables
        Pull    "r0, r1"
        STR     r0, WindowWidth

        CMPS    r0, #8+2+3*32+3+1*32
        MOVHS   r14, #32
        MOVLO   r14, #16
        STR     r14, BytesPerLine

        MOV     r11, #0                 ; Force header on first row

05 ; Loop displaying memory

        SWI     XOS_ReadEscapeState
        BCS     %FT95

        TST     r11, #15
        BLEQ    MemoryHeader

        BLVC    DisplayHexWord_R9       ; address

        SWIVC   XOS_WriteI+space
        SWIVC   XOS_WriteI+colon
        BVS     %FT90

        LDR     r8, BytesPerLine
        TEQS    r6, #4
        MOVEQ   r8, r8, LSR #2          ; words per line

        MOV     r0, r9

10
 [ Addr26
        BIC     r0, r0, #&FC000000      ; Wrap to keep in 64M each loop
 ]
        TEQS    r6, #4                  ; Need to size reset each loop
        MOVEQ   r2, #32-4               ; word
        BEQ     %FT20

        MOV     r2, #8-4                ; byte

        SWI     XOS_WriteI+space        ; Display byte

        TEQ     r0, r7
        BEQ     %FT50                   ; [ended, so blank. DO NOT READ BYTE]

        LDRVCB  r10, [r0], #1           ; <<<get from buffer
        B       %FA30


20      SWI     XOS_WriteS              ; Display word
        DCB     "    ", 0
        ALIGN

        TEQ     r0, r7
        BEQ     %FT50                   ; [ended, so blank. DO NOT READ WORD]

        LDRVC   r10, [r0], #4           ; <<<get from buffer


30      BLVC    DisplayHex
        B       %FA60


50      BLVC    Blank                   ; Output r2 spaces

60      BVS     %FT90

        SUBS    r8, r8, #1              ; Loop if not done whole line
        BNE     %BT10                   ; Even if ended in middle, were padding

        BL      SpaceColonSpace
        BVS     %FT90

        SUB     r2, r7, r9              ; nchars to print this row

        LDR     r14, BytesPerLine
        CMP     r2, r14
        MOVHS   r2, r14

        CMPS    r2, #0                  ; VClear
        BLNE    DisplayCharacters
        SWIVC   XOS_NewLine
        BVS     %FT90

        ADD     r11, r11, #1            ; Another line gone by

        LDR     r14, BytesPerLine
        ADD     r9, r9, r14             ; More bytes per line done

        CMPS    r9, r7
        BLO     %BT05


90      BL      SwapAllBreakpoints
        EXIT

95      BL      AckEscape
        B       %BT90

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SpaceColonSpace ENTRY

        SWI     XOS_WriteI+space
        SWIVC   XOS_WriteI+colon
        SWIVC   XOS_WriteI+space
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MemoryHeader ENTRY

        SWI     XOS_NewLine
        EXIT    VS
        BL      message_writes
        DCB     "M22", 0		; "Address  :"
        ALIGN
        EXIT    VS

        TEQ     r6, #4
        ADREQ   r0, Words
        ADRNE   r0, Bytes
        MOV     lr, pc
        MOV     pc, r0

        BL      SpaceColonSpace
        EXIT    VS

        LDR     r14, BytesPerLine       ; Doing in 32 ?
        CMPS    r14, #32
        ADREQ   r0, %FT85
        SWIEQ   XOS_Write0

        ADRVC   r0, %FT80
        BLVC    message_write0
        MOVVC   r11, #0
        SWIVC   XOS_NewLine
        EXIT

80
        DCB     "M23"			; "   ASCII Data"

85
        DCB     "        ", 0           ; Otherwise centre in field of 32
;                01234567

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9 (0,4,8,C)

Words ENTRY "r9, r10, r11"

        LDR     r11, BytesPerLine

        ADR     r10, Words_Header

10      SWI     XOS_WriteS
        DCB     "     ", 0
        ALIGN
        ANDVC   r9, r9, #&F
        ADDVC   r0, r10, r9, LSL #1
        SWIVC   XOS_Write0
        EXIT    VS

        ADD     r9, r9, #4

        SUBS    r11, r11, #4
        BNE     %BT10
        EXIT

Words_Header
        DCB     "3 2 1 0", 0
        DCB     "7 6 5 4", 0
        DCB     "B A 9 8", 0
        DCB     "F E D C", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Count from r9 to r9+15 modulo 16 along the top

Bytes ENTRY "r9, r10, r11"

        LDR     r11, BytesPerLine

10      SWI     XOS_WriteI+space
        MOVVC   r2, #8-4
        ANDVC   r10, r9, #&F
        BLVC    DisplayHex
        EXIT    VS

        ADD     r9, r9, #1

        SUBS    r11, r11, #1
        BNE     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Fill remaining space with 1 + r2/4 blanks

; In    r2 = number of blanks to go (multiple of 4)

Blank ENTRY

10      SWI     XOS_WriteI+space
        EXIT    VS

        SUBS    r2, r2, #4
        BPL     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; in    r12 to be indirected
;       r0 -> string
;	r6 = character to check for

; Out   r1 -> string
 [ Thumb
;       r6 = 1 or 4 depending on whether 'r6' present (+ skipped)
 |
;       r6 = 1 or 4 depending on whether 'B' present (+ skipped)
 ]
;       r0 corrupt

MemoryCommon ENTRY

        LDR     wp, [r12]

        MOV     r1, r0                  ; Check for 'r6',space
        BL      SkipSpaces
 [ Thumb
        TEQ     r0, R6			; Check upper case
	ADDNE	r6, r6, #"a"-"A"
        TEQNE   r0, R6			; Check lower case
 |
        TEQ     r0, #"b"
        TEQNE   r0, #"B"
 ]
        LDREQB  r0, [r1, #1]
        TEQEQ   r0, #space
        ADDEQ   r1, r1, #2              ; skip 'r6',space
        MOVEQ   r6, #1                  ; bytes (or Thumb)
        MOVNE   r6, #4                  ; otherwise
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MemoryA_Code ENTRY "r6-r11"

 [ Thumb
	MOV	R6,#"B"
 ]
        BL      MemoryCommon

        ADR     r2, MemoryA_Error
        BL      GetCommandParms
        EXIT    VS

        TST     r8, #&FF00              ; had operator ?
        BNE     %FT99                   ; [not permitted here]

 [ Addr26
        BIC     r9, r9, #&FC000000      ; Ensure in 64M space
 ]
        TEQS    r6, #4                  ; round down if words
        BICEQ   r9, r9, #3

        [       rp0512
        MOV     r2, r7                 ; avoid walking over the value to write
        MOV     r7,r9

        BL      memorytest2
        ]

        BL      SwapAllBreakpoints

        [       rp0512
        MOV     r7, r2                  ; and back where it should be
        ]
        TST     r8, #secondparm
        BEQ     Interactive             ; [no second parameter]

; Simple command, not interactive

        TEQ     r6, #4
        MOVEQ   r2, #32-4
        LDREQ   r4, [r9]
        STREQ   r7, [r9]
        LDREQ   r5, [r9]
        ADREQ   r0, %FT40

        MOVNE   r2, #8-4
        LDRNEB  r4, [r9]
        STRNEB  r7, [r9]
        LDRNE   r5, [r9]
        ADRNE   r0, %FT41
        BL      message_write0

        BLVC    DisplayHexWord_R9

        ADRVC   r0, %FT44
        BLVC    message_write0

        MOVVC   r10, r4
        BLVC    DisplayHex

        ADRVC   r0, %FT45
        BLVC    message_write0

        MOVVC   r10, r5
        BLVC    DisplayHex

        SWIVC   XOS_NewLine

        BL      SwapAllBreakpoints
        EXIT

40
        DCB     "M24", 0		; "Word at &"
41
        DCB     "M25", 0		; "Byte at &"
44
        DCB     "M26", 0		; " was &"
45
        DCB     "M27", 0		; " altered to &"
        ALIGN

99      ADR     r0, MemoryA_Error
        BL      CopyError
        EXIT


MemoryA_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGMMA", 0
        ALIGN

; .............................................................................

Interactive ROUT

        SUB     sp, sp, #256            ; Use buffer on stack
        MOV     r8, r6                  ; 1 or 4, initial step +ve

10
 [ Addr26
        BIC     r9, r9, #&FC000000      ; Wrap in 64M space
 ]
        CMPS    r8, #0
        MOVGE   r0, #"+"
        MOVLT   r0, #"-"
        SWI     XOS_WriteC
        SWIVC   XOS_WriteI+space

        BLVC    DisplayHexWord_R9

        BLVC    MarkPC

        TEQ     r6, #4
        LDREQ   r10, [r9]
        LDRNEB  r10, [r9]
        MOVVC   r2, r6
        BLVC    DisplayCharacters

        BLVC    MarkBreakpoints

        TEQ     r6, #4
        MOVEQ   r2, #32-4
        MOVNE   r2, #8-4
        BLVC    DisplayHex

        SWIVC   XOS_WriteI+space
        SWIVC   XOS_WriteI+colon
        SWIVC   XOS_WriteI+space

        TEQ     r6, #4                  ; Only disassemble when doing words
        BNE     %FT50

        LDRVC   r0, [r9]
        MOVVC   r1, r9
        SWIVC   XDebugger_Disassemble
        MOVVC   r0, r1
        SWIVC   XOS_Write0

50      SWIVC   XOS_NewLine
        ADRVC   r0, %FT96
        BLVC    message_write0

        MOVVC   r0, sp
        MOVVC   r1, #255
        MOVVC   r2, #space
        MOVVC   r3, #&FF
        SWIVC   XOS_ReadLine
        BVS     %FT90
        BCS     %FT95

        MOV     r1, sp
        BL      SkipSpaces
        ADDCC   r9, r9, r8              ; No parm, just advance in current dirn
        MOVCC   r7,r9
        [       rp0512
        ADDCC   sp,sp,#256
        BLCC    memorytest2             ;ensure not walking into prohibited space
        SUBCC   sp,sp,#256
        ]

        BCC     %BT10

        TEQ     r0, #"+"
        MOVEQ   r8, r6                  ; Change to +ve step
        BEQ     %BT10

        TEQ     r0, #"-"
        RSBEQ   r8, r6, #0              ; Change to -ve step
        BEQ     %BT10

        CMP     r0, #"."                ; End interactive
        BEQ     %FT90                   ; VClear

        ADR     r0, ErrorBlock_Debug_InvalidValue
        BL      CopyError
        Push    r8
        BL      ReadOneParm             ; r7 := parm, r8 state
        Pull    r8
        BVS     %FT90

        TEQ     r6, #4
        STREQ   r7, [r9]
        LDREQ   r10, [r9]
        MOVEQ   r2, #32-4

        STRNEB  r7, [r9]
        LDRNEB  r10, [r9]
        MOVNE   r2, #8-4

        SWI     XOS_WriteS
        DCB     "                  . ", 0
        ALIGN

        BLVC    DisplayHex
        SWIVC   XOS_NewLine
        BVC     %BT10


90      ADD     sp, sp, #256
        BL      SwapAllBreakpoints
        EXIT

95      BL      AckEscape
        B       %BT90


        MakeInternatErrorBlock Debug_InvalidValue, NOALIGN, M46

96
        DCB     "M29", 0		; "  Enter new value : "
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BreakSet_Code ENTRY "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        BL      ReadFirstParm           ; r7 := parm
        EXIT    VS

        TST     r8, #parmfollowed
        BNE     BreakSetError0

 [ Addr26
        BIC     r7, r7, #ARM_CC_Mask    ; Can only set at word address in 64M

        CMP     r7, #&02000000          ; Can only set in LogRam
        BHS     BreakSetError1
 |
        BIC     r7, r7, #3              ; Can only set at word address
        CMP     r7, #&04000000          ; Can only set in bottom 64M (has to
                                        ; construct a branch)
        BHS     BreakSetError1
 ]

        [       rp0512
        MOV     r9,r7
        BL      memorytest
        ]

        ADR     r4, Breaklist           ; Check for breakpoint already in list
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        TEQ     r1, r7
        BEQ     %FT40                   ; [already allocated, but ensure there]
        SUBS    r3, r3, #8              ; each breakpoint entry is 8 bytes
        BPL     %BT10

        MOV     r3, #(nbreakpoints-1)*8 ; Allocate breakpoint
20      LDR     r1, [r4, r3]
        CMP     r1, #-1
        BEQ     %FT30                   ; [free slot found]
        SUBS    r3, r3, #8
        BPL     %BT20

        ADR     r0, ErrorBlock_Debug_NoRoom
        BL      CopyError
        B       %FA90


30 ; Store breakpoint address and old contents, r3 = breakpoint number*8

        MOV     r1, r7
        STR     r1, [r4, r3]            ; breakpoint address
        LDR     r0, [r1]
        ADD     r14, r4, #4
        STR     r0, [r14, r3]           ; old data

40 ; Place branch at breakpoint address, r3 = breakpoint number*8, r1 valid

        ADR     r0, BreakCodeStart
        ADD     r0, r0, r3              ; each code entry is 8 bytes too
        BL      MakeBranch
        STR     r2, [r1]
 [ StrongARM
	;Do the IMB thingy here, for the replaced instruction
	MOV	r0, #1		;Ranged IMB
	MOV	r2, r1
	SWI	XOS_SynchroniseCodeAreas
 ]
        EXIT


BreakSetError0
        ADR     r0, BreakSet_Error
        BL      CopyError

90      EXIT


BreakSetError1
        ADR     r0, ErrorBlock_Debug_BadBreakpoint
        BL      CopyError
        B       %BA90


BreakSet_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGBST", 0
        ALIGN

        MakeInternatErrorBlock Debug_NoRoom,,M48
        MakeInternatErrorBlock Debug_BadBreakpoint,,M50

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BreakList_Code ENTRY "r6-r11"

        LDR     wp, [r12]

        ADR     r4, Breaklist           ; Any breakpoints to display ?
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        CMP     r1, #-1
        BNE     %FT20                   ; [yes, starting at r3]
        SUBS    r3, r3, #8
        BPL     %BT10

        BL      message_writes
        DCB     "M31", 0		; "No breakpoints set"
        SWIVC   XOS_NewLine
        ALIGN
        EXIT


20 ; Display list

        BL      message_writes
        DCB     "M32", 0		; "Address     Old data"
        ALIGN
        SWIVC   XOS_NewLine
        EXIT    VS

30      CMP     r1, #-1
        BEQ     %FT60                   ; [no breakpoint entry here]

        MOV     r10, r1
        BL      DisplayHexWord          ; r10 = breakpoint address
        EXIT    VS

        SWI     XOS_WriteS
        DCB     "    ", 0
        ALIGN

        ADDVC   r14, r4, #4
        LDRVC   r10, [r14, r3]
        BLVC    DisplayHexWord          ; r10 = old data
        EXIT    VS

        ADR     r0, BreakCodeStart      ; Check still B debugger
        ADD     r0, r0, r3              ; each code entry is 8 bytes too
        BL      MakeBranch              ; r1 from up there
        LDR     r14, [r1]
        TEQS    r14, r2
        BEQ     %FT50                   ; [breakpoint present and correct]

        MOV     r14, #-1                ; Clear faulty breakpoint entry
        STR     r14, [r4, r3]           ; Only need to zap address field

        BL      message_writes
        DCB     "M33", 0 ; No newline	; " : bad breakpoint; cleared."
        ALIGN

50      SWIVC   XOS_NewLine
        EXIT    VS

60      SUBS    r3, r3, #8
        LDRPL   r1, [r4, r3]
        BPL     %BT30

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BreakClr_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGBCL", 0
        ALIGN


BreakClr_Code ENTRY "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        ADR     r0, BreakClr_Error
        BL      ReadOneParm             ; r7 := parm, r8 state
        BLVS    CopyError
        EXIT    VS

        BIC     r7, r7, #ARM_CC_Mask    ; Can only set at word address in 64M

        ADR     r4, Breaklist
        MOV     r3, #(nbreakpoints-1)*8

        TST     r8, #hasparm
        BEQ     %FT50                   ; [no parm, so prompt]

; Clear particular breakpoint

10      LDR     r1, [r4, r3]
        TEQS    r1, r7
        BEQ     %FT20                   ; [found]
        SUBS    r3, r3, #8
        BPL     %BT10

        ADR     r0, ErrorBlock_Debug_BreakNotFound
        BL      CopyError
        EXIT


20      BL      ClearBreakpoint         ; uses r1,r3,r4
        EXIT


50 ; Clear all breakpoints

        BL      message_writes
        DCB     "M35", 0		; "Clear all breakpoints? [Y/N]"
        ALIGN

        SWIVC   XOS_Confirm             ; So sexy, huh ? Returns lowercase char
        EXIT    VS
        BLCS    AckEscape
        SWIVC   XOS_NewLine
        EXIT    VS

        ;TEQ     r0, #"y"
        EXIT    NE                      ; [anything else -> go home]


60      LDR     r1, [r4, r3]
        CMP     r1, #-1
        BLNE    ClearBreakpoint         ; uses r1,r3,r4

        SUBS    r3, r3, #8
        BPL     %BT60

        BL      message_writes
        DCB     "M36", 0		; "All breakpoints cleared"
        ALIGN
        SWIVC   XOS_NewLine
        EXIT


        MakeInternatErrorBlock Debug_BreakNotFound,,M45

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 = breakpoint address
;       r3 = breakpoint number*8
;       r4 -> Breaklist

ClearBreakpoint ENTRY "r0-r2, r10"

        MOV     r14, #-1                ; Always clear breakpoint entry
        STR     r14, [r4, r3]           ; Only need to zap address field

        ADR     r0, BreakCodeStart      ; Check that breakpoint was valid
        ADD     r0, r0, r3              ; Each code entry is 8 bytes too
        BL      MakeBranch
        LDR     r14, [r1]
        TEQS    r14, r2
        ADDEQ   r14, r4, #4             ; breakpoint was good, so put data back
        LDREQ   r14, [r14, r3]
        STREQ   r14, [r1]
 [ StrongARM
	;Do the IMB thingy here
	MOV	r0, #1			;Ranged IMB
	MOV	r2, r1
	SWI	XOS_SynchroniseCodeAreas
 ]
        EXIT    EQ

        BL      message_writes
        DCB     "M37", 0		; "Bad breakpoint at &"
        ALIGN
        MOVVC   r10, r1
        BICVC   R10,R10,#ARM_CC_Mask
        BLVC    DisplayHexWord
        EXIT    VS
        BL      message_writes
        DCB     "M38", 0		; "; cleared."
        ALIGN
        SWIVC   XOS_NewLine
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Continue_Code ENTRY "r6-r11"

        LDR     wp, [r12]

        LDR     r14, pc_register        ; Get pc from exception dump
        BIC     r14, r14, #ARM_CC_Mask

        ADR     r4, Breaklist           ; Check breakpoint list for pc
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        TEQS    r1, r14
        MOVEQ   r5, #0                  ; [found]
        BEQ     %FT20
        SUBS    r3, r3, #8
        BPL     %BT10

 [ debug
 DLINE "Not continuing from any of current breakpoints"
 ]
        ADR     r0, Registers
        B       %FT90                   ; Continue with this state



20 ; Check branch at breakpoint

        ADR     r0, BreakCodeStart
        ADD     r0, r0, r3
        BL      MakeBranch
        LDR     r14, [r1]
        TEQ     r14, r2
        BNE     ContinueError1          ; [not kosher]

        BL      message_writes
        DCB     "M39", 0		; "Continue from breakpoint set at &"
        ALIGN

        MOVVC   r10, r1
        BICVC   R10,R10,#ARM_CC_Mask
        BLVC    DisplayHexWord
        EXIT    VS

        SWI     XOS_NewLine
        EXIT    VS
        BL      message_writes
        DCB     "M40", 0		; "Execute out of line? [Y/N] "
        ALIGN

        SWIVC   XOS_Confirm             ; So sexy, huh ? Returns lowercase char
        EXIT    VS                      ; (which for Internationalisation's sake
        BLCS    AckEscape               ; we now ignore, and use the Carry flag
        SWIVC   XOS_NewLine             ; return instead!)
        EXIT    VS

        ;TEQ     r0, #"y"
        EXIT    NE

; Execute instruction out-of-line

        Push    "r1, r3, r4"
        ADR     r8, ExecuteBuffer+8
        ADR     r9, Registers
        LDMIA   r9!, {r0-r7}            ; Get + Store first 8 registers
        STMIA   r8!, {r0-r7}
        LDMIA   r9!, {r0-r6}            ; Get next 7 registers
        LDR     r14, pc_register
        AND     r14, r14, #ARM_CC_Mask
        ADR     r7, ExecuteBuffer
        ORR     r7, r7, r14             ; dumped pc -> ExecBuffer +mode +flags
        STMIA   r8!, {r0-r7}
        Pull    "r1, r3, r4"

; See if we can do any better for pc relatives in this version

        ADR     r8, ExecuteBuffer
        ADD     r14, r4, #4
        LDR     r14, [r14, r3]          ; Copy instruction(old data)into buffer
 [ debug
 DREG r14,"Instruction to execute out of line is "
 ]
        AND     r0, r14, #&0F000000     ; If it's a Bxx, correct for new loc'n
        TEQ     r0,      #&0A000000
        MOVEQ   r0, r14, LSL #8
        ADDEQ   r0, r0, r1, LSL #6      ; r0 = destination of branch-8
 [ debug
 BNE %FT00
 MOV r0, r0, LSR #6
 DREG r0,"continuing a branch, destination-8 = "
 MOV r0, r0, LSL #6
00
 ]
        SUBEQ   r0, r0, r8, LSL #6
        ANDEQ   r2, r14, #&FF000000     ; Copy condition codes + instruction
        ORREQ   r14, r2, r0, LSR #8     ; Munge back together
 [ debug
 BNE %FT00
 DREG r14,"replacing instruction with "
00
 ]
        STR     r14, ExecuteBuffer


        ADD     r0, r1, #4              ; Make a BAL to the next instruction
        ADR     r1, ExecuteBuffer+4     ; that it wants to execute after this
        BL      MakeBranch              ; one, ie. back in real program @ r1+4
        STR     r2, [r1]
 [ StrongARM
	;Best IMB the ExecuteBuffer here
	MOV	r0, #1			; Guess what? It's a ranged sync
	ADR	r1, ExecuteBuffer
	ADD	r2, r1, #ExeBufLen
	SWI	XOS_SynchroniseCodeAreas
 ]
        ADR     r0, ExecuteBuffer+8     ; and drop into ...


90 ; Nice simple continuation. r0 -> register state to continue with

        LDR     r14_svc, [r0, #15*4]
        ANDS    r14_svc, r14_svc, #SVC_mode
        BEQ     %FT95                   ; [user mode harder]

        TEQP    r14_svc, #F_bit + I_bit ; Enter correct mode, ints off
        NOP
        LDMIA   r0, {r0-pc}^            ; Restore int state, r0 never banked


95      MOV     r14_svc, r0
        LDMIA   r14_svc, {r0-r12, r13_usr, r14_usr}^
; ECN: Inserted NOP to avoid registers being trashed.
        NOP
        LDR     r14_svc, [r14_svc, #15*4]
        MOVS    pc, r14_svc             ; Jump to instruction in right mode


ContinueError1
        MOV     r14, #-1
        STR     r14, [r4, r3]           ; Only need to zap address field
        BL      message_writes
        DCB     "M41", 0		; "Bad breakpoint at &"
        ALIGN
        MOVVC   r10, r1
        BICVC   R10,R10,#ARM_CC_Mask
        BLVC    DisplayHexWord
        EXIT    VS
        BL      message_writes
        DCB     "M42", 0		; "; cleared."
        ALIGN
        SWIVC   XOS_NewLine
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Debug_Code

        LDR     wp, [r12]

; .............................................................................

Debug_Code_Common ENTRY "r6-r11"

10
        BL      message_writes
        DCB     "M43", 0		; "Debug*"
        ALIGN

        ADRVC   r0, StringBuffer
        MOVVC   r1, #?StringBuffer-1
        MOVVC   r2, #space
        MOVVC   r3, #255
        SWIVC   XOS_ReadLine
        EXIT    VS
        BCS     %FT50

        SWIVC   XOS_CLI

40      BLVS    PrintError
        B       %BT10

50      BL      AckEscape

        TEQ     r1, #0                  ; Any chars read ?
        EXIT    EQ                      ; VSet, return error

        SWI     XOS_NewLine             ; Need to print a NewLine as we
        SETV                            ; didn't terminate the Iine with CR/LF
        B       %BT40

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

AckEscape ENTRY "r1, r2"

        MOV     r0, #&7E
        SWI     XOS_Byte

        ADRVC   r0, ErrorBlock_Escape
        BLVC    CopyError
        EXIT

        MakeInternatErrorBlock Escape,,Escape

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PrintError ENTRY

        ADD     r0, r0, #4
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r10 = number to be displayed
;       r2 = starting bit position

; Out   r0 corrupt if error

DisplayHex ENTRY "r0, r2"

10      MOV     r0, r10, LSR r2
        AND     r0, r0, #15
        CMPS    r0, #9
        ORRLS   r0, r0, #"0"
        ADDHI   r0, r0, #"A"-10
        SWI     XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS

        SUBS    r2, r2, #4
        BPL     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Out   r10 corrupt

DisplayHexWord_R9

        MOV     r10, r9

; .............................................................................

DisplayHexWord ENTRY "r2"

        MOV     r2, #32-4
        BL      DisplayHex
        EXIT

; .............................................................................

 [ Thumb
DisplayHexHalfword ENTRY "r2"

        MOV     r2, #16-4
        BL      DisplayHex
        EXIT
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r9 -> core
;       r2 = number of chars to print

; Out   VS: r0 -> error
;       VC: all preserved

DisplayCharacters ENTRY "r0, r2, r9"

10
 [ Addr26
        BIC     r9, r9, #&FC000000      ; Wrap within 64M each loop
 ]
        LDRB    r0, [r9], #1
        CMPS    r0, #delete
        CMPNES  r0, #space-1
        MOVLS   r0, #"."
        SWI     XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS

        SUBS    r2, r2, #1
        BNE     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r8 = number to display

DisplayDecimalNumber ENTRY "r0-r2"

        SUB     sp, sp, #16
        MOV     r0, r8
        MOV     r1, sp
        MOV     r2, #16
        SWI     XOS_BinaryToDecimal

        ADD     r2, r2, r1
10      LDRB    r0, [r1], #1
        SWI     XOS_WriteC
        BVS     %FT90
        CMPS    r1, r2
        BLT     %BT10

90      ADD     sp, sp, #16
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r9 = address to consider

MarkBreakpoints ENTRY "r2, r3"

        ADR     r2, Breaklist
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r14, [r2, r3]
        TEQS    r14, r9
        MOVEQ   r0, #"*"                ; [found]
        BEQ     %FT50
        SUBS    r3, r3, #8
        BPL     %BT10
        MOV     r0, #":"                ; [not found]

50      SWI     XOS_WriteI+space
        SWIVC   XOS_WriteC
        SWIVC   XOS_WriteI+space
        EXIT

; .............................................................................

MarkPC ALTENTRY

        LDR     r14, pc_register
        BIC     r14, r14, #ARM_CC_Mask
        TEQS    r14, r9
        MOVEQ   r0, #"<"                ; [found]
        MOVNE   r0, #":"                ; [not found]

        B       %BT50                   ; Share some code

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Swap old data back into core, remembering our branches

SwapAllBreakpoints ENTRY "r1-r5"

        ADR     r4, Breaklist
        ADD     r5, r4, #4              ; r5 -> old data list to index on
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        CMP     r1, #-1
        LDRNE   r2,  [r1]               ; Get our branch
        LDRNE   r14, [r5, r3]           ; Get old data
        STRNE   r2,  [r5, r3]
        STRNE   r14, [r1]
        SUBS    r3, r3, #8
        BPL     %BT10
        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Code to be relocated into RAM at initialise time

RelocatedCodeStart ROUT

        GBLA    count
count   SETA    0
        WHILE   count < nbreakpoints
        STR     r14, Registers_ROM+14*4 ; Dump current r14 directly
        BL      ClaimBreak              ; pc relative, into RAM code really
count   SETA    count + 1
        WEND

ClaimBreak
        STR     r14, TrapStore_ROM      ; Save id of breakpoint
        ADR     r14, Registers_ROM
        STMIA   r14, {r0-r13}           ; Save registers 0 to 13 in dump area
        LDR     wp, r12Store_ROM
        LDR     pc, JumpStore_ROM       ; Jump to debugger with correct wp

RelocatedCodeEnd ; End of relocated code - next instruction is a patched branch
                 ; to the debugger

 ASSERT RelocatedCodeEnd-RelocatedCodeStart = BreakCodeEnd-BreakCodeStart

TrapStore_ROM   *       (TrapStore - BreakCodeStart) + RelocatedCodeStart
Registers_ROM   *       (Registers - BreakCodeStart) + RelocatedCodeStart
r12Store_ROM    *       (r12Store  - BreakCodeStart) + RelocatedCodeStart
JumpStore_ROM   *       (JumpStore - BreakCodeStart) + RelocatedCodeStart

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; A breakpoint has been hit

BreakTrap ROUT

        SWI     XOS_EnterOS             ; And why not too!

        LDR     r1, TrapStore
        AND     r3, r1, #ARM_CC_Mask    ; Save mode and flags
        BIC     r1, r1, #ARM_CC_Mask
        ADR     r0, BreakCodeStart      ; Calculate Breakpoint number we hit
        SUB     r0, r1, r0
        SUB     r0, r0, #8
        ADR     r1, Breaklist
        LDR     r10, [r1, r0]
        ORR     r10, r10, r3
        STR     r10, pc_register        ; Save pc+psr from breakpoint

        BL      message_writes
        DCB     "M44", 0
        ALIGN

        BIC     R10,R10,#ARM_CC_Mask
        BLVC    DisplayHexWord          ; Tee hee, nowhere to go if VS! <<<
        SWIVC   XOS_NewLine

        BLVC    ShowRegs_Code_Common
        BLVC    Debug_Code_Common

        SWI     XOS_NewLine
        SWI     XOS_Exit

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> string
;       r2 -> error to generate if naff syntax (ie. no p1, trailing op or crap)

GetCommandParms_R0

        MOV     r1, r0

; .............................................................................
; In    r1 -> string
;       r2 -> error to generate if naff syntax (ie. no p1, trailing op or crap)

; Decodes string of form <addr|reg> [[+|-] <addr|reg>]

; Out   r9 = parm1
;       r8 = parm state
;       r7 = parm2

hasparm         *       2_001
parmfollowed    *       2_010
secondparm      *       2_100

; a         -> a, X
; a b       -> a, b
; a + b     -> a, a+b
; a - b     -> a-b, a
; a + b + c -> a+b, a+b+c
; a - b + c -> a-b, a-b+c

GetCommandParms ENTRY "r2"

 [ debug
 DSTRING r1, "Command tail "
        BL      %FT00
 DREG r9, "p1 ",cc
 DREG r7, " p2 ",cc
 DREG r8, " state ",,Byte
        EXIT

00
        ENTRY
 ]

        BL      ReadFirstParm           ; r7 := parm
        EXIT    VS

        TST     r8, #hasparm
        BEQ     %FT99                   ; [no parm1, so it's bad news]

        MOV     r9, r7                  ; r9 := parm1

        TST     r8, #parmfollowed
        EXIT    EQ                      ; [no parm2]

        ORR     r8, r8, #secondparm

        TEQ     r0, #"+"
        TEQNE   r0, #"-"
        BNE     %FT50

        ORR     r8, r8, r0, LSL #8      ; has '+' or '-', so skip it
        ADD     r1, r1, #1

50      BL      ReadParm                ; r7 := parm2
        EXIT    VS

        TST     r8, #hasparm            ; [no second parm when there should be]
        BEQ     %FT99                   ; [ie. after operator]

        MOVS    r14, r8, LSR #8
        BEQ     %FT80                   ; [no operator]

        TEQ     r14, #"+"               ; addition ?
        ADDEQ   r7, r9, r7              ; -> a, a+b
        SUBNE   r14, r9, r7             ; subtraction then
        MOVNE   r7, r9
        MOVNE   r9, r14                 ; -> a-b, a

        TST     r8, #parmfollowed
        EXIT    EQ                      ; [no second operator]

        TEQ     r0, #"+"                ; so we can *mi base -offset1 +offset2
        BNE     %FT99                   ;        or *mi base +offset1 +offset2

        Push    "r7, r14"               ; save r7, first operator
        ADD     r1, r1, #1              ; skip '+'
        BL      ReadParm                ; r7 := parm3
        Pull    "r1, r14"
        EXIT    VS

        TEQ     r14, #"+"               ; it does work, honest ...
        MOVEQ   r9, r1                  ; a, a+b -> a+b, a+b+c
        ADD     r7, r9, r7              ; a-b, a -> a-b, a-b+c

                                        ; and fall into ...

80      TST     r8, #parmfollowed
        EXIT    EQ                      ; [no trailing non-blank muck]


99      LDR     r0, [sp]
        SETV
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string

; Out   r7 = value of parm
;       r8 = parm state
;       r0 = next ~space char

ReadFirstParm ROUT

        MOV     r8, #0                  ; nowt so far

; .............................................................................

ReadParm ENTRY "r2"

 [ debug
 DSTRING r1, "ReadParm "
        BL      %FT00
 DREG r7, "parm ",cc
 DREG r8, ", state "
        EXIT

00
        ENTRY
 ]
        BIC     r8, r8, #hasparm + parmfollowed ; in all cases

        BL      SkipSpaces
        EXIT    LO

        ORR     r0, r0, #&20            ; Cheap and nasty lowercase

        TEQ     r0, #"r"
        BEQ     %FT50                   ; register

        TEQ     r0, #"p"
        MOVEQ   r0, #"c"                ; Expect 'c'
        LDREQ   r7, pc_register
 [ :LNOT: Addr26
        BICEQ   r7, r7, #ARM_CC_Mask    ; knock off psr bits for "pc" but not for "r15"
 ]
        BEQ     %FT60

        TEQ     r0, #"l"
        MOVEQ   r0, #"r"                ; Expect 'r'
        LDREQ   r7, Registers + 14*4
 [ :LNOT: Addr26
        BICEQ   r7, r7, #ARM_CC_Mask    ; knock off psr bits for "lr" but not for "r14"
 ]
        BEQ     %FT60

        TEQ     r0, #"s"
        MOVEQ   r0, #"p"                ; Expect 'p'
        LDREQ   r7, Registers + 13*4
        BEQ     %FT60

        TEQ     r0, #"w"
        MOVEQ   r0, #"p"                ; Expect 'p'
        LDREQ   r7, Registers + 12*4
        BEQ     %FT60


40      MOV     r0, #16                 ; allow any term, read hex
        SWI     XOS_ReadUnsigned
        MOVVC   r7, r2

45      EXIT    VS

        BL      SkipSpaces
        ORR     r8, r8, #hasparm
        ORRCS   r8, r8, #parmfollowed
        EXIT


50      ADD     r1, r1, #1
        MOV     r0, #(2_001 :SHL: 29) + 10 ; allow any term, read decimal, rest
        MOV     r2, #15
        SWI     XOS_ReadUnsigned

        ADRVC   r14, Registers
        LDRVC   r7, [r14, r2, LSL #2]   ; load register n from dump
        B       %BA45


60      LDRB    r14, [r1, #1]
        ORR     r14, r14, #&20          ; Cheap and nasty lowercase
        TEQ     r14, r0                 ; Expected ?
        BNE     %BT40                   ; give error from ReadUnsniged

        ADD     r1, r1, #2              ; skip 'pc'
        B       %BA45                   ; and skip spaces

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string
;       r0 -> error to generate if parmfollowed

; Out   r7, r8 from ReadFirstParm

ReadOneParm ENTRY "r0"

        BL      ReadFirstParm           ; r7 := parm
        EXIT    VS

        TST     r8, #parmfollowed
        LDRNE   r0, [sp]
        SETV    NE
        STRVS   r0, [sp]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string

; Out   r0 = first non-space char
;       flags from CMP r0, #space for eol detection. (LO -> r0 = CtrlChar)

SkipSpaces ROUT

10      LDRB    r0, [r1], #1
        CMPS    r0, #space
        BEQ     %BT10
        SUB     r1, r1, #1      ; Leave r1 -> ~space
        MOV     pc, lr          ; r0 = first ~space

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = branch destination
;       r1 = branch location (ie. where it is executed)

; Out   r2 = branch instruction

MakeBranch ROUT

        SUB     r2, r0, r1
        SUB     r2, r2, #8
        MOV     r2, r2, ASR #2
        BIC     r2, r2, #&FF000000
        ORR     r2, r2, #&EA000000      ; BAL instruction
 [ debug
 DREG r0,"Branch instruction to get to ",cc
 DREG r1," from ",cc
 DREG r2," is "
 ]
        MOVS    pc, lr

lookup_r10 ENTRY r0-r7
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r10
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r10, r2
        EXIT

message_writes
        ENTRY   r0-r7
        BIC     r0, lr, #&fc000003
        MOV     r2, r0
10      LDRB    r1, [r2], #1
        TEQS    r1, #0
        BNE     %B10
        SUB     r2, r2, r0
        ADD     r2, r2, #3
        BIC     r2, r2, #3
        ADD     lr, lr, r2
        STR     lr, [sp, #8 * 4]
        B       message_write0_tail

message_write0 ENTRY r0-r7
message_write0_tail
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMPS    r0, #32
        SWIHS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        EXIT

CopyErrorP1 ENTRY r1-r7
        BL      open_messagefile
        EXIT    VS
        ADRL    R4,Debug_Title
        B       CopyError0

CopyErrorR2
        MOV     R0,R2

CopyError ENTRY r1-r7
        BL      open_messagefile
        EXIT    VS
        MOV     R4, #0
CopyError0
        ADR     R1, MessageFile_Block
	ADR	R2, StringBuffer
	MOV	R3, #?StringBuffer
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.Debugger.Messages", 0

        ALIGN

open_messagefile ENTRY r0-r2
        LDR     r0, MessageFile_Open
        CMPS    r0, #0			; clears V
        EXIT    NE
        ADR     R0, MessageFile_Block
        ADR     R1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ rp0512

memorytest2
;for memorya - only allow values <&3000000
  STMFD R13!,{R7-R9,R14}
  CMPS R7,#&3000000
  CMPLTS R9,#&3000000
  BHS bad_write_addr
  B memtest

memorytest
  STMFD R13!,{R7-R9,R14}
memtest
  ;address range=R9 to R7

  ;under <&2000000 call OS_ValidateAddress
  ;no if within &3000000-&33FFFFF
  ;yes if &3400000-&3FFFFFF

  ;is high address above validated area ?
  CMPS r7,#&2000000
  BHS above_logical

  ;feed both through OS_ValidateAddress
  MOV r0,r9
  MOV r1,r7
  SWI XOS_ValidateAddress
  BCS bad_addr
values_ok
  LDMFD R13!,{R7-R9,R15}


above_logical
  ;is low address below this range
  CMPS r9,#&2000000
  BHS not_logical

  ;validate from low address to end of logical ram
  MOV r0,r9
  MOV r1,#&2000000
  SUB r1,r1,#1
  SWI XOS_ValidateAddress
  BCS bad_addr

not_logical
  ;now bounce if either involve, or pass &3000000-&33FFFFF
  ;logic - if low addr<&33FFFFF and hi>&3000000 bounce it - crosses the range
  ;then bounce if either is within the range &3000000-&33FFFFF

  MOV r8,#&3400000
  SUB r8,r8,#1

  CMPS r9,r8
  BHS values_ok ;lower is >end of area, so higher must be

  CMPS r7,#&3000000
  BLT values_ok ; higher is before area, so lower must be

bad_addr
  ADR R0,badaddr
bad_common
  LDMFD R13!,{R7-R9,R14} ;recover regs and return for BL
  LDMFD R13!,{R6-R11,R14}
  B CopyError

bad_write_addr
  ADR R0,badwrite
  B bad_common

badaddr
  DCD ErrorNumber_CoreNotReadable
  = "BadRead",0
  ALIGN

badwrite
  DCD ErrorNumber_CoreNotWriteable
  = "BadWrt",0
  ALIGN

 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


        LTORG

 [ debug
        InsertDebugRoutines
 ]

	LNK	s.FP
