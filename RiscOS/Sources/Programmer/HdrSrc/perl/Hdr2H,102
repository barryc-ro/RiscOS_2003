my($dir,$script)=$0=~/^(.*)\.([^.]+)$/;
my $infile=shift @ARGV;
my $outfile=shift @ARGV;
die("Usage: $script <infile> <outfile>\n") if @ARGV || !defined $outfile;

my $TOKEN='[a-zA-Z_]\w+';
my $NUMBER='(?:-?\&[\da-zA-Z]+|-?\d+)';
my $STRING='"[^\"]*"';

processfile($infile, $outfile);

sub processfile {
  my($in, $out)=@_;
  my $tmp=$out;
  $tmp=~s/\.[^\.]*\Z/\.!tmp/;
  my $current=0;
  my $do_hex=0;
  local *F;
  open(IN, "<$in") || die("Could not open file '$in'.\n");
  open(OUT, ">$tmp") || die("Could not open file '$tmp'.\n");
  print OUT <<"END";
/* Created by Hdr2H.  Do not edit.*/
#pragma force_top_level
#pragma include_only_once

END
  while(<IN>) {
    s/\;.*//;
    next unless /\S/;
    if(/^\s+SUBT\s+/) {         # Title
      next;
    } elsif(/\AOldOpt\s+SETA/) { # Assembler specific thing
      next;
    } elsif(/\A\s+OPT\s+/) {     # Assembler specific thing
      next;
    } elsif(/\A($TOKEN)\s+([\*\#]|EQU)\s+($NUMBER|$TOKEN)\s*\Z/) {
      my($define, $type, $value)=($1, $2, $3);
      
      if($type eq '*' || $type eq 'EQU') {
        $value=~s/\&/0x/;
        printf(OUT "#define %-40s %s\n", $define, $value);
      } else {
        if($value!~/\A$NUMBER\Z/) {
          die("$file:$.: Bad space definition: '$value'\n");
        }
        if($do_hex) {
          printf(OUT "#define %-40s 0x%x\n", $define, $current);
        } else {
          printf(OUT "#define %-40s %d\n", $define, $current);
        };
        $value=~s/\&/0x/;
        $current+=eval($value);
      };
      next;
    } elsif(/^\s+\^\s+($NUMBER)\s*$/) {
      my $value=$1;
      $do_hex=($value=~s/\&/0x/);
      $current=eval($value);
      next;
    } elsif(/\A\s+GBLS\s+$TOKEN\s*\Z/) { # We can ignore these
      next;
    } elsif(/\A($TOKEN)\s+SETS\s+($STRING)/) {
      my ($define, $value)=($1, $2);
      printf(OUT "#define %-40s %s\n", $define, $value);
    } elsif(/\A\s+ASSERT\s+/) {
      # Ignore asserts - we assume the assembler deals with them.
      next;
    } elsif(/\A\s+AddError2?\s+($TOKEN)\s*,\s*($STRING)\s*(?:,\s*($NUMBER|$TOKEN)\s*)?\Z/) {
      my($define, $msg, $value)=($1, $2, $3);
      if(defined($value)) {
        printf(OUT "#define %-40s %s\n", "ErrorNumber_$define", $value);
      } else {
        if($do_hex) {
          printf(OUT "#define %-40s 0x%x\n", "ErrorNumber_$define", $current);
        } else {
          printf(OUT "#define %-40s %d\n", "ErrorNumber_$define", $current);
        };
        $current+=1;
      };
      printf(OUT "#define %-40s %s\n", "ErrorString_$define", $msg);
    } elsif(/^\s+END\s*$/) {
      next;
    } else {
      warn("$file:$.: Unrecognised line: $_");
    }
  };
  close(IN);
  close(OUT);
  unlink($out);
  rename($tmp, $out)||die("Could not rename '$tmp' to '$out'\n");
};
