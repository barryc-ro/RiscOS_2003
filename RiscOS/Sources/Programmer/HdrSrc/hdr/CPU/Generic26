        SUBT    Generic CPU Specific Definitions

OldOpt  SETA    {OPT}
        OPT     OptNoList+OptNoP1List

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************
;
; Date       Name          Description
; ----       ----          -----------
; 13-Jul-93  JRoach        Created
; 30-Jun-94  AMcC          Restore OPT
; 05-Nov-99  KBracey       Keep an eye on No26bitCode flag

       GBLS     CPU26_GetMachine
 [ :LNOT: :DEF: Included_Hdr_Machine_Machine
CPU26_GetMachine SETS "GET Hdr:Machine.<Machine>"
 |
CPU26_GetMachine SETS ""
 ]
       $CPU26_GetMachine

        ; Standard register names

r0      RN      0
R0      RN      r0
r1      RN      1
R1      RN      r1
r2      RN      2
R2      RN      r2
r3      RN      3
R3      RN      r3
r4      RN      4
R4      RN      r4
r5      RN      5
R5      RN      r5
r6      RN      6
R6      RN      r6
r7      RN      7
R7      RN      r7
r8      RN      8
R8      RN      r8
r9      RN      9
R9      RN      r9
r10     RN      10
R10     RN      r10
r11     RN      11
R11     RN      r11
r12     RN      12
R12     RN      r12
r13     RN      13
R13     RN      r13
r14     RN      14
R14     RN      r14
r15     RN      15
R15     RN      r15


        ; Special names for the banked registers

r13_usr RN      13
r14_usr RN      14

r10_fiq RN      10
r11_fiq RN      11
r12_fiq RN      12
r13_fiq RN      13
r14_fiq RN      14

r13_irq RN      13
r14_irq RN      14

r13_svc RN      13
r14_svc RN      14


        ; Standard register synonyms

lr      RN      r14                     ; Link Register
LR      RN      r14
lr_usr  RN      r14_usr
lr_fiq  RN      r14_fiq
lr_irq  RN      r14_irq
lr_svc  RN      r14_svc
link    RN      r14
LINK    RN      r14

pc      RN      r15                     ; Program Counter
PC      RN      r15

 [ :LNOT: No26bitCode
psr     RN      r15                     ; Processor Status Register
PSR     RN      r15
 ]


        ; Registers for the ARM Procedure Calling Standard

sl      RN      10
SL      RN      10
fp      RN      11
FP      RN      11
IP      RN      12
ip      RN      12


        ; Condition code symbols

Cond_EQ *       0  :SHL: 28
Cond_NE *       1  :SHL: 28
Cond_CS *       2  :SHL: 28
Cond_HS * Cond_CS
Cond_CC *       3  :SHL: 28
Cond_LO * Cond_CC
Cond_MI *       4  :SHL: 28
Cond_PL *       5  :SHL: 28
Cond_VS *       6  :SHL: 28
Cond_VC *       7  :SHL: 28
Cond_HI *       8  :SHL: 28
Cond_LS *       9  :SHL: 28
Cond_GE *       10 :SHL: 28
Cond_LT *       11 :SHL: 28
Cond_GT *       12 :SHL: 28
Cond_LE *       13 :SHL: 28
Cond_AL *       14 :SHL: 28
Cond_   * Cond_AL
Cond_NV *       15 :SHL: 28

        ; Flag position specifiers for the PSR

N_bit_number    *       31
Z_bit_number    *       30
C_bit_number    *       29
V_bit_number    *       28
I_bit_number    *       27
F_bit_number    *       26


        ; Flag value specifiers for the PSR

N_bit           *       1 :SHL: N_bit_number
Z_bit           *       1 :SHL: Z_bit_number
C_bit           *       1 :SHL: C_bit_number
V_bit           *       1 :SHL: V_bit_number
I_bit           *       1 :SHL: I_bit_number
F_bit           *       1 :SHL: F_bit_number


        ; Processor mode values for the PSR

USR_mode        *      2_00
FIQ_mode        *      2_01
IRQ_mode        *      2_10
SVC_mode        *      2_11

ARM_CC_Mask     *   &FC000003           ; Processor condition flags + mode bits


        ; Co_processor number allocations

                        ^       0
ARMCoProc_Reserved      #       1       ;  0, Reserved by Acorn
ARMCoProc_FPU           #       1       ;  1, All floating point systems
ARMCoProc_FPUextra      #       1       ;  2, For extra FP instructions
ARMCoProc_3             #       1       ;  3,
ARMCoProc_4             #       1       ;  4,
ARMCoProc_5             #       1       ;  5,
ARMCoProc_6             #       1       ;  6,
ARMCoProc_OMBRA         #       1       ;  7, Olivetti/Acorn 80x86
ARMCoProc_TestHardware  #       1       ;  8, Acorn
ARMCoProc_9             #       1       ;  9,
ARMCoProc_10            #       1       ; 10,
ARMCoProc_11            #       1       ; 11,
ARMCoProc_12            #       1       ; 12,
ARMCoProc_13            #       1       ; 13,
ARMCoProc_14            #       1       ; 14,
ARMCoProc_CacheControl  #       1       ; 15, Part of the ARM3 CPU


        ; 26 bit processor specific macro definitions

; ************************************************************
; ***  BSR - Branch to subroutine saving R14 on the stack  ***
; ************************************************************
        MACRO
$label  BSR     $dest
$label  Push    R14
        BL      $dest
        Pull    R14
        MEND

; ************************************************
; ***  CLC - Clear carry flag - will set nzcv  ***
; ************************************************
        MACRO
$label  CLC     $cond
$label  CMN$cond pc, #0         ; pc can be anything (26 or 32)
        MEND

 [ No32bitCode
; ***********************************************
; ***  CLRPSR - Clear bits in PSR from the    ***
; ***  mask in $bits, using register $regtmp  ***
; ***********************************************
        MACRO
$label  CLRPSR  $bits, $regtmp, $cond
$label  MVN$cond   $regtmp, #$bits
        TST$cond.P $regtmp, pc
        MEND
 ]

; **************************************************
; *** CLRV - Clear overflow flag - will set nzCv ***
; **************************************************
        MACRO
$label  CLRV    $cond
$label  CMP$cond pc, #0         ; pc can be anything (26 or 32)
        MEND

 [ No32bitCode
; **********************************************************************************
; ***  PHPSEI - Disable IRQs, saving an old interrupt state indicator in a       ***
; ***  register, default R14.  Note that this code preserves the C and V flags.  ***
; **********************************************************************************
        MACRO
$label  PHPSEI  $register, $regtmp      ; (we don't use regtmp, 32-bit one does)
  [ $register = " = ""
$label  MOV     R14, #I_bit
        TST     R14, PC                 ; is I_bit set ?
        TEQEQP  R14, PC                 ; no, then set it (and R14 = I_bit)
        MOVNE   R14, #0                 ; yes, then leave alone (and R14=0)
  |
$label  MOV     $register, #I_bit
        TST     $register, PC           ; is I_bit set ?
        TEQEQP  $register, PC           ; no, then set it (and $reg. = I_bit)
        MOVNE   $register, #0           ; yes, then leave alone (and R14=0)
  ]
        MEND

; **************************************************************************
; ***  PLP - Restore IRQ state from the indicator in a register (set up  ***
; ***  by PHPSEI).  Note that this code preserves the C and V flags.     ***
; **************************************************************************
        MACRO
$label  PLP     $register=R14
  [     "$register" = ""
$label  TEQP    R14, PC
  |
$label  TEQP    $register, PC
  ]
        MEND
 ]

; ****************
; ***  RETURN  ***
; ****************
        MACRO
$label  RETURN  $cond
$label  MOV$cond pc, lr
        MEND

 [ :LNOT: No26bitCode
; *****************
; ***  RETURNS  ***
; *****************
        MACRO
$label  RETURNS $cond
$label  MOV$cond.S pc, lr
        MEND
 ]

 [ No32bitCode
; ****************************************************
; ***  SCPSR - Set and clear bits in PSR from the  ***
; ***  masks $set, $clr, using register $regtmp    ***
; ****************************************************
        MACRO
$label  SCPSR   $set, $clr, $regtmp, $cond
$label  MOV$cond   $regtmp, pc
        ORR$cond   $regtmp, $regtmp, #($set) :OR: ($clr)
        TEQ$cond.P $regtmp, #$clr
        MEND
 ]

; **********************************************
; ***  SEC - Set carry flag - will set nzCv  ***
; **********************************************
        MACRO
$label  SEC     $cond
$label  CMP$cond pc, #0         ; pc can be anything (26 or 32)
        MEND

 [ No32bitCode
; ************************************************
; ***  SETPSR - Set bits in PSR from the mask  ***
; ***  in $bits, using register $regtmp        ***
; ************************************************
        MACRO
$label  SETPSR  $bits, $regtmp, $cond
$label  MOV$cond   $regtmp, pc
        ORR$cond   $regtmp, $regtmp, #$bits
        TEQ$cond.P $regtmp, #0
        MEND
 ]

; **************************************************
; ***  SETV - Set overflow flag - will set NzcV  ***
; ***  Please supply a known positive register.  ***
; **************************************************
        MACRO
$label  SETV    $cond, $register
$label
  [ "$register" = ""
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
        ; branch over on opposite condition
        DCD     &1A000001 :EOR: Cond_$cond
  ]
        CMPVC   pc, #&80000000  ; handle +ve pc
        CMNVC   pc, #&80000000  ; and -ve pc
  |
        CMP$cond $register, #&80000000
  ]
        MEND

 [ No32bitCode
; ***********************************************
; ***  TOGPSR - Toggle bits in PSR from the   ***
; ***  mask in $bits, using register $regtmp  ***
; ***********************************************
        MACRO
$label  TOGPSR  $bits, $regtmp, $cond
$label  MOV$cond   $regtmp, pc
        TEQ$cond.P $regtmp, #$bits
        MEND
 ]

        OPT     OldOpt
        END
