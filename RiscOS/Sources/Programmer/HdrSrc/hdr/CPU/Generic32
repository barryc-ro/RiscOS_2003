        SUBT    Generic 32-bit CPU Specific Definitions

OldOpt  SETA    {OPT}
        OPT     OptNoList+OptNoP1List

 [ :LNOT: :DEF: Included_Hdr_CPU_Generic32
        GBLL    Included_Hdr_CPU_Generic32
Included_Hdr_CPU_Generic32 SETL {TRUE}

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************
;
; Date       Name          Description
; ----       ----          -----------
; 05-Nov-99  KBracey       Moved from ARM600.
;                          32-bit versions of Generic26 macros created.

; 32-bit PSR transfer macros

; New positions of I and F bits in 32-bit PSR

I32_bit *       1 :SHL: 7
F32_bit *       1 :SHL: 6
IF32_26Shift *  26-6

; And the Thumb bit

T32_bit *       1 :SHL: 5

; Processor mode numbers

USR26_mode      *       2_00000
FIQ26_mode      *       2_00001
IRQ26_mode      *       2_00010
SVC26_mode      *       2_00011
USR32_mode      *       2_10000
FIQ32_mode      *       2_10001
IRQ32_mode      *       2_10010
SVC32_mode      *       2_10011
ABT32_mode      *       2_10111
UND32_mode      *       2_11011
SYS32_mode      *       2_11111

; New register names

r13_abort       RN      13
r14_abort       RN      14
lr_abort        RN      14

r13_undef       RN      13
r14_undef       RN      14
lr_undef        RN      14

 [ :LNOT: No32bitCode

        ; 32 bit versions of the macros in Generic26

        GBLA    CPU32_bits
        GBLA    CPU32_set
        GBLA    CPU32_clr

; ***************************************************
; ***  PSRto32 - Convert a PSR constant to a      ***
; ***  32-bit PSR value in variable psr32         ***
; ***  Shifts I and F into their 32-bit positions ***
; ***************************************************
        MACRO
$psr32  PSRto32 $psr
$psr32  SETA    (($psr) :AND: :NOT: (I_bit:OR:F_bit)) :OR: ((($psr) :AND: (I_bit:OR:F_bit)) :SHR: IF32_26Shift)
        MEND

; ***********************************************
; ***  CLRPSR - Clear bits in PSR from the    ***
; ***  mask in $bits, using register $regtmp  ***
; ***********************************************
        MACRO
$label  CLRPSR  $bits, $regtmp, $cond=AL
$label  mymrs   $cond, $regtmp, CPSR
CPU32_bits  PSRto32 $bits
        BIC$cond $regtmp, $regtmp, #CPU32_bits
        somemsr $cond, CPSR_cf, $regtmp, CPU32_bits
        MEND

; **********************************************************************************
; ***  PHPSEI - Disable IRQs, saving an old interrupt state indicator in a       ***
; ***  register, default R14.  Note that this code preserves the C and V flags.  ***
; ***  Don't have to supply regtmp, but if you do, we save an instruction.       ***
; **********************************************************************************
        MACRO
$label  PHPSEI  $register=R14, $regtmp
  [ "$register" = ""
  [     "$regtmp" = ""
$label  mymrs   AL, R14, CPSR
        TST     R14, #I32_bit                  ; is I32_bit set?
        ORREQ   R14, R14, #I32_bit             ; no, then set it
        mymsr   EQ, CPSR_c, R14
        BICEQ   R14, R14, #I32_bit             ; $reg contains original PSR
  |
$label  mymrs   AL, R14, CPSR
        TST     R14, #I32_bit                  ; is I32_bit set?
        ORREQ   $regtmp, R14, #I32_bit         ; no, then set it
        mymsr   EQ, CPSR_c, $regtmp            ; $reg contains original PSR
  ]
  |
  [     "$regtmp" = ""
$label  mymrs   AL, $register, CPSR
        TST     $register, #I32_bit            ; is I32_bit set?
        ORREQ   $register, $register, #I32_bit ; no, then set it
        mymsr   EQ, CPSR_c, $register
        BICEQ   $register, $register, #I32_bit ; $reg contains original PSR
  |
$label  mymrs   AL, $register, CPSR
        TST     $register, #I32_bit            ; is I32_bit set?
        ORREQ   $regtmp, $register, #I32_bit   ; no, then set it
        mymsr   EQ, CPSR_c, $regtmp            ; $reg contains original PSR
  ]
  ]
        MEND

; **************************************************************************
; ***  PLP - Restore IRQ state from the indicator in a register (set up  ***
; ***  by PHPSEI).  Note that this code preserves the C and V flags.     ***
; **************************************************************************
        MACRO
$label  PLP     $register=R14
  [ "$register" = ""
$label  mymsr   AL, CPSR_c, R14
  |
$label  mymsr   AL, CPSR_c, $register
  ]
        MEND

; ******************
; ***  RETURNVC  ***
; ******************
        MACRO
$label  RETURNVC  $cond
$label
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
        ; branch over on opposite condition
        DCD     &1A000001 :EOR: Cond_$cond
  ]
        CMP     pc, #0
        MOV     pc, lr
        MEND

; ******************
; ***  RETURNVS  ***
; ******************
        MACRO
$label  RETURNVS  $cond
$label
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
        ; branch over on opposite condition
        DCD     &1A000002 :EOR: Cond_$cond
  ]
        CMPVC   pc, #&80000000  ; handle +ve pc
        CMNVC   pc, #&80000000  ; and -ve pc
        MOV     pc, lr
        MEND

; ****************************************************
; ***  SCPSR - Set and clear bits in PSR from the  ***
; ***  masks $set, $clr, using register $regtmp    ***
; ****************************************************
        MACRO
$label  SCPSR   $set, $clr, $regtmp, $cond
$label  mymrs   $cond, $regtmp, CPSR
        [ ($set :AND: $clr) <> 0
        ! 0, "Attempt to simultaneously set and clear a bit in SCPSR"
        ]
CPU32_set PSRto32 $set
CPU32_clr PSRto32 $clr
 [ CPU32_set <> 0
        ORR$cond $regtmp, $regtmp, #CPU32_set
 ]
 [ CPU32_clr <> 0
        BIC$cond $regtmp, $regtmp, #CPU32_clr
 ]
        somemsr  $cond, CPSR_cf, $regtmp, CPU32_set:OR:CPU32_clr
        MEND

; ****************************************************
; ***  SavePSR - Save the PSR in a register, to be ***
; ***  restored later using RestorePSR             ***
; ****************************************************
        MACRO
$label  SavePSR $reg, $cond
$label  mymrs   $cond, $reg, CPSR
        MEND

; ****************************************************
; ***  RestPSR - Restore the PSR from a register   ***
; ***  set up by SavePSR                           ***
; ****************************************************
        MACRO
$label  RestPSR $reg, $cond
$label  mymsr   $cond, CPSR_cf, $reg
        MEND

; ************************************************
; ***  SETPSR - Set bits in PSR from the mask  ***
; ***  in $bits, using register $regtmp        ***
; ************************************************
        MACRO
$label  SETPSR  $bits, $regtmp, $cond=AL
$label  mymrs   $cond, $regtmp, CPSR
CPU32_bits PSRto32 $bits
        ORR$cond $regtmp, $regtmp, #CPU32_bits
        somemsr $cond, CPSR_cf, $regtmp, CPU32_bits
        MEND

; ***********************************************
; ***  TOGPSR - Toggle bits in PSR from the   ***
; ***  mask in $bits, using register $regtmp  ***
; ***********************************************
        MACRO
$label  TOGPSR  $bits, $regtmp, $cond=AL
$label  mymrs   $cond, $regtmp, CPSR
CPU32_bits PSRto32 $bits
        EOR$cond $regtmp, $regtmp, #CPU32_bits
        somemsr $cond, CPSR_cf, $regtmp, CPU32_bits
        MEND

; *************************************************
; ***  WritePSRc - Set the PSR control bits to  ***
; ***  an absolute value.                       ***
; ***  Sets I,F,M[0:1], corrupts NZVC.          ***
; ***  Preserves 32-bitness.                    ***
; ***  Only use in IRQ26/32,FIQ26/32,SVC26/32   ***
; ***  Ignored in USR modes, illegal in others  ***
; ***  Use instead of TEQP PC,#0 etc            ***
; *************************************************
        MACRO
$label  WritePSRc $bits, $regtmp
        [ $bits :AND::NOT: (I_bit+F_bit+SVC_mode) <> 0
	! 1, "Illegal flags for WritePSRc"
        ]
$label  SCPSR   $bits, (I_bit+F_bit+SVC_mode):EOR:($bits), $regtmp, AL
        MEND

; Original AAsm macros
        MACRO
        mrs     $cond, $rd, $psrs
        mymrs   $cond, $rd, $psrs
        MEND

        MACRO
        msr     $cond, $psrl, $op2a, $op2b
        mymsr   $cond, $psrl, $op2a, $op2b
        MEND


; ***************************************************
; *** somemsr - Set some fields of the PSR from   ***
; *** $op, according to $mask. The mask should    ***
; *** indicate which bits have been modified.     ***
; *** This saves us writing the control field,    ***
; *** when it hasn't been modified, for example,  ***
; *** saving 2 cycles on some processors.         ***
; ***************************************************
        MACRO
$label  somemsr $cond, $psr, $op, $mask
        LCLS    s
s       SETS    "$psr._"
 [ $mask :AND: &FF <> 0
s       SETS    s:CC:"c"
 ]
 [ $mask :AND: &FF00 <> 0
s       SETS    s:CC:"x"
 ]
 [ $mask :AND: &FF0000 <> 0
s       SETS    s:CC:"s"
 ]
 [ $mask :AND: &FF000000 <> 0
s       SETS    s:CC:"f"
 ]
$label  mymsr   $cond, $psr, $op
        MEND

; Funny names for ObjAsm compatibility
        MACRO
        mymrs   $cond, $rd, $psrs
        LCLA    psrtype
psrtype SETA    -1
 [ "$psrs" = "CPSR" :LOR: "$psrs" = "CPSR_all"
psrtype SETA    0 :SHL: 22
 ]
 [ "$psrs" = "SPSR" :LOR: "$psrs" = "SPSR_all"
psrtype SETA    1 :SHL: 22
 ]
        ASSERT  psrtype <> -1
        ASSERT  $rd <> 15
        &       Cond_$cond :OR: 2_00000001000011110000000000000000 :OR: psrtype :OR: ($rd :SHL: 12)
        MEND

        MACRO
        mymsr   $cond, $psrl, $op2a, $op2b
        LCLA    psrtype
        LCLS    op2as
        LCLA    op
        LCLA    shift
        LCLS    s
s       SETS    "$psrl"
 [ s:RIGHT:4 = "_ctl" :LOR: s:RIGHT:4 = "_flg"
s       SETS    s:LEFT:(:LEN:s-2)
 ]
 [ s:RIGHT:4 = "_all"
s       SETS    s:LEFT:(:LEN:s-3) :CC: "cf"
 ]
 [ s:RIGHT:3 = "PSR"
s       SETS    s:CC:"_cf"
 ]
        ASSERT  s:LEFT:5 = "CPSR_" :LOR: s:LEFT:5 = "SPSR_"
 [ s:LEFT:5 = "SPSR_"
psrtype SETA    (1:SHL:22)
|
psrtype SETA    (0:SHL:22)
 ]
s       SETS    s :RIGHT: (:LEN:s-5)

 [ s:LEFT:1 = "c"
psrtype SETA    psrtype :OR: (1:SHL:16)
s       SETS    s :RIGHT: (:LEN:s-1)
 ]
 [ s:LEFT:1 = "x"
psrtype SETA    psrtype :OR: (1:SHL:17)
s       SETS    s :RIGHT: (:LEN:s-1)
 ]
 [ s:LEFT:1 = "s"
psrtype SETA    psrtype :OR: (1:SHL:18)
s       SETS    s :RIGHT: (:LEN:s-1)
 ]
 [ s:LEFT:1 = "f"
psrtype SETA    psrtype :OR: (1:SHL:19)
s       SETS    s :RIGHT: (:LEN:s-1)
 ]
        ASSERT  s = ""
 [ (psrtype :AND: (15:SHL:16)) = 0
        ! 0, "MSR that sets no fields"
 ]
 [ ("$op2a" :LEFT: 1) = "#"
 ; Immediate operand

op2as   SETS    "$op2a" :RIGHT: ((:LEN: "$op2a")-1)
op      SETA    $op2as

  [ "$op2b" = ""
  ; Rotate not specified in immediate operand
shift   SETA    0
        WHILE   (op :AND: &FFFFFF00)<>0 :LAND: shift<16
op      SETA    ((op:SHR:30):AND:3):OR:(op:SHL:2)
shift   SETA    shift + 1
        WEND
        ASSERT  (op :AND: &FFFFFF00)=0
  |
  ; Rotate of immediate operand specified explicitly
        ASSERT  (($op2b):AND:&FFFFFFE1)=0
shift   SETA    ($opt2b):SHR:1
  ]
op      SETA    (shift :SHL: 8) :OR: op :OR: (1:SHL:25)
 |

 ; Not an immediate operand
  [ "$op2b" = ""
  ; Unshifted register
op      SETA    ($op2a) :OR: (0:SHL:25)
  |
        ! 1, "Shifted register not yet implemented in this macro!"
  ]
 ]
        &       Cond_$cond :OR: 2_00000001001000001111000000000000 :OR: op :OR: psrtype
        MEND

; SetMode newmode, reg1, regoldpsr
;
; Sets processor mode to constant value newmode
; using register reg1 as a temporary.
; If regoldpsr is specified, then this register
; on exit holds the old PSR before the mode change
; reg1 on exit always holds the new PSR after the mode change

        MACRO
        SetMode $newmode, $reg1, $regoldpsr
 [ "$regoldpsr"=""
        mymrs   AL, $reg1, CPSR
        BIC     $reg1, $reg1, #&1F
        ORR     $reg1, $reg1, #$newmode
        mymsr   AL, CPSR_c, $reg1
 |
        mymrs   AL, $regoldpsr, CPSR
        BIC     $reg1, $regoldpsr, #&1F
        ORR     $reg1, $reg1, #$newmode
        mymsr   AL, CPSR_c, $reg1
 ]
        MEND

 ] ; :LNOT: No32bitCode

 ] ; :LNOT: :DEF: Included_Hdr_CPU_Generic32

        OPT     OldOpt
        END
