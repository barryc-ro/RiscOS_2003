        SUBT    Generic 32-bit CPU Specific Definitions

OldOpt  SETA    {OPT}
        OPT     OptNoList+OptNoP1List

 [ :LNOT: :DEF: Included_Hdr_CPU_Generic32
        GBLL    Included_Hdr_CPU_Generic32
Included_Hdr_CPU_Generic32 SETL {TRUE}

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************
;
; Date       Name          Description
; ----       ----          -----------
; 05-Nov-99  KBracey       Moved from ARM600.
;                          32-bit versions of Generic26 macros created.

; 32-bit PSR transfer macros

; New positions of I and F bits in 32-bit PSR

I32_bit *       1 :SHL: 7
F32_bit *       1 :SHL: 6
IF32_26Shift *  26-6

; And the Thumb bit

T32_bit *       1 :SHL: 5

; Processor mode numbers

USR26_mode      *       2_00000
FIQ26_mode      *       2_00001
IRQ26_mode      *       2_00010
SVC26_mode      *       2_00011
USR32_mode      *       2_10000
FIQ32_mode      *       2_10001
IRQ32_mode      *       2_10010
SVC32_mode      *       2_10011
ABT32_mode      *       2_10111
UND32_mode      *       2_11011
SYS32_mode      *       2_11111

; New register names

r13_abort       RN      13
r14_abort       RN      14
lr_abort        RN      14

r13_undef       RN      13
r14_undef       RN      14
lr_undef        RN      14

 [ :LNOT: No32bitCode

        ; 32 bit versions of the macros in Generic26

        GBLA    CPU32_bits
        GBLA    CPU32_set
        GBLA    CPU32_clr

; ***************************************************
; ***  PSRto32 - Convert a PSR constant to a      ***
; ***  32-bit PSR value in variable psr32         ***
; ***  Shifts I and F into their 32-bit positions ***
; ***************************************************
        MACRO
$psr32  PSRto32 $psr
$psr32  SETA    (($psr) :AND: :NOT: (I_bit:OR:F_bit)) :OR: ((($psr) :AND: (I_bit:OR:F_bit)) :SHR: IF32_26Shift)
        MEND

; ***********************************************
; ***  CLRPSR - Clear bits in PSR from the    ***
; ***  mask in $bits, using register $regtmp  ***
; ***********************************************
        MACRO
$label  CLRPSR  $bits, $regtmp, $cond
$label  mrs     $cond, $regtmp, CPSR
CPU32_bits  PSRto32 $bits
        BIC$cond $regtmp, $regtmp, #CPU32_bits
        msr     $cond, CPSR_cf, $regtmp
        MEND

; **********************************************************************************
; ***  PHPSEI - Disable IRQs, saving an old interrupt state indicator in a       ***
; ***  register, default R14.  Note that this code preserves the C and V flags.  ***
; ***  Don't have to supply regtmp, but if you do, we save an instruction.       ***
; **********************************************************************************
        MACRO
$label  PHPSEI  $register=R14, $regtmp
  [ "$register" = ""
  [     "$regtmp" = ""
$label  mrs     AL, R14, CPSR
        TST     R14, #I32_bit                  ; is I32_bit set?
        ORREQ   R14, R14, #I32_bit             ; no, then set it
        msr     EQ, CPSR_c, R14
        BICEQ   R14, R14, #I32_bit             ; $reg contains original PSR
  |
$label  mrs     AL, R14, CPSR
        TST     R14, #I32_bit                  ; is I32_bit set?
        ORREQ   $regtmp, R14, #I32_bit         ; no, then set it
        msr     EQ, CPSR_c, $regtmp            ; $reg contains original PSR
  ]
  |
  [     "$regtmp" = ""
$label  mrs     AL, $register, CPSR
        TST     $register, #I32_bit            ; is I32_bit set?
        ORREQ   $register, $register, #I32_bit ; no, then set it
        msr     EQ, CPSR_c, $register
        BICEQ   $register, $register, #I32_bit ; $reg contains original PSR
  |
$label  mrs     AL, $register, CPSR
        TST     $register, #I32_bit            ; is I32_bit set?
        ORREQ   $regtmp, $register, #I32_bit   ; no, then set it
        msr     EQ, CPSR_c, $regtmp            ; $reg contains original PSR
  ]
  ]
        MEND

; **************************************************************************
; ***  PLP - Restore IRQ state from the indicator in a register (set up  ***
; ***  by PHPSEI).  Note that this code preserves the C and V flags.     ***
; **************************************************************************
        MACRO
$label  PLP     $register=R14
  [ "$register" = ""
$label  msr     AL, CPSR_c, R14
  |
$label  msr     AL, CPSR_c, $register
  ]
        MEND

; ****************************************************
; ***  SCPSR - Set and clear bits in PSR from the  ***
; ***  masks $set, $clr, using register $regtmp    ***
; ****************************************************
        MACRO
$label  SCPSR   $set, $clr, $regtmp, $cond
$label  mrs     $cond, $regtmp, CPSR
CPU32_set PSRto32 $set
CPU32_clr PSRto32 $clr
        ORR$cond $regtmp, $regtmp, #CPU32_set
        BIC$cond $regtmp, $regtmp, #CPU32_clr
        msr     $cond, CPSR_cf, $regtmp
        MEND

; ************************************************
; ***  SETPSR - Set bits in PSR from the mask  ***
; ***  in $bits, using register $regtmp        ***
; ************************************************
        MACRO
$label  SETPSR  $bits, $regtmp, $cond
$label  mrs     $cond, $regtmp, CPSR
CPU32_bits PSRto32 $bits
        ORR$cond $regtmp, $regtmp, #CPU32_bits
        msr     $cond, CPSR_cf, $regtmp
        MEND

; ***********************************************
; ***  TOGPSR - Toggle bits in PSR from the   ***
; ***  mask in $bits, using register $regtmp  ***
; ***********************************************
        MACRO
$label  TOGPSR  $bits, $regtmp, $cond
$label  mrs     $cond, $regtmp, CPSR
CPU32_bits PSRto32 $bits
        EOR$cond $regtmp, $regtmp, #CPU32_bits
        msr     $cond, CPSR_cf, $regtmp
        MEND


        MACRO
        mrs     $cond, $rd, $psrs
        LCLA    psrtype
psrtype SETA    -1
 [ "$psrs" = "CPSR" :LOR: "$psrs" = "CPSR_all"
psrtype SETA    0 :SHL: 22
 ]
 [ "$psrs" = "SPSR" :LOR: "$psrs" = "SPSR_all"
psrtype SETA    1 :SHL: 22
 ]
        ASSERT  psrtype <> -1
        ASSERT  $rd <> 15
        &       Cond_$cond :OR: 2_00000001000011110000000000000000 :OR: psrtype :OR: ($rd :SHL: 12)
        MEND

        MACRO
        msr     $cond, $psrl, $op2a, $op2b
        LCLA    psrtype
        LCLS    op2as
        LCLA    op
        LCLA    shift
psrtype SETA    -1
 [ "$psrl" = "CPSR" :LOR: "$psrl" = "CPSR_all" :LOR: "$psrl" = "CPSR_cf"
psrtype SETA    (0:SHL:22) :OR: (1:SHL:19) :OR: (1:SHL:16)
 ]
 [ "$psrl" = "CPSR_flg" :LOR: "$psrl" = "CPSR_f"
psrtype SETA    (0:SHL:22) :OR: (1:SHL:19) :OR: (0:SHL:16)
 ]
 [ "$psrl" = "CPSR_ctl" :LOR: "$psrl" = "CPSR_c"
psrtype SETA    (0:SHL:22) :OR: (0:SHL:19) :OR: (1:SHL:16)
 ]
 [ "$psrl" = "SPSR" :LOR: "$psrl" = "SPSR_all" :LOR: "$psrl" = "SPSR_cf"
psrtype SETA    (1:SHL:22) :OR: (1:SHL:19) :OR: (1:SHL:16)
 ]
 [ "$psrl" = "SPSR_flg" :LOR: "$psrl" = "SPSR_f"
psrtype SETA    (1:SHL:22) :OR: (1:SHL:19) :OR: (0:SHL:16)
 ]
 [ "$psrl" = "SPSR_ctl" :LOR: "$psrl" = "SPSR_c"
psrtype SETA    (1:SHL:22) :OR: (0:SHL:19) :OR: (1:SHL:16)
 ]
        ASSERT  psrtype <> -1
 [ ("$op2a" :LEFT: 1) = "#"
 ; Immediate operand

op2as   SETS    "$op2a" :RIGHT: ((:LEN: "$op2a")-1)
op      SETA    $op2as

  [ "$op2b" = ""
  ; Rotate not specified in immediate operand
shift   SETA    0
        WHILE   (op :AND: &FFFFFF00)<>0 :LAND: shift<16
op      SETA    ((op:SHR:30):AND:3):OR:(op:SHL:2)
shift   SETA    shift + 1
        WEND
        ASSERT  (op :AND: &FFFFFF00)=0
  |
  ; Rotate of immediate operand specified explicitly
        ASSERT  (($op2b):AND:&FFFFFFE1)=0
shift   SETA    ($opt2b):SHR:1
  ]
op      SETA    (shift :SHL: 8) :OR: op :OR: (1:SHL:25)
 |

 ; Not an immediate operand
  [ "$op2b" = ""
  ; Unshifted register
op      SETA    ($op2a) :OR: (0:SHL:25)
  |
        ! 1, "Shifted register not yet implemented in this macro!"
  ]
 ]
        &       Cond_$cond :OR: 2_00000001001000001111000000000000 :OR: op :OR: psrtype
        MEND

; SetMode newmode, reg1, regoldpsr
;
; Sets processor mode to constant value newmode
; using register reg1 as a temporary.
; If regoldpsr is specified, then this register
; on exit holds the old PSR before the mode change
; reg1 on exit always holds the new PSR after the mode change

        MACRO
        SetMode $newmode, $reg1, $regoldpsr
 [ "$regoldpsr"=""
        mrs     AL, $reg1, CPSR
        BIC     $reg1, $reg1, #&1F
        ORR     $reg1, $reg1, #$newmode
        msr     AL, CPSR_c, $reg1
 |
        mrs     AL, $regoldpsr, CPSR
        BIC     $reg1, $regoldpsr, #&1F
        ORR     $reg1, $reg1, #$newmode
        msr     AL, CPSR_c, $reg1
 ]
        MEND

 ] ; :LNOT: No32bitCode

 ] ; :LNOT: :DEF: Included_Hdr_CPU_Generic32

        OPT     OldOpt
        END
