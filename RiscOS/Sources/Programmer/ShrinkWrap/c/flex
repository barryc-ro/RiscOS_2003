/*->c.flex */

#define BOOL int
#define TRUE 1
#define FALSE 0


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

#include "h.mem"
#include "h.err"

#include "h.flex"




typedef struct
{
 flex_ptr anchor;      /* *anchor should point back to here. */
 int size;             /* in bytes. Exact size of logical area. */
                       /* then the actual store follows. */
} flex__rec;




static void flex__fail(int i)
{
/* printf("xxxxxxxxxxxxxxxxxxx i=%d xxxxxxxxxxxxxxxxxxxxx",i); */

/* memcorrupt(i); */

 i=i;
}



static int roundup(int i)
{
  return 0xfffffffc & (i + 3);
}


static char *flex__freep;       /* free flex memory */
static char *flex__lim;         /* limit of flex memory */
static char *flex__base;


/* From base upwards, it's divided into store blocks of
  a flex__rec
  the space
  align up to next word.
*/




static BOOL flex__more(int n)
{
 return(memextend(n));
}



static void flex__give(void)
{
 memcontract();
}



static BOOL flex__ensure(int n)
{
 n-=flex__lim-flex__freep;
 if(n<=0 || flex__more(n)) return(TRUE);
 else                      return(FALSE);
}



_kernel_oserror * flex_alloc(flex_ptr anchor, int n)
{
 flex__rec *p;

/* printf("alloc %d\n",n); */

 if(n<0 || ! flex__ensure(sizeof(flex__rec) + roundup(n)))
 {
  *anchor = 0;
  return(&mb_malloc_failed);
 }

 p = (flex__rec*) flex__freep;
 flex__freep += sizeof(flex__rec) + roundup(n);

 p->anchor = anchor;
 p->size = n;
 *anchor = p + 1; /* sizeof(flex__rec), that is */

 return(NULL);
}




_kernel_oserror * flex_allocc(flex_ptr anchor, int n)
{
 _kernel_oserror * err;

 err=flex_alloc(anchor,n);
 if(!err) memset(*anchor,0,n);
 return(err);
}







static void flex__reanchor(flex__rec *p, int by)
{
 /* Move all the anchors from p upwards. This is in anticipation
  of that block of the heap being shifted. */

 while (1)
 {
  if((int) p>=(int) flex__freep) break;
  if(*(p->anchor) != p + 1) flex__fail(6);
  *(p->anchor) = ((char*) (p + 1)) + by;
  p = (flex__rec*) (((char*) (p + 1)) + roundup(p->size));
 }
}


void flex_free(flex_ptr anchor)
{
 flex__rec *p = ((flex__rec*) *anchor) - 1;
 int roundsize = roundup(p->size);
 flex__rec *next = (flex__rec*) (((char*) (p + 1)) + roundsize);


 if(p->anchor!=anchor)
 {
  flex__fail(0);
 }

 flex__reanchor(next, - (sizeof(flex__rec) + roundsize));

 memmove(p,next,flex__freep-(char*) next);

 flex__freep-=sizeof(flex__rec) + roundsize;

 flex__give();

 *anchor = 0;
}



int flex_size(flex_ptr anchor)
{
 flex__rec *p = ((flex__rec*) *anchor) - 1;
 if(p->anchor!=anchor)
 {
  flex__fail(4);
 }
 return(p->size);
}



_kernel_oserror * flex_extend(flex_ptr anchor, int newsize)
{
 flex__rec *p = ((flex__rec*) *anchor) - 1;

 return(flex_midextend(anchor, p->size, newsize - p->size));
}



_kernel_oserror * flex_midextend(flex_ptr anchor, int at, int by)
{
 flex__rec *p;
 flex__rec *next;


 p=((flex__rec*) *anchor) - 1;

 if(p->anchor!=anchor)
 {
  flex__fail(1);
 }

 if(at>p->size)
 {
  flex__fail(2);
 }

 if(by < 0 && (-by) > at)
 {
  flex__fail(3);
 }

 if(by == 0)
 {
  /* do nothing */
 }
 else
 if(by > 0)
 { /* extend */

  int growth = roundup(p->size + by) - roundup(p->size);
  /* Amount by which the block will actually grow. */

  if(!flex__ensure(growth))
  {
   return(&mb_malloc_failed);
  }

  next = (flex__rec*) (((char*) (p + 1)) + roundup(p->size));

  /* The move has to happen in two parts because the moving
    of objects above is word-aligned, while the extension within
    the object may not be. */

  flex__reanchor(next, growth);

  memmove(((char*) next) + roundup(growth),next,flex__freep - (char*) next);

  flex__freep += growth;

  memmove(((char*) (p + 1)) + at + by,((char*) (p + 1)) + at,p->size - at);
  p->size += by;

 }
 else
 { /* The block shrinks. */
  int shrinkage;

  next = (flex__rec*) (((char*) (p + 1)) + roundup(p->size));

  by = -by; /* a positive value now */
  shrinkage = roundup(p->size) - roundup(p->size - by);
  /* a positive value */

  memmove(((char*) (p + 1)) + at - by,((char*) (p + 1)) + at,p->size - at);
  p->size -= by;

  flex__reanchor(next, - shrinkage);

  memmove(((char*) next) - shrinkage,next,flex__freep - (char*) next);

  flex__freep -= shrinkage;

  flex__give();

 };

 return(NULL);
}




/* called when we propose to change amount of stuff in flex block */

_kernel_oserror * flex_chunk(flex_ptr anchor,int size,int chunksize)
{
 flex__rec *p = ((flex__rec*) *anchor)-1;

 if((size>=p->size) || (p->size>(size+chunksize)))
   return(flex_extend(anchor,(size/chunksize+1)*chunksize));

 return(NULL);
}



int flex_init(char * chunk,int size)
{
 flex__freep=chunk;
 flex__lim=chunk+size;
 flex__base=chunk;
 return(1);
}


int flex_newmax(char * chunk,int size)
{
 flex__lim=chunk+size;
 return(1);
}


int flex_inuse(void)
{
 return(flex__freep-flex__base);
}


int flex_max(void)
{
 return(flex__lim-flex__base);
}


int flex_reloc(char * newbase)
{
 int         shift;
 flex__rec * p;

 shift=newbase-flex__base;

 flex__base+=shift;
 flex__freep+=shift;
 flex__lim+=shift;

 p=(flex__rec *)flex__base;

 while(((int)p)<((int)flex__freep))
 {
/*printf("shift=%d *(p->anchor)=%x p+1=%x",shift,*(p->anchor),(char*)(p+1));*/

  if(*(p->anchor)!=(((char*)(p+1))-shift))
  {
   flex__fail(6);
   return(0);
  }
  *(p->anchor)=((char*)(p+1));

  p=(flex__rec*)(((char*)(p + 1))+roundup(p->size));
 }

 return(1);
}



#ifdef NEVER

/* return 1 if corrupt */


int flex_check(void)
{
 flex__rec * p;
 char      * q;

 p=(flex__rec *)flex__base;

 while(((int)p)<((int)flex__freep))
 {
  q=*(p->anchor);

  if(q<((char*)flex__base) || q>((char*)flex__freep))
  {
   deb("flex pointer at %x points to illegal address.",(int)p);
   return(1);
  }

  if(*(p->anchor)!=(((char*)(p+1))))
  {
   deb("bad flex blockat %x.",(int)p);
   return(1);
  }

/*  deb("block %x len=%d.",p,p->size);  */

  p=(flex__rec*)(((char*)(p + 1))+roundup(p->size));
 }

 return(0);
}

#endif



