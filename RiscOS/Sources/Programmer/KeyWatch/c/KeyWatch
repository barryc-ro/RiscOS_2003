/* INCLUDES */

#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include "kernel.h"
#include "swis.h"

/* CONSTANTS */

#define  KW                     "KeyWatch"
#define  KW_SWI_CHUNK_BASE      0x4E940
#define  KW_SWI_REGISTER        0
#define  KW_SWI_DEREGISTER      1
#define  KW_ERR_BAD_SWI         0x1E6 /* same as system error */
#define  KW_ERR_TABLE_FULL      (KW_SWI_CHUNK_BASE + 1)
#define  KW_ERR_BAD_POLLWORD    (KW_SWI_CHUNK_BASE + 2)
#define  KEYV_VECT              0x13
#define  KEYV_DummyKeyboard	11
#define  PW_TABLE_SIZE          10

/* TYPE DEFINITIONS */

typedef struct {
  int pollword; /* actual pollword */
  int used;     /* whether this entry is in use or not */
} pw_table_entry; /* individual entry of poll word table */

/* GLOBALS */

static _kernel_oserror kw_error;
static int initialised=0;
static pw_table_entry pollword_table[PW_TABLE_SIZE];


/* FUNCTION PROTOTYPES */

/* The following is brought in from CMHG */
extern int keyv_handler_entry(_kernel_swi_regs *r, void *pw);


/* The C part of the handler */

int keyv_handler(_kernel_swi_regs *r, void *pw)
{
  int count; /* boring loop count variable */

  /* if the reason is a key press or release or dummy keyboard */
  if ( (r->r[0] == 1) || (r->r[0] == 2) || (r->r[0] == KEYV_DummyKeyboard))
  {
    /* if it is a mouse button that has been pressed */
    if ( (r->r[1] >= 0x70) && (r->r[1] <= 0x72) )
      return 1; /* don't claim the vector and don't do anything else */

    for (count=0; count < PW_TABLE_SIZE; count++)
    {
      if (pollword_table[count].used)
        pollword_table[count].pollword++;
    } /* for */
  }

  return 1; /* don't claim the vector */
} /* keyv_handler */


_kernel_oserror *swi_handler(int swi_no, _kernel_swi_regs *r, void *private_word)
{
  int count; /* boring count variable */
  int cont=1; /* whether to continue looping */

  switch (swi_no)
  {
    case KW_SWI_REGISTER:
                          /* Find an empty table entry */
                          for (count=0; (count < PW_TABLE_SIZE) && cont;
                               count++)
                          {
                            if (pollword_table[count].used == 0) cont=0;
                          } /* for */

                          if (cont) /* table is full */
                          {
                            kw_error.errnum = KW_ERR_TABLE_FULL;
                            strcpy(kw_error.errmess,
                                   "Cannot register keywatch - table full");
                            return(&kw_error);
                          } /* if */

                          /* count is now one past what it should be, so go back */
                          count--;

                          /* mark as used */
                          pollword_table[count].used = 1;

                          /* reset pollword */
                          pollword_table[count].pollword = 0;

                          /* return pollword address in r0 */
                          r->r[0] = (int) &(pollword_table[count].pollword);
                          break;

    case KW_SWI_DEREGISTER:
                            /* find passed pollword in table - I actually look
                             * for it, rather than just add 1 to get to the
                             * used field, to verify that it is actually in
                             * the table, and not spurious */
                            for (count=0; (count < PW_TABLE_SIZE) && cont;
                                 count++)
                            {
                              if (pollword_table[count].used)
                              {
                                if (r->r[0] == (int) &(pollword_table[count].pollword))
                                  cont=0;
                              } /* if */
                            } /* for */

                            if (cont) /* reached the end of the table */
                            {
                              kw_error.errnum = KW_ERR_BAD_POLLWORD;
                              strcpy(kw_error.errmess,
                                   "Cannot deregister keywatch - bad pollword handle");
                              return(&kw_error);
                            } /* if */

                            /* set unused - NB count is one more than it should
                             * be so we decrement it */
                            pollword_table[--count].used = 0;

                            break;
    default:
             kw_error.errnum = KW_ERR_BAD_SWI;
             sprintf(kw_error.errmess, "Bad SWI number &%08x", swi_no);
             return(&kw_error);
  } /* switch */

  return NULL; /* no error */

} /* swi_handler */


/* Module initialisation code */

_kernel_oserror *kw_initialise(char *cmd_tail, int podule_base, void *private_word)
{
    _kernel_swi_regs regs;
    _kernel_oserror *kern_err=NULL;

    /* Initialise poll word table */
    memset(&pollword_table[0], 0, sizeof(pollword_table[0]) * PW_TABLE_SIZE);

    /* OS_Claim the KeyV vector */
    regs.r[0] = KEYV_VECT;
    regs.r[1] = (int) &keyv_handler_entry;
    regs.r[2] = (int) private_word;

    kern_err=_kernel_swi(OS_Claim, &regs, &regs);

    if (kern_err)
    {
      initialised=0;
      return kern_err;
    } /* if */
    else
    {
      initialised=1;
    } /* else */

    return NULL;
} /* kw_initialise */


/* Module exit code */

_kernel_oserror *kw_final(int fatal, int podule, void *private_word)
{
  _kernel_oserror *kern_err=NULL;
  _kernel_swi_regs regs;

  /* Only do anything if we were initialised */
  if (initialised)
  {
    regs.r[0] = KEYV_VECT;
    regs.r[1] = (int) &keyv_handler_entry;
    regs.r[2] = (int) private_word;

    kern_err = _kernel_swi(OS_Release, &regs, &regs);

    if (kern_err) return kern_err;
    else
    {
      initialised = 0;
    } /* else */
  } /* if */

  return NULL;
} /* kw_final */
