/************************************************************************/
/*                  Copyright 1997 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "module.h"
#include "header.h"

#define STATUS_FILE "<Wimp$ScrapDir>.mem/html"
#define STATUS_URL  "file:/<Wimp$ScrapDir>/mem.html"
#define ENV_VAR	    "Alias$URLOpen_MemInfo"
#define ENV_VAL	    "MemInfo_HTML %*0"

typedef enum {Text,HTML} style_t;

/*
 * module housekeeping globals
 */
void   *workspace_pointer = NULL;
ERROR_STRUCT(NO_FILE,"Could not open status file.");

_kernel_oserror *
url_open(char *url)
{
  _kernel_swi_regs reg;
  _kernel_oserror *err=NULL;
  char msg_block[256];
  int n;

  n = strlen(url);
  n = n>236?236:n;
  memset(msg_block, 0, 256);

  *(int *)msg_block = 256;
  *(int *)(msg_block + 16) = 0x4af80; /* Message_URL */
  strncpy(msg_block + 20, url, n);

  reg.r[0] = 0;
  reg.r[1] = (int)msg_block;
  reg.r[2] = 0;
  reg.r[3] = 0;
  reg.r[4] = 0;
  reg.r[5] = 0;

  ERR_RETURN(err,_kernel_swi(TaskModule_SendMessage, &reg, &reg));
    
  return(NULL);
}

_kernel_oserror *
display_memory_info(style_t style)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  FILE *f=NULL;
  int area,size,lba;
  char *desc;
  char utctime[8];
  char lcltime[256];
  
  *(int *)utctime = 3; 		/* reason code 3, read RTC */
  reg.r[0] = 14;
  reg.r[1] = (int)utctime;
  _kernel_swi(OS_Word, &reg, &reg);

  reg.r[0] = -1;
  reg.r[1] = (int)utctime;
  reg.r[2] = (int)lcltime;
  reg.r[3] = 256;
  _kernel_swi(Territory_ConvertStandardDateAndTime, &reg, &reg);

  if (style == HTML) {
    if((f = fopen(STATUS_FILE, "w"))==NULL) {
      return (ERROR(NO_FILE));
    }
  
    fprintf(f,"<html><head>");
    fprintf(f,"<title>Memory distribution</title>");
    fprintf(f,"</head><body BGCOLOR=\"#ffffff\">\n");
    fprintf(f,"<p><center><h1>Memory distribution</h1></p>\n");
    
    fprintf(f,"<p><b>Time:</b>%s<p>\n",lcltime);
    
    fprintf(f,"<p><table border=1 width=\"70%%\">\n");
    fprintf(f,"<tr><th>Dynamic area<th>Size (k)<th>Address\n");
  } else {
    printf("  Dynamic area             Size (k)   Address\n");
    printf("  ------------             --------   -------\n");
  }
    
  reg.r[0] = 3; 	/* enumerate dynamic areas */
  reg.r[1] = -1; 	/* start */
  ERR_GOTO(err,_kernel_swi(OS_DynamicArea,&reg,&reg));
  area = reg.r[1];
  while (area != -1) {
    reg.r[0] = 2;	/* info */
    reg.r[1] = area;
    ERR_GOTO(err,_kernel_swi(OS_DynamicArea,&reg,&reg));
    size = reg.r[2];
    lba  = reg.r[3];
    desc = (char *)reg.r[8];
    
    if (style == HTML) {
      fprintf(f,"<tr><td>%s<td align=\"right\">%d<td align=\"right\">0x%07x\n",
    	desc,size/1024,lba);
    } else {
      printf("  %-25s %6d    0x%07x\n",desc,size/1024,lba);
    }
    reg.r[0] = 3; 	/* enumerate dynamic areas */
    reg.r[1] = area;
    ERR_GOTO(err,_kernel_swi(OS_DynamicArea,&reg,&reg));
    area = reg.r[1];
  }
  
  /* application space */
  reg.r[0] = -1;
  ERR_GOTO(err,_kernel_swi(OS_ReadDynamicArea,&reg,&reg));
  lba = reg.r[0];
  size = reg.r[1];
  if (style == HTML) {
    fprintf(f,"<tr><td>Current application<td align=\"right\">%d<td align=\"right\">0x%07x\n",
     size/1024,lba);
    fprintf(f,"</table><p>\n");
  } else {
    printf("  %-25s %6d    0x%07x\n","Current application",size/1024,lba);
  }
  
  /* get total box memory */
  reg.r[0] = 0;
  ERR_GOTO(err,_kernel_swi(OS_SetEnv,&reg,&reg));
  size = reg.r[2];
  if (style == HTML) {
    fprintf(f,"<p>Total memory %dMb<p>\n",size/1024/1024);
  } else {
    printf("\n  Total memory %dMb\n",size/1024/1024);  
  }

  /* get total free memory */
  reg.r[0] = 5;		/* shrinkable reason code */
  reg.r[1] = -1;	/* all */
  if (_kernel_swi(OS_DynamicArea,&reg,&reg)==NULL) {
    size = reg.r[2];
    if (style == HTML) {
      fprintf(f,"Total free memory %dk<p>",size/1024);
    } else {
      printf("  Total free memory %dk",size/1024);
    }
  } else {
    if (style == HTML) {
      fprintf(f,"Total free memory info not available on this platform<p>\n");
    } else {
      printf("  Total free memory info not available on this platform\n");  
    }
  }


  if (style == HTML) {
    fprintf(f,"<a href=\"meminfo:\">Reload</a></center>\n");
    fprintf(f,"</body></html>\n");
    fclose(f);
    url_open(STATUS_URL);
  }
  
exit_gracefully:  
  if (f) {
    fclose(f);
  }
  
  return (err);
}


/*
 * module finalise
 */
_kernel_oserror *
module_finalise(int fatal, int podule, void *pw)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;

  /* remove variable before exiting */
  reg.r[0] = (int)ENV_VAR;
  reg.r[1] = NULL;
  reg.r[2] = -1;
  reg.r[3] = 0;
  reg.r[4] = 0;
  ERR_RETURN(err,_kernel_swi(OS_SetVarVal,&reg,&reg));
  
  return (NULL);
}
/*
 * module initialise
 */
_kernel_oserror *
module_initialise(char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *err = NULL;
  workspace_pointer = pw;

  /* set variable for browser to use */
  ERR_RETURN(err,_kernel_setenv(ENV_VAR,ENV_VAL));

  return (NULL);
}

_kernel_oserror *
module_cmd_handler(char *arg_string, int argc, int cmd_no, void *pw)
{
  _kernel_oserror *err = NULL;
  
  switch (cmd_no) {
    case CMD_MemInfo_HTML :
      ERR_RETURN(err,display_memory_info(HTML));
      break;
    case CMD_MemInfo_Text :
      ERR_RETURN(err,display_memory_info(Text));
      break;
  }
  return (NULL);
}
