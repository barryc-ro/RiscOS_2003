/************************************************************************************/
/*                                                                                  */
/*  File: msgqueue.c                                                                */
/*                                                                                  */
/*  Copyright © 1999 Element 14, The Acorn Group plc, Cambridge, England            */
/*  Documents:  MessageQueue Software Functional Specification, 1216,612/FS         */
/*              XXX: Additional design note supplements(?)                          */
/*                                                                                  */
/************************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "utils.h"

struct MessageQueue
{
  unsigned int pollword;
  unsigned int queue_size;
  void *head;
  void *tail;
  int *startof_despatch;
  int *startof_freespace;
};

typedef struct
{
  MessageQueue *handle;
  MessageNode *next;
} MessageNode;

/*
 * The register and deregister SWIs share the same mutual exclusion flag, because we
 * don't want one caller registering at the same time as another caller deregistering.
 * This would break the integrity of the list structure.
 */
static int mutex = 0;


/************************************************************************************/
/* Function:  Non re-entrant messagequeue_register()                                */
/* Behaviour: Creates a new message queue for use by the calling app'n wishing to   */
/*            receive messages.                                                     */
/* Requires:  Register arguments:                                                   */
/*            R0: Flags. If bit 0 is set, claim memory dynamically if possible.     */
/*                Bits 1 to 31 are reserved and should be zero.                     */
/*            R1: Application identifier.                                           */
/*            R2: Total buffer space to claim for message queue.                    */
/*            R3: Maximum size for a single message (or 0 if no limit).             */
/* Returns:   NULL for success, otherwise ....                                      */
/*            Call by reference returns exit registers as follows:                  */
/*            R0: Flags. If bit 0 is set, dynamic memory request was honoured.      */
/*                Bits 1 to 31 are preserved.                                       */
/*            R1: Message queue handle.                                             */
/*            R2: Address of pollword (0 indicates no messages in the queue, otw    */
/*                contains the size of the next message to be despatched).          */
/************************************************************************************/
_kernel_oserror *messagequeue_register(messagequeue_register_args *args,void *pw)
{
  MessageNode *current = NULL;

    Disable interrupts.
    if (mutex)
    {
        Re-enable interrupts.
        There is already a caller executing this SWI.  It is not re-entrant, so
        return an error.  (There might be a standard error for this kind of thing).
    }
    mutex = 1;
    Re-enable interrupts.

    NB: Plan to do away with all this.  Far more efficient way of doing it.

    /* Allocate a new base node. */

    if (head == NULL)
    {
        create node;
        head = current = tail = node;
        node.handle = NULL;
        node.next = NULL;
    }
    else
    {
        current = tail;
        if (current->next != NULL)
        {
            Development warning error.  Something's not right.
        }
        else
        {
            current->next = allocate a new node;
            current = current->next;
            current->handle = NULL;
            current->next = NULL;
            tail = current;
        }
    }

    /* Create a message queue to hang off the base node. */

    if (requested dynamic allocation)
    {
        current->handle = allocate dynamic area for message queue;
        If successful, current->handle points at the base of the new message queue
        and bit 0 of R0 is set to indicate that the request was honoured, otherwise,
        bit 0 of R0 must be cleared.
    }

    if (current->handle still NULL)
    {
        current->handle = allocate memory for message queue using the RMA;
        If successful, current->handle points at the base of the new message queue;
    }

    if (current->handle still NULL)
    {
        Leave things in a tidy state - deallocate node and reset pointers.
        mutex = 0;
        return error insufficient memory to set up message queue;
    }

    /* Initialise the new message queue. */

    handle->pollword = 0;
    handle->queue_size = size of queue (in bytes);
    handle->head = current->handle;
    handle->tail = current->handle + number of bytes specified in R2 (size of buffer).

    handle->startof_despatch = NULL;
    handle->startof_freespace = handle->head;

    Set R1 to contain the message handle;
    R2 = address of pollword;

    mutex = 0;  /* We're finished.  Allow the next caller in when it next calls. */

}

/************************************************************************************/
/* Function:  Non re-entrant messagequeue_deregister()                              */
/* Behaviour: Deletes the specified message queue.  Any messages pending delivery   */
/*            are discarded.                                                        */
/* Requires:  Register arguments:                                                   */
/*            R0: Flags (bits 0 to 31 reserved, should be zero).                    */
/*            R1: Message queue handle.                                             */
/* Returns:   NULL for success, otherwise ....                                      */
/*            Call by reference returns exit registers as follows:                  */
/*            R0: Flags.                                                            */
/*            R1: Number of messages discarded.                                     */
/************************************************************************************/
_kernel_oserror *messagequeue_deregister(messagequeue_deregister_args *args,void *pw)
{
  MessageNode *prev = NULL;
  MessageNode *current;

    Disable interrupts.
    if (mutex)
    {
        Re-enable interrupts.
        There is already a caller executing this SWI.  It is not re-entrant, so
        return an error.
    }
    mutex = 1;
    Re-enable interrupts.

    current = head;
    if (current == NULL)
    {
        mutex = 0;
        return error.  Specified message queue not found (and besides, no queues
        exist at the moment.  (Useful to know this during development and testing).
    }

    do
    {  if (current->handle == message queue handle passed in thru R1)
       {
           We've found the right queue.  Break out of loop;
       }
       else
       {
           Keep on searching.  prev = current; current = current->next;
       }
    }while (current->next != NULL)

    if (current->handle == message queue handle passed in thru R1)
    {
        /* Remove queue and associated node */
        if (prev != NULL)
        {
            prev->next = current->next;
        }
        else
        {
            head = current->next;
        }
        R1 = number of messages discarded.  (XXX: number of messages discarded = ...)
        free(current->handle);  /* Frees the message queue */
        free(current);          /* Frees the anchor node */
        current = head;         /* Current node's just been deleted.  Reset current. */
    }
    else
    {
        mutex = 0;
        return error.  Specified message queue not found.
    }

    mutex = 0;
}

/************************************************************************************/
/* Function:  Re-entrant messagequeue_send()                                        */
/* Behaviour: Sender wants to deliver a message into the specified queue.           */
/* Requires:  Register arguments:                                                   */
/*            R0: Flags (bits 0 to 31 reserved, should be zero).                    */
/*            R1: Message queue handle.                                             */
/*            R2: Points to the message.                                            */
/* Returns:   NULL for success, otherwise ...                                       */
/************************************************************************************/
_kernel_oserror *messagequeue_send(messagequeue_send_args *args)
{
  workspace *w;
  MessageNode *current;
  MessageQueue *qhandle;
  int old_startof_freespace;
  int total_freespace;
  int timestamp;
  int freespace_at_tail;
  int freespace_at_head;
  int timestamp;

    qhandle = args->mq;
    if ((current = find_queue(qhandle)) == NULL)
         return error (queue not found);

    freespace_at_tail = freespace_at_head = 0;

    Start of critical section.  Do reading and updating of startof_freespace and
    startof_despatch ptrs as close together as possible, to reduce the size of the
    critical section.

    timestamp = get OS_Monotonic time;
    if (timestamp is zero)
    {
        OS_Monotonic time has just been reset.  Zero is a special case for us, so reset
        timestamp to some other 'pretend' time which is close to but not equal to zero
        (e.g. 1 in pseudo terms).  It's highly unlikely we'll ever end up in this section
        of code.  A possible side effect if we did get here is that to the user, it
        might appear that they'd received a message or two out of order when really it's
        just the timestamp that's slightly out.
    }

    Write an invalid timestamp into the message space (e.g. zero).

    if (size of message > freespace_avail(starts,&freespace_at_tail,&freespace_at_head))
    {
        if (size of message > qhandle->queuesize)
            return Error_MessageQueue_MessageTooLarge;
        else
            return Error_MessageQueue_QueueFull;
    }

    /* Reserve space for the new message but save copying until we've exited the critical region. */

    if (startof_despatch == NULL) && (startof_freespace == head)
    {
        old_startof_freespace = qhandle->head;
        startof_freespace += size of message;
    }
    else if (((startof_despatch == NULL) && (startof_freespace != head)) ||
              (startof_freespace > startof_despatch))
    {
         old_startof_freespace = qhandle->startof_freespace;
         if (size of message <= freespace_at_tail)
             startof_freespace += size of message;
         else
             startof_freespace = qhandle->head + (size of message - qhandle->tail - startof_freespace);
    }
    else
    {
         The messages wrap round from tail to head with free space somewhere in the middle.
         old_startof_freespace = startof_freespace;
         startof_freespace += size of message;
    }

    initialise timestamp portion of our reserved space to some invalid value.

    End of critical section.

    Copy message into old_startof_freespace;
    (Remember to allow for wraparound.  We already know freespace_at_tail and
     freespace_at_head).

    /* We're ok if an interrupt occurs here.  SWI_receive won't despatch until
       it sees a valid timestamp in the message at the startof_despatch point. */

    Insert timestamp;

    if (pollword == 0)
    {
        Set it to the size of this message.
    }

}

/************************************************************************************/
/* Function:  Re-entrant messagequeue_receive()                                     */
/* Behaviour: Despatch a message from the specified queue.                          */
/* Requires:  Register arguments:                                                   */
/*            R0: Flags.  Bit 0 is used to determine whether we should discard the  */
/*            message from the queue if it's too big for the receiver, or whether   */
/*            we should divide it up into smaller messages to be delivered on       */
/*            subsequent calls to this routine. Bits 1 to 31 are reserved (zero).   */
/*            R1: Message queue handle.                                             */
/*            R2: Ptr to buffer to receive message.                                 */
/*            R3: Size of buffer.                                                   */
/* Returns:   NULL for success, otherwise ...                                       */
/*            Call by reference returns exit registers as follows:                  */
/*            R0: Flags.                                                            */
/*            R3: Decremented by size of message despatched.                        */
/************************************************************************************/
_kernel_oserror *messagequeue_receive(messagequeue_receive_args *args)
{
  (re-entrant)

  Right at the end of this SWI, the following:-
  If there are any complete messages in the queue, set the pollword, otherwise, zero
  it.  i.e. the pollword is always zero unless there is a complete message in the
  queue.  A complete message is one that has a valid timestamp added and is ready
  for despatch.
}

/************************************************************************************/
/* Function:  messagequeue_status()                                                 */
/* Behaviour: */
/************************************************************************************/
_kernel_oserror *messagequeue_status(messagequeue_status_args *args)
{
  (re-entrant)
}

/************************************************************************************/
/* Function:  find_queue()                                                          */
/* Behaviour: Looks for the specified queue.                                        */
/* Requires:  Message handle.                                                       */
/* Returns:   Ptr to the node for the specified queue, or NULL if not found.        */
/************************************************************************************/
MessageNode *find_node(MessageQueue *mq)
{
  MessageNode *current, *prev;
  workspace *w;

    current = head;
    if (current == NULL)
    {
        Queue not found (none exist).
        return NULL;
    }

    do
    {  if (current->handle == mq)
       {
           Found the right queue;
           break out of loop;
       }
       else
       {
           Keep searching.
           prev = current;
           current = current->next;
       }
    } while (current->next != NULL);

    if (current->handle == mq)
    {
        return current;
    }
    else
    {
        return NULL;
    }
}

/************************************************************************************/
/* Function:  freespace_avail()                                                     */
/* Behaviour: Determines the amt of free space available in the queue.              */
/* Returns:   Byte count of free space available.  If free space wraps around, call */
/*            by reference returns amt of free space available at tail and head     */
/*            ends as freespace_at_tail and freespace_at_head respectively.         */
/************************************************************************************/
int freespace_avail(int *startof_despatch, int *startof_freespace, int *freespace_at_tail,
  int *freespace_at_head)
{
    if (startof_despatch == NULL)
    {
        There are no messages in the queue.
        total_freespace = qhandle->queuesize;
    }
    else if (startof_freespace > startof_despatch)
    {
         Free space wraps round from tail to head.
         *freespace_at_tail = qhandle->tail - startof_freespace;
         *freespace_at_head = startof_despatch - head;
         total_freespace = *freespace_at_tail + *freespace_at_head;
    }
    else
    {
         The messages wrap round from tail to head, with free space somewhere in the middle.
         total_freespace = qhandle->startof_despatch - qhandle->startof_freespace;
    }

    if (size of message > total_freespace)
    {
        return Error_MessageQueue_MessageTooLarge;
    }

    if (startof_despatch == NULL) && (startof_freespace != head)
    {
        *freespace_at_tail = qhandle->tail - startof_freespace;
        *freespace_at_head = startof_freespace - qhandle->head;
    }

    return total_freespace;

}

/*
 * Optimization reminders:
 * Anchor list - use handle passed in, instead of searching the list.  Need to think
 *               about invalid handles being passed in tho.  Alternatively,
 *             - use array blocks (cuts down on allocs and saves searching thru the list.
 *             - or use a hash table, which the above is, more or less.
 */
