/************************************************************************************/
/*                                                                                  */
/*  File: msgqueue.c                                                                */
/*                                                                                  */
/*  Copyright © 1999 Element 14, The Acorn Group plc, Cambridge, England            */
/*  Documents:  MessageQueue Software Functional Specification, 1216,612/FS         */
/*              MessageQueue Detailed Software Design, 1216,612/DS                  */
/*  Development Testing: SimpleTest and Basher                                      */
/*                                                                                  */
/************************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>
#include <assert.h>


#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "utils.h"

#undef DEVELOPMENT
#undef CORRUPTION_CHECK

#define TRUE 1
#define FALSE 0
#define SIZEOF_HDR 24
#define RQUEST_DYNAMIC_ALLOC (1 << 0)
#define DYNAMIC_RQUEST_HONORED (flags | (1 << 0))
#define DYNAMIC_RQUEST_NOT_HONORED ((~1) & (flags))
#define TIMESTAMP_FAILED 1
#define TIMESTAMP_OFFSET 5
#define INVALID_TIMESTAMP -1
#define NO_LIMIT 0

typedef struct
{
  unsigned int sizeof_message;
  unsigned int sender_id;
  unsigned int reserved;
  unsigned int flags;
  unsigned int message_id;
  signed int timestamp;
  char *message_data;
} Message;

struct MessageQueue
{
  int dynamic_area_num;
  ApplicationId application_id;
  unsigned int pollword;
  unsigned int queue_size;
  unsigned int q_empty;
  int last_recorded_timestamp;
  unsigned int maxsize_single_msg;
  unsigned int *head;
  unsigned int *tail;
  unsigned int *startof_dispatch;
  unsigned int *startof_freespace;
  unsigned int *buff;
};

typedef struct BlockOfQueues BlockOfQueues;

struct BlockOfQueues
{
  MessageQueue qslots[32];
  struct BlockOfQueues *next;
};

static BlockOfQueues *head = NULL;

/*
 * The register and deregister SWIs share the same mutual exclusion flag, because we
 * don't want one caller registering at the same time as another caller deregistering.
 */
static int mutex = 0;

#ifdef CORRUPTION_CHECK
static int corruption_allowance = 64;
#endif

extern unsigned int enter_critical(void);
extern void restore_critical(int old_state);

BlockOfQueues *findq(int *n);
_kernel_oserror * freespace_avail (MessageQueue q, unsigned int *total_freespace,
                                        unsigned int *headspace, unsigned int *tailspace,
                                        unsigned int msgsize);
unsigned int count_msgs (MessageQueue q, unsigned int *largest);
void report_err(char *mess,int ln);

/************************************************************************************/
/* Function:  Non re-entrant messagequeue_register()                                */
/* Behaviour: Creates a new message queue for use by the calling app'n wishing to   */
/*            receive messages.                                                     */
/* Requires:  Register arguments:                                                   */
/*            R0: Flags. If bit 0 is set, claim memory dynamically if possible.     */
/*            Bits 1 to 31 are reserved and should be zero.                         */
/*            R1: Application identifier.                                           */
/*            R2: Total buffer space to claim for message queue.                    */
/*            R3: Maximum size for a single message (or 0 if no limit).             */
/* Returns:   error_NOT_ENOUGH_MEMORY, or NULL.  NULL can mean that the function    */
/*            completed successfully, or, the caller is not adhering to the rules   */
/*            of re-entrancy.  (This SWI is non re-entrant).  Call by reference     */
/*            returns exit registers as follows:                                    */
/*            R0: Flags. If bit 0 is set, dynamic memory request was honoured.      */
/*            Bits 1 to 31 are preserved.                                           */
/*            R1: Message queue handle.                                             */
/*            R2: Address of pollword (0 indicates no messages in the queue, otw    */
/*            contains the size of the next message to be dispatched).              */
/************************************************************************************/
extern _kernel_oserror *messagequeue_register(messagequeue_register_args *args)
{
  BlockOfQueues *current = NULL;
  int i = 0;
  BlockOfQueues *p = NULL;
  unsigned int *p2 = NULL;
  BlockOfQueues *prev = NULL;
  int blocknum = 0;
  int old_state = 0;
  int flags = 0;
  _kernel_swi_regs regs;
  int queuesize;
  char str_sizecheck[12];
  ApplicationId application_id;
  int max_msg_size;

    old_state = enter_critical();
    if (mutex)
    {
        restore_critical(old_state);
        return NULL;
    }
    mutex = 1;
    restore_critical(old_state);

    flags = args->in.flags;
    application_id = args->in.application_id;
    queuesize = args->in.total_space;
    max_msg_size = args->in.maximum_size;

    if (max_msg_size > queuesize)
        max_msg_size = queuesize;

    while (queuesize % 4 != 0)
           queuesize++;

    if (queuesize < SIZEOF_HDR)
    {
        sprintf(str_sizecheck,"%d",queuesize);
        args->out.mq_handle = -1;
        args->out.pollword = NULL;
        mutex = 0;
        return make_error(error_BAD_MESSAGE_SIZE,1,str_sizecheck);
    }

    if (max_msg_size < SIZEOF_HDR)
    {
        sprintf(str_sizecheck,"%d",max_msg_size);
        args->out.mq_handle = -1;
        args->out.pollword = NULL;
        mutex = 0;
        return make_error(error_BAD_MESSAGE_SIZE,1,str_sizecheck);
    }

    if (max_msg_size % 4 != 0)
    {
        sprintf(str_sizecheck,"%d",max_msg_size);
        args->out.mq_handle = -1;
        args->out.pollword = NULL;
        mutex = 0;
        return make_error(error_BAD_MESSAGE_SIZE,1,str_sizecheck);
    }

    if (head == NULL)
    {
         if ((p = malloc(sizeof(BlockOfQueues))) == NULL)
         {
              args->out.mq_handle = -1;
              args->out.pollword = NULL;
              mutex = 0;
              return make_error(error_NOT_ENOUGH_MEMORY,0);
         }

         for (i = 0; i < 32; p->qslots[i].buff = NULL, i++);
         p->next = NULL;
         head = current = p;
         i = 0;
    }
    else
    {
         current = head;

         i = 0;
         while ((current->qslots[i].buff != NULL) && (p == NULL))
         {
                 for (i = 0; i < 32; i++)
                 {
                      if (current->qslots[i].buff == NULL)
                      {
                          goto spare_slot_found;
                      }
                 }

                 /*
                 Look in the next block.  If there are no more blocks to look in,
                 we need to create a new block of queue handles.
                 */

                 if (current->next == NULL)
                 {
                      if ((p = malloc(sizeof(BlockOfQueues))) == NULL)
                      {
                           args->out.mq_handle = -1;
                           args->out.pollword = NULL;
                           mutex = 0;
                           return make_error(error_NOT_ENOUGH_MEMORY,0);
                      }

                      for (i = 0; i < 32; p->qslots[i].buff = NULL, i++);
                      p->next = NULL;
                      prev = current;
                      current = p;
                 }
                 else
                 {
                      current = current->next;
                 }
                 i = 0;
                 blocknum++;
          }
    }

    spare_slot_found:  /* Now slot in a new message queue buffer. */

    if (p == NULL)
    {
        p = current;
    }

    if (flags & RQUEST_DYNAMIC_ALLOC)
    {
        regs.r[0] = regs.r[4] = regs.r[6] = regs.r[7] = 0;
        regs.r[1] = regs.r[3] = -1;

        #ifdef CORRUPTION_CHECK
        regs.r[2] = regs.r[5] = queuesize + corruption_allowance;
        #else
        regs.r[2] = regs.r[5] = queuesize;
        #endif

        regs.r[8] = (int)"MsgQ";
        if ((_kernel_swi(OS_DynamicArea,&regs,&regs)) == NULL)
        {
             p2 = (unsigned int *)regs.r[3];
             args->out.flags = DYNAMIC_RQUEST_HONORED;
             p->qslots[i].dynamic_area_num = regs.r[1];

             #ifdef DEVELOPMENT
             printf("Start of dispatch on creation: %u, 0x%x\n",(unsigned int)(p2),(unsigned int)p2);
             memset(p2,0xff,queuesize);
             #endif
        }
        else
        {
             args->out.flags = DYNAMIC_RQUEST_NOT_HONORED;
             p2 = NULL;
        }
    }

    if (p2 == NULL)
    {
        #ifdef CORRUPTION_CHECK
        if ((p2 = malloc(queuesize + corruption_allowance)) == NULL)
        #else
        if ((p2 = malloc(queuesize)) == NULL)
        #endif
        {
             if (prev != NULL)
             {
                 free(current);
             }
             mutex = 0;
             args->out.mq_handle = -1;
             args->out.pollword = NULL;
             return make_error(error_NOT_ENOUGH_MEMORY,0);
        }
        else
        {
             p->qslots[i].dynamic_area_num = -1;
        }
    }

    /* Initialise the new message queue. */

    p->qslots[i].application_id = application_id;
    p->qslots[i].pollword = 0;
    p->qslots[i].queue_size = queuesize;
    p->qslots[i].q_empty = TRUE;
    p->qslots[i].last_recorded_timestamp = 1;
    p->qslots[i].head = (unsigned int *)p2;
    p->qslots[i].tail = (unsigned int *)((int)p2 + (int)(p->qslots[i].queue_size));
    p->qslots[i].maxsize_single_msg = max_msg_size;
    p->qslots[i].startof_dispatch = NULL;
    p->qslots[i].startof_freespace = p->qslots[i].head;
    args->out.mq_handle = (blocknum * 32) + i;
    args->out.pollword = &(p->qslots[i].pollword);

    if (prev != NULL)
    {
        prev->next = p;
    }

    current->qslots[i].buff = p2;

    #ifdef DEVELOPMENT
    printf("Queue handle %d\n",i);
    printf("head: %d, 0x%x\n",(int)p->qslots[i].head,(int)p->qslots[i].head);
    printf("tail: %d, 0x%x\n",(int)p->qslots[i].tail,(int)p->qslots[i].tail);
    #endif

    #ifdef CORRUPTION_CHECK
    memset(p2,0xff,queuesize + corruption_allowance);
    /* Corruption allowance portion should never change.  Check after       */
    /* each operation and if it does change, report corruption detection.   */
    #endif

    mutex = 0;  /* We're finished. Allow the next caller in when it next calls. */

    return NULL;
}

/************************************************************************************/
/* Function:  Non re-entrant messagequeue_deregister()                              */
/* Behaviour: Deletes the specified message queue.  Any messages pending delivery   */
/*            are discarded.                                                        */
/* Requires:  Register arguments:                                                   */
/*            R0: Flags (bits 0 to 31 reserved, should be zero).                    */
/*            R1: Message queue handle.                                             */
/* Returns:   error_UNKNOWN_QUEUE, or NULL.  NULL can mean that the function        */
/*            completed successfully, or, the caller is not adhering to the rules   */
/*            of re-entrancy.  (This SWI is non re-entrant).                        */
/*            Call by reference returns exit registers as follows:                  */
/*            R0: Flags.                                                            */
/*            R1: Number of messages discarded.                                     */
/* Prerequisites: MUST NOT BE CALLED FROM WITHIN AN INTERRUPT.                      */
/************************************************************************************/
extern _kernel_oserror *messagequeue_deregister(messagequeue_deregister_args *args)
{
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;
  BlockOfQueues *current;
  unsigned int *p;
  int old_state;
  int n;

    old_state = enter_critical();
    if (mutex)
    {
       restore_critical(old_state);
       return NULL;
    }
    mutex = 1;
    restore_critical(old_state);

    n = args->in.mq_handle;
    if ((current = (findq(&n))) == NULL)
    {
         mutex = 0;
         return make_error(error_UNKNOWN_QUEUE,0);
    }

    p = current->qslots[n].buff;
    current->qslots[n].buff = NULL;

    /* From here on, we're safe if interrupted by a send or receive, since the queue
       won't be found.  (Don't want send / receive to be working with partially deallocated
       memory or altering the number of messages in the queue while we're counting).
     */

    args->out.discard_count = count_msgs(current->qslots[n],NULL);

    if (current->qslots[n].dynamic_area_num == -1)
    {
        free(p); /* Guaranteed not NULL */
    }
    else
    {
        regs.r[0] = 1;
        regs.r[1] = current->qslots[n].dynamic_area_num;
        if ((er = _kernel_swi(OS_DynamicArea,&regs,&regs)) != NULL)
        {
             report_err(er->errmess,__LINE__);
        }
    }

    mutex = 0;

    return NULL;
}

/************************************************************************************/
/* Function:  Re-entrant messagequeue_send()                                        */
/* Behaviour: Sender wants to deliver a message into the specified queue.           */
/* Requires:  Register arguments:                                                   */
/*            R0: Flags (bits 0 to 31 reserved, should be zero).                    */
/*            R1: Message queue handle.                                             */
/*            R2: Points to the message.                                            */
/* Returns:   NULL for success, otherwise, error_BAD_MESSAGE_SIZE, error_UNKNOWN_   */
/*            QUEUE, error_MESSAGE_TOO_LARGE, or error_QUEUE_FULL.                  */
/************************************************************************************/
extern _kernel_oserror *messagequeue_send(messagequeue_send_args *args)
{
  MessageQueue *q;
  unsigned int * old_startof_freespace;
  int timestamp;
  unsigned int freespace_at_tail = 0;
  unsigned int freespace_at_head = 0;
  unsigned int total_freespace = 0;
  int old_state;
  BlockOfQueues *current;
  int n;
  unsigned int msgsize;
  _kernel_oserror *e = NULL;
  _kernel_swi_regs regs;
  char str_msgsize[12];
  int mq_handle;
  void *message;
  #ifdef CORRUPTION_CHECK
  _kernel_oserror ce;
  int i;
  char *p
  #endif

    mq_handle = args->in.mq_handle;
    message = args->in.buffer;

    if (message != NULL)
    {
        msgsize = *((unsigned int *)(message));
        if ((msgsize % 4) != 0)
        {
             sprintf(str_msgsize,"%d",msgsize);
             return make_error(error_BAD_MESSAGE_SIZE,1,str_msgsize);
        }
    }
    else
    {
        return make_error(error_BAD_MESSAGE_SIZE,1,"0");
    }

    n = mq_handle;

    if ((current = (findq(&n))) == NULL)
    {
         return make_error(error_UNKNOWN_QUEUE,0);
    }

    q = &(current->qslots[n]);

    if (msgsize > q->maxsize_single_msg)
    {
        return make_error(error_MESSAGE_TOO_LARGE,0);
    }

    if ((e = _kernel_swi(OS_ReadMonotonicTime,&regs,&regs)) != NULL)
    {
         timestamp = TIMESTAMP_FAILED;
    }
    else
    {
         timestamp = regs.r[0];
    }

    if (timestamp == 0)
    {
        /*
         OS_Monotonic time has just been reset.  Zero is a special case for us, so reset
         timestamp to some other 'pretend' time which is close to but not equal to zero
         (e.g. 1 in pseudo terms).  It's highly unlikely we'll ever end up in this section
         of code.  A possible side effect if we did get here is that to the user, it
         might appear that they'd received a message or two out of order when really
         it's just the timestamp that's slightly out.  Unlikely to ever occur.
        */
         timestamp = 1;
    }

    old_state = enter_critical();

    if ((e = freespace_avail(current->qslots[n],&total_freespace,&freespace_at_head,&freespace_at_tail,msgsize))
         != NULL)
    {
         return e;
    }

    if (msgsize > total_freespace)
    {
        if (msgsize > q->queue_size)
            return make_error(error_MESSAGE_TOO_LARGE,0);
        else
            return make_error(error_QUEUE_FULL,0);
    }

    /* Reserve space for the new message but save copying until we've exited the critical region. */

    old_startof_freespace = q->startof_freespace;

    /* Cases 1,5 (refer section 5.2, detailed design 1216,612/DS) */
    if (((q->startof_dispatch != NULL) && (q->startof_dispatch < q->startof_freespace) && (q->startof_dispatch != NULL)) ||
        ((q->startof_dispatch == NULL) && (q->startof_freespace != q->head)))
    {
          if (msgsize < (int)q->tail - (int)q->startof_freespace)
          {
              q->startof_freespace += msgsize/4;
          }
          else if (msgsize == (int)q->tail - (int)q->startof_freespace)
          {
              q->startof_freespace = q->head;
          }
          else
          {

              q->startof_freespace = (unsigned int *)((int)q->head + msgsize - (int)q->tail + (int)q->startof_freespace);
          }

          if (q->startof_dispatch == NULL)
          {
              q->startof_dispatch = old_startof_freespace;
          }
    }
    /* Cases 2,4,7 (refer section 5.2, detailed design 1216,612/DS) */
    else if (((q->startof_dispatch != NULL) && (q->startof_dispatch > q->startof_freespace)) ||
             ((q->startof_dispatch == q->head) && (q->startof_freespace > q->startof_dispatch)) ||
             ((q->startof_dispatch != NULL) && (q->startof_dispatch == q->head) && (q->startof_freespace > q->startof_dispatch)))
    {
          q->startof_freespace += msgsize/4;
    }
    /* Case 3 (refer section 5.2, 1216,612/DS) */
    else if ((q->startof_dispatch == NULL) && (q->startof_freespace == q->head))
    {
         q->startof_freespace += msgsize/4;
         q->startof_dispatch = q->head;
    }
    /* Case 6 (refer section 5.2, 1216,612/DS) */
    else if (q->startof_freespace == q->startof_dispatch)
    {
         report_err("Unexpected path of execution. startof_freespace == startof_dispatch.",__LINE__);
    }
    else
    {
         report_err("Unexpected path of execution.",__LINE__);
    }


    if (((int)old_startof_freespace + TIMESTAMP_OFFSET * 4) < (int)q->tail)
    {
        *((int *)((int)old_startof_freespace + TIMESTAMP_OFFSET * 4)) = INVALID_TIMESTAMP;
    }
    else
    {
        *((int *)((int)q->head + TIMESTAMP_OFFSET * 4 - (int)q->tail + (int)old_startof_freespace)) = INVALID_TIMESTAMP;

        #ifdef DEVELOPMENT
        printf("Wrapping ++++\n");
        printf("head: 0x%x\n",(int)q->head);
        printf("tail: 0x%x\n",(int)q->tail);
        printf("old_startof_freespace: 0x%x\n",(int)old_startof_freespace);
        printf("0x%x + %d * 4 - 0x%x + 0x%x = 0x%x\n",(int)q->head,TIMESTAMP_OFFSET, (int)q->tail,(int)old_startof_freespace,
                (int)q->head + TIMESTAMP_OFFSET * 4 - (int)q->tail + (int)old_startof_freespace);
        #endif
    }

    /* If timestamp we saved earlier is less than last recorded timestamp ... */
    if (timestamp < q->last_recorded_timestamp)
    {
         timestamp = q->last_recorded_timestamp;
    }
    else
    {
         q->last_recorded_timestamp = timestamp;
    }

    restore_critical(old_state);

    if (msgsize <= freespace_at_tail)
    {
        memcpy(old_startof_freespace,message,msgsize);
    }
    else if (msgsize > (unsigned int)((int)q->tail - (int)old_startof_freespace))
    {
        memcpy(old_startof_freespace,message,freespace_at_tail);
        memcpy(q->head,(unsigned int *)(message) + freespace_at_tail / 4,freespace_at_head);
    }
    else
    {
        memcpy(old_startof_freespace,(unsigned int *)(message),msgsize);
    }

    /* We're ok if an interrupt happens here.  SWI_receive won't dispatch until
       it sees a valid timestamp in the message at the startof_dispatch point. */

     if (((int)old_startof_freespace + TIMESTAMP_OFFSET * 4) < (int)q->tail)
     {
         *((int *)(old_startof_freespace + TIMESTAMP_OFFSET)) = timestamp;
     }
     else
     {
         *((int *)((int)q->head + TIMESTAMP_OFFSET * 4 - (int)q->tail + (int)old_startof_freespace)) = timestamp;
     }

     #ifdef DEVELOPMENT
     printf("timestamp: 0x%x, %d\n",timestamp,timestamp);
     #endif

   /* Don't use the pollword, because it can temporarily be zero in the middle of
      a recieve (to prevent the owner of the queue receiving messages out of
      order during one particular interrupt scenario. Use q_empty flag instead. */
    old_state = enter_critical();
    if (q->q_empty == TRUE)
    {
         q->pollword = msgsize;
         q->q_empty = FALSE;
    }
    restore_critical(old_state);

    #ifdef DEVELOPMENT
    printf("start of freespace after send: %d, 0x%x\n",(int)q->startof_freespace,(int)q->startof_freespace);
    #endif

    #ifdef CORRUPTION_CHECK
    p = (char *)q->tail;
    for (i = 0; i < corruption_allowance; i++)
    {
         if (*(p+i) != 0xff)
         {
             printf("Possible corruption detected at end of send(), handle: %d, i: %d\n",mq_handle,i);
             sprintf(ce.errmess,"Possible corruption detected at end of send(), handle: %d, i: %d, value: 0x%x\n",mq_handle,i,(int)(*(p+i)));
             return &ce;
         }
    }
    #endif


    return NULL;
}

/************************************************************************************/
/* Function:  Re-entrant messagequeue_receive()                                     */
/* Behaviour: Dispatch a message from the specified queue.                          */
/* Requires:  Register arguments:                                                   */
/*            R0: Flags.  Copy as much of the message as possible, into the callers */
/*            buffer.  Then, if the bit 0 is set, discard the message from the queue*/
/*            as normal.  If bit 0 is not set, keep the message.  This gives the    */
/*            caller a chance to retry with a larger buffer.                        */
/*            Bits 1 to 31 are reserved (zero).                                     */
/*            R1: Message queue handle.                                             */
/*            R2: Ptr to buffer to receive message.                                 */
/*            R3: Size of buffer.                                                   */
/* Returns:   NULL for success, otherwise, error_UNKNOWN_QUEUE or error_QUEUE_EMPTY.*/
/*            Call by reference returns exit registers as follows:                  */
/*            R0: Flags.                                                            */
/*            R3: Decremented by size of message dispatched.                        */
/************************************************************************************/
extern _kernel_oserror *messagequeue_receive(messagequeue_receive_args *args)
{
  int buffer_too_small = 0;
  unsigned int messagespace_at_tail = 0;
  unsigned int messagespace_at_head = 0;
  unsigned int cbufsize;
  int n;
  unsigned int msgsize;
  MessageQueue *q = NULL;
  unsigned int old_state;
  BlockOfQueues *current = NULL;
  int flags;
  void *buffer;
  int sizeof_buffer;
  #ifdef CORRUPTION_CHECK
  int h,i;
  _kernel_oserror e;
  char *p;
  #endif

    flags = args->in.flags;
    buffer = args->in.buffer;
    sizeof_buffer = args->in.size_of_buffer;

    #ifdef CORRUPTION_CHECK
    h = args->in.mq_handle;
    #endif

    n = args->in.mq_handle;
    if ((current = (findq(&n))) == NULL)
    {
         return make_error(error_UNKNOWN_QUEUE,0);
    }

    q = &(current->qslots[n]);

    /* pollword == 0 implies we're already in the middle of dispatching a message to this caller. */
    /* If we allow the interrupt, the caller will receive messages out of order, so don't allow it.  */
    if ((q->startof_dispatch == NULL) || (q->pollword == 0))
    {
         return make_error(error_QUEUE_EMPTY,0);
    }

    msgsize = *(q->startof_dispatch);

    q->pollword = 0;

    /* Its safe to do all this outside the critical region because we're protected from a 2nd receive,
       and a send interrupt won't interfere with our space because we haven't released it yet. */
    if ((unsigned int)(q->startof_dispatch) + msgsize > (unsigned int)(q->tail))
    {
     /* Message wraps */
        messagespace_at_tail = (unsigned int)((int)q->tail - (int)q->startof_dispatch);
        messagespace_at_head = msgsize - messagespace_at_tail;
    }
    args->out.outsize = sizeof_buffer - (int)msgsize;

    cbufsize = (unsigned int)sizeof_buffer;

    if ((msgsize <= cbufsize) && (messagespace_at_head != 0))
    {
         memcpy(buffer,q->startof_dispatch,messagespace_at_tail);
         if (messagespace_at_head > 0)
         {
             memcpy((char *)buffer + messagespace_at_tail,q->head,messagespace_at_head);
         }
    }
    else if ((msgsize <= cbufsize) && (messagespace_at_head == 0))
    {
         memcpy(buffer,q->startof_dispatch,msgsize);
    }
    else
    {
        buffer_too_small = TRUE;
        if ((messagespace_at_tail == 0) && (messagespace_at_head == 0))
        {
          /* Message doesn't wrap */
             memcpy(buffer,q->startof_dispatch,cbufsize);
        }
        else
        {
          /* Message wraps */
             if (messagespace_at_tail <= cbufsize)
             {
                 memcpy(buffer,q->startof_dispatch,messagespace_at_tail);
                 cbufsize -= messagespace_at_tail;
                 if (messagespace_at_head <= cbufsize)
                 {
                     memcpy((unsigned int *)(buffer) + messagespace_at_tail / 4,q->head,messagespace_at_head);
                 }
                 else
                 {
                     memcpy((unsigned int *)(buffer) + messagespace_at_tail / 4,q->head,cbufsize);
                 }
             }
             else
             {
                  memcpy(buffer,q->startof_dispatch,cbufsize);
             }
       }
    }

    /* Only keep the message if buffer was too small and bit 0 of R1 is set,
       in which case there's nothing to do.  Otherwise, as follows. */
    if (!((buffer_too_small) && (!(flags & 1))))
    {
         old_state = enter_critical();
         if ((unsigned int)(q->startof_dispatch) + msgsize < (unsigned int)(q->tail))
         {
              q->startof_dispatch = (q->startof_dispatch) + msgsize/4;
         }
         else if ((unsigned int)(q->startof_dispatch) + msgsize == (unsigned int)(q->tail))
         {
                q->startof_dispatch = q->head;
         }
         else
         {
                 /* Message wraps */
                 q->startof_dispatch = (unsigned int *)((unsigned int)(q->head) + messagespace_at_head);
         }
         restore_critical(old_state);
    }

    old_state = enter_critical();
    if (q->startof_dispatch == q->startof_freespace)
    {
       /* Queue is completely empty. */
          q->startof_dispatch = NULL;
          q->q_empty = TRUE;
       /* (pollword's already zero) */
    }
    else
    {
          q->q_empty = FALSE;
          q->pollword = *((int *)(q->startof_dispatch)); /* size of next message */
    }
    restore_critical(old_state);

    #ifdef CORRUPTION_CHECK
    p = (char *)q->tail;
    for (i = 0; i < corruption_allowance; i++)
    {
         if (*(p+i) != 0xff)
         {
             printf("Possible corruption detected at end of receive(), handle: %d, i: %d\n",h,i);
             sprintf(e.errmess,"Possible corruption detected at end of receive(), handle: %d, i: %d, value: 0x%x\n",h,i,(int)(*(p+i)));
             return &e;
         }
    }
    #endif

    return NULL;
}

/************************************************************************************/
/* Function:  Re-entrant messagequeue_status()                                      */
/* Behaviour: Describes the status of the specified message queue.                  */
/* Requires:  Register arguments as follows.                                        */
/*            R0: flags.  (Reserved, should be zero).                               */
/*            R1: message queue handle.                                             */
/* Returns:   NULL for success, otherwise, error_UNKNOWN_QUEUE.  Call by reference  */
/*            returns exit registers as follows.                                    */
/*            R0: flags.                                                            */
/*            R1: Next message queue handle (-1 if no more).                        */
/*            R2: Application identifier.                                           */
/*            R3: Total buffer space claimed for message queue.                     */
/*            R4: Maximum size for a single message (or zero if no limit).          */
/*            R5: Number of messages currently in the queue.                        */
/*            R6: Space remaining in queue buffer.                                  */
/*            R7: Size of largest message in queue.                                 */
/************************************************************************************/
extern _kernel_oserror *messagequeue_status(messagequeue_status_args *args)
{
  int usr_handle, internal_index;
  BlockOfQueues *current;
  MessageQueue q;
  int next_usr_handle = -1;
  int i,j;
  unsigned int largest_message;
  unsigned int freespace_at_tail = 0;
  unsigned int freespace_at_head =0;
  unsigned int space_remaining;

    /* Find the current message queue */

    usr_handle = args->in.mq_handle;
    internal_index = usr_handle;

    if ((current = (findq(&internal_index))) == NULL)
    {
         return make_error(error_UNKNOWN_QUEUE,0);
    }
    q = current->qslots[internal_index];

    /* Report the next message queue handle */

    i = internal_index; j = usr_handle;

    while (!((current->next == NULL) && (i == 31)))
    {
       if ((i == 31) && (current->next != NULL))
       {
            current = current->next;
            i = 0;
       }
       else
       {
            i++;
       }

       j++;

       if (current->qslots[i].buff != NULL)
       {
           next_usr_handle = j;
           break;
       }
    }

    args->out.next_mq_handle = next_usr_handle;

    /* Remaining fields */
    args->out.application_id = q.application_id;
    args->out.total_space = q.queue_size;
    args->out.maximum_size = q.maxsize_single_msg;
    args->out.count = count_msgs(q,&largest_message);
    args->out.largest_message = largest_message;

    /* Space remaining */
    freespace_avail(q,&space_remaining,&freespace_at_head,&freespace_at_tail,0);

    args->out.space_remaining = space_remaining;

    return NULL;
}

/************************************************************************************/
/* Function:  findq()                                                               */
/* Behaviour: Sets the current block pointer and the index into the block, such     */
/*            that the current message queue can be found at current->qslots[n].    */
/* Requires:  -'n', which is the message queue handle as seen at user level.        */
/*            -'current', which can be any value on entry.                          */
/* Returns:   Returns 'current' as described, or NULL if queue not found.  Call by  */
/*            reference converts 'n' from a user level handle in the range 0..n,    */
/*            (where n has no limit), to an internal handle in the range 0..31.     */
/************************************************************************************/
BlockOfQueues *findq(int *n)
{
  BlockOfQueues *current = NULL;

    if (*n < 0)
        return NULL;

    current = head;

    while (1)
    {
        if (current == NULL)
            return NULL;

        if (*n < 32)
            break;

        *n -= 32;
        current = current->next;
    }

    if (current->qslots[*n].buff == NULL)
        return NULL;

    return current;
}

/************************************************************************************/
/* Function: count_msgs()                                                           */
/* Returns:  Count of the number of messages in the specified queue.  Call by       */
/*           reference returns the largest message in the queue.                    */
/************************************************************************************/
unsigned int count_msgs (MessageQueue q,unsigned int *largest)
{
  unsigned int msg_size;
  unsigned int count = 0;
  unsigned int *startof_dispatch = NULL;
  unsigned int *startof_freespace = NULL;


    if (largest != NULL)
    {
        *largest = 0;
    }

    startof_dispatch = q.startof_dispatch;
    startof_freespace = q.startof_freespace;

    if (startof_dispatch != NULL)
    {
        while (startof_dispatch != startof_freespace)
        {
               msg_size = *(startof_dispatch);

               #ifdef DEVELOPMENT
               printf("msgsize: %d\n",(int)msg_size);
               #endif

               if (largest != NULL)
               {
                   if (msg_size > *largest)
                   {
                       *largest = msg_size;
                   }
               }

               if (((int)(startof_dispatch) + msg_size) <= (int)(q.tail))
               {
                    startof_dispatch = (unsigned int *)((unsigned int)(startof_dispatch) + msg_size);

                    if (startof_dispatch == q.tail)
                    {
                        startof_dispatch = q.head;
                    }

                    if (startof_freespace == q.tail)
                    {
                        startof_freespace = q.head;
                    }
               }
               else
               {
                    startof_dispatch = (unsigned int *)((int)startof_dispatch + msg_size - ((int)q.tail - (int)q.head));
               }

               count++;

               #ifdef DEVELOPMENT
               printf("count = %d\n",count);
               #endif
        }
    }

    return count;
}

/************************************************************************************/
/* Function: freespace_avail()                                                      */
/* Requires: 'q', which is the current message queue. 'total_freespace', 'headspace'*/
/*           and 'tailspace' do not need to be set on entry, and 'msgsize', which is*/
/*           the size of the message the caller wishes to insert into the queue. If */
/*           the caller only wishes to know the total amount of free space available*/
/*           set msgsize to 0 on entry.                                             */
/* Returns:  error_MESSAGE_TOO_LARGE if 'msgsize' is greater than the total amt of  */
/*           available free space, otherwise NULL to indicate no errors.  Call by   */
/*           reference returns the total free space available in the queue, and, if */
/*           free space wraps around, returns amt of free space available at tail   */
/*           and head ends as tailspace and headspace respectively.                 */
/************************************************************************************/
_kernel_oserror * freespace_avail (MessageQueue q,unsigned int *total_freespace,
  unsigned int *headspace, unsigned int *tailspace, unsigned int msgsize)
{
  unsigned int *startof_dispatch;
  unsigned int *startof_freespace;
  unsigned int *qtail;
  unsigned int *qhead;

    startof_dispatch = q.startof_dispatch;
    startof_freespace = q.startof_freespace;
    qtail = q.tail;
    qhead = q.head;

    /* Cases 1 and 8 (refer section 5.4, detailed design 1216,612/DS) */
    if ((startof_dispatch != NULL) && (startof_dispatch < startof_freespace) && (startof_dispatch != qhead))
    {
         *tailspace = (unsigned int)((int)qtail - (int)startof_freespace);
         *headspace = (unsigned int)((int)startof_dispatch - (int)qhead);
         *total_freespace = *tailspace + *headspace;
    }
    /* Case 2 (refer section 5.4, detailed design 1216,612/DS) */
    else if ((startof_dispatch != NULL) && (startof_dispatch > startof_freespace))
    {
         *tailspace = *headspace = 0;
         *total_freespace = (unsigned int)((int)startof_dispatch - (int)startof_freespace);
    }
    /* Case 3 (refer section 5.4, detailed design 1216,612/DS) */
    else if ((startof_dispatch == NULL) && (startof_freespace == qhead))
    {
         *tailspace = *headspace = 0;
         *total_freespace = q.queue_size;
    }
    /* Cases 4 and 7 (refer section 5.4, detailed design 1216,612/DS) */
    else if (((startof_dispatch == qhead) && (startof_freespace > startof_dispatch)) ||
             ((startof_dispatch != NULL) && (startof_dispatch == qhead) && (startof_freespace > startof_dispatch)))
    {
         *tailspace = *headspace = 0;
         *total_freespace = (unsigned int)((int)qtail - (int)startof_freespace);
    }
    /* Case 5 (refer section 5.4, detailed design 1216,612/DS) */
    else if ((startof_dispatch == NULL) && (startof_freespace != qhead))
    {
         *tailspace = (unsigned int)((int)qtail - (int)startof_freespace);
         *headspace = (unsigned int)((int)startof_freespace - (int)qhead);
         *total_freespace = q.queue_size;
    }
    /* Cases 6, 9, and 10 (refer section 5.4, detailed design 1216,612/DS) */
    else if ((startof_freespace == startof_dispatch) ||
            ((startof_dispatch == qhead) && (startof_freespace == qtail)))
    {
         *tailspace = *headspace = 0;
         *total_freespace = 0;
    }

    if (msgsize > (*total_freespace))
    {
        return make_error(error_MESSAGE_TOO_LARGE,0);
    }

    return NULL;
}

/************************************************************************************/
/* Function:  deallocate_message_queues()                                           */
/* Behaviour: Deallocates all message queues, together with base blocks holding     */
/*            the handles for these queues.                                         */
/************************************************************************************/
void deallocate_message_queues(void)
{
  _kernel_swi_regs regs;
  _kernel_oserror *er;
  BlockOfQueues *current;
  MessageQueue q;
  int i = 0;

    if (head == NULL)
    {
        return;
    }

    current = head;

    do
    {
      q = current->qslots[i];

      if (q.buff != NULL)
      {
          if (q.dynamic_area_num != -1)
          {
              regs.r[0] = 1;
              regs.r[1] = q.dynamic_area_num;
              if ((er = _kernel_swi(OS_DynamicArea,&regs,&regs)) != NULL)
              {
                   report_err(er->errmess,__LINE__);
              }
          }
          else
          {
              free(q.buff);
          }
      }

      if (i == 31)
      {
          current = current->next;
          i = 0;
      }
      else
      {
          i++;
      }

    } while (current != NULL);
}

/************************************************************************************/
/* Function:       report_err()                                                     */
/* Behaviour:      Creates and sets a system variable called with appropriate error */
/*                 diagnostics.                                                     */
/* Requires:       - 'mess', which is the error message.                            */
/*                 - 'ln', which is the line number in the file in which the error  */
/*                    occurred.                                                     */
/* Assumptions:    - 'ln' is never greater than 999999.                             */
/************************************************************************************/
void report_err(char *mess,int ln)
{
 char *str = NULL;
 _kernel_swi_regs regs;

   if ((str = calloc(strlen("Set mqerr ")+
              strlen("999999")+strlen(mess)+1,sizeof(char))) != NULL)
   {
        sprintf(str,"Set err Line:%d,Error message:%s",ln,mess);
        regs.r[0] = (int)str;
        _kernel_swi(OS_CLI,&regs,&regs);
        free(str);
   }

   #ifdef DEVELOPMENT
   printf("Error at line %d of msgqueue.c\n%s\n",__LINE__,mess);
   fflush(stdout);
   #endif
}


/************************************************************************************/
/* Function:  message_queue_info()                                                  */
/* Behaviour: Outputs status information about each active message queue.           */
/************************************************************************************/
void message_queue_info(void)
{
  BlockOfQueues *current;
  unsigned int largest_msg;
  MessageQueue q;
  int old_state;
  int i = 0;
  unsigned int freespace = 0;
  unsigned int dummy1 = 0;
  unsigned int dummy2 = 0;

    if (head == NULL)
    {
        puts("No queues allocated");
        return;
    }

    current = head;

    puts("Q:        Message queue handle");
    puts("AppId:    Application Identifier");
    puts("Buffsize: Size of fixed length message queue (bytes)");
    puts("Maxsize:  Maximum size allowed for a single message (0 -> no limit)");
    puts("          (word units)                                             ");
    puts("Messages: Number of messages currently in the queue");
    puts("Free:     Free space available (word units)");
    puts("Largest:  Size of largest message in queue (word units)");
    puts("-------------------------------------------------------------------- ");
    puts("Q    AppId     Buffsize  Maxsize   Messages  Free      Largest ");
    puts("---------------------------------------------------------------------");

    old_state = enter_critical();

    do
    {
      if (current->qslots[i].buff != NULL)
      {
          q = current->qslots[i];

          printf("%-5d",i % 32);
          printf("%-10u",q.application_id);
          printf("%-10u",q.queue_size);
          printf("%-10u",q.maxsize_single_msg);
          printf("%-10u",count_msgs(q,&largest_msg));
          freespace_avail(q,&freespace,&dummy1,&dummy2,0);
          printf("%-10u",freespace);
          printf("%-10u\n",largest_msg);
      }

      if (i == 31)
      {
          i = 0;
          current = current->next;
      }
      else
      {
          i++;
      }

    } while (current != NULL);

    putchar('\n');

    restore_critical(old_state);
}


