; > Sources.DynAreas

;;-----------------------------------------------------------------------------
;;
;; Change list
;;
;; 17-Oct-94    0.01    JRH: Created by nicking bits of switcher 0.94
;;                           Added rma and screen size args, why weren't they already?
;;------------------------------------------------------------------------------------

        GET     Version

                GBLL    DynamicAreas    ; Can cope with app-dynamic areas
DynamicAreas    SETL    {TRUE}

Module_BaseAddr

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:CMOS
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:FileTypes
        GET     Hdr:NewErrors
        GET     Hdr:Variables
        GET     Hdr:Messages
        GET     Hdr:Proc
        GET     Hdr:MsgTrans
        GET     Hdr:NDRDebug


;        ^       1


;;----------------------------------------------------------------------------
;; Module header
;;----------------------------------------------------------------------------

        LEADR   Module_LoadAddr

        ASSERT  (.=Module_BaseAddr)

MySWIBase       *       Module_SWISystemBase + SwitcherSWI * Module_SWIChunkSize

        DCD     0	;Start          - Module_BaseAddr
        DCD     0	;Init           - Module_BaseAddr
        DCD     0	;Die            - Module_BaseAddr
        DCD     0
        DCD     Title          - Module_BaseAddr
        DCD     Helpstr        - Module_BaseAddr
        DCD     Helptable      - Module_BaseAddr
        DCD     0
        DCD     0
        DCD     0
        DCD     0
 [ International_Help <> 0
        DCD     str_messagefile - Module_BaseAddr
 |
        DCD     0
 ]

Title   =       "DynamicAreas",0
Helpstr =       "DynamicAreas",9,"$VString ($Date)",0
        =       0
        ALIGN

Helptable
        Command ChangeDynamicArea,255,0,International_Help
        DCB     0

  [	International_Help <> 0
ChangeDynamicArea_Help          DCB     "HTMGCDA",0
ChangeDynamicArea_Syntax        DCB     "STMGCDA",0

  |
ChangeDynamicArea_Help
        DCB     "Allows the size of the font cache, system sprite area and RAM disc to be set up."
        DCB     13
ChangeDynamicArea_Syntax
        DCB     "Syntax: *ChangeDynamicArea [-FontSize <n>[K]] [-SpriteSize <n>[K]] [-RamFsSize <n>[K]] [-RMASize <n>[K]] [-ScreenSize <n>[K]]"
        DCB     0

  ]
        ALIGN

;------------------------------------------------------------------------------
; Command decoding
;------------------------------------------------------------------------------

rmaarea         *       1               ; RMA area
screenarea      *       2               ; screen area
spritearea      *       3               ; sprite area
fontarea        *       4               ; font cache dynamic area number
ramfsarea       *       5               ; RAM disc area

                ^       0
vec_fontsize    #       4               ; fields in output vector
vec_spritesize  #       4
vec_ramfssize   #       4
vec_rmasize	#	4
vec_screensize	#	4
ss_outputvec    *       &100

Keydef  DCB     "FontSize/K,SpriteSize/K,RamFsSize/K,RMASize/K,ScreenSize/K"
        DCB     0
        ALIGN

; NB: R12 -> private word (don't use workspace, as it may not be present)

ChangeDynamicArea_Code  ROUT
        Push    "R11,LR"
        MOV     R11,sp                  ; remember stack for later
;
        SUB     sp,sp,#ss_outputvec     ; local workspace
;
; scan the comand line by calling OS_ReadArgs
;
        MOV     R1,R0                   ; R1 = input string
        ADR     R0,Keydef               ; R0 = key defion string
        MOV     R2,sp                   ; R2 = output vector
        MOV     R3,#ss_outputvec        ; R3 = max output vector length
        SWI     XOS_ReadArgs
;
; scan the resulting vector for known fields
;
        MOVVC   R0,#rmaarea
        LDRVC   R1,[sp,#vec_rmasize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#screenarea
        LDRVC   R1,[sp,#vec_screensize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#fontarea
        LDRVC   R1,[sp,#vec_fontsize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#spritearea
        LDRVC   R1,[sp,#vec_spritesize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#ramfsarea           ; NB: do RAMFS last so others get done if it fails
        LDRVC   R1,[sp,#vec_ramfssize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOV     sp,R11                  ; restore stack
        Pull    "R11,PC"

; In    R0 = dynamic area number
;       R1 -> string specifying size required (<=0 => don't bother)
; Out   calls OS_ChangeDynamicArea, which gives Service_MemoryMoved
;       this is intercepted, and sets [memoryupdated]
;       this causes a pollword event:
;           which calls set_memory for all memory slots
;           if the RAM disc slot size changes to/from 0
;               [ramfsflag] is set
;               unless dragging the ram slot bar:
;                   reramfsfiler re-ialises the RAMFSFiler
;                   otherwise it waits till the bar is dropped

changeR0R1      ROUT
        Push    "R0-R3,LR"

        CMP     R1,#0
        Pull    "R0-R3,PC",LE

        SWI     XOS_ReadDynamicArea     ; R1 = current size of area
        MOVVC   R3,R1

        LDRVC   R1,[sp,#1*4]
        BLVC    getK                    ; R1 = new amount required

        LDRVC   R0,[sp,#0*4]
        SUBVC   R1,R1,R3                ; R1 = change required
        SWIVC   XOS_ChangeDynamicArea

        STRVS   R0,[sp]
        Pull    "R0-R3,PC"


; In    R1 --> string
; Out   R1 = parameter value (number)
; Errors: "Bad number"
;

getK    ROUT
        Push    "R2-R3,LR"
;
        MOV     R0,#10
        SWI     XOS_ReadUnsigned
        Pull    "R2-R3,PC",VS
;
        LDRB    R3,[R1]                 ; if terminator is "K" or "k",
        UpperCase R3, R14
        TEQ     R3,#"K"
        ADDEQ   R1,R1,#1
        MOVEQ   R2,R2,LSL #10           ; multiply by 1024
;
        LDRB    R14,[R1]                ; check terminator
        RSBS    R14,R14,#" "+1          ; ensure GT set if OK
        ADRLE R0,ErrorBlock_BadNumb
        BLLE    lookup_error            ; "Bad number"
;
        MOVVC   R1,R2                   ; R1 = answer
        Pull    "R2-R3,PC"
        MakeInternatErrorBlock BadNumb,,E04


;..............................................................................

; In    R0 -> error block
; Out   R0 -> resolved error block and  V set!

lookup_error
        Push    "R1-R8,LR"
        BL      lookup_erroralt
        Pull    "R1-R8,PC"

; hand crafted routine that does not require any stack to perform an error
; look up - use with caution!!!

; in    R0 -> error block
; out   R0 -> resolve error block

lookup_erroralt ROUT

        MOV     R8,R14
        MOV     R4,R0                   ; preserve original error pointer

        MOV     R0,#ModHandReason_Claim
        MOV     R3,#16
        SWI     XOS_Module              ; attempt to claim workspace block
        MOVVS   PC,R8                   ; exit if failed to get workspace

        MOV     R0,R2
        ADR     R1,str_messagefile
        MOV     R2,#0                   ; no user buffer
        SWI     XMessageTrans_OpenFile

        MOVVC   R1,R0
        MOV     R0,R4                   ; R1 -> blk, R0 -> error
        MOVVC   R2,#0                   ; no user buffer
        ADRVCL  R4,Title
        MOVVC   R5,#0
        MOVVC   R6,#0
        MOVVC   R7,#0                   ; no parameter substitution
        SWIVC   XMessageTrans_ErrorLookup

        MOV     R3,R0                   ; preserve the error block pointer
        MOV     R0,R1
        SWI     XMessageTrans_CloseFile ; attempt to close the file (ignore any errors)

        MOV     R0,#ModHandReason_Free
        MOV     R2,R1
        SWI     XOS_Module              ; release our workspace (ignore any errors)

        MOV     R0,R3
        ORRS    PC,R8,#V_bit            ; return with R0 -> error and oVerflow set

; Use the kernel's message file for this one error
str_messagefile DCB     "Resources:$.resources.DynAreas.Messages", 0
        ALIGN

        END

