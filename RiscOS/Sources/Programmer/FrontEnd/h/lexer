/* Title:    lexer.h
 * Purpose:  lexical analysis of an application description
 * Author:   IDJ
 * History:  05-Apr-90: IDJ: created
 *
 */

#ifndef __lexer_h
#define __lexer_h

#ifndef BOOL
#include "bool.h"
#endif

/* keywords */

#define NKEYWORDS  74
#define  s_any                   0
#define  s_buffer_size           1
#define  s_by                    2
#define  s_command_is            3
#define  s_dbox_end              4
#define  s_dbox_start            5
#define  s_decreases             6
#define  s_defaults              7
#define  s_deselections_end      8 
#define  s_deselections_start    9
#define  s_deselects            10
#define  s_display_dft_is       11
#define  s_drag_to              12
#define  s_excludes             13
#define  s_exclusions_end       14
#define  s_exclusions_start     15
#define  s_extends              16
#define  s_fileoutput_end       17
#define  s_fileoutput_start     18
#define  s_filetype             19
#define  s_followed_by          20
#define  s_from                 21
#define  s_has_auto_run         22
#define  s_has_auto_save        23
#define  s_has_extended_cmdline 24
#define  s_has_summary_window   25
#define  s_has_text_window      26
#define  s_icn                  27
#define  s_iconbar              28
#define  s_icons_end            29
#define  s_icons_start          30
#define  s_imports_end          31
#define  s_imports_start        32
#define  s_increases            33
#define  s_inserts              34
#define  s_k                    35
#define  s_leafname             36
#define  s_make_defaults        37
#define  s_make_excludes        38
#define  s_make_order_is        39
#define  s_maps_to              40
#define  s_max                  41
#define  s_menu                 42
#define  s_menu_end             43
#define  s_menu_start           44
#define  s_metaoptions_end      45
#define  s_metaoptions_start    46
#define  s_min                  47
#define  s_name                 48
#define  s_not_saved            49
#define  s_number               50
#define  s_off                  51
#define  s_on                   52
#define  s_order_is             53
#define  s_output               54
#define  s_output_dft_is        55
#define  s_output_dft_string    56
#define  s_output_option_is     57
#define  s_prefix_by            58
#define  s_produces_no_output   59
#define  s_produces_output      60
#define  s_separator_is         61
#define  s_spaces               62
#define  s_string               63
#define  s_sub_menu             64
#define  s_summary              65
#define  s_text                 66
#define  s_to                   67
#define  s_tool_details_end     68
#define  s_tool_details_start   69
#define  s_toolflags            70
#define  s_version              71
#define  s_wild_card_is         72
#define  s_wimpslot             73

/* lexeme types */
#define  s_string_value       74
#define  s_number_value       75
#define  s_boolean_value      76
#define  s_eof                77
#define  s_semicolon          78
#define  s_bra                79
#define  s_ket                80
#define  s_comma              81
#define  s_dot                82
#define  s_hat                83
#define  s_keywd              84


#define  s_unknown           (-1)


extern char *lexer_tokenstrings[];

extern int line_number;


#define LEXLEN  64
typedef struct 
{
   int number;
   union
   { 
      int   integer;
      BOOL  boolean;
   } value;
#if VARIABLE_LENGTH_TOKENS
   char *lexeme;
   unsigned int lexeme_size;
#else
   char lexeme[LEXLEN];
#endif
} lexer_token;

#if VARIABLE_LENGTH_TOKENS
extern void lexer_next_token(lexer_token *token);
extern void lexer_copy_token(lexer_token *dst, lexer_token *src);
#else
extern lexer_token lexer_next_token(void);
#endif

#endif

 



