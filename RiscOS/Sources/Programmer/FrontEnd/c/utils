/* Title:    utils.c
 * Purpose:  general utility functions
 * Author:   IDJ
 * History:  22-May-90: IDJ: Created
 *           21-Jun-90: IDJ: added wildcarding
 *           27-Jun-90: IDJ: added fieldlength, find_writeable
 *
 */

#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"

#include "wimp.h"
#include "template.h"
#include "dbox.h"
#include "werr.h"
#include "flex.h"
#include "msgs.h"

#include "global.h"
#include "types.h"
#include "FrontEnd.h"
#include "FEmem.h"
#include "FEinterr.h"

#include "utils.h"

#define DIRECTORY   0x1000
#define APPLICATION 0x2000


extern int cistrcmp(const char *s1, const char *s2)
{
  int ch1, ch2;
  for (;;) {
    ch1 = *s1++;  ch2 = *s2++;
    /* care here for portability... don't rely on ANSI spec */
    if (isupper(ch1)) ch1 = tolower(ch1);
    if (isupper(ch2)) ch2 = tolower(ch2);
    if (ch1 != ch2) return ch1-ch2;
    if (ch1 == 0) return 0;
  }
}


extern wimp_icon *icon_num_to_pointer(char *dbox_name, int icon_number)
{
   template *t;
   wimp_wind *w;

   t = template_find(dbox_name);
   w = &t->window;
   return (((wimp_icon *)(w + 1)) + icon_number);
}

extern Frontend_dragto *find_drag(int icn)
{
   Frontend_dragto *d = application.setup->drags;

   while (d != 0)
   {
      if (d->drag == icn) return d;
      else d = d->next;
   }
   return 0;
}

extern Frontend_icon *find_icon(int icn)
{
   Frontend_icon *i = application.setup->icons;

   while (i != 0)
   {
      if (i->number == icn) return i;
      else i = i->next;
   }
   return 0;
}

extern Frontend_menuentry *find_menuentry(int entry)
{
   Frontend_menuentry *e = application.setup->menu.entries;

   while (e != 0)
   {
      if (e->number == entry) return e;
      else e = e->next;
   }
   return 0;
}

extern void add_char(char *s, char c)
{
   int len = strlen(s);

   s[len] = c;
   s[len+1] = '\0';
}

extern void do_exclusions(void *i_m, int icon_or_menu, BOOL exclude)
{
   Frontend_exclusion *ex;
   Frontend_icon *i;
   Frontend_menuentry *m;

   ex = (icon_or_menu == IS_ICON)?((Frontend_icon *)i_m)->exclusions
                                 :((Frontend_menuentry *)i_m)->exclusions;
   while (ex != 0)
   {
       if (ex->menu_or_icon == IS_ICON)
       {
          if (exclude)
          {
             i = find_icon(ex->exclude);
             dbox_fadefield(application.setup->d, ex->exclude);
             if ((i->flags & IF_NUMBER) || !(i->flags & (IF_STRING|IF_ARROWUP|IF_ARROWDOWN)))
                dbox_setnumeric(application.setup->d, ex->exclude, 0);
             else  /* string */
                dbox_setfield(application.setup->d, ex->exclude, "");
             i->flags |= IF_FADED;
             i->flags &= ~IF_SELECTED;
          }
          else
          {
             dbox_unfadefield(application.setup->d, ex->exclude);
             i = find_icon(ex->exclude);
             i->flags &= ~IF_FADED;
          }
       }
       else   /* IS_MENU */
       {
          if (exclude)
          {
             m = find_menuentry(ex->exclude+1);
             m->flags |= IF_FADED;
             m->flags &= ~IF_SELECTED;
          }
          else
          {
             m = find_menuentry(ex->exclude+1);
             m->flags &= ~IF_FADED;
          }
       }
       ex = ex->next;
   }
}


extern void do_make_exclusions(void)
{
   Frontend_icon *i = application.setup->icons;
   Frontend_menuentry *m = application.setup->menu.entries;

   /* --- first the icons --- */
   while (i != 0)
   {
      if (i->flags & IF_MAKE_EXCLUDES) 
      {
         dbox_fadefield(application.setup->d, i->number);
         i->flags |= IF_FADED;
      }
      i = i->next;
   }

   /* --- then the menu entries --- */
   while (m != 0)
   {
      if (m->flags & IF_MAKE_EXCLUDES) m->flags |= IF_FADED;
      m = m->next;
   }
}


extern void do_deselections(void *i_m, int icon_or_menu)
{
   Frontend_deselection *de;
   Frontend_icon *i;
   Frontend_menuentry *m;

   de = (icon_or_menu == IS_ICON)?((Frontend_icon *)i_m)->deselections
                                 :((Frontend_menuentry *)i_m)->deselections;
 
   while (de != 0)
   {
       if (de->menu_or_icon == IS_ICON)
       {
          i = find_icon(de->deselect);
          if ((i->flags & IF_NUMBER) || !(i->flags & (IF_STRING|IF_ARROWUP|IF_ARROWDOWN)))
              dbox_setnumeric(application.setup->d, de->deselect, 0);
          else  /* string */
              dbox_setfield(application.setup->d, de->deselect, "");
          i->flags &= ~IF_SELECTED;

          
          /* --- and "unexclude" anything excluded by this icon --- */
          do_exclusions((void *)i, IS_ICON, FALSE);
       }
       else
       {
          m = find_menuentry(de->deselect+1);
          m->flags &= ~IF_SELECTED;

          /* --- and "unexclude" anything excluded by this entry --- */
          do_exclusions((void *)m, IS_MENU, FALSE);
       }
       de = de->next;
   }
}

extern void do_inserts(int icn, char *filename, int type, BOOL setcaret)
{
   Frontend_dragto *d;
   char save_filename[MAXFILENAME];

   strcpy(save_filename, filename);

   /* --- for directories we add wild card string --- */
   if ((type == DIRECTORY || type == APPLICATION) && application.setup->wild_card != 0)
   {
      add_char(save_filename, '.');
      strcat(save_filename, application.setup->wild_card);
   }

   d = find_drag(icn);
   if (d == 0) d = find_drag(ANY_ICON);

   if (d != 0)
   {
      Frontend_insert *ins;
      wimp_icon ii;

      /* --- insert filename into "insert list" icons, separated --- */
      ins = d->inserts;
      while (ins != 0)
      {
         char *buffer;

         wimp_get_icon_info(dbox_syshandle(application.setup->d), ins->insert, &ii);
         buffer = FEmem_alloc(ii.data.indirecttext.bufflen);

         buffer[0] = 0;
         dbox_getfield(application.setup->d, ins->insert, buffer, ii.data.indirecttext.bufflen);
      
         /* --- check for buffer overflow --- */

         if (strlen(buffer) + strlen(save_filename) >= ii.data.indirecttext.bufflen)
         {
            werr(FALSE, msgs_lookup("utils1:Field is too long"));
         }
         else
         {
            if (buffer[0] >= 32) 
            {
               if (d->separator != '\0')
               {
                   add_char(buffer, d->separator);
                   strcat(buffer, save_filename);
               }
               else
                   strcpy(buffer, save_filename);
            }
            else
               strcpy(buffer, save_filename);
            dbox_setfield(application.setup->d, ins->insert, buffer);

            /* --- put caret at end of writeable icon --- */
            if (setcaret)
                set_caret(dbox_syshandle(application.setup->d), ins->insert); 
         }

         FEmem_free(buffer);

         ins = ins->next;
      }
   }
}

extern BOOL delete_object(char *object)
{
   _kernel_swi_regs r;

   if (object == 0) return TRUE;  /* play it safe !! */

   r.r[0] = 27;             /* wipe object */
   r.r[1] = (int)object;  /* temp. filename */
   r.r[3] = 0x02 | 0x01;    /* force/recurse (in case directory) */
   r.r[4] = r.r[5] = r.r[6] = r.r[7] = 0;

   return (_kernel_swi(OS_FSControl, &r, &r) == 0); 
}


extern BOOL rename_object(char *from, char *to)
{
   _kernel_swi_regs r;

   r.r[0] = 25;             /* rename */
   r.r[1] = (int)from;
   r.r[2] = (int)to; 

   return (_kernel_swi(OS_FSControl, &r, &r) == 0); 
}


extern BOOL copy_object_with_delete(char *from, char *to)
{
   _kernel_swi_regs r;
   _kernel_oserror *e;

   /* NB we don't use delete-source bit on copy, in case copy of directory fails! */

   r.r[0] = 26;             /* copy object */
   r.r[1] = (int)from;   
   r.r[2] = (int)to;    
   r.r[3] = 0x40 | 0x02 | 0x01;  /* prompt-for-media-change/force/recurse(in case directory!) */

   e = _kernel_swi(OS_FSControl, &r, &r);

   /* now do the delete (testing if the copy worked!) */
   if (e == 0)
       return delete_object(from);
   else
   {
       werr(FALSE, msgs_lookup("utils2:Save failed %s -> %s"), from, to);
       werr(FALSE, "%s", e->errmess);
       return FALSE;
   }
}


extern BOOL find_writeable(char *name, wimp_w wh, wimp_i *i)
{
   wimp_icon *wi;
   template *t;
   wimp_wind *w;

   t = template_find(name);
   w = &t->window;

   for (*i=0; *i<w->nicons; (*i)++)
   {
      wi = ((wimp_icon *)(w + 1)) + *i;
      if (is_writeable_indirecttext(wi))
      {
          wimp_icon is;
          
          wimp_get_icon_info(wh, *i, &is);
          if (!(is.flags & wimp_INOSELECT))
             return TRUE;
      }
   }
   return FALSE;      
}


extern int fieldlength(wimp_w w, wimp_i i)
{
   wimp_icon wi;
   int len = 0;

   wimpt_noerr(wimp_get_icon_info(w, i, &wi));
   while (wi.data.indirecttext.buffer[len] >=32) len++;

   return len;
}


extern void set_caret(wimp_w w, wimp_i i)
{
   wimp_caretstr c;
   c.i = i;
   c.x = 0;
   c.y = 0;
   c.height = -1;
   c.w = w;
   c.index = fieldlength(w, i);
   wimpt_noerr(wimp_set_caret_pos(&c));
}


extern void stralloc(char **dst, char *src)
{
   if ((*dst = FEmem_alloc(strlen(src)+1)) != 0)
        strcpy(*dst, src);
}
