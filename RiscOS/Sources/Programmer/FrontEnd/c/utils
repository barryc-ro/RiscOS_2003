/* Title:    utils.c
 * Purpose:  general utility functions
 * Author:   IDJ
 * History:  22-May-90: IDJ: Created
 *           21-Jun-90: IDJ: added wildcarding
 *           27-Jun-90: IDJ: added fieldlength, find_writeable
 *           18-May-01: ADH: on/off select/deselect/include/exclude support
 *
 */

#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"

#include "wimp.h"
#include "template.h"
#include "dbox.h"
#include "werr.h"
#include "flex.h"
#include "msgs.h"

#include "global.h"
#include "types.h"
#include "FrontEnd.h"
#include "FEmem.h"
#include "FEinterr.h"

#include "utils.h"

#define DIRECTORY   0x1000
#define APPLICATION 0x2000

/* Define the below to output a debug file to the named location */

#undef  LOCAL_TRACING
#define TRACE_LOCATION "Mem::Sprites.$.FEDebug"

extern int cistrcmp(const char *s1, const char *s2)
{
  int ch1, ch2;
  for (;;) {
    ch1 = *s1++;  ch2 = *s2++;
    /* care here for portability... don't rely on ANSI spec */
    if (isupper(ch1)) ch1 = tolower(ch1);
    if (isupper(ch2)) ch2 = tolower(ch2);
    if (ch1 != ch2) return ch1-ch2;
    if (ch1 == 0) return 0;
  }
}


extern wimp_icon *icon_num_to_pointer(char *dbox_name, int icon_number)
{
   template *t;
   wimp_wind *w;

   t = template_find(dbox_name);
   w = &t->window;
   return (((wimp_icon *)(w + 1)) + icon_number);
}

extern Frontend_dragto *find_drag(int icn)
{
   Frontend_dragto *d = application.setup->drags;

   while (d != 0)
   {
      if (d->drag == icn) return d;
      else d = d->next;
   }
   return 0;
}

extern Frontend_icon *find_icon(int icn)
{
   Frontend_icon *i = application.setup->icons;

   while (i != 0)
   {
      if (i->number == icn) return i;
      else i = i->next;
   }
   return 0;
}

extern Frontend_menuentry *find_menuentry(int entry)
{
   Frontend_menuentry *e = application.setup->menu.entries;

   while (e != 0)
   {
      if (e->number == entry) return e;
      else e = e->next;
   }
   return 0;
}

extern void add_char(char *s, char c)
{
   int len = strlen(s);

   s[len] = c;
   s[len+1] = '\0';
}

static void do__setnumeric(Frontend_icon *i, dbox d, dbox_field f, int val)
{
   if ((i->flags & IF_NUMBER) != 0)
   {
     int current = dbox_getnumeric(d, f);
     if (current != val) dbox_setnumeric(d, f, val);
   }
   else
   {
     if ((((i->flags & IF_SELECTED) != 0) && val == 0) || (((i->flags & IF_SELECTED) == 0) && val != 0))
         dbox_setnumeric(d, f, !!val);
   }

   return;
}

static void do__setfield(dbox d, dbox_field f, char *p)
{
   if (*p == '\0')
   {
      char current[4]; /* Just some small value - we're interested only if the string is NUL */

      dbox_getfield(d, f, current, sizeof(current));
      if (*current == '\0') return;
   }

   dbox_setfield(d, f, p);
   return;
}

/* --- note that this assumes it is called for icons only in the SetUp window */
static void do__fadefield(Frontend_icon *i, dbox d, dbox_field f)
{
   if ((i->flags & IF_FADED) == 0)
   {
      wimp_caretstr cs;

      /* --- is caret in this icon? --- */
      if (wimp_get_caret_pos(&cs) == NULL)
      {
         if (cs.i == (wimp_i) f)
         {
            /* --- yes; since we don't know what other items bay be faded, just hide the caret --- */

            cs.i = -1;
            cs.x = 0;
            cs.y = 0;
            cs.index = -1;

            wimp_set_caret_pos(&cs);
         }
      }
      dbox_fadefield(d, f);
   }

   return;
}

static void do__unfadefield(Frontend_icon *i, dbox d, dbox_field f)
{
   if ((i->flags & IF_FADED) != 0) dbox_unfadefield(d, f);
   return;
}


/* This recursively runs rules putting the results into one of four arrays for icons
 * and four arrays for menu entries. Whenever a set of rules is run, it overrides any
 * previous settings. Whenever a selection rule is run, the routine calls itself
 * recursively to run the 'on' rules for each item named in the selection rule, in
 * turn; whenever a deselection rule is run, the item calls itself recursively to
 * run the 'off' rules.
 *
 * Rule evaluation order is, for the case where we're called for the 'on' rules at
 * the top level:
 *
 * 1) Unwind exclusions previously run for the item.
 * 2) Unwind inclusions previously run for the item.
 * 3) Run selection rules, with recursive call back.
 * 4) Run deselection rules, with recursive call back.
 * 5) Run exclusions for the item.
 * 6) Run inclusions for the item.
 *
 * The "_off" variants are (clearly) run if parameter 'off' is TRUE.
 *
 * If TRUE is returned, the function has suspected infinite recursion in the
 * rule patterns and is bailing out. Callers should not try to call again for
 * part of that same rule set.
 */

#ifdef LOCAL_TRACING
   #include <stdio.h>
#endif

static BOOL do__resolve_actions_in_array(void * i_m, int icon_or_menu, BOOL off,
                                         BOOL inner, void * outer_i_m, BOOL outer_off,
                                         int ihigh, int mhigh,
                                         Frontend_icon ** isel,
                                         Frontend_icon ** idesel,
                                         Frontend_icon ** iexcl,
                                         Frontend_icon ** iincl,
                                         Frontend_menuentry ** msel,
                                         Frontend_menuentry ** mdesel,
                                         Frontend_menuentry ** mexcl,
                                         Frontend_menuentry ** mincl)
{
   Frontend_deselection * desel;
   Frontend_selection   * sel;
   Frontend_exclusion   * excl;
   Frontend_inclusion   * incl;

   Frontend_icon        * icurrent;
   Frontend_menuentry   * mcurrent;

   int                    i, m;

   #ifdef LOCAL_TRACING
      {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
      fprintf(fi, "Resolve actions: Called with &%08X for %s %d\n", (int) i_m, icon_or_menu == IS_ICON ? "icon" : "menuentry", icon_or_menu == IS_ICON ? ((Frontend_icon *)i_m)->number : ((Frontend_menuentry *)i_m)->number);
      fprintf(fi, "Resolve actions: Running %s rules\n", off ? "OFF" : "ON");
      fclose(fi);}}
   #endif

   if (inner && outer_i_m == i_m && outer_off == off)
   {
     #ifdef LOCAL_TRACING
        {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
        fprintf(fi, "Resolve actions: INFINITE RECURSION SUSPECTED\n");
        fclose(fi);}}
     #endif

     werr(0, msgs_lookup("FERuleRec:Cannot complete Desc file rule execution; infinite recursion would result."));
     return TRUE;
   }

   /* Unwind this item's exclusion/inclusion rules. If the item is being
    * switched on, it must presently be switched off, in which case we
    * need to unwind its _off rules - and vice versa.
    */

   /* Unwind exclusions */

   if (icon_or_menu == IS_ICON)
      excl = !off ? ((Frontend_icon *)i_m)->exclusions_off : ((Frontend_icon *)i_m)->exclusions;
   else
      excl = !off ? ((Frontend_menuentry *)i_m)->exclusions_off : ((Frontend_menuentry *)i_m)->exclusions;

   #ifdef LOCAL_TRACING
      {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
      if (excl) fprintf(fi, "Exclude rules to unwind are at &%08X\n", (int) excl);
      else fprintf(fi, "No exclusion rules to unwind\n");
      fclose(fi);}}
   #endif

   while (excl != NULL)
   {
      if (excl->menu_or_icon == IS_ICON)
      {
         icurrent = find_icon(excl->exclude);
         if (icurrent == NULL || icurrent->number > ihigh) break;

         /* Unwind this exclude rule - i.e. add to the include list */

         #ifdef LOCAL_TRACING
            {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
            fprintf(fi, "Unwind exclude rule for icon %d\n", icurrent->number);
            fclose(fi);}}
         #endif

         iexcl[icurrent->number] = NULL;
         iincl[icurrent->number] = icurrent;
      }
      else
      {
         mcurrent = find_menuentry(excl->exclude + 1);
         if (mcurrent == NULL || mcurrent->number > mhigh) break;

         #ifdef LOCAL_TRACING
            {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
            fprintf(fi, "Unwind exclude rule for menu entry %d\n", mcurrent->number);
            fclose(fi);}}
         #endif

         mexcl[mcurrent->number] = NULL;
         mincl[mcurrent->number] = mcurrent;
      }

      excl = excl->next;
   }

   /* Unwind inclusions */

   if (icon_or_menu == IS_ICON)
      incl = !off ? ((Frontend_icon *)i_m)->inclusions_off : ((Frontend_icon *)i_m)->inclusions;
   else
      incl = !off ? ((Frontend_menuentry *)i_m)->inclusions_off : ((Frontend_menuentry *)i_m)->inclusions;

   #ifdef LOCAL_TRACING
      {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
      if (incl) fprintf(fi, "Include rules to unwind are at &%08X\n", (int) incl);
      else fprintf(fi, "No inclusion rules to unwind\n");
      fclose(fi);}}
   #endif

   while (incl != NULL)
   {
      if (incl->menu_or_icon == IS_ICON)
      {
         icurrent = find_icon(incl->include);
         if (icurrent == NULL || icurrent->number > ihigh) break;

         /* Unwind this include rule - i.e. add to the exclude list */

         #ifdef LOCAL_TRACING
            {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
            fprintf(fi, "Unwind include rule for icon %d\n", icurrent->number);
            fclose(fi);}}
         #endif

         iexcl[icurrent->number] = icurrent;
         iincl[icurrent->number] = NULL;
      }
      else
      {
         mcurrent = find_menuentry(incl->include + 1);
         if (mcurrent == NULL || mcurrent->number > mhigh) break;

         #ifdef LOCAL_TRACING
            {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
            fprintf(fi, "Unwind include rule for menu entry %d\n", mcurrent->number);
            fclose(fi);}}
         #endif

         mexcl[mcurrent->number] = mcurrent;
         mincl[mcurrent->number] = NULL;
      }

      incl = incl->next;
   }

   /* Run the selection rules */

   if (icon_or_menu == IS_ICON)
      sel = off ? ((Frontend_icon *)i_m)->selections_off : ((Frontend_icon *)i_m)->selections;
   else
      sel = off ? ((Frontend_menuentry *)i_m)->selections_off : ((Frontend_menuentry *)i_m)->selections;

   #ifdef LOCAL_TRACING
      {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
      if (sel) fprintf(fi, "Selection rules to run are at &%08X\n", (int) sel);
      else fprintf(fi, "No selection rules to run\n");
      fclose(fi);}}
   #endif

   while (sel != NULL)
   {
      if (sel->menu_or_icon == IS_ICON)
      {
         icurrent = find_icon(sel->select);
         if (icurrent == NULL || icurrent->number > ihigh) break;

         isel  [icurrent->number] = icurrent;
         idesel[icurrent->number] = NULL;

         #ifdef LOCAL_TRACING
            {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
            fprintf(fi, "Run selection rule for icon %d, go recursive\n", icurrent->number);
            fclose(fi);}}
         #endif

         if (do__resolve_actions_in_array((void *)icurrent, IS_ICON, FALSE,
                                          TRUE, outer_i_m, outer_off,
                                          ihigh, mhigh,
                                          isel, idesel, iexcl, iincl,
                                          msel, mdesel, mexcl, mincl))
         {
            return TRUE;
         }
      }
      else
      {
         mcurrent = find_menuentry(sel->select + 1);
         if (mcurrent == NULL || mcurrent->number > mhigh) break;

         msel  [mcurrent->number] = mcurrent;
         mdesel[mcurrent->number] = NULL;

         #ifdef LOCAL_TRACING
            {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
            fprintf(fi, "Run selection rule for menu entry %d, go recursive\n", mcurrent->number);
            fclose(fi);}}
         #endif

         if (do__resolve_actions_in_array((void *)mcurrent, IS_MENU, FALSE,
                                          TRUE, outer_i_m, outer_off,
                                          ihigh, mhigh,
                                          isel, idesel, iexcl, iincl,
                                          msel, mdesel, mexcl, mincl))
         {
            return TRUE;
         }
      }

      sel = sel->next;
   }

   /* Run the deselection rules */

   if (icon_or_menu == IS_ICON)
      desel = off ? ((Frontend_icon *)i_m)->deselections_off : ((Frontend_icon *)i_m)->deselections;
   else
      desel = off ? ((Frontend_menuentry *)i_m)->deselections_off : ((Frontend_menuentry *)i_m)->deselections;

   #ifdef LOCAL_TRACING
      {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
      if (desel) fprintf(fi, "Deselection rules to run are at &%08X\n", (int) desel);
      else fprintf(fi, "No deselection rules to run\n");
      fclose(fi);}}
   #endif

   while (desel != NULL)
   {
      if (desel->menu_or_icon == IS_ICON)
      {
         icurrent = find_icon(desel->deselect);
         if (icurrent == NULL || icurrent->number > ihigh) break;

         isel  [icurrent->number] = NULL;
         idesel[icurrent->number] = icurrent;

         #ifdef LOCAL_TRACING
            {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
            fprintf(fi, "Run deselection rule for icon %d, go recursive\n", icurrent->number);
            fclose(fi);}}
         #endif

         if (do__resolve_actions_in_array((void *)icurrent, IS_ICON, TRUE,
                                          TRUE, outer_i_m, outer_off,
                                          ihigh, mhigh,
                                          isel, idesel, iexcl, iincl,
                                          msel, mdesel, mexcl, mincl))
         {
            return TRUE;
         }
      }
      else
      {
         mcurrent = find_menuentry(desel->deselect + 1);
         if (mcurrent == NULL || mcurrent->number > mhigh) break;

         msel  [mcurrent->number] = NULL;
         mdesel[mcurrent->number] = mcurrent;

         #ifdef LOCAL_TRACING
            {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
            fprintf(fi, "Run deselection rule for menu entry %d, go recursive\n", mcurrent->number);
            fclose(fi);}}
         #endif

         if (do__resolve_actions_in_array((void *)mcurrent, IS_MENU, TRUE,
                                          TRUE, outer_i_m, outer_off,
                                          ihigh, mhigh,
                                          isel, idesel, iexcl, iincl,
                                          msel, mdesel, mexcl, mincl))
         {
            return TRUE;
         }
      }

      desel = desel->next;
   }

   /* Run the exclusion rules */

   if (icon_or_menu == IS_ICON)
      excl = off ? ((Frontend_icon *)i_m)->exclusions_off : ((Frontend_icon *)i_m)->exclusions;
   else
      excl = off ? ((Frontend_menuentry *)i_m)->exclusions_off : ((Frontend_menuentry *)i_m)->exclusions;

   #ifdef LOCAL_TRACING
      {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
      if (excl) fprintf(fi, "Exclusion rules to run are at &%08X\n", (int) excl);
      else fprintf(fi, "No exclusion rules to run\n");
      fclose(fi);}}
   #endif

   while (excl != NULL)
   {
      if (excl->menu_or_icon == IS_ICON)
      {
         icurrent = find_icon(excl->exclude);
         if (icurrent == NULL || icurrent->number > ihigh) break;

         #ifdef LOCAL_TRACING
            {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
            fprintf(fi, "Run exclude rule for icon %d\n", icurrent->number);
            fclose(fi);}}
         #endif

         iexcl[icurrent->number] = icurrent;
         iincl[icurrent->number] = NULL;
      }
      else
      {
         mcurrent = find_menuentry(excl->exclude + 1);
         if (mcurrent == NULL || mcurrent->number > mhigh) break;

         #ifdef LOCAL_TRACING
            {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
            fprintf(fi, "Run exclude rule for menu entry %d\n", mcurrent->number);
            fclose(fi);}}
         #endif

         mexcl[mcurrent->number] = mcurrent;
         mincl[mcurrent->number] = NULL;
      }

      excl = excl->next;
   }

   /* Run the inclusion rules */

   if (icon_or_menu == IS_ICON)
      incl = off ? ((Frontend_icon *)i_m)->inclusions_off : ((Frontend_icon *)i_m)->inclusions;
   else
      incl = off ? ((Frontend_menuentry *)i_m)->inclusions_off : ((Frontend_menuentry *)i_m)->inclusions;

   #ifdef LOCAL_TRACING
      {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
      if (incl) fprintf(fi, "Inclusion rules to run are at &%08X\n", (int) incl);
      else fprintf(fi, "No inclusion rules to run\n");
      fclose(fi);}}
   #endif

   while (incl != NULL)
   {
      if (incl->menu_or_icon == IS_ICON)
      {
         icurrent = find_icon(incl->include);
         if (icurrent == NULL || icurrent->number > ihigh) break;

         #ifdef LOCAL_TRACING
            {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
            fprintf(fi, "Run include rule for icon %d\n", icurrent->number);
            fclose(fi);}}
         #endif

         iexcl[icurrent->number] = NULL;
         iincl[icurrent->number] = icurrent;
      }
      else
      {
         mcurrent = find_menuentry(incl->include + 1);
         if (mcurrent == NULL || mcurrent->number > mhigh) break;

         #ifdef LOCAL_TRACING
            {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
            fprintf(fi, "Run include rule for menu entry %d\n", mcurrent->number);
            fclose(fi);}}
         #endif

         mexcl[mcurrent->number] = NULL;
         mincl[mcurrent->number] = mcurrent;
      }

      incl = incl->next;
   }

   /* If we're ungreying (including) any icon, it could be part of
    * a larger group that was greyed out. For example, a selection
    * made in a group of radio buttons might lead to a large chunk
    * of icons in a window being greyed out. When the selection in
    * the radio group was changed, these are ungreyed. However, the
    * group of icons might have its own local include/exclude rules,
    * and we'd be destroying that. So, for each icon about to be
    * included, according to the array, we must run the relevant
    * rule to ensure anything that should still be greyed out, is.
    *
    * Thus the logic follows - if the item about to be included has
    * state and this state is 'on', unwind its 'include off' rules
    * and run its 'exclude on' rules. Conversely if the icon state
    * is 'off', unwind its 'include on' rules and run its 'exclude
    * off' rules.
    */

   for (i = 0; i <= ihigh; i++)
   {
      /* Going to include this icon? */

      if ((icurrent = iincl[i]) != NULL)
      {
         if ((icurrent->flags & IF_SELECTED) != 0)
         {
            incl = icurrent->inclusions_off;
            excl = icurrent->exclusions;
         }
         else
         {
            incl = icurrent->inclusions;
            excl = icurrent->exclusions_off;
         }

         /* Unwind include on/off */

         while (incl != NULL)
         {
            if (incl->menu_or_icon == IS_ICON)
            {
               icurrent = find_icon(incl->include);
               if (icurrent == NULL || icurrent->number > ihigh) break;

               /* Unwind this include rule - i.e. add to the exclude list */

               iexcl[icurrent->number] = icurrent;
               iincl[icurrent->number] = NULL;
            }
            else
            {
               mcurrent = find_menuentry(incl->include + 1);
               if (mcurrent == NULL || mcurrent->number > mhigh) break;

               mexcl[mcurrent->number] = mcurrent;
               mincl[mcurrent->number] = NULL;
            }

            incl = incl->next;
         }

         /* Run exclude on/off */

         while (excl != NULL)
         {
            if (excl->menu_or_icon == IS_ICON)
            {
               icurrent = find_icon(excl->exclude);
               if (icurrent == NULL || icurrent->number > ihigh) break;

               iexcl[icurrent->number] = icurrent;
               iincl[icurrent->number] = NULL;
            }
            else
            {
               mcurrent = find_menuentry(excl->exclude + 1);
               if (mcurrent == NULL || mcurrent->number > mhigh) break;

               mexcl[mcurrent->number] = mcurrent;
               mincl[mcurrent->number] = NULL;
            }

            excl = excl->next;
         }
      }
   }

   /* Same again, this time for menus */

   for (m = 0; m <= mhigh; m++)
   {
      /* Going to include this menu? */

      if ((mcurrent = mincl[m]) != NULL)
      {
         if ((mcurrent->flags & IF_SELECTED) != 0)
         {
            incl = mcurrent->inclusions_off;
            excl = mcurrent->exclusions;
         }
         else
         {
            incl = mcurrent->inclusions;
            excl = mcurrent->exclusions_off;
         }

         /* Unwind include on/off */

         while (incl != NULL)
         {
            if (incl->menu_or_icon == IS_ICON)
            {
               icurrent = find_icon(incl->include);
               if (icurrent == NULL || icurrent->number > ihigh) break;

               /* Unwind this include rule - i.e. add to the exclude list */

               iexcl[icurrent->number] = icurrent;
               iincl[icurrent->number] = NULL;
            }
            else
            {
               mcurrent = find_menuentry(incl->include + 1);
               if (mcurrent == NULL || mcurrent->number > mhigh) break;

               mexcl[mcurrent->number] = mcurrent;
               mincl[mcurrent->number] = NULL;
            }

            incl = incl->next;
         }

         /* Run exclude on/off */

         while (excl != NULL)
         {
            if (excl->menu_or_icon == IS_ICON)
            {
               icurrent = find_icon(excl->exclude);
               if (icurrent == NULL || icurrent->number > ihigh) break;

               iexcl[icurrent->number] = icurrent;
               iincl[icurrent->number] = NULL;
            }
            else
            {
               mcurrent = find_menuentry(excl->exclude + 1);
               if (mcurrent == NULL || mcurrent->number > mhigh) break;

               mexcl[mcurrent->number] = mcurrent;
               mincl[mcurrent->number] = NULL;
            }

            excl = excl->next;
         }
      }
   }

   /* Finished updating the array; return either back to further
    * rules processing, or to the external caller that will now
    * use the array contents to update the front-end.
    */

   #ifdef LOCAL_TRACING
      {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
      fprintf(fi, "Resolve actions: Exit\n");
      fclose(fi);}}
   #endif

   return FALSE;
}

static void do__actions(void * i_m, int icon_or_menu, BOOL off)
{
   /* This gets quite volved, though overall, it's straightforward */

   unsigned int          amount;
   int                   ihigh, mhigh;
   int                   ictr,  mctr;

   Frontend_icon       * icurrent;
   Frontend_icon      ** isel;
   Frontend_icon      ** idesel;
   Frontend_icon      ** iexcl;
   Frontend_icon      ** iincl;

   Frontend_menuentry  * mcurrent;
   Frontend_menuentry ** msel   = NULL;
   Frontend_menuentry ** mdesel = NULL;
   Frontend_menuentry ** mexcl  = NULL;
   Frontend_menuentry ** mincl  = NULL;

   /* Find out the highest icon number */

   icurrent = application.setup->icons;
   ihigh    = -1;

   if (icurrent == NULL) return;

   while (icurrent != NULL)
   {
      if (icurrent->number > ihigh) ihigh = icurrent->number;
      icurrent = icurrent->next;
   }

   /* Allocate arrays for includes and excludes; there may be more
    * entries than needed but it's fastest to reference the array
    * contents by icon number.
    */

   amount = (ihigh + 1) * sizeof(Frontend_icon *);

   isel   = FEmem_alloc(amount); /* (this guarantees it will return a valid pointer or will bail out itself) */
   idesel = FEmem_alloc(amount);
   iexcl  = FEmem_alloc(amount);
   iincl  = FEmem_alloc(amount);

   memset(isel,   0, amount);
   memset(idesel, 0, amount);
   memset(iincl,  0, amount);
   memset(iexcl,  0, amount);

   /* Similar thing for menu entries */

   mcurrent = application.setup->menu.entries;
   mhigh    = -1;

   if (mcurrent != NULL)
   {
      while (mcurrent != NULL)
      {
         if (mcurrent->number > mhigh) mhigh = mcurrent->number;
         mcurrent = mcurrent->next;
      }

      amount = (mhigh + 1) * sizeof(Frontend_menuentry *);

      msel   = FEmem_alloc(amount);
      mdesel = FEmem_alloc(amount);
      mexcl  = FEmem_alloc(amount);
      mincl  = FEmem_alloc(amount);

      memset(msel,   0, amount);
      memset(mdesel, 0, amount);
      memset(mincl,  0, amount);
      memset(mexcl,  0, amount);
   }

   /* Run the rules */

   _swix(Hourglass_On, 0);

   #ifdef LOCAL_TRACING
      {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
      fprintf(fi, "** Outer call for resolve, %s %d\n", icon_or_menu == IS_ICON ? "icon" : "menuentry", icon_or_menu == IS_ICON ? ((Frontend_icon *)i_m)->number : ((Frontend_menuentry *)i_m)->number);
      fprintf(fi, "** Highest icon number: %d\n", ihigh);
      fprintf(fi, "** Highest menu entry : %d\n", mhigh);
      fclose(fi);}}
   #endif

   do__resolve_actions_in_array(i_m, icon_or_menu, off,
                                FALSE, i_m, off,
                                ihigh, mhigh,
                                isel, idesel, iexcl, iincl,
                                msel, mdesel, mexcl, mincl);

   #ifdef LOCAL_TRACING
      {FILE * fi = fopen(TRACE_LOCATION, "a"); if (fi != NULL){
      fprintf(fi, "** Outer call returned\n");
      fclose(fi);}}
   #endif

   _swix(Hourglass_Off, 0);

   /* The eight arrays now contain entries that are either NULL, or point
    * to a relevant icon or menu entry structure describing something that
    * should be selected, deselected, excluded or included. There are no
    * items that contradict each other (e.g. both in the exclusions and
    * inclusions arrays) and no items that reflect an icon or menu entry
    * already in the relevant state (e.g. an icon in the selection array
    * that is already selected).
    *
    * So...
    *
    * Deselect everything in the deselection arrays;
    * select everything in the selection arrays;
    * exclude everything in the exclusion arrays;
    * include everything in the inclusion arrays.
    */

   ictr = 0;

   while (ictr <= ihigh)
   {
      icurrent = idesel[ictr];

      if (icurrent != NULL)
      {
          if ((icurrent->flags & IF_NUMBER) || !(icurrent->flags & (IF_STRING|IF_ARROWUP|IF_ARROWDOWN)))
              do__setnumeric(icurrent, application.setup->d, icurrent->number, 0);
          else if ((icurrent->flags & IF_STRING) != 0) /* string */
              do__setfield(application.setup->d, icurrent->number, "");

          icurrent->flags &= ~IF_SELECTED;
      }

      icurrent = isel[ictr];

      if (icurrent != NULL)
      {
          if (!(icurrent->flags & (IF_STRING|IF_ARROWUP|IF_ARROWDOWN|IF_NUMBER)))
              do__setnumeric(icurrent, application.setup->d, icurrent->number, 1);

          icurrent->flags |= IF_SELECTED;
      }

      icurrent = iexcl[ictr];

      if (icurrent != NULL)
      {
          do__fadefield(icurrent, application.setup->d, icurrent->number);
          icurrent->flags |= IF_FADED;
      }

      icurrent = iincl[ictr];

      if (icurrent != NULL)
      {
          do__unfadefield(icurrent, application.setup->d, icurrent->number);
          icurrent->flags &= ~IF_FADED;
      }

      ictr++;
   }

   /* (Don't forget menus!) */

   mctr = 0;

   while (mctr <= mhigh)
   {
      mcurrent = mdesel[mctr];
      if (mcurrent != NULL) mcurrent->flags &= ~IF_SELECTED;

      mcurrent = msel[mctr];
      if (mcurrent != NULL) mcurrent->flags |= IF_SELECTED;

      mcurrent = mexcl[mctr];
      if (mcurrent != NULL) mcurrent->flags |= IF_FADED;

      mcurrent = mincl[mctr];
      if (mcurrent != NULL) mcurrent->flags &= ~IF_FADED;

      mctr++;
   }

   /* Release memory claimed for the temporary arrays */

   FEmem_free(isel);
   FEmem_free(idesel);
   FEmem_free(iexcl);
   FEmem_free(iincl);

   if (application.setup->menu.entries != NULL)
   {
      FEmem_free(msel);
      FEmem_free(mdesel);
      FEmem_free(mexcl);
      FEmem_free(mincl);
   }

   /* Done. Hurrah. */

   return;
}

extern void do_on_actions(void *i_m, int icon_or_menu)
{
   do__actions(i_m, icon_or_menu, FALSE);
}

extern void do_off_actions(void *i_m, int icon_or_menu)
{
   do__actions(i_m, icon_or_menu, TRUE);
}


extern void do_make_exclusions(void)
{
   Frontend_icon *i = application.setup->icons;
   Frontend_menuentry *m = application.setup->menu.entries;

   /* --- first the icons --- */
   while (i != 0)
   {
      if (i->flags & IF_MAKE_EXCLUDES)
      {
         do__fadefield(i, application.setup->d, i->number);
         i->flags |= IF_FADED;
      }
      i = i->next;
   }

   /* --- then the menu entries --- */
   while (m != 0)
   {
      if (m->flags & IF_MAKE_EXCLUDES) m->flags |= IF_FADED;
      m = m->next;
   }
}

extern void do_inserts(int icn, char *filename, int type, BOOL setcaret)
{
   Frontend_dragto *d;
   char save_filename[MAXFILENAME];

   strcpy(save_filename, filename);

   /* --- for directories we add wild card string --- */
   if ((type == DIRECTORY || type == APPLICATION) && application.setup->wild_card != 0)
   {
      add_char(save_filename, '.');
      strcat(save_filename, application.setup->wild_card);
   }

   d = find_drag(icn);
   if (d == 0) d = find_drag(ANY_ICON);

   if (d != 0)
   {
      Frontend_insert *ins;
      wimp_icon ii;

      /* --- insert filename into "insert list" icons, separated --- */
      ins = d->inserts;
      while (ins != 0)
      {
         char *buffer;

         wimp_get_icon_info(dbox_syshandle(application.setup->d), ins->insert, &ii);
         buffer = FEmem_alloc(ii.data.indirecttext.bufflen);

         buffer[0] = 0;
         dbox_getfield(application.setup->d, ins->insert, buffer, ii.data.indirecttext.bufflen);

         /* --- check for buffer overflow --- */

         if (strlen(buffer) + strlen(save_filename) >= ii.data.indirecttext.bufflen)
         {
            werr(FALSE, msgs_lookup("utils1:Field is too long"));
         }
         else
         {
            if (buffer[0] >= 32)
            {
               if (d->separator != '\0')
               {
                   add_char(buffer, d->separator);
                   strcat(buffer, save_filename);
               }
               else
                   strcpy(buffer, save_filename);
            }
            else
               strcpy(buffer, save_filename);
            dbox_setfield(application.setup->d, ins->insert, buffer);

            /* --- put caret at end of writeable icon --- */
            if (setcaret)
                set_caret(dbox_syshandle(application.setup->d), ins->insert);
         }

         FEmem_free(buffer);

         ins = ins->next;
      }
   }
}

extern BOOL delete_object(char *object)
{
   _kernel_swi_regs r;

   if (object == 0) return TRUE;  /* play it safe !! */

   r.r[0] = 27;             /* wipe object */
   r.r[1] = (int)object;  /* temp. filename */
   r.r[3] = 0x02 | 0x01;    /* force/recurse (in case directory) */
   r.r[4] = r.r[5] = r.r[6] = r.r[7] = 0;

   return (_kernel_swi(OS_FSControl, &r, &r) == 0);
}


extern BOOL rename_object(char *from, char *to)
{
   _kernel_swi_regs r;

   r.r[0] = 25;             /* rename */
   r.r[1] = (int)from;
   r.r[2] = (int)to;

   return (_kernel_swi(OS_FSControl, &r, &r) == 0);
}


extern BOOL copy_object_with_delete(char *from, char *to)
{
   _kernel_swi_regs r;
   _kernel_oserror *e;

   /* NB we don't use delete-source bit on copy, in case copy of directory fails! */

   r.r[0] = 26;             /* copy object */
   r.r[1] = (int)from;
   r.r[2] = (int)to;
   r.r[3] = 0x40 | 0x02 | 0x01;  /* prompt-for-media-change/force/recurse(in case directory!) */

   e = _kernel_swi(OS_FSControl, &r, &r);

   /* now do the delete (testing if the copy worked!) */
   if (e == 0)
       return delete_object(from);
   else
   {
       werr(FALSE, msgs_lookup("utils2:Save failed %s -> %s"), from, to);
       werr(FALSE, "%s", e->errmess);
       return FALSE;
   }
}


extern BOOL find_writeable(char *name, wimp_w wh, wimp_i *i)
{
   wimp_icon *wi;
   template *t;
   wimp_wind *w;

   t = template_find(name);
   w = &t->window;

   for (*i=0; *i<w->nicons; (*i)++)
   {
      wi = ((wimp_icon *)(w + 1)) + *i;
      if (is_writeable_indirecttext(wi))
      {
          wimp_icon is;

          wimp_get_icon_info(wh, *i, &is);
          if (!(is.flags & wimp_INOSELECT))
             return TRUE;
      }
   }
   return FALSE;
}


extern int fieldlength(wimp_w w, wimp_i i)
{
   wimp_icon wi;
   int len = 0;

   wimpt_noerr(wimp_get_icon_info(w, i, &wi));
   while (wi.data.indirecttext.buffer[len] >=32) len++;

   return len;
}


extern void set_caret(wimp_w w, wimp_i i)
{
   wimp_caretstr c;
   c.i = i;
   c.x = 0;
   c.y = 0;
   c.height = -1;
   c.w = w;
   c.index = fieldlength(w, i);
   wimpt_noerr(wimp_set_caret_pos(&c));
}


extern void stralloc(char **dst, char *src)
{
   if ((*dst = FEmem_alloc(strlen(src)+1)) != 0)
        strcpy(*dst, src);
}
