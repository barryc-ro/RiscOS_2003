/* Title:    FEdbox.c
 * Purpose:  Show a dialogue box for setting options.
 * Author:   IDJ
 * History:  12-Apr-90: IDJ: created
 *           21-Jun-90: IDJ: made setup dbox hide when RUN click
 *           26-Jun-90: IDJ: fixed state handling/setting (I hope)
 *           28-Jun-90: IDJ: cancel now closes dbox as well
 *           05-Mar-91: IDJ: use msgs.h
 *           18-Mar-91: IDJ: right click on Run leaves dbox up
 *           04-Apr-91: IDJ: fix "throbbing" extended dbox
 *           29-Apr-91: IDJ: exit if too many windows
 *
 *           Re-relesae started (31-Oct-91 IDJ)
 *           31-Oct-91: IDJ: correct (re)open of setup dbox if extender icon selected
 *                           (bug DDE-0828)
 *
 *           Aquarius:
 *           25-Nov-94: IDJ: allow non-menu buttons to do insertion (bug AQU-00619)
 *           19-Dec-94: IDJ: AQU-00596 - quit frontend task on cancel click on dbox
 */

#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "dbox.h"
#include "wimp.h"
#include "template.h"
#include "msgs.h"
#include "werr.h"
#include "event.h"
#include "wimp.h"
#include "xferrecv.h"
#include "wimpt.h"
#include "help.h"

#include "global.h"
#include "types.h"
#include "FrontEnd.h"
#include "FEdbox.h"
#include "FEmem.h"
#include "FEmenus.h"
#include "FEmsg.h"
#include "FEcmdline.h"
#include "utils.h"
#include "bool.h"
#include "FEinterr.h"


#define  FEdbox_IRun     0
#define  FEdbox_ICancel  1

#define  FEdbox_large_dbox  1
#define  FEdbox_small_dbox  2


/* ---------------------------------- state handling/setting ---------------------------- */

static void FEdbox__extend_dbox(wimp_w whandle, int top, int bottom, int size)
{
   wimp_wstate state;
   wimp_icon top_icon, bottom_icon;
   int growth;
   template *t;
   int small_size = 0;

   if ((t = template_find("SetUp")) != 0)
      small_size = t->window.box.y1 - t->window.box.y0;

   /* --- get the window state --- */
   wimpt_noerr(wimp_get_wind_state(whandle, &state));

   /* --- use icon defs to set size of window --- */
   wimp_get_icon_info(whandle, top, &top_icon);
   wimp_get_icon_info(whandle, bottom, &bottom_icon);

   growth = top_icon.box.y0 - bottom_icon.box.y0;

   /* --- change bottom of window --- */
   if (size == FEdbox_small_dbox)
       state.o.box.y0 = state.o.box.y1 - small_size;
   else
       state.o.box.y0 = state.o.box.y1 - small_size - growth;

   /* --- open it again --- */
   wimpt_noerr(wimp_open_wind(&state.o));
}


static void FEdbox__click(dbox_field icon)
{
   Frontend_icon *i;
   wimp_icon *wi;

   i = find_icon(icon);
   assert(i != 0, "Zero icon pointer");
   wi = icon_num_to_pointer("SetUp", i->number);

   if (is_click(wi))
   {
      if (i->flags & (IF_ARROWUP | IF_ARROWDOWN))
      {
         int icn_val;
         wimp_mousestr m;
         BOOL going_up;

         wimp_get_point_info(&m);
         going_up = ((m.bbits & wimp_BLEFT) && (i->flags & IF_ARROWUP)) ||
                    ((m.bbits & wimp_BRIGHT) && (i->flags & IF_ARROWDOWN));

         /* --- get numeric value of the icon it changes and find it --- */
         icn_val = dbox_getnumeric(application.setup->d, i->incdec);

         /* --- modify it (up/down) --- */
         icn_val += (going_up)?i->by:-i->by;

         /* --- write the value back --- */
         if (icn_val <= i->max_val && going_up ||
             !going_up && icn_val >= i->min_val)
             dbox_setnumeric(application.setup->d, i->incdec, icn_val);
      }
      else if (i->flags & IF_EXTENDS)
      {
         wimp_icon icon;
         wimp_w handle = dbox_syshandle(application.setup->d);
         wimp_get_icon_info(handle, i->number, &icon);

         if ((icon.flags & wimp_ISELECTED) != 0)
         {
           wimpt_noerr(wimp_set_icon_state(handle, i->number, wimp_ISELECTED, (wimp_iconflags)0));
           FEdbox__extend_dbox(handle, application.setup->extends_from,
                                      application.setup->extends_to,
                                      FEdbox_small_dbox);
         }
         else
         {
           wimpt_noerr(wimp_set_icon_state(handle, i->number, wimp_ISELECTED, wimp_ISELECTED));
           FEdbox__extend_dbox(handle, application.setup->extends_from,
                                      application.setup->extends_to,
                                      FEdbox_large_dbox);
         }
      }
      else if (i->insert)   /* Bug-fix AQU-00619 */
      {
         char *p = i->insert;
         wimp_caretstr c;
         wimp_icon *ci;

         /* --- keys which insert a string into another icon --- */
         /* --- if we have the caret, then insert the given string associated --- */
         /* --- with this icon                                                --- */
         wimp_get_caret_pos(&c);
         if (c.w == dbox_syshandle(application.setup->d))
         {
            ci = icon_num_to_pointer("SetUp", c.i);
            if (is_writeable_indirecttext(ci))
            {
               /* --- insert the string --- */
               /* --- problems here with multiple characters using wimp_processkey --- */
               /* --- so we insert straight into the keyboard buffer (yuk!)        --- */
               while (*p)
               {
                  _kernel_swi_regs r;
                  r.r[0] = 138;  /* insert into buffer */
                  r.r[1] = 0;    /* the keyboard */
                  r.r[2] = *p++; /* the character */
                  _kernel_swi(OS_Byte, &r, &r);
               }
             }
         }
      }
      else
      {
         if (i->flags & IF_SELECTED)
         {
             /* --- deselect it --- */
             dbox_setnumeric(application.setup->d, i->number, 0);
             i->flags &= ~IF_SELECTED;

             /* --- "unexclude" things that were excluded --- */
             do_exclusions(i, IS_ICON, FALSE);
         }
         else
         {
             /* --- select it --- */
             dbox_setnumeric(application.setup->d, i->number, 1);
             i->flags |= IF_SELECTED;

             /* --- do the deselections --- */
             do_deselections(i, IS_ICON);

             /* --- do the exclusions --- */
             do_exclusions(i, IS_ICON, TRUE);
         }
      }
   }
   else if (is_autorepeat(wi))   /* this is an arrow key */
   {
      int icn_val;
      wimp_mousestr m;
      BOOL going_up;

      wimp_get_point_info(&m);
      going_up = ((m.bbits & wimp_BLEFT) && (i->flags & IF_ARROWUP)) ||
                 ((m.bbits & wimp_BRIGHT) && (i->flags & IF_ARROWDOWN));

      /* --- get numeric value of the icon it changes and find it --- */
      icn_val = dbox_getnumeric(application.setup->d, i->incdec);

      /* --- modify it (up/down) --- */
      icn_val += (going_up)?i->by:-i->by;

      /* --- write the value back --- */
      if (icn_val <= i->max_val && going_up ||
          !going_up && icn_val >= i->min_val)
          dbox_setnumeric(application.setup->d, i->incdec, icn_val);
   }
   else if (is_menu(wi))
   {
      char *p = i->insert;
      wimp_caretstr c;
      wimp_icon *ci;

      /* --- keys which insert a string into another icon --- */
      /* --- if we have the caret, then insert the given string associated --- */
      /* --- with this icon                                                --- */
      wimp_get_caret_pos(&c);
      if (c.w == dbox_syshandle(application.setup->d))
      {
         ci = icon_num_to_pointer("SetUp", c.i);
         if (is_writeable_indirecttext(ci))
         {
            /* --- insert the string --- */
            /* --- problems here with multiple characters using wimp_processkey --- */
            /* --- so we insert straight into the keyboard buffer (yuk!)        --- */
            while (*p)
            {
               _kernel_swi_regs r;
               r.r[0] = 138;  /* insert into buffer */
               r.r[1] = 0;    /* the keyboard */
               r.r[2] = *p++; /* the character */
               _kernel_swi(OS_Byte, &r, &r);
            }
          }
      }
   }
   else
   {
      /* do nothing */
   }
}


static void FEdbox__cancel(void)
{
   Frontend_icon *icon;
   wimp_icon *wi;

   /* --- this function returns to the previous state of the dialogue box --- */

   icon = application.setup->icons;
   while (icon != 0)
   {
      /* --- see what sort of icon it is in the template --- */
      wi = icon_num_to_pointer("SetUp", icon->number);

      /* --- indirect text - writeable --- */
      if (is_writeable_indirecttext(wi))
      {
         /* --- restore saved buffer --- */
         if (icon->save_buffer != 0)
            dbox_setfield(application.setup->d, icon->number, icon->save_buffer);
      }
      /* --- click/autorepeat --- */
      else if (is_click(wi) || is_autorepeat(wi))
      {
         if ((icon->flags & (IF_ARROWUP | IF_ARROWDOWN)) == 0)
         {
             /* --- restore saved flags --- */
             icon->flags = icon->save_flags;
             if (icon->flags & IF_SELECTED)
             {
                dbox_setnumeric(application.setup->d, icon->number, 1);
                do_deselections(icon, IS_ICON);
                do_exclusions(icon, IS_ICON, TRUE);
             }
             else
                dbox_setnumeric(application.setup->d, icon->number, 0);
         }
      }
      icon = icon->next;
   }
}


static void FEdbox__save_state(void)
{
   Frontend_icon *icon;
   wimp_icon *wi;

   /* --- this function saves the state of the dialogue box --- */

   icon = application.setup->icons;
   while (icon != 0)
   {
      /* --- see what sort of icon it is in the template --- */
      wi = icon_num_to_pointer("SetUp", icon->number);

      if (is_writeable_indirecttext(wi))
      {
         if (icon->save_buffer == 0)
             icon->save_buffer = FEmem_alloc(wi->data.indirecttext.bufflen);

         dbox_getfield(application.setup->d, icon->number, icon->save_buffer, wi->data.indirecttext.bufflen);
      }
      else if (is_click(wi) || is_autorepeat(wi))
      {
         if ((icon->flags & (IF_ARROWUP | IF_ARROWDOWN)) == 0)
         {
              icon->save_flags = icon->flags;
         }
      }
      icon = icon->next;
   }
}


static void FEdbox__initial_state(void)
{
   Frontend_icon *icon;
   wimp_icon *wi;

   /* --- this function sets the initial state of the dialogue box --- */

   icon = application.setup->icons;

   while (icon != 0)
   {
      /* --- see what sort of icon it is in the template --- */
      wi = icon_num_to_pointer("SetUp", icon->number);

      /* --- indirect text - writeable --- */
      if (is_writeable_indirecttext(wi))
      {
          /* --- nothin there yet, so put default there --- */
          if (icon->flags & IF_STRING)
          {
                if (!(application.flags & AF_MAKE))
                {
                   if (icon->dft_value.string != 0)
                      dbox_setfield(application.setup->d, icon->number, icon->dft_value.string);
                }
                else
                {
                   if (icon->make_dft_value.string != 0)
                      dbox_setfield(application.setup->d, icon->number, icon->make_dft_value.string);
                }
          }
          else if (icon->flags & IF_NUMBER)
          {
                if (!(application.flags & AF_MAKE))
                   dbox_setnumeric(application.setup->d, icon->number, icon->dft_value.integer);
                else
                   dbox_setnumeric(application.setup->d, icon->number, icon->make_dft_value.integer);
          }
      }
      /* --- click/autorepeat --- */
      else if (is_click(wi) || is_autorepeat(wi))
      {
         if ((icon->flags & (IF_ARROWUP|IF_ARROWDOWN)) == 0)
         {
             if (!(application.flags & AF_MAKE))
                dbox_setnumeric(application.setup->d, icon->number, icon->dft_value.integer);
             else
                dbox_setnumeric(application.setup->d, icon->number, icon->make_dft_value.integer);
             if ((icon->dft_value.integer == 1 && !(application.flags & AF_MAKE)) ||
                 (icon->make_dft_value.integer == 1 && (application.flags & AF_MAKE)))
             {
               icon->flags |= IF_SELECTED;
               do_deselections(icon, IS_ICON);
               do_exclusions(icon, IS_ICON, TRUE);
             }
             else
               icon->flags &= ~IF_SELECTED;
         }
      }
      icon = icon->next;
   }

   /* --- if we were invoked via make, then we also need to:
             1. do all the make exclusions (ie exclude things not appropriate for make)
             2. set up the menu to take its Make defaults
             3. change button icon texts
   */
   if (application.flags & AF_MAKE)
   {
      do_make_exclusions();
      FEmenus_setup_make_defaults();
      dbox_setfield(application.setup->d, FEdbox_IRun, msgs_lookup("FECmd5:OK"));
   }
}


/* -------------------------------------------- event handling ----------------------------- */

static void FEdbox__events(dbox d, void *handle)
{
   dbox_field click;

   IGNORE(handle);

   switch(click = dbox_get(d))
   {
      case dbox_CLOSE:
        dbox_hide(d);
        if (application.flags & AF_MAKE) exit(EXIT_SUCCESS);  /* !!! close dbox from make, we must exit */
        break;

      case FEdbox_IRun:
        {
           /* --- construct the command line and run it --- */
           if (!dbox_persist())
              dbox_hide(d);
           if (application.flags & AF_MAKE)
           {
              FEcmdline_send();
              exit(EXIT_SUCCESS);
           }
           else
              FEcmdline_run();
        }
        break;

      case FEdbox_ICancel:
        /* --- revert to previous options and close box --- */
        FEdbox__cancel();
        FEmenus_setup_cancel();
        dbox_hide(d);
        /* IDJ: 19-Dec-94: bug-fix AQU-00596 */
        if (application.flags & AF_MAKE) exit(EXIT_SUCCESS);  /* !!! close dbox from make, we must exit */
        break;

      default:
        /* --- process the click --- */
        FEdbox__click(click);
        break;
   }
}


static BOOL FEdbox__raw_events(dbox d, void *event, void *handle)
{
   wimp_eventstr *e = (wimp_eventstr *)event;

   IGNORE(handle);

   switch(e->e)
   {
      case wimp_ESEND:
      case wimp_ESENDWANTACK:
         switch(e->data.msg.hdr.action)
         {
            case wimp_MDATALOAD:
               {
                  FEmsg_dataload(TRUE, e->data.msg.data.dataload.i);
               }
               return TRUE;

            case wimp_MDATASAVE:
               {
                  if (!(application.flags & AF_MAKE))
                     FEmsg_datasave(&e->data.msg, e->data.msg.data.datasave.i);
                  else
                     werr(FALSE, msgs_lookup("FEdbox1:Can't import from other applications when invoked from !Make"));
               }
               return TRUE;

            case wimp_MHELPREQUEST:
               return help_dboxrawevents(d, event, "SETUP");

            default:
               return FALSE;
         }
         break;
      case wimp_EOPEN:
         if (application.setup->extends != -1)
         {
            wimp_icon icon;
            wimp_w handle = dbox_syshandle(d);
            wimp_get_icon_info(handle, application.setup->extends, &icon);

           wimpt_noerr(wimp_open_wind(&e->data.o));
           if ((icon.flags & wimp_ISELECTED) != 0)
             FEdbox__extend_dbox(handle, application.setup->extends_from,
                                         application.setup->extends_to,
                                         FEdbox_large_dbox);
           else
             FEdbox__extend_dbox(handle, application.setup->extends_from,
                                         application.setup->extends_to,
                                         FEdbox_small_dbox);
            return TRUE;
         }
         else
            return FALSE;

      default:
         return FALSE;
   }
}


/* --------------------------------------- exported functions ------------------------------- */

extern void FEdbox_create(void)
{
   if (application.setup->d == 0)
   {
      if ((application.setup->d = dbox_new("SetUp")) == 0)
      {
          werr(TRUE, msgs_lookup("FEdbox2:Unable to start up -- not enough space (or too many windows)"));
      }
      dbox_eventhandler(application.setup->d, FEdbox__events, 0);
      dbox_raw_eventhandler(application.setup->d, FEdbox__raw_events, 0);
      event_attachmenumaker(dbox_syshandle(application.setup->d), FEmenus_setup_maker,
                            FEmenus_setup_proc, 0);

      FEdbox__initial_state();
   }
}


extern void FEdbox_show(void)
{
   wimp_i i;
   wimp_wstate ws;

   /* --- save state in case of a cancel --- */
   FEdbox__save_state();
   FEmenus_setup_save_state();

   /* --- show the box --- */
   wimpt_noerr(wimp_get_wind_state(dbox_syshandle(application.setup->d), &ws));
   if (ws.flags & wimp_WOPEN)
   {
      ws.o.behind = -1;
      wimpt_noerr(wimp_open_wind(&ws.o));
   }
   else
      dbox_showstatic(application.setup->d);

   /* --- ensure toggled large if appropriate --- */
   /* IDJ: 31-Oct-91: bug fix DDE-0828 */
   if (application.setup->extends != -1)
   {
      wimp_icon icon;
      wimp_w handle = dbox_syshandle(application.setup->d);
      wimp_get_icon_info(handle, application.setup->extends, &icon);

     if ((icon.flags & wimp_ISELECTED) != 0)
       FEdbox__extend_dbox(handle, application.setup->extends_from,
                                   application.setup->extends_to,
                                   FEdbox_large_dbox);
     else
       FEdbox__extend_dbox(handle, application.setup->extends_from,
                                   application.setup->extends_to,
                                   FEdbox_small_dbox);
   }

   /* --- caret at end of first writeable icon --- */
   if (find_writeable("SetUp", dbox_syshandle(application.setup->d), &i))
   {
       set_caret(dbox_syshandle(application.setup->d), i);
   }
}
