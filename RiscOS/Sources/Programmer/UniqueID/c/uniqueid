/* > uniqueid.c
 *
 *	  UniqueID code.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "uniqueid.h"
#include "idblock.h"
#include "nvram.h"


static uniqueid UniqueID;


static byte *
StoreBigEndian( byte *bp, int word, int size )
{
	size = (size - 1) * 8;			/* Bits to shift. */
	while ( size )
	{
		*bp++ = (byte)(word >> size);
		size -= 8;
	}
	return bp;
}


static char *
GetOSVersion( void )
{
	int modbase;
	_kernel_oserror *err = _swix( OS_Module, _INR(0,1)|_OUT(3), 18, "OSVersion", &modbase );
	return ( err == NULL ) ? (char *)(modbase + *(int *)(modbase + 0x14)) : NULL;
}


_kernel_oserror *
uniqueid_initialise( void )
{
	uniqueid *uid = &UniqueID;
	char *osversion = GetOSVersion();

	/* Copy template unique ID. */
	memcpy( uid, idblock_start_address, sizeof(uniqueid) );

	/* Fill in NC OS and BIOS version numbers. */
	if ( osversion != NULL )
	{
		char *sep = strchr( osversion, '.' );
		if ( sep != NULL )
		{
			char *spc = sep;
			while ( (spc != osversion) && (*spc != ' ') && (*spc != 9) ) spc--;
			uid->bios_major = uid->ncos_major = atoi( spc + 1 );
			uid->bios_minor = uid->ncos_minor = atoi( sep + 1 );
		}
	}

	/* Fill in serial number. */
	switch ( uid->serial_type )
	{
		case UNIQUEID_SERIALTYPE_NCI:
			/* Assume ID length and data are defined in s.<Machine>.idblock. */
			break;

		case UNIQUEID_SERIALTYPE_ETHERID:
		{
			int lsw, msw;
			byte *bp = uid->serial_info;

			_swix( OS_ReadSysInfo, _IN(0)|_OUTR(0,1), 4, &lsw, &msw );
			uid->serial_len = 6;
			bp = StoreBigEndian( bp, msw, 2 );
			(void)StoreBigEndian( bp, lsw, 4 );
			break;
		}

		case UNIQUEID_SERIALTYPE_EEPROM:
		{
			int length;
			_swix( NVRAM_Read, _INR(0,2)|_OUT(0), UNIQUEID_NVRAM_TAG, 0, 0, &length );
			if ( length > 0 )
			{
				uid->serial_len = length;
				_swix( NVRAM_Read, _INR(0,2), UNIQUEID_NVRAM_TAG, uid->serial_info, length );
			}
			break;
		}

		case UNIQUEID_SERIALTYPE_DALLASID:
		{
			int lsw, msw;
			byte *bp = uid->serial_info;

			_swix( OS_ReadSysInfo, _IN(0)|_OUTR(0,1), 5, &lsw, &msw );
			uid->serial_len = 6;
			bp = StoreBigEndian( bp, msw, 2 );
			(void)StoreBigEndian( bp, lsw, 4 );
			break;
		}
	}
	return NULL;
}


_kernel_oserror *
uniqueid_read( _kernel_swi_regs *r )
{
	uniqueid *uid = (uniqueid *)r->r[1];

	if ( uid != NULL )
	{
		int size = r->r[2];
		if ( size > sizeof(uniqueid) ) size = sizeof(uniqueid);
		memcpy( uid, &UniqueID, size );
		r->r[2] = size;
	}
	else
	{
		r->r[2] = sizeof(uniqueid);
	}

	return NULL;
}


_kernel_oserror *
uniqueid_set( _kernel_swi_regs *r )
{
	switch ( r->r[0] )
	{
		case UNIQUEID_BIOSPATCH_REASON:
			UniqueID.bios_patch = r->r[1];
			break;
			
		case UNIQUEID_BIOSPORT_REASON:
			UniqueID.bios_port = r->r[1];
			break;
			
		case UNIQUEID_NCOSPATCH_REASON:
			UniqueID.ncos_patch = r->r[1];
			break;
			
		case UNIQUEID_NCOSPORT_REASON:
			UniqueID.ncos_port = r->r[1];
			break;
	}
	return NULL;
}
