
; Territory_TransformString SWI for an 8-bit or simplistic UTF-8 territory

; Entry: R1 = destination string buffer
;        R2 = source string
;        R3 = length of destination string buffer
;
; Exit:  R0 = The length of the transformed string (not including the
;             terminating null character). If the returned value is >= R3 on
;             entry the contents of the buffer pointed to by R1 are
;             indeterminate.
;
;        The Territory_TransformString SWI transforms the string pointed to
;        by R2 and places the resulting string into the buffer pointed to by
;        R1. The transformation is such that if a byte by byte comparison is
;        applied to two transformed strings the strings will compare less
;        than, equal to or greater than as though Territory_Collate had been
;        appled to the original strings. No more than R3 bytes are placed in
;        the buffer pointed to by R1 including a terminating null character.
;        If R3 is 0 R1 may be a null pointer. If copying takes place between
;        strings that overlap the behaviour is undefined.
;
; OSmith 30-Apr-92 Added two instructions to make code actually transform
; the string rather than just copying it!
;
; KBracey 13-Sep-98 modified to do a better comparison, looking at first
; the letters, then the accents, then the case (see Collate).
;
; The main complexity is different length strings. You can't just concatenate
; the strings. For example if you just concatenated the transformations of
; "c" and "cba" you might end up with "ccc" and "cbacbacba" => "c" > "cba" !
; You need a separator token (say X), hence:  "cXcXcX" cbaXcbaXcbaX", but this
; token must be lexicographically less than any other, but > 0. Solution is
; to make the token &01, and write a real &01 as &02 01, and &02 as &02 &02.

 [ newsortorder
TransformString
        Entry   "r1-r6"
        SUB     r12, r2, #1
        MOV     r14, #0
01      LDRB    r0, [r12, #1]!
        CMP     r0, #&02
        ADDLS   r14, r14, #1      ; must escape &01,&02 -> assumption is SortTable[1,2]=1,2
 [ CollateDanishAA
        TEQ     r0, #'A'
        TEQNE   r0, #'a'
        BNE     %FT05
        LDRB    r4, [r12, #1]
        TEQ     r4, r0
        SUBEQ   r14, r14, #1
        BEQ     %FT05
        TEQ     r0, #'A'
        TEQEQ   r4, #'a'
        SUBEQ   r14, r14, #1    ; join AA, Aa, aa
05
 ]
 [ CollateLatin1Ligatures
        TEQ     r0, #'ž'
        TEQNE   r0, #'Ÿ'
        ADDEQ   r14, r14, #1    ; separate ligatures...
 ]
 [ CollateOELigatures
        TEQ     r0, #'š'
        TEQNE   r0, #'›'
        ADDEQ   r14, r14, #1    ; separate ligatures...
 ]
 [ CollateThornAsTH
        TEQ     r0, #'Þ'
        TEQNE   r0, #'þ'
        ADDEQ   r14, r14, #1    ; split thorn into t,h...
 ]
        CMP     r0, #0
        BNE     %B01
        SUB     r0, r12, r2     ; r0 = strlen(r2)
        ADD     r0, r0, r14
        ADD     r0, r0, r0, LSL #1 ; r0 = length of output
        ADRL    r4, SortValueTable
        ADRL    r5, ToLowerTable
        ADRL    r6, ToPlainForCollateTable
02      SUBS    r3, r3, #1      ; for (; r3!=0; r3--)
        EXITS   CC
        LDRB    r12, [r2], #1   ;     if ((*r1++ = *r2++) == 0) break;
 [ CollateDanishAA
        TEQ     r12, #'A'
        TEQNE   r12, #'a'
        BNE     %FT14
        LDRB    r14, [r2]
        TEQ     r14, r12
        BEQ     %FT50
        TEQ     r12, #'A'
        TEQEQ   r12, #'a'
        BNE     %FT14
50      TEQ     r12, #'A'
        MOVEQ   r12, #'Å'
        MOVNE   r12, #'å'
        ADD     r2, r2, #1
14
 ]
        TEQ     r6, #0
        LDRNEB  r12, [r6, r12]  ; strip the accent
        TEQ     r5, #0
        LDRNEB  r12, [r5, r12]  ; lower case
 [ CollateLatin1Ligatures
        TEQ     r12, #'ž'
        TEQNE   r12, #'Ÿ'
        BNE     %FT15
        MOV     r14, #'f'
        LDRB    r14, [r4, r14]
        STRB    r14, [r1],#1
        SUBS    r3, r3, #1
        EXITS   CC
        TEQ     r12, #'ž'
        MOVEQ   r12, #'i'
        MOVNE   r12, #'l'
15
 ]
 [ CollateOELigatures
        TEQ     r12, #'š'
        TEQNE   r12, #'›'
        BNE     %FT16
        TEQ     r12, #'š'
        MOVEQ   r14, #'O'
        MOVNE   r14, #'o'
        LDRB    r14, [r4, r14]
        STRB    r14, [r1],#1
        SUBS    r3, r3, #1
        EXITS   CC
        TEQ     r12, #'š'
        MOVEQ   r12, #'E'
        MOVNE   r12, #'e'
16
 ]
 [ CollateThornAsTH
        TEQ     r12, #'Þ'
        TEQNE   r12, #'þ'
        BNE     %FT17
        TEQ     r12, #'Þ'
        MOVEQ   r14, #'T'
        MOVNE   r14, #'t'
        LDRB    r14, [r4, r14]
        STRB    r14, [r1],#1
        SUBS    r3, r3, #1
        EXITS   CC
        TEQ     r12, #'Þ'
        MOVEQ   r12, #'H'
        MOVNE   r12, #'h'
17
 ]
        LDRB    r12, [r4, r12]  ; OSS Read sort value table entry
        CMP     r12, #2
        BHI     %FT20
        SUBS    r3, r3, #1
        EXITS   CC
        MOV     r14, #2
        STRB    r14, [r1], #1    ; escape &01, &02 (and &00).
20      STRB    r12, [r1], #1
        CMP     r12, #0
        BNE     %B02
        MOV     r14, #1
        STRB    r14, [r1, #-2]   ; separator token
03      TEQ     r5, #0
        TEQEQ   r6, #0
        EXITS   EQ              ; finished. return r0

        SUB     r1, r1, #1
        ADD     r3, r3, #1

        LDR     r2, [sp, #4]    ; restore source pointer

        TEQ     r6, #0
        MOVNE   r6, #0
        BNE     %B02            ; tack on accented version

        MOV     r5, #0
        B       %B02            ; tack on cased version
 |
TransformString
        Entry   "r1-r4"
        SUB     r12, r2, #1
01      LDRB    r0, [r12, #1]!  ; r0 = strlen(r2)
        CMP     r0, #0
        BNE     %B01
        SUB     r0, r12, r2
        ADRL    r4, SortValueTable
02      SUBS    r3, r3, #1      ; for (; r3!=0; r3--)
        EXITS   CC
        LDRB    r12, [r2], #1   ;     if ((*r1++ = *r2++) == 0) break;
        LDRB    r12, [r4, r12]  ; OSS Read sort value table entry
        STRB    r12, [r1], #1
        CMP     r12, #0
        BNE     %B02
        EXITS                   ; return r0
 ]
        LNK     s.tail
