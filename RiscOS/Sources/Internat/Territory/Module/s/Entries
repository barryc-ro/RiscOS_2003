; Sources.Entries

;--------------------------------------------------------
Alphabet
        Debug   xx,"Territory : Alphabet entry"

        MOV     r0,#AlphNum
        MOV     PC,LR

;--------------------------------------------------------
AlphabetIdent
        Debug   xx,"Territory : AlphabetIdentifier entry"

        ADR     r0,Alphabet_IdentString
        MOV     PC,LR

Alphabet_IdentString

        DCB     "$AlphabetName",0
        ALIGN


;--------------------------------------------------------
SelectKeyboardHandler

        Push    "r0-r2,LR"

        MOV     r0,#71
        MOV     r1,#128+TerrNum
        SWI     XOS_Byte
        STRVS   r0,[SP]

        Pull    "r0-r2,PC"

;--------------------------------------------------------
WriteDirection

        MOV     r0,#WriteDir
        MOV     PC,LR

;--------------------------------------------------------


CharacterPropertyTable

        TEQ     r1,#Property_Control
        ADREQL  r0,ControlTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Uppercase
        ADREQL  r0,UppercaseTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Lowercase
        ADREQL  r0,LowercaseTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Alpha
        ADREQL  r0,AlphaTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Punctuation
        ADREQL  r0,PunctuationTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Space
        ADREQL  r0,SpaceTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Digit
        ADREQL  r0,DigitTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_XDigit
        ADREQL  r0,XDigitTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Accented
        ADREQL  r0,AccentedTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_ForwardFlow
        ADREQL  r0,ForwardFlowTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_BackwardFlow
        ADREQL  r0,BackwardFlowTable
        MOVEQ   PC,LR

        ADR     r0,ErrorBlock_UnknownProperty
        B       message_errorlookup

ErrorBlock_UnknownProperty
        DCD     0
        DCB     "UnkProp",0
        ALIGN

;--------------------------------------------------------
GetLowerCaseTable

        ADRL    r0,ToLowerTable
        MOV     PC,LR

;--------------------------------------------------------
GetUpperCaseTable

        ADRL    r0,ToUpperTable
        MOV     PC,LR

;--------------------------------------------------------
GetControlTable

        ADRL    r0,ToControlTable
        MOV     PC,LR

;--------------------------------------------------------
GetPlainTable

        ADRL    r0,ToPlainTable
        MOV     PC,LR

;--------------------------------------------------------
GetValueTable

        ADRL    r0,ToValueTable
        MOV     PC,LR

;--------------------------------------------------------
GetRepresentationTable

        ADRL    r0,ToRepresentationTable
        MOV     PC,LR

;--------------------------------------------------------
; Collate
;     Entry:
;             R1 -> String 1   (0 terminated)
;             R2 -> String 2   (0 terminated)
;             R3 = flags
;                        bit 0 - Ignore case.
;                        bit 1 - Ignore accents
;     Exit:
;             R0   <0 if S1 < S2
;                  =0 if S1 = S2
;                  >0 if S1 > S2
;             Other registers preserved.
;
;             Z set if equal (EQ).
;             C set and Z clear if S1 > S2 (HI)
;             N set and V clear if S1 < S2 (LT)
;
;             V set if error.

Collate

        Push    "r1-r7,LR"

 [ CollateLatin1Ligatures :LOR: CollateOELigatures :LOR: CollateDanishAA :LOR: CollateThornAsTH
        BIC     r3, r3, #&ff000000
 ]

 [ newsortorder
        ; We start off ignoring case and accents
        ORR     r3,r3,#Collate_IgnoreCase :OR: Collate_IgnoreAccent
        ADRL    r4,ToLowerTable
        ADRL    r5,ToPlainForCollateTable
 |
        TST     r3,#Collate_IgnoreCase
        ADRNEL  r4,ToLowerTable
        TST     r3,#Collate_IgnoreAccent
        ADRNEL  r5,ToPlainForCollateTable
 ]
        ADRL    r7,SortValueTable

01
        LDRB    r14,[r1],#1
        LDRB    r6 ,[r2],#1


        Debug   xx,"r14,r6",r14,r6

 [ CollateDanishAA
        TEQ     r14,#'A'
        TEQNE   r14,#'a'
        TEQNE   r6, #'A'
        TEQNE   r6, #'a'
        BNE     %FT35

        TEQ     r14,#'A'
        TEQNE   r14,#'a'
        BNE     %FT33           ; r6 must be an A/a
        LDRB    r0, [r1]
        TEQ     r0, r14
        BEQ     %FT31
        TEQ     r14,#'A'
        TEQEQ   r0,#'a'
        BNE     %FT32
31
        TEQ     r14,#'A'        ; Got aa, Aa or AA.
        MOVEQ   r14,#'Å'
        MOVNE   r14,#'å'
        ADD     r1, r1, #1

32
        TEQ     r6,#'A'
        TEQNE   r6,#'a'
        BNE     %FT35
33      LDRB    r0, [r2]
        TEQ     r0, r6
        BEQ     %FT34
        TEQ     r6,#'A'
        TEQEQ   r0,#'a'
        BNE     %FT35
34
        TEQ     r6,#'A'         ; Got aa, Aa or AA.
        MOVEQ   r6,#'Å'
        MOVNE   r6,#'å'
        ADD     r2, r2, #1
35
 ]

        TST     r3,#Collate_IgnoreAccent
        LDRNEB  r14,[r5,r14]
        LDRNEB  r6 ,[r5,r6]

        Debug   xx,"r14,r6",r14,r6

        TST     r3,#Collate_IgnoreCase
        LDRNEB  r14,[r4,r14]
        LDRNEB  r6 ,[r4,r6]

        Debug   xx,"r14,r6",r14,r6

 [ CollateLatin1Ligatures
        TEQ     r14,#'ž'
        TEQNE   r14,#'Ÿ'
        TEQNE   r6, #'ž'
        TEQNE   r6, #'Ÿ'
        BNE     %FT05

        TEQ     r14,#'ž'
        TEQNE   r14,#'Ÿ'
        BNE     %FT03           ; r6 must be a ligature
        EOR     r3, r3, #&20000000
        TST     r3, #&20000000
        MOVNE   r14, #'f'
        SUBNE   r1, r1, #1
        BNE     %FT02
        TEQ     r14, #'ž'
        MOVEQ   r14, #'i'
        MOVNE   r14, #'l'

02      TEQ     r6,#'ž'
        TEQNE   r6,#'Ÿ'
        BNE     %FT05
03      EOR     r3, r3, #&10000000
        TST     r3, #&10000000
        MOVNE   r6, #'f'
        SUBNE   r2, r2, #1
        BNE     %FT05
        TEQ     r6, #'ž'
        MOVEQ   r6, #'i'
        MOVNE   r6, #'l'
05
 ]

 [ CollateOELigatures
        TEQ     r14,#'š'
        TEQNE   r14,#'›'
        TEQNE   r6, #'š'
        TEQNE   r6, #'›'
        BNE     %FT15

        TEQ     r14,#'š'
        TEQNE   r14,#'›'
        BNE     %FT13           ; r6 must be a ligature
        EOR     r3, r3, #&08000000
        TST     r3, #&08000000
        BEQ     %FT11
        SUB     r1, r1, #1
        TEQ     r14,#'š'
        MOVEQ   r14,#'O'
        MOVNE   r14,#'o'
        B       %FT12
11      TEQ     r14,#'š'
        MOVEQ   r14,#'E'
        MOVNE   r14,#'e'

12      TEQ     r6,#'š'
        TEQNE   r6,#'›'
        BNE     %FT15
13      EOR     r3, r3, #&04000000
        TST     r3, #&04000000
        BEQ     %FT14
        SUB     r1, r1, #1
        TEQ     r6,#'š'
        MOVEQ   r6,#'O'
        MOVNE   r6,#'o'
        B       %FT15
14      TEQ     r6,#'š'
        MOVEQ   r6,#'E'
        MOVNE   r6,#'e'
15
 ]

 [ CollateThornAsTH
        TEQ     r14,#'Þ'
        TEQNE   r14,#'þ'
        TEQNE   r6, #'Þ'
        TEQNE   r6, #'þ'
        BNE     %FT25

        TEQ     r14,#'Þ'
        TEQNE   r14,#'þ'
        BNE     %FT23           ; r6 must be a thorn
        EOR     r3, r3, #&02000000
        TST     r3, #&02000000
        BEQ     %FT21
        SUB     r1, r1, #1
        TEQ     r14,#'Þ'
        MOVEQ   r14,#'T'
        MOVNE   r14,#'t'
        B       %FT22
21      TEQ     r14,#'Þ'
        MOVEQ   r14,#'H'
        MOVNE   r14,#'h'

22      TEQ     r6,#'Þ'
        TEQNE   r6,#'þ'
        BNE     %FT25
23      EOR     r3, r3, #&04000000
        TST     r3, #&04000000
        BEQ     %FT24
        SUB     r1, r1, #1
        TEQ     r6,#'Þ'
        MOVEQ   r6,#'T'
        MOVNE   r6,#'t'
        B       %FT25
24      TEQ     r6,#'Þ'
        MOVEQ   r6,#'H'
        MOVNE   r6,#'h'
25
 ]

        LDRB    r14,[r7,r14]
        LDRB    r6 ,[r7,r6]

        Debug   xx,"r14,r6",r14,r6

        SUBS    r0,r14,r6
        Pull    "r1-r7,PC",NE           ; Not equal, result is result of compare.
        TEQ     r14,#0
 [ newsortorder
        BNE     %BT01                   ; Equal but not 0, get next char.
        LDR     r14,[sp,#8]             ; Get original flags
        EORS    r14,r3,r14
        Pull    "r1-r7,PC",EQ           ; Done desired comparison - they're equal

        LDMIA   sp,{r1,r2}              ; Restore string pointers

        TST     r14,#Collate_IgnoreAccent ; Do they want us to differ accents?
        BICNE   r3,r3,#Collate_IgnoreAccent
        BNE     %BT01                   ; Back to the top, doing accents this time.

        BIC     r3,r3,#Collate_IgnoreCase ; Already obeying accent directive, so
        B       %BT01                   ; must be disobeying case - check case.
 |
        Pull    "r1-r7,PC",EQ           ; Both 0 -> Strings equal.
        B       %B01
 ]

; ------------------------------------------------------------------------
; ReadTimeZones
;
; In:
;       -
; Out:
;       R0 - Pointer to name of standard TZ
;       R1 - Pointer to name of summer TZ.
;       R2 - Offser from UTC to standard time
;       R3 - Offset from UTC to summer time.
;
ReadTimeZones
        STMDB   sp!, {lr}

        MOV     r0, #ReadCMOS
        MOV     r1, #TimeZoneCMOS
        SWI     XOS_Byte
        LDMVSIA sp!, {pc}

        MOV     r2, r2, LSL #24
        MOV     r2, r2, ASR #24

 [ USTimeZones
        CMP     r2, #-22
        ADRGE   r0, NODSTName1
        ADRGE   r1, DSTName1
        BGE     %FT10
        CMP     r2, #-26
        ADRGE   r0, NODSTName2
        ADRGE   r1, DSTName2
        BGE     %FT10
        CMP     r2, #-30
        ADRGE   r0, NODSTName3
        ADRGE   r1, DSTName3
        ADRLT   r0, NODSTName4
        ADRLT   r1, DSTName4
10
 |
        ADR     R0,NODSTName
        ADR     R1,DSTName
 ]

        ADD     r3, r2, r2, ASL #1
        ADD     r3, r2, r3, ASL #3
        RSB     r3, r3, r3, ASL #4
        RSB     r3, r3, r3, ASL #4

        MOV     r2, r3, ASL #4
        LDR     r3, =(DSTOffset-NODSTOffset)
        ADD     r3, r3, r2

        LDMIA   sp!, {pc}

 [ USTimeZones
NODSTName1                DCB "$NODST1",0
DSTName1                  DCB "$DST1",0
NODSTName2                DCB "$NODST2",0
DSTName2                  DCB "$DST2",0
NODSTName3                DCB "$NODST3",0
DSTName3                  DCB "$DST3",0
NODSTName4                DCB "$NODST4",0
DSTName4                  DCB "$DST4",0
 |
NODSTName                 DCB "$NODST",0
DSTName                   DCB "$DST",0
 ]
StandardDateFormat        DCB "$DateFormat",0
StandardTimeFormat        DCB "$TimeFormat",0
StandardDateAndTimeFormat DCB "$DateAndTime",0

        ALIGN

; ------------------------------------------------------------------------
; ReadSymbols
;
; In:
;       R1 - Reason code:
;               0 Return pointer to 0 terminated decimal point string.
;               1 Return pointer to 0 terminated thousands separator
;               2 Return pointer byte list containing the size of each
;                 group of digits in formatted nonmonetary quantities.
;                 255   = No further grouping
;                   0   = Repeat last grouping for rest of number
;                 other = Size of current group, the next byte contains
;                         the size of the next group of dogits before the
;                          current group.
;               3 Return pointer to 0 terminated international currency symbol.
;               4 Return pointer to 0 terminated currency symbol in local alphabet.
;               5 Return pointer to 0 terminated decimal point used for monetary quantities
;               6 Return pointer to 0 terminated thousands separator for monetary quantities
;               7 Return pointer byte list containing the size of each
;                 group of digits in formatted monetary quantities.
;               8 Return pointer to 0 terminated positive sign used for monetary quantities
;               9 Return pointer to 0 terminated negative sign used for monetary quantities
;              10 Return number of fractional digits to be displayed in an internationally
;                 formatted monetay quantity
;              11 Return number of fractional digits to be displayed in a formatted monetay
;                 quantity
;              12 Return 1 If the currency symbol precedes the value for a nonnegative
;                          formatted monetary quantity
;                        0 If the currency symbol succeeds the value for a nonnegative
;                          formatted monetary quantity
;              13 Return 1 If the currency symbol is separated by a space from the value for a
;                          nonnegative formatted monetary quantity
;                        0 If the currency symbol is not separated by a space from the value for a
;                          nonnegative formatted monetary quantity
;              14 Return 1 If the currency symbol precedes the value for a negative
;                          formatted monetary quantity
;                        0 If the currency symbol succeeds the value for a negative
;                          formatted monetary quantity
;              15 Return 1 If the currency symbol is separated by a space from the value for a
;                          negative formatted monetary quantity
;                        0 If the currency symbol is not separated by a space from the value for a
;                          negative formatted monetary quantity
;
;              16 Return for a nonnegative formatted monetary quantity
;                        0 If there are parentheses arround the quantity and currency symbol.
;                        1 If the sign string precedes the quantity and currency symbol.
;                        2 If the sign string succeeds the quantity and currency symbol.
;                        3 If the sign string immediately precedes the currency symbol.
;                        4 If the sign string immediately succeeds the  currency symbol.
;              17 Return for a negative formatted monetary quantity
;                        0 If there are parentheses arround the quantity and currency symbol.
;                        1 If the sign string precedes the quantity and currency symbol.
;                        2 If the sign string succeeds the quantity and currency symbol.
;                        3 If the sign string immediately precedes the currency symbol.
;                        4 If the sign string immediately succeeds the  currency symbol.
;              18 Return pointer to 0 terminated list separator
; Out:
;       R0 - Requested value.
ReadSymbols
        Push    "LR"

        ADR     R14,SymbolTable
        LDR     R0,[R14,R1,ASL #2]
        CMP     R0,#20
        ADDGE   R0,R0,R14

        Pull    "PC"

SymbolTable
        DCD     decimal_point           - SymbolTable
        DCD     thousands_sep           - SymbolTable
        DCD     grouping                - SymbolTable
        DCD     int_curr_symbol         - SymbolTable
        DCD     currency_symbol         - SymbolTable
        DCD     mon_decimal_point       - SymbolTable
        DCD     mon_thousands_sep       - SymbolTable
        DCD     mon_grouping            - SymbolTable
        DCD     positive_sign           - SymbolTable
        DCD     negative_sign           - SymbolTable
        DCD     int_frac_digits
        DCD     frac_digits
        DCD     p_cs_precedes
        DCD     p_sep_by_space
        DCD     n_cs_precedes
        DCD     n_sep_by_space
        DCD     p_sign_posn
        DCD     n_sign_posn
        DCD     list_symbol             - SymbolTable

decimal_point           DCB     "$Decimal",0
thousands_sep           DCB     "$Thousand",0
grouping                DCB     $Grouping
int_curr_symbol         DCB     "$IntCurr",0
currency_symbol         DCB     "$Currency",0
mon_decimal_point       DCB     "$MDecimal",0
mon_thousands_sep       DCB     "$MThousand",0
mon_grouping            DCB     $MGrouping
positive_sign           DCB     "$MPositive",0
negative_sign           DCB     "$MNegative",0
list_symbol             DCB     "$ListSymbol",0
        ALIGN

;---------------------------------------------------------------------------------
;ReadCalendarInformation
;
;In:
;   R1 = Pointer to 5 byte UTC time value.
;   R2 = Pointer to an 11 word buffer
;
;Out:
;
;   R1,R2 Preserved.
;
;   [R2]    = Number of first working day in the week.
;   [R2+4]  = Number of last working day in the week.
;   [R2+8]  = Number of months in the current year.
;                 (current = one in which given time falls)
;   [R2+12] = Number of days in the current month.
;
;   [R2+16] = Max length of AM/PM string.
;   [R2+20] = Max length of WE string.
;   [R2+24] = Max length of W3 string.
;   [R2+28] = Max length of DY string.
;   [R2+32] = Max length of ST string (May be 0).
;   [R2+36] = Max length of MO string.
;   [R2+40] = Max length of M3 string.
;   [R2+44] = Max length of TZ string.
;
GetCalendarInformation
        Push    "r0-r11,LR"

        ADR     LR,CalendarInfo
        LDMIA   LR,{R0,R3-R11,LR}       ; Load fixed 11 items
        STMIA   R2!,{R0,R3,R4}          ; First three
        STMIB   R2,{R5-R11,LR}          ; Skip one, then next 8

        BL      GetTimeValues
        BVS     %FT02
        ADRL    R0,MonthLengths
        LDRB    R0,[R0,R1]              ; Get length of month
        CMP     R1,#2                   ; Is Feb ?
        BNE     %FT01

        TST     R6, #3                  ; is year multiple of 4
        MOVNE   R0,#28                  ; no, then 29 Feb is bad
        BNE     %FT01

        TEQ     R6, #0                  ; is it a century year ?
        BNE     %FT01                   ; no, then 29 Feb is good

        TST     R5, #3                  ; is it a multiple of 400 ?
        MOVNE   R0,#28                  ; no, then 29 Feb is bad
01
        LDR     R2,[SP,#2*4]
        STR     R0,[R2,#12]
02
        STRVS   r0,[SP]
        Pull    "r0-r11,PC"

CalendarInfo
        DCD     FirstWorkDay    ; First working day in week 1=Sunday 7=Saturday
        DCD     LastWorkDay     ; Last  working day in week 1=Sunday 7=Saturday
        DCD     NumberOfMonths  ; Number of month in a year

        DCD     MaxAMPMLength   ; Max length of AM PM String
        DCD     MaxWELength     ; Max length of full day name
        DCD     MaxW3Length     ; Max length of short day name
        DCD     MaxDYLength     ; Max length of day in month
        DCD     MaxSTLength     ; Max length of st nd rd th ... string
        DCD     MaxMOLength     ; Max length of full month name.
        DCD     MaxM3Length     ; Max length of short month name.
        DCD     MaxTZLength     ; Max length of time zone name.

;---------------------------------------------------------------------------------
;NameToNumber
;
;In:
;   R1 = Pointer to territory name.
;
;Out:
;   R0 = 0 - Unknown territory
;        Else territory number.
NameToNumber     ROUT
        Entry   "r1-r7",8               ; We know tokens aren't long.

        BL      open_messages_file

; Enumerate all territory name tokens (TRnn)
        ADR     r0,message_file_block+4
        MOV     R4,#0                   ; First call
        ADR     R7,ToLowerTable

01
        ADR     R1,territory_token
        MOV     R2,SP
        MOV     R3,#8
        SWI     XMessageTrans_EnumerateTokens
        EXIT    VS
        CMP     R2,#0
        MOVEQ   r0,#0
        EXIT    EQ

; Get Message

        DebugS  xx,"Next token is ",R2
        MOV     R1,R2                   ; Token.
        MOV     R2,#0                   ; Don't copy message !
        SWI     XMessageTrans_Lookup
        EXIT    VS

; Got message, now compare with territory name in string.

        LDR     R1,[SP,#8]              ; get user R1
02
        LDRB    R14,[R2],#1
        CMP     R14,#10
        BEQ     %FT03                   ; End of message
        LDRB    R14,[R7,R14]            ; Lower case

        LDRB    R10,[R1],#1
        CMP     R10,#0
        MOVEQ   r0,#0
        EXIT    EQ
        LDRB    R10,[R7,R10]            ; Lower case

        CMP     R14,R10
        BEQ     %BT02                   ; Try next character.
        B       %BT01                   ; Try next month.
03
        LDRB    R10,[R1],#1
        CMP     R10,#" "
        BGE     %BT01                   ; Not end of user input !

        MOV     R0,#10                  ; Check token number
        ADD     R1,SP,#2
        SWI     XOS_ReadUnsigned
        MOVVC   R0,R2
        EXIT

territory_token
        DCB     "TR*",0
        ALIGN

        LNK     s.Tables


