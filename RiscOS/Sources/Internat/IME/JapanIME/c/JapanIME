/***************************************************************************************/
/* File: JapanIME                                                                      */
/* Purpose:                                                                            */
/*     Provides a Unicode interface to the VACS Compact VJE IME code                   */
/*                                                                                     */
/* Author:  Bob Pollard (mailto:bob@icontech.demon.co.uk)                              */
/* History:                                                                            */
/* Date       Name         Description                                                 */
/* ----       ----         -----------                                                 */
/* 08-Sep-98  RSP          ver 0.00 - Created.                                         */
/* 16-Sep-98  RSP          ver 0.00 - Sent to Acorn.                                   */
/* 17-Sep-98               updates for new VACS spec ver 0.01                          */
/*            RSP          - 6Kb size (from 2K) for learning buffer                    */
/*            RSP          - Map keys from extended Japanese keyboard to IME codes     */
/*            RSP          - Open_Dict redone to read file and pass RAM/ROM location,  */
/*                           rather than filename to VJE                               */
/*            RSP          - added explicit Close_Dict                                 */
/*            RSP          - testing configure option for setting number of candidate  */
/*                           selections before list shown                              */
/*            RSP          - Ctrl-key options done by look-up rather than case switch  */
/* 23-Sep-98               as a result of James Byrne input:                           */
/*            RSP          - PageUp/Down actions more important than Shift U/D arrows  */
/*            RSP          - Title for 'Code' converts now hex code value (as MS-IME)  */
/*            RSP          - Handle candidate list selections: 1..9, <Esc>, <PageUp>,  */
/*                           and <PageDown> explicitly                                 */
/*            RSP          - Get a full 'Cancel', even when candidate list showing     */
/*            RSP          - Set KeyClaimed flag correctly even if OnlyHotKeys set     */
/*            RSP          - Handle Pound, etc. which do not give a Sh-JIS single byte */
/*            RSP          - set 3 display area 'changes' flags using our own code     */
/* 24/25-Sep-98            spec changes, clarifications                                */
/*            RSP          - the module is now initialised to the 'off' state          */
/*            RSP          - extra return flag for just candidate selection changed    */
/*            RSP          - Common up returned candidate title and candidate buffers  */
/* 28/30-Sep-98            resolution of outstanding problems                          */
/*            RSP          - Test keyboard number and differentiate space, enter, etc. */
/* 30-Sep-98  RSP          ver 0.01 - Sent to Acorn.                                   */
/*            RSP          - Check for the IME on/off key on different keyboards       */
/*            RSP          - Some changes for handling the Kana lock in Eisuu mode     */
/*            KJB          - Set default JapanIME$Path in the module initialisation    */
/* 01-Oct-98  RSP          - Use cmhg generated header file                            */
/* 05-Oct-98               tidy up for release                                         */
/*            RSP          - Use MessageTrans for messages + rewrite error handler     */
/*            RSP          - Read and write learning buffer to NVRAM if possible       */
/* 06-Oct-98  RSP          - Link kana lock to VJE's Romanji lock - test lock on       */
/*                           module initialisation - monitor changes in lock state.    */
/* 07-Oct-98  RSP          - Keyboard lock state b5 only tested on Japanese keyboards  */
/*            RSP          - Fixed problems with title in code input mode              */
/* 08-Oct-98  RSP          - Convert <tab> key code to Ctrl-key range (&09)            */
/* 08-Oct-98  RSP          Version 0.02 - Sent to Acorn                                */
/*            KJB          - Input may be in current alphabet, not necessarily UTF-8   */
/*            KJB          - Icelandic on/off key is dagger                            */
/*            KJB          - Stopped VACS code doing block cursor                      */
/*            KJB          - Keys changed: Page Down=F_CNV_NBLK, Ctrl-Left=F_LLIM,     */
/*                           All Candidates=F_CNV_NBLK where appropriate,              */
/*                           Kanji Number=F_CODE. Also adjusted tilde and space.       */
/*                         - Use F_CHRK code for funny chars. Ignore them in RCNV and  */
/*                           CODE states. Removed DOPOUND define.                      */
/*                         - Fixed code that sets JapanIME$Path.                       */
/*                         - Initialise wDispListBox to 3, and code type to KUTEN      */
/* 09-Oct-98  RSP          - Tidied cases of setting Romanji lock into single function */
/* 09-Oct-98  RSP          - For safety, stop using grave as IME on/off on Russian k/b */
/* 12-Oct-98  RSP          - Include PRC_INPUT in All Candidates (F_CNV_NBLK) list     */
/* 13-Oct-98  RSP          - Test explicitly for 0x2020 in Iceland to allow char table */
/* 13-Oct-98  RSP          - Proper error numbers used                                 */
/* 13-Oct-98  RSP          - Save learning buffer on Standby and timer                 */
/* 14-Oct-98  RSP          - Added Home/End for F_LLIM/F_RLIM                          */
/* 14-Oct-98  RSP          - Added UpCall handler to trap keyboard lock changes and    */
/*                           removed code for polling the keyboard state               */
/* 15-Oct-98  RSP          - Optimised SWI distribution code                           */
/* 16-Oct-98  KJB          - Removed tilde/overline unification.                       */
/* 20-Oct-98  RSP          - Clear UTF8 in progress variable any character input       */
/* 22-Oct-98  RSP          - Fixed bug when BS, etc. with 'display' set is sucked in   */
/* 22-Oct-98  RSP          - Code for monitoring VJE result codes improved             */
/* 27-Oct-98  ADH          - JapanIME__Configure translates flags bits correctly now   */
/* 29-Oct-98  ADH          - Service_IME implemented                                   */
/* 30-Oct-98  KJB          - Funai want Space to always be Convert                     */
/***************************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "C:kernel.h"
#include "C:swis.h"
#include "common.h"
#include "VJE.h"
#include "basicedt.h"
#include "encoding.h"
#include "charsets.h"
#include "utf8.h"
#include "CModuleHdr.h"
#include "IntIME.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

/* SWI numbers - not in h.swis */
#define         NVRAM_Read       (0x4EE00)
#define         NVRAM_Write      (0x4EE01)

/* Service and UpCall numbers */
#define         Service_International 0x43
#define         Service_ShutDown      0x7E
#define         Service_Standby       0xAD
#define         UpCallV               0x1D
#define         UpCall_KeyboardStatus 20

/* bit in keyboard OSByte 202 representing inverse state of Kana Lock */
#define         ROMANLOCK              0x20

/* Sizes required for VJE areas - See VACS documentation */
#define         DSP_LEN          (80)
#define         MODE_LEN         (80)
#define         MB_LEN           (80)
#define         LB_LEN           (64 * 9)
#define         GAKU_SIZE        ((6 * 1024) - 3)

#if !defined FALSE
#define         FALSE            0
#endif
#if !defined TRUE
#define         TRUE             1
#endif
#define         PUCHAR unsigned char *

/* keyboard/country numbers */
#define         UK               1
#define         ICELAND          16
#define         JAPAN            32
#define         USA              48
#define         DvorakUK         70
#define         DvorakUSA        71
#define         ISO4             83

/* alphabet numbers */
#define         UTF8             111

/* Error numbers */
#define         ERR_Base         0x813210
#define         ERR_NoDict       0
#define         ERR_BadConfig    1
#define         ERR_NoCandidates 2
#define         ERR_BadCandidate 3
#define         ERR_CorruptDict  4
#define         ERR_Max          239
/* the max allows for numbers for other (non-shared) IME messages */

/* Returned error tags with default messages */
#define         ERR_NoDictMsg        "NoDict:Unable to open IME dictionary"
#define         ERR_BadConfigMsg     "Config:Unknown IME_Configure reason code"
#define         ERR_NoCandidatesMsg  "NoCand:No IME candidate list"
#define         ERR_BadCandidateMsg  "BadCand:Bad IME candidate list number"
#define         ERR_CorruptDictMsg   "BadDict:Bad IME dictionary"

/* Built in paths to resources and NVRAM */
#define         JapanIME_DefaultPath "Resources:$.Resources.JapanIME."
#define         JapanIME_Path        "JapanIME$Path"
#define         JapanIME_Dict        "JapanIME:Dictionary"
#define         JapanIME_Messages    "JapanIME:Messages"
#define         JapanIME_MemTag      "IMEMemory"

/* Name of dynamic area for holding dictionary - not worth translating as the dictionary should   */
/* normally be held in Resources: - so the dynamic area will only be used in testing              */
#define         JapanIME_DynamicArea "JapanIME dictionary"

/* delay between saves of the learning buffer */
#define         MINSDELAY 30

#define         BOTHFLAGS (EISUU_BIT | SCREEN_MODE)

/* Do we treat Space as Convert or Space on a Japanese keyboard? */
#define         SPACE_ALWAYS_CONVERTS

/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

#if ROMDIC
void *JapanIME_Dic_Address;   /* 21-Sep-98 used to tell VJE the location of dictionary in RAM/ROM */
#endif

/* -------------------------------------- STATIC VARIABLES -------------------------------------- */

static int      JapanIME_MsgFile[5] = {0, 0, 0, 0, 0};
                                       /* flag plus 4 words of file descriptor */
static char     JapanIME_Msgs[] = JapanIME_Messages;

static UCHAR    JapanIME_ChResult[DSP_LEN * 2 + 1];
static UCHAR    JapanIME_ChDisplay[DSP_LEN * 2 + 1];
static UCHAR    JapanIME_AttrDisplay[DSP_LEN * 2 + 1];
static UCHAR    JapanIME_ChMode[MODE_LEN + 1];
static UCHAR    JapanIME_AttrMode[MODE_LEN + 1];
static UCHAR    JapanIME_MBTitle[DSP_LEN + 1];
static UCHAR    JapanIME_MBText[MB_LEN * 2 + 1];
static UCHAR    JapanIME_LBTitle[DSP_LEN + 1];
static UCHAR    JapanIME_LBList[LB_LEN + 1];

/* converted 'output' buffers */
static char     JapanIME_UTF8output[DSP_LEN * 6 + 1];
static char     JapanIME_UTF8display[DSP_LEN * 6 + 1];
static char     JapanIME_attributes[DSP_LEN + 1];
static char     JapanIME_UTF8candidate[(LB_LEN / 9) * 6 + 1];

static BDATA    JapanIME_Bdata;

static UCHAR    JapanIME_SramData[GAKU_SIZE + 3];

static char     JapanIME_UTF8input[8];
static int      JapanIME_UTF8index;
static int      JapanIME_LastCaret;
static int      JapanIME_LastAttrLen;
static int      JapanIME_DictOpen;  /* initialised to 0; 1 if in ROM; -1 if in dynamic area */
static int      JapanIME_DynAreaNumber;
static unsigned JapanIME_KeyboardNumber;
static unsigned JapanIME_AlphabetNumber;
static int      JapanIME_KanaLockSave;
static int      JapanIME_LastResult;
static int      JapanIME_NVRAMsize;      /* amount of NVRAM storage allocated to IME */
static int      JapanIME_NVRAMsum;
static int      JapanIME_NVRAMsavetime;  /* set by interval timer when a NVRAM backup is due */
static int      JapanIME_ModeSave;       /* set by upcall handler to new state of Kana Lock  */
static int      JapanIME_UpCalled;
static Encoding *JapanIME_Enc;

static char JapanIME_KanaLookup[192] = {
// Hiragana
/*    0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f */
/* 304x */
   0x00, 0xa7, 0xb1, 0xa8, 0xb2, 0xa9, 0xb3, 0xaa, 0xb4, 0xab, 0xb5, 0xb6, 0x00, 0xb7, 0x00, 0xb8,
/* 305x */
   0x00, 0xb9, 0x00, 0xba, 0x00, 0xbb, 0x00, 0xbc, 0x00, 0xbd, 0x00, 0xbe, 0x00, 0xbf, 0x00, 0xc0,
/* 306x */
   0x00, 0xc1, 0x00, 0xaf, 0xc2, 0x00, 0xc3, 0x00, 0xc4, 0x00, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca,
/* 307x */
   0x00, 0x00, 0xcb, 0x00, 0x00, 0xcc, 0x00, 0x00, 0xcd, 0x00, 0x00, 0xce, 0x00, 0x00, 0xcf, 0xd0,
/* 308x */
   0xd1, 0xd2, 0xd3, 0xac, 0xd4, 0xad, 0xd5, 0xae, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0x00, 0xdc,
/* 309x */
   0x00, 0x00, 0xa6, 0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0xdf, 0x00, 0x00, 0x00, 0x00, 0x00,
// Katakana
/* 30ax */
   0x00, 0xa7, 0xb1, 0xa8, 0xb2, 0xa9, 0xb3, 0xaa, 0xb4, 0xab, 0xb5, 0xb6, 0x00, 0xb7, 0x00, 0xb8,
/* 30bx */
   0x00, 0xb9, 0x00, 0xba, 0x00, 0xbb, 0x00, 0xbc, 0x00, 0xbd, 0x00, 0xbe, 0x00, 0xbf, 0x00, 0xc0,
/* 30cx */
   0x00, 0xc1, 0x00, 0xaf, 0xc2, 0x00, 0xc3, 0x00, 0xc4, 0x00, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca,
/* 30dx */
   0x00, 0x00, 0xcb, 0x00, 0x00, 0xcc, 0x00, 0x00, 0xcd, 0x00, 0x00, 0xce, 0x00, 0x00, 0xcf, 0xd0,
/* 30ex */
   0xd1, 0xd2, 0xd3, 0xac, 0xd4, 0xad, 0xd5, 0xae, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0x00, 0xdc,
/* 30fx */
   0x00, 0x00, 0xa6, 0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa5, 0xb0, 0x00, 0x00, 0x00,
};


/* keys marked with # are those defined in VACS spec for the extended Japanese keyboard layout    */
static char JapanIME_CtrlLookup[] = {
  F_CTRL,         // Cntl-@/NULL
  F_LLIM,         // Cntl-A             # after convert
  F_CTRL,         // Cntl-B
  F_CNV,          // Cntl-C             # after input
  F_RIGHT,        // Cntl-D             # after input
  F_CNV_BBLK,     // Cntl-E             # after input
  F_RLIM,         // Cntl-F             # after convert
  F_DEL,          // Cntl-G             # after input
  F_BS,           // Cntl-H / BackSpace # after input
  F_CTRL,         // Cntl-I
  F_HIRA_CNV,     // Cntl-J             # after input
  F_KATA_CNV,     // Cntl-K             # after input
  F_ZEN_CNV,      // Cntl-L             # after input
  F_NO_CNV2,      // Cntl-M / Enter     # after input
  F_CTRL,         // Cntl-N
  F_HAN_CNV,      // Cntl-O             # after input
  F_CTRL,         // Cntl-P
  F_CNV_BUNS,     // Cntl-Q             # after convert
  F_CTRL,         // Cntl-R
  F_LEFT,         // Cntl-S             # after input
  F_CTRL,         // Cntl-T
  F_CTRL,         // Cntl-U
  F_CTRL,         // Cntl-V
  F_CNV_BUNL,     // Cntl-W             # after convert
  F_CNV_NBLK,     // Cntl-X             # after input
  F_CANALL,       // Cntl-Y             # after input
  F_CNV_BCNV,     // Cntl-Z             # after input
  F_CANCEL,       // Cntl-[ / Esc       # after input
  F_CTRL,         // (0x1c)
  F_CTRL,         // (0x1d)
  F_LLIM,         // Home
  F_CTRL,         // (0x1f)
};

/* a look-up table giving the Alt-key code for the top right IME on/off key for each keyboard.    */
/* 0 means either the keyboard is not supported or Alt key does not produce a key code            */
static unsigned char JapanIME_KbdLookup[] = {
  0x0,   // Default
  0xa6,  // UK
  0x0,
  0x0,
  0xac,  // Italy
  0x5c,  // Spain
  0xac,  // France
  0xac,  // Germany
  0xa6,  // Portugal
  0xa6,  // Esperanto
  0x5c,  // Greece
  0x0,   // Sweden
  0x0,   // Finland
  0x0,
  0xac,  // Denmark
  0xa6,  // Norway
  0x0,   // Iceland test explicitly for 0x2020 below to allow char table
  0xa6,  // Canada 1
  0xa6,  // Canada 2
  0xa6,  // Canada
  0x0,   // Turkey
  0x0,
  0x0,
  0x0,
  0x0,   // Russia
  0x0,
  0xac,  // Israel
  0xa6,  // Mexico
  0xac,  // LatinAm
  0xa6,  // Australia
  0xa6,  // Austria
  0x0,   // Belgium
  0x0,   // Japan test done in F-key section
  0xa6,  // MiddleEast
  0xac,  // Netherlands
  0x0,   // Switzerland
  0xa6,  // Wales
  0x0,
  0x0,
  0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  // 40 - 47
  0xac,  // USA
  0xa6,  // Wales2
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  // 50 - 59
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  // 60 - 69
  0xa6,  // DvorakUK
  0xac,  // DvorakUSA
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  // 72 -79
  0xa6,  // ISO1
  0x0,
  0x0,
  0x0    // ISO4
};

static char JapanIME_AttrMap[] = {
0x00, 0x01, 0x01, 0x03, 0x02, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00 };

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/* ----------------------------------------------------------------------- JapanIME__OpenMessages */
static void JapanIME__OpenMessages()
{
  /* Initialise the message file in JapanIME:Messages */
  if (JapanIME_MsgFile[0] == 0)
  {
    _kernel_oserror *err;

    err = _swix(MessageTrans_OpenFile, _INR(0,2), JapanIME_MsgFile + 1, JapanIME_Msgs, 0);
    if (err == NULL)
      JapanIME_MsgFile[0] = 1;
  }
}

/* ------------------------------------------------------------------------------ JapanIME__Fault */
static _kernel_oserror *JapanIME__Fault(int errnum, char *tag)
{
  /* errnum:  is error number before the error base has been added;              */
  /* tag:     is a string suitable for passing to MessageTrans to look up        */
  /* returns: pointer to MessageTrans buffer containing the error number/message */

  _kernel_oserror err_buffer;

  err_buffer.errnum = errnum + ERR_Base;
  strcpy(err_buffer.errmess, tag);

  JapanIME__OpenMessages();       /* in case closed? */

  /* translate error message, which because ErrorLookup sets V, is returned as the _swix result   */
  return _swix(MessageTrans_ErrorLookup,
               _INR(0,2) | _INR(4,7), &err_buffer,
               JapanIME_MsgFile[0] ? JapanIME_MsgFile + 1 : 0,
               0, Module_Title /* %0 if needed */, 0, 0, 0);
}

/* --------------------------------------------------------------------------- JapanIME__CheckSum */
static int JapanIME__CheckSum()
{
  /* return checksum for the learning buffer - so not saved unnecessarily */
  int CRC;

  _swix(OS_CRC, _INR(0, 3) | _OUT(0),
            0, JapanIME_SramData, JapanIME_SramData + GAKU_SIZE + 3, 4, &CRC);
  return CRC;
}

/* ------------------------------------------------------------------------ JapanIME__SaveToNVRAM */
static _kernel_oserror *JapanIME__SaveToNVRAM(int closing)
{
  /* Backup the learning buffer to NVRAM (unless checksum has not changed since last load/save).  */
  /* closing - if non-zero, force a save, regardless of checksum                                  */
  int oldChecksum = JapanIME_NVRAMsum;

  JapanIME_NVRAMsavetime = 0;
  if (!closing && (JapanIME_NVRAMsum = JapanIME__CheckSum()) == oldChecksum)
   return NULL;

  return _swix(NVRAM_Write, _INR(0,2), JapanIME_MemTag, JapanIME_Bdata.lpchSramAddress,
                                JapanIME_Bdata.wSramMaxSize);
}

/* ------------------------------------------------------------------------- JapanIME__ProcessUCS */
static int JapanIME__ProcessUCS(void *handle, UCS4 code)
{
  /* this hook is called for each UCS character; it appends the corresponding UTF-8 code */
  /* on to the end of the buffer, whose address is passed via the handle parameter       */

  *((char **)handle) = UCS4_to_UTF8(*((char **)handle), code);
  return 0;
}


/* -------------------------------------------------------------------------- JapanIME__CvtToUTF8 */
static int JapanIME__CvtToUTF8(char *s, int n, char *op)
{
  /* convert a Shift-JIS string, length n to UTF-8 */
  /* return converted length                       */
  char *currPos = op;

  if (JapanIME_Enc == NULL)
    JapanIME_Enc = encoding_new(csShiftJIS, encoding_READ);

  encoding_read(JapanIME_Enc, JapanIME__ProcessUCS, s, n, &currPos);
  *currPos = 0;
  return currPos - op;
}

/* ---------------------------------------------------------------------------  JapanIME__CvtAttr */
static int JapanIME__CvtAttr(char *op, int *cursorPos)
{
  /* converts the attribute list in Bdata to our format (1 byte per character) and returns the    */
  /* caret position. It scans through the ShiftJis codes to identify each character, and copies   */
  /* the first attribute byte to 'op'                                                             */

  char *attr = (char *)JapanIME_Bdata.lpattrDisplay;
  char *src = (char *)JapanIME_Bdata.lpchDisplay;
  char *srcEnd = src + JapanIME_Bdata.cchDisplay;
  char *opStart = op;
  int   cursor = -1;

  for ( ; src < srcEnd; )
  {
    /* When processing Shift-JIS, 0xa0 can be a half-width space (1-byte), and 0xf0-0xfc can be   */
    /* user-defined (2-byte) codes. 0xfd-0xff are are not defined and assumed to be 2-byte codes. */
    /* Others are 1-byte, except 0x81 to 0x9f, which are 2-bytes long.                            */

    int ch;

    if (JapanIME_Bdata.cchCurPosition == src - (char *)JapanIME_Bdata.lpchDisplay)
      cursor = op - opStart;                     /* the cursor position matches the source offset */

    ch = *(src++);
    *(op++) = JapanIME_AttrMap[*(attr++)];         /* copy the attr byte for first byte to output */

    if (ch >= 0x81 && (ch < 0xa0 || ch >= 0xe0))
    {
      src++;                                                /* it is a 2-byte code, skip 2nd byte */
      attr++;                                               /* and skip over its attr byte too    */
    }
  }

  if (JapanIME_Bdata.cchCurPosition == src - (char *)JapanIME_Bdata.lpchDisplay)
    cursor = op - opStart;                /* the cursor is at the end */

  *op = 0;
  *cursorPos = (JapanIME_Bdata.cchCurAttr ? cursor : -1);
  return op - opStart;                                       /* return the number of bytes needed */
}

/* ---------------------------------------------------------------------------- JapanIME__PutVkey */
static int JapanIME__PutVkey(int key)
{
  /* input: key - a VJE virtual key code                            */
  /* return: one of VJE codes, -1 error; 0 eaten; 1 ignored; 2 exit */
  /* function: passes the supplied virtual code to VJE to action    */

  JapanIME_Bdata.wVkey = key;
  return BasicEdit(&JapanIME_Bdata);
}

/* ------------------------------------------------------------------- JapanIME__CheckRomanjiLock */
static void JapanIME__CheckRomanjiLock()
{
  /* If ModeSave is set, indicating a change to the Non-Roman bit, set wVjeModeFlag accordingly   */
  int lockState = JapanIME_ModeSave;

  JapanIME_ModeSave = -1;
  if (lockState >= 0)
  {
    if (lockState)
      JapanIME_Bdata.wVjeModeFlag &= ~NONROMAN_BIT;         /* clear to match */
    else
      JapanIME_Bdata.wVjeModeFlag |= NONROMAN_BIT;          /* set to match */
  }
}

#if 0
/* --------------------------------------------------------------------- JapanIME__SetRomanjiLock */
static int JapanIME__SetRomanjiLock(int modeFlags, int lockState)
{
  /* input: modeFlags is new state of VjeModeFlag                */
  /*        lockState is new lock state to be applied            */
  /* returns update flags which may be set as a result of        */
  /*        SET_MODE - to be Or-ed into with main update changes */

  JapanIME_ModeSave = -1;
  if (lockState >= 0)
  {
    if (lockState)
      modeFlags &= ~NONROMAN_BIT;         /* clear to match */
    else
      modeFlags |= NONROMAN_BIT;          /* set to match */
  }
  if (modeFlags != JapanIME_Bdata.wVjeModeFlag)
  {
    /* Notify VJE of state changes - and see if any fields (e.g. input indicator) need updating   */
    JapanIME_Bdata.wVjeModeFlag = modeFlags;
    JapanIME__PutVkey(F_SET_MODE);
    return JapanIME_Bdata.wDataUpdate;
  }
  return 0;
}

/* ----------------------------------------------------------------------- JapanIME__SyncKanaLock */
static int JapanIME__SyncKanaLock()
{
  /* called to ensure that the Romanji lock is consistent with the Keyboard's kana lock           */
  /* returns update flags set as a result of SET_MODE - to be Or-ed into with main update changes */

  if (JapanIME_KeyboardNumber == JAPAN)
  {
    int lockState = _kernel_osbyte(202, 0, 0xff) & ROMANLOCK;
    int modeFlags = JapanIME_Bdata.wVjeModeFlag;

    if (lockState == 0 && (modeFlags & BOTHFLAGS) == BOTHFLAGS)
    {
      /* The kana lock has somehow been turned on in Eisuu input mode - a converted character has */
      /* already arrived, so the only course of action that makes any sense is turn Eisuu off     */
      modeFlags &= ~EISUU_BIT;                                          /* set to kana input mode */
    }
    return JapanIME__SetRomanjiLock(modeFlags, lockState);
  }
  return 0;
}
#endif

/* ------------------------------------------------------------------------ JapanIME__SetKanaLock */
static int JapanIME__SetKanaLock(int state)
{
  /* Can be called:- When, eg, Ctrl-F3 entered from the keyboard     */
  /*                 The bit is changed by Configure                 */
  /*                 Both Eisuu and IME set with lock set            */
  /*                 Eisuu or IME is exited with a saved lock        */
  /* state = ROMANLOCK to turn the Kana lock off, 0 to turn on       */
  /* return ROMANLOCK if Latin entry; 0 if Kana lock is set on entry */
  /* should only be called if keyboard supports kana lock            */
  /* Cheat a little - don't bother to check for fail ...             */
  /* ... code below will return ROMANLOCK in such cases              */
  int oldState;

  JapanIME_UpCalled = 0;
  oldState = _kernel_osbyte(202, state, 0xff ^ ROMANLOCK) & ROMANLOCK;   /* write keyboard status */

  if (oldState != state && JapanIME_UpCalled == 0)   /* state change requested but no upcall made */
  {
    /* if eisuu state established, rather than just switching to it (when KanaLockSave < 0)       */
    /* just reset our internal flag showing what the state should be when we leave eisuu state    */
    if ((JapanIME_Bdata.wVjeModeFlag & BOTHFLAGS) == BOTHFLAGS && JapanIME_KanaLockSave >= 0)
    {
      JapanIME_KanaLockSave ^= ROMANLOCK;                /* Flip our saved state of the kana lock */
      _kernel_osbyte(202, oldState, 0xff ^ ROMANLOCK);             /* restore to original setting */
    }
    else
      JapanIME_ModeSave = state;
  }
  return oldState;
}

/* ---------------------------------------------------------------------- JapanIME__CheckIMEState */
static int JapanIME__CheckIMEState(int oldState)
{
  /* called every time there is a potential state change, passing the old state */

  /* If input mode switched to EISUU or VJE turned on with EISUU set, unset the Kana Lock */
  if (JapanIME_KeyboardNumber == JAPAN)
  {
    int newState = JapanIME_Bdata.wVjeModeFlag;
    int changeStates = newState ^ oldState;

    if ((changeStates & BOTHFLAGS) != 0)                /* one or both(?) changed */
    {
      if ((newState & BOTHFLAGS) == BOTHFLAGS)
      {
        /* EISUU and VJE are now both on, (while at least one was off before)                     */
        JapanIME_KanaLockSave = -1;                               /* force the kana lock off      */
        JapanIME_KanaLockSave = JapanIME__SetKanaLock(ROMANLOCK); /* turn off and save lock state */
      }
      else if (((oldState & SCREEN_MODE) != 0 && (newState & BOTHFLAGS) == EISUU_BIT) ||
               ((oldState & EISUU_BIT) != 0 && (newState & BOTHFLAGS) == SCREEN_MODE))
      {
        /* Either VJE turned off while EISUU was on, or EISUU turned off while VJE was on         */
        JapanIME__SetKanaLock(JapanIME_KanaLockSave);                      /* restore saved state */
      }
    }
  }
  JapanIME__CheckRomanjiLock();
  if (oldState != JapanIME_Bdata.wVjeModeFlag)
  {
    /* Notify VJE of state changes - and see if any fields (e.g. input indicator) need updating   */
    JapanIME__PutVkey(F_SET_MODE);
    return JapanIME_Bdata.wDataUpdate;
  }
  return 0;
}

/* --------------------------------------------------------------------------- JapanIME__CheckCNV */
static int JapanIME__CheckCNV()
{
  /* F_CNV should only be passed 'after input character' otherwise VJE inserts a space */

  return ((JapanIME_Bdata.wMainStage & PRC_EMP) != 0 ? F_CTRL : F_CNV);
}

/* -------------------------------------------------------------------------- JapanIME__CloseDict */
static void JapanIME__CloseDict()
{
#if ROMDIC
  int openState = JapanIME_DictOpen;
#endif

  JapanIME_DictOpen = 0;
#if ROMDIC
  if (openState < 0)                              /* dictionary is already open in a dynamic area */
    _swix(OS_DynamicArea, _IN(0) | _IN(1), 1, JapanIME_DynAreaNumber);
#endif
}

/* --------------------------------------------------------------------------- JapanIME__OpenDict */
static _kernel_oserror *JapanIME__OpenDict(char *dictName)
{
  /* redone 21-Sep-98 used to tell VJE the location of dictionary in RAM/ROM */
  /* Called at initialisation and when the dictionary name is changed        */
#if ROMDIC
  _kernel_oserror *e;
  int ftype;           // file type
  int flen;            // file length
  int fh;              // file handle
  int inthandle;
  int filesys;

  if (dictName == NULL ||
      _swix(OS_File, _INR(0,1)|_OUT(0)|_OUT(4), 23, dictName, &ftype, &flen) != NULL ||
      (ftype & 1) == 0)                                /* not a file/image file */
    return JapanIME__Fault(ERR_NoDict, ERR_NoDictMsg);

  /* Open the file for input */
  e = _swix(OS_Find, _INR(0,1)|_OUT(0), 0x4F, dictName, &fh);

  /* Obtain the filing system number and internal handle */
  if (e == NULL)
  {
    e = _swix(OS_FSControl, _INR(0,1)|_OUTR(1,2), 21, fh, &inthandle, &filesys);

    /* Close the file */
    _swix(OS_Find, _INR(0,1), 0, fh);
    /* return e if an error after closing file */

    if (e == NULL)
    {
      /* in case already open in a dynamic area ... */
      JapanIME__CloseDict();

      /* If it's ResourceFS, return a direct pointer */
      if ((filesys & 0xFF) == 46)
      {
        JapanIME_Dic_Address = (void *)inthandle;
        JapanIME_DictOpen = 1;
      }
      else
      {
        e = _swix(OS_DynamicArea, _INR(0,8)|_OUT(1)|_OUT(3), 0, -1, flen, -1,
                   0x80 /* do not allow task window bar drag */, flen, 0, 0,
                   (int)JapanIME_DynamicArea, &JapanIME_DynAreaNumber, &JapanIME_Dic_Address);
        if (e == NULL)
        {
          e = _swix(OS_File, _INR(0,3), 16, dictName, JapanIME_Dic_Address, 0);
          if (e)
            JapanIME__CloseDict();
          else
            JapanIME_DictOpen = -1;           /* dynamic area needs to be freed on re-select dict */
        }
      }
    }
  }
  if (e)
    return e;

  JapanIME_Bdata.lpchDicName = (PCH)0;
#else
  JapanIME_Bdata.lpchDicName = (PCH)dictName;
#endif

  if (JapanIME__PutVkey(F_OPEN) == RC_ERROR)
    return JapanIME__Fault(ERR_CorruptDict, ERR_CorruptDictMsg);
  return NULL;
}

/* --------------------------------------------------------------------- JapanIME__DoProcessInput */
static _kernel_oserror *JapanIME__DoProcessInput(int cancel, _kernel_swi_regs *r)
{
  /* Main key conversion routine. Entered from ProcessInput, and Cancel (when cancel is set).     */
  /* The registers parameter (r) contains the input and output parameters from the conversion.    */

  int inFlags = r->r[0];
  UCS4 rawKey = r->r[1];        /* make a copy before clearing regs - not used in the cancel case */
  int wVkey;
  int ret;
  int IMEstate;
  int oldIMEstate;
  int changes;                       /* update flags set as a result of kana lock synchronisation */

  if (!JapanIME_DictOpen)
    JapanIME__OpenDict(JapanIME_Dict);

  memset(r, 0, 20);                                          /* initialise to 'not handled' state */
  JapanIME_LastResult = -2;                                     /* will be reset if passed to VJE */

  oldIMEstate = JapanIME_Bdata.wVjeModeFlag;
  changes     = JapanIME__CheckIMEState(JapanIME_Bdata.wVjeModeFlag);

  /* Issue Service_IME 0 (flags changed) if required */
  if (JapanIME_Bdata.wVjeModeFlag != oldIMEstate)
  {
    _swix(OS_ServiceCall,
          _INR(1,5),

          Service_IME,
          IME_Serv_NewFlags,
          oldIMEstate,
          JapanIME_Bdata.wVjeModeFlag,
          IME_Serv_NewFlags_Key);
  }

#if 0
  changes |= JapanIME__SyncKanaLock();         /* check keyboard's Kana lock matches NONROMAN_BIT */
#endif

  if (cancel)
  {
    wVkey = F_NO_CNV2;     /* 23-Sep-98 use CNV2 for cancel; return what is in the display string */
  }
  else
  {
    if ((inFlags & IME_UCSinput) == 0)                              /* need to convert from UTF-8 */
    {
      /* Code is in the current alphabet - either an 8-bit one, or UTF-8. */
      JapanIME_AlphabetNumber = _kernel_osbyte(71, 127, 0) & 0xFF;
      if (JapanIME_AlphabetNumber == UTF8)
      {
        /* inCode may be just part of a character. We need to buffer up until a complete          */
        /* character has been assembled, and convert it to a UCS value. While an incomplete UTF-8 */
        /* buffer exists return an 'key claimed' result to the caller                             */

        if (rawKey < 0x80)
        {
          /* trivial convert to UCS :-) */
        }
        else if (rawKey >= 0x100)             /* not a UTF8 code, so must be a Function key, etc. */
        {
          rawKey = 0x80000000 + rawKey - 0x100;
        }
        else if (JapanIME_UTF8index == 0 && (rawKey & 0xC0) == 0x80) /* leading continuation byte */
          return NULL;
        else
        {
          if (JapanIME_UTF8index > 0 && (rawKey & 0xC0) != 0x80)      /* start byte in the middle */
            JapanIME_UTF8index = 0;

          if (JapanIME_UTF8index > 6)
            return NULL;            /* UTF8_to_UCS4 is misbehaving? do this until next start code */

          JapanIME_UTF8input[JapanIME_UTF8index++] = rawKey;
          JapanIME_UTF8input[JapanIME_UTF8index] = 0;

          if (UTF8_to_UCS4(JapanIME_UTF8input, &rawKey) == 1)       /* returns 1 if not ready yet */
          {
            r->r[0] = IME_KeyClaimed;
            return NULL;                             /* claimed, but we are not processing it yet */
          }
        }
      }
      else
      {
        if (rawKey >= 0x100)                                   /* function keys are function keys */
        {
          rawKey = 0x80000000 + rawKey - 0x100;
        }
        else
        {
          int unclaimed = 1;                       /* get a UCS table using Service_International */
          const unsigned int *alphabet_table;

          if (_swix(OS_ServiceCall, _INR(1,3)|_OUT(1)|_OUT(4), 0x43, 8, JapanIME_AlphabetNumber,
                                     &unclaimed, &alphabet_table) == NULL && !unclaimed)
          {
            rawKey = alphabet_table[rawKey];      /* use the table, otherwise assume direct codes */
          }
        }
      }
    }
    JapanIME_UTF8index = 0;                               /* clear ready for next input character */

    /* we now have the UCS code from the 'keyboard': convert it to a Compact VJE virtual key.     */

    wVkey = F_CHR;
    if (rawKey <= 31)                                                    /******* Ctrl keys *******/
    {
      if (rawKey == 3)  // Ctrl-C
        wVkey = JapanIME__CheckCNV();
      else if (rawKey == 27 && (inFlags & IME_ListSelection) != 0)        /* Close list selection */
        wVkey = F_NO_CNV;
      else if (rawKey == 0x0d && JapanIME_KeyboardNumber != JAPAN)       /* Enter on 101 keyboard */
        wVkey = F_NO_CNV;
      else
        wVkey = JapanIME_CtrlLookup[rawKey];

      /* passing F_CTRL to VJE causes it to return 'not handled', but set wDataUpdate, so return  */
      if (wVkey == F_CTRL)
        return NULL;
    }
    else if (rawKey == ' ')                                               /******** <Space> *******/
    {
#ifndef SPACE_ALWAYS_CONVERTS
      if (JapanIME_KeyboardNumber != JAPAN)
#endif
        wVkey = F_CNV;
    }
    else if ((rawKey & 0x80000000) != 0)
    {
      switch (rawKey & 0x7fffffff)                               /****** Function keys, etc. ******/
      {
        case 0x85:        // F5 # after input
          wVkey = F_CODE;
          break;
        case 0x86:        // F6 # after input
          wVkey = F_HIRA_CNV;
          break;
        case 0x87:        // F7 # after input
          wVkey = F_KATA_CNV;
          break;
        case 0x88:        // F8 # after input
          wVkey = F_ZEN_CNV;
          break;
        case 0x89:        // F9 # after input
          wVkey = F_HAN_CNV;
          break;
        case 0xA3:        // Ctrl-F3 #
          if (JapanIME_KeyboardNumber != JAPAN)        /* cannot use kana lock on non-Japanese kb */
            return NULL;
          wVkey = F_ROM;
          break;
        case 0xA5:        // Ctrl-F5 # before input
          wVkey = F_CODE_CNT;
          break;
        case 0xA6:        // Ctrl-F6 #
          wVkey = F_HIRA;
          break;
        case 0xA7:        // Ctrl-F7 #
          wVkey = F_KATA;
          break;
        case 0xA8:        // Ctrl-F8 #
          wVkey = F_EISUU;
          break;
        case 0xA9:        // Ctrl-F9 #
          wVkey = F_ZEN;
          break;
        case 0xEC:        // Ctrl-F12 # before input
          wVkey = F_DMODE;
          break;
        case 0x8C:        // normal Left # after input
          wVkey = F_LEFT;
          break;
        case 0x8D:        // normal Right # after input
          wVkey = F_RIGHT;
          break;
        case 0x8F:        // normal Up # after input
          wVkey = F_CNV_BCNV;
          break;
        case 0x9C:        // Shift-Left # after convert
          wVkey = F_CNV_BUNS;
          break;
        case 0x9D:        // Shift-Right # after convert
          wVkey = F_CNV_BUNL;
          break;
        case 0xAC:        // Ctrl-Left
          wVkey = F_LLIM;
          break;
        case 0xAD:        // Ctrl-Right
        case 0x8B:        // Copy/End key
          wVkey = F_RLIM;
          break;
        case 0x9E:        // PageDown (also Shift-Down!) # after convert
          wVkey = F_CNV_NBLK;
          break;
        case 0x9F:        // PageUp (also Shift-Up!) # after convert
          wVkey = F_CNV_BBLK;
          break;
        case 0xc2:        // Zen/han toggle
        case 0xd2:        // Shift-Zen/han toggle
          wVkey = F_ZEN;
          break;
        case 0xc3:        // Active toggle (on the Alt-topleft key) #
          wVkey = F_SCRN;
          break;
        case 0xc4:        // Eisuu (Roman)
          wVkey = F_EISUU;
          break;
        case 0xc5:        // Muhenkan (non-convert) - need to test wMainStage
        case 0xd5:        // and Shift-Muhenkan
          if ((JapanIME_Bdata.wMainStage & PRC_EMP) != 0)
            wVkey = F_UNDO;         // before input #
          else
            wVkey = F_NO_CNV;       // after input #
          break;
        case 0xc7:        // Kana (Hiragana)
          wVkey = F_HIRA;
          break;
        case 0xd6:        // Shift-Henkan (Previous convert) # after input
          wVkey = F_CNV_BCNV;
          break;
        case 0xd7:        // Shift-Kana (Katakana)
          wVkey = F_KATA;
          break;
        case 0x8A:        // Tab
          wVkey = F_CTRL;
          rawKey = 0x09;
          break;
        case 0xC9:        // Kanji Number
          wVkey = F_CODE;
          break;
        case 0xD9:        // Shift-Kanji Number
          wVkey = F_CODE_CNT;
          break;        case 0x8E:        // normal Down # after input
        case 0xc6:        // Henkan (Next convert) # after input
          wVkey = JapanIME__CheckCNV();
          if (wVkey == F_CNV)
            break;
          // else if wMainStage | PRC_EMP, return unprocessed
        case 0xC8:        // All Candidates
          if (JapanIME_Bdata.wMainStage & (PRC_INPUT | PRC_CNV | PRC_RCNV))
          {
            wVkey = F_CNV_NBLK; // brings up candidate list in CNV and RCNV states
            break;
          }
          // else return (NULL)

      /* ---- return the following 'function keys' unhandled
        case 0x80:        // F0/Print
        case 0x81:        // F1
        case 0x82:        // F2
        case 0x83:        // F3
        case 0x84:        // F4
        case 0xCA:        // F10
        case 0xCB:        // F11
        case 0xCC:        // F12
        case 0xA0:        // Ctrl-F0/Print
        case 0xA1:        // Ctrl-F1
        case 0xA2:        // Ctrl-F2
        case 0xA4:        // Ctrl-F4
        case 0xEA:        // Ctrl-F10
        case 0xEB:        // Ctrl-F11
        case 0x9A:        // Shift-Tab
        case 0x9B:        // Shift-Copy
        ------------------------------------- end of unprocessed f-keys */
        default:
          return NULL;                                             /* return with key not handled */
      }
    }
    else if (JapanIME_KeyboardNumber <= ISO4 &&
             rawKey == JapanIME_KbdLookup[JapanIME_KeyboardNumber])  /****** IME on/off key? ******/
      wVkey = F_SCRN;
    else if (rawKey >= 0x7f)                                     /***** 'Top bit' characters ******/
    {
      if (rawKey == 0x7f)                                                /* DEL key # after input */
        wVkey = F_DEL;
      else if (rawKey == 0x2020 && JapanIME_KeyboardNumber == ICELAND) /* Iceland IME on/off key? */
        wVkey = F_SCRN;
      else if (rawKey >= 0x3000 && rawKey < 0x3100)       /* Row 30: Punct, Hiragana and Katakana */
      {
        if (rawKey >= 0x3040)      /* convert Hiragana and Katakana to half-width Shift-JIS codes */
        {
          int newKey = JapanIME_KanaLookup[rawKey - 0x3040];

          if (newKey == 0)
            wVkey = -1;                     /* 'illegal' range as far as Compact-VJE is concerned */
          else
            rawKey = newKey;            /* Compact VJE can handle it by mapping to a h/w katakana */
        }
        /* deal with punctuation in Row 30 on an ad-hoc basis */
        else if (rawKey == 0x3000)        /* the Row 30 space - treat as space or CNV virtual key */
        {
#ifndef SPACE_ALWAYS_CONVERTS
          if (JapanIME_KeyboardNumber != JAPAN)
#endif
            wVkey = F_CNV;
          rawKey = 0x20;
        }
        else if (rawKey == 0x3001)                  /* Japanese comma -> halfwidth Shift-JIS code */
          rawKey = 0xa4;
        else if (rawKey == 0x3002)                 /* Japanese period -> halfwidth Shift-JIS code */
          rawKey = 0xa1;
        else if (rawKey == 0x300c)            /* Japanese left corner -> halfwidth Shift-JIS code */
          rawKey = 0xa2;
        else if (rawKey == 0x300d)           /* Japanese right corner -> halfwidth Shift-JIS code */
          rawKey = 0xa3;
        else
          wVkey = -1;                       /* 'illegal' range as far as Compact-VJE is concerned */
      }
      else if (rawKey >= 0xff61 && rawKey < 0xffa0) /* Row ff, the Unicode halfwidth Katakana set */
      {
        rawKey = 0xa0 + rawKey - 0xff60;                         /* convert to the Shift-JIS code */
      }
      else if (rawKey == 0xa5)                        /* &5c is what Compact VJE regards as a Yen */
        rawKey = 0x5c;
      else
        wVkey = -1;                         /* 'illegal' range as far as Compact-VJE is concerned */
    }
    else                                                 /***** ASCII non-top bit printables ******/
    {
      /* deal with remaining &21 through &7e codes */
      if (rawKey == 0x5c)            /* backslash cannot be passed to VJE - it thinks it is a Yen */
        wVkey = -1;

      /* in VACS spec: ... & (KANA_BIT | EISUU_BIT) - which does not give the commented effect!   */
      if ((JapanIME_Bdata.wVjeModeFlag & EISUU_BIT) == 0)                       /* Not EISUU mode */
      {
        /* Map Japanese punctuation as per VACS spec */
        if (rawKey == 0x2e)                           /* Return Japanese period if it is a period */
          rawKey = 0xa1;
        else if (rawKey == 0x2c)                        /* Return Japanese comma if it is a comma */
          rawKey = 0xa4;
        else if (rawKey == 0x2d)                         /* Return a long vowel if it is a hyphen */
          rawKey = 0xb0;
        else if (rawKey == 0x2f)                           /* Return Nakaguro if it is a slash ?? */
          rawKey = 0xa5;
      }
      else if ((inFlags & IME_ListSelection) != 0 && rawKey >= '1' && rawKey <= '9')
        wVkey = F_CHR;         /* F_LB_SEL - candidates selected by mouse, does not seem to work! */
    }
    JapanIME_Bdata.wCharCode = rawKey;

    /* wVkey == -1 means the key could not be mapped to a Shift-JIS byte - see what can be done!  */
    if (wVkey < 0 && (JapanIME_Bdata.wVjeModeFlag & SCREEN_MODE) == 0)
      return NULL;                                          /* ignore character if VJE turned off */
    if (wVkey < 0 && (JapanIME_Bdata.wMainStage & (PRC_RCNV|PRC_CODE)) != 0)
      return NULL;                             /* ignore character if in reconvert or code stages */
  }

  /************************** Pass the virtual/actual key packet to VJE ***************************/

  if ((inFlags & IME_OnlyHotKeys) != 0 && wVkey != F_SCRN && wVkey != F_ROM &&
           wVkey != F_HIRA && wVkey != F_KATA && wVkey != F_EISUU && wVkey != F_ZEN)
    return NULL;                           /* These are the functions active under all conditions */

  if ((JapanIME_Bdata.wDataStatus & VJE_LBDATA) != 0)
    memcpy(JapanIME_UTF8output, JapanIME_LBList, DSP_LEN * 6 + 1);    /* save previous candidates */
  else
    *JapanIME_UTF8output = 0;

  oldIMEstate = IMEstate = JapanIME_Bdata.wVjeModeFlag;

  if (wVkey == F_ROM)
  {
    if ((JapanIME_Bdata.wMainStage & PRC_CODE) == 0)
      JapanIME__SetKanaLock((JapanIME_Bdata.wVjeModeFlag & NONROMAN_BIT) == 0 ? 0 : ROMANLOCK);
    ret = JapanIME_LastResult = RC_EATEN;
  }
  else
    ret = JapanIME_LastResult = JapanIME__PutVkey(wVkey >= 0 ? wVkey : F_CHRK);

  changes |= JapanIME_Bdata.wDataUpdate;       /* add in changes due to kana lock synchronisation */

  JapanIME_Bdata.wDataUpdate = changes | JapanIME__CheckIMEState(IMEstate);

  /* Issue Service_IME 0 (flags changed) if required */
  if (JapanIME_Bdata.wVjeModeFlag != oldIMEstate)
  {
    _swix(OS_ServiceCall,
          _INR(1,5),

          Service_IME,
          IME_Serv_NewFlags,
          oldIMEstate,
          JapanIME_Bdata.wVjeModeFlag,
          IME_Serv_NewFlags_Key);
  }

  /* 30/09/98 In case VJE returns RC_IGNORED with wDataUpdate set (i.e. it has not been ignored), */
  /* which is certainly the case for F_CTRL, and caused some problems, ignore the RC in this case */
  if (ret == RC_IGNORED && wVkey >= 0 && (JapanIME_Bdata.wDataUpdate & ~VJE_RESULT) == 0)
    return NULL;                                                /* todo : what if not RC_IGNORED? */

  if (!cancel)
    r->r[0] = IME_KeyClaimed;

  if ((inFlags & IME_OnlyHotKeys) != 0)
    return NULL;                               /* Results will not be used, so save a little work */

  /* Fiddle with VJE flags to get the returned R0 settings - and convert text to UTF-8 encodings. */
  /* Do the candidate list first so it can use before and after values, using the result buffer.  */
  /* Do display next, so that the result buffer can be used as workspace in detecting a change.   */

  /************************************* The Candidate List ***************************************/

  if ((JapanIME_Bdata.wDataUpdate & VJE_LBDATA) != 0) /* either or both list or selection changed */
  {
    if (memcmp(JapanIME_UTF8output, JapanIME_LBList, JapanIME_Bdata.cchLBListLen) != 0)
      r->r[0] |= IME_CandidatesChanged | IME_SelectionChanged;
    else
      r->r[0] |= IME_SelectionChanged;    /* by elimination, it must have been only the selection */
  }
  if ((JapanIME_Bdata.wDataStatus & VJE_LBDATA) != 0)
    r->r[0] |= IME_ShowCandidates;

  /****************************** The Display buffer and Attributes *******************************/

  if ((JapanIME_Bdata.wDataStatus & VJE_DISPLAYDATA) != 0)                /* the display is valid */
  {
    if ((JapanIME_Bdata.wDataUpdate & VJE_DISPLAYDATA) != 0)           /* the display has changed */
    {
      int caret;
      int uLen;

      memcpy(JapanIME_UTF8output, JapanIME_UTF8display, DSP_LEN * 6 + 1);  /* save previous value */

      uLen = JapanIME__CvtToUTF8((char *)JapanIME_Bdata.lpchDisplay,
                                    JapanIME_Bdata.cchDisplay, JapanIME_UTF8display);

      if (strcmp(JapanIME_UTF8output, JapanIME_UTF8display) != 0)
        r->r[0] |= IME_DisplayChanged;

      memcpy(JapanIME_UTF8output, JapanIME_attributes, DSP_LEN + 1);       /* save previous attrs */

      uLen = JapanIME__CvtAttr(JapanIME_attributes, &caret);        /* convert current attributes */

      if (JapanIME_LastCaret != caret)
        r->r[0] |= IME_CaretChanged;
      JapanIME_LastCaret = caret;

      if (uLen != JapanIME_LastAttrLen ||
                            strncmp(JapanIME_UTF8output, JapanIME_attributes, uLen) != 0)
        r->r[0] |= IME_AttributesChanged;                          /* set attributes changed flag */

      JapanIME_LastAttrLen = uLen;
    }
    r->r[2] = (int)JapanIME_UTF8display;
    r->r[3] = (int)JapanIME_attributes;
    r->r[4] = JapanIME_LastCaret;
    r->r[0] |= IME_ShowDisplay;
  }
  else                                            /* nothing in the display now; NB R2-4 are zero */
  {
    if ((JapanIME_Bdata.wDataUpdate & VJE_DISPLAYDATA) != 0)       /* but the display has changed */
      r->r[0] |= IME_DisplayChanged | IME_AttributesChanged | IME_CaretChanged;    /* all changed */
    JapanIME_LastCaret = -2;
    JapanIME_LastAttrLen = 0;
  }

  /**************************************** The Result ********************************************/

  if (wVkey < 0 || (JapanIME_Bdata.wDataStatus & VJE_RESULT) != 0)     /* there is some output ready */
  {
    int len = ((JapanIME_Bdata.wDataStatus & VJE_RESULT) == 0 ? 0 :
         JapanIME__CvtToUTF8((char *)JapanIME_Bdata.lpchResult,
                             JapanIME_Bdata.cchResult, JapanIME_UTF8output));

    if (wVkey < 0)
      *UCS4_to_UTF8(JapanIME_UTF8output + len, rawKey) = 0;            /* append UTF-8 for rawKey */

    r->r[1] = (int)JapanIME_UTF8output;
    r->r[0] |= IME_Output;
  }

  return NULL;
}

/* ---------------------------------------------------------------------- JapanIME__GetListEntryN */
static char *JapanIME__GetListEntryN(int entNum, int *entLen)
{
  /* return pointer to text for Candidate list number entNum, and return its length in entLen     */
  /* If there is no entry corresponding to entNum, return NULL (entLen is then undefined)         */
  char *listEnd;
  char *list;

  list = (char *)JapanIME_Bdata.lpchLBList;
  listEnd = list + JapanIME_Bdata.cchLBListLen;

  for (; *entLen = strlen(list), --entNum > 0; list += *entLen + 1)
  {
    if (list >= listEnd)
      return NULL;   /* off the end of the list */
  }
  return list;
}

/* --------------------------------------------------------------- JapanIME__GetCandidateListInfo */
_kernel_oserror *JapanIME__GetCandidateListInfo(int swiOffset, _kernel_swi_regs *r)
{
  /* on entry, R0 is a flags word of zero */
  /* returns details of the candidate list as a whole */
  /* R0 is the rturned flags (zero) */
  /* R1 is a pointer to the title (if not returned by the VJE, make one up) */
  /* R2 total candidates */
  /* R3 maximum per page (9) */
  /* R4 number displayed in the list */
  /* R5 index of first shown on the page 1..R4 */
  /* R6 entry to highlight */

  char *listEnd;
  char *list;

  if ((JapanIME_Bdata.wDataStatus & VJE_LBDATA) == 0)
    return JapanIME__Fault(ERR_NoCandidates, ERR_NoCandidatesMsg);           /* nothing to return */

  list = (char *)JapanIME_Bdata.lpchLBList;           /* zero separated list of Sh-JIS candidates */
  listEnd = list + JapanIME_Bdata.cchLBListLen;       /* end of list for loop below               */
  r->r[4] = 0;                                        /* running count of candidates this time    */
  while (list < listEnd)
  {
    list += strlen(list) + 1;
    r->r[4]++;
  }
  r->r[0] = 0;                                        /* returned flags always zero */

  if (*JapanIME_Bdata.lpchLBTitle)                    /* this version of VJE never returns title  */
    JapanIME__CvtToUTF8((char *)JapanIME_Bdata.lpchLBTitle,
                       strlen((char *)JapanIME_Bdata.lpchLBTitle), JapanIME_UTF8candidate);
  else
  {
    /* Generate a suitable title string */
    if ((JapanIME_Bdata.wMainStage & PRC_CODE) != 0)
    {
      int entLen;
      char *entry = JapanIME__GetListEntryN(JapanIME_Bdata.cLBItemNum, &entLen);

      if (entry)
      {
        int chCode = *entry;
        char *format = "%X";

        if (*(entry + 1))
          chCode = (chCode << 8) + *(entry + 1);

        if ((JapanIME_Bdata.wHenModFlag & MOD_SJIS) == 0)
        {
          /* convert to JIS */
          int low = chCode & 0xff;

          chCode = ((chCode - (chCode < 0xa000 ? 0x7000 : 0xb000)) >> 8) << 9;
          if (low >= 0x80)
            --low;
          if (low >= 0x9e)
            low -= 0x5e;
          else
            chCode -= 0x100;
          chCode += low - 0x1f;
          if ((JapanIME_Bdata.wHenModFlag & MOD_KUTEN) != 0)
          {
            chCode = (((chCode >>  8) - 0x20) * 100) + ((chCode & 0xff) - 0x20);  /* JIS -> Kuten */
            format = "%04.4u";
          }
        }
        sprintf(JapanIME_UTF8candidate, format, chCode);
      }
      else
        *JapanIME_UTF8candidate = 0;
    }
    else
      sprintf(JapanIME_UTF8candidate, "%i/%i",
              JapanIME_Bdata.cLBItemPageFirst + JapanIME_Bdata.cLBItemNum - 1,
              JapanIME_Bdata.cLBItemTotal);            /* make one up nn/tt; nn current, tt total */
  }
  r->r[1] = (int)JapanIME_UTF8candidate;
  r->r[2] = JapanIME_Bdata.cLBItemTotal;
  r->r[3] = JapanIME_Bdata.cLBItemNumMax;
  r->r[5] = JapanIME_Bdata.cLBItemPageFirst;
  r->r[6] = JapanIME_Bdata.cLBItemNum;
  return NULL;
}


/* -------------------------------------------------------------- JapanIME__GetCandidateListEntry */
_kernel_oserror *JapanIME__GetCandidateListEntry(int swiOffset, _kernel_swi_regs *r)
{
  /* on entry, R0 is a flags word of zero */
  /* R1 is the index 1... of the entry */
  /* returns with R1 pointing to the text for the entry in UTF-8 */
  char *list;
  int entLen;

  if ((JapanIME_Bdata.wDataStatus & VJE_LBDATA) == 0)
    return JapanIME__Fault(ERR_NoCandidates, ERR_NoCandidatesMsg);           /* nothing to return */

  list = JapanIME__GetListEntryN(r->r[1], &entLen);
  if (list == NULL)
    return JapanIME__Fault(ERR_BadCandidate, ERR_BadCandidateMsg);     /* off the end of the list */

  JapanIME__CvtToUTF8(list, entLen, JapanIME_UTF8candidate);
  r->r[1] = (int)JapanIME_UTF8candidate;
  return NULL;
}

/* -------------------------------------------------------------------------- JapanIME__Configure */
_kernel_oserror *JapanIME__Configure(int swiOffset, _kernel_swi_regs *r)
{
#define eorValue reg1
#define dictFilename reg1
  int reg1 = r->r[1];
  int flagValue;
  int IMEstate;
  int oldIMEstate;

  switch (r->r[0])
  {
    case IME_Config_Dict:
      return JapanIME__OpenDict((char *)dictFilename);

    case IME_Config_Status:
      oldIMEstate = IMEstate = JapanIME_Bdata.wVjeModeFlag;

      JapanIME__CheckRomanjiLock();

      /* Note that we're assuming where things are in IMEstate */

      flagValue = (IMEstate  & 0x19)       |
               (((~IMEstate) & 0x40) >> 5) |                     /* our bit is kana, not eisuu... */
                 ((IMEstate  & 0x20) >> 3) |
                 ((IMEstate  & 0x04) << 3);                            /* shuffle the bits around */
      r->r[1] = flagValue & 0x0f;                               /* only return old values in spec */

      flagValue = (flagValue & r->r[2]) ^ eorValue;

      flagValue = (flagValue  & 0x19)       |
               (((~flagValue) & 0x02) << 5) |
                 ((flagValue  & 0x04) << 3) |
                 ((flagValue  & 0x20) >> 3);                        /* shuffle back to VJE format */

      /* despite what it claims in the spec, SET_MODE cannot be used to turn VJE on and off so .. */
      if (((flagValue ^ JapanIME_Bdata.wVjeModeFlag) & SCREEN_MODE) != 0) /* on/off state changed */
        JapanIME__PutVkey(F_SCRN);                                     /* .. call VJE to toggle   */

      /* 06/10/98 Also apply any changes to the NonRoman bit via SetKanaLock rather than directly */
      if (JapanIME_KeyboardNumber == JAPAN &&
                                 ((flagValue ^ JapanIME_Bdata.wVjeModeFlag) & NONROMAN_BIT) != 0)
      {
        JapanIME__SetKanaLock((JapanIME_Bdata.wVjeModeFlag & NONROMAN_BIT) == 0 ? 0 : ROMANLOCK);
        JapanIME__CheckRomanjiLock();
      }

      /* set bits for any other state(s) changed */
      JapanIME_Bdata.wVjeModeFlag =
                           (JapanIME_Bdata.wVjeModeFlag & (SCREEN_MODE | NONROMAN_BIT)) |
                           (flagValue & ~(SCREEN_MODE | NONROMAN_BIT));   /* reset remaining bits */

      JapanIME__CheckIMEState(IMEstate);

      /* Issue Service_IME 0 (flags changed) if required */
      if (JapanIME_Bdata.wVjeModeFlag != oldIMEstate)
      {
        _swix(OS_ServiceCall,
              _INR(1,5),

              Service_IME,
              IME_Serv_NewFlags,
              oldIMEstate,
              JapanIME_Bdata.wVjeModeFlag,
              IME_Serv_NewFlags_SWI);
      }

      break;

    case IME_Config_DispListBox:
      r->r[1] = JapanIME_Bdata.wDispListBox;    /* set (or just read if R1 < 0), delay in showing */
                                             /* candidate list (number of CNV actions); 0 = never */
      if (reg1 >= 0)
        JapanIME_Bdata.wDispListBox = reg1;
      break;

    case IME_Config_Input:                               /* set bits in the wHenModFlag structure */
      r->r[1] = JapanIME_Bdata.wHenModFlag;
      JapanIME_Bdata.wHenModFlag = (r->r[1] & r->r[2]) ^ eorValue;
      if (r->r[1] != JapanIME_Bdata.wHenModFlag)
        JapanIME__PutVkey(F_SET_MODE);
      break;

    case IME_Config_Bdata:
      r->r[1] = (int)&JapanIME_Bdata;         /* 'read-only' for displaying bdata in test program */
      r->r[2] = JapanIME_LastResult;          /* 'read-only' for displaying value in test program */
      break;

    default:
      return JapanIME__Fault(ERR_BadConfig, ERR_BadConfigMsg);
  }
  if (JapanIME_NVRAMsavetime)
    JapanIME__SaveToNVRAM(0);
  return NULL;
}

/* ------------------------------------------------------------------------- JapanIME__SWIHandler */
_kernel_oserror *JapanIME__SWIHandler(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  switch (swi_offset)
  {
    case JapanIME_ProcessInput - JapanIME_00:
      return JapanIME__DoProcessInput(swi_offset, r);

    case JapanIME_Cancel - JapanIME_00:
      return JapanIME__DoProcessInput(swi_offset, r);

    case JapanIME_GetCandidateListInfo - JapanIME_00:
      return JapanIME__GetCandidateListInfo(swi_offset, r);

    case JapanIME_GetCandidateListEntry - JapanIME_00:
      return JapanIME__GetCandidateListEntry(swi_offset, r);

    case JapanIME_Configure - JapanIME_00:
      return JapanIME__Configure(swi_offset, r);

    default:
      return error_BAD_SWI;
  }
}

/* --------------------------------------------------------------------- JapanIME__Initialisation */
_kernel_oserror *JapanIME__Initialisation(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_swi_regs r;
  int nvram_size;
  int kLock;

  /* set path variable JapanIME$Path to point to ResourceFS if not already set */
  r.r[0] = (int) JapanIME_Path;
  r.r[2] = -1;
  r.r[3] = 0;
  r.r[4] = 3;
  _kernel_swi(OS_ReadVarVal, &r, &r);    /* Must use _kernel_swi because of silly error behaviour */

  if (r.r[2] == 0)
  {
    r.r[0] = (int) JapanIME_Path;
    r.r[1] = (int) JapanIME_DefaultPath;
    r.r[2] = sizeof JapanIME_DefaultPath - 1;
    r.r[3] = 0;
    r.r[4] = 0;
    _kernel_swi(OS_SetVarVal, &r, &r);
  }

  JapanIME__OpenMessages();

  /* initialise input fields in bdata - See VACS spec */
  JapanIME_Bdata.lpchResult = (PUCHAR) JapanIME_ChResult;
  JapanIME_Bdata.lpchMode = (PUCHAR) JapanIME_ChMode;
  JapanIME_Bdata.lpattrMode = (PUCHAR) JapanIME_AttrMode;
  JapanIME_Bdata.lpchMBText = (PUCHAR) JapanIME_MBText;
  JapanIME_Bdata.lpchMBTitle = (PUCHAR) JapanIME_MBTitle;
  JapanIME_Bdata.lpchDisplay = (PUCHAR) JapanIME_ChDisplay;
  JapanIME_Bdata.lpattrDisplay = (PUCHAR) JapanIME_AttrDisplay;
  JapanIME_Bdata.lpchLBList = (PUCHAR) JapanIME_LBList;
  JapanIME_Bdata.lpchLBTitle = (PUCHAR) JapanIME_LBTitle;
  JapanIME_Bdata.cchResult = 0;
  JapanIME_Bdata.cLBItemLenMax = LB_LEN / 9;
  JapanIME_Bdata.cLBItemNumMax = 9;
  JapanIME_Bdata.cLBItemHead = 2;
  JapanIME_Bdata.wKeyType = KEY_STANDARD;                                            /* not used? */
  JapanIME_Bdata.wColorType = CL_SPECIAL;

  /* see what type of keyboard is really being used - module will be informed of later changes    */
  JapanIME_KeyboardNumber = _kernel_osbyte(71, 255, 0) & 0x7f;            /* read keyboard number */
  if (JapanIME_KeyboardNumber > ISO4)
    JapanIME_KeyboardNumber = 0;                     /* ensure a value in the look-up table range */

  /* Initialise input mode flags and set an upcall handler to monitor changes in Kana Lock state  */
  kLock = _kernel_osbyte(202, 0, 0xff);                            /* test current keyboard state */
  JapanIME_Bdata.wVjeModeFlag = INP_MASK;         /* ZENKAKU_BIT (Full width); Inactive; Hiragana */
  if (JapanIME_KeyboardNumber == JAPAN && (kLock & ROMANLOCK) == 0)
    JapanIME_Bdata.wVjeModeFlag |= NONROMAN_BIT;      /* Module loaded with Kana lock already set */
  JapanIME_ModeSave = -1;
  _swix(OS_Claim, _INR(0,2), UpCallV, JapanIME__UpCall, pw);

  JapanIME_Bdata.wCodeMax = 0x987E;
  JapanIME_Bdata.wDispListBox = 3;
  JapanIME__PutVkey(F_INIT);

  /* Attempt to read in previously saved version of learning buffer in NVRAM */
  JapanIME_Bdata.lpchSramAddress = (PSZ)JapanIME_SramData;
  JapanIME_NVRAMsize = 0;

  if (_swix(NVRAM_Read, _INR(0,2) | _OUT(0), JapanIME_MemTag, 0, 0, &JapanIME_NVRAMsize) == NULL &&
      JapanIME_NVRAMsize > 0 &&
      JapanIME_NVRAMsize <= GAKU_SIZE + 2 &&
      _swix(NVRAM_Read, _INR(0,2) | _OUT(0), JapanIME_MemTag, JapanIME_Bdata.lpchSramAddress,
                                              JapanIME_NVRAMsize, &nvram_size) == NULL &&
      nvram_size > 0)
  {
    JapanIME_Bdata.wSramMaxSize = nvram_size;
  }
  else
  {
    memset((PSZ)JapanIME_SramData, 0, 2);                                         /* set to empty */
    JapanIME_Bdata.wSramMaxSize = GAKU_SIZE + 2;
  }
  JapanIME_NVRAMsavetime = 0;
  _swix(OS_CallEvery, _INR(0,2), MINSDELAY * 60 * 100, JapanIME__Timer, pw);
  JapanIME__PutVkey(F_SRAM_OPEN);
  JapanIME_NVRAMsum = JapanIME__CheckSum();

  /* set 'sentance' mode, etc, */
  JapanIME_Bdata.wHenModFlag  = (MOD_BUNSETU | MOD_GAKU | MOD_KUTEN_CNV_NO | MOD_KUTEN | MOD_REN);
  JapanIME__PutVkey(F_SET_MODE);

  /* Initialise module's static data */
  JapanIME_UTF8index = 0;
  JapanIME_LastCaret = -2;
  JapanIME_LastAttrLen = 0;
  JapanIME_DictOpen = 0;
  JapanIME_Enc = NULL;
  JapanIME_KanaLockSave = 0;
  return NULL;
}

/* ----------------------------------------------------------------------- JapanIME__Finalisation */
_kernel_oserror *JapanIME__Finalisation(int fatal, int podule, void *pw)
{
  int oldState = JapanIME_Bdata.wVjeModeFlag;

  /* release the claimed UpCall vector */
  _swix(OS_Release, _INR(0,2), UpCallV, JapanIME__UpCall, pw);

  /* release the call every timer */
  _swix(OS_RemoveTickerEvent, _INR(0,1), JapanIME__Timer, pw);

  /* simulate turning VJE off - in case killed while holding the saved state of the kana lock */
  JapanIME_Bdata.wVjeModeFlag &= SCREEN_MODE;
  JapanIME__CheckIMEState(oldState);

  /* close the messages file */
  if (JapanIME_MsgFile[0] != 0)
  {
    _swix(MessageTrans_CloseFile, _IN(0), JapanIME_MsgFile + 1);
    JapanIME_MsgFile[0] = 0;
  }

  /* dispose of the encoding tables */
  if (JapanIME_Enc)
    encoding_delete(JapanIME_Enc);

  JapanIME__SaveToNVRAM(1);

  JapanIME__PutVkey(F_SRAM_CLOSE);
  JapanIME__PutVkey(F_CLOSE);
  JapanIME__CloseDict();
  return NULL;
}

/* ---------------------------------------------------------------------------- JapanIME__Service */
void JapanIME__ServiceHandler(int service_number, _kernel_swi_regs *r, void *pw)
{
  if (service_number == Service_International)  /* International */
  {
    if (r->r[2] == 6)               /* new keyboard selection - get the new keyboard number in R3 */
      JapanIME_KeyboardNumber = (r->r[3] > ISO4 ? 0 : r->r[3]);  /* ensure in look-up table range */
  }
  else if ((service_number == Service_Standby && (r->r[0] & 1) != 0) ||
            service_number == Service_ShutDown)
  {
    JapanIME__SaveToNVRAM(0);
  }
}

/* ---------------------------------------------------------------------- JapanIME__Event_handler */
int JapanIME__UpCall_handler(_kernel_swi_regs *r, void *pw)
{
  /* For intercepting UpCalls when the state of the keyboard locks is changed */

  if (r->r[0] == UpCall_KeyboardStatus && JapanIME_KeyboardNumber == JAPAN)
  {
    /* R0 = 20 (UpCall_KeyboardStatus)        */
    /* R1 = 0 if pre-change, 1 if post-change */
    /* R2 = old value                         */
    /* R3 = new value                         */

    if (r->r[1] == 0)       /* pre-change */
    {
      JapanIME_UpCalled = 1;
      if ((JapanIME_Bdata.wVjeModeFlag & BOTHFLAGS) == BOTHFLAGS)     /* IME on and in Eisuu mode */
      {
        if ((r->r[2] & ROMANLOCK) != 0 && (r->r[3] & ROMANLOCK) == 0)     /* setting kana lock on */
        {
          JapanIME_KanaLockSave ^= ROMANLOCK;            /* Flip our saved state of the kana lock */
          r->r[3] |= ROMANLOCK;                             /* set b5 back to old set value state */
          if (r->r[2] == r->r[3])                                             /* if no net change */
            r->r[0] = 0;
          return 0;                                          /* do not risk it being changed back */
        }
      }
    }
    else if (((r->r[2] ^ r->r[3]) & ROMANLOCK) != 0)                    /* bit 5 has been flipped */
    {
      // make a note, and deal with it asap
      JapanIME_ModeSave = (r->r[3] & ROMANLOCK);
    }
  }
  return 1;
}

/* ---------------------------------------------------------------------- JapanIME__Timer_handler */
_kernel_oserror *JapanIME__Timer_handler(_kernel_swi_regs *r, void *pw)
{
  /* Sets a flag every MINSDELAY minutes, indicating a NVRAM save check is due */
  JapanIME_NVRAMsavetime = 1;
  return NULL;
}

/* ---------------------------------------------------------------------------------------------- */
