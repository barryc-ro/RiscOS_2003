/************************************************************************/
/* File: JapanIME                                                       */
/* Purpose:                                                             */
/*     Provides a Unicode interface to the VACS Compact VJE IME code    */
/*                                                                      */
/* Author:  Bob Pollard (mailto:bob@icontech.demon.co.uk)               */
/* History: Tue 8th September 1998  ver 0.00 - Created.                 */
/*          Wed 16th September 1998  ver 0.00 - Sent to Acorn.          */
/*          Thu 17th September 1998  updates for new VACS spec ver 0.01 */
/*          - 6Kb size (from 2K) for learning buffer                    */
/*          - Map keys from extended Japanese keyboard to IME codes     */
/*          - Open_Dict redone to read file and pass RAM/ROM location,  */
/*            rather than filename to VJE                               */
/*          - added explicit Close_Dict                                 */
/*          - testing configure option for setting number of candidate  */
/*            selections before list shown                              */
/*          - Ctrl-key options done by look-up rather than case switch  */
/*          23-Sep-98 as a result of James Byrne input:                 */
/*          - PageUp/Down actions more important than Shift U/D arrows  */
/*          - Title for 'Code' converts now hex code value (as MS-IME)  */
/*          - Handle candidate list selections: 1..9, <Esc>, <PageUp>,  */
/*            and <PageDown> explicitly                                 */
/*          - Get a full 'Cancel', even when candidate list showing     */
/*          - Set KeyClaimed flag correctly even if OnlyHotKeys set     */
/*          - Handle Pound, etc. which do not give a Sh-JIS single byte */
/*          - set 3 display area 'changes' flags using our own code     */
/*          24/25-Sep-98 spec changes, clarifications                   */
/*          - the module is now initialised to the 'off' state          */
/*          - extra return flag for just candidate selection changed    */
/*          - Common up returned candidate title and candidate buffers  */
/*          28/30-Sep-98 resolution of outstanding problems             */
/*          - Test keyboard number and differentiate space, enter, etc. */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "C:kernel.h"
#include "C:swis.h"
#include "common.h"
#include "VJE.h"
#include "basicedt.h"
#include "encoding.h"
#include "charsets.h"
#include "utf8.h"
#include "JapanIME.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

#define         DSP_LEN         (80)
#define         MODE_LEN        (80)
#define         MB_LEN          (80)
#define         LB_LEN          (64 * 9)
#define         GAKU_SIZE       ((6 * 1024) - 2)

#if !defined FALSE
#define         FALSE           0
#endif
#if !defined TRUE
#define         TRUE            1
#endif
#define         PUCHAR unsigned char *

/* keyboard/country numbers */
#define         UK              1
#define         SPAIN           5
#define         ESPERANTO       9
#define         GREECE          10
#define         NORWAY          15
#define         ICELAND         16
#define         RUSSIA          24
#define         JAPAN           32
#define         SWITZERLAND     35
#define         WALES           36
#define         WALES2          49
#define         DVORAKUK        70

/* alphabet numbers */
#define         UTF8            111

#define         ERR_BadSWI      76
#define         ERR_NoDict      77
#define         ERR_BadConfig   78
#define         ERR_NoCandidates 79
#define         ERR_BadCandidate 80
#define         ERR_NoMemForDict 81

#define         ERR_BadSWIMsg   "Bad IME SWI number"
#define         ERR_NoDictMsg   "Japanese IME dictionary null name or open failed"
#define         ERR_BadConfigMsg "Bad configure number"
#define         ERR_NoCandidatesMsg  "There is no IME Candidate List"
#define         ERR_BadCandidateMsg  "There is no such entry in the IME Candidate List"
#define         ERR_FailGenMsg  "Internal failure in IME"

#define         JapanIME_Path        "JapanIME$Path"
#define         JapanIME_DefaultPath "Resources:$.Resources.JapanIME."
#define         JapanIME_Dict        "JapanIME:Dictionary"

/* The following #define controls what happens in the case where we find input from the keyboard  */
/* which cannot be converted to a single byte Shift-JIS character, needed by Compact-VJE. Actions */
/* are: DOPOUND undefined - return character to caller; DOPOUND = 1 - Transfer outstanding input  */
/* and append the character to the result string; DOPOUND = 2 - As for 1, but return the key      */
/* unprocessed if there is already anything in the in the input buffer.                           */
#define         DOPOUND         1

/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

#if ROMDIC
void *JapanIME_Dic_Address;   /* 21-Sep-98 used to tell VJE the location of dictionary in RAM/ROM */
#endif

/* -------------------------------------- STATIC VARIABLES -------------------------------------- */

static UCHAR    JapanIME_ChResult[DSP_LEN * 2 + 1];
static UCHAR    JapanIME_ChDisplay[DSP_LEN * 2 + 1];
static UCHAR    JapanIME_AttrDisplay[DSP_LEN * 2 + 1];
static UCHAR    JapanIME_ChMode[MODE_LEN + 1];
static UCHAR    JapanIME_AttrMode[MODE_LEN + 1];
static UCHAR    JapanIME_MBTitle[DSP_LEN + 1];
static UCHAR    JapanIME_MBText[MB_LEN * 2 + 1];
static UCHAR    JapanIME_LBTitle[DSP_LEN + 1];
static UCHAR    JapanIME_LBList[LB_LEN + 1];

/* converted 'output' buffers */
static char     JapanIME_UTF8output[DSP_LEN * 6 + 1];
static char     JapanIME_UTF8display[DSP_LEN * 6 + 1];
static char     JapanIME_attributes[DSP_LEN + 1];
static char     JapanIME_UTF8candidate[(LB_LEN / 9) * 6 + 1];

static BDATA    JapanIME_Bdata;

static UCHAR    JapanIME_SramData[GAKU_SIZE + 2];

static _kernel_oserror JapanIME_Err;

static char     JapanIME_UTF8input[8];
static int      JapanIME_UTF8index;
static int      JapanIME_LastCaret;
static int      JapanIME_LastAttrLen;
static int      JapanIME_DictOpen;  /* initialised to 0; 1 if in ROM; -1 if in dynamic area */
static int      JapanIME_DynAreaNumber;
static int      JapanIME_KeyboardNumber;
static int      JapanIME_AlphabetNumber;
static int      JapanIME_KanaLockState;
static Encoding *JapanIME_Enc;

static char JapanIME_KanaLookup[192] = {
// Hiragana
/*    0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f */
/* 304x */
   0x00, 0xa7, 0xb1, 0xa8, 0xb2, 0xa9, 0xb3, 0xaa, 0xb4, 0xab, 0xb5, 0xb6, 0x00, 0xb7, 0x00, 0xb8,
/* 305x */
   0x00, 0xb9, 0x00, 0xba, 0x00, 0xbb, 0x00, 0xbc, 0x00, 0xbd, 0x00, 0xbe, 0x00, 0xbf, 0x00, 0xc0,
/* 306x */
   0x00, 0xc1, 0x00, 0xaf, 0xc2, 0x00, 0xc3, 0x00, 0xc4, 0x00, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca,
/* 307x */
   0x00, 0x00, 0xcb, 0x00, 0x00, 0xcc, 0x00, 0x00, 0xcd, 0x00, 0x00, 0xce, 0x00, 0x00, 0xcf, 0xd0,
/* 308x */
   0xd1, 0xd2, 0xd3, 0xac, 0xd4, 0xad, 0xd5, 0xae, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0x00, 0xdc,
/* 309x */
   0x00, 0x00, 0xa6, 0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0xdf, 0x00, 0x00, 0x00, 0x00, 0x00,
// Katakana
/* 30ax */
   0x00, 0xa7, 0xb1, 0xa8, 0xb2, 0xa9, 0xb3, 0xaa, 0xb4, 0xab, 0xb5, 0xb6, 0x00, 0xb7, 0x00, 0xb8,
/* 30bx */
   0x00, 0xb9, 0x00, 0xba, 0x00, 0xbb, 0x00, 0xbc, 0x00, 0xbd, 0x00, 0xbe, 0x00, 0xbf, 0x00, 0xc0,
/* 30cx */
   0x00, 0xc1, 0x00, 0xaf, 0xc2, 0x00, 0xc3, 0x00, 0xc4, 0x00, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca,
/* 30dx */
   0x00, 0x00, 0xcb, 0x00, 0x00, 0xcc, 0x00, 0x00, 0xcd, 0x00, 0x00, 0xce, 0x00, 0x00, 0xcf, 0xd0,
/* 30ex */
   0xd1, 0xd2, 0xd3, 0xac, 0xd4, 0xad, 0xd5, 0xae, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0x00, 0xdc,
/* 30fx */
   0x00, 0x00, 0xa6, 0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa5, 0xb0, 0x00, 0x00, 0x00,
};


/* keys marked with # are those defined in VACS spec for the extended Japanese keyboard layout    */
static char JapanIME_CtrlLookup[] = {
  F_CTRL,         // Cntl-@/NULL
  F_LLIM,         // Cntl-A             # after convert
  F_CTRL,         // Cntl-B
  F_CNV,          // Cntl-C             # after input
  F_RIGHT,        // Cntl-D             # after input
  F_CNV_BBLK,     // Cntl-E             # after input
  F_RLIM,         // Cntl-F             # after convert
  F_DEL,          // Cntl-G             # after input
  F_BS,           // Cntl-H / BackSpace # after input
  F_CTRL,         // Cntl-I
  F_HIRA_CNV,     // Cntl-J             # after input
  F_KATA_CNV,     // Cntl-K             # after input
  F_ZEN_CNV,      // Cntl-L             # after input
  F_NO_CNV2,      // Cntl-M / Enter     # after input
  F_CTRL,         // Cntl-N
  F_HAN_CNV,      // Cntl-O             # after input
  F_CTRL,         // Cntl-P
  F_CNV_BUNS,     // Cntl-Q             # after convert
  F_CTRL,         // Cntl-R
  F_LEFT,         // Cntl-S             # after input
  F_CTRL,         // Cntl-T
  F_CTRL,         // Cntl-U
  F_CTRL,         // Cntl-V
  F_CNV_BUNL,     // Cntl-W             # after convert
  F_CNV_NBLK,     // Cntl-X             # after input
  F_CANALL,       // Cntl-Y             # after input
  F_CNV_BCNV,     // Cntl-Z             # after input
  F_CANCEL,       // Cntl-[/Esc         # after input
  F_CTRL,         // (0x1c)
  F_CTRL,         // (0x1d)
  F_CTRL,         // (0x1e)
  F_CTRL,         // (0x1f)
};

static char JapanIME_AttrMap[] = {
0x00, 0x01, 0x01, 0x03, 0x02, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00 };

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/* ------------------------------------------------------------------------------ JapanIME__Fault */
static _kernel_oserror *JapanIME__Fault(int errnum)
{
  /* Temporary version in English with built-in messages and random error numbers */
  /* errnum (input) the error number */
  /* returns: pointer to static buffer containing the error number/message */
  JapanIME_Err.errnum = errnum;
  switch (errnum)
  {
    case ERR_BadSWI:
      strcpy(JapanIME_Err.errmess, ERR_BadSWIMsg);
      break;

    case ERR_NoDict:
      strcpy(JapanIME_Err.errmess, ERR_NoDictMsg);
      break;

    case ERR_BadConfig:
      strcpy(JapanIME_Err.errmess, ERR_BadConfigMsg);
      break;

    case ERR_NoCandidates:
      strcpy(JapanIME_Err.errmess, ERR_NoCandidatesMsg);
      break;

    case ERR_BadCandidate:
      strcpy(JapanIME_Err.errmess, ERR_BadCandidateMsg);
      break;

    default:
      strcpy(JapanIME_Err.errmess, ERR_FailGenMsg);
      break;
  }
  return &JapanIME_Err;
}

/* --------------------------------------------------------------------------- JapanIME__SWIFault */
static _kernel_oserror *JapanIME__SWIFault(_kernel_swi_regs *r)
{
  return JapanIME__Fault(ERR_BadSWI);
}

/* ------------------------------------------------------------------------- JapanIME__ProcessUCS */
static int JapanIME__ProcessUCS(void *handle, UCS4 code)
{
  /* this hook is called for each UCS character; it appends the corresponding UTF-8 code */
  /* on to the end of the buffer, whose address is passed via the handle parameter       */

  *((char **)handle) = UCS4_to_UTF8(*((char **)handle), code);
  return 0;
}


/* -------------------------------------------------------------------------- JapanIME__CvtToUTF8 */
static int JapanIME__CvtToUTF8(char *s, int n, char *op)
{
  /* convert a Shift-JIS string, length n to UTF-8 */
  /* return converted length                       */
  char *currPos = op;

  if (JapanIME_Enc == NULL)
    JapanIME_Enc = encoding_new(csShiftJIS, encoding_READ);

  encoding_read(JapanIME_Enc, JapanIME__ProcessUCS, s, n, &currPos);
  *currPos = 0;
  return currPos - op;
}

/* ---------------------------------------------------------------------------  JapanIME__CvtAttr */
static int JapanIME__CvtAttr(char *op, int *cursorPos)
{
  /* converts the attribute list in Bdata to our format (1 byte per character) */
  /* and returns the caret position. It scans through the ShiftJis codes to    */
  /* identify each character, and copies the first attribute byte to 'op'      */

  char *attr = (char *)JapanIME_Bdata.lpattrDisplay;
  char *src = (char *)JapanIME_Bdata.lpchDisplay;
  char *srcEnd = src + JapanIME_Bdata.cchDisplay;
  char *opStart = op;
  int   cursor = -1;

  for ( ; src < srcEnd; )
  {
    /* When processing Shift-JIS, 0xa0 can be a half-width space     */
    /* (1-byte), and 0xf0-0xfc can be user-defined (2-byte) codes.   */
    /* 0xfd-0xff are are not defined and assumed to be 2-byte codes. */
    /* Others are 1-byte, except 0x81 to 0x9f, which are 2-bytes     */

    int ch;

    if (JapanIME_Bdata.cchCurPosition == src - (char *)JapanIME_Bdata.lpchDisplay)
      cursor = op - opStart;                /* the cursor position matches the source offset */

    ch = *(src++);
    *(op++) = JapanIME_AttrMap[*(attr++)];  /* copy the attr byte for first byte to output */

    if (ch >= 0x81 && (ch < 0xa0 || ch >= 0xe0))
    {
      src++;                                /* it is a 2-byte code, skip 2nd byte */
      attr++;                               /* and skip over its attr byte too    */
    }
  }

  if (JapanIME_Bdata.cchCurPosition == src - (char *)JapanIME_Bdata.lpchDisplay)
    cursor = op - opStart;                /* the cursor is at the end */

  *op = 0;
  *cursorPos = (JapanIME_Bdata.cchCurAttr ? cursor : -1);
  return op - opStart;                      /* return the number of bytes needed */
}

/* --------------------------------------------------------------------------- JapanIME__IMEState */
static void JapanIME__CheckIMEState(int oldState)
{
  /* called every time there is a potential state change, passing the old state */

  /* To be done, when we can work out what to do! */
}

/* --------------------------------------------------------------------------- JapanIME__CheckCNV */
static int JapanIME__CheckCNV()
{
  /* F_CNV should only be passed 'after input character' otherwise VJE inserts a space */

  return ((JapanIME_Bdata.wMainStage & PRC_EMP) != 0 ? -1 : F_CNV);
}

/* ---------------------------------------------------------------------------- JapanIME__PutVkey */
static int JapanIME__PutVkey(int key)
{
  /* input: key - a VJE virtual key code */
  /* return: one of VJE codes, -1 error; 0 eaten; 1 ignored; 2 exit */
  /* function: passes the supplied virtual code to VJE to action */
  JapanIME_Bdata.wVkey = key;
  return BasicEdit(&JapanIME_Bdata);
}

/* -------------------------------------------------------------------------- JapanIME__CloseDict */
static void JapanIME__CloseDict()
{
#if ROMDIC
  int openState = JapanIME_DictOpen;
#endif

  JapanIME_DictOpen = 0;
#if ROMDIC
  if (openState < 0)                              /* dictionary is already open in a dynamic area */
    _swix(OS_DynamicArea, _IN(0) | _IN(1), 1, JapanIME_DynAreaNumber);
#endif
}

/* --------------------------------------------------------------------------- JapanIME__OpenDict */
static _kernel_oserror *JapanIME__OpenDict(char *dictName)
{
  /* redone 21-Sep-98 used to tell VJE the location of dictionary in RAM/ROM */
  /* Called at initialisation and when the dictionary name is changed        */
#if ROMDIC
  _kernel_oserror *e;
  int ftype;           // file type
  int flen;            // file length
  int fh;              // file handle
  int inthandle;
  int filesys;

  if (dictName == NULL)
    return JapanIME__Fault(ERR_NoDict);

  e = _swix(OS_File, _INR(0,1)|_OUT(0)|_OUT(4), 23, dictName, &ftype, &flen);

  if (e != NULL || (ftype & 1) == 0)       // not a file/image file
    return JapanIME__Fault(ERR_NoDict);

  /* Open the file for input */
  e = _swix(OS_Find, _INR(0,1)|_OUT(0), 0x4F, dictName, &fh);

  /* Obtain the filing system number and internal handle */
  if (e == NULL)
  {
    e = _swix(OS_FSControl, _INR(0,1)|_OUTR(1,2), 21, fh, &inthandle, &filesys);

    /* Close the file */
    _swix(OS_Find, _INR(0,1), 0, fh);
    /* return e if an error after closing file */

    if (e == NULL)
    {
      /* in case already open in a dynamic area ... */
      JapanIME__CloseDict();

      /* If it's ResourceFS, return a direct pointer */
      if ((filesys & 0xFF) == 46)
      {
        JapanIME_Dic_Address = (void *)inthandle;
        JapanIME_DictOpen = 1;
      }
      else
      {
        e = _swix(OS_DynamicArea, _INR(0,8)|_OUT(1)|_OUT(3), 0, -1, flen, -1,
                   0x80 /* do not allow bar drag*/, flen, 0, 0,
                   (int)"JapanIME dictionary", &JapanIME_DynAreaNumber, &JapanIME_Dic_Address);
        if (e == NULL)
        {
          e = _swix(OS_File, _INR(0,3), 16, dictName, JapanIME_Dic_Address, 0);
          if (e)
            JapanIME__CloseDict();
          else
            JapanIME_DictOpen = -1;           /* dynamic area needs to be freed on re-select dict */
        }
      }
    }
  }
  if (e)
    return e;

  JapanIME_Bdata.lpchDicName = (PCH)0;
#else
  JapanIME_Bdata.lpchDicName = (PCH)dictName;
#endif

  if (JapanIME__PutVkey(F_OPEN) == RC_ERROR)
    return JapanIME__Fault(ERR_NoDict);
  return NULL;
}

/* --------------------------------------------------------------------- JapanIME__DoProcessInput */
static _kernel_oserror *JapanIME__DoProcessInput(_kernel_swi_regs *r, int cancel)
{
  /* Main key conversion routine. Entered from ProcessInput, and Cancel (when cancel is set).     */
  /* The registers parameter (r) contains the input and output parameters from the conversion.    */

  int inFlags = r->r[0];
  UCS4 rawKey = r->r[1];        /* make a copy before clearing regs - not used in the cancel case */
  int wVkey;
  int ret;
  int IMEstate;

  if (!JapanIME_DictOpen)
    JapanIME__OpenDict(JapanIME_Dict);

  memset(r, 0, 20);                                          /* initialise to 'not handled' state */

  if (cancel)
  {
    wVkey = F_NO_CNV2;     /* 23-Sep-98 use CNV2 for cancel; return what is in the display string */
  }
  else
  {
    if ((inFlags & IME_UCSinput) == 0)                              /* need to convert from UTF-8 */
    {
      /* Code is in the current alphabet - either an 8-bit one, or UTF-8. */
      JapanIME_AlphabetNumber = _kernel_osbyte(71, 127, 0) & 0xFF;
      if (JapanIME_AlphabetNumber == UTF8)
      {
        /* inCode may be just part of a character. We need to buffer up until a complete character  */
        /* has been assembled, and convert it to a UCS value. While an incomplete UTF-8 buffer      */
        /* exists return an 'key claimed' result to the caller                                      */

        if (rawKey < 0x80)
        {
          /* trivial convert to UCS :-) */
        }
        else if (rawKey >= 0x100)               /* not a UTF8 code, so must be a Function key, etc. */
        {
          rawKey = 0x80000000 + rawKey - 0x100;
        }
        else if (JapanIME_UTF8index == 0 && (rawKey & 0xC0) == 0x80)   /* leading continuation byte */
          return NULL;
        else
        {
          if (JapanIME_UTF8index > 0 && (rawKey & 0xC0) != 0x80)        /* start byte in the middle */
            JapanIME_UTF8index = 0;

          if (JapanIME_UTF8index > 6)
            return NULL;              /* UTF8_to_UCS4 is misbehaving? do this until next start code */

          JapanIME_UTF8input[JapanIME_UTF8index++] = rawKey;
          JapanIME_UTF8input[JapanIME_UTF8index] = 0;

          if (UTF8_to_UCS4(JapanIME_UTF8input, &rawKey) == 1)         /* returns 1 if not ready yet */
          {
            r->r[0] = IME_KeyClaimed;
            return NULL;                               /* claimed, but we are not processing it yet */
          }
        }
        JapanIME_UTF8index = 0;                             /* clear ready for next input character */
      }
      else
      {
        JapanIME_UTF8index = 0;                   /* alphabet isn't UTF-8. */

        if (rawKey >= 0x100)                      /* function keys are function keys */
        {
          rawKey = 0x80000000 + rawKey - 0x100;
        }
        else
        {
          int unclaimed=1;                        /* get a UCS table using Service_International */
          const unsigned int *alphabet_table;
          _swix(OS_ServiceCall, _INR(1,3)|_OUT(1)|_OUT(4), 0x43, 8, JapanIME_AlphabetNumber,
                                                           &unclaimed, &alphabet_table);
          if (!unclaimed)
          {
            rawKey = alphabet_table[rawKey];      /* use the table, otherwise assume direct codes */
          }
        }
      }
    }

    /* we now have the UCS code from the 'keyboard': convert it to a Compact VJE virtual key.     */

    wVkey = F_CHR;
    if (rawKey <= 31)                                                    /******* Ctrl keys *******/
    {
      if (rawKey == 3)  // Ctrl-C
        wVkey = JapanIME__CheckCNV();
      else if (rawKey == 27 && (inFlags & IME_ListSelection) != 0)        /* Close list selection */
        wVkey = F_NO_CNV;
      else if (rawKey == 0x0d && JapanIME_KeyboardNumber != JAPAN)       /* Enter on 101 keyboard */
        wVkey = F_NO_CNV;
      else
        wVkey = JapanIME_CtrlLookup[rawKey];
    }
    else if (rawKey == ' ')                                               /******** <Space> *******/
    {
      if (JapanIME_KeyboardNumber != JAPAN)
        wVkey = F_CNV;
    }
    else if ((rawKey & 0x80000000) != 0)
    {
      switch (rawKey & 0x7fffffff)                               /****** Function keys, etc. ******/
      {
        case 0x85:        // F5 # after input
          wVkey = F_CODE;
          break;
        case 0x86:        // F6 # after input
          wVkey = F_HIRA_CNV;
          break;
        case 0x87:        // F7 # after input
          wVkey = F_KATA_CNV;
          break;
        case 0x88:        // F8 # after input
          wVkey = F_ZEN_CNV;
          break;
        case 0x89:        // F9 # after input
          wVkey = F_HAN_CNV;
          break;
        case 0xA3:        // Ctrl-F3 #
          wVkey = F_ROM;
          break;
        case 0xA5:        // Ctrl-F5 # before input
          wVkey = F_CODE_CNT;
          break;
        case 0xA6:        // Ctrl-F6 #
          wVkey = F_HIRA;
          break;
        case 0xA7:        // Ctrl-F7 #
          wVkey = F_KATA;
          break;
        case 0xA8:        // Ctrl-F8 #
          wVkey = F_EISUU;
          break;
        case 0xA9:        // Ctrl-F9 #
          wVkey = F_ZEN;
          break;
        case 0xEC:        // Ctrl-F12 # before input
          wVkey = F_DMODE;
          break;
        case 0x8C:        // normal Left # after input
          wVkey = F_LEFT;
          break;
        case 0x8D:        // normal Right # after input
          wVkey = F_RIGHT;
          break;
        case 0x8F:        // normal Up # after input
          wVkey = F_CNV_BCNV;
          break;
        case 0x9C:        // Shift-Left # after convert
          wVkey = F_CNV_BUNS;
          break;
        case 0x9D:        // Shift-Right # after convert
          wVkey = F_CNV_BUNL;
          break;
        case 0xAC:        // Ctrl-Left
          wVkey = F_LLIM;
          break;
        case 0xAD:        // Ctrl-Right
          wVkey = F_RLIM;
          break;
        case 0x9E:        // PageDown (also Shift-Down!) # after convert
          //if ((inFlags & IME_ListSelection) != 0)    /* check mouse button down in list selection */
            wVkey = F_CNV_NBLK;
          //else
            //wVkey = F_RLIM;
          break;
        case 0x9F:        // PageUp (also Shift-Up!) # after convert
          //if ((inFlags & IME_ListSelection) != 0)      /* check mouse button up in list selection */
            wVkey = F_CNV_BBLK;
          //else
           // wVkey = F_LLIM;
          break;
        case 0xc2:        // Zen/han toggle
        case 0xd2:        // Shift-Zen/han toggle
          wVkey = F_ZEN;
          break;
        case 0xc3:        // Active toggle (on the Alt-topleft key) #
          wVkey = F_SCRN;
          break;
        case 0xc4:        // Eisuu (Roman)
          wVkey = F_EISUU;
          break;
        case 0xc5:        // Muhenkan (non-convert) - need to test wMainStage
        case 0xd5:        // and Shift-Muhenkan
          if ((JapanIME_Bdata.wMainStage & PRC_EMP) != 0)
            wVkey = F_UNDO;         // before input #
          else
            wVkey = F_NO_CNV;       // after input #
          break;
        case 0xc7:        // Kana (Hiragana)
          wVkey = F_HIRA;
          break;
        case 0xd6:        // Shift-Henkan (Previous convert) # after input
          wVkey = F_CNV_BCNV;
          break;
        case 0xd7:        // Shift-Kana (Katakana)
          wVkey = F_KATA;
          break;
        case 0x8E:        // normal Down # after input
        case 0xc6:        // Henkan (Next convert) # after input
          wVkey = JapanIME__CheckCNV();
          if (wVkey >= 0)
            break;        // else return unprocessed
        case 0xC8:        // All Candidates
          if (JapanIME_Bdata.wMainStage & (PRC_CNV | PRC_RCNV))
          {
            wVkey = F_CNV_NBLK; // brings up candidate list in CNV and RCNV states
            break;
          }
          else
            return NULL;
        case 0xC9:        // Kanji Number
          wVkey = F_CODE;
          break;
        case 0xD9:        // Shift-Kanji Number
          wVkey = F_CODE_CNT;
          break;
      /* ---- return the following 'function keys' unhandled
        case 0x80:        // F0/Print
        case 0x81:        // F1
        case 0x82:        // F2
        case 0x83:        // F3
        case 0x84:        // F4
        case 0xCA:        // F10
        case 0xCB:        // F11
        case 0xCC:        // F12
        case 0xA0:        // Ctrl-F0/Print
        case 0xA1:        // Ctrl-F1
        case 0xA2:        // Ctrl-F2
        case 0xA4:        // Ctrl-F4
        case 0xEA:        // Ctrl-F10
        case 0xEB:        // Ctrl-F11
        case 0x8A:        // Tab
        case 0x8B:        // Copy
        case 0x9A:        // Shift-Tab
        case 0x9B:        // Shift-Copy
        ------------------------------------- end of unprocessed f-keys */
        default:
          return NULL;                                             /* return with key not handled */
      }
    }
    else if (rawKey >= 0x7f)                                     /***** 'Top bit' characters ******/
    {
      if (rawKey == 0x7f)                                                /* DEL key # after input */
        wVkey = F_DEL;
      else if (rawKey == 0x203e)     /* overline - tilde/overline are sort of unified in Shift-JIS */
        rawKey = 0x7e;
      else if (rawKey >= 0x3000 && rawKey < 0x3100)       /* Row 30: Punct, Hiragana and Katakana */
      {
        if (rawKey >= 0x3040)      /* convert Hiragana and Katakana to half-width Shift-JIS codes */
        {
          int newKey = JapanIME_KanaLookup[rawKey - 0x3040];

          if (newKey == 0)
            wVkey = -1;                     /* 'illegal' range as far as Compact-VJE is concerned */
          else
            rawKey = newKey;            /* Compact VJE can handle it by mapping to a h/w katakana */
        }
        /* deal with punctuation in Row 30 on an ad-hoc basis */
        else if (rawKey == 0x3000)    /* the Row 30 space - treat as space or CNV virtual key */
        {
          if (JapanIME_KeyboardNumber != JAPAN)
            wVkey = F_CNV;
          rawKey = 0x20;
        }
        else if (rawKey == 0x3001)                  /* Japanese comma -> halfwidth Shift-JIS code */
          rawKey = 0xa4;
        else if (rawKey == 0x3002)                 /* Japanese period -> halfwidth Shift-JIS code */
          rawKey = 0xa1;
        else if (rawKey == 0x300c)            /* Japanese left corner -> halfwidth Shift-JIS code */
          rawKey = 0xa2;
        else if (rawKey == 0x300d)           /* Japanese right corner -> halfwidth Shift-JIS code */
          rawKey = 0xa3;
        else
          wVkey = -1;                       /* 'illegal' range as far as Compact-VJE is concerned */
      }
      else if (rawKey >= 0xff61 && rawKey < 0xffa0) /* Row ff, the Unicode halfwidth Katakana set */
      {
        rawKey = 0xa0 + rawKey - 0xff60;                         /* convert to the Shift-JIS code */
      }
      else if (rawKey == 0xa5)                        /* &5c is what Compact VJE regards as a Yen */
        rawKey = 0x5c;
      else if ((rawKey == 0xa6   && (JapanIME_KeyboardNumber == UK ||
                                     JapanIME_KeyboardNumber == DVORAKUK ||
                                     JapanIME_KeyboardNumber == ESPERANTO ||
                                     JapanIME_KeyboardNumber == NORWAY ||
                                     JapanIME_KeyboardNumber == WALES ||
                                     JapanIME_KeyboardNumber == WALES2))
            || (rawKey == 0x2020 && (JapanIME_KeyboardNumber == ICELAND))
            || (rawKey == 0xac   && (JapanIME_KeyboardNumber != JAPAN)))
        wVkey = F_SCRN; /* Alt+key to left of 1 - assume "not sign" for other keyboards */
      else
        wVkey = -1;                         /* 'illegal' range as far as Compact-VJE is concerned */
    }
    else                                                 /***** ASCII non-top bit printables ******/
    {
      /* deal with remaining &21 through &7e codes */
      if (rawKey == 0x5c)            /* backslash cannot be passed to VJE - it thinks it is a Yen */
        wVkey = -1;

      if ((JapanIME_Bdata.wVjeModeFlag & (KANA_BIT | EISUU_BIT)) == 0)          /* Not EISUU mode */
      {
        /* Map Japanese punctuation as per VACS spec */
        if (rawKey == 0x2e)                           /* Return Japanese period if it is a period */
          rawKey = 0xa1;
        else if (rawKey == 0x2c)                        /* Return Japanese comma if it is a comma */
          rawKey = 0xa4;
        else if (rawKey == 0x2d)                         /* Return a long vowel if it is a hyphen */
          rawKey = 0xb0;
        else if (rawKey == 0x2f)                           /* Return Nakaguro if it is a slash ?? */
          rawKey = 0xa5;
      }
      else if ((inFlags & IME_ListSelection) != 0 && rawKey >= '1' && rawKey <= '9')
        wVkey = F_CHR;         /* F_LB_SEL - candidates selected by mouse, does not seem to work! */
    }
    JapanIME_Bdata.wCharCode = rawKey;

    /* wVkey == -1 means the key could not be mapped to a Shift-JIS byte - see what can be done!  */
#ifdef DOPOUND
#if DOPOUND == 2
    if (wVkey < 0 && (JapanIME_Bdata.wMainStage & PRC_EMP) == 0)
      return NULL;                                        /* ignore character if buffer non-empty */
#endif
    if (wVkey < 0 && (JapanIME_Bdata.wMainStage & (PRC_RCNV|PRC_CODE)) != 0)
      return NULL;
#define NOKEY   (wVkey >= 0)
#else
    if (wVkey < 0)
      return NULL;
#define NOKEY   TRUE
#endif
  }

  /************************** Pass the virtual/actual key packet to VJE ***************************/

  if ((inFlags & IME_OnlyHotKeys) != 0 && wVkey != F_SCRN && wVkey != F_ROM &&
           wVkey != F_HIRA && wVkey != F_KATA && wVkey != F_EISUU && wVkey != F_ZEN)
    return NULL;                            /* These are the funtions active under all conditions */

  if ((JapanIME_Bdata.wDataStatus & VJE_LBDATA) != 0)
    memcpy(JapanIME_UTF8output, JapanIME_LBList, DSP_LEN * 6 + 1);    /* save previous candidates */
  else
    *JapanIME_UTF8output = 0;

  IMEstate = JapanIME_Bdata.wVjeModeFlag;

  ret = JapanIME__PutVkey(NOKEY ? wVkey : F_CHRK /*F_NO_CNV2*/);

  JapanIME__CheckIMEState(IMEstate);

  if (ret == RC_IGNORED && NOKEY)
    return NULL;                                                /* todo : what if not RC_IGNORED? */

  if (!cancel)
    r->r[0] = IME_KeyClaimed;

  if ((inFlags & IME_OnlyHotKeys) != 0)
    return NULL;                               /* Results will not be used, so save a little work */

  /* Fiddle with VJE flags to get the returned R0 settings - and convert text to UTF-8 encodings. */
  /* Do the candidate list first so it can use before and after values, using the result buffer.  */
  /* Do display next, so that the result buffer can be used as workspace in detecting a change.   */

  /************************************* The Candidate List ***************************************/

  if ((JapanIME_Bdata.wDataUpdate & VJE_LBDATA) != 0) /* either or both list or selection changed */
  {
    if (memcmp(JapanIME_UTF8output, JapanIME_LBList, JapanIME_Bdata.cchLBListLen) != 0)
      r->r[0] |= IME_CandidatesChanged | IME_SelectionChanged;
    else
      r->r[0] |= IME_SelectionChanged;    /* by elimination, it must have been only the selection */
  }
  if ((JapanIME_Bdata.wDataStatus & VJE_LBDATA) != 0)
    r->r[0] |= IME_ShowCandidates;

  /****************************** The Display buffer and Attributes *******************************/

  if ((JapanIME_Bdata.wDataStatus & VJE_DISPLAYDATA) != 0)                /* the display is valid */
  {
    if ((JapanIME_Bdata.wDataUpdate & VJE_DISPLAYDATA) != 0)           /* the display has changed */
    {
      int caret;
      int uLen;

      memcpy(JapanIME_UTF8output, JapanIME_UTF8display, DSP_LEN * 6 + 1);  /* save previous value */

      uLen = JapanIME__CvtToUTF8((char *)JapanIME_Bdata.lpchDisplay,
                                    JapanIME_Bdata.cchDisplay, JapanIME_UTF8display);
      #if !THIN_CSR
      if (uLen && JapanIME_UTF8display[--uLen] == 0x20)
        JapanIME_UTF8display[uLen] = 0;     /* knock off trailing space representing block cursor */
      #endif

      if (strcmp(JapanIME_UTF8output, JapanIME_UTF8display) != 0)
        r->r[0] |= IME_DisplayChanged;

      memcpy(JapanIME_UTF8output, JapanIME_attributes, DSP_LEN + 1);       /* save previous attrs */

      uLen = JapanIME__CvtAttr(JapanIME_attributes, &caret);        /* convert current attributes */

      if (JapanIME_LastCaret != caret)
        r->r[0] |= IME_CaretChanged;
      JapanIME_LastCaret = caret;

      if (uLen != JapanIME_LastAttrLen ||
                            strncmp(JapanIME_UTF8output, JapanIME_attributes, uLen) != 0)
        r->r[0] |= IME_AttributesChanged;                          /* set attributes changed flag */

      JapanIME_LastAttrLen = uLen;
    }
    r->r[2] = (int)JapanIME_UTF8display;
    r->r[3] = (int)JapanIME_attributes;
    r->r[4] = JapanIME_LastCaret;
    r->r[0] |= IME_ShowDisplay;
  }
  else                                            /* nothing in the display now; NB R2-4 are zero */
  {
    if ((JapanIME_Bdata.wDataUpdate & VJE_DISPLAYDATA) != 0)       /* but the display has changed */
      r->r[0] |= IME_DisplayChanged | IME_AttributesChanged | IME_CaretChanged;    /* all changed */
    JapanIME_LastCaret = -2;
    JapanIME_LastAttrLen = 0;
  }

  /**************************************** The Result ********************************************/

  if (!NOKEY || (JapanIME_Bdata.wDataStatus & VJE_RESULT) != 0)     /* there is some output ready */
  {
    int len = ((JapanIME_Bdata.wDataStatus & VJE_RESULT) == 0 ? 0 :
         JapanIME__CvtToUTF8((char *)JapanIME_Bdata.lpchResult,
                             JapanIME_Bdata.cchResult, JapanIME_UTF8output));

    if (!NOKEY)
      *UCS4_to_UTF8(JapanIME_UTF8output + len, rawKey) = 0;            /* append UTF-8 for rawKey */

    r->r[1] = (int)JapanIME_UTF8output;
    r->r[0] |= IME_Output;
  }

  return NULL;
}

/* ----------------------------------------------------------------------- JapanIME__ProcessInput */
_kernel_oserror *JapanIME__ProcessInput(_kernel_swi_regs *r)
{
  return JapanIME__DoProcessInput(r, 0);
}

/* ----------------------------------------------------------------------------- JapanIME__Cancel */
_kernel_oserror *JapanIME__Cancel(_kernel_swi_regs *r)
{
  return JapanIME__DoProcessInput(r, 1);
}

/* --------------------------------------------------------------- JapanIME__GetCandidateListInfo */
_kernel_oserror *JapanIME__GetCandidateListInfo(_kernel_swi_regs *r)
{
  /* on entry, R0 is a flags word of zero */
  /* returns details of the candidate list as a whole */
  /* R0 is the rturned flags (zero) */
  /* R1 is a pointer to the title (if not returned by the VJE, make one up) */
  /* R2 total candidates */
  /* R3 maximum per page (9) */
  /* R4 number displayed in the list */
  /* R5 index of first shown on the page 1..R4 */
  /* R6 entry to highlight */

  char *listEnd;
  char *list;

  if ((JapanIME_Bdata.wDataStatus & VJE_LBDATA) == 0)
    return JapanIME__Fault(ERR_NoCandidates);          /* nothing to return */

  list = (char *)JapanIME_Bdata.lpchLBList;           /* zero separated list of Sh-JIS candidates */
  listEnd = list + JapanIME_Bdata.cchLBListLen;       /* end of list for loop below */
  r->r[4] = 0;                                        /* running count of candidates this time */
  while (list < listEnd)
  {
    list += strlen(list) + 1;
    r->r[4]++;
  }
  r->r[0] = 0;                                        /* returned flags always zero */

  if (*JapanIME_Bdata.lpchLBTitle)                    /* this version of VJE never returns title */
    JapanIME__CvtToUTF8((char *)JapanIME_Bdata.lpchLBTitle,
                       strlen((char *)JapanIME_Bdata.lpchLBTitle), JapanIME_UTF8candidate);
  else
  {
    if ((JapanIME_Bdata.wMainStage & PRC_CODE) != 0)
    {
      int ch1 = ((char *)JapanIME_Bdata.lpchLBList)[0];
      int ch2 = ((char *)JapanIME_Bdata.lpchLBList)[1];
      int index;

      /* Convert to kuten */
      if (ch1 >= 0xE0) ch1 -= 0xC1; else ch1 -= 0x81;
      if (ch2 >= 0x80) ch2 -= 0x41; else ch2 -= 0x40;
      index = 188 * ch1 + ch2;

      /* Offset to current character */
      index += JapanIME_Bdata.cLBItemNum - 1;

      ch1 = index / 94;
      ch2 = index % 94;

      /* Convert to current coding */
      if (JapanIME_Bdata.wHenModFlag & MOD_KUTEN)
        sprintf(JapanIME_UTF8candidate, "%02d%02d", ch1+1, ch2+1);
      else if (JapanIME_Bdata.wHenModFlag & MOD_JIS)
        sprintf(JapanIME_UTF8candidate, "%02X%02X", ch1+0x21, ch2+0x21);
      else
      {
        ch1 = index / 188;
        ch2 = index % 188;
        if (ch1 <= 0x1E) ch1 += 0x81; else ch1 += 0xE0-0x1F;
        if (ch2 <= 0x3E) ch2 += 0x40; else ch2 += 0x80-0x3F;
        sprintf(JapanIME_UTF8candidate, "%02X%02X", ch1, ch2);
      }
    }
    else
      sprintf(JapanIME_UTF8candidate, "%i/%i",
              JapanIME_Bdata.cLBItemPageFirst + JapanIME_Bdata.cLBItemNum - 1,
              JapanIME_Bdata.cLBItemTotal);             /* make one up nn/tt; nn current, tt total */
  }
  r->r[1] = (int)JapanIME_UTF8candidate;
  r->r[2] = JapanIME_Bdata.cLBItemTotal;
  r->r[3] = JapanIME_Bdata.cLBItemNumMax;
  r->r[5] = JapanIME_Bdata.cLBItemPageFirst;
  r->r[6] = JapanIME_Bdata.cLBItemNum;
  return NULL;
}

/* -------------------------------------------------------------- JapanIME__GetCandidateListEntry */
_kernel_oserror *JapanIME__GetCandidateListEntry(_kernel_swi_regs *r)
{
  /* on entry, R0 is a flags word of zero */
  /* R1 is the index 1... of the entry */
  /* returns with R1 pointing to the text for the entry in UTF-8 */
  char *listEnd;
  char *list;
  int entNum = r->r[1];
  int entLen;

  if ((JapanIME_Bdata.wDataStatus & VJE_LBDATA) == 0)
    return JapanIME__Fault(ERR_NoCandidates);             /* nothing to return */

  list = (char *)JapanIME_Bdata.lpchLBList;
  listEnd = list + JapanIME_Bdata.cchLBListLen;

  for (; entLen = strlen(list), --entNum > 0; list += entLen + 1)
  {
    if (list >= listEnd)
      return JapanIME__Fault(ERR_BadCandidate);             /* off the end of the list */
  }
  JapanIME__CvtToUTF8(list, entLen, JapanIME_UTF8candidate);
  r->r[1] = (int)JapanIME_UTF8candidate;
  return NULL;
}

/* -------------------------------------------------------------------------- JapanIME__Configure */
_kernel_oserror *JapanIME__Configure(_kernel_swi_regs *r)
{
#define eorValue reg1
#define dictFilename reg1
  int reg1 = r->r[1];
  int flagValue;
  int IMEstate;

  switch (r->r[0])
  {
    case IME_Config_Dict:
      return JapanIME__OpenDict((char *)dictFilename);

    case IME_Config_Status:
      IMEstate = JapanIME_Bdata.wVjeModeFlag;

      flagValue = (IMEstate & 0x19) |
                 ((IMEstate & 0x60) >> 4) |
                 ((IMEstate & 0x04) << 3);                             /* shuffle the bits around */
      r->r[1] = flagValue & 0x0f;                               /* only return old values in spec */

      flagValue = (flagValue & r->r[2]) ^ eorValue;

      flagValue = (flagValue & 0x19) |
                  ((flagValue & 0x06) << 4) |
                  ((flagValue & 0x20) >> 3) |                       /* shuffle back to VJE format */
                  ((flagValue & 0x04) << 3);                      /* ensure tri-state value legal */

      /* despite what it claims in the spec, SET_MODE cannot be used to turn VJE on and off so .. */
      if (((flagValue ^ JapanIME_Bdata.wVjeModeFlag) & 1) != 0)        /* if on/off state changed */
        JapanIME__PutVkey(F_SCRN);                                     /* .. call VJE to toggle   */
      if (((flagValue ^ JapanIME_Bdata.wVjeModeFlag) & 0xfe) != 0)     /* other state(s) changed  */
      {
        JapanIME_Bdata.wVjeModeFlag = flagValue;   /* this may reset bit 0 to the state set above */
        JapanIME__PutVkey(F_SET_MODE);
      }
      JapanIME__CheckIMEState(IMEstate);
      break;

    case IME_Config_DispListBox:
      r->r[1] = JapanIME_Bdata.wDispListBox;    /* set (or just read if R1 < 0), delay in showing */
                                             /* candidate list (number of CNV actions); 0 = never */
      if (reg1 >= 0)
        JapanIME_Bdata.wDispListBox = reg1;
      break;

    case IME_Config_Input:                               /* set bits in the wHenModFlag structure */
      r->r[1] = JapanIME_Bdata.wHenModFlag;
      JapanIME_Bdata.wHenModFlag = (r->r[1] & r->r[2]) ^ eorValue;
      if (r->r[1] != JapanIME_Bdata.wHenModFlag)
        JapanIME__PutVkey(F_SET_MODE);
      break;

    case IME_Config_Bdata:
      r->r[1] = (int)&JapanIME_Bdata;   /* 'read-only' for displaying bdata in test program */
      break;

    default:
      return JapanIME__Fault(ERR_BadConfig);
  }
  return NULL;
}

/* ------------------------------------------------------------------------- JapanIME__SWIHandler */
_kernel_oserror *JapanIME__SWIHandler(int swi_no, _kernel_swi_regs *r, void *pw)
{
  switch (swi_no & 0x3f)
  {
    case JapanIME_ProcessInput - JapanIME_base:
      return JapanIME__ProcessInput(r);

    case JapanIME_Cancel - JapanIME_base:
      return JapanIME__Cancel(r);

    case JapanIME_GetCandidateListInfo - JapanIME_base:
      return JapanIME__GetCandidateListInfo(r);

    case JapanIME_GetCandidateListEntry - JapanIME_base:
      return JapanIME__GetCandidateListEntry(r);

    case JapanIME_Configure - JapanIME_base:
      return JapanIME__Configure(r);

    default:
      return JapanIME__SWIFault(r);
  }
}

/* --------------------------------------------------------------------- JapanIME__Initialisation */
_kernel_oserror *JapanIME__Initialisation(char *cmd_tail, int podule_base, void *pw)
{
  /* set path variable if not already set */
  _kernel_swi_regs r;
  r.r[0] = (int) JapanIME_Path;
  r.r[2] = -1;
  r.r[3] = 0;
  r.r[4] = 3;
  _kernel_swi(OS_ReadVarVal, &r, &r); /* Must use _kernel_swi because of silly error behaviour */

  if (r.r[2] == 0)
  {
    r.r[0] = (int) JapanIME_Path;
    r.r[1] = (int) JapanIME_DefaultPath;
    r.r[2] = sizeof JapanIME_DefaultPath - 1;
    r.r[3] = 0;
    r.r[4] = 0;
    _kernel_swi(OS_SetVarVal, &r, &r);
  }

  /* initialise input fields in bdata - See VACS spec */
  JapanIME_Bdata.lpchResult = (PUCHAR) JapanIME_ChResult;
  JapanIME_Bdata.lpchMode = (PUCHAR) JapanIME_ChMode;
  JapanIME_Bdata.lpattrMode = (PUCHAR) JapanIME_AttrMode;
  JapanIME_Bdata.lpchMBText = (PUCHAR) JapanIME_MBText;
  JapanIME_Bdata.lpchMBTitle = (PUCHAR) JapanIME_MBTitle;
  JapanIME_Bdata.lpchDisplay = (PUCHAR) JapanIME_ChDisplay;
  JapanIME_Bdata.lpattrDisplay = (PUCHAR) JapanIME_AttrDisplay;
  JapanIME_Bdata.lpchLBList = (PUCHAR) JapanIME_LBList;
  JapanIME_Bdata.lpchLBTitle = (PUCHAR) JapanIME_LBTitle;
  JapanIME_Bdata.cchResult = 0;
  JapanIME_Bdata.cLBItemLenMax = LB_LEN / 9;
  JapanIME_Bdata.cLBItemNumMax = 9;
  JapanIME_Bdata.cLBItemHead = 2;
  JapanIME_Bdata.wKeyType = KEY_STANDARD;
  JapanIME_Bdata.wColorType = CL_SPECIAL;
  JapanIME_Bdata.wVjeModeFlag = INP_MASK;
  JapanIME_Bdata.wCodeMax = 0x987E;
  JapanIME_Bdata.wDispListBox = 1;
  JapanIME__PutVkey(F_INIT);

  JapanIME_Bdata.lpchSramAddress = (PSZ)JapanIME_SramData;
  JapanIME_Bdata.wSramMaxSize = GAKU_SIZE;
  JapanIME__PutVkey(F_SRAM_OPEN);

  /* set 'sentance' mode, etc, */
  JapanIME_Bdata.wHenModFlag  = ( MOD_BUNSETU | MOD_GAKU | MOD_KUTEN_CNV_NO | MOD_SJIS | MOD_REN );
  JapanIME__PutVkey(F_SET_MODE);

  /* Initialise module's static data */
  JapanIME_UTF8index = 0;
  JapanIME_LastCaret = -2;
  JapanIME_LastAttrLen = 0;
  JapanIME_DictOpen = 0;
  JapanIME_Enc = NULL;
  JapanIME_KanaLockState = 0;
  JapanIME_KeyboardNumber = _kernel_osbyte(71, 255, 0) & 0xff;   /* read keyboard number */

  return NULL;
}

/* ----------------------------------------------------------------------- JapanIME__Finalisation */
_kernel_oserror *JapanIME__Finalisation(int fatal, int podule, void *pw)
{
  if (JapanIME_Enc)
    encoding_delete(JapanIME_Enc);
  JapanIME__PutVkey(F_SRAM_CLOSE);
  JapanIME__PutVkey(F_CLOSE);
  JapanIME__CloseDict();
  return NULL;
}

/* ----------------------------------------------------------------------------- JapanIME__Service */
void JapanIME__ServiceHandler(int service_number, _kernel_swi_regs *r, void *pw)
{
  if (service_number == 0x43)  /* International */
  {
    if (r->r[2] == 6)                /* new keyboard selection - get the new keyboard number in R3 */
      JapanIME_KeyboardNumber = r->r[3];
  }
}

/* ---------------------------------------------------------------------------------------------- */
