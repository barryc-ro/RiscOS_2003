/* MsgExt.c: */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "shared.h"

typedef struct stTag Tag;
typedef struct stEntry Entry;

struct stTag {
    Tag  *next;
    char *id;
    char *msg;
};

struct stEntry {
    Tag   *root;
    char  *msg;
};

/* ------------------------------------------------------------------------------------------- */
/*
static const char *chk_null(const char *s)
{
  return s ? s : "<null>";
}

static void Show_Tag(Tag *this_tag)
{
    if (this_tag == NULL)
        fprintf(stderr,"<null record>\n");
    else {
        fprintf(stderr,"Tag: '%s'\n", chk_null(this_tag->id));
        fprintf(stderr,"Msg: '%s'\n", chk_null(this_tag->msg));
        fprintf(stderr,"Lnk: %08p\n", this_tag->next);
    }
}

static void Show_Entry(Entry *this_entry)
{
    if (this_entry == NULL)
        fprintf(stderr,"<null entry>\n");
    else {
        Tag *chain = this_entry->root;
        int count=0;

        fprintf(stderr,"Msg: '%s'\n", chk_null(this_entry->msg));
        fprintf(stderr,"Root: \n");
        while (chain != NULL)
        {
           count++;
           fprintf(stderr,"Link %i:\n",count);
           Show_Tag(chain);
           chain = chain->next;
        }
    }
    fprintf(stderr,"\n");
}
*/


/* ------------------------------------------------------------------------------------------- */
Tag *New_Tag(Tag *append,char *id, char *msg)
{
    Tag *root;

    root = safe_alloc(sizeof(Tag));
    root->next = NULL;
    root->msg = msg;
    root->id = id;

    if (append != NULL) append->next = root;        /* Append to a given tag, if given */

    return root;
}


/* ------------------------------------------------------------------------------------------- */
Tag *Delete_Tag(Tag *root)
{
    Tag *next;

    if (root == NULL) return NULL;
    next = root->next;

    free_block(root->msg);
    free_block(root->id);
    free_block(root);

    return next;
}


/* ------------------------------------------------------------------------------------------- */
Entry *Read_Tokens(Entry *root,char *filename)
{
    FILE *read;

    if (root != NULL)
    {
        Tag *chain = root->root;                        /* => Entry.Root */
        while (chain != NULL)                           /* While links in the chain */
           chain = Delete_Tag(chain);

        free_block(root->msg);                          /* Free Entry.msg */
        free_block(root);                               /* Free Entry */
    }

    if (filename == NULL) return 0;                     /* Filename valid? */

    root = safe_alloc(sizeof(Entry));
    root->root = NULL;
    root->msg = str_dup_term(filename);

    if ((read=fopen(filename,"r")) != NULL)
    {
        char msgbuf[1024];
        Tag *head = NULL;

        fprintf(stderr,"Reading %s...\n",filename);

        while (fgets(msgbuf, sizeof(msgbuf), read) != NULL)
        {
            msgbuf[strcspn(msgbuf, "\n")] = '\0';

            while (strchr(msgbuf,':') == NULL && !feof(read))
            {
                if (msgbuf[0] == '#') break;
                if (strlen(msgbuf) > 1 ) msgbuf[strlen(msgbuf)-1] = '/'; else msgbuf[0] = '\0';
                fgets(&msgbuf[strlen(msgbuf)],1024-strlen(msgbuf),read);
            }

            if (msgbuf[0] != '#' && msgbuf[0] != '\0')
            {
                char *colon = strchr(msgbuf,':');

                if (colon != NULL)
                {
                    char *x = str_dup_term(msgbuf), *b = x;
                    char taglen = (int)(colon-msgbuf);
                    char *tagsep;

                    x[taglen] = '\0';

                    tagsep = strchr(b,'/');
                    while (tagsep != NULL)
                    {
                        head = New_Tag(head,str_dup_sub_term(b,0,(int)(tagsep-b)),NULL);
                        if (root->root == NULL) root->root = head;
                        b = tagsep+1;
                        tagsep = strchr(b,'/');
                    }
                    head = New_Tag(head,str_dup_term(b),str_dup_term(colon+1));
                    if (root->root == NULL) root->root = head;
                    free_block(x);
                }
                else
                {
                    report(EXIT_FAILURE, err_SERIOUS_ERROR,"Missing ':' in %s\n",filename);
                }
            }
        }
        fclose(read);
    }
    return root;
}
/* ------------------------------------------------------------------------------------------- */
int Write_Tokens(Entry *tkns)
{
    FILE *out;
    Tag *root;
    int count=0;

    if (tkns == NULL) report(2,err_SERIOUS_ERROR,"Null -> passed to Write_Tokens\n");
    if (tkns->msg == NULL)
        out = stdout;
    else
        if ((out = fopen(tkns->msg,"a")) == NULL)
            return NULL;

    if ((root = tkns->root) != NULL)
    {
        while (root != NULL)
        {
            if (root->id != NULL) fprintf(out,"%s",root->id);
            if (root->msg == NULL)
            {
                if (root->id != NULL) fprintf(out,"/");
            } else {
                if (root->id != NULL) fprintf(out,":");
                fprintf(out,"%s",root->msg);
                fprintf(out,"\n");
            }
            root = root->next;
            count++;
        }
    } else {
        report(0,err_WARN,"No tokens written\n");
        count = -1;
    }
    fclose(out);
    return count;
}


   int Expand_Tokens(Entry *subs,Entry *msgtags,Entry *only)
/* ------------------------------------------------------------------------------------------- */
{
    Tag *process = only->root;
    Tag *head = NULL;

    subs->root = NULL;

    while (process != NULL)
    {
        Tag *search = msgtags->root;
        while (search != NULL && strcmp(search->id,process->id) != NULL)
            search = search->next;

        if (search != NULL)
        {
            char clean[1024];

            if (search != NULL)
            {
                int i,p=0,l;
                l = strlen(search->msg);
                for (i=0;i<l;i++)
                {
                    switch (search->msg[i])
                    {
                    case '|':i++; clean[p]='\n'; break;
                    case '%':i++; clean[p]='\n'; break;
                    default:
                        clean[p] = search->msg[i];
                    }
                    p++;
                }
                clean[p]='\0';
            }

            head = New_Tag(head,NULL,(search->msg!=NULL?str_dup_term(clean):NULL));
            if (subs->root == NULL) subs->root = head;
        } else {
            report(0,err_ERROR,"Tag '%s' not found\n",process->id);
        }
        process = process->next;
    }

    return NULL;
}

   Entry *Read_Entry(Entry *root,FILE *in)
/* ------------------------------------------------------------------------------------------- */
{
    char msgbuf[1024];
    char *finished;
    Tag *head = NULL;

    if (root != NULL)
    {
       Tag *chain = root->root;                      /* => Entry.Root */

        while (chain != NULL)                           /* While links in the chain */
           chain = Delete_Tag(chain);

        if (root->msg != NULL) free_block(root->msg);   /* Free Entry.msg */
        free_block(root);                               /* Free Entry */
        root = NULL;                                    /* Make sure root is NULL */
    }

    root = safe_alloc(sizeof(Entry));
    root->root = NULL;
    root->msg = NULL;

    memset(msgbuf,0,1024);
    fscanf(in,"%s",msgbuf);
    while (strchr(msgbuf,':') == NULL && !feof(in)) fscanf(in,"%s",msgbuf);

    if (feof(in)) return NULL;

    msgbuf[strlen(msgbuf)-1] = '\0';
    root->msg = str_dup_term(msgbuf); /* filename of file */

    if (feof(in)) report(0,err_ERROR,"End of process file\n");

    finished = (char *)-1;
    while (finished != NULL)
    {
        char ctag[256];
        fscanf(in,"%s",&ctag);
        finished = strchr(ctag,',');
        if (finished != NULL) *finished = '\0';

        {
            char *x = str_dup_term(ctag), *b = x;
            char *tagsep;
            tagsep = strchr(b,'/');
            while (tagsep != NULL)
            {
                head = New_Tag(head,str_dup_sub_term(b,0,(int)(tagsep-b)),NULL);
                if (root->root == NULL) root->root = head;
                b = tagsep+1;
                tagsep = strchr(b,'/');
            }
            head = New_Tag(head,str_dup_term(b),NULL);
            if (root->root == NULL) root->root = head;
            free_block(x);
        }

    }
    return root;
}


int main(int argc,char *argv[])
{
    char *tokenfile = NULL, *tagsfile = NULL;
    FILE *tags;
    Entry *subs = NULL, *msgtags = NULL, *root = NULL;

    shared_init(argc, argv);
    if (argc != 3) {
      report(EXIT_FAILURE, err_INFO, "Usage: %s <tokens file> <tags file>\n", progname);
    }

    tokenfile = argv[1];                         /* -> Name of token file */
    tagsfile = argv[2];                          /* -> Name of tags file */

    tags = fopen(tokenfile, "w");                /* Don't really want tokenfile to contain anything. */
    if (tags) fclose(tags);

    subs = Read_Tokens(NULL,tokenfile);

    /* Open for reading the tags file containing all the help tokens to be extracted and */
    /* create an error if not */
    /* */
    if ((tags = fopen(tagsfile,"r")) == NULL)
        report(EXIT_FAILURE, err_SERIOUS_ERROR, "Cannot open tags file '%s'\n",tagsfile);

    while ((root=Read_Entry(root,tags)) != NULL && !feof(tags))
    {
        /* At this point Entry 'root' contain 'filename' (root->msg) and a link list */
        /* of token to be obtained from the 'filename' (root->root.id, root->root.next) */

        /* Next order of business is to read in the whole message file, compress help token, */
        /* write out message tokens and warn of any lines greater than 240 characters in */
        /* length */
        /* */
        if ((msgtags=Read_Tokens(msgtags,root->msg)) == NULL)
            report(EXIT_FAILURE, err_SERIOUS_ERROR,"Unable to access '%s' for reading\n",root->msg);

        Expand_Tokens(subs,msgtags,root);

        if (Write_Tokens(subs) == NULL)
            report(EXIT_FAILURE, err_SERIOUS_ERROR,"Unable to access '%s' for writing\n",root->msg);

    }
    /* Close open tagfile */
    fclose(tags);

    /* Discard Used Tokens */
    return 0;
}

/* End of MsgTok.c */
