/*
 * TagExtract <directory> <dictionary tag file> <!Help tag file>
 *
 * Create dictionary and !Help tag files for messages module build.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>

/* CLX */
#include "err.h"
#include "prgname.h"
#include "wholefls.h"
#include "host.h"

#ifdef RISCOS
#  include "swis.h"
#else
#  include <sys/stat.h>
#  include <dirent.h>
#endif

#ifdef RISCOS
#define BUFSZ   512
#else
#define BUFSZ   4096
#endif

#define FALSE   0
#define TRUE    ~FALSE

#define FATAL           TRUE
#define NON_FATAL       FALSE

#define STATE_DEFAULT   0
#define STATE_DICTTOK   1
#define STATE_HELPTOK   2

char dir[ BUFSZ ];
char dictfile[ BUFSZ ];
char helpfile[ BUFSZ ];
char text[ BUFSZ ];
char token0[ BUFSZ ];

char dir_sep_char;

typedef unsigned int word;

typedef struct
{
#ifdef RISCOS
        word loadaddr;
        word execaddr;
        word length;
        word attr;
#endif
        word type;
        char name[1];
} object;

#ifdef RISCOS
#define filetype( object )      (((object)->loadaddr>>8)&0xFFF)
#else
#define filetype( object )      (0xFFF)
#endif


/* Print an error and then exit.
 */
void
error( int fatal, const char *str, ... )
{
        va_list argp;

        fprintf( stderr, fatal ? "Error: " : "Warning: " );

        va_start( argp, str );
        vfprintf( stderr, str, argp );
        va_end( argp );

        if ( fatal ) exit( 1 );
}

int
gettype( char *obj )
{
        return wf_objtype(obj);
}

/* Function to compare two strings case insensitively
 *
 * Originally: sbrodie
 *
 * Parameters: matches those of strcmp.
 * Result: matches the exit conditions of strcmp.
 *
 *
 * The conversions to unsigned int stop the compiler messing around with
 * shifts all over the place whilst trying to promote the chars to int
 * whilst retaining the sign.
 *
 * Problems: Choice of return value when strings do not match is based
 *           upon character number rather than any alphabetic sorting.
 *
 */
/* Match two strings ignoring case. A partial match is allowed ie. the
 * comparison stops as soon as either terminator is reached.
 */
int strcmp_nocase(const char *first_param, const char *second_param)
{
        const unsigned char *first = (const unsigned char *) first_param;
        const unsigned char *second = (const unsigned char *) second_param;

        for (;;) {
                unsigned int a = *first++;
                unsigned int b = *second++;

                /* only if either a or b is zero is the multiplication result 0 */
                if ((a * b) == 0) return 0;

                if (a != b) {
                        /* avoid the tolower() call until we need it */
                        unsigned int c = (unsigned int) tolower(a);
                        unsigned int d = (unsigned int) tolower(b);
                        signed int result = c - d;
                        if (result != 0) return result;
                }
        }
}

/* Output a '\0' terminated string to the given file.
 */
void
output0( char *text, FILE *fp )
{
        if ( fputs(text, fp) == EOF )
                error( FATAL, "Write failed\n" );
}

/* Output a counted string to the given file.
 */
void
outputn( char *text, int n, FILE *fp )
{
        if ( fwrite(text, sizeof(char), n, fp) != n )
                error( FATAL, "Write failed\n" );
}

/* If the text passed in contains a tag then output it to the given file.
 * If first is TRUE then this is the first tag output for the current file
 * so the file name is output first, otherwise it is a continuation so a
 * comma is output before the tag. Function returns TRUE if anything was
 * output.
 */
int
output_token( char *text, int *first, FILE *fp )
{
        char *cp = strchr( text, ':' );

        if ( cp != NULL )
        {
                if ( *first )
                {
                        output0( dir, fp );
                        output0( ": ", fp );
                        *first = FALSE;
                }
                else
                {
                        output0( ", ", fp );
                }

                outputn( text, cp-text, fp );
                return TRUE;
        }

        return FALSE;
}

/* Scan the given file and output tags to the tag files as appropriate.
 */
void
scan( char *obj, FILE *dictfp, FILE *helpfp )
{
        FILE *fp = fopen( obj, "r" );

        if ( fp )
        {
                int state = STATE_DEFAULT;                      /* Initial state is no tokenisation. */
                int first_dict = TRUE, first_help = TRUE;       /* Not written to either file yet. */
                int ignore_next = FALSE;                        /* Used when buffer is not big enough for whole line. */
                long size = ftell( fp );                        /* Used to find out how much is read at one time. */

                printf( "Extracting tags from '%s'.\n", obj );

                *token0 = '\0';                                 /* No text for token 0 initially. */

                while ( fgets( text, BUFSZ, fp ) )
                {
                        size = ftell(fp) - size;

                        if ( ignore_next )
                        {
                                /* Ignoring this buffer as it is a continuation of the last line.
                                 * Only start again when end of line is found.
                                 */
                                if ( text[size-1] == '\n' )
                                        ignore_next = FALSE;
                        }
                        else
                        {
                                if ( *text == '#' )
                                {
                                        /* Found a comment so see if it is actually a directive.
                                         */
                                        if ( strcmp_nocase(text+1, "{Default}") == 0 )
                                        {
                                                state = STATE_DEFAULT;
                                        }
                                        else
                                        {
                                                if ( strcmp_nocase(text+1, "{DictTokens}") == 0 )
                                                {
                                                        state = STATE_DICTTOK;
                                                        *token0 = '\0';
                                                }
                                                else
                                                {
                                                        if ( strcmp_nocase(text+1, "{HelpTokens}") == 0 )
                                                        {
                                                                state = STATE_HELPTOK;
                                                        }
                                                        else
                                                        {
                                                                if ( strcmp_nocase(text+1, "{Token0=") == 0 )
                                                                {
                                                                        if ( state != STATE_DICTTOK )
                                                                        {
                                                                                error( NON_FATAL, "Attempt to set token 0 when not performing dictionary tokenisation in '%s'.\n", obj );
                                                                        }
                                                                        else
                                                                        {
                                                                                char *tp = text+9;      /* Skip "#{Token0=". */
                                                                                char *cp = token0;

                                                                                /* Copy string for token 0 into buffer.
                                                                                 */
                                                                                while ( *tp != '}' )
                                                                                {
                                                                                        if ( *tp < ' ' )
                                                                                                error( NON_FATAL, "Badly formed directive in '%s'\n", obj );
                                                                                        *cp++ = *tp++;
                                                                                }
                                                                                *cp = '\0';
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                                else
                                {
                                        switch ( state )
                                        {
                                                case STATE_DEFAULT:
                                                        break;

                                                case STATE_DICTTOK:
                                                        if ( output_token(text, &first_dict, dictfp) && (*token0 != '\0') )
                                                        {
                                                                /* If we have a current token 0 string then output it too.
                                                                 */
                                                                output0( ":", dictfp );
                                                                output0( token0, dictfp );
                                                        }
                                                        break;

                                                case STATE_HELPTOK:
                                                        output_token( text, &first_help, helpfp );
                                                        break;
                                        }
                                }

                                /* If no '\n' at the end of the string then the line was too big for the buffer
                                 * so ignore any more input until '\n' is found.
                                 */
                                if ( text[size-1] != '\n' )
                                        ignore_next = TRUE;
                        }

                        /* Set up size so we can work out how much is read next time round.
                         */
                        size = ftell( fp );
                }

                /* Output new lines if we wrote anything to the files.
                 */
                if ( !first_dict ) output0( "\n\n", dictfp );
                if ( !first_help ) output0( "\n\n", helpfp );

                fclose( fp );
        }
        else
        {
                error( NON_FATAL, "Couldn't open file '%s' for read\n", obj );
        }
}


/* Append leaf to path, returning truncation point to remove it again
 */
char *
appendleaf( char *path, char *leaf )
{
        path = strchr(path, '\0');
        *path = dir_sep_char;
        (void) strcpy(path+1, leaf);
        return path;
}

/* Strip leaf from path.
 */
void
stripleaf( char *path )
{
        *path = '\0';
}


typedef struct {
  object op[2];
} align_test;

#define STRUCTURE_ALIGNMENT \
  ((offsetof(align_test, op[1]) - offsetof(align_test, op[0].name)) - 1)

#ifndef RISCOS
void load_unix_directory(char *dir, char *buf, size_t bufsize, int *nread)
{
  DIR *d = opendir(dir);
  char *const leaf = appendleaf(dir, "") + 1;

  *nread = 0;

  if (!d) {
    error(FATAL, "Unable to open directory '%s'\n", dir);
  }

  for (;;) {
    struct dirent *de;
    errno = 0;
    de = readdir(d);
    if (de == NULL) {
      if (errno == 0) {
        break;
      }
      else {
        error( NON_FATAL, "Unable to read directory '%s': %s\n", dir, strerror(errno));
        break;
      }
    }
    else {
      char *last_comma, *eos;
      object *op = (object *) buf;
      int namelen;

      if (de->d_name[0] == '.' && (de->d_name[1] == '\0' || (de->d_name[1] == '.' && de->d_name[2] == '\0'))) {
        continue;
      }

      /* Find length of leafname whilst copying it */
      namelen = sprintf(leaf, "%s", de->d_name);

      if (sizeof(*op) + namelen >= bufsize) {
        error(FATAL, "out of buffer space in load_unix_directory (directory %s)", dir);
      }

      op->type = gettype(dir);
      if (op->type != 1 && op->type != 2) {
        continue;
      }
      last_comma = strrchr(leaf, ',');
      if (last_comma != NULL && strtoul(last_comma+1, &eos, 16) != 0xfff && *eos == '\0') {
        /* OK - it was a non-textual file or directory - dump it */
      }
      else {
        buf = memcpy(op->name, de->d_name, namelen) + namelen;
        do {
          *buf++ = '\0';
        } while (((int)buf)&STRUCTURE_ALIGNMENT);
        bufsize -= (buf - (char *)op);
        ++(*nread);
      }
    }
  }

  (void) closedir(d);
  leaf[-1] = '\0';
}
#endif

/* Descend into the given directory. Called recursively to scan a whole
 * directory structure.
 */
#pragma check_stack
void
descend( char *path, FILE *dictfp, FILE *helpfp )
{
        char *buf = malloc( BUFSZ );
        int offset = 0;

        if ( buf != NULL )
        {
                do
                {
                        object *op = (object *)buf;
                        int nread;

#ifdef RISCOS
                        _swi( OS_GBPB, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5)|_IN(6)|_OUT(3)|_OUT(4),
                                10, path, buf, 80, offset, BUFSZ, 0, &nread, &offset );
#else
                        offset = -1;
                        load_unix_directory(path, buf, BUFSZ, &nread);
#endif

                        while ( nread > 0 )
                        {
                                switch ( op->type )
                                {
                                        case 1:
                                                if ( filetype(op) == 0xFFF )
                                                {
                                                        /* Text file found so scan it for tags.
                                                         */
                                                        char *trunc_char = appendleaf( path, op->name );
                                                        scan( path, dictfp, helpfp );
                                                        stripleaf( trunc_char );
                                                }
                                                break;

                                        case 2: {
                                                  /* Directory found so descend into it.
                                                   */
                                                  char *trunc_char = appendleaf( path, op->name );
                                                  descend( path, dictfp, helpfp );
                                                  stripleaf( trunc_char );
                                                  break;
                                                }

                                        default:
                                                error( NON_FATAL, "Don't know how to process object type %d\n", op->type );
                                }

                                op = (object *)(((int)(op->name)+strlen(op->name)+STRUCTURE_ALIGNMENT+1)&~STRUCTURE_ALIGNMENT);
                                nread -= 1;
                        }
                } while ( offset != -1 );

                free( buf );
        }
        else
        {
                error( FATAL, "Couldn't allocate enough memory\n" );
        }
}
#pragma no_check_stack

/* Canonicalise the given file name.
 */
void
canonicalise( char *src, char *dest, int bufsz )
{
#ifdef RISCOS
        _swi( OS_FSControl, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5),
                37, src, dest, 0, 0, bufsz );
#else
        *dest = 0;
        strncat(dest, src, bufsz);
#endif
}

int
main( int argc, char *argv[] )
{
//  printf("%d\n", STRUCTURE_ALIGNMENT);
//  exit(0);
        if ( argc != 4 )
        {
                printf( "Syntax: TagExtract <directory> <dict tags> <help tags>\n" );
        }
        else
        {
                host_init();
                dir_sep_char = host_dir_sep_char();
                strcpy( dir, argv[1] );
                canonicalise( argv[2], dictfile, BUFSZ );
                canonicalise( argv[3], helpfile, BUFSZ );

                if ( gettype(dir) == 2 )
                {
                        FILE *dictfp, *helpfp;

                        if ( (dictfp = fopen(dictfile, "w")) != NULL )
                        {
                                if ( (helpfp = fopen(helpfile, "w")) != NULL )
                                {
                                        descend( dir, dictfp, helpfp );
                                        fclose( helpfp );
                                        fclose( dictfp );
                                }
                                else
                                {
                                        fclose( dictfp );
                                        error( FATAL, "'%s' could not be opened for update\n", helpfile );
                                }
                        }
                        else
                        {
                                error( FATAL, "'%s' could not be opened for update\n", dictfile );
                        }
                }
                else
                {
                        error( FATAL, "'%s' is not a directory\n", dir );
                }
        }
}
