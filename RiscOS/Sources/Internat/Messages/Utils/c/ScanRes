
/* ScanRes
 *
 * Copyright (C) Pace Micro Technology plc. 2001
 *
 */

/* Standard C headers */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <errno.h>
#include <ctype.h>
#include <time.h>

/* CLX heders */
#include "wholefls.h"
#include "err.h"
#include "host.h"
#include "prgname.h"
#include "bytesex.h"
#include "filestamp.h"

/* Local */
#include "shared.h"

#ifdef RISCOS
#  include "swis.h"
#else
#  include <sys/stat.h>
#  include <dirent.h>
#endif

#ifdef RISCOS
#define BUFSZ 512
#else
#define BUFSZ 4096
#endif

char path[ BUFSZ ];
char buffer[ BUFSZ ];

typedef int32 word;

typedef struct
{
        word next;
        word loadaddr;
        word execaddr;
        word length;
        word access;
} resfile;

typedef struct
{
        word loadaddr;
        word execaddr;
        word length;
        word attr;
        word type;
        char name[1];
} object;

char dir_sep_char;


/* Define some things needed to store exactly which territories we are storing. */
unsigned int num_of_territories = 0;                 /* The number of territories defined. */

/* Now something to store the territories we are saving */
char* territory_directories[MAX_TERRITORIES]; /* Stores the directory names */
unsigned long territory_numbers[MAX_TERRITORIES][MAX_TERRITORIES]; /*  Store the numeric representation of each territory. Array is terminated by -1. */
unsigned int num_of_territory_dirs = 0;                 /* The number of territory directories scanned. */


/* Forward prototypes */
bool find_resource_directories(const char* const root_path);
static bool convert_dir_to_numeric_form(const char* const dir_name);
char *appendleaf( char *path, char *leaf );


/*****************************************************************************
* Strcmp_ci
*
* This routine compares two string caselessly.
*
* Assumptions
*  State any assumptions and side effects (eg. globals changed)
*
* Inputs
*  a:            The first string to be compared.
*  b:            The second string to be compared.
*
* Outputs
*  None.
*
* Returns
*  0 if both strings are NULL, or both strings are (ignoring case) identical.
*  -1 if one (but not both) of the strings are NULL.
*  Any other value if the strings are different.
*****************************************************************************/

int Strcmp_ci(const char *first_param, const char *second_param)
{
        const unsigned char *first = (const unsigned char *) first_param;
        const unsigned char *second = (const unsigned char *) second_param;

        if (first == second) return 0;
        if (first == NULL || second == NULL) return -1;

        for (;;) {
                unsigned int a = *first++;
                unsigned int b = *second++;

                if (a == 0) return -b;
                if (a != b) {
                        unsigned int c = (unsigned int) tolower(a);
                        unsigned int d = (unsigned int) tolower(b);
                        signed int result = c - d;
                        if (result != 0) return result;
                }
        }
}

void error( const char *str, ... )
{
        va_list argp;

        fprintf( stderr, "ERROR: ");

        va_start( argp, str );
        vfprintf( stderr, str, argp );
        va_end( argp );

        putc('\n', stderr);

        exit(EXIT_FAILURE);
}


/*
 * malloc an area for a string and copy the string in
 */

char *strdup(const char *s1)
{
        if (s1 == NULL) {
                s1 = "";
        }
        {
                const size_t length = strlen(s1) + 1;
                char *const s2 = malloc(length);

                if (s2 == NULL) return NULL;
                return memcpy(s2, s1, length);
        }
}

int
gettype( char *obj )
{
        return wf_objtype(obj);
}


typedef struct {
  object op[2];
} align_test;

#define STRUCTURE_ALIGNMENT \
  ((offsetof(align_test, op[1]) - offsetof(align_test, op[0].name)) - 1)

#ifndef RISCOS
static void modgen_time_t_to_riscos(TimeStamp ts, int32 *load, int32 *exec)
{
        /* convert a time_t (seconds from 1 Jan 1970 00:00:00 UTC) to a RISC OS
         * date/time stamp (centiseconds from 1 Jan 1900 00:00:00 UTC)
         * The "load address" attribute used by RISCOS is equal to 0xFFFtttdd, where
         * ttt is a 12-bit file type and dd is bits 32..39 of the time stamp. This is
         * defined as the number of centiseconds since 01-Jan-1900.
         *
         * DOS and UNIX deal (in the main) with time as the number of seconds since
         * 01-Jan-1970, which is to be RISCOS time 0x33 6E99 6A00.  Hence the conversion
         * is relatively simple.   RISCOS time = 336E996A00h + 100*UNIX time
         */
        int32 t_hi, t_lo;

        t_hi = 0x336E99 + (ts >> 16) * 100;
        t_lo = 0x6A00 + (ts & 0xFFFF) * 100;

        *load = (*load & ~0xFF) | ((t_hi + (t_lo >> 16)) >> 16);
        *exec = (t_hi << 16) + t_lo;
}

/* This routine may truncate 'leaf' as a result of deriving the filetye */
static void derive_riscos_attributes(object *op, struct stat *sb, char *leaf, char *fullname, FILE *fobj)
{
  TimeStamp ts = filestamp_get(fullname);
  char *last_comma = strrchr(leaf, ',');

  op->loadaddr = 0xFFF00000;
  op->execaddr = 0;
  op->length = (int32) (sb->st_size);
  op->attr = 3;
  op->type = (sb->st_mode & S_IFDIR) ? 2 : 1;

  if (last_comma && strlen(last_comma) == 4) {
    int32 type;
    int count = -1;
    if (strcmp(last_comma+1, "lxa") == 0) {
      /* need to load the last 8 bytes to get the load/exec address, then truncate */
      op->length -= 8;
      *last_comma = '\0';
      fseek(fobj, -8L, SEEK_END);
      fread(&op->loadaddr, 4, 1, fobj);
      fread(&op->execaddr, 4, 1, fobj);
      op->loadaddr = bytesex_hostval(op->loadaddr);
      op->execaddr = bytesex_hostval(op->execaddr);
      rewind(fobj);
    }
    else if (strcmp(last_comma+1, "xxx") == 0) {
      error("File is unstable! (%s is being updated whilst this utility is running)", fullname);
    }
    else if (sscanf(last_comma+1, "%x%n", &type, &count) > 0 && count == 3) {
      *last_comma = '\0';
      op->loadaddr = 0xFFF00000 | ((type & 0xFFF) << 8);
      modgen_time_t_to_riscos(ts, &op->loadaddr, &op->execaddr);
    }
    else {
      /* Not a filetype */
      op->loadaddr = 0xFFFFFF00;
      modgen_time_t_to_riscos(ts, &op->loadaddr, &op->execaddr);
    }
  }
  else {
    op->loadaddr = 0xFFFFFF00;
    modgen_time_t_to_riscos(ts, &op->loadaddr, &op->execaddr);
  }
}


/*****************************************************************************
* load_unix_directory
*
* This routine enumerates the contents of the specified directory and stores
* the results in 'buf'.  buf has size bufsize, *nread receives the number of
* entries in the directory.  'buf' is filled with structures as returned by
* OS_GBPB 10, although not all the data is filled in (only the name and
* the objct type)
*
* Assumptions
*  the buffer is large enough to receive the details on ALL items.
*
* Inputs
*  dir:     the directory to search (must be writable!)
*  buf:     to receive the output records
*  bufsize: size of buf
*
* Outputs
*  nread:   the number of items placed in buf.
*
* Returns
*  Nothing.
*****************************************************************************/

void load_unix_directory(char *dir, char *buf, size_t bufsize, int *nread)
{
  DIR *d = opendir(dir);
  char *const leaf = appendleaf(dir, "") + 1;

  *nread = 0;

  if (!d) {
    error("Unable to open directory '%s'\n", dir);
  }

  for (;;) {
    struct dirent *de;
    errno = 0;
    de = readdir(d);
    if (de == NULL) {
      if (errno == 0) {
        break;
      }
      else {
        error("Unable to read directory '%s': %s\n", dir, strerror(errno));
        break;
      }
    }
    else {
      object *op = (object *) buf;
      int namelen;

      if (de->d_name[0] == '.' && (de->d_name[1] == '\0' || (de->d_name[1] == '.' && de->d_name[2] == '\0'))) {
        continue;
      }

      /* Find length of leafname whilst copying it */
      namelen = sprintf(leaf, "%s", de->d_name);

      if (sizeof(*op) + namelen >= bufsize) {
        error("out of buffer space in load_unix_directory (directory %s)", dir);
      }
      else {
        struct stat sb;

        op->type = gettype(dir);
        if (op->type != 1 && op->type != 2) {
          continue;
        }

        buf = memcpy(op->name, de->d_name, namelen) + namelen;
        do {
          *buf++ = '\0';
        } while (((int)buf)&STRUCTURE_ALIGNMENT);
        bufsize -= (buf - (char *)op);
        ++(*nread);
      }
    }
  }

  (void) closedir(d);
  leaf[-1] = '\0';
}
#endif

static
void riscosify_path( char *path )
{
  /* Invert the directory separator and '.' */
  for (; *path; ++path) {
    if (*path == dir_sep_char) *path = '.'; else if (*path == '.') *path = dir_sep_char;
  }
}

static void
appendfile( object *op, char *path, char *respath, FILE *fp )
{
        int32 filelen;
        int32 pathlen = 0;
        int32 totallen;
        char *fbuf, *resp, *resendp;
        FILE *rp;

#ifndef RISCOS
        struct stat sb;

        if (stat(path, &sb) == -1) {
          error("error reading attributes of '%s': %s", path, strerror(errno));
        }
#endif

        rp = fopen( path, "rb" );
        if (rp != NULL)
        {
#ifndef RISCOS
                derive_riscos_attributes(op, &sb, strrchr(path, dir_sep_char), path, rp);
#endif

                filelen = (op->length+3)&~3;                /* Aligned file length. */

                /* ResourceFS directories can contain more than 77 directory entries but ADFS
                 * directories can't. To get round this any directory starting with "Resources"
                 * (eg. Resources1, Resources2 etc.) will be reduced to "Resources" in the pathname
                 * inside ResourceFS.
                 */
                if ( (resp = strstr(respath, "Resources")) != NULL )
                {
                        if ( (resendp = strchr(resp, dir_sep_char)) != NULL )
                        {
                                /* Adjustment for pathlen as Resources* will have * stripped out. */
                                pathlen = 9-(int32)(resendp-resp);
                        }
                        else
                        {
                                resp = NULL;
                        }
                }
                pathlen = (pathlen+strlen(respath)+4)&~3;       /* Aligned ResourceFS file name length. */

                totallen = sizeof(resfile)+pathlen+sizeof(int)+filelen;

                fbuf = (char *)malloc( (size_t) totallen );

                if ( fbuf != NULL )
                {
                        resfile *rf = (resfile *)fbuf;
                        char *path = fbuf+sizeof(resfile);

                        /* Clear fbuf.  SNB: Why?? */
                        memset(fbuf, 0, (size_t) totallen);

                        /* Set up resource file header. */
                        if (bytesex_reversing()) {
                          rf->next = bytesex_hostval(totallen);
                          rf->loadaddr = bytesex_hostval(op->loadaddr);
                          rf->execaddr = bytesex_hostval(op->execaddr);
                          rf->length = bytesex_hostval(op->length);
                          rf->access = bytesex_hostval(3);
                        }
                        else {
                          rf->next = totallen;
                          rf->loadaddr = op->loadaddr;
                          rf->execaddr = op->execaddr;
                          rf->length = op->length;
                          rf->access = 3;
                        }

                        /* Copy ResourceFS file name. */
                        if ( resp != NULL )
                        {
                                /* Work out length of respath up to and including "Resources". */
                                int sublen = resp-respath+9;
                                strncpy( path, respath, sublen );

                                /* Strip out chars trailing after "Resources" up to next directory separator. */
                                strcpy( path+sublen, resendp );
                        }
                        else
                        {
                                strcpy( path, respath );
                        }
                        /* Re-convert the host directory separator to the RISC OS directory separator */
                        if (dir_sep_char != '.') riscosify_path(path);

                        /* Store file length + 4 */
                        *(int32 *)(path+pathlen) = bytesex_hostval(op->length+4);

                        /* Load resource file. */
                        if ( fread( fbuf+totallen-filelen, sizeof(char), (size_t) op->length, rp ) != op->length )
                                error( "Error reading '%s'", path );

                        if ( fwrite( fbuf, sizeof(char), (size_t) totallen, fp ) != totallen )
                                error( "Error writing to output file", NULL );
                }
                else
                {
                        error( "Not enough memory to append '%s'", path );
                }
                free( fbuf );
                fclose( rp );
        }
        else
        {
                error( "Can't open '%s' for reading", path );
        }
}


/* Append leaf to path, returning truncation point to remove it again
 */
char *
appendleaf( char *path, char *leaf )
{
        path = strchr(path, '\0');
        *path = dir_sep_char;
        (void) strcpy(path+1, leaf);
        return path;
}

/* Strip leaf from path.
 */
void
stripleaf( char *path )
{
        *path = '\0';
}

void
descend( char *path, char *respath, FILE *fp )
{
        char *buf = malloc( BUFSZ );
        int offset = 0;

//  printf("descend(): path=%s, respath=%s\n", path, respath);

        if ( buf != NULL )
        {
                do
                {
                        object *op = (object *)buf;
                        int nread;

#ifdef RISCOS
                        _swi( OS_GBPB, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5)|_IN(6)|_OUT(3)|_OUT(4),
                                10, path, buf, 80, offset, BUFSZ, 0, &nread, &offset );
#else
                        offset = -1;
                        load_unix_directory(path, buf, BUFSZ, &nread);
#endif

                        while ( nread > 0 )
                        {
                                char *trunc_char = appendleaf( path, op->name );
                                switch ( op->type )
                                {
                                        case 2:
                                                descend( path, respath, fp );
                                                break;

                                        default:
                                                appendfile( op, path, respath, fp );
                                                break;
                                }
                                stripleaf( trunc_char );
                                op = (object *)(((int)(op->name)+strlen(op->name)+STRUCTURE_ALIGNMENT+1)&~STRUCTURE_ALIGNMENT);
                                nread -= 1;
                        }
                } while ( offset != -1 );

                free( buf );
        }
        else
        {
                error( "Not enough memory to descend '%s'", path );
        }
}

/* Canonicalise the given file name.
 */
void
canonicalise( char *src, char *dest, int bufsz )
{
#ifdef RISCOS
        _swi( OS_FSControl, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5),
                37, src, dest, 0, 0, bufsz );
#else
        *dest = 0;
        strncat(dest, src, bufsz);
#endif
}


/* Write a number in word form toa file pointer. */
void
fwriteword( unsigned long param_n, FILE *fp )
{
        const unsigned int n = (unsigned int) param_n;

        putc(((n >>  0) &0xFF), fp);
        putc(((n >>  8) &0xFF), fp);
        putc(((n >> 16) &0xFF), fp);
        putc(((n >> 24) &0xFF), fp);
}



/* Under the new scheme, we wish to store each of the territory directories
    in the structure in the following way.
   Note that one resource block can be used by more than one country, eg.
    the USA and UK may share resource blocks as they may well be indentical.

      |-----------|
      |     1     | Header. One word per territory held in the following block. Each number
      |     4     |  is the corresponding country code for the territory, with 0 being the common block.
      |    -1     | The list is terminated with a -1.
      |-----------|
      | Resources |  The resources block for this country.
      |           |
      |           |
      |-----------|
      |     0     |  End of this resourcefs chain.
      |-----------|
      |     0     |  Another country (this one is the common one)
      |    -1     |
      |-----------|
      | Resources |  Another resources block
      |           |
      |           |
      |-----------|
      |     0     |  End of this resourcefs chain.
      |-----------|
      |    -1     |  Block terminator.
      |-----------|

     Hence we introduce a wrapper around the original code, calling it once
for each different territory block that we wish to add. Simple, eh?
*/

int main( int argc, char *argv[] )
{
  unsigned int loop;
  FILE *fp = NULL;
  static char path2[BUFSZ];

  if ( argc != 3 )
  {
    error( "Syntax: scanres <directory> <file>", NULL );
  }

  host_init();
  dir_sep_char = host_dir_sep_char();
  bytesex_reverse_auto(bytesex_WANT_LITTLE_ENDIAN);

  printf("Scanning from directory %s\n", argv[1]);

  /* Canonicalise directory path. */
  canonicalise(argv[1], path, BUFSZ);

  /* Read all the directory names.
     If a directory is numeric, ten it contans 1 or more territories (eg. 0001 would have both Common (00) and UK (01) resource blocks
     If it is a string, then it is a country name. Pass it in to Territory_NumberToName to get te numeric value. If it does not exist, throw an error.
  */
  find_resource_directories(path);

  /* Canonicalise output file path. */
  canonicalise(argv[2], buffer, BUFSZ);

  /* Open the output file for writing the resource blocks to. */
  if ((fp=fopen( buffer, "wb" )) == 0)
  {
    error("Could not open %s for writing\n", buffer);
  }

  /* Parse through all the directories that have been stored, writing the
      relevant data to the block before appending the data. */
  for (loop=0; loop < num_of_territory_dirs; loop++)
  {
    unsigned int index = 0;
    printf("Directory %d is %s (territory numbers: ", loop, territory_directories[loop]);
    /* Write the list of territories this block is suitable for:
    * zero means any; list terminated by -1.
    */
    do
    {
      printf("%ld ", territory_numbers[loop][index]);
      fwriteword(territory_numbers[loop][index++], fp);
    }
    while (territory_numbers[loop][index]!=-1);
    fwriteword(-1, fp); /* Terminate the header territory list. */
    printf(")\n");

    strcpy(path2, path);
    (void) appendleaf(path2, territory_directories[loop]);
    printf ("Appending data for territory resource dir %s\n", path2);

    if ( gettype(path2) == 2 ) /* It must obviously be a directory */
    {
      descend( path2, path2+strlen(path2)+1, fp );

      /* Add on a zero-word to mark end of ResourceFS chain */
      fwriteword( 0, fp );
    }
    else
    {
      error( "'%s' is not a directory", path );
    }
  }

  /* And a -1 to mark end of block sequence */
  fwriteword( -1, fp );

  /* Close the output file. */
  if (fclose(fp) == EOF) {
    error( "Error writing output file!\n" );
    exit(EXIT_FAILURE);
  }

  exit(EXIT_SUCCESS);
}


/*
  This routine scans through root_path and places all directories held within
it into the territory_directories array. It then parses through the directory
entries and converts the entries into numeric form.
  It returns false if no valid resource directories were located in root_path.
*/

bool find_resource_directories(const char* const root_path)
{
  /* Recurse from path. */
  char *buf = malloc( BUFSZ );
  int offset = 0;

  if ( buf != NULL )
  {
    do
    {
      object *op = (object *)buf;
      int nread;

#ifdef RISCOS
      _swi( OS_GBPB, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5)|_IN(6)|_OUT(3)|_OUT(4),
              10, path, buf, 80, offset, BUFSZ, 0, &nread, &offset );
#else
      offset = -1;
      load_unix_directory(path, buf, BUFSZ, &nread);
#endif

      while ( nread > 0 )
      {
        char *const trunc_char = appendleaf( path, op->name );
        switch ( op->type )
        {
           case 2:
             printf("Directory is %s\n", path);
             convert_dir_to_numeric_form(op->name);
             break;
        }
        stripleaf( trunc_char );
        op = (object *)(((int)(op->name)+strlen(op->name)+STRUCTURE_ALIGNMENT+1)&~STRUCTURE_ALIGNMENT);
        nread -= 1;
      }
    } while ( offset != -1 );

    free( buf );
  }
  else
  {
    error( "Not enough memory to descend '%s'", path );
  }

  return (true);
}



/* Convert the directory name passed in to a numeric form.
   If the directory name is in numeric form, then it converts every two
digits into a unique territory number (eg. 0105 represents territories 1 and
5). Textual names (eg. UK or France) get sent to Service_International to be
converted to a numeric representation.
   The name 'Common' is a special case; if this is seen, then it is given the
territory number of 0 as expected within the specification.
   If there is an error, return false.
*/
static bool convert_dir_to_numeric_form(const char* const dir_name)
{
  unsigned int loop=0;
  bool is_numeric = true;
  bool success = true;

  /* Firstly, is this a numeric filename? */
  for (loop=0; loop<strlen(dir_name); loop++)
  {
    if (!isdigit(dir_name[loop])) /* It is not a numeric digit */
    {
      is_numeric = false;
    }
  }

  if (is_numeric) /* Split this into a series of two-digit country codes. */
  {
    char tempstr[4];
    unsigned int length = strlen(dir_name);
    unsigned int index = 0;
    unsigned int count = 0;
    do
    {
      unsigned int eval_result;
      tempstr[0] = dir_name[index++];
      tempstr[1] = dir_name[index++];
      tempstr[2] = '\0';
      eval_result = (int) strtol(tempstr, NULL, 10);
      territory_numbers[num_of_territory_dirs][count++] = eval_result;
      printf ("Index = %d  number=%d\n", index, eval_result);
    }
    while (index < length); /* Until we reach the end of the string. */
    territory_numbers[num_of_territory_dirs][count++] = -1; /* Terminate the list. */
  }
  else /* Is a named country. Convert to a territory number. */
  {
    unsigned long territory_number;
    if (Strcmp_ci(dir_name, "Common") == 0) /* It is the common dir */
    {
      territory_number = 0; /* Country code representing the Common dir */
    }
    else
    {
      if ((territory_number = return_country_number(dir_name)) == -1)
      {
        /* Unrecognised country name */
        success = false;
      }
    }
    printf("Country code for %s is %ld\n", dir_name, territory_number);
    territory_numbers[num_of_territory_dirs][0] = territory_number;
    territory_numbers[num_of_territory_dirs][1] = -1; /* Terminate the list. */
  }

  territory_directories[num_of_territory_dirs] = strdup(dir_name);
  /* Move onto the next part of the territory list. */
  num_of_territory_dirs++;

  return (success);
}
