/*****************************************************************************
* $Id$
* $Name$
*
* Author:  David Cotton
* Project: Bethany (333)
*
* ----------------------------------------------------------------------------
* Copyright [2000] Pace Micro Technology PLC.  All rights reserved.
*
* The copyright in this material is owned by Pace Micro Technology PLC
* ("Pace").  This material is regarded as a highly confidential trade secret
* of Pace.  It may not be reproduced, used, sold or in any other way exploited
* or transferred to any third party without the prior written permission of
* Pace.
*
* ----------------------------------------------------------------------------
* Purpose: This file contains source code required for the ResCommon utility.
*           This utility implements some of the functionality required for
*           the Multiple Resource sets in RISC OS ROMS (see spec 2503,027/FS).
*          This utlity scans through a set of resource directories and strips
*           out all the common files into a series of Common directories.
*
* ----------------------------------------------------------------------------
* History: See source control system log
*
*****************************************************************************/


/*****************************************************************************
* Include header files
*****************************************************************************/
/* Include Standard headers */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <stdbool.h>
#include <assert.h>
#include <errno.h>
#include <ctype.h>

/* CLX */
#include "wholefls.h"
#include "host.h"
#include "filestamp.h"
#include "err.h"

/* Include RISC OS headers */
#ifdef RISCOS
#  include "swis.h"
#else
#  include <sys/stat.h>
#  include <dirent.h>
#endif

/* Local headers */
#include "shared.h"

/*****************************************************************************
* MACROS
*****************************************************************************/
#define MAX_OPEN_TERRITORY_FILES MAX_TERRITORIES   /* This value matches the available number of territories defined in the spec */
#define FileType_Squash                          (0xfca)
#define FileType_Sprite                          (0xff9)

#ifdef RISCOS
#  define BUFSZ   512                   /* Old value needed by cut & paste code. */
#else
#  define BUFSZ   4096
#endif

#define MAX_PATH_SIZE BUFSZ           /* Maximum path lengths allowed in strings. */
#define filetype( object )      (((object)->loadaddr>>8)&0xFFF)


/*****************************************************************************
* New enumerated types
*****************************************************************************/
typedef unsigned int word;

/* Structure in which to hold the file information for a file */
typedef struct
{
  word loadaddr;
  word execaddr;
  word length;
  word attr;
  word type;
  char name[1];
} object;

/* The structure below defines a type that can be used to hold squash file headers as
    defined in PRM 4 Appendix E */
typedef struct
{
  char id[4];
  int size;
  int load_addr;
  int exec_addr;
  int reserved;
} squash_header_struct;


/* This structure holds the details of which files held in the resources are
    identical. */
typedef struct
{
  int   file_num[MAX_TERRITORIES];   // The file number this refers to, 0 to MAX_TERRITORIES-1
  int   array_size;                  // The number of entries in this array. -1 is a special value.
} list;

/* This structure holds a list of the above structures. This allows a number
    of resource files to be seen as being identical. Each set of identical
    resource files is held in it's own list. */
typedef struct
{
  list lists[MAX_TERRITORIES]; // There has to be a maximum of MAX_TERRITORIES list.
} list_of_lists;

list_of_lists* main_list;

/*****************************************************************************
* Constants
*****************************************************************************/

typedef struct {
  object op[2];
} align_test;

#define STRUCTURE_ALIGNMENT \
  ((offsetof(align_test, op[1]) - offsetof(align_test, op[0].name)) - 1)



/*****************************************************************************
* File scope Global variables
*****************************************************************************/
unsigned int num_of_territories = 0;                 /* The number of territories defined. */
char* root_resources_directory = NULL;
char* root_processed_directory = NULL;
char* directory_to_copy = NULL;
char* compared_files[MAX_TERRITORIES];               /* An array in which to store the filenames of the files to be compared. */
bool  verbose = false;                               /* Do you wish to see what it is doing? */
bool  simulate = false;                              /* Do not actually delete any files. */
char* common_directory = NULL;                       /* Stores the path relating to the 'common' resource set. */
bool  uk_resources_present = false;                  /* Set to true if locale_list includes "UK" */

char  dir_sep_char;                                  /* Host directory separator */

/*****************************************************************************
* Function prototypes - Private to this file
*****************************************************************************/
unsigned long int filer_object_type(const char* filename);
static char *str_rc_dup(const char *str, size_t);
static bool do_mkdir(char *dir1);
static bool ensure_resource_directories_exist(void);
int  get_filetype(char* obj);
static char *appendleaf( char *path, const char *leaf );
static char *stripleaf( char *path );
static int  cstrcmp(const char* a, const char *b);
static int  cnstrcmp(const char *first_param, const char *second_param, size_t limit);
static void help_text(void);
bool compare_squash_files(void);

void test_file_comparisons(void);


void         main_list_create_initial(unsigned int num_of_territories);
void         main_list_initialise(list_of_lists* main_list, unsigned int num_of_territories);
void         main_list_display(list_of_lists* list_to_display, unsigned int num_of_territories);
void         main_list_display_node_num(list_of_lists* main_list_to_display, unsigned int list_to_display);
unsigned int list_create_new(list_of_lists* list_to_alter, const char char_to_enter, unsigned int num_of_territories);
void         sublist_parse(list* this_list, list_of_lists* new_list, const unsigned int* const file_line, unsigned int num_of_territories);
unsigned int main_list_count_nodes(list_of_lists* list, unsigned int num_of_territories);

void         compare_file_contents(const unsigned int* const string, unsigned int num_of_territories);


/*****************************************************************************
* Functions
*****************************************************************************/



/*********************************************************************************/
/* file_copy                                                                     */
/*                                                                               */
/* This routine copies files/directories                                         */
/*                                                                               */
/* Parameters: source   The source file/directory                                */
/*             dest     The destination file/directory                           */
/*                                                                               */
/* Returns:    It returns true if the copy succeeded, false otherwise.           */
/*                                                                               */
/*********************************************************************************/
bool file_copy(char* source, char* dest)
{
#ifdef RISCOS
  return (_swix(OS_FSControl, _INR(0,3), 26, source, dest, 3/*FR~C~V~N*/) == NULL);
#else
  char command[BUFSZ];
  sprintf(command, "cp -pfr %s %s", source, dest);
  return (system(command) == 0);
#endif
}





/*********************************************************************************/
/* filer_object_type                                                             */
/*                                                                               */
/* This routine returns the type of the filer object corresponding to the        */
/*  filename passed in.                                                          */
/*                                                                               */
/* Parameters: filename  This is the filename of the file to be checked.         */
/*                                                                               */
/* Returns:    It returns : 0 for no such object                                 */
/*                          1 for a file object                                  */
/*                          2 for a directory object                             */
/*                          3 for an image object                                */
/*                                                                               */
/*********************************************************************************/
unsigned long int filer_object_type(const char* filename)
{
  return wf_objtype(filename);
}





/*****************************************************************************
* str_rc_dup
*
* This routine malloc's an area for a string and copy the string in
* optionally with some extra spare bytes allocated.
*
* Assumptions
*  uses malloc; the memory allocated must be free'd at some point.
*
* Inputs
*  str         : The string to be copied (or NULL => empty string)
*  n           : Extra space to allocate
*
* Outputs
*  none
*
* Returns
*  A pointer to the copy of the string
*  This function cannot fail - it will abort the program in preference
*****************************************************************************/
static char *str_rc_dup(const char *s1, const size_t extra_to_allocate)
{
        if (s1 == NULL) {
                s1 = "";
        }
        {
                const size_t length = strlen(s1) + 1;
                return memcpy(safe_alloc(length + extra_to_allocate), s1, length);
        }
}




/*****************************************************************************
* parse_territory_callback
*
* This routine stores the parsed territories into the global supported_territories
* array.  It is passed as the callback function to parse_territories.
*
* Assumptions
*  None.
*
* Inputs
*  name:    the territory name
*  num:     that territory's number
*  data:    the void* parameter passed to parse_territories
*
* Outputs
*  None.
*
* Returns
*  A boolean describing whether or not the territory line was parsed
*   successfully.
*****************************************************************************/

static void parse_territory_callback(const char *name, unsigned long num, void *data)
{
  (void) data;
  (void) num;
  printf("territory is %s\n", name);
  supported_territories[num_of_territories++] = str_rc_dup(name, 0);
}






/*****************************************************************************
* do_mkdir
*
* This routine creates the directory passed in.
*
* Assumptions
*  That the directory immediately below the one to be created exists. If it
*   does not then the directory will fail to be completed.
*
* Inputs
*  dir1          : A pointer to a string containing the root directory to be
*                   created
*
* Outputs
*  Will create the directory if all conditions are met.
*
* Returns
*  A boolean describing whether or not the system call was called successfully.
*
*****************************************************************************/
static bool do_mkdir(char *dir1)
{
#ifdef RISCOS
  return (_swix(OS_File, _INR(0,1)|_IN(4), 8, dir1, 256) == NULL);
#else
  if (mkdir(dir1, 0755) < 0) {
    if (errno == EEXIST) {
      return true;
    }
    else {
      char *last_dir_sep = stripleaf(dir1);
      fprintf(stderr, "mkdir fails: %s - trying parent\n", strerror(errno));
      if (last_dir_sep) {
        bool result = do_mkdir(dir1);
        *last_dir_sep = dir_sep_char;
        return result;
      }
      else {
        return false;
      }
    }
  }
  else {
    return true;
  }
#endif
}





/*****************************************************************************
* load_unix_directory
*
* This routine enumerates the contents of the specified directory and stores
* the results in 'buf'.  buf has size bufsize, *nread receives the number of
* entries in the directory.  'buf' is filled with structures as returned by
* OS_GBPB 10, although not all the data is filled in (only the name and
* the objct type)
*
* Assumptions
*  the buffer is large enough to receive the details on ALL items.
*
* Inputs
*  dir:     the directory to search (must be writable!)
*  buf:     to receive the output records
*  bufsize: size of buf
*
* Outputs
*  nread:   the number of items placed in buf.
*
* Returns
*  Nothing.
*****************************************************************************/
#ifndef RISCOS
void load_unix_directory(char *dir, char *buf, size_t bufsize, int *nread)
{
  DIR *d = opendir(dir);
  char *const leaf = appendleaf(dir, "") + 1;

  *nread = 0;

  if (!d) {
    err_fail("Unable to open directory '%s'\n", dir);
  }

  for (;;) {
    struct dirent *de;
    errno = 0;
    de = readdir(d);
    if (de == NULL) {
      if (errno == 0) {
        break;
      }
      else {
        err_fail("Unable to read directory '%s': %s\n", dir, strerror(errno));
        break;
      }
    }
    else {
      object *op = (object *) buf;
      int namelen;

      if (de->d_name[0] == '.' && (de->d_name[1] == '\0' || (de->d_name[1] == '.' && de->d_name[2] == '\0'))) {
        continue;
      }

      /* Find length of leafname whilst copying it */
      namelen = sprintf(leaf, "%s", de->d_name);

      if (sizeof(*op) + namelen >= bufsize) {
        err_fail("out of buffer space in load_unix_directory (directory %s)", dir);
      }
      else {
        struct stat sb;

        op->type = filer_object_type(dir);
        if (op->type != 1 && op->type != 2) {
          continue;
        }

        buf = memcpy(op->name, de->d_name, namelen) + namelen;
        do {
          *buf++ = '\0';
        } while (((int)buf)&STRUCTURE_ALIGNMENT);
        bufsize -= (buf - (char *)op);
        ++(*nread);
      }
    }
  }

  (void) closedir(d);
  leaf[-1] = '\0';
}
#endif





/*****************************************************************************
* resolve_unix_filetypes
*
* This routine examines the specified name to see if the directory contains
* a filename which matches but with a different RISC OS type.
*
* Assumptions
*  none
*
* Inputs
*  file          : A pointer to the filename
*
* Outputs
*  size          : The size of the file (or -1 if unable to find the file)
*
* Returns
*   true if the file existed and the information could be read, false otherwise.
*
*****************************************************************************/
#ifndef RISCOS
static bool resolve_unix_filetypes(char *name, unsigned int *size)
{
  DIR *d;
  bool result = false;

  char *end_of_dir = stripleaf(name);
  d = opendir(name);
  *end_of_dir++ = dir_sep_char;

  if (d != NULL) {
    /* end_of_dir is now the leafname we are looking to match */
    int type = get_filetype(end_of_dir);
    /* Calculate the initial amount of string to match */
    const size_t length = strlen(end_of_dir) - 4 * (type != 0xFFF);

    while (result == false) {
      struct dirent *de = readdir(d);
      if (de == NULL) {
        /* Either an error or end of directory - don't care which */
        break;
      }
      else {
        if (cnstrcmp(end_of_dir, de->d_name, length) == 0) {
          /* Might have found a match */
          char *end_of_d_name = de->d_name + length;
          if (*end_of_d_name == '\0' || (*end_of_d_name == ',' && strlen(end_of_d_name) == 4)) {
            /* Found a match, update the filename and return true */
            (void) strcpy(end_of_dir, de->d_name);
            result = true;
          }
        }
      }
    }
    closedir(d);
  }

  return result;
}
#endif






/*****************************************************************************
* retrieve_file_details
*
* This routine returns the size of the file represented by the filename
*  passed in and the filetype.  If the file does not exist but a file
*  with a different filetype *does* exist, then we *alter* the name
*  and file in the correct filetype.
*
* Assumptions
*  This routine falls foul of the normal RISC OS limitation of a file
*   not being larger than the size of an unsigned integer.
*
* Inputs
*  file          : A pointer to the filename
*
* Outputs
*  filetype      : The RISC OS filetype
*  size          : The size of the file
*  path          : May have been updated on UNIX systems to reflect the real filename
*
* Returns
*   true if the file existed and the information could be read, false otherwise.
*
*****************************************************************************/
static bool retrieve_file_details(char *name, unsigned int *filetype, unsigned int *size)
{
  *size = (unsigned) wf_filesize(name);

#ifndef RISCOS
  if (*size == -1 && !resolve_unix_filetypes(name, size)) {
    return false;
  }
#endif

  if (*size != -1) {
    /* Derive the filetype */
    *filetype = get_filetype(name);
    return true;
  }
  else {
    return false;
  }
}






/*****************************************************************************
* ensure_resource_directories_exist
*
* This routine scans through the list of territories and ensures that the
*  required resource directories all exist. It does this by checking that
*  <root_resources_directory>.<territory_name> is a valid directory.
*
* Assumptions
*  There should be no effect outside this routine.
*
* Inputs
*  None.
*
* Outputs
*  None.
*
* Returns
*  A boolean, true if the resource directories existed in the correct
*   location, false otherwise.
*****************************************************************************/
static bool ensure_resource_directories_exist(void)
{
  unsigned int loop;
  char buffer[BUFSZ]; /* Nasty hardcoded value */
  for (loop=0; loop < num_of_territories; loop++)
  {
    sprintf(buffer, "%s%c%s", root_resources_directory, dir_sep_char, supported_territories[loop]);
    printf ("Checking for %s.\n", buffer);
    if (filer_object_type(buffer) != 2)
    {
      printf("Warning: %s is not a directory.\n", buffer);
      return (false);
    }
  }

  return (true);
}







/*****************************************************************************
* get_filetype
*
* This routine returns the filetype of the object to pointed to by obj.
*
* Assumptions
*  It is assumed that the object pointed to by obj exists and is a file; if
*   not then -1 is returned.
*
* Inputs
*  obj :         The object we require the filetype of.
*
* Outputs
*  None.
*
* Returns
*  The filetype, or -1 if the file does not exist.
*****************************************************************************/

int get_filetype(char* obj)
{
  int type = 0xfff;

#ifdef RISCOS
  int load_addr;
  _swi( OS_File, _IN(0)|_IN(1)|_OUT(2), 17, obj, &load_addr );
  type = (load_addr>>8)&0xFFF;
#else
  obj = strrchr(obj, ',');
  if (obj && strlen(obj) == 4) {
    int count;

    ++obj;

    if (memcmp(obj, "lxa", 3) == 0) {
      /* need to load the last 8 bytes to get the load/exec address, then truncate */
      err_fail("Sorry - I cannot cope with files that have an explicit load+exec address");
    }
    else if (memcmp(obj, "xxx", 3) == 0) {
      err_fail("Files are unstable - being updated whilst this program is running!");
    }
    else if (sscanf(obj, "%x%n", &type, &count) > 0 && count == 3) {
      /* Got one! */
    }
    else {
      /* Not a filetype */
      type = 0xfff;
    }
  }
#endif
  return (type);
}







/*****************************************************************************
* appendleaf
*
* This routine appends the leaf passed in onto the end of the path.
*
* Assumptions
*  This routine assumes that the area of memory that holds path is large
*   enough to hold the alterd string. No bounds checking is performed.
*   The address of the appended terminator is returned to optimise the
*   removal (via stripleaf) of this leafname (although NOTE that if 'leaf'
*   contains directory separators, stripleaf won't overwrite the dir sep
*   that is returned by this function).
*
* Inputs
*  path :        The path for the leaf to be appended to.
*  leaf :        The leafname to be appended.
*
* Outputs
*  The new path with the leaf appended.
*
* Returns
*  The address of the appended directory separator
*****************************************************************************/
static char *appendleaf( char *path, const char *leaf )
{
  path = strchr(path, '\0');
  *path = dir_sep_char;
  (void) strcpy(path+1, leaf);
  return path;
}





/*****************************************************************************
* stripleaf
*
* This function strips the last leaf segment off the path passed in.
* The filename seperator is taken to be the '.' character
*
* Assumptions
*  If there are no seperator ('.') characters in the string, then the string
*   is unaltered.
*
* Inputs
*  path :        The path to be truncated.
*
* Outputs
*  path :         The truncated path.
*
* Returns
*  The address of the separator it just obliterated.
*
*****************************************************************************/
static char *stripleaf( char *path )
{
  char *sep = strrchr( path, dir_sep_char );

  if (sep != NULL)
  {
    *sep = '\0';
  }

  return sep;
}





/*****************************************************************************
* perform_comparisons
*
* This routine opens all the files held in the compared_files array and
*  attempts to compare them. It checks files are identical by the following
*  means:
*   1) Compare filetypes and sizes.
*   2) Open all the files
*   3) Read all the files byte-by-byte, compareing them, until a difference
*       is detected or the end of the file is reached.
*   4) Close all the files.
* Note that files of type Squash are treated differently due to the fact
*  that identical files that have been squashed at different times will end
*  up with different header data.
* If a file is identical in (say) UK and France but not in Germany, then the
*  file will be placed in a UK,France directory and also in the Germany
*  directory. This reduces the commanlity of the files to the minimum possible.
* If a file is identical in all files, then it gets placed into a directory
*  that is common between all resource sets.
*
* Assumptions
*  That the number of files to be opened is less than MAX_OPEN_TERRITORY_FILES.
*
* Inputs
*  None.
*
* Outputs
*  None.
*
* Returns
*  This routine returns true if all the files are the same, false otherwise.
*****************************************************************************/
static bool perform_comparisons(char* path_leaf, unsigned int filesize[MAX_OPEN_TERRITORY_FILES], unsigned int filetype[MAX_OPEN_TERRITORY_FILES])
{
  FILE* file_handles[MAX_OPEN_TERRITORY_FILES] = { NULL }; /* An array to hold all the file handles */
  unsigned int loop;
  bool file_matches = true;
  unsigned int main_list_loop;
  unsigned int file_byte_count = 0; /* Stores the number of bytes we are through the file. */

  assert (path_leaf != NULL);

  /* Initialise all the memory */
  main_list = safe_alloc(sizeof(list_of_lists));
  main_list_initialise(main_list, num_of_territories);
  main_list_create_initial(num_of_territories);  /* Create a list with all files being identical. */

  /* Ensure that all the files exist and grab their filesizes and filetypes.*/
  for (loop=0; loop < num_of_territories; loop++)
  {
    assert (compared_files[loop] != NULL); /* Check we are not going to try to open a NULL pointer... */

    /* Ensure that all the files exist. */
  }

  /* Now set up the initial list with the data held in the filetype and filesizes. */
  compare_file_contents(filetype, num_of_territories);
  compare_file_contents(filesize, num_of_territories);

  /* Open all the files. */
  for (loop=0; loop < num_of_territories; loop++)
  {
    /* Open the file.. */
    if ((file_handles[loop]=fopen(compared_files[loop],"r")) == NULL)
    {
      if (verbose)
        printf("Error opening file %s for reading.\n", compared_files[loop]);

      /* Let's close the files that we *did* manage to open */
      while (--loop != -1u) {
        (void) fclose(file_handles[loop]);
      }

      return (false); /* If we can't open it, we are not bothered... (atm neway) */
    }
  }

  /* Scan through all the files on a byte-by-byte basis, comparing them. */
  while (!feof(file_handles[0]) && file_matches)
  {
    unsigned int bytes[MAX_OPEN_TERRITORY_FILES+1]; /* To hold the bytes from all the files... */
    bool ignore_line = false; /* Set if we wish to ignore a line of a file for some reason. */
    file_byte_count++;

    /* Another check - if the files are squash files, then they will always be
       different due to header differences. Ignore the headers. */
    if (file_byte_count < sizeof(squash_header_struct))
    {
      if (filetype[0] == FileType_Squash)
      {
        ignore_line = true;
      }
    }

    /* In the future we may wish to treat spritefiles differently. This is a
        conditional to check for the presence of a spritefile. */
    if (filetype[0] == FileType_Sprite)
    {
      /* Do some magic munging here. We could possibly split all common sprites
          held within the spritefiles into a 'common' file to save ROM space. */
    }

    /* Fill up the string with the bytes from the files. */
    if (!ignore_line) /* We wish to diff this line. */
    {
      for (loop=0; loop<num_of_territories; loop++)
      {
        bytes[loop] = (unsigned int) getc(file_handles[loop]);
      }
      bytes[loop+1]=(unsigned int)'\0';

      /* Perform the comparisons */
      compare_file_contents(bytes, num_of_territories);

      /* If we have n lists, they must all be different files. No need to parse anymore. */
      if (main_list_count_nodes(main_list, num_of_territories) == num_of_territories)
      {
        if (verbose)
        {
          printf ("All files are different. Exiting early.\n");
        }
        break;
      }
    }
  }

  /* Display the results */
  if (verbose)
  {
    printf("List condition after parsing all the files (file %s)...\n", path_leaf);
    main_list_display(main_list, num_of_territories);
  }

  /* Collate the result into a series of directories that the files have to be
      copied into. */
  for (main_list_loop=0; main_list_loop<num_of_territories; main_list_loop++)
  {
    char directory_string[(MAX_TERRITORIES*2)+1]; /* Each territory can have two characters, and the string needs a terminator */
    char destination_directory[MAX_PATH_SIZE];    /* Nasty hardcoded limit */
    list *this_list = &main_list->lists[main_list_loop];

    /* Create the directory string relating to this particular list of
        directories */
    *directory_string = '\0'; /* Initialise the string */
    if (this_list->array_size > 0) /* We do not wish to display empty lists. */
    {
      unsigned int sublist_loop;
      for (sublist_loop=0; sublist_loop < this_list->array_size; sublist_loop++)
      {
        if (this_list->file_num[sublist_loop] >= 0) /* Do not display empty locations */
        {
          char tempstr[7];
          unsigned long terr_number = return_country_number(supported_territories[this_list->file_num[sublist_loop]]);
          //printf (" %d (%s, country code %d)", this_list->file_num[sublist_loop], supported_territories[this_list->file_num[sublist_loop]], terr_number);
          if (!uk_resources_present && this_list->file_num[sublist_loop] == 0)
          {
            /* We wish to add UK territory number (01) onto the first territory */
            sprintf(tempstr, "%02ld01", terr_number);
            strcat(directory_string, tempstr);
          }
          else
          {
            sprintf(tempstr, "%02ld", terr_number);
            strcat(directory_string, tempstr);
          }
        }
      }

      /* printf ("directory string is %s\n", directory_string); Debug line */

      /* If the directory string is the same as the common one, then change
          it's name to 'common' */
      if (strcmp(directory_string, common_directory) == 0) /* They match */
      {
        assert (common_directory != NULL);
        // printf("%s is the common resource set. Renaming the directory path to 00.\n", directory_string);
        strcpy(directory_string, "Common");
      }

      /* Create the directory and copy the resources over. */
      sprintf(destination_directory, "%s%c%s", root_processed_directory, dir_sep_char, directory_string);
      do_mkdir (destination_directory);
      for (sublist_loop=0; sublist_loop < this_list->array_size; sublist_loop++)
      {
        if (this_list->file_num[sublist_loop] >= 0) /* Do not display empty locations */
        {
          char dir_to_create[MAX_PATH_SIZE];
          char src_file[MAX_PATH_SIZE];
          /* Ensure the relevant directory exists. */
          sprintf(dir_to_create, "%s%c%s", destination_directory, dir_sep_char, path_leaf);
          (void) stripleaf(dir_to_create);
          do_mkdir(dir_to_create);
          sprintf(dir_to_create, "%s%c%s", destination_directory, dir_sep_char, path_leaf);
          sprintf(src_file, "%s%c%s%c%s", root_resources_directory, dir_sep_char,
            supported_territories[this_list->file_num[sublist_loop]], dir_sep_char, path_leaf);
          file_copy(src_file, dir_to_create);
        }
      }
    }
  }

  /* Close all the files */
  for (loop=0; loop < num_of_territories; loop++)
  {
    if (file_handles[loop])
    {
      fclose(file_handles[loop]);
    }
  }

  /* Free off the memory. */
  free (main_list);

  return (file_matches);
}




/* A helper function that puts three bits of a path together optimally
 * 4 extra bytes are allocated to ensure we have space to append a UNIX filetype indicator
 * (which is ,xxx)
 *
 */
#pragma no_check_stack
static char *compare_files_construct_path(const char *part1, const char *part2, const char *part3)
{
  const size_t lpart1 = strlen(part1)+1;
  const size_t lpart2 = strlen(part2)+1;
  const size_t lpart3 = strlen(part3)+1;
  char *result;

  result = memcpy(safe_alloc(lpart1 + lpart2 + lpart3 + 4), part1, lpart1);
  (void) memcpy(result + lpart1, part2, lpart2);
  (void) memcpy(result + lpart1 + lpart2, part3, lpart3);
  result[lpart1 + lpart2 - 1] = result[lpart1 - 1] = dir_sep_char;

  return result;
}
#pragma check_stack




/*****************************************************************************
* compare_files
*
* This routine takes the path passed in and compares it with the other
*  resource sets. E.g. if a file ...UK.Foo was passed in, and the LocaleList
*  was set to UK,France,Germany it would compare ...Common.Foo, ...France.Foo
*  and ...Germany.Foo.
* The UK territory, being the first in the localelist, was used as the base for
*  the Common directory, and therefore must be identical and is not compared
*  for that reason.
*
* Assumptions
*  This routine alters the global array compared_files[], which contains the
*   paths to all the files to be compared.
*  It also deletes the file in the 'common' directory if it was not common, or
*   in the territory-specific directories if it was common.
*
* Inputs
*  filename:     The name of the file to be compared.
*
* Outputs
*  None.
*
* Returns
*  It returns true if the file exists in all possible resource sets and they
*   match, false otherwise
*****************************************************************************/
static bool compare_files(const char* filename)
{
  char* path_segment = NULL;
  unsigned int length;
  unsigned int loop;
  unsigned int filesize[MAX_OPEN_TERRITORY_FILES];
  unsigned int filetype[MAX_OPEN_TERRITORY_FILES];

  /* Get the segment of the path after the territory. */
  length = strlen(root_resources_directory);
  path_segment = (char*)filename+length;
  length = strlen(supported_territories[0]);
  path_segment+=length+2;

  /* Now create the other filenames using the known path. */
  for (loop=0; loop < num_of_territories; loop++)
  {
    compared_files[loop] = compare_files_construct_path(root_resources_directory, supported_territories[loop], path_segment);

    /* Display all the files that will be parsed if the verbose flag is set. */
    if (verbose)
    {
       printf ("%s\n", compared_files[loop]);
    }

    if (!retrieve_file_details(compared_files[loop], &filetype[loop], &filesize[loop]))
    {
      if (verbose)
        printf("%s does not exist.\n", compared_files[loop]);
      return (false);
    }
  }

  /* Perform the comparisons...*/
  perform_comparisons(path_segment, filesize, filetype);

  /* Now free the memory held by all the files... */
  for (loop=0; loop < num_of_territories; loop++)
  {
    if (compared_files[loop])
    {
      free (compared_files[loop]);
      compared_files[loop] = NULL;
    }
  }

  return (false);
}






/*****************************************************************************
* descend
*
* This routine descends into the directory path passed in, reading all the
*  files and directories held within it. It can be called recursively to scan
*  a whole directory structure.
* Any files that are in the path directory are compared using subsidiary
*  routines.
*
* Assumptions
*  That BUFSZ is large enough to hold any possible path.
*
* Inputs
*  path:         The path to be recursed from.
*
* Outputs
*  None.
*
* Returns
*  None.
*****************************************************************************/
static void descend(char *path)
{
  char *buf = safe_alloc( BUFSZ );
  int offset = 0;

  if ( buf != NULL )
  {
    do
    {
      object *op = (object *)buf;
      int nread;

      printf ("Comparing files in path %s\n", path);
#ifdef RISCOS
      _swi( OS_GBPB, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5)|_IN(6)|_OUT(3)|_OUT(4),
              10, path, buf, 80, offset, BUFSZ, 0, &nread, &offset );
#else
      offset = -1;
      load_unix_directory(path, buf, BUFSZ, &nread);
#endif

      while ( nread > 0 )
      {
        switch ( op->type )
        {
          char *trunc_char;

          case 1:
            /* Text file found so scan it for tags. */
            trunc_char = appendleaf( path, op->name );
            if (compare_files(path))
            {
            }
            else
            {
              //printf ("Not matched: %s\n", path);
            }
            (void) stripleaf( trunc_char );
            break;

          case 2:
            /* Directory found so descend into it.
             */
            trunc_char = appendleaf( path, op->name );
            descend( path );
            (void) stripleaf( trunc_char );
            break;

          default:
            printf("Don't know how to process object type %d\n", op->type );
      }

        op = (object *)(((int)(op->name)+strlen(op->name)+STRUCTURE_ALIGNMENT+1)&~STRUCTURE_ALIGNMENT);
        nread -= 1;
      }
    } while ( offset != -1 );

    free( buf );
  }
  else
  {
    printf("Couldn't allocate enough memory\n" );
    exit (EXIT_FAILURE);
  }
}







/*****************************************************************************
* compare_resources
*
* This routine is the main routine that is called when attempting to compare
*  a set of resources.
*
* Assumptions
*  That root_resources_directory exists, and that BUFSZ is large enoguh to hold a
*   string of length strlen(root_resources_directory)+strlen(".Common"). Because it is
*   used within the descend() routine to hold the curren path, then BUFSZ will
*   have to be large enough to hold the longest path in the directory
*   structure below root_resources_directory.
*
* Inputs
*  None.
*
* Outputs
*  buffer :      This gets altered  range of outputs, etc. List variables in
*                the same order that they appear in the function definition.
*
* Returns
*  This routine returns true.
*****************************************************************************/

static bool compare_resources(void)
{
  static char buffer[BUFSZ];

  assert(root_resources_directory);

  /* Recurse down the directory structure... */
  sprintf(buffer, "%s%c%s", root_resources_directory, dir_sep_char, supported_territories[0]);
  descend(buffer);

  return (true);
}




/*****************************************************************************
* cstrcmp
*
* This routine compares two string caselessly.
*
* Assumptions
*  State any assumptions and side effects (eg. globals changed)
*
* Inputs
*  a:            The first string to be compared.
*  b:            The second string to be compared.
*
* Outputs
*  None.
*
* Returns
*  0 if both strings are NULL, or both strings are (ignoring case) identical.
*  -1 if one (but not both) of the strings are NULL.
*  Any other value if the strings are different.
*****************************************************************************/

int cstrcmp(const char *first_param, const char *second_param)
{
        const unsigned char *first = (const unsigned char *) first_param;
        const unsigned char *second = (const unsigned char *) second_param;

        if (first == second) return 0;
        if (first == NULL || second == NULL) return -1;

        for (;;) {
                unsigned int a = *first++;
                unsigned int b = *second++;

                if (a == 0) return -b;
                if (a != b) {
                        unsigned int c = (unsigned int) tolower(a);
                        unsigned int d = (unsigned int) tolower(b);
                        signed int result = c - d;
                        if (result != 0) return result;
                }
        }
}



/*****************************************************************************
* cnstrcmp
*
* This routine compares two string caselessly.
*
* Assumptions
*  State any assumptions and side effects (eg. globals changed)
*
* Inputs
*  a:            The first string to be compared.
*  b:            The second string to be compared.
*  limit:        The maximum number of characters to compare
*
* Outputs
*  None.
*
* Returns
*  0 if both strings are NULL, or both strings are (ignoring case) identical.
*  -1 if one (but not both) of the strings are NULL.
*  Any other value if the strings are different.
*****************************************************************************/

static int cnstrcmp(const char *first_param, const char *second_param, size_t limit)
{
        const unsigned char *first = (const unsigned char *) first_param;
        const unsigned char *second = (const unsigned char *) second_param;

        for (;limit;--limit) {
                unsigned int a = *first++;
                unsigned int b = *second++;

                if (a == 0) return -b;
                if (a != b) {
                        unsigned int c = (unsigned int) tolower(a);
                        unsigned int d = (unsigned int) tolower(b);
                        signed int result = c - d;
                        if (result != 0) return result;
                }
        }

        return 0;
}




/*****************************************************************************
* help_text
*
* Display a suitable help text.
*
* Assumptions
*  There are no assumptions.
*
* Inputs
*  None.
*
* Outputs
*  None.
*
* Returns
*  None.
*****************************************************************************/

static void help_text(void)
{
  puts(
  "ResCommon\n"
  "\n"
  "Usage: ResCommon <root resources dir> <root processed dir> [-t <territory_list>] [-v -h -s]\n\n"
  "Commands: <root resources dir> Where to get the resources files for each territory from.\n"
  "Commands: <root processed dir> Where to place all the resource files after commonalities have been detected.\n"
  "Options:  -t <territory_list>  A comma-seperated list of territories to use.\n"
  "          -v                   Verbose. Display verbose output on what the utility is doing.\n"
  "          -h                   Help. Display help text.\n"
  "          -s                   Simulate. Do not delete any files.\n"
  "\n"
  "This utility looks for common resources held in different territories and places them in relevant directories. \n"
  "This allows as many different resource sets as possible to be squeezed into one ROM image.\n"
  "\n");
}





/*****************************************************************************
* main
*
* Main routine. This routine parses the command line argument passed in, sets
*  up appropriate data needed for the program and starts off the comparison
*  of the resources.
*
* Assumptions
*  None.
*
* Inputs
*  argc:         A count of the number of command-line arguments.
*  argv:         A vector containing the command line arguments.
*
* Outputs
*  None.
*
* Returns
*  EXIT_FAILURE if the program failed for some reason, otherwise,
*   EXIT_SUCCESS
*****************************************************************************/
int main(int argc, char **argv)
{
  unsigned int i, loop;

  /* Define an atexit handler */
  /* Not needed: atexit(exit_handler); */

  shared_init(argc, argv);
  host_init();
  dir_sep_char = host_dir_sep_char();

  for (i = 1; i < argc; i++)
  {
    // printf("arg %d: %s\n", i, argv[i]);
    if ((cstrcmp(argv[i], "-h") == 0) || (cstrcmp(argv[i], "-help") == 0))
    {
      help_text();
      exit(EXIT_FAILURE);
    }
    else if ((cstrcmp(argv[i], "-v") == 0) || (cstrcmp(argv[i], "-verbose") == 0))
    {
      verbose = true;
    }
    else if ((cstrcmp(argv[i], "-t") == 0) || (cstrcmp(argv[i], "-territories") == 0))
    {
      /* The next arg should be a comma-separated territory list. */
      char* const list = str_rc_dup(argv[++i], 0);
      (void) parse_territories(list, parse_territory_callback, NULL);
      free(list);
    }
    else if ((cstrcmp(argv[i], "-s") == 0) || (cstrcmp(argv[i], "-simulate") == 0))
    {
      simulate = true;
    }
    else if ((argv[i])[0] == '-') {
      fprintf(stderr, "Unknown option '%s'\n", argv[i]);
      exit(EXIT_FAILURE);
    }
    else if (root_resources_directory == NULL) {
      root_resources_directory = str_rc_dup(argv[i], 0);
    }
    else if (root_processed_directory == NULL) {
      root_processed_directory = str_rc_dup(argv[i], 0);
    }
    else {
      root_processed_directory = NULL;
      break;
    }
  }

  if (root_processed_directory == NULL)
  {
    fprintf(stderr, "Usage: ResCommon <root resources dir> <root processed dir> [-t <territory_list>] [-v -h -s]\n");
    exit (EXIT_FAILURE);
  }

  /* Read the required starting directory from the command line. */
  if (verbose)
    printf("root resources directory is %s\n", root_resources_directory);

  /* Read the required starting directory from the command line. */
  if (verbose)
    printf("root processed directory is %s\n", root_processed_directory);

  /* Ensure that root resources directory is a directory. */
  if (filer_object_type(root_resources_directory) != 2)
  {
    fprintf(stderr, "Error: %s should be a directory.\n", root_resources_directory);
    exit (EXIT_FAILURE);
  }
  /* Ensure that root processed directory is a directory. */
  if (filer_object_type(root_processed_directory) != 2)
  {
    fprintf(stderr, "Error: %s should be a directory.\n", root_processed_directory);
    exit (EXIT_FAILURE);
  }

  /* We need to see if a locale_list has been defined. If it has, we need to split it into a list of locales.
      Only do this if a valid list was not passed in on the command line. */
  if (num_of_territories == 0)
  {
    if (!parse_territories(NULL, parse_territory_callback, NULL))
    {
      /* An error occured whilst parsing the loale list. */
      printf("Malformed locale list detected.");
      exit (EXIT_FAILURE);
    }
  }

  /* If there are no territories something has gone wrong. Flag this up. */
  if (num_of_territories == 0)
  {
    /* If there was not a locale list in env or on command line, report it and quit. */
    fprintf(stderr, "No locale list present.\n");
    exit (EXIT_FAILURE); /* Success as the program should do nothing if there is no localelist. */
  }

  /* One territory is a special case - just copy the resources as there are
     no comparisons to be made. This will speed up single-territory builds. */
  if (num_of_territories == 1)
  {
    char buffer[MAX_PATH_SIZE];                   /* Another nasty hardcoded limit. */
    char dest[MAX_PATH_SIZE];
    printf("There is only one territory. Copying from resources to processed and exiting.\n");
    /* Copy the file over. */
    sprintf(buffer, "%s%c%s", root_resources_directory, dir_sep_char, supported_territories[0]);
    sprintf(dest,   "%s%c%s", root_processed_directory, dir_sep_char, "Common");
    /* Ensure the relevant directory exists. */
    do_mkdir(dest);
    if (verbose) printf("Copying %s as %s ...\n", buffer, dest);
    exit (file_copy(buffer, dest) ? EXIT_SUCCESS : EXIT_FAILURE);
  }

  /* See if the UK territory (01) is in the list. If it is not, map one of
     the other territories onto it. This is because a ROM build should always
     have a UK territory in it (the Kernel default value for territory is 01, so
     doing a reset on a build with no UK resources in causes ROM initialisation to
     fail). Mapping a territory to UK (for example making Germany 0701) means that
     the ROM thinks that the UK resources are present, although in reality it is
     using the German resource set. This will allow the NC to boot correctly after
     a delete-poweron has been performed. */
  for (loop=0; loop < num_of_territories; loop++)
  {
    printf("Supported territory %d is %s\n", loop, supported_territories[loop]);
    if (cstrcmp(supported_territories[loop],"UK") == 0) /* UK resource set is present */
    {
      printf("UK resource set present in locale list.\n");
      uk_resources_present = true;
    }
  }

  /* Create the 'common_directory' string */
  common_directory = safe_alloc ((num_of_territories*3)+1);
  if (num_of_territories == 1)
  {
    sprintf(common_directory, "%02ld", return_country_number(supported_territories[0]));
  }
  else
  {
    unsigned int loop;
    char *end = common_directory;
    for (loop=0; loop < num_of_territories; loop++)
    {
      end += sprintf(end, "%02ld", return_country_number(supported_territories[loop]));
      if (!uk_resources_present && loop == 0)
      {
        /* Add the UK territory onto the string */
        end += sprintf(end, "01");
      }
    }
  }
  printf("Common directory is %s\n", common_directory);

  /* Ensure that the resource directories exist. */
  if (!ensure_resource_directories_exist())
  {
    printf("Not all resource directories exist.\n");
    exit (EXIT_FAILURE);
  }

  /* And now do the comparisons... */
  compare_resources();

  /* Whee ! */
  exit(EXIT_SUCCESS);

  /* Now some references to avoid compiler warnings */
  (void) cnstrcmp;
}




/*****************************************************************************
* exit_handler
*
* This function can be used to clear up any outstanding memory left
*  afer the program has finished. It should only be used to delete
*  memory that is needed throughout the lifetime of the program, for
*  example the locale_list.
*
* Assumptions
*  There are no assumptions.
*  (SNB: except that the author didn't know that malloc'ed memory is discarded
*         automatically on process exit?? )
*
* Inputs
*  None.
*
* Outputs
*  None.
*
* Returns
*  None.
*****************************************************************************/
#if 0
void exit_handler(void)
{
  unsigned int loop;

  /* Free the locale array if it has not already been free'd. */
  if (num_of_territories != 0)
  {
    for (loop=0; loop < num_of_territories; loop++)
    {
      if (compared_files[loop]) /* Memory has not been free'd. */
      {
        free (compared_files[loop]);
        compared_files[loop] = NULL;
      }
    }
    num_of_territories = 0;
  }

  /* Free the directory_to_copy memory */
  if (directory_to_copy)
  {
    free (directory_to_copy);
    directory_to_copy = NULL;
  }

  /* Free the root resources directory */
  if (root_resources_directory)
  {
    free (root_resources_directory);
    root_resources_directory = NULL;
  }

  /* Free the root processed directory */
  if (root_processed_directory)
  {
    free (root_processed_directory);
    root_processed_directory = NULL;
  }

  /* Free the common directory */
  if (common_directory)
  {
    free (common_directory);
    common_directory = NULL;
  }
}
#endif







/*****************************************************************************
* compare_file_contents
*
* This routine compares the contents of a 'line' of bytes across the files
*  that are currently open. The contents of the file are held in array of
*  unsigned integers, which means that things other than file contents can be
*  compared (for instance this routine is also used to compare filetypes and
*  filesizes).
*
* Assumptions
*  This routine assumes that all the data being passed in is filled in as
*   appropriate; no run-time checks are performed to ensure this.
*
* Inputs
*  uint* file_contents: A pointer to an array of integers comprising the data
*                       that is to be compared.
*  uint num_of_territories: The number of territories that are held within the
*                       data array.
*
* Outputs
*  The contents of the global main_list array is altered.
*
* Returns
*  None.
*****************************************************************************/
void compare_file_contents(const unsigned int* const file_contents, unsigned int num_of_territories)
{
  unsigned int main_list_loop;
  unsigned int file_contents_loop;
  bool file_contents_identical = true; /* set to true if all bytes in the file_contents are the same. */
  list_of_lists* swap_ptr; /* Used as a scratch ptr to aid swapping lists */
  const unsigned int *file_contents_ptr = file_contents;

  /* Quick check: if all bytes in the file_contents are the same, then the list must remain identical. */
  for (file_contents_loop=1; file_contents_loop<num_of_territories; file_contents_loop++)
  {
    const unsigned int previous_word = *file_contents_ptr++;
    if (*file_contents_ptr != previous_word)
    {
      file_contents_identical=false;
      break; // Quit loop early - we have proved file_contents is not identical.
    }
  }

  /* Iterate through all the main lists. */
  if (!file_contents_identical)
  {
    /* Create a temp list which data can be stored in. */
    list_of_lists* temp_list = safe_alloc(sizeof(list_of_lists));

    main_list_initialise(temp_list, num_of_territories);

    for (main_list_loop=0; main_list_loop < num_of_territories; main_list_loop++)
    {
      list *this_list = &main_list->lists[main_list_loop];
      sublist_parse(this_list, temp_list, file_contents, num_of_territories);
    }

    /* Copy the data from the temp list to the main list. Do this by swapping the pointers. */
    swap_ptr = main_list;
    main_list = temp_list;
    temp_list = swap_ptr;

    /* Free up the memory holding the temporary list */
    free (temp_list);
  }

}




#ifdef INCLUDE_OLD_DEBUG_CODE
/* The code below is a wrapper routne that I used to test some of the core
functions within this code. This routine has not been run for some time, but
I have left it in as it may be of use to maintainers of code in the future. */


static char *test_array[] =
{
"AAAAA", /* Should all be in the same list. */
"AABBB", /* 2 lists  0,1   and  2,3,4 */
"ABBBB", /* 3 lists  0  1   and 2,3,4 */
"ABBCB", /* 4 lists  0  1  2,4 and 3 */
"ABCDD", /* 4 lists  0  1  2  and 3,4 */
"BCDRR", /* 4 lists  0  1  2  and 3,4 */
"ABCDE", /* 5 lists  0  1  2  3  and 4 */
"QQQQQ", /* Should not have to parse this line. */
"ADSFC",  /* Or this one...*/
""
};


void test_file_comparisons(void)
{
  unsigned int file_line = 0;
  unsigned int num_territories = 5; /* This hould be passed in as a parameter */

  main_list = safe_alloc(sizeof(list_of_lists));

  main_list_initialise(main_list, num_of_territories);

  /* Create a list with all files being identical. */
  main_list_create_initial(num_of_territories);  /* Create a list with all files being identical. */

  /* Create a new node inthe main list */
  list_create_new(main_list, 'a', num_of_territories);

  /* Now scan through the file line by line, altering the list as appropriate. */
  file_line = 0;
  while (test_array[file_line])
  {
    unsigned int main_list_loop;
    list_of_lists* swap_ptr;
    /* Create a temp list which data can be stored in. */
    list_of_lists* temp_list = safe_alloc(sizeof(list_of_lists));
    main_list_initialise(temp_list, num_of_territories);

    printf ("\n\nParsing string %s\n", test_array[file_line]);

    /* Iterate through all the main lists. */
    for (main_list_loop=0; main_list_loop < num_of_territories; main_list_loop++)
    {
      list *this_list = &main_list->lists[main_list_loop];
      sublist_parse(this_list, temp_list, (unsigned int*) test_array[file_line], num_of_territories);
    }

    /* Display it after the alterations... */
    main_list_display(temp_list, num_of_territories);

    /* Copy the data from the temp list to the main list. Do this by swapping the pointers. */
    swap_ptr = main_list;
    main_list = temp_list;
    temp_list = swap_ptr;
    free (temp_list);

    /* If we have n lists, they must all be different files. No need to parse anymore. */
    if (main_list_count_nodes(main_list, num_of_territories) == num_territories)
    {
      printf ("All files are different. Exiting early.\n");
      break;
    }

    file_line++;
  }

  /* Free off the memory. */
  free (main_list);
}

#endif  /* INCLUDE_OLD_DEBUG_CODE */




/* This routine initialises the lists ready for use. */
void main_list_initialise(list_of_lists* main_list, unsigned int num_of_territories)
{
  unsigned int main_list_loop;
  /* Initialise all the lists held in the main list */
  for (main_list_loop=0; main_list_loop<num_of_territories; main_list_loop++)
  {
    list *this_list = &main_list->lists[main_list_loop];
    unsigned int sublist_loop;
    /* Initialise all the sub-lists */
    for (sublist_loop=0; sublist_loop<num_of_territories; sublist_loop++)
    {
      this_list->file_num[sublist_loop] = -1;
    }
    this_list->array_size = -1;
  }
}






/* This routine creates an initial list with the first node pointing to all files. */
void main_list_create_initial(unsigned int num_of_territories)
{
  unsigned int sublist_loop;
  list *this_list = &main_list->lists[0];
  /* Initialise all the sub-lists */
  for (sublist_loop=0; sublist_loop<num_of_territories; sublist_loop++)
  {
    this_list->file_num[sublist_loop] = sublist_loop;
  }
  this_list->array_size = num_of_territories;
}




/* This routine displays all the nodes in the main list.*/
void main_list_display(list_of_lists* list_to_display, unsigned int num_of_territories)
{
  unsigned int main_list_loop;
  for (main_list_loop=0; main_list_loop<num_of_territories; main_list_loop++)
  {
    main_list_display_node_num(list_to_display, main_list_loop);
  }
}




/* This routine returns the number of filled nodes in the passed in list. */
unsigned int main_list_count_nodes(list_of_lists* list_to_count, unsigned int num_of_territories)
{
  unsigned int main_list_loop;
  unsigned int count = 0;

  for (main_list_loop=0; main_list_loop<num_of_territories; main_list_loop++)
  {
    list *this_list = &list_to_count->lists[main_list_loop];
    if (this_list->array_size > 0)
    {
      count++;
    }
  }

  return (count);
}



/* This routine displays the information held in a specific node of the main list. */
void main_list_display_node_num(list_of_lists* main_list_to_display, unsigned int list_to_display)
{
  unsigned int sublist_loop;
  list *this_list = &main_list_to_display->lists[list_to_display];
  if (this_list->array_size > 0) /* We do not wish to display empty lists. */
  {
    printf ("main_list_display_node_num(): List %d contains %d nodes:", list_to_display, this_list->array_size);
    /* Loop through all the elements in the loop */
    for (sublist_loop=0; sublist_loop < this_list->array_size; sublist_loop++)
    {
      if (this_list->file_num[sublist_loop] >= 0) /* Do not display empty locations */
      {
        printf (" %d (%s)", this_list->file_num[sublist_loop], supported_territories[this_list->file_num[sublist_loop]]);
      }
    }
    printf("\n");
  }
}




/* This routine creates a new main list.
   It returns the number of the created list.  */
unsigned int list_create_new(list_of_lists* list_to_alter, const char char_to_enter, unsigned int num_of_territories)
{
  unsigned int pos_created = 0;
  unsigned int list_loop;

  /* Find an empty list. */
  for (list_loop=0; list_loop<num_of_territories; list_loop++)
  {
    list *this_list = &list_to_alter->lists[list_loop];
    //printf("list_create_new(): this_list->array_size = %d\n", this_list->array_size);
    if (this_list->array_size == -1)
    {
      //printf("list_create_new(): Creating an array at position %d\n", list_loop);
      pos_created = list_loop;
      break;
    }
  }

  return (pos_created);
}



/*
  We use arrays rather than linked lists for two reasons:
     *) Linked lists need memory allocations, node creation and node destruction, which can be time-consuming.
     *) We know that there only needs to be a maximum of n nodes, where n is the number of territories being supported.
  This means that we waste a small amount of memory, but the build should go quicker without the extra memory allocaions.
*/


/* This routine scans through the current main list and creates a relevent new list. */
void sublist_parse(list* this_list, list_of_lists* new_list, const unsigned int* const file_line, unsigned int num_of_territories)
{
  unsigned int char_array[MAX_TERRITORIES];
  bool char_array_pos_filled[MAX_TERRITORIES] = { false };

  if (this_list->array_size > 0) /* Ensure this list has some entries... */
  {
    unsigned int sublist_loop;

    /* We now wish to scan through all the entries in this list */
    for (sublist_loop=0; sublist_loop < this_list->array_size; sublist_loop++)
    {
      int num = this_list->file_num[sublist_loop];
      unsigned int main_list_loop;
      signed int char_already_entered=-1;
      // printf ("sublist_parse(): %d (corresponding char is %c)\n", num, (char)file_line[num]);

      /* Is the character already held in one of the lists? */
      for (main_list_loop=0; main_list_loop<num_of_territories; main_list_loop++)
      {
        list *this_list = &new_list->lists[main_list_loop];
        if (this_list->array_size > -1) /* The list is not empty */
        {
          unsigned int sublist_loop;
          for (sublist_loop=0; sublist_loop<this_list->array_size; sublist_loop++)
          {
            if (char_array_pos_filled[main_list_loop] && char_array[main_list_loop] == file_line[num])
            {
              char_already_entered = main_list_loop;
              //printf("sublist_parse(): char %c has already been entered at pos %d\n", file_line[num], main_list_loop);
              break; /* We have found it, so quit the loop early. */
            }
          }
        }
      }

      if (char_already_entered >= 0)
      {
        //printf("char %c has already been entered at pos %d\n", file_line[num], char_already_entered);
        new_list->lists[char_already_entered].file_num[new_list->lists[char_already_entered].array_size++] = num;
      }
      else
      {
        /* Create another list. */
        unsigned int node_pos = 0;
        node_pos = list_create_new(new_list, file_line[num], num_of_territories);
        //printf("Created another sublist for char %c at pos %d\n", file_line[num], node_pos);
        new_list->lists[node_pos].array_size++; /* move it onto 0 from -1 */
        new_list->lists[node_pos].file_num[new_list->lists[node_pos].array_size++] = num;
        char_array[node_pos] = file_line[num];
        char_array_pos_filled[node_pos] =true;
      }

    }
  }
}



/* Things to do:
   3) Implement a system where all the files in all the resource directories
are listed. Use this list to search for the files, and not scanning through
one individual directory. Currently if a file is not present in the main
resource directory being scanned but is present in one of the other resource
directories, then it will not be scanned.
   4) As part of 3) above, ensure that if a file is not present the system
still works.

Completed ones:
   9) Make it use ServiceCall_Territory 0 insetad of Territory_NameToNumber
   2) A common case is for all files to be identical; catch the case where
all bytes in a line of the file are identical early and drop out without
doing the laborious list calculations.
   10) Convert the char array that is read from the file to integers. This
will allow filetypes and filesizes to be compared, as well as the actual file
contents.
   8) Get the filesize and filetype things working.
   7) Test with 1,2,3,4 and 5 territories set.
   5) Ensure that the created resource directories are in the processed
directory, not the resources one as they are at present. Do this by altering
the command-line arguments so that the required processed directory is passed
in as a flag.
   1) Cope with squash files.
   6) If there is only one territory, none of the above should happen, and
the resources should be copied straight into the relevant territory
directory. 
  11) There should always be a 'common' directory, called 'Common'. In the
case of single-territory builds, this will be the territory itself. In the
case of multiple territory builds, this will be the 'common' directory (e.g.
0107 for UK and German builds).
  12) If the locale_list does not include UK, make the first locale in the
list also map to territory 01. This prevents problems with the UK resource
set being expected in ROM by making the Kernel believe that the first
resource set is the UK set, even if it is not.
  13) Ensure that if there is only one territory it copies the resources
directory over to the processed directory, meaning that the scanning does not
have to be done and saving time.
 */



/*****************************************************************************
* END OF FILE
*****************************************************************************/


