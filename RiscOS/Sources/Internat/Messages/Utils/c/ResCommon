/*****************************************************************************
* $Id$
* $Name$
*
* Author:  David Cotton
* Project: Bethany (333)
*
* ----------------------------------------------------------------------------
* Copyright [2000] Pace Micro Technology PLC.  All rights reserved.
*
* The copyright in this material is owned by Pace Micro Technology PLC
* ("Pace").  This material is regarded as a highly confidential trade secret
* of Pace.  It may not be reproduced, used, sold or in any other way exploited
* or transferred to any third party without the prior written permission of
* Pace.
*
* ----------------------------------------------------------------------------
* Purpose: This file contains source code required for the ResCommon utility.
*           This utility implements some of the functionality required for
*           the Multiple Resource sets in RISC OS ROMS (see spec 2503,027/FS).
*          This utlity scans through a set of resource directories and strips
*           out all the common files into a Common directory.
*
* ----------------------------------------------------------------------------
* History: See source control system log
*
*****************************************************************************/


/*****************************************************************************
* Include header files
*****************************************************************************/
/* Include Standard headers */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <ctype.h>

/* Include RISC OS headers */
#include "kernel.h"
#include "swis.h"
#include "os.h"
#include "Global/FileTypes.h"

/* Include other headers */
#include "msgcommon.h"
#include "debuglib/debuglib.h"

/*****************************************************************************
* MACROS
*****************************************************************************/
#define MAX_OPEN_TERRITORY_FILES 10   /* This value matches the available number of territories defined in the spec */
#define ENV_LOCALE_LIST "LocaleList"  /* name of env var holding the comma-seperated list of lcoales */
#define MAX_TERRITORIES 10            /* As defind in the spec. */
#define BUFSZ   512                   /* Old value needed by cut & paste code. */
#define filetype( object )      (((object)->loadaddr>>8)&0xFFF)

/*****************************************************************************
* New enumerated types
*****************************************************************************/
typedef unsigned int word;

/* Structure in which to hold the file information for a file */
typedef struct
{
  word loadaddr;
  word execaddr;
  word length;
  word attr;
  word type;
  char name[1];
} object;

/* The structure below defines a type that can be used to hold squash file headers as
    defined in PRM 4 Appendix E */
typedef struct
{
  char id[4];
  int size;
  int load_addr;
  int exec_addr;
  int reserved;
} squash_header_struct;


/*****************************************************************************
* Constants
*****************************************************************************/


/*****************************************************************************
* File scope Global variables
*****************************************************************************/
char* supported_territories[MAX_TERRITORIES] = NULL; /* An array in which territories defined in the Env file can be stored. */
unsigned int num_of_territories = 0;                 /* The number of territories defined. */
char* root_directory = NULL;
char* directory_to_copy = NULL;
char* compared_files[MAX_TERRITORIES] = NULL; /* An array in which to store the filenames of the files t be compared. */
bool verbose = false; /* Do you wish to see what it is doing */
bool simulate = false; /* Do not actually delete any files. */


/*****************************************************************************
* Function prototypes - Private to this file
*****************************************************************************/
unsigned long int filer_object_type(const char* filename);
bool file_exists(char* filename);
char *strdup(const char *str);
bool parse_territories(char* territory_line);
bool mkdir(char *dir, int mode);
int  file_size(char *file);
char *read_env(char *variable);
bool ensure_resource_directories_exist(void);
void create_common(const char* res_to_copy);
int  get_filetype(char* obj);
void appendleaf( char *path, char *leaf );
void stripleaf( char *path );
bool compare_files(const char* filename);
bool remove_file(const char* file_to_remove);
bool perform_comparisons(void);
void descend(char *path);
bool compare_resources(void);
int  cstrcmp(const char *a, const char *b);
void help_text(void);
void exit_handler(void);
bool compare_squash_files(void);
bool is_directory_empty(const char* directory);


/*****************************************************************************
* Functions
*****************************************************************************/




/*********************************************************************************/
/* file_exists                                                                   */
/*                                                                               */
/* This routine checks whether the passed file exists.                           */
/*                                                                               */
/* Parameters: filename  This is the filename of the file to be checked.         */
/*                                                                               */
/* Returns:    It returns true if the file exists, false otherwise (or if there  */
/*              was an error during the SWI call).                               */
/*                                                                               */
/*********************************************************************************/
bool file_exists(char* filename)
{
  _kernel_oserror *err;
  unsigned long int exists;

  dprintf(("", "file_exists()\n"));

  err = _swix( OS_File, _IN(0)|_IN(1)|_OUT(0), 5, filename, &exists);
  if (!exists || err) /* File does not exist. */
  {
    return (false);
  }
  return (true);
}




/*********************************************************************************/
/* filer_object_type                                                             */
/*                                                                               */
/* This routine returns the type of the filer object corresponding to the        */
/*  filename passed in.                                                          */
/*                                                                               */
/* Parameters: filename  This is the filename of the file to be checked.         */
/*                                                                               */
/* Returns:    It returns : 0 for no such object                                 */
/*                          1 for a file object                                  */
/*                          2 for a directory object                             */
/*                          3 for an image object                                */
/*                                                                               */
/*********************************************************************************/
unsigned long int filer_object_type(const char* filename)
{
  _kernel_oserror *err;
  unsigned long int object_type = 0;

  dprintf(("", "filer_object_type()\n"));

  assert (filename!=NULL);
  err = _swix( OS_File, _IN(0)|_IN(1)|_OUT(0), 5, filename, &object_type);
  if (err)
  {
    dprintf(("", "filer_object_type(): Error trying to find object type of file '%s'\n", filename));
  }

  return (object_type);
}





/*****************************************************************************
* strdup
*
* malloc an area for a string and copy the string in
*
* Assumptions
*  uses malloc; the memory allocated must be free'd at some point.
*
* Inputs
*  str         : The string to be copied.
*
* Outputs
*  variablename: None; str is constant and should remain unaltered.
*
* Returns
*  A pointer to the copy of the string, or NULL if the copy failed.
*****************************************************************************/
char *strdup(const char *str)
{
  char *newstr = malloc(str == NULL ? 1 : (strlen(str) + 1));

  if (newstr != NULL) {
    if (str == NULL)
      *newstr = 0;
    else
      strcpy(newstr, str);
  }
  return (newstr);
}



/*****************************************************************************
* parse_territories
*
* This routine parses any territory line passed in and strips out all the
*  territories into the global supported_territoried array.
* If the line is invalid, it retunrs false, otherwise it returns true. A
*  line is considered invalid if it is empty or contains whitespace.
*
* Assumptions
*  The global variables supported_territories[] and num_of_territories
*   will both be altered.
*
* Inputs
*  territory_line: A comma-seperated list of countries.
*
* Outputs
*  None. territory_line is a constant pointer.
*
* Returns
*  A boolean describing whether or not the territory line was parsed
*   successfully.
*****************************************************************************/

bool parse_territories(char* territory_line)
{
  char *territory = NULL;

  printf("Parsing territory line %s\n", territory_line);

  if (strlen(territory_line) < 1)
  {
    /* Line must contain something */
    return (false);
  }

  territory = strtok(territory_line, ",");
  while (territory)
  {
    printf ("territory is %s\n", territory);
    supported_territories[num_of_territories++] = strdup(territory);
    territory = strtok (NULL, ",");
  }

  printf ("%d territories detected in the territories list.\n", num_of_territories);

  return (true);
}



/*
 * make directory
 */
bool mkdir(char *dir, int mode)
{
  _kernel_swi_regs reg;

  reg.r[0] = 8;
  reg.r[1] = (int) dir;
  reg.r[4] = 0;
  if (_kernel_swi(OS_File, &reg, &reg))
  {
    return (true);
  }
  return (false);
}




/*
 * return the size of a file in bytes
 */
int file_size(char *file)
{
  _kernel_swi_regs reg;

  reg.r[0] = 23;		/* no paths */
  reg.r[1] = (int) file;
  _kernel_swi(OS_File, &reg, &reg);

  return (reg.r[0] == 1 ? reg.r[4] : -1);
}




/*
 * read an environment variable in to a malloced string
 */
char *read_env(char *variable)
{
  char *var = NULL;
  char *cp = NULL;

  if ((var = getenv(variable)) != NULL)
    cp = strdup(var);

  return (cp);
}





/*****************************************************************************
* ensure_resource_directories_exist
*
* This routine scans through the list of territories and ensures that the
*  required resource directories all exist. It does this by checking that
*  <root_directory>.<territory_name> is a valid directory.
*
* Assumptions
*  There should be no effect outside this routine.
*
* Inputs
*  None.
*
* Outputs
*  None.
*
* Returns
*  A boolean, true if the resource directories existed in the correct
*   locationm false otherwise.
*****************************************************************************/
bool ensure_resource_directories_exist(void)
{
  unsigned int loop;
  char buffer[BUFSZ]; /* Nasty hardcoded value */
  for (loop=0; loop < num_of_territories; loop++)
  {
    sprintf(buffer, "%s.%s", root_directory, supported_territories[loop]);
    printf ("Checking for %s.\n", buffer);
    if (filer_object_type(buffer) != 2)
    {
      printf("Warning: %s is not a directory.\n", buffer);
      return (false);
    }
  }

  return (true);
}





/*****************************************************************************
* create_common
*
* This routine creates the 'common' directory, and copies the resources from
*  the res_to_copy resource set recursively into it.
*
* Assumptions
*  That res_tp_copy points to a valid territory that exists in the resource
*   set.
*  This routine use filer operations to create directories and copy files; as
*   such it is open to the vagaries of available disc space, pre-existing
*   files etcetera. No checks are made as for whether or not any of these
*   operations failed.
*
* Inputs
*  res_to_copy:  The resource set to use as the copy; this will get copied
*                 into the 'Common' directory.
*
* Outputs
*  None.
*
* Returns
*  None.
*****************************************************************************/
void create_common(const char* res_to_copy)
{
  char buffer[255]; /* another nasty hardcoded limit */
  char source[255];
  char dest[255];

  /* Create the common directory */
  sprintf(dest, "%s.Common", root_directory);
  mkdir (dest, 0);
  printf ("Creating directory %s\n", dest);

  sprintf(source, "%s.%s", root_directory, res_to_copy);
  printf ("Copying from %s to %s\n", source, dest);

  /* Copy the resources over into the common directory. */
  sprintf(buffer, "copy %s %s r~v~cf", source, dest);
  system(buffer);
}





/*****************************************************************************
* get_filetype
*
* This routine returns the filetype of the object to pointed to by obj.
*
* Assumptions
*  It is assumed that the object pointed to by obj exists and is a file; if
*   not then -1 is returned.
*
* Inputs
*  obj :         The object we require the filetype of.
*
* Outputs
*  None.
*
* Returns
*  The filetype, or -1 if the file does not exist.
*****************************************************************************/

int get_filetype(char* obj)
{
  if (file_exists(obj))
  {
    int type, load_addr;
    _swi( OS_File, _IN(0)|_IN(1)|_OUT(2), 17, obj, &load_addr );
    type = (load_addr>>8)&0xFFF;
    return (type);
  }
  else
  {
    return (-1);
  }
}







/*****************************************************************************
* appendleaf
*
* This routine appends the leaf passed in onto the end of the path.
*
* Assumptions
*  This routine assumes that the area of memory that holds path is large
*   enough to hold the alterd string. No bounds checking is performed.
*
* Inputs
*  path :        The path for the leaf to be appended to.
*  leaf :        The leafname to be appended.
*
* Outputs
*  The new path with the leaf appended.
*
* Returns
*  None.
*****************************************************************************/
void appendleaf( char *path, char *leaf )
{
  strcat( path, "." );
  strcat( path, leaf );
}





/*****************************************************************************
* stripleaf
*
* This function strips the last leaf segment off the path passed in.
* The filename seperator is taken to be the '.' character
*
* Assumptions
*  If there are no seperator ('.') characters in te string, then the string
*   is unaltered.
*
* Inputs
*  path :        The path to be truncated.
*
* Outputs
*  path :         The truncated path.
*
* Returns
*  None.
*****************************************************************************/
void stripleaf( char *path )
{
  char *sep = strrchr( path, '.' );

  if (sep != NULL)
  {
    *sep = '\0';
  }
}





/*****************************************************************************
* compare_files
*
* This routine takes the path passed in and compares it with the other
*  resource sets. E.g. if a file ...UK.Foo was passed in, and the LocaleList
*  was set to UK,France,Germany it would compare ...Common.Foo, ...France.Foo
*  and ...Germany.Foo.
* The UK territory, being he first in the localelist, was used as te base for
*  the Common directory, and therefore must be identical and is not compared
*  for that reason.
*
* Assumptions
*  This routine alters the global array compared_files[], which contains the
*   paths to all the files to be compared.
*  It also deletes the file in the 'common' directory if it was not common, or
*   in the territory-specific directoties if it was common.
*
* Inputs
*  filename:     The name of the file to be compared.
*
* Outputs
*  None.
*
* Returns
*  It returns true if the file exists in all possible resource sets and they
*   match, false otherwise
*****************************************************************************/
bool compare_files(const char* filename)
{
  char buffer[255];
  char* path_segment;
  unsigned int length;
  unsigned int loop;
  bool matches = false;

  if (verbose)
  {
    printf("Comparing with %s\n", filename);
  }

  /* Get the segment of the path after the territory. */
  length = strlen(root_directory);
  path_segment = (char*)filename+length;
  length = strlen("Common");
  path_segment+=length+2;

  /* Now create the other filenames using the known path. */
  for (loop=0; loop < num_of_territories; loop++)
  {
    if (strcmp(supported_territories[loop], directory_to_copy) != 0) /* Ignore the one we copied, as files must be the same. */
    {
      sprintf(buffer, "%s.%s.%s", root_directory, supported_territories[loop], path_segment);
      //printf("Comparing with %s\n", buffer);
      compared_files[loop] = strdup(buffer);
    }
    else
    {
      /* Store the reference file */
      compared_files[loop] = strdup((char*)filename);
    }
  }

  if (verbose)
  {
    for (loop=0; loop < num_of_territories; loop++)
    {
       printf ("%s\n", compared_files[loop]);
    }
  }

  /* Perform the comparisons...*/
  if (!perform_comparisons())
  {
    /* Delete the files from the 'Common' directory */
    matches = false;
    remove_file(filename);
  }
  else
  {
    /* Delete the files from the other directories apart from the 'Common' one. */
    matches = true;
    /* Recurse through all the territories... We should just be left with the 'common' one in this case. */
    for (loop=0; loop < num_of_territories; loop++)
    {
      sprintf(buffer, "%s.%s.%s", root_directory, supported_territories[loop], path_segment);
      remove_file(buffer);
    }
  }

  /* Now free the memory... */
  for (loop=0; loop < num_of_territories; loop++)
  {
    if (compared_files[loop])
    {
      free (compared_files[loop]);
      compared_files[loop] = NULL;
    }
  }

  return (matches);
}




/*****************************************************************************
* remove_file
*
* Ths routine does exactly what it says on the tin - it removes the
*  specified file. It returns true if successful, false otherwise.
* If the global 'simulate' flag is set, then the file is not actually
*  deleted. This is useful if you wish to see what it will do before
*
* Assumptions
*  If the global flag 'simulate' is set then the file does not actualy get
*   deleted. This is handy fo testing the functionality of this utility
*   without having to regenerate resource tree each time.
*  If the global flag 'verbose' is set then the routine displays a diagnostic
*   statinf which file is being deleted.
*
* Inputs
*  file_to_remove: The name of the file to be removed.
*
* Outputs
*  None.
*
* Returns
*  true if the file was deleted, false otherwise.
*****************************************************************************/

bool remove_file(const char* file_to_remove)
{
  bool success = false;
  _kernel_swi_regs reg;

  if (verbose)
    printf("Removing file %s\n", file_to_remove);

  if (!simulate)
  {
    reg.r[0] = 6;		/* remove object */
    reg.r[1] = (int) file_to_remove;
    _kernel_swi(OS_File, &reg, &reg);
    success = true;
  }

  return (success);
}







/*****************************************************************************
* perform_comparisons
*
* This routine opens all the files held in the compared_files array and
*  attempts to compare them. It checks files are identical by the following
*  means:
*   1) Compare filetypes and sizes.
*   2) Open all the files
*   3) Read all th files byte-by-byte, compareing them, until a difference
*       is detected or the end of the file is reached.
*   4) Close all the files.
* Note that files of type Squash asre treated differently due to the fact
*  that identical files that have been squashed at different times will end
*  up with different header data.
*
* Assumptions
*  That the number of files to be opened is less than MAX_OPEN_TERRITORY_FILES.
*
* Inputs
*  None.
*
* Outputs
*  None.
*
* Returns
*  This routine returns true if all the files are the same, false otherwise.
*****************************************************************************/
bool perform_comparisons(void)
{
  FILE* file_handles[MAX_OPEN_TERRITORY_FILES]; /* An array to hold all the file handles */
  unsigned int loop;
  bool file_matches = true;
  unsigned int filesize[MAX_OPEN_TERRITORY_FILES] = 0;
  unsigned int filetype[MAX_OPEN_TERRITORY_FILES] = 0;

  /* Ensure that all the files exist and grab their filesizes and filetypes.*/
  for (loop=0; loop < num_of_territories; loop++)
  {
    assert (compared_files[loop] != NULL); /* Check we are not going to try to open a NULL pointer... */

    /* Ensure that all the files exist. */
    if (!file_exists(compared_files[loop]))
    {
      if (verbose)
        printf("%s does not exist.\n", compared_files[loop]);
      return (false);
    }

    /* Compare the filetypes and fileseizes */
    filetype[loop] = get_filetype(compared_files[loop]);
    filesize[loop] = file_size(compared_files[loop]);
    if (loop > 0 && ((filesize[loop] != filesize[loop-1]) || filetype[loop] != filetype[loop-1]))
    {
      if (verbose)
        printf("No match: differing file sizes or types!\n");
      return (false);
    }
  }

  /* Another check - if the files are squash files, then they will always be
      different. Check the headers of each file to ensure they are the same. */
  if (filetype[0] == FileType_Squash)
  {
    return (compare_squash_files()); /* We hsve no need to continue. */
  }

  /* In the future we may wish to treat spritefiles differently. This is a
      conditional to check for the presence of a spritefile. */
  if (filetype[0] == FileType_Sprite)
  {
    /* Do some magic munging here. We could possibly split all common sprites
        held within the spritefiles into a 'common' file to save ROM space. */
  }

  /* Open all the files. */
  for (loop=0; loop < num_of_territories; loop++)
  {
    assert (compared_files[loop] != NULL); /* Check we are not going to try to open a NULL pointer... */
    /* Open the file.. */
    if ((file_handles[loop]=fopen(compared_files[loop],"r")) == NULL)
    {
      if (verbose)
        printf("Error opening file %s for reading.\n", compared_files[loop]);
      return (false); /* If we can't open it, we are not bothered... (atm neway) */
    }
  }

  /* Scan through all the files on a byte-by-byte basis, comparing them. */
  while (!feof(file_handles[0]) && file_matches)
  {
    char bytes[MAX_OPEN_TERRITORY_FILES]; /* To hold the bytes from all the files... */
    bytes[MAX_OPEN_TERRITORY_FILES-1]='\0';
    for (loop=0; loop < num_of_territories; loop++)
    {
      bytes[loop] = getc(file_handles[loop]);
      if (loop > 0 && (bytes[loop] != bytes[loop-1]))
      {
        file_matches = false;
        break;
      }
    }
  }

  /* Close all the files */
  for (loop=0; loop < num_of_territories; loop++)
  {
    if (file_handles[loop])
    {
      fclose(file_handles[loop]);
    }
  }

  return (file_matches);
}





/*****************************************************************************
* descend
*
* This routine descends into the directory path passed in, reading all the
*  files and directories held within it. It can be caled recursively to scan
*  a whole directory structure.
* Any files that are in the path directory are compared using subsidiary
*  routines.
*
* Assumptions
*  That BUFSZ is large enough to hold any possible path.
*
* Inputs
*  path:         The path to be recursed from.
*
* Outputs
*  None.
*
* Returns
*  None.
*****************************************************************************/
void descend(char *path)
{
  char *buf = malloc( BUFSZ );
  int offset = 0;

  if ( buf != NULL )
  {
    do
    {
      object *op = (object *)buf;
      int nread;

      printf ("Comparing files in path %s\n", path);
      _swi( OS_GBPB, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5)|_IN(6)|_OUT(3)|_OUT(4),
              10, path, buf, 80, offset, BUFSZ, 0, &nread, &offset );

      while ( nread > 0 )
      {
        switch ( op->type )
        {
          case 1:
            /* Text file found so scan it for tags. */
            appendleaf( path, op->name );
            if (compare_files(path))
            {
            }
            else
            {
              printf ("Not matched: %s\n", path);
            }
            stripleaf( path );
            break;

          case 2:
            /* Directory found so descend into it.
             */
            appendleaf( path, op->name );
            descend( path );
            stripleaf( path );
            break;

          default:
            printf("Don't know how to process object type %d\n", op->type );
      }

        op = (object *)(((int)(op->name)+strlen(op->name)+4)&~3);
        nread -= 1;
      }
    } while ( offset != -1 );

    free( buf );
  }
  else
  {
    printf("Couldn't allocate enough memory\n" );
    exit (EXIT_FAILURE);
  }
}







/*****************************************************************************
* compare_resources
*
* This routine is the main routine that is called when attempting to compare
*  a set of resources.
*
* Assumptions
*  That root_directory exists, and that BUFSZ is large enoguh to hold a
*   string of length strlen(root_directory)+strlen(".Common"). Because it is
*   used within the descend() routine to hold the curren path, then BUFSZ will
*   have to be large enough to hold the longest path in the directory
*   structure below root_directory.
*
* Inputs
*  None.
*
* Outputs
*  buffer :      This gets altered  range of outputs, etc. List variables in
*                the same order that they appear in the function definition.
*
* Returns
*  This routine returns true.
*****************************************************************************/

bool compare_resources(void)
{
  char buffer[BUFSZ];

  assert(root_directory);

  /* Recurse down the directory structure... */
  sprintf(buffer, "%s.Common", root_directory);
  descend(buffer);

  return (true);
}




/*****************************************************************************
* cstrcmp
*
* This routine compares two string caselessly.
*
* Assumptions
*  State any assumptions and side effects (eg. globals changed)
*
* Inputs
*  a:            The first string to be compared.
*  b:            The second string to be compared.
*
* Outputs
*  None.
*
* Returns
*  0 if both strings are NULL, or both strings are (ignoring case) identical.
*  -1 if one (but not both) of the strings are NULL.
*  Any other value if the strings are different.
*****************************************************************************/

int cstrcmp(const char *a, const char *b)
{
  int d;

  if (a == NULL && b == NULL)
    return (0);

  if (a == NULL || b == NULL)
    return (-1);

  while (*a || *b) {
    d = tolower(*(a++)) - tolower(*(b++));
    if (d)
      return (d);
  }
  return (0);
}





/*****************************************************************************
* help_text
*
* Display a suitable help text.
*
* Assumptions
*  There are no assumptions.
*
* Inputs
*  None.
*
* Outputs
*  None.
*
* Returns
*  None.
*****************************************************************************/

void help_text(void)
{
  printf ("ResCommon\n");
  printf ("\n");
  printf ("Usage: ResCommon <root dir> [-t <territory_list>] [-v -h -s]\n");
  printf ("Commands: <root dir> n");
  printf ("Options:  -t <territory_list> A comma-seperated list of territories to use.\n");
  printf ("          -v                  Verbose. Display verbose output on what the utility is doing.\n");
  printf ("          -h                  Help. Display help text.\n");
  printf ("          -s                  Simulate. Do not delete any files.\n");
  printf ("\n");
  printf ("This utility looks for common resources held in different territories and palces them in a 'Common' directory. \n");
  printf ("This allows as may different resource sets as possible to be squeezed into one ROM image.\n");
  printf ("\n");
}





/*****************************************************************************
* main
*
* Main routine. This routine parses the command line argument passed in, sets
*  up appropriate data needed for the program and starts off the comparison
*  of the resources.
*
* Assumptions
*  None.
*
* Inputs
*  argc:         A count of the number of command-line arguments.
*  argv:         A vector containing the command line arguments.
*
* Outputs
*  None.
*
* Returns
*  EXIT_FAILURE if the program failed for some reason, otherwise,
*   EXIT_SUCCESS
*****************************************************************************/
int main(int argc, char **argv)
{
  char* locale_list = NULL;
  unsigned int i;

  if (argc < 2)
  {
    fprintf(stderr, "Usage: ResCommon <root dir> [-t <territory_list>] [-v -h -s]\n");
    exit (EXIT_FAILURE);
  }

  /* Define an atexit handler */
  atexit(exit_handler);

  for (i = 1; i < argc; i++)
  {
    // printf("arg %d: %s\n", i, argv[i]);
    if ((cstrcmp(argv[i], "-h") == 0) || (cstrcmp(argv[i], "-help") == 0))
    {
      help_text();
      exit(EXIT_FAILURE);
    }
    if ((cstrcmp(argv[i], "-v") == 0) || (cstrcmp(argv[i], "-verbose") == 0))
    {
      verbose = TRUE;
    }
    if ((cstrcmp(argv[i], "-t") == 0) || (cstrcmp(argv[i], "-territories") == 0))
    {
      /* The next arg should be a comma-separated territory list. */
      char* list = NULL;
      list = strdup(argv[++i]);
      parse_territories(list);
      if (list)
      {
        free (list);
        list = NULL;
      }
    }
    else
    {
      if ((cstrcmp(argv[i], "-s") == 0) || (cstrcmp(argv[i], "-simulate") == 0))
      {
        simulate = TRUE;
      }
    }
  }

  /* Read the required starting directory from the command line. */
  root_directory = strdup(argv[1]);
  if (verbose)
    printf("root directory is %s\n", root_directory);

  /* Ensure that root directory is a directory. */
  if (filer_object_type(root_directory) != 2)
  {
    fprintf(stderr, "Error: %s should be a directory.\n", argv[1]);
    exit (EXIT_FAILURE);
  }

  /* We need to see if a locale_list has been defined. If it has, we need to split it into a list of locales.
      Only do this if a valid list was not passed in on the command line. */
  if (num_of_territories == 0 && ((locale_list = read_env(ENV_LOCALE_LIST)) != NULL))
  {
    if (!parse_territories(locale_list))
    {
      /* An error occured whilst parsing the loale list. */
      printf("Malformed Locale list detected.");
      exit (EXIT_FAILURE);
    }
    free (locale_list);
    locale_list = NULL; /* locale_list is no longer needed */
  }

  if (num_of_territories == 0)
  {
    /* If there was not a locale list in env or on command line, report it and quit. */
    fprintf(stderr, "No locale list present.\n");
    exit (EXIT_SUCCESS); /* Success as the program should do nothing if there is no localelist. */
  }

  /* Ensure that the resource directories exist. */
  if (!ensure_resource_directories_exist())
  {
    printf("Not all resource directories exist.\n");
    exit (EXIT_FAILURE);
  }

  /* Copy the UK directory into the Common one. */
  directory_to_copy = strdup(supported_territories[0]);
  create_common(directory_to_copy);

  /* And now do the compariasons... */
  compare_resources();
}




/*****************************************************************************
* exit_handler
*
* This function can be used to clear up any outstanding memory left
*  afer the program has finished. It should only be used to delete
*  memory that is needed throughout the lifetime of the program, for
*  example the locale_list.
*
* Assumptions
*  There are no assumptions.
*
* Inputs
*  None.
*
* Outputs
*  None.
*
* Returns
*  None.
*****************************************************************************/
void exit_handler(void)
{
  unsigned int loop;

  /* Free the locale array if it has not already been free'd. */
  if (num_of_territories != 0)
  {
    for (loop=0; loop < num_of_territories; loop++)
    {
      if (compared_files[loop]) /* Memory has not been free'd. */
      {
        free (compared_files[loop]);
        compared_files[loop] = NULL;
      }
    }
    num_of_territories = 0;
  }

  /* Free the directory_to_copy memory */
  if (directory_to_copy)
  {
    free (directory_to_copy);
    directory_to_copy = NULL;
  }

  /* Free the root directory */
  if (root_directory)
  {
    free (root_directory);
    root_directory = NULL;
  }
}




/*****************************************************************************
* compare_squash_files
*
* This routine scans a number of squash files and returns whether or not they
*  are identical. This is necessary because identical files can be squahed
*  at different times and end up with different timestamps and load/exec
*  addreses due to when the Squash files were created. Therefore we ignore the
*  timestamp and exec data held in the Squashfile header.
*
* Assumptions
*  That the compared_files[] array contains num_of_territories files, and
*  that these files point to files of type Squash (&FCA). It also assumes
*  that the files are able to be opened for reading.
*  The routine should not alter the contents of any of the files.
*
* Inputs
*  None.
*
* Outputs
*  None.
*
* Returns
*  A boolean stating wether or not the files are identical.
*****************************************************************************/

bool compare_squash_files(void)
{
  bool file_matches = true;
  unsigned int loop;
  FILE* file_handles[MAX_OPEN_TERRITORY_FILES]; /* An array to hold all the file handles */
  squash_header_struct hdr[MAX_OPEN_TERRITORY_FILES];
  /* Squash file header is as follows: (PRM 4 appendix E):
  char[4] id      (should be SQSH)
  int size
  int load_addr
  int exec_addr
  int reserved    (should be 0)
  We would expect exec_addr to be different even if the two files are identical.
  */

  /* Open all the files. */
  for (loop=0; loop < num_of_territories; loop++)
  {
    assert (compared_files[loop] != NULL); /* Check we are not going to try to open a NULL pointer... */
    /* Open the file.. */
    if ((file_handles[loop]=fopen(compared_files[loop],"r")) == NULL)
    {
      if (verbose)
        printf("Error opening file %s for reading.\n", compared_files[loop]);
      return (false); /* If we can't open it, we are no bothered... (atm neway)*/
    }
  }

  /* Read in the header for all the files. */
  for (loop=0; loop < num_of_territories; loop++)
  {
    printf ("%s is a squash file...\n", compared_files[loop]);
    if (fread (&hdr[loop], sizeof(squash_header_struct), 1, file_handles[loop]) == 0)
    {
      printf("Read of the header for file %s failed.\n", compared_files[loop]);
    }
    else
    {
      if (loop > 0 && ((hdr[loop].size != hdr[loop-1].size) || (hdr[loop].load_addr != hdr[loop-1].load_addr))) /* We are not bothered with exec_addr as it contains the datestamp */
      {
        file_matches = false;
        break;
      }
      if (verbose)
      {
        printf("Size      for file %d is %0x\n", loop, hdr[loop].size);
        printf("Load addr for file %d is %0x\n", loop, hdr[loop].load_addr);
        printf("Exec addr for file %d is %0x\n", loop, hdr[loop].exec_addr);
        printf("reserved  for file %d is %0x\n", loop, hdr[loop].reserved);
      }
    }
  }

  /* Now go through the rest of the file and do a byte-by-byte comparison... */
  while (!feof(file_handles[0]))
  {
    char bytes[MAX_OPEN_TERRITORY_FILES]; // To hold the bytes from all the files...
    bytes[MAX_OPEN_TERRITORY_FILES-1]='\0';
    for (loop=0; loop < num_of_territories; loop++)
    {
      bytes[loop] = getc(file_handles[loop]);
      if (loop > 0 && (bytes[loop] != bytes[loop-1]))
      {
        // printf ("File %s do not match!\n", compared_files[loop]);
        file_matches = false;
        break;
      }
    }
  }

  /* Close all the files */
  for (loop=0; loop < num_of_territories; loop++)
  {
    if (file_handles[loop])
    {
      fclose(file_handles[loop]);
    }
  }

  return (file_matches);
}






/*****************************************************************************
* is_directory_empty
*
* This routine attempts to read the number of objects held in the directory
*  passed in. Ir returns true *only* if the object passed in is a directory
*  and there are no objects held within the directory.
*
* Assumptions
*  None.
*
* Inputs
*  directory   : The directory to be scanned.
*
* Outputs
*  None        : directory is a constant pointer.
*
* Returns
*  This routine returns true if the directory has no entries or is not a
*   valid directory, othrwise it returns true.
*****************************************************************************/
bool is_directory_empty(const char* directory)
{
  bool is_empty = false;

  if (filer_object_type(directory) == 2) /* It is a directory. */
  {
    /* Is directory empty? */
    char *buf = malloc( BUFSZ );
    int offset = 0;
    if ( buf != NULL )
    {
      int nread;
      _swi( OS_GBPB, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5)|_IN(6)|_OUT(3)|_OUT(4),
              10, directory, buf, 80, offset, BUFSZ, 0, &nread, &offset );
      if (verbose)
      {
        printf ("Number of files in directory %s is %d\n", directory, nread);
      }
      free (buf);
      if (nread == 0) /* There were no entries */
      {
        is_empty=true;
      }
    }
  }
  else
  {
    printf ("Warning: %s is not a directory.\n", directory);
  }

  return (is_empty);
}



/*****************************************************************************
* END OF FILE
*****************************************************************************/

