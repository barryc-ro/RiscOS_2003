; > OutputDump

        GET     ^.Generic.s.OutputDump

debugDump SETL true


;Macro to perform bit transforms on the data about to be sent to the
;device, this should be called proir to doing a counted string output
;it will preserve the start and size registers but will destory
;the three temporary registers.

        MACRO
$l      LJTranspose $start,$size,$temp1,$temp2,$temp3
$l
        Push    "$start,$size"  ;Preserve start and end points correctly
00
        SUBS    $size,$size,#1  ;Have we finished sending the line yet?
        BLT     %FT20           ;Yes so exit the main loop 

        LDRB    $temp1,[$start],#1
        MOV     $temp1,$temp1,LSL #24
        MOV     $temp2,#8       ;Reverse the top eight bits of $temp1
10
        MOVS    $temp1,$temp1,LSL #1
        MOV     $temp3,$temp3,RRX
        SUBS    $temp2,$temp2,#1
        BNE     %BT10           ;Loop back until all bits transposed

        MOV     $temp3,$temp3,LSR #24
        STRB    $temp3,[$start,#-1]
        B       %BT00           ;Make byte to be stored (copy top 8 bits down) and loop again
20
        Pull    "$start,$size"
        MEND
        
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; in:   r0  -> strip
;       r3   = dump width (in bytes)
;       r4   = dump height
;       r5   = row width in bytes ( >= r3 )
;       r7  -> job workspace
;
; Output strip as monochrome data to device.
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

output_mono_spriteV ROUT

        Push   "R1,LR"
        MOV    R3,R5
        MOV    R1,#"V"
        B      output_mono_altentryV

output_mono_sprite ROUT
              
        Push    "LR"
        MOV     R3,R5           ;Get the byte width of the image correct
                  
output_mono_altentry ROUT

        Push    "R1"
        MOV     R1,#"W"

output_mono_altentryV ROUT
;This version has scan type in R1 and R1,LR on stack

        LDRB    R7,[R7,#pd_private_flags]
        Debug   Dump,"PDumper byte contains",R7
10
        SWI     XOS_ReadEscapeState
        Pull    "R1,PC",CS         ;Return if escape pressed
                  
        Push    "R3"            ;Get the line width
15
        SUBS    R3,R3,#1
        BMI     %20             ;Any more bytes pending?

        LDRB    LR,[R0,R3]
        TEQ     LR,#0           ;Is there a valid byte here?
        BEQ     %15
20
        ADD     R3,R3,#1        ;Account for pre-index

        TST     R7,#pdf_Compression
        BLEQ    sendlj_compressoff
        BLNE    sendlj_compressed

        Pull    "R3"            ;Restore real line length

        ADD     R0,R0,R5
        SUBS    R4,R4,#1
        BNE     %BT10           ;Loop back until all scan lines checked       

        Pull    "R1,PC",,^

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Send a line of data uncompressed to the device.
;
;  in: R0 ->Line data
;      R1 = scan type (V or W)
;      R3 Length of the line to send in bytes
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                                 
sendlj_compressoff ROUT

        Push    "R0-R4,LR"
             
        Debuga  Dump,"Length of line to send",R3
        Debug   Dump," from",R0

        ADR     R0,line_prologue
        PDumper_PrintCountedString R0,R2,LR
        MOV     R0,R3
        BL      print_number
        PDumper_OutputReg R1    ;Send print line prologue
                 
        LDMIA   SP,{R0}         ;Get the length and the width
        LJTranspose R0,R3,R1,R2,R4
        PDumper_PrintLengthString R0,R3,R1

        Pull    "R0-R4,PC",,^

line_prologue   = 3,27,"*b"
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Send a line in Level 2 compression.
;
;  in: R0 ->Data line
;      R1 = scan type (V or W)
;      R3 Length of the line to send
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++                                

sendlj_compressed
        Push    "R0-R8,LR"
         
        MOV     R8,#0           ;Do not send any data as R1=0
        BL      compresslj      ;And return the size back in R1

        Debuga  Dump,"Scan to get length of line at",R0
        Debug   Dump,", yeilds length of",R1
        
        ADR     R2,line_prologuecompressed
        PDumper_PrintCountedString R2,R5,R8
        MOV     R0,R1
        BL      print_number
        LDR     R2,[SP,#4]      ;Pick the line characteristic off the stack
        PDumper_OutputReg R2    ;Describe the line characteristics to the printer

        LDMIA   SP,{R0-R3}
        LJTranspose R0,R3, R1,R2,R4

        MOV     R8,#-1          ;This time output the real data
        BL      compresslj
         
        Pull    "R0-R8,PC",,^

line_prologuecompressed 
        = 5,27,"*b2m"

;..............................................................................
; 
; Perform HP graphics compression (level 2) on the scan line specified, returning
; the length of the generated data and spooling data to the specified
; stream if required.
;
; in    R0 ->Line to compress
;       R3 byte length of the line
;       R8 flag to indicate if data should be sent
;
; out   R0 ->Byte after line sent
;       R1 length of data sent to stream
;       R3 preserved



compresslj ROUT

        Push    "R3,R6-R7,LR"

        MOV     R1,#0           ;Amount of data spat out so far
        ADD     R3,R0,R3        ;End point of the current line
        MOV     R4,#-1          ;No image data has been sent

        Debuga  Dump,"Compress line from",R0
        Debug   Dump," to",R3

compresslj_loop
        Debug   Dump,"Looping and checking byte from",R0

        TEQ     R0,R3           ;Has the line expired?
        BLEQ    compresslj_flush
        Pull    "R3,R6-R7,PC",EQ,^ 

        LDRB    R6,[R0],#1      ;Get a character
        TEQ     R0,R3           ;End of the line, ie. only a single byte remaining?
        BEQ     compresslj_single

        LDRB    R7,[R0]         ;Get the next byte to check for run lengthing
        TEQ     R6,R7           ;Is it a run length starting?
        BEQ     compresslj_scanrun
          
compresslj_single
        CMP     R4,#-1          ;Is there any image data already?
        SUBEQ   R4,R0,#1        ;Nope so back step and reset the length
        MOVEQ   R5,#0
        ADD     R5,R5,#1        ;Otherwise just update the length and loop again until finished
        B       compresslj_loop

;..............................................................................
;
; As a two byte sequence has been found we attempt to scan forward looking
; for a run length.  Once this has been scanned we then break it up
; into 128 character runs that are then sent to the stream if R8 is
; none zero.
;
; in    R0 ->character following start of section
;       R1 number of bytes already sent in this line
;       R3 ->end of line
;       R6 character obtained
;       R8 flag to indicate if data should be sent
;
; out   R0 updated (must be <= R3)
;       R1 updated
;       R8 preserved
        
compresslj_scanrun
        SUB     R7,R0,#1        ;Setup to contain the a copy of the start of the run length

        Debug   Dump,"Scanning a run length from",R7

compresslj_looprun
        TEQ     R0,R3           ;Have we reached the end of the line yet?
        BEQ     compresslj_finished

        LDRB    LR,[R0],#1      ;Get a character
        TEQ     LR,R6           ;Is it the same as the previous one?
        BEQ     compresslj_looprun

        SUB     R0,R0,#1        ;Backstep as this character is different

compresslj_finished
        Push    "R2,R7"         ;Store away the important registers
        BL      compresslj_flush
        Pull    "R2,R7"         ;Flush the image data preceeding the run and then restore registers

        SUBS    R7,R0,R7        ;Get the length of the run area
        BEQ     compresslj_loop ;If it is zero (by accident) then skip back

compresslj_flushrunlength
        Debug   Dump,"Flushing run length",R7

        Push    "R7"

        CMP     R7,#128         ;Can I send this section of data without clipping it?
        MOVGT   R7,#128         ;Truncate if too big man
        SUB     R7,R7,#1        ;Get the length -1
        RSB     R7,R7,#0        ;and then make -ve as run length info stored as -ve value

        ADD     R1,R1,#2        ;We will output two bytes so increase the bytes sent register
     
        TEQ     R8,#0           ;Do I need to write anything to the stream?
        BEQ     compresslj_flushrunskip

        PDumper_OutputReg R7    ;Send the length and then the byte to be replicated
        PDumper_OutputReg R6

compresslj_flushrunskip
        Pull    "R7"            ;Restore the length remaining
        SUBS    R7,R7,#128      ;Decrease the counter
        BGT     compresslj_flushrunlength
        B       compresslj_loop ;Try some more data and stream that to the file


;..............................................................................
; 
; Flush data to the stream, this routine is a general one called to flush
; any image data to the stream that is pointed to by R4 (and if R8 is non-zero).
;
; in    R1 number of bytes sent so far
;       R4 ->start of image data to be sent / =-1 for no image data
;       R5 length of image section to send / if R4 =-1 then ignored
;       R8 flag to indicate if data should be sent (<>0 then send)       
;                                           
; out   R1 updated
;       R4 -1 to indicate no image data remaining
;       R5 corrupt
;       R8 preserved

compresslj_flush
        CMP     R4,#-1          ;Is there any image data worth sending?
        MOVEQS  PC,LR           ;Nope so return now 
                                                    
        Push    "R2,LR"

compresslj_flushloop
        Debug   Dump,"Flushing image data length",R5

        Push    "R5"            ;Store the length of the run section

        CMP     R5,#128         ;Do I need to truncate it (ie. is it more than 128 characters)
        MOVGT   R5,#128         ;Yup so truncate
        ADD     R1,R1,#1  
        ADD     R1,R1,R5        ;Sending the length byte followed by the actual data for the section

        TEQ     R8,#0           ;Do we need to send any data to the stream?
        BEQ     compresslj_flushskip
        
        SUB     R2,R5,#1        ;Decrease the length so stored as length -1
        PDumper_OutputReg R2
        PDumper_PrintLengthString R4,R5,R2

compresslj_flushskip
        Pull    "R5"            ;Data has been spat out and R5 will have been corrupted so restore
        SUBS    R5,R5,#128
        BGT     compresslj_flushloop

        MOV     R4,#-1          ;Mark as their being no image data queued up
        Pull    "R2,PC",,^


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; in:   r0  -> strip
;       r3   = dump width
;       r4   = dump height
;       r5   = row width in bytes ( >= r3 )
;       r7  -> job workspace
;
; Ouput the 8BPP strip in colour. Bytes are KCMY, and have to be rearranged
; in situ, in order to do compression sensibly. The rearrangement is only
; possible, if like output_grey_sprite, the area of memory written lags
; behind the area read from. There is unfortunately a lower bound for this
; which has to be treated as a special case....
; Start is %0000KCMY %0000KCMY %0000KCMY ....
; Finish is %RRRRRRRR %RRRRRRRR... %GGGGGGGGG %GGGGGGGG... %BBBBBBBB ....
; First occupies N bytes
; Latter occupies (N/8+1)*3 at most
; First phase packs info into upper N/2+1 bytes at most

output_colour_sprite ROUT

        TEQ     R3,#0           ;Ignore zero widths!
        MOVEQS  PC,LR

        Push    "R0-R2,R4,R6-R8,LR"

        [ FourPlanes

        LDRB    LR,[R7,#pd_private_flags]
        TST     LR,#pdf_FourPlanes
        BEQ     colourlj_lineloop           ;Usual stuff...
        ;BNE     colourlj_lineloop           ;Usual stuff...
;This is an approximate copy of the Escape-P2 driver!
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; in:   r0  -> strip
;       r3   = dump width
;       r4   = dump height
;       r5   = row width in bytes ( >= r3 )
;       r7  -> job workspace
;
; Ouput the 8BPP strip in colour. Bytes are KCMY, and have to be rearranged
; in situ, in order to do compression sensibly. The rearrangement is only
; possible, if like output_grey_sprite, the area of memory written lags
; behind the area read from. There is unfortunately a lower bound for this
; which has to be treated as a special case....
; Start is %0000KCMY %0000KCMY %0000KCMY ....
; Finish is %YYYYYYYY %YYYYYYYY... %MMMMMMMM... %CCCCCCCC.... %KKKKKKKK...
; First occupies N bytes
; Latter occupies (N/8+1)*4 at most
; First phase packs info into upper N/2+1 bytes at most
        Debug   , "in FourPlanes stuff"

        Debug   Dump,"Converting colour to monochrome"
        Debuga  Dump,"At",R0
        Debuga  Dump,", Width",R3
        Debuga  Dump,", Height",R4
        Debuga  Dump,", Byte width",R5
        Debug   Dump,", Workspace at",R7

colourE2_lineloop

        Push    "R0,R3-R5,R7"         ;will need this again

        CMP     R3,#5           ;fewer than 5 bytes to store in?
        BGT     longE2_colour   ;enough for a general algorithm
        BLT     vshortE2_colour ;bit of a stupid bloody picture
        BL      shortE2_colour
        B       colourE2_rearranged

vshortE2_colour
;Oh hell I'll have to use the stack!
        SUB     SP,SP,#8
        MOV     R1,#0
        STR     R1,[SP]
        LDRB    R1,[R0,#0]      ;At least one byte (see above)
        STRB    R1,[SP,#0]
        CMP     R3,#2
        LDRGEB  R1,[R0,#1]
        STRGEB  R1,[SP,#1]
        CMP     R3,#3
        LDRGEB  R1,[R0,#2]
        STRGEB  R1,[SP,#2]
        CMP     R3,#4
        LDRGEB  R1,[R0,#3]
        STRGEB  R1,[SP,#3]
        MOV     R0,SP
        BL      shortE2_colour
        BL      colourE2_colourstrip
        ADD     SP,SP,#8        ;Balance the stack
        B       colourE2_nextline

longE2_colour
        Push    "R0,R3,R7"      ;Need to keep position of strip for output
        Push    "R0,R3"         ;and for CMYK scanning

        ADD     R0,R0,R3        ;->Scan line end to shuffle up
        MOV     R1,R0           ;second pointer for save

        TST     R3,#1           ;Is the line length odd?
        SUBNE   R0,R0,#1        ;if so the last byte stays the same
        SUBNE   R1,R1,#1
        SUBNE   R3,R3,#1        ;Length is now definitely even

10      LDRB    R4,[R0,#-1]!    ;Load colours
        LDRB    R7,[R0,#-1]!

        ORR     R4,R7,R4,LSL#4  ;Munge together as a single byte
        STRB    R4,[R1,#-1]!    ;and keep for next pass

        SUBS    R3,R3,#2        ;Finished the even bit yet?
        BNE     %BT10

        Pull    "R0,R3"         ;Restore the line start, count
        MOV     R4,#1:SHL:0     ;Current ribbon (start at Y!)
20
        MOV     R2,#1:SHL:0     ;Bit to modify output
        MOV     R6,#0           ;Current bit to set
        MOV     R7,#0           ;Byte so far
        Push    "R1,R3"         ;Read from here for each pass
30
        LDRB    R8,[R1],#1      ;Get two CMYK clusters
        TST     R8,R4           ;Check the "ribbon"
        ORRNE   R7,R7,R2,LSL R6 ;and set a bit if required
        ADD     R6,R6,#1
        TST     R8,R4,LSL#4
        ORRNE   R7,R7,R2,LSL R6
        ADD     R6,R6,#1
        ANDS    R6,R6,#7
        STREQB  R7,[R0],#1      ;Write a destination byte if finished a complete one
        MOVEQ   R7,#0
        SUBS    R3,R3,#2        ;May go to 0 or -1
        BGT     %BT30

        ANDS    R6,R6,#7
        STRNEB  R7,[R0],#1      ;Store the byte if bit index >0
        Pull    "R1,R3"         ;Get the input data back
        MOV     R4,R4,LSL#1     ;Next ribbon
        ANDS    R4,R4,#15       ;Check if bit is in range
        BNE     %BT20

        Pull    "R0,R3,R7"

colourE2_rearranged
        BL      colourE2_colourstrip

colourE2_nextline

        Pull    "R0,R3-R5,R7"      
        ADD     R0,R0,R5        ;Adjust the line pointer
        SUBS    R4,R4,#1
        BGT     colourE2_lineloop ;Loop back until all bits tested

colourE2_exit
        Pull    "R0-R2,R4,R6-R8,PC",,^

colourE2_colourstrip
;So now can do four output_mono_strip's from R0 width R3 job R7
        Push    "LR"

        ADD     R5,R3,#7
        MOV     R5,R5,LSR#3
        MOV     R4,#1
        ADD     R0,R0,R5
        ADD     R0,R0,R5,LSL#1                 ;Starts with K!!

        Push    "R0,R3,R4,R5,R7"               ;Keep this lot for each pass
        BL      output_mono_spriteV

        Pull    "R0,R3,R4,R5,R7"
        SUB     R0,R0,R5                       ;Back down to previous colour
        Push    "R0,R3,R4,R5,R7"

        BL      output_mono_spriteV

        Pull    "R0,R3,R4,R5,R7"
        SUB     R0,R0,R5
        Push    "R0,R3,R4,R5,R7"

        BL      output_mono_spriteV

        Pull    "R0,R3,R4,R5,R7"
        SUB     R0,R0,R5

        BL      output_mono_sprite          ;W to terminate

        Pull    "PC"

shortE2_colour
;Exactly 4 bytes to store in!
        Push    "R5,R6,R7,LR"
        LDRB    R1,[R0,#0]
        LDRB    R2,[R0,#1]
        LDRB    R4,[R0,#2]
        LDRB    R5,[R0,#3]
        LDRB    R6,[R0,#4]
;Yellow 
        MOV     R7,#0
        TST     R1,#(1:SHL:0)
        ORRNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:0)
        ORRNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:0)
        ORRNE   R7,R7,#1:SHL:2
        TST     R5,#(1:SHL:0)
        ORRNE   R7,R7,#1:SHL:3
        TST     R6,#(1:SHL:0)
        ORRNE   R7,R7,#1:SHL:4
        STRB    R7,[R0,#0]
;Magenta
        MOV     R7,#0
        TST     R1,#(1:SHL:1)
        ORRNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:1)
        ORRNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:1)
        ORRNE   R7,R7,#1:SHL:2
        TST     R5,#(1:SHL:1)
        ORRNE   R7,R7,#1:SHL:3
        TST     R6,#(1:SHL:1)
        ORRNE   R7,R7,#1:SHL:4
        STRB    R7,[R0,#1]
;Cyan
        MOV     R7,#0
        TST     R1,#(1:SHL:2)
        ORRNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:2)
        ORRNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:2)
        ORRNE   R7,R7,#1:SHL:2
        TST     R5,#(1:SHL:2)
        ORRNE   R7,R7,#1:SHL:3
        TST     R6,#(1:SHL:2)
        ORRNE   R7,R7,#1:SHL:4
        STRB    R7,[R0,#2]
;Key
        MOV     R7,#0
        TST     R1,#(1:SHL:3)
        ORRNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:3)
        ORRNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:3)
        ORRNE   R7,R7,#1:SHL:2
        TST     R5,#(1:SHL:3)
        ORRNE   R7,R7,#1:SHL:3
        TST     R6,#(1:SHL:3)
        ORRNE   R7,R7,#1:SHL:4
        STRB    R7,[R0,#3]

        Pull    "R5,R6,R7,PC"

        ]

;----------------USUAL STUFF FOR 3-BIT PLANES---------------------

        Debug   Dump,"Converting colour to monochrome"
        Debuga  Dump,"At",R0
        Debuga  Dump,", Width",R3
        Debuga  Dump,", Height",R4
        Debuga  Dump,", Byte width",R5
        Debug   Dump,", Workspace at",R7

colourlj_lineloop

        Push    "R0,R3-R5,R7"         ;will need this again

        CMP     R3,#3           ;fewer than 3 bytes to store in?
        BGT     longlj_colour   ;enough for a general algorithm
        BLT     vshortlj_colour ;bit of a stupid bloody picture
        BL      shortlj_colour
        B       colourlj_rearranged

vshortlj_colour
;Oh hell I'll have to use the stack!
        SUB     SP,SP,#4
        MOV     R1,#0
        STR     R1,[SP]
        LDRB    R1,[R0,#0]      ;At least one byte (see above)
        STRB    R1,[SP,#0]
        CMP     R3,#2
        LDRGEB  R1,[R0,#1]
        STRGEB  R1,[SP,#1]
        MOV     R0,SP
        BL      shortlj_colour
        BL      colourlj_colourstrip
        ADD     SP,SP,#4        ;Balance the stack
        B       colourlj_nextline

longlj_colour
        Push    "R0,R3,R7"      ;Need to keep position of strip for output
        Push    "R0,R3"         ;and for CMYK scanning

        ADD     R0,R0,R3        ;->Scan line end to shuffle up
        MOV     R1,R0           ;second pointer for save

        TST     R3,#1           ;Is the line length odd?
        SUBNE   R0,R0,#1        ;if so the last byte stays the same
        SUBNE   R1,R1,#1
        SUBNE   R3,R3,#1        ;Length is now definitely even

10      LDRB    R4,[R0,#-1]!    ;Load colours
        TST     R4,#8
        MOVNE   R4,#7           ;and put back CMY for K!

        LDRB    R7,[R0,#-1]!
        TST     R7,#8
        MOVNE   R7,#7           ;second four-bit set

        ORR     R4,R7,R4,LSL#4  ;Munge together as a single byte
        STRB    R4,[R1,#-1]!    ;and keep for next pass

        SUBS    R3,R3,#2        ;Finished the even bit yet?
        BNE     %BT10

        Pull    "R0,R3"         ;Restore the line start, count
        MOV     R4,#1:SHL:2     ;Current ribbon
20
        MOV     R2,#1:SHL:0     ;Bit to modify output
        MOV     R6,#0           ;Current bit to set
        MOV     R7,#255         ;Byte so far
        Push    "R1,R3"         ;Read from here for each pass
30
        LDRB    R8,[R1],#1      ;Get two CMY clusters
        TST     R8,R4           ;Check the "ribbon"
        BICNE   R7,R7,R2,LSL R6 ;and clear a bit if required
        ADD     R6,R6,#1
        TST     R8,R4,LSL#4
        BICNE   R7,R7,R2,LSL R6
        ADD     R6,R6,#1
        ANDS    R6,R6,#7
        STREQB  R7,[R0],#1      ;Write a destination byte if finished a complete one
        MOVEQ   R7,#255
        SUBS    R3,R3,#2        ;May go to 0 or -1
        BGT     %BT30

        ANDS    R6,R6,#7
        STRNEB  R7,[R0],#1      ;Store the byte if bit index >0
        Pull    "R1,R3"         ;Get the input data back
        MOVS    R4,R4,LSR#1     ;Next ribbon
        BNE     %BT20

        Pull    "R0,R3,R7"

colourlj_rearranged
        BL      colourlj_colourstrip

colourlj_nextline

        Pull    "R0,R3-R5,R7"      
        ADD     R0,R0,R5        ;Adjust the line pointer
        SUBS    R4,R4,#1
        BGT     colourlj_lineloop ;Loop back until all bits tested

colourlj_exit
        Pull    "R0-R2,R4,R6-R8,PC",,^

colourlj_colourstrip
;So now can do three output_mono_strip's from R0 width R3 job R7
        Push    "LR"

        ADD     R5,R3,#7
        MOV     R5,R5,LSR#3
        MOV     R4,#1

        Push    "R0,R3,R4,R5,R7"               ;Keep this lot for each pass
        BL      output_mono_spriteV

        Pull    "R0,R3,R4,R5,R7"
        ADD     R0,R0,R5
        Push    "R0,R3,R4,R5,R7"

        BL      output_mono_spriteV

        Pull    "R0,R3,R4,R5,R7"
        ADD     R0,R0,R5

        BL      output_mono_sprite          ;W to terminate

        Pull    "PC"

shortlj_colour
;Exactly 3 bytes to store in!
        Push    "R7,LR"
        LDRB    R1,[R0,#0]
        LDRB    R2,[R0,#1]
        LDRB    R4,[R0,#2]
;Red (=>Opposite of Cyan)
        MOV     R7,#255
        TST     R1,#(1:SHL:2):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:2):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:2):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:2
        STRB    R7,[R0,#0]
;Green
        MOV     R7,#255
        TST     R1,#(1:SHL:1):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:1):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:1):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:2
        STRB    R7,[R0,#1]
;Blue
        MOV     R7,#255
        TST     R1,#(1:SHL:0):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:0
        TST     R2,#(1:SHL:0):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:1
        TST     R4,#(1:SHL:0):OR:(1:SHL:3)
        BICNE   R7,R7,#1:SHL:2
        STRB    R7,[R0,#2]
        Pull    "R7,PC"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; in:   r0  -> strip
;       r3   = dump width
;       r4   = dump height
;       r5   = row width in bytes ( >= r3 )
;       r7  -> job workspace
;
; Output and 8BPP strip for the current device, this is done by converting
; the data from the 8BPP data to the 1BPP data suitable for printing via
; the monochrome output routines, we need not attempt to perform bit
; reversal.
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


output_grey_sprite ROUT

        Push    "R0-R2,R4,R6-R8,LR"


        Debug   Dump,"Converting to monochrome"
        Debuga  Dump,"At",R0
        Debuga  Dump,", Width",R3
        Debuga  Dump,", Height",R4
        Debuga  Dump,", Byte width",R5
        Debug   Dump,", Workspace at",R7
       
        MOV     R1,R0           ;->Scan line to convert
        MOV     R2,#1:SHL:0     ;Bit to modify in source data
10
        Push    "R1,R3-R5"      ;Store the byte width of the line
        
        MOV     R4,#0           ;Reset the pixel to write
        MOV     R6,#0
15
        SUBS    R3,R3,#1        ;Decrease the pixel count along the scan line
        BLT     %FT20           ;If <min width then exit
        
        LDRB    R7,[R1],#1      ;Get a byte from the source and check to see if bit is set
        TST     R7,#1:SHL:0     ;use the bottom bit, not the K bit!!
        ORRNE   R4,R4,R2,LSL R6

        ADD     R6,R6,#1
        ANDS    R6,R6,#7
        STREQB  R4,[R0],#1      ;Write a destination byte if finished a complete one
        MOVEQ   R4,#0           ;...and then reset the byte to write
        B       %BT15
20
        ANDS    R6,R6,#7
        STRNEB  R4,[R0],#1      ;Store the byte if bit index >0

        ADD     R0,R0,#3
        BIC     R0,R0,#3        ;Align to a word boundary (nb - pad bytes contain crap!)

        Pull    "R1,R3-R5"      
        ADD     R1,R1,R5        ;Adjust the line pointer
        SUBS    R4,R4,#1
        BGT     %BT10           ;Loop back until all bits tested
         
        ADD     R3,R3,#7
        MOV     R3,R3,LSR #3    ;Ensure a nice byte width of the scan
        ADD     R5,R3,#3
        BIC     R5,R5,#3        ;Word align the width of the strip

        Pull    "R0-R2,R4,R6-R8"
        B       output_mono_altentry


        END
