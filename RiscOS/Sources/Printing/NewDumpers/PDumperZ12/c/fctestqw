
/****************************************************************************
 * FCTESTQW.C   Quick Win App                        Lexmark Confidential
 *
 * $Revision$
 * $Date$
 * $Author$
 *
 *
 * Description:
 *    FCTESTQW.C is our development program which we use to develop and exercise
 *    the hbpcode for any printer outside of a driver environment.
 *
 *
 * No.   Date     Who  Function              Description of Change
 * --------------------------------------------------------------------------
 * 001  03/05/98  jbb  All functions         Begin changing functions to
 *      adhere to our coding standards.
 *
 * 002  03/05/98  jbb  main()                Added an #if define around the
 *      initialization of lpxDataRec->bBitsPerPixel to be equal 2 for Rome
 *      and 1 for all other printers.
 *
 * 003  03/11/98  jbb  Several functions     Made more code cleanup changes,
 *      getting rid to BYTE and replacing with ByteType, for example.
 *
 * 004  03/11/98  jbb  main()                Changed the exit algorithm for
 *      the 32bit development environment so the dot count information would
 *      stay on the screen longer.
 *
 * 005  03/12/98  jbb  main()                Began initializing some
 *      DVDATAREC alignment values that only Kelvin / Zurich uses.
 *
 * 006  04/05/98  jbb  main()                Changed initialization of
 *      variable lpxDataRec->dwSecondsSinceLastPrint from 60 to 0;
 *
 * 007  04/28/98  jbb  main()                Minor code cleanup.
 *
 * 008  09/13/98  wlc  main()                Major changes to call formatter
 *                                           code DLL.
 *
 * 009  01/12/99  xzhan  main()				disable the default bMediaType 
 *											and bQuality
 *
 * 010  03/29/99  xzhan copy John's lstest.c windows file i/o, and remove the 
 *      dotcount file.   Now support multi-pages printing
 ****************************************************************************/

//#pragma warning (disable: 4001)  /* nonstandard ext 'single line comment' */
//#pragma warning (disable: 4103)  /* used #pragma pack to change alignment */

//#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//#include <memory.h>
//#include <malloc.h>
#include <time.h>


#ifndef TRUE
   #define TRUE 1
#endif

#ifndef FALSE
   #define FALSE 0
#endif

#include "hbpfunc.h"
#include <io.h>

void FAR PASCAL _loadds _export SendToFile(void FAR * , void FAR * , DwordType );

/* Added the following to make the HBP code a DLL  9/11/98 wlc */
typedef WordType (CALLBACK *EXTSTARTDOC) (LPDVDATAREC);
typedef WordType (CALLBACK *EXTSTARTPAGE) (LPDVDATAREC);
typedef void (CALLBACK *EXTENDPAGE) (LPDVDATAREC);
typedef void (CALLBACK *EXTENDDOC) (LPDVDATAREC);
typedef WordType (CALLBACK *EXTOUTPUTSTRIP) (LPDVDATAREC, LPByteType, SdwordType, SwordType,SwordType);
typedef void (CALLBACK *EXTGETINKUSAGE) (LPDVDATAREC, LPDOTCOUNTS);

EXTSTARTDOC    lpfnFCStartDoc;
EXTSTARTPAGE   lpfnFCStartPage;
EXTOUTPUTSTRIP lpfnFCOutputStrip;
EXTENDPAGE     lpfnFCEndPage;
EXTENDDOC      lpfnFCEndDoc;
EXTGETINKUSAGE lpfnFCGetInkUsage;


HFILE             flOutFile;
HFILE             flInFile;
OFSTRUCT          xOutFileInfo;
OFSTRUCT          xInFileInfo;
OFSTRUCT FAR *    lpxOutFileInfo;
OFSTRUCT FAR *    lpxInFileInfo;

void     Convert4PlaneTo3Plane(ByteType *npbInLine, WordType wBytesPerPlane);
WordType DVSetShingle(LPDVDATAREC lpxDataRec, SwordType nDPI, 
                      SwordType nShingle );
void     ReadINIFile(LPDVDATAREC lpxDataRec, LPByteType lpbSectionName);

/***************************************************************************
 * FCTESTQW.C                                        Lexmark Confidential
 *
 * Function Name:    main
 *
 * Description:
 *    This is the main function for executing the new formatter code in a
 *    Quick Win App development environment.
 *
 * Inputs:  argc  Should always be equal to 3.
 *          argv  Expecting two file names.  The first is the name of the
 *                input file which contains raster lines to process.  The
 *                second is the name of the output file where the print
 *                swaths are written.
 *
 * Outputs: <none>
 *
 * Major Functions Called:    FCStartDoc
 *                            FCStartPage
 *                            FCOutputStrip
 *                            FCEndPage
 *                            FCEndDoc
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void _cdecl main(int argc, char *argv[])
{

   LPDVDATAREC lpxDataRec;
   LPDOTCOUNTS lpDotCounts;
   HINSTANCE   hFcDllInst;

   clock_t     
      start,
      finish;
   double      duration;

#ifndef COPEN
   ByteType    bValue;
#endif
   LPWordType  lpwTempWord;

   SdwordType sdwStripStart;

#ifndef COPEN
   WordType    
      wNewLocation1,
      wNewLocation2,
      wOldLocation,
      wPlaneSize;
#endif
   WordType    
      wNumPasses,
      wReturnCode,
      wLineLimitPerPage,
      wResolution;
#ifndef COPEN
   SwordType   
      i,j;
#endif
   SwordType   
      swNumLines=0,
      swLineSize,
      nCharsRet,
      swScanStart,
      swScanEnd,
      swShingle;
   ByteType    
      *npbInLine,
      *npbInLine2,
      abInLine[80],
      abFcDllToCall[12],
      abTempString[20],
      bInputColorPlanes;
   BoolType    
      fTerminate = TRUE,
      fGetNextRasterLine;

   //#ifdef GEN_BIDI
   //struct tHwData FAR *lpHwData;
   //#endif

   start = clock();

   if ( (lpxDataRec = (LPDVDATAREC) _fmalloc(sizeof(DVDATAREC))) == NULL)
   {
      printf("Error: Couldn't allocate lpDevice.\n");
      exit(0);
   }

   if ((argc != 6)&&(argc != 7 ))
   {
      printf("Syntax: fctestqw lxcafc.dll -x|n -shingle <ini_sectionn> input_file output_file\n");
      exit(0);
   }
   /* Copy name of formatter code dll to local string variable */
   _fstrcpy((char *)abFcDllToCall,argv[1]);

   _fstrcpy((char *)abTempString,argv[2]);
   if ((abTempString[1] == 'n') || (abTempString[1] == 'N'))
   {
      fTerminate = FALSE;
   }

   _fstrcpy((char *)abTempString,argv[3]);
   swShingle = (SwordType) atoi((char *)&(abTempString[1]));
   switch (swShingle)
   {
   case 0 :
   case 2 :
   case 3 :
   case 4 :
      break;
   case 50 :
      swShingle = 2;
      break;
   case 33 :
      swShingle = 3;
      break;
   case 25 :
      swShingle = 4;
      break;
   default :
      printf("Error: Invalid value for shingle amount.\n");
      printf("Syntax: fctestqw.exe lxcafc.dll -x|n -shingle <ini section> input_file output_file\n");
      exit(0);
   }

   /* call function ReadINIFile() to get alignment values from the            */
   /* development INI file.                                                   */
   if (argc == 7)
   {
      ReadINIFile(lpxDataRec, argv[4]);
   }
   else
   {
      ReadINIFile(lpxDataRec, "DEFAULT");
   }


   lpxInFileInfo = &xInFileInfo;
   if (argc == 6)
   {
      flInFile = OpenFile(argv[4],lpxInFileInfo,OF_READ);
      if (flInFile == HFILE_ERROR)
      {
         printf("ERROR: input file %s could not be opened.\n",argv[3]);
         exit(-1);
      }
   }
   else
   {
      flInFile = OpenFile(argv[5],lpxInFileInfo,OF_READ);
      if (flInFile == HFILE_ERROR)
      {
         printf("ERROR: input file %s could not be opened.\n",argv[4]);
         exit(-1);
      }
   }

   lpxOutFileInfo = &xOutFileInfo;
   if (argc == 6)
   {
      flOutFile = OpenFile(argv[5],lpxOutFileInfo,OF_CREATE | OF_WRITE);
      if (flOutFile == HFILE_ERROR)
      {
         printf("ERROR: output file %s could not be opened.\n",argv[4]);
         exit(-1);
      }
   }
   else
   {
      flOutFile = OpenFile(argv[6],lpxOutFileInfo,OF_CREATE | OF_WRITE);
      if (flOutFile == HFILE_ERROR)
      {
         printf("ERROR: output file %s could not be opened.\n",argv[5]);
         exit(-1);
      }
   }
   printf("\nReading input file  : %s",xInFileInfo.szPathName);
   printf("\nWriting output file : %s\n\n\n",xOutFileInfo.szPathName);


   /* Load the Formatter Code DLL and get addresses for all called functions */
   if ( (hFcDllInst = LoadLibrary(abFcDllToCall)) < HINSTANCE_ERROR)
   {
      /* could not load Formatter Code dll, so return error */
      printf("ERROR: Could not load Formatter Code DLL.\n",abFcDllToCall);
      exit(-1);
   }
   if ( (lpfnFCStartDoc = (EXTSTARTDOC) GetProcAddress( hFcDllInst,"FCStartDoc")) == NULL)
   {
      printf("ERROR: Could not get address of FcStartDoc  \n");
      exit(-1);
   }
   if ( (lpfnFCStartPage = (EXTSTARTPAGE) GetProcAddress( hFcDllInst,"FCStartPage")) == NULL)
   {
      printf("ERROR: Could not get address of FcStartPage  \n");
      exit(-1);
   }
   if ( (lpfnFCEndPage = (EXTENDPAGE) GetProcAddress( hFcDllInst,"FCEndPage")) == NULL)
   {
      printf("ERROR: Could not get address of FcEndPage  \n");
      exit(-1);
   }
   if ( (lpfnFCEndDoc = (EXTENDDOC) GetProcAddress( hFcDllInst,"FCEndDoc")) == NULL)
   {
      printf("ERROR: Could not get address of FcEndDoc  \n");
      exit(-1);
   }
   if ( (lpfnFCOutputStrip = (EXTOUTPUTSTRIP) GetProcAddress( hFcDllInst,"FCOutputStrip")) == NULL)
   {
      printf("ERROR: Could not get address of FcOutputStrip  \n");
      exit(-1);
   }

   if ( (lpfnFCGetInkUsage = (EXTGETINKUSAGE) GetProcAddress( hFcDllInst,"FCGetInkUsage")) == NULL)
   {
      printf("ERROR: Could not get address of FcOutputStrip  \n");
      exit(-1);
   }

   /* Set the address of SendCommand so we get called back */
   lpxDataRec->lpfnSendCommand = (EXTSENDCMD)GetProcAddress(0,"SendToFile");



   lpxDataRec->lpLXDevice      = (DwordType)NULL;
   lpxDataRec->bMediaSize      = PAPER_LETTER;
   lpxDataRec->bMediaSource    = AUTO_FEED;
   lpxDataRec->wSwathWidth     = 2400;
   lpxDataRec->bBitsPerPixel   = 1;
   lpxDataRec->bCompress       = 0;


#if defined(ROME) ||defined(PARIS)
   if (wResolution == 600)
   {
      lpxDataRec->bBitsPerPixel   = 2;
   }
   else
   {  /* Rome 300 and 1200 dpi are always 1 bit per pixel */
      lpxDataRec->bBitsPerPixel   = 1;
   }
#else
   lpxDataRec->bBitsPerPixel   = 1;
#endif

   _lread(flInFile,abInLine,10);

   lpwTempWord              = &((void)abInLine[0]);
   lpxDataRec->bColorPlanes = (ByteType)(*lpwTempWord);
   bInputColorPlanes        = lpxDataRec->bColorPlanes;

#if defined(CAIRO)
   if (lpxDataRec->bColorPlanes == 4)
   {
      printf("Converting 4 color print job to 3 color print job.\n\n");
      lpxDataRec->bColorPlanes = 3;
   }
#endif

   lpwTempWord             = &((void)abInLine[2]);
   wResolution             = (*lpwTempWord)*300;
   lpwTempWord             = &((void)abInLine[4]);
   lpxDataRec->wTopMargin   = *lpwTempWord;
   lpwTempWord             = &((void)abInLine[6]);
   lpxDataRec->wLeftMargin  = *lpwTempWord;

   lpxDataRec->bRightCartridgeID = COL_CARTRIDGE;
   swLineSize = (SwordType)wResolution;


   /* set up the maximum line number per page */
   if (wResolution==1200)
   {
      wLineLimitPerPage = 2*6600;
   }
   else
   {
      wLineLimitPerPage = 6600;
   }

   switch (bInputColorPlanes)
   {
   case 1 :
      lpxDataRec->bLeftCartridgeID = MONO_CARTRIDGE;
      break;
   case 3 :
#ifdef COPEN
         if (bMode==0)
      {
         swLineSize *= 3;
      }
      else
      {
         swLineSize *= 6;
      }
#else
         swLineSize *= 3;
#endif
      lpxDataRec->bLeftCartridgeID = MONO_CARTRIDGE;
      break;
   case 4 :

#ifdef COPEN
         if (bMode==0)
      {
         swLineSize *= 4;
      }
      else
      {
         swLineSize *= 7;
      }
#else
         swLineSize *= 4;
#endif
      lpxDataRec->bLeftCartridgeID = MONO_CARTRIDGE;
      break;
   case 6 :
      swLineSize *= 6;
      lpxDataRec->bLeftCartridgeID = KCM_CARTRIDGE;
      break;
   default :
      printf("Unexpected value for number of color planes\n");
      exit(0);
   }
#ifdef COPEN
   wNumPasses = SetPrintMode(lpxDataRec, bMode);
#else
   lpxDataRec->bDocumentType = INTENT_GRAPHIC;
   wNumPasses = DVSetShingle(lpxDataRec, (SwordType)wResolution, swShingle);
#endif

   lpxDataRec->dwSecondsSinceLastPrint = 0L;



   printf("                Shingle level : %d pass\n",wNumPasses);
   printf("        Horizontal adjustment : %d\n",lpxDataRec->bHorizontalAdj);
   printf("          Vertical adjustment : %d\n",lpxDataRec->bVerticalAdj);
   printf(" CMY bidirectional adjustment : %d\n",lpxDataRec->bBidiAlignColor);
   printf("Mono bidirectional adjustment : %d\n\n\n",lpxDataRec->bBidiAlignMono);



   /* go ahead and allocate as much memory as you might possibly need,  */
   /* which is 1200*6*2+10 = 14410 bytes.                               */
   npbInLine = (ByteType *) malloc((14410));
   if (npbInLine == NULL)
   {
      printf("Error.  Unable to allocate space for npbInLine.\n");
      exit(-1);
   }

   npbInLine2 = (ByteType *) malloc((swLineSize+10));
   if (npbInLine2 == NULL)
   {
      printf("Error.  Unable to allocate space for npbInLine2.\n");
      exit(-1);
   }

   wReturnCode = lpfnFCStartDoc(lpxDataRec);
   if (wReturnCode == FALSE)
   {
      printf("Error, FCStartDoc did not complete successfully\n");
      exit(-1);
   }

   //lpxPFData = (LPPFDATA) lpxDataRec->lpLXDevice;

   wReturnCode = lpfnFCStartPage(lpxDataRec);
   if (wReturnCode == FALSE)
   {
      printf("Error, FCStartPage did not complete successfully\n");
      exit(-1);
   }

   fGetNextRasterLine = TRUE;
   do 
   {
      if (fGetNextRasterLine)
      {
         nCharsRet = _lread(flInFile,npbInLine,(swLineSize+6));
      }
      if ( (bInputColorPlanes == 4) && (lpxDataRec->bColorPlanes == 3) )
      {
         Convert4PlaneTo3Plane(npbInLine+6,wResolution);
      }

      if (nCharsRet != 0)
      {
         swNumLines++;
         lpwTempWord    = &((void)npbInLine[0]);
         sdwStripStart   = (SwordType)(*lpwTempWord);
         lpwTempWord    = &((void)npbInLine[2]);
         swScanStart    = (SwordType)(*lpwTempWord);
         lpwTempWord    = &((void)npbInLine[4]);
         swScanEnd      = (SwordType)(*lpwTempWord);

#ifndef COPEN
         if (lpxDataRec->bBitsPerPixel == 2)
         {  /* double all color planes, including the black plane in CMYK  */
            /* printing, although we know the 2nd black plane will get     */
            /* ignored.                                                    */
            wPlaneSize = (WordType)(swLineSize / lpxDataRec->bColorPlanes);
            switch (lpxDataRec->bColorPlanes)
            {
            case 1 :
               break;
            case 4 :
               i = 4;
               wOldLocation  = (i-1)*wPlaneSize;
               wNewLocation1 = (i-1)*2*wPlaneSize;
               for (j=wPlaneSize; j>0; j--)
               {
                  bValue = npbInLine[wOldLocation+j];
                  npbInLine[wNewLocation1+j] = bValue;
               }
               /* intentionally falling through to CMY case */
            case 3 :
               for (i=3; i>0; i--)
               {
                  wOldLocation  = (i-1)*wPlaneSize;
                  wNewLocation1 = (i-1)*2*wPlaneSize;
                  wNewLocation2 = (((i-1)*2)+1)*wPlaneSize;
                  for (j=wPlaneSize; j>0; j--)
                  {
                     bValue = npbInLine[wOldLocation+j];
                     npbInLine[wNewLocation2+j] = bValue;
                     npbInLine[wNewLocation1+j] = 0x00;
                  }
               }
               break;
            case 6 :
               for (i=6; i>0; i--)
               {
                  wOldLocation  = (i-1)*wPlaneSize;
                  wNewLocation1 = (i-1)*2*wPlaneSize;
                  wNewLocation2 = (((i-1)*2)+1)*wPlaneSize;
                  for (j=wPlaneSize; j>0; j--)
                  {
                     bValue = npbInLine[wOldLocation+j];
                     npbInLine[wNewLocation2+j] = bValue;
                     npbInLine[wNewLocation1+j] = 0x00;
                  }
               }
               break;
            }
         }
#endif
         if (sdwStripStart>(SdwordType)wLineLimitPerPage)
         {
            lpfnFCEndPage(lpxDataRec);
            wReturnCode = (WordType)lpfnFCStartPage(lpxDataRec);
            if (wReturnCode == FALSE)
            {
               printf("Error, FCStartPage did not complete successfully\n");
               exit(-1);
            }
         }
         else
         {
            wReturnCode = lpfnFCOutputStrip(lpxDataRec,(LPByteType)(npbInLine+6),sdwStripStart,swScanStart,
                                            swScanEnd);
            if (wReturnCode)
            {
               printf("Error, Unexpected return code from FCOutputStrip, RC = %d\n",wReturnCode);
               exit(0);
            }
         }
      }  /* end of if (nCharsRet != 0) */
   }while (nCharsRet != 0);

   lpfnFCEndPage(lpxDataRec);


   finish = clock();
   duration = (double)(finish - start) / CLOCKS_PER_SEC;
   printf("raster lines read in = %d, time = %4.2f seconds\n",swNumLines,
          duration);

   if ( (lpDotCounts = (LPDOTCOUNTS) _fmalloc(sizeof(DOTCOUNTS))) != NULL)
   {
      lpfnFCGetInkUsage(lpxDataRec, lpDotCounts);
      printf("Dot Count 1 = %8ld\n",lpDotCounts->sdwInk1);
      printf("Dot Count 2 = %8ld\n",lpDotCounts->sdwInk2);
      printf("Dot Count 3 = %8ld\n",lpDotCounts->sdwInk3);
      printf("Dot Count 4 = %8ld\n",lpDotCounts->sdwInk4);
      printf("Dot Count 5 = %8ld\n",lpDotCounts->sdwInk5);
      printf("Dot Count 6 = %8ld\n",lpDotCounts->sdwInk6);
   }

   lpfnFCEndDoc(lpxDataRec);
   _lclose(flInFile);
   _lclose(flOutFile);


#if defined(FC_DOS_32)
   printf("\n\nEnter 'x' to exit...  ");
   scanf( "%s", &abTempString);
#else
   if (fTerminate)
   {
      _wsetexit(_WINEXITNOPERSIST);
      exit(1);
   }
#endif

   return;

}


WordType DVSetShingle(LPDVDATAREC lpxDataRec, SwordType nDPI,
                      SwordType nShingle)
{
   WordType       wNumPasses;


   /* set defaults */
   lpxDataRec->bQuality      = QUALITY_NORMAL;
   lpxDataRec->bMediaType    = PLAIN_PAPER;
   lpxDataRec->bDocumentType = INTENT_BUSINESS;
   wNumPasses = 2;

   if ((nDPI == 300) && (nShingle == 0))
   {
      lpxDataRec->bQuality      = QUALITY_DRAFT;
      lpxDataRec->bMediaType    = PLAIN_PAPER;
      lpxDataRec->bDocumentType = INTENT_BUSINESS;
      wNumPasses = 1;
   }
   else if (nDPI == 300)
   {
      printf("Only 1 pass printing supported for draft quality.\n");
      printf("Converting to 1 pass printing.\n");
      lpxDataRec->bQuality   = QUALITY_DRAFT;
      lpxDataRec->bMediaType = PLAIN_PAPER;
      lpxDataRec->bDocumentType = INTENT_BUSINESS;
      wNumPasses = 1;
   }
   else if ((nDPI == 600) && (nShingle == 0))
   {
      lpxDataRec->bQuality      = QUALITY_NORMAL;
      lpxDataRec->bMediaType    = PLAIN_PAPER;
      lpxDataRec->bDocumentType = INTENT_BUSINESS;
      wNumPasses = 1;
   }
   else if ((nDPI == 600) && (nShingle == 2))
   {
      lpxDataRec->bQuality      = QUALITY_NORMAL;
      lpxDataRec->bMediaType    = PLAIN_PAPER;
      lpxDataRec->bDocumentType = INTENT_PHOTO;
      wNumPasses = 2;
   }
   else if ((nDPI == 600) && (nShingle == 3))
   {
      lpxDataRec->bQuality      = QUALITY_NORMAL;
      lpxDataRec->bMediaType    = GLOSSY_PAPER;
      lpxDataRec->bDocumentType = INTENT_BUSINESS;
      wNumPasses = 3;
   }
   else if ((nDPI == 600) && (nShingle == 4))
   {
      printf("4 pass LQ printing not supported.  ");
      printf("Converting to 2 pass LQ printing.\n");
      lpxDataRec->bQuality      = QUALITY_NORMAL;
      lpxDataRec->bMediaType    = PLAIN_PAPER;
      lpxDataRec->bDocumentType = INTENT_PHOTO;
      wNumPasses = 2;
   }
   else if ((nDPI == 1200) && (nShingle == 2))
   {
      lpxDataRec->bQuality      = QUALITY_HIGH;
      lpxDataRec->bMediaType    = PLAIN_PAPER;
      lpxDataRec->bDocumentType = INTENT_BUSINESS;
      wNumPasses = 2;
   }
   else if (nDPI == 1200)
   {
      printf("Only 2 pass printing supported for high quality.\n");
      printf("Converting to 2 pass printing.\n");
      lpxDataRec->bQuality      = QUALITY_HIGH;
      lpxDataRec->bMediaType    = PLAIN_PAPER;
      lpxDataRec->bDocumentType = INTENT_BUSINESS;
      wNumPasses = 2;
   }

   return(wNumPasses);

}  /* end of DVSetShingle() */




/*******************************************************************************
* Function Name: Convert4PlaneTo3Plane
*
* Description:
*   This function merges the 4th plane into the first 3 planes.
*    
* Original Author: J. Bates
* Data:  10/09/98
*
******************************************************************************/
void Convert4PlaneTo3Plane(ByteType *npbInLine, WordType wBytesPerPlane)
{
   LPByteType     lpbP1, lpbP2, lpbP3, lpbP4;
   WordType       wI;


   lpbP1 = (LPByteType) npbInLine;
   lpbP2 = lpbP1 + wBytesPerPlane;
   lpbP3 = lpbP1 + (wBytesPerPlane * 2);
   lpbP4 = lpbP1 + (wBytesPerPlane * 3);

   for (wI=0; wI<wBytesPerPlane; wI++)
   {
      *lpbP1++ |= *lpbP4;
      *lpbP2++ |= *lpbP4;
      *lpbP3++ |= *lpbP4++;
   }

   return; 

} 


/****************************************************************************
 * Function Name:    SendToFile
 *
 * Description:
 *    This function is called from the HBP DLL to output print swath data into a file.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to file.
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 ***************************************************************************/

void FAR PASCAL _loadds _export SendToFile(void FAR * lpDevice, void FAR * cmd_ptr,
                                           DwordType dwLength)
{
   WordType       wDataToWrite;
   HPByteType     hpbDataPtr;

   hpbDataPtr = (HPByteType) cmd_ptr;


   if (dwLength > 64000 )
   {
      wDataToWrite = (WordType) (dwLength / 4);
      _lwrite(flOutFile,hpbDataPtr,wDataToWrite);
      hpbDataPtr += wDataToWrite;
      _lwrite(flOutFile,hpbDataPtr,wDataToWrite);
      hpbDataPtr += wDataToWrite;
      _lwrite(flOutFile,hpbDataPtr,wDataToWrite);
      hpbDataPtr += wDataToWrite;
      wDataToWrite = (WordType) ((dwLength) - ((DwordType)wDataToWrite * 3));
      _lwrite(flOutFile,hpbDataPtr,wDataToWrite);
   }
   else
   {
      _lwrite(flOutFile,hpbDataPtr,(WordType)dwLength);
   }

   return;

}




void ReadINIFile(LPDVDATAREC lpxDataRec, LPByteType lpbSectionName)
{
   HFILE             flINIFile;
   OFSTRUCT          xINIFileInfo;
   OFSTRUCT FAR *    lpxINIFileInfo;
   ByteType          abINIFileName[50];


   strcpy(abINIFileName,"CPDDEV.INI");
   lpxINIFileInfo = &xINIFileInfo;
   flINIFile = OpenFile(abINIFileName,lpxINIFileInfo,OF_EXIST);
   if (flINIFile == HFILE_ERROR)
   {
      printf("CPD development INI file CPDDEV.INI not found.\n");
      printf("Using internal defaults for alignment values.\n\n");
      lpxDataRec->bHorizontalAdj  = 15;
      lpxDataRec->bVerticalAdj    = 8;
      lpxDataRec->bBidiAlignColor = 15;
      lpxDataRec->bBidiAlignMono  = 15;
      return;
   }


   printf("Reading section [%s] from CPDDEV.INI\n\n",lpbSectionName);


   lpxDataRec->bHorizontalAdj  = GetPrivateProfileInt(lpbSectionName,"HORZ_ADJ",15,abINIFileName);
   lpxDataRec->bVerticalAdj    = GetPrivateProfileInt(lpbSectionName,"VERT_ADJ", 8,abINIFileName);
   lpxDataRec->bBidiAlignMono  = GetPrivateProfileInt(lpbSectionName,"MONO_ADJ",15,abINIFileName);
   lpxDataRec->bBidiAlignColor = GetPrivateProfileInt(lpbSectionName,"CMY_ADJ", 15,abINIFileName);

   return;

}

/* set print mode for copenhagan*/
WordType SetPrintMode(LPDVDATAREC lpxDataRec, ByteType bMode)
{
   WordType       wNumPasses;

   lpxDataRec->bDocumentType = INTENT_GRAPHIC;
   switch (bMode)
   {
   case 1: //Mode B
      lpxDataRec->bMediaType  =  PLAIN_PAPER;
      lpxDataRec->bQuality    =  QUALITY_NORMAL;
      wNumPasses = 2;

      break;
   case 2:  //Mode C
      lpxDataRec->bMediaType  =  COATED_PAPER;
      lpxDataRec->bQuality    =  QUALITY_NORMAL;
      wNumPasses = 2;

      break;
   case 3:  //mode D
      lpxDataRec->bMediaType  =  GLOSSY_PAPER;
      lpxDataRec->bQuality    =  QUALITY_NORMAL;
      break;
   case 4:  //Mode E
      lpxDataRec->bMediaType  =  PLAIN_PAPER;
      lpxDataRec->bQuality    =  QUALITY_HIGH;
      break;
   case 5:  //Mode test
      lpxDataRec->bMediaType  =  COATED_PAPER;
      lpxDataRec->bQuality    =  QUALITY_HIGH;
      break;
   default: //Mode A
      lpxDataRec->bMediaType  =  PLAIN_PAPER;
      lpxDataRec->bQuality    =  QUALITY_DRAFT;
      wNumPasses = 1;
      break;
   }
   return wNumPasses;

}

