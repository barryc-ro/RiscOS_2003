
/****************************************************************************
 * FcRotate.c                                      Lexmark Confidential
 *
 * $Revision$
 * $Date$
 * $Author$
 *
 *
 * Description:
 *    FCROTATE.C contains the function, Rotate(), which rotates the raster
 *    lines into swaths.
 *
 *
 * No.   Date     Who  Function              Description of Change
 * --------------------------------------------------------------------------
 * 026  02/10/99  wlc   Moved 1200 dpi correction for reversed built swath
 *      so it only gets done once per swath.
 *
 * 027  02/20/99  bsp   Wrong placement of dots in 6 planes corrected.
 *
 * 028  03/09/99  wlc   Fix problem with OPTION_CDE to add wStartSlice.
 *
 * 029  04/23/99  xzhan Add option to record dotcounts for each color at each swath
 *
 * 030  05/21/99  xzhan fix 2 bitperpixel reverse printing for paris
 *
 * 031  06/21/99  bsp   gave additional LTOR capability to 600_as_2x300
 *
 * 032  07/19/99  xzhan fix the reverse print for 2 bit perpixel
 *
 * 033  09/16/99  bsp   get K in 1200 CMYK to use OPTION_1200_AS_2X600.
 *
 * 034  09/17/99  bsp   removed a bug in OPTION_1200_AS_2X600.
 *
 * 035  09/21/99  bsp   Use OPTION_K_1200_AS_2X600 for K in 1200dpi CMYK
 *
 * 036  10/06/99  xzhan change the wStartSlice when changing the lpxPFData->swLeftPrintPos
 *      lpxPFData->swRightPrintPos to fix 1200 dpi reverse printing problem
 *
 * 037  10/19/99  wlc   Remove extra comma after 5th parm in ReverseNozzleOffset
 *       call statement.
 *
 * 038  10/21/99 xzhan change lpxPFData->aswDelayKSwath[swOut], wRowToFree in
 *      HiResPostSwathAdjust() and HiResPreSwathAdjust(), change SHINGLE_25 shingle mask
 *      in GetHiRasterLineShingleMask() to make 1200dpi as 2-pass 600 dpi working
 *      comment out lpxPFData->swLeftPrintPos,lpxPFData->swRightPrintPos increase/decrease
 *      to make reverse swath print work.
 *
 * 039  10/26/99  wlc   Remove all support for building a reverse swath.  Swaths
 *      are always built from left to right and can be reversed when required
 *      in the printer specific file either in the Compress() function or by
 *      calling a seperate function when compression is disabled.
 *
 *      040  11/03/99  xzhan  add 2400x1200 dpi(SHIRES_INTERLACED, 8-pass and 16-pass) support
 *
 * 041  12/16/99 xzhan PreSwathAdjust() set fMustPrintColor[3] = TRUE for draft mode, 4 colorplanes
 *      to cahnge the stepsize from 68, 60 to 0, 128
 *
 * 042  01/17/00  xzhan change 4-color black in 1200dpi mode to 33% shingling(true 1200dpi swath)
 *      to improve quality. Ptr 33577(Osaka), Ptr 33578(Nairobi), Ptr 33549(Paris)
 *
 * 043  01/20/99  wlc   Code clean up and remove unused macros.
 *
 * 044  04/27/00  xzhan add OPTION_K_1200_AS_2x600 in rotate()
 *
 * 045  05/02/00  xzhan add OPTION_K_1200_AS_2x600 in HiResPostSwathAdjust() and
 *      HiResPreSwathAdjust()
 ****************************************************************************/

/************** Definitions & Macros **************************************/

#if !defined(NOPRAGMA)
//#pragma warning (disable: 4103)  /* used #pragma pack to change alignment */
#endif

/************** Include Files *********************************************/

#include "common.h"

#if defined(DOS_BUILD) || defined(FC_DOS_32)
#include <stdio.h>
#endif

#if !defined(FC_WIN_32) && !defined(FC_OS2) && !defined(PACE)
#include <memory.h>
#endif


/************** Global Variable Declarations *********************************/

/* set object module level ID */
static char fc_version[] = "fcrotate $Revision$";


/***************************************************************************
 * Function Name:    Rotate
 *
 * Description:
 *    This is the function that rotates raster lines into a print swath.
 *    It rotates the appropriate raster lines into the print swath.  It also
 *    applies the shingling mask, if one is required.  After creating the
 *    print swath, several pieces of information are added to the 26 byte
 *    print swath header, such as slice count, left margin, and right
 *    margin.
 *
 * Inputs:  lpxDataRec   Far pointer to HBP interface structure.
 *          swBuffers    Tells which buffers to use when building the print
 *                       swath, ie CMY, K, KCM.
 *
 * Outputs: SwordType  number of lines moved down the page.  Positive number
 *                     indicates there is a swath which needs to be printed.
 *                     Negative number means the swath is empty, so move the
 *                     page by SwordType amount but don't print a swath.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 *************************************************************************/
SwordType Rotate(LPDVDATAREC lpxDataRec, SwordType swBuffers, SdwordType sdwRow)
{
   LPPFDATA    lpxPFData;

   LPWordType  lpwSwathWord;

   LPWordType  lpwRaster,
               lpwRastMask,
               lpwRM,
               lpwRMStart,
               lpwRMEnd;

   WordType    i, k,
               wIEnd=0,
               wIndx,
               wIStart=0,
               wKKInc,
               wLeftMargin,
               wNozzleCount=0,
               wPrintMaskWord,
               wRasterWord,
               wRowsToPrint,
               wSeg,
               wShingle=0,
               wSliceCount,
               wSliceWord,
               wSwathScanEnd,
               wSwathScanStart,
               wSwathSeg,
               wSWInc,
               wBitsToProcess,              /* added for 1200 to 2 pass 600 */
               wStartSlice;                 /* added for 1200 to 2 pass 600 */

   SwordType   j,
               swJEnd,
               swJStart,
               swKCMOffset,
               swNozzle,
               swNozzleGap=0,
               swNozzleOffset,
               swOut,
               swRastRes,
               swRowsMoved,
               swScanIndex,
               swShingle16=0,
               swShingle25=0,
               swShingle33=0,
               swShingle50=0,
               swSwathRes,
               swSwathScanEnd=0,
               swSwathScanStart=299,
               swVertAdj=0,
               swVertRes;

   SdwordType  r,
               sdwBufSize,
               sdwInIndex,
               sdwOutIndex,
               sdwRowStart;

   DwordType   kk,
               dwColorOffset,
               dwSwathByteOffset,
               dwSwathOffset,
               dwSwathWordOffset;

   SdwordType  asdwDotCount[6] = {0,0,0,0,0,0},
               sdwSwathDotCount=0;

   LPByteType  pbPrtDat;

   ByteType    bBytesPerSlice,
               bColorPlanes,
               bDropsPerPixel,
               bResolution,
               bSwathDir;

   BoolType    fEmptySwath=TRUE,
               fShingled=TRUE;

   LPWordType  lpwRaster2 = NULL;
   WordType    wShingle2 = 0,
               wRasterWord2;
   BoolType    fShingled2 = FALSE;

#if OPTION_CDE
   BoolType    fCDE;
   WordType    wCDEBoundary;
#endif


   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

#if CPROF
   PrfEnter(7);
#endif

#if OPTION_CDE
   fCDE              = lpxPFData->fCDE;
#endif

   /* initialize local variables */
   bColorPlanes      = lpxPFData->bColorPlanes;
   bResolution       = lpxPFData->bResolution;
   lpwRastMask       = lpxPFData->lpwRastMask;
   swVertRes         = lpxPFData->swVertResMult;
   swRastRes         = lpxPFData->swRastResMult;
   swSwathRes        = lpxPFData->swSwathResMult;
   wLeftMargin       = lpxPFData->wLeftMargin;
   wSliceCount       = 0;
   swSwathScanStart  = lpxPFData->swPreRotateStart;
   swSwathScanEnd    = lpxPFData->swPreRotateEnd;
   wSwathScanStart   = (WordType)lpxPFData->swPreRotateStart/2;
   wSwathScanEnd     = (WordType)(lpxPFData->swPreRotateEnd+1)/2;
   swRowsMoved       = (SwordType) lpxPFData->wRowsToMove;
   lpxPFData->sdwSwathDotCount = 0;

   /* Set print direction flags to OFF to support printing in opposite
      direction of last swath.  This was added to support the Birch print head.
      These flags will get updated in GetPrintDir() when the swath needs to
      be printed in opposite direction of last swath.  These flags can only be
      equal to 1 when the call to GetPrintDir() returns BIDI for the print
      direction. */
   lpxPFData->bPrintCMYOpposite   = 0;
   lpxPFData->bPrintBLKOpposite   = 0;
   lpxPFData->bPrintSwathOpposite = 0;

   /* Initialize variables to rotate every bit in raster line to slice and    */
   /* start with slice 0.  These are changed below for 1200 dpi 50% shingled  */
   /* that will be printed as 2 pass 600 dpi.                                 */
   wBitsToProcess = 1;            /* rotate every bit in raster line to slice */
   wStartSlice = 0;               /* make sure we start with first slice      */

   swOut = lpxPFData->swOut;
   if (swOut == FC_OUT_EVEN)
   {
      swRowsMoved -= 3;
   }
   else if (swOut == FC_OUT_ODD)
   {
      swRowsMoved += 3;
   }

#if OPTION_1200_AS_2X600
   /* Added the following for 1200 to 2 pass 600 printing */
   /* See if this is a 1200 dpi swath that is shingled at 50%.  If so we can
      print it as 2 pass 600 dpi swath, so set a flag for checking later.    */
   /* Now all of CMYK planes use OPTION_1200_AS_2X600
   except that 4 color black in 1200dpi still use 33% shingling
   */

#if OPTION_K_1200_AS_2x600
   if((lpxPFData->fOPTION_1200_AS_2X600 == TRUE)&&
      ((bResolution == HIRES_INTERLACED) ||
       (bResolution == SHIRES_INTERLACED)))
#else
   if((lpxPFData->fOPTION_1200_AS_2X600 == TRUE)&&
      ((bResolution == HIRES_INTERLACED &&
      (swBuffers == CMYPLANES || swBuffers == KCMPLANES ||
      (swBuffers == KPLANE && bColorPlanes != 4)))||
       bResolution == SHIRES_INTERLACED))
#endif
   {
      /* Set flag to print 1200 dpi as 2 pass 600 dpi */
      lpxPFData->bShingleHiRes = SHINGLE_50;

      /* Get the starting slice (0 or 1). This value is initialized at the
         start of each page in FCStartPage() and alternates for each swath.
         Process all even or odd slices for this swath.  Update the starting
         slice for next even raster line swath  */
      wStartSlice = GetHiResStartSlice(lpxPFData, swOut, swBuffers);

      /*Rotate only every other bit in raster to slice */
      if(bResolution == SHIRES_INTERLACED)
      {
         /* Adjust the swath resolution from 2400 dpi to 600 dpi */
         wBitsToProcess = 4;
         swSwathRes /= 4;
      }
      else
      {
         /* Adjust the swath resolution from 1200 dpi to 600 dpi */
         wBitsToProcess = 2;
         swSwathRes /= 2;
      }
   }
   else
   {  /* Not 1200 dpi or 1200 dpi that is not shingled at 50% */
      lpxPFData->bShingleHiRes = NO_SHINGLE;
   }
#else
   /* Don't print 1200 dpi 50% shingled as 2 pass 600 dpi */
   lpxPFData->bShingleHiRes = NO_SHINGLE;
#endif

#if OPTION_600_AS_2X300
   /*  Below if statement was put in to turn off OPTION_600_AS_2X300 for K */
   /*  in a CMYK job shingled at 50%                                       */
   if ( (bResolution == LORES) &&
        (lpxPFData->bShingle == SHINGLE_50) &&
        ( (swBuffers == CMYPLANES) || (swBuffers == KCMPLANES) ||
          ( (swBuffers == KPLANE) && (bColorPlanes != 4) ) ) )
   {
      lpxPFData->bShingleLoRes = SHINGLE_50;
      wBitsToProcess = 2; /*Rotate only every other bit in raster to slice    */
      swSwathRes /= 2;    /* Nozzle offset adjustment is also required as well.*/

      if (swBuffers == CMYPLANES)
      {
         lpxPFData->fCMYSwathBuild = TRUE;
      }
      else
      {
         lpxPFData->fCMYSwathBuild = FALSE;
      }
   }
   else
   {
      lpxPFData->bShingleLoRes = NO_SHINGLE;
   }
#else
   /* Don't print 600 dpi 50% shingled as 2 pass 300 dpi */
   lpxPFData->bShingleLoRes = NO_SHINGLE;
#endif

   switch (swBuffers)
   {
   case CMYPLANES :
      lpxPFData->bPrintHead   = COL_CARTRIDGE;
      wSliceCount            += (WordType)(MAGENTA_OFFSET*swSwathRes);
      wSliceCount            += (WordType)(COLOR_NOZZLE_OFFSET*swSwathRes);
      wIStart                 = 0;
      wIEnd                   = 3;
      lpxPFData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
      wNozzleCount            = (WordType) lpxPFData->swColorNozzleCount;
      swNozzleGap             = COLOR_NOZZLE_OFFSET;
      swVertAdj               = 0;
      break;

   case KCMPLANES :
      if (wLeftMargin)
      {
         wLeftMargin         -= (WordType)(KCM_HORZ_OFFSET*swSwathRes);
      }
      lpxPFData->bPrintHead   = KCM_CARTRIDGE;
      wSliceCount            += (WordType)(MAGENTA_OFFSET*swSwathRes);
      wSliceCount            += (WordType)(COLOR_NOZZLE_OFFSET*swSwathRes);
      wIStart                 = 3;
      wIEnd                   = 6;
      lpxPFData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
      wNozzleCount            = (WordType) lpxPFData->swColorNozzleCount;
      swNozzleGap             = COLOR_NOZZLE_OFFSET;
      swVertAdj               = 0;
      break;

   case KPLANE:
      if (bColorPlanes == 4)
      {
         /* CMYK print job */
         lpxPFData->bBytesPerSlice  = CMY_BYTES_PER_SLICE;
         swVertAdj                  = (SwordType) lpxDataRec->bVerticalAdj;
         wIStart                    = 3;
         wIEnd                      = 4;
      }
      else
      {
         /* K print job */
         wIStart = 0;
         wIEnd   = 1;
         if ( (bResolution == HIRES_INTERLACED) ||
               bResolution == SHIRES_INTERLACED||
              (bResolution == HIRES_NONINTERLACED) )
         {
            lpxPFData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
            swVertAdj                 = (SwordType)lpxDataRec->bVerticalAdj;
         }
         else
         {
            lpxPFData->bBytesPerSlice = K_BYTES_PER_SLICE;
            swVertAdj               = 0;
         }
      }
      lpxPFData->bPrintHead  = MONO_CARTRIDGE;
      wSliceCount         += (WordType)(MONO_NOZZLE_OFFSET*swSwathRes);
      wNozzleCount         = (WordType) lpxPFData->swMonoNozzleCount;
      swNozzleGap          = MONO_NOZZLE_OFFSET;
      break;
   }  /* end of switch(nBuffers) */

   /* Set for product.C file use */
   lpxPFData->bPrintDirection = GetPrintDir(lpxDataRec, swBuffers);

   /* set as locals */
   bBytesPerSlice             = lpxPFData->bBytesPerSlice;
   lpxPFData->swLeftPrintPos  = RastertoPrintPos(swSwathScanStart,
                                (SwordType)wLeftMargin);
   /* clear print swath */
   ClearPrintSwath(lpxPFData);

   bSwathDir = FORWARD;

   if ( lpxPFData->bShingleHiRes == SHINGLE_50 )
   {  /* Print 1200dpi 50% shingled as 2 swaths(even or odd slices) at 600dpi.*/
      /* Adjust left and right print position for even or odd slice pass in   */
      /* 1200 dpi.                                                            */
      lpxPFData->swLeftPrintPos  += wStartSlice;

      /* left and right print position are calculated in 1200 dpi.  */
      if(bResolution == SHIRES_INTERLACED)
      {
         wSliceCount *= 4;  /* convert nozzle gap to 1200 dpi */
      }
      else
      {
         wSliceCount *= 2;  /* convert nozzle gap to 1200 dpi */
      }
      wSliceCount += (WordType)(swSwathScanEnd - swSwathScanStart)*8;

      /* Calculate right print position. The (wSliceCount -1) added
         to the left print position gives the  horiz coordinate of the
         rightmost slice.  The other -1 is done because the actual
         slice count is one less than the total number of slices.
         It's one less on right when we print the even slices and one
         less on the left when we print the odd slices. */
      lpxPFData->swRightPrintPos = lpxPFData->swLeftPrintPos +
                                   (wSliceCount - 1 ) - 1;

      /* only half as many slices at 600 as we have at 1200 */
      if(bResolution == SHIRES_INTERLACED)
      {
         wSliceCount = wSliceCount/4;
      }
      else
      {
         wSliceCount = wSliceCount/2;
      }
   }
   else
   {

#if OPTION_600_AS_2X300
      /* In new 600 dpi, only a half of the usual number of slices are built.  */
      if (lpxPFData->bShingleLoRes == SHINGLE_50)
      {
         if (lpxPFData->fCMYSwathBuild )
         { /* processing CMY swath */
         /* bidi capable */
        /* Odd swath needs movement of 1/600 to right or left before printing. */
            if ( (lpxPFData->wCMYSwathByPgCtr % 2) == 0 )
            {
               wStartSlice = 1;
               lpxPFData->swLeftPrintPos++;
            }
         }
         else
         {  /* processing K or Kcm swath */
            if ( (lpxPFData->wKOrKcmSwathByPgCtr % 2) == 1 )
            {
               wStartSlice = 1;
               lpxPFData->swLeftPrintPos++;
            }
         }
         wSliceCount += (WordType)((swSwathScanEnd - swSwathScanStart) * 8 / 2);
         lpxPFData->swRightPrintPos = lpxPFData->swLeftPrintPos +
                                  (SwordType)((wSliceCount - (SwordType)1) * 2);
      }
      else
      {
         wSliceCount += (WordType)((swSwathScanEnd - swSwathScanStart)*8);
         lpxPFData->swRightPrintPos = lpxPFData->swLeftPrintPos +
                                  (SwordType)wSliceCount - (SwordType)1;
      }
#else
      {
         wSliceCount += (WordType)((swSwathScanEnd - swSwathScanStart)*8);
         lpxPFData->swRightPrintPos = lpxPFData->swLeftPrintPos +
                                  (SwordType)wSliceCount - (SwordType)1;
      }
#endif
   }

   for (i=wIStart; i<wIEnd; i++)
   {  /* Once for each plane of color */
      sdwOutIndex    = lpxPFData->asdwDBIndx[swOut][i];
      sdwInIndex     = lpxPFData->asdwDBIndx[FC_IN][i];
      sdwBufSize     = lpxPFData->asdwDBIndx[BUFSIZE][i];
      wRowsToPrint   = lpxPFData->awRowsToPrint[i];
      bDropsPerPixel = (ByteType)lpxPFData->asdwDBIndx[DROPS_PER_PIXEL][i];

#if OPTION_DOTCOUNT_PER_SWATH
      lpxPFData->asdwSwathDotCount[i] = 0;
#endif

      /* sdwRowStart is the topmost row (raster line) in this color plane  */
      /* for this swath.  Topmost means the smallest raster line number or */
      /* the row closet to the top of the printed page.                    */
      if (bResolution == HIRES_INTERLACED||
         bResolution == SHIRES_INTERLACED)
      {
         sdwRowStart = (sdwRow - (SdwordType)(wNozzleCount*swVertRes) + 1);
         if (sdwRowStart < lpxPFData->asdwFirstRowOfSection[swOut][i])
         {
            sdwRowStart = lpxPFData->asdwFirstRowOfSection[swOut][i];
         }
         sdwRowStart   -= (SdwordType)(lpxPFData->asdwDBIndx[INIT_DELAY][i] *
                          swVertRes);
         sdwRowStart    = sdwRowStart % (SdwordType)lpxPFData->swMaxDelayBuf;
      }
      else
      {
         sdwRowStart    = (lpxPFData->sdwBottomNozzleRowNum - (wRowsToPrint  *
                          swVertRes) - (lpxPFData->asdwDBIndx[INIT_DELAY][i] *
                          swVertRes) + 1);
      }

      swJStart   = ((SwordType)wNozzleCount*swVertRes) -
                   (SwordType)wRowsToPrint;
      swJEnd     = (SwordType)wNozzleCount * swVertRes;

      for (j=swJStart, r=sdwRowStart; j < swJEnd; j++, r++)
      {  /* Once for each raster line in the color plane */
         if (sdwOutIndex == sdwInIndex)
         {
            break;
         }

         swNozzle = j/swVertRes;
         fShingled = TRUE;
         swScanIndex = (SwordType)(r%lpxPFData->swMaxDelayBuf);

         if (((swOut == FC_OUT_EVEN) && (sdwOutIndex % 2))   ||
             ((swOut == FC_OUT_ODD) && (!(sdwOutIndex % 2))) ||
             (sdwOutIndex < 0)                              ||
             ((swSwathScanEnd - swSwathScanStart) <= 0 )    ||
             (lpxPFData->alpbShingleToApply[i][swScanIndex] == SHINGLE_THRU) )
         {
            if (bResolution == HIRES_INTERLACED ||
               bResolution == SHIRES_INTERLACED )
            {
               sdwOutIndex = (SdwordType)((sdwOutIndex + 1) %
                             lpxPFData->asdwDBIndx[BUFSIZE][i]);
            }
            else
            {
               sdwOutIndex++;
            }
            continue;
         }

#if OPTION_CDE
         wCDEBoundary = FALSE;
#endif

         wShingle = GetRasterLineShingleMask(lpxDataRec,i,swScanIndex,wStartSlice);

         if (wShingle == 0xFFFF )
         {  /* not shingled */
            fShingled = FALSE;
         }
         else
         {  /* shingled */
            fShingled = TRUE;
         }

#if OPTION_MULTIBITS_PER_PIXEL
         if (bDropsPerPixel == 2)
         {  /* Set the shingle level for the second CMY plane */

            wShingle2 = GetRasterLineShingleMask2(lpxDataRec, i, swScanIndex);

            if (wShingle2 == 0xFFFF )
            {  /* not shingled */
               fShingled2 = FALSE;
            }
            else
            {  /* shingled */
               fShingled2 = TRUE;
            }

         }
#endif
         wPrintMaskWord = lpxPFData->lpwPrtMask[(swNozzle % 16)];

         if (swBuffers == KPLANE &&
             bColorPlanes == 1 &&
             (!((bResolution == HIRES_INTERLACED)||
                (bResolution == SHIRES_INTERLACED)||
                (bResolution == HIRES_NONINTERLACED)) ))
         {
            wSliceWord     = ((WordType)swNozzle / (SwordType)16)*(SwordType)2;
            wPrintMaskWord  = lpxPFData->lpwPrtMask[(swNozzle % 16)];
         }
         else if (swBuffers == KPLANE)
         {
            wSliceWord  = (WordType)swNozzle / (SwordType)16;
         }
         else
         {
            wSliceWord     = SliceWord(i, wIStart, wIEnd, swNozzle);
         }

         /* For Babbage, no ColorOffset */
         dwColorOffset=0;

         swNozzleOffset = NozzleOffset(swVertAdj, swNozzle, swNozzleGap,
                                       bBytesPerSlice, swSwathRes);

         if (swBuffers == KCMPLANES)
         {
            swKCMOffset = KCMOffset(swNozzle, swSwathRes);
         }
         else
         {
            swKCMOffset = 0;
         }

         /* this code section gets a pointer to the raster line color      */
         /* plane we are currently working on.                             */
         if (bResolution == HIRES_INTERLACED ||
            bResolution == SHIRES_INTERLACED)
         {
            wSeg  = i + (WordType)(sdwOutIndex / lpxPFData->wRastersPerSeg *
                     bColorPlanes) + (WordType)((lpxPFData->asdwDBIndx[
                     DROPS_PER_PIXEL][i]-1) * DROP_SEC_SIZE);
            wIndx = (WordType)(sdwOutIndex % lpxPFData->wRastersPerSeg);
         }
         else
         {
            wSeg  = i + ( (WordType)(sdwOutIndex % lpxPFData->asdwDBIndx[
                     BUFSIZE][i]) / lpxPFData->wRastersPerSeg *
                     (WordType)bColorPlanes);
            wIndx = ( (WordType)(sdwOutIndex % lpxPFData->asdwDBIndx[
                     BUFSIZE][i]) % lpxPFData->wRastersPerSeg);
         }

         lpwRaster = lpxPFData->alpwPlane[wSeg] + (wIndx *
                     lpxPFData->wWordsPerRow);
         /* end of code section to get pointer to raster line color plane  */

#if OPTION_MULTIBITS_PER_PIXEL
         if (bDropsPerPixel == 2)
         {  /* get pointer to second plane of this color's data   */
            wSeg      = i + ( (WordType)(sdwOutIndex % lpxPFData->asdwDBIndx[
                         BUFSIZE][i]) / lpxPFData->wRastersPerSeg *
                         (WordType)bColorPlanes) + (WordType)DROP_SEC_SIZE;
            wIndx     = ( (WordType)(sdwOutIndex % lpxPFData->asdwDBIndx[
                         BUFSIZE][i]) % lpxPFData->wRastersPerSeg);
            lpwRaster2 = lpxPFData->alpwPlane[wSeg] + (wIndx *
                         lpxPFData->wWordsPerRow);
         }  /* end of getting pointer to second plane of this color's data   */
#endif

         wKKInc = (WordType)bBytesPerSlice * (WordType)8;

#if OPTION_600_AS_2X300
         /* wKKInc traditionally brings the pointer to the swathword location which has    */
         /* an offset of 16X24 from the previous swathword location after a rasterword is  */
         /* completely processed. However, in the new 600 the offset is 8X24.              */
         /* Thus,synchronize the rest of pointer movements as well.                        */
         if (lpxPFData->bShingleLoRes == SHINGLE_50)
         {
            wKKInc /= 2;
         }
#endif

         if ( lpxPFData->bShingleHiRes == SHINGLE_50 )
         {  /* Change swath offset pointer from 1200dpi to 600dpi */
            if(bResolution == SHIRES_INTERLACED)
            {
               wKKInc /= 4;
            }
            else
            {
               wKKInc /= 2;
            }
         }

         kk = 0;
         for (k = wSwathScanStart; k < wSwathScanEnd; k++)
         {  /* Once for each word in the raster line */
            wRasterWord  = *(lpwRaster + k);

            if (fShingled == TRUE)
            {  /* apply the raster line shingle mask to this word */
               wRasterWord &= wShingle;
            }

#if OPTION_MULTIBITS_PER_PIXEL
            if (bDropsPerPixel == 2)
            {
               wRasterWord2 = *(lpwRaster2 + k);
               if (wRasterWord2)
               {
                  if (fShingled2 == TRUE )
                  {
                     wRasterWord |= (wRasterWord2 & wShingle2);
                  }
                  else
                  {  /* Use 100% shingle mode for second plane */
                     wRasterWord |= wRasterWord2;
                  }
               }
            }
#endif

            if (wRasterWord)
            {  /* there is print data in this word */
               if (swBuffers == KPLANE &&
                   bColorPlanes == 1 &&
                   (!((bResolution == HIRES_INTERLACED) ||
                      (bResolution == SHIRES_INTERLACED) ||
                      (bResolution == HIRES_NONINTERLACED))))
               {
                  dwSwathWordOffset = (DwordType)(kk + dwColorOffset +
                                       swNozzleOffset + swKCMOffset);

                  dwSwathByteOffset = (DwordType)dwSwathWordOffset * 2 +
                                      wSliceWord;
               }
               else
               {
                    dwSwathWordOffset = (DwordType)(kk + wSliceWord +
                                         dwColorOffset + swNozzleOffset +
                                         swKCMOffset);
                    dwSwathByteOffset = (DwordType)dwSwathWordOffset * 2;
               }
               wSwathSeg = (WordType)((DwordType)dwSwathByteOffset /
                           ((DwordType)SLICES_PER_SEG *
                           (DwordType)bBytesPerSlice));

               dwSwathOffset = (DwordType)((DwordType)dwSwathByteOffset %
                              ((DwordType)SLICES_PER_SEG *
                              (DwordType)bBytesPerSlice));

               pbPrtDat       = (LPByteType)lpxPFData->alpbSwath[wSwathSeg];
               pbPrtDat      += dwSwathOffset;

               lpwSwathWord   = (LPWordType) pbPrtDat;
               lpwRMEnd       = lpwRastMask + 16;
               wSWInc         = bBytesPerSlice;


#if OPTION_CDE
               if (wCDEBoundary)
               {  /* last bit of prior word was rotated, start with 2nd bit */
                  lpwRMStart = lpwRastMask + 1;
                  lpwSwathWord = (LPWordType)
                                 ((LPByteType)lpwSwathWord + wSWInc);
               }
               else
               {
                  lpwRMStart = lpwRastMask + wStartSlice;
               }
#else
               /* wStartSlice added to support printing 1200dpi as 2 pass 600dpi */
               lpwRMStart = lpwRastMask + wStartSlice;
#endif

               /* wBitsToProcess added to support printing 1200dpi as 2 pass 600dpi */
               for (lpwRM = lpwRMStart; lpwRM < lpwRMEnd; lpwRM += wBitsToProcess)
               {  /* Once for each bit in the word */
                  if (wRasterWord & *lpwRM)
                  {  /* bit to be rotated */
                     *(lpwSwathWord) |= wPrintMaskWord; /* adding a mask bit to swathword */
                     asdwDotCount[i]++;
#if OPTION_CDE
                     if (fCDE)
                     {
                        lpwSwathWord = (LPWordType)
                                       ((LPByteType)lpwSwathWord + wSWInc);

                        /* set boundary switch if last bit rotated */
                        wCDEBoundary = (*lpwRM & lpxPFData->lpwRastMask[15]);
                        lpwRM++; /* increment past next bit */
                     }
#endif
                  }
                  lpwSwathWord = (LPWordType)       /* picking up the next swathword */
                              ((LPByteType)lpwSwathWord + wSWInc);
               }  /* Once for each bit in the word */
            }  /* end of data in this word */
            kk += wKKInc;
         }  /* Once for each word in the raster line */

         if (bResolution == HIRES_INTERLACED ||
            bResolution == SHIRES_INTERLACED)
         {
            sdwOutIndex = ((sdwOutIndex + 1) % lpxPFData->asdwDBIndx[BUFSIZE][i]);
         }
         else
         {
            sdwOutIndex++;
         }

      }  /* Once for each raster line in the color plane */
   }  /* Once for each plane of color */

   for (i=wIStart; i<wIEnd; i++)
   {
      /* check to see if any dots were added to print swath */
      if (asdwDotCount[i] != 0)
      {
         fEmptySwath = FALSE;
         lpxPFData->asdwDotCount[i] += asdwDotCount[i];
#if OPTION_DOTCOUNT_PER_SWATH
         lpxPFData->asdwSwathDotCount[i] = asdwDotCount[i];
#endif
         sdwSwathDotCount += asdwDotCount[i];
      }

   }

#if OPTION_600_AS_2X300
   /* wCMYSwathByPgCtr and wKOrKcmSwathByPgCtr are # of swaths in a page  */
   if (lpxPFData->bShingleLoRes == SHINGLE_50)
   {
      if ( lpxPFData->fCMYSwathBuild )
      {
         lpxPFData->wCMYSwathByPgCtr++;
      }
      else
      {
         lpxPFData->wKOrKcmSwathByPgCtr++;
      }
   }
#endif

   lpxPFData->wSliceCount = wSliceCount; /* restore global */

   lpxPFData->sdwSwathDotCount = sdwSwathDotCount;

#if CPROF
      PrfExit(7);
#endif


   if (fEmptySwath || ((swSwathScanEnd - swSwathScanStart) <= 0 ))
   {
      /* Added the following to handle printing in opposite direction  */
      /* of last swath for either the CMY or Black head.               */
      /* Need to do this even for blank swaths to keep in sync.        */
      if (lpxPFData->bPrintCMYOpposite )
      {  /* update the bidi print direction even for empty swath */
         if (lpxPFData->bNextCMYPrintDir == LTOR)
         {
             lpxPFData->bNextCMYPrintDir = RTOL;
         }
         else
         {
            lpxPFData->bNextCMYPrintDir = LTOR;
         }
      }
      /* See if we need to print BLK in opposite direction of last BLK */
      else if (lpxPFData->bPrintBLKOpposite)
      {
         if (lpxPFData->bNextBLKPrintDir == LTOR)
         {
             lpxPFData->bNextBLKPrintDir = RTOL;
         }
         else
         {
            lpxPFData->bNextBLKPrintDir = LTOR;
         }
      }
      return(0); /* empty swath */
   }

   return(1);

}  /* end of Rotate() */


/***************************************************************************
 * Function Name:    SwathMargins
 *
 * Description:
 *    Determines the narrowest margins possible for the current print
 *    swath.  Considers the left and right margins for each raster line
 *    that will be used to help create the current print swath.
 *
 * Inputs:  lpxDataRec     Far pointer to HBP interface structure.
 *          sdwRow         helps synchronize the delay buffers with the
 *                         margins buffer.
 *
 * Outputs: stores swath left margin in lpxPFData->swPreRotateStart.  Stores
 *          swath right margin in lpxPFData->swPreRotateEnd.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/


void SwathMargins(LPDVDATAREC lpxDataRec, SwordType swBuffers,
                  SdwordType sdwRow)
{
   LPPFDATA       lpxPFData;
   WordType       i,
                  wIEnd,
                  wIStart,
                  wNozzleCount,
                  wRowsToPrint,
                  wVertRes;
   SwordType      swOut,
                  swScanIndex,
                  swSwathScanEnd,
                  swSwathScanStart;
   SdwordType     j, k,
                  sdwBufStart,
                  sdwKEnd,
                  sdwRowStart;

#if CPROF
PrfEnter(6);
#endif

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   lpxPFData->swPreRotateStart = lpxPFData->wBytesPerRow-(SwordType)1;
   lpxPFData->swPreRotateEnd = 0;
   swSwathScanStart=lpxPFData->wBytesPerRow;
   swSwathScanEnd=0;

   switch (swBuffers)
   {
   case CMYPLANES :
      wIStart = 0;
      wIEnd   = 3;
      lpxPFData->bPreRotatePrintHead = COL_CARTRIDGE;
      break;
   case KCMPLANES :
      wIStart = 3;
      wIEnd   = 6;
      lpxPFData->bPreRotatePrintHead = MONO_CARTRIDGE;
      break;
   case KPLANE:
      if (lpxPFData->bColorPlanes == 4)
      {
         /* CMYK print job */
         wIStart = 3;
         wIEnd   = 4;
      }
      else
      {
         /* K print job */
         wIStart = 0;
         wIEnd   = 1;
      }
      lpxPFData->bPreRotatePrintHead = MONO_CARTRIDGE;
      break;
   default :
#if CPROF
   PrfExit(6);
#endif
      return;
   }

   /* This line is used for host logic seek printers */
   lpxPFData->bPreRotateDir = GetPrintDir(lpxDataRec, swBuffers);

   wVertRes = (WordType)lpxPFData->swVertResMult;
   swOut    = lpxPFData->swOut;

   /* For the raster lines involved in this print swath, determine the     */
   /* smallest left margin (ScanStart) and the largest right margin        */
   /* (ScanEnd).  These will determine the size and horizontal position    */
   /* of the print swath created.                                          */
   for (i=wIStart; i<wIEnd; i++)
   {
      wNozzleCount = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[i];
      wRowsToPrint = lpxPFData->awRowsToPrint[i];

      if (lpxPFData->bResolution == HIRES_INTERLACED ||
         lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         sdwRowStart = (sdwRow - (SdwordType)(wNozzleCount*wVertRes) + 1);
         if (sdwRowStart < lpxPFData->asdwFirstRowOfSection[swOut][i])
         {
            sdwRowStart = lpxPFData->asdwFirstRowOfSection[swOut][i];
         }
         sdwRowStart   -= (SdwordType)
                          (lpxPFData->asdwDBIndx[INIT_DELAY][i]*wVertRes);
      }
      else
      {
         sdwRowStart = (lpxPFData->sdwBottomNozzleRowNum -
                       (wRowsToPrint * wVertRes)       -
                       (lpxPFData->asdwDBIndx[INIT_DELAY][i]*wVertRes) + 1);
      }

      if ( (sdwRowStart > lpxPFData->sdwRowPos) ||
           (lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i]) )
      {
         continue;
      }

      if (lpxPFData->bResolution == HIRES_INTERLACED ||
         lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         sdwRowStart = sdwRowStart % (SdwordType)lpxPFData->swMaxDelayBuf;
         sdwKEnd = sdwRowStart+(SdwordType)(wNozzleCount*wVertRes);
      }
      else
      {
         sdwKEnd = sdwRowStart + wRowsToPrint;
      }
      sdwBufStart = lpxPFData->asdwDBIndx[swOut][i];

      for (k=sdwRowStart, j=sdwBufStart; k<sdwKEnd; k++, j++)
      {
         if (k > lpxPFData->sdwRowPos)
         {
            break;
         }
      if ( (lpxPFData->bResolution == HIRES_INTERLACED ||
            lpxPFData->bResolution == SHIRES_INTERLACED) &&
           ((j % lpxPFData->asdwDBIndx[BUFSIZE][i]) == 
            lpxPFData->asdwDBIndx[FC_IN][i]) )
         {
            break;
         }
         if ( (j<0) || (k < 0))
         {
            continue;
         }
         if ((swOut == FC_OUT_EVEN) && (j%2))
         {
            continue;
         }
         if ((swOut == FC_OUT_ODD) && (!(j%2)))
         {
            continue;
         }

         swScanIndex = (SwordType)(k%lpxPFData->swMaxDelayBuf);

         if (lpxPFData->alpswScanStart[i][swScanIndex] < swSwathScanStart)
         {
            swSwathScanStart = lpxPFData->alpswScanStart[i][swScanIndex];
         }
         if (lpxPFData->alpswScanEnd[i][swScanIndex] > swSwathScanEnd)
         {
            swSwathScanEnd = lpxPFData->alpswScanEnd[i][swScanIndex];
         }
      }  /* end of for (k=sdwRowStart, j=sdwBufStart; k<sdwKEnd; k++, j++) */
   }  /* end of for (i=wIStart; i<wIEnd; i++) */

   lpxPFData->swPreRotateStart = swSwathScanStart;
   lpxPFData->swPreRotateEnd   = swSwathScanEnd;

#if CPROF
   PrfExit(6);
#endif

   return;

}  /* end of SwathMargins() */




/***************************************************************************
 * Function Name:    PreSwathAdjust
 *
 * Description:
 *    Determines which color planes must be printed now.
 *
 * Inputs:  lpxDataRec     Far pointer to HBP interface structure.
 *          sdwRow         bottom raster line read in.
 *
 * Outputs: returns vertical move amount, in raster lines, required before
 *          printing this swath.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/
SwordType PreSwathAdjust(LPDVDATAREC lpxDataRec, SdwordType sdwRow)
{
   LPPFDATA       lpxPFData;
   WordType       awNozzleStart[MAXNUMPLANES],
                  awVerticalMove[MAXNUMPLANES],
                  wBaseNozzleCount,
                  wMoveAmount,
                  wNozzle,
                  wNozzleCount,
                  wNozzleStart=0,
                  wVerticalMove;
   SwordType      i,
                  swOut,
                  swScanIndex,
                  swShingleThreshold,
                  swVertRes;
   SdwordType     k,
                  sdwBottomRow,
                  sdwOldBottomRow,
                  sdwTopRow;
   ByteType       bSI=0;
   BoolType       fMustPrintColor[6] = {FALSE,FALSE,FALSE,FALSE,FALSE,FALSE},
                  fMustPrintHead[2]  = {FALSE,FALSE},
                  fNoLinesToProcess=TRUE,
                  fRowsToPrint = FALSE;

#if CPROF
   PrfEnter(5);
#endif

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;


   swVertRes     = lpxPFData->swVertResMult;
   swOut         = lpxPFData->swOut;
   wMoveAmount   = lpxPFData->wBaseNozzleCount;
   wVerticalMove = lpxPFData->wBaseNozzleCount;

   /* The following for() loop determines the number of nozzles to use in  */
   /* this swath (or these swaths).  In other words, determine             */
   /* wNozzleStart for the entire swath(s) by looking at wNozzleStart for  */
   /* each color plane.  Notice that as we go from one color plane to the  */
   /* next, wNozzleStart can become larger (meaning the swath will use     */
   /* fewer nozzles), but it will not get smaller because the previous     */
   /* color planes have already established a maximum nozzle               */
   for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++)
   {

      wBaseNozzleCount = lpxPFData->wBaseNozzleCount;
      wNozzleCount     = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[i];
      bSI              = lpxPFData->abShingleIndex[i];

      /* Assuming a full vertical movement before printing this swath,     */
      /* sdwBottomRow is the row number of the row which will be printed   */
      /* by the bottom nozzle of this color plane.   The full vertical     */
      /* movement comes by using sdwRow as the basis for calculating       */
      /* sdwBottomRow.                                                     */
      sdwBottomRow = (sdwRow - (lpxPFData->asdwDBIndx[INIT_DELAY][i]*swVertRes));

      if ( (lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i]) ||
           (sdwBottomRow < lpxPFData->asdwDBIndx[swOut][i]) )
      {
         /* if the bottom nozzle is still off the printable area,          */
         /* sdwBottomRow < lpxPFData->asdwDBIndx[sswOut][i],                 */
         /* then the entire color nozzles are off the page.  So as far     */
         /* as this color plane is concerned, it can "use" all of its      */
         /* nozzles, or in other words, it can be moved a full vertical    */
         /* amount.                                                        */
         awNozzleStart[i] = 0;
         awVerticalMove[i] = wNozzleCount;
         if (awVerticalMove[i] < wVerticalMove)
         {
            wVerticalMove = awVerticalMove[i];
         }
         continue;
      }

      /* Assuming a full vertical movement before printing this swath,     */
      /* sdwTopRow is the row number of the row which will be printed by   */
      /* the top nozzle (nozzle 0) of this color plane.                    */
      sdwTopRow = sdwBottomRow - (SdwordType) wNozzleCount + 1;

      k = sdwBottomRow;
      wNozzle = wNozzleCount;

      /* Important to note that this while() loop processes from the       */
      /* bottom of the print nozzles to the top.  I am doing this          */
      /* because all color banks don't have the same number of nozzles.    */
      while (k >= sdwTopRow)
      {

         if (k < lpxPFData->asdwDBIndx[swOut][i])
         {
            break;
         }

         wNozzle--;

         swScanIndex = (SwordType)(k%lpxPFData->swMaxDelayBuf);

         if (lpxPFData->alpbShingleToApply[i][swScanIndex] != SHINGLE_THRU)
         {
            swShingleThreshold = (SwordType) lpxPFData->awShingleThreshold[bSI][
                                 (lpxPFData->alpbShingleToApply[i][swScanIndex])];

            /* This is a critical decision.  If this if() statement is     */
            /* true then that means that this color plane has to be        */
            /* printed at this time.                                       */
            if ( ((SwordType)wNozzle) <= (swShingleThreshold))
            {
               /* We won't make a full vertical movement, so adjust the    */
               /* sdwBottomRow value we calculated above accordingly.      */
               sdwBottomRow        -= (swShingleThreshold - wNozzle);
               wNozzle              = swShingleThreshold;
               fMustPrintColor[i]   = TRUE;
            }
            else if (((SwordType)wNozzle) <=
                     (swShingleThreshold + MINIMUM_VERTICAL_MOVE))
            {
               fMustPrintColor[i] = TRUE;
            }
            else if ((i==3)&&((SwordType)wNozzle <= 34)
                     &&(lpxPFData->bResolution==SUPERLOWRES))
                                {
                                        fMustPrintColor[3] = TRUE;
                                }
         }
         k--;
      }  /* end of while (k >= sdwTopRow) */

      awNozzleStart[i]  = wNozzle;
      sdwOldBottomRow   = lpxPFData->sdwBottomNozzleRowNum -
                          lpxPFData->asdwDBIndx[INIT_DELAY][i];
      awVerticalMove[i] = (WordType)(sdwBottomRow - sdwOldBottomRow);

      if (awVerticalMove[i] < wVerticalMove)
      {
         wVerticalMove = awVerticalMove[i];
      }
   }  /* end of for (i=lpxPFData->swDelayBufStart...) */


   /* Update bottom nozzle row number based on the vertical movement    */
   /* that will occur before this swath (swaths) print.                 */
   lpxPFData->sdwBottomNozzleRowNum += (SdwordType)wVerticalMove;

   for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++)
   {
      if ((fMustPrintColor[i]) && (awVerticalMove[i] == wVerticalMove))
      {
         fMustPrintHead[(i/3)] = TRUE;
      }
      else if ( (fMustPrintColor[i]) &&
                (awVerticalMove[i] >= (wVerticalMove - MINIMUM_VERTICAL_MOVE)) )
      {
         fMustPrintHead[(i/3)] = TRUE;
      }
   }

   /* Now assign nozzle positions to the raster lines that will make up    */
   /* this swath.  This is used to determine what shingle mask pattern to  */
   /* apply                                                                */
   for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++)
   {
      wNozzle      = awNozzleStart[i] + (awVerticalMove[i]-wVerticalMove);
      wNozzleCount = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[i];
      sdwBottomRow = lpxPFData->sdwBottomNozzleRowNum -
                     (lpxPFData->asdwDBIndx[INIT_DELAY][i]*swVertRes);

      if (fMustPrintHead[(i/3)])
      {
         if ((lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i]) ||
              (sdwBottomRow < lpxPFData->asdwDBIndx[swOut][i]) )
         {
            lpxPFData->awRowsToPrint[i] = 0;
            continue;
         }
         else
         {
            lpxPFData->awRowsToPrint[i] = wNozzleCount - wNozzle;
         }
      }
      else
      {
         lpxPFData->awRowsToPrint[i]    = 0;
         continue;
      }

      sdwTopRow = sdwBottomRow - lpxPFData->awRowsToPrint[i] + 1;
      k         = sdwTopRow;

      while (k <= sdwBottomRow)
      {
         if (k == lpxPFData->asdwDBIndx[FC_IN][i])
         {
            break;
         }
         swScanIndex = (SwordType)(k%lpxPFData->swMaxDelayBuf);

         switch(lpxPFData->alpbShingleToApply[i][swScanIndex])
         {
         case SHINGLE_0_1 :
         case SHINGLE_50_1 :
         case SHINGLE_25_1 :
         case SHINGLE_33_1 :
         case SHINGLE_16_1 :
         case SHINGLE_12_1 :
            lpxPFData->alpwShingleLine[i][swScanIndex] = wNozzle;
            break;
         }

         wNozzle++;
         k++;
      }  /* end of while (k <= sdwBottomRow) */
   }  /* end of for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++) */

   lpxPFData->wRowsToMove = wVerticalMove;

#if CPROF
   PrfExit(5);
#endif
   return((SwordType)wVerticalMove);
}  /* end of PreSwathAdjust() */




/***************************************************************************
 * Function Name:    PostSwathAdjust
 *
 * Description:
 *    Updates delay buffer out pointers, based on which raster lines are now
 *    completely printed.
 *
 * Inputs:  lpxDataRec     Far pointer to HBP interface structure.
 *          sdwRow         last raster line read in.
 *
 * Outputs: returns the number of raster lines to read to fill delay
 *          buffers
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/
SwordType PostSwathAdjust(LPDVDATAREC lpxDataRec, SdwordType sdwRow)
{
   LPPFDATA       lpxPFData;
   WordType       wMinRowsToRead,
                  wNozzleCount,
                  wRowsToRead;
   SwordType      i,
                  swOut,
                  swScanIndex,
                  swVertRes;
   SdwordType     k,
                  sdwRowEnd,
                  sdwRowStart;
   BoolType       fKeepRow;

#if CPROF
   PrfEnter(8);
#endif

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   swVertRes      = lpxPFData->swVertResMult;
   swOut          = lpxPFData->swOut;
   wMinRowsToRead = lpxPFData->wBaseNozzleCount;


   for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++)
   {
      fKeepRow = FALSE;

      if (lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i])
      {
         continue;
      }


      sdwRowStart = lpxPFData->asdwDBIndx[swOut][i];
      sdwRowEnd   = sdwRowStart + lpxPFData->awRowsToPrint[i];

      k = sdwRowStart;

      while (k < sdwRowEnd)
      {
         if (k == lpxPFData->asdwDBIndx[FC_IN][i])
         {
            break;
         }

         swScanIndex = (SwordType)(k%lpxPFData->swMaxDelayBuf);

         switch(lpxPFData->alpbShingleToApply[i][swScanIndex])
         {
         case SHINGLE_THRU    :
            if (fKeepRow == FALSE)
            {
               lpxPFData->asdwDBIndx[swOut][i]++;
            }
            break;
         case SHINGLE_0_1  :
         case SHINGLE_50_2 :
         case SHINGLE_25_4 :
         case SHINGLE_33_3 :
         case SHINGLE_16_6 :
         case SHINGLE_12_8 :
            lpxPFData->alpbShingleToApply[i][swScanIndex] = SHINGLE_THRU;
            if (fKeepRow == FALSE)
            {
               lpxPFData->asdwDBIndx[swOut][i]++;
            }
            break;
         default :
            lpxPFData->alpbShingleToApply[i][swScanIndex]++;
            fKeepRow = TRUE;
            break;
         }
         k++;
      }  /* end of while (k < sdwKEnd) */

      wNozzleCount = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[i];

      if (lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i])
      {
         wRowsToRead = wNozzleCount;
      }
      else
      {
         wRowsToRead = (wNozzleCount +
                       (WordType)lpxPFData->asdwDBIndx[INIT_DELAY][i]) -
                       (WordType)(sdwRow - lpxPFData->asdwDBIndx[swOut][i] + 1L);
      }

      if (wRowsToRead < wMinRowsToRead)
      {
         wMinRowsToRead = wRowsToRead;
      }
   }   /* end of for (i=lpxPFData->swDelayBufStart...) */


#if CPROF
   PrfExit(8);
#endif
   return((SwordType)wMinRowsToRead);
}  /* end of PostSwathAdjust() */




/***************************************************************************
 * Function Name:    HiResPreSwathAdjust
 *
 * Description:
 *    We have not yet merged independent shingling with high resolution
 *    alternating raster line printing.  So this function is used when
 *    in high resolution printing mode.
 *
 * Inputs:  lpxDataRec     Far pointer to HBP interface structure.
 *          sdwRow         bottom raster line read in.
 *
 * Outputs: returns vertical move amount, in raster lines, required before
 *          printing this swath.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/
SwordType HiResPreSwathAdjust(LPDVDATAREC lpxDataRec, SdwordType sdwRow)
{
   LPPFDATA       
      lpxPFData;
   WordType
      wNozzle,
      wNozzleCount,
      wNozzleStart=0,
      wRowsToMove,
      wStepDiff;
   SwordType
      i,
      swOut,
      swScanIndex,
      swVertRes;
   SdwordType
      j, k,
      sdwBufStart,
      sdwRowStart;

   ByteType       
      bSI;

#if CPROF
   PrfEnter(5);
#endif
   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   swVertRes = lpxPFData->swVertResMult;
   swOut     = lpxPFData->swOut;

   if(lpxPFData->bShingle != SHINGLE_12)
   {
      wStepDiff=3;
   }
   else
   {
      wStepDiff=1;
   }

   for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++)
   {
      wNozzle      = 0;
      wNozzleCount = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[i];
      bSI          = lpxPFData->abShingleIndex[i];


      sdwRowStart = (sdwRow - (SdwordType)(lpxPFData->asdwDBIndx[INIT_DELAY][i] *
                    swVertRes) - (SdwordType)(wNozzleCount*swVertRes) + 1);
      if (sdwRowStart > lpxPFData->sdwRowPos)
      {
         continue;
      }
      sdwRowStart = sdwRowStart % (SdwordType)lpxPFData->swMaxDelayBuf;
      sdwBufStart = lpxPFData->asdwDBIndx[swOut][i];

      for (j=sdwBufStart,k=sdwRowStart; k<sdwRowStart+(wNozzleCount*swVertRes);
           j++,k++)
      {

         swScanIndex = (SwordType)(k%lpxPFData->swMaxDelayBuf);

         if ( (wNozzle >= wNozzleCount) ||
              ((j % lpxPFData->asdwDBIndx[BUFSIZE][i]) == 
               lpxPFData->asdwDBIndx[FC_IN][i]) || 
              (k > lpxPFData->sdwRowPos) )
         {
            break;
         }
         if ( ((swOut == FC_OUT_EVEN) && (j%2)) ||
              ((swOut == FC_OUT_ODD) && (!(j%2))) )
         {
            continue;
         }
         if ( (j < 0) || (k < 0) ||
              (lpxPFData->alpbShingleToApply[i][swScanIndex] == SHINGLE_THRU) )
         {
            wNozzle++;
            continue;
         }

         switch(lpxPFData->alpbShingleToApply[i][swScanIndex])
         {
         case SHINGLE_0_1 :
         case SHINGLE_50_1 :
         case SHINGLE_25_1 :
         case SHINGLE_33_1 :
         case SHINGLE_16_1 :
         case SHINGLE_12_1 :
            lpxPFData->alpwShingleLine[i][swScanIndex] = wNozzle;
            break;
         }

         wNozzle++;
      }
      lpxPFData->awRowsToPrint[i] = wNozzleCount*swVertRes;
   }

/* TEST / DEVELOPMENT */
/* FIX THIS FOR HIGH RES 8 PASS PRINTING */
        /* both color and black use 192 nozzles , but #black nozzles is three times of #color nozzles
        assuming both use 50% (4 passes)or 25% (8 passes) or 12% (16 passes), ie. even passes, to pass
        true 600 dpi data to printer    instead of 1200 dpi for black (33%)*/
#if OPTION_K_1200_AS_2x600
   if ((lpxPFData->bColorPlanes == 4) &&
       (lpxPFData->bShingle == SHINGLE_50 ||
       lpxPFData->bShingle == SHINGLE_25 ||
       lpxPFData->bShingle == SHINGLE_12))
   {
      lpxPFData->aswDelayKSwath[swOut] = (lpxPFData->aswDelayKSwath[swOut] +
                                         (SwordType)1) % (SwordType)3;
      if (lpxPFData->aswDelayKSwath[swOut] != 0)
      {
         lpxPFData->awRowsToPrint[3] = 0;
      }
   }
#else
   if (lpxPFData->bColorPlanes == 4)
   {
      if(lpxPFData->bShingle == SHINGLE_50)
      {
         lpxPFData->aswDelayKSwath[swOut] = (lpxPFData->aswDelayKSwath[swOut] +
                                         (SwordType)1) % (SwordType)2;
      }
      else if(lpxPFData->bShingle == SHINGLE_25 ||lpxPFData->bShingle == SHINGLE_12)
      {
         lpxPFData->aswDelayKSwath[swOut] = (lpxPFData->aswDelayKSwath[swOut] +
                                         (SwordType)1) % (SwordType)3;

      }

      if (lpxPFData->aswDelayKSwath[swOut] != 0)
      {
         lpxPFData->awRowsToPrint[3] = 0;
      }
   }
#endif


   if (lpxPFData->bShingle == NO_SHINGLE)
   {
      wRowsToMove = (WordType)lpxPFData->wBaseNozzleCount;
   }
   else if (lpxPFData->bShingle == SHINGLE_50)
   {
      wRowsToMove = (WordType)lpxPFData->wBaseNozzleCount / 2;
   }
   else if (lpxPFData->bShingle == SHINGLE_25)
   {
      wRowsToMove = (WordType)lpxPFData->wBaseNozzleCount / 4;
   }
   else
   {  /* 12 % shingling */
      wRowsToMove = (WordType)lpxPFData->wBaseNozzleCount / 8;
   }

   if (swOut == FC_OUT_EVEN)
   {
      wRowsToMove -= wStepDiff;
   }
   else if (swOut == FC_OUT_ODD)
   {
      wRowsToMove += wStepDiff;
   }

#if CPROF
   PrfExit(5);
#endif
   return((SwordType)wRowsToMove);
}  /* end of HiResPreSwathAdjust() */




/***************************************************************************
 * Function Name:    HiResPostSwathAdjust
 *
 * Description:
 *    We have not yet merged independent shingling with high resolution
 *    alternating raster line printing.  This is why we now have two sets
 *    of swath adjust functions.  For high resolution printing, this
 *    function updates delay buffer out pointers, based on which raster
 *    lines are now completely printed.
 *
 * Inputs:  lpxDataRec     Far pointer to HBP interface structure.
 *          sdwRow         last raster line read in.
 *
 * Outputs: returns the number of raster lines to read to fill delay
 *          buffers
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/
SwordType HiResPostSwathAdjust(LPDVDATAREC lpxDataRec, SdwordType sdwRow)
{
   LPPFDATA       lpxPFData;
   WordType       wNozzleCount,
                  wRowsToFree;
   SwordType      i,
                  swOut,
                  swScanIndex,
                  swVertRes;
   SdwordType     j, k,
                  sdwBufStart,
                  sdwRowStart;

#if CPROF
   PrfEnter(8);
#endif
   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   swVertRes = lpxPFData->swVertResMult;
   swOut     = lpxPFData->swOut;

   for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++)
   {
      wNozzleCount = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[i];


      sdwRowStart = (sdwRow - (SdwordType)(lpxPFData->asdwDBIndx[INIT_DELAY][i] *
                    swVertRes) - (SdwordType)(wNozzleCount*swVertRes) + 1);
      if (sdwRowStart > lpxPFData->sdwRowPos)
      {
         continue;
      }
      sdwRowStart = sdwRowStart % (SdwordType)lpxPFData->swMaxDelayBuf;
      sdwBufStart = (SwordType) lpxPFData->asdwDBIndx[swOut][i];

      for (j=sdwBufStart,k=sdwRowStart; k<sdwRowStart+lpxPFData->awRowsToPrint[i];
           j++,k++)
      {
         if ( ((swOut == FC_OUT_EVEN) && (j%2)) ||
              ((swOut == FC_OUT_ODD) && (!(j%2))) )
         {
            continue;
         }

         if (lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i])
         {
            break;
         }

         if ((j < 0) || (k < 0))
         {
            continue;
         }

         swScanIndex = (SwordType)(k%lpxPFData->swMaxDelayBuf);

         switch(lpxPFData->alpbShingleToApply[i][swScanIndex])
         {
         case SHINGLE_THRU    :
            break;
         case SHINGLE_0_1  :
         case SHINGLE_50_2 :
         case SHINGLE_25_4 :
         case SHINGLE_33_3 :
         case SHINGLE_16_6 :
         case SHINGLE_12_8 :
            lpxPFData->alpbShingleToApply[i][swScanIndex] = SHINGLE_THRU;
            break;
         default :
            lpxPFData->alpbShingleToApply[i][swScanIndex]++;
            break;
         }
      }  /* end of for (j=sdwBufStart,k=sdwRowStart...) */

#if OPTION_K_1200_AS_2x600                
      if ((lpxPFData->bColorPlanes == 4) && (i==3) &&
          (lpxPFData->bShingle == SHINGLE_33)) 
#else
      if ((lpxPFData->bColorPlanes == 4) && (i==3)
          &&(lpxPFData->bResolution == HIRES_INTERLACED||
             (lpxPFData->bResolution == SHIRES_INTERLACED
              &&lpxPFData->bShingle == SHINGLE_33)))
#endif
      {
         wRowsToFree = wNozzleCount / 3;
      }
      else if (lpxPFData->bShingle == NO_SHINGLE)
      {
         wRowsToFree = wNozzleCount;
      }
      else if (lpxPFData->bShingle == SHINGLE_50)
      {
         wRowsToFree = wNozzleCount / 2;
      }
      else if (lpxPFData->bShingle == SHINGLE_25)
      {
         wRowsToFree = wNozzleCount / 4;
      }
      else
      {  /* 12% shingling */
         wRowsToFree = wNozzleCount / 8;
      }


      if ((lpxPFData->bColorPlanes == 4) && (i == 3) &&
          (lpxPFData->aswDelayKSwath[swOut] != 0) &&
          ((lpxPFData->bShingle == SHINGLE_50) ||
           (lpxPFData->bShingle == SHINGLE_25) ||
           (lpxPFData->bShingle == SHINGLE_12))  )
      {
         wRowsToFree = 0;
      }


      for (k=0; k<(SwordType)(wRowsToFree*swVertRes); k++)
      {
         if ( lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i])
         {
            break;
         }
         lpxPFData->asdwDBIndx[swOut][i] = (lpxPFData->asdwDBIndx[swOut][i]+1) %
                                         lpxPFData->asdwDBIndx[BUFSIZE][i];

      }  /* end of for (k=0; k<(SwordType)(wRowsToFree*swVertRes); k++) */
   }

   if (lpxPFData->bShingle == NO_SHINGLE)
   {
      wRowsToFree = (WordType)lpxPFData->wBaseNozzleCount;
   }
   else if (lpxPFData->bShingle == SHINGLE_50)
   {
      wRowsToFree = (WordType)lpxPFData->wBaseNozzleCount / 2;
   }
   else if (lpxPFData->bShingle == SHINGLE_25)
   {
      wRowsToFree = (WordType)lpxPFData->wBaseNozzleCount / 4;
   }
   else
   {  /* 12% shingling */
      wRowsToFree = (WordType)lpxPFData->wBaseNozzleCount / 8;
   }
#if CPROF
   PrfExit(8);
#endif
   return ((SwordType)wRowsToFree);
}  /* end of HiResPostSwathAdjust() */


/***************************************************************************
 * Function Name:    GetHiResStartSlice
 *
 * Description:
 *    This function returns 0 or 1 for even or odd slice usage for building
 *    a 600 dpi swath from 1200 dpi even or odd numbered raster lines based
 *    on the printhead in use
 *
 * Inputs:  lpxPFData      Far pointer to HBP PFData structure.
 *          swOut          Even or odd rasters lines used to build swath
 *          swBuffers      Which printhead used, CMY, KCM or K.
 *
 * Outputs: Returns 0 to use even slices or 1 to use odd slices to build swath.
 *
 * Original Author: L. Cheatham
 * Date: 10/10/98
 *
 **************************************************************************/

WordType GetHiResStartSlice(LPPFDATA lpxPFData, SwordType swOut, SwordType swBuffers)
{
   WordType
      wStartSlice = 0,
      wBitsToProcess =2;

   if(lpxPFData->bResolution == SHIRES_INTERLACED)
   {
      wBitsToProcess=4;
   }
   else
   {
      wBitsToProcess=2;
   }

   switch (swBuffers)
   {
   case CMYPLANES :
      if (swOut == FC_OUT_EVEN)
      {
         wStartSlice = lpxPFData->wCMYEvenRasterSlice++;
         lpxPFData->wCMYEvenRasterSlice %= wBitsToProcess;  /* should always be = 0 or 1 */
      }
      else
      {
         wStartSlice = lpxPFData->wCMYOddRasterSlice++;
         lpxPFData->wCMYOddRasterSlice %= wBitsToProcess;  /* should always be = 0 or 1 */
      }

      break;

   case KCMPLANES :
      if (swOut == FC_OUT_EVEN)
      {
         wStartSlice = lpxPFData->wKCMEvenRasterSlice++;
         lpxPFData->wKCMEvenRasterSlice %= wBitsToProcess;  /* should always be = 0 or 1 */
      }
      else
      {
         wStartSlice = lpxPFData->wKCMOddRasterSlice++;
         lpxPFData->wKCMOddRasterSlice %= wBitsToProcess;  /* should always be = 0 or 1 */
      }
      break;

   case KPLANE:
      if (swOut == FC_OUT_EVEN)
      {
         wStartSlice = lpxPFData->wBLKEvenRasterSlice++;
         lpxPFData->wBLKEvenRasterSlice %= wBitsToProcess;  /* should always be = 0 or 1 */
      }
      else
      {
         wStartSlice = lpxPFData->wBLKOddRasterSlice++;
         lpxPFData->wBLKOddRasterSlice %= wBitsToProcess;  /* should always be = 0 or 1 */
      }
      break;
   }  /* end of switch(swBuffers) */

   return (wStartSlice);
}

/***************************************************************************
 * Function Name:    GetRasterLineShingleMask
 *
 * Description:
 *    This function returns the shingle mask to use for this raster line.
 *    This mask is used (Anded) with each word of the raster line to get
 *    the bits to rotate to the swath.  Returns hex FFFF when the raster
 *    line does not require a shingle mask.
 *
 * Inputs:  lpxPFData      Far pointer to HBP PFData structure.
 *          wPlane         Color plane number 0 to 6.
 *          swScanIndes    Raster line number.
 *
 * Outputs: Returns a 16 bit shingle mask for use with current raster line.
 *
 * Original Author: L. Cheatham
 * Date: 10/21/98
 *
 **************************************************************************/

WordType GetRasterLineShingleMask(LPDVDATAREC lpxDataRec, WordType wPlane,
                                  SwordType swScanIndex, WordType wStartSlice )
{
   WordType  wShingle;
   ByteType  bDropsPerPixel;
   LPPFDATA lpxPFData;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;
   bDropsPerPixel = (ByteType)lpxPFData->asdwDBIndx[DROPS_PER_PIXEL][wPlane];

#if OPTION_600_AS_2X300
   if (lpxPFData->bShingleLoRes == SHINGLE_50)
   {
      /*  no shingle-masking is required  */
      return( 0xFFFF );
   }
#endif

   switch(lpxPFData->alpbShingleToApply[wPlane][swScanIndex])
   {
   case SHINGLE_0_1 :
   default :
      wShingle = 0xFFFF;            /* not shingled */
      break;
   case SHINGLE_50_1 :
      if (lpxPFData->bResolution == HIRES_INTERLACED &&
          lpxPFData->bShingleHiRes == SHINGLE_50 )
      {  /* For 1200 dpi even or odd bits will be used by rotate loop */
         wShingle = 0xFFFF;            /* not shingled */
      }
      else
      {
         /* use alternating shingle mask based on raster line number */
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_50][
                    (lpxPFData->alpwShingleLine[wPlane][swScanIndex])%2];
      }
      break;
   case SHINGLE_50_2 :
      if (lpxPFData->bResolution == HIRES_INTERLACED &&
          lpxPFData->bShingleHiRes == SHINGLE_50 )
      {  /* For 1200 dpi even or odd bits will be used by rotate loop */
         wShingle = 0xFFFF;            /* not shingled */
      }
      else
      {
         /* use same shingle mask for all colors for this raster */
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_50][
                    ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+1)%2];
      }
      break;
   case SHINGLE_25_1 :
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) &&
           ( (lpxPFData->bColorPlanes == 3) || (lpxPFData->bColorPlanes == 4)) )
      {
         if (wStartSlice == 0)
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][0];
         }
         else
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][3];
         }
      }
      else if (lpxPFData->bResolution == SHIRES_INTERLACED)
      {
            wShingle = 0xFFFF;
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][
                    (lpxPFData->alpwShingleLine[wPlane][swScanIndex])%4];
      }
      break;
   case SHINGLE_25_2 :
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) &&
           ( (lpxPFData->bColorPlanes == 3) || (lpxPFData->bColorPlanes == 4)) )
      {
         if (wStartSlice == 0)
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][0];
         }
         else
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][3];
         }
      }
      else if (lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         wShingle = 0xFFFF;
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][
                    ((lpxPFData->alpwShingleLine[wPlane][swScanIndex]+1))%4];
      }
      break;
   case SHINGLE_25_3 :
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) &&
           ( (lpxPFData->bColorPlanes == 3) || (lpxPFData->bColorPlanes == 4)) )
      {
         if (wStartSlice == 0)
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][2];
         }
         else
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][1];
         }
      }
      else if (lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         wShingle = 0xFFFF;
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][
                    ((lpxPFData->alpwShingleLine[wPlane][swScanIndex]+2))%4];
      }
      break;
   case SHINGLE_25_4 :
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) &&
           ( (lpxPFData->bColorPlanes == 3) || (lpxPFData->bColorPlanes == 4)) )
      {
         if (wStartSlice == 0)
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][2];
         }
         else
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][1];
         }
      }
      else if (lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         wShingle = 0xFFFF;
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][
                    ((lpxPFData->alpwShingleLine[wPlane][swScanIndex]+3))%4];
      }
      break;
   case SHINGLE_33_1 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_33][
                 (lpxPFData->alpwShingleLine[wPlane][swScanIndex])%3];
      break;
   case SHINGLE_33_2 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_33][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+1)%3];
      break;
   case SHINGLE_33_3 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_33][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+2)%3];
      break;
   case SHINGLE_16_1 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_16][
                 (lpxPFData->alpwShingleLine[wPlane][swScanIndex])%6];
      break;
   case SHINGLE_16_2 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_16][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+1)%6];
      break;
   case SHINGLE_16_3 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_16][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+2)%6];
      break;
   case SHINGLE_16_4 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_16][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+3)%6];
      break;
   case SHINGLE_16_5 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_16][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+4)%6];
      break;
   case SHINGLE_16_6 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_16][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+5)%6];
      break;

   case SHINGLE_12_1 :
      if(lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         wShingle=0xF0F0;
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_12][
                    (lpxPFData->alpwShingleLine[wPlane][swScanIndex])%8];
      }
      break;
   case SHINGLE_12_2 :
      if(lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         wShingle=0xF0F0;
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_12][
                    (lpxPFData->alpwShingleLine[wPlane][swScanIndex]+1)%8];
      }
      break;
   case SHINGLE_12_3 :
      if(lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         wShingle=0xF0F0;
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_12][
                    (lpxPFData->alpwShingleLine[wPlane][swScanIndex]+2)%8];
      }
      break;
   case SHINGLE_12_4 :
      if(lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         wShingle=0xF0F0;
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_12][
                    (lpxPFData->alpwShingleLine[wPlane][swScanIndex]+3)%8];
      }
      break;
   case SHINGLE_12_5 :
      if(lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         wShingle=0x0F0F;
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_12][
                    (lpxPFData->alpwShingleLine[wPlane][swScanIndex]+4)%8];
      }
      break;
   case SHINGLE_12_6 :
      if(lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         wShingle=0x0F0F;
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_12][
                    (lpxPFData->alpwShingleLine[wPlane][swScanIndex]+5)%8];
      }
      break;
   case SHINGLE_12_7 :
      if(lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         wShingle=0x0F0F;
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_12][
                    (lpxPFData->alpwShingleLine[wPlane][swScanIndex]+6)%8];
      }
      break;
   case SHINGLE_12_8 :
      if(lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         wShingle=0x0F0F;
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_12][
                    (lpxPFData->alpwShingleLine[wPlane][swScanIndex]+7)%8];
      }
      break;
   }

   return( wShingle );

}


/***************************************************************************
 * Function Name:    GetRasterLineShingleMask2
 *
 * Description:
 *    This function returns the shingle mask to use for this raster line
 *    in the second color planes for CMY when 2 bits per pixel is used.
 *    This mask is used (Anded) with each word of the raster line to get
 *    the bits to rotate to the swath.  Returns hex FFFF when the raster
 *    line does not require a shingle mask.
 *
 * Inputs:  lpxPFData      Far pointer to HBP PFData structure.
 *          wPlane         Color plane number 0 to 6.
 *          swScanIndes    Raster line number.
 *
 * Outputs: Returns a 16 bit shingle mask for use with the current raster
 *    line in the second plane.
 * Original Author: L. Cheatham
 * Date: 10/21/98
 *
 **************************************************************************/

WordType GetRasterLineShingleMask2(LPDVDATAREC lpxDataRec, WordType wPlane,
                                   SwordType swScanIndex)
{
   WordType wShingle2;
   LPPFDATA lpxPFData;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   switch(lpxPFData->alpbShingleToApply[wPlane][swScanIndex])
   {
   case SHINGLE_0_1 :
   default :
      /* Don't shingle second plane */
      wShingle2 = 0xFFFF;
      break;
   case SHINGLE_50_1 :
      /* Don't shingle second plane */
      wShingle2 = 0xFFFF;
      break;
   case SHINGLE_50_2 :
      /* Don't shingle second plane */
      wShingle2 = 0xFFFF;
      break;

   case SHINGLE_25_1 :
   case SHINGLE_25_3 :
      /* Use 2 pass shingle mask for second plane when first plane */
      /* is printed with 4 pass */
      wShingle2 = lpxPFData->alpwShingleMask[SHINGLE_MASK_50][
                 (lpxPFData->alpwShingleLine[wPlane][swScanIndex])%2];
      break;
   case SHINGLE_25_2 :
   case SHINGLE_25_4 :
      /* Use 2 pass shingle mask for second plane when first plane */
      /* is printed with 4 pass */
      wShingle2 = lpxPFData->alpwShingleMask[SHINGLE_MASK_50][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex]+1))%2];
      break;
   case SHINGLE_33_1 :
      /* Use a shingle mask that prints each drop in second plane  */
      /* two times in 3 passes.  The drops in the first plane are  */
      /* printed only once in 3 passes.                            */
      wShingle2 = 0xB6B6;
      break;
   case SHINGLE_33_2 :
      wShingle2 = 0x6D6D;
      break;
   case SHINGLE_33_3 :
      wShingle2 = 0xDBDB;
      break;
   case SHINGLE_12_1 :
   case SHINGLE_12_5 :
      wShingle2 = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex]))%4];
      break;
   case SHINGLE_12_2 :
   case SHINGLE_12_6 :
      wShingle2 = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex]+1))%4];
      break;
   case SHINGLE_12_3 :
   case SHINGLE_12_7 :
      /* Use 4 pass shingle mask for second plane when first plane */
      /* is printed with 8 pass */
      wShingle2 = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex]+2))%4];
      break;
   case SHINGLE_12_4 :
   case SHINGLE_12_8 :
      wShingle2 = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex]+3))%4];
      break;
   }

   return( wShingle2 );
}

