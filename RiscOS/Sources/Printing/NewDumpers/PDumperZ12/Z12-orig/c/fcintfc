
/****************************************************************************
 * FcIntfc.c                                       Lexmark Confidential
 *
 * $Revision$
 * $Date$
 * $Author$
 *
 *
 * Description:
 *    FCINTFC.C contains the interface functions for the hbpcode.  Every
 *    function that a driver can call into the hbpcode is included
 *    in this moodule.  There are also some related functions and functions
 *    only used in this module.
 *
 *
 * No.   Date     Who  Function              Description of Change
 * --------------------------------------------------------------------------
 *
 * 037  12/13/99 wlc   Init lpxPFData buffer to 0 after allocating for Mac
 *      driver.
 *
 * 037  12/13/99 cli   Make change in FCStartPage() when print envelop
 *
 * 038  01/08/00 wlc   Only allocate swath buffers for 600 when 1200 or 2400
 *      is being printed as multi pass 600 dpi swaths.  Plus minor cleanup.
 *
 * 039  01/08/00 wlc   Remove reading from WIN.INI for 16 bit compression
 *      override.
 *
 * 040  01/11/00 xzhan FcOutputStrip don't speed up if
 *      lpxPFData->bEnvelopeSize=1
 *
 * 041  01/12/00 xzhan remove all #if OAK_HEAD code
 *
 * 042  01/13/00 xzhan  FcInitStore(), 1200 dpi mode black is still printed as
 *      true 1200dpi to improve the quality
 *
 * 043  01/28/00 xzhan add comments to FCoutputStrip(), clean codes
 *
 * 044  02/14/00 wlc   Set lpxPFData-bTotalPlanes for use in header of raster
 *      file.  This field is needed by some of the debug utility programs.
 *
 * 045  03/10/00 wlc   Set lpxPFData-bTotalPlanes in FCStartDoc() instead of
 *      in FCStartPage() since it used in HwStartPrintJob().
 *
 * 046  03/21/00 kwl   added 2 bit per pixel support
 *
 * 047  04/27/00  xzhan add OPTION_K_1200_AS_2x600 in FCinitstore()
 *
 * 048  05/02/00  xzhan add OPTION_K_1200_AS_2x600 in ResetBuffers()
 *
 * 049  06/02/00  xzhan add FC_WIN32_DLL in FCStartDoc to support 32 bit dll
 *****************************************************************************/

/************** Definitions & Macros *****************************************/
#if !defined(NOPRAGMA)
#pragma warning (disable: 4103)  /* used #pragma pack to change alignment    */
#pragma warning (disable: 4213)  /* nonstndrd extension used: cast on l-value*/
#endif

/************** Include Files *********************************************/

#if defined(DOS_BUILD) || defined(FC_DOS_32)
#include <stdio.h>
#include <malloc.h>
#endif

#if !defined(FC_WIN_32) && !defined(FC_OS2)
#include <memory.h>
#endif

#if defined(GEN_TEST_INPUT_FILES)
#include <stdio.h>
#endif

#include "fclocal.h"
#if defined(THUNKBACK)
#include "sendcmd.h"
#endif

/************** Variable Declarations *************************************/

static char fc_version[] = "fcintfc $Revision$";


/***************************************************************************
 * Function Name:    FCKillStore
 *
 * Description:
 *    This function ***MUST*** be called at the end of every print job.  It
 *    frees all resolution dependent memory that was allocated by
 *    FCInitStore().
 *
 * Inputs:  lpxDataRec     Long pointer to print device structure.
 *
 * Outputs: <none>
 *
 * Date: 05/07/97
 *
 **************************************************************************/
void FCKillStore(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   WordType    i,m,n;
   ByteType    bColorPlanes;

   if (lpxDataRec)
   {
      lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;
   }
   else
   {
      lpxPFData = NULL;
   }

   if (lpxPFData)
   {  /* storage is allocated, so free it */
      bColorPlanes = lpxPFData->bOldColorPlanes;

      for (n=0; n < bColorPlanes; n++)
      {  /* loop for number of color planes in this page */
         for (m=0;m<(WordType)lpxPFData->asdwDBIndx[DROPS_PER_PIXEL][n]; m++)
         {  /* loop for number of drops per pixel for this color plane */
            for (i=0;i<=((WordType)(lpxPFData->asdwDBIndx[BUFSIZE][n]-1) /
                         lpxPFData->wRastersPerSeg);i++)
            {  /* loop for number of segments required for one drop for    */
               /* this color plane                                         */
               if (lpxPFData->alpwPlane[(m*DROP_SEC_SIZE)+(i*bColorPlanes)+n])
               {
                  FREE_MEMORY(lpxPFData->alpwPlane[(m*DROP_SEC_SIZE)+
                              (i*bColorPlanes)+n]);
                  /* Set address in array to null to show it has been freed */
                  lpxPFData->alpwPlane[(m*DROP_SEC_SIZE)+(i*bColorPlanes)+n] =
                     NULL;
               }
            }  /* end of loop for number of segments required.... */
         }  /* end of loop for number of drops per pixel.         */
      }  /* end of loop for number of color planes in this page   */

      if (lpxPFData->lpbMemArea)
      {
         FREE_MEMORY(lpxPFData->lpbMemArea);
         lpxPFData->lpbMemArea = NULL;
      }

      if (lpxPFData->lpxPrtCmd)
      {
         if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
         {
            if (lpxPFData->alpbSwath[0] == (LPByteType)(lpxPFData->lpxPrtCmd +
               SWATH_HEADER_SIZE))
            {
               lpxPFData->alpbSwath[0] = NULL;
            }
            FREE_HUGE_MEMORY((HPPRTCMD)lpxPFData->lpxPrtCmd);
         }
         else
         {
            FREE_MEMORY((LPPRTCMD)lpxPFData->lpxPrtCmd);
            lpxPFData->alpbSwath[0] = NULL;
         }
      }

#if OPTION_COMPRESSION
      if (lpxPFData->lpxCompPrtCmd)
      {
         if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
         {
            FREE_HUGE_MEMORY((HPPRTCMD)lpxPFData->lpxCompPrtCmd);
            lpxPFData->lpxCompPrtCmd = NULL;
         }
         else
         {
            FREE_MEMORY((LPPRTCMD)lpxPFData->lpxCompPrtCmd);
            lpxPFData->lpxCompPrtCmd = NULL;
         }
      }
#endif

#if OPTION_CHECKDENSITY
      if (lpxPFData->lpxDensePrtCmd)
      {
         if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
         {
            FREE_HUGE_MEMORY((HPPRTCMD)lpxPFData->lpxDensePrtCmd);
            lpxPFData->lpxDensePrtCmd = NULL;
         }
         else
         {
            FREE_MEMORY((LPPRTCMD)lpxPFData->lpxDensePrtCmd);
            lpxPFData->lpxDensePrtCmd = NULL;
         }
      }
#endif

      for (i=0; i<=((lpxPFData->wSlicesPerRow-1)/SLICES_PER_SEG);i++)
      {
         if (lpxPFData->alpbSwath[i])
         {
            FREE_MEMORY(lpxPFData->alpbSwath[i]);
            lpxPFData->alpbSwath[i] = NULL;
         }
      }


#if   OPTION_CMY_ENVELOPES
      if (lpxPFData->lpbEnvelopeRasterLine)
      {
         FREE_MEMORY(lpxPFData->lpbEnvelopeRasterLine);
         lpxPFData->lpbEnvelopeRasterLine = NULL;
      }
#endif

#if defined(GEN_TEST_INPUT_FILES)
      if (lpxPFData->lpwRasterFileHeader)
      {
         FREE_MEMORY(lpxPFData->lpwRasterFileHeader);
         lpxPFData->lpwRasterFileHeader = NULL;
      }

      if (lpxPFData->lpbExtendedRasterLine)
      {
         FREE_MEMORY(lpxPFData->lpbExtendedRasterLine);
         lpxPFData->lpbExtendedRasterLine = NULL;
      }
#endif
   }  /* end of freeing allocating storage */

   return;

}  /* end of FCKillStore() */


/***************************************************************************
 * Function Name:    FCInitStore
 *
 * Description:
 *    This function is expected to be called at the beginning of every print
 *    job and sometimes at the beginning of a page. It allocates all storage
 *    that is based on resolution and initializes variables/pointers.
 *
 * Inputs:  lpxDataRec        Far pointer to HBP interface structure.
 *
 * Outputs: fStoreAllocated   TRUE - storage allocation successful
 *                            FALSE - storage allocation failed
 *
 * Date: 05/06/97
 *
 *************************************************************************/
WordType FAR FCInitStore(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   WordType    i, m, n,
               wMemAreaSize,
               wIStart;
   WordType    wSegments;
   WordType    wLines;
   BoolType    fStoreAllocated;
   ByteType    bColorPlanes;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   if ((lpxDataRec->wSwathWidth%16) != 0)
   {
      /* error, swathwidth must be an even word amount */
      return((WordType)FALSE);
   }

   bColorPlanes = lpxPFData->bColorPlanes;

   fStoreAllocated = TRUE; /* storage allocate successful */
   while (fStoreAllocated)
   {

      /* store current values for color planes, resolution, and swath      */
      /* width so we can notice if any of these values change on a page    */
      /* basis.                                                            */
      lpxPFData->bOldColorPlanes  = lpxPFData->bColorPlanes;
      lpxPFData->bOldResolution   = lpxPFData->bResolution;
      lpxPFData->wOldSwathWidth   = lpxDataRec->wSwathWidth;
      lpxPFData->bOldBitsPerPixel = lpxPFData->bBitsPerPixel;

      switch (lpxPFData->bResolution)
      {
      case SUPERLOWRES:
         /* Super Low resolution 300 x 600 dpi */
         lpxPFData->swVertResMult   = SLRES_VERTICAL_MULTIPLIER;
         lpxPFData->swRastResMult   = SLRES_RASTER_MULTIPLIER;
         lpxPFData->swSwathResMult  = SLRES_SWATH_MULTIPLIER;
         break;

      case LORES:
         /* Low resolution 600 x 600 dpi*/
         lpxPFData->swVertResMult   = LORES_VERTICAL_MULTIPLIER;
         lpxPFData->swRastResMult   = LORES_RASTER_MULTIPLIER;
         lpxPFData->swSwathResMult  = LORES_SWATH_MULTIPLIER;
         break;

      case HIRES_NONINTERLACED:
         /* resolution between normal and high 1200 x 600 dpi*/
         lpxPFData->swVertResMult   = LORES_VERTICAL_MULTIPLIER;
         lpxPFData->swRastResMult   = HIRES_RASTER_MULTIPLIER;
         lpxPFData->swSwathResMult  = HIRES_SWATH_MULTIPLIER;
         break;

      case HIRES_INTERLACED:
         /* High resolution 1200 x 1200 dpi */
         lpxPFData->swVertResMult   = HIRES_VERTICAL_MULTIPLIER;
         lpxPFData->swRastResMult   = HIRES_RASTER_MULTIPLIER;
         lpxPFData->swSwathResMult  = HIRES_SWATH_MULTIPLIER;
         break;

      case SHIRES_INTERLACED:
         /* Maximum resolution 2400 x 1200 */
         lpxPFData->swVertResMult   = SHIRES_VERTICAL_MULTIPLIER;
         lpxPFData->swRastResMult   = SHIRES_RASTER_MULTIPLIER;
         lpxPFData->swSwathResMult  = SHIRES_SWATH_MULTIPLIER;
         break;
      }   /* end of Set up the resolution for this print page */


      /* When 2400 dpi is printed as multi pass 600 dpi the swath
         buffer only needs to be large enough for a 600 dpi swath.
         1200 dpi mode, 4 color, black still printed as true 1200dpi  */
#if OPTION_K_1200_AS_2x600
      if((lpxPFData->fOPTION_1200_AS_2X600 == TRUE ) &&
         ((lpxPFData->bResolution == HIRES_INTERLACED) ||
          (lpxPFData->bResolution == SHIRES_INTERLACED ) )) 
#else
      if( ( lpxPFData->fOPTION_1200_AS_2X600 == TRUE ) &&
           ( lpxPFData->bResolution == SHIRES_INTERLACED ) )
#endif
      {  /* 1200 or 2400 dpi printed as multi pass 600 dpi */
         lpxPFData->dwSwathPrintSize = PRT_CMD_SIZE(lpxDataRec->wSwathWidth,
                                                    LORES_SWATH_MULTIPLIER);
      }
      else
      {  /* 300 or 600 dpi or 1200 dpi */
         lpxPFData->dwSwathPrintSize = PRT_CMD_SIZE(lpxDataRec->wSwathWidth,
                                                    lpxPFData->swSwathResMult);
      }


      lpxPFData->wWordsPerRow    = (lpxDataRec->wSwathWidth/16) *
                                    lpxPFData->swSwathResMult;

      lpxPFData->wBytesPerRow    = lpxPFData->wWordsPerRow * (WordType)2;

      lpxPFData->wRastersPerSeg  = (WordType)((SEGMENT_SIZE) /
                                    lpxPFData->wBytesPerRow);


      /* set size of delay buffers, in number of raster lines */
      lpxPFData->asdwDBIndx[BUFSIZE][0] = P1_BUFNUM * lpxPFData->swVertResMult;
      lpxPFData->asdwDBIndx[BUFSIZE][1] = P2_BUFNUM * lpxPFData->swVertResMult;
      lpxPFData->asdwDBIndx[BUFSIZE][2] = P3_BUFNUM * lpxPFData->swVertResMult;
      lpxPFData->asdwDBIndx[BUFSIZE][3] = P4_BUFNUM * lpxPFData->swVertResMult;
      lpxPFData->asdwDBIndx[BUFSIZE][4] = P5_BUFNUM * lpxPFData->swVertResMult;
      lpxPFData->asdwDBIndx[BUFSIZE][5] = P6_BUFNUM * lpxPFData->swVertResMult;

      /* allocate delay buffers */
      for (n = 0;n < bColorPlanes; n++)
      {  /* loop for number of color planes in this page */
         for (m=0;m<(WordType)lpxPFData->asdwDBIndx[DROPS_PER_PIXEL][n]; m++)
         {  /* loop for number of drops per pixel for this color plane */

            /* This re-write will fix BUG-1541 & read better I hope */
            /* get the number of raster lines we need for this buffer */
            wLines = (WordType)(lpxPFData->asdwDBIndx[BUFSIZE][n]);

            /* the -1 in the following statement insures we do not allocate
             * an extra zero length buffer segment when the number of rows to
             * be stored in the delay buffer is equal to the number of rows
             * per segment. */
            wSegments = ((wLines - 1) / lpxPFData->wRastersPerSeg) + 1;

            for (i = 0; i < wSegments; i++)
            {  /* loop for number of segments required for this color plane */

               if (wLines >= lpxPFData->wRastersPerSeg)
               {  /* full segment required */
                  lpxPFData->alpwPlane[(m*DROP_SEC_SIZE)+(i*bColorPlanes)+n] =
                        (LPWordType)ALLOCATE_MEMORY((lpxPFData->wRastersPerSeg *
                                                     lpxPFData->wBytesPerRow));
                  /* decrement number of rows needed */
                  wLines -= lpxPFData->wRastersPerSeg;
               }
               else
               {  /* partial segment required */
                  lpxPFData->alpwPlane[(m*DROP_SEC_SIZE)+(i*bColorPlanes)+n] =
                        (LPWordType)ALLOCATE_MEMORY((wLines *
                                                     lpxPFData->wBytesPerRow));
               }

               if (lpxPFData->alpwPlane[(m*DROP_SEC_SIZE)+(i*bColorPlanes)+n] ==
                   NULL)
               {
                  fStoreAllocated = FALSE;
                  break;
               }
            }  /* end of loop for number of segments required */

            if (fStoreAllocated == FALSE)
            {
               break;
            }
         }  /* end of loop for number of drops per pixel.   */
         if (fStoreAllocated == FALSE)
         {
            break;
         }
      }  /* end of loop for number of color planes in this page */

      /* end of allocating delay buffers */

      if (fStoreAllocated == FALSE)
      {
         break;
      }

      /* allocate print swath buffer */
      lpxPFData->wSlicesPerRow = lpxPFData->wBytesPerRow * (WordType)8;

      
      if( lpxPFData->fOPTION_1200_AS_2X600 == TRUE ) 
      {
#if OPTION_K_1200_AS_2x600
         if( lpxPFData->bResolution == HIRES_INTERLACED )
         {  /* for HiRes mode convert from 1200 dpi to 600 dpi */
           lpxPFData->wSlicesPerRow /=2;
         }
#endif
         if( lpxPFData->bResolution == SHIRES_INTERLACED )
         {  /* for Maximum mode convert from 2400 dpi to 600 dpi */
            lpxPFData->wSlicesPerRow /=4;
         }
      }

      if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
      {  /* larger than one segment */
         lpxPFData->lpxPrtCmd = (HPByteType)ALLOCATE_HUGE_MEMORY(
                              lpxPFData->dwSwathPrintSize);
         /* cast pointer to DwordType for MAC driver */
         if (LOWORD((DwordType)lpxPFData->lpxPrtCmd) == 0)
         {
            lpxPFData->alpbSwath[0]=(LPByteType)
                                  (lpxPFData->lpxPrtCmd+SWATH_HEADER_SIZE);
            wIStart = 1;
         }
         else
         {
            wIStart = 0;
         }

         if (!lpxPFData->lpxPrtCmd)
         {
            fStoreAllocated = FALSE;
            break;
         }
      }
      else
      {  /* smaller than one segment */
         lpxPFData->lpxPrtCmd    = (LPByteType)ALLOCATE_MEMORY(
                                   lpxPFData->dwSwathPrintSize);
         lpxPFData->alpbSwath[0] = (LPByteType) (lpxPFData->lpxPrtCmd +
                                   SWATH_HEADER_SIZE);
         wIStart = 1;

         if (!lpxPFData->lpxPrtCmd)
         {
            fStoreAllocated = FALSE;
            break;
         }
      }

      /* the -1 in the statement (lpxPFData->swSlicesPerSeg-1) is so we      */
      /* don't allocate a zero length buffer segment when the swath slices   */
      /* per row is evenly divisible by MAX_SLICES_PER_SEG.                  */
      for (i = wIStart; i <= ((WordType)(lpxPFData->wSlicesPerRow-1) /
          (WordType)SLICES_PER_SEG); i++)
      {
         lpxPFData->alpbSwath[i] =
            (LPByteType)ALLOCATE_MEMORY(((WordType)K_BYTES_PER_SLICE *
                                         (WordType)SLICES_PER_SEG));
         if (!lpxPFData->alpbSwath[i])
         {
            fStoreAllocated = FALSE;
            break;
         }
      }

      if (fStoreAllocated == FALSE)
      {
         break;
      }
      /* end of allocating print swath buffer */


#if OPTION_COMPRESSION
      /* allocate compressed print swath buffer */
      if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
      {
         lpxPFData->lpxCompPrtCmd =
            (HPByteType)ALLOCATE_HUGE_MEMORY(lpxPFData->dwSwathPrintSize);
      }
      else
      {
         lpxPFData->lpxCompPrtCmd =
            (LPByteType)ALLOCATE_MEMORY(lpxPFData->dwSwathPrintSize);
      }

      if   (!lpxPFData->lpxCompPrtCmd)
      {
         fStoreAllocated = FALSE;
         break;
      }
#else
      lpxPFData->lpxCompPrtCmd = 0;
#endif

#if   OPTION_CHECKDENSITY
      /* allocate extra print swath buffer for swaths that are too dense   */
      if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
      {
         lpxPFData->lpxDensePrtCmd =
            (HPByteType)ALLOCATE_HUGE_MEMORY(lpxPFData->dwSwathPrintSize);
      }
      else
      {
         lpxPFData->lpxDensePrtCmd =
            (LPByteType)ALLOCATE_MEMORY(lpxPFData->dwSwathPrintSize);
      }

      if   (!lpxPFData->lpxDensePrtCmd)
      {
         fStoreAllocated = FALSE;
         break;
      }

      /* initialze the array which helps us count the dots in a swath   */
      PopulateBitCount(lpxDataRec);
#else
      lpxPFData->lpxDensePrtCmd = 0;
#endif


      /* get storage for several smaller 'chunks' of memory                */
      /* specifically:                                                     */
      /*       Print Line Mask   16 words                                  */
      /*       Raster Line Mask  16 words                                  */
      /*       Shingle Mask      10 shingle passes * 20 words each         */
      /*                         we are not currently using 10 shingle     */
      /*                         masks, but this allows room to grow.      */
      /*       Scan Start Array  Max Delay Buffer * Max Num Planes words   */
      /*       Scan End Array    Max Delay Buffer * Max Num Planes words   */
      /*       Shingle line      Max Delay Buffer * Max Num Planes words   */
      /*       Shingle to Apply  Max Delay Buffer * Max Num Planes bytes   */
      lpxPFData->swMaxDelayBuf = MAXBUFNUM * lpxPFData->swVertResMult;

      wMemAreaSize = (WordType)((16 + 16 + 400 +
                      (lpxPFData->swMaxDelayBuf*bColorPlanes*3))*2 +
                      (lpxPFData->swMaxDelayBuf*bColorPlanes));

      lpxPFData->lpbMemArea = (LPByteType) ALLOCATE_MEMORY(wMemAreaSize);

      if   (lpxPFData->lpbMemArea)
      {
         lpxPFData->lpwPrtMask            = (LPWordType)lpxPFData->lpbMemArea;
         lpxPFData->lpwRastMask           = (LPWordType)(lpxPFData->lpbMemArea +
                                          32);
         lpxPFData->alpwShingleMask[0]    = (LPWordType)(lpxPFData->lpbMemArea +
                                          32 + 32);
         lpxPFData->alpswScanStart[0]     = (LPSwordType)(lpxPFData->lpbMemArea+
                                          32 + 32 + 400);
         lpxPFData->alpswScanEnd[0]       = (LPSwordType)(lpxPFData->lpbMemArea+
                                          32 + 32 + 400 +
                                          (lpxPFData->swMaxDelayBuf *
                                         bColorPlanes * 2));
         lpxPFData->alpwShingleLine[0]    = (LPWordType) (lpxPFData->lpbMemArea+
                                          32 + 32 + 400 +
                                          (lpxPFData->swMaxDelayBuf *
                                          bColorPlanes * 2) +
                                          (lpxPFData->swMaxDelayBuf *
                                          bColorPlanes * 2));
         lpxPFData->alpbShingleToApply[0] = (LPByteType) (lpxPFData->lpbMemArea+
                                          32 + 32 + 400 +
                                          (lpxPFData->swMaxDelayBuf *
                                          bColorPlanes * 2) +
                                          (lpxPFData->swMaxDelayBuf *
                                          bColorPlanes * 2) +
                                          (lpxPFData->swMaxDelayBuf *
                                          bColorPlanes * 2));
         for (n=1;n<bColorPlanes;n++)
         {
            lpxPFData->alpswScanStart[n]    =lpxPFData->alpswScanStart[n-1] +
                                             lpxPFData->swMaxDelayBuf;
            lpxPFData->alpswScanEnd[n]      =lpxPFData->alpswScanEnd[n-1] +
                                             lpxPFData->swMaxDelayBuf;
            lpxPFData->alpwShingleLine[n]   =lpxPFData->alpwShingleLine[n-1] +
                                             lpxPFData->swMaxDelayBuf;
            lpxPFData->alpbShingleToApply[n]=lpxPFData->alpbShingleToApply[n-1]+
                                             lpxPFData->swMaxDelayBuf;
         }

         for (n=1;n<10;n++)
         {
            lpxPFData->alpwShingleMask[n] =
               lpxPFData->alpwShingleMask[n-1] + 20;
         }
      }
      else
      {
         fStoreAllocated = FALSE;
         break;
      }

#if OPTION_CMY_ENVELOPES
      /* allocate enough bytes to expand the input raster line to CMYK */
      /* only for printers that require envelopes be printed using CMY */
      switch (lpxDataRec->bMediaSize)
      {
      case ENVELOPE_MONARCH :
      case ENVELOPE_9 :
      case ENVELOPE_10 :
      case ENVELOPE_DL :
      case ENVELOPE_C5 :
      case ENVELOPE_B5 :
      case ENVELOPE_C6 :
      case ENVELOPE_D5 :
      case ENVELOPE_75 :
      case ENVELOPE_BARONIAL :
      case ENVELOPE_6_3_4 :
      case JPNLONG3:
      case JPNSQUARE4:
      case JPNSQUARE5:
      case JPNSQUARE6:
      case ENVELOPE_CUSTOM :
      {
         lpxPFData->lpbEnvelopeRasterLine =
            (LPByteType)ALLOCATE_MEMORY(300 * lpxPFData->bResolution
                                        * bColorPlanes);
         if    (!lpxPFData->lpbEnvelopeRasterLine)
         {
            fStoreAllocated = FALSE;
            break;
         }
         break;
      }
      default :
         break;
      }
#endif

#if defined(GEN_TEST_INPUT_FILES)
      lpxPFData->lpwRasterFileHeader =
         (LPWordType)ALLOCATE_MEMORY(100);
      if    (!lpxPFData->lpwRasterFileHeader)
      {
         fStoreAllocated = FALSE;
         break;
      }
      /* At 2400 dpi and 6 planes we need 14,400 bytes */
      lpxPFData->lpbExtendedRasterLine = (LPByteType)
                                         ALLOCATE_MEMORY(14400);
      if (!lpxPFData->lpbExtendedRasterLine)
      {
         fStoreAllocated = FALSE;
         break;
      }
#endif

      break;   /* get out of loop unconditionally */
   } /* end of: while (fStoreAllocated) */

   return(fStoreAllocated);

}  /* end of FCInitStore(); */


/***************************************************************************
 * Function Name:    FCStartDoc
 *
 * Description:
 *    This function is expected to be called at the beginning of every print
 *    job. It allocates all global memory required by all print formatter
 *    functions.
 *
 * Inputs:  lpxDataRec        Far pointer to HBP interface structure.
 *
 * Outputs: fStoreAllocated   TRUE - storage allocation successful
 *                            FALSE - storage allocation failed
 *
 * Date: 09/27/96
 *
 *************************************************************************/
WordType EXPENTRY FAR FCStartDoc(LPDVDATAREC lpxDataRec)
{
   LPPFDATA   lpxPFData;
   WordType   i, n ;
   BoolType   fStoreAllocated;
   ByteType   bCompressOverRide = 0;
   ByteType   bPlanes = 0;


#if CPROF
   PrfEnter(0);
#endif

#if defined(FC_WIN16_DLL) ||defined(FC_WIN32_DLL)
#if !defined(THUNKBACK)
   /* Initialize the address for the OUTPUT() macro to callers SendCommand */
   lpfnSendCommand = lpxDataRec->lpfnSendCommand;
#endif
#endif

   FCEndDoc(lpxDataRec); /* Clean up any prior or current allocated space */

   /* get lpxPFData, the print formatter common data structure   */
   lpxDataRec->lpLXDevice = (DwordType)ALLOCATE_MEMORY(COMMONBUFSIZE);
   lpxPFData = (LPPFDATA) lpxDataRec->lpLXDevice;

   if (lpxPFData)
   {
      /* Init allocated buffer to zero for OS's that don't zero memory */
      _fmemset( (void FAR *)lpxDataRec->lpLXDevice, 0, COMMONBUFSIZE);

      /* bColorPlanes and bBitsPerPixel may get updated in GetResolution */
      lpxPFData->bColorPlanes  = lpxDataRec->bColorPlanes;
      lpxPFData->bBitsPerPixel = lpxDataRec->bBitsPerPixel;
      lpxPFData->fOPTION_1200_AS_2X600 = TRUE;

      lpxPFData->bResolution = GetResolution(lpxDataRec);
      SetBitsPerPixel(lpxDataRec);
      SetDropsPerPixel(lpxDataRec);

      /* Calculate number of color planes from driver*/
      for (i = 0;  i < lpxPFData->bColorPlanes; i++)
      {
         bPlanes += lpxPFData->abBitsPerPixel[i];
      }

      lpxPFData->bTotalPlanes = bPlanes;

      /* now allocate the rest of dynamic storage the hbpcode will need    */
      fStoreAllocated = (BoolType)FCInitStore(lpxDataRec);

      if (fStoreAllocated)
      {
         /* Set head adjustment values based on lpxDataRec input, and also */
         /* perform error checking on the lpxDataRec input values.         */
         SetCartridgeAlignment(lpxDataRec);

         /* initialize dot count to 0 for all color planes */
         for (n = 0; n < MAXNUMPLANES; n++)
         {
            lpxPFData->asdwDotCount[n] = 0;
         }

         /* get hardware printer specific buffer */
         lpxPFData->lpxHWData =
            (LPHWDATA )ALLOCATE_MEMORY(HW_BUFF_SIZE);

         if (lpxPFData->lpxHWData)
         {
            HwStartPrintJob(lpxDataRec);
         }
         else
         {
            fStoreAllocated = FALSE;
         }

      }   /* end of FCInitStore() sucessfull */
   }  /* end of lpxDataRec->lpLXDevice allocated */
   else
   {
      fStoreAllocated = FALSE;
   }

#if 0
/*#if defined(FC_WIN_16) */
   /* Get configuration values from WIN.INI for Win 9x/3x systems.      */
   /* This is just for fexlibility and development.  Defaults used when */
   /* the key is not found in WIN.INI                                   */

   bCompressOverRide = (ByteType)GetProfileInt("Lexmark_Test",
                                               "EnableCompression",
                                               2);
   if (bCompressOverRide <= 1)
   {  /* Override with value read from WIN.INI */
      lpxDataRec->bCompress = bCompressOverRide;
   }
#endif

   return((WordType)fStoreAllocated);

} /* end of FCStartDoc() */


/***************************************************************************
 * Function Name:    FCStartPage
 *
 * Description:
 *    This function is expected to be called at the beginning of every print
 *    page.  It initializes several variables in the print formatter
 *    structure (lpxPFData), based on information in reads from the HBP
 *    interface structure (lpxDataRec).  Allocates memory when more memory
 *    is required for the current page than has been allocated.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: TRUE        Always returns successful.
 *
 * Date: 09/27/96
 *
 **************************************************************************/
WordType EXPENTRY FAR FCStartPage(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   WordType    i, n;
   ByteType    bOldResolution;
   BoolType    fStoreAllocated;
   ByteType    bColorPlanes;
   ByteType    bPlanes = 0;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   bOldResolution = lpxPFData->bResolution;

   /* set flag to indicate this is the first move on this page */
   lpxPFData->bFirstMoveOnPage = 1;
   /* don't need more blank line */
   lpxPFData->swMoreBlankLine = 0;

   /* bColorPlanes and bBitsPerPixel may get updated in GetResolution         */
   /* Both are updated for printers that require envelopes be printed with CMY*/
   /* The updated values are then used in FormatInputRasterLine()             */
   lpxPFData->bColorPlanes = lpxDataRec->bColorPlanes;
   lpxPFData->bBitsPerPixel = lpxDataRec->bBitsPerPixel;

   lpxPFData->bResolution = GetResolution(lpxDataRec);

   bColorPlanes   = lpxPFData->bColorPlanes;

   /* Test for page boundry changes which will require us to reallocate    */
   /* memory.  Notice that we do not reallocate memory if we have too much */
   /* memory allocated for the current page.  We only reallocate memory if */
   /* we don't have enough memory allocated for the current page.          */
   /* However for bits per pixel, we reallocate memory whenever the value  */
   /* changes, whether its higher or lower.                                */

   /* Changed to reallocate when resolution changes, since FCInitStore()   */
   /* sets the resoulution multipliers based on resolution.                */

   if ( (lpxPFData->bOldResolution   !=  lpxPFData->bResolution)   ||
        (lpxPFData->bOldColorPlanes  !=  lpxPFData->bColorPlanes)  ||
        (lpxPFData->bOldBitsPerPixel !=  lpxPFData->bBitsPerPixel) ||
        (lpxPFData->wOldSwathWidth   !=  lpxDataRec->wSwathWidth)   )
   {
      FCKillStore(lpxDataRec); /* release resolution dependent storage */

      /* Moved to here to fix bug 27689 14-Oct-99  */
      SetBitsPerPixel(lpxDataRec);
      SetDropsPerPixel(lpxDataRec);

      /* Calculate number of color planes from driver*/
      for (i = 0;  i < lpxPFData->bColorPlanes; i++)
      {
         bPlanes += lpxPFData->abBitsPerPixel[i];
      }

      lpxPFData->bTotalPlanes = bPlanes;


      /* allocate resolution, planes and bits per pixel dependent storage */
      fStoreAllocated = (BoolType)FCInitStore(lpxDataRec);
      if (fStoreAllocated == FALSE)
      {
         return(FALSE);
      }
   }

   lpxPFData->sdwRowPos      = -1;         /* raster row number begins at 0 */
   lpxPFData->bPrintQuality  = lpxDataRec->bQuality;
   lpxPFData->fSwathPresent  = FALSE;

   /* order is important! Resolution must be set before margins are set */
   lpxPFData->wLeftMargin              = GetLeftMargin(lpxDataRec);
   lpxPFData->wTopMargin               = GetTopMargin(lpxDataRec);
   lpxPFData->swFormsMovePending       = (SwordType)lpxPFData->wTopMargin;
   lpxPFData->swFutureFormsMovePending = 0;
   lpxPFData->bShingle                 = GetShingleMode(lpxDataRec);
   lpxPFData->bBIDIPrintDirection      = LTOR;

   for (n=0; n<bColorPlanes; n++)
   {
      lpxPFData->awExtraNozzles[n] = 0;
      lpxPFData->abShingleIndex[n] = COLOR;
   }

   switch (lpxPFData->bColorPlanes)
   {
   case 1 :
      if((lpxPFData->bResolution == HIRES_INTERLACED)  ||
         (lpxPFData->bResolution == SHIRES_INTERLACED) ||
         (lpxPFData->bResolution == HIRES_NONINTERLACED) )
      {
         lpxPFData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT;
         lpxPFData->abShingleIndex[0] = MONO_PART;
      }
      else
      {
         lpxPFData->wBaseNozzleCount  = MONO_NOZZLE_COUNT;
         lpxPFData->abShingleIndex[0] = MONO_FULL;
      }
      break;
   case 3 :
      lpxPFData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT/3;
      break;
   case 4 :
      lpxPFData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT/3;
      lpxPFData->awExtraNozzles[3] = COLOR_NOZZLE_COUNT - (COLOR_NOZZLE_COUNT/3);
      lpxPFData->abShingleIndex[3] = MONO_PART;
      break;
   case 6 :
      lpxPFData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT/3;
      break;
   }


#if 0
   if ( (lpxPFData->bResolution == HIRES_INTERLACED) &&
        (lpxPFData->bShingle == SHINGLE_25))
   {
      /* 25% shingling at the interlacing high resolution is not supported */
      lpxPFData->bShingle = SHINGLE_50;
   }
#endif

   /* Added following to support printing 1200dpi as 2 pass 600dpi.            */
   /* These are only used for 1200 dpi that is 50% shingled printed at 600 dpi */
   /* Initialize these at the start of each page when in 1200 dpi mode.        */
   if((lpxPFData->bResolution == SHIRES_INTERLACED)||
      (lpxPFData->bResolution == HIRES_INTERLACED &&
      lpxDataRec->bMediaType == GLOSSY_PAPER
      &&(lpxDataRec->bColorPlanes == 3||lpxDataRec->bColorPlanes == 4)) )
   {
      lpxPFData->wCMYEvenRasterSlice = 0;  /* start with even slice CMY head */
      lpxPFData->wCMYOddRasterSlice  = 0;  /* start with odd slice CMY head */
      lpxPFData->wBLKEvenRasterSlice = 0;  /* start with even slice Black head */
      lpxPFData->wBLKOddRasterSlice  = 0;  /* start with odd slice Black head */
      lpxPFData->wKCMEvenRasterSlice = 0;  /* start with even slice KCM head*/
      lpxPFData->wKCMOddRasterSlice  = 0;  /* start with odd slice KCM head */
   }
   else if ( lpxPFData->bResolution == HIRES_INTERLACED)
   {
      lpxPFData->wCMYEvenRasterSlice = 0;  /* start with even slice CMY head */
      lpxPFData->wCMYOddRasterSlice  = 1;  /* start with odd slice CMY head */
      lpxPFData->wBLKEvenRasterSlice = 0;  /* start with even slice Black head */
      lpxPFData->wBLKOddRasterSlice  = 1;  /* start with odd slice Black head */
      lpxPFData->wKCMEvenRasterSlice = 0;  /* start with even slice KCM head*/
      lpxPFData->wKCMOddRasterSlice  = 1;  /* start with odd slice KCM head */
   } 
   
#if OPTION_600_AS_2X300
   /* 600_AS_2X300 scheme is applied when 600 dpi 50% shingling is desired  */
   if( (lpxPFData->bShingle == SHINGLE_50) && (lpxPFData->bResolution == LORES) )
   {
      lpxPFData->wCMYSwathByPgCtr = 0;
      lpxPFData->wKOrKcmSwathByPgCtr = 0;
   }
#endif

#if OPTION_CDE
   /* Consecutive dot elimination is used for ink depletion for some printers
      in certain modes.                                                    */
   lpxPFData->fCDE = CheckForCDE(lpxDataRec, lpxDataRec->bQuality);
   if (lpxPFData->bShingle != NO_SHINGLE)
   {
      lpxPFData->fCDE = FALSE;
   }
#endif

   FCSetPaperSource(lpxDataRec);

   LoadShingleMasks(lpxDataRec, bColorPlanes);

   switch (bColorPlanes)
   {  /* Set print mode, beginning and ending delay buffer, and initial    */
      /* delay for delay buffers                                           */

   case 1 : /* black only */
      lpxPFData->swDelayBufStart = 0;
      lpxPFData->swDelayBufEnd   = 1;
      lpxPFData->asdwDBIndx[INIT_DELAY][0] = KONLY_P4_DELAY;
      lpxPFData->bPrintHead = MONO_CARTRIDGE;
      break;

   case 3 : /* CMY */
      lpxPFData->swDelayBufStart = 0;
      lpxPFData->swDelayBufEnd   = 3;
      lpxPFData->asdwDBIndx[INIT_DELAY][0] = CMY_P1_DELAY;
      lpxPFData->asdwDBIndx[INIT_DELAY][1] = CMY_P2_DELAY;
      lpxPFData->asdwDBIndx[INIT_DELAY][2] = CMY_P3_DELAY;
      lpxPFData->bPrintHead = COL_CARTRIDGE;
      break;

   case 4 : /* CMYK */
      lpxPFData->swDelayBufStart = 0;
      lpxPFData->swDelayBufEnd   = 4;

      lpxPFData->asdwDBIndx[INIT_DELAY][0] = (SdwordType)(CMYK_P1_DELAY +
                                             lpxPFData->swHead1VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][1] = (SdwordType)(CMYK_P2_DELAY +
                                             lpxPFData->swHead1VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][2] = (SdwordType)(CMYK_P3_DELAY +
                                             lpxPFData->swHead1VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][3] = (SdwordType)(CMYK_P4_DELAY +
                                             lpxPFData->swHead2VertAdjust);

      break;

   case 6 : /* CMYKCM */
      lpxPFData->swDelayBufStart = 0;
      lpxPFData->swDelayBufEnd   = 6;

      lpxPFData->asdwDBIndx[INIT_DELAY][0] = (SdwordType)(CMYKCM_P1_DELAY +
                                             lpxPFData->swHead1VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][1] = (SdwordType)(CMYKCM_P2_DELAY +
                                             lpxPFData->swHead1VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][2] = (SdwordType)(CMYKCM_P3_DELAY +
                                             lpxPFData->swHead1VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][3] = (SdwordType)(CMYKCM_P4_DELAY +
                                             lpxPFData->swHead2VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][4] = (SdwordType)(CMYKCM_P5_DELAY +
                                             lpxPFData->swHead2VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][5] = (SdwordType)(CMYKCM_P6_DELAY +
                                             lpxPFData->swHead2VertAdjust);
      break;

   default :
      break;
   }  /* End of: Set print mode, beginning and ending delay buffer, and    */
      /* initial delay for delay buffers                                   */

   ResetBuffers(0L,lpxDataRec);

   lpxPFData->lpwPrtMask[0] = PRINT_MASK0;
   lpxPFData->lpwPrtMask[1] = PRINT_MASK1;
   lpxPFData->lpwPrtMask[2] = PRINT_MASK2;
   lpxPFData->lpwPrtMask[3] = PRINT_MASK3;
   lpxPFData->lpwPrtMask[4] = PRINT_MASK4;
   lpxPFData->lpwPrtMask[5] = PRINT_MASK5;
   lpxPFData->lpwPrtMask[6] = PRINT_MASK6;
   lpxPFData->lpwPrtMask[7] = PRINT_MASK7;
   lpxPFData->lpwPrtMask[8] = PRINT_MASK8;
   lpxPFData->lpwPrtMask[9] = PRINT_MASK9;
   lpxPFData->lpwPrtMask[10] = PRINT_MASK10;
   lpxPFData->lpwPrtMask[11] = PRINT_MASK11;
   lpxPFData->lpwPrtMask[12] = PRINT_MASK12;
   lpxPFData->lpwPrtMask[13] = PRINT_MASK13;
   lpxPFData->lpwPrtMask[14] = PRINT_MASK14;
   lpxPFData->lpwPrtMask[15] = PRINT_MASK15;

   lpxPFData->lpwRastMask[0] = RASTER_MASK0;
   lpxPFData->lpwRastMask[1] = RASTER_MASK1;
   lpxPFData->lpwRastMask[2] = RASTER_MASK2;
   lpxPFData->lpwRastMask[3] = RASTER_MASK3;
   lpxPFData->lpwRastMask[4] = RASTER_MASK4;
   lpxPFData->lpwRastMask[5] = RASTER_MASK5;
   lpxPFData->lpwRastMask[6] = RASTER_MASK6;
   lpxPFData->lpwRastMask[7] = RASTER_MASK7;
   lpxPFData->lpwRastMask[8] = RASTER_MASK8;
   lpxPFData->lpwRastMask[9] = RASTER_MASK9;
   lpxPFData->lpwRastMask[10] = RASTER_MASK10;
   lpxPFData->lpwRastMask[11] = RASTER_MASK11;
   lpxPFData->lpwRastMask[12] = RASTER_MASK12;
   lpxPFData->lpwRastMask[13] = RASTER_MASK13;
   lpxPFData->lpwRastMask[14] = RASTER_MASK14;
   lpxPFData->lpwRastMask[15] = RASTER_MASK15;

   HwStartPage(lpxDataRec);

#if defined(GEN_TEST_INPUT_FILES)
   {
      lpxPFData->lpwRasterFileHeader[0] = 'XX';
      lpxPFData->lpwRasterFileHeader[1] = 'XX';

      lpxPFData->lpwRasterFileHeader[2]  = 'TL';
      lpxPFData->lpwRasterFileHeader[3]  = 0x0001;
      lpxPFData->lpwRasterFileHeader[4]  = (WordType) lpxPFData->swRastResMult
                                                      * 300;
      lpxPFData->lpwRasterFileHeader[5]  = (WordType) lpxPFData->bTotalPlanes;
      lpxPFData->lpwRasterFileHeader[6]  = (WordType) lpxPFData->swRastResMult
                                                      * 2400;
      lpxPFData->lpwRasterFileHeader[7]  = (WordType) lpxPFData->swVertResMult
                                                      * 3300;
      lpxPFData->lpwRasterFileHeader[8]  = (WordType) lpxPFData->bBitsPerPixel;
      lpxPFData->lpwRasterFileHeader[9]  = (WordType) lpxDataRec->bColorPlanes;
      /* clear unused word fields in header */
      for (n = 10; n < 34; n++)
      {
         lpxPFData->lpwRasterFileHeader[n] = 0x0000;
      }

      SendRasters((void FAR *)lpxDataRec, lpxPFData->lpwRasterFileHeader, 68);
   }
#endif

   return(TRUE);
} /* end of FCStartPage() */


/***************************************************************************
 * Function Name:    FCEndPage
 *
 * Description:
 *    This function ***MUST*** be called at the end of every print page.  It
 *    calls function FlushBuffers(), which formats and prints all raster
 *    lines that are in the delay buffers.
 *
 * Inputs:  lpxDataRec    Long pointer to print device structure.
 *
 * Outputs: <none>
 *
 * Date: 09/27/96
 *
 **************************************************************************/
void EXPENTRY FAR FCEndPage(LPDVDATAREC lpxDataRec)
{
   FlushBuffers(lpxDataRec,END_OF_PAGE);

   HwEndPage(lpxDataRec);

   return;

}  /* End of FCEndPage() */


/***************************************************************************
 * Function Name:    FCEndDoc
 *
 * Description:
 *    This function ***MUST*** be called at the end of every print job.  It
 *    frees all fixed size memory that was allocated in FCStartDoc().
 *
 * Inputs:  lpxDataRec    Long pointer to print device structure.
 *
 * Outputs: <none>
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/
void EXPENTRY FAR FCEndDoc(LPDVDATAREC lpxDataRec)
{
   LPPFDATA lpxPFData;

   if   (lpxDataRec)
   {
      lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

      if (lpxPFData)
      {  /* storage is allocated, so free it */
         HwEndJob(lpxDataRec);

         FCKillStore(lpxDataRec);/* release resolution dependent storage */

         if (lpxPFData->lpxHWData)
         {
            FREE_MEMORY(lpxPFData->lpxHWData);
         }

         FREE_MEMORY(lpxPFData);
         lpxDataRec->lpLXDevice = 0x00;

      }  /* end of freeing storage allocation */
   }

#if CPROF
   PrfExit(0);
#endif
   return;

}  /* End of FCEndDoc() */


/***************************************************************************
 * Function Name:    ResetBuffers
 *
 * Description:
 *    This function initializes the IN and OUT indexes that point into the
 *    delay buffers.  It should be called every time the delay buffers have
 *    been emptied and need to be reinitialized.
 *
 * Inputs:  lpxDataRec    Long pointer to HBP interface structure.
 *
 * Outputs: Initializes the IN and OUT indexes which point into the color
 *          plane delay buffers.
 *
 * Date: 09/27/96
 *
 *************************************************************************/
void ResetBuffers(SdwordType lCurrentRowPos, LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   WordType
      n,m,
      wShingleSize,
      wNozzleCount,
      wStepDiff;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   lpxPFData->sdwRasterLinesProcessed = 0;
   lpxPFData->sdwRowsToProcess        = (SdwordType)lpxPFData->wBaseNozzleCount;
   lpxPFData->swFutureRowsToShingle   = 0;
   lpxPFData->swOut                   = FC_OUT;
   /*lpxPFData->bBIDIPrintDirection     = LTOR; */
   lpxPFData->sdwBottomNozzleRowNum   = lCurrentRowPos - 1;

   if(lpxPFData->bShingle != SHINGLE_12)
   {
      wStepDiff=3;
   }
   else
   {
      wStepDiff=1;
   }

   for (n=(WordType)lpxPFData->swDelayBufStart;
        n<(WordType)lpxPFData->swDelayBufEnd; n++)
   {
      wNozzleCount =
         lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[n];
      lpxPFData->asdwDBIndx[FC_IN][n]  = 0;
      lpxPFData->awRowsToDelayPrint[n] = 0;
      lpxPFData->awRowsToPrint[n]      = 0;
      lpxPFData->awRowsToDelayFree[n]  = 0;
      lpxPFData->asdwFirstRowOfSection[FC_OUT][n] = lCurrentRowPos;
      for (m=0; m<(WordType)lpxPFData->swMaxDelayBuf; m++)
      {
         lpxPFData->alpbShingleToApply[n][m] = SHINGLE_THRU;
      }
   }

   for (n=(WordType)lpxPFData->swDelayBufStart;
        n<(WordType)lpxPFData->swDelayBufEnd; n++)
   {
      lpxPFData->asdwDBIndx[FC_OUT][n] =
         -(lpxPFData->asdwDBIndx[INIT_DELAY][n]);
      lpxPFData->asdwFirstRowOfSection[FC_OUT_EVEN][n] = -9999L;
      lpxPFData->asdwFirstRowOfSection[FC_OUT_ODD][n]  = -9999L;

      if (lpxPFData->bResolution == HIRES_INTERLACED
         ||lpxPFData->bResolution == SHIRES_INTERLACED)
      {
         wNozzleCount = lpxPFData->wBaseNozzleCount +
                        lpxPFData->awExtraNozzles[n];
#if OPTION_K_1200_AS_2x600
         if ((lpxPFData->bColorPlanes == 4) && (n==3)&&
             (lpxPFData->bShingle == SHINGLE_33))
#else
         /* now K in cmyk also use 2-pass 600 dpi method to form 1200 dpi
         so merge them*/
         if ((lpxPFData->bColorPlanes == 4) && (n==3)
             &&(lpxPFData->bResolution == HIRES_INTERLACED||
                (lpxPFData->bResolution == SHIRES_INTERLACED
                 &&lpxPFData->bShingle == SHINGLE_33)))
#endif
         {
            wShingleSize = wNozzleCount / (WordType)3;
         }
         else if (lpxPFData->bShingle == NO_SHINGLE)
         {
            wShingleSize = wNozzleCount;
         }
         else if (lpxPFData->bShingle == SHINGLE_50)
         {
            wShingleSize = wNozzleCount / (WordType)2;
         }
         else if (lpxPFData->bShingle == SHINGLE_25)
         {
            wShingleSize = wNozzleCount / (WordType)4;
         }
         else
         {  /* 12% shingling */
            wShingleSize = wNozzleCount / (WordType)8;
         }

         lpxPFData->asdwDBIndx[FC_OUT][n] =
            -( lpxPFData->asdwDBIndx[INIT_DELAY][n] +
               (wNozzleCount - wShingleSize));

         lpxPFData->asdwDBIndx[FC_OUT_EVEN][n] =
            (lpxPFData->asdwDBIndx[FC_OUT][n] * 2 -
             (SwordType)(wShingleSize + wStepDiff));

         lpxPFData->asdwDBIndx[FC_OUT_ODD][n] =
            (SwordType)(lpxPFData->asdwDBIndx[FC_OUT][n]*2);
      }
   }


   if ( (lpxPFData->bColorPlanes == 4) &&
        (lpxPFData->bResolution == HIRES_INTERLACED) &&
        (lpxPFData->bShingle == SHINGLE_50) )
   {
      /* Note that FC_OUT_EVEN is adjusted by the Color Shingle Size and   */
      /* not Mono Shingle Size.  This is correct.                          */
      lpxPFData->asdwDBIndx[FC_OUT_EVEN][3] = (SwordType)
                                     ((lpxPFData->asdwDBIndx[FC_OUT][3]*2)-
                                     ((lpxPFData->wBaseNozzleCount/2) + 3));
   }
   else if ( (lpxPFData->bColorPlanes == 4) &&
        (lpxPFData->bResolution == HIRES_INTERLACED ||
        lpxPFData->bResolution == SHIRES_INTERLACED) &&
        (lpxPFData->bShingle == SHINGLE_25) )
   {
      /* Note that FC_OUT_EVEN is adjusted by the Color Shingle Size and   */
      /* not Mono Shingle Size.  This is correct.                          */
      lpxPFData->asdwDBIndx[FC_OUT_EVEN][3] = (SwordType)
                                     ((lpxPFData->asdwDBIndx[FC_OUT][3]*2)-
                                     ((lpxPFData->wBaseNozzleCount/4) + 3));
   }
   else if ( (lpxPFData->bColorPlanes == 4) &&
        (lpxPFData->bResolution == SHIRES_INTERLACED) &&
        (lpxPFData->bShingle == SHINGLE_12) )
   {
      /* Note that FC_OUT_EVEN is adjusted by the Color Shingle Size and   */
      /* not Mono Shingle Size.  This is correct.                          */
      lpxPFData->asdwDBIndx[FC_OUT_EVEN][3] = (SwordType)
                                     ((lpxPFData->asdwDBIndx[FC_OUT][3]*2)-
                                     ((lpxPFData->wBaseNozzleCount/8) +
                                      wStepDiff));
   }


   if (lpxPFData->bResolution == HIRES_INTERLACED ||
      lpxPFData->bResolution == SHIRES_INTERLACED)
   {
      if (lpxPFData->bShingle == NO_SHINGLE)
      {
         wShingleSize = lpxPFData->wBaseNozzleCount;
      }
      else if (lpxPFData->bShingle == SHINGLE_50)
      {
         wShingleSize = lpxPFData->wBaseNozzleCount / (WordType)2;
      }
      else if (lpxPFData->bShingle == SHINGLE_25)
      {
         wShingleSize = lpxPFData->wBaseNozzleCount / (WordType)4;
      }
      else
      {
         wShingleSize = lpxPFData->wBaseNozzleCount / (WordType)8;
      }


      /* HIRES */
      lpxPFData->sdwRowsToProcess = (SdwordType)(wShingleSize - wStepDiff);

      lpxPFData->swOut = FC_OUT_EVEN;
   }

   lpxPFData->aswDelayKSwath[FC_OUT] = 0;
   lpxPFData->aswDelayKSwath[FC_OUT_EVEN] = 0;
   lpxPFData->aswDelayKSwath[FC_OUT_ODD] = 0;

   for (n=(WordType)lpxPFData->swDelayBufStart;
        n<(WordType)lpxPFData->swDelayBufEnd; n++)
   {
      lpxPFData->asdwDBIndx[FC_OUT][n] = lCurrentRowPos;
   }

   return;

}  /* End of ResetBuffers() */


/***************************************************************************
 * Function Name:    FCOutputStrip
 *
 * Description:
 *    This is the interface function between the rest of the printer driver
 *    and the print formatter code.  It adds any necessary white space
 *    between the current raster line and the previous raster line.
 *    Calls ProcessRaster() to add the current raster line to the
 *    delay buffers.
 *
 * Inputs:  lpxDataRec     Long pointer to print device structure.
 *          lpbRasterLine  Long pointer to the raster line to be processed.
 *          dwStripStrart  The absolute vertical position of this raster
 *                         line on the page.  Begins at 0.
 *          swScanStart    The horizontal starting position of valid data
 *                         within the raster line.  Begin at 0.
 *                         When called with ScanStart > ScanEnd a blank
 *                         raster line will be generated.
 *          swScanEnd      The horizontal ending position of the valid
 *                         data within the raster line. nScanEnd points
 *                         one byte beyond the last good data byte.
 *
 * Outputs: Always returns 0
 *
 * Date: 09/27/96
 *
 *************************************************************************/
WordType EXPENTRY FAR FCOutputStrip(LPDVDATAREC lpxDataRec,
                                    LPByteType lpbRasterLine,
                                    SdwordType lStripStart,
                                    SwordType swScanStart,
                                    SwordType swScanEnd)
{
   LPPFDATA    lpxPFData;
   WordType    i;
   SdwordType  n, lRows, lTmp;
   SdwordType  lRowsMoved;
   SdwordType  lStripNum;
   SdwordType  lOutOfPhaseLines;
   SdwordType  lWhiteSkip;
   ByteType    bPlanes;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;
   lpxPFData->lpbInPtr = lpbRasterLine;

#if CPROF
   lpxPFData->TotalRasterLines++;
   lpxPFData->TotalRasterWidth += (swScanEnd - swScanStart);
#endif

   bPlanes = lpxPFData->bTotalPlanes;

#if defined(GEN_TEST_INPUT_FILES)
   {
      WordType wByteCount;

      for (i=0; i<4; i++)
      {
         lpxPFData->lpbExtendedRasterLine[i] = 'X';
      }
      lpxPFData->lpbExtendedRasterLine[4] = LOBYTE(LOWORD(lStripStart));
      lpxPFData->lpbExtendedRasterLine[5] = HIBYTE(LOWORD(lStripStart));
      lpxPFData->lpbExtendedRasterLine[6] = LOBYTE(swScanStart);
      lpxPFData->lpbExtendedRasterLine[7] = HIBYTE(swScanStart);
      lpxPFData->lpbExtendedRasterLine[8] = LOBYTE(swScanEnd);
      lpxPFData->lpbExtendedRasterLine[9] = HIBYTE(swScanEnd);

      wByteCount = (WordType)300 * lpxPFData->swRastResMult *
                   lpxPFData->bTotalPlanes;

      for (i=0; i<wByteCount; i++)
      {
         lpxPFData->lpbExtendedRasterLine[i+10] = lpbRasterLine[i];
      }

      SendRasters((void FAR *)lpxDataRec, lpxPFData->lpbExtendedRasterLine,
                  (wByteCount+10));
      return(0);  /* Return to drive without going thru formatter code */
   }
#endif

   if (lpxPFData->bResolution == SUPERLOWRES)
   {
      /* For the 7000 print head in draft mode convert from 300 to 600 dpi
         in the vertical direction. Raster line will be printed twice.    */
      lStripStart *= 2;
   }

   /* Align swScanStart to WordType boundary */
   if (swScanStart%2)
   {
      swScanStart--;

      for (i = 0;i < bPlanes; i++)
      {
         /* make sure the extra byte added is blank */
         lpbRasterLine[(i*lpxPFData->wBytesPerRow)+swScanStart] = 0x00;
      }
   }

   /* Align swScanEnd to WordType boundary */
   if (swScanEnd%2)
   {
      for (i = 0;i < bPlanes; i++)
      {
         /* make sure the extra byte added is blank */
         lpbRasterLine[(i*lpxPFData->wBytesPerRow)+swScanEnd] = 0x00;
      }
      swScanEnd++;
   }

   lRows = lStripStart - lpxPFData->sdwRowPos;

   /* Row number (vertical position down page) must always increase with
      each call.  */
   if (lRows < 0)
   {
      /* Return error. Row number less than last call. */
      return 1;
   }

   /* In the if() statement below, the +4 added to the skip amount         */
   /* calculation was added to account for high resolution "in phase"      */
   /* adjustments.  This means that for high resolution large vertical     */
   /* movements (600dpi for the 4076 based printers, and 1200dpi for the   */
   /* babbage based printers), the next raster line after the move must be */
   /* evenly divisible by 300.  The move is then "in phase".               */


   /* for mono single-pass(non-enevlope) printing, goto this control block
   lRows is the gap between next available non-blank line and current position*/
   if((lRows > 1) &&(lpxDataRec->bColorPlanes == 1)&&
      (lpxPFData->bEnvelopeSize != 1)&&(lpxPFData->bShingle == NO_SHINGLE))
   {

      lStripNum = lStripStart - (lRows-1);
      /* default---at top of page, don't need blank line, it is set in
      FcStartPage() */

      if(lpxPFData->swMoreBlankLine==1)
      {
         /*fill some blank lines to use the full height of the printer head*/
         for (n=0; n<(lRows-1); n++)
         {
            /* Add a blank raster line by making ScanStart > ScanEnd */
            lpxPFData->sdwRowPos++;
            ProcessRaster(lpxDataRec, lStripNum, lpxPFData->wBytesPerRow, 0);

            /*in PrintSwath(), if don't need blank line, set swMoreBlankLine=0,
            remember the current position lStripNum*/

            lStripNum++;

            if(lpxPFData->swMoreBlankLine == 0)
            {
               break; /*don't need fill blank line anymore, get out of loop*/
            }
         }
      }

      if(lpxPFData->swMoreBlankLine == 0)
      {
         lTmp = lStripStart - lStripNum;
         if(lTmp!=0)
         {
            /*add ot subtract some lines to adjust the move amount to be
            divisble by 4*/
            lOutOfPhaseLines = VerticalMoveInPhase(lpxDataRec, lStripStart);

            /*lStripNum is just a temporary varible, I use it to record the next
            position where top of printer head align up*/
            lStripNum = lStripStart - lOutOfPhaseLines;

            /* record the old Bottom nozzle, it will be used in other function
            PreSwathAdjust()*/
            lpxPFData->sdwBottomNozzleRowNum=lStripNum-1;

            /*don't reset the delay buffer which is not like conventional
            method. by doing this, we can save some lines in the delay buffer.
            Delay buffer is circular. We can always add new line as along as we
            record FC_IN, FC_OUT line number right*/

            lpxPFData->asdwDBIndx[FC_IN][0]=lStripNum;
            lpxPFData->asdwDBIndx[FC_OUT][0]=lStripNum;
            lpxPFData->asdwFirstRowOfSection[FC_OUT][0]=lStripNum;


            lpxPFData->sdwRasterLinesProcessed = 0;
            lpxPFData->sdwRowsToProcess =
               (SdwordType)lpxPFData->wBaseNozzleCount;
            /*record the swFuturFormsMovePending, which will be used in
            LineFeed() to move the printer head*/
            lpxPFData->swFutureFormsMovePending +=
               (SwordType)(lTmp -lOutOfPhaseLines);

            lpxPFData->sdwRowPos = lStripNum;
            for (n = 0; n < lOutOfPhaseLines; n++)
            {
               /*don't skip the outof phase lines, fill as blank lines by making
               starting position begger than the ending position*/
               ProcessRaster(lpxDataRec, lStripNum, lpxPFData->wBytesPerRow, 0);
               lStripNum++;
               lpxPFData->sdwRowPos++;
            }

         }
      }
   }
   else if (lRows>1)
   {
      if (lpxDataRec->bQuality == QUALITY_DRAFT)
      {  /* Do white space skip in draft mode when more than 256 blank rasters*/
         lWhiteSkip = (SdwordType)lpxPFData->swMaxDelayBuf;
      }
      else
      {
         lWhiteSkip = (SdwordType)(lpxPFData->swMaxDelayBuf+
                                   MONO_NOZZLE_COUNT + 4);
      }

      if (lRows <= lWhiteSkip)
      {  /* small whitespace skip, so just feed blank raster lines */
         lStripNum = lStripStart - (lRows-1);
         for (n=0; n<(lRows-1); n++)
         {
            /* Add a blank raster line by making ScanStart > ScanEnd */
            lpxPFData->sdwRowPos++;
            ProcessRaster(lpxDataRec, lStripNum, lpxPFData->wBytesPerRow, 0);
            lStripNum++;
         }
      }
      else
      {
         /* large whitespace skip, so flush buffers and then move             */
         /* lOutOfPhaseLines will be equal to 0, 1, 2, or 3.  And this is the */
         /* number of blank lines we need to send to ProcessRaster() before   */
         /* sending the lStripStart raster line.  These blank raster lines    */
         /* affect how much of a large skip vertical move we make, and this   */
         /* is how we are guaranteeing our moves to be "in phase".            */
         lOutOfPhaseLines = VerticalMoveInPhase(lpxDataRec, lStripStart);

         lRowsMoved = (SdwordType)FlushBuffers(lpxDataRec,MIDDLE_OF_PAGE);
         ResetBuffers((lStripStart - lOutOfPhaseLines), lpxDataRec);
         /* Calculate amount to move before 2nd swath is printed */
         lpxPFData->swFutureFormsMovePending +=
            (SwordType)((lRows - lRowsMoved - lOutOfPhaseLines - 1));

         /* now send the necessary blank lines which ensured the large        */
         /* vertical movement was "in phase".                                 */
         lStripNum = lStripStart - lOutOfPhaseLines;
         lpxPFData->sdwRowPos = lStripNum;
         for (n = 0; n < lOutOfPhaseLines; n++)
         {
            ProcessRaster(lpxDataRec, lStripNum, lpxPFData->wBytesPerRow, 0);
            lStripNum++;
            lpxPFData->sdwRowPos++;
         }
      }
   }

   /* now process the current raster line */
   lpxPFData->sdwRowPos = lStripStart;
   ProcessRaster(lpxDataRec, lStripStart, swScanStart, swScanEnd);
   lpxPFData->swMoreBlankLine = 1;

   if (lpxPFData->bResolution == SUPERLOWRES)
   {
      /* Send the raster line again for the 7000 print head in draft mode
         to generate 600 dpi in the vertical direction.  */
      lStripStart++;
      lpxPFData->sdwRowPos = lStripStart;
      ProcessRaster(lpxDataRec, lStripStart, swScanStart, swScanEnd);
   }

   return(0);

}  /* End of FCOutputStrip() */


/***************************************************************************
 * Description:
 *    Loads the correct shingle masks based on the number of color planes
 *    for this page, and the shingle mode requested.
 *
 * Inputs:  bNumPlanes     Number of color planes for this page.
 *          lpxPFData        Long pointer to our internal data structure.
 *
 * Outputs: initializes the shingle mask lpxPFData->alpwShingleMask[].
 *
 * Date: 09/27/96
 *
 *************************************************************************/
void LoadShingleMasks(LPDVDATAREC lpxDataRec, ByteType bNumPlanes)
{
   LPPFDATA    lpxPFData;
   SwordType   n, swNozCnt;
   ByteType    bSI;
   WordType    wNC;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   switch (bNumPlanes)
   {
   case 1 :
      if ((lpxPFData->bResolution == HIRES_INTERLACED) ||
          (lpxPFData->bResolution == HIRES_NONINTERLACED)||
          (lpxPFData->bResolution == SHIRES_INTERLACED) )
      {

         lpxPFData->swMonoNozzleCount  = COLOR_NOZZLE_COUNT;

      }
      else
      {
         lpxPFData->swMonoNozzleCount  = MONO_NOZZLE_COUNT;
      }
      swNozCnt = lpxPFData->swMonoNozzleCount;
      break;

   case 4 :

      lpxPFData->swMonoNozzleCount = COLOR_NOZZLE_COUNT;
      /* intentionally falling through to CMY case */

   case 3 :
   case 6 :
      lpxPFData->swColorNozzleCount = COLOR_NOZZLE_COUNT/3;
   }



   lpxPFData->alpwShingleMask[SHINGLE_MASK_50][0] = 0xAAAA;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_50][1] = 0x5555;

   lpxPFData->alpwShingleMask[SHINGLE_MASK_25][0] = 0x8888;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_25][1] = 0x4444;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_25][2] = 0x2222;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_25][3] = 0x1111;

   lpxPFData->alpwShingleMask[SHINGLE_MASK_33][0] = 0x9292;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_33][1] = 0x4949;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_33][2] = 0x2424;

   lpxPFData->alpwShingleMask[SHINGLE_MASK_16][0] = 0x8282;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_16][1] = 0x4141;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_16][2] = 0x2020;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_16][3] = 0x1010;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_16][4] = 0x0808;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_16][5] = 0x0404;

   lpxPFData->alpwShingleMask[SHINGLE_MASK_12][0] = 0x8080;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_12][1] = 0x4040;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_12][2] = 0x2020;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_12][3] = 0x1010;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_12][4] = 0x0808;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_12][5] = 0x0404;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_12][6] = 0x0202;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_12][7] = 0x0101;

   /* Each shingle pattern has a top range of the printhead portion it can */
   /* be printed with.  The top range will be from top nozzle down to a    */
   /* certain nozzle value.  Calculate and store these values.             */
   for (n=0;n<3;n++)
   {
      if (n==0)
      {
         bSI = COLOR;
         wNC = COLOR_NOZZLE_COUNT / 3;
      }
      else if (n==1)
      {
         bSI = MONO_FULL;
         wNC = MONO_NOZZLE_COUNT;
      }
      else
      {
         bSI = MONO_PART;
         wNC = COLOR_NOZZLE_COUNT;
      }

      lpxPFData->awShingleThreshold[bSI][SHINGLE_0_1]  = 0;

#if OPTION_VARIABLE_MONO_NOZZLES
      /* The following if() statement allows us to use a variable number   */
      /* of bottom black nozzles when printing envelopes.  This allows     */
      /* more drying time for the black ink.                               */
      if ( ((bSI == MONO_FULL) || (bSI == MONO_PART)) &&
           ((GetMonoNozzlesToUse(lpxDataRec)) != 0) )
      {
         lpxPFData->awShingleThreshold[bSI][SHINGLE_0_1]  =
                           wNC - (GetMonoNozzlesToUse(lpxDataRec));
      }
#endif

      lpxPFData->awShingleThreshold[bSI][SHINGLE_50_1] = wNC/2;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_50_2] = 0;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_25_1] = wNC - wNC/4;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_25_2] = wNC - 2*wNC/4;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_25_3] = wNC - 3*wNC/4;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_25_4] = 0;

      if (bSI == COLOR)
      {
         lpxPFData->awShingleThreshold[bSI][SHINGLE_33_1] = wNC -
                                             PCT33_COLOR_NOZZLES;
         lpxPFData->awShingleThreshold[bSI][SHINGLE_33_2] = wNC -
                                             2 * (PCT33_COLOR_NOZZLES);
      }
      else if (bSI == MONO_FULL)
      {
         lpxPFData->awShingleThreshold[bSI][SHINGLE_33_1] = wNC -
                                             PCT33_MONO_FULL_NOZZLES;
         lpxPFData->awShingleThreshold[bSI][SHINGLE_33_2] = wNC -
                                             (2 * PCT33_MONO_FULL_NOZZLES);
      }
      else
      {
         lpxPFData->awShingleThreshold[bSI][SHINGLE_33_1] = wNC - wNC/3;
         lpxPFData->awShingleThreshold[bSI][SHINGLE_33_2] = wNC - (2*(wNC/3));
      }

      lpxPFData->awShingleThreshold[bSI][SHINGLE_33_3] = 0;

      lpxPFData->awShingleThreshold[bSI][SHINGLE_16_1] = wNC - wNC/6;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_16_2] = wNC - 2*wNC/6;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_16_3] = wNC - 3*wNC/6;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_16_4] = wNC - 4*wNC/6;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_16_5] = wNC - 5*wNC/6;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_16_6] = 0;

      lpxPFData->awShingleThreshold[bSI][SHINGLE_12_1] = wNC - wNC/8;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_12_2] = wNC - 2*wNC/8;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_12_3] = wNC - 3*wNC/8;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_12_4] = wNC - 4*wNC/8;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_12_5] = wNC - 5*wNC/8;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_12_6] = wNC - 6*wNC/8;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_12_7] = wNC - 7*wNC/8;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_12_8] = 0;
   }

   return;
}   /* end of LoadShingleMask() */


/****************************************************************************
 * Function Name:    FCGetInkUsage
 *
 * Description:
 *    This is the interface function between the rest of the printer driver
 *    and the print formatter code.  It returns to the driver the dot count
 *    for all the inks.  The driver is responsible for accumulating and
 *    storing the dot counts.  The print formatter code dot counts are
 *    zeroed with each call.  This function must be called within calles to
 *    FCStartDoc/FCEndDoc because the dot count data structure is allocated
 *    in FCStartDoc.
 *
 * Inputs:  lpxDataRec    Long pointer to print device structure.
 *          lpDotCounts  Data structure for returning the dot counts
 *                       for 6 inks.
 *
 * Outputs: lpDotCounts  Dot counts for all 6 inks.
 *
 * Date: 01/18/97
 *
 ***************************************************************************/
void EXPENTRY FAR FCGetInkUsage( LPDVDATAREC lpxDataRec,
                                 LPDOTCOUNTS lpDotCounts)
{
   LPPFDATA    lpxPFData;
   SwordType   n;

   if   (lpxDataRec)
   {   /* non NULL lpxDataRec pointer */
      lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

      switch (lpxDataRec->bColorPlanes)
      {
      case 1 :
         lpDotCounts->sdwInk1 = lpxPFData->asdwDotCount[0];
         lpDotCounts->sdwInk2 = 0;
         lpDotCounts->sdwInk3 = 0;
         lpDotCounts->sdwInk4 = 0;
         lpDotCounts->sdwInk5 = 0;
         lpDotCounts->sdwInk6 = 0;
         break;

      case 3 :
         lpDotCounts->sdwInk1 = lpxPFData->asdwDotCount[0];
         lpDotCounts->sdwInk2 = lpxPFData->asdwDotCount[1];
         lpDotCounts->sdwInk3 = lpxPFData->asdwDotCount[2];
         lpDotCounts->sdwInk4 = 0;
         lpDotCounts->sdwInk5 = 0;
         lpDotCounts->sdwInk6 = 0;
         break;

      case 4 :
         lpDotCounts->sdwInk1 = lpxPFData->asdwDotCount[0];
         lpDotCounts->sdwInk2 = lpxPFData->asdwDotCount[1];
         lpDotCounts->sdwInk3 = lpxPFData->asdwDotCount[2];
         lpDotCounts->sdwInk4 = lpxPFData->asdwDotCount[3];
         lpDotCounts->sdwInk5 = 0;
         lpDotCounts->sdwInk6 = 0;
         break;

      case 6 :
         lpDotCounts->sdwInk1 = lpxPFData->asdwDotCount[0];
         lpDotCounts->sdwInk2 = lpxPFData->asdwDotCount[1];
         lpDotCounts->sdwInk3 = lpxPFData->asdwDotCount[2];
         lpDotCounts->sdwInk4 = lpxPFData->asdwDotCount[3];
         lpDotCounts->sdwInk5 = lpxPFData->asdwDotCount[4];
         lpDotCounts->sdwInk6 = lpxPFData->asdwDotCount[5];
         break;
      }  /* end of switch (lpxDataRec->bColorPlanes) */

      /* Now that ink usage has been reported, zero the counters. */
      for (n=0; n<6; n++)
      {
         lpxPFData->asdwDotCount[n] = 0;
      }

   }   /* end of non NULL lpxDataRec pointer */
   else
   {
      lpDotCounts->sdwInk1 = 0;
      lpDotCounts->sdwInk2 = 0;
      lpDotCounts->sdwInk3 = 0;
      lpDotCounts->sdwInk4 = 0;
      lpDotCounts->sdwInk5 = 0;
      lpDotCounts->sdwInk6 = 0;
   }

   return;

}   /* end of FCGetInkUsage() */


/****************************************************************************
 * Function Name:    FCGetResolution
 *
 * Description:
 *    This interface function returns the current page and raster resolution
 *    values.
 *
 * Inputs:  lpxDataRec           Long pointer to print device structure.
 *          lpbPageResolution    Page resolution is returned in this value.
 *          lpwRasterResolution  Raster line resolution is returned in this
 *                               value.
 *
 * Outputs: If successful, sets lpbPageResolution and lpwRasterResolution to
 *          the correct values and returns 1, i.e.
 *          lpbPageResolution    Possible return values are:
 *                                        SUPERLOWRES
 *                                        LORES
 *                                        HIRES_NONINTERLACED
 *                                        HIRES_INTERLACED
 *                                        SHIRES_INTERLACED
 *
 *          lpwRasterResolution  Possible return values are:
 *                                         300
 *                                         600
 *                                        1200
 *          If an error occurs, set lpbPageResolution and lpwRasterResolution
 *          to 0 and return 0.
 *
 * Date: 03/27/98
 *
 ***************************************************************************/
WordType EXPENTRY FAR FCGetResolution(LPDVDATAREC lpxDataRec,
                                      LPByteType lpbPageResolution,
                                      LPWordType lpwRasterResolution)
{
   LPPFDATA    lpxPFData;
   WordType    wRetCode;

   if   (lpxDataRec)
   {  /* lpxDataRec exists */
      lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;
      if (lpxPFData)
      {  /* lpxPFData exists */
         *lpbPageResolution   = lpxPFData->bResolution;
         *lpwRasterResolution = (lpxPFData->swRastResMult * (WordType)300);
         wRetCode = 1;
      }
      else
      {
         *lpbPageResolution   = 0;
         *lpwRasterResolution = 0;
         wRetCode = 0;
      }
   }
   else
   {
      *lpbPageResolution   = 0;
      *lpwRasterResolution = 0;
      wRetCode = 0;
   }

   return(wRetCode);

}  /* end of FCGetResolution() */


#if defined(THUNKBACK)
void FAR SendCommand32(void FAR * lpDevice, 
							  void FAR * lpfnCallback,
							  void FAR* pOutString, 
							  DWORD dwLength)
{

	unsigned char *dataPtr = (unsigned char *) pOutString;
	DWORD dataSize = dwLength;
	DWORD numChars;

	while ( dataSize > 0 )
	{
		numChars = min(0xFFFF, dataSize);
		
		SendCommand16(lpDevice, lpfnCallback,(void FAR *) dataPtr, numChars);
		
		dataSize -= numChars;
		dataPtr  += numChars;
	}
		
}

BOOL WINAPI thk_ThunkConnect32(  LPSTR     lpDll16,
                        LPSTR     lpDll32,
                        HINSTANCE hDllInst,
                        DWORD     dwReason);


BOOL APIENTRY DllMain( HANDLE hDllInst, 
                       DWORD  dwReason, 
                       LPVOID lpReserved)
{
   hInst=hDllInst;

   if (!thk_ThunkConnect32("lxahfctk.DLL", "lxfc32.DLL",
                             hDllInst, dwReason))
   {
            return FALSE;
   }

    switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
      case DLL_PROCESS_DETACH:
         break;
    }
    return TRUE;
}
#endif


