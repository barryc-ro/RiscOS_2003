
/****************************************************************************
 * LSOSAKA.C                                       Lexmark Confidential
 *
 * $Revision$
 * $Date$
 * $Author$
 *
 *
 * Description:
 *    LSOSAKA.C contains all the OSAKA/NAIROBI printer logic seek and maintenance
 *    functions.
 *
 *
 * No.   Date     Who  Function                       Description of Change
 * -----------------------------------------------------------------------------
 *
 *  020  03/23/00 jbb    PageInformationCmd()         Matching change with above
 *       change to send possibly different pinch point and TOF values for hagaki
 *       and envelopes.
 *
 *  021  03/23/00 jbb    LoadRampTable()              Changed Hagaki paper to
 *       use plain paper ramp table.
 *
 *  022  03/24/00 bd     none                  Removed support for Normal
 *       quality bidi printing.
 *
 *  023  03/24/00 jbb   LSProductReturns() and MaintenanceCmd()      Now sending
 *       an invalid command to printer after every spit command.  This is a
 *       workaround for a firmware bug.
 *
 *  024  03/31/00 bd    LoadRampTable() and LoadCarrierSteps()       Changed 
 *       Osaka so that different values can be used for TOF and Pinch Point.
 *       A different ramp table is now used for Envelope than for hagaki and 
 *       normal paper.
 *
 *  025  03/31/00 bd    LoadRampTable() and LoadCarrierSteps()       Changed
 *       Nairobi to use 'Envelope' ramp table for Hagaki and envelope, and
 *       changed Osaka to use 'Envelope' ramp table only for envelope.
 *
 *  026  04/07/00 bd     none                         Pick up new ramp files.
 *
 *  027  04/18/00 jbb    EjectPage()                  Increase eject length
 *       padding from 2 inches to 10 inches.  This is to help paper ejection
 *       when the printer double picks paper.
 *
 *  028  04/27/00 bd     LoadRampTable() and LoadCarrierSteps()      Added
 *       support for Aruba and Bermuda.
 *
 *  029  06/01/00  bd         Changed DIR_LAG_COMPENSATION for Nairobi/Bermuda
 *       in LSOSAKA.H.
 *
 *  030  07/07/00  bd         Changed mainteance values for Aruba/Bermuda in
 *       LSOSAKA.H
 *
 *  031  08/23/00  jbb  Changed Bermuda to cap heads before ejecting paper.
 *
 ******************************************************************************/




/************** Definitions & Macros ***************************************/

#define LS_VERSION  "LS_OS 1.27, 08-23-00"




/************** Include Files **********************************************/


#include "lsxface.h"


#if defined(FC_DOS_32) ||defined(FC_WIN32_DLL)
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#endif

#if !defined(FC_WIN_32) && !defined(FC_OS2) &&!defined(FC_WIN32_DLL)
#include <memory.h>
#endif

#if defined(FC_WIN_16)
#include <string.h>
#endif

#include "lsosaka.h"


#if defined(OSAKA)  || defined(ARUBA)
#include "lsosarmp.h"

#elif defined(NAIROBI) || defined(BERMUDA)
#include "lsnairmp.h"

#endif



/************** Global Variable Declarations **********************************/

static char ls_version[] = LS_VERSION; /* set object module ID */




/************** Prototype Definitions *****************************************/




/*******************************************************************************
 * Function Name:    AlphaDistance
 *
 * Description:
 *       This function returns the carrier distance, in 1/1200, for the
 *       requested ramps and/or alpha values and for the specified speed.  The
 *       possible values which can be requested are:
 *          ACCEL       acceleration ramp distance
 *          DECEL       deceleration ramp distance
 *          ALPHA_A     alpha distance for acceleration
 *          ALPHA_D     alpha distance for deceleration
 *       or any combination of these values.
 *
 * Inputs:  lpxLSXface  long pointer to hpc interface structure
 *          wSpeed      carrier speed to calculate acceleration distance for.
 *          bInclude    type of distances requested.
 *
 * Outputs: carrier distance, in 1/1200"
 *
 * Original Author: J. Bates
 * Date: 10/21/98
 *
 ******************************************************************************/
WordType AlphaDistance(LPLSINTFACE lpxLSXface, WordType wSpeed, ByteType bInclude)
{

   LPLSDATA       lpxLSData;
   SwordType      swAlphaDist=0;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   switch (wSpeed)
   {
   case SPEED_NORMAL :
   default           :
      if (bInclude & ACCEL)
      {
         swAlphaDist += (SwordType)lpxLSData->bAccelStepCntNormal;
      }
      if (bInclude & DECEL)
      {
         swAlphaDist += (SwordType)lpxLSData->bDecelStepCntNormal;
      }
      if (bInclude & ALPHA_A)
      {
         swAlphaDist += (SwordType)lpxLSData->bAlphaStepCntNormal;
      }
      if (bInclude & ALPHA_D)
      {
         swAlphaDist += (SwordType)lpxLSData->bDAlphaStepCntNormal;
      }
      break;
   case SPEED_FAST :
      if (bInclude & ACCEL)
      {
         swAlphaDist += (SwordType)lpxLSData->bAccelStepCntFast;
      }
      if (bInclude & DECEL)
      {
         swAlphaDist += (SwordType)lpxLSData->bDecelStepCntFast;
      }
      if (bInclude & ALPHA_A)
      {
         swAlphaDist += (SwordType)lpxLSData->bAlphaStepCntFast;
      }
      if (bInclude & ALPHA_D)
      {
         swAlphaDist += (SwordType)lpxLSData->bDAlphaStepCntFast;
      }
      break;
   case SPEED_SLOW :
      if (bInclude & ACCEL)
      {
         swAlphaDist += (SwordType)lpxLSData->bAccelStepCntSlow;
      }
      if (bInclude & DECEL)
      {
         swAlphaDist += (SwordType)lpxLSData->bDecelStepCntSlow;
      }
      if (bInclude & ALPHA_A)
      {
         swAlphaDist += (SwordType)lpxLSData->bAlphaStepCntSlow;
      }
      if (bInclude & ALPHA_D)
      {
         swAlphaDist += (SwordType)lpxLSData->bDAlphaStepCntSlow;
      }
      break;
   }  /* end of switch (wSpeed) */


   /* convert from carrier step resolution, 1/150", to 1/1200" */
   swAlphaDist *= RES1200_PER_STEP;


   return(swAlphaDist);

}  /* end of AlphaDistance() */



/*******************************************************************************
 * Function Name:    CalculateRICCarrierPosition
 *
 * Description:
 *    This function calculates the carrier move required, if any, by the Return
 *    Information Command to properly position the carrier for the next print
 *    swath.
 *
 * Inputs:  lpxLSXface           Long pointer to logic seek interface structure.
 *          swCurrCarrPos        Current carrier position, in 1200dpi
 *          swNextLeftPrintPos   The left print position for the next swath, in
 *                               1200dpi
 *          swNextRightPrintPos  The right print position for the next swath, in
 *                               1200dpi
 *          bNextPrintHead       Which printhead the next swath swath will use
 *          bNextPrintDir        The print direction for the next swath.  Note
 *                               that this value should only be LS_LTOR or
 *                               LS_RTOL.  It should never be LS_BIDI.
 *
 * Outputs: Initializes lpxLSData->bPosCarrDirection, lpxLSData->wPosCarrSpeed,
 *          and lpxLSData->wPosCarrStopPosition to the proper values for the
 *          carrier move amount of the Return Information Command.  If the
 *          carrier should not be moved by the Return Information Command, then
 *          set lpxLSData->wPosCarrSpeed = SPEED_STOPPED and
 *          lpxLSData->bPosCarrDirection = NO_DIRECTION.
 *
 * Original Author: J Bates
 * Date: 12/28/98
 *
 ******************************************************************************/
void CalculateRICCarrierPosition(LPLSINTFACE lpxLSXface,WordType wCurrCarrPos,
            SwordType swNextLeftPrintPos, SwordType swNextRightPrintPos,
            ByteType bNextPrinthead, ByteType bNextPrintDir)
{
   LPLSDATA       lpxLSData;
   WordType       wAccelDist,
                  wMinMoveFast,
                  wMinMoveNormal,
                  wMinimumMove,
                  wNextPrintStartPos,
                  wRICStopPos;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   /* assume initially that no move will be required to position carrier for  */
   /* printing                                                                */
   lpxLSData->bPosCarrDirection = NO_DIRECTION;
   lpxLSData->wPosCarrStopPosition = 0;
   lpxLSData->wPosCarrSpeed = SPEED_STOPPED;


   if (swNextRightPrintPos < swNextLeftPrintPos)
   {
      return;
   }


   /* Save the print speed : note that high and normal quality are printed at */
   /* same (normal) speed.  Slow speed is only used for carrier positioning   */
   if ( lpxLSXface->bPrintQuality == LS_QUALITY_HIGH || 
        lpxLSXface->bPrintQuality == LS_QUALITY_NORMAL )
   {
      lpxLSData->wPrtCarrSpeed = SPEED_NORMAL;
   }
   else  /* QUALITY_DRAFT */
   {
      lpxLSData->wPrtCarrSpeed = SPEED_FAST;
   }


   /* get accel distance for the specific print speed */
   wAccelDist = AlphaDistance( lpxLSXface, lpxLSData->wPrtCarrSpeed,
                               (ACCEL+ALPHA_A) );


   /* +8 is because we want to move at least 1 step more than the shortest    */
   /* move distance                                                           */
   wMinMoveFast   = AlphaDistance(lpxLSXface,SPEED_FAST,  ACCEL+DECEL)+8;
   wMinMoveNormal = AlphaDistance(lpxLSXface,SPEED_NORMAL,ACCEL+DECEL)+8;


   if (bNextPrintDir == LS_LTOR)
   {
      /* convert print positions from hbp relative position to carrier system */
      /* absolute position.                                                   */
      wNextPrintStartPos = PrintPos(lpxLSXface,bNextPrinthead,
                                    swNextLeftPrintPos,LS_LTOR);
      wRICStopPos        = wNextPrintStartPos - wAccelDist;

      if (wCurrCarrPos  > wRICStopPos)
      {
         /* we need to perform a RIC carrier move toward the maintenance      */
         /* station (RTOL) before printing this swath away from the           */
         /* maintenance station (LTOR).                                       */

         wMinimumMove = wCurrCarrPos - wRICStopPos;

         if (wMinimumMove >= wMinMoveFast)
         {  /* perform the RIC carrier move at FAST speed */
            lpxLSData->wPosCarrSpeed = SPEED_FAST;
         }
         else if (wMinimumMove >= wMinMoveNormal)
         {  /* perform the RIC carrier move at NORMAL speed */
            lpxLSData->wPosCarrSpeed = SPEED_NORMAL;
         }
         else if ((wCurrCarrPos-wMinMoveNormal) >= lpxLSData->wLeftPrintLimit)
         {  /* adjust the stop position so we can move at NORMAL speed */
            wRICStopPos = wCurrCarrPos - wMinMoveNormal;
            lpxLSData->wPosCarrSpeed = SPEED_NORMAL;
         }
         else
         {  /* the carrier is too close to the maintenance station to perform */
            /* a move even at normal speed.  So don't move the carrier        */
            /* at all, and the next call to LSSwathCmd() will first perform   */
            /* a couple of carrier moves to properly position the carrier for */
            /* printing.                                                      */
            lpxLSData->wPosCarrSpeed = SPEED_STOPPED;
         }
         
         if (lpxLSData->wPosCarrSpeed != SPEED_STOPPED)
         {
            lpxLSData->bPosCarrDirection     = LS_RTOL;
            lpxLSData->wPosCarrStopPosition  = wRICStopPos;
         }
      }
   }  /* end of if (bNextPrintDir == LS_LTOR) */
   else  /* bNextPrintDir = LS_RTOL */
   {
      /* convert print positions from hbp relative position to carrier system */
      /* absolute position.                                                   */
      wNextPrintStartPos = PrintPos(lpxLSXface,bNextPrinthead,
                                    swNextRightPrintPos,LS_RTOL);
      wRICStopPos        = wNextPrintStartPos + wAccelDist;

      if (wCurrCarrPos < wRICStopPos)
      {
         /* we need to perform a carrier move away from the maintenance       */
         /* station (LTOR) before printing this swath toward the              */
         /* maintenance station (RTOL).                                       */
      
         wMinimumMove = wRICStopPos - wCurrCarrPos;

         if ( (wCurrCarrPos+wMinimumMove) > lpxLSData->wRightPrintLimit )
         {  /* the carrier is too close to the right side of frame to perform */
            /* the move required.  So don't move the carrier at all, and the  */
            /* next call to LSSwathCmd() will first perform a couple of       */
            /* carrier moves to properly position the carrier for printing.   */
            lpxLSData->wPosCarrSpeed = SPEED_STOPPED;
         }
         else if (wMinimumMove >= wMinMoveFast)
         {
            lpxLSData->wPosCarrSpeed = SPEED_FAST;
         }
         else if (wMinimumMove >= wMinMoveNormal)
         {
            lpxLSData->wPosCarrSpeed = SPEED_NORMAL;
         }
         else if ((wCurrCarrPos+wMinMoveNormal) <= lpxLSData->wRightPrintLimit)
         {  /* adjust the stop position so we can move at NORMAL speed */
            wRICStopPos              = wCurrCarrPos + wMinMoveNormal;
            lpxLSData->wPosCarrSpeed = SPEED_NORMAL;
         }
         else
         {  /* the carrier is too close to the right side of frame to perform */
            /* a move even at normal speed.  So don't move the carrier        */
            /* at all, and the next call to LSSwathCmd() will first perform   */
            /* a couple of carrier moves to properly position the carrier for */
            /* printing.                                                      */
            lpxLSData->wPosCarrSpeed = SPEED_STOPPED;
         }
         
         if (lpxLSData->wPosCarrSpeed != SPEED_STOPPED)
         {
            lpxLSData->bPosCarrDirection     = LS_LTOR;
            lpxLSData->wPosCarrStopPosition  = wRICStopPos;
         }
      }
   }  /* end of bNextPrintDir== LS_RTOL */

   return;

}  /* end of CalculateRICCarrierPosition() */




/*******************************************************************************
 * Function Name:    CalcConstantSteps
 *
 * Description:
 *    This function takes the requested move amount (wStopPosition - 
 *    wStartPosition) and adjusts the move amount to make sure the move is in
 *    phase.  It then subtracts the appropriate accel and decel values from the
 *    move amount because the move amounts sent to the printer should not
 *    include accel and decel.  The last thing this function does is update our
 *    global variable lpxLSData->wCurrCarrPos with the correct carrier position
 *    after this move.
 *
 * Inputs:  lpxLSXface        Long pointer to logic seek interface structure.
 *          wStartPosition    The position of the carrier, in 1/1200, before
 *                            this move is applied.
 *          wStopPosition     The position the carrier should be in, in 1/1200,
 *                            after this move is applied.  Note that the carrier
 *                            stop position may be different than this value
 *                            because of phase control considerations.
 *          wSpeed            The required speed (SPEED_FAST, SPEED_NORMAL, or
 *                            SPEED_SLOW) for this carrier move.
 *          wDirection        The direction (LS_LTOR or LS_RTOL) for this
 *                            carrier move.
 *          wPhaseChangeLock  ????
 *                            
 * Outputs: Returns the number of carrier steps (in 1/150") to send to the
 *          printer for the required carrier move with phase adjustment taken
 *          into consideration.  Also updates the global variable
 *          lpxLSData->wCurrCarrPos with the correct carrier position after this
 *          move.
 *
 * Original Author: J Bates
 * Date: 12/28/98
 *
 ******************************************************************************/
WordType CalcConstantSteps(LPLSINTFACE lpxLSXface, LPWordType lpwCarrPos,
               WordType wStopPosition, WordType wSpeed,
               ByteType bCarrierDirection, ByteType bNextCarrierDirection)
{
   LPLSDATA       lpxLSData;
   WordType       wCarrierMove1200,
                  wCarrierSteps,
                  wPhase,
                  wPhaseAdjust,
                  wShortMoveDist;
   BoolType       fPhaseSwitch;


   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;


   /* Determine if the phase should be switched for the next swath. */
   if ( (lpxLSData->bPhase == LS_LTOR) && (bNextCarrierDirection == LS_RTOL) )
   {
      fPhaseSwitch = TRUE;
      lpxLSData->bPhase = LS_RTOL;
   }
   else if ((lpxLSData->bPhase ==LS_RTOL) && (bNextCarrierDirection ==LS_LTOR))
   {
      fPhaseSwitch = TRUE;
      lpxLSData->bPhase = LS_LTOR;
   }
   else
   {
      fPhaseSwitch = FALSE;
   }
   /* end of determining if a phase switch is required */


   /* calculate the requested distance, in 1/1200", for the carrier to move   */
   if (bCarrierDirection == LS_LTOR )
   {
      wCarrierMove1200 = wStopPosition - *lpwCarrPos;
   }
   else  /* direction == LS_RTOL */
   {
      wCarrierMove1200 = *lpwCarrPos  - wStopPosition;
   }

   wShortMoveDist = AlphaDistance(lpxLSXface,wSpeed,ACCEL+DECEL);
   if ( wCarrierMove1200 < (wShortMoveDist + ((WordType)RES1200_PER_STEP*16)) )
   {
      /* The shortest possible move is one full phase (16 1/150" steps)       */
      /* longer than accel/decel                                              */
      wCarrierMove1200 = wShortMoveDist + ((WordType)RES1200_PER_STEP*16);
   }


   /* Put the carrier move distance on a step boundary.  Remember that a step */
   /* is 1/150".  The  +(RES1200_PER_STEP-1) is so we always round up when    */
   /* dividing by RES1200_PER_STEP                                            */
   wCarrierMove1200 = ((wCarrierMove1200+(RES1200_PER_STEP-1))/RES1200_PER_STEP)
                      * RES1200_PER_STEP;



   /* Make sure carrier move is in phase, which means it must be on a 16 step */
   /* boundary if not doing a phase switch.  And it must be on a PHASE_CHANGE */
   /* boundary if doing a phase switch.                                       */

   wPhase = (wCarrierMove1200/RES1200_PER_STEP) % 16;

   if ( (fPhaseSwitch == FALSE) && (wPhase != 0) )
   {
      wPhaseAdjust  = 16 - wPhase;
      wCarrierMove1200 += wPhaseAdjust * RES1200_PER_STEP;
   }
   else if ( (fPhaseSwitch == TRUE) && (wPhase != PHASE_SHIFT_AMOUNT) )
   {
      if (wPhase < PHASE_SHIFT_AMOUNT)
      {
         wPhaseAdjust = PHASE_SHIFT_AMOUNT - wPhase;
      }
      else
      {
         wPhaseAdjust = 16 - wPhase + PHASE_SHIFT_AMOUNT;
      }
      wCarrierMove1200 += wPhaseAdjust * RES1200_PER_STEP;
   }
   /* end of phase control */


   /* Subtract accel/decel distance and convert from 1/1200" to 1/150".  The  */
   /* +(RES1200_PER_STEP-1) is so we always round up when dividing by         */
   /* RES1200_PER_STEP                                                        */
   wCarrierSteps = (wCarrierMove1200 - wShortMoveDist + (RES1200_PER_STEP - 1))
                   / RES1200_PER_STEP;

   /* calculate the new carrier position after this move has been completed */
   if(bCarrierDirection == LS_LTOR)
   {
      *lpwCarrPos += ((wCarrierSteps*RES1200_PER_STEP)+wShortMoveDist);
   }
   else
   {
      *lpwCarrPos -= ((wCarrierSteps*RES1200_PER_STEP)+wShortMoveDist);
   }

   return (wCarrierSteps);

}  /* end of CalcConstantSteps() */




/*******************************************************************************
 * Function Name:    CalculateAppendDistance
 *
 * Description:
 *    This function takes the current print swath stop position and determines
 *    if it should be extended to position the carrier correctly for the next
 *    swath to print.  All calculations are using 1/1200" units.  Note that
 *    LEFT/RIGHT and the carrier position increment/decrement is with respect to
 *    the page, not the printer ( page LEFT and RIGHT is reversed from printer
 *    LEFT and RIGHT).
 *
 *
 * Inputs:  lpxDataRec           Long pointer to print device structure.
 *          swNextLeftPrintPos   The left print position for the next swath to
 *                               be printed, in1200dpi
 *          swNextRightPrintPos  The right print position for the next swath to
 *                               be printed, in 1200dpi
 *          bNextPrintHead       Which printhead the next swath will use
 *          bPrintDir            The print direction for the current swath.  Note
 *                               that this value should only be LS_LTOR or
 *                               LS_RTOL.  It should never be LS_BIDI.
 *          bNextPrintDir        The print direction for the next swath.  Note
 *                               that this value should only be LS_LTOR or
 *                               LS_RTOL.  It should never be LS_BIDI.
 *
 * Outputs: None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 ******************************************************************************/
void CalculateAppendDistance(LPLSINTFACE lpxLSXface,
            SwordType swNextLeftPrintPos,SwordType swNextRightPrintPos,
            ByteType bNextPrinthead, ByteType bPrintDir, ByteType bNextPrintDir)
{
   LPLSDATA       lpxLSData;
   SwordType      swMaxAccelDist,
                  swNextCarrStartPos,
                  swNextPrintStartPos;


   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   if (swNextRightPrintPos < swNextLeftPrintPos)
   {  /* next swath is empty, so return without adding any append distance.   */
      return;
   }

   swMaxAccelDist = AlphaDistance(lpxLSXface, lpxLSData->wPrtCarrSpeed,
                                  (ACCEL+ALPHA_A));

   if ( (lpxLSData->fMaintenanceRequired == TRUE) && 
        (bPrintDir == LS_RTOL) )
   {  /* we need to perform maintenance, and this swath is printing toward    */
      /* the maintenance station.  So, if necessary, extend the carrier move  */
      /* so it will stop at the spit position.                                */
      if (lpxLSData->wPrtCarrStopPosition > lpxLSData->wSpitPosition)
      {
         lpxLSData->wPrtCarrStopPosition = lpxLSData->wSpitPosition;
      }
   }
   else if ( (bPrintDir == LS_LTOR) && (bNextPrintDir == LS_RTOL) )
   {  /* current swath prints away from maintenance station, or LTOR, and the */
      /* next swath will print toward the maintenance station, or RTOL.       */
      /* so let's make sure the carrier stops accel+alpha beyond where the    */
      /* next swath will start printing at.                                   */
      swNextPrintStartPos  = PrintPos(lpxLSXface,bNextPrinthead,
                                      swNextRightPrintPos,LS_RTOL);
      swNextCarrStartPos   = swNextPrintStartPos + swMaxAccelDist;
      if (swNextCarrStartPos > (SwordType) lpxLSData->wPrtCarrStopPosition)
      {
         lpxLSData->wPrtCarrStopPosition = (WordType)swNextCarrStartPos;
      }
   }
   else if ( (bPrintDir == LS_RTOL) && (bNextPrintDir == LS_LTOR) )
   {  /* current swath prints toward maintenance station, or RTOL, and the    */
      /* next swath will print away from the maintenance station, or   LTOR.  */
      /* So let's make sure the carrier stops accel+alpha beyond where the    */
      /* next swath will start printing at.                                   */
      swNextPrintStartPos  = PrintPos(lpxLSXface,bNextPrinthead,
                                      swNextLeftPrintPos,LS_LTOR);
      swNextCarrStartPos   = swNextPrintStartPos - swMaxAccelDist;
      if (swNextCarrStartPos < (SwordType) lpxLSData->wPrtCarrStopPosition)
      {
         lpxLSData->wPrtCarrStopPosition = (WordType)swNextCarrStartPos;
      }
   }

   return;

}  /* end of CalculateAppendDistance() */


/*******************************************************************************
 * Function Name:    CarrierMoveCmd
 *
 * Description:
 *    This function is called to send a command to the printer to perform a
 *    carrier position move. The carrier position kept by the driver is then
 *    updated to the new position.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 ******************************************************************************/
void CarrierMoveCmd (LPLSINTFACE lpxLSXface, ByteType bCarrierDirection,
                     ByteType bNextCarrierDirection)
{

   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;
   ByteType       bSpeed;       /* bSpeed is a bit-mask representation of the speed sent to firmware, as defined by CAR_MOVE_xx*/
   ByteType       bDir;
   ByteType       bInstl;
   WordType       wCarrPos,
                  wNumCarrStep;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   if (bCarrierDirection != NO_DIRECTION)
   {
      /* The carrier may be moved at speeds slower than currently used for    */
      /* printing (9ips), to position for spitting, cartridge installation,   */
      /* or beginning of the next print line.                                 */
      switch (lpxLSData->wPosCarrSpeed)
      {
      case SPEED_FAST :
         bSpeed = CARRIER_MOVE_FAST;
         break;
      case SPEED_NORMAL :
         bSpeed = CARRIER_MOVE_MEDIUM;
         break;
      case SPEED_SLOW :
      default         :
         bSpeed = CARRIER_MOVE_SLOW;
         break;
      }

      if (bCarrierDirection == LS_LTOR)
      {
         bDir = FORWARD_CAR;
      }
      else
      {
         bDir = REVERSE_CAR;
      }

      bInstl = 0x00;

      wCarrPos  = lpxLSData->wCurrCarrPos;
      wNumCarrStep = CalcConstantSteps(lpxLSXface, &wCarrPos,
                     lpxLSData->wPosCarrStopPosition, lpxLSData->wPosCarrSpeed,
                     bCarrierDirection, bNextCarrierDirection);
      lpxLSData->wCurrCarrPos = wCarrPos;


      lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
      lpbCmd[0] = CMD_START_BYTE;
      lpbCmd[1] = CARRIER_MOVE_CMD;
      lpbCmd[2] = (ByteType)(bSpeed | bDir | bInstl);
      lpbCmd[3] = HIBYTE(wNumCarrStep);
      lpbCmd[4] = LOBYTE(wNumCarrStep);
      lpbCmd[5] = 0;
      lpbCmd[6] = 0;
      lpbCmd[7] = Checksum(lpbCmd);
   
      lpxLSData->wCmdLength += COMMAND_SIZE;

   }  /* end of if (lpxLSData->bPosCarrDirection != NO_DIRECTION) */

   lpxLSData->bPosCarrDirection = NO_DIRECTION;
   lpxLSData->wPosCarrStopPosition = 0;
   lpxLSData->wPosCarrSpeed = SPEED_STOPPED;

   return;

}  /* end of CarrierMoveCmd() */




/*******************************************************************************
 * Function Name:    Checksum
 *
 * Description:
 *    Calculates the checksum for bytes 1-6 of the printer command pointed to by
 *    lpbCmd.  Byte 0 is not included in the checksum calculation.
 *
 * Inputs:  lpbCmd   Long pointer to a printer command.
 *
 * Outputs: Returns the low order byte of the checksum
 *
 * Original Author: L. Barkley
 * Date: 09/25/98
 *
 ******************************************************************************/
ByteType Checksum(LPByteType lpbCmd)
{
   ByteType       bN,
                  bChecksum = 0;

   for(bN=1; bN<7; bN++)
   {
      bChecksum += lpbCmd[bN];
   }

   return bChecksum;

}  /* end of Checksum() */




/*******************************************************************************
 * Function Name:    EjectPage
 *
 * Description:
 *    This function sends a page eject command to the printer.  Note that no
 *    action is taken by the printer unless paper has been loaded.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Eject Page printer command added to command queue.
 *
 * Original Author: J. Bates
 * Date: 06/25/98
 *
 ******************************************************************************/
void EjectPage(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;
   DwordType      dwRowPos;
   WordType       wEjectLength,
                  wPageLength;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   switch (lpxLSXface->bMediaSize)
   {
   default :
      wPageLength = lpxLSXface->wPageLength;
   
      /* get number of steps paper has already moved */
      dwRowPos = lpxLSData->dwPaperStepCount;

      wEjectLength = (WordType)(wPageLength - dwRowPos);

      /* add more steps (10inches) just to make sure paper is fully ejected.   */
      wEjectLength += 12000;
      break;
   case LS_PAPER_BANNER_A4     :
   case LS_PAPER_BANNER_LETTER :
   case LS_PAPER_CUSTOM_BANNER :
      /* when printing banners, the job comes through the hbp/hpc code as a   */
      /* one page print job.  This means the current row position can be a    */
      /* very large number.  So we are going to always send a 14 inch eject   */
      /* page amount.  We chose 14 inches because that is larger than the     */
      /* length of the letter size and A4 size banner papers we support.  The */
      /* paper eject motor may run a little longer than necessary, but the    */
      /* current page will be properly ejected.                               */
      wEjectLength = 16800;
      break;
   }


   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   lpbCmd[0] = CMD_START_BYTE;
   lpbCmd[1] = PAPER_EJECT_CMD;
   lpbCmd[2] = 0;
   if (lpxLSXface->fEnableJamDetect)
   {
      lpbCmd[2] |= DET_JAM_ENABLE;
   }
   lpbCmd[3] = HIBYTE(wEjectLength);
   lpbCmd[4] = LOBYTE(wEjectLength);
   lpbCmd[5] = 0;
   lpbCmd[6] = 0;
   lpbCmd[7] = Checksum(lpbCmd);

   lpxLSData->wCmdLength += COMMAND_SIZE;

   return;

}  /* end of EjectPage() */


/*******************************************************************************
 * Function Name:    EndPrintDataCmd
 *
 * Description:
 *    This function adds the End Print Data command to the command queue.  The
 *    End Print Data command is not used by the printer, but it is used by LCS
 *    to determine if a print job was terminated normally.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *
 * Outputs: none.
 *
 * Original Author: B. Douglas
 * Date: 07/21/99
 *
 ******************************************************************************/
void EndPrintDataCmd(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   lpbCmd[0] = CMD_START_BYTE;
   lpbCmd[1] = NULL_CMD;
   lpbCmd[2] = 0x82;
   lpbCmd[3] = 0;
   lpbCmd[4] = 0;
   lpbCmd[5] = 0;
   lpbCmd[6] = 0;
   lpbCmd[7] = Checksum(lpbCmd);

   lpxLSData->wCmdLength += COMMAND_SIZE;

   return;

}  /* end of EndPrintDataCmd() */

   
/*******************************************************************************
 * Function Name:    HPCFormFeed
 *
 * Description:
 *    This function sends a Formfeed command to the printer.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 ******************************************************************************/
void HPCFormFeed(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   lpbCmd[0] = CMD_START_BYTE;
   lpbCmd[1] = PAPER_LOAD_CMD;
   lpbCmd[3] = 0;
   if (lpxLSXface->bMediaSource == LS_MANUAL_FEED)
   {
      lpbCmd[2] = MANUAL_LOAD;
   }
   else
   {
      lpbCmd[2] = ASF_LOAD;
   }
   lpbCmd[4] = 0;
   lpbCmd[5] = 0;
   lpbCmd[6] = 0;
   lpbCmd[7] = Checksum(lpbCmd);

   lpxLSData->wCmdLength += COMMAND_SIZE;

   return;

}  /* end of HPCFormFeed() */




/*******************************************************************************
 * Function Name:    InitializeMaintenanceArrays
 *
 * Description:
 *    This function initializes the arrays used to keep track of the printhead
 *    maintenance required during a print job.  There are two types of
 *    information and decisions made: cartridge level and color level.
 *    Cartridge level information is stored in the double array adwCartridge[][].
 *    The first subscript is for the cartridge CMY, MONO, or KCM.  The second
 *    subscript is for a particular cartridge characteristic, such as
 *    IDLE_SPIT_COUNT, THOLD_WIPE_COUNT, etc.  The color level information is 
 *    stored in the triple array adwColor[][][].  This array holds all the
 *    dot counts and elapsed times for each color we must keep and use in the
 *    maintenance algorithms.  The first subscript is for the cartridge the
 *    color is in, ie CMY, MONO, or KCM.  The second subscript is for each color
 *    in a cartridge, so there are three choices for the second subscript, 0, 1,
 *    and 2.  Note that for the MONO cartridge only color 0 is ever used.  The
 *    third element is for a partriclar dot count, such as PRINT_DOTS,
 *    MAINT_DOTS, etc.
 *
 * Inputs:  lpxDataRec       Long pointer to print device structure.
 *
 * Outputs: No return value.
 *
 * Original Author: J. Bates
 * Date: 07/07/98
 *
 ******************************************************************************/
void InitializeMaintenanceArrays(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   ByteType       bN;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   lpxLSData->fMaintenanceRequired = FALSE;

   /* Initialize CMY cartridge and colors */
   lpxLSData->adwCartridge[CMY][THOLD_DOT_CNT]  = CMY_THOLD_DOT_CNT;
   lpxLSData->adwCartridge[CMY][THOLD_SPIT_CNT] = CMY_THOLD_SPIT_CNT;
   lpxLSData->adwCartridge[CMY][THOLD_WIPE_CNT] = CMY_THOLD_WIPE_CNT;
   lpxLSData->adwCartridge[CMY][IDLE_SPIT_CNT]  = CMY_IDLE_SPIT_CNT;
   lpxLSData->adwCartridge[CMY][IDLE_WIPE_CNT]  = 0L;
   lpxLSData->adwCartridge[CMY][MAX_IDLE_TIME]  = CMY_MAX_IDLE_TIME;
   lpxLSData->adwCartridge[CMY][LAST_SPIT_TIME] = 0L;
   for (bN=0; bN<3; bN++)
   {
      lpxLSData->adwColor[CMY][bN][PRINT_DOT_CNT]  = 0L;
      lpxLSData->adwColor[CMY][bN][MAINT_DOT_CNT]  = 0L;
      lpxLSData->adwColor[CMY][bN][IDLE_DOT_CNT]   = 0L;
   }


   /* Initialize MONO cartridge and colors */
   lpxLSData->adwCartridge[MONO][THOLD_DOT_CNT]  = MONO_THOLD_DOT_CNT;
   lpxLSData->adwCartridge[MONO][THOLD_SPIT_CNT] = MONO_THOLD_SPIT_CNT;
   lpxLSData->adwCartridge[MONO][THOLD_WIPE_CNT] = MONO_THOLD_WIPE_CNT;
   lpxLSData->adwCartridge[MONO][IDLE_SPIT_CNT]  = MONO_IDLE_SPIT_CNT;
   lpxLSData->adwCartridge[MONO][IDLE_WIPE_CNT]  = 0L;
   lpxLSData->adwCartridge[MONO][MAX_IDLE_TIME]  = MONO_MAX_IDLE_TIME;
   lpxLSData->adwCartridge[MONO][LAST_SPIT_TIME] = 0L;
   lpxLSData->adwColor[MONO][0][PRINT_DOT_CNT]   = 0L;
   lpxLSData->adwColor[MONO][0][MAINT_DOT_CNT]   = 0L;
   lpxLSData->adwColor[MONO][0][IDLE_DOT_CNT]    = 0L;


   /* Initialize KCM cartridge and colors */
   lpxLSData->adwCartridge[KCM][THOLD_DOT_CNT]  = KCM_THOLD_DOT_CNT;
   lpxLSData->adwCartridge[KCM][THOLD_SPIT_CNT] = KCM_THOLD_SPIT_CNT;
   lpxLSData->adwCartridge[KCM][THOLD_WIPE_CNT] = KCM_THOLD_WIPE_CNT;
   lpxLSData->adwCartridge[KCM][IDLE_SPIT_CNT]  = KCM_IDLE_SPIT_CNT;
   lpxLSData->adwCartridge[KCM][IDLE_WIPE_CNT]  = 0L;
   lpxLSData->adwCartridge[KCM][MAX_IDLE_TIME]  = KCM_MAX_IDLE_TIME;
   lpxLSData->adwCartridge[KCM][LAST_SPIT_TIME] = 0L;
   for (bN=0; bN<3; bN++)
   {
      lpxLSData->adwColor[KCM][bN][PRINT_DOT_CNT]  = 0L;
      lpxLSData->adwColor[KCM][bN][MAINT_DOT_CNT]  = 0L;
      lpxLSData->adwColor[KCM][bN][IDLE_DOT_CNT]   = 0L;
   }

   return;

}  /* end of InitializeMaintenanceArrays() */




/*******************************************************************************
 * Function Name:    Linefeed
 *
 * Description:
 *    This function adds a paper vertical move command to the command buffer.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *          wMoveAmount    vertical move amount, in 1200dpi.
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 ******************************************************************************/
void LineFeed(LPLSINTFACE lpxLSXface, DwordType dwMoveAmount)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;
   WordType       wMoveAmount;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   if (lpxLSData->dwVertMovePending != 0)
   {
      dwMoveAmount += lpxLSData->dwVertMovePending;
      lpxLSData->dwVertMovePending = 0;
   }

   if (dwMoveAmount == 0)
   {
      return;
   }

   /* keep track of where we are vertically on the page */
   lpxLSData->dwPaperStepCount += dwMoveAmount;

   while (dwMoveAmount)
   {
      if (dwMoveAmount > 0xFFFF)
      {
         if (dwMoveAmount < 0x1FFFE)
         {
            wMoveAmount = (WordType)(dwMoveAmount/2);
         }
         else
         {
            wMoveAmount = 0xFFFF;
         }
         dwMoveAmount -= wMoveAmount;
      }
      else
      {
         wMoveAmount  = (WordType)dwMoveAmount;
         dwMoveAmount = 0;
      }

      lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
      lpbCmd[0] = CMD_START_BYTE;
      lpbCmd[1] = PAPER_FEED_CMD;
      lpbCmd[2] = (PAPER_FORWARD | PAPER_NORMAL_SPEED);
      lpbCmd[3] = HIBYTE(wMoveAmount);
      lpbCmd[4] = LOBYTE(wMoveAmount);
      lpbCmd[5] = 0;
      lpbCmd[6] = 0;
      lpbCmd[7] = Checksum(lpbCmd);
   
      lpxLSData->wCmdLength += COMMAND_SIZE;
   }

   return;

}  /* end of LineFeed() */




SdwordType llabs(SdwordType n)
{
   if (n < 0)
   {
      return(n*(-1));
   }
   else
   {
      return(n);
   }

}  /* end of llabs() */




SwordType lnabs(SwordType n)
{
   if (n < 0)
   {
      return(n*(SwordType)(-1));
   }
   else
   {
      return(n);
   }

}  /* end of lnabs() */




/*******************************************************************************
 * Function Name:    LoadCarrierDistances
 *
 * Description:
 *    This function initializes the lpxLSData structure elements which
 *    characterize the mechanical distances of the printer carrier system.  It
 *    reads these values from file "carrdist.bin" if the file exists and has
 *    enough bytes.  Otherwise these variables are initialized with constants.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: none.
 *
 * Original Author: J. Bates
 * Date: 07/23/98
 *
 ******************************************************************************/
void LoadCarrierDistances(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   LPWordType     lpwCarrierMeasures;

                  /* I realize I am allocating 14 words when I only need 7    */
                  /* words for each of the next two arrays.                   */
   WordType       awCarrierMechConst[CARRIER_MECH_DATA_SIZE],
                  awCarrierMechData[CARRIER_MECH_DATA_SIZE];


   BoolType       fValidCarrierDataFile;
#if 0    /* remove ability to override driver's ramp table data */
//#if defined(FC_WIN_16) || defined(FC_DOS_32)
   HFILE          flCarrierDataFile;
   OFSTRUCT       xFileInfo;
   OFSTRUCT FAR * lpxFileInfo;
   WordType       wRetCode;

                  /* now here I need 14 bytes */
   ByteType       abInputData[CARRIER_MECH_DATA_SIZE],
                  bN;
#endif

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   /* populate carrier measurements array with the constant values */
   awCarrierMechConst[0]  = RAMP_TABLE_ADDRESS_OFFSET;
   awCarrierMechConst[1]  = MAX_CARRIER_TRAVEL_DIST;
   awCarrierMechConst[2]  = SPIT_POSITION;
   awCarrierMechConst[3]  = LEFT_PAPER_EDGE;
   awCarrierMechConst[4]  = MONO_POS_OFFSET;
   awCarrierMechConst[5]  = COLOR_POS_OFFSET;
   awCarrierMechConst[6]  = LEFT_PRINT_LIMIT;


#if 1    /* remove ability to override driver's ramp table data */
//#if defined(FC_WIN_32) /*|| defined(FC_DOS_32)*/
   /* Windows NT drivers run in kernal mode, which means they don't have      */
   /* access to file i/o.                                                     */
   fValidCarrierDataFile = FALSE;
#else
   lpxFileInfo = &xFileInfo;
   flCarrierDataFile = OpenFile("carrdist.car",lpxFileInfo,OF_READ);

   if (flCarrierDataFile == HFILE_ERROR)
   {  
      /* can't find the carrier measurements data file                        */
      fValidCarrierDataFile = FALSE;
   }
   else
   {  /* read carrier measurements data file */
      wRetCode = (WordType) _lread( flCarrierDataFile, abInputData, 
                                    CARRIER_MECH_DATA_SIZE );
      if (wRetCode != CARRIER_MECH_DATA_SIZE)
      {
         fValidCarrierDataFile = FALSE;
      }
      else
      {
         fValidCarrierDataFile = TRUE;
         for (bN=0; bN<7; bN++)
         {
            awCarrierMechData[bN] = ((WordType)abInputData[(bN*2)] << 8) +
                                    (WordType)abInputData[(bN*2)+1];
         }
      }
      _lclose(flCarrierDataFile);
   }  /* end of reading carrier measurements data file */
#endif


   if (fValidCarrierDataFile == TRUE)
   {
      /* we were able to read the carrier data from the input file, so  use   */
      /* those values.                                                        */
      lpwCarrierMeasures = awCarrierMechData;
   }
   else
   {
      lpwCarrierMeasures = awCarrierMechConst;
   }


   /* now initialize lpxLSData variables with the carrier measurements values */
   lpxLSData->bRampTableAddressOffset = (ByteType) (lpwCarrierMeasures[0]);
   lpxLSData->wMaxCarrierTravelDist   = lpwCarrierMeasures[1];
   lpxLSData->wSpitPosition           = lpwCarrierMeasures[2] +
                                        LEFT_SIDE_FRAME_POSITION;
   lpxLSData->wLeftPaperEdge          = lpwCarrierMeasures[3] +
                                        LEFT_SIDE_FRAME_POSITION;
   lpxLSData->wMonoPosOffset          = lpwCarrierMeasures[4];
   lpxLSData->wColorPosOffset         = lpwCarrierMeasures[5];
   lpxLSData->wLeftPrintLimit         = lpwCarrierMeasures[6] +
                                        LEFT_SIDE_FRAME_POSITION;
   lpxLSData->wRightPrintLimit        = lpxLSData->wMaxCarrierTravelDist +
                                        LEFT_SIDE_FRAME_POSITION;

   return;

}  /* end of LoadCarrierDistances() */




/*******************************************************************************
 * Function Name:    LoadCarrierSteps
 *
 * Description:
 *    This function initializes the carrier step values by either reading them
 *    from an input binary file if it exists and has enough data bytes, or from
 *    constant values.  These values are used in the logic seek code.  They are
 *    also sent to the printer in the ramp download command.
 *
 * Inputs:  lpxLSXface  Long pointer to print device structure.
 *
 * Outputs: none.
 *
 * Original Author: J. Bates
 * Date: 07/23/98
 *
 ******************************************************************************/
void LoadCarrierSteps(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCarrierSteps=NULL;
   ByteType       bN;
   LPByteType     lpbCarrierData;
   LPByteType     lpbRampData;
   BoolType       fValidCarrierStepFile;

#if 0    /* remove ability to override driver's ramp table data */
//#if defined(FC_WIN_16) || defined(FC_DOS_32)
   HFILE          flCarrierDataFile;
   OFSTRUCT       xFileInfo;
   OFSTRUCT FAR * lpxFileInfo;
   WordType       wRetCode;
#endif

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;


#if 1    /* remove ability to override driver's ramp table data */
//#if defined(FC_WIN_32) /* || defined(FC_DOS_32) */
   /* Windows NT drivers run in kernal mode, which means we don't have        */
   /* access to file i/o.  Since we can't read the carrier step data, we will */
   /* stay with the constant values.                                          */
   fValidCarrierStepFile = FALSE;
#else
   lpxFileInfo = &xFileInfo;


#if defined(OSAKA) || defined(ARUBA)
   flCarrierDataFile = OpenFile("osaka.rmp", lpxFileInfo,OF_READ);
#else
   flCarrierDataFile = OpenFile("nairobi.rmp",lpxFileInfo,OF_READ);
#endif

  lpbCarrierData = ALLOCATE_MEMORY(RAMP_DATA_SIZE);

   if (flCarrierDataFile == HFILE_ERROR)
   {  
      /* can't find the carrier step data file, so don't try to read it.      */

      fValidCarrierStepFile = FALSE;
   }                                                              
   else
   {  /* read carrier step file */
   
      wRetCode = (WordType) _lread( flCarrierDataFile,lpbCarrierData,
                                    RAMP_DATA_SIZE);
      if ( wRetCode == RAMP_DATA_SIZE )
      {
         fValidCarrierStepFile = TRUE;
      }
      else
      {
         /* there was not CARRIER_STEP_DATA_SIZE bytes in the carrier step data  */
         /* file.  This file must be corrupt, so don't use it.                   */
         fValidCarrierStepFile = FALSE;
      }
      _lclose(flCarrierDataFile);

   }  /* end of reading carrier step file */
#endif

   lpbCarrierSteps = ALLOCATE_MEMORY(sizeof(ByteType) * CARRIER_STEP_DATA_SIZE);

   if (fValidCarrierStepFile == TRUE)
   {
      /* we were able to read the carrier step values from the input file, so */
      /* use their values.                                                    */

      lpbCarrierSteps[0]  = lpbCarrierData[0x0004];   /* Accel Slow      */
      lpbCarrierSteps[1]  = 0;                        /* Alpha Slow      */
      lpbCarrierSteps[2]  = lpbCarrierData[0x0005];   /* Decel Slow      */
      lpbCarrierSteps[3]  = lpbCarrierData[0x0002];   /* Accel Normal    */
      lpbCarrierSteps[4]  = 0;                        /* Alpha Normal    */
      lpbCarrierSteps[5]  = lpbCarrierData[0x0003];   /* Decel Normal    */
      lpbCarrierSteps[6]  = lpbCarrierData[0x0000];   /* Accel Fast      */
      lpbCarrierSteps[7]  = 0;                        /* Alpha Fast      */
      lpbCarrierSteps[8]  = lpbCarrierData[0x0001];   /* Decel Fast      */
      lpbCarrierSteps[9]  = lpbCarrierData[0x0006];   /* Reserved        */
      lpbCarrierSteps[10] = 0;                        /* Reserved        */
      lpbCarrierSteps[11] = lpbCarrierData[0x0007];   /* Reserved        */
      lpbCarrierSteps[12] = lpbCarrierData[0x1010];   /* Plain PP HO     */
      lpbCarrierSteps[13] = lpbCarrierData[0x1011];   /* Plain PP LO     */
      lpbCarrierSteps[14] = lpbCarrierData[0x1012];   /* Plain TOF HO    */
      lpbCarrierSteps[15] = lpbCarrierData[0x1013];   /* Plain TOF LO    */
      lpbCarrierSteps[16] = lpbCarrierData[0x1014];   /* Hagaki PP HO    */
      lpbCarrierSteps[17] = lpbCarrierData[0x1015];   /* Hagaki PP LO    */
      lpbCarrierSteps[18] = lpbCarrierData[0x1016];   /* Hagaki TOF HO   */
      lpbCarrierSteps[19] = lpbCarrierData[0x1017];   /* Hagaki TOF LO   */
      lpbCarrierSteps[20] = lpbCarrierData[0x1018];   /* Reserved        */
      lpbCarrierSteps[21] = lpbCarrierData[0x1019];   /* Reserved        */
      lpbCarrierSteps[22] = lpbCarrierData[0x101A];   /* Reserved        */
      lpbCarrierSteps[23] = lpbCarrierData[0x101B];   /* Reserved        */

   }
   else
   {

      /* Nairoibi and Osaka now have two different ramps.  Nairobi uses the   */
     /* same ramp for hagaki and envelopes, and another ramp for everything  */
     /* else.  Osaka uses one ramp for envelopes, and another ramp for Hagaki*/
     /* and everything else.                                                 */
#if defined(NAIROBI) || defined(BERMUDA)
      switch (lpxLSXface->bMediaSize)
      {
      case LS_PAPER_OHFHAGAKI   :
      case LS_PAPER_HAGAKI      :
      case LS_ENVELOPE_MONARCH  :
      case LS_ENVELOPE_9        :
      case LS_ENVELOPE_10       :
      case LS_ENVELOPE_DL       :
      case LS_ENVELOPE_C5       :
      case LS_ENVELOPE_B5       :
      case LS_ENVELOPE_C6       :
      case LS_ENVELOPE_D5       :
      case LS_ENVELOPE_75       :
      case LS_ENVELOPE_BARONIAL :
      case LS_ENVELOPE_6_3_4    :
      case LS_JPNLONG3          :
      case LS_JPNSQUARE4        :
      case LS_JPNSQUARE5        :
      case LS_JPNSQUARE6        :
         lpbRampData = RAMP_TABLE_DATA_ENV;
         break;
      default                   :
         lpbRampData = RAMP_TABLE_DATA;
         break;
      }
#else /* OSAKA */
      switch (lpxLSXface->bMediaSize)
      {
      case LS_ENVELOPE_MONARCH  :
      case LS_ENVELOPE_9        :
      case LS_ENVELOPE_10       :
      case LS_ENVELOPE_DL       :
      case LS_ENVELOPE_C5       :
      case LS_ENVELOPE_B5       :
      case LS_ENVELOPE_C6       :
      case LS_ENVELOPE_D5       :
      case LS_ENVELOPE_75       :
      case LS_ENVELOPE_BARONIAL :
      case LS_ENVELOPE_6_3_4    :
      case LS_JPNLONG3          :
      case LS_JPNSQUARE4        :
      case LS_JPNSQUARE5        :
      case LS_JPNSQUARE6        :
         lpbRampData = RAMP_TABLE_DATA_ENV;
         break;
      default                   :
         lpbRampData = RAMP_TABLE_DATA;
         break;
      }
#endif
      /* use constant carrier step values */

      lpbCarrierSteps[0]  = lpbRampData[0x0004];      /* Accel Slow        */
      lpbCarrierSteps[1]  = 0;                        /* Alpha Slow        */
      lpbCarrierSteps[2]  = lpbRampData[0x0005];      /* Decel Slow        */
      lpbCarrierSteps[3]  = lpbRampData[0x0002];      /* Accel Normal      */
      lpbCarrierSteps[4]  = 0;                        /* Alpha Normal      */
      lpbCarrierSteps[5]  = lpbRampData[0x0003];      /* Decel Normal      */
      lpbCarrierSteps[6]  = lpbRampData[0x0000];      /* Accel Fast        */
      lpbCarrierSteps[7]  = 0;                        /* Alpha Fast        */
      lpbCarrierSteps[8]  = lpbRampData[0x0001];      /* Decel Fast        */
      lpbCarrierSteps[9]  = lpbRampData[0x0006];      /* Reserved          */
      lpbCarrierSteps[10] = 0;                        /* Reserved          */
      lpbCarrierSteps[11] = lpbRampData[0x0007];      /* Reserved          */
      lpbCarrierSteps[12] = lpbRampData[0x1010];      /* Plain PP HI (also called skew)     */
      lpbCarrierSteps[13] = lpbRampData[0x1011];      /* Plain PP LO       */
      lpbCarrierSteps[14] = lpbRampData[0x1012];      /* Plain TOF HI      */
      lpbCarrierSteps[15] = lpbRampData[0x1013];      /* Plain TOF LO      */
      lpbCarrierSteps[16] = lpbRampData[0x1014];      /* Hagaki PP HI      */
      lpbCarrierSteps[17] = lpbRampData[0x1015];      /* Hagaki PP LO      */
      lpbCarrierSteps[18] = lpbRampData[0x1016];      /* Hagaki TOF HI     */
      lpbCarrierSteps[19] = lpbRampData[0x1017];      /* Hagaki TOF LO     */
      lpbCarrierSteps[20] = lpbRampData[0x1018];      /* Envelope PP HI    */
      lpbCarrierSteps[21] = lpbRampData[0x1019];      /* Envelope PP LO    */
      lpbCarrierSteps[22] = lpbRampData[0x101A];      /* Envelope TOF HI   */
      lpbCarrierSteps[23] = lpbRampData[0x101B];      /* Envelope TOF LO   */
   }

   /* now initialize hpc carrier step variables */
   lpxLSData->bAccelStepCntSlow   = lpbCarrierSteps[0];
   lpxLSData->bAlphaStepCntSlow   = lpbCarrierSteps[1];
   lpxLSData->bDecelStepCntSlow   = lpbCarrierSteps[2];

   lpxLSData->bAccelStepCntNormal = lpbCarrierSteps[3];
   lpxLSData->bAlphaStepCntNormal = lpbCarrierSteps[4];
   lpxLSData->bDecelStepCntNormal = lpbCarrierSteps[5];

   lpxLSData->bAccelStepCntFast   = lpbCarrierSteps[6];
   lpxLSData->bAlphaStepCntFast   = lpbCarrierSteps[7];
   lpxLSData->bDecelStepCntFast   = lpbCarrierSteps[8];

   lpxLSData->wPinchPointLetter   = ((WordType)lpbCarrierSteps[12] << 8) +
                                    lpbCarrierSteps[13];

   lpxLSData->wTopOfFormLetter    = ((WordType)lpbCarrierSteps[14] << 8) +
                                    lpbCarrierSteps[15];

   lpxLSData->wPinchPointHagaki   = ((WordType)lpbCarrierSteps[16] << 8) +
                                    lpbCarrierSteps[17];

   lpxLSData->wTopOfFormHagaki    = ((WordType)lpbCarrierSteps[18] << 8) +
                                    lpbCarrierSteps[19];

   /* for Nairobi and Osaka, Funai changed the envelope pinch point (skew)    */
   /* and TOF to be different than Hagaki.  They did this by using the        */
   /* reserved pinch  point and TOF values for envelopes.                     */
   lpxLSData->wPinchPointEnvelope = ((WordType)lpbCarrierSteps[20] << 8) +
                                    lpbCarrierSteps[21];

   lpxLSData->wTopOfFormEnvelope  = ((WordType)lpbCarrierSteps[22] << 8) +
                                    lpbCarrierSteps[23];

   /* now store carrier step values in the lpxLSData->abCarrierSteps[] array  */
   /* so they can be sent to the printer on a page boundary                   */
   for (bN=0; bN<CARRIER_STEP_DATA_SIZE; bN++)
   {
      lpxLSData->abCarrierStepData[bN] = lpbCarrierSteps[bN];
   }

   /* Osaka/Nairobi do not use an alpha deceleration amount, so set the alpha decel */
   /* values to 0.                                                            */
   lpxLSData->bDAlphaStepCntSlow   = 0;
   lpxLSData->bDAlphaStepCntNormal = 0;
   lpxLSData->bDAlphaStepCntFast   = 0;

#if 0    /* remove ability to override driver's ramp table data */
   FREE_MEMORY(lpbCarrierData);
#endif
   FREE_MEMORY(lpbCarrierSteps);      

   return;

}  /* end of LoadCarrierSteps() */




/*******************************************************************************
 * Function Name:    LoadRampTable
 *
 * Description:
 *    This function initializes the lpxLSData->abRampData array from input file
 *    "ramp.bin" if it exists and is large enough, or from the constant array
 *    PAPER_RAMP_TABLE_DATA[].
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: none.
 *
 * Original Author: J. Bates
 * Date: 07/23/98
 *
 ******************************************************************************/
void LoadRampTable(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbRampData;
   WordType       wN;
   BoolType       fValidRampDataFile;
#if 0    /* remove ability to override driver's ramp table data */
//#if defined(FC_WIN_16) || defined(FC_DOS_32)
   HFILE           flRampDataFile;
   OFSTRUCT       xFileInfo;
   OFSTRUCT FAR * lpxFileInfo;
   WordType       wRetCode;
#endif

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   /* read the ramp table information */
#if 1    /* remove ability to override driver's ramp table data */
//#if defined(FC_WIN_32) /* || defined(FC_DOS_32)  */
   /* Windows NT drivers run in kernal mode, which means they don't have      */
   /* access to file i/o.                                                     */
   fValidRampDataFile = FALSE;
#else
   lpxFileInfo = &xFileInfo;

#if defined(OSAKA) || defined(ARUBA)
   flRampDataFile = OpenFile("osaka.rmp",  lpxFileInfo,OF_READ);
#elif defined(NAIROBI) || defined(BERMUDA)
   flRampDataFile = OpenFile("nairobi.rmp",lpxFileInfo,OF_READ);
#endif /* OSAKA or NAIROBI definition */


   if (flRampDataFile == HFILE_ERROR)
   {  
      /* can't find the ramp data file                             */
      fValidRampDataFile = FALSE;
   }
   else
   {  /* read ramp data file */
      wRetCode  = (WordType) _lread( flRampDataFile,lpxLSData->abRampData,
                                    RAMP_DATA_SIZE );

      if (wRetCode != RAMP_DATA_SIZE) 
      {
         /* there was not (PAPER_RAMP_DATA_SIZE + CARRIER_RAMP_DATA_SIZE) bytes */
       /* in the ramp data file. This file must be corrupt, so don't trust    */
       /* its values.                                                         */
         fValidRampDataFile = FALSE;
      }
      else
      {
         fValidRampDataFile = TRUE;
      }



      _lclose(flRampDataFile);
   }  /* end of reading ramp data file */
#endif /* (FC_WIN_32) || (FC_DOS_32) */
   if (fValidRampDataFile == FALSE)
   {

      /* we were not able to read the ramp data from the input file, so  use  */
      /* the constant ramp data.                                              */

      /* We are given one file that contains both the carrier ramp table and  */
      /* the feed ramp table data. The lower portion contains the carrier     */
      /* ramp table, and the upper portion contains the feed ramp table.      */

      /* Nairoibi and Osaka now have two different ramps.  Nairobi uses the   */
     /* same ramp for hagaki and envelopes, and another ramp for everything  */
     /* else.  Osaka uses one ramp for envelopes, and another ramp for Hagaki*/
     /* and everything else.                                                 */

#if defined(NAIROBI) || defined(BERMUDA)
     switch (lpxLSXface->bMediaSize)
      {
      case LS_PAPER_OHFHAGAKI   :
      case LS_PAPER_HAGAKI      :
      case LS_ENVELOPE_MONARCH  :
      case LS_ENVELOPE_9        :
      case LS_ENVELOPE_10       :
      case LS_ENVELOPE_DL       :
      case LS_ENVELOPE_C5       :
      case LS_ENVELOPE_B5       :
      case LS_ENVELOPE_C6       :
      case LS_ENVELOPE_D5       :
      case LS_ENVELOPE_75       :
      case LS_ENVELOPE_BARONIAL :
      case LS_ENVELOPE_6_3_4    :
      case LS_JPNLONG3          :
      case LS_JPNSQUARE4        :
      case LS_JPNSQUARE5        :
      case LS_JPNSQUARE6        :
         lpbRampData = RAMP_TABLE_DATA_ENV;
         break;
      default                   :
         lpbRampData = RAMP_TABLE_DATA;
         break;
      }
#else /* for OSAKA */
     switch (lpxLSXface->bMediaSize)
      {
      case LS_ENVELOPE_MONARCH  :
      case LS_ENVELOPE_9        :
      case LS_ENVELOPE_10       :
      case LS_ENVELOPE_DL       :
      case LS_ENVELOPE_C5       :
      case LS_ENVELOPE_B5       :
      case LS_ENVELOPE_C6       :
      case LS_ENVELOPE_D5       :
      case LS_ENVELOPE_75       :
      case LS_ENVELOPE_BARONIAL :
      case LS_ENVELOPE_6_3_4    :
      case LS_JPNLONG3          :
      case LS_JPNSQUARE4        :
      case LS_JPNSQUARE5        :
      case LS_JPNSQUARE6        :
         lpbRampData = RAMP_TABLE_DATA_ENV;
         break;
      default                   :
         lpbRampData = RAMP_TABLE_DATA;
         break;
      }
#endif

      for (wN=0; wN<RAMP_DATA_SIZE; wN++)
      {
         lpxLSData->abRampData[wN] = lpbRampData[wN];
      }
   }
   /* end of reading the paper ramp table */

   return;

}  /* end of LoadRampTable() */




/*******************************************************************************
 * Function Name:    LSGetSwathDirection
 *
 * Description:
 *    When printing in BIDI mode, each swath can potentially be printed either
 *    LTOR or RTOL.  This function determines which direction to print the next
 *    swath based on the shortest move amount required to position the carrier
 *    for printing.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *
 * Outputs: return LS_RTOL if should print toward maintenance station.
 *          return LS_LTOR if should print away from maintenance station..
 *
 * Original Author: K. Profitt
 * Date: 12/12/96
 *
 ******************************************************************************/
ByteType FAR LSGetSwathDirection(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   return(GetSwathDirection(lpxLSXface,lpxLSData->wCurrCarrPos));
}




ByteType GetSwathDirection(LPLSINTFACE lpxLSXface, WordType wCurrentPosition)
{
   LPLSDATA       lpxLSData;
   SwordType      swCarrPos,
                  swLeftPrintPos,
                  swRightPrintPos;
   ByteType       bDirection;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;
   if (lpxLSXface->xSwath.bNextPrintDirection == LS_LTOR)
   {
      bDirection = LS_LTOR;
   }
   else if (lpxLSXface->xSwath.bNextPrintDirection == LS_RTOL)
   {
      bDirection = LS_RTOL;
   }
   else
   {  /* BIDI print direction */

      /* Convert swath left and right print positions into carrier positions, */
      /* taking into account print direction and print head.                  */
      swLeftPrintPos  = PrintPos(lpxLSXface,lpxLSXface->xSwath.bNextPrintHead,
                                 lpxLSXface->xSwath.swNextLeftPrintPos,LS_LTOR);
      swRightPrintPos = PrintPos(lpxLSXface,lpxLSXface->xSwath.bNextPrintHead,
                                 lpxLSXface->xSwath.swNextRightPrintPos,LS_RTOL);
   
      swCarrPos =  (SwordType)wCurrentPosition;
   
      if ( (lnabs(swCarrPos - swLeftPrintPos)) <=
           (lnabs(swCarrPos - swRightPrintPos)) )
      {
         bDirection = LS_LTOR;
      }
      else
      {
         bDirection = LS_RTOL;
      }
   }  /* end of BIDI print direction */

   return(bDirection);

}  /* end of LSGetSwathDirection() */




/*******************************************************************************
 * Function Name:    LSEjectPage
 *
 * Description:
 *    This function calls EjectPage() to add a page eject command to the command
 *    buffer.  It then returns the command buffer to the calling function.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *
 * Outputs: lppbReturnCmd  the address of the command buffer to be sent to the
 *                         printer is stored at the memory location pointed to
 *                         by lppbReturnCmd.
 *          return code n  n = 0, function completed successfully, and no data
 *                                to send to printer.
 *                         n > 0  function completed successfully, with n bytes
 *                                of data to send to printer.
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 ******************************************************************************/
SwordType FAR LSEjectPage(LPLSINTFACE lpxLSXface, LPPByteType  lppbReturnCmd)
{
   LPLSDATA       lpxLSData;
   WordType       wCmdLength;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   EjectPage(lpxLSXface);

   /* now send the command(s) stored in the command buffer back to the        */
   /* calling function.                                                       */
   wCmdLength            = lpxLSData->wCmdLength;
   *lppbReturnCmd        = lpxLSData->lpbCmd;
   lpxLSData->wCmdLength = 0;

#if defined(CREATE_PRINT_FILE)
   WriteToOutFile(lpxLSXface, lpxLSData->lpbCmd, wCmdLength);
#endif

   return(wCmdLength);

}  /* end of LSEjectPage() */




/*******************************************************************************
 * Function Name:    LSEndPage
 *
 * Description:
 *    This function is called at the end of a page.  It builds a command buffer
 *    with the appropriate end-of-page commands, such as eject page and possibly
 *    carrier move commands.  It also sets several logic seek internal variables
 *    which describe the page and carrier positions.  Finally, it returns the
 *    command buffer to the calling function.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *
 * Outputs: lppbReturnCmd  the address of the command buffer to be sent to the
 *                         printer is stored at the memory location pointed to
 *                         by lppbReturnCmd.
 *          return code n  n = 0, function completed successfully, and no data
 *                                to send to printer.
 *                         n > 0  function completed successfully, with n bytes
 *                                of data to send to printer.
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 ******************************************************************************/
SwordType FAR LSEndPage(LPLSINTFACE lpxLSXface, LPPByteType  lppbReturnCmd)
{
   LPLSDATA       lpxLSData;
   WordType       wCmdLength;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

#if 0
/*#if defined(OSAKA)*/
/* commented this section out because we now want Osaka and Nairobi to behave */
/* the same.                                                                  */

   /* Before ejecting page, move the carrier off the page to avoid ink        */
   /* smearing. Move the carrier to either the right side frame or the spit   */
   /* position, whichever is closer.                                          */
   MoveCarrierOffPage(lpxLSXface, MCOP_CLOSEST_POSITION);
   
   EjectPage(lpxLSXface);

   /* now move the carrier to the spit position, if it is not already there.  */
   MoveCarrierOffPage(lpxLSXface, MCOP_SPIT_POSITION);

/*#elif defined(NAIROBI)*/


   /* For Nairobi, exit mechanism is better and therefore there will be no    */
   /* ink smearing if we leave the carrier on the page while ejecting         */
   EjectPage(lpxLSXface);

   /* Now send carrier to spit position.  First try sending at fast speed,    */
   /* then at normal speed. If both speeds require too much ramp-up/down      */
   /* distance, then the carrier is already off the page.                     */

   /* now move the carrier to the spit position                               */
   MoveCarrierOffPage(lpxLSXface, MCOP_SPIT_POSITION);

#endif

#if defined(BERMUDA)
   /* for Bermuda, we are homing the carrier at EndPage(), after ejecting the */
   /* paper.  This change was required to work around a Thunderbolt issue.    */

   MoveCarrierOffPage(lpxLSXface, MCOP_SPIT_POSITION);
   /* sync up with carrier position so send it home */
   SendCartridgeHome(lpxLSXface);
   EjectPage(lpxLSXface);
#else
   if ( lpxLSXface->bPrintQuality == LS_QUALITY_HIGH || 
        lpxLSXface->bPrintQuality == LS_QUALITY_NORMAL )
   {
      /* first move the carrier to the spit position, then eject the paper.   */
      /* This is to prevent the printhead touching the paper when the tail    */
      /* flip occurs.                                                         */
      MoveCarrierOffPage(lpxLSXface, MCOP_SPIT_POSITION);
      EjectPage(lpxLSXface);
   }
   else  /* QUALITY_DRAFT */
   {
      /* for draft, we want speed (paper eject as fast as possible).  So      */
      /* eject paper first, and then move the carrier to the spit position.   */
      EjectPage(lpxLSXface);
      MoveCarrierOffPage(lpxLSXface, MCOP_SPIT_POSITION);
   }
#endif


   /* now send the command(s) stored in the command buffer back to the        */
   /* calling function.                                                       */
   wCmdLength            = lpxLSData->wCmdLength;
   *lppbReturnCmd        = lpxLSData->lpbCmd;
   lpxLSData->wCmdLength = 0;

#if defined(CREATE_PRINT_FILE)
   WriteToOutFile(lpxLSXface, lpxLSData->lpbCmd, wCmdLength);
#endif

   return(wCmdLength);

}  /* end of LSEndPage() */




/*******************************************************************************
 * Function Name:    LSEndPrintJob
 *
 * Description:
 *    This must be the last logic seek function called at the end of a print 
 *    job.  It builds a command buffer with the appropriate end-of-document
 *    commands, such as head cap command.  It then deallocates the hpc internal
 *    data structure LSDATA.  Notice that it doesn't  deallocate the command
 *    buffer.  We can't deallocate the command buffer because it has the final
 *    commands to send to the printer.  The calling function must first send
 *    these commands to the printer and then deallocate the command buffer.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *
 * Outputs: lppbReturnCmd  the address of the command string to be sent to the
 *                         printer is stored at the memory location pointed to
 *                         by lppbReturnCmd.
 *          return code n  n < 0, error.  lppbReturnCmd will be set = NULL.
 *                         n = 0, function completed successfully, and no data
 *                                to send to printer.
 *                         n > 0  function completed successfully, with n bytes
 *                                of data to send to printer.
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 ******************************************************************************/
SwordType FAR LSEndPrintJob(LPLSINTFACE lpxLSXface, LPPByteType lppbReturnCmd)
{
   LPLSDATA       lpxLSData;
   WordType       wCmdLength;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   SendCartridgeHome(lpxLSXface);

   if(lpxLSXface->bAbortJob != 1)
   {
      EndPrintDataCmd(lpxLSXface);
   }

   /* now send the command(s) stored in the command buffer back to the        */
   /* calling function.                                                       */
   wCmdLength            = lpxLSData->wCmdLength;
   *lppbReturnCmd        = lpxLSData->lpbCmd;
   lpxLSData->wCmdLength = 0;


#if defined(CREATE_PRINT_FILE)
   WriteToOutFile(lpxLSXface, lpxLSData->lpbCmd, wCmdLength);
   if (lpxLSData->flPrnFile != HFILE_ERROR)
   {
      _lclose(lpxLSData->flPrnFile);
   }
#endif


   /* free dynamic memory allocated by hpc code                               */
   if (lpxLSData != NULL)
   {
      FREE_MEMORY(lpxLSData);

      /* Note that I am not freeing the lpxLSData->lpbCmd memory which I      */
      /* allocated at LSStartPrintJob().  It is the calling function's (hbp)  */
      /* responsibility to deallocate that memory.  The calling function has  */
      /* a pointer to that memory in *lppbReturnCmd.                          */
   }

   return((SwordType)wCmdLength);

}  /* end of LSEndPrintJob() */




void FAR LSGetMaintenanceDotCounts(LPLSINTFACE lpxLSXface,
                                   LPLSDOTCOUNTS lpxDotCounts)
{
   LPLSDATA       lpxLSData;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   lpxDotCounts->dwInk1 = 0L;
   lpxDotCounts->dwInk2 = 0L;
   lpxDotCounts->dwInk3 = 0L;
   lpxDotCounts->dwInk4 = 0L;
   lpxDotCounts->dwInk5 = 0L;
   lpxDotCounts->dwInk6 = 0L;

   return;

}




/*******************************************************************************
 * Function Name:    LSInstallCartridge
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to send the carrier to the install position.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: none
 *
 * Original Author: K. Profitt
 * Date: 12/12/96
 *
 ******************************************************************************/
SwordType FAR LSInstallCartridge(LPLSINTFACE lpxLSXface, LPPByteType lppbReturnCmd)
{

   /* silence compiler warnings */
   lpxLSXface = lpxLSXface;
   lppbReturnCmd = lppbReturnCmd;

   return(0);

}  /* end of function LSInstallCartridge() */




/*******************************************************************************
 * Function Name:    LSPerformMaintenance
 *
 * Description:
 *    This function allows the driver to explicitly send a maintenance command
 *    to the printer.
 *
 * Inputs:  lpxLSXface        Long pointer to hpc interface structure.
 *          lppbReturnCmd     Pointer to Command string the driver will send to
 *                            the printer.
 *          wSpitCount        The number of spits for each maintenance cycle.
 *          wRepeatCount      The number of maintenance cycles to perform.
 *
 * Outputs: none
 *
 * Original Author: J. Bates
 * Date: 09/29/98
 *
 ******************************************************************************/
SwordType FAR  LSPerformMaintenance(LPLSINTFACE lpxLSXface,LPPByteType
                                    lppbReturnCmd, DwordType dwSpitCount,
                                    DwordType dwRepeatCount)
{
   LPLSDATA       lpxLSData;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   if (lpxLSData->fMaintenanceRequired == FALSE)
   {         
      lpxLSData->fMaintenanceRequired = TRUE;
      lpxLSData->dwSpitCount = dwSpitCount;
      lpxLSData->dwWipeCount = dwRepeatCount;
   }

   *lppbReturnCmd = NULL;
   return(0);

}  /* end of LSPerformMaintenance() */




/*******************************************************************************
 * Function Name:    LSProductReturns
 *
 * Description:
 *    This function should be called once for the life of a printer.  At the
 *    first 100 printed page milestone, the driver should call
 *    FCProductReturns() which in turn calls this function.  We move the carrier
 *    to the extreme right position (away from maintenance station) and perform
 *    a spit command.  This is to leave a mark on the printer body to let our
 *    product returns team know that the printer is no longer new.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *
 * Outputs: lppbReturnCmd  the address of the command buffer to be sent to the
 *                         printer is stored at the memory location pointed to
 *                         by lppbReturnCmd.
 *          return code n  n < 0, error.  lppbReturnCmd will be set = NULL.
 *                         n = 0, function completed successfully, and no data
 *                                to send to printer.  lppbReturnCmd will be
 *                                set = NULL.
 *                         n > 0  function completed successfully, with n bytes
 *                                of data to send to printer.
 *
 * Original Author: J. Bates
 * Date: 01/19/99
 *
 ******************************************************************************/
SwordType FAR LSProductReturns(LPLSINTFACE lpxLSXface,
                                LPPByteType lppbReturnCmd)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;
   WordType       wCmdLength;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   SendCartridgeHome(lpxLSXface);

   lpxLSData->bPosCarrDirection    = LS_LTOR;
   lpxLSData->wPosCarrStopPosition = lpxLSData->wRightPrintLimit;
   lpxLSData->wPosCarrSpeed        = SPEED_SLOW;

   CarrierMoveCmd(lpxLSXface, LS_LTOR, LS_RTOL);

   /* now perform a spit to place ink on the printer body */
   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   lpbCmd[0] = CMD_START_BYTE;
   lpbCmd[1] = SPIT_CMD;
   lpbCmd[2] = (ByteType)(384/32);
   lpbCmd[3] = 0;
   lpbCmd[4] = 0;
   lpbCmd[5] = 0;
   lpbCmd[6] = 0;
   lpbCmd[7] = Checksum(lpbCmd);
   lpxLSData->wCmdLength += COMMAND_SIZE;

   /* jbb 03/28/00 - we are intentionally sending an invalid command to    */
   /* the printer after the spit command.  This is to work around a bug in */
   /* firmware version 000214-3.  The bug is when the spit command is      */
   /* followed by a carrier move command, the carrier will move before     */
   /* spitting.                                                            */
   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   lpbCmd[0] = CMD_START_BYTE;
   lpbCmd[1] = 0x21;
   lpbCmd[2] = 0;
   lpbCmd[3] = 0;
   lpbCmd[4] = 0;
   lpbCmd[5] = 0;
   lpbCmd[6] = 0;
   lpbCmd[7] = 0xFF;
   lpxLSData->wCmdLength += COMMAND_SIZE;

   SendCartridgeHome(lpxLSXface);

   /* now send the command(s) stored in the command buffer back to the     */
   /* calling function.                                                    */
   wCmdLength            = lpxLSData->wCmdLength;
   *lppbReturnCmd        = lpxLSData->lpbCmd;
   lpxLSData->wCmdLength = 0;

#if defined(CREATE_PRINT_FILE)
   WriteToOutFile(lpxLSXface, lpxLSData->lpbCmd, wCmdLength);
#endif

   return(wCmdLength);

}  /* end of LSProductReturns() */




/*******************************************************************************
 * Function Name:    LSSendCartridgeHome
 *
 * Description:
 *    This function calls SendCartridgeHome() to add a cap command to the
 *    command buffer and then returns the command buffer to the calling
 *    function.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *
 * Outputs: lppbReturnCmd  the address of the command buffer to be sent to the
 *                         printer is stored at the memory location pointed to
 *                         by lppbReturnCmd.
 *          return code n  n < 0, error.  lppbReturnCmd will be set = NULL.
 *                         n = 0, function completed successfully, and no data
 *                                to send to printer.  lppbReturnCmd will be
 *                                set = NULL.
 *                         n > 0  function completed successfully, with n bytes
 *                                of data to send to printer.
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 ******************************************************************************/
SwordType FAR LSSendCartridgeHome(LPLSINTFACE lpxLSXface, LPPByteType lppbReturnCmd)
{
   LPLSDATA       lpxLSData;
   WordType       wCmdLength;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   SendCartridgeHome(lpxLSXface);

   /* now send the command(s) stored in the command buffer back to the        */
   /* calling function.                                                       */
   wCmdLength            = lpxLSData->wCmdLength;
   *lppbReturnCmd        = lpxLSData->lpbCmd;
   lpxLSData->wCmdLength = 0;

#if defined(CREATE_PRINT_FILE)
   WriteToOutFile(lpxLSXface, lpxLSData->lpbCmd, wCmdLength);
#endif

   return((SwordType)wCmdLength);

}  /* end of function LSSendCartridgeHome() */




/****************************************************************************
 * Function Name:    LSSwathCmd
 *
 * Description:
 *    This function is responsible for everything that needs to
 *    happen when one swath buffer is sent to the printer for
 *    printing.  Linefeed is called to move the paper to the
 *    correct position for the swath followed by the swath
 *    data.
 *
 *
 * Inputs:  lpxLSXface  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 ***************************************************************************/
SwordType FAR LSSwathCmd(LPLSINTFACE lpxLSXface, LPPByteType lppbReturnCmd)
{
   LPLSDATA       lpxLSData;
   WordType       wCarrPos,
                  wCmdLength;
   ByteType       bCarrierDirection,
                  bNextCarrierDirection,
                  bNextPrintDir;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;


   /* perform required vertical move before printing this swath.  */
   LineFeed(lpxLSXface,lpxLSXface->xSwath.dwVertMoveBeforePrint);


   /* add the dot counts from this swath to our dot counts */
   switch (lpxLSXface->xSwath.bPrintHead)
   {
   case LS_MONO_CARTRIDGE :
      lpxLSData->adwColor[MONO][0][PRINT_DOT_CNT] += lpxLSXface->xSwath.adwDotCount[0];
      lpxLSData->adwColor[MONO][0][IDLE_DOT_CNT]  += lpxLSXface->xSwath.adwDotCount[0];
      lpxLSData->dwSwathDotCount = lpxLSXface->xSwath.adwDotCount[0];
      break;
   case LS_CMY_CARTRIDGE :
      lpxLSData->adwColor[CMY][0][PRINT_DOT_CNT] += lpxLSXface->xSwath.adwDotCount[0];
      lpxLSData->adwColor[CMY][0][IDLE_DOT_CNT]  += lpxLSXface->xSwath.adwDotCount[0];
      lpxLSData->adwColor[CMY][1][PRINT_DOT_CNT] += lpxLSXface->xSwath.adwDotCount[1];
      lpxLSData->adwColor[CMY][1][IDLE_DOT_CNT]  += lpxLSXface->xSwath.adwDotCount[1];
      lpxLSData->adwColor[CMY][2][PRINT_DOT_CNT] += lpxLSXface->xSwath.adwDotCount[2];
      lpxLSData->adwColor[CMY][2][IDLE_DOT_CNT]  += lpxLSXface->xSwath.adwDotCount[2];
      lpxLSData->dwSwathDotCount  = lpxLSXface->xSwath.adwDotCount[0];
      lpxLSData->dwSwathDotCount += lpxLSXface->xSwath.adwDotCount[1];
      lpxLSData->dwSwathDotCount += lpxLSXface->xSwath.adwDotCount[2];
      break;
   case LS_KCM_CARTRIDGE :
      lpxLSData->adwColor[KCM][0][PRINT_DOT_CNT] += lpxLSXface->xSwath.adwDotCount[0];
      lpxLSData->adwColor[KCM][0][IDLE_DOT_CNT]  += lpxLSXface->xSwath.adwDotCount[0];
      lpxLSData->adwColor[KCM][1][PRINT_DOT_CNT] += lpxLSXface->xSwath.adwDotCount[1];
      lpxLSData->adwColor[KCM][1][IDLE_DOT_CNT]  += lpxLSXface->xSwath.adwDotCount[1];
      lpxLSData->adwColor[KCM][2][PRINT_DOT_CNT] += lpxLSXface->xSwath.adwDotCount[2];
      lpxLSData->adwColor[KCM][2][IDLE_DOT_CNT]  += lpxLSXface->xSwath.adwDotCount[2];
      lpxLSData->dwSwathDotCount  = lpxLSXface->xSwath.adwDotCount[0];
      lpxLSData->dwSwathDotCount += lpxLSXface->xSwath.adwDotCount[1];
      lpxLSData->dwSwathDotCount += lpxLSXface->xSwath.adwDotCount[2];
      break;
   }
   /* end of adding the dot counts from this swath to our dot counts */


   lpxLSData->fMaintenanceRequired = MaintenanceRequired(lpxLSXface);

   if ( (lpxLSData->fMaintenanceRequired == TRUE) &&
        (lpxLSData->wCurrCarrPos <= lpxLSData->wLeftPaperEdge) )
   {
      MaintenanceCmd(lpxLSXface);
   }

   if (lpxLSXface->xSwath.swRightPrintPos < lpxLSXface->xSwath.swLeftPrintPos)
   {  /* this is an empty swath, so don't send the swath information, return  */
      /* information, and swath data commands.  If a vertical move is         */
      /* required after "printing", then send a line feed command.            */
      if (lpxLSXface->xSwath.dwNextVertMoveBeforePrint != 0)
      {
         LineFeed(lpxLSXface,lpxLSXface->xSwath.dwNextVertMoveBeforePrint);
      }

      /* now send the command(s) stored in the command buffer back to the     */
      /* calling function.                                                    */
      wCmdLength            = lpxLSData->wCmdLength;
      *lppbReturnCmd        = lpxLSData->lpbCmd;
      lpxLSData->wCmdLength = 0;

#if defined(CREATE_PRINT_FILE)
      WriteToOutFile(lpxLSXface, lpxLSData->lpbCmd, wCmdLength);
      WriteToOutFile( lpxLSXface, lpxLSXface->xSwath.hpbSwathData,
                      lpxLSXface->xSwath.dwSwathLength );
#endif
      return(wCmdLength);
   }  /* end of processing an empty swath */


   /* Calculate where the carrier needs to be to start printing and output    */
   /* the command to move the carrier to the correct position.                */
   PositionCarrierToPrint(lpxLSXface,lpxLSXface->xSwath.swLeftPrintPos,
         lpxLSXface->xSwath.swRightPrintPos, lpxLSXface->xSwath.bPrintHead,
         lpxLSXface->xSwath.bPrintDirection);


   /* The carrier is now in the correct position to print the current swath,  */
   /* and our lpxLSData->wCurrCarrPos reflects that position.  Now we need to */
   /* decide if we should change the stop position to better prepare for the  */
   /* next swath.                                                             */


   /* first, get the direction the next swath should be printed in.           */
   bNextPrintDir = GetSwathDirection(lpxLSXface,lpxLSData->wPrtCarrStopPosition);

   /* next, check the next swath positions to be printed and append any       */
   /* distance required to setup for the next swath to the print stop         */
   /* position.                                                               */
   CalculateAppendDistance(lpxLSXface,lpxLSXface->xSwath.swNextLeftPrintPos,
            lpxLSXface->xSwath.swNextRightPrintPos,
            lpxLSXface->xSwath.bNextPrintHead, lpxLSData->bPrtCarrDirection,
            bNextPrintDir);


   /* we need to go ahead and calculate the Return Information Command        */
   /* carrier move before sending the Swath Information Command to the        */
   /* printer because the RIC move will help us determine what the next move  */
   /* direction after the SIC move will be.  But the                          */
   /* CalculateRICCarrierPosition() needs to know where the carrier will be   */
   /* positioned after the SIC move.  To accomplish this, I am calculating    */
   /* the carrier move and resulting stop position of the SIC command, and    */
   /* passing that position into the CalculateRICCarrierPosition(), even      */
   /* though the move hasn't actually taken place yet.  For this estimate of  */
   /* the carrier position, we don't want a phase change, so make the next    */
   /* carrier move direction the same as the current carrier move direction.  */

   wCarrPos     = lpxLSData->wCurrCarrPos;
   CalcConstantSteps(lpxLSXface, &wCarrPos,
                  lpxLSData->wPrtCarrStopPosition,lpxLSData->wPrtCarrSpeed,
                  lpxLSData->bPrtCarrDirection,lpxLSData->bPrtCarrDirection);

   /* Now calculate the return move required, if any, so the carrier is in */
   /* position for the next swath                                          */
   CalculateRICCarrierPosition(lpxLSXface,wCarrPos,
         lpxLSXface->xSwath.swNextLeftPrintPos,
         lpxLSXface->xSwath.swNextRightPrintPos,
         lpxLSXface->xSwath.bNextPrintHead, bNextPrintDir);


   bCarrierDirection = lpxLSData->bPrtCarrDirection;
   if (lpxLSData->bPosCarrDirection == NO_DIRECTION)
   {
      bNextCarrierDirection = bNextPrintDir;
   }
   else
   {
      bNextCarrierDirection = lpxLSData->bPosCarrDirection;
   }

   /* Send the swath information command to the printer */
   SwathInformationCmd(lpxLSXface,bCarrierDirection,bNextCarrierDirection);



   if (lpxLSData->bPosCarrDirection == NO_DIRECTION)
   {
      bCarrierDirection     = NO_DIRECTION;
      bNextCarrierDirection = NO_DIRECTION;
   }
   else
   {
      bCarrierDirection     = lpxLSData->bPosCarrDirection;
      bNextCarrierDirection = bNextPrintDir;
   }

   /* Send the swath return information command to the printer */
   ReturnInformationCmd(lpxLSXface,bCarrierDirection,bNextCarrierDirection);

   SwathDataCmd(lpxLSXface);

   /* now send the command(s) stored in the command buffer back to the        */
   /* calling function.                                                       */
   wCmdLength            = lpxLSData->wCmdLength;
   *lppbReturnCmd        = lpxLSData->lpbCmd;
   lpxLSData->wCmdLength = 0;

#if defined(CREATE_PRINT_FILE)
   WriteToOutFile(lpxLSXface, lpxLSData->lpbCmd, wCmdLength);
   WriteToOutFile( lpxLSXface, lpxLSXface->xSwath.hpbSwathData,
                   lpxLSXface->xSwath.dwSwathLength );
#endif

   return(wCmdLength);

}  /* end of function LSSwathCmd() */




/*******************************************************************************
 * Function Name:    LSStartPrintJob
 *
 * Description:
 *    This function is called at the beginning of a document and can send the
 *    printer any required information for the job start.  The logic seek
 *    internal data structure is also initialized here.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *
 * Outputs: lppbReturnCmd  the address of the command buffer to be sent to the
 *                         printer is stored at the memory location pointed to
 *                         by lppbReturnCmd.
 *          return code n  n < 0, error.  lppbReturnCmd will be set = NULL.
 *                         n = 0, function completed successfully, and no data
 *                                to send to printer.  lppbReturnCmd will be
 *                                set = NULL.
 *                         n > 0  function completed successfully, with n bytes
 *                                of data to send to printer.
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 ******************************************************************************/
SwordType FAR LSStartPrintJob(LPLSINTFACE lpxLSXface, LPPByteType lppbReturnCmd)
{
   LPLSDATA       lpxLSData;
#if 0
   WordType       wCmdLength;
#endif


   /* Allocate memory for the logic seek internal data structure. */
   lpxLSXface->lpLSDevice = (DwordType) ALLOCATE_MEMORY(LSDATA_SIZE);
   if (lpxLSXface->lpLSDevice == 0)
   {  /* error */
      *lppbReturnCmd = NULL;
      return(-1);
   }

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   /* Allocate memory for the command buffer.  Make it larger than the byte   */
   /* length of any possible combination of commands.                         */
   lpxLSData->lpbCmd = (LPByteType) ALLOCATE_MEMORY(COMMAND_BUFFER_SIZE);
   if (lpxLSData->lpbCmd == NULL)
   {  /* error */
      FREE_MEMORY(lpxLSData);
      *lppbReturnCmd = NULL;
      return(-1);
   }


   /* Init Hw data stucture */
   lpxLSData->wCmdLength               = 0;
   lpxLSData->bPrtCarrDirection        = NO_DIRECTION;
   lpxLSData->wPrtStartPosition        = 0;
   lpxLSData->wPrtCarrStopPosition     = 0;
   lpxLSData->wPrtCarrSpeed            = SPEED_STOPPED;
   lpxLSData->bPosCarrDirection        = NO_DIRECTION;
   lpxLSData->wPosCarrStopPosition     = 0;
   lpxLSData->wPosCarrSpeed            = SPEED_STOPPED;
   lpxLSData->wCurrCarrPos             = LEFT_SIDE_FRAME_POSITION;
   lpxLSData->bPhase                   = LS_LTOR;



#if defined(CREATE_PRINT_FILE)
   /* we will write each command and swath data to a print file as well as    */
   /* add it to the command buffer.  So open the output print file.           */
   lpxLSData->lpxPrnFileInfo = &(lpxLSData->xPrnFileInfo);
   lpxLSData->flPrnFile = OpenFile(PRINT_FILE_NAME,lpxLSData->lpxPrnFileInfo,
                          (OF_CREATE | OF_WRITE));
#endif


   if (lpxLSXface->dwSecondsSinceLastPrint > FULL_MAINTENANCE_SECONDS)
   {
      lpxLSData->bPORMaintenanceRequired = TRUE;
   }
   else
   {
      lpxLSData->bPORMaintenanceRequired = FALSE;
   }


   /* The null command should be the first command sent to the printer at the */
   /* beginning of a print job.                                               */
   NullCmd(lpxLSXface);


#if defined(BERMUDA)
   /* for Bermuda, we are homing the carrier at EndPage(), after ejecting the */
   /* paper, instead of at StartPage().  This means we need to also home the  */
   /* carrier at StartJob() so the HPC and printer are in sync for the first  */
   /* page.  This change was required to work around a Thunderbolt issue.     */

   /* sync up with carrier position so send it home */
   SendCartridgeHome(lpxLSXface);
#endif


/* Osaka and Nairobi do not need to send 64 null bytes in Windows NT.  If     */
/* they do, the 64 nulls get intepreted by the firmware as a cancel print.    */
#if 0
//#if defined(FC_WIN_32) /*|| defined(FC_DOS_32)*/
   /* The Windows NT logic seek code needs to send down 64 blank bytes at the */
   /* beginning of the print job.                                             */
   {
      LPByteType  lpbCmd;
      ByteType    bCounter;

      lpbCmd = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
      for(bCounter=0; bCounter<64; bCounter++)
      {
         lpbCmd[bCounter] = 0x00;
      }
      lpxLSData->wCmdLength += 64;

   }

#endif   /* #if defined(FC_WIN_32) */


   /* We moved the section which downloads the ramp tables to LSStartPage()   */
   /* because Nairobi now needs to send different ramps depending on whether  */
   /* the first page is envelope and hagaki or the other media sizes.  This   */
   /* information is not provided by the driver until FCStartPage() in the    */
   /* HBP code.  We also added the new variable fFirstPageInDocument and set  */
   /* it equal TRUE here to help LSStartPage() know which is the first page   */
   /* of this print job.                                                      */
   lpxLSData->fFirstPageInDocument = TRUE;


#if 0
   /* now send the command(s) stored in the command buffer back to the        */
   /* calling function.                                                       */
   wCmdLength            = lpxLSData->wCmdLength;
   *lppbReturnCmd        = lpxLSData->lpbCmd;
   lpxLSData->wCmdLength = 0;

   return(wCmdLength);
#else 
   /* Vladimir asked that the beginning of job commands be sent before the    */
   /* first page instead of start of document.  So by returning 0 I am        */
   /* leaving the commands in the command buffer until the LSStartPage()      */
   /* function is called.  The commands added by LSStartPage() will get added */
   /* to the back of the buffer, and all the commands will get sent to the    */
   /* printer at that time.                                                   */
   *lppbReturnCmd = NULL;
   return(0);
#endif

}  /* end of LSStartPrintJob() */




/****************************************************************************
 * Function Name:    LSStartPage
 *
 * Description:
 *    This function is called at the beginning of a page and
 *    can send the printer any required information for the
 *    page start.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 ***************************************************************************/
SwordType FAR LSStartPage(LPLSINTFACE lpxLSXface, LPPByteType lppbReturnCmd)
{
   LPLSDATA       lpxLSData;
   WordType       wCmdLength;
   DwordType      dwSpitCount,
                  dwWipeCount;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;


   if (lpxLSData->fFirstPageInDocument == TRUE)
   {
      /* This is the first page in the document, so download ramps.  We       */
      /* moved this section from LSStartPrintJob() because Nairobi now needs  */
      /* to send different ramps depending on whether the first page is       */
      /* envelope and hagaki or the other media sizes.  This information is   */
      /* not provided by the driver until FCStartPage() in the HBP code.      */
      LoadRampTable(lpxLSXface);
      LoadCarrierSteps(lpxLSXface);
      LoadCarrierDistances(lpxLSXface);
   
      /* now download the paper and carrier ramp tables to the printer.          */
      RampTableInformationCmd(lpxLSXface);
   
      InitializeMaintenanceArrays(lpxLSXface);

      /* the next page(s) will not be the first page in the document */
      lpxLSData->fFirstPageInDocument = FALSE;
   }


   lpxLSData->dwPaperStepCount = 0;

   lpxLSData->dwVertMovePending = 0;

#if !defined(BERMUDA)
   /* for Bermuda, we are homing the carrier at EndPage(), after ejecting the */
   /* paper.  This change was required to work around a Thunderbolt issue.    */

   /* sync up with carrier position so send it home */
   SendCartridgeHome(lpxLSXface);
#endif

   /* download the correct paper load parameters */
   PageInformationCmd(lpxLSXface);


#if HEAD_SWAPPER
   if (lpxLSXface->bColorPlanes == 1)
   {
      lpxLSData->bPrimaryCartridgeID = LS_MONO_CARTRIDGE;
   }
   else
   {
      lpxLSData->bPrimaryCartridgeID = LS_CMY_CARTRIDGE;
   }
   lpxLSData->bSecondaryCartridgeID  = LS_NO_CARTRIDGE;
#else
   lpxLSData->bPrimaryCartridgeID    = LS_CMY_CARTRIDGE;
   lpxLSData->bSecondaryCartridgeID  = lpxLSXface->bLeftCartridgeID;

   /* override lpxLSXface->bLeftCartridgeID based on the number of color      */
   /* planes in this print page.  I am doing this because we are not reliably */
   /* receiving the left cartridge information from the hbp code.             */
   switch (lpxLSXface->bColorPlanes)
   {
   case 6 :
      lpxLSData->bSecondaryCartridgeID = LS_KCM_CARTRIDGE;
      break;
   default :
      lpxLSData->bSecondaryCartridgeID = LS_MONO_CARTRIDGE;
      break;
   }
#endif


   /* now perform start of page maintenance */
   lpxLSData->fMaintenanceRequired = TRUE;

   if (lpxLSData->bPORMaintenanceRequired)
   {
      /* we did it, don't do it again on next page */
      lpxLSData->bPORMaintenanceRequired = FALSE;

      dwSpitCount = INSTALL_SPIT_CNT;
      dwWipeCount = INSTALL_WIPE_CNT;
   }
   else
   {
      dwSpitCount = BETWEEN_PAGE_SPIT_CNT;
      dwWipeCount = BETWEEN_PAGE_WIPE_CNT;
   }
   lpxLSData->dwSpitCount = dwSpitCount;
   lpxLSData->dwWipeCount = dwWipeCount;
   MaintenanceCmd(lpxLSXface);

#if defined(GEN_COL_BIDI)
   bNumBidiSwaths = 0;
#endif


   HPCFormFeed(lpxLSXface);

   /* now send the command(s) stored in the command buffer back to the        */
   /* calling function.                                                       */
   wCmdLength            = lpxLSData->wCmdLength;
   *lppbReturnCmd        = lpxLSData->lpbCmd;
   lpxLSData->wCmdLength = 0;

#if defined(CREATE_PRINT_FILE)
   WriteToOutFile(lpxLSXface, lpxLSData->lpbCmd, wCmdLength);
#endif

   return(wCmdLength);

}  /* end of LSStartPage() */




/*******************************************************************************
 * Function Name:    MaintenanceCmd
 *
 * Description:
 *    This function is called to send a command to the printer to perform
 *    printhead maintenance.  This command will be the SPIT_CMD if Wipe Count
 *    is 0, otherwise it will be the MAINTENANCE_CMD.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: J. Bates
 * Date: 07/07/98
 *
 ******************************************************************************/
void MaintenanceCmd(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;
   WordType       minDist;
   DwordType      dwDotCount,
                  dwTime;
   ByteType       bN;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   /* this function will perform printhead maintenance, so go ahead and turn  */
   /* the maintenance flag off.                                               */
   lpxLSData->fMaintenanceRequired = FALSE;


#if defined(FC_WIN_16)
   dwTime = (long)GetTickCount();
#else
   /* GetTickCount() is not available to the NT driver */
   dwTime = 0;
#endif

   if (lpxLSData->dwSpitCount == 0)
   {
      return;
   }


   /* position the carrier for either spitting or maintenance */
   if (lpxLSData->dwWipeCount == 0)
   {  /* spit command */
      if( !((lpxLSData->wCurrCarrPos < (lpxLSData->wSpitPosition + (WordType)120))
         && (lpxLSData->wCurrCarrPos > (lpxLSData->wSpitPosition - (WordType)120))) )
      {

         /* +8 is because we want to move at least 1 step more than the       */
         /* shortest move distance                                            */
         minDist = AlphaDistance(lpxLSXface,SPEED_FAST,ACCEL+DECEL) + 8;

         /* Can we move to spit quickly? */
         if (lpxLSData->wCurrCarrPos > lpxLSData->wSpitPosition + minDist)
         {
             lpxLSData->wPosCarrStopPosition  = lpxLSData->wSpitPosition;
             lpxLSData->bPosCarrDirection     = LS_RTOL;
             lpxLSData->wPosCarrSpeed         = SPEED_FAST;
         }
         else
         {
            minDist = AlphaDistance(lpxLSXface,SPEED_SLOW,ACCEL+DECEL) + 8;

            if (lpxLSData->wCurrCarrPos < (lpxLSData->wSpitPosition + minDist))
            {  /* We are too close to move to spit position, even at slow     */
               /* speed, so, back away from the spit position a little and    */
               /* move back over                                              */
               lpxLSData->wPosCarrSpeed         = SPEED_SLOW;
               lpxLSData->wPosCarrStopPosition  = lpxLSData->wSpitPosition + minDist;
               lpxLSData->bPosCarrDirection     = LS_LTOR;
               CarrierMoveCmd (lpxLSXface, LS_LTOR, LS_RTOL);
            }

            /* now setup the position variables for the move back to the spit */
            /* position                                                       */
            lpxLSData->wPosCarrSpeed         = SPEED_SLOW;
            lpxLSData->wPosCarrStopPosition  = lpxLSData->wSpitPosition;
            lpxLSData->bPosCarrDirection     = LS_RTOL;
         }
      
         /* Position for spit (not print) */
         CarrierMoveCmd(lpxLSXface, LS_RTOL, LS_LTOR);
      }
   }
   else
   {  /* maintenance command */
      if (lpxLSData->wCurrCarrPos > LEFT_SIDE_FRAME_POSITION)
      {  /* move carrier to home position in preparation for maintenance.        */

         if( lpxLSData->wCurrCarrPos > (lpxLSData->wSpitPosition +
             AlphaDistance(lpxLSXface,SPEED_FAST,ACCEL+DECEL)) )
         {  /* There is enough distance to perform a fast carrier move           */
            lpxLSData->wPosCarrStopPosition  = lpxLSData->wSpitPosition;
            lpxLSData->bPosCarrDirection     = LS_RTOL;
            lpxLSData->wPosCarrSpeed         = SPEED_FAST;
            CarrierMoveCmd(lpxLSXface, LS_RTOL, LS_RTOL);
         }
         SendCartridgeHome(lpxLSXface);
      }
   }




   /* update dot count and time information for the current head(s)           */
   switch (lpxLSData->bPrimaryCartridgeID + lpxLSData->bSecondaryCartridgeID)
   {
   case LS_CMY_CARTRIDGE :
      lpxLSData->adwCartridge[CMY][LAST_SPIT_TIME] = dwTime;
      dwDotCount = lpxLSData->dwSpitCount*(COLOR_NOZ_CNT/3);
      for (bN=0; bN<3; bN++)
      {
         lpxLSData->adwColor[CMY][bN][MAINT_DOT_CNT] += dwDotCount;
         lpxLSData->adwColor[CMY][bN][IDLE_DOT_CNT]   = 0L;
         if (lpxLSData->dwWipeCount > 0)
         {
            lpxLSData->adwColor[CMY][bN][PRINT_DOT_CNT]  = 0L;
         }
      }
      break;

   case LS_MONO_CARTRIDGE :
      lpxLSData->adwCartridge[MONO][LAST_SPIT_TIME] = dwTime;
      dwDotCount = lpxLSData->dwSpitCount*BLACK_NOZ_CNT;
      lpxLSData->adwColor[MONO][0][MAINT_DOT_CNT] += dwDotCount;
      lpxLSData->adwColor[MONO][0][IDLE_DOT_CNT]   = 0L;
      if (lpxLSData->dwWipeCount > 0)
      {
         lpxLSData->adwColor[MONO][0][PRINT_DOT_CNT]  = 0L;
      }
      break;

   case (LS_CMY_CARTRIDGE + LS_MONO_CARTRIDGE) :
      /* CMY head */
      lpxLSData->adwCartridge[CMY][LAST_SPIT_TIME]  = dwTime;
      dwDotCount = lpxLSData->dwSpitCount*(COLOR_NOZ_CNT/3);
      for (bN=0; bN<3; bN++)
      {
         lpxLSData->adwColor[CMY][bN][MAINT_DOT_CNT] += dwDotCount;
         lpxLSData->adwColor[CMY][bN][IDLE_DOT_CNT]   = 0L;
         if (lpxLSData->dwWipeCount > 0)
         {
            lpxLSData->adwColor[CMY][bN][PRINT_DOT_CNT]  = 0L;
         }
      }

      /* Mono head */
      lpxLSData->adwCartridge[MONO][LAST_SPIT_TIME] = dwTime;
      dwDotCount = lpxLSData->dwSpitCount*BLACK_NOZ_CNT;
      lpxLSData->adwColor[MONO][0][MAINT_DOT_CNT] += dwDotCount;
      lpxLSData->adwColor[MONO][0][IDLE_DOT_CNT]   = 0L;
      if (lpxLSData->dwWipeCount > 0)
      {
         lpxLSData->adwColor[MONO][0][PRINT_DOT_CNT]  = 0L;
      }
      break;

   case (LS_CMY_CARTRIDGE + LS_KCM_CARTRIDGE) :
      /* CMY head */
      lpxLSData->adwCartridge[CMY][LAST_SPIT_TIME] = dwTime;
      dwDotCount = lpxLSData->dwSpitCount*(COLOR_NOZ_CNT/3);
      for (bN=0; bN<3; bN++)
      {
         lpxLSData->adwColor[CMY][bN][MAINT_DOT_CNT] += dwDotCount;
         lpxLSData->adwColor[CMY][bN][IDLE_DOT_CNT]   = 0L;
         if (lpxLSData->dwWipeCount > 0)
         {
            lpxLSData->adwColor[CMY][bN][PRINT_DOT_CNT]  = 0L;
         }
      }

      /* Kcm head */
      lpxLSData->adwCartridge[KCM][LAST_SPIT_TIME] = dwTime;
      for (bN=0; bN<3; bN++)
      {
         lpxLSData->adwColor[KCM][bN][MAINT_DOT_CNT] += dwDotCount;
         lpxLSData->adwColor[KCM][bN][IDLE_DOT_CNT]   = 0L;
         if (lpxLSData->dwWipeCount > 0)
         {
            lpxLSData->adwColor[KCM][bN][PRINT_DOT_CNT]  = 0L;
         }
      }
      break;

   default :
      break;
   }
   /* end of update dot count and time information for the current head(s)    */



   /* now add the appropriate command to the command buffer */
   if (lpxLSData->dwWipeCount == 0)
   {  /* spit command */
      lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
      lpbCmd[0] = CMD_START_BYTE;
      lpbCmd[1] = SPIT_CMD;
      lpbCmd[2] = (ByteType)(lpxLSData->dwSpitCount/32);
      lpbCmd[3] = 0;
      lpbCmd[4] = 0;
      lpbCmd[5] = 0;
      lpbCmd[6] = 0;
      lpbCmd[7] = Checksum(lpbCmd);
      lpxLSData->wCmdLength += COMMAND_SIZE;

      /* jbb 03/28/00 - we are intentionally sending an invalid command to    */
      /* the printer after the spit command.  This is to work around a bug in */
      /* firmware version 000214-3.  The bug is when the spit command is      */
      /* followed by a carrier move command, the carrier will move before     */
      /* spitting.                                                            */
      lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
      lpbCmd[0] = CMD_START_BYTE;
      lpbCmd[1] = 0x21;
      lpbCmd[2] = 0;
      lpbCmd[3] = 0;
      lpbCmd[4] = 0;
      lpbCmd[5] = 0;
      lpbCmd[6] = 0;
      lpbCmd[7] = 0xFF;
      lpxLSData->wCmdLength += COMMAND_SIZE;
   }
   else
   {  /* maintenance command */
      lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
      lpbCmd[0] = CMD_START_BYTE;
      lpbCmd[1] = MAINTENANCE_CMD;
      lpbCmd[2] = MAINT_SPIT_POS;
      lpbCmd[3] = (ByteType)(lpxLSData->dwSpitCount/32);
      lpbCmd[4] = (ByteType)lpxLSData->dwWipeCount;
      lpbCmd[5] = 0;
      lpbCmd[6] = 0;
      lpbCmd[7] = Checksum(lpbCmd);
      lpxLSData->wCmdLength += COMMAND_SIZE;

      /* the maintenace command will leave the carrier at the spit position.  */
      lpxLSData->wCurrCarrPos = lpxLSData->wSpitPosition;
      lpxLSData->bPhase       = LS_LTOR;
   }


   return;

}  /* end of MaintenanceCmd() */




/*******************************************************************************
 *                                                  Lexmark Confidential
 *
 *  Function Name:
 *    MaintenanceRequired
 *
 *  Description:
 *
 *    This function determines if maintenance needs to be performed while the
 *    page is printing.  If the ink dot count exceeds a threshold or if the
 *    time since the last maintenance exceeds a threshold then maintenance is
 *    performed before the line is printed.
 *
 *  Inputs:
 *   None
 *
 *  Original Author : K. Profitt
 *  Date: 10/27/94
 *
 ***************************************************************************/
BoolType MaintenanceRequired(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   DwordType      dwIdleTime,
                  dwSpitCount=0,
                  dwTime,
                  dwWipeCount=0;
   ByteType       bI;     /* loop counters */
   BoolType       fMaintenanceRequired = FALSE;

#if defined(FC_WIN_16)
   dwTime = (long)GetTickCount ();
#else
   /* GetTickCount() is not available to the NT driver */
   dwTime = 0;
#endif

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   if (lpxLSData->fMaintenanceRequired)
   {         
      /* we already know we need to perform maintenance */
      return(TRUE);
   }
   

   /* If the dot count for the current printhead exceeds a certain dot        */
   /* threshold, then perform full maintenace ( spit & wipe )                 */
   switch (lpxLSXface->xSwath.bPrintHead)
   {
   case LS_MONO_CARTRIDGE :
      if ( lpxLSData->adwColor[MONO][0][PRINT_DOT_CNT] >
           lpxLSData->adwCartridge[MONO][THOLD_DOT_CNT] )
      {
         fMaintenanceRequired   = TRUE;
         lpxLSData->dwSpitCount = lpxLSData->adwCartridge[MONO][THOLD_SPIT_CNT];
         lpxLSData->dwWipeCount = lpxLSData->adwCartridge[MONO][THOLD_WIPE_CNT];
      }
      break;

   case LS_CMY_CARTRIDGE :
      for (bI=0; bI<3; bI++)
      {
         if ( lpxLSData->adwColor[CMY][bI][PRINT_DOT_CNT] >
              lpxLSData->adwCartridge[CMY][THOLD_DOT_CNT] )
         {
            fMaintenanceRequired  = TRUE;
            lpxLSData->dwSpitCount=lpxLSData->adwCartridge[CMY][THOLD_SPIT_CNT];
            lpxLSData->dwWipeCount=lpxLSData->adwCartridge[CMY][THOLD_WIPE_CNT];
            break;
         }
      }
      break;

   case LS_KCM_CARTRIDGE :
      for (bI=0; bI<3; bI++)
      {
         if ( lpxLSData->adwColor[KCM][bI][PRINT_DOT_CNT] >
              lpxLSData->adwCartridge[KCM][THOLD_DOT_CNT] )
         {
            fMaintenanceRequired  = TRUE;
            lpxLSData->dwSpitCount=lpxLSData->adwCartridge[KCM][THOLD_SPIT_CNT];
            lpxLSData->dwWipeCount=lpxLSData->adwCartridge[KCM][THOLD_WIPE_CNT];
            break;
         }
      }
      break;
   }  /* end of checking dotcounts */



   /* Check to see if we should perform maintenance based on the elapsed   */
   /* time since the last maintenance cycle.                               */

   /* CMY head */
   if ( (fMaintenanceRequired == FALSE) &&
        (lpxLSXface->bColorPlanes != 1) &&
        ( (lpxLSData->bPrimaryCartridgeID   == LS_CMY_CARTRIDGE) || 
          (lpxLSData->bSecondaryCartridgeID == LS_CMY_CARTRIDGE) ) )  
   {
      dwIdleTime = dwTime - lpxLSData->adwCartridge[CMY][LAST_SPIT_TIME];
      if (dwIdleTime >= lpxLSData->adwCartridge[CMY][MAX_IDLE_TIME])
      {
         /* we may need to perform idle time maintenance, if any of the CMY   */
         /* colors haven't been used since last maintenance spit.             */
         for (bI=0; bI<3; bI++)
         {
            if (lpxLSData->adwColor[CMY][bI][IDLE_DOT_CNT] == 0)
            {
               fMaintenanceRequired  = TRUE;
               lpxLSData->dwSpitCount=lpxLSData->adwCartridge[CMY][IDLE_SPIT_CNT];
               lpxLSData->dwWipeCount=lpxLSData->adwCartridge[CMY][IDLE_WIPE_CNT];
               break;
            }
         }
      }
   }
   /* end of CMY head idle time maintenance check*/


   /* MONO head */
   if ( (fMaintenanceRequired == FALSE) &&
        (lpxLSXface->bColorPlanes != 3) &&
        ( (lpxLSData->bPrimaryCartridgeID   == LS_MONO_CARTRIDGE) || 
          (lpxLSData->bSecondaryCartridgeID == LS_MONO_CARTRIDGE) ) )
   {
      dwIdleTime = dwTime - lpxLSData->adwCartridge[MONO][LAST_SPIT_TIME];
      if (dwIdleTime >= lpxLSData->adwCartridge[MONO][MAX_IDLE_TIME])
      {
         /* we may need to perform idle time maintenance, if MONO head hasn't */
         /* been used since last maintenance spit.                            */
         if (lpxLSData->adwColor[MONO][0][IDLE_DOT_CNT] == 0)
         {
            fMaintenanceRequired  = TRUE;
            lpxLSData->dwSpitCount=lpxLSData->adwCartridge[MONO][IDLE_SPIT_CNT];
            lpxLSData->dwWipeCount=lpxLSData->adwCartridge[MONO][IDLE_WIPE_CNT];
         }
      }
   }
   /* end of MONO head idle time maintenance check*/

   /* KCM head */
   if ( (fMaintenanceRequired == FALSE) &&
        (lpxLSData->bSecondaryCartridgeID == LS_KCM_CARTRIDGE) )
   {
      dwIdleTime = dwTime - lpxLSData->adwCartridge[KCM][LAST_SPIT_TIME];
      if (dwIdleTime >= lpxLSData->adwCartridge[KCM][MAX_IDLE_TIME])
      {
         /* we may need to perform idle time maintenance, if any of the CMY   */
         /* colors haven't been used since last maintenance spit.             */
         for (bI=0; bI<3; bI++)
         {
            if (lpxLSData->adwColor[KCM][bI][IDLE_DOT_CNT] == 0)
            {
               fMaintenanceRequired  = TRUE;
               lpxLSData->dwSpitCount=lpxLSData->adwCartridge[KCM][IDLE_SPIT_CNT];
               lpxLSData->dwWipeCount=lpxLSData->adwCartridge[KCM][IDLE_WIPE_CNT];
               break;
            }
         }
      }
   }
   /* end of KCM head idle time maintenance check*/

   return (fMaintenanceRequired);

}  /* end of MaintenanceRequired() */




/*******************************************************************************
 * Function Name:    MoveCarrierOffPage
 *
 * Description:
 *    This function will move the carrier off the edge of the paper, either
 *    towards the home position or away from the home position, depending on 
 *    which move will be shorter.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *
 * Outputs: none.
 *
 * Original Author: J. Bates
 * Date: 11/01/99
 *
 ******************************************************************************/
void MoveCarrierOffPage(LPLSINTFACE lpxLSXface, ByteType bPosition)
{
   LPLSDATA       lpxLSData;
   WordType       wCarrierStopPosition;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   if ( (bPosition == MCOP_CLOSEST_POSITION) &&
        (lpxLSData->wCurrCarrPos > PAPER_MIDPOINT) )
   {
      /* move carrier off the page away from the maintenance station */

      /* move carrier to within 1/4" of the right side frame */
      wCarrierStopPosition = LEFT_SIDE_FRAME_POSITION + 
                             MAX_CARRIER_TRAVEL_DIST - 300;

      if (lpxLSData->wCurrCarrPos >= wCarrierStopPosition)
      {
         /* do nothing, carrier is already off the page */
      }
      else if ( lpxLSData->wCurrCarrPos < (wCarrierStopPosition -
           AlphaDistance(lpxLSXface,SPEED_FAST,ACCEL+DECEL)) )
      {
         lpxLSData->wPosCarrStopPosition  = wCarrierStopPosition;
         lpxLSData->bPosCarrDirection     = LS_LTOR;
         lpxLSData->wPosCarrSpeed         = SPEED_FAST;
         CarrierMoveCmd(lpxLSXface, LS_LTOR, LS_RTOL);
      }
      else if ( lpxLSData->wCurrCarrPos < (wCarrierStopPosition -
           AlphaDistance(lpxLSXface,SPEED_NORMAL,ACCEL+DECEL)) )
      {
         lpxLSData->wPosCarrStopPosition  = wCarrierStopPosition;
         lpxLSData->bPosCarrDirection     = LS_LTOR;
         lpxLSData->wPosCarrSpeed         = SPEED_NORMAL;
         CarrierMoveCmd(lpxLSXface, LS_LTOR, LS_RTOL);
      }
      else if ( lpxLSData->wCurrCarrPos < (wCarrierStopPosition -
           AlphaDistance(lpxLSXface,SPEED_SLOW,ACCEL+DECEL)) )
      {
         lpxLSData->wPosCarrStopPosition  = wCarrierStopPosition;
         lpxLSData->bPosCarrDirection     = LS_LTOR;
         lpxLSData->wPosCarrSpeed         = SPEED_SLOW;
         CarrierMoveCmd(lpxLSXface, LS_LTOR, LS_RTOL);
      }
      else
      {
         /* we must move the carrier back onto the page slightly, so we have  */
         /* enough accel/decel distance to move it back off the page.         */
         lpxLSData->wPosCarrStopPosition  = lpxLSData->wCurrCarrPos - 
                              AlphaDistance(lpxLSXface,SPEED_SLOW,ACCEL+DECEL);
         lpxLSData->bPosCarrDirection     = LS_RTOL;
         lpxLSData->wPosCarrSpeed         = SPEED_SLOW;
         CarrierMoveCmd(lpxLSXface, LS_RTOL, LS_LTOR);

         lpxLSData->wPosCarrStopPosition  = wCarrierStopPosition;
         lpxLSData->bPosCarrDirection     = LS_LTOR;
         lpxLSData->wPosCarrSpeed         = SPEED_SLOW;
         CarrierMoveCmd(lpxLSXface, LS_LTOR, LS_RTOL);
      }
   }
   else
   {
      /* move carrier off the page toward the maintenance station */

      /* First try sending at fast speed, then at normal speed. If both       */
      /* speeds require too much ramp-up/down distance, then the carrier is   */
      /* already off the page.                                                */
      if ( lpxLSData->wCurrCarrPos >(lpxLSData->wSpitPosition +
           AlphaDistance(lpxLSXface,SPEED_FAST,ACCEL+DECEL)) )
      {
         lpxLSData->wPosCarrStopPosition  = lpxLSData->wSpitPosition;
         lpxLSData->bPosCarrDirection     = LS_RTOL;
         lpxLSData->wPosCarrSpeed         = SPEED_FAST;
         CarrierMoveCmd(lpxLSXface, LS_RTOL, LS_LTOR);
      }
      else if ( lpxLSData->wCurrCarrPos >(lpxLSData->wSpitPosition +
           AlphaDistance(lpxLSXface,SPEED_NORMAL,ACCEL+DECEL)) )
      {
         lpxLSData->wPosCarrStopPosition  = lpxLSData->wSpitPosition;
         lpxLSData->bPosCarrDirection     = LS_RTOL;
         lpxLSData->wPosCarrSpeed         = SPEED_NORMAL;
         CarrierMoveCmd(lpxLSXface, LS_RTOL, LS_LTOR);
      }
   }

   return;

}




/*******************************************************************************
 * Function Name:    NullCmd
 *
 * Description:
 *    This function adds the null command to the command queue.  The null
 *    command is not used by the printer, but it is used by the dosbox pcl
 *    emulator to determine a preformatted print job.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *
 * Outputs: none.
 *
 * Original Author: J. Bates
 * Date: 10/06/98
 *
 ******************************************************************************/
void NullCmd(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   lpbCmd[0] = CMD_START_BYTE;
   lpbCmd[1] = NULL_CMD;
   lpbCmd[2] = 0x80;
   lpbCmd[3] = 0;
   lpbCmd[4] = 0;
   lpbCmd[5] = 0;
   lpbCmd[6] = 0;
   lpbCmd[7] = Checksum(lpbCmd);

   lpxLSData->wCmdLength += COMMAND_SIZE;

   return;

}  /* end of NullCmd() */




/*******************************************************************************
 * Function Name:    PageInformationCmd
 *
 * Description:
 *    This function adds the page information command to the command buffer.
 *    The paper load pinch point and top-of-form (TOF) values are based on the
 *    media size.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *
 * Outputs: none
 *
 * Original Author: J. Bates
 * Date: 06/25/98
 *
 ******************************************************************************/
void PageInformationCmd(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;
   WordType       wPinchPoint,
                  wTOF;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   switch (lpxLSXface->bMediaSize)
   {
   case LS_PAPER_LETTER :
   default              : 
      wPinchPoint = lpxLSData->wPinchPointLetter;
      wTOF        = lpxLSData->wTopOfFormLetter;
      break;
   case LS_PAPER_OHFHAGAKI   :
   case LS_PAPER_HAGAKI      :
      wPinchPoint = lpxLSData->wPinchPointHagaki;
      wTOF        = lpxLSData->wTopOfFormHagaki;
      break;
   case LS_ENVELOPE_MONARCH  :
   case LS_ENVELOPE_9        :
   case LS_ENVELOPE_10       :
   case LS_ENVELOPE_DL       :
   case LS_ENVELOPE_C5       :
   case LS_ENVELOPE_B5       :
   case LS_ENVELOPE_C6       :
   case LS_ENVELOPE_D5       :
   case LS_ENVELOPE_75       :
   case LS_ENVELOPE_BARONIAL :
   case LS_ENVELOPE_6_3_4    :
   case LS_ENVELOPE_CUSTOM   :
   case LS_JPNLONG3          :
   case LS_JPNSQUARE4        :
   case LS_JPNSQUARE5        :
   case LS_JPNSQUARE6        :
      wPinchPoint = lpxLSData->wPinchPointEnvelope;
      wTOF        = lpxLSData->wTopOfFormEnvelope;
      break;
   }

   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   lpbCmd[0] = CMD_START_BYTE;
   lpbCmd[1] = PAGE_INFORMATION_CMD;
   lpbCmd[2] = 0x00;
   lpbCmd[3] = HIBYTE(wPinchPoint);
   lpbCmd[4] = LOBYTE(wPinchPoint);
   lpbCmd[5] = HIBYTE(wTOF);
   lpbCmd[6] = LOBYTE(wTOF);
   lpbCmd[7] = Checksum(lpbCmd);

   lpxLSData->wCmdLength += COMMAND_SIZE;

   return;

}  /* end of function PageInformationCmd() */




/*******************************************************************************
 * Function Name:    PositionCarrierToPrint
 *
 * Description:
 *    This function determines the print direction, start position, and stop
 *    position taking into account the acceleration and deceleration distances
 *    for the carrier move given the print speed.  It also checks the current
 *    carrier position and calculates a position move if required.  All
 *    calculations are using 1/1200" units.  Note that LEFT/RIGHT and the
 *    carrier position increment/decrement is with respect to the page, not the
 *    printer ( page LEFT and RIGHT is reversed from printer LEFT and RIGHT).
 *
 *
 * Inputs:  lpxLSXface        Long pointer to logic seek interface structure.
 *          swLeftPrintPos    The left print position for this swath, in 1200dpi
 *          swRightPrintPos   The right print position for this swath, in
 *                            1200dpi
 *          bPrintHead        Which printhead this swath will use
 *          bPrintDir         The print direction for this swath.  Note that
 *                            this value should only be LS_LTOR or LS_RTOL.  It
 *                            should never be LS_BIDI.
 *
 * Outputs: None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 ******************************************************************************/
void PositionCarrierToPrint(LPLSINTFACE lpxLSXface,SwordType swLeftPrintPos,
            SwordType swRightPrintPos, ByteType bPrinthead, ByteType bPrintDir)
{
   LPLSDATA       lpxLSData;
   WordType       wCarrierStartPos,
                  wCarrierStopPos,
                  wCurrCarrPos,    /* current carrier position  */
                  wAccelDist,
                  wDecelDist,
                  wMinimumMove,
                  wMinMoveFast,
                  wMinMoveNormal,
                  wMinMoveSlow,
                  wPrintStartPos,
                  wPrintStopPos;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   /* assume initially that no move will be required to position carrier for  */
   /* printing                                                                */
   lpxLSData->bPosCarrDirection     = NO_DIRECTION;
   lpxLSData->wPosCarrStopPosition  = 0;
   lpxLSData->wPosCarrSpeed         = SPEED_STOPPED;


   if (swRightPrintPos < swLeftPrintPos)
   {
      return;
   }


   /* Save the print speed : on Madrid, high and normal quality are printed at   */
   /* same (normal) speed.  Slow speed is only used for carrier positioning      */
   if ( lpxLSXface->bPrintQuality == LS_QUALITY_HIGH || 
        lpxLSXface->bPrintQuality == LS_QUALITY_NORMAL )
   {
      lpxLSData->wPrtCarrSpeed = SPEED_NORMAL;
   }
   else  /* QUALITY_DRAFT */
   {
      lpxLSData->wPrtCarrSpeed = SPEED_FAST;
   }


   /* get maximum acceleration distance from hardware specific routine */
   wAccelDist = AlphaDistance(lpxLSXface, lpxLSData->wPrtCarrSpeed,(ACCEL+ALPHA_A));
   wDecelDist = AlphaDistance(lpxLSXface, lpxLSData->wPrtCarrSpeed,(DECEL+ALPHA_D));


   wCurrCarrPos = lpxLSData->wCurrCarrPos;


   /* +8 is because we want to move at least 1 step more than the       */
   /* shortest move distance                                            */
   wMinMoveFast   = AlphaDistance(lpxLSXface,SPEED_FAST,  ACCEL+DECEL)+8;
   wMinMoveNormal = AlphaDistance(lpxLSXface,SPEED_NORMAL,ACCEL+DECEL)+8;
   wMinMoveSlow   = AlphaDistance(lpxLSXface,SPEED_SLOW,  ACCEL+DECEL)+8;


   if (bPrintDir == LS_LTOR)
   {
      /* convert print positions from hbp relative position to carrier system */
      /* absolute position.                                                   */
      wPrintStartPos = PrintPos(lpxLSXface,bPrinthead,swLeftPrintPos,LS_LTOR);
      wPrintStopPos  = PrintPos(lpxLSXface,bPrinthead,swRightPrintPos,LS_LTOR);
      wCarrierStartPos = wPrintStartPos - wAccelDist;
      wCarrierStopPos  = wPrintStopPos + wDecelDist;

      lpxLSData->bPrtCarrDirection     = LS_LTOR;
      lpxLSData->wPrtStartPosition     = wPrintStartPos;
      lpxLSData->wPrtCarrStopPosition  = wCarrierStopPos;


      if (wCurrCarrPos  > wCarrierStartPos)
      {
         /* we need to perform a carrier move toward the maintenance          */
         /* station (RTOL) before printing this swath away from the           */
         /* maintenance station (LTOR).                                       */

         wMinimumMove = wCurrCarrPos - wCarrierStartPos;

         if (wMinimumMove >= wMinMoveFast)
         {  /* perform the carrier move at FAST speed */
            lpxLSData->wPosCarrSpeed = SPEED_FAST;
         }
         else if (wMinimumMove >= wMinMoveNormal)
         {  /* perform the carrier move at NORMAL speed */
            lpxLSData->wPosCarrSpeed = SPEED_NORMAL;
         }
         else if (wMinimumMove >= wMinMoveSlow)
         {  /* perform the carrier move at SLOW speed */
            lpxLSData->wPosCarrSpeed = SPEED_SLOW;
         }
         else if ((wCurrCarrPos - wMinMoveSlow) >= lpxLSData->wLeftPrintLimit)
         {  /* adjust the positioning so we cam move at SLOW speed */
            wCarrierStartPos = wCurrCarrPos - wMinMoveSlow;
            lpxLSData->wPosCarrSpeed = SPEED_SLOW;
         }
         else
         {  /* We are too close to the home position.  We will first have to  */
            /* move away from the home position (LTOR), and then move back    */
            /* toward the home position.                                      */
            lpxLSData->bPosCarrDirection     = LS_LTOR;
            lpxLSData->wPosCarrSpeed         = SPEED_SLOW;
            lpxLSData->wPosCarrStopPosition  = wCurrCarrPos + wMinMoveSlow;
            CarrierMoveCmd(lpxLSXface, LS_LTOR, LS_RTOL);

            /* now we can move back toward the home position to prepare for   */
            /* printing LTOR.                                                 */
            lpxLSData->wPosCarrSpeed         = SPEED_SLOW;
            lpxLSData->wPosCarrStopPosition  = wCarrierStartPos;
         }

         if (lpxLSData->wPosCarrSpeed != SPEED_STOPPED)
         {
            lpxLSData->bPosCarrDirection     = LS_RTOL;
            lpxLSData->wPosCarrStopPosition  = wCarrierStartPos;
            CarrierMoveCmd(lpxLSXface, LS_RTOL, LS_LTOR);
         }
      }
   }  /* end of if (bPrintDir == LS_LTOR) */
   else
   {  /* bPrintDir = LS_RTOL */
      /* convert print positions from hbp relative position to carrier system */
      /* absolute position.                                                   */
      wPrintStartPos = PrintPos(lpxLSXface,bPrinthead,swRightPrintPos,LS_RTOL);
      wPrintStopPos  = PrintPos(lpxLSXface,bPrinthead,swLeftPrintPos,LS_RTOL);
      wCarrierStartPos = wPrintStartPos + wAccelDist;
      wCarrierStopPos  = wPrintStopPos  - wDecelDist;

      lpxLSData->bPrtCarrDirection     = LS_RTOL;
      lpxLSData->wPrtStartPosition     = wPrintStartPos;
      lpxLSData->wPrtCarrStopPosition  = wCarrierStopPos;

      if (wCurrCarrPos < wCarrierStartPos)
      {
         /* we need to perform a carrier move away from the maintenance       */
         /* station (LTOR) before printing this swath toward the              */
         /* maintenance station (RTOL).                                       */
      
         wMinimumMove = wCarrierStartPos - wCurrCarrPos;

         if (wMinimumMove >= wMinMoveFast)
         {  /* perform the carrier move at FAST speed */
            lpxLSData->wPosCarrSpeed = SPEED_FAST;
         }
         else if (wMinimumMove >= wMinMoveNormal)
         {  /* perform the carrier move at NORMAL speed */
            lpxLSData->wPosCarrSpeed = SPEED_NORMAL;
         }
         else if (wMinimumMove >= wMinMoveSlow)
         {  /* perform the carrier move at SLOW speed */
            lpxLSData->wPosCarrSpeed = SPEED_SLOW;
         }
         else if ((wCurrCarrPos+wMinMoveSlow) <= lpxLSData->wRightPrintLimit)
         {  /* adjust the positioning so we can move at SLOW speed */
            wCarrierStartPos = wCurrCarrPos + wMinimumMove;
            lpxLSData->wPosCarrSpeed = SPEED_SLOW;
         }
         else
         {  /* We are too close to the right frame.  We will first have to    */
            /* move away from the right frame (RTOL), and then move back      */
            /* toward the right frame.                                        */
            lpxLSData->bPosCarrDirection     = LS_RTOL;
            lpxLSData->wPosCarrSpeed         = SPEED_SLOW;
            lpxLSData->wPosCarrStopPosition  = wCurrCarrPos - wMinimumMove;
            CarrierMoveCmd(lpxLSXface, LS_RTOL, LS_LTOR);

            /* now we can move back toward the right frame to prepare for     */
            /* printing RTOL.                                                 */
            lpxLSData->wPosCarrSpeed         = SPEED_SLOW;
            lpxLSData->wPosCarrStopPosition  = wCarrierStartPos;
         }

         if (lpxLSData->wPosCarrSpeed != SPEED_STOPPED)
         {
            lpxLSData->bPosCarrDirection     = LS_LTOR;
            lpxLSData->wPosCarrStopPosition  = wCarrierStartPos;
            CarrierMoveCmd(lpxLSXface, LS_LTOR, LS_RTOL);
         }
      }  /* end of if (wCurrCarrPos < wCarrierStartPos) */
   }  /* end of bPrintDir== LS_RTOL */

   return;

}  /* end of PositionCarrierToPrint() */




/*******************************************************************************
 * Function Name:    PrintPos
 *
 * Description:
 *    This function changes the print position from an hbp value relative to the
 *    left paper edge, to an absolute carrier position, taking into account
 *    head alignment, bidi alignment, and print direction.
 *
 *
 * Inputs:  lpxLSXface        long pointer to hpc interface structure
 *          bHead             print head used
 *          swPrintPosition   the print position, in 1200dpi relative to the
 *                            left paper edge
 *          bDirection        direction this swath will be printed in
 *
 * Outputs: the absolute carrier position to start printing this swath.
 *
 * Major Functions Called:    None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 ******************************************************************************/
SwordType PrintPos(LPLSINTFACE lpxLSXface, ByteType bHead,
                   SwordType swPrintPosition, ByteType bDirection)
{
   LPLSDATA       lpxLSData;
   SwordType      swAlignTemp;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;


   /* Add the distance from the home position to the left edge of the paper   */
   swPrintPosition += (SwordType)lpxLSData->wLeftPaperEdge;

   if ( (bHead == LS_MONO_CARTRIDGE) || (bHead == LS_KCM_CARTRIDGE) )
   {
      swPrintPosition += (SwordType)lpxLSData->wMonoPosOffset;

      /* Bidi Mono Alignment Compensation */
      if( bDirection == LS_RTOL )
      {
         swAlignTemp = (SwordType)((SwordType)lpxLSXface->bBidiAlignMono - 15);
         if ( (bHead == LS_MONO_CARTRIDGE) && (lpxLSXface->bPrintQuality == LS_QUALITY_DRAFT) )
         {
            swAlignTemp += MONO_DRAFT_BIDI_ADJUST;
         }
         swPrintPosition += swAlignTemp;
      }
   }
   else
   {  /* CMY head */
      swPrintPosition -= (SwordType)lpxLSData->wColorPosOffset;

#if !(HEAD_SWAPPER)
      /* Horizontal Alignment Compensation */
      swAlignTemp = (SwordType)((SwordType)lpxLSXface->bHorizontalAdj - 15);
      swPrintPosition += swAlignTemp;
#endif

      /* Bidi Color Alignment Compensation */
      if (bDirection == LS_LTOR)
      {
         swAlignTemp = (15 - (SwordType)lpxLSXface->bBidiAlignColor);
         swPrintPosition += swAlignTemp;
      }
   }


   /* Nominal compensation for reverse printing lag */
   if (bDirection == LS_RTOL)
   {
      swPrintPosition -= DIR_LAG_COMPENSATION;
   }


   return (swPrintPosition);

}  /* end of PrintPos() */




/*******************************************************************************
 * Function Name:    RampTableInformationCmd
 *
 * Description:
 *    This function is called to send the ramp table information commands, 
 *    including the ramp table data for paper feed and carrier movement, to the
 *    printer.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: J. Bates
 * Date: 07/22/98
 *
 ******************************************************************************/
void RampTableInformationCmd(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;
   WordType       wN;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   if ((lpxLSData->wCmdLength+COMMAND_SIZE+RAMP_DATA_SIZE)>COMMAND_BUFFER_SIZE)
   {
      /* there is not enough space left in the command buffer to add the      */
      /* paper feed ramp table command and data.                              */
      return;
   }

   /* add paper feed ramp download command to the command buffer              */
   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   lpbCmd[0] = CMD_START_BYTE;
   lpbCmd[1] = RAMP_INFO_CMD;
   lpbCmd[2] = 0x00;
   lpbCmd[3] = (ByteType) ((RAMP_DATA_SIZE & 0x0000FF00) >> 8);
   lpbCmd[4] = (ByteType)  (RAMP_DATA_SIZE & 0x000000FF);
   lpbCmd[5] = 0;
   lpbCmd[6] = 0;
   lpbCmd[7] = Checksum(lpbCmd);

   lpxLSData->wCmdLength += COMMAND_SIZE;


   /* add paper feed ramp data to command buffer                              */
   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   for (wN=0; wN<RAMP_DATA_SIZE; wN++)
   {
      lpbCmd[wN] = lpxLSData->abRampData[wN];
   }
   lpxLSData->wCmdLength += RAMP_DATA_SIZE;

   return;

}  /* end of RampTableInformationCmd() */




/****************************************************************************
*  ReturnInformationCmd()                            Lexmark Confidential
*
*  Description:
*
*
*
*
******************************************************************************/
void ReturnInformationCmd(LPLSINTFACE lpxLSXface, ByteType bCarrierDirection,
                          ByteType bNextCarrierDirection)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;
   WordType       wCarrPos,
                  wNumCarrStep,
                  wVertMove;
   ByteType       bCarrSpeed,
                  bDir;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;


   if ( (lpxLSData->fMaintenanceRequired == TRUE) &&
        (lpxLSData->wCurrCarrPos <= lpxLSData->wLeftPaperEdge) )
   {
      /* We will perform maintenance the next time LSSwathCmd() is called,    */
      /* and the carrier is already in the correct position.  So don't move   */
      /* the carrier in the Return Information Command.                       */
      lpxLSData->bPosCarrDirection     = NO_DIRECTION;
      lpxLSData->wPosCarrStopPosition  = 0;
      lpxLSData->wPosCarrSpeed         = SPEED_STOPPED;
   }


   if (bCarrierDirection == LS_LTOR )
   {
      bDir = FORWARD_CAR_RETURN;
   }
   else
   {
      bDir = REVERSE_CAR_RETURN;
   }


   /* This is a return move to position carrier for next swath.   Therefore,  */
   /* the PosCarr variables contain the correct start and stop positions to   */
   /* position the carrier.                                                   */

   if (lpxLSData->wPosCarrSpeed != SPEED_STOPPED)
   {
      if ( (lpxLSData->fMaintenanceRequired == TRUE) && 
           (lpxLSData->bPosCarrDirection == LS_RTOL) )
      {
         if (lpxLSData->wPosCarrStopPosition > lpxLSData->wSpitPosition)
         {
            lpxLSData->wPosCarrStopPosition = lpxLSData->wSpitPosition;
         }
      }

      wCarrPos     = lpxLSData->wCurrCarrPos;
      wNumCarrStep = CalcConstantSteps(lpxLSXface, &wCarrPos,
                     lpxLSData->wPosCarrStopPosition, lpxLSData->wPosCarrSpeed,
                     bCarrierDirection, bNextCarrierDirection);
      lpxLSData->wCurrCarrPos = wCarrPos;

      lpxLSData->bLastCarrDir = bCarrierDirection;

   }
   else
   {
      wNumCarrStep = 0;
   }

   if (lpxLSXface->xSwath.dwNextVertMoveBeforePrint > 0xFFFF)
   {
      if (lpxLSXface->xSwath.dwNextVertMoveBeforePrint < 0x1FFFE)
      {
         wVertMove = (WordType)(lpxLSXface->xSwath.dwNextVertMoveBeforePrint/2);
      }
      else
      {
         wVertMove = 0xFFFF;
      }
      lpxLSData->dwVertMovePending =
                     (lpxLSXface->xSwath.dwNextVertMoveBeforePrint - wVertMove);
   }
   else
   {
      wVertMove = (WordType)lpxLSXface->xSwath.dwNextVertMoveBeforePrint;
   }


   /* keep track of where we are vertically on the page */
   lpxLSData->dwPaperStepCount += wVertMove;


   switch (lpxLSData->wPosCarrSpeed)
   {
   case SPEED_FAST :
      bCarrSpeed = RETURN_INFO_RETSPEED_FAST;
      break;
   case SPEED_NORMAL :
   default           :
      bCarrSpeed = RETURN_INFO_RETSPEED_MEDIUM;
      break;
   case SPEED_SLOW :
      bCarrSpeed = RETURN_INFO_RETSPEED_SLOW;
      break;
   }


   /* Reset the variables */

   lpxLSData->bPosCarrDirection     = NO_DIRECTION;
   lpxLSData->wPosCarrStopPosition  = 0;
   lpxLSData->wPosCarrSpeed         = SPEED_STOPPED;


   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   lpbCmd[0] = CMD_START_BYTE;
   lpbCmd[1] = RETURN_INFORMATION_CMD;
   lpbCmd[2] = (ByteType) ( bCarrSpeed | bDir | RETURN_FEED_NORMAL );
   lpbCmd[3] = HIBYTE(wNumCarrStep);
   lpbCmd[4] = LOBYTE(wNumCarrStep);
   lpbCmd[5] = HIBYTE(wVertMove);
   lpbCmd[6] = LOBYTE(wVertMove);
   lpbCmd[7] = Checksum(lpbCmd);

   lpxLSData->wCmdLength += COMMAND_SIZE;

   return;

}  /* end of ReturnInformationCmd() */




/*******************************************************************************
 * Function Name:    SendCartridgeHome
 *
 * Description:
 *    This function adds the cartridge home (cap) command to the command
 *    buffer.  The carrier position kept in our internal data structure
 *    is also updated to the maintenance cap position.
 *
 * Inputs:  lpxLSXface     Long pointer to logic seek interface structure.
 *
 * Outputs: none
 *
 * Original Author: J. Bates
 * Date: 06/25/98
 *
 ******************************************************************************/
void SendCartridgeHome(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   lpbCmd[0] = CMD_START_BYTE;
   lpbCmd[1] = CAP_CMD;
   lpbCmd[2] = 0;
   lpbCmd[3] = 0;
   lpbCmd[4] = 0;
   lpbCmd[5] = 0;
   lpbCmd[6] = 0;
   lpbCmd[7] = Checksum(lpbCmd);

   lpxLSData->wCmdLength += COMMAND_SIZE;

   lpxLSData->wCurrCarrPos = LEFT_SIDE_FRAME_POSITION;

   return;

}  /* end of function SendCartridgeHome() */




void SwathDataCmd(LPLSINTFACE lpxLSXface)
{
   LPLSDATA       lpxLSData;
   LPByteType     lpbCmd;
   DwordType      dwSize;
   SwordType      swPrintPos;

   lpxLSData  = (LPLSDATA)lpxLSXface->lpLSDevice;
   dwSize     = lpxLSXface->xSwath.dwSwathLength;


   if (lpxLSXface->xSwath.bPrintDirection == LS_LTOR )
   {
      swPrintPos = PrintPos(lpxLSXface,lpxLSXface->xSwath.bPrintHead,
                            lpxLSXface->xSwath.swLeftPrintPos,LS_LTOR);
   }
   else
   {
      swPrintPos = PrintPos(lpxLSXface,lpxLSXface->xSwath.bPrintHead,
                            lpxLSXface->xSwath.swRightPrintPos,LS_RTOL);
   }


   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   lpbCmd[0] = CMD_START_BYTE;
   lpbCmd[1] = SWATH_DATA_CMD;
   lpbCmd[2] = (ByteType) ((dwSize & 0x00FF0000) >> 16);
   lpbCmd[3] = (ByteType) ((dwSize & 0x0000FF00) >> 8);
   lpbCmd[4] = (ByteType)  (dwSize & 0x000000FF);
   lpbCmd[5] = HIBYTE(swPrintPos);
   lpbCmd[6] = LOBYTE(swPrintPos);
   lpbCmd[7] = Checksum(lpbCmd);

   lpxLSData->wCmdLength += COMMAND_SIZE;

   return;

}  /* end of SwathDataCmd() */




/*******************************************************************************
 * Function Name:    SwathInformationCmd
 *
 * Description:
 *    This function outputs the swath data and buffer to the
 *    printer in the expected format.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 ******************************************************************************/
void SwathInformationCmd(LPLSINTFACE lpxLSXface, ByteType bCarrierDirection,
                         ByteType bNextCarrierDirection)
{

   LPLSDATA       lpxLSData;
   ByteType       abPrinterCmd[COMMAND_SIZE] =
                      {CMD_START_BYTE,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPByteType     lpbCmd;
   WordType       wCarrPos,
                  wNumCarrStep;
   DwordType      dwSwathDotCount,
                  dwSwathDotPct;
   ByteType bDir;
   ByteType bHead;
   ByteType bRes;
   ByteType bSliceBytes;
   ByteType bPercentNozzles;

   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;

   if ( (lpxLSXface->xSwath.bPrintHead == LS_MONO_CARTRIDGE) ||
        (lpxLSXface->xSwath.bPrintHead == LS_KCM_CARTRIDGE) )
   {
      bHead = MONO_HEAD;
   }
   else
   {
      bHead = COLOR_HEAD;
   }

   switch (lpxLSXface->xSwath.bResolution)
   {
   case LS_300_DPI :
      if (lpxLSData->wPrtCarrSpeed == SPEED_FAST)
      {
         bRes = SWATH_INFO_300DPI_FASTSPEED;
      }
      else
      {
         bRes = SWATH_INFO_300DPI_MEDSPEED;
      }
      break;
   case LS_600_DPI :
   default         :
      bRes = SWATH_INFO_600DPI_MEDSPEED;
      break;
   case LS_1200_DPI :
      bRes = SWATH_INFO_1200DPI_MEDSPEED;
      break;
   }

   if (lpxLSXface->xSwath.bBytesPerSlice == 24)
   {
      bSliceBytes = BYTES_24;
   }
   else
   {
      bSliceBytes = BYTES_26;
   }

   dwSwathDotCount = lpxLSData->dwSwathDotCount;

   if (lpxLSXface->xSwath.bPrintHead == LS_MONO_CARTRIDGE)
   {
      dwSwathDotPct = (dwSwathDotCount*16)/MAX_MONO_DOTS;
   }
   else
   {
      dwSwathDotPct = (dwSwathDotCount*16)/MAX_COLOR_DOTS;
   }

   switch (dwSwathDotPct)
   {
   case 0 :    /* < 1/16 */
      bPercentNozzles = ONE_SIXTEENTH;
      break;
   case 1 :    /* < 2/16 */
      bPercentNozzles = TWO_SIXTEENTHS;
      break;
   case 2 :    /* < 2/16 */
      bPercentNozzles = THREE_SIXTEENTHS;
      break;
   case 3 :    /* < 2/16 */
      bPercentNozzles = FOUR_SIXTEENTHS;
      break;
   case 4 :    /* < 2/16 */
      bPercentNozzles = FIVE_SIXTEENTHS;
      break;
   case 5 :    /* < 2/16 */
      bPercentNozzles = SIX_SIXTEENTHS;
      break;
   case 6 :    /* < 2/16 */
      bPercentNozzles = SEVEN_SIXTEENTHS;
      break;
   default :
      bPercentNozzles = EIGHT_SIXTEENTHS;
      break;
   }


   if (bCarrierDirection == LS_LTOR )
   {
      bDir = FORWARD_PRINT;
   }
   else
   {
      bDir = REVERSE_PRINT;
   }


   /* This is a print move to move the carrier to print the swath.            */
   /* Therefore, the PrtCarr variables contain the correct start and stop     */
   /* positions for the carrier.                                              */
   wCarrPos     = lpxLSData->wCurrCarrPos;
   wNumCarrStep = CalcConstantSteps(lpxLSXface,&wCarrPos,
                  lpxLSData->wPrtCarrStopPosition,lpxLSData->wPrtCarrSpeed,
                  bCarrierDirection, bNextCarrierDirection);
   lpxLSData->wCurrCarrPos = wCarrPos;


   lpxLSData->bLastCarrDir = bCarrierDirection;


   lpxLSData->bPrtCarrDirection     = NO_DIRECTION;
   lpxLSData->wPrtCarrStopPosition  = 0;
   lpxLSData->wPrtCarrSpeed         = SPEED_STOPPED;


   lpbCmd    = lpxLSData->lpbCmd + lpxLSData->wCmdLength;
   lpbCmd[0] = CMD_START_BYTE;
   if (lpxLSXface->xSwath.fCompress == TRUE)
   {
      lpbCmd[1] = SWATH_INFO_CMPRD_CMD;
   }
   else
   {
      lpbCmd[1] = SWATH_INFO_NONCP_CMD;
   }
   lpbCmd[2] = (ByteType) (bHead | bRes | bSliceBytes | bDir | bPercentNozzles);
   lpbCmd[3] = HIBYTE(lpxLSXface->xSwath.wSliceCount);
   lpbCmd[4] = LOBYTE(lpxLSXface->xSwath.wSliceCount);
   lpbCmd[5] = HIBYTE(wNumCarrStep);
   lpbCmd[6] = LOBYTE(wNumCarrStep);
   lpbCmd[7] = Checksum(lpbCmd);

   lpxLSData->wCmdLength += COMMAND_SIZE;

   return;

}  /* end of SwathInformationCmd() */




#if defined(CREATE_PRINT_FILE)
void WriteToOutFile(LPLSINTFACE lpxLSXface, HPByteType hpbData,
                    DwordType dwLength)
{
   LPLSDATA       lpxLSData;
   WordType       wI;
   
   lpxLSData = (LPLSDATA)lpxLSXface->lpLSDevice;


   if (lpxLSData->flPrnFile == HFILE_ERROR)
   {
      return;
   }


   for (wI=0; wI<(dwLength/60000L); wI++)
   {
      _lwrite(lpxLSData->flPrnFile,hpbData,(UINT)60000L);
      hpbData += 60000L;
   }


   if ((dwLength % 60000L) != 0)
   {
      _lwrite(lpxLSData->flPrnFile,hpbData,(UINT)(dwLength % 60000L));
      hpbData += 60000L;
   }

   return;

}
#endif
