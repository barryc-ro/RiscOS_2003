/****************************************************************************
 * FCOSAKA.C                                       Lexmark Confidential
 *
 * $Revision$
 * $Date$
 * $Author$
 *
 *
 * Description:
 *    FCOSAKA.C contains all the Osaka printer specific functions.
 *
 *
 * No.   Date     Who  Function              Description of Change
 * --------------------------------------------------------------------------
 * 024  11/02/99  bsp  Change compress to allow REVERSE printing for LTOR
 *      swaths
 * 025  11/02/99  bsp  Removed a bug in the last changes.
 * 026  11/15/99  bsp  Added a function ReverseSwathForRTOL() in OutPutSwath
 *      to fix ptr 29989.
 * 027  01/12/99  bsp  Fixed ptr 32510 by disabling ExpandSwathTo8Inches()
 * 028  01/18/00  bsp  Added an if statement in OutputSwath() to ensure
 *      paper feed on white spaces are always divisible by 4.
 * 029  02/14/00  bsp  ptr 34569, 33% shingle mode applied for Greeting_Stock
 *      and Transparency.
 * 030  03/08/00  bsp  Turned on function ExpandSwathTo8Inches() to eliminate
 *      smearing problems in envelope printing.
 * 031  03/10/00  bsp  resolved GPF in banner printing.
 * 032  04/04/00  bsp  Copied GetTopMargin() from fcvienna.c and added
 *      fudge factor for hires mono printing for top margin.
 * 033  04/17/00  wlc  Changes to workaround bug 39148. ECP mode drops bytes
 *      when OUTPUT() is called with 17 to 68 bytes.  I combined the swath
 *      commands with the swath data so OUTPUT() is called only once with
 *      a larger byte count.  I did this by setting the Swath_Header_Size to
 *      80.
 * 034  04/18/00  wlc  Made final adjustment for top margin in GetTopMargin()
 *      No adjustment required for the left margin.
 * 035  04/20/00  wlc  Removed all buffer padding for bug 39148.  LCS has been
 *      changed to send 16 bytes at a time for block sizes >16 and <69 as a
 *      fix for this problem for all products.
 ****************************************************************************/




/************** Definitions & Macros ***************************************/

#if !defined(NOPRAGMA)
#pragma warning (disable: 4103)  /* used #pragma pack to change alignment  */
#endif




/************** Include Files **********************************************/

#if defined(DOS_BUILD) || defined(FC_DOS_32)
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#endif

#if !defined(FC_WIN_32) && !defined(FC_OS2) &&!defined(FC_WIN32_DLL)
#include <memory.h>
#endif

#if defined(GEN_TEST_INPUT_FILES)
#include <string.h>
#endif

#include "fclocal.h"

/************** Prototype Definitions **************************************/

void      FCSetHeadTypes(LPDVDATAREC lpxDataRec);
SwordType CheckSwathDensity(LPDVDATAREC lpxDataRec);
ByteType  CheckForReverseSwath(LPDVDATAREC lpxDataRec);
void      CreateTwoSwaths(LPDVDATAREC lpxDataRec);
DwordType Compress(LPDVDATAREC lpxDataRec, LPPRTCMD lpxPrtCmd);
void CopyDocInfoToLSXface(LPDVDATAREC lpxDataRec);
void CopySwathInfoToLSXface(LPDVDATAREC lpxDataRec, ByteType bSwathDensity);
DwordType   ExpandSwathTo8Inches(LPDVDATAREC lpxDataRec);

/************** Variable Declarations **************************************/

/* set object module level ID */
static char fc_version[] = "lxadfc $Revision$";

EXTSENDCMD lpfnSendCommand;      /* added to make HBP a DLL */

/****************************************************************************
 * Function Name:    HwStartPrintJob
 *
 * Description:
 *    This function is called at the beginning of a document and
 *    can send the printer any required information for the
 *    job start.  Some printers may not require any special
 *    data to be sent.  The printer specific hardware structure
 *    is also initialized here.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 *
 ***************************************************************************/
void HwStartPrintJob(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   LPHWDATA    lpxHWData;
   LPByteType  lpbCmd;
   SwordType   swRetCode;
   ByteType    bN;

#if defined(TEST)
   FILE       *flOutFile;
#endif

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   if (lpxPFData == NULL)
   {
      return;
   }

   lpxHWData = lpxPFData->lpxHWData;

   lpxHWData->lpxLSXface = (LPLSINTFACE) ALLOCATE_MEMORY(LSINTFACE_SIZE);

   if   (lpxHWData->lpxLSXface == NULL)
   {
      return;
   }

   for (bN=0; bN<6; bN++)
   {
      lpxHWData->adwDotCount[bN] = 0;
   }

   CopyDocInfoToLSXface(lpxDataRec);
   swRetCode = LSStartPrintJob(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode < 0)
   {
      return;
   }
   else if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of HwStartPrintJob() */




/****************************************************************************
 * Function Name:    HwStartPage
 *
 * Description:
 *    This function is called at the beginning of a page and
 *    can send the printer any required information for the
 *    page start.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 *
 ***************************************************************************/
void HwStartPage(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   LPByteType     lpbCmd;
   WordType       wLength;
   SwordType      swRetCode;
   BoolType       fEnableJamDetect = TRUE;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

#if OPTION_600_AS_2X300
   /* New 600 dpi scheme is applied when 600 dpi 50% shingling is desired  */
   if( (lpxPFData->bShingle == SHINGLE_50) && (lpxPFData->bResolution == LORES) )
   {
      lpxPFData->bShingleLoRes = SHINGLE_50;
      lpxPFData->wCMYSwathByPgCtr = 0;
      lpxPFData->wKOrKcmSwathByPgCtr = 0;
   }
   else
   {
      lpxPFData->bShingleLoRes = NO_SHINGLE;
   }
#endif

   switch (lpxDataRec->bMediaSize)
   {
   case PAPER_LETTER:
      wLength = 3300;
      break;
   case PAPER_LEGAL:
      wLength = 4200;
      break;
   case PAPER_B5:
      wLength = 3035;
      break;
   case PAPER_EXECUTIVE:
      wLength = 3150;
      break;
   case PAPER_A5:
      wLength = 2480;
      break;
   case CARD_A6:
      wLength = 1748;
      break;
   case PAPER_USER:
      /* Custom paper can be up to 17" long */
      wLength = 5100;
      break;
   case PAPER_A4:
      wLength = 3510;
      break;
   case PAPER_OHFHAGAKI:
      wLength = 1748;
      break;
   case PAPER_HAGAKI:
      wLength = 1748;
      break;
   case ENVELOPE_9:
      wLength = 2662;
      break;
   case ENVELOPE_10:
      wLength = 2850;
      break;
   case ENVELOPE_DL:
      wLength = 2598;
      break;
   case ENVELOPE_C5:
      wLength = 2703;
      break;
   case ENVELOPE_C6:
      wLength = 1914;
      break;
   case ENVELOPE_D5:
      wLength = 2952;
      break;
   case ENVELOPE_75:
      wLength = 2250;
      break;
   case CARD_3X5:
      wLength = 1500;
      break;
   case CARD_4X6:
      wLength = 1800;
      break;
   case ENVELOPE_BARONIAL:
      wLength = 1314;
      break;
   case ENVELOPE_6_3_4:
      wLength = 1950;
      break;
   case JPNLONG3:
      wLength = 2776;
      break;
   case JPNSQUARE4:
      wLength = 3154;
      break;
   case JPNSQUARE5:
      wLength = 2835;
      break;
   case JPNSQUARE6:
      wLength = 2705;
      break;
   case PAPER_BANNER_A4:
   case PAPER_BANNER_LETTER:
   case PAPER_CUSTOM_BANNER:
      wLength = 3510;
      fEnableJamDetect = FALSE;
      break;
   default :
      /* Custom paper can be up to 17" long */
      wLength = 5100;
         break;
   }  /* end of switch (lpxDataRec->bMediaSize) */


   /* LSEjectCmd expects page length in 1200dpi */
   wLength *= 4;

   CopyDocInfoToLSXface(lpxDataRec);
   lpxPFData->lpxHWData->lpxLSXface->wPageLength = wLength;
   lpxPFData->lpxHWData->lpxLSXface->fEnableJamDetect = fEnableJamDetect;
   swRetCode = LSStartPage(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of HwStartPage() */




/****************************************************************************
 * Function Name:    HwEndPage
 *
 * Description:
 *    This function is called at the end of a page and
 *    can send the printer any required information for the
 *    page end.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 *
 ***************************************************************************/
void HwEndPage(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   LPByteType  lpbCmd;
   SwordType   swRetCode;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   CopyDocInfoToLSXface(lpxDataRec);
   swRetCode = LSEndPage(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of HwEndPage() */




/****************************************************************************
 * Function Name:    HwEndJob
 *
 * Description:
 *    This function is called at the end of a job and
 *    can send the printer any required information for the
 *    job end.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 *
 ***************************************************************************/
void HwEndJob(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   LPByteType  lpbCmd;
   SwordType   swRetCode;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   CopyDocInfoToLSXface(lpxDataRec);

   /* Copy info on canceling a print job, 1 for canceling  */
   lpxPFData->lpxHWData->lpxLSXface->bAbortJob = lpxDataRec->bAbortJob;

   swRetCode = LSEndPrintJob(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   if (lpbCmd != NULL)
   {  /* The hpc code allocated the command buffer, but we are required to    */
      /* deallocate it.                                                       */
      FREE_MEMORY(lpbCmd);
   }

   return;

}  /* end of HwEndJob() */




/****************************************************************************
 * Function Name:    OutputSwath
 *
 * Description:
 *    This function is responsible for everything that needs to
 *    happen when one swath buffer is sent to the printer for
 *    printing.  Linefeed is called to move the paper to the
 *    correct position for the swath followed by the swath
 *    data.
 *
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 *
 ***************************************************************************/
void OutputSwath(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   LPLSINTFACE    lpxLSXface;
   LPByteType     lpbCmd;
   HPByteType     hpbPrtData;
   ByteType       bPreRotateDir,
                  bPreRotatePrintHead,
                  bDirection;
   WordType       i,
                  wIStart,
                  wIEnd,
                  wDenseSwath;
   SwordType      swFutureFormsMovePending,
                  swPreRotateStart,
                  swPreRotateEnd,
                  swRetCode;
   DwordType      j,
                  dwCount,
                  dwCompressLength,
                  dwSize;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;
   lpxLSXface = lpxPFData->lpxHWData->lpxLSXface;
   bDirection = CheckForReverseSwath(lpxDataRec);

   /* if swath is more than one segment, then combine segments */
   if (lpxPFData->wSlicesPerRow > (WordType)SLICES_PER_SEG)
   {
      hpbPrtData = (HPByteType)lpxPFData->lpxPrtCmd + SWATH_HEADER_SIZE;
      if (lpxPFData->alpbSwath[0] == (LPByteType)hpbPrtData)
      {
         hpbPrtData += ((DwordType)SLICES_PER_SEG *
                       (DwordType)lpxPFData->bBytesPerSlice);
         if (lpxPFData->wSliceCount <= (WordType)SLICES_PER_SEG)
         {
            wIStart = (WordType)99;
         }
         else
         {
            wIStart = (WordType)1;
         }
      }
      else
      {
         wIStart = (WordType)0;
      }

      wIEnd = ((lpxPFData->wSliceCount-(WordType)1)/
               (WordType)SLICES_PER_SEG);

      /* now combine all print swath segments into one print swath */
      for (i=wIStart; i<=wIEnd;i++)
      {
         if (i == wIEnd)
         {
            dwCount = ((((DwordType)(lpxPFData->wSliceCount-1)%SLICES_PER_SEG)+
                      1)*(DwordType)lpxPFData->bBytesPerSlice);
         }
         else
         {
            dwCount = ((DwordType)SLICES_PER_SEG * lpxPFData->bBytesPerSlice);
         }

         for (j=0;j<dwCount;j++)
         {
            *hpbPrtData = *(lpxPFData->alpbSwath[i]+j);
            hpbPrtData++;
         }
      }
   }  /* end of combining swath segments into one huge swath */


   if ( (lpxPFData->bResolution == SUPERLOWRES) ||
        (lpxPFData->bResolution == LORES ) )
   {
      lpxPFData->swFormsMovePending       *= 2;
      lpxPFData->swFutureFormsMovePending *= 2;
   }

   /* Below if was added to ensure swFormsMovePending is Divisible by 4 */
   if(lpxPFData->bFirstMoveOnPage ||
            (lpxPFData->swFormsMovePending > ((MONO_NOZZLE_COUNT+4) * 2)) )
   {
      lpxPFData->swFormsMovePending -= (lpxPFData->swFormsMovePending % 4);
      lpxPFData->bFirstMoveOnPage = 0;
   }

   /* For Osaka, we slow down envelope printing to allow time for the       */
   /* black ink to dry before it rubs against the trailing edge of the      */
   /* cartridges.  We are doing this by printing a full 8" swath            */
   /* We will not get HIRES for mono envelope printing from driver.         */
   /* Expansion now is impossible since swath is shorter for mono   */
   /* envelope printing.                                                             */
   if ( lpxPFData->bEnvelopeSize == 1 )
   {
      dwSize = ExpandSwathTo8Inches(lpxDataRec);
   }

   /* Now determine the swath density */
   wDenseSwath = CheckSwathDensity(lpxDataRec);

   if (wDenseSwath == 1)
   {
      /* The swath is too dense (too many dots in an area).  It will       */
      /* overload Osaka's power supply.  So break the swath into two       */
      /* swaths, each one with alternating slices from the original swath. */
      CreateTwoSwaths(lpxDataRec);

      /* Since two swaths are created, store away the next swath info now  */
      /* before calculating the swath info for the second half swath.      */
      swPreRotateStart         = lpxPFData->swPreRotateStart;
      swPreRotateEnd           = lpxPFData->swPreRotateEnd;
      bPreRotateDir            = lpxPFData->bPreRotateDir;

      swFutureFormsMovePending = lpxPFData->swFutureFormsMovePending;
      bPreRotatePrintHead      = lpxPFData->bPreRotatePrintHead;

      /* Calculating for the second half swath info */
      lpxPFData->swPreRotateStart = (lpxPFData->swLeftPrintPos -
                                    lpxPFData->wLeftMargin + 7) / 8;

      if (lpxPFData->bPreRotatePrintHead == MONO_CARTRIDGE)
      {
         lpxPFData->swPreRotateEnd =
            (lpxPFData->swRightPrintPos -
             MONO_NOZZLE_OFFSET*lpxPFData->swSwathResMult -
             lpxPFData->wLeftMargin + 7) / 8;
      }
      else
      {
         lpxPFData->swPreRotateEnd =
            (lpxPFData->swRightPrintPos -
             COLOR_NOZZLE_OFFSET * lpxPFData->swSwathResMult -
             lpxPFData->wLeftMargin + 7) / 8;
      }
      /* Get current print direction for the second half */
      lpxPFData->bPreRotateDir = lpxPFData->bPrintDirection;

      lpxPFData->swFutureFormsMovePending = 0;

      dwCompressLength = Compress(lpxDataRec,
                                  (LPPRTCMD)lpxPFData->lpxDensePrtCmd);

      if (dwCompressLength)
      {
         dwSize                    = dwCompressLength;
         hpbPrtData = (LPByteType) lpxPFData->lpxCompPrtCmd + SWATH_HEADER_SIZE;
         lpxLSXface->xSwath.dwSwathLength = dwSize;
         lpxLSXface->xSwath.hpbSwathData  = hpbPrtData;
         lpxLSXface->xSwath.fCompress     = TRUE;
      }
      else
      {
         if(lpxPFData->bPrintDirection == RTOL )
         {  /* If the print direction is RTOL reverse the uncompressed swath. */
            ReverseSwathForRTOL(lpxDataRec,
                                (LPPRTCMD)lpxPFData->lpxDensePrtCmd);
         }
         else if( (lpxPFData->bPrintDirection == BIDI) &&
                        (lpxPFData->bSwathDirection == LS_RTOL) )
         {
            ReverseSwathForRTOL(lpxDataRec,
                                (LPPRTCMD)lpxPFData->lpxDensePrtCmd);
         }

         dwSize = (DwordType)lpxPFData->wSliceCount *lpxPFData->bBytesPerSlice;
         hpbPrtData =(LPByteType)lpxPFData->lpxDensePrtCmd + SWATH_HEADER_SIZE;
         lpxLSXface->xSwath.dwSwathLength = dwSize;
         lpxLSXface->xSwath.hpbSwathData  = hpbPrtData;
         lpxLSXface->xSwath.fCompress     = FALSE;
      }

      CopySwathInfoToLSXface(lpxDataRec, HALF_SWATH);
      swRetCode = LSSwathCmd(lpxLSXface, &lpbCmd);
      lpxPFData->swFormsMovePending = 0;
      lpxPFData->swFutureFormsMovePending = 0;

      if (swRetCode > 0)
      {
         if (swRetCode > SWATH_HEADER_SIZE )
         { /* command size too large, so call OUTPUT twice */
            OUTPUT(lpxDataRec, lpbCmd, swRetCode);
            OUTPUT(lpxDataRec,(HPByteType)hpbPrtData, dwSize);
         }
         else
         { /* combine the command and swath and call OUTPUT only once */
            hpbPrtData -= swRetCode;
            dwSize += swRetCode;
            _fmemcpy(hpbPrtData, lpbCmd, swRetCode);

            OUTPUT(lpxDataRec,(HPByteType)hpbPrtData, dwSize);
         }
      }

      /* restore saved values for the next swath to be sent */
      lpxPFData->swPreRotateStart         = swPreRotateStart;
      lpxPFData->swPreRotateEnd           = swPreRotateEnd;
      lpxPFData->bPreRotateDir            = bPreRotateDir;

      lpxPFData->swFutureFormsMovePending = swFutureFormsMovePending;
      lpxPFData->bPreRotatePrintHead      = bPreRotatePrintHead;

   }  /* end of if (wDenseSwath == 1) */

   dwCompressLength = Compress(lpxDataRec, (LPPRTCMD)lpxPFData->lpxPrtCmd);
   if (dwCompressLength)
   {
      dwSize                    = dwCompressLength;
      hpbPrtData = (LPByteType) lpxPFData->lpxCompPrtCmd + SWATH_HEADER_SIZE;
      lpxLSXface->xSwath.dwSwathLength = dwSize;
      lpxLSXface->xSwath.hpbSwathData  = hpbPrtData;
      lpxLSXface->xSwath.fCompress     = TRUE;
   }
   else
   {
      if(lpxPFData->bPrintDirection == RTOL )
      {  /* If the print direction is RTOL reverse the uncompressed swath. */
         ReverseSwathForRTOL(lpxDataRec, (LPPRTCMD)lpxPFData->lpxPrtCmd);
      }
      else if( (lpxPFData->bPrintDirection == BIDI) &&
                     (lpxPFData->bSwathDirection == LS_RTOL) )
      {
         ReverseSwathForRTOL(lpxDataRec, (LPPRTCMD)lpxPFData->lpxPrtCmd);
      }

      dwSize                    = ((DwordType)lpxPFData->wSliceCount *
                                  lpxPFData->bBytesPerSlice);
      hpbPrtData = (LPByteType) lpxPFData->lpxPrtCmd + SWATH_HEADER_SIZE;
      lpxLSXface->xSwath.dwSwathLength = dwSize;
      lpxLSXface->xSwath.hpbSwathData  = hpbPrtData;
      lpxLSXface->xSwath.fCompress     = FALSE;
   }

   CopySwathInfoToLSXface(lpxDataRec, FULL_SWATH);
   swRetCode = LSSwathCmd(lpxLSXface, &lpbCmd);
   lpxPFData->swFormsMovePending = 0;
   lpxPFData->swFutureFormsMovePending = 0;

   if (swRetCode > 0)
   {
      if (swRetCode > SWATH_HEADER_SIZE )
      { /* command size too large, so call OUTPUT twice */
         OUTPUT(lpxDataRec, lpbCmd, swRetCode);
         OUTPUT(lpxDataRec,(HPByteType)hpbPrtData, dwSize);
      }
      else
      { /* combine the command and swath and call OUTPUT only once */
         hpbPrtData -= swRetCode;
         dwSize += swRetCode;
         _fmemcpy(hpbPrtData, lpbCmd, swRetCode);
         OUTPUT(lpxDataRec,(HPByteType)hpbPrtData, dwSize);
      }
   }

   return;

}  /* end of function OutputSwath() */




/****************************************************************************
 * Function Name:    FCEjectPage
 *
 * Description:
 *    This function sends a page eject command to the printer.
 *    Note that no action is taken by the printer unless paper has
 *    been loaded.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 *
 ***************************************************************************/
void FAR FCEjectPage(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   LPByteType  lpbCmd;
   WordType    wLength;
   SwordType   swRetCode;
   BoolType    fEnableJamDetect = TRUE;

   if (lpxDataRec == NULL)
   {
      return;
   }

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   switch (lpxDataRec->bMediaSize)
   {
   case PAPER_LETTER:
      wLength = 3300;
      break;
   case PAPER_LEGAL:
      wLength = 4200;
      break;
   case PAPER_B5:
      wLength = 3035;
      break;
   case PAPER_EXECUTIVE:
      wLength = 3150;
      break;
   case PAPER_A5:
      wLength = 2480;
      break;
   case CARD_A6:
      wLength = 1748;
      break;
   case PAPER_USER:
      /* Custom paper can be up to 17" long */
      wLength = 5100;
      break;
   case PAPER_A4:
      wLength = 3510;
      break;
   case PAPER_OHFHAGAKI:
      wLength = 1748;
      break;
   case PAPER_HAGAKI:
      wLength = 1748;
      break;
   case ENVELOPE_9:
      wLength = 2662;
      break;
   case ENVELOPE_10:
      wLength = 2850;
      break;
   case ENVELOPE_DL:
      wLength = 2598;
      break;
   case ENVELOPE_C5:
      wLength = 2703;
      break;
   case ENVELOPE_C6:
      wLength = 1914;
      break;
   case ENVELOPE_D5:
      wLength = 2952;
      break;
   case ENVELOPE_75:
      wLength = 2250;
      break;
   case CARD_3X5:
      wLength = 1500;
      break;
   case CARD_4X6:
      wLength = 1800;
      break;
   case ENVELOPE_BARONIAL:
      wLength = 1314;
      break;
   case ENVELOPE_6_3_4:
      wLength = 1950;
      break;
   case JPNLONG3:
      wLength = 2776;
      break;
   case JPNSQUARE4:
      wLength = 3154;
      break;
   case JPNSQUARE5:
      wLength = 2835;
      break;
   case JPNSQUARE6:
      wLength = 2705;
      break;
   case PAPER_BANNER_A4:
   case PAPER_BANNER_LETTER:
   case PAPER_CUSTOM_BANNER:
      wLength = 3510;
      fEnableJamDetect = FALSE;
      break;
   default :
      /* Custom paper can be up to 17" long */
      wLength = 5100;
         break;
   }  /* end of switch (lpxDataRec->bMediaSize) */


   /* LSEjectCmd expects page length in 1200dpi */
   wLength *= 4;

   CopyDocInfoToLSXface(lpxDataRec);
   lpxPFData->lpxHWData->lpxLSXface->wPageLength = wLength;
   lpxPFData->lpxHWData->lpxLSXface->fEnableJamDetect = fEnableJamDetect;
   swRetCode = LSEjectPage(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of FCEjectPage() */




/****************************************************************************
 * Function Name:    FCProductReturns
 *
 * Description:
 * FCProductReturns() is called once for the life of a printer.  It should
 * be called after the first 100 pages have been printed.  It places an
 * ink mark on the printer's body at the extreme right edge, the edge
 * farthest from the maintenance station.  This is to help our Products
 * Returns group decide if the printer is new or not.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 *
 ***************************************************************************/
void FAR FCProductReturns(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   LPByteType     lpbCmd;
   SwordType      swRetCode;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   swRetCode = LSProductReturns(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of function FCProductReturns() */




/****************************************************************************
 * Function Name:    FcPaperSource
 *
 * Description:
 *    This function outputs the paper source data (manual or
 *    automatic sheet feed) to the printer in the expected format.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 *
 ***************************************************************************/
void FCSetPaperSource(LPDVDATAREC lpxDataRec)
{
   lpxDataRec = lpxDataRec;
   return;
}





/****************************************************************************
 * Function Name:    FCSetHeadTypes
 *
 * Description:
 *    This function outputs the disable head detect & head id commands.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 *
 ***************************************************************************/
void FCSetHeadTypes(LPDVDATAREC lpxDataRec)
{
   lpxDataRec = lpxDataRec;
   return;
} /* end of FCSetHeadTypes() */




/****************************************************************************
 * Function Name:    GetPrintDir
 *
 * Description:
 *    This function determines the print direction for each swath.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *          swBuffers   Which head is used in this swath.
 *
 * Outputs: print direction
 *
 *
 ***************************************************************************/
ByteType GetPrintDir(LPDVDATAREC lpxDataRec, SwordType swBuffers)
{
   LPPFDATA    lpxPFData;
   ByteType    bPrintDir;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   switch (swBuffers)
   {
   case CMYPLANES :       /* set print direction for CMY swath */
      if( lpxPFData->bEnvelopeSize == 1 )
      {
         bPrintDir = LTOR;
         break;
      }
      switch (lpxDataRec->bColorPlanes)
      {
      case 3:
      case 4:
         switch (lpxDataRec->bQuality)
         {
         case QUALITY_DRAFT:
            bPrintDir = BIDI;
            break;
         case QUALITY_NORMAL:
         case QUALITY_HIGH:
            bPrintDir = RTOL;
            break;
         }  /* end of Quality switch */
         break;

      case 6:
         bPrintDir = RTOL;
         break;

      }        /* end of color planes switch */
      break;   /* out of CMYPLANES */

   case KPLANE :          /* set print direction for Black swath */
      if( lpxPFData->bEnvelopeSize == 1 )
      {
         bPrintDir = LTOR;
         break;
      }
      switch (lpxDataRec->bColorPlanes)
      {
      case 1:
      case 4:
         switch (lpxDataRec->bQuality)
         {
         case QUALITY_DRAFT:
            bPrintDir = BIDI;
            break;
         case QUALITY_NORMAL:
         case QUALITY_HIGH:
            bPrintDir = LTOR;
            break;
         }  /* end of Quality switch */
         break;

      } /* end of switch for ColorPlanes */
      break;

   case KCMPLANES :       /* set print direction for KCM swath */
      bPrintDir = LTOR;
      break;

   default:
      bPrintDir = LTOR;  /* This should never happen */
      break;
   } /* end of swBuffers (CMY K and KCM swath) switch */

   return(bPrintDir);
}




/****************************************************************************
 * Function Name:    GetLeftMargin
 *
 * Description:
 *    This function determines the left margin based on the following :
 *    Paper Size - (i.e. left margin is 75/300 for Letter, 40/300" for A4
 *    paper.  Note that for custom paper sizes, we expect the driver to
 *    provide the left margin value via interface value
 *    lpxDataRec->wLeftMargin, which should already be in the current
 *    page's resolution.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: return left margin for the print page in the page's resolution.
 *
 *
 ***************************************************************************/
WordType GetLeftMargin(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   WordType    wLeftMargin;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   switch (lpxDataRec->bMediaSize)
   {
   case ENVELOPE_MONARCH:
   case ENVELOPE_9:
   case ENVELOPE_10:
   case ENVELOPE_DL:
   case ENVELOPE_C5:
   case ENVELOPE_B5:
   case ENVELOPE_C6:
   case ENVELOPE_D5:
   case ENVELOPE_75:
   case ENVELOPE_6_3_4:
   case ENVELOPE_BARONIAL:
   case JPNLONG3:
   case JPNSQUARE4:
   case JPNSQUARE5:
   case JPNSQUARE6:
   case ENVELOPE_CUSTOM:
      lpxPFData->bEnvelopeSize = 1;
      break;
   default:
      lpxPFData->bEnvelopeSize = 0;
      break;
   }

   return(wLeftMargin = lpxDataRec->wLeftMargin);

}  /* end of GetLeftMargin() */




/****************************************************************************
 * Function Name:    GetShingleMode
 *
 * Description:
 *    Some printers use this function to set the shingle amount for the
 *    page.  Marconi does not use this function.  It requires the correct
 *    shingle amount be chosen be the driver and communicated by variable
 *    lpxDataRec->bShingle;
 *
 * Inputs:  lpxDataRec  pointer to hbpcode interface structure.
 *
 * Outputs: none for Marconi
 *
 *
 ***************************************************************************/
ByteType GetShingleMode(LPDVDATAREC lpxDataRec)
{
   ByteType    bShingle = NO_SHINGLE;
   LPPFDATA lpxPFData;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   /* determine shingle value from media type and print quality */
   switch (lpxDataRec->bMediaType)
   {
   case PLAIN_PAPER :
   case GREETING_CARD_STOCK :
      switch (lpxDataRec->bQuality)
      {
      case  QUALITY_DRAFT :
         bShingle = NO_SHINGLE;
         break;
      case  QUALITY_NORMAL :
         switch (lpxPFData->bColorPlanes)
         {
         case 3:
         case 4:
         case 6:
            if ( lpxDataRec->bDocumentType != INTENT_PHOTO )
            {  /* business graphic mode */
               bShingle = NO_SHINGLE;
            }
            else
            {   /* use 2-pass for CMY or KCM head for normal photo mode */
               bShingle = SHINGLE_50;
            }
            break;

         case 1:   /* black only */
            if ( (lpxDataRec->bDocumentType == INTENT_PHOTO) ||
                   (lpxDataRec->bMediaType == GREETING_CARD_STOCK) )
            {
               bShingle = SHINGLE_33;
            }
            else
            {
               bShingle = NO_SHINGLE;
            }
            break;
         }  /* end of switch for bColorPlanes */
         break;     /* get out of normal */

      case  QUALITY_HIGH :
         bShingle = SHINGLE_50;
         break;
      }  /* end of switch (lpxDataRec->bQuality) */
      break;

   case GLOSSY_PAPER :
      switch (lpxDataRec->bQuality)
      {
      case  QUALITY_DRAFT :
         bShingle = NO_SHINGLE;
         break;
      case  QUALITY_NORMAL :
         bShingle = SHINGLE_33;
         break;
      case  QUALITY_HIGH :
         bShingle = SHINGLE_50;
         break;
      }  /* end of switch (lpxDataRec->bQuality) */
      break;

   case COATED_PAPER :
   case TRANSPARENCY :
      switch (lpxDataRec->bQuality)
      {
      case  QUALITY_DRAFT :
         bShingle = NO_SHINGLE;
         break;
      case  QUALITY_NORMAL :
         if ( (lpxPFData->bColorPlanes == 6) ||
               ( (lpxPFData->bColorPlanes == 1) &&
                 (lpxDataRec->bDocumentType == INTENT_PHOTO) ) )
         {
            bShingle = SHINGLE_33;
         }
         else
         {
            bShingle = SHINGLE_50;
         }
         break;
      case  QUALITY_HIGH :
         bShingle = SHINGLE_50;
         break;
      }  /* end of switch (lpxDataRec->bQuality) */
      break;

   case IRON_ON_TRANSFER :
      switch (lpxDataRec->bQuality)
      {
      case  QUALITY_DRAFT :
         bShingle = NO_SHINGLE;
         break;
      case  QUALITY_NORMAL :
         switch (lpxPFData->bColorPlanes)
         {
         case 3:
         case 4:
         case 6:
            bShingle = SHINGLE_50;
            break;

         case 1:   /* black only */
            bShingle = SHINGLE_33;
            break;
         }  /* end of switch for bColorPlanes */
         break;     /* get out of normal */

      case  QUALITY_HIGH :
         bShingle = SHINGLE_50;
         break;
      }  /* end of switch (lpxDataRec->bQuality) */
      break;

   }  /* end of switch (lpxDataRec->bMediaType) */

#if defined(DOS_BUILD)
   bShingle = lpxDataRec->bShingle;
#endif

   return(bShingle);

}




/****************************************************************************
 * Function Name:    GetResolution
 *
 * Description:
 *    We determine our printer resolution based on driver communicated
 *    variable lpxDataRec->bQuality.
 *
 * Inputs:  lpxDataRec  pointer to hbpcode interface structure.
 *
 * Outputs: returns the current specified resolution.
 *
 *
 ***************************************************************************/
ByteType GetResolution(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   ByteType    bResolution;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   switch(lpxDataRec->bQuality)
   {
   case QUALITY_DRAFT:
      bResolution = SUPERLOWRES;
      break;
   case QUALITY_NORMAL:
   default :
      bResolution = LORES;
      break;
   case QUALITY_HIGH:
      bResolution = HIRES_INTERLACED;
      break;
   }

   return(bResolution);
}



/****************************************************************************
 * Function Name:    GetTopMargin
 *
 * Description:
 *    This function determines the top margin.  It seems like
 *    the interface has changed to SW2000 driver code for some
 *    printers so this is now printer specific.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 *
 ***************************************************************************/
WordType GetTopMargin(LPDVDATAREC lpxDataRec)
{
   LPPFDATA lpxPFData;
   WordType wTopMargin,
            wTopMarginAdjust;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   /* The 13 is the top margin adjustment from average of 20 MVT machines. */
   wTopMargin = lpxDataRec->wTopMargin + 13;

   /* We need additional 14/600 for Hi-Res Mono printing to compensate */
   /* the vertical gap left by 14 unused bottom K nozzles.             */
   if( (lpxDataRec->bQuality >= 4 ) && ( lpxPFData->bColorPlanes == 1) )
   {
      wTopMargin += 14;
   }

   if ( lpxPFData->bColorPlanes == 1 )
   {  /* MONO */
      wTopMarginAdjust = 0;
   }
   else
   {  /* COLOR.  The color nozzles begin 20/600 down farther than the      */
      /* black nozzles do.  Do subtract 20/600 from the top margin to      */
      /* account for this.                                                 */
      wTopMarginAdjust = 20;
   }

   if ( wTopMargin >= wTopMarginAdjust )
   {
      wTopMargin -= wTopMarginAdjust;
   }
   else
   {
       wTopMargin = 0;
   }

   wTopMargin = wTopMargin * lpxPFData->swVertResMult;

   return (wTopMargin);

}  /* GetTopMargin() */



/****************************************************************************
 * Function Name:    ClearPrintSwath
 *
 * Description:
 *    This function zeroes out the print swath buffer.
 *
 * Inputs:  xPFData     Pointer to the hbpcode internal data structure
 *
 * Outputs: Adds correct vertical move amount for top margin.
 *
 *
 ***************************************************************************/
void ClearPrintSwath(LPPFDATA lpxPFData)
{
   WordType    i;
   size_t      stMemSetSize;

   if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
   {
      stMemSetSize = (size_t)SLICES_PER_SEG * (size_t)lpxPFData->bBytesPerSlice;
      for (i=0; i<=((lpxPFData->wSlicesPerRow-1)/SLICES_PER_SEG);i++)
      {
         _fmemset( lpxPFData->alpbSwath[i],0x00,stMemSetSize);
      }
   }
   else
   {
      stMemSetSize = (size_t)lpxPFData->dwSwathPrintSize - SWATH_HEADER_SIZE;
      _fmemset(lpxPFData->alpbSwath[0],0x00,stMemSetSize);
   }
   return;

}  /* end of function ClearPrintSwath() */




/****************************************************************************
 * Function Name:    FCSendCartridgeHome
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to send the carrier to be capped at the
 *    maintenance station.  The carrier position
 *    kept by the driver is then updated to the
 *    maintenance cap position.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 *
 ***************************************************************************/
void FAR FCSendCartridgeHome(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   LPByteType     lpbCmd;
   SwordType      swRetCode;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   CopyDocInfoToLSXface(lpxDataRec);
   swRetCode = LSSendCartridgeHome(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of FCSendCartridgeHome() */




/****************************************************************************
 * Function Name:    FCInstallCartridge
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to send the carrier to the install position.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: none
 *
 *
 ***************************************************************************/
void FAR FCInstallCartridge(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   LPByteType     lpbCmd;
   SwordType      swRetCode;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   CopyDocInfoToLSXface(lpxDataRec);
   swRetCode = LSInstallCartridge(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of function FCInstallCartridge() */



/****************************************************************************
 * Function Name:    CheckForCDE
 *
 * Description:
 *    For Osaka, we perform consecutive dot elimination (CDE) if we are in
 *    normal mode and printing an envelope using the black head.
 *    This function will return TRUE (perform CDE) when in normal mode
 *    and printing an envelope.  This is to put down less ink and thus
 *    prevent smearing when using the black head on some envelopes.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: return TRUE (perform CDE) for normal black envelope printing.
 *          return FALSE (do not perform CDE) for all other modes.
 *
 *
 ***************************************************************************/
BoolType CheckForCDE(LPDVDATAREC lpxDataRec, ByteType bQuality)
{
   BoolType    fRetCode;
   LPPFDATA    lpxPFData;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   if (lpxPFData->bEnvelopeSize && (bQuality == QUALITY_NORMAL) &&
       lpxPFData->bColorPlanes == 1 )
   {
      /* Enable CDE for normal black only envelope printing to prevent */
      /* smearing while printing.                                      */
      fRetCode = TRUE;
   }
   else
   {
      fRetCode = FALSE;
   }

   return(fRetCode);
}  /* end of function CheckForCDE() */




/****************************************************************************
 * Function Name:    CheckForReverseSwath
 *
 * Description:
 *    Osaka builds a swath backwards if printing RTOL.  This function
 *    determines if Osaka in printing RTOL, in which case it returns
 *    REVERSE telling the Rotate() function to build the swath backwards.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: return REVERSE if backwards swath (RTOL).
 *          return FORWARD if forwards swath (LTOR).
 *
 *
 ***************************************************************************/
ByteType CheckForReverseSwath(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   ByteType       bDirection,
                  bMode;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   CopySwathInfoToLSXface(lpxDataRec, NO_SWATH);
   bDirection = LSGetSwathDirection(lpxPFData->lpxHWData->lpxLSXface);
   lpxPFData->bSwathDirection = bDirection;

   if (bDirection == LS_LTOR)
   {
      bMode = FORWARD;
   }
   else
   {
      bMode = REVERSE;
   }

   return(bMode);

}  /* end of function CheckforReverseSwath() */




/****************************************************************************
 *  Function:  Compress()
 *  Parameters: <lpxPFData>     pointer to print data structure
 *  Returns:    <0>          compression not successful
 *           OR <n>          size (in bytes) of successfully compressed
 *                           print swath which is stored in
 *                           lpxPFData->hpCompress
 *  Description:
 *       Processes print data stream one slice at a time.  Compresses each
 *       slice using both compression methods, which are:
 *             mode 0   compress 0x00 bytes.
 *             mode 1   compress repeating words
 *       Places the most compressed version of the slice, along with its
 *       control word, in the output data stream.  If the length of the
 *       output data stream becomes >= length of the input data stream,
 *       stop compression.
 ***************************************************************************/
DwordType Compress(LPDVDATAREC lpxDataRec, LPPRTCMD pPrtCmd)
{
   LPPRTCMD pCompPrtCmd;
   int      nNumSlices,      /* number of slices in umcompressed data buffer*/
            nMode0Cnt,       /* compression mode 0 length count */
            nMode1Cnt,       /* compression mode 1 length count */
            i,j;             /* loop counters */
   ByteType mode0[26],       /* work buffer for compression mode 0 */
            mode1[26],       /* work buffer for compression mode 1 */
            bSSize,          /* slice size (in bytes) */
            bBitIndex;
   DwordType dwInLength=0,   /* input data buffer data size (in bytes) */
            dwOutLength=0,   /* output data buffer size (in bytes)*/
            dwOutBufLength=0,/* output data buffer size + 26 */
            dwMode0CW,       /* control word for compression mode 0 */
            dwMode1CW;       /* control word for compression mode 1 */
   HPByteType   hpbInSwath;  /* pointer to uncompressed data buffer */
   HPByteType   hpbCompSwath; /* pointer to compressed data buffer */
   LPPFDATA lpxPFData;

#if defined(CPROF)
   PrfEnter(10);
#endif
   lpxPFData      = (LPPFDATA )lpxDataRec->lpLXDevice;
   pCompPrtCmd = (LPPRTCMD)lpxPFData->lpxCompPrtCmd;


   if( lpxDataRec->bCompress == 0 )
   {
#if defined(CPROF)
      PrfExit(10);
#endif
      return(0L);
   }


   hpbInSwath = (HPByteType)pPrtCmd + SWATH_HEADER_SIZE;
   hpbCompSwath = (HPByteType)pCompPrtCmd + SWATH_HEADER_SIZE;

   bSSize = lpxPFData->bBytesPerSlice;
   nNumSlices = (SwordType) lpxPFData->wSliceCount;

   /* get the length of the input print data stream minus the print header */
   dwInLength = ((DwordType)lpxPFData->wSliceCount*lpxPFData->bBytesPerSlice);

   bBitIndex = (ByteType)(bSSize - 1);

   if(lpxPFData->bPrintDirection == RTOL )
   {  /* We want to move the ptr to the last slice since
         slices are processed from the last to the first. */
      hpbInSwath += ( dwInLength - bSSize );
   }
   else if( (lpxPFData->bPrintDirection == BIDI) &&
                  (lpxPFData->bSwathDirection == LS_RTOL) )
   {
      hpbInSwath += ( dwInLength - bSSize );
   }

   for (i = 0; i < nNumSlices; i++)
   {  /* do for each slice in input data stream */

      /* Handle first byte in slice */

      if (*hpbInSwath == 0x00)
      {  /* with mode 0, if first byte is 0's, then don't copy */
         nMode0Cnt = 0;
         dwMode0CW = 0x80000000;
         dwMode0CW |= ( (DwordType) 1 << bBitIndex);
      }
      else
      {  /* with mode 0, if first byte is not 0's, then copy */
         nMode0Cnt = 1;
         mode0[0] = *hpbInSwath;
         dwMode0CW = 0x80000000;
      }


      /* with mode 1, first byte is always copied to the output string */
      nMode1Cnt = 1;
      mode1[0] = *hpbInSwath;
      dwMode1CW = 0x40000000;

      /* End of section to handle first byte in slice */


      /* move on to next byte in slice */
      hpbInSwath++;

      for   (j = 1; j < bSSize; j++)
      {  /* do for rest of bytes in slice */

         /* mode0 compression */
         if (*hpbInSwath == 0x00)
         {
            dwMode0CW |= ( (DwordType) 1 << (bBitIndex - j) );
         }
         else
         {
            mode0[nMode0Cnt] = *hpbInSwath;
            nMode0Cnt++;
         }

         /* mode 1 compression */
         if (*hpbInSwath == mode1[nMode1Cnt - 1])
         {
            dwMode1CW |= ( (DwordType) 1 << (bBitIndex - j) );
         }
         else
         {
            mode1[nMode1Cnt] = *hpbInSwath;
            nMode1Cnt++;
         }

         hpbInSwath++;
      }  /* End of for (j = 0; j < (bSSize >> 1); j++) */


      if(lpxPFData->bPrintDirection == RTOL )
      {  /* In order for us to get the ptr at the beginning of the next slice
            from the last one processed we need to move the ptr by the distance of
            full 2 slices backward since the ptr has moved to the end of the last slice
            processed */
         hpbInSwath -= (bSSize << 1);
      }
      else if( (lpxPFData->bPrintDirection == BIDI) &&
                     (lpxPFData->bSwathDirection == LS_RTOL) )
      {
         hpbInSwath -= (bSSize << 1);
      }

      /* now store the compressed slice in the output data stream */
      if (nMode0Cnt < nMode1Cnt)
      {  /* use compression mode 0 */
         dwOutLength += ( nMode0Cnt + 4 );  /* + 4 is for the control word */
         if (dwOutLength >= dwInLength)
         {
            /* compression isn't saving any space, so quit. */
#if defined(CPROF)
PrfExit(10);
#endif
            return(0L);
         }

         *hpbCompSwath = (ByteType) ((dwMode0CW & 0xFF000000) >> 24);
         hpbCompSwath++;
         *hpbCompSwath = (ByteType) ((dwMode0CW & 0x00FF0000) >> 16);
         hpbCompSwath++;
         *hpbCompSwath = (ByteType) ((dwMode0CW & 0x0000FF00) >> 8);
         hpbCompSwath++;
         *hpbCompSwath = (ByteType)  (dwMode0CW & 0x000000FF);
         hpbCompSwath++;
         for (j = 0; j < nMode0Cnt; j++)
         {
            *hpbCompSwath = mode0[j];
            hpbCompSwath++;
         }
      } /* End of: use compression mode 0 */
      else
      {  /* use compression mode 1 */
         dwOutLength += nMode1Cnt + 4;  /* +1 is for the control word */
         if (dwOutLength >= dwInLength)
         {
            /* compression isn't saving any space, so quit. */
#if defined(CPROF)
PrfExit(10);
#endif
            return(0L);
         }

         *hpbCompSwath = (ByteType) ((dwMode1CW & 0xFF000000) >> 24);
         hpbCompSwath++;
         *hpbCompSwath = (ByteType) ((dwMode1CW & 0x00FF0000) >> 16);
         hpbCompSwath++;
         *hpbCompSwath = (ByteType) ((dwMode1CW & 0x0000FF00) >> 8);
         hpbCompSwath++;
         *hpbCompSwath = (ByteType)  (dwMode1CW & 0x000000FF);
         hpbCompSwath++;
         for (j = 0; j < nMode1Cnt; j++)
         {
            *hpbCompSwath = mode1[j];
            hpbCompSwath++;
         }
      } /* End of use compression mode 1 */
   }  /* End of for (i = 0; i < nNumSlices; i++) */


#if defined(CPROF)
PrfExit(10);
#endif

   return(dwOutLength);

}  /* end of Compress() */



/****************************************************************************
 * Function Name:    CheckSwathDensity
 *
 * Description:
 *    Osaka can become power starved if the number of dots printed is too
 *    high for too long.  CheckSwathDensity() counts the number of dots one
 *    section at a time to seed see if a swath needs to be broken into two
 *    swaths.  If any one section is above the percent coverage threshold,
 *    then signal that the swath needs to be divided into two swaths.
 *
 * Inputs:  lpxDataRec   Long pointer to print device structure.
 *
 * Outputs: Return 1 if Swath is too dense, otherwise return 0.
 *
 *
 ***************************************************************************/
SwordType CheckSwathDensity(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   SwordType      i, j, k,
                  swDotsPerSlice,
                  swRetCode=0,   /* initial state assuming swath is not    */
                                 /* too dense                              */
                  swSegs,
                  swSlices,
                  swThresholdPct;
   DwordType      dwThresholdDots,
                  dwSegDotCount;
   ByteType       bBPS;
   HPByteType     hpbSliceByte;

   lpxPFData  = (LPPFDATA )lpxDataRec->lpLXDevice;

   if (lpxPFData->bPrintHead == MONO_CARTRIDGE)
      swDotsPerSlice = 208;
   else
      swDotsPerSlice = 192;

   if (lpxPFData->bResolution == SUPERLOWRES)
   {  /* 300x600 dpi, threshold is more than 50% dots for two inches       */
      swSlices = 600;
      swThresholdPct = 50;
   }
   else if (lpxPFData->bResolution == LORES)
   {  /* 600 dpi        */
      if ( lpxPFData->bPrintHead == COL_CARTRIDGE )
      {  /* color swath */
         swSlices = 600;
         /* Raised limit from 50% to 65% for color swaths 4-12-99 wlc */
         swThresholdPct = 65;

         /* Don't check density for CMY swaths that are shingled */
         if ( lpxPFData->bShingle != NO_SHINGLE   )
         {  /* normal CMY shingled swath so just return */
            return(swRetCode);
         }
      }
      else
      {  /* black swath */
         swSlices = 600;
         swThresholdPct = 50;
      }
   }
   else
   {  /* 1200 dpi, threshold is more than 25% dots for one inch            */
      if (lpxPFData->bShingleHiRes == SHINGLE_50 )
      {  /* 600 dpi swath in HiRes mode. Use 600 dpi limits. */
         swSlices = 600;
         swThresholdPct = 65;
      }
      else
      {  /* true 1200 dpi swath */
         swSlices = 1200;
         swThresholdPct = 25;
      }
   }

   dwThresholdDots = (DwordType)((DwordType)swSlices * swDotsPerSlice * swThresholdPct / 100);
   bBPS = lpxPFData->bBytesPerSlice;
   swSegs = (lpxPFData->wSliceCount+swSlices-1)/swSlices;

   hpbSliceByte = (HPByteType)lpxPFData->lpxPrtCmd + SWATH_HEADER_SIZE;
   for (i = 1; i <= swSegs; i++)
   {
      dwSegDotCount = 0;
      if (i == swSegs)
      {
         /* The last segment will likely not have a full count of slices */
         swSlices = lpxPFData->wSliceCount - (swSlices*(i-1));
      }
      for (j=0; j<swSlices; j++)
      {
         for (k=0; k<bBPS; k++)
         {
            dwSegDotCount += lpxPFData->abBitCount[(*hpbSliceByte)];
            hpbSliceByte++;
         }
      }
      if (dwSegDotCount > dwThresholdDots)
      {
         /* This swath is too dense, it should be broken into two swaths   */
         swRetCode = 1;
         break;
      }
   }

   return(swRetCode);

}  /* end of CheckSwathDensity() */




/****************************************************************************
 * Function Name:    CreateTwoSwaths
 *
 * Description:
 *    Splits one swath into two swaths by moving every even slice from the
 *    first swath into the second swath.
 *
 * Inputs:  lpxDataRec   Long pointer to print device structure.
 *
 * Outputs: places every even slice from swath lpxPFData->lpxPrtCmd into
 *          the same location of swath lpxPFData->pDensePrtCmd, and
 *          then removes the even slice from lpxPFData->lpxPrtCmd.
 *
 *
 ***************************************************************************/
void CreateTwoSwaths(LPDVDATAREC lpxDataRec)
{
   ByteType     bBPS;
   HPByteType   hpbSliceByte, hpbDenseSliceByte, hbpHeader;
   HPWordType   hpwDenseSwath;
   WordType     i,j;
   DwordType    k;
   LPPRTCMD pPrtCmd, pDensePrtCmd;
   LPPFDATA lpxPFData;

   lpxPFData         = (LPPFDATA )lpxDataRec->lpLXDevice;
   pDensePrtCmd      = (LPPRTCMD)lpxPFData->lpxDensePrtCmd;
   pPrtCmd           = (LPPRTCMD)lpxPFData->lpxPrtCmd;
   hbpHeader         = (HPByteType) pDensePrtCmd;
   bBPS              = lpxPFData->bBytesPerSlice;
   hpbSliceByte      = (HPByteType)pPrtCmd + SWATH_HEADER_SIZE;
   hpbDenseSliceByte = (HPByteType)pDensePrtCmd + SWATH_HEADER_SIZE;
   hpwDenseSwath     = (HPWordType)pDensePrtCmd;

   for (k=0; k<(lpxPFData->dwSwathPrintSize/2); k++)
   {
      /* initialize second swath buffer to 0 */
      *hpwDenseSwath++ = 0x0000;
   }

   for (i=0;i<SWATH_HEADER_SIZE;i++)
   {
      /* copy print swath header to second swath */
      hbpHeader[i] = ((HPByteType)pPrtCmd)[i];
   }

   for (i=0;i<lpxPFData->wSliceCount;i+=2)
   {
      for (j=0;j<bBPS;j++)
      {  /* copy even slice into second swath and apply an 0xAA shingle */
         /* pattern to the source swath and an 0x55 shingle pattern to the */
         /* second swath */
         *hpbDenseSliceByte++ = *hpbSliceByte & 0x55;
         *hpbSliceByte++ &= 0xAA;
      }

      for (j=0;j<bBPS;j++)
      {  /* copy odd slice into second swath and apply an 0xAA shingle */
         /* pattern to the source swath and an 0x55 shingle pattern to the */
         /* second swath */
         *hpbDenseSliceByte++ = *hpbSliceByte & 0xAA;
         *hpbSliceByte++ &= 0x55;
      }
   }
   return;
}




/****************************************************************************
 *  FCOSAKA.C                                          Lexmark Confidential
 *
 * Function Name:    PopulateBitCount
 *
 * Description:
 *    This function initializes the bit count array used when we are
 *    checking swath density.  So for byte values 0..255, this array
 *    has a corresponding member 0..255 which has stored how many bits
 *    are set to 1.
 *
 * Inputs:
 *    lpxDataRec   Long pointer to print device structure.
 *
 * Outputs: initializes lpxPFData->abBitCount[] array
 *
 *
 ***************************************************************************/
void PopulateBitCount(LPDVDATAREC lpxDataRec)
{
   LPPFDATA lpxPFData;
   SwordType  i;
   ByteType ii,j,k=1;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   for (i=0; i<=255; i++)
   {
      lpxPFData->abBitCount[i] = 0;
      ii = (unsigned char)i;
      for (j=0; j<8; j++)
      {
         lpxPFData->abBitCount[i] = (ByteType)(lpxPFData->abBitCount[i]+(ii & 0x01));
         ii >>= 1;
      }
   }
}  /* end of PopulateBitCount() */




/****************************************************************************
 *  FCOSAKA.C                                          Lexmark Confidential
 *
 * Function Name:    VerticalMoveInPhase
 *
 * Description:
 *    Large vertical moves must be "in phase", which means they should be
 *    a whole 300 dpi movement.  So for 600dpi printing, large space
 *    vertical movements should be a multiple of 2, and for  1200dpi
 *    printing, large space vertical movements should be a multiple of 4.
 *    For example, 1/600 is not an even 300dpi movement, but 2/600 is an
 *    even 300dpi movement (1/300).  This function determines whether a
 *    potential large space vertical move is "in phase".  If the movement
 *    is "in phase" then return 0.  If the movement is not "in phase", then
 *    return the number of blank lines which should be inserted before the
 *    next raster line to reduce the vertical movement enough to bring the
 *    vertical movement "in phase".
 *
 * Inputs:
 *    lpxDataRec         Long pointer to print device structure.
 *    lNextRasterLine   raster line number for next raster line.
 *
 * Outputs: returns number of blank lines to insert to make vertical move
 *          "in phase"
 *
 ***************************************************************************/
SdwordType  VerticalMoveInPhase(LPDVDATAREC lpxDataRec, SdwordType lNextRasterLine)
{
   SdwordType  lVerticalAdjustment;
   LPPFDATA lpxPFData;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   switch (lpxPFData->swVertResMult)
   {
   case 1  :
   default :
      /* this is a 600dpi vertical resolution print job.  So make sure     */
      /* lNextRasterLine is evenly divisible by 2.                         */
      lVerticalAdjustment = lNextRasterLine%2;
      break;
   case 2:
      /* this is a 1200dpi vertical resolution print job.  So make sure    */
      /* lNextRasterLine is evenly divisible by 4.                         */
      lVerticalAdjustment = lNextRasterLine%4;
      break;
   }

   return (lVerticalAdjustment);
}




/****************************************************************************
 * Function Name:    SetShingle
 *
 * Description:
 *    This functions set the shingle amount for each raster line's color
 *    planes.  This is a critical function in our independent shingling
 *    solution.  We are always setting the CMY color planes shingle
 *    amounts the same on a page basis.  But for the K color plane in a
 *    CMYK print job, we will change its shingle amount based on whether
 *    there is any color arount the K plane.
 *
 * Inputs:
 *    lpxDataRec         Long pointer to print device structure.
 *    nRowIndex         index into our raster line information buffers for
 *                      the current raster line.
 *
 * Outputs: (none)
 *
 *
 ***************************************************************************/
void SetShingle(LPDVDATAREC lpxDataRec, SwordType nRowIndex)
{
   ByteType  bShingle;
   int   n,i,swIEnd;
   ByteType  bShingleToApply;
   int   nRI;
   LPPFDATA lpxPFData;
   BoolType  fColors;

#if defined(CPROF)
PrfEnter(3);
#endif

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   nRI = nRowIndex;
   bShingle  = lpxPFData->bShingle;

   switch(bShingle)
   {
      case SHINGLE_50 :
            bShingleToApply = SHINGLE_50_1;
            break;
      case SHINGLE_25 :
            bShingleToApply = SHINGLE_25_1;
            break;
      case SHINGLE_33 :
            bShingleToApply = SHINGLE_33_1;
            break;
      default :
            bShingleToApply = SHINGLE_0_1;
            break;
   }

   for (n=lpxPFData->swDelayBufStart;n<lpxPFData->swDelayBufEnd;n++)
   {
      lpxPFData->alpbShingleToApply[n][nRowIndex] = bShingleToApply;
   }

   /* For Osaka envelope printing, we must allow time for the black ink    */
   /* to dry before it rubs against the trailing edge of the cartridges.   */
   /* One thing we do to help accomplish this is to use only the bottom    */
   /* portion of the black printhead.  The bottom portion is the section   */
   /* fartherest from the trailing edge of the cartridges.  We do this by  */
   /* not shingling the black color plane, but we change the 'print zone'  */
   /* to the bottom x nozzles. This changing the 'print zone' is done in   */
   /* functions LoadShingleMasks() and GetMonoNozzlesToUse().          */
   if ((GetMonoNozzlesToUse(lpxDataRec)) != 0)
   {
      if (lpxDataRec->bColorPlanes == 1)
      {
         lpxPFData->alpbShingleToApply[0][nRI] = SHINGLE_0_1;
      }
      else if (lpxDataRec->bColorPlanes == 4)
      {
         lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_0_1;
      }
      return;
   }
   /* end of Osaka envelope printing specific section.                   */


   if (lpxDataRec->bColorPlanes == 4)
   {
      if (lpxPFData->swVertResMult == HIRES_VERTICAL_MULTIPLIER)
      {
#if 0 //OPTION_K_1200_AS_2X600
         lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_50_1;
#else
         lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_33_1;
#endif
      }
      else if (lpxPFData->bResolution != SUPERLOWRES)
      {
         /* CMYK 600 dpi print page, so consider K dynamic shingling */

         fColors = FALSE;

         /* are there any color dots in this raster line ? */
         for (n=0; n<3; n++)
         {
            if (lpxPFData->alpswScanStart[n][nRI] < lpxPFData->alpswScanEnd[n][nRI])
            {
               fColors = TRUE;
               break;
            }
         }

         if ( (fColors == TRUE) && (lpxPFData->swFutureRowsToShingle == 0) )
         {
            /* this raster line has color dots and is following an area of */
            /* black only printing (or is at the top of page or after a    */
            /* large white space skip), so increase the K shingle amount   */
            /* for this raster line and the raster lines above this one,   */
            /* and set nFutureRowsToShingle to increase K shingle amount   */
            /* for next SHINGLE_BAND lines.      */

            if (lpxPFData->sdwRowPos < SHINGLE_BAND)
               swIEnd = (SwordType)lpxPFData->sdwRowPos;
            else
               swIEnd = SHINGLE_BAND;
            for (i=0; i<=swIEnd; i++)
            {
               if ( (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_0_1) ||
                    (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_50_1) )
                  lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_33_1;
               else if (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_25_1)
                  lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_16_1;
               nRI--;
               if (nRI < 0)
                  nRI = lpxPFData->swMaxDelayBuf-1;
            }
            lpxPFData->swFutureRowsToShingle = SHINGLE_BAND;
         }
         else if (fColors == TRUE)
         {
            /* this raster line has color dots, so increase the K shingle  */
            /* amount for this raster line and set nFutureRowsToShingle to */
            /* increase K shingle amount for next SHINGLE_BAND lines.      */

            if ( (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_0_1) ||
                 (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_50_1) )
               lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_33_1;
            else if (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_25_1)
               lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_16_1;
            lpxPFData->swFutureRowsToShingle = SHINGLE_BAND;
         }
         else if (lpxPFData->swFutureRowsToShingle > 0)
         {
            if ( (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_0_1) ||
                 (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_50_1) )
               lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_33_1;
            else if (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_25_1)
               lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_16_1;
            lpxPFData->swFutureRowsToShingle--;
         }
      }
   }

#if defined(CPROF)
PrfExit(3);
#endif
   return;
}  /* end of SetShingle() */




/****************************************************************************
 * Function Name:    GetMonoNozzlesToUse
 *
 * Description:
 *    For Osaka envelope printing, we must allow time for the black ink
 *    to dry before it rubs against the trailing edge of the cartridges.
 *    One thing we do to help accomplish this is to use only the bottom
 *    portion of the black printhead.  The bottom portion is the section
 *    fartherest from the trailing edge of the cartridges.  We do this by
 *    not shingling the black color plane, but we change the 'print zone'
 *    to the bottom x nozzles. GetMonoNozzlesToUse() sets this value x
 *    for all print jobs with mediasize = envelope.
 *
 *    Tom Bailey and Terry King ran tests the week of Dec. 8 - 11 1997,
 *    and determined we should use the bottom 50 mono nozzles when
 *    printing envelopes.
 *
 * Inputs:  lpxDataRec   Long pointer to print device structure.
 *
 * Outputs: returns the number of black nozzles to use when printing
 *          envelopes.  For nonenvelope pages, returns 0.
 *          banner printing.
 *
 *
 ***************************************************************************/
WordType GetMonoNozzlesToUse(LPDVDATAREC lpxDataRec)
{
   WordType wNozzlesToUse;
   LPPFDATA lpxPFData;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   switch (lpxDataRec->bMediaSize)
   {
   case ENVELOPE_MONARCH :
   case ENVELOPE_9  :
   case ENVELOPE_10 :
   case ENVELOPE_DL :
   case ENVELOPE_C5 :
   case ENVELOPE_B5 :
   case ENVELOPE_C6 :
   case ENVELOPE_D5 :
   case ENVELOPE_75 :
   case ENVELOPE_6_3_4 :
   case ENVELOPE_BARONIAL :
   case ENVELOPE_CUSTOM   :
   case JPNLONG3   :
   case JPNSQUARE4 :
   case JPNSQUARE5 :
   case JPNSQUARE6 :
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) ||
           (lpxPFData->bResolution == HIRES_NONINTERLACED) )
         {  /* use all nozzles in high resolution */
            wNozzlesToUse = 0;
         }
         else
         {  /* use only part of the nozzles to prevent smear */
            wNozzlesToUse = 50;
         }
         break;
   default :
         wNozzlesToUse = 0;
         break;
   }

   return(wNozzlesToUse);

}  /* end of GetMonoNozzlesToUse() */



/****************************************************************************
 * Function Name:    SetCartridgeAlignment
 *
 * Description:
 * This function sets the print heads vertical adjustment value.  It also
 * does some error checking on all cartridge adjustment values to make sure
 * they are between the minimum and maximum possible values.
 *
 * Inputs:  lpxDataRec   Long pointer to print device structure.
 *
 * Outputs: sets lpxPFData->swHead1VertAdjust and
 *               lpxPFData->swHead2VertAdjust
 *
 *
 ***************************************************************************/
void SetCartridgeAlignment(LPDVDATAREC lpxDataRec)
{
   SwordType   swVertAlign;
   LPPFDATA lpxPFData;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   lpxPFData->swHead1VertAdjust = 0;
   lpxPFData->swHead2VertAdjust = 0;

   /* perform error checking on alignment values passed in from the driver */

   if ( (lpxDataRec->bVerticalAdj < VERTHEAD_MINALIGN) ||
        (lpxDataRec->bVerticalAdj > VERTHEAD_MAXALIGN) )
   {
      lpxDataRec->bVerticalAdj = VERTHEAD_MIDALIGN;
   }

   if ( (lpxDataRec->bHorizontalAdj < HORZHEAD_MINALIGN) ||
        (lpxDataRec->bHorizontalAdj > HORZHEAD_MAXALIGN) )
   {
      lpxDataRec->bHorizontalAdj = HORZHEAD_MIDALIGN;
   }

   if ( (lpxDataRec->bBidiAlignMono < KHEAD_MINALIGN) ||
        (lpxDataRec->bBidiAlignMono > KHEAD_MAXALIGN) )
   {
      lpxDataRec->bBidiAlignMono = KHEAD_MIDALIGN;
   }

   if ( (lpxDataRec->bBidiAlignColor < CMYHEAD_MINALIGN) ||
        (lpxDataRec->bBidiAlignColor > CMYHEAD_MAXALIGN) )
   {
      lpxDataRec->bBidiAlignColor = CMYHEAD_MIDALIGN;
   }

   switch (lpxDataRec->bColorPlanes)
   {
   case 1  :
   case 3  :
   default :
      break;
   case 4  :
   case 6  :
      swVertAlign = lpxDataRec->bVerticalAdj;

      if (swVertAlign < VERTHEAD_MIDALIGN)
      {
         lpxPFData->swHead1VertAdjust = (VERTHEAD_MIDALIGN - swVertAlign);
      }
      else if (swVertAlign > VERTHEAD_MIDALIGN)
      {
         lpxPFData->swHead2VertAdjust = (swVertAlign -
                                        (SwordType)VERTHEAD_MIDALIGN);
      }
      break;
   }

   return;

}  /* end of SetCartridgeAlignment() */



/****************************************************************************
 * Function Name:    SetDropsPerPixel
 *
 * Description:
 *    This function sets the internal (lpxPFData) drops per pixel
 *    value for each color plane, based on the input interface variable
 *    lpxDataRec->bBitsPerPixel.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Sets correct values for lpxPFData->abBitsPerPixel[]
 *
 *
 ***************************************************************************/
void SetDropsPerPixel(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   ByteType    i;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   for (i=0; i<lpxPFData->bColorPlanes; i++)
   {
      lpxPFData->asdwDBIndx[DROPS_PER_PIXEL][i] = 1;
   }

   return;

}  /* end of SetDropsPerPixel() */




/****************************************************************************
 * Function Name:    SetBitsPerPixel
 *
 * Description:
 *    This function sets the internal (lpxPFData) bits per pixel
 *    value for each color plane, based on the input interface variable
 *    lpxDataRec->bBitsPerPixel.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Sets correct values for lpxPFData->abBitsPerPixel[]
 *
 *
 ***************************************************************************/
void SetBitsPerPixel(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   ByteType    i;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   for (i=0; i<lpxPFData->bColorPlanes; i++)
   {
      lpxPFData->abBitsPerPixel[i] = 1;
   }

   return;

}  /* end of SetBitsPerPixel() */

#if FC_FORMAT_INPUT_RASTER_LINE
/****************************************************************************
 * Function Name:    FormatInputRasterLine
 *
 * Description:
 *    Rome
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 *   Add yellow undercoating to Black with a mask to deepen the hue of black.
 * plane position    0     1        2        3        4       5      6
 * color 600 DPI   Cyan0 Cyan1   Magenta0 Magenta1 Yellow0 Yellow1 blacK
 *      1200 DPI   Cyan  Magenta Yellow   blacK
 *
 *        Y0 |=  K & (UnderCoatMask[RasterLineNumber % 2] )
 *
 * Outputs: Additional yellow in raster line.
 *
 *
 *
 ***************************************************************************/
void FormatInputRasterLine(LPDVDATAREC lpxDataRec,
                           SdwordType  sdwStripStart,
                           SwordType   swScanStart,
                           SwordType   swScanEnd)
{
   LPPFDATA    lpxPFData;

   if (swScanStart > swScanEnd)
   {  /* blank raster line so just return */
      return;
   }

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   sdwStripStart = sdwStripStart; /* silence the compiler */

   return;

}  /* end of FormatInputRasterLine() */

#endif /* FC_FORMAT_INPUT_RASTER_LINE */

#if defined(GEN_TEST_INPUT_FILES)
/****************************************************************************
 * Function Name:    SendRasters
 *
 * Description:
 *    This function is used to generate input image files for out development
 *    environment.  When GEN_TEST_INPUT_FILES is defined, we route all input
 *    raster lines to this function to be "printed".  All other print
 *    commands are also routed through this function, but since they don't
 *    begin with "XXXX" they are ignored.  I say "printed" because the proper
 *    use of this function is to set the driver to print to file, and then
 *    print images, which will result in image files that contains an exact
 *    image of what the driver gave the hbpcode as input.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *          lpCmdPtr    Long pointer to the data to be printed.
 *          dwSize      number of bytes in the print datastream.
 *
 * Outputs: Sends raster lines on to SendCommand() to be "printed".
 *
 *
 ***************************************************************************/
void FAR SendRasters(LPDVDATAREC lpxDataRec, void FAR * lpCmdPtr, DwordType dwSize)
{
   LPByteType     lpbCmdPtr;

   lpbCmdPtr = (LPByteType) lpCmdPtr;

   if ( (dwSize > 4) && ((_fstrncmp((char FAR *)lpbCmdPtr,"XXXX",4)) == 0) )
   {
      lpbCmdPtr += 4;
      dwSize    -= 4;
#if defined(DOS_BUILD) || defined(FC_DOS_32)
      OutToFile(lpxDataRec,lpbCmdPtr,dwSize);
#elif defined(FC_WIN16_DLL)
      lpfnSendCommand((void FAR *)lpxDataRec->lpLXGenericPtr, (void FAR *)lpbCmdPtr,
                      dwSize);
#else
      SendCommand((void FAR *)lpxDataRec->lpLXGenericPtr, (void FAR *)lpbCmdPtr,
                  dwSize);
#endif
   }

   return;

}  /* end of SendRasters() */
#endif




void CopyDocInfoToLSXface(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   LPHWDATA       lpxHWData;
   LPLSINTFACE    lpxLSXface;

   lpxPFData  = (LPPFDATA )lpxDataRec->lpLXDevice;
   lpxHWData  = lpxPFData->lpxHWData;
   lpxLSXface = (LPLSINTFACE)lpxPFData->lpxHWData->lpxLSXface;

   lpxLSXface->bColorPlanes            = lpxDataRec->bColorPlanes;
   lpxLSXface->bBidiAlignMono          = lpxDataRec->bBidiAlignMono;
   lpxLSXface->bHorizontalAdj          = lpxDataRec->bHorizontalAdj;
   lpxLSXface->bBidiAlignColor         = lpxDataRec->bBidiAlignColor;
   lpxLSXface->dwSecondsSinceLastPrint = lpxDataRec->dwSecondsSinceLastPrint;
   lpxLSXface->bMediaSource            = LS_AUTO_FEED;


   switch (lpxDataRec->bMediaSize)
   {
   case PAPER_LETTER :
   default :
      lpxLSXface->bMediaSize = LS_PAPER_LETTER;
      break;
   case PAPER_LEGAL:
      lpxLSXface->bMediaSize = LS_PAPER_LEGAL;
      break;
   case PAPER_B5:
      lpxLSXface->bMediaSize = LS_PAPER_B5;
      break;
   case PAPER_EXECUTIVE:
      lpxLSXface->bMediaSize = LS_PAPER_EXECUTIVE;
      break;
   case PAPER_A5:
      lpxLSXface->bMediaSize = LS_PAPER_A5;
      break;
   case PAPER_USER:
      lpxLSXface->bMediaSize = LS_PAPER_USER;
      break;
   case PAPER_A4:
      lpxLSXface->bMediaSize = LS_PAPER_A4;
      break;
   case PAPER_OHFHAGAKI:
      lpxLSXface->bMediaSize = LS_PAPER_OHFHAGAKI;
      break;
   case PAPER_HAGAKI:
      lpxLSXface->bMediaSize = LS_PAPER_HAGAKI;
      break;
   case ENVELOPE_MONARCH:
      lpxLSXface->bMediaSize = LS_ENVELOPE_MONARCH;
      break;
   case ENVELOPE_9:
      lpxLSXface->bMediaSize = LS_ENVELOPE_9;
      break;
   case ENVELOPE_10:
      lpxLSXface->bMediaSize = LS_ENVELOPE_10;
      break;
   case ENVELOPE_DL:
      lpxLSXface->bMediaSize = LS_ENVELOPE_DL;
      break;
   case ENVELOPE_C5:
      lpxLSXface->bMediaSize = LS_ENVELOPE_C5;
      break;
   case ENVELOPE_B5:
      lpxLSXface->bMediaSize = LS_ENVELOPE_B5;
      break;
   case ENVELOPE_C6:
      lpxLSXface->bMediaSize = LS_ENVELOPE_C6;
      break;
   case ENVELOPE_D5:
      lpxLSXface->bMediaSize = LS_ENVELOPE_D5;
      break;
   case ENVELOPE_75:
      lpxLSXface->bMediaSize = LS_ENVELOPE_75;
      break;
   case CARD_3X5:
      lpxLSXface->bMediaSize = LS_CARD_3X5;
      break;
   case CARD_4X6:
      lpxLSXface->bMediaSize = LS_CARD_4X6;
      break;
   case PAPER_BANNER_A4:
      lpxLSXface->bMediaSize = LS_PAPER_BANNER_A4;
      break;
   case PAPER_BANNER_LETTER:
      lpxLSXface->bMediaSize = LS_PAPER_BANNER_LETTER;
      break;
   case CARD_A6:
      lpxLSXface->bMediaSize = LS_CARD_A6;
      break;
   case ENVELOPE_BARONIAL:
      lpxLSXface->bMediaSize = LS_ENVELOPE_BARONIAL;
      break;
   case ENVELOPE_6_3_4:
      lpxLSXface->bMediaSize = LS_ENVELOPE_6_3_4;
      break;
   case JPNLONG3:
      lpxLSXface->bMediaSize = LS_JPNLONG3;
      break;
   case JPNSQUARE4:
      lpxLSXface->bMediaSize = LS_JPNSQUARE4;
      break;
   case JPNSQUARE5:
      lpxLSXface->bMediaSize = LS_JPNSQUARE5;
      break;
   case JPNSQUARE6:
      lpxLSXface->bMediaSize = LS_JPNSQUARE6;
      break;
   case PAPER_A3:
      lpxLSXface->bMediaSize = LS_PAPER_A3;
      break;
   case PAPER_SUPER_A3:
      lpxLSXface->bMediaSize = LS_PAPER_SUPER_A3;
      break;
   case PAPER_TABLOID:
      lpxLSXface->bMediaSize = LS_PAPER_TABLOID;
      break;
   case ENVELOPE_CUSTOM:
      lpxLSXface->bMediaSize = LS_ENVELOPE_CUSTOM;
      break;
   case PAPER_CUSTOM_BANNER:
      lpxLSXface->bMediaSize = LS_PAPER_CUSTOM_BANNER;
      break;
   case PAPER_CUSTOM:
      lpxLSXface->bMediaSize = LS_PAPER_CUSTOM;
      break;
   }


   switch (lpxDataRec->bMediaType)
   {
   case PLAIN_PAPER :
   default :
      lpxLSXface->bMediaType = LS_PLAIN_PAPER;
      break;
   case COATED_PAPER :
      lpxLSXface->bMediaType = LS_COATED_PAPER;
      break;
   case GLOSSY_PAPER :
      lpxLSXface->bMediaType = LS_GLOSSY_PAPER;
      break;
   case TRANSPARENCY :
      lpxLSXface->bMediaType = LS_TRANSPARENCY;
      break;
   case IRON_ON_TRANSFER :
      lpxLSXface->bMediaType = LS_IRON_ON_TRANSFER;
      break;
   case GREETING_CARD_STOCK :
      lpxLSXface->bMediaType = LS_GREETING_CARD_STOCK;
      break;
   }

   switch (lpxPFData->bPrintQuality)
   {
   case QUALITY_DRAFT :
      lpxLSXface->bPrintQuality = LS_QUALITY_DRAFT;
      break;
   case QUALITY_NORMAL :
   default :
      lpxLSXface->bPrintQuality = LS_QUALITY_NORMAL;
      break;
   case QUALITY_HIGH :
      if(lpxPFData->bShingle == SHINGLE_50)
      {
      /* Osaka uses the 1200_AS_2X_600 option for 1200 dpi that is 2 pass */
         lpxLSXface->bPrintQuality = LS_QUALITY_NORMAL;
      }
      else
      {
         lpxLSXface->bPrintQuality = LS_QUALITY_HIGH;
      }
      break;
   }

  return;

}




void CopySwathInfoToLSXface(LPDVDATAREC lpxDataRec, ByteType bSwathDensity)
{
   LPPFDATA       lpxPFData;
   LPHWDATA       lpxHWData;
   LPLSINTFACE    lpxLSXface;
   SwordType      swHorzMult;
   DwordType      dwDotCount,
                  dwSwathDensity;
   ByteType       bN;

   lpxPFData  = (LPPFDATA )lpxDataRec->lpLXDevice;
   lpxHWData  = lpxPFData->lpxHWData;
   lpxLSXface = (LPLSINTFACE)lpxPFData->lpxHWData->lpxLSXface;


   switch (lpxPFData->bResolution)
   {
   case SUPERLOWRES :
      swHorzMult = 4;
      lpxLSXface->xSwath.bResolution = LS_300_DPI;
      break;
   case LORES :
      swHorzMult = 2;

#if OPTION_600_AS_2X300
      if (lpxPFData->bShingleLoRes == SHINGLE_50)
      {  /* New 600 requires the 300 dpi(in 2 passes) printing mode */
         lpxLSXface->xSwath.bResolution = LS_300_DPI;
      }
      else
#endif

      {
         lpxLSXface->xSwath.bResolution = LS_600_DPI;
      }
      break;
   default :
      swHorzMult = 1;
      if(lpxPFData->bShingleHiRes == SHINGLE_50)
      {
         /* Print 1200 dpi as 2-pass 600 dpi   */
         lpxLSXface->xSwath.bResolution = LS_600_DPI;
      }
      else
      {
         lpxLSXface->xSwath.bResolution = LS_1200_DPI;
      }
      break;
   }

   lpxLSXface->xSwath.wSliceCount          = lpxPFData->wSliceCount;
   lpxLSXface->xSwath.dwVertMoveBeforePrint =
                           (DwordType)(WordType)lpxPFData->swFormsMovePending;
   lpxLSXface->xSwath.bBytesPerSlice       = lpxPFData->bBytesPerSlice;
   lpxLSXface->xSwath.swLeftPrintPos  = lpxPFData->swLeftPrintPos*swHorzMult;
   lpxLSXface->xSwath.swRightPrintPos = lpxPFData->swRightPrintPos*swHorzMult;

   switch (lpxPFData->bPrintDirection)
   {
   case  LTOR :
      lpxLSXface->xSwath.bPrintDirection = LS_LTOR;
      break;
   case RTOL :
      lpxLSXface->xSwath.bPrintDirection = LS_RTOL;
      break;
   case BIDI :
      lpxLSXface->xSwath.bPrintDirection = lpxPFData->bSwathDirection;
      break;
   }

   switch (lpxPFData->bPrintHead)
   {
   case COL_CARTRIDGE :
      lpxLSXface->xSwath.bPrintHead = LS_CMY_CARTRIDGE;
      break;
   case MONO_CARTRIDGE :
      lpxLSXface->xSwath.bPrintHead = LS_MONO_CARTRIDGE;
      break;
   case KCM_CARTRIDGE :
      lpxLSXface->xSwath.bPrintHead = LS_KCM_CARTRIDGE;
      break;
   }



   switch (lpxPFData->bPreRotateDir)
   {
   case  LTOR :
      lpxLSXface->xSwath.bNextPrintDirection = LS_LTOR;
      break;
   case RTOL :
      lpxLSXface->xSwath.bNextPrintDirection = LS_RTOL;
      break;
   case BIDI :
      lpxLSXface->xSwath.bNextPrintDirection = LS_BIDI;
      break;
   }

   switch (lpxPFData->bPreRotatePrintHead)
   {
   case COL_CARTRIDGE :
      lpxLSXface->xSwath.bNextPrintHead = LS_CMY_CARTRIDGE;
      break;
   case MONO_CARTRIDGE :
      lpxLSXface->xSwath.bNextPrintHead = LS_MONO_CARTRIDGE;
      break;
   case KCM_CARTRIDGE :
      lpxLSXface->xSwath.bNextPrintHead = LS_KCM_CARTRIDGE;
      break;
   }



   lpxLSXface->xSwath.dwNextVertMoveBeforePrint  =
                            (DwordType)(WordType)lpxPFData->swFutureFormsMovePending;
   lpxLSXface->xSwath.swNextLeftPrintPos = RastertoPrintPos(
                              lpxPFData->swPreRotateStart,lpxPFData->wLeftMargin);
   lpxLSXface->xSwath.swNextRightPrintPos = RastertoPrintPos(
                              lpxPFData->swPreRotateEnd,lpxPFData->wLeftMargin);
   lpxLSXface->xSwath.swNextRightPrintPos -= 1;

   if (lpxPFData->bPreRotatePrintHead == MONO_CARTRIDGE)
   {
      lpxLSXface->xSwath.swNextRightPrintPos +=
                                    (MONO_NOZZLE_OFFSET * lpxPFData->swSwathResMult);
   }
   else
   {
      lpxLSXface->xSwath.swNextRightPrintPos +=
             ((COLOR_NOZZLE_OFFSET + COLOR_HEAD_OFFSET) * lpxPFData->swSwathResMult);
   }


   lpxLSXface->xSwath.swNextLeftPrintPos  *= swHorzMult;
   lpxLSXface->xSwath.swNextRightPrintPos *= swHorzMult;



   if (bSwathDensity == FULL_SWATH)
   {
      dwSwathDensity = 1;
   }
   else if (bSwathDensity == HALF_SWATH)
   {
      dwSwathDensity = 2;
   }
   else
   {
      return;
   }

   switch (lpxPFData->bPrintHead)
   {
   case COL_CARTRIDGE :
      for (bN=0; bN<3; bN++)
      {
         if ( lpxPFData->asdwDotCount[bN] <
              (SdwordType)lpxHWData->adwDotCount[bN] )
         {  /* the PFData dot counts have been reinitialized */
            lpxHWData->adwDotCount[bN] = 0;
         }
         dwDotCount = (DwordType) (lpxPFData->asdwDotCount[bN] -
                      lpxHWData->adwDotCount[bN]) / dwSwathDensity;
         lpxLSXface->xSwath.adwDotCount[bN] = dwDotCount;
         lpxHWData->adwDotCount[bN]        += dwDotCount;
      }
      break;

   case MONO_CARTRIDGE :
      if (lpxDataRec->bColorPlanes == 1)
      {
         bN = 0;
      }
      else
      {
         bN = 3;
      }
      if (lpxPFData->asdwDotCount[bN] < (SdwordType)lpxHWData->adwDotCount[bN])
      {  /* the PFData dot counts have been reinitialized */
         lpxHWData->adwDotCount[bN] = 0;
      }
      dwDotCount = (DwordType) (lpxPFData->asdwDotCount[bN] -
                   lpxHWData->adwDotCount[bN]) / dwSwathDensity;
      lpxLSXface->xSwath.adwDotCount[0] = dwDotCount;
      lpxHWData->adwDotCount[bN]       += dwDotCount;
      break;

   case KCM_CARTRIDGE :
      for (bN=3; bN<6; bN++)
      {
         if (lpxPFData->asdwDotCount[bN] < (SdwordType)lpxHWData->adwDotCount[bN])
         {  /* the PFData dot counts have been reinitialized */
            lpxHWData->adwDotCount[bN] = 0;
         }
         dwDotCount = (DwordType) (lpxPFData->asdwDotCount[bN] -
                      lpxHWData->adwDotCount[bN]) / dwSwathDensity;
         lpxLSXface->xSwath.adwDotCount[bN-3] = dwDotCount;
         lpxHWData->adwDotCount[bN]          += dwDotCount;
      }
      break;
   }

  return;

}

/****************************************************************************
 * Function Name:    ExpandSwathTo8Inches
 *
 * Description:
 *    For Osaka, we must slow down envelope printing to allow time for the
 *    ink to dry before it rubs against the back edge of the cartrdige.  One
 *    way we do this is by taking each swath and expanding it to 8 inches, so
 *    the carrier moves the entire 8 inches, thereby taking more time.  This
 *    is the function which expands each swath to 8 inches.
 *
 * Inputs:  lpxDataRec   Long pointer to print device structure.
 *
 * Outputs: expands a swath to 8 inches.
 *
 *
 ***************************************************************************/
DwordType ExpandSwathTo8Inches(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   ByteType    bResolution,
               bSliceSize;
   WordType    n,
               wSliceCount,
               wMultiplier;
   SwordType   m,
               swLeftPrtPos,
               swRightPrtPos,
               swGivenSlices,
               swSlicesToAdd;
   HPByteType  hpbDataPtr;
   DwordType   dwSize;


   lpxPFData    = (LPPFDATA)lpxDataRec->lpLXDevice;
   bResolution  = lpxPFData->bResolution;

   switch (bResolution)
   {
   case 1 :
      wMultiplier = 1;
      break;
   case 2 :
   case 3 :
      wMultiplier = 2;
      break;
   case 4 :
   case 5 :
      wMultiplier = 4;
      break;
   default :
      wMultiplier = 1;
   }

   bSliceSize   = lpxPFData->bBytesPerSlice;

   wSliceCount  = lpxPFData->wSliceCount;

   swLeftPrtPos  = lpxPFData->swLeftPrintPos;

   swRightPrtPos = lpxPFData->swRightPrintPos;


   swSlicesToAdd = (SwordType)(300L*8*wMultiplier) - swRightPrtPos - 1;

   if (swSlicesToAdd <= 0)
   {
      /* don't change anything */
      return(0);
   }
   swGivenSlices = swRightPrtPos-swLeftPrtPos;
   swRightPrtPos += (WordType)swSlicesToAdd;

   if ( lpxPFData->bShingle == SHINGLE_50 )
   {
      swGivenSlices = (swGivenSlices / 2) + (swGivenSlices % 2);
      swSlicesToAdd = (swSlicesToAdd / 2) + (swSlicesToAdd % 2);
   }
   hpbDataPtr = (HPByteType)lpxPFData->lpxPrtCmd + SWATH_HEADER_SIZE +
                ((DwordType)(swGivenSlices+1)*(DwordType)bSliceSize);

   for (m=0; m<swSlicesToAdd; m++)
   {
      for (n=0; n<(WordType)bSliceSize; n++)
      {
         *hpbDataPtr++ = 0x00;
      }
   }

   wSliceCount  += (WordType)swSlicesToAdd;

   lpxPFData->wSliceCount = wSliceCount;
   lpxPFData->swRightPrintPos = swRightPrtPos;

   dwSize = ((DwordType)wSliceCount*(DwordType)bSliceSize) +
            (DwordType)SWATH_HEADER_SIZE;

   return(dwSize);

}  /* end of ExpandSwathTo8Inches() */

