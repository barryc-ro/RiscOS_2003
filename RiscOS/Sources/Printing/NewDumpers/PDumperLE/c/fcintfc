
//#pragma warning (disable: 4103)  /* used #pragma pack to change alignment */
//#pragma warning (disable: 4213)  /* nonstndrd extension used: cast on l-value*/

#if defined(DOS_BUILD) || defined(FC_DOS_32)
//#include <stdio.h>
//#include <malloc.h>
#endif
#ifndef FC_WIN_32
//#include <memory.h>
#endif
#include "common.h"
//#include <stdlib.h>

static char fc_version[] = "fcintfc.obj: "FC_VERSION;  /* set object module level ID */

/***************************************************************************
 * FC_INTFC.C                                        Lexmark Confidential
 *
 * Function Name:    FCKillStore
 *
 * Description:
 *    This function ***MUST*** be called at the end of every print job.  It
 *    frees all resolution dependent memory that was allocated by
 *    FCInitStore().
 *
 * Inputs:  lpDataRec    Long pointer to print device structure.
 *
 * Outputs: <none>
 *
 * Original Author: Bob Locasto
 * Date: 05/07/97
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
static void FAR FCKillStore(LPDVDATAREC lpDataRec)
{
   struct  pf_data FAR *pfData;
   int   n,i;

   if (lpDataRec)
      pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   else
      pfData = NULL;

   if (pfData)
   {  /* storage is allocated, so free it */
      for (n=0;n<MAXNUMPLANES;n++)
      {
         for (i=0;i<=((pfData->alDBIndx[BUFSIZE][n]-1)/pfData->nRastersPerSeg);i++)
            if (pfData->alpwPlane[n+(i*MAXNUMPLANES)])
               FREE(pfData->alpwPlane[n+(i*MAXNUMPLANES)]);
      }

      if (pfData->lpbMemArea)
         FREE(pfData->lpbMemArea);

      if ((LPBYTE) pfData->pPrtCmd)
      {
         if (pfData->nSlicesPerRow > SLICES_PER_SEG)
         {
            if (pfData->alpbSwath[0] == (LPBYTE)(pfData->pPrtCmd+SWATH_HEADER_SIZE))
               pfData->alpbSwath[0] = NULL;
            FREE((struct tPrintCmd _huge *)pfData->pPrtCmd);
         }
         else
         {
            FREE((struct tPrintCmd FAR *)pfData->pPrtCmd);
            pfData->alpbSwath[0] = NULL;
         }
      }

#if   OPTION_COMPRESSION
      if ((LPBYTE) pfData->pCompPrtCmd)
      {
         if (pfData->nSlicesPerRow > SLICES_PER_SEG)
            FREE((struct tPrintCmd _huge *)pfData->pCompPrtCmd);
         else
            FREE((struct tPrintCmd FAR *)pfData->pCompPrtCmd);
      }
#endif

#if   OPTION_CHECKDENSITY
      if ((LPBYTE) pfData->pDensePrtCmd)
      {
         if (pfData->nSlicesPerRow > SLICES_PER_SEG)
            FREE((struct tPrintCmd _huge *)pfData->pDensePrtCmd);
         else
            FREE((struct tPrintCmd FAR *)pfData->pDensePrtCmd);
      }
#endif

      for (i=0; i<=((pfData->nSlicesPerRow-1)/SLICES_PER_SEG);i++)
      {
         if (pfData->alpbSwath[i])
            FREE(pfData->alpbSwath[i]);
      }

#if   OPTION_REVERSE_SWATH
      if (pfData->lpwReverseRaster)
         FREE(pfData->lpwReverseRaster);
#endif
   }
   return;
}  /* end of FCKillStore() */


/***************************************************************************
 *  FC_INTFC.C                                          Lexmark Confidential
 *
 * Function Name:    FCInitStore
 *
 * Description:
 *    This function is expected to be called at the beginning of every print
 *    job and sometimes at the beginning of a padge. It allocates all storage
 *    that is based on resolution and initializes variables/pointers.
 *
 * Inputs:  lpDataRec          Far pointer to HBP interface structure.
 *
 * Outputs: fStoreAllocated   TRUE - storage allocation successful
 *                            FALSE - storage allocation failed
 *
 * Original Author: Bob Locasto
 * Date: 05/06/97
 *
 * Changes:
 *    Date        Name           Reason for Change
 * 05/07/97       RFL            Added OPTION_REVERSE_SWATH test.
 *************************************************************************/
static UINT FAR FCInitStore(LPDVDATAREC lpDataRec)
{
   struct   pf_data FAR *pfData;
   FC_INT   n,i,nMemAreaSize,nIStart;
   BOOL     fStoreAllocated;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

   fStoreAllocated = TRUE; /* storage allocate successful */
   while (fStoreAllocated)
   {
      /* Set up the resolution for this print job */
      switch (GetResolution(lpDataRec))
      {
          case SUPERLOWRES:
             /* Super Low resolution for printers that have 3 resolutions */
             pfData->bResolution    = SUPERLOWRES;
             pfData->nVertResMult   = SLRES_VERTICAL_MULTIPLIER;
             pfData->nRastResMult   = SLRES_RASTER_MULTIPLIER;
             pfData->nSwathResMult  = SLRES_SWATH_MULTIPLIER;
             pfData->nBytesPerRow   = SLRES_BYTES_PER_ROW;
             pfData->nWordsPerRow   = SLRES_BYTES_PER_ROW / 2;
             pfData->nRastersPerSeg = SLRES_RASTERS_PER_SEGMENT;
             break;

          case LORES:
             /* Low resolution */
             pfData->bResolution    = LORES;
             pfData->nVertResMult   = LORES_VERTICAL_MULTIPLIER;
             pfData->nRastResMult   = LORES_RASTER_MULTIPLIER;
             pfData->nSwathResMult  = LORES_SWATH_MULTIPLIER;
             pfData->nBytesPerRow   = LORES_BYTES_PER_ROW;
             pfData->nWordsPerRow   = LORES_BYTES_PER_ROW / 2;
             pfData->nRastersPerSeg = LORES_RASTERS_PER_SEGMENT;
             break;

          case MIDRES:
             /* resolution between normal and high */
             pfData->bResolution    = HIRES; /* all buffers will be doubled */
             pfData->nVertResMult   = LORES_VERTICAL_MULTIPLIER;
             pfData->nRastResMult   = HIRES_RASTER_MULTIPLIER;
             pfData->nSwathResMult  = HIRES_SWATH_MULTIPLIER;
             pfData->nBytesPerRow   = HIRES_BYTES_PER_ROW;
             pfData->nWordsPerRow   = HIRES_BYTES_PER_ROW / 2;
             pfData->nRastersPerSeg = HIRES_RASTERS_PER_SEGMENT;
             break;

          case HIRES:
             /* High resolution */
             pfData->bResolution    = HIRES; /* all buffers will be doubled */
             pfData->nVertResMult   = HIRES_VERTICAL_MULTIPLIER;
             pfData->nRastResMult   = HIRES_RASTER_MULTIPLIER;
             pfData->nSwathResMult  = HIRES_SWATH_MULTIPLIER;
             pfData->nBytesPerRow   = HIRES_BYTES_PER_ROW;
             pfData->nWordsPerRow   = HIRES_BYTES_PER_ROW / 2;
             pfData->nRastersPerSeg = HIRES_RASTERS_PER_SEGMENT;
             break;

      }   /* end of Set up the resolution for this print page */

      /**************************
       * set pointers to buffers
       **************************/
      pfData->alDBIndx[BUFSIZE][0] = P1_BUFNUM * pfData->nVertResMult;
      pfData->alDBIndx[BUFSIZE][1] = P2_BUFNUM * pfData->nVertResMult;
      pfData->alDBIndx[BUFSIZE][2] = P3_BUFNUM * pfData->nVertResMult;
      pfData->alDBIndx[BUFSIZE][3] = P4_BUFNUM * pfData->nVertResMult;
      pfData->alDBIndx[BUFSIZE][4] = P5_BUFNUM * pfData->nVertResMult;
      pfData->alDBIndx[BUFSIZE][5] = P6_BUFNUM * pfData->nVertResMult;

      /*************************
       * allocate delay buffers
       *************************/
      for (n = 0;n < MAXNUMPLANES; n++)
      {  /* loop for max number of planes possible */
         /* the -1 in the statement (pfData->alDBIndx[BUFSIZE][n]-1) is so
            we don't allocate a zero length buffer segment when the number of
            rows to be stored in the delay buffer is evenly divisible by the
            number of rows per segment */
         for (i=0; i<=((pfData->alDBIndx[BUFSIZE][n]-1)/pfData->nRastersPerSeg); i++)
         {
            if (i == ((pfData->alDBIndx[BUFSIZE][n]-1)/pfData->nRastersPerSeg))
               pfData->alpwPlane[n+(i*MAXNUMPLANES)] = (LPWORD)
                        MALLOC((WORD) ((pfData->alDBIndx[BUFSIZE][n] %
                        pfData->nRastersPerSeg) * pfData->nBytesPerRow));
            else
               pfData->alpwPlane[n+(i*MAXNUMPLANES)] = (LPWORD)
                        MALLOC((WORD) (pfData->nRastersPerSeg *
                        pfData->nBytesPerRow));

            if (pfData->alpwPlane[n+(i*MAXNUMPLANES)] == NULL)
            {
               fStoreAllocated = FALSE;
               break;
            }
         }
         if   (!fStoreAllocated)
            break;
      } /* end of allocating delay buffers */

      if (fStoreAllocated == FALSE)
         break;

      /******************************
       * allocate print swath buffer
       ******************************/
      pfData->nSlicesPerRow = pfData->nBytesPerRow * 8;
      if (pfData->nSlicesPerRow > SLICES_PER_SEG)
      {  /* larger than one segment */
         pfData->pPrtCmd = (HPBYTE)MALLOC((PRT_CMD_SIZE));
         if (LOWORD(pfData->pPrtCmd) == 0)
         {
            pfData->alpbSwath[0]=(LPBYTE)(pfData->pPrtCmd+SWATH_HEADER_SIZE);
            nIStart = 1;
         }
         else
            nIStart = 0;

         if    (!(LPBYTE)pfData->pPrtCmd)
         {
             fStoreAllocated = FALSE;
             break;
         }
      }
      else
      {
         pfData->pPrtCmd = MALLOC(((WORD)PRT_CMD_SIZE));
         pfData->alpbSwath[0] = (LPBYTE) (pfData->pPrtCmd+SWATH_HEADER_SIZE);
         nIStart = 1;

         if     (!(LPBYTE)pfData->pPrtCmd)
         {
             fStoreAllocated = FALSE;
             break;
         }
      }  /* end of allocate print swath buffer */
      /*********************************************************************
       * the -1 in the statement (pfData->nSlicesPerSeg-1) is so we don't
       * allocate a zero length buffer segment when the swath slices per
       * row is evenly divisible by MAX_SLICES_PER_SEG.
       *********************************************************************/
      for (i = nIStart; i <= ((pfData->nSlicesPerRow-1)/SLICES_PER_SEG); i++)
      {
         pfData->alpbSwath[i] = (LPBYTE)MALLOC(
                     (WORD)((WORD)K_BYTES_PER_SLICE* (WORD)SLICES_PER_SEG));
         if   (!pfData->alpbSwath[i])
         {
            fStoreAllocated = FALSE;
            break;
         }
      }
      if (fStoreAllocated == FALSE)
         break;

#if   OPTION_COMPRESSION
      /* get compressed print swath buffer */
      if (pfData->nSlicesPerRow > SLICES_PER_SEG)
         (HPBYTE)pfData->pCompPrtCmd=(HPBYTE)MALLOC((PRT_CMD_SIZE));
      else
         pfData->pCompPrtCmd = MALLOC(((WORD)PRT_CMD_SIZE));

      if   (!(LPBYTE)pfData->pCompPrtCmd)
      {
         fStoreAllocated = FALSE;
         break;
      }
#else
      pfData->pCompPrtCmd = 0;
#endif

#if   OPTION_CHECKDENSITY
      /*************************************************************
       * get extra print swath buffer for swaths that are too dense
       *************************************************************/
      if (pfData->nSlicesPerRow > SLICES_PER_SEG)
         (HPBYTE)pfData->pDensePrtCmd = (HPBYTE)MALLOC((PRT_CMD_SIZE));
      else
         (LPBYTE)pfData->pDensePrtCmd = (LPBYTE)MALLOC(((WORD)PRT_CMD_SIZE));

      if   (!(LPBYTE)pfData->pDensePrtCmd)
      {
         fStoreAllocated = FALSE;
         break;
      }
      PopulateBitCount(lpDataRec);
#else
      pfData->pDensePrtCmd = 0;
#endif

#if   OPTION_REVERSE_SWATH
      /**********************************************************************
       * Used for products that require a print swath to be built in reverse
       **********************************************************************/
      pfData->lpwReverseRaster = (LPWORD) MALLOC(pfData->nBytesPerRow);
      if    (!pfData->lpwReverseRaster)
      {
         fStoreAllocated = FALSE;
         break;
      }
#else
      pfData->lpwReverseRaster = 0;
#endif

      /********************************************************************
       * get storage for several smaller 'chunks' of memory
       * specifically:
       *       Print Line Mask   16 words
       *       Raster Line Mask  16 words
       *       Shingle Mask      10 shingle passes * 20 words each
       *                         we are not currently using 10 shingle
       *                         masks, but this allows room to grow.
       *       Scan Start Array  Max Delay Buffer * Max Num Planes words
       *       Scan End Array    Max Delay Buffer * Max Num Planes words
       *       Shingle line      Max Delay Buffer * Max Num Planes words
       *       Shingle to Apply  Max Delay Buffer * Max Num Planes bytes
       ********************************************************************/
      pfData->nMaxDelayBuf = MAXBUFNUM * pfData->nVertResMult;

      nMemAreaSize = (FC_INT)((16 + 16 + 400 +
                         (pfData->nMaxDelayBuf*MAXNUMPLANES*3))*2 +
                         (pfData->nMaxDelayBuf*MAXNUMPLANES));
      pfData->lpbMemArea = (LPBYTE) MALLOC(nMemAreaSize);

      if   (pfData->lpbMemArea)
      {
         pfData->lpwPrtMask            = (LPWORD)pfData->lpbMemArea;
         pfData->lpwRastMask           = (LPWORD)(pfData->lpbMemArea+32);
         pfData->alpwShingleMask[0]    = (LPWORD)(pfData->lpbMemArea+32+32);
         pfData->alpnScanStart[0]      = (FC_LPINT)(pfData->lpbMemArea+32+
                                         32+400);
         pfData->alpnScanEnd[0]        = (FC_LPINT)(pfData->lpbMemArea+32+
                                         32+400+
                                         (pfData->nMaxDelayBuf*MAXNUMPLANES*2));
         pfData->alpwShingleLine[0]    = (LPWORD) (pfData->lpbMemArea+32+32+400+
                                         (pfData->nMaxDelayBuf*MAXNUMPLANES*2)+
                                         (pfData->nMaxDelayBuf*MAXNUMPLANES*2));
         pfData->alpbShingleToApply[0] = (LPBYTE) (pfData->lpbMemArea+32+32+400+
                                         (pfData->nMaxDelayBuf*MAXNUMPLANES*2)+
                                         (pfData->nMaxDelayBuf*MAXNUMPLANES*2)+
                                         (pfData->nMaxDelayBuf*MAXNUMPLANES*2));
         for (n=1;n<MAXNUMPLANES;n++)
         {
            pfData->alpnScanStart[n]      = pfData->alpnScanStart[n-1] +
                                          pfData->nMaxDelayBuf;
            pfData->alpnScanEnd[n]        = pfData->alpnScanEnd[n-1] +
                                          pfData->nMaxDelayBuf;
            pfData->alpwShingleLine[n]    = pfData->alpwShingleLine[n-1] +
                                          pfData->nMaxDelayBuf;
            pfData->alpbShingleToApply[n] = pfData->alpbShingleToApply[n-1] +
                                          pfData->nMaxDelayBuf;
         }

         for (n=1;n<10;n++)
            pfData->alpwShingleMask[n] = pfData->alpwShingleMask[n-1] + 20;
      }
      else
      {
         fStoreAllocated = FALSE;
         break;
      }
      break;   /* get out of loop unconditionally */
   } /* end of: while (fStoreAllocated) */

   return(fStoreAllocated);

}  /* end of FCInitStore(); */

/***************************************************************************
 *  FC_INTFC.C                                          Lexmark Confidential
 *
 * Function Name:    FCStartDoc
 *
 * Description:
 *    This function is expected to be called at the beginning of every print
 *    job. It allocates all global memory required by all print formatter
 *    functions.
 *
 * Inputs:  lpDataRec          Far pointer to HBP interface structure.
 *
 * Outputs: fStoreAllocated   TRUE - storage allocation successful
 *                            FALSE - storage allocation failed
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name         Reason for Change
 *  5/06/97       RFL          moved variable store allocate to FCInitStore()
 *                             for page resolution support.
 *************************************************************************/
UINT FAR FCStartDoc(LPDVDATAREC lpDataRec)
{
   struct   pf_data FAR *pfData;
   FC_INT   n ;
   BOOL     fStoreAllocated;


   FCEndDoc(lpDataRec); /* Clean up any prior or current allocated space */

   /********************************************************
    * get pfData, the print formatter common data structure
    ********************************************************/
   lpDataRec->lpLXDevice = (DWORD)MALLOC(COMMONBUFSIZE);
   pfData = (struct pf_data FAR *) lpDataRec->lpLXDevice;

   if (pfData)
   {
      fStoreAllocated = FCInitStore(lpDataRec); /* get the rest of storage */

      if   (fStoreAllocated)
      {
         /*************************************************
          * initialize dot count to 0 for all color planes
          *************************************************/
         for (n = 0; n < MAXNUMPLANES; n++)
            pfData->alDotCount[n] = 0;

         /***************************************
          * get hardware printer specific buffer
          ***************************************/
         pfData->lpHwData = (struct tHwData FAR *) MALLOC(HW_BUFF_SIZE);

         if   (pfData->lpHwData)
            HwStartPrintJob(lpDataRec);
         else
            fStoreAllocated = FALSE;

      }   /* end of FCInitStore() sucessfull */
   }  /* end of lpDataRec->lpLXDevice allocated */
   else
      fStoreAllocated = FALSE;


   return(fStoreAllocated);

} /* end of FCStartDoc() */



/***************************************************************************
 *  FC_INTFC.C                                          Lexmark Confidential
 *
 * Function Name:    FCStartPage
 *
 * Description:
 *    This function is expected to be called at the beginning of every print
 *    page.  It initializes several variables in the print formatter
 *    structure (pfData), based on information in reads from the HBP interface
 *    structure (lpDataRec).
 *
 * Inputs:  lpDataRec    Long pointer to print device structure.
 *
 * Outputs: TRUE        Always returns successful.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *    4/29/97     RFL            Added SmartBIDI
 *    5/07/97     RFL            Added padge boundary resolution.
 *    9/25/97     RFL            Added support for generation of print
 *                                formatter test files (GEN_TEST_INPUT_FILES).
 *
 *************************************************************************/
UINT FAR FCStartPage(LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   int n, nHead1VertAlign = 0, nHead2VertAlign = 0;
   BOOL     fStoreAllocated;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

   /*******************************************
    * test for page boundry resolution change
    *******************************************/
   if   ((GetResolution(lpDataRec)) != pfData->bResolution)
   {
       FCKillStore(lpDataRec); /* release resolution dependent storage */
       fStoreAllocated = FCInitStore(lpDataRec); /* allocate resolution dependent storage */
       if (fStoreAllocated == FALSE)
         return(FALSE);
   }

   pfData->lRowPos          = -1;            /* raster row number begins at 0 */
                                             /* but DWORD is only postive */
   pfData->bPrintQuality     = lpDataRec->bQuality;
   pfData->fSwathPresent     = FALSE;

   /* order is important! Resolution must be set before margins are set */
   pfData->bResolution             = GetResolution(lpDataRec);
   pfData->wLeftMargin             = GetLeftMargin(lpDataRec);
   pfData->wTopMargin              = GetTopMargin(lpDataRec);
   pfData->nFormsMovePending       = pfData->wTopMargin;
   pfData->nFutureFormsMovePending = 0;
   pfData->bShingle                = GetShingleMode(lpDataRec);

   for (n=0; n<MAXNUMPLANES; n++)
   {
      pfData->awExtraNozzles[n] = 0;
      pfData->abShingleIndex[n] = COLOR;
   }

   switch (lpDataRec->bColorPlanes)
   {
      case 1 :
         if ((pfData->bResolution == HIRES) || (pfData->bResolution == MIDRES))
         {
            pfData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT;
            pfData->abShingleIndex[3] = MONO_PART;
         }
         else
         {
            pfData->wBaseNozzleCount  = MONO_NOZZLE_COUNT;
            pfData->abShingleIndex[3] = MONO_FULL;
         }
         break;
      case 3 :
         pfData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT/3;
         break;
      case 4 :
         pfData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT/3;
         pfData->awExtraNozzles[3] = COLOR_NOZZLE_COUNT - (COLOR_NOZZLE_COUNT/3);
         pfData->abShingleIndex[3] = MONO_PART;
         break;
      case 6 :
         pfData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT/3;
         break;
   }


   if ((pfData->bResolution == HIRES) && (lpDataRec->bShingle == SHINGLE_25))
   {
      /* 25% shingling at high resolution is not supported */
      lpDataRec->bShingle = SHINGLE_50;
   }

#if OPTION_CDE
   pfData->fCDE = CheckForCDE(pfData->bResolution,lpDataRec->bQuality);
   if (lpDataRec->bShingle != NO_SHINGLE)
      pfData->fCDE = FALSE;
#endif

   FCSetPaperSource(lpDataRec);

   LoadShingleMasks(lpDataRec, lpDataRec->bColorPlanes);

   switch (lpDataRec->bColorPlanes)
   {  /* Set print mode, beginning and ending delay buffer, and initial
         delay for delay buffers */

      case 1 : /* black only */
               pfData->nDelayBufStart = 3;
               pfData->nDelayBufEnd   = 4;
               pfData->alDBIndx[INIT_DELAY][3] = KONLY_P4_DELAY;
               pfData->bPrintHead = MONO_CARTRIDGE;
#ifdef SMARTBIDI                                             /*RFL*/
               if    (pfData->bShingle == NO_SHINGLE &&
                      pfData->bResolution == LORES)
                  pfData->iSmartBIDI = 1;   /* set test for SmartBIDI */
               pfData->bPrtDir = LTOR;      /* set initial direction */
               pfData->iLastLineNull = 0;   /* set last line to not NULL */
#endif
               break;

      case 3 : /* CMY */
               pfData->nDelayBufStart = 0;
               pfData->nDelayBufEnd   = 3;
               pfData->alDBIndx[INIT_DELAY][0] = CMY_P1_DELAY;
               pfData->alDBIndx[INIT_DELAY][1] = CMY_P2_DELAY;
               pfData->alDBIndx[INIT_DELAY][2] = CMY_P3_DELAY;
               pfData->bPrintHead = COL_CARTRIDGE;
               break;

      case 4 : /* CMYK */
               pfData->nDelayBufStart = 0;
               pfData->nDelayBufEnd   = 4;
               pfData->alDBIndx[INIT_DELAY][0] = CMYK_P1_DELAY;
               pfData->alDBIndx[INIT_DELAY][1] = CMYK_P2_DELAY;
               pfData->alDBIndx[INIT_DELAY][2] = CMYK_P3_DELAY;
               pfData->alDBIndx[INIT_DELAY][3] = CMYK_P4_DELAY;
               break;

      case 6 : /* CMYKCM */
               pfData->nDelayBufStart = 0;
               pfData->nDelayBufEnd   = 6;

               pfData->nVertAlign = lpDataRec->bVerticalAdj;
               if ((pfData->nVertAlign < VERTHEAD_MINALIGN) ||
                   (pfData->nVertAlign > VERTHEAD_MAXALIGN))
                  pfData->nVertAlign = VERTHEAD_MIDALIGN;

               if (pfData->nVertAlign < VERTHEAD_MIDALIGN)
                  nHead1VertAlign = (VERTHEAD_MIDALIGN - pfData->nVertAlign);
               else if (pfData->nVertAlign > VERTHEAD_MIDALIGN)
                  nHead2VertAlign = (pfData->nVertAlign - VERTHEAD_MIDALIGN);

               pfData->alDBIndx[INIT_DELAY][0] = (FC_INT)(CMYKCM_P1_DELAY +
                                                     nHead1VertAlign);
               pfData->alDBIndx[INIT_DELAY][1] = (FC_INT)(CMYKCM_P2_DELAY +
                                                     nHead1VertAlign);
               pfData->alDBIndx[INIT_DELAY][2] = (FC_INT)(CMYKCM_P3_DELAY +
                                                     nHead1VertAlign);
               pfData->alDBIndx[INIT_DELAY][3] = (FC_INT)(CMYKCM_P4_DELAY +
                                                     nHead2VertAlign);
               pfData->alDBIndx[INIT_DELAY][4] = (FC_INT)(CMYKCM_P5_DELAY +
                                                     nHead2VertAlign);
               pfData->alDBIndx[INIT_DELAY][5] = (FC_INT)(CMYKCM_P6_DELAY +
                                                     nHead2VertAlign);
               break;

      default :
               break;
   }  /* End of: Set print mode, beginning and ending delay buffer, and
         initial delay for delay buffers */

   ResetBuffers(0L,lpDataRec);

   pfData->lpwPrtMask[0] = PRINT_MASK0;
   pfData->lpwPrtMask[1] = PRINT_MASK1;
   pfData->lpwPrtMask[2] = PRINT_MASK2;
   pfData->lpwPrtMask[3] = PRINT_MASK3;
   pfData->lpwPrtMask[4] = PRINT_MASK4;
   pfData->lpwPrtMask[5] = PRINT_MASK5;
   pfData->lpwPrtMask[6] = PRINT_MASK6;
   pfData->lpwPrtMask[7] = PRINT_MASK7;
   pfData->lpwPrtMask[8] = PRINT_MASK8;
   pfData->lpwPrtMask[9] = PRINT_MASK9;
   pfData->lpwPrtMask[10] = PRINT_MASK10;
   pfData->lpwPrtMask[11] = PRINT_MASK11;
   pfData->lpwPrtMask[12] = PRINT_MASK12;
   pfData->lpwPrtMask[13] = PRINT_MASK13;
   pfData->lpwPrtMask[14] = PRINT_MASK14;
   pfData->lpwPrtMask[15] = PRINT_MASK15;

   pfData->lpwRastMask[0] = RASTER_MASK0;
   pfData->lpwRastMask[1] = RASTER_MASK1;
   pfData->lpwRastMask[2] = RASTER_MASK2;
   pfData->lpwRastMask[3] = RASTER_MASK3;
   pfData->lpwRastMask[4] = RASTER_MASK4;
   pfData->lpwRastMask[5] = RASTER_MASK5;
   pfData->lpwRastMask[6] = RASTER_MASK6;
   pfData->lpwRastMask[7] = RASTER_MASK7;
   pfData->lpwRastMask[8] = RASTER_MASK8;
   pfData->lpwRastMask[9] = RASTER_MASK9;
   pfData->lpwRastMask[10] = RASTER_MASK10;
   pfData->lpwRastMask[11] = RASTER_MASK11;
   pfData->lpwRastMask[12] = RASTER_MASK12;
   pfData->lpwRastMask[13] = RASTER_MASK13;
   pfData->lpwRastMask[14] = RASTER_MASK14;
   pfData->lpwRastMask[15] = RASTER_MASK15;

   HwStartPage(lpDataRec);

#ifdef GEN_TEST_INPUT_FILES   /* include test file generation */

   GenTstInit( lpDataRec, pfData->nBytesPerRow, lpDataRec->bColorPlanes);

#endif   /* defined GEN_TEST_INPUT_FILES */

   return(TRUE);
} /* end of FCStartPage() */




/***************************************************************************
 *  FC_INTFC.C                                          Lexmark Confidential
 *
 * Function Name:    FCEndPage
 *
 * Description:
 *    This function ***MUST*** be called at the end of every print page.  It
 *    calls function FlushBuffers(), which formats and prints all raster
 *    lines that are in the delay buffers.
 *
 * Inputs:  lpDataRec    Long pointer to print device structure.
 *
 * Outputs: <none>
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *    9/25/97     RFL            Added support for generation of print
 *                                formatter test files (GEN_TEST_INPUT_FILES).
 *
 *************************************************************************/
void FAR FCEndPage(LPDVDATAREC lpDataRec)
{
   FlushBuffers(lpDataRec,END_OF_PAGE);

   HwEndPage(lpDataRec);

#ifdef GEN_TEST_INPUT_FILES   /* include test file generation */
   GenTstCleanup( lpDataRec);
#endif

   return;
}  /* End of FCEndPage() */




/***************************************************************************
 * FC_INTFC.C                                        Lexmark Confidential
 *
 * Function Name:    FCEndDoc
 *
 * Description:
 *    This function ***MUST*** be called at the end of every print job.  It
 *    frees all fixed size memory that was allocated in FCStartDoc().
 *
 * Inputs:  lpDataRec    Long pointer to print device structure.
 *
 * Outputs: <none>
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name        Reason for Change
 *  5/07/97       RFL         moved variable store release to FCKillStore()
 *                            for page resolution support.
 *************************************************************************/
void FAR FCEndDoc(LPDVDATAREC lpDataRec)
{
   struct  pf_data FAR *pfData;

   if   (lpDataRec)
   {
      pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

      if (pfData)
      {  /* storage is allocated, so free it */
          FCKillStore(lpDataRec);/* release resolution dependent storage */

          if (pfData->lpHwData)
             FREE(pfData->lpHwData);

          FREE(pfData);
          lpDataRec->lpLXDevice = NULL;

          HwEndJob(lpDataRec);

      }  /* end of freeing storage allocation */
   }
   else
      pfData = NULL;

   return;

}  /* End of FCEndDoc() */




/***************************************************************************
 *  FC_INTFC.C                                          Lexmark Confidential
 *
 * Function Name:    ResetBuffers
 *
 * Description:
 *    This function initializes the IN and OUT indexes that point into the
 *    delay buffers.  It should be called every time the delay buffers have
 *    been emptied and need to be reinitialized.
 *
 * Inputs:  lpDataRec    Long pointer to HBP interface structure.
 *
 * Outputs: Initializes the IN and OUT indexes which point into the color
 *          plane delay buffers.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void ResetBuffers(FC_LONG lCurrentRowPos, LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   int n,m;
   int   nShingleSize;
   int   nNozzleCount;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

   pfData->lRasterLinesProcessed   = 0;
   pfData->lRowsToProcess          = (FC_LONG)pfData->wBaseNozzleCount;
   pfData->nFutureRowsToShingle    = 0;
   pfData->nOut                    = FC_OUT;
   pfData->bBIDIPrintDirection     = LTOR;
   pfData->lBottomNozzleRowNum     = lCurrentRowPos - 1;
/*   pfData->nFutureFormsMovePending = 0; */

   for (n=pfData->nDelayBufStart; n<pfData->nDelayBufEnd; n++)
   {
      nNozzleCount = pfData->wBaseNozzleCount + pfData->awExtraNozzles[n];
      pfData->alDBIndx[FC_IN][n]    = 0;
      pfData->awRowsToDelayPrint[n] = 0;
      pfData->awRowsToPrint[n]      = 0;
      pfData->awRowsToDelayFree[n]  = 0;
      pfData->lFirstRowOfSection[FC_OUT][n]      = lCurrentRowPos;
      for (m=0;m<pfData->nMaxDelayBuf;m++)
      {
         pfData->alpbShingleToApply[n][m] = SHINGLE_THRU;
      }
   }

   for (n=pfData->nDelayBufStart; n<pfData->nDelayBufEnd; n++)
   {
      pfData->alDBIndx[FC_OUT][n] = -(pfData->alDBIndx[INIT_DELAY][n]);
      pfData->lFirstRowOfSection[FC_OUT_EVEN][n] = -9999L;
      pfData->lFirstRowOfSection[FC_OUT_ODD][n]  = -9999L;

      if (pfData->nVertResMult == HIRES_VERTICAL_MULTIPLIER)
      {
         nNozzleCount = pfData->wBaseNozzleCount + pfData->awExtraNozzles[n];
         if ((lpDataRec->bColorPlanes == 4) && (n==3))
         {
            nShingleSize = nNozzleCount / 3;
         }
         else if (lpDataRec->bShingle == NO_SHINGLE)
         {
            nShingleSize = nNozzleCount;
         }
         else
         {
            nShingleSize = nNozzleCount / 2;
         }
         pfData->alDBIndx[FC_OUT][n] = -( pfData->alDBIndx[INIT_DELAY][n] +
                                    (FC_INT)(nNozzleCount - nShingleSize));
         pfData->alDBIndx[FC_OUT_EVEN][n] = (pfData->alDBIndx[FC_OUT][n]*2 -
                                        (FC_INT)(nShingleSize + 3));
         pfData->alDBIndx[FC_OUT_ODD][n] = (FC_INT)(pfData->alDBIndx[FC_OUT][n]*2);
      }
   }


   if ( (lpDataRec->bColorPlanes == 4) &&
        (pfData->nVertResMult == HIRES_VERTICAL_MULTIPLIER) &&
        (lpDataRec->bShingle == SHINGLE_50) )
   {
      /* Note that FC_OUT_EVEN is adjusted by the Color Shingle Size and not Mono
      Shingle Size.  This is correct. */
      pfData->alDBIndx[FC_OUT_EVEN][3] = (FC_INT)((pfData->alDBIndx[FC_OUT][3]*2)-
                                     ((pfData->wBaseNozzleCount/2) + 3));
   }




   if (pfData->nVertResMult == HIRES_VERTICAL_MULTIPLIER)
   {
      if (lpDataRec->bShingle == NO_SHINGLE)
      {
         nShingleSize = (WORD)pfData->wBaseNozzleCount;
      }
      else
      {
         nShingleSize = (WORD)pfData->wBaseNozzleCount / 2;
      }
      pfData->lRowsToProcess = (FC_LONG)(nShingleSize - 3); /* HIRES */
      pfData->nOut = FC_OUT_EVEN;
   }

   pfData->anDelayKSwath[FC_OUT] = 0;
   pfData->anDelayKSwath[FC_OUT_EVEN] = 0;
   pfData->anDelayKSwath[FC_OUT_ODD] = 0;

   for (n=pfData->nDelayBufStart; n<pfData->nDelayBufEnd; n++)
   {
      pfData->alDBIndx[FC_OUT][n] = lCurrentRowPos;
   }

   return;

}  /* End of ResetBuffers() */




/***************************************************************************
 *  FC_INTFC.C                                          Lexmark Confidential
 *
 * Function Name:    FCOutputStrip
 *
 * Description:
 *    This is the interface function between the rest of the printer driver
 *    and the print formatter code.  It adds any necessary white space
 *    between the current raster line and the previous raster line.  It then
 *    adds the current raster line's margins into the margin arrays, and
 *    finally calls ProcessRaster() to add the current raster line to the
 *    delay buffers.
 *
 * Inputs:  lpDataRec      Long pointer to print device structure.
 *          lpRasterLine   Long pointer to the raster line to be processed.
 *          dwStripStrart  The absolute vertical position of this raster
 *                         line on the page.  Begins at 0.
 *          nScanStart     The horizontal starting position of valid data
 *                         within the raster line.  Begin at 0.
 *          nScanEnd       The horizontal ending position of the valid
 *                         data within the raster line. nScanEnd points
 *                         one byte beyond the last good data byte.
 *
 * Outputs: Always returns 0
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *    9/25/97     RFL            Added support for generation of print
 *                                formatter test files (GEN_TEST_INPUT_FILES).
 *
 *************************************************************************/
UINT FAR FCOutputStrip(LPDVDATAREC lpDataRec, LPBYTE lpRasterLine,
                       FC_LONG lStripStart, int nScanStart, int nScanEnd)
{
   struct pf_data FAR *pfData;
#ifndef GEN_TEST_INPUT_FILES   /* include test file generation */
   FC_INT   i;
   FC_LONG  n;
   FC_LONG  lRows;
   FC_LONG  lRowsMoved;
   FC_LONG  lStripNum;
   FC_LONG  lOutOfPhaseLines;
#endif

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   pfData->in_ptr = lpRasterLine;

#ifdef GEN_TEST_INPUT_FILES   /* include test file generation */
   GenTstFile( lpDataRec,
               (int)lStripStart,
               nScanStart,
               nScanEnd,
               lpRasterLine,
               pfData->nBytesPerRow);
   return(0);
#else

   if (pfData->bResolution == SUPERLOWRES)
   {
      lStripStart *= 2;
   }

   /* Align nScanStart to word boundary */
   if (nScanStart%2)
   {
      nScanStart--;
      for (i=0;i<lpDataRec->bColorPlanes;i++)
         /* make sure the extra byte added is blank */
         lpRasterLine[(i*pfData->nBytesPerRow)+nScanStart] = 0x00;
   }

   /* Align nScanEnd to word boundary */
   if (nScanEnd%2)
   {
      for (i=0;i<lpDataRec->bColorPlanes;i++)
         /* make sure the extra byte added is blank */
         lpRasterLine[(i*pfData->nBytesPerRow)+nScanEnd] = 0x00;
      nScanEnd++;
   }

   lRows = lStripStart - pfData->lRowPos;

   /************************************************************************
    * In the if() statement below, the +4 added to the skip amount
    * calculation was added to account for high resolution "in phase"
    * adjustments.  This means that for high resolution large vertical
    * movements (600dpi for the 4076 based printers, and 1200dpi for the
    * babbage based printers), the next raster line after the move must be
    * evenly divisible by 300.  The move is then "in phase".
    ************************************************************************/
   if ((lRows > 1) && (lRows <= ((FC_LONG)(pfData->nMaxDelayBuf+MONO_NOZZLE_COUNT+4))))
   {  /* small whitespace skip, so just feed blank raster lines */
      lStripNum = lStripStart - (lRows-1);
      for (n=0; n<(lRows-1); n++)
      {
         /* check for first raster */
         if (pfData->lRowPos == 0xFFFFFFFF)
            pfData->lRowPos = 0;
         else
            pfData->lRowPos++;

         ProcessRaster(lpDataRec, lStripNum, pfData->nBytesPerRow, 0);
         lStripNum++;
      }
   }
   else if (lRows > (FC_LONG)(pfData->nMaxDelayBuf+MONO_NOZZLE_COUNT+4))
   {
      /********************************************************************
       * large whitespace skip, so flush buffers and then move
       * lOutOfPhaseLines will be equal to 0, 1, 2, or 3.  And this is the
       * number of blank lines we need to send to ProcessRaster() before
       * sending the lStripStart raster line.  These blank raster lines
       * affect how much of a large skip vertical move we make, and this
       * is how we are guaranteeing our moves to be "in phase".
       *******************************************************************/
      lOutOfPhaseLines = VerticalMoveInPhase(lpDataRec, lStripStart);

      lRowsMoved = (FC_LONG)FlushBuffers(lpDataRec,MIDDLE_OF_PAGE);
      ResetBuffers((lStripStart - lOutOfPhaseLines), lpDataRec);
      pfData->nFutureFormsMovePending += 
                        (int)((lRows - lRowsMoved - lOutOfPhaseLines - 1));

      /* now send the necessary blank lines which ensured the large        */
      /* vertical movement was "in phase".                                 */
      lStripNum = lStripStart - lOutOfPhaseLines;
      pfData->lRowPos = lStripNum;
      for (n = 0; n < lOutOfPhaseLines; n++)
      {
         ProcessRaster(lpDataRec, lStripNum, pfData->nBytesPerRow, 0);
         lStripNum++;
         pfData->lRowPos++;
      }
   }

   /* now process the current raster line */
   pfData->lRowPos = lStripStart;
   ProcessRaster(lpDataRec, lStripStart, nScanStart, nScanEnd);

   if (pfData->bResolution == SUPERLOWRES)
   {
      lStripStart++;
      pfData->lRowPos = lStripStart;
      ProcessRaster(lpDataRec, lStripStart, nScanStart, nScanEnd);
   }
   return(0);
#endif

}  /* End of FCOutputStrip() */


/***************************************************************************
 *  FC_INTFC.C                                          Lexmark Confidential
 *
 * Function Name:    LoadShingleMask
 *
 * Description:
 *    Loads the correct shingle masks based on the number of color planes
 *    for this page, and the shingle mode requested.
 *
 * Inputs:  bNumPlanes     Number of color planes for this page.
 *          pfData         Long pointer to our internal data structure.
 *
 * Outputs: initializes the shingle mask pfData->alpwShingleMask[].
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void FAR LoadShingleMasks(LPDVDATAREC lpDataRec, BYTE bNumPlanes)
{
   int n, nNozCnt;
   BYTE bSI;
   WORD  wNC;
   struct pf_data FAR *pfData;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

   switch (bNumPlanes)
   {
      case 1 :
         if ((pfData->bResolution == HIRES) || (pfData->bResolution == MIDRES))
            pfData->nMonoNozzleCount  = COLOR_NOZZLE_COUNT;
         else
            pfData->nMonoNozzleCount  = MONO_NOZZLE_COUNT;
         nNozCnt = pfData->nMonoNozzleCount;

         break;

      case 4 :
         pfData->nMonoNozzleCount = COLOR_NOZZLE_COUNT;
         /* intentionally falling through to CMY case */

      case 3 :
      case 6 :
         pfData->nColorNozzleCount = COLOR_NOZZLE_COUNT/3;
   }



   pfData->alpwShingleMask[SHINGLE_MASK_50][0] = 0xAAAA;
   pfData->alpwShingleMask[SHINGLE_MASK_50][1] = 0x5555;

   pfData->alpwShingleMask[SHINGLE_MASK_25][0] = 0x8888;
   pfData->alpwShingleMask[SHINGLE_MASK_25][1] = 0x4444;
   pfData->alpwShingleMask[SHINGLE_MASK_25][2] = 0x2222;
   pfData->alpwShingleMask[SHINGLE_MASK_25][3] = 0x1111;

   pfData->alpwShingleMask[SHINGLE_MASK_33][0] = 0x9292;
   pfData->alpwShingleMask[SHINGLE_MASK_33][1] = 0x4949;
   pfData->alpwShingleMask[SHINGLE_MASK_33][2] = 0x2424;

   pfData->alpwShingleMask[SHINGLE_MASK_16][0] = 0x8282;
   pfData->alpwShingleMask[SHINGLE_MASK_16][1] = 0x4141;
   pfData->alpwShingleMask[SHINGLE_MASK_16][2] = 0x2020;
   pfData->alpwShingleMask[SHINGLE_MASK_16][3] = 0x1010;
   pfData->alpwShingleMask[SHINGLE_MASK_16][4] = 0x0808;
   pfData->alpwShingleMask[SHINGLE_MASK_16][5] = 0x0404;

   /* Each shingle pattern has a top range of the printhead portion it can */
   /* be printed with.  The top range will be from top nozzle down to a    */
   /* certain nozzle value.  Calculate and store these values.             */
   for (n=0;n<3;n++)
   {
      if (n==0)
      {
         bSI = COLOR;
         wNC = COLOR_NOZZLE_COUNT / 3;
      }
      else if (n==1)
      {
         bSI = MONO_FULL;
         wNC = MONO_NOZZLE_COUNT;
      }
      else
      {
         bSI = MONO_PART;
         wNC = COLOR_NOZZLE_COUNT;
      }

      pfData->awShingleThreshold[bSI][SHINGLE_0_1]  = 0;

#if OPTION_VARIABLE_MONO_NOZZLES
      /* The following if() statement allows us to use a variable number   */
      /* of bottom black nozzles when printing envelopes.  This allows     */
      /* more drying time for the black ink.                               */
      if ( ((bSI == MONO_FULL) || (bSI == MONO_PART)) &&
           ((GetMonoNozzlesToUse(lpDataRec)) != 0) )
      {
         pfData->awShingleThreshold[bSI][SHINGLE_0_1]  =
                           wNC - (GetMonoNozzlesToUse(lpDataRec));
      }
#endif

      pfData->awShingleThreshold[bSI][SHINGLE_50_1] = wNC/2;
      pfData->awShingleThreshold[bSI][SHINGLE_50_2] = 0;

      pfData->awShingleThreshold[bSI][SHINGLE_25_1] = wNC - wNC/4;
      pfData->awShingleThreshold[bSI][SHINGLE_25_2] = wNC - 2*wNC/4;
      pfData->awShingleThreshold[bSI][SHINGLE_25_3] = wNC - 3*wNC/4;
      pfData->awShingleThreshold[bSI][SHINGLE_25_4] = 0;

      if (bSI == COLOR)
      {
         pfData->awShingleThreshold[bSI][SHINGLE_33_1] = wNC - PCT33_COLOR_NOZZLES;
         pfData->awShingleThreshold[bSI][SHINGLE_33_2] = wNC - 2*(PCT33_COLOR_NOZZLES);
      }
      else if (bSI == MONO_FULL)
      {
         pfData->awShingleThreshold[bSI][SHINGLE_33_1] = wNC - PCT33_MONO_FULL_NOZZLES;
         pfData->awShingleThreshold[bSI][SHINGLE_33_2] = wNC - (2*PCT33_MONO_FULL_NOZZLES);
      }
      else
      {
         pfData->awShingleThreshold[bSI][SHINGLE_33_1] = wNC - wNC/3;
         pfData->awShingleThreshold[bSI][SHINGLE_33_2] = wNC - (2*(wNC/3));
      }

      pfData->awShingleThreshold[bSI][SHINGLE_33_3] = 0;

      pfData->awShingleThreshold[bSI][SHINGLE_16_1] = wNC - wNC/6;
      pfData->awShingleThreshold[bSI][SHINGLE_16_2] = wNC - 2*wNC/6;
      pfData->awShingleThreshold[bSI][SHINGLE_16_3] = wNC - 3*wNC/6;
      pfData->awShingleThreshold[bSI][SHINGLE_16_4] = wNC - 4*wNC/6;
      pfData->awShingleThreshold[bSI][SHINGLE_16_5] = wNC - 5*wNC/6;
      pfData->awShingleThreshold[bSI][SHINGLE_16_6] = 0;
   }

   return;
}   /* end of LoadShingleMask() */



/***************************************************************************
 *  FC_INTFC.C                                          Lexmark Confidential
 *
 * Function Name:    FCGetInkUsage
 *
 * Description:
 *    This is the interface function between the rest of the printer driver
 *    and the print formatter code.  It returns to the driver the dot count
 *    for all the inks.  The driver is responsible for accumulating and
 *    storing the dot counts.  The print formatter code dot counts are
 *    zeroed with each call.  This function must be called within calles to
 *    FCStartDoc/FCEndDoc because the dot count data structure is allocated
 *    in FCStartDoc.
 *
 * Inputs:  lpDataRec    Long pointer to print device structure.
 *          lpDotCounts  Data structure for returning the dot counts
 *                       for 6 inks.
 *
 * Outputs: lpDotCounts  Dot counts for all 6 inks.
 *
 * Original Author: K. Profitt
 * Date: 01/18/97
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void FAR FCGetInkUsage( LPDVDATAREC lpDataRec,  LPDOTCOUNTS lpDotCounts)
{
   int   n;
   struct  pf_data FAR *pfData;

   if   (lpDataRec)
   {   /* non NULL lpDataRec pointer */
       pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

       switch (lpDataRec->bColorPlanes)
       {
          case 1 :
                lpDotCounts->nInk1 = pfData->alDotCount[3];
                lpDotCounts->nInk2 = 0;
                lpDotCounts->nInk3 = 0;
                lpDotCounts->nInk4 = 0;
                lpDotCounts->nInk5 = 0;
                lpDotCounts->nInk6 = 0;
                break;

          case 3 :
                lpDotCounts->nInk1 = pfData->alDotCount[0];
                lpDotCounts->nInk2 = pfData->alDotCount[1];
                lpDotCounts->nInk3 = pfData->alDotCount[2];
                lpDotCounts->nInk4 = 0;
                lpDotCounts->nInk5 = 0;
                lpDotCounts->nInk6 = 0;
                break;

          case 4 :
                lpDotCounts->nInk1 = pfData->alDotCount[0];
                lpDotCounts->nInk2 = pfData->alDotCount[1];
                lpDotCounts->nInk3 = pfData->alDotCount[2];
                lpDotCounts->nInk4 = pfData->alDotCount[3];
                lpDotCounts->nInk5 = 0;
                lpDotCounts->nInk6 = 0;
                break;

          case 6 :
                lpDotCounts->nInk1 = pfData->alDotCount[0];
                lpDotCounts->nInk2 = pfData->alDotCount[1];
                lpDotCounts->nInk3 = pfData->alDotCount[2];
                lpDotCounts->nInk4 = pfData->alDotCount[3];
                lpDotCounts->nInk5 = pfData->alDotCount[4];
                lpDotCounts->nInk6 = pfData->alDotCount[5];
                break;
       }  /* end of switch (lpDataRec->bColorPlanes) */

       /* Now that ink usage has been reported, zero the counters. */
       for (n=0; n<6; n++)
          pfData->alDotCount[n] = 0;

   }   /* end of non NULL lpDataRec pointer */
   else
   {
        lpDotCounts->nInk1 = 0;
        lpDotCounts->nInk2 = 0;
        lpDotCounts->nInk3 = 0;
        lpDotCounts->nInk4 = 0;
        lpDotCounts->nInk5 = 0;
        lpDotCounts->nInk6 = 0;
   }

   return;

}   /* end of FCGetInkUsage() */
