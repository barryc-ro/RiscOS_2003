/* fcintfc.c */

#include "common.h"

/***************************************************************************
 *  shortFC.C                                          Lexmark Confidential
 *
 * Function Name:    FCStartDoc
 *
 * Description:
 *    This function is expected to be called at the beginning of every print
 *    job. It allocates all global memory required by all print formatter
 *    functions.
 *
 * Inputs:  lpDataRec          Far pointer to HBP interface structure.
 *
 * Outputs: fStoreAllocated   TRUE - storage allocation successful
 *                            FALSE - storage allocation failed
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
unsigned int FCStartDoc(LPDVDATAREC lpDataRec)
{
	struct pf_data *pfData;
	BOOL fStoreAllocated = TRUE;								/* storage allocate successful */
	short n, i, nMemAreaSize, nIStart;

#if defined(DOS_BUILD) || defined(FC_DOS_32) || defined(__riscos)
// HANDLE   hPrtCmd;
	//unsigned long    dwPrtCmdSize;
#endif

	/* Clean up any currently allocated space */
	FCEndDoc(lpDataRec);

// #pragma warning (disable: 4127)  /*warning: conditional expression is constant*/
	while (1)
// #pragma warning (default: 4127)  /*warning: conditional expression is constant*/
	{
		/* get pfData, the print formatter common data structure */
		lpDataRec->lpLXDevice = (unsigned long) MALLOC(COMMONBUFSIZE);
		if (lpDataRec->lpLXDevice)
		{
			pfData = (struct pf_data *) lpDataRec->lpLXDevice;
		}
		else
		{
			pfData = NULL;
			fStoreAllocated = FALSE;
			break;
		}

		/* Set up the resolution for this print job */
		switch ((GetResolution(lpDataRec)))
		{
		case SUPERLOWRES:
			/* Super Low resolution for printers that have 3 resolutions */
			pfData->bResolution = SUPERLOWRES;
			pfData->nVertResMult = SLRES_VERTICAL_MULTIPLIER;
			pfData->nRastResMult = SLRES_RASTER_MULTIPLIER;
			pfData->nSwathResMult = SLRES_SWATH_MULTIPLIER;
			pfData->nBytesPerRow = SLRES_BYTES_PER_ROW;
			pfData->nWordsPerRow = SLRES_BYTES_PER_ROW / 2;
			pfData->nRastersPerSeg = SLRES_RASTERS_PER_SEGMENT;
			break;
		case LORES:
			/* Low resolution */
			pfData->bResolution = LORES;
			pfData->nVertResMult = LORES_VERTICAL_MULTIPLIER;
			pfData->nRastResMult = LORES_RASTER_MULTIPLIER;
			pfData->nSwathResMult = LORES_SWATH_MULTIPLIER;
			pfData->nBytesPerRow = LORES_BYTES_PER_ROW;
			pfData->nWordsPerRow = LORES_BYTES_PER_ROW / 2;
			pfData->nRastersPerSeg = LORES_RASTERS_PER_SEGMENT;
			break;
		case HIRES:
			/* High resolution */
			pfData->bResolution = HIRES;						/* all buffers will be doubled */
			pfData->nVertResMult = HIRES_VERTICAL_MULTIPLIER;
			pfData->nRastResMult = HIRES_RASTER_MULTIPLIER;
			pfData->nSwathResMult = HIRES_SWATH_MULTIPLIER;
			pfData->nBytesPerRow = HIRES_BYTES_PER_ROW;
			pfData->nWordsPerRow = HIRES_BYTES_PER_ROW / 2;
			pfData->nRastersPerSeg = HIRES_RASTERS_PER_SEGMENT;
			break;
		}

		pfData->nMaxDelayBuf = MAXBUFNUM * pfData->nVertResMult;

		pfData->anDBIndx[BUFSIZE][0] = P1_BUFNUM * pfData->nVertResMult;
		pfData->anDBIndx[BUFSIZE][1] = P2_BUFNUM * pfData->nVertResMult;
		pfData->anDBIndx[BUFSIZE][2] = P3_BUFNUM * pfData->nVertResMult;
		pfData->anDBIndx[BUFSIZE][3] = P4_BUFNUM * pfData->nVertResMult;
		pfData->anDBIndx[BUFSIZE][4] = P5_BUFNUM * pfData->nVertResMult;
		pfData->anDBIndx[BUFSIZE][5] = P6_BUFNUM * pfData->nVertResMult;

		pfData->nSlicesPerRow = pfData->nBytesPerRow * 8;

		/* initial dot count to 0 for all color planes */
		for (n = 0; n < MAXNUMPLANES; n++)
			pfData->alDotCount[n] = 0;

		/* get delay buffers */
		for (n = 0; n < MAXNUMPLANES; n++)
		{
			/* the -1 in the statement (pfData->anDBIndx[BUFSIZE][n]-1) is so we don't
			 * allocate a zero length buffer segment when the number of rows to
			 * be stored in the delay buffer is evenly divisible by the number
			 * of rows per segment */
			for (i = 0; i <= ((pfData->anDBIndx[BUFSIZE][n] - 1) / pfData->nRastersPerSeg); i++)
			{
				if (i == ((pfData->anDBIndx[BUFSIZE][n] - 1) / pfData->nRastersPerSeg))
					pfData->alpwPlane[n + (i * MAXNUMPLANES)] = (unsigned short *)
							MALLOC((unsigned short) ((pfData->anDBIndx[BUFSIZE][n] %
											pfData->nRastersPerSeg) * pfData->nBytesPerRow));
				else
					pfData->alpwPlane[n + (i * MAXNUMPLANES)] = (unsigned short *)
							MALLOC((unsigned short) (pfData->nRastersPerSeg *
									pfData->nBytesPerRow));

				if (pfData->alpwPlane[n + (i * MAXNUMPLANES)] == NULL)
				{
					fStoreAllocated = FALSE;
					break;
				}
			}
			if (fStoreAllocated == FALSE)
				break;
		}														/* end of allocating delay buffers */
		if (fStoreAllocated == FALSE)
			break;

		/* get print swath buffer */
		if (pfData->nSlicesPerRow > SLICES_PER_SEG)
		{
			pfData->pPrtCmd = MALLOC(PRT_CMD_SIZE);
			if (LOWORD(pfData->pPrtCmd) == 0)
			{
				pfData->alpbSwath[0] = (unsigned char *) pfData->pPrtCmd + SWATH_HEADER_SIZE;
				nIStart = 1;
			}
			else
				nIStart = 0;
		}
		else
		{
			pfData->pPrtCmd = MALLOC(PRT_CMD_SIZE);
			pfData->alpbSwath[0] = (unsigned char *) pfData->pPrtCmd + SWATH_HEADER_SIZE;
			nIStart = 1;
		}
		if ((unsigned char *) pfData->pPrtCmd == NULL)
		{
			fStoreAllocated = FALSE;
			break;
		}

		/* the -1 in the statement (pfData->nSlicesPerSeg-1) is so we don't
		 * allocate a zero length buffer segment when the swath slices per
		 * row is evenly divisible by MAX_SLICES_PER_SEG.  */
		for (i = nIStart; i <= ((pfData->nSlicesPerRow - 1) / SLICES_PER_SEG); i++)
		{
			pfData->alpbSwath[i] = MALLOC((unsigned short) ((unsigned short) K_BYTES_PER_SLICE *
							(unsigned short) SLICES_PER_SEG));
			if (pfData->alpbSwath[i] == NULL)
			{
				fStoreAllocated = FALSE;
				break;
			}
		}
		if (fStoreAllocated == FALSE)
			break;
		/* end of get print swath buffer */

		if (OPTION_COMPRESSION == 1)
		{
			/* get compressed print swath buffer */
			if (pfData->nSlicesPerRow > SLICES_PER_SEG)
				pfData->pCompPrtCmd = MALLOC(PRT_CMD_SIZE);
			else
				pfData->pCompPrtCmd = MALLOC(PRT_CMD_SIZE);
			if ((unsigned char *) pfData->pCompPrtCmd == NULL)
			{
				fStoreAllocated = FALSE;
				break;
			}
			/* end of get compressed print swath buffer */
		}
		else
			pfData->pCompPrtCmd = 0;

		if (OPTION_CHECKDENSITY == 1)
		{
			/* get extra print swath buffer for swaths that are too dense */
			if (pfData->nSlicesPerRow > SLICES_PER_SEG)
				pfData->pDensePrtCmd = MALLOC(PRT_CMD_SIZE);
			else
				pfData->pDensePrtCmd = MALLOC(PRT_CMD_SIZE);

			if ((unsigned char *) pfData->pDensePrtCmd == NULL)
			{
				fStoreAllocated = FALSE;
				break;
			}
			PopulateBitCount(lpDataRec);
			/* end of get extra print swath buffer for swaths that are too dense */
		}
		else
			pfData->pDensePrtCmd = 0;

		/* Used for products that require a print swath to be built in reverse */
		pfData->lpwReverseRaster = (unsigned short *) MALLOC(pfData->nBytesPerRow);
		if (pfData->lpwReverseRaster == NULL)
		{
			fStoreAllocated = FALSE;
			break;
		}

		/* get hardware printer specific buffer */
		pfData->lpHwData = (struct tHwData *) MALLOC(HW_BUFF_SIZE);

		if (pfData->lpHwData == NULL)
		{
			fStoreAllocated = FALSE;
			break;
		}

		/* get storage for several smaller 'chunks' of memory */
		/* specifically:  Print Line Mask   16 words
		 * Raster Line Mask  16 words
		 * Shingle Mask      MONO_NOZZLE_COUNT*2 words
		 * Scan Start Array  Max Delay Buffer words
		 * Scan End Array    Max Delay Buffer words */
		nMemAreaSize = (16 + 16 + (MONO_NOZZLE_COUNT * 2) +
				(pfData->nMaxDelayBuf * 2)) * 2;
		pfData->lpbMemArea = (unsigned char *) MALLOC(nMemAreaSize);
		if (pfData->lpbMemArea == NULL)
		{
			fStoreAllocated = FALSE;
			break;
		}
		pfData->lpwPrtMask = (unsigned short *) pfData->lpbMemArea;
		pfData->lpwRastMask = (unsigned short *) (pfData->lpbMemArea + 32);
		pfData->awShingleMask = (unsigned short *) (pfData->lpbMemArea + 32 + 32);
		pfData->anScanStart = (short *) (pfData->lpbMemArea + 32 + 32 +
				(MONO_NOZZLE_COUNT * 2 * 2));
		pfData->anScanEnd = (short *) (pfData->lpbMemArea + 32 + 32 +
				(MONO_NOZZLE_COUNT * 2 * 2) +
				(pfData->nMaxDelayBuf * 2));

		break;
	}															/* end of: while (1) */

#if defined(FC_WIN_16) || defined(FC_WIN_32)
	HwStartPrintJob(lpDataRec);
#endif

	return (fStoreAllocated);
}																/* end of FCStartDoc() */

/***************************************************************************
 *  shortFC.C                                          Lexmark Confidential
 *
 * Function Name:    FCStartPage
 *
 * Description:
 *    This function is expected to be called at the beginning of every print
 *    page.  It initializes several variables in the print formatter
 *    structure (pfData), based on information in reads from the HBP interface
 *    structure (lpDataRec).
 *
 * Inputs:  lpDataRec    Long pointer to print device structure.
 *
 * Outputs: TRUE        Always returns successful.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
unsigned int FCStartPage(LPDVDATAREC lpDataRec)
{
	struct pf_data *pfData;
	int n, nHead1VertAlign = 0, nHead2VertAlign = 0;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;

	pfData->lRowPos = -1;										/* raster row number begins at 0 */
	/* but unsigned long is only postive */
	pfData->bPrintQuality = lpDataRec->bQuality;
	pfData->fSwathPresent = FALSE;
	pfData->bShingle = GetShingleMode(lpDataRec);
	/* order is important! Resolution must be set before margins are set */
	pfData->bResolution = GetResolution(lpDataRec);
	pfData->wLeftMargin = GetLeftMargin(lpDataRec);
	pfData->wTopMargin = GetTopMargin(lpDataRec);
	pfData->nFormsMovePending = pfData->wTopMargin;

	if ((pfData->bResolution == HIRES) && (pfData->bShingle == SHINGLE_25))
		/* 25% shingling at high resolution is not supported */
		pfData->bShingle = SHINGLE_50;

	pfData->fCDE = CheckForCDE(pfData->bResolution, lpDataRec->bQuality);
	if (pfData->bShingle != NO_SHINGLE)
		pfData->fCDE = FALSE;

	FCSetPaperSource(lpDataRec);

	for (n = 0; n < MAXNUMPLANES; n++)
		pfData->alDotCount[n] = 0;

	LoadShingleMask(lpDataRec->bColorPlanes, pfData);

	switch (lpDataRec->bColorPlanes)
	{															/* Set print mode, beginning and ending delay buffer, and initial
																 * delay for delay buffers */
	case 1:													/* black only */
		pfData->nDelayBufStart = 3;
		pfData->nDelayBufEnd = 4;
		pfData->anDBIndx[INIT_DELAY][3] = KONLY_P4_DELAY;
		pfData->bPrintHead = MONO_CARTRIDGE;
		break;
	case 3:													/* CMY */
		pfData->nDelayBufStart = 0;
		pfData->nDelayBufEnd = 3;
		pfData->anDBIndx[INIT_DELAY][0] = CMY_P1_DELAY;
		pfData->anDBIndx[INIT_DELAY][1] = CMY_P2_DELAY;
		pfData->anDBIndx[INIT_DELAY][2] = CMY_P3_DELAY;
		pfData->bPrintHead = COL_CARTRIDGE;
		break;
	case 4:													/* CMYK */
		pfData->nDelayBufStart = 0;
		pfData->nDelayBufEnd = 4;
		pfData->anDBIndx[INIT_DELAY][0] = CMYK_P1_DELAY;
		pfData->anDBIndx[INIT_DELAY][1] = CMYK_P2_DELAY;
		pfData->anDBIndx[INIT_DELAY][2] = CMYK_P3_DELAY;
		pfData->anDBIndx[INIT_DELAY][3] = CMYK_P4_DELAY;
		break;
	case 6:													/* CMYKCM */
		pfData->nDelayBufStart = 0;
		pfData->nDelayBufEnd = 6;

		pfData->nVertAlign = lpDataRec->bVerticalAdj;
		if ((pfData->nVertAlign < VERTHEAD_MINALIGN) ||
				(pfData->nVertAlign > VERTHEAD_MAXALIGN))
			pfData->nVertAlign = VERTHEAD_MIDALIGN;

		if (pfData->nVertAlign < VERTHEAD_MIDALIGN)
			nHead2VertAlign = (VERTHEAD_MIDALIGN - pfData->nVertAlign);
		else if (pfData->nVertAlign > VERTHEAD_MIDALIGN)
			nHead1VertAlign = (pfData->nVertAlign - VERTHEAD_MIDALIGN);

		pfData->anDBIndx[INIT_DELAY][0] = CMYKCM_P1_DELAY +
				nHead1VertAlign;
		pfData->anDBIndx[INIT_DELAY][1] = CMYKCM_P2_DELAY +
				nHead1VertAlign;
		pfData->anDBIndx[INIT_DELAY][2] = CMYKCM_P3_DELAY +
				nHead1VertAlign;
		pfData->anDBIndx[INIT_DELAY][3] = CMYKCM_P4_DELAY +
				nHead2VertAlign;
		pfData->anDBIndx[INIT_DELAY][4] = CMYKCM_P5_DELAY +
				nHead2VertAlign;
		pfData->anDBIndx[INIT_DELAY][5] = CMYKCM_P6_DELAY +
				nHead2VertAlign;
		break;
	default:
		break;
	}															/* End of: Set print mode, beginning and ending delay buffer, and
																 * initial delay for delay buffers */

	ResetBuffers(lpDataRec);

	pfData->lpwPrtMask[0] = PRINT_MASK0;
	pfData->lpwPrtMask[1] = PRINT_MASK1;
	pfData->lpwPrtMask[2] = PRINT_MASK2;
	pfData->lpwPrtMask[3] = PRINT_MASK3;
	pfData->lpwPrtMask[4] = PRINT_MASK4;
	pfData->lpwPrtMask[5] = PRINT_MASK5;
	pfData->lpwPrtMask[6] = PRINT_MASK6;
	pfData->lpwPrtMask[7] = PRINT_MASK7;
	pfData->lpwPrtMask[8] = PRINT_MASK8;
	pfData->lpwPrtMask[9] = PRINT_MASK9;
	pfData->lpwPrtMask[10] = PRINT_MASK10;
	pfData->lpwPrtMask[11] = PRINT_MASK11;
	pfData->lpwPrtMask[12] = PRINT_MASK12;
	pfData->lpwPrtMask[13] = PRINT_MASK13;
	pfData->lpwPrtMask[14] = PRINT_MASK14;
	pfData->lpwPrtMask[15] = PRINT_MASK15;

	pfData->lpwRastMask[0] = RASTER_MASK0;
	pfData->lpwRastMask[1] = RASTER_MASK1;
	pfData->lpwRastMask[2] = RASTER_MASK2;
	pfData->lpwRastMask[3] = RASTER_MASK3;
	pfData->lpwRastMask[4] = RASTER_MASK4;
	pfData->lpwRastMask[5] = RASTER_MASK5;
	pfData->lpwRastMask[6] = RASTER_MASK6;
	pfData->lpwRastMask[7] = RASTER_MASK7;
	pfData->lpwRastMask[8] = RASTER_MASK8;
	pfData->lpwRastMask[9] = RASTER_MASK9;
	pfData->lpwRastMask[10] = RASTER_MASK10;
	pfData->lpwRastMask[11] = RASTER_MASK11;
	pfData->lpwRastMask[12] = RASTER_MASK12;
	pfData->lpwRastMask[13] = RASTER_MASK13;
	pfData->lpwRastMask[14] = RASTER_MASK14;
	pfData->lpwRastMask[15] = RASTER_MASK15;

	HwStartPage(lpDataRec);

#ifdef MARCONI
	if ((lpDataRec->bMediaSize == PAPER_BANNER_LETTER) ||
			(lpDataRec->bMediaSize == PAPER_BANNER_A4))
		FCSetBannerMode(lpDataRec, BANNER_ENABLE);
#endif

	return (TRUE);
}																/* end of FCStartPage() */

/***************************************************************************
 *  shortFC.C                                          Lexmark Confidential
 *
 * Function Name:    FCEndPage
 *
 * Description:
 *    This function ***MUST*** be called at the end of every print page.  It
 *    calls function FlushBuffers(), which formats and prints all raster
 *    lines that are in the delay buffers.
 *
 * Inputs:  lpDataRec    Long pointer to print device structure.
 *
 * Outputs: <none>
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void FCEndPage(LPDVDATAREC lpDataRec)
{
	FlushBuffers(lpDataRec);

#ifdef MARCONI
	if ((lpDataRec->bMediaSize == PAPER_BANNER_LETTER) ||
			(lpDataRec->bMediaSize == PAPER_BANNER_A4))
		FCSetBannerMode(lpDataRec, BANNER_DISABLE);
#endif

	HwEndPage(lpDataRec);

}																/* End of FCEndPage() */

/***************************************************************************
 * shortFC.C                                        Lexmark Confidential
 *
 * Function Name:    FCEndDoc
 *
 * Description:
 *    This function ***MUST*** be called at the end of every print job.  It
 *    frees all memory that was allocated in FCStartDoc().
 *
 * Inputs:  lpDataRec    Long pointer to print device structure.
 *
 * Outputs: <none>
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void FCEndDoc(LPDVDATAREC lpDataRec)
{
	struct pf_data *pfData;
	int n, i;

	if (lpDataRec)
		pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	else
		pfData = NULL;

	if (pfData)
	{															/* storage is allocated, so free it */
		for (n = 0; n < MAXNUMPLANES; n++)
			for (i = 0; i <= ((pfData->anDBIndx[BUFSIZE][n] - 1) / pfData->nRastersPerSeg); i++)
				if (pfData->alpwPlane[n + (i * MAXNUMPLANES)])
					FREE(pfData->alpwPlane[n + (i * MAXNUMPLANES)]);

		if (pfData->lpbMemArea)
			FREE(pfData->lpbMemArea);

		if ((unsigned char *) pfData->pPrtCmd)
		{
			if (pfData->nSlicesPerRow > SLICES_PER_SEG)
			{
				// AA: The next line seemed to be a typo. It ended in a semicolon

				if (pfData->alpbSwath[0] == (unsigned char *) pfData->pPrtCmd + SWATH_HEADER_SIZE)
					pfData->alpbSwath[0] = NULL;
				FREE((struct tPrintCmd *) pfData->pPrtCmd);
			}
			else
			{
				FREE((struct tPrintCmd *) pfData->pPrtCmd);
				pfData->alpbSwath[0] = NULL;
			}
		}

		if ((unsigned char *) pfData->pCompPrtCmd)
		{
			if (pfData->nSlicesPerRow > SLICES_PER_SEG)
				FREE((struct tPrintCmd *) pfData->pCompPrtCmd);
			else
				FREE((struct tPrintCmd *) pfData->pCompPrtCmd);
		}

		if ((unsigned char *) pfData->pDensePrtCmd)
		{
			if (pfData->nSlicesPerRow > SLICES_PER_SEG)
				FREE((struct tPrintCmd *) pfData->pDensePrtCmd);
			else
				FREE((struct tPrintCmd *) pfData->pDensePrtCmd);
		}

		for (i = 0; i <= ((pfData->nSlicesPerRow - 1) / SLICES_PER_SEG); i++)
			if (pfData->alpbSwath[i])
				FREE(pfData->alpbSwath[i]);

		if (pfData->lpHwData)
			FREE(pfData->lpHwData);

		if (pfData->lpwReverseRaster)
			FREE(pfData->lpwReverseRaster);

		FREE(pfData);
		lpDataRec->lpLXDevice = NULL;

		HwEndJob(lpDataRec);

	}															/* end of freeing storage allocation */

}																/* End of FCEndDoc() */

/***************************************************************************
 *  shortFC.C                                          Lexmark Confidential
 *
 * Function Name:    ResetBuffers
 *
 * Description:
 *    This function initializes the IN and OUT indexes that point into the
 *    delay buffers.  It should be called every time the delay buffers have
 *    been emptied and need to be reinitialized.
 *
 * Inputs:  lpDataRec    Long pointer to HBP interface structure.
 *
 * Outputs: Initializes the IN and OUT indexes which point into the color
 *          plane delay buffers.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void ResetBuffers(LPDVDATAREC lpDataRec)
{
	struct pf_data *pfData;
	int n, nShingleSize, nNozzleCount;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;

	pfData->lRasterLinesProcessed = 0;

	for (n = pfData->nDelayBufStart; n < pfData->nDelayBufEnd; n++)
		pfData->anDBIndx[FC_IN][n] = 0;

	switch (lpDataRec->bColorPlanes)
	{
	case 1:
		nShingleSize = pfData->nMonoShingleSize;
		nNozzleCount = pfData->nMonoNozzleCount;
		break;
	default:
		nShingleSize = pfData->nColorShingleSize;
		nNozzleCount = pfData->nColorNozzleCount;
	}

	for (n = pfData->nDelayBufStart; n < pfData->nDelayBufEnd; n++)
	{
		pfData->anDBIndx[FC_OUT][n] = -(pfData->anDBIndx[INIT_DELAY][n] +
				(nNozzleCount - nShingleSize));
		pfData->anDBIndx[FC_OUT_EVEN][n] = (pfData->anDBIndx[FC_OUT][n] * 2) -
				(nShingleSize + 3);
		pfData->anDBIndx[FC_OUT_ODD][n] = pfData->anDBIndx[FC_OUT][n] * 2;
	}

	if (lpDataRec->bColorPlanes == 4)
	{
		pfData->anDBIndx[FC_OUT][3] = -(pfData->anDBIndx[INIT_DELAY][3] +
				(pfData->nMonoNozzleCount - pfData->nMonoShingleSize));
		/* Note that FC_OUT_EVEN is adjusted by the Color Shingle Size and not Mono
		 * Shingle Size.  This is correct. */
		pfData->anDBIndx[FC_OUT_EVEN][3] = (pfData->anDBIndx[FC_OUT][3] * 2) -
				(pfData->nColorShingleSize + 3);
		pfData->anDBIndx[FC_OUT_ODD][3] = pfData->anDBIndx[FC_OUT][3] * 2;
	}

	if (pfData->nVertResMult == LORES_VERTICAL_MULTIPLIER)
	{
		pfData->lRowsToProcess = (long) nShingleSize;			/* LORES */
		pfData->nOut = FC_OUT;
	}
	else
	{
		pfData->lRowsToProcess = (long) (nShingleSize - 3);		/* HIRES */
		pfData->nOut = FC_OUT_EVEN;
	}

	pfData->anK6SwathDelay[FC_OUT] = 0;
	pfData->anK6SwathDelay[FC_OUT_EVEN] = 0;
	pfData->anK6SwathDelay[FC_OUT_ODD] = 0;

	pfData->bBIDIPrintDirection = LTOR;
}																/* End of ResetBuffers() */

/***************************************************************************
 *  shortFC.C                                          Lexmark Confidential
 *
 * Function Name:    FCOutputStrip
 *
 * Description:
 *    This is the interface function between the rest of the printer driver
 *    and the print formatter code.  It adds any necessary white space
 *    between the current raster line and the previous raster line.  It then
 *    adds the current raster line's margins into the margin arrays, and
 *    finally calls ProcessRaster() to add the current raster line to the
 *    delay buffers.
 *
 * Inputs:  lpDataRec      Long pointer to print device structure.
 *          lpRasterLine   Long pointer to the raster line to be processed.
 *          dwStripStrart  The absolute vertical position of this raster 
 *                         line on the page.  Begins at 0.
 *          nScanStart     The horizontal starting position of valid data
 *                         within the raster line.  Begin at 0.
 *          nScanEnd       The horizontal ending position of the valid
 *                         data within the raster line. nScanEnd points
 *                         one byte beyond the last good data byte.
 *
 * Outputs: Always returns 0
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
unsigned int FCOutputStrip(LPDVDATAREC lpDataRec, unsigned char *lpRasterLine,
		long lStripStart, int nScanStart, int nScanEnd)
{
	long n, lRows, lRowsMoved;
	struct pf_data *pfData;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	pfData->in_ptr = lpRasterLine;

	if (nScanEnd > pfData->nBytesPerRow)
	{
		kelvin_trace6("FCOutputStrip(%p, %p, %ld, %d, %d) -- nScan adjusted to %d\n",
				lpDataRec, lpRasterLine, lStripStart, nScanStart, nScanEnd,
				pfData->nBytesPerRow);
		nScanEnd = pfData->nBytesPerRow;
	}

	if (nScanStart > nScanEnd)
		nScanStart = nScanEnd;

	if (pfData->bResolution == SUPERLOWRES)
	{
		lStripStart *= 2;
	}

	/* Align nScanStart to word boundary */
	if (nScanStart % 2)
		nScanStart--;

	lRows = lStripStart - pfData->lRowPos;

	if ((lRows > 1) && (lRows <= ((long) (pfData->nMaxDelayBuf + MONO_NOZZLE_COUNT))))
	{
		/* small whitespace skip, so just feed blank raster lines */
		for (n = 0; n < lRows - 1; n++)
		{

			/* check for first raster */
			if (pfData->lRowPos == 0xFFFFFFFF)
				pfData->lRowPos = 0;
			else
				pfData->lRowPos++;

			pfData->anScanStart[(short) (pfData->lRowPos % (long) pfData->nMaxDelayBuf)] = (short) pfData->nBytesPerRow;
			pfData->anScanEnd[(short) (pfData->lRowPos % (long) pfData->nMaxDelayBuf)] = 0;
			ProcessRaster(lpDataRec, pfData->nBytesPerRow, 0);
		}
	}
	else if (lRows > (long) (pfData->nMaxDelayBuf + MONO_NOZZLE_COUNT))
	{
		/* large whitespace skip, so flush buffers and then move */
		lRowsMoved = (long) FlushBuffers(lpDataRec);
		ResetBuffers(lpDataRec);
		pfData->nFormsMovePending += (int) ((lRows - lRowsMoved - 1));
	}

	/* now process the current raster line */
	pfData->lRowPos = lStripStart;
	pfData->anScanStart[(short) (lStripStart % (long) pfData->nMaxDelayBuf)] = (short) nScanStart;
	pfData->anScanEnd[(short) (lStripStart % (long) pfData->nMaxDelayBuf)] = (short) nScanEnd;
	ProcessRaster(lpDataRec, nScanStart, nScanEnd);

	if (pfData->bResolution == SUPERLOWRES)						/* double up */
	{
		lStripStart++;
		pfData->lRowPos = lStripStart;
		pfData->anScanStart[(short) (lStripStart % (long) pfData->nMaxDelayBuf)] = (short) nScanStart;
		pfData->anScanEnd[(short) (lStripStart % (long) pfData->nMaxDelayBuf)] = (short) nScanEnd;
		ProcessRaster(lpDataRec, nScanStart, nScanEnd);
	}

	return 0;
}																/* End of FCOutputStrip() */

/***************************************************************************
 *  shortFC.C                                          Lexmark Confidential
 *
 * Function Name:    LoadShingleMask
 *
 * Description:
 *    Loads the correct shingle masks based on the number of color planes
 *    for this page, and the shingle mode requested.
 *
 * Inputs:  bNumPlanes     Number of color planes for this page.
 *          pfData         Long pointer to our internal data structure.
 *
 * Outputs: initializes the shingle mask pfData->awShingleMask[].
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void LoadShingleMask(unsigned char bNumPlanes, struct pf_data *pfData)
{
	int n, nNozCnt;
	unsigned char bShingle;
	unsigned char *lpbShingle;

	bShingle = pfData->bShingle;

	switch (bNumPlanes)
	{
	case 1:
		if (pfData->bResolution == HIRES)
			pfData->nMonoNozzleCount = COLOR_NOZZLE_COUNT;
		else
			pfData->nMonoNozzleCount = MONO_NOZZLE_COUNT;
		nNozCnt = pfData->nMonoNozzleCount;

		if (bShingle == SHINGLE_50)
		{
			for (n = 0; n < nNozCnt; n++)
				pfData->awShingleMask[(K_SHINGLE_INDEX * MONO_NOZZLE_COUNT) + n] =
						(unsigned short) (0xAAAA >> ((n + (n / (nNozCnt / 2))) % 2));
			pfData->nMonoShingleSize = nNozCnt / 2;
		}
		else if (bShingle == SHINGLE_25)
		{
			for (n = 0; n < nNozCnt; n++)
				pfData->awShingleMask[(K_SHINGLE_INDEX * MONO_NOZZLE_COUNT) + n] =
						(unsigned short) (0x8888 >> ((n - (n / (nNozCnt / 4))) % 4));
			if (nNozCnt == 56)
			{
				/* 56 Nozzle 25% shingling is a special case that uses a
				 * different shingle mask. */
				for (n = 0; n < nNozCnt; n++)
					pfData->awShingleMask[(K_SHINGLE_INDEX * MONO_NOZZLE_COUNT) + n] =
							(unsigned short) (0x8888 >> ((n + (n / (nNozCnt / 4))) % 4));
			}
			pfData->nMonoShingleSize = nNozCnt / 4;
		}
		else
			pfData->nMonoShingleSize = pfData->nMonoNozzleCount;
		break;
	case 4:
		pfData->nMonoNozzleCount = COLOR_NOZZLE_COUNT;
		nNozCnt = pfData->nMonoNozzleCount;
		if (bShingle == SHINGLE_25)
		{
			/* 16% shingling */
			for (n = 0; n < nNozCnt; n++)
			{
				lpbShingle = (unsigned char *) &(pfData->awShingleMask[
								(K_SHINGLE_INDEX * MONO_NOZZLE_COUNT) + n]);
				*lpbShingle = (unsigned char) (0x82 >> ((n + ((n / (nNozCnt / 6)) * 3)) % 6));
				lpbShingle++;
				*lpbShingle = (unsigned char) (0x82 >> ((n + ((n / (nNozCnt / 6)) * 3)) % 6));
			}
			pfData->nMonoShingleSize = nNozCnt / 6;
		}
		else
		{
			/* The K swath in CMYK printing uses 33% shingling for both */
			/* 0% and 50% shingling                                     */
			for (n = 0; n < nNozCnt; n++)
			{
				lpbShingle = (unsigned char *) &(pfData->awShingleMask[
								(K_SHINGLE_INDEX * MONO_NOZZLE_COUNT) + n]);
				*lpbShingle = (unsigned char) (0x92 >> ((n + (n / (nNozCnt / 3))) % 3));
				lpbShingle++;
				*lpbShingle = (unsigned char) (0x92 >> ((n + (n / (nNozCnt / 3))) % 3));
			}
			pfData->nMonoShingleSize = nNozCnt / 3;
#if defined(EINSTEIN) || defined(MARCONI)
			/* Einstein and Marconi don't shingle 300dpi Mono in CMYK */
			if (pfData->bResolution == SUPERLOWRES)
			{
				pfData->nMonoShingleSize = nNozCnt;
			}
#endif
		}
		/* intentionally falling through to CMY case */
	case 3:
	case 6:
		pfData->nColorNozzleCount = COLOR_NOZZLE_COUNT / 3;
		nNozCnt = pfData->nColorNozzleCount;
		if (bShingle == SHINGLE_50)
		{
			for (n = 0; n < nNozCnt; n++)
				pfData->awShingleMask[(CMY_SHINGLE_INDEX * MONO_NOZZLE_COUNT) + n] =
						(unsigned short) (0xAAAA >> ((n + (n / (nNozCnt / 2))) % 2));
			pfData->nColorShingleSize = nNozCnt / 2;
		}
		else if (bShingle == SHINGLE_25)
		{
			for (n = 0; n < nNozCnt; n++)
				pfData->awShingleMask[(CMY_SHINGLE_INDEX * MONO_NOZZLE_COUNT) + n] =
						(unsigned short) (0x8888 >> ((n - (n / (nNozCnt / 4))) % 4));
			pfData->nColorShingleSize = nNozCnt / 4;
		}
		else
			pfData->nColorShingleSize = nNozCnt;
		break;
	}
}

/***************************************************************************
 *  shortFC.C                                          Lexmark Confidential
 *
 * Function Name:    FCGetInkUsage
 *
 * Description:
 *    This is the interface function between the rest of the printer driver
 *    and the print formatter code.  It returns to the driver the dot count
 *    for all the inks.  The driver is responsible for accumulating and
 *    storing the dot counts.  The print formatter code dot counts are
 *    zeroed with each call.  This function must be called within calles to
 *    FCStartDoc/FCEndDoc because the dot count data structure is allocated
 *    in FCStartDoc.
 *
 * Inputs:  lpDataRec    Long pointer to print device structure.
 *          lpDotCounts  Data structure for returning the dot counts
 *                       for 6 inks.
 *
 * Outputs: lpDotCounts  Dot counts for all 6 inks.
 *
 * Original Author: K. Profitt
 * Date: 01/18/97
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void FCGetInkUsage(LPDVDATAREC lpDataRec, LPDOTCOUNTS lpDotCounts)
{
	int n;
	struct pf_data *pfData;

	if (lpDataRec == NULL)
	{
		lpDotCounts->nInk1 = 0;
		lpDotCounts->nInk2 = 0;
		lpDotCounts->nInk3 = 0;
		lpDotCounts->nInk4 = 0;
		lpDotCounts->nInk5 = 0;
		lpDotCounts->nInk6 = 0;
		return;
	}

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;

	switch (lpDataRec->bColorPlanes)
	{
	case 1:
		lpDotCounts->nInk1 = pfData->alDotCount[3];
		lpDotCounts->nInk2 = 0;
		lpDotCounts->nInk3 = 0;
		lpDotCounts->nInk4 = 0;
		lpDotCounts->nInk5 = 0;
		lpDotCounts->nInk6 = 0;
		break;
	case 3:
		lpDotCounts->nInk1 = pfData->alDotCount[0];
		lpDotCounts->nInk2 = pfData->alDotCount[1];
		lpDotCounts->nInk3 = pfData->alDotCount[2];
		lpDotCounts->nInk4 = 0;
		lpDotCounts->nInk5 = 0;
		lpDotCounts->nInk6 = 0;
		break;
	case 4:
		lpDotCounts->nInk1 = pfData->alDotCount[0];
		lpDotCounts->nInk2 = pfData->alDotCount[1];
		lpDotCounts->nInk3 = pfData->alDotCount[2];
		lpDotCounts->nInk4 = pfData->alDotCount[3];
		lpDotCounts->nInk5 = 0;
		lpDotCounts->nInk6 = 0;
		break;
	case 6:
		lpDotCounts->nInk1 = pfData->alDotCount[0];
		lpDotCounts->nInk2 = pfData->alDotCount[1];
		lpDotCounts->nInk3 = pfData->alDotCount[2];
		lpDotCounts->nInk4 = pfData->alDotCount[3];
		lpDotCounts->nInk5 = pfData->alDotCount[4];
		lpDotCounts->nInk6 = pfData->alDotCount[5];
		break;
	}

	/* Now that ink usage has been reported, zero the counters. */
	for (n = 0; n < 6; n++)
		pfData->alDotCount[n] = 0;

}
