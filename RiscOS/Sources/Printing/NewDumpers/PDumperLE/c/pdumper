/* pdumper.c
 *
 * Changes
 *
 *	8.8.97		AA	Added support for new PDumper reason code 8
 *
 */

#include "common.h"
#include "pdumper.h"
#include "pdsupport.h"
#include "lexsupport.h"
#include "kelvswis.h"
#include "rawsprite.h"

#define NAMELEN			32

static BOOL				registered = FALSE;
static char				palfile[256];
static char				curname[NAMELEN];
static kelvin_pdconfig	conf;
static unsigned int		confWord;

enum
{
	kelvin__rootBlock		= BlockType_ThirdParty,
	kelvin__lineBuffer,
	kelvin__blockMAX
};

/* Our private data structure for an active job */

typedef struct
{
	LPDVDATAREC		lpDataRec;
	unsigned int	leftMargin;			/* in pixels					*/
	unsigned int	topMargin;			/* in rows						*/
	unsigned int	curRow;				/* current row					*/
	unsigned int	bytesPerLine;		/* in buffer					*/
	unsigned int	bytesPerColour;		/* == resolution				*/

	BOOL			startPending;		/* need to call Lexmark_StartJob */
	BOOL			needEndPage;		/* need to do an end of page sequence */

	unsigned char	*rowBuf;			/* claimed when we need it		*/
	size_t			rowBufSize;

} kelvin__job;

static _kernel_oserror *kelvin__ensurebuffer(void **anchor, kelvin__job *job, size_t size)
{
	if (job->rowBufSize < size)
	{
		unsigned char *newBuf;
		_kernel_oserror *err;

		if (err = pdumper_claim(anchor, size, kelvin__lineBuffer, (void **) &newBuf), err)
			return err;

		memset(newBuf + job->rowBufSize, 0, size - job->rowBufSize);

		if (job->rowBuf)
		{
        	memcpy(newBuf, job->rowBuf, job->rowBufSize);
        	if (err = pdumper_free(anchor, job->rowBuf), err)
        		return err;
		}

		job->rowBuf		= newBuf;
		job->rowBufSize	= size;
	}

	return NULL;
}

const char *kelvin_name(void)
{
	_kernel_swi_regs r;
	_kernel_oserror *err;

	if (err = _kernel_swi(PDriver_Info, &r, &r), err)
		return NULL;

	return (const char *) r.r[4];
}

/* Return TRUE if this PDumper is currently active. Note, this is determined only by comparing
 * the current name with the name at the time of the last setdriver(), so it could be wrong if
 * there are two printers with the same name. Only used by the experimental text mode support,
 * so don't worry too much about it!
 */

BOOL kelvin_active(void)
{
	char nbuf[NAMELEN];
	const char *name;
	memset(nbuf, 0, sizeof(nbuf));
	if (name = kelvin_name(), name) strncpy(nbuf, name, sizeof(nbuf)-1);
	return strcmp(nbuf, curname) == 0;
}

static void kelvin__setdriver(const char *palf, const kelvin_pdconfig *c, unsigned int cw)
{
	char *cr;
	const char *name;
	memcpy(palfile, palf, sizeof(palfile));
	if (cr = strchr(palfile, 0x0d), cr) *cr = '\0';

	memset(curname, 0, sizeof(curname));
	if (name = kelvin_name(), name) strncpy(curname, name, sizeof(curname)-1);
	kelvin_trace1("Hi, I'm %s\n", name);

	conf		= *c;
	confWord	= cw;

	/* Now find out what we're called so we can work out whether we're active later on */

	if (0)
	{
		_kernel_swi_regs r;
		r.r[0] = 10;
		r.r[1] = (int) "ADFS::Aden.$.Works.Lexmark.Kelvin.Config";
		r.r[2] = 0xFFD;
		r.r[4] = (int) &conf;
		r.r[5] = r.r[4] + sizeof(conf);
		(void) _kernel_swi(OS_File, &r, &r);
	}
}

static const char *kelvin__getconfstring(int offset)
{
	static char buf[32];
	const char *base;
	size_t len;

//	kelvin_trace1("kelvin__getconfstring(%d)\n", offset);

	base = ((char *) &conf) + offset + 12;
	len = *base++;
	if (len > 31) len = 31;

	memcpy(buf, base, len);
	buf[len] = '\0';

	return buf;
}

void kelvin_setjobparameters(BOOL colour, LPDVDATAREC lpDataRec, unsigned int *bpl, unsigned int *bpc)
{
	const char *mode;
	static int shingle[6][3] =
	{
		/*  draft,      normal,     high quality */
		{	NO_SHINGLE,	NO_SHINGLE,	NO_SHINGLE	},	/* plain paper		*/
		{	NO_SHINGLE,	SHINGLE_50,	NO_SHINGLE	},	/* coated paper		*/
		{	NO_SHINGLE,	SHINGLE_25,	SHINGLE_50	},	/* glossy paper		*/
		{	NO_SHINGLE,	SHINGLE_25,	SHINGLE_50	},	/* transparency		*/
		{	NO_SHINGLE,	SHINGLE_50,	NO_SHINGLE	},	/* iron on			*/
		{	NO_SHINGLE,	SHINGLE_50,	NO_SHINGLE	},	/* greeting card	*/
	};

	lpDataRec->lpLXDevice			= NULL;							/* pointer to hbp internal structure */
	lpDataRec->lpLXGenericPtr		= NULL;							/* pointer to driver specific print device */
	lpDataRec->nRightBidiAlignColor	= COLOR_RIGHT_BIDI_ALIGN;
	lpDataRec->nLeftBidiAlignColor	= COLOR_LEFT_BIDI_ALIGN;
	lpDataRec->nRightBidiAlignMono	= MONO_RIGHT_BIDI_ALIGN;
	lpDataRec->nLeftBidiAlignMono	= MONO_LEFT_BIDI_ALIGN;

	lpDataRec->bCompress			= 1;							/* Compression? 0= no compress, 1= compress */
	lpDataRec->bInkSave				= 0;							/* are we in ink saver mode? */
	lpDataRec->bLeftCartridgeID		= MONO_CARTRIDGE;				/* id of installed left cartridge */
	lpDataRec->bRightCartridgeID	= COL_CARTRIDGE;				/* id of installed right cartridge */
	lpDataRec->bHorizontalAdj		= 9;							/* horizontal adjustment between cartridges */
	lpDataRec->bVerticalAdj			= 4;							/* vertical adjustment between cartridges */
	lpDataRec->bBidiAlignLo			= 0;							/* Bidrectional printing alignment */
	lpDataRec->bBidiAlignHi			= 0;							/* Bidrectional printing alignment */
	lpDataRec->bColorPlanes			= 1;					        /* Number of color planes, i.e. 1,3,4,6 */
	lpDataRec->bDocumentType		= 0;							/* What? */
	lpDataRec->bQuality				= QUALITY_NORMAL;				/* Draft or Letter Quality, HIGH = 600 DPI */
	lpDataRec->bMediaType			= PLAIN_PAPER;					/* example PLAIN, GLOSSY, TRANSPARENCY, etc. */
	lpDataRec->bMediaSize			= PAPER_A4;						/* predefined paper size, ie Letter, A4, etc. */
	lpDataRec->bMediaSource			= AUTO_FEED;					/* Manual or Auto feed */
	lpDataRec->wTopMargin			= 75;							/* page top margin */
	lpDataRec->flOutFile			= 0;							/* riscos file handle */

	*bpl							= 300;

	mode = kelvin__getconfstring(conf.strPageStart);
	if (strcmp(mode, "6") == 0)
	{
		lpDataRec->bQuality			= QUALITY_HIGH;
		*bpl						= 600;
	}

	lpDataRec->bShingle				= shingle[lpDataRec->bMediaType][lpDataRec->bQuality];	/* shingle level */
	*bpc							= *bpl;

	if (colour)
	{
		lpDataRec->bLeftCartridgeID		= COL_CARTRIDGE;
		lpDataRec->bColorPlanes			= 3;
		*bpl							*= 3;
	}
}

static _kernel_oserror *kelvin__startjob(void **anchor, int stripType)
{
	_kernel_oserror *err;
	kelvin__job *job;
	LPDVDATAREC lpDataRec;

	if (err = pdumper_startjob(anchor, 0u, palfile), err)
		return err;

	/* Now claim our little bit of workspace */

	if (err = pdumper_claim(anchor, sizeof(kelvin__job), kelvin__rootBlock, (void **) &job), err)
		return err;

	memset(job, 0, sizeof(kelvin__job));

	if (err = lexmark_claimworkspace(&job->lpDataRec), err)
		return err;

	lpDataRec = job->lpDataRec;

    kelvin_setjobparameters((stripType & 0xFF) >= StripType_256Colour, lpDataRec, &job->bytesPerLine, &job->bytesPerColour);

	if (err = kelvin__ensurebuffer(anchor, job, job->bytesPerLine), err)
		return err;

    job->startPending = TRUE;

	return NULL;
}

static _kernel_oserror *kelvin__colourset(	void **anchor, unsigned int col, unsigned int stripType,
											unsigned int halfToneInfo, unsigned int *colNo /* out */)
{
	return pdumper_setcolour(anchor, col, stripType, halfToneInfo, colNo);
}

static _kernel_oserror *kelvin__startpage(	void **anchor, unsigned int *copies /* in/out */, unsigned int fh,
											unsigned int stripType, unsigned int *blankLines /* in/out */,
											unsigned int leftMargin, unsigned int halfToneInfo)
{
	kelvin__job *job;
	_kernel_oserror *err;

	(void) copies;
	(void) stripType;
	(void) halfToneInfo;

	if (err = pdumper_find(anchor, kelvin__rootBlock, (void **) &job), err)
		return err;

	job->lpDataRec->flOutFile = fh;

	job->leftMargin		= leftMargin & ~7;		/* bytes */
	job->topMargin		= *blankLines;
	*blankLines			= 0;
	job->curRow			= job->topMargin;

	if (job->startPending)
	{
		if (err = lexmark_startdoc(job->lpDataRec), err)
			return err;
			
		job->startPending	= FALSE;
	}

	job->needEndPage	= TRUE;		/* in case we get aborted */

	return lexmark_startpage(job->lpDataRec);
}

static _kernel_oserror *kelvin__endpage(	void **anchor, unsigned int fh, unsigned int stripType)
{
	kelvin__job *job;
	_kernel_oserror *err;

	(void) stripType;

	if (err = pdumper_find(anchor, kelvin__rootBlock, (void **) &job), err)
		return err;

	job->lpDataRec->flOutFile	= fh;
	job->needEndPage			= FALSE;

	if (err = lexmark_endpage(job->lpDataRec), err)		return err;

	return NULL;
}

static _kernel_oserror *kelvin__abortjob(   void **anchor, unsigned int fh, unsigned int stripType, int reason)
{
	kelvin__job *job;
	_kernel_oserror *err = NULL, *err2;

    (void) stripType;

	if (reason != 0)	/* end of whole job */
	{
		if (err = pdumper_find(anchor, kelvin__rootBlock, (void **) &job), err)
			goto noluck;

		kelvin_trace1("Abort job: %p\n", job);
	
		job->lpDataRec->flOutFile = fh;

		if (job->needEndPage)
		{
			kelvin_trace0("Making pending call to kelvin__endpage()\n");
			err = lexmark_endpage(job->lpDataRec);
			kelvin_trace0("Done kelvin__endpage()\n");
			job->needEndPage = FALSE;
		}

		err2 = lexmark_enddoc(job->lpDataRec);
		if (!err) err = err2;
	
		/* now free the memory we got at the start of the job */
	
		if (job->rowBuf)
			err2 = pdumper_free(anchor, job->rowBuf);
		if (!err) err = err2;
		err2 = pdumper_free(anchor, job);
		if (!err) err = err2;
	}

noluck:
	err2 = pdumper_tidyjob(anchor, NULL, reason);
	if (!err) err = err2;

	return err;
}

void kelvin_findlimits(const unsigned char *buf, int *left, int *right)
{
	int l	= *left;
	int r	= *right;

	while (r > 0 && buf[r-1] == 0)
		r--;

	while (l < r && buf[l] == 0)
		l++;

	*left	= l;
	*right	= r;
}

static _kernel_oserror *kelvin__outputdump(	void **anchor, unsigned char *data, unsigned int fh, unsigned int stripType,
											unsigned int pixWidth, unsigned int pixHeight, size_t rowLen,
											unsigned int halfToneInfo)
{
	kelvin__job *job;
	_kernel_oserror *err;
	int lineWidth;
	int prepType;
	BOOL colour = (stripType & 0xFF) >= StripType_256Colour;
	enum { Y = 1, M = 2, C = 4, K = 8 };		/* bits in a colour byte */

	(void) conf;
	(void) halfToneInfo;

	prepType = ((stripType & 0xFF) - 1) * 2;
	if ((halfToneInfo & 0xFF) <= 1) prepType++;

	if (err = pdumper_find(anchor, kelvin__rootBlock, (void **) &job), err)
		return err;

	job->lpDataRec->flOutFile = fh;

	if (0)
	{
		char name[256];
		sprintf(name, "IDEFS::Inca.$.Works.Lexmark.Kelvin.Trace.In(%05d)", job->curRow);
		rawsprite_save(name, data, rowLen, pixHeight, 3);
	}

	if (err = pdumper_preparestrip(anchor, data, prepType, pixWidth, pixHeight, rowLen, halfToneInfo), err)
		return err;

	if (0)
	{
		char name[256];
		sprintf(name, "IDEFS::Inca.$.Works.Lexmark.Kelvin.Trace.Out(%05d)", job->curRow);
		rawsprite_save(name, data, rowLen, pixHeight, 3);
	}

	lineWidth = (pixWidth + 7) / 8;
	if (lineWidth > job->bytesPerColour) lineWidth = job->bytesPerColour;
		
	/* Got that done, so now sling the actual data */

	while (pixHeight-- > 0)
	{
		int b;
		struct _wb { unsigned w1, w2; } *wb = (struct _wb *) data;
		int left, right;

		if (colour)
		{
			static int colbit[3] = { C | K, M | K, Y | K };
			int c;
			int l, r;

			left	= lineWidth;
			right	= 0;

			for (c = 0; c < 3; c++)
			{
				int bit = colbit[c];
				unsigned char *row = job->rowBuf + job->bytesPerColour * c;

 				for (b = 0; b < lineWidth; b++)
 				{
 					row[b] =	((wb[b].w1 & (bit <<  0)) ? (1 << 7) : 0) |
 								((wb[b].w1 & (bit <<  8)) ? (1 << 6) : 0) |
 								((wb[b].w1 & (bit << 16)) ? (1 << 5) : 0) |
 								((wb[b].w1 & (bit << 24)) ? (1 << 4) : 0) |
 								((wb[b].w2 & (bit <<  0)) ? (1 << 3) : 0) |
 								((wb[b].w2 & (bit <<  8)) ? (1 << 2) : 0) |
 								((wb[b].w2 & (bit << 16)) ? (1 << 1) : 0) |
 								((wb[b].w2 & (bit << 24)) ? (1 << 0) : 0);
 				}

				l		= 0;
				r		= lineWidth;
				kelvin_findlimits(row, &l, &r);
				left	= MIN(left, l);
				right	= MAX(right, r);
			}
		}
		else
		{
			for (b = 0; b < lineWidth; b++)
			{
				job->rowBuf[b] =	((wb[b].w1 & 0x00000001) <<  7) |
									((wb[b].w1 & 0x00000100) >>  2) |
									((wb[b].w1 & 0x00010000) >> 11) |
									((wb[b].w1 & 0x01000000) >> 20) |
									((wb[b].w2 & 0x00000001) <<  3) |
									((wb[b].w2 & 0x00000100) >>  6) |
									((wb[b].w2 & 0x00010000) >> 15) |
									((wb[b].w2 & 0x01000000) >> 24);
			}
			
			left	= 0;
			right	= lineWidth;
			kelvin_findlimits(job->rowBuf, &left, &right);
		}

		if (left < right && (err = lexmark_sendstrip(job->lpDataRec, job->rowBuf, job->curRow, 0, lineWidth), err))
			return err;

		job->curRow++;

		data += rowLen;
	}

	return NULL;
}

static _kernel_oserror *kelvin__command(unsigned int reason, unsigned int fh)
{
	LPDVDATAREC lpDataRec;
	_kernel_oserror *err;

	switch (reason)
	{
	case 0:		/* centre the head				*/
		if (err = lexmark_claimworkspace(&lpDataRec), err) return err;
		lpDataRec->flOutFile = fh;						/* riscos file handle */
		if (err = lexmark_startdoc(lpDataRec), err) return err;
		if (err = lexmark_installcartridge(lpDataRec), err) return err;
		lexmark_enddoc(lpDataRec);
		break;
		
	case 1:		/* send the print head home		*/
		if (err = lexmark_claimworkspace(&lpDataRec), err) return err;
		lpDataRec->flOutFile = fh;						/* riscos file handle */
		if (err = lexmark_startdoc(lpDataRec), err) return err;
		if (err = lexmark_sendcartridgehome(lpDataRec), err) return err;
		lexmark_enddoc(lpDataRec);
		break;

	case 2:		/* clean the print head			*/
		break;
	}

	return NULL;
}

_kernel_oserror *kelvin_handler(int reason, _kernel_swi_regs *r)
{
	kelvin_trace11("PDumper(%3d, %08x, %08x, %08x, %08x, %08x,\n"
	             "             %08x, %08x, %08x, %08x, %08x)\n",
	             reason,	r->r[0], r->r[1], r->r[2], r->r[3], r->r[4],
	             			r->r[5], r->r[6], r->r[7], r->r[8], r->r[9]);

	switch (reason)
	{
	case PDumperReason_SetDriver:		/* it's me!! */
		kelvin__setdriver(	(const char *) r->r[3], (const kelvin_pdconfig *) r->r[4], (unsigned int) r->r[5]);
		return NULL;
		
	case PDumperReason_OutputDump:
		return kelvin__outputdump(	(void **) r->r[8], (unsigned char *) r->r[0], r->r[1], r->r[2], r->r[3], r->r[4],
									r->r[5], r->r[6]);
		break;

	case PDumperReason_ColourSet:
		return kelvin__colourset(	(void **) r->r[3], r->r[0], r->r[2], r->r[4], (unsigned int *) &r->r[3]);

	case PDumperReason_StartPage:
		return kelvin__startpage(	(void **) r->r[4], (unsigned int *) &r->r[0], r->r[1], r->r[2],
									(unsigned int *) &r->r[3], r->r[6], r->r[7]);

	case PDumperReason_EndPage:
		return kelvin__endpage(		(void **) r->r[3], r->r[1], r->r[2]);
		break;

	case PDumperReason_StartJob:
		return kelvin__startjob(	(void **) r->r[0], r->r[2]);

	case PDumperReason_AbortJob:
		return kelvin__abortjob(	(void **) r->r[0], r->r[1], r->r[2], r->r[3]);
		break;

	case PDumperReason_MiscOp:
		break;

	case PDumperReason_Command:
		return kelvin__command(		r->r[0], r->r[1]);
		break;

	default:
		kelvin_trace1("Unknown reason code %d\n", reason);
		break;
	}

	return NULL;
}

void kelvin_register(void *ws)
{
	_kernel_swi_regs r;
	_kernel_oserror *err;
	int c = 1;

	r.r[0]		= 0x301680B5;		/* Who knows? */
	r.r[1]		= 4;
	(void) _kernel_swi_c(OS_ReadModeVariable, &r, &r, &c);

	kelvin_trace0("Registering dumper\n");

	r.r[0]		= (int) 0x80000000ul;
	r.r[1]		= PDumperLexmark_Number;
	r.r[2]		= 439;						/* min version == 4.39 */
	r.r[3]		= (int) ws;
	r.r[4]		= (int) kelvin_handlerveneer;
	r.r[5]		= (1 << PDumperReason_MAX) - 1;
	r.r[6]		= c ? 0x0F : 0x37;			/* magic! */
	r.r[8]		= 7;

	if (err = _kernel_swi(PDriver_MiscOpForDriver, &r, &r), err)
		kelvin_trace1("Error registering: %s\n", err->errmess);
	else
		registered = TRUE;
}

void kelvin_pdumperdead(void)
{
	kelvin_trace0("PDumper_Dying\n");
	registered = FALSE;
}

_kernel_oserror *kelvin_unregister(void)
{
	_kernel_swi_regs r;
	_kernel_oserror *err;

	if (!registered)
		return NULL;

	r.r[0]		= (int) 0x80000001ul;
	r.r[1]		= PDumperLexmark_Number;

	if (err = _kernel_swi(PDriver_MiscOp, &r, &r), !err)
		kelvin_pdumperdead();

	return err;
}
