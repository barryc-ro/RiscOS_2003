
//#pragma warning (disable: 4103)  /* used #pragma pack to change alignment */

#if defined(DOS_BUILD) || defined(FC_DOS_32)
#include <stdio.h>
#endif
#ifndef FC_WIN_32
//#include <memory.h>
#endif
#include "common.h"
//#include "fclocal.h"


static char fc_version[] = "fcrotate.obj: "FC_VERSION;  /* set object module level ID */

/***************************************************************************
 *  FCROTATE.C                                          Lexmark Confidential
 *
 * Function Name:    Rotate
 *
 * Description:
 *    This is the function that rotates raster lines into a print swath.
 *    It rotates the appropriate raster lines into the print swath.  It also
 *    applies the shingling mask, if one is required.  After creating the
 *    print swath, several pieces of information are added to the 26 byte
 *    print swath header, such as slice count, left margin, and right
 *    margin.
 *
 * Inputs:  lpDataRec      Far pointer to HBP interface structure.
 *          nBuffers       Tells which buffers to use when building the print
 *                         swath, ie CMY, K, KCM.
 *
 * Outputs: int   number of lines moved down the page.  Positive number
 *                indicates there is a swath which needs to be printed.
 *                Negative number means the swath is empty, so move the
 *                page by int amount but don't print a swath.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *    4/29/97     RFL            SmartBIDI for KELVIN
 *    6/27/97     RFL            Performance improvements, readability.
 *    8/7/98      AA             lpwSwathWord --> lpwSwathByte and other changes to
 *                               avoid non-aligned word loads and stores
 *
 *************************************************************************/
int Rotate(LPDVDATAREC lpDataRec, int nBuffers, FC_LONG lRow)
{
   int i, j;  /* for loop indexes */
   WORD k;
   DWORD kk;
   int nIStart=0, nIEnd=0;
   WORD  wNozzleCount=0;
   int nSeg, nIndx, nVertRes, nRastRes, nSwathRes, nOut, nRowsMoved;
   WORD wLeftMargin;
   WORD wShingle=0;
   WORD  wRowsToPrint;
   DWORD dwSwathWordOffset;
   DWORD dwSwathByteOffset;
   int nSwathScanStart=299, nSwathScanEnd=0;
   LPBYTE pbPrtDat;
   LPBYTE lpwSwathByte;
   LPWORD lpwRaster;
   WORD wRasterWord;
   WORD wSwathScanStart, wSwathScanEnd;
   WORD wPrintMaskWord;
   LPWORD lpwRastMask,lpwRM,lpwRMStart, lpwRMEnd;
   int   nColorOffset;
   FC_LONG  lBegOut;
   int   nKKInc, nSWInc, nNozzleGap=0, nSliceWord, nNozzleOffset;
   int   nKCMOffset, nSwathSeg, nSwathOffset;
   int   nVertAdj=0;
   BYTE  bBytesPerSlice;
   FC_LONG alDotCount[6] = {0,0,0,0,0,0};
   FC_LONG lSwathDotCount=0;
   BOOL   fEmptySwath=TRUE, fShingled=TRUE;
#if OPTION_CDE
   BOOL   fCDE, fCDEBoundary;
#endif
   BYTE  bSwathDir = FORWARD;
   struct pf_data FAR *pfData;

   int    nNozzle;
   FC_LONG lOutIndex;
   FC_LONG    lInIndex;
   FC_LONG    lBufSize;
   WORD   wSliceCount;
   BYTE   bColorPlanes;
   BYTE   bResolution;
   int   r;
   int   nScanIndex;
   int   nShingle50=0, nShingle25=0, nShingle33=0, nShingle16=0;
   int   jStart, jEnd;
   FC_LONG  lRowStart;

#ifdef CPROF
PrfEnter(7);
#endif

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

   /* localize */
   bColorPlanes = lpDataRec->bColorPlanes;
   bResolution = pfData->bResolution;

   pfData->lSwathDotCount = 0;   /* initialize to 0 */
   lpwRastMask = pfData->lpwRastMask;
   nVertRes = pfData->nVertResMult;
   nRastRes = pfData->nRastResMult;
   nSwathRes = pfData->nSwathResMult;
   wLeftMargin = pfData->wLeftMargin;
   wSliceCount = 0;
   nSwathScanStart = pfData->nPreRotateStart;
   nSwathScanEnd = pfData->nPreRotateEnd;
   wSwathScanStart = (WORD)pfData->nPreRotateStart/2;
   wSwathScanEnd = (WORD)(pfData->nPreRotateEnd+1)/2;
   nRowsMoved = pfData->wRowsToMove;
#if OPTION_CDE
   fCDE = pfData->fCDE;
#endif

   switch (nBuffers)
   {
      case CMYPLANES :
      {
         pfData->bPrintHead = COL_CARTRIDGE;
         wSliceCount += (WORD)(MAGENTA_OFFSET*nSwathRes);
         wSliceCount += (WORD)(COLOR_NOZZLE_OFFSET*nSwathRes);
         nIStart = 0;
         nIEnd   = 3;
         pfData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
         wNozzleCount  = (WORD) pfData->nColorNozzleCount;
         nNozzleGap    = COLOR_NOZZLE_OFFSET;
         nVertAdj      = 0;
         break;
      }  /* end of CMYPLANES */

      case KCMPLANES :
      {
         if (wLeftMargin)
            wLeftMargin -= (WORD)(KCM_HORZ_OFFSET*nSwathRes);
         pfData->bPrintHead = KCM_CARTRIDGE;
         wSliceCount += (WORD)(MAGENTA_OFFSET*nSwathRes);
         wSliceCount += (WORD)(COLOR_NOZZLE_OFFSET*nSwathRes);
         nIStart = 3;
         nIEnd   = 6;
         pfData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
         wNozzleCount  = (WORD) pfData->nColorNozzleCount;
         nNozzleGap    = COLOR_NOZZLE_OFFSET;
         nVertAdj      = 0;
         break;
      }  /* end of KCMPLANES */

      case KPLANE:
      {
         if (bColorPlanes == 4)
         {
            /* CMYK print job */
            pfData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
            nVertAdj = (int) lpDataRec->bVerticalAdj;
         }
         else
         {
            /* K print job */
            if ((bResolution == HIRES) || (bResolution == MIDRES))
            {
               pfData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
               nVertAdj = (int) lpDataRec->bVerticalAdj;
            }
            else
            {
               pfData->bBytesPerSlice = K_BYTES_PER_SLICE;
               nVertAdj = 0;
            }
         }
         pfData->bPrintHead = MONO_CARTRIDGE;
         wSliceCount += (WORD)(MONO_NOZZLE_OFFSET*nSwathRes);
         nIStart = 3;
         nIEnd   = 4;
         wNozzleCount  = (WORD) pfData->nMonoNozzleCount;
         nNozzleGap    = MONO_NOZZLE_OFFSET;
         break;
      }  /* end of KPLANE */
   }  /* end of switch(nBuffers) */

   pfData->bPrintDirection = GetPrintDir(lpDataRec, nBuffers);


   /* set as locals */
   bBytesPerSlice = pfData->bBytesPerSlice;
   nSwathScanStart        = SliceSkip(nSwathScanStart,nSwathRes);
   nSwathScanEnd          = SliceSkip(nSwathScanEnd,nSwathRes);
   pfData->nLeftPrintPos  = RastertoPrintPos(nSwathScanStart,wLeftMargin);

   wSliceCount   += (WORD)((nSwathScanEnd - nSwathScanStart)*8);
   pfData->nRightPrintPos = pfData->nLeftPrintPos + wSliceCount - 1;

   /* clear print swath */
   ClearPrintSwath(pfData);

#if OPTION_REVERSE_SWATH
   /******************************************************
    * reset raster masks based on carrier print direction
    ******************************************************/
   bSwathDir = CheckforReverseSwath(lpDataRec);
   if (bSwathDir == REVERSE)
   {  /* reverse swath */
      /* If building swath backwards then rotate from the end */
      /* of the raster, not the begining (right to left) */

      pfData->lpwRastMask[0]  = RASTER_MASK15;
      pfData->lpwRastMask[1]  = RASTER_MASK14;
      pfData->lpwRastMask[2]  = RASTER_MASK13;
      pfData->lpwRastMask[3]  = RASTER_MASK12;
      pfData->lpwRastMask[4]  = RASTER_MASK11;
      pfData->lpwRastMask[5]  = RASTER_MASK10;
      pfData->lpwRastMask[6]  = RASTER_MASK9;
      pfData->lpwRastMask[7]  = RASTER_MASK8;
      pfData->lpwRastMask[8]  = RASTER_MASK7;
      pfData->lpwRastMask[9]  = RASTER_MASK6;
      pfData->lpwRastMask[10] = RASTER_MASK5;
      pfData->lpwRastMask[11] = RASTER_MASK4;
      pfData->lpwRastMask[12] = RASTER_MASK3;
      pfData->lpwRastMask[13] = RASTER_MASK2;
      pfData->lpwRastMask[14] = RASTER_MASK1;
      pfData->lpwRastMask[15] = RASTER_MASK0;
   }  /* end of reverse swath */
   else
   {  /* forward swath */
      pfData->lpwRastMask[0]  = RASTER_MASK0;
      pfData->lpwRastMask[1]  = RASTER_MASK1;
      pfData->lpwRastMask[2]  = RASTER_MASK2;
      pfData->lpwRastMask[3]  = RASTER_MASK3;
      pfData->lpwRastMask[4]  = RASTER_MASK4;
      pfData->lpwRastMask[5]  = RASTER_MASK5;
      pfData->lpwRastMask[6]  = RASTER_MASK6;
      pfData->lpwRastMask[7]  = RASTER_MASK7;
      pfData->lpwRastMask[8]  = RASTER_MASK8;
      pfData->lpwRastMask[9]  = RASTER_MASK9;
      pfData->lpwRastMask[10] = RASTER_MASK10;
      pfData->lpwRastMask[11] = RASTER_MASK11;
      pfData->lpwRastMask[12] = RASTER_MASK12;
      pfData->lpwRastMask[13] = RASTER_MASK13;
      pfData->lpwRastMask[14] = RASTER_MASK14;
      pfData->lpwRastMask[15] = RASTER_MASK15;
   } /* end of forward swath */
#endif /* end of OPTION_REVERSE_SWATH */

   nOut = pfData->nOut;
   if (nOut == FC_OUT_EVEN)
      nRowsMoved -= 3;
   else if (nOut == FC_OUT_ODD)
      nRowsMoved += 3;

   for (i=nIStart; i<nIEnd; i++)
   {  /* Once for each plane of color */

      lBegOut = pfData->alDBIndx[nOut][i];          /* get begining index */
      lOutIndex = pfData->alDBIndx[nOut][i];
      lInIndex = pfData->alDBIndx[FC_IN][i];
      lBufSize = pfData->alDBIndx[BUFSIZE][i];
      wRowsToPrint = pfData->awRowsToPrint[i];

      if (pfData->bResolution == HIRES)
      {
         lRowStart = (lRow - (FC_LONG)(wNozzleCount*nVertRes) + 1);
         if (lRowStart < pfData->lFirstRowOfSection[nOut][i])
         {
            lRowStart = pfData->lFirstRowOfSection[nOut][i];
         }
         lRowStart -= (FC_LONG)(pfData->alDBIndx[INIT_DELAY][i]*nVertRes);
         lRowStart = lRowStart % (FC_LONG)pfData->nMaxDelayBuf;
      }
      else
      {
         lRowStart = (pfData->lBottomNozzleRowNum - (wRowsToPrint*nVertRes) - 
                     (pfData->alDBIndx[INIT_DELAY][i]*nVertRes) + 1);
      }

      jStart   = (wNozzleCount*(WORD)nVertRes) - wRowsToPrint;
      jEnd     = wNozzleCount * (WORD)nVertRes;
      for (j=jStart, r=(int)lRowStart; j < jEnd; j++, r++)
      {  /* Once for each raster line in the color plane */
         if (lOutIndex == lInIndex)
            break;

         nNozzle = j/nVertRes;
         fShingled = TRUE;
         nScanIndex = (int)(r%pfData->nMaxDelayBuf);

         if (((nOut == FC_OUT_EVEN) && (lOutIndex % 2))   ||
             ((nOut == FC_OUT_ODD) && (!(lOutIndex % 2))) ||
             (lOutIndex < 0)                              ||
             ((nSwathScanEnd - nSwathScanStart) <= 0 )    ||
             (pfData->alpbShingleToApply[i][nScanIndex] == SHINGLE_THRU) )
         {
            if (pfData->bResolution == HIRES)
            {
               lOutIndex = (FC_LONG)((lOutIndex + 1) % pfData->alDBIndx[BUFSIZE][i]);
            }
            else
            {
               lOutIndex++;
            }
            continue;
         }

#if OPTION_CDE
         fCDEBoundary = FALSE;
#endif

         switch(pfData->alpbShingleToApply[i][nScanIndex])
         {
            case SHINGLE_0_1 :
               fShingled = FALSE;
               break;
            case SHINGLE_50_1 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_50][
                          (pfData->alpwShingleLine[i][nScanIndex])%2];
               break;
            case SHINGLE_50_2 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_50][
                          ((pfData->alpwShingleLine[i][nScanIndex])+1)%2];
               break;
            case SHINGLE_25_1 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_25][
                          (pfData->alpwShingleLine[i][nScanIndex])%4];
               break;
            case SHINGLE_25_2 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_25][
                          ((pfData->alpwShingleLine[i][nScanIndex]+1))%4];
               break;
            case SHINGLE_25_3 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_25][
                          ((pfData->alpwShingleLine[i][nScanIndex]+2))%4];
               break;
            case SHINGLE_25_4 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_25][
                          ((pfData->alpwShingleLine[i][nScanIndex]+3))%4];
               break;
            case SHINGLE_33_1 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_33][
                          (pfData->alpwShingleLine[i][nScanIndex])%3];
               break;
            case SHINGLE_33_2 :
                  wShingle = pfData->alpwShingleMask[SHINGLE_MASK_33][
                             ((pfData->alpwShingleLine[i][nScanIndex])+1)%3];
               break;
            case SHINGLE_33_3 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_33][
                          ((pfData->alpwShingleLine[i][nScanIndex])+2)%3];
               break;
            case SHINGLE_16_1 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_16][
                          (pfData->alpwShingleLine[i][nScanIndex])%6];
               break;
            case SHINGLE_16_2 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_16][
                          ((pfData->alpwShingleLine[i][nScanIndex])+1)%6];
               break;
            case SHINGLE_16_3 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_16][
                          ((pfData->alpwShingleLine[i][nScanIndex])+2)%6];
               break;
            case SHINGLE_16_4 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_16][
                          ((pfData->alpwShingleLine[i][nScanIndex])+3)%6];
               break;
            case SHINGLE_16_5 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_16][
                          ((pfData->alpwShingleLine[i][nScanIndex])+4)%6];
               break;
            case SHINGLE_16_6 :
               wShingle = pfData->alpwShingleMask[SHINGLE_MASK_16][
                          ((pfData->alpwShingleLine[i][nScanIndex])+5)%6];
               break;
         }

         wPrintMaskWord = pfData->lpwPrtMask[(nNozzle % 16)];

         if (nBuffers == KPLANE &&
             bColorPlanes == 1 &&
             (!((bResolution == HIRES) || (bResolution == MIDRES))))
         {
            nSliceWord     = Mono7SliceWord(i, nIStart, nIEnd, nNozzle);
            wPrintMaskWord = pfData->lpwPrtMask[(nNozzle % 16)+ OddByteMaskAdjust(nNozzle)];
         }
         else if (nBuffers == K7PLANE)
            nSliceWord     = Mono6SliceWord(i, nIStart, nIEnd, nNozzle);
         else if (nBuffers == K6PLANE)
            nSliceWord     = Mono6SliceWord(i, nIStart, nIEnd, nNozzle);
         else if (nBuffers == KPLANE)
            nSliceWord     = Mono6SliceWord(i, nIStart, nIEnd, nNozzle);
         else
            nSliceWord     = SliceWord(i,nIStart,nIEnd, nNozzle);

         nColorOffset = ColorOffset(bSwathDir, i, MAGENTA_OFFSET, nSwathRes);
         nNozzleOffset  = NozzleOffset(nVertAdj, nNozzle, nNozzleGap, bBytesPerSlice, nSwathRes);

         if (nBuffers == KCMPLANES)
            nKCMOffset = KCMOffset(nNozzle, nSwathRes);
         else
            nKCMOffset = 0;

         if (pfData->bResolution == HIRES)
         {
            nSeg = i + (FC_INT)(lOutIndex / pfData->nRastersPerSeg * MAXNUMPLANES);
            nIndx = (FC_INT)(lOutIndex % pfData->nRastersPerSeg);
         }
         else
         {
            nSeg = i + ( (FC_INT)(lOutIndex % pfData->alDBIndx[BUFSIZE][i])
                   / pfData->nRastersPerSeg * MAXNUMPLANES);
            nIndx = ( (FC_INT)(lOutIndex % pfData->alDBIndx[BUFSIZE][i])
                    % pfData->nRastersPerSeg);
         }

         lpwRaster = pfData->alpwPlane[nSeg] + (nIndx * pfData->nWordsPerRow);


#if OPTION_REVERSE_SWATH
         if (bSwathDir == REVERSE)
         {
             /* If need to build print swath backwards then reverse the */
             /* words in the raster.  Reversing the bits within each word */
             /* is performed by switching the raster masks above */

            nNozzleOffset  = ReverseNozzleOffset(nVertAdj, nNozzle, nNozzleGap, bBytesPerSlice,nSwathRes);

             for (k=wSwathScanStart; k<wSwathScanEnd; k++)
               *(pfData->lpwReverseRaster + k) = *(lpwRaster+(wSwathScanStart + wSwathScanEnd-k-1));

             lpwRaster = pfData->lpwReverseRaster;
         }
#endif

         nKKInc = bBytesPerSlice * 8;

         kk = 0;
         for (k = wSwathScanStart; k < wSwathScanEnd; k++)
         {  /* Once for each word in the raster line */
            wRasterWord = *(lpwRaster + k);

            if (fShingled == TRUE)
               wRasterWord &= wShingle;

            if (wRasterWord)
            {  /* data in this word */
               if    (nBuffers == KPLANE &&
                      bColorPlanes == 1 &&
                     (!((bResolution == HIRES) || (bResolution == MIDRES))))
               {
                  dwSwathWordOffset = (DWORD)(SliceSkip(kk, nSwathRes) +
                                                            nColorOffset +
                                                            nNozzleOffset +
                                                            nKCMOffset);

                  dwSwathByteOffset = (DWORD)dwSwathWordOffset * 2 +
                                             nSliceWord;
               }
               else
               {
                  dwSwathWordOffset = (DWORD)(SliceSkip(kk, nSwathRes) +
                                                            nSliceWord +
                                                            nColorOffset +
                                                            nNozzleOffset +
                                                            nKCMOffset);

                  dwSwathByteOffset = (DWORD)dwSwathWordOffset * 2;
               }

               nSwathSeg = (int)((DWORD)dwSwathByteOffset /
                                 ((DWORD)SLICES_PER_SEG *
                                  (DWORD)bBytesPerSlice));

               nSwathOffset = (int)((DWORD)dwSwathByteOffset %
                                    ((DWORD)SLICES_PER_SEG *
                                     (DWORD)bBytesPerSlice));

               pbPrtDat = (LPBYTE)pfData->alpbSwath[nSwathSeg];
               pbPrtDat += nSwathOffset;
               lpwSwathByte = pbPrtDat;

               lpwRMEnd = lpwRastMask + 16;

               nSWInc = SliceSkip(bBytesPerSlice, nSwathRes);


#if OPTION_CDE
               if (fCDEBoundary)
               {  /* last bit of prior word was rotated, start with 2nd bit */
                  lpwRMStart = lpwRastMask + 1;
                  lpwSwathByte += nSWInc;
               }
               else
                  lpwRMStart = lpwRastMask;
#else
               lpwRMStart = lpwRastMask;
#endif

               for (lpwRM = lpwRMStart; lpwRM < lpwRMEnd; lpwRM++)
               {  /* Once for each bit in the word */
                  if (wRasterWord & *lpwRM)
                  {  /* bit to be rotated */
                  	lpwSwathByte[0] |= (wPrintMaskWord >> 0);
                  	lpwSwathByte[1] |= (wPrintMaskWord >> 8);
                     alDotCount[i]++;

#if OPTION_CDE
                     if (fCDE)
                     {
                        lpwSwathByte += nSWInc;

                        /* set boundary sw. if last bit rotated */
                        fCDEBoundary = (*lpwRM & pfData->lpwRastMask[15]);
                        lpwRM++; /* increment past next bit */
                     }
#endif

                  }
                  lpwSwathByte += nSWInc;
               }  /* Once for each bit in the word */
            }  /* end of data in this word */
            kk += nKKInc;
         }  /* Once for each word in the raster line */

         if (pfData->bResolution == HIRES)
         {
            lOutIndex = ((lOutIndex + 1) % pfData->alDBIndx[BUFSIZE][i]);
         }
         else
         {
            lOutIndex++;
         }

      }  /* Once for each raster line in the color plane */

#ifdef SMARTBIDI
      /***************************************************************
       * SmartBIDI - test for data in last line of swath     RFL
       ****************************************************************/
      if   (pfData->iSmartBIDI)
      {
         pfData->iLastLineNull = 1;     /* set the swath break switch */
         lpwRaster = lpwRaster + wSwathScanStart;/* set to 1st wd */
         for (k=wSwathScanStart; k<wSwathScanEnd; k++)
         {  /* Once for each word in the raster line till data found */
            if   (*lpwRaster++)
            {
               pfData->iLastLineNull = 0; /* clear the swath break switch */
               break;                     /* get out of loop */
            }
         }
      }  /* end of test for data in last line of swath */
#endif /* end of SMARTBIDI */

   }  /* Once for each plane of color */

   for (i=nIStart; i<nIEnd; i++)
   {
      /* check to see if any dots were added to print swath */
      if (alDotCount[i] != 0)
      {
         fEmptySwath = FALSE;
         pfData->alDotCount[i] += alDotCount[i];
         lSwathDotCount += alDotCount[i];
      }

   }
   if (fEmptySwath || ((nSwathScanEnd - nSwathScanStart) <= 0 ))
   {
#ifdef CPROF
PrfExit(7);
#endif
      pfData->wSliceCount = wSliceCount; /* restore global */
      return(0); /* empty swath */
   }

   pfData->lSwathDotCount = lSwathDotCount;

#ifdef CPROF
PrfExit(7);
#endif

   pfData->wSliceCount = wSliceCount; /* restore global */
   return(1);

}  /* end of Rotate() */


/***************************************************************************
 *  FCROTATE.C                                          Lexmark Confidential
 *
 * Function Name:    SwathMargins
 *
 * Description:
 *    Determines the narrowest margins possible for the current print
 *    swath.  Considers the left and right margins for each raster line
 *    that will be used to help create the current print swath.
 *
 * Inputs:  lpDataRec      Far pointer to HBP interface structure.
 *          lRow           helps synchronize the delay buffers with the
 *                         margins buffer.
 *
 * Outputs: stores swath left margin in pfData->nPreRotateStart.  Stores
 *          swath right margin in pfData->nPreRotateEnd.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void SwathMargins(LPDVDATAREC lpDataRec, int nBuffers, FC_LONG lRow)
{
   int      i;    /* for loop indexes */
   FC_LONG  j;
   int nIStart, nIEnd;
   int nOut;
   WORD  wVertRes;
   FC_LONG k, kEnd, lRowStart, lBufStart;
   int nSwathScanStart, nSwathScanEnd;
   struct pf_data FAR *pfData;
   int      nScanIndex;
   WORD  wNozzleCount, wRowsToPrint;

#ifdef CPROF
PrfEnter(6);
#endif

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

   pfData->nPreRotateStart = pfData->nBytesPerRow-1;
   pfData->nPreRotateEnd = 0;

   nSwathScanStart=pfData->nBytesPerRow;
   nSwathScanEnd=0;

   switch (nBuffers)
   {
      case CMYPLANES :
            nIStart = 0;
            nIEnd   = 3;
            pfData->bPreRotatePrintHead = COL_CARTRIDGE;
            break;
      case KCMPLANES :
            nIStart = 3;
            nIEnd   = 6;
            pfData->bPreRotatePrintHead = MONO_CARTRIDGE;
            break;
      case KPLANE:
            nIStart = 3;
            nIEnd   = 4;
            pfData->bPreRotatePrintHead = MONO_CARTRIDGE;
            break;
      default :
#ifdef CPROF
PrfExit(6);
#endif
            return;
   }

   pfData->bPreRotateDir = GetPrintDir(lpDataRec, nBuffers);
   wVertRes = (WORD)pfData->nVertResMult;

   nOut = pfData->nOut;

   /* For the raster lines involved in this print swath, determine the  */
   /* smallest left margin (ScanStart) and the largest right margin     */
   /* (ScanEnd).  These will determine the size and horizontal position */
   /* of the print swath created.                                       */
   for (i=nIStart; i<nIEnd; i++)
   {
      wNozzleCount = pfData->wBaseNozzleCount + pfData->awExtraNozzles[i];
      wRowsToPrint = pfData->awRowsToPrint[i];

      if (pfData->bResolution == HIRES)
      {
         lRowStart = (lRow - (FC_LONG)(wNozzleCount*wVertRes) + 1);
         if (lRowStart < pfData->lFirstRowOfSection[nOut][i])
         {
            lRowStart = pfData->lFirstRowOfSection[nOut][i];
         }
         lRowStart -= (FC_LONG)(pfData->alDBIndx[INIT_DELAY][i]*wVertRes);
         }
      else
      {
         lRowStart = (pfData->lBottomNozzleRowNum - (wRowsToPrint*wVertRes) - 
                     (pfData->alDBIndx[INIT_DELAY][i]*wVertRes) + 1);
      }

      if ( (lRowStart > pfData->lRowPos) ||
           (pfData->alDBIndx[nOut][i] == pfData->alDBIndx[FC_IN][i]) )
      {
         continue;
      }

      if (pfData->bResolution == HIRES)
      {
         lRowStart = lRowStart % (FC_LONG)pfData->nMaxDelayBuf;
         kEnd = lRowStart+(FC_LONG)(wNozzleCount*wVertRes);
      }
      else
      {
         kEnd = lRowStart + wRowsToPrint;
      }
      lBufStart = (int) pfData->alDBIndx[nOut][i];

      for (k=lRowStart, j=lBufStart; k<kEnd; k++, j++)
      {
         if (k > pfData->lRowPos)
            break;
         if ( (pfData->bResolution == HIRES) &&
              ((j % pfData->alDBIndx[BUFSIZE][i]) == pfData->alDBIndx[FC_IN][i]) )
            break;
         if ( (j<0) || (k < 0))
            continue;
         if ((nOut == FC_OUT_EVEN) && (j%2))
            continue;
         if ((nOut == FC_OUT_ODD) && (!(j%2)))
            continue;

         nScanIndex = (int)(k%pfData->nMaxDelayBuf);

         if (pfData->alpnScanStart[i][nScanIndex] < nSwathScanStart)
            nSwathScanStart = pfData->alpnScanStart[i][nScanIndex];
         if (pfData->alpnScanEnd[i][nScanIndex] > nSwathScanEnd)
            nSwathScanEnd = pfData->alpnScanEnd[i][nScanIndex];
      }
   }

   pfData->nPreRotateStart = nSwathScanStart;
   pfData->nPreRotateEnd = nSwathScanEnd;

#ifdef CPROF
PrfExit(6);
#endif

   return;

}  /* end of SwathMargins() */




/***************************************************************************
 *  FCROTATE.C                                          Lexmark Confidential
 *
 * Function Name:    PreSwathAdjust
 *
 * Description:
 *    Determines the narrowest margins possible for the current print
 *    swath.  Considers the left and right margins for each raster line
 *    that will be used to help create the current print swath.
 *
 * Inputs:  lpDataRec      Far pointer to HBP interface structure.
 *          lRow           helps synchronize the delay buffers with the
 *                         margins buffer.
 *
 * Outputs: stores swath left margin in pfData->nPreRotateStart.  Stores
 *          swath right margin in pfData->nPreRotateEnd.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
int PreSwathAdjust(LPDVDATAREC lpDataRec, FC_LONG lRow)
{
   int i; /* for loop indexes */
   WORD           wNozzleCount, wBaseNozzleCount;
   SIGNED_WORD    swShingleThreshold;
   int            nVertRes, nOut;
   BYTE  bSI=0;
   FC_LONG        k;
   struct pf_data FAR *pfData;
   int      nScanIndex;
   WORD     wNozzle, wNozzleStart=0;
   WORD     awNozzleStart[MAXNUMPLANES];
   WORD     wMoveAmount;
   BOOL     fMustPrintHead[2]   = {FALSE, FALSE};
   BOOL     fMustPrintColor[6] = {FALSE, FALSE, FALSE, FALSE, FALSE, FALSE};
   BOOL     fNoLinesToProcess=TRUE;
   BOOL     fRowsToPrint = FALSE;
   WORD     wVerticalMove, awVerticalMove[MAXNUMPLANES];
   FC_LONG  lBottomRow, lTopRow;
   FC_LONG  lOldBottomRow;

#ifdef CPROF
PrfEnter(5);
#endif

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;


   nVertRes    = pfData->nVertResMult;
   nOut        = pfData->nOut;
   wMoveAmount = pfData->wBaseNozzleCount;
   wVerticalMove = pfData->wBaseNozzleCount;

   /* The following for() loop determines the number of nozzles to use in
      this swath (or these swaths).  In other words, determine
      wNozzleStart for the entire swath(s) by looking at wNozzleStart for
      each color plane.  Notice that as we go from one color plane to the
      next, wNozzleStart can become larger (meaning the swath will use 
      fewer nozzles), but it will not get smaller because the previous 
      color planes have already established a maximum nozzle               */
   for (i=pfData->nDelayBufStart;i<pfData->nDelayBufEnd;i++)
   {

      wBaseNozzleCount = pfData->wBaseNozzleCount;
      wNozzleCount = pfData->wBaseNozzleCount + pfData->awExtraNozzles[i];

      bSI = pfData->abShingleIndex[i];

      /* Assuming a full vertical movement before printing this swath,
         lBottomRow is the row number of the row which will be printed
         by the bottom nozzle of this color plane.   The full vertical
         movement comes by using lRow as the basis for calculating 
         lBottomRow. */
      lBottomRow = (lRow - (pfData->alDBIndx[INIT_DELAY][i]*nVertRes));

      if ( (pfData->alDBIndx[nOut][i] == pfData->alDBIndx[FC_IN][i]) || 
           (lBottomRow < pfData->alDBIndx[nOut][i]) )
      {
         /* if the bottom nozzle is still off the printable area, 
            lBottomRow < pfData->alDBIndx[nOut][i],
            then the entire color nozzles are off the page.  So as far
            as this color plane is concerned, it can "use" all of its
            nozzles, or in other words, it can be moved a full vertical
            amount.     */
         awNozzleStart[i] = 0;
         awVerticalMove[i] = wNozzleCount;
         if (awVerticalMove[i] < wVerticalMove)
         {
            wVerticalMove = awVerticalMove[i];
         }
         continue;
      }

      /* Assuming a full vertical movement before printing this swath,
         lTopRow is the row number of the row which will be printed by
         the top nozzle (nozzle 0) of this color plane.     */
      lTopRow = lBottomRow - (FC_LONG) wNozzleCount + 1;

      k = lBottomRow;
      wNozzle = wNozzleCount;

      /* Important to note that this while() loop processes from the 
         bottom of the print nozzles to the top.  I am doing this
         because all color banks don't have the same number of nozzles.  */
      while (k >= lTopRow)
      {

         if (k < pfData->alDBIndx[nOut][i])
         { 
            break;
         }

         wNozzle--;

         nScanIndex = (int)(k%pfData->nMaxDelayBuf);

         if (pfData->alpbShingleToApply[i][nScanIndex] != SHINGLE_THRU)
         {
            swShingleThreshold = (SIGNED_WORD) pfData->awShingleThreshold[bSI][
                                (pfData->alpbShingleToApply[i][nScanIndex])];

            /* This is a critical decision.  If this if() statement is true 
               then that means that this color plane has to be printed at 
               this time.  */
            if ( ((SIGNED_WORD)wNozzle) <= (swShingleThreshold))
            {
               /* We won't make a full vertical movement, so adjust the
                  lBottomRow value we calculated above accordingly.        */
               lBottomRow -= (swShingleThreshold - wNozzle);
               wNozzle    = swShingleThreshold;
               fMustPrintColor[i] = TRUE;
            }
            else if (((SIGNED_WORD)wNozzle) <= 
                     (swShingleThreshold + MINIMUM_VERTICAL_MOVE))
            {
               fMustPrintColor[i] = TRUE;
            }
         }
            
         k--;
      }  /* end of while (k >= lTopRow) */

      awNozzleStart[i] = wNozzle;

      lOldBottomRow = pfData->lBottomNozzleRowNum - 
                      pfData->alDBIndx[INIT_DELAY][i];
      awVerticalMove[i] = (WORD)(lBottomRow - lOldBottomRow);

      if (awVerticalMove[i] < wVerticalMove)
         wVerticalMove = awVerticalMove[i];

   }  /* end of for (i=pfData->nDelayBufStart...) */


   /* Update bottom nozzle row number based on the vertical movement    */
   /* that will occur before this swath (swaths) print.                 */
   pfData->lBottomNozzleRowNum += (FC_LONG)wVerticalMove;

   for (i=pfData->nDelayBufStart;i<pfData->nDelayBufEnd;i++)
   {
      if ((fMustPrintColor[i]) && (awVerticalMove[i] == wVerticalMove))
      {
         fMustPrintHead[(i/3)] = TRUE;
      }
      else if ( (fMustPrintColor[i]) && 
                (awVerticalMove[i] >= (wVerticalMove - MINIMUM_VERTICAL_MOVE)) )
      {
         fMustPrintHead[(i/3)] = TRUE;
      }
   }

   /* Now assign nozzle positions to the raster lines that will make up this
      swath.  This is used to determine what shingle mask pattern to apply */
   for (i=pfData->nDelayBufStart;i<pfData->nDelayBufEnd;i++)
   {
      wNozzle      = awNozzleStart[i] + (awVerticalMove[i]-wVerticalMove);
      wNozzleCount = pfData->wBaseNozzleCount + pfData->awExtraNozzles[i];
      lBottomRow   = pfData->lBottomNozzleRowNum - 
                     (pfData->alDBIndx[INIT_DELAY][i]*nVertRes);

      if (fMustPrintHead[(i/3)])
      {
         if ( (pfData->alDBIndx[nOut][i] == pfData->alDBIndx[FC_IN][i]) ||
              (lBottomRow < pfData->alDBIndx[nOut][i]) )
         {
            pfData->awRowsToPrint[i] = 0;
            continue;
         }
         else
         {
            pfData->awRowsToPrint[i]      = wNozzleCount - wNozzle;
         }
      }
      else
      {
         pfData->awRowsToPrint[i] = 0;
         continue;
      }

      lTopRow      = lBottomRow - pfData->awRowsToPrint[i] + 1;
      k = lTopRow;

      while (k <= lBottomRow)
      {
         if (k == pfData->alDBIndx[FC_IN][i])
         {
            break;
         }
         nScanIndex = (int)(k%pfData->nMaxDelayBuf);

         switch(pfData->alpbShingleToApply[i][nScanIndex])
         {
         case SHINGLE_0_1 :
         case SHINGLE_50_1 :
         case SHINGLE_25_1 :
         case SHINGLE_33_1 :
         case SHINGLE_16_1 :
            pfData->alpwShingleLine[i][nScanIndex] = wNozzle;
            break;
         }

         wNozzle++;
         k++;
      }  /* end of while (k <= lBottomRow) */


   }  /* end of for (i=pfData->nDelayBufStart;i<pfData->nDelayBufEnd;i++) */

   pfData->wRowsToMove = wVerticalMove;

#ifdef CPROF
PrfExit(5);
#endif
   return((int)wVerticalMove);
}  /* end of PrepareSwath() */




int PostSwathAdjust(LPDVDATAREC lpDataRec, FC_LONG lRow)
{
   int i; /* for loop indexes */
   WORD wNozzleCount;
   int nVertRes, nOut;
   FC_LONG     lRowStart, lRowEnd, k;
   struct pf_data FAR *pfData;
   int      nScanIndex;
   WORD     wRowsToRead, wMinRowsToRead;
   BOOL     fKeepRow;

#ifdef CPROF
PrfEnter(8);
#endif

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

   nVertRes = pfData->nVertResMult;
   nOut     = pfData->nOut;
   wMinRowsToRead = pfData->wBaseNozzleCount;


   for (i=pfData->nDelayBufStart;i<pfData->nDelayBufEnd;i++)
   {
      fKeepRow = FALSE;

      if (pfData->alDBIndx[nOut][i] == pfData->alDBIndx[FC_IN][i])
      {
         continue;
      }


      lRowStart = pfData->alDBIndx[nOut][i];
      lRowEnd   = lRowStart + pfData->awRowsToPrint[i];

      k = lRowStart;

      while (k < lRowEnd)
      {
         if (k == pfData->alDBIndx[FC_IN][i])
         {
            break;
         }

         nScanIndex = (int)(k%pfData->nMaxDelayBuf);

         switch(pfData->alpbShingleToApply[i][nScanIndex])
         {
         case SHINGLE_THRU    :
            if (fKeepRow == FALSE)
            {
               pfData->alDBIndx[nOut][i]++;
            }
            break;
         case SHINGLE_0_1  :
         case SHINGLE_50_2 :
         case SHINGLE_25_4 :
         case SHINGLE_33_3 :
         case SHINGLE_16_6 :
            pfData->alpbShingleToApply[i][nScanIndex] = SHINGLE_THRU;
            if (fKeepRow == FALSE)
            {
               pfData->alDBIndx[nOut][i]++;
            }
            break;
         default :
            pfData->alpbShingleToApply[i][nScanIndex]++;
            fKeepRow = TRUE;
            break;
         }
         k++;                 
      }  /* end of while (k < kEnd) */

      wNozzleCount = pfData->wBaseNozzleCount + pfData->awExtraNozzles[i];

      if (pfData->alDBIndx[nOut][i] == pfData->alDBIndx[FC_IN][i])
      {
         wRowsToRead = wNozzleCount;
      }
      else
      {
         wRowsToRead = (wNozzleCount + (WORD)pfData->alDBIndx[INIT_DELAY][i]) -
                       (WORD)(lRow - pfData->alDBIndx[nOut][i] + 1L);
      }

      if (wRowsToRead < wMinRowsToRead)
      {
         wMinRowsToRead = wRowsToRead;
      }
   }   /* end of for (i=pfData->nDelayBufStart...) */


#ifdef CPROF
PrfExit(8);
#endif
   return(wMinRowsToRead);
}  /* end of PostSwathAdjust() */




int HiResPreSwathAdjust(LPDVDATAREC lpDataRec, FC_LONG lRow)
{
   int i,j; /* for loop indexes */
   WORD wNozzleCount;
   int nVertRes, nOut;
   int   nBufStart;
   BYTE  bSI;
   FC_LONG k,lRowStart;
   struct pf_data FAR *pfData;
   int      nScanIndex;
   WORD     wNozzle, wNozzleStart=0;
   WORD     wRowsToMove;

#ifdef CPROF
PrfEnter(5);
#endif
   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   nVertRes = pfData->nVertResMult;
   nOut     = pfData->nOut;

   for (i=pfData->nDelayBufStart;i<pfData->nDelayBufEnd;i++)
   {
      wNozzle = 0;
      wNozzleCount = pfData->wBaseNozzleCount + pfData->awExtraNozzles[i];
      bSI = pfData->abShingleIndex[i];


      lRowStart = (lRow - (FC_LONG)(pfData->alDBIndx[INIT_DELAY][i]*nVertRes) -
                  (FC_LONG)(wNozzleCount*nVertRes) + 1);
      if (lRowStart > pfData->lRowPos)
         continue;
      lRowStart = lRowStart % (FC_LONG)pfData->nMaxDelayBuf;
      nBufStart = (int) pfData->alDBIndx[nOut][i];

      for (j=nBufStart,k=lRowStart; k<lRowStart+(wNozzleCount*nVertRes); j++,k++)
      {

         nScanIndex = (int)(k%pfData->nMaxDelayBuf);

         if ( (wNozzle >= wNozzleCount) ||
              ((j % pfData->alDBIndx[BUFSIZE][i]) == pfData->alDBIndx[FC_IN][i]) ||
              (k > pfData->lRowPos) )
            break;
         if ( ((nOut == FC_OUT_EVEN) && (j%2)) ||
              ((nOut == FC_OUT_ODD) && (!(j%2))) )
            continue;
         if ( (j < 0) || (k < 0) ||
              (pfData->alpbShingleToApply[i][nScanIndex] == SHINGLE_THRU) )
         {
            wNozzle++;
            continue;
         }

         switch(pfData->alpbShingleToApply[i][nScanIndex])
         {
         case SHINGLE_0_1 :
         case SHINGLE_50_1 :
         case SHINGLE_25_1 :
         case SHINGLE_33_1 :
         case SHINGLE_16_1 :
            pfData->alpwShingleLine[i][nScanIndex] = wNozzle;
            break;
         }

         wNozzle++;
      }
      pfData->awRowsToPrint[i] = wNozzleCount*nVertRes;
   }

   if ((lpDataRec->bColorPlanes == 4) && (lpDataRec->bShingle == SHINGLE_50))
   {
      pfData->anDelayKSwath[nOut] = (pfData->anDelayKSwath[nOut] + 1) % 2;
      if (pfData->anDelayKSwath[nOut] == 1)
      {
         pfData->awRowsToPrint[3] = 0;
      }
   }

   if (lpDataRec->bShingle == NO_SHINGLE)
   {
      wRowsToMove = (WORD)pfData->wBaseNozzleCount;
   }
   else
   {
      wRowsToMove = (WORD)pfData->wBaseNozzleCount / 2;
   }
   if (nOut == FC_OUT_EVEN)
      wRowsToMove -= 3;
   else if (nOut == FC_OUT_ODD)
      wRowsToMove += 3;
/*   pfData->awRowsToDelayPrint[i] = 0; */

#ifdef CPROF
PrfExit(5);
#endif
   return(wRowsToMove);
}  /* end of HiResPreSwathAdjust() */




int HiResPostSwathAdjust(LPDVDATAREC lpDataRec, FC_LONG lRow)
{
   int i,j; /* for loop indexes */
   WORD wNozzleCount;
   int nVertRes, nOut;
   FC_LONG k,lRowStart;
   struct pf_data FAR *pfData;
   int      nBufStart;
   int      nScanIndex;
   WORD     wRowsToFree;

#ifdef CPROF
PrfEnter(8);
#endif
   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   nVertRes = pfData->nVertResMult;
   nOut     = pfData->nOut;

   for (i=pfData->nDelayBufStart;i<pfData->nDelayBufEnd;i++)
   {
      wNozzleCount = pfData->wBaseNozzleCount + pfData->awExtraNozzles[i];


      lRowStart = (lRow - (FC_LONG)(pfData->alDBIndx[INIT_DELAY][i]*nVertRes) -
                  (FC_LONG)(wNozzleCount*nVertRes) + 1);
      if (lRowStart > pfData->lRowPos)
         continue;
      lRowStart = lRowStart % (FC_LONG)pfData->nMaxDelayBuf;
      nBufStart = (int) pfData->alDBIndx[nOut][i];

      for (j=nBufStart,k=lRowStart; k<lRowStart+pfData->awRowsToPrint[i]; j++,k++)
      {
         if ( ((nOut == FC_OUT_EVEN) && (j%2)) ||
              ((nOut == FC_OUT_ODD) && (!(j%2))) )
         {
            continue;
         }

         if (pfData->alDBIndx[nOut][i] == pfData->alDBIndx[FC_IN][i])
         {
            break;
         }

         if ((j < 0) || (k < 0))
         {
            continue;
         }

         nScanIndex = (int)(k%pfData->nMaxDelayBuf);

         switch(pfData->alpbShingleToApply[i][nScanIndex])
         {
         case SHINGLE_THRU    :
            break;
         case SHINGLE_0_1  :
         case SHINGLE_50_2 :
         case SHINGLE_25_4 :
         case SHINGLE_33_3 :
         case SHINGLE_16_6 :
            pfData->alpbShingleToApply[i][nScanIndex] = SHINGLE_THRU;
            break;
         default :
            pfData->alpbShingleToApply[i][nScanIndex]++;
            break;
         }
      }  /* end of for (j=nBufStart,k=lRowStart...) */

      if ((lpDataRec->bColorPlanes == 4) && (i==3))
      {
         wRowsToFree = wNozzleCount / 3;
      }
      else if (lpDataRec->bShingle == NO_SHINGLE)
      {
         wRowsToFree = wNozzleCount;
      }
      else
      {
         wRowsToFree = wNozzleCount / 2;
      }

      if ((lpDataRec->bColorPlanes == 4) && (lpDataRec->bShingle == SHINGLE_50) && (i == 3))
      {
         if (pfData->anDelayKSwath[nOut] == 1)
         {
            wRowsToFree = 0;
         }
      }

      for (k=0; k<(int)(wRowsToFree*nVertRes); k++)
      {
         if ( pfData->alDBIndx[nOut][i] == pfData->alDBIndx[FC_IN][i])
            break;
         pfData->alDBIndx[nOut][i] = (pfData->alDBIndx[nOut][i]+1) %
                                     pfData->alDBIndx[BUFSIZE][i];

      }  /* end of for (j=nBufStart,k=lRowStart...) */
   }

   if (lpDataRec->bShingle == NO_SHINGLE)
   {
      wRowsToFree = (WORD)pfData->wBaseNozzleCount;
   }
   else
   {
      wRowsToFree = (WORD)pfData->wBaseNozzleCount / 2;
   }
#ifdef CPROF
PrfExit(8);
#endif
   return (wRowsToFree);
}  /* end of HiResPostSwathAdjust() */
