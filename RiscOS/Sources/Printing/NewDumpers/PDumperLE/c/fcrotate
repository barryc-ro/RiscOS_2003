/* fcrotate.c */

#include "common.h"

/***************************************************************************
 *  FCROTATE.C                                          Lexmark Confidential
 *
 * Function Name:    Rotate
 *
 * Description:
 *    This is the function that rotates raster lines into a print swath.
 *    It rotates the appropriate raster lines into the print swath.  It also
 *    applies the shingling mask, if one is required.  After creating the
 *    print swath, several pieces of information are added to the 26 byte
 *    print swath header, such as slice count, left margin, and right 
 *    margin.
 *
 * Inputs:  lpDataRec      Far pointer to HBP interface structure.
 *          nBuffers       Tells which buffers to use when building the print
 *                         swath, ie CMY, K, KCM.
 *
 * Outputs: int   number of lines moved down the page.  Positive number
 *                indicates there is a swath which needs to be printed.
 *                Negative number means the swath is empty, so move the
 *                page by int amount but don't print a swath.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/

int Rotate(LPDVDATAREC lpDataRec, int nBuffers)
{
	int i, j;													/* for loop indexes */
	unsigned short k;
	unsigned long kk;
	int nIStart, nIEnd, nShingleIndex, nNozzleCount;
	int nSeg, nIndx, nVertRes, nRastRes, nSwathRes, nOut, nRowsMoved;
	int nShingleSize;
	unsigned short wLeftMargin;
	unsigned short wShingle;
	unsigned long dwSwathWordOffset;
	unsigned long dwSwathByteOffset;
	int nSwathScanStart = 299, nSwathScanEnd = 0;
	unsigned char *pbPrtDat;

	unsigned char  *lpwSwathByte;
	unsigned short *lpwRaster;
	unsigned short wRasterWord;
	unsigned short wSwathScanStart, wSwathScanEnd;
	unsigned int wPrintMaskWord;
	unsigned short *lpwRastMask, *lpwRM, *lpwRMStart, *lpwRMEnd;
	int nColorOffset, nBegOut;
	int nKKInc, nSWInc, nNozzleGap, nSliceWord, nNozzleOffset;
	int nKCMOffset, nSwathSeg, nSwathOffset;
	int nVertAdj;
	unsigned char bBytesPerSlice;
	long alDotCount[6] = { 0, 0, 0, 0, 0, 0 };
	long lSwathDotCount = 0;
	BOOL fCDE, fCDEBoundary, fEmptySwath = TRUE, fShingled = TRUE;
	unsigned char bSwathDir;
	struct pf_data *pfData;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;

	pfData->lSwathDotCount = 0;									/* initialize to 0 */
	lpwRastMask = pfData->lpwRastMask;
	nVertRes = pfData->nVertResMult;
	nRastRes = pfData->nRastResMult;
	nSwathRes = pfData->nSwathResMult;
	wLeftMargin = pfData->wLeftMargin;
	pfData->wSliceCount = 0;
	nSwathScanStart = pfData->nPreRotateStart;
	nSwathScanEnd = pfData->nPreRotateEnd;
	wSwathScanStart = (unsigned short) pfData->nPreRotateStart / 2;
	wSwathScanEnd = (unsigned short) (pfData->nPreRotateEnd + 1) / 2;
	fCDE = pfData->fCDE;
	nRowsMoved = 0;

	switch (nBuffers)
	{
	case CMYPLANES:
		pfData->bPrintHead = COL_CARTRIDGE;
		pfData->wSliceCount += (unsigned short) (MAGENTA_OFFSET * nSwathRes);
		pfData->wSliceCount += (unsigned short) (COLOR_NOZZLE_OFFSET * nSwathRes);
		nIStart = 0;
		nIEnd = 3;
		pfData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
		nShingleIndex = CMY_SHINGLE_INDEX;
		nNozzleCount = pfData->nColorNozzleCount;
		nShingleSize = pfData->nColorShingleSize;
		nRowsMoved = pfData->nColorShingleSize;
		nNozzleGap = COLOR_NOZZLE_OFFSET;
		nVertAdj = 0;
		if (pfData->bShingle == NO_SHINGLE)
			fShingled = FALSE;
		break;
		
	case KCMPLANES:
		if (wLeftMargin)
			wLeftMargin -= (unsigned short) (KCM_HORZ_OFFSET * nSwathRes);
		pfData->bPrintHead = KCM_CARTRIDGE;
// pfData->bPrintHead = MONO_CARTRIDGE;
		pfData->wSliceCount += (unsigned short) (MAGENTA_OFFSET * nSwathRes);
		pfData->wSliceCount += (unsigned short) (COLOR_NOZZLE_OFFSET * nSwathRes);
		nIStart = 3;
		nIEnd = 6;
		pfData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
		nShingleIndex = CMY_SHINGLE_INDEX;
		nNozzleCount = pfData->nColorNozzleCount;
		nShingleSize = pfData->nColorShingleSize;
		nRowsMoved = pfData->nColorShingleSize;
		nNozzleGap = COLOR_NOZZLE_OFFSET;
		nVertAdj = 0;
		if (pfData->bShingle == NO_SHINGLE)
			fShingled = FALSE;
		break;
		
	case KPLANE:
		if (lpDataRec->bColorPlanes == 4)
		{
			/* CMYK print job */
			pfData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
			nRowsMoved = pfData->nColorShingleSize;
			if (pfData->bResolution == SUPERLOWRES)
				fShingled = FALSE;
			nVertAdj = (int) lpDataRec->bVerticalAdj;
		}
		else
		{
			/* K print job */
			if (pfData->bResolution == HIRES)
			{
				pfData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
				nVertAdj = (int) lpDataRec->bVerticalAdj;
			}
			else
			{
				pfData->bBytesPerSlice = K_BYTES_PER_SLICE;
				nVertAdj = 0;
			}
			nRowsMoved = pfData->nMonoShingleSize;
			if (pfData->bShingle == NO_SHINGLE)
				fShingled = FALSE;
		}
		pfData->bPrintHead = MONO_CARTRIDGE;
		pfData->wSliceCount += (unsigned short) (MONO_NOZZLE_OFFSET * nSwathRes);
		nIStart = 3;
		nIEnd = 4;
		nShingleIndex = K_SHINGLE_INDEX;
		nNozzleCount = pfData->nMonoNozzleCount;
		nShingleSize = pfData->nMonoShingleSize;
		nNozzleGap = MONO_NOZZLE_OFFSET;
		break;
#if 0
	case K6PLANE:
		pfData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
		pfData->bPrintHead = MONO_CARTRIDGE;
		pfData->wSliceCount += (unsigned short) (MONO_NOZZLE_OFFSET * nSwathRes);
		nIStart = 3;
		nIEnd = 4;
		nShingleIndex = K_SHINGLE_INDEX;
		nNozzleCount = pfData->nMonoNozzleCount;
		nShingleSize = pfData->nMonoShingleSize;
		nRowsMoved = pfData->nColorShingleSize;
		nNozzleGap = MONO_NOZZLE_OFFSET;
#if defined(EINSTEIN) || defined(MARCONI)
		if (pfData->bResolution == SUPERLOWRES)
			fShingled = FALSE;
#endif
		break;
	case K7PLANE:
		if (pfData->bResolution == HIRES)
			pfData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
		else
			pfData->bBytesPerSlice = K_BYTES_PER_SLICE;
		pfData->bPrintHead = MONO_CARTRIDGE;
		pfData->wSliceCount += (unsigned short) (MONO_NOZZLE_OFFSET * nSwathRes);
		nIStart = 3;
		nIEnd = 4;
		nShingleIndex = K_SHINGLE_INDEX;
		nNozzleCount = pfData->nMonoNozzleCount;
		nShingleSize = pfData->nMonoShingleSize;
		nRowsMoved = pfData->nMonoShingleSize;
		nNozzleGap = MONO_NOZZLE_OFFSET;
		if (pfData->bShingle == NO_SHINGLE)
			fShingled = FALSE;
		break;
#endif
	default:
#ifdef CPROF
		PrfExit(5);
#endif
		return (-nRowsMoved);
	}

	pfData->bPrintDirection = GetPrintDir(lpDataRec, nBuffers);
	bBytesPerSlice = pfData->bBytesPerSlice;

	nSwathScanStart = SliceSkip(nSwathScanStart, nSwathRes);
	nSwathScanEnd = SliceSkip(nSwathScanEnd, nSwathRes);
	pfData->nLeftPrintPos = RastertoPrintPos(nSwathScanStart, wLeftMargin);
	pfData->wSliceCount += (unsigned short) ((nSwathScanEnd - nSwathScanStart) * 8);
	pfData->nRightPrintPos = pfData->nLeftPrintPos + pfData->wSliceCount - 1;

	/* clear print swath */
	ClearPrintSwath(pfData);

	bSwathDir = CheckforReverseSwath(lpDataRec);

	if (bSwathDir == REVERSE)
	{

		/* If building swath backwards then rotate from the end */
		/* of the raster, not the begining */

		pfData->lpwRastMask[0] = RASTER_MASK15;
		pfData->lpwRastMask[1] = RASTER_MASK14;
		pfData->lpwRastMask[2] = RASTER_MASK13;
		pfData->lpwRastMask[3] = RASTER_MASK12;
		pfData->lpwRastMask[4] = RASTER_MASK11;
		pfData->lpwRastMask[5] = RASTER_MASK10;
		pfData->lpwRastMask[6] = RASTER_MASK9;
		pfData->lpwRastMask[7] = RASTER_MASK8;
		pfData->lpwRastMask[8] = RASTER_MASK7;
		pfData->lpwRastMask[9] = RASTER_MASK6;
		pfData->lpwRastMask[10] = RASTER_MASK5;
		pfData->lpwRastMask[11] = RASTER_MASK4;
		pfData->lpwRastMask[12] = RASTER_MASK3;
		pfData->lpwRastMask[13] = RASTER_MASK2;
		pfData->lpwRastMask[14] = RASTER_MASK1;
		pfData->lpwRastMask[15] = RASTER_MASK0;
	}
	else
	{

		pfData->lpwRastMask[0] = RASTER_MASK0;
		pfData->lpwRastMask[1] = RASTER_MASK1;
		pfData->lpwRastMask[2] = RASTER_MASK2;
		pfData->lpwRastMask[3] = RASTER_MASK3;
		pfData->lpwRastMask[4] = RASTER_MASK4;
		pfData->lpwRastMask[5] = RASTER_MASK5;
		pfData->lpwRastMask[6] = RASTER_MASK6;
		pfData->lpwRastMask[7] = RASTER_MASK7;
		pfData->lpwRastMask[8] = RASTER_MASK8;
		pfData->lpwRastMask[9] = RASTER_MASK9;
		pfData->lpwRastMask[10] = RASTER_MASK10;
		pfData->lpwRastMask[11] = RASTER_MASK11;
		pfData->lpwRastMask[12] = RASTER_MASK12;
		pfData->lpwRastMask[13] = RASTER_MASK13;
		pfData->lpwRastMask[14] = RASTER_MASK14;
		pfData->lpwRastMask[15] = RASTER_MASK15;

	}

	nOut = pfData->nOut;
	if (nOut == FC_OUT_EVEN)
		nRowsMoved -= 3;
	else if (nOut == FC_OUT_ODD)
		nRowsMoved += 3;

	/* For CMYK printing with 50% or 25% shingling, one K swath is built for
	 * every two CMY swaths.   */
	if ((nBuffers == KPLANE) && (lpDataRec->bColorPlanes == 4) && (pfData->bShingle != NO_SHINGLE))
	{
		pfData->anK6SwathDelay[nOut] = (pfData->anK6SwathDelay[nOut] + 1) % 2;
		if (pfData->anK6SwathDelay[nOut] == 1)
			return (-nRowsMoved);
	}

#if defined(EINSTEIN) || defined(MARCONI)
	if ((nBuffers == KPLANE) && (lpDataRec->bColorPlanes == 4) &&
			(pfData->bResolution == SUPERLOWRES))
	{
		pfData->anK6SwathDelay[nOut] = (pfData->anK6SwathDelay[nOut] + 1) % 3;
		if (pfData->anK6SwathDelay[nOut] != 0)
			return (-nRowsMoved);
	}
#endif

	for (i = nIStart; i < nIEnd; i++)
	{															/* Once for each plane of color */
		nBegOut = pfData->anDBIndx[nOut][i];

		for (j = 0; j < (nNozzleCount * nVertRes); j++)
		{														/* Once for each raster line in the color plane */

			if (pfData->anDBIndx[nOut][i] == pfData->anDBIndx[FC_IN][i])
				break;

			if (((nOut == FC_OUT_EVEN) && ((pfData->anDBIndx[nOut][i]) % 2)) ||
					((nOut == FC_OUT_ODD) && (!((pfData->anDBIndx[nOut][i]) % 2))) ||
					(pfData->anDBIndx[nOut][i] < 0) ||
					((nSwathScanEnd - nSwathScanStart) <= 0))
			{
				pfData->anDBIndx[nOut][i] = (pfData->anDBIndx[nOut][i] + 1) %
						pfData->anDBIndx[BUFSIZE][i];
				continue;
			}

			fCDEBoundary = FALSE;

			wShingle = pfData->awShingleMask[(nShingleIndex * MONO_NOZZLE_COUNT) + (j / nVertRes)];
			wPrintMaskWord = pfData->lpwPrtMask[((j / nVertRes) % 16)];

			if ((nBuffers == KPLANE) && (lpDataRec->bColorPlanes == 1) &&
					(pfData->bResolution != HIRES))
			{
				nSliceWord = Mono7SliceWord(i, nIStart, nIEnd, (j / nVertRes));
				wPrintMaskWord = pfData->lpwPrtMask[((j / nVertRes) % 16) + OddByteMaskAdjust(j / nVertRes)];
			}
			else if (nBuffers == K7PLANE)
				nSliceWord = Mono6SliceWord(i, nIStart, nIEnd, (j / nVertRes));
			else if (nBuffers == K6PLANE)
				nSliceWord = Mono6SliceWord(i, nIStart, nIEnd, (j / nVertRes));
			else if (nBuffers == KPLANE)
				nSliceWord = Mono6SliceWord(i, nIStart, nIEnd, (j / nVertRes));
			else
				nSliceWord = SliceWord(i, nIStart, nIEnd, (j / nVertRes));

			nColorOffset = ColorOffset(bSwathDir, i, MAGENTA_OFFSET, nSwathRes);

			nNozzleOffset = NozzleOffset(nVertAdj, (j / nVertRes),
					nNozzleGap, bBytesPerSlice, nSwathRes);
			if (nBuffers == KCMPLANES)
				nKCMOffset = KCMOffset((j / nVertRes), nSwathRes);
			else
				nKCMOffset = 0;

			nSeg = i + ((pfData->anDBIndx[nOut][i] / pfData->nRastersPerSeg) * MAXNUMPLANES);
			nIndx = (pfData->anDBIndx[nOut][i] % pfData->nRastersPerSeg);
			lpwRaster = pfData->alpwPlane[nSeg] + (nIndx * pfData->nWordsPerRow);

			if (bSwathDir == REVERSE)
			{
				/* If need to build print swath backwards then reverse the */
				/* words in the raster.  Reversing the bits within each word */
				/* is performed by switching the raster masks above */

				nNozzleOffset = ReverseNozzleOffset(j / nVertRes, nNozzleGap, bBytesPerSlice, nSwathRes);

				for (k = wSwathScanStart; k < wSwathScanEnd; k++)
					*(pfData->lpwReverseRaster + k) = *(lpwRaster + (wSwathScanStart + wSwathScanEnd - k - 1));

				lpwRaster = pfData->lpwReverseRaster;

			}

			nKKInc = pfData->bBytesPerSlice * 8;

			for (k = wSwathScanStart, kk = 0; k < wSwathScanEnd; k++, kk += nKKInc)
			{													/* Once for each word in the raster line */
				wRasterWord = *(lpwRaster + k);
				if (fShingled == TRUE)
					wRasterWord &= wShingle;
				if (wRasterWord == 0x0000)
					continue;

				if ((nBuffers == K7PLANE) && (pfData->bResolution != HIRES))
				{
					dwSwathWordOffset = (unsigned long) (SliceSkip(kk, nSwathRes) + nColorOffset + nNozzleOffset + nKCMOffset);
					dwSwathByteOffset = (unsigned long) dwSwathWordOffset *2 + nSliceWord;
				}
				else if ((nBuffers == KPLANE) && (lpDataRec->bColorPlanes == 1) && (pfData->bResolution != HIRES))
				{
					dwSwathWordOffset = (unsigned long) (SliceSkip(kk, nSwathRes) + nColorOffset + nNozzleOffset + nKCMOffset);
					dwSwathByteOffset = (unsigned long) dwSwathWordOffset *2 + nSliceWord;
				}
				else
				{
					dwSwathWordOffset = (unsigned long) (SliceSkip(kk, nSwathRes) + nSliceWord +
														nColorOffset + nNozzleOffset + nKCMOffset);
					dwSwathByteOffset = (unsigned long) dwSwathWordOffset *2;
				}

				nSwathSeg = (int) ((unsigned long) dwSwathByteOffset / ((unsigned long) SLICES_PER_SEG *
								(unsigned long) pfData->bBytesPerSlice));
				nSwathOffset = (int) ((unsigned long) dwSwathByteOffset % ((unsigned long) SLICES_PER_SEG *
								(unsigned long) pfData->bBytesPerSlice));
				pbPrtDat = (unsigned char *) pfData->alpbSwath[nSwathSeg];
				pbPrtDat += nSwathOffset;
				lpwSwathByte = pbPrtDat;

				lpwRMEnd = lpwRastMask + 16;
				nSWInc = SliceSkip((pfData->bBytesPerSlice), nSwathRes);

				if (fCDEBoundary)
					lpwRMStart = lpwRastMask + 1;
				else
					lpwRMStart = lpwRastMask;

				for (lpwRM = lpwRMStart; lpwRM < lpwRMEnd; lpwRM++)
				{												/* Once for each bit in the word */

					if (wRasterWord & *lpwRM)
					{
						lpwSwathByte[0] |= (wPrintMaskWord >> 0);
						lpwSwathByte[1] |= (wPrintMaskWord >> 8);
						alDotCount[i]++;
						if (fCDE)
						{
							lpwRM++;
#ifndef KELVIN
							// Seems to be causing extra slice dropout on word boundaries.
							// Needs to be investigated.
							
							fCDEBoundary = TRUE;
#endif
						}
						else
							fCDEBoundary = FALSE;
					}
					lpwSwathByte += nSWInc;
				}												/* Once for each bit in the word */
			}													/* Once for each word in the raster line */
			pfData->anDBIndx[nOut][i] = (pfData->anDBIndx[nOut][i] + 1) %
					pfData->anDBIndx[BUFSIZE][i];
		}														/* Once for each raster line in the color plane */

		if ((fShingled == TRUE) && (nBegOut != pfData->anDBIndx[FC_IN][i]))
		{														/* adjust OUT index to account for shingling */
			pfData->anDBIndx[nOut][i] = nBegOut;
			for (j = 0; j < (nShingleSize * nVertRes); j++)
			{
				pfData->anDBIndx[nOut][i] = (pfData->anDBIndx[nOut][i] + 1) %
						pfData->anDBIndx[BUFSIZE][i];
				if (pfData->anDBIndx[nOut][i] == pfData->anDBIndx[FC_IN][i])
					break;
			}
		}														/* adjust OUT index to account for shingling */
	}															/* Once for each plane of color */

	for (i = nIStart; i < nIEnd; i++)
	{
		/* check to see if any dots were added to print swath */
		if (alDotCount[i] != 0)
		{
			fEmptySwath = FALSE;
			pfData->alDotCount[i] += alDotCount[i];
			lSwathDotCount += alDotCount[i];
		}

	}

	if ((fEmptySwath) || ((nSwathScanEnd - nSwathScanStart) <= 0))
		return (-nRowsMoved);									/* empty swath */

	pfData->lSwathDotCount = lSwathDotCount;
	return (nRowsMoved);
}

/***************************************************************************
 *  FCROTATE.C                                          Lexmark Confidential
 *
 * Function Name:    SwathMargins
 *
 * Description:
 *    Determines the narrowest margins possible for the current print
 *    swath.  Considers the left and right margins for each raster line
 *    that will be used to help create the current print swath.
 *
 * Inputs:  lpDataRec      Far pointer to HBP interface structure.
 *          lRow           helps synchronize the delay buffers with the
 *                         margins buffer.
 *
 * Outputs: stores swath left margin in pfData->nPreRotateStart.  Stores
 *          swath right margin in pfData->nPreRotateEnd.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void SwathMargins(LPDVDATAREC lpDataRec, int nBuffers, long lRow)
{
	int i, j, m;												/* for loop indexes */
	int nIStart, nIEnd, nNozzleCount;
	int nVertRes, nSeg, nIndx, nOut, nRowDelay;
	int nBufStart;
	long k, lRowStart;
	int nRasterScanStart, nRasterScanEnd, nEvenOdd;
	int nSwathScanStart, nSwathScanEnd;
	unsigned short *lpwRaster;
	struct pf_data *pfData;

#ifdef CPROF
	PrfEnter(5);
#endif
	pfData = (struct pf_data *) lpDataRec->lpLXDevice;

	pfData->nPreRotateStart = pfData->nBytesPerRow - 1;
	pfData->nPreRotateEnd = 0;

	nSwathScanStart = pfData->nBytesPerRow;
	nSwathScanEnd = 0;

	switch (nBuffers)
	{
	case CMYPLANES:
		nIStart = 0;
		nIEnd = 3;
		nRowDelay = pfData->nColorNozzleCount;
		pfData->bPreRotatePrintHead = COL_CARTRIDGE;
		nNozzleCount = pfData->nColorNozzleCount;
		break;
	case KCMPLANES:
		nIStart = 3;
		nIEnd = 6;
		nRowDelay = pfData->nColorNozzleCount;
		pfData->bPreRotatePrintHead = MONO_CARTRIDGE;
		nNozzleCount = pfData->nColorNozzleCount;
		break;
	case KPLANE:
		nIStart = 3;
		nIEnd = 4;
		if (lpDataRec->bColorPlanes == 4)
			nRowDelay = pfData->nColorNozzleCount;
		else
			nRowDelay = pfData->nMonoNozzleCount;
		pfData->bPreRotatePrintHead = MONO_CARTRIDGE;
		nNozzleCount = pfData->nMonoNozzleCount;
		break;
	case K6PLANE:
		nIStart = 3;
		nIEnd = 4;
		nRowDelay = pfData->nColorNozzleCount;
		pfData->bPreRotatePrintHead = MONO_CARTRIDGE;
		nNozzleCount = pfData->nMonoNozzleCount;
		break;
	case K7PLANE:
		nIStart = 3;
		nIEnd = 4;
		nRowDelay = pfData->nMonoNozzleCount;
		pfData->bPreRotatePrintHead = MONO_CARTRIDGE;
		nNozzleCount = pfData->nMonoNozzleCount;
		break;
	default:
#ifdef CPROF
		PrfExit(5);
#endif
		return;
	}

	pfData->bPreRotateDir = GetPrintDir(lpDataRec, nBuffers);
	nVertRes = pfData->nVertResMult;

	nOut = pfData->nOut;

	/* For the raster lines involved in this print swath, determine the  */
	/* smallest left margin (ScanStart) and the largest right margin     */
	/* (ScanEnd).  These will determine the size and horizontal position */
	/* of the print swath created.                                       */
	for (i = nIStart; i < nIEnd; i++)
	{
		lRowStart = (lRow - (long) pfData->anDBIndx[INIT_DELAY][i] * (long) nVertRes -
				(long) nNozzleCount * (long) nVertRes + 1);
		if (lRowStart > pfData->lRowPos)
			continue;
		lRowStart = lRowStart % (long) pfData->nMaxDelayBuf;
		nBufStart = (int) pfData->anDBIndx[nOut][i];
		for (j = nBufStart, k = lRowStart; j < (nBufStart + (nNozzleCount * nVertRes)); j++, k++)
		{
			if ((j % pfData->anDBIndx[BUFSIZE][i]) == pfData->anDBIndx[FC_IN][i])
				break;
			if ((j < 0) || (k < 0))
				continue;
			if ((nOut == FC_OUT_EVEN) && (j % 2))
				continue;
			if ((nOut == FC_OUT_ODD) && (!(j % 2)))
				continue;

			nSeg = i + (((j % pfData->anDBIndx[BUFSIZE][i]) / pfData->nRastersPerSeg) *
					MAXNUMPLANES);
			nIndx = ((j % pfData->anDBIndx[BUFSIZE][i]) % pfData->nRastersPerSeg);
			lpwRaster = pfData->alpwPlane[nSeg] + ((nIndx % pfData->anDBIndx[BUFSIZE][i])
					* pfData->nWordsPerRow);

			nRasterScanStart = pfData->anScanStart[(k % pfData->nMaxDelayBuf)];
			nRasterScanEnd = pfData->anScanEnd[(k % pfData->nMaxDelayBuf)];

			for (m = (nRasterScanStart / 2); m < ((nRasterScanEnd + 1) / 2); m++)
				if (lpwRaster[m] != 0x0000)
					break;
			nRasterScanStart = m * 2;

			if (nRasterScanStart < nSwathScanStart)
				nSwathScanStart = nRasterScanStart;

			nEvenOdd = 1;
			for (m = ((nRasterScanEnd - 1) / 2); m >= (nSwathScanStart / 2); m--)
				if (lpwRaster[m] != 0x0000)
				{
					/* Now decide if the entire word contains data, or just the */
					/* first byte.  Get HIBYTE instead of LOBYTE because of     */
					/* intel byte ordering in words */
// bOddByte = HIBYTE((lpwRaster[m]));
					//               if (bOddByte == 0x00)
					//                  nEvenOdd = 1;
					//               else
					//                  nEvenOdd = 2;
					break;
				}
// nRasterScanEnd = (m * 2) + nEvenOdd;
			nRasterScanEnd = (m * 2) + 2;

			if (nRasterScanEnd > nSwathScanEnd)
				nSwathScanEnd = nRasterScanEnd;
		}
	}

	pfData->nPreRotateStart = nSwathScanStart;
	pfData->nPreRotateEnd = nSwathScanEnd;
}
