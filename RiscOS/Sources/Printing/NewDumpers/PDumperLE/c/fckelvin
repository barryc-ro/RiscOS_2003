/* fckelvin.c */

#include "common.h"
#ifdef TEXTPRINT
#include "wedge.h"
#endif

#ifdef GEN_COL_BIDI
unsigned char bNumBidiSwaths;

#endif

/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name:    OutToFile
 *
 * Description:
 *    This function outputs print swath data into a file.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to file.
 *
 * Major Functions Called:  fwrite
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void OutToFile(LPDVDATAREC lpDataRec, void *pOutString, unsigned long dwLength)
{
	_kernel_swi_regs r;

//	kelvin_trace3("Sending %d bytes to file handle %d (%p)\n", dwLength, lpDataRec->flOutFile, lpDataRec);

	r.r[0] = 2;
	r.r[1] = (int) lpDataRec->flOutFile;

#ifdef TEXTPRINT
	if (wedge_getcooked())
	{
		unsigned char esc[] = { 27, '%', 0, 0, 0 };
		esc[2] = (dwLength >>  0) & 0xFF;
		esc[3] = (dwLength >>  8) & 0xFF;
		esc[4] = (dwLength >> 16) & 0xFF;
		r.r[2] = (int) esc;
		r.r[3] = 5;
		THROW(_kernel_swi(OS_GBPB, &r, &r));
	}
#endif

	r.r[2] = (int) pOutString;
	r.r[3] = (int) dwLength;

	THROW(_kernel_swi(OS_GBPB, &r, &r));
}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    HwStartPrintJob
 *
 * Description:
 *    This function is called at the beginning of a document and
 *    can send the printer any required information for the
 *    job start.  Some printers may not require any special
 *    data to be sent.  The printer specific hardware structure
 *    is also initialized here.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void HwStartPrintJob(LPDVDATAREC lpDataRec)
{
	struct pf_data *pfData;
	struct tHwData *lpHwData;
	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;

	lpCmd = abPrinterCmd;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	if (pfData != NULL)
		lpHwData = pfData->lpHwData;
	else
		return;

	/* Clear hardware data arrays */

	MEMSET(lpHwData->bCarrRampTableData, 0x00, MAX_CARRIER_RAMP_SIZE);
	MEMSET(lpHwData->bPaperRampTableData, 0x00, MAX_PAPER_RAMP_SIZE);
	MEMSET(lpHwData->bPaperRampTableType, 0x00, MAX_RAMP_TABLE_CNT);

// kelvin_traceout ("HwDataArrays Cleared called\n");

	/* Init Hw data stucture */
#if defined(DOS_BUILD) || defined(__riscos)
	lpHwData->bTestPrintDir = LTOR;
#endif
	lpHwData->bInstallCartridge = FALSE;
	lpHwData->bMonoFirePulse = MONO_FIRE_PULSE;
	lpHwData->bColorFirePulse = COLOR_FIRE_PULSE;
	lpHwData->bHomeStepCnt = HOME_POSITION_STEP_CNT;
	lpHwData->wPaperLoadStepCntA = PAPER_LOAD_STEP_CNT_A;
	lpHwData->wPaperLoadStepCntB = PAPER_LOAD_STEP_CNT_B;
	lpHwData->wPaperEjectStepCnt = PAPER_EJECT_STEP_CNT;
	lpHwData->wManualFeedStepCnt = MANUAL_FEED_STEP_CNT;
	lpHwData->bPaperRampTableSpeed = 0;
	lpHwData->wPaperRampSRAMOffset = PAP_RAMP_SRAM_OFFSET;
	lpHwData->wPaperRampTableLength = MAX_PAPER_RAMP_SIZE;
	lpHwData->bAccelStepCnt3 = ACCEL_STEP_9IPS;
	lpHwData->bAlphaStepCnt3 = ALPHA_STEP_9IPS;
	lpHwData->bDecelStepCnt3 = DECEL_STEP_9IPS;
	lpHwData->wDecelOffsetAddr3 = DECEL_OFFSET_9IPS;
	lpHwData->bAccelStepCnt16 = ACCEL_STEP_16IPS;
	lpHwData->bAlphaStepCnt16 = ALPHA_STEP_16IPS;
	lpHwData->bDecelStepCnt16 = DECEL_STEP_16IPS;
	lpHwData->wDecelOffsetAddr16 = DECEL_OFFSET_16IPS;
	lpHwData->bAccelStepCnt25 = ACCEL_STEP_25IPS;
	lpHwData->bAlphaStepCnt25 = ALPHA_STEP_25IPS;
	lpHwData->bDecelStepCnt25 = DECEL_STEP_25IPS;
	lpHwData->wDecelOffsetAddr25 = DECEL_OFFSET_25IPS;
	lpHwData->wCarrRampSRAMOffset = CAR_RAMP_SRAM_OFFSET;
	lpHwData->wCarrRampTableLength = MAX_CARRIER_RAMP_SIZE;
	lpHwData->wPrintSRAMOffset = PRINT_SRAM_OFFSET;
	lpHwData->bPrtCarrDirection = NO_DIRECTION;
	lpHwData->wPrtStartPosition = 0;
	lpHwData->wPrtCarrStopPosition = 0;
	lpHwData->wPrtCarrStartPosition = 0;
	lpHwData->bPrtCarrSpeed = STOPPED;
	lpHwData->bPosCarrDirection = NO_DIRECTION;
	lpHwData->wPosCarrStopPosition = 0;
	lpHwData->wPosCarrStartPosition = 0;
	lpHwData->bPosCarrSpeed = STOPPED;
	lpHwData->wCurrCarrPos = LEFT_SIDE_FRAME_POSITION;
	lpHwData->wColorHeadOffset = COLOR_POS_OFFSET;
	lpHwData->wMonoHeadOffset = MONO_POS_OFFSET;

#ifdef BIDI_ALIGN
	lpHwData->nMonoLeftBidiAlign = lpDataRec->nLeftBidiAlignMono;
	lpHwData->nMonoRightBidiAlign = lpDataRec->nRightBidiAlignMono;
	lpHwData->nColorLeftBidiAlign = lpDataRec->nLeftBidiAlignColor;
	lpHwData->nColorRightBidiAlign = lpDataRec->nRightBidiAlignColor;
#else
	lpHwData->nMonoLeftBidiAlign = MONO_LEFT_BIDI_ALIGN;
	lpHwData->nMonoRightBidiAlign = MONO_RIGHT_BIDI_ALIGN;
	lpHwData->nColorLeftBidiAlign = COLOR_LEFT_BIDI_ALIGN;
	lpHwData->nColorRightBidiAlign = COLOR_RIGHT_BIDI_ALIGN;
#endif

	/* Init and send HW values from external files if they exist */
	if (ParseHwFile(pfData->lpHwData))
	{

#ifndef DOS_BUILD
// kelvin_traceout ("Using Data From elctable.dat and/or elcpara.txt\n");
#endif

		*(lpCmd + 0) = SET_INIT_1_CMD;
		*(lpCmd + 1) = HIBYTE(lpHwData->wPaperLoadStepCntA);
		*(lpCmd + 2) = LOBYTE(lpHwData->wPaperLoadStepCntA);
		*(lpCmd + 3) = HIBYTE(lpHwData->wPaperLoadStepCntB);
		*(lpCmd + 4) = LOBYTE(lpHwData->wPaperLoadStepCntB);
		*(lpCmd + 5) = HIBYTE(lpHwData->wManualFeedStepCnt);
		*(lpCmd + 6) = LOBYTE(lpHwData->wManualFeedStepCnt);

		OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

		/* send fire pulse to printer */

		*(lpCmd + 0) = SET_INIT_2_CMD;
		*(lpCmd + 1) = lpHwData->bHomeStepCnt;
		*(lpCmd + 2) = HIBYTE(lpHwData->wPaperEjectStepCnt);
		*(lpCmd + 3) = LOBYTE(lpHwData->wPaperEjectStepCnt);
		*(lpCmd + 4) = lpHwData->bMonoFirePulse;
		*(lpCmd + 5) = lpHwData->bColorFirePulse;
		*(lpCmd + 6) = 0x00;

		OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

		SendPaperRampTables(lpDataRec);
		SendCarrierRampTables(lpDataRec);
	}

	lpHwData->wPrintSRAMOffset = 0x00;
	lpHwData->bPrtCarrDirection = NO_DIRECTION;
	lpHwData->wPrtStartPosition = 0;
	lpHwData->wPrtCarrStopPosition = 0;
	lpHwData->wPrtCarrStartPosition = 0;
	lpHwData->bPrtCarrSpeed = STOPPED;
	lpHwData->bPosCarrDirection = NO_DIRECTION;
	lpHwData->wPosCarrStopPosition = 0;
	lpHwData->wPosCarrStartPosition = 0;
	lpHwData->bPosCarrSpeed = STOPPED;
	lpHwData->wCurrCarrPos = LEFT_SIDE_FRAME_POSITION;

#if 0

	kelvin_trace1("Accel 3 = %d\n", (int) lpHwData->bAccelStepCnt3);
	kelvin_trace1("Alpha 3 = %d\n", (int) lpHwData->bAlphaStepCnt3);
	kelvin_trace1("Decel 3 = %d\n", (int) lpHwData->bDecelStepCnt3);

	kelvin_trace1("Accel 16 = %d\n", (int) lpHwData->bAccelStepCnt16);
	kelvin_trace1("Alpha 16 = %d\n", (int) lpHwData->bAlphaStepCnt16);
	kelvin_trace1("Decel 16 = %d\n", (int) lpHwData->bDecelStepCnt16);

	kelvin_trace1("Accel 25 = %d\n", (int) lpHwData->bAccelStepCnt25);
	kelvin_trace1("Alpha 25 = %d\n", (int) lpHwData->bAlphaStepCnt25);
	kelvin_trace1("Decel 25 = %d\n", (int) lpHwData->bDecelStepCnt25);

	kelvin_trace1("MonoLeftBidiAlign = %d\n", lpHwData->nMonoLeftBidiAlign);
	kelvin_trace1("MonoRightBidiAlign = %d\n", lpHwData->nMonoRightBidiAlign);
	kelvin_trace1("ColorLeftBidiAlign = %d\n", lpHwData->nColorLeftBidiAlign);
	kelvin_trace1("ColorRightBidiAlign = %d\n", lpHwData->nColorRightBidiAlign);

#endif

	return;
}

void SendPaperRampTables(LPDVDATAREC lpDataRec)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;
	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;
	int i;

	lpCmd = abPrinterCmd;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	/* Output feed motor accel/decel table information command */
	*(lpCmd + 0) = FEED_ACCEL_DECEL_CMD;
	for (i = 1; i < COMMAND_SIZE; i++)
	{
		*(lpCmd + i) = lpHwData->bPaperRampTableType[i - 1];
	}

	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

	/* Clear command data */
	MEMSET(lpCmd, 0x00, COMMAND_SIZE);

	/* Output feed motor accel/decel table data command */
	*(lpCmd + 0) = FEED_RAMP_CMD;
	*(lpCmd + 1) = HIBYTE(lpHwData->wPaperRampSRAMOffset);
	*(lpCmd + 2) = LOBYTE(lpHwData->wPaperRampSRAMOffset);
	*(lpCmd + 3) = HIBYTE(lpHwData->wPaperRampTableLength);
	*(lpCmd + 4) = LOBYTE(lpHwData->wPaperRampTableLength);

	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

	lpCmd = lpHwData->bPaperRampTableData;

	/* Now output the actual paper ramp data */
	OUTPUT(lpDataRec, lpCmd, lpHwData->wPaperRampTableLength);

}

void SendCarrierRampTables(LPDVDATAREC lpDataRec)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;
	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;

	lpCmd = abPrinterCmd;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	*(lpCmd + 0) = CARR_ACCEL_DECEL_CMD;
	*(lpCmd + 1) = DATA_OFFSET_9IPS;
	*(lpCmd + 2) = lpHwData->bAccelStepCnt3;
	*(lpCmd + 3) = lpHwData->bDecelStepCnt3;
	*(lpCmd + 4) = HIBYTE(lpHwData->wDecelOffsetAddr3);
	*(lpCmd + 5) = LOBYTE(lpHwData->wDecelOffsetAddr3);

	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

	*(lpCmd + 0) = CARR_ACCEL_DECEL_CMD;
	*(lpCmd + 1) = DATA_OFFSET_16IPS;
	*(lpCmd + 2) = lpHwData->bAccelStepCnt16;
	*(lpCmd + 3) = lpHwData->bDecelStepCnt16;
	*(lpCmd + 4) = HIBYTE(lpHwData->wDecelOffsetAddr16);
	*(lpCmd + 5) = LOBYTE(lpHwData->wDecelOffsetAddr16);

	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

	*(lpCmd + 0) = CARR_ACCEL_DECEL_CMD;
	*(lpCmd + 1) = DATA_OFFSET_25IPS;
	*(lpCmd + 2) = lpHwData->bAccelStepCnt25;
	*(lpCmd + 3) = lpHwData->bDecelStepCnt25;
	*(lpCmd + 4) = HIBYTE(lpHwData->wDecelOffsetAddr25);
	*(lpCmd + 5) = LOBYTE(lpHwData->wDecelOffsetAddr25);

	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

	*(lpCmd + 0) = CARR_RAMP_CMD;
	*(lpCmd + 1) = HIBYTE(lpHwData->wCarrRampSRAMOffset);
	*(lpCmd + 2) = LOBYTE(lpHwData->wCarrRampSRAMOffset);
	*(lpCmd + 3) = HIBYTE(lpHwData->wCarrRampTableLength);
	*(lpCmd + 4) = LOBYTE(lpHwData->wCarrRampTableLength);
	*(lpCmd + 5) = 0x00;

	/* Now send the control codes and the ramp table data to the printer */
	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

	lpCmd = lpHwData->bCarrRampTableData;

	OUTPUT(lpDataRec, lpCmd, lpHwData->wCarrRampTableLength);

}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    HwStartPage
 *
 * Description:
 *    This function is called at the beginning of a page and
 *    can send the printer any required information for the
 *    page start.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void HwStartPage(LPDVDATAREC lpDataRec)
{

	FcFormFeed(lpDataRec);

	ResetHeadMaintenance(lpDataRec);

	/* sync up with carrier position so send it home */
	FCSendCartridgeHome(lpDataRec);

	SendMaintenanceCmd(lpDataRec, BETWEEN_PAGE_SPIT_CNT, BETWEEN_PAGE_WIPE_CNT);
	UpdatePageDotCount(lpDataRec, BETWEEN_PAGE_SPIT_CNT);

#ifdef GEN_COL_BIDI
	bNumBidiSwaths = 0;
#endif

	LineFeed(lpDataRec);										/* for top margin */
}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    HwStartPage
 *
 * Description:
 *    This function is called at the end of a page and
 *    can send the printer any required information for the
 *    page end.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void HwEndPage(LPDVDATAREC lpDataRec)
{

	FCSendCartridgeHome(lpDataRec);
	FCEjectPage(lpDataRec);

#ifdef DEBUG_MAINT
	{
		unsigned char n;
		struct pf_data *pfData;

		pfData = (struct pf_data *) lpDataRec->lpLXDevice;

		for (n = 0; n < MAX_NUM_INKS; n++)
			kelvin_trace2("End Page Dot Count pfData->alDotCount[%1d] = %10ld\n", n,
					pfData->alDotCount[n]);

	}
#endif

}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    HwEndJob
 *
 * Description:
 *    This function is called at the end of a job and
 *    can send the printer any required information for the
 *    job end.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void HwEndJob(LPDVDATAREC lpDataRec)
{
	/* Silence the compiler */
	lpDataRec = lpDataRec;
	return;
}

/***************************************************************************
 *  FCKELVIN.C                                     Lexmark Confidential
 *
 * Function Name:    OutputSwath
 *
 * Description:
 *    This function is responsible for everything that needs to
 *    happen when one swath buffer is sent to the printer for
 *    printing.  Linefeed is called to move the paper to the
 *    correct position for the swath followed by the swath
 *    data.
 *
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/

void OutputSwath(LPDVDATAREC lpDataRec)
{
	struct pf_data *pfData;
	struct tPrintCmd *pPrtCmd;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	pPrtCmd = (struct tPrintCmd *) pfData->pPrtCmd;

	LineFeed(lpDataRec);										/* for top margin */

	if (IsCarrierInMaintStation(lpDataRec) == TRUE)
	{
		SendMaintenanceCmd(lpDataRec, UNCAP_SPIT_CNT, UNCAP_WIPE_CNT);
		UpdatePageDotCount(lpDataRec, UNCAP_SPIT_CNT);
	}

	/*
	 * Calculate where the carrier needs to be to start printing
	 * and output the command to move the carrier to the
	 *  correct posiiton.
	 */

	CalcCarrierPositions(lpDataRec, FALSE);
	PositionCarrierForPrint(lpDataRec);

	/*
	 *  Now check the next swath positions to be printed
	 *  and append any distance required to setup for the
	 *  next swath to the print stop position.
	 */

	CalculateAppendDistance(lpDataRec);

	/* Send the swath data to the printer */
	OutputSwathInfo(lpDataRec);

	/* Now calculate the return move so the carrier is in position for the
	 * next swath */

	CalcCarrierPositions(lpDataRec, TRUE);

	SetupPrinterForNextSwath(lpDataRec);
	OutputPrintSliceData(lpDataRec);

	PerformPrintMaintenance(lpDataRec);

}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    OutputSwathInfo
 *
 * Description:
 *    This function outputs the swath data and buffer to the
 *    printer in the expected format.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void OutputSwathInfo(LPDVDATAREC lpDataRec)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;
	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{SWATH_INFO_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;
	unsigned short wNumCarrStep;
	unsigned char bDir;
	unsigned char bPrintSpeed;
	unsigned char bMonoHead;
	unsigned char bRes;
	unsigned char bSliceBytes;
	int nPrintPos;
	int nPrintOffset;

	lpCmd = abPrinterCmd;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	if (pfData->bPrintHead == MONO_CARTRIDGE)
	{
		bMonoHead = MONO_HEAD;
		nPrintOffset = (MONO_NOZZLE_OFFSET * pfData->nSwathResMult);
	}
	else
	{
		bMonoHead = COLOR_HEAD;
		nPrintOffset = (COLOR_NOZZLE_OFFSET * pfData->nSwathResMult);
	}

	if ((pfData->bResolution == LORES) || (pfData->bResolution == SUPERLOWRES))
		bRes = NORMAL_RES_300;
	else
		bRes = HIGH_RES_600;

	if (pfData->bBytesPerSlice == 6)
		bSliceBytes = BYTES_6;
	else
		bSliceBytes = BYTES_7;

	if (pfData->bPrintQuality == QUALITY_DRAFT)
		bPrintSpeed = PRINT_DRAFT;
// bPrintSpeed = CAR_MOVE_25;
	else
	{
		bPrintSpeed = PRINT_LQ;

#ifdef GEN_BIDI
		bPrintSpeed = PRINT_DRAFT;
// bPrintSpeed = PRINT_LQ;
#endif

// kelvin_traceout ("SwathInfo LQ Speed\n");
	}
// bPrintSpeed = CAR_MOVE_16;

	if (lpHwData->bPrtCarrDirection == RIGHT)
		bDir = FORWARD_PRINT;
	else
		bDir = REVERSE_PRINT;

	*(lpCmd + 1) = (unsigned char) (bMonoHead | bRes | bSliceBytes | bPrintSpeed | bDir);
// *(lpCmd+1) = (unsigned char) ( bPrintSpeed | bDir);

	*(lpCmd + 2) = HIBYTE(pfData->wSliceCount);
	*(lpCmd + 3) = LOBYTE(pfData->wSliceCount);

	/*
	 * This is a print move to move the carrier to print
	 * the swath.  Therefore, the PrtCarr variables contain
	 * the correct start and stop positions for
	 * the carrier.
	 */

	wNumCarrStep = CalcConstantSteps(lpDataRec,
			lpHwData->wCurrCarrPos, lpHwData->wPrtCarrStopPosition,
			lpHwData->bPrtCarrSpeed, lpHwData->bPrtCarrDirection);

// kelvin_trace1("SwathInfo NumSteps = %x\n", wNumCarrStep);

	*(lpCmd + 4) = HIBYTE(wNumCarrStep);
	*(lpCmd + 5) = LOBYTE(wNumCarrStep);

	if (lpHwData->bPrtCarrDirection == LEFT)
	{
		nPrintPos = PrintPos(pfData->bResolution, pfData->bPrintHead,
				pfData->nRightPrintPos, NO_DIRECTION);

#ifndef GEN_COL_BIDI
		if (pfData->bPrintDirection == BIDI)
#endif
			nPrintPos += GetBidiAlign(lpHwData, RIGHT, pfData->bPrintHead);

// kelvin_trace1("Right Print Pos in Swath Info  = %x\n", (nPrintPos/4));
	}
	else
	{
		nPrintPos = PrintPos(pfData->bResolution, pfData->bPrintHead,
				pfData->nLeftPrintPos, NO_DIRECTION);

#ifndef GEN_COL_BIDI
		if (pfData->bPrintDirection == BIDI)
#endif
			nPrintPos += GetBidiAlign(lpHwData, LEFT, pfData->bPrintHead);

// kelvin_trace1("Left Print Pos in Swath Info  = %x\n", (nPrintPos/4));

	}

// kelvin_trace1("600 Slice Cnt / 4 = %x\n", (pfData->wSliceCount/4));

// kelvin_trace1("Left Print Pos = %x\n", (pfData->nLeftPrintPos/2));
	//     kelvin_trace1("Right Print Pos = %x\n", (pfData->nRightPrintPos/2));

	*(lpCmd + 6) = HIBYTE(nPrintPos);
	*(lpCmd + 7) = LOBYTE(nPrintPos);

	/* temporary for debug */
#if 0
	*(lpCmd + 0) = CARRIER_MOVE_CMD;
	*(lpCmd + 2) = HIBYTE(wNumCarrStep);
	*(lpCmd + 3) = LOBYTE(wNumCarrStep);
	*(lpCmd + 4) = 0x00;
	*(lpCmd + 5) = 0x00;
	*(lpCmd + 6) = 0x00;
	*(lpCmd + 7) = 0x00;
#endif
	lpHwData->bPrtCarrDirection = NO_DIRECTION;
	lpHwData->wPrtCarrStartPosition = 0;
	lpHwData->wPrtCarrStopPosition = 0;
	lpHwData->bPrtCarrSpeed = STOPPED;

	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

// kelvin_trace1("After Swath Info Carrier Pos = %x\n", (lpHwData->wCurrCarrPos/4));

}

void SetupPrinterForNextSwath(LPDVDATAREC lpDataRec)
{
	struct pf_data *pfData;
	struct tHwData *lpHwData;
	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{CARRIER_RETURN_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;

	unsigned short wNumCarrStep, wVertMove;
	unsigned char bDir, bSpeed;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;
	lpCmd = abPrinterCmd;

// kelvin_traceout ("**************************************************************\n\n\n");
	if (lpHwData->bPosCarrDirection == RIGHT)
	{
// kelvin_traceout ("Next Swath RIGHT MOVE\n");
		bDir = FORWARD_CAR_RETURN;
	}
	else
	{
// kelvin_traceout ("Next Swath LEFT MOVE\n");
		bDir = REVERSE_CAR_RETURN;
	}

	if (lpHwData->bPosCarrSpeed == QUALITY_DRAFT)
		bSpeed = RETURN_MOVE_25;
	else
	{
		bSpeed = RETURN_MOVE_16;
// kelvin_traceout ("Next SwathInfo LQ Speed\n");
	}

	*(lpCmd + 1) = (unsigned char) (bDir | bSpeed | RETURN_FEED_NORMAL);

	/*
	 * This is a return move to position carrier for next
	 * swath.   Therefore, the PosCarr variables contain
	 * the correct start and stop positions to position
	 * the carrier.
	 */

	if (lpHwData->bPosCarrSpeed != STOPPED)

		wNumCarrStep = CalcConstantSteps(lpDataRec,
				lpHwData->wCurrCarrPos, lpHwData->wPosCarrStopPosition,
				lpHwData->bPosCarrSpeed, lpHwData->bPosCarrDirection);
	else
		wNumCarrStep = 0;

// kelvin_trace1("Next SwathInfo NumSteps = %x\n", wNumCarrStep);

	*(lpCmd + 2) = HIBYTE(wNumCarrStep);
	*(lpCmd + 3) = LOBYTE(wNumCarrStep);

	wVertMove = (unsigned short) pfData->nFormsMovePending;

	/* printer needs vertical moves in 1/300" units */
	if (pfData->bResolution == LORES)
		wVertMove *= 2;
	*(lpCmd + 4) = HIBYTE(wVertMove);
	*(lpCmd + 5) = LOBYTE(wVertMove);

	/* Reset the variables */

	pfData->nFormsMovePending = 0;
	lpHwData->bPosCarrDirection = NO_DIRECTION;
	lpHwData->wPosCarrStartPosition = 0;
	lpHwData->wPosCarrStopPosition = 0;
	lpHwData->bPosCarrSpeed = STOPPED;

	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

// kelvin_trace1("After Next Swath Info Carrier Pos = %x\n", (lpHwData->wCurrCarrPos/4));
	//   kelvin_traceout ("**************************************************************\n\n\n");
}

void OutputPrintSliceData(LPDVDATAREC lpDataRec)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;
	struct tPrintCmd *pPrtCmd;
	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{SWATH_DATA_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;
	unsigned short wSize;

	lpCmd = abPrinterCmd;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;
	pPrtCmd = (struct tPrintCmd *) pfData->pPrtCmd;

	*(lpCmd + 1) = HIBYTE(lpHwData->wPrintSRAMOffset);
	*(lpCmd + 2) = LOBYTE(lpHwData->wPrintSRAMOffset);

	wSize = (pfData->wSliceCount * pfData->bBytesPerSlice);
	*(lpCmd + 3) = HIBYTE(wSize);
	*(lpCmd + 4) = LOBYTE(wSize);

	/* Now send the control codes and the print slice data to the printer */
	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);
	OUTPUT(lpDataRec, (unsigned char *) pPrtCmd, wSize);
}

/***************************************************************************
 *  FCKELVIN.C                                     Lexmark Confidential
 *
 * Function Name:    Linefeed
 *
 * Description:
 *    This function converts the FormsMovePending number into a
 *    resolution the printer is expecting.  It then sends a paper
 *    move command to the printer in the printer expected format.
 *    If in Windows, paper animation is called.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  PaperAnimation
 *                          OUTPUT
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/

void LineFeed(LPDVDATAREC lpDataRec)
{
	struct pf_data *pfData;
	struct tHwData *lpHwData;
	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;
	unsigned short wVertMove;

	lpCmd = abPrinterCmd;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	wVertMove = (unsigned short) pfData->nFormsMovePending;

	if (wVertMove == 0)
		return;

	/* printer needs vertical moves in 1/300" units */
#ifndef GEN_BIDI
	if (pfData->bResolution == LORES)
#endif
		wVertMove *= 2;

	*(lpCmd + 0) = PAPER_FEED_CMD;
	*(lpCmd + 1) = (PAPER_FORWARD | PAPER_NORMAL_SPEED);
	*(lpCmd + 2) = HIBYTE(wVertMove);
	*(lpCmd + 3) = LOBYTE(wVertMove);

	/* move sent to printer so no moves pending now */
	pfData->nFormsMovePending = 0;

#if !defined(DOS_BUILD) && !defined(__riscos)
	if (pfData->bResolution == LORES)
		PaperAnimation((void *) lpDataRec->lpLXGenericPtr, (unsigned int) (wVertMove / 2));
	else
		PaperAnimation((void *) lpDataRec->lpLXGenericPtr, (unsigned int) (wVertMove));
#endif

	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);
}

/***************************************************************************
 *  FCKELVIN.C                                     Lexmark Confidential
 *
 * Function Name:    FcFormfeed
 *
 * Description:
 *    This function sends a Formfeed command to the printer.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/

void FcFormFeed(LPDVDATAREC lpDataRec)
{

	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{PAPER_LOAD_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;

	lpCmd = abPrinterCmd;
	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);
}

/***************************************************************************
 *  FCKELVIN.C                                     Lexmark Confidential
 *
 * Function Name:    FCEjectPage
 *
 * Description:
 *    This function sends a page eject command to the printer.
 *    Note that no action is taken by the printer unless paper has
 *    been loaded.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/

void FCEjectPage(LPDVDATAREC lpDataRec)
{
	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{PAPER_EJECT_CMD, 0x00, 0x10, 0xCC, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;
	struct pf_data *pfData;
	unsigned short wLength;
	long lRowPos;

	lpCmd = abPrinterCmd;

	if (lpDataRec != NULL)
	{
		pfData = (struct pf_data *) lpDataRec->lpLXDevice;

		switch (lpDataRec->bMediaSize)
		{
		case ENVELOPE_MONARCH:
		case ENVELOPE_B5:
		case PAPER_LETTER:
			wLength = 3300;
			break;
		case PAPER_LEGAL:
			wLength = 4200;
			break;
		case PAPER_B5:
			wLength = 3035;
			break;
		case PAPER_EXECUTIVE:
			wLength = 3150;
			break;
		case PAPER_A5:
			wLength = 2480;
			break;
		case PAPER_USER:
			wLength = 4300;
			break;
		case PAPER_A4:
			wLength = 3510;
			break;
		case PAPER_OHFHAGAKI:
			wLength = 1749;
			break;
		case PAPER_HAGAKI:
			wLength = 1749;
			break;
		case ENVELOPE_9:
			wLength = 2662;
			break;
		case ENVELOPE_10:
			wLength = 2850;
			break;
		case ENVELOPE_DL:
			wLength = 2598;
			break;
		case ENVELOPE_C5:
			wLength = 2703;
			break;
		case ENVELOPE_C6:
			wLength = 1914;
			break;
		case ENVELOPE_D5:
			wLength = 2952;
			break;
		case ENVELOPE_75:
			wLength = 2250;
			break;
		case CARD_3X5:
			wLength = 1500;
			break;
		case CARD_4X6:
			wLength = 1800;
			break;
		default:
			wLength = 4300;
			break;
		}

		lRowPos = pfData->lRowPos;

		if ((lpDataRec->bMediaSize != PAPER_BANNER_A4) && (lpDataRec->bMediaSize != PAPER_BANNER_LETTER))
		{
			abPrinterCmd[1] |= DET_JAM_ENABLE;
		}
		else
		{
			wLength = (unsigned short) lRowPos;
			kelvin_trace1("Banner Paper  = %d\n", (int) lpDataRec->bMediaSize);
		}

		//kelvin_trace2("EJ, wLength = %d, lRowPos = %d\n", wLength, lRowPos);

		/* units = 1600" */
		wLength = wLength * 2;

		/* add more steps just to make sure paper is ejected OK */
		wLength = wLength + 1200;

		/* printer needs vertical moves in 1/300" units */

		if (pfData->bResolution != HIRES)
			lRowPos *= 2;

		//kelvin_trace3("Eject page (%d, %d, %d rows to go)\n", wLength, lRowPos, wLength - lRowPos);

		abPrinterCmd[2] = HIBYTE(wLength - (unsigned short) lRowPos);
		abPrinterCmd[3] = LOBYTE(wLength - (unsigned short) lRowPos);
	}

	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);
}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    FcPaperSource
 *
 * Description:
 *    This function outputs the paper source data (manual or
 *    automatic sheet feed) to the printer in the expected format.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void FCSetPaperSource(LPDVDATAREC lpDataRec)
{

	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{PAPER_SOURCE_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;

	lpCmd = abPrinterCmd;

	if (lpDataRec->bMediaSource == MANUAL_FEED)
		*(lpCmd + 1) = MANUAL_LOAD;
	else
		*(lpCmd + 1) = ASF_LOAD;

	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);
}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    GetLeftMargin
 *
 * Description:
 *    This function determines the left margin
 *    based on the following :
 *      Paper Size - (i.e. left margin is 75/300 for Letter,
 *                         40/300" for A4 paper.
 *
 * Inputs:  bMediatSource  ASF or manual feed
 *          bMediaSize
 *
 * Outputs: unsigned short LeftMargin
 *
 * Major Functions Called:
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

unsigned short GetLeftMargin(LPDVDATAREC lpDataRec)
{
	struct pf_data *pfData;
	unsigned short bLeftMargin;

	bLeftMargin = LEFT_UNPRINTABLE_AREA;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;

	/* Determine Minimum left margin from the Media Size and Source */
	/* Note that A4 and Hagaki is 35/300" < than other US paper sources. */
	/* All envelopes and Hagaki is always manual feed for this product. */

	switch (lpDataRec->bMediaSize)
	{
	case PAPER_LETTER:
	case PAPER_BANNER_LETTER:
	case PAPER_LEGAL:
	case PAPER_B5:
	case PAPER_EXECUTIVE:
	case PAPER_A5:
	case PAPER_USER:
		if (lpDataRec->bMediaSource == MANUAL_FEED)
			bLeftMargin += MANUAL_FEED_OFFSET;
		break;
	case PAPER_A4:
	case PAPER_BANNER_A4:
		bLeftMargin -= 35;
		if (lpDataRec->bMediaSource == MANUAL_FEED)
			bLeftMargin += MANUAL_FEED_OFFSET;
		break;
	case PAPER_OHFHAGAKI:
	case PAPER_HAGAKI:
		bLeftMargin -= 35;
		bLeftMargin += MANUAL_FEED_OFFSET;
		break;
	case ENVELOPE_MONARCH:
	case ENVELOPE_9:
	case ENVELOPE_10:
	case ENVELOPE_DL:
	case ENVELOPE_C5:
	case ENVELOPE_B5:
	case ENVELOPE_C6:
	case ENVELOPE_D5:
	case ENVELOPE_75:
	case CARD_3X5:
	case CARD_4X6:
		bLeftMargin += MANUAL_FEED_OFFSET;
		break;
	default:
		bLeftMargin = LEFT_UNPRINTABLE_AREA;
		break;
	}

	return (bLeftMargin * pfData->nSwathResMult);
}

unsigned char GetShingleMode(LPDVDATAREC lpDataRec)
{
	unsigned char bShingle = NO_SHINGLE;

	/* determine shingle value from media type and print quality */
	switch (lpDataRec->bMediaType)
	{
	case PLAIN_PAPER:
		switch (lpDataRec->bQuality)
		{
		case QUALITY_DRAFT:
			bShingle = NO_SHINGLE;
			break;
		case QUALITY_NORMAL:
			bShingle = NO_SHINGLE;
			break;
		case QUALITY_HIGH:
			bShingle = NO_SHINGLE;
			break;
		default:
			bShingle = NO_SHINGLE;
			break;
		}
		break;
	case COATED_PAPER:
		switch (lpDataRec->bQuality)
		{
		case QUALITY_DRAFT:
			bShingle = NO_SHINGLE;
		case QUALITY_NORMAL:
			bShingle = SHINGLE_50;
			break;
		case QUALITY_HIGH:
			bShingle = NO_SHINGLE;
			break;
		default:
			bShingle = NO_SHINGLE;
			break;
		}
		break;
	case GLOSSY_PAPER:
	case TRANSPARENCY:
		switch (lpDataRec->bQuality)
		{
		case QUALITY_DRAFT:
			bShingle = NO_SHINGLE;
		case QUALITY_NORMAL:
			bShingle = SHINGLE_25;
			break;
		case QUALITY_HIGH:
			bShingle = SHINGLE_50;
			break;
		default:
			bShingle = NO_SHINGLE;
			break;
		}
		break;
	case IRON_ON_TRANSFER:
	case GREETING_CARD_STOCK:
		switch (lpDataRec->bQuality)
		{
		case QUALITY_DRAFT:
			bShingle = NO_SHINGLE;
			break;
		case QUALITY_NORMAL:
			bShingle = SHINGLE_50;
			break;
		case QUALITY_HIGH:
			bShingle = NO_SHINGLE;
			break;
		default:
			bShingle = NO_SHINGLE;
			break;
		}
		break;
	default:
		bShingle = NO_SHINGLE;
	}

	return (bShingle);
}

unsigned char CheckforReverseSwath(LPDVDATAREC lpDataRec)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	CalcCarrierPositions(lpDataRec, TRUE);

	if (lpHwData->bPrtCarrDirection == LEFT)
		return (REVERSE);
	else
		return (FORWARD);
}

unsigned char GetResolution(LPDVDATAREC lpDataRec)
{
	unsigned char bResolution;									/* 300 dpi */

	bResolution = LORES;

	if (lpDataRec->bQuality == QUALITY_HIGH)
		bResolution = HIRES;									/* 600 dpi */

#ifdef GEN_BIDI
	bResolution = HIRES;										/* 600 dpi */
#endif

	return (bResolution);
}

int GetBidiAlign(struct tHwData *lpHwData, unsigned char bDirection, unsigned char bPrinthead)
{
	int nBidiAlign;

	/* Make sure initialized to something so no compiler warning */
	nBidiAlign = MONO_LEFT_BIDI_ALIGN;

	if (bPrinthead == MONO_CARTRIDGE)
	{
		if (bDirection == LEFT)
			nBidiAlign = lpHwData->nMonoLeftBidiAlign;
		else
			nBidiAlign = lpHwData->nMonoRightBidiAlign;

	}

	if (bPrinthead == COL_CARTRIDGE)
	{
		if (bDirection == LEFT)
			nBidiAlign = lpHwData->nColorLeftBidiAlign;
		else
			nBidiAlign = lpHwData->nColorRightBidiAlign;
	}

	return (nBidiAlign);
}

unsigned char CheckForCDE(unsigned char bResolution, unsigned char bQuality)
{
	/* Make the compiler happy */
	bResolution = bResolution;

	if (bQuality == QUALITY_DRAFT)
		return (TRUE);
	else
		return (FALSE);
}

unsigned char GetPrintDir(LPDVDATAREC lpDataRec, int nBuffers)
{
	struct pf_data *pfData;
	struct tHwData *lpHwData;
	unsigned char bPrintDir;

	/* silence the compiler */
	nBuffers = nBuffers;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	if (pfData->bPrintQuality == QUALITY_DRAFT)
	{
		bPrintDir = BIDI;
	}
	else
	{
		bPrintDir = RTOL;
	}

	if (lpDataRec->bColorPlanes == 6)
	{
		bPrintDir = RTOL;
	}

#ifdef PQ_TEST
	bPrintDir = lpHwData->bTestPrintDir;
#endif

#ifdef GEN_BIDI
// bPrintDir = LTOR;
	bPrintDir = BIDI;
#endif

#ifdef GEN_COL_BIDI
	bNumBidiSwaths++;
	if ((bNumBidiSwaths > 4 * 3) && (bNumBidiSwaths < 17))
		bPrintDir = RTOL;
	else
		bPrintDir = LTOR;
#endif

	return (bPrintDir);

}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    GetTopMargin
 *
 * Description:
 *    This function determines the top margin.  It seems like
 *    the interface has changed to SW2000 driver code for some
 *    printers so this is now printer specific.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

unsigned short GetTopMargin(LPDVDATAREC lpDataRec)
{
	struct pf_data *pfData;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	return ((unsigned short) (40 * pfData->nVertResMult));
}

void ClearPrintSwath(struct pf_data *pfData)
{
	struct tPrintCmd *pPrtCmd;
	unsigned char *lpbSwath;

	pPrtCmd = (struct tPrintCmd *) pfData->pPrtCmd;
	lpbSwath = pPrtCmd->abSwathBuff;
	MEMSET(lpbSwath, 0x00, (unsigned short) ((PRT_CMD_SIZE) - (SWATH_HEADER_SIZE)));
}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    FCSendCartridgeHome
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to send the carrier to be capped at the
 *    maintenance station.  The carrier position
 *    kept by the driver is then updated to the
 *    maintenance cap position.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void FCSendCartridgeHome(LPDVDATAREC lpDataRec)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;
	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{CAP_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;
	unsigned short wCarrPos;

	lpCmd = abPrinterCmd;
	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	/* If carrier is not close to maintenance station then send it close
	 * at draft speed before sending home command which is only 9IPS     */

	wCarrPos = lpHwData->wCurrCarrPos;

	if (lpHwData->wCurrCarrPos > (MONO_SPIT_POSITION +
					(unsigned short) ShortestMoveDist(lpHwData, QUALITY_DRAFT, FALSE))
			)

	{
		lpHwData->wPosCarrStartPosition = lpHwData->wCurrCarrPos;
		lpHwData->wPosCarrStopPosition = MONO_SPIT_POSITION;
		lpHwData->bPosCarrDirection = LEFT;
		lpHwData->bPosCarrSpeed = QUALITY_DRAFT;
		PositionCarrierForPrint(lpDataRec);
	}

	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);
	lpHwData->wCurrCarrPos = LEFT_SIDE_FRAME_POSITION;

	/* Only do maintenance after an install */
	if (lpHwData->bInstallCartridge == TRUE)
	{
		pfData->bPrintHead = lpDataRec->bLeftCartridgeID;
		SendMaintenanceCmd(lpDataRec, INSTALL_SPIT_CNT, INSTALL_WIPE_CNT);
		UpdatePageDotCount(lpDataRec, INSTALL_SPIT_CNT);
		lpHwData->bInstallCartridge = FALSE;
	}

}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    FCInstallCartridge
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to send the carrier to the install position.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: K. Profitt
 * Date: 12/12/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void FCInstallCartridge(LPDVDATAREC lpDataRec)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	if (IsCarrierInMaintStation(lpDataRec) == TRUE)
	{
		SendMaintenanceCmd(lpDataRec, UNCAP_SPIT_CNT, UNCAP_WIPE_CNT);
		UpdatePageDotCount(lpDataRec, UNCAP_SPIT_CNT);
	}

	/* If carrier is not close to maintenance station then send it close
	 * at draft speed before sending home command which is only 9IPS     */

	if (lpHwData->wCurrCarrPos < (CARTRIDGE_INSTALL_POSITION -
					(unsigned short) ShortestMoveDist(lpHwData, QUALITY_DRAFT, FALSE))
			)

	{
		lpHwData->wPosCarrStartPosition = lpHwData->wCurrCarrPos;
		lpHwData->wPosCarrStopPosition = CARTRIDGE_INSTALL_POSITION;
		lpHwData->bPosCarrDirection = RIGHT;
		lpHwData->bPosCarrSpeed = QUALITY_DRAFT;
		PositionCarrierForPrint(lpDataRec);
	}

	if (lpHwData->wCurrCarrPos > (CARTRIDGE_INSTALL_POSITION +
					(unsigned short) ShortestMoveDist(lpHwData, QUALITY_DRAFT, FALSE))
			)

	{
		lpHwData->wPosCarrStartPosition = lpHwData->wCurrCarrPos;
		lpHwData->wPosCarrStopPosition = CARTRIDGE_INSTALL_POSITION;
		lpHwData->bPosCarrDirection = LEFT;
		lpHwData->bPosCarrSpeed = QUALITY_DRAFT;
		PositionCarrierForPrint(lpDataRec);
	}

	lpHwData->bInstallCartridge = TRUE;
}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    PositionCarrierForPrint
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to perform a carrier position move. The
 *    carrier position kept by the driver is then updated
 *    to the new position.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void PositionCarrierForPrint(LPDVDATAREC lpDataRec)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;
	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{CARRIER_MOVE_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;
	unsigned char bSpeed;
	unsigned char bDir;
	unsigned short wNumCarrStep;

	lpCmd = abPrinterCmd;
	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	if (lpHwData->bPosCarrDirection != NO_DIRECTION)
	{

// kelvin_trace1("Before PositionCar Carrier Pos = %x\n", (lpHwData->wCurrCarrPos/4));
		if (lpHwData->bPosCarrSpeed == QUALITY_DRAFT)
			bSpeed = CAR_MOVE_25;
		else if ((lpHwData->bPosCarrSpeed == QUALITY_NORMAL) ||
					(lpHwData->bPosCarrSpeed == QUALITY_HIGH)
				)
		{
			bSpeed = CAR_MOVE_16;
// kelvin_traceout ("Position Carrier LQ Speed\n");
		}
		else
		{
			bSpeed = CAR_MOVE_09;
// kelvin_traceout ("Position Carrier 9IPS Speed\n");
		}

		if (lpHwData->bPosCarrDirection == RIGHT)
			bDir = FORWARD_CAR;
		else
			bDir = REVERSE_CAR;

		*(lpCmd + 1) = (unsigned char) (bSpeed | bDir);

		wNumCarrStep = CalcConstantSteps(lpDataRec,
				lpHwData->wPosCarrStartPosition, lpHwData->wPosCarrStopPosition,
				lpHwData->bPosCarrSpeed, lpHwData->bPosCarrDirection);

// kelvin_trace1("PositionCar NumSteps = %x\n", wNumCarrStep);

		*(lpCmd + 2) = HIBYTE(wNumCarrStep);
		*(lpCmd + 3) = LOBYTE(wNumCarrStep);

		OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

// lpHwData->wCurrCarrPos = lpHwData->wPosCarrStopPosition;

// kelvin_trace1("After PositionCar Carrier Pos = %x\n", (lpHwData->wCurrCarrPos/4));
	}

	lpHwData->bPosCarrDirection = NO_DIRECTION;
	lpHwData->wPosCarrStartPosition = 0;
	lpHwData->wPosCarrStopPosition = 0;
	lpHwData->bPosCarrSpeed = STOPPED;

}

/* 
 *      Note that right and left are with respect to
 *      the page, not the printer.
 *
 *               <----Constant Speed---->           Initial
 *        Stop                               Car    Carrier
 *        Pos                       Settle   Pos    Position 0x100
 *   |------|----|-------------------|--|-----|--------------|
 *   Left  <---->   <----------        <---->       Maintenance
 *   Side   Decel     Direction         Accel          Station
 *
 *
 *   r = 0x100 + length of carrier travel for printer
 */

unsigned short CalcConstantSteps(LPDVDATAREC lpDataRec, unsigned short wStartPosition,
		unsigned short wStopPosition, unsigned short wSpeed, unsigned short wDirection)
{
	struct pf_data *pfData;
	struct tHwData *lpHwData;
	unsigned short wNumCarrStep, wShortMoveDist;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	/* Make sure positions are on carrier step boundaries */

	wStartPosition = (unsigned short) PositionCompensation(wStartPosition, wDirection);
	wStopPosition = (unsigned short) PositionCompensation(wStopPosition, wDirection);

	if (wDirection == RIGHT)
	{

		/*
		 * calculate the number of steps for the carrier
		 * to move (1/600")
		 */

		wNumCarrStep = wStopPosition - wStartPosition;

	}
	else
		/* direction is LEFT */
	{

		/*
		 * calculate the number of steps for the carrier
		 * to move (1/600")
		 */

		wNumCarrStep = wStartPosition - wStopPosition;

	}

	/*
	 * Calculate number of steps for constant speed.
	 * The printer does not need accel/decel distance in cmd
	 * so subtract them from the number of carrier steps.
	 * ShortestMoveDist calculates this value.
	 * The "settle" distance for the carrier to reach steady state
	 * after acceleration is included in this calculation if
	 * a value of TRUE is passed in as a parameter.
	 * Settle should be included in the constant step number
	 * sent to the printer so a FALSE for the IncludeSettle
	 * parmeter is given.
	 */

	if ((wSpeed == QUALITY_NORMAL) ||
			(wSpeed == QUALITY_HIGH)
			)

		wShortMoveDist = (unsigned short) ShortestMoveDist(lpHwData, QUALITY_NORMAL, FALSE);
	else if (wSpeed == QUALITY_DRAFT)
		wShortMoveDist = (unsigned short) ShortestMoveDist(lpHwData, QUALITY_DRAFT, FALSE);
	else
		wShortMoveDist = (unsigned short) ShortestMoveDist(lpHwData, SLOW, FALSE);

	if (wNumCarrStep > wShortMoveDist)
		wNumCarrStep -= wShortMoveDist;
	else
	{
		if (wDirection == RIGHT)
			wStopPosition += wShortMoveDist - wNumCarrStep;
		else
			wStopPosition -= wShortMoveDist - wNumCarrStep;

		wNumCarrStep = 0;
	}

	/*
	 * now update the driver carrier position with this move
	 * since PositionCompensation forces stop to be in
	 * HW resolution boundaries
	 */
	lpHwData->wCurrCarrPos = wStopPosition;

	/* convert from 1/600" to 1/150" */
	wNumCarrStep = wNumCarrStep / RES600_PER_STEP;

	return (wNumCarrStep);
}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    MaxAccelDistance
 *
 * Description:
 *    This function returns the shortest distance
 *    that it will take to accelerate  to a given steady state
 *    velocity.  This value includes the acceleration ramp
 *    + the settle time (Alpha) to reach  constant speed.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *          wQuality  Quality input gives the steady state speed.
 *
 * Outputs: Maximum Acceleration Distance
 *          Units are in 1/600" at carrier motor step
 *          increment.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

int MaxAccelDistance(LPDVDATAREC lpDataRec, unsigned short wQuality)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;
	int nAccelDist;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	if ((wQuality == QUALITY_NORMAL) ||
			(wQuality == QUALITY_HIGH)
			)
	{
		nAccelDist = lpHwData->bAccelStepCnt16;
		nAccelDist += lpHwData->bAlphaStepCnt16;
	}
	else
	{
		if (wQuality == QUALITY_DRAFT)
		{
			nAccelDist = lpHwData->bAccelStepCnt25;
			nAccelDist += lpHwData->bAlphaStepCnt25;
		}
		else
			/* SLOW speed */
		{
			nAccelDist = lpHwData->bAccelStepCnt3;
			nAccelDist += lpHwData->bAlphaStepCnt3;
		}
	}

	/* convert from carrier step resolution to 1/600" */
	nAccelDist *= RES600_PER_STEP;

	/* put in carrier units */
	nAccelDist = PositionCompensation(nAccelDist, RIGHT);

	return (nAccelDist);
}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    MaxDecelDistance
 *
 * Description:
 *    This function returns the shortest distance
 *    that it will take to decelerate from a given steady state
 *    velocity.  This value is the deceleration ramp.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *          wQuality  Quality input gives the steady state speed.
 *
 * Outputs: Maximum Deceleration Distance
 *          Units are in 1/600" at carrier motor step
 *          increment.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

int MaxDecelDistance(LPDVDATAREC lpDataRec, unsigned short wQuality)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;
	int nDecelDist;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	if ((wQuality == QUALITY_NORMAL) ||
			(wQuality == QUALITY_HIGH)
			)
	{
		nDecelDist = lpHwData->bDecelStepCnt16;
	}
	else
	{
		if (wQuality == QUALITY_DRAFT)
		{
			nDecelDist = lpHwData->bDecelStepCnt25;
		}
		else
			/* SLOW speed */
		{
			nDecelDist = lpHwData->bDecelStepCnt3;
		}
	}

	/* convert from carrier step resolution to 1/600" */
	nDecelDist *= RES600_PER_STEP;

	/* must end on even step */
	nDecelDist = PositionCompensation(nDecelDist, RIGHT);

	return (nDecelDist);
}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    ShortestMoveDistance
 *
 * Description:
 *    Calculates the shortest distance that it will take to
 *    accelerate and decelerate the carrier.
 *
 * Inputs:  lpDataRec       Long pointer to print device structure.
 *          wQuality       Quality input gives the steady state speed.
 *          bIncludeSettle If true then the settle time /alpha
 *                         is included in the calculation.
 *
 * Outputs: Minimum Distance for a move at given speed.
 *          Units are in 1/600" at carrier motor step
 *          increment.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

int ShortestMoveDist(struct tHwData *lpHwData,
		unsigned short wQuality, BOOL bIncludeSettle)
{

	int nShortDist;

	if ((wQuality == QUALITY_NORMAL) ||
			(wQuality == QUALITY_HIGH)
			)
	{
		nShortDist = lpHwData->bAccelStepCnt16;
		nShortDist += lpHwData->bDecelStepCnt16;
		if (bIncludeSettle)
			nShortDist += lpHwData->bAlphaStepCnt16;
	}
	else
	{
		if (wQuality == QUALITY_DRAFT)
		{
			nShortDist = lpHwData->bAccelStepCnt25;
			nShortDist += lpHwData->bDecelStepCnt25;
			if (bIncludeSettle)
				nShortDist += lpHwData->bAlphaStepCnt25;
		}
		else
			/* SLOW speed */
		{
			nShortDist = lpHwData->bAccelStepCnt3;
			nShortDist += lpHwData->bDecelStepCnt3;
			if (bIncludeSettle)
				nShortDist += lpHwData->bAlphaStepCnt3;
		}
	}

	/* convert from carrier step resolution to 1/600" */
	nShortDist *= RES600_PER_STEP;

	/* put in carrier units */
	nShortDist = PositionCompensation(nShortDist, RIGHT);

	return (nShortDist);
}

/***************************************************************************
 * FCKELVIN.C                                Lexmark Confidential
 *
 * Function Name:    PositionCompensation
 *
 * Description:
 *    This function takes the input direction ( 1/600" units )
 *    and modifies it to make sure it is on a carrier step
 *    boundary.  For example, if RES600_PER_STEP is equal to 4,
 *    then the carrier step resolution is 1/150".  The carrier
 *    can only stop on 4/600" boundaries.
 *
 * Inputs:  nPosition   1/600" units.
 *          wDir        Carrier movement direction.
 *
 * Outputs: Compensated nPosition
 *
 * Major Functions Called:    None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/

int PositionCompensation(int nPosition, unsigned short wDir)
{
	int x3;

	x3 = nPosition % RES600_PER_STEP;
	if (x3 != 0)
	{
		nPosition -= x3;
		if (wDir == RIGHT)
			nPosition += RES600_PER_STEP;
	}

	return (nPosition);
}

/***************************************************************************
 * FCKELVIN.C                                Lexmark Confidential
 *
 * Function Name:    IsCarrierInMaintenanceStation
 *
 * Description:
 *    This function checks the current carrier position and
 *    returns TRUE if carrier is in the maintenance station.
 *
 * Inputs:  lpDataRec       Long pointer to print device structure.
 *
 * Outputs: TRUE if Carrier in Maintenace station, FALSE otherwise
 *
 * Major Functions Called:    None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/

BOOL IsCarrierInMaintStation(LPDVDATAREC lpDataRec)
{
	struct pf_data *pfData;
	struct tHwData *lpHwData;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	if (lpHwData->wCurrCarrPos <= LEFT_SIDE_FRAME_POSITION)
		return (TRUE);

	else
		return (FALSE);

}

/***************************************************************************
 * FCKELVIN.C                                Lexmark Confidential
 *
 * Function Name:    PrintPos
 *
 * Description:
 *    This function puts the print position into 1/600" carrier
 *    units taking into considertation the offset between the mono
 *    and color cartridges for two pen printers and the paper edge.
 *
 *
 * Inputs:  unsigned char bResolution    - Resolution of print position.
 *          unsigned char bMono          - TRUE if print swath mono.
 *          int  nPrintPosition
 *          bDirection          - Direction of carrier travel
 *
 * Outputs: int nPrintPosition is carrier 1/600" units
 *
 * Major Functions Called:    None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/

int PrintPos(unsigned char bResolution, unsigned char bMono, int nPrintPosition,
		unsigned char bDirection)
{
	int nPosition600;

	nPosition600 = nPrintPosition;

	if (bResolution == LORES)
	{

		nPosition600 = nPrintPosition * 2;
// kelvin_trace1("nPosition600 - Mulitplied by 2 = %x\n", nPrintPosition);
	}

	if (bMono == MONO_CARTRIDGE)
		bMono = TRUE;

	nPosition600 += ((bMono ? MONO_POS_OFFSET : COLOR_POS_OFFSET));
	nPosition600 += HW_LT_PAP_EDGE;

	/* put position into carrier motor step boundaries */
	if (bDirection == LEFT)
		nPosition600 = PositionCompensation(nPosition600, LEFT);
	else if (bDirection == RIGHT)
		nPosition600 = PositionCompensation(nPosition600, RIGHT);

	/* returns value in 600ths */
	return (nPosition600);
}

/***************************************************************************
 * FCKELVIN.C                                Lexmark Confidential
 *
 * Function Name:    CalculateCarrPositions
 *
 * Description:
 *    This function determines the print direction, start position,
 *    and stop position taking into account the acceleration and
 *    deceleration distances for the carrier move given the print
 *    speed.  It also checks the current carrier position and
 *    calculates a position move if required.  All calculations
 *    are using 1/600" units.  Note that LEFT/RIGHT and the carrier
 *    position increment/decrement is with respect to the page,
 *    not the printer ( page LEFT and RIGHT is reversed from printer
 *    LEFT and RIGHT).
 *
 *
 * Inputs:  lpDataRec          Long pointer to print device structure.
 *          BOOL fNextSwath   Function can be called to calculate positions
 *                            for current swath to print or the next swath
 *                            to print.  If fNextSwath is TRUE, then the
 *                            print positions are retrieved from different
 *                            variables.
 *
 * Outputs: None
 *
 * Major Functions Called:    None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/

void CalcCarrierPositions(LPDVDATAREC lpDataRec, BOOL fNextSwath)
{
	/* all distance/position variables are in 1/600" units */

	/* left and right print positions of current swath */
	int nLeftPrintPos, nRightPrintPos;

	int nLeftPlusAccel, nRightPlusAccel;

	unsigned char bPrinthead, bPrintDir;
	int nCarrPos;												/* current carrier position  */
	int nMaxAccelDist, nMaxDecelDist;
	int nLeftBidi, nRightBidi;
	struct pf_data *pfData;
	struct tHwData *lpHwData;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	/* no move required to position carrier for printing */
	lpHwData->bPosCarrDirection = NO_DIRECTION;
	lpHwData->wPosCarrStartPosition = 0;
	lpHwData->wPosCarrStopPosition = 0;
	lpHwData->bPosCarrSpeed = STOPPED;

/* 
 *      Note that right and left are with respect to
 *      the page, not the printer.
 *
 *          Left                        Right
 *          Print                       Print
 *          Position                    Position
 *           ___________________________
 *          |___________________________|
 * |---|--------------------------------------|----|
 *      Left                                  Right
 *      Plus                                  Plus
 *      Accel                                 Accel
 *
 */

	/* get maximum acceleration distance from hardware specific routine */
	nMaxAccelDist = MaxAccelDistance(lpDataRec, pfData->bPrintQuality);
	nMaxDecelDist = MaxDecelDistance(lpDataRec, pfData->bPrintQuality);

	/* save the print speed */
	lpHwData->bPrtCarrSpeed = pfData->bPrintQuality;

	/*
	 * get necessary data depending on if calculating positions for
	 * current swath or the next swath to be printed.
	 */

	if (fNextSwath == FALSE)
	{
		nLeftPrintPos = pfData->nLeftPrintPos;
		nRightPrintPos = pfData->nRightPrintPos;
		bPrinthead = pfData->bPrintHead;
		bPrintDir = pfData->bPrintDirection;
	}
	else
	{
		/*
		 * Need to calculate positions for next swath.  The
		 * positions are in the PreRotateVariables for the next
		 * swath.
		 */

		/* first check to see if next swath is empty.  If it is, return */
		if ((pfData->nPreRotateEnd - pfData->nPreRotateStart) <= 0)
			return;

		nLeftPrintPos = RastertoPrintPos(pfData->nPreRotateStart, pfData->wLeftMargin);
		nRightPrintPos = RastertoPrintPos(pfData->nPreRotateEnd, pfData->wLeftMargin);
		nRightPrintPos -= 1;

#if 0
		if (pfData->bPreRotateDir == BIDI)
		{
			/* alignment in 1/600" units */
			nLeftPrintPos += (GetBidiAlign(lpHwData, LEFT, pfData->bPreRotatePrintHead) / pfData->nSwathResMult);
			nRightPrintPos += (GetBidiAlign(lpHwData, RIGHT, pfData->bPreRotatePrintHead) / pfData->nSwathResMult);
		}

#endif

		bPrinthead = pfData->bPreRotatePrintHead;
		bPrintDir = pfData->bPreRotateDir;
		if (bPrinthead == MONO_CARTRIDGE)
		{
			nRightPrintPos += (MONO_NOZZLE_OFFSET * pfData->nSwathResMult);
			nLeftPrintPos -= (MONO_NOZZLE_OFFSET * pfData->nSwathResMult);
		}
		else
		{
			nRightPrintPos += ((COLOR_NOZZLE_OFFSET + COLOR_HEAD_OFFSET) * pfData->nSwathResMult);
			nLeftPrintPos -= ((COLOR_NOZZLE_OFFSET + COLOR_HEAD_OFFSET) * pfData->nSwathResMult);
		}
	}

	/* put print position into 1/600" units and account for
	 * printhead offsets in two pen printers */
	nLeftPrintPos = PrintPos(pfData->bResolution, bPrinthead,
			nLeftPrintPos, LEFT);
	nRightPrintPos = PrintPos(pfData->bResolution, bPrinthead,
			nRightPrintPos, RIGHT);

	/* alignment values returned in 1/600" units */
#ifndef GEN_COL_BIDI
	if (bPrintDir == BIDI)
#endif
	{
		nLeftPrintPos += GetBidiAlign(lpHwData, LEFT, bPrinthead);
		nRightPrintPos += GetBidiAlign(lpHwData, RIGHT, bPrinthead);

		/* make sure on 1/150" boundaries */
		nLeftPrintPos = PositionCompensation(nLeftPrintPos, LEFT);
		nRightPrintPos = PositionCompensation(nRightPrintPos, RIGHT);

	}

	/* get the right and left positions with acceleration added */
	nLeftPlusAccel = (LeftPosPlus(nLeftPrintPos, nMaxAccelDist));
	nRightPlusAccel = (RightPosPlus(nRightPrintPos, nMaxAccelDist));

	nCarrPos = (int) lpHwData->wCurrCarrPos;

	nLeftBidi = lnabs(nCarrPos - nLeftPlusAccel);
	nRightBidi = lnabs(nCarrPos - nRightPlusAccel);

/* 
 *
 *
 *                      PAGE
 *
 *            LPP                 RPP
 *            ______________________
 *            |_____________________|
 *   |-----|--------|-------------------|---------------------|
 *       LPP+accel CP                 RPP+accel
 *                  <-------------------->
 *                          nRightBidi
 *         <-------->
 *          nLeftBidi
 *
 *      RPP = RightPrintPosition
 *      LPP = LeftPrintPosition
 *
 */

	/* Determine if repositioning is required for Bi-di printing   */
	/* or the return move for unidirectional printing - fNextSwath */
	/* is FALSE */

	if (bPrintDir == LTOR
			|| ((nLeftBidi < nRightBidi) && bPrintDir == BIDI))
// if ( ( (bPrintDir == LTOR) && ( fNextSwath == FALSE ) )
		//      || ( ( nLeftBidi < nRightBidi ) && bPrintDir == BIDI ) )
	{
		/* if carr left of acceleration ramp portion then print left to right */

		lpHwData->bPrtCarrDirection = RIGHT;
		lpHwData->wPrtStartPosition = (unsigned short) nLeftPrintPos;
		lpHwData->wPrtCarrStartPosition = (unsigned short) nLeftPlusAccel;
		if (nMaxDecelDist >= nMaxAccelDist)
			lpHwData->wPrtCarrStopPosition = (unsigned short) RightPosPlus(nRightPrintPos, nMaxDecelDist);
		else
			lpHwData->wPrtCarrStopPosition = (unsigned short) RightPosPlus(nRightPrintPos, nMaxAccelDist);

		if (lpHwData->wPrtCarrStopPosition > RIGHT_SIDE_FRAME_POSITION)
			lpHwData->wPrtCarrStopPosition = RIGHT_SIDE_FRAME_POSITION;

		if ((nCarrPos > nLeftPlusAccel) &&
				(nCarrPos > LEFT_PRINT_LIMIT)
				)
		{
			if (nLeftPlusAccel < LEFT_PRINT_LIMIT)
				nLeftPlusAccel = LEFT_PRINT_LIMIT;

			if (fNextSwath == TRUE)
			{
// kelvin_traceout ("NEXT SWATH CALC\n");
				//               kelvin_trace1("PreRotateStart = %x\n", (pfData->nPreRotateStart));
				//               kelvin_trace1("PreRotateEnd = %x\n",   (pfData->nPreRotateEnd));
			}

#if 0
			kelvin_trace1("LEFTPRINTLIMIT = %x\n", (LEFT_PRINT_LIMIT / 4));
			kelvin_trace1("nLeftPrintPos = %x\n", (nLeftPrintPos / 4));
			kelvin_trace1("nRightPrintPos = %x\n", (nRightPrintPos / 4));
			kelvin_trace1("nLeftPlusAccel = %x\n", (nLeftPlusAccel / 4));
			kelvin_trace1("nCarrPos = %x\n", (nCarrPos / 4));
#endif

			if ((nCarrPos - nLeftPlusAccel) >= ShortestMoveDist(lpHwData, QUALITY_DRAFT, TRUE))
				lpHwData->bPosCarrSpeed = QUALITY_DRAFT;
			else if ((nCarrPos - nLeftPlusAccel) >= ShortestMoveDist(lpHwData, QUALITY_NORMAL, TRUE))
				lpHwData->bPosCarrSpeed = QUALITY_NORMAL;
			else if (fNextSwath == FALSE)
				lpHwData->bPosCarrSpeed = SLOW;

			if (lpHwData->bPosCarrSpeed != STOPPED)
			{
				lpHwData->bPosCarrDirection = LEFT;
				lpHwData->wPosCarrStartPosition = (unsigned short) nCarrPos;
				lpHwData->wPosCarrStopPosition = (unsigned short) nLeftPlusAccel;
			}
		}
	}
	else
	{
		if (bPrintDir == RTOL
				|| (bPrintDir == BIDI))
// if ( ( bPrintDir== RTOL ) ||
			//           ( ( bPrintDir == LTOR ) && ( fNextSwath == TRUE ) )
			//           || (bPrintDir == BIDI) )
		{

			lpHwData->bPrtCarrDirection = LEFT;
			lpHwData->wPrtStartPosition = (unsigned short) nRightPrintPos;
			lpHwData->wPrtCarrStartPosition = (unsigned short) nRightPlusAccel;

			if (nMaxDecelDist >= nMaxAccelDist)
				lpHwData->wPrtCarrStopPosition = (unsigned short) LeftPosPlus(nLeftPrintPos, nMaxDecelDist);
			else
				lpHwData->wPrtCarrStopPosition = (unsigned short) LeftPosPlus(nLeftPrintPos, nMaxAccelDist);

			if (lpHwData->wPrtCarrStopPosition < LEFT_PRINT_LIMIT)
				lpHwData->wPrtCarrStopPosition = LEFT_PRINT_LIMIT;

			if ((nCarrPos < nRightPlusAccel) &&
					(nCarrPos < RIGHT_PRINT_LIMIT)
					)
			{
				/* need to position carrier before printing */

				if (nRightPlusAccel > RIGHT_PRINT_LIMIT)
				{
// kelvin_trace1("Assigning Right Print Limit nRightPlusAccel = %x\n", (nRightPlusAccel/4));
					nRightPlusAccel = RIGHT_PRINT_LIMIT;
				}

// if (fNextSwath == TRUE )
				//               kelvin_traceout ("NEXT SWATH CALC\n");
				//            kelvin_trace1("RIGHTPRINTLIMIT = %x\n", (RIGHT_PRINT_LIMIT/4));
				//            kelvin_trace1("nRightPrintPos = %x\n", (nRightPrintPos/4));
				//            kelvin_trace1("nRightPlusAccel = %x\n", (nRightPlusAccel/4));
				//            kelvin_trace1("nCarrPos = %x\n", (nCarrPos/4));

				if ((nRightPlusAccel - nCarrPos) >= ShortestMoveDist(lpHwData, QUALITY_DRAFT, TRUE))
					lpHwData->bPosCarrSpeed = QUALITY_DRAFT;
				else
				{
					if ((nRightPlusAccel - nCarrPos) >= ShortestMoveDist(lpHwData, QUALITY_NORMAL, TRUE))
						lpHwData->bPosCarrSpeed = QUALITY_NORMAL;
					else if (fNextSwath == FALSE)				/* No slow speed for return command */
						lpHwData->bPosCarrSpeed = SLOW;
				}

				if (lpHwData->bPosCarrSpeed != STOPPED)
				{
					lpHwData->bPosCarrDirection = RIGHT;
					lpHwData->wPosCarrStartPosition = (unsigned short) nCarrPos;
					lpHwData->wPosCarrStopPosition = (unsigned short) nRightPlusAccel;
				}

			}
		}
	}
}

/***************************************************************************
 * FCKELVIN.C                                Lexmark Confidential
 *
 * Function Name:    CalculateAppendDistance
 *
 * Description:
 *    This function takes the current print swath stop position and
 *    determines if it should be extended to position the carrier
 *    correctly for the next swath to print.  All calculations
 *    are using 1/600" units.  Note that LEFT/RIGHT and the carrier
 *    position increment/decrement is with respect to the page,
 *    not the printer ( page LEFT and RIGHT is reversed from printer
 *    LEFT and RIGHT).
 *
 *
 * Inputs:  lpDataRec          Long pointer to print device structure.
 *
 * Outputs: None
 *
 * Major Functions Called:    None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/

void CalculateAppendDistance(LPDVDATAREC lpDataRec)
{
	int nCurrLeftPrintPos, nCurrRightPrintPos;					/* left and right print positions of current swath */
	int nNextLeftPrintPos, nNextRightPrintPos;					/* left and right print positions of next swath */
	int nAppendDist;
	struct pf_data *pfData;
	struct tHwData *lpHwData;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	nCurrLeftPrintPos = PrintPos(pfData->bResolution, pfData->bPrintHead,
			pfData->nLeftPrintPos, LEFT);

	nCurrRightPrintPos = PrintPos(pfData->bResolution, pfData->bPrintHead,
			pfData->nRightPrintPos, RIGHT);

#ifndef GEN_COL_BIDI
	if (pfData->bPrintDirection == BIDI)
#endif
	{
		nCurrLeftPrintPos += GetBidiAlign(lpHwData, LEFT, pfData->bPrintHead);
		nCurrRightPrintPos += GetBidiAlign(lpHwData, RIGHT, pfData->bPrintHead);

		nCurrLeftPrintPos = PositionCompensation(nCurrLeftPrintPos, LEFT);
		nCurrRightPrintPos = PositionCompensation(nCurrRightPrintPos, RIGHT);
	}

	/*
	 * The PreRoatate values are kept in bytes for a raster line.
	 * Therefore, to convert to slices, need to multiply by 8
	 * bits per slice and add the left margin.
	 */

	/* if the following is TRUE then the next swath is empty */
	if ((pfData->nPreRotateEnd - pfData->nPreRotateStart) <= 0)
	{
		/* Next swath empty so move carrier all the way to the end of the
		 * print line to prepare for next swath with data */

		nNextLeftPrintPos = LEFT_PRINT_LIMIT
				+ MaxAccelDistance(lpDataRec, pfData->bPrintQuality);
		nNextRightPrintPos = RIGHT_PRINT_LIMIT
				- MaxAccelDistance(lpDataRec, pfData->bPrintQuality);

	}
	else
	{

		nNextLeftPrintPos = RastertoPrintPos(pfData->nPreRotateStart, pfData->wLeftMargin);
		nNextRightPrintPos = RastertoPrintPos(pfData->nPreRotateEnd, pfData->wLeftMargin);
		nNextRightPrintPos -= 1;

		if (pfData->bPrintHead == MONO_CARTRIDGE)
		{
			nNextRightPrintPos += (MONO_NOZZLE_OFFSET * pfData->nSwathResMult);
			nNextLeftPrintPos -= (MONO_NOZZLE_OFFSET * pfData->nSwathResMult);
		}
		else
		{
			nNextRightPrintPos += ((COLOR_NOZZLE_OFFSET + COLOR_HEAD_OFFSET) * pfData->nSwathResMult);
			nNextLeftPrintPos -= ((COLOR_NOZZLE_OFFSET + COLOR_HEAD_OFFSET) * pfData->nSwathResMult);
		}

		/* Now convert to 1/600" units */
		nNextLeftPrintPos = PrintPos(pfData->bResolution, pfData->bPreRotatePrintHead,
				nNextLeftPrintPos, LEFT);
		nNextRightPrintPos = PrintPos(pfData->bResolution, pfData->bPreRotatePrintHead,
				nNextRightPrintPos, RIGHT);

#ifndef GEN_COL_BIDI
		if (pfData->bPreRotateDir == BIDI)
#endif
		{
			nNextLeftPrintPos += GetBidiAlign(lpHwData, LEFT, pfData->bPreRotatePrintHead);
			nNextRightPrintPos += GetBidiAlign(lpHwData, RIGHT, pfData->bPreRotatePrintHead);

			/* make sure on 1/150" boundaries */
			nNextLeftPrintPos = PositionCompensation(nNextLeftPrintPos, LEFT);
			nNextRightPrintPos = PositionCompensation(nNextRightPrintPos, RIGHT);
		}

	}

/* 
 *                Bidirectional Printing
 *
 *       LPP                 RPP
 *      ______________________
 *      |_____________________|
 *
 *                             <--------------------> nAppendDistance
 *
 *                                Next LPP         Next  RPP
 *                                   _______________
 *                                   |______________|
 *   |---------------------------------------------------------|
 *     CP--->
 */

/* 
 *                Unidirectional Printing
 *
 *      LPP             RPP
 *       ________________
 *       |________________|
 *
 *                         <---------> nAppendDistance
 *
 *                                 Next LPP      Next  RPP
 *                                    _______________
 *                                    |______________|
 *   |---------------------------------------------------------|
 *    CP----->
 */

	if (lpHwData->bPrtCarrDirection == RIGHT)
	{

		if (pfData->bPrintDirection == BIDI)
			nAppendDist = nNextRightPrintPos - nCurrRightPrintPos;
		else
			nAppendDist = nNextLeftPrintPos - nCurrRightPrintPos;

		if (nAppendDist <= 0)
			nAppendDist = 0;

		if (nAppendDist != 0)
		{
// kelvin_trace1("LTOR Stop Before Add = %x\n", (lpHwData->wPrtCarrStopPosition/4));
			//         kelvin_trace1("LTOR Adding = %x\n", (nAppendDist/4));
		}
		lpHwData->wPrtCarrStopPosition += (unsigned short) nAppendDist;

	}

/* Bidirection Printing * * *                              LPP                 RPP * *
 *   ______________________ *                               |_____________________| * * *
 *               <-----> nAppendDistance * *      Next LPP      Next  RPP * * _______________ *
 *     |______________| * * |---------------------------------------------------------| * *
 *          <----CP */

/* 
 *                    Unidirection Printing
 *
 *                             LPP                 RPP
 *                               ______________________
 *                               |_____________________|
 *
 *                       <-------> nAppendDistance
 *
 *     Next LPP      Next  RPP
 *        _______________
 *       |______________|
 *   |---------------------------------------------------------|
 *                                                     <----CP
 */

	else
		/* printing towards left side of page */
	{

		if (pfData->bPrintDirection == BIDI)
			nAppendDist = nCurrLeftPrintPos - nNextLeftPrintPos;
		else
			nAppendDist = nCurrLeftPrintPos - nNextRightPrintPos;

		if (nAppendDist <= 0)
			nAppendDist = 0;

		if (nAppendDist != 0)
		{
// kelvin_trace1("RTOL Stop Before Sub = %x\n", (lpHwData->wPrtCarrStopPosition/4));
			//         kelvin_trace1("RTOL Subtrating Append = %x\n", (nAppendDist/4));
		}

		lpHwData->wPrtCarrStopPosition -= (unsigned short) nAppendDist;

	}
}

/***************************************************************************
 *                                                  Lexmark Confidential
 *
 *  Function Name:
 *    PerformPrintMaintenance
 *
 *  Description:
 *
 *   This function determines if maintenance needs to be performed while
 *   the page is printing.  If the ink dot count exceeds a threshold or
 *   if the time since the last maintenance exceeds a threshold then
 *   maintenance is performed before the line is printed.
 *
 *  Inputs:
 *   None
 *
 *  Outputs:
 *   None
 *
 *  Original Author : K. Profitt
 *  Date: 10/27/94
 *
 *  Changes:
 *   Date       Name             Reason for Change
 *                     
 *************************************************************************/

void PerformPrintMaintenance(LPDVDATAREC lpDataRec)
{

	long lSpitCount, lWipeCount;
	unsigned char i;
	struct pf_data *pfData;
	long dlTime;
	struct tHwData *lpHwData;

#if !defined(DOS_BUILD) && !defined(__riscos)
	dlTime = (long) GetTickCount();
#else
	dlTime = 0;
#endif
	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	lSpitCount = 0;
	lWipeCount = 0;

	/*
	 * If the dot count for either printhead exceeds a certain dot
	 * threshold, then should perform full maintenace ( spit & wipe )
	 */
#if DO_MONO_MAINT												/*  mono head maintenance  */

	if (pfData->bPrintHead == MONO_CARTRIDGE)
	{
		if ((llabs(pfData->alDotCount[MONO_INK] -
								lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][MONO_INK]))
				>= MONO_PRINTING_THRESHOLD
				)
		{
			lSpitCount = lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][MONO_INK];
			lWipeCount = lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][MONO_INK];
			lpHwData->alHwDotCount[LAST_SPIT_TIME][MONO_INK] = dlTime;
			pfData->alDotCount[MONO_INK] += lSpitCount * BLACK_NOZ_CNT;
		}
	}
	else
#endif /* end DO_MONO_MAINT */

#if DO_COLOR_MAINT												/*  color head maintenance  */

	{

		if (((llabs(pfData->alDotCount[YELLOW_INK] -
										lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][YELLOW_INK]))
						>= COLOR_PRINTING_THRESHOLD) ||

				((llabs(pfData->alDotCount[MAGENTA_INK] -
										lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][MAGENTA_INK]))
						>= COLOR_PRINTING_THRESHOLD) ||

				((llabs(pfData->alDotCount[CYAN_INK] -
										lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][CYAN_INK]))
						>= COLOR_PRINTING_THRESHOLD)
				)
		{

			lSpitCount = lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][CYAN_INK];
			lWipeCount = lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][CYAN_INK];

#ifdef DEBUG_MAINT
			kelvin_trace1("Color Spit Count = %ld\n", lSpitCount);
			kelvin_trace1("Color Wipe Count = %ld\n", lWipeCount);
#endif

#ifdef TWO_PEN
			for (i = 0; i < MAX_NUM_INKS; i++)
				pfData->alDotCount[i] += lSpitCount * (COLOR_NOZ_CNT / 3);
#endif

			for (i = CYAN_INK; i <= YELLOW_INK; i++)
			{
				pfData->alDotCount[i] += lSpitCount * (COLOR_NOZ_CNT / 3);
				lpHwData->alHwDotCount[LAST_SPIT_TIME][i] = dlTime;
				pfData->alDotCount[i] += lSpitCount * (COLOR_NOZ_CNT / 3);
			}
		}
	}

#endif /* DO_COLOR_MAINT */

#if DO_KCM_MAINT												/*  KCM head maintenance  */

	if (((llabs(pfData->alDotCount[DILUTED_C_INK] -
									lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][DILUTED_C_INK]))
					>= COLOR_PRINTING_THRESHOLD) ||

			((llabs(pfData->alDotCount[DILUTED_M_INK] -
									lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][DILUTED_M_INK]))
					>= COLOR_PRINTING_THRESHOLD) ||

			((llabs(pfData->alDotCount[DILUTED_K_INK] -
									lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][DILUTED_K_INK]))
					>= COLOR_PRINTING_THRESHOLD)
			)
	{

		lSpitCount = lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][DILUTED_C_INK];
		lWipeCount = lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][DILUTED_C_INK];

		for (i = 0; i < MAX_NUM_INKS; i++)
		{
			pfData->alDotCount[i] += lSpitCount * (COLOR_NOZ_CNT / 3);
			lpHwData->alHwDotCount[LAST_SPIT_TIME][i] = dlTime;
		}

		for (i = DILUTED_C_INK; i <= DILUTED_K_INK; i++)
		{
			lpHwData->alHwDotCount[LAST_SPIT_TIME][i] = dlTime;
			lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][i] = pfData->alDotCount[i];
			lpHwData->alHwDotCount[IDLE_DOT_CNT][i] = pfData->alDotCount[i];
		}

	}															/* end KCM Maintenance */

#endif /* DO_KCM_MAINT */

	if (lSpitCount != 0)
	{
#ifdef DVT
		SendMaintenanceCmd(lpDataRec, (unsigned short) lSpitCount, (unsigned short) lWipeCount);
#endif
		ResetHeadMaintenance(lpDataRec);
	}
	else
	{

#if DO_COLOR_IDLE_MAINT

		if (pfData->bPrintHead == COL_CARTRIDGE)
		{
			/*
			 * The following code is to support maintenance where if
			 * either printhead is idle for more than the specifided Idle Time
			 */
			if ((llabs(dlTime - lpHwData->alHwDotCount[LAST_SPIT_TIME][CYAN_INK])) >=
					lpHwData->alHwDotCount[MAX_IDLE_TIME][CYAN_INK]
					)
			{
				if ((pfData->alDotCount[YELLOW_INK] <= lpHwData->alHwDotCount[IDLE_DOT_CNT][YELLOW_INK]) ||
						(pfData->alDotCount[MAGENTA_INK] <= lpHwData->alHwDotCount[IDLE_DOT_CNT][MAGENTA_INK]) ||
						(pfData->alDotCount[CYAN_INK] <= lpHwData->alHwDotCount[IDLE_DOT_CNT][CYAN_INK])
						)
				{
					lSpitCount = lpHwData->alHwDotCount[IDLE_SPIT_COUNT][CYAN_INK];
					SendSpitCmd(lpDataRec, (unsigned short) lSpitCount);

#ifdef DEBUG_MAINT

					{
						unsigned char n;

						kelvin_traceout("\n\n ************ COLOR IDLE Maintenance **********************\n");

						for (n = 0; n < MAX_NUM_INKS; n++)
							kelvin_trace2("pfData->alDotCount[%1d] = %10ld\n", n,
									pfData->alDotCount[n]);

						for (n = 0; n < MAX_NUM_INKS; n++)
							kelvin_trace2("lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][%1d] = %10ld\n", n,
									lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][n]);

						for (n = 0; n < MAX_NUM_INKS; n++)
							kelvin_trace2("lpHwData->alHwDotCount[IDLE_DOT_CNT][%1d] = %10ld\n", n,
									lpHwData->alHwDotCount[IDLE_DOT_CNT][n]);

						kelvin_trace1("\nIdle Maint k  Time = %ld\n", lpHwData->alHwDotCount[LAST_SPIT_TIME][DILUTED_K_INK]);
						kelvin_trace1("Current Time = %ld\n", dlTime);
						kelvin_trace1("Seconds Since Last Maint = %ld\n", (dlTime - lpHwData->alHwDotCount[LAST_SPIT_TIME][DILUTED_K_INK]) / 1000);

						kelvin_trace1("\nSpitCount = %ld\n", lSpitCount);
						kelvin_trace1("\nWipeCount = %ld\n", lWipeCount);
					}
#endif
					for (i = CYAN_INK; i <= YELLOW_INK; i++)
					{
						pfData->alDotCount[i] += lSpitCount * (COLOR_NOZ_CNT / 3);
						lpHwData->alHwDotCount[LAST_SPIT_TIME][i] = dlTime;
						lpHwData->alHwDotCount[IDLE_DOT_CNT][i] = pfData->alDotCount[i];
					}

#ifdef DEBUG_MAINT
					for (n = 0; n < MAX_NUM_INKS; n++)
						kelvin_trace2("pfData->alDotCount[%1d] = %10ld\n", n,
								pfData->alDotCount[n]);

					for (n = 0; n < MAX_NUM_INKS; n++)
						kelvin_trace2("New lpHwData->alHwDotCount[IDLE_DOT_CNT][%1d] = %10ld\n", n,
								lpHwData->alHwDotCount[IDLE_DOT_CNT][n]);
#endif
				}												/* end no dot check */

			}													/* end time check */

		}														/* end if color printhead */

#endif /* DO_COLOR_IDLE_MAINTENANCE */

#if DO_KCM_IDLE_MAINT											/*  KCM head maintenance  */

		if ((llabs(dlTime - lpHwData->alHwDotCount[LAST_SPIT_TIME][DILUTED_C_INK])) >=
				lpHwData->alHwDotCount[MAX_IDLE_TIME][DILUTED_C_INK]
				)
		{
			if ((pfData->alDotCount[DILUTED_K_INK] <= lpHwData->alHwDotCount[IDLE_DOT_CNT][DILUTED_K_INK]) ||
					(pfData->alDotCount[DILUTED_M_INK] <= lpHwData->alHwDotCount[IDLE_DOT_CNT][DILUTED_M_INK]) ||
					(pfData->alDotCount[DILUTED_C_INK] <= lpHwData->alHwDotCount[IDLE_DOT_CNT][DILUTED_C_INK])
					)
			{
				lSpitCount = lpHwData->alHwDotCount[IDLE_SPIT_COUNT][DILUTED_C_INK];
				SendSpitCmd(lpDataRec, (unsigned short) lSpitCount);

#ifdef DEBUG_MAINT

				kelvin_traceout("\n\n ************ KCM IDLE Maintenance **********************\n");

				for (n = 0; n < MAX_NUM_INKS; n++)
					kelvin_trace2("KCM Idle pfData->alDotCount[%1d] = %10ld\n", n,
							pfData->alDotCount[n]);

				for (n = 0; n < MAX_NUM_INKS; n++)
					kelvin_trace2("lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][%1d] = %10ld\n", n,
							lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][n]);

				for (n = 0; n < MAX_NUM_INKS; n++)
					kelvin_trace2("lpHwData->alHwDotCount[IDLE_DOT_CNT][%1d] = %10ld\n", n,
							lpHwData->alHwDotCount[IDLE_DOT_CNT][n]);

				kelvin_trace1("\nIdle Maint k  Time = %ld\n", lpHwData->alHwDotCount[LAST_SPIT_TIME][DILUTED_K_INK]);
				kelvin_trace1("Current Time = %ld\n", dlTime);
				kelvin_trace1("Seconds Since Last Maint = %ld\n", (dlTime - lpHwData->alHwDotCount[LAST_SPIT_TIME][DILUTED_K_INK]) / 1000);

				kelvin_trace1("\nSpitCount = %ld\n", lSpitCount);
				kelvin_trace1("\nWipeCount = %ld\n", lWipeCount);

#endif
				for (i = DILUTED_C_INK; i <= DILUTED_K_INK; i++)
				{
					pfData->alDotCount[i] += lSpitCount * (COLOR_NOZ_CNT / 3);
					lpHwData->alHwDotCount[LAST_SPIT_TIME][i] = dlTime;
					lpHwData->alHwDotCount[IDLE_DOT_CNT][i] = pfData->alDotCount[i];
				}

#ifdef DEBUG_MAINT

				for (n = 0; n < MAX_NUM_INKS; n++)
					kelvin_trace2("Total Page pfData->alDotCount[%1d] = %10ld\n", n,
							pfData->alDotCount[n]);

				for (n = 0; n < MAX_NUM_INKS; n++)
					kelvin_trace2("New lpHwData->alHwDotCount[IDLE_DOT_CNT][%1d] = %10ld\n", n,
							lpHwData->alHwDotCount[IDLE_DOT_CNT][n]);
#endif
			}

		}

#endif

#if DO_MONO_IDLE_MAINT											/*  mono head maintenance  */

		if ((llabs(dlTime - lpHwData->alHwDotCount[LAST_SPIT_TIME][MONO_INK])) >=
				lpHwData->alHwDotCount[MAX_IDLE_TIME][MONO_INK]
				)
		{
			if (pfData->alDotCount[MONO_INK] <= lpHwData->alHwDotCount[IDLE_DOT_CNT][MONO_INK])
				SendSpitCmd(lpDataRec, (unsigned short) lSpitCount);

			lpHwData->alHwDotCount[LAST_SPIT_TIME][MONO_INK] = dlTime;

			/* Update count for black only so it will spit again if black */
			/* not used */

			lpHwData->alHwDotCount[IDLE_DOT_CNT][MONO_INK] = pfData->alDotCount[MONO_INK];

		}

#endif

	}
}

/***************************************************************************
 * PH_FUNC.C                                        Lexmark Confidential
 *
 *  Function Name:
 *    ResetHeadMaintenance
 *
 *  Description:
 *
 *   This function is called after maintenance is performed to reset
 *   the dot counting variables and time.  The dot counting variables
 *   are used to determine is maintenance is required during printing.
 *
 *  Inputs:
 *   None
 *
 *  Outputs:
 *   None
 *
 *  Original Author : K. Profitt
 *  Date: 10/27/94
 *
 *  Changes:
 *   Date       Name             Reason for Change
 *                     
 *************************************************************************/

void ResetHeadMaintenance(LPDVDATAREC lpDataRec)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;
	long dlStartTime;
	unsigned short n;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

#ifdef DEBUG_MAINT

	kelvin_traceout("\n\n ************ Before ResetMaintenance **********************\n");
	for (n = 0; n < MAX_NUM_INKS; n++)
		kelvin_trace2("Page Dot Count pfData->alDotCount[%1d] = %10ld\n", n,
				pfData->alDotCount[n]);

	for (n = 0; n < MAX_NUM_INKS; n++)
		kelvin_trace2("lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][%1d] = %10ld\n", n,
				lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][n]);

	for (n = 0; n < MAX_NUM_INKS; n++)
		kelvin_trace2("lpHwData->alHwDotCount[IDLE_DOT_CNT][%1d] = %10ld\n", n,
				lpHwData->alHwDotCount[IDLE_DOT_CNT][n]);
#endif

#if !defined(DOS_BUILD) && !defined(__riscos)
	dlStartTime = (long) GetTickCount();
#else
	dlStartTime = 0;
#endif

	/* initial dot count to 0 for all color planes */
	for (n = 0; n < MAX_NUM_INKS; n++)
	{
		lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][n] = pfData->alDotCount[n];
		lpHwData->alHwDotCount[IDLE_DOT_CNT][n] = pfData->alDotCount[n];
		lpHwData->alHwDotCount[LAST_SPIT_TIME][n] = dlStartTime;
	}

	lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][MAGENTA_INK] = COLOR_THRESHOLD_SPIT_CNT;
	lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][CYAN_INK] = COLOR_THRESHOLD_SPIT_CNT;
	lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][YELLOW_INK] = COLOR_THRESHOLD_SPIT_CNT;

	lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][DILUTED_M_INK] = KCM_THRESHOLD_SPIT_CNT;
	lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][DILUTED_C_INK] = KCM_THRESHOLD_SPIT_CNT;
	lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][DILUTED_K_INK] = KCM_THRESHOLD_SPIT_CNT;

	lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][MAGENTA_INK] = COLOR_THRESHOLD_WIPE_CNT;
	lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][CYAN_INK] = COLOR_THRESHOLD_WIPE_CNT;
	lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][YELLOW_INK] = COLOR_THRESHOLD_WIPE_CNT;

	lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][DILUTED_M_INK] = KCM_THRESHOLD_WIPE_CNT;
	lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][DILUTED_C_INK] = KCM_THRESHOLD_WIPE_CNT;
	lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][DILUTED_K_INK] = KCM_THRESHOLD_WIPE_CNT;

	lpHwData->alHwDotCount[IDLE_SPIT_COUNT][MAGENTA_INK] = COLOR_IDLE_SPIT_CNT;
	lpHwData->alHwDotCount[IDLE_SPIT_COUNT][CYAN_INK] = COLOR_IDLE_SPIT_CNT;
	lpHwData->alHwDotCount[IDLE_SPIT_COUNT][YELLOW_INK] = COLOR_IDLE_SPIT_CNT;

	lpHwData->alHwDotCount[IDLE_SPIT_COUNT][DILUTED_M_INK] = KCM_IDLE_SPIT_CNT;
	lpHwData->alHwDotCount[IDLE_SPIT_COUNT][DILUTED_C_INK] = KCM_IDLE_SPIT_CNT;
	lpHwData->alHwDotCount[IDLE_SPIT_COUNT][DILUTED_K_INK] = KCM_IDLE_SPIT_CNT;

	lpHwData->alHwDotCount[MAX_IDLE_TIME][MAGENTA_INK] = COLOR_MAX_IDLE_TIME;
	lpHwData->alHwDotCount[MAX_IDLE_TIME][CYAN_INK] = COLOR_MAX_IDLE_TIME;
	lpHwData->alHwDotCount[MAX_IDLE_TIME][YELLOW_INK] = COLOR_MAX_IDLE_TIME;

	lpHwData->alHwDotCount[MAX_IDLE_TIME][DILUTED_M_INK] = KCM_MAX_IDLE_TIME;
	lpHwData->alHwDotCount[MAX_IDLE_TIME][DILUTED_C_INK] = KCM_MAX_IDLE_TIME;
	lpHwData->alHwDotCount[MAX_IDLE_TIME][DILUTED_K_INK] = KCM_MAX_IDLE_TIME;

	if (lpDataRec->bLeftCartridgeID != KCM_CARTRIDGE)
	{
		lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][MONO_INK] = MONO_THRESHOLD_SPIT_CNT;
		lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][MONO_INK] = MONO_THRESHOLD_WIPE_CNT;
		lpHwData->alHwDotCount[IDLE_SPIT_COUNT][MONO_INK] = MONO_IDLE_SPIT_CNT;
		lpHwData->alHwDotCount[MAX_IDLE_TIME][MONO_INK] = MONO_MAX_IDLE_TIME;
	}

#ifdef DEBUG_MAINT

	kelvin_traceout("\n\n ************ After ResetMaintenance **********************\n");
	for (n = 0; n < MAX_NUM_INKS; n++)
		kelvin_trace2("Total Page Dot Count pfData->alDotCount[%1d] = %10ld\n", n,
				pfData->alDotCount[n]);

	for (n = 0; n < MAX_NUM_INKS; n++)
		kelvin_trace2("lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][%1d] = %10ld\n", n,
				lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][n]);

	for (n = 0; n < MAX_NUM_INKS; n++)
		kelvin_trace2("lpHwData->alHwDotCount[IDLE_DOT_CNT][%1d] = %10ld\n", n,
				lpHwData->alHwDotCount[IDLE_DOT_CNT][n]);
#endif

}

/******************************************************************
 *  FCVOLTA.C                               Lexmark Confidential
 *
 * Function Name:    SendMaintenanceCmd
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to perform printhead maintenance.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void SendMaintenanceCmd(LPDVDATAREC lpDataRec, unsigned short wSpitCount, unsigned short wWipeCount)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;
	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{MAINTENANCE_CMD, MAINT_SPIT_POS,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;

	lpCmd = abPrinterCmd;
	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	if (wSpitCount == 0)
		return;

#ifdef DEBUG_MAINT
	kelvin_traceout("SendMaintenenceCmd Called\n");
	kelvin_traceout("Calling SendCartridgeHome to Printer \n");
	kelvin_trace1("SpitCount = %d\n", wSpitCount);
	kelvin_trace1("WipeCount = %d\n\n", wWipeCount);
#endif

	if (lpHwData->wCurrCarrPos > LEFT_SIDE_FRAME_POSITION)
	{
//		kelvin_traceout("Calling Send Cartridge Home Called\n");
		FCSendCartridgeHome(lpDataRec);
	}

	if (pfData->bPrintHead == COL_CARTRIDGE)
		abPrinterCmd[1] |= MAINT_COLOR;
	else
		abPrinterCmd[1] |= MAINT_MONO;

	abPrinterCmd[2] = (unsigned char) (wSpitCount / 2);
	abPrinterCmd[3] = (unsigned char) wWipeCount;

	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

	lpHwData->wCurrCarrPos = MONO_SPIT_POSITION;

#ifdef DEBUG_MAINT
	kelvin_traceout("Sending Maintenance Cmd Now \n");
#endif

}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    UpdatePageDotCount
 *
 * Description:
 *    This function is called to update dot counts from a maintenance
 *    command sent to the printer.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *          SpitCnt    Number of spits per nozzle
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void UpdatePageDotCount(LPDVDATAREC lpDataRec, unsigned short wSpitCount)
{

	struct pf_data *pfData;
	unsigned char i;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;

	if (wSpitCount == 0)
		return;

	if (pfData->bPrintHead == COL_CARTRIDGE)
	{
		for (i = CYAN_INK; i <= YELLOW_INK; i++)
			pfData->alDotCount[i] += (long) wSpitCount *(long) (COLOR_NOZ_CNT / 3);
	}
	else
		pfData->alDotCount[MONO_INK] += (long) wSpitCount *(long) BLACK_NOZ_CNT;

#ifdef DEBUG_MAINT
	{

		kelvin_traceout("Update Page Dot Counts\n");
		kelvin_trace1("SpitCount = %ld\n", wSpitCount);
		for (i = 0; i < MAX_NUM_INKS; i++)
			kelvin_trace2("Total Page Dot Count pfData->alDotCount[%1d] = %10ld\n", i,
					pfData->alDotCount[i]);
	}
#endif

}

/******************************************************************
 *  FCVOLTA.C                               Lexmark Confidential
 *
 * Function Name:    SendSpitCmd
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to perform printhead maintenance when there
 *    is no wipe command with the spit.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void SendSpitCmd(LPDVDATAREC lpDataRec, unsigned short wSpitCount)
{

	struct pf_data *pfData;
	struct tHwData *lpHwData;
	unsigned char abPrinterCmd[COMMAND_SIZE] =
	{SPIT_CMD, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00};
	unsigned char *lpCmd;

	lpCmd = abPrinterCmd;
	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lpHwData = pfData->lpHwData;

	if (wSpitCount == 0)
		return;

#ifdef DEBUG_MAINT
	kelvin_traceout("SendSpitCmd Called\n");
	kelvin_trace1("SpitCount = %d\n", wSpitCount);
#endif

	if (lpHwData->wCurrCarrPos > (MONO_SPIT_POSITION +
					(unsigned short) ShortestMoveDist(lpHwData, QUALITY_DRAFT, FALSE))
			)

	{
		kelvin_traceout("Position Carrier for Spit - DRAFT SPEED\n");
		lpHwData->wPosCarrStartPosition = lpHwData->wCurrCarrPos;
		lpHwData->wPosCarrStopPosition = MONO_SPIT_POSITION;
		lpHwData->bPosCarrDirection = LEFT;
		lpHwData->bPosCarrSpeed = QUALITY_DRAFT;
	}
	else
	{
		kelvin_traceout("Position Carrier for Spit - SLOW SPEED\n");
		lpHwData->wPosCarrStartPosition = lpHwData->wCurrCarrPos;
		lpHwData->wPosCarrStopPosition = MONO_SPIT_POSITION;
		lpHwData->bPosCarrDirection = LEFT;
		lpHwData->bPosCarrSpeed = SLOW;
	}

	PositionCarrierForPrint(lpDataRec);

	if (pfData->bPrintHead == COL_CARTRIDGE)
		abPrinterCmd[1] |= MAINT_COLOR;
	else
		abPrinterCmd[1] |= MAINT_MONO;

	abPrinterCmd[2] = (unsigned char) (wSpitCount / 2);

#ifdef DEBUG_MAINT
	kelvin_traceout("Sending Spit Cmd Now \n");
#endif
	OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

}

/*******************************************************************
*  PARSEDAT.C  reads ELCTABLE.DAT and ELCPARA.TXT and loads the    *
*  data into a structure for manipulation.  It requires            *
*    <stdio.h> <fckelvin.h> <stdlib.h> or the equivilant           *
*  getword() returns a word read from the file pointed to by the   *
*  file stream pointer passed to it.                               *
*  GetByte() returns a byte read from the file pointed to by the   *
*  file stream pointer passed to it.                               *
*  getzero() reads and discards the number of bytes referenced in  *
*  the integer passed to it from the file pointed to by the file   *
*  stream pointer passed to it.                                    *
*  ParseParmFile() reads ELCPARA.TXT and loads the data found therein   *
*  into the structure pointed to by tHwData.                       *
*  parse() uses the above functions to read the data in ELCPARA.TXT*
*  and ELCTABLE.DAT into the structure pointed to by tHwData.      *
*                                           Jay Vessels  #988396   *
*******************************************************************/
#define MSBSET   0x80											/*This masks the high bit */
#define FILE_IN_TXT "ELCPARA.TXT"
#define FILE_IN_DAT "ELCTABLE.DAT"

unsigned short GetWord(unsigned char *lpbBuffer, int *lpnSize)	/* read a word from *lpbBuffer */
{
	unsigned char lobyte;
	unsigned char hibyte;
	unsigned short data;

	hibyte = GetByte(lpbBuffer, lpnSize);
	lobyte = GetByte(lpbBuffer + 1, lpnSize);
	data = (unsigned short) (lobyte + (hibyte * 256));
	return data;
}

unsigned char GetByte(unsigned char *lpbBuffer, int *lpnSize)	/* read a byte from a file */
{
	*lpnSize -= 1;
	return (*lpbBuffer);
}

void getzero(unsigned char *lpbBuffer, int *lpnSize, int zero)	/*discard 'zero' bytes from *lpbBuffer */
{
	int loop;

	for (loop = 0; loop < zero; loop++)
		GetByte(lpbBuffer, lpnSize);
}

// #define TSTRMP
BOOL ParseHwFile(struct tHwData *lpHwData)						/* parse the file ELCTABLE.DAT */
{
	unsigned short loop, endloop;
	unsigned char command;
	long dwBufSize;
	int *lpnSize;
	unsigned char *lpbBuffer;

#if defined(DOS_BUILD) || defined(__riscos)
	FILE *hfHwData;

#ifdef TSTRMP
	FILE *rmpfp;

#endif
	unsigned char *lpbBufStart;

#else
#ifdef TSTRMP
	HFILE rmpfp;
	long i;

#endif
	HFILE hfHwData;
	OFSTRUCT of;

#endif

	lpnSize = (int *) &dwBufSize;
	dwBufSize = 0;
	lpbBuffer = NULL;

	ParseParmFile(lpHwData);									// First read and parse the data in ELCPARA.TXT

#if defined(DOS_BUILD) || defined(__riscos)

	if ((hfHwData = fopen(FILE_IN_DAT, "rb")) == NULL)			/*open the file */
	{
		return (FALSE);
	}

#ifdef TSTRMP
	if ((rmpfp = fopen("ramp.dat", "wb")) == NULL)				/*open the file */
		return (FALSE);
#endif

	lpbBuffer = (unsigned char *) MALLOC(2000);
	lpbBufStart = lpbBuffer;

	while (!feof(hfHwData))
	{
		*lpbBuffer++ = fgetc(hfHwData);
		dwBufSize++;
	}

	lpbBuffer = lpbBufStart;
	fclose(hfHwData);

#ifdef TSTRMP
	for (i = 0; i < dwBufSize; i++)
		fputc(*(lpbBuffer + i), rmpfp);
	fclose(rmpfp);
#endif

#else

	hfHwData = OpenFile(FILE_IN_DAT, &of, OF_READ | OF_SEARCH);
	if (hfHwData == HFILE_ERROR)
	{
#ifdef DVT
// kelvin_traceout ("error opening elctable.dat file - returning\n");
#endif
		return (FALSE);
	}
	else
		kelvin_traceout(" opened elctable.dat file \n");

#ifdef TSTRMP
	rmpfp = OpenFile("ramp.dat", &of, OF_WRITE | OF_CREATE);

	if (rmpfp == HFILE_ERROR)
	{
		lclose(hfHwData);
#ifdef DVT
// kelvin_traceout ("error opening ramp.dat file - returning\n");
#endif
		return (FALSE);
	}

#endif
// kelvin_traceout ("Both files opened\n");

	/* Find out the length of the file */
	dwBufSize = _llseek(hfHwData, 0, 2);

// kelvin_trace1("dwBufSize - ramp data = %x\n", dwBufSize);

	/* Return to start of file */
	_llseek(hfHwData, 0, 0);

	if (dwBufSize == -1)
	{

		kelvin_traceout("error getting size of elctable.dat file - returning\n");
		_lclose(hfHwData);
		return (FALSE);
	}

	lpbBuffer = (unsigned char *) MALLOC(dwBufSize);

	if (lpbBuffer == NULL)
	{
		_lclose(hfHwData);
		kelvin_traceout("error allocating memory for lpbBuffer - returning\n");
		if (lpbBuffer)
			FREE(lpbBuffer);
		return (FALSE);
	}

	_lread(hfHwData, lpbBuffer, (unsigned short) dwBufSize);

	_lclose(hfHwData);

#ifdef TSTRMP
	_lwrite(rmpfp, lpbBuffer, dwBufSize);
	_lclose(rmpfp);
#endif

#endif

	while (*lpnSize > 0)										/*loop through and parse each byte */
	{															/*last byte will be a 0xFF, ignored */
		switch ((command = GetByte(lpbBuffer++, lpnSize)))		/*by the parser                    */
		{
		case SET_INIT_1_CMD:
			lpHwData->wPaperLoadStepCntA = GetWord(lpbBuffer++, lpnSize);
			lpbBuffer += 1;
			lpHwData->wPaperLoadStepCntB = GetWord(lpbBuffer++, lpnSize);
			lpbBuffer += 1;
			lpHwData->wManualFeedStepCnt = GetWord(lpbBuffer++, lpnSize);
			lpbBuffer += 1;
			getzero(lpbBuffer++, lpnSize, 1);					/*last byte is always 0 */
			break;

		case SET_INIT_2_CMD:
			lpHwData->bHomeStepCnt = GetByte(lpbBuffer++, lpnSize);
			lpHwData->wPaperEjectStepCnt = GetWord(lpbBuffer++, lpnSize);
			lpbBuffer += 1;
			lpHwData->bMonoFirePulse = GetByte(lpbBuffer++, lpnSize);
			lpHwData->bColorFirePulse = GetByte(lpbBuffer++, lpnSize);
			getzero(lpbBuffer++, lpnSize, 2);					/*the last two bytes are always 0 */
			lpbBuffer += 1;
			break;

		case FEED_ACCEL_DECEL_CMD:
			for (loop = 0; loop < 7; loop++)
				lpHwData->bPaperRampTableType[loop] = GetByte(lpbBuffer++, lpnSize);
			break;

		case FEED_RAMP_CMD:
			lpHwData->wPaperRampSRAMOffset = GetWord(lpbBuffer++, lpnSize);
			lpbBuffer += 1;
			lpHwData->wPaperRampTableLength = GetWord(lpbBuffer++, lpnSize);
			lpbBuffer += 1;
			getzero(lpbBuffer++, lpnSize, 3);					/*bytes 6-8 are always 0 */
			lpbBuffer += 2;
			endloop = lpHwData->wPaperRampTableLength;
			for (loop = 0; loop < endloop; loop++)
				lpHwData->bPaperRampTableData[loop] = GetByte(lpbBuffer++, lpnSize);
			break;

		case CARR_ACCEL_DECEL_CMD:
			switch (GetByte(lpbBuffer++, lpnSize))
			{
			case DATA_OFFSET_9IPS:
				lpHwData->bAccelStepCnt3 = GetByte(lpbBuffer++, lpnSize);
				lpHwData->bDecelStepCnt3 = GetByte(lpbBuffer++, lpnSize);
				lpHwData->wDecelOffsetAddr3 = GetWord(lpbBuffer++, lpnSize);
				lpbBuffer += 1;
				break;

			case DATA_OFFSET_16IPS:
				lpHwData->bAccelStepCnt16 = GetByte(lpbBuffer++, lpnSize);
				lpHwData->bDecelStepCnt16 = GetByte(lpbBuffer++, lpnSize);
				lpHwData->wDecelOffsetAddr16 = GetWord(lpbBuffer++, lpnSize);

				lpbBuffer += 1;
				break;

			case DATA_OFFSET_25IPS:
				lpHwData->bAccelStepCnt25 = GetByte(lpbBuffer++, lpnSize);
				lpHwData->bDecelStepCnt25 = GetByte(lpbBuffer++, lpnSize);
				lpHwData->wDecelOffsetAddr25 = GetWord(lpbBuffer++, lpnSize);
				lpbBuffer += 1;
				break;
			}
			getzero(lpbBuffer++, lpnSize, 2);					/*bytes 7,8 are always 0 */
			lpbBuffer += 1;
			break;

		case CARR_RAMP_CMD:
			lpHwData->wCarrRampSRAMOffset = GetWord(lpbBuffer++, lpnSize);
			lpbBuffer += 1;
			lpHwData->wCarrRampTableLength = GetWord(lpbBuffer++, lpnSize);
			lpbBuffer += 1;
			getzero(lpbBuffer++, lpnSize, 3);					/*bytes 6-8 are always 0 */
			lpbBuffer += 2;
			endloop = lpHwData->wCarrRampTableLength;
			for (loop = 0; loop < endloop; loop++)
				lpHwData->bCarrRampTableData[loop] = GetByte(lpbBuffer++, lpnSize);
			break;
		default:
			break;
		}
	}

	FREE(lpbBuffer);
	return (TRUE);
}

/* This is a function to read the file ELCpara.txt and write the appropriate data into lpHwData */

void ParseParmFile(struct tHwData *lpHwData)
{
	long dwBufSize;
	unsigned char *lpbBuffer;
	char align;

	FILE *hfHwData;
	unsigned char *lpbBufStart;

	kelvin_trace0("Reading parameter file\n");

	if ((hfHwData = fopen(FILE_IN_TXT, "rb")) == NULL)			/*open the file */
		return;

	lpbBuffer = (unsigned char *) MALLOC(2000);
	lpbBufStart = lpbBuffer;
	dwBufSize = 0;

	while (!feof(hfHwData))
	{
		*lpbBuffer++ = fgetc(hfHwData);
		dwBufSize++;
	}

	lpbBuffer = lpbBufStart;

	fclose(hfHwData);

	lpHwData->bAccelStepCnt3 = (unsigned char) *lpbBuffer++;
	lpHwData->bAlphaStepCnt3 = (unsigned char) *lpbBuffer++;
	lpHwData->bDecelStepCnt3 = (unsigned char) *lpbBuffer++;

	lpHwData->bAccelStepCnt16 = (unsigned char) *lpbBuffer++;
	lpHwData->bAlphaStepCnt16 = (unsigned char) *lpbBuffer++;
	lpHwData->bDecelStepCnt16 = (unsigned char) *lpbBuffer++;

	lpHwData->bAccelStepCnt25 = (unsigned char) *lpbBuffer++;
	lpHwData->bAlphaStepCnt25 = (unsigned char) *lpbBuffer++;
	lpHwData->bDecelStepCnt25 = (unsigned char) *lpbBuffer++;

	align = (char) *lpbBuffer++;
	lpHwData->nMonoLeftBidiAlign = (int) align;
	align = (char) *lpbBuffer++;
	lpHwData->nMonoRightBidiAlign = (int) align;
	align = (char) *lpbBuffer++;
	lpHwData->nColorLeftBidiAlign = (int) align;
	align = (char) *lpbBuffer++;
	lpHwData->nColorRightBidiAlign = (int) align;

#if 0
	fscanf(hfHwData, "3 Accel step count = %d\n", WordPtr);
	lpHwData->bAccelStepCnt3 = (unsigned char) *WordPtr;
	fscanf(hfHwData, "3 Alpha step count = %d\n", WordPtr);
	lpHwData->bAlphaStepCnt3 = (unsigned char) *WordPtr;
	fputc((unsigned char) *WordPtr, rmpfp);
	fscanf(hfHwData, "3 Decel step count = %d\n", WordPtr);
	lpHwData->bDecelStepCnt3 = (unsigned char) *WordPtr;

	fscanf(hfHwData, "16.7 Accel step count = %d\n", WordPtr);
	lpHwData->bAccelStepCnt16 = (unsigned char) *WordPtr;
	fscanf(hfHwData, "16.7 Alpha step count = %d\n", WordPtr);
	lpHwData->bAlphaStepCnt16 = (unsigned char) *WordPtr;
	fputc((unsigned char) *WordPtr, rmpfp);
	fscanf(hfHwData, "16.7 Decel step count = %d\n", WordPtr);
	lpHwData->bDecelStepCnt16 = (unsigned char) *WordPtr;

	fscanf(hfHwData, "25 Accel step count = %d\n", WordPtr);
	lpHwData->bAccelStepCnt25 = (unsigned char) *WordPtr;
	fscanf(hfHwData, "25 Alpha step count = %d\n", WordPtr);
	lpHwData->bAlphaStepCnt25 = (unsigned char) *WordPtr;
	fputc((unsigned char) *WordPtr, rmpfp);
	fscanf(hfHwData, "25 Decel step count = %d\n", WordPtr);
	lpHwData->bDecelStepCnt25 = (unsigned char) *WordPtr;

#endif

	FREE(lpbBuffer);

}

int lnabs(int n)
{
	if (n < 0)
		return (n * (-1));
	else
		return (n);
}

long llabs(long n)
{
	if (n < 0)
		return (n * (-1));
	else
		return (n);
}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    FCCalcBidiAlign
 *
 * Description:
 *    This function is called from the driver to calculate
 *    the bidi alignment numbers based on the user input and
 *    the alignment numbers that were stored in an ini file.
 *    This function is only used for printers that do not
 *    perform bidirectional alignment in the printer code.
 *
 * Inputs:  lpDataRec      Far pointer to print device structure.
 *          lpBidiAlign    Far pointer to bidirectional alignment values
 *
 * Outputs: lpBidiAlign     Updated bidirectional alignment values
 *
 * Original Author: K. Profitt
 * Date: 01/17/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
#ifdef BIDI_ALIGN

void FCCalcBidiAlign(LPBIDIALIGN lpBidiAlign)
{

#if 0
	kelvin_trace1("lpBidiAlign->cColorUserInput = %d\n", lpBidiAlign->cColorUserInput);
	kelvin_trace1("lpBidiAlign->cColorRightBidiAlign = %d\n", lpBidiAlign->nColorRightBidiAlign);
	kelvin_trace1("lpBidiAlign->cColorLeftBidiAlign = %d\n\n", lpBidiAlign->nColorLeftBidiAlign);
	kelvin_trace1("lpBidiAlign->cMonoUserInput = %d\n", lpBidiAlign->cMonoUserInput);
	kelvin_trace1("lpBidiAlign->cMonoLeftBidiAlign = %d\n", lpBidiAlign->nMonoLeftBidiAlign);
	kelvin_trace1("lpBidiAlign->cMonoRightBidiAlign = %d\n\n", lpBidiAlign->nMonoRightBidiAlign);
#endif

	if ((lpBidiAlign->cMonoUserInput == -1) &&
			(lpBidiAlign->cColorUserInput == -1))
	{
		kelvin_trace0("CalcBidiAlign returning Defaults\n");
		lpBidiAlign->nMonoLeftBidiAlign = MONO_LEFT_BIDI_ALIGN;
		lpBidiAlign->nMonoRightBidiAlign = MONO_RIGHT_BIDI_ALIGN;
		lpBidiAlign->nColorLeftBidiAlign = COLOR_LEFT_BIDI_ALIGN;
		lpBidiAlign->nColorRightBidiAlign = COLOR_RIGHT_BIDI_ALIGN;
	}
	else
	{
		if (lpBidiAlign->cMonoUserInput != -1)
		{
			if ((lpBidiAlign->cMonoUserInput / 2) < (MAX_BIDI_ALIGN / 2))
				lpBidiAlign->nMonoLeftBidiAlign = MONO_LEFT_BIDI_ALIGN + ((MAX_BIDI_ALIGN / 2) - lpBidiAlign->cMonoUserInput);
			else
				lpBidiAlign->nMonoLeftBidiAlign = MONO_LEFT_BIDI_ALIGN - ((MAX_BIDI_ALIGN / 2) - lpBidiAlign->cMonoUserInput);
		}

		if (lpBidiAlign->cColorUserInput != -1)
		{
			if ((lpBidiAlign->cColorUserInput / 2) < (MAX_BIDI_ALIGN / 2))
				lpBidiAlign->nColorLeftBidiAlign = COLOR_LEFT_BIDI_ALIGN + ((MAX_BIDI_ALIGN / 2) - lpBidiAlign->cColorUserInput);
			else
				lpBidiAlign->nColorLeftBidiAlign = COLOR_LEFT_BIDI_ALIGN - ((MAX_BIDI_ALIGN / 2) - lpBidiAlign->cColorUserInput);
		}
	}

#if 0
	kelvin_trace0("After calculations\n");
	kelvin_trace1("lpBidiAlign->cColorUserInput = %d\n", lpBidiAlign->cColorUserInput);
	kelvin_trace1("lpBidiAlign->cColorRightBidiAlign = %d\n", lpBidiAlign->nColorRightBidiAlign);
	kelvin_trace1("lpBidiAlign->cColorLeftBidiAlign = %d\n\n", lpBidiAlign->nColorLeftBidiAlign);
	kelvin_trace1("lpBidiAlign->cMonoUserInput = %d\n", lpBidiAlign->cMonoUserInput);
	kelvin_trace1("lpBidiAlign->cMonoLeftBidiAlign = %d\n", lpBidiAlign->nMonoLeftBidiAlign);
	kelvin_trace1("lpBidiAlign->cMonoRightBidiAlign = %d\n\n", lpBidiAlign->nMonoRightBidiAlign);
#endif

}

#endif

void PopulateBitCount(LPDVDATAREC lpDataRec)
{
	/* silence the compiler */
	lpDataRec = lpDataRec;
	return;
}
