//#pragma warning (disable: 4103)  /* used #pragma pack to change alignment */

//#include <memory.h>
//#include <malloc.h>
#include "common.h"
//#include "fclocal.h"
//#include <stdlib.h>
//#include <string.h>
//#include "kernel.h"
//#include "swis.h"

static char fc_version[] = "product.obj: "FC_VERSION;  /* set object module level ID */

#ifdef GEN_COL_BIDI
BYTE bNumBidiSwaths;
#endif /* GEN_COL_BIDI */

/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name:    OutToFile
 *
 * Description:
 *    This function outputs print swath data into a file.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to file.
 *
 * Major Functions Called:  fwrite
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void OutToFile(LPDVDATAREC lpDataRec, void *pOutString, unsigned long dwLength)
{
	_kernel_swi_regs r;

#ifdef FAKEDFSERROR
	r.r[0] = 129;
	r.r[1] = -3;
	r.r[2] = -3 >> 8;
	(void) _kernel_swi(OS_Byte, &r, &r);
	if (r.r[1])
	{
		static _kernel_oserror fake = { 0, "Simulated DeviceFS error" };
		THROW(&fake);
	}
#endif

#ifdef CHECKBUSY
	/* AA 11/2/98: Added this test which should throw an error if the
	 * printer isn't ready. Should we retry though?
	 */
	r.r[0] = 0;
	THROW(_kernel_swi(Parallel_Op, &r, &r));
	if ((r.r[2] & 0x80) == 0)
	{
		THROW(&kelvin_notready);
	}
#endif

	kelvin_trace3("Sending %d bytes to file handle %d (%p)\n", dwLength, lpDataRec->flOutFile, lpDataRec);

	r.r[0] = 2;
	r.r[1] = (int) lpDataRec->flOutFile;

#ifdef TEXTPRINT
	if (wedge_getcooked())
	{
		unsigned char esc[] = { 27, '%', 0, 0, 0 };
		esc[2] = (dwLength >>  0) & 0xFF;
		esc[3] = (dwLength >>  8) & 0xFF;
		esc[4] = (dwLength >> 16) & 0xFF;
		r.r[2] = (int) esc;
		r.r[3] = 5;
		THROW(_kernel_swi(OS_GBPB, &r, &r));
	}
#endif

	r.r[2] = (int) pOutString;
	r.r[3] = (int) dwLength;

	THROW(_kernel_swi(OS_GBPB, &r, &r));
}

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    HwStartPrintJob
 *
 * Description:
 *    This function is called at the beginning of a document and
 *    can send the printer any required information for the
 *    job start.  Some printers may not require any special
 *    data to be sent.  The printer specific hardware structure
 *    is also initialized here.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void     HwStartPrintJob(LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;

#ifdef TEST
   FILE *flOutFile;
#endif /* TEST */


   lpCmd = abPrinterCmd;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   if (pfData != NULL)
      lpHwData = pfData->lpHwData;
   else
      return;


   /* Clear hardware data arrays */

   MEMSET(lpHwData->bCarrRampTableData,0x00,MAX_CARRIER_RAMP_SIZE);
   MEMSET(lpHwData->bPaperRampTableData,0x00,MAX_PAPER_RAMP_SIZE);
   MEMSET(lpHwData->bPaperRampTableType,0x00,MAX_RAMP_TABLE_CNT);

   /* Init Hw data stucture */
#ifdef DOS_BUILD
   lpHwData->bTestPrintDir = LTOR;
#endif /* DOS_BUILD */
   lpHwData->bInstallCartridge = FALSE;
   lpHwData->bMonoFirePulse = MONO_FIRE_PULSE;
   lpHwData->bColorFirePulse = COLOR_FIRE_PULSE;
   lpHwData->bHomeStepCnt = HOME_POSITION_STEP_CNT;
   lpHwData->wPaperLoadStepCntA = PAPER_LOAD_STEP_CNT_A;
   lpHwData->wPaperLoadStepCntB = PAPER_LOAD_STEP_CNT_B;
   lpHwData->wPaperEjectStepCnt = PAPER_EJECT_STEP_CNT;
   lpHwData->wManualFeedStepCnt = MANUAL_FEED_STEP_CNT;
   lpHwData->bPaperRampTableSpeed = 0;
   lpHwData->wPaperRampSRAMOffset = PAP_RAMP_SRAM_OFFSET;
   lpHwData->wPaperRampTableLength = MAX_PAPER_RAMP_SIZE;
   lpHwData->bAccelStepCntSlow = ACCEL_STEP_9IPS;
   lpHwData->bAlphaStepCntSlow = ALPHA_STEP_9IPS;
   lpHwData->bDecelStepCntSlow = DECEL_STEP_9IPS;
   lpHwData->wDecelOffsetAddrSlow = DECEL_OFFSET_9IPS;
   lpHwData->bAccelStepCntNormal = ACCEL_STEP_16IPS;
   lpHwData->bAlphaStepCntNormal = ALPHA_STEP_16IPS;
   lpHwData->bDecelStepCntNormal = DECEL_STEP_16IPS;
   lpHwData->wDecelOffsetAddrNormal = DECEL_OFFSET_16IPS;
   lpHwData->bAccelStepCntFast = ACCEL_STEP_25IPS;
   lpHwData->bAlphaStepCntFast = ALPHA_STEP_25IPS;
   lpHwData->bDecelStepCntFast = DECEL_STEP_25IPS;
   lpHwData->wDecelOffsetAddrFast = DECEL_OFFSET_25IPS;
   lpHwData->wCarrRampSRAMOffset = CAR_RAMP_SRAM_OFFSET;
   lpHwData->wCarrRampTableLength = MAX_CARRIER_RAMP_SIZE;
   lpHwData->wPrintSRAMOffset = PRINT_SRAM_OFFSET;
   lpHwData->bPrtCarrDirection = NO_DIRECTION;
   lpHwData->wPrtStartPosition = 0;
   lpHwData->wPrtCarrStopPosition = 0;
   lpHwData->wPrtCarrStartPosition = 0;
   lpHwData->bPrtCarrSpeed = SPEED_STOPPED;
   lpHwData->bPosCarrDirection = NO_DIRECTION;
   lpHwData->wPosCarrStopPosition = 0;
   lpHwData->wPosCarrStartPosition = 0;
   lpHwData->bPosCarrSpeed = SPEED_STOPPED;
   lpHwData->wCurrCarrPos = LEFT_SIDE_FRAME_POSITION;
   lpHwData->wColorHeadOffset = COLOR_POS_OFFSET;
   lpHwData->wMonoHeadOffset = MONO_POS_OFFSET;

#ifdef BIDI_ALIGN
   lpHwData->nMonoLeftBidiAlign = lpDataRec->nLeftBidiAlignMono;
   lpHwData->nMonoRightBidiAlign = lpDataRec->nRightBidiAlignMono;
   lpHwData->nColorLeftBidiAlign = lpDataRec->nLeftBidiAlignColor;
   lpHwData->nColorRightBidiAlign = lpDataRec->nRightBidiAlignColor;
#else /* BIDI_ALIGN */
   lpHwData->nMonoLeftBidiAlign = MONO_LEFT_BIDI_ALIGN;
   lpHwData->nMonoRightBidiAlign = MONO_RIGHT_BIDI_ALIGN;
   lpHwData->nColorLeftBidiAlign = COLOR_LEFT_BIDI_ALIGN;
   lpHwData->nColorRightBidiAlign = COLOR_RIGHT_BIDI_ALIGN;
#endif /* BIDI_ALIGN */

#ifdef USE_DRIVER_RAMP
   /* Init and send HW values from external files if they exist */
   if (ParseHwFile(pfData->lpHwData) )
   {
      * (lpCmd+0) = SET_INIT_1_CMD;
      *(lpCmd+1) = HIBYTE(lpHwData->wPaperLoadStepCntA);
      *(lpCmd+2) = LOBYTE(lpHwData->wPaperLoadStepCntA);
      *(lpCmd+3) = HIBYTE(lpHwData->wPaperLoadStepCntB);
      *(lpCmd+4) = LOBYTE(lpHwData->wPaperLoadStepCntB);
      *(lpCmd+5) = HIBYTE(lpHwData->wManualFeedStepCnt);
      *(lpCmd+6) = LOBYTE(lpHwData->wManualFeedStepCnt);




      OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

      /* send fire pulse to printer */

      *(lpCmd+0) = SET_INIT_2_CMD;
      *(lpCmd+1) = lpHwData->bHomeStepCnt;
      *(lpCmd+2) = HIBYTE(lpHwData->wPaperEjectStepCnt);
      *(lpCmd+3) = LOBYTE(lpHwData->wPaperEjectStepCnt);
      *(lpCmd+4) = lpHwData->bMonoFirePulse;
      *(lpCmd+5) = lpHwData->bColorFirePulse;
      *(lpCmd+6) = 0x00;

      OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

      SendPaperRampTables(lpDataRec);
      SendCarrierRampTables(lpDataRec);
   }

#endif /* USE_DRIVER_RAMP */

#ifdef ELAPSED_MAINT
   /* Kelvin firmware (041497) is not performing POR and 8-hour idle time maintenance as spec'd
      We address this in the firmware by having the driver record a time/date stamp for each print job,
      and as a new print job is initiated, set the secondsSinceLastPrint field.  This field is used as the print job is
      started to set the porMaintenanceRequired field in lpHwData, so we know at the start of the first page to do POR
      maintenance instead of the more limited  begin of page maintenance. */
   if (lpDataRec->secondsSinceLastPrint > FULL_MAINTENANCE_SECONDS)
      lpHwData->porMaintenanceRequired = TRUE;
   else
      lpHwData->porMaintenanceRequired = FALSE;
#endif /* ELAPSED_MAINT */

   lpHwData->wPrintSRAMOffset = 0x00;
   lpHwData->bPrtCarrDirection = NO_DIRECTION;
   lpHwData->wPrtStartPosition = 0;
   lpHwData->wPrtCarrStopPosition = 0;
   lpHwData->wPrtCarrStartPosition = 0;
   lpHwData->bPrtCarrSpeed = SPEED_STOPPED;
   lpHwData->bPosCarrDirection = NO_DIRECTION;
   lpHwData->wPosCarrStopPosition = 0;
   lpHwData->wPosCarrStartPosition = 0;
   lpHwData->bPosCarrSpeed = SPEED_STOPPED;
   lpHwData->wCurrCarrPos = LEFT_SIDE_FRAME_POSITION;

#ifdef TEST
   fclose(flOutFile);
#endif /* TEST */

#ifdef FUNAIPPF
   /* for FUNAI PPF printer, send a start document command to the printer  */
   *(lpCmd+0) = 0x52;
   *(lpCmd+1) = 0x01;
   *(lpCmd+2) = 0x00;
   *(lpCmd+3) = 0x00;
   *(lpCmd+4) = 0x00;
   *(lpCmd+5) = 0x00;
   *(lpCmd+6) = 0x00;
   *(lpCmd+7) = 0x00;
   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);
#endif

    return;
}  /* end of HwStartPrintJob() */




/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    HwStartPage
 *
 * Description:
 *    This function is called at the beginning of a page and
 *    can send the printer any required information for the
 *    page start.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
void     HwStartPage(LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   WORD                spitCount, wipeCount;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   lpHwData->dwPaperStepCount = 0;

   FcFormFeed(lpDataRec);

   ResetHeadMaintenance(lpDataRec);

   /* sync up with carrier position so send it home */
   FCSendCartridgeHome(lpDataRec);

#ifdef ELAPSED_MAINT
   /* Changes for firmware maintenance problems (PTR kv000140) - do POR
    * maintenance when elapsed time between print jobs exceeds a value. */
   if (lpHwData->porMaintenanceRequired)
   {
      lpHwData->porMaintenanceRequired = FALSE;  /* we did it, don't do it again on next page */
          spitCount = INSTALL_SPIT_CNT;
          wipeCount = INSTALL_WIPE_CNT;
   }
   else
#endif /* ELAPSED_MAINT */
   {
      spitCount = BETWEEN_PAGE_SPIT_CNT;
      wipeCount = BETWEEN_PAGE_WIPE_CNT;
   }
   SendMaintenanceCmd (lpDataRec, spitCount, wipeCount);
   UpdatePageDotCount(lpDataRec, (WORD)(spitCount * wipeCount));

#ifdef GEN_COL_BIDI
   bNumBidiSwaths = 0;
#endif /* GEN_COL_BIDI */

   /* HACK :  Send down extra commands that will not impact
      print job in case there is a paper out.  After a paper
      out, the page is resent.  However, there can be data
      leftover from the first start of the page in the port
      buffer which is sent also.   Therefore, need to "pad" the
      port buffer with data that will not impact paper out. */

   FcFormFeed(lpDataRec);
   FcFormFeed(lpDataRec);
   FcFormFeed(lpDataRec);
   FcFormFeed(lpDataRec);
   FcFormFeed(lpDataRec);
   FcFormFeed(lpDataRec);
   FcFormFeed(lpDataRec);
   FcFormFeed(lpDataRec);
   FcFormFeed(lpDataRec);
}  /* end of HwStartPage() */


/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    HwStartPage
 *
 * Description:
 *    This function is called at the end of a page and
 *    can send the printer any required information for the
 *    page end.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
void     HwEndPage(LPDVDATAREC lpDataRec)
{

   FCSendCartridgeHome(lpDataRec);
   FCEjectPage(lpDataRec);

}  /* end of HwEndPage() */


/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    HwEndJob
 *
 * Description:
 *    This function is called at the end of a job and
 *    can send the printer any required information for the
 *    job end.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/

void     HwEndJob(LPDVDATAREC lpDataRec)
{
   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;

   lpCmd = abPrinterCmd;

   /* Silence the compiler */
   lpDataRec = lpDataRec;

#ifdef FUNAIPPF
   /* for FUNAI PPF printer, send an end of document command to the printer */
   *(lpCmd+0) = 0x53;
   *(lpCmd+1) = 0x01;
   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);
#endif

   return;
}  /* end of HwEndJob() */



/***************************************************************************
 *  FCKELVIN.C                                     Lexmark Confidential
 *
 * Function Name:    OutputSwath
 *
 * Description:
 *    This function is responsible for everything that needs to
 *    happen when one swath buffer is sent to the printer for
 *    printing.  Linefeed is called to move the paper to the
 *    correct position for the swath followed by the swath
 *    data.
 *
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void OutputSwath(LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   struct tPrintCmd FAR *pPrtCmd;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   pPrtCmd = (struct tPrintCmd FAR *) pfData->pPrtCmd;

   LineFeed(lpDataRec);   /* for top margin */

   if (IsCarrierInMaintStation(lpDataRec)==TRUE)
   {
       SendMaintenanceCmd(lpDataRec, UNCAP_SPIT_CNT,UNCAP_WIPE_CNT);
       UpdatePageDotCount(lpDataRec, UNCAP_SPIT_CNT * UNCAP_WIPE_CNT);
   }

   /*
    * Calculate where the carrier needs to be to start printing
    * and output the command to move the carrier to the
    *  correct posiiton.
    */


   CalcCarrierPositions(lpDataRec,FALSE);
   PositionCarrierForPrint(lpDataRec);

   /*
    *  Now check the next swath positions to be printed
    *  and append any distance required to setup for the
    *  next swath to the print stop position.
    */

    CalculateAppendDistance(lpDataRec);

   /* Send the swath data to the printer */
   OutputSwathInfo(lpDataRec);

    /* Now calculate the return move so the carrier is in position for the
      next swath */

   CalcCarrierPositions(lpDataRec,TRUE);

   SetupPrinterForNextSwath(lpDataRec);
   OutputPrintSliceData(lpDataRec);

   PerformPrintMaintenance (lpDataRec);

}  /* end of OutputSwath() */



/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    OutputSwathInfo
 *
 * Description:
 *    This function outputs the swath data and buffer to the
 *    printer in the expected format.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
void OutputSwathInfo(LPDVDATAREC lpDataRec)
{

   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {SWATH_INFO_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;
   WORD wNumCarrStep;
   BYTE bDir;
   BYTE bPrintSpeed;
   BYTE bMonoHead;
   BYTE bRes;
   BYTE bSliceBytes;
   int  nPrintPos;
   int  nPrintOffset;

   lpCmd = abPrinterCmd;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   if (pfData->bPrintHead == MONO_CARTRIDGE)
   {
      bMonoHead = MONO_HEAD;
      nPrintOffset = (MONO_NOZZLE_OFFSET * pfData->nSwathResMult);
   }
   else
   {
      bMonoHead = COLOR_HEAD;
      nPrintOffset = (COLOR_NOZZLE_OFFSET * pfData->nSwathResMult);
   }

   if ( (pfData->bResolution == LORES) || ( pfData->bResolution == SUPERLOWRES ) )
      bRes = NORMAL_RES_300;
   else
      bRes = HIGH_RES_600;

   if (pfData->bBytesPerSlice == 6)
      bSliceBytes = BYTES_6;
   else
      bSliceBytes = BYTES_7;

   if (pfData->bPrintQuality == QUALITY_DRAFT)
      bPrintSpeed = PRINT_DRAFT;
/*    bPrintSpeed = CAR_MOVE_25; */
   else
   {
      bPrintSpeed = PRINT_LQ;

#ifdef GEN_BIDI
      bPrintSpeed = PRINT_DRAFT;
/*    bPrintSpeed = PRINT_LQ;    */
#endif /* GEN_BIDI */
   }
/*        bPrintSpeed = CAR_MOVE_16;     */

   if (lpHwData->bPrtCarrDirection == RIGHT )
      bDir = FORWARD_PRINT;
   else
      bDir = REVERSE_PRINT;

   *(lpCmd + 1) = (BYTE) (bMonoHead | bRes | bSliceBytes | bPrintSpeed | bDir);

   *(lpCmd+2) = HIBYTE(pfData->wSliceCount);
   *(lpCmd+3) = LOBYTE(pfData->wSliceCount);

   /**************************************************************************
    * This is a print move to move the carrier to print the swath.  Therefore
    * the PrtCarr variables contain the correct start and stop positions for
    * the carrier.
    **************************************************************************/
   wNumCarrStep = CalcConstantSteps(lpDataRec,
                                    lpHwData->wCurrCarrPos,
                                    lpHwData->wPrtCarrStopPosition,
                                    lpHwData->bPrtCarrSpeed,
                                    lpHwData->bPrtCarrDirection);

   *(lpCmd + 4) = HIBYTE(wNumCarrStep);
   *(lpCmd + 5) = LOBYTE(wNumCarrStep);

   if (lpHwData->bPrtCarrDirection == LEFT )
   {
      nPrintPos = PrintPos(pfData->bResolution,
                           pfData->bPrintHead,
                           pfData->nRightPrintPos,
                           NO_DIRECTION);

#ifndef GEN_COL_BIDI
      if (pfData->bPrintDirection == BIDI)
#endif /* GEN_COL_BIDI */
         nPrintPos += GetBidiAlign(lpHwData, RIGHT, pfData->bPrintHead);
   }
   else
   {
      nPrintPos = PrintPos(pfData->bResolution, pfData->bPrintHead,
                           pfData->nLeftPrintPos, NO_DIRECTION);

#ifndef GEN_COL_BIDI
      if (pfData->bPrintDirection == BIDI)
#endif /* GEN_COL_BIDI */
         nPrintPos += GetBidiAlign(lpHwData, LEFT, pfData->bPrintHead);
   }

   *(lpCmd + 6) = HIBYTE(nPrintPos);
   *(lpCmd + 7) = LOBYTE(nPrintPos);

   /* temporary for debug */
#if 0
   *(lpCmd + 0) = CARRIER_MOVE_CMD;
   *(lpCmd + 2) = HIBYTE(wNumCarrStep);
   *(lpCmd + 3) = LOBYTE(wNumCarrStep);
   *(lpCmd + 4) = 0x00;
   *(lpCmd + 5) = 0x00;
   *(lpCmd + 6) = 0x00;
   *(lpCmd + 7) = 0x00;
#endif /* 0 */

   lpHwData->bPrtCarrDirection = NO_DIRECTION;
   lpHwData->wPrtCarrStartPosition = 0;
   lpHwData->wPrtCarrStopPosition = 0;
   lpHwData->bPrtCarrSpeed = SPEED_STOPPED;

#ifdef DOS_BUILD

#ifdef HUGE
      HugeOutToFile(pfData);
#else  /* HUGE */
   OUTPUT(lpDataRec,lpCmd,COMMAND_SIZE);
#endif /* HUGE */

#else /* DOS_BUILD */
   OUTPUT(lpDataRec,lpCmd,COMMAND_SIZE);
#endif /* DOS_BUILD */

}  /* end of OutputSwathInfo() */



/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: SetupPrinterForNextSwath
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void SetupPrinterForNextSwath(LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {CARRIER_RETURN_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;

   WORD wNumCarrStep,wVertMove;
   BYTE bDir,bSpeed;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;
   lpCmd = abPrinterCmd;

   if (lpHwData->bPosCarrDirection == RIGHT )
   {
      bDir = FORWARD_CAR_RETURN;
   }
   else
   {
      bDir = REVERSE_CAR_RETURN;
   }

   /* The firmware only supports 2 speeds for carrier return */
   if (lpHwData->bPosCarrSpeed == SPEED_FAST)
      bSpeed = RETURN_MOVE_25;
   else
   {
      bSpeed = RETURN_MOVE_16;
   }


   *(lpCmd + 1) = (BYTE) ( bDir| bSpeed | RETURN_FEED_NORMAL );


   /*************************************************************************
    * This is a return move to position carrier for next swath. Therefore
    * the PosCarr variables contain the correct start and stop positions to
    * position the carrier.
    *************************************************************************/
   if (lpHwData->bPosCarrSpeed != SPEED_STOPPED)
      wNumCarrStep = CalcConstantSteps(lpDataRec,
                                       lpHwData->wCurrCarrPos,
                                       lpHwData->wPosCarrStopPosition,
                                       lpHwData->bPosCarrSpeed,
                                       lpHwData->bPosCarrDirection);
   else
      wNumCarrStep = 0;

   *(lpCmd + 2) = HIBYTE(wNumCarrStep);
   *(lpCmd + 3) = LOBYTE(wNumCarrStep);

   wVertMove = (WORD)pfData->nFormsMovePending;

   /* printer needs vertical moves in 1/300" units */
   if (pfData->bResolution == LORES)
       wVertMove *= 2;
   *(lpCmd + 4) = HIBYTE(wVertMove);
   *(lpCmd + 5) = LOBYTE(wVertMove);

   /* Reset the variables */

   pfData->nFormsMovePending = 0;
   lpHwData->bPosCarrDirection = NO_DIRECTION;
   lpHwData->wPosCarrStartPosition = 0;
   lpHwData->wPosCarrStopPosition = 0;
   lpHwData->bPosCarrSpeed = SPEED_STOPPED;

   OUTPUT(lpDataRec,lpCmd,COMMAND_SIZE);

}  /* end of SetupPrinterForNextSwath() */


/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: OutputPrintSliceData
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void OutputPrintSliceData(LPDVDATAREC lpDataRec)
{

   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   struct tPrintCmd FAR *pPrtCmd;
   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {SWATH_DATA_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;
   WORD   wSize;

   lpCmd = abPrinterCmd;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;
   pPrtCmd = (struct tPrintCmd FAR *) pfData->pPrtCmd;

   *(lpCmd + 1) = HIBYTE(lpHwData->wPrintSRAMOffset);
   *(lpCmd + 2) = LOBYTE(lpHwData->wPrintSRAMOffset);

   wSize = (pfData->wSliceCount * pfData->bBytesPerSlice);
   *(lpCmd + 3) = HIBYTE(wSize);
   *(lpCmd + 4) = LOBYTE(wSize);

   /* Now send the control codes and the print slice data to the printer */
   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);
   OUTPUT(lpDataRec, (LPBYTE)pPrtCmd, wSize);

   return;

}  /* end of OutputPrintSliceData() */



/***************************************************************************
 *  FCKELVIN.C                                     Lexmark Confidential
 *
 * Function Name:    Linefeed
 *
 * Description:
 *    This function converts the FormsMovePending number into a
 *    resolution the printer is expecting.  It then sends a paper
 *    move command to the printer in the printer expected format.
 *    If in Windows, paper animation is called.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  PaperAnimation
 *                          OUTPUT
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 * 12/15/97       RFL            Modified ifdef for 32 bit compile.
 *
 *************************************************************************/
void LineFeed(LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;
   WORD   wVertMove;

   lpCmd = abPrinterCmd;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   wVertMove = (WORD)pfData->nFormsMovePending;

/* if ( wVertMove == 0 )*/
/*     return;          */
   if ( wVertMove > 0 )
   {
      /* printer needs vertical moves in 1/300" units */
#ifndef GEN_BIDI
      if (pfData->bResolution == LORES)
#endif /* GEN_BIDI */
          wVertMove *= 2;

      *(lpCmd + 0) = PAPER_FEED_CMD;
      *(lpCmd + 1) = (PAPER_FORWARD | PAPER_NORMAL_SPEED);
      *(lpCmd + 2) = HIBYTE(wVertMove);
      *(lpCmd + 3) = LOBYTE(wVertMove);

      /* move sent to printer so no moves pending now */
      pfData->nFormsMovePending = 0;

      lpHwData->dwPaperStepCount += wVertMove;

/* #ifndef DOS_BUILD */  /*RFL*/
#ifdef FC_WIN_16         /*RFL*/
      if (pfData->bResolution == LORES)
         PaperAnimation((void _far *)lpDataRec->lpLXGenericPtr,
                        (UINT)(wVertMove/2));
      else
         PaperAnimation((void _far *)lpDataRec->lpLXGenericPtr, (UINT)(wVertMove));
#endif /* FC_WIN_16 */

      OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);
    }

    return;

}  /* end of LineFeed() */


/***************************************************************************
 *  FCKELVIN.C                                     Lexmark Confidential
 *
 * Function Name:    FcFormfeed
 *
 * Description:
 *    This function sends a Formfeed command to the printer.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void FcFormFeed(LPDVDATAREC lpDataRec)
{
   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {PAPER_LOAD_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;

   lpCmd = abPrinterCmd;
   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

   return;

}  /* end of FcFormFeed() */


/***************************************************************************
 *  FCKELVIN.C                                     Lexmark Confidential
 *
 * Function Name:    FCEjectPage
 *
 * Description:
 *    This function sends a page eject command to the printer.
 *    Note that no action is taken by the printer unless paper has
 *    been loaded.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void FAR FCEjectPage(LPDVDATAREC lpDataRec)
{
   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {PAPER_EJECT_CMD, 0x00, 0x10, 0xCC, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;
   struct pf_data FAR *pfData;
   DWORD dwLength;
   DWORD dwRowPos;
   WORD  wEjectLength;
   struct tHwData FAR *lpHwData;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   lpCmd = abPrinterCmd;

   if (lpDataRec != NULL)
   {
      pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

      switch (lpDataRec->bMediaSize)
      {
         case PAPER_LETTER:
            dwLength = 3300;
            break;
         case PAPER_LEGAL:
            dwLength = 4200;
            break;
         case PAPER_B5:
            dwLength = 3035;
            break;
         case PAPER_EXECUTIVE:
            dwLength = 3150;
            break;
         case PAPER_A5:
            dwLength = 2480;
            break;
         case CARD_A6:
            dwLength = 1748;
            break;
         case PAPER_USER:
            /* Custom paper can be up to 17" long */
            dwLength = 5100;
            break;
         case PAPER_A4:
            dwLength = 3510;
            break;
         case PAPER_OHFHAGAKI:
            dwLength = 1748;
            break;
         case PAPER_HAGAKI:
            dwLength = 1748;
            break;
         case ENVELOPE_9:
            dwLength = 2662;
            break;
         case ENVELOPE_10:
            dwLength = 2850;
            break;
         case ENVELOPE_DL:
            dwLength = 2598;
            break;
         case ENVELOPE_C5:
            dwLength = 2703;
            break;
         case ENVELOPE_C6:
            dwLength = 1914;
            break;
         case ENVELOPE_D5:
            dwLength = 2952;
            break;
         case ENVELOPE_75:
            dwLength = 2250;
            break;
         case CARD_3X5:
            dwLength = 1500;
            break;
         case CARD_4X6:
            dwLength = 1800;
            break;
         case ENVELOPE_BARONIAL:
            dwLength = 1314;
            break;
         case ENVELOPE_6_3_4:
            dwLength = 1950;
            break;
         default :
            /* Custom paper can be up to 17" long */
            dwLength = 5100;
               break;
      }


      /* get number of steps paper has already moved */
      dwRowPos = lpHwData->dwPaperStepCount;

      if ( (lpDataRec->bMediaSize != PAPER_BANNER_A4 ) &&
           (lpDataRec->bMediaSize != PAPER_BANNER_LETTER ) )
      {
        abPrinterCmd[1] |= DET_JAM_ENABLE;
      }
      else      /* Use A4 length for banner */
        dwLength = 3510;


      /* printer units = 1/600" */
      dwLength = dwLength*2;


      /* add more steps just to make sure paper is fully ejected from printer */
      dwLength = dwLength + 1200;

      wEjectLength = (WORD)(dwLength - dwRowPos);

      abPrinterCmd[2] = HIBYTE(wEjectLength);
      abPrinterCmd[3] = LOBYTE(wEjectLength);
   }

   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

   return;

}  /* end of FCEjectPage() */


/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    FcPaperSource
 *
 * Description:
 *    This function outputs the paper source data (manual or
 *    automatic sheet feed) to the printer in the expected format.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
void FCSetPaperSource(LPDVDATAREC lpDataRec)
{

   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {PAPER_SOURCE_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;

   lpCmd = abPrinterCmd;

   if (lpDataRec->bMediaSource == MANUAL_FEED)
      *(lpCmd+1) = MANUAL_LOAD;
   else
      *(lpCmd+1) = ASF_LOAD;

   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

   return;

}  /* end of FCSetPaperSource() */


/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    GetLeftMargin
 *
 * Description:
 *    This function determines the left margin
 *    based on the following :
 *      Paper Size - (i.e. left margin is 75/300 for Letter,
 *                         40/300" for A4 paper.
 *
 * Inputs:  bMediatSource  ASF or manual feed
 *          bMediaSize
 *
 * Outputs: WORD LeftMargin
 *
 * Major Functions Called:
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
WORD GetLeftMargin(LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   WORD bLeftMargin;
   bLeftMargin = LEFT_UNPRINTABLE_AREA;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

   /* Determine Minimum left margin from the Media Size and Source */
   /* Note that A4 and Hagaki is 35/300" < than other US paper sources. */
   /* All envelopes and Hagaki is always manual feed for this product. */

   switch (lpDataRec->bMediaSize)
   {
   case PAPER_LETTER:
   case PAPER_BANNER_LETTER:
   case PAPER_LEGAL:
   case PAPER_EXECUTIVE:
   case PAPER_USER:
      if (lpDataRec->bMediaSource == MANUAL_FEED)
      {
         bLeftMargin += MANUAL_FEED_OFFSET;
      }
      break;
   case PAPER_B5:
   case PAPER_A5:
   case PAPER_A4:
   case PAPER_BANNER_A4:
      bLeftMargin -= 35;
      if (lpDataRec->bMediaSource == MANUAL_FEED)
      {
         bLeftMargin += MANUAL_FEED_OFFSET;
      }
      break;
   case PAPER_OHFHAGAKI:
   case PAPER_HAGAKI:
      bLeftMargin -= 35;
      /* Hagaki ASF has a offset like manual */
      bLeftMargin += MANUAL_FEED_OFFSET;
      break;

   /* all of the paper type below must be fed manually, so always add   */
   /* the manual feed offset to their left margin.                      */
   case ENVELOPE_MONARCH:
   case ENVELOPE_9:
   case ENVELOPE_10:
   case ENVELOPE_DL:
   case ENVELOPE_C5:
   case ENVELOPE_B5:
   case ENVELOPE_C6:
   case ENVELOPE_D5:
   case ENVELOPE_75:
   case CARD_3X5:
   case CARD_4X6:
   case CARD_A6:
   case ENVELOPE_BARONIAL:
   case ENVELOPE_6_3_4:
   case JPNLONG3:
   case JPNSQUARE4:
   case JPNSQUARE5:
   case JPNSQUARE6:
      bLeftMargin += MANUAL_FEED_OFFSET;
      break;

   /* When the driver sets MediaSize to one of the custom choices, we      */
   /* expect the driver to give us the correct left margin in              */
   /* lpDataRec->wLeftMargin.                                              */
   case PAPER_CUSTOM:
   case PAPER_CUSTOM_BANNER:
   case ENVELOPE_CUSTOM:
      bLeftMargin = lpDataRec->wLeftMargin;
      break;

   default :
      bLeftMargin = LEFT_UNPRINTABLE_AREA;
      if (lpDataRec->bMediaSource == MANUAL_FEED)
      {
         bLeftMargin += MANUAL_FEED_OFFSET;
      }
      break;
   }  /* end of switch (lpDataRec->bMediaSize) */

   return(bLeftMargin * pfData->nSwathResMult);

}  /* end of GetLeftMargin() */


/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name:
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
BYTE GetShingleMode(LPDVDATAREC lpDataRec)
{
   BYTE bShingle = NO_SHINGLE;

   /* determine shingle value from media type and print quality */
   switch (lpDataRec->bMediaType)
   {
      case PLAIN_PAPER :
            switch (lpDataRec->bQuality)
            {
               case  QUALITY_DRAFT :
                     bShingle = NO_SHINGLE;
                     break;
               case  QUALITY_NORMAL :
                     if (lpDataRec->bDocumentType == INTENT_PHOTO)
                        bShingle = SHINGLE_50;
                     else
                        bShingle = NO_SHINGLE;
                     break;
               case  QUALITY_HIGH :
                     bShingle = SHINGLE_25;
                     break;
#ifdef DEBUG_SHINGLE
               /* Other cases not expected.. */
               default :
                     Dprints ("GetShingleMode has unexpected quality:%d\n", lpDataRec->bQuality);
                     break;
#endif /* DEBUG_SHINGLE */
            }
            break;
      case COATED_PAPER :
      case GLOSSY_PAPER :
            switch (lpDataRec->bQuality)
            {
               case  QUALITY_DRAFT :
                     bShingle = NO_SHINGLE;
                     break;
               case  QUALITY_NORMAL :
                     bShingle = SHINGLE_50;
                     break;
               case  QUALITY_HIGH :
                     bShingle = SHINGLE_50;
                     break;
#ifdef DEBUG_SHINGLE
               /* Other cases not expected.. */
               default :
                     Dprints ("GetShingleMode has unexpected quality:%d\n", lpDataRec->bQuality);
                     break;
#endif /* DEBUG_SHINGLE */
            }
            break;
      case TRANSPARENCY :
      case IRON_ON_TRANSFER :
      case GREETING_CARD_STOCK :
            switch (lpDataRec->bQuality)
            {
               case  QUALITY_DRAFT :
                     bShingle = NO_SHINGLE;
                     break;
               case  QUALITY_NORMAL :
                     bShingle = SHINGLE_50;
                     break;
               case  QUALITY_HIGH :
                     bShingle = SHINGLE_25;
                     break;
#ifdef DEBUG_SHINGLE
               /* Other cases not expected.. */
               default :
                     Dprints ("GetShingleMode has unexpected quality:%d\n", lpDataRec->bQuality);
                     break;
#endif /* DEBUG_SHINGLE */
            }
            break;
#ifdef DEBUG_SHINGLE
      default :
         /* Other cases not expected.. */
         Dprints ("GetShingleMode has unexpected quality:%d\n", lpDataRec->bQuality);
         break;
#endif /* DEBUG_SHINGLE */
   }

   return(bShingle);

}  /* end of GetShingleMode() */


/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name:
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
BYTE CheckforReverseSwath(LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   BYTE   bDirection;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   CalcCarrierPositions(lpDataRec,TRUE);

   bDirection = FORWARD;
   if (lpHwData->bPrtCarrDirection == LEFT )
      bDirection = REVERSE;

   return(bDirection);

}  /* end of CheckforReverseSwath() */



/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: GetResolution
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
BYTE FAR GetResolution(LPDVDATAREC lpDataRec)
{
   BYTE bResolution;     /* 300 dpi */

   bResolution = LORES;

   switch (lpDataRec->bMediaType)
   {
      case PLAIN_PAPER :
         bResolution = LORES;
         break;
      case GLOSSY_PAPER :
      case COATED_PAPER :
            switch (lpDataRec->bQuality)
            {
               case  QUALITY_DRAFT :
               case  QUALITY_NORMAL :
                     bResolution = LORES;
                     break;
               case  QUALITY_HIGH :
                     bResolution = HIRES;    /* 600 dpi */
                     break;
#ifdef DEBUG_RESOLUTION
               default :
                  /* Other cases not expected.. */
                  Dprints ("GetResolution has unexpected quality:%d\n", lpDataRec->bQuality);
                  break;
#endif /* DEBUG_RESOLUTION */
            }
            break;
      case TRANSPARENCY :
      case IRON_ON_TRANSFER :
      case GREETING_CARD_STOCK :
            bResolution = LORES;
            break;
      default :
            bResolution = LORES;

      }

#ifdef GEN_BIDI
      bResolution = HIRES;    /* 600 dpi */
#endif /* GEN_BIDI */

   return(bResolution);

}  /* end of GetResolution() */


/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: GetBidiAlign
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
int GetBidiAlign(struct tHwData FAR *lpHwData, BYTE bDirection,BYTE bPrinthead)
{
   int nBidiAlign;

   /* Make sure initialized to something so no compiler warning */
   nBidiAlign = MONO_LEFT_BIDI_ALIGN;

   if (bPrinthead == MONO_CARTRIDGE)
   {
      if ( bDirection == LEFT )
          nBidiAlign = lpHwData->nMonoLeftBidiAlign;
      else
          nBidiAlign = lpHwData->nMonoRightBidiAlign;

   }

   if (bPrinthead == COL_CARTRIDGE)
   {
      if ( bDirection == LEFT )
          nBidiAlign = lpHwData->nColorLeftBidiAlign;
      else
          nBidiAlign = lpHwData->nColorRightBidiAlign;
   }
   return(nBidiAlign);

}  /* end of GetBidiAlign() */


/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: CheckForCDE
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
BYTE CheckForCDE(BYTE bResolution, BYTE bQuality)
{
   BYTE  bDraft;

   /* Make the compiler happy */
   bResolution = bResolution;

   bDraft = FALSE;
   if (bQuality == QUALITY_DRAFT)
      bDraft = TRUE;

   return(bDraft);

}  /* end of CheckForCDE() */


/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: GetPrintDir
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 * 12/15/97       RFL            Modified ifdef for 32 bit compile.
 *
 *************************************************************************/
BYTE GetPrintDir(LPDVDATAREC lpDataRec, int nBuffers)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   BYTE bPrintDir;

   /* silence the compiler */
   nBuffers = nBuffers;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   if ( pfData->bPrintQuality == QUALITY_DRAFT )
   {
      bPrintDir = BIDI;
   }
   else
   {
      bPrintDir = LTOR;

#ifdef SMARTBIDI

      /* SmartBIDI */            /*RFL*/
      if    (pfData->iSmartBIDI && pfData->iLastLineNull)
      {  /* change direction */
         pfData->iLastLineNull = 0;/* clear sw so we do this once per swath */
         if    (pfData->bPrtDir == RTOL)
            pfData->bPrtDir = LTOR;
         else if (pfData->bPrtDir == LTOR)
            pfData->bPrtDir = RTOL;

         bPrintDir = pfData->bPrtDir;
      }
#endif /* SMARTBIDI */

   }

   if  (lpDataRec->bColorPlanes == 6)
   {
      bPrintDir = RTOL;
   }

#ifdef PQ_TEST
      bPrintDir = lpHwData->bTestPrintDir;
#endif /* PQ_TEST */

#ifdef GEN_BIDI
/*       bPrintDir = LTOR;  */
      bPrintDir = BIDI;
#endif /* GEN_BIDI */

#ifdef GEN_COL_BIDI
   bNumBidiSwaths++;
   if ((bNumBidiSwaths > 4*3) && (bNumBidiSwaths < 17))
      bPrintDir = RTOL;
   else
      bPrintDir = LTOR;
#endif /* GEN_COL_BIDI */

   return(bPrintDir);

}  /* end of GetPrintDir() */


/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    GetTopMargin
 *
 * Description:
 *    This function determines the top margin.  It seems like
 *    the interface has changed to SW2000 driver code for some
 *    printers so this is now printer specific.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
WORD GetTopMargin(LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

   /**************************************************************************
    * Top margin should be 40 but add 20 pels to help with firmware/mechanical
    * inaccuracies. (Hagaki)
    * Another adjustment on 6/2/97 for mechanical differences/stretching in
    * production units. (60 - 18 pels per Mike Wilson)
    **************************************************************************/
   return((WORD)(42 * pfData->nVertResMult));

}  /* end of GetTopMargin() */


/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: ClearPrintSwath
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void ClearPrintSwath(struct pf_data FAR *pfData)
{
   struct tPrintCmd FAR *pPrtCmd;
   LPBYTE lpbSwath;

   pPrtCmd = (struct tPrintCmd FAR *)pfData->pPrtCmd;
   lpbSwath = pPrtCmd->abSwathBuff;
   MEMSET(lpbSwath,0x00,(WORD)((PRT_CMD_SIZE)-(SWATH_HEADER_SIZE)));

   return;

}  /* end of ClearPrintSwath() */



/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    FCSendCartridgeHome
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to send the carrier to be capped at the
 *    maintenance station.  The carrier position
 *    kept by the driver is then updated to the
 *    maintenance cap position.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
void FAR FCSendCartridgeHome(LPDVDATAREC lpDataRec)
{

   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {CAP_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;
   WORD   wCarrPos;

   lpCmd = abPrinterCmd;
   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   /* If carrier is not close to maintenance station then send it close
      at draft speed before sending home command which is only 9IPS     */

   wCarrPos = lpHwData->wCurrCarrPos;

   if (lpHwData->wCurrCarrPos > (MONO_SPIT_POSITION +
                       (WORD)ShortestMoveDist(lpHwData, SPEED_FAST, FALSE)) )
   {
      lpHwData->wPosCarrStartPosition = lpHwData->wCurrCarrPos;
      lpHwData->wPosCarrStopPosition = MONO_SPIT_POSITION;
      lpHwData->bPosCarrDirection = LEFT;
      lpHwData->bPosCarrSpeed = SPEED_FAST;
      PositionCarrierForPrint(lpDataRec);
   }

   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);
   lpHwData->wCurrCarrPos = LEFT_SIDE_FRAME_POSITION;

   /* Only do maintenance after an install */
   if (lpHwData->bInstallCartridge == TRUE)
   {
      pfData->bPrintHead = lpDataRec->bLeftCartridgeID;
      SendMaintenanceCmd(lpDataRec, INSTALL_SPIT_CNT, INSTALL_WIPE_CNT);
      UpdatePageDotCount(lpDataRec, INSTALL_SPIT_CNT * INSTALL_WIPE_CNT);
      lpHwData->bInstallCartridge = FALSE;
   }

   return;

}  /* end of FCSendCartridgeHome() */

/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    FCInstallCartridge
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to send the carrier to the install position.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: K. Profitt
 * Date: 12/12/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
void FAR FCInstallCartridge(LPDVDATAREC lpDataRec)
{

   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;


   if (IsCarrierInMaintStation(lpDataRec)==TRUE)
   {
       SendMaintenanceCmd(lpDataRec, UNCAP_SPIT_CNT, UNCAP_WIPE_CNT);
       UpdatePageDotCount(lpDataRec, UNCAP_SPIT_CNT * UNCAP_WIPE_CNT);
   }

   /************************************************************************
    * If carrier is not close to cartridge install position then send it
    * close at draft speed before sending home command which is only 9IPS
    ************************************************************************/
   if (lpHwData->wCurrCarrPos < (CARTRIDGE_INSTALL_POSITION -
                        (WORD)ShortestMoveDist(lpHwData, SPEED_FAST, FALSE)) )
   {
      lpHwData->wPosCarrStartPosition = lpHwData->wCurrCarrPos;
      lpHwData->wPosCarrStopPosition = CARTRIDGE_INSTALL_POSITION;
      lpHwData->bPosCarrDirection = RIGHT;
      lpHwData->bPosCarrSpeed = SPEED_FAST;
      PositionCarrierForPrint(lpDataRec);
   }


   if (lpHwData->wCurrCarrPos > (CARTRIDGE_INSTALL_POSITION +
                        (WORD)ShortestMoveDist(lpHwData, SPEED_FAST, FALSE)) )
   {
      lpHwData->wPosCarrStartPosition = lpHwData->wCurrCarrPos;
      lpHwData->wPosCarrStopPosition = CARTRIDGE_INSTALL_POSITION;
      lpHwData->bPosCarrDirection = LEFT;
      lpHwData->bPosCarrSpeed = SPEED_FAST;
      PositionCarrierForPrint(lpDataRec);
   }

   lpHwData->bInstallCartridge = TRUE;

   return;

}  /* end of FCInstallCartridge() */



/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    PositionCarrierForPrint
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to perform a carrier position move. The
 *    carrier position kept by the driver is then updated
 *    to the new position.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
void PositionCarrierForPrint ( LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {CARRIER_MOVE_CMD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;
   BYTE   bSpeed;  /* bSpeed is a bit-mask representation of the speed sent to firmware, as defined by CAR_MOVE_xx */
   BYTE   bDir;
   WORD   wNumCarrStep;

   lpCmd = abPrinterCmd;
   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   if (lpHwData->bPosCarrDirection != NO_DIRECTION)
   {
      /**********************************************************************
       * The carrier may be moved at speeds slower than currently used for
       * printing (9ips), to position for spitting, cartridge installation,
       * or beginning of the next print line.
       **********************************************************************/
      if   (lpHwData->bPosCarrSpeed == SPEED_FAST)
         bSpeed = CAR_MOVE_25;
      else if (lpHwData->bPosCarrSpeed == SPEED_NORMAL)
      {
         bSpeed = CAR_MOVE_16;
      }
      else /* lpHwData->bPosCarrSpeed == SPEED_SLOW */
      {
         bSpeed = CAR_MOVE_09;
      }

      if (lpHwData->bPosCarrDirection == RIGHT )
         bDir = FORWARD_CAR;
      else
         bDir = REVERSE_CAR;

      *(lpCmd + 1) = (BYTE)(bSpeed | bDir );

      wNumCarrStep = CalcConstantSteps(lpDataRec,
                                       lpHwData->wPosCarrStartPosition,
                                       lpHwData->wPosCarrStopPosition,
                                       lpHwData->bPosCarrSpeed,
                                       lpHwData->bPosCarrDirection);

      *(lpCmd + 2) = HIBYTE(wNumCarrStep);
      *(lpCmd + 3) = LOBYTE(wNumCarrStep);

      OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

/*    lpHwData->wCurrCarrPos = lpHwData->wPosCarrStopPosition;  */

   }

   lpHwData->bPosCarrDirection = NO_DIRECTION;
   lpHwData->wPosCarrStartPosition = 0;
   lpHwData->wPosCarrStopPosition = 0;
   lpHwData->bPosCarrSpeed = SPEED_STOPPED;

   return;

}  /* end of PositionCarrierForPrint() */




/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: CalcConstantSteps
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/

/***************************************************************************
 *      Note that right and left are with respect to
 *      the page, not the printer.
 *
 *               <----Constant Speed---->           Initial
 *        Stop                               Car    Carrier
 *        Pos                       Settle   Pos    Position 0x100
 *   |------|----|-------------------|--|-----|--------------|
 *   Left  <---->   <----------        <---->       Maintenance
 *   Side   Decel     Direction         Accel          Station
 *
 *
 *   r = 0x100 + length of carrier travel for printer
 ****************************************************************************/
WORD CalcConstantSteps( LPDVDATAREC lpDataRec, WORD wStartPosition,
                        WORD wStopPosition, WORD wSpeed, WORD wDirection )
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   WORD wNumCarrStep,wShortMoveDist;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   /* Make sure positions are on carrier step boundaries */

   wStartPosition = (WORD)PositionCompensation(wStartPosition, wDirection);
   wStopPosition = (WORD)PositionCompensation(wStopPosition, wDirection);

   if (wDirection == RIGHT )
   {
      /* calculate the number of steps for the carrier to move (1/600") */
      wNumCarrStep = wStopPosition - wStartPosition;
   }
   else         /* direction is LEFT */
   {
      /* calculate the number of steps for the carrier to move (1/600") */
      wNumCarrStep = wStartPosition  - wStopPosition;
   }


   /*************************************************************************
    * Calculate number of steps for constant speed. The printer does not
    * need accel/decel distance in cmd so subtract them from the number of
    * carrier steps. ShortestMoveDist calculates this value. The "settle"
    * distance for the carrier to reach steady state after acceleration is
    * included in this calculation if a value of TRUE is passed in as a
    * parameter. Settle should be included in the constant step number sent
    * to the printer so a FALSE for the IncludeSettle parmeter is given.
    *************************************************************************/
   wShortMoveDist = (WORD)ShortestMoveDist (lpHwData, wSpeed, FALSE);

   if (wNumCarrStep > wShortMoveDist)
     wNumCarrStep -= wShortMoveDist;
   else
   {
      if (wDirection == RIGHT )
         wStopPosition += wShortMoveDist - wNumCarrStep;
      else
         wStopPosition -= wShortMoveDist - wNumCarrStep;

      wNumCarrStep = 0;
   }

   /*************************************************************************
    * now update the driver carrier position with this move since
    * PositionCompensation forces stop to be in HW resolution boundaries
    *************************************************************************/
   lpHwData->wCurrCarrPos = wStopPosition;

   /* convert from 1/600" to 1/150" */
   wNumCarrStep = wNumCarrStep / RES600_PER_STEP;

   return (wNumCarrStep);

}  /* end of CalcConstantSteps() */


/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    MaxAccelDistance
 *
 * Description:
 *    This function returns the shortest distance
 *    that it will take to accelerate  to a given steady state
 *    velocity.  This value includes the acceleration ramp
 *    + the settle time (Alpha) to reach  constant speed.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *          wSpeed     Gives the steady state speed.
 *
 * Outputs: Maximum Acceleration Distance
 *          Units are in 1/600" at carrier motor step
 *          increment.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
int MaxAccelDistance( LPDVDATAREC lpDataRec, WORD wSpeed)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   int nAccelDist;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   if (wSpeed == SPEED_NORMAL)
   {
      nAccelDist = lpHwData->bAccelStepCntNormal;
      nAccelDist += lpHwData->bAlphaStepCntNormal;
   }
   else if (wSpeed == SPEED_FAST)
   {
      nAccelDist = lpHwData->bAccelStepCntFast;
      nAccelDist += lpHwData->bAlphaStepCntFast;
   }
   else /* wSpeed == SPEED_SLOW */
   {
      nAccelDist = lpHwData->bAccelStepCntSlow;
      nAccelDist += lpHwData->bAlphaStepCntSlow;
   }

   /* convert from carrier step resolution to 1/600" */
   nAccelDist *= RES600_PER_STEP;

   /* put in carrier units*/
   nAccelDist = PositionCompensation(nAccelDist, RIGHT);

   return (nAccelDist);

}  /* end of MaxAccelDistance() */


/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    MaxDecelDistance
 *
 * Description:
 *    This function returns the shortest distance
 *    that it will take to decelerate from a given steady state
 *    velocity.  This value is the deceleration ramp.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *          wSpeed     Gives the steady state speed.
 *
 * Outputs: Maximum Deceleration Distance
 *          Units are in 1/600" at carrier motor step
 *          increment.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
int MaxDecelDistance( LPDVDATAREC lpDataRec, WORD wSpeed)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   int nDecelDist;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;


   if (wSpeed == SPEED_NORMAL)
   {
      nDecelDist = lpHwData->bDecelStepCntNormal;
   }
   else if (wSpeed == SPEED_FAST)
   {
      nDecelDist = lpHwData->bDecelStepCntFast;
   }
   else /* wSpeed == SPEED_SLOW */
   {
      nDecelDist = lpHwData->bDecelStepCntSlow;
   }

   /* convert from carrier step resolution to 1/600" */
   nDecelDist *= RES600_PER_STEP;

   /* must end on even step */
   nDecelDist = PositionCompensation(nDecelDist, RIGHT);

   return ( nDecelDist );

}  /* end of MaxDecelDistance() */


/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    ShortestMoveDistance
 *
 * Description:
 *    Calculates the shortest distance that it will take to
 *    accelerate and decelerate the carrier.
 *
 * Inputs:  lpDataRec       Long pointer to print device structure.
 *          wSpeed          Speed input gives the steady state speed.
 *          bIncludeSettle If true then the settle time /alpha
 *                         is included in the calculation.
 *
 * Outputs: Minimum Distance for a move at given speed.
 *          Units are in 1/600" at carrier motor step
 *          increment.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
int ShortestMoveDist(struct tHwData FAR *lpHwData,
                     WORD wSpeed, BOOL bIncludeSettle)
{
   int nShortDist;


   /* Based on speed, get shortest distance in steps  */
   if (wSpeed == SPEED_NORMAL)
   {
      nShortDist = lpHwData->bAccelStepCntNormal;
      nShortDist += lpHwData->bDecelStepCntNormal;
      if (bIncludeSettle)
        nShortDist += lpHwData->bAlphaStepCntNormal;
   }
   else if (wSpeed == SPEED_FAST)
   {
      nShortDist = lpHwData->bAccelStepCntFast;
      nShortDist += lpHwData->bDecelStepCntFast;
      if (bIncludeSettle)
         nShortDist += lpHwData->bAlphaStepCntFast;
   }
   else /* wSpeed == SPEED_SLOW */
   {
      nShortDist = lpHwData->bAccelStepCntSlow;
      nShortDist += lpHwData->bDecelStepCntSlow;
      if (bIncludeSettle)
         nShortDist += lpHwData->bAlphaStepCntSlow;
   }

   /* convert from carrier step resolution to 1/600" */
   nShortDist *= RES600_PER_STEP;

   /* put in carrier units*/
   nShortDist = PositionCompensation(nShortDist, RIGHT);

   return ( nShortDist );

}  /* end of ShortestMoveDist() */

/***************************************************************************
 * FCKELVIN.C                                Lexmark Confidential
 *
 * Function Name:    PositionCompensation
 *
 * Description:
 *    This function takes the input direction ( 1/600" units )
 *    and modifies it to make sure it is on a carrier step
 *    boundary.  For example, if RES600_PER_STEP is equal to 4,
 *    then the carrier step resolution is 1/150".  The carrier
 *    can only stop on 4/600" boundaries.
 *
 * Inputs:  nPosition   1/600" units.
 *          wDir        Carrier movement direction.
 *
 * Outputs: Compensated nPosition
 *
 * Major Functions Called:    None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
int PositionCompensation(int nPosition, WORD wDir)
{
   int x3;

   x3 = nPosition % RES600_PER_STEP;
   if  (x3 != 0)
   {
      nPosition -= x3;
      if   (wDir == RIGHT)
         nPosition += RES600_PER_STEP;
   }
   return( nPosition );

}  /* end of PositionCompensation() */


/***************************************************************************
 * FCKELVIN.C                                Lexmark Confidential
 *
 * Function Name:    IsCarrierInMaintenanceStation
 *
 * Description:
 *    This function checks the current carrier position and
 *    returns TRUE if carrier is in the maintenance station.
 *
 * Inputs:  lpDataRec       Long pointer to print device structure.
 *
 * Outputs: TRUE if Carrier in Maintenace station, FALSE otherwise
 *
 * Major Functions Called:    None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
BOOL IsCarrierInMaintStation(LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   if (lpHwData->wCurrCarrPos <= LEFT_SIDE_FRAME_POSITION )
      return ( TRUE );
   else
      return ( FALSE );

}  /* end of IsCarrierInMaintStation() */


/***************************************************************************
 * FCKELVIN.C                                Lexmark Confidential
 *
 * Function Name:    PrintPos
 *
 * Description:
 *    This function puts the print position into 1/600" carrier
 *    units taking into considertation the offset between the mono
 *    and color cartridges for two pen printers and the paper edge.
 *
 *
 * Inputs:  BYTE bResolution    - Resolution of print position.
 *          BYTE bMono          - TRUE if print swath mono.
 *          int  nPrintPosition
 *          bDirection          - Direction of carrier travel
 *
 * Outputs: int nPrintPosition is carrier 1/600" units
 *
 * Major Functions Called:    None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
int PrintPos(BYTE bResolution, BYTE bMono, int nPrintPosition,
             BYTE bDirection)
{
   int nPosition600;

   nPosition600 = nPrintPosition;

   if (bResolution == LORES)
   {
      nPosition600 = nPrintPosition * 2;
   }

   if (bMono == MONO_CARTRIDGE)
      bMono = TRUE;

   nPosition600 += ((bMono ? MONO_POS_OFFSET:COLOR_POS_OFFSET));
   nPosition600 += HW_LT_PAP_EDGE;

   /* put position into carrier motor step boundaries */
   if ( bDirection == LEFT )
      nPosition600 = PositionCompensation(nPosition600, LEFT);
   else
      if ( bDirection == RIGHT )
         nPosition600 = PositionCompensation(nPosition600, RIGHT);

   /* returns value in 600ths */
   return (nPosition600);

}  /* end of PrintPos() */




/***************************************************************************
 * FCKELVIN.C                                Lexmark Confidential
 *
 * Function Name:    CalculateCarrPositions
 *
 * Description:
 *    This function determines the print direction, start position,
 *    and stop position taking into account the acceleration and
 *    deceleration distances for the carrier move given the print
 *    speed.  It also checks the current carrier position and
 *    calculates a position move if required.  All calculations
 *    are using 1/600" units.  Note that LEFT/RIGHT and the carrier
 *    position increment/decrement is with respect to the page,
 *    not the printer ( page LEFT and RIGHT is reversed from printer
 *    LEFT and RIGHT).
 *
 *
 * Inputs:  lpDataRec          Long pointer to print device structure.
 *          BOOL fNextSwath   Function can be called to calculate positions
 *                            for current swath to print or the next swath
 *                            to print.  If fNextSwath is TRUE, then the
 *                            print positions are retrieved from different
 *                            variables.
 *
 * Outputs: None
 *
 * Major Functions Called:    None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void CalcCarrierPositions(LPDVDATAREC lpDataRec, BOOL fNextSwath)
{
   /* all distance/position variables are in 1/600" units */

   /* left and right print positions of current swath */
   int nLeftPrintPos, nRightPrintPos;

   int nLeftPlusAccel, nRightPlusAccel;

   BYTE bPrinthead, bPrintDir;
   int  nCarrPos;    /* current carrier position  */
   int  nMaxAccelDist;
   int  nMaxDecelDist;
   int  nLeftBidi;
   int  nRightBidi;
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   /* no move required to position carrier for printing */
   lpHwData->bPosCarrDirection = NO_DIRECTION;
   lpHwData->wPosCarrStartPosition = 0;
   lpHwData->wPosCarrStopPosition = 0;
   lpHwData->bPosCarrSpeed = SPEED_STOPPED;


/***************************************************************************
 *      Note that right and left are with respect to
 *      the page, not the printer.
 *
 *          Left                        Right
 *          Print                       Print
 *          Position                    Position
 *           ___________________________
 *          |___________________________|
 * |---|--------------------------------------|----|
 *      Left                                  Right
 *      Plus                                  Plus
 *      Accel                                 Accel
 *
 ***************************************************************************/

   /**************************************************************************
    * Save the print speed : on kelvin, high and normal quality are printed at
    * same (normal) speed. Slow speed is only used for carrier positioning
    **************************************************************************/
   if    (pfData->bPrintQuality == QUALITY_HIGH ||
          pfData->bPrintQuality == QUALITY_NORMAL)
      lpHwData->bPrtCarrSpeed = SPEED_NORMAL;
   else  /* QUALITY_DRAFT */
      lpHwData->bPrtCarrSpeed = SPEED_FAST;


   /* get maximum acceleration distance from hardware specific routine */
   nMaxAccelDist = MaxAccelDistance (lpDataRec, lpHwData->bPrtCarrSpeed);
   nMaxDecelDist = MaxDecelDistance(lpDataRec, lpHwData->bPrtCarrSpeed);

   /********************************************************************
    * get necessary data depending on if calculating positions for
    * current swath or the next swath to be printed.
    ********************************************************************/
   if (fNextSwath == FALSE )
   {
      nLeftPrintPos =  pfData->nLeftPrintPos;
      nRightPrintPos = pfData->nRightPrintPos;
      bPrinthead = pfData->bPrintHead;
      bPrintDir  = pfData->bPrintDirection;
   }
   else
   {
     /*******************************************************************
      * Need to calculate positions for next swath.  The
      * positions are in the PreRotateVariables for the next
      * swath.
      *******************************************************************/

      /* first check to see if next swath is empty.  If it is, return */
/**/  if ( (pfData->nPreRotateEnd - pfData->nPreRotateStart) <= 0 )
         return;

      nLeftPrintPos  = RastertoPrintPos(pfData->nPreRotateStart,
                                        pfData->wLeftMargin);
      nRightPrintPos = RastertoPrintPos(pfData->nPreRotateEnd,
                                        pfData->wLeftMargin);
      nRightPrintPos -= 1;

#if 0
      if (pfData->bPreRotateDir == BIDI)
      {
        /* alignment in 1/600" units */
        nLeftPrintPos += (GetBidiAlign(lpHwData,LEFT,pfData->bPreRotatePrintHead) / pfData->nSwathResMult);
        nRightPrintPos += (GetBidiAlign(lpHwData,RIGHT,pfData->bPreRotatePrintHead) / pfData->nSwathResMult);
      }

#endif /* 0 */

      bPrinthead = pfData->bPreRotatePrintHead;
      bPrintDir  = pfData->bPreRotateDir;
      if (bPrinthead == MONO_CARTRIDGE)
      {
        nRightPrintPos += (MONO_NOZZLE_OFFSET * pfData->nSwathResMult);
        nLeftPrintPos -= (MONO_NOZZLE_OFFSET * pfData->nSwathResMult);
      }
      else
      {
        nRightPrintPos += ((COLOR_NOZZLE_OFFSET + COLOR_HEAD_OFFSET) *
                           pfData->nSwathResMult);
        nLeftPrintPos -= ((COLOR_NOZZLE_OFFSET + COLOR_HEAD_OFFSET) *
                          pfData->nSwathResMult);
      }
   }

   /***************************************************************
    * put print position into 1/600" units and account for
    * printhead offsets in two pen printers
    ****************************************************************/
   nLeftPrintPos =  PrintPos(pfData->bResolution, bPrinthead,
                             nLeftPrintPos, LEFT);
   nRightPrintPos = PrintPos(pfData->bResolution, bPrinthead,
                             nRightPrintPos, RIGHT);

   /* alignment values returned in 1/600" units */
#ifndef GEN_COL_BIDI
   if (bPrintDir == BIDI)
#endif /* GEN_COL_BIDI */
   {
      nLeftPrintPos += GetBidiAlign(lpHwData, LEFT, bPrinthead);
      nRightPrintPos += GetBidiAlign(lpHwData, RIGHT, bPrinthead);

      /* make sure on 1/150" boundaries */
      nLeftPrintPos = PositionCompensation(nLeftPrintPos, LEFT);
      nRightPrintPos = PositionCompensation(nRightPrintPos, RIGHT);
   }

   /* get the right and left positions with acceleration added */
   nLeftPlusAccel =  LeftPosPlus(nLeftPrintPos, nMaxAccelDist);
   nRightPlusAccel = RightPosPlus(nRightPrintPos, nMaxAccelDist);

   nCarrPos =  (int)lpHwData->wCurrCarrPos;


   nLeftBidi =  lnabs(nCarrPos - nLeftPlusAccel);
   nRightBidi = lnabs(nCarrPos - nRightPlusAccel);

/**************************************************************************
 *                      PAGE
 *
 *            LPP                 RPP
 *            ______________________
 *            |_____________________|
 *   |-----|--------|-------------------|---------------------|
 *       LPP+accel CP                 RPP+accel
 *                  <-------------------->
 *                          nRightBidi
 *         <-------->
 *          nLeftBidi
 *
 *      RPP = RightPrintPosition
 *      LPP = LeftPrintPosition
 *************************************************************************/
   /*************************************************************************
    * Determine if repositioning is required for Bi-di printing or the
    * return move for unidirectional printing - fNextSwath is FALSE
    *************************************************************************/
   if  (bPrintDir == LTOR || ((nLeftBidi < nRightBidi) && bPrintDir == BIDI))
   {
      /* if carr left of acceleration ramp portion then print left to right */
      lpHwData->bPrtCarrDirection = RIGHT;
      lpHwData->wPrtStartPosition = (WORD)nLeftPrintPos;
      lpHwData->wPrtCarrStartPosition = (WORD)nLeftPlusAccel;
      if (nMaxDecelDist >= nMaxAccelDist)
         lpHwData->wPrtCarrStopPosition = (WORD)RightPosPlus(nRightPrintPos,
                                                             nMaxDecelDist);
      else
         lpHwData->wPrtCarrStopPosition = (WORD)RightPosPlus(nRightPrintPos,
                                                             nMaxAccelDist);

      if     (lpHwData->wPrtCarrStopPosition > RIGHT_SIDE_FRAME_POSITION)
          lpHwData->wPrtCarrStopPosition = RIGHT_SIDE_FRAME_POSITION;

      if    ((nCarrPos > nLeftPlusAccel) && (nCarrPos > LEFT_PRINT_LIMIT))
      {
         if    (nLeftPlusAccel < LEFT_PRINT_LIMIT)
            nLeftPlusAccel = LEFT_PRINT_LIMIT;

         if ((nCarrPos - nLeftPlusAccel) >= ShortestMoveDist (lpHwData,
                                                              SPEED_FAST,
                                                              TRUE))
            lpHwData->bPosCarrSpeed = SPEED_FAST;
         else if ((nCarrPos - nLeftPlusAccel) >= ShortestMoveDist (lpHwData,
                                                                   SPEED_NORMAL,
                                                                   TRUE))
            lpHwData->bPosCarrSpeed = SPEED_NORMAL;
         else if ((nCarrPos - nLeftPlusAccel) >= ShortestMoveDist (lpHwData,
                                                                   SPEED_SLOW,
                                                                   TRUE))
            lpHwData->bPosCarrSpeed = SPEED_SLOW;

         /* else  We're very close.. do we need to back off?  Same questions
          * applies to right move below */
         if (lpHwData->bPosCarrSpeed != SPEED_STOPPED)
         {
            lpHwData->bPosCarrDirection = LEFT;
            lpHwData->wPosCarrStartPosition = (WORD)nCarrPos;
            lpHwData->wPosCarrStopPosition = (WORD)nLeftPlusAccel;
         }
      }
   }
   else
   {
      if ((bPrintDir == RTOL) || (bPrintDir == BIDI))
      {

         lpHwData->bPrtCarrDirection = LEFT;
         lpHwData->wPrtStartPosition = (WORD)nRightPrintPos;
         lpHwData->wPrtCarrStartPosition = (WORD)nRightPlusAccel;

         if (nMaxDecelDist >= nMaxAccelDist)
            lpHwData->wPrtCarrStopPosition = (WORD)LeftPosPlus(nLeftPrintPos,
                                                               nMaxDecelDist);
         else
            lpHwData->wPrtCarrStopPosition = (WORD)LeftPosPlus(nLeftPrintPos,
                                                               nMaxAccelDist);

       if (lpHwData->wPrtCarrStopPosition < LEFT_PRINT_LIMIT)
          lpHwData->wPrtCarrStopPosition = LEFT_PRINT_LIMIT;

         if ((nCarrPos < nRightPlusAccel) && (nCarrPos < RIGHT_PRINT_LIMIT ))
         {
            /* need to position carrier before printing */
            if ( nRightPlusAccel > RIGHT_PRINT_LIMIT )
            {
                nRightPlusAccel = RIGHT_PRINT_LIMIT;
            }
            if ((nRightPlusAccel - nCarrPos) >= ShortestMoveDist(lpHwData,
                                                                 SPEED_FAST,
                                                                 TRUE))
               lpHwData->bPosCarrSpeed = SPEED_FAST;
            else if ((nRightPlusAccel - nCarrPos) >= ShortestMoveDist (lpHwData,
                                                                       SPEED_NORMAL,
                                                                       TRUE))
               lpHwData->bPosCarrSpeed = SPEED_NORMAL;
            else if ((nRightPlusAccel - nCarrPos) >= ShortestMoveDist (lpHwData,
                                                                       SPEED_SLOW,
                                                                       TRUE))
               lpHwData->bPosCarrSpeed = SPEED_SLOW;


            if (lpHwData->bPosCarrSpeed != SPEED_STOPPED)
            {
               lpHwData->bPosCarrDirection = RIGHT;
               lpHwData->wPosCarrStartPosition = (WORD)nCarrPos;
               lpHwData->wPosCarrStopPosition = (WORD)nRightPlusAccel;
            }

         }
      }
   }

   return;

}  /* end of CalcCarrierPositions() */


/***************************************************************************
 * FCKELVIN.C                                Lexmark Confidential
 *
 * Function Name:    CalculateAppendDistance
 *
 * Description:
 *    This function takes the current print swath stop position and
 *    determines if it should be extended to position the carrier
 *    correctly for the next swath to print.  All calculations
 *    are using 1/600" units.  Note that LEFT/RIGHT and the carrier
 *    position increment/decrement is with respect to the page,
 *    not the printer ( page LEFT and RIGHT is reversed from printer
 *    LEFT and RIGHT).
 *
 *
 * Inputs:  lpDataRec          Long pointer to print device structure.
 *
 * Outputs: None
 *
 * Major Functions Called:    None
 *
 * Original Author: K. Profitt
 * Date: 10/3/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void CalculateAppendDistance(LPDVDATAREC lpDataRec)
{
   int nCurrLeftPrintPos;  /* left print pos of cur swath */
   int nCurrRightPrintPos; /* right print pos of cur swath */
   int nNextLeftPrintPos;  /* left prt pos of next swath */
   int nNextRightPrintPos; /* right prt pos of next swath */
   int nAppendDist;
   int nMaxAccelDist;

   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;


   nMaxAccelDist = MaxAccelDistance(lpDataRec, lpHwData->bPrtCarrSpeed);

   nCurrLeftPrintPos = PrintPos(pfData->bResolution, pfData->bPrintHead,
                                pfData->nLeftPrintPos, LEFT);

   nCurrRightPrintPos = PrintPos(pfData->bResolution, pfData->bPrintHead,
                                 pfData->nRightPrintPos, RIGHT);

#ifndef GEN_COL_BIDI
   if (pfData->bPrintDirection == BIDI)
#endif /* GEN_COL_BIDI */
   {
      nCurrLeftPrintPos += GetBidiAlign(lpHwData, LEFT, pfData->bPrintHead);
      nCurrRightPrintPos += GetBidiAlign(lpHwData, RIGHT, pfData->bPrintHead);

      nCurrLeftPrintPos = PositionCompensation(nCurrLeftPrintPos, LEFT);
      nCurrRightPrintPos = PositionCompensation(nCurrRightPrintPos, RIGHT);
   }

   /*************************************************************************
    * The PreRoatate values are kept in bytes for a raster line. Therefore,
    * to convert to slices, need to multiply by 8 bits per slice and add
    * the left margin.
    *************************************************************************/
   /* if the following is TRUE then the next swath is empty */
   if   ((pfData->nPreRotateEnd - pfData->nPreRotateStart) <= 0)
   {
      /* Next swath empty so move carrier all the way to the end of the
         print line to prepare for next swath with data */
      nNextLeftPrintPos = LEFT_PRINT_LIMIT + nMaxAccelDist;
      nNextRightPrintPos = RIGHT_PRINT_LIMIT - nMaxAccelDist;
   }
   else
   {
      nNextLeftPrintPos =  RastertoPrintPos(pfData->nPreRotateStart,
                                            pfData->wLeftMargin);
      nNextRightPrintPos = RastertoPrintPos(pfData->nPreRotateEnd,
                                            pfData->wLeftMargin);
      nNextRightPrintPos -= 1;

      if (pfData->bPrintHead == MONO_CARTRIDGE)
      {
        nNextRightPrintPos +=(MONO_NOZZLE_OFFSET * pfData->nSwathResMult);
        nNextLeftPrintPos -=(MONO_NOZZLE_OFFSET * pfData->nSwathResMult);
      }
      else
      {
        nNextRightPrintPos += ((COLOR_NOZZLE_OFFSET + COLOR_HEAD_OFFSET) *
                               pfData->nSwathResMult);
        nNextLeftPrintPos -= ((COLOR_NOZZLE_OFFSET + COLOR_HEAD_OFFSET) *
                              pfData->nSwathResMult);
      }


      /* Now convert to 1/600" units */
      nNextLeftPrintPos = PrintPos(pfData->bResolution,
                                   pfData->bPreRotatePrintHead,
                                   nNextLeftPrintPos, LEFT);
      nNextRightPrintPos = PrintPos(pfData->bResolution,
                                    pfData->bPreRotatePrintHead,
                                    nNextRightPrintPos, RIGHT);

#ifndef GEN_COL_BIDI
      if (pfData->bPreRotateDir == BIDI)
#endif /* GEN_COL_BIDI */
      {
         nNextLeftPrintPos += GetBidiAlign(lpHwData, LEFT,
                                           pfData->bPreRotatePrintHead);
         nNextRightPrintPos += GetBidiAlign(lpHwData, RIGHT,
                                            pfData->bPreRotatePrintHead);

         /* make sure on 1/150" boundaries */
         nNextLeftPrintPos = PositionCompensation(nNextLeftPrintPos, LEFT);
         nNextRightPrintPos = PositionCompensation(nNextRightPrintPos, RIGHT);


         /* If there is room on the print line for draft printing,
            add ALPHA_STEP_DRAFT to allow for more settle time */

         if    (lnabs(nNextLeftPrintPos - (LEFT_PRINT_LIMIT + nMaxAccelDist)) >
                ALPHA_STEP_DRAFT)
            nNextLeftPrintPos -= ALPHA_STEP_DRAFT;
         else
            if   (nNextLeftPrintPos > (LEFT_PRINT_LIMIT + nMaxAccelDist))
               nNextLeftPrintPos = LEFT_PRINT_LIMIT + nMaxAccelDist;

         if    (lnabs(RIGHT_PRINT_LIMIT - nNextRightPrintPos - nMaxAccelDist) >
                ALPHA_STEP_DRAFT)
            nNextRightPrintPos += ALPHA_STEP_DRAFT;
         else
            if   (nNextRightPrintPos < (RIGHT_PRINT_LIMIT - nMaxAccelDist))
               nNextRightPrintPos = RIGHT_PRINT_LIMIT - nMaxAccelDist;
      }
   }


/***************************************************************************
 *                Bidirectional Printing
 *
 *       LPP                 RPP
 *      ______________________
 *      |_____________________|
 *
 *                             <--------------------> nAppendDistance
 *
 *                                Next LPP         Next  RPP
 *                                   _______________
 *                                   |______________|
 *   |---------------------------------------------------------|
 *     CP--->
 ***************************************************************************/


/***************************************************************************
 *                Unidirectional Printing
 *
 *      LPP             RPP
 *       ________________
 *       |________________|
 *
 *                         <---------> nAppendDistance
 *
 *                                 Next LPP      Next  RPP
 *                                    _______________
 *                                    |______________|
 *   |---------------------------------------------------------|
 *    CP----->
 ***************************************************************************/

   if (  lpHwData->bPrtCarrDirection == RIGHT )
   {  /* printing in right direction */
      if (pfData->bPrintDirection == BIDI)
         nAppendDist = nNextRightPrintPos - nCurrRightPrintPos;
      else
         nAppendDist = nNextLeftPrintPos - nCurrRightPrintPos;

      if (nAppendDist <= 0 )
         nAppendDist = 0;

      lpHwData->wPrtCarrStopPosition += (WORD)nAppendDist;


   }  /* end of printing in right direction */


/***************************************************************************
 *                    Bidirection Printing
 *
 *
 *                              LPP                 RPP
 *                               ______________________
 *                               |_____________________|
 *
 *                         <-----> nAppendDistance
 *
 *      Next LPP      Next  RPP
 *          _______________
 *         |______________|
 *   |---------------------------------------------------------|
 *                                                     <----CP
 ***************************************************************************/


/***************************************************************************
 *                    Unidirection Printing
 *
 *                             LPP                 RPP
 *                               ______________________
 *                               |_____________________|
 *
 *                       <-------> nAppendDistance
 *
 *     Next LPP      Next  RPP
 *        _______________
 *       |______________|
 *   |---------------------------------------------------------|
 *                                                     <----CP
 ***************************************************************************/


  else  /* printing towards left side of page */
  {

     if (pfData->bPrintDirection == BIDI)
         nAppendDist = nCurrLeftPrintPos - nNextLeftPrintPos;
     else
         nAppendDist = nCurrLeftPrintPos - nNextRightPrintPos;

      if (nAppendDist <= 0 )
      {
         nAppendDist= 0;
      }

      lpHwData->wPrtCarrStopPosition -= (WORD)nAppendDist;
   }  /* end of printing in left direction */

   return;

}  /* end of CalculateAppendDistance() */



/***************************************************************************
 *                                                  Lexmark Confidential
 *
 *  Function Name: PerformPrintMaintenance
 *
 *  Description:
 *
 *   This function determines if maintenance needs to be performed while
 *   the page is printing.  If the ink dot count exceeds a threshold or
 *   if the time since the last maintenance exceeds a threshold then
 *   maintenance is performed before the line is printed.
 *
 *  Inputs:
 *   None
 *
 *  Outputs:
 *   None
 *
 *  Original Author : K. Profitt
 *  Date: 10/27/94
 *
 *  Changes:
 *   Date       Name             Reason for Change
 *                     
 * 12/15/97       RFL            Modified ifdef for 32 bit compile.
 *************************************************************************/
void PerformPrintMaintenance (LPDVDATAREC lpDataRec)
{
   long lSpitCount;
   long lWipeCount;
   BYTE i;
   BYTE inkIndex;
#ifdef DEBUG_MAINT
   BYTE n;
#endif /* DEBUG_MAINT */
   struct pf_data FAR *pfData;
   long dlTime;
   struct tHwData FAR *lpHwData;

/* #ifndef DOS_BUILD */    /*RFL*/
#ifdef FC_WIN_16           /*RFL*/
   dlTime = (long)GetTickCount ();
#else /* FC_WIN_16 */
   dlTime = 0;
#endif /* FC_WIN_16 */
   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   lSpitCount = 0;
   lWipeCount = 0;

   /*****************************************************************
    * If the dot count for either printhead exceeds a certain dot
    * threshold, then should perform full maintenace ( spit & wipe )
    *****************************************************************/
#if DO_MONO_MAINT /*  mono head maintenance  */

   if (pfData->bPrintHead == MONO_CARTRIDGE)
   {
      if ((llabs(pfData->alDotCount[MONO_INK] -
           lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][MONO_INK])) >=
          MONO_PRINTING_THRESHOLD)
      {
         lSpitCount = lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][MONO_INK];
         lWipeCount = lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][MONO_INK];
#ifndef DOS_BUILD
         pfData->alDotCount[MONO_INK] += lSpitCount * BLACK_NOZ_CNT;
#endif  /* DOS_BUILD */
         lpHwData->alHwDotCount[LAST_SPIT_TIME][MONO_INK] = dlTime;
         /* resynch the idle dot count */
         lpHwData->alHwDotCount[IDLE_DOT_CNT][MONO_INK] =
                                pfData->alDotCount[MONO_INK];
      }
   }
   else
#endif  /* end DO_MONO_MAINT */


#if DO_COLOR_MAINT /*  color head maintenance  */

   {
      /***********************************************************************
       * For now, the thresholds spit/wipe counts are the same for all color
       * heads, but they're stored and accessed via array indexing (inkIndex)
       * for future expandability.
       ***********************************************************************/
      for (inkIndex = CYAN_INK; inkIndex <= YELLOW_INK; inkIndex++)
      {
         if ((llabs(pfData->alDotCount[inkIndex] -
              lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][inkIndex])) >=
             COLOR_PRINTING_THRESHOLD)
         {
            lSpitCount = lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][inkIndex];
            lWipeCount = lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][inkIndex];

#ifdef TWO_PEN
#ifndef DOS_BUILD
            for (i = 0; i < MAX_NUM_INKS; i++)
               pfData->alDotCount[i] += lSpitCount * (COLOR_NOZ_CNT / 3);
#endif /* DOS_BUILD */
#endif /* TWO_PEN */

            for (i = CYAN_INK; i <= YELLOW_INK; i++)
            {
#ifndef DOS_BUILD
               pfData->alDotCount[i] += lSpitCount * (COLOR_NOZ_CNT / 3);
               lpHwData->alHwDotCount[LAST_SPIT_TIME][i] = dlTime;
#endif /* DOS_BUILD */
               /* resynch the idle dot count */
               lpHwData->alHwDotCount[IDLE_DOT_CNT][i] = pfData->alDotCount[i];
            }
            break;  /* One spit trigger is enough for now, check other colors next time through */
         }
      }
   }

#endif /* DO_COLOR_MAINT */

#if DO_KCM_MAINT /*  KCM head maintenance  */

      if ( ((llabs(pfData->alDotCount[DILUTED_C_INK] -
             lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][DILUTED_C_INK])) >=
            COLOR_PRINTING_THRESHOLD) ||

           ((llabs(pfData->alDotCount[DILUTED_M_INK] -
             lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][DILUTED_M_INK])) >=
            COLOR_PRINTING_THRESHOLD) ||

           ((llabs(pfData->alDotCount[DILUTED_K_INK] -
             lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][DILUTED_K_INK])) >=
            COLOR_PRINTING_THRESHOLD) )
      {

         lSpitCount = lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][DILUTED_C_INK];
         lWipeCount = lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][DILUTED_C_INK];


         for (i = 0; i < MAX_NUM_INKS; i++)
         {
#ifndef DOS_BUILD
            pfData->alDotCount[i] += lSpitCount * (COLOR_NOZ_CNT / 3);
#endif /* DOS_BUILD */
               lpHwData->alHwDotCount[LAST_SPIT_TIME][i] = dlTime;
            }

            for (i = DILUTED_C_INK; i <= DILUTED_K_INK; i++)
            {
               lpHwData->alHwDotCount[LAST_SPIT_TIME][i] = dlTime;
               lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][i] =  pfData->alDotCount[i];
               lpHwData->alHwDotCount[IDLE_DOT_CNT][i] =  pfData->alDotCount[i];
            }
      }  /* end KCM Maintenance */


#endif  /* DO_KCM_MAINT */

   if (lSpitCount != 0)
   {
#ifdef DVT
      SendMaintenanceCmd(lpDataRec, (WORD)lSpitCount, (WORD)lWipeCount);
#endif /* DVT */
      ResetHeadMaintenance(lpDataRec);
   }
   else
   {

#if DO_COLOR_IDLE_MAINT

      if (pfData->bPrintHead == COL_CARTRIDGE)
      {
         /*******************************************************************
          * The following code is to support maintenance where if either
          * printhead is idle for more than the specifided Idle Time.
          * Note that the LAST_SPIT_TIME is set at the same time for all colors
          * and that MAX_IDLE_TIME is the same for all colors..  if these are
          * different, this condition will need to be modified to check for
          * each color.
          *******************************************************************/
         if ((llabs(dlTime - lpHwData->alHwDotCount[LAST_SPIT_TIME][CYAN_INK])) >=
               lpHwData->alHwDotCount[MAX_IDLE_TIME][CYAN_INK] )
         {
            if ( (pfData->alDotCount[YELLOW_INK] <=
                  lpHwData->alHwDotCount[IDLE_DOT_CNT][YELLOW_INK] ) ||
                 (pfData->alDotCount[MAGENTA_INK] <=
                  lpHwData->alHwDotCount[IDLE_DOT_CNT][MAGENTA_INK] ) ||
                 (pfData->alDotCount[CYAN_INK] <=
                  lpHwData->alHwDotCount[IDLE_DOT_CNT][CYAN_INK] ))
            {
               /* Assuming idle spit count is same for all colors.. */
               lSpitCount = lpHwData->alHwDotCount[IDLE_SPIT_COUNT][CYAN_INK];
               SendSpitCmd(lpDataRec, (WORD)lSpitCount);

               for (i = CYAN_INK; i <= YELLOW_INK; i++)
               {
#ifndef DOS_BUILD
                  pfData->alDotCount[i] += lSpitCount * (COLOR_NOZ_CNT / 3);
#endif  /* DOS_BUILD */
                  lpHwData->alHwDotCount[LAST_SPIT_TIME][i] = dlTime;
                  lpHwData->alHwDotCount[IDLE_DOT_CNT][i] = pfData->alDotCount[i];
               }
            } /* end no dot check */
         } /* end time check */
      }   /* end if color printhead */

#endif /* DO_COLOR_IDLE_MAINTENANCE */

#if DO_KCM_IDLE_MAINT /*  KCM head maintenance  */
         if ((llabs(dlTime - lpHwData->alHwDotCount[LAST_SPIT_TIME][DILUTED_C_INK])) >=
             lpHwData->alHwDotCount[MAX_IDLE_TIME][DILUTED_C_INK] )
         {
             if ( (pfData->alDotCount[DILUTED_K_INK] <=
                   lpHwData->alHwDotCount[IDLE_DOT_CNT][DILUTED_K_INK] ) ||
                  (pfData->alDotCount[DILUTED_M_INK] <=
                   lpHwData->alHwDotCount[IDLE_DOT_CNT][DILUTED_M_INK] ) ||
                  (pfData->alDotCount[DILUTED_C_INK] <=
                   lpHwData->alHwDotCount[IDLE_DOT_CNT][DILUTED_C_INK] ) )
             {
                lSpitCount = lpHwData->alHwDotCount[IDLE_SPIT_COUNT][DILUTED_C_INK];
                SendSpitCmd(lpDataRec, (WORD)lSpitCount);

                for (i = DILUTED_C_INK; i <= DILUTED_K_INK; i++)
                {
#ifndef DOS_BUILD
                   pfData->alDotCount[i] += lSpitCount * (COLOR_NOZ_CNT / 3);
#endif /* DOS_BUILD */
                   lpHwData->alHwDotCount[LAST_SPIT_TIME][i] = dlTime;
                   lpHwData->alHwDotCount[IDLE_DOT_CNT][i] = pfData->alDotCount[i];
                }
            }
         }

#endif /* DO_KCM_IDLE_MAINT */

#if DO_MONO_IDLE_MAINT /*  mono head maintenance  */
      if (pfData->bPrintHead == MONO_CARTRIDGE)
      {
         if ((llabs(dlTime - lpHwData->alHwDotCount[LAST_SPIT_TIME][MONO_INK] )) >=
               lpHwData->alHwDotCount[MAX_IDLE_TIME][MONO_INK] )
         {
            if (pfData->alDotCount[MONO_INK] <=
                lpHwData->alHwDotCount[IDLE_DOT_CNT][MONO_INK] )
            {
               lSpitCount = lpHwData->alHwDotCount[IDLE_SPIT_COUNT][MONO_INK];
               SendSpitCmd(lpDataRec,(WORD)lSpitCount);
#ifndef DOS_BUILD
             pfData->alDotCount[MONO_INK] += lSpitCount * BLACK_NOZ_CNT;
#endif /* DOS_BUILD */
               lpHwData->alHwDotCount[LAST_SPIT_TIME][MONO_INK] = dlTime;
               /* Update count for black only so it will spit again if black not used */
               lpHwData->alHwDotCount[IDLE_DOT_CNT][MONO_INK] = pfData->alDotCount[MONO_INK];
            }
         }
      }
#endif /* DO_MONO_IDLE_MAINT */
   }

   return;

}  /* end of PerformPrintMaintenance() */


/***************************************************************************
 * PH_FUNC.C                                        Lexmark Confidential
 *
 *  Function Name:
 *    ResetHeadMaintenance
 *
 *  Description:
 *
 *   This function is called after maintenance is performed to reset
 *   the dot counting variables and time.  The dot counting variables
 *   are used to determine is maintenance is required during printing.
 *
 *  Inputs:
 *   None
 *
 *  Outputs:
 *   None
 *
 *  Original Author : K. Profitt
 *  Date: 10/27/94
 *
 *  Changes:
 *   Date       Name             Reason for Change
 *                     
 * 12/15/97       RFL            Modified ifdef for 32 bit compile.
 *************************************************************************/
void ResetHeadMaintenance (LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   long dlStartTime;
   WORD n;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

/* #ifndef DOS_BUILD */  /*RFL*/
#ifdef FC_WIN_16         /*RFL*/
   dlStartTime = (long)GetTickCount ();
#else /* FC_WIN_16 */
   dlStartTime = 0;
#endif /* FC_WIN_16 */

   /* initial dot count to 0 for all color planes */
   for (n = 0; n < MAX_NUM_INKS; n++)
   {
      lpHwData->alHwDotCount[DOT_THRESHOLD_CNT][n] =  pfData->alDotCount[n];
      lpHwData->alHwDotCount[IDLE_DOT_CNT][n]      =  pfData->alDotCount[n];
      lpHwData->alHwDotCount[LAST_SPIT_TIME][n]    =  dlStartTime;
   }


   lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][MAGENTA_INK] =
                          COLOR_THRESHOLD_SPIT_CNT;
   lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][CYAN_INK] =
                          COLOR_THRESHOLD_SPIT_CNT;
   lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][YELLOW_INK] =
                          COLOR_THRESHOLD_SPIT_CNT;

   lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][DILUTED_M_INK] =
                          KCM_THRESHOLD_SPIT_CNT;
   lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][DILUTED_C_INK] =
                          KCM_THRESHOLD_SPIT_CNT;
   lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][DILUTED_K_INK] =
                          KCM_THRESHOLD_SPIT_CNT;

   lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][MAGENTA_INK] =
                          COLOR_THRESHOLD_WIPE_CNT;
   lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][CYAN_INK] =
                          COLOR_THRESHOLD_WIPE_CNT;
   lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][YELLOW_INK] =
                          COLOR_THRESHOLD_WIPE_CNT;

   lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][DILUTED_M_INK] =
                          KCM_THRESHOLD_WIPE_CNT;
   lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][DILUTED_C_INK] =
                          KCM_THRESHOLD_WIPE_CNT;
   lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][DILUTED_K_INK] =
                          KCM_THRESHOLD_WIPE_CNT;

   lpHwData->alHwDotCount[IDLE_SPIT_COUNT][MAGENTA_INK] = COLOR_IDLE_SPIT_CNT;
   lpHwData->alHwDotCount[IDLE_SPIT_COUNT][CYAN_INK] = COLOR_IDLE_SPIT_CNT;
   lpHwData->alHwDotCount[IDLE_SPIT_COUNT][YELLOW_INK] = COLOR_IDLE_SPIT_CNT;

   lpHwData->alHwDotCount[IDLE_SPIT_COUNT][DILUTED_M_INK] = KCM_IDLE_SPIT_CNT;
   lpHwData->alHwDotCount[IDLE_SPIT_COUNT][DILUTED_C_INK] = KCM_IDLE_SPIT_CNT;
   lpHwData->alHwDotCount[IDLE_SPIT_COUNT][DILUTED_K_INK] = KCM_IDLE_SPIT_CNT;

   lpHwData->alHwDotCount[MAX_IDLE_TIME][MAGENTA_INK] = COLOR_MAX_IDLE_TIME;
   lpHwData->alHwDotCount[MAX_IDLE_TIME][CYAN_INK] = COLOR_MAX_IDLE_TIME;
   lpHwData->alHwDotCount[MAX_IDLE_TIME][YELLOW_INK] = COLOR_MAX_IDLE_TIME;

   lpHwData->alHwDotCount[MAX_IDLE_TIME][DILUTED_M_INK] = KCM_MAX_IDLE_TIME;
   lpHwData->alHwDotCount[MAX_IDLE_TIME][DILUTED_C_INK] = KCM_MAX_IDLE_TIME;
   lpHwData->alHwDotCount[MAX_IDLE_TIME][DILUTED_K_INK] = KCM_MAX_IDLE_TIME;

   if (lpDataRec->bLeftCartridgeID != KCM_CARTRIDGE)
   {
      lpHwData->alHwDotCount[THRESHOLD_SPIT_CNT][MONO_INK] =
                             MONO_THRESHOLD_SPIT_CNT;
      lpHwData->alHwDotCount[THRESHOLD_WIPE_CNT][MONO_INK] =
                             MONO_THRESHOLD_WIPE_CNT;
      lpHwData->alHwDotCount[IDLE_SPIT_COUNT][MONO_INK] = MONO_IDLE_SPIT_CNT;
      lpHwData->alHwDotCount[MAX_IDLE_TIME][MONO_INK] = MONO_MAX_IDLE_TIME;
   }

   return;

}  /* end of ResetHeadMaintenance() */


/******************************************************************
 *  FCVOLTA.C                               Lexmark Confidential
 *
 * Function Name:    SendMaintenanceCmd
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to perform printhead maintenance.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
void SendMaintenanceCmd(LPDVDATAREC lpDataRec, WORD wSpitCount, WORD wWipeCount)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   BYTE   abPrinterCmd[COMMAND_SIZE] = {MAINTENANCE_CMD, MAINT_SPIT_POS,
                                        0x00,0x00,0x00,0x00, 0x00, 0x00};
   LPBYTE lpCmd;
#ifdef REPEAT_WITH_MULTIPLE_CMDS
   WORD   wipeTotal;
#endif /* REPEAT_WITH_MULTIPLE_CMDS */

   lpCmd = abPrinterCmd;
   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   if (wSpitCount == 0)
      return;

   if (pfData->bPrintHead == COL_CARTRIDGE)
      abPrinterCmd[1] |= MAINT_COLOR;
   else
      abPrinterCmd[1] |= MAINT_MONO;

   abPrinterCmd[2] = (BYTE)(wSpitCount / 2);
#ifdef REPEAT_WITH_MULTIPLE_CMDS
   /**************************************************************************
    * The 041497 Kelvin firmware does not handle the repeat operation for
    * this for this command properly. It repeats the wipes, but not the spits.
    * This means 1) we aren't getting the recommended # of spits,
    *        and 2) we're wiping without spitting, a bad thing according to
    *               Chuck.
    * To work around this in the driver software, we will loop here to repeat
    * spits and wipes.
    **************************************************************************/
   abPrinterCmd[3] = (BYTE)1; /* would normally be repeat count (wWipeCount), if not looping below */

   for (wipeTotal = 1; wipeTotal <= wWipeCount; wipeTotal++)
#else /* REPEAT_WITH_MULTIPLE_CMDS */
   abPrinterCmd[3] = wWipeCount;
#endif /* REPEAT_WITH_MULTIPLE_CMDS */
   {
      if (lpHwData->wCurrCarrPos > LEFT_SIDE_FRAME_POSITION)
      {
         FCSendCartridgeHome(lpDataRec);
      }

      OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

      lpHwData->wCurrCarrPos = MONO_SPIT_POSITION;
   }

   return;

}  /* end of SendMaintenanceCmd() */


/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    UpdatePageDotCount
 *
 * Description:
 *    This function is called to update dot counts from a maintenance
 *    command sent to the printer.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *          SpitCnt    Number of spits per nozzle
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
void UpdatePageDotCount(LPDVDATAREC lpDataRec, WORD wSpitCount)
{
   struct pf_data FAR *pfData;
   BYTE i;
   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

   if (wSpitCount == 0)
      return;

#ifndef DOS_BUILD
   if (pfData->bPrintHead == COL_CARTRIDGE)
   {
      for (i = CYAN_INK; i <= YELLOW_INK; i++)
         pfData->alDotCount[i] += wSpitCount * (COLOR_NOZ_CNT / 3);
   }
   else
      pfData->alDotCount[MONO_INK] += wSpitCount * BLACK_NOZ_CNT;
#endif  /* DOS_BUILD */

   return;

}  /* end of UpdatePageDotCount() */



/******************************************************************
 *  FCVOLTA.C                               Lexmark Confidential
 *
 * Function Name:    SendSpitCmd
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to perform printhead maintenance when there
 *    is no wipe command with the spit.
 *
 * Inputs:  lpDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Major Functions Called:  OUTPUT
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
void SendSpitCmd(LPDVDATAREC lpDataRec, WORD wSpitCount)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   BYTE   abPrinterCmd[COMMAND_SIZE] = {SPIT_CMD,0x00,0x00,0x00,
                                        0x00,0x00,0x00, 0x00};
   WORD   minDist;
   LPBYTE lpCmd;

   lpCmd = abPrinterCmd;
   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   if (wSpitCount == 0)
      return;

   minDist = (WORD)ShortestMoveDist (lpHwData, SPEED_FAST, FALSE);
   /* Can we move to spit quickly? */
   if (lpHwData->wCurrCarrPos > MONO_SPIT_POSITION + minDist)
   {
       lpHwData->wPosCarrStartPosition = lpHwData->wCurrCarrPos;
       lpHwData->wPosCarrStopPosition = MONO_SPIT_POSITION;
       lpHwData->bPosCarrDirection = LEFT;
       lpHwData->bPosCarrSpeed = SPEED_FAST;
   }
   else
   {
       /********************************************************************
        * When we're close to the spit position, perform all moves (left or
        * right) at slow speed
        ********************************************************************/
       lpHwData->bPosCarrSpeed = SPEED_SLOW;
       /* Are we too close to move to spit position, even at slow speed? */
       if (lpHwData->wCurrCarrPos < (MONO_SPIT_POSITION +
                                     (WORD)ShortestMoveDist (lpHwData,
                                                             SPEED_SLOW,
                                                             FALSE)))
       {
          /* If so, back away from the spit position a little and move back
           * over */
          lpHwData->wPosCarrStartPosition = lpHwData->wCurrCarrPos;
          lpHwData->wPosCarrStopPosition = MONO_SPIT_POSITION + minDist;
          lpHwData->bPosCarrDirection = RIGHT;
                  PositionCarrierForPrint (lpDataRec);
       }
       lpHwData->wPosCarrStartPosition = lpHwData->wCurrCarrPos;
       lpHwData->wPosCarrStopPosition = MONO_SPIT_POSITION;
       lpHwData->bPosCarrDirection = LEFT;
   }

   /* Position for spit (not print) */
   PositionCarrierForPrint(lpDataRec);

   if (pfData->bPrintHead == COL_CARTRIDGE)
      abPrinterCmd[1] |= MAINT_COLOR;
   else
      abPrinterCmd[1] |= MAINT_MONO;


   abPrinterCmd[2] = (BYTE)(wSpitCount / 2);

   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

   return;

}  /* end of SendSpitCmd() */



#ifdef USE_DRIVER_RAMP
/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: GetWord
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
/*******************************************************************
 *  PARSEDAT.C  reads ELCTABLE.DAT and ELCPARA.TXT and loads the
 *  data into a structure for manipulation.  It requires
 *    <stdio.h> <fckelvin.h> <stdlib.h> or the equivilant
 *  getword() returns a word read from the file pointed to by the
 *  file stream pointer passed to it.
 *  GetByte() returns a byte read from the file pointed to by the
 *  file stream pointer passed to it.
 *  getzero() reads and discards the number of bytes referenced in
 *  the integer passed to it from the file pointed to by the file
 *  stream pointer passed to it.
 *  ParseParmFile() reads ELCPARA.TXT and loads the data found therein
 *  into the structure pointed to by tHwData.
 *  parse() uses the above functions to read the data in ELCPARA.TXT
 *  and ELCTABLE.DAT into the structure pointed to by tHwData.
 *                                           Jay Vessels  #988396
 *******************************************************************/
#define MSBSET   0x80   /*This masks the high bit*/
#define FILE_IN_TXT "ELCPARA.TXT"
#define FILE_IN_DAT "ELCTABLE.DAT"

WORD GetWord(LPBYTE lpbBuffer, LPINT lpnSize) /* read a word from *lpbBuffer */
{
   BYTE lobyte;
   BYTE hibyte;
   WORD data;

   hibyte = GetByte(lpbBuffer, lpnSize);
   lobyte = GetByte(lpbBuffer + 1, lpnSize);
   data = (WORD)(lobyte + (hibyte * 256));

   return data;

}  /* end of GetWord() */
#endif /* USE_DRIVER_RAMP */

#ifdef USE_DRIVER_RAMP
/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: GetByte
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
BYTE GetByte(LPBYTE lpbBuffer, LPINT lpnSize) /* read a byte from a file */
{
  *lpnSize -= 1;

  return (*lpbBuffer);

}  /* end of GetByte() */
#endif /* USE_DRIVER_RAMP */

#ifdef USE_DRIVER_RAMP
/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: getzero
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void getzero(LPBYTE lpbBuffer, LPINT lpnSize, int zero) /*discard 'zero' bytes from *lpbBuffer */
{
   int loop;
   for  (loop = 0; loop < zero; loop++)
      GetByte(lpbBuffer,lpnSize);

   return;

}  /* end of getzero() */
#endif /* USE_DRIVER_RAMP */

#ifdef USE_DRIVER_RAMP
/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: ParseHwFile
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
/*#define TSTRMP */
BOOL ParseHwFile(struct tHwData FAR * lpHwData)  /* parse the file ELCTABLE.DAT */
{
   WORD loop, endloop;
   BYTE command;
   LONG   dwBufSize;
   LPINT  lpnSize;
   LPBYTE lpbBuffer;

#ifdef DOS_BUILD
   FILE *hfHwData;
#ifdef TSTRMP
   FILE *rmpfp;
#endif /* TSTRMP */
   LPBYTE lpbBufStart;
#else /* DOS_BUILD */
#ifdef TSTRMP
   HFILE rmpfp;
   LONG  i;
#endif /* TSTRMP */
   HFILE hfHwData;
   OFSTRUCT of;
#endif /* DOS_BUILD */

   lpnSize = (LPINT)&dwBufSize;
   dwBufSize = 0;
   lpbBuffer = NULL;

   ParseParmFile(lpHwData); /* First read and parse the data in ELCPARA.TXT */


#ifdef DOS_BUILD
   if ((hfHwData = fopen(FILE_IN_DAT,"rb"))==NULL)    /*open the file*/
   {
      return(FALSE);
   }

#ifdef TSTRMP
   if  ((rmpfp = fopen("ramp.dat","wb"))==NULL)    /*open the file*/
    return(FALSE);
#endif /* TSTRMP */

    lpbBuffer = (LPBYTE) MALLOC(2000);
    lpbBufStart = lpbBuffer;


    while(!feof(hfHwData))
    {
       *lpbBuffer++ = fgetc(hfHwData);
       dwBufSize++;
    }

   lpbBuffer = lpbBufStart;
   fclose(hfHwData);

#ifdef TSTRMP
   for (i = 0; i < dwBufSize; i++)
       fputc(*(lpbBuffer + i), rmpfp);
   fclose(rmpfp);
#endif /* TSTRMP */



#else /* DOS_BUILD */


    hfHwData = OpenFile (FILE_IN_DAT, &of, OF_READ | OF_SEARCH );
    if (hfHwData == HFILE_ERROR)
    {
        return(FALSE);
    }

#ifdef TSTRMP
    rmpfp = OpenFile ("ramp.dat", &of, OF_WRITE | OF_CREATE );

    if (rmpfp == HFILE_ERROR)
    {
        lclose(hfHwData);

        return(FALSE);
    }

#endif /* TSTRMP */

    /* Find out the length of the file */
    dwBufSize = _llseek(hfHwData, 0, 2);

    /* Return to start of file */
    _llseek(hfHwData, 0, 0);

    if (dwBufSize == -1)
    {
        _lclose (hfHwData);
        return(FALSE);
    }

    lpbBuffer = (LPBYTE) MALLOC(dwBufSize);

    if (lpbBuffer == NULL)
    {
        _lclose (hfHwData);
        if (lpbBuffer)
          FREE(lpbBuffer);
        return(FALSE);
    }


     _lread (hfHwData, lpbBuffer, (WORD)dwBufSize);

    _lclose (hfHwData);

#ifdef TSTRMP
    _lwrite(rmpfp, lpbBuffer, dwBufSize);
    _lclose (rmpfp);
#endif /* TSTRMP */

#endif /* DOS_BUILD */

     while(*lpnSize > 0)
     {
       /*loop through and parse each byte last byte will be a 0xFF, ignored*/
       switch((command=GetByte(lpbBuffer++,lpnSize)))       /*by the parser                    */
         {
           case SET_INIT_1_CMD:
             lpHwData->wPaperLoadStepCntA=GetWord(lpbBuffer++,lpnSize);
             lpbBuffer += 1;
             lpHwData->wPaperLoadStepCntB=GetWord(lpbBuffer++,lpnSize);
             lpbBuffer += 1;
             lpHwData->wManualFeedStepCnt=GetWord(lpbBuffer++,lpnSize);
             lpbBuffer += 1;
             getzero(lpbBuffer++,lpnSize,1); /*last byte is always 0*/
             break;

            case SET_INIT_2_CMD:
              lpHwData->bHomeStepCnt=GetByte(lpbBuffer++,lpnSize);
              lpHwData->wPaperEjectStepCnt=GetWord(lpbBuffer++,lpnSize);
              lpbBuffer += 1;
              lpHwData->bMonoFirePulse=GetByte(lpbBuffer++,lpnSize);
              lpHwData->bColorFirePulse=GetByte(lpbBuffer++,lpnSize);
              getzero(lpbBuffer++,lpnSize,2); /*the last 2 bytes are always 0 */
              lpbBuffer += 1;
              break;

            case FEED_ACCEL_DECEL_CMD:
              for(loop=0;loop<7;loop++)
                lpHwData->bPaperRampTableType[loop]=GetByte(lpbBuffer++,lpnSize);
              break;

            case FEED_RAMP_CMD:
              lpHwData->wPaperRampSRAMOffset=GetWord(lpbBuffer++,lpnSize);
              lpbBuffer += 1;
              lpHwData->wPaperRampTableLength=GetWord(lpbBuffer++,lpnSize);
              lpbBuffer += 1;
              getzero(lpbBuffer++,lpnSize,3); /*bytes 6-8 are always 0*/
              lpbBuffer += 2;
              endloop=lpHwData->wPaperRampTableLength;
              for(loop=0;loop<endloop;loop++)
                lpHwData->bPaperRampTableData[loop]=GetByte(lpbBuffer++,lpnSize);
                break;

            case CARR_ACCEL_DECEL_CMD:
              switch(GetByte(lpbBuffer++,lpnSize))
                {
                  case DATA_OFFSET_9IPS:
                  lpHwData->bAccelStepCntSlow=GetByte(lpbBuffer++,lpnSize);
                  lpHwData->bDecelStepCntSlow=GetByte(lpbBuffer++,lpnSize);
                  lpHwData->wDecelOffsetAddrSlow=GetWord(lpbBuffer++,lpnSize);
                  lpbBuffer += 1;
                  break;

                  case DATA_OFFSET_16IPS:
                  lpHwData->bAccelStepCntNormal=GetByte(lpbBuffer++,lpnSize);
                  lpHwData->bDecelStepCntNormal=GetByte(lpbBuffer++,lpnSize);
                  lpHwData->wDecelOffsetAddrNormal=GetWord(lpbBuffer++,lpnSize);

                  lpbBuffer += 1;
                  break;

                  case DATA_OFFSET_25IPS:
                  lpHwData->bAccelStepCntFast=GetByte(lpbBuffer++,lpnSize);
                  lpHwData->bDecelStepCntFast=GetByte(lpbBuffer++,lpnSize);
                  lpHwData->wDecelOffsetAddrFast=GetWord(lpbBuffer++,lpnSize);
                  lpbBuffer += 1;
                  break;
                }
              getzero(lpbBuffer++,lpnSize,2);                                  /*bytes 7,8 are always 0*/
              lpbBuffer += 1;
              break;

            case CARR_RAMP_CMD:
              lpHwData->wCarrRampSRAMOffset=GetWord(lpbBuffer++,lpnSize);
              lpbBuffer += 1;
              lpHwData->wCarrRampTableLength=GetWord(lpbBuffer++,lpnSize);
              lpbBuffer += 1;
              getzero(lpbBuffer++,lpnSize,3);                                  /*bytes 6-8 are always 0*/
              lpbBuffer += 2;
              endloop=lpHwData->wCarrRampTableLength;
              for(loop=0;loop<endloop;loop++)
                lpHwData->bCarrRampTableData[loop]=GetByte(lpbBuffer++,lpnSize);
              break;
            default:
              break;
            }
     }
    FREE(lpbBuffer);

    return (TRUE);

}  /* end of ParseHwFile() */
#endif /* USE_DRIVER_RAMP */


#ifdef USE_DRIVER_RAMP
/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: ParseParmFile
 *
 * Description:
 *          This is a function to read the file ELCpara.txt and write the
 *          appropriate data into lpHwData
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void ParseParmFile(struct tHwData FAR *lpHwData)
{
   LONG   dwBufSize;
   LPBYTE lpbBuffer;
   char   align;
#ifdef DOS_BUILD
   FILE   *hfHwData;
   LPBYTE lpbBufStart;
#ifdef TSTRMP
   FILE   *rmpfp;
   LONG   i;
   WORD * WordPtr;
#endif /* TSTRMP */
#else /* DOS_BUILD */
   HFILE  hfHwData;
   OFSTRUCT of;
#ifdef TSTRMP
   HFILE  txtfp;
   LPWORD WordPtr;
#endif /* TSTRMP */
#endif /* DOS_BUILD */

#ifdef DOS_BUILD


   if((hfHwData = fopen(FILE_IN_TXT,"rb")) == NULL)    /*open the file*/
      return;

#ifdef TSTRMP
   if((rmpfp=fopen("ramp.dat","wb"))==NULL)    /*open the file*/
    return;
#endif /* TSTRMP */

    lpbBuffer = (LPBYTE) MALLOC(2000);
    lpbBufStart = lpbBuffer;
    dwBufSize = 0;


    while(!feof(hfHwData))
    {
       *lpbBuffer++ = fgetc(hfHwData);
       dwBufSize++;
    }

   lpbBuffer = lpbBufStart;

   fclose(hfHwData);

#ifdef TSTRMP
   for (i = 0; i < dwBufSize; i++)
       fputc(*(lpbBuffer + i), rmpfp);

   fclose(rmpfp);
#endif /* TSTRMP */

#else /* DOS_BUILD */

    hfHwData = OpenFile (FILE_IN_TXT, &of, OF_READ | OF_SEARCH );
    if (hfHwData == HFILE_ERROR)
    {
        return;
    }

#ifdef TSTRMP
   txtfp = OpenFile ("ramp.txt", &of, OF_WRITE);
   if (txtfp == HFILE_ERROR)
       return;
#endif /* TSTRMP */

    /* Find out the length of the file */
    dwBufSize = _llseek(hfHwData, 0, 2);

    /* Return to start of file */
    _llseek(hfHwData, 0, 0);

    if (dwBufSize == -1)
    {

        _lclose (hfHwData);
        return;
    }

    lpbBuffer = (LPBYTE) MALLOC(dwBufSize);

    if (lpbBuffer == NULL)
    {
        _lclose (hfHwData);
        return;
    }

     _lread (hfHwData, lpbBuffer, (WORD)dwBufSize);
    _lclose (hfHwData);


#ifdef TSTRMP
    _lwrite(txtfp, lpbBuffer, dwBufSize);
    _lclose (txtfp);
#endif /* TSTRMP */

#endif /* DOS_BUILD */

   lpHwData->bAccelStepCntSlow = (BYTE)*lpbBuffer++;
   lpHwData->bAlphaStepCntSlow = (BYTE)*lpbBuffer++;
   lpHwData->bDecelStepCntSlow = (BYTE)*lpbBuffer++;

   lpHwData->bAccelStepCntNormal = (BYTE)*lpbBuffer++;
   lpHwData->bAlphaStepCntNormal = (BYTE)*lpbBuffer++;
   lpHwData->bDecelStepCntNormal = (BYTE)*lpbBuffer++;

   lpHwData->bAccelStepCntFast = (BYTE)*lpbBuffer++;
   lpHwData->bAlphaStepCntFast = (BYTE)*lpbBuffer++;
   lpHwData->bDecelStepCntFast = (BYTE)*lpbBuffer++;


   align = (char)*lpbBuffer++;
   lpHwData->nMonoLeftBidiAlign   = (int)align;
   align = (char)*lpbBuffer++;
   lpHwData->nMonoRightBidiAlign  = (int)align;
   align = (char)*lpbBuffer++;
   lpHwData->nColorLeftBidiAlign  = (int)align;
   align = (char)*lpbBuffer++;
   lpHwData->nColorRightBidiAlign = (int)align;


#if 0
   fscanf(hfHwData,"Slow Accel step count = %d\n",WordPtr);
   lpHwData->bAccelStepCntSlow = (BYTE)*WordPtr;
   fscanf(hfHwData,"Slow Alpha step count = %d\n",WordPtr);
   lpHwData->bAlphaStepCntSlow = (BYTE)*WordPtr;
   fputc((BYTE)*WordPtr,rmpfp);
   fscanf(hfHwData,"Slow Decel step count = %d\n",WordPtr);
   lpHwData->bDecelStepCntSlow = (BYTE)*WordPtr;

   fscanf(hfHwData,"16.7 Accel step count = %d\n",WordPtr);
   lpHwData->bAccelStepCntNormal = (BYTE)*WordPtr;
   fscanf(hfHwData,"16.7 Alpha step count = %d\n",WordPtr);
   lpHwData->bAlphaStepCntNormal = (BYTE)*WordPtr;
   fputc((BYTE)*WordPtr,rmpfp);
   fscanf(hfHwData,"16.7 Decel step count = %d\n",WordPtr);
   lpHwData->bDecelStepCntNormal = (BYTE)*WordPtr;

   fscanf(hfHwData,"25 Accel step count = %d\n",WordPtr);
   lpHwData->bAccelStepCntFast = (BYTE)*WordPtr;
   fscanf(hfHwData,"25 Alpha step count = %d\n",WordPtr);
   lpHwData->bAlphaStepCntFast = (BYTE)*WordPtr;
   fputc((BYTE)*WordPtr,rmpfp);
   fscanf(hfHwData, "25 Decel step count = %d\n", WordPtr);
   lpHwData->bDecelStepCntFast = (BYTE)*WordPtr;

#endif /* 0 */


   FREE(lpbBuffer);

   return;

}  /* end of ParseParmFile() */
#endif /* USE_DRIVER_RAMP */


#ifdef USE_DRIVER_RAMP
/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: SendPaperRampTables
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void SendPaperRampTables(LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;
   int i;

   lpCmd = abPrinterCmd;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   /* Output feed motor accel/decel table information command */
   *(lpCmd + 0)= FEED_ACCEL_DECEL_CMD;
   for (i = 1; i < COMMAND_SIZE; i++ )
   {
      *(lpCmd + i) = lpHwData->bPaperRampTableType[i-1];
   }

   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

   /* Clear command data */
   MEMSET(lpCmd, 0x00, COMMAND_SIZE);


   /* Output feed motor accel/decel table data command */
   *(lpCmd + 0) = FEED_RAMP_CMD;
   *(lpCmd + 1) = HIBYTE(lpHwData->wPaperRampSRAMOffset);
   *(lpCmd + 2) = LOBYTE(lpHwData->wPaperRampSRAMOffset);
   *(lpCmd + 3) = HIBYTE(lpHwData->wPaperRampTableLength);
   *(lpCmd + 4) = LOBYTE(lpHwData->wPaperRampTableLength);

   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

   lpCmd = lpHwData->bPaperRampTableData;

   /* Now output the actual paper ramp data */
   OUTPUT(lpDataRec, lpCmd, lpHwData->wPaperRampTableLength);

   return;

}  /* end of SendPaperRampTables() */
#endif /* USE_DRIVER_RAMP */


#ifdef USE_DRIVER_RAMP
/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: SendCarrierRampTables
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void SendCarrierRampTables(LPDVDATAREC lpDataRec)
{
   struct pf_data FAR *pfData;
   struct tHwData FAR *lpHwData;
   BYTE   abPrinterCmd[COMMAND_SIZE] =
                      {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   LPBYTE lpCmd;

   lpCmd = abPrinterCmd;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;
   lpHwData = pfData->lpHwData;

   *(lpCmd + 0) = CARR_ACCEL_DECEL_CMD;
   *(lpCmd + 1) = DATA_OFFSET_9IPS;
   *(lpCmd + 2) = lpHwData->bAccelStepCntSlow;
   *(lpCmd + 3) = lpHwData->bDecelStepCntSlow;
   *(lpCmd + 4) = HIBYTE(lpHwData->wDecelOffsetAddrSlow);
   *(lpCmd + 5) = LOBYTE(lpHwData->wDecelOffsetAddrSlow);

   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

   *(lpCmd + 0) = CARR_ACCEL_DECEL_CMD;
   *(lpCmd + 1) = DATA_OFFSET_16IPS;
   *(lpCmd + 2) = lpHwData->bAccelStepCntNormal;
   *(lpCmd + 3) = lpHwData->bDecelStepCntNormal;
   *(lpCmd + 4) = HIBYTE(lpHwData->wDecelOffsetAddrNormal);
   *(lpCmd + 5) = LOBYTE(lpHwData->wDecelOffsetAddrNormal);

   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

   *(lpCmd + 0) = CARR_ACCEL_DECEL_CMD;
   *(lpCmd + 1) = DATA_OFFSET_25IPS;
   *(lpCmd + 2) = lpHwData->bAccelStepCntFast;
   *(lpCmd + 3) = lpHwData->bDecelStepCntFast;
   *(lpCmd + 4) = HIBYTE(lpHwData->wDecelOffsetAddrFast);
   *(lpCmd + 5) = LOBYTE(lpHwData->wDecelOffsetAddrFast);

   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);


   *(lpCmd + 0) = CARR_RAMP_CMD;
   *(lpCmd + 1) = HIBYTE(lpHwData->wCarrRampSRAMOffset);
   *(lpCmd + 2) = LOBYTE(lpHwData->wCarrRampSRAMOffset);
   *(lpCmd + 3) = HIBYTE(lpHwData->wCarrRampTableLength);
   *(lpCmd + 4) = LOBYTE(lpHwData->wCarrRampTableLength);
   *(lpCmd + 5) = 0x00;

   /* Now send the control codes and the ramp table data to the printer */
   OUTPUT(lpDataRec, lpCmd, COMMAND_SIZE);

   lpCmd = lpHwData->bCarrRampTableData;

   OUTPUT(lpDataRec, lpCmd, lpHwData->wCarrRampTableLength);

   return;

}  /* end of SendCarrierRampTables() */
#endif /* USE_DRIVER_RAMP */

/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: lnabs
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
int lnabs(int n)
{
   if (n < 0)
      return(n*(-1));
   else
      return(n);

}  /* end of lnabs() */


/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: llabs
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
long llabs(long n)
{
   if (n < 0)
      return(n*(-1));
   else
      return(n);

}  /* end of llabs() */



/******************************************************************
 *  FCKELVIN.C                               Lexmark Confidential
 *
 * Function Name:    FCCalcBidiAlign
 *
 * Description:
 *    This function is called from the driver to calculate
 *    the bidi alignment numbers based on the user input and
 *    the alignment numbers that were stored in an ini file.
 *    This function is only used for printers that do not
 *    perform bidirectional alignment in the printer code.
 *
 * Inputs:  lpDataRec      Far pointer to print device structure.
 *          lpBidiAlign    Far pointer to bidirectional alignment values
 *
 * Outputs: lpBidiAlign     Updated bidirectional alignment values
 *
 * Original Author: K. Profitt
 * Date: 01/17/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *****************************************************************/
#ifdef BIDI_ALIGN

void FAR FCCalcBidiAlign(LPBIDIALIGN lpBidiAlign)
{

   if ( (lpBidiAlign->cMonoUserInput == -1) &&
        (lpBidiAlign->cColorUserInput == -1))
   {
      lpBidiAlign->nMonoLeftBidiAlign = MONO_LEFT_BIDI_ALIGN;
      lpBidiAlign->nMonoRightBidiAlign = MONO_RIGHT_BIDI_ALIGN;
      lpBidiAlign->nColorLeftBidiAlign = COLOR_LEFT_BIDI_ALIGN;
      lpBidiAlign->nColorRightBidiAlign = COLOR_RIGHT_BIDI_ALIGN;
   }
   else
   {
      if (lpBidiAlign->cMonoUserInput != -1)
      {
         if ((lpBidiAlign->cMonoUserInput / 2) < (MAX_BIDI_ALIGN / 2))
            lpBidiAlign->nMonoLeftBidiAlign = MONO_LEFT_BIDI_ALIGN +
                          ((MAX_BIDI_ALIGN / 2) - lpBidiAlign->cMonoUserInput);
         else
            lpBidiAlign->nMonoLeftBidiAlign = MONO_LEFT_BIDI_ALIGN -
                          ((MAX_BIDI_ALIGN / 2) - lpBidiAlign->cMonoUserInput);
      }

      if (lpBidiAlign->cColorUserInput != -1)
      {
         if ((lpBidiAlign->cColorUserInput / 2) < (MAX_BIDI_ALIGN / 2))
            lpBidiAlign->nColorLeftBidiAlign = COLOR_LEFT_BIDI_ALIGN +
                         ((MAX_BIDI_ALIGN / 2) - lpBidiAlign->cColorUserInput);
         else
            lpBidiAlign->nColorLeftBidiAlign = COLOR_LEFT_BIDI_ALIGN -
                         ((MAX_BIDI_ALIGN / 2) - lpBidiAlign->cColorUserInput);
      }
   }

   return;

}  /* end of FCCalcBidiAlign() */
#endif /* BIDI_ALIGN */


/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: PopulateBitCount
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void PopulateBitCount(LPDVDATAREC lpDataRec)
{
   /* silence the compiler */
   lpDataRec = lpDataRec;

   return;

}  /* end of PopulateBitCount() */

/***************************************************************************
 *  FCKELVIN.C                                          Lexmark Confidential
 *
 * Function Name:    VerticalMoveInPhase
 *
 * Description:
 *    Large vertical moves must be "in phase", which means they should be
 *    a whole 300 dpi movement.  So for 600dpi printing, large space
 *    vertical movements should be a multiple of 2.  For example, 1/600 is
 *    not an even 300dpi movement, but 2/600 is an even 300dpi movement
 *    (1/300).  This function determines whether a potential large space
 *    vertical move is "in phase".  If the movement is "in phase" then
 *    return 0.  If the movement is not "in phase", then return the number
 *    of blank lines which should be inserted before the next raster line
 *    to reduce the vertical movement enough to bring the vertical movement
 *    "in phase".
 *
 * Inputs:
 *    lpDataRec         Long pointer to print device structure.
 *    lNextRasterLine   raster line number for next raster line.
 *
 * Outputs: returns number of blank lines to insert to make vertical move
 *          "in phase".
 *
 * Original Author: J. Bates
 * Date: 01/09/98
 *
 *************************************************************************/
FC_LONG  VerticalMoveInPhase(LPDVDATAREC lpDataRec, FC_LONG lNextRasterLine)
{
   FC_LONG  lVerticalAdjustment;
   struct pf_data FAR *pfData;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

   switch (pfData->nVertResMult)
   {
   case 2  :
      /******************************************************************
       * this is a 600dpi vertical resolution print job.  So make sure
       * lNextRasterLine is evenly divisible by 2.
       ******************************************************************/
      lVerticalAdjustment = lNextRasterLine%2;
      break;
   default :
      /******************************************************************
       * this is a 30dpi vertical resolution print job.  So return 0.
       ******************************************************************/
      lVerticalAdjustment = 0;
      break;
   }

   return (lVerticalAdjustment);
}  /* end of VerticalMoveInPhase() */

/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: SetShingle
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void SetShingle(LPDVDATAREC lpDataRec, int nRowIndex)
{
   BYTE  bShingle;
   int   n;
   BYTE  bShingleToApply;
   int   nRI;
   struct pf_data FAR *pfData;

   pfData = (struct pf_data FAR *)lpDataRec->lpLXDevice;

   nRI = nRowIndex;
/*   bShingle  = lpDataRec->bShingle; */
   bShingle  = pfData->bShingle;

   switch(bShingle)
   {
      case SHINGLE_50 :
            bShingleToApply = SHINGLE_50_1;
            break;
      case SHINGLE_25 :
            bShingleToApply = SHINGLE_25_1;
            break;
      default :
            bShingleToApply = SHINGLE_0_1;
            break;
   }

   for (n=pfData->nDelayBufStart;n<pfData->nDelayBufEnd;n++)
      pfData->alpbShingleToApply[n][nRowIndex] = bShingleToApply;

   return;

}  /* end of SetShingle() */

#ifdef DOS_BUILD
/***************************************************************************
 *  FCKELVIN.C                                    Lexmark Confidential
 *
 * Function Name: SetResolutionAndShingle
 *
 * Description:
 *
 *
 * Inputs:
 *
 * Outputs:
 *
 * Major Functions Called:
 *
 * Original Author:
 * Date:
  *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void SetResolutionAndShingle(LPDVDATAREC lpDataRec, FC_INT nDPI, FC_INT nShingle)
{
   /* set defaults */
   lpDataRec->bMediaType = PLAIN_PAPER;
   lpDataRec->bQuality   = QUALITY_NORMAL;

   if ((nDPI == 300) && (nShingle == 0))
   {
      lpDataRec->bMediaType = PLAIN_PAPER;
      lpDataRec->bQuality   = QUALITY_DRAFT;
   }
   else if ((nDPI == 300) && (nShingle == 50))
   {
      lpDataRec->bMediaType = COATED_PAPER;
      lpDataRec->bQuality   = QUALITY_NORMAL;
   }
   else if ((nDPI == 300) && (nShingle == 25))
   {
      lpDataRec->bMediaType = PLAIN_PAPER;
      lpDataRec->bQuality   = QUALITY_HIGH;
   }
   else if (nDPI == 600)
   {  /* only one 600dpi setting, uses 50% shingle */
      lpDataRec->bMediaType = COATED_PAPER;
      lpDataRec->bQuality   = QUALITY_HIGH;
   }

   return;

}  /* end of SetResolutionAndShingle() */
#endif /* DOS_BUILD */
