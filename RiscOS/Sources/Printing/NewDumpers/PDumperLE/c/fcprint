/* fcprint.c */

#include "common.h"

/***************************************************************************
 *  FC_PRINT.C                                          Lexmark Confidential
 *
 * Function Name:    ProcessRaster
 *
 * Description:
 *    This function breaks a raster line into its individual colors.  It
 *    then stores the colors in the appropriate color delay buffers.  When
 *    enough raster lines have been processed, it calls the PrintSwath()
 *    function to build a print swath(s) and send it to the printer.
 *
 * Inputs:  lpDataRec      Long pointer to HBP interface structure.
 *          nScanStart     The horizontal starting position of valid data
 *                         within the raster line.
 *          nScanEnd       The horizontal ending position of the valid data
 *                         within the raster line.
 *          The input raster line is stored in pfData->in_ptr.  Using KCM
 *          printing at 300DPI as an example, the input raster line will be
 *          1800 (6*300) bytes long.  Each 300 byte segment will be one color
 *          plane.  The "valid" data within each 300 byte segment starts at
 *          byte position nScanStart and ends at byte position nScanEnd-1.
 *          For example, if nScanStart=0 and nScanEnd=5, there are 4 "good"
 *          data bytes, bytes 0, 1, 2, 3, and 4.
 *
 * Outputs: stores each color plane from the raster line in the appropriate
 *          delay buffer.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
void ProcessRaster(LPDVDATAREC lpDataRec, int nScanStart, int nScanEnd)
{
	struct pf_data *pfData;
	int nOffset = 0, n, nScanCount;
	int nIndx, nSeg;
	char *lpchInPtr;

//	kelvin_trace3("ProcessRaster(%p, %d, %d)\n", lpDataRec, nScanStart, nScanEnd);

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;

	nScanCount = nScanEnd - nScanStart;

	for (n = pfData->nDelayBufStart; n < pfData->nDelayBufEnd; n++)
	{
		nSeg = n + ((pfData->anDBIndx[FC_IN][n] / pfData->nRastersPerSeg) * MAXNUMPLANES);
		nIndx = (pfData->anDBIndx[FC_IN][n] % pfData->nRastersPerSeg);
		lpchInPtr = (char *) (pfData->alpwPlane[nSeg] + (nIndx * pfData->nWordsPerRow));

		if (nScanCount <= 0)
		{
			MEMSET(lpchInPtr, 0x00, pfData->nBytesPerRow);
		}
		else
		{
			MEMSET(lpchInPtr, 0x00, nScanStart);
			MEMCPY(lpchInPtr + nScanStart, pfData->in_ptr + nOffset + nScanStart, nScanCount);
			MEMSET(lpchInPtr + nScanEnd, 0x00, (pfData->nBytesPerRow - nScanEnd));
		}
		
		pfData->anDBIndx[FC_IN][n] = ((pfData->anDBIndx[FC_IN][n] + 1) %
				pfData->anDBIndx[BUFSIZE][n]);
		nOffset += pfData->nBytesPerRow;
	}

	pfData->lRasterLinesProcessed++;

	if ((pfData->lRasterLinesProcessed % pfData->lRowsToProcess) == 0)
		PrintSwath(lpDataRec, pfData->lRowPos);
}

/***************************************************************************
 *  FC_PRINT.C                                          Lexmark Confidential
 *
 * Function Name:    FlushBuffers
 *
 * Description:
 *    This function processes all raster lines in the delay buffers, by
 *    calling the PrintSwath() function as many times as necessary to
 *    process and remove all raster lines currently in the delay buffers.
 *    It accomplishes this by stepping through each delay buffer and 
 *    continually calling PrintSwath() until the delay buffer is empty.  It
 *    then goes to the next delay buffer and does the same thing.
 *
 * Inputs:  lpDataRec       Long pointer to HBP interface structure.
 *
 * Outputs: empties the delay buffers.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/
int FlushBuffers(LPDVDATAREC lpDataRec)
{
	int n = 0, nOut;
	struct pf_data *pfData;
	long lRowPos, lRowsToMove = 0, lBlankRowsMoved = 0, lRowsMoved = 0;
	int nShingleSize;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;
	lRowPos = pfData->lRowPos;

	switch (lpDataRec->bColorPlanes)
	{
	case 1:
		nShingleSize = pfData->nMonoShingleSize;
		break;
	default:
		nShingleSize = pfData->nColorShingleSize;
		break;
	}

	n = pfData->nDelayBufStart;
	while (n < pfData->nDelayBufEnd)
	{
		nOut = pfData->nOut;
		if (pfData->anDBIndx[FC_IN][n] == pfData->anDBIndx[nOut][n])
		{
			n++;
		}
		else
		{
			lRowsToMove = pfData->lRowsToProcess -
					pfData->lRasterLinesProcessed;
			lRowPos += lRowsToMove;
			lBlankRowsMoved += lRowsToMove;
			pfData->lRasterLinesProcessed += lRowsToMove;
			lRowsMoved += (long) PrintSwath(lpDataRec, lRowPos);
		}
	}

#if 0
	if (bCalledLocation == FLUSH_EOP)
	{
		/* add one more PrintSwath call to flush swath buffer */
// lRowsMoved += (long)PrintSwath(lpDataRec, lRowPos);
		lBlankRowsMoved += (long) PrintSwath(lpDataRec, lRowPos);
	}
#endif

	lBlankRowsMoved += (long) PrintSwath(lpDataRec, lRowPos);

// return(lRowsMoved);
	return ((int) lBlankRowsMoved);
}

/***************************************************************************
 *  FC_PRINT.C                                          Lexmark Confidential
 *
 * Function Name:    PrintSwath
 *
 * Description:
 *    This function calls Rotate() to create a print swath, and then
 *    calls OutputSwath() to send the swath to the printer.  For a two
 *    head print page, both swaths are printed.
 *
 * Inputs:  lpDataRec      Long pointer to HBP interface structure.
 *          lRowPos        Row position of current "bottom" raster line.
 *                         Passed along to SwathMargins() where its used
 *                         to synchronize the delay buffers with the
 *                         margins buffer.
 *
 * Outputs: int   number of rows moved down the page.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 *************************************************************************/

int PrintSwath(LPDVDATAREC lpDataRec, long lRowPos)
{
	int nRetCode = 0, nShingleSize = 0, nRowsMoved = 0, nPlanes;
	struct pf_data *pfData;

	pfData = (struct pf_data *) lpDataRec->lpLXDevice;

	switch (lpDataRec->bColorPlanes)
	{
	case 1:
		nPlanes = KPLANE;
		nShingleSize = pfData->nMonoShingleSize;
		break;
	case 3:
	case 4:
	case 6:
		nPlanes = CMYPLANES;
		nShingleSize = pfData->nColorShingleSize;
		break;
	default:
		return (0);
	}

	SwathMargins(lpDataRec, nPlanes, lRowPos);
	if (pfData->fSwathPresent == TRUE)
		OutputSwath(lpDataRec);
	nRetCode = Rotate(lpDataRec, nPlanes);

	if (nRetCode > 0)
	{
		nRowsMoved = nRetCode;
		pfData->fSwathPresent = TRUE;
	}
	else
	{
		nRowsMoved = (-nRetCode);
		pfData->fSwathPresent = FALSE;
	}
	pfData->nFormsMovePending += nRowsMoved;

	switch (lpDataRec->bColorPlanes)
	{
	case 4:
	case 6:
		if (lpDataRec->bColorPlanes == 4)
			nPlanes = KPLANE;
		else
			nPlanes = KCMPLANES;
		SwathMargins(lpDataRec, nPlanes, lRowPos);
		if (pfData->fSwathPresent == TRUE)
			OutputSwath(lpDataRec);
		nRetCode = Rotate(lpDataRec, nPlanes);
		if (nRetCode > 0)
			pfData->fSwathPresent = TRUE;
		else
			pfData->fSwathPresent = FALSE;
		break;
	default:
		break;
	}

	/* now prepare for next call to PrintSwath() */

	switch (pfData->nOut)
	{
	case FC_OUT_EVEN:
		pfData->nOut = FC_OUT_ODD;
		pfData->lRowsToProcess = pfData->lRasterLinesProcessed +
				(long) (nShingleSize + 3l);
		break;
	case FC_OUT_ODD:
		pfData->nOut = FC_OUT_EVEN;
		pfData->lRowsToProcess = pfData->lRasterLinesProcessed +
				(long) (nShingleSize - 3l);
		break;
	case FC_OUT:
		pfData->lRowsToProcess = pfData->lRasterLinesProcessed +
				(long) nShingleSize;
	}

	return (nRowsMoved);
}
