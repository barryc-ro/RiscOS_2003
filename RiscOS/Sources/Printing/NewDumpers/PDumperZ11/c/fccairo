/****************************************************************************
 * FCCAIRO.C                                       Lexmark Confidential
 *
 * $Revision$
 * $Date$
 * $Author$
 *
 *
 * Description:
 *    FCCAIRO.C contains all the Cairo printer specific functions.
 *
 *
 * No.   Date     Who  Function              Description of Change
 * --------------------------------------------------------------------------
 * 009  12/14/98  bsp  SetShingle            Modified so that avoid 33% and get
 *      50% shingling in for black when 50% shingled CMYK job is attempted.
 * 010  12/22/98  cwl  Compress              Added blank slice at beginning and
 *      end of each swath to fix a hardware ASIC bug in Cairo.
 * 011  01/19/99  jbb  FCProductReturns      Created this function.
 * 012  02/18/99  wlc  Changes to use only 50 nozzles for black on envelopes
 *      in Quick and Normal print mode. Use all nozzles for High quality mode.
 * 013  02/23/99  wlc  GetPrintDir           Changes to print modes per Scott H.
 *                     GetShingleMode        Changes to print modes per Scott H.
 * 014  03/08/99  wlc  CheckForCDE()         Use CDE to prevent smearing when
 *      printing envelopes with black head at normal or high resolutions.  The
 *      driver was changed to pass 1200 dpi as 600 dpi so CDE is only done for
 *      600 dpi resolution.  No CDE is required for draft mode.
 *      Also did some minor code clean up.
 * 015  03/16/99  wlc  GetShingleMode()     Change coated paper from 2 pass to 3
 *                     GetShingleMode()     Change iron on transfer to 2 pass.
 * 016  03/16/99 xzhan Change the ClearPrintSwath to fix draft printing problem
 *      (bug 4760)
 * 017  03/16/99  wlc  GetShingleMode()     Change coated paper from 3 pass to 2
 * 018  03/25/99  wlc  GetLeftMargin()      Change left margin for all envelopes
 *      and Hagaki paper to .125 inch (38/300 pels).  Fix for Cai bug 4846.
 * 019  03/27/99  wlc  CheckSwathDensity()  Don't check CMY shingled swaths.
 ***************************************************************************/




/************** Definitions & Macros ***************************************/

#if !defined(NOPRAGMA)
//#pragma warning (disable: 4103)  /* used #pragma pack to change alignment  */
#endif




/************** Include Files **********************************************/

#if defined(DOS_BUILD) || defined(FC_DOS_32)
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#endif

#if !defined(FC_WIN_32) && !defined(FC_OS2)
//#include <memory.h>
#endif

#ifdef PACE
#include <stdlib.h>
#include <string.h>
#include "swis.h"
#include "kernel.h"
#include "module.h"
#endif

#if defined(GEN_TEST_INPUT_FILES)
#include <string.h>
#endif

#include "fclocal.h"




/************** Prototype Definitions **************************************/

void      FCSetHeadTypes(LPDVDATAREC lpxDataRec);
SwordType CheckSwathDensity(LPDVDATAREC lpxDataRec);
void      CreateTwoSwaths(LPDVDATAREC lpxDataRec);
DwordType Compress(LPDVDATAREC lpxDataRec, LPPRTCMD lpxPrtCmd);
void CopyDocInfoToLSXface(LPDVDATAREC lpxDataRec);
void CopySwathInfoToLSXface(LPDVDATAREC lpxDataRec, ByteType bSwathDensity);
DwordType   ExpandSwathTo8Inches(LPDVDATAREC lpxDataRec);

/************** Variable Declarations **************************************/

/* set object module level ID */
static char fc_version[] = "product.obj: "FC_VERSION;


#if defined(GEN_COL_BIDI)
ByteType bNumBidiSwaths;
#endif


EXTSENDCMD lpfnSendCommand;      /* added to make HBP a DLL */

#ifdef PACE
/* Pace specific OutToFile */

void OutToFile(LPDVDATAREC lpDataRec, void *pOutString, unsigned long dwLength)
{
	_kernel_swi_regs r;

#ifdef FAKEDFSERROR
	/* User holds down either ALT key to simulate a DeviceFS error */
	r.r[0] = 129;
	r.r[1] = -3;
	r.r[2] = -3 >> 8;
	(void) _kernel_swi(OS_Byte, &r, &r);
	if (r.r[1])
	{
		static _kernel_oserror fake = { 0, "Simulated DeviceFS error" };
		THROW(&fake);
	}
#endif

#ifdef NULLOUT
	cairo_trace1("Discarding %d bytes\n", dwLength);
#else

#  ifdef CHECKBUSY
	/* AA 11/2/98: Added this test which should throw an error if the
	 * printer isn't ready. Should we retry though?
	 */
	r.r[0] = 0;
	THROW(_kernel_swi(Parallel_Op, &r, &r));
	if ((r.r[2] & 0x80) == 0)
	{
		THROW(&cairo_notready);
	}
#  endif

//	cairo_trace3("Sending %d bytes to file handle %d (%p)\n", dwLength, lpDataRec->flOutFile, lpDataRec);

	r.r[0] = 2;
	r.r[1] = (int) lpDataRec->flOutFile;

#  ifdef TEXTPRINT
	if (wedge_getcooked())
	{
		unsigned char esc[] = { 27, '%', 0, 0, 0 };
		esc[2] = (dwLength >>  0) & 0xFF;
		esc[3] = (dwLength >>  8) & 0xFF;
		esc[4] = (dwLength >> 16) & 0xFF;
		r.r[2] = (int) esc;
		r.r[3] = 5;
		THROW(_kernel_swi(OS_GBPB, &r, &r));
	}
#  endif

	r.r[2] = (int) pOutString;
	r.r[3] = (int) dwLength;

	THROW(_kernel_swi(OS_GBPB, &r, &r));
#endif // NULLOUT
}
#endif

/****************************************************************************
 * Function Name:    HwStartPrintJob
 *
 * Description:
 *    This function is called at the beginning of a document and
 *    can send the printer any required information for the
 *    job start.  Some printers may not require any special
 *    data to be sent.  The printer specific hardware structure
 *    is also initialized here.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 ***************************************************************************/
void HwStartPrintJob(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   LPHWDATA    lpxHWData;
   LPByteType  lpbCmd;
   SwordType   swRetCode;
   ByteType    bN;
#if 0
   /* This command will be generated by the HPC code for Cairo */
   ByteType    abStartPrintJob[8] =
                           {0x1b, 0x2a, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00};
#endif

#if defined(FC_WIN_32)

   ByteType    abNull[64], bCounter;

   for(bCounter=0; bCounter<64; bCounter++)
      abNull[bCounter] = 0x00;

#endif


#if defined(TEST)
   FILE       *flOutFile;
#endif

   /* The StartPrintJob command is actually a command that Cairo does not */
   /* recognize, so Cairo throws it away.  We have added it so Cairo's    */
   /* pcl emulator will have a recognizable command to key on, so it will */
   /* know when it is parsing a preformatted print job.                   */
#if 0
   /* This command will be generated by the HPC code for Cairo */
   lpbCmd    = abStartPrintJob;
   OUTPUT(lpxDataRec, lpbCmd, 8);
#endif


   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   if (lpxPFData == NULL)
   {
      return;
   }

   lpxHWData = lpxPFData->lpxHWData;

   lpxHWData->lpxLSXface = (LPLSINTFACE) ALLOCATE_MEMORY(LSINTFACE_SIZE);

   if   (lpxHWData->lpxLSXface == NULL)
   {
      return;
   }

   for (bN=0; bN<6; bN++)
   {
      lpxHWData->adwDotCount[bN] = 0;
   }

   CopyDocInfoToLSXface(lpxDataRec);
   swRetCode = LSStartPrintJob(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode < 0)
   {
      return;
   }
   else if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of HwStartPrintJob() */




/****************************************************************************
 * Function Name:    HwStartPage
 *
 * Description:
 *    This function is called at the beginning of a page and
 *    can send the printer any required information for the
 *    page start.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 ***************************************************************************/
void HwStartPage(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   LPByteType     lpbCmd;
   WordType       wLength;
   SwordType      swRetCode;
   BoolType       fEnableJamDetect = TRUE;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

#if OPTION_600_AS_2X300
   /* New 600 dpi scheme is applied when 600 dpi 50% shingling is desired  */
   if( (lpxPFData->bShingle == SHINGLE_50) && (lpxPFData->bResolution == LORES) )
   {
      lpxPFData->bShingleLoRes = SHINGLE_50;
      lpxPFData->wCMYSwathByPgCtr = 0;
      lpxPFData->wKOrKcmSwathByPgCtr = 0;
   }
   else
   {
      lpxPFData->bShingleLoRes = NO_SHINGLE;
   }
#endif

   switch (lpxDataRec->bMediaSize)
   {
   case PAPER_LETTER:
      wLength = 3300;
      break;
   case PAPER_LEGAL:
      wLength = 4200;
      break;
   case PAPER_B5:
      wLength = 3035;
      break;
   case PAPER_EXECUTIVE:
      wLength = 3150;
      break;
   case PAPER_A5:
      wLength = 2480;
      break;
   case CARD_A6:
      wLength = 1748;
      break;
   case PAPER_USER:
      /* Custom paper can be up to 17" long */
      wLength = 5100;
      break;
   case PAPER_A4:
      wLength = 3510;
      break;
   case PAPER_OHFHAGAKI:
      wLength = 1748;
      break;
   case PAPER_HAGAKI:
      wLength = 1748;
      break;
   case ENVELOPE_9:
      wLength = 2662;
      break;
   case ENVELOPE_10:
      wLength = 2850;
      break;
   case ENVELOPE_DL:
      wLength = 2598;
      break;
   case ENVELOPE_C5:
      wLength = 2703;
      break;
   case ENVELOPE_C6:
      wLength = 1914;
      break;
   case ENVELOPE_D5:
      wLength = 2952;
      break;
   case ENVELOPE_75:
      wLength = 2250;
      break;
   case CARD_3X5:
      wLength = 1500;
      break;
   case CARD_4X6:
      wLength = 1800;
      break;
   case ENVELOPE_BARONIAL:
      wLength = 1314;
      break;
   case ENVELOPE_6_3_4:
      wLength = 1950;
      break;
   case JPNLONG3:
      wLength = 2776;
      break;
   case JPNSQUARE4:
      wLength = 3154;
      break;
   case JPNSQUARE5:
      wLength = 2835;
      break;
   case JPNSQUARE6:
      wLength = 2705;
      break;
   case PAPER_BANNER_A4:
   case PAPER_BANNER_LETTER:
   case PAPER_CUSTOM_BANNER:
      wLength = 3510;
      fEnableJamDetect = FALSE;
      break;
   default :
      /* Custom paper can be up to 17" long */
      wLength = 5100;
         break;
   }  /* end of switch (lpxDataRec->bMediaSize) */


   /* LSEjectCmd expects page length in 1200dpi */
   wLength *= 4;

   CopyDocInfoToLSXface(lpxDataRec);
   lpxPFData->lpxHWData->lpxLSXface->wPageLength = wLength;
   lpxPFData->lpxHWData->lpxLSXface->fEnableJamDetect = fEnableJamDetect;
   swRetCode = LSStartPage(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of HwStartPage() */




/****************************************************************************
 * Function Name:    HwEndPage
 *
 * Description:
 *    This function is called at the end of a page and
 *    can send the printer any required information for the
 *    page end.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 ***************************************************************************/
void HwEndPage(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   LPByteType  lpbCmd;
   SwordType   swRetCode;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   CopyDocInfoToLSXface(lpxDataRec);
   swRetCode = LSEndPage(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of HwEndPage() */




/****************************************************************************
 * Function Name:    HwEndJob
 *
 * Description:
 *    This function is called at the end of a job and
 *    can send the printer any required information for the
 *    job end.  Some printers may not require any special
 *    data to be sent.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 ***************************************************************************/
void HwEndJob(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   LPByteType  lpbCmd;
   SwordType   swRetCode;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   CopyDocInfoToLSXface(lpxDataRec);
   swRetCode = LSEndPrintJob(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   if (lpbCmd != NULL)
   {  /* The hpc code allocated the command buffer, but we are required to    */
      /* deallocate it.                                                       */
      // AA: This reports "Attempt to free block that has not been allocated", so
      // we'll just forget about it now and let our gross clean up code clobber it
      // when the job is dead. This won't be a problem because this only happens
      // once per job anyway.
      //FREE_MEMORY(lpbCmd);
   }

   return;

}  /* end of HwEndJob() */




/****************************************************************************
 * Function Name:    OutputSwath
 *
 * Description:
 *    This function is responsible for everything that needs to
 *    happen when one swath buffer is sent to the printer for
 *    printing.  Linefeed is called to move the paper to the
 *    correct position for the swath followed by the swath
 *    data.
 *
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 ***************************************************************************/
void OutputSwath(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   LPLSINTFACE    lpxLSXface;
   LPByteType     lpbCmd,
                  lpbPrtCmd;
   HPByteType     hpbPrtData;
   WordType       i,
                  wIStart,
                  wIEnd,
                  wDenseSwath;
   SwordType      swFutureFormsMovePending,
                  swPreRotateStart,
                  swPreRotateEnd,
                  swRetCode;
   DwordType      j,
                  dwCount,
                  dwCompressLength,
                  dwSize;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;
   lpxLSXface = lpxPFData->lpxHWData->lpxLSXface;

   /* if swath is more than one segment, then combine segments */
   if (lpxPFData->wSlicesPerRow > (WordType)SLICES_PER_SEG)
   {
      hpbPrtData = (HPByteType)lpxPFData->lpxPrtCmd;
      if (lpxPFData->alpbSwath[0] == (LPByteType)hpbPrtData)
      {
         hpbPrtData += ((DwordType)SLICES_PER_SEG *
                       (DwordType)lpxPFData->bBytesPerSlice);
         if (lpxPFData->wSliceCount <= (WordType)SLICES_PER_SEG)
         {
            wIStart = (WordType)99;
         }
         else
         {
            wIStart = (WordType)1;
         }
      }
      else
      {
         wIStart = (WordType)0;
      }

      wIEnd = ((lpxPFData->wSliceCount-(WordType)1)/
               (WordType)SLICES_PER_SEG);

      /* now combine all print swath segments into one print swath */
      for (i=wIStart; i<=wIEnd;i++)
      {
         if (i == wIEnd)
         {
            dwCount = ((((DwordType)(lpxPFData->wSliceCount-1)%SLICES_PER_SEG)+
                      1)*(DwordType)lpxPFData->bBytesPerSlice);
         }
         else
         {
            dwCount = ((DwordType)SLICES_PER_SEG * lpxPFData->bBytesPerSlice);
         }

         for (j=0;j<dwCount;j++)
         {
            *hpbPrtData = *(lpxPFData->alpbSwath[i]+j);
            hpbPrtData++;
         }
      }
   }  /* end of combining swath segments into one huge swath */


   if ( (lpxPFData->bResolution == SUPERLOWRES) ||
        (lpxPFData->bResolution == LORES ) )
   {
      lpxPFData->swFormsMovePending       *= 2;
      lpxPFData->swFutureFormsMovePending *= 2;
   }

   /* For Cairo, we slow down envelope printing to allow time for the       */
   /* black ink to dry before it rubs against the trailing edge of the      */
   /* cartridges.  We are doing this by printing a full 8" swath            */
   /* We will not get HIRES for mono envelope printing from driver.         */
   if ( ( lpxPFData->bEnvelopeSize == 1 ) &&
        ( lpxPFData->bPrintHead == MONO_CARTRIDGE ) &&
        ( (lpxPFData->bResolution == SUPERLOWRES) ||
          (lpxPFData->bResolution == LORES ) ) )
   {
      dwSize = ExpandSwathTo8Inches(lpxDataRec);
   }

   /* Now determine the swath density */
   wDenseSwath = CheckSwathDensity(lpxDataRec);

   /* adjust wSliceCount, swLeftPrintPos, swRightPrintPos */
   /* for added blank slice before calling Compress() and CopySwathInfoToLSXface() */
   lpxPFData->wSliceCount += 2;

   lpxPFData->swLeftPrintPos -= 1;
   lpxPFData->swRightPrintPos += 1;

   /* For new 1200 dpi and new 600 dpi require one additional print position   */
   /* movement to accommodate each null slices added to both ends of a print swath */

#if OPTION_600_AS_2X300
   if (lpxPFData->bShingleLoRes == SHINGLE_50)
   {
     lpxPFData->swLeftPrintPos -= 1;
     lpxPFData->swRightPrintPos += 1;
   }
#endif

   if (lpxPFData->bShingleHiRes == SHINGLE_50)
   {
      lpxPFData->swLeftPrintPos -= 1;
      lpxPFData->swRightPrintPos += 1;
   }

   /* adjust the next swath position for the added blank slice */
   lpxPFData->swNextLeftPos = RastertoPrintPos(
                              lpxPFData->swPreRotateStart,lpxPFData->wLeftMargin) - 1;
   lpxPFData->swNextRightPos = RastertoPrintPos(
                              lpxPFData->swPreRotateEnd,lpxPFData->wLeftMargin) + 1;

   if (wDenseSwath == 1)
   {
      /* The swath is too dense (too many dots in an area).  It will       */
      /* overload Cairo's power supply.  So break the swath into two      */
      /* swaths, each one with alternating slices from the original swath. */
      CreateTwoSwaths(lpxDataRec);

      swPreRotateStart         = lpxPFData->swPreRotateStart;
      swPreRotateEnd           = lpxPFData->swPreRotateEnd;
      lpbPrtCmd                = lpxPFData->lpxPrtCmd;
      swFutureFormsMovePending = lpxPFData->swFutureFormsMovePending;

      lpxPFData->swPreRotateStart = (lpxPFData->swLeftPrintPos -
                                    lpxPFData->wLeftMargin + 7) / 8;
      lpxPFData->swPreRotateEnd   = lpxPFData->swPreRotateStart +
                                    ( (lpxPFData->wSliceCount + 7) / 8 );
      lpxPFData->lpxPrtCmd        = lpxPFData->lpxDensePrtCmd;
      lpxPFData->swFutureFormsMovePending = 0;

      dwCompressLength = Compress(lpxDataRec, (LPPRTCMD)lpxPFData->lpxPrtCmd);
      if (dwCompressLength)
      {
         dwSize                    = dwCompressLength;
         hpbPrtData                = (LPByteType) lpxPFData->lpxCompPrtCmd;
         lpxLSXface->xSwath.dwSwathLength = dwSize;
         lpxLSXface->xSwath.hpbSwathData  = hpbPrtData;
         lpxLSXface->xSwath.fCompress     = TRUE;
      }
      else
      {
         dwSize                    = ((DwordType)lpxPFData->wSliceCount *
                                     lpxPFData->bBytesPerSlice);
         hpbPrtData                = (LPByteType) lpxPFData->lpxPrtCmd;
         lpxLSXface->xSwath.dwSwathLength = dwSize;
         lpxLSXface->xSwath.hpbSwathData  = hpbPrtData;
         lpxLSXface->xSwath.fCompress     = FALSE;
      }

      CopySwathInfoToLSXface(lpxDataRec, HALF_SWATH);
      swRetCode = LSSwathCmd(lpxLSXface, &lpbCmd);
      lpxPFData->swFormsMovePending = 0;
      lpxPFData->swFutureFormsMovePending = 0;
      if (swRetCode > 0)
      {
         OUTPUT(lpxDataRec, lpbCmd, swRetCode);
      }


      OUTPUT(lpxDataRec,(HPByteType)hpbPrtData, dwSize);


      lpxPFData->swPreRotateStart         = swPreRotateStart;
      lpxPFData->swPreRotateEnd           = swPreRotateEnd;
      lpxPFData->lpxPrtCmd                = lpbPrtCmd;
      lpxPFData->swFutureFormsMovePending = swFutureFormsMovePending;

   }  /* end of if (wDenseSwath == 1) */

   dwCompressLength = Compress(lpxDataRec, (LPPRTCMD)lpxPFData->lpxPrtCmd);
   if (dwCompressLength)
   {
      dwSize                    = dwCompressLength;
      hpbPrtData                = (LPByteType) lpxPFData->lpxCompPrtCmd;
      lpxLSXface->xSwath.dwSwathLength = dwSize;
      lpxLSXface->xSwath.hpbSwathData  = hpbPrtData;
      lpxLSXface->xSwath.fCompress     = TRUE;
   }
   else
   {
      dwSize                    = ((DwordType)lpxPFData->wSliceCount *
                                  lpxPFData->bBytesPerSlice);
      hpbPrtData                = (LPByteType) lpxPFData->lpxPrtCmd;
      lpxLSXface->xSwath.dwSwathLength = dwSize;
      lpxLSXface->xSwath.hpbSwathData  = hpbPrtData;
      lpxLSXface->xSwath.fCompress     = FALSE;
   }

   CopySwathInfoToLSXface(lpxDataRec, FULL_SWATH);
   swRetCode = LSSwathCmd(lpxLSXface, &lpbCmd);
   lpxPFData->swFormsMovePending = 0;
   lpxPFData->swFutureFormsMovePending = 0;
   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }


   OUTPUT(lpxDataRec,(HPByteType)hpbPrtData, dwSize);


   return;

}  /* end of function OutputSwath() */




/****************************************************************************
 * Function Name:    FCEjectPage
 *
 * Description:
 *    This function sends a page eject command to the printer.
 *    Note that no action is taken by the printer unless paper has
 *    been loaded.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 ***************************************************************************/
void FAR FCEjectPage(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   LPByteType  lpbCmd;
   WordType    wLength;
   SwordType   swRetCode;
   BoolType    fEnableJamDetect = TRUE;

   if (lpxDataRec == NULL)
   {
      return;
   }

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   switch (lpxDataRec->bMediaSize)
   {
   case PAPER_LETTER:
      wLength = 3300;
      break;
   case PAPER_LEGAL:
      wLength = 4200;
      break;
   case PAPER_B5:
      wLength = 3035;
      break;
   case PAPER_EXECUTIVE:
      wLength = 3150;
      break;
   case PAPER_A5:
      wLength = 2480;
      break;
   case CARD_A6:
      wLength = 1748;
      break;
   case PAPER_USER:
      /* Custom paper can be up to 17" long */
      wLength = 5100;
      break;
   case PAPER_A4:
      wLength = 3510;
      break;
   case PAPER_OHFHAGAKI:
      wLength = 1748;
      break;
   case PAPER_HAGAKI:
      wLength = 1748;
      break;
   case ENVELOPE_9:
      wLength = 2662;
      break;
   case ENVELOPE_10:
      wLength = 2850;
      break;
   case ENVELOPE_DL:
      wLength = 2598;
      break;
   case ENVELOPE_C5:
      wLength = 2703;
      break;
   case ENVELOPE_C6:
      wLength = 1914;
      break;
   case ENVELOPE_D5:
      wLength = 2952;
      break;
   case ENVELOPE_75:
      wLength = 2250;
      break;
   case CARD_3X5:
      wLength = 1500;
      break;
   case CARD_4X6:
      wLength = 1800;
      break;
   case ENVELOPE_BARONIAL:
      wLength = 1314;
      break;
   case ENVELOPE_6_3_4:
      wLength = 1950;
      break;
   case JPNLONG3:
      wLength = 2776;
      break;
   case JPNSQUARE4:
      wLength = 3154;
      break;
   case JPNSQUARE5:
      wLength = 2835;
      break;
   case JPNSQUARE6:
      wLength = 2705;
      break;
   case PAPER_BANNER_A4:
   case PAPER_BANNER_LETTER:
   case PAPER_CUSTOM_BANNER:
      wLength = 3510;
      fEnableJamDetect = FALSE;
      break;
   default :
      /* Custom paper can be up to 17" long */
      wLength = 5100;
         break;
   }  /* end of switch (lpxDataRec->bMediaSize) */


   /* LSEjectCmd expects page length in 1200dpi */
   wLength *= 4;

   CopyDocInfoToLSXface(lpxDataRec);
   lpxPFData->lpxHWData->lpxLSXface->wPageLength = wLength;
   lpxPFData->lpxHWData->lpxLSXface->fEnableJamDetect = fEnableJamDetect;
   swRetCode = LSEjectPage(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of FCEjectPage() */




/****************************************************************************
 * Function Name:    FCProductReturns
 *
 * Description:
 * FCProductReturns() is called once for the life of a printer.  It should
 * be called after the first 100 pages have been printed.  It places an
 * ink mark on the printer's body at the extreme right edge, the edge
 * farthest from the maintenance station.  This is to help our Products
 * Returns group decide if the printer is new or not.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: J. Bates
 * Date: 01/19/99
 *
 ***************************************************************************/
void FAR FCProductReturns(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   LPByteType     lpbCmd;
   SwordType      swRetCode;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   swRetCode = LSProductReturns(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of function FCProductReturns() */




/****************************************************************************
 * Function Name:    FcPaperSource
 *
 * Description:
 *    This function outputs the paper source data (manual or
 *    automatic sheet feed) to the printer in the expected format.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 ***************************************************************************/
void FCSetPaperSource(LPDVDATAREC lpxDataRec)
{
   lpxDataRec = lpxDataRec;
   return;
}





/****************************************************************************
 * Function Name:    FCSetHeadTypes
 *
 * Description:
 *    This function outputs the disable head detect & head id commands.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: Bob Locasto
 * Date: 09/02/97
 *
 ***************************************************************************/
void FCSetHeadTypes(LPDVDATAREC lpxDataRec)
{
   lpxDataRec = lpxDataRec;
   return;
} /* end of FCSetHeadTypes() */




/****************************************************************************
 * Function Name:    GetPrintDir
 *
 * Description:
 *    This function determines the print direction for each swath.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *          swBuffers   Which head is used in this swath.
 *
 * Outputs: print direction
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 ***************************************************************************/
ByteType GetPrintDir(LPDVDATAREC lpxDataRec, SwordType swBuffers)
{
   LPPFDATA    lpxPFData;
   ByteType    bPrintDir;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   switch (swBuffers)
   {
   case CMYPLANES :       /* set print direction for CMY swath */

      switch (lpxDataRec->bColorPlanes)
      {
      case 3:
      case 4:
         switch (lpxDataRec->bQuality)
         {
         case QUALITY_DRAFT:
            bPrintDir = BIDI;
            break;
         case QUALITY_NORMAL:
         case QUALITY_HIGH:
            bPrintDir = RTOL;
            break;
         }  /* end of Quality switch */
         break;

      case 6:
         bPrintDir = RTOL;
         break;

      }        /* end of color planes switch */
      break;   /* out of CMYPLANES */

   case KPLANE :          /* set print direction for Black swath */

      switch (lpxDataRec->bColorPlanes)
      {
      case 1:
      case 4:
         switch (lpxDataRec->bQuality)
         {
         case QUALITY_DRAFT:
            if ( lpxPFData->bEnvelopeSize )
            {  /* Printing envelope */
               bPrintDir = LTOR;
            }
            else
            {  /* Not printing envelope */
               bPrintDir = BIDI;
            }
            break;
         case QUALITY_NORMAL:
         case QUALITY_HIGH:
            bPrintDir = LTOR;
            break;
         }  /* end of Quality switch */
         break;

      } /* end of switch for ColorPlanes */
      break;

   case KCMPLANES :       /* set print direction for KCM swath */
      bPrintDir = LTOR;
      break;

   default:
      bPrintDir = LTOR;  /* This should never happen */
      break;
   } /* end of swBuffers (CMY K and KCM swath) switch */

   return(bPrintDir);
}




/****************************************************************************
 * Function Name:    GetLeftMargin
 *
 * Description:
 *    This function determines the left margin based on the following :
 *    Paper Size - (i.e. left margin is 75/300 for Letter, 40/300" for A4
 *    paper.  Note that for custom paper sizes, we expect the driver to
 *    provide the left margin value via interface value
 *    lpxDataRec->wLeftMargin, which should already be in the current
 *    page's resolution.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: return left margin for the print page in the page's resolution.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 ***************************************************************************/
WordType GetLeftMargin(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   WordType    wLeftMargin;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   lpxPFData->bEnvelopeSize = 0;  /* set flag for non-envelope */

   /* Determine minimum left margin from the Media Size and Source */
   switch (lpxDataRec->bMediaSize)
   {
   case ENVELOPE_MONARCH:
   case ENVELOPE_9:
   case ENVELOPE_10:
   case ENVELOPE_DL:
   case ENVELOPE_C5:
   case ENVELOPE_B5:
   case ENVELOPE_C6:
   case ENVELOPE_D5:
   case ENVELOPE_75:
   case ENVELOPE_6_3_4:
   case ENVELOPE_BARONIAL:
      lpxPFData->bEnvelopeSize = 1;
      wLeftMargin = (WordType) (38 * lpxPFData->swSwathResMult);
      break;
   case PAPER_LETTER:
   case PAPER_LEGAL:
   case PAPER_EXECUTIVE:
   case PAPER_USER:
   case PAPER_BANNER_LETTER:
   case CARD_3X5:
   case CARD_4X6:
   case CARD_A6:
   default :
      wLeftMargin = (WordType) (75 * lpxPFData->swSwathResMult);
      break;
   case JPNLONG3:
   case JPNSQUARE4:
   case JPNSQUARE5:
   case JPNSQUARE6:
      lpxPFData->bEnvelopeSize = 1;  /* intentionally falling thru */
   case PAPER_A5:
   case PAPER_B5:
   case PAPER_A4:
   case PAPER_BANNER_A4:
      wLeftMargin = (WordType) (40 * lpxPFData->swSwathResMult);
      break;
   case PAPER_OHFHAGAKI:
   case PAPER_HAGAKI:
      wLeftMargin = (WordType) (38 * lpxPFData->swSwathResMult);
      break;
   case ENVELOPE_CUSTOM:
      lpxPFData->bEnvelopeSize = 1;  /* intentionally falling thru */
   case PAPER_CUSTOM:
   case PAPER_CUSTOM_BANNER:
      wLeftMargin = lpxDataRec->wLeftMargin;
      break;
   }  /* end of switch (lpxDataRec->bMediaSize) */

   /* now add the Cairo machine "fudge" factor for left margin. */
   wLeftMargin += (12 * lpxPFData->swSwathResMult);

   return(wLeftMargin);

}  /* end of GetLeftMargin() */




/****************************************************************************
 * Function Name:    GetShingleMode
 *
 * Description:
 *    Some printers use this function to set the shingle amount for the
 *    page.  Marconi does not use this function.  It requires the correct
 *    shingle amount be chosen be the driver and communicated by variable
 *    lpxDataRec->bShingle;
 *
 * Inputs:  lpxDataRec  pointer to hbpcode interface structure.
 *
 * Outputs: none for Marconi
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 ***************************************************************************/
ByteType GetShingleMode(LPDVDATAREC lpxDataRec)
{
   ByteType    bShingle = NO_SHINGLE;
   LPPFDATA lpxPFData;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   /* determine shingle value from media type and print quality */
   switch (lpxDataRec->bMediaType)
   {
   case PLAIN_PAPER :
   case GREETING_CARD_STOCK :
      switch (lpxDataRec->bQuality)
      {
      case  QUALITY_DRAFT :
         bShingle = NO_SHINGLE;
         break;
      case  QUALITY_NORMAL :
         switch (lpxPFData->bColorPlanes)
         {
         case 3:
         case 4:
         case 6:
            if ( lpxDataRec->bDocumentType != INTENT_PHOTO )
            {  /* business graphic mode */
               bShingle = NO_SHINGLE;
            }
            else
            {   /* use 2-pass for CMY or KCM head for normal photo mode */
               bShingle = SHINGLE_50;
            }
            break;

         case 1:   /* black only */
            if (lpxDataRec->bDocumentType == INTENT_PHOTO)
            {
               bShingle = SHINGLE_33;
            }
            else
            {
               bShingle = NO_SHINGLE;
            }
            break;
         }  /* end of switch for bColorPlanes */
         break;     /* get out of normal */

      case  QUALITY_HIGH :
         bShingle = SHINGLE_50;
         break;
      }  /* end of switch (lpxDataRec->bQuality) */
      break;

   case GLOSSY_PAPER :
      switch (lpxDataRec->bQuality)
      {
      case  QUALITY_DRAFT :
         bShingle = NO_SHINGLE;
         break;
      case  QUALITY_NORMAL :
         bShingle = SHINGLE_33;
         break;
      case  QUALITY_HIGH :
         bShingle = SHINGLE_50;
         break;
      }  /* end of switch (lpxDataRec->bQuality) */
      break;

   case COATED_PAPER :
   case TRANSPARENCY :
      switch (lpxDataRec->bQuality)
      {
      case  QUALITY_DRAFT :
         bShingle = NO_SHINGLE;
         break;
      case  QUALITY_NORMAL :
         if (lpxDataRec->bColorPlanes == 6)
         {
            bShingle = SHINGLE_33;
         }
         else
         {
            bShingle = SHINGLE_50;
         }
         break;
      case  QUALITY_HIGH :
         bShingle = SHINGLE_50;
         break;
      }  /* end of switch (lpxDataRec->bQuality) */
      break;

   case IRON_ON_TRANSFER :
      switch (lpxDataRec->bQuality)
      {
      case  QUALITY_DRAFT :
         bShingle = NO_SHINGLE;
         break;
      case  QUALITY_NORMAL :
         switch (lpxPFData->bColorPlanes)
         {
         case 3:
         case 4:
         case 6:
            bShingle = SHINGLE_50;
            break;

         case 1:   /* black only */
            bShingle = SHINGLE_33;
            break;
         }  /* end of switch for bColorPlanes */
         break;     /* get out of normal */

      case  QUALITY_HIGH :
         bShingle = SHINGLE_50;
         break;
      }  /* end of switch (lpxDataRec->bQuality) */
      break;

   }  /* end of switch (lpxDataRec->bMediaType) */

#if defined(DOS_BUILD)
   bShingle = lpxDataRec->bShingle;
#endif

   return(bShingle);

}




/****************************************************************************
 * Function Name:    GetResolution
 *
 * Description:
 *    We determine our printer resolution based on driver communicated
 *    variable lpxDataRec->bQuality.
 *
 * Inputs:  lpxDataRec  pointer to hbpcode interface structure.
 *
 * Outputs: returns the current specified resolution.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 ***************************************************************************/
ByteType GetResolution(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   ByteType    bResolution;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   switch(lpxDataRec->bQuality)
   {
   case QUALITY_DRAFT:
      bResolution = SUPERLOWRES;
      break;
   case QUALITY_NORMAL:
   default :
      bResolution = LORES;
      break;
   case QUALITY_HIGH:
      bResolution = HIRES_INTERLACED;
      break;
   }

   return(bResolution);
}




/****************************************************************************
 * Function Name:    GetTopMargin
 *
 * Description:
 *    This function determines the top margin.  It seems like
 *    the interface has changed to SW2000 driver code for some
 *    printers so this is now printer specific.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 ***************************************************************************/
WordType GetTopMargin(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   WordType       wTopMargin;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   /* the 6 in the equation below is Cairo's hardware "fudge" factor     */
   wTopMargin = lpxDataRec->wTopMargin + 6;

   if (lpxDataRec->bColorPlanes != 1)
   {  /* COLOR.  The color nozzles begin 20/600 down farther than the      */
      /* black nozzles do.  So subtract 20/600 from the top margin to      */
      /* account for this.                                                 */
      if (wTopMargin > 20)
      {
         wTopMargin -= 20;
      }
      else
      {
         wTopMargin = 0;
      }
   }

   wTopMargin *= lpxPFData->swVertResMult;

   return(wTopMargin);

}




/****************************************************************************
 * Function Name:    ClearPrintSwath
 *
 * Description:
 *    This function zeroes out the print swath buffer.
 *
 * Inputs:  xPFData     Pointer to the hbpcode internal data structure
 *
 * Outputs: Adds correct vertical move amount for top margin.
 *
 * Original Author: J. Bates/K. Profitt
 * Date: 09/27/96
 *
 ***************************************************************************/
void ClearPrintSwath(LPPFDATA lpxPFData)
{
   WordType    i;
   size_t      stMemSetSize;

   if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
   {
      stMemSetSize = (size_t)SLICES_PER_SEG * (size_t)lpxPFData->bBytesPerSlice;
      for (i=0; i<=((lpxPFData->wSlicesPerRow-1)/SLICES_PER_SEG);i++)
      {
         _fmemset( lpxPFData->alpbSwath[i],0x00,stMemSetSize);
      }
   }
   else
   {
      stMemSetSize = (size_t)lpxPFData->dwSwathPrintSize;
      _fmemset(lpxPFData->alpbSwath[0],0x00,stMemSetSize);
   }
   return;

}  /* end of function ClearPrintSwath() */




/****************************************************************************
 * Function Name:    FCSendCartridgeHome
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to send the carrier to be capped at the
 *    maintenance station.  The carrier position
 *    kept by the driver is then updated to the
 *    maintenance cap position.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Printer Command to printer port/file.
 *
 * Original Author: K. Profitt
 * Date: 10/21/96
 *
 ***************************************************************************/
void FAR FCSendCartridgeHome(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   LPByteType     lpbCmd;
   SwordType      swRetCode;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   CopyDocInfoToLSXface(lpxDataRec);
   swRetCode = LSSendCartridgeHome(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of FCSendCartridgeHome() */




/****************************************************************************
 * Function Name:    FCInstallCartridge
 *
 * Description:
 *    This function is called to send a command to the
 *    printer to send the carrier to the install position.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: none
 *
 * Original Author: K. Profitt
 * Date: 12/12/96
 *
 ***************************************************************************/
void FAR FCInstallCartridge(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   LPByteType     lpbCmd;
   SwordType      swRetCode;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   CopyDocInfoToLSXface(lpxDataRec);
   swRetCode = LSInstallCartridge(lpxPFData->lpxHWData->lpxLSXface, &lpbCmd);

   if (swRetCode > 0)
   {
      OUTPUT(lpxDataRec, lpbCmd, swRetCode);
   }

   return;

}  /* end of function FCInstallCartridge() */



/****************************************************************************
 * Function Name:    CheckForCDE
 *
 * Description:
 *    For Cairo, we perform consecutive dot elimination (CDE) if we are in
 *    normal mode and printing an envelope using the black head.
 *    This function will return TRUE (perform CDE) when in normal mode
 *    and printing an envelope.  This is to put down less ink and thus
 *    prevent smearing when using the black head on some envelopes.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: return TRUE (perform CDE) for normal black envelope printing.
 *          return FALSE (do not perform CDE) for all other modes.
 *
 * Original Author: L. Cheatham
 * Date: 03/04/99
 *
 ***************************************************************************/
BoolType CheckForCDE(LPDVDATAREC lpxDataRec, ByteType bQuality)
{
   BoolType    fRetCode;
   LPPFDATA    lpxPFData;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   if (lpxPFData->bEnvelopeSize && (bQuality == QUALITY_NORMAL) &&
       lpxPFData->bColorPlanes == 1 )
   {
      /* Enable CDE for normal black only envelope printing to prevent */
      /* smearing while printing.                                      */
      fRetCode = TRUE;
   }
   else
   {
      fRetCode = FALSE;
   }

   return(fRetCode);
}  /* end of function CheckForCDE() */




/****************************************************************************
 * Function Name:    CheckForReverseSwath
 *
 * Description:
 *    Cairo builds a swath backwards if printing RTOL.  This function
 *    determines if Cairo in printing RTOL, in which case it returns
 *    REVERSE telling the Rotate() function to build the swath backwards.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: return REVERSE if backwards swath (RTOL).
 *          return FORWARD if forwards swath (LTOR).
 *
 * Original Author: K. Profitt
 * Date: 12/12/96
 *
 ***************************************************************************/
ByteType CheckForReverseSwath(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   ByteType       bDirection,
                  bMode;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   CopySwathInfoToLSXface(lpxDataRec, NO_SWATH);
   bDirection = LSGetSwathDirection(lpxPFData->lpxHWData->lpxLSXface);
   lpxPFData->bSwathDirection = bDirection;

   if (bDirection == LS_LTOR)
   {
      bMode = FORWARD;
   }
   else
   {
      bMode = REVERSE;
   }

   return(bMode);

}  /* end of function CheckforReverseSwath() */




/****************************************************************************
 *  Function:  Compress()
 *  Parameters: <lpxPFData>     pointer to print data structure
 *  Returns:    <0>          compression not successful
 *           OR <n>          size (in bytes) of successfully compressed
 *                           print swath which is stored in
 *                           lpxPFData->hpCompress
 *  Description:
 *       Processes print data stream one slice at a time.  Compresses each
 *       slice using both compression methods, which are:
 *             mode 0   compress 0x00 bytes.
 *             mode 1   compress repeating words
 *       Places the most compressed version of the slice, along with its
 *       control word, in the output data stream.  If the length of the
 *       output data stream becomes >= length of the input data stream,
 *       stop compression.
 ***************************************************************************/
DwordType Compress(LPDVDATAREC lpxDataRec, LPPRTCMD pPrtCmd)
{
   LPPRTCMD pCompPrtCmd;
   int      nNumSlices,       /* number of slices in umcompressed data buffer*/
            nMode0Cnt,       /* compression mode 0 length count */
            nMode1Cnt,       /* compression mode 1 length count */
            i,j;           /* loop counters */
   ByteType     mode0[26],     /* work buffer for compression mode 0 */
            mode1[26],     /* work buffer for compression mode 1 */
            bSSize,         /* slice size (in bytes) */
            bBitIndex;
   DwordType    dwInLength=0,    /* input data buffer data size (in bytes) */
            dwOutLength=0,   /* output data buffer size (in bytes)*/
            dwOutBufLength=0,   /* output data buffer size + 26 */
            dwMode0CW,      /* control word for compression mode 0 */
            dwMode1CW;      /* control word for compression mode 1 */
   HPByteType   hpbInSwath;   /* pointer to uncompressed data buffer */
   HPByteType   hpbCompSwath;  /* pointer to compressed data buffer */
   LPPFDATA lpxPFData;

#if CPROF
   PrfEnter(10);
#endif
   lpxPFData      = (LPPFDATA )lpxDataRec->lpLXDevice;
   pCompPrtCmd = (LPPRTCMD)lpxPFData->lpxCompPrtCmd;


   if( lpxDataRec->bCompress == 0 )
   {
#if CPROF
      PrfExit(10);
#endif
      return(0L);
   }


   hpbInSwath = (HPByteType)pPrtCmd;
   hpbCompSwath = (HPByteType)pCompPrtCmd;
   bSSize = lpxPFData->bBytesPerSlice;

   nNumSlices = (SwordType) lpxPFData->wSliceCount;

   /* get the length of the input print data stream minus the print header */
   dwInLength = ((DwordType)lpxPFData->wSliceCount*lpxPFData->bBytesPerSlice);

   dwInLength -= SWATH_HEADER_SIZE;

   bBitIndex = (ByteType)(bSSize - 1);

   for (i = 0; i < nNumSlices; i++)
   {  /* do for each slice in input data stream */

      /* Handle first byte in slice */

      /* Add a blank slice at the beginning and end of each swath to fix Cairo
        ASIC bug. */
     if (i == 0 || i == nNumSlices - 1)
     {  /* with mode 0, first byte is 0, don't copy */
        if(bSSize == 24)
        {
           nMode0Cnt = 0;
           dwMode0CW = 0x80FFFFFF;

           /* with mode 1, first byte is always copied to the output string */
           nMode1Cnt = 1;
           mode1[0] = 0x00;
           dwMode1CW = 0x40FFFFFF;
        }
        else
        {
           nMode0Cnt = 0;
           dwMode0CW = 0x83FFFFFF;

           /* with mode 1, first byte is always copied to the output string */
           nMode1Cnt = 1;
           mode1[0] = 0x00;
           dwMode1CW = 0x43FFFFFF;
        }
     }
     /* process input data stream */
     else
     {
        if (*hpbInSwath == 0x00)
        {  /* with mode 0, if first byte is 0's, then don't copy */
          nMode0Cnt = 0;
          dwMode0CW = 0x80000000;
          dwMode0CW |= ( (DwordType) 1 << bBitIndex);
        }
        else
        {  /* with mode 0, if first byte is not 0's, then copy */
          nMode0Cnt = 1;
          mode0[0] = *hpbInSwath;
          dwMode0CW = 0x80000000;
        }


        /* with mode 1, first byte is always copied to the output string */
        nMode1Cnt = 1;
        mode1[0] = *hpbInSwath;
        dwMode1CW = 0x40000000;

        /* End of section to handle first byte in slice */


        /* move on to next byte in slice */
        hpbInSwath++;

        for   (j = 1; j < bSSize; j++)
        {  /* do for rest of bytes in slice */

          /* mode0 compression */
          if (*hpbInSwath == 0x00)
          {
            dwMode0CW |= ( (DwordType) 1 << (bBitIndex - j) );
          }
          else
          {
            mode0[nMode0Cnt] = *hpbInSwath;
            nMode0Cnt++;
          }

          /* mode 1 compression */
          if (*hpbInSwath == mode1[nMode1Cnt - 1])
          {
            dwMode1CW |= ( (DwordType) 1 << (bBitIndex - j) );
          }
          else
          {
            mode1[nMode1Cnt] = *hpbInSwath;
            nMode1Cnt++;
          }

          hpbInSwath++;
        }  /* End of for (j = 0; j < (bSSize >> 1); j++) */
     }


      /* now store the compressed slice in the output data stream */
      if (nMode0Cnt < nMode1Cnt)
      {  /* use compression mode 0 */
         dwOutLength += ( nMode0Cnt + 4 );  /* + 4 is for the control word */

         *hpbCompSwath = (ByteType) ((dwMode0CW & 0xFF000000) >> 24);
         hpbCompSwath++;
         *hpbCompSwath = (ByteType) ((dwMode0CW & 0x00FF0000) >> 16);
         hpbCompSwath++;
         *hpbCompSwath = (ByteType) ((dwMode0CW & 0x0000FF00) >> 8);
         hpbCompSwath++;
         *hpbCompSwath = (ByteType)  (dwMode0CW & 0x000000FF);
         hpbCompSwath++;
         for (j = 0; j < nMode0Cnt; j++)
         {
            *hpbCompSwath = mode0[j];
            hpbCompSwath++;
         }
      } /* End of: use compression mode 0 */
      else
      {  /* use compression mode 1 */
         dwOutLength += nMode1Cnt + 4;  /* +1 is for the control word */

         *hpbCompSwath = (ByteType) ((dwMode1CW & 0xFF000000) >> 24);
         hpbCompSwath++;
         *hpbCompSwath = (ByteType) ((dwMode1CW & 0x00FF0000) >> 16);
         hpbCompSwath++;
         *hpbCompSwath = (ByteType) ((dwMode1CW & 0x0000FF00) >> 8);
         hpbCompSwath++;
         *hpbCompSwath = (ByteType)  (dwMode1CW & 0x000000FF);
         hpbCompSwath++;
         for (j = 0; j < nMode1Cnt; j++)
         {
            *hpbCompSwath = mode1[j];
            hpbCompSwath++;
         }
      } /* End of use compression mode 1 */
   }  /* End of for (i = 0; i < nNumSlices; i++) */

#if CPROF
PrfExit(10);
#endif

   return(dwOutLength);

}  /* end of Compress() */



/****************************************************************************
 * Function Name:    CheckSwathDensity
 *
 * Description:
 *    Cairo can become power starved if the number of dots printed is too
 *    high for too long.  CheckSwathDensity() counts the number of dots one
 *    section at a time to seed see if a swath needs to be broken into two
 *    swaths.  If any one section is above the percent coverage threshold,
 *    then signal that the swath needs to be divided into two swaths.
 *
 * Inputs:  lpxDataRec   Long pointer to print device structure.
 *
 * Outputs: Return 1 if Swath is too dense, otherwise return 0.
 *
 * Original Author: J. Bates
 * Date: 04/10/97
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 ***************************************************************************/
SwordType CheckSwathDensity(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   SwordType      i, j, k,
                  swDotsPerSlice,
                  swRetCode=0,   /* initial state assuming swath is not    */
                                 /* too dense                              */
                  swSegs,
                  swSlices,
                  swThresholdPct;
   DwordType      dwThresholdDots,
                  dwSegDotCount;
   ByteType       bBPS;
   HPByteType     hpbSliceByte;

   lpxPFData  = (LPPFDATA )lpxDataRec->lpLXDevice;

   if (lpxPFData->bPrintHead == MONO_CARTRIDGE)
      swDotsPerSlice = 208;
   else
      swDotsPerSlice = 192;

   if (lpxPFData->bResolution == SUPERLOWRES)
   {  /* 300x600 dpi, threshold is more than 50% dots for two inches       */
      swSlices = 600;
      swThresholdPct = 50;
   }
   else if (lpxPFData->bResolution == LORES)
   {  /* 600 dpi, threshold is more than 50% dots for one inch             */
      if (lpxPFData->bShingleLoRes == SHINGLE_50 )
      {  /* 300 dpi swath in 600dpi mode. Use 300 dpi limits. */
         swSlices = 600;
         swThresholdPct = 50;
      }
      else
      {  /* true 600 dpi swath */
         swSlices = 600;
         swThresholdPct = 50;

         /* Don't check density for CMY swaths that are shingled */
         if ( (lpxPFData->bPrintHead == COL_CARTRIDGE) &&
              (lpxPFData->bShingle   != NO_SHINGLE)          )
         {  /* normal CMY shingled swath so just return */
            return(swRetCode);
         }
      }
   }
   else
   {  /* 1200 dpi, threshold is more than 25% dots for one inch            */
      if (lpxPFData->bShingleHiRes == SHINGLE_50 )
      {  /* 600 dpi swath in HiRes mode. Use 600 dpi limits. */
         swSlices = 600;
         swThresholdPct = 50;
      }
      else
      {  /* true 1200 dpi swath */
         swSlices = 1200;
         swThresholdPct = 25;
      }
   }

   dwThresholdDots = (DwordType)((DwordType)swSlices * swDotsPerSlice * swThresholdPct / 100);
   bBPS = lpxPFData->bBytesPerSlice;
   swSegs = (lpxPFData->wSliceCount+swSlices-1)/swSlices;

   hpbSliceByte = (HPByteType)lpxPFData->lpxPrtCmd+SWATH_HEADER_SIZE;
   for (i = 1; i <= swSegs; i++)
   {
      dwSegDotCount = 0;
      if (i == swSegs)
      {
         /* The last segment will likely not have a full count of slices */
         swSlices = lpxPFData->wSliceCount - (swSlices*(i-1));
      }
      for (j=0; j<swSlices; j++)
      {
         for (k=0; k<bBPS; k++)
         {
            dwSegDotCount += lpxPFData->abBitCount[(*hpbSliceByte)];
            hpbSliceByte++;
         }
      }
      if (dwSegDotCount > dwThresholdDots)
      {
         /* This swath is too dense, it should be broken into two swaths   */
         swRetCode = 1;
         break;
      }
   }

   return(swRetCode);

}  /* end of CheckSwathDensity() */




/****************************************************************************
 * Function Name:    CreateTwoSwaths
 *
 * Description:
 *    Splits one swath into two swaths by moving every even slice from the
 *    first swath into the second swath.
 *
 * Inputs:  lpxDataRec   Long pointer to print device structure.
 *
 * Outputs: places every even slice from swath lpxPFData->lpxPrtCmd into
 *          the same location of swath lpxPFData->pDensePrtCmd, and
 *          then removes the even slice from lpxPFData->lpxPrtCmd.
 *
 * Original Author: J. Bates
 * Date: 04/10/97
 *
 * Changes:
 *    Date        Name           Reason for Change
 *
 ***************************************************************************/
void CreateTwoSwaths(LPDVDATAREC lpxDataRec)
{
   ByteType     bBPS;
   HPByteType   hpbSliceByte, hpbDenseSliceByte, hbpHeader;
   HPWordType   hpwDenseSwath;
   WordType     i,j;
   DwordType    k;
   LPPRTCMD pPrtCmd, pDensePrtCmd;
   LPPFDATA lpxPFData;

   lpxPFData            = (LPPFDATA )lpxDataRec->lpLXDevice;
   pDensePrtCmd      = (LPPRTCMD)lpxPFData->lpxDensePrtCmd;
   pPrtCmd           = (LPPRTCMD)lpxPFData->lpxPrtCmd;
   hbpHeader         = (HPByteType) pDensePrtCmd;
   bBPS              = lpxPFData->bBytesPerSlice;
   hpbSliceByte      = (HPByteType)pPrtCmd+SWATH_HEADER_SIZE;
   hpbDenseSliceByte = (HPByteType)pDensePrtCmd+SWATH_HEADER_SIZE;
   hpwDenseSwath     = (HPWordType)pDensePrtCmd;

   for (k=0; k<(lpxPFData->dwSwathPrintSize/2); k++)
      /* initialize second swath buffer to 0 */
      *hpwDenseSwath++ = 0x0000;

   for (i=0;i<lpxPFData->wSliceCount;i+=2)
   {
      for (j=0;j<bBPS;j++)
      {  /* copy even slice into second swath and apply an 0xAA shingle */
         /* pattern to the source swath and an 0x55 shingle pattern to the */
         /* second swath */
         *hpbDenseSliceByte++ = *hpbSliceByte & 0x55;
         *hpbSliceByte++ &= 0xAA;
      }

      for (j=0;j<bBPS;j++)
      {  /* copy odd slice into second swath and apply an 0xAA shingle */
         /* pattern to the source swath and an 0x55 shingle pattern to the */
         /* second swath */
         *hpbDenseSliceByte++ = *hpbSliceByte & 0xAA;
         *hpbSliceByte++ &= 0x55;
      }
   }

   return;
}




/****************************************************************************
 *  FCCAIRO.C                                          Lexmark Confidential
 *
 * Function Name:    PopulateBitCount
 *
 * Description:
 *    This function initializes the bit count array used when we are
 *    checking swath density.  So for byte values 0..255, this array
 *    has a corresponding member 0..255 which has stored how many bits
 *    are set to 1.
 *
 * Inputs:
 *    lpxDataRec   Long pointer to print device structure.
 *
 * Outputs: initializes lpxPFData->abBitCount[] array
 *
 * Original Author: J. Bates
 * Date: 04/10/97
 *
 ***************************************************************************/
void PopulateBitCount(LPDVDATAREC lpxDataRec)
{
   LPPFDATA lpxPFData;
   SwordType  i;
   ByteType ii,j,k=1;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   for (i=0; i<=255; i++)
   {
      lpxPFData->abBitCount[i] = 0;
      ii = (unsigned char)i;
      for (j=0; j<8; j++)
      {
         lpxPFData->abBitCount[i] = (ByteType)(lpxPFData->abBitCount[i]+(ii & 0x01));
         ii >>= 1;
      }
   }
}  /* end of PopulateBitCount() */




/****************************************************************************
 *  FCCAIRO.C                                          Lexmark Confidential
 *
 * Function Name:    VerticalMoveInPhase
 *
 * Description:
 *    Large vertical moves must be "in phase", which means they should be
 *    a whole 300 dpi movement.  So for 600dpi printing, large space
 *    vertical movements should be a multiple of 2, and for  1200dpi
 *    printing, large space vertical movements should be a multiple of 4.
 *    For example, 1/600 is not an even 300dpi movement, but 2/600 is an
 *    even 300dpi movement (1/300).  This function determines whether a
 *    potential large space vertical move is "in phase".  If the movement
 *    is "in phase" then return 0.  If the movement is not "in phase", then
 *    return the number of blank lines which should be inserted before the
 *    next raster line to reduce the vertical movement enough to bring the
 *    vertical movement "in phase".
 *
 * Inputs:
 *    lpxDataRec         Long pointer to print device structure.
 *    lNextRasterLine   raster line number for next raster line.
 *
 * Outputs: returns number of blank lines to insert to make vertical move
 *          "in phase"
 *
 * Original Author: J. Bates
 * Date: 01/09/98
 *
 ***************************************************************************/
SdwordType  VerticalMoveInPhase(LPDVDATAREC lpxDataRec, SdwordType lNextRasterLine)
{
   SdwordType  lVerticalAdjustment;
   LPPFDATA lpxPFData;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   switch (lpxPFData->swVertResMult)
   {
   case 1  :
   default :
      /* this is a 600dpi vertical resolution print job.  So make sure     */
      /* lNextRasterLine is evenly divisible by 2.                         */
      lVerticalAdjustment = lNextRasterLine%2;
      break;
   case 2:
      /* this is a 1200dpi vertical resolution print job.  So make sure    */
      /* lNextRasterLine is evenly divisible by 4.                         */
      lVerticalAdjustment = lNextRasterLine%4;
      break;
   }

   return (lVerticalAdjustment);
}




/****************************************************************************
 * Function Name:    SetShingle
 *
 * Description:
 *    This functions set the shingle amount for each raster line's color
 *    planes.  This is a critical function in our independent shingling
 *    solution.  We are always setting the CMY color planes shingle
 *    amounts the same on a page basis.  But for the K color plane in a
 *    CMYK print job, we will change its shingle amount based on whether
 *    there is any color arount the K plane.
 *
 * Inputs:
 *    lpxDataRec         Long pointer to print device structure.
 *    nRowIndex         index into our raster line information buffers for
 *                      the current raster line.
 *
 * Outputs: (none)
 *
 * Original Author: J. Bates
 * Date: 07/01/97
 *
 ***************************************************************************/
void SetShingle(LPDVDATAREC lpxDataRec, SwordType nRowIndex)
{
   ByteType  bShingle;
   int   n,i,swIEnd;
   ByteType  bShingleToApply;
   int   nRI;
   LPPFDATA lpxPFData;
   BoolType  fColors;

#if CPROF
PrfEnter(3);
#endif

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   nRI = nRowIndex;
   bShingle  = lpxPFData->bShingle;

   switch(bShingle)
   {
      case SHINGLE_50 :
            bShingleToApply = SHINGLE_50_1;
            break;
      case SHINGLE_25 :
            bShingleToApply = SHINGLE_25_1;
            break;
      case SHINGLE_33 :
            bShingleToApply = SHINGLE_33_1;
            break;
      default :
            bShingleToApply = SHINGLE_0_1;
            break;
   }

   for (n=lpxPFData->swDelayBufStart;n<lpxPFData->swDelayBufEnd;n++)
   {
      lpxPFData->alpbShingleToApply[n][nRowIndex] = bShingleToApply;
   }

   /* For Cairo envelope printing, we must allow time for the black ink    */
   /* to dry before it rubs against the trailing edge of the cartridges.   */
   /* One thing we do to help accomplish this is to use only the bottom    */
   /* portion of the black printhead.  The bottom portion is the section   */
   /* fartherest from the trailing edge of the cartridges.  We do this by  */
   /* not shingling the black color plane, but we change the 'print zone'  */
   /* to the bottom x nozzles. This changing the 'print zone' is done in   */
   /* functions LoadShingleMasks() and GetMonoNozzlesToUse().          */
   if ((GetMonoNozzlesToUse(lpxDataRec)) != 0)
   {
      if (lpxDataRec->bColorPlanes == 1)
      {
         lpxPFData->alpbShingleToApply[0][nRI] = SHINGLE_0_1;
      }
      else if (lpxDataRec->bColorPlanes == 4)
      {
         lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_0_1;
      }
      return;
   }
   /* end of Cairo envelope printing specific section.                   */

   if (lpxDataRec->bColorPlanes == 4)
   {
      if (lpxPFData->swVertResMult == HIRES_VERTICAL_MULTIPLIER)
      {
         lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_33_1;
      }
      else if (lpxPFData->bResolution != SUPERLOWRES)
      {
         /* CMYK 600 dpi print page, so consider K dynamic shingling */

         fColors = FALSE;

         /* are there any color dots in this raster line ? */
         for (n=0; n<3; n++)
         {
            if (lpxPFData->alpswScanStart[n][nRI] < lpxPFData->alpswScanEnd[n][nRI])
            {
               fColors = TRUE;
               break;
            }
         }

         if ( (fColors == TRUE) && (lpxPFData->swFutureRowsToShingle == 0) )
         {
            /* this raster line has color dots and is following an area of */
            /* black only printing (or is at the top of page or after a    */
            /* large white space skip), so increase the K shingle amount   */
            /* for this raster line and the raster lines above this one,   */
            /* and set nFutureRowsToShingle to increase K shingle amount   */
            /* for next SHINGLE_BAND lines.      */

            if (lpxPFData->sdwRowPos < SHINGLE_BAND)
               swIEnd = (SwordType)lpxPFData->sdwRowPos;
            else
               swIEnd = SHINGLE_BAND;
            for (i=0; i<=swIEnd; i++)
            {
               if ( (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_0_1) ||
                    (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_50_1) )
                  lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_33_1;
               else if (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_25_1)
                  lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_16_1;
               nRI--;
               if (nRI < 0)
                  nRI = lpxPFData->swMaxDelayBuf-1;
            }
            lpxPFData->swFutureRowsToShingle = SHINGLE_BAND;
         }
         else if (fColors == TRUE)
         {
            /* this raster line has color dots, so increase the K shingle  */
            /* amount for this raster line and set nFutureRowsToShingle to */
            /* increase K shingle amount for next SHINGLE_BAND lines.      */

            if ( (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_0_1) ||
                 (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_50_1) )
               lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_33_1;
            else if (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_25_1)
               lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_16_1;
            lpxPFData->swFutureRowsToShingle = SHINGLE_BAND;
         }
         else if (lpxPFData->swFutureRowsToShingle > 0)
         {
            if ( (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_0_1) ||
                 (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_50_1) )
               lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_33_1;
            else if (lpxPFData->alpbShingleToApply[3][nRI] == SHINGLE_25_1)
               lpxPFData->alpbShingleToApply[3][nRI] = SHINGLE_16_1;
            lpxPFData->swFutureRowsToShingle--;
         }
      }
   }


#if CPROF
PrfExit(3);
#endif
   return;
}  /* end of SetShingle() */




/****************************************************************************
 * Function Name:    GetMonoNozzlesToUse
 *
 * Description:
 *    For Cairo envelope printing, we must allow time for the black ink
 *    to dry before it rubs against the trailing edge of the cartridges.
 *    One thing we do to help accomplish this is to use only the bottom
 *    portion of the black printhead.  The bottom portion is the section
 *    fartherest from the trailing edge of the cartridges.  We do this by
 *    not shingling the black color plane, but we change the 'print zone'
 *    to the bottom x nozzles. GetMonoNozzlesToUse() sets this value x
 *    for all print jobs with mediasize = envelope.
 *
 *    Tom Bailey and Terry King ran tests the week of Dec. 8 - 11 1997,
 *    and determined we should use the bottom 50 mono nozzles when
 *    printing envelopes.
 *
 * Inputs:  lpxDataRec   Long pointer to print device structure.
 *
 * Outputs: returns the number of black nozzles to use when printing
 *          envelopes.  For nonenvelope pages, returns 0.
 *          banner printing.
 *
 * Original Author: J. Bates
 * Date: 12/7/97
 *
 ***************************************************************************/
WordType GetMonoNozzlesToUse(LPDVDATAREC lpxDataRec)
{
   WordType wNozzlesToUse;
   LPPFDATA lpxPFData;

   lpxPFData = (LPPFDATA )lpxDataRec->lpLXDevice;

   switch (lpxDataRec->bMediaSize)
   {
   case ENVELOPE_MONARCH :
   case ENVELOPE_9  :
   case ENVELOPE_10 :
   case ENVELOPE_DL :
   case ENVELOPE_C5 :
   case ENVELOPE_B5 :
   case ENVELOPE_C6 :
   case ENVELOPE_D5 :
   case ENVELOPE_75 :
   case ENVELOPE_6_3_4 :
   case ENVELOPE_BARONIAL :
   case ENVELOPE_CUSTOM   :
   case JPNLONG3   :
   case JPNSQUARE4 :
   case JPNSQUARE5 :
   case JPNSQUARE6 :
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) ||
           (lpxPFData->bResolution == HIRES_NONINTERLACED) )
         {  /* use all nozzles in high resolution */
            wNozzlesToUse = 0;
         }
         else
         {  /* use only part of the nozzles to prevent smear */
            wNozzlesToUse = 50;
         }
         break;
   default :
         wNozzlesToUse = 0;
         break;
   }

   return(wNozzlesToUse);

}  /* end of GetMonoNozzlesToUse() */



/****************************************************************************
 * Function Name:    SetCartridgeAlignment
 *
 * Description:
 * This function sets the print heads vertical adjustment value.  It also
 * does some error checking on all cartridge adjustment values to make sure
 * they are between the minimum and maximum possible values.
 *
 * Inputs:  lpxDataRec   Long pointer to print device structure.
 *
 * Outputs: sets lpxPFData->swHead1VertAdjust and
 *               lpxPFData->swHead2VertAdjust
 *
 * Original Author: J. Bates
 * Date: 1/29/98
 *
 ***************************************************************************/
void SetCartridgeAlignment(LPDVDATAREC lpxDataRec)
{
   SwordType   swVertAlign;
   LPPFDATA lpxPFData;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   lpxPFData->swHead1VertAdjust = 0;
   lpxPFData->swHead2VertAdjust = 0;

   /* perform error checking on alignment values passed in from the driver */

   if ( (lpxDataRec->bVerticalAdj < VERTHEAD_MINALIGN) ||
        (lpxDataRec->bVerticalAdj > VERTHEAD_MAXALIGN) )
   {
      lpxDataRec->bVerticalAdj = VERTHEAD_MIDALIGN;
   }

   if ( (lpxDataRec->bHorizontalAdj < HORZHEAD_MINALIGN) ||
        (lpxDataRec->bHorizontalAdj > HORZHEAD_MAXALIGN) )
   {
      lpxDataRec->bHorizontalAdj = HORZHEAD_MIDALIGN;
   }

   if ( (lpxDataRec->bBidiAlignMono < KHEAD_MINALIGN) ||
        (lpxDataRec->bBidiAlignMono > KHEAD_MAXALIGN) )
   {
      lpxDataRec->bBidiAlignMono = KHEAD_MIDALIGN;
   }

   if ( (lpxDataRec->bBidiAlignColor < CMYHEAD_MINALIGN) ||
        (lpxDataRec->bBidiAlignColor > CMYHEAD_MAXALIGN) )
   {
      lpxDataRec->bBidiAlignColor = CMYHEAD_MIDALIGN;
   }

   switch (lpxDataRec->bColorPlanes)
   {
   case 1  :
   case 3  :
   default :
      break;
   case 4  :
   case 6  :
      swVertAlign = lpxDataRec->bVerticalAdj;

      if (swVertAlign < VERTHEAD_MIDALIGN)
      {
         lpxPFData->swHead1VertAdjust = (VERTHEAD_MIDALIGN - swVertAlign);
      }
      else if (swVertAlign > VERTHEAD_MIDALIGN)
      {
         lpxPFData->swHead2VertAdjust = (swVertAlign -
                                        (SwordType)VERTHEAD_MIDALIGN);
      }
      break;
   }

   return;

}  /* end of SetCartridgeAlignment() */



/****************************************************************************
 * Function Name:    SetDropsPerPixel
 *
 * Description:
 *    This function sets the internal (lpxPFData) drops per pixel
 *    value for each color plane, based on the input interface variable
 *    lpxDataRec->bBitsPerPixel.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Sets correct values for lpxPFData->abBitsPerPixel[]
 *
 * Original Author: J. Bates
 * Date: 02/23/98
 *
 ***************************************************************************/
void SetDropsPerPixel(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   ByteType    i;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   for (i=0; i<lpxPFData->bColorPlanes; i++)
   {
      lpxPFData->asdwDBIndx[DROPS_PER_PIXEL][i] = 1;
   }

   return;

}  /* end of SetDropsPerPixel() */




/****************************************************************************
 * Function Name:    SetBitsPerPixel
 *
 * Description:
 *    This function sets the internal (lpxPFData) bits per pixel
 *    value for each color plane, based on the input interface variable
 *    lpxDataRec->bBitsPerPixel.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: Sets correct values for lpxPFData->abBitsPerPixel[]
 *
 * Original Author: J. Bates
 * Date: 02/23/98
 *
 ***************************************************************************/
void SetBitsPerPixel(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   ByteType    i;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   for (i=0; i<lpxPFData->bColorPlanes; i++)
   {
      lpxPFData->abBitsPerPixel[i] = 1;
   }

   return;

}  /* end of SetBitsPerPixel() */




#if defined(GEN_TEST_INPUT_FILES)
/****************************************************************************
 * Function Name:    SendRasters
 *
 * Description:
 *    This function is used to generate input image files for out development
 *    environment.  When GEN_TEST_INPUT_FILES is defined, we route all input
 *    raster lines to this function to be "printed".  All other print
 *    commands are also routed through this function, but since they don't
 *    begin with "XXXX" they are ignored.  I say "printed" because the proper
 *    use of this function is to set the driver to print to file, and then
 *    print images, which will result in image files that contains an exact
 *    image of what the driver gave the hbpcode as input.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *          lpCmdPtr    Long pointer to the data to be printed.
 *          dwSize      number of bytes in the print datastream.
 *
 * Outputs: Sends raster lines on to SendCommand() to be "printed".
 *
 * Original Author: J. Bates
 * Date: 03/31/98
 *
 ***************************************************************************/
void FAR SendRasters(LPDVDATAREC lpxDataRec, void FAR * lpCmdPtr, DwordType dwSize)
{
   LPByteType     lpbCmdPtr;

   lpbCmdPtr = (LPByteType) lpCmdPtr;

   if ( (dwSize > 4) && ((_fstrncmp((char FAR *)lpbCmdPtr,"XXXX",4)) == 0) )
   {
      lpbCmdPtr += 4;
      dwSize    -= 4;
#if defined(DOS_BUILD) || defined(FC_DOS_32)
      OutToFile(lpxDataRec,lpbCmdPtr,dwSize);
#elif defined(FC_WIN16_DLL)
      lpfnSendCommand((void FAR *)lpxDataRec->lpLXGenericPtr, (void FAR *)lpbCmdPtr,
                      dwSize);
#else
      SendCommand((void FAR *)lpxDataRec->lpLXGenericPtr, (void FAR *)lpbCmdPtr,
                  dwSize);
#endif
   }

   return;

}  /* end of SendRasters() */
#endif




void CopyDocInfoToLSXface(LPDVDATAREC lpxDataRec)
{
   LPPFDATA       lpxPFData;
   LPHWDATA       lpxHWData;
   LPLSINTFACE    lpxLSXface;

   lpxPFData  = (LPPFDATA )lpxDataRec->lpLXDevice;
   lpxHWData  = lpxPFData->lpxHWData;
   lpxLSXface = (LPLSINTFACE)lpxPFData->lpxHWData->lpxLSXface;

	cairo_trace2("CopyDocInfoToLSXface(): lpxHWData=%p, lpxLSXFace=%p\n", lpxHWData, lpxLSXface);

   lpxLSXface->bColorPlanes            = lpxDataRec->bColorPlanes;
   lpxLSXface->bBidiAlignMono          = lpxDataRec->bBidiAlignMono;
   lpxLSXface->bHorizontalAdj          = lpxDataRec->bHorizontalAdj;
   lpxLSXface->bBidiAlignColor         = lpxDataRec->bBidiAlignColor;
   lpxLSXface->dwSecondsSinceLastPrint = lpxDataRec->dwSecondsSinceLastPrint;
   lpxLSXface->bMediaSource            = LS_AUTO_FEED;


   switch (lpxDataRec->bMediaSize)
   {
   case PAPER_LETTER :
   default :
      lpxLSXface->bMediaSize = LS_PAPER_LETTER;
      break;
   case PAPER_LEGAL:
      lpxLSXface->bMediaSize = LS_PAPER_LEGAL;
      break;
   case PAPER_B5:
      lpxLSXface->bMediaSize = LS_PAPER_B5;
      break;
   case PAPER_EXECUTIVE:
      lpxLSXface->bMediaSize = LS_PAPER_EXECUTIVE;
      break;
   case PAPER_A5:
      lpxLSXface->bMediaSize = LS_PAPER_A5;
      break;
   case PAPER_USER:
      lpxLSXface->bMediaSize = LS_PAPER_USER;
      break;
   case PAPER_A4:
      lpxLSXface->bMediaSize = LS_PAPER_A4;
      break;
   case PAPER_OHFHAGAKI:
      lpxLSXface->bMediaSize = LS_PAPER_OHFHAGAKI;
      break;
   case PAPER_HAGAKI:
      lpxLSXface->bMediaSize = LS_PAPER_HAGAKI;
      break;
   case ENVELOPE_MONARCH:
      lpxLSXface->bMediaSize = LS_ENVELOPE_MONARCH;
      break;
   case ENVELOPE_9:
      lpxLSXface->bMediaSize = LS_ENVELOPE_9;
      break;
   case ENVELOPE_10:
      lpxLSXface->bMediaSize = LS_ENVELOPE_10;
      break;
   case ENVELOPE_DL:
      lpxLSXface->bMediaSize = LS_ENVELOPE_DL;
      break;
   case ENVELOPE_C5:
      lpxLSXface->bMediaSize = LS_ENVELOPE_C5;
      break;
   case ENVELOPE_B5:
      lpxLSXface->bMediaSize = LS_ENVELOPE_B5;
      break;
   case ENVELOPE_C6:
      lpxLSXface->bMediaSize = LS_ENVELOPE_C6;
      break;
   case ENVELOPE_D5:
      lpxLSXface->bMediaSize = LS_ENVELOPE_D5;
      break;
   case ENVELOPE_75:
      lpxLSXface->bMediaSize = LS_ENVELOPE_75;
      break;
   case CARD_3X5:
      lpxLSXface->bMediaSize = LS_CARD_3X5;
      break;
   case CARD_4X6:
      lpxLSXface->bMediaSize = LS_CARD_4X6;
      break;
   case PAPER_BANNER_A4:
      lpxLSXface->bMediaSize = LS_PAPER_BANNER_A4;
      break;
   case PAPER_BANNER_LETTER:
      lpxLSXface->bMediaSize = LS_PAPER_BANNER_LETTER;
      break;
   case CARD_A6:
      lpxLSXface->bMediaSize = LS_CARD_A6;
      break;
   case ENVELOPE_BARONIAL:
      lpxLSXface->bMediaSize = LS_ENVELOPE_BARONIAL;
      break;
   case ENVELOPE_6_3_4:
      lpxLSXface->bMediaSize = LS_ENVELOPE_6_3_4;
      break;
   case JPNLONG3:
      lpxLSXface->bMediaSize = LS_JPNLONG3;
      break;
   case JPNSQUARE4:
      lpxLSXface->bMediaSize = LS_JPNSQUARE4;
      break;
   case JPNSQUARE5:
      lpxLSXface->bMediaSize = LS_JPNSQUARE5;
      break;
   case JPNSQUARE6:
      lpxLSXface->bMediaSize = LS_JPNSQUARE6;
      break;
   case PAPER_A3:
      lpxLSXface->bMediaSize = LS_PAPER_A3;
      break;
   case PAPER_SUPER_A3:
      lpxLSXface->bMediaSize = LS_PAPER_SUPER_A3;
      break;
   case PAPER_TABLOID:
      lpxLSXface->bMediaSize = LS_PAPER_TABLOID;
      break;
   case ENVELOPE_CUSTOM:
      lpxLSXface->bMediaSize = LS_ENVELOPE_CUSTOM;
      break;
   case PAPER_CUSTOM_BANNER:
      lpxLSXface->bMediaSize = LS_PAPER_CUSTOM_BANNER;
      break;
   case PAPER_CUSTOM:
      lpxLSXface->bMediaSize = LS_PAPER_CUSTOM;
      break;
   }


   switch (lpxDataRec->bMediaType)
   {
   case PLAIN_PAPER :
   default :
      lpxLSXface->bMediaType = LS_PLAIN_PAPER;
      break;
   case COATED_PAPER :
      lpxLSXface->bMediaType = LS_COATED_PAPER;
      break;
   case GLOSSY_PAPER :
      lpxLSXface->bMediaType = LS_GLOSSY_PAPER;
      break;
   case TRANSPARENCY :
      lpxLSXface->bMediaType = LS_TRANSPARENCY;
      break;
   case IRON_ON_TRANSFER :
      lpxLSXface->bMediaType = LS_IRON_ON_TRANSFER;
      break;
   case GREETING_CARD_STOCK :
      lpxLSXface->bMediaType = LS_GREETING_CARD_STOCK;
      break;
   }


   switch (lpxPFData->bPrintQuality)
   {
   case QUALITY_DRAFT :
      lpxLSXface->bPrintQuality = LS_QUALITY_DRAFT;
      break;
   case QUALITY_NORMAL :
   default :
      lpxLSXface->bPrintQuality = LS_QUALITY_NORMAL;
      break;
   case QUALITY_HIGH :
      if(lpxPFData->bShingle == SHINGLE_50)
      {
      /* Cairo uses the 1200_AS_2X_600 option for 1200 dpi that is 2 pass */
         lpxLSXface->bPrintQuality = LS_QUALITY_NORMAL;
      }
      else
      {
         lpxLSXface->bPrintQuality = LS_QUALITY_HIGH;
      }
      break;
   }

  return;

}




void CopySwathInfoToLSXface(LPDVDATAREC lpxDataRec, ByteType bSwathDensity)
{
   LPPFDATA       lpxPFData;
   LPHWDATA       lpxHWData;
   LPLSINTFACE    lpxLSXface;
   SwordType      swHorzMult;
   DwordType      dwDotCount,
                  dwSwathDensity;
   ByteType       bN;

	cairo_trace2("CopySwathInfoToLSXface(): lpxHWData=%p, lpxLSXFace=%p\n", lpxHWData, lpxLSXface);

   lpxPFData  = (LPPFDATA )lpxDataRec->lpLXDevice;
   lpxHWData  = lpxPFData->lpxHWData;
   lpxLSXface = (LPLSINTFACE)lpxPFData->lpxHWData->lpxLSXface;


   switch (lpxPFData->bResolution)
   {
   case SUPERLOWRES :
      swHorzMult = 4;
      lpxLSXface->xSwath.bResolution = LS_300_DPI;
      break;
   case LORES :
      swHorzMult = 2;

#if OPTION_600_AS_2X300
      if (lpxPFData->bShingleLoRes == SHINGLE_50)
      {  /* New 600 requires the 300 dpi(in 2 passes) printing mode */
         lpxLSXface->xSwath.bResolution = LS_300_DPI;
      }
      else
#endif

      {
         lpxLSXface->xSwath.bResolution = LS_600_DPI;
      }
      break;
   default :
      swHorzMult = 1;
      if(lpxPFData->bShingleHiRes == SHINGLE_50)
      {
         /* Print 1200 dpi as 2-pass 600 dpi   */
         lpxLSXface->xSwath.bResolution = LS_600_DPI;
      }
      else
      {
         lpxLSXface->xSwath.bResolution = LS_1200_DPI;
      }
      break;
   }

   lpxLSXface->xSwath.wSliceCount          = lpxPFData->wSliceCount;
   lpxLSXface->xSwath.wVertMoveBeforePrint = lpxPFData->swFormsMovePending;
   lpxLSXface->xSwath.bBytesPerSlice       = lpxPFData->bBytesPerSlice;
   lpxLSXface->xSwath.swLeftPrintPos  = lpxPFData->swLeftPrintPos*swHorzMult;
   lpxLSXface->xSwath.swRightPrintPos = lpxPFData->swRightPrintPos*swHorzMult;

   switch (lpxPFData->bPrintDirection)
   {
   case  LTOR :
      lpxLSXface->xSwath.bPrintDirection = LS_LTOR;
      break;
   case RTOL :
      lpxLSXface->xSwath.bPrintDirection = LS_RTOL;
      break;
   case BIDI :
      lpxLSXface->xSwath.bPrintDirection = lpxPFData->bSwathDirection;
      break;
   }

   switch (lpxPFData->bPrintHead)
   {
   case COL_CARTRIDGE :
      lpxLSXface->xSwath.bPrintHead = LS_CMY_CARTRIDGE;
      break;
   case MONO_CARTRIDGE :
      lpxLSXface->xSwath.bPrintHead = LS_MONO_CARTRIDGE;
      break;
   case KCM_CARTRIDGE :
      lpxLSXface->xSwath.bPrintHead = LS_KCM_CARTRIDGE;
      break;
   }



   switch (lpxPFData->bPreRotateDir)
   {
   case  LTOR :
      lpxLSXface->xSwath.bNextPrintDirection = LS_LTOR;
      break;
   case RTOL :
      lpxLSXface->xSwath.bNextPrintDirection = LS_RTOL;
      break;
   case BIDI :
      lpxLSXface->xSwath.bNextPrintDirection = LS_BIDI;
      break;
   }

   switch (lpxPFData->bPreRotatePrintHead)
   {
   case COL_CARTRIDGE :
      lpxLSXface->xSwath.bNextPrintHead = LS_CMY_CARTRIDGE;
      break;
   case MONO_CARTRIDGE :
      lpxLSXface->xSwath.bNextPrintHead = LS_MONO_CARTRIDGE;
      break;
   case KCM_CARTRIDGE :
      lpxLSXface->xSwath.bNextPrintHead = LS_KCM_CARTRIDGE;
      break;
   }



   lpxLSXface->xSwath.wNextVertMoveBeforePrint  = lpxPFData->swFutureFormsMovePending;
   lpxLSXface->xSwath.swNextLeftPrintPos = lpxPFData->swNextLeftPos;
   lpxLSXface->xSwath.swNextRightPrintPos = lpxPFData->swNextRightPos;
   lpxLSXface->xSwath.swNextRightPrintPos -= 1;

   if (lpxPFData->bPreRotatePrintHead == MONO_CARTRIDGE)
   {
      lpxLSXface->xSwath.swNextRightPrintPos +=(MONO_NOZZLE_OFFSET * lpxPFData->swSwathResMult);
   }
   else
   {
      lpxLSXface->xSwath.swNextRightPrintPos += ((COLOR_NOZZLE_OFFSET + COLOR_HEAD_OFFSET) * lpxPFData->swSwathResMult);
   }


   lpxLSXface->xSwath.swNextLeftPrintPos  *= swHorzMult;
   lpxLSXface->xSwath.swNextRightPrintPos *= swHorzMult;



   if (bSwathDensity == FULL_SWATH)
   {
      dwSwathDensity = 1;
   }
   else if (bSwathDensity == HALF_SWATH)
   {
      dwSwathDensity = 2;
   }
   else
   {
      return;
   }

   switch (lpxPFData->bPrintHead)
   {
   case COL_CARTRIDGE :
      for (bN=0; bN<3; bN++)
      {
         if ( lpxPFData->asdwDotCount[bN] <
              (SdwordType)lpxHWData->adwDotCount[bN] )
         {  /* the PFData dot counts have been reinitialized */
            lpxHWData->adwDotCount[bN] = 0;
         }
         dwDotCount = (DwordType) (lpxPFData->asdwDotCount[bN] -
                      lpxHWData->adwDotCount[bN]) / dwSwathDensity;
         lpxLSXface->xSwath.adwDotCount[bN] = dwDotCount;
         lpxHWData->adwDotCount[bN]        += dwDotCount;
      }
      break;

   case MONO_CARTRIDGE :
      if (lpxDataRec->bColorPlanes == 1)
      {
         bN = 0;
      }
      else
      {
         bN = 3;
      }
      if (lpxPFData->asdwDotCount[bN] < (SdwordType)lpxHWData->adwDotCount[bN])
      {  /* the PFData dot counts have been reinitialized */
         lpxHWData->adwDotCount[bN] = 0;
      }
      dwDotCount = (DwordType) (lpxPFData->asdwDotCount[bN] -
                   lpxHWData->adwDotCount[bN]) / dwSwathDensity;
      lpxLSXface->xSwath.adwDotCount[0] = dwDotCount;
      lpxHWData->adwDotCount[bN]       += dwDotCount;
      break;

   case KCM_CARTRIDGE :
      for (bN=3; bN<6; bN++)
      {
         if (lpxPFData->asdwDotCount[bN] < (SdwordType)lpxHWData->adwDotCount[bN])
         {  /* the PFData dot counts have been reinitialized */
            lpxHWData->adwDotCount[bN] = 0;
         }
         dwDotCount = (DwordType) (lpxPFData->asdwDotCount[bN] -
                      lpxHWData->adwDotCount[bN]) / dwSwathDensity;
         lpxLSXface->xSwath.adwDotCount[bN-3] = dwDotCount;
         lpxHWData->adwDotCount[bN]          += dwDotCount;
      }
      break;
   }

  return;

}

/****************************************************************************
 * Function Name:    ExpandSwathTo8Inches
 *
 * Description:
 *    For Cairo, we must slow down envelope printing to allow time for the
 *    ink to dry before it rubs against the back edge of the cartrdige.  One
 *    way we do this is by taking each swath and expanding it to 8 inches, so
 *    the carrier moves the entire 8 inches, thereby taking more time.  This
 *    is the function which expands each swath to 8 inches.
 *
 * Inputs:  lpxDataRec   Long pointer to print device structure.
 *
 * Outputs: expands a swath to 8 inches.
 *
 * Original Author: J. Bates
 * Date: 12/1/97
 *
 ***************************************************************************/
DwordType ExpandSwathTo8Inches(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   ByteType    bResolution,
               bSliceSize;
   WordType    n,
               wSliceCount,
               wMultiplier;
   SwordType   m,
               swLeftPrtPos,
               swRightPrtPos,
               swSlicesToAdd;
   HPByteType  hpbDataPtr;
   DwordType   dwSize;


   lpxPFData    = (LPPFDATA)lpxDataRec->lpLXDevice;
   bResolution  = lpxPFData->bResolution;

   switch (bResolution)
   {
   case 1 :
      wMultiplier = 1;
      break;
   case 2 :
   case 3 :
      wMultiplier = 2;
      break;
   case 4 :
   case 5 :
      wMultiplier = 4;
      break;
   default :
      wMultiplier = 1;
   }

   bSliceSize   = lpxPFData->bBytesPerSlice;

   wSliceCount  = lpxPFData->wSliceCount;

   swLeftPrtPos  = lpxPFData->swLeftPrintPos;

   swRightPrtPos = lpxPFData->swRightPrintPos;


   swSlicesToAdd = (SwordType)(300L*8*wMultiplier) - swRightPrtPos - 1;

   if (swSlicesToAdd <= 0)
   {
      /* don't change anything */
      return(0);
   }

   hpbDataPtr = (HPByteType)lpxPFData->lpxPrtCmd + SWATH_HEADER_SIZE +
                ((DwordType)(swRightPrtPos-swLeftPrtPos+1)*(DwordType)bSliceSize);

   for (m=0; m<swSlicesToAdd; m++)
   {
      for (n=0; n<(WordType)bSliceSize; n++)
      {
         *hpbDataPtr++ = 0x00;
      }
   }

   swRightPrtPos += (WordType)swSlicesToAdd;
   wSliceCount  += (WordType)swSlicesToAdd;

   lpxPFData->wSliceCount = wSliceCount;
   lpxPFData->swRightPrintPos = swRightPrtPos;

   dwSize = ((DwordType)wSliceCount*(DwordType)bSliceSize) +
            (DwordType)SWATH_HEADER_SIZE;

   return(dwSize);

}  /* end of ExpandSwathTo8Inches() */
