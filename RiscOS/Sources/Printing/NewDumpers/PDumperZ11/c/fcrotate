
/****************************************************************************
 * FcRotate.c                                      Lexmark Confidential
 *
 * $Revision$
 * $Date$
 * $Author$
 *
 *
 * Description:
 *    FCROTATE.C contains the function, Rotate(), which rotates the raster
 *    lines into swaths.  It also contains function SwathMargins() which
 *    determines the minimum width of each swath.  It all contains the
 *    functions which manage our independent shingling algorigthm.  They are
 *    PreSwathAdjust(), PostSwathAdjust(), HiResPreSwathAdjust(), and
 *    HiResPostSwathAdjust().
 *
 *
 * No.   Date     Who  Function              Description of Change
 * --------------------------------------------------------------------------
 * 016  12/02/98  wlc   Changes to support printing color swath unidirectional
 *      and Black swaths BIDI.  Added PFData->bPrintSwathOpposite.
 *
 * 017  12/03/98  wlc   Changes to several functions to support 25% shingling
 *      of High Resolution printing.  This is also known as 8 pass in comments.
 *      This mode is only supported for CMY data.  The color tables for Rome
 *      assures us that we only get CMY data for Glossy paper even when the
 *      number of color planes is 4.  More changes would be required to support
 *      printing true 8-pass CMYK in this mode.
 *
 * 018  12/14/98  wlc   Fix for bug 2573. Don't subtract wStartSlice from slice
 *      count for 1200 dpi that is 50% shingled.
 *
 * 019  12/14/98  bsp   Modiifed Rotate and GetRasterLineShingleMask to allow
 *      2 pass 300 dpi printing to take an effect instead of old 50% 600 dpi.
 *
 * 020  01/06/99  bsp   Fix for bug 2481, missing vertical movement when there
 *      is a swath but no dot is counted.
 *
 * 021  01/08/99  bsp   Fixed a problem of coarse print texture in new 600dpi.
 *      WStartSlice is subtracted from LeftPrintPos for CMY swath.
 *
 * 022  01/09/99 xzhan  Added codes in Rotate() and Swathmargin() to support
 *      the Palm black and color heads by using OAK_HEAD define.
 *
 * 023  01/13/99  bsp   Fixed a problem of coarse print texture in new 1200dpi.
 *      WStartSlice is subtracted from LeftPrintPos for CMY swath.
 *
 * 024  02/06/99  wlc   Fixed problem with 1200 dpi as 2 pass 600 for reversed
 *      swath building.  Corrected left and right print position calculations.
 *      Removed all Palm head code.  We are creating a new FCPALM.C to handle
 *      the rotate for the Palm head printers.  Minor code clean up.
 *
 * 025  02/08/99  pbs   Fixed print position for 2 pass 300 dpi mode.
 *
 * 026  02/10/99  wlc   Moved 1200 dpi correction for reversed built swath
 *      so it only gets done once per swath.
 * 027  02/20/99  bsp   Wrong placement of dots in 6 planes corrected.
 * 028  03/09/99  wlc   Fix problem with OPTION_CDE to add wStartSlice.
 ***************************************************************************/

/************** Definitions & Macros **************************************/

#if !defined(NOPRAGMA)
//#pragma warning (disable: 4103)  /* used #pragma pack to change alignment */
#endif

/************** Include Files *********************************************/

#if defined(DOS_BUILD) || defined(FC_DOS_32)
#include <stdio.h>
#endif

#if !defined(FC_WIN_32) && !defined(FC_OS2)
//#include <memory.h>
#endif
#include <stdlib.h>

#include "fclocal.h"

/************** Global Variable Declarations *********************************/

/* set object module level ID */
static char fc_version[] = "fcrotate.obj: "FC_VERSION;


/***************************************************************************
 * Function Name:    Rotate
 *
 * Description:
 *    This is the function that rotates raster lines into a print swath.
 *    It rotates the appropriate raster lines into the print swath.  It also
 *    applies the shingling mask, if one is required.  After creating the
 *    print swath, several pieces of information are added to the 26 byte
 *    print swath header, such as slice count, left margin, and right
 *    margin.
 *
 * Inputs:  lpxDataRec   Far pointer to HBP interface structure.
 *          swBuffers    Tells which buffers to use when building the print
 *                       swath, ie CMY, K, KCM.
 *
 * Outputs: SwordType  number of lines moved down the page.  Positive number
 *                     indicates there is a swath which needs to be printed.
 *                     Negative number means the swath is empty, so move the
 *                     page by SwordType amount but don't print a swath.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 *************************************************************************/
SwordType Rotate(LPDVDATAREC lpxDataRec, SwordType swBuffers, SdwordType sdwRow)
{
   LPPFDATA    lpxPFData;

   LPWordType  lpwSwathWord;

   LPWordType  lpwRaster,
               lpwRastMask,
               lpwRM,
               lpwRMStart,
               lpwRMEnd;

   WordType    i, k,
               wIEnd=0,
               wIndx,
               wIStart=0,
               wKKInc,
               wLeftMargin,
               wNozzleCount=0,
               wPrintMaskWord,
               wRasterWord,
               wRowsToPrint,
               wSeg,
               wShingle=0,
               wSliceCount,
               wSliceWord,
               wSwathScanEnd,
               wSwathScanStart,
               wSwathSeg,
               wSWInc,
               wBitsToProcess,              /* added for 1200 to 2 pass 600 */
               wStartSlice;                 /* added for 1200 to 2 pass 600 */

   SwordType   j,
               swJEnd,
               swJStart,
               swKCMOffset,
               swNozzle,
               swNozzleGap=0,
               swNozzleOffset,
               swOut,
               swRastRes,
               swRowsMoved,
               swScanIndex,
               swShingle16=0,
               swShingle25=0,
               swShingle33=0,
               swShingle50=0,
               swSwathRes,
               swSwathScanEnd=0,
               swSwathScanStart=299,
               swVertAdj=0,
               swVertRes;

   SdwordType  r,
               sdwBufSize,
               sdwInIndex,
               sdwOutIndex,
               sdwRowStart;

   DwordType   kk,
               dwColorOffset,
               dwSwathByteOffset,
               dwSwathOffset,
               dwSwathWordOffset;

   SdwordType  asdwDotCount[6] = {0,0,0,0,0,0},
               sdwSwathDotCount=0;

   LPByteType  pbPrtDat;

   ByteType    bBytesPerSlice,
               bColorPlanes,
               bDropsPerPixel,
               bResolution,
               bSwathDir;

   BoolType    fEmptySwath=TRUE,
               fShingled=TRUE;

#if OPTION_CDE
   BoolType    fCDE;
   WordType    wCDEBoundary;
#endif

#if OPTION_MULTIBITS_PER_PIXEL
   LPWordType  lpwRaster2 = NULL;
   WordType    wShingle2 = 0,
               wRasterWord2;
   BoolType    fShingled2 = FALSE;
#endif

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

#if CPROF
   PrfEnter(7);
#endif

#if OPTION_CDE
   fCDE              = lpxPFData->fCDE;
#endif

   /* initialize local variables */
   bColorPlanes      = lpxPFData->bColorPlanes;
   bResolution       = lpxPFData->bResolution;
   lpwRastMask       = lpxPFData->lpwRastMask;
   swVertRes         = lpxPFData->swVertResMult;
   swRastRes         = lpxPFData->swRastResMult;
   swSwathRes        = lpxPFData->swSwathResMult;
   wLeftMargin       = lpxPFData->wLeftMargin;
   wSliceCount       = 0;
   swSwathScanStart  = lpxPFData->swPreRotateStart;
   swSwathScanEnd    = lpxPFData->swPreRotateEnd;
   wSwathScanStart   = (WordType)lpxPFData->swPreRotateStart/2;
   wSwathScanEnd     = (WordType)(lpxPFData->swPreRotateEnd+1)/2;
   swRowsMoved       = (SwordType) lpxPFData->wRowsToMove;
   lpxPFData->sdwSwathDotCount = 0;

   /* Set print direction flags to OFF to support printing in opposite
      direction of last swath.  This was added to support the Birch print head.
      These flags will get updated in GetPrintDir() when the swath needs to
      be printed in opposite direction of last swath.  These flags can only be
      equal to 1 when the call to GetPrintDir() returns BIDI for the print
      direction. */
   lpxPFData->bPrintCMYOpposite   = 0;
   lpxPFData->bPrintBLKOpposite   = 0;
   lpxPFData->bPrintSwathOpposite = 0;

   /* Initialize variables to rotate every bit in raster line to slice and    */
   /* start with slice 0.  These are changed below for 1200 dpi 50% shingled  */
   /* that will be printed as 2 pass 600 dpi.                                 */
   wBitsToProcess = 1;            /* rotate every bit in raster line to slice */
   wStartSlice = 0;               /* make sure we start with first slice      */

   swOut = lpxPFData->swOut;
   if (swOut == FC_OUT_EVEN)
   {
      swRowsMoved -= 3;
   }
   else if (swOut == FC_OUT_ODD)
   {
      swRowsMoved += 3;
   }

#if OPTION_1200_AS_2X600
   /* Added the following for 1200 to 2 pass 600 printing */
   /* See if this is a 1200 dpi swath that is shingled at 50%.  If so we can
      print it as 2 pass 600 dpi swath, so set a flag for checking later.    */
   if ( (lpxPFData->bResolution == HIRES_INTERLACED) &&
        ( (swBuffers == CMYPLANES) || (swBuffers == KCMPLANES) ||
          ( (swBuffers == KPLANE) && (bColorPlanes != 4) ) ) )
   {
      /* Set flag to print 1200 dpi as 2 pass 600 dpi */
      lpxPFData->bShingleHiRes = SHINGLE_50;

      /*Rotate only every other bit in raster to slice */
      wBitsToProcess = 2;

      /* Adjust the swath resolution from 1200 dpi to 600 dpi */
      swSwathRes /= 2;

      /* Get the starting slice (0 or 1). This value is initialized at the
         start of each page in FCStartPage() and alternates for each swath.
         Process all even or odd slices for this swath.  Update the starting
         slice for next even raster line swath  */
      wStartSlice = GetHiResStartSlice(lpxPFData, swOut, swBuffers);
   }
   else
   {  /* Not 1200 dpi or 1200 dpi that is not shingled at 50% */
      lpxPFData->bShingleHiRes = NO_SHINGLE;
   }
#else
   /* Don't print 1200 dpi 50% shingled as 2 pass 600 dpi */
   lpxPFData->bShingleHiRes = NO_SHINGLE;
#endif

#if OPTION_600_AS_2X300
   /*  Below if statement was put in to turn off OPTION_600_AS_2X300 for K */
   /*  in a CMYK job shingled at 50%                                       */
   if ( (lpxPFData->bResolution == LORES) &&
        (lpxPFData->bShingle == SHINGLE_50) &&
        ( (swBuffers == CMYPLANES) || (swBuffers == KCMPLANES) ||
          ( (swBuffers == KPLANE) && (bColorPlanes != 4) ) ) )
   {
      lpxPFData->bShingleLoRes = SHINGLE_50;
      wBitsToProcess = 2; /*Rotate only every other bit in raster to slice    */
      swSwathRes /= 2;    /* Nozzle offset adjustment is also required as well.*/

      /*  fCMYSwathBuild = 1: CMY swath is built, 0: K or KCM swath is built   */
      if (swBuffers == CMYPLANES)
      {
         lpxPFData->fCMYSwathBuild = TRUE;
      }
      else
      {
         lpxPFData->fCMYSwathBuild = FALSE;
      }
   }
   else
   {
      lpxPFData->bShingleLoRes = NO_SHINGLE;
   }
#else
   /* Don't print 600 dpi 50% shingled as 2 pass 300 dpi */
   lpxPFData->bShingleLoRes = NO_SHINGLE;
#endif

   switch (swBuffers)
   {
   case CMYPLANES :
      lpxPFData->bPrintHead     = COL_CARTRIDGE;
      wSliceCount            += (WordType)(MAGENTA_OFFSET*swSwathRes);
      wSliceCount            += (WordType)(COLOR_NOZZLE_OFFSET*swSwathRes);
      wIStart                 = 0;
      wIEnd                   = 3;
      lpxPFData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
      wNozzleCount            = (WordType) lpxPFData->swColorNozzleCount;
      swNozzleGap             = COLOR_NOZZLE_OFFSET;
      swVertAdj               = 0;
      break;

   case KCMPLANES :
      if (wLeftMargin)
      {
         wLeftMargin         -= (WordType)(KCM_HORZ_OFFSET*swSwathRes);
      }
      lpxPFData->bPrintHead     = KCM_CARTRIDGE;
      wSliceCount            += (WordType)(MAGENTA_OFFSET*swSwathRes);
      wSliceCount            += (WordType)(COLOR_NOZZLE_OFFSET*swSwathRes);
      wIStart                 = 3;
      wIEnd                   = 6;
      lpxPFData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
      wNozzleCount            = (WordType) lpxPFData->swColorNozzleCount;
      swNozzleGap             = COLOR_NOZZLE_OFFSET;
      swVertAdj               = 0;
      break;

   case KPLANE:
      if (bColorPlanes == 4)
      {
         /* CMYK print job */
         lpxPFData->bBytesPerSlice  = CMY_BYTES_PER_SLICE;
         swVertAdj                  = (SwordType) lpxDataRec->bVerticalAdj;
         wIStart                    = 3;
         wIEnd                      = 4;
      }
      else
      {
         /* K print job */
         wIStart = 0;
         wIEnd   = 1;
         if ( (bResolution == HIRES_INTERLACED) ||
              (lpxPFData->bResolution == HIRES_NONINTERLACED) )
         {
            lpxPFData->bBytesPerSlice = CMY_BYTES_PER_SLICE;
            swVertAdj               = (SwordType) lpxDataRec->bVerticalAdj;
         }
         else
         {
            lpxPFData->bBytesPerSlice = K_BYTES_PER_SLICE;
            swVertAdj               = 0;
         }
      }
      lpxPFData->bPrintHead  = MONO_CARTRIDGE;
      wSliceCount         += (WordType)(MONO_NOZZLE_OFFSET*swSwathRes);
      wNozzleCount         = (WordType) lpxPFData->swMonoNozzleCount;
      swNozzleGap          = MONO_NOZZLE_OFFSET;
      break;
   }  /* end of switch(nBuffers) */

   /* Set for product.C file use */
   lpxPFData->bPrintDirection = GetPrintDir(lpxDataRec, swBuffers);

   /* set as locals */
   bBytesPerSlice             = lpxPFData->bBytesPerSlice;
   swSwathScanStart           = SliceSkip(swSwathScanStart,swSwathRes);
   swSwathScanEnd             = SliceSkip(swSwathScanEnd,swSwathRes);
   lpxPFData->swLeftPrintPos  = RastertoPrintPos(swSwathScanStart,
                                (SwordType)wLeftMargin);

   if ( lpxPFData->bShingleHiRes == SHINGLE_50 )
   {  /* Print 1200dpi 50% shingled as 2 swaths(even or odd slices) at 600dpi.*/
      /* Adjust left and right print position for even or odd slice pass in   */
      /* 1200 dpi.                                                            */
      lpxPFData->swLeftPrintPos  += wStartSlice;

      /* left and right print position are calculated in 1200 dpi.  */
      wSliceCount *= 2;  /* convert nozzle gap to 1200 dpi */
      wSliceCount += (WordType)(swSwathScanEnd - swSwathScanStart)*8;

      /* Calculate right print position. The (wSliceCount -1) added
         to the left print position gives the  horiz coordinate of the
         rightmost slice.  The other -1 is done because the actual
         slice count is one less than the total number of slices.
         It's one less on right when we print the even slices and one
         less on the left when we print the odd slices. */
      lpxPFData->swRightPrintPos = lpxPFData->swLeftPrintPos +
                                   (wSliceCount - 1 ) - 1;

      /* only half as many slices at 600 as we have at 1200 */
      wSliceCount = wSliceCount/2;
   }
   else
   {

#if OPTION_600_AS_2X300
      /* In new 600 dpi, only a half of the usual number of slices are built.  */
      if (lpxPFData->bShingleLoRes == SHINGLE_50)
      {
        /* Printing direction dependent */
        /* Odd swath needs movement of 1/600 to right or left before printing. */
         if ( lpxPFData->fCMYSwathBuild )
         { /* Keep in mind that CMY swath is built forward like KCM swath in 6 colors */
           /* For CMY swath */
            if (lpxPFData->wCMYSwathByPgCtr % 2)
            {  /* Odd Swath */
               wStartSlice = 1;
            }
            else
            {  /* Even Swath */
               lpxPFData->swLeftPrintPos ++;
            }
         }
         else
         {  /* For K or KCM swath */
            if (lpxPFData->wKOrKcmSwathByPgCtr % 2)
            {  /* Odd Swath */
               wStartSlice = 1;
               lpxPFData->swLeftPrintPos ++;
            }
         }
         wSliceCount += (WordType)((swSwathScanEnd - swSwathScanStart) * 8 / 2);
         lpxPFData->swRightPrintPos = lpxPFData->swLeftPrintPos +
                                  (SwordType)((wSliceCount - (SwordType)1) * 2);
      }
      else
      {
         wSliceCount += (WordType)((swSwathScanEnd - swSwathScanStart)*8);
         lpxPFData->swRightPrintPos = lpxPFData->swLeftPrintPos +
                                    (SwordType)wSliceCount - (SwordType)1;
      }
#else

      wSliceCount += (WordType)((swSwathScanEnd - swSwathScanStart)*8);
      lpxPFData->swRightPrintPos = lpxPFData->swLeftPrintPos +
                                   (SwordType)wSliceCount - (SwordType)1;
#endif
   }

   /* clear print swath */
   ClearPrintSwath(lpxPFData);

   /* get swath direction and update raster masks for REVERSE_SWATH */
   bSwathDir = UpdateRasterMask(lpxDataRec);

#if OPTION_REVERSE_SWATH
   if (bSwathDir == REVERSE)
   {
      /* Added the following for 1200 to 2 pass 600 printing*/
      if ( lpxPFData->bShingleHiRes == SHINGLE_50 )
      {
         /* Correct left and right print position for building swath
            from right to left.  In this case the odd slice swath
            is built first when wStartSlice is zero and the even slice
            swath is built last when wStartSlice is one.               */

         if (wStartSlice == 1)
         {
            /* using odd numbered slices so subtract one */
            lpxPFData->swLeftPrintPos--;
            lpxPFData->swRightPrintPos--;
         }
         else
         {
            /* using even numbered slices so add one */
            lpxPFData->swLeftPrintPos++;
            lpxPFData->swRightPrintPos++;
         }

      }
   }
#endif

   for (i=wIStart; i<wIEnd; i++)
   {  /* Once for each plane of color */
      sdwOutIndex    = lpxPFData->asdwDBIndx[swOut][i];
      sdwInIndex     = lpxPFData->asdwDBIndx[FC_IN][i];
      sdwBufSize     = lpxPFData->asdwDBIndx[BUFSIZE][i];
      wRowsToPrint   = lpxPFData->awRowsToPrint[i];
      bDropsPerPixel = (ByteType)lpxPFData->asdwDBIndx[DROPS_PER_PIXEL][i];

      /* sdwRowStart is the topmost row (raster line) in this color plane  */
      /* for this swath.  Topmost means the smallest raster line number or */
      /* the row closet to the top of the printed page.                    */
      if (lpxPFData->bResolution == HIRES_INTERLACED)
      {
         sdwRowStart = (sdwRow - (SdwordType)(wNozzleCount*swVertRes) + 1);
         if (sdwRowStart < lpxPFData->asdwFirstRowOfSection[swOut][i])
         {
            sdwRowStart = lpxPFData->asdwFirstRowOfSection[swOut][i];
         }
         sdwRowStart   -= (SdwordType)(lpxPFData->asdwDBIndx[INIT_DELAY][i] *
                          swVertRes);
         sdwRowStart    = sdwRowStart % (SdwordType)lpxPFData->swMaxDelayBuf;
      }
      else
      {
         sdwRowStart    = (lpxPFData->sdwBottomNozzleRowNum - (wRowsToPrint  *
                          swVertRes) - (lpxPFData->asdwDBIndx[INIT_DELAY][i] *
                          swVertRes) + 1);
      }

      swJStart   = ((SwordType)wNozzleCount*swVertRes) -
                   (SwordType)wRowsToPrint;
      swJEnd     = (SwordType)wNozzleCount * swVertRes;

      for (j=swJStart, r=sdwRowStart; j < swJEnd; j++, r++)
      {  /* Once for each raster line in the color plane */
         if (sdwOutIndex == sdwInIndex)
         {
            break;
         }

         swNozzle = j/swVertRes;
         fShingled = TRUE;
         swScanIndex = (SwordType)(r%lpxPFData->swMaxDelayBuf);

         if (((swOut == FC_OUT_EVEN) && (sdwOutIndex % 2))   ||
             ((swOut == FC_OUT_ODD) && (!(sdwOutIndex % 2))) ||
             (sdwOutIndex < 0)                              ||
             ((swSwathScanEnd - swSwathScanStart) <= 0 )    ||
             (lpxPFData->alpbShingleToApply[i][swScanIndex] == SHINGLE_THRU) )
         {
            if (lpxPFData->bResolution == HIRES_INTERLACED)
            {
               sdwOutIndex = (SdwordType)((sdwOutIndex + 1) %
                             lpxPFData->asdwDBIndx[BUFSIZE][i]);
            }
            else
            {
               sdwOutIndex++;
            }
            continue;
         }

#if OPTION_CDE
         wCDEBoundary = FALSE;
#endif

         wShingle = GetRasterLineShingleMask(lpxDataRec,i,swScanIndex,wStartSlice);

         if (wShingle == 0xFFFF )
         {  /* not shingled */
            fShingled = FALSE;
         }
         else
         {  /* shingled */
            fShingled = TRUE;
         }

#if OPTION_MULTIBITS_PER_PIXEL
         if (bDropsPerPixel == 2)
         {  /* Set the shingle level for the second CMY plane */

            wShingle2 = GetRasterLineShingleMask2(lpxDataRec, i, swScanIndex);

            if (wShingle2 == 0xFFFF )
            {  /* not shingled */
               fShingled2 = FALSE;
            }
            else
            {  /* shingled */
               fShingled2 = TRUE;
            }

         }
#endif
         wPrintMaskWord = lpxPFData->lpwPrtMask[(swNozzle % 16)];

         if (swBuffers == KPLANE &&
             bColorPlanes == 1 &&
             (!((bResolution == HIRES_INTERLACED) ||
                (lpxPFData->bResolution == HIRES_NONINTERLACED)) ))
         {
            wSliceWord     = Mono7SliceWord(i, wIStart,
                             wIEnd, (WordType)swNozzle);
            wPrintMaskWord  = lpxPFData->lpwPrtMask[(swNozzle % 16) +
                              OddByteMaskAdjust(swNozzle)];
         }
         else if (swBuffers == KPLANE)
         {
            wSliceWord     = Mono6SliceWord(i, wIStart,
                             wIEnd, (WordType)swNozzle);
         }
         else
         {
			   wSliceWord     = SliceWord(i, wIStart, wIEnd, swNozzle);
	      }

         /* For KPLANE, no ColorOffset */
         if(swBuffers == KPLANE)
         {
         	dwColorOffset=0;
         }
         else
         {
         	dwColorOffset  = COLOR_OFFSET(bColorPlanes, bSwathDir, i, MAGENTA_OFFSET, swSwathRes);
         }
         swNozzleOffset = NozzleOffset(swVertAdj, swNozzle, swNozzleGap,
                          bBytesPerSlice, swSwathRes);
         if (swBuffers == KCMPLANES)
         {
            swKCMOffset = KCMOffset(swNozzle, swSwathRes);
         }
         else
         {
            swKCMOffset = 0;
         }

         /* this code section gets a pointer to the raster line color      */
         /* plane we are currently working on.                             */
         if (lpxPFData->bResolution == HIRES_INTERLACED)
         {
            wSeg  = i + (WordType)(sdwOutIndex / lpxPFData->wRastersPerSeg *
                     bColorPlanes) + (WordType)((lpxPFData->asdwDBIndx[
                     DROPS_PER_PIXEL][i]-1) * DROP_SEC_SIZE);
            wIndx = (WordType)(sdwOutIndex % lpxPFData->wRastersPerSeg);
         }
         else
         {
            wSeg  = i + ( (WordType)(sdwOutIndex % lpxPFData->asdwDBIndx[
                     BUFSIZE][i]) / lpxPFData->wRastersPerSeg *
                     (WordType)bColorPlanes);
            wIndx = ( (WordType)(sdwOutIndex % lpxPFData->asdwDBIndx[
                     BUFSIZE][i]) % lpxPFData->wRastersPerSeg);
         }

         lpwRaster = lpxPFData->alpwPlane[wSeg] + (wIndx *
                     lpxPFData->wWordsPerRow);
         /* end of code section to get pointer to raster line color plane  */

#if OPTION_MULTIBITS_PER_PIXEL
         if (bDropsPerPixel == 2)
         {  /* get pointer to second plane of this color's data   */
            wSeg      = i + ( (WordType)(sdwOutIndex % lpxPFData->asdwDBIndx[
                         BUFSIZE][i]) / lpxPFData->wRastersPerSeg *
                         (WordType)bColorPlanes) + (WordType)DROP_SEC_SIZE;
            wIndx     = ( (WordType)(sdwOutIndex % lpxPFData->asdwDBIndx[
                         BUFSIZE][i]) % lpxPFData->wRastersPerSeg);
            lpwRaster2 = lpxPFData->alpwPlane[wSeg] + (wIndx *
                         lpxPFData->wWordsPerRow);
         }  /* end of getting pointer to second plane of this color's data   */
#endif


#if OPTION_REVERSE_SWATH
         if (bSwathDir == REVERSE)
         {
             /* If need to build print swath backwards then reverse the    */
             /* words in the raster.  Reversing the bits within each word  */
             /* is performed by switching the raster masks above           */

            swNozzleOffset = ReverseNozzleOffset(swVertAdj, swNozzle,
                             swNozzleGap, bBytesPerSlice,swSwathRes);

            for (k=wSwathScanStart; k<wSwathScanEnd; k++)
            {
               *(lpxPFData->lpwReverseRaster + k) = *(lpwRaster+(wSwathScanStart +
                                                  wSwathScanEnd-k-1));
            }

            lpwRaster = lpxPFData->lpwReverseRaster;
         }
#endif

         wKKInc = (WordType)bBytesPerSlice * (WordType)8;

#if OPTION_600_AS_2X300
         /* wKKInc traditionally brings the pointer to the swathword location which has    */
         /* an offset of 16X24 from the previous swathword location after a rasterword is  */
         /* completely processed. However, in the new 600 the offset is 8X24.              */
         /* Thus,synchronize the rest of pointer movements as well.                        */
         if (lpxPFData->bShingleLoRes == SHINGLE_50)
         {
            wKKInc /= 2;
         }
#endif
         if ( lpxPFData->bShingleHiRes == SHINGLE_50 )
         {  /* Change swath offset pointer from 1200dpi to 600dpi */
            wKKInc /= 2;
         }

         kk = 0;
         for (k = wSwathScanStart; k < wSwathScanEnd; k++)
         {  /* Once for each word in the raster line */
            wRasterWord  = *(lpwRaster + k);

            if (fShingled == TRUE)
            {  /* apply the raster line shingle mask to this word */
               wRasterWord &= wShingle;
            }

#if OPTION_MULTIBITS_PER_PIXEL
            if (bDropsPerPixel == 2)
            {
               wRasterWord2 = *(lpwRaster2 + k);
               if (wRasterWord2)
               {
                  if (fShingled2 == TRUE )
                  {
                     wRasterWord |= (wRasterWord2 & wShingle2);
                  }
                  else
                  {  /* Use 100% shingle mode for second plane */
                     wRasterWord |= wRasterWord2;
                  }
               }
            }
#endif

            if (wRasterWord)
            {  /* there is print data in this word */
               if (swBuffers == KPLANE &&
                   bColorPlanes == 1 &&
                   (!((bResolution == HIRES_INTERLACED) ||
                   (bResolution == HIRES_NONINTERLACED))))
               {
                  dwSwathWordOffset = (DwordType)(SliceSkip(kk, swSwathRes) +
                                      dwColorOffset + swNozzleOffset         +
                                      swKCMOffset);

                  dwSwathByteOffset = (DwordType)dwSwathWordOffset * 2 +
                                      wSliceWord;
               }
               else
               {
                    dwSwathWordOffset = (DwordType)(SliceSkip(kk, swSwathRes) +
                                       wSliceWord + dwColorOffset             +
                                       swNozzleOffset + swKCMOffset);
                    dwSwathByteOffset = (DwordType)dwSwathWordOffset * 2;
               }
               wSwathSeg = (WordType)((DwordType)dwSwathByteOffset /
                           ((DwordType)SLICES_PER_SEG *
                           (DwordType)bBytesPerSlice));

               dwSwathOffset = (DwordType)((DwordType)dwSwathByteOffset %
                              ((DwordType)SLICES_PER_SEG *
                              (DwordType)bBytesPerSlice));

               pbPrtDat       = (LPByteType)lpxPFData->alpbSwath[wSwathSeg];
               pbPrtDat      += dwSwathOffset;

               lpwSwathWord   = (LPWordType) pbPrtDat;
               lpwRMEnd       = lpwRastMask + 16;
               wSWInc         = SliceSkip(bBytesPerSlice, swSwathRes);


#if OPTION_CDE
               if (wCDEBoundary)
               {  /* last bit of prior word was rotated, start with 2nd bit */
                  lpwRMStart = lpwRastMask + 1;
                  lpwSwathWord = (LPWordType) ((LPByteType)lpwSwathWord + wSWInc);
               }
               else
               {
                  lpwRMStart = lpwRastMask + wStartSlice;
               }
#else
               /* wStartSlice added to support printing 1200dpi as 2 pass 600dpi */
               lpwRMStart = lpwRastMask + wStartSlice;
#endif

               /* wBitsToProcess added to support printing 1200dpi as 2 pass 600dpi */
               for (lpwRM = lpwRMStart; lpwRM < lpwRMEnd; lpwRM += wBitsToProcess)
               {  /* Once for each bit in the word */
                  if (wRasterWord & *lpwRM)
                  {  /* bit to be rotated */
					      *(lpwSwathWord) |= wPrintMaskWord; /* adding a mask bit to swathword */
                     asdwDotCount[i]++;
#if OPTION_CDE
                     if (fCDE)
                     {
                        lpwSwathWord = (LPWordType) ((LPByteType)lpwSwathWord + wSWInc);

                        /* set boundary switch if last bit rotated */
                        wCDEBoundary = (*lpwRM & lpxPFData->lpwRastMask[15]);
                        lpwRM++; /* increment past next bit */
                     }
#endif
                  }
                  lpwSwathWord = (LPWordType)       /* picking up the next swathword */
                              ((LPByteType)lpwSwathWord + wSWInc);
               }  /* Once for each bit in the word */
            }  /* end of data in this word */
            kk += wKKInc;
         }  /* Once for each word in the raster line */

         if (lpxPFData->bResolution == HIRES_INTERLACED)
         {
            sdwOutIndex = ((sdwOutIndex + 1) % lpxPFData->asdwDBIndx[BUFSIZE][i]);
         }
         else
         {
            sdwOutIndex++;
         }

      }  /* Once for each raster line in the color plane */
   }  /* Once for each plane of color */

   for (i=wIStart; i<wIEnd; i++)
   {
      /* check to see if any dots were added to print swath */
      if (asdwDotCount[i] != 0)
      {
         fEmptySwath = FALSE;
         lpxPFData->asdwDotCount[i] += asdwDotCount[i];
         sdwSwathDotCount += asdwDotCount[i];
      }

   }

#if OPTION_600_AS_2X300
   /* wCMYSwathByPgCtr and wKOrKcmSwathByPgCtr are # of swaths in a page  */
   if (lpxPFData->bShingleLoRes == SHINGLE_50)
   {
      if ( lpxPFData->fCMYSwathBuild )
      {
         lpxPFData->wCMYSwathByPgCtr++;
      }
      else
      {
         lpxPFData->wKOrKcmSwathByPgCtr++;
      }
   }
#endif

   lpxPFData->wSliceCount = wSliceCount; /* restore global */

   lpxPFData->sdwSwathDotCount = sdwSwathDotCount;

#if CPROF
      PrfExit(7);
#endif


   if (fEmptySwath || ((swSwathScanEnd - swSwathScanStart) <= 0 ))
   {
      /* Added the following to handle printing in opposite direction  */
      /* of last swath for either the CMY or Black head.               */
      /* Need to do this even for blank swaths to keep in sync.        */
      if (lpxPFData->bPrintCMYOpposite )
      {  /* update the bidi print direction even for empty swath */
         if (lpxPFData->bNextCMYPrintDir == LTOR)
         {
             lpxPFData->bNextCMYPrintDir = RTOL;
         }
         else
         {
            lpxPFData->bNextCMYPrintDir = LTOR;
         }
      }
      /* See if we need to print BLK in opposite direction of last BLK */
      else if (lpxPFData->bPrintBLKOpposite)
      {
         if (lpxPFData->bNextBLKPrintDir == LTOR)
         {
             lpxPFData->bNextBLKPrintDir = RTOL;
         }
         else
         {
            lpxPFData->bNextBLKPrintDir = LTOR;
         }
      }
      return(0); /* empty swath */
   }

   return(1);

}  /* end of Rotate() */


/***************************************************************************
 * Function Name:    SwathMargins
 *
 * Description:
 *    Determines the narrowest margins possible for the current print
 *    swath.  Considers the left and right margins for each raster line
 *    that will be used to help create the current print swath.
 *
 * Inputs:  lpxDataRec     Far pointer to HBP interface structure.
 *          sdwRow         helps synchronize the delay buffers with the
 *                         margins buffer.
 *
 * Outputs: stores swath left margin in lpxPFData->swPreRotateStart.  Stores
 *          swath right margin in lpxPFData->swPreRotateEnd.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/


void SwathMargins(LPDVDATAREC lpxDataRec, SwordType swBuffers,
                  SdwordType sdwRow)
{
   LPPFDATA       lpxPFData;
   WordType       i,
                  wIEnd,
                  wIStart,
                  wNozzleCount,
                  wRowsToPrint,
                  wVertRes;
   SwordType      swOut,
                  swScanIndex,
                  swSwathScanEnd,
                  swSwathScanStart;
   SdwordType     j, k,
                  sdwBufStart,
                  sdwKEnd,
                  sdwRowStart;

#if CPROF
PrfEnter(6);
#endif

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   lpxPFData->swPreRotateStart = lpxPFData->wBytesPerRow-(SwordType)1;
   lpxPFData->swPreRotateEnd = 0;
   swSwathScanStart=lpxPFData->wBytesPerRow;
   swSwathScanEnd=0;

   switch (swBuffers)
   {
   case CMYPLANES :
      wIStart = 0;
      wIEnd   = 3;
      lpxPFData->bPreRotatePrintHead = COL_CARTRIDGE;
      break;
   case KCMPLANES :
      wIStart = 3;
      wIEnd   = 6;
      lpxPFData->bPreRotatePrintHead = MONO_CARTRIDGE;
      break;
   case KPLANE:
      if (lpxPFData->bColorPlanes == 4)
      {
         /* CMYK print job */
         wIStart = 3;
         wIEnd   = 4;
      }
      else
      {
         /* K print job */
         wIStart = 0;
         wIEnd   = 1;
      }
      lpxPFData->bPreRotatePrintHead = MONO_CARTRIDGE;
      break;
   default :
#if CPROF
   PrfExit(6);
#endif
      return;
   }

   /* This line is used for host logic seek printers */
   lpxPFData->bPreRotateDir = GetPrintDir(lpxDataRec, swBuffers);

   wVertRes = (WordType)lpxPFData->swVertResMult;
   swOut    = lpxPFData->swOut;

   /* For the raster lines involved in this print swath, determine the     */
   /* smallest left margin (ScanStart) and the largest right margin        */
   /* (ScanEnd).  These will determine the size and horizontal position    */
   /* of the print swath created.                                          */
   for (i=wIStart; i<wIEnd; i++)
   {
      wNozzleCount = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[i];
      wRowsToPrint = lpxPFData->awRowsToPrint[i];

      if (lpxPFData->bResolution == HIRES_INTERLACED)
      {
         sdwRowStart = (sdwRow - (SdwordType)(wNozzleCount*wVertRes) + 1);
         if (sdwRowStart < lpxPFData->asdwFirstRowOfSection[swOut][i])
         {
            sdwRowStart = lpxPFData->asdwFirstRowOfSection[swOut][i];
         }
         sdwRowStart   -= (SdwordType)
                          (lpxPFData->asdwDBIndx[INIT_DELAY][i]*wVertRes);
      }
      else
      {
         sdwRowStart = (lpxPFData->sdwBottomNozzleRowNum -
                       (wRowsToPrint * wVertRes)       -
                       (lpxPFData->asdwDBIndx[INIT_DELAY][i]*wVertRes) + 1);
      }

      if ( (sdwRowStart > lpxPFData->sdwRowPos) ||
           (lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i]) )
      {
         continue;
      }

      if (lpxPFData->bResolution == HIRES_INTERLACED)
      {
         sdwRowStart = sdwRowStart % (SdwordType)lpxPFData->swMaxDelayBuf;
         sdwKEnd = sdwRowStart+(SdwordType)(wNozzleCount*wVertRes);
      }
      else
      {
         sdwKEnd = sdwRowStart + wRowsToPrint;
      }
      sdwBufStart = lpxPFData->asdwDBIndx[swOut][i];

      for (k=sdwRowStart, j=sdwBufStart; k<sdwKEnd; k++, j++)
      {
         if (k > lpxPFData->sdwRowPos)
         {
            break;
         }
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) &&
           ((j % lpxPFData->asdwDBIndx[BUFSIZE][i]) ==
           lpxPFData->asdwDBIndx[FC_IN][i]) )
         {
            break;
         }
         if ( (j<0) || (k < 0))
         {
            continue;
         }
         if ((swOut == FC_OUT_EVEN) && (j%2))
         {
            continue;
         }
         if ((swOut == FC_OUT_ODD) && (!(j%2)))
         {
            continue;
         }

         swScanIndex = (SwordType)(k%lpxPFData->swMaxDelayBuf);

         if (lpxPFData->alpswScanStart[i][swScanIndex] < swSwathScanStart)
         {
            swSwathScanStart = lpxPFData->alpswScanStart[i][swScanIndex];
         }
         if (lpxPFData->alpswScanEnd[i][swScanIndex] > swSwathScanEnd)
         {
            swSwathScanEnd = lpxPFData->alpswScanEnd[i][swScanIndex];
         }
      }  /* end of for (k=sdwRowStart, j=sdwBufStart; k<sdwKEnd; k++, j++) */
   }  /* end of for (i=wIStart; i<wIEnd; i++) */

   lpxPFData->swPreRotateStart = swSwathScanStart;
   lpxPFData->swPreRotateEnd   = swSwathScanEnd;

#if CPROF
   PrfExit(6);
#endif

   return;

}  /* end of SwathMargins() */




/***************************************************************************
 * Function Name:    PreSwathAdjust
 *
 * Description:
 *    Determines which color planes must be printed now.
 *
 * Inputs:  lpxDataRec     Far pointer to HBP interface structure.
 *          sdwRow         bottom raster line read in.
 *
 * Outputs: returns vertical move amount, in raster lines, required before
 *          printing this swath.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/
SwordType PreSwathAdjust(LPDVDATAREC lpxDataRec, SdwordType sdwRow)
{
   LPPFDATA       lpxPFData;
   WordType       awNozzleStart[MAXNUMPLANES],
                  awVerticalMove[MAXNUMPLANES],
                  wBaseNozzleCount,
                  wMoveAmount,
                  wNozzle,
                  wNozzleCount,
                  wNozzleStart=0,
                  wVerticalMove;
   SwordType      i,
                  swOut,
                  swScanIndex,
                  swShingleThreshold,
                  swVertRes;
   SdwordType     k,
                  sdwBottomRow,
                  sdwOldBottomRow,
                  sdwTopRow;
   ByteType       bSI=0;
   BoolType       fMustPrintColor[6] = {FALSE,FALSE,FALSE,FALSE,FALSE,FALSE},
                  fMustPrintHead[2]  = {FALSE,FALSE},
                  fNoLinesToProcess=TRUE,
                  fRowsToPrint = FALSE;

#if CPROF
   PrfEnter(5);
#endif

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;


   swVertRes     = lpxPFData->swVertResMult;
   swOut         = lpxPFData->swOut;
   wMoveAmount   = lpxPFData->wBaseNozzleCount;
   wVerticalMove = lpxPFData->wBaseNozzleCount;

   /* The following for() loop determines the number of nozzles to use in  */
   /* this swath (or these swaths).  In other words, determine             */
   /* wNozzleStart for the entire swath(s) by looking at wNozzleStart for  */
   /* each color plane.  Notice that as we go from one color plane to the  */
   /* next, wNozzleStart can become larger (meaning the swath will use     */
   /* fewer nozzles), but it will not get smaller because the previous     */
   /* color planes have already established a maximum nozzle               */
   for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++)
   {

      wBaseNozzleCount = lpxPFData->wBaseNozzleCount;
      wNozzleCount     = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[i];
      bSI              = lpxPFData->abShingleIndex[i];

      /* Assuming a full vertical movement before printing this swath,     */
      /* sdwBottomRow is the row number of the row which will be printed   */
      /* by the bottom nozzle of this color plane.   The full vertical     */
      /* movement comes by using sdwRow as the basis for calculating       */
      /* sdwBottomRow.                                                     */
      sdwBottomRow = (sdwRow - (lpxPFData->asdwDBIndx[INIT_DELAY][i]*swVertRes));

      if ( (lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i]) ||
           (sdwBottomRow < lpxPFData->asdwDBIndx[swOut][i]) )
      {
         /* if the bottom nozzle is still off the printable area,          */
         /* sdwBottomRow < lpxPFData->asdwDBIndx[sswOut][i],                 */
         /* then the entire color nozzles are off the page.  So as far     */
         /* as this color plane is concerned, it can "use" all of its      */
         /* nozzles, or in other words, it can be moved a full vertical    */
         /* amount.                                                        */
         awNozzleStart[i] = 0;
         awVerticalMove[i] = wNozzleCount;
         if (awVerticalMove[i] < wVerticalMove)
         {
            wVerticalMove = awVerticalMove[i];
         }
         continue;
      }

      /* Assuming a full vertical movement before printing this swath,     */
      /* sdwTopRow is the row number of the row which will be printed by   */
      /* the top nozzle (nozzle 0) of this color plane.                    */
      sdwTopRow = sdwBottomRow - (SdwordType) wNozzleCount + 1;

      k = sdwBottomRow;
      wNozzle = wNozzleCount;

      /* Important to note that this while() loop processes from the       */
      /* bottom of the print nozzles to the top.  I am doing this          */
      /* because all color banks don't have the same number of nozzles.    */
      while (k >= sdwTopRow)
      {

         if (k < lpxPFData->asdwDBIndx[swOut][i])
         {
            break;
         }

         wNozzle--;

         swScanIndex = (SwordType)(k%lpxPFData->swMaxDelayBuf);

         if (lpxPFData->alpbShingleToApply[i][swScanIndex] != SHINGLE_THRU)
         {
            swShingleThreshold = (SwordType) lpxPFData->awShingleThreshold[bSI][
                                 (lpxPFData->alpbShingleToApply[i][swScanIndex])];

            /* This is a critical decision.  If this if() statement is     */
            /* true then that means that this color plane has to be        */
            /* printed at this time.                                       */
            if ( ((SwordType)wNozzle) <= (swShingleThreshold))
            {
               /* We won't make a full vertical movement, so adjust the    */
               /* sdwBottomRow value we calculated above accordingly.      */
               sdwBottomRow        -= (swShingleThreshold - wNozzle);
               wNozzle              = swShingleThreshold;
               fMustPrintColor[i]   = TRUE;
            }
            else if (((SwordType)wNozzle) <=
                     (swShingleThreshold + MINIMUM_VERTICAL_MOVE))
            {
               fMustPrintColor[i] = TRUE;
#if defined(CREATE_TEST_PAGE)
               /* This code is for assuring that the swaths for vertical   */
               /* alignment are created with no vertical move between them.*/
               if (bVertAlignFlag)
               {
                  if (fMustPrintColor[0] == TRUE)
                  {
                     fMustPrintColor[3] = TRUE;
                  }
                  else
                  {
                     fMustPrintColor[3] = FALSE;
                  }
               }
#endif
            }
         }
         k--;
      }  /* end of while (k >= sdwTopRow) */

      awNozzleStart[i]  = wNozzle;
      sdwOldBottomRow   = lpxPFData->sdwBottomNozzleRowNum -
                          lpxPFData->asdwDBIndx[INIT_DELAY][i];
      awVerticalMove[i] = (WordType)(sdwBottomRow - sdwOldBottomRow);

      if (awVerticalMove[i] < wVerticalMove)
      {
         wVerticalMove = awVerticalMove[i];
      }
   }  /* end of for (i=lpxPFData->swDelayBufStart...) */


   /* Update bottom nozzle row number based on the vertical movement    */
   /* that will occur before this swath (swaths) print.                 */
   lpxPFData->sdwBottomNozzleRowNum += (SdwordType)wVerticalMove;

   for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++)
   {
      if ((fMustPrintColor[i]) && (awVerticalMove[i] == wVerticalMove))
      {
         fMustPrintHead[(i/3)] = TRUE;
      }
      else if ( (fMustPrintColor[i]) &&
                (awVerticalMove[i] >= (wVerticalMove - MINIMUM_VERTICAL_MOVE)) )
      {
         fMustPrintHead[(i/3)] = TRUE;
      }
   }

   /* Now assign nozzle positions to the raster lines that will make up    */
   /* this swath.  This is used to determine what shingle mask pattern to  */
   /* apply                                                                */
   for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++)
   {
      wNozzle      = awNozzleStart[i] + (awVerticalMove[i]-wVerticalMove);
      wNozzleCount = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[i];
      sdwBottomRow = lpxPFData->sdwBottomNozzleRowNum -
                     (lpxPFData->asdwDBIndx[INIT_DELAY][i]*swVertRes);

      if (fMustPrintHead[(i/3)])
      {
         if ((lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i]) ||
              (sdwBottomRow < lpxPFData->asdwDBIndx[swOut][i]) )
         {
            lpxPFData->awRowsToPrint[i] = 0;
            continue;
         }
         else
         {
            lpxPFData->awRowsToPrint[i] = wNozzleCount - wNozzle;
         }
      }
      else
      {
         lpxPFData->awRowsToPrint[i]    = 0;
         continue;
      }

      sdwTopRow = sdwBottomRow - lpxPFData->awRowsToPrint[i] + 1;
      k         = sdwTopRow;

      while (k <= sdwBottomRow)
      {
         if (k == lpxPFData->asdwDBIndx[FC_IN][i])
         {
            break;
         }
         swScanIndex = (SwordType)(k%lpxPFData->swMaxDelayBuf);

         switch(lpxPFData->alpbShingleToApply[i][swScanIndex])
         {
         case SHINGLE_0_1 :
         case SHINGLE_50_1 :
         case SHINGLE_25_1 :
         case SHINGLE_33_1 :
         case SHINGLE_16_1 :
            lpxPFData->alpwShingleLine[i][swScanIndex] = wNozzle;
            break;
         }

         wNozzle++;
         k++;
      }  /* end of while (k <= sdwBottomRow) */
   }  /* end of for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++) */

   lpxPFData->wRowsToMove = wVerticalMove;

#if CPROF
   PrfExit(5);
#endif
   return((SwordType)wVerticalMove);
}  /* end of PreSwathAdjust() */




/***************************************************************************
 * Function Name:    PostSwathAdjust
 *
 * Description:
 *    Updates delay buffer out pointers, based on which raster lines are now
 *    completely printed.
 *
 * Inputs:  lpxDataRec     Far pointer to HBP interface structure.
 *          sdwRow         last raster line read in.
 *
 * Outputs: returns the number of raster lines to read to fill delay
 *          buffers
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/
SwordType PostSwathAdjust(LPDVDATAREC lpxDataRec, SdwordType sdwRow)
{
   LPPFDATA       lpxPFData;
   WordType       wMinRowsToRead,
                  wNozzleCount,
                  wRowsToRead;
   SwordType      i,
                  swOut,
                  swScanIndex,
                  swVertRes;
   SdwordType     k,
                  sdwRowEnd,
                  sdwRowStart;
   BoolType       fKeepRow;

#if CPROF
   PrfEnter(8);
#endif

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   swVertRes      = lpxPFData->swVertResMult;
   swOut          = lpxPFData->swOut;
   wMinRowsToRead = lpxPFData->wBaseNozzleCount;


   for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++)
   {
      fKeepRow = FALSE;

      if (lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i])
      {
         continue;
      }


      sdwRowStart = lpxPFData->asdwDBIndx[swOut][i];
      sdwRowEnd   = sdwRowStart + lpxPFData->awRowsToPrint[i];

      k = sdwRowStart;

      while (k < sdwRowEnd)
      {
         if (k == lpxPFData->asdwDBIndx[FC_IN][i])
         {
            break;
         }

         swScanIndex = (SwordType)(k%lpxPFData->swMaxDelayBuf);

         switch(lpxPFData->alpbShingleToApply[i][swScanIndex])
         {
         case SHINGLE_THRU    :
            if (fKeepRow == FALSE)
            {
               lpxPFData->asdwDBIndx[swOut][i]++;
            }
            break;
         case SHINGLE_0_1  :
         case SHINGLE_50_2 :
         case SHINGLE_25_4 :
         case SHINGLE_33_3 :
         case SHINGLE_16_6 :
            lpxPFData->alpbShingleToApply[i][swScanIndex] = SHINGLE_THRU;
            if (fKeepRow == FALSE)
            {
               lpxPFData->asdwDBIndx[swOut][i]++;
            }
            break;
         default :
            lpxPFData->alpbShingleToApply[i][swScanIndex]++;
            fKeepRow = TRUE;
            break;
         }
         k++;
      }  /* end of while (k < sdwKEnd) */

      wNozzleCount = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[i];

      if (lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i])
      {
         wRowsToRead = wNozzleCount;
      }
      else
      {
         wRowsToRead = (wNozzleCount +
                       (WordType)lpxPFData->asdwDBIndx[INIT_DELAY][i]) -
                       (WordType)(sdwRow - lpxPFData->asdwDBIndx[swOut][i] + 1L);
      }

      if (wRowsToRead < wMinRowsToRead)
      {
         wMinRowsToRead = wRowsToRead;
      }
   }   /* end of for (i=lpxPFData->swDelayBufStart...) */


#if CPROF
   PrfExit(8);
#endif
   return((SwordType)wMinRowsToRead);
}  /* end of PostSwathAdjust() */




/***************************************************************************
 * Function Name:    HiResPreSwathAdjust
 *
 * Description:
 *    We have not yet merged independent shingling with high resolution
 *    alternating raster line printing.  So this function is used when
 *    in high resolution printing mode.
 *
 * Inputs:  lpxDataRec     Far pointer to HBP interface structure.
 *          sdwRow         bottom raster line read in.
 *
 * Outputs: returns vertical move amount, in raster lines, required before
 *          printing this swath.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/
SwordType HiResPreSwathAdjust(LPDVDATAREC lpxDataRec, SdwordType sdwRow)
{
   LPPFDATA       lpxPFData;
   WordType       wNozzle,
                  wNozzleCount,
                  wNozzleStart=0,
                  wRowsToMove;
   SwordType      i,
                  swOut,
                  swScanIndex,
                  swVertRes;
   SdwordType     j, k,
                  sdwBufStart,
                  sdwRowStart;
   ByteType       bSI;

#if CPROF
   PrfEnter(5);
#endif
   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   swVertRes = lpxPFData->swVertResMult;
   swOut     = lpxPFData->swOut;

   for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++)
   {
      wNozzle      = 0;
      wNozzleCount = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[i];
      bSI          = lpxPFData->abShingleIndex[i];


      sdwRowStart = (sdwRow - (SdwordType)(lpxPFData->asdwDBIndx[INIT_DELAY][i] *
                    swVertRes) - (SdwordType)(wNozzleCount*swVertRes) + 1);
      if (sdwRowStart > lpxPFData->sdwRowPos)
      {
         continue;
      }
      sdwRowStart = sdwRowStart % (SdwordType)lpxPFData->swMaxDelayBuf;
      sdwBufStart = lpxPFData->asdwDBIndx[swOut][i];

      for (j=sdwBufStart,k=sdwRowStart; k<sdwRowStart+(wNozzleCount*swVertRes);
           j++,k++)
      {

         swScanIndex = (SwordType)(k%lpxPFData->swMaxDelayBuf);

         if ( (wNozzle >= wNozzleCount) ||
              ((j % lpxPFData->asdwDBIndx[BUFSIZE][i]) == lpxPFData->asdwDBIndx[
              FC_IN][i]) || (k > lpxPFData->sdwRowPos) )
         {
            break;
         }
         if ( ((swOut == FC_OUT_EVEN) && (j%2)) ||
              ((swOut == FC_OUT_ODD) && (!(j%2))) )
         {
            continue;
         }
         if ( (j < 0) || (k < 0) ||
              (lpxPFData->alpbShingleToApply[i][swScanIndex] == SHINGLE_THRU) )
         {
            wNozzle++;
            continue;
         }

         switch(lpxPFData->alpbShingleToApply[i][swScanIndex])
         {
         case SHINGLE_0_1 :
         case SHINGLE_50_1 :
         case SHINGLE_25_1 :
         case SHINGLE_33_1 :
         case SHINGLE_16_1 :
            lpxPFData->alpwShingleLine[i][swScanIndex] = wNozzle;
            break;
         }

         wNozzle++;
      }
      lpxPFData->awRowsToPrint[i] = wNozzleCount*swVertRes;
   }

/* TEST / DEVELOPMENT */
/* FIX THIS FOR HIGH RES 8 PASS PRINTING */
   if ((lpxPFData->bColorPlanes == 4) && (lpxPFData->bShingle == SHINGLE_50))
   {
      lpxPFData->aswDelayKSwath[swOut] = (lpxPFData->aswDelayKSwath[swOut] +
                                         (SwordType)1) % (SwordType)2;
      if (lpxPFData->aswDelayKSwath[swOut] == 1)
      {
         lpxPFData->awRowsToPrint[3] = 0;
      }
   }

   if (lpxPFData->bShingle == NO_SHINGLE)
   {
      wRowsToMove = (WordType)lpxPFData->wBaseNozzleCount;
   }
   else if (lpxPFData->bShingle == SHINGLE_50)
   {
      wRowsToMove = (WordType)lpxPFData->wBaseNozzleCount / 2;
   }
   else
   {  /* 25 % shingling */
      wRowsToMove = (WordType)lpxPFData->wBaseNozzleCount / 4;
   }

   if (swOut == FC_OUT_EVEN)
   {
      wRowsToMove -= 3;
   }
   else if (swOut == FC_OUT_ODD)
   {
      wRowsToMove += 3;
   }

#if CPROF
   PrfExit(5);
#endif
   return((SwordType)wRowsToMove);
}  /* end of HiResPreSwathAdjust() */




/***************************************************************************
 * Function Name:    HiResPostSwathAdjust
 *
 * Description:
 *    We have not yet merged independent shingling with high resolution
 *    alternating raster line printing.  This is why we now have two sets
 *    of swath adjust functions.  For high resolution printing, this
 *    function updates delay buffer out pointers, based on which raster
 *    lines are now completely printed.
 *
 * Inputs:  lpxDataRec     Far pointer to HBP interface structure.
 *          sdwRow         last raster line read in.
 *
 * Outputs: returns the number of raster lines to read to fill delay
 *          buffers
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/
SwordType HiResPostSwathAdjust(LPDVDATAREC lpxDataRec, SdwordType sdwRow)
{
   LPPFDATA       lpxPFData;
   WordType       wNozzleCount,
                  wRowsToFree;
   SwordType      i,
                  swOut,
                  swScanIndex,
                  swVertRes;
   SdwordType     j, k,
                  sdwBufStart,
                  sdwRowStart;

#if CPROF
   PrfEnter(8);
#endif
   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   swVertRes = lpxPFData->swVertResMult;
   swOut     = lpxPFData->swOut;

   for (i=lpxPFData->swDelayBufStart;i<lpxPFData->swDelayBufEnd;i++)
   {
      wNozzleCount = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[i];


      sdwRowStart = (sdwRow - (SdwordType)(lpxPFData->asdwDBIndx[INIT_DELAY][i] *
                    swVertRes) - (SdwordType)(wNozzleCount*swVertRes) + 1);
      if (sdwRowStart > lpxPFData->sdwRowPos)
      {
         continue;
      }
      sdwRowStart = sdwRowStart % (SdwordType)lpxPFData->swMaxDelayBuf;
      sdwBufStart = (SwordType) lpxPFData->asdwDBIndx[swOut][i];

      for (j=sdwBufStart,k=sdwRowStart; k<sdwRowStart+lpxPFData->awRowsToPrint[i];
           j++,k++)
      {
         if ( ((swOut == FC_OUT_EVEN) && (j%2)) ||
              ((swOut == FC_OUT_ODD) && (!(j%2))) )
         {
            continue;
         }

         if (lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i])
         {
            break;
         }

         if ((j < 0) || (k < 0))
         {
            continue;
         }

         swScanIndex = (SwordType)(k%lpxPFData->swMaxDelayBuf);

         switch(lpxPFData->alpbShingleToApply[i][swScanIndex])
         {
         case SHINGLE_THRU    :
            break;
         case SHINGLE_0_1  :
         case SHINGLE_50_2 :
         case SHINGLE_25_4 :
         case SHINGLE_33_3 :
         case SHINGLE_16_6 :
            lpxPFData->alpbShingleToApply[i][swScanIndex] = SHINGLE_THRU;
            break;
         default :
            lpxPFData->alpbShingleToApply[i][swScanIndex]++;
            break;
         }
      }  /* end of for (j=sdwBufStart,k=sdwRowStart...) */

      if ((lpxPFData->bColorPlanes == 4) && (i==3))
      {
         wRowsToFree = wNozzleCount / 3;
      }
      else if (lpxPFData->bShingle == NO_SHINGLE)
      {
         wRowsToFree = wNozzleCount;
      }
      else if (lpxPFData->bShingle == SHINGLE_50)
      {
         wRowsToFree = wNozzleCount / 2;
      }
      else
      {  /* 25% shingling */
         wRowsToFree = wNozzleCount / 4;
      }

      if ((lpxPFData->bColorPlanes == 4) && (lpxPFData->bShingle == SHINGLE_50) && (i == 3))
      {
         if (lpxPFData->aswDelayKSwath[swOut] == 1)
         {
            wRowsToFree = 0;
         }
      }

      for (k=0; k<(SwordType)(wRowsToFree*swVertRes); k++)
      {
         if ( lpxPFData->asdwDBIndx[swOut][i] == lpxPFData->asdwDBIndx[FC_IN][i])
         {
            break;
         }
         lpxPFData->asdwDBIndx[swOut][i] = (lpxPFData->asdwDBIndx[swOut][i]+1) %
                                         lpxPFData->asdwDBIndx[BUFSIZE][i];

      }  /* end of for (k=0; k<(SwordType)(wRowsToFree*swVertRes); k++) */
   }

   if (lpxPFData->bShingle == NO_SHINGLE)
   {
      wRowsToFree = (WordType)lpxPFData->wBaseNozzleCount;
   }
   else if (lpxPFData->bShingle == SHINGLE_50)
   {
      wRowsToFree = (WordType)lpxPFData->wBaseNozzleCount / 2;
   }
   else
   {  /* 25% shingling */
      wRowsToFree = (WordType)lpxPFData->wBaseNozzleCount / 4;
   }
#if CPROF
   PrfExit(8);
#endif
   return ((SwordType)wRowsToFree);
}  /* end of HiResPostSwathAdjust() */


/***************************************************************************
 * Function Name:    GetHiResStartSlice
 *
 * Description:
 *    This function returns 0 or 1 for even or odd slice usage for building
 *    a 600 dpi swath from 1200 dpi even or odd numbered raster lines based
 *    on the printhead in use
 *
 * Inputs:  lpxPFData      Far pointer to HBP PFData structure.
 *          swOut          Even or odd rasters lines used to build swath
 *          swBuffers      Which printhead used, CMY, KCM or K.
 *
 * Outputs: Returns 0 to use even slices or 1 to use odd slices to build swath.
 *
 * Original Author: L. Cheatham
 * Date: 10/10/98
 *
 **************************************************************************/

WordType GetHiResStartSlice(LPPFDATA lpxPFData, SwordType swOut, SwordType swBuffers)
{
   WordType wStartSlice = 0;

   switch (swBuffers)
   {
   case CMYPLANES :
      if (swOut == FC_OUT_EVEN)
      {
         wStartSlice = lpxPFData->wCMYEvenRasterSlice++;
         lpxPFData->wCMYEvenRasterSlice %= 2;  /* should always be = 0 or 1 */
      }
      else
      {
         wStartSlice = lpxPFData->wCMYOddRasterSlice++;
         lpxPFData->wCMYOddRasterSlice %= 2;  /* should always be = 0 or 1 */
      }

      break;

   case KCMPLANES :
      if (swOut == FC_OUT_EVEN)
      {
         wStartSlice = lpxPFData->wKCMEvenRasterSlice++;
         lpxPFData->wKCMEvenRasterSlice %= 2;  /* should always be = 0 or 1 */
      }
      else
      {
         wStartSlice = lpxPFData->wKCMOddRasterSlice++;
         lpxPFData->wKCMOddRasterSlice %= 2;  /* should always be = 0 or 1 */
      }
      break;

   case KPLANE:
      if (swOut == FC_OUT_EVEN)
      {
         wStartSlice = lpxPFData->wBLKEvenRasterSlice++;
         lpxPFData->wBLKEvenRasterSlice %= 2;  /* should always be = 0 or 1 */
      }
      else
      {
         wStartSlice = lpxPFData->wBLKOddRasterSlice++;
         lpxPFData->wBLKOddRasterSlice %= 2;  /* should always be = 0 or 1 */
      }
      break;
   }  /* end of switch(swBuffers) */

   return (wStartSlice);
}

/***************************************************************************
 * Function Name:    GetRasterLineShingleMask
 *
 * Description:
 *    This function returns the shingle mask to use for this raster line.
 *    This mask is used (Anded) with each word of the raster line to get
 *    the bits to rotate to the swath.  Returns hex FFFF when the raster
 *    line does not require a shingle mask.
 *
 * Inputs:  lpxPFData      Far pointer to HBP PFData structure.
 *          wPlane         Color plane number 0 to 6.
 *          swScanIndes    Raster line number.
 *
 * Outputs: Returns a 16 bit shingle mask for use with current raster line.
 *
 * Original Author: L. Cheatham
 * Date: 10/21/98
 *
 **************************************************************************/

WordType GetRasterLineShingleMask(LPDVDATAREC lpxDataRec, WordType wPlane,
                                  SwordType swScanIndex, WordType wStartSlice )
{
   WordType  wShingle;
   ByteType  bDropsPerPixel;
   LPPFDATA lpxPFData;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;
   bDropsPerPixel = (ByteType)lpxPFData->asdwDBIndx[DROPS_PER_PIXEL][wPlane];

#if OPTION_600_AS_2X300
   if (lpxPFData->bShingleLoRes == SHINGLE_50)
   {
      /*  no shingle-masking is required  */
      return( 0xFFFF );
   }
#endif

   switch(lpxPFData->alpbShingleToApply[wPlane][swScanIndex])
   {
   case SHINGLE_0_1 :
   default :
      wShingle = 0xFFFF;            /* not shingled */
      break;
   case SHINGLE_50_1 :
      if (lpxPFData->bResolution == HIRES_INTERLACED &&
          lpxPFData->bShingleHiRes == SHINGLE_50 )
      {  /* For 1200 dpi even or odd bits will be used by rotate loop */
         wShingle = 0xFFFF;            /* not shingled */
      }
      else
      {
         /* use alternating shingle mask based on raster line number */
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_50][
                    (lpxPFData->alpwShingleLine[wPlane][swScanIndex])%2];
      }
      break;
   case SHINGLE_50_2 :
      if (lpxPFData->bResolution == HIRES_INTERLACED &&
          lpxPFData->bShingleHiRes == SHINGLE_50 )
      {  /* For 1200 dpi even or odd bits will be used by rotate loop */
         wShingle = 0xFFFF;            /* not shingled */
      }
      else
      {
         /* use same shingle mask for all colors for this raster */
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_50][
                    ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+1)%2];
      }
      break;
   case SHINGLE_25_1 :
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) &&
           ( (lpxPFData->bColorPlanes == 3) || (lpxPFData->bColorPlanes == 4)) )
      {
         if (wStartSlice == 0)
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][0];
         }
         else
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][3];
         }
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][
                    (lpxPFData->alpwShingleLine[wPlane][swScanIndex])%4];
      }
      break;
   case SHINGLE_25_2 :
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) &&
           ( (lpxPFData->bColorPlanes == 3) || (lpxPFData->bColorPlanes == 4)) )
      {
         if (wStartSlice == 0)
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][0];
         }
         else
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][3];
         }
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][
                    ((lpxPFData->alpwShingleLine[wPlane][swScanIndex]+1))%4];
      }
      break;
   case SHINGLE_25_3 :
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) &&
           ( (lpxPFData->bColorPlanes == 3) || (lpxPFData->bColorPlanes == 4)) )
      {
         if (wStartSlice == 0)
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][2];
         }
         else
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][1];
         }
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][
                    ((lpxPFData->alpwShingleLine[wPlane][swScanIndex]+2))%4];
      }
      break;
   case SHINGLE_25_4 :
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) &&
           ( (lpxPFData->bColorPlanes == 3) || (lpxPFData->bColorPlanes == 4)) )
      {
         if (wStartSlice == 0)
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][2];
         }
         else
         {
            wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][1];
         }
      }
      else
      {
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_25][
                    ((lpxPFData->alpwShingleLine[wPlane][swScanIndex]+3))%4];
      }
      break;
   case SHINGLE_33_1 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_33][
                 (lpxPFData->alpwShingleLine[wPlane][swScanIndex])%3];
      break;
   case SHINGLE_33_2 :
         wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_33][
                    ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+1)%3];
      break;
   case SHINGLE_33_3 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_33][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+2)%3];
      break;
   case SHINGLE_16_1 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_16][
                 (lpxPFData->alpwShingleLine[wPlane][swScanIndex])%6];
      break;
   case SHINGLE_16_2 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_16][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+1)%6];
      break;
   case SHINGLE_16_3 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_16][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+2)%6];
      break;
   case SHINGLE_16_4 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_16][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+3)%6];
      break;
   case SHINGLE_16_5 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_16][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+4)%6];
      break;
   case SHINGLE_16_6 :
      wShingle = lpxPFData->alpwShingleMask[SHINGLE_MASK_16][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex])+5)%6];
      break;
   }

   return( wShingle );

}


/***************************************************************************
 * Function Name:    GetRasterLineShingleMask2
 *
 * Description:
 *    This function returns the shingle mask to use for this raster line
 *    in the second color planes for CMY when 2 bits per pixel is used.
 *    This mask is used (Anded) with each word of the raster line to get
 *    the bits to rotate to the swath.  Returns hex FFFF when the raster
 *    line does not require a shingle mask.
 *
 * Inputs:  lpxPFData      Far pointer to HBP PFData structure.
 *          wPlane         Color plane number 0 to 6.
 *          swScanIndes    Raster line number.
 *
 * Outputs: Returns a 16 bit shingle mask for use with the current raster
 *    line in the second plane.
 * Original Author: L. Cheatham
 * Date: 10/21/98
 *
 **************************************************************************/

WordType GetRasterLineShingleMask2(LPDVDATAREC lpxDataRec, WordType wPlane,
                                   SwordType swScanIndex)
{
   WordType wShingle2;
   LPPFDATA lpxPFData;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   switch(lpxPFData->alpbShingleToApply[wPlane][swScanIndex])
   {
   case SHINGLE_0_1 :
   default :
      /* Don't shingle second plane */
      wShingle2 = 0xFFFF;
      break;
   case SHINGLE_50_1 :
      /* Don't shingle second plane */
      wShingle2 = 0xFFFF;
      break;
   case SHINGLE_50_2 :
      /* Don't shingle second plane */
      wShingle2 = 0xFFFF;
      break;

   case SHINGLE_25_1 :
   case SHINGLE_25_3 :
      /* Use 2 pass shingle mask for second plane when first plane */
      /* is printed with 4 pass */
      wShingle2 = lpxPFData->alpwShingleMask[SHINGLE_MASK_50][
                 (lpxPFData->alpwShingleLine[wPlane][swScanIndex])%2];
      break;
   case SHINGLE_25_2 :
   case SHINGLE_25_4 :
      /* Use 2 pass shingle mask for second plane when first plane */
      /* is printed with 4 pass */
      wShingle2 = lpxPFData->alpwShingleMask[SHINGLE_MASK_50][
                 ((lpxPFData->alpwShingleLine[wPlane][swScanIndex]+1))%2];
      break;
   case SHINGLE_33_1 :
      /* Use a shingle mask that prints each drop in second plane  */
      /* two times in 3 passes.  The drops in the first plane are  */
      /* printed only once in 3 passes.                            */
      wShingle2 = 0xB6B6;
      break;
   case SHINGLE_33_2 :
      wShingle2 = 0x6D6D;
      break;
   case SHINGLE_33_3 :
      wShingle2 = 0xDBDB;
      break;
   }

   return( wShingle2 );
}

ByteType UpdateRasterMask(LPDVDATAREC lpxDataRec)
{
   LPPFDATA lpxPFData;
   ByteType bSwathDir = FORWARD;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

#if OPTION_REVERSE_SWATH

   /* reset raster masks based on carrier print direction */
   bSwathDir = CheckForReverseSwath(lpxDataRec);

   if (bSwathDir == REVERSE)
   {  /* reverse swath */
      /* When building swath backwards, rotate from the end of the raster, */
      /* not the begining (right to left)                                  */
      lpxPFData->lpwRastMask[0]  = RASTER_MASK15;
      lpxPFData->lpwRastMask[1]  = RASTER_MASK14;
      lpxPFData->lpwRastMask[2]  = RASTER_MASK13;
      lpxPFData->lpwRastMask[3]  = RASTER_MASK12;
      lpxPFData->lpwRastMask[4]  = RASTER_MASK11;
      lpxPFData->lpwRastMask[5]  = RASTER_MASK10;
      lpxPFData->lpwRastMask[6]  = RASTER_MASK9;
      lpxPFData->lpwRastMask[7]  = RASTER_MASK8;
      lpxPFData->lpwRastMask[8]  = RASTER_MASK7;
      lpxPFData->lpwRastMask[9]  = RASTER_MASK6;
      lpxPFData->lpwRastMask[10] = RASTER_MASK5;
      lpxPFData->lpwRastMask[11] = RASTER_MASK4;
      lpxPFData->lpwRastMask[12] = RASTER_MASK3;
      lpxPFData->lpwRastMask[13] = RASTER_MASK2;
      lpxPFData->lpwRastMask[14] = RASTER_MASK1;
      lpxPFData->lpwRastMask[15] = RASTER_MASK0;
   }  /* end of reverse swath */
   else
   {  /* forward swath */
      lpxPFData->lpwRastMask[0]  = RASTER_MASK0;
      lpxPFData->lpwRastMask[1]  = RASTER_MASK1;
      lpxPFData->lpwRastMask[2]  = RASTER_MASK2;
      lpxPFData->lpwRastMask[3]  = RASTER_MASK3;
      lpxPFData->lpwRastMask[4]  = RASTER_MASK4;
      lpxPFData->lpwRastMask[5]  = RASTER_MASK5;
      lpxPFData->lpwRastMask[6]  = RASTER_MASK6;
      lpxPFData->lpwRastMask[7]  = RASTER_MASK7;
      lpxPFData->lpwRastMask[8]  = RASTER_MASK8;
      lpxPFData->lpwRastMask[9]  = RASTER_MASK9;
      lpxPFData->lpwRastMask[10] = RASTER_MASK10;
      lpxPFData->lpwRastMask[11] = RASTER_MASK11;
      lpxPFData->lpwRastMask[12] = RASTER_MASK12;
      lpxPFData->lpwRastMask[13] = RASTER_MASK13;
      lpxPFData->lpwRastMask[14] = RASTER_MASK14;
      lpxPFData->lpwRastMask[15] = RASTER_MASK15;
   }  /* end of forward swath */
#endif   /* end of OPTION_REVERSE_SWATH */

    return (bSwathDir);
}
