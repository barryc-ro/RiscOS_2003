/* daheap.c
 *
 * Very simple heap in a dynamic area
 */

#include "common.h"

#define MAXSIZE (1200 * 1024)
#define MINSIZE ( 800 * 1024)	/* Driver seems to need about 800k so let's just get it all at once */
#define MINGROW (  32 * 1024)
#define AREANAME "Lexmark Workspace"

static int da = 0;
static size_t dasize;
static void *base = NULL;

void daheap_dispose(void)
{
	_kernel_swi_regs r;
	if (da == 0) return;
	r.r[0]	= 1;
	r.r[1]	= da;
	THROW(_kernel_swi(OS_DynamicArea, &r, &r));
	da		= 0;
	base	= NULL;
	dasize	= 0;
}

void daheap_create(size_t initsize)
{
	_kernel_swi_regs r;
	/* we can use daheap_create() to recycle an existing heap,
	 * so if there is one we ditch it here
	 */
	daheap_dispose();

	/* create a new DA */
	if (initsize < MINSIZE)
		initsize = MINSIZE;

	r.r[0]	= 0;
	r.r[1]	= -1;
	r.r[2]	= initsize;
	r.r[3]	= -1;
	r.r[4]	= (1 << 7);		/* can't be user resized */
	r.r[5]	= MAXSIZE;
	r.r[6]	= 0;
	r.r[7]	= -1;
	r.r[8]	= (int) AREANAME;
	THROW(_kernel_swi(OS_DynamicArea, &r, &r));
	da		= r.r[1];
	dasize	= initsize;
	base	= (void *) r.r[3];

	/* now initialise a heap */
	r.r[0]	= 0;
	r.r[1]	= (int) base;
	r.r[3]	= dasize;
	THROW(_kernel_swi(OS_Heap, &r, &r));

	cairo_trace1("Dynamic area of %ld bytes allocated\n", (long) dasize);
}

static void daheap__ensure(size_t initsize)
{
	if (da == 0) daheap_create(initsize);
}

void *daheap_malloc(size_t size)
{
	_kernel_swi_regs r;
	_kernel_oserror *err;

	if (size == 0) size = 1;

	/* make sure we've got a heap to work with */
	daheap__ensure(size);

	r.r[0]	= 2;
	r.r[1]	= (int) base;
	r.r[3]	= (int) size;
	err = _kernel_swi(OS_Heap, &r, &r);

	if (err != NULL || r.r[2] == 0)		/* failed? */
	{
		/* very simple; just grow the DA and heap by the size
		 * of the allocation
		 */
		size_t growby	= size;
		size_t oldsize	= dasize;

		if (growby < MINGROW) growby = MINGROW;

		/* grow the area */
		r.r[0]	= da;
		r.r[1]	= growby;
		THROW(_kernel_swi(OS_ChangeDynamicArea, &r, &r));

		/* get info about the area */
		r.r[0]	= 2;
		r.r[1]	= da;
		THROW(_kernel_swi(OS_DynamicArea, &r, &r));
		dasize	= r.r[2];

		/* extend the heap to fit the resized DA */
		r.r[0]	= 5;
		r.r[1]	= (int) base;
		r.r[3]	= (int) dasize - (int) oldsize;
		THROW(_kernel_swi(OS_Heap, &r, &r));

		cairo_trace2("Dynamic area grown from %ld to %ld\n", (long) oldsize, (long) dasize);

		/* and attempt the allocation again */
		r.r[0]	= 2;
		r.r[1]	= (int) base;
		r.r[3]	= (int) size;
		THROW(_kernel_swi(OS_Heap, &r, &r));
		if (r.r[2] == 0) THROW(&cairo_nomem);
	}

	return (void *) r.r[2];
}

void daheap_free(void *mem)
{
	_kernel_swi_regs r;
	r.r[0]	= 3;
	r.r[1]	= (int) base;
	r.r[2]	= (int) mem;
	THROW(_kernel_swi(OS_Heap, &r, &r));
}
