
/****************************************************************************
 * FcIntfc.c                                       Lexmark Confidential
 *
 * $Revision$
 * $Date$
 * $Author$
 *
 *
 * Description:
 *    FCINTFC.C contains the interface functions for the hbpcode.  Every
 *    function that a driver can call into the hbpcode is included
 *    in this moodule.  There are also some related functions and functions
 *    only used in this module.
 *
 *
 * No.   Date     Who  Function              Description of Change
 * --------------------------------------------------------------------------
 * 015  08/10/98  xzhan LoadShingleMasks() For Oak head, The COLOR_NOZZLE_COUNT
 *      is three times bigger than MONO_NOZZLE_COUNT.
 *
 * 016   9/10/98  RFL   Fixed FCOutputStrip() to handle 7-planes of raster
 *                      data when 4-plane with 2-bit per pixel and aligning
 *                      ScanStart & ScanEnd to word boundarys.
 *
 * 017   9/12/98  wlc   Update to FCOutputStrip() to zero additional 2-bit per
 *                      pixel planes when ScanStart & ScanEnd are aligned to
 *                      word boundary.
 *
 * 018  10/02/98  wlc   Changes to support printing 1200 dpi 50% shingled data
 *      as 2 pass 600 dpi starting on even and odd 1/1200.
 *
 * 019  10/17/98  wlc   Changes to use bColorPlanes from lpxPFData struc
 *      instead of lpxDataRec struc.  This allows lpxPFData->bColorPlanes to be
 *      changed in GetResolution() to support printing CMY for Envelopes when
 *      the driver sends us raster lines with only data for the K plane.
 *
 * 020  10/28/98  RFL   Fixed out of memory error BUG-1541 for paper width of
 *                      254 pixels (executive draft).
 *
 * 021  10/30/98  wlc   Moved WIN.INI compression overide from HwStartJob() to
 *      FCStartDoc() to make it available for all products.
 *
 * 022  11/16/98  jbb   FCInitStore()     Added code to allocate
 *      lpxPFData->lpbExtendedRasterLine when GEN_TEST_INPUT_FILES is
 *      defined.  This was accidentally removed.
 *
 * 023  01/11/99 xzhan  FCInitStore() and FCKillStore  Added code to allocate
 *      and free memory for lpxPrtCmd and lpxSegmentCmd structure for Oak head
 *
 * 024  03/02/99 xzhan  FCInitStore() and FCKillStore made some changes to Oak head
 *      code to use new segment size (804 color firegroups, 402 black firegroup
 *      so the nozzles won't fill into next segment because of the offset
 * 025  03/04/99  wlc   Changed call to CheckForCDE() to pass in lpxDataRec as
 *      the first parm.
 *
 * 026  03/10/99 xzhan update FCinitStore and FCKillStore to fix a draft mode
 *      printing problem BUG04760.
 ***************************************************************************/

/************** Definitions & Macros **************************************/
#if !defined(NOPRAGMA)
//#pragma warning (disable: 4103)  /* used #pragma pack to change alignment    */
//#pragma warning (disable: 4213)  /* nonstndrd extension used: cast on l-value*/
#endif


/************** Include Files *********************************************/

#if defined(DOS_BUILD) || defined(FC_DOS_32)
#include <stdio.h>
#include <malloc.h>
#endif

#if !defined(FC_WIN_32) && !defined(FC_OS2)
//#include <memory.h>
#endif

#include <stdlib.h>
#include <string.h>

#if defined(GEN_TEST_INPUT_FILES)
#include <stdio.h>
#endif

#include "fclocal.h"
#include "common.h"


/************** Prototype Definitions *************************************/

void FCKillStore(LPDVDATAREC lpxDataRec);
WordType FAR FCInitStore(LPDVDATAREC lpxDataRec);
void LoadShingleMasks(LPDVDATAREC lpxDataRec, ByteType bNumPlanes);


/************** Variable Declarations *************************************/

static char fc_version[] = "fcintfc.obj: "FC_VERSION; /* set object module ID */


/***************************************************************************
 * Function Name:    FCKillStore
 *
 * Description:
 *    This function ***MUST*** be called at the end of every print job.  It
 *    frees all resolution dependent memory that was allocated by
 *    FCInitStore().
 *
 * Inputs:  lpxDataRec     Long pointer to print device structure.
 *
 * Outputs: <none>
 *
 * Original Author: Bob Locasto
 * Date: 05/07/97
 *
 **************************************************************************/
void FCKillStore(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   WordType    i,m,n;
   ByteType    bColorPlanes;

   if (lpxDataRec)
   {
      lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;
   }
   else
   {
      lpxPFData = NULL;
   }

   if (lpxPFData)
   {  /* storage is allocated, so free it */
      bColorPlanes = lpxPFData->bOldColorPlanes;

      for (n=0; n < bColorPlanes; n++)
      {  /* loop for number of color planes in this page */
         for (m=0;m<(WordType)lpxPFData->asdwDBIndx[DROPS_PER_PIXEL][n]; m++)
         {  /* loop for number of drops per pixel for this color plane */
            for (i=0;i<=((WordType)(lpxPFData->asdwDBIndx[BUFSIZE][n]-1) /
                         lpxPFData->wRastersPerSeg);i++)
            {  /* loop for number of segments required for one drop for    */
               /* this color plane                                         */
               if (lpxPFData->alpwPlane[(m*DROP_SEC_SIZE)+(i*bColorPlanes)+n])
               {
                  FREE_MEMORY(lpxPFData->alpwPlane[(m*DROP_SEC_SIZE)+
                              (i*bColorPlanes)+n]);
               }
            }  /* end of loop for number of segments required.... */
         }  /* end of loop for number of drops per pixel.         */
      }  /* end of loop for number of color planes in this page   */

      if (lpxPFData->lpbMemArea)
      {
         FREE_MEMORY(lpxPFData->lpbMemArea);
      }

#if OAK_HEAD
      if (lpxPFData->lpxPrtCmd)
      {
         FREE_MEMORY((LPPRTCMD)lpxPFData->lpxPrtCmd);
      }

      if (lpxPFData->lpxSegmentCmd)
      {
         if (lpxPFData->wSlicesPerRow > SLICES_PER_SEG)
         {
            if (lpxPFData->alpbSwath[0] == (LPByteType)
                (lpxPFData->lpxSegmentCmd +SEGMENT_HEADER_SIZE))
            {
               lpxPFData->alpbSwath[0] = NULL;
            }
            FREE_HUGE_MEMORY((HPSEGMENTCMD)lpxPFData->lpxSegmentCmd);
         }
         else
         {
            FREE_MEMORY((LPSEGMENTCMD)lpxPFData->lpxSegmentCmd);
            lpxPFData->alpbSwath[0] = NULL;
         }
      }
#else
      if (lpxPFData->lpxPrtCmd)
      {
         if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
         {
            if (lpxPFData->alpbSwath[0] == (LPByteType)(lpxPFData->lpxPrtCmd +
               SWATH_HEADER_SIZE))
            {
               lpxPFData->alpbSwath[0] = NULL;
            }
            FREE_HUGE_MEMORY((HPPRTCMD)lpxPFData->lpxPrtCmd);
         }
         else
         {
            FREE_MEMORY((LPPRTCMD)lpxPFData->lpxPrtCmd);
            lpxPFData->alpbSwath[0] = NULL;
         }
      }
#endif

#if OPTION_COMPRESSION
      if (lpxPFData->lpxCompPrtCmd)
      {
         if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
         {
            FREE_HUGE_MEMORY((HPPRTCMD)lpxPFData->lpxCompPrtCmd);
         }
         else
         {
            FREE_MEMORY((LPPRTCMD)lpxPFData->lpxCompPrtCmd);
         }
      }
#endif

#if OPTION_CHECKDENSITY
      if (lpxPFData->lpxDensePrtCmd)
      {
         if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
         {
            FREE_HUGE_MEMORY((HPPRTCMD)lpxPFData->lpxDensePrtCmd);
         }
         else
         {
            FREE_MEMORY((LPPRTCMD)lpxPFData->lpxDensePrtCmd);
         }
      }
#endif

#if OAK_HEAD
      for (i=2; i<=(3*(lpxPFData->wSlicesPerRow-1)/SLICES_PER_SEG);i+=2)
#else
      for (i=0; i<=((lpxPFData->wSlicesPerRow-1)/SLICES_PER_SEG);i++)
#endif
      {
         if (lpxPFData->alpbSwath[i])
         {
            FREE_MEMORY(lpxPFData->alpbSwath[i]);
         }
      }

#if   OPTION_REVERSE_SWATH
      if (lpxPFData->lpwReverseRaster)
      {
         FREE_MEMORY(lpxPFData->lpwReverseRaster);
      }
#endif

#if   OPTION_CMY_ENVELOPES
      if (lpxPFData->lpbEnvelopeRasterLine)
      {
         FREE_MEMORY(lpxPFData->lpbEnvelopeRasterLine);
      }
#endif

#if defined(GEN_TEST_INPUT_FILES)
      if (lpxPFData->lpbExtendedRasterLine)
      {
         FREE_MEMORY(lpxPFData->lpbExtendedRasterLine);
      }
#endif

   }  /* end of freeing allocating storage */

   return;

}  /* end of FCKillStore() */


/***************************************************************************
 * Function Name:    FCInitStore
 *
 * Description:
 *    This function is expected to be called at the beginning of every print
 *    job and sometimes at the beginning of a page. It allocates all storage
 *    that is based on resolution and initializes variables/pointers.
 *
 * Inputs:  lpxDataRec        Far pointer to HBP interface structure.
 *
 * Outputs: fStoreAllocated   TRUE - storage allocation successful
 *                            FALSE - storage allocation failed
 *
 * Original Author: Bob Locasto
 * Date: 05/06/97
 *
 *************************************************************************/
WordType FAR FCInitStore(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   WordType    i, m, n,
               wMemAreaSize,
               wIStart;
   WordType    wSegments;
   WordType    wLines;
#if OAK_HEAD && defined(FC_DOS_32)
   DwordType   ii;
#endif
   BoolType    fStoreAllocated;
   ByteType    bColorPlanes;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   if ((lpxDataRec->wSwathWidth%16) != 0)
   {
      /* error, swathwidth must be an even word amount */
      return((WordType)FALSE);
   }

   bColorPlanes = lpxPFData->bColorPlanes;

   fStoreAllocated = TRUE; /* storage allocate successful */
   while (fStoreAllocated)
   {

      /* store current values for color planes, resolution, and swath      */
      /* width so we can notice if any of these values change on a page    */
      /* basis.                                                            */
      lpxPFData->bOldColorPlanes  = lpxPFData->bColorPlanes;
      lpxPFData->bOldResolution   = lpxPFData->bResolution;
      lpxPFData->wOldSwathWidth   = lpxDataRec->wSwathWidth;
      lpxPFData->bOldBitsPerPixel = lpxPFData->bBitsPerPixel;

      switch (lpxPFData->bResolution)
      {
      case SUPERLOWRES:
         /* Super Low resolution for printers that have 3 resolutions */
         lpxPFData->swVertResMult   = SLRES_VERTICAL_MULTIPLIER;
         lpxPFData->swRastResMult   = SLRES_RASTER_MULTIPLIER;
         lpxPFData->swSwathResMult  = SLRES_SWATH_MULTIPLIER;
         break;

      case LORES:
         /* Low resolution */
         lpxPFData->swVertResMult   = LORES_VERTICAL_MULTIPLIER;
         lpxPFData->swRastResMult   = LORES_RASTER_MULTIPLIER;
         lpxPFData->swSwathResMult  = LORES_SWATH_MULTIPLIER;
         break;

      case HIRES_NONINTERLACED:
         /* resolution between normal and high */
         lpxPFData->swVertResMult   = LORES_VERTICAL_MULTIPLIER;
         lpxPFData->swRastResMult   = HIRES_RASTER_MULTIPLIER;
         lpxPFData->swSwathResMult  = HIRES_SWATH_MULTIPLIER;
         break;

      case HIRES_INTERLACED:
         /* High resolution */
         lpxPFData->swVertResMult   = HIRES_VERTICAL_MULTIPLIER;
         lpxPFData->swRastResMult   = HIRES_RASTER_MULTIPLIER;
         lpxPFData->swSwathResMult  = HIRES_SWATH_MULTIPLIER;
         break;
      }   /* end of Set up the resolution for this print page */


#if OAK_HEAD
      /* for black swath, it need 6 segments, segment size is 32640 for either
      black or color:
      32640*6+20=195860, this will take care of the nozzle offset
      */
      lpxPFData->dwSwathPrintSize = (DwordType)195860;
#else
      lpxPFData->dwSwathPrintSize = PRT_CMD_SIZE(lpxDataRec->wSwathWidth,
                                    lpxPFData->swSwathResMult);
#endif

      lpxPFData->wWordsPerRow    = (lpxDataRec->wSwathWidth/16) *
                                    lpxPFData->swSwathResMult;

      lpxPFData->wBytesPerRow     = lpxPFData->wWordsPerRow * (WordType)2;

      lpxPFData->wRastersPerSeg  = (WordType)((SEGMENT_SIZE) /
                                    lpxPFData->wBytesPerRow);


      /* set size of delay buffers, in number of raster lines */
      lpxPFData->asdwDBIndx[BUFSIZE][0] = P1_BUFNUM * lpxPFData->swVertResMult;
      lpxPFData->asdwDBIndx[BUFSIZE][1] = P2_BUFNUM * lpxPFData->swVertResMult;
      lpxPFData->asdwDBIndx[BUFSIZE][2] = P3_BUFNUM * lpxPFData->swVertResMult;
      lpxPFData->asdwDBIndx[BUFSIZE][3] = P4_BUFNUM * lpxPFData->swVertResMult;
      lpxPFData->asdwDBIndx[BUFSIZE][4] = P5_BUFNUM * lpxPFData->swVertResMult;
      lpxPFData->asdwDBIndx[BUFSIZE][5] = P6_BUFNUM * lpxPFData->swVertResMult;

      /* allocate delay buffers */
      for (n = 0;n < bColorPlanes; n++)
      {  /* loop for number of color planes in this page */
         for (m=0;m<(WordType)lpxPFData->asdwDBIndx[DROPS_PER_PIXEL][n]; m++)
         {  /* loop for number of drops per pixel for this color plane */

            /* This re-write will fix BUG-1541 & read better I hope */
            /* get the number of raster lines we need for this buffer */
            wLines = (WordType)(lpxPFData->asdwDBIndx[BUFSIZE][n]);

            /* the -1 in the following statement insures we do not allocate
             * an extra zero length buffer segment when the number of rows to
             * be stored in the delay buffer is equal to the number of rows
             * per segment. */
            wSegments = ((wLines - 1) / lpxPFData->wRastersPerSeg) + 1;

            for (i = 0; i < wSegments; i++)
            {  /* loop for number of segments required for this color plane */

               if (wLines >= lpxPFData->wRastersPerSeg)
               {  /* full segment required */
                  lpxPFData->alpwPlane[(m*DROP_SEC_SIZE)+(i*bColorPlanes)+n] =
                        (LPWordType)ALLOCATE_MEMORY((lpxPFData->wRastersPerSeg *
                                                     lpxPFData->wBytesPerRow));
                  /* decrement number of rows needed */
                  wLines -= lpxPFData->wRastersPerSeg;
               }
               else
               {  /* partial segment required */
                  lpxPFData->alpwPlane[(m*DROP_SEC_SIZE)+(i*bColorPlanes)+n] =
                        (LPWordType)ALLOCATE_MEMORY((wLines *
                                                     lpxPFData->wBytesPerRow));
               }

               if (lpxPFData->alpwPlane[(m*DROP_SEC_SIZE)+(i*bColorPlanes)+n] ==
                   NULL)
               {
                  fStoreAllocated = FALSE;
                  break;
               }
            }  /* end of loop for number of segments required */

            if (fStoreAllocated == FALSE)
            {
               break;
            }
         }  /* end of loop for number of drops per pixel.   */
         if (fStoreAllocated == FALSE)
         {
            break;
         }
      }  /* end of loop for number of color planes in this page */

      /* end of allocating delay buffers */

      if (fStoreAllocated == FALSE)
      {
         break;
      }
#if OAK_HEAD
      lpxPFData->lpxPrtCmd = (LPByteType)ALLOCATE_MEMORY(SWATH_HEADER_SIZE);
#endif

      /* allocate print swath buffer */
#if OAK_HEAD
      lpxPFData->wSlicesPerRow = lpxPFData->wBytesPerRow * (WordType)4;
#else
      lpxPFData->wSlicesPerRow = lpxPFData->wBytesPerRow * (WordType)8;
#endif

#if OAK_HEAD
/*      if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)*/
/* for 16 bit, SEGMENT_SIZE is 64K */
#ifndef FC_DOS_32
      lpxPFData->lpxSegmentCmd = (LPByteType)
                                 ALLOCATE_MEMORY(SEGMENT_HEADER_SIZE);

      wIStart=0;
      if (!lpxPFData->lpxSegmentCmd)
      {
         fStoreAllocated = FALSE;
         break;
      }
#else
/* for 32 bit, SEGMENT_SIZE>dwSwathPrintSize*/
/* allocate 6 swath segment in continuous memory blocks*/
      lpxPFData->lpxSegmentCmd=(LPByteType)
                               ALLOCATE_MEMORY(lpxPFData->dwSwathPrintSize);
      for (i=0;i<6;i++)
      {
         ii=(DwordType)i;
         lpxPFData->alpbSwath[i] = (LPByteType)(lpxPFData->lpxSegmentCmd +
                                                SEGMENT_HEADER_SIZE+
                                                (DwordType)32640*ii);
      }

      if (!lpxPFData->lpxSegmentCmd)
      {
         fStoreAllocated = FALSE;
         break;
      }

      /* for color, need 3 more continuous swath segments */
      lpxPFData->alpbSwath[6] = (LPByteType)ALLOCATE_MEMORY((DwordType)97920);
      lpxPFData->alpbSwath[7] = (LPByteType)(lpxPFData->alpbSwath[6]+
                                             (DwordType)32640);
      lpxPFData->alpbSwath[8] = (LPByteType)(lpxPFData->alpbSwath[6]+
                                             (DwordType)65280);
      wIStart = 9;

      if (!lpxPFData->alpbSwath[6])
      {
         fStoreAllocated = FALSE;
         break;
      }
#endif

#else
      if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
      {  /* larger than one segment */
         lpxPFData->lpxPrtCmd = (HPByteType)ALLOCATE_HUGE_MEMORY(
                              lpxPFData->dwSwathPrintSize);
         if (LOWORD(lpxPFData->lpxPrtCmd) == 0)
         {
            lpxPFData->alpbSwath[0]=(LPByteType)
                                  (lpxPFData->lpxPrtCmd+SWATH_HEADER_SIZE);
            wIStart = 1;
         }
         else
         {
            wIStart = 0;
         }

         if (!lpxPFData->lpxPrtCmd)
         {
             fStoreAllocated = FALSE;
             break;
         }
      }
      else
      {  /* smaller than one segment */
         lpxPFData->lpxPrtCmd    = (LPByteType)ALLOCATE_MEMORY(
                                   lpxPFData->dwSwathPrintSize);
         lpxPFData->alpbSwath[0] = (LPByteType) (lpxPFData->lpxPrtCmd +
                                   SWATH_HEADER_SIZE);
         wIStart = 1;

         if     (!lpxPFData->lpxPrtCmd)
         {
             fStoreAllocated = FALSE;
             break;
         }
      }
#endif
      /* the -1 in the statement (lpxPFData->swSlicesPerSeg-1) is so we      */
      /* don't allocate a zero length buffer segment when the swath slices */
      /* per row is evenly divisible by MAX_SLICES_PER_SEG.                */
#if OAK_HEAD
      /*********************************************************************
       * This is only for 16 bit                                            *
       * allocate swath segments as following:                              *
       * [0][1]   [2][3]    [4][5]   [6][7]    [8]                          *
       * because the 64k segment size, we can only put two swath segments   *
       * (size is about 32K) close to each other.                           *
       * for [1],[3], [5] and [7], I add 200bytes more to hold extra nozzle *
       * offset, after building these swath segments, in outputswath(), we  *
       * will merge [1] and [2], [3] and [4], [7] and [8], make sure we     *
       * don't leave any data out.                                          *
       * For black swath, only need the first six swath segments,           *
       * For color swath, it may need all the swath segments.               *
       *********************************************************************/
      for (i = wIStart; i < ((WordType)(3*(lpxPFData->wSlicesPerRow)-1)/
                             (WordType)CMY_SLICES_PER_SEG); i=i+2)
      {
         /*65480=32640+32640+200*/
         lpxPFData->alpbSwath[i] =  (LPByteType)
                                    ALLOCATE_MEMORY((DwordType)65480);
         lpxPFData->alpbSwath[i+1] = (LPByteType)(lpxPFData->alpbSwath[i] +
                                                  (DwordType)32640);
#else
      for (i = wIStart; i <= ((WordType)(lpxPFData->wSlicesPerRow-1) /
          (WordType)SLICES_PER_SEG); i++)
      {
         lpxPFData->alpbSwath[i] = (LPByteType)ALLOCATE_MEMORY(
                                 ((WordType)K_BYTES_PER_SLICE *
                                  (WordType)SLICES_PER_SEG));
#endif
         if   (!lpxPFData->alpbSwath[i])
         {
            fStoreAllocated = FALSE;
            break;
         }
      }
#if OAK_HEAD
#ifndef FC_DOS_32
      lpxPFData->alpbSwath[8] =  (LPByteType)
                                 ALLOCATE_MEMORY((DwordType)32640);
      if (!lpxPFData->alpbSwath[8])
      {
         fStoreAllocated = FALSE;
         break;
      }
#endif
#endif
      if (fStoreAllocated == FALSE)
      {
         break;
      }
      /* end of allocating print swath buffer */


#if OPTION_COMPRESSION
      /* allocate compressed print swath buffer */
      if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
      {
         lpxPFData->lpxCompPrtCmd = (HPByteType)ALLOCATE_HUGE_MEMORY(
                                    lpxPFData->dwSwathPrintSize);
      }
      else
      {
         lpxPFData->lpxCompPrtCmd = (LPByteType)ALLOCATE_MEMORY(
                                    lpxPFData->dwSwathPrintSize);
      }

      if   (!lpxPFData->lpxCompPrtCmd)
      {
         fStoreAllocated = FALSE;
         break;
      }
#else
      lpxPFData->lpxCompPrtCmd = 0;
#endif

#if   OPTION_CHECKDENSITY
      /* allocate extra print swath buffer for swaths that are too dense   */
      if (lpxPFData->dwSwathPrintSize > SEGMENT_SIZE)
      {
         lpxPFData->lpxDensePrtCmd = (HPByteType)ALLOCATE_HUGE_MEMORY(
                                     lpxPFData->dwSwathPrintSize);
      }
      else
      {
         lpxPFData->lpxDensePrtCmd = (LPByteType)ALLOCATE_MEMORY(
                                     lpxPFData->dwSwathPrintSize);
      }

      if   (!lpxPFData->lpxDensePrtCmd)
      {
         fStoreAllocated = FALSE;
         break;
      }

      /* initialze the array which helps us count the dots in a swath   */
      PopulateBitCount(lpxDataRec);
#else
      lpxPFData->lpxDensePrtCmd = 0;
#endif

#if   OPTION_REVERSE_SWATH
      /* used for products that require a print swath to be built in reverse */
      lpxPFData->lpwReverseRaster = (LPWordType)
                                  ALLOCATE_MEMORY(lpxPFData->wBytesPerRow);
      if    (!lpxPFData->lpwReverseRaster)
      {
         fStoreAllocated = FALSE;
         break;
      }
#else
      lpxPFData->lpwReverseRaster = 0;
#endif

      /* get storage for several smaller 'chunks' of memory                */
      /* specifically:                                                     */
      /*       Print Line Mask   16 words                                  */
      /*       Raster Line Mask  16 words                                  */
      /*       Shingle Mask      10 shingle passes * 20 words each         */
      /*                         we are not currently using 10 shingle     */
      /*                         masks, but this allows room to grow.      */
      /*       Scan Start Array  Max Delay Buffer * Max Num Planes words   */
      /*       Scan End Array    Max Delay Buffer * Max Num Planes words   */
      /*       Shingle line      Max Delay Buffer * Max Num Planes words   */
      /*       Shingle to Apply  Max Delay Buffer * Max Num Planes bytes   */
      lpxPFData->swMaxDelayBuf = MAXBUFNUM * lpxPFData->swVertResMult;

      wMemAreaSize = (WordType)((16 + 16 + 400 +
                      (lpxPFData->swMaxDelayBuf*bColorPlanes*3))*2 +
                      (lpxPFData->swMaxDelayBuf*bColorPlanes));

      lpxPFData->lpbMemArea = (LPByteType) ALLOCATE_MEMORY(wMemAreaSize);

      if   (lpxPFData->lpbMemArea)
      {
         lpxPFData->lpwPrtMask            = (LPWordType)lpxPFData->lpbMemArea;
         lpxPFData->lpwRastMask           = (LPWordType)(lpxPFData->lpbMemArea  +
                                          32);
         lpxPFData->alpwShingleMask[0]    = (LPWordType)(lpxPFData->lpbMemArea  +
                                          32 + 32);
         lpxPFData->alpswScanStart[0]     = (LPSwordType)(lpxPFData->lpbMemArea +
                                          32 + 32 + 400);
         lpxPFData->alpswScanEnd[0]       = (LPSwordType)(lpxPFData->lpbMemArea +
                                          32 + 32 + 400 +
                                          (lpxPFData->swMaxDelayBuf *
                                         bColorPlanes * 2));
         lpxPFData->alpwShingleLine[0]    = (LPWordType) (lpxPFData->lpbMemArea +
                                          32 + 32 + 400 +
                                          (lpxPFData->swMaxDelayBuf *
                                          bColorPlanes * 2) +
                                          (lpxPFData->swMaxDelayBuf *
                                          bColorPlanes * 2));
         lpxPFData->alpbShingleToApply[0] = (LPByteType) (lpxPFData->lpbMemArea +
                                          32 + 32 + 400 +
                                          (lpxPFData->swMaxDelayBuf *
                                          bColorPlanes * 2) +
                                          (lpxPFData->swMaxDelayBuf *
                                          bColorPlanes * 2) +
                                          (lpxPFData->swMaxDelayBuf *
                                          bColorPlanes * 2));
         for (n=1;n<bColorPlanes;n++)
         {
            lpxPFData->alpswScanStart[n]     = lpxPFData->alpswScanStart[n-1] +
                                             lpxPFData->swMaxDelayBuf;
            lpxPFData->alpswScanEnd[n]       = lpxPFData->alpswScanEnd[n-1] +
                                             lpxPFData->swMaxDelayBuf;
            lpxPFData->alpwShingleLine[n]    = lpxPFData->alpwShingleLine[n-1] +
                                             lpxPFData->swMaxDelayBuf;
            lpxPFData->alpbShingleToApply[n] = lpxPFData->alpbShingleToApply[n-1] +
                                             lpxPFData->swMaxDelayBuf;
         }

         for (n=1;n<10;n++)
         {
            lpxPFData->alpwShingleMask[n] = lpxPFData->alpwShingleMask[n-1] + 20;
         }
      }
      else
      {
         fStoreAllocated = FALSE;
         break;
      }

#if OPTION_CMY_ENVELOPES
      /* allocate enough bytes to expand the input raster line to CMYK */
      /* only for printers that require envelopes be printed using CMY */
      switch (lpxDataRec->bMediaSize)
      {
      case ENVELOPE_MONARCH :
      case ENVELOPE_9 :
      case ENVELOPE_10 :
      case ENVELOPE_DL :
      case ENVELOPE_C5 :
      case ENVELOPE_B5 :
      case ENVELOPE_C6 :
      case ENVELOPE_D5 :
      case ENVELOPE_75 :
      case ENVELOPE_BARONIAL :
      case ENVELOPE_6_3_4 :
      case JPNLONG3:
      case JPNSQUARE4:
      case JPNSQUARE5:
      case JPNSQUARE6:
      case ENVELOPE_CUSTOM :
      {
         lpxPFData->lpbEnvelopeRasterLine = (LPByteType)
                                    ALLOCATE_MEMORY(300*lpxPFData->bResolution
                                                    *bColorPlanes);
         if    (!lpxPFData->lpbEnvelopeRasterLine)
         {
            fStoreAllocated = FALSE;
            break;
         }
         break;
      }
      default :
         break;
      }
#endif

#if defined(GEN_TEST_INPUT_FILES)
      lpxPFData->lpbExtendedRasterLine = (LPByteType)
                                         ALLOCATE_MEMORY(12000);
      if    (!lpxPFData->lpbExtendedRasterLine)
      {
         fStoreAllocated = FALSE;
         break;
      }
#endif

      break;   /* get out of loop unconditionally */
   } /* end of: while (fStoreAllocated) */

   return(fStoreAllocated);

}  /* end of FCInitStore(); */


/***************************************************************************
 * Function Name:    FCStartDoc
 *
 * Description:
 *    This function is expected to be called at the beginning of every print
 *    job. It allocates all global memory required by all print formatter
 *    functions.
 *
 * Inputs:  lpxDataRec        Far pointer to HBP interface structure.
 *
 * Outputs: fStoreAllocated   TRUE - storage allocation successful
 *                            FALSE - storage allocation failed
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 *************************************************************************/
WordType EXPENTRY FAR FCStartDoc(LPDVDATAREC lpxDataRec)
{
   LPPFDATA   lpxPFData;
   WordType   n ;
   BoolType   fStoreAllocated;
   ByteType   bCompressOverRide = 0;

	cairo_trace1("FCStartDoc(%p)\n", lpxDataRec);

#if CPROF
   PrfEnter(0);
#endif

#if defined(FC_WIN16_DLL)
   /* Initialize the address for the OUTPUT() macro to callers SendCommand */
   lpfnSendCommand = lpxDataRec->lpfnSendCommand;
#endif

   FCEndDoc(lpxDataRec); /* Clean up any prior or current allocated space */


   /* get lpxPFData, the print formatter common data structure   */
   lpxDataRec->lpLXDevice = (DwordType)ALLOCATE_MEMORY(COMMONBUFSIZE);
   lpxPFData = (LPPFDATA) lpxDataRec->lpLXDevice;

	cairo_trace1("lpxPFData=%p\n", lpxPFData);

   if (lpxPFData)
   {
      /* bColorPlanes and bBitsPerPixel may get updated in GetResolution */
      lpxPFData->bColorPlanes  = lpxDataRec->bColorPlanes;
      lpxPFData->bBitsPerPixel = lpxDataRec->bBitsPerPixel;

      lpxPFData->bResolution = GetResolution(lpxDataRec);
      SetBitsPerPixel(lpxDataRec);
      SetDropsPerPixel(lpxDataRec);

      /* now allocate the rest of dynamic storage the hbpcode will need    */
      fStoreAllocated = (BoolType)FCInitStore(lpxDataRec);
      cairo_trace1("FCInitStore() returned %d\n", fStoreAllocated);

      if (fStoreAllocated)
      {
         /* Set head adjustment values based on lpxDataRec input, and also */
         /* perform error checking on the lpxDataRec input values.         */
         SetCartridgeAlignment(lpxDataRec);

         /* initialize dot count to 0 for all color planes */
         for (n = 0; n < MAXNUMPLANES; n++)
         {
            lpxPFData->asdwDotCount[n] = 0;
         }

         /* get hardware printer specific buffer */
         lpxPFData->lpxHWData = (LPHWDATA ) ALLOCATE_MEMORY(HW_BUFF_SIZE);
         cairo_trace1("lpxPFData->lpxHWData=%x\n", lpxPFData->lpxHWData);

         if (lpxPFData->lpxHWData)
         {
            HwStartPrintJob(lpxDataRec);
         }
         else
         {
            fStoreAllocated = FALSE;
         }

      }   /* end of FCInitStore() sucessfull */
   }  /* end of lpxDataRec->lpLXDevice allocated */
   else
   {
      fStoreAllocated = FALSE;
   }

#if 0
   /* Get configuration values from WIN.INI for Win 9x/3x systems.      */
   /* This is just for fexlibility and development.  Defaults used when */
   /* the key is not found in WIN.INI                                   */

#if OPTION_COMPRESSION
         bCompressOverRide = (ByteType)GetProfileInt("Lexmark_Test",
                                                     "EnableCompression",
                                                      2);
         if (bCompressOverRide <= 1)
         {  /* Override with value read from WIN.INI */
            lpxDataRec->bCompress = bCompressOverRide;
         }
#endif
#endif

   return((WordType) fStoreAllocated);

} /* end of FCStartDoc() */


/***************************************************************************
 * Function Name:    FCStartPage
 *
 * Description:
 *    This function is expected to be called at the beginning of every print
 *    page.  It initializes several variables in the print formatter
 *    structure (lpxPFData), based on information in reads from the HBP
 *    interface structure (lpxDataRec).  Allocates memory when more memory
 *    is required for the current page than has been allocated.
 *
 * Inputs:  lpxDataRec  Long pointer to print device structure.
 *
 * Outputs: TRUE        Always returns successful.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/
WordType EXPENTRY FAR FCStartPage(LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   WordType    n;
   ByteType    bOldResolution;
   BoolType    fStoreAllocated;
   ByteType    bColorPlanes;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   bOldResolution = lpxPFData->bResolution;

   /* set flag to indicate this is the first move on this page */
   lpxPFData->bFirstMoveOnPage = 1;

   /* bColorPlanes and bBitsPerPixel may get updated in GetResolution         */
   /* Both are updated for printers that require envelopes be printed with CMY*/
   /* The updated values are then used in FormatInputRasterLine()             */
   lpxPFData->bColorPlanes = lpxDataRec->bColorPlanes;
   lpxPFData->bBitsPerPixel = lpxDataRec->bBitsPerPixel;

   lpxPFData->bResolution = GetResolution(lpxDataRec);
   SetBitsPerPixel(lpxDataRec);
   SetDropsPerPixel(lpxDataRec);

   bColorPlanes   = lpxPFData->bColorPlanes;

   /* Test for page boundry changes which will require us to reallocate    */
   /* memory.  Notice that we do not reallocate memory if we have too much */
   /* memory allocated for the current page.  We only reallocate memory if */
   /* we don't have enough memory allocated for the current page.          */
   /* However for bits per pixel, we reallocate memory whenever the value  */
   /* changes, whether its higher or lower.                                */

   /* Changed to reallocate when resolution changes, since FCInitStore()   */
   /* sets the resoulution multipliers based on resolution.                */

   if ( (lpxPFData->bOldResolution   !=  lpxPFData->bResolution)   ||
        (lpxPFData->bOldColorPlanes  !=  lpxPFData->bColorPlanes)  ||
        (lpxPFData->bOldBitsPerPixel !=  lpxPFData->bBitsPerPixel) ||
        (lpxPFData->wOldSwathWidth   <   lpxDataRec->wSwathWidth)   )
   {
      FCKillStore(lpxDataRec); /* release resolution dependent storage */

      /* allocate resolution dependent storage */
      fStoreAllocated = (BoolType)FCInitStore(lpxDataRec);
      if (fStoreAllocated == FALSE)
      {
         return(FALSE);
      }
   }

   lpxPFData->sdwRowPos      = -1;         /* raster row number begins at 0 */
   lpxPFData->bPrintQuality  = lpxDataRec->bQuality;
   lpxPFData->fSwathPresent  = FALSE;

   /* order is important! Resolution must be set before margins are set */
   lpxPFData->wLeftMargin              = GetLeftMargin(lpxDataRec);
   lpxPFData->wTopMargin               = GetTopMargin(lpxDataRec);
   lpxPFData->swFormsMovePending       = (SwordType)lpxPFData->wTopMargin;
   lpxPFData->swFutureFormsMovePending = 0;
   lpxPFData->bShingle                 = GetShingleMode(lpxDataRec);

   for (n=0; n<bColorPlanes; n++)
   {
      lpxPFData->awExtraNozzles[n] = 0;
      lpxPFData->abShingleIndex[n] = COLOR;
   }

   switch (lpxPFData->bColorPlanes)
   {
   case 1 :
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) ||
           (lpxPFData->bResolution == HIRES_NONINTERLACED) )
      {
         lpxPFData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT;
         lpxPFData->abShingleIndex[0] = MONO_PART;
      }
      else
      {
#if OAK_HEAD
         lpxPFData->wBaseNozzleCount  = MONO_NOZZLE_COUNT/2;
#else
         lpxPFData->wBaseNozzleCount  = MONO_NOZZLE_COUNT;
#endif
         lpxPFData->abShingleIndex[0] = MONO_FULL;
      }
      break;
   case 3 :
#if OAK_HEAD
      lpxPFData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT/3-16;
#else
      lpxPFData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT/3;
#endif
      break;
   case 4 :
#if OAK_HEAD
      lpxPFData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT/3-16;
      lpxPFData->awExtraNozzles[3] = 0;
#else
      lpxPFData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT/3;
      lpxPFData->awExtraNozzles[3] = COLOR_NOZZLE_COUNT - (COLOR_NOZZLE_COUNT/3);
#endif


      lpxPFData->abShingleIndex[3] = MONO_PART;
      break;
   case 6 :
      lpxPFData->wBaseNozzleCount  = COLOR_NOZZLE_COUNT/3;
      break;
   }


#if 0
   if ( (lpxPFData->bResolution == HIRES_INTERLACED) &&
        (lpxPFData->bShingle == SHINGLE_25))
   {
      /* 25% shingling at the interlacing high resolution is not supported */
      lpxPFData->bShingle = SHINGLE_50;
   }
#endif

   /* Added following to support printing 1200dpi as 2 pass 600dpi.            */
   /* These are only used for 1200 dpi that is 50% shingled printed at 600 dpi */
   /* Initialize these at the start of each page when in 1200 dpi mode.        */
   if ( (lpxPFData->bResolution == HIRES_INTERLACED) && (lpxDataRec->bMediaType == GLOSSY_PAPER) &&
      ((lpxDataRec->bColorPlanes == 3) || (lpxDataRec->bColorPlanes == 4)) )
   {
      lpxPFData->wCMYEvenRasterSlice = 0;  /* start with even slice CMY head */
      lpxPFData->wCMYOddRasterSlice  = 0;  /* start with odd slice CMY head */
      lpxPFData->wBLKEvenRasterSlice = 0;  /* start with even slice Black head */
      lpxPFData->wBLKOddRasterSlice  = 0;  /* start with odd slice Black head */
      lpxPFData->wKCMEvenRasterSlice = 0;  /* start with even slice KCM head*/
      lpxPFData->wKCMOddRasterSlice  = 0;  /* start with odd slice KCM head */
   }
   else if ( lpxPFData->bResolution == HIRES_INTERLACED)
   {
      lpxPFData->wCMYEvenRasterSlice = 0;  /* start with even slice CMY head */
      lpxPFData->wCMYOddRasterSlice  = 1;  /* start with odd slice CMY head */
      lpxPFData->wBLKEvenRasterSlice = 0;  /* start with even slice Black head */
      lpxPFData->wBLKOddRasterSlice  = 1;  /* start with odd slice Black head */
      lpxPFData->wKCMEvenRasterSlice = 0;  /* start with even slice KCM head*/
      lpxPFData->wKCMOddRasterSlice  = 1;  /* start with odd slice KCM head */
   }

#if OPTION_CDE
   /* Consecutive dot elimination is used for ink depletion for some printers
      in certain modes.                                                    */
   lpxPFData->fCDE = CheckForCDE(lpxDataRec, lpxDataRec->bQuality);
   if (lpxPFData->bShingle != NO_SHINGLE)
   {
      lpxPFData->fCDE = FALSE;
   }
#endif

   FCSetPaperSource(lpxDataRec);

   LoadShingleMasks(lpxDataRec, bColorPlanes);

   switch (bColorPlanes)
   {  /* Set print mode, beginning and ending delay buffer, and initial    */
      /* delay for delay buffers                                           */

   case 1 : /* black only */
      lpxPFData->swDelayBufStart = 0;
      lpxPFData->swDelayBufEnd   = 1;
      lpxPFData->asdwDBIndx[INIT_DELAY][0] = KONLY_P4_DELAY;
      lpxPFData->bPrintHead = MONO_CARTRIDGE;
      break;

   case 3 : /* CMY */
      lpxPFData->swDelayBufStart = 0;
      lpxPFData->swDelayBufEnd   = 3;
      lpxPFData->asdwDBIndx[INIT_DELAY][0] = CMY_P1_DELAY;
      lpxPFData->asdwDBIndx[INIT_DELAY][1] = CMY_P2_DELAY;
      lpxPFData->asdwDBIndx[INIT_DELAY][2] = CMY_P3_DELAY;
      lpxPFData->bPrintHead = COL_CARTRIDGE;
      break;

   case 4 : /* CMYK */
      lpxPFData->swDelayBufStart = 0;
      lpxPFData->swDelayBufEnd   = 4;

      lpxPFData->asdwDBIndx[INIT_DELAY][0] = (SdwordType)(CMYK_P1_DELAY +
                                             lpxPFData->swHead1VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][1] = (SdwordType)(CMYK_P2_DELAY +
                                             lpxPFData->swHead1VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][2] = (SdwordType)(CMYK_P3_DELAY +
                                             lpxPFData->swHead1VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][3] = (SdwordType)(CMYK_P4_DELAY +
                                             lpxPFData->swHead2VertAdjust);
      break;

   case 6 : /* CMYKCM */
      lpxPFData->swDelayBufStart = 0;
      lpxPFData->swDelayBufEnd   = 6;

      lpxPFData->asdwDBIndx[INIT_DELAY][0] = (SdwordType)(CMYKCM_P1_DELAY +
                                             lpxPFData->swHead1VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][1] = (SdwordType)(CMYKCM_P2_DELAY +
                                             lpxPFData->swHead1VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][2] = (SdwordType)(CMYKCM_P3_DELAY +
                                             lpxPFData->swHead1VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][3] = (SdwordType)(CMYKCM_P4_DELAY +
                                             lpxPFData->swHead2VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][4] = (SdwordType)(CMYKCM_P5_DELAY +
                                             lpxPFData->swHead2VertAdjust);
      lpxPFData->asdwDBIndx[INIT_DELAY][5] = (SdwordType)(CMYKCM_P6_DELAY +
                                             lpxPFData->swHead2VertAdjust);
      break;

   default :
      break;
   }  /* End of: Set print mode, beginning and ending delay buffer, and    */
      /* initial delay for delay buffers                                   */

   ResetBuffers(0L,lpxDataRec);

   lpxPFData->lpwPrtMask[0] = PRINT_MASK0;
   lpxPFData->lpwPrtMask[1] = PRINT_MASK1;
   lpxPFData->lpwPrtMask[2] = PRINT_MASK2;
   lpxPFData->lpwPrtMask[3] = PRINT_MASK3;
   lpxPFData->lpwPrtMask[4] = PRINT_MASK4;
   lpxPFData->lpwPrtMask[5] = PRINT_MASK5;
   lpxPFData->lpwPrtMask[6] = PRINT_MASK6;
   lpxPFData->lpwPrtMask[7] = PRINT_MASK7;
   lpxPFData->lpwPrtMask[8] = PRINT_MASK8;
   lpxPFData->lpwPrtMask[9] = PRINT_MASK9;
   lpxPFData->lpwPrtMask[10] = PRINT_MASK10;
   lpxPFData->lpwPrtMask[11] = PRINT_MASK11;
   lpxPFData->lpwPrtMask[12] = PRINT_MASK12;
   lpxPFData->lpwPrtMask[13] = PRINT_MASK13;
   lpxPFData->lpwPrtMask[14] = PRINT_MASK14;
   lpxPFData->lpwPrtMask[15] = PRINT_MASK15;

   lpxPFData->lpwRastMask[0] = RASTER_MASK0;
   lpxPFData->lpwRastMask[1] = RASTER_MASK1;
   lpxPFData->lpwRastMask[2] = RASTER_MASK2;
   lpxPFData->lpwRastMask[3] = RASTER_MASK3;
   lpxPFData->lpwRastMask[4] = RASTER_MASK4;
   lpxPFData->lpwRastMask[5] = RASTER_MASK5;
   lpxPFData->lpwRastMask[6] = RASTER_MASK6;
   lpxPFData->lpwRastMask[7] = RASTER_MASK7;
   lpxPFData->lpwRastMask[8] = RASTER_MASK8;
   lpxPFData->lpwRastMask[9] = RASTER_MASK9;
   lpxPFData->lpwRastMask[10] = RASTER_MASK10;
   lpxPFData->lpwRastMask[11] = RASTER_MASK11;
   lpxPFData->lpwRastMask[12] = RASTER_MASK12;
   lpxPFData->lpwRastMask[13] = RASTER_MASK13;
   lpxPFData->lpwRastMask[14] = RASTER_MASK14;
   lpxPFData->lpwRastMask[15] = RASTER_MASK15;

   HwStartPage(lpxDataRec);

#if defined(GEN_TEST_INPUT_FILES)   /* include test file generation */
   {
      for (n=0; n<4; n++)
      {
         lpxPFData->lpbExtendedRasterLine[n] = 'X';
      }

      lpxPFData->lpbExtendedRasterLine[4]  = lpxDataRec->bColorPlanes;
      lpxPFData->lpbExtendedRasterLine[5]  = 0x00;
      lpxPFData->lpbExtendedRasterLine[6]  = (ByteType) lpxPFData->swRastResMult;
      lpxPFData->lpbExtendedRasterLine[7]  = 0x00;
      lpxPFData->lpbExtendedRasterLine[8]  = (ByteType) LOBYTE(lpxPFData->wTopMargin);
      lpxPFData->lpbExtendedRasterLine[9]  = (ByteType) HIBYTE(lpxPFData->wTopMargin);
      lpxPFData->lpbExtendedRasterLine[10] = 0x4b;
      lpxPFData->lpbExtendedRasterLine[11] = 0x00;
#if 0
      lpxPFData->lpbExtendedRasterLine[8]  = (ByteType) LOBYTE(lpxPFData->wTopMargin);
      lpxPFData->lpbExtendedRasterLine[9]  = (ByteType) HIBYTE(lpxPFData->wTopMargin);
      lpxPFData->lpbExtendedRasterLine[10] = (ByteType) LOBYTE(lpxPFData->wLeftMargin);
      lpxPFData->lpbExtendedRasterLine[11] = (ByteType) HIBYTE(lpxPFData->wLeftMargin);
#endif
      lpxPFData->lpbExtendedRasterLine[12] = (ByteType) lpxDataRec->bVerticalAdj;
      lpxPFData->lpbExtendedRasterLine[13] = 0x00;

      SendRasters((void FAR *)lpxDataRec, lpxPFData->lpbExtendedRasterLine, 14);
   }
#endif   /* defined GEN_TEST_INPUT_FILES */

   return(TRUE);
} /* end of FCStartPage() */


/***************************************************************************
 * Function Name:    FCEndPage
 *
 * Description:
 *    This function ***MUST*** be called at the end of every print page.  It
 *    calls function FlushBuffers(), which formats and prints all raster
 *    lines that are in the delay buffers.
 *
 * Inputs:  lpxDataRec    Long pointer to print device structure.
 *
 * Outputs: <none>
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/
void EXPENTRY FAR FCEndPage(LPDVDATAREC lpxDataRec)
{
   FlushBuffers(lpxDataRec,END_OF_PAGE);

   HwEndPage(lpxDataRec);

   return;

}  /* End of FCEndPage() */


/***************************************************************************
 * Function Name:    FCEndDoc
 *
 * Description:
 *    This function ***MUST*** be called at the end of every print job.  It
 *    frees all fixed size memory that was allocated in FCStartDoc().
 *
 * Inputs:  lpxDataRec    Long pointer to print device structure.
 *
 * Outputs: <none>
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 **************************************************************************/
void EXPENTRY FAR FCEndDoc(LPDVDATAREC lpxDataRec)
{
   LPPFDATA lpxPFData;

   if   (lpxDataRec)
   {
      lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

      if (lpxPFData)
      {  /* storage is allocated, so free it */
      
          /* AA, 9th August 2000: Added condition to stop HwEndJob() from
           * being called in cases where lpxHWData is NULL (because allocation
           * failed) causing as data abort.
           */
          if (NULL != lpxPFData->lpxHWData)
             HwEndJob(lpxDataRec);

          FCKillStore(lpxDataRec);/* release resolution dependent storage */

          if (lpxPFData->lpxHWData)
          {
             FREE_MEMORY(lpxPFData->lpxHWData);
          }

          FREE_MEMORY(lpxPFData);
          lpxDataRec->lpLXDevice = 0x00;

      }  /* end of freeing storage allocation */
   }

#if CPROF
   PrfExit(0);
#endif
   return;

}  /* End of FCEndDoc() */


/***************************************************************************
 * Function Name:    ResetBuffers
 *
 * Description:
 *    This function initializes the IN and OUT indexes that point into the
 *    delay buffers.  It should be called every time the delay buffers have
 *    been emptied and need to be reinitialized.
 *
 * Inputs:  lpxDataRec    Long pointer to HBP interface structure.
 *
 * Outputs: Initializes the IN and OUT indexes which point into the color
 *          plane delay buffers.
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 *************************************************************************/
void ResetBuffers(SdwordType lCurrentRowPos, LPDVDATAREC lpxDataRec)
{
   LPPFDATA    lpxPFData;
   WordType    n,m,
               wShingleSize,
               wNozzleCount;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   lpxPFData->sdwRasterLinesProcessed = 0;
   lpxPFData->sdwRowsToProcess        = (SdwordType)lpxPFData->wBaseNozzleCount;
   lpxPFData->swFutureRowsToShingle   = 0;
   lpxPFData->swOut                   = FC_OUT;
#if OAK_HEAD
   lpxPFData->bPrintDirection          = LTOR;
   lpxPFData->wPass                    = 1;
#else
   lpxPFData->bBIDIPrintDirection     = LTOR;
#endif
   lpxPFData->sdwBottomNozzleRowNum   = lCurrentRowPos - 1;

   for (n=(WordType)lpxPFData->swDelayBufStart; n<(WordType)lpxPFData->swDelayBufEnd; n++)
   {
      wNozzleCount = lpxPFData->wBaseNozzleCount + lpxPFData->awExtraNozzles[n];
      lpxPFData->asdwDBIndx[FC_IN][n]  = 0;
      lpxPFData->awRowsToDelayPrint[n] = 0;
      lpxPFData->awRowsToPrint[n]      = 0;
      lpxPFData->awRowsToDelayFree[n]  = 0;
      lpxPFData->asdwFirstRowOfSection[FC_OUT][n] = lCurrentRowPos;
      for (m=0; m<(WordType)lpxPFData->swMaxDelayBuf; m++)
      {
         lpxPFData->alpbShingleToApply[n][m] = SHINGLE_THRU;
      }
   }

   for (n=(WordType)lpxPFData->swDelayBufStart; n<(WordType)lpxPFData->swDelayBufEnd; n++)
   {
      lpxPFData->asdwDBIndx[FC_OUT][n] = -(lpxPFData->asdwDBIndx[INIT_DELAY][n]);
      lpxPFData->asdwFirstRowOfSection[FC_OUT_EVEN][n] = -9999L;
      lpxPFData->asdwFirstRowOfSection[FC_OUT_ODD][n]  = -9999L;

      if (lpxPFData->bResolution == HIRES_INTERLACED)
      {
         wNozzleCount = lpxPFData->wBaseNozzleCount +
                        lpxPFData->awExtraNozzles[n];
         if ((lpxPFData->bColorPlanes == 4) && (n==3))
         {
            wShingleSize = wNozzleCount / (WordType)3;
         }
         else if (lpxPFData->bShingle == NO_SHINGLE)
         {
            wShingleSize = wNozzleCount;
         }
         else if (lpxPFData->bShingle == SHINGLE_50)
         {
            wShingleSize = wNozzleCount / (WordType)2;
         }
         else
         {  /* 25% shingling */
            wShingleSize = wNozzleCount / (WordType)4;
         }
         lpxPFData->asdwDBIndx[FC_OUT][n] = -( lpxPFData->asdwDBIndx[INIT_DELAY][n]
                                 + (wNozzleCount - wShingleSize));
         lpxPFData->asdwDBIndx[FC_OUT_EVEN][n] = (lpxPFData->asdwDBIndx[FC_OUT][n]
                                 * 2 - (SwordType)(wShingleSize + 3));
         lpxPFData->asdwDBIndx[FC_OUT_ODD][n] = (SwordType)
                                 (lpxPFData->asdwDBIndx[FC_OUT][n]*2);
      }
   }


/* TEST / DEVELOPMENT */
/* VERIFY HOW THIS SHOULD WORK FOR HIGH RES 8 PASS PRINTING */
   if ( (lpxPFData->bColorPlanes == 4) &&
        (lpxPFData->bResolution == HIRES_INTERLACED) &&
        (lpxPFData->bShingle == SHINGLE_50) )
   {
      /* Note that FC_OUT_EVEN is adjusted by the Color Shingle Size and   */
      /* not Mono Shingle Size.  This is correct.                          */
      lpxPFData->asdwDBIndx[FC_OUT_EVEN][3] = (SwordType)
                                     ((lpxPFData->asdwDBIndx[FC_OUT][3]*2)-
                                     ((lpxPFData->wBaseNozzleCount/2) + 3));
   }
   else if ( (lpxPFData->bColorPlanes == 4) &&
        (lpxPFData->bResolution == HIRES_INTERLACED) &&
        (lpxPFData->bShingle == SHINGLE_25) )
   {
      /* Note that FC_OUT_EVEN is adjusted by the Color Shingle Size and   */
      /* not Mono Shingle Size.  This is correct.                          */
      lpxPFData->asdwDBIndx[FC_OUT_EVEN][3] = (SwordType)
                                     ((lpxPFData->asdwDBIndx[FC_OUT][3]*2)-
                                     ((lpxPFData->wBaseNozzleCount/4) + 3));
   }


   if (lpxPFData->bResolution == HIRES_INTERLACED)
   {
      if (lpxPFData->bShingle == NO_SHINGLE)
      {
         wShingleSize = lpxPFData->wBaseNozzleCount;
      }
      else if (lpxPFData->bShingle == SHINGLE_50)
      {
         wShingleSize = lpxPFData->wBaseNozzleCount / (WordType)2;
      }
      else
      {
         wShingleSize = lpxPFData->wBaseNozzleCount / (WordType)4;
      }
      lpxPFData->sdwRowsToProcess = (SdwordType)(wShingleSize - 3); /* HIRES */
      lpxPFData->swOut = FC_OUT_EVEN;
   }

   lpxPFData->aswDelayKSwath[FC_OUT] = 0;
   lpxPFData->aswDelayKSwath[FC_OUT_EVEN] = 0;
   lpxPFData->aswDelayKSwath[FC_OUT_ODD] = 0;

   for (n=(WordType)lpxPFData->swDelayBufStart; n<(WordType)lpxPFData->swDelayBufEnd; n++)
   {
      lpxPFData->asdwDBIndx[FC_OUT][n] = lCurrentRowPos;
   }

   return;

}  /* End of ResetBuffers() */


/***************************************************************************
 * Function Name:    FCOutputStrip
 *
 * Description:
 *    This is the interface function between the rest of the printer driver
 *    and the print formatter code.  It adds any necessary white space
 *    between the current raster line and the previous raster line.
 *    Calls ProcessRaster() to add the current raster line to the
 *    delay buffers.
 *
 * Inputs:  lpxDataRec     Long pointer to print device structure.
 *          lpbRasterLine  Long pointer to the raster line to be processed.
 *          dwStripStrart  The absolute vertical position of this raster
 *                         line on the page.  Begins at 0.
 *          swScanStart    The horizontal starting position of valid data
 *                         within the raster line.  Begin at 0.
 *                         When called with ScanStart > ScanEnd a blank
 *                         raster line will be generated.
 *          swScanEnd      The horizontal ending position of the valid
 *                         data within the raster line. nScanEnd points
 *                         one byte beyond the last good data byte.
 *
 * Outputs: Always returns 0
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 *************************************************************************/
WordType EXPENTRY FAR FCOutputStrip(LPDVDATAREC lpxDataRec,
                              LPByteType lpbRasterLine, SdwordType lStripStart,
                              SwordType swScanStart, SwordType swScanEnd)
{
   LPPFDATA    lpxPFData;
   WordType    i;
   SdwordType  n, lRows;
   SdwordType  lRowsMoved;
   SdwordType  lStripNum;
   SdwordType  lOutOfPhaseLines;
   ByteType    bPlanes;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;
   lpxPFData->lpbInPtr = lpbRasterLine;

#if CPROF
   lpxPFData->TotalRasterLines++;
   lpxPFData->TotalRasterWidth += (swScanEnd - swScanStart);
#endif

#if defined(GEN_TEST_INPUT_FILES)
   {
      WordType wByteCount;

      for (i=0; i<4; i++)
      {
         lpxPFData->lpbExtendedRasterLine[i] = 'X';
      }
      lpxPFData->lpbExtendedRasterLine[4] = LOBYTE(LOWORD(lStripStart));
      lpxPFData->lpbExtendedRasterLine[5] = HIBYTE(LOWORD(lStripStart));
      lpxPFData->lpbExtendedRasterLine[6] = LOBYTE(swScanStart);
      lpxPFData->lpbExtendedRasterLine[7] = HIBYTE(swScanStart);
      lpxPFData->lpbExtendedRasterLine[8] = LOBYTE(swScanEnd);
      lpxPFData->lpbExtendedRasterLine[9] = HIBYTE(swScanEnd);

      if (lpxPFData->bBitsPerPixel == 2)
      {
         wByteCount = (WordType)300 * lpxPFData->swRastResMult *
                      (lpxPFData->bColorPlanes+3);
      }
      else
      {
         wByteCount = (WordType)300 * lpxPFData->swRastResMult *
                      lpxPFData->bColorPlanes;
      }

      for (i=0; i<wByteCount; i++)
      {
         lpxPFData->lpbExtendedRasterLine[i+10] = lpbRasterLine[i];
      }

      SendRasters((void FAR *)lpxDataRec, lpxPFData->lpbExtendedRasterLine,
                  (wByteCount+10));
      return(0);  /* Return to drive without going thru formatter code */
   }
#endif

   if (lpxPFData->bResolution == SUPERLOWRES)
   {
      /* For the 7000 print head in draft mode convert from 300 to 600 dpi
         in the vertical direction. Raster line will be printed twice.    */
      lStripStart *= 2;
   }

   /* use number of planes from DataRec rather than PFData.  The number
      of planes in PFData may be larger when printing envelopes using CMY
      but in this case we only need to adjust the single input black plane */
   bPlanes =  lpxDataRec->bColorPlanes;

   if  (lpxDataRec->bBitsPerPixel == 2 && lpxDataRec->bColorPlanes > 1 )
   {  /* add second planes for CMY head for 2 bits per pixel */
      bPlanes += 3;
   }

   /* Align swScanStart to WordType boundary */
   if (swScanStart%2)
   {
      swScanStart--;

      for (i = 0;i < bPlanes; i++)
      {
         /* make sure the extra byte added is blank */
         lpbRasterLine[(i*lpxPFData->wBytesPerRow)+swScanStart] = 0x00;
      }
   }

   /* Align swScanEnd to WordType boundary */
   if (swScanEnd%2)
   {
      for (i = 0;i < bPlanes; i++)
      {
         /* make sure the extra byte added is blank */
         lpbRasterLine[(i*lpxPFData->wBytesPerRow)+swScanEnd] = 0x00;
      }
      swScanEnd++;
   }

   lRows = lStripStart - lpxPFData->sdwRowPos;

   /* Row number (vertical position down page) must always increase with
      each call.  */
   if (lRows < 0)
   {
      /* Return error. Row number less than last call. */
      return 1;
   }

   /* In the if() statement below, the +4 added to the skip amount         */
   /* calculation was added to account for high resolution "in phase"      */
   /* adjustments.  This means that for high resolution large vertical     */
   /* movements (600dpi for the 4076 based printers, and 1200dpi for the   */
   /* babbage based printers), the next raster line after the move must be */
   /* evenly divisible by 300.  The move is then "in phase".               */
   if ((lRows > 1) && (lRows <= ((SdwordType)
                                (lpxPFData->swMaxDelayBuf+MONO_NOZZLE_COUNT+4))))
   {  /* small whitespace skip, so just feed blank raster lines */
      lStripNum = lStripStart - (lRows-1);
      for (n=0; n<(lRows-1); n++)
      {
         /* Add a blank raster line by making ScanStart > ScanEnd */
         lpxPFData->sdwRowPos++;
         ProcessRaster(lpxDataRec, lStripNum, lpxPFData->wBytesPerRow, 0);
         lStripNum++;
      }
   }
   else if (lRows > 1 )
   {
      /* large whitespace skip, so flush buffers and then move             */
      /* lOutOfPhaseLines will be equal to 0, 1, 2, or 3.  And this is the */
      /* number of blank lines we need to send to ProcessRaster() before   */
      /* sending the lStripStart raster line.  These blank raster lines    */
      /* affect how much of a large skip vertical move we make, and this   */
      /* is how we are guaranteeing our moves to be "in phase".            */
      lOutOfPhaseLines = VerticalMoveInPhase(lpxDataRec, lStripStart);

      lRowsMoved = (SdwordType)FlushBuffers(lpxDataRec,MIDDLE_OF_PAGE);
      ResetBuffers((lStripStart - lOutOfPhaseLines), lpxDataRec);
      /* Calculate amount to move before 2nd swath is printed */
      lpxPFData->swFutureFormsMovePending += (SwordType)
                                 ((lRows - lRowsMoved - lOutOfPhaseLines - 1));

      /* now send the necessary blank lines which ensured the large        */
      /* vertical movement was "in phase".                                 */
      lStripNum = lStripStart - lOutOfPhaseLines;
      lpxPFData->sdwRowPos = lStripNum;
      for (n = 0; n < lOutOfPhaseLines; n++)
      {
         ProcessRaster(lpxDataRec, lStripNum, lpxPFData->wBytesPerRow, 0);
         lStripNum++;
         lpxPFData->sdwRowPos++;
      }
   }

   /* now process the current raster line */
   lpxPFData->sdwRowPos = lStripStart;
   ProcessRaster(lpxDataRec, lStripStart, swScanStart, swScanEnd);

   if (lpxPFData->bResolution == SUPERLOWRES)
   {
      /* Send the raster line again for the 7000 print head in draft mode
         to generate 600 dpi in the vertical direction.  */
      lStripStart++;
      lpxPFData->sdwRowPos = lStripStart;
      ProcessRaster(lpxDataRec, lStripStart, swScanStart, swScanEnd);
   }

   return(0);

}  /* End of FCOutputStrip() */


/***************************************************************************
 * Description:
 *    Loads the correct shingle masks based on the number of color planes
 *    for this page, and the shingle mode requested.
 *
 * Inputs:  bNumPlanes     Number of color planes for this page.
 *          lpxPFData        Long pointer to our internal data structure.
 *
 * Outputs: initializes the shingle mask lpxPFData->alpwShingleMask[].
 *
 * Original Author: J. Bates
 * Date: 09/27/96
 *
 *************************************************************************/
void LoadShingleMasks(LPDVDATAREC lpxDataRec, ByteType bNumPlanes)
{
   LPPFDATA    lpxPFData;
   SwordType   n, swNozCnt;
   ByteType    bSI;
   WordType    wNC;

   lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

   switch (bNumPlanes)
   {
   case 1 :
      if ( (lpxPFData->bResolution == HIRES_INTERLACED) ||
           (lpxPFData->bResolution == HIRES_NONINTERLACED) )
      {

#if OAK_HEAD
         lpxPFData->swMonoNozzleCount  = MONO_NOZZLE_COUNT/2;
#else
         lpxPFData->swMonoNozzleCount  = COLOR_NOZZLE_COUNT;
#endif

      }
      else
      {
#if OAK_HEAD
         lpxPFData->swMonoNozzleCount  = MONO_NOZZLE_COUNT/2;
#else
         lpxPFData->swMonoNozzleCount  = MONO_NOZZLE_COUNT;
#endif
      }
      swNozCnt = lpxPFData->swMonoNozzleCount;
      break;

   case 4 :

#if OAK_HEAD
      lpxPFData->swMonoNozzleCount = MONO_NOZZLE_COUNT/2;   /* alignment nozzles subtraction can be moved here from rotate.c*/
#else
      lpxPFData->swMonoNozzleCount = COLOR_NOZZLE_COUNT;
#endif
      /* intentionally falling through to CMY case */

   case 3 :
   case 6 :
      lpxPFData->swColorNozzleCount = COLOR_NOZZLE_COUNT/3;
   }



   lpxPFData->alpwShingleMask[SHINGLE_MASK_50][0] = 0xAAAA;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_50][1] = 0x5555;

   lpxPFData->alpwShingleMask[SHINGLE_MASK_25][0] = 0x8888;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_25][1] = 0x4444;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_25][2] = 0x2222;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_25][3] = 0x1111;

   lpxPFData->alpwShingleMask[SHINGLE_MASK_33][0] = 0x9292;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_33][1] = 0x4949;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_33][2] = 0x2424;

   lpxPFData->alpwShingleMask[SHINGLE_MASK_16][0] = 0x8282;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_16][1] = 0x4141;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_16][2] = 0x2020;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_16][3] = 0x1010;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_16][4] = 0x0808;
   lpxPFData->alpwShingleMask[SHINGLE_MASK_16][5] = 0x0404;

   /* Each shingle pattern has a top range of the printhead portion it can */
   /* be printed with.  The top range will be from top nozzle down to a    */
   /* certain nozzle value.  Calculate and store these values.             */
   for (n=0;n<3;n++)
   {
      if (n==0)
      {
         bSI = COLOR;
#if OAK_HEAD
         wNC = COLOR_NOZZLE_COUNT / 3 -16;
#else
         wNC = COLOR_NOZZLE_COUNT / 3;
#endif
      }
      else if (n==1)
      {
         bSI = MONO_FULL;
#if OAK_HEAD
         wNC = MONO_NOZZLE_COUNT/2;
#else
         wNC = MONO_NOZZLE_COUNT;
#endif
      }
      else
      {
         bSI = MONO_PART;
#ifdef OAK_HEAD
         wNC = MONO_NOZZLE_COUNT/2-16;
#else
         wNC = COLOR_NOZZLE_COUNT;
#endif
      }

      lpxPFData->awShingleThreshold[bSI][SHINGLE_0_1]  = 0;

#if OPTION_VARIABLE_MONO_NOZZLES
      /* The following if() statement allows us to use a variable number   */
      /* of bottom black nozzles when printing envelopes.  This allows     */
      /* more drying time for the black ink.                               */
      if ( ((bSI == MONO_FULL) || (bSI == MONO_PART)) &&
           ((GetMonoNozzlesToUse(lpxDataRec)) != 0) )
      {
         lpxPFData->awShingleThreshold[bSI][SHINGLE_0_1]  =
                           wNC - (GetMonoNozzlesToUse(lpxDataRec));
      }
#endif

      lpxPFData->awShingleThreshold[bSI][SHINGLE_50_1] = wNC/2;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_50_2] = 0;

      lpxPFData->awShingleThreshold[bSI][SHINGLE_25_1] = wNC - wNC/4;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_25_2] = wNC - 2*wNC/4;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_25_3] = wNC - 3*wNC/4;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_25_4] = 0;

      if (bSI == COLOR)
      {
         lpxPFData->awShingleThreshold[bSI][SHINGLE_33_1] = wNC -
                                             PCT33_COLOR_NOZZLES;
         lpxPFData->awShingleThreshold[bSI][SHINGLE_33_2] = wNC -
                                             2 * (PCT33_COLOR_NOZZLES);
      }
      else if (bSI == MONO_FULL)
      {
         lpxPFData->awShingleThreshold[bSI][SHINGLE_33_1] = wNC -
                                             PCT33_MONO_FULL_NOZZLES;
         lpxPFData->awShingleThreshold[bSI][SHINGLE_33_2] = wNC -
                                             (2 * PCT33_MONO_FULL_NOZZLES);
      }
      else
      {
         lpxPFData->awShingleThreshold[bSI][SHINGLE_33_1] = wNC - wNC/3;
         lpxPFData->awShingleThreshold[bSI][SHINGLE_33_2] = wNC - (2*(wNC/3));
      }

      lpxPFData->awShingleThreshold[bSI][SHINGLE_33_3] = 0;

      lpxPFData->awShingleThreshold[bSI][SHINGLE_16_1] = wNC - wNC/6;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_16_2] = wNC - 2*wNC/6;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_16_3] = wNC - 3*wNC/6;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_16_4] = wNC - 4*wNC/6;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_16_5] = wNC - 5*wNC/6;
      lpxPFData->awShingleThreshold[bSI][SHINGLE_16_6] = 0;
   }

   return;
}   /* end of LoadShingleMask() */


/****************************************************************************
 * Function Name:    FCGetInkUsage
 *
 * Description:
 *    This is the interface function between the rest of the printer driver
 *    and the print formatter code.  It returns to the driver the dot count
 *    for all the inks.  The driver is responsible for accumulating and
 *    storing the dot counts.  The print formatter code dot counts are
 *    zeroed with each call.  This function must be called within calles to
 *    FCStartDoc/FCEndDoc because the dot count data structure is allocated
 *    in FCStartDoc.
 *
 * Inputs:  lpxDataRec    Long pointer to print device structure.
 *          lpDotCounts  Data structure for returning the dot counts
 *                       for 6 inks.
 *
 * Outputs: lpDotCounts  Dot counts for all 6 inks.
 *
 * Original Author: K. Profitt
 * Date: 01/18/97
 *
 ***************************************************************************/
void EXPENTRY FAR FCGetInkUsage( LPDVDATAREC lpxDataRec,
                                 LPDOTCOUNTS lpDotCounts)
{
   LPPFDATA    lpxPFData;
   SwordType   n;

   if   (lpxDataRec)
   {   /* non NULL lpxDataRec pointer */
       lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;

       switch (lpxDataRec->bColorPlanes)
       {
       case 1 :
          lpDotCounts->sdwInk1 = lpxPFData->asdwDotCount[0];
          lpDotCounts->sdwInk2 = 0;
          lpDotCounts->sdwInk3 = 0;
          lpDotCounts->sdwInk4 = 0;
          lpDotCounts->sdwInk5 = 0;
          lpDotCounts->sdwInk6 = 0;
          break;

       case 3 :
          lpDotCounts->sdwInk1 = lpxPFData->asdwDotCount[0];
          lpDotCounts->sdwInk2 = lpxPFData->asdwDotCount[1];
          lpDotCounts->sdwInk3 = lpxPFData->asdwDotCount[2];
          lpDotCounts->sdwInk4 = 0;
          lpDotCounts->sdwInk5 = 0;
          lpDotCounts->sdwInk6 = 0;
          break;

       case 4 :
          lpDotCounts->sdwInk1 = lpxPFData->asdwDotCount[0];
          lpDotCounts->sdwInk2 = lpxPFData->asdwDotCount[1];
          lpDotCounts->sdwInk3 = lpxPFData->asdwDotCount[2];
          lpDotCounts->sdwInk4 = lpxPFData->asdwDotCount[3];
          lpDotCounts->sdwInk5 = 0;
          lpDotCounts->sdwInk6 = 0;
          break;

       case 6 :
          lpDotCounts->sdwInk1 = lpxPFData->asdwDotCount[0];
          lpDotCounts->sdwInk2 = lpxPFData->asdwDotCount[1];
          lpDotCounts->sdwInk3 = lpxPFData->asdwDotCount[2];
          lpDotCounts->sdwInk4 = lpxPFData->asdwDotCount[3];
          lpDotCounts->sdwInk5 = lpxPFData->asdwDotCount[4];
          lpDotCounts->sdwInk6 = lpxPFData->asdwDotCount[5];
          break;
       }  /* end of switch (lpxDataRec->bColorPlanes) */

       /* Now that ink usage has been reported, zero the counters. */
       for (n=0; n<6; n++)
       {
          lpxPFData->asdwDotCount[n] = 0;
       }

   }   /* end of non NULL lpxDataRec pointer */
   else
   {
      lpDotCounts->sdwInk1 = 0;
      lpDotCounts->sdwInk2 = 0;
      lpDotCounts->sdwInk3 = 0;
      lpDotCounts->sdwInk4 = 0;
      lpDotCounts->sdwInk5 = 0;
      lpDotCounts->sdwInk6 = 0;
   }

   return;

}   /* end of FCGetInkUsage() */


/****************************************************************************
 * Function Name:    FCGetResolution
 *
 * Description:
 *    This interface function returns the current page and raster resolution
 *    values.
 *
 * Inputs:  lpxDataRec           Long pointer to print device structure.
 *          lpbPageResolution    Page resolution is returned in this value.
 *          lpwRasterResolution  Raster line resolution is returned in this
 *                               value.
 *
 * Outputs: If successful, sets lpbPageResolution and lpwRasterResolution to
 *          the correct values and returns 1, i.e.
 *          lpbPageResolution    Possible return values are:
 *                                        SUPERLOWRES
 *                                        LORES
 *                                        HIRES_NONINTERLACED
 *                                        HIRES_INTERLACED
 *          lpwRasterResolution  Possible return values are:
 *                                         300
 *                                         600
 *                                        1200
 *          If an error occurs, set lpbPageResolution and lpwRasterResolution
 *          to 0 and return 0.
 *
 * Original Author: J. Bates
 * Date: 03/27/98
 *
 ***************************************************************************/
WordType EXPENTRY FAR FCGetResolution(LPDVDATAREC lpxDataRec,
                                      LPByteType lpbPageResolution,
                                      LPWordType lpwRasterResolution)
{
   LPPFDATA    lpxPFData;
   WordType    wRetCode;

   if   (lpxDataRec)
   {   /* lpxDataRec exists */
      lpxPFData = (LPPFDATA)lpxDataRec->lpLXDevice;
      if (lpxPFData)
      {  /* lpxPFData exists */
         *lpbPageResolution   = lpxPFData->bResolution;
         *lpwRasterResolution = (lpxPFData->swRastResMult * (WordType)300);
         wRetCode = 1;
      }
      else
      {
         *lpbPageResolution   = 0;
         *lpwRasterResolution = 0;
         wRetCode = 0;
      }
   }
   else
   {
      *lpbPageResolution   = 0;
      *lpwRasterResolution = 0;
      wRetCode = 0;
   }

   return(wRetCode);

}  /* end of FCGetResolution() */
