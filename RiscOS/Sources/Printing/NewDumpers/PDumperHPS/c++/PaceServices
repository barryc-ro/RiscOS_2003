
/*****************************************************************************************/
/***                                                                                   ***/
/***  PaceServices.h                                                                   ***/
/***                                                                                   ***/
/***  Application:   HP Printer Dumper module (using HP SDK)                           ***/
/***                                                                                   ***/
/***  Purpose:       Implemets the functions required by the SDK. These allow the SDK  ***/
/***                 to access lowlevel I/O of the system.                             ***/
/***                                                                                   ***/
/*****************************************************************************************/

 
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#include "swis.h"
#include "IOCtl.h"


#include "Defs.h"
#include "Debug.h"
#include "PDumper.h"
#include "Variables.h"
#include "Routines.h"



PaceSystemServices::PaceSystemServices()
    {
    DEBUGV( DebugMessage("PacesSystemServices::PaceSystemService()\n"); )

    InitDeviceComm();

    srand(GetTime());
    }



PaceSystemServices::~PaceSystemServices()
    {
    DEBUGV( DebugMessage("PacesSystemServices::~PaceSystemService()\n"); )
    }


BOOL PaceSystemServices::PrinterIsAlive()
    {
    DEBUGV( DebugMessage("PacesSystemServices::PrinterIsAlive()\n"); )

    return(TRUE);
    }


void PaceSystemServices::DisplayPrinterStatus(DISPLAY_STATUS ePrinterStatus)
    {
    static busy_loops = 0;
    DEBUGV( DebugMessage("PacesSystemServices::DisplayPrinterStatus()\n"); )

    DEBUG( DebugMessageInt("*****  Printer Status Message = %d,  ", (int) ePrinterStatus); )

    switch(ePrinterStatus)
        {
        case NODISPLAYSTATUS -1:
            DEBUG( DebugMessage(" No Display Status\n"); )
            break;

        case DISPLAY_PRINTING:
            DEBUG( DebugMessage(" Printing\n"); )
            return;
            break;

        case DISPLAY_PRINTING_COMPLETE:
            DEBUG( DebugMessage(" Printing Complete\n"); )
            break;

        case DISPLAY_PRINTING_CANCELED:
            DEBUG( DebugMessage(" Printing Cancelled\n"); )
            break;

        case DISPLAY_OFFLINE:
            DEBUG( DebugMessage(" Printer off-line\n"); )
            break;

        case DISPLAY_BUSY:
            DEBUG( DebugMessage(" Printer Busy\n"); )
            if (busy_loops++ < 3)
                return;
            break;

        case DISPLAY_OUT_OF_PAPER:
            DEBUG( DebugMessage(" Out of paper\n"); )
            break;

        case DISPLAY_TOP_COVER_OPEN:
            DEBUG( DebugMessage(" Cover Open\n"); )
            break;

        case DISPLAY_ERROR_TRAP:
            DEBUG( DebugMessage(" Error Trap ???\n"); )
            break;

        case DISPLAY_NO_PRINTER_FOUND:
            DEBUG( DebugMessage(" No Printer found\n"); )
            break;

        case DISPLAY_NO_PEN_DJ400:
            DEBUG( DebugMessage(" No Pen (DJ400)\n"); )
            break;

        case DISPLAY_NO_PEN_DJ600:
            DEBUG( DebugMessage(" No Pen (DJ600)\n"); )
            break;

        case DISPLAY_NO_COLOR_PEN:
            DEBUG( DebugMessage(" No Colour Pen\n"); )
            break;

        case DISPLAY_NO_BLACK_PEN:
            DEBUG( DebugMessage(" No Black Pen\n"); )
            break;

        case DISPLAY_NO_PENS:
            DEBUG( DebugMessage(" No Pens\n"); )
            break;

        case DISPLAY_PHOTO_PEN_WARN:
            DEBUG( DebugMessage(" Photo Pen warning\n"); )
            break;

        case DISPLAY_PRINTER_NOT_SUPPORTED:
            DEBUG( DebugMessage(" Printer is not supportted\n"); )
            break;

        case DISPLAY_COMM_PROBLEM:
            DEBUG( DebugMessage(" Comms problem\n"); )
            break;

        case DISPLAY_CANT_ID_PRINTER:
            DEBUG( DebugMessage(" Can't ID Printer\n"); )
            break;

        case ACCEPT_DEFAULT:
            DEBUG( DebugMessage(" Accept Default\n"); )
            break;
    }

    exit(1);
    }




/*****************************************************************************************/
/***                                                                                   ***/
/***  PaceSystemServices::BusyWait(msec)                                               ***/
/***                                                                                   ***/
/***  Delays for a period of time, mesaured in mili-seconds.                           ***/
/***                                                                                   ***/
/***                                                                                   ***/
/*****************************************************************************************/

DRIVER_ERROR PaceSystemServices::BusyWait(DWORD msec)
    {
    DEBUGV( DebugMessageInt("PacesSystemServices::BusyWait(%d)\n", msec); )

    return(NO_ERROR);
    }




DRIVER_ERROR PaceSystemServices::ReadDeviceID(BYTE* strID, int iSize)
    {
    DRIVER_ERROR   error=NO_ERROR;
    BOOL        ID_READ = FALSE;
    ioctl_t *ioctl_structptr, *ioctl_struct_ptr1;
    char *data = NULL;
    int data_size = 0;
    int file_handle = -1;
    int i = 0;



    DEBUGV( DebugMessage("PacesSystemServices::ReadDeviceID()\n"); )

    DEBUGV( DebugMessageInt("printer Handle = &%8X\n", PrinterHandle); )


    if (PrinterHandle == -1)
        _swix(OS_Find, _INR(0,2)|_OUT(0), 0x8F,  "parallel:", 0, &file_handle);
     else
        file_handle = PrinterHandle;


    if (file_handle != -1)
      {
      ioctl_struct_ptr1 = (ioctl_t *)malloc(sizeof(ioctl_t));
      if (ioctl_struct_ptr1 != NULL)
          {
          ioctl_struct_ptr1->reason = IOCTL_PARALLEL_DEVICEID_SIZE;
          ioctl_struct_ptr1->group = IOCTL_GROUP_PARALLEL;
          ioctl_struct_ptr1->reserved = 0;
          ioctl_struct_ptr1->write = 0;
          ioctl_struct_ptr1->read = 1;
          ioctl_struct_ptr1->data = 0;
          _swi(OS_Args, _INR(0,2), 9, file_handle, ioctl_struct_ptr1);
          data_size = ioctl_struct_ptr1->data;

          DEBUGV( DebugMessageInt("  device id size = %i\n", data_size); )
          DEBUGV( DebugMessageInt("  sizeof ioctl = %i\n", sizeof(ioctl_t)); )
          free (ioctl_struct_ptr1);
          }
      }

  Delay(5);                         // wait 5 c-seconds

    if (data_size > 0)
        {
        ioctl_structptr = (ioctl_t *)malloc (data_size + sizeof(ioctl_t));
        if (ioctl_structptr)
            {
            memset(ioctl_structptr, 0x66, data_size);

            ioctl_structptr->reason = IOCTL_PARALLEL_DEVICEID_DATA;
            ioctl_structptr->group = IOCTL_GROUP_PARALLEL;
            ioctl_structptr->reserved = 0;
            ioctl_structptr->write = 0;
            ioctl_structptr->read = 1;
            ioctl_structptr->data = data_size;

            _swi(OS_Args, _INR(0,2), 9, file_handle, ioctl_structptr);

            data = ((char*)ioctl_structptr) + 4;

            for(i = 0; i<data_size; i++)
                {
                strID[i] = data[i];
                DEBUG( DebugChar(strID[i]); )
                }
            strID[i] = '\0';
            DEBUG( DebugMessage("\n"); )
            ID_READ = TRUE;

            if (DeviceIDCache != NULL)
                {
                for(i = 0; i<data_size; i++)
                    {
                    DeviceIDCache[i] = data[i];
                    }
                DeviceIDCache[i] = '\0';
                }

            free (ioctl_structptr);
            }
        }



    if (file_handle != PrinterHandle)
        {
        _swix(OS_Find, _INR(0,1), 0, file_handle);          /* Ensure file handle is closed */
        }


    if (!ID_READ)
        {
        if (!CopyDevIDFromCache(strID, iSize))             // Try reading a cached version instead
            {
            DEBUGV( DebugMessage("Can't obtain any device ID!\n"); )
            error = BAD_DEVICE_ID;
            }
        }


    return(error);
    }




BYTE* PaceSystemServices::AllocMem(int iMemSize)
    {
    DEBUGV( DebugMessage("PacesSystemServices::AllocMem()\n"); )

    return((BYTE *)malloc(iMemSize));
    }



void PaceSystemServices::FreeMem(BYTE* pMem)
    {
    DEBUGV( DebugMessage("PacesSystemServices::FreeMem()\n"); )

    free(pMem);
    }



BOOL PaceSystemServices::GetStatusInfo(BYTE* bStatReg)
    {
    BOOL        ret_value = TRUE;
    ioctl_t    *ioctl_struct_ptr1;
    int         file_handle = -1;
    int         data;
    int         stat;


    DEBUGV( DebugMessage("PacesSystemServices::GetStatusInfo()\n"); )




    DEBUGV( DebugMessageInt("printer Handle = &%8X\n", PrinterHandle); )
    if (PrinterHandle == -1)
        _swix(OS_Find, _INR(0,2)|_OUT(0), 0x8F,  "parallel:", 0, &file_handle);
     else
        file_handle = PrinterHandle;

    if (file_handle != -1)
      {
      ioctl_struct_ptr1 = (ioctl_t *)malloc(sizeof(ioctl_t));
      if (ioctl_struct_ptr1 != NULL)
          {
          ioctl_struct_ptr1->reason = IOCTL_PARALLEL_STATUS_BYTE;
          ioctl_struct_ptr1->group = IOCTL_GROUP_PARALLEL;
          ioctl_struct_ptr1->reserved = 0;
          ioctl_struct_ptr1->write = 0;
          ioctl_struct_ptr1->read = 1;
          ioctl_struct_ptr1->data = 0;
          _swi(OS_Args, _INR(0,2), 9, file_handle, ioctl_struct_ptr1);
          *bStatReg = ioctl_struct_ptr1->data;

          DEBUGV( DebugMessageInt("  device id status byte = %d\n", *bStatReg); )
          }


      if (file_handle != PrinterHandle)
          {
          _swi(OS_Find, _INR(0,1), 0, file_handle);          /* Ensure file handle is closed */
          }
      }
    else
      {
      DEBUGV( DebugMessage("Reading Status byte by SWI\n"); )
      if (!_swi(__Parallel_OP, _IN(0)|_OUTR(1,2), 0, &data, &stat) )
         {
         *bStatReg = stat;
         DEBUGV( DebugMessageInt("  device id status byte (swi) = %d\n", *bStatReg); )
         }
      else
         {
         DEBUGV( DebugMessage("Cannot get status register\n"); )
         ret_value = FALSE;
         }

      }


    return(ret_value);
    }




DRIVER_ERROR PaceSystemServices::ToDevice(const BYTE* pBuffer, DWORD* dwCount)
    {
    DRIVER_ERROR         error = NO_ERROR;
    int                  file_handle = -1;

    DEBUGV( DebugMessage("PacesSystemServices::ToDevice()\n"); )
    DEBUGV( DebugMessageInt("   *Buffer  = &%8X\n", (int)pBuffer); )
    DEBUGV( DebugMessageInt("   *dwCount = &%8X\n", (int)*dwCount); )


    DEBUGV( DebugMessageInt("printer Handle = &%8X\n", PrinterHandle); )
    if (PrinterHandle == -1)
        _swix(OS_Find, _INR(0,2)|_OUT(0), 0x8F,  "parallel:", 0, &file_handle);
     else
        file_handle = PrinterHandle;

    if (file_handle != -1)
        {
        _swix(OS_GBPB, _INR(0,3)|_OUT(3), 2, file_handle, (int)pBuffer, (int)*dwCount, dwCount);



        DEBUGV( DebugMessageInt("   bytes not written = &%8X\n", (int)*dwCount); )
        

        if (file_handle != PrinterHandle)
            {
            _swi(OS_Find, _INR(0,1), 0, file_handle);          /* Ensure file handle is closed */
            }
        }
    else
        {
        error = IO_ERROR;
        }


    return(error);
    }



DRIVER_ERROR PaceSystemServices::FromDevice(char* pReadBuff, WORD* wReadCount)
    {
    DEBUGV( DebugMessage("PacesSystemServices::FromDeviceID()\n"); )


    return(NO_ERROR);
    }



BOOL PaceSystemServices::YieldToSystem(void)
    {
    DEBUGV( DebugMessage("PacesSystemServices::YieldToSystem()\n"); )


    return(TRUE);
    }



BYTE PaceSystemServices::GetRandomNumber()
    {
//    DEBUGV( DebugMessage("PacesSystemServices::GetRandomNumber()\n"); )


    return((BYTE)rand());
    }


DWORD PaceSystemServices::GetSystemTickCount(void)
    {
    DEBUGV( DebugMessage("PacesSystemServices:: GetSystemTickCount()\n"); )


    return(0);
    }



float PaceSystemServices::power(float x, float y)
    {
    DEBUGV( DebugMessage("PacesSystemServices::power()\n"); )


    return(0x00FFFFFF);
    }



