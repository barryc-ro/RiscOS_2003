
Copyright (C) Acorn Computers Ltd. 1992   0197,262/FS Issue 0 ****DRAFT****



            Jordan  SCSI Software Functional Specification
           ==================================================

                -----------------------------------------
                |  Drawing No : 0197,262/FS             |
                |       Issue : 0 ****DRAFT****         |
                |        Date : 18th November 1992      |
                |      Author : Neil Critchell          |
                |  Last Issue : None                    |
                -----------------------------------------




Contents
--------
  1)   History
  2)   Outstanding Issues
  3)   Overview
  4)   Technical Background
  5)   User Interface
  6)   Programmer Interface
  7)   Data Formats
  8)   Protocols
  9)   External Dependencies
  10)  Development Test Strategy
  11)  Organisation
  12)  Future Enhancements

  Appendix A) SCSIDriver Application Note 0470,207


1) History
----------

0.00  NC  18-Nov-92  Written
0.01  JSR 23-Nov-92  Added SCSI Tape & SCSI Printer.
0.02  JSR 04-Jan-93  Initial pass through corrections/extentions from
                        review.
0.03  JSR 21-Jan-93  Corrections.
0.04  JSR 27-Jan-93  More corrections.




2) Outstanding Issues
---------------------

2.1) SCSI Driver
Three additional bits in the CMOS RAM needs to be allocated for the 
SCSIHostID configuration. This also needs to be factory set to 7.



2.2) SCSIFS
No outstanding issues.



2.3) SCSI Tape
Should it be called Tape or SCSITape in DeviceFS? Tape means Tape: works
without effort - people are familiar with this. SCSITape means  people will
have to set up a Tape$Path to point to SCSITape$Path so  they can use Tape:.


2.4) SCSI Printer
No outstanding issues.



3) Overview
-----------

3.1) SCSI Driver
The SCSI Driver software is a module which provides a programming 
interface to the SCSI controller hardware, provides specific SCSI 
*commands and configuration options. The SCSI driver does not 
provide support for any particular SCSI device, this is handled by 
higher level code which uses this module to communicate with it. 
Simply this module, in conjunction with the SCSI controller hardware, 
provides the necessary SCSI protocols, in order to move data, such as 
commands, messages, statuses and device data, to and from a SCSI 
device and the host computer.

The host computer in this case, is Jordan. Jordan will contain as part 
of its main PCB hardware a new SCSI hardware implementation, see 
the SCSI hardware functional specification 0197,261/FS. The main 
difference in the hardware is a new SCSI controller chip, the NCR 
53C94, new hardware address locations, and a new method of 
transferring bulk data, using DMA. This means that the SCSI driver 
must provide the same programming interface to a completely different 
hardware specification.

All the code which sits above the SCSI driver should continue to 
function as before without any modification as the only differences 
noticed would be the speed at which operations are performed.

This driver does not implement any new SCSI driver interface calls, but 
will implement most of the optional functions which the current Acorn 
SCSI drivers do not support.

The SCSI Driver will support a CMOS RAM configurable SCSIHostID 
which is used at initialisation.



3.2) SCSIFS

SCSIFS is the interface between FileCore and SCSIDriver to make SCSI discs
available to FileCore. This module has been provided by Acorn in previous
products, but has not been updated to follow changes in disc drive
capabilities and the capability of the underlying operating system. The
modifications described here should bring SCSIFS into line with its
environment.

The changes to SCSIFS can be summarised as follows:

Auto configuration. SCSIFS will not longer need to have the number of discs
given as a configuration option. This means that when a user attaches a new
disc and powers on the machine it will be immediately available. Note,
however, that if a disc isn't attached, powered up and ready within 60
seconds of reset then it won't be noticed until the next reset.

Partitioned hard discs. SCSIFS, to permit access to hard discs bigger than
512MBytes, will allow these discs to be partitioned.

Removable disc handling. RISC OS 3 supports removable hard discs where RISC
OS 2 did not. SCSIFS did not previously support this feature - it will now
do so. Of course, the problems of disc name ambiguity are the same as for
ADFS and the user resolves the ambiguity in the same way - by clicking on
the icon of the required disc.

Auto spin down. A large proportion of SCSI discs support spinning down of
hard discs. As a power saving measure SCSIFS will be extended to support
this by spinning down any SCSI hard disc which hasn't been accessed within a
user configurable interval.

Read-ahead and write-behind. This feature has been available in RISC  OS,
but not supported by Acorn's SCSIFS since RISC OS 2.00. It increases
SCSIFS's performance significantly and is now becoming the  norm, rather
than the exception for SCSI cards. This will be added to the Jordan
SCSIFS.

Internationalisation. RISC OS 3 supports internationalisation, but Acorn's
SCSIFS does not. This will be remedied.

SCSIFiler, the desktop hook to access SCSIFS will be enhanced where necessary
to support the above features.

There is a separate project called Coffee which will supply Cumana's SCSIFS
as part of an Acorn package. This SCSI implementation supports partitioning
and password protection. The partitioning scheme used by Cumana's system is
not the same as that adopted here. This isn't going to be a problem as
interworking of hard discs is expected to be rare. Also, the RISCiX solution
is being adopted because it is better technically, and it gives write
protection on partitions. As for password protection, this is being provided
by FSLock being bundled in the ROM.


3.3) SCSI Tape
The SCSI tape driver provides a basic programmatic interface to SCSI tape
drives so that other operating systems' archiving programs (eg tar) can be
used more easily, and so that RISC OS native archiving  programs can rely on
a tape driver without having to provide their own.

The tape driver has had its facilities based around the Brian Brunswick 
version which seems to be well liked. This version wasn't itself used as 
it is excessively large for what it does (aside: it is based around more 
general filing system technology which Brian has, which is why it is so 
big). Also, the new tape driver, being RISC OS 3 specific can make use 
of common facilities provided by DeviceFS and BufferManager. 
Further, once written, due to the similarity in required functionality 
between the tape and printer driver the tape driver can be largely reused 
for the printer driver.

There are two classes of SCSI tape device: sequential access devices 
and direct access tape devices. Of these, it is only intended to support 
the sequential access variety, these being in the more traditional mould.

As in SCSIFS the SCSI tape device driver will be auto-configuring.



3.4) SCSI Printer
The SCSI printer driver will provide a DeviceFS device called 
SCSIPrinter with associated SCSIPrinter$Path. No options or
 *-commands will be supported.




4) Technical Background
-----------------------

4.2) SCSIFS
RISC OS has a disc format which is understood by the FileCore module 
which is the standard way RISC OS treats discs. FileCore talks to discs 
through its own interface which is different to the SCSI interface. 
SCSIFS translates between what FileCore understands and what SCSI 
understands. SCSIDriver manages the SCSI bus for several clients (eg 
SCSIFS and SCSITape) so that they need not know that both are using 
it, and so that the clients are isolated from the particular hardware 
implementing the SCSI bus. SCSIFS talks through SCSIDriver to the 
discs on the bus, using a number of SCSI commands. Not all devices 
need support all SCSI commands, so the ones SCSIFS uses will be 
given.



4.4) SCSI Printer
DeviceFS is a filing system to hold devices and present them to the rest 
of the system. A device appears as a file in this.




5) User Interface
-----------------

5.1) SCSI Driver
There are no user interfaces to this code.



5.2) SCSIFS
!Configure

!Configure will need changing to match Jordan. The hard disc drive 
window will change to this:

        See diagram 1


The SCSI hard discs section has been removed - it is automatically 
configured. The spindown delay is no longer dependant on IDE discs - 
it applies to SCSI hard discs too.


SCSIFiler

SCSIFiler will look the same as it does now, however its behaviour will
change a bit.

Removable discs

When a drive is empty the icon will look like this:

        See diagram 2


When a drive has a disc in it the drive icon will look like this:

        See diagram 3


The change between these two states will happen automatically. Where a disc
has more than one partition on it multiple icons will be presented on the
iconbar, one for each partition, and the icon will return back to a single
one when the drive is empty.

Automatic drive detection.

Some drives take their time appearing on the SCSI bus. After power-up 
the full complement of drive icons may not be present, but as the drives 
start to respond the icons will appear.



5.3) SCSI Tape
There are no new user interfaces provided by the SCSITape device 
driver. However, an archiver may be provided with Jordan which will 
use the SCSI tape device.



5.4) SCSI Printer
!Printers will be adapted to have a SCSI Printer option in the 
Connections window:

        See diagram4


This will work like the other printer options do. The user interface is
being kept simple on the basis that it is not obvious that extra complexity
is needed until we get feedback from users.




6) Programmer Interface
-----------------------

6.1) SCSIDriver

This device driver will be compliant to the current RISC OS SCSIDriver
Application Note 0470,207. Only the differences from  the current
implementation will be described here. Note that this SCSIDriver will not
interwork with a SCSI podule. This is because you can not mix SCSIPodules
from different manufacturers, and there is no intention to produce a 53C94
based Acorn SCSI podule for Jordan.

6.1.1) SCSIDriver SWIs

  SCSI Version (&403C0)
  ---------------------
  entry: None

  exit:
    R0 = &0000200      (software version number)
    R1 = &D400FFFF     (software features)
    R2 = &0000200      (hardware version number)
    R3 = &8000FFFF     (hardware features)

    Software Version number
    bits  0 -  7  minor release number.
    bits  8 - 31  major release number

    Software Features
    bit  31       Supports target mode
    bit  30       Supports configuration
    bit  29       Doesn't support reading control lines
    bit  28       Supports device reservation
    bit  27       Doesn't support multiple SCSI cards
    bit  26       Supports *SCSIBlock
    bits 25 - 16  Reserved must be 0
    bits 15 -  7  Reserved must be 1
    bit  6        Supports *Devices
    bit  5        Supports scatter list for SWI SCSI_Op
    bit  4        Supports messaging
    bit  3        Supports automatic "Request Sense"
    bit  2        Supports command queueing
    bit  1        Supports background data transfer
    bit  0        Supports target disconnect/reconnect

    Hardware Version Number
    bits  0 -  7  minor release number.
    bits  8 - 31  major release number

    Hardware Features
    bit  31       Supports configuration
    bits 30 - 16  Reserved must be 0
    bits 15 -  1  Reserved must be 1
    bit  0        Supports target mode

  (NB. This driver does not support multiple SCSI cards and hence SWI
  "SCSI_List" or "*SCSIList), but all other optional features are
  supported many of which are not supported in SCSIDriver 1.10)


  SCSI_ReadControlLines
  ---------------------
  This will not be implemented as is is not possible to do this with the
  controller we're using.


  SCSI_EEProm (&403C6)
  --------------------
  This SWI call will not be implemented.


  SCSI_List (&403C8)
  ------------------
  This SWI call will not be implemented.

  It is not possible to have a SCSI podule on Jordan.

Note that the special access key &fc000003 which acts like a skeleton key
will still work to get around the access key mechanism.

6.1.2) SCSIDriver *-Commands

*Configure SCSIHostID id

where:
  <id>          = device id to be given to the on-board SCSI

This is necessary to avoid SCSI bus ID clashes which would otherwise happen
if two Jordan's were connected to the same bus. This is now a sensible setup
as target mode is now supported.


*Disconnect <device_id> [ON/OFF]

where:
  <device_id>   = the number of the device on the SCSI bus
  ON            = if specified will allow disconnection.
  OFF           = if specified will inhibit disconnection.

If the optional parameter [ON/OFF] is not specified, then the current 
value for the given device ID will be returned:-

    Device "device_id" disconnection is [ON/OFF]

Disconnection control to a device is necessary as some devices can not cope
with disconnection. Also, on a single initiator single target system (ie as
shipped) disconnection will slow SCSI operations by up to 5%.

*Configure Disconnect <device_id> [ON/OFF]

where:
  <device_id>   = the number of the device on the SCSI bus
  ON            = if specified will allow disconnection.
  OFF           = if specified will inhibit disconnection.

These configurations will be stored as 1 bit per device on the SCSI bus.
This controls the initial state of whether disconnection is allowed or
disallowed on a particular device. The CMOS byte will default to 0 on
delete-power-on, indicating that disconnections are enabled on all devices.

6.1.3) Disconnection and SCSIDriver

Some devices cannot cope with disconnection, and all devices can cope if
disconnection is disabled. To enable the user the necessary control over
this the *configure disconnect/*disconnect setting will override
SCSI_Control's setting of disconnection on each device if the *-command form
disallows disconnection and the SWI form allows it. In other words a
*disconnect <device> OFF overrides SCSI_Control, and a *disconnect <device>
ON allows SCSI_Control's setting through.

If there's only one active device allowing disconnection can slow the system
by 5%. The following algorithm will be used to regain this 5% on a one
target system (the default machine configuration):

The driver will maintain, a count of the number of devices 
successfully "Selected", If this number is two or more then, the driver 
will use the disconnect/reconnect parameter, currently in force. If the 
number of selected device is less than two and the amount of data to 
be transferred, is less than 128K, then the driver will ignore the 
parameter currently in force and always inhibit disconnection.

The reason for checking the amount of data, allows another device to 
be selected, during the middle of a long data transfer, otherwise it 
might have to wait for a long time, and could even timeout, when the 
active device may only be using the SCSI bus for 10% of the time.  
(eg. reading 2Mb from CD-ROM will take minimum of 13.7 Seconds, 
in which time no other SCSI device could be used (Not a good idea in 
a multi-tasking system!).

Performing the above will increase the overheads for each SCSI 
command sent to the devices by a very small amount, thus reducing 
the performance in all cases apart from when a single device is 
present, in which case performance will increase fairly significantly 
(eg. could be +5% or so, deepending upon device).



6.2) SCSIFS

6.2.1) SCSIFS *-Commands

*Configure SCSIFSDiscs will be removed.

*Configure SCSIFSBuffers <D> will be added. Its syntax and effect 
will be the same as *configure ADFSbuffers, but for SCSI. A value for <D> of
0 or 2 or more will allocate that many buffers, each one being 1024 bytes
for data and taking slightly more than that each after taking into account
buffer management data structures. A value of <D> of one will allocate a
number of buffers which is calculated from the memory size: number of
buffers=memory size/256, limited to 255 maximum.

6.2.2) SCSIFS Programming Interfaces

The SWI SCSIFS_MiscOp will be added. Its functionality will be the 
same as ADFS_MiscOp, but for SCSI.

SCSIFS's entry point MiscOp will be enhanced to RISC OS 3 
functionality. Mount, PollChange, LockDrive, UnlockDrive, PollPeriod 
and Eject reasons will all be supported as per the RISC OS 3 PRMs. SCSIFS
specific details are given for individual reasons below:

MiscOp_PollChange
Due to variations between drives the algorithm for this is quite 
complex. However, it is safe to say that these commands are used:
TEST UNIT READY
START/STOP UNIT stopping the disc when spun down

MiscOp_LockDrive
If the drive media is removable then the SCSI command PREVENT/
ALLOW MEDIA REMOVAL (&1E) will be used to lock the media in 
the drive.

MiscOp_UnlockDrive
If the drive media is removable then the SCSI command PREVENT/
ALLOW MEDIA REMOVAL (&1E) will be used to unlock the media 
to allow its removal from the drive.

MiscOp_PollPeriod
A very short poll period is given.

MiscOp_Eject
The preferred drive is the highest SCSI numbered removable media 
drive. The SCSI command used is START_STOP UNIT with spin 
down and eject flags set.


SCSIFS's entry point DiscOp will be enhanced for the features listed in 
the overview.

The SCSI commands used are:

TEST UNIT READY (&00) to sense for drive ready.
REQUEST SENSE (&03) to get error conditions.
INQUIRY (&12) part of SCSI_Initialise 2
START/STOP UNIT (&1B) to spin up spun down discs.
PREVENT/ALLOW MEDIA REMOVAL (&1E) for Lock/Unlock drive.
READ CAPACITY (&25) part of SCSI_Initialise 2
READ EXTENDED (&28) for reading from discs.
WRITE EXTENDED (&2A) for writing to discs.
VERIFY (&2F) for verify reason code.

Note that disconnections will be enabled by SCSIFS on all drives it
recognises using the SCSI_Control SWI. Note that this setting will be
overridden by the *configure disconnect/*Disconnect setting if these
*-commands indicate disconnect disabled.


6.2.3) SCSIFS, Partitions and Auto-Configuration

SCSIFS will allow discs to be partitioned using the RISCiX partitioning
scheme. This provides backwards compatibility with some partitioning SCSIFSs
in the market, and appears to be the more desirable of the partitioning
methods adopted. RISCiX partitions have names in the partition table for
each partition and this will be used to identify RISC OS partitions - a
partition whose name starts "RiscOs:" will be treated as a partition to be
presented to RISC OS.

Access to partitions needs special effort because FileCore can only handle 8
discs and each partition is, as far as FileCore is concerned, another disc.
Other SCSIFSs get round this problem by causing the user to have to
configure which partitions are attached to particular FileCore drives. This
is clearly undesirable, so I propose the following:

As all access to discs is via the desktop, it is most unlikely that
reference to discs by drive number will occur. Hence, I propose that SCSIFS
present a view of the world to FileCore where FileCore sees 8 removable
media drives. SCSIFS then attaches as required the partitions to these
drives. FileCore will need to tell SCSIFS that it has been asked for a
'disc' which it can't see at the moment. This will be achieved by a new
MiscOp reason code, enabled by a new flag in the startup options given in
FileCore_Create. FileCore will call this just prior to performing the UpCall
to prompt for the new disc. If the filing system responds then the prompt
won't be given and the discs scanned by FileCore as if the UpCall had been
given and the user had responded. SCSIFS, when it receives the MiscOp it
will scan its partition table and swap the required partition onto one of
the drives, faking that that drive has just had its disc changed. The net
result is that one of the drives had changed to being the required
partition.

FileCore_MiscOp 6

In
R0=6 (MiscOp_MediaRequest)
R3=disc name
Out
r3=0 or unchanged

This gives a filing system an opportunity to get the relevant disc ready for
use. If the filing system has taken action to sort this out it should return
with r3 set to 0 - FileCore will check the drives for the given disc. If the
filing system has done nothing it should return with r3 unchanged (non-0).
This MiscOp is enabled with bit 8 being set in the create flags (bit 0, byte
1 of the FileCore filing system descriptor block given to FileCore_Create).

Allocation of partitions to drives will be made as follows:

If 60 seconds have not yet elapsed and a unit hasn't yet responded then a
drive will be reserved for that unit as follows:
RISC OS drive           SCSI bus unit number
0                       4
1                       5
2                       6
3                       7
4                       0
5                       1
6                       2
7                       3

If a unit is empty then the corresponding drive (as above table) will be
reserved for when it has a media inserted.

If a unit was empty, now has a media in it, but that media hasn't been
referenced yet then that media's initial RISC OS partition will be tied to
that unit's corresponding drive. This ensures that a freshly inserted disc
can be accessed by drive number unambiguously.

If only the base partition of a media has been accessed then that media will
remain attached to its default drive.

In other cases a request for a partition will attach it to the least
recently used available drive.

The affect of this is that the base partition of a unit will be the one
attached to the corresponding drive initially, and only once partition names
start getting used will the base partition start wandering between drives.
This ensures that booting will still work and that a freshly inserted disc
can be accessed reasonably easily.

Any unit will be given 60 seconds from reset to get itself ready. Before the
60 seconds are up SCSIFS will wait for it to respond on a request to access
that unit. After the 60 seconds are up the drive must respond to the first
request from SCSIFS otherwise SCSIFS will assume no unit is attached. Once a
unit has responded SCSIFS will become patient again and wait.

Automatic drive detection will be achieved using the IDENTIFY command.

When all partitions on a device have been dismounted then it will be
released by SCSIFS from being reserved. As there is no explicit dismount
call by FileCore to SCSIFS so SCSIFS will assume a seek request is a
dismount. This is a reasonable guess as FileCore only seeks when it parks
the heads on a dismount.

SCSIFiler will need to talk directly to SCSIFS to get the real information
about media changing and the partitions available because FileCore is being
given an artificial view of the world. The following interfaces will be
provided:

SCSIFS_PollChange

In:
r1=drive
r2=sequence number
Out:
r2=sequence number
r3=flags

This works in the same way as miscellaneous entry 1 (Poll changed) does. The
difference being the drive number refers to units attached to the SCSI bus
as follows:

Drive   unit
0       4
1       5
2       6
3       7
4       0
5       1
6       2
7       3

This call has been provided to get the real information about units attached
to the bus.

SCSIFS_PartitionName

In:
r1=drive
r2=partition number
r3=buffer
r4=length of buffer
Out:
r2=flags:
        bit     meaning
        0       0 - Partition undefined
                1 - Partition defined
        1       0 - There cannot be a partition with this number.
                1 - There can be a partition with this partition number.
        2       0 - Partition is write permitted
                1 - Partition is write protected
        3-31    reserved for future use - will be 0.
other regs preserved

This returns the disc name of the given partition. The name will be
NULL-terminated. The drive number maps to SCSI unit numbers in the same way
as SCSIFS_PollChange does. The partition number refers to a partition on the
given drive. Partition 0 is the base RISC OS partition which does not appear
in the partition table on the disc. Partitions 1 upwards refer to entries in
the partition table. r2 gives information about the partition. Bit 0 gives
whether that partition is defined, bit 1 gives whether a partition can be
defined at the table position, bit 2 gives whether the partition is write
protected or not. To enumerate the partitions on a disc start with partition
0 and increase through the partitions until r2 returns with bit 1 clear.


6.3) SCSI Tape
The SCSI tape device is accessed through DeviceFS. The tape is divided into
files which are separated from one another by single file marks. The last
file on a tape may overflow onto another tape - the exchange of tapes is
controlled by SCSI Tape. The SCSI tape device appears in  DeviceFS as
Devices:$.Tape and has the usual Tape$Path and  DeviceFS$Tape$Options. When
this device is openned the file seen is the one wherever the tape happened
to be wound to. The special field options are ; separated. All numeric
parameters accept the K (for *1024), M (for *1048576) and B (for *512)
suffixes. These suffixes are case insensitive. The following special field
options are supported:

rewind
        rewind immediately - rewinds tape before access starts. The SCSI
        command used is REWIND (&01)

norewind
        provided to counteract a rewind option in the defaults.

blocksize[=]<N>
        Sets the blocksize to <N>. The SCSI command used is MODE SELECT
        (&15) with number of blocks field set to 0 and block length field
        set to the blocksize parameter. If no blocksize is specified then a
        blocksize of 512 is assumed. If a blocksize of 0 is specified then
        non-fixed-sized block transfers will take place.

defaultblocksize
        provided to counteract a blocksize option in the defaults.

density[=]<N>
        Sets the density to <N>. The SCSI command MODE SELECT
        (&15) is used. This value is inserted in the density code field.

defaultdensity
        provided to counteract a density option in the defaults.

drive[=]<N>
        Sets the drive to be accessed by this open. There must be a drive
        option given in either the defaults in DeviceFS$Tape$Options or the
        special field.

defaultdrive
        provided to counteract a drive option in the defaults.

buffersize[=]<N>
        Sets the buffer size to be used. If no buffer size is specified it
        defaults to 64 blocks. If a buffer size of less than 3 blocks is
        given this is rounded up to 3 blocks.

buffer[=]<N>
        This is a direct equivalent to the buffersize option.

defaultbuffersize
        provided to counteract a buffer or buffersize option given in the
        defaults.

defaultbuffer
        This is a direct equivalent of the defaultbuffersize option.

speed[=]<N>
        This set the tape speed. The SCSI command used is MODE
        SELECT (&15). This value is placed in the speed field.

defaultspeed
        provided to counteract a speed option in the defaults.

retension
        This retensions the tape before use. The SCSI command used is
        LOAD/UNLOAD (&1B) with the retension and load bits set.

noretension
        provided to counteract a retension option in the defaults.

load
        This loads the tape before use. The SCSI command used is LOAD/
        UNLOAD (&1B) with the load bit set. Note that if both retension
        and load are specified then only one command is sent with both
        retension and load bits set.

noload
        provided to counteract a load option in the defaults.

unload
        This unloads the tape when the device is closed. The SCSI
        command used is LOAD/UNLOAD with the load and retension
        bits clear.

nounload
        provided to counteract an unload option in the defaults.

closerewind
        This causes the tape to be rewound when the device is closed. The
        tape will be rewound before being unloaded. The SCSI command
        used is REWIND (&01).

nocloserewind
        provided to counteract a closerewind in the defaults.

The tape drive is expected to support disconnections - they will be 
enabled. The complete sequence of commands the device can expect is:

SCSI commands issued on open:
[LOAD/UNLOAD]           for load/retension flags
[TRACK SELECT]          for track switch
[MODE SELECT]           for blocksize/speed/density switches
MODE SENSE              to read block size - defaults to 512 on error
[REWIND]                for rewind switch
The open request will return once all the commands up to and including 
the mode sense have completed. The rewind will be going in the 
background.

SCSI commands issued when doing I/O:
READ or WRITE           with the fixed bit set
[RECOVER BUFFERED DATA] to go onto the next tape

SCSI commands issued on close:
[WRITE FILEMARKS]       to mark the end of a written file
[REWIND]                for closerewind flag
[LOAD/UNLOAD]           for unload flag

Note that when the near-end-of-tape is detected the user will be 
prompted in insert the next tape. When writing the data buffered in the 
drive will be retrieved for writing onto the next tape using SCSI 
command RECOVER BUFFERED DATA (&14). A tape file is 
considered to the the data between the current positioning on the tape to 
the next file mark.


*-Commands Supported

All *-commands take the drive as the last parameter. This is optional 
and defaults in the same way as the open drive option does. Note if the tape
drive is open these commands will return an error.

Rewind [<N>]

Rewinds drive <N>. SCSI command used is REWIND (&01). The *-
command will return immediately.

Wind [<N>]

Winds drive <N> to end of data. SCSI command used is SPACE (&01). 
The *-command will return immediately.

Forward <M> [<N>]

This winds drive <N> past <M> blocks. SCSI command used is SPACE 
(&01). The *-command will return immediately. If <M> is negative then the
drive will rewind past the given number of blocks.

Skip <M> [<N>]

This winds drive <N> past <M> files. The SCSI command used is 
SPACE (&01). The *-command will return immediately. If <M> is negative then the
drive will rewind past the given number of files.

Retension [<N>]

This retensions the tape in drive <N>. The SCSI command used is 
LOAD/UNLOAD (&1B) with the load and retension bits set. The *-
command will return immediately.

LastTapeError [<N>]

This will return the last error for drive <N> as an error from this command.
If there is no error this command will simply return.



6.4) SCSI Printer
The SCSI printer device is accessed through DeviceFS. It appears in 
DeviceFS as Devices:$.SCSIPrinter and has the usual SCSIPrinter$Path 
and DeviceFS$SCSIPrinter$Options. The special field options are ; 
delimited. SCSIPrinter can be opened multiple times, once for each printer
device on the SCSI bus.

These are the options provided:

device[=]<N>

This selects SCSI device <N> as the printer. A device option must be
given, either on the default options or in the special field.

nodevice

This is provided to override any device option given in the special field
defaults.

Some errors from the SCSI printer will not be returned, instead the printer
driver will continuously retry. The errors which will do this are:

Medium not present

It is possible other errors may be added as we try real SCSI printers.

No *-commands will be provided.

A new printer type (number 9) has been defined for SCSIPrinter.




7) Data Formats
---------------

7.1) SCSI Driver
There are no new data formats defined for the SCSI driver code.



7.4) SCSIFS
No new data formats will be introduced for this development.



7.3) SCSI Tape
No new data formats.



7.4) SCSI Printer 
No new data formats.




8) Protocols
------------

8.1) SCSI Driver
Upon initialisation of the SCSIDriver code, the configured SCSHostID 
value is read from the CMOS RAM. This value will be used as the on 
board SCSI Host ID as the default. The value can still be altered using 
the SCSI_Initialise SWI call as previously defined.

All the Target Control protocols will be implemented as specified in the 
0470,207, SCSIDriver Application Note.



8.2) SCSIFS
The protocols used to communicate with the drive are given by the  SCSI II
draft spec. All commands used are, where possible, CCS4B commands to
maintain compatibility as far as possible.



8.3) SCSI Tape No new data formats.



8.4) SCSI Printer
No new data formats.




9) External Dependencies
------------------------

9.1) SCSI Driver
There are several external items which will effect the development of 
the SCSI Driver code.

 - Issue A PCB
  - DMA manager driver
  - Devices for testing/developing


  Issue A PCB
  -----------
  The Issue A PCB will be required to complete the development of the
  SCSI driver as there are differences in the hardware of the
  development board which will need the code to be altered.


  DMA manager driver
  ------------------
  This is required to allow data to be transferred to/from the device. 
  Until this is complete the SCSI driver can not be completed as the 
  SCSI hardware relies heavily upon the DMA.


  Devices for testing/developing
  ------------------------------
  Various SCSI devices will be required to test the functionality of the
  SCSI driver is correct. As there are many variations in the way devices
  implement the SCSI protocols a combination of devices will be needed
  to test this.
    Variations:-
      - Disconnect/Re-connect
      - Different Transfer rates
      - SCSI 2
      - Synchronous/synchronous
      - Hard discs, CD-ROM drives, MOs, and others.



9.2) SCSIFS
Access to removable media direct access disc drive will be needed to 
get the software working. These include SyQuest drives and magneto 
optical devices. Access to a SCSI card is also necessary. The Jordan is 
not necessary to completion of this software as Jordan should be 
completely compatible with the changes being made.

A couple of bugs in FileCore to do with ejecting discs need fixing for 
this feature to work well. These are: FileCore repeatedly ejects discs 
when trying to check for the right disc being inserted which can cause 
the right disc to be ejected before it is checked - users annoyed!; On 
shutdown you get a drive empty error when FileCore ejects empty 
drives - this is undesirable and causes the subsequent drives not to eject.

The changes to FileCore given for partition handling will need implementing.



9.3) SCSI Tape
Some enhancements are needed to DeviceFS and BufferManager to 
support SCSITape properly. These changes are to bring a DeviceFS 
device into line with other stream files (eg SystemDevs files and Brian 
Brunswick's TapeFS) - without these changes C cannot open the tape 
file which limits its usefulness. The changes needed to BufferManager 
allow the buffer to be used directly when transferring to/from the tape.

Access to various tape drives will be needed.



9.4) SCSI Printer
This development requires a SCSI printer to be available.

This development assumes the SCSI tape development has been 
completed - it will use the tape sources, but strip most of it out.




10) Development Test Strategy
-----------------------------

10.1) SCSI Driver 
There will be various levels of testing during the development stage 
consisting of:-

  - SWI level comparisons
  - Performance assessment
  - SCSI routines testing
  - Stress testing
  - Filling system bashing
  - Target usage testing


  SWI level comparisons
  ---------------------
  Each individual SWI call will be tested with each possible
  combination of parameters, where possible, or a large number of 
  combinations where not. The tests will be carried out, on both the 
  current SCSI Driver (1.10) and the new SCSI Driver (2.0) using the 
  same device. The results will be compared, and should be identical 
  except where the specification varies (see above for details).

  A program, or suite of programs will be created to do this.

  Performance Assessment
  ----------------------
  A specific speed testing program will be written, to test the 
  performance of the host SCSI system (ie. the SCSI bus throughput). 
  This program will give an approximate throughput of the SCSI bus, 
  under the conditions it meets. A throughput of over 3Mb 
  Asynchronous per second should be obtainable in the following 
  conditions:
      - Correct and Good termination of both ends of the SCSI Bus.
      - Good quality SCSI cable
      - A device with a sustained throughput of 3.5 Mb/Sec or greater.
      - A device with no defects
      - Executed in a low DMA intensive screen mode (eg. mode 8)
      - The program will not be multi-tasking.
      - The SCSI chip is clocked at 25Mhz.

  This test will be written, in such a way that it may be used upon any 
  SCSI system, with a SCSI driver meeting the Acorn spec. It may be 
  used to test any SCSI setup to determine performance for that 
  particular combination.

  SCSI routine testing
  --------------------
  A number of simple programs will be produced to test specific features 
  of the SCSI sub system. The programs will be run on both the current 
  SCSI Driver (1.10) and new SCSI Driver (2.0) using the same devices. 
  The results of the programs will then be compared, these should be the  
  same, except perhaps for speed of execution.

  Stress Testing Program
  ----------------------
  A stress testing program, will also be written. This program will 
  continuously READ/WRITE data to multiple devices. The testing will 
  initiate the following conditions:

      - Multiple devices (of various type)
      - Multiply queued commands
      - Background & foreground SCSI commands
      - Varying data Reads/Writes
      - Data integrity checking
      - Devices, Selecting/Disconnecting/Reselecting continuously at
        varying intervals.
      - Mixed synchronous & asynchronous data transferring.
      - Varying device parameters whilst in progress.    (ie. 
        Disconnection/Queue type)
      - Aborting commands, in mid flow.

  This test will be written, in such a way that it may be used upon any 
  SCSI system, with a SCSI driver meeting the Acorn spec. It may be 
  used to either stress test the SCSI Driver, or stress test a SCSI device.

  Filing system bashing
  ----------------------
  After the two above tests have been carried out successfully,  adding 
  SCSFS (1.10) to the SCSI Driver (2.00) a filing system bashing 
  program can be used. The filing system basher will use many features 
  of the SCSI Driver and the SCSI Device, and will demonstrate the 
  compatibility of the SCSI Driver with the SCSI FS. This bashing 
  program will demonstrate the reliability and compatibility of the SCSI 
  Driver code.


  Target usage testing
  --------------------
  As a standard filing system basher will not test any of the "Target" 
  features a separate test for this must be performed. The easiest and best 
  way to test this (after the SWI comparisons) is to use a program which 
  uses these features. For example Lindis's 'SCSI share' (for which the 
  interface was designed) or Cumana's 'Easy Share', which also uses 
  these features. This test will require several machines, connected to 1
  or more SCSI devices and to run programs on all machines from the 
  same devices at the same time. A good test would be to run the filling 
  system basher and disc basher at the same time.



10.2) SCSIFS
Development will happen in two phases: prototyping; completion. The 
prototyping phase is necessary to get a good handle on different drives' 
behaviour, and it has been necessary to complete prototyping to get this 
specification done. Testing during the prototyping stage has been 
largely manual by its nature of investigation and tuning. Completion 
testing will be as follows:

Auto configuration: This will be tested by various mixtures of drives 
being attached to the bus and seeing what comes up. The following 
drive types will be tried:
Slow spin-up fixed hard disc (eg late revision A540)
Faster spin-up fixed hard disc (eg early A540)
SyQuest (with and without disc in)
Any 3 1/2" M/O drive (with and without disc in)
All these devices will be attached to the bus at once with mixtures 
powered on. All 36 combinations will be tried - power on, try accessing 
each, note result, rmreinit SCSIFS, try accessing each, note result. 
Shuffling the drive numbers around will be tried in an ad hoc fashion 
after this test to make sure it doesn't affect things it shouldn't. Auto-boot 
will be tried on slow and fast spin-up discs.

Removable disc handling: A short BASIC program will be written 
which does repeated SCSIFS_MiscOp PollChange on a test drive. This 
will be run in isolation from the active desktop and discs inserted/
removed and the results observed. This will be run before entering the 
desktop, from the F12 command line and in a task window - its 
influence on SCSIFiler and access to the SCSI disc in question and 
other SCSI discs will be sampled by hand. Experience has shown that 
when it's wrong a few operations in the Filer will show this up, and that 
it shows up very obviously.

Auto spin down. This will be tried on disc which do and those which 
don't support this. The spin-down time will be noted and checked for 
accuracy. The configured spin-down time will be varied and checked. 
Spin-down after power-up will be checked it works. Spin-up on first 
operation after *rmreinit will be checked it works. These will all be 
done by hand due to the difficulty of automating this.

Read-ahead and Write-behind: Nick Reeves' bash program will be used 
to check this is working. This program is designed to hunt out read-
ahead write-behind problems. Initial checking will be for 10000 tests 
(several minutes). When the code is stable a full weekend soak will be 
done.

Internationalisation: A program which will produce as many of the 
messages as possible will be written. The expected results will be noted 
and the checking will be done by hand - it is difficult to automate this.

SCSIFiler testing will be done by hand. As many messages as possible 
will be generated and checked (test internationalisation). Disc insertion 
and PollChange interactions will be checked by hand too, with three 
drives (fixed, SyQuest, random 3 1/2" M.O.).



10.3) SCSI Tape
Data integrity tests will be performed - data will be written to tape and 
retrieved and checked against the original.

Data interworking will be checked. Data will be written to tape using 
SCSITape and retrieved with Brian Brunswick's TapeFS and the results 
compared. Also, Tar archives will be tested to work between our Sun UNIX
systems and Jordan.

Program interworking will be checked. Programs which work with 
Brian Brunswick's TapeFS will be tried against SCSITape - SCSITape 
will be expected to work as well.

Command and option operation and parameter vetting will be checked. 
A program will be written which will test all commands and options. It 
will check the end cases and a middle case on all numeric parameters. 
Invalid options will be tried.



10.4) SCSI Printer
Program interworking will be checked. This will involve printing 
documents by various methods - !Printers text, !Printers 1st word plus, 
application direct with various applications (Acorn and non-Acorn), 
application through !Printers.

Command and option operation and parameter vetting will be checked. 
A program will be written which will test all commands and options. It 
will check the end cases and a middle case on all numeric parameters. 
Invalid options will be tried. This will be based on the SCSITape 
parameter tester.




11) Organisation
----------------

11.1) SCSI Driver
The SCSI Driver will reside in ROM. (It is also assumed that the 
SCSIFS and SCSIFiler will also reside in ROM.)

The SCSIHostID will reside in 3bits of the CMOS RAM.

All code and documentation for the SCSI Driver are in a directory 
called 'SCSIDrv200'. The SCSI driver source is in a sub directory called 
'Source'. The test programs and documentation are in a sub directory 
called 'SCSITests'.



11.2) SCSIFS
SCSIFS and SCSIFiler will be provided in ROM. The test software will 
be placed in subdirectory Test in SCSIFS.



11.2) SCSI Tape
SCSITape will be in ROM. Test resources will be in directory Test in 
SCSITape. Documentation on the SCSI Tape device will be provided in the PRM
extension, and in the user's guide. The information in the user guide will
be enough to use SCSITape with an archiver program.



11.3) SCSI Printer
SCSIPrinter will be in ROM. Test resources will be in directory Test in 
SCSIPrinter. Documentation on the SCSI printer device will be in the PRM
extention. No technical documentation will be needed for this in the user's
guide as it will already be wired into the !Printers application.




12) Future Enhancements
-----------------------

12.1) SCSI Driver
SCSI_List, (and SCSI_Log etc). The device driver is written assuming 
that the only SCSI_Controller is on the main board. This means that in 
future it would not be possible to add another SCSI Expansion board (of 
the same hardware). The SCSI_Log specification does not allow for 
this, thus it cannot be implemented until changes to the SCSI Log 
specification are made.
However as there is currently no project to produce such a SCSI 
Expansion board, the SCSI Log specification does not need to be 
updated, until such a time.

Synchronous/Asynchronous data transfers. Currently the SCSI Driver 
negotiates with the device for synchronous data transferring, if all is 
well then data will be transferred synchrounously otherwise 
asychronously. It might be sensible to allow user selection to force 
asychronous data transfers for devices which might cause problems. 
(NB.  data transfer rates would be a maximum of: synchronous = 5Mb/
sec asychronous = 3.5Mb/sec.)



12.2) SCSIFS
Handling of SCSI floppy discs has been suggested, but there are some 
difficulties associated with this due to the limitations of accessing 
floppy discs over the SCSI bus.



12.3) SCSI Tape
Unclear without user feedback.



12.4) SCSI Printer

Unclear without user feedback. One suggestion has been to put a drive
selection on the printer dialogue box. This has been left out until there is
some user feedback. Also, multiple paper bin handling on SCSI printers may
be added in future.



Appendix A)

RISC OS SCSIdriver
==================

Author: Nick Reeves, Richard Manby, BC
Version: 0.18
 
History

1) 24-Nov-88 NR:        Initial draft
2) 02-Dec-88 NR:        Added a) timeout parameter for SCSI_Op
                              b) SCSI_Op to return operation id number, which
                                 can be used to abort operation.
                              c) parameter for number of bytes of extended
                                 sense
0.03: 31-Jan-89 RCM:    Copy placed in Arf:doc
0.04:  1-Mar-89 RCM:    Defined data returned by 'Determine Device'
0.05: 15-Mar-89 RCM:    Removed 'Establish Device' and 'Remove Device'
                        reason codes from SWI SCSI_Initialise.
                        Changed reason codes for 'Determine Device' in
                        SWI SCSI_Initialise from 4 to 2.
                        Removed 'Return error statistics' from
                        SWI SCSI_Status.
                        SWI SCSI_Op; Moved transfer direction, Scatter,
                        Poll, Retry & Background Bits in R0 into MSByte to
                        leave room for its device ID field to grow.
                        Added 'Set Error Response','Set Queue Behaviour' &
                        'Disconnect' to SWI SCSI_Control.
0.06: 17-Apr-89 RCM:    Removed the scatter list Bit from SWI SCSI_Op, this
                        Bit is now reserved.
                        Commands execute totaly in the foreground or in the
                        background. The 'return-after-some-of-the-data-has-
                        been-transfered' cannot be supported by SCSI.
                        Added section on error messages.
0.07: 25-Apr-89 RCM:    Tidied up some of the error messages
                        Full definition of Host ID and Device ID
0.08: 16-May-89 RCM:    Reordered reason codes for
                        SCSI_Control-SetErrorResponse.
                        SetErrorResponse, SetTimeout & ControlDisconnect
                        now return their previous settings.
0.09: 08-Jun-89 BC+RCM: Changed spec of SCSI_Version to indicate the
                        hardware and software types as a Bitset.  Added all
                        the error messages and their numbers,
                        documented *Devices.  Admitted to total reentrancy
                        and interrupt kosherness.
                        Scatter list reimplemented.

0.10: 26-Jun-89 RCM:    Removed restrictions on device having to be idle
                        before issuing SWI SCSI_Control (eg on SetTimeout).
                        Defined bit value for 'supports scatterlist' and for 
                        'supports device reservation'.
                        Added SWI SCSI_Reserve.
                        Added R8 (access key) to any dangerous operations.
0.11: 30-Jun-89 RCM:    Reordered the error message section, so it made
                        more sense.
                        Added recommendations to SCSI_Control about the use
                        of the control_disconnect reason code.
0.12: 04-Jul-89 RCM:    Changed "Device reserved" to "Reservation error"
0.13: 12-Jul-89 RCM:    Added SWI SCSI_List, *ScsiBlock
0.14: 23-Aug-89 RCM:    Added accesskey to *ScsiBlock
0.15: 29-Aug-89 RCM:    Added reason code 3 to SWI SCSI_Initialise.
0.16: 04-Sep-89 RCM:    Changed "Reservation error" to
                        "SCSI driver reservation error" 
0.17: 19-Oct-89 RCM:    Reset Bus restores various defaults.
0.18: 20-Oct-89 RCM:    Added SBIC bug warning.
0.19: 09-Nov-90 JSR:    Added SCSI_TargetControl details from John Ballance Computing.
0.20: 14-Nov-90 JSR:    Minor corrections to SCSI_TargetControl.
0.21: 17-Jun-91 JSR:    Enhancements to SCSI_TargetControl:
                        Target handler routine r0 in top byte is ID of host
                        Target handler routine r0 out = &80000000 to indicate
                                command implemented by the handler.
0.22: 14-Jan-93 JSR:    Add over-title SCSIDriver Application Note and Acorn
                                object number (0470,207)
                        Add programmer note regarding keeping the SCSI host
                                ID unchanged across a bus reset.



                   ======================================
                   SCSIDriver Application Note (0470,207)
                   ======================================


                --------------------------------------------
                INTERFACE FOR THE RISC OS SCSI DEVICE DRIVER
                -------------------------------------------- 


                                Introduction
                                ============
The SCSI device driver for RISC OS is a relocatable module whose
interface consists of the following SWIs:

SCSI_Version              403C0    603C0
SCSI_Initialise           403C1    603C1
SCSI_Control              403C2    603C2
SCSI_Op                   403C3    603C3
SCSI_Status               403C4    603C4
SCSI_ReadControlLines     403C5    603C5
SCSI_EEProm               403C6    603C6
SCSI_Reserve              403C7    603C7
SCSI_List                 403C8    603C8
SCSI_TargetControl        403C9    603C9

and the following * commands:

*Devices
*ScsiBlock   (N.B. NOT IMPLEMENTED BY ACORN SCSIdriver)




Note on Device ID and Host ID
-----------------------------

The device ID is a composite of the SCSI id number, the logical unit number
(LUN) within the device and the logical slot number of the SCSI card.
They are packed into 8 bits as follows:

  Bits 2..0  SCSI device id (0..7)
  Bits 4..3  Logical SCSI card number (0..3)
  Bits 7..5  Logical unit number      (0..7)


The SCSI card numbering is based on the relative slot positions of any SCSI
cards in the machine, thus in a machine with 2 cards, in physical slots 2
and 4 they are refered to as logical SCSI card numbers 0 and 1. In a machine
with 1 card it may be placed in any slot refered to as logical SCSI card
number 0.

The host ID is a similar composite, but of SCSI id number and logical slot
number, with no LUN field.

  Bits 2..0  Host device id (0..7) - Usually 7
  Bits 4..3  Logical SCSI card number (0..3)


The Host device id is usually 7 and there must be no other devices on the
bus with the same id.


                                The SWIs
                                ========

All SWIs conform to the RISC OS standard that is
a) Any registers not explicitly defined as result parameters are preserved
b) The processor flags N,Z and C are preserved.
c) Errors are indicated by setting V and returning with R0 pointing at an
   error block (If the Bit 17 clear version is called control passes to
   the error handler instead).
d) All SWIs preserve the interrupt state unless stated otherwise, and so
   they may be called from interrupt or event routines.
e) All SWIs are reentrant.


----------------------------------------------------------------------------


SCSI_Version (403C0 & 603C0)
============
This SWI is used to determine the version number of the drivers, whether it
supports any particular later extension, and what particular hardware
implementation is present.

entry: no parameters

exit:
 R0 Bits 0..7 software minor version number, 0 for any release
    Bits 8..31 software major version number eg 100 for 1.00
 R1 Bitset of software features
 R2 Bits 0..7 hardware minor version number, 0 for any release
    Bits 8..31 hardware major version number eg 100 for 1.00
 R3 Bitset of hardware features

The Bitset of software features is defined as follows;
    Bit  31     Supports target mode
    Bit  30     Supports configuration
    Bit  29     Supports reading control lines
    Bit  28     Supports device reservation
    Bit  27     Supports multiple SCSI cards (and hence SWI SCSI_List)
    Bit  26     Supports *ScsiBlock
    Bits 25..16 Reserved must be 0
    Bits 15..7  Reserved must be 1
    Bit  6      Supports *Devices
    Bit  5      Supports scatter list for SWI SCSI_Op
    Bit  4      Supports messaging
    Bit  3      Supports automatic "Request Sense"
    Bit  2      Supports command queueing
    Bit  1      Supports background data transfer
    Bit  0      Supports target disconnect/reconnect

The Bitset of hardware features is defined as follows;
    Bit  31     Supports configuration
    Bits 30..16 Reserved must be 0
    Bits 15..1  Reserved must be 1
    Bit  0      Supports target mode

errors: none


---------------------------------------------------------------------------


SCSI_Initialise (403C1 & 603C1)
===============
This SWI performs various initialisations determined by a reason code in R0.
Any additional parameters are given in subsequent registers.


'Reset Bus'
-----------
entry:
 R0 0
 R1 host ID

This call resets all options set by SCSI_Control to their default states and
removes any device reservations. In addition it sets a new host ID and
causes a full reset of the SCSI bus by driving the SCSI bus RESET line.

The default states set for each device are
  Reservation     - none
  Timeout=0       - no timeout
  Error response  - report check condition as an error
  Queue behaviour - wait until slot becomes free
  Disconnect      - allow disconnect/reselect

Programmer note: if you wish to keep the SCSI host ID unchanged then quote
the ID of the device which returns the error 'Invalid SCSI device ID' from
the 'Determine Device' reason code.

success exit: no results

errors:
  &00020100 - No room for SCSI driver workspace
  &00020103 - SCSI bus failed to reset
  &00020104 - Invalid SCSI host ID


'Reset Device' - initiates the reset operation and returns immediately.
--------------
entry:
 R0 1
 R1 device ID
 R8 access key

success exit: no results

errors:
  &00020105 - Invalid SCSI device ID
  &0002010E - SCSI driver reservation error


'Determine Device' - performs an Inquiry command to see what type the device
------------------   is and then performs the appropriate Read-Capacity
                     command depending on the device type.
entry:
 R0 2
 R1 device ID
 R2 pointer to buffer for description, (16 bytes, word aligned).

success exit: buffer filled in

        Offset
 R2 -->   0    Type = &00    Direct-access            (eg magnetic disk)
                      &01    Sequential-access        (eg magnetic tape)
                      &02    Printer device
                      &03    Processor device
                      &04    Write-once read-multiple (eg some optical discs)
                      &05    Read-only                (eg some optical discs)
                      &06-7E Reserved
                      &7F    Logical unit not present
                      &80-FF Vendor unique

          1    Removable medium Bit (Bit7)/Device-Type Qualifier (Bits 0..6)
          2    ISO (b7..6)/ECMA (b5..3)/ANSI (b2..0) version
          3    Reserved (reserved field returned by inquiry command)

          4   Additional length, extra data that could be obtained by an
               inquiry command
          5   }
          6   } Reserved (by device driver - currently zero) 
          7   }

        8..11  word highest logical block number  (converted to normal)
       12..15  word block length                  ( ARM byte sex)


errors:
  &00020105 - Invalid SCSI device ID
  &0002010A - Timeout


Bytes 0..4 are the first 5 bytes returned by an inquiry command, byte 5 is
provided to indicate how much additional data (vendor ID,product ID etc)
could be obtained by an Inquiry command Bytes 5..7 are reserved by the
device driver

Bytes 8..11 (word 2) & 12..15 (word 3) are the highest block count and block
size returned by a Read Capacity command but have had the byte sex reversed
to suit ARM's LDR instruction.


'Enumerate Device' - performs an Inquiry command to see what type the device
------------------   is and then performs the appropriate Read-Capacity
                     Data returned as formatted text.
entry:
 R0 3
 R1 device ID
 R2 pointer to buffer for description, word aligned).
 R3 buffer size

The data returned is a zero terminated string of the same form as that
printed by *devices, ie

"ddd    ttttttttttttttttt cccc Mbytes vvvvvvvv pppppppppppppppp rrrr"

where the fields are device number, type, capacity, vendor, product and
revision number.

If a device doesn't respond, a string containing just the device number is
returned, if the device responds, but the 'read-capacity' call fails, the
capacity field will be set to unknown.


----------------------------------------------------------------------------


SCSI_Control (403C2 & 603C2)
============
This SWI issuess various control commands determined by a reason code in R0.
Any additional parameters are given in subsequent registers.


'Abort device' - cancels all outstanding operations on a device. 'Abort op'
--------------   should normally be used instead wherever possible.
entry:
 R0 0
 R1 device ID
 R8 access key

success exit: no results

errors:
  &00020105 - Invalid SCSI device ID
  &0002010E - SCSI driver reservation error


'Abort op' - cancels a particular operation on a device.
----------
entry:
 R0 1
 R1 device ID
 R2 operation id as returned by SCSI_Op
 R8 access key

success exit: no results

errors:
  &00020105 - Invalid SCSI device ID
  &0002010E - SCSI driver reservation error


Reserved
--------
entry:
 R0 2
 R8 access key


'Set Timeout' - sets the default timeout for a device.
-------------   
entry:
 R0 3
 R1 device ID
 R2 timeout value in centi-seconds or zero for no timeout
 R8 access key

exit:
 R2 previous timeout setting

errors:
  &00020105 - Invalid SCSI device ID
  &0002010E - SCSI driver reservation error


'Set Error Response' - controls the behaviour of CHECK CONDITION status.
--------------------
entry:
 R0 4
 R1 device ID
 R2 0  If device returns 'check condition', return that as an error message.
       This is for badly behaved devices with non-standard request sense
       return blocks.
    1  If device returns 'check condition' do a request sense automaticaly,
       report the error.
    2  If device returns 'check condition' do a request sense automaticaly, 
       if 'unit attention', ignore it and reissue the command else report
       the error.
   -1 no action, return previous setting.
 R8 access key

exit:
 R2 previous setting

errors:
  &00020105 - Invalid SCSI device ID
  &0002010E - SCSI driver reservation error


'Set Queue Behaviour'
---------------------

  The driver supports disconnection/reselection and queueing of commands,
this implies that when a command is issued, the podule hardware may be in
use servicing another command, a command maybe queued/running for the target
device or the queue may be full.

entry:
 R0 5
 R1 device ID
 R2 0                       ie if queue full loop until a slot becomes free
                               if command operates totally in the background
                               control returns to the caller as soon as the
                               command is queued
                               if the command operates in the forground,
                               portion, control returns when the command
                               completes.
    1 Reject if queue full  ie command accepted only if it can be queued/run
                               without waiting.
                               if command operates totally in background,
                               control returns to the caller as soon as the
                               command is queued
                               if the command operates in the forground,
                               portion, control returns when the command
                               completes.
    2 Reject if device busy ie command accepted only there are no other
       (or queue full)         queued/running for this device.
    3 Reject if podule busy ie accept command only if it will run immediatly
   -1 no action, return previous setting.
 R8 access key

exit:
 R2 previous setting

errors:
  &00020105 - Invalid SCSI device ID
  &0002010E - SCSI driver reservation error


'Disconnect' - Allow/Inhibit disconnect/reselect
------------

entry:
 R0 6
 R1 device ID
 R2 0 allow disconnect/reselect
      (ie when the bus selection phase is complete, the driver will attempt
          to send an IDENTIFY message with bit6 set, this tells the target that
          it may disconnect if it wants to).
    1 inhibit disconnect/reselect, so that once started, a command will proceed
      to completion without allowing any other command to start/reconnect.
      (ie when the bus selection phase is complete the driver will attempt
          to send an IDENTIFY message with bit6 clear).
    2 inhibit disconnect/reselect by not sending an identify message
   -1 no action, return previous setting.
 R8 access key

exit:
 R2 previous setting

errors:
  &00020105 - Invalid SCSI device ID
  &0002010E - SCSI driver reservation error


Note codes 0/1 cause SWI SCSI_Op to attempt to send an identify message once
     the bus selection phase is complete. The target may choose not to take the
     message (Not an error), in which case the driver proceedes to the command
     phase. The target may reply to the message with a message reject.
     These two cases do not produce an error from SCSI_Op, as the command may
     still complete successfully, it will however remain connected all the
     time.

Note Applications/filing systems are NOT expected to issue this call, as
     all software/hardware should work happily regardless of any disconnections
     that occur.

     It should only be issued by:

     1) The user (in his boot file) if his/her particular device mis-behaves
        when sent messages.

     2) Application/filing system software specific to one vendors product that
        is known to mis-behave when sent messages.


----------------------------------------------------------------------------


SCSI_Op (403C3 & 603C3) - issues a SCSI command to a device.
=======                   Can be called in the background.

 R0 Bits 0..7    Device ID
    Bits 24..25  00 => no data transfer, 01 => read, 10=>write, 11=>reserved
    Bit 26       Scatter Bit, if set, R3 is a pointer to a scatter list.
    Bit 27       If clear, poll escape during transfer and abort if escape
                 pressed
    Bit 28       If set, repeatedly retry on timeout
    Bit 29       Set if a background transfer (possibly 0 length).
 R1 Length of SCSI control block
 R2 Ptr to SCSI control block
 R3 RAM ptr for start of transfer or pointer to scatter list of address length
    pairs if Bit 26 of R0 is set. After each chunk in the scatter list is
    transferred the address should be incremented and the length set to 0.
 R4 Length of transfer (in bytes).
 R5 Timeout in centiseconds or 0 for default timeout
 R6 Address to call back when transfer is complete if background Bit set.
    The call is made in IRQ mode with IRQs disabled.
    If an error has occurred, V is set, R0 points to a non-dynamic error
    block, (ie a pointer to a fixed block in the module rather than built
    up in a buffer), R1 indicates the cause of the error and R2 the logical
    address on the device of where the error occured.
 R7 Workspace pointer to pass in R12 for background call back.
 R8 access key

exit (V clear)
 R0 returns a 32 Bit id incremented for each operation. Used to cancel op.
 R3 updated to indicate how much of transfer was successful (if scatter
    list, pointer to first unused/partially used entry).
 R4 updated to the amount untransferred

exit (V set)
 R0 points to an error block
 R1 indicates the cause of the error
 R2 hold the logical address on the device of where the error occured.
 R3 updated to indicate how much of transfer was successful (if scatter
    list, points to first unused entry, entry is updated to indicate amount
    transfered).
 R4 updated to the amount untransferred

errors:
 many

Interrupts may be enabled by the call, this does not affect it's reentrancy.

N.B. See below for detailed description of errors


----------------------------------------------------------------------------


SCSI_Status (403C4 & 603C4)
===========
This SWI issues various control commands determined by a reason code in R0.
Any additional parameters are given in subsequent registers.


'Check Device Status' - returns the status of the selected device
---------------------
entry:
 R0 0
 R1 device ID

success exit:
 R0 status
    1 => Idle
    2 => Busy
    4 => Error
   16 => not available

errors:
  &00020105 - Invalid SCSI device ID



----------------------------------------------------------------------------


SCSI_ReadControlLines (403C5 & 603C5)  N.B. NOT IMPLEMENTED BY ACORN SCSIdriver
=====================

Returns current state of SCSI bus lines 

entry:
 R0 host ID

success exit: 
 R0 SCSI data bus
 R1 Control lines, 1 = asserted :
    Bit  7   6   5   4   3   2   1   0
        RST BSY REQ MSG C/D I/O SEL DBP                    

 R2 Control lines, 1 = asserted : 
    Bit   7   6   5   4   3   2   1   0 
                                 ATN ACK       
    (Bits 7..2 are Bits of 5380 bus & status register)

errors:
  &00020104 - Invalid SCSI host ID


----------------------------------------------------------------------------


SCSI_EEProm (403C6 & 603C6)            N.B. NOT IMPLEMENTED BY ACORN SCSIdriver
===========

Reads/writes EEProm on SCSI podule 

entry: 
 R0 Bits 0..3 address of 16 Bit word
    Bit 10 set for write, clear for read
 R1 Bits 0..15 write data (if R0 Bit 10 set)

success exit: 
 R0 data read if R0 Bit 10 was set on entry
 R0 preserved if R0 Bit 10 was clear on entry

errors:


----------------------------------------------------------------------------


SCSI_Reserve (403C7 & 603C7)
============

This SWI allows the caller to claim exclusive use of a device and may prevent
data corruption problems that may arise if a program (by accident or on
purpose) issues a Write/Format/ModeSelect command to a device currently mounted
by SCSIFS.

It also provides for a clean change of device ownership from one user to
another, as SCSIdm for example is entitled to modify your disc, (to map out
defects/format/partition it etc) but must only do so once SCSIFS has closed
down all open files and dismounted the disc.


'Claim' - Claim exclusive use of a device
-------

This call attempts to claim exclusive use of the given device.
If the call is successful, the caller will be granted sole use of the
'dangerous' SCSIdriver calls for that device and may use them itself, only
by supplying the access key registered at 'Claim' time. Other callers
may only use safe calls such as SCSI_Initialise-DetermineDevice.

If the device has already been claimed, an error message
'SCSI driver reservation error' will be returned.

entry
  R0 0
  R1 device ID
  R2 release address
  R3 workspace pointer, to be passed in R12 when release address is called
  R8 access key

exit
  VC
  VS & R0-> error

errors:
  &00020105 - Invalid SCSI device ID
  &0002010E - SCSI driver reservation error


'ForceClaim'
------------

This call is similar to 'Claim' above, however, if the device is already
claimed, it will ask the current claimant to release it, by calling the
release address registered for that device.
The current owner should try to tidy up, and call 'Release' but may refuse
by returning VS and R0 pointing to an error message

Aside: This call is used by SCSIdm to ask SCSIfs to close files and dismount
       etc

entry
  R0 1
  R1 device ID
  R2 release address
  R3 workspace pointer, to be passed in R12 when release address is called
  R8 access key

exit
  VC
  VS & R0-> error

errors:
  &00020105 - Invalid SCSI device ID
  &0002010E - SCSI driver reservation error
  OR an error message passed back by the current claimant.

When the current claimant is called R0 will hold a reason code indicating:
  R0 = 1 called from ForceClaim


'Release'
---------
This call will remove the reservation of a device.

entry
  R0 2
  R1 device ID
  R8 access key  (to prove you actually claimed it)

exit
  VC
  VS -> error

errors:
  &00020105 - Invalid SCSI device ID
  &0002010E - SCSI driver reservation error


Passing access key value to SCSI SWI's
======================================
The access key (probably WorkSpacePointer) should be passed in R8
and is only checked if the specified device is claimed and the call/reason
code is 'dangerous'.


----------------------------------------------------------------------------


SCSI_List (403C8 & 603C8)
=========

This is used by the ScsiLog module as part of the multiple SCSI card
initialisation sequence (see separate SCSILog documentation).

exit:
 R0 -> Null terminated list of podule addresses

This SWI returns a pointer to a null terminated list of SCSI podules
available to SCSIdriver. The addresses are those of the 'slow access' space
for the podule, ie, 
 &03240000, &03244000, &03248000 or &0324C000 for podule slot 0,1,2 or 3.


----------------------------------------------------------------------------


SCSI_TargetControl (403C9 & 603C9)
==================================

This SWI is to enable an application to register routines with the
SCSIDriver which provide target mode responses to commands sent from another
SCSI host via the SCSI bus. The host ID of the SCSI driver is also the
target ID seen by other hosts across the SCSI bus, but separate routines must
be registered for each of the 8 logical units (LUN) that can exist for this
ID.

On entry:
 r1 = Bit       Meaning
      0..2      Reserved, should be set to 0
      3..4      Podule number
      5..7      LUN
      8..32     Reserved, should be set to 0
 r2 = Address of the target handler routine, or 0 to deregister the target
        handler on the given podule and LUN.
 r3 = Address of the deregistration routine. This routine will be called
        when the handler on the given podule and LUN is deregistered. This
        may happen, for example, if another pair of routines is registered
        or if the SCSIDriver is reinitialised.
 r4 = Value to be passed in r12 when either of the above two routines is
        called.

On exit:
 r2 = Address of the routine to call to read bytes from the SCSI bus.
 r3 = Address of the routine to call to write bytes to the SCSI bus.
 r4 = Address of the routine to call to reconnect to a previously
        disconnected host, or 0 if this feature is not implemented.
 r5 = value to be passed in r12 when any of the above routines are called.

The target handler routines are called in SVC mode with interrupts enabled
and the return address in r14. The SCSIDriver will ensure that none of the
routines are reentered until they have returned to the SCSIDriver module.
The routines must be in the RMA.

Target handler routine:
On entry:
 r0 = Bits      Meaning
      0..7      Byte 0 of the CDB
      8..15     Byte 1 of the CDB
      16..23    Host mode SCSI ID
      24..31    Host SCSI ID
 r12 = value passed to SCSI_TargetControl in r4
 r14 = return address

On exit:
 r0 = r0 as passed in if the command specified in byte 0 of the CDB was not
        implemented by this handler, or &80000000 if the command was
        implemented.
 r1 = Bits      Meaning
      0..7      Sense code
      8..15     Sense key
      16..23    termination status
      24..31    termination message

The target handler routine is called in SVC mode with interrupts enabled. The
SCSIDriver will ensure that this routine will not be reentered for the given
LUN until it returns control to the SCSIDriver.

If the command is not implemented by the handler, as indicated by 
the handler returning &80000000 in r0, then the SCSIdriver must 
handle the command itself, in one of two ways:
    1) Perform its own command
    2) Return a status "CHECK CONDITION", upon receipt of next 
       "REQUEST SENSE"  command, return a valid "ILLEGAL
       REQUEST" sense block.

The commands which should be handled by the SCSIdriver by 
default, (although the handler may handle them first) are as follows:-
  (&00) Test Ready
  (&03) Sense Mode
  (&12) Identify

Valid data for each of these commands must be returned.

The driver may wish to handle other optional SCSI commands as it 
sees fit, if the handler routine does not.

The final status and command complete message phases are implemented by the
driver module. If the termination message is 0, then a status phase and
message command complete phase are given before disconnection. If the
termination message is disconnection (3), then both a save pointers message
and a disconnection message are given before disconnection, but no status
phase is given.

Calling the read bytes and write bytes routines:
On entry:
 r0 = SCSI bus phase to use:
        0       Data to target
        1       Data from target
        2       Command to target
        3       Status from target
        4       Illegal
        5       Illegal
        6       Message to target
        7       Message from target
 r2 = Transfer count
 r3 = data source or destination address
 r12 = value in r5 returned from SCSI_TargetControl
 r14 = Return address

On exit:
 r0 = corrupted
 r3 = advanced past the bytes transfered

Calling the reconnection routine:
On entry:
 r0 = ID to reconnect to
On exit:
 r0 = 0 if the reconnection was successful, or a pointer to a standard
        error block if not.
 r3 corrupted.

----------------------------------------------------------------------------

SCSI messages & error codes
===========================

Errors reported by the SCSIdriver fall into 3 classes:
1) Those generated/detected by the driver
2) Interpretations of the SCSI status byte returned on command completion.
3) Interpretation of the sense data (collected on CHECK CONDITION status if
   the error response is set to 0 or 1).


Device driver errors
====================

&00020100 = "No room for SCSI driver workspace"
&00020101 = "Unknown SCSI SWI number"
&00020102 = "Unknown reason code for SCSI SWI"
&00020103 = "SCSI bus failed to reset
&00020104 = "Invalid SCSI host ID"
&00020105 = "Invalid SCSI device ID
&00020109 = "Device not idle"
&0002010A = "Timeout" ; During selection phase
&0002010B = "Timeout" ; During any other phase
&0002010C = "Command queue not empty"
&0002010D = "Command queue full"
&0002010E = "SCSI driver reservation error"
&0002010F = "Invalid parameters"
&00020110 = "Parameter error"
&00020111 = "Not callable from IRQ routine"  (reported by podule loader)
&00020112 = "Operation aborted"
&00020113 = "Unexpected disconnection"

Interpretation of the returned SCSI status byte
===============================================

On completion of the command, the target returns a status byte.
The Vendor unique Bits are masked out and the following interpretations
placed on the result.  If the returned status is GOOD then that is not an
error so there will not be an error returned.  If the status retured is not
GOOD then it will be translated into one of the following three errors;

&00020180 = "Target status - Check condition"
&00020181 = "Target status - Busy"
&00020182 = "Target status - Unknown"

Any other value, including GOOD/CHECK CONDITION/BUSY with reserved Bit 7
set, is reported as an error "Target status - Unknown"

If the error response level is 1 or 2, then on 'CHECK CONDITION', the driver
will automatically perform a request sense.


Interpretation of the Sense data
================================

The first byte of returned sense data is masked to leave the
Error-class/error-code code Bits these are interpreted as:

0x..6x vendor unique error (non extended sense) } Reported as
71..7E reserved error      (extended sense)     } "Target error - Unknown"
7F     vendor unique error (extended sense)     }

70                         (extended sense), the error is given by examination
                           of the 'sense key' in byte 2 of the sense data


&000201C0 = "Target error - No sense"
&000201C1 = "Target error - Recovered error"
&000201C2 = "Target error - Not ready"
&000201C3 = "Target error - Medium error"
&000201C4 = "Target error - Hardware error"
&000201C5 = "Target error - Illegal request"
&000201C6 = "Target error - Unit attention"
&000201C7 = "Target error - Data protect"
&000201C8 = "Target error - Blank check"
&000201C9 = "Target error - Vendor unique"
&000201CA = "Target error - Copy aborted"
&000201CB = "Target error - Aborted command"
&000201CC = "Target error - Equal"
&000201CD = "Target error - Volume overflow"
&000201CE = "Target error - Miscompare"
&000201CF = "Target error - Reserved sense key"

&000201D0 = "Target error - Unknown"


Errors produced by calling SWI SCSI_Op
======================================

When an error is returned by a call of SWI SCSI_Op, in addition to the normal
error pointer in R0, R1 and R2 provide extra information:

R0 -> error message     - a standard RISC OS error block, consisting of a 1
                          word error number, followed by an error message
R1  = error indication  - this is a composite of the LSB of the above error
                          number and the status/sense-errorclass/sense key
                          that produced the error.
R2  = logical address on the device of where the error occured.



Device driver detected errors
=============================

R1 MSB = the LSB of the RISC OS error number. ie 0..127
R1     = 0 (see note below)
R1     = TBA } If error was due to an unexpected bus phase, the phase could
R1 LSB = TBA } be indicated here - assume undefined for now.

R2     = undefined
R3     = undefined
R4     = undefined


Status byte errors
==================

R1 MSB = the LSB of the RISC OS error number. ie 128..195
R1     = 0 (see note below)
R1     = 0
R1 LSB = returned status byte (unmasked)

R2     = undefined
R3     = indicates amount of data transfered
R4     = amount of data not transfered



Returned Sense data
===================

Non-extended sense data returned
--------------------------------
R1 MSB = the LSB of the RISC OS error number. ie 196..255
R1 UMB =   Bits 23..16 holds byte 0 of the returned sense data
           Bit  23     is the 'Valid' Bit and is set if the 'Logical block
                       address' in the returned sense data (in R2) is valid.
           Bits 22..20 are the 'error class'
           Bits 19..16 are the 'error code'
R1 LMB =   Bits 15..13 are the 'vendor unique' Bits from byte 1
           Bits 12..8  are zero
R1 LSB =   Bits 7..0

R2     = 'Logical block address' returned in bytes 1..3 of the returnrd sense
          data (the vendor unique Bits masked out).
R3     = indicates amount of data transfered
R4     = amount of data not transfered


Extended sense data returned
----------------------------
R1 MSB = the LSB of the RISC OS error number. ie 196..255
R1     = byte 0 of the returned sense data
           Bit 23 is the 'Valid' Bit and is set if the 'Information bytes'
                  in the returned sense data (now in R2) are valid.
           Bits 22..20 are the 'error class'
           Bits 19..16 are the 'error code'
R1     = 'segment number' ie byte 1 of the returned sense data
R1        byte 2 of the returned sense data
            Bit7      is 'Filemark'
            Bit6      is 'EOM'
            Bit5      is 'ILI'
            Bit4      is 'reserved'
            Bits 3..0 hold the 'sense key'
R2     = the 'information bytes' returned as bytes 3..6 of the sense data,
         (byte sex reversed to suit ARM).
R3     = indicates amount of data transfered
R4     = amount of data not transfered


NOTE Bit 23 of R1 always indicates data-in-R2-is-valid, as it is either the
     'valid' Bit returned by the request sense command, or zero.



----------------------------------------------------------------------------

                                The * commands
                                ==============

*Devices
========

  *Devices displays information on the devices attached to the SCSI
 bus(es).  The resulting display shows the type of each device this can be
either "Direct-access", "Sequential-access", "Printer", "Processor", "WORM",
"Read-only", "Scanner", "Optical memory", "Changer", Communications",
"Unknown", and "Host".  The capacity is calculated by multiplying the
highest block number by the block size, as returned by a Read Capacity
command.  The Vendor, Product and Revision fields are provided by the
Inquiry command, and are displayed with mimimal formating.  An example of
the output of this command is shown below;

Device Type              Capacity    Vendor   Product          Revision
0      Direct-access       18 Mbytes RODIME   RO652            5.02
1      
2      Direct-access      100 Mbytes CONNER   Cp3100-100mb-3.5 0.0C      
3      Read-only           27 Mbytes HITACHI  CDR              0004
4
5      Direct-access       43 Mbytes RODIME   RO3000S          1.24
6
7      Host                          ACORN    SCSI expansion   0000


*ScsiBlock                       N.B. NOT IMPLEMENTED BY ACORN SCSIdriver
==========



*ScsiBlock  adr accesskey  devID  cdb0 cdb1 cdb2...



*ScsiBlock issues a SCSI command to the target device.
  adr        - is the address data transfer address
  acesskey   - access key value for specified device.
  devID      - is the SCSI deviceID
  cbd0       - onwards (maximum of 12 parameters) are the bytes of the SCSI
               command block to be sent.

all parameters are assumed to be decimal, unless preceded by a & 
which indicates that the value is Hexadecimal.

errors unique to this command
&0002010F - "Invalid parameters"
&00020110 - "Parameter error"



Warning
=======
The use of SWI SCSI_Control with R0=1 (Abort Op), or the use of command
timeouts may prove unreliable with certain versions of the WD33C93A SCSI bus
interface controller. The current version of the chip, revision C, is known
to exhibit problems, it is expected that later revisions will not.

The SBIC has a tendancy to hang if a RaiseATN command (issued by the device
driver abort command code) is issued during a data-out phase.

