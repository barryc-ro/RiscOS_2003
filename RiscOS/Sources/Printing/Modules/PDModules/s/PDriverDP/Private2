; > Sources.PDriverDP.Private2


; *************************************************************
; Coordinate scaling
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

YScale ROUT          ; apply currentYscale to r0
           Push  "r1, lr"
           BL     times_currYs
           B      %FT01

XScale               ; apply currentXscale to r0
           Push  "r1, lr"
           BL     times_currXs
01         MOV    r1, #180
           BL     Divide
           Pull  "r1, pc"

;; The old versions of these routines were incorrect!
;; The mantissa (lower 16 bits) of currentXscale can easily be &8000,
;; in which case, since r0 can be > &8000, overflow occurs.
;; The solution is to split r0 itself into 2 when calculating the mantissa.
;;
;; if    r0 = (x_hi << 16) + x_lo
;;    scale = y_hi + (y_lo >> 16)
;; answer := (((x_hi << 16) + x_lo) * (y_hi + (y_lo >> 16))
;;         = (x_hi*y_hi << 16) + x_hi*y_lo + x_lo*y_hi + (x_lo*y_lo >> 16)
;;
;; Note that x_hi and y_hi must be sign-extended.

;; times_currXs ROUT             ; times_currYs was similar
;;           Push  "r1, lr"
;;           LDR    r1, job_currentXscale
;;           MOV    lr, r1, LSR #16
;;           BIC    r1, r1, lr, LSL #16
;;           MUL    r1, r0, r1        ; low part of answer
;;           MOV    r1, r1, LSR #16   ; scaled back down
;;           MLA    r0, lr, r0, r1    ; X coord * current scale
;;           MOV    r0, r0, LSL #bufferpix_l2size
;;           Pull  "r1, pc"

times_currXs ROUT
           Push  "r1-r3, lr"

           LDR    r1, job_currentXscale
           MOV    r2, r1, ASR #16       ; r2 = scale_hi
           BIC    r1, r1, r2, LSL #16   ; r1 = scale_lo
           MOV    r3, r0, ASR #16       ; r3 = input_hi
           BIC    r0, r0, r3, LSL #16   ; r0 = input_lo

           MUL    lr, r2, r0            ; lr = scale_hi * input_lo
           MLA    lr, r1, r3, lr        ; lr = scale_lo * input_hi + lr
           MUL    r0, r1, r0            ; r0 = scale_lo * input_lo
           MUL    r1, r2, r3            ; r1 = scale_hi * input_hi

           ADD    r0, lr, r0, LSR #16
           ADD    r0, r0, r1, LSL #16   ; r0 = answer!

           MOV    r0, r0, LSL #bufferpix_l2size
           Pull  "r1-r3, pc"

times_currYs ROUT
           Push  "r1-r3, lr"

           LDR    r1, job_currentYscale
           MOV    r2, r1, ASR #16       ; r2 = scale_hi (signed)
           BIC    r1, r1, r2, LSL #16   ; r1 = scale_lo
           MOV    r3, r0, ASR #16       ; r3 = input_hi (signed)
           BIC    r0, r0, r3, LSL #16   ; r0 = input_lo

           MUL    lr, r2, r0            ; lr = scale_hi * input_lo
           MLA    lr, r1, r3, lr        ; lr = scale_lo * input_hi + lr
           MUL    r0, r1, r0            ; r0 = scale_lo * input_lo
           MUL    r1, r2, r3            ; r1 = scale_hi * input_hi

           ADD    r0, lr, r0, LSR #16
           ADD    r0, r0, r1, LSL #16   ; r0 = answer!

           MOV    r0, r0, LSL #bufferpix_l2size
           Pull  "r1-r3, pc"

;.............................................................................

Divide     ROUT      ; r0:= r0/r1, sign of r0 noted
           Push   "r1-r3, lr"
           MOVS    lr, r0
           RSBMI   r0, r0, #1

         [ debugPrivate
           CMP     r1,#0
           BNE     %FT80
           Debug   ,"****Division by zero"
80
         ]
           ADD     r0, r0, r1, LSR #1      ; rounded division
           DivRem  r2, r0, r1, r3
           CMP     lr, #0
           RSBMI   r0, r2, #0
           MOVPL   r0, r2
           Pull   "r1-r3, pc"

; swap output to the sprite at the start of the job_currentbuffer sprite area

redirect_output ROUT
         Push   "r0-r3, lr"

  ; need to get redirection params in sprite pointer form for
  ; recognition by main code

         LDR     r2, job_currentbuffer

  ; can't call get_sprite_address as we need r1 on exit as well!

         LDR       r1, job_spritearea
         CMP       r1, #0
       [ debugPrivate
         BGE       %FT80
         Debug     Private,"*********** redirect_output: no sprite area !!!"
80
       ]
         MOVEQ    r0, #3
         SWIEQ    XOS_ReadDynamicArea
         MOVEQ    r1, r0
         LDR      r0, =SpriteReason_SelectSprite+256
         BL       pass_spriteop

         BVS      %FT99

         Debuga   Private,"swap output to sprite area @",R1

         LDR      r0, =SpriteReason_SwitchOutputToSprite+512
         LDR      r3, job_VDUsavearea

       [ debugPrivate
         Debug   ,", save area",R3
         LDR     LR,[R3]
         Debug   ,", first word",LR
         LDR     LR,job_savedVDUstate
         CMP     LR,#0
         BEQ     %FT80
         Debug   ,"** output already redirected"
80
       ]
         ADR     lr, jobspriteparams
         STMIA   lr, {r0-r3}
         BL      pass_spriteop

         ADRVC   lr, job_savedVDUstate
         STMVCIA lr, {r0-r3}

         MOVVC   r0, #5
         BLVC    vdu_char

;; we must invalidate ColourTrans's cache, as output bitmap is changing
;; (also done in PDriverDP.ManageJob: restore_output_state)

         SWIVC   XColourTrans_InvalidateCache   ;; ADDED BY NRAINE

99       STRVS   r0, [stack]
         Pull   "r0-r3, pc"

myspriteop
         LDR     r1, job_spritearea
         CMP     r1, #0
       [ debugPrivate
         BGE     %FT80
         Debug   ,"*** myspriteop: no sprite area"
80
       ]
         MOVLT   pc, lr                 ; not yet allocated
         ADDNE   r0, r0, #256

pass_spriteop
         Push   "r11, lr"
         ASSERT :BASE: passthrough = 12

         LDRB    r11, passthrough
         ORR     lr, r11, #passthrough_spr
         STRB    lr, passthrough
         SWI     XOS_SpriteOp             ; redirect output

         STRB    r11, passthrough
         Pull   "r11, pc"


; find a name in the current sprite area not in use, create it

fourzeros   = "0000"

create_buffer_sprite
        Push    "r2, r3, r6, lr"
        LDR      lr, fourzeros
        STR      lr, [r2]
        STR      lr, [r2, #4]
        STR      lr, [r2, #8]
02      BL       get_sprite_address
        BVS      %FT01                ; doesn't exist: can use this name
        LDR      r2, [stack]
03      LDRB     lr, [r2]
        ADD      lr, lr, #1
        CMP      lr, #"9"+1
        MOVEQ    lr, #"0"
        STRB     lr, [r2], #1
        BEQ      %BT03
        LDR      r2, [stack]
        B        %BT02

01      MOV      r0, #SpriteReason_CreateSprite
        MOV      r3, #0

    [ MonoBufferOK
      [ NbppBufferOK
        LDRB     r6, job_output_bpp
        CMP      r6, #8
      |
        LDRB     r6, job_use_1bpp
        CMP      r6, #0
      ]
        MOVEQ    r6, #21               ; a square pixel 256 colour mode
        MOVNE    r6, #18               ; a square pixel mono mode
    |
        MOV      r6, #21               ; a square pixel 256 colour mode
    ]
        [ Libra1
        Push    "R0"
        LDRB    R0, job_strip_type
        CMP     R0, #4                 ; if output sprite strip - 16bpp
        MOVEQ   R0, #5                  ; create fancy spritetype with 16bpp information
        MOVEQ   R6, R0, LSL #13         ; 16bpp
        MOVEQ   r0, #90
        ORREQ   R6, R6, R0              ; Vdpi = 90
        MOVEQ   R6, R6, LSL #13
        ORREQ   R6, R6, R0              ; Hdpi = 90
        MOVEQ   R6, R6, LSL #1
        MOVEQ   R0, #1
        ORREQ   R6, R6, R0              ; distringuishing bit
        Pull    "R0"
        ]
        [ Libra1
        Push    "R0"
        LDRB    R0, job_strip_type
        CMP     R0, #5                 ; if output sprite strip = 32bpp
        MOVEQ   R0, #6                  ; create fancy spritetype with 32bpp information
        MOVEQ   R6, R0, LSL #13         ; 32bpp
        MOVEQ   r0, #90
        ORREQ   R6, R6, R0              ; Vdpi = 90
        MOVEQ   R6, R6, LSL #13
        ORREQ   R6, R6, R0              ; Hdpi = 90
        MOVEQ   R6, R6, LSL #1
        MOVEQ   R0, #1
        ORREQ   R6, R6, R0              ; distringuishing bit
        Pull    "R0"
        ]
    [ debugPrivate
      LDRB   lr, [r2, #12]
      STRB   r3, [r2, #12]
      Debuga  ,"Create sprite ",R2
      STRB   lr, [r2, #12]
      Debuga ,", width",r4
      Debug  ,", height",r5
    ]

        BL       myspriteop

;We have now created the sprite, for ColourTrans 0.90+ we need to add
;a palette block in for this.  We use the sprite reason to create
;one, space will already have been allocated for this.
        [ Libra1
        BVS     %FT01
        LDRB    LR, job_strip_type
        CMP     LR, #4
        CMPNE   LR, #5
        MOVNE   R0, #SpriteReason_CreateRemovePalette
        MOVNE   R3, #&100
        BLNE    myspriteop              ; Attempt to append a suitable palette
01
        |
        MOVVC   R0, #SpriteReason_CreateRemovePalette
        MOVVC   R3, #&100
        BLVC    myspriteop              ; Attempt to append a suitable palette

        ]
        Pull    "r2, r3, r6, pc"

; get the address of the named sprite in the current spritearea

get_sprite_address ROUT
        Push     "r0, r1, lr"
        LDR       r1, job_spritearea
        CMP       r1, #0
      [ debugPrivate
        BGE       %FT80
        Debug     ,"*** no sprite area"
80
      ]
        MOVEQ     r0, #3
        SWIEQ     XOS_ReadDynamicArea
        MOVEQ     r1, r0
        LDR       r0, =SpriteReason_SelectSprite+256
        BL        pass_spriteop
        STRVS     r0, [stack]
        Pull     "r0, r1, pc"

; transform a point in the current rectangle space

transform_point ROUT
        Push  "r0-r3, r7, lr"

  ; transform coordinates with matrix
        LDR    r7, recttransform
        BL     full_signed_multiply
        Push  "r0, r1"
        LDR    r0, [stack, #12]
        LDR    r7, recttransform+8
        BLVC   full_signed_multiply
        Pull  "r2, r3"
        Pull  "r0-r3, r7, pc",VS
        ADDS   r1, r1, r3
        ADCS   r0, r0, r2              ; r0 is new x coordinate, OS units*2^16
        Pull  "r0-r3, r7, pc",VS

 ;  convert to 1/72000 inch from OS coordinates:
 ; i.e. multiply by 72000/180 = 400
 ; but coordinates are currently 2^16 too big
 ; so shift down 12 and multiply by &19

        MOV    r2, r1, LSR #8
        ADDS   r2, r2, r0, LSL #24     ; r2 := r0,r1 >>8
        ADDVCS r2, r2, r1, LSR #9
        ADDVCS r2, r2, r0, LSL #23     ; += r0,r1 >>9
        ADDVCS r2, r2, r1, LSR #12
        ADDVCS r2, r2, r0, LSL #20     ; += r0,r1 >>12
        Pull  "r0-r3, r7, pc",VS
        LDR    r0, [stack]
        STR    r2, [stack]

 ; repeat for Y coordinate
        LDR    r7, recttransform+4
        BL     full_signed_multiply
        Push  "r0, r1"
        LDR    r0, [stack, #12]
        LDR    r7, recttransform+12
        BL     full_signed_multiply
        Pull  "r2, r3"
        Pull  "r0-r3, r7, pc",VS
        ADDS   r1, r1, r3
        ADCS   r0, r0, r2              ; r0 is new y coordinate, OS units*2^16
        Pull  "r0-r3, r7, pc",VS

        MOV    r2, r1, LSR #8
        ADDS   r2, r2, r0, LSL #24     ; r2 := r0,r1 >>8
        ADDVCS r2, r2, r1, LSR #9
        ADDVCS r2, r2, r0, LSL #23     ; += r0,r1 >>9
        ADDVCS r2, r2, r1, LSR #12
        ADDVCS r2, r2, r0, LSL #20     ; += r0,r1 >>12
        STR    r2, [stack, #4]
        Pull  "r0-r3, r7, pc"

; update the visible area limits in job_print_area

update_limits ROUT
        Push "lr"

        Debuga Private,"update_limits with coords",R0
        Debug  Private,",",R1

 ;  clip against the current area

        LDR   lr, job_print_area
        CMP   lr, r0
        STRGT r0, job_print_area
        LDR   lr, job_print_area+8
        CMP   lr, r0
        STRLT r0, job_print_area+8

 ; repeat for Y coordinate

        LDR   lr, job_print_area+4
        CMP   lr, r1
        STRGT r1, job_print_area+4
        LDR   lr, job_print_area+12
        CMP   lr, r1
        STRLT r1, job_print_area+12

        Pull  "pc"
        LTORG

full_signed_multiply ROUT
        Push "lr"
        CMP   r7, #0
        RSBMI r7, r7, #0
        BL    full_multiply
        Pull "pc",VS
        Pull "pc",PL
        RSBS  r1, r1, #0
        RSC   r0, r0, #0
        RSB   r7, r7, #0
        Pull "pc"

; free a buffer sprite: pointer to name in R0

losebuffersprite ROUT
         Push "r0-r2, lr"
         MOV   r2, r0
         MOV   r0, #SpriteReason_DeleteSprite
         BL    myspriteop
         Pull "r0-r2, pc"


; routines to go with the vdu_ stuff in the main file

; send 2 bytes from r0

vdu_pair
     Push "r0, lr"
     BL    vdu_char
     MOVVC r0, r0, LSR #8
     BLVC  vdu_char
     STRVS r0, [stack]
     Pull "r0, pc"

; send a counted string @ r0

vdu_counted_string
    Push   "r0, r1, lr"
    LDRB    r1, [r0], #1
    BL      vdu_stringN
    STRVS   r0, [stack]
    Pull   "r0, r1, pc"


; do a 64 bit multiply where one of the operands may be negative.
; In: r7, known to be positive
;     r0, may be negative
; Out: r0, r1 contain r7*r0 (hi, lo)

full_multiply ROUT
    Push   "r0, r7, r8, r9, lr"
    SavePSR r9                      ; need to preserve entry flags except V
    BICVS   r9, r9, #V_bit
    CMP     r0, #0
    RSBMI   r0, r0, #0

    MOV     lr, r7, LSR #16         ; Ah
    BIC     r7, r7, lr, LSL #16     ; Al
    MOV     r8, r0, LSR #16         ; Bh
    BIC     r0, r0, r8, LSL #16     ; Bl: now got all the halfwords

    MUL     r1, r0, r7              ; low word: Al*Bl
    MUL     r7, r8, r7              ; intermediate: Al*Bh
    MUL     r0, lr, r0              ; intermediate: Ah*Bl
    MUL     r8, lr, r8              ; high: Ah*Bh

    ADDS    r1, r1, r0, LSL #16
    ADCS    r0, r8, r0, LSR #16
    ORRVS   r9, r9, #V_bit
    ADDS    r1, r1, r7, LSL #16
    ADCS    r0, r0, r7, LSR #16
    ORRVS   r9, r9, #V_bit

    Pull   "r7"

    CMP     r7, #0
    BPL     %FT99

    RSBS    r1, r1, #0
    RSC     r0, r0, #0
99
    RestPSR r9,,f
    Pull   "r7, r8, r9, pc"

; extended precision division: take 64 bit number in r0(high), r1(low),
; and return that divided by the 32 bit number in r2

extended_divide ROUT
    Push   "r0-r7, lr"
    MOV     r1, r2
    LDMFD   stack, {r2, r3}
    CMP     r2, #0
    BPL     %FT10
    RSBS    r3, r3, #0
    RSC     r2, r2, #0
    B       %FT10

; routine used from pagebox_nextbox:
; return r0*2^16/r1

divide_and_scale
    EntryS  "r0-r7"

    CMP     r0, #0
    RSBMI   r0, r0, #0

    MOV     r2, r0, LSR #16      ; high word of r0*2^16
    MOV     r3, r0, LSL #16      ; r2, r3 form 64 bit numerator (ra)

10                               ; alternate entry
    ADDS    r3, r3, r1, LSR #1   ; rounded division
    ADC     r2, r2, #0
    MOVS    r4, r1               ; rtemp = rb
  [ debugPrivate
    BNE     %FT80
    Debug   Private,"*** Extended divide by zero"
80
  ]
    MOV     r5, #0               ; r5, r4 are 64 bit rtemp

    MOVS    r6, r2, LSR #1       ; form ra>>1
    MOV     lr, r3, RRX

01  CMP     r5, r6               ; CMP rtemp, ra, LSR #1
    CMPEQ   r4, lr
    BHI     %FT02
    ADDS    r4, r4, r4
    ADC     r5, r5, r5           ; rtemp := rtemp LSL #1
    B       %BT01

02  MOV     r0, #0               ; the answer so far
03  SUBS    r7, r3, r4
    SBCS    r7, r2, r5
    ADC     r0, r0, r0
    BCC     %FT04
    SUBS    r3, r3, r4           ; SUB ra, ra, rtemp
    SBC     r2, r2, r5
04  MOVS    r5, r5, LSR #1
    MOV     r4, r4, RRX          ; rtemp := rtemp>>1
    SUBS    r7, r4, r1
    SBCS    r7, r5, #0           ; CMP rtemp, rb
    BCS     %BT03
    LDR     r1, [sp, #Proc_RegOffset + 0 * 4]
    CMP     r1, #0
    RSBMI   r0, r0, #0
    STRMI   r0, [sp, #Proc_RegOffset + 0 * 4]

    EXITS

; +++++++++++++++++++++++++++++++++++++++++
; Apply flips indicated by job_rotation_id
; +++++++++++++++++++++++++++++++++++++++++

flip_buffer ROUT
     Entry  "r0-r3"


     LDRB   lr, job_buffer_marked
     CMP    lr, #0

   [ debugPrivate
     BNE    %FT80
     Debug  ,"Skip flips - no point"
80
80
   ]
     EXIT   EQ

     BL     restore_output_state
     LDR    r2, job_currentbuffer
     LDRB   r3, job_rotation_id
     TST    r3, #2

   [ debugPrivate
     BEQ    %FT80
     Debug  ,"invert X coordinates"
80
   ]
     MOVNE  r0, #SpriteReason_FlipAboutYAxis  ; invert X coordinates
     BLNE   myspriteop
     BVS    %FT99
     TST    r3, #4
   [ debugPrivate
     BEQ    %FT81
     Debug  ,"invert Y coordinates"
81
   ]
     MOVNE  r0, #SpriteReason_FlipAboutXAxis  ; invert Y coordinates
     BLNE   myspriteop
     BLVC   redirect_output
99   STRVS  r0, [stack, #Proc_RegOffset]
     EXIT

; *****************************************************************************
;
;       SquareRoot - Calculate the square root of a 32-bit number
;         Adapted for use on radius calculations: given a 32-bit number,
;         return the square root of input*2^16
;           (i.e. answer scaled up by 8 places, i.e. scaled for Draw coord)
; in:   R7 = number to squareroot
; out:  R8 = result
;

SquareRoot ROUT
        EntryS  "r7, r9-r11"
        MOV     R11, #24                ; 24 bit result
        MOV     R8, #0                  ; result=0
        MOV     R10, #0                 ; sqdiff=0
10
        MOVS    R10, R10, LSL #2        ; C:=0 (we hope!) while doing (sqdiff,
        ORR     R10, R10, R7, LSR #30   ;   number) := (sqdiff, number) * 4
        MOV     R7, R7, LSL #2

        SBCS    R9, R10, R8, LSL #2     ; C=0 here, so try to subtract
                                        ; result*4 +1 from sqdiff
        MOVCS   R10, R9                 ; if successful then shift in a "1" bit
        ADC     R8, R8, R8              ; else shift in a "0" bit
        SUBS    R11, R11, #1            ; decrement loop counter
        BNE     %BT10
        EXITS

; *****************************************************************************
;
;  BigSquareRoot - Calculate the square root of a 64-bit number
; in:   R0,1 = number to squareroot
; out:    R0 = result
;

BigSquareRoot ROUT
        EntryS  "r5, r8-r12"

        Debuga  Private,"Square root of",R0
        Debuga  Private,"",R1

        MOV     r12, #32                ; 32 bit result
        MOV     r5, #0                  ; result=0
   ; r10,r11 form a 64-bit "sqdiff"
        MOV     r10, #0                 ; sqdiff(hi)=0
        MOV     r11, #0                 ; sqdiff(lo)=0
  ; r8, r9 form a temp 64 bit number
10
        MOVS    r10, r10, LSL #2        ; C:=0 (we hope!) while doing (sqdiff,
        ORR     r10, r10, r11, LSR #30   ;   number) := (sqdiff, number) * 4
        MOV     r11, r11, LSL #2
        ORR     r11, r11, r0, LSR #30
        MOV     r0, r0, LSL #2
        ORR     r0, r0, r1, LSR #30
        MOV     r1, r1, LSL #2

        SBCS    r9, r11, r5, LSL #2     ; C=0 here, so try to subtract
        SBCS    r8, r10, #0             ; result*4 +1 from sqdiff
        MOVCS   r10, r8                 ; if successful then shift in a "1" bit
        MOVCS   r11, r9
        ADC     r5, r5, r5              ; else shift in a "0" bit
        SUBS    r12, r12, #1            ; decrement loop counter
        BNE     %BT10

        MOV     r0, r5

        Debug   Private," yields",R0

        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; copy from one sprite (area) to another with 90 degree (anticlockwise)
; rotation.
; In:  r0 -> source sprite area
;      r1 -> dest sprite area
; and we know both sprites have the same shape, both are 256 colours
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

copysprite_withrotate ROUT
        EntryS  "r0-r7"

        LDRB    lr, job_buffer_marked
        CMP     lr, #0
        BNE     %FT20

        Debug   Private,"Skip rotation - no point"

; simply clearing the destination sprite will do

        LDR     r2, job_currentbuffer
        STR     r1, job_currentbuffer
        BL      redirect_output
        [ Libra1
        BL      set_sprite_background
        ]
        ADRL    r0, set_sprite_output_state
        BL      vdu_counted_string
        BL      restore_output_state
        STR     r2, job_currentbuffer
        EXIT

20      MOV     r2, r0
        BL      get_sprite_address
        MOV     r0, r2
        MOV     r2, r1
        BL      get_sprite_address
        MOV     r1, r2

      [ debugPrivate
        Debug   ,"copysprite_withrotate from",R0
        Debug   ,"to",R1
        LDR     R2,[R0,#spLBit]
        LDR     R3,[R1,#spLBit]
        ORRS    R2,R2,R3
        BEQ     %FT80
        Debug   ,"** flip with wastage!!!"
80
      ]



        [  Libra1
        LDRB    R7, job_strip_type
        CMP     R7, #4
        BEQ     Handle_16bpp_rotation
        CMP     R7, #5
        BEQ     Handle_32bpp_rotation
        BNE     Handle_8bpp_rotation
        ]

        [ Libra1
Handle_16bpp_rotation

  Debug Privatemjs,"16 bpp rotation case (Landscape)"
        LDR     R4, [r1, #spHeight]
        ADD     r4, r4, #1
  Debug Privatemjs,"destination sp height = ",R4
        MOV     R6, R4

        LDR     R5, [r1, #spWidth]
        ADD     R5, R5, #1
  Debug Privatemjs,"destination sp width = ",R5
        MOV     R5, R5, LSL #1

      ; now set initial pixel pointers
        LDR     r7, [r0, #spImage]
        ADD     r0, r0, r7

      ; destination copy starts at the first pixel on the last row
        LDR     r7, [r1, #spImage]
        ADD     r1, r1, r7          ; point at first byte after sprite

        MOV     R7, R5
        MOV     R3, R4, LSL #1      ; significant bytes in row

        ADD     R0, R0, R3          ; r0 -> last pixel in row, + 1 pixel

        TST     R3, #2              ; r3 is step to next row, ...
        ADDNE   R3, R3, #2          ; ... remembering padding to word alignment
  Debug Privatemjs, "row step (R3) = ",R3

        MOV     R2, R0


Start_loop16
        SUB     R2, R2, #2
        MOV     R0, R2
main_loopy16
        LDRB    R8, [R0]
        STRB    R8, [R1], #1

        LDRB    R8, [r0, #1]
        STRB    R8, [R1], #1

        ADD     R0, R0, R3

        SUBS    R5, R5, #1
        BGT     main_loopy16
        MOV     R5, R7
        SUBS    R4, R4, #1
        BGT     Start_loop16


        EXITS
        ]
        [ Libra1
Handle_32bpp_rotation
        Push    "R8-R11"
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
;  Debug PageBoxMem,"32bpp rotate: source width height = ",R2,R3
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5,LSL #2
        SUB     R1,R1,R3,LSL #2     ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
;  Debug PageBoxMem,"32bpp rotate:R0 R1 start = ",R0,R1
01
        MOV     R6,R2               ;source column counter
02
        LDR     R8,[R0],R2,LSL #2   ;load next 4 pixels...
        LDR     R9,[R0],R2,LSL #2
        LDR     R10,[R0],R2,LSL #2
        LDR     R11,[R0],R2,LSL #2  ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        SUB     R1,R1,R3,LSL #2     ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5,LSL #2
        ADD     R1,R1,#16           ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
;  Debug PageBoxMem,"32bpp rotate:R0 R1 next = ",R0,R1
        BNE     %BT01
        Pull    "R8-R11"
        EXITS
        ]

        [ Libra1
Handle_8bpp_rotation
        ]
      ; get the number of pixels we will copy in the inner loop
      ; we copy right then down  in the source sprite,
      ;       upwards then right in the destination

        LDR     r2, [r1, #spHeight]
        ADD     r2, r2, #1         ; number of pixels we will copy (= n)

      ; step up in destination = -linelength
        LDR     r4, [r1, #spWidth]
        ADD     r4, r4, #1
        MOV     r4, r4, LSL #2
        RSB     r4, r4, #0        ; -linelength (in bytes)

      ; step right in destination = 1 - (-linelength*n)
        MUL     r5, r4, r2
        RSB     r5, r5, #1        ; 1 - (-linelength*n)


      ; outer loop count = depth of source
        LDR     r6, [r0, #spHeight]

      ; step right in source = 1
      ; step down 1 and back n = linelength - n

        LDR     r3, [r0, #spWidth]
        ADD     r3, r3, #1         ; number of words

      ; now set initial pixel pointers
        LDR     r7, [r0, #spImage]
        ADD     r0, r0, r7

      ; destination copy starts at the first pixel on the last row
        LDR     r7, [r1, #spNext]
        ADD     r1, r1, r7          ; point at first byte after sprite

    [ MonoBufferOK
      [ NbppBufferOK
        LDRB    lr, job_output_bpp
        CMP     lr, #8
      |
        LDRB    lr, job_use_1bpp
        CMP     lr, #0
      ]
        BNE     cswr_1bpp
    ]

        RSB     r3, r2, r3, LSL #2 ; number of bytes to step

        Debug   Private,"Source pointer",R0
        Debug   Private,"Dest pointer",R1
        Debug   Private,"Inner loop count",R2
        Debug   Private,"Source outer step",R3
        Debug   Private,"Dest inner step",R4
        Debug   Private,"Dest outer step",R5
        Debug   Private,"Outer loop count",R6

01      SUBS    r7, r2, #4
03      LDRHS   lr, [r0], #4        ; do this loop while >= 4 bytes remain
        STRHSB  lr, [r1, r4]!       ; essentially, it's the lower loop
        MOVHS   lr, lr, LSR #8      ; unrolled to allow word fetches
        STRHSB  lr, [r1, r4]!
        MOVHS   lr, lr, LSR #8
        STRHSB  lr, [r1, r4]!
        MOVHS   lr, lr, LSR #8
        STRHSB  lr, [r1, r4]!
        SUBHSS  r7, r7, #4
        BHS     %BT03
        ADDS    r7, r7, #4
02      LDRGTB  lr, [r0], #1        ; beware exactly 4*n columns
        STRGTB  lr, [r1, r4]!
        SUBS    r7, r7, #1
        BGT     %BT02
        ADD     r1, r1, r5
        ADD     r0, r0, r3
        SUBS    r6, r6, #1
        BPL     %BT01              ; counter is rows-1

        EXITS

    [ MonoBufferOK
cswr_1bpp
        Push   "r1, r8-r12"
        [ Libra1        ; getting rid of this stops noise at top of page.
       ; ADD     r6, r6, #1         ; was height-1 before
        |
        ADD     r6, r6, #1      ; was height-1 before
        ]

;  got:
;    source byte pointer        : r0
;    source row length          : r3 << 2
;    dest byte pointer          : r1
;    dest row length            : -r4
;    width, height in dots      ; r2, r6

        Debug   Private,"mono: source byte pointer",R0
        Debug   Private,"dest byte pointer",R1
        Debug   Private,"width",R2
        Debug   Private,"source words per row",R3
        Debug   Private,"dest row len",R4
        Debug   Private,"height",R6
;
;use:
;    loop count : r7
;    rs1, rs2   : r8, r9
;    rd1, rd2   : r10,r11
;    bit        : r12

13      SUBS    r6, r6, #8       ; see if full height cube can be picked out
        BLT     %FT10

        MOV     r7, r2
12      LDRB    r8, [r0], r3, LSL #2     ; build a source cube
        LDRB    lr, [r0], r3, LSL #2
        ORR     r8, r8, lr, LSL #8
        LDRB    lr, [r0], r3, LSL #2
        ORR     r8, r8, lr, LSL #16
        LDRB    lr, [r0], r3, LSL #2
        ORR     r8, r8, lr, LSL #24      ; rs1 complete
        LDRB    r9, [r0], r3, LSL #2
        LDRB    lr, [r0], r3, LSL #2
        ORR     r9, r9, lr, LSL #8
        LDRB    lr, [r0], r3, LSL #2
        ORR     r9, r9, lr, LSL #16
        LDRB    lr, [r0], r3, LSL #2
        ORR     r9, r9, lr, LSL #24      ; rs2 complete
        BL      spin8x8_in_words         ; get rd1,rd2 (corrupts flags)

        SUBS    r7, r7, #8               ; decrement the counter
        BLGE    save_with_gay_abandon
        BLLT    save_carefully

    ; step the pixel pointers
        SUB     r0, r0, r3, LSL #2+3     ; step back to start point
        ADD     r0, r0, #1               ; and on one byte
        BGT     %BT12                    ; loop while more
        ADD     r0, r0, #3               ; step to word boundary
        BIC     r0, r0, #3               ; now at next row start
        ADD     r0, r0, r3, LSL #2+3     ; step on 8 rows
        SUB     r0, r0, r3, LSL #2       ; and back one
        LDR     r1, [stack]
        ADD     r1, r1, #1
        STR     r1, [stack]

        Debug   Private,"Source ptr",R0
        Debug   Private,"Dest ptr",R1

        B       %BT13                    ; step to next row

10  ; there are less than 8 rows left in the source: pick up carefully
        MOV     r7, r2
        ADD     r6, r6, #8
11      LDRB    r8, [r0], r3, LSL #2     ; build a source cube
        SUBS    r12, r6, #1              ; count the rows
        LDRGTB  lr, [r0], r3, LSL #2
        ORRGT   r8, r8, lr, LSL #8
        SUBS    r12, r12, #1
        LDRGTB  lr, [r0], r3, LSL #2
        ORRGT   r8, r8, lr, LSL #16
        SUBS    r12, r12, #1
        LDRGTB  lr, [r0], r3, LSL #2
        ORRGT   r8, r8, lr, LSL #24      ; rs1 complete
        SUBS    r12, r12, #1
        LDRGTB  r9, [r0], r3, LSL #2
        MOVLE   r9, #0
        SUBS    r12, r12, #1
        LDRGTB  lr, [r0], r3, LSL #2
        ORRGT   r9, r9, lr, LSL #8
        SUBS    r12, r12, #1
        LDRGTB  lr, [r0], r3, LSL #2
        ORRGT   r9, r9, lr, LSL #16
        BL      spin8x8_in_words         ; get rd1,rd2 (corrupts flags)

        SUBS    r7, r7, #8               ; decrement the counter
        BLGE    save_with_gay_abandon
        BLLT    save_carefully

    ; step the pixel pointers

        MUL     r12, r3, r6
        SUB     r0, r0, r12, LSL #2      ; step back to start point
        ADD     r0, r0, #1               ; and on one byte
        BGT     %BT11                    ; loop while more

    ; finished!
        Pull   "r1, r8-r12"
        EXITS

save_with_gay_abandon ROUT               ; Must preserve flags
        MOV     r11, r11, ROR #24
        STRB    r11, [r1, r4]!
        MOV     r11, r11, ROR #24
        STRB    r11, [r1, r4]!
        MOV     r11, r11, ROR #24
        STRB    r11, [r1, r4]!
        MOV     r11, r11, ROR #24
        STRB    r11, [r1, r4]!
        MOV     r10, r10, ROR #24
        STRB    r10, [r1, r4]!
        MOV     r10, r10, ROR #24
        STRB    r10, [r1, r4]!
        MOV     r10, r10, ROR #24
        STRB    r10, [r1, r4]!
        MOV     r10, r10, ROR #24
        STRB    r10, [r1, r4]!
        MOV     pc, lr

; saving may drop off the start of the destination: do it carefully

save_carefully ROUT
        EntryS
        MOV     r11, r11, ROR #24
        STRB    r11, [r1, r4]!           ; at least one to do
        ADDS    r7, r7, #7               ; count of bytes left to do
        MOV     r11, r11, ROR #24
        STRGTB  r11, [r1, r4]!
        SUBS    r7, r7, #1
        MOV     r11, r11, ROR #24
        STRGTB  r11, [r1, r4]!
        SUBS    r7, r7, #1
        MOV     r11, r11, ROR #24
        STRGTB  r11, [r1, r4]!
        SUBS    r7, r7, #1
        MOV     r10, r10, ROR #24
        STRGTB  r10, [r1, r4]!
        SUBS    r7, r7, #1
        MOV     r10, r10, ROR #24
        STRGTB  r10, [r1, r4]!
        SUBS    r7, r7, #1
        MOV     r10, r10, ROR #24
        STRGTB  r10, [r1, r4]!
        SUBS    r7, r7, #1
        MOV     r10, r10, ROR #24
        STRGTB  r10, [r1, r4]!
        EXITS

; take 8x8 source pixels in rs1, rs2 and build rd1, rd2

spin8x8_in_words ROUT

        Debuga  Private,"Source ptr",R0
        Debuga  Private,", pixels",R8
        Debug   Private,",",R9

        MOV     r12, #1:SHL:24     ; start in LSB of byte 8 in dest
        MOV     r10, #0
        MOV     r11, #0
01      MOVS    r8, r8, LSR #1   ; next bit -> C
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSR #8
        MOVS    r8, r8, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSR #8
        MOVS    r8, r8, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSR #8
        MOVS    r8, r8, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSL #24  ; step to next word

        MOVS    r8, r8, LSR #1
        ORRCS   r10, r10, r12
        MOV     r12, r12, LSR #8
        MOVS    r8, r8, LSR #1
        ORRCS   r10, r10, r12
        MOV     r12, r12, LSR #8
        MOVS    r8, r8, LSR #1
        ORRCS   r10, r10, r12
        MOV     r12, r12, LSR #8
        MOVS    r8, r8, LSR #1
        ORRCS   r10, r10, r12
        MOVS    r12, r12, LSL #29
        MOVCC   r12, r12, LSR #4   ; step to next source byte
        BCC     %BT01              ; still on first source word

        MOV     r12, #1:SHL:28     ; start in r12 4 of byte 8 in dest
02      MOVS    r9, r9, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSR #8
        MOVS    r9, r9, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSR #8
        MOVS    r9, r9, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSR #8
        MOVS    r9, r9, LSR #1
        ORRCS   r11, r11, r12
        MOV     r12, r12, LSL #24  ; step to next word

        MOVS    r9, r9, LSR #1
        ORRCS   r10, r10, r12
        MOV     r12, r12, LSR #8
        MOVS    r9, r9, LSR #1
        ORRCS   r10, r10, r12
        MOV     r12, r12, LSR #8
        MOVS    r9, r9, LSR #1
        ORRCS   r10, r10, r12
        MOV     r12, r12, LSR #8
        MOVS    r9, r9, LSR #1
        ORRCS   r10, r10, r12
        MOVS    r12, r12, LSL #25
        BCC     %BT02              ; still on second source word

        Debug   Private,"Result pixels",R11
        Debug   Private,",",R12

        MOV     pc, lr             ; no need to preserve flags
    ]

;
;fast copysprite_withrotate, 32 bpp case, 90 degrees
;
copysprite_withrotate_32bpp90 ROUT
        EntryS  "R0-R11"
  Debug PageBoxMem,"copysprite_withrotate_32bpp90"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5,LSL #2
        SUB     R1,R1,R3,LSL #2     ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDR     R8,[R0],R2,LSL #2   ;load next 4 pixels...
        LDR     R9,[R0],R2,LSL #2
        LDR     R10,[R0],R2,LSL #2
        LDR     R11,[R0],R2,LSL #2  ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        SUB     R1,R1,R3,LSL #2     ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5,LSL #2
        ADD     R1,R1,#16           ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        EXITS

;
;fast copysprite_withrotate, 32 bpp case, 270 degrees (implicit flips)
;
copysprite_withrotate_32bpp270 ROUT
        EntryS  "R0-R11"
  Debug PageBoxMem,"copysprite_withrotate_32bpp270"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1            ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R3,LSL #2
        SUB     R1,R1,#16           ;R1 -> last 4-pixels of 1st row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDR     R11,[R0],R2,LSL #2  ;load next 4 pixels...
        LDR     R10,[R0],R2,LSL #2
        LDR     R9,[R0],R2,LSL #2
        LDR     R8,[R0],R2,LSL #2   ;...columnwise from source
        STMIA   R1,{R8-R11}         ;store them rowwise in dest.
        SUB     R0,R0,R2,LSL #4     ;reset R0
        ADD     R0,R0,#4            ;move to next source column
        ADD     R1,R1,R3,LSL #2     ;move to next dest row down
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R2,LSL #3
        ADD     R0,R0,R2,LSL #2     ;move R0 to next set of 4 source rows
        SUB     R1,R1,R5,LSL #2
        SUB     R1,R1,#16           ;move R1 to next set of 4 pixels, top row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        EXITS


;
;fast copysprite_withrotate, 8 bpp case, 90 degrees
;
copysprite_withrotate_8bpp90 ROUT
        EntryS  "R0-R12"
  Debug PageBoxMem,"copysprite_withrotate_8bpp90"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1
        MOV     R3,R3,LSL #2        ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        ADD     R12,R2,#3
        BIC     R12,R12,#3          ;R12:=source width, word aligned
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R5
        SUB     R1,R1,R3            ;R1 -> 1st dest pixel of last row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDRB    R8,[R0],R12         ;load next 4 pixels...
        LDRB    R9,[R0],R12
        LDRB    R10,[R0],R12
        LDRB    R11,[R0],R12        ;...columnwise from source
        ORR     R8,R8,R9,LSL #8
        ORR     R8,R8,R10,LSL #16
        ORR     R8,R8,R11,LSL #24
        STR     R8,[R1]             ;store them rowwise in dest.
        SUB     R0,R0,R12,LSL #2    ;reset R0
        ADD     R0,R0,#1            ;move to next source column
        SUB     R1,R1,R3            ;move to next dest row up
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R12,LSL #1
        ADD     R0,R0,R12           ;move R0 to next set of 4 source rows
        ADD     R1,R1,R5
        ADD     R1,R1,#4            ;move R1 to next set of 4 pixels, bottom row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        EXITS


;
;fast copysprite_withrotate, 8 bpp case, 270 degrees (implicit flips)
;
copysprite_withrotate_8bpp270 ROUT
        EntryS  "R0-R12"
  Debug PageBoxMem,"copysprite_withrotate_8bpp270"
        MOV     R2,R0
        BL      get_sprite_address
        MOV     R0,R2
        MOV     R2,R1
        BL      get_sprite_address
        MOV     R1,R2
        LDR     R2, [R1, #spHeight]
        ADD     R2,R2,#1            ;dest height, or source width
        LDR     R3, [R1, #spWidth]
        ADD     R3,R3,#1
        MOV     R3,R3,LSL #2        ;dest width, or source height
        LDR     R4, [R0, #spImage]
        ADD     R0,R0,R4            ;R0 -> 1st source pixel
        LDR     R4, [R1, #spImage]
        ADD     R1,R1,R4            ;R1 -> 1st dest pixel
        ADD     R12,R2,#3
        BIC     R12,R12,#3          ;R12:=source width, word aligned
        MUL     R5,R2,R3            ;R5 = (dest height).(dest width)
        ADD     R1,R1,R3
        SUB     R1,R1,#4            ;R1 -> last 4-pixels of 1st row
        MOV     R7,R3               ;source row counter
01
        MOV     R6,R2               ;source column counter
02
        LDRB    R11,[R0],R12        ;load next 4 pixels...
        LDRB    R10,[R0],R12
        LDRB    R9,[R0],R12
        LDRB    R8,[R0],R12         ;...columnwise from source
        ORR     R8,R8,R9,LSL #8
        ORR     R8,R8,R10,LSL #16
        ORR     R8,R8,R11,LSL #24
        STR     R8,[R1]             ;store them rowwise in dest.
        SUB     R0,R0,R12,LSL #2    ;reset R0
        ADD     R0,R0,#1            ;move to next source column
        ADD     R1,R1,R3            ;move to next dest row down
        SUBS    R6,R6,#1
        BNE     %BT02               ;till columns done
        ADD     R0,R0,R12,LSL #1
        ADD     R0,R0,R12           ;move R0 to next set of 4 source rows
        SUB     R1,R1,R5
        SUB     R1,R1,#4            ;move R1 to next set of 4 pixels, top row
        SUBS    R7,R7,#4            ;4 more source rows done
        BNE     %BT01
        EXITS


; ******************************************************************


        END
