; > Sources.PDriverPS.Font

; Font handling routines for the PostScript printer driver

; The PostScript printer driver does not use slaved font manager fonts.

; *************************************************************************
; Printer specific code for SWI PDriver_DeclareFont.
; *************************************************************************

defaultfont
        DCB     "Courier",0
NullString
        DCB     "XXXX",0

        [ BeingDeveloped
forcekerns_name
        DCB     "PDriver$PSForceKerning"
        ]

; XXXX Currently duplicate entries are just added in.  This could conveivably
; cause a problem with apps which (incorrectly) declare the same font twice,
; once without kerning and once with.  We should probably check if this is
; a duplicate entry.  If so, don't re-enter it but instead upgrade the flags
; word of the existing entry to 'needs kerning'.

font_declare ROUT
;       R1 is a pointer to the font name
;       R2 is the flags word
        Push    lr
        PrError font_declare_return

        DebugS  Font,"Declare font ",r1
        Debug   Font," with flags ",r2

        [ BeingDeveloped
; If user sets magic variable PDriver$PSForceKerning, then switch on kerning
        Push    "R0-R4"
        ADR     R0,forcekerns_name
        MOV     R2,#-1
        MOV     R3,#0
        SWI     XOS_ReadVarVal
        TEQ     R2,#0
        Pull    "R0-R4"
        ORRNE   r2, r2, #2      ; FORCE KERNING ON!!!
        ]

        TEQ     r1, #0                  ; Is this the last call?
        BNE     font_declare_addfont    ; No, so go and do it
        LDR     r0, declaredfonts       ; Check the state of the list
        CMP     r0, #-1                 ; Is there "no list"?
        STREQ   r1, declaredfonts       ; Yes, so make an empty list
        [       PSDebugFont
        PrLnIm  "% End of declared fonts"
        ]
        B       font_declare_returnOK

font_declare_addfont
        MOV     r4, r2                  ; Save the flags word
        MOV     r3, #0                  ; Count the chars in the name
font_declare_countloop
        LDRB    r14, [ r1, r3 ]
        INC     r3
        CMP     r14, #" "               ; Is this the terminator?
        BGT     font_declare_countloop  ; No, so count some more
        INC     r3, 8                   ; Allow for the link and flags words
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        BVS     font_declare_return
        [       PSDebugFont
        PrStrIm "% Declare font '"
        ]
        STR     r4, [ r2, #4 ]
        MOV     r3, #8
font_declare_copyloop
        LDRB    r0, [ r1 ], #1
        CMP     r0, #" "
        MOVLE   r0, #0
        STRB    r0, [ r2, r3 ]
        [       PSDebugFont
        BLGT    output_character
        CMP     r0, #0
        ]
        INC     r3
        BGT     font_declare_copyloop
        [       PSDebugFont
        PrLnIm  "'"
        ]
        LDR     r14, declaredfonts
        CMP     r14, #-1
        MOVEQ   r14, #0
        STR     r14, [ r2, #0 ]
        STR     r2, declaredfonts
font_declare_returnOK
        CLRV
font_declare_return
        Pull    pc
           

; Invalidate any references to font r0 in the font stack.  Does not
; actually pop anything from the stack, just sets the matching
; entries to -1.

        [ PSTextSpeedUps

invalidate_fontstack    ENTRY   "r0-r3"
        ADR     r1, currentfonts                ; bottom of font stack (full ascending)
        LDR     lr, currentfontptr              ; end of the font stack
        MOV     r3, #-1                         ; marks an invalid entry
00
        CMP     r1, lr                          ; past end of stack yet?
        EXIT    GT                              ; yes, so leave
        LDR     r2, [r1], #4                    ; get next handle from stack
        TEQ     r2, r0                          ; is it the one we're clearing?
        STREQ   r3, [r1, #-4]                   ; yes, so invalidate it
        B       %BT00
;NOTREACHED

        |

invalidate_fontstack    ENTRY   "r0"
        LDR     lr, currentPSfont
        TEQ     lr, r0
        MOVEQ   r0, #-1
        STREQ   r0, currentPSfont
        EXIT

        ]


; If losefont gets called, then erase the record for handle in r0 (all
; handles if r0 == 0).

font_losefont ROUT
        TEQ     r0, #0
        BEQ     font_fontslost
        Push    "r1-r2, lr"

        BL      invalidate_fontstack

        ADR     r2, fontmapping
        MOV     r1, #0
        STR     r1, [r2, r0, LSL #2]
        Pull    "r1-r2, pc"
        
font_fontslost  ROUT
        Push    "r0-r3, lr"

        ADR     r1, fontmapping
        MOV     r3, #0
        MOV     r2, #255
00
        LDR     r0, [r1, r2, LSL #2]
        BL      invalidate_fontstack

        STR     r3, [r1, r2, LSL #2]
        SUBS    r2, r2, #1
        BPL     %BT00
        Pull    "r0-r3, pc"

        [       PSCoordSpeedUps

        [       PSDebugFont

font_stringend                          ;Leave text co-ordinates active
        Push    "LR"                    ;  in case of another string
        PrLnIm  "% font_stringend",FallThroughOnError
        Pull    "PC"
        |
font_stringend                          ;Leave text co-ordinates active
                                        ;  in case of another string
        Return
        ]

        ]

; The string initialisation routine

font_stringstart
        [       PSCoordSpeedUps

        Push    "LR"
        PrError font_stringstart_return
        [       PSDebugFont
        PrLnIm  "% font_stringstart"
        ]

        MOV     R7,#&FF00                       ;Can deal with strings up to
        LDR     R8,fontpaint_initflags          ;  PostScript implementation
        ASSERT  fontpaintflag_rubout = 2        ;  limit. We want two passes
        ANDS    R8,R8,#fontpaintflag_rubout     ;  if rubout is required,
        MOVEQ   R8,#1                           ;  one otherwise.
        BL      ensure_textcoords               ;Use correct co-ordinates

        PrError
font_stringstart_return
        Pull    "PC"

        |

        Push    "R1,R2,LR"
        PrError font_stringstart_return
        [       PSDebugFont
        PrLnIm  "% font_stringstart"
        ]

        MOV     R7,#&FF00                       ;Can deal with strings up to
        LDR     R8,fontpaint_flags              ;  PostScript implementation
        ASSERT  fontpaintflag_rubout = 2        ;  limit. We want two passes
        ANDS    R8,R8,#fontpaintflag_rubout     ;  if rubout is required,
        MOVEQ   R8,#1                           ;  one otherwise.

        SWI     XFont_ReadScaleFactor           ;Change to millipoint-based
        BLVC    output_gsave                    ;  co-ordinates, using font
        PrPassError                             ;  manager's conversion
        PrPair  R1,R2                           ;  factors.
        PrLnIm  "TS",FallThroughOnError

        PrError
font_stringstart_return
        Pull    "R1,R2,PC"

        ]

; The string finalisation routine

        [       :LNOT:PSCoordSpeedUps

font_stringend
        [       PSDebugFont
        Push    "LR"
        PrLnIm  "% font_stringend",FallThroughOnError
        Pull    "LR"
        MOVVS   PC,LR
        ]
        B       output_grestore                 ;Revert to original
                                                ;  co-ordinate system.
        ]

; The pass initialisation routine

font_passstart
        Push    "R1-R2,LR"
        PrError font_passstart_return
        [       PSDebugFont
        PrLnIm  "% font_passstart"
        ]

        [       :LNOT:PSTextSpeedUps
        TEQ     R8,#1                           ;Which pass?
        MOVEQ   LR,#-1                          ;On main pass, PostScript's
        STREQ   LR,currentPSfont                ;  current font is unknown.
        ]
        BL      font_restorecolours             ;Revert to start of string
        TEQ     R8,#1                           ;  font colours, then return
        Pull    "R1-R2,PC",EQ                   ;  if this is the main pass
        BL      font_getbgrgb                   ;Determine background rgb
        LDRVC   R2,fontpaint_ruboutbox          ;And left side of the box we
        ADRVCL  LR,pendingrubout_rgb            ;  can rub out so far
        STMVCIA LR,{R1,R2}
        ASSERT  pendingrubout_left = pendingrubout_rgb+4

        PrError
font_passstart_return
        Pull    "R1-R2,PC"

; The pass finalisation routine

font_passend
        TEQ     R8,#2                           ;Nothing to do except on
        Return  NE                              ;  rubout pass
        Push    "R1,R2,R4,LR"
        PrError font_passend_return
        [       PSDebugFont
        PrLnIm  "% font_passend"
        ]

        ADRL    LR,pendingrubout_rgb            ;Do pending rubout
        LDMIA   LR,{R1,R2}
        ASSERT  pendingrubout_left = pendingrubout_rgb+4
        LDR     R4,fontpaint_ruboutbox+8        ;Up to right edge of rubout
        BL      font_dorubout                   ;  box

        PrError
font_passend_return
        Pull    "R1,R2,R4,PC"

; Routines to get the correct RGB value for the foreground and background
; font colours. Both exit with R1 = &BBGGRR00.

font_getfgrgb
        LDR     R1,absfontcols                  ;Absolute RGB or GCOL?
        TST     R1,#2
        LDREQ   R1,fgfontrgb                    ;Load RGB if the former
        Return  EQ                              ;  and return, clearing V
        Push    "LR"
        ADR     R1,fgfontgcol                   ;If the latter, add first
        LDMIA   R1,{R1,LR}                      ;  foreground GCOL and
        ASSERT  fgfontoff = fgfontgcol+4        ;  foreground offset to get
        ADD     R1,R1,LR                        ;  full foreground GCOL,
        MOV     R1,R1,LSL #8                    ;  then look up the result
        BL      gcol_lookup                     ;  as an RGB combination
        Pull    "PC"

font_getbgrgb
        LDR     R1,absfontcols                  ;Absolute RGB or GCOL?
        TST     R1,#1
        LDREQ   R1,bgfontrgb                    ;Load RGB if the former
        Return  EQ                              ;  and return, clearing V
        LDR     R1,bgfontgcol                   ;Otherwise, get background
        MOV     R1,R1,LSL #8                    ;  GCOL, then look up the
        B       gcol_lookup                     ;  result as an RGB value

; Subroutine to print a chunk of rubout box.
; Entry: R1 = &BBGGRR00
;        R2 = left X
;        R4 = right X
; Exit:  All registers preserved.

font_dorubout
        Push    "R2,R4,R5-R8,LR"
        PrError font_dorubout_return

        ADR     LR,fontpaint_ruboutbox          ;Get rubout box co-ordinates
        LDMIA   LR,{R5-R8}

        CMP     R2,R5                           ;Clip left and right edges
        MOVLT   R2,R5                           ;  of chunk to print
        CMP     R4,R5
        MOVLT   R4,R5
        CMP     R2,R7
        MOVGT   R2,R7
        CMP     R4,R7
        MOVGT   R4,R7

        CMP     R4,R2                           ;Check result positive in
        CMPGT   R8,R6                           ;  both dimensions
        BLE     font_dorubout_noerrorreturn

        BL      colour_setrealrgb
        [       PSCoordSpeedUps
        BL      colour_ensure
        ]
        PrPassError

        PrPair  R2,R6
        PrPair  R4,R8
        PrLnIm  "Bx fill"

font_dorubout_noerrorreturn
        CLRV

        PrError
font_dorubout_return
        Pull    "R2,R4,R5-R8,PC"

; Locate the start of a \letter escape sequence in a control-terminated string.
; Entry: r0 = start of the string.  r3 = letter to look for.
; Exit: SUCCESS: V CLEAR and r0 = address of first character after the backslash
;       FAILURE: V SET, r0 points past terminating null.

font_locateescape    ENTRY   "r2"
00      LDRB    r2, [r0], #1    ; get the next byte

01      CMP     r2, #32         ; control?
        BLT     %FT99           ; yes, so fail

        TEQ     r2, #'\'        ; backslash?
        BNE     %BT00           ; no, so continue

        LDRB    r2, [r0], #1    ; get char after backslash

        TEQ     r2, r3          ; is it the letter we wanted?
        BNE     %BT01           ; no, so continue after checking for end of string

        CLRV                    ; r0 now points to start of substring
        EXIT
99
        SETV                    ; failure so set V
        EXIT                    ; and exit


; Locate the NAME portion of font name addressed by R0.
; Exit: SUCCESS: V CLEAR and r0 = address of start of name text
;       FAILURE: V SET and r0 undefined.

font_locatename         ENTRY   "r1,r3"
        MOV     r1, r0          ; keep start of string handy
        MOV     r3, #'F'        ; NAME escape
        BL      font_locateescape
        EXIT    VC              ; found OK

        MOV     r0, r1          ; not found.  get the string ptr back
        LDRB    r1, [r0]        ; check first char
        TEQ     r0, #'\'        ; if it is not a backslash
        BEQ     %FT99

        CLRV                    ; then assume the font NAME portion starts there
        EXIT                    ; and return success
99
        SETV                    ; string started with a \, so name not found
        EXIT

; Compare the two strings pointed to by R4 and R5.  Do a caseless match (in the
; ASCII sense of 'case'.)  The strings are terminated by either control OR backslash,
; and the terminator does not take part in the comparison
;
; Exit: if r4 == 0 and r5 == 0, SUCCESS: VCLR
;       if ONLY one of r4 and r5 is 0, FAILURE: VSET
;       if r4 and r5 point to identical strings, SUCCESS: VCLR
;       otherwise, FAILURE: VSET
;       On exit, r4 and r5 are as on entry.

font_compareR4andR5     ENTRY   "r0,r1,r4,r5"
        ORRS    lr, r4, r5      ; if both pointers are zero
        BEQ     %FT88           ; then instant match

        TEQ     r4, #0          ; if one zero
        TEQNE   r5, #0          ; but not the other
        BEQ     %FT99           ; then instant failure

00      LDRB    r0, [r4], #1    ; get a byte of the first string
        LowerCase r0, lr        ; ASCII lowercase
        TEQ     r0, #'\'        ; make \ equivalent to 0
        MOVEQ   r0, #0          ; character ends up in R0

        LDRB    r1, [r5], #1    ; as above for second string
        LowerCase r1, lr        ; character ends up in R1
        TEQ     r1, #'\'
        MOVEQ   r1, #0

        CMP     r0, #32         ; is first a terminator?
        CMPLT   r1, #32         ; is the second too?
        BLT     %FT88           ; if both, the strings matched

        TEQ     r0, r1          ; both the same?
        BEQ     %BT00           ; if so, try the next character
99
        SETV                    ; hit a difference
        EXIT                    ; failure
88
        CLRV                    ; match
        EXIT                    ; success



; Compare two font names pointed to by r1 and r2.  Return with V clear if they
; match on \F, \E and \M entries (fields which are equally absent in both
; fontnames are said to match.)  Ignore all the other fields for the purposes
; of this comparison.  Match is caseless.


font_comparenames       ENTRY   "r0-r5"

        ; First check the NAME portion of the strings:

        MOV     r0, r1          ; first string
        BL      font_locatename
        EXIT    VS              ; always fail if no name
        MOV     r4, r0          ; stash name ptr for first string

        MOV     r0, r2          ; second string
        BL      font_locatename
        EXIT    VS              ; always fail if no name
        MOV     r5, r0          ; stash name ptr for second string

        BL      font_compareR4andR5
        EXIT    VS              ; different, so fail

        ; Second, check the ENCODING portion of the strings:

        MOV     r3, #'E'

        MOV     r0, r1
        BL      font_locateescape
        MOVVC   r4, r0          ; found \E, keep address
        MOVVS   r4, #0          ; no \E, keep 0

        MOV     r0, r2
        BL      font_locateescape
        MOVVC   r5, r0          ; found \E, keep address
        MOVVS   r5, #0          ; no \E, keep 0

        BL      font_compareR4andR5
        EXIT    VS              ; different, so fail

        ; Third, check the MATRIX portion of the strings:
        
        MOV     r3, #'M'
        
        MOV     r0, r1
        BL      font_locateescape
        MOVVC   r4, r0          ; found \M, keep address
        MOVVS   r4, #0          ; no \M, keep 0

        MOV     r0, r2
        BL      font_locateescape
        MOVVC   r5, r0          ; found \M, keep address
        MOVVS   r5, #0          ; no \M, keep 0

        BL      font_compareR4andR5

        EXIT                    ; if VCLR, all sections matched (or were equally absent); else failed

        LTORG

font_paintchunk
;       Printer specific code to handle the painting of a string
;       section at a specified area on the page.  The routine will
;       be passed a string in which all control sequences will have been
;       interpreted or faulted by the independent code, which will
;       therefore in general have broken the string supplied to Font_Paint
;       up into the number of strings to be passed to this routine with
;       various parameters.
;       Entry:  R1 -> Start of printable chunk (will only contain
;                     printable characters.
;               R3 Contains the X position to paint the sub-section at.
;               R4 Contains the Y position to paint the sub-section at.
;               R5 Contains the number of characters in the chunk, never
;                  greater than the maximum chunk size returned.
;               R8 Pass number over the string in the usual countdown format.
;               R10 contains the print job's file handle.
;               R11 contains the pointer to the print jobs workspace.
;                 'fontpaint_flags' contains the flags that indicate if
;                    justification, rubout, kerning and reversed text to be plotted.
;                 'fontpaint_rubout' contains the rubout region to be applied
;                    below the text.
;                 'fontpaint_font' handle of the font to be used for painting the text.
;                 'fontpaint_ulpos' and 'fontpaint_ulthick' contain the current
;                    underline position and thickness.
;                 'fontpaint_matrix' contains the CTM to use to plot the text.
;                 'fontpaint_spaceaddX,Y/charaddX,Y' contain the information required
;                    to justify the text correctly.
;                 'fontpaint_paintendxy' end coordinates of the paint end sequence,
;                    also used to update the painting position.
;               All co-ordinates are in millipoints, and are relative to the
;                  bottom left corner of the user's box.
;
;       Exit:   All registers preserved (except R0 on an error).

        Push    "R0-R9,LR"
        PrError font_paintchunk_return
        [       PSDebugFont
        PrLnIm  "% font_paintchunk"
        ]

        CMP     R8,#2                           ;A pass with R8=2 will only
        BNE     font_paintchunk_text            ;  happen if we're rubbing
                                                ;  out and will be the first
                                                ;  pass executed

        BL      font_getbgrgb                   ;Get new background colour
        MOV     R3,R1
        ADRL    R5,pendingrubout_rgb            ;Also the pending rubout
        LDMIA   R5,{R1,R2}                      ;  background and left edge
        ASSERT  pendingrubout_left = pendingrubout_rgb+4
        CMP     R3,R1                           ;If colour hasn't changed, we
        BEQ     font_paintchunk_return          ;  leave the rubout pending
                                                ;  (NB V=0 in this case)
        LDR     r4, [ sp, #12 ]                 ;Otherwise get the place to
        BL      font_dorubout                   ;  rub out to and do it
        STMVCIA R5,{R3,R4}                      ;Store new pending position
        ASSERT  pendingrubout_left = pendingrubout_rgb+4
        B       font_paintchunk_return          ;And return

font_paintchunk_text
        [       PSTextSpeedUps

        LDR     R0,fontpaint_font               ;Are we out of step with the

        Debuga  Font, "Paint chunk: handle ", r0
        DebugS  Font, " String ", R1

        LDR     R7,currentfontptr               ;  PostScript font? If so, we
        LDR     LR,[R7]                         ;  want to update PostScript.
        CMP     R0,LR
        BEQ     font_paintchunk_fontunchanged   ;NB V is clear if we branch
        STR     R0,[R7]

        |

        LDR     R0,fontpaint_font               ;Are we out of step with the
        LDR     LR,currentPSfont                ;  PostScript font? If so, we
        CMP     R0,LR                           ;  want to update PostScript.
        BEQ     font_paintchunk_fontunchanged   ;NB V is clear if we branch
        STR     R0,currentPSfont

        ]

        Push    "R1,R4,R5,R6"
        PrError font_paintchunk_fontdone


; Read font definition; needed to get size even if the font is in fontmapping
        Push    "r0"                            ; save handle
        ADR     R1,expansionbuffer              ; Read font name and size.
        LDR     r3, =&4C4C5546                  ; "FULL"
        SWI     XFont_ReadDefn
        Pull    "r0"                            ; get handle back

; See if we know about this font handle already

        ADR     lr, fontmapping
        LDR     lr, [lr, r0, LSL #2]            ; r7 <- address of PostScript name string
        TEQ     lr, #0                          ; is it known?
        MOVNE   r1, lr                          ; so point r1 to it ready for...

        BEQ     %FT00
        Debuga  Font, "Font handle ", r0
        DebugS  Font, " Maps to ", r1
00
        BNE     font_paintchunk_outputfontname  ; yes, so just output it

; Font handle not known; we'll have to do a little more work.

        LDRB    r0, jobverbose                  ; if we're not using verbose prologue
        TEQ     r0, #0                          ; then go ahead and scan the list
        BEQ     font_paintchunk_scanlist

; Verbose prologue.  Skip past the \F (if present) and put a NUL over the next \ (if present).
; We are working in the expansionbuffer (still pointed to by r1).
; The font mapping scheme is NOT USED under verbose prologue!

        MOV     r0, r1                          ; r1 and r0 = start of string
        BL      font_locatename                 ; r0 = start of fontname part
        ADRVSL  r1, defaultfont                 ; if the font name couldn't be parsed
        BVS     font_paintchunk_outputfontname  ; then revert in desperation to the default

        MOV     r1, r0                          ; r1 = start of fontname part (so does r0)

00      LDRB    r14, [r0], #1                   ; get the next byte
        TEQ     r14, #0                         ; if it's not the terminator
        TEQNE   r14, #"\"                       ; and not a backslash
        BNE     %BT00                           ; then continue
        MOV     r14, #0                         ; but if it is, then put a zero over it
        STRB    r14, [r0, #-1]                  ; remembering that we're pointing beyond it!
        B       font_paintchunk_outputfontname  ; skipping the font mapping and declaration stuff

; Scan the fontlist for an exact match of the
; font name found in expansionbuffer.  Output the corresponding
; foreign font name.

font_paintchunk_scanlist

        Push    "R2,R3"
        ADRL    r5, enumeration_buf
        MOV     r6, #0                  ; first handle
        MOV     r4, #0                  ; flags
        B       %FT04

01      TEQ     r6, #0                  ; was handle returned last time zero?
        BEQ     %FT02                   ; if so, then stop looking

04      MOV     r0, #2                  ; enumerate fonts
        MOV     r1, r5                  ; address (clobbered by the call)
        MOV     r2, #12                 ; size (also clobbered)
        MOV     r3, r6                  ; next handle
        SWI     XPDriver_MiscOp
        BVS     %FT02                   ; if there was an error, or
        TEQ     r2, #0                  ; if the remaining size is nonzero
        BNE     %FT02                   ; then we didn't find it
        MOV     r6, r3                  ; preserve next handle

        LDR     r1, [r5, #8]            ; check flags word
        TEQ     r1, #PDriverMiscOp_PS_Font
        BNE     %BT01

        LDR     r1, [r5, #0]            ; local name
        ADR     r2, expansionbuffer

        BL      font_comparenames       ; sets V if no match
        BVS     %BT01                   ; failed, try next one

        ; Success - matched the name in R1.  Exit the loop and get alien name
        LDR     r1, [r5, #4]            ; alien name
        B       %FT03                   ; success - name is in r1

02      ADRL    r1, defaultfont         ; failure!
03

; Update the fontmapping with this information
        LDR     r0, fontpaint_font
        ADR     r3, fontmapping
        STR     r1, [r3, r0, LSL #2]
        Debuga  Font, "Mapping font handle ", r0
        DebugS  Font, " to ", r1

; Now add the font to the document fonts list.  This can safely be called
; multiple times.  The "local" (sic) name is in r1.  The SWI preserves registers.

        MOV     r0, #0                  ; AddFont
        ADRL    r2, NullString          ; no particular "foreign" name
        MOV     r3, #PDriverMiscOp_PS_DF        ; flags word
        MOV     r4, #0                  ; don't overwrite duplicates
        SWI     XPDriver_MiscOp         ; ignore errors
        CLRV

        Pull    "R2,R3"

font_paintchunk_outputfontname                  ; which should be referenced by r1
        PrPassError
        PrChrIm "/"                             ;Output font name
font_paintchunk_fontloop
        LDRB    R0,[R1],#1
        CMP     R0,#32
        BLO     font_paintchunk_endfontloop
        TEQ     R0,#"*"
        BEQ     font_paintchunk_fontloop
        PrChr   R0
        B       font_paintchunk_fontloop
font_paintchunk_endfontloop
        PrChrIm " "

        PrPair  R2,R3                           ;Output font size
        PrLnIm  "Fn",FallThroughOnError         ;Select font

        PrError font_paintchunk_return
font_paintchunk_fontdone
        Pull    "R1,R4,R5,R6"
font_paintchunk_fontunchanged                   ;NB V is clear if branched to
        PrPassError
        LDR     r14, fontpaint_flags
        TST     r14, #fontpaintflag_reversed
        BNE     font_paintchunk_reversed

        BL      output_PSstring                 ; Output the string
        B       font_paintchunk_getfgrgb

font_paintchunk_reversed
        BL      output_PSstringBackwards        ; Output the string

font_paintchunk_getfgrgb
        BLVC    font_getfgrgb                   ;Get foreground RGB value and
        BLVC    colour_setrealrgb               ;  set it if necessary
        [       PSCoordSpeedUps
        BLVC    colour_ensure
        ]
        PrPassError

        LDR     r0, fontpaint_flags
        [       PSDebugFont
        PrNewLn
        PrStrIm "% fontpaint_flags = "
        PrNumSp r0
        PrNewLn
        ]
        TST     r0, #fontpaintflag_matrix
        BEQ     font_paintchunk_NoMatrixToSend
        PrStrIm "GS "

        ADR     r14, fontpaint_matrix
        LDMIA   r14, { r4-r9 }
        PrPair  r4, r5
        PrPair  r6, r7
; since the SDM operator is organised for Draw-style transformations, it divides
; the translational part by 256 - this is *not* required for the font transformation,
; so is countered here (easier than defining font-specific version of SDM in prologue)
        MOV     r8,r8,ASL #8
        MOV     r9,r9,ASL #8
        PrPair  r8, r9
        MOV     r8,r8,ASR #8
        MOV     r9,r9,ASR #8

        ; We must start at the endpoint if we're reversed
        TST     r0, #fontpaintflag_reversed
        ADRNE   r14, fontpaint_paintendxy
        ADDEQ   r14, sp, #12                     ; Address in the stack of R3
        LDMIA   r14, { r6, r7 }                  ; Get the start position

        PrPair  r6, r7 

        PrLnIm  "T SDM"

font_paintchunk_NoMatrixToSend
        ADR     r14, fontpaint_spaceaddX
        LDMIA   r14, { r6-r9 }
        ASSERT  fontpaint_spaceaddY = fontpaint_spaceaddX+4
        ASSERT  fontpaint_charaddX  = fontpaint_spaceaddX+8
        ASSERT  fontpaint_charaddY  = fontpaint_spaceaddX+12
        ORR     r14, r6, r7                     ; See if all four
        ORR     r14, r14, r8                    ; are zero
        ORRS    r14, r14, r9
        BEQ     font_paintchunk_notjustifying   ; Branch if they are

        PrPair  r6, r7                          ; Output the spaceadd pair
        [ PSAxisAlignedJustification
        TST     r0, #fontpaintflag_matrix
        BEQ     %FT00
        PrStrIm "IT "
00
        ]

        PrStrIm "32 "                           ; Char to do extra spacing on

        PrPair  r8, r9                          ; Output the charadd pair
        [ PSAxisAlignedJustification
        TST     r0, #fontpaintflag_matrix
        BEQ     %FT00
        PrStrIm "IT "
00
        ]

        LDR     r0, fontpaint_font
        LDR     r1, [ sp, #4 ]
        LDR     r2, =&180                       ; Bits 8, and 7
        MOV     r3, #BigNum
        MOV     r4, #BigNum
        LDR     r7, [ sp, #20 ]                 ; Get the string's length
        MOV     r5, #0
        [       PSDebugFont
        PrNewLn
        PrStrIm "%"
        PrNumSp r0
        PrNumSp r1
        PrNumSp r2
        PrNumSp r7
        PrNewLn
        ]
        SWI     XFont_ScanString
        PrPair  r3, r4                          ; Get the RISC OS StringWidth

        [ {FALSE}
; we need to get the underline vector in millipoints (ie, ignoring any matrix)
; since the matrix will be in force at the time we draw the underline.
; This must take account of any kerning and justification in force

        ADR     r14, fontpaint_ulpos            ;Get underline position and
        LDMIA   r14, { r4, r5 }                 ;  height
        ASSERT  fontpaint_ulthick = fontpaint_ulpos+4
        TEQ     r5, #0                          ;No underlining?
        BEQ     font_paintchunk_justifynounderline

        Push    "r4, r5"                        ; save u/l pos and height
        LDR     r0, fontpaint_font
        LDR     r1, [ sp, #12 ]
        LDR     R2,fontpaint_flags      ;Setup a valid flags word
        AND     R2,R2,#fontpaintflag_reversed +fontpaintflag_kern
        ORR     R2,R2,#fontpaintflag_coordsblk +fontpaintflag_usehandle +fontpaintflag_length
        LDR     r7, [ sp, #28 ]                 ; Get the string's length
      
        ADR     lr,fontpaint_spaceaddX
        LDMIA   lr,{R3-R6}
        MOV     LR,#-1                  ;Split character is -1 (none)
        Push    "R3-R6,LR"              ;Push justification + split character
        MOV     R5,SP                   ;Pointer to my coordinate block copy on the stack

        MOV     r3, #BigNum
        MOV     r4, #BigNum

        SWI     XFont_ScanString        ;Returns the nearest caret position to use as coordaintes
        ADD     SP,SP,#4*5              ;Balance the stack correctly

        MOVVS   r3, #0
        MOVVS   r4, #0
        TST     r2, #fontpaintflag_reversed     ; Font_ScanString preserves r2
        RSBNE   r3, r3, #0
        RSBNE   r4, r4, #0

        PrPair  r3, r4                          ; u/l vector

        Pull    "r4, r5"                        ; get u/l pos and height back
        MOV     r4, r4, LSL #24                 ;Sign extend position
        MOV     r4, r4, ASR #24
        PrPair  r4, r5                          ;Output position and height
        |
; old way
        ADR     r14, fontpaint_ulpos            ;Get underline position and
        LDMIA   r14, { r4, r5 }                 ;  height
        ASSERT  fontpaint_ulthick = fontpaint_ulpos+4
        TEQ     r5, #0                          ;No underlining?
        BEQ     font_paintchunk_justifynounderline
        ADD     r14, sp, #12                    ; Address in the stack of R3
        LDMIA   r14, { r6, r7 }                 ; Get the start position
        ADR     r14, fontpaint_paintendxy       ; Get the end position
        LDMIA   r14, { r8, r9 }
        LDR     r0, fontpaint_flags             ; get the sums right if we're reversed
        TST     r0, #fontpaintflag_reversed
        SUBEQ   r8, r8, r6                      ;Calculate width (non-reversed)
        SUBNE   r8, r6, r8                      ;Calculate width (reversed)
        SUBEQ   r9, r9, r7                      ;Calculate height (non-reversed)
        SUBNE   r9, r7, r9                      ;Calculate height (reversed)
        MOV     r4, r4, LSL #24                 ;Sign extend position
        MOV     r4, r4, ASR #24

        PrPair  r8, r9                          ;Output width
        [ PSAxisAlignedJustification
        TST     r0, #fontpaintflag_matrix
        BEQ     %FT00
        PrStrIm "IT "
00
        ]
        PrPair  r4, r5                          ;Output position and height

        ]

font_paintchunk_justifynounderline
        LDR     r14, fontpaint_flags
        TST     r14, #fontpaintflag_matrix      ; If there's a matrix
        MOVNE   r2, #0                          ; Then we have done a translate
        MOVNE   r3, #0                          ; So the start position is 0,0
        BNE     %FT00                           ; and don't look at the reversal question

        TST     r14, #fontpaintflag_reversed    ; is this section reversed?
        ADDEQ   r14, sp, #12                    ; NO: Address in the stack of R3
        LDMEQIA r14, { r2, r3 }                 ; Get the start position
        ADRNE   r14, fontpaint_paintendxy       ; YES: get "end" position instead
        LDMNEIA r14, {r2, r3}
00
        PrPair  r2, r3                          ; Output the start position

        TEQ     r5, #0                          ; Are we underlining?
        BEQ     font_paintchunk_OutputJ
        PrStrIm "U"
font_paintchunk_OutputJ
        PrStrIm "J"
        B       font_paintchunk_OutputTx

font_paintchunk_notjustifying
        [       True
        LDR     r0, fontpaint_font
        LDR     r1, [ sp, #4 ]
        LDR     r2, =&180                       ; Bits 8, and 7
        MOV     r3, #BigNum
        MOV     r4, #BigNum
        LDR     r7, [ sp, #20 ]                 ; Get the string's length
        MOV     r5, #0
        [       PSDebugFont
        PrNewLn
        PrStrIm "%"
        PrNumSp r0
        PrNumSp r1
        PrNumSp r2
        PrNumSp r7
        PrNewLn
        ]

; We get the string width without kerning, and so does the PostScript support
; code.  The two cancel out since they are using exactly the same kern data.

        SWI     XFont_ScanString
        PrPair  r3, r4                          ; Get the RISC OS StringWidth

        LDR     r14, fontpaint_flags
        TST     r14, #fontpaintflag_matrix      ; If there's a matrix
        MOVNE   r2, #0                          ; Then we have done a translate
        MOVNE   r3, #0                          ; So the start position is 0,0
        BNE     %FT00                           ; and don't look at the reversal question

        TST     r14, #fontpaintflag_reversed    ; is this section reversed?
        ADDEQ   r14, sp, #12                    ; NO: Address in the stack of R3
        LDMEQIA r14, { r2, r3 }                 ; Get the start position
        ADRNE   r14, fontpaint_paintendxy       ; YES: get "end" position instead
        LDMNEIA r14, {r2, r3}
00
        PrPair  r2, r3                          ; Output the start position
        |
        ADD     r14, sp, #12                    ; Address in the stack of R3
        LDMIA   r14, { r2, r3 }                 ; Get the start position
        ADR     r14, fontpaint_paintendxy       ; Get the end position
        LDMIA   r14, { r8, r9 }
        SUB     R8,R8,R2                        ;Calculate width
        SUB     R9,R9,R3
        PrPair  R8,R9                           ;Output width
        PrPair  R2,R3                           ;And start position
        ]

        ADR     R0,fontpaint_ulpos              ;Get underline position and
        LDMIA   R0,{R0,R1}                      ;  height
        ASSERT  fontpaint_ulthick = fontpaint_ulpos+4
        TEQ     R1,#0                           ;No underlining?
        BEQ     font_paintchunk_OutputTx
        MOV     R0,R0,LSL #24                   ;Sign extend position
        MOV     R0,R0,ASR #24
        PrPair  R0,R1                           ;Output position and height

; If kerning and underlining, we need to also supply the x and y movements corresponding
; to the kerned rendition of the text, to make sure that the underline is suitably short.
; Note that this is in millipoints; the matrix (if any) is already in PostScript's CTM.

        LDR     r14, fontpaint_flags
        TST     r14, #fontpaintflag_kern
        BEQ     %FT00

        LDR     r0, fontpaint_font
        LDR     r1, [ sp, #4 ]
        LDR     r2, =&380                       ; Bits 9, 8, and 7
        MOV     r3, #BigNum
        MOV     r4, #BigNum
        LDR     r7, [ sp, #20 ]                 ; Get the string's length
        MOV     r5, #0
        SWI     XFont_ScanString
        PrPair  r3, r4                          ; output the kerned width

00
        PrStrIm "U"                             ;Use "UTx" rather than "Tx"

font_paintchunk_OutputTx
        LDR     r14, fontpaint_flags
        TST     r14, #fontpaintflag_kern
        BEQ     font_paintchunk_nokerning
        PrStrIm "K"

font_paintchunk_nokerning
        PrLnIm  "Tx",FallThroughOnError         ;And tell PostScript to print
        LDR     r14, fontpaint_flags
        TST     r14, #fontpaintflag_matrix
        BEQ     font_paintchunk_NoMatrixToRestore
        PrLnIm  "GR"
font_paintchunk_NoMatrixToRestore
        PrError
font_paintchunk_return
        STRVS   R0,[R13]
        Pull    "R0-R9,PC"

        LTORG

; Old version
; The string painting routine.
; Entry: R0 = number of spaces in the chunk to be printed.
;        R1 points to the start of the chunk to print. This is guaranteed to
;           contain only printable characters.
;        R4 is the X component of the "deficit" for this chunk (i.e. the
;           difference between its required width and its width according to
;           the font manager). If we're not justifying or there are no
;           spaces, this will be zero.
;        R5 is the number of characters in the chunk. This is guaranteed not
;           to be more than the maximum returned by the call to
;           'font_stringstart'.
;        R6 is the Y component of the "deficit" for this chunk. See comments
;           on R4.
;        R8 is the pass over the string, in countdown format (e.g. if there
;           are two passes, it is 2 on the first pass, 1 on the second).
;        R10 contains the print job's file handle.
;        R11 points to the print job's workspace.
;        'fontpaint_chunkstart' contains the required start position for the
;           chunk.
;        'fontpaint_chunkend' contains the required end position for the
;           chunk.
;        'fontpaint_flags' contains the justification and rubout flags.
;        'fontpaint_font' contains the current font handle. The routine may
;           freely alter the font manager's current font.
;        'fontpaint_ulpos' and 'fontpaint_ulthick' contain the current
;           underlining information.
;        All co-ordinates are in millipoints, and are relative to the bottom
;           left corner of the user's box.
; Exit:  All registers preserved (except R0 on an error).

;font_paintchunk
;        Push    "R0-R9,LR"
;        PrError font_paintchunk_return
;        [       PSDebugFont
;        PrLnIm  "% font_paintchunk"
;        ]

;        CMP     R8,#2                           ;A pass with R8=2 will only
;        BNE     font_paintchunk_text            ;  happen if we're rubbing
;                                                ;  out and will be the first
;                                                ;  pass executed

;        BL      font_getbgrgb                   ;Get new background colour
;        MOV     R3,R1
;        ADR     R5,pendingrubout_rgb            ;Also the pending rubout
;        LDMIA   R5,{R1,R2}                      ;  background and left edge
;        ASSERT  pendingrubout_left = pendingrubout_rgb+4
;        CMP     R3,R1                           ;If colour hasn't changed, we
;        BEQ     font_paintchunk_return          ;  leave the rubout pending
;                                                ;  (NB V=0 in this case)
;        LDR     R4,fontpaint_chunkstart         ;Otherwise get the place to
;        BL      font_dorubout                   ;  rub out to and do it
;        STMVCIA R5,{R3,R4}                      ;Store new pending position
;        ASSERT  pendingrubout_left = pendingrubout_rgb+4
;        B       font_paintchunk_return          ;And return

;font_paintchunk_text
;        [       PSTextSpeedUps

;        LDR     R0,fontpaint_font               ;Are we out of step with the
;        LDR     R7,currentfontptr               ;  PostScript font? If so, we
;        LDR     LR,[R7]                         ;  want to update PostScript.
;        CMP     R0,LR
;        BEQ     font_paintchunk_fontunchanged   ;NB V is clear if we branch
;        STR     R0,[R7]

;        |

;        LDR     R0,fontpaint_font               ;Are we out of step with the
;        LDR     LR,currentPSfont                ;  PostScript font? If so, we
;        CMP     R0,LR                           ;  want to update PostScript.
;        BEQ     font_paintchunk_fontunchanged   ;NB V is clear if we branch
;        STR     R0,currentPSfont

;        ]

;        Push    "R1,R4,R5,R6"
;        PrError font_paintchunk_fontdone

;        ADR     R1,expansionbuffer              ;Read font name and size.
;        SWI     XFont_ReadDefn
;        PrPassError

;        PrChrIm "/"                             ;Output font name
;font_paintchunk_fontloop
;        LDRB    R0,[R1],#1
;        CMP     R0,#32
;        BLO     font_paintchunk_endfontloop
;        TEQ     R0,#"*"
;        BEQ     font_paintchunk_fontloop
;        PrChr   R0
;        B       font_paintchunk_fontloop
;font_paintchunk_endfontloop
;        PrChrIm " "

;        PrPair  R2,R3                           ;Output font size
;        PrLnIm  "Fn",FallThroughOnError         ;Select font

;        PrError font_paintchunk_return
;font_paintchunk_fontdone
;        Pull    "R1,R4,R5,R6"
;font_paintchunk_fontunchanged                   ;NB V is clear if branched to

;        BLVC    output_PSstring                 ;Output the string
;        BLVC    font_getfgrgb                   ;Get foreground RGB value and
;        BLVC    colour_setrealrgb               ;  set it if necessary
;        [       PSCoordSpeedUps
;        BLVC    colour_ensure
;        ]
;        PrPassError

;        ADR     LR,fontpaint_chunkstart         ;Get start and end positions
;        LDMIA   LR,{R2,R3,R8,R9}
;        ASSERT  fontpaint_chunkend = fontpaint_chunkstart+8
;        SUB     R8,R8,R2                        ;Calculate width
;        SUB     R9,R9,R3
;        PrPair  R8,R9                           ;Output width
;        PrPair  R2,R3                           ;And start position

;        ORRS    LR,R4,R6                        ;Justifying?
;        BEQ     font_paintchunk_notjustifying   ;Branch if not
;        PrPair  R4,R6                           ;Otherwise output deficit,
;        LDR     R0,[R13]                        ;  then recover space count
;        PrNumSp R0                              ;  and output it
;font_paintchunk_notjustifying

;        ADR     R0,fontpaint_ulpos              ;Get underline position and
;        LDMIA   R0,{R0,R1}                      ;  height
;        ASSERT  fontpaint_ulthick = fontpaint_ulpos+4
;        TEQ     R1,#0                           ;No underlining?
;        BEQ     font_paintchunk_underlinedone
;        MOV     R0,R0,LSL #24                   ;Sign extend position
;        MOV     R0,R0,ASR #24
;        PrPair  R0,R1                           ;Output position and height
;        PrStrIm "U"                             ;Use "UJTx" or "UTx" rather
;                                                ;  than "JTx" or "Tx"
;font_paintchunk_underlinedone

;        ORRS    LR,R4,R6                        ;If justifying, use "UJTx" or
;        BEQ     font_paintchunk_justifydone     ;  "JTx" rather than "UTx" or
;        PrStrIm "J"                             ;  "Tx"
;font_paintchunk_justifydone

;        PrLnIm  "Tx",FallThroughOnError         ;And tell PostScript to print

;        PrError
;font_paintchunk_return
;        STRVS   R0,[R13]
;        Pull    "R0-R9,PC"
;        ]

; The string colour setting routines.

font_bg
        Push    "LR"
        PrError font_bg_return
        [       PSDebugFont
        PrLnIm  "% font_bg"
        ]
        LDR     LR,absfontcols
        ORR     LR,LR,#1
        STR     LR,absfontcols
        STR     R1,bgfontgcol
        PrError
font_bg_return
        Pull    "PC"

font_fg
        Push    "LR"
        PrError font_fg_return
        [       PSDebugFont
        PrLnIm  "%! font_fg"
        ]
        LDR     LR,absfontcols
        ORR     LR,LR,#2
        STR     LR,absfontcols
        STR     R2,fgfontgcol
        PrError
font_fg_return
        Pull    "PC"

font_absbg
        Push    "LR"
        PrError font_absbg_return
        [       PSDebugFont
        PrLnIm  "% font_absbg"
        ]
        LDR     LR,absfontcols
        BIC     LR,LR,#1
        STR     LR,absfontcols
        STR     R1,bgfontrgb
        PrError
font_absbg_return
        Pull    "PC"

font_absfg
        Push    "LR"
        PrError font_absfg_return
        [       PSDebugFont
        PrLnIm  "% font_absfg"
        ]
        LDR     LR,absfontcols
        BIC     LR,LR,#2
        STR     LR,absfontcols
        STR     R2,fgfontrgb
        PrError
font_absfg_return
        Pull    "PC"

font_coloffset
        [       PSDebugFont
        Push    "LR"
        PrLnIm  "% font_coloffset",FallThroughOnError
        Pull    "LR"
        MOVVS   PC,LR
        ]
        STR     R3,fgfontoff
        Return

font_savecolours
        Push    "R0-R6,LR"                      ;Copy contents of
        [       PSDebugFont
        PrError font_savecolours_return
        PrLnIm  "% font_savecolours"
        ]
        ADR     R0,absfontcols                  ;  'absfontcols'-'fgfontoff'
        ADR     LR,absfontcols2                 ;  to their counterparts
        B       font_copycolours
font_restorecolours
        Push    "R0-R6,LR"                      ;Recover contents of
        ADR     R0,absfontcols2                 ;  'absfontcols'-'fgfontoff'
        ADR     LR,absfontcols                  ;  from their counterparts
font_copycolours
        LDMIA   R0,{R1-R6}
        STMIA   LR,{R1-R6}
        CLRV
        [       PSDebugFont
        PrError
font_savecolours_return
        STRVS   R0,[R13]
        ]
        Pull    "R0-R6,PC"

        ASSERT  bgfontrgb = absfontcols+4
        ASSERT  fgfontrgb = bgfontrgb+4
        ASSERT  bgfontgcol = fgfontrgb+4
        ASSERT  fgfontgcol = bgfontgcol+4
        ASSERT  fgfontoff = fgfontgcol+4

        ASSERT  bgfontrgb2 = absfontcols2+4
        ASSERT  fgfontrgb2 = bgfontrgb2+4
        ASSERT  bgfontgcol2 = fgfontrgb2+4
        ASSERT  fgfontgcol2 = bgfontgcol2+4
        ASSERT  fgfontoff2 = fgfontgcol2+4

        END
