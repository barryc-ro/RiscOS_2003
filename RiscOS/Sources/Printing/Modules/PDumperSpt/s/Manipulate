; > Manipulate

;------------------------------------------------------------------------------
;
; PDumper_PrepareStrip implementation
;
;   Entry: R0 ->anchor word
;          R1 ->bit image data
;          R2 resulting format of the strip
;               bits 0..7 => format
;                               0 =grey level (halftoned)
;                               1 =grey level (diffused)
;                               2 =colour     (halftoned)
;                               3 =colour     (diffused)
;                               2*X  =halftoned
;                               2*X+1=diffused for strip-type X
;
;               bits 8 set => returned monochrome always
;               all other bits reserved
;
;          R3 strip width in pixels               ;N.B. NOT IN BYTES
;          R4 strip height in scan lines
;          R5 strip width in pixels               ;INCLUDING PADDING, NOT IN BYTES
;>>>>>>>>>>>N.B. R5 IS DEFINED TO BE A MULTIPLE OF 4<<<<<<<<<<<<<<<<<
;          R6 halftone information
;               bits 0..7 => horizontal resolution
;               bits 8..15 => vertical resolution
;                     
;   Exit:  V =1 => R0 ->Error block
;          else,   
;>>>>>>>>>>R1->bit image data to ouput, N.B. could now be different from R1 in<<<<<<<
; This call processes the specified 8BPP bitmap generated by the PDumperDP
; module into a format suitable for printing by the relevant output routine.
;
;------------------------------------------------------------------------------

                                ^ 0
preptype_GreyHalftone           # 1
preptype_GreyDithered           # 1
preptype_ColourHalftone         # 1
preptype_ColourDither           # 1
                                [ fullrgb
preptype_MultiRGBHalftone       # 1
preptype_MultiRGBDither         # 1
preptype_16BitRGBHalftone       # 1
preptype_16BitRGBDither         # 1
preptype_24BitRGBHalftone       # 1
preptype_24BitRGBDither         # 1
                                ]
preptype_Max                    * :INDEX: @

prepflag_OutputInMonochrome     * 1:SHL:8
                                       
prepflag_Allowed                * 2_11111111
preptype_Mask                   * 2_11111111

SWIPDumper_PrepareStrip ROUT

;make sure width is multiple of 8 (assumed by some newer code), ie. catch case
;when old PDriverDP might cause crash
        TST     R3,#7
        BNE     %FT81
               
        Push    "R0-R1,R8,LR"
       
        Debug   prepstrip,"(prepstrip) anchor word",R0
        Debug   prepstrip,"            strip at",R1
        Debug   prepstrip,"            format",R2
        Debuga  prepstrip,"            width",R3
        Debuga  prepstrip,", height",R4
        Debuga  prepstrip,", byte width",R5
        Debug   prepstrip,", halftone information",R6

        LDR     R8,=prepflag_Allowed
        BICS    R8,R2,R8                ;Are any invalid bits set within flags
        BLNE    %FT80                   ;Yes, so give an error

        MOVVC   R8,R0                   ;->Pointer to anchor word
        MOVVC   R0,R1                   ;->Strip data
        BLVC    preproutine             ;Despatch to a suitable routine for prep work
        MOVVC   R8,#0
        STRVC   R8,FirstStrip           ;reset flag
        STRVS   R0,[SP]                 ;Balance the stack and then exit
        STRVC   R0,[SP,#4]              ;<<<<AND KEEP NEW STRIP POINTER
        Pull    "R0-R1,R8,PC"

80
        Debug   prepstrip,"(prepstrip) reserved bits set"

        ADRL    R0,ErrorBlock_PDumperReserved
        B       LookupError             ;Convert token to a suitable error 

;sod it - this is a very rare error, so forget internationalisation
81
       ADR      R0,old_pdriverdp_error
       SETV
       MOV      PC,LR

old_pdriverdp_error
       DCD      0
       DCB      "PDumperSpt needs newer PDriverDP (illegal strip width)",0
       ALIGN

;..............................................................................           

InvalidateGammaTable
        Push    "R0-R1,LR"
        
        ADRL    R0, RedGammaTable
        MOV     R1, #&FF
        STRB    R1, [R0]
        Pull    "R0-R1,PC"

;32bit case removed - replaced by code in s.Calib32
;BuildGammaTable32

BuildGammaTable16
        Push    "R0-R11,LR"

        LDR     R2, =BlockType_Palette
        SWI     XPDumper_Find
        BVS     builttable16

        LDR     R3, [R2, #palette_Calibration]
        TEQ     R3, #0
        ADDNE   R3, R2, R3

        Push    "R7,R0"
        MOV     R11, #&FF
        MOV     R0, #&1F
01
        MOV     R4, R0, LSL #3
        ORR     R4, R4, R4, LSR #5      ; convert from 5bit -> 8bit

        MOV     R1, R4, LSL #8          ; make 24 bit rgb value
        ORR     R1, R1, R4, LSL #16
        ORR     R1, R1, R4, LSL #24

        SWI     XColourTrans_ConvertDeviceColour

        ADRL    R6, RedGammaTable
        AND     R7, R11, R2, LSR #8
        AND     R7, R7, #&F8
        MOV     R7, R7, LSR #3
        STRB    R7, [R6, R0]

        ADRL    R6, GreenGammaTable 
        AND     R7, R11, R2, LSR #16
        AND     R7, R7, #&F8
        MOV     R7, R7, LSR #3
        STRB    R7, [R6, R0]

        ADRL    R6, BlueGammaTable
        AND     R7, R11, R2, LSR #24
        AND     R7, R7, #&F8
        MOV     R7, R7, LSR #3
        STRB    R7, [R6, R0] 

        SUBS    R0, R0, #1
;version 1.18 - make sure table includes proper 0 correction
        BPL     %BT01

        Pull    "R7,R0"

builttable16
        Pull    "R0-R11,PC"
 

;32bit case removed - replaced by code in s.Calib32
;gamma_correctstrip32

        GET     s.Calib32

;8 bit gr8rey calib
        GET     s.Calib8

gamma_correctstrip16
        Push    "R0-R11,LR"

        Push    "R0-R3"
        
        ADR     R3, RedGammaTable
        LDRB    R1, [R3]
        CMP     R1, #&FF
        MOVEQ   R0, R8
        BLEQ    BuildGammaTable16
        Pull    "R0-R3"

        MUL     R5, R4, R3
        MOV     R6, #&1F               ; R6 = mask for 5 bit colour
        ADR     R8, RedGammaTable
        ADR     R9, GreenGammaTable
        ADR     R10, BlueGammaTable

        LDRB    R11,[R9,#0]  ; = corrected-green[0] , detects ink-density-correcting palette

        MOV     R7, #&7F00
        ORR     R7, R7, #&FF           
        ORR     R7, R7, R7, LSL #16    ; R7 = &7FFF7FFF = white,white

        B       %FT01

next_pixel16
        SUBS    R5, R5, #2             ; next 2 pixels
        Pull    "R0-R11,PC",LE,^

01      LDR     R14, [R0], #4          ; load 2 pixels

; version 1.18 - stop the optimise which doesn't look-up 0 (black) - may need correction
        CMP     R14,R7                 ; are they white,white ?
        BEQ     next_pixel16

        AND     R3, R6, R14, LSR #10     ; extract blue 1
        AND     R2, R6, R14, LSR #5      ; extract green 1
        AND     R1, R6, R14              ; extract red 1
        LDRB    R1, [R8, R1]             ; gamma correct red
        LDRB    R2, [R9, R2]             ; gamma correct green
        LDRB    R3, [R10, R3]            ; gamma correct blue
        CMP     R11,#0
        BEQ     %FT02
;ink density correction - hell, 32k mode is going to be naff anyway (range 0..31, then reduce ink
;densities ... oh dear!), so do something cheap, ie. just crunch all components by another 62.5% factor
        ADD     R1,R1,R1,LSL #2 ;*5
        MOV     R1,R1,LSR #3    ;*5/8 (62.5%)
        ADD     R1,R1,#12       ;+3/8 (of 31)
        ADD     R2,R2,R2,LSL #2
        MOV     R2,R2,LSR #3
        ADD     R2,R2,#12
        ADD     R3,R3,R3,LSL #2
        MOV     R3,R3,LSR #3
        ADD     R3,R3,#12
02
        ORR     R1, R1, R2, LSL #5
        ORR     R1, R1, R3, LSL #10
        MOV     R4, R1                   ; remember corrected 1

        AND     R3, R6, R14, LSR #10+16  ; extract blue 2
        AND     R2, R6, R14, LSR #5+16   ; extract green 2
        AND     R1, R6, R14, LSR #16     ; extract red 2
        LDRB    R1, [R8, R1]             ; gamma correct red
        LDRB    R2, [R9, R2]             ; gamma correct green
        LDRB    R3, [R10, R3]            ; gamma correct blue
        CMP     R11,#0
        BEQ     %FT03
        ADD     R1,R1,R1,LSL #2 ;*5
        MOV     R1,R1,LSR #3    ;*5/8 (62.5%)
        ADD     R1,R1,#12       ;+3/8 (of 31)
        ADD     R2,R2,R2,LSL #2
        MOV     R2,R2,LSR #3
        ADD     R2,R2,#12
        ADD     R3,R3,R3,LSL #2
        MOV     R3,R3,LSR #3
        ADD     R3,R3,#12
03
        ORR     R1, R1, R2, LSL #5
        ORR     R1, R1, R3, LSL #10
        ORR     R4, R4, R1, LSL #16      ; corrected 1 and 2

        STR     R4, [R0, #-4]            ; store corrected 1 and 2
        B       next_pixel16


preproutine
        AND     R1,R2,#preptype_Mask    ;Extract suitable bits for execution

        Debug   prepstrip,"(prepstrip) strip at",R0
        Debuga  prepstrip,"(prepstrip) output type",R1
        Debug   prepstrip,", flags word",R2

        [ {TRUE}
        Push    "R14"
        CMP     R1, #0
        CMPNE   R1, #1
        BLEQ    cmyk_convert_strip8     ;grey->k conversion (also finds whitespace margins)
        CMP     R1, #6                  ; Is it a 16bpp output
        CMPNE   R1, #7                  ; or is it a 32bpp output
        BLEQ    gamma_correctstrip16    ; then gamma correct output strip
        CMP     R1, #8
        CMPNE   R1, #9
        BLEQ    cmyk_convert_strip32    ;combined (fast) calibration, rgb->cmyk conversion
        Pull    "R14"
        ]

        CMP     R1,#preptype_Max        ;Is it within a sensible range?
        ADDCC   PC,PC,R1,LSL #2         ;...yup so despatch
        B       %FT99

        B       HalftoneGreySprite
        B       DitherGreySprite
        B       HalftoneColourSprite
        B       DitherColourSprite
        [ fullrgb
        B       HalftoneMultiRGB
        B       DitherMultiRGB
        B       Halftone16BitRGB
        B       Dither16BitRGB
        B       Halftone24BitRGB
        B       Dither24BitRGB
        ]
99
        Debug   prepstrip,"(prepstrip) kabooom!"

        ADR     R0,ErrorBlock_PDumperBadOutputType
        B       LookupError             ;Return a deep and meaningful error

        MakeInternatErrorBlock PDumperBadOutputType,,BadType

;------------------------------------------------------------------------------
; 
; findblock / findblockR8
;                       
; Find the block based on the tag in R1, either using the anchor point in R0
; or R8.  The routine can be made to the next block by moving the returned
; pointer into the specified anchor word pointer and then calling the
; routines again.
; 
; in    R0 ->anchor word (if 'findblock')
;       R1 tag of block to find
;       R8 ->anchor word (if 'findblockR8')
; 
; out   V =1 => R0 ->error block
;       else,   R1 ->block located

findblockR8 ROUT

        Push    "R0,LR"

        Debuga  findblock,"(findblockR8) Anchor word",R8
        Debug   findblock,", tag",R1
                          
        MOV     R0,R8           ;Move anchor word to suitable register
        BL      findblock       ;Attempt to find the block
        STRVS   R0,[SP]

        DebugE  findblock,"(findblockR8) Gave error"
        Debug   findblock,"(findblockR8) Pointer to strip block",R1
                                
        Pull    "R0,PC"

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 

findblock ROUT

        Push    "R0,R2,LR"

        Debuga  findblock,"(findblock) Anchor word",R0
        Debug   findblock,", tag",R1

        MOV     R2,R1           ;Tag for the block to be found
        SWI     XPDumper_Find
        MOVVC   R1,R2           ;Resolve pointer to block if it has been found
        STRVS   R0,[SP]         ;..or maybe even the error pointer

        DebugE  findblock,"(findblock) Gave error"
        Debug   findblock,"(findblock) Pointer to strip block",R1
                                
        Pull    "R0,R2,PC"     

;------------------------------------------------------------------------------
;
; HalftoneGreySprite implementation
;
;   Entry: R0 ->strip
;          R3 dump width
;          R4 number of rows
;          R5 row width in bytes
;          R6 x halftone width in bits 0..7 and Y in bits 8..15
;          R8 ->anchor word for pdumper
;                     
;   Exit:  V =1 => R0 ->Error block
;
; Halftone the specified sprite using the data stored within the palette
; file.
;
;------------------------------------------------------------------------------
          
HalftoneGreySprite ROUT

        Push    "R0-R11,LR"

        LDR     R1,=BlockType_Palette   ;Tag for the palette file
        BL      findblockR8          
        BVS     halftonegrey_return     ;If unable to locate the block then return

        ADR     R10,KeyHalfInfo            ;Needed later
        LDR     R11,FirstStrip
        TEQ     R11,#0
        BEQ     halftonegrey_start         ;Initialisation has been done
        MOV     R11,#0
        STR     R11,FirstStrip

        Debuga  prepstrip,"(halftone grey) Strip at",R0
        Debuga  prepstrip,", width",R3
        Debuga  prepstrip,", height",R4
        Debuga  prepstrip,", byte width",R5
        Debuga  prepstrip,", halftone info",R6
        Debug   prepstrip,", palette block at",R1
;Need to call Do_HalftoneGreySprite with a bit of register rearrangement...
;R0=R5 (columncount byte width used, halftoning missing bits doesn't matter)
;R1=R4 (rowcount)
;R2,R3=x,y
;R4,R6=table,halfsize
;R7,R8=xstart,ystart
;R10=R0 (sprite)
;R12,KeyHalfInfo=Small/Large halftone info for each colour...depends on R6
;Between strips, information is kept in KeyHalfInfo, like the colour rendering
        AND     R6,R6,#255           ;Get halftoning resolution
        CMP     R6,#4
        ADDLS   R8,R1,#palette_Small    ;Use small halftone if <=4
        ADDHI   R8,R1,#palette_Large    ;Otherwise large halftones
        MOV     R14,#0
;Clear out the halftone table
        MOV     R9,#halftone_workspace
00
        STR     R14,[R10],#4
        SUBS    R9,R9,#4
        BNE     %BT00
;So now x,y,xstart,ystart are Ok, Need also to set halftone_table and halftone_halfsize
        ADR     R10,KeyHalfInfo
        LDR     R14,[R8]                 ;Pick up offset to halftone table
        ADD     R14,R1,R14               ;Add the file start
        LDR     R9,[R14],#4              ;Load the size
        STR     R9,[R10,#halftone_halfsize]
        ADD     R9,R14,R9,LSL #2         ;Offset to the actual table
        STR     R9,[R10,#halftone_table]
;And now whole block is ready for load...
halftonegrey_start
        MOV     R1,R4
        LDMIA   R10,{R2,R3,R4,R6,R7,R8}
        MOV     R10,R0
        MOV     R0,R5
        CLRV                              ;There won't be any errors (honest guv!)
        BL      Do_HalftoneGreySprite
        ADR     R10,KeyHalfInfo
        STMIA   R10,{R2,R3,R4,R6,R7,R8}   ;Keep info for next sweep                           
halftonegrey_return
        DebugE  prepstrip,"(halftone grey) errored"
        Debug   prepstrip,"(halftone grey) exiting"

        STRVS   R0,[SP]                 ;Return any errors generated
        Pull    "R0-R11,PC"

;------------------------------------------------------------------------------
;
; DitherGreySprite implementation
;
;   Entry: R0 ->strip
;          R3 dump width (bytes or bits)
;          R4 dump height (rows)
;          R5 row width in bytes ( >=R3)
;          R6 x halftone width in bits 0..7 and Y in bits 8..15
;          R8 ->anchor word
;                     
;   Exit:  V =1 => R0 ->Error block
;
; Error diffuse a grey sprite using palette data.
;                     
;------------------------------------------------------------------------------
; Entry for Do_DitherGreySprite is
; R0=Width (***should be dump width, not row width??***) use R5 for the moment
; R1=Height (=R4)
; R2=abefore (kept between strips)
; R3=anow (kept between strips)
; (R5=before)
; R12,errorbuffer=allocated buffer for errors (initially blank), size=Width+2


DitherGreySprite ROUT

        Push    "R0-R11,LR"

        Debug   prepstrip,"(dither grey) Entered"

        LDR     R1,=BlockType_ErrorDiffuse
        BL      findblockR8             ;Attempt to find diffusion block
        BVC     %FT10                   ;We found it so no need to set one up

        Debug   prepstrip,"(dither grey) Allocate diffuse buffer"

        Push    "R3,R4"
        MOV     R0,R8
        ADD     R3,R5,#2                ;Size of block with two blanks at ends
        MOV     R3,R3,LSL#2             ;And need words (error may be +/-)
        LDR     R4,=BlockType_ErrorDiffuse
        SWI     XPDumper_Claim          ;Attempt to claim the block required
        Pull    "R3,R4"                 ;...restore R3,R4
        BVS     dithergrey_return

        Debug   prepstrip,"(dither grey) Diffuse buffer at",R2

        MOV     R1,#1                   ;Reset the random seed
        STR     R1,RandomSeed
        STR     R2,errorbuffer          ;Keep the error buffer for later
        ADD     R3,R5,#2                ;Temporary copy of line width used when reseting
        MOV     R1,#0                   ;Reset the rest of the buffer will nulls
05
        STR     R1,[R2],#4              ;Reset the pixel value
        SUBS    R3,R3,#1
        BNE     %BT05                   ;Loop back until all reset

        MOV   R2,#0                ;clear abefore/anow for the first row
        STR   R2,KeyDiffuse        ;before is dealt with by code anyway at line ends
        STR   R2,KeyDiffuse+4
10
        LDR     R10,[SP]                ;Restore original strip pointer
        MOV     R0,R5
        MOV     R1,R4
        LDR     R2,KeyDiffuse
        LDR     R3,KeyDiffuse+4

        CLRV                            ;Should be no errors
        BL      Do_DitherGreySprite

        STR     R2,KeyDiffuse           ;Keep for next time to glue lines together
        STR     R3,KeyDiffuse+4

        Debuga  prepstrip,"(dither grey) Strip at",R0
        Debuga  prepstrip,", width",R3
        Debuga  prepstrip,", height",R4
        Debuga  prepstrip,", byte width",R5
        Debug   prepstrip,", halftone info",R6 
        Debug   prepstrip,"(dither grey) Diffuse buffer at",R8

dithergrey_return
        DebugE  prepstrip,"(dither grey) errored"
        Debug   prepstrip,"(dither grey) exiting"

        STRVS   R0,[SP]                 ;Store suitable error pointer if required
        Pull    "R0-R11,PC"

;routine used in multi-pass case to convert 3-plane 24bpp format into 32bpp
;(deep sprite) format for new code
;
;entry: R0->descriptor
;           R0+0  -> red plane
;           R0+4  -> green plane
;           R0+8  -> blue plane
;           R0+12 -> 32bpp buffer
;       R3 = width in pixels
;       R4 = height in pixels
conv_24bpp_to_32bpp ROUT
        Push    "R0-R9,LR"
   Debug prepstrip,"conv_24bpp_to_32bpp R0 w h ",R0,R3,R4
        LDMIA R0,{R5-R8}
   Debug prepstrip,"conv_24bpp_to_32bpp buffers ",R5,R6,R7,R8
        MUL   R3,R4,R3
01
        LDR   R0,[R5],#4
        LDR   R1,[R6],#4
        LDR   R2,[R7],#4
        CMN   R0,#1
        CMNEQ R1,#1
        CMNEQ R2,#1
        BEQ   %FT03  ;all 4 pixels white
        MOV   LR,#4
02
        AND   R4,R0,#255
        AND   R9,R1,#255
        ORR   R4,R4,R9,LSL #8
        AND   R9,R2,#255
        ORR   R4,R4,R9,LSL #16
        STR   R4,[R8],#4
        MOV   R0,R0,LSR #8
        MOV   R1,R1,LSR #8
        MOV   R2,R2,LSR #8
        SUBS  LR,LR,#1
        BNE   %BT02
        SUBS  R3,R3,#4
        BNE   %BT01
        Pull  "R0-R9,PC"
03
        MOV   R0,R0,LSR #8   ; &FFFFFFFF => &00FFFFFF (= 32bpp white)
        MOV   R1,R0
        MOV   R2,R0
        MOV   R4,R0
        STMIA R8!,{R0-R2,R4}
        SUBS  R3,R3,#4
        BNE   %BT01
        Pull  "R0-R9,PC"

;------------------------------------------------------------------------------
;
; HalftoneColourSprite implementation
;
;   Entry: R0 ->strip
;          R3 dump width (bytes or bits)          ***I.e. pixels for fullrgb
;          R4 number of rows
;          R5 row width in bytes ( >= R3 )
;          R6 x halftone width in bits 0..7 and Y in bits 8..15
;          R8 ->anchor word for pdumper
;          
;   Exit:  V =1 => R0 ->Error block
;
; Recolour a 256 colour sprite according to the specified pattern table.
;
;------------------------------------------------------------------------------
            [ fullrgb
;In much the same way as for the error diffuser (see below)
;It is safe to write the result into the 'first' of the various buffers

HalftoneMultiRGB ROUT
        Push    "R0-R11,LR"
        MOV     R1,#0
        STR     R1,KCMYTable
        BL      conv_24bpp_to_32bpp         ;convert to 32bpp pixels
        LDR     R0,[R0,#12]                 ;pick up the 32bpp pointer
        Push    "R1"
        MOV     R1,#8 ;flags halftone mode
        BL      cmyk_convert_strip32
        Pull    "R1"
;now everything looks like ordinary 24BitRGB case
        MOV     R10,#4
        STR     R0,redbuffer
        ADD     R1,R0,#1
        STR     R1,greenbuffer
        ADD     R1,R0,#2
        STR     R1,bluebuffer
        STR     R0,[SP]                     ;See note below...
        B       HalftoneColourSprite2
Halftone16BitRGB ROUT
        Push    "R0-R11,LR"
        MOV     R1,#1
        STR     R1,KCMYTable
        MOV     R10,#2
        STR     R0,redbuffer
        B       HalftoneColourSprite2
Halftone24BitRGB ROUT
        Push    "R0-R11,LR"
        MOV     R1,#0
        STR     R1,KCMYTable
        MOV     R10,#4
        STR     R0,redbuffer
        ADD     R1,R0,#1
        STR     R1,greenbuffer
        ADD     R1,R0,#2
        STR     R1,bluebuffer
        B       HalftoneColourSprite2
            ]

HalftoneColourSprite ROUT

        Push    "R0-R11,LR"

        [ fullrgb
        MOV     R10,#0                  ;Get KCMYTable from palette file
HalftoneColourSprite2
        STR     R10,pixsep              ;Will be non-zero for real sprites
        ]

        LDR     R1,=BlockType_Palette   ;Tag for the palette block
        BL      findblockR8
        BVS     halftonecolour_return   ;If unable to find the palette block then exit

        LDR     R11,FirstStrip
  Debug mjs,"HalftoneColourSprite, FirstStrip = ",R11
        TEQ     R11,#0
        BEQ     halftonecolour_start         ;Initialisation has been done
        MOV     R11,#0
        STR     R11,FirstStrip

        [ fullrgb
        TEQ     R10,#0                         ;See if this is 8-bit sprite
        LDREQ     R11,[R1,#palette_PalInverse] ;Get the inverse table
        ADDEQ     R11,R1,R11                   ;Pointer to Key inverses
        STREQ     R11,KCMYTable                ;Keep it for the halftoner
        |
        LDR     R11,[R1,#palette_PalInverse] ;Get the inverse table
        ADD     R11,R1,R11                   ;Pointer to Key inverses
        STR     R11,KCMYTable                ;Keep it for the halftoner
        ]

        LDR     R11,[R1,#palette_Removal]    ;Removal and Overlap flag
        STR     R11,Remove                   ;We need these both

        Debuga  prepstrip,"(halftone colour) Strip at",R0
        Debuga  prepstrip,", width",R3
        Debuga  prepstrip,", height",R4
        Debuga  prepstrip,", byte width",R5
        Debuga  prepstrip,", halftone info",R6
        Debug   prepstrip,", palette block at",R1
;Need to call Do_HalftoneColourSprite with a bit of register rearrangement...
;R0=R5 (columncount byte width used, halftoning missing bits doesn't matter)
;R1=R4 (rowcount)
;R10=R0 (sprite)
;R12,KCMYTable=address of Inverse table in palette file
;R12,XXXHalfInfo=Small/Large halftone info for each colour...depends on R6
        AND     R6,R6,#255           ;Get halftoning resolution
        CMP     R6,#4
        ADDLS   R8,R1,#palette_Small+4  ;Use small halftone if <=4 (preceeded by Grey halftones)
        ADDHI   R8,R1,#palette_Large+4  ;Otherwise large halftones
;Order of tables is Grey,Key,Cyan,Magenta,Yellow i.e. same as for internal layout (of course)
        MOV     R14,#0
;Clear out the halftone tables, this should be dependant on 'first strip' flag
        ADR     R10,KeyHalfInfo
        MOV     R9,#halftone_workspace*4
00
        STR     R14,[R10],#4
        SUBS    R9,R9,#4
        BNE     %BT00
;So now x,y,xstart,ystart are Ok, Need also to set halftone_table and halftone_halfsize
        ADR     R10,KeyHalfInfo
        MOV     R7,#4
10
        LDR     R14,[R8],#4              ;Pick up offset to halftone table
        ADD     R14,R1,R14               ;Add the file start
        LDR     R9,[R14],#4              ;Load the size
        STR     R9,[R10,#halftone_halfsize]
        ADD     R9,R14,R9,LSL #2         ;Offset to the actual table
        STR     R9,[R10,#halftone_table]
        ADD     R10,R10,#halftone_workspace
        SUBS    R7,R7,#1                  ;Repeat for all four colours
        BNE     %BT10
;This is all that's required, except on the first strip
;WARNING: (IMPLICIT) USE OF R12 OFFSETS RESTRICTS USE TO ONE DUMPER AT A TIME...
;SHOULD CHANGE R12 TO A LOCAL ONE HUNG OFF THE ANCHOR
halftonecolour_start
        MOV     R10,R0
        MOV     R1,R4
        MOV     R0,R5
        CLRV                              ;There won't be any errors (honest guv!)
        BL      Do_HalftoneColourSprite

halftonecolour_return
        DebugE  prepstrip,"(halftone colour) errored"
        Debug   prepstrip,"(halftone colour) exiting"

        STRVS   R0,[SP]                 ;Store the error pointer (if error condition)
        Pull    "R0-R11,PC"

;------------------------------------------------------------------------------
;
; DitherColourSprite implementation
;
;   Entry: R0 ->strip
;          R3 dump width (bytes or bits)         ***I.e. Pixels for FullRGB
;          R4 dump height (rows)
;          R5 row width in bytes ( >=R3)
;          R6 x halftone width in bits 0..7 and Y in bits 8..15
;          R8 ->anchor word
;                     
;   Exit:  V =1 => R0 ->Error block
;
; Error diffuse a colour sprite using palette data.
;
;------------------------------------------------------------------------------
; See DitherGreySprite for info on register usage
; Things are multiplied up by a factor of 4 (e.g. error buffer size, and abefore/anows kept)
             [ fullrgb
;for these new ones, we have to set up the buffer pointers
;also some part of the image needs choosing for the output buffer
;since the input is at least 2x the size of the output, it is safe to use the
;first of the pointers as the output buffer, no overlaps occur (honest!)
DitherMultiRGB ROUT
        Push    "R0-R11,LR"
        MOV     R1,#0
        STR     R1,KCMYTable
        BL      conv_24bpp_to_32bpp         ;convert to 32bpp pixels
        LDR     R0,[R0,#12]                 ;pick up the 32bpp pointer
        Push    "R1"
        MOV     R1,#9 ;flags diffused mode
        BL      cmyk_convert_strip32
        Pull    "R1"
;now everything looks like ordinary 24BitRGB
        MOV     R10,#4
        STR     R0,redbuffer
        ADD     R1,R0,#1
        STR     R1,greenbuffer
        ADD     R1,R0,#2
        STR     R1,bluebuffer
        STR     R0,[SP]                     ;System picks this up later...
        B       DitherColourSprite2    ;I.e. this returns output buffer address
Dither16BitRGB ROUT
        Push    "R0-R11,LR"
        MOV     R1,#1
        STR     R1,KCMYTable
        MOV     R10,#2
        STR     R0,redbuffer
        B       DitherColourSprite2
Dither24BitRGB ROUT
        Push    "R0-R11,LR"
        MOV     R1,#0
        STR     R1,KCMYTable
        MOV     R10,#4
        STR     R0,redbuffer
        ADD     R1,R0,#1
        STR     R1,greenbuffer
        ADD     R1,R0,#2
        STR     R1,bluebuffer
        B       DitherColourSprite2
             ]

DitherColourSprite ROUT
         
        Push    "R0-R11,LR"

        [ fullrgb
        MOV     R10,#0
DitherColourSprite2
        STR     R10,pixsep              ;Will be non-zero for real sprites
        ]

        LDR     R1,=BlockType_Palette
        BL      findblockR8             ;Locate the requested block
        BVS     dithercolour_return     ;Return if it errors.

        [ fullrgb
        TEQ     R10,#0                         ;See if this is 8-bit sprite
        LDREQ     R11,[R1,#palette_PalInverse] ;Get the inverse table
        ADDEQ     R11,R1,R11                   ;Pointer to Key inverses
        STREQ     R11,KCMYTable                ;Keep it for the diffuser
        LDRNE     R11,[R1,#palette_Removal]    ;Removal and Overlap flag
        STRNE     R11,Remove                   ;We need Removal for full colour
        |
        LDR     R11,[R1,#palette_PalInverse] ;Get the inverse table
        ADD     R11,R1,R11                   ;Pointer to Key inverses
        STR     R11,KCMYTable                ;Keep it for the diffuser
        ]
        
        MOV     R0,R8
        LDR     R1,=BlockType_ErrorDiffuse
        BL      findblock               ;Attempt to locate the error diffusion block
        BVC     %FT10                   ;Found it Ok
  
        Push    "R3,R4"
        MOV     R0,R8                   ;Fix to ensure that the anchor word is correctly quoted!
        ADD     R3,R5,#2                ;Size and two blanks
        MOV     R3,R3,LSL#4             ;Needs words and 4 inks
        LDR     R4,=BlockType_ErrorDiffuse
        SWI     XPDumper_Claim          ;Attempt to claim the block (assumes R0 ->anchor word)
        Pull    "R3,R4"                 ;Preserve R3,R4 they are kinda important
        BVS     dithercolour_return     ;..exit if it fails to claim

        MOV     R1,#1                   ;Reset the random seed
        STR     R1,RandomSeed
        STR     R2,errorbuffer          ;Keep the error buffer for later
        MOV     R1,#0                   ;Reset scan line information within buffer
        ADD     R3,R5,#2                ;Temporary copy of line width used when reseting
05
        STR     R1,[R2],#4              ;Reset pixel entries to contain zero
        STR     R1,[R2],#4
        STR     R1,[R2],#4
        STR     R1,[R2],#4
        SUBS    R3,R3,#1           
        BNE     %BT05                   ;And loop until they have all been reset

        MOV   R2,#0                ;clear abefore/anow for each colour
        STR   R2,KeyDiffuse        ;before is dealt with by code anyway at line ends
        STR   R2,KeyDiffuse+4
        STR   R2,CyanDiffuse
        STR   R2,CyanDiffuse+4
        STR   R2,MagentaDiffuse
        STR   R2,MagentaDiffuse+4
        STR   R2,YellowDiffuse
        STR   R2,YellowDiffuse+4
10
        Debuga  prepstrip,"(dither colour) Strip at",R0
        Debuga  prepstrip,", width",R3
        Debuga  prepstrip,", height",R4
        Debuga  prepstrip,", byte width",R5
        Debuga  prepstrip,", halftone info",R6
        Debug   prepstrip,"Inverse palette at",R11
                   
        LDR     R10,[SP]                ;Restore original strip pointer
        MOV     R0,R5
        MOV     R1,R4
        CLRV                            ;Should be no errors
        BL      Do_DitherColourSprite

dithercolour_return
        DebugE  prepstrip,"(dither colour) errored"
        Debug   prepstrip,"(dither colour) exiting"

        STRVS   R0,[SP]                 ;Store the error pointer if needed
        Pull    "R0-R11,PC"

        END
