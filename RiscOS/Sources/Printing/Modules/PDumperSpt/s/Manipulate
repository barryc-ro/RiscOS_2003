; > Manipulate

;------------------------------------------------------------------------------
;
; PDumper_PrepareStrip implementation
;
;   Entry: R0 ->anchor word
;          R1 ->bit image data
;          R2 resulting format of the strip
;               bits 0..7 => format
;                               0 =grey level (halftoned)
;                               1 =grey level (diffused)
;                               2 =colour     (halftoned)
;                               3 =colour     (diffused)
;                               2*X  =halftoned
;                               2*X+1=diffused for strip-type X
;
;               bits 8 set => returned monochrome always
;               all other bits reserved
;
;          R3 strip width in pixels               ;N.B. NOT IN BYTES
;          R4 strip height in scan lines
;          R5 strip width in pixels               ;INCLUDING PADDING, NOT IN BYTES
;>>>>>>>>>>>N.B. R5 IS DEFINED TO BE A MULTIPLE OF 4<<<<<<<<<<<<<<<<<
;          R6 halftone information
;               bits 0..7 => horizontal resolution
;               bits 8..15 => vertical resolution
;                     
;   Exit:  V =1 => R0 ->Error block
;          else,   
;>>>>>>>>>>R1->bit image data to ouput, N.B. could now be different from R1 in<<<<<<<
; This call processes the specified 8BPP bitmap generated by the PDumperDP
; module into a format suitable for printing by the relevant output routine.
;
;------------------------------------------------------------------------------

                                ^ 0
preptype_GreyHalftone           # 1
preptype_GreyDithered           # 1
preptype_ColourHalftone         # 1
preptype_ColourDither           # 1
                                [ fullrgb
preptype_MultiRGBHalftone       # 1
preptype_MultiRGBDither         # 1
preptype_16BitRGBHalftone       # 1
preptype_16BitRGBDither         # 1
preptype_24BitRGBHalftone       # 1
preptype_24BitRGBDither         # 1
                                ]
preptype_Max                    * :INDEX: @

prepflag_OutputInMonochrome     * 1:SHL:8
                                       
prepflag_Allowed                * 2_11111111
preptype_Mask                   * 2_11111111

SWIPDumper_PrepareStrip ROUT
                  
        Push    "R0-R1,R8,LR"
       
        Debug   prepstrip,"(prepstrip) anchor word",R0
        Debug   prepstrip,"            strip at",R1
        Debug   prepstrip,"            format",R2
        Debuga  prepstrip,"            width",R3
        Debuga  prepstrip,", height",R4
        Debuga  prepstrip,", byte width",R5
        Debug   prepstrip,", halftone information",R6

        LDR     R8,=prepflag_Allowed
        BICS    R8,R2,R8                ;Are any invalid bits set within flags
        BLNE    %FT80                   ;Yes, so give an error

        MOVVC   R8,R0                   ;->Pointer to anchor word
        MOVVC   R0,R1                   ;->Strip data
        BLVC    preproutine             ;Despatch to a suitable routine for prep work

        STRVS   R0,[SP]                 ;Balance the stack and then exit
        STRVC   R0,[SP,#4]              ;<<<<AND KEEP NEW STRIP POINTER
        Pull    "R0-R1,R8,PC"
80
        Debug   prepstrip,"(prepstrip) reserved bits set"

        ADRL    R0,ErrorBlock_PDumperReserved
        B       LookupError             ;Convert token to a suitable error 

;..............................................................................           

InvalidateGammaTable
        Push    "R0-R1,LR"
        
        ADRL    R0, RedGammaTable
        MOV     R1, #&FF
        STRB    R1, [R0]
        Pull    "R0-R1,PC"

BuildGammaTable32
        Push    "R0-R11,LR"

        LDR     R2, =BlockType_Palette
        SWI     XPDumper_Find
        BVS     builttable32

        LDR     R3, [R2, #palette_Calibration]
        TEQ     R3, #0
        ADDNE   R3, R2, R3

        Push    "R7,R0"
        MOV     R11, #&FF
        MOV     R0, #&FF
01      MOV     R1, R0, LSL #8
        ORR     R1, R1, R0, LSL #16
        ORR     R1, R1, R0, LSL #24
        SWI     XColourTrans_ConvertDeviceColour

        ADRL    R6, RedGammaTable
        AND     R7, R11, R2, LSR #8
        STRB    R7, [R6, R0]

        ADRL    R6, GreenGammaTable 
        AND     R7, R11, R2, LSR #16
        STRB    R7, [R6, R0]

        ADRL    R6, BlueGammaTable
        AND     R7, R11, R2, LSR #24
        STRB    R7, [R6, R0] 

        SUBS    R0, R0, #1
;version 1.18 - make sure table includes proper 0 correction (eg. for ink density)
        BPL     %BT01

        Pull    "R7,R0"
builttable32
        Pull    "R0-R11,PC"


BuildGammaTable16
        Push    "R0-R11,LR"

        LDR     R2, =BlockType_Palette
        SWI     XPDumper_Find
        BVS     builttable16

        LDR     R3, [R2, #palette_Calibration]
        TEQ     R3, #0
        ADDNE   R3, R2, R3

        Push    "R7,R0"
        MOV     R11, #&FF
        MOV     R0, #&1F
01
        MOV     R4, R0, LSL #3
        ORR     R4, R4, R4, LSR #5      ; convert from 5bit -> 8bit

        MOV     R1, R4, LSL #8          ; make 24 bit rgb value
        ORR     R1, R1, R4, LSL #16
        ORR     R1, R1, R4, LSL #24

        SWI     XColourTrans_ConvertDeviceColour

        ADRL    R6, RedGammaTable
        AND     R7, R11, R2, LSR #8
        AND     R7, R7, #&F8
        MOV     R7, R7, LSR #3
        STRB    R7, [R6, R0]

        ADRL    R6, GreenGammaTable 
        AND     R7, R11, R2, LSR #16
        AND     R7, R7, #&F8
        MOV     R7, R7, LSR #3
        STRB    R7, [R6, R0]

        ADRL    R6, BlueGammaTable
        AND     R7, R11, R2, LSR #24
        AND     R7, R7, #&F8
        MOV     R7, R7, LSR #3
        STRB    R7, [R6, R0] 

        SUBS    R0, R0, #1
;version 1.18 - make sure table includes proper 0 correction
        BPL     %BT01

        Pull    "R7,R0"

builttable16
        Pull    "R0-R11,PC"
 
gamma_correctstrip32
        Push    "R0-R11,LR"

        ; R0 = location of pixel strip
        ; R3 = width of strip
        ; R4 = height of strip

        Push    "R0-R3"
        
        ADR     R3, RedGammaTable
        LDRB    R1, [R3]
        CMP     R1, #&FF
        MOVEQ   R0, R8
        BLEQ    BuildGammaTable32
        Pull    "R0-R3"

        MUL     R5, R3, R4              ; r5 = number pixels to convert
        MOV     R7, #&FF                ; r7 = byte mask for extracting rgb components
        ADR     R8,  RedGammaTable
        ADR     R9,  GreenGammaTable
        ADR     R10, BlueGammaTable

        LDRB    R4,[R9,#0] ; = corrected-green[0] , detects ink-density-correcting palette
        CMP     R4,#0
        ADRNEL  R4,two_ink_correction   ; fixed table, optimised for 62.5% 1-ink, 62.5% 2-ink

        MOV     R14, #&FFFFFF00         ; initialise initial value of last corrected pixel (=white)
        MOV     R1,R14,LSR #8           ; initialise corrected value of last corrected pixel (=white)
        B       %FT01

next_pixel32
        SUBS    R5, R5, #1
        Pull    "R0-R11,PC",EQ,^

01      LDR     R6, [R0], #4
; version 1.18 - stop the optimise which doesn't look-up 0 (black) - may need correction
        MOV     R6, R6, LSL #8
        CMP     R6, #&FFFFFF00
        BEQ     next_pixel32            ; don't gamma correct if pure white

        TEQ     R14, R6                 ; is it the same colour as the last one corrected
        MOVNE   R14, R6
        STREQ   R1, [R0, #-4]           ; if it is there use the last computed colour
        BEQ     next_pixel32

        AND     R11, R7, R6, LSR #8     ; extract red
        LDRB    R1, [R8, R11]           ; look up gamma corrected red

        AND     R11, R7, R6, LSR #16    ; extract green
        LDRB    R2, [R9, R11]           ; look up gamma corrected green

        LDRB    R3, [R10, R6, LSR #24]  ; extract + gamma correct blue

        CMP     R4,#0 ; if R4=0, no ink density correction
        BEQ     %FT09
;additional correction for use of two inks (fixed at 62.5%)
;first, do a sort (swaps remembered in R6), to give R1 <= R2 <= R3
;wish I could make this neater/faster
        MOV     R6,#0
        CMP     R1,R2
        ORRGT   R1,R1,R2,LSL #8
        ANDGT   R2,R1,#255
        MOVGT   R1,R1,LSR #8
        ORRGT   R6,R6,#1        ;flags 1st r1,r2 swap
        CMP     R2,R3
        ORRGT   R2,R2,R3,LSL #8
        ANDGT   R3,R2,#255
        MOVGT   R2,R2,LSR #8
        ORRGT   R6,R6,#2        ;flags r2,r3 swap
        CMP     R1,R2
        ORRGT   R1,R1,R2,LSL #8
        ANDGT   R2,R1,#255
        MOVGT   R1,R1,LSR #8
        ORRGT   R6,R6,#4        ;flags 2nd r1,r2 swap
;now adjust values - call initial R1,R2,R3 values u,v,w (w stays the same)
        SUB     R1,R1,R2        ;R1 := u - v
        SUB     R2,R3,R2        ;R2 := w - v (always +ve)
        LDRB    R2,[R4,R2]      ;look-up 2-ink correction
        SUB     R2,R3,R2        ;R2 := w - corrected(w - v) = corrected_v
        ADD     R1,R1,R2        ;R1 := u - v + corrected_v = corrected_u
;now we have to undo the sort, to move back to proper r,g,b
        TST     R6,#4           ;check for 2nd r1,r2 swap
        ORRNE   R1,R1,R2,LSL #8
        ANDNE   R2,R1,#255
        MOVNE   R1,R1,LSR #8
        TST     R6,#2           ;check for r2,r3 swap
        ORRNE   R2,R2,R3,LSL #8
        ANDNE   R3,R2,#255
        MOVNE   R2,R2,LSR #8
        TST     R6,#1           ;check for 1st r1,r2 swap
        ORRNE   R1,R1,R2,LSL #8
        ANDNE   R2,R1,#255
        MOVNE   R1,R1,LSR #8
;done adjustment!
09
        ORR     R1, R1, R2, LSL #8      ; combine components to give colour number
        ORR     R1, R1, R3, LSL #16

        STR     R1, [R0, #-4]          ; store corrected colour

        B       next_pixel32

; *** MJS bug fix: this code was swapping pairs of pixels horizontally, except
;     where pixels are white or black! This is fault MED-03675 on database.
;     New code deals with 2 pixels at once, to allow valid word-wise load/store
;     (hope number of pixels in row is even...)
;     Note: we skip pairs of black or white for speed: individual black or
;     white will be 'corrected' to same value, via table

gamma_correctstrip16
        Push    "R0-R11,LR"

        Push    "R0-R3"
        
        ADR     R3, RedGammaTable
        LDRB    R1, [R3]
        CMP     R1, #&FF
        MOVEQ   R0, R8
        BLEQ    BuildGammaTable16
        Pull    "R0-R3"

        MUL     R5, R4, R3
        MOV     R6, #&1F               ; R6 = mask for 5 bit colour
        ADR     R8, RedGammaTable
        ADR     R9, GreenGammaTable
        ADR     R10, BlueGammaTable

        LDRB    R11,[R9,#0]  ; = corrected-green[0] , detects ink-density-correcting palette

        MOV     R7, #&7F00
        ORR     R7, R7, #&FF           
        ORR     R7, R7, R7, LSL #16    ; R7 = &7FFF7FFF = white,white

        B       %FT01

next_pixel16
        SUBS    R5, R5, #2             ; next 2 pixels
        Pull    "R0-R11,PC",LE,^

01      LDR     R14, [R0], #4          ; load 2 pixels

; version 1.18 - stop the optimise which doesn't look-up 0 (black) - may need correction
        CMP     R14,R7                 ; are they white,white ?
        BEQ     next_pixel16

        AND     R3, R6, R14, LSR #10     ; extract blue 1
        AND     R2, R6, R14, LSR #5      ; extract green 1
        AND     R1, R6, R14              ; extract red 1
        LDRB    R1, [R8, R1]             ; gamma correct red
        LDRB    R2, [R9, R2]             ; gamma correct green
        LDRB    R3, [R10, R3]            ; gamma correct blue
        CMP     R11,#0
        BEQ     %FT02
;ink density correction - hell, 32k mode is going to be naff anyway (range 0..31, then reduce ink
;densities ... oh dear!), so do something cheap, ie. just crunch all components by another 62.5% factor
        ADD     R1,R1,R1,LSL #2 ;*5
        MOV     R1,R1,LSR #3    ;*5/8 (62.5%)
        ADD     R1,R1,#12       ;+3/8 (of 31)
        ADD     R2,R2,R2,LSL #2
        MOV     R2,R2,LSR #3
        ADD     R2,R2,#12
        ADD     R3,R3,R3,LSL #2
        MOV     R3,R3,LSR #3
        ADD     R3,R3,#12
02
        ORR     R1, R1, R2, LSL #5
        ORR     R1, R1, R3, LSL #10
        MOV     R4, R1                   ; remember corrected 1

        AND     R3, R6, R14, LSR #10+16  ; extract blue 2
        AND     R2, R6, R14, LSR #5+16   ; extract green 2
        AND     R1, R6, R14, LSR #16     ; extract red 2
        LDRB    R1, [R8, R1]             ; gamma correct red
        LDRB    R2, [R9, R2]             ; gamma correct green
        LDRB    R3, [R10, R3]            ; gamma correct blue
        CMP     R11,#0
        BEQ     %FT03
        ADD     R1,R1,R1,LSL #2 ;*5
        MOV     R1,R1,LSR #3    ;*5/8 (62.5%)
        ADD     R1,R1,#12       ;+3/8 (of 31)
        ADD     R2,R2,R2,LSL #2
        MOV     R2,R2,LSR #3
        ADD     R2,R2,#12
        ADD     R3,R3,R3,LSL #2
        MOV     R3,R3,LSR #3
        ADD     R3,R3,#12
03
        ORR     R1, R1, R2, LSL #5
        ORR     R1, R1, R3, LSL #10
        ORR     R4, R4, R1, LSL #16      ; corrected 1 and 2

        STR     R4, [R0, #-4]            ; store corrected 1 and 2
        B       next_pixel16

preproutine
        AND     R1,R2,#preptype_Mask    ;Extract suitable bits for execution

        Debug   prepstrip,"(prepstrip) strip at",R0
        Debuga  prepstrip,"(prepstrip) output type",R1
        Debug   prepstrip,", flags word",R2

        [ {TRUE}
        Push    "R14"
        CMP     R1, #6                  ; Is it a 16bpp output
        CMPNE   R1, #7                  ; or is it a 32bpp output
        BLEQ    gamma_correctstrip16      ; then gamma correct output strip
        CMP     R1, #8
        CMPNE   R1, #9
        BLEQ    gamma_correctstrip32
        Pull    "R14"
        ]

        CMP     R1,#preptype_Max        ;Is it within a sensible range?
        ADDCC   PC,PC,R1,LSL #2         ;...yup so despatch
        B       %FT99

        B       HalftoneGreySprite
        B       DitherGreySprite
        B       HalftoneColourSprite
        B       DitherColourSprite
        [ fullrgb
        B       HalftoneMultiRGB
        B       DitherMultiRGB
        B       Halftone16BitRGB
        B       Dither16BitRGB
        B       Halftone24BitRGB
        B       Dither24BitRGB
        ]
99
        Debug   prepstrip,"(prepstrip) kabooom!"

        ADR     R0,ErrorBlock_PDumperBadOutputType
        B       LookupError             ;Return a deep and meaningful error

        MakeInternatErrorBlock PDumperBadOutputType,,BadType

;------------------------------------------------------------------------------
; 
; findblock / findblockR8
;                       
; Find the block based on the tag in R1, either using the anchor point in R0
; or R8.  The routine can be made to the next block by moving the returned
; pointer into the specified anchor word pointer and then calling the
; routines again.
; 
; in    R0 ->anchor word (if 'findblock')
;       R1 tag of block to find
;       R8 ->anchor word (if 'findblockR8')
; 
; out   V =1 => R0 ->error block
;       else,   R1 ->block located

findblockR8 ROUT

        Push    "R0,LR"

        Debuga  findblock,"(findblockR8) Anchor word",R8
        Debug   findblock,", tag",R1
                          
        MOV     R0,R8           ;Move anchor word to suitable register
        BL      findblock       ;Attempt to find the block
        STRVS   R0,[SP]

        DebugE  findblock,"(findblockR8) Gave error"
        Debug   findblock,"(findblockR8) Pointer to strip block",R1
                                
        Pull    "R0,PC"

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 

findblock ROUT

        Push    "R0,R2,LR"

        Debuga  findblock,"(findblock) Anchor word",R0
        Debug   findblock,", tag",R1

        MOV     R2,R1           ;Tag for the block to be found
        SWI     XPDumper_Find
        MOVVC   R1,R2           ;Resolve pointer to block if it has been found
        STRVS   R0,[SP]         ;..or maybe even the error pointer

        DebugE  findblock,"(findblock) Gave error"
        Debug   findblock,"(findblock) Pointer to strip block",R1
                                
        Pull    "R0,R2,PC"     

;------------------------------------------------------------------------------
;
; HalftoneGreySprite implementation
;
;   Entry: R0 ->strip
;          R3 dump width
;          R4 number of rows
;          R5 row width in bytes
;          R6 x halftone width in bits 0..7 and Y in bits 8..15
;          R8 ->anchor word for pdumper
;                     
;   Exit:  V =1 => R0 ->Error block
;
; Halftone the specified sprite using the data stored within the palette
; file.
;
;------------------------------------------------------------------------------
          
HalftoneGreySprite ROUT

        Push    "R0-R11,LR"

        LDR     R1,=BlockType_Palette   ;Tag for the palette file
        BL      findblockR8          
        BVS     halftonegrey_return     ;If unable to locate the block then return

        ADR     R10,KeyHalfInfo            ;Needed later
        LDR     R11,FirstStrip
        TEQ     R11,#0
        BEQ     halftonegrey_start         ;Initialisation has been done
        MOV     R11,#0
        STR     R11,FirstStrip

        Debuga  prepstrip,"(halftone grey) Strip at",R0
        Debuga  prepstrip,", width",R3
        Debuga  prepstrip,", height",R4
        Debuga  prepstrip,", byte width",R5
        Debuga  prepstrip,", halftone info",R6
        Debug   prepstrip,", palette block at",R1
;Need to call Do_HalftoneGreySprite with a bit of register rearrangement...
;R0=R5 (columncount byte width used, halftoning missing bits doesn't matter)
;R1=R4 (rowcount)
;R2,R3=x,y
;R4,R6=table,halfsize
;R7,R8=xstart,ystart
;R10=R0 (sprite)
;R12,KeyHalfInfo=Small/Large halftone info for each colour...depends on R6
;Between strips, information is kept in KeyHalfInfo, like the colour rendering
        AND     R6,R6,#255           ;Get halftoning resolution
        CMP     R6,#4
        ADDLS   R8,R1,#palette_Small    ;Use small halftone if <=4
        ADDHI   R8,R1,#palette_Large    ;Otherwise large halftones
        MOV     R14,#0
;Clear out the halftone table
        MOV     R9,#halftone_workspace
00
        STR     R14,[R10],#4
        SUBS    R9,R9,#4
        BNE     %BT00
;So now x,y,xstart,ystart are Ok, Need also to set halftone_table and halftone_halfsize
        ADR     R10,KeyHalfInfo
        LDR     R14,[R8]                 ;Pick up offset to halftone table
        ADD     R14,R1,R14               ;Add the file start
        LDR     R9,[R14],#4              ;Load the size
        STR     R9,[R10,#halftone_halfsize]
        ADD     R9,R14,R9,LSL #2         ;Offset to the actual table
        STR     R9,[R10,#halftone_table]
;And now whole block is ready for load...
halftonegrey_start
        MOV     R1,R4
        LDMIA   R10,{R2,R3,R4,R6,R7,R8}
        MOV     R10,R0
        MOV     R0,R5
        CLRV                              ;There won't be any errors (honest guv!)
        BL      Do_HalftoneGreySprite
        ADR     R10,KeyHalfInfo
        STMIA   R10,{R2,R3,R4,R6,R7,R8}   ;Keep info for next sweep                           
halftonegrey_return
        DebugE  prepstrip,"(halftone grey) errored"
        Debug   prepstrip,"(halftone grey) exiting"

        STRVS   R0,[SP]                 ;Return any errors generated
        Pull    "R0-R11,PC"

;------------------------------------------------------------------------------
;
; DitherGreySprite implementation
;
;   Entry: R0 ->strip
;          R3 dump width (bytes or bits)
;          R4 dump height (rows)
;          R5 row width in bytes ( >=R3)
;          R6 x halftone width in bits 0..7 and Y in bits 8..15
;          R8 ->anchor word
;                     
;   Exit:  V =1 => R0 ->Error block
;
; Error diffuse a grey sprite using palette data.
;                     
;------------------------------------------------------------------------------
; Entry for Do_DitherGreySprite is
; R0=Width (***should be dump width, not row width??***) use R5 for the moment
; R1=Height (=R4)
; R2=abefore (kept between strips)
; R3=anow (kept between strips)
; (R5=before)
; R12,errorbuffer=allocated buffer for errors (initially blank), size=Width+2


DitherGreySprite ROUT

        Push    "R0-R11,LR"

        Debug   prepstrip,"(dither grey) Entered"

        LDR     R1,=BlockType_ErrorDiffuse
        BL      findblockR8             ;Attempt to find diffusion block
        BVC     %FT10                   ;We found it so no need to set one up

        Debug   prepstrip,"(dither grey) Allocate diffuse buffer"

        Push    "R3,R4"
        MOV     R0,R8
        ADD     R3,R5,#2                ;Size of block with two blanks at ends
        MOV     R3,R3,LSL#2             ;And need words (error may be +/-)
        LDR     R4,=BlockType_ErrorDiffuse
        SWI     XPDumper_Claim          ;Attempt to claim the block required
        Pull    "R3,R4"                 ;...restore R3,R4
        BVS     dithergrey_return

        Debug   prepstrip,"(dither grey) Diffuse buffer at",R2

        MOV     R1,#1                   ;Reset the random seed
        STR     R1,RandomSeed
        STR     R2,errorbuffer          ;Keep the error buffer for later
        ADD     R3,R5,#2                ;Temporary copy of line width used when reseting
        MOV     R1,#0                   ;Reset the rest of the buffer will nulls
05
        STR     R1,[R2],#4              ;Reset the pixel value
        SUBS    R3,R3,#1
        BNE     %BT05                   ;Loop back until all reset

        MOV   R2,#0                ;clear abefore/anow for the first row
        STR   R2,KeyDiffuse        ;before is dealt with by code anyway at line ends
        STR   R2,KeyDiffuse+4
10
        LDR     R10,[SP]                ;Restore original strip pointer
        MOV     R0,R5
        MOV     R1,R4
        LDR     R2,KeyDiffuse
        LDR     R3,KeyDiffuse+4

        CLRV                            ;Should be no errors
        BL      Do_DitherGreySprite

        STR     R2,KeyDiffuse           ;Keep for next time to glue lines together
        STR     R3,KeyDiffuse+4

        Debuga  prepstrip,"(dither grey) Strip at",R0
        Debuga  prepstrip,", width",R3
        Debuga  prepstrip,", height",R4
        Debuga  prepstrip,", byte width",R5
        Debug   prepstrip,", halftone info",R6 
        Debug   prepstrip,"(dither grey) Diffuse buffer at",R8

dithergrey_return
        DebugE  prepstrip,"(dither grey) errored"
        Debug   prepstrip,"(dither grey) exiting"

        STRVS   R0,[SP]                 ;Store suitable error pointer if required
        Pull    "R0-R11,PC"

;------------------------------------------------------------------------------
;
; HalftoneColourSprite implementation
;
;   Entry: R0 ->strip
;          R3 dump width (bytes or bits)          ***I.e. pixels for fullrgb
;          R4 number of rows
;          R5 row width in bytes ( >= R3 )
;          R6 x halftone width in bits 0..7 and Y in bits 8..15
;          R8 ->anchor word for pdumper
;          
;   Exit:  V =1 => R0 ->Error block
;
; Recolour a 256 colour sprite according to the specified pattern table.
;
;------------------------------------------------------------------------------
            [ fullrgb
;In much the same way as for the error diffuser (see below)
;It is safe to write the result into the 'first' of the various buffers

HalftoneMultiRGB ROUT
        Push    "R0-R11,LR"
        MOV     R1,#0
        STR     R1,KCMYTable
        MOV     R10,#1
        LDR     R1,[R0,#4]
        STR     R1,greenbuffer
        LDR     R1,[R0,#8]
        STR     R1,bluebuffer
        LDR     R0,[R0]
        STR     R0,redbuffer
        STR     R0,[SP]                     ;See note below...
        B       HalftoneColourSprite2
Halftone16BitRGB ROUT
        Push    "R0-R11,LR"
        MOV     R1,#1
        STR     R1,KCMYTable
        MOV     R10,#2
        STR     R0,redbuffer
        B       HalftoneColourSprite2
Halftone24BitRGB ROUT
        Push    "R0-R11,LR"
        MOV     R1,#0
        STR     R1,KCMYTable
        MOV     R10,#4
        STR     R0,redbuffer
        ADD     R1,R0,#1
        STR     R1,greenbuffer
        ADD     R1,R0,#2
        STR     R1,bluebuffer
        B       HalftoneColourSprite2
            ]

HalftoneColourSprite ROUT

        Push    "R0-R11,LR"

        [ fullrgb
        MOV     R10,#0                  ;Get KCMYTable from palette file
HalftoneColourSprite2
        STR     R10,pixsep              ;Will be non-zero for real sprites
        ]

        LDR     R1,=BlockType_Palette   ;Tag for the palette block
        BL      findblockR8
        BVS     halftonecolour_return   ;If unable to find the palette block then exit

        LDR     R11,FirstStrip
        TEQ     R11,#0
        BEQ     halftonecolour_start         ;Initialisation has been done
        MOV     R11,#0
        STR     R11,FirstStrip

        [ fullrgb
        TEQ     R10,#0                         ;See if this is 8-bit sprite
        LDREQ     R11,[R1,#palette_PalInverse] ;Get the inverse table
        ADDEQ     R11,R1,R11                   ;Pointer to Key inverses
        STREQ     R11,KCMYTable                ;Keep it for the halftoner
        |
        LDR     R11,[R1,#palette_PalInverse] ;Get the inverse table
        ADD     R11,R1,R11                   ;Pointer to Key inverses
        STR     R11,KCMYTable                ;Keep it for the halftoner
        ]

        LDR     R11,[R1,#palette_Removal]    ;Removal and Overlap flag
        STR     R11,Remove                   ;We need these both

        Debuga  prepstrip,"(halftone colour) Strip at",R0
        Debuga  prepstrip,", width",R3
        Debuga  prepstrip,", height",R4
        Debuga  prepstrip,", byte width",R5
        Debuga  prepstrip,", halftone info",R6
        Debug   prepstrip,", palette block at",R1
;Need to call Do_HalftoneColourSprite with a bit of register rearrangement...
;R0=R5 (columncount byte width used, halftoning missing bits doesn't matter)
;R1=R4 (rowcount)
;R10=R0 (sprite)
;R12,KCMYTable=address of Inverse table in palette file
;R12,XXXHalfInfo=Small/Large halftone info for each colour...depends on R6
        AND     R6,R6,#255           ;Get halftoning resolution
        CMP     R6,#4
        ADDLS   R8,R1,#palette_Small+4  ;Use small halftone if <=4 (preceeded by Grey halftones)
        ADDHI   R8,R1,#palette_Large+4  ;Otherwise large halftones
;Order of tables is Grey,Key,Cyan,Magenta,Yellow i.e. same as for internal layout (of course)
        MOV     R14,#0
;Clear out the halftone tables, this should be dependant on 'first strip' flag
        ADR     R10,KeyHalfInfo
        MOV     R9,#halftone_workspace*4
00
        STR     R14,[R10],#4
        SUBS    R9,R9,#4
        BNE     %BT00
;So now x,y,xstart,ystart are Ok, Need also to set halftone_table and halftone_halfsize
        ADR     R10,KeyHalfInfo
        MOV     R7,#4
10
        LDR     R14,[R8],#4              ;Pick up offset to halftone table
        ADD     R14,R1,R14               ;Add the file start
        LDR     R9,[R14],#4              ;Load the size
        STR     R9,[R10,#halftone_halfsize]
        ADD     R9,R14,R9,LSL #2         ;Offset to the actual table
        STR     R9,[R10,#halftone_table]
        ADD     R10,R10,#halftone_workspace
        SUBS    R7,R7,#1                  ;Repeat for all four colours
        BNE     %BT10
;This is all that's required, except on the first strip
;WARNING: (IMPLICIT) USE OF R12 OFFSETS RESTRICTS USE TO ONE DUMPER AT A TIME...
;SHOULD CHANGE R12 TO A LOCAL ONE HUNG OFF THE ANCHOR
halftonecolour_start
        MOV     R10,R0
        MOV     R1,R4
        MOV     R0,R5
        CLRV                              ;There won't be any errors (honest guv!)
        BL      Do_HalftoneColourSprite

halftonecolour_return
        DebugE  prepstrip,"(halftone colour) errored"
        Debug   prepstrip,"(halftone colour) exiting"

        STRVS   R0,[SP]                 ;Store the error pointer (if error condition)
        Pull    "R0-R11,PC"

;------------------------------------------------------------------------------
;
; DitherColourSprite implementation
;
;   Entry: R0 ->strip
;          R3 dump width (bytes or bits)         ***I.e. Pixels for FullRGB
;          R4 dump height (rows)
;          R5 row width in bytes ( >=R3)
;          R6 x halftone width in bits 0..7 and Y in bits 8..15
;          R8 ->anchor word
;                     
;   Exit:  V =1 => R0 ->Error block
;
; Error diffuse a colour sprite using palette data.
;
;------------------------------------------------------------------------------
; See DitherGreySprite for info on register usage
; Things are multiplied up by a factor of 4 (e.g. error buffer size, and abefore/anows kept)
             [ fullrgb
;for these new ones, we have to set up the buffer pointers
;also some part of the image needs choosing for the output buffer
;since the input is at least 2x the size of the output, it is safe to use the
;first of the pointers as the output buffer, no overlaps occur (honest!)
DitherMultiRGB ROUT
        Push    "R0-R11,LR"
        MOV     R1,#0
        STR     R1,KCMYTable
        MOV     R10,#1
        LDR     R1,[R0,#4]
        STR     R1,greenbuffer
        LDR     R1,[R0,#8]
        STR     R1,bluebuffer
        LDR     R0,[R0]
        STR     R0,redbuffer
        STR     R0,[SP]                ;System picks this up later...
        B       DitherColourSprite2    ;I.e. this returns output buffer address
Dither16BitRGB ROUT
        Push    "R0-R11,LR"
        MOV     R1,#1
        STR     R1,KCMYTable
        MOV     R10,#2
        STR     R0,redbuffer
        B       DitherColourSprite2
Dither24BitRGB ROUT
        Push    "R0-R11,LR"
        MOV     R1,#0
        STR     R1,KCMYTable
        MOV     R10,#4
        STR     R0,redbuffer
        ADD     R1,R0,#1
        STR     R1,greenbuffer
        ADD     R1,R0,#2
        STR     R1,bluebuffer
        B       DitherColourSprite2
             ]

DitherColourSprite ROUT
         
        Push    "R0-R11,LR"

        [ fullrgb
        MOV     R10,#0
DitherColourSprite2
        STR     R10,pixsep              ;Will be non-zero for real sprites
        ]

        LDR     R1,=BlockType_Palette
        BL      findblockR8             ;Locate the requested block
        BVS     dithercolour_return     ;Return if it errors.

        [ fullrgb
        TEQ     R10,#0                         ;See if this is 8-bit sprite
        LDREQ     R11,[R1,#palette_PalInverse] ;Get the inverse table
        ADDEQ     R11,R1,R11                   ;Pointer to Key inverses
        STREQ     R11,KCMYTable                ;Keep it for the diffuser
        LDRNE     R11,[R1,#palette_Removal]    ;Removal and Overlap flag
        STRNE     R11,Remove                   ;We need Removal for full colour
        |
        LDR     R11,[R1,#palette_PalInverse] ;Get the inverse table
        ADD     R11,R1,R11                   ;Pointer to Key inverses
        STR     R11,KCMYTable                ;Keep it for the diffuser
        ]
        
        MOV     R0,R8
        LDR     R1,=BlockType_ErrorDiffuse
        BL      findblock               ;Attempt to locate the error diffusion block
        BVC     %FT10                   ;Found it Ok
                  
        Push    "R3,R4"
        MOV     R0,R8                   ;Fix to ensure that the anchor word is correctly quoted!
        ADD     R3,R5,#2                ;Size and two blanks
        MOV     R3,R3,LSL#4             ;Needs words and 4 inks
        LDR     R4,=BlockType_ErrorDiffuse
        SWI     XPDumper_Claim          ;Attempt to claim the block (assumes R0 ->anchor word)
        Pull    "R3,R4"                 ;Preserve R3,R4 they are kinda important
        BVS     dithercolour_return     ;..exit if it fails to claim

        MOV     R1,#1                   ;Reset the random seed
        STR     R1,RandomSeed
        STR     R2,errorbuffer          ;Keep the error buffer for later
        MOV     R1,#0                   ;Reset scan line information within buffer
        ADD     R3,R5,#2                ;Temporary copy of line width used when reseting
05
        STR     R1,[R2],#4              ;Reset pixel entries to contain zero
        STR     R1,[R2],#4
        STR     R1,[R2],#4
        STR     R1,[R2],#4
        SUBS    R3,R3,#1           
        BNE     %BT05                   ;And loop until they have all been reset

        MOV   R2,#0                ;clear abefore/anow for each colour
        STR   R2,KeyDiffuse        ;before is dealt with by code anyway at line ends
        STR   R2,KeyDiffuse+4
        STR   R2,CyanDiffuse
        STR   R2,CyanDiffuse+4
        STR   R2,MagentaDiffuse
        STR   R2,MagentaDiffuse+4
        STR   R2,YellowDiffuse
        STR   R2,YellowDiffuse+4
10
        Debuga  prepstrip,"(dither colour) Strip at",R0
        Debuga  prepstrip,", width",R3
        Debuga  prepstrip,", height",R4
        Debuga  prepstrip,", byte width",R5
        Debuga  prepstrip,", halftone info",R6
        Debug   prepstrip,"Inverse palette at",R11
                   
        LDR     R10,[SP]                ;Restore original strip pointer
        MOV     R0,R5
        MOV     R1,R4
        CLRV                            ;Should be no errors
        BL      Do_DitherColourSprite

dithercolour_return
        DebugE  prepstrip,"(dither colour) errored"
        Debug   prepstrip,"(dither colour) exiting"

        STRVS   R0,[SP]                 ;Store the error pointer if needed
        Pull    "R0-R11,PC"


;2-ink correction table assuming 62.5% 1-ink (0..159 in) and 62.5% 2-ink
two_ink_correction
  DCB   0,  1,  2,  3,  3,  4,  5,  6,  7,  7,  8,  9, 10, 11, 12, 12
  DCB  13, 14, 15, 16, 16, 17, 18, 19, 20, 20, 21, 22, 23, 24, 24, 25
  DCB  26, 27, 27, 28, 29, 30, 30, 31, 32, 33, 33, 34, 35, 35, 36, 37
  DCB  38, 38, 39, 40, 40, 41, 42, 43, 43, 44, 45, 45, 46, 47, 47, 48
  DCB  49, 49, 50, 51, 51, 52, 53, 53, 54, 55, 55, 56, 56, 57, 58, 58
  DCB  59, 60, 60, 61, 61, 62, 63, 63, 64, 65, 65, 66, 66, 67, 67, 68
  DCB  69, 69, 70, 70, 71, 72, 72, 73, 73, 74, 74, 75, 75, 76, 76, 77
  DCB  77, 78, 79, 79, 80, 80, 81, 81, 82, 82, 83, 83, 84, 84, 85, 85
  DCB  86, 86, 87, 87, 88, 88, 88, 89, 89, 90, 90, 91, 91, 92, 92, 93
  DCB  93, 94, 94, 94, 95, 95, 96, 96, 96, 97, 97, 98, 98, 99, 99, 99
  DCB  99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99
  DCB  99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99
  DCB  99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99
  DCB  99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99
  DCB  99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99
  DCB  99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99

        END
