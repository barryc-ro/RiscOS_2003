#! /usr/local/bin/perl
# Version number: $Revision$

my($dir,$script)=$0=~/^(.*)\.([^.]+)$/;
my $doswis=0;
my $infile=shift @ARGV;
if($infile eq "-swi") {
  $doswis=1;
  $infile=shift @ARGV;
}
elsif($infile eq "/^\-.*/") {
  die("Unrecognised option: '$infile'\n");
}
my $outfile=shift @ARGV;
die("Usage: $script [-swi] <infile> <outfile>\n") if @ARGV || !defined $outfile;

my $SYMBOL='@';
my $TOKEN='[a-zA-Z_]\w+';
my $NUMBER='(?:-?(?:\&|0x)?\&[\da-zA-Z]+|-?\d+)';
my $STRING='"[^\"]*"';
my $BINOP="(?:(?:(?:\\:SH[LR]\\:)|(?:\\<\\<)|(?:\\>\\>)|(?:\\+)|(?:\\-)|(?:\\*)))";
my $OPTIONALOP="(?:\\s\*($BINOP)\\s\*($NUMBER|$TOKEN))\?";

processfile($infile, $outfile);

sub processfile {
  my($in, $out)=@_;
  my $tmp=$out;
  $tmp=~s/\.[^\.]*\Z/\.!tmp/;
  my $prefix="";
  my $current=0;
  my $do_hex=0;
  my $swiclass="";
  my $swibasesym="";
  local *F;
  open(IN, "<$in") || die("Could not open file '$in'.\n");
  open(OUT, ">$tmp") || die("Could not open file '$tmp'.\n");
  my $define=uc "$out.h";
  $define=~s/\A\<.*\>\.//i;
  $define=~s/\.H\././g;
  $define=~s/[^\w]/_/g;
  print OUT <<"END";
/* Created by Hdr2H.  Do not edit.*/
#ifndef $define
#define $define

#pragma force_top_level
#pragma include_only_once

END
  while(<IN>) {
    s/\;.*//;
    next unless /\S/;
    s/\s+$//;
    s/([\dA-Fa-f])(\<\<)(\d)/\1 \2 \3/g;	# Insert spaces in 1<<2 (--> 1 << 2)
    s/([\dA-Fa-f])(\>\>)(\d)/\1 \2 \3/g;        # As above, for >>
    s/(\:SH[RL]\:)/ \1 /g;			# Spaces around :SHR: and :SHL:
    s/\:INDEX\:\s*\@/\@/g;
    if(/^\s+SUBT\s+/) {         # Sub-Title
      next;
    } elsif(/^\s+TTL\s+/) {	# Title
      next;
    } elsif(/^\s+MACRO(\s+|$)/) {	# Skip macro definitions
      while (<IN>) {
        if(/^\s*MEND(\s|$)/) {
          last;
        }
      }
      next;
    } elsif(/\AOldOpt\s+SETA/) { # Assembler specific thing
      next;
    } elsif(/\A\s+OPT\s+/) {     # Assembler specific thing
      next;
    } elsif(/\A\s+[\!\|\[\]](\s|$)/) { 	# Assertions and macroey things
      next;
    } elsif(/\A\s+AddSWI\s+($TOKEN)/) {     # SWI number declaration
      my $swiname=$1;
      if ($doswis && $swiclass) {
        my $swiname = $swiclass . "_" . $swiname;
        printf(OUT "#ifndef $swiname\n#define %-40s (%s + 0x%02x)\n#endif\n", $swiname, $swibasesym, $current);
      }
      $current+=1;
      next;
    } elsif(/\A\s*SWIClass\s+SETS\s+($STRING)/) {     # Hdr:RISCOS specific thing
      $swiclass=substr($1, 1, length($1)-2);
      $swibasesym="";
      next;
    } elsif(/\A\s*SWIClass\s+SETS\s+($TOKEN)/) {     # Hdr:RISCOS specific thing
      $swibasesym="";
      next;
    } elsif(/\A\s*SWIClass\s+.*/) {
      next;
    } elsif(/\A($TOKEN)\s+[RF]N\s+/i) { # Register number alias
      next;
    } elsif(/\A\s+[AV]RegI?\s+/) { # MPEG headers
      next;
    } elsif(/\A($TOKEN)\s+([\*\#]|EQU)\s+\(?($NUMBER|$TOKEN|$SYMBOL)(?:$OPTIONALOP)\)?/) {
      my($define, $type, $value, $shiftop, $places)=($1, $2, $3, $4, $5);
      my $hexconst;
      $value=~s/^\&/0x/;
      $places=~s/^\&/0x/;
      if (substr($value,0,2) eq "0x") {
        $value=oct($value);
        $hexconst=1;
      }
      if ($value eq $SYMBOL) {
        $value = $current;
      }
      elsif ($type ne '#') {
        $swibasesym="";
      }

      if($type eq '*' || $type eq 'EQU') {
        printf(OUT "#define %-40s (", $define);
        if ($swibasesym) {
          printf(OUT "((%s)+(0x%02x))", $swibasesym, $value);
        }
        else {
          if($hexconst) {
            printf(OUT "0x%x", $value);
          }
          else {
            printf(OUT "%s", $value);
          }
        }
        if ($shiftop) {
          printf(OUT " %s %s)\n", &binopconv($shiftop), $places);
        }
        else {
          printf(OUT ")\n");
        }
      } else {
        my $num;
        if($value!~/\A$NUMBER\Z/) {
          die("$file:$.: Bad space definition: '$value'\n");
        }
        if ($swibasesym) {
          if($do_hex) {
           printf(OUT "#define %-40s ((%s) + 0x%x)\n", $define, $swibasesym, $current);
          } else {
            printf(OUT "#define %-40s ((%s) + %d)\n", $define, $swibasesym, $current);
          }
        } else {
          if($do_hex) {
           printf(OUT "#define %-40s (0x%x)\n", $define, $current);
          } else {
            printf(OUT "#define %-40s (%d)\n", $define, $current);
          };
        }
        $value=~s/\&/0x/;
        $current+=eval($value);
      };
      next;
    } elsif(/^\s+\^\s+($NUMBER)\s*$/) {
      my $value=$1;
      $prefix="";
      $do_hex=($value=~s/\&/0x/);
      $current=eval($value);
      $swibasesym="";
      next;
    } elsif(/^\s+\^\s+($TOKEN)\s*$/) {
      $swibasesym=$1;
      $current=0;
    } elsif(/\A\s+GBL[LSA]\s+$TOKEN\s*\Z/) { # We can ignore these
      next;
    } elsif(/\A($TOKEN)\s+SETS\s+($STRING|$TOKEN)/) {
      my ($define, $value)=($1, $2);
      printf(OUT "#define %-40s %s\n", $define, $value);
    } elsif(/\A($TOKEN)\s+SET[AL]\s+/) {
      next;
    } elsif(/\A\s+ASSERT\s+/) {
      # Ignore asserts - we assume the assembler deals with them.
      next;
    } elsif(/\A\s+AddError2?\s+($TOKEN)\s*,\s*($STRING)\s*(?:,\s*($NUMBER|$TOKEN)\s*)?\Z/) {
      my($define, $msg, $value)=($1, $2, $3);
      if(defined($value)) {
        printf(OUT "#define %-40s %s\n", "ErrorNumber_$define", $value);
      } else {
        if($do_hex) {
          printf(OUT "#define %-40s 0x%x\n", "ErrorNumber_$define", $current);
        } else {
          printf(OUT "#define %-40s %d\n", "ErrorNumber_$define", $current);
        };
        $current+=1;
      };
      printf(OUT "#define %-40s %s\n", "ErrorString_$define", $msg);
    } elsif(/^\s+END\s*$/) {
      next;
    } else {
      warn("$file:$.: Unrecognised line: $_");
    }
  };
  close(IN);
  print OUT "#endif\n";
  close(OUT);
  unlink($out);
  rename($tmp, $out)||die("Could not rename '$tmp' to '$out'\n");
};

sub binopconv {
  my $op=$_[0];
  if (/\:([A-Z]{3})\:/) {
    if (/SHL/) {
      return "<<";
    }
    elsif (/SHR/) {
      return ">>";
    }
    else {
      die("Unknown :shift: operator '$op'\n");
    }
  }

  return $op;
};


# Local Variables:
# mode: perl
# End:
