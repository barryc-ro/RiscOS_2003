#! /usr/local/bin/perl
#
# $Id$
#
#############################################################################
#
# This script filters the module database file to contain only those components
# required by a particular product.  Do NOT commit the filtered output to CVS -
# or all the non-included components will be lost!
#
#
# Usage: $thisfile FullPathOfComponentFile
#
# stdin = ModuleDB source file, stdout = ModuleDB output file, stdin != stdout
#

my $script = $0;
$script  =~ s/^.*[\/:]//;
$version_file     = "VersionNum";
$usage = "Usage: $script ".
  "<components file>\n\n" .
  "Filters the standard input to generate a cut-down module database containing\n".
  "only those components which are present in a product.\n";

#############################################################################

my $component_file = shift @ARGV;
die($usage) unless $component_file;

my %components = &read_file($component_file);

while (<>) {
  if (/^\W/) {
    print;
    next;
  }
  if (/^(\S+)\s/) {
    print if ($components{$1});
    next;
  }
  
  die("Internal error: $_\n");
}

exit 0;

#############################################################################
# Read the components file to find the required module database entries
#
sub read_file {
  my $file = $_[0];
  my %result;
  
  open(FILE,"<$file") || &failed("cannot open $file");
  
  while (<FILE>) {
    if (/^(\w\S+)\s/) {
      $result{$1} = 1;
    }
  }

  return %result;
}

#############################################################################
# Wrap things up neatly.
#
sub failed {
  printf(STDERR "$script: $_[0] failed: $!\n");
  exit 1;
};

