<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD><TITLE>HierProf</TITLE></HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<H1 ALIGN=CENTER>Dr Smith's C Development Toolkit 1.55 (15 Jun 1998)</H1>
<H2>Introduction</H2>
<P>
The two main parts of the toolkit are HierProf (for detailed time-profiling) and MemCheck (for finding illegal memory accesses).
<P>
In addition, the directory <TT><B>Utilities</B></TT> contains some command-line tools which may be useful.
<H2>License</H2>
<P>
These utilities are Copyright &copy; 1995-1998 Julian Smith, all rights reserved, apart from the Makatic tools, whose copyright status is described in the Makatic <TT><B>!Help</B></TT> file.
<P>
We hereby reserve the right to take action against any person, persons or company which infringes the above conditions. Applications for permission to distribute contrary to these conditions may be made in writing, or by electronic mail to the addresses given below.
<P>
This software is provided 'as is', with no guarantee of its suitability for any purpose. No responsibility will be accepted for any data lost while using these program. NO WARRANTY IS GIVEN!
<H2>Contact Addresses</H2>
<P>
Post:	Warm Silence Software<BR>PO Box 28<BR>Woodstock<BR>Oxfordshire<BR>OX20 1XX
<P>
Internet:	<TT><B>Robin.Watts@wss.co.uk<BR>Paul.Gardiner@wss.co.uk</B></TT>
<P>
Phone:	0585 487642
<P>
Phone/Fax:	01608 737172
<H1 ALIGN=CENTER>MemCheck</H1>
<H2>Contents</H2>
<UL>
<LI>Introduction
<LI>Installation
<LI>Building a project
<LI>Example project
<LI>Notes on MemCheck operation
<LI>Restrictions
<LI>MemCheck's !Boot file
</UL>
<H2>Introduction</H2>
<H3>Overview</H3>
<P>
The <TT><B>!MemCheck</B></TT> directory contains a C library that provides full checking of all memory accesses from within programs compiled with the Acorn C compiler, version 4 or later.
<P>
MemCheck automatically keeps track of areas of memory which are safe to read or write to, such as memory returned from <TT><B>malloc</B></TT>, parts of the stack which aren't used for stack-frame house-keeping, etc.
<P>
Any attempt to read or write to memory which isn't in any of these areas will result in diagnostics, about the address accessed and the offending source instruction, being sent to <TT><B>stderr</B></TT>.
<P>
MemCheck will also allow the program to register areas of memory which are to be considered safe to access (e.g. memory claimed from the RMA or claimed with a memory allocator other than <TT><B>malloc()</B></TT>, such as Acorn's <TT><B>flex</B></TT>).
<P>
MemCheck allows access permissions of blocks of memory to be set, so that (for example) attempts to write to a block are faulted, but reads are allowed.
<P>
MemCheck optionally intercepts ANSI <TT><B>str</B></TT>/<TT><B>mem</B></TT> functions, and checks the pointer arguments refer to safe memory.
<P>
MemCheck requires each source file to be recompiled with the compiler front-end tool <TT><B>MemCheck.CC</B></TT>, the final executable to be linked with the MemCheck library, and a single call to <TT><B>MemCheck_Init()</B></TT> to be made at the start of <TT><B>main()</B></TT>. See below for the details. 
<H3>Using debugging information</H3>
<P>
If a program is compiled and linked with debugging information, MemCheck will automatically use this information to give full information on the source instruction which caused an illegal read or write. It will also open a throwback window for the offending source line if the program is running in the desktop. 
<H3>Speed</H3>
<P>
Because every read or write to memory is checked, programs built with MemCheck will run more slowly than normal. This effect gets worse for large programs which typically use many malloc blocks. 
<P>
There is support for turning off checking of memory reads and/or writes at run-time, which can be used to make trusted parts of a program run at nearly normal speed.
<H3>C compiler Compatibility</H3>
<P>
MemCheck relies on a special feature of the Acorn C compiler version 4 or later. It will <I>not</I> work with other compilers. 
<H3>Normal and MemCheck builds</H3>
<P>
To allow normal and memory-checking versions of a project to be easily built from the same source files, the MemCheck header file will macro-out all MemCheck function calls <I>unless</I> compilation is with <TT><B>MemCheck.CC</B></TT>.
<H3>Compatibility</H3>
<P>
MemCheck will work with both normal applications and RISC OS modules written in C.
<P>
MemCheck also works with programs running under DDT.
<H2>Installation</H2>
<P>
MemCheck uses an internal altered version of the <TT><B>stdio.h</B></TT> header file. To avoid copyright problems, this altered version is not distributed with MemCheck, but is generated from your own copy, using the command-line program <TT><B>!MemCheck.!MakeStdIO</B></TT>.
<P>
To generate this file:
<P>
1)	Ensure the Filer has seen the <TT><B>!MemCheck</B></TT> directory.
<P>
2)	Double-click on <TT><B>!MemCheck.!MakeStdIO</B></TT>. This will make an altered copy of your <TT><B>stdio.h</B></TT> header file, and save it inside the <TT><B>!MemCheck</B></TT> directory. This header file is used instead of the normal one when building MemCheck projects - see later.
<P>
Note that <TT><B>!MakeStdIO</B></TT> runs in a task window. If it can't find <TT><B>C:h.stdio</B></TT>, you will be asked to enter the filename (for example by shift-dragging the file into the taskwindow).
<P>
Also note that your original <TT><B>stdio.h</B></TT> header is left completely unchanged by <TT><B>!MemCheck.!MakeStdIO</B></TT>.
<H2>Building a project</H2>
<H3>Summary</H3>
<P>
To make a MemCheck version of a project:

<P>
1)	Ensure that the <TT><B>!MemCheck</B></TT> application-directory has been seen by the Filer.
<P>
2)	Add <TT><B>#include "MemCheck:MemCheck.h"</B></TT> to the source file containing <TT><B>main()</B></TT>.
<P>
3)	At the start of <TT><B>main()</B></TT>, call <TT><B>MemCheck_Init()</B></TT>. If you wish to have <TT><B>str</B></TT>/<TT><B>mem</B></TT> functions checked, also call <TT><B>MemCheck_InterceptSCLStringFunctions()</B></TT>.
<P>
4)	Recompile all source code, prefixing the call to your compiler with <TT><B>MemCheck.CC</B></TT>. 
<P>
5)	Link with the MemCheck library.

<P>
For example, if a source file is normally compiled with:
<PRE><B>cc -c -o o.foo c.foo</B>
<B></B>
</PRE>
<P>
- then recompile with:
<PRE><B>MemCheck.CC cc -c -o o.foo c.foo</B>
<B></B>
</PRE>
<P>
Note that the <TT><B>cc</B></TT> is still included.
<P>
There are two versions of the MemCheck library. If you are using Acorn C version 5 or later, link with <TT><B>MemCheck:o.MC</B></TT>. If you are using Acorn C version 4, link with <TT><B>MemCheck:o.MC_4</B></TT>.
<P>
The reason for having these two versions of the MemCheck library is that the names of some Shared C Library symbols changed between Acorn C version 4 and Acorn C version 5.
<P>
Also, compiling and linking with debugging (<TT><B>cc -g</B></TT>, <TT><B>link -d</B></TT>) enables MemCheck to give source-file information about offending instructions.
<H3>MemCheck.CC </H3>
<P>
<TT><B>MemCheck.CC</B></TT> is a tool which simply calls <TT><B>cc</B></TT> (or whatever is its first argument) with various extra flags.
<P>
To conditionally call <TT><B>MemCheck.CC</B></TT> from a makefile, use <TT><B>$(MemCheckCC) cc</B></TT> instead of <TT><B>cc</B></TT> in the makefile, and set the macro <TT><B>$(MemCheckCC)</B></TT> to <TT><B>MemCheck.CC</B></TT> when a MemCheck build is required. Otherwise, the macro will reduce to nothing, and <TT><B>cc</B></TT> will be called normally.
<P>
The example project described below uses this method.
<H3>Problems with using MemCheck's version of &lt;stdio.h&gt;</H3>
<P>
There seems to be a small problem with Acorn <TT><B>cc</B></TT>'s treatment of the <TT><B>-J</B></TT> option, used by <TT><B>MemCheck.CC</B></TT> to force use of MemCheck's altered version of <TT><B>stdio.h</B></TT>.
<P>
If the ANSI header files are in your <TT><B>C$Path</B></TT>, or are otherwise accessible to <TT><B>cc</B></TT> via the <TT><B>-I</B></TT> option, (which isn't really necessary because the compiler has internal pre-compiled versions), <TT><B>cc</B></TT> seems to prefer to use these rather than any files accessible via the <TT><B>-J</B></TT> option.
<P>
Essentially, this means that you should move the ANSI header files away from you normal include path, so that they don't interfere with inclusion of MemCheck's altered <TT><B>stdio.h</B></TT>.
<P>
You should leave <TT><B>kernel.h</B></TT> and <TT><B>swis.h</B></TT> though, because the compiler doesn't have internal versions of these.
<P>
Note that MemCheck's altered version of <TT><B>stdio.h</B></TT> merely makes the <TT><B>getc()</B></TT> and <TT><B>putc()</B></TT> macros into function calls (to <TT><B>fgetc()</B></TT> and <TT><B>fputc()</B></TT>), to prevent direct access to a <TT><B>FILE</B></TT> block that will be faulted by MemCheck.
<P>
Thus you don't have to move the ANSI header files away from your normal include path if you program doesn't use <TT><B>getc</B></TT> or <TT><B>putc</B></TT>.
<H3>Use with C modules</H3>
<P>
To make a MemCheck version of a C module (built using Acorn's <TT><B>CMHG</B></TT> tool), you should follow the steps described above, except that you should link with <TT><B>MemCheck:o.MC_M</B></TT>.
<P>
You can include source-level debugging information in a module by linking with <TT><B>MemCheck.DDTModLink link</B></TT> rather than <TT><B>link</B></TT> only, for example with:
<PRE><B>memcheck.ddtmodlink link -rmf -o MyModule o.foo o.bar C:o.stubs</B>
<B></B>
</PRE>
<P>
This will allow MemCheck to give source-file information when outputing diagnostics. Note that <TT><B>MemCheck.DDTModLink</B></TT> requires that the Utiltities directory supplied with Dr Smith's is added to your Run$Path. 
<P>
See <TT><B>!MemCheck.Examples.Module.!Mod_MC.Makefile</B></TT> for an example of this. 
<P>
If MemCheck decides to terminate the module (for example after a write error), it will call <TT><B>exit(1)</B></TT>, instead of <TT><B>abort()</B></TT>, which can crash the machine if called from within a module.
<P>
Note that MemCheck will attempt to write all diagnostics to <TT><B>stderr</B></TT>, which is not particularly useful from within a module. It is recommended that you call <TT><B>MemCheck_RedirectToFilename( tmpnam())</B></TT> or similar in your module initialisation code.
<P>
CMHG 5.00 can call IRQ handlers with a badly defined stack (the stack is not terminated with returnFP=0), so it may be necessary to turn off MemCheck checking in IRQ handlers. Later versions of CMHG fix this, but the <TT><B>_kernel_swi_regs</B></TT> block passed to the handler is not in the visible stack, so needs to be registered with <TT><B>MemCheck_RegisterMiscBlock()</B></TT>.
<H2>Example project	</H2>
<P>
<TT><B>!MemCheck.Test.</B></TT> contains a simple C program which repeatedly mallocs, frees and reallocs blocks of memory, and reads and writes to undefined bits of memory.
<P>
The project has three separate builds, each in an application-subdirectory of <TT><B>!MemCheck.Test</B></TT>:
<P>
<TT><B>!MemCheck.Test.!Normal</B></TT> contains a normal build which quits with a corrupt heap.
<P>
!<TT><B>MemCheck.Test.!MemCheck</B></TT> contains a version compiled and linked for use with MemCheck, and with debugging information. The illegal memory accesses are detected by MemCheck, and the program is aborted when the first illegal write is attempted.
<P>
<TT><B>!MemCheck.Test.!MC_4</B></TT> is for use by those with version 4 of Acorn's development tools. It works with C version 4, and the stubs library supplied with C version 4, but requires a more fully-featured linker than the link version 4, such as the freeware <TT><B>DRLink</B></TT>.
<P>
Double-clicking on an application-subdirectory rebuilds that build of the program using Makatic. Alternatively, if you don't want to use Makatic, run the makefile in the application-subdirectory with Acorn's AMU tool.
<P>
Note that the compiler will warn about some (but not all) of the errors in the code - these are deliberately there to test MemCheck.
<P>
Run each of the versions by double-clicking on the <TT><B>RunProg</B></TT> TaskObey file within the build application-subdirectory.
<H2>Notes on MemCheck operation</H2>
<H3>Documentation of MemCheck functions</H3>
<P>
The information below doesn't go into the full details of each MemCheck function.
<P>
For these details, see the comments in The MemCheck header file, <TT><B>!MemCheck.h.MemCheck</B></TT>', or use the StrongHelp manual <TT><B>!MemCheck.MemCheck</B></TT>'.
<H3>Calling MemCheck_Init()</H3>
<P>
This should be done as soon as possible after the program starts up. 
<P>
In particular, it is essential to call <TT><B>MemCheck_Init()</B></TT> before any calls to memory-allocators such as <TT><B>malloc</B></TT>, otherwise MemCheck will fault accesses to these blocks of memory. Also, attempts to <TT><B>free</B></TT>/<TT><B>realloc</B></TT> <TT><B>malloc</B></TT>ed blocks will fail (with something like a <TT><B>bad user block</B></TT> error).
<P>
<TT><B>MemCheck_Init()</B></TT> should be called before any other MemCheck functions.
<H3>MemCheck_RegisterArgs()</H3>
<P>
This function should be called after <TT><B>MemCheck_Init()</B></TT>. 
<P>
If your program uses the <TT><B>arg</B></TT> and <TT><B>argv</B></TT> parameters passed to <TT><B>main()</B></TT>, you should call this function, passing <TT><B>argc</B></TT> and <TT><B>argv</B></TT>, otherwise MemCheck will fault any accesses to <TT><B>argv[]</B></TT>.
<P>
MemCheck will treat the strings referred to by <TT><B>argv</B></TT> as read-only.
<H3>MemCheck_InterceptSCLStringFunctions()</H3>
<P>
This should be called after <TT><B>MemCheck_Init()</B></TT>. 
<P>
This makes MemCheck intercept and check all calls to <TT><B>strcpy()</B></TT>, <TT><B>strncpy()</B></TT>, <TT><B>strcat()</B></TT>, <TT><B>strncat()</B></TT>, <TT><B>memcpy()</B></TT>, <TT><B>memmove()</B></TT> and <TT><B>memset()</B></TT>, and ensures that the arguments point to known blocks with appropriate read/write access settings.
<P>
MemCheck also checks that the blocks are large enough to accommodate any copied data etc.
<P>
For relevant functions, MemCheck also checks that ranges don't overlap. Note that if the blocks do overlap, MemCheck gives a warning, but allows the program to continue with the call. Hence MemCheck won't prevent such a faulty call from crashing the program.
<H3>MemCheck output</H3>
<P>
By default, MemCheck sends all diagnostics to <TT><B>stderr</B></TT>. This can be changed at run-time using the functions <TT><B>MemCheck_RedirectToStream()</B></TT>, <TT><B>MemCheck_RedirectToFilename()</B></TT> and <TT><B>MemCheck_RedirectToFilenamef()</B></TT>. Note that using an unbuffered stream will ensure that the diagnostics are saved to a file even if the program crashes immediately afterwards.
<P>
The function <TT><B>MemCheck_Printf()</B></TT> can be used in exactly the same way as <TT><B>printf()</B></TT>, except that it outputs to wherever MemCheck diagnostics are going.
<H4>Logging of malloc functions</H4>
<P>
If the program calls <TT><B>MemCheck_SetStoreMallocFunctions()</B></TT>, MemCheck will store information about the function-nesting whenever <TT><B>malloc</B></TT>, <TT><B>calloc</B></TT> or <TT><B>realloc</B></TT> are used.
<P>
This information is then used when printing diagnostics, to give a backtrace for when the call to <TT><B>malloc()</B></TT> was made. This is useful if your program uses a central error-checking wrapper for <TT><B>malloc()</B></TT>.
<P>
Naturally, this entails a size overhead on every malloc block.
<H3>Use with shifting-heap memory managers</H3>
<P>
If your program uses Acorn's <TT><B>flex</B></TT> routines (or similar), you will need to tell MemCheck about each flex block that is allocated or freed, using <TT><B>MemCheck_RegisterFlexBlock()</B></TT> and <TT><B>MemCheck_UnRegisterFlexBlock()</B></TT>.
<P>
In addition, you will need to inform MemCheck whenever a flex block is resized, by calling <TT><B>MemCheck_ResizeFlexBlock()</B></TT>.
<P>
Note that Acorn's flex library uses <TT><B>memmove()</B></TT> in a way which causes MemCheck to report an error when <TT><B>MemCheck_InterceptSCLStringFunctions()</B></TT> is being used.
<P>
To avoid this problem, you should temporarily turn of all MemCheck checking while the flex functions are being called, using code like:
<PRE><B>void	MemCheck_Flex__Alloc( flex_ptr anchor, int n)</B>
<B>	{</B>
<B>	MemCheck_checking	oldchecking = MemCheck_SetChecking( 0, 0);</B>
<B>	flex_alloc( anchor, n);</B>
<B>	MemCheck_RegisterFlexBlock(anchor, n);</B>
<B>	MemCheck_RestoreChecking( oldchecking);</B>
<B>	}</B>
</PRE>
<P>
		
<P>
The <TT><B>MemCheck:Flex.h</B></TT> header and <TT><B>MemCheck:o.Flex</B></TT> library provides this funcionality automatically. To use, put <TT><B>#include "MemCheck:Flex.h"</B></TT> after your <TT><B>#include"flex.h"</B></TT>, link with <TT><B>MemCheck:o.MCFlex</B></TT>, and all flex calls will be automatically replaced by wrapper functions when compilation is with <TT><B>MemCheck.CC</B></TT>. Note that this library has been written for use with Acorn's stand-alone version of flex.
<P>
In <TT><B>!MemCheck.o.Sources.Flex.</B></TT> is the source for this library, which you could modify for use with (for example) RISC_OSLib's flex.
<P>
The program inside !<TT><B>MemCheck.TestFlex.</B></TT> is an example of how to use this library. Note that this example assumes that your flex header and library are <TT><B>C:flexlib.flex.h</B></TT> and <TT><B>C:flexlib.o.flexlib</B></TT>.
<H3>Read/write access to memory</H3>
<P>
For each block of memory known to MemCheck, you can specify whether the block is readable and/or writable, using the functions <TT><B>MemCheck_SetBlockReadable()</B></TT> and <TT><B>MemCheck_SetBlockWritable()</B></TT>.
<P>
You can also set the default access permissions for subsequently-created blocks, using <TT><B>MemCheck_SetDefaultMallocAccess()</B></TT> etc. 
<P>
This is useful when using a library which hasn't been compiled with memory-checking, but which allocates memory for internal usage which you shouldn't be writing to:
<PRE><B>MemCheck_SetDefaultMallocWriteAccess( 0);</B>
<B>&lt;call library functions&gt;</B>
<B>MemCheck_SetDefaultMallocWriteAccess( 1);</B>
<B>&lt;...&gt;</B>
<B></B>
</PRE>
<P>
- this will mean that any attempts to write to the library's data from your code will be faulted by MemCheck.
<H3>Diagnostics</H3>
<P>
For each illegal read or write, MemCheck outputs the addresses that was illegally accessed, the size being accessed (byte, half-word, word etc) and gives the address of the offending instruction. 
<P>
It then lists all known blocks of memory. There are four types of memory blocks:
<UL>
<LI>Malloc blocks. These are claimed by your program calling <TT><B>malloc()</B></TT>, <TT><B>realloc()</B></TT> or <TT><B>calloc()</B></TT>.
<LI>Misc blocks. These are registered by your program using <TT><B>MemCheck_RegisterMiscBlock()</B></TT>. There will also be a few Misc blocks at the start of the list which correspond to various special areas of memory. These include: zero-init and static data areas, the <TT><B>FILE</B></TT> structs <TT><B>stdio</B></TT>, <TT><B>stderr</B></TT> and <TT><B>stdin</B></TT> (currently 40 bytes each), and the <TT><B>argv[]</B></TT> strings passed to any call to <TT><B>MemCheck_RegisterArgs()</B></TT>.
<LI>Flex blocks. These are registered by your program using <TT><B>MemCheck_RegisterFlexBlock()</B></TT>.
<LI>Stack chunks.
</UL>
<P>
MemCheck will also give a simple backtrace. Note that the backtrace will include some internal MemCheck functions.
<P>
If any malloc blocks were claimed after a call to <TT><B>MemCheck_StoreMallocFunctions()</B></TT>, a list of the addresses of all active functions when these malloc blocks were claimed is displayed for each malloc block. The function name is also displayed if it is embedded in the code (<TT><B>cc -ff</B></TT> stops the compiler from including this information).
<P>
See the test program output to see what this looks like.
<P>
If debugging information is present, MemCheck will attempt to find and display the source file, line and column of the offending instruction, and will also attempt to start a throwback session for these lines.
<P>
When using throwback, MemCheck will prefix all incomplete filenames with <TT><B>&lt;!RunImage&gt;.^.</B></TT>, where <TT><B>&lt;!RunImage&gt;</B></TT> is the filename of the executable, which will give the correct filename if the executable is in the project directory.
<P>
If this isn't the case, you will have to compile with complete pathnames to make use of the throwback, rather than use the CSD or Acorn's prefix directory.
<H4>Compiling with complete pathnames</H4>
<P>
To do this, simply pass the complete pathname of each source file to cc, rather than using an implicit CSD. For example:
<PRE><B>cc ... ADFS::4.$.Progs.Foo.c.main</B>
<B></B>
</PRE>
<P>
You can use system variables to do this when using general rules in a makefile. For example, if the project directory is <TT><B>&lt;Foo$Dir&gt;</B></TT>, and the makefile is run with the CSD set, one can still include full filename information using:
<PRE><B>.c.o: cc -o $@ &lt;Foo$Dir&gt;.$&lt;</B>
<B></B>
</PRE>
<P>
instead of:
<PRE><B>c.o: cc -o $@ $&lt;</B>
<B></B>
</PRE>
<P>
Note that <TT><B>&lt;Foo$Dir&gt;</B></TT> will also have to be set when these filenames are used with throwback at runtime.
<H3>Terminating after memory errors</H3>
<P>
If an illegal read is made, the program is allowed to continue. After an attempt to do an illegal write however, MemCheck will call <TT><B>abort()</B></TT>. The function <TT><B>MemCheck_SetQuitting()</B></TT> can be used to change this behaviour from within your program. It may be useful to quit on read errors as well as write errors when first adding MemCheck checking to a project, as there can be large amounts of diagnostics produced.
<P>
Note that an attempt to read or write to zero bytes of memory (e.g. with <TT><B>memcpy()</B></TT>) will result in a diagnostic, but won't cause MemCheck to abort the program, irrespective of any calls to <TT><B>MemCheck_SetQuitting()</B></TT>.
<H3>Controlling memory checking</H3>
<P>
To stop memory-checking at run-time, call <TT><B>MemCheck_SetChecking( checkreads, checkwrites)</B></TT>, where <TT><B>checkreads</B></TT> and <TT><B>checkwrites</B></TT> should be 0 or non-zero to turn checking off or on respectively. This will remove most of the slow-down from memory-checking. 
<P>
For example, if a function is known to make no illegal writes, but you would like to check reads, use <TT><B>MemCheck_SetChecking( 1, 0)</B></TT> before calling the function. 
<P>
In addition, you can stop the compiler from inserting branches to MemCheck's checking code by putting <TT><B>#pragma -c0</B></TT> in the source code. Note that this won't stop MemCheck from checking calls to <TT><B>strcpy()</B></TT> etc, which are checked using a different mechanism.
<H3>Using MemCheck with DDT</H3>
<P>
If a MemCheck program is run under DDT, you can make DDT catch any memory errors, enabling you to immediately examine function parameters etc.
<P>
To do this, simply set a breakpoint on the function <TT><B>MemCheck_DDTTrap</B></TT> (ie type <TT><B>MemCheck_DDTTrap</B></TT> in DDT's break-point dialog box, and then click on the <TT><B>Procedure</B></TT> button).
<P>
<TT><B>MemCheck_DDTTrap</B></TT> is simply an empty function in the MemCheck library, which is compiled with <TT><B>cc -g</B></TT> and which MemCheck calls immediately after reporting any memory-violation.
<H3>Using MemCheck with module code</H3>
<P>
Link with <TT><B>MemCheck:o.MC_M</B></TT> instead of <TT><B>MemCheck:o.MC</B></TT> if your project is built with <TT><B>cc -zm</B></TT> (eg a RISC OS module).
<P>
Also, use the tool <TT><B>MemCheck.DDTModLink</B></TT> to link, to include source-level debugging information. For example:
<PRE><B>memcheck.ddtmodlink link -rmf -o MyModule o.foo o.bar C:o.stubs</B>
<B></B>
</PRE>
<P>
This will allow MemCheck to give source-file information when outputing diagnostics.
<H3>MemCheck names</H3>
<P>
All MemCheck function names start with <TT><B>MemCheck_</B></TT>; all names with this prefix should be regarded as being reserved for the MemCheck system.
<H3>Warning</H3>
<P>
If you forget to link a program with the MemCheck library, and also forget to call <TT><B>MemCheck_Init()</B></TT>, the program will link and run without memory checking, which can be slightly confusing.
<H3>Finding memory-leaks</H3>
<P>
A simple way of detecting memory leaks is to call <TT><B>MemCheck_OutputBlocksInfo()</B></TT> just before you program finishes (e.g. with <TT><B>atexit()</B></TT>). This will display all un-freed blocks. 
<P>
It is particularly helpful if you call <TT><B>MemCheck_StoreMallocFunctions()</B></TT> at the start of your program so that MemCheck displays the functions active when each malloc-block was claimed.
<H3>Hyper-text documentation of MemCheck_ functions</H3>
<P>
There are rather a lot of functions for controlling the behaviour of the MemCheck system, all prototyped in the file <TT><B>MemCheck:MemCheck.h</B></TT>.
<P>
This header file contains comments on each MemCheck function. 
<P>
This information is also available as fully cross-referenced hyper-text pages in the StrongHelp manual <TT><B>MemCheck.MemCheck</B></TT> for use with the freeware StrongHelp program, and in HTML form inside the StrongHelp directory <TT><B>!MemCheck.HTMLHelp</B></TT>, for use with a WWW browser.
<H3>Running debug applications without DDT</H3>
<P>
If you compile and link with debugging information, the resulting executable will be file-typed as <TT><B>DebImage</B></TT> by link, and so will start DDT when run.
<P>
To avoid starting DDT, simply <TT><B>settype</B></TT> the <TT><B>!RunImage</B></TT> to filetype <TT><B>absolute</B></TT>.
<H3>Using MemCheck_InterceptSCLStringFunctions() with libraries</H3>
<P>
<TT><B>MemCheck_InterceptSCLStringFunctions()</B></TT> will cause all calls to (for example) <TT><B>strcpy()</B></TT> to be intercepted, even if from within a library that wasn't compiled with <TT><B>MemCheck.CC</B></TT>.
<P>
This can lead to MemCheck faulting calls from within the library if, for example, the library copies an internal static string (which MemCheck won't know is safe memory to read).
<P>
To add to the confusion, Acorn's compiler sometimes replaces <TT><B>strcpy()</B></TT> with <TT><B>memcpy()</B></TT> if it knows how long the source string is.
<P>
So, if you are getting diagnostics about <TT><B>memcpy()</B></TT> reading unknown memory, check whether you are using a library that calls <TT><B>memcpy()</B></TT> or <TT><B>strcpy()</B></TT>.
<H3>Problems with the compiler</H3>
<P>
There is a bug in Acorn's compiler which can cause an internal inconsistancy error when <TT><B>cc -zpc1</B></TT> (as used by <TT><B>MemCheck.CC</B></TT>) is used with constructs like:
<PRE><B> *(int*)"SQSH"</B>
</PRE>
<P>
A workaround for this sort of thing is to write out the numerical value explicitly.
<H3>Other functions checked by MemCheck</H3>
<P>
MemCheck intercepts calls to the Shared C Library functions <TT><B>getenv()</B></TT>, <TT><B>_kernel_swi()</B></TT> and <TT><B>_kernel_last_oserror()</B></TT>. This is done so that MemCheck will treat any buffers returned by these functions as readable.
<P>
MemCheck stores just one buffer for each of the above functions. For example, if <TT><B>_kernel_swi</B></TT> returns an error, MemCheck will register the <TT><B>_kernel_oserror</B></TT> as readable. If a subsequent call to <TT><B>_kernel_swi</B></TT> also returns an error, the first <TT><B>_kernel_oserror</B></TT> block will be unregistered, and the new <TT><B>_kernel_oserror</B></TT> block registered in its place.
<P>
The function <TT><B>MemCheck_SetOSBuffersLifetime()</B></TT> can be used to alter this behaviour slightly to make it more strict.
<H2>Restrictions</H2>
<P>
MemCheck will find many types of illegal memory access, but there are case when bad accesses will go undetected:
<H3>Limited stack protection</H3>
<P>
MemCheck knows about the top 4 words in each stack frame, which are used by the runtime system to maintain the stack, so should prevent a program corrupting the stack structure. However, MemCheck will not detect overwriting of variables which are on the stack, because it doesn't know where each variable starts and ends.
<P>
For example:
<PRE><B>void	Foo()</B>
<B>	{</B>
<B>	int	array1[ 10];</B>
<B>	int	array2[ 3];</B>
<B>	...</B>
<B>	}</B>
<B></B>
</PRE>
<P>
Here, if the compiler puts <TT><B>array1</B></TT> just above <TT><B>array2</B></TT> in stack memory, there will be no way for MemCheck to know that <TT><B>array2[5]</B></TT> is illegal.
<P>
In addition, if there are extra words on the stack above <TT><B>array1</B></TT>, then reading or writing just beyond <TT><B>array1[9]</B></TT> may not be detected.
<H3>Limited array bounds-checking</H3>
<P>
Accessing one or two words beyond the bounds of a <TT><B>malloc-ed</B></TT> block will always be detected by MemCheck. This enables MemCheck to catch most common array mistakes.
<P>
However, an address more than two words beyond a malloc block may be in the next malloc block, so be treated as safe.
<P>
To improve on this, the compiler would have to pass the base of any array being accessed, as well as the actual address, to memory-checking code, which could then check they were in the same block. The Acorn compiler doesn't do this.
<H3>Stubs</H3>
<P>
MemCheck will only work with programs which are linked with Shared C Library stubs - it won't work with the stand-alone <TT><B>ansilib</B></TT> supplied with Acorn C. 


<H2>MemCheck's !Boot file</H2>
<P>
When seen by the Filer, the <TT><B>!MemCheck</B></TT> application directory affects the following system variables:
<P>
<TT><B>Run$Path</B></TT>	(<TT><B>MemCheck:Bin.</B></TT> is added)
<P>
<TT><B>MemCheck$Dir</B></TT>
<P>
<TT><B>MemCheck$Path</B></TT>
<P>
(<TT><B>C$Path</B></TT> is not changed)
<H1 ALIGN=CENTER>HierProf</H1>
<H2>Contents</H2>

<UL>
<LI>Introduction
<LI>Adding profiling to a project
<LI>Adding profiling to a project - details
<LI>The HierProf libraries
<LI>Loading and analysing HierProf data
<LI>Manual control of profiling in C programs
<LI>Timing overheads and restrictions
<LI>Using <TT><B>HierProf.CC</B></TT> with C++
<LI>HierProf's !Boot file
</UL>
<H2>Introduction</H2>
<P>
The <TT><B>!HierProf</B></TT> application-directory contains various tools which allow you to build profiled versions of programs running under RISC OS.
<P>
The profiling output is plain text containing a full hierarchical listing of the time spent in each function, so you get told how much time was spent in function <TT><B>Foo</B></TT> as percentages of the amount of time spent in all other functions that indirectly or directly called <TT><B>Foo</B></TT>.
<P>
For example, here is part of the profiling output from one of the programs in the <TT><B>!HierProf.Examples</B></TT> directory:
<PRE><B>    Outermost loop                                                </B>
<B>2    `--  99.71% main                                             </B>
<B>3         85.97%  `--  86.22% FunctionC                           </B>
<B>4          2.81%        2.82%  |--   3.27% NullFunction           </B>
<B>5         17.67%       17.72%  |--  20.56% FunctionA              </B>
<B>6          5.31%        5.33%  |     6.18%  `--  30.07% FunctionD </B>
<B>7         23.66%       23.73%  `--  27.53% FunctionB             </B>
<B></B>
</PRE>
<P>
The '--' indicate direct calls, to help you to follow the tree-structure of the function calls.
<P>
More detailed numerical information is also given for each 'nesting' of function calls: number of calls, total time, average time, minimum time, maximum time, and standard deviation time. In addition, exact machine-readable timing values are also output.
<P>
By default, the profiling output is sent to <TT><B>stderr</B></TT> when the program finishes, using <TT><B>atexit()</B></TT>. There are functions to send the output to temporary files etc instead.
<P>
The timing information is displayed in ms or us (micro-seconds) as appropriate. Exact timings are also added in crude form for use with custom analysis programs. There is a library function provided which can be used to load this data from a HierProf output file into a C structure. This is to allow one to perform custom analysis of the data. See later for the details.
<P>
See the file <TT><B>!HierProf.History</B></TT> if you want to see the changes made since the last version of HierProf.
<H3>Tool names</H3>
<P>
HierProf provides various <I>tools</I> - RISC OS programs which run from the CLI, in the same way that Acorn's <TT><B>cc</B></TT> and <TT><B>link</B></TT> do.
<P>
To ensure that HierProf's tools don't clash with any existing commands, HierProf uses a slightly unusual method of adding the tools to your <TT><B>Run$Path</B></TT>.
<P>
For example, to run HierProf's <TT><B>ConvertAOF</B></TT> tool, you should actually use: <TT><B>HierProf.ConvertAOF ...</B></TT>. The <TT><B>HierProf.</B></TT> prefix guarantees that HierProf tools will never clash with any other tools (as long as no one ever writes a tool called <TT><B>hierprof</B></TT>, of course).
<P>
This is done by having all the HierProf tools in the directory <TT><B>!HierProf.Bin.HierProf.</B></TT>, and making <TT><B>!HierProf.!Boot</B></TT> add the <TT><B>!HierProf.Bin.</B></TT> directory to <TT><B>Run$Path</B></TT>.
<H2>Adding profiling to a project</H2>
<P>
There are three methods provided by HierProf for adding profiling to a project.
<P>
All three methods require the final executable to be linked with one of the HierProf libraries (see later) but provide different ways of adding the appropriate calls (to the HierProf library) to the project.
<P>
Method 1 works at run-time, and is probably the simplest to use. The other methods are for use at build-time using command-line tools provided by HierProf.
<P>
Methods 1 and 3 don't affect the optimisation of existing functions - they merely add simple wrapper functions which call HierProf timing functions before and after. This means that they add a slightly larger overhead to the time a function takes to complete, but the timings will be closer to the unprofiled performance.
<P>
Because it modifies source code prior to compilation, method 2 will sometimes affect the optimisations that <TT><B>cc</B></TT> will make during compilation. On the other hand, there will be slightly less overhead associated with the calls to HierProf timing functions (see later).
<H3>1. HierProf_ProfileAllFunctions()</H3>
<P>
This is the recommended way of profiling code.
<P>
If your program calls this function, HierProf will search through the executable at runtime and alter the code so that all functions are subsequently profiled.
<P>
Note that this method of adding profiling will ignore all functions which don't have their function-names embedded in the code (e.g. C functions compiled with Acorn <TT><B>cc</B></TT>'s <TT><B>-ff</B></TT> option, and also C functions which are simple enough not to require any stack). Such functions have to be made known to HierProf individually.
<H3>2. HierProf.CC - a C preprocessor</H3>
<P>
<TT><B>HierProf.CC</B></TT> is a tool which preprocesses the C source code to add calls to the HierProf library at the start and end of each function.
<P>
It is very straightforward to use but its use is deprecated - see later for the details.
<H3>3. HierProf.ConvertAOF - an AOF converter</H3>
<P>
<TT><B>HierProf.ConvertAOF</B></TT> is a tool which adds HierProf library calls to ARM Object Format (AOF) files, as produced by most RISC OS C compilers and assemblers. 
<P>
This enables you, for example, to add profiling to libraries for which you don't have source code.
<P>
This system is a little more restricted than <TT><B>HierProf.CC</B></TT>:
<P>
- it can only add profiling to functions with external linkage (this means, for example, that <TT><B>static</B></TT> C functions are ignored).
<P>
<TT><B>HierProf.ConvertAOF</B></TT> is intended for use with code for which source isn't available, and which doesn't contain embedded function names.
<P>
See later for details on using <TT><B>HierProf.ConvertAOF</B></TT>.
<H2>Adding profiling to a project - details</H2>
<H3>Adding profiling to C source code with HierProf_ProfileAllFunctions()</H3>
<P>
1)	Ensure that the <TT><B>!HierProf</B></TT> application-directory has been seen by the Filer.
<P>
2)	Add <TT><B>#include "HierProf:HierProf.h"</B></TT> to the source file that contains <TT><B>main()</B></TT>.
<P>
3)	Add a call to <TT><B>HierProf_ProfileAllFunctions()</B></TT> to the start of <TT><B>main()</B></TT>.
<P>
4)	Recompile <TT><B>main()</B></TT>'s source file with: <TT><B>cc -DHierProf_PROFILE ...</B></TT>.
<P>
5)	Link with <TT><B>HierProf:o.HP</B></TT> for 100Hz timing using the Shared C Library's <TT><B>clock()</B></TT> function, or link with <TT><B>HierProf:o.HP_T1</B></TT> for 2MHz timing using IOC's timer1.
<P>
The function <TT><B>HierProf_ProfileFunction()</B></TT> can be used to profile individual functions which <TT><B>HierProf_ProfileAllFunctions()</B></TT> misses because they don't have their names embedded in the code.
<P>
Note that a few very simple functions are ignored by because the first instruction refers to the ARM's programme-counter register. HierProf will tell you if this happens.
<P>
You can call <TT><B>HierProf_IgnoreFunctions()</B></TT> with a space-separated list of wild-carded function-names which a subsequent call to <TT><B>HierProf_ProfileAllFunctions()</B></TT> will ignore.
<H3>Adding profiling to C source code with HierProf.CC</H3>
<P>
To make a profiled version of a C project, do the following:
<P>
1)	Ensure that the <TT><B>!HierProf</B></TT> application-directory has been seen by the Filer.
<P>
2)	Compile each C source file by calling <TT><B>HierProf.CC</B></TT> rather than your normal compiler, passing the full call to your compiler as the arguments to <TT><B>HierProf.CC</B></TT>.
<P>
3)	Link with <TT><B>HierProf:o.HP</B></TT> for 100Hz timing using the Shared C Library's <TT><B>clock()</B></TT> function. or link with <TT><B>HierProf:o.HP_T1</B></TT> for 2MHz timing using IOC's timer1.
<P>
For example, if you normally build with:
<PRE><B>cc -c -I,C: -o o.main c.main link -o !RunImage o.main C:o.Stubs</B>
<B></B>
</PRE>
<P>
then to include profiling, do:
<PRE><B>HierProf.CC cc -c -I,C: -o o.main c.main link -o !RunImage o.main HierProf:o.HP C:o.Stubs</B>
<B></B>
</PRE>
<P>
(Users of Acorn C version 4 should use <TT><B>HierProf:o.HP_4</B></TT>)
<P>
Note that <TT><B>cc</B></TT> is still included as the first parameter to <TT><B>HierProf.CC</B></TT> . This is to allow the use of <TT><B>HierProf.CC</B></TT> with compilers which aren't called <TT><B>cc</B></TT>.
<H4>Restrictions when using HierProf.CC</H4>
<P>
<TT><B>HierProf.CC</B></TT> has a small restriction compared to a normal C compiler - it will only process one <TT><B>.c</B></TT> file in the command line parameters, so you will have to compile multiple <TT><B>.c</B></TT> files individually.
<P>
You should ensure that the C source code will compile normally without errors before using <TT><B>HierProc.CC</B></TT>, because <TT><B>HierProf.CC</B></TT> will not be particularly helpful if it can't parse the C source.
<H4>Problems with using HierProf.CC</H4>
<P>
<TT><B>HierProf.CC</B></TT> can fail to correctly parse C source code which omits white space between a '<TT><B>)</B></TT>' and a '<TT><B>{</B></TT>'.
<P>
Because <TT><B>HierProf.CC</B></TT> adds code to the C source, it significantly interferes with the optimisation that the compiler can do, making the results of the profiling unreliable. It also causes problems if function names are generated using macros.
<P>
For these reasons, use of <TT><B>HierProf.CC</B></TT> is not recommended - it is much better to use <TT><B>HierProf_ProfileAllFunctions()</B></TT>.
<H3>Adding profiling to existing AOF files with HierProf.ConvertAOF</H3>
<P>
To make profiled versions of existing AOF files, simply run the <TT><B>HierProf.ConvertAOF</B></TT> tool on the AOF file using:
<PRE><B>HierProf.ConvertAOF &lt;AOF infile&gt; &lt;AOF outfile&gt;</B>
<B></B>
</PRE>
<P>
For example, if your AOF files are <TT><B>o.Foo</B></TT> and <TT><B>o.Bar</B></TT>, and you normally link with:
<PRE><B>link -o !RunImage o.Foo o.Bar C:o.Stubs</B>
<B></B>
</PRE>
<P>
then to include function profiling, do:
<PRE><B>HierProf.ConvertAOF o.Foo o.Foo </B>
<B>HierProf.ConvertAOF o.Bar o.Bar </B>
<B>link -o !RunImage o.Foo o.Bar HierProf:o.HP C:o.Stubs</B>
<B></B>
</PRE>
<P>
Note that <TT><B>HierProf.ConvertAOF</B></TT> is actually a simple <TT><B>Obey</B></TT> script which calls <TT><B>link</B></TT> and <TT><B>objasm</B></TT> (and the <TT><B>special HierProf._AOF</B></TT> tool). If both of these tools aren't present, you won't be able to use <TT><B>HierProf.ConvertAOF</B></TT>.
<P>
<TT><B>HierProf.ConvertAOF</B></TT> uses flags appropriate for Acorn's versions of these tools, so will probably need modification to work with other products.

<H4>Converting Stubs</H4>
<P>
The file <TT><B>C:o.stubs</B></TT>, which one normally links with to make the C functions in the Shared C Library available to a C program, is a standard AOF file. It is possible to make a HierProf version of Stubs in the same way as for any other AOF file.
<P>
The only thing to be careful of is that some functions in stubs are special (e.g. involved in setting up the C runtime environment etc), so should not be altered to call the HierProf library.
<P>
<TT><B>HierProf.ConvertAOF</B></TT> accepts a list of wild-carded function-names to be ignored. These names should be simply added to the end of the call to <TT><B>HierProf.ConvertAOF</B></TT>.
<P>
Most of the special Stubs functions start with a '<TT><B>_</B></TT>', and there are also the functions <TT><B>clock()</B></TT> <TT><B>TrapHandler()</B></TT>, <TT><B>UncaughtTrapHandler</B></TT>, <TT><B>EventHandler()</B></TT>, names with '<TT><B>$</B></TT>' and <TT><B>UnhandledEventHandler()</B></TT> which would cause problems if they were interfered with.
<P>
Thus to make a new HierProf-using stubs, use (in one long command line):
<PRE><B>Hierprof.ConvertAOF &lt;Stubs filename&gt; &lt;New HierProf Stubs filename&gt; _* *$* clock TrapHandler UncaughtTrapHandler EventHandler UnhandledEventHandler</B>
<B></B>
</PRE>
<P>
Note that this will ignore all the <TT><B>_kernel_*</B></TT> functions.
<P>
Please note also that, while this seems to work fine, only a small amount of testing has been done on a profiled stubs.
<H4>Converting existing libraries</H4>
<P>
If you wish to add HierProf calls to an existing library created with Acorn's LibFile or similar, you will have to extract the individual AOF files with LibFile, run <TT><B>HierProf.ConvertAOF</B></TT> on each AOF file, and then use LibFile again to put all the new AOF files in a library again.
<P>
There is a tool called <TT><B>HierProf.ConvertALF</B></TT> which automates this. It is a simple Obey file which uses LibFile to extract the individual AOF files from the library (storing them in <TT><B>&lt;Wimp$ScrapDir&gt;.HierProf.</B></TT>), runs <TT><B>HierProf.ConvertAOF</B></TT> on each of the AOF files, and then makes a new library using LibFile.
<P>
The main limitation is that <TT><B>HierProf.ConvertALF</B></TT> will only be able to extract and deal with the individual AOF files if they have names such as <TT><B>o.Foo</B></TT>, <TT><B>o.Bar</B></TT> etc. While this is true of many libraries, some (for example DeskLib), use a complete pathname.

<H3>Examples</H3>
<P>
The <TT><B>!HierProf.Test.Simple</B></TT> directory contains an example project which demonstrates how to use HierProf.
<P>
There are various different builds of the project, each in a separate application-directory with a makefile created using Makatic.
<P>
The different builds of the project can be re-built either by running the <TT><B>!Run</B></TT> file within each build application-directory (which uses Makatic and the template makefile), or simply by running the existing makefile with Acorn's AMU tool.
<H2>The HierProf libraries</H2>
<P>
As mentioned earlier, any program which uses the HierProf system needs to be linked with the HierProf library which provides functions which do the actual timing and housekeeping needed.
<P>
There are two different versions of the library:
<P>
<TT><B>HierProf:o.HP</B></TT>		Uses 100Hz ANSI C clock() for timing. 
<P>
<TT><B>HierProf:o.HP_T1</B></TT>	Uses 2MHz IOC timer.
<P>
Any of these libraries can be used with any of the three methods of adding profiling described earlier.
<P>
Note that HierProf uses 32 bit values to measure time, which will overflow after about 35 minutes when using the IOC timer1-based HierProf library.
<P>
Note that users of Acorn's Desktop C should use the libraries ending with '<TT><B>_</B></TT>4' - this is because Desktop C has a version of <TT><B>C:o.stubs</B></TT> which doesn't support some new symbol names.
<H2>Loading and analysing HierProf data</H2>
<P>
The header file <TT><B>HierProf:Data.h</B></TT> and C library <TT><B>HierProf:o.Data.HPData</B></TT> can be used to load all timing information from a HierProf output file for analysis by your own program.
<P>
The header file provides a few structures and a function <TT><B>HierProf_LoadData</B></TT> which loads all data from a file into an easy-to-use form.
<P>
See the example program in <TT><B>!HierProf.Test.Data.</B></TT> to see how to use this library. This example loads the profiling data from the example HierProf program in <TT><B>!HierProf.Test.Simple.</B></TT>.
<H2>Manual control of profiling in C programs</H2>
<P>
You can manually profile any region of code inside a C function by adding pairs of the macros <TT><B>HierProf_Start("any text")</B></TT> and <TT><B>HierProf_Stop()</B></TT> lines (with no terminating semicolons) around the code you want profiled.
<P>
These macros will be removed unless compilation is with <TT><B>HierProf.CC</B></TT>, or with <TT><B>HierProf_PROFILE</B></TT> defined and the HierProf header file <TT><B>#include</B></TT>d.
<P>
You can also make <TT><B>HierProf.CC</B></TT> ignore a function by putting <TT><B>HierProf_DontProfile()</B></TT> immediately after the opening '<TT><B>{</B></TT>' of the function.
<P>
For example:
<PRE><B>int FunctionWeDontWantToProfile( int x)</B>
<B>{ HierProf_DontProfile()</B>
<B>...</B>
<B>}</B>
<B></B>
</PRE>
<P>
There are various functions which can be used to control where profiling information is sent to, in <TT><B>HierProf:HierProf.h</B></TT>.
<H2>Timing overheads and restrictions</H2>
<H3>Program slow-down</H3>
<P>
As you may have been thinking, two function calls per profile block is going to give a hefty time overhead.
<P>
On a 25MHz A5000, this overhead is around 0.15 ms. Hence programs using HierProf will run rather slowly.
<H3>Timing correction</H3>
<P>
HierProf measures how long is spent in its start/stop functions, and uses this information to correct the timing information.
<P>
HierProf also attempts to correct for the time spent inside <TT><B>clock()</B></TT> or the timer1-reading functions. This correction is updated periodically as the program runs in case the environment changes, and the most recent correction (in micro-secs) is displayed after the profiling statistics.
<P>
This correction is only significant when using <TT><B>HierProf:o.HP_T1</B></TT>, because the time taken to read <TT><B>clock()</B></TT> is much less than <TT><B>clock()</B></TT>'s 10ms resolution.
<P>
Note that this correction can result in some functions having a negative minimum time, because the timing functions sometimes work faster than average.
<P>
This is mainly a problem when running taskwindows, which can be pre-empted. If the profiled program is interrupted inside HierProf's correction loop, this can result in HierProf over-correcting, giving large negative time-measurements.
<P>
The only time left uncorrected is that spent in the code which calls HierProf timing functions before and after each function. In code compiled with <TT><B>HierProf.CC</B></TT>, this overhead is 3-4us. Run-time addition of profiling calls with <TT><B>HierProf_ProfileAllFunctions()</B></TT> is slightly less efficient, with an overhead of 8-9us.
<P>
N.B. These last two timings are simply the average time HierProf gave for a null C function, running on a 25MHz A5000 in mode 31.
<P>
There is a maximum of 65536 for the number of different functions or blocks that are profiled.
<P>
A maximum of 62 nested function levels are handled - higher nestings are ignored. HierProf will also ignore all but the first recursive call to a recursive function (including mutually recursive functions).
<P>
To avoid name-clashes, the HierProf system only uses names starting with <TT><B>HierProf_</B></TT>. Hence code used with the HierProf system should regard this prefix as reserved.
<H2>Using HierProf_ProfileAllFunctions with C++</H2>
<P>
HierProf will unmangle embedded C++ function names as generated by Acorn C++.
<H2>Using HierProf.CC with C++</H2>
<P>
<TT><B>HierProf.CC</B></TT> semi-works with C++ code and Acorn's C++ compiler 5.06.
<P>
Only class-method names are noticed by the source parser, so <TT><B>SomeClass::dosomething(...)</B></TT> will appear as <TT><B>dosomething</B></TT> in the profile output. Similarly, parameter types are ignored.
<P>
Owing to the way <TT><B>HierProf.CC</B></TT> works though, methods with the same names in different classes will still be individually profiled, even though they have the same name in the output.
<P>
Converted C++ files are put into <TT><B>&lt;Wimp$ScrapDir&gt;.HierProf.c++.</B></TT> because Acorn C++ 5.06 doesn't cope very well with files inside <TT><B>.c</B></TT> directories.
<P>
Because of a bug in Acorn C++ 5.06, HierProf has to use the leafname of the input file as the temporary leafname when the input file is in a <TT><B>c++</B></TT> directory - C++ 5.06 seems to ignore any <TT><B>-o</B></TT> directive, and always uses the input source leafname as the output leafname. This will result in
<P>
<TT><B>&lt;Wimp$ScrapDir&gt;.HierProf.c++.</B></TT> filling up with old converted files.
<H2>!HierProf's !Boot file</H2>
<P>
When seen by the Filer, the <TT><B>!HierProf</B></TT> application directory affects the following system variables:
<P>
<TT><B>Run$Path</B></TT>	(<TT><B>HierProf:Bin.</B></TT> is added)
<P>
<TT><B>HierProf$Dir</B></TT>
<P>
<TT><B>HierProf$Path</B></TT>
<P>
(<TT><B>C$Path</B></TT> is not changed)
<P>
Also, the directories <TT><B>&lt;Wimp$ScrapDir&gt;.HierProf.c, &lt;Wimp$ScrapDir&gt;.HierProf.c++</B></TT>, <TT><B>&lt;Wimp$ScrapDir&gt;.HierProf.o</B></TT> and <TT><B>&lt;Wimp$ScrapDir&gt;.HierProf.s</B></TT> are created.
<H1 ALIGN=CENTER>Command-line tools in the 'Utilities' directory</H1>
<P>
Each tool within this directory gives full help if run with a <TT><B>-help</B></TT> parameter. 
<P>
Note that some of the simple Obey tools are dependent on others, and assume that the <TT><B>Utilities</B></TT> directory is moved into <TT><B>Run$Path</B></TT> - the tools themselves are run with (for example) <TT><B>AOF.Replace ...</B></TT>.
<P>
If you don't like this system, it should be very easy to amend the Obey tools to work with your preferred tools names.
<P>
Here are brief details about each tool:

<H2>Utilities.</H2>

<H3>Makatic.	</H3>
<P>
Freeware system for automatically constructing and running makefiles.
<H4>Docs.</H4>
<P>
Documentation and examples.
<H3>AOF.</H3>
<P>
Files for simple processing of AOF files.
<H4>Stubs5To4</H4>
<P>
Converts an AOF file to use old Acorn C version 4 symbols (for example <TT><B>x$stack_overflow</B></TT> instead of <TT><B>__rt_stkovf_split_small</B></TT>).
<H4>Replace</H4>
<P>
Crude tool for replacing symbols in AOF files.
<H4>TrimAOF</H4>
<P>
Makes particular global symbols in an AOF file local, and gives them meaningless names.
<H3>Every</H3>
<P>
Tools which act on all files which match a particular wild-carded name. The wild-card specification is similar to that of Acorn's Find tool.
<H4>Every2</H4>
<P>
Runs a given command on each matching file.
<H4>Count</H4>
<P>
Counts matching files.
<H4>ListNewer</H4>
<P>
Lists all matching files that are newer than a given file.
<H3>CTools</H3>
<P>
Tools for use with C programming.
<H4>CTrim</H4>
<P>
Makes a crunched version of C source. Useful for making crunched headers for faster compilation.
<H4>TemplHead</H4>
<P>
Generates general description file for icon numbers from a Templates file. Icons should have N&lt;iconname&gt; in validation string.
<H4>TemplCH</H4>
<P>
Simple front-end to TemplHead which makes a C header file with icon numbers.
</BODY>
</HTML>
