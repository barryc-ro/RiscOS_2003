#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#include "MemCheck:MemCheck.h"

#include "Test.h"



#define Utils_Rnd() ( (double) rand() / ( RAND_MAX+1.0))
/*
Treat like a function 'double  Utils_Rnd( void);'.

Returns random double y, 0 <= y < 1
 */

#define Utils_RndInt( x) ( (int) (Utils_Rnd() * ((double) x)) )
/*
Treat like a functin 'int Utils_RndInt( int x);'.

Returns random integer from { 0, 1, ... x-1 }. Have to use  ((double) x)
instead of (double)(x) in case x is 'a-b' - get a loss of precision
warning otherwise.
 */



#define	NUM 10

int	globalint = 0;
char	globalstring[256] = "";


int	main( int argc, char* argv[])
	{
	int	array2[ 32];
	int**	ptrs;
	int	i;
	int	array[ 200];
	
	printf( "MemCheck test application started\n");
	
	MemCheck_Init();
	MemCheck_InterceptSCLStringFunctions();	/* Turn on checking of strcpy etc.						*/
	MemCheck_SetStoreMallocFunctions( 1);	/* So that diagnostics tell us which functions malloced each malloc block.	*/
	MemCheck_SetStoreMiscFunctions( 1);	/* So that diagnostics tell us which functions malloced each malloc block.	*/
	MemCheck_RegisterArgs( argc, argv);	/* Tell MemCheck that strings in argv[0...argc-1] are ok to read.		*/
	
	MemCheck_Printf( "This text printed using MemCheck_Printf\n");
	
		{
		/* Test MemCheck's interception of getenv()	*/
		char	buffer[ 256];
		strncpy( buffer, getenv( "Wimp$ScrapDir"), 256);
		strncpy( buffer, getenv( "C$Path"), 256);
		memcpy( buffer, getenv( "Wimp$ScrapDir"), 256);	/* Causes a MemCheck error if <Wimp$ScrapDir> is less than 255 chrs	*/
		}
	
		{
		/* Check that MemCheck_RegisterArgs worked...	*/
		int	i;
		printf( "argc=%i, args are:\n", argc);
		for ( i=0; i<argc; i++)		printf( "0x%p %s\n", argv[i], argv[i]);
		}
	
	
	/* Remove the 'if (0)' to test guard-word checking	*/
	if (0)	{
		/* 
		Check that guard-word at end of malloc blocks works.
		We temporarily turn off checking so we can illegally overwrite
		the guard word for a malloc block.
		 */
		char*			ptr0;
		MemCheck_checking	oldchecking = MemCheck_SetChecking( 0, 0);
		int			i;
		
		/* Call malloc a few times...	*/
		for (i=0; i<10; i++)	malloc( 32);
		
		ptr0 = malloc( 31);
		ptr0[32] = 0;
		MemCheck_RestoreChecking( oldchecking);
		/*
		The next malloc should detect the alteration in the word beyond the malloced block.
		Note that the guard-word is word-aligned after the malloc block, so in the above
		test code, writing to ptr0[31] will not be detected (even though it is illegal).
		 */
		}
	
	
	putc( '\n', stdout);
	/* If this gives a write error, MemCheck's replacement stdio.h header hasn't been used.	*/
	
	globalint = 8;		/* CC doesn't include checking for this write to memory.	*/
	globalstring[0] = ' ';	/* This is checked						*/
	
	printf( "Calling test()\n");
	test();
	printf( "Called test()\n");
	
	if ( array2[32])	printf( "");	/* Should cause an error but doesn't	*/
	
	
	/*
	Test MemCheck's registering of miscellaneous blocks...
	We register and read from some arbitrary areas of memory.
	 */
	
	MemCheck_RegisterMiscBlock( (void*) 0x8000, 256);
	if ( *(int*) 0x8000)	printf( "");
	
	MemCheck_RegisterMiscBlock( (void*) 0x9000, 4);
	if ( *(int*) 0x9000)	printf( "");
	
	MemCheck_UnRegisterMiscBlock( (void*) 0x8000);
	if ( *(int*) 0x8000)	printf( "");	/* This should give an error	*/
	if ( *(int*) 0x9000)	printf( "");
	
	MemCheck_UnRegisterMiscBlock( (void*) 0x2345);	/* Should give an error	*/
	
	
	/* Test MemCheck_CheckRange()	*/
	
	MemCheck_CheckRange( (void*) 0x9000, 1, MemCheck_readwrite_READ, "Test 0");
	MemCheck_CheckRange( (void*) 0x9000, 100, MemCheck_readwrite_READ, "Test 1");
	MemCheck_CheckRange( (void*) 0x9000, 300, MemCheck_readwrite_READ, "Test 2");
	MemCheck_CheckRange( (void*) 0x8000, 300, MemCheck_readwrite_READ, "Test 3");
	/* Last three should give an error	*/
	
	MemCheck_UnRegisterMiscBlock( (void*) 0x9000);
	
	
	/* Test stack-checking.	*/
	array[22] = 4;
	
	if (array[-1]==0)	printf( "");
	/* This should give read error.	*/
	
	array[ 0] = 4;
	
	if (array[200]==0)	printf( "");
	/* This should give error, but doesn't because details of stack-variables aren't known.	*/
	
	if (array[300]==0)	printf( "");
	/* This should give error - the memory accessed is outside of the stackframe.	*/
	
		{
		char*	ptr = (char*) malloc( 300*sizeof(int));
		memcpy( ptr, array, 300*sizeof( int));
		/* Should cause an error - read beyond stack frame.	*/
		}
	
	
	/*
	Now do some random allocs and frees to the malloc heap, doing some bad
	reads and writes as we go.
	 */
	
	printf( "Mallocing array of pointer...\n");
	ptrs = (int**) malloc( NUM * sizeof( int*));
	printf( "Done, ptrs = 0x%p\n", ptrs);
	
	/*
	An array of pointers which we will repeatedly realloc/free/malloc.
	 */
	
	for ( i=0; i<NUM; i++)	ptrs[ i]=NULL;
	
	
	for(;;)	{
		int	n = Utils_RndInt( 10);
		int	i = Utils_RndInt( NUM);
		
		printf( "i=%i, n=%i\n", i, n);
		
		if ( ptrs[i])	{
			
			if ( Utils_RndInt( 2))	{
				printf( "Calling free\n");
				free( ptrs[i]);
				if ( ptrs[i][2])	printf( "");	/* Should give a read error.	*/
				ptrs[i] = NULL;
				}
			
			else	{
				void*	newptr;
				printf( "Calling realloc\n");
				newptr = (int*) realloc( ptrs[i], n*sizeof(int));
				if (newptr)	{
					ptrs[i] = newptr;
					ptrs[i][0] = n;	/* Gives a write error when n=0	*/
					}
				}
			}
		
		else	{
			
			ptrs[i] = (int*) malloc( n*sizeof(int));
			printf( "Called malloc ptrs[%i]=0x%p\n", n, ptrs[i]);
			
			if (ptrs[i])	ptrs[i][0] = 2;	/* Gives write error when n=0	*/
			}
		}
	
	return 0;
	}

