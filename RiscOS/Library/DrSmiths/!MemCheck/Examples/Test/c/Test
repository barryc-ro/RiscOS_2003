#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "MemCheck:MemCheck.h"

#include "Test.h"




static void	test3( void)
{
int	si[ 256];
char*	s = (char*) si;
strcpy( s, "abcdefghijklm");

/*strcpy( s, s+5);*/
/*
This is warned about by MemCheck (arguments overlap), but is commented
out here because MemCheck will not prevent the call from proceeding, and
it messes up the stack 8)
 */

strncpy( s, s+5, 3);
printf( "test3 string is %s\n", s);
si[128] = 0;
si[250] = 0;
si[252] = 0;
si[254] = 0;
si[255] = 0;
if ( si[254])	printf( "");
if ( si[255])	printf( "");
if ( si[256])	printf( "");	/* Should give read error	*/
}


static void	test2( void)
{
char*	s = (char*) malloc( 99);
char	s2[ 1200];
memset( s, 1, 99);
strncpy( s, (char*) 0x800, 99);		/* Should give read error	*/
memset( s, 1, 99);
strncpy( s2, s, 100);			/* might give read error	*/
}


void	test( void)
{
int	array[ 300];
char	array2[ 20000];

printf( "Just about to read array element -1...\n");
if (array[-1]==0)	printf( "");
printf( "\n\n");

printf( "Just about to read array element 0...\n");
if (array[0]==0)	printf( "");
printf( "\n\n");

	{
	char*	p = (char*) malloc( 230);
	printf( "p=%p\n", p);
	/* Should show up in MemCheck's list of known blocks.	*/
	if (p)	{
		p[3]=1;
		MemCheck_SetBlockReadable( p, 0);	/* Make unreadable	*/
		if ( p[3])	printf( "\n");	/* Should raise error	*/
		}
	}

test2();

test3();

printf( "Just about to read array[0..299] element 300\n");
if (array[300]==0)	printf( "...\n");	/* Should raise error	*/
printf( "\n\n");

printf( "Just about to read array[0..299] element 299\n");
if (array[299]==0)	printf( "...\n");
printf( "\n\n");

}
