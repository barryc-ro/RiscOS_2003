/* released */

/*===============================================================================*/
/*                                                                               */
/*                      FILE:        join                                        */
/*                      VERSION:     3.07                                        */
/*                      DATE:        16 May, 1994.                               */
/*                                                                               */
/*-------------------------------------------------------------------------------*/
/*  DIFFERENCES BETWEEN CURRENT VERSION AND PREVIOUS VERSION:                    */
/*  PREVIOUS VERSION: 3.06                                                       */
/*-------------------------------------------------------------------------------*/
/*                                                                               */
/*  In the previous version it was a requirement that the string "frames per     */
/*  second" be present along with the actual value in the header.  This          */
/*  requirement no longer applies.                                               */
/*                                                                               */
/*-------------------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
#include "swis.h"
#include "kernel.h"
#include "join.h"
#include "my_adpcm.h"

int end_of_source_data[50];
int oldtotfile;
int samples_to_adpcm = FALSE;
int samples_to_adpcm_stereo = FALSE;
_kernel_oserror *error;

static int indexTable[16] = {
    -1, -1, -1, -1, 2, 4, 6, 8,
    -1, -1, -1, -1, 2, 4, 6, 8,
};

static int stepsizeTable[89] = {
    7, 8, 9, 10, 11, 12, 13, 14, 16, 17,
    19, 21, 23, 25, 28, 31, 34, 37, 41, 45,
    50, 55, 60, 66, 73, 80, 88, 97, 107, 118,
    130, 143, 157, 173, 190, 209, 230, 253, 279, 307,
    337, 371, 408, 449, 494, 544, 598, 658, 724, 796,
    876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,
    2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,
    5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,
    15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767
};

struct adpcm_state state[10][2]; /* first index is the track no. */
int filename_len, max_arfilename_len;
boolean format2[10];  /* array index is the track number (so ignore */
                      /* index zero).  Value is true if header being*/
                      /* used to build the movie says format 2 for  */
                      /* that track.                                */
boolean stereo[10];   /* true if stereo, false otw.  index is track */
                      /* no. as above.                              */
boolean change_sample_rate = FALSE;
int new_srate;
char new_srate_str[10];
int im_fptr2;
int sent_out_state_info[10];
 unsigned char *outbuffx_odds, *outbuffx_evens;
 short *inbuffx_odds, *inbuffx_evens;
 unsigned char *outbuff;
char bps16to4 = FALSE;
char *keepline = NULL;
/*---------------------------------------------------------------------------------*/
int main(int argc,char *argv[])

{double fps = 0,fpc = 0;
 int spritesize,flag = 0,oddmaxsize = 0,evenmaxsize = 0,KeyFileSize = 0,
      numbering_of_sound_files = 1, numbering_of_sample_files = 1,
      numbering_of_adpcm_files = 1,t,sndchannels=0,sound_compression;
 int xx;  char *buffer;
 char ch;    
 char *sload;
 int no_sound;
 int num_of_movie_files = 1;
 int snd_period;
 char add4,add8;
 
     
     atexit(close_files);    
     for (i = 0; i < MAX_TRACKS; ARFileHandles2[i] = 0, i++);
     for (i = 0; i < MAX_TRACKS; newARFileHandles[i] = 0, i++);
     
     for (i = 0; i < MAX_TRACKS; i++)
     {
          state[i][0].valprev = 0; state[i][1].valprev = 0;
          state[i][0].index = 0;   state[i][1].index = 0;
     }
     
     process_command_line_args(argc,argv,&num_of_movie_files);  
     spritesize = get_sprite_size();
    
     fps = get_frames_per_sec();
    
     
     ReadHeader();

     
     if (header_line5[0] == '0')
     {
         NumOfVideoChannelsToPutIntoMovie = -1;
     }    
     
     if (header_line10[0] == '0')
     {
         no_sound = TRUE;
     }    
     else 
     {       
         no_sound = FALSE;
     }    
     
     block_sizes(&oddmaxsize,&evenmaxsize);
     
     NumOfVideoChannelsToPutIntoMovie = z - 1;
     if (header_line5[0] == '0')
     {
         NumOfVideoChannelsToPutIntoMovie = -1; 
     }
     
     if (dokeys) 
     {   
         KeyFileSize = GetKeyFileSize();
     }
     sprintf(load,"%sImages0.00",source);  /* For date stamp later on. */
     tracks = get_number_of_soundtracks();
  
     if (header_line5[0] == '0' && tracks > 1)
     {
         tracks = 1;
     }    
     if (sound_source == ARMOVIE_FILE)
     {   
      /* Check that enough soundtracks exist in accordance with
         header information specified by user.  */
        
               buffer = calloc(MAX_LINE,sizeof(char));
               if (buffer == NULL)
               {  
                   printf("Fatal Error:  Insufficient memory.\n");
                   printf("              %d more bytes required.\n",MAX_LINE);
                   exit(0);
               }    
 
               for (xx = 0; xx < num_of_movie_files; xx++)
               {
                    if (xx >= 10)
                    {
                        printf("Fatal Error:  Exceeded max. no. of movie files.\n");
                        exit(0);
                    }    
             
                    if ((ARMovie_fptr[xx] = fopen(movie_snd_src[xx],"r")) == NULL)
                    {                 
                         printf("Fatal error: Unable to read %s\n",movie_snd_src[xx]);
                         exit(0);
                    }
         
                 /* Find out no. of soundtracks in this movie. */
                    init_str(buffer,MAX_LINE);
                    movie_tracks[xx] = 1;
                    for (t = 1; t <= 10;t++) 
                    {
                         init_str(buffer,MAX_LINE);
                         fgets(buffer,MAX_LINE,ARMovie_fptr[xx]);
                         if (strlen(buffer) > MAX_LINE - 3)
                         {
                             PROG_ID;
                             printf("Fatal Error:  Line too long in header.\n");
                             exit(0);
                         }    
                    }
                 /* no. of soundtracks is no. of | characters + 1 */
                    for (t = 0; t < strlen(buffer); t++)
                    {
                         if (buffer[t] == '|')
                         {
                             movie_tracks[xx] = movie_tracks[xx] + 1;
                         }    
                    }
                    fclose(ARMovie_fptr[xx]);
               }
          
               no_of_soundtracks = 0; xx = 0;
               while (xx < num_of_movie_files)
               {
                      no_of_soundtracks = no_of_soundtracks + movie_tracks[xx];
                      xx++;
               }
          
               if (no_of_soundtracks < tracks)
               {
                   printf("Fatal Error: Insufficient number of soundtracks:\n");
                   printf("             %sHeader indicates %d sound tracks are required.\n",
                                         source,tracks);
                   printf("             Could only find %d.\n",no_of_soundtracks);
                   putchar('\n');
                   exit(0);
               } 
               
               free(buffer);
     } /* end of check to see if enough soundtracks exist. */         
    
     fpc = get_frames_per_chunk();
     chunktime = fpc / fps;
     sndsize = 0.0;
     
     for (i = 0; i < MAX_TRACKS; format2[i] = FALSE, i++);  
     for (i = 0; i < MAX_TRACKS; stereo[i] = FALSE, i++);
           
     for (i = 1; i <= tracks; i++) 
     {   
          sound_compression = fn_a(header_line10,i);
          if (sound_compression > 2)
          {
              PROG_ID;
              printf("Fatal Error:  Unknown sound compression format identifier in header.\n");
              printf("              (line 10) track %d\n",i);
              printf("              Format identifier has been read as %d\n",sound_compression);
              printf("              Expecting 0 (no sound), 1 (old format), or 2 (new format).\n");
              printf("              See document ToUseSound for further info.\n");
              exit(0);
          }    
   
          if (sound_compression == 1 || sound_compression == 2)
          { 
              if (sound_compression == 2)
              {
                  format2[i] = TRUE;
              }    
              snd_period = fn_a(header_line11,i);  /* sound rate */
       
              if (snd_period > 255)
              {
                  a_sndsize[i] = snd_period * chunktime;
              }    
              else 
              { 
                  a_sndsize[i] = 1E6/snd_period * chunktime;
              }
              sndchannels = fn_a(header_line12,i);
              if (sndchannels == 2)
              {
                  stereo[i] = TRUE;
              } 
              else
              if (sndchannels != 1 && sndchannels != 0)
              {
                  PROG_ID;
                  printf("Fatal Error:  Header line 12, track %d\n",i);
                  printf("              Expecting 1 (mono) or 2 (stereo).\n");
                  printf("              Number of sound channels read as %d\n",
                                         sndchannels);
                  exit(0);
              }       
                
              sndbits[i] = fn_a(header_line13,i); /* Bits per sample */
  
           /* Determine whether or not user wants to convert from samples to adpcm. */
              if (sndbits[i] == 16 && format2[i] && stereo[i])
              {
                  samples_to_adpcm_stereo = TRUE;
              }
              else
              if (sndbits[i] == 16 && format2[i] && !stereo[i])
              {
                  samples_to_adpcm = TRUE;
              }
              else
              if (sndbits[i] != 16 && sndbits[i] != 4 && format2[i])
              {
                  PROG_ID;
                  printf("Fatal Error: If header specifies sound format 2 adpcm\n");
                  printf("             then bits per sample should be 4 for no\n");
                  printf("             change, or 16 for compression down to 4\n");
                  printf("             bits per sample format 2.\n");
                  exit(0);
              }         
              

              if (samples_to_adpcm_stereo || samples_to_adpcm)
              {
                  /* Check that the compression is valid.  i.e. check that the */
                  /* source sound is not already at 4 bits per sample in which */
                  /* case further compression would result in error.           */
               
                     if (sound_source == ARMOVIE_FILE)
                     {
                         if ((ARMovie_fptr[0] = fopen(movie_snd_src[0],"r")) == NULL)
                         {
                              printf("Warning: Unable to check that compression is acceptable.\n");
                              printf("         If sound is wrong on playback or if program\n");
                              printf("         aborts, check that sound being used to build\n");
                              printf("         the ARMovie is at 16 bits per sample and NOT\n");
                              printf("         at 4 or 8 bits per sample.\n");
                         }    
                         else
                         {
                              /* For compression to be valid, sound format in */
                              /* source ARMovie should be "2 adpcm" and bits  */
                              /* per sample should be 16.                     */
                                 
                                 if ((buffer = calloc(MAX_LINE,sizeof(char)))==NULL)
                                 {
                                      printf("Fatal Error: Insufficient memory.\n");
                                      printf("             %d more bytes required.\n",MAX_LINE);
                                      exit(0);
                                 }     
                                 for (xx = 1; xx <= 10; xx++)
                                 {
                                      init_str(buffer,MAX_LINE);
                                      fgets(buffer,MAX_LINE,ARMovie_fptr[0]);
                                      if (strlen(buffer) == 0 || strlen(buffer) > MAX_LINE-3)
                                      {
                                          printf("Fatal Error: Line too long in source header.\n");
                                          exit(0);
                                      }
                                 }
                                 
                                 if ((keepline = calloc(MAX_LINE,sizeof(char)))==NULL)
                                 {
                                      printf("Fatal Error: Insufficient memory.\n");
                                      printf("             %d more bytes required.\n",MAX_LINE);
                                      exit(0);
                                 }     
                                 
                                 rewind(ARMovie_fptr[0]);
                                 for (xx = 1; xx <= 13; xx++)
                                 {
                                      init_str(keepline,MAX_LINE);
                                      
                                      fgets(keepline,MAX_LINE,ARMovie_fptr[0]);
                                      if (strlen(keepline) == 0 || strlen(keepline) > MAX_LINE-3)
                                      {
                                          printf("Fatal Error: Line too long in source header.\n");
                                          exit(0);
                                      }
                                 }
                                 
                                 rewind(ARMovie_fptr[0]);
                                 for (xx = 1; xx <= 10; xx++)
                                 {
                                      init_str(buffer,MAX_LINE);
                                      fgets(buffer,MAX_LINE,ARMovie_fptr[0]);
                                      if (strlen(buffer) == 0 || strlen(buffer) > MAX_LINE-3)
                                      {
                                          printf("Fatal Error: Line too long in source header.\n");
                                          exit(0);
                                      }
                                 }
                                      
                                 
                                
                                 if ((strstr(buffer,"2 adpcm")) != NULL)
                                 {
                                     printf("Warning: Compression will result in error.\n");
                                     printf("         Sound format in ARMovie source file is \n");
                                     printf("         2 adpcm i.e. sound is already at 4 bits\n");
                                     printf("         per sample.  Join proceeding without\n");
                                     printf("         compression.\n");
                                     
                                     samples_to_adpcm_stereo = FALSE;
                                     samples_to_adpcm = FALSE;
                                     sndbits[1] = 4;
                                     format2[1] = TRUE;
                                     
                                     /* USER'S header says "2 adpcm".  Needs to stay */
                                     /* this way but 16 bits per sample needs to be  */
                                     /* changed down to 4 bits per sample.           */
                                        
                                        bps16to4 = TRUE;
                                   
                                  }    
                                  else
                                  {
                                     /* Do one more further check to see if compression */
                                     /* is valid.  Check that bits per sample is 16.    */
                                     
                                        for (xx = 11; xx <= 13; xx++)
                                        {
                                             init_str(buffer,MAX_LINE);
                                             fgets(buffer,MAX_LINE,ARMovie_fptr[0]);
                                             if (strlen(buffer) == 0 || 
                                                 strlen(buffer) > MAX_LINE-3)
                                             {
                                                 printf("Fatal Error: Line too long in source header.\n");
                                                 exit(0);
                                             }
                                        }
                                        
                                        if ((strstr(buffer,"16")) == NULL)
                                        {
                                            printf("Warning: Compression will result in error.\n");
                                            printf("         Bits per sample in ARMovie sound\n");
                                            printf("         source should be 16.  Compression \n");
                                            printf("         from bits per sample other than 16\n");
                                            printf("         will result in error.  Join proceeding\n");
                                            printf("         without compression.\n");
                                            sndbits[1] = 4;
                                            bps16to4 = TRUE;
                                            samples_to_adpcm_stereo = FALSE;
                                            samples_to_adpcm = FALSE;
                                            format2[1] = TRUE;
                                            
                                        }
                                  }
                                  
                                  free(buffer);  fclose(ARMovie_fptr[0]);             
                         }                           
                     }
              }    
  
              if ((samples_to_adpcm && sndbits[i] == 16) || 
                  (samples_to_adpcm_stereo && sndbits[i] == 16))
              {   
                   sndbits[i] = 4;
              }
              else
              if ((samples_to_adpcm && sndbits[i] == 8) || 
                       (samples_to_adpcm_stereo && sndbits[i] == 8))
              {
                        printf("Doesn't convert from Sound to Adpcm (8 to 4) ...\n");
                        exit(0);
              }
              else if ((samples_to_adpcm && sndbits[i] == 4) || 
                       (samples_to_adpcm_stereo && sndbits[i] == 4))
              {
                        samples_to_adpcm = FALSE; 
                        samples_to_adpcm_stereo = FALSE;
              }               
  
              a_sndsize[i] = a_sndsize[i] * sndchannels * sndbits[i] / 8;
              sndsize = sndsize + a_sndsize[i];
              old_sndsize[i] = a_sndsize[i];        
              buffer = calloc(strlen(source)+strlen(myindex)+15,sizeof(char));
              if (buffer == NULL)
              {
                  printf("Fatal Error:  Insufficient memory.\n");
                  printf("              %d more bytes required.\n",strlen(source)+15);
                  exit(0);
              }         
              init_str(buffer,strlen(source)+strlen(myindex)+15); 
      
              if (sound_source == SOUND_FILE)
              {   
                  if (samples_to_adpcm || samples_to_adpcm_stereo)
                      sndbits[i] = 16;
                 
                  switch (sndbits[i])
                  {
                     case 8 : sprintf(buffer,"%s%sSound",source,myindex);
                              if (numbering_of_sound_files > 1)
                              {
                                  int_to_str(numbering_of_sound_files);
                                  strcat(buffer,str_z);
                                  numbering_of_sound_files++;
                              }    
                              
                       
                              inregs.r[0] = 0x40;
                              inregs.r[1] = (int)buffer;
                              error = _kernel_swi(OS_Find,&inregs,&outregs);
                              newARFileHandles[i] = outregs.r[0];
                              if (error != NULL || newARFileHandles[i] == NULL)
                              {
                                  PROG_ID;
                                  printf("Fatal Error: Failure opening sound file.\n");
                                  printf("             Line 13 in your header ");
                                  printf("indicates that\n");
                                  printf("             %s\n",buffer);
                                  printf("             is required.\n");
                                  printf("             (line 13 in header: 16 bits per sample\n");
                                  printf("                                 looks for ""Samples""\n\n");
                                  printf("                                 8 bits per sample\n");
                                  printf("                                 looks for ""Sound""\n\n");
                                  printf("                                 4 bits per sample\n");
                                  printf("                                 looks for ""Adpcm)""\n\n");
                                  exit(0);
                              }    
                              else
                              if (header_line5[0] == '0')
                              {   /* i.e. if sound only.  If sound only, tracks will */
                                  /* have already been set to 1 so temp_fptr (which  */
                                  /* only gets used in sound_only() ) only opens up  */
                                  /* one file.                                       */
                                
                                  inregs.r[0] = 0x40;
                                  inregs.r[1] = (int)buffer;
                                  error = _kernel_swi(OS_Find,&inregs,&outregs);
                                  if (error != NULL)
                                  {
                                      PROG_ID;
                                      printf("Fatal Error: cannot open %s\n",buffer);
                                  }    
                                  temp_fptr = outregs.r[0];
                            
                                  if (temp_fptr == NULL)
                                  {   
                                      printf("Fatal Error: Unable to open %s\n",
                                              buffer);
                                      exit(0);
                                  }    
                              }
                              if (numbering_of_sound_files == 1)
                              {
                                  sload = calloc(strlen(source)+10,sizeof(char));
                                  if (sload == NULL)
                                  {
                                      PROG_ID;
                                      printf("Fatal Error:  Insufficient memory.\n");
                                      printf("              %d more bytes required.\n",
                                                             strlen(source)+10);
                                      exit(0);
                                  }                                           
                                  sprintf(sload,"%sSound",source);
                                  numbering_of_sound_files++; 
                              }
                              break;
                              
                    case 16 : sprintf(buffer,"%s%sSamples",source,myindex); 
                              if (numbering_of_sample_files > 1)
                              {
                                  int_to_str(numbering_of_sample_files);
                                  strcat(buffer,str_z);
                                  numbering_of_sample_files++;
                              }
                             
                       
                              inregs.r[0] = 0x40;
                              inregs.r[1] = (int)buffer;
                              error = _kernel_swi(OS_Find,&inregs,&outregs);
                              newARFileHandles[i] = outregs.r[0];
                              if (error != NULL || newARFileHandles[i] == NULL)
                              {
                                  PROG_ID;
                                  printf("Fatal Error: Failure opening %s\n",
                                          buffer);
                                  printf("             Line 13 in your header ");
                                  printf("indicates that ");
                                  printf("%s is required.\n",buffer);
                                  printf("             (line 13 in header: ");
                                  printf("16 bits per sample - looks for Samples)\n");
                                  printf("             (                    ");
                                  printf("8 bits per sample - looks for Sound  )\n");
                                  printf("             (                    ");
                                  printf("4 bits per sample - looks for Adpcm  )\n");
                                  exit(0);
                               }      
                               else
                               if (header_line5[0] == '0')
                               {  
                                  inregs.r[0] = 0x40;
                                  inregs.r[1] = (int)buffer;
                                  error = _kernel_swi(OS_Find,&inregs,&outregs);
                                  if (error != NULL)
                                  {
                                      PROG_ID;
                                      printf("Fatal Error: Cannot open samples file\n");
                                      exit(0);  
                                  }    
                                  temp_fptr = outregs.r[0];
                            
                                  if (temp_fptr == NULL)
                                  {    
                                      printf("Fatal Error: Unable to open %s\n",
                                                           buffer);
                                      exit(0);
                                  }     
                               }
                               if (numbering_of_sample_files == 1)
                               {
                                   sload = calloc(strlen(source)+10,sizeof(char));
                                   if (sload == NULL)
                                   {
                                       PROG_ID;
                                       printf("Fatal Error: Insufficient memory.\n");
                                       printf("             %d more bytes required.\n",
                                                              strlen(source)+10);
                                       exit(0);
                                   }                            
                                   sprintf(sload,"%sSamples",source);
                                   numbering_of_sample_files++;
                               }
                               break;
              
                      case 4 : sprintf(buffer,"%s%sAdpcm",source,myindex);
                               if (numbering_of_adpcm_files > 1)
                               {
                                   int_to_str(numbering_of_adpcm_files);
                                   strcat(buffer,str_z);
                                   numbering_of_adpcm_files++;
                               }
                             
                               inregs.r[0] = 0x40;
                               inregs.r[1] = (int)buffer;
                               error = _kernel_swi(OS_Find,&inregs,&outregs);
                               newARFileHandles[i] = outregs.r[0];
                               if (error != NULL || newARFileHandles[i] == NULL)
                               {
                                   PROG_ID;
                                   printf("Fatal Error: Failure opening %s\n",
                                           buffer);
                                   printf("             Line 13 in your header ");
                                   printf("indicates that ");
                                   printf("%s is required.\n",buffer);
                                   printf("             (line 13 in header: ");
                                   printf("16 bits per sample - looks for Samples)\n");
                                   printf("             (                    ");
                                   printf("8 bits per sample - looks for Sound  )\n");
                                   printf("             (                    ");
                                   printf("4 bits per sample - looks for Adpcm  )\n");
                                   exit(0);
                               }      
                               else
                               if (header_line5[0] == '0')
                               {  
                                   inregs.r[0] = 0x40;
                                   inregs.r[1] = (int)buffer;
                                   error = _kernel_swi(OS_Find,&inregs,&outregs);
                                   if (error != NULL)
                                   {
                                       PROG_ID;
                                       printf("Fatal Error: Cannot open Adpcm file\n");
                                       exit(0);
                                   }    
                                   temp_fptr = outregs.r[0];
                            
                                   if (temp_fptr == NULL)
                                   {
                                       printf("Fatal Error: Unable to open %s\n",
                                               buffer);
                                       exit(0);
                                   }      
                               }
                               if (numbering_of_adpcm_files == 1)
                               {
                                   sload = calloc(strlen(source)+10,sizeof(char));
                                   if (sload == NULL)
                                   {
                                       PROG_ID; 
                                       printf("Fatal Error: Insufficient memory.\n");
                                       printf("             %d more bytes required.\n",
                                                               strlen(source)+10);
                                       exit(0);
                                   }       
                                   sprintf(sload,"%sAdpcm",source);
                                   numbering_of_adpcm_files++;
                               }         
                               break;
                  } /* end switch */
                  
                  if (samples_to_adpcm || samples_to_adpcm_stereo)
                      sndbits[i] = 4;
              
              }  /* End if sound source == sound file */
          
          } /* End if sound comp. == 1 or 2 */                                                               
     
     } /* End of for i = 1 while i <= tracks. */
  
 
     if (evenmaxsize != 0)                      
     {
         
         evenmaxsize = (int)sndsize + evenmaxsize + 1;
         add8 = 0; add4 = 0;
         for (i = 1; i <= tracks; i++)
         {
              if (format2[i])
              {
                  if (stereo[i])
                  {
                      evenmaxsize = evenmaxsize + 8;
                  }
                  else
                  {
                      evenmaxsize = evenmaxsize + 4;
                  }
              }
         }
             
       
     }
     if (oddmaxsize != 0)
     {
         oddmaxsize = (int)sndsize + oddmaxsize + 1;
         add8 = 0; add4 = 0;
         for (i = 1; i <= tracks; i++)
         {
              if (format2[i])
              {
                  if (stereo[i])
                  {
                      oddmaxsize = oddmaxsize+8;
                  }
                  else
                  {
                      oddmaxsize = oddmaxsize+4;
                  }
              }
          }
                   
     }
     rewind(h_ptr);
 
     if (dest[0] == '\0') /* if dest not specified .... */
     {  
         sprintf(dest,"JoinOp");    
         strcat(dest,"\0");
      
         
        
      } /* END OF IF DEST NOT SPECIFIED. */
      
     
  
 
  chunksize = evenmaxsize;
  if (oddmaxsize > chunksize) 
  {
      chunksize = oddmaxsize;  
  }      
  
  output_header();
  fclose(h_ptr);   
  
  /* If there is video with sound or video without sound ... */
  if (NumOfVideoChannelsToPutIntoMovie >= 0) 
  {
      video(evenmaxsize,oddmaxsize,spritesize,KeyFileSize,sound_compression,
            num_of_movie_files);
  }    
  else
  {   
      if (sound_source == ARMOVIE_FILE)
      {
          sprintf(load,"%s",movie_snd_src[0]);
      }    
      else 
      if (sound_source == SOUND_FILE)
      {
          sprintf(load,"%s",sload); 
        
          free(sload);
      }       
      sound_only(spritesize,num_of_movie_files);
  } 
 
  load_and_execute();
  
}
/*---------------------------------------------------------------------------------*/
void process_command_line_args(int argc,char *argv[],int *num_of_movie_files)

{int clargs_buffer_size = 0;
 char *clargs_buffer,*extra_args,*all_args;
 char *arg_ptr;
 char size[20];
 char movie_files[10];
 int q;
 
 
 for (i = 1; i <= argc; i++)
 {
      clargs_buffer_size = clargs_buffer_size + strlen(argv[i-1]);
      clargs_buffer_size++; /* Allow for insertion of space later on. */
 }
 
 clargs_buffer_size++; /* Add extra byte for null terminating character. */
 clargs_buffer = calloc(clargs_buffer_size,sizeof(char));
 if (clargs_buffer == NULL)
 {
     printf("Fatal Error: Insufficient memory. \n");
     printf("             %d more bytes required.\n",clargs_buffer_size);
     exit(0);
 }    
 
 init_str(clargs_buffer,clargs_buffer_size);
 for (i = 1; i <= argc; i++)
 {
      strcat(clargs_buffer,argv[i-1]);
      strcat(clargs_buffer," ");
 }
 if (strlen(clargs_buffer) > 0)
 {
     clargs_buffer[strlen(clargs_buffer)-1] = '\0';
 }
     
 /* Command line args are in clargs_buffer. Now need to add on anything in */
 /* the environment variable.                                              */
 
    extra_args = getenv("Join$ExtraArgs");
    
    
    if (extra_args == NULL)
    {
        all_args = calloc(clargs_buffer_size + 3,sizeof(char));
    }
    else
    {      
        all_args = calloc(clargs_buffer_size + strlen(extra_args) + 3,
                          sizeof(char));
    }    
   
    
    if (all_args == NULL)
    {
        printf("Fatal Error: Insufficient memory.\n");
        printf("             %d more bytes required.\n",
                 clargs_buffer_size+strlen(extra_args)+3);
        exit(0);
    }    
    
    sprintf(all_args,"%s",clargs_buffer);
    if (extra_args != NULL)
    {
        strcat(all_args," ");        /* Without this line, if command line is */
                                     /* join206 -source $.whatever and        */
                                     /* join$ExtraArgs is -dest wherever then */
                                     /* end up with Fatal Error, can't open   */
                                     /* ...whatever-dest.Sprite.  Need to     */
                                     /* separate the -dest.                   */
        strcat(all_args,extra_args);
    }
  
   
    if (((arg_ptr = strstr(all_args,"-nokeys")) == NULL) &&
        ((arg_ptr = strstr(all_args,"-Nokeys")) == NULL) &&
        ((arg_ptr = strstr(all_args,"-NOKEYS")) == NULL))
    {
         dokeys = TRUE;
         
    }     
    else 
    {
         dokeys = FALSE;
         
    }     
    
    if (((arg_ptr = strstr(all_args,"-source")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-SOURCE")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-Source")) != NULL))
    {
         
            while (*arg_ptr != '\0' && *arg_ptr != ' ')   
            {    
                 /* Skip past -source to the next space. */                                         
                    arg_ptr++;    
            }                             
            
            if (*arg_ptr == '\0')
            {
                 printf("Fatal Error: Source not specified.\n");
                 printf("             Syntax: -source name_of_source_directory\n");
                 exit(0);
            }     
    
            while (*arg_ptr == ' ' && *arg_ptr != '\0')   
            {
                 /* Move to source name. */
                    arg_ptr++;
            }         
            
            if (*arg_ptr == '\0' || *arg_ptr == '-')
            {
                 printf("Fatal Error: Source not specified.\n");
                 printf("             Syntax: -source name_of_source_directory\n");
                 exit(0);
            }     
    
            i = 0;
            while (*arg_ptr != ' ' && *arg_ptr != '\0')
            {
                   source[i] = *arg_ptr;
                   arg_ptr++;
                   i++;
            }
            source[i] = '\0';                       
    }
    
    if (((arg_ptr = strstr(all_args,"-adpcm")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-Adpcm")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-ADPCM")) != NULL))
    {
          samples_to_adpcm = TRUE;
    }    
    
    if (((arg_ptr = strstr(all_args,"-stereo")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-Stereo")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-STEREO")) != NULL))
    {
          samples_to_adpcm_stereo = TRUE;
    }          
    
    if (((arg_ptr = strstr(all_args,"-index")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-INDEX")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-Index")) != NULL))
    {
         while (*arg_ptr != ' ' && *arg_ptr != '\0')
         {
                arg_ptr++;
         }
         
         if (*arg_ptr == '\0' || *arg_ptr == '-')
         {
              printf("Warning: Index parameter given without a value.\n");
              printf("         Ignoring index.\n");
              goto IGNORE_INDEX;     
         }     
                
         while (*arg_ptr == ' ')
         {
                arg_ptr++;
         }       
         if (*arg_ptr == '\0' || *arg_ptr == '-')
         {
              printf("Warning: Index parameter given without a value.\n");
              printf("         Ignoring index.\n");
              goto IGNORE_INDEX;      
         }        
                
         i = 0;
         while (*arg_ptr != ' ')
         {       
                myindex[i] = *arg_ptr++; i++;
         }
         myindex[i] = '\0';
    }
    
    IGNORE_INDEX:
   
    if (((arg_ptr = strstr(all_args,"-dest")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-DEST")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-Dest")) != NULL))
    {
         while (*arg_ptr != ' ' && *arg_ptr != '\0')
         {    
                arg_ptr++;
         }       
         
         if (*arg_ptr == '\0' || *arg_ptr == '-')
         {
              printf("Fatal Error:  Illegal syntax for -dest.\n");
              printf("              Either don't type -dest at all ");
              printf("or specify the destination.\n");
              printf("              e.g. -dest $.Movies.newmovie\n");
              exit(0);     
         }       
                
         while (*arg_ptr == ' ' && *arg_ptr != '\0' && *arg_ptr != '-')
         {
                arg_ptr++;
         }       
         if (*arg_ptr == '\0' || *arg_ptr == '-')
         {
              printf("Fatal Error:  Illegal syntax for -dest.\n");
              printf("              Either don't type -dest at all ");
              printf("or specify the destination.\n");
              printf("              e.g. -dest $.Movies.newmovie\n");
              exit(0);  
         }       
                
         i = 0;
         while (*arg_ptr != ' ')
         {       
                dest[i] = *arg_ptr++; i++;
         }           
         dest[i] = '\0';
    }
    
         
    if (((arg_ptr = strstr(all_args,"-size")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-Size")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-SIZE")) != NULL))
    {
         while (*arg_ptr != ' ' && *arg_ptr != '\0' && *arg_ptr != '\n') 
         {
                arg_ptr++;
         }       
         if (*arg_ptr == '-' || *arg_ptr == '\0' || *arg_ptr == '\n')
         {
              printf("Warning: Illegal syntax for -size.\n");
              printf("         size parameter used without specifying a value.\n");
              printf("         Setting size to default value (2047).\n");
              goto IGNORE_SIZE;
         }            
                
         while (*arg_ptr == ' ' && *arg_ptr != '-' && *arg_ptr != '\0')
         {
                arg_ptr++;
         }
         if (*arg_ptr == '-' || *arg_ptr == '\0')
         {
              printf("Warning: Illegal syntax for -size.\n");
              printf("         size parameter used without specifying a value.\n");
              printf("         Setting size to default value (2047).\n");
              goto IGNORE_SIZE;
         }            
                
         i = 0;
         while (*arg_ptr != ' ' && *arg_ptr != '\n' && *arg_ptr != '\0')
         {      
                
                if (i > 15)
                {
                    PROG_ID;
                    printf("Fatal Error:  Size is too big.\n");
                    exit(0);
                }    
               
                if (!isdigit(*arg_ptr))
                {
                    PROG_ID;
                    printf("Fatal Error: Reading size value.\n");
                    printf("             %c is not a number.\n",(char)*arg_ptr);
                    exit(0);
                }         
                size[i] = *arg_ptr++; i++;
         }
         size[i] = '\0';
         secsize = atoi(size);
    }
    IGNORE_SIZE:
   
    if (((arg_ptr = strstr(all_args,"-help")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-HELP")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-Help")) != NULL))
       
    {
         Help(); exit(0);
    }     
    
    if (((arg_ptr = strstr(all_args,"-srate")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-Srate")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-SRATE")) != NULL))
    {
          change_sample_rate = TRUE;
          
          /* Get the new sample rate. */
          /* -----------------------  */
          
          /* Bypass "-srate" */
             for (i = 1; i <= 6; arg_ptr++,i++);
             
          /* arg_ptr now at character immediately after the e */
             if (*arg_ptr == '\n' || *arg_ptr == '\0')
             {
                  PROG_ID;
                  printf("Fatal Error: New sample rate not specified.\n");
                  exit(0);
             }
          /* bypass space/s */
             while (!(isdigit(*arg_ptr)) && *arg_ptr != '\n' && *arg_ptr != '\0')
             {
                      arg_ptr++;  
                     
             }
             if (*arg_ptr == '\n' || *arg_ptr == '\0' || !isdigit(*arg_ptr))
             {
                  PROG_ID;
                  printf("Fatal Error: New sample rate not specified.\n");
                  printf("             or new sample rate is illegal.\n");
                  exit(0);
             }
            
             for (i = 0; i < 10; new_srate_str[i] = '\0',i++);
             i = 0;
             while (isdigit(*arg_ptr))
             {
                    new_srate_str[i] = *arg_ptr;
                    
                    i++; arg_ptr++;
             }   
             
                          
             new_srate = atoi(new_srate_str);
              
    }    
    
    if (((arg_ptr = strstr(all_args,"-armovie")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-Armovie")) != NULL) ||
        ((arg_ptr = strstr(all_args,"-ARMOVIE")) != NULL))
    {
      /* Skip past -armovie. */
         while (*arg_ptr != ' ' && *arg_ptr != '\0')
         {    
                arg_ptr++;   
         }             
         if (*arg_ptr == '\0' || *arg_ptr == '-' || *arg_ptr == '\n')
         {
              printf("Fatal Error: Illegal syntax for -armovie.\n");
              printf("             -armovie N armovie source file/s\n");
              printf("              e.g. -armovie 2 $.Movies.armovie1 ");
              printf("$.Movies.armovie2\n");
              exit(0);
         }            
                
         while (*arg_ptr == ' ' && *arg_ptr != '\0' && *arg_ptr != '\n')    /* Bypass space/s.     */
         {
                 arg_ptr++;
         }        
         if (*arg_ptr == '-' || !isdigit(*arg_ptr) || *arg_ptr == '\n')
         {
              printf("Fatal Error: Illegal syntax for -armovie.\n");
              printf("             -armovie N armovie source file/s\n");
              printf("              e.g. -armovie 2 $.Movies.armovie1 ");
              printf("$.Movies.armovie2\n");
              printf("              (N was missing).\n");
              exit(0);
         }            
                 
         i = 0; 
             
         while (isdigit(arg_ptr[i]))
         {      
                movie_files[i] = *arg_ptr++;
                i++;
         }
         movie_files[i] = '\0';
         *num_of_movie_files = atoi(movie_files);
         max_arfilename_len = 0;
         
         for (i = 1; i <= *num_of_movie_files; i++) /* Get file names. */
         {
             
              while (*arg_ptr == ' ' && *arg_ptr != '\0' && *arg_ptr != '\n')  /* By pass space/s */
              {
                     arg_ptr++;
              }       
              if (*arg_ptr == '\0' || *arg_ptr == '-' || *arg_ptr == '\n')
              {
                   printf("Fatal Error: Illegal syntax for -armovie.\n");
                   printf("             Number of Armovie source files ");
                   printf("(N in -armovie N filename/s), does ");
                   printf("not match\n");
                   printf("              number of source files ");
                   printf("specified after the N.\n");
                   exit(0);
              }            
                     
              q = 0;       
              while (*arg_ptr != ' ' && *arg_ptr != '\n' && *arg_ptr != '\0')    
              {
                     movie_snd_src[i-1][q] = *arg_ptr++; q++;
              }
              movie_snd_src[i-1][q] = '\0';   
              
              filename_len = q+3;
              if (filename_len > max_arfilename_len)
              {
                  max_arfilename_len = filename_len;
              }    
         }
         sound_source = ARMOVIE_FILE;
    }     
    
  /* If source specified, append a full stop (if there isn't one already) */
  /* -------------------------------------------------------------------- */
  
     if ((source[strlen(source)-1] != '.') && (strlen(source) > 0)) 
     {
          source[strlen(source)] = '.';
     }
     else if ((strlen(source) == 0) || source[0] == '\0')
          {
               printf("Fatal Error: Source not specified.\n");
               printf("             Syntax: -source name_of_source_directory\n");
               exit(0);
          }          
  
    
}
/*----------------------------------------------------------------------------------*/
int get_sprite_size(void)
{char *sprite;
  
  sprite = calloc(strlen(source)+10,sizeof(char));
  if (sprite == NULL)
  {
      PROG_ID;
      printf("Fatal Error: Insufficient memory.\n");
      printf("             %d more bytes required.\n",strlen(source) + 10);
      exit(0);
  }
  init_str(sprite,strlen(source)+10);    
  sprintf(sprite,"%sSprite",source);
  
  /* Get sprite size */
  /* --------------- */
    
  if ((sprite_fptr = fopen(sprite,"r")) != NULL)   
  {  
       fseek(sprite_fptr,0,SEEK_END);   /* Sprite exists - find its size */
  }     
  else 
  {      printf("Fatal Error: Unable to open %s\n",sprite);
         exit(0);
  }

  free(sprite);
  return((int)ftell(sprite_fptr));
}
/*----------------------------------------------------------------------------------*/
int GetKeyFileSize(void)
{int KeyFileSize = 0;
 char *KeysFile;
 
      KeysFile = calloc(strlen(source)+strlen(myindex)+15,sizeof(char));
      if (KeysFile == NULL)
      {
          PROG_ID;
          printf("Fatal Error: Insufficient memory.\n");
          printf("             %d more bytes required.\n",
                                 strlen(source)+strlen(myindex)+15);
          exit(0);
      }
      init_str(KeysFile,strlen(source)+strlen(myindex)+15);                           
      sprintf(KeysFile,"%s%sKeys0.00",source,myindex);
     
      if ((fptr = fopen(KeysFile,"r")) != NULL) 
      {                                              
           /* File exists */
           fseek(fptr,0,SEEK_END);
           KeyFileSize = (int)ftell(fptr);
           fclose(fptr);
      }
      else
      {     KeyFileSize = 0;
           /* printf("Couldn't find %s\n",KeysFile);*/
      } 
   
      free(KeysFile);
      return KeyFileSize;    
  }
/*----------------------------------------------------------------------------------*/
void block_sizes(int *oddmaxsize,int *evenmaxsize)

{int directory = 0;  /* directory is 0 for image files 00 to 76,
                        directory is 1 for the next 76 image files,
                        and so on. Reason for this is that the maximum
                        number of files in a directory is 75. So after
                        Images0.76 we move on to Images 1.00            
                     */   
 int fnum = 0;
 int err_check;
 char *ImageFile;
 boolean file_exists;
 int a_size = 0;
 
 ImageFile = calloc(strlen(source) + strlen(myindex) + 20,sizeof(char));
 if (ImageFile == NULL)
 {
     PROG_ID;
     printf("Fatal Error: Insufficient memory.\n");
     printf("             %d more bytes required.\n",
                            strlen(source)+strlen(myindex)+20);
     exit(0);
 }    
 init_str(ImageFile,strlen(source)+strlen(myindex)+20);
 sprintf(ImageFile,"%s%sImages0.00",source,myindex);
 
 if ((a_fptr = fopen(ImageFile,"r")) == NULL && header_line5[0] != '0')
 {  
      printf("Fatal Error: Header indicates that images are required but ");
      printf("none were found.\n");
      printf("            (Looking for %s)\n",ImageFile);
      exit(0);
 }      
 else
 {
      fclose(a_fptr);
 }     

 /* Scan image files to work out biggest block sizes */
    z = -1;
        
    do  { z++;
    
          /* Build path and file name.  e.g. ===> */
          /* 1st time round: $.DataToJoin.Images0.00 */
          /* 2nd time round: $.DataToJoin.Images0.01 */
          /* 3rd time round: $.DataToJoin.Images0.02 */
          /* etc.                                    */
             init_str(ImageFile,strlen(source) + strlen(myindex) + 20);
             sprintf(ImageFile,"%s%sImages",source,myindex);
             
          
          if ((z % 77 == 0) && ( z != 0))
          {
              directory++;
              fnum = 0;
          }    
          int_to_str(directory);
          strcat(ImageFile,str_z);    
          strcat(ImageFile,".");    
          int_to_str(fnum);
          init_str(str_z2,100);
          str_z2[0] = '0'; str_z2[1] = '\0';
          strcat(str_z2,str_z);  strcat(str_z2,"\0");
          ImageFile[strlen(ImageFile)] = str_z2[strlen(str_z2)-2];
          
          ImageFile[strlen(ImageFile)] = str_z2[strlen(str_z2)-1];
          
         
          /**/ 
          
          /* Find out if ImageFile exists - if it does find its length */
          file_exists = NO;
     
          if ((a_fptr = fopen(ImageFile,"r")) != NULL) 
          {             
                                    
               /* File exists - find its length */
                  a_size = 0;
                  fseek(a_fptr,0,SEEK_END);
                  a_size = (int)ftell(a_fptr); 
                  
                  fclose(a_fptr);
                  
                  
               /* Image chunks must end on even boundaries. */
               /* Add a zero if necessary.                  */                  
                  
                  if (a_size % 2 != 0)
                  {
                      if ((a_fptr = fopen(ImageFile,"a")) != NULL)
                      {
                           err_check = fputc(0,a_fptr);
                           a_size++;
                           if (err_check == EOF)
                           {
                                printf("Warning: Image file ends on uneven boundary.\n");
                                printf("         Write failure in correcting this.\n");
                                a_size--;
                           }
                           fclose(a_fptr);     
                      }
                      else
                      {
                           printf("Warning: Image file ends on uneven boundary.\n");
                           printf("         File open (append) failure in correcting this.\n");
                      }                        
                  }
                  
                  file_exists = YES;
	  }
	  
	  s[z] = a_size;
	  
	  if (file_exists) 
	  {
	      if (z % 2 == 0)
	      {
	          if (a_size > *evenmaxsize) 
	          {
	              *evenmaxsize = a_size;
	          }    
	      } 
	      else 
	      { 
	         if (a_size > *oddmaxsize)
	         {
	              *oddmaxsize = a_size;
	         }    
              }   
           }      
     fnum++;     
  } while (file_exists);  
 
  free(ImageFile);
  	
}
/*----------------------------------------------------------------------------------*/
double get_frames_per_sec(void)
{int chk_eof;
 char *buffer;
 char fps_str[300];
 int line_count = 0;
  
  sprintf(header_file,"%s%sHeader",source,myindex);
  
  if ((h_ptr = fopen(header_file,"r")) != NULL)
  {    
      
       rewind(h_ptr);
       chk_eof = feof(h_ptr);
       buffer = calloc(MAX_LINE,sizeof(char));
       if (buffer == NULL)
       {
           printf("Fatal Error: Insufficient memory.\n");
           printf("             Reading frames per sec. from header.\n");
           printf("             %d more bytes required.\n",MAX_LINE * sizeof(char));
           exit(0);
       }    
       while ((chk_eof == 0) && 
              (line_count != 9)) 
       {           
               init_str(buffer,MAX_LINE);     
               fgets(buffer,MAX_LINE,h_ptr);
     
               if ((strstr(buffer,"\n"))==NULL)
               {
                    printf("Fatal Error: Reading frames per sec. from header.\n");
                    printf("             Line too long (max: %d characters, including spaces).\n",
                                         MAX_LINE - 3);    
                    printf("             or incomplete header.\n");                                  
                    exit(0);
               }     
               chk_eof = feof(h_ptr);
               line_count++;
       }       
 
       init_str(fps_str,100);
  
       for (i = 0; i < 80; i++) 
       {
            if (isdigit(buffer[i]) || buffer[i] == '.') 
            {
                fps_str[i] = buffer[i];
            }
       }
  
       fps_str[i] = '\0';  
    } 
    else  
    {
       printf("Fatal Error: Unable to read %s\n",header_file);
       exit(0);
    }  
  
    free(buffer);
    return(atof(fps_str));
}
/*----------------------------------------------------------------------------------*/
double get_frames_per_chunk(void)
{int chk_eof;
 char *buffer;

  buffer = calloc(MAX_LINE,sizeof(char));
  if (buffer == NULL)
  {
      printf("Fatal Error: Insufficient memory.\n");
      printf("             Reading frames per chunk from header.\n");
      printf("             %d more bytes required.\n",MAX_LINE);
      exit(0);
  }    
  chk_eof = feof(h_ptr);
  init_str(buffer,MAX_LINE);
 
   
  while ((chk_eof == 0) && (strstr(buffer, "frames per chunk") == NULL)) 
  {
          init_str(buffer,MAX_LINE);
          fgets(buffer,MAX_LINE,h_ptr);
          if ((strstr(buffer,"\n"))==NULL || strlen(buffer) > MAX_LINE - 3)
          {
               printf("Fatal Error: Reading frames per chunk from header.\n");
               printf("             Line too long (max: %d characters, including spaces).\n",
                                    MAX_LINE - 3);
               printf("             or new line character not found.\n");
               printf("             Header should end with a carriage return immediately\n");
               printf("             after frames per chunk.\n");                  
               exit(0);
          }     
          chk_eof = feof(h_ptr);
  }
  
  init_str(fpc_str,100);
  
  for (i = 0; i < 80; i++) 
  {
       if (isdigit(buffer[i])||buffer[i]=='.') 
       {
           fpc_str[i] = buffer[i];
       }
  }
 
  free(buffer);
  fpc_str[i] = '\0'; 
  return(atof(fpc_str));
}
/*---------------------------------------------------------------------------------*/
void ReadHeader(void)
{
  rewind(h_ptr);
  for (i = 1; i <= 10; i++)
  {
       init_str(header_line10,MAX_LINE);
       fgets(header_line10,MAX_LINE,h_ptr);
       if (strlen(header_line10) > MAX_LINE - 3)
       {
           PROG_ID;
           printf("Fatal Error: Line too long in header.\n");
           printf("             Max: %d\n",MAX_LINE-3);
           printf("             Current length is %d\n",strlen(header_line10));
           exit(0);
       }    
  }     
  init_str(header_line11,MAX_LINE);
  init_str(header_line12,MAX_LINE);
  init_str(header_line13,MAX_LINE);
  
  fgets(header_line11,MAX_LINE,h_ptr);
  if (strlen(header_line11) > MAX_LINE - 3)
  {
      PROG_ID;
      printf("Fatal Error: Line too long in header.\n");
      printf("             Max: %d\n",MAX_LINE-3);
      printf("             Currently: %d\n",strlen(header_line11));
      exit(0);
  }    
 
  fgets(header_line12,MAX_LINE,h_ptr);
  if (strlen(header_line12) > MAX_LINE - 3)
  {
      PROG_ID;
      printf("Fatal Error: Line too long in header.\n");
      printf("             Max: %d\n",MAX_LINE-3);
      printf("             Currently: %d\n",strlen(header_line12));
      exit(0);
  }    
 
 
  fgets(header_line13,MAX_LINE,h_ptr);
  if (strlen(header_line13) > MAX_LINE - 3)
  {
      PROG_ID;
      printf("Fatal Error: Line too long in header.\n");
      printf("             Max: %d\n",MAX_LINE-3);
      printf("             Currently: %d\n",strlen(header_line13));
      exit(0);
  }    
 
  
  rewind(h_ptr);
  for (i = 1; i <= 5; i++)
  {
       init_str(header_line5,MAX_LINE);
       fgets(header_line5,MAX_LINE,h_ptr);
       if (strlen(header_line5) > MAX_LINE - 3)
       {
           PROG_ID;
           printf("Fatal Error: Line too long in header.\n");
           printf("             Max: %d\n",MAX_LINE-3);
           printf("             Currently: %d\n",strlen(header_line5));
           exit(0);
       }    
  }
 
}
/*--------------------------------------------------------------------------------*/
void output_header(void)
{char *stoa;
 char *buffer;

  buffer = calloc(MAX_LINE,sizeof(char));
  if (buffer == NULL)
  {  
      PROG_ID;
      printf("Fatal Error: Insufficient memory.\n");
      printf("             %d more bytes required.\n",MAX_LINE);
      exit(0);
  }    
  
  inregs.r[0] = 0x80;
  inregs.r[1] = (int)dest;
  error = _kernel_swi(OS_Find,&inregs,&outregs);
  
  
  if (error != NULL)
  {
      PROG_ID;
      printf("Fatal Error: Error returned from _kernel_swi(OS_Find)\n");
      exit(0);
     
  }   
   
  dest_fptr2 = outregs.r[0];
  
  if (dest_fptr2 == NULL)
  {  
      printf("Fatal Error: Unable to write to %s\n",dest);
      exit(0);
  }    
  
  rewind(h_ptr);
  
  for (i = 1; i <= 12; i++) 
  {
          
       init_str(buffer,MAX_LINE);
       fgets(buffer,MAX_LINE,h_ptr);
       
       if (strlen(buffer) > MAX_LINE - 3)
       {
           PROG_ID;
           printf("Fatal Error: Line too long in header.\n");
           printf("             Reading line %d\n",i);
           exit(0);
       }  
       
       inregs.r[0] = 2;
       inregs.r[1] = dest_fptr2;
       inregs.r[2] = (int)buffer;
       inregs.r[3] = strlen(buffer);
       error = _kernel_swi(OS_GBPB,&inregs,&outregs);
       if (error != NULL)
       {
           PROG_ID;
           printf("Fatal Error: Error returned from _kernel_swi(OS_GBPB).\n");
           printf("             Disc may be full.\n");
           exit(0);
       }    
  }     
  
  init_str(buffer,MAX_LINE);
  if (samples_to_adpcm || samples_to_adpcm_stereo || bps16to4)
  {
     /* bps16to4:  if this is true,                                 */
     /* user tried to compress from 16 bps down to 4bps using sound */
     /* from an ARMovie but the sound was already at 4bps.  Join    */
     /* is therefore proceeding without compression but user's      */
     /* header needs to be changed from 16 bps down to 4 bps.       */
  
      fgets(buffer,MAX_LINE,h_ptr);
      if (strlen(buffer) > MAX_LINE - 3)
      {
          PROG_ID;
          printf("Fatal Error: Line too long in header.\n");
          exit(0);
      }    
          
      if (bps16to4)
      {
          init_str(buffer,MAX_LINE);
          sprintf(buffer,keepline);
          free(keepline);
      }
      else
      {        
          
      /* Replace all the 16's with 4's */
         stoa = strstr(buffer,"16");
         while (stoa != NULL && (int)stoa <= (int)buffer + MAX_LINE - 3)
         {
                *stoa++ = '4';  
                if (*stoa != '\n')
                    *stoa = ' ';
                stoa = strstr(stoa,"16");
         }
       }  
  }
  else
  {
      fgets(buffer,MAX_LINE,h_ptr);
      if (strlen(buffer) > MAX_LINE - 3)
      {
          PROG_ID;
          printf("Fatal Error: Line too long in header.\n");
          exit(0);
      }    
  }
          
  inregs.r[0] = 2;
  inregs.r[1] = dest_fptr2;
  inregs.r[2] = (int)buffer;
  inregs.r[3] = strlen(buffer);
  error = _kernel_swi(OS_GBPB,&inregs,&outregs);
  if (error != NULL)
  {
      PROG_ID;
      printf("Fatal Error: Error returned from _kernel_swi(OS_GBPB)\n");
      printf("             Disc may be full.\n");
      exit(0);
      
  }    
  init_str(buffer,MAX_LINE);
  fgets(buffer,MAX_LINE,h_ptr);
  if (strlen(buffer) > MAX_LINE - 3)
  {
      PROG_ID;
      printf("Fatal Error: Line too long in header.\n");
      exit(0);
  }    
  inregs.r[0] = 2;
  inregs.r[1] = dest_fptr2;
  inregs.r[2] = (int)buffer;
  inregs.r[3] = strlen(buffer);
  error = _kernel_swi(OS_GBPB,&inregs,&outregs);
  if (error != NULL)
  {
      PROG_ID;
      printf("Fatal Error: - error code returned from _kernel_swi(OS_GBPB)\n");
      exit(0);  
  }  
 
  free(buffer);
}
/*----------------------------------------------------------------------------------*/
void video(int evenmaxsize, int oddmaxsize, int spritesize,
           int KeyFileSize,int sound_compression,int num_of_movie_files)
{int directory = 0, biggest_schunk = 0, read_in, *ibuffer, zeroes,
     fnum = 0, no_output, lastone, icnt;          
 char *ptr_myj;

 short *inbase, *in; 

 int current_file = 0;
 int wflg = 0;
 int ss,t;
 char *ImageFile;
 int ImageFileSize;
 int res;
 int ij;
 char *buffer;
 char *KeysFile;
 unsigned char *myj_ptr2;
 int myj;
 char *op;
 boolean video_data = YES;
 void *io_buffer;
 int int_d;
 int guess,int_a,int_b,int_c;
 int next_byte_pos;
 int int_stime;
 int total_snd_in_src;
 
      if (NumOfVideoChannelsToPutIntoMovie == 0)   
      {
          KeyFileSize = 0;  
      }    
     
      buffer = calloc(30,sizeof(char));
      if (buffer == NULL)
      {
          PROG_ID;
          printf("Fatal Error: Insufficient memory.\n");
          printf("             %d more bytes required.\n",30);
          exit(0);
      }
      init_str(buffer,30); 


        
      sprintf(buffer,"%d number of chunks\n",NumOfVideoChannelsToPutIntoMovie);
      
 
      inregs.r[0] = 2;
      inregs.r[1] = dest_fptr2;
      inregs.r[2] = (int)buffer;
      inregs.r[3] = strlen(buffer);
      error = _kernel_swi(OS_GBPB,&inregs,&outregs);
      if (error != NULL)
      {
          PROG_ID;
          printf("Fatal Error: Error code returned from OS_GBPB\n");
          printf("             Disc may be full.\n");
          exit(0);
         
      }    
      init_str(buffer,30);
      sprintf(buffer,"%d even chunk size\n",evenmaxsize);
      inregs.r[0] = 2;
      inregs.r[1] = dest_fptr2;
      inregs.r[2] = (int)buffer;
      inregs.r[3] = strlen(buffer);
      error = _kernel_swi(OS_GBPB,&inregs,&outregs);
      if (error != NULL)
      {
          PROG_ID;
          printf("Fatal Error: Error code returned from OS_GBPB\n");
          printf("             Disc may be full.\n");
          exit(0);
          
      }    
      init_str(buffer,30);
      sprintf(buffer,"%d odd chunk size\n",oddmaxsize);
      inregs.r[0] = 2;
      inregs.r[1] = dest_fptr2;
      inregs.r[2] = (int)buffer;
      inregs.r[3] = strlen(buffer);
      error = _kernel_swi(OS_GBPB,&inregs,&outregs);
      if (error != NULL)
      {
          PROG_ID;
          printf("Fatal Error: Error code returned from OS_GBPB\n");
          printf("             Disc may be full.\n");
          exit(0);
      } 
    
      free(buffer);
      sprintf(a,"XXXXXXX catalogue offset");
      sprintf(b,"XXXXXXX offset to sprite");
      
      int_to_str(spritesize);
      init_str(c,100); strcpy(c,str_z); strcat(c," size of sprite\n"); 
      init_str(d,100); strcpy(d,"XXXXXXX offset to keys");
 
      
      inregs.r[0] = 0;
      inregs.r[1] = dest_fptr2;
      error = _kernel_swi(OS_Args,&inregs,&outregs);
      if (error != NULL)
      {
          PROG_ID;
          printf("Fatal Error: Reading file pointer.\n");
          printf("             OS_Args failure\n");
          printf("             Unable to read current position in output file.\n");
          exit(0);
      }       
     
      int_b = outregs.r[2] - 1;  
     
     
      int_b = int_b + (int)strlen(a) + (int)strlen(b) + 
                      (int)strlen(c) + (int)strlen(d) + 3;

      int_to_str(int_b);
      init_str(b,100);
      strcat(b,str_z); strcat(b," offset to sprite\n");
  
      int_d = int_b + spritesize;
    
      if (KeyFileSize) 
      {
          init_str(d,100);
          int_to_str(int_d);
          strcat(d,str_z);
          strcat(d," offset to keys\n");
      } else
          {init_str(d,100);
           strcpy(d,"-1 (no keys)\n");
          }       
    
      int_a = int_d + NumOfVideoChannelsToPutIntoMovie * KeyFileSize;
     
      int_to_str(int_a);
      init_str(a,100);
      strcpy(a,str_z); strcat(a," catalogue offset\n");
     
      inregs.r[0] = 2;
      inregs.r[1] = dest_fptr2;
      inregs.r[2] = (int)a;
      inregs.r[3] = strlen(a);
      error = _kernel_swi(OS_GBPB,&inregs,&outregs);
      if (error != NULL)
      {
          PROG_ID;
          printf("Fatal Error: Error code returned from OS_GBPB\n");
          printf("             Disc may be full.\n");
          exit(0);
      }    
      inregs.r[0] = 2;       inregs.r[1] = dest_fptr2;
      inregs.r[2] = (int)b;  inregs.r[3] = strlen(b);
      error = _kernel_swi(OS_GBPB,&inregs,&outregs);
      if (error != NULL)
      {  
          PROG_ID;
          printf("Fatal Error: Error code returned from OS_GBPB\n");
          printf("             Disc may be full.\n");
          exit(0);
      }     
      inregs.r[0] = 2;       inregs.r[1] = dest_fptr2;
      inregs.r[2] = (int)c;  inregs.r[3] = strlen(c);
      error = _kernel_swi(OS_GBPB,&inregs,&outregs); 
      if (error != NULL)
      {
          PROG_ID;
          printf("Fatal Error: Error code returned from OS_GBPB\n");
          printf("             Disc may be full.\n");
          exit(0);
      }    
      inregs.r[0] = 2;       inregs.r[1] = dest_fptr2;
      inregs.r[2] = (int)d;  inregs.r[3] = strlen(d);
      error = _kernel_swi(OS_GBPB,&inregs,&outregs);
      if (error != NULL)
      {
          PROG_ID;
          printf("Fatal Error: Error code returned from OS_GBPB\n");
          printf("             Disc may be full.\n");
          exit(0);
      }    
     
      
    
      inregs.r[0] = 0;
      inregs.r[1] = dest_fptr2;
      error = _kernel_swi(OS_Args,&inregs,&outregs);
      if (error != NULL)
      {
          PROG_ID;
          printf("Fatal Error: Reading file pointer.\n");
          printf("             OS_Args failure.\n");
          printf("             Unable to read current position in output file.\n");
          exit(0);
      }        
      next_byte_pos = outregs.r[2] - 1; 
      
 
      ss = int_b - next_byte_pos;
     
     ibuffer = malloc(ss * 4);
     if (ibuffer == NULL)
     {
         printf("Fatal Error: Insufficient memory.\n");
         printf("             %d more bytes required.\n",ss*4);
         exit(0);
     }    
     for (j = 0; j < ss-1; j++)
     {
           *(ibuffer + j) = 0;
     }
     
      inregs.r[0] = 2;           inregs.r[1] = dest_fptr2;
      inregs.r[2] = (int)ibuffer; inregs.r[3] = ss-1;
      error = _kernel_swi(OS_GBPB,&inregs,&outregs); 
      if (error != NULL)
      {
          PROG_ID;
          printf("Fatal Error: Error code returned from OS_GBPB\n");
          printf("             Disc may be full.\n");
          exit(0);
      } 
       
      free(ibuffer);   
     
  /* Output the sprite */
  
   io_buffer = malloc(spritesize);
   if (io_buffer == NULL)
   {
       printf("Fatal Error: Insufficient memory.\n");
       printf("             %d more bytes required.\n",spritesize);
       exit(0);
   }    
   rewind(sprite_fptr);
   read_in = spritesize;
   res = fread(io_buffer,sizeof(char),spritesize,sprite_fptr);
   
   inregs.r[0] = 2;              inregs.r[1] = dest_fptr2;
   inregs.r[2] = (int)io_buffer; inregs.r[3] = spritesize;
   error = _kernel_swi(OS_GBPB,&inregs,&outregs);
   if (error != NULL)
   {
       PROG_ID;
       printf("Fatal Error: Error code returned from OS_GBPB\n");
       printf("             Disc may be full.\n");
       exit(0);
   }    
   fclose(sprite_fptr);
  
   free(io_buffer);
  
      if (KeyFileSize)
      {
      /* Output the keys information */
      
         KeysFile = calloc(strlen(source)+strlen(myindex)+30,sizeof(char));
         if (KeysFile == NULL)
         {
             PROG_ID;
             printf("Fatal Error: Insufficient memory.\n");
             printf("             %d more bytes required.\n",
                                    strlen(source)+strlen(myindex)+30);
             exit(0);
         }                  
         
         for (Z = 0; Z <= NumOfVideoChannelsToPutIntoMovie -1; Z++)
         {
              if ((Z % 77 == 0) && (Z != 0))
              {
                  directory++;
                  fnum = 0;
              } 
              init_str(KeysFile,strlen(source)+strlen(myindex)+30);   
              sprintf(KeysFile,"%s%sKeys%1d.%02d",source,myindex,directory,fnum);
              fnum++;
              
              inregs.r[0] = 0x40;
              inregs.r[1] = (int)KeysFile;
              error = _kernel_swi(OS_Find,&inregs,&outregs);
              if (error != NULL)
              {
                  PROG_ID;
                  printf("Fatal Error: Unable to read keys file %s\n",KeysFile);
                  exit(0);
              }
              keys_fptr = outregs.r[0];
              
              if (keys_fptr != NULL)
              {                                        
                   /* Get size of keys file */
                   
                   inregs.r[0] = 2;
                   inregs.r[1] = keys_fptr;
                   error = _kernel_swi(OS_Args,&inregs,&outregs);
                   if (error != NULL)
                   {
                       printf("Fatal Error: Unable to read size of keys file %s\n",
                               KeysFile);
                       exit(0);
                   }    
                   KeyFileSize = outregs.r[2];
                   
                   
                   /*rewind(keys_fptr);
                   fseek(keys_fptr,0,SEEK_END);
                   KeyFileSize = ftell(keys_fptr);
                     
                   rewind(keys_fptr);
                   */
               
                   io_buffer = malloc(KeyFileSize);
                   if (io_buffer == NULL)
                   {
                       printf("Fatal Error: Insufficient memory.\n");
                       printf("             %d more bytes required.\n",KeyFileSize);
                       exit(0);
                   }
                   
                   inregs.r[0] = 4;
                   inregs.r[1] = keys_fptr;
                   inregs.r[2] = (int)io_buffer;
                   inregs.r[3] = KeyFileSize;
                   error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                   if (error != NULL)
                   {
                       printf("Fatal Error: Swi failure (OS_GBPB)\n");
                       printf("             Unable to read keys into memory.\n");
                       printf("             Allocation of memory for\n");
                       printf("             transfer of data was successful.\n");
                       exit(0);
                   }
                       
                   inregs.r[0] = 2; inregs.r[1] = dest_fptr2; 
                   inregs.r[2] = (int)io_buffer; inregs.r[3] = KeyFileSize;
                   error = _kernel_swi(OS_GBPB,&inregs,&outregs); 
                   if (error != NULL)
                   {
                       printf("Fatal Error: Unable to write keys data to ARMovie.");
                       printf("             Disc may be full.\n");
                       exit(0);
                   }    
                   
                   free(io_buffer); 
                   
                   /*fclose(keys_fptr);*/
                   inregs.r[0] = 0;
                   inregs.r[1] = keys_fptr;
                   error = _kernel_swi(OS_Find,&inregs,&outregs);
                   if (error != NULL)
                   {
                       printf("Fatal Error: Unable to close keys file.\n");
                       exit(0);
                   }
                   keys_fptr = 0;
                      
              }
              else
              {    printf("Fatal Error: Unable to read keys file%s\n",KeysFile);
                   exit(0);
              }                       
         }
         
         free(KeysFile); 
      }
      
   

        
        /* zeroes get written direct to file so can ignore. */
           if (sound_source == ARMOVIE_FILE)
           {
               
               biggest_schunk = initialisation_for_reading_sound_ARMOVIE_FILE(&current_file,&total_snd_in_src,
                                  num_of_movie_files);
           
               current_file = 0;
           
               if (samples_to_adpcm || samples_to_adpcm_stereo)
                   op = malloc(chunksize + (biggest_schunk*4 * tracks));
               else
                   op = malloc(chunksize + (biggest_schunk * tracks));
               if (op == NULL)
               {
                   PROG_ID;
                   printf("Fatal Error: Insufficient memory.\n");
                   printf("             %d more bytes required.\n",
                                          chunksize+(biggest_schunk*tracks));
                   exit(0);
               }                         
           }
      
      /* Now at a, ready for catalogue. */
      /* 1st compute how long the catalogue is */
      
       guess = (int_a + NumOfVideoChannelsToPutIntoMovie * 30 + secsize) & ~secsize; 
      
       biggest_schunk = 0;
  
       do { int_c = int_a;
            z = guess;
            for (i = 0; i < 150; stime[i] = 0.0, i++);
            
            if (sound_source == ARMOVIE_FILE)
            {   current_file = 0;
               
                biggest_schunk = initialisation_for_reading_sound_ARMOVIE_FILE(&current_file,&total_snd_in_src,
                       num_of_movie_files);
                
            }         
         
   
            for (i = 0; i < 50; end_of_source_data[i] = 0,i++);
           
            for (Z = 0; Z <= NumOfVideoChannelsToPutIntoMovie; Z++) 
            {    
                 init_str(n,100);
                 int_to_str(z);
                 strcpy(n,str_z);
                 strcat(n,",");
                 int_to_str(s[Z]);
                 strcat(n,str_z);
                 strcat(n,";");  
                 
                
                 if (tracks) 
                 {
                     for (i = 1; i <= tracks; i++) 
                     {                        
                          
                          stime[i] = stime[i] + a_sndsize[i];
                          if (a_sndsize[i] == 0) 
                          {   
                              stime[i] = 0;                        
                          }
                          schunk = (int)stime[i];
                          
                          
                              
                          if (sound_source == SOUND_FILE && schunk%2 != 0 && schunk != 0)
                              schunk--;
                          
                       /* Check to see if there's enough sound in the
                          source file.  If there isn't enough sound,
                          modify schunk accordingly.                  */
                         
                         if (sound_source == ARMOVIE_FILE)
                         {
                             no_output = 1;
                            
                             lastone = sound_io_ARMOVIE_FILE(no_output,op,&myj,video_data);
                             
                             if (end_of_source_data[i] == TRUE)
                             {      
                                 schunk = lastone;
                                 a_sndsize[i] = schunk;     
                             }    
                            
                             
                             no_output = 0;
                         }    
                         else
                         {
                             
                             lastone = check_enough_sound(wflg,sound_compression);
                            
                             if (end_of_source_data[i])
                             {   
                                 schunk = lastone;
                                
                                 if (schunk % 2 != 0 && schunk != 0)
                                     schunk--;
                                 a_sndsize[i] = schunk;
                             }
                             
                             if (biggest_schunk < schunk)
                                 biggest_schunk = schunk;
                         }        
                          
                         stime[i] = 0;
                         z = z + schunk;
                        
                          if (i > 1) 
                          {
                              strcat(n,"|");
                              int_to_str(i);
                              strcat(n,str_z);
                              strcat(n," ");
                              if (format2[i] && stereo[i] && schunk != 0)
                              {
                                  int_to_str(schunk+8);
                              }
                              else
                              if (format2[i] && !(stereo[i]) && schunk != 0)
                              {
                                  int_to_str(schunk+4);
                              }
                              else
                              {
                                  int_to_str(schunk);
                              }        
                                  
                              strcat(n,str_z);
                              
                                
                          }
                          else
                             {  
                                if (format2[i] && stereo[i] && schunk != 0)
                                {
                                    int_to_str(schunk+8);      
                                }
                                else
                                if (format2[i] && !(stereo[i]) && schunk != 0)
                                {
                                    int_to_str(schunk+4);  
                                }
                                else
                                {        
                                    int_to_str(schunk);
                                }
                                strcat(n,str_z);
                                
                             }
                     } 
                                  
                  }
        
             int_c = int_c + strlen(n) + 1;
             
             z = (z + s[Z] + secsize) & ~secsize;  
         
             }
             
             guess = guess + secsize + 1;
        } while (int_c >= guess); 

        if (sound_source == SOUND_FILE)
        {
               op = malloc(chunksize + (biggest_schunk * tracks));
               
               if (op == NULL)
               {
                   PROG_ID;
                   printf("Fatal Error: Insufficient memory.\n");
                   printf("             %d more bytes required.\n",
                                        chunksize+(biggest_schunk*tracks));
                   exit(0);
               }                         
        }
         
 
        z = (int_c + secsize) & ~secsize;
        for (i = 0; i < 150; stime[i] = 0.0, i++);

   for (ij = 1; ij < 10; a_sndsize[ij] = old_sndsize[ij],ij++);
   
   if (sound_source == ARMOVIE_FILE)
   {        
       current_file = 0;
      
       initialisation_for_reading_sound_ARMOVIE_FILE(&current_file,&total_snd_in_src,
            num_of_movie_files); 
           
   }         
   if (sound_source == SOUND_FILE)
   {
       ij = 1;
       while (newARFileHandles[ij] != 0)
       {
              inregs.r[0] = 1;
              inregs.r[1] = newARFileHandles[ij];
              inregs.r[2] = 0;
              error = _kernel_swi(OS_Args,&inregs,&outregs);
              if (error != NULL)
              {
                  printf("Fatal Error: swi failure (OS_Args).\n");
                  exit(0);
              }    
              ij++;
       }
   }           
                  /* 26/4/94 */
        for (i = 0; i < 50; end_of_source_data[i] = FALSE,i++);
    for (i = 1; i <10; a_sndsize[i] = old_sndsize[i],i++);     
    
    for (Z = 0; Z <= NumOfVideoChannelsToPutIntoMovie; Z++) 
        {  
             int_to_str(z);
            
             init_str(n,100);
             strcpy(n,str_z); strcat(n,",");
             int_to_str(s[Z]);
             strcat(n,str_z);
             strcat(n,";");
             
             if (tracks) 
             {
                
                 for (i = 1; i <= tracks; i++) {
 
                      
                      stime[i] = stime[i] + a_sndsize[i];
                      if (a_sndsize[i] == 0)
                      {
                          stime[i] = 0;
                      }    
                      schunk = (int)stime[i];
                      if (sound_source == SOUND_FILE && schunk % 2 != 0 && schunk != 0)
                          schunk--;
                      
                      /* Check to see if there's enough sound in the
                         source file.  If there isn't enough sound,
                         modify schunk accordingly.                  */
                         
                         if (sound_source == ARMOVIE_FILE)
                         {
                             no_output = 1;
                             lastone = sound_io_ARMOVIE_FILE(no_output,op,&myj,video_data);
                             
                             if (end_of_source_data[i] == TRUE)
                             {   
                                 schunk = lastone;
                                 a_sndsize[i] = schunk;
                             }    
                             
                             no_output = 0;
                         }    
                         else
                         {
                             
                              lastone = check_enough_sound(wflg,sound_compression);
                             
                              if (end_of_source_data[i])
                              {
                                  schunk = lastone;
                                  
                                  if (schunk % 2 != 0 && schunk != 0)
                                      schunk--;
                      
                                  a_sndsize[i] = schunk;
                              }
                         }             
                             
                    
                      stime[i] = /*stime[i] - schunk*/ 0;  
                      z = z + schunk;
                      
                      if (i > 1) 
                      {
                          strcat(n,"|");
                          int_to_str(i);
                          strcat(n,str_z);
                          strcat(n," ");
                          if (format2[i] && stereo[i] && schunk != 0)
                          {
                              int_to_str(schunk+8);
                          }
                          else
                          if (format2[i] && !(stereo[i]) && schunk != 0)
                          {
                              int_to_str(schunk+4);
                          }
                          else
                          {        
                              int_to_str(schunk);
                          }
                          strcat(n,str_z);
                      }
                      else {  if (format2[i] && stereo[i] && schunk != 0)
                              {
                                  int_to_str(schunk + 8);
                              }
                              else
                              if (format2[i] && !(stereo[i]) && schunk != 0)
                              {  
                                  int_to_str(schunk + 4);
                              }        
                              else
                              {
                                  int_to_str(schunk);
                              }    
                              strcat(n,str_z);
                           
                      }
                      
                 }
             }
            
             
             n[strlen(n)] = '\n';
           /*  n[strlen(n)] = '\0'; */  /* 26/4/94 */
             
             inregs.r[0] = 2; 
             inregs.r[1] = dest_fptr2;
             inregs.r[2] = (int)n; 
             inregs.r[3] = strlen(n);
             error = _kernel_swi(OS_GBPB,&inregs,&outregs);
             if (error != NULL)
             {
                 printf("Fatal Error: Writing out catalogue info.");
                 printf("             Write failure.\n");
                 printf("             Disc may be full.\n"); 
                 exit(0);
             }    
            
             z = (z + s[Z] + secsize) & ~secsize;
        }     

        z = (int_c + secsize) & ~secsize; int_stime = 0; schunk = 0;    
        

       for (ij = 1; ij < 10; a_sndsize[ij] = old_sndsize[ij],ij++);
      
        /* ss is the file no. */
           current_file = 0;  
        if (sound_source == ARMOVIE_FILE)
        {  
           
            initialisation_for_reading_sound_ARMOVIE_FILE(&current_file,&total_snd_in_src,
               num_of_movie_files);
             
        }    
        
        if (sound_source == SOUND_FILE)
        {
            ij = 1;
            while (newARFileHandles[ij] != 0)
            {
                   inregs.r[0] = 1;
                   inregs.r[1] = newARFileHandles[ij];
                   inregs.r[2] = 0;
                   error = _kernel_swi(OS_Args,&inregs,&outregs);
                   if (error != NULL)
                   {
                       printf("Fatal Error: OS_Args failure.");
                       exit(0);
                   }    
                   ij++;
            }
        }          
        
        directory = 0;    
    
    fnum = 0;
  
 
 if (samples_to_adpcm_stereo)
 {
 inbuffx_odds = calloc((biggest_schunk)*4/2,2); 
   
 if (inbuffx_odds == NULL)
 {
     PROG_ID;
     printf("Fatal Error: Insufficient memory.\n");
     printf("             %d more bytes required.\n",biggest_schunk*4/2*2);
     exit(0);
 }    


 inbuffx_evens = calloc((biggest_schunk)*4/2,2);
 if (inbuffx_evens == NULL)
 {
      PROG_ID;
      printf("Fatal Error: Insufficient memory.\n");
      printf("             %d more bytes required.\n",biggest_schunk*4/2*2);
      exit(0);
 }     
 

 
 outbuffx_odds = calloc(biggest_schunk,1);
 if (outbuffx_odds == NULL)
 {
     PROG_ID;
     printf("Fatal Error: Insufficient memory.\n");
     printf("             %d more bytes required.\b",biggest_schunk);
     exit(0);
 }
 
 outbuffx_evens = calloc(biggest_schunk,1);
 if (outbuffx_evens == NULL)
 {
     PROG_ID;
     printf("Fatal Error: Insufficient memory.\n");
     printf("             %d more bytes required.\b",biggest_schunk);
     exit(0);
 }           
  
 } /* end of if samples to adpcm stereo */ 
   /********************************************************************/
   
        for (i = 0; i < 150; stime[i] = 0.0,i++);
        for (i = 0; i < 50; end_of_source_data[i] = FALSE,i++);
        for (ij = 1; ij < 10; a_sndsize[ij] = old_sndsize[ij],ij++);   
        ImageFile = calloc(strlen(source)+strlen(myindex)+25,sizeof(char));
        if (ImageFile == NULL)
        {
            PROG_ID;
            printf("Fatal Error: Insufficient memory.\n");
            printf("             %d more bytes required.\n",
                                  strlen(source)+strlen(myindex)+25);
            exit(0);
        }    
        for (Z = 0; Z <= NumOfVideoChannelsToPutIntoMovie; Z++)
        {   	
          
             inregs.r[0] = 0; inregs.r[1] = dest_fptr2;
             error = _kernel_swi(OS_Args,&inregs,&outregs);
             if (error != NULL)
             {
                 printf("Fatal Error: Unable to read current position in output file.\n");
                 exit(0);
             }    
             next_byte_pos = outregs.r[2]-1;
             
             ss = z - next_byte_pos;
            
            
           ibuffer = malloc(ss * 4);     
           if (ibuffer == NULL)
           {
               printf("Fatal Error: Insufficient memory.\n");
               printf("             %d more bytes required.\n",ss*4);
               exit(0);
           }    

        
           for (j = 0; j < ss-1; j++)
           {
                       *(ibuffer + j) = 0;
           }            
             inregs.r[0] = 2; inregs.r[1] = dest_fptr2;
             inregs.r[2] = (int)ibuffer; inregs.r[3] = ss - 1;
             error = _kernel_swi(OS_GBPB,&inregs,&outregs);
             if (error != NULL)
             {
                  printf("Disc Full.");
                  exit(0);
             }     
             
             free(ibuffer); 
            

             if ((Z % 77 == 0) && (Z != 0))
             {
                  directory++;
                  fnum = 0;
             }     
             int_to_str(directory);
             sprintf(ImageFile,"%s%sImages%s.%02d" ,source,myindex,str_z,fnum);     
             fnum++;
     
             inregs.r[0] = 0x40;
             inregs.r[1] = (int)ImageFile;
             error = _kernel_swi(OS_Find,&inregs,&outregs);
             if (error != NULL)
             {
                 printf("Fatal Error: Unable to open image file %s\n",ImageFile);
                 exit(0);
             }    
          
             
             if (outregs.r[0] == 0)
             {
                 printf("Fatal Error: Unable to open %s\n",ImageFile);
                 exit(0);
             }
             im_fptr2 = outregs.r[0];
             
             /* Get size of image file */
             inregs.r[0] = 2;
             inregs.r[1] = im_fptr2;
             error = _kernel_swi(OS_Args,&inregs,&outregs);
             if (error != NULL)
             {
                 printf("Fatal Error: swi failure (OS_Args)\n");
                 printf("             Unable to read size of image file %s\n",ImageFile);
                 exit(0);
             }    
             ImageFileSize = outregs.r[2];
            
             /* Read image file into memory. */
             inregs.r[0] = 4;
             inregs.r[1] = im_fptr2;
             inregs.r[2] = (int)op;
             inregs.r[3] = ImageFileSize;
             error = _kernel_swi(OS_GBPB,&inregs,&outregs);
             if (error != NULL)
             {
                 printf("Fatal Error: swi failure (OS_GBPB).\n");
                 printf("             Unable to read image file into memory.\n");
                 printf("             Allocation of memory space was successful\n");
                 exit(0);
             }    
             if (outregs.r[3] != 0)
             {
                  printf("Fatal Error: %d bytes not transferred\n",outregs.r[3]);
                  printf("             Reading image file into memory.\n");
                  printf("             Allocation of memory was successful.\n");
                  exit(0);
             }     
             
             /* Close image file */
             inregs.r[0] = 0;
             inregs.r[1] = im_fptr2;
             error = _kernel_swi(OS_Find,&inregs,&outregs);
             if (error != NULL)
             {
                 PROG_ID;
                 printf("Fatal Error: Error code returned from OS_Find\n");
                 printf("             Unable to close image file.\n");
                 exit(0);
             }       
             im_fptr2 = 0;
            
             myj = ImageFileSize + (int)op;
             CHECK_OP_SPACE;
            
       
             if (tracks) 
             {
                
                 for (i = 1; i <= tracks; i++) 
                 { 
                      stime[i] = stime[i] + a_sndsize[i];
                     
                      if (a_sndsize[i] == 0)
                      {
                          stime[i] = 0;
                      }    
                      schunk = (int)stime[i];
                      if (sound_source == SOUND_FILE && schunk % 2 != 0 && schunk != 0)
                          schunk--;
                      
                      stime[i] = stime[i] - schunk;
                      
                      if (sound_source == ARMOVIE_FILE)
                      {  
                          sent_out_state_info[i] = NO;
                          if (format2[i] && !end_of_source_data[i])
                          {    
                               ptr_myj = (char *)myj;
                              *ptr_myj++ = state[i][0].valprev&0xFF; myj++;
                              *ptr_myj++ = state[i][0].valprev >> 8; myj++;
                              *ptr_myj++ = state[i][0].index;   myj++;
                              *ptr_myj++ = 0;  myj++;
                               if (stereo[i])
                               {
                                   *ptr_myj++ = state[i][1].valprev&0xFF; myj++;
                                   *ptr_myj++ = state[i][1].valprev >> 8; myj++;
                                   *ptr_myj++ = state[i][1].index;   myj++;
                                   *ptr_myj++ = 0;  myj++;
                               }
                               sent_out_state_info[i] = YES;
                          }         
                          lastone = sound_io_ARMOVIE_FILE(0,op,&myj,video_data); 
                          
                          if (sent_out_state_info[i] == YES && lastone == 0)
                          {
                              if (format2[i] && stereo[i])
                              {
                                  myj = myj - 8;
                              }
                              else
                              if (format2[i] && !stereo[i])
                              {
                                  myj = myj - 4;
                              }
                          }            
                          if (end_of_source_data[i] == TRUE)
                          {
                              schunk = lastone;
                              a_sndsize[i] = schunk;
                          }
                       
                          z = z + schunk;   
     
                                          
                                     
                      }                         
                      else
                          if (sound_source == SOUND_FILE && sound_compression != 0)
                          {    
                              if (newARFileHandles[i] != 0)
                              {
                                  amt_of_sound_written = 0;
                                  if (sndbits[i] == 8) /* fixed E26D4*/
                                  {                
                                      if (Z == 0)    /* Miss 1st character */
                                      {
                                          /*ch = fgetc(ARFileHandles[i]); */
                                          inregs.r[1] = newARFileHandles[i];
                                          error = _kernel_swi(OS_BGet,&inregs,&outregs);
                                          if (error != NULL)
                                          {
                                              printf("Fatal Error: swi failure (OS_BGet)\n");
                                              exit(0);
                                          }    
                                       }   
                                  }
                                  t = 0;
                                  
                                  if (samples_to_adpcm)
                                  {
                                      sent_out_state_info[i] = NO;  /* 1/5/94 */
                                      
                                      if (!end_of_source_data[i])
                                      {
                                      
                                          in = malloc((schunk)*4);
                                          if (in == NULL)
                                          {
                                              printf("Fatal Error: Insufficient memory.\n");
                                              printf("             %d more bytes required.\n",
                                                                   schunk * 4);
                                              exit(0);
                                          }     
                                          inbase = in; 
                                      
                                          inregs.r[0] = 4; 
                                          inregs.r[1] = newARFileHandles[i];
                                          inregs.r[2] = (int)in; 
                                          inregs.r[3] = (schunk) * 4;   
                                          error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                                          if (error != NULL)
                                          {
                                              printf("Fatal Error: swi failure (OS_GBPB)");
                                              printf("             Unable to read samples into memory.\n");
                                              printf("             Allocation of memory was successful.\n");
                                              exit(0);
                                          }    
                                          zeroes = outregs.r[3];
                                    
                                      
                                          while (zeroes % 4 != 0)
                                          {
                                                 zeroes--;
                                                
                                          }        
                                    
                                        
                                          ptr_myj = (char *)myj;     
                                      
                                         *ptr_myj++  = state[i][0].valprev&0xFF;
                                          myj++;
                                        
                                         *ptr_myj++  = state[i][0].valprev >> 8;
                                          myj++;
                                       
                                         *ptr_myj++  = state[i][0].index;
                                          myj++;
                                 
                                         *ptr_myj++ = 0;
                                          myj++;
                                          
                                          sent_out_state_info[i] = YES;  /* 1/5/94 */
                                      
                                          end_of_source_data[i] = FALSE; 
                                          if (zeroes > 0)
                                          {
                                              end_of_source_data[i] = TRUE;
                                             
                                          }
                                          
                                          /* 1/5/94 */
                                          if (sent_out_state_info[i] == YES &&
                                              zeroes == (schunk * 4))
                                          {
                                              myj = myj - 4; 
                                          }        
                                          
                                          adpcm_coder(in,(unsigned char *)myj,(((schunk)*4)-zeroes)/2,&state[i][0]);
                                          myj = myj + schunk  - (zeroes/4);
                                          
                                          CHECK_OP_SPACE;
                                          schunk = schunk - (zeroes/4);                                   
                                          a_sndsize[i] = schunk;
                                          z = z+schunk;
                                         
                                          free(inbase);
                                      }/* end of if not end of source data [i] */
                                                
                                    }/* end of if samples to adpcm */
                                  
                               
                                   /*************/
                         
         
                                   if (samples_to_adpcm_stereo)
                                   {  sent_out_state_info[i] = NO;
                                      if (!end_of_source_data[i])
                                      {  
                                         ptr_myj = (char *)myj;     
                                      
                                         *ptr_myj++  = state[i][0].valprev&0xFF;
                                          myj++;
                                        
                                         *ptr_myj++  = state[i][0].valprev >> 8;
                                          myj++;
                                       
                                         *ptr_myj++  = state[i][0].index;
                                          myj++;
                                 
                                         *ptr_myj++ = 0;
                                          myj++;
                                   
                                         *ptr_myj++ = state[i][1].valprev&0xFF;
                                          myj++;
                                          
                                         *ptr_myj++  = state[i][1].valprev >> 8;
                                          myj++;
                                       
                                         *ptr_myj++  = state[i][1].index;
                                          myj++;
                                 
                                         *ptr_myj++ = 0;
                                          myj++;
                                          
                                          sent_out_state_info[i] = YES;
                                     
                                      
                                       in = malloc((schunk)*4);
                                 
                                       if (in == NULL)
                                       {
                                           printf("Fatal Error: Insufficient memory.");
                                           printf("             %d more bytes required.\n",(schunk)*4);
                                           exit(0);
                                       }    
                                     
                                       inbase = in;
                                      
                                       inregs.r[0] = 4;
                                       inregs.r[1] = newARFileHandles[i];
                                       inregs.r[2] = (int)in;
                                       inregs.r[3] = (schunk)*4;
                                       error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                                       if (error != NULL)
                                       {
                                           printf("Fatal Error: swi failure (OS_GBPB)");
                                           printf("             Unable to read samples into memory.\n");
                                           printf("             Allocation of memory was successful.\n");
                                           exit(0);
                                       }    
                                       zeroes = outregs.r[3];
                                       if (sent_out_state_info[i] == YES &&
                                           zeroes == (schunk*4))
                                       {
                                           myj = myj - 8;    
                                       }
                                       end_of_source_data[i] = FALSE;
                                       if (zeroes > 0)
                                       {   
                                           end_of_source_data[i] = TRUE;
                                           while (zeroes % 4 != 0)
                                           {
                                                  zeroes--;
                                                 
                                           }       
                                       }
                                       in = inbase;
                                      
                                       for (icnt = 0; icnt < (((schunk)*4)-zeroes)/4; icnt++)
                                       {   
                              
                                            inbuffx_evens[icnt] = *in++;
                                            inbuffx_odds[icnt] = *in++;
                                          
                                       }   
                                      
                                      
                                       adpcm_coder(inbuffx_evens,outbuffx_evens,(((schunk)*4)-zeroes)/2/2,&state[i][0]);
                                       adpcm_coder(inbuffx_odds,outbuffx_odds,(((schunk)*4)-zeroes)/2/2,&state[i][1]);
                                    
                                       outbuff = (unsigned char *)myj;
                                       
                                       for (icnt=0;icnt<(schunk)-(zeroes/4);++icnt)
                                       {
                                            *outbuff++ = (((outbuffx_evens[icnt >> 1] >> (4 * (icnt & 1))) &0xf) << 0 |
                                                        ((outbuffx_odds[icnt >> 1] >> (4 * (icnt & 1))) &0xf) << 4);
                                             myj++;           
                                       } 
                                       CHECK_OP_SPACE;
                                       schunk = schunk - (zeroes/4);           
                                       a_sndsize[i] = schunk;     
                                       z = z+schunk;
                                      
                                       free(inbase);     
                                       
                                    } /* end of if not end of source data */  
               
                                   }   
                                   /*************/
                                   
                                   if (!samples_to_adpcm && !samples_to_adpcm_stereo)
                                   {     
                                    if (format2[i] == FALSE)
                                    {
                                     /*res = fread((void *)myj,sizeof(ch),schunk,ARFileHandles[i]);*/
                                       inregs.r[0] = 4;
                                       inregs.r[1] = newARFileHandles[i];
                                       inregs.r[2] = myj;
                                       inregs.r[3] = schunk;
                                       error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                                       if (error != NULL)
                                       {
                                           printf("Fatal Error: swi failure (OS_GBPB)");
                                           printf("             Unable to read sound data into memory.\n");
                                           printf("             Allocation of memory was successful.\n");
                                           exit(0);
                                       }    
                                       zeroes = outregs.r[3];
                                  
                                   
                                  
                                       end_of_source_data[i] = FALSE;
                                  
                                 
                                       if (zeroes > 0 && wflg==0)
                                       {
                                           end_of_source_data[i] = TRUE;
                                           wflg = 1;
                                       }    
                     
                                       schunk = schunk - zeroes;
                                       if (sound_source == SOUND_FILE && schunk % 2 != 0 && schunk != 0)
                                           schunk--;
                                 
                                       myj = myj + schunk;
                                       CHECK_OP_SPACE;
                                       a_sndsize[i] = schunk;
                                  
                                       z = z+schunk;  
                                    } /* end if format2[i] is false */
                                    else
                                    if (format2[i] == TRUE && !end_of_source_data[i])
                                    {
                                         ptr_myj = (char *)myj;
                                        *ptr_myj++ = state[i][0].valprev&0xFF; myj++; 
                                        *ptr_myj++ = state[i][0].valprev >> 8; myj++; 
                                        *ptr_myj++ = state[i][0].index; myj++;       
                                        *ptr_myj++ = 0; myj++;    
                                        
                                         if (stereo[i])
                                         {
                                             *ptr_myj++ = state[i][1].valprev&0xFF; myj++; 
                                             *ptr_myj++ = state[i][1].valprev >> 8; myj++;
                                             *ptr_myj++ = state[i][1].index; myj++;    
                                             *ptr_myj++ = 0; myj++;
                                         }
                                         
                                         inregs.r[0] = 4;
                                         inregs.r[1] = newARFileHandles[i];
                                         inregs.r[2] = myj;
                                         inregs.r[3] = schunk;
                                         error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                                         if (error != NULL)
                                         {
                                             PROG_ID;
                                             printf("Fatal Error: swi failure (OS_GBPB)\n");
                                             printf("             Unable to read sound data into memory.\n");
                                             printf("             Allocation of memory was successful\n");
                                             exit(0);
                                         }
                                         zeroes = outregs.r[3];
                                       
                      if (zeroes == schunk)
                      {   /* get rid of state info */
                        
                          if (stereo[i])
                          {
                              myj = myj-8;
                          }
                          else
                          {
                              myj = myj-4;
                          }
                      }                               
                                         
                                         end_of_source_data[i] = FALSE;            
                                         if (zeroes > 0 && wflg == 0)
                                         {
                                             end_of_source_data[i] = TRUE;
                                             /*printf("Warning: insufficient sound\n");  
                                             printf("         (track %d)\n",i);  */
                                             wflg = 1;
                                         }
                                         schunk = schunk - zeroes;
                                         
                                         if (sound_source == SOUND_FILE &&
                                             schunk % 2 != 0 &&
                                             schunk != 0)
                                         {
                                             schunk--;
                                         }
                                         myj_ptr2 = (unsigned char *)myj;
                                       
                                         if (!stereo[i])
                                         {                                       
                                              adpcm_decoder(myj_ptr2,NULL,schunk*2,&state[i][0],0,1);
                                         }
                                         else
                                         {
                                              adpcm_decoder(myj_ptr2,NULL,schunk,&state[i][0],0,2);
                                              adpcm_decoder(myj_ptr2,NULL,schunk,&state[i][1],1,2);
                                         }    
                                         
                                         myj = myj+schunk;  CHECK_OP_SPACE;
                                         a_sndsize[i] = schunk;
                                         z = z+schunk;
         
                      
                                    }  /* end if format2[i] is true */
                                  
                                   } /* end of if not samples to adpcm */                            
                              }
                              else
                              {
                                  /*printf("Couldn't find sound file for handle index %d\n",i);
                                  printf("Need viastuff code\n");*/
                                  printf("Fatal Error: Check header information is correct.\n");
                                  exit(0);
                              }
                          
                          }  
                   
                 }
                
    
                 z = (z + s[Z] + secsize) & ~secsize;
             } 
             
               CHECK_OP_SPACE;
               inregs.r[0] = 2;            
               inregs.r[1] = (int)dest_fptr2;
               inregs.r[2] = (int)op;
               inregs.r[3] = myj-(int)op;
               error = _kernel_swi(OS_GBPB,&inregs,&outregs); 
               if (outregs.r[3] != 0)
               {
                   printf("Disc full\n");
                   exit(0);
               }            
               if (error != NULL)
               {
                   PROG_ID;
                   printf("Fatal Error: Error code returned from OS_GBPB\n");
                   exit(0);
               }    
               
        }  
        
        free(ImageFile); free(op);
}
/*----------------------------------------------------------------------------*/
void sound_only(int spritesize,int num_of_movie_files)
{
 int totfile = 0;                 
 int firstone;
 int read_in;
 int *ibuffer;
 char *ptr_myj;
 short *in;
 short *inbase;
 int zeroes = 0;
 int icnt;
 short *inbuffx_odds, *inbuffx_evens; 
 unsigned char *outbuffx_odds, *outbuffx_evens;
 unsigned char *outbuff; 
 int biggest_schunk = 0;
 int ss;
 int res;
 int total_snd_in_src = 0;
 char *buffer;
 char *op;
 int myj;
 int current_file = 0;
 boolean video_data = NO;
 void *io_buffer;
 int guess,int_a,int_b,int_c;
 int next_byte_pos;
 int int_stime;
 int wflg = 0;
 unsigned char *myj_ptr2;
 int lastone; 
  
 
   op = malloc((int)sndsize+8);
   if (op == NULL)
   {
       printf("Fatal Error: Insufficient memory.\n");
       printf("             %d more bytes required.\n",(int)((sndsize + 3)*4));
       exit(0);
   }    

   if (sound_source == ARMOVIE_FILE)
   {   
       initialisation_for_reading_sound_ARMOVIE_FILE(&current_file,&total_snd_in_src,
           num_of_movie_files);
      
       
   }    
  
 
   if (sound_source == SOUND_FILE && sndbits[1] != 4 && sndbits[1] != 16)
   {    
       /*ch = fgetc(ARFileHandles[1]);*/
       inregs.r[1] = newARFileHandles[1];
       error = _kernel_swi(OS_BGet,&inregs,&outregs);
       if (error != NULL)
       {
           printf("Fatal Error: swi failure (OS_BGet)");
           exit(0);
       }    
   }    
  
 
   if (sound_source == ARMOVIE_FILE)
   {  
       /* temp_fptr is zero at this point - checked */
   
       inregs.r[0] = 0x40;
       inregs.r[1] = (int)movie_snd_src[0];
       error = _kernel_swi(OS_Find,&inregs,&outregs);
       if (error != NULL)
       {
            printf("Fatal Error: Unable to open source ARMovie file.\n");
            exit(0);
       }     
       temp_fptr = outregs.r[0];  
      
  /* okhere */      
                                                 inregs.r[0] = 0x40;
                                                 inregs.r[1] = (int)movie_snd_src[0];
                                                 error = _kernel_swi(OS_Find,&inregs,&outregs);
                                                 if (error != NULL)
                                                 {
                                                     printf("Fatal Error: swi failure.\n");
                                                     printf("             Unable to open source ARMovie file.\n");
                                                     exit(0);
                                                 }     

                       
       newARFileHandles[1] = outregs.r[0];
  /* but not here, unless the above is repeated. */     
   }
  
     
   if (tracks > 1)
   {
       puts("Sound only ARMovie file - will contain only first track ");
       tracks = 1;
   }
  
   if (newARFileHandles[1] != 0)
   {
       inregs.r[0] = 2;
       inregs.r[1] = newARFileHandles[1];
       error = _kernel_swi(OS_Args,&inregs,&outregs);
       if (error != NULL)
       {
            printf("Fatal Error: Unable to read extent of file.\n");
            printf("             swi failure (OS_Args)\n");   
            exit(0);
       }     
       
       if (sound_source == SOUND_FILE)
       {
           total_snd_in_src = outregs.r[2];
         
           if (samples_to_adpcm || samples_to_adpcm_stereo)
           {
               while (total_snd_in_src % 4 != 0)
               {
                     
                      total_snd_in_src--;
               }
               total_snd_in_src = total_snd_in_src/4;
           }            
       }
       
       /* If sound source is ARMOVIE_FILE then total_snd_in_src will have    */
       /* been calculated in initialisation_for_reading_sound_ARMOVIE_FILE() */
                           
       /*rewind(temp_fptr);
       fseek(temp_fptr,0,SEEK_END); */
      
       NumOfVideoChannelsToPutIntoMovie = total_snd_in_src/(int)a_sndsize[1];
      
       
   }
  
   buffer = calloc(30,sizeof(char));
   if (buffer == NULL)
   {
       PROG_ID;
       printf("Fatal Error: Insufficient memory.\n");
       printf("             30 more bytes required.\n");
       exit(0);
   }    
   init_str(buffer,30);  
   
   if (sound_source == SOUND_FILE)
   {
       if (((NumOfVideoChannelsToPutIntoMovie+1)*(int)a_sndsize[1])>total_snd_in_src)
             NumOfVideoChannelsToPutIntoMovie--;
   }          
   if (sound_source == ARMOVIE_FILE)
       NumOfVideoChannelsToPutIntoMovie--;  /* added 17/3/94 */
                                            /* n.b. don't do it for df sound
                                               source.  Tried and it missed
                                               last chunk of sound */
                                                
   sprintf(buffer,"%d number of chunks\n",NumOfVideoChannelsToPutIntoMovie); /* here*/
   inregs.r[0] = 2;   inregs.r[1] = dest_fptr2;
   inregs.r[2] = (int)buffer;   inregs.r[3] = strlen(buffer);
   error = _kernel_swi(OS_GBPB,&inregs,&outregs);
   if (error != NULL)
   {
       printf("Disc full.\n");
       exit(0);
   }    
   
   
   /* If sound is format 2 adpcm (or is being converted to that from */
   /* 16 bps) then there will be 4 bytes extra of state info. at the */
   /* start of each sound chunk (8 bytes extra if stereo).  Need to  */
   /* add these extra bytes onto even and odd max chunk size.        */
   
      
   init_str(buffer,30);
   if ((int)a_sndsize[1] != 0)
   {
       if (format2[1])
       {
           if (stereo[1])
           {
               sprintf(buffer,"%d even chunk size\n",(int)a_sndsize[1] + 8);
           }
           else
           {
               sprintf(buffer,"%d even chunk size\n",(int)a_sndsize[1] + 4);
           }
       }
       else
       {                
           sprintf(buffer,"%d even chunk size\n",(int)a_sndsize[1]);
       }
   }
   else
   {
       sprintf(buffer,"%d even chunk size\n",(int)a_sndsize[1]);
   }    
   inregs.r[0] = 2;   inregs.r[1] = dest_fptr2;
   inregs.r[2] = (int)buffer;   inregs.r[3] = strlen(buffer);
   error = _kernel_swi(OS_GBPB,&inregs,&outregs);
   if (error != NULL)
   {
        printf("Disc full\n");
        exit(0);
   }     
       
   init_str(buffer,30);    
   if ((int)a_sndsize[1] != 0)
   {
       if (format2[1])
       {
           if (stereo[1])
           {
               sprintf(buffer,"%d odd chunk size\n",(int)a_sndsize[1] + 8);
           }
           else
           {
               sprintf(buffer,"%d odd chunk size\n",(int)a_sndsize[1] + 4);
           }
       }
       else
       {
           sprintf(buffer,"%d odd chunk size\n",(int)a_sndsize[1]);
       }    
   }
   else
   {                
      sprintf(buffer,"%d odd chunk size\n",(int)a_sndsize[1]);
   }
   
   inregs.r[0] = 2;   inregs.r[1] = dest_fptr2;
   inregs.r[2] = (int)buffer;   inregs.r[3] = strlen(buffer);
   error = _kernel_swi(OS_GBPB,&inregs,&outregs);
   if (error != NULL)
   {
        printf("Disc full\n");
        exit(0);
   }     
   
   free(buffer);
   
   sprintf(a,"XXXXXX catalogue offset");
   sprintf(b,"XXXXXX offset to sprite");
   sprintf(c,"%d size of sprite",spritesize); 
  
   inregs.r[0] = 0; inregs.r[1] = dest_fptr2;
   if ((error = _kernel_swi(OS_Args,&inregs,&outregs)) != NULL)
   {
        PROG_ID;
        printf("Fatal Error: swi failure (OS_Args)");
        printf("             Unable to read current position in output file.\n");
        exit(0);
   }     
   int_b = outregs.r[2];
  
   int_b = int_b + (int)strlen(a) + (int)strlen(b) + 
                   (int)strlen(c) + 3;
  
   init_str(b,100);
   sprintf(b,"%d offset to sprite",int_b);

   int_a = int_b + spritesize;
   init_str(a,100);
   sprintf(a,"%d catalogue offset",int_a);
   
   inregs.r[0] = 2; inregs.r[1] = dest_fptr2; 
   inregs.r[2] = (int)a; inregs.r[3] = strlen(a);
   error = _kernel_swi(OS_GBPB,&inregs,&outregs);
   if (error != NULL)
   {
       printf("Disc full");
       exit(0);
   }    
       
   
   /* Write out \n */
   inregs.r[0] = 10;
   inregs.r[1] = dest_fptr2;
   error = _kernel_swi(OS_BPut,&inregs,&outregs);
   if (error != NULL)
   {
       printf("Fatal Error: swi failure (OS_BPut)");
       printf("             Disc may be full\n");
       exit(0);
   }    
   
   inregs.r[0] = 2; inregs.r[1] = dest_fptr2; 
   inregs.r[2] = (int)b; inregs.r[3] = strlen(b);
   error = _kernel_swi(OS_GBPB,&inregs,&outregs);
   if (error != NULL)
   {
       printf("Disc full\n");
       exit(0);
   }     
   
   /* Write out \n */
   inregs.r[0] = 10;
   inregs.r[1] = dest_fptr2;
   error = _kernel_swi(OS_BPut,&inregs,&outregs);
   if (error != NULL)
   {
       printf("Fatal Error: swi failure (OS_BPut)\n");
       printf("             Disc may be full.\n");
       exit(0);
   }    
   
   inregs.r[0] = 2; inregs.r[1] = dest_fptr2; 
   inregs.r[2] = (int)c; inregs.r[3] = strlen(c);
   error = _kernel_swi(OS_GBPB,&inregs,&outregs);
   if (error != NULL)
   {
       printf("Disc full");
       exit(0);
   }    
       
   
   /* Write out \n */
   inregs.r[0] = 10;
   inregs.r[1] = dest_fptr2;
   error = _kernel_swi(OS_BPut,&inregs,&outregs);
   if (error != NULL)
   {
        printf("Fatal Error: swi failure (OS_BPut)");
        printf("             Disc may be full.\n");
        exit(0);
   }     
  
   inregs.r[0] = 0; inregs.r[1] = dest_fptr2;
   if ((error = _kernel_swi(OS_Args,&inregs,&outregs)) != NULL)
   {
        PROG_ID;
        printf("Fatal Error: swi failure (OS_Args).\n");
        printf("             Unable to read current position in file.\n");
        exit(0);
   }
  
   next_byte_pos = outregs.r[2] - 1;
    
   
   ss = int_b - next_byte_pos;
   
 
     ibuffer = malloc((ss * 4)*4);
     if (ibuffer == NULL)
     {
          printf("Fatal Error: Insufficient memory.\n");
          printf("             %d more bytes required.\n",(ss*4)*4);
          exit(0);
     }     
     for (j = 0; j < ss-1; j++)
     {
           *(ibuffer + j) = 0;
     }
     inregs.r[0] = 2; inregs.r[1] = dest_fptr2;
     inregs.r[2] = (int)ibuffer; inregs.r[3] = ss-1;
     error = _kernel_swi(OS_GBPB,&inregs,&outregs);
     if (error != NULL)
     {
         printf("Disc full");
         exit(0);
     }  
     
     free(ibuffer);
   
  
   
   
   /* output the sprite */    
  
   
   io_buffer = malloc(spritesize);
   if (io_buffer == NULL)
   {
       printf("Fatal Error: Insufficient memory.\n");
       printf("             %d more bytes required.\n",spritesize);
       exit(0);
   }
   rewind(sprite_fptr);
   read_in = spritesize;
   res = fread(io_buffer,sizeof(char),spritesize,sprite_fptr);
   inregs.r[0] = 2; inregs.r[1] = dest_fptr2;
   inregs.r[2] = (int)io_buffer; inregs.r[3] = spritesize;
   error = _kernel_swi(OS_GBPB,&inregs,&outregs);
   if (error != NULL)
   {
        printf("Disc full");
        exit(0);
   }  
    
   free(io_buffer);
   fclose(sprite_fptr);
   
   /* Now at a, ready for catalogue.  First compute how long the */
   /* catalogue is.                                              */
   
  
   guess = (int_a + NumOfVideoChannelsToPutIntoMovie * 30 + secsize) & ~secsize;
   
   do { int_c = int_a;
       
        z = guess;
       
        for (i = 0; i < 150; stime[i] = 0.0, i++);
        int_stime = 0;
       
        if (newARFileHandles[1] != 0)
        {   
            /*fseek(temp_fptr,0,SEEK_END); */
            inregs.r[0] = 2;
            inregs.r[1] = temp_fptr;
            error = _kernel_swi(OS_Args,&inregs,&outregs);
            if (error != NULL)
            {
                printf("Fatal Error: Unable to read extent of sound file.\n"); 
                printf("             swi failure (OS_Args)\n");  
                exit(0);
            }    
            firstone = outregs.r[2];
            
/* closes ok here if code from close_files is here but not if exit() is here. */
 
            
            inregs.r[0] = 0;
            inregs.r[1] = newARFileHandles[1];
            error = _kernel_swi(OS_Args,&inregs,&outregs);
            if (error != NULL)
            {
                printf("Fatal Error: swi failure (OS_Args)\n");
                printf("             Unable to read current position in sound file\n");
                exit(0);
            }    
            
            /* below: i.e. totfile = length of all the sound - current pos in sound file*/
            /* (for sound source is SOUND_FILE) */
           
            if (sound_source == SOUND_FILE)
            {
                totfile = firstone - outregs.r[2]; /* total_snd_in_src; */
             
                
                if (samples_to_adpcm || samples_to_adpcm_stereo)
                {
                    while (totfile % 4 != 0)
                    {
                     
                           totfile--;
                    }
                    totfile = totfile/4;
                }    
            }
            else
            if (sound_source == ARMOVIE_FILE)
            {
                totfile = total_snd_in_src;
            }    
            
            /* If sound source is ARMOVIE_FILE then total_snd_in_src  will have been   */
            /* calculated in initialisation_for_reading_sound_ARMOVIE_FILE() */
                
           
            if (sound_source == ARMOVIE_FILE)
            {
                oldtotfile = totfile;
            }    
        }
        else
        {   
             totfile = NumOfVideoChannelsToPutIntoMovie * (int)a_sndsize[1];
             
        }
        

        for (Z = 0; Z <= NumOfVideoChannelsToPutIntoMovie; Z++)
        {   
             init_str(n,100);
             sprintf(n,"%d,0;",z);
             int_stime = (int)a_sndsize[1];
             schunk = int_stime;
          
             int_stime = int_stime - schunk;
           
             
             if (schunk > totfile)
             {   
                schunk = totfile;     
             } 
           
             if (format2[1] && stereo[1])
             {
                
                 int_to_str(schunk+8);
             }
             else
             if (format2[1] && !(stereo[1]))
             {
                 int_to_str(schunk+4);
             }
             else
             {        
                 int_to_str(schunk);
             }    
             strcat(n,str_z);
                
             z = z + schunk;
             totfile = totfile - schunk;
            
             int_c = int_c + (int)strlen(n) + 1;
             z = (z + secsize) & ~secsize;
        }
        guess = guess + secsize + 1;
       
        
   } while(int_c >=guess);
   
   
 
   z = (int_c + secsize) & ~secsize;
  
   int_stime = 0;
   
   if (newARFileHandles[1] != 0)
   {
       /* totfile = length of file pointed to by FileHandles[1] i.e. length of sound file */
       
       inregs.r[0] = 2;
       inregs.r[1] = temp_fptr;
       error = _kernel_swi(OS_Args,&inregs,&outregs); 
       if (error != NULL)
       {
           printf("Fatal Error: swi failure (OS_Args)\n");
           printf("             Unable to read extent of sound file\n");
           exit(0);
       }    
           
       
       /*fseek(temp_fptr,0,SEEK_END); */
       totfile = outregs.r[2]; /*ftell(temp_fptr);*/
     
       if (samples_to_adpcm || samples_to_adpcm_stereo)
       {
           while (totfile % 4 != 0)
           {
                 
                  totfile--;
           }
           totfile = totfile/4;
       }    
   }
   else
   {
       totfile = NumOfVideoChannelsToPutIntoMovie * (int)a_sndsize[1];
   }
  
   if (sound_source == ARMOVIE_FILE)
   {
       totfile = oldtotfile;
   }    
   
   for (Z = 0; Z <= NumOfVideoChannelsToPutIntoMovie; Z++)
   {    
        init_str(n,100);
        sprintf(n,"%d,0;",z);
        
        int_stime = int_stime + (int)a_sndsize[1];
        schunk = int_stime;
        int_stime = int_stime - schunk;
     
        if (schunk > totfile)
        {
            if (sndbits[i] == 8 && sound_source == SOUND_FILE)
                totfile--;
            schunk = totfile;
            if (samples_to_adpcm || samples_to_adpcm_stereo)
            {
                while (total_snd_in_src % 4 != 0)
                {
                  
                       total_snd_in_src--;
                }
                total_snd_in_src = total_snd_in_src/4;
            }    
        }    
        
        if (schunk > biggest_schunk)
            biggest_schunk = schunk*4;
            
        if (format2[1] && stereo[1])
        {
            int_to_str(schunk+8);
        }
        else
        if (format2[1] && !(stereo[1]))
        {
            int_to_str(schunk + 4);
        }
        else
        {                   
            int_to_str(schunk);
        }
        strcat(n,str_z);
        z = z + schunk;
        totfile = totfile - schunk;
      
   
        n[strlen(n)] = '\n';
      /*  n[strlen(n)] = '\0'; */  /* 26/4/94 */
        inregs.r[0] = 2;
        inregs.r[1] = dest_fptr2;
        inregs.r[2] = (int)n;
        inregs.r[3] = strlen(n);
        error = _kernel_swi(OS_GBPB,&inregs,&outregs);
        if (error != NULL)
        {
             printf("Disc full");
             exit(0);
        }     
 
        
        z = (z + secsize) & ~secsize;
   }
  
 
 
 if (samples_to_adpcm_stereo)
 {
     inbuffx_odds = calloc((biggest_schunk)/2,2); 
   
     if (inbuffx_odds == NULL)
     {
         PROG_ID;
         printf("Fatal Error: Insufficient memory.\n");
         printf("             %d more bytes required.\n",biggest_schunk);
         exit(0);
     }    

     inbuffx_evens = calloc((biggest_schunk)/2,2);
     if (inbuffx_evens == NULL)
     {
         PROG_ID;
         printf("Fatal Error: Insufficient memory.\n");
         printf("             %d more bytes required.\n",biggest_schunk);
         exit(0);
     }      
 
 
     outbuffx_odds = calloc((biggest_schunk)/4,1);
     if (outbuffx_odds == NULL)
     {
         PROG_ID;
         printf("Fatal Error: Insufficient memory.\n");
         printf("             %d more bytes required.\n",biggest_schunk/4);
         exit(0);
     } 
 
     outbuffx_evens = calloc((biggest_schunk)/4,1);
     if (outbuffx_evens == NULL)
     {
         PROG_ID;
         printf("Fatal Error: Insufficient memory.\n");
         printf("             %d more bytes required.\n",biggest_schunk/4);
         exit(0);
     }        
 
 } /* end of if samples to adpcm or samples to adpcm stereo */
  
   z = (int_c + secsize) & ~secsize;
   int_stime = 0;
   schunk = 0;
   
   if (newARFileHandles[1] != 0)            
   {
       /* totfile = length of file pointed to by FileHandles[1] ie.. length of sound file */
       inregs.r[0] = 2;
       inregs.r[1] = temp_fptr; 
       error = _kernel_swi(OS_Args,&inregs,&outregs);  
       if (error != NULL)
       {
           printf("Fatal Error: swi failure (OS_Args)\n");
           printf("             Unable to read extent of sound file\n");   
           exit(0);
       }    
       
       /*fseek(temp_fptr,0,SEEK_END); */
       totfile = outregs.r[2];/*ftell(temp_fptr);*/
     
       
       if (samples_to_adpcm || samples_to_adpcm_stereo)
       {
           while (totfile % 4 != 0)
           {
                  
                  totfile--;
           }
           totfile = totfile/4;
        }    
       
   }
   else
   {
        totfile = NumOfVideoChannelsToPutIntoMovie * (int)a_sndsize[1];
   }

end_of_source_data[0] = 0; end_of_source_data[1] = 0;
/*-----------------------------------------------------------------*/

   for (Z = 0; Z <= NumOfVideoChannelsToPutIntoMovie; Z++)
   {  
  
      inregs.r[0] = 0; inregs.r[1] = dest_fptr2;
      if ((error = _kernel_swi(OS_Args,&inregs,&outregs)) != NULL)
      {
           PROG_ID;
           printf("Fatal Error: swi failure (OS_Args)\n");
           printf("             Unable to read current position in output file\n");
           exit(0);
      }
      next_byte_pos = outregs.r[2]-1;
     
      ss = z - next_byte_pos;
     

     
      ibuffer = malloc((ss * 4)*4);
      
      if (ibuffer == NULL)
      {
          printf("Fatal Error: Insufficient memory.\n");
          printf("             %d more bytes required.\n",(ss * 4)*4);
     
          exit(0);
      }    
      for (j = 0; j < ss-1; j++)
      {
           *(ibuffer + j) = 0;
      }
     
      inregs.r[0] = 2;           inregs.r[1] = dest_fptr2;
      inregs.r[2] = (int)ibuffer; inregs.r[3] = ss-1;
      error = _kernel_swi(OS_GBPB,&inregs,&outregs); 
      if (error != NULL)
      {
          printf("Disc full");
          exit(0);
      }  
     
      free(ibuffer);   
 
      
        int_stime = int_stime + (int)a_sndsize[1];
        schunk = int_stime;
        int_stime = int_stime - schunk;
     
        if (schunk > totfile)
        {
            schunk = totfile;
        }    
        
        /*if (samples_to_adpcm_stereo) 
        z = z + schunk;*/
        
        totfile = totfile - schunk;
    
     
        myj = (int)op;
      
        
        if (sound_source == ARMOVIE_FILE)
        {
   if (format2[1])
   {
       ptr_myj = (char *)myj;
       *ptr_myj++ = state[1][0].valprev&0xFF; myj++;
       *ptr_myj++ = state[1][0].valprev >> 8; myj++;
       *ptr_myj++ = state[1][0].index; myj++;
       *ptr_myj++ = 0; myj++;
       
        if (stereo[1])
        {
            *ptr_myj++ = state[1][1].valprev&0xFF; myj++;
            *ptr_myj++ = state[1][1].valprev >> 8; myj++;
            *ptr_myj++ = state[1][1].index; myj++;
            *ptr_myj++ = 0; myj++;
        }
    }
         
    lastone =        sound_io_ARMOVIE_FILE(0,op,&myj,video_data);
    if (end_of_source_data[1] == TRUE)
    {  
        schunk = lastone;
        a_sndsize[1] = schunk;
    }            
            
            z = z + schunk;          
        }    
        else    
        {
             if (newARFileHandles[1] != 0)
             {
                 /* output schunk amt of sound */
                /* chk_eof = feof(block_fptr);*/
  
                 amt_of_sound_written = 0;
                 if (Z == 0 && sndbits[i] != 4)
                 {
                 /*ch = fgetc(ARFileHandles[1]);*/ /* miss 1st char. */
                 /*    inregs.r[1] = newARFileHandles[1];
                      _kernel_swi(OS_BGet,&inregs,&outregs);      */
                 /* the above - don't discard 1st char. - then */
                 /* passes bincomp with rogers.        */    
                     
                  }    
                  if (!samples_to_adpcm && !samples_to_adpcm_stereo)
                  {
                      if (format2[1] == FALSE)
                      {
                          inregs.r[0] = 4;
                          inregs.r[1] = newARFileHandles[1];
                          inregs.r[2] = myj;
                          inregs.r[3] = schunk;
                          error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                          if (error != NULL)
                          {
                              printf("Fatal Error: swi failure (OS_GBPB)\n");
                              printf("             Unable to transfer sound data to memory.\n");
                              printf("             Allocation of memory was successful.\n");
                              exit(0);
                          }    
                          zeroes = outregs.r[3];
                          if (zeroes != 0)
                          {
                              end_of_source_data[1] = 1;
                          }
                          schunk = schunk - zeroes;  /* these 3 lines */
                          a_sndsize[1] = schunk;   /* <-- changed i to 1 25/2/94 */
                          z = z+schunk;
                      
                        /*res = fread((void *)myj,sizeof(ch),schunk,ARFileHandles[i]);*/       
                          myj = myj + schunk; 
                  
                          CHECK_OP_SPACE2;
                      } /* end of if format2[1] is false */
                      else
                      if (format2[1])
                      {  
                          ptr_myj = (char *)myj;
                          *ptr_myj++ = state[1][0].valprev&0xFF; myj++;
                          *ptr_myj++ = state[1][0].valprev >> 8; myj++;
                          *ptr_myj++ = state[1][0].index; myj++;
                          *ptr_myj++ = 0; myj++;
                          
                           if (stereo[1])
                           {
                              
                               *ptr_myj++ = state[1][1].valprev&0xFF; myj++;
                               *ptr_myj++ = state[1][1].valprev >> 8; myj++;
                               *ptr_myj++ = state[1][1].index; myj++;
                               *ptr_myj++ = 0; myj++;
                           }
                           
                           inregs.r[0] = 4;
                           inregs.r[1] = newARFileHandles[1];
                           inregs.r[2] = myj;
                           inregs.r[3] = schunk;
                           error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                           if (error != NULL)
                           {
                               PROG_ID;
                               printf("Fatal Error: swi failure (OS_GBPB)\n");
                               printf("             Unable to transfer sound data to memory.\n");
                               exit(0);
                           }
                           zeroes = outregs.r[3];
       if (zeroes == schunk)
       {   /* get rid of state info */
             
              if (stereo[i])
              {
                  myj = myj-8;
              }
              else
              {
                  myj = myj-4;
              }
       }                                  
                           end_of_source_data[1] = FALSE;
                           if (zeroes > 0 && wflg == 0)
                           {
                               end_of_source_data[1] = TRUE;
                              /* printf("Warning - insufficient sound\n");*/
                               wflg = 1;
                           }
                           schunk = schunk - zeroes;
                           myj_ptr2 = (unsigned char *)myj;
                           if (!stereo[1])
                           {                       /* used to be schunk*2 */
                                adpcm_decoder(myj_ptr2,NULL,schunk*2,&state[1][0],0,1);
                           }
                           else
                           {
                                adpcm_decoder(myj_ptr2,NULL,schunk,&state[1][0],0,2);
                                adpcm_decoder(myj_ptr2,NULL,schunk,&state[1][1],1,2);
                           }
                           myj = myj + schunk; CHECK_OP_SPACE2;
                           a_sndsize[1] = schunk; z = z + schunk;
                      } /* end of if format2[1] is true */                           
                  }
                  else if (samples_to_adpcm)
                  {
                           in = malloc((schunk)*4);
                           if (in == NULL)
                           {
                               printf("Fatal Error: Insufficient memory.\n");
                               printf("             %d more bytes required.\n",schunk*4);
                               exit(0);
                           }    
                           inbase = in;
                           inregs.r[0] = 4;
                           inregs.r[1] = newARFileHandles[1];
                           inregs.r[2] = (int)in;
                           inregs.r[3] = (schunk)*4;
                           error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                           if (error != NULL)
                           {
                               printf("Fatal Error: swi failure (OS_GBPB)");
                               printf("             Unable to transfer sound data to memory.\n");
                               printf("             Allocation of memory was successful.\n");
                               exit(0);
                           }    
                           
                           ptr_myj = (char *)myj;
                           
                          *ptr_myj++ = state[1][0].valprev&0xFF;
                           myj++;
                           
                          *ptr_myj++ = state[1][0].valprev >> 8;
                           myj++;
                           
                          *ptr_myj++ = state[1][0].index;
                           myj++;
                           
                          *ptr_myj++ = 0;
                           myj++;
                           
                     
                           adpcm_coder(in,(unsigned char *)myj,(((schunk)*4))/2,&state[1][0]);
                           myj = myj+schunk;
                           CHECK_OP_SPACE2;
                           
                           z = z+schunk; 
                           free(inbase);
                  }
                  else if (samples_to_adpcm_stereo)
                  {          
                           if (!end_of_source_data[1])
                           {   
                                ptr_myj = (char *)myj;
                           
                               *ptr_myj++ = state[1][0].valprev&0xFF;
                                myj++;
                           
                               *ptr_myj++ = state[1][0].valprev >> 8;
                                myj++;
                           
                               *ptr_myj++ = state[1][0].index;
                                myj++;
                           
                               *ptr_myj++ = 0;
                                myj++;
                           
                               *ptr_myj++ = state[1][1].valprev&0xFF;
                                myj++;
                           
                               *ptr_myj++ = state[1][1].valprev >> 8;
                                myj++;
                           
                               *ptr_myj++ = state[1][1].index;
                                myj++;
                           
                               *ptr_myj++ = 0;
                                myj++;
                              
                                in = malloc((schunk)*4);
                                if (in == NULL)
                                {
                                    printf("Fatal Error: Insufficient memory.\n");
                                    printf("             %d more bytes wanted\n",schunk*4);
                                    exit(0);
                                }    
                                
                                inbase = in;
                                inregs.r[0] = 4;
                                inregs.r[1] = newARFileHandles[1];
                                inregs.r[2] = (int)in;
                                inregs.r[3] = (schunk)*4;
                                error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                                if (error != NULL)
                                {
                                   printf("Fatal Error: swi failure (OS_GBPB).");
                                   printf("             Unable to read sound data into memory.\n");
                                   printf("             Allocation of memory was successful.\n");
                                   exit(0);
                                }   
                                zeroes = outregs.r[3];
                               
                                end_of_source_data[1] = FALSE;
                                if (zeroes > 0)
                                {
                                    end_of_source_data[1] = TRUE;
                                    while (zeroes % 4 != 0)
                                    {
                                           zeroes--;
                                         
                                    }        
                                }
                               
                                in = inbase;
                                for (icnt = 0; icnt < (((schunk)*4)-zeroes)/4;icnt++)
                                {
                                     inbuffx_evens[icnt] = *in++;
                                     inbuffx_odds[icnt] = *in++;
                                }
                                
                                adpcm_coder(inbuffx_evens,outbuffx_evens,(((schunk)*4)-zeroes)/2/2,&state[1][0]);
                                adpcm_coder(inbuffx_odds,outbuffx_odds,(((schunk)*4)-zeroes)/2/2,&state[1][1]);
                                outbuff = (unsigned char *)myj;
                                
                                for (icnt = 0; icnt<(schunk)-(zeroes/4);++icnt)
                                {
                                     *outbuff++ = (((outbuffx_evens[icnt >> 1] >> (4 * (icnt & 1))) &0xf) << 0 |
                                                   ((outbuffx_odds[icnt >> 1] >> (4 * (icnt & 1))) &0xf) << 4);
                                      myj++;
                                }
                               
                                CHECK_OP_SPACE2;
                               
                                schunk = schunk-(zeroes/4);
                                a_sndsize[i] = schunk;
                                z = z+schunk; 
                                free(inbase);
                           } /* end of if not end of source data */                                        
                               
                  }          
                          
             }
        }
        
        CHECK_OP_SPACE2;
        
        z = (z + secsize) & ~secsize;
        inregs.r[0] = 2; 
        inregs.r[1] = (int)dest_fptr2;
        inregs.r[2] = (int)op;
        inregs.r[3] = myj-(int)op;
        error = _kernel_swi(OS_GBPB,&inregs,&outregs);
        if (outregs.r[3] != 0)
        {
            printf("Fatal Error: Disc Full\n");
            exit(0);
        }    
        
        if (error != NULL)
        {
            PROG_ID;
            printf("Fatal Error: swi failure (OS_GBPB)");
            exit(0);
        }    
        
   }    
                            
   free(op); 
}
/*--------------------------------------------------------------------------------*/
void load_and_execute(void)
{char *last;   
 char blk[5];
  
  _swi(OS_File,_IN(0)|_IN(1)|_OUT(2)|_OUT(3),17,load,&ld,&ex);  
  blk[4] = (ld & 0xFF); 
  *((int *)blk) = ex;
 _swi(OS_ConvertDateAndTime,_IN(0)|_IN(1)|_IN(2)|_IN(3)|_RETURN(0),
       blk,load,100,"%24:%MI:%SE %DY-%M3-%YR");  

  _swi(OS_File,_IN(0)|_IN(1)|_IN(2),2,dest,ld);
  _swi(OS_File,_IN(0)|_IN(1)|_IN(3),3,dest,ex);  

  last = calloc(strlen(dest)+15,sizeof(char));
  if (last ==  NULL)
  {
      PROG_ID;
      printf("Fatal Error: Insufficient memory.\n");
      printf("             %d more bytes required.\n",strlen(dest)+15);
      exit(0);
  }
  init_str(last,strlen(dest)+15);    
  sprintf(last,"Settype %s AE7\n",dest);
  system(last);  
  free(last);
}
/*----------------------------------------------------------------------------------*/
/* (Tested - alters original in calling env.)*/

void init_str(char *arep,int len)  
{int iii;

   for (iii = 0; iii < len; arep[iii] = '\0', iii++);
   
}

/*----------------------------------------------------------------------------------*/

int get_number_of_soundtracks(void)
{ int soundtracks = 1;
  int k;
  char *buffer;
  
   /* 10th line in header file */
   
   buffer = calloc(MAX_LINE,sizeof(char));
   if (buffer == NULL)
   {
       PROG_ID;
       printf("Fatal Error: Insufficient memory.\n");
       printf("             %d more bytes required.\n",MAX_LINE);
       exit(0);
   }    
   rewind(h_ptr);
   
   
   for (k = 1; k <= 10; k++)
   {
        init_str(buffer,MAX_LINE);
        fgets(buffer,MAX_LINE,h_ptr);
        if ((strstr(buffer,"\n")) == NULL || strlen(buffer) > MAX_LINE - 3)
        {
             PROG_ID;
             printf("Fatal Error: Line too long in header.\n");
             printf("             or header is incomplete.\n");
             printf("             Reading line %d\n",k);
             printf("             Max. length allowed = %d bytes\n",MAX_LINE-3);
             printf("                  (including spaces).\n");
             exit(0);
        }     
             
   }     
   /* Find no. of soundtracks.  e.g. given xxx|xx|xxx, there are 3 soundtracks. */
   /* Given xxxx|xxxxxx|xx|x|xxxx|xx|xx, there are 7 soundtracks, and so on.    */
   /* i.e. no. of soundtracks is the number of '|' characters, + 1.             */
   
   for (k = 0; k < strlen(buffer); k++)
   {
        if (buffer[k] == '|')
        {
            soundtracks++;
        }
   }
   
   /* soundtracks started off as 1 so no need to increment again. */
   
   free(buffer);
   return soundtracks;
 }
/*------------------------------------------------------------------------------*/
int fn_a(char *string, int irep)
{ int k = 0; int jrep = 0;
  char result_str[150];
  char num[2];
  
 
/*  string[strlen(string)] = '\0';  26/4/94 */
  
  if (irep > 1)
  {
      /* Find position of |irep in string */
      /* ----------------------------- */
      for (k = 0; k < ((int)strlen(string) - 2); k++)
      {
           init_str(num,2);
           num[0] = string[k+1];
           num[1] = '\0';
           
           if ((string[k] == '|') && (atoi(num) == irep))
           {
                break; /* position found */
           }     
           else
                if (k == ((int)strlen(string) - 2))
                {
                   /* position of |irep will never be found */
                   printf("ERROR:\n");
                   printf("Source: fn_a()\n");
                   printf("Unable to find |%d in string %s\n",irep,string);
                   printf("Suggestion: check header file format.\n");
                }
                
           /* else  keep on searching */
      }
      
      /* Add length of stringed irep to position of |irep in string */
      /* ---------------------------------------------------- */
      if (irep < 10) 
      {
          k = k + 1;
      }    
      else if (irep < 100) 
           {
               k = k + 2;
           }     
           else if (irep < 1000) 
                {
                    k = k + 3;
                }     
                else {printf("SOURCE: fn_a()\n");
                      printf("More code required\n");
                     }
           
      /* Add 2 */
      /* ----- */
      k = k + 2;
      
      /* c.f. basic, now have VALMID$(j$,k), where j$ is string.       */
      /* MID$(j$,k) gives all characters from the kth position to the  */
      /* end.  We now want VALMID$(j$,k).  In basic, e.g. VAL("10to10")*/
      /* will be 10 as all characters after the 1st 10 will be ignored.*/
      
      init_str(result_str,100);
      jrep = 0; 
      /*string[strlen(string)] = '\0'; 26/4/94 */
      while ((jrep < 99) && (isdigit(string[k])))
      {
              result_str[jrep] = string[k];
              jrep++; k++;
      }
      
     /* result_str[strlen(result_str)] = '\0'; 26/4/94 */
    
  }
  else
  {
      init_str(result_str,100);
      while (isdigit(string[k]))
      {
             result_str[k] = string[k]; 
             k++;
      }
  }
  
  return (atoi(result_str));

}                         

/*--------------------------------------------------------------------------*/
int initialisation_for_reading_sound_ARMOVIE_FILE(int *current_file,
                                                   int *total_snd_in_src,
                                                   int num_of_movie_files)
{FILE *cat_fptr;
 int cat_chunks;
 int track_no = 1;
 int ntracks;
 int strack;
 int found = NO;
 int file_count;
 int ms2;
 int ss = 0;
 int mt;
 int q;
 int t;
 int xx;
 char *buffer;
 int biggest_schunk = 0;
 char ch;
 int start_pos = 0;

     buffer = calloc(MAX_LINE,sizeof(char));
     if (buffer == NULL)
     {
         PROG_ID;
         printf("Fatal Error: Insufficient memory.\n");
         printf("             %d more bytes required.\n",MAX_LINE);
         exit(0);
     }    
   
     ms2 = 0; 
     while (ms2 <= tracks-1)
     {
            mt = movie_tracks[ss];
            for (xx = 1; xx <= mt; xx++)
            {
                 if (ms2 >= 10 || strlen(movie_snd_src[ss]) >= 150)
                 {
                     printf("Fatal Error:  Exceeded max. no. of ARMovie source files.\n");
                     exit(0);
                 }    
                 sprintf(movie_snd_src2[ms2],"%s",movie_snd_src[ss]);
                 ms2++;
            }
            ss++;
    }
 
   cat_fptr = fopen(movie_snd_src2[*current_file],"r");
   if (cat_fptr == NULL)
   {
       printf("Fatal Error: Unable to open %s\n",movie_snd_src2[*current_file]);
       exit(0);
   }
   cat_fptr = start_of_cat_info(cat_fptr);
   
   cat_fptr = create_head(cat_fptr,&track_no,current_file,total_snd_in_src);
 
   fclose(cat_fptr);
   current = head;
   
   file_count = *current_file;
   while (file_count <= num_of_movie_files - 1)   
   {  
          temp = (struct cat_info *)malloc(sizeof(struct cat_info));
          if (temp == NULL)
          {
              printf("Fatal Error: Insufficient memory.\n");
              printf("             %d more bytes required.\n",sizeof(struct cat_info));
              exit(0);
          }    
         
          while (strcmp(movie_snd_src2[*current_file],
              movie_snd_src2[*current_file-1]) == NULL)
          {    
                        (*current_file)++;
          }
          temp->file_id = *current_file; (*current_file)++;
          temp->next = NULL;       
          
          
          cat_fptr = fopen(movie_snd_src2[*current_file - 1],"r");
          if (cat_fptr == NULL)
          {
              if (movie_snd_src2[*current_file - 1][0] == '\0')
              {
                  printf("Fatal Error: Total number of sound tracks specified in your\n");
                  printf("             header does not match total number of sound \n");
                  printf("             tracks found in armovie source file/s.\n\n");
                  exit(0);
              }    
                  
              printf("Fatal Error: Unable to open %s\n",movie_snd_src2[*current_file - 1]);
              exit(0);
                  
          }
          cat_fptr = start_of_cat_info(cat_fptr);
         
   
          /* get no. of chunks (so know when to stop reading cat info */
          
          init_str(buffer,MAX_LINE);
          sprintf(buffer,"%.*s",MAX_LINE,movie_snd_src2[*current_file - 1]);
          if (strlen(buffer) < 1 || strlen(buffer) > MAX_LINE-3)
          {
              PROG_ID;
              printf("Fatal Error: Line too long in header.\n");
              exit(0);
          }    
          h_ptr = fopen(buffer,"r");
          if (h_ptr == NULL)
          {
              printf("Fatal Error: Unable to open %s\n",buffer);
              exit(0);
          }
          for (t = 1; t <= 14;t++) 
          {
               init_str(buffer,MAX_LINE);
               fgets(buffer,MAX_LINE,h_ptr);
               if (strlen(buffer) < 1 || strlen(buffer) > MAX_LINE - 3)
               {
                   PROG_ID;
                   printf("Fatal Error: Line too long in header.\n");
                   printf("             Reading line %d\n",t);
                   exit(0);
               }    
               
          }
          fscanf(h_ptr,"%d",&cat_chunks);
         
          fclose(h_ptr);
          
  cat_chunks++;        
 
  
          /* create heads for video and sound chunk sizes */
          temp->v = (struct video *)malloc(sizeof(struct video));    
          if (temp->v == NULL)
          {
              printf("Fatal Error: Insufficient memory.\n");
              printf("             %d more bytes required.\n",sizeof(struct video));
              exit(0);
          }    
                                                    
          
          temp->scs = (struct sound_chunk_sizes *)malloc(sizeof(struct sound_chunk_sizes));
          if (temp->scs == NULL)
          {
              printf("Fatal Error: Insufficient memory.\n");
              printf("             %d more bytes required.\n",sizeof(struct sound_chunk_sizes));
              exit(0);
              
          }    
 
          fscanf(cat_fptr,"%d",&temp->v->isp);
         
          ch = fgetc(cat_fptr);
          fscanf(cat_fptr,"%d",&temp->v->vds);
          current->next = temp;
          current = current->next;
          vcurrent = current->v;
          scurrent = current->scs;
          ch = fgetc(cat_fptr);
          fscanf(cat_fptr,"%d",&temp->scs->size);
 /*if (format2[track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
 {
     temp->scs->size = temp->scs->size - 4;
     if (stereo[track_no])
     {
         temp->scs->size = temp->scs->size - 4;
     }
 }*/                 
          *total_snd_in_src = *total_snd_in_src + temp->scs->size;
         
 
  if (format2[track_no] && stereo[track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
  {       
      *total_snd_in_src = *total_snd_in_src - 8;
  }
  else
  if (format2[track_no] && !stereo[track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
  {   
      *total_snd_in_src = *total_snd_in_src - 4;
  }          
          current->scs->track = track_no;  
/*last_isp[track_no] = vcurrent->isp;
last_vds[track_no] = vcurrent->vds;  */
last_sndsize[track_no] = temp->scs->size; 
          
          ch = fgetc(cat_fptr);
          while (ch != '\n')
          {
                 if (ch == '|')
                 {
                     while (ch != ' ')
                     {
                            ch = fgetc(cat_fptr);
                     }       
                     track_no++;
                 }
                 scurrent->slink = (struct sound_chunk_sizes *)malloc(sizeof(struct sound_chunk_sizes));
                 if (scurrent->slink == NULL)
                 {
                     printf("Fatal Error: Insufficient memory.\n");
                     printf("             %d more bytes required.\n",sizeof(struct sound_chunk_sizes));
                     exit(0);
                 }    
                 scurrent = scurrent->slink;
                 scurrent->slink = NULL;
                 scurrent->track = track_no;
                 fscanf(cat_fptr,"%d",&scurrent->size);
  /*if (format2[track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
  {
      if (stereo[track_no])
      {
          scurrent->size = scurrent->size - 8;
      }
      else
      {
          scurrent->size = scurrent->size - 4;
      }
  }*/                           
                 *total_snd_in_src = *total_snd_in_src + scurrent->size;
                 
          /*       if (format2[track_no] && stereo[track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
                 {       
                     *total_snd_in_src = *total_snd_in_src - 8;
                 }
                 else
                 if (format2[track_no] && !stereo[track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
                 {
                    *total_snd_in_src = *total_snd_in_src - 4;
                 }*/           

last_sndsize[track_no] = scurrent->size;             
                 ch = fgetc(cat_fptr);
          }                  
          ntracks = track_no;  strack = current->scs->track;
         
          for (t = 2; t <= cat_chunks; t++)
          {   
               vcurrent->vlink = (struct video *)malloc(sizeof(struct video));
               if (vcurrent->vlink == NULL)
               {
                   printf("Fatal Error: Insufficient memory.\n");
                   printf("             %d more bytes required.\n",sizeof(struct video));
                   exit(0);
               }    
               vcurrent = vcurrent->vlink;
               fscanf(cat_fptr,"%d",&vcurrent->isp);
               ch = fgetc(cat_fptr);
               fscanf(cat_fptr,"%d",&vcurrent->vds);
               ch = fgetc(cat_fptr);
               vcurrent->vlink = NULL;
              
               track_no = strack;   
               for (q = strack; q <= ntracks; q++)
               {
                    scurrent->slink = (struct sound_chunk_sizes *)malloc(sizeof(struct sound_chunk_sizes));
                    if (scurrent->slink == NULL)
                    {
                        printf("Fatal Error: Insufficient memory.\n");
                        printf("             %d more bytes required.\n",sizeof(struct sound_chunk_sizes));
                        exit(0);
                    }    
                    scurrent = scurrent -> slink;
                    scurrent->track = track_no;
                    fscanf(cat_fptr,"%d",&scurrent->size);
  /*if (format2[track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
  {
      if (stereo[track_no])
      {
          scurrent->size = scurrent->size - 8;
      }
      else
      {
          scurrent->size = scurrent->size - 4;
      }
  }  */                             
                    *total_snd_in_src = *total_snd_in_src + scurrent->size;
                 
/*if (format2[track_no] && stereo[track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
{       
    *total_snd_in_src = *total_snd_in_src - 8;
}
else
if (format2[track_no] && !stereo[track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
{
    *total_snd_in_src = *total_snd_in_src - 4;
} */          
  
  
    /*  last_isp[track_no] = vcurrent->isp;
      last_vds[track_no] = vcurrent->vds;*/
      last_sndsize[track_no] = scurrent->size;  
      track_no++;            
                    ch = fgetc(cat_fptr);
                    if (ch == '|')
                    {
                        while (ch != ' ')
                        {
                               ch = fgetc(cat_fptr);
                        }       
                    }           
                    scurrent->slink = NULL;
               }
          }
         
          fclose(cat_fptr);
          
         
   file_count++;       
   } /*  end of while *current_file <= num_of_movie_files - 1 */ 
  
  
  
/*    for (t = 0; t < 150; ARFileHandles[t] = NULL,t++);*/
  
    /* Associate track pointers with the right source files */
    
    if (ARFileHandles2[1] == 0)   /* Make sure files only get opened once, */
    {                            /* ie first time this function is called.*/
        for (t = 1; t <= tracks; t++)
        {
         inregs.r[0] = 0x40;
         inregs.r[1] = (int)movie_snd_src2[t-1];
         error = _kernel_swi(OS_Find,&inregs,&outregs);
         if (error != NULL)
         {
             printf("Fatal Error: Unable to open source ARMovie file\n");
             exit(0);
         }    
         ARFileHandles2[t] = outregs.r[0];
         
         if (ARFileHandles2[t] == 0)
         {
             printf("Fatal Error: Unable to read %s\n",movie_snd_src2[t-1]);
             exit(0);
         }
        }       
    }
    
   
    /* Move track pointers to start positions ready for reading data */
 
    for (t = 1; t <= tracks; t++)
    { 
         current = head;
         scurrent = current->scs;
         strack = scurrent->track;
    
         if (scurrent->track == t)
         {
             found = YES;
             image_list_ptrs[t] = current->v;
             slist_ptrs[t] = scurrent;
         }             
         else
         {
             found = NO;
             image_list_ptrs[t] = current->v;
             slist_ptrs[t] = scurrent;
         }    
      
         f2[t] = image_list_ptrs[t]->isp + image_list_ptrs[t]->vds
                  + slist_ptrs[t]->size;    
             
         if (biggest_schunk < slist_ptrs[t]->size)
         {
             biggest_schunk = slist_ptrs[t]->size;
         }      
 
         while (found == NO)
         { 
                scurrent = scurrent->slink;  
                f2[t] = f2[t] + scurrent->size;
                if (biggest_schunk < slist_ptrs[t]->size)
                {
                    biggest_schunk = slist_ptrs[t]->size;
                }       
 
                if (scurrent->track == strack)
                {    
                    /* track t is in another file */
                   
                    f2[t] = 0;  
                    current = current->next;
                    scurrent = current->scs;
                    strack = scurrent->track;          
                    
                    if (scurrent->track == t)
                    {   
                        found = YES;
                        image_list_ptrs[t] = current->v;
                        slist_ptrs[t] = scurrent;
                        
                    }    
                    else
                    {
                        found = NO;
                    }    
                    f2[t] = current->v->isp + current->v->vds
                              + scurrent->size; 
                    
                    if (biggest_schunk < scurrent->size)
                    {
                        biggest_schunk = scurrent->size;
                    }       
                    while (found == NO && scurrent->slink->track != strack)
                    {     scurrent = scurrent->slink;
                           f2[t] = f2[t] + scurrent->size;
                           if (biggest_schunk < scurrent->size)
                           {
                               biggest_schunk = scurrent->size;
                           }  
                           if (scurrent->track == t)
                           {  
                               found = YES;
                               image_list_ptrs[t] = current->v;
                               slist_ptrs[t] = scurrent;
                               
                           }    
                    }
            
                    
                }
                else
                if (scurrent->track == t)
                {   
                    found = YES; image_list_ptrs[t] = current->v;
                    slist_ptrs[t] = scurrent;
                }                                 
         }
         
   
         /*fseek(ARFileHandles[t],current->v->isp + current->v->vds,SEEK_SET);
          */
          
          start_pos = f2[t] - scurrent->size;
 
 if (format2[t] && !samples_to_adpcm && !samples_to_adpcm_stereo)
 {  
     start_pos = start_pos + 4;
     if (stereo[t])
     {
         start_pos = start_pos + 4;
     }
  }       
              
          inregs.r[0] = 1;
          inregs.r[1] = ARFileHandles2[t];
          inregs.r[2] = start_pos;
          error = _kernel_swi(OS_Args,&inregs,&outregs);
          if (error != NULL)
          {
               printf("Fatal Error: Unable to position file pointer at offset %d\n",start_pos);
               printf("             Possible cause of error is an incomplete \n");
               printf("             ARMovie source file, e.g. join may have \n");
               printf("             been aborted, giving a half made movie.\n");
               exit(0);
          }     
        
    }
  
   
    for (t = 0; t <10;  t++)    /* 25/4/94 150 changed to 10 */
    { 
         if (format2[t] && !samples_to_adpcm && !samples_to_adpcm_stereo)
         {
             if (stereo[t])
             {
                 amt_of_sound_read[t] = 8;
             }
             else
             {
                 amt_of_sound_read[t] = 4;
             }       
         }
         else 
         { 
             amt_of_sound_read[t] = 0;
         }  
    }    
 free(buffer);   

 return biggest_schunk;   
} 
        

/*----------------------------------------------------------------------------*/
int sound_io_ARMOVIE_FILE(int no_output,char *op,int *myj,boolean video_data)
{int read_in; int no_more_sound_nodes = 0, current_file_pos;
 int res; 
 short *in, *inbase;
 int start_pos = 0;
 char *dptr, *dptr_base;
 int baktrak;
 char *aptr, *aptr_base;
 int int_in,icnt,zeroes;
 int new_in;

   if (schunk == 0) 
   {   
       return 0;
   }    
   
   
   if (schunk % 2 != 0)
   {
       schunk--;
   }    
 
   if (no_output == TRUE)
   {
       *myj = (int)op;
   }    
   
   if (video_data == NO)
   {  
       i = 1;
   }    
                                        if (end_of_source_data[i]) return 0; /* 18/3/94 */ 
   amt_of_sound_written = 0;
   
   if (format2[i] && !samples_to_adpcm_stereo && !samples_to_adpcm && no_output == FALSE)
   {
       /* Allocate space for schunk amt. of sound to be run thru. 
        the decoder.  */                                          
         
          if ((dptr = malloc(schunk)) == NULL)
          {
              PROG_ID;
              printf("Fatal Error:  Insufficient memory.\n");
              printf("              %d more bytes required.\n",schunk);
              exit(0);
          }
          dptr_base = dptr; 
   }
   else
   if (samples_to_adpcm)
   {
       if ((aptr = malloc(schunk*4)) == NULL)
       {
            PROG_ID;
            printf("Fatal Error: Insufficient memory.\n");
            printf("             %d more bytes required.\n",schunk*4);
            exit(0);
       } 
       aptr_base = aptr;    
   }
   else
   if (samples_to_adpcm_stereo)
   {
       if ((in = malloc(schunk * 4)) == NULL)
       {
            PROG_ID;
            printf("Fatal Error: Insufficient memory.\n");
            printf("             %d more bytes required.\n",schunk*4);
            exit(0);
       }
       inbase = in;
       
   }         
 

   while (amt_of_sound_written != schunk && no_more_sound_nodes ==0)
   {  
      
      if (slist_ptrs[i] == NULL || slist_ptrs[i]->size == 0)
      {   
          
           no_more_sound_nodes = 1; 
          
      }     
      
      /* Check that we don't need to jump to the next chunk in the file */
      /* we're reading from for this particular soundtrack.             */
      
      if (no_more_sound_nodes) 
      {
         
          goto START;   
      }
     
      if (amt_of_sound_read[i] == slist_ptrs[i]->size)
      {    
          /* Move to the next (reading) chunk for this particular */
          /* soundtrack i.                      */
         
         
          if (image_list_ptrs[i]->vlink == NULL)
          {   
              /*printf("No more sound data left.\n");*/
              no_more_sound_nodes = 1;
              end_of_source_data[i] = 1;     
          }
          else
          { 
          
            image_list_ptrs[i] = image_list_ptrs[i]->vlink;
            start_pos = image_list_ptrs[i]->isp + image_list_ptrs[i]->vds;
            
          }
          
          if (slist_ptrs[i]->slink == NULL) 
          {    
             
              no_more_sound_nodes = 1;    
          }
   /*       else
   if (slist_ptrs[i]->slink->size == 0)
   {
                                       
       no_more_sound_nodes = 1;
   } */
   else    
          {   
              
              slist_ptrs[i] = slist_ptrs[i]->slink;
             
              while (slist_ptrs[i]!= NULL && slist_ptrs[i]->track != i) 
              {
                  
                    if (slist_ptrs[i]->track < i)
                    {   
                        start_pos = start_pos + slist_ptrs[i]->size;
                    }
                   
                    slist_ptrs[i] =slist_ptrs[i]->slink;
                    
              }  
              f2[i] = start_pos + slist_ptrs[i]->size;
             
              if (format2[i] && !samples_to_adpcm && !samples_to_adpcm_stereo/* &&
                  no_output == FALSE*/)
              {  
                  start_pos = start_pos + 4;
                  if (stereo[i])
                  {
                      start_pos = start_pos + 4;
                  }
              }        
              
              if (slist_ptrs[i] == NULL  || /* added-->*/slist_ptrs[i]->size == 0) 
              {
                
                  no_more_sound_nodes = 1;
                
                  goto START;
              }    
          
              
              
              
              /*fseek(ARFileHandles[i],start_pos,SEEK_SET);*/
               inregs.r[0] = 1;
               inregs.r[1] = ARFileHandles2[i];
               inregs.r[2] = start_pos;
               error = _kernel_swi(OS_Args,&inregs,&outregs); 
               if (error != NULL)
               {
                   printf("Fatal Error: Unable to position file pointer at offset %d\n",start_pos);
                   exit(0);
               }    
               
          }
          if (format2[i] && !samples_to_adpcm && !samples_to_adpcm_stereo)
          {
              if (stereo[i])
              {
                  amt_of_sound_read[i] = 8;
              }
              else
              {
                  amt_of_sound_read[i] = 4;
              } 
          }  
          else 
          {           
              amt_of_sound_read[i] = 0;
          } 
      }
      
      inregs.r[0] = 0;
      inregs.r[1] = ARFileHandles2[i];
      error = _kernel_swi(OS_Args,&inregs,&outregs);
      if (error != NULL)
      {
          printf("Fatal Error: Unable to read current position in file.\n");
          printf("             swi failure (OS_Args).\n");
          exit(0);
      }    
      
      current_file_pos = outregs.r[2];
   
 START:     
 
      if (no_more_sound_nodes)
      {   
           /*if (format2[i] && !samples_to_adpcm && !samples_to_adpcm_stereo)
           {
               if (stereo[i])
               {
                  *myj = *myj - 8;
               }
               else
               {
                    *myj = *myj - 4;
               }
            } */    /* 18/3/94*/          
      
           if (slist_ptrs[i] != NULL) slist_ptrs[i] = slist_ptrs[i]->slink;      
           if (samples_to_adpcm_stereo)
           {
               free(inbase);
           }    
         
           if (end_of_source_data[i] == TRUE && no_output && amt_of_sound_written == 0)
           {   
              
               return 0;
           }    
           else
           {   
              
               end_of_source_data[i] = TRUE;
               return amt_of_sound_written;
           }    
      }         
    
    else
      if ((schunk - amt_of_sound_written <= f2[i] - current_file_pos && !samples_to_adpcm
          && !samples_to_adpcm_stereo)  ||                                /* added *4 below 22/3/94 */
         ((samples_to_adpcm || samples_to_adpcm_stereo) && schunk*4 - amt_of_sound_written*4
            <= f2[i] - current_file_pos))
      {  
        
       
          read_in = schunk - amt_of_sound_written; 
          if (samples_to_adpcm || samples_to_adpcm_stereo)
              read_in = read_in * 4;
        
          if (format2[i] && !samples_to_adpcm && !samples_to_adpcm_stereo && no_output == FALSE)
          {       
              inregs.r[0] = 0;
              inregs.r[1] = (int)ARFileHandles2[i];  
              _kernel_swi(OS_Args,&inregs,&outregs);
              baktrak = (int)outregs.r[2];
          }          
                 /*res = fread((void *)myj,sizeof(ch),read_in,ARFileHandles[i]);*/
                 inregs.r[0] = 4;
                 inregs.r[1] = (int)ARFileHandles2[i];
                 if (samples_to_adpcm)
                 {
                     inregs.r[2] = (int)aptr;
                 }
                 else
                 if (samples_to_adpcm_stereo)
                 {
                    
                     if (read_in > schunk * 4)
                     {
                         PROG_ID;
                         printf("Fatal Error: Exceeded bounds of allocated memory.\n");
                         exit(0);
                     }    
                     inregs.r[2] = (int)in;
                 }    
                 else    
                 {
                     inregs.r[2] = (int)*myj;
                 }
                 inregs.r[3] = (int)read_in;
               
                 error = _kernel_swi(OS_GBPB,&inregs,&outregs);
 
                 if (error != NULL)
                 {
                      printf("Fatal Error: swi failure (OS_GBPB)\n");
                      printf("             Unable to read sound data into memory.\n");
                      printf("             Allocation of memory was successful.\n");
                      exit(0);
                 }     
 
                 if (samples_to_adpcm || samples_to_adpcm_stereo)
                     read_in = read_in/4;

                 res = read_in - outregs.r[3];
               
                if (format2[i] && !samples_to_adpcm && !samples_to_adpcm_stereo && no_output == FALSE)
                 {
                 
                    inregs.r[0] = 1;
                    inregs.r[1] = (int)ARFileHandles2[i];
                    inregs.r[2] = baktrak;
                    error = _kernel_swi(OS_Args,&inregs,&outregs);
                    if (error != NULL)
                    {
                        PROG_ID;
                        printf("Fatal Error: Unable to position file pointer at offset %d\n",baktrak);      
                        exit(0);
                    }        
               
                 
                    
                     inregs.r[0] = 4;
                     inregs.r[1] = (int)ARFileHandles2[i];
                     inregs.r[2] = (int)dptr;
                     inregs.r[3] = read_in;
                     if ((error = _kernel_swi(OS_GBPB,&inregs,&outregs)) != NULL)
                     {
                          PROG_ID;
                          printf("Fatal Error: Unable to read sound data into memory.\n");
                          printf("             swi failure (OS_GBPB).\n");
                          printf("             Allocation of memory was successful.\n"); 
                          exit(0);
                     }
                     dptr = dptr + (int)res;   
                /*     CHECK_DPTR_SPACE;       */
                 }         
                       
                 if (!samples_to_adpcm && !samples_to_adpcm_stereo)
                 {
                      *myj = *myj + res;
                 }
                 else
                 if (samples_to_adpcm_stereo)
                 {
                       new_in = (int)in + ((int)res * 4);
                       in = (short *)new_in;
                 }    
                 else
                 {
                       aptr = aptr + ((int)res* 4);
                 }
                             
                 
                 if (samples_to_adpcm || samples_to_adpcm_stereo)
                     amt_of_sound_read[i] = amt_of_sound_read[i] + res*4;
                 else 
                     amt_of_sound_read[i] = amt_of_sound_read[i] + res;   
                 amt_of_sound_written = amt_of_sound_written + res;
              
    }
    else
    if ((f2[i] - current_file_pos >= schunk && !samples_to_adpcm && 
        !samples_to_adpcm_stereo)  ||
       (f2[i] - current_file_pos >= schunk*4 && (samples_to_adpcm || samples_to_adpcm_stereo))) 
    {     
          /* can write out schunk amt. without having to move to next */
          /* (reading) chunk.                                         */
          
          read_in = schunk - amt_of_sound_written;
          
          if (samples_to_adpcm || samples_to_adpcm_stereo)
              read_in = read_in * 4;
               
          if (format2[i] && !samples_to_adpcm && !samples_to_adpcm_stereo && no_output == FALSE)
          {       
              inregs.r[0] = 0;
              inregs.r[1] = (int)ARFileHandles2[i];  
              _kernel_swi(OS_Args,&inregs,&outregs);
              baktrak = (int)outregs.r[2];
          }          
                 /*res = fread((void *)myj,sizeof(ch),read_in,ARFileHandles[i]);*/
                 inregs.r[0] = 4;
                 inregs.r[1] = (int)ARFileHandles2[i];
                 if (samples_to_adpcm)
                 {
                     inregs.r[2] = (int)aptr;
                 }
                 else
                 if (samples_to_adpcm_stereo)
                 {
                   
                     inregs.r[2] = (int)in;
                 }    
                 else    
                 {
                     inregs.r[2] = (int)*myj;
                 }
               
                 inregs.r[3] = read_in;
                 error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                 if (error != NULL)
                 {
                     printf("Fatal Error: swi failure (OS_GBPB).\n");
                     printf("             Unable to read sound data into memory.\n");
                     printf("             Allocation of memory was successful.\n");
                     exit(0);
                 }
                 if (samples_to_adpcm || samples_to_adpcm_stereo)
                     read_in = read_in / 4;    
                 res = read_in - outregs.r[3];
                 if (format2[i] && !samples_to_adpcm && !samples_to_adpcm_stereo && no_output == FALSE)
                 {
                 
                    inregs.r[0] = 1;
                    inregs.r[1] = (int)ARFileHandles2[i];
                    inregs.r[2] = baktrak;
                    error = _kernel_swi(OS_Args,&inregs,&outregs);
                    if (error != NULL)
                    {
                        PROG_ID;
                        printf("Fatal Error: Unable to position file pointer at offset %d\n",baktrak);
                        printf("             swi failure (OS_Args).\n");
                        exit(0);
                    }        
               
                 
                    
                     inregs.r[0] = 4;
                     inregs.r[1] = (int)ARFileHandles2[i];
                     inregs.r[2] = (int)dptr;
                     inregs.r[3] = read_in;
                     if ((error = _kernel_swi(OS_GBPB,&inregs,&outregs)) != NULL)
                     {
                          PROG_ID;
                          printf("Fatal Error: swi failure (OS_GBPB).\n");
                          printf("             Unable to read sound data into memory.\n");
                          printf("             Allocation of memory was successful.\n");
                          exit(0);
                     }
                     dptr = dptr + (int)res;   
                /*     CHECK_DPTR_SPACE;       */
                 }         
                 
                 if (!samples_to_adpcm && !samples_to_adpcm_stereo)
                 {
                     *myj = *myj + res;
                 }
                 else
                 if (samples_to_adpcm_stereo)
                 {
                     new_in = (int)in + ((int)res * 4);
                     in = (short *)new_in;
                 }    
                 else
                 {
                      aptr = aptr + ((int)res * 4);
                 }    
                 
                 if (samples_to_adpcm || samples_to_adpcm_stereo)
                     amt_of_sound_read[i] = amt_of_sound_read[i] + res*4;
                 else
                     amt_of_sound_read[i] = amt_of_sound_read[i] + res;    
                 amt_of_sound_written = amt_of_sound_written + res;
                 
    }
    else
    {
          
       /* Write out f2[i] - current_file_pos amt. of sound */
         
          read_in = f2[i] - current_file_pos;
          
         
     /*     if (samples_to_adpcm || samples_to_adpcm_stereo)
              read_in = read_in * 4;                        */
           
           if (format2[i] && !samples_to_adpcm && !samples_to_adpcm_stereo && no_output == FALSE)
           {       
              inregs.r[0] = 0;
              inregs.r[1] = (int)ARFileHandles2[i];  
              _kernel_swi(OS_Args,&inregs,&outregs);
              baktrak = (int)outregs.r[2];
           }       
         
          inregs.r[0] = 4;
          inregs.r[1] = (int)ARFileHandles2[i];
          if (samples_to_adpcm)
          {
              inregs.r[2] = (int)aptr;
          }
          else
          if (samples_to_adpcm_stereo)
          {
              inregs.r[2] = (int)in;
              
          }    
          else    
          {
              inregs.r[2] = (int)*myj;
          }
          inregs.r[3] = read_in;
          error = _kernel_swi(OS_GBPB,&inregs,&outregs);
          if (error != NULL)
          {
               PROG_ID;
               printf("Fatal Error: swi failure (OS_GBPB).\n");
               printf("             Unable to read sound data into memory.\n");
               printf("             Allocation of memory was successful.\n");
               exit(0);
          }     
          
          
          if (samples_to_adpcm || samples_to_adpcm_stereo)
              read_in = read_in /4;
              
          res = read_in - outregs.r[3];
          
         
          if (format2[i] && !samples_to_adpcm && !samples_to_adpcm_stereo && no_output == FALSE)
                 {
                 
                    inregs.r[0] = 1;
                    inregs.r[1] = (int)ARFileHandles2[i];
                    inregs.r[2] = baktrak;
                    error = _kernel_swi(OS_Args,&inregs,&outregs);
                    if (error != NULL)
                    {
                        PROG_ID;
                        printf("Fatal Error: Error code returned from OS_Args\n");
                        exit(0);
                    }        
               
                 
                    
                     inregs.r[0] = 4;
                     inregs.r[1] = (int)ARFileHandles2[i];
                     inregs.r[2] = (int)dptr;
                     inregs.r[3] = res;   /* was read_in */
                     if ((error = _kernel_swi(OS_GBPB,&inregs,&outregs)) != NULL)
                     {
                          PROG_ID;
                          printf("Fatal Error: Error code returned from OS_GBPB \n");
                          exit(0);
                     }
                     dptr = dptr + (int)res;   
                /*     CHECK_DPTR_SPACE;       */
                 }         
           if (!samples_to_adpcm && !samples_to_adpcm_stereo)
                *myj = *myj + res;
           else
           if (samples_to_adpcm_stereo)
           {
               new_in = (int)in + ((int)res * 4);
               in = (short *)new_in;
               
           }else
               aptr = aptr + ((int)res * 4);
            
          if (samples_to_adpcm || samples_to_adpcm_stereo) 
              amt_of_sound_read[i] = amt_of_sound_read[i] + res*4;
          else
              amt_of_sound_read[i] = amt_of_sound_read[i] + res;      
          amt_of_sound_written = amt_of_sound_written + res;
        
    }                   
 
   } /* end of while amt_of_sound_written  != schunk */
 
   if (format2[i] && !samples_to_adpcm && !samples_to_adpcm_stereo && no_output == FALSE)
   {
       if (!stereo[i])
       {
            adpcm_decoder((unsigned char *)dptr_base,NULL,schunk*2,&state[i][0],0,1);
       }
       else
       {
            adpcm_decoder((unsigned char *)dptr_base,NULL,schunk,&state[i][0],0,2);
            adpcm_decoder((unsigned char *)dptr_base,NULL,schunk,&state[i][1],1,2);
       }
       free(dptr_base);          
   }
   else
   if (samples_to_adpcm)
   {   
       adpcm_coder((short *)aptr_base,(unsigned char *)*myj,(schunk*4)/2,&state[i][0]);
       *myj = *myj + schunk;
       free(aptr_base);
   }    
   else
   if (samples_to_adpcm_stereo && no_output == FALSE)
   {
     
       
       in = inbase;
       for (icnt = 0; icnt < ((schunk * 4)/*-zeroes*/)/4;icnt++)
       {
            inbuffx_evens[icnt] = *in++;
            inbuffx_odds[icnt] = *in++;
       }
      
       adpcm_coder(inbuffx_evens,outbuffx_evens,(((schunk)*4)/*-zeroes*/)/2/2,&state[i][0]);
      
       adpcm_coder(inbuffx_odds,outbuffx_odds,(((schunk)*4)/*-zeroes*/)/2/2,&state[i][1]);
      
       outbuff = (unsigned char *)*myj;
       
       
       for (icnt=0;icnt<(schunk)/*-(zeroes/4)*/;++icnt)
       {
            *outbuff++ = (((outbuffx_evens[icnt >> 1] >> (4 * (icnt & 1))) &0xf) << 0 |
                          ((outbuffx_odds[icnt >> 1] >> (4 * (icnt & 1))) &0xf) << 4);
             (*myj)++;           
       }     
      
       free(inbase);
   }
   else if (samples_to_adpcm_stereo && no_output == TRUE)
   {
            free(inbase);
   }         
        
   return read_in;
}     
/*----------------------------------------------------------------------------*/
void int_to_str(int nrep)
{
          init_str(str_z,100); 
          sprintf(str_z,"%d",nrep);
          if (strlen(str_z) >= 149)
          {
              printf("Fatal Error:  A3. Exceeded bounds of array.\n");
              exit(0);
          }    
}
/*----------------------------------------------------------------------------------*/
FILE *create_head(FILE *cat_fptr,int *track_no, int *current_file,
                  int *total_snd_in_src)
{
  int cat_chunks;
  int ntracks;
  int q,t;
  char buffer[300];
  char ch;
   
     head = (struct cat_info *)malloc(sizeof(struct cat_info));
     if (head == NULL)
     {
        PROG_ID;
        printf("Fatal Error: Insufficient memory.\n");
        printf("             %d more bytes required.\n",sizeof(struct cat_info));
        exit(0);
     }   
     head->file_id = *current_file; (*current_file)++;
     head->v = NULL; head->scs = NULL; head->next = NULL;
     
     /* get no. of chunks (so know when to stop reading cat info. ) */
     sprintf(buffer,"%s",movie_snd_src2[*current_file-1]);
     h_ptr = fopen(buffer,"r");
     if (h_ptr == NULL)
     {   
         PROG_ID;
         printf("Fatal Error: - unable to open %s\n",buffer);
         exit(0);
     }
     rewind(h_ptr);
     for (t = 1; t <= 14; fgets(buffer,200,h_ptr), t++);
     fscanf(h_ptr,"%d",&cat_chunks); cat_chunks++;
     fclose(h_ptr);
     
     /* create heads for video and sound chunk sizes */
     head->v = (struct video *) malloc (sizeof(struct video));
     if (head->v == NULL)
     {
         printf("Fatal Error: - insufficient memory.\n");
         printf("             - %d more bytes required.\n",sizeof(struct video));
         exit(0);
     }    
     head->scs = (struct sound_chunk_sizes *)malloc(sizeof(struct sound_chunk_sizes));
     if (head->scs == NULL)
     {
         PROG_ID;
         printf("Fatal Error: - insufficient memory.\n");
         printf("             - %d more bytes required\n",
                                sizeof(struct sound_chunk_sizes));
         exit(0);
     }    
     fscanf(cat_fptr,"%d",&head->v->isp);
     ch = fgetc(cat_fptr);
     fscanf(cat_fptr,"%d",&head->v->vds);
     ch = fgetc(cat_fptr);
     vcurrent = head->v;
     head->scs->track = *track_no;
     fscanf(cat_fptr,"%d",&head->scs->size); 
  /*if (format2[i] && !samples_to_adpcm && !samples_to_adpcm_stereo)
  {
      if (stereo[i])
      {
          head->scs->size = head->scs->size - 8;  
      }
      else
      {
          head->scs->size = head->scs->size - 4;
      }
  } */            
     *total_snd_in_src = head->scs->size;

  if (format2[*track_no] && stereo[*track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
  {       
      *total_snd_in_src = *total_snd_in_src - 8;
  }
  else
  if (format2[*track_no] && !stereo[*track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
  {  
      *total_snd_in_src = *total_snd_in_src - 4;
  }               
    
     scurrent = head->scs;
     ch = fgetc(cat_fptr);
     
/*last_isp[1] = vcurrent->isp;
last_vds[1] = vcurrent->vds;*/
last_sndsize[1] = scurrent->size;
     
     while (ch != '\n')
     {
            if (ch == '|')
            {
                while (ch != ' ')
                {
                       ch = fgetc(cat_fptr);
                }       
                *track_no = *track_no + 1;
            }
            scurrent->slink = (struct sound_chunk_sizes *)malloc(sizeof(struct sound_chunk_sizes));
            if (scurrent->slink == NULL)
            {
                PROG_ID;
                printf("Fatal Error: - insufficient memory.\n");
                printf("             - %d more bytes required\n",
                                       sizeof(struct sound_chunk_sizes));
                exit(0);
            }    
            scurrent = scurrent->slink;
            scurrent->slink = NULL;
            scurrent->track = *track_no;
            fscanf(cat_fptr,"%d",&scurrent->size);
          /*  if (format2[i] && !samples_to_adpcm_stereo && !samples_to_adpcm)
            {
                if (stereo[i])
                {
                    scurrent->size = scurrent->size - 8;
                }
                else
                {
                    scurrent->size = scurrent->size - 4;
                }
            }*/            
            *total_snd_in_src = *total_snd_in_src + scurrent->size;

  if (format2[*track_no] && stereo[*track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
  {       
      *total_snd_in_src = *total_snd_in_src - 8;
  }
  else
  if (format2[*track_no] && !stereo[*track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
  {   
      *total_snd_in_src = *total_snd_in_src - 4;
  }          


/*last_isp[*track_no] = vcurrent->isp;
last_vds[*track_no] = vcurrent->vds;*/
last_sndsize[*track_no] = scurrent->size;        
           /* total_snd_in_src = total_snd_in_src + scurrent->size; */
           
            ch = fgetc(cat_fptr);
      }
      
      /* Now have cat info for the 1st chunk. Get info for all the other chunks. */
      ntracks = *track_no;
     
      for (t = 2; t <= cat_chunks; t++)
      {
           vcurrent->vlink = (struct video *)malloc(sizeof(struct video));
           if (vcurrent->vlink == NULL)
           {
               printf("Fatal Error: Insufficient memory.\n");
               printf("             %d more bytes required.\n",sizeof(struct video));
               exit(0);
           }    
           vcurrent = vcurrent->vlink;
           fscanf(cat_fptr,"%d",&vcurrent->isp);
           ch = fgetc(cat_fptr);
           fscanf(cat_fptr,"%d",&vcurrent->vds);
           ch = fgetc(cat_fptr);
           vcurrent->vlink = NULL;
           
          
           for (*track_no = 1; *track_no <= ntracks; q++)
           {
                scurrent->slink = (struct sound_chunk_sizes *)malloc(sizeof(struct sound_chunk_sizes));
                if (scurrent->slink == NULL)
                {
                    printf("Fatal Error: Insufficient memory.\n"); 
                    printf("             %d more bytes required.\n",sizeof(struct sound_chunk_sizes));
                    exit(0);
                }    
                scurrent = scurrent->slink;
                scurrent->track = *track_no;
                
                fscanf(cat_fptr,"%d",&scurrent->size);
             /*   if (format2[i] && !samples_to_adpcm && !samples_to_adpcm_stereo)
                {
                    if (stereo[i])
                    {
                        scurrent->size = scurrent->size - 8;
                    }
                    else
                    {
                        scurrent->size = scurrent->size - 4;
                    }
                }  */          
                        
                *total_snd_in_src = *total_snd_in_src + scurrent->size;
             
  if (format2[*track_no] && stereo[*track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
  {       
      *total_snd_in_src = *total_snd_in_src - 8;
  }
  else
  if (format2[*track_no] && !stereo[*track_no] && !samples_to_adpcm && !samples_to_adpcm_stereo)
  {  
      *total_snd_in_src = *total_snd_in_src - 4;
  }          
   
/*last_isp[*track_no] = vcurrent->isp;
last_vds[*track_no] = vcurrent->vds;*/
last_sndsize[*track_no] = scurrent->size; 
                *track_no = *track_no + 1;            
            /*    total_snd_in_src = total_snd_in_src + scurrent->size;*/
                ch = fgetc(cat_fptr);
                if (ch == '|')
                {
                    while (ch != ' ')
                    {
                           ch = fgetc(cat_fptr);
                    }       
                }           
                scurrent->slink = NULL;
           }
       }       
       
      
       
       
       
       return cat_fptr;   
 }                  
/*-----------------------------------------------------------------------*/     
FILE * start_of_cat_info(FILE *cat_fptr)
{int t;
 int cat_offset = 0;
 char *buffer;
 
   rewind(cat_fptr);
   buffer = calloc(MAX_LINE,sizeof(char));
   if (buffer == NULL)
   {
       PROG_ID;
       printf("Fatal Error: - insufficient memory.\n");
       printf("             - %d more bytes required.\n",MAX_LINE);
       exit(0);
   }    
   
   /* get cat offset */
   for (t = 1; t <= 17; t++)
   {
        init_str(buffer,MAX_LINE);
        fgets(buffer,MAX_LINE,cat_fptr);
        if (strlen(buffer) > MAX_LINE - 3)
        {
            PROG_ID;
            printf("Fatal Error: - Line too long in header.\n");
            printf("             - reading line %d\n",t);
            exit(0);
        }    
   }     
   /* cat offset is now on next line */
   fscanf(cat_fptr,"%d",&cat_offset);
   
   
   /* move to cat offset */
   fseek(cat_fptr,cat_offset,SEEK_SET);
   
   /* now ready to read cat info */
   
   free(buffer);
   return cat_fptr;
}             
/*------------------------------------------------------------------------*/
void Help(void)
{
     puts("Join Version 3.07, 16 May 1994.");
     puts("Commands:\n");
     puts("-help      this command.");
     puts("-dest f    set destination file name (default 'JoinOp')");
     puts("-index N   select different Header,Images,Keys combination.");
     puts("           (default is 0=no prefix)");  
     puts("-nokeys    prevent the key frames being written.");
     puts("-size N    set chunk alignment size to N.");
     puts("           (default 2047 bytes).");
     puts("-source    set name of source directory.");
     puts("-armovie N (full path name).");
     puts("           (default - data format files).");
     puts("           N is the number of movie files.");
     puts("           e.g. -armovie 2 $.dir1.file1 $.dir1.file2");
     
}
/*------------------------------------------------------------------------*/  
void close_files(void)
{
    /* Exception handler function - closes output file on normal exit */
    /* and if user terminates program execution prematurely.          */
       
       inregs.r[0] = 0; inregs.r[1] = dest_fptr2;
       _kernel_swi(OS_Find,&inregs,&outregs); 
       
       if (im_fptr2 != 0)
       {
           inregs.r[0] = 0; inregs.r[1] = im_fptr2;
           if ((error = _kernel_swi(OS_Find,&inregs,&outregs)) != NULL)
           {
                PROG_ID;
                puts("Warning: - unable to close image file.\n");
           }
       }    
       
       if (keys_fptr != 0)
       {
           inregs.r[0] = 0; inregs.r[1] = keys_fptr;
           if ((error = _kernel_swi(OS_Find,&inregs,&outregs)) != NULL)
           {
                PROG_ID;
                puts("Warning: - unable to close keys file.\n");
           }
       }    
       
       for (i = 0; i < MAX_TRACKS; i++)
       {
            if (newARFileHandles[i] != 0)
            {
                inregs.r[0] = 0;  inregs.r[1] = newARFileHandles[i];
                if ((error = _kernel_swi(OS_Find,&inregs,&outregs)) != NULL)
                {  
                    PROG_ID;
                    printf("Warning: - unable to close sound file/s\n");
                    printf("         - handle %d\n",newARFileHandles[i]);
                }
            }
            
            if (ARFileHandles2[i] != 0)
            {
                inregs.r[0] = 0;  inregs.r[1] = ARFileHandles2[i];
                if ((error = _kernel_swi(OS_Find,&inregs,&outregs)) != NULL)
                {  
                    PROG_ID;
                    printf("Warning: - unable to close source file/s\n");
                    printf("         - handle %d\n",ARFileHandles2[i]);
                }
            }
       }
       
       if (temp_fptr != 0)
       {
           inregs.r[0] = 0; inregs.r[1] = temp_fptr;
           if ((error = _kernel_swi(OS_Find,&inregs,&outregs)) != NULL)
           {
                PROG_ID;
                printf("Warning: - unable to close source movie file\n");
                printf("         - handle: %d\n",temp_fptr);
           }
       }   
       
      
       
       
}
/*========================================================================*/
int check_enough_sound(int wflg,int sound_compression)
{int zeroes;
 short *in;

 short *inbase; 

 
 
   if (schunk == 0 || end_of_source_data[i]) return 0;   
   if (sound_source == SOUND_FILE && sound_compression != 0)
   {  
       if (newARFileHandles[i] != 0)
       {
           amt_of_sound_written = 0;
           if (sndbits[i] == 8 && !format2[i]) /* fixed E26D4*/
           {                
               if (Z == 0)    /* Miss 1st character */
               {
                 /*ch = fgetc(ARFileHandles[i]); */
                   inregs.r[1] = newARFileHandles[i];
                   error = _kernel_swi(OS_BGet,&inregs,&outregs);
                   if (error != NULL)
                   {
                       printf("Fatal Error: swi failure (OS_BGet)\n");
                       exit(0); 
                   }    
               }   
            }
         
            if (samples_to_adpcm)
            {
               
                in = malloc((schunk)*4);
                if (in == NULL)
                {
                    PROG_ID;
                    printf("Fatal Error: - insufficient memory.\n");
                    printf("             - %d more bytes required.\n",schunk*4);
                    exit(0); 
                }    
                inbase = in;
                
                inregs.r[0] = 4;
                inregs.r[1] = newARFileHandles[i];
                inregs.r[2] = (int)in;
                inregs.r[3] = (schunk)*4;
                error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                if (error != NULL)
                {
                    printf("Fatal Error: swi failure (OS_GBPB)\n");
                    printf("             Unable to read sound data into memory.\n");
                    printf("             Allocation of memory was successful.\n");
                    exit(0);
                }    
                zeroes = outregs.r[3];
                
              
                while (zeroes % 4 != 0)
                {
                       zeroes--;
                      
                }       
               
             
                end_of_source_data[i] = FALSE;
                
                if (zeroes > 0)
                {
                    end_of_source_data[i] = TRUE;
                   
                    
                }
               
                free(inbase);
                return((schunk)-(zeroes/4));
               }
        
            
            
            if (samples_to_adpcm_stereo)
            {
                
               
                in = malloc((schunk)*4);
                if (in == NULL)
                {
                    printf("Fatal Error: - insufficient memory.\n");
                    printf("             - %d more bytes required.\n",schunk*4);
                    exit(0); 
                }    
                inbase = in;
                
                inregs.r[0] = 4;
                inregs.r[1] = newARFileHandles[i];
                inregs.r[2] = (int)in;
                inregs.r[3] = (schunk)*4;
                error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                if (error != NULL)
                {
                     printf("Fatal Error: swi failure (OS_GBPB)\n");
                     printf("             Unable to read sound data into memory.\n");
                     printf("             Allocation of memory was successful.\n");
                     exit(0); return 0;
                }     
                zeroes = outregs.r[3];
                
              
                while (zeroes % 4 != 0)
                {
                       zeroes--;
                      
                }       
               
                end_of_source_data[i] = FALSE;
                
                if (zeroes > 0)
                {
                    end_of_source_data[i] = TRUE;
                   
                    
                }
                   
                free(inbase);
                return((schunk)-(zeroes/4));
               }
            
            
            
            if (!samples_to_adpcm && !samples_to_adpcm_stereo)
            {    
               if (format2[i] == FALSE)
               {
                 in = malloc(schunk);
                 if (in == NULL)
                 {
                     PROG_ID;
                     printf("Fatal Error: - insufficient memory.\n");
                     printf("             - %d more bytes required.\n",schunk);
                     exit(0); 
                 }
                 inbase = in;    
               /*res = fread((void *)myj,sizeof(ch),schunk,ARFileHandles[i]);*/
                 inregs.r[0] = 4;
                 inregs.r[1] = newARFileHandles[i];
                 inregs.r[2] = (int)in;
                 inregs.r[3] = schunk;
                 error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                 if (error != NULL)
                 {
                     printf("Fatal Error: swi failure (OS_GBPB)\n"); 
                     printf("             Unable to read sound data into memory.\n");
                     printf("             Allocation of memory was successful.\n"); 
                     exit(0);  return 0;
                 }    
                 zeroes = outregs.r[3];
            
                 end_of_source_data[i] = FALSE;                      
                                 
                 if (zeroes > 0 && wflg==0)
                 {
                     end_of_source_data[i] = TRUE;
                 }    
                
                 free(inbase);
                 return (schunk - zeroes);
              } /* end of if format2[i] is false */
              else
              if (format2[i] == TRUE)
              {
                  
                  in = malloc(schunk);
                  
                  if (in == NULL)
                  {
                      PROG_ID;
                      printf("Fatal Error: - insufficient memory.\n");
                      printf("             - %d more bytes required.\n",schunk);
                      exit(0); return 0;
                  }
                  inbase = in;
                  inregs.r[0] = 4;
                  inregs.r[1] = newARFileHandles[i];
                  inregs.r[2] = (int)in;
                  inregs.r[3] = schunk;
                  error = _kernel_swi(OS_GBPB,&inregs,&outregs);
                  if (error != NULL)
                  {
                      PROG_ID;
                      printf("Fatal Error: swi failure (OS_GBPB)\n");
                      printf("             Unable to read sound data into memory.\n");
                      printf("             Allocation of memory was successful.\n");
                      exit(0); 
                  } 
                  zeroes = outregs.r[3];
                  end_of_source_data[i] = FALSE;
                  if (zeroes > 0 && wflg == 0)
                  {
                      end_of_source_data[i] = TRUE;
                  }
                 
                  free(inbase);
                  return(schunk - zeroes);             
              }       
              else
              {
                  printf("Fatal Error - bad format2[i] (got checked earlier)\n");
                  printf(" so should have been caught.\n");
                  exit(0);  return 0;
              }    
            }                                   
     }
  } 

}
/*------------------------------------------------------------------------------*/

void adpcm_coder  (short indata[], unsigned char outdata[], int len,struct adpcm_state *state)
{
    short *inp;			/* Input buffer pointer */
    unsigned char *outp;	/* output buffer pointer */
    int val;			/* Current input sample value */
    int sign;			/* Current adpcm sign bit */
    int delta;			/* Current adpcm output value */
    int diff;			/* Difference between val and valprev */
    int step;			/* Stepsize */
    int valprev;		/* virtual previous output value */
    int vpdiff;			/* Current change to valprev */
    int index;			/* Current step change index */
    int outputbuffer;		/* place to keep previous 4-bit value */
    int bufferstep;		/* toggle between outputbuffer/output */

    outp = outdata;
    inp = indata;

valprev = state->valprev;
index = state->index;


    step = stepsizeTable[index];
    
    bufferstep = 0;

    for ( ; len > 0 ; len-- ) {
	val = *inp++;

	/* Step 1 - compute difference with previous value */
	diff = val - valprev;
	sign = (diff < 0) ? 8 : 0;
	if ( sign ) diff = (-diff);

	/* Step 2 - Divide and clamp */
	/* Note:
	** This code *approximately* computes:
	**    delta = diff*4/step;
	**    vpdiff = (delta+0.5)*step/4;
	** but in shift step bits are dropped. The net result of this is
	** that even if you have fast mul/div hardware you cannot put it to
	** good use since the fixup would be too expensive.
	*/
	delta = 0;
	vpdiff = (step >> 3);
	
	if ( diff >= step ) {
	    delta = 4;
	    diff -= step;
	    vpdiff += step;
	}
	step >>= 1;
	if ( diff >= step  ) {
	    delta |= 2;
	    diff -= step;
	    vpdiff += step;
	}
	step >>= 1;
	if ( diff >= step ) {
	    delta |= 1;
	    vpdiff += step;
	}

	/* Step 3 - Update previous value */
	if ( sign )
	  valprev -= vpdiff;
	else
	  valprev += vpdiff;

	/* Step 4 - Clamp previous value to 16 bits */
	if ( valprev > 32767 )
	  valprev = 32767;
	else if ( valprev < -32768 )
	  valprev = -32768;

	/* Step 5 - Assemble value, update index and step values */
	delta |= sign;
	
	index += indexTable[delta];
	if ( index < 0 ) index = 0;
	if ( index > 88 ) index = 88;
	step = stepsizeTable[index];

	/* Step 6 - Output value */
	if ( !bufferstep ) {
	    outputbuffer = delta;	/* must be in range 0..15 */
	} else {
	    *outp++ = delta << 4 | outputbuffer;
	}
	bufferstep ^= 1;
    }

    /* Output last step, if needed */
    if ( !bufferstep )
      *outp++ = outputbuffer;
    
    state->valprev = valprev;
    state->index = index;
}


void
adpcm_decoder (unsigned char indata[], short outdata[], int len, 
	       struct adpcm_state *state, int chanpos, int nchan)
{
    short *outp;		/* output buffer pointer */
    int valprev;		/* virtual previous output value */
    int index;			/* Current step change index */
    outp = outdata;

    valprev = state->valprev;
    index = state->index;

    for ( ; len > 0 ; len-- ) {
	/* Step 1 - get the delta value */
        int delta = (indata[chanpos>>1] >> ((chanpos & 1) * 4)) & 0xF;  /* Current adpcm output value */
        int step = stepsizeTable[index];
        int vpdiff;
        chanpos += nchan;
	/* Step 2 - Find new index value (for later) */
	index += indexTable[delta];
	if ( index < 0 ) index = 0;
	if ( index > 88 ) index = 88;

	/* Step 4 - Compute difference and new predicted value */
	/*
	** Computes 'vpdiff = (delta+0.5)*step/4', but see comment
	** in adpcm_coder.
	*/
	vpdiff = step >> 3;
	if ( delta & 4 ) vpdiff += step;
	if ( delta & 2 ) vpdiff += step>>1;
	if ( delta & 1 ) vpdiff += step>>2;

	if ( delta & 8 )
	  valprev -= vpdiff;
	else
	  valprev += vpdiff;

	/* Step 5 - clamp output value */
	if ( valprev > 32767 )
	  valprev = 32767;
	else if ( valprev < -32768 )
	  valprev = -32768;

	/* Step 7 - Output value */
	if (outp)
	{
	    *outp = valprev;
	    outp += nchan;
	}
    }

    state->valprev = valprev;
    state->index = index;
}
